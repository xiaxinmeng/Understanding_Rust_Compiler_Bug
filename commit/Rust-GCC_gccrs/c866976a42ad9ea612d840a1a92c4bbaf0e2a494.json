{"sha": "c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg2Njk3NmE0MmFkOWVhNjEyZDg0MGExYTkyYzRiYmFmMGUyYTQ5NA==", "commit": {"author": {"name": "Leehod Baruch", "email": "leehod@il.ibm.com", "date": "2005-02-07T10:07:07Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-02-07T10:07:07Z"}, "message": "invoke.texi (ftree-vectorizer-verbose): New.\n\n        * doc/invoke.texi (ftree-vectorizer-verbose): New.\n        * opts.c (OPT_ftree_vectorizer_verbose_): New case for switch.\n        * common.opt (ftree-vectorizer-verbose): New Flag for the vectorizer\n        was added.\n        * tree.h (vect_set_verbosity_level): New extern function declaration\n        added.\n        * tree-vectorizer.h (verbosity_levels): New enum type.\n        * tree-vectorizer.c (vect_debug_stats): Function removed.\n        (vect_debug_details): Likewise.\n        (vect_verbosity_level): Global variable was defined and initialized.\n        (vect_dump): Global variable definition.\n        (vect_print_dump_info): New function.\n        (vect_set_dump_settings): New function.\n        (vect_set_verbosity_level): New function.\n        (vectorize_loops): Add call to vect_set_dump_settings.\n\n        (slpeel_make_loop_iterate_ntimes): Dump condition was changed.\n        (slpeel_tree_duplicate_loop_to_edge_cfg): Likewise.\n        (slpeel_tree_peel_loop_to_edge): Likewise.\n\n        (vect_analyze_offset_expr): Call to vect_print_dump_info with\n        appropriate verbosity level instead of call to vect_debug_details\n        or vect_debug_stats.\n        (vect_get_base_and_offset):\n        (vect_create_addr_base_for_vector_ref):\n        (get_vectype_for_scalar_type):\n        (vect_create_data_ref_ptr):\n        (vect_init_vector):\n        (vect_get_vec_def_for_operand):\n        (vect_finish_stmt_generation):\n        (vectorizable_assignment):\n        (vectorizable_operation):\n        (vectorizable_store):\n        (vectorizable_load):\n        (vect_transform_stmt):\n        (vect_update_ivs_after_vectorizer):\n        (vect_do_peeling_for_loop_bound):\n        (vect_update_inits_of_drs):\n        (vect_do_peeling_for_alignment):\n        (vect_transform_loop):\n        (vect_is_simple_use):\n        (vect_analyze_operations):\n        (vect_is_simple_iv_evolution):\n        (vect_analyze_scalar_cycles):\n        (vect_analyze_data_ref_dependence):\n        (vect_analyze_data_ref_dependences):\n        (vect_compute_data_ref_alignment):\n        (vect_enhance_data_refs_alignment):\n        (vect_analyze_data_refs_alignment):\n        (vect_analyze_data_ref_access):\n        (vect_analyze_data_ref_accesses):\n        (vect_analyze_pointer_ref_access):\n        (vect_get_memtag_and_dr):\n        (vect_analyze_data_refs):\n        (vect_mark_relevant):\n        (vect_stmt_relevant_p):\n        (vect_mark_stmts_to_be_vectorized):\n        (vect_can_advance_ivs_p):\n        (vect_get_loop_niters):\n        (vect_analyze_loop_form):\n        (vect_analyze_loop):\n        (vectorize_loops): Likewise.\n\n        (vect_do_peeling_for_loop_bound): Dump format slightly changed.\n        (vect_update_inits_of_drs):\n        (vect_do_peeling_for_alignment):\n        (vect_transform_loop):\n        (vect_analyze_operations):\n        (vect_analyze_scalar_cycles):\n        (vect_analyze_data_ref_dependences):\n        (vect_analyze_data_refs_alignment):\n        (vect_analyze_data_ref_accesses):\n        (vect_analyze_data_refs):\n        (vect_mark_stmts_to_be_vectorized):\n        (vect_get_loop_niters):\n        (vect_analyze_loop_form):\n        (vect_analyze_loop): Likewise.\n        (vect_mark_stmts_to_be_vectorized): Add call to print_generic_expr.\n\nCo-Authored-By: Dorit Naishlos <dorit@il.ibm.com>\n\nFrom-SVN: r94697", "tree": {"sha": "0d1e56e99e264d4126f76ddd24e7eb3bc11febf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d1e56e99e264d4126f76ddd24e7eb3bc11febf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/comments", "author": null, "committer": null, "parents": [{"sha": "88ab13d651e6e056978db22b331268e47679f84b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ab13d651e6e056978db22b331268e47679f84b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ab13d651e6e056978db22b331268e47679f84b"}], "stats": {"total": 1085, "additions": 634, "deletions": 451}, "files": [{"sha": "1418ba196e42e233c9e7ec8fbbd72024519b11c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -1,3 +1,85 @@\n+2005-02-07  Leehod Baruch  <leehod@il.ibm.com>\n+\t    Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* doc/invoke.texi (ftree-vectorizer-verbose): New.\n+\t* opts.c (OPT_ftree_vectorizer_verbose_): New case for switch.\n+\t* common.opt (ftree-vectorizer-verbose): New Flag for the vectorizer\n+\twas added.\n+\t* tree.h (vect_set_verbosity_level): New extern function declaration\n+\tadded.\n+\t* tree-vectorizer.h (verbosity_levels): New enum type.\n+\t* tree-vectorizer.c (vect_debug_stats): Function removed.\n+\t(vect_debug_details): Likewise.\n+\t(vect_verbosity_level): Global variable was defined and initialized.\n+\t(vect_dump): Global variable definition.\n+\t(vect_print_dump_info): New function.\n+\t(vect_set_dump_settings): New function.\n+\t(vect_set_verbosity_level): New function.\n+\t(vectorize_loops): Add call to vect_set_dump_settings.\n+\n+\t(slpeel_make_loop_iterate_ntimes): Dump condition was changed.\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): Likewise.\n+\t(slpeel_tree_peel_loop_to_edge): Likewise.\n+\n+\t(vect_analyze_offset_expr): Call to vect_print_dump_info with\n+\tappropriate verbosity level instead of call to vect_debug_details \n+\tor vect_debug_stats. \n+\t(vect_get_base_and_offset):\n+\t(vect_create_addr_base_for_vector_ref):\n+\t(get_vectype_for_scalar_type):\n+\t(vect_create_data_ref_ptr):\n+\t(vect_init_vector):\n+\t(vect_get_vec_def_for_operand):\n+\t(vect_finish_stmt_generation):\n+\t(vectorizable_assignment):\n+\t(vectorizable_operation):\n+\t(vectorizable_store):\n+\t(vectorizable_load):\n+\t(vect_transform_stmt):\n+\t(vect_update_ivs_after_vectorizer):\n+\t(vect_do_peeling_for_loop_bound):\n+\t(vect_update_inits_of_drs):\n+\t(vect_do_peeling_for_alignment):\n+\t(vect_transform_loop):\n+\t(vect_is_simple_use):\n+\t(vect_analyze_operations):\n+\t(vect_is_simple_iv_evolution):\n+\t(vect_analyze_scalar_cycles):\n+\t(vect_analyze_data_ref_dependence):\n+\t(vect_analyze_data_ref_dependences):\n+\t(vect_compute_data_ref_alignment):\n+\t(vect_enhance_data_refs_alignment):\n+\t(vect_analyze_data_refs_alignment):\n+\t(vect_analyze_data_ref_access):\n+\t(vect_analyze_data_ref_accesses):\n+\t(vect_analyze_pointer_ref_access):\n+\t(vect_get_memtag_and_dr):\n+\t(vect_analyze_data_refs):\n+\t(vect_mark_relevant):\n+\t(vect_stmt_relevant_p):\n+\t(vect_mark_stmts_to_be_vectorized):\n+\t(vect_can_advance_ivs_p):\n+\t(vect_get_loop_niters):\n+\t(vect_analyze_loop_form):\n+\t(vect_analyze_loop):\n+\t(vectorize_loops): Likewise.\n+\n+\t(vect_do_peeling_for_loop_bound): Dump format slightly changed.\n+\t(vect_update_inits_of_drs):\n+\t(vect_do_peeling_for_alignment):\n+\t(vect_transform_loop):\n+\t(vect_analyze_operations):\n+\t(vect_analyze_scalar_cycles):\n+\t(vect_analyze_data_ref_dependences):\n+\t(vect_analyze_data_refs_alignment):\n+\t(vect_analyze_data_ref_accesses):\n+\t(vect_analyze_data_refs):\n+\t(vect_mark_stmts_to_be_vectorized):\n+\t(vect_get_loop_niters):\n+\t(vect_analyze_loop_form):\n+\t(vect_analyze_loop): Likewise. \n+\t(vect_mark_stmts_to_be_vectorized): Add call to print_generic_expr.\n+\n 2005-02-07  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR bootstrap/19796"}, {"sha": "10d157ede7d3b630750e7709d5094daf2687e004", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -916,6 +916,10 @@ ftree-vectorize\n Common Report Var(flag_tree_vectorize)\n Enable loop vectorization on trees\n \n+ftree-vectorizer-verbose=\n+Common RejectNegative Joined\n+-ftree-vectorizer-verbose=<number>   Set the verbosity level of the vectorizer\n+\n ; -fverbose-asm causes extra commentary information to be produced in\n ; the generated assembly code (to make it more readable).  This option\n ; is generally only of use to those who actually need to read the"}, {"sha": "d440ceff5e77b838183f04a9eb6f8693c7d0944f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -266,6 +266,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-nrv -fdump-tree-vect @gol\n -fdump-tree-sra@r{[}-@var{n}@r{]} @gol\n -fdump-tree-fre@r{[}-@var{n}@r{]} @gol\n+-ftree-vectorizer-verbose=@var{n} @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n -feliminate-unused-debug-symbols -fmem-report -fprofile-arcs -ftree-based-profiling @gol\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n@@ -3882,6 +3883,13 @@ made by appending @file{.vect} to the source file name.\n Enable all the available tree dumps with the flags provided in this option.\n @end table\n \n+@item -ftree-vectorizer-verbose=@var{n}\n+@opindex ftree-vectorizer-verbose\n+This option controls the amount of debugging output the vectorizer prints.\n+This information is written to standard error, unless @option{-fdump-tree-all}\n+or @option{-fdump-tree-vect} is specified, in which case it is output to the\n+usual dump listing file, @file{.vect}.\n+\n @item -frandom-seed=@var{string}\n @opindex frandom-string\n This option provides a seed that GCC uses when it would otherwise use"}, {"sha": "8af263a8498c9bd516163e1af9ca83b4b90302c2", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -945,6 +945,10 @@ common_handle_option (size_t scode, const char *arg, int value)\n       stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (arg));\n       break;\n \n+    case OPT_ftree_vectorizer_verbose_:\n+      vect_set_verbosity_level (arg);\n+      break;\n+\n     case OPT_ftls_model_:\n       if (!strcmp (arg, \"global-dynamic\"))\n \tflag_tls_default = TLS_MODEL_GLOBAL_DYNAMIC;"}, {"sha": "f4fac6f1a6eda2ccbd6fd1cbbe04d913d6c8bb7e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -1,3 +1,8 @@\n+2005-02-07  Leehod Baruch  <leehod@il.ibm.com> \n+\t    Dorit Naishlos  <dorit@il.ibm.com>\n+\t\n+\t* testsuite/gcc.dg/vect/vect.exp: Add -ftree-vectorizer-verbose=3.\n+\n 2005-02-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.c-torture/compile/20050206-1.c: New test."}, {"sha": "3f52ed68e19831d32b01d1cb1bfb97f93eb48bb0", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -23,7 +23,8 @@ load_lib gcc-dg.exp\n set DEFAULT_VECTCFLAGS \"\"\n \n # These flags are used for all targets.\n-lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fdump-tree-vect-stats\"\n+lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \\\n+  \"-ftree-vectorizer-verbose=3\" \"-fdump-tree-vect-stats\"\n \n # If the target system supports vector instructions, the default action\n # for a test is 'run', otherwise it's 'compile'.  Save current default."}, {"sha": "b2c0e0a9bbd6926118e04f7464b5825b641af41d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 513, "deletions": 450, "changes": 963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -271,9 +271,18 @@ stmt_vec_info new_stmt_vec_info (tree, loop_vec_info);\n   Vectorization Debug Information.\n  *************************************************************************/\n \n+/* vect_verbosity_level set to invalid verbosity level to mark that it's\n+   uninitialized.  */\n+enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n+\n+/* vect_dump will be set to stderr or dump_file if exist.  */\n+FILE *vect_dump;\n+\n /* Utilities for output formatting. */\n-static bool vect_debug_stats (LOC);\n-static bool vect_debug_details (LOC);\n+static bool vect_print_dump_info (enum verbosity_levels, LOC);\n+static void vect_set_dump_settings (void);\n+void vect_set_verbosity_level (const char *);\n+\n \n \f\n /*************************************************************************\n@@ -708,8 +717,13 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   bsi_remove (&loop_cond_bsi);\n \n   loop_loc = find_loop_location (loop);\n-  if (vect_debug_details (loop_loc))\n-    print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      if (loop_loc != UNKNOWN_LOC)\n+        fprintf (dump_file, \"\\nloop at %s:%d: \",\n+                 LOC_FILE (loop_loc), LOC_LINE (loop_loc));\n+      print_generic_expr (dump_file, cond_stmt, TDF_SLIM);\n+    }\n \n   loop->nb_iterations = niters;\n }\n@@ -1003,9 +1017,13 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n     {\n       loop_loc = find_loop_location (loop);\n-      if (vect_debug_stats (loop_loc)\n-          || vect_debug_details (loop_loc))\n-        fprintf (dump_file, \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        {\n+          if (loop_loc != UNKNOWN_LOC)\n+            fprintf (dump_file, \"\\n%s:%d: note: \",\n+                     LOC_FILE (loop_loc), LOC_LINE (loop_loc));\n+          fprintf (dump_file, \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n+        }\n       return NULL;\n     }\n   \n@@ -1160,6 +1178,83 @@ find_loop_location (struct loop *loop)\n }\n \n \n+/*************************************************************************\n+  Vectorization Debug Information.\n+ *************************************************************************/\n+\n+/* Function vect_set_verbosity_level.\n+\n+   Called from toplev.c upon detection of the\n+   -ftree-vectorizer-verbose=N option.  */\n+\n+void\n+vect_set_verbosity_level (const char *val)\n+{\n+   unsigned int vl;\n+\n+   vl = atoi (val);\n+   if (vl < MAX_VERBOSITY_LEVEL)\n+     vect_verbosity_level = vl;\n+   else\n+     vect_verbosity_level = MAX_VERBOSITY_LEVEL - 1;\n+}\n+\n+\n+/* Function vect_set_dump_settings.\n+\n+   Fix the verbosity level of the vectorizer if the\n+   requested level was not set explicitly using the flag\n+   -ftree-vectorizer-verbose=N.\n+   Decide where to print the debugging information (dump_file/stderr).\n+   If the user defined the verbosity level, but there is no dump file,\n+   print to stderr, otherwise print to the dump file.  */\n+\n+static void\n+vect_set_dump_settings (void)\n+{\n+  vect_dump = dump_file;\n+\n+  /* Check if the verbosity level was defined by the user:  */\n+  if (vect_verbosity_level != MAX_VERBOSITY_LEVEL)\n+    {\n+      /* If there is no dump file, print to stderr.  */\n+      if (!dump_file)\n+        vect_dump = stderr;\n+      return;\n+    }\n+\n+  /* User didn't specify verbosity level:  */\n+  if (dump_flags & TDF_DETAILS)\n+    vect_verbosity_level = REPORT_DETAILS;\n+  else if (dump_flags & TDF_STATS)\n+    vect_verbosity_level = REPORT_UNVECTORIZED_LOOPS;\n+  else\n+    vect_verbosity_level = REPORT_NONE;\n+}\n+\n+\n+/* Function debug_loop_details.\n+\n+   For vectorization debug dumps.  */\n+\n+static bool\n+vect_print_dump_info (enum verbosity_levels vl, LOC loc)\n+{\n+  if (vl > vect_verbosity_level)\n+    return false;\n+\n+  if (loc == UNKNOWN_LOC)\n+    fprintf (vect_dump, \"\\n%s:%d: note: \",\n+\t\t DECL_SOURCE_FILE (current_function_decl),\n+\t\t DECL_SOURCE_LINE (current_function_decl));\n+  else\n+    fprintf (vect_dump, \"\\n%s:%d: note: \", LOC_FILE (loc), LOC_LINE (loc));\n+\n+\n+  return true;\n+}\n+\n+\n \f\n /* Here the proper Vectorizer starts.  */\n \n@@ -1288,46 +1383,6 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function debug_loop_stats.\n-\n-   For vectorization statistics dumps.  */\n-\n-static bool\n-vect_debug_stats (LOC loc)\n-{\n-  if (!dump_file || !(dump_flags & TDF_STATS))\n-    return false;\n-\n-  if (loc == UNKNOWN_LOC)\n-    fprintf (dump_file, \"\\n\");\n-  else\n-    fprintf (dump_file, \"\\nloop at %s:%d: \",\n-             LOC_FILE (loc), LOC_LINE (loc));\n-\n-  return true;\n-}\n-\n-\n-/* Function debug_loop_details.\n-\n-   For vectorization debug dumps.  */\n-\n-static bool\n-vect_debug_details (LOC loc)\n-{\n-  if (!dump_file || !(dump_flags & TDF_DETAILS))\n-    return false;\n-   \n-  if (loc == UNKNOWN_LOC)\n-    fprintf (dump_file, \"\\n\");\n-  else\n-    fprintf (dump_file, \"\\nloop at %s:%d: \",\n-             LOC_FILE (loc), LOC_LINE (loc));\n-    \n-  return true;\n-}\n-\n-\n /* Function vect_get_ptr_offset\n \n    Compute the OFFSET modulo vector-type alignment of pointer REF in bits.  */\n@@ -1477,10 +1532,10 @@ vect_analyze_offset_expr (tree expr,\n   if (!BINARY_CLASS_P (expr))\n     {\n       /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         {\n-\t  fprintf (dump_file, \"Not binary expression \");\n-          print_generic_expr (dump_file, expr, TDF_SLIM);\n+\t  fprintf (vect_dump, \"Not binary expression \");\n+          print_generic_expr (vect_dump, expr, TDF_SLIM);\n \t}\n       return false;\n     }\n@@ -1722,8 +1777,8 @@ vect_get_base_and_offset (struct data_reference *dr,\n       /* Check that there is no remainder in bits.  */\n       if (pbitpos%BITS_PER_UNIT)\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"bit offset alignment.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"bit offset alignment.\");\n \t  return NULL_TREE;\n \t}\n       this_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, \n@@ -1751,15 +1806,15 @@ vect_get_base_and_offset (struct data_reference *dr,\n \n       *initial_offset = size_binop (PLUS_EXPR, *initial_offset, this_offset);\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         {\n-          print_generic_expr (dump_file, expr, TDF_SLIM);\n-          fprintf (dump_file, \"\\n --> total offset for ref: \");\n-          print_generic_expr (dump_file, *initial_offset, TDF_SLIM);\n-          fprintf (dump_file, \"\\n --> total misalign for ref: \");\n-          print_generic_expr (dump_file, *misalign, TDF_SLIM);\n-          fprintf (dump_file, \"\\n --> total step for ref: \");\n-          print_generic_expr (dump_file, *step, TDF_SLIM);\n+          print_generic_expr (vect_dump, expr, TDF_SLIM);\n+          fprintf (vect_dump, \"\\n --> total offset for ref: \");\n+          print_generic_expr (vect_dump, *initial_offset, TDF_SLIM);\n+          fprintf (vect_dump, \"\\n --> total misalign for ref: \");\n+          print_generic_expr (vect_dump, *misalign, TDF_SLIM);\n+          fprintf (vect_dump, \"\\n --> total step for ref: \");\n+          print_generic_expr (vect_dump, *step, TDF_SLIM);\n         }\n     }    \n   return base;\n@@ -1972,11 +2027,10 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n   append_to_statement_list_force (vec_stmt, new_stmt_list);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"created \");\n-      print_generic_expr (dump_file, vec_stmt, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n+      fprintf (vect_dump, \"created \");\n+      print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n     }\n   return new_temp;\n }\n@@ -2003,28 +2057,28 @@ get_vectype_for_scalar_type (tree scalar_type)\n   nunits = UNITS_PER_SIMD_WORD / nbytes;\n \n   vectype = build_vector_type (scalar_type, nunits);\n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"get vectype with %d units of type \", nunits);\n-      print_generic_expr (dump_file, scalar_type, TDF_SLIM);\n+      fprintf (vect_dump, \"get vectype with %d units of type \", nunits);\n+      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n     }\n \n   if (!vectype)\n     return NULL_TREE;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"vectype: \");\n-      print_generic_expr (dump_file, vectype, TDF_SLIM);\n+      fprintf (vect_dump, \"vectype: \");\n+      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n     }\n \n   if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n     {\n       /* TODO: tree-complex.c sometimes can parallelize operations\n          on generic vectors.  We can vectorize the loop in that case,\n          but then we should re-run the lowering pass.  */\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"mode not supported by target.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"mode not supported by target.\");\n       return NULL_TREE;\n     }\n \n@@ -2127,20 +2181,20 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree type, tmp, size;\n \n   base_name = unshare_expr (DR_BASE_NAME (dr));\n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n       tree data_ref_base = base_name;\n-      fprintf (dump_file, \"create array_ref of type: \");\n-      print_generic_expr (dump_file, vectype, TDF_SLIM);\n+      fprintf (vect_dump, \"create array_ref of type: \");\n+      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n       if (TREE_CODE (data_ref_base) == VAR_DECL)\n-        fprintf (dump_file, \"\\nvectorizing a one dimensional array ref: \");\n+        fprintf (vect_dump, \"  vectorizing a one dimensional array ref: \");\n       else if (TREE_CODE (data_ref_base) == ARRAY_REF)\n-        fprintf (dump_file, \"\\nvectorizing a multidimensional array ref: \");\n+        fprintf (vect_dump, \"  vectorizing a multidimensional array ref: \");\n       else if (TREE_CODE (data_ref_base) == COMPONENT_REF)\n-        fprintf (dump_file, \"\\nvectorizing a record based array ref: \");\n+        fprintf (vect_dump, \"  vectorizing a record based array ref: \");\n       else if (TREE_CODE (data_ref_base) == SSA_NAME)\n-        fprintf (dump_file, \"\\nvectorizing a pointer ref: \");\n-      print_generic_expr (dump_file, base_name, TDF_SLIM);\n+        fprintf (vect_dump, \"  vectorizing a pointer ref: \");\n+      print_generic_expr (vect_dump, base_name, TDF_SLIM);\n     }\n \n   /** (1) Create the new vector-pointer variable:  **/\n@@ -2294,10 +2348,10 @@ vect_init_vector (tree stmt, tree vector_var)\n   new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n   gcc_assert (!new_bb);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"created new init_stmt: \");\n-      print_generic_expr (dump_file, init_stmt, TDF_SLIM);\n+      fprintf (vect_dump, \"created new init_stmt: \");\n+      print_generic_expr (vect_dump, init_stmt, TDF_SLIM);\n     }\n \n   vec_oprnd = TREE_OPERAND (init_stmt, 0);\n@@ -2334,10 +2388,10 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   tree def;\n   int i;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"vect_get_vec_def_for_operand: \");\n-      print_generic_expr (dump_file, op, TDF_SLIM);\n+      fprintf (vect_dump, \"vect_get_vec_def_for_operand: \");\n+      print_generic_expr (vect_dump, op, TDF_SLIM);\n     }\n \n   /** ===> Case 1: operand is a constant.  **/\n@@ -2349,8 +2403,8 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       tree vec_cst;\n \n       /* Build a tree with vector elements.  */\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"Create vector_cst. nunits = %d\", nunits);\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n \n       for (i = nunits - 1; i >= 0; --i)\n         {\n@@ -2367,10 +2421,10 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   def_stmt = SSA_NAME_DEF_STMT (op);\n   def_stmt_info = vinfo_for_stmt (def_stmt);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"vect_get_vec_def_for_operand: def_stmt: \");\n-      print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n+      fprintf (vect_dump, \"vect_get_vec_def_for_operand: def_stmt: \");\n+      print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n     }\n \n \n@@ -2393,8 +2447,8 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n   bb = bb_for_stmt (def_stmt);\n   if (TREE_CODE (def_stmt) == PHI_NODE && flow_bb_inside_loop_p (loop, bb))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"reduction/induction - unsupported.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"reduction/induction - unsupported.\");\n       internal_error (\"no support for reduction/induction\"); /* FORNOW */\n     }\n \n@@ -2416,18 +2470,19 @@ vect_get_vec_def_for_operand (tree op, tree stmt)\n       def = op;\n       break;\n     default:\n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-          fprintf (dump_file, \"unsupported defining stmt: \");\n-\t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n+          fprintf (vect_dump, \"unsupported defining stmt: \");\n+\t  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n \t}\n       internal_error (\"unsupported defining stmt\");\n     }\n \n-  /* Build a tree with vector elements. Create 'vec_inv = {inv,inv,..,inv}'  */\n+  /* Build a tree with vector elements.\n+     Create 'vec_inv = {inv,inv,..,inv}'  */\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"Create vector_inv.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"Create vector_inv.\");\n \n   for (i = nunits - 1; i >= 0; --i)\n     {\n@@ -2448,10 +2503,10 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n {\n   bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"add new stmt: \");\n-      print_generic_expr (dump_file, vec_stmt, TDF_SLIM);\n+      fprintf (vect_dump, \"add new stmt: \");\n+      print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n     }\n \n #ifdef ENABLE_CHECKING\n@@ -2498,8 +2553,8 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = TREE_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, NULL))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"use not simple.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n \n@@ -2510,8 +2565,8 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     }\n \n   /** Transform.  **/\n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"transform assignment.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"transform assignment.\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -2571,8 +2626,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != unary_op && op_type != binary_op)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"num. args = %d (not unary/binary op).\", op_type);\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"num. args = %d (not unary/binary op).\", op_type);\n       return false;\n     }\n \n@@ -2581,24 +2636,24 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       op = TREE_OPERAND (operation, i);\n       if (!vect_is_simple_use (op, loop_vinfo, NULL))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"use not simple.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"use not simple.\");\n \t  return false;\n \t}\t\n     } \n \n   /* Supportable by target?  */\n   if (!optab)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"no optab.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"no optab.\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n   if (optab->handlers[(int) vec_mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"op not supported by target.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"op not supported by target.\");\n       return false;\n     }\n \n@@ -2610,8 +2665,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"transform binary/unary operation.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"transform binary/unary operation.\");\n \n   /* Handle def.  */\n   scalar_dest = TREE_OPERAND (stmt, 0);\n@@ -2679,8 +2734,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = TREE_OPERAND (stmt, 1);\n   if (!vect_is_simple_use (op, loop_vinfo, NULL))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"use not simple.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n \n@@ -2702,8 +2757,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"transform store\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"transform store\");\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n   gcc_assert (alignment_support_cheme);\n@@ -2777,8 +2832,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     (e.g. - data copies).  */\n   if (mov_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"Aligned load, but unsupported type.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"Aligned load, but unsupported type.\");\n       return false;\n     }\n \n@@ -2790,8 +2845,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /** Transform.  **/\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"transform load.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"transform load.\");\n \n   alignment_support_cheme = vect_supportable_dr_alignment (dr);\n   gcc_assert (alignment_support_cheme);\n@@ -2997,8 +3052,8 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n       is_store = true;\n       break;\n     default:\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"stmt not supported.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"stmt not supported.\");\n       gcc_unreachable ();\n     }\n \n@@ -3170,8 +3225,8 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       /* Skip virtual phi's.  */\n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"virtual phi. skip.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n@@ -3234,8 +3289,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   int loop_num;\n #endif\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_transtorm_for_unknown_loop_bound>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_transtorm_for_unknown_loop_bound ===\");\n \n   /* Generate the following variables on the preheader of original loop:\n \t \n@@ -3403,8 +3458,8 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n<<vect_update_inits_of_dr>>\\n\");\n+  if (vect_dump && (dump_flags & TDF_DETAILS))\n+    fprintf (vect_dump, \"=== vect_update_inits_of_dr ===\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n@@ -3436,8 +3491,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   tree n_iters;\n   struct loop *new_loop;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_do_peeling_for_alignment>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_do_peeling_for_alignment ===\");\n \n   ni_name = vect_build_loop_niters (loop_vinfo);\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name);\n@@ -3484,8 +3539,8 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   tree ratio = NULL;\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vec_transform_loop>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n   \n   /* Peel the loop if there are data refs with unknown alignment.\n@@ -3533,10 +3588,10 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t  stmt_vec_info stmt_info;\n \t  bool is_store;\n \n-\t  if (vect_debug_details (UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      fprintf (dump_file, \"------>vectorizing statement: \");\n-\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t      fprintf (vect_dump, \"------>vectorizing statement: \");\n+\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t    }\t\n \t  stmt_info = vinfo_for_stmt (stmt);\n \t  gcc_assert (stmt_info);\n@@ -3553,8 +3608,8 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t\t == vectorization_factor);\n #endif\n \t  /* -------- vectorize statement ------------ */\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"transform statement.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"transform statement.\");\n \n \t  is_store = vect_transform_stmt (stmt, &si);\n \t  if (is_store)\n@@ -3573,10 +3628,8 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \n   slpeel_make_loop_iterate_ntimes (loop, ratio);\n \n-  if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-    fprintf (dump_file,\"Success! loop vectorized.\");\n-  if (vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-    fprintf (dump_file, \"LOOP VECTORIZED.\");\n+  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS, LOOP_LOC (loop_vinfo)))\n+    fprintf (vect_dump, \"LOOP VECTORIZED.\");\n }\n \n \n@@ -3612,8 +3665,8 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n   def_stmt = SSA_NAME_DEF_STMT (operand);\n   if (def_stmt == NULL_TREE )\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"no def_stmt.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"no def_stmt.\");\n       return false;\n     }\n \n@@ -3624,10 +3677,10 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n       tree arg = TREE_OPERAND (def_stmt, 0);\n       if (TREE_CODE (arg) == INTEGER_CST || TREE_CODE (arg) == REAL_CST)\n \treturn true;\n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-\t  fprintf (dump_file, \"Unexpected empty stmt: \");\n-\t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n+\t  fprintf (vect_dump, \"Unexpected empty stmt: \");\n+\t  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n \t}\n       return false;  \n     }\n@@ -3637,8 +3690,8 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def)\n   bb = bb_for_stmt (def_stmt);\n   if (TREE_CODE (def_stmt) == PHI_NODE && flow_bb_inside_loop_p (loop, bb))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"reduction/induction - unsupported.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"reduction/induction - unsupported.\");\n       return false; /* FORNOW: not supported yet.  */\n     }\n \n@@ -3671,8 +3724,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   bool ok;\n   tree scalar_type;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_analyze_operations>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n \n   for (i = 0; i < nbbs; i++)\n     {\n@@ -3685,10 +3738,10 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \t  tree vectype;\n \n-\t  if (vect_debug_details (UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      fprintf (dump_file, \"==> examining statement: \");\n-\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t      fprintf (vect_dump, \"==> examining statement: \");\n+\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t    }\n \n \t  gcc_assert (stmt_info);\n@@ -3702,18 +3755,18 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n \t    {\n-\t      if (vect_debug_details (UNKNOWN_LOC))\n-\t        fprintf (dump_file, \"irrelevant.\");\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t        fprintf (vect_dump, \"irrelevant.\");\n \t      continue;\n \t    }\n \n \t  if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (stmt))))\n \t    {\n-\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-                  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                         LOOP_LOC (loop_vinfo)))\n \t\t{\n-                  fprintf (dump_file, \"not vectorized: vector stmt in loop:\");\n-\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+                  fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n@@ -3725,28 +3778,29 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  else\n \t    scalar_type = TREE_TYPE (stmt);\n \n-\t  if (vect_debug_details (UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      fprintf (dump_file, \"get vectype for scalar type:  \");\n-\t      print_generic_expr (dump_file, scalar_type, TDF_SLIM);\n+\t      fprintf (vect_dump, \"get vectype for scalar type:  \");\n+\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n \t    }\n \n \t  vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vectype)\n \t    {\n-\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-                  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                         LOOP_LOC (loop_vinfo)))\n \t\t{\n-                  fprintf (dump_file, \"not vectorized: unsupported data-type \");\n-\t\t  print_generic_expr (dump_file, scalar_type, TDF_SLIM);\n+                  fprintf (vect_dump,\n+                           \"not vectorized: unsupported data-type \");\n+\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n \n-\t  if (vect_debug_details (UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      fprintf (dump_file, \"vectype: \");\n-\t      print_generic_expr (dump_file, vectype, TDF_SLIM);\n+\t      fprintf (vect_dump, \"vectype: \");\n+\t      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n \t    }\n \t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n@@ -3757,28 +3811,28 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t  if (!ok)\n \t    {\n-\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-                  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                         LOOP_LOC (loop_vinfo)))\n \t\t{\n-                  fprintf (dump_file, \"not vectorized: stmt not supported: \");\n-\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+                  fprintf (vect_dump, \"not vectorized: stmt not supported: \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n \n \t  nunits = GET_MODE_NUNITS (TYPE_MODE (vectype));\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"nunits = %d\", nunits);\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"nunits = %d\", nunits);\n \n \t  if (vectorization_factor)\n \t    {\n \t      /* FORNOW: don't allow mixed units.\n \t         This restriction will be relaxed in the future.  */\n \t      if (nunits != vectorization_factor)\n \t\t{\n-\t          if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-                      || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\t\t    fprintf (dump_file, \"not vectorized: mixed data-types\");\n+\t          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                             LOOP_LOC (loop_vinfo)))\n+\t\t    fprintf (vect_dump, \"not vectorized: mixed data-types\");\n \t\t  return false;\n \t\t}\n \t    }\n@@ -3796,46 +3850,47 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n   if (vectorization_factor <= 1)\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-          || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-        fprintf (dump_file, \"not vectorized: unsupported data-type\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                 LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"not vectorized: unsupported data-type\");\n       return false;\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file,\n+      && vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump,\n         \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n         vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor)\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-          || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"not vectorized: iteration count too small.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                 LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"not vectorized: iteration count too small.\");\n       return false;\n     }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-          || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-        fprintf (dump_file, \"epilog loop required.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"epilog loop required.\");\n       if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n-          if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-            fprintf (dump_file, \"not vectorized: can't create epilog loop 1.\");\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                     LOOP_LOC (loop_vinfo)))\n+            fprintf (vect_dump,\n+                     \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n       if (!slpeel_can_duplicate_loop_p (loop, loop->exit_edges[0]))\n         {\n-          if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-            fprintf (dump_file, \"not vectorized: can't create epilog loop 2.\");\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                     LOOP_LOC (loop_vinfo)))\n+            fprintf (vect_dump,\n+                     \"not vectorized: can't create epilog loop 2.\");\n           return false;\n         }\n     }\n@@ -3914,31 +3969,32 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n     return false;\n   \n   step_expr = evolution_part;\n-  init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, loop_nb));\n+  init_expr = unshare_expr (initial_condition_in_loop_num (access_fn,\n+                                                           loop_nb));\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"step: \");\n-      print_generic_expr (dump_file, step_expr, TDF_SLIM);\n-      fprintf (dump_file, \",  init: \");\n-      print_generic_expr (dump_file, init_expr, TDF_SLIM);\n+      fprintf (vect_dump, \"step: \");\n+      print_generic_expr (vect_dump, step_expr, TDF_SLIM);\n+      fprintf (vect_dump, \",  init: \");\n+      print_generic_expr (vect_dump, init_expr, TDF_SLIM);\n     }\n \n   *init = init_expr;\n   *step = step_expr;\n \n   if (TREE_CODE (step_expr) != INTEGER_CST)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"step unknown.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"step unknown.\");\n       return false;\n     }\n \n   if (strict)\n     if (!integer_onep (step_expr))\n       {\n-        if (vect_debug_details (UNKNOWN_LOC))\n-\t  print_generic_expr (dump_file, step_expr, TDF_SLIM);\n+        if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t  print_generic_expr (vect_dump, step_expr, TDF_SLIM);\n         return false;\n       }\n \n@@ -3990,26 +4046,26 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n   basic_block bb = loop->header;\n   tree dummy;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_analyze_scalar_cycles>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_analyze_scalar_cycles ===\");\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree access_fn = NULL;\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-          fprintf (dump_file, \"Analyze phi: \");\n-          print_generic_expr (dump_file, phi, TDF_SLIM);\n+          fprintf (vect_dump, \"Analyze phi: \");\n+          print_generic_expr (vect_dump, phi, TDF_SLIM);\n \t}\n \n       /* Skip virtual phi's. The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n \n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"virtual phi. skip.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n@@ -4030,24 +4086,25 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: unsupported scalar cycle.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: unsupported scalar cycle.\");\n \t  return false;\n \t}\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n         {\n-           fprintf (dump_file, \"Access function of PHI: \");\n-           print_generic_expr (dump_file, access_fn, TDF_SLIM);\n+           fprintf (vect_dump, \"Access function of PHI: \");\n+           print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n         }\n \n       if (!vect_is_simple_iv_evolution (loop->num, access_fn, &dummy, \n \t\t\t\t\t&dummy, false))\n \t{\n-\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-              || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: unsupported scalar cycle.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: unsupported scalar cycle.\");\n \t  return false;\n \t}\n     }\n@@ -4071,14 +4128,14 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   \n   if (!array_base_name_differ_p (dra, drb, &differ_p))\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))   \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n         {\n-          fprintf (dump_file,\n+          fprintf (vect_dump,\n                 \"not vectorized: can't determine dependence between: \");\n-          print_generic_expr (dump_file, DR_REF (dra), TDF_SLIM);\n-          fprintf (dump_file, \" and \");\n-          print_generic_expr (dump_file, DR_REF (drb), TDF_SLIM);\n+          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+          fprintf (vect_dump, \" and \");\n+          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n       return true;\n     }\n@@ -4092,14 +4149,14 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return false;\n   \n-  if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-      || vect_debug_details (LOOP_LOC (loop_vinfo)))\n+  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t    LOOP_LOC (loop_vinfo)))\n     {\n-      fprintf (dump_file,\n+      fprintf (vect_dump,\n \t\"not vectorized: possible dependence between data-refs \");\n-      print_generic_expr (dump_file, DR_REF (dra), TDF_SLIM);\n-      fprintf (dump_file, \" and \");\n-      print_generic_expr (dump_file, DR_REF (drb), TDF_SLIM);\n+      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+      fprintf (vect_dump, \" and \");\n+      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n     }\n \n   return true;\n@@ -4123,11 +4180,11 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \n   /* Examine store-store (output) dependences.  */\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_analyze_dependences>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"compare all store-store pairs.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"compare all store-store pairs.\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_refs); i++)\n     {\n@@ -4144,8 +4201,8 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n \n   /* Examine load-store (true/anti) dependences.  */\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"compare all load-store pairs.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"compare all load-store pairs.\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_refs); i++)\n     {\n@@ -4186,8 +4243,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   bool base_aligned_p;\n   tree misalign;\n    \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"vect_compute_data_ref_alignment:\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"vect_compute_data_ref_alignment:\");\n \n   /* Initialize misalignment to unknown.  */\n   DR_MISALIGNMENT (dr) = -1;\n@@ -4199,10 +4256,10 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   if (!misalign)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC)) \n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC)) \n \t{\n-\t  fprintf (dump_file, \"Unknown alignment for access: \");\n-\t  print_generic_expr (dump_file, base, TDF_SLIM);\n+\t  fprintf (vect_dump, \"Unknown alignment for access: \");\n+\t  print_generic_expr (vect_dump, base, TDF_SLIM);\n \t}\n       return true;\n     }\n@@ -4211,19 +4268,19 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n     {\n       if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      fprintf (dump_file, \"can't force alignment of ref: \");\n-\t      print_generic_expr (dump_file, ref, TDF_SLIM);\n+\t      fprintf (vect_dump, \"can't force alignment of ref: \");\n+\t      print_generic_expr (vect_dump, ref, TDF_SLIM);\n \t    }\n \t  return true;\n \t}\n       \n       /* Force the alignment of the decl.\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"force alignment\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"force alignment\");\n       DECL_ALIGN (base) = TYPE_ALIGN (vectype);\n       DECL_USER_ALIGN (base) = 1;\n     }\n@@ -4241,15 +4298,15 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if (tree_int_cst_sgn (misalign) < 0)\n     {\n       /* Negative misalignment value.  */\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"unexpected misalign value\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"unexpected misalign value\");\n       return false;\n     }\n \n   DR_MISALIGNMENT (dr) = tree_low_cst (misalign, 1);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"misalign = %d\", DR_MISALIGNMENT (dr));\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"misalign = %d bytes\", DR_MISALIGNMENT (dr));\n \n   return true;\n }\n@@ -4418,13 +4475,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (!LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"Peeling for alignment will not be applied.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"Peeling for alignment will not be applied.\");\n       return;\n     }\n   else\n-    if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-      fprintf (dump_file, \"Peeling for alignment will be applied.\");\n+    if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+      fprintf (vect_dump, \"Peeling for alignment will be applied.\");\n \n \n   /* (1.2) Update the alignment info according to the peeling factor.\n@@ -4448,9 +4505,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n \t{\n \t  DR_MISALIGNMENT (dr) = 0;\n-\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"Alignment of access forced using peeling.\");\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n \t}\n       else\n \tDR_MISALIGNMENT (dr) = -1;\n@@ -4461,9 +4517,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (dr == LOOP_VINFO_UNALIGNED_DR (loop_vinfo))\n \t{\n \t  DR_MISALIGNMENT (dr) = 0;\n-\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"Alignment of access forced using peeling.\");\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n \t}\n       else\n \tDR_MISALIGNMENT (dr) = -1;\n@@ -4486,18 +4541,18 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_analyze_data_refs_alignment>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n \n \n   /* This pass may take place at function granularity instead of at loop\n      granularity.  */\n \n   if (!vect_compute_data_refs_alignment (loop_vinfo))\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \n \t\t \"not vectorized: can't calculate alignment for data ref.\");\n       return false;\n     }\n@@ -4518,31 +4573,29 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: unsupported unaligned load.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: unsupported unaligned load.\");\n \t  return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t      || vect_debug_stats (LOOP_LOC (loop_vinfo))))\n-\tfprintf (dump_file, \"Vectorizing an unaligned access.\");\n+\t  && (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo))))\n+\tfprintf (vect_dump, \"Vectorizing an unaligned access.\");\n     }\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t      || vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: unsupported unaligned store.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: unsupported unaligned store.\");\n \t  return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_debug_details (LOOP_LOC (loop_vinfo)) \n-\t      || vect_debug_stats (LOOP_LOC (loop_vinfo))))\n-\tfprintf (dump_file, \"Vectorizing an unaligned access.\");\n+\t  && (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo))))\n+\tfprintf (vect_dump, \"Vectorizing an unaligned access.\");\n     }\n \n   return true;\n@@ -4564,8 +4617,8 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (!step || tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"not consecutive access\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"not consecutive access\");\n       return false;\n     }\n   return true;\n@@ -4588,18 +4641,18 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_analyze_data_ref_accesses>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_analyze_data_ref_accesses ===\");\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n       bool ok = vect_analyze_data_ref_access (dr);\n       if (!ok)\n \t{\n-\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-\t      || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\t    fprintf (dump_file, \"not vectorized: complicated access pattern.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                      LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n \t  return false;\n \t}\n     }\n@@ -4610,9 +4663,9 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n       bool ok = vect_analyze_data_ref_access (dr);\n       if (!ok)\n \t{\n-\t  if (vect_debug_stats (LOOP_LOC (loop_vinfo))\n-\t      || vect_debug_details (LOOP_LOC (loop_vinfo))) \n-\t    fprintf (dump_file, \"not vectorized: complicated access pattern.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n \t  return false;\n \t}\n     }\n@@ -4645,71 +4698,71 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \n   if (!access_fn)\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-        fprintf (dump_file, \"not vectorized: complicated pointer access.\");\t\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"not vectorized: complicated pointer access.\");\t\n       return NULL;\n     }\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"Access function of ptr: \");\n-      print_generic_expr (dump_file, access_fn, TDF_SLIM);\n+      fprintf (vect_dump, \"Access function of ptr: \");\n+      print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n     }\n \n   if (!vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step, false))\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n-\tfprintf (dump_file, \"not vectorized: pointer access is not simple.\");\t\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"not vectorized: pointer access is not simple.\");\t\n       return NULL;\n     }\n \t\t\n   STRIP_NOPS (init);\n \n   if (!expr_invariant_in_loop_p (loop, init))\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n-\tfprintf (dump_file, \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \n \t\t \"not vectorized: initial condition is not loop invariant.\");\t\n       return NULL;\n     }\n \n   if (TREE_CODE (step) != INTEGER_CST)\n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n-\tfprintf (dump_file, \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \n \t\t\"not vectorized: non constant step for pointer access.\");\t\n       return NULL;\n     }\n \n   reftype = TREE_TYPE (TREE_OPERAND (memref, 0));\n   if (TREE_CODE (reftype) != POINTER_TYPE) \n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"not vectorized: unexpected pointer access form.\");\t\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\t\n       return NULL;\n     }\n \n   reftype = TREE_TYPE (init);\n   if (TREE_CODE (reftype) != POINTER_TYPE) \n     {\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n-\tfprintf (dump_file, \"not vectorized: unexpected pointer access form.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\n       return NULL;\n     }\n \n   innertype = TREE_TYPE (reftype);\n   if (tree_int_cst_compare (TYPE_SIZE_UNIT (innertype), step))\n     {\n       /* FORNOW: support only consecutive access */\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t  || vect_debug_details (LOOP_LOC (loop_vinfo))) \n-\tfprintf (dump_file, \"not vectorized: non consecutive access.\");\t\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"not vectorized: non consecutive access.\");\t\n       return NULL;\n     }\n \n@@ -4724,10 +4777,10 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n \n   indx_access_fn = \n \tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n-  if (vect_debug_details (LOOP_LOC (loop_vinfo))) \n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n     {\n-      fprintf (dump_file, \"Access function of ptr indx: \");\n-      print_generic_expr (dump_file, indx_access_fn, TDF_SLIM);\n+      fprintf (vect_dump, \"Access function of ptr indx: \");\n+      print_generic_expr (vect_dump, indx_access_fn, TDF_SLIM);\n     }\n   dr = init_data_ref (stmt, memref, init, indx_access_fn, is_read);\n   return dr;\n@@ -4798,8 +4851,9 @@ vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read,\n \t    }\n \t  if (!tag)\n \t    {\n-\t      if (vect_debug_details (UNKNOWN_LOC))\n-\t\tfprintf (dump_file, \"not vectorized: no memtag for ref.\");\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                         UNKNOWN_LOC))\n+\t\tfprintf (vect_dump, \"not vectorized: no memtag for ref.\");\n \t      return NULL_TREE;\n \t    }\n \t  return tag;\n@@ -4956,8 +5010,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   int j;\n   struct data_reference *dr;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_analyze_data_refs>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_analyze_data_refs ===\");\n \n   for (j = 0; j < nbbs; j++)\n     {\n@@ -4988,20 +5042,20 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n \t  if (nvuses && (nv_may_defs || nv_must_defs))\n \t    {\n-\t      if (vect_debug_details (UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t\t{\n-\t\t  fprintf (dump_file, \"unexpected vdefs and vuses in stmt: \");\n-\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t\t  fprintf (vect_dump, \"unexpected vdefs and vuses in stmt: \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n \n \t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n \t    {\n-\t      if (vect_debug_details (UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t\t{\n-\t\t  fprintf (dump_file, \"unexpected vops in stmt: \");\n-\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t\t  fprintf (vect_dump, \"unexpected vops in stmt: \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n@@ -5023,12 +5077,12 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vectype)\n \t    {\n-\t      if (vect_debug_details (UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t\t{\n-\t\t  fprintf (dump_file, \"no vectype for stmt: \");\n-\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n-\t\t  fprintf (dump_file, \" scalar_type: \");\n-\t\t  print_generic_expr (dump_file, scalar_type, TDF_DETAILS);\n+\t\t  fprintf (vect_dump, \"no vectype for stmt: \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t  fprintf (vect_dump, \" scalar_type: \");\n+\t\t  print_generic_expr (vect_dump, scalar_type, TDF_DETAILS);\n \t\t}\n \t      /* It is not possible to vectorize this data reference.  */\n \t      return false;\n@@ -5040,11 +5094,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t\t\t\t  vectype, &dr);\n \t  if (!symbl)\n \t    {\n-\t      if (vect_debug_stats (LOOP_LOC (loop_vinfo)) \n-\t\t  || vect_debug_details (LOOP_LOC (loop_vinfo)))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\tLOOP_LOC (loop_vinfo)))\n \t\t{\n-\t\t  fprintf (dump_file, \"not vectorized: unhandled data ref: \"); \n-\t\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t\t  fprintf (vect_dump, \"not vectorized: unhandled data ref: \"); \n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n@@ -5070,8 +5124,8 @@ vect_mark_relevant (varray_type *worklist, tree stmt)\n {\n   stmt_vec_info stmt_info;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"mark relevant.\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"mark relevant.\");\n \n   if (TREE_CODE (stmt) == PHI_NODE)\n     {\n@@ -5083,18 +5137,18 @@ vect_mark_relevant (varray_type *worklist, tree stmt)\n \n   if (!stmt_info)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-\t  fprintf (dump_file, \"mark relevant: no stmt info!!.\");\n-\t  print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t  fprintf (vect_dump, \"mark relevant: no stmt info!!.\");\n+\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t}\n       return;\n     }\n \n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"already marked relevant.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+        fprintf (vect_dump, \"already marked relevant.\");\n       return;\n     }\n \n@@ -5130,13 +5184,16 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n     return true;\n \n   /* changing memory.  */\n-  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-  if (v_may_defs || v_must_defs)\n+  if (TREE_CODE (stmt) != PHI_NODE)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-        fprintf (dump_file, \"vec_stmt_relevant_p: stmt has vdefs.\");\n-      return true;\n+      v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n+      v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n+      if (v_may_defs || v_must_defs)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n+\t  return true;\n+\t}\n     }\n \n   /* uses outside the loop.  */\n@@ -5148,8 +5205,8 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo)\n       basic_block bb = bb_for_stmt (use);\n       if (!flow_bb_inside_loop_p (loop, bb))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"vec_stmt_relevant_p: used out of loop.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"vec_stmt_relevant_p: used out of loop.\");\n \t  return true;\n \t}\n     }\n@@ -5191,22 +5248,23 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   basic_block bb;\n   tree phi;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<vect_mark_stmts_to_be_vectorized>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== vect_mark_stmts_to_be_vectorized ===\");\n \n   bb = loop->header;\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         {\n-          fprintf (dump_file, \"init: phi relevant? \");\n-          print_generic_expr (dump_file, phi, TDF_SLIM);\n+          fprintf (vect_dump, \"init: phi relevant? \");\n+          print_generic_expr (vect_dump, phi, TDF_SLIM);\n         }\n \n       if (vect_stmt_relevant_p (phi, loop_vinfo))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"unsupported reduction/induction.\");\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    fprintf (vect_dump, \"unsupported reduction/induction.\");\n           return false;\n \t}\n     }\n@@ -5222,10 +5280,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n \t  stmt = bsi_stmt (si);\n \n-\t  if (vect_debug_details (UNKNOWN_LOC))\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t    {\n-\t      fprintf (dump_file, \"init: stmt relevant? \");\n-\t      print_generic_expr (dump_file, stmt, TDF_SLIM);\n+\t      fprintf (vect_dump, \"init: stmt relevant? \");\n+\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t    } \n \n \t  stmt_info = vinfo_for_stmt (stmt);\n@@ -5244,10 +5302,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       stmt = VARRAY_TOP_TREE (worklist);\n       VARRAY_POP (worklist);\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-          fprintf (dump_file, \"worklist: examine stmt: \");\n-          print_generic_expr (dump_file, stmt, TDF_SLIM);\n+          fprintf (vect_dump, \"worklist: examine stmt: \");\n+          print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t}\n \n       /* Examine the USES in this statement. Mark all the statements which\n@@ -5264,18 +5322,19 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      basic_block bb;\n \t      if (!vect_is_simple_use (arg, loop_vinfo, &def_stmt))\n \t\t{\n-\t\t  if (vect_debug_details (UNKNOWN_LOC))\t\n-\t\t    fprintf (dump_file, \"worklist: unsupported use.\");\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t\t    fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n \t\t  varray_clear (worklist);\n \t\t  return false;\n \t\t}\n \t      if (!def_stmt)\n \t\tcontinue;\n \n-\t      if (vect_debug_details (UNKNOWN_LOC))\n+\t      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t        {\n-\t          fprintf (dump_file, \"worklist: def_stmt: \");\n-\t\t  print_generic_expr (dump_file, def_stmt, TDF_SLIM);\n+\t          fprintf (vect_dump, \"worklist: def_stmt: \");\n+\t\t  print_generic_expr (vect_dump, def_stmt, TDF_SLIM);\n \t\t}\n \n \t      bb = bb_for_stmt (def_stmt);\n@@ -5300,19 +5359,20 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n               basic_block bb;\n               if (!vect_is_simple_use (use, loop_vinfo, &def_stmt))\n                 {\n-                  if (vect_debug_details (UNKNOWN_LOC))        \n-                    fprintf (dump_file, \"worklist: unsupported use.\");\n+                  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+                    fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n                   varray_clear (worklist);\n                   return false;\n                 }\n \n \t      if (!def_stmt)\n \t\tcontinue;\n \n-              if (vect_debug_details (UNKNOWN_LOC))\n+              if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n                 {\n-                  fprintf (dump_file, \"worklist: examine use %d: \", i);\n-                  print_generic_expr (dump_file, use, TDF_SLIM);\n+                  fprintf (vect_dump, \"worklist: examine use %d: \", i);\n+                  print_generic_expr (vect_dump, use, TDF_SLIM);\n                 }\n \n \t      bb = bb_for_stmt (def_stmt);\n@@ -5350,19 +5410,19 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n       tree access_fn = NULL;\n       tree evolution_part;\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-          fprintf (dump_file, \"Analyze phi: \");\n-          print_generic_expr (dump_file, phi, TDF_SLIM);\n+          fprintf (vect_dump, \"Analyze phi: \");\n+          print_generic_expr (vect_dump, phi, TDF_SLIM);\n \t}\n \n       /* Skip virtual phi's. The data dependences that are associated with\n          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n \n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"virtual phi. skip.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"virtual phi. skip.\");\n \t  continue;\n \t}\n \n@@ -5373,15 +5433,15 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (vect_debug_details (UNKNOWN_LOC))\n-\t    fprintf (dump_file, \"No Access function.\");\n+\t  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\t    fprintf (vect_dump, \"No Access function.\");\n \t  return false;\n \t}\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         {\n-\t  fprintf (dump_file, \"Access function of PHI: \");\n-\t  print_generic_expr (dump_file, access_fn, TDF_SLIM);\n+\t  fprintf (vect_dump, \"Access function of PHI: \");\n+\t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n         }\n \n       evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n@@ -5412,8 +5472,8 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n {\n   tree niters;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<get_loop_niters>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"=== get_loop_niters ===\");\n \n   niters = number_of_iterations_in_loop (loop);\n \n@@ -5422,10 +5482,10 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n     {\n       *number_of_iterations = niters;\n \n-      if (vect_debug_details (UNKNOWN_LOC))\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n \t{\n-\t  fprintf (dump_file, \"==> get_loop_niters:\" );\n-\t  print_generic_expr (dump_file, *number_of_iterations, TDF_SLIM);\n+\t  fprintf (vect_dump, \"==> get_loop_niters:\" );\n+\t  print_generic_expr (vect_dump, *number_of_iterations, TDF_SLIM);\n \t}\n     }\n \n@@ -5454,29 +5514,32 @@ vect_analyze_loop_form (struct loop *loop)\n \n   loop_loc = find_loop_location (loop);\n \n-  if (vect_debug_details (loop_loc))\n-    fprintf (dump_file, \"\\n<<vect_analyze_loop_form>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n+    fprintf (vect_dump, \"=== vect_analyze_loop_form ===\");\n \n-  if (loop->inner\n-      || !loop->single_exit\n+  if (loop->inner)\n+    {\n+      if (vect_print_dump_info (REPORT_OUTER_LOOPS, loop_loc))\n+        fprintf (vect_dump, \"not vectorized: nested loop.\");\n+      return NULL;\n+    }\n+  \n+  if (!loop->single_exit \n       || loop->num_nodes != 2\n       || EDGE_COUNT (loop->header->preds) != 2\n       || loop->num_entries != 1)\n     {\n-      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\t\n-\t{\n-\t  fprintf (dump_file, \"not vectorized: bad loop form. \");\n-\t  if (loop->inner)\n-\t    fprintf (dump_file, \"nested loop.\");\n-\t  else if (!loop->single_exit)\n-\t    fprintf (dump_file, \"multiple exits.\");\n-\t  else if (loop->num_nodes != 2)\n-\t    fprintf (dump_file, \"too many BBs in loop.\");\n-\t  else if (EDGE_COUNT (loop->header->preds) != 2)\n-            fprintf (dump_file, \"too many incoming edges.\");\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+        {\n+          if (!loop->single_exit)\n+            fprintf (vect_dump, \"not vectorized: multiple exits.\");\n+          else if (loop->num_nodes != 2)\n+            fprintf (vect_dump, \"not vectorized: too many BBs in loop.\");\n+          else if (EDGE_COUNT (loop->header->preds) != 2)\n+            fprintf (vect_dump, \"not vectorized: too many incoming edges.\");\n           else if (loop->num_entries != 1)\n-            fprintf (dump_file, \"too many entries.\");\n-\t}\n+            fprintf (vect_dump, \"not vectorized: too many entries.\");\n+        }\n \n       return NULL;\n     }\n@@ -5487,8 +5550,8 @@ vect_analyze_loop_form (struct loop *loop)\n      executable statements, and the latch is empty.  */\n   if (!empty_block_p (loop->latch))\n     {\n-      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n-        fprintf (dump_file, \"not vectorized: unexpectd loop form.\");\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+        fprintf (vect_dump, \"not vectorized: unexpectd loop form.\");\n       return NULL;\n     }\n \n@@ -5515,31 +5578,31 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (empty_block_p (loop->header))\n     {\n-      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n-        fprintf (dump_file, \"not vectorized: empty loop.\");\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+        fprintf (vect_dump, \"not vectorized: empty loop.\");\n       return NULL;\n     }\n \n   loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n   if (!loop_cond)\n     {\n-      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n-\tfprintf (dump_file, \"not vectorized: complicated exit condition.\");\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+\tfprintf (vect_dump, \"not vectorized: complicated exit condition.\");\n       return NULL;\n     }\n   \n   if (!number_of_iterations) \n     {\n-      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n-\tfprintf (dump_file, \n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+\tfprintf (vect_dump, \n \t\t \"not vectorized: number of iterations cannot be computed.\");\n       return NULL;\n     }\n \n   if (chrec_contains_undetermined (number_of_iterations))\n     {\n-      if (vect_debug_details (loop_loc))\n-        fprintf (dump_file, \"Infinite number of iterations.\");\n+      if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS, loop_loc))\n+        fprintf (vect_dump, \"Infinite number of iterations.\");\n       return false;\n     }\n \n@@ -5548,18 +5611,17 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (vect_debug_details (loop_loc))\n+      if (vect_print_dump_info (REPORT_DETAILS, loop_loc))\n         {\n-          fprintf (dump_file, \"loop bound unknown.\\n\");\n-          fprintf (dump_file, \"Symbolic number of iterations is \");\n-          print_generic_expr (dump_file, number_of_iterations, TDF_DETAILS);\n+          fprintf (vect_dump, \"Symbolic number of iterations is \");\n+          print_generic_expr (vect_dump, number_of_iterations, TDF_DETAILS);\n         }\n     }\n   else\n   if (LOOP_VINFO_INT_NITERS (loop_vinfo) == 0)\n     {\n-      if (vect_debug_stats (loop_loc) || vect_debug_details (loop_loc))\n-        fprintf (dump_file, \"not vectorized: number of iterations = 0.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS, loop_loc))\n+        fprintf (vect_dump, \"not vectorized: number of iterations = 0.\");\n       return NULL;\n     }\n \n@@ -5582,16 +5644,16 @@ vect_analyze_loop (struct loop *loop)\n   bool ok;\n   loop_vec_info loop_vinfo;\n \n-  if (vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\n<<<<<<< analyze_loop_nest >>>>>>>\\n\");\n+  if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"===== analyze_loop_nest =====\");\n \n   /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n \n   loop_vinfo = vect_analyze_loop_form (loop);\n   if (!loop_vinfo)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"bad loop form.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"bad loop form.\");\n       return NULL;\n     }\n \n@@ -5604,8 +5666,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_refs (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"bad data references.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"bad data references.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5615,10 +5677,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"unexpected pattern.\");\n-      if (vect_debug_stats (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"not vectorized: unexpected pattern.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"unexpected pattern.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5629,8 +5689,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_scalar_cycles (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"bad scalar cycle.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"bad scalar cycle.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5641,8 +5701,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_ref_dependences (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"bad data dependence.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"bad data dependence.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5653,8 +5713,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_ref_accesses (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"bad data access.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"bad data access.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5665,8 +5725,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"bad data alignment.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"bad data alignment.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5677,8 +5737,8 @@ vect_analyze_loop (struct loop *loop)\n   ok = vect_analyze_operations (loop_vinfo);\n   if (!ok)\n     {\n-      if (vect_debug_details (LOOP_LOC (loop_vinfo)))\n-\tfprintf (dump_file, \"bad operation or unsupported loop bound.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"bad operation or unsupported loop bound.\");\n       destroy_loop_vec_info (loop_vinfo);\n       return NULL;\n     }\n@@ -5712,12 +5772,15 @@ vectorize_loops (struct loops *loops)\n   unsigned int i, loops_num;\n   unsigned int num_vectorized_loops = 0;\n \n+  /* Fix the verbosity level if not defined explicitly by the user.  */\n+  vect_set_dump_settings ();\n+\n   /* Does the target support SIMD?  */\n   /* FORNOW: until more sophisticated machine modelling is in place.  */\n   if (!UNITS_PER_SIMD_WORD)\n     {\n-      if (vect_debug_details (UNKNOWN_LOC))\n-\tfprintf (dump_file, \"vectorizer: target vector size is not defined.\");\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"vectorizer: target vector size is not defined.\");\n       return;\n     }\n \n@@ -5751,8 +5814,8 @@ vectorize_loops (struct loops *loops)\n       num_vectorized_loops++;\n     }\n \n-  if (vect_debug_stats (UNKNOWN_LOC) || vect_debug_details (UNKNOWN_LOC))\n-    fprintf (dump_file, \"\\nvectorized %u loops in function.\\n\",\n+  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS, UNKNOWN_LOC))\n+    fprintf (vect_dump, \"vectorized %u loops in function.\\n\",\n \t     num_vectorized_loops);\n \n   /*  ----------- Finalize. -----------  */"}, {"sha": "c4b89ca5c09d94e04103db2ea56e3c842f002fe4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -56,6 +56,19 @@ enum dr_alignment_support {\n   dr_aligned\n };\n \n+/* Define verbosity levels.  */\n+enum verbosity_levels {\n+  REPORT_NONE,\n+  REPORT_VECTORIZED_LOOPS,\n+  REPORT_UNVECTORIZED_LOOPS,\n+  REPORT_ALIGNMENT,\n+  REPORT_BAD_FORM_LOOPS,\n+  REPORT_OUTER_LOOPS,\n+  REPORT_DETAILS,\n+  /* New verbosity levels should be added before this one.  */\n+  MAX_VERBOSITY_LEVEL\n+};\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/"}, {"sha": "47f65c8f6ff4963b3c9674699d550cd269904cfc", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c866976a42ad9ea612d840a1a92c4bbaf0e2a494/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c866976a42ad9ea612d840a1a92c4bbaf0e2a494", "patch": "@@ -3917,4 +3917,7 @@ extern bool thread_through_all_blocks (void);\n /* In tree-gimple.c.  */\n extern tree get_base_address (tree t);\n \n+/* In tree-vectorizer.c.  */\n+extern void vect_set_verbosity_level (const char *);\n+\n #endif  /* GCC_TREE_H  */"}]}