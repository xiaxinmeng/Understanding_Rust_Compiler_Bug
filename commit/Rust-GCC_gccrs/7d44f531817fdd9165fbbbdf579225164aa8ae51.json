{"sha": "7d44f531817fdd9165fbbbdf579225164aa8ae51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q0NGY1MzE4MTdmZGQ5MTY1ZmJiYmRmNTc5MjI1MTY0YWE4YWU1MQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-04-28T05:16:19Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-04-28T05:16:19Z"}, "message": "re PR fortran/39879 (double free or corruption abort with gfortran)\n\n2009-04-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/39879\n\t* trans_expr.c (gfc_conv_procedure_call): Deep copy a derived\n\ttype parentheses argument if it is a variable with allocatable\n\tcomponents.\n\n2009-04-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/39879\n\t* gfortran.dg/alloc_comp_assign_10.f90: New test.\n\nFrom-SVN: r146871", "tree": {"sha": "f04a8d72271d3d34abda6a4ef6ffa6676d1561bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f04a8d72271d3d34abda6a4ef6ffa6676d1561bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d44f531817fdd9165fbbbdf579225164aa8ae51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d44f531817fdd9165fbbbdf579225164aa8ae51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d44f531817fdd9165fbbbdf579225164aa8ae51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d44f531817fdd9165fbbbdf579225164aa8ae51/comments", "author": null, "committer": null, "parents": [{"sha": "b2ed71b61a5f8a7d8c001516af6997d3fcaff403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ed71b61a5f8a7d8c001516af6997d3fcaff403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ed71b61a5f8a7d8c001516af6997d3fcaff403"}], "stats": {"total": 87, "additions": 86, "deletions": 1}, "files": [{"sha": "2ca027108700780e8c8056f395123ed6f08f70e4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7d44f531817fdd9165fbbbdf579225164aa8ae51", "patch": "@@ -1,3 +1,10 @@\n+2009-04-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/39879\n+\t* trans_expr.c (gfc_conv_procedure_call): Deep copy a derived\n+\ttype parentheses argument if it is a variable with allocatable\n+\tcomponents.\n+\n 2009-04-27  Ian Lance Taylor  <iant@google.com>\n \n \t* trans-intrinsic.c (DEFINE_MATH_BUILTIN): Add casts to enum"}, {"sha": "77a2dfae3563c6330f41ca3918c6b70f7ae8cf96", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7d44f531817fdd9165fbbbdf579225164aa8ae51", "patch": "@@ -1119,7 +1119,8 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n       gfc_add_modify (&se->pre, var, tmp);\n \n       /* Free the temporary afterwards.  */\n-      tmp = gfc_call_free (convert (pvoid_type_node, var));\n+      tmp = gfc_call_free (var, true, &gfc_current_locus,\n+\t\t\t   ALLOCTYPE_TEMPORARY);\n       gfc_add_expr_to_block (&se->post, tmp);\n     }\n \n@@ -2782,7 +2783,18 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      break;\n \t    }\n \n+\t  if (e->expr_type == EXPR_OP\n+\t\t&& e->value.op.op == INTRINSIC_PARENTHESES\n+\t\t&& e->value.op.op1->expr_type == EXPR_VARIABLE)\n+\t    {\n+\t      tree local_tmp;\n+\t      local_tmp = gfc_evaluate_now (tmp, &se->pre);\n+\t      local_tmp = gfc_copy_alloc_comp (e->ts.derived, local_tmp, tmp, parm_rank);\n+\t      gfc_add_expr_to_block (&se->post, local_tmp);\n+\t    }\n+\n \t  tmp = gfc_deallocate_alloc_comp (e->ts.derived, tmp, parm_rank);\n+\n \t  gfc_add_expr_to_block (&se->post, tmp);\n         }\n "}, {"sha": "53a81259cfba11b4043ebfc67f7a9a4223194f1f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d44f531817fdd9165fbbbdf579225164aa8ae51", "patch": "@@ -1,3 +1,8 @@\n+2009-04-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/39879\n+\t* gfortran.dg/alloc_comp_assign_10.f90: New test.\n+\n 2009-04-28  Ben Elliston  <bje@au.ibm.com>\n \n \tPR c++/35652"}, {"sha": "c85edea62fc95a2d657a7fe6e0e49be0eb8cc853", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_10.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d44f531817fdd9165fbbbdf579225164aa8ae51/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_10.f90?ref=7d44f531817fdd9165fbbbdf579225164aa8ae51", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR39879, in which gfc gagged on the double\n+! defined assignment where the rhs had a default initialiser.\n+!\n+! Contributed by David Sagan <david.sagan@gmail.com>\n+!\n+module test_struct\n+  interface assignment (=)\n+    module procedure tao_lat_equal_tao_lat\n+  end interface\n+  type bunch_params_struct\n+    integer n_live_particle          \n+  end type\n+  type tao_lattice_struct\n+    type (bunch_params_struct), allocatable :: bunch_params(:)\n+    type (bunch_params_struct), allocatable :: bunch_params2(:)\n+  end type\n+  type tao_universe_struct\n+    type (tao_lattice_struct), pointer :: model, design\n+    character(200), pointer :: descrip => NULL()\n+  end type\n+  type tao_super_universe_struct\n+    type (tao_universe_struct), allocatable :: u(:)          \n+  end type\n+  type (tao_super_universe_struct), save, target :: s\n+  contains\n+    subroutine tao_lat_equal_tao_lat (lat1, lat2)\n+      implicit none\n+      type (tao_lattice_struct), intent(inout) :: lat1\n+      type (tao_lattice_struct), intent(in) :: lat2\n+      if (allocated(lat2%bunch_params)) then\n+        lat1%bunch_params = lat2%bunch_params\n+      end if \n+      if (allocated(lat2%bunch_params2)) then\n+        lat1%bunch_params2 = lat2%bunch_params2\n+      end if \n+    end subroutine\n+end module\n+\n+program tao_program\n+  use test_struct\n+  implicit none\n+  type (tao_universe_struct), pointer :: u\n+  integer n, i\n+  allocate (s%u(1))\n+  u => s%u(1)\n+  allocate (u%design, u%model)\n+  n = 112\n+  allocate (u%model%bunch_params(0:n), u%design%bunch_params(0:n))\n+  u%design%bunch_params%n_live_particle = [(i, i = 0, n)]\n+  u%model = u%design\n+  u%model = u%design ! The double assignment was the cause of the ICE\n+  if (.not. allocated (u%model%bunch_params)) call abort\n+  if (any (u%model%bunch_params%n_live_particle .ne. [(i, i = 0, n)])) call abort\n+  Deallocate (u%model%bunch_params, u%design%bunch_params)\n+  deallocate (u%design, u%model)\n+  deallocate (s%u)\n+end program\n+\n+! { dg-final { cleanup-modules \"test_struct\" } }"}]}