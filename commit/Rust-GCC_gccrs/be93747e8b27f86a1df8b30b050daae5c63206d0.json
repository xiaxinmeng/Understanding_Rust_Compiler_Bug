{"sha": "be93747e8b27f86a1df8b30b050daae5c63206d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5Mzc0N2U4YjI3Zjg2YTFkZjhiMzBiMDUwZGFhZTVjNjMyMDZkMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-18T17:19:03Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-18T17:19:03Z"}, "message": "cvt.c (convert_to_void): Avoid C++ keywords.\n\n\t* cvt.c (convert_to_void): Avoid C++ keywords.\n\t* decl.c (walk_namespaces_r, wrapup_globals_for_namespace):\n\tLikewise.\n\t* friend.c (is_friend): Likewise.\n\t* init.c (perform_member_init): Likewise.\n\t* mangle.c (write_template_prefix, write_template_template_param):\n\tLikewise.\n\t* name-lookup.c (do_namespace_alias, do_using_directive,\n\tparse_using_directive, ambiguous_decl, arg_assoc): Likewise.\n\t* parser.c (cp_parser_template_id, cp_parser_namespace_definition,\n\tcp_parser_objc_typename, cp_parser_objc_method_keyword_params):\n\tLikewise.\n\t* pt.c (is_specialization_of_friend, lookup_template_class,\n\tpush_tinst_level, instantiate_class_template,\n\ttsubst_copy_and_build): Likewise.\n\t* tree.c (add_stmt_to_compound): Likewise.\n\t* typeck.c (finish_class_member_access_expr): Likewise.\n\nFrom-SVN: r137959", "tree": {"sha": "a60dba86fc4150038bcebaed919ee2dcb85e0195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a60dba86fc4150038bcebaed919ee2dcb85e0195"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be93747e8b27f86a1df8b30b050daae5c63206d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be93747e8b27f86a1df8b30b050daae5c63206d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be93747e8b27f86a1df8b30b050daae5c63206d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be93747e8b27f86a1df8b30b050daae5c63206d0/comments", "author": null, "committer": null, "parents": [{"sha": "5025f3793e879f9011890fc0641c51693165ffc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5025f3793e879f9011890fc0641c51693165ffc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5025f3793e879f9011890fc0641c51693165ffc2"}], "stats": {"total": 392, "additions": 206, "deletions": 186}, "files": [{"sha": "d67a10b0283f21b920cfd22730ef04b3139d2558", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -1,3 +1,23 @@\n+2008-07-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cvt.c (convert_to_void): Avoid C++ keywords.\n+\t* decl.c (walk_namespaces_r, wrapup_globals_for_namespace):\n+\tLikewise.\n+\t* friend.c (is_friend): Likewise.\n+\t* init.c (perform_member_init): Likewise.\n+\t* mangle.c (write_template_prefix, write_template_template_param):\n+\tLikewise.\n+\t* name-lookup.c (do_namespace_alias, do_using_directive,\n+\tparse_using_directive, ambiguous_decl, arg_assoc): Likewise.\n+\t* parser.c (cp_parser_template_id, cp_parser_namespace_definition,\n+\tcp_parser_objc_typename, cp_parser_objc_method_keyword_params):\n+\tLikewise.\n+\t* pt.c (is_specialization_of_friend, lookup_template_class,\n+\tpush_tinst_level, instantiate_class_template,\n+\ttsubst_copy_and_build): Likewise.\n+\t* tree.c (add_stmt_to_compound): Likewise.\n+\t* typeck.c (finish_class_member_access_expr): Likewise.\n+\n 2008-07-17  Julian Brown  <julian@codesourcery.com>\n \t    Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "3ee3ba7956bb9cb170f2f9e97c204108733e9d46", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -938,7 +938,7 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \t    {\n \t      tree e;\n \t      enum tree_code code;\n-\t      enum tree_code_class class;\n+\t      enum tree_code_class tclass;\n \n \t      e = expr;\n \t      /* We might like to warn about (say) \"(int) f()\", as the\n@@ -955,10 +955,10 @@ convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n \t\te = TREE_OPERAND (e, 0);\n \n \t      code = TREE_CODE (e);\n-\t      class = TREE_CODE_CLASS (code);\n-\t      if ((class == tcc_comparison\n-\t\t   || class == tcc_unary\n-\t\t   || (class == tcc_binary\n+\t      tclass = TREE_CODE_CLASS (code);\n+\t      if ((tclass == tcc_comparison\n+\t\t   || tclass == tcc_unary\n+\t\t   || (tclass == tcc_binary\n \t\t       && !(code == MODIFY_EXPR\n \t\t\t    || code == INIT_EXPR\n \t\t\t    || code == PREDECREMENT_EXPR"}, {"sha": "cd6f287c85793929abedb69608b27f79e45167a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -800,12 +800,12 @@ insert_block (tree block)\n    itself, calling F for each.  The DATA is passed to F as well.  */\n \n static int\n-walk_namespaces_r (tree namespace, walk_namespaces_fn f, void* data)\n+walk_namespaces_r (tree name_space, walk_namespaces_fn f, void* data)\n {\n   int result = 0;\n-  tree current = NAMESPACE_LEVEL (namespace)->namespaces;\n+  tree current = NAMESPACE_LEVEL (name_space)->namespaces;\n \n-  result |= (*f) (namespace, data);\n+  result |= (*f) (name_space, data);\n \n   for (; current; current = TREE_CHAIN (current))\n     result |= walk_namespaces_r (current, f, data);\n@@ -827,9 +827,9 @@ walk_namespaces (walk_namespaces_fn f, void* data)\n    wrapup_global_declarations for this NAMESPACE.  */\n \n int\n-wrapup_globals_for_namespace (tree namespace, void* data)\n+wrapup_globals_for_namespace (tree name_space, void* data)\n {\n-  struct cp_binding_level *level = NAMESPACE_LEVEL (namespace);\n+  struct cp_binding_level *level = NAMESPACE_LEVEL (name_space);\n   VEC(tree,gc) *statics = level->static_decls;\n   tree *vec = VEC_address (tree, statics);\n   int len = VEC_length (tree, statics);"}, {"sha": "090f84db28844690d886f4241ff27dd5f7401187", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -59,15 +59,15 @@ is_friend (tree type, tree supplicant)\n \t      tree friends = FRIEND_DECLS (list);\n \t      for (; friends ; friends = TREE_CHAIN (friends))\n \t\t{\n-\t\t  tree friend = TREE_VALUE (friends);\n+\t\t  tree this_friend = TREE_VALUE (friends);\n \n-\t\t  if (friend == NULL_TREE)\n+\t\t  if (this_friend == NULL_TREE)\n \t\t    continue;\n \n-\t\t  if (supplicant == friend)\n+\t\t  if (supplicant == this_friend)\n \t\t    return 1;\n \n-\t\t  if (is_specialization_of_friend (supplicant, friend))\n+\t\t  if (is_specialization_of_friend (supplicant, this_friend))\n \t\t    return 1;\n \t\t}\n \t      break;"}, {"sha": "add7596b97abaf75f968728261d96e62e498584f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -469,13 +469,13 @@ perform_member_init (tree member, tree init)\n {\n   tree decl;\n   tree type = TREE_TYPE (member);\n-  bool explicit;\n+  bool is_explicit;\n \n-  explicit = (init != NULL_TREE);\n+  is_explicit = (init != NULL_TREE);\n \n   /* Effective C++ rule 12 requires that all data members be\n      initialized.  */\n-  if (warn_ecpp && !explicit && TREE_CODE (type) != ARRAY_TYPE)\n+  if (warn_ecpp && !is_explicit && TREE_CODE (type) != ARRAY_TYPE)\n     warning (OPT_Weffc__, \"%J%qD should be initialized in the member initialization \"\n \t     \"list\", current_function_decl, member);\n \n@@ -503,7 +503,7 @@ perform_member_init (tree member, tree init)\n     }\n   else if (TYPE_NEEDS_CONSTRUCTING (type))\n     {\n-      if (explicit\n+      if (is_explicit\n \t  && TREE_CODE (type) == ARRAY_TYPE\n \t  && init != NULL_TREE\n \t  && TREE_CHAIN (init) == NULL_TREE\n@@ -523,7 +523,7 @@ perform_member_init (tree member, tree init)\n     {\n       if (init == NULL_TREE)\n \t{\n-\t  if (explicit)\n+\t  if (is_explicit)\n \t    {\n \t      init = build_default_init (type, /*nelts=*/NULL_TREE);\n \t      if (TREE_CODE (type) == REFERENCE_TYPE)"}, {"sha": "1bc72b86a2de0a794cd11b5111954954ae525372", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -974,19 +974,19 @@ write_template_prefix (const tree node)\n   tree type = DECL_P (node) ? TREE_TYPE (node) : node;\n   tree context = CP_DECL_CONTEXT (decl);\n   tree template_info;\n-  tree template;\n+  tree templ;\n   tree substitution;\n \n   MANGLE_TRACE_TREE (\"template-prefix\", node);\n \n   /* Find the template decl.  */\n   if (decl_is_template_id (decl, &template_info))\n-    template = TI_TEMPLATE (template_info);\n+    templ = TI_TEMPLATE (template_info);\n   else\n     {\n       gcc_assert (CLASSTYPE_TEMPLATE_ID_P (type));\n \n-      template = TYPE_TI_TEMPLATE (type);\n+      templ = TYPE_TI_TEMPLATE (type);\n     }\n \n   /* For a member template, though, the template name for the\n@@ -1012,21 +1012,21 @@ write_template_prefix (const tree node)\n      substitution candidate by a TREE_LIST whose purpose is `Outer<int>'\n      and whose value is `Outer<T>::Inner<U>'.  */\n   if (TYPE_P (context))\n-    substitution = build_tree_list (context, template);\n+    substitution = build_tree_list (context, templ);\n   else\n-    substitution = template;\n+    substitution = templ;\n \n   if (find_substitution (substitution))\n     return;\n \n   /* In G++ 3.2, the name of the template template parameter was used.  */\n-  if (TREE_CODE (TREE_TYPE (template)) == TEMPLATE_TEMPLATE_PARM\n+  if (TREE_CODE (TREE_TYPE (templ)) == TEMPLATE_TEMPLATE_PARM\n       && !abi_version_at_least (2))\n     G.need_abi_warning = true;\n \n-  if (TREE_CODE (TREE_TYPE (template)) == TEMPLATE_TEMPLATE_PARM\n+  if (TREE_CODE (TREE_TYPE (templ)) == TEMPLATE_TEMPLATE_PARM\n       && abi_version_at_least (2))\n-    write_template_param (TREE_TYPE (template));\n+    write_template_param (TREE_TYPE (templ));\n   else\n     {\n       write_prefix (context);\n@@ -2480,24 +2480,24 @@ write_template_param (const tree parm)\n static void\n write_template_template_param (const tree parm)\n {\n-  tree template = NULL_TREE;\n+  tree templ = NULL_TREE;\n \n   /* PARM, a TEMPLATE_TEMPLATE_PARM, is an instantiation of the\n      template template parameter.  The substitution candidate here is\n      only the template.  */\n   if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n-      template\n+      templ\n \t= TI_TEMPLATE (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm));\n-      if (find_substitution (template))\n+      if (find_substitution (templ))\n \treturn;\n     }\n \n   /* <template-param> encodes only the template parameter position,\n      not its template arguments, which is fine here.  */\n   write_template_param (parm);\n-  if (template)\n-    add_substitution (template);\n+  if (templ)\n+    add_substitution (templ);\n }\n \n /* Non-terminal <substitution>."}, {"sha": "edf74f9c81f8c9a111c9d91f949a079c5e62f516", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -3310,18 +3310,18 @@ namespace_ancestor (tree ns1, tree ns2)\n /* Process a namespace-alias declaration.  */\n \n void\n-do_namespace_alias (tree alias, tree namespace)\n+do_namespace_alias (tree alias, tree name_space)\n {\n-  if (namespace == error_mark_node)\n+  if (name_space == error_mark_node)\n     return;\n \n-  gcc_assert (TREE_CODE (namespace) == NAMESPACE_DECL);\n+  gcc_assert (TREE_CODE (name_space) == NAMESPACE_DECL);\n \n-  namespace = ORIGINAL_NAMESPACE (namespace);\n+  name_space = ORIGINAL_NAMESPACE (name_space);\n \n   /* Build the alias.  */\n   alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);\n-  DECL_NAMESPACE_ALIAS (alias) = namespace;\n+  DECL_NAMESPACE_ALIAS (alias) = name_space;\n   DECL_EXTERNAL (alias) = 1;\n   DECL_CONTEXT (alias) = FROB_CONTEXT (current_scope ());\n   pushdecl (alias);\n@@ -3459,46 +3459,46 @@ do_toplevel_using_decl (tree decl, tree scope, tree name)\n /* Process a using-directive.  */\n \n void\n-do_using_directive (tree namespace)\n+do_using_directive (tree name_space)\n {\n   tree context = NULL_TREE;\n \n-  if (namespace == error_mark_node)\n+  if (name_space == error_mark_node)\n     return;\n \n-  gcc_assert (TREE_CODE (namespace) == NAMESPACE_DECL);\n+  gcc_assert (TREE_CODE (name_space) == NAMESPACE_DECL);\n \n   if (building_stmt_tree ())\n-    add_stmt (build_stmt (USING_STMT, namespace));\n-  namespace = ORIGINAL_NAMESPACE (namespace);\n+    add_stmt (build_stmt (USING_STMT, name_space));\n+  name_space = ORIGINAL_NAMESPACE (name_space);\n \n   if (!toplevel_bindings_p ())\n     {\n-      push_using_directive (namespace);\n+      push_using_directive (name_space);\n       context = current_scope ();\n     }\n   else\n     {\n       /* direct usage */\n-      add_using_namespace (current_namespace, namespace, 0);\n+      add_using_namespace (current_namespace, name_space, 0);\n       if (current_namespace != global_namespace)\n \tcontext = current_namespace;\n     }\n \n   /* Emit debugging info.  */\n   if (!processing_template_decl)\n-    (*debug_hooks->imported_module_or_decl) (namespace, context);\n+    (*debug_hooks->imported_module_or_decl) (name_space, context);\n }\n \n /* Deal with a using-directive seen by the parser.  Currently we only\n    handle attributes here, since they cannot appear inside a template.  */\n \n void\n-parse_using_directive (tree namespace, tree attribs)\n+parse_using_directive (tree name_space, tree attribs)\n {\n   tree a;\n \n-  do_using_directive (namespace);\n+  do_using_directive (name_space);\n \n   for (a = attribs; a; a = TREE_CHAIN (a))\n     {\n@@ -3507,14 +3507,14 @@ parse_using_directive (tree namespace, tree attribs)\n \t{\n \t  if (!toplevel_bindings_p ())\n \t    error (\"strong using only meaningful at namespace scope\");\n-\t  else if (namespace != error_mark_node)\n+\t  else if (name_space != error_mark_node)\n \t    {\n-\t      if (!is_ancestor (current_namespace, namespace))\n+\t      if (!is_ancestor (current_namespace, name_space))\n \t\terror (\"current namespace %qD does not enclose strongly used namespace %qD\",\n-\t\t       current_namespace, namespace);\n-\t      DECL_NAMESPACE_ASSOCIATIONS (namespace)\n+\t\t       current_namespace, name_space);\n+\t      DECL_NAMESPACE_ASSOCIATIONS (name_space)\n \t\t= tree_cons (current_namespace, 0,\n-\t\t\t     DECL_NAMESPACE_ASSOCIATIONS (namespace));\n+\t\t\t     DECL_NAMESPACE_ASSOCIATIONS (name_space));\n \t    }\n \t}\n       else\n@@ -3603,25 +3603,25 @@ merge_functions (tree s1, tree s2)\n /* This should return an error not all definitions define functions.\n    It is not an error if we find two functions with exactly the\n    same signature, only if these are selected in overload resolution.\n-   old is the current set of bindings, new the freshly-found binding.\n+   old is the current set of bindings, new_binding the freshly-found binding.\n    XXX Do we want to give *all* candidates in case of ambiguity?\n    XXX In what way should I treat extern declarations?\n    XXX I don't want to repeat the entire duplicate_decls here */\n \n static void\n-ambiguous_decl (struct scope_binding *old, cxx_binding *new, int flags)\n+ambiguous_decl (struct scope_binding *old, cxx_binding *new_binding, int flags)\n {\n   tree val, type;\n   gcc_assert (old != NULL);\n \n   /* Copy the type.  */\n-  type = new->type;\n+  type = new_binding->type;\n   if (LOOKUP_NAMESPACES_ONLY (flags)\n       || (type && hidden_name_p (type) && !(flags & LOOKUP_HIDDEN)))\n     type = NULL_TREE;\n \n   /* Copy the value.  */\n-  val = new->value;\n+  val = new_binding->value;\n   if (val)\n     {\n       if (hidden_name_p (val) && !(flags & LOOKUP_HIDDEN))\n@@ -4772,21 +4772,21 @@ arg_assoc (struct arg_lookup *k, tree n)\n \t If T is a template-id, its associated namespaces and classes\n \t are the namespace in which the template is defined; for\n \t member templates, the member template's class...  */\n-      tree template = TREE_OPERAND (n, 0);\n+      tree templ = TREE_OPERAND (n, 0);\n       tree args = TREE_OPERAND (n, 1);\n       tree ctx;\n       int ix;\n \n-      if (TREE_CODE (template) == COMPONENT_REF)\n-\ttemplate = TREE_OPERAND (template, 1);\n+      if (TREE_CODE (templ) == COMPONENT_REF)\n+\ttempl = TREE_OPERAND (templ, 1);\n \n       /* First, the template.  There may actually be more than one if\n \t this is an overloaded function template.  But, in that case,\n \t we only need the first; all the functions will be in the same\n \t namespace.  */\n-      template = OVL_CURRENT (template);\n+      templ = OVL_CURRENT (templ);\n \n-      ctx = CP_DECL_CONTEXT (template);\n+      ctx = CP_DECL_CONTEXT (templ);\n \n       if (TREE_CODE (ctx) == NAMESPACE_DECL)\n \t{"}, {"sha": "02fb66071300b6e2fff0de5f9a00b39db254169c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -9890,7 +9890,7 @@ cp_parser_template_id (cp_parser *parser,\n \t\t       bool is_declaration)\n {\n   int i;\n-  tree template;\n+  tree templ;\n   tree arguments;\n   tree template_id;\n   cp_token_position start_of_id = 0;\n@@ -9945,14 +9945,14 @@ cp_parser_template_id (cp_parser *parser,\n   /* Parse the template-name.  */\n   is_identifier = false;\n   token = cp_lexer_peek_token (parser->lexer);\n-  template = cp_parser_template_name (parser, template_keyword_p,\n-\t\t\t\t      check_dependency_p,\n-\t\t\t\t      is_declaration,\n-\t\t\t\t      &is_identifier);\n-  if (template == error_mark_node || is_identifier)\n+  templ = cp_parser_template_name (parser, template_keyword_p,\n+\t\t\t\t   check_dependency_p,\n+\t\t\t\t   is_declaration,\n+\t\t\t\t   &is_identifier);\n+  if (templ == error_mark_node || is_identifier)\n     {\n       pop_deferring_access_checks ();\n-      return template;\n+      return templ;\n     }\n \n   /* If we find the sequence `[:' after a template-name, it's probably\n@@ -10015,10 +10015,10 @@ cp_parser_template_id (cp_parser *parser,\n     }\n \n   /* Build a representation of the specialization.  */\n-  if (TREE_CODE (template) == IDENTIFIER_NODE)\n-    template_id = build_min_nt (TEMPLATE_ID_EXPR, template, arguments);\n-  else if (DECL_CLASS_TEMPLATE_P (template)\n-\t   || DECL_TEMPLATE_TEMPLATE_PARM_P (template))\n+  if (TREE_CODE (templ) == IDENTIFIER_NODE)\n+    template_id = build_min_nt (TEMPLATE_ID_EXPR, templ, arguments);\n+  else if (DECL_CLASS_TEMPLATE_P (templ)\n+\t   || DECL_TEMPLATE_TEMPLATE_PARM_P (templ))\n     {\n       bool entering_scope;\n       /* In \"template <typename T> ... A<T>::\", A<T> is the abstract A\n@@ -10030,17 +10030,17 @@ cp_parser_template_id (cp_parser *parser,\n \t\t\t&& cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t\t   CPP_SCOPE));\n       template_id\n-\t= finish_template_type (template, arguments, entering_scope);\n+\t= finish_template_type (templ, arguments, entering_scope);\n     }\n   else\n     {\n       /* If it's not a class-template or a template-template, it should be\n \t a function-template.  */\n-      gcc_assert ((DECL_FUNCTION_TEMPLATE_P (template)\n-\t\t   || TREE_CODE (template) == OVERLOAD\n-\t\t   || BASELINK_P (template)));\n+      gcc_assert ((DECL_FUNCTION_TEMPLATE_P (templ)\n+\t\t   || TREE_CODE (templ) == OVERLOAD\n+\t\t   || BASELINK_P (templ)));\n \n-      template_id = lookup_template_function (template, arguments);\n+      template_id = lookup_template_function (templ, arguments);\n     }\n \n   /* If parsing tentatively, replace the sequence of tokens that makes\n@@ -11901,14 +11901,14 @@ cp_parser_namespace_definition (cp_parser* parser)\n      followed by a strong using directive.  */\n   if (is_inline)\n     {\n-      tree namespace = current_namespace;\n+      tree name_space = current_namespace;\n       /* Set up namespace association.  */\n-      DECL_NAMESPACE_ASSOCIATIONS (namespace)\n-\t= tree_cons (CP_DECL_CONTEXT (namespace), NULL_TREE,\n-\t\t     DECL_NAMESPACE_ASSOCIATIONS (namespace));\n+      DECL_NAMESPACE_ASSOCIATIONS (name_space)\n+\t= tree_cons (CP_DECL_CONTEXT (name_space), NULL_TREE,\n+\t\t     DECL_NAMESPACE_ASSOCIATIONS (name_space));\n       /* Import the contents of the inline namespace.  */\n       pop_namespace ();\n-      do_using_directive (namespace);\n+      do_using_directive (name_space);\n       push_namespace (identifier);\n     }\n \n@@ -19169,7 +19169,7 @@ cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n static tree\n cp_parser_objc_typename (cp_parser* parser)\n {\n-  tree typename = NULL_TREE;\n+  tree type_name = NULL_TREE;\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n@@ -19184,10 +19184,10 @@ cp_parser_objc_typename (cp_parser* parser)\n \tcp_type = cp_parser_type_id (parser);\n \n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n-      typename = build_tree_list (proto_quals, cp_type);\n+      type_name = build_tree_list (proto_quals, cp_type);\n     }\n \n-  return typename;\n+  return type_name;\n }\n \n /* Check to see if TYPE refers to an Objective-C selector name.  */\n@@ -19244,7 +19244,7 @@ cp_parser_objc_method_keyword_params (cp_parser* parser)\n \n   while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n     {\n-      tree selector = NULL_TREE, typename, identifier;\n+      tree selector = NULL_TREE, type_name, identifier;\n \n       if (token->type != CPP_COLON)\n \tselector = cp_parser_objc_selector (parser);\n@@ -19256,13 +19256,13 @@ cp_parser_objc_method_keyword_params (cp_parser* parser)\n \n       maybe_unary_selector_p = false;\n       cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n-      typename = cp_parser_objc_typename (parser);\n+      type_name = cp_parser_objc_typename (parser);\n       identifier = cp_parser_identifier (parser);\n \n       params\n \t= chainon (params,\n \t\t   objc_build_keyword_decl (selector,\n-\t\t\t\t\t    typename,\n+\t\t\t\t\t    type_name,\n \t\t\t\t\t    identifier));\n \n       token = cp_lexer_peek_token (parser->lexer);"}, {"sha": "8b2d8c3507de6eb5e7f1425f37e365e2386aa4b2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -1022,37 +1022,37 @@ is_specialization_of (tree decl, tree tmpl)\n }\n \n /* Returns nonzero iff DECL is a specialization of friend declaration\n-   FRIEND according to [temp.friend].  */\n+   FRIEND_DECL according to [temp.friend].  */\n \n bool\n-is_specialization_of_friend (tree decl, tree friend)\n+is_specialization_of_friend (tree decl, tree friend_decl)\n {\n   bool need_template = true;\n   int template_depth;\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n \t      || TREE_CODE (decl) == TYPE_DECL);\n \n-  /* For [temp.friend/6] when FRIEND is an ordinary member function\n+  /* For [temp.friend/6] when FRIEND_DECL is an ordinary member function\n      of a template class, we want to check if DECL is a specialization\n      if this.  */\n-  if (TREE_CODE (friend) == FUNCTION_DECL\n-      && DECL_TEMPLATE_INFO (friend)\n-      && !DECL_USE_TEMPLATE (friend))\n+  if (TREE_CODE (friend_decl) == FUNCTION_DECL\n+      && DECL_TEMPLATE_INFO (friend_decl)\n+      && !DECL_USE_TEMPLATE (friend_decl))\n     {\n       /* We want a TEMPLATE_DECL for `is_specialization_of'.  */\n-      friend = DECL_TI_TEMPLATE (friend);\n+      friend_decl = DECL_TI_TEMPLATE (friend_decl);\n       need_template = false;\n     }\n-  else if (TREE_CODE (friend) == TEMPLATE_DECL\n-\t   && !PRIMARY_TEMPLATE_P (friend))\n+  else if (TREE_CODE (friend_decl) == TEMPLATE_DECL\n+\t   && !PRIMARY_TEMPLATE_P (friend_decl))\n     need_template = false;\n \n   /* There is nothing to do if this is not a template friend.  */\n-  if (TREE_CODE (friend) != TEMPLATE_DECL)\n+  if (TREE_CODE (friend_decl) != TEMPLATE_DECL)\n     return false;\n \n-  if (is_specialization_of (decl, friend))\n+  if (is_specialization_of (decl, friend_decl))\n     return true;\n \n   /* [temp.friend/6]\n@@ -1075,14 +1075,14 @@ is_specialization_of_friend (tree decl, tree friend)\n      nonzero.  To determine if DECL is a friend of FRIEND, we first\n      check if the enclosing class is a specialization of another.  */\n \n-  template_depth = template_class_depth (DECL_CONTEXT (friend));\n+  template_depth = template_class_depth (DECL_CONTEXT (friend_decl));\n   if (template_depth\n       && DECL_CLASS_SCOPE_P (decl)\n       && is_specialization_of (TYPE_NAME (DECL_CONTEXT (decl)),\n-\t\t\t       CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (friend))))\n+\t\t\t       CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (friend_decl))))\n     {\n       /* Next, we check the members themselves.  In order to handle\n-\t a few tricky cases, such as when FRIEND's are\n+\t a few tricky cases, such as when FRIEND_DECL's are\n \n \t   template <class T> friend void A<T>::g(T t);\n \t   template <class T> template <T t> friend void A<T>::h();\n@@ -1122,7 +1122,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t  tree friend_args_type;\n \t  tree decl_args_type;\n \n-\t  /* Make sure that both DECL and FRIEND are templates or\n+\t  /* Make sure that both DECL and FRIEND_DECL are templates or\n \t     non-templates.  */\n \t  is_template = DECL_TEMPLATE_INFO (decl)\n \t\t\t&& PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl));\n@@ -1132,7 +1132,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t    {\n \t      /* If both are templates, check template parameter list.  */\n \t      tree friend_parms\n-\t\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend),\n+\t\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_decl),\n \t\t\t\t\t args, tf_none);\n \t      if (!comp_template_parms\n \t\t     (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl)),\n@@ -1144,7 +1144,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t  else\n \t    decl_type = TREE_TYPE (decl);\n \n-\t  friend_type = tsubst_function_type (TREE_TYPE (friend), args,\n+\t  friend_type = tsubst_function_type (TREE_TYPE (friend_decl), args,\n \t\t\t\t\t      tf_none, NULL_TREE);\n \t  if (friend_type == error_mark_node)\n \t    return false;\n@@ -1157,7 +1157,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t     `this' parameter.  */\n \t  friend_args_type = TYPE_ARG_TYPES (friend_type);\n \t  decl_args_type = TYPE_ARG_TYPES (decl_type);\n-\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (friend))\n+\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (friend_decl))\n \t    friend_args_type = TREE_CHAIN (friend_args_type);\n \t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n \t    decl_args_type = TREE_CHAIN (decl_args_type);\n@@ -1170,7 +1170,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t  bool is_template;\n \t  tree decl_type = TREE_TYPE (decl);\n \n-\t  /* Make sure that both DECL and FRIEND are templates or\n+\t  /* Make sure that both DECL and FRIEND_DECL are templates or\n \t     non-templates.  */\n \t  is_template\n \t    = CLASSTYPE_TEMPLATE_INFO (decl_type)\n@@ -1184,20 +1184,20 @@ is_specialization_of_friend (tree decl, tree friend)\n \t      /* If both are templates, check the name of the two\n \t\t TEMPLATE_DECL's first because is_friend didn't.  */\n \t      if (DECL_NAME (CLASSTYPE_TI_TEMPLATE (decl_type))\n-\t\t  != DECL_NAME (friend))\n+\t\t  != DECL_NAME (friend_decl))\n \t\treturn false;\n \n \t      /* Now check template parameter list.  */\n \t      friend_parms\n-\t\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend),\n+\t\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_decl),\n \t\t\t\t\t args, tf_none);\n \t      return comp_template_parms\n \t\t(DECL_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (decl_type)),\n \t\t friend_parms);\n \t    }\n \t  else\n \t    return (DECL_NAME (decl)\n-\t\t    == DECL_NAME (friend));\n+\t\t    == DECL_NAME (friend_decl));\n \t}\n     }\n   return false;\n@@ -5536,7 +5536,7 @@ lookup_template_class (tree d1,\n \t\t       int entering_scope,\n \t\t       tsubst_flags_t complain)\n {\n-  tree template = NULL_TREE, parmlist;\n+  tree templ = NULL_TREE, parmlist;\n   tree t;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -5545,18 +5545,18 @@ lookup_template_class (tree d1,\n     {\n       tree value = innermost_non_namespace_value (d1);\n       if (value && DECL_TEMPLATE_TEMPLATE_PARM_P (value))\n-\ttemplate = value;\n+\ttempl = value;\n       else\n \t{\n \t  if (context)\n \t    push_decl_namespace (context);\n-\t  template = lookup_name (d1);\n-\t  template = maybe_get_template_decl_from_type_decl (template);\n+\t  templ = lookup_name (d1);\n+\t  templ = maybe_get_template_decl_from_type_decl (templ);\n \t  if (context)\n \t    pop_decl_namespace ();\n \t}\n-      if (template)\n-\tcontext = DECL_CONTEXT (template);\n+      if (templ)\n+\tcontext = DECL_CONTEXT (templ);\n     }\n   else if (TREE_CODE (d1) == TYPE_DECL && MAYBE_CLASS_TYPE_P (TREE_TYPE (d1)))\n     {\n@@ -5569,37 +5569,37 @@ lookup_template_class (tree d1,\n \n       if (CLASSTYPE_TEMPLATE_INFO (type))\n \t{\n-\t  template = CLASSTYPE_TI_TEMPLATE (type);\n-\t  d1 = DECL_NAME (template);\n+\t  templ = CLASSTYPE_TI_TEMPLATE (type);\n+\t  d1 = DECL_NAME (templ);\n \t}\n     }\n   else if (TREE_CODE (d1) == ENUMERAL_TYPE\n \t   || (TYPE_P (d1) && MAYBE_CLASS_TYPE_P (d1)))\n     {\n-      template = TYPE_TI_TEMPLATE (d1);\n-      d1 = DECL_NAME (template);\n+      templ = TYPE_TI_TEMPLATE (d1);\n+      d1 = DECL_NAME (templ);\n     }\n   else if (TREE_CODE (d1) == TEMPLATE_DECL\n \t   && TREE_CODE (DECL_TEMPLATE_RESULT (d1)) == TYPE_DECL)\n     {\n-      template = d1;\n-      d1 = DECL_NAME (template);\n-      context = DECL_CONTEXT (template);\n+      templ = d1;\n+      d1 = DECL_NAME (templ);\n+      context = DECL_CONTEXT (templ);\n     }\n \n   /* Issue an error message if we didn't find a template.  */\n-  if (! template)\n+  if (! templ)\n     {\n       if (complain & tf_error)\n \terror (\"%qT is not a template\", d1);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n-  if (TREE_CODE (template) != TEMPLATE_DECL\n+  if (TREE_CODE (templ) != TEMPLATE_DECL\n \t /* Make sure it's a user visible template, if it was named by\n \t    the user.  */\n-      || ((complain & tf_user) && !DECL_TEMPLATE_PARM_P (template)\n-\t  && !PRIMARY_TEMPLATE_P (template)))\n+      || ((complain & tf_user) && !DECL_TEMPLATE_PARM_P (templ)\n+\t  && !PRIMARY_TEMPLATE_P (templ)))\n     {\n       if (complain & tf_error)\n \t{\n@@ -5612,7 +5612,7 @@ lookup_template_class (tree d1,\n \n   complain &= ~tf_user;\n \n-  if (DECL_TEMPLATE_TEMPLATE_PARM_P (template))\n+  if (DECL_TEMPLATE_TEMPLATE_PARM_P (templ))\n     {\n       /* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store\n \t template arguments */\n@@ -5621,7 +5621,7 @@ lookup_template_class (tree d1,\n       tree arglist2;\n       tree outer;\n \n-      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n+      parmlist = DECL_INNERMOST_TEMPLATE_PARMS (templ);\n \n       /* Consider an example where a template template parameter declared as\n \n@@ -5639,7 +5639,7 @@ lookup_template_class (tree d1,\n \t level 1, and T at level 2, while the template arguments at level 1\n \t becomes {std::vector} and the inner level 2 is {int}.  */\n \n-      outer = DECL_CONTEXT (template);\n+      outer = DECL_CONTEXT (templ);\n       if (outer)\n \touter = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (outer)));\n       else if (current_template_parms)\n@@ -5650,29 +5650,29 @@ lookup_template_class (tree d1,\n       if (outer)\n \targlist = add_to_template_args (outer, arglist);\n \n-      arglist2 = coerce_template_parms (parmlist, arglist, template,\n+      arglist2 = coerce_template_parms (parmlist, arglist, templ,\n \t\t\t\t\tcomplain,\n \t\t\t\t\t/*require_all_args=*/true,\n \t\t\t\t\t/*use_default_args=*/true);\n       if (arglist2 == error_mark_node\n \t  || (!uses_template_parms (arglist2)\n-\t      && check_instantiated_args (template, arglist2, complain)))\n+\t      && check_instantiated_args (templ, arglist2, complain)))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n-      parm = bind_template_template_parm (TREE_TYPE (template), arglist2);\n+      parm = bind_template_template_parm (TREE_TYPE (templ), arglist2);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, parm);\n     }\n   else\n     {\n-      tree template_type = TREE_TYPE (template);\n+      tree template_type = TREE_TYPE (templ);\n       tree gen_tmpl;\n       tree type_decl;\n       tree found = NULL_TREE;\n       int arg_depth;\n       int parm_depth;\n       int is_partial_instantiation;\n \n-      gen_tmpl = most_general_template (template);\n+      gen_tmpl = most_general_template (templ);\n       parmlist = DECL_TEMPLATE_PARMS (gen_tmpl);\n       parm_depth = TMPL_PARMS_DEPTH (parmlist);\n       arg_depth = TMPL_ARGS_DEPTH (arglist);\n@@ -5692,7 +5692,7 @@ lookup_template_class (tree d1,\n \t     <class U> struct S1<T>::S2'.  We must fill in the missing\n \t     arguments.  */\n \t  arglist\n-\t    = add_outermost_template_args (TYPE_TI_ARGS (TREE_TYPE (template)),\n+\t    = add_outermost_template_args (TYPE_TI_ARGS (TREE_TYPE (templ)),\n \t\t\t\t\t   arglist);\n \t  arg_depth = TMPL_ARGS_DEPTH (arglist);\n \t}\n@@ -5702,7 +5702,7 @@ lookup_template_class (tree d1,\n \n       /* From here on, we're only interested in the most general\n \t template.  */\n-      template = gen_tmpl;\n+      templ = gen_tmpl;\n \n       /* Calculate the BOUND_ARGS.  These will be the args that are\n \t actually tsubst'd into the definition to create the\n@@ -5716,12 +5716,12 @@ lookup_template_class (tree d1,\n \t  tree bound_args = make_tree_vec (parm_depth);\n \n \t  for (i = saved_depth,\n-\t\t t = DECL_TEMPLATE_PARMS (template);\n+\t\t t = DECL_TEMPLATE_PARMS (templ);\n \t       i > 0 && t != NULL_TREE;\n \t       --i, t = TREE_CHAIN (t))\n \t    {\n \t      tree a = coerce_template_parms (TREE_VALUE (t),\n-\t\t\t\t\t      arglist, template,\n+\t\t\t\t\t      arglist, templ,\n \t\t\t\t\t      complain,\n \t\t\t\t\t      /*require_all_args=*/true,\n \t\t\t\t\t      /*use_default_args=*/true);\n@@ -5752,7 +5752,7 @@ lookup_template_class (tree d1,\n \targlist\n \t  = coerce_template_parms (INNERMOST_TEMPLATE_PARMS (parmlist),\n \t\t\t\t   INNERMOST_TEMPLATE_ARGS (arglist),\n-\t\t\t\t   template,\n+\t\t\t\t   templ,\n \t\t\t\t   complain,\n \t\t\t\t   /*require_all_args=*/true,\n \t\t\t\t   /*use_default_args=*/true);\n@@ -5774,7 +5774,7 @@ lookup_template_class (tree d1,\n \t{\n \t  found = template_type;\n \n-\t  if (!entering_scope && PRIMARY_TEMPLATE_P (template))\n+\t  if (!entering_scope && PRIMARY_TEMPLATE_P (templ))\n \t    {\n \t      tree ctx;\n \n@@ -5796,7 +5796,7 @@ lookup_template_class (tree d1,\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \n       /* If we already have this specialization, return it.  */\n-      found = retrieve_specialization (template, arglist,\n+      found = retrieve_specialization (templ, arglist,\n \t\t\t\t       /*class_specializations_p=*/false);\n       if (found)\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n@@ -5810,22 +5810,22 @@ lookup_template_class (tree d1,\n       /* If the deduced arguments are invalid, then the binding\n \t failed.  */\n       if (!is_partial_instantiation\n-\t  && check_instantiated_args (template,\n+\t  && check_instantiated_args (templ,\n \t\t\t\t      INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t      complain))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n       if (!is_partial_instantiation\n-\t  && !PRIMARY_TEMPLATE_P (template)\n-\t  && TREE_CODE (CP_DECL_CONTEXT (template)) == NAMESPACE_DECL)\n+\t  && !PRIMARY_TEMPLATE_P (templ)\n+\t  && TREE_CODE (CP_DECL_CONTEXT (templ)) == NAMESPACE_DECL)\n \t{\n-\t  found = xref_tag_from_type (TREE_TYPE (template),\n-\t\t\t\t      DECL_NAME (template),\n+\t  found = xref_tag_from_type (TREE_TYPE (templ),\n+\t\t\t\t      DECL_NAME (templ),\n \t\t\t\t      /*tag_scope=*/ts_global);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \t}\n \n-      context = tsubst (DECL_CONTEXT (template), arglist,\n+      context = tsubst (DECL_CONTEXT (templ), arglist,\n \t\t\tcomplain, in_decl);\n       if (!context)\n \tcontext = global_namespace;\n@@ -5855,7 +5855,7 @@ lookup_template_class (tree d1,\n \n \t  /* A local class.  Make sure the decl gets registered properly.  */\n \t  if (context == current_function_decl)\n-\t    pushtag (DECL_NAME (template), t, /*tag_scope=*/ts_current);\n+\t    pushtag (DECL_NAME (templ), t, /*tag_scope=*/ts_current);\n \n \t  if (comp_template_args (CLASSTYPE_TI_ARGS (template_type), arglist))\n \t    /* This instantiation is another name for the primary\n@@ -5875,7 +5875,7 @@ lookup_template_class (tree d1,\n \t{\n \t  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n \n-\t  type_decl = create_implicit_typedef (DECL_NAME (template), t);\n+\t  type_decl = create_implicit_typedef (DECL_NAME (templ), t);\n \t  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (t);\n \t  TYPE_STUB_DECL (t) = type_decl;\n \t  DECL_SOURCE_LOCATION (type_decl)\n@@ -5889,7 +5889,7 @@ lookup_template_class (tree d1,\n       TREE_PROTECTED (type_decl)\n \t= TREE_PROTECTED (TYPE_STUB_DECL (template_type));\n       DECL_IN_SYSTEM_HEADER (type_decl)\n-\t= DECL_IN_SYSTEM_HEADER (template);\n+\t= DECL_IN_SYSTEM_HEADER (templ);\n       if (CLASSTYPE_VISIBILITY_SPECIFIED (template_type))\n \t{\n \t  DECL_VISIBILITY_SPECIFIED (type_decl) = 1;\n@@ -5900,15 +5900,15 @@ lookup_template_class (tree d1,\n \t template is the immediate parent if this is a full\n \t instantiation.  */\n       if (parm_depth == 1 || is_partial_instantiation\n-\t  || !PRIMARY_TEMPLATE_P (template))\n+\t  || !PRIMARY_TEMPLATE_P (templ))\n \t/* This case is easy; there are no member templates involved.  */\n-\tfound = template;\n+\tfound = templ;\n       else\n \t{\n \t  /* This is a full instantiation of a member template.  Look\n \t     for a partial instantiation of which this is an instance.  */\n \n-\t  for (found = DECL_TEMPLATE_INSTANTIATIONS (template);\n+\t  for (found = DECL_TEMPLATE_INSTANTIATIONS (templ);\n \t       found; found = TREE_CHAIN (found))\n \t    {\n \t      int success;\n@@ -5953,15 +5953,15 @@ lookup_template_class (tree d1,\n \t\t Create the partial instantiation.\n \t       */\n \t      TREE_VEC_LENGTH (arglist)--;\n-\t      found = tsubst (template, arglist, complain, NULL_TREE);\n+\t      found = tsubst (templ, arglist, complain, NULL_TREE);\n \t      TREE_VEC_LENGTH (arglist)++;\n \t    }\n \t}\n \n       SET_TYPE_TEMPLATE_INFO (t, tree_cons (found, arglist, NULL_TREE));\n-      DECL_TEMPLATE_INSTANTIATIONS (template)\n+      DECL_TEMPLATE_INSTANTIATIONS (templ)\n \t= tree_cons (arglist, t,\n-\t\t     DECL_TEMPLATE_INSTANTIATIONS (template));\n+\t\t     DECL_TEMPLATE_INSTANTIATIONS (templ));\n \n       if (TREE_CODE (t) == ENUMERAL_TYPE\n \t  && !is_partial_instantiation)\n@@ -6292,7 +6292,7 @@ static int last_template_error_tick;\n static int\n push_tinst_level (tree d)\n {\n-  struct tinst_level *new;\n+  struct tinst_level *new_level;\n \n   if (tinst_depth >= max_tinst_depth)\n     {\n@@ -6312,12 +6312,12 @@ push_tinst_level (tree d)\n       return 0;\n     }\n \n-  new = GGC_NEW (struct tinst_level);\n-  new->decl = d;\n-  new->locus = input_location;\n-  new->in_system_header_p = in_system_header;\n-  new->next = current_tinst_level;\n-  current_tinst_level = new;\n+  new_level = GGC_NEW (struct tinst_level);\n+  new_level->decl = d;\n+  new_level->locus = input_location;\n+  new_level->in_system_header_p = in_system_header;\n+  new_level->next = current_tinst_level;\n+  current_tinst_level = new_level;\n \n   ++tinst_depth;\n #ifdef GATHER_STATISTICS\n@@ -6839,7 +6839,7 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n tree\n instantiate_class_template (tree type)\n {\n-  tree template, args, pattern, t, member;\n+  tree templ, args, pattern, t, member;\n   tree typedecl;\n   tree pbinfo;\n   tree base_list;\n@@ -6853,12 +6853,12 @@ instantiate_class_template (tree type)\n     return type;\n \n   /* Figure out which template is being instantiated.  */\n-  template = most_general_template (CLASSTYPE_TI_TEMPLATE (type));\n-  gcc_assert (TREE_CODE (template) == TEMPLATE_DECL);\n+  templ = most_general_template (CLASSTYPE_TI_TEMPLATE (type));\n+  gcc_assert (TREE_CODE (templ) == TEMPLATE_DECL);\n \n   /* Determine what specialization of the original template to\n      instantiate.  */\n-  t = most_specialized_class (type, template);\n+  t = most_specialized_class (type, templ);\n   if (t == error_mark_node)\n     {\n       TYPE_BEING_DEFINED (type) = 1;\n@@ -6881,7 +6881,7 @@ instantiate_class_template (tree type)\n     }\n   else\n     {\n-      pattern = TREE_TYPE (template);\n+      pattern = TREE_TYPE (templ);\n       args = CLASSTYPE_TI_ARGS (type);\n     }\n \n@@ -7303,7 +7303,7 @@ instantiate_class_template (tree type)\n   /* Now that the class is complete, instantiate default arguments for\n      any member functions.  We don't do this earlier because the\n      default arguments may reference members of the class.  */\n-  if (!PRIMARY_TEMPLATE_P (template))\n+  if (!PRIMARY_TEMPLATE_P (templ))\n     for (t = TYPE_METHODS (type); t; t = TREE_CHAIN (t))\n       if (TREE_CODE (t) == FUNCTION_DECL\n \t  /* Implicitly generated member functions will not have template\n@@ -10943,26 +10943,26 @@ tsubst_copy_and_build (tree t,\n     case TEMPLATE_ID_EXPR:\n       {\n \ttree object;\n-\ttree template = RECUR (TREE_OPERAND (t, 0));\n+\ttree templ = RECUR (TREE_OPERAND (t, 0));\n \ttree targs = TREE_OPERAND (t, 1);\n \n \tif (targs)\n \t  targs = tsubst_template_args (targs, args, complain, in_decl);\n \n-\tif (TREE_CODE (template) == COMPONENT_REF)\n+\tif (TREE_CODE (templ) == COMPONENT_REF)\n \t  {\n-\t    object = TREE_OPERAND (template, 0);\n-\t    template = TREE_OPERAND (template, 1);\n+\t    object = TREE_OPERAND (templ, 0);\n+\t    templ = TREE_OPERAND (templ, 1);\n \t  }\n \telse\n \t  object = NULL_TREE;\n-\ttemplate = lookup_template_function (template, targs);\n+\ttempl = lookup_template_function (templ, targs);\n \n \tif (object)\n-\t  return build3 (COMPONENT_REF, TREE_TYPE (template),\n-\t\t\t object, template, NULL_TREE);\n+\t  return build3 (COMPONENT_REF, TREE_TYPE (templ),\n+\t\t\t object, templ, NULL_TREE);\n \telse\n-\t  return baselink_for_fns (template);\n+\t  return baselink_for_fns (templ);\n       }\n \n     case INDIRECT_REF:"}, {"sha": "b288c5bbfca170ccb370037f3cba80e6c5c05f1f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -2594,17 +2594,17 @@ stabilize_expr (tree exp, tree* initp)\n   return exp;\n }\n \n-/* Add NEW, an expression whose value we don't care about, after the\n+/* Add NEW_EXPR, an expression whose value we don't care about, after the\n    similar expression ORIG.  */\n \n tree\n-add_stmt_to_compound (tree orig, tree new)\n+add_stmt_to_compound (tree orig, tree new_expr)\n {\n-  if (!new || !TREE_SIDE_EFFECTS (new))\n+  if (!new_expr || !TREE_SIDE_EFFECTS (new_expr))\n     return orig;\n   if (!orig || !TREE_SIDE_EFFECTS (orig))\n-    return new;\n-  return build2 (COMPOUND_EXPR, void_type_node, orig, new);\n+    return new_expr;\n+  return build2 (COMPOUND_EXPR, void_type_node, orig, new_expr);\n }\n \n /* Like stabilize_expr, but for a call whose arguments we want to"}, {"sha": "ad297106a6ee647e5fd5ed74d58d1f2ac090526e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be93747e8b27f86a1df8b30b050daae5c63206d0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=be93747e8b27f86a1df8b30b050daae5c63206d0", "patch": "@@ -2315,10 +2315,10 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \n       if (is_template_id)\n \t{\n-\t  tree template = member;\n+\t  tree templ = member;\n \n-\t  if (BASELINK_P (template))\n-\t    template = lookup_template_function (template, template_args);\n+\t  if (BASELINK_P (templ))\n+\t    templ = lookup_template_function (templ, template_args);\n \t  else\n \t    {\n \t      if (complain & tf_error)"}]}