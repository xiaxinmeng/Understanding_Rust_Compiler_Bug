{"sha": "9a8bd0b556b1a5ec3f6029ce80860b6675a09b33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4YmQwYjU1NmIxYTVlYzNmNjAyOWNlODA4NjBiNjY3NWEwOWIzMw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-04-06T09:21:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:21:48Z"}, "message": "g-alleve.ads (Low Level Vector type definitions): Map each to the associated vector view instead of all to the unsigned char view.\n\n2007-04-06  Olivier Hainque  <hainque@adacore.com>\n\n\t* g-alleve.ads (Low Level Vector type definitions): Map each to the\n\tassociated vector view instead of all to the unsigned char view.\n\n\t* g-altcon.adb (Generic_Conversions): New internal generic package,\n\toffering facilities for all the Vector/View conversion routines\n\timplemented by this unit.\n\t(To_View/To_Vector - all versions): Reimplemented in a systematic\n\tmanner, using the internal Generic_Conversions facilities.\n\nFrom-SVN: r123570", "tree": {"sha": "691ebf2fdb079444a5d5ec8c36b0636377d76556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/691ebf2fdb079444a5d5ec8c36b0636377d76556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aad93b553795dbdb0ebc03051bd6c638bfe6a785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aad93b553795dbdb0ebc03051bd6c638bfe6a785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aad93b553795dbdb0ebc03051bd6c638bfe6a785"}], "stats": {"total": 565, "additions": 297, "deletions": 268}, "files": [{"sha": "255949058741751749aa16a7a4ab6904f1567e43", "filename": "gcc/ada/g-alleve.ads", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33/gcc%2Fada%2Fg-alleve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33/gcc%2Fada%2Fg-alleve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-alleve.ads?ref=9a8bd0b556b1a5ec3f6029ce80860b6675a09b33", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                         (Soft Binding Version)                           --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -317,21 +317,20 @@ private\n    --  We simply use the natural array definitions corresponding to each\n    --  user-level vector type.\n \n-   type LL_VUI is new VUC_View;\n-   type LL_VSI is new VUC_View;\n+   type LL_VUI is new VUI_View;\n+   type LL_VSI is new VSI_View;\n+   type LL_VBI is new VBI_View;\n \n-   type LL_VUS is new VUC_View;\n-   type LL_VSS is new VUC_View;\n+   type LL_VUS is new VUS_View;\n+   type LL_VSS is new VSS_View;\n+   type LL_VBS is new VBS_View;\n \n    type LL_VUC is new VUC_View;\n-   type LL_VSC is new VUC_View;\n+   type LL_VSC is new VSC_View;\n+   type LL_VBC is new VBC_View;\n \n-   type LL_VF is new VUC_View;\n-\n-   type LL_VBC is new VUC_View;\n-   type LL_VBS is new VUC_View;\n-   type LL_VBI is new VUC_View;\n-   type LL_VP is new VUC_View;\n+   type LL_VF is new VF_View;\n+   type LL_VP is new VP_View;\n \n    ------------------------------------\n    -- Low level functional interface --"}, {"sha": "a1f2d3f3e583b04e7540a382c85984de922fd8c3", "filename": "gcc/ada/g-altcon.adb", "status": "modified", "additions": 286, "deletions": 256, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33/gcc%2Fada%2Fg-altcon.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8bd0b556b1a5ec3f6029ce80860b6675a09b33/gcc%2Fada%2Fg-altcon.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-altcon.adb?ref=9a8bd0b556b1a5ec3f6029ce80860b6675a09b33", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2005, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2005-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,450 +35,480 @@ with Ada.Unchecked_Conversion;\n \n with System; use System;\n \n-with GNAT.Altivec.Low_Level_Interface; use GNAT.Altivec.Low_Level_Interface;\n-with GNAT.Altivec.Low_Level_Vectors;   use GNAT.Altivec.Low_Level_Vectors;\n-\n package body GNAT.Altivec.Conversions is\n \n-   function To_Varray_unsigned_char is\n-     new Ada.Unchecked_Conversion (Varray_signed_char,\n-                                   Varray_unsigned_char);\n-\n-   function To_Varray_unsigned_char is\n-     new Ada.Unchecked_Conversion (Varray_bool_char,\n-                                   Varray_unsigned_char);\n-\n-   function To_Varray_unsigned_short is\n-     new Ada.Unchecked_Conversion (Varray_signed_short,\n-                                   Varray_unsigned_short);\n-\n-   function To_Varray_unsigned_short is\n-     new Ada.Unchecked_Conversion (Varray_bool_short,\n-                                   Varray_unsigned_short);\n-\n-   function To_Varray_unsigned_short is\n-      new Ada.Unchecked_Conversion (Varray_pixel,\n-                                    Varray_unsigned_short);\n-\n-   function To_Varray_unsigned_int is\n-     new Ada.Unchecked_Conversion (Varray_signed_int,\n-                                   Varray_unsigned_int);\n-\n-   function To_Varray_unsigned_int is\n-     new Ada.Unchecked_Conversion (Varray_bool_int,\n-                                   Varray_unsigned_int);\n-\n-   function To_Varray_unsigned_int is\n-      new Ada.Unchecked_Conversion (Varray_float,\n-                                    Varray_unsigned_int);\n-\n-   function To_Varray_signed_char is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_char,\n-                                   Varray_signed_char);\n-\n-   function To_Varray_bool_char is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_char,\n-                                   Varray_bool_char);\n-\n-   function To_Varray_signed_short is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_short,\n-                                   Varray_signed_short);\n-\n-   function To_Varray_bool_short is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_short,\n-                                   Varray_bool_short);\n-\n-   function To_Varray_pixel is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_short,\n-                                   Varray_pixel);\n-\n-   function To_Varray_signed_int is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_int,\n-                                   Varray_signed_int);\n-\n-   function To_Varray_bool_int is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_int,\n-                                   Varray_bool_int);\n-\n-   function To_Varray_float is\n-     new Ada.Unchecked_Conversion (Varray_unsigned_int,\n-                                   Varray_float);\n-\n-   function To_VUC is new Ada.Unchecked_Conversion (VUC_View, VUC);\n-   function To_VSC is new Ada.Unchecked_Conversion (VSC_View, VSC);\n-   function To_VBC is new Ada.Unchecked_Conversion (VBC_View, VBC);\n-   function To_VUS is new Ada.Unchecked_Conversion (VUS_View, VUS);\n-   function To_VSS is new Ada.Unchecked_Conversion (VSS_View, VSS);\n-   function To_VBS is new Ada.Unchecked_Conversion (VBS_View, VBS);\n-   function To_VUI is new Ada.Unchecked_Conversion (VUI_View, VUI);\n-   function To_VSI is new Ada.Unchecked_Conversion (VSI_View, VSI);\n-   function To_VBI is new Ada.Unchecked_Conversion (VBI_View, VBI);\n-   function To_VF  is new Ada.Unchecked_Conversion (VF_View,  VF);\n-   function To_VP  is new Ada.Unchecked_Conversion (VP_View,  VP);\n-\n-   function To_VUC_View is new Ada.Unchecked_Conversion (VUC, VUC_View);\n-   function To_VSC_View is new Ada.Unchecked_Conversion (VSC, VSC_View);\n-   function To_VBC_View is new Ada.Unchecked_Conversion (VBC, VBC_View);\n-   function To_VUS_View is new Ada.Unchecked_Conversion (VUS, VUS_View);\n-   function To_VSS_View is new Ada.Unchecked_Conversion (VSS, VSS_View);\n-   function To_VBS_View is new Ada.Unchecked_Conversion (VBS, VBS_View);\n-   function To_VUI_View is new Ada.Unchecked_Conversion (VUI, VUI_View);\n-   function To_VSI_View is new Ada.Unchecked_Conversion (VSI, VSI_View);\n-   function To_VBI_View is new Ada.Unchecked_Conversion (VBI, VBI_View);\n-   function To_VF_View  is new Ada.Unchecked_Conversion (VF,  VF_View);\n-   function To_VP_View  is new Ada.Unchecked_Conversion (VP,  VP_View);\n-\n-   pragma Warnings (Off, Default_Bit_Order);\n-\n-   ---------------\n-   -- To_Vector --\n-   ---------------\n+   --  All the vector/view conversions operate similarily: bare unchecked\n+   --  conversion on big endian targets, and elements permutation on little\n+   --  endian targets. We call \"Mirroring\" the elements permutation process.\n+\n+   --  We would like to provide a generic version of the conversion routines\n+   --  and just have a set of \"renaming as body\" declarations to satisfy the\n+   --  public interface. This unfortunately prevents inlining, which we must\n+   --  preserve at least for the hard binding.\n+\n+   --  We instead provide a generic version of facilities needed by all the\n+   --  conversion routines and use them repeatedly.\n+\n+   generic\n+      type Vitem_Type is private;\n+\n+      type Varray_Index_Type is range <>;\n+      type Varray_Type is array (Varray_Index_Type) of Vitem_Type;\n+\n+      type Vector_Type is private;\n+      type View_Type is private;\n+\n+   package Generic_Conversions is\n+\n+      subtype Varray is Varray_Type;\n+      --  This provides an easy common way to refer to the type parameter\n+      --  in contexts where a specific instance of this package is \"use\"d.\n+\n+      procedure Mirror (A : Varray_Type; Into : out Varray_Type);\n+      pragma Inline (Mirror);\n+      --  Mirror the elements of A into INTO, not touching the per-element\n+      --  internal ordering.\n+\n+      --  A procedure with an out parameter is a bit heavier to use than a\n+      --  function but reduces the amount of temporary creations around the\n+      --  call. Instances are typically not front-end inlined. They can still\n+      --  be back-end inlined on request with the proper command-line option.\n+\n+      --  Below are Unchecked Conversion routines for various purposes,\n+      --  relying on internal knowledge about the bits layout in the different\n+      --  types (all 128 value bits blocks).\n+\n+      --  View<->Vector straight bitwise conversions on BE targets.\n+\n+      function UNC_To_Vector is\n+         new Ada.Unchecked_Conversion (View_Type, Vector_Type);\n+\n+      function UNC_To_View is\n+         new Ada.Unchecked_Conversion (Vector_Type, View_Type);\n+\n+      --  Varray->Vector/View for returning mirrored results on LE targets.\n+\n+      function UNC_To_Vector is\n+         new Ada.Unchecked_Conversion (Varray_Type, Vector_Type);\n+\n+      function UNC_To_View is\n+         new Ada.Unchecked_Conversion (Varray_Type, View_Type);\n+\n+      --  Vector/View->Varray for to-be-permuted source on LE targets.\n+\n+      function UNC_To_Varray is\n+         new Ada.Unchecked_Conversion (Vector_Type, Varray_Type);\n+\n+      function UNC_To_Varray is\n+         new Ada.Unchecked_Conversion (View_Type, Varray_Type);\n+\n+   end Generic_Conversions;\n+\n+   package body Generic_Conversions is\n+\n+      procedure Mirror (A : Varray_Type; Into : out Varray_Type) is\n+      begin\n+         for J in A'Range loop\n+            Into (J) := A (A'Last - J + A'First);\n+         end loop;\n+      end Mirror;\n+\n+   end Generic_Conversions;\n+\n+   --  Now we declare the instances and implement the interface function\n+   --  bodies simply calling the instantiated routines.\n+\n+   ---------------------\n+   -- Char components --\n+   ---------------------\n+\n+   package SC_Conversions is new Generic_Conversions\n+     (signed_char, Vchar_Range, Varray_signed_char, VSC, VSC_View);\n \n    function To_Vector (S : VSC_View) return VSC is\n+      use SC_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VSC (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : LL_VUC;\n-            VS     : constant VUC_View :=\n-                       (Values => To_Varray_unsigned_char (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VSC (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n    end To_Vector;\n \n-   function To_Vector (S : VBC_View) return VBC is\n+   function To_View (S : VSC) return VSC_View is\n+      use SC_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VBC (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : LL_VUC;\n-            VS     : constant VUC_View :=\n-                       (Values => To_Varray_unsigned_char (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VBC (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n-   end To_Vector;\n+   end To_View;\n \n-   function To_Vector (S : VSS_View) return VSS is\n+   --\n+\n+   package UC_Conversions is new Generic_Conversions\n+     (unsigned_char, Vchar_Range, Varray_unsigned_char, VUC, VUC_View);\n+\n+   function To_Vector (S : VUC_View) return VUC is\n+      use UC_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VSS (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : LL_VUS;\n-            VS     : constant VUS_View :=\n-                       (Values => To_Varray_unsigned_short (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return VSS (To_LL_VSS (Result));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n    end To_Vector;\n \n-   function To_Vector (S : VBS_View) return VBS is\n+   function To_View (S : VUC) return VUC_View is\n+      use UC_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VBS (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : LL_VUS;\n-            VS     : constant VUS_View :=\n-                       (Values => To_Varray_unsigned_short (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VBS (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n-   end To_Vector;\n+   end To_View;\n \n-   function To_Vector (S : VP_View) return VP is\n+   --\n+\n+   package BC_Conversions is new Generic_Conversions\n+     (bool_char, Vchar_Range, Varray_bool_char, VBC, VBC_View);\n+\n+   function To_Vector (S : VBC_View) return VBC is\n+      use BC_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VP (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : LL_VUS;\n-            VS     : constant VUS_View :=\n-                       (Values => To_Varray_unsigned_short (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VP (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n    end To_Vector;\n \n-   function To_Vector (S : VSI_View) return VSI is\n+   function To_View (S : VBC) return VBC_View is\n+      use BC_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VSI (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : LL_VUI;\n-            VS     : constant VUI_View :=\n-                       (Values => To_Varray_unsigned_int (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VSI (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n-   end To_Vector;\n+   end To_View;\n \n-   function To_Vector (S : VBI_View) return VBI is\n+   ----------------------\n+   -- Short components --\n+   ----------------------\n+\n+   package SS_Conversions is new Generic_Conversions\n+     (signed_short, Vshort_Range, Varray_signed_short, VSS, VSS_View);\n+\n+   function To_Vector (S : VSS_View) return VSS is\n+      use SS_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VBI (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : LL_VUI;\n-            VS     : constant VUI_View :=\n-                       (Values => To_Varray_unsigned_int (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VBI (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n    end To_Vector;\n \n-   function To_Vector (S : VF_View) return VF is\n+   function To_View (S : VSS) return VSS_View is\n+      use SS_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VF (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : LL_VUI;\n-            VS     : constant VUI_View :=\n-                       (Values => To_Varray_unsigned_int (S.Values));\n+            M : Varray;\n          begin\n-            Result := To_Vector (VS);\n-            return To_LL_VF (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n-   end To_Vector;\n+   end To_View;\n \n-   function To_Vector (S : VUC_View) return VUC is\n+   --\n+\n+   package US_Conversions is new Generic_Conversions\n+     (unsigned_short, Vshort_Range, Varray_unsigned_short, VUS, VUS_View);\n+\n+   function To_Vector (S : VUS_View) return VUS is\n+      use US_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VUC (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : VUC_View;\n+            M : Varray;\n          begin\n-            for J in Vchar_Range'Range loop\n-               Result.Values (J) :=\n-                 S.Values (Vchar_Range'Last - J + Vchar_Range'First);\n-            end loop;\n-            return To_VUC (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n    end To_Vector;\n \n-   function To_Vector (S : VUS_View) return VUS is\n+   function To_View (S : VUS) return VUS_View is\n+      use US_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VUS (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : VUS_View;\n+            M : Varray;\n          begin\n-            for J in Vshort_Range'Range loop\n-               Result.Values (J) :=\n-                 S.Values (Vshort_Range'Last - J + Vshort_Range'First);\n-            end loop;\n-            return To_VUS (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n-   end To_Vector;\n+   end To_View;\n \n-   function To_Vector (S : VUI_View) return VUI is\n+   --\n+\n+   package BS_Conversions is new Generic_Conversions\n+     (bool_short, Vshort_Range, Varray_bool_short, VBS, VBS_View);\n+\n+   function To_Vector (S : VBS_View) return VBS is\n+      use BS_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VUI (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : VUI_View;\n+            M : Varray;\n          begin\n-            for J in Vint_Range'Range loop\n-               Result.Values (J) :=\n-                 S.Values (Vint_Range'Last - J + Vint_Range'First);\n-            end loop;\n-            return To_VUI (Result);\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n    end To_Vector;\n \n-   --------------\n-   -- To_View --\n-   --------------\n-\n-   function To_View (S : VSC) return VSC_View is\n+   function To_View (S : VBS) return VBS_View is\n+      use BS_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VSC_View (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : VUC_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUC (S));\n-            return (Values => To_Varray_signed_char (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n    end To_View;\n \n-   function To_View (S : VBC) return VBC_View is\n+   --------------------\n+   -- Int components --\n+   --------------------\n+\n+   package SI_Conversions is new Generic_Conversions\n+     (signed_int, Vint_Range, Varray_signed_int, VSI, VSI_View);\n+\n+   function To_Vector (S : VSI_View) return VSI is\n+      use SI_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VBC_View (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : VUC_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUC (S));\n-            return (Values => To_Varray_bool_char (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n-   end To_View;\n+   end To_Vector;\n \n-   function To_View (S : VSS) return VSS_View is\n+   function To_View (S : VSI) return VSI_View is\n+      use SI_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VSS_View (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : VUS_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUS (S));\n-            return (Values => To_Varray_signed_short (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n    end To_View;\n \n-   function To_View (S : VBS) return VBS_View is\n+   --\n+\n+   package UI_Conversions is new Generic_Conversions\n+     (unsigned_int, Vint_Range, Varray_unsigned_int, VUI, VUI_View);\n+\n+   function To_Vector (S : VUI_View) return VUI is\n+      use UI_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VBS_View (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : VUS_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUS (S));\n-            return (Values => To_Varray_bool_short (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n-   end To_View;\n+   end To_Vector;\n \n-   function To_View (S : VP) return VP_View is\n+   function To_View (S : VUI) return VUI_View is\n+      use UI_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VP_View (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : VUS_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUS (S));\n-            return (Values => To_Varray_pixel (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n    end To_View;\n \n-   function To_View (S : VSI) return VSI_View is\n+   --\n+\n+   package BI_Conversions is new Generic_Conversions\n+     (bool_int, Vint_Range, Varray_bool_int, VBI, VBI_View);\n+\n+   function To_Vector (S : VBI_View) return VBI is\n+      use BI_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VSI_View (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : VUI_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUI (S));\n-            return (Values => To_Varray_signed_int (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n-   end To_View;\n+   end To_Vector;\n \n    function To_View (S : VBI) return VBI_View is\n+      use BI_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VBI_View (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            Result : VUI_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUI (S));\n-            return (Values => To_Varray_bool_int (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n    end To_View;\n \n-   function To_View (S : VF) return VF_View is\n+   ----------------------\n+   -- Float components --\n+   ----------------------\n+\n+   package F_Conversions is new Generic_Conversions\n+     (C_float, Vfloat_Range, Varray_float, VF, VF_View);\n+\n+   function To_Vector (S : VF_View) return VF is\n+      use F_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VF_View (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            Result : VUI_View;\n+            M : Varray;\n          begin\n-            Result := To_View (To_LL_VUI (S));\n-            return (Values => To_Varray_float (Result.Values));\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n-   end To_View;\n+   end To_Vector;\n \n-   function To_View (S : VUC) return VUC_View is\n+   function To_View (S : VF) return VF_View is\n+      use F_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VUC_View (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            VS     : constant VUC_View := To_VUC_View (S);\n-            Result : VUC_View;\n+            M : Varray;\n          begin\n-            for J in Vchar_Range'Range loop\n-               Result.Values (J) :=\n-                 VS.Values (Vchar_Range'Last - J + Vchar_Range'First);\n-            end loop;\n-            return Result;\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n    end To_View;\n \n-   function To_View (S : VUS) return VUS_View is\n+   ----------------------\n+   -- Pixel components --\n+   ----------------------\n+\n+   package P_Conversions is new Generic_Conversions\n+     (pixel, Vpixel_Range, Varray_pixel, VP, VP_View);\n+\n+   function To_Vector (S : VP_View) return VP is\n+      use P_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VUS_View (S);\n+         return UNC_To_Vector (S);\n       else\n          declare\n-            VS     : constant VUS_View := To_VUS_View (S);\n-            Result : VUS_View;\n+            M : Varray;\n          begin\n-            for J in Vshort_Range'Range loop\n-               Result.Values (J) :=\n-                 VS.Values (Vshort_Range'Last - J + Vshort_Range'First);\n-            end loop;\n-            return Result;\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_Vector (M);\n          end;\n       end if;\n-   end To_View;\n+   end To_Vector;\n \n-   function To_View (S : VUI) return VUI_View is\n+   function To_View (S : VP) return VP_View is\n+      use P_Conversions;\n    begin\n       if Default_Bit_Order = High_Order_First then\n-         return To_VUI_View (S);\n+         return UNC_To_View (S);\n       else\n          declare\n-            VS     : constant VUI_View := To_VUI_View (S);\n-            Result : VUI_View;\n+            M : Varray;\n          begin\n-            for J in Vint_Range'Range loop\n-               Result.Values (J) :=\n-                 VS.Values (Vint_Range'Last - J + Vint_Range'First);\n-            end loop;\n-            return Result;\n+            Mirror (UNC_To_Varray (S), Into => M);\n+            return UNC_To_View (M);\n          end;\n       end if;\n    end To_View;"}]}