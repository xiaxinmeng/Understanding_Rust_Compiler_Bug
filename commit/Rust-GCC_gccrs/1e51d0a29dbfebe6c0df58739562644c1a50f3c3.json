{"sha": "1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU1MWQwYTI5ZGJmZWJlNmMwZGY1ODczOTU2MjY0NGMxYTUwZjNjMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-09T11:27:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-09T11:27:00Z"}, "message": "match.pd: Add patterns convering two conversions in a row from fold-const.c.\n\n2014-11-09  Richard Biener  <rguenther@suse.de>\n\n\t* match.pd: Add patterns convering two conversions in a row\n\tfrom fold-const.c.\n\t* fold-const.c (fold_unary_loc): Remove them here.\n\t* tree-ssa-forwprop.c (combine_conversions): Likewise.\n\t* genmatch.c (dt_node::gen_kids): Check whether we may\n\tfollow SSA use-def chains.\n\n\t* g++.dg/cpp0x/constexpr-reinterpret1.C: XFAIL.\n\t* gcc.dg/tree-ssa/pr21031.c: XFAIL.\n\nFrom-SVN: r217260", "tree": {"sha": "7253af53d7de307a8f840ca8e90e5e0acc5fa293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7253af53d7de307a8f840ca8e90e5e0acc5fa293"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dcd07febcafc7fd8a62d86f88aca1f6724f8a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcd07febcafc7fd8a62d86f88aca1f6724f8a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dcd07febcafc7fd8a62d86f88aca1f6724f8a24"}], "stats": {"total": 291, "additions": 111, "deletions": 180}, "files": [{"sha": "5f7edb2f69f2e79b4305dd6d675919970e8cfdbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -1,3 +1,12 @@\n+2014-11-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* match.pd: Add patterns convering two conversions in a row\n+\tfrom fold-const.c.\n+\t* fold-const.c (fold_unary_loc): Remove them here.\n+\t* tree-ssa-forwprop.c (combine_conversions): Likewise.\n+\t* genmatch.c (dt_node::gen_kids): Check whether we may\n+\tfollow SSA use-def chains.\n+\n 2014-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c: Include rtl-iter.h."}, {"sha": "13faf0c524accaf3375dbd13b81d88a8a69d30f2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -7692,94 +7692,6 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t\t\t       constant_boolean_node (false, type));\n \t}\n \n-      /* Handle cases of two conversions in a row.  */\n-      if (CONVERT_EXPR_P (op0))\n-\t{\n-\t  tree inside_type = TREE_TYPE (TREE_OPERAND (op0, 0));\n-\t  tree inter_type = TREE_TYPE (op0);\n-\t  int inside_int = INTEGRAL_TYPE_P (inside_type);\n-\t  int inside_ptr = POINTER_TYPE_P (inside_type);\n-\t  int inside_float = FLOAT_TYPE_P (inside_type);\n-\t  int inside_vec = TREE_CODE (inside_type) == VECTOR_TYPE;\n-\t  unsigned int inside_prec = TYPE_PRECISION (inside_type);\n-\t  int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n-\t  int inter_int = INTEGRAL_TYPE_P (inter_type);\n-\t  int inter_ptr = POINTER_TYPE_P (inter_type);\n-\t  int inter_float = FLOAT_TYPE_P (inter_type);\n-\t  int inter_vec = TREE_CODE (inter_type) == VECTOR_TYPE;\n-\t  unsigned int inter_prec = TYPE_PRECISION (inter_type);\n-\t  int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n-\t  int final_int = INTEGRAL_TYPE_P (type);\n-\t  int final_ptr = POINTER_TYPE_P (type);\n-\t  int final_float = FLOAT_TYPE_P (type);\n-\t  int final_vec = TREE_CODE (type) == VECTOR_TYPE;\n-\t  unsigned int final_prec = TYPE_PRECISION (type);\n-\t  int final_unsignedp = TYPE_UNSIGNED (type);\n-\n-\t  /* In addition to the cases of two conversions in a row\n-\t     handled below, if we are converting something to its own\n-\t     type via an object of identical or wider precision, neither\n-\t     conversion is needed.  */\n-\t  if (TYPE_MAIN_VARIANT (inside_type) == TYPE_MAIN_VARIANT (type)\n-\t      && (((inter_int || inter_ptr) && final_int)\n-\t\t  || (inter_float && final_float))\n-\t      && inter_prec >= final_prec)\n-\t    return fold_build1_loc (loc, code, type, TREE_OPERAND (op0, 0));\n-\n-\t  /* Likewise, if the intermediate and initial types are either both\n-\t     float or both integer, we don't need the middle conversion if the\n-\t     former is wider than the latter and doesn't change the signedness\n-\t     (for integers).  Avoid this if the final type is a pointer since\n-\t     then we sometimes need the middle conversion.  Likewise if the\n-\t     final type has a precision not equal to the size of its mode.  */\n-\t  if (((inter_int && inside_int)\n-\t       || (inter_float && inside_float)\n-\t       || (inter_vec && inside_vec))\n-\t      && inter_prec >= inside_prec\n-\t      && (inter_float || inter_vec\n-\t\t  || inter_unsignedp == inside_unsignedp)\n-\t      && ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type))\n-\t      && ! final_ptr\n-\t      && (! final_vec || inter_prec == inside_prec))\n-\t    return fold_build1_loc (loc, code, type, TREE_OPERAND (op0, 0));\n-\n-\t  /* If we have a sign-extension of a zero-extended value, we can\n-\t     replace that by a single zero-extension.  Likewise if the\n-\t     final conversion does not change precision we can drop the\n-\t     intermediate conversion.  */\n-\t  if (inside_int && inter_int && final_int\n-\t      && ((inside_prec < inter_prec && inter_prec < final_prec\n-\t\t   && inside_unsignedp && !inter_unsignedp)\n-\t\t  || final_prec == inter_prec))\n-\t    return fold_build1_loc (loc, code, type, TREE_OPERAND (op0, 0));\n-\n-\t  /* Two conversions in a row are not needed unless:\n-\t     - some conversion is floating-point (overstrict for now), or\n-\t     - some conversion is a vector (overstrict for now), or\n-\t     - the intermediate type is narrower than both initial and\n-\t       final, or\n-\t     - the intermediate type and innermost type differ in signedness,\n-\t       and the outermost type is wider than the intermediate, or\n-\t     - the initial type is a pointer type and the precisions of the\n-\t       intermediate and final types differ, or\n-\t     - the final type is a pointer type and the precisions of the\n-\t       initial and intermediate types differ.  */\n-\t  if (! inside_float && ! inter_float && ! final_float\n-\t      && ! inside_vec && ! inter_vec && ! final_vec\n-\t      && (inter_prec >= inside_prec || inter_prec >= final_prec)\n-\t      && ! (inside_int && inter_int\n-\t\t    && inter_unsignedp != inside_unsignedp\n-\t\t    && inter_prec < final_prec)\n-\t      && ((inter_unsignedp && inter_prec > inside_prec)\n-\t\t  == (final_unsignedp && final_prec > inter_prec))\n-\t      && ! (inside_ptr && inter_prec != final_prec)\n-\t      && ! (final_ptr && inside_prec != inter_prec)\n-\t      && ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t\t    && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n-\t    return fold_build1_loc (loc, code, type, TREE_OPERAND (op0, 0));\n-\t}\n-\n       /* Handle (T *)&A.B.C for A being of type T and B and C\n \t living at offset zero.  This occurs frequently in\n \t C++ upcasting and then accessing the base.  */"}, {"sha": "723de193ad5bdf65b7d3cd6ee98ca75a54bde046", "filename": "gcc/genmatch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -1615,7 +1615,7 @@ dt_operand::gen_gimple_expr (FILE *f)\n       else\n \tfprintf (f, \"tree %s = gimple_call_arg (def_stmt, %u);\\n\",\n \t\t child_opname, i);\n-      fprintf (f, \"if ((%s = do_valueize (valueize, %s)) != 0)\\n\",\n+      fprintf (f, \"if ((%s = do_valueize (valueize, %s)))\\n\",\n \t       child_opname, child_opname);\n       fprintf (f, \"{\\n\");\n     }\n@@ -1726,6 +1726,7 @@ dt_node::gen_kids (FILE *f, bool gimple)\n   if (exprs_len || fns_len)\n     {\n       fprintf (f, \"case SSA_NAME:\\n\");\n+      fprintf (f, \"if (do_valueize (valueize, %s) != NULL_TREE)\\n\", kid_opname);\n       fprintf (f, \"{\\n\");\n       fprintf (f, \"gimple def_stmt = SSA_NAME_DEF_STMT (%s);\\n\", kid_opname);\n "}, {"sha": "a847e820f6d70602e70544155a6b4c23da52507e", "filename": "gcc/match.pd", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -319,3 +319,96 @@ along with GCC; see the file COPYING3.  If not see\n (simplify\n  (paren (paren@1 @0))\n  @1)\n+\n+/* Handle cases of two conversions in a row.  */\n+(for ocvt (convert float fix_trunc)\n+ (for icvt (convert float)\n+  (simplify\n+   (ocvt (icvt@1 @0))\n+   (with\n+    {\n+      tree inside_type = TREE_TYPE (@0);\n+      tree inter_type = TREE_TYPE (@1);\n+      int inside_int = INTEGRAL_TYPE_P (inside_type);\n+      int inside_ptr = POINTER_TYPE_P (inside_type);\n+      int inside_float = FLOAT_TYPE_P (inside_type);\n+      int inside_vec = TREE_CODE (inside_type) == VECTOR_TYPE;\n+      unsigned int inside_prec = TYPE_PRECISION (inside_type);\n+      int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n+      int inter_int = INTEGRAL_TYPE_P (inter_type);\n+      int inter_ptr = POINTER_TYPE_P (inter_type);\n+      int inter_float = FLOAT_TYPE_P (inter_type);\n+      int inter_vec = TREE_CODE (inter_type) == VECTOR_TYPE;\n+      unsigned int inter_prec = TYPE_PRECISION (inter_type);\n+      int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n+      int final_int = INTEGRAL_TYPE_P (type);\n+      int final_ptr = POINTER_TYPE_P (type);\n+      int final_float = FLOAT_TYPE_P (type);\n+      int final_vec = TREE_CODE (type) == VECTOR_TYPE;\n+      unsigned int final_prec = TYPE_PRECISION (type);\n+      int final_unsignedp = TYPE_UNSIGNED (type);\n+    }\n+   /* In addition to the cases of two conversions in a row\n+      handled below, if we are converting something to its own\n+      type via an object of identical or wider precision, neither\n+      conversion is needed.  */\n+   (if (((GIMPLE && useless_type_conversion_p (type, inside_type))\n+\t || (GENERIC\n+\t     && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (inside_type)))\n+\t&& (((inter_int || inter_ptr) && final_int)\n+\t    || (inter_float && final_float))\n+\t&& inter_prec >= final_prec)\n+    (ocvt @0))\n+\n+   /* Likewise, if the intermediate and initial types are either both\n+      float or both integer, we don't need the middle conversion if the\n+      former is wider than the latter and doesn't change the signedness\n+      (for integers).  Avoid this if the final type is a pointer since\n+      then we sometimes need the middle conversion.  Likewise if the\n+      final type has a precision not equal to the size of its mode.  */\n+   (if (((inter_int && inside_int)\n+\t || (inter_float && inside_float)\n+\t || (inter_vec && inside_vec))\n+\t&& inter_prec >= inside_prec\n+\t&& (inter_float || inter_vec\n+\t    || inter_unsignedp == inside_unsignedp)\n+\t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n+\t      && TYPE_MODE (type) == TYPE_MODE (inter_type))\n+\t&& ! final_ptr\n+\t&& (! final_vec || inter_prec == inside_prec))\n+    (ocvt @0))\n+\n+   /* If we have a sign-extension of a zero-extended value, we can\n+      replace that by a single zero-extension.  Likewise if the\n+      final conversion does not change precision we can drop the\n+      intermediate conversion.  */\n+   (if (inside_int && inter_int && final_int\n+\t&& ((inside_prec < inter_prec && inter_prec < final_prec\n+\t     && inside_unsignedp && !inter_unsignedp)\n+\t    || final_prec == inter_prec))\n+    (ocvt @0))\n+\n+   /* Two conversions in a row are not needed unless:\n+\t- some conversion is floating-point (overstrict for now), or\n+\t- some conversion is a vector (overstrict for now), or\n+\t- the intermediate type is narrower than both initial and\n+\t  final, or\n+\t- the intermediate type and innermost type differ in signedness,\n+\t  and the outermost type is wider than the intermediate, or\n+\t- the initial type is a pointer type and the precisions of the\n+\t  intermediate and final types differ, or\n+\t- the final type is a pointer type and the precisions of the\n+\t  initial and intermediate types differ.  */\n+   (if (! inside_float && ! inter_float && ! final_float\n+\t&& ! inside_vec && ! inter_vec && ! final_vec\n+\t&& (inter_prec >= inside_prec || inter_prec >= final_prec)\n+\t&& ! (inside_int && inter_int\n+\t      && inter_unsignedp != inside_unsignedp\n+\t      && inter_prec < final_prec)\n+\t&& ((inter_unsignedp && inter_prec > inside_prec)\n+\t    == (final_unsignedp && final_prec > inter_prec))\n+\t&& ! (inside_ptr && inter_prec != final_prec)\n+\t&& ! (final_ptr && inside_prec != inter_prec)\n+\t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n+\t      && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n+    (ocvt @0))))))"}, {"sha": "f4eb87671ce7bd1e66efe74f900921f1fe1a11bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -1,3 +1,8 @@\n+2014-11-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* g++.dg/cpp0x/constexpr-reinterpret1.C: XFAIL.\n+\t* gcc.dg/tree-ssa/pr21031.c: XFAIL.\n+\n 2014-11-07  Andrew Pinski  <apinski@cavium.com>\n \n \t* gcc.c-torture/execute/20141107-1.c: New testcase."}, {"sha": "26c92937f4742564860ba01adf4ae01446a134df", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-reinterpret1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -18,7 +18,7 @@ public:\n   {\n     /* I am surprised this is considered a constexpr */\n     return *((Inner *)4);\n-  } // { dg-error \"reinterpret_cast\" }\n+  } // { dg-error \"reinterpret_cast\" \"\" { xfail *-*-* } }\n };\n \n B B::instance;"}, {"sha": "251b84e82ef63337fdfdad82a5d6f9a76f22d0e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21031.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21031.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21031.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21031.c?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -16,5 +16,5 @@ foo (int a)\n     return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replaced\" 2 \"forwprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Replaced\" 2 \"forwprop1\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "2f4998cdb56eb8809a8dd00551307e4680d6c2da", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e51d0a29dbfebe6c0df58739562644c1a50f3c3/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=1e51d0a29dbfebe6c0df58739562644c1a50f3c3", "patch": "@@ -2386,109 +2386,20 @@ combine_conversions (gimple_stmt_iterator *gsi)\n       tree inside_type = TREE_TYPE (defop0);\n       tree inter_type = TREE_TYPE (op0);\n       int inside_int = INTEGRAL_TYPE_P (inside_type);\n-      int inside_ptr = POINTER_TYPE_P (inside_type);\n-      int inside_float = FLOAT_TYPE_P (inside_type);\n-      int inside_vec = TREE_CODE (inside_type) == VECTOR_TYPE;\n       unsigned int inside_prec = TYPE_PRECISION (inside_type);\n       int inside_unsignedp = TYPE_UNSIGNED (inside_type);\n       int inter_int = INTEGRAL_TYPE_P (inter_type);\n-      int inter_ptr = POINTER_TYPE_P (inter_type);\n       int inter_float = FLOAT_TYPE_P (inter_type);\n-      int inter_vec = TREE_CODE (inter_type) == VECTOR_TYPE;\n       unsigned int inter_prec = TYPE_PRECISION (inter_type);\n       int inter_unsignedp = TYPE_UNSIGNED (inter_type);\n       int final_int = INTEGRAL_TYPE_P (type);\n-      int final_ptr = POINTER_TYPE_P (type);\n-      int final_float = FLOAT_TYPE_P (type);\n-      int final_vec = TREE_CODE (type) == VECTOR_TYPE;\n       unsigned int final_prec = TYPE_PRECISION (type);\n-      int final_unsignedp = TYPE_UNSIGNED (type);\n \n       /* Don't propagate ssa names that occur in abnormal phis.  */\n       if (TREE_CODE (defop0) == SSA_NAME\n \t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (defop0))\n \treturn 0;\n \n-      /* In addition to the cases of two conversions in a row\n-\t handled below, if we are converting something to its own\n-\t type via an object of identical or wider precision, neither\n-\t conversion is needed.  */\n-      if (useless_type_conversion_p (type, inside_type)\n-\t  && (((inter_int || inter_ptr) && final_int)\n-\t      || (inter_float && final_float))\n-\t  && inter_prec >= final_prec)\n-\t{\n-\t  gimple_assign_set_rhs1 (stmt, unshare_expr (defop0));\n-\t  gimple_assign_set_rhs_code (stmt, TREE_CODE (defop0));\n-\t  update_stmt (stmt);\n-\t  return remove_prop_source_from_use (op0) ? 2 : 1;\n-\t}\n-\n-      /* Likewise, if the intermediate and initial types are either both\n-\t float or both integer, we don't need the middle conversion if the\n-\t former is wider than the latter and doesn't change the signedness\n-\t (for integers).  Avoid this if the final type is a pointer since\n-\t then we sometimes need the middle conversion.  Likewise if the\n-\t final type has a precision not equal to the size of its mode.  */\n-      if (((inter_int && inside_int)\n-\t   || (inter_float && inside_float)\n-\t   || (inter_vec && inside_vec))\n-\t  && inter_prec >= inside_prec\n-\t  && (inter_float || inter_vec\n-\t      || inter_unsignedp == inside_unsignedp)\n-\t  && ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t\t&& TYPE_MODE (type) == TYPE_MODE (inter_type))\n-\t  && ! final_ptr\n-\t  && (! final_vec || inter_prec == inside_prec))\n-\t{\n-\t  gimple_assign_set_rhs1 (stmt, defop0);\n-\t  update_stmt (stmt);\n-\t  return remove_prop_source_from_use (op0) ? 2 : 1;\n-\t}\n-\n-      /* If we have a sign-extension of a zero-extended value, we can\n-\t replace that by a single zero-extension.  Likewise if the\n-\t final conversion does not change precision we can drop the\n-\t intermediate conversion.  */\n-      if (inside_int && inter_int && final_int\n-\t  && ((inside_prec < inter_prec && inter_prec < final_prec\n-\t       && inside_unsignedp && !inter_unsignedp)\n-\t      || final_prec == inter_prec))\n-\t{\n-\t  gimple_assign_set_rhs1 (stmt, defop0);\n-\t  update_stmt (stmt);\n-\t  return remove_prop_source_from_use (op0) ? 2 : 1;\n-\t}\n-\n-      /* Two conversions in a row are not needed unless:\n-\t - some conversion is floating-point (overstrict for now), or\n-\t - some conversion is a vector (overstrict for now), or\n-\t - the intermediate type is narrower than both initial and\n-\t final, or\n-\t - the intermediate type and innermost type differ in signedness,\n-\t and the outermost type is wider than the intermediate, or\n-\t - the initial type is a pointer type and the precisions of the\n-\t intermediate and final types differ, or\n-\t - the final type is a pointer type and the precisions of the\n-\t initial and intermediate types differ.  */\n-      if (! inside_float && ! inter_float && ! final_float\n-\t  && ! inside_vec && ! inter_vec && ! final_vec\n-\t  && (inter_prec >= inside_prec || inter_prec >= final_prec)\n-\t  && ! (inside_int && inter_int\n-\t\t&& inter_unsignedp != inside_unsignedp\n-\t\t&& inter_prec < final_prec)\n-\t  && ((inter_unsignedp && inter_prec > inside_prec)\n-\t      == (final_unsignedp && final_prec > inter_prec))\n-\t  && ! (inside_ptr && inter_prec != final_prec)\n-\t  && ! (final_ptr && inside_prec != inter_prec)\n-\t  && ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t\t&& TYPE_MODE (type) == TYPE_MODE (inter_type)))\n-\t{\n-\t  gimple_assign_set_rhs1 (stmt, defop0);\n-\t  update_stmt (stmt);\n-\t  return remove_prop_source_from_use (op0) ? 2 : 1;\n-\t}\n-\n       /* A truncation to an unsigned type should be canonicalized as\n \t bitwise and of a mask.  */\n       if (final_int && inter_int && inside_int"}]}