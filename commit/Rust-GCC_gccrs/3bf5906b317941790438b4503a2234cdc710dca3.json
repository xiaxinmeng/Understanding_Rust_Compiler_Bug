{"sha": "3bf5906b317941790438b4503a2234cdc710dca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JmNTkwNmIzMTc5NDE3OTA0MzhiNDUwM2EyMjM0Y2RjNzEwZGNhMw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-05-23T04:47:12Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-05-23T04:47:12Z"}, "message": "builtin-types.def (BT_FN_INT_INT_INT_INT_INT_INT_VAR): New.\n\n\t* builtin-types.def (BT_FN_INT_INT_INT_INT_INT_INT_VAR): New.\n\t* builtins.c (fold_builtin_fpclassify): New.\n\t(fold_builtin_varargs): Handle BUILT_IN_FPCLASSIFY.\n\t* builtins.def (BUILT_IN_FPCLASSIFY): New.\n\t* c-common.c (handle_type_generic_attribute): Adjust to accept\n\tfixed arguments before an elipsis.\n\t(check_builtin_function_arguments): Handle BUILT_IN_FPCLASSIFY.\n\t* doc/extend.texi: Document __builtin_fpclassify.\n\ntestsuite:\n\t* gcc.dg/builtins-error.c: Test __builtin_fpclassify.  Also\n\tadd tests for all previous type-generic builtins.\n\t* gcc.dg/pr28796-2.c: Add -DUNSAFE flag.\n\t* gcc.dg/tg-tests.h: Test __builtin_fpclassify.\n\nFrom-SVN: r135789", "tree": {"sha": "a7912b37870308a35af6d7fef3d8dedaa111ecf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7912b37870308a35af6d7fef3d8dedaa111ecf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bf5906b317941790438b4503a2234cdc710dca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf5906b317941790438b4503a2234cdc710dca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bf5906b317941790438b4503a2234cdc710dca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf5906b317941790438b4503a2234cdc710dca3/comments", "author": null, "committer": null, "parents": [{"sha": "2aa5c17ce58d1e54763875dfb10580fbdd871731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa5c17ce58d1e54763875dfb10580fbdd871731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa5c17ce58d1e54763875dfb10580fbdd871731"}], "stats": {"total": 249, "additions": 224, "deletions": 25}, "files": [{"sha": "a75c72ffcda22e362c7188fb72a7b36648c8d9cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -1,3 +1,14 @@\n+2008-05-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtin-types.def (BT_FN_INT_INT_INT_INT_INT_INT_VAR): New.\n+\t* builtins.c (fold_builtin_fpclassify): New.\n+\t(fold_builtin_varargs): Handle BUILT_IN_FPCLASSIFY.\n+\t* builtins.def (BUILT_IN_FPCLASSIFY): New.\n+\t* c-common.c (handle_type_generic_attribute): Adjust to accept\n+\tfixed arguments before an elipsis.\n+\t(check_builtin_function_arguments): Handle BUILT_IN_FPCLASSIFY.\n+\t* doc/extend.texi: Document __builtin_fpclassify.\n+\n 2008-05-22  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* omp-low.c (gate_expand_omp_ssa): Remove."}, {"sha": "25b5a0964f5ca7f97b38415828f323f58d16310d", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -449,6 +449,9 @@ DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n \t\t\t BT_CONST_STRING)\n \n+DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_INT_INT_INT_INT_INT_VAR,\n+\t\t\t BT_INT, BT_INT, BT_INT, BT_INT, BT_INT, BT_INT)\n+\n DEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,\n \t\t     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)"}, {"sha": "d442469b7eead388d6ad5f439d5ab91a5d6448de", "filename": "gcc/builtins.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -9744,6 +9744,70 @@ fold_builtin_classify (tree fndecl, tree arg, int builtin_index)\n     }\n }\n \n+/* Fold a call to __builtin_fpclassify(int, int, int, int, int, ...).\n+   This builtin will generate code to return the appropriate floating\n+   point classification depending on the value of the floating point\n+   number passed in.  The possible return values must be supplied as\n+   int arguments to the call in the following order: FP_NAN, FP_INF,\n+   FP_NORMAL, FP_SUBNORMAL and FP_ZERO.  The ellipses is for exactly\n+   one floating point argument which is \"type generic\".  */\n+\n+static tree\n+fold_builtin_fpclassify (tree exp)\n+{\n+  tree fp_nan, fp_inf, fp_normal, fp_subnormal, fp_zero, arg, type, res, tmp;\n+  enum machine_mode mode;\n+  REAL_VALUE_TYPE r;\n+  char buf[128];\n+  \n+  /* Verify the required arguments in the original call.  */\n+  if (!validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE,\n+\t\t\t INTEGER_TYPE, INTEGER_TYPE,\n+\t\t\t INTEGER_TYPE, REAL_TYPE, VOID_TYPE))\n+    return NULL_TREE;\n+  \n+  fp_nan = CALL_EXPR_ARG (exp, 0);\n+  fp_inf = CALL_EXPR_ARG (exp, 1);\n+  fp_normal = CALL_EXPR_ARG (exp, 2);\n+  fp_subnormal = CALL_EXPR_ARG (exp, 3);\n+  fp_zero = CALL_EXPR_ARG (exp, 4);\n+  arg = CALL_EXPR_ARG (exp, 5);\n+  type = TREE_TYPE (arg);\n+  mode = TYPE_MODE (type);\n+  arg = builtin_save_expr (fold_build1 (ABS_EXPR, type, arg));\n+\n+  /* fpclassify(x) -> \n+       isnan(x) ? FP_NAN :\n+         (fabs(x) == Inf ? FP_INF :\n+\t   (fabs(x) >= DBL_MIN ? FP_NORMAL :\n+\t     (x == 0 ? FP_ZERO : FP_SUBNORMAL))).  */\n+  \n+  tmp = fold_build2 (EQ_EXPR, integer_type_node, arg,\n+\t\t     build_real (type, dconst0));\n+  res = fold_build3 (COND_EXPR, integer_type_node, tmp, fp_zero, fp_subnormal);\n+\n+  sprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (mode)->emin - 1);\n+  real_from_string (&r, buf);\n+  tmp = fold_build2 (GE_EXPR, integer_type_node, arg, build_real (type, r));\n+  res = fold_build3 (COND_EXPR, integer_type_node, tmp, fp_normal, res);\n+  \n+  if (HONOR_INFINITIES (mode))\n+    {\n+      real_inf (&r);\n+      tmp = fold_build2 (EQ_EXPR, integer_type_node, arg,\n+\t\t\t build_real (type, r));\n+      res = fold_build3 (COND_EXPR, integer_type_node, tmp, fp_inf, res);\n+    }\n+\n+  if (HONOR_NANS (mode))\n+    {\n+      tmp = fold_build2 (ORDERED_EXPR, integer_type_node, arg, arg);\n+      res = fold_build3 (COND_EXPR, integer_type_node, tmp, res, fp_nan);\n+    }\n+  \n+  return res;\n+}\n+\n /* Fold a call to an unordered comparison function such as\n    __builtin_isgreater().  FNDECL is the FUNCTION_DECL for the function\n    being called and ARG0 and ARG1 are the arguments for the call.\n@@ -10528,6 +10592,11 @@ fold_builtin_varargs (tree fndecl, tree exp, bool ignore ATTRIBUTE_UNUSED)\n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n       ret = fold_builtin_snprintf_chk (exp, NULL_TREE, fcode);\n+      break;\n+\n+    case BUILT_IN_FPCLASSIFY:\n+      ret = fold_builtin_fpclassify (exp);\n+      break;\n \n     default:\n       break;"}, {"sha": "310e5f456a798a086cfb29e11cd341432c065f67", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -654,6 +654,7 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITEL, \"finitel\", BT_FN_INT_LONGDOUBLE, ATTR_\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITED32, \"finited32\", BT_FN_INT_DFLOAT32, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITED64, \"finited64\", BT_FN_INT_DFLOAT64, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FINITED128, \"finited128\", BT_FN_INT_DFLOAT128, ATTR_CONST_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_FPCLASSIFY, \"fpclassify\", BT_FN_INT_INT_INT_INT_INT_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC)\n DEF_GCC_BUILTIN        (BUILT_IN_ISFINITE, \"isfinite\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC)\n DEF_GCC_BUILTIN        (BUILT_IN_ISINF_SIGN, \"isinf_sign\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC)\n DEF_C99_C90RES_BUILTIN (BUILT_IN_ISINF, \"isinf\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC)"}, {"sha": "70ba5cc485150a36f4a91f3e3bcab0bf2d207bf1", "filename": "gcc/c-common.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -6528,8 +6528,17 @@ handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n \t\t\t       tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n \t\t\t       bool * ARG_UNUSED (no_add_attrs))\n {\n-  /* Ensure we have a function type, with no arguments.  */\n-  gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE && ! TYPE_ARG_TYPES (*node));\n+  tree params;\n+  \n+  /* Ensure we have a function type.  */\n+  gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE);\n+  \n+  params = TYPE_ARG_TYPES (*node);\n+  while (params && ! VOID_TYPE_P (TREE_VALUE (params)))\n+    params = TREE_CHAIN (params);\n+\n+  /* Ensure we have a variadic function.  */\n+  gcc_assert (!params);\n \n   return NULL_TREE;\n }\n@@ -6712,6 +6721,29 @@ check_builtin_function_arguments (tree fndecl, int nargs, tree *args)\n \t}\n       return false;\n \n+    case BUILT_IN_FPCLASSIFY:\n+      if (validate_nargs (fndecl, nargs, 6))\n+\t{\n+\t  unsigned i;\n+\t  \n+\t  for (i=0; i<5; i++)\n+\t    if (TREE_CODE (args[i]) != INTEGER_CST)\n+\t      {\n+\t\terror (\"non-const integer argument %u in call to function %qE\",\n+\t\t       i+1, fndecl);\n+\t\treturn false;\n+\t      }\n+\n+\t  if (TREE_CODE (TREE_TYPE (args[5])) != REAL_TYPE)\n+\t    {\n+\t      error (\"non-floating-point argument in call to function %qE\",\n+\t\t     fndecl);\n+\t      return false;\n+\t    }\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       return true;\n     }"}, {"sha": "78d581d62e6c362a75fe009aafcc62426bacee8f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -5764,6 +5764,7 @@ should be called and the @var{flag} argument passed to it.\n @node Other Builtins\n @section Other built-in functions provided by GCC\n @cindex built-in functions\n+@findex __builtin_fpclassify\n @findex __builtin_isfinite\n @findex __builtin_isnormal\n @findex __builtin_isgreater\n@@ -6295,10 +6296,10 @@ the same names as the standard macros ( @code{isgreater},\n @code{islessgreater}, and @code{isunordered}) , with @code{__builtin_}\n prefixed.  We intend for a library implementor to be able to simply\n @code{#define} each standard macro to its built-in equivalent.\n-In the same fashion, GCC provides @code{isfinite}, @code{isinf_sign}\n-and @code{isnormal} built-ins used with @code{__builtin_} prefixed.\n-The @code{isinf} and @code{isnan} builtins appear both with and\n-without the @code{__builtin_} prefix.\n+In the same fashion, GCC provides @code{fpclassify}, @code{isfinite},\n+@code{isinf_sign} and @code{isnormal} built-ins used with\n+@code{__builtin_} prefixed.  The @code{isinf} and @code{isnan}\n+builtins appear both with and without the @code{__builtin_} prefix.\n \n @deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})\n \n@@ -6555,6 +6556,17 @@ Similar to @code{__builtin_huge_val}, except the return\n type is @code{long double}.\n @end deftypefn\n \n+@deftypefn {Built-in Function} int __builtin_fpclassify (int, int, int, int, int, ...)\n+This built-in implements the C99 fpclassify functionality.  The first\n+five int arguments should be the target library's notion of the\n+possible FP classes and are used for return values.  They must be\n+constant values and they must appear in this order: @code{FP_NAN},\n+@code{FP_INF}, @code{FP_NORMAL}, @code{FP_SUBNORMAL} and\n+@code{FP_ZERO}.  The ellipsis is for exactly one floating point value\n+to classify.  GCC treats the last argument as type-generic, which\n+means it does not do default promotion from float to double.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} double __builtin_inf (void)\n Similar to @code{__builtin_huge_val}, except a warning is generated\n if the target floating-point format does not support infinities."}, {"sha": "420a482832f4cc6d2428a8871b842f2bf8af336a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -1,3 +1,10 @@\n+2008-05-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/builtins-error.c: Test __builtin_fpclassify.  Also\n+\tadd tests for all previous type-generic builtins.\n+\t* gcc.dg/pr28796-2.c: Add -DUNSAFE flag.\n+\t* gcc.dg/tg-tests.h: Test __builtin_fpclassify.\n+\n 2008-05-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libgfortran/36302"}, {"sha": "0f41700ba1a081c5d4ef5ef051f89383a89a065f", "filename": "gcc/testsuite/gcc.dg/builtins-error.c", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-error.c?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -4,20 +4,62 @@ struct X { int x; };\n \n int test1(struct X x)\n {\n-  return __builtin_isnormal(x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  1) return __builtin_fpclassify(1,2,3,4,5,x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  2) return __builtin_isfinite(x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  3) return __builtin_isinf_sign(x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  4) return __builtin_isinf(x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  5) return __builtin_isnan(x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  6) return __builtin_isnormal(x); /* { dg-error \"non-floating-point argument\" } */\n+  if (x.x ==  7) return __builtin_isgreater(x, x); /* { dg-error \"non-floating-point arguments\" } */\n+  if (x.x ==  8) return __builtin_isgreaterequal(x, x); /* { dg-error \"non-floating-point arguments\" } */\n+  if (x.x ==  9) return __builtin_isless(x, x); /* { dg-error \"non-floating-point arguments\" } */\n+  if (x.x == 10) return __builtin_islessequal(x, x); /* { dg-error \"non-floating-point arguments\" } */\n+  if (x.x == 11) return __builtin_islessgreater(x, x); /* { dg-error \"non-floating-point arguments\" } */\n+  if (x.x == 12) return __builtin_isunordered(x, x); /* { dg-error \"non-floating-point arguments\" } */\n+\n+  return 0;\n }\n \n int test2(double x)\n {\n-  return __builtin_isgreater(x); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  1) return __builtin_fpclassify(1,2,3,4,5); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  2) return __builtin_isfinite(); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  3) return __builtin_isinf_sign(); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  4) return __builtin_isinf(); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  5) return __builtin_isnan(); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  6) return __builtin_isnormal(); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  7) return __builtin_isgreater(x); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  8) return __builtin_isgreaterequal(x); /* { dg-error \"not enough arguments\" } */\n+  if (x ==  9) return __builtin_isless(x); /* { dg-error \"not enough arguments\" } */\n+  if (x == 10) return __builtin_islessequal(x); /* { dg-error \"not enough arguments\" } */\n+  if (x == 11) return __builtin_islessgreater(x); /* { dg-error \"not enough arguments\" } */\n+  if (x == 12) return __builtin_isunordered(x); /* { dg-error \"not enough arguments\" } */\n+  return 0;\n }\n \n int test3(double x)\n {\n-  return __builtin_isinf(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  1) return __builtin_fpclassify(1,2,3,4,5,x,x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  2) return __builtin_isfinite(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  3) return __builtin_isinf_sign(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  4) return __builtin_isinf(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  5) return __builtin_isnan(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  6) return __builtin_isnormal(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  7) return __builtin_isgreater(x, x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  8) return __builtin_isgreaterequal(x, x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  9) return __builtin_isless(x, x, x); /* { dg-error \"too many arguments\" } */\n+  if (x == 10) return __builtin_islessequal(x, x, x); /* { dg-error \"too many arguments\" } */\n+  if (x == 11) return __builtin_islessgreater(x, x, x); /* { dg-error \"too many arguments\" } */\n+  if (x == 12) return __builtin_isunordered(x, x, x); /* { dg-error \"too many arguments\" } */\n+  return 0;\n }\n \n-int test4(double x)\n+int test4(int i, double x)\n {\n-  return __builtin_isinf_sign(x, x); /* { dg-error \"too many arguments\" } */\n+  if (x ==  1) return __builtin_fpclassify(i,2,3,4,5,x); /* { dg-error \"non-const integer argument\" } */\n+  if (x ==  2) return __builtin_fpclassify(1,i,3,4,5,x); /* { dg-error \"non-const integer argument\" } */\n+  if (x ==  3) return __builtin_fpclassify(1,2,i,4,5,x); /* { dg-error \"non-const integer argument\" } */\n+  if (x ==  4) return __builtin_fpclassify(1,2,3,i,5,x); /* { dg-error \"non-const integer argument\" } */\n+  if (x ==  5) return __builtin_fpclassify(1,2,3,4,i,x); /* { dg-error \"non-const integer argument\" } */\n+  return 0;\n }"}, {"sha": "f4900817581c5aba8616beabafb5faba0839f37b", "filename": "gcc/testsuite/gcc.dg/pr28796-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28796-2.c?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -funsafe-math-optimizations -fno-finite-math-only\" } */\n-/* { dg-options \"-mieee -O2 -funsafe-math-optimizations -fno-finite-math-only\" { target alpha*-*-* } } */\n+/* { dg-options \"-O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE\" } */\n+/* { dg-options \"-mieee -O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE\" { target alpha*-*-* } } */\n \n #include \"tg-tests.h\"\n "}, {"sha": "dc95a2cde623811d888396454395a3106d24ac98", "filename": "gcc/testsuite/gcc.dg/tg-tests.h", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftg-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf5906b317941790438b4503a2234cdc710dca3/gcc%2Ftestsuite%2Fgcc.dg%2Ftg-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftg-tests.h?ref=3bf5906b317941790438b4503a2234cdc710dca3", "patch": "@@ -1,9 +1,17 @@\n /* Test various type-generic builtins by calling \"main_tests()\".  */\n \n+#define FP_NAN 1\n+#define FP_INF 2\n+#define FP_NORMAL 3\n+#define FP_SUBNORMAL 4\n+#define FP_ZERO 5\n+#define fpclassify(X) __builtin_fpclassify(FP_NAN, FP_INF, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, (X))\n+\n void __attribute__ ((__noinline__))\n foo_1 (float f, double d, long double ld,\n        int res_unord, int res_isnan, int res_isinf,\n-       int res_isinf_sign, int res_isfin, int res_isnorm)\n+       int res_isinf_sign, int res_isfin, int res_isnorm,\n+       int classification)\n {\n   if (__builtin_isunordered (f, 0) != res_unord)\n     __builtin_abort ();\n@@ -71,16 +79,30 @@ foo_1 (float f, double d, long double ld,\n     __builtin_abort ();\n   if (__builtin_finitel (ld) != res_isfin)\n     __builtin_abort ();\n+\n+  /* Subnormals can abruptly underflow to zero in unsafe math\n+     mode, so bypass testing these numbers if necessary.  */\n+#ifdef UNSAFE\n+  if (classification != FP_SUBNORMAL)\n+#endif\n+    {\n+      if (fpclassify(f) != classification)\n+\t__builtin_abort ();\n+      if (fpclassify(d) != classification)\n+\t__builtin_abort ();\n+      if (fpclassify(ld) != classification)\n+\t__builtin_abort ();\n+    }\n }\n \n void __attribute__ ((__noinline__))\n foo (float f, double d, long double ld,\n      int res_unord, int res_isnan, int res_isinf,\n-     int res_isfin, int res_isnorm)\n+     int res_isfin, int res_isnorm, int classification)\n {\n-  foo_1 (f, d, ld, res_unord, res_isnan, res_isinf, res_isinf, res_isfin, res_isnorm);\n+  foo_1 (f, d, ld, res_unord, res_isnan, res_isinf, res_isinf, res_isfin, res_isnorm, classification);\n   /* Try all the values negated as well.  */\n-  foo_1 (-f, -d, -ld, res_unord, res_isnan, res_isinf, -res_isinf, res_isfin, res_isnorm);\n+  foo_1 (-f, -d, -ld, res_unord, res_isnan, res_isinf, -res_isinf, res_isfin, res_isnorm, classification);\n }\n \n int __attribute__ ((__noinline__))\n@@ -92,35 +114,35 @@ main_tests (void)\n   \n   /* Test NaN.  */\n   f = __builtin_nanf(\"\"); d = __builtin_nan(\"\"); ld = __builtin_nanl(\"\");\n-  foo(f, d, ld, /*unord=*/ 1, /*isnan=*/ 1, /*isinf=*/ 0, /*isfin=*/ 0, /*isnorm=*/ 0);\n+  foo(f, d, ld, /*unord=*/ 1, /*isnan=*/ 1, /*isinf=*/ 0, /*isfin=*/ 0, /*isnorm=*/ 0, FP_NAN);\n \n   /* Test infinity.  */\n   f = __builtin_inff(); d = __builtin_inf(); ld = __builtin_infl();\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0, FP_INF);\n \n   /* Test zero.  */\n   f = 0; d = 0; ld = 0;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0, FP_ZERO);\n \n   /* Test one.  */\n   f = 1; d = 1; ld = 1;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, FP_NORMAL);\n \n   /* Test minimum values.  */\n   f = __FLT_MIN__; d = __DBL_MIN__; ld = __LDBL_MIN__;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, FP_NORMAL);\n \n   /* Test subnormal values.  */\n   f = __FLT_MIN__/2; d = __DBL_MIN__/2; ld = __LDBL_MIN__/2;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 0, FP_SUBNORMAL);\n \n   /* Test maximum values.  */\n   f = __FLT_MAX__; d = __DBL_MAX__; ld = __LDBL_MAX__;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 0, /*isfin=*/ 1, /*isnorm=*/ 1, FP_NORMAL);\n \n   /* Test overflow values.  */\n   f = __FLT_MAX__*2; d = __DBL_MAX__*2; ld = __LDBL_MAX__*2;\n-  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0);\n+  foo(f, d, ld, /*unord=*/ 0, /*isnan=*/ 0, /*isinf=*/ 1, /*isfin=*/ 0, /*isnorm=*/ 0, FP_INF);\n \n   return 0;\n }"}]}