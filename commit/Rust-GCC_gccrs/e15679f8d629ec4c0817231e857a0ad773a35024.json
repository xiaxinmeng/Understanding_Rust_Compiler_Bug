{"sha": "e15679f8d629ec4c0817231e857a0ad773a35024", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1Njc5ZjhkNjI5ZWM0YzA4MTcyMzFlODU3YTBhZDc3M2EzNTAyNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:30:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:30:29Z"}, "message": "Add prototypes for static functions.\n\n(bc_expand_function_end, expand_function_end): Call new expand_fixups\ninstead of old fixup_gotos.\n\nFrom-SVN: r7116", "tree": {"sha": "1e51015ee16e43cbeb79f310e5361158afdbe56b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e51015ee16e43cbeb79f310e5361158afdbe56b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e15679f8d629ec4c0817231e857a0ad773a35024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15679f8d629ec4c0817231e857a0ad773a35024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e15679f8d629ec4c0817231e857a0ad773a35024", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15679f8d629ec4c0817231e857a0ad773a35024/comments", "author": null, "committer": null, "parents": [{"sha": "318e45ce5af90ba0a6a80a636e7ba3a758148711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318e45ce5af90ba0a6a80a636e7ba3a758148711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/318e45ce5af90ba0a6a80a636e7ba3a758148711"}], "stats": {"total": 107, "additions": 47, "deletions": 60}, "files": [{"sha": "27318d440d68a83139997aad8535fe5a1eb84bb0", "filename": "gcc/function.c", "status": "modified", "additions": 47, "deletions": 60, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15679f8d629ec4c0817231e857a0ad773a35024/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15679f8d629ec4c0817231e857a0ad773a35024/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e15679f8d629ec4c0817231e857a0ad773a35024", "patch": "@@ -322,23 +322,6 @@ extern tree bc_runtime_type_code ();\n extern rtx bc_build_calldesc ();\n extern char *bc_emit_trampoline ();\n extern char *bc_end_function ();\n-\n-void fixup_gotos ();\n-\n-static tree round_down ();\n-static rtx round_trampoline_addr ();\n-static rtx fixup_stack_1 ();\n-static void put_reg_into_stack ();\n-static void fixup_var_refs ();\n-static void fixup_var_refs_insns ();\n-static void fixup_var_refs_1 ();\n-static void optimize_bit_field ();\n-static void instantiate_decls ();\n-static void instantiate_decls_1 ();\n-static void instantiate_decl ();\n-static int instantiate_virtual_regs_1 ();\n-static rtx fixup_memory_subreg ();\n-static rtx walk_fixup_memory_subreg ();\n \f\n /* In order to evaluate some expressions, such as function calls returning\n    structures in memory, we need to temporarily allocate stack locations.\n@@ -411,6 +394,49 @@ int max_stack_depth;\n \n /* Current depth in statement expressions.  */\n static int stmt_expr_depth;\n+\n+/* This structure is used to record MEMs or pseudos used to replace VAR, any\n+   SUBREGs of VAR, and any MEMs containing VAR as an address.  We need to\n+   maintain this list in case two operands of an insn were required to match;\n+   in that case we must ensure we use the same replacement.  */\n+\n+struct fixup_replacement\n+{\n+  rtx old;\n+  rtx new;\n+  struct fixup_replacement *next;\n+};\n+   \n+/* Forward declarations.  */\n+\n+static struct temp_slot *find_temp_slot_from_address  PROTO((rtx));\n+static void put_reg_into_stack\tPROTO((struct function *, rtx, tree,\n+\t\t\t\t       enum machine_mode, enum machine_mode));\n+static void fixup_var_refs\tPROTO((rtx, enum machine_mode, int));\n+static struct fixup_replacement\n+  *find_fixup_replacement\tPROTO((struct fixup_replacement **, rtx));\n+static void fixup_var_refs_insns PROTO((rtx, enum machine_mode, int,\n+\t\t\t\t\trtx, int));\n+static void fixup_var_refs_1\tPROTO((rtx, enum machine_mode, rtx *, rtx,\n+\t\t\t\t       struct fixup_replacement **));\n+static rtx fixup_memory_subreg\tPROTO((rtx, rtx, int));\n+static rtx walk_fixup_memory_subreg  PROTO((rtx, rtx, int));\n+static rtx fixup_stack_1\tPROTO((rtx, rtx));\n+static void optimize_bit_field\tPROTO((rtx, rtx, rtx *));\n+static void instantiate_decls\tPROTO((tree, int));\n+static void instantiate_decls_1\tPROTO((tree, int));\n+static void instantiate_decl\tPROTO((rtx, int, int));\n+static int instantiate_virtual_regs_1 PROTO((rtx *, rtx, int));\n+static void delete_handlers\tPROTO((void));\n+static void pad_to_arg_alignment PROTO((struct args_size *, int));\n+static void pad_below\t\tPROTO((struct args_size *, enum  machine_mode,\n+\t\t\t\t       tree));\n+static tree round_down\t\tPROTO((tree, int));\n+static rtx round_trampoline_addr PROTO((rtx));\n+static tree blocks_nreverse\tPROTO((tree));\n+static int all_blocks\t\tPROTO((tree, tree *));\n+static int *record_insns\tPROTO((rtx));\n+static int contains\t\tPROTO((rtx, int *));\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n@@ -1263,20 +1289,7 @@ fixup_var_refs (var, promoted_mode, unsignedp)\n     }\n }\n \f\n-/* This structure is used by the following two functions to record MEMs or\n-   pseudos used to replace VAR, any SUBREGs of VAR, and any MEMs containing\n-   VAR as an address.  We need to maintain this list in case two operands of\n-   an insn were required to match; in that case we must ensure we use the\n-   same replacement.  */\n-\n-struct fixup_replacement\n-{\n-  rtx old;\n-  rtx new;\n-  struct fixup_replacement *next;\n-};\n-   \n-/* REPLACEMENTS is a pointer to a list of the above structures and X is\n+/* REPLACEMENTS is a pointer to a list of the struct fixup_replacement and X is\n    some part of an insn.  Return a struct fixup_replacement whose OLD\n    value is equal to X.  Allocate a new structure if no such entry exists. */\n \n@@ -2065,28 +2078,6 @@ walk_fixup_memory_subreg (x, insn, uncritical)\n   return x;\n }\n \f\n-#if 0\n-/* Fix up any references to stack slots that are invalid memory addresses\n-   because they exceed the maximum range of a displacement.  */\n-\n-void\n-fixup_stack_slots ()\n-{\n-  register rtx insn;\n-\n-  /* Did we generate a stack slot that is out of range\n-     or otherwise has an invalid address?  */\n-  if (invalid_stack_slot)\n-    {\n-      /* Yes.  Must scan all insns for stack-refs that exceed the limit.  */\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n-\t    || GET_CODE (insn) == JUMP_INSN)\n-\t  fixup_stack_1 (PATTERN (insn), insn);\n-    }\n-}\n-#endif\n-\n /* For each memory ref within X, if it refers to a stack slot\n    with an out of range displacement, put the address in a temp register\n    (emitting new insns before INSN to load these registers)\n@@ -3851,8 +3842,6 @@ promoted_input_arg (regno, pmode, punsignedp)\n     callers pass in the total size of args so far as\n     initial_offset_ptr. arg_size_ptr is always positive.*/\n \n-static void pad_to_arg_alignment (), pad_below ();\n-\n void\n locate_and_pad_parm (passed_mode, type, in_regs, fndecl,\n \t\t     initial_offset_ptr, offset_ptr, arg_size_ptr)\n@@ -4353,9 +4342,6 @@ round_trampoline_addr (tramp)\n    duplicate portions of the RTL code.  Call identify_blocks before\n    changing the RTL, and call reorder_blocks after.  */\n \n-static int all_blocks ();\n-static tree blocks_nreverse ();\n-\n /* Put all this function's BLOCK nodes into a vector, and return it.\n    Also store in each NOTE for the beginning or end of a block\n    the index of that block in the vector.\n@@ -4495,6 +4481,7 @@ all_blocks (block, vector)\n }\n \f\n /* Build bytecode call descriptor for function SUBR. */\n+\n rtx\n bc_build_calldesc (subr)\n   tree subr;\n@@ -4788,7 +4775,7 @@ bc_expand_function_end ()\n      to BC_END_FUNCTION (), since that will cause the bytecode\n      segment to be finished off and closed. */\n \n-  fixup_gotos (0, 0, 0, 0, 0);\n+  expand_fixups (NULL_RTX);\n \n   ptrconsts = bc_end_function ();\n \n@@ -5257,7 +5244,7 @@ expand_function_end (filename, line, end_bindings)\n   /* If you have any cleanups to do at this point,\n      and they need to create temporary variables,\n      then you will lose.  */\n-  fixup_gotos (NULL_PTR, NULL_RTX, NULL_TREE, get_insns (), 0);\n+  expand_fixups (get_insns ());\n }\n \f\n /* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */"}]}