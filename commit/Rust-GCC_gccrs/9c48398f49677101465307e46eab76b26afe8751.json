{"sha": "9c48398f49677101465307e46eab76b26afe8751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM0ODM5OGY0OTY3NzEwMTQ2NTMwN2U0NmVhYjc2YjI2YWZlODc1MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-03-07T05:04:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-03-07T05:04:37Z"}, "message": "runtime: Fix GC bug caused by Entersyscall modifying reg.\n\nThis patch fixes a rare but serious bug.  The Go garbage\ncollector only examines Go stacks.  When Go code calls a\nfunction that is not written in Go, it first calls\nsyscall.Entersyscall.  Entersyscall records the position of\nthe Go stack pointer and saves a copy of all the registers.\nIf the garbage collector runs while the thread is executing\nthe non-Go code, the garbage collector fetches the stack\npointer and registers from the saved location.\n\nEntersyscall saves the registers using the getcontext\nfunction.  Unfortunately I didn't consider the possibility\nthat Entersyscall might itself change a register before\ncalling getcontext.  This only matters for callee-saved\nregisters, as caller-saved registers would be visible on the\nsaved stack.  And it only matters if Entersyscall is compiled\nto save and modify a callee-saved register before it calls\ngetcontext.  And it only matters if a garbage collection\noccurs while the non-Go code is executing.  And it only\nmatters if the only copy of a valid Go pointer happens to be\nin the callee-saved register when Entersyscall is called.\nWhen all those conditions are true, the Go pointer might get\ncollected incorrectly, leading to memory corruption.\n\nThis patch tries to avoid the problem by splitting\nEntersyscall into two functions.  The first is a simple\nfunction that just calls getcontext and then calls the rest of\nEntersyscall.  This should fix the problem, provided the\nsimple Entersyscall function does not itself modify any\ncallee-saved registers before calling getcontext.  That seems\nto be true on the systems I checked.  But since the argument\nto getcontext is an offset from a TLS variable, it won't be\ntrue on a system which needs to save callee-saved registers in\norder to get the address of a TLS variable.  I don't know why\nany system would work that way, but I don't know how to rule\nit out.  I think that on any such system this will have to be\nimplemented in assembler.  I can't put the ucontext_t\nstructure on the stack, because this function can not split\nstacks, and the ucontext_t structure is large enough that it\ncould cause a stack overflow.\n\nFrom-SVN: r208390", "tree": {"sha": "cac7b4912e650c3152d0b195494180cd27549221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cac7b4912e650c3152d0b195494180cd27549221"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c48398f49677101465307e46eab76b26afe8751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c48398f49677101465307e46eab76b26afe8751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c48398f49677101465307e46eab76b26afe8751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c48398f49677101465307e46eab76b26afe8751/comments", "author": null, "committer": null, "parents": [{"sha": "663a708753149d056328e5394a7d194322cd7245", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/663a708753149d056328e5394a7d194322cd7245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/663a708753149d056328e5394a7d194322cd7245"}], "stats": {"total": 24, "additions": 20, "deletions": 4}, "files": [{"sha": "1bc0876d8e6273377b487583eaa040a777d1895d", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c48398f49677101465307e46eab76b26afe8751/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c48398f49677101465307e46eab76b26afe8751/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=9c48398f49677101465307e46eab76b26afe8751", "patch": "@@ -1857,9 +1857,29 @@ goexit0(G *gp)\n // entersyscall is going to return immediately after.\n \n void runtime_entersyscall(void) __attribute__ ((no_split_stack));\n+static void doentersyscall(void) __attribute__ ((no_split_stack, noinline));\n \n void\n runtime_entersyscall()\n+{\n+\t// Save the registers in the g structure so that any pointers\n+\t// held in registers will be seen by the garbage collector.\n+\tgetcontext(&g->gcregs);\n+\n+\t// Do the work in a separate function, so that this function\n+\t// doesn't save any registers on its own stack.  If this\n+\t// function does save any registers, we might store the wrong\n+\t// value in the call to getcontext.\n+\t//\n+\t// FIXME: This assumes that we do not need to save any\n+\t// callee-saved registers to access the TLS variable g.  We\n+\t// don't want to put the ucontext_t on the stack because it is\n+\t// large and we can not split the stack here.\n+\tdoentersyscall();\n+}\n+\n+static void\n+doentersyscall()\n {\n \t// Disable preemption because during this function g is in Gsyscall status,\n \t// but can have inconsistent g->sched, do not let GC observe it.\n@@ -1878,10 +1898,6 @@ runtime_entersyscall()\n \t}\n #endif\n \n-\t// Save the registers in the g structure so that any pointers\n-\t// held in registers will be seen by the garbage collector.\n-\tgetcontext(&g->gcregs);\n-\n \tg->status = Gsyscall;\n \n \tif(runtime_atomicload(&runtime_sched.sysmonwait)) {  // TODO: fast atomic"}]}