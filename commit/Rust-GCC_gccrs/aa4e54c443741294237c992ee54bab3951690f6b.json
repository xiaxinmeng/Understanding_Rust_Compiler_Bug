{"sha": "aa4e54c443741294237c992ee54bab3951690f6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0ZTU0YzQ0Mzc0MTI5NDIzN2M5OTJlZTU0YmFiMzk1MTY5MGY2Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-17T19:01:47Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-17T19:01:47Z"}, "message": "(memory): Change r4100/r4300 support.\n\n(imuldiv): Add r4300 support.\n(high, low): New patterns.\n(movsi, movdi): Add LO_SUM support.\n(movsi_internal1, movsi_internal2): Use move_operand instead of\ngeneral_operand.\n(movstrsi_internal, movstrsi_internal2): Delete R constraint.\n(call, call_value): Pass address instead of MEM to call_insn_operand.\nCall gen_call_{value_}internal0 instead of internal1.\n(call_internal0, call_value_internal0, call_multiple_internal0):\nNew patterns.\n(call_internal1, call_internal2, call_value_internal1,\ncall_value_internal2, call_value_multiple_internal2): Add explicit\nMEM before target address.\n\nFrom-SVN: r12287", "tree": {"sha": "43ec8ee5ec3711764cf4b38901de28a8b26460c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43ec8ee5ec3711764cf4b38901de28a8b26460c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4e54c443741294237c992ee54bab3951690f6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4e54c443741294237c992ee54bab3951690f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4e54c443741294237c992ee54bab3951690f6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4e54c443741294237c992ee54bab3951690f6b/comments", "author": null, "committer": null, "parents": [{"sha": "ce57d6f4d1aead4ca9b4bd2ff6dc6f5130f27e0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce57d6f4d1aead4ca9b4bd2ff6dc6f5130f27e0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce57d6f4d1aead4ca9b4bd2ff6dc6f5130f27e0f"}], "stats": {"total": 136, "additions": 105, "deletions": 31}, "files": [{"sha": "fe58fdda774ab02f6d77bb67cb36db78d321b40f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 105, "deletions": 31, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4e54c443741294237c992ee54bab3951690f6b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4e54c443741294237c992ee54bab3951690f6b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=aa4e54c443741294237c992ee54bab3951690f6b", "patch": "@@ -155,13 +155,9 @@\n   3 0)\n \n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"r3000,r4600,r4650\"))\n+  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"r3000,r4600,r4650,r4100,r4300\"))\n   2 0)\n \n-(define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"r4100,r4300\"))\n-  1 0)\n-\n (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"store\") 1 0)\n \n (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"xfer\") 2 0)\n@@ -356,6 +352,10 @@\n   (and (eq_attr \"type\" \"fadd\") (eq_attr \"cpu\" \"r4300\"))\n   3 3)\n \n+(define_function_unit \"imuldiv\" 1 0\n+  (and (eq_attr \"type\" \"fcmp,fabs,fneg\") (eq_attr \"cpu\" \"r4300\"))\n+  1 1)\n+\n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"fmul\") (and (eq_attr \"mode\" \"SF\") (eq_attr \"cpu\" \"r4300\")))\n   5 5)\n@@ -868,9 +868,9 @@\n ;;  ....................\n ;;\n \n-;; Vr4300 has a CPU bug where multiplies with certain operands may\n-;; corrupt immediately following multiplies. This is a simple fix to\n-;; insert NOPs.\n+;; Early Vr4300 silicon has a CPU bug where multiplies with certain\n+;; operands may corrupt immediately following multiplies. This is a\n+;; simple fix to insert NOPs.\n \n (define_expand \"muldf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n@@ -3108,6 +3108,30 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"2,4\")])\n \n+;; These two patterns support loading addresses with two instructions instead\n+;; of using the macro instruction la.\n+\n+;; ??? mips_move_1word has support for HIGH, so this pattern may be\n+;; unnecessary.\n+\n+(define_insn \"high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand:SI 1 \"immediate_operand\" \"\")))]\n+  \"mips_split_addresses\"\n+  \"lui\\\\t%0,%%hi(%1) # high\"\n+  [(set_attr \"type\"\t\"move\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"low\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  \"mips_split_addresses\"\n+  \"addiu\\\\t%0,%1,%%lo(%2) # low\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n ;; 64-bit integer moves\n \n ;; Unlike most other insns, the move insns can't be split with\n@@ -3120,6 +3144,18 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\"\n   \"\n {\n+  if (mips_split_addresses && mips_check_split (operands[1], DImode))\n+    {\n+      enum machine_mode mode = GET_MODE (operands[0]);\n+      rtx tem = ((reload_in_progress | reload_completed)\n+\t\t ? operands[0] : gen_reg_rtx (mode));\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, tem,\n+\t\t\t  gen_rtx (HIGH, mode, operands[1])));\n+\n+      operands[1] = gen_rtx (LO_SUM, mode, tem, operands[1]);\n+    }\n+\n   /* If we are generating embedded PIC code, and we are referring to a\n      symbol in the .text section, we must use an offset from the start\n      of the function.  */\n@@ -3359,6 +3395,18 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\"\n   \"\n {\n+  if (mips_split_addresses && mips_check_split (operands[1], SImode))\n+    {\n+      enum machine_mode mode = GET_MODE (operands[0]);\n+      rtx tem = ((reload_in_progress | reload_completed)\n+\t\t ? operands[0] : gen_reg_rtx (mode));\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, tem,\n+\t\t\t  gen_rtx (HIGH, mode, operands[1])));\n+\n+      operands[1] = gen_rtx (LO_SUM, mode, tem, operands[1]);\n+    }\n+\n   /* If we are generating embedded PIC code, and we are referring to a\n      symbol in the .text section, we must use an offset from the start\n      of the function.  */\n@@ -3406,7 +3454,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"movsi_internal1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d\")\n-\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,I,*d,*x,*a\"))]\n+\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,I,*d,*x,*a\"))]\n   \"TARGET_DEBUG_H_MODE\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n@@ -3418,7 +3466,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"movsi_internal2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d\")\n-\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,I,*x,*d,*a\"))]\n+\t(match_operand:SI 1 \"move_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,I,*x,*d,*a\"))]\n   \"!TARGET_DEBUG_H_MODE\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n@@ -3714,8 +3762,8 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; Insn generated by block moves\n \n (define_insn \"movstrsi_internal\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Ro\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"Ro\"))\t;; source\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\t;; destination\n+\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\t;; source\n    (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n    (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n    (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n@@ -3773,8 +3821,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\")\n \n (define_insn \"movstrsi_internal2\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Ro\")\t;; destination\n-\t(match_operand:BLK 1 \"memory_operand\" \"Ro\"))\t;; source\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\t;; destination\n+\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\t;; source\n    (clobber (match_scratch:SI 4 \"=&d\"))\t\t\t;; temp 1\n    (clobber (match_scratch:SI 5 \"=&d\"))\t\t\t;; temp 2\n    (clobber (match_scratch:SI 6 \"=&d\"))\t\t\t;; temp 3\n@@ -6277,7 +6325,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     {\n       addr = XEXP (operands[0], 0);\n       if ((GET_CODE (addr) != REG && (!CONSTANT_ADDRESS_P (addr) || TARGET_LONG_CALLS))\n-\t  || ! call_insn_operand (operands[0], VOIDmode))\n+\t  || ! call_insn_operand (addr, VOIDmode))\n \tXEXP (operands[0], 0) = copy_to_mode_reg (Pmode, addr);\n \n       /* In order to pass small structures by value in registers\n@@ -6297,20 +6345,27 @@ move\\\\t%0,%z4\\\\n\\\\\n \t    emit_insn (RTVEC_ELT (adjust, i));\n \t}\n \n-      emit_call_insn (gen_call_internal1 (operands[0], operands[1],\n+      emit_call_insn (gen_call_internal0 (operands[0], operands[1],\n \t\t\t\t\t  gen_rtx (REG, SImode, GP_REG_FIRST + 31)));\n       DONE;\n     }\n }\")\n \n+(define_expand \"call_internal0\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (match_operand:SI 2 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n (define_insn \"call_internal1\"\n-  [(call (match_operand 0 \"call_insn_operand\" \"m\")\n+  [(call (mem (match_operand 0 \"call_insn_operand\" \"ri\"))\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=d\"))]\n   \"!TARGET_ABICALLS && !TARGET_LONG_CALLS\"\n   \"*\n {\n-  register rtx target = XEXP (operands[0], 0);\n+  register rtx target = operands[0];\n \n   if (GET_CODE (target) == SYMBOL_REF)\n     return \\\"%*jal\\\\t%0\\\";\n@@ -6332,13 +6387,13 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"length\"\t\"1\")])\n \n (define_insn \"call_internal2\"\n-  [(call (match_operand 0 \"call_insn_operand\" \"m\")\n+  [(call (mem (match_operand 0 \"call_insn_operand\" \"ri\"))\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=d\"))]\n   \"TARGET_ABICALLS && !TARGET_LONG_CALLS\"\n   \"*\n {\n-  register rtx target = XEXP (operands[0], 0);\n+  register rtx target = operands[0];\n \n   if (GET_CODE (target) == SYMBOL_REF)\n     return \\\"jal\\\\t%0\\\";\n@@ -6431,7 +6486,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     {\n       addr = XEXP (operands[1], 0);\n       if ((GET_CODE (addr) != REG && (!CONSTANT_ADDRESS_P (addr) || TARGET_LONG_CALLS))\n-\t  || ! call_insn_operand (operands[1], VOIDmode))\n+\t  || ! call_insn_operand (addr, VOIDmode))\n \tXEXP (operands[1], 0) = copy_to_mode_reg (Pmode, addr);\n \n       /* In order to pass small structures by value in registers\n@@ -6455,30 +6510,38 @@ move\\\\t%0,%z4\\\\n\\\\\n \t results.  */\n       if (GET_CODE (operands[0]) == PARALLEL)\n \t{\n-\t  emit_call_insn (gen_call_value_multiple_internal2\n+\t  emit_call_insn (gen_call_value_multiple_internal0\n \t\t\t  (XEXP (XVECEXP (operands[0], 0, 0), 0),\n \t\t\t   operands[1], operands[2],\n \t\t\t   XEXP (XVECEXP (operands[0], 0, 1), 0),\n \t\t\t   gen_rtx (REG, SImode, GP_REG_FIRST + 31)));\n \t  DONE;\n \t}\n \n-      emit_call_insn (gen_call_value_internal1 (operands[0], operands[1], operands[2],\n-\t\t\t\t\t        gen_rtx (REG, SImode, GP_REG_FIRST + 31)));\n+      emit_call_insn (gen_call_value_internal0 (operands[0], operands[1], operands[2],\n+\t\t\t\t\t        gen_rtx (REG, Pmode, GP_REG_FIRST + 31)));\n \n       DONE;\n     }\n }\")\n \n+(define_expand \"call_value_internal0\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (match_operand:SI 3 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n (define_insn \"call_value_internal1\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (match_operand 1 \"call_insn_operand\" \"m\")\n+        (call (mem (match_operand 1 \"call_insn_operand\" \"ri\"))\n               (match_operand 2 \"\" \"i\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n   \"!TARGET_ABICALLS && !TARGET_LONG_CALLS\"\n   \"*\n {\n-  register rtx target = XEXP (operands[1], 0);\n+  register rtx target = operands[1];\n \n   if (GET_CODE (target) == SYMBOL_REF)\n     return \\\"%*jal\\\\t%1\\\";\n@@ -6501,13 +6564,13 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"call_value_internal2\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (match_operand 1 \"call_insn_operand\" \"m\")\n+        (call (mem (match_operand 1 \"call_insn_operand\" \"ri\"))\n               (match_operand 2 \"\" \"i\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n   \"TARGET_ABICALLS && !TARGET_LONG_CALLS\"\n   \"*\n {\n-  register rtx target = XEXP (operands[1], 0);\n+  register rtx target = operands[1];\n \n   if (GET_CODE (target) == SYMBOL_REF)\n     return \\\"jal\\\\t%1\\\";\n@@ -6587,21 +6650,32 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"2\")])\n \n+(define_insn \"call_value_multiple_internal0\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (set (match_operand 3 \"\" \"\")\n+\t\t   (call (match_dup 1)\n+\t\t\t (match_dup 2)))\n+\t      (clobber (match_operand:SI 4 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n ;; ??? May eventually need all 6 versions of the call patterns with multiple\n ;; return values.\n \n (define_insn \"call_value_multiple_internal2\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (match_operand 1 \"call_insn_operand\" \"m\")\n+        (call (mem (match_operand 1 \"call_insn_operand\" \"ri\"))\n               (match_operand 2 \"\" \"i\")))\n    (set (match_operand 3 \"register_operand\" \"=df\")\n-        (call (match_dup 1)\n+        (call (mem (match_dup 1))\n               (match_dup 2)))\n    (clobber (match_operand:SI 4 \"register_operand\" \"=d\"))]\n   \"TARGET_ABICALLS && !TARGET_LONG_CALLS\"\n   \"*\n {\n-  register rtx target = XEXP (operands[1], 0);\n+  register rtx target = operands[1];\n \n   if (GET_CODE (target) == SYMBOL_REF)\n     return \\\"jal\\\\t%1\\\";"}]}