{"sha": "c29301d6b19c28277b5a419e74297261d66e719e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI5MzAxZDZiMTljMjgyNzdiNWE0MTllNzQyOTcyNjFkNjZlNzE5ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-27T19:14:55Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-27T19:14:55Z"}, "message": "Add runtime profiling infrastructure, not yet working.\n\nFrom-SVN: r171579", "tree": {"sha": "697642cd2e886980983c07df0c23953228a22714", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/697642cd2e886980983c07df0c23953228a22714"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c29301d6b19c28277b5a419e74297261d66e719e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c29301d6b19c28277b5a419e74297261d66e719e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c29301d6b19c28277b5a419e74297261d66e719e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c29301d6b19c28277b5a419e74297261d66e719e/comments", "author": null, "committer": null, "parents": [{"sha": "d253656a7be7461c2fc7bb638e93b9943a91de9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d253656a7be7461c2fc7bb638e93b9943a91de9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d253656a7be7461c2fc7bb638e93b9943a91de9b"}], "stats": {"total": 641, "additions": 598, "deletions": 43}, "files": [{"sha": "24587ca34acd17daefccb484a40de6bf255578cf", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -423,6 +423,7 @@ runtime_files = \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n \truntime/go-unwind.c \\\n+\truntime/cpuprof.c \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n \t$(runtime_mem_file) \\"}, {"sha": "e61f1e749652b1af7aec12b0e0f4c46ec3318c32", "filename": "libgo/Makefile.in", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -207,7 +207,7 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-typestring.c runtime/go-unreflect.c \\\n \truntime/go-unsafe-new.c runtime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c runtime/go-unwind.c \\\n-\truntime/mcache.c runtime/mcentral.c \\\n+\truntime/cpuprof.c runtime/mcache.c runtime/mcentral.c \\\n \truntime/mem_posix_memalign.c runtime/mem.c runtime/mfinal.c \\\n \truntime/mfixalloc.c runtime/mgc0.c runtime/mheap.c \\\n \truntime/msize.c runtime/proc.c runtime/thread.c \\\n@@ -240,10 +240,11 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n \tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unwind.lo mcache.lo mcentral.lo \\\n-\t$(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo mheap.lo \\\n-\tmsize.lo proc.lo thread.lo $(am__objects_2) chan.lo iface.lo \\\n-\tmalloc.lo map.lo mprof.lo reflect.lo sigqueue.lo string.lo\n+\tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo mcache.lo \\\n+\tmcentral.lo $(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo \\\n+\tmheap.lo msize.lo proc.lo thread.lo $(am__objects_2) chan.lo \\\n+\tiface.lo malloc.lo map.lo mprof.lo reflect.lo sigqueue.lo \\\n+\tstring.lo\n am_libgo_la_OBJECTS = $(am__objects_3)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -836,6 +837,7 @@ runtime_files = \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n \truntime/go-unwind.c \\\n+\truntime/cpuprof.c \\\n \truntime/mcache.c \\\n \truntime/mcentral.c \\\n \t$(runtime_mem_file) \\\n@@ -2164,6 +2166,7 @@ distclean-compile:\n \t-rm -f *.tab.c\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chan.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpuprof.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-append.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert.Plo@am__quote@\n@@ -2836,6 +2839,13 @@ go-unwind.lo: runtime/go-unwind.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-unwind.lo `test -f 'runtime/go-unwind.c' || echo '$(srcdir)/'`runtime/go-unwind.c\n \n+cpuprof.lo: runtime/cpuprof.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cpuprof.lo -MD -MP -MF $(DEPDIR)/cpuprof.Tpo -c -o cpuprof.lo `test -f 'runtime/cpuprof.c' || echo '$(srcdir)/'`runtime/cpuprof.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cpuprof.Tpo $(DEPDIR)/cpuprof.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/cpuprof.c' object='cpuprof.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cpuprof.lo `test -f 'runtime/cpuprof.c' || echo '$(srcdir)/'`runtime/cpuprof.c\n+\n mcache.lo: runtime/mcache.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mcache.lo -MD -MP -MF $(DEPDIR)/mcache.Tpo -c -o mcache.lo `test -f 'runtime/mcache.c' || echo '$(srcdir)/'`runtime/mcache.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mcache.Tpo $(DEPDIR)/mcache.Plo"}, {"sha": "07567ccaffd1b38a8e98aafa16d88891d1a61db1", "filename": "libgo/runtime/cpuprof.c", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fcpuprof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fcpuprof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fcpuprof.c?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -0,0 +1,432 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// CPU profiling.\n+// Based on algorithms and data structures used in\n+// http://code.google.com/p/google-perftools/.\n+//\n+// The main difference between this code and the google-perftools\n+// code is that this code is written to allow copying the profile data\n+// to an arbitrary io.Writer, while the google-perftools code always\n+// writes to an operating system file.\n+//\n+// The signal handler for the profiling clock tick adds a new stack trace\n+// to a hash table tracking counts for recent traces.  Most clock ticks\n+// hit in the cache.  In the event of a cache miss, an entry must be \n+// evicted from the hash table, copied to a log that will eventually be\n+// written as profile data.  The google-perftools code flushed the\n+// log itself during the signal handler.  This code cannot do that, because\n+// the io.Writer might block or need system calls or locks that are not\n+// safe to use from within the signal handler.  Instead, we split the log\n+// into two halves and let the signal handler fill one half while a goroutine\n+// is writing out the other half.  When the signal handler fills its half, it\n+// offers to swap with the goroutine.  If the writer is not done with its half,\n+// we lose the stack trace for this clock tick (and record that loss).\n+// The goroutine interacts with the signal handler by calling getprofile() to\n+// get the next log piece to write, implicitly handing back the last log\n+// piece it obtained.\n+//\n+// The state of this dance between the signal handler and the goroutine\n+// is encoded in the Profile.handoff field.  If handoff == 0, then the goroutine\n+// is not using either log half and is waiting (or will soon be waiting) for\n+// a new piece by calling notesleep(&p->wait).  If the signal handler\n+// changes handoff from 0 to non-zero, it must call notewakeup(&p->wait)\n+// to wake the goroutine.  The value indicates the number of entries in the\n+// log half being handed off.  The goroutine leaves the non-zero value in\n+// place until it has finished processing the log half and then flips the number\n+// back to zero.  Setting the high bit in handoff means that the profiling is over, \n+// and the goroutine is now in charge of flushing the data left in the hash table\n+// to the log and returning that data.  \n+//\n+// The handoff field is manipulated using atomic operations.\n+// For the most part, the manipulation of handoff is orderly: if handoff == 0\n+// then the signal handler owns it and can change it to non-zero.  \n+// If handoff != 0 then the goroutine owns it and can change it to zero.\n+// If that were the end of the story then we would not need to manipulate\n+// handoff using atomic operations.  The operations are needed, however,\n+// in order to let the log closer set the high bit to indicate \"EOF\" safely\n+// in the situation when normally the goroutine \"owns\" handoff.\n+\n+#include \"runtime.h\"\n+#include \"malloc.h\"\n+\n+#include \"array.h\"\n+typedef struct __go_open_array Slice;\n+#define array __values\n+#define len __count\n+#define cap __capacity\n+\n+enum\n+{\n+\tHashSize = 1<<10,\n+\tLogSize = 1<<17,\n+\tAssoc = 4,\n+\tMaxStack = 64,\n+};\n+\n+typedef struct Profile Profile;\n+typedef struct Bucket Bucket;\n+typedef struct Entry Entry;\n+\n+struct Entry {\n+\tuintptr count;\n+\tuintptr depth;\n+\tuintptr stack[MaxStack];\n+};\n+\n+struct Bucket {\n+\tEntry entry[Assoc];\n+};\n+\n+struct Profile {\n+\tbool on;\t\t// profiling is on\n+\tNote wait;\t\t// goroutine waits here\n+\tuintptr count;\t\t// tick count\n+\tuintptr evicts;\t\t// eviction count\n+\tuintptr lost;\t\t// lost ticks that need to be logged\n+\tuintptr totallost;\t// total lost ticks\n+\n+\t// Active recent stack traces.\n+\tBucket hash[HashSize];\n+\n+\t// Log of traces evicted from hash.\n+\t// Signal handler has filled log[toggle][:nlog].\n+\t// Goroutine is writing log[1-toggle][:handoff].\n+\tuintptr log[2][LogSize/2];\n+\tuintptr nlog;\n+\tint32 toggle;\n+\tuint32 handoff;\n+\t\n+\t// Writer state.\n+\t// Writer maintains its own toggle to avoid races\n+\t// looking at signal handler's toggle.\n+\tuint32 wtoggle;\n+\tbool wholding;\t// holding & need to release a log half\n+\tbool flushing;\t// flushing hash table - profile is over\n+};\n+\n+static Lock lk;\n+static Profile *prof;\n+\n+static void tick(uintptr*, int32);\n+static void add(Profile*, uintptr*, int32);\n+static bool evict(Profile*, Entry*);\n+static bool flushlog(Profile*);\n+\n+// LostProfileData is a no-op function used in profiles\n+// to mark the number of profiling stack traces that were\n+// discarded due to slow data writers.\n+static void LostProfileData(void) {\n+}\n+\n+extern void runtime_SetCPUProfileRate(int32)\n+     __asm__(\"libgo_runtime.runtime.SetCPUProfileRate\");\n+\n+// SetCPUProfileRate sets the CPU profiling rate.\n+// The user documentation is in debug.go.\n+void\n+runtime_SetCPUProfileRate(int32 hz)\n+{\n+\tuintptr *p;\n+\tuintptr n;\n+\n+\t// Clamp hz to something reasonable.\n+\tif(hz < 0)\n+\t\thz = 0;\n+\tif(hz > 1000000)\n+\t\thz = 1000000;\n+\n+\truntime_lock(&lk);\n+\tif(hz > 0) {\n+\t\tif(prof == nil) {\n+\t\t\tprof = runtime_SysAlloc(sizeof *prof);\n+\t\t\tif(prof == nil) {\n+\t\t\t\truntime_printf(\"runtime: cpu profiling cannot allocate memory\\n\");\n+\t\t\t\truntime_unlock(&lk);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tif(prof->on || prof->handoff != 0) {\n+\t\t\truntime_printf(\"runtime: cannot set cpu profile rate until previous profile has finished.\\n\");\n+\t\t\truntime_unlock(&lk);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tprof->on = true;\n+\t\tp = prof->log[0];\n+\t\t// pprof binary header format.\n+\t\t// http://code.google.com/p/google-perftools/source/browse/trunk/src/profiledata.cc#117\n+\t\t*p++ = 0;  // count for header\n+\t\t*p++ = 3;  // depth for header\n+\t\t*p++ = 0;  // version number\n+\t\t*p++ = 1000000 / hz;  // period (microseconds)\n+\t\t*p++ = 0;\n+\t\tprof->nlog = p - prof->log[0];\n+\t\tprof->toggle = 0;\n+\t\tprof->wholding = false;\n+\t\tprof->wtoggle = 0;\n+\t\tprof->flushing = false;\n+\t\truntime_noteclear(&prof->wait);\n+\n+\t\truntime_setcpuprofilerate(tick, hz);\n+\t} else if(prof->on) {\n+\t\truntime_setcpuprofilerate(nil, 0);\n+\t\tprof->on = false;\n+\n+\t\t// Now add is not running anymore, and getprofile owns the entire log.\n+\t\t// Set the high bit in prof->handoff to tell getprofile.\n+\t\tfor(;;) {\n+\t\t\tn = prof->handoff;\n+\t\t\tif(n&0x80000000)\n+\t\t\t\truntime_printf(\"runtime: setcpuprofile(off) twice\");\n+\t\t\tif(runtime_cas(&prof->handoff, n, n|0x80000000))\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tif(n == 0) {\n+\t\t\t// we did the transition from 0 -> nonzero so we wake getprofile\n+\t\t\truntime_notewakeup(&prof->wait);\n+\t\t}\n+\t}\n+\truntime_unlock(&lk);\n+}\n+\n+static void\n+tick(uintptr *pc, int32 n)\n+{\n+\tadd(prof, pc, n);\n+}\n+\n+// add adds the stack trace to the profile.\n+// It is called from signal handlers and other limited environments\n+// and cannot allocate memory or acquire locks that might be\n+// held at the time of the signal, nor can it use substantial amounts\n+// of stack.  It is allowed to call evict.\n+static void\n+add(Profile *p, uintptr *pc, int32 n)\n+{\n+\tint32 i, j;\n+\tuintptr h, x;\n+\tBucket *b;\n+\tEntry *e;\n+\n+\tif(n > MaxStack)\n+\t\tn = MaxStack;\n+\t\n+\t// Compute hash.\n+\th = 0;\n+\tfor(i=0; i<n; i++) {\n+\t\th = h<<8 | (h>>(8*(sizeof(h)-1)));\n+\t\tx = pc[i];\n+\t\th += x*31 + x*7 + x*3;\n+\t}\n+\tp->count++;\n+\n+\t// Add to entry count if already present in table.\n+\tb = &p->hash[h%HashSize];\n+\tfor(i=0; i<Assoc; i++) {\n+\t\te = &b->entry[i];\n+\t\tif(e->depth != (uintptr)n)\t\n+\t\t\tcontinue;\n+\t\tfor(j=0; j<n; j++)\n+\t\t\tif(e->stack[j] != pc[j])\n+\t\t\t\tgoto ContinueAssoc;\n+\t\te->count++;\n+\t\treturn;\n+\tContinueAssoc:;\n+\t}\n+\n+\t// Evict entry with smallest count.\n+\te = &b->entry[0];\n+\tfor(i=1; i<Assoc; i++)\n+\t\tif(b->entry[i].count < e->count)\n+\t\t\te = &b->entry[i];\n+\tif(e->count > 0) {\n+\t\tif(!evict(p, e)) {\n+\t\t\t// Could not evict entry.  Record lost stack.\n+\t\t\tp->lost++;\n+\t\t\tp->totallost++;\n+\t\t\treturn;\n+\t\t}\n+\t\tp->evicts++;\n+\t}\n+\t\n+\t// Reuse the newly evicted entry.\n+\te->depth = n;\n+\te->count = 1;\n+\tfor(i=0; i<n; i++)\n+\t\te->stack[i] = pc[i];\n+}\n+\n+// evict copies the given entry's data into the log, so that\n+// the entry can be reused.  evict is called from add, which\n+// is called from the profiling signal handler, so it must not\n+// allocate memory or block.  It is safe to call flushLog.\n+// evict returns true if the entry was copied to the log,\n+// false if there was no room available.\n+static bool\n+evict(Profile *p, Entry *e)\n+{\n+\tint32 i, d, nslot;\n+\tuintptr *log, *q;\n+\t\n+\td = e->depth;\n+\tnslot = d+2;\n+\tlog = p->log[p->toggle];\n+\tif(p->nlog+nslot > nelem(p->log[0])) {\n+\t\tif(!flushlog(p))\n+\t\t\treturn false;\n+\t\tlog = p->log[p->toggle];\n+\t}\n+\t\n+\tq = log+p->nlog;\n+\t*q++ = e->count;\n+\t*q++ = d;\n+\tfor(i=0; i<d; i++)\n+\t\t*q++ = e->stack[i];\n+\tp->nlog = q - log;\n+\te->count = 0;\n+\treturn true;\n+}\n+\n+// flushlog tries to flush the current log and switch to the other one.\n+// flushlog is called from evict, called from add, called from the signal handler,\n+// so it cannot allocate memory or block.  It can try to swap logs with\n+// the writing goroutine, as explained in the comment at the top of this file.\n+static bool\n+flushlog(Profile *p)\n+{\n+\tuintptr *log, *q;\n+\n+\tif(!runtime_cas(&p->handoff, 0, p->nlog))\n+\t\treturn false;\n+\truntime_notewakeup(&p->wait);\n+\n+\tp->toggle = 1 - p->toggle;\n+\tlog = p->log[p->toggle];\n+\tq = log;\n+\tif(p->lost > 0) {\n+\t\t*q++ = p->lost;\n+\t\t*q++ = 1;\n+\t\t*q++ = (uintptr)LostProfileData;\n+\t}\n+\tp->nlog = q - log;\n+\treturn true;\n+}\n+\n+// getprofile blocks until the next block of profiling data is available\n+// and returns it as a []byte.  It is called from the writing goroutine.\n+Slice\n+getprofile(Profile *p)\n+{\n+\tuint32 i, j, n;\n+\tSlice ret;\n+\tBucket *b;\n+\tEntry *e;\n+\n+\tret.array = nil;\n+\tret.len = 0;\n+\tret.cap = 0;\n+\t\n+\tif(p == nil)\t\n+\t\treturn ret;\n+\n+\tif(p->wholding) {\n+\t\t// Release previous log to signal handling side.\n+\t\t// Loop because we are racing against setprofile(off).\n+\t\tfor(;;) {\n+\t\t\tn = p->handoff;\n+\t\t\tif(n == 0) {\n+\t\t\t\truntime_printf(\"runtime: phase error during cpu profile handoff\\n\");\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t\tif(n & 0x80000000) {\n+\t\t\t\tp->wtoggle = 1 - p->wtoggle;\n+\t\t\t\tp->wholding = false;\n+\t\t\t\tp->flushing = true;\n+\t\t\t\tgoto flush;\n+\t\t\t}\n+\t\t\tif(runtime_cas(&p->handoff, n, 0))\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tp->wtoggle = 1 - p->wtoggle;\n+\t\tp->wholding = false;\n+\t}\n+\t\n+\tif(p->flushing)\n+\t\tgoto flush;\n+\t\n+\tif(!p->on && p->handoff == 0)\n+\t\treturn ret;\n+\n+\t// Wait for new log.\n+\t// runtime\u00b7entersyscall();\n+\truntime_notesleep(&p->wait);\n+\t// runtime\u00b7exitsyscall();\n+\truntime_noteclear(&p->wait);\n+\n+\tn = p->handoff;\n+\tif(n == 0) {\n+\t\truntime_printf(\"runtime: phase error during cpu profile wait\\n\");\n+\t\treturn ret;\n+\t}\n+\tif(n == 0x80000000) {\n+\t\tp->flushing = true;\n+\t\tgoto flush;\n+\t}\n+\tn &= ~0x80000000;\n+\n+\t// Return new log to caller.\n+\tp->wholding = true;\n+\n+\tret.array = (byte*)p->log[p->wtoggle];\n+\tret.len = n*sizeof(uintptr);\n+\tret.cap = ret.len;\n+\treturn ret;\n+\n+flush:\n+\t// In flush mode.\n+\t// Add is no longer being called.  We own the log.\n+\t// Also, p->handoff is non-zero, so flushlog will return false.\n+\t// Evict the hash table into the log and return it.\n+\tfor(i=0; i<HashSize; i++) {\n+\t\tb = &p->hash[i];\n+\t\tfor(j=0; j<Assoc; j++) {\n+\t\t\te = &b->entry[j];\n+\t\t\tif(e->count > 0 && !evict(p, e)) {\n+\t\t\t\t// Filled the log.  Stop the loop and return what we've got.\n+\t\t\t\tgoto breakflush;\n+\t\t\t}\n+\t\t}\n+\t}\n+breakflush:\n+\n+\t// Return pending log data.\n+\tif(p->nlog > 0) {\n+\t\t// Note that we're using toggle now, not wtoggle,\n+\t\t// because we're working on the log directly.\n+\t\tret.array = (byte*)p->log[p->toggle];\n+\t\tret.len = p->nlog*sizeof(uintptr);\n+\t\tret.cap = ret.len;\n+\t\tp->nlog = 0;\n+\t\treturn ret;\n+\t}\n+\n+\t// Made it through the table without finding anything to log.\n+\t// Finally done.  Clean up and return nil.\n+\tp->flushing = false;\n+\tif(!runtime_cas(&p->handoff, p->handoff, 0))\n+\t\truntime_printf(\"runtime: profile flush racing with something\\n\");\n+\treturn ret;  // set to nil at top of function\n+}\n+\n+extern Slice runtime_CPUProfile(void)\n+     __asm__(\"libgo_runtime.runtime.CPUProfile\");\n+\n+// CPUProfile returns the next cpu profile block as a []byte.\n+// The user documentation is in debug.go.\n+Slice\n+runtime_CPUProfile(void)\n+{\n+\treturn getprofile(prof);\n+}"}, {"sha": "2b80b9b12212950c1ddefa380e91aad11cc96b9a", "filename": "libgo/runtime/go-note.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fgo-note.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fgo-note.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-note.c?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -21,7 +21,7 @@ static pthread_cond_t note_cond = PTHREAD_COND_INITIALIZER;\n    notewakeup.  */\n \n void\n-noteclear (Note* n)\n+runtime_noteclear (Note* n)\n {\n   int32 i;\n \n@@ -37,7 +37,7 @@ noteclear (Note* n)\n /* Wait until notewakeup is called.  */\n \n void\n-notesleep (Note* n)\n+runtime_notesleep (Note* n)\n {\n   int32 i;\n \n@@ -57,7 +57,7 @@ notesleep (Note* n)\n /* Wake up every thread sleeping on the note.  */\n \n void\n-notewakeup (Note *n)\n+runtime_notewakeup (Note *n)\n {\n   int32 i;\n "}, {"sha": "edeeccc79eb2f6444efec249c353d450937eaccf", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 78, "deletions": 28, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -6,17 +6,16 @@\n \n #include <signal.h>\n #include <stdlib.h>\n+#include <sys/time.h>\n \n #include \"go-assert.h\"\n #include \"go-panic.h\"\n #include \"go-signal.h\"\n \n #include \"runtime.h\"\n \n-#undef int \n-\n-#ifndef SA_ONSTACK\n-#define SA_ONSTACK 0\n+#ifndef SA_RESTART\n+  #define SA_RESTART 0\n #endif\n \n /* What to do for a signal.  */\n@@ -27,68 +26,70 @@ struct sigtab\n   int sig;\n   /* Nonzero if the signal should be ignored.  */\n   _Bool ignore;\n+  /* Nonzero if we should restart system calls.  */\n+  _Bool restart;\n };\n \n /* What to do for signals.  */\n \n static struct sigtab signals[] =\n {\n-  { SIGHUP, 0 },\n-  { SIGINT, 0 },\n-  { SIGALRM, 1 },\n-  { SIGTERM, 0 },\n+  { SIGHUP, 0, 1 },\n+  { SIGINT, 0, 1 },\n+  { SIGALRM, 1, 1 },\n+  { SIGTERM, 0, 1 },\n #ifdef SIGBUS\n-  { SIGBUS, 0 },\n+  { SIGBUS, 0, 0 },\n #endif\n #ifdef SIGFPE\n-  { SIGFPE, 0 },\n+  { SIGFPE, 0, 0 },\n #endif\n #ifdef SIGUSR1\n-  { SIGUSR1, 1 },\n+  { SIGUSR1, 1, 1 },\n #endif\n #ifdef SIGSEGV\n-  { SIGSEGV, 0 },\n+  { SIGSEGV, 0, 0 },\n #endif\n #ifdef SIGUSR2\n-  { SIGUSR2, 1 },\n+  { SIGUSR2, 1, 1 },\n #endif\n #ifdef SIGPIPE\n-  { SIGPIPE, 1 },\n+  { SIGPIPE, 1, 0 },\n #endif\n #ifdef SIGCHLD\n-  { SIGCHLD, 1 },\n+  { SIGCHLD, 1, 1 },\n #endif\n #ifdef SIGTSTP\n-  { SIGTSTP, 1 },\n+  { SIGTSTP, 1, 1 },\n #endif\n #ifdef SIGTTIN\n-  { SIGTTIN, 1 },\n+  { SIGTTIN, 1, 1 },\n #endif\n #ifdef SIGTTOU\n-  { SIGTTOU, 1 },\n+  { SIGTTOU, 1, 1 },\n #endif\n #ifdef SIGURG\n-  { SIGURG, 1 },\n+  { SIGURG, 1, 1 },\n #endif\n #ifdef SIGXCPU\n-  { SIGXCPU, 1 },\n+  { SIGXCPU, 1, 1 },\n #endif\n #ifdef SIGXFSZ\n-  { SIGXFSZ, 1 },\n+  { SIGXFSZ, 1, 1 },\n #endif\n #ifdef SIGVTARLM\n-  { SIGVTALRM, 1 },\n+  { SIGVTALRM, 1, 1 },\n #endif\n #ifdef SIGWINCH\n-  { SIGWINCH, 1 },\n+  { SIGWINCH, 1, 1 },\n #endif\n #ifdef SIGIO\n-  { SIGIO, 1 },\n+  { SIGIO, 1, 1 },\n #endif\n #ifdef SIGPWR\n-  { SIGPWR, 1 },\n+  { SIGPWR, 1, 1 },\n #endif\n-  { -1, 0 }\n+  { -1, 0, 0 }\n };\n \n /* The Go signal handler.  */\n@@ -99,6 +100,13 @@ sighandler (int sig)\n   const char *msg;\n   int i;\n \n+  if (sig == SIGPROF)\n+    {\n+      /* FIXME.  */\n+      runtime_sigprof (0, 0, nil);\n+      return;\n+    }\n+\n   /* FIXME: Should check siginfo for more information when\n      available.  */\n   msg = NULL;\n@@ -192,6 +200,48 @@ __initsig ()\n   __go_assert (i == 0);\n \n   for (i = 0; signals[i].sig != -1; ++i)\n-    if (sigaction (signals[i].sig, &sa, NULL) != 0)\n-      __go_assert (0);\n+    {\n+      sa.sa_flags = signals[i].restart ? SA_RESTART : 0;\n+      if (sigaction (signals[i].sig, &sa, NULL) != 0)\n+\t__go_assert (0);\n+    }\n+}\n+\n+void\n+runtime_resetcpuprofiler(int32 hz)\n+{\n+  struct itimerval it;\n+  struct sigaction sa;\n+  int i;\n+\n+  memset (&it, 0, sizeof it);\n+\n+  memset (&sa, 0, sizeof sa);\n+  i = sigfillset (&sa.sa_mask);\n+  __go_assert (i == 0);\n+\n+  if (hz == 0)\n+    {\n+      i = setitimer (ITIMER_PROF, &it, NULL);\n+      __go_assert (i == 0);\n+\n+      sa.sa_handler = SIG_IGN;\n+      i = sigaction (SIGPROF, &sa, NULL);\n+      __go_assert (i == 0);\n+    }\n+  else\n+    {\n+      sa.sa_handler = sighandler;\n+      sa.sa_flags = SA_RESTART;\n+      i = sigaction (SIGPROF, &sa, NULL);\n+      __go_assert (i == 0);\n+\n+      it.it_interval.tv_sec = 0;\n+      it.it_interval.tv_usec = 1000000 / hz;\n+      it.it_value = it.it_interval;\n+      i = setitimer (ITIMER_PROF, &it, NULL);\n+      __go_assert (i == 0);\n+    }\n+\n+  m->profilehz = hz;\n }"}, {"sha": "bbdf894f49d1a68a328db439d7cac07da79967c5", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -14,3 +14,60 @@ M\tm0;\n #endif\n \n __thread M *m = &m0;\n+\n+static struct {\n+\tLock;\n+\tvoid (*fn)(uintptr*, int32);\n+\tint32 hz;\n+\tuintptr pcbuf[100];\n+} prof;\n+\n+void\n+runtime_sigprof(uint8 *pc __attribute__ ((unused)),\n+\t\tuint8 *sp __attribute__ ((unused)),\n+\t\tuint8 *lr __attribute__ ((unused)))\n+{\n+\tint32 n;\n+\t\n+\tif(prof.fn == nil || prof.hz == 0)\n+\t\treturn;\n+\t\n+\truntime_lock(&prof);\n+\tif(prof.fn == nil) {\n+\t\truntime_unlock(&prof);\n+\t\treturn;\n+\t}\n+\tn = 0;\n+\t// n = runtime\u00b7gentraceback(pc, sp, lr, gp, 0, prof.pcbuf, nelem(prof.pcbuf));\n+\tif(n > 0)\n+\t\tprof.fn(prof.pcbuf, n);\n+\truntime_unlock(&prof);\n+}\n+\n+void\n+runtime_setcpuprofilerate(void (*fn)(uintptr*, int32), int32 hz)\n+{\n+\t// Force sane arguments.\n+\tif(hz < 0)\n+\t\thz = 0;\n+\tif(hz == 0)\n+\t\tfn = nil;\n+\tif(fn == nil)\n+\t\thz = 0;\n+\n+\t// Stop profiler on this cpu so that it is safe to lock prof.\n+\t// if a profiling signal came in while we had prof locked,\n+\t// it would deadlock.\n+\truntime_resetcpuprofiler(0);\n+\n+\truntime_lock(&prof);\n+\tprof.fn = fn;\n+\tprof.hz = hz;\n+\truntime_unlock(&prof);\n+\t// runtime_lock(&runtime_sched);\n+\t// runtime_sched.profilehz = hz;\n+\t// runtime_unlock(&runtime_sched);\n+\t\n+\tif(hz != 0)\n+\t\truntime_resetcpuprofiler(hz);\n+}"}, {"sha": "af98683aab13a1a304c7a19cb138f0e30aa2217a", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -102,6 +102,7 @@ struct\tM\n \tint32\tgcing_for_prof;\n \tint32\tholds_finlock;\n \tint32\tgcing_for_finlock;\n+\tint32\tprofilehz;\n \tMCache\t*mcache;\n \n \t/* For the list of all threads.  */\n@@ -163,9 +164,9 @@ void semrelease (uint32 *) asm (\"libgo_runtime.runtime.Semrelease\");\n  * once notewakeup has been called, all the notesleeps\n  * will return.  future notesleeps will return immediately.\n  */\n-void\tnoteclear(Note*);\n-void\tnotesleep(Note*);\n-void\tnotewakeup(Note*);\n+void\truntime_noteclear(Note*);\n+void\truntime_notesleep(Note*);\n+void\truntime_notewakeup(Note*);\n \n /* Functions.  */\n #define runtime_printf printf\n@@ -187,6 +188,10 @@ void\truntime_walkfintab(void (*fn)(void*), void (*scan)(byte *, int64));\n #define runtime_cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n #define runtime_casp(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n \n+void\truntime_sigprof(uint8 *pc, uint8 *sp, uint8 *lr);\n+void\truntime_resetcpuprofiler(int32);\n+void\truntime_setcpuprofilerate(void(*)(uintptr*, int32), int32);\n+\n struct __go_func_type;\n void reflect_call(const struct __go_func_type *, const void *, _Bool, void **,\n \t\t  void **)"}, {"sha": "2e4722238a445cb2889f66e2eb0b3813665e8a25", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c29301d6b19c28277b5a419e74297261d66e719e/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=c29301d6b19c28277b5a419e74297261d66e719e", "patch": "@@ -51,7 +51,7 @@ static struct {\n void\n siginit(void)\n {\n-\tnoteclear(&sig);\n+\truntime_noteclear(&sig);\n }\n \n // Called from sighandler to send a signal back out of the signal handling thread.\n@@ -71,7 +71,7 @@ __go_sigsend(int32 s)\n \t\t\t// Added to queue.\n \t\t\t// Only send a wakeup for the first signal in each round.\n \t\t\tif(mask == 0)\n-\t\t\t\tnotewakeup(&sig);\n+\t\t\t\truntime_notewakeup(&sig);\n \t\t\tbreak;\n \t\t}\n \t}\n@@ -81,9 +81,9 @@ __go_sigsend(int32 s)\n // Called to receive a bitmask of queued signals.\n func Sigrecv() (m uint32) {\n \t// runtime\u00b7entersyscall();\n-\tnotesleep(&sig);\n+\truntime_notesleep(&sig);\n \t// runtime\u00b7exitsyscall();\n-\tnoteclear(&sig);\n+\truntime_noteclear(&sig);\n \tfor(;;) {\n \t\tm = sig.mask;\n \t\tif(runtime_cas(&sig.mask, m, 0))"}]}