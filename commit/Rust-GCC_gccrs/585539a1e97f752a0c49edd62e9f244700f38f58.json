{"sha": "585539a1e97f752a0c49edd62e9f244700f38f58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg1NTM5YTFlOTdmNzUyYTBjNDllZGQ2MmU5ZjI0NDcwMGYzOGY1OA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-06-27T15:31:53Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-06-27T15:31:53Z"}, "message": "s390-protos.h (s390_load_got): Update prototype.\n\n\t* config/s390/s390-protos.h (s390_load_got): Update prototype.\n\t* config/s390/s390.c (struct machine_function): Add member base_reg.\n\t(s390_decompose_address): Accept UNSPEC_LTREF.  Simplify logic.\n\t(s390_split_branches): Annotate late pool references.\n\t(annotate_constant_pool_refs): New function.\n\t(find_constant_pool_ref): Work on annotated pool references.\n\t(replace_constant_pool_ref): Likewise.  Use explicit base.\n\t(replace_ltrel_base): Use explicit base.\n\t(s390_mainpool_start): Reflect main_pool pattern change.\n\t(s390_mainpool_finish): Use base register from main_pool.\n\tUpdate calls to replace_ltrel_base and replace_constant_pool_ref.\n\t(s390_chunkify_start): Use base_reg from struct machine_function.\n\t(s390_chunkify_finish): Remove base_reg argument.  Update calls\n\tto replace_ltrel_base and replace_constant_pool_ref.\n\t(s390_reorg): Don't decide upon base register.  Update calls.\n\t(s390_load_got): Remove MAYBE_DEAD handling.  Do not emit insns\n\tbut return sequence instead.\n\t(s390_emit_prologue): Decide upon base register to use.  Annotate\n\tall literal pool references.  Adapt to main_pool pattern change.\n\tUpdate s390_load_got call; move MAYBE_DEAD handling here.\n\t(s390_emit_epilogue): Annotate late literal pool references.\n\tRemove barrier before register restore instruction.\n\t* config/s390/s390.md (UNSPEC_LTREF): New constant.\n\t(\"builtin_setjmp_receiver\"): Update s390_load_got call.\n\t(\"main_pool\"): Explicitly reference base register.\n\nFrom-SVN: r83735", "tree": {"sha": "e2fca769f59904c06f359a977016ccbfe57c6045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2fca769f59904c06f359a977016ccbfe57c6045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/585539a1e97f752a0c49edd62e9f244700f38f58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/585539a1e97f752a0c49edd62e9f244700f38f58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/585539a1e97f752a0c49edd62e9f244700f38f58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/585539a1e97f752a0c49edd62e9f244700f38f58/comments", "author": null, "committer": null, "parents": [{"sha": "0f6cd83f96821808017f3b2318da521a9c29ed62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6cd83f96821808017f3b2318da521a9c29ed62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f6cd83f96821808017f3b2318da521a9c29ed62"}], "stats": {"total": 597, "additions": 385, "deletions": 212}, "files": [{"sha": "edfb656615c9af7816775e0c3031caf7372d7f95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=585539a1e97f752a0c49edd62e9f244700f38f58", "patch": "@@ -1,3 +1,31 @@\n+2004-06-27  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_load_got): Update prototype.\n+\t* config/s390/s390.c (struct machine_function): Add member base_reg.\n+\t(s390_decompose_address): Accept UNSPEC_LTREF.  Simplify logic.\n+\t(s390_split_branches): Annotate late pool references.\n+\t(annotate_constant_pool_refs): New function.\n+\t(find_constant_pool_ref): Work on annotated pool references.\n+\t(replace_constant_pool_ref): Likewise.  Use explicit base.\n+\t(replace_ltrel_base): Use explicit base.\n+\t(s390_mainpool_start): Reflect main_pool pattern change.\n+\t(s390_mainpool_finish): Use base register from main_pool.\n+\tUpdate calls to replace_ltrel_base and replace_constant_pool_ref.\n+\t(s390_chunkify_start): Use base_reg from struct machine_function.\n+\t(s390_chunkify_finish): Remove base_reg argument.  Update calls\n+\tto replace_ltrel_base and replace_constant_pool_ref.\n+\t(s390_reorg): Don't decide upon base register.  Update calls.\n+\t(s390_load_got): Remove MAYBE_DEAD handling.  Do not emit insns\n+\tbut return sequence instead.\n+\t(s390_emit_prologue): Decide upon base register to use.  Annotate\n+\tall literal pool references.  Adapt to main_pool pattern change.\n+\tUpdate s390_load_got call; move MAYBE_DEAD handling here.\n+\t(s390_emit_epilogue): Annotate late literal pool references.\n+\tRemove barrier before register restore instruction.\n+\t* config/s390/s390.md (UNSPEC_LTREF): New constant.\n+\t(\"builtin_setjmp_receiver\"): Update s390_load_got call.\n+\t(\"main_pool\"): Explicitly reference base register.\n+\n 2004-06-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold) <BIT_IOR_EXPR>: Optimize ~X|X and X|~X as -1."}, {"sha": "2b835264eb96cd12dcb9238d63671ff768600726", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=585539a1e97f752a0c49edd62e9f244700f38f58", "patch": "@@ -24,7 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n extern void optimization_options (int, int);\n extern void override_options (void);\n extern HOST_WIDE_INT s390_arg_frame_offset (void);\n-extern void s390_load_got (int);\n extern void s390_emit_prologue (void);\n extern void s390_emit_epilogue (bool);\n extern void s390_function_profiler (FILE *, int);\n@@ -92,6 +91,7 @@ extern void s390_initialize_trampoline (rtx, rtx, rtx);\n extern rtx s390_gen_rtx_const_DI (int, int);\n extern void s390_output_dwarf_dtprel (FILE*, int, rtx);\n extern int s390_agen_dep_p (rtx, rtx);\n+extern rtx s390_load_got (void);\n \n #endif /* RTX_CODE */\n "}, {"sha": "537148e17643d54b8a84fa1a874e636a8ccbce27", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 351, "deletions": 208, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=585539a1e97f752a0c49edd62e9f244700f38f58", "patch": "@@ -217,6 +217,9 @@ struct machine_function GTY(())\n   /* Size of stack frame.  */\n   HOST_WIDE_INT frame_size;\n \n+  /* Literal pool base register.  */\n+  rtx base_reg;\n+\n   /* Some local-dynamic TLS symbol name.  */\n   const char *some_ld_name;\n };\n@@ -236,10 +239,11 @@ static int get_some_local_dynamic_name_1 (rtx *, void *);\n static int reg_used_in_mem_p (int, rtx);\n static int addr_generation_dependency_p (rtx, rtx);\n static int s390_split_branches (void);\n+static void annotate_constant_pool_refs (rtx *x);\n static void find_constant_pool_ref (rtx, rtx *);\n static void replace_constant_pool_ref (rtx *, rtx, rtx);\n static rtx find_ltrel_base (rtx);\n-static void replace_ltrel_base (rtx *, rtx);\n+static void replace_ltrel_base (rtx *);\n static void s390_optimize_prolog (bool);\n static int find_unused_clobbered_reg (void);\n static void s390_frame_info (int, int);\n@@ -2069,9 +2073,11 @@ s390_expand_plus_operand (register rtx target, register rtx src,\n static int\n s390_decompose_address (register rtx addr, struct s390_address *out)\n {\n+  HOST_WIDE_INT offset = 0;\n   rtx base = NULL_RTX;\n   rtx indx = NULL_RTX;\n   rtx disp = NULL_RTX;\n+  rtx orig_disp;\n   int pointer = FALSE;\n   int base_ptr = FALSE;\n   int indx_ptr = FALSE;\n@@ -2119,16 +2125,69 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n   else\n     disp = addr;\t\t/* displacement */\n \n+  /* Extract integer part of displacement.  */\n+  orig_disp = disp;\n+  if (disp)\n+    {\n+      if (GET_CODE (disp) == CONST_INT)\n+\t{\n+\t  offset = INTVAL (disp);\n+\t  disp = NULL_RTX;\n+\t}\n+      else if (GET_CODE (disp) == CONST\n+\t       && GET_CODE (XEXP (disp, 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT)\n+\t{\n+\t  offset = INTVAL (XEXP (XEXP (disp, 0), 1));\n+\t  disp = XEXP (XEXP (disp, 0), 0);\n+\t}\n+    }\n+\n+  /* Strip off CONST here to avoid special case tests later.  */\n+  if (disp && GET_CODE (disp) == CONST)\n+    disp = XEXP (disp, 0);\n+\n+  /* We can convert literal pool addresses to\n+     displacements by basing them off the base register.  */\n+  if (disp && GET_CODE (disp) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (disp))\n+    {\n+      /* Either base or index must be free to hold the base register.  */\n+      if (!base)\n+        base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+      else if (!indx)\n+        indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n+      else\n+        return FALSE;\n+\n+      /* Mark up the displacement.  */\n+      disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp),\n+\t\t\t     UNSPEC_LTREL_OFFSET);\n+    }\n \n   /* Validate base register.  */\n   if (base)\n     {\n       if (GET_CODE (base) == UNSPEC)\n-        {\n-          if (XVECLEN (base, 0) != 1 || XINT (base, 1) != UNSPEC_LTREL_BASE)\n+\tswitch (XINT (base, 1))\n+\t  {\n+\t  case UNSPEC_LTREF:\n+\t    if (!disp)\n+\t      disp = gen_rtx_UNSPEC (Pmode, \n+\t\t\t\t     gen_rtvec (1, XVECEXP (base, 0, 0)),\n+\t\t\t\t     UNSPEC_LTREL_OFFSET);\n+\t    else\n+\t      return FALSE;\n+\n+\t    base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t    break;\n+\n+\t  case UNSPEC_LTREL_BASE:\n+\t    base = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t    break;\n+\n+\t  default:\n \t    return FALSE;\n-\t  base = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t}\n+\t  }\n \n       if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n \treturn FALSE;\n@@ -2149,11 +2208,26 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n   if (indx)\n     {\n       if (GET_CODE (indx) == UNSPEC)\n-        {\n-          if (XVECLEN (indx, 0) != 1 || XINT (indx, 1) != UNSPEC_LTREL_BASE)\n+\tswitch (XINT (indx, 1))\n+\t  {\n+\t  case UNSPEC_LTREF:\n+\t    if (!disp)\n+\t      disp = gen_rtx_UNSPEC (Pmode, \n+\t\t\t\t     gen_rtvec (1, XVECEXP (indx, 0, 0)),\n+\t\t\t\t     UNSPEC_LTREL_OFFSET);\n+\t    else\n+\t      return FALSE;\n+\n+\t    indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t    break;\n+\n+\t  case UNSPEC_LTREL_BASE:\n+\t    indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t    break;\n+\n+\t  default:\n \t    return FALSE;\n-\t  indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t}\n+\t  }\n \n       if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n \treturn FALSE;\n@@ -2180,106 +2254,63 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n     }\n \n   /* Validate displacement.  */\n-  if (disp)\n+  if (!disp)\n     {\n-      /* Allow integer constant in range.  */\n-      if (GET_CODE (disp) == CONST_INT)\n-        {\n-\t  /* If the argument pointer is involved, the displacement will change\n-\t     later anyway as the argument pointer gets eliminated.  This could\n-\t     make a valid displacement invalid, but it is more likely to make\n-\t     an invalid displacement valid, because we sometimes access the\n-\t     register save area via negative offsets to the arg pointer.\n-\t     Thus we don't check the displacement for validity here.  If after\n-\t     elimination the displacement turns out to be invalid after all,\n-\t     this is fixed up by reload in any case.  */\n-\t  if (base != arg_pointer_rtx && indx != arg_pointer_rtx)\n-\t    {\n-\t      if (!DISP_IN_RANGE (INTVAL (disp)))\n-\t        return FALSE;\n-\t    }\n-        }\n+      /* If the argument pointer is involved, the displacement will change\n+\t later anyway as the argument pointer gets eliminated.  This could\n+\t make a valid displacement invalid, but it is more likely to make\n+\t an invalid displacement valid, because we sometimes access the\n+\t register save area via negative offsets to the arg pointer.\n+\t Thus we don't check the displacement for validity here.  If after\n+\t elimination the displacement turns out to be invalid after all,\n+\t this is fixed up by reload in any case.  */\n+      if (base != arg_pointer_rtx && indx != arg_pointer_rtx)\n+\tif (!DISP_IN_RANGE (offset))\n+\t  return FALSE;\n+    }\n+  else\n+    {\n+      /* All the special cases are pointers.  */\n+      pointer = TRUE;\n \n       /* In the small-PIC case, the linker converts @GOT\n          and @GOTNTPOFF offsets to possible displacements.  */\n-      else if (GET_CODE (disp) == CONST\n-               && GET_CODE (XEXP (disp, 0)) == UNSPEC\n-               && (XINT (XEXP (disp, 0), 1) == UNSPEC_GOT\n-\t\t   || XINT (XEXP (disp, 0), 1) == UNSPEC_GOTNTPOFF))\n+      if (GET_CODE (disp) == UNSPEC\n+          && (XINT (disp, 1) == UNSPEC_GOT\n+\t      || XINT (disp, 1) == UNSPEC_GOTNTPOFF)\n+\t  && offset == 0\n+\t  && flag_pic == 1)\n         {\n-          if (flag_pic != 1)\n-            return FALSE;\n-\n-\t  pointer = TRUE;\n+\t  ;\n         }\n \n-      /* Accept chunkfied literal pool symbol references.  */\n-      else if (GET_CODE (disp) == CONST\n-               && GET_CODE (XEXP (disp, 0)) == MINUS\n-               && GET_CODE (XEXP (XEXP (disp, 0), 0)) == LABEL_REF\n-               && GET_CODE (XEXP (XEXP (disp, 0), 1)) == LABEL_REF)\n+      /* Accept chunkified literal pool symbol references.  */\n+      else if (GET_CODE (disp) == MINUS\n+               && GET_CODE (XEXP (disp, 0)) == LABEL_REF\n+               && GET_CODE (XEXP (disp, 1)) == LABEL_REF)\n         {\n-\t  pointer = TRUE;\n+\t  ;\n         }\n \n-      /* Likewise if a constant offset is present.  */\n-      else if (GET_CODE (disp) == CONST\n-               && GET_CODE (XEXP (disp, 0)) == PLUS\n-               && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT\n-               && GET_CODE (XEXP (XEXP (disp, 0), 0)) == MINUS\n-               && GET_CODE (XEXP (XEXP (XEXP (disp, 0), 0), 0)) == LABEL_REF\n-               && GET_CODE (XEXP (XEXP (XEXP (disp, 0), 0), 1)) == LABEL_REF)\n+      /* Accept literal pool references.  */\n+      else if (GET_CODE (disp) == UNSPEC\n+\t       && XINT (disp, 1) == UNSPEC_LTREL_OFFSET)\n         {\n-\t  pointer = TRUE;\n+\t  orig_disp = gen_rtx_CONST (Pmode, disp);\n+\t  if (offset)\n+\t    {\n+\t      /* If we have an offset, make sure it does not\n+\t\t exceed the size of the constant pool entry.  */\n+\t      rtx sym = XVECEXP (disp, 0, 0);\n+\t      if (offset >= GET_MODE_SIZE (get_pool_mode (sym)))\n+\t\treturn FALSE;\n+\n+              orig_disp = plus_constant (orig_disp, offset);\n+\t    }\n         }\n \n-      /* We can convert literal pool addresses to\n-         displacements by basing them off the base register.  */\n       else\n-        {\n-          /* In some cases, we can accept an additional\n-             small constant offset.  Split these off here.  */\n-\n-          unsigned int offset = 0;\n-\n-          if (GET_CODE (disp) == CONST\n-              && GET_CODE (XEXP (disp, 0)) == PLUS\n-              && GET_CODE (XEXP (XEXP (disp, 0), 1)) == CONST_INT)\n-            {\n-              offset = INTVAL (XEXP (XEXP (disp, 0), 1));\n-              disp = XEXP (XEXP (disp, 0), 0);\n-            }\n-\n-          /* Now we must have a literal pool address.  */\n-          if (GET_CODE (disp) != SYMBOL_REF\n-              || !CONSTANT_POOL_ADDRESS_P (disp))\n-            return FALSE;\n-\n-          /* If we have an offset, make sure it does not\n-             exceed the size of the constant pool entry.  */\n-          if (offset && offset >= GET_MODE_SIZE (get_pool_mode (disp)))\n-            return FALSE;\n-\n-          /* Either base or index must be free to\n-             hold the base register.  */\n-          if (base && indx)\n-            return FALSE;\n-\n-          /* Convert the address.  */\n-          if (base)\n-            indx = gen_rtx_REG (Pmode, BASE_REGISTER);\n-          else\n-            base = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\n-          disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp),\n-\t\t\t\t UNSPEC_LTREL_OFFSET);\n-          disp = gen_rtx_CONST (Pmode, disp);\n-\n-          if (offset)\n-            disp = plus_constant (disp, offset);\n-\n-\t  pointer = TRUE;\n-        }\n+\treturn FALSE;\n     }\n \n   if (!base && !indx)\n@@ -2289,7 +2320,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n     {\n       out->base = base;\n       out->indx = indx;\n-      out->disp = disp;\n+      out->disp = orig_disp;\n       out->pointer = pointer;\n     }\n \n@@ -4058,6 +4089,7 @@ s390_split_branches (void)\n \t  tmp = force_const_mem (Pmode, *label);\n \t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, tmp), insn);\n \t  INSN_ADDRESSES_NEW (tmp, -1);\n+\t  annotate_constant_pool_refs (&PATTERN (tmp));\n \n \t  target = temp_reg;\n \t}\n@@ -4070,8 +4102,10 @@ s390_split_branches (void)\n \t  target = force_const_mem (Pmode, target);\n \t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, target), insn);\n \t  INSN_ADDRESSES_NEW (tmp, -1);\n+\t  annotate_constant_pool_refs (&PATTERN (tmp));\n \n-          target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (target, 0)),\n+          target = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, XEXP (target, 0),\n+\t\t\t\t\t\t\tcfun->machine->base_reg),\n \t\t\t\t   UNSPEC_LTREL_BASE);\n \t  target = gen_rtx_PLUS (Pmode, temp_reg, target);\n \t}\n@@ -4083,11 +4117,115 @@ s390_split_branches (void)\n   return new_literal;\n }\n \n+/* Annotate every literal pool reference in X by an UNSPEC_LTREF expression.\n+   Fix up MEMs as required.  */\n+\n+static void\n+annotate_constant_pool_refs (rtx *x)\n+{\n+  int i, j;\n+  const char *fmt;\n+\n+  if (GET_CODE (*x) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (*x))\n+    abort ();\n+\n+  /* Literal pool references can only occur inside a MEM ...  */\n+  if (GET_CODE (*x) == MEM)\n+    {\n+      rtx memref = XEXP (*x, 0);\n+\n+      if (GET_CODE (memref) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (memref))\n+\t{\n+\t  rtx base = cfun->machine->base_reg;\n+\t  rtx addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, memref, base),\n+\t\t\t\t     UNSPEC_LTREF);\n+\n+\t  *x = replace_equiv_address (*x, addr);\n+\t  return;\n+\t}\n+\n+      if (GET_CODE (memref) == CONST\n+\t  && GET_CODE (XEXP (memref, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (memref, 0), 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (XEXP (memref, 0), 0)) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (memref, 0), 0)))\n+\t{\n+\t  HOST_WIDE_INT off = INTVAL (XEXP (XEXP (memref, 0), 1));\n+\t  rtx sym = XEXP (XEXP (memref, 0), 0);\n+\t  rtx base = cfun->machine->base_reg;\n+\t  rtx addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, sym, base),\n+\t\t\t\t     UNSPEC_LTREF);\n+\n+\t  *x = replace_equiv_address (*x, plus_constant (addr, off));\n+\t  return;\n+\t}\n+    }\n+\n+  /* ... or a load-address type pattern.  */\n+  if (GET_CODE (*x) == SET)\n+    {\n+      rtx addrref = SET_SRC (*x);\n+\n+      if (GET_CODE (addrref) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (addrref))\n+\t{\n+\t  rtx base = cfun->machine->base_reg;\n+\t  rtx addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, addrref, base),\n+\t\t\t\t     UNSPEC_LTREF);\n+\n+\t  SET_SRC (*x) = addr;\n+\t  return;\n+\t}\n+\n+      if (GET_CODE (addrref) == CONST\n+\t  && GET_CODE (XEXP (addrref, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (addrref, 0), 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (XEXP (addrref, 0), 0)) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (addrref, 0), 0)))\n+\t{\n+\t  HOST_WIDE_INT off = INTVAL (XEXP (XEXP (addrref, 0), 1));\n+\t  rtx sym = XEXP (XEXP (addrref, 0), 0);\n+\t  rtx base = cfun->machine->base_reg;\n+\t  rtx addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, sym, base),\n+\t\t\t\t     UNSPEC_LTREF);\n+\n+\t  SET_SRC (*x) = plus_constant (addr, off);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Annotate LTREL_BASE as well.  */\n+  if (GET_CODE (*x) == UNSPEC\n+      && XINT (*x, 1) == UNSPEC_LTREL_BASE)\n+    {\n+      rtx base = cfun->machine->base_reg;\n+      *x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, XVECEXP (*x, 0, 0), base),\n+\t\t\t\t  UNSPEC_LTREL_BASE);\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (*x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+        {\n+          annotate_constant_pool_refs (&XEXP (*x, i));\n+        }\n+      else if (fmt[i] == 'E')\n+        {\n+          for (j = 0; j < XVECLEN (*x, i); j++)\n+            annotate_constant_pool_refs (&XVECEXP (*x, i, j));\n+        }\n+    }\n+}\n+\n \n-/* Find a literal pool symbol referenced in RTX X, and store\n-   it at REF.  Will abort if X contains references to more than\n-   one such pool symbol; multiple references to the same symbol\n-   are allowed, however.\n+/* Find an annotated literal pool symbol referenced in RTX X, \n+   and store it at REF.  Will abort if X contains references to \n+   more than one such pool symbol; multiple references to the same\n+   symbol are allowed, however.\n \n    The rtx pointed to by REF must be initialized to NULL_RTX\n    by the caller before calling this routine.  */\n@@ -4109,11 +4247,21 @@ find_constant_pool_ref (rtx x, rtx *ref)\n \n   if (GET_CODE (x) == SYMBOL_REF\n       && CONSTANT_POOL_ADDRESS_P (x))\n+    abort ();\n+\n+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_LTREF)\n     {\n+      rtx sym = XVECEXP (x, 0, 0);\n+      if (GET_CODE (sym) != SYMBOL_REF\n+\t  || !CONSTANT_POOL_ADDRESS_P (sym))\n+\tabort ();\n+\n       if (*ref == NULL_RTX)\n-        *ref = x;\n-      else if (*ref != x)\n-        abort();\n+\t*ref = sym;\n+      else if (*ref != sym)\n+\tabort ();\n+\n+      return;\n     }\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n@@ -4131,73 +4279,48 @@ find_constant_pool_ref (rtx x, rtx *ref)\n     }\n }\n \n-/* Replace every reference to the literal pool symbol REF\n-   in X by the address ADDR.  Fix up MEMs as required.  */\n+/* Replace every reference to the annotated literal pool \n+   symbol REF in X by its base plus OFFSET.  */\n \n static void\n-replace_constant_pool_ref (rtx *x, rtx ref, rtx addr)\n+replace_constant_pool_ref (rtx *x, rtx ref, rtx offset)\n {\n   int i, j;\n   const char *fmt;\n \n   if (*x == ref)\n     abort ();\n \n-  /* Literal pool references can only occur inside a MEM ...  */\n-  if (GET_CODE (*x) == MEM)\n+  if (GET_CODE (*x) == UNSPEC\n+      && XINT (*x, 1) == UNSPEC_LTREF\n+      && XVECEXP (*x, 0, 0) == ref)\n     {\n-      rtx memref = XEXP (*x, 0);\n-\n-      if (memref == ref)\n-\t{\n-\t  *x = replace_equiv_address (*x, addr);\n-\t  return;\n-\t}\n-\n-      if (GET_CODE (memref) == CONST\n-\t  && GET_CODE (XEXP (memref, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (memref, 0), 1)) == CONST_INT\n-\t  && XEXP (XEXP (memref, 0), 0) == ref)\n-\t{\n-\t  HOST_WIDE_INT off = INTVAL (XEXP (XEXP (memref, 0), 1));\n-\t  *x = replace_equiv_address (*x, plus_constant (addr, off));\n-\t  return;\n-\t}\n+      *x = gen_rtx_PLUS (Pmode, XVECEXP (*x, 0, 1), offset);\n+      return;\n     }\n \n-  /* ... or a load-address type pattern.  */\n-  if (GET_CODE (*x) == SET)\n+  if (GET_CODE (*x) == PLUS\n+      && GET_CODE (XEXP (*x, 1)) == CONST_INT\n+      && GET_CODE (XEXP (*x, 0)) == UNSPEC\n+      && XINT (XEXP (*x, 0), 1) == UNSPEC_LTREF\n+      && XVECEXP (XEXP (*x, 0), 0, 0) == ref)\n     {\n-      rtx addrref = SET_SRC (*x);\n-\n-      if (addrref == ref)\n-\t{\n-\t  SET_SRC (*x) = addr;\n-\t  return;\n-\t}\n-\n-      if (GET_CODE (addrref) == CONST\n-\t  && GET_CODE (XEXP (addrref, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (addrref, 0), 1)) == CONST_INT\n-\t  && XEXP (XEXP (addrref, 0), 0) == ref)\n-\t{\n-\t  HOST_WIDE_INT off = INTVAL (XEXP (XEXP (addrref, 0), 1));\n-\t  SET_SRC (*x) = plus_constant (addr, off);\n-\t  return;\n-\t}\n+      rtx addr = gen_rtx_PLUS (Pmode, XVECEXP (XEXP (*x, 0), 0, 1), offset);\n+      *x = plus_constant (addr, INTVAL (XEXP (*x, 1)));\n+      return;\n     }\n \n   fmt = GET_RTX_FORMAT (GET_CODE (*x));\n   for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n         {\n-          replace_constant_pool_ref (&XEXP (*x, i), ref, addr);\n+          replace_constant_pool_ref (&XEXP (*x, i), ref, offset);\n         }\n       else if (fmt[i] == 'E')\n         {\n           for (j = 0; j < XVECLEN (*x, i); j++)\n-            replace_constant_pool_ref (&XVECEXP (*x, i, j), ref, addr);\n+            replace_constant_pool_ref (&XVECEXP (*x, i, j), ref, offset);\n         }\n     }\n }\n@@ -4238,18 +4361,18 @@ find_ltrel_base (rtx x)\n   return NULL_RTX;\n }\n \n-/* Replace any occurrence of UNSPEC_LTREL_BASE in X with BASE.  */\n+/* Replace any occurrence of UNSPEC_LTREL_BASE in X with its base.  */\n \n static void\n-replace_ltrel_base (rtx *x, rtx base)\n+replace_ltrel_base (rtx *x)\n {\n   int i, j;\n   const char *fmt;\n \n   if (GET_CODE (*x) == UNSPEC\n       && XINT (*x, 1) == UNSPEC_LTREL_BASE)\n     {\n-      *x = base;\n+      *x = XVECEXP (*x, 0, 1);\n       return;\n     }\n \n@@ -4258,12 +4381,12 @@ replace_ltrel_base (rtx *x, rtx base)\n     {\n       if (fmt[i] == 'e')\n         {\n-          replace_ltrel_base (&XEXP (*x, i), base);\n+          replace_ltrel_base (&XEXP (*x, i));\n         }\n       else if (fmt[i] == 'E')\n         {\n           for (j = 0; j < XVECLEN (*x, i); j++)\n-            replace_ltrel_base (&XVECEXP (*x, i, j), base);\n+            replace_ltrel_base (&XVECEXP (*x, i, j));\n         }\n     }\n }\n@@ -4302,11 +4425,11 @@ struct constant_pool\n };\n \n static struct constant_pool * s390_mainpool_start (void);\n-static void s390_mainpool_finish (struct constant_pool *, rtx base_reg);\n+static void s390_mainpool_finish (struct constant_pool *);\n static void s390_mainpool_cancel (struct constant_pool *);\n \n-static struct constant_pool * s390_chunkify_start (rtx base_reg);\n-static void s390_chunkify_finish (struct constant_pool *, rtx base_reg);\n+static struct constant_pool * s390_chunkify_start (void);\n+static void s390_chunkify_finish (struct constant_pool *);\n static void s390_chunkify_cancel (struct constant_pool *);\n \n static struct constant_pool *s390_start_pool (struct constant_pool **, rtx);\n@@ -4560,8 +4683,9 @@ s390_mainpool_start (void)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n-\t  && XINT (PATTERN (insn), 1) == UNSPECV_MAIN_POOL)\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC_VOLATILE\n+\t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPECV_MAIN_POOL)\n \t{\n \t  if (pool->pool_insn)\n \t    abort ();\n@@ -4599,12 +4723,12 @@ s390_mainpool_start (void)\n \n /* POOL holds the main literal pool as collected by s390_mainpool_start.\n    Modify the current function to output the pool constants as well as\n-   the pool register setup instruction.  BASE_REG is the register to\n-   be used as pool base register.  */\n+   the pool register setup instruction.  */\n \n static void\n-s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n+s390_mainpool_finish (struct constant_pool *pool)\n {\n+  rtx base_reg = SET_DEST (PATTERN (pool->pool_insn));\n   rtx insn;\n \n   /* If the pool is empty, we're done.  */\n@@ -4684,7 +4808,7 @@ s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n-\treplace_ltrel_base (&PATTERN (insn), base_reg);\n+\treplace_ltrel_base (&PATTERN (insn));\n \n       if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n         {\n@@ -4694,7 +4818,6 @@ s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n             {\n               addr = s390_find_constant (pool, get_pool_constant (pool_ref),\n                                                get_pool_mode (pool_ref));\n-              addr = gen_rtx_PLUS (Pmode, base_reg, addr);\n               replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n               INSN_CODE (insn) = -1;\n             }\n@@ -4718,14 +4841,13 @@ s390_mainpool_cancel (struct constant_pool *pool)\n }\n \n \n-/* Chunkify the literal pool.  BASE_REG is to be used as pool\n-   register.  */\n+/* Chunkify the literal pool.  */\n \n #define S390_POOL_CHUNK_MIN\t0xc00\n #define S390_POOL_CHUNK_MAX\t0xe00\n \n static struct constant_pool *\n-s390_chunkify_start (rtx base_reg)\n+s390_chunkify_start (void)\n {\n   struct constant_pool *curr_pool = NULL, *pool_list = NULL;\n   int extra_size = 0;\n@@ -4952,7 +5074,8 @@ s390_chunkify_start (rtx base_reg)\n \n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n     {\n-      rtx new_insn = gen_reload_base (base_reg, curr_pool->label);\n+      rtx new_insn = gen_reload_base (cfun->machine->base_reg, \n+\t\t\t\t      curr_pool->label);\n       rtx insn = curr_pool->first_insn;\n       INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n     }\n@@ -4966,7 +5089,8 @@ s390_chunkify_start (rtx base_reg)\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n \tif (pool)\n \t  {\n-\t    rtx new_insn = gen_reload_base (base_reg, pool->label);\n+\t    rtx new_insn = gen_reload_base (cfun->machine->base_reg, \n+\t\t\t\t\t    pool->label);\n \t    INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n \t  }\n       }\n@@ -4985,11 +5109,10 @@ s390_chunkify_start (rtx base_reg)\n \n /* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n    After we have decided to use this list, finish implementing\n-   all changes to the current function as required.  BASE_REG is\n-   to be used as pool base register.  */\n+   all changes to the current function as required.  */\n \n static void\n-s390_chunkify_finish (struct constant_pool *pool_list, rtx base_reg)\n+s390_chunkify_finish (struct constant_pool *pool_list)\n {\n   struct constant_pool *curr_pool = NULL;\n   rtx insn;\n@@ -5000,7 +5123,7 @@ s390_chunkify_finish (struct constant_pool *pool_list, rtx base_reg)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n-\treplace_ltrel_base (&PATTERN (insn), base_reg);\n+\treplace_ltrel_base (&PATTERN (insn));\n \n       curr_pool = s390_find_pool (pool_list, insn);\n       if (!curr_pool)\n@@ -5014,7 +5137,6 @@ s390_chunkify_finish (struct constant_pool *pool_list, rtx base_reg)\n             {\n               addr = s390_find_constant (curr_pool, get_pool_constant (pool_ref),\n                                                     get_pool_mode (pool_ref));\n-              addr = gen_rtx_PLUS (Pmode, base_reg, addr);\n               replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n               INSN_CODE (insn) = -1;\n             }\n@@ -5273,7 +5395,6 @@ s390_optimize_prolog (bool base_used)\n static void\n s390_reorg (void)\n {\n-  rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n   bool base_used = false;\n   bool pool_overflow = false;\n \n@@ -5282,12 +5403,6 @@ s390_reorg (void)\n   split_all_insns_noflow ();\n \n \n-  /* In small leaf functions, try to use an unused call-clobbered\n-     register as base register to avoid save/restore overhead.  */\n-  if (current_function_is_leaf && !regs_ever_live[5])\n-    base_reg = gen_rtx_REG (Pmode, 5);\n-\n-\n   /* Install the main literal pool and the associated base\n      register load insns.\n \n@@ -5335,7 +5450,7 @@ s390_reorg (void)\n \n       /* If literal pool overflowed, start to chunkify it.  */\n       if (pool_overflow)\n-        pool = s390_chunkify_start (base_reg);\n+        pool = s390_chunkify_start ();\n \n       /* Split out-of-range branches.  If this has created new\n \t literal pool entries, cancel current chunk list and\n@@ -5354,13 +5469,13 @@ s390_reorg (void)\n       /* If we made it up to here, both conditions are satisfied.\n \t Finish up literal pool related changes.  */\n       if ((pool_overflow || pool->size > 0)\n-\t   && REGNO (base_reg) == BASE_REGISTER)\n+\t   && REGNO (cfun->machine->base_reg) == BASE_REGISTER)\n \tbase_used = true;\n \n       if (pool_overflow)\n-\ts390_chunkify_finish (pool, base_reg);\n+\ts390_chunkify_finish (pool);\n       else\n-\ts390_mainpool_finish (pool, base_reg);\n+\ts390_mainpool_finish (pool);\n \n       break;\n     }\n@@ -5649,49 +5764,47 @@ restore_gprs (rtx base, int offset, int first, int last)\n   return insn;\n }\n \n-/* Emit code to load the GOT register.  If MAYBE_DEAD is true,\n-   annotate generated insns with REG_MAYBE_DEAD notes.  */\n+/* Return insn sequence to load the GOT register.  */\n \n static GTY(()) rtx got_symbol;\n-void\n-s390_load_got (int maybe_dead)\n+rtx\n+s390_load_got (void)\n {\n+  rtx insns;\n+\n   if (!got_symbol)\n     {\n       got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n       SYMBOL_REF_FLAGS (got_symbol) = SYMBOL_FLAG_LOCAL;\n     }\n \n+  start_sequence ();\n+\n   if (TARGET_CPU_ZARCH)\n     {\n-      rtx insn = emit_move_insn (pic_offset_table_rtx, got_symbol);\n-      if (maybe_dead)\n-        REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-                                             REG_NOTES (insn));\n+      emit_move_insn (pic_offset_table_rtx, got_symbol);\n     }\n   else\n     {\n-      rtx offset, insn;\n+      rtx offset;\n \n       offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got_symbol),\n \t\t\t       UNSPEC_LTREL_OFFSET);\n       offset = gen_rtx_CONST (Pmode, offset);\n       offset = force_const_mem (Pmode, offset);\n \n-      insn = emit_move_insn (pic_offset_table_rtx, offset);\n-      if (maybe_dead)\n-\tREG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-\t\t\t\t\t     REG_NOTES (insn));\n+      emit_move_insn (pic_offset_table_rtx, offset);\n \n       offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (offset, 0)),\n \t\t\t       UNSPEC_LTREL_BASE);\n       offset = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, offset);\n \n-      insn = emit_move_insn (pic_offset_table_rtx, offset);\n-      if (maybe_dead)\n-\tREG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n-\t\t\t\t\t     REG_NOTES (insn));\n+      emit_move_insn (pic_offset_table_rtx, offset);\n     }\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+  return insns;\n }\n \n /* Expand the prologue into a bunch of separate insns.  */\n@@ -5712,6 +5825,17 @@ s390_emit_prologue (void)\n       || regs_ever_live[RETURN_REGNUM])\n     cfun->machine->save_return_addr_p = 1;\n \n+  /* Decide which register to use as literal pool base.  In small leaf \n+     functions, try to use an unused call-clobbered register as base \n+     register to avoid save/restore overhead.  */\n+\n+  if (current_function_is_leaf && !regs_ever_live[5])\n+    cfun->machine->base_reg = gen_rtx_REG (Pmode, 5);\n+  else\n+    cfun->machine->base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\n+  regs_ever_live[REGNO (cfun->machine->base_reg)] = 1;\n+\n   /* Compute frame info.  Note that at this point, we assume the base \n      register and -on S/390- the return register always need to be saved.\n      This is done because the usage of these registers might change even \n@@ -5727,6 +5851,17 @@ s390_emit_prologue (void)\n \t\t\t\t  || cfun->machine->save_return_addr_p;\n   regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n+  /* Annotate all constant pool references to let the scheduler know\n+     they implicitly use the base register.  */\n+\n+  push_topmost_sequence ();\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      annotate_constant_pool_refs (&PATTERN (insn));\n+\n+  pop_topmost_sequence ();\n+\n   /* Choose best register to use for temp use within prologue.\n      See below for why TPF must use the register 1.  */\n \n@@ -5744,7 +5879,7 @@ s390_emit_prologue (void)\n \n   /* Dummy insn to mark literal pool slot.  */\n \n-  emit_insn (gen_main_pool ());\n+  emit_insn (gen_main_pool (cfun->machine->base_reg));\n \n   /* Save fprs for variable args.  */\n \n@@ -5790,6 +5925,7 @@ s390_emit_prologue (void)\n \t    frame_off = force_const_mem (Pmode, frame_off);\n \n           insn = emit_insn (gen_add2_insn (stack_pointer_rtx, frame_off));\n+\t  annotate_constant_pool_refs (&PATTERN (insn));\n \t}\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -5854,7 +5990,19 @@ s390_emit_prologue (void)\n   /* Set up got pointer, if needed.  */\n \n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    s390_load_got(true);\n+    {\n+      rtx insns = s390_load_got ();\n+\n+      for (insn = insns; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  annotate_constant_pool_refs (&PATTERN (insn));\n+\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+\t\t\t\t\t\tREG_NOTES (insn));\n+\t}\n+\n+      emit_insn (insns);\n+    }\n \n   if (TARGET_TPF_PROFILING)\n     {\n@@ -5965,6 +6113,7 @@ s390_emit_epilogue (bool sibcall)\n \t    frame_off = force_const_mem (Pmode, frame_off);\n \n \t  insn = emit_insn (gen_add2_insn (frame_pointer, frame_off));\n+\t  annotate_constant_pool_refs (&PATTERN (insn));\n \t}\n     }\n \n@@ -6044,12 +6193,6 @@ s390_emit_epilogue (bool sibcall)\n \t    }\n \t}\n \n-      /* ??? As references to the base register are not made\n-\t explicit in insn RTX code, we have to add a barrier here\n-\t to prevent incorrect scheduling.  */\n-\n-      emit_insn (gen_blockage());\n-\n       insn = restore_gprs (frame_pointer, offset,\n \t\t\t   cfun->machine->first_restore_gpr,\n \t\t\t   cfun->machine->last_restore_gpr);"}, {"sha": "e2a026215227ada2831c976275ac4d73168298ad", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/585539a1e97f752a0c49edd62e9f244700f38f58/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=585539a1e97f752a0c49edd62e9f244700f38f58", "patch": "@@ -92,6 +92,7 @@\n    ; Literal pool\n    (UNSPEC_RELOAD_BASE\t\t210)\n    (UNSPEC_MAIN_BASE\t\t211)\n+   (UNSPEC_LTREF\t\t212)\n \n    ; TLS relocation specifiers\n    (UNSPEC_TLSGD\t\t500)\n@@ -7394,7 +7395,7 @@\n   [(match_operand 0 \"\" \"\")]\n   \"flag_pic\"\n {\n-  s390_load_got (false);\n+  emit_insn (s390_load_got ());\n   emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n   DONE;\n })\n@@ -7561,8 +7562,9 @@\n    (set_attr \"type\"    \"larl\")])\n \n (define_insn \"main_pool\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL)]\n-  \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (unspec_volatile [(const_int 0)] UNSPECV_MAIN_POOL))]\n+  \"GET_MODE (operands[0]) == Pmode\"\n   \"* abort ();\"\n   [(set_attr \"op_type\" \"NN\")])\n "}]}