{"sha": "f8190ffc6cf4cb616b423b930395ffd284688e28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgxOTBmZmM2Y2Y0Y2I2MTZiNDIzYjkzMDM5NWZmZDI4NDY4OGUyOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-02-22T17:05:58Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-02-22T17:05:58Z"}, "message": "re PR libstdc++/26132 (tr1/hashtable: rehash not implemented)\n\n2006-02-22  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/26132\n\t* include/tr1/hashtable (hashtable<>::rehash): Define.\n\t* testsuite/tr1/6_containers/unordered/hashtable/26132.cc: New.\n\n\t* include/tr1/hashtable: Trivial formatting and stylistic fixes.\n\n\t* testsuite/tr1/headers.cc: remove <tr1/hashtable>, not a tr1 header,\n\tonly an implementation detail.\n\nFrom-SVN: r111366", "tree": {"sha": "c46f27ecfceaa5e18aab8d08330b20372088b0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c46f27ecfceaa5e18aab8d08330b20372088b0fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8190ffc6cf4cb616b423b930395ffd284688e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8190ffc6cf4cb616b423b930395ffd284688e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8190ffc6cf4cb616b423b930395ffd284688e28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8190ffc6cf4cb616b423b930395ffd284688e28/comments", "author": null, "committer": null, "parents": [{"sha": "e3a26d2fc577210675f407a3ac8083cc22fe3150", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a26d2fc577210675f407a3ac8083cc22fe3150", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a26d2fc577210675f407a3ac8083cc22fe3150"}], "stats": {"total": 138, "additions": 110, "deletions": 28}, "files": [{"sha": "b5658d510b419264b193bf34533970f069a5e7e5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f8190ffc6cf4cb616b423b930395ffd284688e28", "patch": "@@ -1,3 +1,14 @@\n+2006-02-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/26132\n+\t* include/tr1/hashtable (hashtable<>::rehash): Define.\n+\t* testsuite/tr1/6_containers/unordered/hashtable/26132.cc: New.\n+\n+\t* include/tr1/hashtable: Trivial formatting and stylistic fixes.\n+\n+\t* testsuite/tr1/headers.cc: remove <tr1/hashtable>, not a tr1 header,\n+\tonly an implementation detail.\n+\n 2006-02-22  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/debug/list (splice): Remove splice_alloc check, redundant"}, {"sha": "7092e3cf39d66753fc3f41a5d94e27ef588a16d8", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=f8190ffc6cf4cb616b423b930395ffd284688e28", "patch": "@@ -1132,6 +1132,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       { \n \treturn static_cast<float>(size()) / static_cast<float>(bucket_count());\n       }\n+\n       // max_load_factor, if present, comes from rehash_base.\n \n       // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n@@ -1226,7 +1227,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       clear();\n \n     public:\n-      // Set number of buckets to be apropriate for container of n element.\n+      // Set number of buckets to be appropriate for container of n element.\n       void rehash(size_type n);\n       \n     private:\n@@ -1306,7 +1307,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       // We allocate one extra bucket to hold a sentinel, an arbitrary\n       // non-null pointer.  Iterator increment relies on this.\n       node** p = alloc.allocate(n + 1);\n-      std::fill(p, p+n, (node*) 0);\n+      std::fill(p, p + n, (node*) 0);\n       p[n] = reinterpret_cast<node*>(0x1000);\n       return p;\n     }\n@@ -1320,7 +1321,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     m_deallocate_buckets(node** p, size_type n)\n     {\n       bucket_allocator_t alloc(m_node_allocator);\n-      alloc.deallocate(p, n+1);\n+      alloc.deallocate(p, n + 1);\n     }\n \n   template<typename K, typename V, \n@@ -1356,11 +1357,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\tconst Eq& eq, const Ex& exk,\n \t\tconst allocator_type& a)\n       : Internal::rehash_base<RP, hashtable>(),\n-\tInternal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c> (exk, eq,\n-\t\t\t\t\t\t\t      h1, h2, h),\n+\tInternal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq,\n+\t\t\t\t\t\t\t     h1, h2, h),\n \tInternal::map_base<K, V, Ex, u, hashtable>(),\n \tm_node_allocator(a),\n-\tm_bucket_count (0),\n+\tm_bucket_count(0),\n \tm_element_count(0),\n \tm_rehash_policy()\n       {\n@@ -1396,10 +1397,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       m_element_count(ht.m_element_count),\n       m_rehash_policy(ht.m_rehash_policy)\n     {\n-      m_buckets = m_allocate_buckets (m_bucket_count);\n+      m_buckets = m_allocate_buckets(m_bucket_count);\n       try\n \t{\n-\t  for (size_t i = 0; i < ht.m_bucket_count; ++i)\n+\t  for (size_type i = 0; i < ht.m_bucket_count; ++i)\n \t    {\n \t      node* n = ht.m_buckets[i];\n \t      node** tail = m_buckets + i;\n@@ -1415,7 +1416,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       catch(...)\n \t{\n \t  clear();\n-\t  m_deallocate_buckets (m_buckets, m_bucket_count);\n+\t  m_deallocate_buckets(m_buckets, m_bucket_count);\n \t  __throw_exception_again;\n \t}\n     }\n@@ -1520,7 +1521,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      size_t result = 0;\n+      std::size_t result = 0;\n       for (node* p = m_buckets[n]; p; p = p->m_next)\n \tif (this->compare(k, code, p))\n \t  ++result;\n@@ -1541,7 +1542,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       node** head = m_buckets + n;\n-      node* p = find_node (*head, k, code);\n+      node* p = find_node(*head, k, code);\n       \n       if (p)\n \t{\n@@ -1604,7 +1605,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     find_node(node* p, const key_type& k,\n \t      typename hashtable::hash_code_t code) const\n     {\n-      for (; p ; p = p->m_next)\n+      for (; p; p = p->m_next)\n \tif (this->compare(k, code, p))\n \t  return p;\n       return false;\n@@ -1622,12 +1623,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     {\n       const key_type& k = this->m_extract(v);\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      std::size_t n = this->bucket_index(k, code, m_bucket_count);\n       \n       if (node* p = find_node(m_buckets[n], k, code))\n \treturn std::make_pair(iterator(p, m_buckets + n), false);\n \n-      std::pair<bool, size_t> do_rehash\n+      std::pair<bool, std::size_t> do_rehash\n \t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n \n       // Allocate the new node before doing the rehash so that we don't\n@@ -1671,7 +1672,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       const key_type& k = this->m_extract(v);\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      std::size_t n = this->bucket_index(k, code, m_bucket_count);\n       \n       node* new_node = m_allocate_node(v);\n       node* prev = find_node(m_buckets[n], k, code);\n@@ -1727,7 +1728,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n       insert(InIter first, InIter last)\n       {\n-\tsize_type n_elt = Internal::distance_fw (first, last);\n+\tsize_type n_elt = Internal::distance_fw(first, last);\n \tstd::pair<bool, std::size_t> do_rehash\n \t  = m_rehash_policy.need_rehash(m_bucket_count, m_element_count, n_elt);\n \tif (do_rehash.first)\n@@ -1774,7 +1775,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     erase(const key_type& k)\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      size_type n = this->bucket_index(k, code, m_bucket_count);\n+      std::size_t n = this->bucket_index(k, code, m_bucket_count);\n       size_type result = 0;\n       \n       node** slot = m_buckets + n;\n@@ -1783,9 +1784,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       while (*slot && this->compare(k, code, *slot))\n \t{\n-\t  node* n = *slot;\n-\t  *slot = n->m_next;\n-\t  m_deallocate_node(n);\n+\t  node* p = *slot;\n+\t  *slot = p->m_next;\n+\t  m_deallocate_node(p);\n \t  --m_element_count;\n \t  ++result;\n \t}\n@@ -1833,38 +1834,51 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       m_deallocate_nodes(m_buckets, m_bucket_count);\n       m_element_count = 0;\n     }\n+ \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    rehash(size_type n)\n+    {\n+      m_rehash(std::max(m_rehash_policy.next_bkt(n),\n+\t\t\tm_rehash_policy.bkt_for_elements(m_element_count\n+\t\t\t\t\t\t\t + 1)));\n+    }\n \n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n \t   bool c, bool ci, bool u>\n     void\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_rehash(size_type N)\n+    m_rehash(size_type n)\n     {\n-      node** new_array = m_allocate_buckets(N);\n+      node** new_array = m_allocate_buckets(n);\n       try\n \t{\n \t  for (size_type i = 0; i < m_bucket_count; ++i)\n \t    while (node* p = m_buckets[i])\n \t      {\n-\t\tsize_type new_index = this->bucket_index(p, N);\n+\t\tstd::size_t new_index = this->bucket_index(p, n);\n \t\tm_buckets[i] = p->m_next;\n \t\tp->m_next = new_array[new_index];\n \t\tnew_array[new_index] = p;\n \t      }\n \t  m_deallocate_buckets(m_buckets, m_bucket_count);\n-\t  m_bucket_count = N;\n+\t  m_bucket_count = n;\n \t  m_buckets = new_array;\n \t}\n-      catch (...)\n+      catch(...)\n \t{\n \t  // A failure here means that a hash function threw an exception.\n \t  // We can't restore the previous state without calling the hash\n \t  // function again, so the only sensible recovery is to delete\n \t  // everything.\n-\t  m_deallocate_nodes(new_array, N);\n-\t  m_deallocate_buckets(new_array, N);\n+\t  m_deallocate_nodes(new_array, n);\n+\t  m_deallocate_buckets(new_array, n);\n \t  m_deallocate_nodes(m_buckets, m_bucket_count);\n \t  m_element_count = 0;\n \t  __throw_exception_again;"}, {"sha": "9d0076e96988227c69d4a25b28ed0a0e8c7a19ce", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/hashtable/26132.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fhashtable%2F26132.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fhashtable%2F26132.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fhashtable%2F26132.cc?ref=f8190ffc6cf4cb616b423b930395ffd284688e28", "patch": "@@ -0,0 +1,58 @@\n+// 2006-02-22  Paolo Carlini  <pcarlini@suse.de>\n+//\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3 Unordered associative containers\n+\n+#include <tr1/unordered_set>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/26132\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  for (float lf = 1.0; lf < 101.0; lf *= 10.0)\n+    for (int size = 1; size <= 6561; size *= 3)\n+      {\n+\tstd::tr1::unordered_set<int> us1;\n+\ttypedef std::tr1::unordered_set<int>::size_type size_type;\n+\t\n+\tus1.max_load_factor(10.0);\n+\n+\tfor (int i = 0; i < size; ++i)\n+\t  us1.insert(i);\n+\n+\tus1.max_load_factor(lf);\n+\n+\tfor (int i = 1; i <= 6561; i *= 81)\n+\t  {\n+\t    const size_type n = size * 81 / i;\n+\t    us1.rehash(n);\n+\t    VERIFY( us1.bucket_count() > us1.size() / us1.max_load_factor() );\n+\t    VERIFY( us1.bucket_count() >= n );\n+\t  }\n+      }\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4be96e020b771ef38a8e84cb575e80d342916f06", "filename": "libstdc++-v3/testsuite/tr1/headers.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8190ffc6cf4cb616b423b930395ffd284688e28/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2Fheaders.cc?ref=f8190ffc6cf4cb616b423b930395ffd284688e28", "patch": "@@ -39,7 +39,6 @@\n #include <tr1/fenv.h>\n #include <tr1/float.h>\n #include <tr1/functional>\n-#include <tr1/hashtable>\n #include <tr1/inttypes.h>\n #include <tr1/limits.h>\n #include <tr1/math.h>"}]}