{"sha": "c4984bad36ef142b95331ca1552b7498fa78f019", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5ODRiYWQzNmVmMTQyYjk1MzMxY2ExNTUyYjc0OThmYTc4ZjAxOQ==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@linux.org.pl", "date": "2000-07-03T16:51:38Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2000-07-03T16:51:38Z"}, "message": "avr.c (out_adj_frame_ptr): Make \"frame pointer change too big for -mtiny-stack\" a warning, if larger than 63.\n\n\t* config/avr/avr.c (out_adj_frame_ptr): Make \"frame pointer\n\tchange too big for -mtiny-stack\" a warning, if larger than 63.\n\t(out_set_stack_ptr): Change the logic so -mno-interrupts is\n\talways safe to use on possible future devices.\n\t(function_prologue): Write SPH before SPL, for consistency.\n\tIf interrupt_func_p true, we know we have enabled interrupts.\n\t(avr_num_arg_regs): New function.  Round up to even number of\n\tbytes if no -mpack-args or if calling a libgcc function.\n\t(function_arg, function_arg_advance): Use it.\n\t(output_movsisf, ashlsi3_out, ashrsi3_out, lshrsi3_out):\n\tOutput \"movw\" if available.\n\t(out_tsthi, out_tstsi, ashlqi3_out, lshrqi3_out): Change uses\n\tof TEST_HARD_REG_CLASS macro to test_hard_reg_class function.\n\t(asm_output_section_name): Add blanks for consistent output.\n\t(encode_section_info): Set TREE_READONLY for progmem data to\n\tavoid gas warnings about changed section attributes.\n\t(avr_hard_regno_mode_ok): Force non-QImode data to start in\n\teven numbered registers on devices with \"movw\".\n\t* config/avr/avr.h (MASK_*): Define bits for target_flags.\n\t(TARGET_SWITCHES): Mark help strings for translation.\n\tAdd new -mpack-args and -menhanced switches.\n\t(TARGET_OPTIONS): Mark help strings for translation.\n\t(progmem_section): Add section attributes.\n\t* config/avr/avr.md (*movhi, call_insn, call_value_insn):\n\tOutput \"movw\" if available.\n\t(mulqi3, mulqihi3, umulqihi3, mulhi3, *tablejump_enh):\n\tNew patterns.\n\t* config/avr/libgcc.S (_mulqi3, _divqi3): Update to the new\n\tcall convention (arguments aligned on even registers).\n\t(_cleanup, _exit): Make weak symbols libc can override.\n\nFrom-SVN: r34847", "tree": {"sha": "36cc90f578a0749cf42c94fbbd73a418032a02e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36cc90f578a0749cf42c94fbbd73a418032a02e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4984bad36ef142b95331ca1552b7498fa78f019", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4984bad36ef142b95331ca1552b7498fa78f019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4984bad36ef142b95331ca1552b7498fa78f019", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4984bad36ef142b95331ca1552b7498fa78f019/comments", "author": null, "committer": null, "parents": [{"sha": "2e6377216286353f8c6fc8b1ecf7dab9e225ce00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6377216286353f8c6fc8b1ecf7dab9e225ce00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6377216286353f8c6fc8b1ecf7dab9e225ce00"}], "stats": {"total": 347, "additions": 260, "deletions": 87}, "files": [{"sha": "b046a72e01beb91ede78b6215aa9d86a45a863b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4984bad36ef142b95331ca1552b7498fa78f019", "patch": "@@ -1,3 +1,36 @@\n+2000-07-01  Marek Michalkiewicz  <marekm@linux.org.pl>\n+\n+\t* config/avr/avr.c (out_adj_frame_ptr): Make \"frame pointer\n+\tchange too big for -mtiny-stack\" a warning, if larger than 63.\n+\t(out_set_stack_ptr): Change the logic so -mno-interrupts is\n+\talways safe to use on possible future devices.\n+\t(function_prologue): Write SPH before SPL, for consistency.\n+\tIf interrupt_func_p true, we know we have enabled interrupts.\n+\t(avr_num_arg_regs): New function.  Round up to even number of\n+\tbytes if no -mpack-args or if calling a libgcc function.\n+\t(function_arg, function_arg_advance): Use it.\n+\t(output_movsisf, ashlsi3_out, ashrsi3_out, lshrsi3_out):\n+\tOutput \"movw\" if available.\n+\t(out_tsthi, out_tstsi, ashlqi3_out, lshrqi3_out): Change uses\n+\tof TEST_HARD_REG_CLASS macro to test_hard_reg_class function.\n+\t(asm_output_section_name): Add blanks for consistent output.\n+\t(encode_section_info): Set TREE_READONLY for progmem data to\n+\tavoid gas warnings about changed section attributes.\n+\t(avr_hard_regno_mode_ok): Force non-QImode data to start in\n+\teven numbered registers on devices with \"movw\".\n+\t* config/avr/avr.h (MASK_*): Define bits for target_flags.\n+\t(TARGET_SWITCHES): Mark help strings for translation.\n+\tAdd new -mpack-args and -menhanced switches.\n+\t(TARGET_OPTIONS): Mark help strings for translation.\n+\t(progmem_section): Add section attributes.\n+\t* config/avr/avr.md (*movhi, call_insn, call_value_insn):\n+\tOutput \"movw\" if available.\n+\t(mulqi3, mulqihi3, umulqihi3, mulhi3, *tablejump_enh):\n+\tNew patterns.\n+\t* config/avr/libgcc.S (_mulqi3, _divqi3): Update to the new\n+\tcall convention (arguments aligned on even registers).\n+\t(_cleanup, _exit): Make weak symbols libc can override.\n+\n 2000-07-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* fp-bit.h: New file."}, {"sha": "ac07707dddd5111ad8e5d615eaa4e296d7a16cd5", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 130, "deletions": 71, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=c4984bad36ef142b95331ca1552b7498fa78f019", "patch": "@@ -49,6 +49,7 @@ static int    signal_function_p    PARAMS ((tree));\n static int    sequent_regs_live    PARAMS ((void));\n static char * ptrreg_to_str        PARAMS ((int));\n static char * cond_string          PARAMS ((enum rtx_code));\n+static int    avr_num_arg_regs     PARAMS ((enum machine_mode, tree));\n static int    out_adj_frame_ptr    PARAMS ((FILE *, int));\n static int    out_set_stack_ptr    PARAMS ((FILE *, int, int));\n \n@@ -347,30 +348,23 @@ out_adj_frame_ptr (file, adj)\n \n   if (adj)\n     {\n-      /* For -mtiny-stack, the high byte (r29) does not change -\n-\t prefer \"subi\" (1 cycle) over \"sbiw\" (2 cycles).  */\n-\n-      if (adj < -63 || adj > 63 || TARGET_TINY_STACK)\n+      if (TARGET_TINY_STACK)\n \t{\n-\t  fprintf (file, (AS2 (subi, r28, lo8(%d)) CR_TAB), adj);\n-\t  size++;\n+\t  if (adj < -63 || adj > 63)\n+\t    warning (\"large frame pointer change (%d) with -mtiny-stack\", adj);\n \n-\t  if (TARGET_TINY_STACK)\n-\t    {\n-\t      /* In addition to any local data, each level of function calls\n-\t\t needs at least 4 more bytes of stack space for the saved\n-\t\t frame pointer and return address.  So, (255 - 16) leaves\n-\t\t room for 4 levels of function calls.  */\n-\n-\t      if (adj < -(255 - 16) || adj > (255 - 16))\n-\t\tfatal (\"Frame pointer change (%d) too big for -mtiny-stack\",\n-\t\t       adj);\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (file, (AS2 (sbci, r29, hi8(%d)) CR_TAB), adj);\n-\t      size++;\n-\t    }\n+\t  /* The high byte (r29) doesn't change - prefer \"subi\" (1 cycle)\n+\t     over \"sbiw\" (2 cycles, same size).  */\n+\n+\t  fprintf (file, (AS2 (subi, r28, %d) CR_TAB), adj);\n+\t  size++;\n+\t}\n+      else if (adj < -63 || adj > 63)\n+\t{\n+\t  fprintf (file, (AS2 (subi, r28, lo8(%d)) CR_TAB\n+\t\t\t  AS2 (sbci, r29, hi8(%d)) CR_TAB),\n+\t\t\t adj, adj);\n+\t  size += 2;\n \t}\n       else if (adj < 0)\n \t{\n@@ -398,17 +392,18 @@ out_set_stack_ptr (file, before, after)\n      int before;\n      int after;\n {\n-  int do_sph, do_cli, do_save, size;\n+  int do_sph, do_cli, do_save, do_sei, lock_sph, size;\n \n-  if (TARGET_NO_INTERRUPTS)\n-    {\n-      before = 0;\n-      after = 0;\n-    }\n+  /* The logic here is so that -mno-interrupts actually means\n+     \"it is safe to write SPH in one instruction, then SPL in the\n+     next instruction, without disabling interrupts first\".\n+     The after != -1 case (interrupt/signal) is not affected.  */\n \n   do_sph = !TARGET_TINY_STACK;\n-  do_cli = (before != 0 && (after == 0 || do_sph));\n-  do_save = (before == -1 && after == -1 && do_cli);\n+  lock_sph = do_sph && !TARGET_NO_INTERRUPTS;\n+  do_cli = (before != 0 && (after == 0 || lock_sph));\n+  do_save = (do_cli && before == -1 && after == -1);\n+  do_sei = ((do_cli || before != 1) && after == 1);\n   size = 1;\n \n   if (do_save)\n@@ -424,8 +419,8 @@ out_set_stack_ptr (file, before, after)\n     }\n \n   /* Do SPH first - maybe this will disable interrupts for one instruction\n-     someday, much like x86 does when changing SS (a suggestion has been\n-     sent to avr@atmel.com for consideration in future devices).  */\n+     someday (a suggestion has been sent to avr@atmel.com for consideration\n+     in future devices - that would make -mno-interrupts always safe).  */\n   if (do_sph)\n     {\n       fprintf (file, AS2 (out, __SP_H__, r29) CR_TAB);\n@@ -440,7 +435,7 @@ out_set_stack_ptr (file, before, after)\n       fprintf (file, AS2 (out, __SREG__, __tmp_reg__) CR_TAB);\n       size++;\n     }\n-  else if (after == 1 && (before != 1 || do_cli))\n+  else if (do_sei)\n     {\n       fprintf (file, \"sei\" CR_TAB);\n       size++;\n@@ -503,8 +498,8 @@ function_prologue (FILE *file, int size)\n       fprintf (file, (\"\\t\" \n \t\t      AS2 (ldi, r28, lo8(%s - %d)) CR_TAB\n \t\t      AS2 (ldi, r29, hi8(%s - %d)) CR_TAB\n-\t\t      AS2 (out,__SP_L__,r28)       CR_TAB\n-\t\t      AS2 (out,__SP_H__,r29) \"\\n\"),\n+\t\t      AS2 (out, __SP_H__, r29)     CR_TAB\n+\t\t      AS2 (out, __SP_L__, r28) \"\\n\"),\n \t       initial_stack, size, initial_stack, size);\n       \n       prologue_size += 4;\n@@ -569,7 +564,7 @@ function_prologue (FILE *file, int size)\n \n \t\tif (interrupt_func_p)\n \t\t  {\n-\t\t    prologue_size += out_set_stack_ptr (file, -1, 1);\n+\t\t    prologue_size += out_set_stack_ptr (file, 1, 1);\n \t\t  }\n \t\telse if (signal_func_p)\n \t\t  {\n@@ -1288,6 +1283,33 @@ init_cumulative_args (cum, fntype, libname, indirect)\n     }\n }\n \n+/* Returns the number of registers to allocate for a function argument.  */\n+\n+static int\n+avr_num_arg_regs (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  int size;\n+\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  /* Align all function arguments to start in even-numbered registers,\n+     for \"movw\" on the enhanced core (to keep call conventions the same\n+     on all devices, do it even if \"movw\" is not available).  Odd-sized\n+     arguments leave holes above them - registers still available for\n+     other uses.  Use -mpack-args for compatibility with old asm code\n+     (the new convention will still be used for libgcc calls).  */\n+\n+  if (!(type && TARGET_PACK_ARGS))\n+    size += size & 1;\n+\n+  return size;\n+}\n+\n /* Controls whether a function argument is passed\n    in a register, and which register. */\n \n@@ -1298,12 +1320,11 @@ function_arg (cum, mode, type, named)\n      tree type;\n      int named ATTRIBUTE_UNUSED;\n {\n-  int bytes;\n-\n-  bytes = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  int bytes = avr_num_arg_regs (mode, type);\n \n   if (cum->nregs && bytes <= cum->nregs)\n     return gen_rtx (REG, mode, cum->regno - bytes);\n+\n   return NULL_RTX;\n }\n \n@@ -1317,9 +1338,8 @@ function_arg_advance (cum, mode, type, named)\n      tree type;                 /* type of the argument or 0 if lib support */\n      int named ATTRIBUTE_UNUSED; /* whether or not the argument was named */\n {\n-  int bytes;\n+  int bytes = avr_num_arg_regs (mode, type);\n \n-  bytes = (mode == BLKmode ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n   cum->nregs -= bytes;\n   cum->regno -= bytes;\n \n@@ -1328,8 +1348,6 @@ function_arg_advance (cum, mode, type, named)\n       cum->nregs = 0;\n       cum->regno = FIRST_CUM_REG;\n     }\n-\n-  return;\n }\n \n /***********************************************************************\n@@ -1788,16 +1806,33 @@ output_movsisf(insn, operands, which_alternative)\n     {\n     case 0: /* mov r,r */\n       if (true_regnum (operands[0]) > true_regnum (operands[1]))\n-        return (AS2 (mov,%D0,%D1) CR_TAB\n-\t        AS2 (mov,%C0,%C1) CR_TAB\n-\t\tAS2 (mov,%B0,%B1) CR_TAB\n-\t\tAS2 (mov,%A0,%A1));\n+\t{\n+\t  if (TARGET_ENHANCED)\n+\t    return (AS2 (movw,%C0,%C1) CR_TAB\n+\t\t    AS2 (movw,%A0,%A1));  /* FIXME: length = 4 -> 2 */\n+\t  else\n+\t    return (AS2 (mov,%D0,%D1) CR_TAB\n+\t\t    AS2 (mov,%C0,%C1) CR_TAB\n+\t\t    AS2 (mov,%B0,%B1) CR_TAB\n+\t\t    AS2 (mov,%A0,%A1));\n+\t}\n       else\n-        return (AS2 (mov,%A0,%A1) CR_TAB\n-\t        AS2 (mov,%B0,%B1) CR_TAB\n-\t\tAS2 (mov,%C0,%C1) CR_TAB\n-\t\tAS2 (mov,%D0,%D1));\n+\t{\n+\t  if (TARGET_ENHANCED)\n+\t    return (AS2 (movw,%A0,%A1) CR_TAB\n+\t\t    AS2 (movw,%C0,%C1));  /* FIXME: length = 4 -> 2 */\n+\t  else\n+\t    return (AS2 (mov,%A0,%A1) CR_TAB\n+\t\t    AS2 (mov,%B0,%B1) CR_TAB\n+\t\t    AS2 (mov,%C0,%C1) CR_TAB\n+\t\t    AS2 (mov,%D0,%D1));\n+\t}\n     case 1:  /* mov r,L */\n+      if (TARGET_ENHANCED)\n+\treturn (AS1 (clr,%A0) CR_TAB\n+\t\tAS1 (clr,%B0) CR_TAB\n+\t\tAS2 (movw,%C0,%A0));  /* FIXME: length = 4 -> 3 */\n+\n       return (AS1 (clr,%A0) CR_TAB\n \t      AS1 (clr,%B0) CR_TAB\n \t      AS1 (clr,%C0) CR_TAB\n@@ -2052,7 +2087,7 @@ out_tsthi (insn,l)\n       if (l) *l = 1;\n       return AS1 (tst,%B0);\n     }\n-  if (TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (SET_SRC (PATTERN (insn)))))\n+  if (test_hard_reg_class (ADDW_REGS, SET_SRC (PATTERN (insn))))\n     {\n       if (l) *l = 1;\n       return AS2 (sbiw,%0,0);\n@@ -2080,7 +2115,7 @@ out_tstsi (insn,l)\n       if (l) *l = 1;\n       return AS1 (tst,%D0);\n     }\n-  if (TEST_HARD_REG_CLASS (ADDW_REGS, true_regnum (SET_SRC (PATTERN (insn)))))\n+  if (test_hard_reg_class (ADDW_REGS, SET_SRC (PATTERN (insn))))\n     {\n       if (l) *l = 3;\n       return (AS2 (sbiw,%A0,0) CR_TAB\n@@ -2142,7 +2177,7 @@ out_shift_with_cnt (template,insn,operands,len)\n \t  *len = mov_len + 1;\n \t}\n     }\n-  else if (register_operand (operands[2],QImode))\n+  else if (register_operand (operands[2], QImode))\n     {\n       if (reg_unused_after (insn, operands[2]))\n \top[3] = op[2];\n@@ -2211,7 +2246,7 @@ ashlqi3_out (insn,operands,len)\n \t\t  AS1 (lsl,%0));\n \n \tcase 4:\n-\t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n+\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n \t    {\n \t      *len = 2;\n \t      return (AS1 (swap,%0) CR_TAB\n@@ -2224,7 +2259,7 @@ ashlqi3_out (insn,operands,len)\n \t\t  AS1 (lsl,%0));\n \n \tcase 5:\n-\t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n+\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n \t    {\n \t      *len = 3;\n \t      return (AS1 (swap,%0) CR_TAB\n@@ -2239,7 +2274,7 @@ ashlqi3_out (insn,operands,len)\n \t\t  AS1 (lsl,%0));\n \n \tcase 6:\n-\t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n+\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n \t    {\n \t      *len = 4;\n \t      return (AS1 (swap,%0) CR_TAB\n@@ -2376,6 +2411,13 @@ ashlsi3_out (insn,operands,len)\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n \t    *len = 4;\n+\t    if (TARGET_ENHANCED && (reg0 + 2 != reg1))\n+\t      {\n+\t\t*len = 3;\n+\t\treturn (AS2 (movw,%C0,%A1) CR_TAB\n+\t\t\tAS1 (clr,%B0)      CR_TAB\n+\t\t\tAS1 (clr,%A0));\n+\t      }\n \t    if (reg0 + 1 >= reg1)\n \t      return (AS2 (mov,%D0,%B1)  CR_TAB\n \t\t      AS2 (mov,%C0,%A1)  CR_TAB\n@@ -2610,6 +2652,15 @@ ashrsi3_out (insn,operands,len)\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n \t    *len=6;\n+\t    if (TARGET_ENHANCED && (reg0 != reg1 + 2))\n+\t      {\n+\t\t*len = 5;\n+\t\treturn (AS2 (movw,%A0,%C1) CR_TAB\n+\t\t\tAS1 (clr,%D0)      CR_TAB\n+\t\t\tAS2 (sbrc,%B0,7)   CR_TAB\n+\t\t\tAS1 (com,%D0)      CR_TAB\n+\t\t\tAS2 (mov,%C0,%D0));\n+\t      }\n \t    if (reg0 <= reg1 + 1)\n \t      return (AS2 (mov,%A0,%C1) CR_TAB\n \t\t      AS2 (mov,%B0,%D1) CR_TAB\n@@ -2693,7 +2744,7 @@ lshrqi3_out (insn,operands,len)\n \t\t  AS1 (lsr,%0));\n \t  \n \tcase 4:\n-\t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n+\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n \t    {\n \t      *len=2;\n \t      return (AS1 (swap,%0) CR_TAB\n@@ -2706,7 +2757,7 @@ lshrqi3_out (insn,operands,len)\n \t\t  AS1 (lsr,%0));\n \t  \n \tcase 5:\n-\t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n+\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n \t    {\n \t      *len = 3;\n \t      return (AS1 (swap,%0) CR_TAB\n@@ -2721,7 +2772,7 @@ lshrqi3_out (insn,operands,len)\n \t\t  AS1 (lsr,%0));\n \t  \n \tcase 6:\n-\t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n+\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n \t    {\n \t      *len = 4;\n \t      return (AS1 (swap,%0) CR_TAB\n@@ -2860,6 +2911,13 @@ lshrsi3_out (insn,operands,len)\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n \t    *len = 4;\n+\t    if (TARGET_ENHANCED && (reg0 != reg1 + 2))\n+\t      {\n+\t\t*len = 3;\n+\t\treturn (AS2 (movw,%A0,%C1) CR_TAB\n+\t\t\tAS1 (clr,%C0)      CR_TAB\n+\t\t\tAS1 (clr,%D0));\n+\t      }\n \t    if (reg0 <= reg1 + 1)\n \t      return (AS2 (mov,%A0,%C1) CR_TAB\n \t\t      AS2 (mov,%B0,%D1) CR_TAB\n@@ -3275,7 +3333,7 @@ asm_output_section_name(file, decl, name, reloc)\n      const char *name;\n      int reloc ATTRIBUTE_UNUSED;\n {\n-  fprintf (file, \".section\\t%s,\\\"%s\\\",@progbits\\n\", name, \\\n+  fprintf (file, \".section %s, \\\"%s\\\", @progbits\\n\", name,\n \t   decl && TREE_CODE (decl) == FUNCTION_DECL ? \"ax\" :\n \t   decl && TREE_READONLY (decl) ? \"a\" : \"aw\");\n }\n@@ -3407,9 +3465,9 @@ valid_machine_type_attribute(type, attributes, identifier, args)\n    Valid attributes:\n    progmem - put data to program memory;\n    signal - make a function to be hardware interrupt. After function\n-   epilogue interrupts are disabled;\n+   prologue interrupts are disabled;\n    interrupt - make a function to be hardware interrupt. After function\n-   epilogue interrupts are enabled;\n+   prologue interrupts are enabled;\n    naked     - don't generate function prologue/epilogue and `ret' command.  */\n \n int\n@@ -3440,7 +3498,7 @@ valid_machine_decl_attribute (decl, attributes, attr, args)\n \n \n /* Look for attribute `progmem' in DECL\n-   founded - 1 otherwise 0 */\n+   if found return 1, otherwise 0.  */\n \n int\n avr_progmem_p (decl)\n@@ -3481,6 +3539,7 @@ encode_section_info (decl)\n     {\n       char * dsec = \".progmem.data\";\n       DECL_SECTION_NAME (decl) = build_string (strlen (dsec), dsec);\n+      TREE_READONLY (decl) = 1;\n     }\n }   \n \n@@ -3864,7 +3923,7 @@ avr_function_value (type,func)\n   return gen_rtx (REG, BLKmode, RET_REGISTER + 2 - offs);\n }\n \n-/* Returns non-zero if number MASK have only one setted bit */\n+/* Returns non-zero if the number MASK has only one bit set.  */\n \n int\n mask_one_bit_p (mask)\n@@ -3892,7 +3951,7 @@ mask_one_bit_p (mask)\n    in class CLASS.  */\n \n enum reg_class\n-preferred_reload_class(x,class)\n+preferred_reload_class (x, class)\n      rtx x;\n      enum reg_class class;\n {\n@@ -3908,7 +3967,7 @@ preferred_reload_class(x,class)\n }\n \n int\n-test_hard_reg_class(class, x)\n+test_hard_reg_class (class, x)\n      enum reg_class class;\n      rtx x;\n {\n@@ -3946,9 +4005,9 @@ jump_over_one_insn_p (insn, dest)\n }\n \n /* Returns 1 if a value of mode MODE can be stored starting with hard\n-   register number REGNO.  On the enhanced core, it should be a win to\n-   align modes larger than QI on even register numbers (even if < 24).\n-   so that the \"movw\" instruction can be used on them.  */\n+   register number REGNO.  On the enhanced core, anything larger than\n+   1 byte must start in even numbered register for \"movw\" to work\n+   (this way we don't have to check for odd registers everywhere).  */\n \n int\n avr_hard_regno_mode_ok (regno, mode)\n@@ -3957,7 +4016,7 @@ avr_hard_regno_mode_ok (regno, mode)\n {\n   if (mode == QImode)\n     return 1;\n-  if (regno < 24 /* && !TARGET_ENHANCED */ )\n+  if (regno < 24 && !TARGET_ENHANCED)\n     return 1;\n   return !(regno & 1);\n }"}, {"sha": "1d8d10099729b5f2e4c3f3f275c3f8d3882855f9", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=c4984bad36ef142b95331ca1552b7498fa78f019", "patch": "@@ -249,6 +249,9 @@\n   switch (which_alternative)\n     {\n     case 0: /* mov r,r */\n+      if (TARGET_ENHANCED)\n+\treturn (AS2 (movw,%0,%1));  /* FIXME: length = 2 -> 1 */\n+\n       if (true_regnum (operands[0]) > true_regnum (operands[1]))\n         return (AS2 (mov,%B0,%B1) CR_TAB\n \t        AS2 (mov,%A0,%A1));\n@@ -653,6 +656,57 @@\n   [(set_attr \"length\" \"4,4\")\n    (set_attr \"cc\" \"set_czn,set_czn\")])\n \n+;******************************************************************************\n+; mul\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mult:QI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_ENHANCED\"\n+  \"mul %1,%2\n+\tmov %0,r0\n+\tclr r1\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))\n+\t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"d\"))))]\n+  \"TARGET_ENHANCED\"\n+  \"muls %1,%2\n+\tmovw %0,r0\n+\tclr r1\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_ENHANCED\"\n+  \"mul %1,%2\n+\tmovw %0,r0\n+\tclr r1\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_ENHANCED\"\n+  \"mul %A1,%A2\n+\tmovw %0,r0\n+\tmul %A1,%B2\n+\tadd %B0,r0\n+\tmul %B1,%A2\n+\tadd %B0,r0\n+\tclr r1\"\n+  [(set_attr \"length\" \"7\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n ; and\n \n@@ -1604,9 +1658,15 @@\n   if (which_alternative==0)\n      return \\\"icall\\\";\n   else if (which_alternative==1)\n-     return (AS2 (mov, r30,%A0) CR_TAB\n-\t     AS2 (mov, r31,%B0) CR_TAB\n-\t     \\\"icall\\\");\n+    {\n+      if (TARGET_ENHANCED)\n+\treturn (AS2 (movw, r30, %0) CR_TAB\n+\t\t\\\"icall\\\");\n+      else\n+\treturn (AS2 (mov, r30, %A0) CR_TAB\n+\t\tAS2 (mov, r31, %B0) CR_TAB\n+\t\t\\\"icall\\\");\n+    }\n   else if (!AVR_MEGA)\n      return AS1(rcall,%c0);   \n   return AS1(call,%c0);\n@@ -1634,9 +1694,15 @@\n   if (which_alternative==0)\n      return \\\"icall\\\";\n   else if (which_alternative==1)\n-     return (AS2 (mov, r30,%A1) CR_TAB\n-\t     AS2 (mov, r31,%B1) CR_TAB\n-\t     \\\"icall\\\");\n+    {\n+      if (TARGET_ENHANCED)\n+\treturn (AS2 (movw, r30, %1) CR_TAB\n+\t\t\\\"icall\\\");\n+      else\n+\treturn (AS2 (mov, r30, %A1) CR_TAB\n+\t\tAS2 (mov, r31, %B1) CR_TAB\n+\t\t\\\"icall\\\");\n+    }\n   else if (!AVR_MEGA)\n      return AS1(rcall,%c1);   \n   return AS1(call,%c1);\n@@ -1676,6 +1742,21 @@\n   \"optimize\"\n   \"\")\n \n+(define_insn \"*tablejump_enh\"\n+   [(set (pc) (mem:HI\n+\t       (plus:HI (match_operand:HI 0 \"register_operand\" \"=&z\")\n+\t\t\t(label_ref (match_operand 2 \"\" \"\")))))\n+    (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_ENHANCED\"\n+  \"subi r30,lo8(-(%2))\n+\tsbci r31,hi8(-(%2))\n+\tlpm __tmp_reg__,Z+\n+\tlpm r31,Z\n+\tmov r30,__tmp_reg__\n+\tijmp\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"*tablejump\"\n    [(set (pc) (mem:HI\n \t       (plus:HI (match_operand:HI 0 \"register_operand\" \"=&z\")\n@@ -1686,10 +1767,10 @@\n \tsbci r31,hi8(-(%2))\n \tlpm\n \tpush r0\n-        adiw r30,1\n+\tadiw r30,1\n \tlpm\n \tpush r0\n-        ret\"\n+\tret\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"clobber\")])\n "}, {"sha": "e5ecbff9e0a9f8d976da3467d0ffde460c5fda13", "filename": "gcc/config/avr/libgcc.S", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4984bad36ef142b95331ca1552b7498fa78f019/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=c4984bad36ef142b95331ca1552b7498fa78f019", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02111-1307, USA.  */\n *******************************************************/\n #if defined (Lmulqi3)\n \n-#define\tr_arg2\tr25\t\t/* multiplicand */\n+#define\tr_arg2\tr22\t\t/* multiplicand */\n #define\tr_arg1 \tr24\t\t/* multiplier */\n #define r_res\t__tmp_reg__\t/* result */\n \n@@ -201,8 +201,8 @@ __mulsi3_exit:\n        Division 8 / 8 => (result + remainder)\n *******************************************************/\n #define\tr_rem\tr26\t/* remainder */\n-#define\tr_arg1\tr25\t/* dividend */\n-#define\tr_arg2\tr24\t/* divisor */\n+#define\tr_arg1\tr24\t/* dividend */\n+#define\tr_arg2\tr22\t/* divisor */\n #define\tr_cnt\tr27\t/* loop count */\n \n #if defined (Lumodqi3)\n@@ -272,8 +272,7 @@ __divqi3_1:\n \tsbrc\t__tmp_reg__,7\n \tneg\tr_arg1\t\t; correct result sign\n __divqi3_exit:\n-\tmov\tr24,r_arg1\t; put result to return register\n-\tret\n+\tret\t\t\t; result already in r24 (r_arg1)\n .endfunc\n #endif /* defined (Ldivqi3) */\n \n@@ -434,8 +433,6 @@ _umodsi3_ret:\n \tmov\tr24,r_remHL\n \tmov\tr23,r_remH\n \tmov\tr22,r_remL\n-\t.global\t_cleanup\n-_cleanup:\n \tret\n .endfunc\n #endif /* defined (Lumodsi3) */\n@@ -630,9 +627,12 @@ __epilogue_restores__:\n #endif /* defined (Lepilogue) */\n \n #ifdef L__exit\n-\t.global\t_exit\n+\t.weak\t_exit\n \t.func\t_exit\n _exit:\n \trjmp\t_exit\n+\t.weak\t_cleanup\n+_cleanup:\n+\tret\n .endfunc\n #endif"}]}