{"sha": "5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWViZmFhY2ZiNWZmYjljM2RjYzBlYTgwZjFmNTFhZmY5NGUzNGNhZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-21T13:42:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-21T13:42:22Z"}, "message": "[multiple changes]\n\n2011-12-21  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-crbtgk.adb (Generic_Conditional_Insert): Fixed incorrect comment.\n\n2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): If the name\n\tof an element iterator is not an entity name we introduce a\n\tlocal renaming declaration for it. To prevent spurious warnings\n\ton parameterless function calls that return a container, when\n\texpansion is disabled (either explicitly or because of a previous\n\terrors) the name must be marked as not coming from source.\n\n2011-12-21  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Separate\n\thandling in CodePeer mode and only ignore Component_Size\n\tattribute.\n\n2011-12-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb (Process_Formals): Set proper mechanism for\n\tformals whose types have conventions Ada_Pass_By_Copy or\n\tAda_Pass_By_Reference.\n\nFrom-SVN: r182584", "tree": {"sha": "247b82d23f09335fb206e9cb9737d5acbf2ced65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/247b82d23f09335fb206e9cb9737d5acbf2ced65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/comments", "author": null, "committer": null, "parents": [{"sha": "892d824b4518db351f549a1d0fe2e423b769be11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892d824b4518db351f549a1d0fe2e423b769be11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/892d824b4518db351f549a1d0fe2e423b769be11"}], "stats": {"total": 131, "additions": 113, "deletions": 18}, "files": [{"sha": "dcf04f978d44e4620c056f8b641037e42d77f706", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "patch": "@@ -1,3 +1,28 @@\n+2011-12-21  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-crbtgk.adb (Generic_Conditional_Insert): Fixed incorrect comment.\n+\n+2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): If the name\n+\tof an element iterator is not an entity name we introduce a\n+\tlocal renaming declaration for it. To prevent spurious warnings\n+\ton parameterless function calls that return a container, when\n+\texpansion is disabled (either explicitly or because of a previous\n+\terrors) the name must be marked as not coming from source.\n+\n+2011-12-21  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Separate\n+\thandling in CodePeer mode and only ignore Component_Size\n+\tattribute.\n+\n+2011-12-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb (Process_Formals): Set proper mechanism for\n+\tformals whose types have conventions Ada_Pass_By_Copy or\n+\tAda_Pass_By_Reference.\n+\n 2011-12-21  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat1drv.adb (Gnat1Drv): Always delete old scil files in"}, {"sha": "713e54269487531ad909484609a8aa10f0c390aa", "filename": "gcc/ada/a-crbtgk.adb", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgk.adb?ref=5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,40 +121,72 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       X : Node_Access := Tree.Root;\n \n    begin\n+      --  This is a \"conditional\" insertion, meaning that the insertion request\n+      --  can \"fail\" in the sense that no new node is created. If the Key is\n+      --  equivalent to an existing node, then we return the existing node and\n+      --  Inserted is set to False. Otherwise, we allocate a new node (via\n+      --  Insert_Post) and Inserted is set to True.\n+\n+      --  Note that we are testing for equivalence here, not equality. Key must\n+      --  be strictly less than its next neighbor, and strictly greater than\n+      --  its previous neighbor, in order for the conditional insertion to\n+      --  succeed.\n+\n+      --  We search the tree to find the nearest neighbor of Key, which is\n+      --  either the smallest node greater than Key (Inserted is True), or the\n+      --  largest node less or equivalent to Key (Inserted is False).\n+\n       Inserted := True;\n       while X /= null loop\n          Y := X;\n          Inserted := Is_Less_Key_Node (Key, X);\n          X := (if Inserted then Ops.Left (X) else Ops.Right (X));\n       end loop;\n \n-      --  If Inserted is True, then this means either that Tree is\n-      --  empty, or there was a least one node (strictly) greater than\n-      --  Key. Otherwise, it means that Key is equal to or greater than\n-      --  every node.\n-\n       if Inserted then\n+\n+         --  Either Tree is empty, or Key is less than Y. If Y is the first\n+         --  node in the tree, then there are no other nodes that we need to\n+         --  search for, and we insert a new node into the tree.\n+\n          if Y = Tree.First then\n             Insert_Post (Tree, Y, True, Node);\n             return;\n          end if;\n \n+         --  Y is the next nearest-neighbor of Key. We know that Key is not\n+         --  equivalent to Y (because Key is strictly less than Y), so we move\n+         --  to the previous node, the nearest-neighbor just smaller or\n+         --  equivalent to Key.\n+\n          Node := Ops.Previous (Y);\n \n       else\n+         --  Y is the previous nearest-neighbor of Key. We know that Key is not\n+         --  less than Y, which means either that Key is equivalent to Y, or\n+         --  greater than Y.\n+\n          Node := Y;\n       end if;\n \n-      --  Here Node has a value that is less than or equal to Key. We\n-      --  now have to resolve whether Key is equal to or greater than\n-      --  Node, which determines whether the insertion succeeds.\n+      --  Key is equivalent to or greater than Node. We must resolve which is\n+      --  the case, to determine whether the conditional insertion succeeds.\n \n       if Is_Greater_Key_Node (Key, Node) then\n+\n+         --  Key is strictly greater than Node, which means that Key is not\n+         --  equivalent to Node. In this case, the insertion succeeds, and we\n+         --  insert a new node into the tree.\n+\n          Insert_Post (Tree, Y, Inserted, Node);\n          Inserted := True;\n          return;\n       end if;\n \n+      --  Key is equivalent to Node. This is a conditional insertion, so we do\n+      --  not insert a new node in this case. We return the existing node and\n+      --  report that no insertion has occurred.\n+\n       Inserted := False;\n    end Generic_Conditional_Insert;\n "}, {"sha": "98fd99ea36eb66fadcb8461d2e937bff4f4704b8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "patch": "@@ -2108,11 +2108,28 @@ package body Sem_Ch13 is\n          Set_Analyzed (N, True);\n       end if;\n \n+      --  Ignore some selected attributes in CodePeer mode since they are not\n+      --  relevant in this context.\n+\n+      if CodePeer_Mode then\n+         case Id is\n+\n+            --  Ignore Component_Size in CodePeer mode, to avoid changing the\n+            --  internal representation of types by implicitly packing them.\n+\n+            when Attribute_Component_Size =>\n+               Rewrite (N, Make_Null_Statement (Sloc (N)));\n+               return;\n+\n+            when others =>\n+               null;\n+         end case;\n+      end if;\n+\n       --  Process Ignore_Rep_Clauses option (we also ignore rep clauses in\n-      --  CodePeer mode or Alfa mode, since they are not relevant in these\n-      --  contexts).\n+      --  Alfa mode, since they are not relevant in this context).\n \n-      if Ignore_Rep_Clauses or CodePeer_Mode or Alfa_Mode then\n+      if Ignore_Rep_Clauses or Alfa_Mode then\n          case Id is\n \n             --  The following should be ignored. They do not affect legality"}, {"sha": "f3188b07fcb0dbb09c0e969798c91f0de6cb2df0", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "patch": "@@ -2257,11 +2257,17 @@ package body Sem_Ch5 is\n          begin\n             Typ := Etype (Iter_Name);\n \n+            --  The name in the renaming declaration may be a function call.\n+            --  Indicate that it does not come from source, to suppress\n+            --  spurious warnings on renamings of parameterless functions,\n+            --  a common enough idiom in user-defined iterators.\n+\n             Decl :=\n               Make_Object_Renaming_Declaration (Loc,\n                 Defining_Identifier => Id,\n                 Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n-                Name                => Relocate_Node (Iter_Name));\n+                Name                =>\n+                  New_Copy_Tree (Iter_Name, New_Sloc => Loc));\n \n             Insert_Actions (Parent (Parent (N)), New_List (Decl));\n             Rewrite (Name (N), New_Occurrence_Of (Id, Loc));"}, {"sha": "1df373722953c8fab321aedd7308f4087293be46", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5ebfaacfb5ffb9c3dcc0ea80f1f51aff94e34cad", "patch": "@@ -9527,14 +9527,14 @@ package body Sem_Ch6 is\n                Default :=  Expression (Param_Spec);\n \n                if Is_Scalar_Type (Etype (Default)) then\n-                  if Nkind\n-                       (Parameter_Type (Param_Spec)) /= N_Access_Definition\n+                  if Nkind (Parameter_Type (Param_Spec)) /=\n+                                              N_Access_Definition\n                   then\n                      Formal_Type := Entity (Parameter_Type (Param_Spec));\n-\n                   else\n-                     Formal_Type := Access_Definition\n-                       (Related_Nod, Parameter_Type (Param_Spec));\n+                     Formal_Type :=\n+                       Access_Definition\n+                         (Related_Nod, Parameter_Type (Param_Spec));\n                   end if;\n \n                   Apply_Scalar_Range_Check (Default, Formal_Type);\n@@ -9556,6 +9556,21 @@ package body Sem_Ch6 is\n \n          if Is_Aliased (Formal) then\n             Set_Mechanism (Formal, By_Reference);\n+\n+            --  Warn if user asked this to be passed by copy\n+\n+            if Convention (Formal_Type) = Convention_Ada_Pass_By_Copy then\n+               Error_Msg_N\n+                 (\"?cannot pass aliased parameter & by copy\", Formal);\n+            end if;\n+\n+         --  Force mechanism if type has Convention Ada_Pass_By_Ref/Copy\n+\n+         elsif Convention (Formal_Type) = Convention_Ada_Pass_By_Copy then\n+            Set_Mechanism (Formal, By_Copy);\n+\n+         elsif Convention (Formal_Type) = Convention_Ada_Pass_By_Reference then\n+            Set_Mechanism (Formal, By_Reference);\n          end if;\n \n          Next (Param_Spec);"}]}