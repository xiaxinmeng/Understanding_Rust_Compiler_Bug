{"sha": "b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMxNDdjMDJkYzc3MmFkNzdlYjdlMWQ1ZDZlMTRhOGYyMjJkMWU2NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-01T20:12:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-01T20:15:53Z"}, "message": "Make -fzero-call-used-regs work on the SPARC\n\nThis contains both a generic fixlet for targets implementing the leaf\nregister optimization (SPARC and Xtensa) and the implementation of the\ntarget hook TARGET_ZERO_CALL_USED_REGS which is needed to make this work\non the SPARC.\n\ngcc/ChangeLog:\n\t* function.c (gen_call_used_regs_seq): In a function subject to the\n\tleaf register optimization, skip registers that are not present.\n\t* config/sparc/sparc.c (TARGET_ZERO_CALL_USED_REGS): Define to...\n\t(sparc_zero_call_used_regs): ...this.  New function.", "tree": {"sha": "3e53fe0b7cf68f44db64ec22408d498fa385287e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e53fe0b7cf68f44db64ec22408d498fa385287e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65/comments", "author": null, "committer": null, "parents": [{"sha": "986bb15d5b375829f8858c2906dab1012166194f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/986bb15d5b375829f8858c2906dab1012166194f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/986bb15d5b375829f8858c2906dab1012166194f"}], "stats": {"total": 54, "additions": 54, "deletions": 0}, "files": [{"sha": "ec0921b7ef51c614534ae9a5ae72ce3ae0160288", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "patch": "@@ -708,6 +708,7 @@ static HOST_WIDE_INT sparc_constant_alignment (const_tree, HOST_WIDE_INT);\n static bool sparc_vectorize_vec_perm_const (machine_mode, rtx, rtx, rtx,\n \t\t\t\t\t    const vec_perm_indices &);\n static bool sparc_can_follow_jump (const rtx_insn *, const rtx_insn *);\n+static HARD_REG_SET sparc_zero_call_used_regs (HARD_REG_SET);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -959,6 +960,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CAN_FOLLOW_JUMP\n #define TARGET_CAN_FOLLOW_JUMP sparc_can_follow_jump\n \n+#undef TARGET_ZERO_CALL_USED_REGS\n+#define TARGET_ZERO_CALL_USED_REGS sparc_zero_call_used_regs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -13810,4 +13814,50 @@ sparc_constant_alignment (const_tree exp, HOST_WIDE_INT align)\n   return align;\n }\n \n+/* Implement TARGET_ZERO_CALL_USED_REGS.\n+\n+   Generate a sequence of instructions that zero registers specified by\n+   NEED_ZEROED_HARDREGS.  Return the ZEROED_HARDREGS that are actually\n+   zeroed.  */\n+\n+static HARD_REG_SET\n+sparc_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n+{\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n+      {\n+\t/* Do not touch the CC registers or the FP registers if no VIS.  */\n+\tif (regno >= SPARC_FCC_REG\n+\t    || (regno >= SPARC_FIRST_FP_REG && !TARGET_VIS))\n+\t  CLEAR_HARD_REG_BIT (need_zeroed_hardregs, regno);\n+\n+\t/* Do not access the odd upper FP registers individually.  */\n+\telse if (regno >= SPARC_FIRST_V9_FP_REG && (regno & 1))\n+\t  ;\n+\n+\t/* Use the most natural mode for the registers, which is not given by\n+\t   regno_reg_rtx/reg_raw_mode for the FP registers on the SPARC.  */\n+\telse\n+\t  {\n+\t    machine_mode mode;\n+\t    rtx reg;\n+\n+\t    if (regno < SPARC_FIRST_FP_REG)\n+\t      {\n+\t\treg = regno_reg_rtx[regno];\n+\t\tmode = GET_MODE (reg);\n+\t      }\n+\t    else\n+\t      {\n+\t\tmode = regno < SPARC_FIRST_V9_FP_REG ? SFmode : DFmode;\n+\t\treg = gen_raw_REG (mode, regno);\n+\t      }\n+\n+\t    emit_move_insn (reg, CONST0_RTX (mode));\n+\t  }\n+      }\n+\n+  return need_zeroed_hardregs;\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "59fd72b0e820de69625fd493726bb9542ac100a0", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b3147c02dc772ad77eb7e1d5d6e14a8f222d1e65", "patch": "@@ -5880,6 +5880,10 @@ gen_call_used_regs_seq (rtx_insn *ret, unsigned int zero_regs_type)\n \tcontinue;\n       if (only_arg && !FUNCTION_ARG_REGNO_P (regno))\n \tcontinue;\n+#ifdef LEAF_REG_REMAP\n+      if (crtl->uses_only_leaf_regs && LEAF_REG_REMAP (regno) < 0)\n+\tcontinue;\n+#endif\n \n       /* Now this is a register that we might want to zero.  */\n       SET_HARD_REG_BIT (selected_hardregs, regno);"}]}