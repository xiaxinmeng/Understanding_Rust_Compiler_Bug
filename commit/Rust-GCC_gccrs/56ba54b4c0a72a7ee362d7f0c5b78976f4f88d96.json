{"sha": "56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiYTU0YjRjMGE3MmE3ZWUzNjJkN2YwYzViNzg5NzZmNGY4OGQ5Ng==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-30T13:05:33Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-30T13:05:33Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r27853,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r27854", "tree": {"sha": "5807fec186c5db0ee8bcc27015b2079d04b2c27e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5807fec186c5db0ee8bcc27015b2079d04b2c27e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/comments", "author": null, "committer": null, "parents": [{"sha": "2fa39a0ec6a238c23ce9c6df6fde18e9ea8625d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa39a0ec6a238c23ce9c6df6fde18e9ea8625d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa39a0ec6a238c23ce9c6df6fde18e9ea8625d4"}], "stats": {"total": 303, "additions": 254, "deletions": 49}, "files": [{"sha": "9fc894d4946e0da9d066fe1fb18f00ba8d9d9ae0", "filename": "boehm-gc/cord/cordbscs.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fcordbscs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fcordbscs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordbscs.c?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -361,7 +361,6 @@ CORD CORD_substr_checked(CORD x, size_t i, size_t n)\n             return(CORD_substr_closure(x, i, n, CORD_index_access_fn));\n         } else {\n             register char * result = GC_MALLOC_ATOMIC(n+1);\n-            register char * p = result;\n             \n             if (result == 0) OUT_OF_MEMORY;\n             strncpy(result, x+i, n);"}, {"sha": "9c8cc8736a90fc658cb7e6d10b4ff4a9d48cbb4b", "filename": "boehm-gc/cord/cordprnt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -231,8 +231,9 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n             \t    \tgoto done;\n \t\t    case 'c':\n \t\t\tif (width == NONE && prec == NONE) {\n-\t\t\t    register char c = va_arg(args, char);\n+\t\t\t    register char c;\n \n+\t\t\t    c = va_arg(args, char);\n \t\t\t    CORD_ec_append(result, c);\n \t\t\t    goto done;\n \t\t\t}"}, {"sha": "fda71424176f784a858aa56a56736cc0fc14d22d", "filename": "boehm-gc/cord/de.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde.c?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -565,7 +565,6 @@ int argc;\n char ** argv;\n {\n     int c;\n-    CORD initial;\n \n #if defined(MACINTOSH)\n \tconsole_options.title = \"\\pDumb Editor\";"}, {"sha": "fedbfbe67c25becc9f082aa3bb3e4f0c3d4f351f", "filename": "boehm-gc/cord/de_win.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fde_win.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fde_win.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.c?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -268,6 +268,7 @@ LRESULT CALLBACK WndProc (HWND hwnd, UINT message,\n \n       case WM_DESTROY:\n            PostQuitMessage (0);\n+\t   GC_win32_free_heap();\n            return 0;\n       \n       case WM_PAINT:"}, {"sha": "ceabb02f6eb611e5c4fada97e6dd589c4558ac30", "filename": "boehm-gc/cord/gc.h", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Fcord%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fgc.h?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -36,11 +36,19 @@\n #endif\n \n #if defined(_MSC_VER) && defined(_DLL)\n-#ifdef GC_BUILD\n-#define GC_API __declspec(dllexport)\n-#else\n-#define GC_API __declspec(dllimport)\n+# ifdef GC_BUILD\n+#   define GC_API __declspec(dllexport)\n+# else\n+#   define GC_API __declspec(dllimport)\n+# endif\n #endif\n+\n+#if defined(__WATCOMC__) && defined(GC_DLL)\n+# ifdef GC_BUILD\n+#   define GC_API extern __declspec(dllexport)\n+# else\n+#   define GC_API extern __declspec(dllimport)\n+# endif\n #endif\n \n #ifndef GC_API\n@@ -126,7 +134,19 @@ GC_API GC_word GC_max_retries;\n \t\t\t/* reporting out of memory after heap\t\t*/\n \t\t\t/* expansion fails.  Initially 0.\t\t*/\n \t\t\t\n-\t\t\t\n+\n+GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n+\t\t\t\t/* May be set in the client prior to\t*/\n+\t\t\t\t/* calling any GC_ routines.  This\t*/\n+\t\t\t\t/* avoids some overhead, and \t\t*/\n+\t\t\t\t/* potentially some signals that can \t*/\n+\t\t\t\t/* confuse debuggers.  Otherwise the\t*/\n+\t\t\t\t/* collector attempts to set it \t*/\n+\t\t\t\t/* automatically.\t\t\t*/\n+\t\t\t\t/* For multithreaded code, this is the\t*/\n+\t\t\t\t/* cold end of the stack for the\t*/\n+\t\t\t\t/* primordial thread.\t\t\t*/\n+\t\t\t\t\n /* Public procedures */\n /*\n  * general purpose allocation routines, with roughly malloc calling conv.\n@@ -193,8 +213,8 @@ GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n /* If the argument is stubborn, the result will have changes enabled.\t*/\n /* It is an error to have changes enabled for the original object.\t*/\n /* Follows ANSI comventions for NULL old_object.\t\t\t*/\n-GC_API GC_PTR GC_realloc GC_PROTO((GC_PTR old_object,\n-\t\t\t\t   size_t new_size_in_bytes));\n+GC_API GC_PTR GC_realloc\n+\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes));\n \t\t\t\t   \n /* Explicitly increase the heap size.\t*/\n /* Returns 0 on failure, 1 on success.  */\n@@ -248,6 +268,7 @@ GC_API void GC_gcollect GC_PROTO((void));\n /* than normal pause times for incremental collection.  However,\t*/\n /* aborted collections do no useful work; the next collection needs\t*/\n /* to start from the beginning.\t\t\t\t\t\t*/\n+/* Return 0 if the collection was aborted, 1 if it succeeded.\t\t*/\n typedef int (* GC_stop_func) GC_PROTO((void));\n GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n \n@@ -604,6 +625,10 @@ GC_API void (*GC_is_valid_displacement_print_proc)\n GC_API void (*GC_is_visible_print_proc)\n \tGC_PROTO((GC_PTR p));\n \n+#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n+#   define SOLARIS_THREADS\n+#endif\n+\n #ifdef SOLARIS_THREADS\n /* We need to intercept calls to many of the threads primitives, so \t*/\n /* that we can locate thread stacks and stop the world.\t\t\t*/\n@@ -660,7 +685,10 @@ GC_API void (*GC_is_visible_print_proc)\n \n #endif /* IRIX_THREADS || LINUX_THREADS */\n \n-#if defined(THREADS) && !defined(SRC_M3)\n+# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n+\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n+\tdefined(IRIX_JDK_THREADS)\n+   \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/\n@@ -691,6 +719,13 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n # endif\n #endif\n \n+#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+     || defined(_WIN32)\n+  /* win32S may not free all resources on process exit.  */\n+  /* This explicitly deallocates the heap.\t\t */\n+    GC_API void GC_win32_free_heap ();\n+#endif\n+\n #ifdef __cplusplus\n     }  /* end of extern \"C\" */\n #endif"}, {"sha": "ceabb02f6eb611e5c4fada97e6dd589c4558ac30", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -36,11 +36,19 @@\n #endif\n \n #if defined(_MSC_VER) && defined(_DLL)\n-#ifdef GC_BUILD\n-#define GC_API __declspec(dllexport)\n-#else\n-#define GC_API __declspec(dllimport)\n+# ifdef GC_BUILD\n+#   define GC_API __declspec(dllexport)\n+# else\n+#   define GC_API __declspec(dllimport)\n+# endif\n #endif\n+\n+#if defined(__WATCOMC__) && defined(GC_DLL)\n+# ifdef GC_BUILD\n+#   define GC_API extern __declspec(dllexport)\n+# else\n+#   define GC_API extern __declspec(dllimport)\n+# endif\n #endif\n \n #ifndef GC_API\n@@ -126,7 +134,19 @@ GC_API GC_word GC_max_retries;\n \t\t\t/* reporting out of memory after heap\t\t*/\n \t\t\t/* expansion fails.  Initially 0.\t\t*/\n \t\t\t\n-\t\t\t\n+\n+GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n+\t\t\t\t/* May be set in the client prior to\t*/\n+\t\t\t\t/* calling any GC_ routines.  This\t*/\n+\t\t\t\t/* avoids some overhead, and \t\t*/\n+\t\t\t\t/* potentially some signals that can \t*/\n+\t\t\t\t/* confuse debuggers.  Otherwise the\t*/\n+\t\t\t\t/* collector attempts to set it \t*/\n+\t\t\t\t/* automatically.\t\t\t*/\n+\t\t\t\t/* For multithreaded code, this is the\t*/\n+\t\t\t\t/* cold end of the stack for the\t*/\n+\t\t\t\t/* primordial thread.\t\t\t*/\n+\t\t\t\t\n /* Public procedures */\n /*\n  * general purpose allocation routines, with roughly malloc calling conv.\n@@ -193,8 +213,8 @@ GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n /* If the argument is stubborn, the result will have changes enabled.\t*/\n /* It is an error to have changes enabled for the original object.\t*/\n /* Follows ANSI comventions for NULL old_object.\t\t\t*/\n-GC_API GC_PTR GC_realloc GC_PROTO((GC_PTR old_object,\n-\t\t\t\t   size_t new_size_in_bytes));\n+GC_API GC_PTR GC_realloc\n+\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes));\n \t\t\t\t   \n /* Explicitly increase the heap size.\t*/\n /* Returns 0 on failure, 1 on success.  */\n@@ -248,6 +268,7 @@ GC_API void GC_gcollect GC_PROTO((void));\n /* than normal pause times for incremental collection.  However,\t*/\n /* aborted collections do no useful work; the next collection needs\t*/\n /* to start from the beginning.\t\t\t\t\t\t*/\n+/* Return 0 if the collection was aborted, 1 if it succeeded.\t\t*/\n typedef int (* GC_stop_func) GC_PROTO((void));\n GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n \n@@ -604,6 +625,10 @@ GC_API void (*GC_is_valid_displacement_print_proc)\n GC_API void (*GC_is_visible_print_proc)\n \tGC_PROTO((GC_PTR p));\n \n+#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n+#   define SOLARIS_THREADS\n+#endif\n+\n #ifdef SOLARIS_THREADS\n /* We need to intercept calls to many of the threads primitives, so \t*/\n /* that we can locate thread stacks and stop the world.\t\t\t*/\n@@ -660,7 +685,10 @@ GC_API void (*GC_is_visible_print_proc)\n \n #endif /* IRIX_THREADS || LINUX_THREADS */\n \n-#if defined(THREADS) && !defined(SRC_M3)\n+# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n+\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n+\tdefined(IRIX_JDK_THREADS)\n+   \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/\n@@ -691,6 +719,13 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n # endif\n #endif\n \n+#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+     || defined(_WIN32)\n+  /* win32S may not free all resources on process exit.  */\n+  /* This explicitly deallocates the heap.\t\t */\n+    GC_API void GC_win32_free_heap ();\n+#endif\n+\n #ifdef __cplusplus\n     }  /* end of extern \"C\" */\n #endif"}, {"sha": "ad7df5d71faf94e0231e8bed5688fd236a255990", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -133,7 +133,8 @@ uses explicit invocation.\n #endif\n \n #if ! defined( OPERATOR_NEW_ARRAY ) \\\n-    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6))\n+    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6) \\\n+        || __WATCOMC__ >= 1050)\n #   define OPERATOR_NEW_ARRAY\n #endif\n \n@@ -212,6 +213,8 @@ inline void* gc::operator new( size_t size ) {\n inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n     if (gcp == GC) \n         return GC_MALLOC( size );\n+    else if (gcp == PointerFreeGC)\n+\treturn GC_MALLOC_ATOMIC( size );\n     else\n         return GC_MALLOC_UNCOLLECTABLE( size );}\n \n@@ -234,7 +237,7 @@ inline void gc::operator delete[]( void* obj ) {\n \n \n inline gc_cleanup::~gc_cleanup() {\n-    GC_REGISTER_FINALIZER_IGNORE_SELF( this, 0, 0, 0, 0 );}\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( GC_base(this), 0, 0, 0, 0 );}\n \n inline void gc_cleanup::cleanup( void* obj, void* displ ) {\n     ((gc_cleanup*) ((char*) obj + (ptrdiff_t) displ))->~gc_cleanup();}"}, {"sha": "934075fa358c8faf5778e7bba7b34f0fbb52e631", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 160, "deletions": 28, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=56ba54b4c0a72a7ee362d7f0c5b78976f4f88d96", "patch": "@@ -42,7 +42,7 @@ typedef GC_word word;\n typedef GC_signed_word signed_word;\n \n # ifndef CONFIG_H\n-#   include \"config.h\"\n+#   include \"gcconfig.h\"\n # endif\n \n # ifndef HEADERS_H\n@@ -336,6 +336,9 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n /* space is assumed to be cleared.\t\t\t\t*/\n /* In the case os USE_MMAP, the argument must also be a \t*/\n /* physical page size.\t\t\t\t\t\t*/\n+/* GET_MEM is currently not assumed to retrieve 0 filled space, */\n+/* though we should perhaps take advantage of the case in which */\n+/* does.\t\t\t\t\t\t\t*/\n # ifdef PCR\n     char * real_malloc();\n #   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n@@ -434,7 +437,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #  ifdef LINUX_THREADS\n #    include <pthread.h>\n #    ifdef __i386__\n-       inline static GC_test_and_set(volatile unsigned int *addr) {\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n \t  int oldval;\n \t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n \t  __asm__ __volatile__(\"xchgl %0, %1\"\n@@ -475,14 +478,15 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n #  endif /* LINUX_THREADS */\n-#  ifdef IRIX_THREADS\n+#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS)\n #    include <pthread.h>\n #    include <mutex.h>\n \n-#    if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n+#    if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n+\t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n #        define GC_test_and_set(addr, v) test_and_set(addr,v)\n #    else\n-#\t  define GC_test_and_set(addr, v) __test_and_set(addr,v)\n+#\t define GC_test_and_set(addr, v) __test_and_set(addr,v)\n #    endif\n      extern unsigned long GC_allocate_lock;\n \t/* This is not a mutex because mutexes that obey the (optional) \t*/\n@@ -501,10 +505,17 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n #    else\n #\tdefine LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n-#       if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64))\n+#       if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n+\t   && defined(_COMPILER_VERSION) && _COMPILER_VERSION >= 700\n #\t    define UNLOCK() __lock_release(&GC_allocate_lock)\n #\telse\n-#           define UNLOCK() GC_allocate_lock = 0\n+\t    /* The function call in the following should prevent the\t*/\n+\t    /* compiler from moving assignments to below the UNLOCK.\t*/\n+\t    /* This is probably not necessary for ucode or gcc 2.8.\t*/\n+\t    /* It may be necessary for Ragnarok and future gcc\t\t*/\n+\t    /* versions.\t\t\t\t\t\t*/\n+#           define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n+\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 0; }\n #\tendif\n #    endif\n      extern GC_bool GC_collecting;\n@@ -513,7 +524,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t    GC_collecting = 1; \\\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n-#  endif /* IRIX_THREADS */\n+#  endif /* IRIX_THREADS || IRIX_JDK_THREADS */\n #  ifdef WIN32_THREADS\n #    include <windows.h>\n      GC_API CRITICAL_SECTION GC_allocate_ml;\n@@ -567,7 +578,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #   if defined(SRC_M3) || defined(AMIGA) || defined(SOLARIS_THREADS) \\\n \t|| defined(MSWIN32) || defined(MACOS) || defined(DJGPP) \\\n \t|| defined(NO_SIGNALS) || defined(IRIX_THREADS) \\\n-\t|| defined(LINUX_THREADS)\n+\t|| defined(IRIX_JDK_THREADS) || defined(LINUX_THREADS) \n \t\t\t/* Also useful for debugging.\t\t*/\n \t/* Should probably use thr_sigsetmask for SOLARIS_THREADS. */\n #     define DISABLE_SIGNALS()\n@@ -595,7 +606,8 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n  \t\t\t\t   PCR_waitForever);\n # else\n #   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n-\t|| defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+\t|| defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+\t|| defined(IRIX_JDK_THREADS)\n       void GC_stop_world();\n       void GC_start_world();\n #     define STOP_WORLD() GC_stop_world()\n@@ -864,7 +876,69 @@ struct hblk {\n /* Object free list link */\n # define obj_link(p) (*(ptr_t *)(p))\n \n-/*  lists of all heap blocks and free lists\t*/\n+/* The type of mark procedures.  This really belongs in gc_mark.h.\t*/\n+/* But we put it here, so that we can avoid scanning the mark proc\t*/\n+/* table.\t\t\t\t\t\t\t\t*/\n+typedef struct ms_entry * (*mark_proc)(/* word * addr, mark_stack_ptr,\n+\t\t\t\t\t  mark_stack_limit, env */);\n+# define LOG_MAX_MARK_PROCS 6\n+# define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n+\n+/* Root sets.  Logically private to mark_rts.c.  But we don't want the\t*/\n+/* tables scanned, so we put them here.\t\t\t\t\t*/\n+/* MAX_ROOT_SETS is the maximum number of ranges that can be \t*/\n+/* registered as static roots. \t\t\t\t\t*/\n+# ifdef LARGE_CONFIG\n+#   define MAX_ROOT_SETS 4096\n+# else\n+#   ifdef PCR\n+#     define MAX_ROOT_SETS 1024\n+#   else\n+#     ifdef MSWIN32\n+#\tdefine MAX_ROOT_SETS 512\n+\t    /* Under NT, we add only written pages, which can result \t*/\n+\t    /* in many small root sets.\t\t\t\t\t*/\n+#     else\n+#       define MAX_ROOT_SETS 64\n+#     endif\n+#   endif\n+# endif\n+\n+# define MAX_EXCLUSIONS (MAX_ROOT_SETS/4)\n+/* Maximum number of segments that can be excluded from root sets.\t*/\n+\n+/*\n+ * Data structure for excluded static roots.\n+ */\n+struct exclusion {\n+    ptr_t e_start;\n+    ptr_t e_end;\n+};\n+\n+/* Data structure for list of root sets.\t\t\t\t*/\n+/* We keep a hash table, so that we can filter out duplicate additions.\t*/\n+/* Under Win32, we need to do a better job of filtering overlaps, so\t*/\n+/* we resort to sequential search, and pay the price.\t\t\t*/\n+struct roots {\n+\tptr_t r_start;\n+\tptr_t r_end;\n+#\tifndef MSWIN32\n+\t  struct roots * r_next;\n+#\tendif\n+\tGC_bool r_tmp;\n+\t  \t/* Delete before registering new dynamic libraries */\n+};\n+\n+#ifndef MSWIN32\n+    /* Size of hash table index to roots.\t*/\n+#   define LOG_RT_SIZE 6\n+#   define RT_SIZE (1 << LOG_RT_SIZE) /* Power of 2, may be != MAX_ROOT_SETS */\n+#endif\n+\n+/* Lists of all heap blocks and free lists\t*/\n+/* as well as other random data structures\t*/\n+/* that should not be scanned by the\t\t*/\n+/* collector.\t\t\t\t\t*/\n /* These are grouped together in a struct\t*/\n /* so that they can be easily skipped by the\t*/\n /* GC_mark routine.\t\t\t\t*/\n@@ -904,7 +978,10 @@ struct _GC_arrays {\n   word _mem_freed;\n   \t/* Number of explicitly deallocated words of memory\t*/\n   \t/* since last collection.\t\t\t\t*/\n-  \t\n+  mark_proc _mark_procs[MAX_MARK_PROCS];\n+  \t/* Table of user-defined mark procedures.  There is\t*/\n+\t/* a small number of these, which can be referenced\t*/\n+\t/* by DS_PROC mark descriptors.  See gc_mark.h.\t\t*/\n   ptr_t _objfreelist[MAXOBJSZ+1];\n \t\t\t  /* free list for objects */\n   ptr_t _aobjfreelist[MAXOBJSZ+1];\n@@ -986,17 +1063,24 @@ struct _GC_arrays {\n \t\t\t\t/* GC_modws_valid_offsets[i%sizeof(word)] */\n #   endif\n # ifdef STUBBORN_ALLOC\n-      page_hash_table _changed_pages;\n+    page_hash_table _changed_pages;\n         /* Stubborn object pages that were changes since last call to\t*/\n \t/* GC_read_changed.\t\t\t\t\t\t*/\n-      page_hash_table _prev_changed_pages;\n+    page_hash_table _prev_changed_pages;\n         /* Stubborn object pages that were changes before last call to\t*/\n \t/* GC_read_changed.\t\t\t\t\t\t*/\n # endif\n # if defined(PROC_VDB) || defined(MPROTECT_VDB)\n-      page_hash_table _grungy_pages; /* Pages that were dirty at last \t   */\n+    page_hash_table _grungy_pages; /* Pages that were dirty at last \t   */\n \t\t\t\t     /* GC_read_dirty.\t\t\t   */\n # endif\n+# ifdef MPROTECT_VDB\n+    VOLATILE page_hash_table _dirty_pages;\t\n+\t\t\t/* Pages dirtied since last GC_read_dirty. */\n+# endif\n+# ifdef PROC_VDB\n+    page_hash_table _written_pages;\t/* Pages ever dirtied\t*/\n+# endif\n # ifdef LARGE_CONFIG\n #   if CPP_WORDSZ > 32\n #     define MAX_HEAP_SECTS 4096 \t/* overflows at roughly 64 GB\t   */\n@@ -1013,6 +1097,11 @@ struct _GC_arrays {\n     ptr_t _heap_bases[MAX_HEAP_SECTS];\n     \t\t/* Start address of memory regions obtained from kernel. */\n # endif\n+  struct roots _static_roots[MAX_ROOT_SETS];\n+# ifndef MSWIN32\n+    struct roots * _root_index[RT_SIZE];\n+# endif\n+  struct exclusion _excl_table[MAX_EXCLUSIONS];\n   /* Block header index; see gc_headers.h */\n   bottom_index * _all_nils;\n   bottom_index * _top_index [TOP_SZ];\n@@ -1049,6 +1138,7 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_words_finalized GC_arrays._words_finalized\n # define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n # define GC_mem_freed GC_arrays._mem_freed\n+# define GC_mark_procs GC_arrays._mark_procs\n # define GC_heapsize GC_arrays._heapsize\n # define GC_max_heapsize GC_arrays._max_heapsize\n # define GC_words_allocd_before_gc GC_arrays._words_allocd_before_gc\n@@ -1057,11 +1147,20 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # ifdef MSWIN32\n #   define GC_heap_bases GC_arrays._heap_bases\n # endif\n+# define GC_static_roots GC_arrays._static_roots\n+# define GC_root_index GC_arrays._root_index\n+# define GC_excl_table GC_arrays._excl_table\n # define GC_all_nils GC_arrays._all_nils\n # define GC_top_index GC_arrays._top_index\n # if defined(PROC_VDB) || defined(MPROTECT_VDB)\n #   define GC_grungy_pages GC_arrays._grungy_pages\n # endif\n+# ifdef MPROTECT_VDB\n+#   define GC_dirty_pages GC_arrays._dirty_pages\n+# endif\n+# ifdef PROC_VDB\n+#   define GC_written_pages GC_arrays._written_pages\n+# endif\n # ifdef GATHERSTATS\n #   define GC_composite_in_use GC_arrays._composite_in_use\n #   define GC_atomic_in_use GC_arrays._atomic_in_use\n@@ -1073,11 +1172,9 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define beginGC_arrays ((ptr_t)(&GC_arrays))\n # define endGC_arrays (((ptr_t)(&GC_arrays)) + (sizeof GC_arrays))\n \n-GC_API word GC_fo_entries;\n-\n+/* Object kinds: */\n # define MAXOBJKINDS 16\n \n-/* Object kinds: */\n extern struct obj_kind {\n    ptr_t *ok_freelist;\t/* Array of free listheaders for this kind of object */\n    \t\t\t/* Point either to GC_arrays or to storage allocated */\n@@ -1091,8 +1188,14 @@ extern struct obj_kind {\n    \t\t\t/* Add object size in bytes to descriptor \t*/\n    \t\t\t/* template to obtain descriptor.  Otherwise\t*/\n    \t\t\t/* template is used as is.\t\t\t*/\n-   GC_bool ok_init;     /* Clear objects before putting them on the free list. */\n+   GC_bool ok_init;   /* Clear objects before putting them on the free list. */\n } GC_obj_kinds[MAXOBJKINDS];\n+\n+# define endGC_obj_kinds (((ptr_t)(&GC_obj_kinds)) + (sizeof GC_obj_kinds))\n+\n+# define end_gc_area ((ptr_t)endGC_arrays == (ptr_t)(&GC_obj_kinds) ? \\\n+\t\t\tendGC_obj_kinds : endGC_arrays)\n+\n /* Predefined kinds: */\n # define PTRFREE 0\n # define NORMAL  1\n@@ -1108,6 +1211,8 @@ extern struct obj_kind {\n \n extern int GC_n_kinds;\n \n+GC_API word GC_fo_entries;\n+\n extern word GC_n_heap_sects;\t/* Number of separately added heap\t*/\n \t\t\t\t/* sections.\t\t\t\t*/\n \n@@ -1142,17 +1247,19 @@ extern GC_bool GC_is_initialized;\t/* GC_init() has been run.\t*/\n extern GC_bool GC_objects_are_marked;\t/* There are marked objects in  */\n \t\t\t\t\t/* the heap.\t\t\t*/\n \n-extern GC_bool GC_incremental; /* Using incremental/generational collection. */\n+#ifndef SMALL_CONFIG\n+  extern GC_bool GC_incremental;\n+\t\t\t/* Using incremental/generational collection. */\n+#else\n+# define GC_incremental TRUE\n+\t\t\t/* Hopefully allow optimizer to remove some code. */\n+#endif\n \n extern GC_bool GC_dirty_maintained;\n \t\t\t\t/* Dirty bits are being maintained, \t*/\n \t\t\t\t/* either for incremental collection,\t*/\n \t\t\t\t/* or to limit the root set.\t\t*/\n \n-# ifndef PCR\n-    extern ptr_t GC_stackbottom;\t/* Cool end of user stack\t*/\n-# endif\n-\n extern word GC_root_size;\t/* Total size of registered root sections */\n \n extern GC_bool GC_debugging_started;\t/* GC_debug_malloc has been called. */ \n@@ -1216,7 +1323,8 @@ void GC_mark_from_mark_stack(); /* Mark from everything on the mark stack. */\n \t\t\t\t/* Return after about one pages worth of   */\n \t\t\t\t/* work.\t\t\t\t   */\n GC_bool GC_mark_stack_empty();\n-GC_bool GC_mark_some();\t/* Perform about one pages worth of marking\t*/\n+GC_bool GC_mark_some(/* cold_gc_frame */);\n+\t\t\t/* Perform about one pages worth of marking\t*/\n \t\t\t/* work of whatever kind is needed.  Returns\t*/\n \t\t\t/* quickly if no collection is in progress.\t*/\n \t\t\t/* Return TRUE if mark phase finished.\t\t*/\n@@ -1238,7 +1346,31 @@ void GC_push_dirty(/*b,t*/);      /* Push all possibly changed\t \t*/\n \t\t\t\t/* on the third arg.\t\t\t*/\n void GC_push_all_stack(/*b,t*/);    /* As above, but consider\t\t*/\n \t\t\t\t    /*  interior pointers as valid  \t*/\n-void GC_push_roots(/* GC_bool all */); /* Push all or dirty roots.\t*/\n+void GC_push_all_eager(/*b,t*/);    /* Same as GC_push_all_stack, but   */\n+\t\t\t\t    /* ensures that stack is scanned\t*/\n+\t\t\t\t    /* immediately, not just scheduled  */\n+\t\t\t\t    /* for scanning.\t\t\t*/\n+#ifndef THREADS\n+  void GC_push_all_stack_partially_eager(/* bottom, top, cold_gc_frame */);\n+\t\t\t/* Similar to GC_push_all_eager, but only the\t*/\n+\t\t\t/* part hotter than cold_gc_frame is scanned\t*/\n+\t\t\t/* immediately.  Needed to endure that callee-\t*/\n+\t\t\t/* save registers are not missed.\t\t*/\n+#else\n+  /* In the threads case, we push part of the current thread stack\t*/\n+  /* with GC_push_all_eager when we push the registers.  This gets the  */\n+  /* callee-save registers that may disappear.  The remainder of the\t*/\n+  /* stacks are scheduled for scanning in *GC_push_other_roots, which\t*/\n+  /* is thread-package-specific.\t\t\t\t\t*/\n+#endif\n+void GC_push_current_stack(/* ptr_t cold_gc_frame */);\n+\t\t\t/* Push enough of the current stack eagerly to\t*/\n+\t\t\t/* ensure that callee-save registers saved in\t*/\n+\t\t\t/* GC frames are scanned.\t\t\t*/\n+\t\t\t/* In the non-threads case, schedule entire\t*/\n+\t\t\t/* stack for scanning.\t\t\t\t*/\n+void GC_push_roots(/* GC_bool all, ptr_t cold_gc_frame */);\n+\t\t\t/* Push all or dirty roots.\t*/\n extern void (*GC_push_other_roots)();\n \t\t\t/* Push system or application specific roots\t*/\n \t\t\t/* onto the mark stack.  In some environments\t*/\n@@ -1403,7 +1535,7 @@ GC_bool GC_collect_or_expand(/* needed_blocks */);\n \t\t\t\t/* blocks available.  Should be called\t*/\n \t\t\t\t/* until the blocks are available or\t*/\n \t\t\t\t/* until it fails by returning FALSE.\t*/\n-void GC_init();\t\t\t/* Initialize collector.\t\t*/\n+GC_API void GC_init();\t\t/* Initialize collector.\t\t*/\n void GC_collect_a_little_inner(/* int n */);\n \t\t\t\t/* Do n units worth of garbage \t\t*/\n \t\t\t\t/* collection work, if appropriate.\t*/\n@@ -1491,7 +1623,7 @@ void GC_write_hint(/* struct hblk * h  */);\n void GC_dirty_init();\n \n /* Slow/general mark bit manipulation: */\n-GC_bool GC_is_marked();\n+GC_API GC_bool GC_is_marked();\n void GC_clear_mark_bit();\n void GC_set_mark_bit();\n "}]}