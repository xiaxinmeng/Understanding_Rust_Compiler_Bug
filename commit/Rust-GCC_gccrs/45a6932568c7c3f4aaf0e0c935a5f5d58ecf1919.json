{"sha": "45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVhNjkzMjU2OGM3YzNmNGFhZjBlMGM5MzVhNWY1ZDU4ZWNmMTkxOQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-03-03T08:40:24Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-03-03T08:40:24Z"}, "message": "re PR fortran/48820 (TR 29113: Implement parts needed for MPI 3)\n\n2012-03-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/48820\n        * decl.c (gfc_match_decl_type_spec): Support type(*).\n        (gfc_verify_c_interop): Allow type(*).\n        * dump-parse-tree.c (show_typespec): Handle type(*).\n        * expr.c (gfc_copy_expr): Ditto.\n        * interface.c (compare_type_rank, compare_parameter,\n        compare_actual_formal, gfc_procedure_use): Ditto.\n        * libgfortran.h (bt): Add BT_ASSUMED.\n        * misc.c (gfc_basic_typename, gfc_typename): Handle type(*).\n        * module.c (bt_types): Ditto.\n        * resolve.c (assumed_type_expr_allowed): New static variable.\n        (resolve_actual_arglist, resolve_variable, resolve_symbol):\n        Handle type(*). \n        * trans-expr.c (gfc_conv_procedure_call): Ditto.\n        * trans-types.c (gfc_typenode_for_spec, gfc_get_dtype): Ditto.\n\n2012-03-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/48820\n        * gfortran.dg/assumed_type_1.f90: New.\n        * gfortran.dg/assumed_type_2.f90: New.\n        * gfortran.dg/assumed_type_3.f90: New.\n        * gfortran.dg/assumed_type_4.f90: New.\n\nFrom-SVN: r184852", "tree": {"sha": "0c29d6bc5a187e73c40b9223ee82a99a407d2889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c29d6bc5a187e73c40b9223ee82a99a407d2889"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0e8830c542d211c6fe1fe3c49a814a46ffc9617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e8830c542d211c6fe1fe3c49a814a46ffc9617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e8830c542d211c6fe1fe3c49a814a46ffc9617"}], "stats": {"total": 532, "additions": 524, "deletions": 8}, "files": [{"sha": "401d66dab813dbd96f042dbdf46f9920a678b0ec", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -1,3 +1,21 @@\n+2012-03-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/48820\n+\t* decl.c (gfc_match_decl_type_spec): Support type(*).\n+\t(gfc_verify_c_interop): Allow type(*).\n+\t* dump-parse-tree.c (show_typespec): Handle type(*).\n+\t* expr.c (gfc_copy_expr): Ditto.\n+\t* interface.c (compare_type_rank, compare_parameter,\n+\tcompare_actual_formal, gfc_procedure_use): Ditto.\n+\t* libgfortran.h (bt): Add BT_ASSUMED.\n+\t* misc.c (gfc_basic_typename, gfc_typename): Handle type(*).\n+\t* module.c (bt_types): Ditto.\n+\t* resolve.c (assumed_type_expr_allowed): New static variable.\n+\t(resolve_actual_arglist, resolve_variable, resolve_symbol):\n+\tHandle type(*). \n+\t* trans-expr.c (gfc_conv_procedure_call): Ditto.\n+\t* trans-types.c (gfc_typenode_for_spec, gfc_get_dtype): Ditto.\n+\n 2012-03-02  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52325"}, {"sha": "bdb8c39acb96d0ffa2dfe8e0ad1eeb2d2589812f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -2600,9 +2600,31 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n     }\n \n \n-  m = gfc_match (\" type ( %n\", name);\n+  m = gfc_match (\" type (\");\n   matched_type = (m == MATCH_YES);\n-  \n+  if (matched_type)\n+    {\n+      gfc_gobble_whitespace ();\n+      if (gfc_peek_ascii_char () == '*')\n+\t{\n+\t  if ((m = gfc_match (\"*)\")) != MATCH_YES)\n+\t    return m;\n+\t  if (gfc_current_state () == COMP_DERIVED)\n+\t    {\n+\t      gfc_error (\"Assumed type at %C is not allowed for components\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  if (gfc_notify_std (GFC_STD_F2008_TS, \"TS 29113: Assumed type \"\n+\t\t\t  \"at %C\") == FAILURE)\n+\t    return MATCH_ERROR;\n+\t  ts->type = BT_ASSUMED;\n+\t  return MATCH_YES;\n+\t}\n+\n+      m = gfc_match (\"%n\", name);\n+      matched_type = (m == MATCH_YES);\n+    }\n+\n   if ((matched_type && strcmp (\"integer\", name) == 0)\n       || (!matched_type && gfc_match (\" integer\") == MATCH_YES))\n     {\n@@ -3854,9 +3876,9 @@ gfc_verify_c_interop (gfc_typespec *ts)\n \t   ? SUCCESS : FAILURE;\n   else if (ts->type == BT_CLASS)\n     return FAILURE;\n-  else if (ts->is_c_interop != 1)\n+  else if (ts->is_c_interop != 1 && ts->type != BT_ASSUMED)\n     return FAILURE;\n-  \n+\n   return SUCCESS;\n }\n "}, {"sha": "7f1d28fd7c973e116c539da47bb8b5806926206c", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -94,6 +94,12 @@ show_indent (void)\n static void\n show_typespec (gfc_typespec *ts)\n {\n+  if (ts->type == BT_ASSUMED)\n+    {\n+      fputs (\"(TYPE(*))\", dumpfile);\n+      return;\n+    }\n+\n   fprintf (dumpfile, \"(%s \", gfc_basic_typename (ts->type));\n \n   switch (ts->type)"}, {"sha": "e6a9c885f0236cc6a6ce28e791133ac26bc7421a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -336,6 +336,7 @@ gfc_copy_expr (gfc_expr *p)\n \tcase BT_LOGICAL:\n \tcase BT_DERIVED:\n \tcase BT_CLASS:\n+\tcase BT_ASSUMED:\n \t  break;\t\t/* Already done.  */\n \n \tcase BT_PROCEDURE:"}, {"sha": "298ae23d2608df6909be1b2cfa6eeb00e3b9db54", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -514,7 +514,8 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n   if (r1 != r2)\n     return 0;\t\t\t/* Ranks differ.  */\n \n-  return gfc_compare_types (&s1->ts, &s2->ts);\n+  return gfc_compare_types (&s1->ts, &s2->ts)\n+\t || s1->ts.type == BT_ASSUMED || s2->ts.type == BT_ASSUMED; \n }\n \n \n@@ -1697,6 +1698,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)\n       && actual->ts.type != BT_HOLLERITH\n+      && formal->ts.type != BT_ASSUMED\n       && !gfc_compare_types (&formal->ts, &actual->ts)\n       && !(formal->ts.type == BT_DERIVED && actual->ts.type == BT_CLASS\n \t   && gfc_compare_derived_types (formal->ts.u.derived, \n@@ -2274,6 +2276,27 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t\t      is_elemental, where))\n \treturn 0;\n \n+      /* TS 29113, 6.3p2.  */\n+      if (f->sym->ts.type == BT_ASSUMED\n+\t  && (a->expr->ts.type == BT_DERIVED\n+\t      || (a->expr->ts.type == BT_CLASS && CLASS_DATA (a->expr))))\n+\t{\n+\t  gfc_namespace *f2k_derived;\n+\n+\t  f2k_derived = a->expr->ts.type == BT_DERIVED\n+\t\t\t? a->expr->ts.u.derived->f2k_derived\n+\t\t\t: CLASS_DATA (a->expr)->ts.u.derived->f2k_derived;\n+\n+\t  if (f2k_derived\n+\t      && (f2k_derived->finalizers || f2k_derived->tb_sym_root))\n+\t    {\n+\t      gfc_error (\"Actual argument at %L to assumed-type dummy is of \"\n+\t\t\t \"derived type with type-bound or FINAL procedures\",\n+\t\t\t &a->expr->where);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+\n       /* Special case for character arguments.  For allocatable, pointer\n \t and assumed-shape dummies, the string length needs to match\n \t exactly.  */\n@@ -2885,7 +2908,6 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n void\n gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n {\n-\n   /* Warn about calls with an implicit interface.  Special case\n      for calling a ISO_C_BINDING becase c_loc and c_funloc\n      are pseudo-unknown.  Additionally, warn about procedures not\n@@ -2938,6 +2960,16 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t      break;\n \t    }\n \n+\t  /* TS 29113, 6.2.  */\n+\t  if (a->expr && a->expr->ts.type == BT_ASSUMED\n+\t      && sym->intmod_sym_id != ISOCBINDING_LOC)\n+\t    {\n+\t      gfc_error (\"Assumed-type argument %s at %L requires an explicit \"\n+\t\t\t \"interface\", a->expr->symtree->n.sym->name,\n+\t\t\t &a->expr->where);\n+\t      break;\n+\t    }\n+\n \t  /* F2008, C1303 and C1304.  */\n \t  if (a->expr\n \t      && (a->expr->ts.type == BT_DERIVED || a->expr->ts.type == BT_CLASS)"}, {"sha": "62afc21e12e1fd6bf09d80e9ea8d0a21fda5c30b", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -129,6 +129,7 @@ libgfortran_stat_codes;\n    used in the run-time library for IO.  */\n typedef enum\n { BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,\n-  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID\n+  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,\n+  BT_ASSUMED\n }\n bt;"}, {"sha": "012364ae774c09aa100b1f6ecff50e52e2c17b03", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -107,6 +107,9 @@ gfc_basic_typename (bt type)\n     case BT_UNKNOWN:\n       p = \"UNKNOWN\";\n       break;\n+    case BT_ASSUMED:\n+      p = \"TYPE(*)\";\n+      break;\n     default:\n       gfc_internal_error (\"gfc_basic_typename(): Undefined type\");\n     }\n@@ -157,6 +160,9 @@ gfc_typename (gfc_typespec *ts)\n       sprintf (buffer, \"CLASS(%s)\",\n \t       ts->u.derived->components->ts.u.derived->name);\n       break;\n+    case BT_ASSUMED:\n+      sprintf (buffer, \"TYPE(*)\");\n+      break;\n     case BT_PROCEDURE:\n       strcpy (buffer, \"PROCEDURE\");\n       break;"}, {"sha": "36ef4f8a088b6ba461008009d6e030f1d199d795", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -2244,6 +2244,7 @@ static const mstring bt_types[] = {\n     minit (\"PROCEDURE\", BT_PROCEDURE),\n     minit (\"UNKNOWN\", BT_UNKNOWN),\n     minit (\"VOID\", BT_VOID),\n+    minit (\"ASSUMED\", BT_ASSUMED),\n     minit (NULL, -1)\n };\n "}, {"sha": "618c6f56c8c08ae3d5ab0676686207388b4d08c9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -63,6 +63,8 @@ static code_stack *cs_base = NULL;\n static int forall_flag;\n static int do_concurrent_flag;\n \n+static bool assumed_type_expr_allowed = false;\n+\n /* Nonzero if we're inside a OpenMP WORKSHARE or PARALLEL WORKSHARE block.  */\n \n static int omp_workshare_flag;\n@@ -1597,6 +1599,8 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n   gfc_expr *e;\n   int save_need_full_assumed_size;\n \n+  assumed_type_expr_allowed = true;\n+\n   for (; arg; arg = arg->next)\n     {\n       e = arg->expr;\n@@ -1829,6 +1833,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n           return FAILURE;\n         }\n     }\n+  assumed_type_expr_allowed = true;\n \n   return SUCCESS;\n }\n@@ -5057,6 +5062,24 @@ resolve_variable (gfc_expr *e)\n     return FAILURE;\n   sym = e->symtree->n.sym;\n \n+  /* TS 29113, 407b.  */\n+  if (e->ts.type == BT_ASSUMED && !assumed_type_expr_allowed)\n+    {\n+      gfc_error (\"Invalid expression with assumed-type variable %s at %L\",\n+\t\t sym->name, &e->where);\n+      return FAILURE;\n+    }\n+\n+  /* TS 29113, 407b.  */\n+  if (e->ts.type == BT_ASSUMED && e->ref\n+      && !(e->ref->type == REF_ARRAY && e->ref->u.ar.type == AR_FULL\n+           && e->ref->next == NULL))\n+    {\n+      gfc_error (\"Assumed-type variable %s with designator at %L\",\n+                 sym->name, &e->ref->u.ar.where);\n+      return FAILURE;\n+    }\n+\n   /* If this is an associate-name, it may be parsed with an array reference\n      in error even though the target is scalar.  Fail directly in this case.  */\n   if (sym->assoc && !sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)\n@@ -12435,6 +12458,31 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n \n+  if (sym->ts.type == BT_ASSUMED)\n+    { \n+      /* TS 29113, C407a.  */\n+      if (!sym->attr.dummy)\n+\t{\n+\t  gfc_error (\"Assumed type of variable %s at %L is only permitted \"\n+\t\t     \"for dummy variables\", sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+      if (sym->attr.allocatable || sym->attr.codimension\n+\t  || sym->attr.pointer || sym->attr.value)\n+    \t{\n+\t  gfc_error (\"Assumed-type variable %s at %L may not have the \"\n+\t\t     \"ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+      if (sym->attr.dimension && sym->as->type == AS_EXPLICIT)\n+\t{\n+\t  gfc_error (\"Assumed-type variable %s at %L shall not be an \"\n+\t\t     \"explicit-shape array\", sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+    }\n+\n   /* If the symbol is marked as bind(c), verify it's type and kind.  Do not\n      do this for something that was implicitly typed because that is handled\n      in gfc_set_default_type.  Handle dummy arguments and procedure"}, {"sha": "d69399ce08fcf5fbc3b8088329b92722599f2fa5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -3619,7 +3619,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t&& CLASS_DATA (e)->attr.dimension)\n \t\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n \n-\t\t  if (fsym && fsym->ts.type == BT_DERIVED\n+\t\t  if (fsym && (fsym->ts.type == BT_DERIVED\n+\t\t\t       || fsym->ts.type == BT_ASSUMED)\n \t\t      && e->ts.type == BT_CLASS\n \t\t      && !CLASS_DATA (e)->attr.dimension\n \t\t      && !CLASS_DATA (e)->attr.codimension)"}, {"sha": "6ff1d33957bc877a7c8557150657301fe2bef6af", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -1118,6 +1118,7 @@ gfc_typenode_for_spec (gfc_typespec * spec)\n         }\n       break;\n     case BT_VOID:\n+    case BT_ASSUMED:\n       /* This is for the second arg to c_f_pointer and c_f_procpointer\n          of the iso_c_binding module, to accept any ptr type.  */\n       basetype = ptr_type_node;\n@@ -1416,6 +1417,10 @@ gfc_get_dtype (tree type)\n       n = BT_CHARACTER;\n       break;\n \n+    case POINTER_TYPE:\n+      n = BT_ASSUMED;\n+      break;\n+\n     default:\n       /* TODO: Don't do dtype for temporary descriptorless arrays.  */\n       /* We can strange array types for temporary arrays.  */"}, {"sha": "e95a0ee43d37718221233233a2c2e1c211a9a237", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -1,3 +1,11 @@\n+2012-03-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/48820\n+\t* gfortran.dg/assumed_type_1.f90: New.\n+\t* gfortran.dg/assumed_type_2.f90: New.\n+\t* gfortran.dg/assumed_type_3.f90: New.\n+\t* gfortran.dg/assumed_type_4.f90: New.\n+\n 2012-03-02  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/49486"}, {"sha": "c49114669974574cedaaa0d85ed40032a44c9173", "filename": "gcc/testsuite/gfortran.dg/assumed_type_1.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_1.f90?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+!\n+! PR fortran/48820\n+!\n+! Test TYPE(*)\n+!\n+! Based on a contributed test case by Walter Spector\n+!\n+module mpi_interface\n+  implicit none\n+\n+  interface mpi_send\n+    subroutine MPI_Send (buf, count, datatype, dest, tag, comm, ierr)\n+      type(*), intent(in) :: buf(:)\n+      integer, intent(in) :: count\n+      integer, intent(in) :: datatype\n+      integer, intent(in) :: dest\n+      integer, intent(in) :: tag\n+      integer, intent(in) :: comm\n+      integer, intent(out):: ierr\n+    end subroutine\n+  end interface\n+\n+  interface mpi_send2\n+    subroutine MPI_Send2 (buf, count, datatype, dest, tag, comm, ierr)\n+      type(*), intent(in) :: buf(*)\n+      integer, intent(in) :: count\n+      integer, intent(in) :: datatype\n+      integer, intent(in) :: dest\n+      integer, intent(in) :: tag\n+      integer, intent(in) :: comm\n+      integer, intent(out):: ierr\n+    end subroutine\n+  end interface\n+\n+end module\n+\n+use mpi_interface\n+  real :: a(3)\n+  integer :: b(3)\n+  call foo(a)\n+  call foo(b)\n+  call foo(a(1:2))\n+  call foo(b(1:2))\n+  call MPI_Send(a, 1, 1,1,1,j,i)\n+  call MPI_Send(b, 1, 1,1,1,j,i)\n+  call MPI_Send2(a, 1, 1,1,1,j,i)\n+  call MPI_Send2(b, 1, 1,1,1,j,i)\n+contains\n+    subroutine foo(x)\n+    type(*):: x(*)\n+    call MPI_Send(x, 1, 1,1,1,j,i)\n+    call MPI_Send2(x, 1, 1,1,1,j,i)\n+  end\n+end\n+\n+! { dg-final { cleanup-modules \"mpi_interface\" } }"}, {"sha": "b88717c0f05b41bf98724839785c94c5c814aace", "filename": "gcc/testsuite/gfortran.dg/assumed_type_2.f90", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_2.f90?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -0,0 +1,181 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/48820\n+!\n+! Test TYPE(*)\n+!\n+\n+module mod\n+  use iso_c_binding, only: c_loc, c_ptr, c_bool\n+  implicit none\n+  interface my_c_loc\n+    function my_c_loc1(x) bind(C)\n+      import c_ptr\n+      type(*) :: x\n+      type(c_ptr) :: my_c_loc1\n+    end function\n+    function my_c_loc2(x) bind(C)\n+      import c_ptr\n+      type(*) :: x(*)\n+      type(c_ptr) :: my_c_loc2\n+    end function\n+  end interface my_c_loc\n+contains\n+  subroutine sub_scalar (arg1, presnt)\n+     type(*), target, optional :: arg1\n+     logical :: presnt\n+     type(c_ptr) :: cpt\n+     if (presnt .neqv. present (arg1)) call abort ()\n+     cpt = c_loc (arg1)\n+  end subroutine sub_scalar\n+\n+  subroutine sub_array_shape (arg2, lbounds, ubounds)\n+     type(*), target :: arg2(:,:)\n+     type(c_ptr) :: cpt\n+     integer :: lbounds(2), ubounds(2)\n+     if (any (lbound(arg2) /= lbounds)) call abort ()\n+     if (any (ubound(arg2) /= ubounds)) call abort ()\n+     if (any (shape(arg2) /= ubounds-lbounds+1)) call abort ()\n+     if (size(arg2) /= product (ubounds-lbounds+1)) call abort ()\n+     if (rank (arg2) /= 2) call abort ()\n+!     if (.not. is_continuous (arg2)) call abort () !<< Not yet implemented\n+!     cpt = c_loc (arg2) ! << FIXME: Valid since TS29113\n+     call sub_array_assumed (arg2)\n+  end subroutine sub_array_shape\n+\n+  subroutine sub_array_assumed (arg3)\n+     type(*), target :: arg3(*)\n+     type(c_ptr) :: cpt\n+     cpt = c_loc (arg3)\n+  end subroutine sub_array_assumed\n+end module\n+\n+use mod\n+use iso_c_binding, only: c_int, c_null_ptr\n+implicit none\n+type t1\n+  integer :: a\n+end type t1\n+type :: t2\n+  sequence\n+  integer :: b\n+end type t2\n+type, bind(C) :: t3\n+  integer(c_int) :: c\n+end type t3\n+\n+integer            :: scalar_int\n+real, allocatable  :: scalar_real_alloc\n+character, pointer :: scalar_char_ptr\n+\n+integer            :: array_int(3)\n+real, allocatable  :: array_real_alloc(:,:)\n+character, pointer :: array_char_ptr(:,:)\n+\n+type(t1)              :: scalar_t1\n+type(t2), allocatable :: scalar_t2_alloc\n+type(t3), pointer     :: scalar_t3_ptr\n+\n+type(t1)              :: array_t1(4)\n+type(t2), allocatable :: array_t2_alloc(:,:)\n+type(t3), pointer     :: array_t3_ptr(:,:)\n+\n+class(t1), allocatable :: scalar_class_t1_alloc\n+class(t1), pointer     :: scalar_class_t1_ptr\n+\n+class(t1), allocatable :: array_class_t1_alloc(:,:)\n+class(t1), pointer     :: array_class_t1_ptr(:,:)\n+\n+scalar_char_ptr => null()\n+scalar_t3_ptr => null()\n+\n+call sub_scalar (presnt=.false.)\n+call sub_scalar (scalar_real_alloc, .false.)\n+call sub_scalar (scalar_char_ptr, .false.)\n+call sub_scalar (null (), .false.)\n+call sub_scalar (scalar_t2_alloc, .false.)\n+call sub_scalar (scalar_t3_ptr, .false.)\n+\n+allocate (scalar_real_alloc, scalar_char_ptr, scalar_t3_ptr)\n+allocate (scalar_class_t1_alloc, scalar_class_t1_ptr, scalar_t2_alloc)\n+allocate (array_real_alloc(3:5,2:4), array_char_ptr(-2:2,2))\n+allocate (array_t2_alloc(3:5,2:4), array_t3_ptr(-2:2,2))\n+allocate (array_class_t1_alloc(3,3), array_class_t1_ptr(4,4))\n+\n+call sub_scalar (scalar_int, .true.)\n+call sub_scalar (scalar_real_alloc, .true.)\n+call sub_scalar (scalar_char_ptr, .true.)\n+call sub_scalar (array_int(2), .true.)\n+call sub_scalar (array_real_alloc(3,2), .true.)\n+call sub_scalar (array_char_ptr(0,1), .true.)\n+call sub_scalar (scalar_t1, .true.)\n+call sub_scalar (scalar_t2_alloc, .true.)\n+call sub_scalar (scalar_t3_ptr, .true.)\n+call sub_scalar (array_t1(2), .true.)\n+call sub_scalar (array_t2_alloc(3,2), .true.)\n+call sub_scalar (array_t3_ptr(0,1), .true.)\n+call sub_scalar (array_class_t1_alloc(2,1), .true.)\n+call sub_scalar (array_class_t1_ptr(3,3), .true.)\n+\n+call sub_array_assumed (array_int)\n+call sub_array_assumed (array_real_alloc)\n+call sub_array_assumed (array_char_ptr)\n+call sub_array_assumed (array_t1)\n+call sub_array_assumed (array_t2_alloc)\n+call sub_array_assumed (array_t3_ptr)\n+call sub_array_assumed (array_class_t1_alloc)\n+call sub_array_assumed (array_class_t1_ptr)\n+\n+call sub_array_shape (array_real_alloc, [1,1], shape(array_real_alloc))\n+call sub_array_shape (array_char_ptr, [1,1], shape(array_char_ptr))\n+call sub_array_shape (array_t2_alloc, [1,1], shape(array_t2_alloc))\n+call sub_array_shape (array_t3_ptr, [1,1], shape(array_t3_ptr))\n+call sub_array_shape (array_class_t1_alloc, [1,1], shape(array_class_t1_alloc))\n+call sub_array_shape (array_class_t1_ptr, [1,1], shape(array_class_t1_ptr))\n+\n+deallocate (scalar_char_ptr, scalar_class_t1_ptr, array_char_ptr)\n+deallocate (array_class_t1_ptr, array_t3_ptr)\n+\n+end\n+\n+! { dg-final { cleanup-modules \"mod\" } }\n+\n+! { dg-final { scan-tree-dump-times \"sub_scalar .0B,\"  2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_real_alloc,\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_char_ptr,\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_t2_alloc,\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .scalar_t3_ptr\" 2 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_int,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_t1,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&array_int.1.,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_t1,\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(real.kind=4..0:. . restrict\\\\) array_real_alloc.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(character.kind=1..0:..1:1. .\\\\) array_char_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t2.0:. . restrict\\\\) array_t2_alloc.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t3.0:. .\\\\) array_t3_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) array_class_t1_alloc._data.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) array_class_t1_ptr._data.dat\" 1 \"original\" } }a\n+\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(D\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \" = _gfortran_internal_pack \\\\(&parm\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(&array_int\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(real\\\\(kind=4\\\\).0:. . restrict\\\\) array_real_alloc.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \" = _gfortran_internal_pack \\\\(&array_char_ptr\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\.data = \\\\(void .\\\\) &array_t1.0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t1.0:. .\\\\) parm\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t2.0:. . restrict\\\\) array_t2_alloc.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t3.0:. .\\\\) array_t3_ptr.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t1.0:. . restrict\\\\) array_class_t1_alloc._data.data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_assumed \\\\(\\\\(struct t1.0:. .\\\\) array_class_t1_ptr._data.data\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"sub_array_shape \\\\(&array_real_alloc,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_shape \\\\(&array_char_ptr,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_shape \\\\(&array_t2_alloc,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_shape \\\\(&array_t3_ptr,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_shape \\\\(&array_class_t1_alloc._data,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_array_shape \\\\(&array_class_t1_ptr._data,\" 1 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "849769197eee09b2b8277f06a92785c533fe9c99", "filename": "gcc/testsuite/gfortran.dg/assumed_type_3.f90", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_3.f90?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -0,0 +1,119 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/48820\n+!\n+! Test TYPE(*)\n+\n+subroutine one(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+  type(*), value :: a\n+end subroutine one\n+\n+subroutine two(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+  type(*), pointer :: a\n+end subroutine two\n+\n+subroutine three(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+  type(*), allocatable :: a\n+end subroutine three\n+\n+subroutine four(a) ! { dg-error \"may not have the ALLOCATABLE, CODIMENSION, POINTER or VALUE attribute\" }\n+  type(*)  :: a[*]\n+end subroutine four\n+\n+subroutine five(a) ! { dg-error \"shall not be an explicit-shape array\" }\n+  type(*) :: a(3)\n+end subroutine five\n+\n+subroutine six()\n+  type(*) :: nodum ! { dg-error \"is only permitted for dummy variables\" }\n+end subroutine six\n+\n+subroutine seven(y)\n+ type(*) :: y(:)\n+ call a7(y(3:5)) ! { dg-error \"Assumed-type variable y with designator\" }\n+contains\n+ subroutine a7(x)\n+   type(*) :: x(*)\n+ end subroutine a7\n+end subroutine seven\n+\n+subroutine eight()\n+  type t\n+    type(*) :: x ! { dg-error \"is not allowed for components\" }\n+  end type t\n+end subroutine eight\n+\n+subroutine nine()\n+  interface one\n+    subroutine okay(x)\n+      type(*) :: x\n+    end subroutine okay\n+    subroutine okay2(x)\n+      type(*) :: x(*)\n+    end subroutine okay2\n+    subroutine okay2(x,y)\n+      integer :: x\n+      type(*) :: y\n+    end subroutine okay2\n+  end interface\n+  interface two\n+    subroutine okok1(x)\n+      type(*) :: x\n+    end subroutine okok1\n+    subroutine okok2(x)\n+      integer :: x(*)\n+    end subroutine okok2\n+  end interface\n+  interface three\n+    subroutine ambig1(x)\n+      type(*) :: x\n+    end subroutine ambig1\n+    subroutine ambig2(x)\n+      integer :: x\n+    end subroutine ambig2 ! { dg-error \"Ambiguous interfaces 'ambig2' and 'ambig1' in generic interface 'three'\" }\n+  end interface\n+end subroutine nine\n+\n+subroutine ten()\n+ interface\n+   subroutine bar()\n+   end subroutine\n+ end interface\n+ type t\n+ contains\n+   procedure, nopass :: proc => bar\n+ end type\n+ type(t) :: xx\n+ call sub(xx) ! { dg-error \"is of derived type with type-bound or FINAL procedures\" }\n+contains\n+  subroutine sub(a)\n+    type(*) :: a\n+  end subroutine sub\n+end subroutine ten\n+\n+subroutine eleven(x)\n+  external bar\n+  type(*) :: x\n+  call bar(x) ! { dg-error \"Assumed-type argument x at .1. requires an explicit interface\" }\n+end subroutine eleven\n+\n+subroutine twelf(x)\n+  type(*) :: x\n+  call bar(x)\n+contains\n+  subroutine bar(x)\n+    integer :: x ! { dg-error \"Type mismatch in argument\" }\n+  end subroutine bar\n+end subroutine twelf\n+\n+subroutine thirteen(x, y)\n+  type(*) :: x\n+  integer :: y(:)\n+  print *, ubound(y, dim=x) ! { dg-error \"must be INTEGER\" }\n+end subroutine thirteen\n+\n+subroutine fourteen(x)\n+  type(*) :: x\n+  x = x ! { dg-error \"Invalid expression with assumed-type variable\" }\n+end subroutine fourteen"}, {"sha": "0b8faa84587a4cd21010e16d47255573a4564b7f", "filename": "gcc/testsuite/gfortran.dg/assumed_type_4.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_4.f90?ref=45a6932568c7c3f4aaf0e0c935a5f5d58ecf1919", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n+! PR fortran/48820\n+!\n+! Test TYPE(*)\n+\n+subroutine one(a) ! { dg-error \"TS 29113: Assumed type\" }\n+  type(*)  :: a\n+end subroutine one"}]}