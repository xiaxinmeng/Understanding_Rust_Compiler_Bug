{"sha": "29742ba4f4eff92353b98ea0a7a039053ccb8de7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk3NDJiYTRmNGVmZjkyMzUzYjk4ZWEwYTdhMDM5MDUzY2NiOGRlNw==", "commit": {"author": {"name": "Hartmut Penner", "email": "hpenner@de.ibm.com", "date": "2002-11-26T15:26:40Z"}, "committer": {"name": "Hartmut Penner", "email": "hpenner@gcc.gnu.org", "date": "2002-11-26T15:26:40Z"}, "message": "s390.md (literal_pool_64, [...]): New insns.\n\n \t* config/s390/s390.md (literal_pool_64, literal_pool_31 ): New\n\tinsns.\n\t* config/s390/s390.c (struct machine_function): Introduction of\n\tstruct machine_function.\n\t* config/s390/s390-protos.h (s390_output_constant_pool): Changed\n\tprototype.\n\nFrom-SVN: r59515", "tree": {"sha": "f5059f38fb08f04050a76a8d8f6b5a33035d2122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5059f38fb08f04050a76a8d8f6b5a33035d2122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29742ba4f4eff92353b98ea0a7a039053ccb8de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29742ba4f4eff92353b98ea0a7a039053ccb8de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29742ba4f4eff92353b98ea0a7a039053ccb8de7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29742ba4f4eff92353b98ea0a7a039053ccb8de7/comments", "author": null, "committer": null, "parents": [{"sha": "f41115930523b329a72f15cac484434e1b66033b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41115930523b329a72f15cac484434e1b66033b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f41115930523b329a72f15cac484434e1b66033b"}], "stats": {"total": 270, "additions": 156, "deletions": 114}, "files": [{"sha": "fd2047ecfc53a54813837f6a3c7673f5a42aab47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29742ba4f4eff92353b98ea0a7a039053ccb8de7", "patch": "@@ -1,3 +1,12 @@\n+2002-11-26  Hartmut Penner  <hpenner@de.ibm.com>\n+\n+\t* config/s390/s390.md (literal_pool_64, literal_pool_31 ): New\n+\tinsns.\n+\t* config/s390/s390.c (struct machine_function): Introduction of\n+\tstruct machine_function.\n+\t* config/s390/s390-protos.h (s390_output_constant_pool): Changed \n+\tprototype.\n+\t\n 2002-11-26  Jakub Jelinek  <jakub@redhat.com>\n \n \t* varasm.c (output_constant_pool): For pool constants in mergeable"}, {"sha": "deecef6b9695cebd84de3e49833467689faafe12", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=29742ba4f4eff92353b98ea0a7a039053ccb8de7", "patch": "@@ -70,7 +70,7 @@ extern rtx s390_return_addr_rtx PARAMS ((int, rtx));\n extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void s390_output_constant_pool PARAMS ((FILE *));\n+extern void s390_output_constant_pool PARAMS ((rtx, rtx));\n extern void s390_trampoline_template PARAMS ((FILE *));\n extern void s390_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern rtx s390_gen_rtx_const_DI PARAMS ((int, int));"}, {"sha": "3332d0f5746aaa5f034da5639d0f1711af37e493", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 119, "deletions": 105, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=29742ba4f4eff92353b98ea0a7a039053ccb8de7", "patch": "@@ -115,17 +115,22 @@ struct s390_address\n   int pointer;\n };\n \n-/* Structure containing information for prologue and epilogue.  */ \n+/* Define the structure for the machine field in struct function.  */\n \n-struct s390_frame\n+struct machine_function GTY(())\n {\n-  int frame_pointer_p;\n+  /* Label of start of initial literal pool.  */\n+  rtx literal_pool_label;\n+\n+  /* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */\n   int save_fprs_p;\n+\n+  /* Number of first and last gpr to be saved, restored.  */\n   int first_save_gpr;\n   int first_restore_gpr;\n   int last_save_gpr;\n-  int arg_frame_offset;\n \n+  /* Size of stack frame.  */\n   HOST_WIDE_INT frame_size;\n };\n \n@@ -146,13 +151,13 @@ static void replace_base_register_ref PARAMS ((rtx *, rtx));\n static void s390_optimize_prolog PARAMS ((int));\n static bool s390_fixup_clobbered_return_reg PARAMS ((rtx));\n static int find_unused_clobbered_reg PARAMS ((void));\n-static void s390_frame_info PARAMS ((struct s390_frame *));\n+static void s390_frame_info PARAMS ((void));\n static rtx save_fpr PARAMS ((rtx, int, int));\n static rtx restore_fpr PARAMS ((rtx, int, int));\n static rtx save_gprs PARAMS ((rtx, int, int, int));\n static rtx restore_gprs PARAMS ((rtx, int, int, int));\n static int s390_function_arg_size PARAMS ((enum machine_mode, tree));\n-\n+static struct machine_function * s390_init_machine_status PARAMS ((void));\n  \n /* Return true if SET either doesn't set the CC register, or else\n    the source and destination have matching CC modes and that \n@@ -827,8 +832,10 @@ override_options ()\n {\n   /* Acquire a unique set number for our register saves and restores.  */\n   s390_sr_alias_set = new_alias_set ();\n-}\n \n+  /* Set up function hooks.  */\n+  init_machine_status = s390_init_machine_status;\n+}\n \n /* Map for smallest class containing reg regno.  */\n \n@@ -2580,10 +2587,12 @@ s390_output_symbolic_const (file, x)\n         case 100:\n         case 104:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"-.LT%d\", current_function_funcdef_no);\n-\t  break;\n+          fprintf (file, \"-\");\t\n+\t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n+ \t  break;\n         case 105:\n-          fprintf (file, \".LT%d-\", current_function_funcdef_no);\n+\t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n+          fprintf (file, \"-\");\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n \t  break;\n \tcase 110:\n@@ -2604,7 +2613,8 @@ s390_output_symbolic_const (file, x)\n \t  break;\n \tcase 114:\n \t  s390_output_symbolic_const (file, XVECEXP (x, 0, 0));\n-          fprintf (file, \"@PLT-.LT%d\", current_function_funcdef_no);\n+          fprintf (file, \"@PLT-\");\n+\t  s390_output_symbolic_const (file, cfun->machine->literal_pool_label);\n \t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand (2)\");\n@@ -4047,42 +4057,27 @@ int s390_nr_constants;\n /* Output main constant pool to stdio stream FILE.  */ \n \n void\n-s390_output_constant_pool (file)\n-     FILE *file;\n+s390_output_constant_pool (start_label, end_label)\n+     rtx start_label;\n+     rtx end_label;\n {\n-  /* Output constant pool.  */\n-  if (s390_nr_constants)\n-    {\n-      if (TARGET_64BIT)\n-\t{\n-\t  fprintf (file, \"\\tlarl\\t%s,.LT%d\\n\", reg_names[BASE_REGISTER],\n-\t\t   current_function_funcdef_no);\n-\t  readonly_data_section ();\n-\t  ASM_OUTPUT_ALIGN (file, 3);\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\tbras\\t%s,.LTN%d\\n\", reg_names[BASE_REGISTER],\n-\t\t   current_function_funcdef_no);\n-\t}\n-      fprintf (file, \".LT%d:\\n\", current_function_funcdef_no);\n-\n-      s390_pool_count = 0;\n-      output_constant_pool (current_function_name, current_function_decl);\n-      s390_pool_count = -1;\n+  if (TARGET_64BIT)\n+    readonly_data_section ();\n+  ASM_OUTPUT_ALIGN (asm_out_file, TARGET_64BIT ? 3 : 2);\n \n-      if (TARGET_64BIT)\n-\tfunction_section (current_function_decl);\n-      else\n-        fprintf (file, \".LTN%d:\\n\", current_function_funcdef_no);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (start_label));\n+  s390_pool_count = 0;\n+  output_constant_pool (current_function_name, current_function_decl);\n+  s390_pool_count = -1;\n+  if (TARGET_64BIT)\n+    function_section (current_function_decl);\n+  else\n+    {\n+      ASM_OUTPUT_ALIGN (asm_out_file, 1);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (end_label));\n     }\n-\n-  /* If no pool required, at least output the anchor label.  */\n-  else if (!TARGET_64BIT && flag_pic)\n-    fprintf (file, \".LT%d:\\n\", current_function_funcdef_no);\n }\n \n-\n /* Rework the prolog/epilog to avoid saving/restoring\n    registers unnecessarily.  If TEMP_REGNO is nonnegative,\n    it specifies the number of a caller-saved register used \n@@ -4097,13 +4092,10 @@ s390_optimize_prolog (temp_regno)\n   int i, j;\n   rtx insn, new_insn, next_insn;\n \n-  struct s390_frame frame;\n-  s390_frame_info (&frame);\n-\n   /* Recompute regs_ever_live data for special registers.  */\n   regs_ever_live[BASE_REGISTER] = 0;\n   regs_ever_live[RETURN_REGNUM] = 0;\n-  regs_ever_live[STACK_POINTER_REGNUM] = frame.frame_size > 0;\n+  regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n   /* If there is (possibly) any pool entry, we need to\n      load the base register.  \n@@ -4241,9 +4233,6 @@ s390_fixup_clobbered_return_reg (return_reg)\n   bool replacement_done = 0;\n   rtx insn;\n \n-  struct s390_frame frame;\n-  s390_frame_info (&frame);\n-\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx reg, off, new_insn;\n@@ -4256,12 +4245,12 @@ s390_fixup_clobbered_return_reg (return_reg)\n \t  && store_multiple_operation (PATTERN (insn), VOIDmode))\n \tcontinue;\n \n-      if (frame.frame_pointer_p)\n+      if (frame_pointer_needed)\n \treg = hard_frame_pointer_rtx;\n       else\n \treg = stack_pointer_rtx;\n \n-      off = GEN_INT (frame.frame_size + REGNO (return_reg) * UNITS_PER_WORD);\n+      off = GEN_INT (cfun->machine->frame_size + REGNO (return_reg) * UNITS_PER_WORD);\n       if (INTVAL (off) >= 4096)\n \t{\n \t  off = force_const_mem (Pmode, off);\n@@ -4413,8 +4402,7 @@ find_unused_clobbered_reg ()\n /* Fill FRAME with info about frame of current function.  */\n \n static void\n-s390_frame_info (frame)\n-     struct s390_frame *frame;\n+s390_frame_info ()\n {\n   char gprs_ever_live[16];\n   int i, j;\n@@ -4424,28 +4412,24 @@ s390_frame_info (frame)\n     fatal_error (\"Total size of local variables exceeds architecture limit.\");\n \n   /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n-  frame->save_fprs_p = 0;\n+  cfun->machine->save_fprs_p = 0;\n   if (TARGET_64BIT)\n     for (i = 24; i < 32; i++) \n       if (regs_ever_live[i])\n \t{\n-          frame->save_fprs_p = 1;\n+          cfun->machine->save_fprs_p = 1;\n \t  break;\n \t}\n \n-  frame->frame_size = fsize + frame->save_fprs_p * 64;\n+  cfun->machine->frame_size = fsize + cfun->machine->save_fprs_p * 64;\n \n   /* Does function need to setup frame and save area.  */\n   \n   if (! current_function_is_leaf\n-      || frame->frame_size > 0\n+      || cfun->machine->frame_size > 0\n       || current_function_calls_alloca \n       || current_function_stdarg)\n-    frame->frame_size += STARTING_FRAME_OFFSET;\n-\n-  /* Frame pointer needed.   */\n-    \n-  frame->frame_pointer_p = frame_pointer_needed;\n+    cfun->machine->frame_size += STARTING_FRAME_OFFSET;\n \n   /* Find first and last gpr to be saved.  Note that at this point,\n      we assume the return register and the base register always\n@@ -4459,7 +4443,7 @@ s390_frame_info (frame)\n \n   gprs_ever_live[BASE_REGISTER] = 1;\n   gprs_ever_live[RETURN_REGNUM] = 1;\n-  gprs_ever_live[STACK_POINTER_REGNUM] = frame->frame_size > 0;\n+  gprs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n   \n   for (i = 6; i < 16; i++)\n     if (gprs_ever_live[i])\n@@ -4471,13 +4455,13 @@ s390_frame_info (frame)\n \n \n   /* Save / Restore from gpr i to j.  */\n-  frame->first_save_gpr = i;\n-  frame->first_restore_gpr = i;\n-  frame->last_save_gpr  = j;\n+  cfun->machine->first_save_gpr = i;\n+  cfun->machine->first_restore_gpr = i;\n+  cfun->machine->last_save_gpr  = j;\n \n   /* Varargs functions need to save gprs 2 to 6.  */\n   if (current_function_stdarg)\n-    frame->first_save_gpr = 2;\n+    cfun->machine->first_save_gpr = 2;\n }\n \n /* Return offset between argument pointer and frame pointer \n@@ -4486,13 +4470,29 @@ s390_frame_info (frame)\n int \n s390_arg_frame_offset ()\n {\n-  struct s390_frame frame;\n+  HOST_WIDE_INT fsize = get_frame_size ();\n+  int save_fprs_p, i;\n \n-  /* Compute frame_info.  */\n+  /* fprs 8 - 15 are caller saved for 64 Bit ABI.  */\n+  save_fprs_p = 0;\n+  if (TARGET_64BIT)\n+    for (i = 24; i < 32; i++) \n+      if (regs_ever_live[i])\n+\t{\n+          save_fprs_p = 1;\n+\t  break;\n+\t}\n \n-  s390_frame_info (&frame);\n+  fsize = fsize + save_fprs_p * 64;\n \n-  return frame.frame_size + STACK_POINTER_OFFSET;\n+  /* Does function need to setup frame and save area.  */\n+  \n+  if (! current_function_is_leaf\n+      || fsize > 0\n+      || current_function_calls_alloca \n+      || current_function_stdarg)\n+    fsize += STARTING_FRAME_OFFSET;\n+  return fsize + STACK_POINTER_OFFSET;\n }\n \n /* Emit insn to save fpr REGNUM at offset OFFSET relative\n@@ -4646,14 +4646,14 @@ restore_gprs (base, offset, first, last)\n void\n s390_emit_prologue ()\n {\n-  struct s390_frame frame;\n   rtx insn, addr;\n   rtx temp_reg;\n+  rtx pool_start_label, pool_end_label;\n   int i;\n \n   /* Compute frame_info.  */\n \n-  s390_frame_info (&frame);\n+  s390_frame_info ();\n \n   /* Choose best register to use for temp use within prologue.  */\n   \n@@ -4667,12 +4667,21 @@ s390_emit_prologue ()\n   /* Save call saved gprs.  */\n \n   insn = save_gprs (stack_pointer_rtx, 0, \n-\t\t    frame.first_save_gpr, frame.last_save_gpr);\n+\t\t    cfun->machine->first_save_gpr, cfun->machine->last_save_gpr);\n   emit_insn (insn);\n \n-  /* Dump constant pool and set constant pool register (13).  */\n- \n-  insn = emit_insn (gen_lit ());\n+  /* Dump constant pool and set constant pool register.  */\n+\n+  pool_start_label = gen_label_rtx();\n+  pool_end_label = gen_label_rtx();\n+  cfun->machine->literal_pool_label = pool_start_label;\n+  \n+  if (TARGET_64BIT)\n+    insn = emit_insn (gen_literal_pool_64 (gen_rtx_REG (Pmode, BASE_REGISTER),\n+                 \t\t\t   pool_start_label, pool_end_label));\n+  else\n+    insn = emit_insn (gen_literal_pool_31 (gen_rtx_REG (Pmode, BASE_REGISTER),\n+\t\t\t\t\t     pool_start_label, pool_end_label));  \n   \n   /* Save fprs for variable args.  */\n \n@@ -4711,21 +4720,21 @@ s390_emit_prologue ()\n \n   /* Decrement stack pointer.  */\n \n-  if (frame.frame_size > 0)\n+  if (cfun->machine->frame_size > 0)\n     {\n-      rtx frame_off = GEN_INT (-frame.frame_size);\n+      rtx frame_off = GEN_INT (-cfun->machine->frame_size);\n \n       /* Save incoming stack pointer into temp reg.  */\n       \n-      if (TARGET_BACKCHAIN || frame.save_fprs_p)\n+      if (TARGET_BACKCHAIN || cfun->machine->save_fprs_p)\n \t{\n \t  insn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n \t}\n       \n       /* Substract frame size from stack pointer.  */\n \n-      frame_off = GEN_INT (-frame.frame_size);\n-      if (!CONST_OK_FOR_LETTER_P (-frame.frame_size, 'K'))\n+      frame_off = GEN_INT (-cfun->machine->frame_size);\n+      if (!CONST_OK_FOR_LETTER_P (-cfun->machine->frame_size, 'K'))\n \tframe_off = force_const_mem (Pmode, frame_off);\n \n       insn = emit_insn (gen_add2_insn (stack_pointer_rtx, frame_off));\n@@ -4734,7 +4743,7 @@ s390_emit_prologue ()\n \tgen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t   gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n \t\t\t\t   gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t           GEN_INT (-frame.frame_size))),\n+\t\t\t           GEN_INT (-cfun->machine->frame_size))),\n \t\t\t   REG_NOTES (insn));\n \n       /* Set backchain.  */\n@@ -4749,15 +4758,15 @@ s390_emit_prologue ()\n \n   /* Save fprs 8 - 15 (64 bit ABI).  */\n   \n-  if (frame.save_fprs_p)\n+  if (cfun->machine->save_fprs_p)\n     {\n       insn = emit_insn (gen_add2_insn (temp_reg, GEN_INT(-64)));\n \n       for (i = 24; i < 32; i++)\n \tif (regs_ever_live[i])\n \t  {\n \t    rtx addr = plus_constant (stack_pointer_rtx, \n-\t\t\t\t      frame.frame_size - 64 + (i-24)*8);\n+\t\t\t\t      cfun->machine->frame_size - 64 + (i-24)*8);\n \n \t    insn = save_fpr (temp_reg, (i-24)*8, i);\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n@@ -4772,7 +4781,7 @@ s390_emit_prologue ()\n \t    \n   /* Set frame pointer, if needed.  */\n   \n-  if (frame.frame_pointer_p)\n+  if (frame_pointer_needed)\n     {\n       insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n@@ -4818,26 +4827,21 @@ s390_emit_prologue ()\n void\n s390_emit_epilogue ()\n {\n-  struct s390_frame frame;\n   rtx frame_pointer, return_reg;\n   int area_bottom, area_top, offset = 0;\n   rtvec p;\n \n-  /* Compute frame_info.  */\n- \n-  s390_frame_info (&frame);\n-\n   /* Check whether to use frame or stack pointer for restore.  */\n \n-  frame_pointer = frame.frame_pointer_p ? \n+  frame_pointer = frame_pointer_needed ? \n     hard_frame_pointer_rtx : stack_pointer_rtx;\n \n   /* Compute which parts of the save area we need to access.  */\n \n-  if (frame.first_restore_gpr != -1)\n+  if (cfun->machine->first_restore_gpr != -1)\n     {\n-      area_bottom = frame.first_restore_gpr * UNITS_PER_WORD;\n-      area_top = (frame.last_save_gpr + 1) * UNITS_PER_WORD;\n+      area_bottom = cfun->machine->first_restore_gpr * UNITS_PER_WORD;\n+      area_top = (cfun->machine->last_save_gpr + 1) * UNITS_PER_WORD;\n     }\n   else\n     {\n@@ -4847,7 +4851,7 @@ s390_emit_epilogue ()\n \n   if (TARGET_64BIT)\n     {\n-      if (frame.save_fprs_p)\n+      if (cfun->machine->save_fprs_p)\n \t{\n \t  if (area_bottom > -64)\n \t    area_bottom = -64;\n@@ -4880,18 +4884,18 @@ s390_emit_epilogue ()\n     {\n       /* Nothing to restore.  */\n     }\n-  else if (frame.frame_size + area_bottom >= 0\n-           && frame.frame_size + area_top <= 4096)\n+  else if (cfun->machine->frame_size + area_bottom >= 0\n+           && cfun->machine->frame_size + area_top <= 4096)\n     {\n       /* Area is in range.  */\n-      offset = frame.frame_size;\n+      offset = cfun->machine->frame_size;\n     }\n   else\n     {\n       rtx insn, frame_off;\n \n       offset = area_bottom < 0 ? -area_bottom : 0; \n-      frame_off = GEN_INT (frame.frame_size - offset);\n+      frame_off = GEN_INT (cfun->machine->frame_size - offset);\n \n       if (!CONST_OK_FOR_LETTER_P (INTVAL (frame_off), 'K'))\n \tframe_off = force_const_mem (Pmode, frame_off);\n@@ -4905,7 +4909,7 @@ s390_emit_epilogue ()\n     {\n       int i;\n \n-      if (frame.save_fprs_p)\n+      if (cfun->machine->save_fprs_p)\n \tfor (i = 24; i < 32; i++)\n \t  if (regs_ever_live[i] && !global_regs[i])\n \t    restore_fpr (frame_pointer, \n@@ -4925,16 +4929,16 @@ s390_emit_epilogue ()\n \n   /* Restore call saved gprs.  */\n \n-  if (frame.first_restore_gpr != -1)\n+  if (cfun->machine->first_restore_gpr != -1)\n     {\n       rtx insn, addr;\n       int i;\n \n       /* Check for global register and save them \n \t to stack location from where they get restored.  */\n \n-      for (i = frame.first_restore_gpr; \n-\t   i <= frame.last_save_gpr;\n+      for (i = cfun->machine->first_restore_gpr; \n+\t   i <= cfun->machine->last_save_gpr;\n \t   i++)\n \t{\n \t  /* These registers are special and need to be \n@@ -4979,7 +4983,8 @@ s390_emit_epilogue ()\n       emit_insn (gen_blockage());      \n \n       insn = restore_gprs (frame_pointer, offset, \n-\t\t\t   frame.first_restore_gpr, frame.last_save_gpr);\n+\t\t\t   cfun->machine->first_restore_gpr, \n+\t\t\t   cfun->machine->last_save_gpr);\n       emit_insn (insn);\n     }\n \n@@ -5811,3 +5816,12 @@ s390_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n     }\n }\n \n+/* How to allocate a 'struct machine_function'.  */\n+\n+static struct machine_function *\n+s390_init_machine_status ()\n+{\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n+}\n+\n+#include \"gt-s390.h\""}, {"sha": "197aa67ebcb8d441dd3ab8c35d28c6780ed5830a", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29742ba4f4eff92353b98ea0a7a039053ccb8de7/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=29742ba4f4eff92353b98ea0a7a039053ccb8de7", "patch": "@@ -6814,17 +6814,36 @@\n    (set_attr \"type\"    \"jsr\")\t\t\n    (set_attr \"atype\"   \"mem\")])\n \n-\n-(define_insn \"lit\"\n-  [(set (reg 13) (pc))\n-   (unspec_volatile [(const_int 0)] 200)]\n+(define_insn \"literal_pool_31\"\n+  [(unspec_volatile [(const_int 0)] 300)\n+   (set (match_operand:SI 0 \"register_operand\" \"=a\") \n+        (label_ref (match_operand 1 \"\" \"\")))\t\n+   (use (label_ref (match_operand 2 \"\" \"\")))]\n   \"\"\n   \"*\n {\n-   s390_output_constant_pool (asm_out_file);\n-   return \\\"\\\";\n+   if (s390_nr_constants) {\n+     output_asm_insn (\\\"bras\\\\t%0,%2\\\", operands);\n+     s390_output_constant_pool (operands[1], operands[2]);\n+   }\n+   return \\\"\\\";\t\n }\"\n   [(set_attr \"op_type\" \"NN\")\n-   (set_attr \"length\"  \"6\")\n-   (set_attr \"type\"    \"integer\")])\n+   (set_attr \"type\"    \"la\")])\n \n+(define_insn \"literal_pool_64\"\n+  [(unspec_volatile [(const_int 0)] 300)\n+   (set (match_operand:DI 0 \"register_operand\" \"=a\") \n+        (label_ref (match_operand 1 \"\" \"\")))\t\n+   (use (label_ref (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+   if (s390_nr_constants) {\n+     output_asm_insn (\\\"larl\\\\t%0,%1\\\", operands);\n+     s390_output_constant_pool (operands[1], operands[2]);\n+   }\n+   return \\\"\\\";\t\n+}\"\n+  [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"type\"    \"la\")])"}]}