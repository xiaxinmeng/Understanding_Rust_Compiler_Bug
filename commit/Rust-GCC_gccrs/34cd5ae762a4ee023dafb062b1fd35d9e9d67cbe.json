{"sha": "34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRjZDVhZTc2MmE0ZWUwMjNkYWZiMDYyYjFmZDM1ZDllOWQ2N2NiZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-05T03:02:05Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-05T03:02:05Z"}, "message": "call.c: Fix comment typos.\n\n\t* call.c: Fix comment typos.\n\t* class.c: Likewise.\n\t* cp-tree.h: Likewise.\n\t* cvt.c: Likewise.\n\t* decl2.c: Likewise.\n\t* decl.c: Likewise.\n\t* init.c: Likewise.\n\t* mangle.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* search.c: Likewise.\n\t* semantics.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise\n\nFrom-SVN: r68956", "tree": {"sha": "8b49720ac0b6412e56b800efc44c446f9ffb3646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b49720ac0b6412e56b800efc44c446f9ffb3646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/comments", "author": null, "committer": null, "parents": [{"sha": "a38825d2c8143aad54427a0bd8591ce45727442d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38825d2c8143aad54427a0bd8591ce45727442d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38825d2c8143aad54427a0bd8591ce45727442d"}], "stats": {"total": 147, "additions": 82, "deletions": 65}, "files": [{"sha": "768fe65154f0cac9271a8fb4c5a7023a62e65ef8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -1,3 +1,20 @@\n+2003-07-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* call.c: Fix comment typos.\n+\t* class.c: Likewise.\n+\t* cp-tree.h: Likewise.\n+\t* cvt.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* init.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\n 2003-07-04  Zack Weinberg  <zack@codesourcery.com>\n \n \t* parser.c (cp_lexer_read_token): No need to handle string"}, {"sha": "2ae13193afb5ab06de2113723636f42083ff9d0b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -1169,7 +1169,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n \t -- is an lvalue (but not an lvalue for a bit-field), and \"cv1 T1\"\n \t    is reference-compatible with \"cv2 T2,\"\n \t \n-\t the reference is bound directly to the initializer exprssion\n+\t the reference is bound directly to the initializer expression\n \t lvalue.  */\n       conv = build1 (IDENTITY_CONV, from, expr);\n       conv = direct_reference_binding (rto, conv);\n@@ -1193,7 +1193,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)\n     {\n       /* [dcl.init.ref]\n \n-\t If the initializer exprsesion\n+\t If the initializer expression\n \n \t -- has a class type (i.e., T2 is a class type) can be\n \t    implicitly converted to an lvalue of type \"cv3 T3,\" where\n@@ -2915,7 +2915,7 @@ build_new_function_call (tree fn, tree args)\n    the arguments provided.  *SIZE points to the total number of bytes\n    required by the allocation, and is updated if that is changed here.\n    *COOKIE_SIZE is non-NULL if a cookie should be used.  If this\n-   function determins that no cookie should be used, after all,\n+   function determines that no cookie should be used, after all,\n    *COOKIE_SIZE is set to NULL_TREE. */\n \n tree\n@@ -5254,7 +5254,7 @@ maybe_handle_implicit_object (tree *ics)\n       tree reference_type;\n \n       /* The `this' parameter is a pointer to a class type.  Make the\n-\t implict conversion talk about a reference to that same class\n+\t implicit conversion talk about a reference to that same class\n \t type.  */\n       reference_type = TREE_TYPE (TREE_TYPE (*ics));\n       reference_type = build_reference_type (reference_type);"}, {"sha": "a699ed0e185e760a3edf1eecdf0a0b5e1c0b7922", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -7813,13 +7813,13 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n \t  vcall_offset = fold (build1 (NOP_EXPR, vtable_entry_type,\n \t\t\t\t       vcall_offset));\n \t}\n-      /* Add the intiailizer to the vtable.  */\n+      /* Add the initializer to the vtable.  */\n       *vid->last_init = build_tree_list (NULL_TREE, vcall_offset);\n       vid->last_init = &TREE_CHAIN (*vid->last_init);\n     }\n }\n \n-/* Return vtbl initializers for the RTTI entries coresponding to the\n+/* Return vtbl initializers for the RTTI entries corresponding to the\n    BINFO's vtable.  The RTTI entries should indicate the object given\n    by VID->rtti_binfo.  */\n "}, {"sha": "a8955f8e269a056923b376df8e9460236d2526b4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -1873,7 +1873,7 @@ struct lang_decl GTY(())\n   (DECL_LANG_SPECIFIC (NODE)->u.f.operator_code = (CODE))\n \n /* If NODE is an overloaded operator, then this returns the TREE_CODE\n-   associcated with the overloaded operator.\n+   associated with the overloaded operator.\n    DECL_ASSIGNMENT_OPERATOR_P must also be checked to determine\n    whether or not NODE is an assignment operator.  If NODE is not an\n    overloaded operator, ERROR_MARK is returned.  Since the numerical\n@@ -2637,7 +2637,7 @@ struct lang_decl GTY(())\n    TREE_LIST, whose TREE_VALUE is a PARM_DECL (if the parameter is a\n    non-type parameter), or a TYPE_DECL (if the parameter is a type\n    parameter).  The TREE_PURPOSE is the default value, if any.  The\n-   TEMPLATE_PARM_INDEX for the parameter is avilable as the\n+   TEMPLATE_PARM_INDEX for the parameter is available as the\n    DECL_INITIAL (for a PARM_DECL) or as the TREE_TYPE (for a\n    TYPE_DECL).  */\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS (NODE)\n@@ -2857,7 +2857,7 @@ struct lang_decl GTY(())\n    class, and hence adds the offsets. A result pointer adjusting thunk\n    converts from a derived class to a base, and hence subtracts the\n    offsets.  If both operations are performed, then the constant\n-   adjument is performed first for this pointer adjustment and last\n+   adjustment is performed first for this pointer adjustment and last\n    for the result pointer adjustment.\n \n    The constant adjustment is given by THUNK_FIXED_OFFSET.  If the\n@@ -3380,7 +3380,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \t\t\t\t   derived from the first.  */\n #define COMPARE_DERIVED       2 /* Like COMPARE_BASE, but in\n \t\t\t\t   reverse.  */\n-#define COMPARE_REDECLARATION 4 /* The comparsion is being done when\n+#define COMPARE_REDECLARATION 4 /* The comparison is being done when\n \t\t\t\t   another declaration of an existing\n \t\t\t\t   entity is seen.  */\n "}, {"sha": "008ff4bf980ca1354ade28dff53aa602c06749b0", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -638,7 +638,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (same_type_p (type, TREE_TYPE (e)))\n \t/* The call to fold will not always remove the NOP_EXPR as\n \t   might be expected, since if one of the types is a typedef;\n-\t   the comparsion in fold is just equality of pointers, not a\n+\t   the comparison in fold is just equality of pointers, not a\n \t   call to comptypes.  We don't call fold in this case because\n \t   that can result in infinite recursion; fold will call\n \t   convert, which will call ocp_convert, etc.  */"}, {"sha": "9b1cdee9dd9c8e02a7fca87cb72384e172e2538a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -3756,7 +3756,7 @@ pushdecl (tree x)\n \t  else if (TREE_CODE (t) == PARM_DECL)\n \t    {\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n-\t\t/* This is probaby caused by too many errors, but calling\n+\t\t/* This is probably caused by too many errors, but calling\n \t\t   abort will say that if errors have occurred.  */\n \t\tabort ();\n \n@@ -6506,7 +6506,7 @@ builtin_function_1 (const char* name,\n \n /* Entry point for the benefit of c_common_nodes_and_builtins.\n \n-   Make a defintion for a builtin function named NAME and whose data type\n+   Make a definition for a builtin function named NAME and whose data type\n    is TYPE.  TYPE should be a function type with argument types.  This\n    function places the anticipated declaration in the global namespace\n    and additionally in the std namespace if appropriate.\n@@ -7300,7 +7300,7 @@ layout_var_decl (tree decl)\n   /* If we haven't already layed out this declaration, do so now.\n      Note that we must not call complete type for an external object\n      because it's type might involve templates that we are not\n-     supposed to isntantiate yet.  (And it's perfectly valid to say\n+     supposed to instantiate yet.  (And it's perfectly valid to say\n      `extern X x' for some incomplete type `X'.)  */\n   if (!DECL_EXTERNAL (decl))\n     complete_type (type);"}, {"sha": "2227164e142bccc8405ba51ec0e41dd65b4877e5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -1996,7 +1996,7 @@ start_objects (int method_type, int initp)\n \n   /* We cannot allow these functions to be elided, even if they do not\n      have external linkage.  And, there's no point in deferring\n-     copmilation of thes functions; they're all going to have to be\n+     compilation of thes functions; they're all going to have to be\n      out anyhow.  */\n   current_function_cannot_inline\n     = \"static constructors and destructors cannot be inlined\";"}, {"sha": "3d4d81bc329aea827e863c04f893f4dd6399e8fa", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -2067,7 +2067,7 @@ build_new_1 (tree exp)\n   bool placement_allocation_fn_p;\n   tree args = NULL_TREE;\n   /* True if the storage must be initialized, either by a constructor\n-     or due to an explicit new-intiailizer.  */\n+     or due to an explicit new-initializer.  */\n   bool is_initialized;\n   /* The address of the thing allocated, not including any cookie.  In\n      particular, if an array cookie is in use, DATA_ADDR is the"}, {"sha": "48ad68b47c92dd8362a4cdb4eea9202f1dbeb860", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -319,7 +319,7 @@ dump_substitution_candidates ()\n /* Both decls and types can be substitution candidates, but sometimes\n    they refer to the same thing.  For instance, a TYPE_DECL and\n    RECORD_TYPE for the same class refer to the same thing, and should\n-   be treated accordinginly in substitutions.  This function returns a\n+   be treated accordingly in substitutions.  This function returns a\n    canonicalized tree node representing NODE that is used when adding\n    and substitution candidates and finding matches.  */\n \n@@ -1428,7 +1428,7 @@ write_type (tree type)\n   if (write_CV_qualifiers_for_type (type) > 0)\n     /* If TYPE was CV-qualified, we just wrote the qualifiers; now\n        mangle the unqualified type.  The recursive call is needed here\n-       since both the qualified and uqualified types are substitution\n+       since both the qualified and unqualified types are substitution\n        candidates.  */\n     write_type (TYPE_MAIN_VARIANT (type));\n   else if (TREE_CODE (type) == ARRAY_TYPE)"}, {"sha": "7d42ea4e77c2397e794510c01559ff5e232668e1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -89,7 +89,7 @@ typedef struct cp_token GTY (())\n    complete.)  \n \n    This somewhat ungainly data structure (as opposed to, say, a\n-   variable-length array), is used due to contraints imposed by the\n+   variable-length array), is used due to constraints imposed by the\n    current garbage-collection methodology.  If it is made more\n    flexible, we could perhaps simplify the data structures involved.  */\n \n@@ -1291,7 +1291,7 @@ static cp_parser *cp_parser_new\n    Those that return `tree' will return the error_mark_node (rather\n    than NULL_TREE) if a parse error occurs, unless otherwise noted.\n    Sometimes, they will return an ordinary node if error-recovery was\n-   attempted, even though a parse error occurrred.  So, to check\n+   attempted, even though a parse error occurred.  So, to check\n    whether or not a parse error occurred, you should always use\n    cp_parser_error_occurred.  If the construct is optional (indicated\n    either by an `_opt' in the name of the function that does the\n@@ -2169,7 +2169,7 @@ cp_parser_new (void)\n   /* Local variable names are not forbidden.  */\n   parser->local_variables_forbidden_p = false;\n \n-  /* We are not procesing an `extern \"C\"' declaration.  */\n+  /* We are not processing an `extern \"C\"' declaration.  */\n   parser->in_unbraced_linkage_specification_p = false;\n \n   /* We are not processing a declarator.  */\n@@ -2399,7 +2399,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t     __func__ are the names of variables -- but they are\n \t     treated specially.  Therefore, they are handled here,\n \t     rather than relying on the generic id-expression logic\n-\t     below.  Gramatically, these names are id-expressions.  \n+\t     below.  Grammatically, these names are id-expressions.  \n \n \t     Consume the token.  */\n \t  token = cp_lexer_consume_token (parser->lexer);\n@@ -4115,7 +4115,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\treturn cp_parser_non_constant_expression (\"an increment\");\n \t      parser->non_constant_expression_p = true;\n \t    }\n-\t  /* Generate a reprsentation for the complete expression.  */\n+\t  /* Generate a representation for the complete expression.  */\n \t  postfix_expression \n \t    = finish_increment_expr (postfix_expression, \n \t\t\t\t     POSTINCREMENT_EXPR);\n@@ -4133,7 +4133,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\treturn cp_parser_non_constant_expression (\"a decrement\");\n \t      parser->non_constant_expression_p = true;\n \t    }\n-\t  /* Generate a reprsentation for the complete expression.  */\n+\t  /* Generate a representation for the complete expression.  */\n \t  postfix_expression \n \t    = finish_increment_expr (postfix_expression, \n \t\t\t\t     POSTDECREMENT_EXPR);\n@@ -4283,7 +4283,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n    ADDRESS_P is true iff the unary-expression is appearing as the\n    operand of the `&' operator.\n \n-   Returns a representation of the expresion.  */\n+   Returns a representation of the expression.  */\n \n static tree\n cp_parser_unary_expression (cp_parser *parser, bool address_p)\n@@ -4723,7 +4723,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n    new-initializer:\n      ( expression-list [opt] )\n \n-   Returns a reprsentation of the expression-list.  If there is no\n+   Returns a representation of the expression-list.  If there is no\n    expression-list, VOID_ZERO_NODE is returned.  */\n \n static tree\n@@ -5134,7 +5134,7 @@ cp_parser_logical_and_expression (cp_parser* parser)\n /* Parse a logical-or-expression.\n \n    logical-or-expression:\n-     logical-and-expresion\n+     logical-and-expression\n      logical-or-expression || logical-and-expression\n \n    Returns a representation of the expression.  */\n@@ -5273,7 +5273,7 @@ cp_parser_assignment_expression (cp_parser* parser)\n \t\t    return cp_parser_non_constant_expression (\"an assignment\");\n \t\t  parser->non_constant_expression_p = true;\n \t\t}\n-\t      /* Build the asignment expression.  */\n+\t      /* Build the assignment expression.  */\n \t      expr = build_x_modify_expr (expr, \n \t\t\t\t\t  assignment_operator, \n \t\t\t\t\t  rhs);\n@@ -6055,7 +6055,7 @@ static void\n cp_parser_for_init_statement (cp_parser* parser)\n {\n   /* If the next token is a `;', then we have an empty\n-     expression-statement.  Gramatically, this is also a\n+     expression-statement.  Grammatically, this is also a\n      simple-declaration, but an invalid one, because it does not\n      declare anything.  Therefore, if we did not handle this case\n      specially, we would issue an error message about an invalid\n@@ -6268,7 +6268,7 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t}\n \n       /* The C lexer modifies PENDING_LANG_CHANGE when it wants the\n-\t parser to enter or exit implict `extern \"C\"' blocks.  */\n+\t parser to enter or exit implicit `extern \"C\"' blocks.  */\n       while (pending_lang_change > 0)\n \t{\n \t  push_lang_context (lang_name_c);\n@@ -6390,7 +6390,7 @@ cp_parser_declaration (cp_parser* parser)\n      __extension__ block-declaration \n      label-declaration\n \n-   If STATEMENT_P is TRUE, then this block-declaration is ocurring as\n+   If STATEMENT_P is TRUE, then this block-declaration is occurring as\n    part of a declaration-statement.  */\n \n static void\n@@ -6464,7 +6464,7 @@ cp_parser_block_declaration (cp_parser *parser,\n      init-declarator\n      init-declarator-list , init-declarator \n \n-   If FUNCTION_DEFINTION_ALLOWED_P is TRUE, then we also recognize a\n+   If FUNCTION_DEFINITION_ALLOWED_P is TRUE, then we also recognize a\n    function-definition as a simple-declaration.   */\n \n static void\n@@ -6624,7 +6624,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n    Returns a TREE_LIST, giving the decl-specifiers in the order they\n    appear in the source code.  The TREE_VALUE of each node is the\n    decl-specifier.  For a keyword (such as `auto' or `friend'), the\n-   TREE_VALUE is simply the correspoding TREE_IDENTIFIER.  For the\n+   TREE_VALUE is simply the corresponding TREE_IDENTIFIER.  For the\n    representation of a type-specifier, see cp_parser_type_specifier.  \n \n    If there are attributes, they will be stored in *ATTRIBUTES,\n@@ -7168,7 +7168,7 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n    GNU extension:\n   \n    mem-initializer:\n-     ( expresion-list [opt] )\n+     ( expression-list [opt] )\n \n    Returns a TREE_LIST.  The TREE_PURPOSE is the TYPE (for a base\n    class) or FIELD_DECL (for a non-static data member) to initialize;\n@@ -7731,7 +7731,7 @@ cp_parser_type_parameter (cp_parser* parser)\n \t  {\n \t    /* Consume the `=' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n-\t    /* Parse the default-argumen.  */\n+\t    /* Parse the default-argument.  */\n \t    default_argument = cp_parser_type_id (parser);\n \t  }\n \telse\n@@ -8360,7 +8360,7 @@ cp_parser_explicit_specialization (cp_parser* parser)\n \n    Returns a representation of the type-specifier.  If the\n    type-specifier is a keyword (like `int' or `const', or\n-   `__complex__') then the correspoding IDENTIFIER_NODE is returned.\n+   `__complex__') then the corresponding IDENTIFIER_NODE is returned.\n    For a class-specifier, enum-specifier, or elaborated-type-specifier\n    a TREE_TYPE is returned; otherwise, a TYPE_DECL is returned.\n \n@@ -9288,7 +9288,7 @@ cp_parser_using_directive (cp_parser* parser)\n   cp_parser_require_keyword (parser, RID_NAMESPACE, \"`namespace'\");\n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n-  /* And the optional nested-name-sepcifier.  */\n+  /* And the optional nested-name-specifier.  */\n   cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t       /*typename_keyword_p=*/false,\n \t\t\t\t       /*check_dependency_p=*/true,\n@@ -9723,12 +9723,12 @@ cp_parser_init_declarator (cp_parser* parser,\n      \n    Returns a representation of the declarator.  If the declarator has\n    the form `* declarator', then an INDIRECT_REF is returned, whose\n-   only operand is the sub-declarator.  Analagously, `& declarator' is\n+   only operand is the sub-declarator.  Analogously, `& declarator' is\n    represented as an ADDR_EXPR.  For `X::* declarator', a SCOPE_REF is\n    used.  The first operand is the TYPE for `X'.  The second operand\n    is an INDIRECT_REF whose operand is the sub-declarator.\n \n-   Otherwise, the reprsentation is as for a direct-declarator.\n+   Otherwise, the representation is as for a direct-declarator.\n \n    (It would be better to define a structure type to represent\n    declarators, rather than abusing `tree' nodes to represent\n@@ -9879,13 +9879,13 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t{\n \t  /* This is either a parameter-declaration-clause, or a\n   \t     parenthesized declarator. When we know we are parsing a\n-  \t     named declarator, it must be a paranthesized declarator\n+  \t     named declarator, it must be a parenthesized declarator\n   \t     if FIRST is true. For instance, `(int)' is a\n   \t     parameter-declaration-clause, with an omitted\n   \t     direct-abstract-declarator. But `((*))', is a\n   \t     parenthesized abstract declarator. Finally, when T is a\n   \t     template parameter `(T)' is a\n-  \t     paremeter-declaration-clause, and not a parenthesized\n+  \t     parameter-declaration-clause, and not a parenthesized\n   \t     named declarator.\n \t     \n \t     We first try and parse a parameter-declaration-clause,\n@@ -9912,7 +9912,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t     The former is a function-declaration; the latter is a\n \t     variable initialization.  \n \n-\t     Thus again, we try a parameter-declation-clause, and if\n+\t     Thus again, we try a parameter-declaration-clause, and if\n \t     that fails, we back out and return.  */\n \n \t  if (!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n@@ -9935,7 +9935,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      params = cp_parser_parameter_declaration_clause (parser);\n \n \t      /* If all went well, parse the cv-qualifier-seq and the\n-\t     \t exception-specfication.  */\n+\t     \t exception-specification.  */\n \t      if (cp_parser_parse_definitely (parser))\n \t\t{\n \t\t  tree cv_qualifiers;\n@@ -10580,7 +10580,7 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n       parameter \n \t= cp_parser_parameter_declaration (parser, /*template_parm_p=*/false);\n \n-      /* If a parse error ocurred parsing the parameter declaration,\n+      /* If a parse error occurred parsing the parameter declaration,\n \t then the entire parameter-declaration-list is erroneous.  */\n       if (parameter == error_mark_node)\n \t{\n@@ -10787,7 +10787,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t     For example, if the default argument is \n \t\t     `X<int, double>()', we need to do name lookup to\n \t\t     figure out whether or not `X' is a template; if\n-\t\t     so, the `,' does not end the deault argument.\n+\t\t     so, the `,' does not end the default argument.\n \n \t\t     That is not yet done.  */\n \t\t  break;\n@@ -11120,7 +11120,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init)\n    Returns an expression representing the initializer.  \n \n    If the `assignment-expression' production is used the value\n-   returned is simply a reprsentation for the expression.  \n+   returned is simply a representation for the expression.  \n \n    Otherwise, a CONSTRUCTOR is returned.  The CONSTRUCTOR_ELTS will be\n    the elements of the initializer-list (or NULL_TREE, if the last\n@@ -12027,7 +12027,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  else if (ANON_AGGR_TYPE_P (type))\n \t    {\n \t      /* Remove constructors and such from TYPE, now that we\n-\t\t know it is an anoymous aggregate.  */\n+\t\t know it is an anonymous aggregate.  */\n \t      fixup_anonymous_aggr (type);\n \t      /* And make the corresponding data member.  */\n \t      decl = build_decl (FIELD_DECL, NULL_TREE, type);\n@@ -12698,7 +12698,7 @@ cp_parser_exception_declaration (cp_parser* parser)\n /* Parse a throw-expression. \n \n    throw-expression:\n-     throw assignment-expresion [opt]\n+     throw assignment-expression [opt]\n \n    Returns a THROW_EXPR representing the throw-expression.  */\n \n@@ -13276,7 +13276,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \n   /* If we have resolved the name of a member declaration, check to\n      see if the declaration is accessible.  When the name resolves to\n-     set of overloaded functions, accesibility is checked when\n+     set of overloaded functions, accessibility is checked when\n      overload resolution is done.  \n \n      During an explicit instantiation, access is not checked at all,\n@@ -13499,7 +13499,7 @@ cp_parser_binary_expression (cp_parser* parser,\n       if (token->type == CPP_GREATER\n \t  && !parser->greater_than_is_operator_p)\n \tbreak;\n-      /* If we find one of the tokens we want, build the correspoding\n+      /* If we find one of the tokens we want, build the corresponding\n \t tree representation.  */\n       for (map_node = token_tree_map; \n \t   map_node->token_type != CPP_EOF;\n@@ -14550,7 +14550,7 @@ cp_parser_abort_tentative_parse (cp_parser* parser)\n   cp_parser_parse_definitely (parser);\n }\n \n-/* Stop parsing tentatively.  If a parse error has ocurred, restore the\n+/* Stop parsing tentatively.  If a parse error has occurred, restore the\n    token stream.  Otherwise, commit to the tokens we have consumed.\n    Returns true if no error occurred; false otherwise.  */\n \n@@ -14560,7 +14560,7 @@ cp_parser_parse_definitely (cp_parser* parser)\n   bool error_occurred;\n   cp_parser_context *context;\n \n-  /* Remember whether or not an error ocurred, since we are about to\n+  /* Remember whether or not an error occurred, since we are about to\n      destroy that information.  */\n   error_occurred = cp_parser_error_occurred (parser);\n   /* Remove the topmost context from the stack.  */"}, {"sha": "3c4d7373636ac6e877e03a2336ce424e9d75b10e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -6277,7 +6277,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n   return r;\n }\n \n-/* Substitue into the ARG_TYPES of a function type.  */\n+/* Substitute into the ARG_TYPES of a function type.  */\n \n static tree\n tsubst_arg_types (tree arg_types, \n@@ -6357,7 +6357,7 @@ tsubst_function_type (tree t,\n   if (return_type == error_mark_node)\n     return error_mark_node;\n \n-  /* Substitue the argument types.  */\n+  /* Substitute the argument types.  */\n   arg_types = tsubst_arg_types (TYPE_ARG_TYPES (t), args,\n \t\t\t\tcomplain, in_decl); \n   if (arg_types == error_mark_node)\n@@ -6868,7 +6868,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (fntype == error_mark_node)\n \t  return error_mark_node;\n \n-\t/* Substitue the exception specification.  */\n+\t/* Substitute the exception specification.  */\n \traises = TYPE_RAISES_EXCEPTIONS (t);\n \tif (raises)\n \t  {\n@@ -8318,7 +8318,7 @@ tsubst_copy_and_build (tree t,\n \n /* Verify that the instantiated ARGS are valid. For type arguments,\n    make sure that the type's linkage is ok. For non-type arguments,\n-   make sure they are constants if they are integral or enumarations.\n+   make sure they are constants if they are integral or enumerations.\n    Emit an error under control of COMPLAIN, and return TRUE on error. */\n \n static bool\n@@ -10869,7 +10869,7 @@ instantiate_decl (tree d, int defer_ok)\n \t     (1) D is a template static data member, for which a\n \t         definition is available.\n \n-\t     (2) An implicit or explicit instantiation has occured.\n+\t     (2) An implicit or explicit instantiation has occurred.\n \n \t     (3) We are not going to emit a definition of the static\n \t         data member at this time."}, {"sha": "1c27d3b5bd5b481d26552544d05d774c63936047", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -1554,7 +1554,7 @@ adjust_result_of_qualified_name_lookup (tree decl,\n    type in the hierarchy, in a breadth-first preorder traversal.\n    If it ever returns a non-NULL value, that value is immediately\n    returned and the walk is terminated.  At each node, FN is passed a\n-   BINFO indicating the path from the curently visited base-class to\n+   BINFO indicating the path from the currently visited base-class to\n    TYPE.  Before each base-class is walked QFN is called.  If the\n    value returned is nonzero, the base-class is walked; otherwise it\n    is not.  If QFN is NULL, it is treated as a function which always\n@@ -2536,7 +2536,7 @@ copied_binfo (tree binfo, tree here)\n }\n \n /* BINFO is some base binfo of HERE, within some other\n-   hierachy. Return the equivalent binfo, but in the hierarchy\n+   hierarchy. Return the equivalent binfo, but in the hierarchy\n    dominated by HERE.  This is the inverse of copied_binfo.  If BINFO\n    is not a base binfo of HERE, returns NULL_TREE. */\n "}, {"sha": "b7b5d853102aa9302e67ffc630833dac2d12d0c0", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -2289,7 +2289,7 @@ expand_body (tree fn)\n \n   /* Save the current file name and line number.  When we expand the\n      body of the function, we'll set INPUT_LOCATION so that\n-     error-mesages come out in the right places.  */\n+     error-messages come out in the right places.  */\n   saved_loc = input_location;\n   saved_function = current_function_decl;\n   input_location = DECL_SOURCE_LOCATION (fn);"}, {"sha": "975c396c2be37202cc1414c567f65a6023ab5f61", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -547,7 +547,7 @@ build_cplus_array_type (tree elt_type, tree index_type)\n    via a typedef or template type argument. [dcl.ref] No such\n    dispensation is provided for qualifying a function type.  [dcl.fct]\n    DR 295 queries this and the proposed resolution brings it into line\n-   with qualifiying a reference.  We implement the DR.  We also behave\n+   with qualifying a reference.  We implement the DR.  We also behave\n    in a similar manner for restricting non-pointer types.  */\n  \n tree"}, {"sha": "cd3bc10ea85e4d2bebb4d0de703650602412bb24", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=34cd5ae762a4ee023dafb062b1fd35d9e9d67cbe", "patch": "@@ -729,9 +729,9 @@ common_type (t1, t2)\n    derived and !exact).\n  \n    [except.spec] \"If a class X ... objects of class X or any class publicly\n-   and unambigously derrived from X. Similarly, if a pointer type Y * ...\n+   and unambiguously derived from X. Similarly, if a pointer type Y * ...\n    exceptions of type Y * or that are pointers to any type publicly and\n-   unambigously derrived from Y. Otherwise a function only allows exceptions\n+   unambiguously derived from Y. Otherwise a function only allows exceptions\n    that have the same type ...\"\n    This does not mention cv qualifiers and is different to what throw\n    [except.throw] and catch [except.catch] will do. They will ignore the\n@@ -3001,7 +3001,7 @@ build_template_expr (enum tree_code code, tree op0, tree op1, tree op2)\n \t      type = boolean_type_node;\n \t      break;\n \t    case COND_EXPR:\n-\t      /* FIXME: Handle special rules for conditioanl\n+\t      /* FIXME: Handle special rules for conditional\n \t\t expressions.  */\n \t      break;\n \t    case COMPOUND_EXPR:\n@@ -6181,7 +6181,7 @@ c_expand_asm_operands (tree string, tree outputs, tree inputs, tree clobbers,\n }\n \f\n /* If RETVAL is the address of, or a reference to, a local variable or\n-   temporary give an appropraite warning.  */\n+   temporary give an appropriate warning.  */\n \n static void\n maybe_warn_about_returning_address_of_local (tree retval)"}]}