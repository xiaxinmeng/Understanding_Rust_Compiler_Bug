{"sha": "0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJmYmMxNjYyYmM0YWE5YmNkYzAwYjZhMjBlM2NiOWQyM2JlMGVmZQ==", "commit": {"author": {"name": "Steve Ellcey", "email": "sellcey@imgtec.com", "date": "2015-11-24T22:09:17Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2015-11-24T22:09:17Z"}, "message": "frame-header-opt.c (gate): Check for optimize > 0.\n\n2015-11-24  Steve Ellcey  <sellcey@imgtec.com>\n\n\t* frame-header-opt.c (gate): Check for optimize > 0.\n\t(has_inlined_assembly): New function.\n\t(needs_frame_header_p): Remove is_leaf_function check,\n\tadd argument type check.\n\t(callees_functions_use_frame_header): Add is_leaf_function\n\tand has_inlined_assembly calls..\n\t(set_callers_may_not_allocate_frame): New function.\n\t(frame_header_opt): Add is_leaf_function call, add\n\tset_callers_may_not_allocate_frame call.\n\t* config/mips/mips.c (mips_compute_frame_info): Add check\n\tto see if callee saved regs can be put in frame header.\n\t(mips_expand_prologue): Add check to see if step1 is zero,\n\tfix cfa restores when using frame header to store regs.\n\t(mips_can_use_return_insn): Check to see if registers are\n\tstored in frame header.\n\t* config/mips/mips.h (machine_function): Add\n\tcallers_may_not_allocate_frame and\n\tuse_frame_header_for_callee_saved_regs fields.\n\nFrom-SVN: r230845", "tree": {"sha": "d775617303374cc385017da3d28ab40d68469aa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d775617303374cc385017da3d28ab40d68469aa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/comments", "author": null, "committer": null, "parents": [{"sha": "82ad51444ff2a9faf3e019b07c98fbae0e753a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ad51444ff2a9faf3e019b07c98fbae0e753a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ad51444ff2a9faf3e019b07c98fbae0e753a0f"}], "stats": {"total": 169, "additions": 153, "deletions": 16}, "files": [{"sha": "30ff440cd0520c66665204791ab2695b8e387ae6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "patch": "@@ -1,3 +1,24 @@\n+2015-11-24  Steve Ellcey  <sellcey@imgtec.com>\n+\n+\t* frame-header-opt.c (gate): Check for optimize > 0.\n+\t(has_inlined_assembly): New function.\n+\t(needs_frame_header_p): Remove is_leaf_function check,\n+\tadd argument type check.\n+\t(callees_functions_use_frame_header): Add is_leaf_function\n+\tand has_inlined_assembly calls..\n+\t(set_callers_may_not_allocate_frame): New function.\n+\t(frame_header_opt): Add is_leaf_function call, add\n+\tset_callers_may_not_allocate_frame call.\n+\t* config/mips/mips.c (mips_compute_frame_info): Add check\n+\tto see if callee saved regs can be put in frame header.\n+\t(mips_expand_prologue): Add check to see if step1 is zero,\n+\tfix cfa restores when using frame header to store regs.\n+\t(mips_can_use_return_insn): Check to see if registers are\n+\tstored in frame header.\n+\t* config/mips/mips.h (machine_function): Add\n+\tcallers_may_not_allocate_frame and\n+\tuse_frame_header_for_callee_saved_regs fields.\n+\n 2015-11-24  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/68520"}, {"sha": "b80aa4db032b1b0536c0fdee73422c5df3d934bb", "filename": "gcc/config/mips/frame-header-opt.c", "status": "modified", "additions": 81, "deletions": 7, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2Fconfig%2Fmips%2Fframe-header-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2Fconfig%2Fmips%2Fframe-header-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fframe-header-opt.c?ref=0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "patch": "@@ -79,7 +79,7 @@ class pass_ipa_frame_header_opt : public ipa_opt_pass_d\n       /* This optimization has no affect if TARGET_NEWABI.   If optimize\n          is not at least 1 then the data needed for the optimization is\n          not available and nothing will be done anyway.  */\n-      return TARGET_OLDABI && flag_frame_header_optimization;\n+      return TARGET_OLDABI && flag_frame_header_optimization && optimize > 0;\n     }\n \n   virtual unsigned int execute (function *) { return frame_header_opt (); }\n@@ -125,6 +125,29 @@ is_leaf_function (function *fn)\n   return true;\n }\n \n+/* Return true if this function has inline assembly code or if we cannot\n+   be certain that it does not.  False if we know that there is no inline\n+   assembly.  */\n+\n+static bool\n+has_inlined_assembly (function *fn)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+\n+  /* If we do not have a cfg for this function be conservative and assume\n+     it is may have inline assembly.  */\n+  if (fn->cfg == NULL)\n+    return true;\n+\n+  FOR_EACH_BB_FN (bb, fn)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      if (gimple_code (gsi_stmt (gsi)) == GIMPLE_ASM)\n+\treturn true;\n+\n+  return false;\n+}\n+\n /* Return true if this function will use the stack space allocated by its\n    caller or if we cannot determine for certain that it does not.  */\n \n@@ -136,20 +159,26 @@ needs_frame_header_p (function *fn)\n   if (fn->decl == NULL)\n     return true;\n \n-  if (fn->stdarg || !is_leaf_function (fn))\n+  if (fn->stdarg)\n     return true;\n \n   for (t = DECL_ARGUMENTS (fn->decl); t; t = TREE_CHAIN (t))\n     {\n       if (!use_register_for_decl (t))\n-\t  return true;\n+\treturn true;\n+\n+      /* Some 64-bit types may get copied to general registers using the frame\n+\t header, see mips_output_64bit_xfer.  Checking for SImode only may be\n+         overly restrictive but it is guaranteed to be safe. */\n+      if (DECL_MODE (t) != SImode)\n+\treturn true;\n     }\n \n   return false;\n }\n \n-/* Returns TRUE if the argument stack space allocated by function FN is used.\n-   Returns FALSE if the space is needed or if the need for the space cannot\n+/* Return true if the argument stack space allocated by function FN is used.\n+   Return false if the space is needed or if the need for the space cannot\n    be determined.  */\n \n static bool\n@@ -177,6 +206,8 @@ callees_functions_use_frame_header (function *fn)\n \t          called_fn = DECL_STRUCT_FUNCTION (called_fn_tree);\n \t\t  if (called_fn == NULL\n \t\t      || DECL_WEAK (called_fn_tree) \n+\t\t      || has_inlined_assembly (called_fn)\n+\t\t      || !is_leaf_function (called_fn)\n \t\t      || !called_fn->machine->does_not_use_frame_header)\n \t\t    return true;\n \t        }\n@@ -188,6 +219,41 @@ callees_functions_use_frame_header (function *fn)\n   return false;\n }\n \n+/* Set the callers_may_not_allocate_frame flag for any function which\n+   function FN calls because FN may not allocate a frame header.  */\n+\n+static void\n+set_callers_may_not_allocate_frame (function *fn)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  gimple *stmt;\n+  tree called_fn_tree;\n+  function *called_fn;\n+\n+  if (fn->cfg == NULL)\n+    return;\n+\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_call (stmt))\n+\t    {\n+\t      called_fn_tree = gimple_call_fndecl (stmt);\n+\t      if (called_fn_tree != NULL)\n+\t        {\n+\t          called_fn = DECL_STRUCT_FUNCTION (called_fn_tree);\n+\t\t  if (called_fn != NULL)\n+\t\t    called_fn->machine->callers_may_not_allocate_frame = true;\n+\t        }\n+            }\n+        }\n+    }\n+  return;\n+}\n+\n /* Scan each function to determine those that need its frame headers.  Perform\n    a second scan to determine if the allocation can be skipped because none of\n    their callees require the frame header.  */\n@@ -209,8 +275,16 @@ frame_header_opt ()\n     {\n       fn = node->get_fun ();\n       if (fn != NULL)\n-        fn->machine->optimize_call_stack\n-\t  = !callees_functions_use_frame_header (fn);\n+\tfn->machine->optimize_call_stack\n+\t  = !callees_functions_use_frame_header (fn) && !is_leaf_function (fn);\n     }\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    {\n+      fn = node->get_fun ();\n+      if (fn != NULL && fn->machine->optimize_call_stack)\n+\tset_callers_may_not_allocate_frame (fn);\n+    }\n+\n   return 0;\n }"}, {"sha": "eeb80eb1abb73ba48c45172cd719bb4e6bf338ec", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "patch": "@@ -10474,6 +10474,35 @@ mips_compute_frame_info (void)\n       frame->cop0_sp_offset = offset - UNITS_PER_WORD;\n     }\n \n+  /* Determine if we can save the callee-saved registers in the frame\n+     header.  Restrict this to functions where there is no other reason\n+     to allocate stack space so that we can eliminate the instructions\n+     that modify the stack pointer.  */\n+\n+  if (TARGET_OLDABI\n+      && optimize > 0\n+      && flag_frame_header_optimization\n+      && !MAIN_NAME_P (DECL_NAME (current_function_decl))\n+      && cfun->machine->varargs_size == 0\n+      && crtl->args.pretend_args_size == 0\n+      && frame->var_size == 0\n+      && frame->num_acc == 0\n+      && frame->num_cop0_regs == 0\n+      && frame->num_fp == 0\n+      && frame->num_gp > 0\n+      && frame->num_gp <= MAX_ARGS_IN_REGISTERS\n+      && !GENERATE_MIPS16E_SAVE_RESTORE\n+      && !cfun->machine->interrupt_handler_p\n+      && cfun->machine->does_not_use_frame_header\n+      && cfun->machine->optimize_call_stack\n+      && !cfun->machine->callers_may_not_allocate_frame\n+      && !mips_cfun_has_cprestore_slot_p ())\n+    {\n+      offset = 0;\n+      frame->gp_sp_offset = REG_PARM_STACK_SPACE(cfun) - UNITS_PER_WORD;\n+      cfun->machine->use_frame_header_for_callee_saved_regs = true;\n+    }\n+\n   /* Move above the callee-allocated varargs save area.  */\n   offset += MIPS_STACK_ALIGN (cfun->machine->varargs_size);\n   frame->arg_pointer_offset = offset;\n@@ -11592,12 +11621,15 @@ mips_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      rtx insn = gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\tGEN_INT (-step1));\n-\t      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n-\t      mips_frame_barrier ();\n-\t      size -= step1;\n+\t      if (step1 != 0)\n+\t\t{\n+\t\t  rtx insn = gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t\t    GEN_INT (-step1));\n+\t\t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n+\t\t  mips_frame_barrier ();\n+\t\t  size -= step1;\n+\t\t}\n \t    }\n \t  mips_for_each_saved_acc (size, mips_save_reg);\n \t  mips_for_each_saved_gpr_and_fpr (size, mips_save_reg);\n@@ -11722,9 +11754,9 @@ mips_epilogue_emit_cfa_restores (void)\n   rtx_insn *insn;\n \n   insn = get_last_insn ();\n-  gcc_assert (insn && !REG_NOTES (insn));\n   if (mips_epilogue.cfa_restores)\n     {\n+      gcc_assert (insn && !REG_NOTES (insn));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       REG_NOTES (insn) = mips_epilogue.cfa_restores;\n       mips_epilogue.cfa_restores = 0;\n@@ -11975,7 +12007,9 @@ mips_expand_epilogue (bool sibcall_p)\n \tmips_deallocate_stack (stack_pointer_rtx, GEN_INT (step2), 0);\n     }\n \n-  if (!use_jraddiusp_p)\n+  if (cfun->machine->use_frame_header_for_callee_saved_regs)\n+    mips_epilogue_emit_cfa_restores ();\n+  else if (!use_jraddiusp_p)\n     gcc_assert (!mips_epilogue.cfa_restores);\n \n   /* Add in the __builtin_eh_return stack adjustment.  We need to\n@@ -12077,7 +12111,8 @@ mips_can_use_return_insn (void)\n   if (mips16_cfun_returns_in_fpr_p ())\n     return false;\n \n-  return cfun->machine->frame.total_size == 0;\n+  return (cfun->machine->frame.total_size == 0\n+\t  && !cfun->machine->use_frame_header_for_callee_saved_regs);\n }\n \f\n /* Return true if register REGNO can store a value of mode MODE."}, {"sha": "7a4a0ba59a0f8531a7b09e48daaf41d8fbfb68fd", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0bfbc1662bc4aa9bcdc00b6a20e3cb9d23be0efe", "patch": "@@ -3273,6 +3273,13 @@ struct GTY(())  machine_function {\n   /* True if none of the functions that are called by this function need\n      stack space allocated for their arguments.  */\n   bool optimize_call_stack;\n+\n+  /* True if one of the functions calling this function may not allocate\n+     a frame header.  */\n+  bool callers_may_not_allocate_frame;\n+\n+  /* True if GCC stored callee saved registers in the frame header.  */\n+  bool use_frame_header_for_callee_saved_regs;\n };\n #endif\n "}]}