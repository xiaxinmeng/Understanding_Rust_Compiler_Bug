{"sha": "1f2d8f510f4e516803427373e1625991756d4d91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYyZDhmNTEwZjRlNTE2ODAzNDI3MzczZTE2MjU5OTE3NTZkNGQ5MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-07-11T15:48:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-07-11T15:48:51Z"}, "message": "mips.c (epilogue_reg_mentioned_p): Delete unused function.\n\n        * mips.c (epilogue_reg_mentioned_p): Delete unused function.\n        (mips_epilogue_delay_slots): Likewise.\n        (function_epilogue): Greatly simplify.\n        (mips_expand_epilogue): If we have a null prologue/epilogue,\n        then use a normal return insn.  Emit blockage insns before\n        stack pointer adjustments.\n        (mips_can_use_return_insn): Renamed from simple_epilogue_p.  All\n        callers changed.  Do not use return insns if $31 is live in the\n        function or if generating profiling information.\n        * mips.h (DELAY_SLOTS_FOR_EPILOGUE): Delete.\n        (ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n        * mips.md (return): Remove expander and change the pattern to\n        look like a standard \"return\" insn.\n        (return_internal): Show use of $31 explictly.\n        (epilogue expander): Enable.\n\nFrom-SVN: r14412", "tree": {"sha": "5e01199fcba309c34ef4cc3157abf0ce7fb2e7c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e01199fcba309c34ef4cc3157abf0ce7fb2e7c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f2d8f510f4e516803427373e1625991756d4d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2d8f510f4e516803427373e1625991756d4d91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f2d8f510f4e516803427373e1625991756d4d91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f2d8f510f4e516803427373e1625991756d4d91/comments", "author": null, "committer": null, "parents": [{"sha": "7a49a4fd7b45ce1c15859f6bd4ee46418310d8f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a49a4fd7b45ce1c15859f6bd4ee46418310d8f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a49a4fd7b45ce1c15859f6bd4ee46418310d8f1"}], "stats": {"total": 366, "additions": 44, "deletions": 322}, "files": [{"sha": "7ebb50836484311c3a0c6fee22d96aa8fc792646", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 13, "deletions": 269, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2d8f510f4e516803427373e1625991756d4d91/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2d8f510f4e516803427373e1625991756d4d91/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1f2d8f510f4e516803427373e1625991756d4d91", "patch": "@@ -4729,71 +4729,6 @@ mips_output_float (stream, value)\n #endif\n }\n \n-\f\n-/* Return TRUE if any register used in the epilogue is used.  This to insure\n-   any insn put into the epilogue delay slots is safe.  */\n-\n-int\n-epilogue_reg_mentioned_p (insn)\n-     rtx insn;\n-{\n-  register char *fmt;\n-  register int i;\n-  register enum rtx_code code;\n-  register int regno;\n-\n-  if (insn == (rtx)0)\n-    return 0;\n-\n-  if (GET_CODE (insn) == LABEL_REF)\n-    return 0;\n-\n-  code = GET_CODE (insn);\n-  switch (code)\n-    {\n-    case REG:\n-      regno = REGNO (insn);\n-      if (regno == STACK_POINTER_REGNUM)\n-\treturn 1;\n-\n-      if (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\n-\treturn 1;\n-\n-      if (!call_used_regs[regno])\n-\treturn 1;\n-\n-      if (regno != MIPS_TEMP1_REGNUM && regno != MIPS_TEMP2_REGNUM)\n-\treturn 0;\n-\n-      if (!current_frame_info.initialized)\n-\tcompute_frame_size (get_frame_size ());\n-\n-      return (current_frame_info.total_size >= 32768);\n-\n-    case SCRATCH:\n-    case CC0:\n-    case PC:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return 0;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = XVECLEN (insn, i) - 1; j >= 0; j--)\n-\t    if (epilogue_reg_mentioned_p (XVECEXP (insn, i, j)))\n-\t      return 1;\n-\t}\n-      else if (fmt[i] == 'e' && epilogue_reg_mentioned_p (XEXP (insn, i)))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n \f\n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.\n@@ -5525,170 +5460,6 @@ function_epilogue (file, size)\n      int size;\n {\n   char *fnname;\n-  long tsize;\n-  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-  char *t1_str = reg_names[MIPS_TEMP1_REGNUM];\n-  rtx epilogue_delay = current_function_epilogue_delay_list;\n-  int noreorder = (epilogue_delay != 0);\n-  int noepilogue = FALSE;\n-  int load_nop = FALSE;\n-  int load_only_r31;\n-  rtx tmp_rtx = (rtx)0;\n-  rtx restore_rtx;\n-  int i;\n-\n-  /* The epilogue does not depend on any registers, but the stack\n-     registers, so we assume that if we have 1 pending nop, it can be\n-     ignored, and 2 it must be filled (2 nops occur for integer\n-     multiply and divide).  */\n-\n-  if (dslots_number_nops > 0)\n-    {\n-      if (dslots_number_nops == 1)\n-\t{\n-\t  dslots_number_nops = 0;\n-\t  dslots_load_filled++;\n-\t}\n-      else\n-\t{\n-\t  while (--dslots_number_nops > 0)\n-\t    fputs (\"\\t#nop\\n\", asm_out_file);\n-\t}\n-    }\n-\n-  if (set_noat != 0)\n-    {\n-      set_noat = 0;\n-      fputs (\"\\t.set\\tat\\n\", file);\n-      error (\"internal gcc error: .set noat left on in epilogue\");\n-    }\n-\n-  if (set_nomacro != 0)\n-    {\n-      set_nomacro = 0;\n-      fputs (\"\\t.set\\tmacro\\n\", file);\n-      error (\"internal gcc error: .set nomacro left on in epilogue\");\n-    }\n-\n-  if (set_noreorder != 0)\n-    {\n-      set_noreorder = 0;\n-      fputs (\"\\t.set\\treorder\\n\", file);\n-      error (\"internal gcc error: .set noreorder left on in epilogue\");\n-    }\n-\n-  if (set_volatile != 0)\n-    {\n-      set_volatile = 0;\n-      fprintf (file, \"\\t%s.set\\tnovolatile\\n\", (TARGET_MIPS_AS) ? \"\" : \"#\");\n-      error (\"internal gcc error: .set volatile left on in epilogue\");\n-    }\n-\n-  size = MIPS_STACK_ALIGN (size);\n-  tsize = (!current_frame_info.initialized)\n-\t\t? compute_frame_size (size)\n-\t\t: current_frame_info.total_size;\n-\n-  if (tsize == 0 && epilogue_delay == 0)\n-    {\n-      rtx insn = get_last_insn ();\n-\n-      /* If the last insn was a BARRIER, we don't have to write any code\n-\t because a jump (aka return) was put there.  */\n-      if (GET_CODE (insn) == NOTE)\n-\tinsn = prev_nonnote_insn (insn);\n-      if (insn && GET_CODE (insn) == BARRIER)\n-\tnoepilogue = TRUE;\n-\n-      noreorder = FALSE;\n-    }\n-\n-  if (!noepilogue)\n-    {\n-      /* In the reload sequence, we don't need to fill the load delay\n-\t slots for most of the loads, also see if we can fill the final\n-\t delay slot if not otherwise filled by the reload sequence.  */\n-\n-      if (noreorder)\n-\tfprintf (file, \"\\t.set\\tnoreorder\\n\");\n-\n-      if (tsize > 32767)\n-\t{\n-\t  fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\", t1_str, (long)tsize, (long)tsize);\n-\t  tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n-\t}\n-\n-      if (frame_pointer_needed)\n-\tfprintf (file, \"\\tmove\\t%s,%s\\t\\t\\t# sp not trusted here\\n\",\n-\t\t sp_str, reg_names[FRAME_POINTER_REGNUM]);\n-\n-      save_restore_insns (FALSE, tmp_rtx, tsize, file);\n-\n-      load_only_r31 = (((current_frame_info.mask\n-\t\t\t & ~ (TARGET_ABICALLS && mips_abi == ABI_32\n-\t\t\t      ? PIC_OFFSET_TABLE_MASK : 0))\n-\t\t\t== RA_MASK)\n-\t\t       && current_frame_info.fmask == 0);\n-\n-      if (noreorder)\n-\t{\n-\t  /* If the only register saved is the return address, we need a\n-\t     nop, unless we have an instruction to put into it.  Otherwise\n-\t     we don't since reloading multiple registers doesn't reference\n-\t     the register being loaded.  */\n-\n-\t  if (load_only_r31)\n-\t    {\n-\t      if (epilogue_delay)\n-\t\t  final_scan_insn (XEXP (epilogue_delay, 0),\n-\t\t\t\t   file,\n-\t\t\t\t   1,\t \t\t/* optimize */\n-\t\t\t\t   -2,\t \t\t/* prescan */\n-\t\t\t\t   1);\t\t\t/* nopeepholes */\n-\t      else\n-\t\t{\n-\t\t  fprintf (file, \"\\tnop\\n\");\n-\t\t  load_nop = TRUE;\n-\t\t}\n-\t    }\n-\n-\t  fprintf (file, \"\\tj\\t%s\\n\", reg_names[GP_REG_FIRST + 31]);\n-\n-\t  if (tsize > 32767)\n-\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n-\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n-\t\t     sp_str, sp_str, t1_str);\n-\n-\t  else if (tsize > 0)\n-\t    fprintf (file, \"\\t%s\\t%s,%s,%d\\n\",\n-\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n-\t\t     sp_str, sp_str, tsize);\n-\n-\t  else if (!load_only_r31 && epilogue_delay != 0)\n-\t    final_scan_insn (XEXP (epilogue_delay, 0),\n-\t\t\t     file,\n-\t\t\t     1, \t\t/* optimize */\n-\t\t\t     -2, \t\t/* prescan */\n-\t\t\t     1);\t\t/* nopeepholes */\n-\n-\t  fprintf (file, \"\\t.set\\treorder\\n\");\n-\t}\n-\n-      else\n-\t{\n-\t  if (tsize > 32767)\n-\t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n-\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n-\t\t     sp_str, sp_str, t1_str);\n-\n-\t  else if (tsize > 0)\n-\t    fprintf (file, \"\\t%s\\t%s,%s,%d\\n\",\n-\t\t     TARGET_LONG64 ? \"daddu\" : \"addu\",\n-\t\t     sp_str, sp_str, tsize);\n-\n-\t  fprintf (file, \"\\tj\\t%s\\n\", reg_names[GP_REG_FIRST + 31]);\n-\t}\n-    }\n \n #ifndef FUNCTION_NAME_ALREADY_DECLARED\n   /* Get the function name the same way that toplev.c does before calling\n@@ -5713,23 +5484,6 @@ function_epilogue (file, size)\n \n       dslots_load_total += num_regs;\n \n-      if (!noepilogue)\n-\tdslots_jump_total++;\n-\n-      if (noreorder)\n-\t{\n-\t  dslots_load_filled += num_regs;\n-\n-\t  /* If the only register saved is the return register, we\n-\t     can't fill this register's delay slot.  */\n-\n-\t  if (load_only_r31 && epilogue_delay == 0)\n-\t    dslots_load_filled--;\n-\n-\t  if (tsize > 0 || (!load_only_r31 && epilogue_delay != 0))\n-\t    dslots_jump_filled++;\n-\t}\n-\n       fprintf (stderr,\n \t       \"%-20s fp=%c leaf=%c alloca=%c setjmp=%c stack=%4ld arg=%3ld reg=%2d/%d delay=%3d/%3dL %3d/%3dJ refs=%3d/%3d/%3d\",\n \t       name,\n@@ -5791,6 +5545,12 @@ mips_expand_epilogue ()\n   rtx tsize_rtx = GEN_INT (tsize);\n   rtx tmp_rtx = (rtx)0;\n \n+  if (mips_can_use_return_insn ())\n+    {\n+      emit_insn (gen_return ());\n+      return;\n+    }\n+\n   if (tsize > 32767)\n     {\n       tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n@@ -5802,6 +5562,7 @@ mips_expand_epilogue ()\n     {\n       if (frame_pointer_needed)\n \t{\n+\t  emit_insn (gen_blockage ());\n \t  if (TARGET_LONG64)\n \t    emit_insn (gen_movdi (stack_pointer_rtx, frame_pointer_rtx));\n \t  else\n@@ -5810,6 +5571,7 @@ mips_expand_epilogue ()\n \n       save_restore_insns (FALSE, tmp_rtx, tsize, (FILE *)0);\n \n+      emit_insn (gen_blockage ());\n       if (TARGET_LONG64)\n \temit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t       tsize_rtx));\n@@ -5818,28 +5580,7 @@ mips_expand_epilogue ()\n \t\t\t       tsize_rtx));\n     }\n \n-  emit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode, GP_REG_FIRST+31)));\n-}\n-\n-\f\n-/* Define the number of delay slots needed for the function epilogue.\n-\n-   On the mips, we need a slot if either no stack has been allocated,\n-   or the only register saved is the return register.  */\n-\n-int\n-mips_epilogue_delay_slots ()\n-{\n-  if (!current_frame_info.initialized)\n-    (void) compute_frame_size (get_frame_size ());\n-\n-  if (current_frame_info.total_size == 0)\n-    return 1;\n-\n-  if (current_frame_info.mask == RA_MASK && current_frame_info.fmask == 0)\n-    return 1;\n-\n-  return 0;\n+  emit_jump_insn (gen_return_internal ());\n }\n \n \f\n@@ -5848,11 +5589,14 @@ mips_epilogue_delay_slots ()\n    was created.  */\n \n int\n-simple_epilogue_p ()\n+mips_can_use_return_insn ()\n {\n   if (!reload_completed)\n     return 0;\n \n+  if (regs_ever_live[31] || profile_flag)\n+    return 0;\n+\n   if (current_frame_info.initialized)\n     return current_frame_info.total_size == 0;\n "}, {"sha": "74068d4497b4f420cbcc16c6da52226e6b8a6b91", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2d8f510f4e516803427373e1625991756d4d91/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2d8f510f4e516803427373e1625991756d4d91/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=1f2d8f510f4e516803427373e1625991756d4d91", "patch": "@@ -2241,22 +2241,6 @@ typedef struct mips_args {\n \n #define FUNCTION_EPILOGUE(FILE, SIZE) function_epilogue(FILE, SIZE)\n \n-/* Define the number of delay slots needed for the function epilogue.\n-\n-   On the mips, we need a slot if either no stack has been allocated,\n-   or the only register saved is the return register.  */\n-\n-#define DELAY_SLOTS_FOR_EPILOGUE mips_epilogue_delay_slots ()\n-\n-/* Define whether INSN can be placed in delay slot N for the epilogue.\n-   No references to the stack must be made, since on the MIPS, the\n-   delay slot is done after the stack has been cleaned up.  */\n-\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N)\t\t\t\t\\\n-  (get_attr_dslot (INSN) == DSLOT_NO\t\t\t\t\t\\\n-   && get_attr_length (INSN) == 1\t\t\t\t\t\\\n-   && ! epilogue_reg_mentioned_p (PATTERN (INSN)))\n-\n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n #define MUST_SAVE_REGISTER(regno) \\"}, {"sha": "770a91c97a3566deeb2c6cfaec1311dbf5c4c11a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f2d8f510f4e516803427373e1625991756d4d91/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f2d8f510f4e516803427373e1625991756d4d91/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=1f2d8f510f4e516803427373e1625991756d4d91", "patch": "@@ -6315,29 +6315,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n-;; Function return, only allow after optimization, so that we can\n-;; eliminate jumps to jumps if no stack space is used.\n-\n-;; (define_expand \"return\"\n-;;   [(set (pc) (reg:SI 31))]\n-;;   \"simple_epilogue_p ()\"\n-;;   \"\")\n-\n-(define_expand \"return\"\n-  [(parallel [(return)\n-\t      (use (reg:SI 31))])]\n-  \"simple_epilogue_p ()\"\n-  \"\")\n-\n-(define_insn \"return_internal\"\n-  [(parallel [(return)\n-              (use (match_operand:SI 0 \"register_operand\" \"d\"))])]\n-  \"\"\n-  \"%*j\\\\t%0\"\n-  [(set_attr \"type\"\t\"jump\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"1\")])\n-\n ;; Implement a switch statement when generating embedded PIC code.\n ;; Switches are implemented by `tablejump' when not using -membedded-pic.\n \n@@ -6448,21 +6425,38 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"0\")])\n \n-;; At present, don't expand the epilogue, reorg.c will clobber the\n-;; return register in compiling gen_lowpart (emit-rtl.c).\n-;; \n-;; (define_expand \"epilogue\"\n-;;   [(const_int 2)]\n-;;   \"\"\n-;;   \"\n-;; {\n-;;   if (mips_isa >= 0)            /* avoid unused code warnings */\n-;;     {\n-;;       mips_expand_epilogue ();\n-;;       DONE;\n-;;     }\n-;; }\")\n+(define_expand \"epilogue\"\n+  [(const_int 2)]\n+  \"\"\n+  \"\n+{\n+  if (mips_isa >= 0)            /* avoid unused code warnings */\n+    {\n+      mips_expand_epilogue ();\n+      DONE;\n+    }\n+}\")\n \n+;; Trivial return.  Make it look like a normal return insn as that\n+;; allows jump optimizations to work better .\n+(define_insn \"return\"\n+  [(return)]\n+  \"mips_can_use_return_insn ()\"\n+  \"%*j\\\\t$31\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+;; Normal return.\n+(define_insn \"return_internal\"\n+  [(use (reg:SI 31))\n+   (return)]\n+  \"\"\n+  \"%*j\\\\t$31\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"1\")])\n+  \n ;; When generating embedded PIC code we need to get the address of the\n ;; current function.  This specialized instruction does just that.\n "}]}