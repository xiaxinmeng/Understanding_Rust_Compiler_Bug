{"sha": "5b00f9d236e181c3ef427989126009f21243a007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwMGY5ZDIzNmUxODFjM2VmNDI3OTg5MTI2MDA5ZjIxMjQzYTAwNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-02-03T19:16:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-02-03T19:16:39Z"}, "message": "re PR tree-optimization/79327 (wrong code at -O2 and -fprintf-return-value)\n\n\tPR tree-optimization/79327\n\t* gimple-ssa-sprintf.c (adjust_range_for_overflow): If returning\n\ttrue, always set *argmin and *argmax to TYPE_{MIN,MAX}_VALUE of\n\tdirtype.\n\t(format_integer): Use wide_int_to_tree instead of build_int_cst\n\t+ to_?hwi.  If argmin is NULL, just set argmin and argmax to\n\tTYPE_{MIN,MAX}_VALUE of argtype.  Simplify and fix computation\n\tof shortest and longest sequence.\n\n\t* gcc.dg/tree-ssa/pr79327.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c\n\t(test_sprintf_chk_hh_nonconst): Don't expect 2 bogus warnings.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c\n\t(test_sprintf_chk_range_schar): Adjust dg-message.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-12.c: New test.\n\t* gcc.c-torture/execute/pr79327.c: New test.\n\nCo-Authored-By: Martin Sebor <msebor@redhat.com>\n\nFrom-SVN: r245166", "tree": {"sha": "354ee345451eb296eb87adff9df1b1c87ad8b2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/354ee345451eb296eb87adff9df1b1c87ad8b2ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b00f9d236e181c3ef427989126009f21243a007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b00f9d236e181c3ef427989126009f21243a007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b00f9d236e181c3ef427989126009f21243a007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b00f9d236e181c3ef427989126009f21243a007/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b333e8ebb0d4b63acd52249b350de410e6f77e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b333e8ebb0d4b63acd52249b350de410e6f77e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b333e8ebb0d4b63acd52249b350de410e6f77e5f"}], "stats": {"total": 420, "additions": 341, "deletions": 79}, "files": [{"sha": "70e37c17d03a1518ca07fbc37a1da93db7ad788f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -1,3 +1,14 @@\n+2017-02-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79327\n+\t* gimple-ssa-sprintf.c (adjust_range_for_overflow): If returning\n+\ttrue, always set *argmin and *argmax to TYPE_{MIN,MAX}_VALUE of\n+\tdirtype.\n+\t(format_integer): Use wide_int_to_tree instead of build_int_cst\n+\t+ to_?hwi.  If argmin is NULL, just set argmin and argmax to\n+\tTYPE_{MIN,MAX}_VALUE of argtype.  Simplify and fix computation\n+\tof shortest and longest sequence.\n+\n 2017-02-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (dimode_scalar_chain::convert_reg):"}, {"sha": "ac4e959ed3c1114cab542e212b32f4dd719420bb", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 30, "deletions": 76, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -1014,8 +1014,8 @@ get_int_range (tree arg, tree type, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n    determined by checking for the actual argument being in the range\n    of the type of the directive.  If it isn't it must be assumed to\n    take on the full range of the directive's type.\n-   Return true when the range has been adjusted to the full unsigned\n-   range of DIRTYPE, or [0, DIRTYPE_MAX], and false otherwise.  */\n+   Return true when the range has been adjusted to the full range\n+   of DIRTYPE, and false otherwise.  */\n \n static bool\n adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n@@ -1051,20 +1051,8 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n \treturn false;\n     }\n \n-  tree dirmin = TYPE_MIN_VALUE (dirtype);\n-  tree dirmax = TYPE_MAX_VALUE (dirtype);\n-\n-  if (TYPE_UNSIGNED (dirtype))\n-    {\n-      *argmin = dirmin;\n-      *argmax = dirmax;\n-    }\n-  else\n-    {\n-      *argmin = integer_zero_node;\n-      *argmax = dirmin;\n-    }\n-\n+  *argmin = TYPE_MIN_VALUE (dirtype);\n+  *argmax = TYPE_MAX_VALUE (dirtype);\n   return true;\n }\n \n@@ -1260,10 +1248,8 @@ format_integer (const directive &dir, tree arg)\n       enum value_range_type range_type = get_range_info (arg, &min, &max);\n       if (range_type == VR_RANGE)\n \t{\n-\t  argmin = build_int_cst (argtype, wi::fits_uhwi_p (min)\n-\t\t\t\t  ? min.to_uhwi () : min.to_shwi ());\n-\t  argmax = build_int_cst (argtype, wi::fits_uhwi_p (max)\n-\t\t\t\t  ? max.to_uhwi () : max.to_shwi ());\n+\t  argmin = wide_int_to_tree (argtype, min);\n+\t  argmax = wide_int_to_tree (argtype, max);\n \n \t  /* Set KNOWNRANGE if the argument is in a known subrange\n \t     of the directive's type (KNOWNRANGE may be reset below).  */\n@@ -1307,47 +1293,16 @@ format_integer (const directive &dir, tree arg)\n \n   if (!argmin)\n     {\n-      /* For an unknown argument (e.g., one passed to a vararg function)\n-\t or one whose value range cannot be determined, create a T_MIN\n-\t constant if the argument's type is signed and T_MAX otherwise,\n-\t and use those to compute the range of bytes that the directive\n-\t can output.  When precision may be zero, use zero as the minimum\n-\t since it results in no bytes on output (unless width is specified\n-\t to be greater than 0).  */\n-      bool zero = dir.prec[0] <= 0 && dir.prec[1] >= 0;\n-      argmin = build_int_cst (argtype, !zero);\n-\n-      int typeprec = TYPE_PRECISION (dirtype);\n-      int argprec = TYPE_PRECISION (argtype);\n-\n-      if (argprec < typeprec)\n-\t{\n-\t  if (POINTER_TYPE_P (argtype))\n-\t    argmax = build_all_ones_cst (argtype);\n-\t  else if (TYPE_UNSIGNED (argtype))\n-\t    argmax = TYPE_MAX_VALUE (argtype);\n-\t  else\n-\t    argmax = TYPE_MIN_VALUE (argtype);\n+      if (TREE_CODE (argtype) == POINTER_TYPE)\n+\t{\n+\t  argmin = build_int_cst (pointer_sized_int_node, 0);\n+\t  argmax = build_all_ones_cst (pointer_sized_int_node);\n \t}\n       else\n \t{\n-\t  if (POINTER_TYPE_P (dirtype))\n-\t    argmax = build_all_ones_cst (dirtype);\n-\t  else if (TYPE_UNSIGNED (dirtype))\n-\t    argmax = TYPE_MAX_VALUE (dirtype);\n-\t  else\n-\t    argmax = TYPE_MIN_VALUE (dirtype);\n+\t  argmin = TYPE_MIN_VALUE (argtype);\n+\t  argmax = TYPE_MAX_VALUE (argtype);\n \t}\n-\n-      res.argmin = argmin;\n-      res.argmax = argmax;\n-    }\n-\n-  if (tree_int_cst_lt (argmax, argmin))\n-    {\n-      tree tmp = argmax;\n-      argmax = argmin;\n-      argmin = tmp;\n     }\n \n   /* Clear KNOWNRANGE if the range has been adjusted to the maximum\n@@ -1361,34 +1316,33 @@ format_integer (const directive &dir, tree arg)\n       res.argmax = argmax;\n     }\n \n-  /* Recursively compute the minimum and maximum from the known range,\n-     taking care to swap them if the lower bound results in longer\n-     output than the upper bound (e.g., in the range [-1, 0].  */\n-\n-  if (TYPE_UNSIGNED (dirtype))\n+  /* Recursively compute the minimum and maximum from the known range.  */\n+  if (TYPE_UNSIGNED (dirtype) || tree_int_cst_sgn (argmin) >= 0)\n     {\n-      /* For unsigned conversions/directives, use the minimum (i.e., 0\n-\t or 1) and maximum to compute the shortest and longest output,\n-\t respectively.  */\n+      /* For unsigned conversions/directives or signed when\n+\t the minimum is positive, use the minimum and maximum to compute\n+\t the shortest and longest output, respectively.  */\n       res.range.min = format_integer (dir, argmin).range.min;\n       res.range.max = format_integer (dir, argmax).range.max;\n     }\n-  else\n+  else if (tree_int_cst_sgn (argmax) < 0)\n     {\n-      /* For signed conversions/directives, use the maximum (i.e., 0)\n-\t to compute the shortest output and the minimum (i.e., TYPE_MIN)\n-\t to compute the longest output.  This is important when precision\n-\t is specified but unknown because otherwise both output lengths\n-\t would reflect the largest possible precision (i.e., INT_MAX).  */\n+      /* For signed conversions/directives if maximum is negative,\n+\t use the minimum as the longest output and maximum as the\n+\t shortest output.  */\n       res.range.min = format_integer (dir, argmax).range.min;\n       res.range.max = format_integer (dir, argmin).range.max;\n     }\n-\n-  if (res.range.max < res.range.min)\n+  else\n     {\n-      unsigned HOST_WIDE_INT tmp = res.range.max;\n-      res.range.max = res.range.min;\n-      res.range.min = tmp;\n+      /* Otherwise, 0 is inside of the range and minimum negative.  Use 0\n+\t as the shortest output and for the longest output compute the\n+\t length of the output of both minimum and maximum and pick the\n+\t longer.  */\n+      unsigned HOST_WIDE_INT max1 = format_integer (dir, argmin).range.max;\n+      unsigned HOST_WIDE_INT max2 = format_integer (dir, argmax).range.max;\n+      res.range.min = format_integer (dir, integer_zero_node).range.min;\n+      res.range.max = MAX (max1, max2);\n     }\n \n   res.range.likely = res.knownrange ? res.range.max : res.range.min;"}, {"sha": "7a34cfeb6dba5d5e99ccec86b0598ddb9d71d306", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -1,3 +1,15 @@\n+2017-02-03  Jakub Jelinek  <jakub@redhat.com>\n+\t    Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/79327\n+\t* gcc.dg/tree-ssa/pr79327.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c\n+\t(test_sprintf_chk_hh_nonconst): Don't expect 2 bogus warnings.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c\n+\t(test_sprintf_chk_range_schar): Adjust dg-message.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-12.c: New test.\n+\t* gcc.c-torture/execute/pr79327.c: New test.\n+\n 2017-02-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/79354"}, {"sha": "6d12b47f27de49a65637b4e86ff193bd1feda595", "filename": "gcc/testsuite/gcc.c-torture/execute/pr79327.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr79327.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr79327.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr79327.c?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/79327 */\n+/* { dg-require-effective-target c99_runtime } */\n+\n+volatile int a;\n+\n+int\n+main (void)\n+{\n+  int i;\n+  char buf[64];\n+  if (__builtin_sprintf (buf, \"%#hho\", a) != 1)\n+    __builtin_abort ();\n+  if (__builtin_sprintf (buf, \"%#hhx\", a) != 1)\n+    __builtin_abort ();\n+  a = 1;\n+  if (__builtin_sprintf (buf, \"%#hho\", a) != 2)\n+    __builtin_abort ();\n+  if (__builtin_sprintf (buf, \"%#hhx\", a) != 3)\n+    __builtin_abort ();\n+  a = 127;\n+  if (__builtin_sprintf (buf, \"%#hho\", a) != 4)\n+    __builtin_abort ();\n+  if (__builtin_sprintf (buf, \"%#hhx\", a) != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "fef9578921d07af4588e6a80f4847674a9d46bdd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -1151,8 +1151,8 @@ void test_sprintf_chk_hh_nonconst (int w, int p, int a)\n   T (2, \"% hhu\",        a);     /* { dg-warning \". . flag used with .%u.\" } */\n   T (2, \"% hhx\",        a);     /* { dg-warning \". . flag used with .%x.\" } */\n \n-  T (2, \"%#hho\",        a);     /* { dg-warning \"nul past the end\" } */\n-  T (2, \"%#hhx\",        a);     /* { dg-warning \".%#hhx. directive writing between 3 and . bytes into a region of size 2\" } */\n+  T (2, \"%#hho\",        a);\n+  T (2, \"%#hhx\",        a);\n \n   T (3, \"%0hhd\",        a);\n   T (3, \"%1hhd\",        a);"}, {"sha": "bdea46f3d0317c411f103125966daac492f07b5a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-12.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-12.c?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -0,0 +1,228 @@\n+/* PR tree-optimization/79327 - wrong code at -O2 and -fprintf-return-value\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-overflow=1 -ftrack-macro-expansion=0\" }\n+   { dg-require-effective-target int32plus } */\n+\n+typedef __SIZE_TYPE__  size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-INT_MAX - 1)\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+void sink (char*, char*);\n+\n+int dummy_sprintf (char*, const char*, ...);\n+\n+char buffer [256];\n+extern char *ptr;\n+\n+int int_range (int min, int max)\n+{\n+  extern int int_value (void);\n+  int n = int_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+unsigned uint_range (unsigned min, unsigned max)\n+{\n+  extern unsigned uint_value (void);\n+  unsigned n = uint_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+/* Evaluate to an array of SIZE characters when non-negative, or to\n+   a pointer to an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\\\n+  ((0 <= size) ? buffer + sizeof buffer - (size) : ptr)\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define FUNC(f)\t\t\t\t\t\t\t\\\n+  ((!LINE || LINE == __LINE__) ? __builtin_ ## f : dummy_ ## f)\n+\n+/* Macro to verify that calls to __builtin_sprintf (i.e., with no size\n+   argument) issue diagnostics by correctly determining the size of\n+   the destination buffer.  */\n+#define T(size, ...)\t\t\t\t\t\t\\\n+  (FUNC (sprintf) (buffer (size),  __VA_ARGS__),\t\t\\\n+   sink (buffer, ptr))\n+\n+/* Return a signed integer in the range [MIN, MAX].  */\n+#define R(min, max)  int_range (min, max)\n+\n+/* Return a unsigned integer in the range [MIN, MAX].  */\n+#define U(min, max)  uint_range (min, max)\n+\n+/* Exercise the hh length modifier with ranges.  */\n+void test_hh (void)\n+{\n+  T (0, \"%hhi\", R (  -1,    0));    /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%hhi\", R (  -1,    1));    /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%hhi\", R (  -1,   12));    /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%hhi\", R (  -1,  123));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhi\", R (  -1,  128));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (  -1,  257));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (  -1, 1234));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,  -11));    /* { dg-warning \"writing 3 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,   -1));    /* { dg-warning \"between 2 and 3 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,    0));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,    1));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,   12));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,  123));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,  128));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R ( -12,  257));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R ( -12, 1234));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R ( -99,  -10));    /* { dg-warning \"writing 3 bytes\" } */\n+  T (0, \"%hhi\", R (-123,   -1));    /* { dg-warning \"between 2 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-123,    0));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-123,    1));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-123,   12));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-123,  123));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-123,  257));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-123, 1234));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-129,    1));    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hhi\", R (-130, -129));    /* { dg-warning \"writing 3 bytes\" } */\n+\n+  T (0, \"%hhi\", U (   0,  127));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+\n+  /* The following results in either \"127\" and \"-128\" so the ideal result\n+     should be \"between 3 and 4 bytes\" but because of the overflow from\n+     128 to -128 in the %hhi directive the input range is reset to that\n+     of char, or [CHAR_MIN, CHAR_MAX], and the warning reflects that.  */\n+  T (0, \"%hhi\", U ( 127,  128));    /* { dg-warning \"between \\[13\\] and 4 bytes\" } */\n+  /* The following results in either \"-128\" or \"-127\".  */\n+  T (0, \"%hhi\", U ( 128,  129));    /* { dg-warning \"writing 4 bytes\" } */\n+  /* The following results in between \"-128\" and \"-99\".  */\n+  T (0, \"%hhi\", U ( 128,  157));    /* { dg-warning \"writing between 3 and 4 bytes\" } */\n+  /* Between \"-128\" and \"-1\".  */\n+  T (0, \"%hhi\", U ( 128,  255));    /* { dg-warning \"writing between 2 and 4 bytes\" } */\n+  /* Between \"-128\" and \"0\".  */\n+  T (0, \"%hhi\", U ( 128,  256));    /* { dg-warning \"writing between 1 and 4 bytes\" } */\n+  /* Between \"-128\" and \"\" (zero formats as nothing with zero precision).  */\n+  T (0, \"%.0hhi\", U ( 128,  256));  /* { dg-warning \"writing up to 4 bytes\" } */\n+  /* Same as above but with a range of precisions including zero.  */\n+  T (0, \"%.*hhi\",                   /* { dg-warning \"writing up to 4 bytes\" } */\n+     R (0, 1), U ( 128,  256));\n+  /* Same as above but with a positive range of precisions.  */\n+  T (0, \"%.*hhi\",                   /* { dg-warning \"between 1 and 4 bytes\" } */\n+     R (1, 2), U ( 128,  256));\n+  /* Precision range includes zero but width is non-zero so output cannot\n+     be empty.  */\n+  T (0, \"%1.*hhi\",                  /* { dg-warning \"between 1 and 4 bytes\" } */\n+     R (0, 2), U ( 128,  256));\n+  /* Same as above but with a width range.  */\n+  T (0, \"%*.*hhi\",                  /* { dg-warning \"between 1 and 4 bytes\" } */\n+     R (1, 2), R (0, 2), U ( 128,  256));\n+  /* Same as above but this time width range does include zero.  */\n+  T (0, \"%*.*hhi\",                  /* { dg-warning \"up to 4 bytes\" } */\n+     R (0, 2), R (0, 2), U ( 128,  256));\n+\n+  /* Range of precisions in excess of the number of digits and sign.  */\n+  T (0, \"%.*hhi\",                   /* { dg-warning \"between 5 and 8 bytes\" } */\n+     R (5, 7), U ( 128,  256));\n+\n+  /* Between \"-128\" and \"+0\".  */\n+  T (0, \"%+hhi\",  U ( 128,  256));  /* { dg-warning \"between 2 and 4 bytes\" } */\n+  /* Between \"-128\" and \" 0\".  */\n+  T (0, \"% hhi\",  U ( 128,  256));  /* { dg-warning \"between 2 and 4 bytes\" } */\n+\n+  T (0, \"%hhu\", R (  -1,    1));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (  -1,   12));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (  -1,  123));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (  -1,  128));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (  -1,  257));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (  -1, 1234));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R ( -12,    1));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R ( -12,   12));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R ( -12,  123));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R ( -12,  128));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R ( -12,  257));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R ( -12, 1234));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-123,    1));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-123,   12));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-123,  123));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-123,  257));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-123, 1234));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-129,    1));    /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hhu\", R (-199, -159));    /* { dg-warning \"writing 2 bytes\" } */\n+  T (0, \"%hhu\", R (-255, -250));    /* { dg-warning \"writing 1 byte\" } */\n+}\n+\n+/* Exercise the h length modifier.  */\n+void test_h (void)\n+{\n+  T (0, \"%hi\", R (    -1,     0));  /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%hi\", R (     0,     1));  /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%hi\", R (    -1,     1));  /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%hi\", R (    -1,    12));  /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%hi\", R (   -12,     1));  /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%hi\", R (   -99,   -10));  /* { dg-warning \"writing 3 bytes\" } */\n+  T (0, \"%hi\", R (  -123,     4));  /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%hi\", R ( -1234,    56));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hi\", R ( -1234,   567));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hi\", R ( -1234,  5678));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%ho\", R (-32768,-32767));  /* { dg-warning \"writing 6 bytes\" } */\n+\n+  T (0, \"%ho\", R (    -1,     0));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R (     0,     1));  /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%ho\", R (    -1,     1));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R (    -1,    12));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R (   -12,     1));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R (  -123,     4));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R ( -1234,    56));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R ( -1234,   567));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R ( -1234,  5678));  /* { dg-warning \"between 1 and 6 bytes\" } */\n+  T (0, \"%ho\", R (-32768,-32767));  /* { dg-warning \"writing 6 bytes\" } */\n+\n+  T (0, \"%hu\", R (    -1,     0));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R (     0,     1));  /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%hu\", R (    -1,     1));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R (    -1,    12));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R (   -12,     1));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R (  -123,     4));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R ( -1234,    56));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R ( -1234,   567));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R ( -1234,  5678));  /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%hu\", R (-32768,-32767));  /* { dg-warning \"writing 5 bytes\" } */\n+\n+  T (0, \"%hx\", R (-32768,-32767));  /* { dg-warning \"writing 4 bytes\" } */\n+}\n+\n+/* Exercise integer directives with no length modifier.  */\n+void test_diou (void)\n+{\n+  T (0, \"%d\", R (    -1,     0));   /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%i\", R (     0,     1));   /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%d\", R (    -1,     1));   /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%i\", R (    -1,    12));   /* { dg-warning \"between 1 and 2 bytes\" } */\n+  T (0, \"%d\", R (   -12,     1));   /* { dg-warning \"between 1 and 3 bytes\" } */\n+  T (0, \"%i\", R (  -123,     4));   /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (0, \"%d\", R ( -1234,    56));   /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%i\", R ( -1234,   567));   /* { dg-warning \"between 1 and 5 bytes\" } */\n+  T (0, \"%d\", R ( -1234,  5678));   /* { dg-warning \"between 1 and 5 bytes\" } */\n+\n+  T (0, \"%u\", R (    -1,     0));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R (     0,     1));  /* { dg-warning \"writing 1 byte\" } */\n+  T (0, \"%u\", R (    -1,     1));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R (    -1,    12));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R (   -12,     1));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R (  -123,     4));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R ( -1234,    56));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R ( -1234,   567));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+  T (0, \"%u\", R ( -1234,  5678));  /* { dg-warning \"between 1 and 10 bytes\" } */\n+\n+  T (0, \"%o\", R (    -1,     0));  /* { dg-warning \"between 1 and 11 bytes\" } */\n+  T (0, \"%o\", R (    -2,     1));  /* { dg-warning \"between 1 and 11 bytes\" } */\n+  T (0, \"%o\", R (     0,     1));  /* { dg-warning \"writing 1 byte\" } */\n+\n+  T (0, \"%x\", R (    -1,     0));  /* { dg-warning \"between 1 and 8 bytes\" } */\n+  T (0, \"%x\", R (    -2,     1));  /* { dg-warning \"between 1 and 8 bytes\" } */\n+  T (0, \"%x\", R (     0,     1));  /* { dg-warning \"writing 1 byte\" } */\n+}"}, {"sha": "c4f7e1f5d22b2cd90f9fd417854de0b0af442f02", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -198,7 +198,7 @@ void test_sprintf_chk_range_schar (void)\n   /* { dg-message \"directive argument in the range \\\\\\[1024, 1034\\\\\\]\" \"note\" { target *-*-* } .-1 } */\n \n   T ( 0, \"%hhi\", R (1024, 2035));   /* { dg-warning \".%hhi. directive writing between 1 and 4 bytes into a region of size 0\" } */\n-  /* { dg-message \"using the range \\\\\\[0, -128\\\\\\] for directive argument\" \"note\" { target *-*-* } .-1 } */\n+  /* { dg-message \"using the range \\\\\\[-128, 127\\\\\\] for directive argument\" \"note\" { target *-*-* } .-1 } */\n \n #undef R\n #define R(min, max) range_schar (min, max)"}, {"sha": "7db875d5cdf86c3e6c55d0aa9c6f37fc854c42ae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79327.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79327.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b00f9d236e181c3ef427989126009f21243a007/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79327.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79327.c?ref=5b00f9d236e181c3ef427989126009f21243a007", "patch": "@@ -0,0 +1,31 @@\n+/* PR tree-optimization/79327 - wrong code at -O2 and -fprintf-return-value\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" }  */\n+\n+volatile int a, b = -1;\n+char buf[64];\n+\n+#define FMT \"%+03d%02d\"\n+const char *volatile fmt = FMT;\n+\n+int main ()\n+{\n+  int c = a;\n+  int d = b;\n+  if (c >= -35791395 && c < 35791394 && d >= -1 && d < __INT_MAX__)\n+    {\n+      /* In the following the range of return values can be computed\n+\t by GCC. */\n+      int n1 = __builtin_sprintf (buf, FMT, c + 1, d + 1);\n+      if (n1 > 7)\n+\t__builtin_abort ();\n+\n+      /* Here GCC can't see the format string so the return value\n+\t must be computed by a libc call.  */\n+      int n2 = __builtin_sprintf (buf, fmt, c + 1, d + 1);\n+\n+      if (n1 != n2)\n+\t__builtin_abort ();\n+    }\n+  return 0;\n+}"}]}