{"sha": "11924f8b487dc3feb882f08b195bbcbfbacfd96d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE5MjRmOGI0ODdkYzNmZWI4ODJmMDhiMTk1YmJjYmZiYWNmZDk2ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-15T14:48:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-15T14:48:22Z"}, "message": "re PR middle-end/50262 (PTA doesn't disambiguate locally allocated heap objects from pointed to by arguments)\n\n2013-11-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/50262\n\t* tree-ssa-alias.h (struct pt_solution): Split\n\tvars_contains_global into vars_contains_nonlocal,\n\tvars_contains_escaped and vars_contains_escaped_heap.\n\t* tree-ssa-structalias.c (label_visit): Expand comment.\n\t(handle_lhs_call): Adjust comment.\n\t(set_uids_in_ptset): Set the new flags appropriately.\n\t(pt_solution_set): Adjust.\n\t(pt_solution_set_var): Likewise.\n\t(pt_solution_ior_into): Likewise.\n\t(pt_solution_includes_global): Likewise.\n\t(pt_solutions_intersect_1): Optimize escaped handling.\n\t(compute_points_to_sets): Remove heap variable globalization.\n\t(ipa_escaped_pt): Adjust initializer.\n\t(pass_data_ipa_pta): Do not run TODO_update_ssa.\n\t* gimple-pretty-print.c (pp_points_to_solution): Print split\n\tflags.\n\t* tree-ssa-alias.c (dump_points_to_solution): Likewise.\n\n\t* gcc.dg/tree-ssa/alias-28.c: New testcase.\n\t* gcc.dg/strlenopt-1.c: Adjust.\n\t* gcc.dg/strlenopt-1f.c: Likewise.\n\nFrom-SVN: r204845", "tree": {"sha": "14c2118dc537f4635438cc32c9d55e790d891b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14c2118dc537f4635438cc32c9d55e790d891b3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11924f8b487dc3feb882f08b195bbcbfbacfd96d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11924f8b487dc3feb882f08b195bbcbfbacfd96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11924f8b487dc3feb882f08b195bbcbfbacfd96d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11924f8b487dc3feb882f08b195bbcbfbacfd96d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e179190c0366ca882d4f7bcc33ea42d1cdcfed22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e179190c0366ca882d4f7bcc33ea42d1cdcfed22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e179190c0366ca882d4f7bcc33ea42d1cdcfed22"}], "stats": {"total": 205, "additions": 153, "deletions": 52}, "files": [{"sha": "697a5c61dc04a71a00009fbdcca6bfc06d62a132", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -1,3 +1,24 @@\n+2013-11-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50262\n+\t* tree-ssa-alias.h (struct pt_solution): Split\n+\tvars_contains_global into vars_contains_nonlocal,\n+\tvars_contains_escaped and vars_contains_escaped_heap.\n+\t* tree-ssa-structalias.c (label_visit): Expand comment.\n+\t(handle_lhs_call): Adjust comment.\n+\t(set_uids_in_ptset): Set the new flags appropriately.\n+\t(pt_solution_set): Adjust.\n+\t(pt_solution_set_var): Likewise.\n+\t(pt_solution_ior_into): Likewise.\n+\t(pt_solution_includes_global): Likewise.\n+\t(pt_solutions_intersect_1): Optimize escaped handling.\n+\t(compute_points_to_sets): Remove heap variable globalization.\n+\t(ipa_escaped_pt): Adjust initializer.\n+\t(pass_data_ipa_pta): Do not run TODO_update_ssa.\n+\t* gimple-pretty-print.c (pp_points_to_solution): Print split\n+\tflags.\n+\t* tree-ssa-alias.c (dump_points_to_solution): Likewise.\n+\n 2013-11-15  Richard Biener  <rguenther@suse.de>\n \n \t* tree-loop-distribution.c (tree_loop_distribution): Make sure"}, {"sha": "26d59d14b359d67915a83b39d0feadd0d719aeae", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -622,8 +622,18 @@ pp_points_to_solution (pretty_printer *buffer, struct pt_solution *pt)\n \t  pp_space (buffer);\n \t}\n       pp_right_brace (buffer);\n-      if (pt->vars_contains_global)\n-\tpp_string (buffer, \" (glob)\");\n+      if (pt->vars_contains_nonlocal\n+\t  && pt->vars_contains_escaped_heap)\n+\tpp_string (buffer, \" (nonlocal, escaped heap)\");\n+      else if (pt->vars_contains_nonlocal\n+\t       && pt->vars_contains_escaped)\n+\tpp_string (buffer, \" (nonlocal, escaped)\");\n+      else if (pt->vars_contains_nonlocal)\n+\tpp_string (buffer, \" (nonlocal)\");\n+      else if (pt->vars_contains_escaped_heap)\n+\tpp_string (buffer, \" (escaped heap)\");\n+      else if (pt->vars_contains_escaped)\n+\tpp_string (buffer, \" (escaped)\");\n     }\n }\n "}, {"sha": "e5f6c89a7255ed31c1e7d98ef62eefe8422b8fc4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -1,3 +1,10 @@\n+2013-11-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50262\n+\t* gcc.dg/tree-ssa/alias-28.c: New testcase.\n+\t* gcc.dg/strlenopt-1.c: Adjust.\n+\t* gcc.dg/strlenopt-1f.c: Likewise.\n+\n 2013-11-15  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/torture/20131115-1.c: New testcase."}, {"sha": "5ed5be1f927534f0639281c74d3ec9eebeca6267", "filename": "gcc/testsuite/gcc.dg/strlenopt-1.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -16,9 +16,7 @@ foo (char *p, char *r)\n      is immediately overwritten.  */\n   strcat (q, \"/\");\n   strcat (q, \"abcde\");\n-  /* Due to inefficient PTA (PR50262) the above calls invalidate\n-     string length of r, so it is optimized just into strcpy instead\n-     of memcpy.  */\n+  /* This can also be optimized into memcpy.  */\n   strcat (q, r);\n   return q;\n }\n@@ -39,8 +37,8 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */"}, {"sha": "e0a2c926ca2778543f88f0e907f61fb7b8ef3a3f", "filename": "gcc/testsuite/gcc.dg/strlenopt-1f.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -6,8 +6,8 @@\n #include \"strlenopt-1.c\"\n \n /* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 3 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */"}, {"sha": "8413230eaf46e61b71aaeb8f1d7d6e0c55c40112", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-28.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-28.c?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3\" } */\n+\n+extern void abort (void);\n+extern void *malloc(__SIZE_TYPE__);\n+\n+int * __attribute__((noinline,noclone))\n+foo (int *p)\n+{\n+  int *q = (int *) malloc (sizeof (int));\n+  *p = 1;\n+  *q = 2;\n+  if (*p != 1)\n+    __link_error ();\n+  *p = 3;\n+  return q;\n+}\n+\n+int main()\n+{\n+  int i;\n+  int *p = foo (&i);\n+  if (i != 3 || *p != 2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "a33b122d274d2e79d626a6bf8ce0da38cdd915dc", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -452,8 +452,18 @@ dump_points_to_solution (FILE *file, struct pt_solution *pt)\n     {\n       fprintf (file, \", points-to vars: \");\n       dump_decl_set (file, pt->vars);\n-      if (pt->vars_contains_global)\n-\tfprintf (file, \" (includes global vars)\");\n+      if (pt->vars_contains_nonlocal\n+\t  && pt->vars_contains_escaped_heap)\n+\tfprintf (file, \" (nonlocal, escaped heap)\");\n+      else if (pt->vars_contains_nonlocal\n+\t       && pt->vars_contains_escaped)\n+\tfprintf (file, \" (nonlocal, escaped)\");\n+      else if (pt->vars_contains_nonlocal)\n+\tfprintf (file, \" (nonlocal)\");\n+      else if (pt->vars_contains_escaped_heap)\n+\tfprintf (file, \" (escaped heap)\");\n+      else if (pt->vars_contains_escaped)\n+\tfprintf (file, \" (escaped)\");\n     }\n }\n "}, {"sha": "44485bdd041958749adbcc2eba5d3b6e32efea53", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -48,9 +48,13 @@ struct GTY(()) pt_solution\n   unsigned int null : 1;\n \n \n-  /* Nonzero if the pt_vars bitmap includes a global variable.  */\n-  unsigned int vars_contains_global : 1;\n-\n+  /* Nonzero if the vars bitmap includes a variable included in 'nonlocal'.  */\n+  unsigned int vars_contains_nonlocal : 1;\n+  /* Nonzero if the vars bitmap includes a variable included in 'escaped'.  */\n+  unsigned int vars_contains_escaped : 1;\n+  /* Nonzero if the vars bitmap includes a anonymous heap variable that\n+     escaped the function and thus became global.  */\n+  unsigned int vars_contains_escaped_heap : 1;\n \n   /* Set of variables that this pointer may point to.  */\n   bitmap vars;"}, {"sha": "481b9fe0ee12acbc4e568b8890b6921a65ffe03f", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11924f8b487dc3feb882f08b195bbcbfbacfd96d/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=11924f8b487dc3feb882f08b195bbcbfbacfd96d", "patch": "@@ -2063,7 +2063,24 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n     si->scc_stack.safe_push (n);\n }\n \n-/* Label pointer equivalences.  */\n+/* Label pointer equivalences.\n+\n+   This performs a value numbering of the constraint graph to\n+   discover which variables will always have the same points-to sets\n+   under the current set of constraints.\n+\n+   The way it value numbers is to store the set of points-to bits\n+   generated by the constraints and graph edges.  This is just used as a\n+   hash and equality comparison.  The *actual set of points-to bits* is\n+   completely irrelevant, in that we don't care about being able to\n+   extract them later.\n+\n+   The equality values (currently bitmaps) just have to satisfy a few\n+   constraints, the main ones being:\n+   1. The combining operation must be order independent.\n+   2. The end result of a given set of operations must be unique iff the\n+      combination of input values is unique\n+   3. Hashable.  */\n \n static void\n label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n@@ -3979,8 +3996,8 @@ handle_lhs_call (gimple stmt, tree lhs, int flags, vec<ce_s> rhsc,\n       struct constraint_expr tmpc;\n       rhsc.create (0);\n       vi = make_heapvar (\"HEAP\");\n-      /* We delay marking allocated storage global until we know if\n-         it escapes.  */\n+      /* We marking allocated storage local, we deal with it becoming\n+         global by escaping and setting of vars_contains_escaped_heap.  */\n       DECL_EXTERNAL (vi->decl) = 0;\n       vi->is_global_var = 0;\n       /* If this is not a real malloc call assume the memory was\n@@ -5983,6 +6000,9 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n+  varinfo_t escaped_vi = get_varinfo (find (escaped_id));\n+  bool everything_escaped\n+    = escaped_vi->solution && bitmap_bit_p (escaped_vi->solution, anything_id);\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n@@ -5993,6 +6013,14 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n       if (vi->is_artificial_var && !vi->is_heap_var)\n \tcontinue;\n \n+      if (everything_escaped\n+\t  || (escaped_vi->solution\n+\t      && bitmap_bit_p (escaped_vi->solution, i)))\n+\t{\n+\t  pt->vars_contains_escaped = true;\n+\t  pt->vars_contains_escaped_heap = vi->is_heap_var;\n+\t}\n+\n       if (TREE_CODE (vi->decl) == VAR_DECL\n \t  || TREE_CODE (vi->decl) == PARM_DECL\n \t  || TREE_CODE (vi->decl) == RESULT_DECL)\n@@ -6007,7 +6035,7 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n \t     set contains global variables.  */\n \t  bitmap_set_bit (into, DECL_PT_UID (vi->decl));\n \t  if (vi->is_global_var)\n-\t    pt->vars_contains_global = true;\n+\t    pt->vars_contains_nonlocal = true;\n \t}\n     }\n }\n@@ -6164,11 +6192,15 @@ pt_solution_reset (struct pt_solution *pt)\n    it contains restrict tag variables.  */\n \n void\n-pt_solution_set (struct pt_solution *pt, bitmap vars, bool vars_contains_global)\n+pt_solution_set (struct pt_solution *pt, bitmap vars,\n+\t\t bool vars_contains_nonlocal)\n {\n   memset (pt, 0, sizeof (struct pt_solution));\n   pt->vars = vars;\n-  pt->vars_contains_global = vars_contains_global;\n+  pt->vars_contains_nonlocal = vars_contains_nonlocal;\n+  pt->vars_contains_escaped\n+    = (cfun->gimple_df->escaped.anything\n+       || bitmap_intersect_p (cfun->gimple_df->escaped.vars, vars));\n }\n \n /* Set the points-to solution *PT to point only to the variable VAR.  */\n@@ -6179,7 +6211,10 @@ pt_solution_set_var (struct pt_solution *pt, tree var)\n   memset (pt, 0, sizeof (struct pt_solution));\n   pt->vars = BITMAP_GGC_ALLOC ();\n   bitmap_set_bit (pt->vars, DECL_PT_UID (var));\n-  pt->vars_contains_global = is_global_var (var);\n+  pt->vars_contains_nonlocal = is_global_var (var);\n+  pt->vars_contains_escaped\n+    = (cfun->gimple_df->escaped.anything\n+       || bitmap_bit_p (cfun->gimple_df->escaped.vars, DECL_PT_UID (var)));\n }\n \n /* Computes the union of the points-to solutions *DEST and *SRC and\n@@ -6202,7 +6237,9 @@ pt_solution_ior_into (struct pt_solution *dest, struct pt_solution *src)\n   dest->escaped |= src->escaped;\n   dest->ipa_escaped |= src->ipa_escaped;\n   dest->null |= src->null;\n-  dest->vars_contains_global |= src->vars_contains_global;\n+  dest->vars_contains_nonlocal |= src->vars_contains_nonlocal;\n+  dest->vars_contains_escaped |= src->vars_contains_escaped;\n+  dest->vars_contains_escaped_heap |= src->vars_contains_escaped_heap;\n   if (!src->vars)\n     return;\n \n@@ -6259,9 +6296,14 @@ pt_solution_includes_global (struct pt_solution *pt)\n {\n   if (pt->anything\n       || pt->nonlocal\n-      || pt->vars_contains_global)\n+      || pt->vars_contains_nonlocal\n+      /* The following is a hack to make the malloc escape hack work.\n+         In reality we'd need different sets for escaped-through-return\n+\t and escaped-to-callees and passes would need to be updated.  */\n+      || pt->vars_contains_escaped_heap)\n     return true;\n \n+  /* 'escaped' is also a placeholder so we have to look into it.  */\n   if (pt->escaped)\n     return pt_solution_includes_global (&cfun->gimple_df->escaped);\n \n@@ -6331,28 +6373,19 @@ pt_solutions_intersect_1 (struct pt_solution *pt1, struct pt_solution *pt2)\n      any global memory they alias.  */\n   if ((pt1->nonlocal\n        && (pt2->nonlocal\n-\t   || pt2->vars_contains_global))\n+\t   || pt2->vars_contains_nonlocal))\n       || (pt2->nonlocal\n-\t  && pt1->vars_contains_global))\n+\t  && pt1->vars_contains_nonlocal))\n     return true;\n \n-  /* Check the escaped solution if required.  */\n-  if ((pt1->escaped || pt2->escaped)\n-      && !pt_solution_empty_p (&cfun->gimple_df->escaped))\n-    {\n-      /* If both point to escaped memory and that solution\n-\t is not empty they alias.  */\n-      if (pt1->escaped && pt2->escaped)\n-\treturn true;\n-\n-      /* If either points to escaped memory see if the escaped solution\n-\t intersects with the other.  */\n-      if ((pt1->escaped\n-\t   && pt_solutions_intersect_1 (&cfun->gimple_df->escaped, pt2))\n-\t  || (pt2->escaped\n-\t      && pt_solutions_intersect_1 (&cfun->gimple_df->escaped, pt1)))\n-\treturn true;\n-    }\n+  /* If either points to all escaped memory and the other points to\n+     any escaped memory they alias.  */\n+  if ((pt1->escaped\n+       && (pt2->escaped\n+\t   || pt2->vars_contains_escaped))\n+      || (pt2->escaped\n+\t  && pt1->vars_contains_escaped))\n+    return true;\n \n   /* Check the escaped solution if required.\n      ???  Do we need to check the local against the IPA escaped sets?  */\n@@ -6800,14 +6833,6 @@ compute_points_to_sets (void)\n      points-to solution queries.  */\n   cfun->gimple_df->escaped.escaped = 0;\n \n-  /* Mark escaped HEAP variables as global.  */\n-  FOR_EACH_VEC_ELT (varmap, i, vi)\n-    if (vi\n-\t&& vi->is_heap_var\n-\t&& !vi->is_global_var)\n-      DECL_EXTERNAL (vi->decl) = vi->is_global_var\n-\t= pt_solution_includes (&cfun->gimple_df->escaped, vi->decl);\n-\n   /* Compute the points-to sets for pointer SSA_NAMEs.  */\n   for (i = 0; i < num_ssa_names; ++i)\n     {\n@@ -7054,7 +7079,7 @@ gate_ipa_pta (void)\n \n /* IPA PTA solutions for ESCAPED.  */\n struct pt_solution ipa_escaped_pt\n-  = { true, false, false, false, false, false, NULL };\n+  = { true, false, false, false, false, false, false, false, NULL };\n \n /* Associate node with varinfo DATA. Worker for\n    cgraph_for_node_and_aliases.  */\n@@ -7412,7 +7437,7 @@ const pass_data pass_data_ipa_pta =\n   0, /* properties_provided */\n   0, /* properties_destroyed */\n   0, /* todo_flags_start */\n-  TODO_update_ssa, /* todo_flags_finish */\n+  0, /* todo_flags_finish */\n };\n \n class pass_ipa_pta : public simple_ipa_opt_pass"}]}