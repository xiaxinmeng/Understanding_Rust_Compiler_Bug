{"sha": "be80a87ee585150cfdd94304848350a2c6d3e0bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU4MGE4N2VlNTg1MTUwY2ZkZDk0MzA0ODQ4MzUwYTJjNmQzZTBiZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-04-30T10:06:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-04-30T10:06:18Z"}, "message": "dwarf2.h (DW_OP_GNU_const_type, [...]): New.\n\n\t* dwarf2.h (DW_OP_GNU_const_type, DW_OP_GNU_regval_type,\n\tDW_OP_GNU_deref_type, DW_OP_GNU_convert, DW_OP_GNU_reinterpret): New.\n\n\t* dwarf2out.c (get_address_mode): New inline.\n\t(mem_loc_descriptor): Add MEM_MODE parameter, adjust recursive calls,\n\tif not dwarf_strict emit\n\tDW_OP_GNU_{{const,regval,deref}_type,convert,reinterpret} when\n\tdesirable.  Handle FLOAT_EXTEND, FLOAT_TRUNCATE, FLOAT,\n\tUNSIGNED_FLOAT, FIX and UNSIGNED_FIX.  Just return NULL for\n\tFMA, STRICT_LOW_PART, CONST_VECTOR and CONST_FIXED.\n\t(dwarf2out_frame_debug_cfa_expression, reg_loc_descriptor,\n\tdw_loc_list_1, cst_pool_loc_descr, loc_list_from_tree): Adjust\n\tmem_loc_descriptor callers.\n\t(dwarf_stack_op_name, size_of_loc_descr, output_loc_operands,\n\toutput_loc_operands_raw, hash_loc_operands, compare_loc_operands):\n\tHandle DW_OP_GNU_const_type, DW_OP_GNU_regval_type,\n\tDW_OP_GNU_deref_type, DW_OP_GNU_convert and DW_OP_GNU_reinterpret.\n\t(base_types): New variable.\n\t(get_base_type_offset, calc_base_type_die_sizes,\n\tbase_type_for_mode, mark_base_types, base_type_cmp,\n\tmove_marked_base_types): New functions.\n\t(calc_die_sizes): Assert that die_offset is 0 or equal to\n\tnext_die_offset.\n\t(loc_descriptor): Only handle here lowpart SUBREGs of REG, for\n\tothers defer to mem_loc_descriptor.  Adjust mem_loc_descriptor\n\tcallers.  If not dwarf_strict, call mem_loc_descriptor even for\n\tnon-MODE_INT modes or MODE_INT modes larger than DWARF2_ADDR_SIZE.\n\t(gen_subprogram_die): Don't give up on call site parameters\n\twith non-integral or large integral modes.  Adjust\n\tmem_loc_descriptor callers.\n\t(prune_unused_types): Call prune_unused_types_mark on base_types\n\tvector entries.\n\t(resolve_addr): Call mark_base_types.\n\t(dwarf2out_finish): Call move_marked_base_types.\n\nFrom-SVN: r173210", "tree": {"sha": "d20094cddcd86128f1e2df5a1d93f33d9cbcbdb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d20094cddcd86128f1e2df5a1d93f33d9cbcbdb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be80a87ee585150cfdd94304848350a2c6d3e0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be80a87ee585150cfdd94304848350a2c6d3e0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be80a87ee585150cfdd94304848350a2c6d3e0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be80a87ee585150cfdd94304848350a2c6d3e0bd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "edb9b69e5730fc6584899297bf5688282de6a1c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edb9b69e5730fc6584899297bf5688282de6a1c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edb9b69e5730fc6584899297bf5688282de6a1c7"}], "stats": {"total": 1279, "additions": 1049, "deletions": 230}, "files": [{"sha": "0655cf644a76954d16559d336757ccd51a8acee3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be80a87ee585150cfdd94304848350a2c6d3e0bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be80a87ee585150cfdd94304848350a2c6d3e0bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be80a87ee585150cfdd94304848350a2c6d3e0bd", "patch": "@@ -1,5 +1,37 @@\n 2011-04-30  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.c (get_address_mode): New inline.\n+\t(mem_loc_descriptor): Add MEM_MODE parameter, adjust recursive calls,\n+\tif not dwarf_strict emit\n+\tDW_OP_GNU_{{const,regval,deref}_type,convert,reinterpret} when\n+\tdesirable.  Handle FLOAT_EXTEND, FLOAT_TRUNCATE, FLOAT,\n+\tUNSIGNED_FLOAT, FIX and UNSIGNED_FIX.  Just return NULL for\n+\tFMA, STRICT_LOW_PART, CONST_VECTOR and CONST_FIXED.\n+\t(dwarf2out_frame_debug_cfa_expression, reg_loc_descriptor,\n+\tdw_loc_list_1, cst_pool_loc_descr, loc_list_from_tree): Adjust\n+\tmem_loc_descriptor callers.\n+\t(dwarf_stack_op_name, size_of_loc_descr, output_loc_operands,\n+\toutput_loc_operands_raw, hash_loc_operands, compare_loc_operands):\n+\tHandle DW_OP_GNU_const_type, DW_OP_GNU_regval_type,\n+\tDW_OP_GNU_deref_type, DW_OP_GNU_convert and DW_OP_GNU_reinterpret.\n+\t(base_types): New variable.\n+\t(get_base_type_offset, calc_base_type_die_sizes,\n+\tbase_type_for_mode, mark_base_types, base_type_cmp,\n+\tmove_marked_base_types): New functions.\n+\t(calc_die_sizes): Assert that die_offset is 0 or equal to\n+\tnext_die_offset.\n+\t(loc_descriptor): Only handle here lowpart SUBREGs of REG, for\n+\tothers defer to mem_loc_descriptor.  Adjust mem_loc_descriptor\n+\tcallers.  If not dwarf_strict, call mem_loc_descriptor even for\n+\tnon-MODE_INT modes or MODE_INT modes larger than DWARF2_ADDR_SIZE.\n+\t(gen_subprogram_die): Don't give up on call site parameters\n+\twith non-integral or large integral modes.  Adjust\n+\tmem_loc_descriptor callers.\n+\t(prune_unused_types): Call prune_unused_types_mark on base_types\n+\tvector entries.\n+\t(resolve_addr): Call mark_base_types.\n+\t(dwarf2out_finish): Call move_marked_base_types.\n+\n \tPR tree-optimization/48809\n \t* tree-switch-conversion.c (build_arrays): Compute tidx in unsigned\n \ttype."}, {"sha": "83653d2984e9bd72c0601c4be26b07474dc9e435", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1005, "deletions": 230, "changes": 1235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be80a87ee585150cfdd94304848350a2c6d3e0bd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be80a87ee585150cfdd94304848350a2c6d3e0bd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=be80a87ee585150cfdd94304848350a2c6d3e0bd", "patch": "@@ -482,7 +482,8 @@ static struct dw_loc_descr_struct *build_cfa_aligned_loc\n   (HOST_WIDE_INT, HOST_WIDE_INT);\n static void def_cfa_1 (const char *, dw_cfa_location *);\n static struct dw_loc_descr_struct *mem_loc_descriptor\n-  (rtx, enum machine_mode mode, enum var_init_status);\n+  (rtx, enum machine_mode mode, enum machine_mode mem_mode,\n+   enum var_init_status);\n \n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n@@ -2053,6 +2054,17 @@ dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n   reg_save (label, sregno, dregno, 0);\n }\n \n+/* Helper function to get mode of MEM's address.  */\n+\n+static inline enum machine_mode\n+get_address_mode (rtx mem)\n+{\n+  enum machine_mode mode = GET_MODE (XEXP (mem, 0));\n+  if (mode != VOIDmode)\n+    return mode;\n+  return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n+}\n+\n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_EXPRESSION note. */\n \n static void\n@@ -2073,8 +2085,8 @@ dwarf2out_frame_debug_cfa_expression (rtx set, const char *label)\n   cfi->dw_cfi_opc = DW_CFA_expression;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = DWARF_FRAME_REGNUM (REGNO (src));\n   cfi->dw_cfi_oprnd2.dw_cfi_loc\n-    = mem_loc_descriptor (XEXP (dest, 0), GET_MODE (dest),\n-\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+    = mem_loc_descriptor (XEXP (dest, 0), get_address_mode (dest),\n+\t\t\t  GET_MODE (dest), VAR_INIT_STATUS_INITIALIZED);\n \n   /* ??? We'd like to use queue_reg_save, were the interface different,\n      and, as above, we could manage flushing for epilogues.  */\n@@ -4785,6 +4797,16 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_GNU_implicit_pointer\";\n     case DW_OP_GNU_entry_value:\n       return \"DW_OP_GNU_entry_value\";\n+    case DW_OP_GNU_const_type:\n+      return \"DW_OP_GNU_const_type\";\n+    case DW_OP_GNU_regval_type:\n+      return \"DW_OP_GNU_regval_type\";\n+    case DW_OP_GNU_deref_type:\n+      return \"DW_OP_GNU_deref_type\";\n+    case DW_OP_GNU_convert:\n+      return \"DW_OP_GNU_convert\";\n+    case DW_OP_GNU_reinterpret:\n+      return \"DW_OP_GNU_reinterpret\";\n \n     default:\n       return \"OP_<unknown>\";\n@@ -4892,6 +4914,7 @@ loc_list_plus_const (dw_loc_list_ref list_head, HOST_WIDE_INT offset)\n   (dwarf_version == 2 ? DWARF2_ADDR_SIZE : DWARF_OFFSET_SIZE)\n \n static unsigned long size_of_locs (dw_loc_descr_ref);\n+static unsigned long int get_base_type_offset (dw_die_ref);\n \n /* Return the size of a location descriptor.  */\n \n@@ -5014,6 +5037,50 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n \tsize += size_of_uleb128 (op_size) + op_size;\n \tbreak;\n       }\n+    case DW_OP_GNU_const_type:\n+      {\n+\tunsigned long o\n+\t  = get_base_type_offset (loc->dw_loc_oprnd1.v.val_die_ref.die);\n+\tsize += size_of_uleb128 (o) + 1;\n+\tswitch (loc->dw_loc_oprnd2.val_class)\n+\t  {\n+\t  case dw_val_class_vec:\n+\t    size += loc->dw_loc_oprnd2.v.val_vec.length\n+\t\t    * loc->dw_loc_oprnd2.v.val_vec.elt_size;\n+\t    break;\n+\t  case dw_val_class_const:\n+\t    size += HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT;\n+\t    break;\n+\t  case dw_val_class_const_double:\n+\t    size += 2 * HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+      }\n+    case DW_OP_GNU_regval_type:\n+      {\n+\tunsigned long o\n+\t  = get_base_type_offset (loc->dw_loc_oprnd2.v.val_die_ref.die);\n+\tsize += size_of_uleb128 (loc->dw_loc_oprnd1.v.val_unsigned)\n+\t\t+ size_of_uleb128 (o);\n+      }\n+      break;\n+    case DW_OP_GNU_deref_type:\n+      {\n+\tunsigned long o\n+\t  = get_base_type_offset (loc->dw_loc_oprnd2.v.val_die_ref.die);\n+\tsize += 1 + size_of_uleb128 (o);\n+      }\n+      break;\n+    case DW_OP_GNU_convert:\n+    case DW_OP_GNU_reinterpret:\n+      {\n+\tunsigned long o\n+\t  = get_base_type_offset (loc->dw_loc_oprnd1.v.val_die_ref.die);\n+\tsize += size_of_uleb128 (o);\n+      }\n     default:\n       break;\n     }\n@@ -5306,6 +5373,96 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n       output_loc_sequence (val1->v.val_loc, for_eh_or_skip);\n       break;\n \n+    case DW_OP_GNU_const_type:\n+      {\n+\tunsigned long o = get_base_type_offset (val1->v.val_die_ref.die), l;\n+\tgcc_assert (o);\n+\tdw2_asm_output_data_uleb128 (o, NULL);\n+\tswitch (val2->val_class)\n+\t  {\n+\t  case dw_val_class_const:\n+\t    l = HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;\n+\t    dw2_asm_output_data (1, l, NULL);\n+\t    dw2_asm_output_data (l, val2->v.val_int, NULL);\n+\t    break;\n+\t  case dw_val_class_vec:\n+\t    {\n+\t      unsigned int elt_size = val2->v.val_vec.elt_size;\n+\t      unsigned int len = val2->v.val_vec.length;\n+\t      unsigned int i;\n+\t      unsigned char *p;\n+\n+\t      l = len * elt_size;\n+\t      dw2_asm_output_data (1, l, NULL);\n+\t      if (elt_size > sizeof (HOST_WIDE_INT))\n+\t\t{\n+\t\t  elt_size /= 2;\n+\t\t  len *= 2;\n+\t\t}\n+\t      for (i = 0, p = val2->v.val_vec.array;\n+\t\t   i < len;\n+\t\t   i++, p += elt_size)\n+\t\tdw2_asm_output_data (elt_size, extract_int (p, elt_size),\n+\t\t\t\t     \"fp or vector constant word %u\", i);\n+\t    }\n+\t    break;\n+\t  case dw_val_class_const_double:\n+\t    {\n+\t      unsigned HOST_WIDE_INT first, second;\n+\t      l = HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;\n+\n+\t      dw2_asm_output_data (1, 2 * l, NULL);\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\t{\n+\t\t  first = val2->v.val_double.high;\n+\t\t  second = val2->v.val_double.low;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  first = val2->v.val_double.low;\n+\t\t  second = val2->v.val_double.high;\n+\t\t}\n+\t      dw2_asm_output_data (l, first, NULL);\n+\t      dw2_asm_output_data (l, second, NULL);\n+\t    }\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n+      break;\n+    case DW_OP_GNU_regval_type:\n+      {\n+\tunsigned r = val1->v.val_unsigned;\n+\tunsigned long o = get_base_type_offset (val2->v.val_die_ref.die);\n+\tgcc_assert (o);\n+\tif (for_eh_or_skip >= 0)\n+\t  {\n+\t    r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);\n+\t    gcc_assert (size_of_uleb128 (r)\n+\t\t\t== size_of_uleb128 (val1->v.val_unsigned));\n+\t  }\n+\tdw2_asm_output_data_uleb128 (r, NULL);\n+\tdw2_asm_output_data_uleb128 (o, NULL);\n+      }\n+      break;\n+    case DW_OP_GNU_deref_type:\n+      {\n+\tunsigned long o = get_base_type_offset (val2->v.val_die_ref.die);\n+\tgcc_assert (o);\n+\tdw2_asm_output_data (1, val1->v.val_int, NULL);\n+\tdw2_asm_output_data_uleb128 (o, NULL);\n+      }\n+      break;\n+    case DW_OP_GNU_convert:\n+    case DW_OP_GNU_reinterpret:\n+      {\n+\tunsigned long o = get_base_type_offset (val1->v.val_die_ref.die);\n+\tgcc_assert (o);\n+\tdw2_asm_output_data_uleb128 (o, NULL);\n+      }\n+      break;\n+\n     default:\n       /* Other codes have no operands.  */\n       break;\n@@ -5483,6 +5640,11 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n \n     case DW_OP_GNU_implicit_pointer:\n     case DW_OP_GNU_entry_value:\n+    case DW_OP_GNU_const_type:\n+    case DW_OP_GNU_regval_type:\n+    case DW_OP_GNU_deref_type:\n+    case DW_OP_GNU_convert:\n+    case DW_OP_GNU_reinterpret:\n       gcc_unreachable ();\n       break;\n \n@@ -6310,6 +6472,8 @@ static GTY(()) VEC(tree,gc) *generic_type_instances;\n    within the current function.  */\n static HOST_WIDE_INT frame_pointer_fb_offset;\n \n+static VEC (dw_die_ref, heap) *base_types;\n+\n /* Forward declarations for functions defined in this file.  */\n \n static int is_pseudo_reg (const_rtx);\n@@ -6442,6 +6606,7 @@ static void output_location_lists (dw_die_ref);\n static int constant_size (unsigned HOST_WIDE_INT);\n static unsigned long size_of_die (dw_die_ref);\n static void calc_die_sizes (dw_die_ref);\n+static void calc_base_type_die_sizes (void);\n static void mark_dies (dw_die_ref);\n static void unmark_dies (dw_die_ref);\n static void unmark_all_dies (dw_die_ref);\n@@ -6780,6 +6945,21 @@ get_ref_die_offset_label (char *label, dw_die_ref ref)\n   sprintf (label, \"%s+%ld\", debug_info_section_label, ref->die_offset);\n }\n \n+/* Return die_offset of a DIE reference to a base type.  */\n+\n+static unsigned long int\n+get_base_type_offset (dw_die_ref ref)\n+{\n+  if (ref->die_offset)\n+    return ref->die_offset;\n+  if (comp_unit_die ()->die_abbrev)\n+    {\n+      calc_base_type_die_sizes ();\n+      gcc_assert (ref->die_offset);\n+    }\n+  return ref->die_offset;\n+}\n+\n /* Convert a DIE tag into its string name.  */\n \n static const char *\n@@ -10811,6 +10991,8 @@ calc_die_sizes (dw_die_ref die)\n {\n   dw_die_ref c;\n \n+  gcc_assert (die->die_offset == 0\n+\t      || (unsigned long int) die->die_offset == next_die_offset);\n   die->die_offset = next_die_offset;\n   next_die_offset += size_of_die (die);\n \n@@ -10821,6 +11003,36 @@ calc_die_sizes (dw_die_ref die)\n     next_die_offset += 1;\n }\n \n+/* Size just the base type children at the start of the CU.\n+   This is needed because build_abbrev needs to size locs\n+   and sizing of type based stack ops needs to know die_offset\n+   values for the base types.  */\n+\n+static void\n+calc_base_type_die_sizes (void)\n+{\n+  unsigned long die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n+  unsigned int i;\n+  dw_die_ref base_type;\n+#if ENABLE_ASSERT_CHECKING\n+  dw_die_ref prev = comp_unit_die ()->die_child;\n+#endif\n+\n+  die_offset += size_of_die (comp_unit_die ());\n+  for (i = 0; VEC_iterate (dw_die_ref, base_types, i, base_type); i++)\n+    {\n+#if ENABLE_ASSERT_CHECKING\n+      gcc_assert (base_type->die_offset == 0\n+\t\t  && prev->die_sib == base_type\n+\t\t  && base_type->die_child == NULL\n+\t\t  && base_type->die_abbrev);\n+      prev = base_type;\n+#endif\n+      base_type->die_offset = die_offset;\n+      die_offset += size_of_die (base_type);\n+    }\n+}\n+\n /* Set the marks for a die and its children.  We do this so\n    that we know whether or not a reference needs to use FORM_ref_addr; only\n    DIEs in the same CU will be marked.  We used to clear out the offset\n@@ -13168,7 +13380,8 @@ reg_loc_descriptor (rtx rtl, enum var_init_status initialized)\n \n       if (dwarf_version >= 4 || !dwarf_strict)\n \t{\n-\t  result = mem_loc_descriptor (rtl, VOIDmode, initialized);\n+\t  result = mem_loc_descriptor (rtl, GET_MODE (rtl), VOIDmode,\n+\t\t\t\t       initialized);\n \t  if (result)\n \t    add_loc_descr (&result,\n \t\t\t   new_loc_descr (DW_OP_stack_value, 0, 0));\n@@ -13596,6 +13809,33 @@ const_ok_for_output (rtx rtl)\n   return true;\n }\n \n+/* Return a reference to DW_TAG_base_type corresponding to MODE and UNSIGNEDP\n+   if possible, NULL otherwise.  */\n+\n+static dw_die_ref\n+base_type_for_mode (enum machine_mode mode, bool unsignedp)\n+{\n+  dw_die_ref type_die;\n+  tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n+\n+  if (type == NULL)\n+    return NULL;\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+      break;\n+    default:\n+      return NULL;\n+    }\n+  type_die = lookup_type_die (type);\n+  if (!type_die)\n+    type_die = modified_type_die (type, false, false, comp_unit_die ());\n+  if (type_die == NULL || type_die->die_tag != DW_TAG_base_type)\n+    return NULL;\n+  return type_die;\n+}\n+\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a\n@@ -13606,35 +13846,41 @@ const_ok_for_output (rtx rtl)\n    equivalent.  This routine recursively descends an RTL tree, turning\n    it into Dwarf postfix code as it goes.\n \n-   MODE is the mode of the memory reference, needed to handle some\n-   autoincrement addressing modes.\n+   MODE is the mode that should be assumed for the rtl if it is VOIDmode.\n \n-   CAN_USE_FBREG is a flag whether we can use DW_AT_frame_base in the\n-   location list for RTL.\n+   MEM_MODE is the mode of the memory reference, needed to handle some\n+   autoincrement addressing modes.\n \n    Return 0 if we can't represent the location.  */\n \n static dw_loc_descr_ref\n mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t    enum machine_mode mem_mode,\n \t\t    enum var_init_status initialized)\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n   enum dwarf_location_atom op;\n   dw_loc_descr_ref op0, op1;\n \n+  if (mode == VOIDmode)\n+    mode = GET_MODE (rtl);\n+\n   /* Note that for a dynamically sized array, the location we will generate a\n      description of here will be the lowest numbered location which is\n      actually within the array.  That's *not* necessarily the same as the\n      zeroth element of the array.  */\n \n   rtl = targetm.delegitimize_address (rtl);\n \n+  if (mode != GET_MODE (rtl) && GET_MODE (rtl) != VOIDmode)\n+    return NULL;\n+\n   switch (GET_CODE (rtl))\n     {\n     case POST_INC:\n     case POST_DEC:\n     case POST_MODIFY:\n-      return mem_loc_descriptor (XEXP (rtl, 0), mode, initialized);\n+      return mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode, initialized);\n \n     case SUBREG:\n       /* The case of a subreg may arise when we have a local (register)\n@@ -13644,15 +13890,72 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t contains the given subreg.  */\n       if (!subreg_lowpart_p (rtl))\n \tbreak;\n-      rtl = SUBREG_REG (rtl);\n-      if (GET_MODE_SIZE (GET_MODE (rtl)) > DWARF2_ADDR_SIZE)\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (rtl))) == MODE_INT\n+\t  && GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE\n+\t  && GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl))) <= DWARF2_ADDR_SIZE)\n+\t{\n+\t  mem_loc_result = mem_loc_descriptor (SUBREG_REG (rtl),\n+\t\t\t\t\t       GET_MODE (SUBREG_REG (rtl)),\n+\t\t\t\t\t       mem_mode, initialized);\n+\t  break;\n+\t}\n+      if (dwarf_strict)\n+\tbreak;\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl))))\n \tbreak;\n-      if (GET_MODE_CLASS (GET_MODE (rtl)) != MODE_INT)\n+      if (GET_MODE_SIZE (mode) != GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl)))\n+\t  && (GET_MODE_CLASS (mode) != MODE_INT\n+\t      || GET_MODE_CLASS (GET_MODE (SUBREG_REG (rtl))) != MODE_INT))\n \tbreak;\n-      mem_loc_result = mem_loc_descriptor (rtl, mode, initialized);\n+      else\n+\t{\n+\t  dw_die_ref type_die;\n+\t  dw_loc_descr_ref cvt;\n+\n+\t  mem_loc_result = mem_loc_descriptor (SUBREG_REG (rtl),\n+\t\t\t\t\t       GET_MODE (SUBREG_REG (rtl)),\n+\t\t\t\t\t       mode, initialized);\n+\t  if (mem_loc_result == NULL)\n+\t    break;\n+\t  type_die = base_type_for_mode (mode, 0);\n+\t  if (type_die == NULL)\n+\t    {\n+\t      mem_loc_result = NULL;\n+\t      break;\n+\t    }\n+\t  if (GET_MODE_SIZE (mode)\n+\t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl))))\n+\t    cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  else\n+\t    cvt = new_loc_descr (DW_OP_GNU_reinterpret, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&mem_loc_result, cvt);\n+\t}\n       break;\n \n     case REG:\n+      if (GET_MODE_CLASS (mode) != MODE_INT\n+\t  || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+\t{\n+\t  dw_die_ref type_die;\n+\n+\t  if (dwarf_strict)\n+\t    break;\n+\t  if (REGNO (rtl) > FIRST_PSEUDO_REGISTER)\n+\t    break;\n+\t  type_die = base_type_for_mode (mode, 0);\n+\t  if (type_die == NULL)\n+\t    break;\n+\t  mem_loc_result = new_loc_descr (DW_OP_GNU_regval_type,\n+\t\t\t\t\t  dbx_reg_number (rtl), 0);\n+\t  mem_loc_result->dw_loc_oprnd2.val_class = dw_val_class_die_ref;\n+\t  mem_loc_result->dw_loc_oprnd2.v.val_die_ref.die = type_die;\n+\t  mem_loc_result->dw_loc_oprnd2.v.val_die_ref.external = 0;\n+\t  break;\n+\t}\n       /* Whenever a register number forms a part of the description of the\n \t method for calculating the (dynamic) address of a memory resident\n \t object, DWARF rules require the register number be referred to as\n@@ -13682,11 +13985,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (XEXP (rtl, 0)),\n+\t\t\t\tmem_mode, VAR_INIT_STATUS_INITIALIZED);\n       if (op0 == 0)\n \tbreak;\n-      else\n+      else if (GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE)\n \t{\n \t  int shift = DWARF2_ADDR_SIZE\n \t\t      - GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)));\n@@ -13701,44 +14005,85 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  add_loc_descr (&mem_loc_result, int_loc_descriptor (shift));\n \t  add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n \t}\n+      else if (!dwarf_strict)\n+\t{\n+\t  dw_die_ref type_die1, type_die2;\n+\t  dw_loc_descr_ref cvt;\n+\n+\t  type_die1 = base_type_for_mode (GET_MODE (XEXP (rtl, 0)),\n+\t\t\t\t\t  GET_CODE (rtl) == ZERO_EXTEND);\n+\t  if (type_die1 == NULL)\n+\t    break;\n+\t  type_die2 = base_type_for_mode (mode, 0);\n+\t  if (type_die2 == NULL)\n+\t    break;\n+\t  mem_loc_result = op0;\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die1;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&mem_loc_result, cvt);\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die2;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&mem_loc_result, cvt);\n+\t}\n       break;\n \n     case MEM:\n-      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n+      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0),\n+\t\t\t\t\t   get_address_mode (rtl), mode,\n \t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n       if (mem_loc_result == NULL)\n \tmem_loc_result = tls_mem_loc_descriptor (rtl);\n       if (mem_loc_result != 0)\n \t{\n-\t  if (GET_MODE_SIZE (GET_MODE (rtl)) > DWARF2_ADDR_SIZE)\n+\t  if (GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE\n+\t      || GET_MODE_CLASS (mode) != MODE_INT)\n \t    {\n-\t      expansion_failed (NULL_TREE, rtl, \"DWARF address size mismatch\");\n-\t      return 0;\n+\t      dw_die_ref type_die;\n+\t      dw_loc_descr_ref deref;\n+\n+\t      if (dwarf_strict)\n+\t\treturn NULL;\n+\t      type_die = base_type_for_mode (mode, 0);\n+\t      if (type_die == NULL)\n+\t\treturn NULL;\n+\t      deref = new_loc_descr (DW_OP_GNU_deref_type,\n+\t\t\t\t     GET_MODE_SIZE (mode), 0);\n+\t      deref->dw_loc_oprnd2.val_class = dw_val_class_die_ref;\n+\t      deref->dw_loc_oprnd2.v.val_die_ref.die = type_die;\n+\t      deref->dw_loc_oprnd2.v.val_die_ref.external = 0;\n+\t      add_loc_descr (&mem_loc_result, deref);\n \t    }\n-\t  else if (GET_MODE_SIZE (GET_MODE (rtl)) == DWARF2_ADDR_SIZE)\n+\t  else if (GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE)\n \t    add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n \t  else\n \t    add_loc_descr (&mem_loc_result,\n \t\t\t   new_loc_descr (DW_OP_deref_size,\n-\t\t\t\t\t  GET_MODE_SIZE (GET_MODE (rtl)), 0));\n+\t\t\t\t\t  GET_MODE_SIZE (mode), 0));\n \t}\n       else\n \t{\n \t  rtx new_rtl = avoid_constant_pool_reference (rtl);\n \t  if (new_rtl != rtl)\n-\t    return mem_loc_descriptor (new_rtl, mode, initialized);\n+\t    return mem_loc_descriptor (new_rtl, mode, mem_mode, initialized);\n \t}\n       break;\n \n     case LO_SUM:\n-      return mem_loc_descriptor (XEXP (rtl, 1), mode, initialized);\n+      return mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode, initialized);\n \n     case LABEL_REF:\n       /* Some ports can transform a symbol ref into a label ref, because\n \t the symbol ref is too far away and has to be dumped into a constant\n \t pool.  */\n     case CONST:\n     case SYMBOL_REF:\n+      if (GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE\n+\t  || GET_MODE_CLASS (mode) != MODE_INT)\n+\tbreak;\n       if (GET_CODE (rtl) == SYMBOL_REF\n \t  && SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)\n \t{\n@@ -13784,23 +14129,32 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case ENTRY_VALUE:\n       if (dwarf_strict)\n \treturn NULL;\n-      mem_loc_result = new_loc_descr (DW_OP_GNU_entry_value, 0, 0);\n-      mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_loc;\n       if (REG_P (ENTRY_VALUE_EXP (rtl)))\n-\tmem_loc_result->dw_loc_oprnd1.v.val_loc\n-\t  = one_reg_loc_descriptor (dbx_reg_number (ENTRY_VALUE_EXP (rtl)),\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-      else if (MEM_P (ENTRY_VALUE_EXP (rtl)) && REG_P (XEXP (ENTRY_VALUE_EXP (rtl), 0)))\n \t{\n-\t  dw_loc_descr_ref ref\n-\t    = mem_loc_descriptor (ENTRY_VALUE_EXP (rtl), GET_MODE (rtl),\n-\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\t  if (ref == NULL || ref->dw_loc_opc == DW_OP_fbreg)\n+\t  if (GET_MODE_CLASS (mode) != MODE_INT\n+\t      || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+\t    op0 = mem_loc_descriptor (ENTRY_VALUE_EXP (rtl), mode,\n+\t\t\t\t      VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n+\t  else\n+\t    op0\n+\t      = one_reg_loc_descriptor (dbx_reg_number (ENTRY_VALUE_EXP (rtl)),\n+\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\t}\n+      else if (MEM_P (ENTRY_VALUE_EXP (rtl))\n+\t       && REG_P (XEXP (ENTRY_VALUE_EXP (rtl), 0)))\n+\t{\n+\t  op0 = mem_loc_descriptor (ENTRY_VALUE_EXP (rtl), mode,\n+\t\t\t\t    VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 && op0->dw_loc_opc == DW_OP_fbreg)\n \t    return NULL;\n-\t  mem_loc_result->dw_loc_oprnd1.v.val_loc = ref;\n \t}\n       else\n \tgcc_unreachable ();\n+      if (op0 == NULL)\n+\treturn NULL;\n+      mem_loc_result = new_loc_descr (DW_OP_GNU_entry_value, 0, 0);\n+      mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+      mem_loc_result->dw_loc_oprnd1.v.val_loc = op0;\n       return mem_loc_result;\n \n     case PRE_MODIFY:\n@@ -13813,32 +14167,35 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case PRE_DEC:\n       /* Turn these into a PLUS expression and fall into the PLUS code\n \t below.  */\n-      rtl = gen_rtx_PLUS (word_mode, XEXP (rtl, 0),\n+      rtl = gen_rtx_PLUS (mode, XEXP (rtl, 0),\n \t\t\t  GEN_INT (GET_CODE (rtl) == PRE_INC\n-\t\t\t\t   ? GET_MODE_UNIT_SIZE (mode)\n-\t\t\t\t   : -GET_MODE_UNIT_SIZE (mode)));\n+\t\t\t\t   ? GET_MODE_UNIT_SIZE (mem_mode)\n+\t\t\t\t   : -GET_MODE_UNIT_SIZE (mem_mode)));\n \n       /* ... fall through ...  */\n \n     case PLUS:\n     plus:\n-      if (is_based_loc (rtl))\n+      if (is_based_loc (rtl)\n+\t  && GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE\n+\t  && GET_MODE_CLASS (mode) == MODE_INT)\n \tmem_loc_result = based_loc_descr (XEXP (rtl, 0),\n \t\t\t\t\t  INTVAL (XEXP (rtl, 1)),\n \t\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n       else\n \t{\n-\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n \t  if (mem_loc_result == 0)\n \t    break;\n \n-\t  if (CONST_INT_P (XEXP (rtl, 1)))\n+\t  if (CONST_INT_P (XEXP (rtl, 1))\n+\t      && GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE)\n \t    loc_descr_plus_const (&mem_loc_result, INTVAL (XEXP (rtl, 1)));\n \t  else\n \t    {\n \t      dw_loc_descr_ref mem_loc_result2\n-\t\t= mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t= mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n \t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n \t      if (mem_loc_result2 == 0)\n \t\tbreak;\n@@ -13869,15 +14226,31 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \n     case ASHIFT:\n       op = DW_OP_shl;\n-      goto do_binop;\n+      goto do_shift;\n \n     case ASHIFTRT:\n       op = DW_OP_shra;\n-      goto do_binop;\n+      goto do_shift;\n \n     case LSHIFTRT:\n       op = DW_OP_shr;\n-      goto do_binop;\n+      goto do_shift;\n+\n+    do_shift:\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1),\n+\t\t\t\tGET_MODE (XEXP (rtl, 1)) == VOIDmode\n+\t\t\t\t? mode : GET_MODE (XEXP (rtl, 1)), mem_mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\n+      if (op0 == 0 || op1 == 0)\n+\tbreak;\n+\n+      mem_loc_result = op0;\n+      add_loc_descr (&mem_loc_result, op1);\n+      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+      break;\n \n     case AND:\n       op = DW_OP_and;\n@@ -13892,9 +14265,9 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       goto do_binop;\n \n     do_binop:\n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \n       if (op0 == 0 || op1 == 0)\n@@ -13906,9 +14279,9 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case MOD:\n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \n       if (op0 == 0 || op1 == 0)\n@@ -13936,7 +14309,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       goto do_unop;\n \n     do_unop:\n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \n       if (op0 == 0)\n@@ -13947,7 +14320,75 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case CONST_INT:\n-      mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n+      if (GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE)\n+\t{\n+\t  mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n+\t  break;\n+\t}\n+      if (!dwarf_strict\n+\t  && (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT\n+\t      || GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT))\n+\t{\n+\t  dw_die_ref type_die = base_type_for_mode (mode, 0);\n+\t  if (type_die == NULL)\n+\t    return NULL;\n+\t  mem_loc_result = new_loc_descr (DW_OP_GNU_const_type, 0,\n+\t\t\t\t\t  INTVAL (rtl));\n+\t  mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  mem_loc_result->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  mem_loc_result->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)\n+\t    mem_loc_result->dw_loc_oprnd2.val_class = dw_val_class_const;\n+\t  else\n+\t    {\n+\t      mem_loc_result->dw_loc_oprnd2.val_class\n+\t\t= dw_val_class_const_double;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_double\n+\t\t= shwi_to_double_int (INTVAL (rtl));\n+\t    }\n+\t}\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (!dwarf_strict)\n+\t{\n+\t  dw_die_ref type_die;\n+\n+\t  /* Note that a CONST_DOUBLE rtx could represent either an integer\n+\t     or a floating-point constant.  A CONST_DOUBLE is used whenever\n+\t     the constant requires more than one word in order to be\n+\t     adequately represented.  We output CONST_DOUBLEs as blocks.  */\n+\t  if (mode == VOIDmode\n+\t      || (GET_MODE (rtl) == VOIDmode\n+\t\t  && GET_MODE_BITSIZE (mode) != 2 * HOST_BITS_PER_WIDE_INT))\n+\t    break;\n+\t  type_die = base_type_for_mode (mode, 0);\n+\t  if (type_die == NULL)\n+\t    return NULL;\n+\t  mem_loc_result = new_loc_descr (DW_OP_GNU_const_type, 0, 0);\n+\t  mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  mem_loc_result->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  mem_loc_result->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  if (SCALAR_FLOAT_MODE_P (mode))\n+\t    {\n+\t      unsigned int length = GET_MODE_SIZE (mode);\n+\t      unsigned char *array\n+\t\t  = (unsigned char*) ggc_alloc_atomic (length);\n+\n+\t      insert_float (rtl, array);\n+\t      mem_loc_result->dw_loc_oprnd2.val_class = dw_val_class_vec;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.length = length / 4;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.elt_size = 4;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_vec.array = array;\n+\t    }\n+\t  else\n+\t    {\n+\t      mem_loc_result->dw_loc_oprnd2.val_class\n+\t\t= dw_val_class_const_double;\n+\t      mem_loc_result->dw_loc_oprnd2.v.val_double\n+\t\t= rtx_to_double_int (rtl);\n+\t    }\n+\t}\n       break;\n \n     case EQ:\n@@ -13975,74 +14416,75 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       goto do_scompare;\n \n     do_scompare:\n-      if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) > DWARF2_ADDR_SIZE\n-\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 1))) > DWARF2_ADDR_SIZE)\n-\tbreak;\n-      else\n-\t{\n-\t  enum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n+      {\n+\tenum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n \n-\t  if (op_mode == VOIDmode)\n-\t    op_mode = GET_MODE (XEXP (rtl, 1));\n-\t  if (op_mode != VOIDmode && GET_MODE_CLASS (op_mode) != MODE_INT)\n-\t    break;\n+\tif (op_mode == VOIDmode)\n+\t  op_mode = GET_MODE (XEXP (rtl, 1));\n+\tif (op_mode == VOIDmode)\n+\t  break;\n \n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\tif (dwarf_strict\n+\t    && (GET_MODE_CLASS (op_mode) != MODE_INT\n+\t\t|| GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE))\n+\t  break;\n \n-\t  if (op0 == 0 || op1 == 0)\n-\t    break;\n+\top0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\top1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n \n-\t  if (op_mode != VOIDmode\n-\t      && GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n-\t    {\n-\t      int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode);\n-\t      shift *= BITS_PER_UNIT;\n-\t      /* For eq/ne, if the operands are known to be zero-extended,\n-\t\t there is no need to do the fancy shifting up.  */\n-\t      if (op == DW_OP_eq || op == DW_OP_ne)\n-\t\t{\n-\t\t  dw_loc_descr_ref last0, last1;\n-\t\t  for (last0 = op0;\n-\t\t       last0->dw_loc_next != NULL;\n-\t\t       last0 = last0->dw_loc_next)\n-\t\t    ;\n-\t\t  for (last1 = op1;\n-\t\t       last1->dw_loc_next != NULL;\n-\t\t       last1 = last1->dw_loc_next)\n-\t\t    ;\n-\t\t  /* deref_size zero extends, and for constants we can check\n-\t\t     whether they are zero extended or not.  */\n-\t\t  if (((last0->dw_loc_opc == DW_OP_deref_size\n-\t\t\t&& last0->dw_loc_oprnd1.v.val_int\n-\t\t\t   <= GET_MODE_SIZE (op_mode))\n-\t\t       || (CONST_INT_P (XEXP (rtl, 0))\n-\t\t\t    && (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 0))\n-\t\t\t       == (INTVAL (XEXP (rtl, 0))\n-\t\t\t\t   & GET_MODE_MASK (op_mode))))\n-\t\t      && ((last1->dw_loc_opc == DW_OP_deref_size\n-\t\t\t   && last1->dw_loc_oprnd1.v.val_int\n-\t\t\t      <= GET_MODE_SIZE (op_mode))\n-\t\t\t  || (CONST_INT_P (XEXP (rtl, 1))\n-\t\t\t      && (unsigned HOST_WIDE_INT)\n-\t\t\t\t INTVAL (XEXP (rtl, 1))\n-\t\t\t\t == (INTVAL (XEXP (rtl, 1))\n-\t\t\t\t     & GET_MODE_MASK (op_mode)))))\n-\t\t    goto do_compare;\n-\t\t}\n-\t      add_loc_descr (&op0, int_loc_descriptor (shift));\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n-\t      if (CONST_INT_P (XEXP (rtl, 1)))\n-\t\top1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) << shift);\n-\t      else\n-\t\t{\n-\t\t  add_loc_descr (&op1, int_loc_descriptor (shift));\n-\t\t  add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n-\t\t}\n-\t    }\n-\t}\n+\tif (op0 == 0 || op1 == 0)\n+\t  break;\n+\n+\tif (GET_MODE_CLASS (op_mode) == MODE_INT\n+\t    && GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n+\t  {\n+\t    int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode);\n+\t    shift *= BITS_PER_UNIT;\n+\t    /* For eq/ne, if the operands are known to be zero-extended,\n+\t       there is no need to do the fancy shifting up.  */\n+\t    if (op == DW_OP_eq || op == DW_OP_ne)\n+\t      {\n+\t\tdw_loc_descr_ref last0, last1;\n+\t\tfor (last0 = op0;\n+\t\t     last0->dw_loc_next != NULL;\n+\t\t     last0 = last0->dw_loc_next)\n+\t\t  ;\n+\t\tfor (last1 = op1;\n+\t\t     last1->dw_loc_next != NULL;\n+\t\t     last1 = last1->dw_loc_next)\n+\t\t  ;\n+\t\t/* deref_size zero extends, and for constants we can check\n+\t\t   whether they are zero extended or not.  */\n+\t\tif (((last0->dw_loc_opc == DW_OP_deref_size\n+\t\t      && last0->dw_loc_oprnd1.v.val_int\n+\t\t\t <= GET_MODE_SIZE (op_mode))\n+\t\t     || (CONST_INT_P (XEXP (rtl, 0))\n+\t\t\t && (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 0))\n+\t\t\t     == (INTVAL (XEXP (rtl, 0))\n+\t\t\t\t & GET_MODE_MASK (op_mode))))\n+\t\t    && ((last1->dw_loc_opc == DW_OP_deref_size\n+\t\t\t && last1->dw_loc_oprnd1.v.val_int\n+\t\t\t    <= GET_MODE_SIZE (op_mode))\n+\t\t\t|| (CONST_INT_P (XEXP (rtl, 1))\n+\t\t\t    && (unsigned HOST_WIDE_INT)\n+\t\t\t       INTVAL (XEXP (rtl, 1))\n+\t\t\t       == (INTVAL (XEXP (rtl, 1))\n+\t\t\t\t   & GET_MODE_MASK (op_mode)))))\n+\t\t  goto do_compare;\n+\t      }\n+\t    add_loc_descr (&op0, int_loc_descriptor (shift));\n+\t    add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+\t    if (CONST_INT_P (XEXP (rtl, 1)))\n+\t      op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) << shift);\n+\t    else\n+\t      {\n+\t\tadd_loc_descr (&op1, int_loc_descriptor (shift));\n+\t\tadd_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n+\t      }\n+\t  }\n+      }\n \n     do_compare:\n       mem_loc_result = op0;\n@@ -14073,87 +14515,111 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       goto do_ucompare;\n \n     do_ucompare:\n-      if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) > DWARF2_ADDR_SIZE\n-\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 1))) > DWARF2_ADDR_SIZE)\n-\tbreak;\n-      else\n-\t{\n-\t  enum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n+      {\n+\tenum machine_mode op_mode = GET_MODE (XEXP (rtl, 0));\n \n-\t  if (op_mode == VOIDmode)\n-\t    op_mode = GET_MODE (XEXP (rtl, 1));\n-\t  if (op_mode != VOIDmode && GET_MODE_CLASS (op_mode) != MODE_INT)\n-\t    break;\n+\tif (op_mode == VOIDmode)\n+\t  op_mode = GET_MODE (XEXP (rtl, 1));\n+\tif (op_mode == VOIDmode)\n+\t  break;\n+\tif (GET_MODE_CLASS (op_mode) != MODE_INT)\n+\t  break;\n \n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n-\t  op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\tif (dwarf_strict && GET_MODE_SIZE (op_mode) > DWARF2_ADDR_SIZE)\n+\t  break;\n \n-\t  if (op0 == 0 || op1 == 0)\n+\tif (op_mode != VOIDmode && GET_MODE_CLASS (op_mode) != MODE_INT)\n \t    break;\n \n-\t  if (op_mode != VOIDmode\n-\t      && GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n-\t    {\n-\t      HOST_WIDE_INT mask = GET_MODE_MASK (op_mode);\n-\t      dw_loc_descr_ref last0, last1;\n-\t      for (last0 = op0;\n-\t\t   last0->dw_loc_next != NULL;\n-\t\t   last0 = last0->dw_loc_next)\n-\t\t;\n-\t      for (last1 = op1;\n-\t\t   last1->dw_loc_next != NULL;\n-\t\t   last1 = last1->dw_loc_next)\n-\t\t;\n-\t      if (CONST_INT_P (XEXP (rtl, 0)))\n-\t\top0 = int_loc_descriptor (INTVAL (XEXP (rtl, 0)) & mask);\n-\t      /* deref_size zero extends, so no need to mask it again.  */\n-\t      else if (last0->dw_loc_opc != DW_OP_deref_size\n-\t\t       || last0->dw_loc_oprnd1.v.val_int\n-\t\t\t  > GET_MODE_SIZE (op_mode))\n-\t\t{\n-\t\t  add_loc_descr (&op0, int_loc_descriptor (mask));\n-\t\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n-\t\t}\n-\t      if (CONST_INT_P (XEXP (rtl, 1)))\n-\t\top1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) & mask);\n-\t      /* deref_size zero extends, so no need to mask it again.  */\n-\t      else if (last1->dw_loc_opc != DW_OP_deref_size\n-\t\t       || last1->dw_loc_oprnd1.v.val_int\n-\t\t\t  > GET_MODE_SIZE (op_mode))\n-\t\t{\n-\t\t  add_loc_descr (&op1, int_loc_descriptor (mask));\n-\t\t  add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      HOST_WIDE_INT bias = 1;\n-\t      bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n-\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n-\t      if (CONST_INT_P (XEXP (rtl, 1)))\n-\t\top1 = int_loc_descriptor ((unsigned HOST_WIDE_INT) bias\n-\t\t\t\t\t  + INTVAL (XEXP (rtl, 1)));\n-\t      else\n-\t\tadd_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst,\n-\t\t\t\t\t\t    bias, 0));\n-\t    }\n-\t}\n+\top0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\top1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\n+\tif (op0 == 0 || op1 == 0)\n+\t  break;\n+\n+\tif (GET_MODE_SIZE (op_mode) < DWARF2_ADDR_SIZE)\n+\t  {\n+\t    HOST_WIDE_INT mask = GET_MODE_MASK (op_mode);\n+\t    dw_loc_descr_ref last0, last1;\n+\t    for (last0 = op0;\n+\t\t last0->dw_loc_next != NULL;\n+\t\t last0 = last0->dw_loc_next)\n+\t      ;\n+\t    for (last1 = op1;\n+\t\t last1->dw_loc_next != NULL;\n+\t\t last1 = last1->dw_loc_next)\n+\t      ;\n+\t    if (CONST_INT_P (XEXP (rtl, 0)))\n+\t      op0 = int_loc_descriptor (INTVAL (XEXP (rtl, 0)) & mask);\n+\t    /* deref_size zero extends, so no need to mask it again.  */\n+\t    else if (last0->dw_loc_opc != DW_OP_deref_size\n+\t\t     || last0->dw_loc_oprnd1.v.val_int\n+\t\t\t> GET_MODE_SIZE (op_mode))\n+\t      {\n+\t\tadd_loc_descr (&op0, int_loc_descriptor (mask));\n+\t\tadd_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t      }\n+\t    if (CONST_INT_P (XEXP (rtl, 1)))\n+\t      op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) & mask);\n+\t    /* deref_size zero extends, so no need to mask it again.  */\n+\t    else if (last1->dw_loc_opc != DW_OP_deref_size\n+\t\t     || last1->dw_loc_oprnd1.v.val_int\n+\t\t\t> GET_MODE_SIZE (op_mode))\n+\t      {\n+\t\tadd_loc_descr (&op1, int_loc_descriptor (mask));\n+\t\tadd_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n+\t      }\n+\t  }\n+\telse if (GET_MODE_SIZE (op_mode) == DWARF2_ADDR_SIZE)\n+\t  {\n+\t    HOST_WIDE_INT bias = 1;\n+\t    bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n+\t    add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t    if (CONST_INT_P (XEXP (rtl, 1)))\n+\t      op1 = int_loc_descriptor ((unsigned HOST_WIDE_INT) bias\n+\t\t\t\t\t+ INTVAL (XEXP (rtl, 1)));\n+\t    else\n+\t      add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst,\n+\t\t\t\t\t\t  bias, 0));\n+\t  }\n+\telse\n+\t  {\n+\t    dw_die_ref type_die = base_type_for_mode (mode, 1);\n+\t    dw_loc_descr_ref cvt;\n+\n+\t    if (type_die == NULL)\n+\t      break;\n+\t    cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t    cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t    cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t    cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t    add_loc_descr (&op0, cvt);\n+\t    cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t    cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t    cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t    cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t    add_loc_descr (&op1, cvt);\n+\t  }\n+      }\n       goto do_compare;\n \n-    case SMIN:\n-    case SMAX:\n     case UMIN:\n     case UMAX:\n-      if (GET_MODE_CLASS (GET_MODE (XEXP (rtl, 0))) != MODE_INT\n-\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) > DWARF2_ADDR_SIZE\n-\t  || GET_MODE (XEXP (rtl, 0)) != GET_MODE (XEXP (rtl, 1)))\n+      if (GET_MODE_CLASS (mode) != MODE_INT)\n+\tbreak;\n+      /* FALLTHRU */\n+    case SMIN:\n+    case SMAX:\n+      if (dwarf_strict\n+\t  && (GET_MODE_CLASS (mode) != MODE_INT\n+\t      || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE))\n \tbreak;\n \n-      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n-      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n \t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \n       if (op0 == 0 || op1 == 0)\n@@ -14164,26 +14630,44 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       add_loc_descr (&op1, new_loc_descr (DW_OP_over, 0, 0));\n       if (GET_CODE (rtl) == UMIN || GET_CODE (rtl) == UMAX)\n \t{\n-\t  if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) < DWARF2_ADDR_SIZE)\n+\t  if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n \t    {\n-\t      HOST_WIDE_INT mask = GET_MODE_MASK (GET_MODE (XEXP (rtl, 0)));\n+\t      HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n \t      add_loc_descr (&op0, int_loc_descriptor (mask));\n \t      add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n \t      add_loc_descr (&op1, int_loc_descriptor (mask));\n \t      add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n \t    }\n-\t  else\n+\t  else if (GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE)\n \t    {\n \t      HOST_WIDE_INT bias = 1;\n \t      bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n \t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n \t      add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n \t    }\n+\t  else\n+\t    {\n+\t      dw_die_ref type_die = base_type_for_mode (mode, 1);\n+\t      dw_loc_descr_ref cvt;\n+\n+\t      if (type_die == NULL)\n+\t\tbreak;\n+\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t      add_loc_descr (&op0, cvt);\n+\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t      add_loc_descr (&op1, cvt);\n+\t    }\n \t}\n-      else if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) < DWARF2_ADDR_SIZE)\n+      else if (GET_MODE_CLASS (mode) == MODE_INT\n+\t       && GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n \t{\n-\t  int shift = DWARF2_ADDR_SIZE\n-\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)));\n+\t  int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (mode);\n \t  shift *= BITS_PER_UNIT;\n \t  add_loc_descr (&op0, int_loc_descriptor (shift));\n \t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n@@ -14217,13 +14701,14 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  && CONST_INT_P (XEXP (rtl, 2))\n \t  && ((unsigned) INTVAL (XEXP (rtl, 1))\n \t      + (unsigned) INTVAL (XEXP (rtl, 2))\n-\t      <= GET_MODE_BITSIZE (GET_MODE (rtl)))\n-\t  && GET_MODE_SIZE (GET_MODE (rtl)) <= DWARF2_ADDR_SIZE\n+\t      <= GET_MODE_BITSIZE (mode))\n+\t  && GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE\n \t  && GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) <= DWARF2_ADDR_SIZE)\n \t{\n \t  int shift, size;\n-\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (XEXP (rtl, 0)),\n+\t\t\t\t    mem_mode, VAR_INIT_STATUS_INITIALIZED);\n \t  if (op0 == 0)\n \t    break;\n \t  if (GET_CODE (rtl) == SIGN_EXTRACT)\n@@ -14255,11 +14740,13 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case IF_THEN_ELSE:\n       {\n \tdw_loc_descr_ref op2, bra_node, drop_node;\n-\top0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\top1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\top0 = mem_loc_descriptor (XEXP (rtl, 0),\n+\t\t\t\t  GET_MODE (XEXP (rtl, 0)) == VOIDmode\n+\t\t\t\t  ? word_mode : GET_MODE (XEXP (rtl, 0)),\n+\t\t\t\t  mem_mode, VAR_INIT_STATUS_INITIALIZED);\n+\top1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,\n \t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n-\top2 = mem_loc_descriptor (XEXP (rtl, 2), mode,\n+\top2 = mem_loc_descriptor (XEXP (rtl, 2), mode, mem_mode,\n \t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n \tif (op0 == NULL || op1 == NULL || op2 == NULL)\n \t  break;\n@@ -14277,6 +14764,70 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       }\n       break;\n \n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+    case FIX:\n+    case UNSIGNED_FIX:\n+      if (!dwarf_strict)\n+\t{\n+\t  dw_die_ref type_die;\n+\t  dw_loc_descr_ref cvt;\n+\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (XEXP (rtl, 0)),\n+\t\t\t\t    mem_mode, VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == NULL)\n+\t    break;\n+\t  if (GET_MODE_CLASS (GET_MODE (XEXP (rtl, 0))) == MODE_INT\n+\t      && (GET_CODE (rtl) == UNSIGNED_FLOAT\n+\t\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)))\n+\t\t     <= DWARF2_ADDR_SIZE))\n+\t    {\n+\t      type_die = base_type_for_mode (GET_MODE (XEXP (rtl, 0)),\n+\t\t\t\t\t     GET_CODE (rtl) == UNSIGNED_FLOAT);\n+\t      if (type_die == NULL)\n+\t\tbreak;\n+\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t      add_loc_descr (&op0, cvt);\n+\t    }\n+\t  type_die = base_type_for_mode (mode, GET_CODE (rtl) == UNSIGNED_FIX);\n+\t  if (type_die == NULL)\n+\t    break;\n+\t  cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t  cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t  cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t  add_loc_descr (&op0, cvt);\n+\t  if (GET_MODE_CLASS (mode) == MODE_INT\n+\t      && (GET_CODE (rtl) == UNSIGNED_FIX\n+\t\t  || GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE))\n+\t    {\n+\t      enum machine_mode outer_mode = mode;\n+\t      if (GET_MODE_SIZE (mode) < DWARF2_ADDR_SIZE)\n+\t\t{\n+\t\t  outer_mode = mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT,\n+\t\t\t\t\t      MODE_INT, 0);\n+\t\t  if (outer_mode == BLKmode\n+\t\t      || GET_MODE_SIZE (outer_mode) != DWARF2_ADDR_SIZE)\n+\t\t    break;\n+\t\t}\n+\t      type_die = base_type_for_mode (outer_mode, 0);\n+\t      if (type_die == NULL)\n+\t\tbreak;\n+\t      cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n+\t      cvt->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.die = type_die;\n+\t      cvt->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t      add_loc_descr (&op0, cvt);\n+\t    }\n+\t  mem_loc_result = op0;\n+\t}\n+      break;\n+\n     case COMPARE:\n     case ROTATE:\n     case ROTATERT:\n@@ -14308,12 +14859,6 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case UNLE:\n     case UNLT:\n     case LTGT:\n-    case FLOAT_EXTEND:\n-    case FLOAT_TRUNCATE:\n-    case FLOAT:\n-    case UNSIGNED_FLOAT:\n-    case FIX:\n-    case UNSIGNED_FIX:\n     case FRACT_CONVERT:\n     case UNSIGNED_FRACT_CONVERT:\n     case SAT_FRACT:\n@@ -14332,6 +14877,10 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n     case VEC_DUPLICATE:\n     case UNSPEC:\n     case HIGH:\n+    case FMA:\n+    case STRICT_LOW_PART:\n+    case CONST_VECTOR:\n+    case CONST_FIXED:\n       /* If delegitimize_address couldn't do anything with the UNSPEC, we\n \t can't express it in the debug info.  This can happen e.g. with some\n \t TLS UNSPECs.  */\n@@ -14469,16 +15018,19 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t up an entire register.  For now, just assume that it is\n \t legitimate to make the Dwarf info refer to the whole register which\n \t contains the given subreg.  */\n-      loc_result = loc_descriptor (SUBREG_REG (rtl), mode, initialized);\n+      if (REG_P (SUBREG_REG (rtl)) && subreg_lowpart_p (rtl))\n+\tloc_result = loc_descriptor (SUBREG_REG (rtl), mode, initialized);\n+      else\n+\tgoto do_default;\n       break;\n \n     case REG:\n       loc_result = reg_loc_descriptor (rtl, initialized);\n       break;\n \n     case MEM:\n-      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n-\t\t\t\t       initialized);\n+      loc_result = mem_loc_descriptor (XEXP (rtl, 0), get_address_mode (rtl),\n+\t\t\t\t       GET_MODE (rtl), initialized);\n       if (loc_result == NULL)\n \tloc_result = tls_mem_loc_descriptor (rtl);\n       if (loc_result == NULL)\n@@ -14673,13 +15225,15 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  break;\n \t}\n       /* FALLTHRU */\n+    do_default:\n     default:\n-      if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE (rtl) == mode\n-\t  && GET_MODE_SIZE (GET_MODE (rtl)) <= DWARF2_ADDR_SIZE\n-\t  && (dwarf_version >= 4 || !dwarf_strict))\n+      if ((GET_MODE_CLASS (mode) == MODE_INT && GET_MODE (rtl) == mode\n+\t   && GET_MODE_SIZE (GET_MODE (rtl)) <= DWARF2_ADDR_SIZE\n+\t   && dwarf_version >= 4)\n+\t  || (!dwarf_strict && mode != VOIDmode && mode != BLKmode))\n \t{\n \t  /* Value expression.  */\n-\t  loc_result = mem_loc_descriptor (rtl, VOIDmode, initialized);\n+\t  loc_result = mem_loc_descriptor (rtl, mode, VOIDmode, initialized);\n \t  if (loc_result)\n \t    add_loc_descr (&loc_result,\n \t\t\t   new_loc_descr (DW_OP_stack_value, 0, 0));\n@@ -14754,18 +15308,20 @@ dw_loc_list_1 (tree loc, rtx varloc, int want_address,\n \t  if (MEM_P (varloc))\n \t    {\n \t      rtx addr = XEXP (varloc, 0);\n-\t      descr = mem_loc_descriptor (addr, mode, initialized);\n+\t      descr = mem_loc_descriptor (addr, get_address_mode (varloc),\n+\t\t\t\t\t  mode, initialized);\n \t      if (descr)\n \t\thave_address = 1;\n \t      else\n \t\t{\n \t\t  rtx x = avoid_constant_pool_reference (varloc);\n \t\t  if (x != varloc)\n-\t\t    descr = mem_loc_descriptor (x, mode, initialized);\n+\t\t    descr = mem_loc_descriptor (x, mode, VOIDmode,\n+\t\t\t\t\t\tinitialized);\n \t\t}\n \t    }\n \t  else\n-\t    descr = mem_loc_descriptor (varloc, mode, initialized);\n+\t    descr = mem_loc_descriptor (varloc, mode, VOIDmode, initialized);\n \t}\n       else\n \treturn 0;\n@@ -15187,7 +15743,6 @@ cst_pool_loc_descr (tree loc)\n {\n   /* Get an RTL for this, if something has been emitted.  */\n   rtx rtl = lookup_constant_def (loc);\n-  enum machine_mode mode;\n \n   if (!rtl || !MEM_P (rtl))\n     {\n@@ -15205,9 +15760,8 @@ cst_pool_loc_descr (tree loc)\n \t\t\t\"CST value in contant pool but not marked.\");\n       return 0;\n     }\n-  mode = GET_MODE (rtl);\n-  rtl = XEXP (rtl, 0);\n-  return mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n+  return mem_loc_descriptor (XEXP (rtl, 0), get_address_mode (rtl),\n+\t\t\t     GET_MODE (rtl), VAR_INIT_STATUS_INITIALIZED);\n }\n \n /* Return dw_loc_list representing address of addr_expr LOC\n@@ -15452,7 +16006,7 @@ loc_list_from_tree (tree loc, int want_address)\n \t  }\n \telse\n \t  {\n-\t    enum machine_mode mode;\n+\t    enum machine_mode mode, mem_mode;\n \n \t    /* Certain constructs can only be represented at top-level.  */\n \t    if (want_address == 2)\n@@ -15464,12 +16018,16 @@ loc_list_from_tree (tree loc, int want_address)\n \t    else\n \t      {\n \t\tmode = GET_MODE (rtl);\n+\t\tmem_mode = VOIDmode;\n \t\tif (MEM_P (rtl))\n \t\t  {\n+\t\t    mem_mode = mode;\n+\t\t    mode = get_address_mode (rtl);\n \t\t    rtl = XEXP (rtl, 0);\n \t\t    have_address = 1;\n \t\t  }\n-\t\tret = mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n+\t\tret = mem_loc_descriptor (rtl, mode, mem_mode,\n+\t\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n \t      }\n \t    if (!ret)\n \t      expansion_failed (loc, rtl,\n@@ -19513,8 +20071,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t      if (mode == VOIDmode)\n \t\t\tmode = GET_MODE (XEXP (arg, 0));\n \t\t    }\n-\t\t  if (GET_MODE_CLASS (mode) != MODE_INT\n-\t\t      || GET_MODE_SIZE (mode) > DWARF2_ADDR_SIZE)\n+\t\t  if (mode == VOIDmode || mode == BLKmode)\n \t\t    continue;\n \t\t  if (XEXP (XEXP (arg, 0), 0) == pc_rtx)\n \t\t    {\n@@ -19533,14 +20090,19 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t    reg = reg_loc_descriptor (XEXP (XEXP (arg, 0), 0),\n \t\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n \t\t  else if (MEM_P (XEXP (XEXP (arg, 0), 0)))\n-\t\t    reg = mem_loc_descriptor (XEXP (XEXP (XEXP (arg, 0),\n-\t\t\t\t\t\t\t  0), 0), mode,\n-\t\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n+\t\t    {\n+\t\t      rtx mem = XEXP (XEXP (arg, 0), 0);\n+\t\t      reg = mem_loc_descriptor (XEXP (mem, 0),\n+\t\t\t\t\t\tget_address_mode (mem),\n+\t\t\t\t\t\tGET_MODE (mem),\n+\t\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\t\t    }\n \t\t  else\n \t\t    continue;\n \t\t  if (reg == NULL)\n \t\t    continue;\n-\t\t  val = mem_loc_descriptor (XEXP (XEXP (arg, 0), 1), VOIDmode,\n+\t\t  val = mem_loc_descriptor (XEXP (XEXP (arg, 0), 1), mode,\n+\t\t\t\t\t    VOIDmode,\n \t\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n \t\t  if (val == NULL)\n \t\t    continue;\n@@ -19552,8 +20114,12 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t  add_AT_loc (cdie, DW_AT_GNU_call_site_value, val);\n \t\t  if (next_arg != XEXP (arg, 1))\n \t\t    {\n+\t\t      mode = GET_MODE (XEXP (XEXP (XEXP (arg, 1), 0), 1));\n+\t\t      if (mode == VOIDmode)\n+\t\t\tmode = GET_MODE (XEXP (XEXP (XEXP (arg, 1), 0), 0));\n \t\t      val = mem_loc_descriptor (XEXP (XEXP (XEXP (arg, 1),\n-\t\t\t\t\t\t\t    0), 1), VOIDmode,\n+\t\t\t\t\t\t\t    0), 1),\n+\t\t\t\t\t\tmode, VOIDmode,\n \t\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \t\t      if (val != NULL)\n \t\t\tadd_AT_loc (cdie, DW_AT_GNU_call_site_data_value, val);\n@@ -19567,13 +20133,19 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t  dw_loc_descr_ref tval = NULL;\n \n \t\t  if (tloc != NULL_RTX)\n-\t\t    tval = mem_loc_descriptor (tloc, VOIDmode,\n+\t\t    tval = mem_loc_descriptor (tloc,\n+\t\t\t\t\t       GET_MODE (tloc) == VOIDmode\n+\t\t\t\t\t       ? Pmode : GET_MODE (tloc),\n+\t\t\t\t\t       VOIDmode,\n \t\t\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n \t\t  if (tval)\n \t\t    add_AT_loc (die, DW_AT_GNU_call_site_target, tval);\n \t\t  else if (tlocc != NULL_RTX)\n \t\t    {\n-\t\t      tval = mem_loc_descriptor (tlocc, VOIDmode,\n+\t\t      tval = mem_loc_descriptor (tlocc,\n+\t\t\t\t\t\t GET_MODE (tlocc) == VOIDmode\n+\t\t\t\t\t\t ? Pmode : GET_MODE (tlocc),\n+\t\t\t\t\t\t VOIDmode,\n \t\t\t\t\t\t VAR_INIT_STATUS_INITIALIZED);\n \t\t      if (tval)\n \t\t\tadd_AT_loc (die, DW_AT_GNU_call_site_target_clobbered,\n@@ -22838,6 +23410,7 @@ prune_unused_types (void)\n   limbo_die_node *node;\n   comdat_type_node *ctnode;\n   pubname_ref pub;\n+  dw_die_ref base_type;\n \n #if ENABLE_ASSERT_CHECKING\n   /* All the marks should already be clear.  */\n@@ -22865,6 +23438,8 @@ prune_unused_types (void)\n      pubname_table.  */\n   FOR_EACH_VEC_ELT (pubname_entry, pubname_table, i, pub)\n     prune_unused_types_mark (pub->die, 1);\n+  for (i = 0; VEC_iterate (dw_die_ref, base_types, i, base_type); i++)\n+    prune_unused_types_mark (base_type, 1);\n \n   /* Get rid of nodes that aren't marked; and update the string counts.  */\n   if (debug_str_hash && debug_str_hash_forced)\n@@ -22953,6 +23528,117 @@ move_linkage_attr (dw_die_ref die)\n     }\n }\n \n+/* Helper function for resolve_addr, mark DW_TAG_base_type nodes\n+   referenced from typed stack ops and count how often they are used.  */\n+\n+static void\n+mark_base_types (dw_loc_descr_ref loc)\n+{\n+  dw_die_ref base_type = NULL;\n+\n+  for (; loc; loc = loc->dw_loc_next)\n+    {\n+      switch (loc->dw_loc_opc)\n+\t{\n+\tcase DW_OP_GNU_regval_type:\n+\tcase DW_OP_GNU_deref_type:\n+\t  base_type = loc->dw_loc_oprnd2.v.val_die_ref.die;\n+\t  break;\n+\tcase DW_OP_GNU_const_type:\n+\tcase DW_OP_GNU_convert:\n+\tcase DW_OP_GNU_reinterpret:\n+\t  base_type = loc->dw_loc_oprnd1.v.val_die_ref.die;\n+\t  break;\n+\tcase DW_OP_GNU_entry_value:\n+\t  mark_base_types (loc->dw_loc_oprnd1.v.val_loc);\n+\t  continue;\n+\tdefault:\n+\t  continue;\n+\t}\n+      gcc_assert (base_type->die_parent == comp_unit_die ());\n+      if (base_type->die_mark)\n+\tbase_type->die_mark++;\n+      else\n+\t{\n+\t  VEC_safe_push (dw_die_ref, heap, base_types, base_type);\n+\t  base_type->die_mark = 1;\n+\t}\n+    }\n+}\n+\n+/* Comparison function for sorting marked base types.  */\n+\n+static int\n+base_type_cmp (const void *x, const void *y)\n+{\n+  dw_die_ref dx = *(const dw_die_ref *) x;\n+  dw_die_ref dy = *(const dw_die_ref *) y;\n+  unsigned int byte_size1, byte_size2;\n+  unsigned int encoding1, encoding2;\n+  if (dx->die_mark > dy->die_mark)\n+    return -1;\n+  if (dx->die_mark < dy->die_mark)\n+    return 1;\n+  byte_size1 = get_AT_unsigned (dx, DW_AT_byte_size);\n+  byte_size2 = get_AT_unsigned (dy, DW_AT_byte_size);\n+  if (byte_size1 < byte_size2)\n+    return 1;\n+  if (byte_size1 > byte_size2)\n+    return -1;\n+  encoding1 = get_AT_unsigned (dx, DW_AT_encoding);\n+  encoding2 = get_AT_unsigned (dy, DW_AT_encoding);\n+  if (encoding1 < encoding2)\n+    return 1;\n+  if (encoding1 > encoding2)\n+    return -1;\n+  return 0;\n+}\n+\n+/* Move base types marked by mark_base_types as early as possible\n+   in the CU, sorted by decreasing usage count both to make the\n+   uleb128 references as small as possible and to make sure they\n+   will have die_offset already computed by calc_die_sizes when\n+   sizes of typed stack loc ops is computed.  */\n+\n+static void\n+move_marked_base_types (void)\n+{\n+  unsigned int i;\n+  dw_die_ref base_type, die, c;\n+\n+  if (VEC_empty (dw_die_ref, base_types))\n+    return;\n+\n+  /* Sort by decreasing usage count, they will be added again in that\n+     order later on.  */\n+  VEC_qsort (dw_die_ref, base_types, base_type_cmp);\n+  die = comp_unit_die ();\n+  c = die->die_child;\n+  do\n+    {\n+      dw_die_ref prev = c;\n+      c = c->die_sib;\n+      while (c->die_mark)\n+\t{\n+\t  remove_child_with_prev (c, prev);\n+\t  /* As base types got marked, there must be at least\n+\t     one node other than DW_TAG_base_type.  */\n+\t  gcc_assert (c != c->die_sib);\n+\t  c = c->die_sib;\n+\t}\n+    }\n+  while (c != die->die_child);\n+  gcc_assert (die->die_child);\n+  c = die->die_child;\n+  for (i = 0; VEC_iterate (dw_die_ref, base_types, i, base_type); i++)\n+    {\n+      base_type->die_mark = 0;\n+      base_type->die_sib = c->die_sib;\n+      c->die_sib = base_type;\n+      c = base_type;\n+    }\n+}\n+\n /* Helper function for resolve_addr, attempt to resolve\n    one CONST_STRING, return non-zero if not successful.  Similarly verify that\n    SYMBOL_REFs refer to variables emitted in the current CU.  */\n@@ -23073,7 +23759,10 @@ resolve_addr (dw_die_ref die)\n \t\t    *curr = next;\n \t\t  }\n \t\telse\n-\t\t  curr = &(*curr)->dw_loc_next;\n+\t\t  {\n+\t\t    mark_base_types ((*curr)->expr);\n+\t\t    curr = &(*curr)->dw_loc_next;\n+\t\t  }\n \t      }\n \t    if (loc == *start)\n \t      loc->resolved_addr = 1;\n@@ -23095,6 +23784,8 @@ resolve_addr (dw_die_ref die)\n \t    remove_AT (die, a->dw_attr);\n \t    ix--;\n \t  }\n+\telse\n+\t  mark_base_types (AT_loc (a));\n \tbreak;\n       case dw_val_class_addr:\n \tif (a->dw_attr == DW_AT_const_value\n@@ -23262,6 +23953,56 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n     case DW_OP_GNU_entry_value:\n       hash = hash_loc_operands (val1->v.val_loc, hash);\n       break;\n+    case DW_OP_GNU_regval_type:\n+    case DW_OP_GNU_deref_type:\n+      {\n+\tunsigned int byte_size\n+\t  = get_AT_unsigned (val2->v.val_die_ref.die, DW_AT_byte_size);\n+\tunsigned int encoding\n+\t  = get_AT_unsigned (val2->v.val_die_ref.die, DW_AT_encoding);\n+\thash = iterative_hash_object (val1->v.val_int, hash);\n+\thash = iterative_hash_object (byte_size, hash);\n+\thash = iterative_hash_object (encoding, hash);\n+      }\n+      break;\n+    case DW_OP_GNU_convert:\n+    case DW_OP_GNU_reinterpret:\n+    case DW_OP_GNU_const_type:\n+      {\n+\tunsigned int byte_size\n+\t  = get_AT_unsigned (val1->v.val_die_ref.die, DW_AT_byte_size);\n+\tunsigned int encoding\n+\t  = get_AT_unsigned (val1->v.val_die_ref.die, DW_AT_encoding);\n+\thash = iterative_hash_object (byte_size, hash);\n+\thash = iterative_hash_object (encoding, hash);\n+\tif (loc->dw_loc_opc != DW_OP_GNU_const_type)\n+\t  break;\n+\thash = iterative_hash_object (val2->val_class, hash);\n+\tswitch (val2->val_class)\n+\t  {\n+\t  case dw_val_class_const:\n+\t    hash = iterative_hash_object (val2->v.val_int, hash);\n+\t    break;\n+\t  case dw_val_class_vec:\n+\t    {\n+\t      unsigned int elt_size = val2->v.val_vec.elt_size;\n+\t      unsigned int len = val2->v.val_vec.length;\n+\n+\t      hash = iterative_hash_object (elt_size, hash);\n+\t      hash = iterative_hash_object (len, hash);\n+\t      hash = iterative_hash (val2->v.val_vec.array,\n+\t\t\t\t     len * elt_size, hash);\n+\t    }\n+\t    break;\n+\t  case dw_val_class_const_double:\n+\t    hash = iterative_hash_object (val2->v.val_double.low, hash);\n+\t    hash = iterative_hash_object (val2->v.val_double.high, hash);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n+      break;\n \n     default:\n       /* Other codes have no operands.  */\n@@ -23421,6 +24162,33 @@ compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)\n \t     && valx2->v.val_int == valy2->v.val_int;\n     case DW_OP_GNU_entry_value:\n       return compare_loc_operands (valx1->v.val_loc, valy1->v.val_loc);\n+    case DW_OP_GNU_const_type:\n+      if (valx1->v.val_die_ref.die != valy1->v.val_die_ref.die\n+\t  || valx2->val_class != valy2->val_class)\n+\treturn false;\n+      switch (valx2->val_class)\n+\t{\n+\tcase dw_val_class_const:\n+\t  return valx2->v.val_int == valy2->v.val_int;\n+\tcase dw_val_class_vec:\n+\t  return valx2->v.val_vec.elt_size == valy2->v.val_vec.elt_size\n+\t\t && valx2->v.val_vec.length == valy2->v.val_vec.length\n+\t\t && memcmp (valx2->v.val_vec.array, valy2->v.val_vec.array,\n+\t\t\t    valx2->v.val_vec.elt_size\n+\t\t\t    * valx2->v.val_vec.length) == 0;\n+\tcase dw_val_class_const_double:\n+\t  return valx2->v.val_double.low == valy2->v.val_double.low\n+\t\t && valx2->v.val_double.high == valy2->v.val_double.high;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    case DW_OP_GNU_regval_type:\n+    case DW_OP_GNU_deref_type:\n+      return valx1->v.val_int == valy1->v.val_int\n+\t     && valx2->v.val_die_ref.die == valy2->v.val_die_ref.die;\n+    case DW_OP_GNU_convert:\n+    case DW_OP_GNU_reinterpret:\n+      return valx1->v.val_die_ref.die == valy1->v.val_die_ref.die;\n     default:\n       /* Other codes have no operands.  */\n       return true;\n@@ -23602,7 +24370,14 @@ dwarf2out_finish (const char *filename)\n \n   limbo_die_list = NULL;\n \n+#if ENABLE_ASSERT_CHECKING\n+  {\n+    dw_die_ref die = comp_unit_die (), c;\n+    FOR_EACH_CHILD (die, c, gcc_assert (! c->die_mark));\n+  }\n+#endif\n   resolve_addr (comp_unit_die ());\n+  move_marked_base_types ();\n \n   for (node = deferred_asm_name; node; node = node->next)\n     {"}, {"sha": "7ad246e44a700f6dc7338917901a6d86231bc1e7", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be80a87ee585150cfdd94304848350a2c6d3e0bd/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be80a87ee585150cfdd94304848350a2c6d3e0bd/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=be80a87ee585150cfdd94304848350a2c6d3e0bd", "patch": "@@ -1,3 +1,8 @@\n+2011-04-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2.h (DW_OP_GNU_const_type, DW_OP_GNU_regval_type,\n+\tDW_OP_GNU_deref_type, DW_OP_GNU_convert, DW_OP_GNU_reinterpret): New.\n+\n 2011-04-25  Jan Kratochvil  <jan.kratochvil@redhat.com>\n \n \t* ansidecl.h (ENUM_BITFIELD): New, from gcc/system.h."}, {"sha": "0b008661f964d672de61eb38dad8003e46718825", "filename": "include/dwarf2.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be80a87ee585150cfdd94304848350a2c6d3e0bd/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be80a87ee585150cfdd94304848350a2c6d3e0bd/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=be80a87ee585150cfdd94304848350a2c6d3e0bd", "patch": "@@ -556,6 +556,13 @@ enum dwarf_location_atom\n     /* The GNU entry value extension.\n        See http://www.dwarfstd.org/ShowIssue.php?issue=100909.1&type=open .  */\n     DW_OP_GNU_entry_value = 0xf3,\n+    /* The GNU typed stack extension.\n+       See http://www.dwarfstd.org/doc/040408.1.html .  */\n+    DW_OP_GNU_const_type = 0xf4,\n+    DW_OP_GNU_regval_type = 0xf5,\n+    DW_OP_GNU_deref_type = 0xf6,\n+    DW_OP_GNU_convert = 0xf7,\n+    DW_OP_GNU_reinterpret = 0xf9,\n     /* HP extensions.  */\n     DW_OP_HP_unknown     = 0xe0, /* Ouch, the same as GNU_push_tls_address.  */\n     DW_OP_HP_is_value    = 0xe1,"}]}