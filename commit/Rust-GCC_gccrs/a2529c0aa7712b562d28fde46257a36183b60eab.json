{"sha": "a2529c0aa7712b562d28fde46257a36183b60eab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1MjljMGFhNzcxMmI1NjJkMjhmZGU0NjI1N2EzNjE4M2I2MGVhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T11:00:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T11:00:52Z"}, "message": "s-dwalin.ads, [...]: New.\n\n2017-09-08  Arnaud Charlet <charlet@adacore.com>\n\n\t* s-dwalin.ads, s-dwalin.adb, s-trasym-dwarf.adb, s-objrea.ads,\n\ts-objrea.adb, s-tsmona-linux.adb, s-tsmona-mingw.adb: New.\n\t* gcc-interface/Makefile.in: Enable s-trasym-dwarf.adb on x86*linux.\n\nFrom-SVN: r251887", "tree": {"sha": "82404394f05c810b593c29c98bc5b2194fd4d2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82404394f05c810b593c29c98bc5b2194fd4d2ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2529c0aa7712b562d28fde46257a36183b60eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2529c0aa7712b562d28fde46257a36183b60eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2529c0aa7712b562d28fde46257a36183b60eab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2529c0aa7712b562d28fde46257a36183b60eab/comments", "author": null, "committer": null, "parents": [{"sha": "6a237c45305054f59be3ceb3b1192f4ee776ee81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a237c45305054f59be3ceb3b1192f4ee776ee81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a237c45305054f59be3ceb3b1192f4ee776ee81"}], "stats": {"total": 5512, "additions": 5512, "deletions": 0}, "files": [{"sha": "9ad7783e43b6595dc6a6089d5c9284811fed7a1f", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -429,6 +429,25 @@ X86_64_TARGET_PAIRS = \\\n   a-numaux.adb<a-numaux-x86.adb \\\n   s-atocou.adb<s-atocou-builtin.adb\n \n+# Implementation of symbolic traceback based on dwarf\n+TRASYM_DWARF_UNIX_PAIRS = \\\n+  s-trasym.adb<s-trasym-dwarf.adb \\\n+  s-mmosin.ads<s-mmosin-unix.ads \\\n+  s-mmosin.adb<s-mmosin-unix.adb \\\n+  s-mmauni.ads<s-mmauni-long.ads\n+\n+TRASYM_DWARF_MINGW_PAIRS = \\\n+  s-trasym.adb<s-trasym-dwarf.adb \\\n+  s-mmosin.ads<s-mmosin-mingw.ads \\\n+  s-mmosin.adb<s-mmosin-mingw.adb\n+\n+TRASYM_DWARF_COMMON_OBJS = s-objrea$(objext) s-dwalin$(objext) s-mmap$(objext) \\\n+  s-mmosin$(objext)\n+\n+TRASYM_DWARF_UNIX_OBJS = $(TRASYM_DWARF_COMMON_OBJS) s-mmauni$(objext)\n+\n+TRASYM_DWARF_MINGW_OBJS = $(TRASYM_DWARF_COMMON_OBJS)\n+\n # Shared library version\n LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)ada/gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n \n@@ -1085,7 +1104,9 @@ ifeq ($(strip $(filter-out %86 linux%,$(target_cpu) $(target_os))),)\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n   s-tpopsp.adb<s-tpopsp-tls.adb \\\n+  $(TRASYM_DWARF_UNIX_PAIRS) \\\n   g-sercom.adb<g-sercom-linux.adb \\\n+  s-tsmona.adb<s-tsmona-linux.adb \\\n   a-exetim.adb<a-exetim-posix.adb \\\n   a-exetim.ads<a-exetim-default.ads \\\n   s-linux.ads<s-linux.ads \\\n@@ -1111,6 +1132,7 @@ ifeq ($(strip $(filter-out %86 linux%,$(target_cpu) $(target_os))),)\n   EH_MECHANISM=-gcc\n   THREADSLIB = -lpthread -lrt\n   EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o\n+  EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)\n   EXTRA_GNATRTL_TASKING_OBJS=s-linux.o a-exetim.o\n \n   TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb\n@@ -1907,13 +1929,16 @@ ifeq ($(strip $(filter-out %x86_64 linux%,$(target_cpu) $(target_os))),)\n   s-tpopsp.adb<s-tpopsp-tls.adb \\\n   s-taspri.ads<s-taspri-posix.ads \\\n   g-sercom.adb<g-sercom-linux.adb \\\n+  $(TRASYM_DWARF_UNIX_PAIRS) \\\n+  s-tsmona.adb<s-tsmona-linux.adb \\\n   $(ATOMICS_TARGET_PAIRS) \\\n   $(X86_64_TARGET_PAIRS) \\\n   system.ads<system-linux-x86.ads\n \n   TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb\n \n   EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o\n+  EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)\n   EXTRA_GNATRTL_TASKING_OBJS=s-linux.o a-exetim.o\n \n   EH_MECHANISM=-gcc"}, {"sha": "1791b2dfcf0de66d5be9bd168cff07d49b3251b6", "filename": "gcc/ada/s-dwalin.adb", "status": "added", "additions": 1627, "deletions": 0, "changes": 1627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-dwalin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-dwalin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dwalin.adb?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,1627 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . D W A R F _ L I N E S                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2009-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we can get\n+--  elaboration circularities when polling is turned on\n+\n+with Ada.Characters.Handling;\n+with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n+with Ada.Unchecked_Deallocation;\n+with Ada.Containers.Generic_Array_Sort;\n+\n+with Interfaces; use Interfaces;\n+\n+with System;                   use System;\n+with System.Storage_Elements;  use System.Storage_Elements;\n+with System.Address_Image;\n+with System.IO;                use System.IO;\n+with System.Object_Reader;     use System.Object_Reader;\n+with System.Traceback_Entries; use System.Traceback_Entries;\n+with System.Mmap;              use System.Mmap;\n+with System.Bounded_Strings;   use System.Bounded_Strings;\n+\n+package body System.Dwarf_Lines is\n+\n+   SSU : constant := System.Storage_Unit;\n+\n+   function String_Length (Str : Str_Access) return Natural;\n+   --  Return the length of the C string Str\n+\n+   ---------------------------------\n+   -- DWARF Parser Implementation --\n+   ---------------------------------\n+\n+   procedure Read_Initial_Length\n+     (S    : in out Mapped_Stream;\n+      Len  :    out Offset;\n+      Is64 :    out Boolean);\n+   --  Read initial length as specified by Dwarf-4 7.2.2\n+\n+   procedure Read_Section_Offset\n+     (S    : in out Mapped_Stream;\n+      Len  :    out Offset;\n+      Is64 :        Boolean);\n+   --  Read a section offset, as specified by Dwarf-4 7.4\n+\n+   procedure Read_Aranges_Entry\n+     (C     : in out Dwarf_Context;\n+      Start :    out Integer_Address;\n+      Len   :    out Storage_Count);\n+   --  Read a single .debug_aranges pair\n+\n+   procedure Read_Aranges_Header\n+     (C           : in out Dwarf_Context;\n+      Info_Offset :    out Offset;\n+      Success     :    out Boolean);\n+   --  Read .debug_aranges header\n+\n+   procedure Aranges_Lookup\n+     (C           : in out Dwarf_Context;\n+      Addr        :        Address;\n+      Info_Offset :    out Offset;\n+      Success     :    out Boolean);\n+   --  Search for Addr in .debug_aranges and return offset Info_Offset in\n+   --  .debug_info.\n+\n+   procedure Skip_Form\n+     (S      : in out Mapped_Stream;\n+      Form   :        uint32;\n+      Is64   :        Boolean;\n+      Ptr_Sz :        uint8);\n+   --  Advance offset in S for Form.\n+\n+   procedure Seek_Abbrev\n+     (C             : in out Dwarf_Context;\n+      Abbrev_Offset :        Offset;\n+      Abbrev_Num    :        uint32);\n+   --  Seek to abbrev Abbrev_Num (starting from Abbrev_Offset)\n+\n+   procedure Debug_Info_Lookup\n+     (C           : in out Dwarf_Context;\n+      Info_Offset :        Offset;\n+      Line_Offset :    out Offset;\n+      Success     :    out Boolean);\n+   --  Search for stmt_list tag in Info_Offset and set Line_Offset to the\n+   --  offset in .debug_lines. Only look at the first DIE, which should be\n+   --  a compilation unit.\n+\n+   procedure Initialize_Pass (C : in out Dwarf_Context);\n+   --  Seek to the first byte of the first prologue and prepare to make a pass\n+   --  over the line number entries.\n+\n+   procedure Initialize_State_Machine (C : in out Dwarf_Context);\n+   --  Set all state machine registers to their specified initial values\n+\n+   procedure Parse_Prologue (C : in out Dwarf_Context);\n+   --  Decode a DWARF statement program prologue\n+\n+   procedure Read_And_Execute_Isn\n+     (C    : in out Dwarf_Context;\n+      Done :    out Boolean);\n+   --  Read an execute a statement program instruction\n+\n+   function To_File_Name\n+     (C    : in out Dwarf_Context;\n+      Code :        uint32) return String;\n+   --  Extract a file name from the prologue\n+\n+   type Callback is access procedure (C : in out Dwarf_Context);\n+   procedure For_Each_Row (C : in out Dwarf_Context; F : Callback);\n+   --  Traverse each .debug_line entry with a callback\n+\n+   procedure Dump_Row (C : in out Dwarf_Context);\n+   --  Dump a single row\n+\n+   function \"<\" (Left, Right : Search_Entry) return Boolean;\n+   --  For sorting Search_Entry\n+\n+   procedure Sort_Search_Array is new Ada.Containers.Generic_Array_Sort\n+     (Index_Type   => Natural,\n+      Element_Type => Search_Entry,\n+      Array_Type   => Search_Array);\n+\n+   procedure Symbolic_Address\n+     (C           : in out Dwarf_Context;\n+      Addr        :        Address;\n+      Dir_Name    :    out Str_Access;\n+      File_Name   :    out Str_Access;\n+      Subprg_Name :    out String_Ptr_Len;\n+      Line_Num    :    out Natural);\n+   --  Symbolize one address\n+\n+   -----------------------\n+   --  DWARF constants  --\n+   -----------------------\n+\n+   --  6.2.5.2 Standard Opcodes\n+\n+   DW_LNS_copy               : constant := 1;\n+   DW_LNS_advance_pc         : constant := 2;\n+   DW_LNS_advance_line       : constant := 3;\n+   DW_LNS_set_file           : constant := 4;\n+   DW_LNS_set_column         : constant := 5;\n+   DW_LNS_negate_stmt        : constant := 6;\n+   DW_LNS_set_basic_block    : constant := 7;\n+   DW_LNS_const_add_pc       : constant := 8;\n+   DW_LNS_fixed_advance_pc   : constant := 9;\n+   DW_LNS_set_prologue_end   : constant := 10;\n+   DW_LNS_set_epilogue_begin : constant := 11;\n+   DW_LNS_set_isa            : constant := 12;\n+\n+   --  6.2.5.3 Extended Opcodes\n+\n+   DW_LNE_end_sequence : constant := 1;\n+   DW_LNE_set_address  : constant := 2;\n+   DW_LNE_define_file  : constant := 3;\n+\n+   --  From the DWARF version 4 public review draft\n+\n+   DW_LNE_set_discriminator : constant := 4;\n+\n+   --  Attribute encodings\n+\n+   DW_TAG_Compile_Unit : constant := 16#11#;\n+\n+   DW_AT_Stmt_List : constant := 16#10#;\n+\n+   DW_FORM_addr         : constant := 16#01#;\n+   DW_FORM_block2       : constant := 16#03#;\n+   DW_FORM_block4       : constant := 16#04#;\n+   DW_FORM_data2        : constant := 16#05#;\n+   DW_FORM_data4        : constant := 16#06#;\n+   DW_FORM_data8        : constant := 16#07#;\n+   DW_FORM_string       : constant := 16#08#;\n+   DW_FORM_block        : constant := 16#09#;\n+   DW_FORM_block1       : constant := 16#0a#;\n+   DW_FORM_data1        : constant := 16#0b#;\n+   DW_FORM_flag         : constant := 16#0c#;\n+   DW_FORM_sdata        : constant := 16#0d#;\n+   DW_FORM_strp         : constant := 16#0e#;\n+   DW_FORM_udata        : constant := 16#0f#;\n+   DW_FORM_ref_addr     : constant := 16#10#;\n+   DW_FORM_ref1         : constant := 16#11#;\n+   DW_FORM_ref2         : constant := 16#12#;\n+   DW_FORM_ref4         : constant := 16#13#;\n+   DW_FORM_ref8         : constant := 16#14#;\n+   DW_FORM_ref_udata    : constant := 16#15#;\n+   DW_FORM_indirect     : constant := 16#16#;\n+   DW_FORM_sec_offset   : constant := 16#17#;\n+   DW_FORM_exprloc      : constant := 16#18#;\n+   DW_FORM_flag_present : constant := 16#19#;\n+   DW_FORM_ref_sig8     : constant := 16#20#;\n+\n+   ---------\n+   -- \"<\" --\n+   ---------\n+\n+   function \"<\" (Left, Right : Search_Entry) return Boolean is\n+   begin\n+      return Left.First < Right.First;\n+   end \"<\";\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (C : in out Dwarf_Context) is\n+      procedure Unchecked_Deallocation is new Ada.Unchecked_Deallocation\n+        (Object_File,\n+         Object_File_Access);\n+      procedure Unchecked_Deallocation is new Ada.Unchecked_Deallocation\n+        (Search_Array,\n+         Search_Array_Access);\n+   begin\n+      if C.Has_Debug then\n+         Close (C.Lines);\n+         Close (C.Abbrev);\n+         Close (C.Info);\n+         Close (C.Aranges);\n+      end if;\n+\n+      Close (C.Obj.all);\n+      Unchecked_Deallocation (C.Obj);\n+\n+      Unchecked_Deallocation (C.Cache);\n+   end Close;\n+\n+   ----------\n+   -- Dump --\n+   ----------\n+\n+   procedure Dump (C : in out Dwarf_Context) is\n+   begin\n+      For_Each_Row (C, Dump_Row'Access);\n+   end Dump;\n+\n+   --------------\n+   -- Dump_Row --\n+   --------------\n+\n+   procedure Dump_Row (C : in out Dwarf_Context) is\n+      PC  : constant Integer_Address := Integer_Address (C.Registers.Address);\n+      Off : Offset;\n+   begin\n+      Tell (C.Lines, Off);\n+\n+      Put (System.Address_Image (To_Address (PC)));\n+      Put (\" \");\n+      Put (To_File_Name (C, C.Registers.File));\n+      Put (\":\");\n+\n+      declare\n+         Image : constant String := uint32'Image (C.Registers.Line);\n+      begin\n+         Put_Line (Image (2 .. Image'Last));\n+      end;\n+\n+      Seek (C.Lines, Off);\n+   end Dump_Row;\n+\n+   procedure Dump_Cache (C : Dwarf_Context) is\n+      Cache : constant Search_Array_Access := C.Cache;\n+      S     : Object_Symbol;\n+      Name  : String_Ptr_Len;\n+   begin\n+      if Cache = null then\n+         Put_Line (\"No cache\");\n+         return;\n+      end if;\n+      for I in Cache'Range loop\n+         Put (System.Address_Image (C.Low + Storage_Count (Cache (I).First)));\n+         Put (\" - \");\n+         Put\n+           (System.Address_Image\n+              (C.Low + Storage_Count (Cache (I).First + Cache (I).Size)));\n+         Put (\" l@\");\n+         Put\n+           (System.Address_Image\n+              (To_Address (Integer_Address (Cache (I).Line))));\n+         Put (\": \");\n+         S    := Read_Symbol (C.Obj.all, Offset (Cache (I).Sym));\n+         Name := Object_Reader.Name (C.Obj.all, S);\n+         Put (String (Name.Ptr (1 .. Name.Len)));\n+         New_Line;\n+      end loop;\n+   end Dump_Cache;\n+\n+   ------------------\n+   -- For_Each_Row --\n+   ------------------\n+\n+   procedure For_Each_Row (C : in out Dwarf_Context; F : Callback) is\n+      Done : Boolean;\n+\n+   begin\n+      Initialize_Pass (C);\n+\n+      loop\n+         Read_And_Execute_Isn (C, Done);\n+\n+         if C.Registers.Is_Row then\n+            F.all (C);\n+         end if;\n+\n+         exit when Done;\n+      end loop;\n+   end For_Each_Row;\n+\n+   ---------------------\n+   -- Initialize_Pass --\n+   ---------------------\n+\n+   procedure Initialize_Pass (C : in out Dwarf_Context) is\n+   begin\n+      Seek (C.Lines, 0);\n+      C.Next_Prologue := 0;\n+\n+      Initialize_State_Machine (C);\n+   end Initialize_Pass;\n+\n+   ------------------------------\n+   -- Initialize_State_Machine --\n+   ------------------------------\n+\n+   procedure Initialize_State_Machine (C : in out Dwarf_Context) is\n+   begin\n+      C.Registers :=\n+        (Address        => 0,\n+         File           => 1,\n+         Line           => 1,\n+         Column         => 0,\n+         Is_Stmt        => C.Prologue.Default_Is_Stmt = 0,\n+         Basic_Block    => False,\n+         End_Sequence   => False,\n+         Prologue_End   => False,\n+         Epilogue_Begin => False,\n+         ISA            => 0,\n+         Is_Row         => False);\n+   end Initialize_State_Machine;\n+\n+   ---------------\n+   -- Is_Inside --\n+   ---------------\n+\n+   function Is_Inside (C : Dwarf_Context; Addr : Address) return Boolean is\n+   begin\n+      return Addr >= C.Low and Addr <= C.High;\n+   end Is_Inside;\n+\n+   ---------\n+   -- Low --\n+   ---------\n+\n+   function Low (C : Dwarf_Context) return Address is\n+   begin\n+      return C.Low;\n+   end Low;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   procedure Open\n+     (File_Name :     String;\n+      C         : out Dwarf_Context;\n+      Success   : out Boolean)\n+   is\n+      Line_Sec, Info_Sec, Abbrev_Sec, Aranges_Sec : Object_Section;\n+      Hi, Lo                                      : uint64;\n+   begin\n+      --  Not a success by default\n+\n+      Success := False;\n+\n+      --  Open file\n+\n+      C.Obj := Open (File_Name, C.In_Exception);\n+\n+      if C.Obj = null then\n+         return;\n+      end if;\n+\n+      Success := True;\n+\n+      --  Get memory bounds\n+\n+      Get_Memory_Bounds (C.Obj.all, Lo, Hi);\n+      C.Low  := Address (Lo);\n+      C.High := Address (Hi);\n+\n+      --  Create a stream for debug sections\n+\n+      if Format (C.Obj.all) = XCOFF32 then\n+         Line_Sec    := Get_Section (C.Obj.all, \".dwline\");\n+         Abbrev_Sec  := Get_Section (C.Obj.all, \".dwabrev\");\n+         Info_Sec    := Get_Section (C.Obj.all, \".dwinfo\");\n+         Aranges_Sec := Get_Section (C.Obj.all, \".dwarnge\");\n+      else\n+         Line_Sec    := Get_Section (C.Obj.all, \".debug_line\");\n+         Abbrev_Sec  := Get_Section (C.Obj.all, \".debug_abbrev\");\n+         Info_Sec    := Get_Section (C.Obj.all, \".debug_info\");\n+         Aranges_Sec := Get_Section (C.Obj.all, \".debug_aranges\");\n+      end if;\n+\n+      if Line_Sec = Null_Section\n+        or else Abbrev_Sec = Null_Section\n+        or else Info_Sec = Null_Section\n+        or else Aranges_Sec = Null_Section\n+      then\n+         C.Has_Debug := False;\n+         return;\n+      end if;\n+\n+      C.Lines   := Create_Stream (C.Obj.all, Line_Sec);\n+      C.Abbrev  := Create_Stream (C.Obj.all, Abbrev_Sec);\n+      C.Info    := Create_Stream (C.Obj.all, Info_Sec);\n+      C.Aranges := Create_Stream (C.Obj.all, Aranges_Sec);\n+\n+      --  All operations are successful, context is valid\n+\n+      C.Has_Debug := True;\n+   end Open;\n+\n+   --------------------\n+   -- Parse_Prologue --\n+   --------------------\n+\n+   procedure Parse_Prologue (C : in out Dwarf_Context) is\n+      Char : uint8;\n+      Prev : uint8;\n+      --  The most recently read character and the one preceding it\n+\n+      Dummy : uint32;\n+      --  Destination for reads we don't care about\n+\n+      Buf : Buffer;\n+      Off : Offset;\n+\n+      First_Byte_Of_Prologue : Offset;\n+      Last_Byte_Of_Prologue  : Offset;\n+\n+      Max_Op_Per_Insn : uint8;\n+      pragma Unreferenced (Max_Op_Per_Insn);\n+\n+      Prologue : Line_Info_Prologue renames C.Prologue;\n+\n+   begin\n+      Tell (C.Lines, First_Byte_Of_Prologue);\n+      Prologue.Unit_Length := Read (C.Lines);\n+      Tell (C.Lines, Off);\n+      C.Next_Prologue := Off + Offset (Prologue.Unit_Length);\n+\n+      Prologue.Version         := Read (C.Lines);\n+      Prologue.Prologue_Length := Read (C.Lines);\n+      Tell (C.Lines, Last_Byte_Of_Prologue);\n+      Last_Byte_Of_Prologue :=\n+        Last_Byte_Of_Prologue + Offset (Prologue.Prologue_Length) - 1;\n+\n+      Prologue.Min_Isn_Length := Read (C.Lines);\n+\n+      if Prologue.Version >= 4 then\n+         Max_Op_Per_Insn := Read (C.Lines);\n+      end if;\n+\n+      Prologue.Default_Is_Stmt := Read (C.Lines);\n+      Prologue.Line_Base       := Read (C.Lines);\n+      Prologue.Line_Range      := Read (C.Lines);\n+      Prologue.Opcode_Base     := Read (C.Lines);\n+\n+      --  Opcode_Lengths is an array of Opcode_Base bytes specifying the number\n+      --  of LEB128 operands for each of the standard opcodes.\n+\n+      for J in 1 .. uint32 (Prologue.Opcode_Base - 1) loop\n+         Prologue.Opcode_Lengths (J) := Read (C.Lines);\n+      end loop;\n+\n+      --  The include directories table follows. This is a list of null\n+      --  terminated strings terminated by a double null. We only store\n+      --  its offset for later decoding.\n+\n+      Tell (C.Lines, Prologue.Includes_Offset);\n+      Char := Read (C.Lines);\n+\n+      if Char /= 0 then\n+         loop\n+            Prev := Char;\n+            Char := Read (C.Lines);\n+            exit when Char = 0 and Prev = 0;\n+         end loop;\n+      end if;\n+\n+      --  The file_names table is next. Each record is a null terminated string\n+      --  for the file name, an unsigned LEB128 directory index, an unsigned\n+      --  LEB128 modification time, and an LEB128 file length. The table is\n+      --  terminated by a null byte.\n+\n+      Tell (C.Lines, Prologue.File_Names_Offset);\n+\n+      loop\n+         --  Read the filename\n+\n+         Read_C_String (C.Lines, Buf);\n+         exit when Buf (0) = 0;\n+         Dummy := Read_LEB128 (C.Lines); --  Skip the directory index.\n+         Dummy := Read_LEB128 (C.Lines); --  Skip the modification time.\n+         Dummy := Read_LEB128 (C.Lines); --  Skip the file length.\n+      end loop;\n+\n+      --  Check we're where we think we are. This sanity check ensures we think\n+      --  the prologue ends where the prologue says it does. It we aren't then\n+      --  we've probably gotten out of sync somewhere.\n+\n+      Tell (C.Lines, Off);\n+\n+      if Prologue.Unit_Length /= 0\n+        and then Off /= Last_Byte_Of_Prologue + 1\n+      then\n+         raise Dwarf_Error with \"Parse error reading DWARF information\";\n+      end if;\n+   end Parse_Prologue;\n+\n+   --------------------------\n+   -- Read_And_Execute_Isn --\n+   --------------------------\n+\n+   procedure Read_And_Execute_Isn\n+     (C    : in out Dwarf_Context;\n+      Done :    out Boolean)\n+   is\n+      Opcode          : uint8;\n+      Extended_Opcode : uint8;\n+      uint32_Operand  : uint32;\n+      int32_Operand   : int32;\n+      uint16_Operand  : uint16;\n+      Off             : Offset;\n+\n+      Extended_Length : uint32;\n+      pragma Unreferenced (Extended_Length);\n+\n+      Obj : Object_File renames C.Obj.all;\n+      Registers : Line_Info_Registers renames C.Registers;\n+      Prologue : Line_Info_Prologue renames C.Prologue;\n+\n+   begin\n+      Done             := False;\n+      Registers.Is_Row := False;\n+\n+      if Registers.End_Sequence then\n+         Initialize_State_Machine (C);\n+      end if;\n+\n+      --  Read the next prologue\n+\n+      Tell (C.Lines, Off);\n+      while Off = C.Next_Prologue loop\n+         Initialize_State_Machine (C);\n+         Parse_Prologue (C);\n+         Tell (C.Lines, Off);\n+         exit when Off + 4 >= Length (C.Lines);\n+      end loop;\n+\n+      --  Test whether we're done\n+\n+      Tell (C.Lines, Off);\n+\n+      --  We are finished when we either reach the end of the section, or we\n+      --  have reached zero padding at the end of the section.\n+\n+      if Prologue.Unit_Length = 0 or else Off + 4 >= Length (C.Lines) then\n+         Done := True;\n+         return;\n+      end if;\n+\n+      --  Read and interpret an instruction\n+\n+      Opcode := Read (C.Lines);\n+\n+      --  Extended opcodes\n+\n+      if Opcode = 0 then\n+         Extended_Length := Read_LEB128 (C.Lines);\n+         Extended_Opcode := Read (C.Lines);\n+\n+         case Extended_Opcode is\n+            when DW_LNE_end_sequence =>\n+\n+               --  Mark the end of a sequence of source locations\n+\n+               Registers.End_Sequence := True;\n+               Registers.Is_Row       := True;\n+\n+            when DW_LNE_set_address =>\n+\n+               --  Set the program counter to a word\n+\n+               Registers.Address := Read_Address (Obj, C.Lines);\n+\n+            when DW_LNE_define_file =>\n+\n+               --  Not implemented\n+\n+               raise Dwarf_Error with \"DWARF operator not implemented\";\n+\n+            when DW_LNE_set_discriminator =>\n+\n+               --  Ignored\n+\n+               int32_Operand := Read_LEB128 (C.Lines);\n+\n+            when others =>\n+\n+               --  Fail on an unrecognized opcode\n+\n+               raise Dwarf_Error with \"DWARF operator not implemented\";\n+         end case;\n+\n+      --  Standard opcodes\n+\n+      elsif Opcode < Prologue.Opcode_Base then\n+         case Opcode is\n+\n+            --  Append a row to the line info matrix\n+\n+            when DW_LNS_copy =>\n+               Registers.Basic_Block := False;\n+               Registers.Is_Row      := True;\n+\n+            --  Add an unsigned word to the program counter\n+\n+            when DW_LNS_advance_pc =>\n+               uint32_Operand    := Read_LEB128 (C.Lines);\n+               Registers.Address :=\n+                 Registers.Address +\n+                 uint64 (uint32_Operand * uint32 (Prologue.Min_Isn_Length));\n+\n+            --  Add a signed word to the current source line\n+\n+            when DW_LNS_advance_line =>\n+               int32_Operand  := Read_LEB128 (C.Lines);\n+               Registers.Line :=\n+                 uint32 (int32 (Registers.Line) + int32_Operand);\n+\n+            --  Set the current source file\n+\n+            when DW_LNS_set_file =>\n+               uint32_Operand := Read_LEB128 (C.Lines);\n+               Registers.File := uint32_Operand;\n+\n+            --  Set the current source column\n+\n+            when DW_LNS_set_column =>\n+               uint32_Operand   := Read_LEB128 (C.Lines);\n+               Registers.Column := uint32_Operand;\n+\n+            --  Toggle the \"is statement\" flag. GCC doesn't seem to set this???\n+\n+            when DW_LNS_negate_stmt =>\n+               Registers.Is_Stmt := not Registers.Is_Stmt;\n+\n+            --  Mark the beginning of a basic block\n+\n+            when DW_LNS_set_basic_block =>\n+               Registers.Basic_Block := True;\n+\n+            --  Advance the program counter as by the special opcode 255\n+\n+            when DW_LNS_const_add_pc =>\n+               Registers.Address :=\n+                 Registers.Address +\n+                 uint64\n+                   (((255 - Prologue.Opcode_Base) / Prologue.Line_Range) *\n+                    Prologue.Min_Isn_Length);\n+\n+            --  Advance the program counter by a constant\n+\n+            when DW_LNS_fixed_advance_pc =>\n+               uint16_Operand    := Read (C.Lines);\n+               Registers.Address :=\n+                 Registers.Address + uint64 (uint16_Operand);\n+\n+            --  The following are not implemented and ignored\n+\n+            when DW_LNS_set_prologue_end =>\n+               null;\n+\n+            when DW_LNS_set_epilogue_begin =>\n+               null;\n+\n+            when DW_LNS_set_isa =>\n+               null;\n+\n+            --  Anything else is an error\n+\n+            when others =>\n+               raise Dwarf_Error with \"DWARF operator not implemented\";\n+         end case;\n+\n+      --  Decode a special opcode. This is a line and address increment encoded\n+      --  in a single byte 'special opcode' as described in 6.2.5.1.\n+\n+      else\n+         declare\n+            Address_Increment : int32;\n+            Line_Increment    : int32;\n+\n+         begin\n+            Opcode := Opcode - Prologue.Opcode_Base;\n+\n+            --  The adjusted opcode is a uint8 encoding an address increment\n+            --  and a signed line increment. The upperbound is allowed to be\n+            --  greater than int8'last so we decode using int32 directly to\n+            --  prevent overflows.\n+\n+            Address_Increment :=\n+              int32 (Opcode / Prologue.Line_Range) *\n+              int32 (Prologue.Min_Isn_Length);\n+            Line_Increment :=\n+              int32 (Prologue.Line_Base) +\n+              int32 (Opcode mod Prologue.Line_Range);\n+\n+            Registers.Address :=\n+              Registers.Address + uint64 (Address_Increment);\n+            Registers.Line := uint32 (int32 (Registers.Line) + Line_Increment);\n+            Registers.Basic_Block    := False;\n+            Registers.Prologue_End   := False;\n+            Registers.Epilogue_Begin := False;\n+            Registers.Is_Row         := True;\n+         end;\n+      end if;\n+\n+   exception\n+      when Dwarf_Error =>\n+\n+         --  In case of errors during parse, just stop reading\n+\n+         Registers.Is_Row := False;\n+         Done             := True;\n+   end Read_And_Execute_Isn;\n+\n+   ----------------------\n+   -- Set_Load_Address --\n+   ----------------------\n+\n+   procedure Set_Load_Address (C : in out Dwarf_Context; Addr : Address) is\n+   begin\n+      if Addr = Null_Address then\n+         return;\n+      else\n+         C.Load_Slide :=\n+           To_Integer (Addr) - Integer_Address (Get_Load_Address (C.Obj.all));\n+\n+         C.Low  := To_Address (To_Integer (C.Low) + C.Load_Slide);\n+         C.High := To_Address (To_Integer (C.High) + C.Load_Slide);\n+      end if;\n+   end Set_Load_Address;\n+\n+   ------------------\n+   -- To_File_Name --\n+   ------------------\n+\n+   function To_File_Name\n+     (C    : in out Dwarf_Context;\n+      Code :        uint32) return String\n+   is\n+      Buf : Buffer;\n+      J   : uint32;\n+\n+      Dir_Idx : uint32;\n+      pragma Unreferenced (Dir_Idx);\n+\n+      Mod_Time : uint32;\n+      pragma Unreferenced (Mod_Time);\n+\n+      Length : uint32;\n+      pragma Unreferenced (Length);\n+\n+   begin\n+      Seek (C.Lines, C.Prologue.File_Names_Offset);\n+\n+      --  Find the entry\n+\n+      J := 0;\n+      loop\n+         J := J + 1;\n+         Read_C_String (C.Lines, Buf);\n+\n+         if Buf (Buf'First) = 0 then\n+            return \"???\";\n+         end if;\n+\n+         Dir_Idx  := Read_LEB128 (C.Lines);\n+         Mod_Time := Read_LEB128 (C.Lines);\n+         Length   := Read_LEB128 (C.Lines);\n+         exit when J = Code;\n+      end loop;\n+\n+      return To_String (Buf);\n+   end To_File_Name;\n+\n+   -------------------------\n+   -- Read_Initial_Length --\n+   -------------------------\n+\n+   procedure Read_Initial_Length\n+     (S    : in out Mapped_Stream;\n+      Len  :    out Offset;\n+      Is64 :    out Boolean)\n+   is\n+      Len32 : uint32;\n+      Len64 : uint64;\n+   begin\n+      Len32 := Read (S);\n+      if Len32 < 16#ffff_fff0# then\n+         Is64 := False;\n+         Len  := Offset (Len32);\n+      elsif Len32 < 16#ffff_ffff# then\n+         --  Invalid length\n+         raise Constraint_Error;\n+      else\n+         Is64  := True;\n+         Len64 := Read (S);\n+         Len   := Offset (Len64);\n+      end if;\n+   end Read_Initial_Length;\n+\n+   -------------------------\n+   -- Read_Section_Offset --\n+   -------------------------\n+\n+   procedure Read_Section_Offset\n+     (S    : in out Mapped_Stream;\n+      Len  :    out Offset;\n+      Is64 :        Boolean)\n+   is\n+   begin\n+      if Is64 then\n+         Len := Offset (uint64'(Read (S)));\n+      else\n+         Len := Offset (uint32'(Read (S)));\n+      end if;\n+   end Read_Section_Offset;\n+\n+   --------------------\n+   -- Aranges_Lookup --\n+   --------------------\n+\n+   procedure Aranges_Lookup\n+     (C           : in out Dwarf_Context;\n+      Addr        :        Address;\n+      Info_Offset :    out Offset;\n+      Success     :    out Boolean)\n+   is\n+   begin\n+      Seek (C.Aranges, 0);\n+\n+      while Tell (C.Aranges) < Length (C.Aranges) loop\n+         Read_Aranges_Header (C, Info_Offset, Success);\n+         exit when not Success;\n+\n+         loop\n+            declare\n+               Start : Integer_Address;\n+               Len   : Storage_Count;\n+            begin\n+               Read_Aranges_Entry (C, Start, Len);\n+               exit when Start = 0 and Len = 0;\n+               if Addr >= To_Address (Start)\n+                 and then Addr < To_Address (Start) + Len\n+               then\n+                  Success := True;\n+                  return;\n+               end if;\n+            end;\n+         end loop;\n+      end loop;\n+      Success := False;\n+   end Aranges_Lookup;\n+\n+   ---------------\n+   -- Skip_Form --\n+   ---------------\n+\n+   procedure Skip_Form\n+     (S      : in out Mapped_Stream;\n+      Form   :        uint32;\n+      Is64   :        Boolean;\n+      Ptr_Sz :        uint8)\n+   is\n+      Skip : Offset;\n+   begin\n+      case Form is\n+         when DW_FORM_addr =>\n+            Skip := Offset (Ptr_Sz);\n+         when DW_FORM_block2 =>\n+            Skip := Offset (uint16'(Read (S)));\n+         when DW_FORM_block4 =>\n+            Skip := Offset (uint32'(Read (S)));\n+         when DW_FORM_data2 | DW_FORM_ref2 =>\n+            Skip := 2;\n+         when DW_FORM_data4 | DW_FORM_ref4 =>\n+            Skip := 4;\n+         when DW_FORM_data8 | DW_FORM_ref8 | DW_FORM_ref_sig8 =>\n+            Skip := 8;\n+         when DW_FORM_string =>\n+            while uint8'(Read (S)) /= 0 loop\n+               null;\n+            end loop;\n+            return;\n+         when DW_FORM_block | DW_FORM_exprloc =>\n+            Skip := Offset (uint32'(Read_LEB128 (S)));\n+         when DW_FORM_block1 | DW_FORM_ref1 =>\n+            Skip := Offset (uint8'(Read (S)));\n+         when DW_FORM_data1 | DW_FORM_flag =>\n+            Skip := 1;\n+         when DW_FORM_sdata =>\n+            declare\n+               Val : constant int32 := Read_LEB128 (S);\n+               pragma Unreferenced (Val);\n+            begin\n+               return;\n+            end;\n+         when DW_FORM_strp | DW_FORM_ref_addr | DW_FORM_sec_offset =>\n+            Skip := (if Is64 then 8 else 4);\n+         when DW_FORM_udata | DW_FORM_ref_udata =>\n+            declare\n+               Val : constant uint32 := Read_LEB128 (S);\n+               pragma Unreferenced (Val);\n+            begin\n+               return;\n+            end;\n+         when DW_FORM_flag_present =>\n+            return;\n+         when DW_FORM_indirect =>\n+            raise Constraint_Error;\n+         when others =>\n+            raise Constraint_Error;\n+      end case;\n+      Seek (S, Tell (S) + Skip);\n+   end Skip_Form;\n+\n+   -----------------\n+   -- Seek_Abbrev --\n+   -----------------\n+\n+   procedure Seek_Abbrev\n+     (C             : in out Dwarf_Context;\n+      Abbrev_Offset :        Offset;\n+      Abbrev_Num    :        uint32)\n+   is\n+      Num       : uint32;\n+      Abbrev    : uint32;\n+      Tag       : uint32;\n+      Has_Child : uint8;\n+      pragma Unreferenced (Abbrev, Tag, Has_Child);\n+   begin\n+      Seek (C.Abbrev, Abbrev_Offset);\n+\n+      Num := 1;\n+\n+      loop\n+         exit when Num = Abbrev_Num;\n+\n+         Abbrev    := Read_LEB128 (C.Abbrev);\n+         Tag       := Read_LEB128 (C.Abbrev);\n+         Has_Child := Read (C.Abbrev);\n+\n+         loop\n+            declare\n+               Name : constant uint32 := Read_LEB128 (C.Abbrev);\n+               Form : constant uint32 := Read_LEB128 (C.Abbrev);\n+            begin\n+               exit when Name = 0 and Form = 0;\n+            end;\n+         end loop;\n+\n+         Num := Num + 1;\n+      end loop;\n+   end Seek_Abbrev;\n+\n+   -----------------------\n+   -- Debug_Info_Lookup --\n+   -----------------------\n+\n+   procedure Debug_Info_Lookup\n+     (C           : in out Dwarf_Context;\n+      Info_Offset :        Offset;\n+      Line_Offset :    out Offset;\n+      Success     :    out Boolean)\n+   is\n+      Unit_Length   : Offset;\n+      Is64          : Boolean;\n+      Version       : uint16;\n+      Abbrev_Offset : Offset;\n+      Addr_Sz       : uint8;\n+      Abbrev        : uint32;\n+      Has_Child     : uint8;\n+      pragma Unreferenced (Has_Child);\n+   begin\n+      Success := False;\n+\n+      Seek (C.Info, Info_Offset);\n+\n+      Read_Initial_Length (C.Info, Unit_Length, Is64);\n+\n+      Version := Read (C.Info);\n+      if Version not in 2 .. 4 then\n+         return;\n+      end if;\n+\n+      Read_Section_Offset (C.Info, Abbrev_Offset, Is64);\n+\n+      Addr_Sz := Read (C.Info);\n+      if Addr_Sz /= (Address'Size / SSU) then\n+         return;\n+      end if;\n+\n+      --  Read DIEs\n+\n+      loop\n+         Abbrev := Read_LEB128 (C.Info);\n+         exit when Abbrev /= 0;\n+      end loop;\n+\n+      --  Read abbrev table\n+\n+      Seek_Abbrev (C, Abbrev_Offset, Abbrev);\n+\n+      --  First ULEB128 is the abbrev code\n+\n+      if Read_LEB128 (C.Abbrev) /= Abbrev then\n+         --  Ill formed abbrev table\n+         return;\n+      end if;\n+\n+      --  Then the tag\n+\n+      if Read_LEB128 (C.Abbrev) /= uint32'(DW_TAG_Compile_Unit) then\n+         --  Expect compile unit\n+         return;\n+      end if;\n+\n+      --  Then the has child flag\n+\n+      Has_Child := Read (C.Abbrev);\n+\n+      loop\n+         declare\n+            Name : constant uint32 := Read_LEB128 (C.Abbrev);\n+            Form : constant uint32 := Read_LEB128 (C.Abbrev);\n+         begin\n+            exit when Name = 0 and Form = 0;\n+            if Name = DW_AT_Stmt_List then\n+               case Form is\n+                  when DW_FORM_sec_offset =>\n+                     Read_Section_Offset (C.Info, Line_Offset, Is64);\n+                  when DW_FORM_data4 =>\n+                     Line_Offset := Offset (uint32'(Read (C.Info)));\n+                  when DW_FORM_data8 =>\n+                     Line_Offset := Offset (uint64'(Read (C.Info)));\n+                  when others =>\n+                     --  Unhandled form\n+                     return;\n+               end case;\n+\n+               Success := True;\n+               return;\n+            else\n+               Skip_Form (C.Info, Form, Is64, Addr_Sz);\n+            end if;\n+         end;\n+      end loop;\n+\n+      return;\n+   end Debug_Info_Lookup;\n+\n+   -------------------------\n+   -- Read_Aranges_Header --\n+   -------------------------\n+\n+   procedure Read_Aranges_Header\n+     (C           : in out Dwarf_Context;\n+      Info_Offset :    out Offset;\n+      Success     :    out Boolean)\n+   is\n+      Unit_Length : Offset;\n+      Is64        : Boolean;\n+      Version     : uint16;\n+      Sz          : uint8;\n+   begin\n+      Success := False;\n+\n+      Read_Initial_Length (C.Aranges, Unit_Length, Is64);\n+\n+      Version := Read (C.Aranges);\n+      if Version /= 2 then\n+         return;\n+      end if;\n+\n+      Read_Section_Offset (C.Aranges, Info_Offset, Is64);\n+\n+      --  Read address_size (ubyte)\n+\n+      Sz := Read (C.Aranges);\n+      if Sz /= (Address'Size / SSU) then\n+         return;\n+      end if;\n+\n+      --  Read segment_size (ubyte)\n+\n+      Sz := Read (C.Aranges);\n+      if Sz /= 0 then\n+         return;\n+      end if;\n+\n+      --  Handle alignment on twice the address size\n+      declare\n+         Cur_Off : constant Offset := Tell (C.Aranges);\n+         Align   : constant Offset := 2 * Address'Size / SSU;\n+         Space   : constant Offset := Cur_Off mod Align;\n+      begin\n+         if Space /= 0 then\n+            Seek (C.Aranges, Cur_Off + Align - Space);\n+         end if;\n+      end;\n+\n+      Success := True;\n+   end Read_Aranges_Header;\n+\n+   ------------------------\n+   -- Read_Aranges_Entry --\n+   ------------------------\n+\n+   procedure Read_Aranges_Entry\n+     (C     : in out Dwarf_Context;\n+      Start :    out Integer_Address;\n+      Len   :    out Storage_Count)\n+   is\n+   begin\n+      --  Read table\n+      if Address'Size = 32 then\n+         declare\n+            S, L : uint32;\n+         begin\n+            S     := Read (C.Aranges);\n+            L     := Read (C.Aranges);\n+            Start := Integer_Address (S);\n+            Len   := Storage_Count (L);\n+         end;\n+      elsif Address'Size = 64 then\n+         declare\n+            S, L : uint64;\n+         begin\n+            S     := Read (C.Aranges);\n+            L     := Read (C.Aranges);\n+            Start := Integer_Address (S);\n+            Len   := Storage_Count (L);\n+         end;\n+      else\n+         raise Constraint_Error;\n+      end if;\n+   end Read_Aranges_Entry;\n+\n+   ------------------\n+   -- Enable_Cache --\n+   ------------------\n+\n+   procedure Enable_Cache (C : in out Dwarf_Context) is\n+      Cache : Search_Array_Access;\n+   begin\n+      --  Phase 1: count number of symbols. Phase 2: fill the cache.\n+      declare\n+         S               : Object_Symbol;\n+         Sz              : uint32;\n+         Addr, Prev_Addr : uint32;\n+         Nbr_Symbols     : Natural;\n+      begin\n+         for Phase in 1 .. 2 loop\n+            Nbr_Symbols := 0;\n+            S           := First_Symbol (C.Obj.all);\n+            Prev_Addr   := uint32'Last;\n+            while S /= Null_Symbol loop\n+               --  Discard symbols whose length is 0\n+               Sz := uint32 (Size (S));\n+\n+               --  Try to filter symbols at the same address. This is a best\n+               --  effort as they might not be consecutive.\n+               Addr := uint32 (Value (S) - uint64 (C.Low));\n+               if Sz > 0 and then Addr /= Prev_Addr then\n+                  Nbr_Symbols := Nbr_Symbols + 1;\n+                  Prev_Addr   := Addr;\n+\n+                  if Phase = 2 then\n+                     C.Cache (Nbr_Symbols) :=\n+                       (First => Addr,\n+                        Size  => Sz,\n+                        Sym   => uint32 (Off (S)),\n+                        Line  => 0);\n+                  end if;\n+               end if;\n+\n+               S := Next_Symbol (C.Obj.all, S);\n+            end loop;\n+\n+            if Phase = 1 then\n+               --  Allocate the cache\n+               Cache   := new Search_Array (1 .. Nbr_Symbols);\n+               C.Cache := Cache;\n+            end if;\n+         end loop;\n+         pragma Assert (Nbr_Symbols = C.Cache'Last);\n+      end;\n+\n+      --  Sort the cache.\n+      Sort_Search_Array (C.Cache.all);\n+\n+      --  Set line offsets\n+      if not C.Has_Debug then\n+         return;\n+      end if;\n+      declare\n+         Info_Offset : Offset;\n+         Line_Offset : Offset;\n+         Success     : Boolean;\n+         Ar_Start    : Integer_Address;\n+         Ar_Len      : Storage_Count;\n+         Start, Len  : uint32;\n+         First, Last : Natural;\n+         Mid         : Natural;\n+      begin\n+         Seek (C.Aranges, 0);\n+\n+         while Tell (C.Aranges) < Length (C.Aranges) loop\n+            Read_Aranges_Header (C, Info_Offset, Success);\n+            exit when not Success;\n+\n+            Debug_Info_Lookup (C, Info_Offset, Line_Offset, Success);\n+            exit when not Success;\n+\n+            --  Read table\n+            loop\n+               Read_Aranges_Entry (C, Ar_Start, Ar_Len);\n+               exit when Ar_Start = 0 and Ar_Len = 0;\n+\n+               Len   := uint32 (Ar_Len);\n+               Start := uint32 (Ar_Start - To_Integer (C.Low));\n+\n+               --  Search START in the array\n+               First := Cache'First;\n+               Last  := Cache'Last;\n+               Mid := First;  --  In case of array with one element\n+               while First < Last loop\n+                  Mid := First + (Last - First) / 2;\n+                  if Start < Cache (Mid).First then\n+                     Last := Mid - 1;\n+                  elsif Start >= Cache (Mid).First + Cache (Mid).Size then\n+                     First := Mid + 1;\n+                  else\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               --  Fill info.\n+\n+               --  There can be overlapping symbols\n+               while Mid > Cache'First\n+                 and then Cache (Mid - 1).First <= Start\n+                 and then Cache (Mid - 1).First + Cache (Mid - 1).Size > Start\n+               loop\n+                  Mid := Mid - 1;\n+               end loop;\n+               while Mid <= Cache'Last loop\n+                  if Start < Cache (Mid).First + Cache (Mid).Size\n+                    and then Start + Len > Cache (Mid).First\n+                  then\n+                     --  MID is within the bounds\n+                     Cache (Mid).Line := uint32 (Line_Offset);\n+                  elsif Start + Len <= Cache (Mid).First then\n+                     --  Over\n+                     exit;\n+                  end if;\n+                  Mid := Mid + 1;\n+               end loop;\n+            end loop;\n+         end loop;\n+      end;\n+   end Enable_Cache;\n+\n+   ----------------------\n+   -- Symbolic_Address --\n+   ----------------------\n+\n+   procedure Symbolic_Address\n+     (C           : in out Dwarf_Context;\n+      Addr        :        Address;\n+      Dir_Name    :    out Str_Access;\n+      File_Name   :    out Str_Access;\n+      Subprg_Name :    out String_Ptr_Len;\n+      Line_Num    :    out Natural)\n+   is\n+      procedure Set_Result (Match : Line_Info_Registers);\n+      --  Set results using match\n+\n+      procedure Set_Result (Match : Line_Info_Registers) is\n+         Dir_Idx : uint32;\n+         J       : uint32;\n+\n+         Mod_Time : uint32;\n+         pragma Unreferenced (Mod_Time);\n+\n+         Length : uint32;\n+         pragma Unreferenced (Length);\n+\n+      begin\n+         Seek (C.Lines, C.Prologue.File_Names_Offset);\n+\n+         --  Find the entry\n+\n+         J := 0;\n+         loop\n+            J         := J + 1;\n+            File_Name := Read_C_String (C.Lines);\n+\n+            if File_Name (File_Name'First) = ASCII.NUL then\n+               --  End of file list, so incorrect entry\n+               return;\n+            end if;\n+\n+            Dir_Idx  := Read_LEB128 (C.Lines);\n+            Mod_Time := Read_LEB128 (C.Lines);\n+            Length   := Read_LEB128 (C.Lines);\n+            exit when J = Match.File;\n+         end loop;\n+\n+         if Dir_Idx = 0 then\n+            --  No directory\n+            Dir_Name := null;\n+\n+         else\n+            Seek (C.Lines, C.Prologue.Includes_Offset);\n+\n+            J := 0;\n+            loop\n+               J        := J + 1;\n+               Dir_Name := Read_C_String (C.Lines);\n+\n+               if Dir_Name (Dir_Name'First) = ASCII.NUL then\n+                  --  End of directory list, so ill-formed table\n+                  return;\n+               end if;\n+\n+               exit when J = Dir_Idx;\n+\n+            end loop;\n+         end if;\n+\n+         Line_Num := Natural (Match.Line);\n+      end Set_Result;\n+\n+      Addr_Int     : constant Integer_Address := To_Integer (Addr);\n+      Previous_Row : Line_Info_Registers;\n+      Info_Offset  : Offset;\n+      Line_Offset  : Offset;\n+      Success      : Boolean;\n+      Done         : Boolean;\n+      S            : Object_Symbol;\n+   begin\n+      --  Initialize result\n+      Dir_Name    := null;\n+      File_Name   := null;\n+      Subprg_Name := (null, 0);\n+      Line_Num    := 0;\n+\n+      if C.Cache /= null then\n+         --  Look in the cache\n+         declare\n+            Addr_Off         : constant uint32 := uint32 (Addr - C.Low);\n+            First, Last, Mid : Natural;\n+         begin\n+            First := C.Cache'First;\n+            Last  := C.Cache'Last;\n+            while First <= Last loop\n+               Mid := First + (Last - First) / 2;\n+               if Addr_Off < C.Cache (Mid).First then\n+                  Last := Mid - 1;\n+               elsif Addr_Off >= C.Cache (Mid).First + C.Cache (Mid).Size then\n+                  First := Mid + 1;\n+               else\n+                  exit;\n+               end if;\n+            end loop;\n+            if Addr_Off >= C.Cache (Mid).First\n+              and then Addr_Off < C.Cache (Mid).First + C.Cache (Mid).Size\n+            then\n+               Line_Offset := Offset (C.Cache (Mid).Line);\n+               S := Read_Symbol (C.Obj.all, Offset (C.Cache (Mid).Sym));\n+               Subprg_Name := Object_Reader.Name (C.Obj.all, S);\n+            else\n+               --  Not found\n+               return;\n+            end if;\n+         end;\n+      else\n+         --  Search symbol\n+         S := First_Symbol (C.Obj.all);\n+         while S /= Null_Symbol loop\n+            if Spans (S, uint64 (Addr_Int)) then\n+               Subprg_Name := Object_Reader.Name (C.Obj.all, S);\n+               exit;\n+            end if;\n+\n+            S := Next_Symbol (C.Obj.all, S);\n+         end loop;\n+\n+         --  Search address in aranges table\n+\n+         Aranges_Lookup (C, Addr, Info_Offset, Success);\n+         if not Success then\n+            return;\n+         end if;\n+\n+         --  Search stmt_list in info table\n+\n+         Debug_Info_Lookup (C, Info_Offset, Line_Offset, Success);\n+         if not Success then\n+            return;\n+         end if;\n+      end if;\n+\n+      Seek (C.Lines, Line_Offset);\n+      C.Next_Prologue := 0;\n+      Initialize_State_Machine (C);\n+      Parse_Prologue (C);\n+\n+      --  Advance to the first entry\n+\n+      loop\n+         Read_And_Execute_Isn (C, Done);\n+\n+         if C.Registers.Is_Row then\n+            Previous_Row := C.Registers;\n+            exit;\n+         end if;\n+\n+         exit when Done;\n+      end loop;\n+\n+      --  Read the rest of the entries\n+\n+      while Tell (C.Lines) < C.Next_Prologue loop\n+         Read_And_Execute_Isn (C, Done);\n+\n+         if C.Registers.Is_Row then\n+            if not Previous_Row.End_Sequence\n+              and then Addr_Int >= Integer_Address (Previous_Row.Address)\n+              and then Addr_Int < Integer_Address (C.Registers.Address)\n+            then\n+               Set_Result (Previous_Row);\n+               return;\n+\n+            elsif Addr_Int = Integer_Address (C.Registers.Address) then\n+               Set_Result (C.Registers);\n+               return;\n+            end if;\n+\n+            Previous_Row := C.Registers;\n+         end if;\n+\n+         exit when Done;\n+      end loop;\n+   end Symbolic_Address;\n+\n+   -------------------\n+   -- String_Length --\n+   -------------------\n+\n+   function String_Length (Str : Str_Access) return Natural is\n+   begin\n+      for I in Str'Range loop\n+         if Str (I) = ASCII.NUL then\n+            return I - Str'First;\n+         end if;\n+      end loop;\n+      return Str'Last;\n+   end String_Length;\n+\n+   ------------------------\n+   -- Symbolic_Traceback --\n+   ------------------------\n+\n+   procedure Symbolic_Traceback\n+     (Cin          :        Dwarf_Context;\n+      Traceback    :        AET.Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Symbol_Found : in out Boolean;\n+      Res          : in out System.Bounded_Strings.Bounded_String)\n+   is\n+      use Ada.Characters.Handling;\n+      C    : Dwarf_Context := Cin;\n+      Addr : Address;\n+\n+      Dir_Name    : Str_Access;\n+      File_Name   : Str_Access;\n+      Subprg_Name : String_Ptr_Len;\n+      Line_Num    : Natural;\n+      Off         : Natural;\n+   begin\n+      if not C.Has_Debug then\n+         Symbol_Found := False;\n+         return;\n+      else\n+         Symbol_Found := True;\n+      end if;\n+\n+      for J in Traceback'Range loop\n+         --  If the buffer is full, no need to do any useless work\n+         exit when Is_Full (Res);\n+\n+         Addr := PC_For (Traceback (J));\n+         Symbolic_Address\n+           (C,\n+            To_Address (To_Integer (Addr) + C.Load_Slide),\n+            Dir_Name,\n+            File_Name,\n+            Subprg_Name,\n+            Line_Num);\n+\n+         if File_Name /= null then\n+            declare\n+               Last   : constant Natural := String_Length (File_Name);\n+               Is_Ada : constant Boolean :=\n+                 Last > 3\n+                 and then\n+                   To_Upper (String (File_Name (Last - 3 .. Last - 1))) =\n+                   \".AD\";\n+               --  True if this is an Ada file. This doesn't take into account\n+               --  nonstandard file-naming conventions, but that's OK; this is\n+               --  purely cosmetic. It covers at least .ads, .adb, and .ada.\n+\n+               Line_Image : constant String := Natural'Image (Line_Num);\n+            begin\n+               if Subprg_Name.Len /= 0 then\n+                  --  For Ada code, Symbol_Image is in all lower case; we don't\n+                  --  have the case from the original source code. But the best\n+                  --  guess is Mixed_Case, so convert to that.\n+\n+                  if Is_Ada then\n+                     declare\n+                        Symbol_Image : String :=\n+                          Object_Reader.Decoded_Ada_Name\n+                            (C.Obj.all,\n+                             Subprg_Name);\n+                     begin\n+                        for K in Symbol_Image'Range loop\n+                           if K = Symbol_Image'First\n+                             or else not\n+                             (Is_Letter (Symbol_Image (K - 1))\n+                              or else Is_Digit (Symbol_Image (K - 1)))\n+                           then\n+                              Symbol_Image (K) := To_Upper (Symbol_Image (K));\n+                           end if;\n+                        end loop;\n+                        Append (Res, Symbol_Image);\n+                     end;\n+                  else\n+                     Off := Strip_Leading_Char (C.Obj.all, Subprg_Name);\n+\n+                     Append\n+                       (Res,\n+                        String (Subprg_Name.Ptr (Off .. Subprg_Name.Len)));\n+                  end if;\n+                  Append (Res, ' ');\n+               end if;\n+\n+               Append (Res, \"at \");\n+               Append (Res, String (File_Name (1 .. Last)));\n+               Append (Res, ':');\n+               Append (Res, Line_Image (2 .. Line_Image'Last));\n+            end;\n+         else\n+            if Suppress_Hex then\n+               Append (Res, \"...\");\n+            else\n+               Append_Address (Res, Addr);\n+            end if;\n+\n+            if Subprg_Name.Len > 0 then\n+               Off := Strip_Leading_Char (C.Obj.all, Subprg_Name);\n+\n+               Append (Res, ' ');\n+               Append (Res, String (Subprg_Name.Ptr (Off .. Subprg_Name.Len)));\n+            end if;\n+\n+            Append (Res, \" at ???\");\n+         end if;\n+\n+         Append (Res, ASCII.LF);\n+      end loop;\n+   end Symbolic_Traceback;\n+end System.Dwarf_Lines;"}, {"sha": "3608fef3ade827c8b70a152349da294258b2240b", "filename": "gcc/ada/s-dwalin.ads", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-dwalin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-dwalin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dwalin.ads?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,191 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . D W A R F _ L I N E S                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--           Copyright (C) 2009-2017, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides routines to read DWARF line number information from\n+--  a generic object file with as little overhead as possible. This allows\n+--  conversions from PC addresses to human readable source locations.\n+--\n+--  Objects must be built with debugging information, however only the\n+--  .debug_line section of the object file is referenced. In cases where object\n+--  size is a consideration it's possible to strip all other .debug sections,\n+--  which will decrease the size of the object significantly.\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we can get\n+--  elaboration circularities when polling is turned on\n+\n+with Ada.Exceptions.Traceback;\n+\n+with System.Object_Reader;\n+with System.Storage_Elements;\n+with System.Bounded_Strings;\n+\n+package System.Dwarf_Lines is\n+\n+   package AET renames Ada.Exceptions.Traceback;\n+   package SOR renames System.Object_Reader;\n+\n+   type Dwarf_Context (In_Exception : Boolean := False) is private;\n+   --  Type encapsulation the state of the Dwarf reader. When In_Exception\n+   --  is True we are parsing as part of a exception handler decorator, we do\n+   --  not want an exception to be raised, the parsing is done safely skipping\n+   --  DWARF file that cannot be read or with stripped debug section for\n+   --  example.\n+\n+   procedure Open\n+     (File_Name :     String;\n+      C         : out Dwarf_Context;\n+      Success   : out Boolean);\n+   procedure Close (C : in out Dwarf_Context);\n+   --  Open and close files\n+\n+   procedure Set_Load_Address (C : in out Dwarf_Context; Addr : Address);\n+   --  Set the load address of a file. This is used to rebase PIE (Position\n+   --  Independant Executable) binaries.\n+\n+   function Is_Inside (C : Dwarf_Context; Addr : Address) return Boolean;\n+   pragma Inline (Is_Inside);\n+   --  Return true iff Addr is within the module\n+\n+   function Low (C : Dwarf_Context) return Address;\n+   pragma Inline (Low);\n+   --  Return the lowest address of C\n+\n+   procedure Dump (C : in out Dwarf_Context);\n+   --  Dump each row found in the object's .debug_lines section to standard out\n+\n+   procedure Dump_Cache (C : Dwarf_Context);\n+   --  Dump the cache (if present)\n+\n+   procedure Enable_Cache (C : in out Dwarf_Context);\n+   --  Read symbols information to speed up Symbolic_Traceback.\n+\n+   procedure Symbolic_Traceback\n+     (Cin          :        Dwarf_Context;\n+      Traceback    :        AET.Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Symbol_Found : in out Boolean;\n+      Res          : in out System.Bounded_Strings.Bounded_String);\n+   --  Generate a string for a traceback suitable for displaying to the user.\n+   --  If one or more symbols are found, Symbol_Found is set to True. This\n+   --  allows the caller to fall back to hexadecimal addresses.\n+\n+   Dwarf_Error : exception;\n+   --  Raised if a problem is encountered parsing DWARF information. Can be a\n+   --  result of a logic error or malformed DWARF information.\n+\n+private\n+   --  The following section numbers reference\n+\n+   --    \"DWARF Debugging Information Format, Version 3\"\n+\n+   --  published by the Standards Group, http://freestandards.org.\n+\n+   --  6.2.2 State Machine Registers\n+\n+   type Line_Info_Registers is record\n+      Address        : SOR.uint64;\n+      File           : SOR.uint32;\n+      Line           : SOR.uint32;\n+      Column         : SOR.uint32;\n+      Is_Stmt        : Boolean;\n+      Basic_Block    : Boolean;\n+      End_Sequence   : Boolean;\n+      Prologue_End   : Boolean;\n+      Epilogue_Begin : Boolean;\n+      ISA            : SOR.uint32;\n+      Is_Row         : Boolean;\n+   end record;\n+\n+   --  6.2.4 The Line Number Program Prologue\n+\n+   MAX_OPCODE_LENGTHS : constant := 256;\n+\n+   type Opcodes_Lengths_Array is\n+     array (SOR.uint32 range 1 .. MAX_OPCODE_LENGTHS) of SOR.uint8;\n+\n+   type Line_Info_Prologue is record\n+      Unit_Length       : SOR.uint32;\n+      Version           : SOR.uint16;\n+      Prologue_Length   : SOR.uint32;\n+      Min_Isn_Length    : SOR.uint8;\n+      Default_Is_Stmt   : SOR.uint8;\n+      Line_Base         : SOR.int8;\n+      Line_Range        : SOR.uint8;\n+      Opcode_Base       : SOR.uint8;\n+      Opcode_Lengths    : Opcodes_Lengths_Array;\n+      Includes_Offset   : SOR.Offset;\n+      File_Names_Offset : SOR.Offset;\n+   end record;\n+\n+   type Search_Entry is record\n+      First : SOR.uint32;\n+      Size  : SOR.uint32;\n+      --  Function bounds as offset to the base address.\n+\n+      Sym : SOR.uint32;\n+      --  Symbol offset to get the name.\n+\n+      Line : SOR.uint32;\n+      --  Dwarf line offset.\n+   end record;\n+\n+   type Search_Array is array (Natural range <>) of Search_Entry;\n+\n+   type Search_Array_Access is access Search_Array;\n+\n+   type Dwarf_Context (In_Exception : Boolean := False) is record\n+      Load_Slide : System.Storage_Elements.Integer_Address := 0;\n+      Low, High  : Address;\n+      --  Bounds of the module\n+\n+      Obj : SOR.Object_File_Access;\n+      --  The object file containing dwarf sections\n+\n+      Has_Debug : Boolean;\n+      --  True if all debug sections are available\n+\n+      Cache : Search_Array_Access;\n+      --  Quick access to symbol and debug info (when present).\n+\n+      Lines   : SOR.Mapped_Stream;\n+      Aranges : SOR.Mapped_Stream;\n+      Info    : SOR.Mapped_Stream;\n+      Abbrev  : SOR.Mapped_Stream;\n+      --  Dwarf line, aranges, info and abbrev sections\n+\n+      Prologue      : Line_Info_Prologue;\n+      Registers     : Line_Info_Registers;\n+      Next_Prologue : SOR.Offset;\n+      --  State for lines\n+   end record;\n+\n+end System.Dwarf_Lines;"}, {"sha": "451abcd3d7b9bc23cb300d74e8f0eb480e8ae738", "filename": "gcc/ada/s-objrea.adb", "status": "added", "additions": 2246, "deletions": 0, "changes": 2246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-objrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-objrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-objrea.adb?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,2246 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . O B J E C T _ R E A D E R                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--         Copyright (C) 2009-2017, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+\n+with Interfaces.C;\n+\n+with System.CRTL;\n+\n+package body System.Object_Reader is\n+   use Interfaces;\n+   use Interfaces.C;\n+   use System.Mmap;\n+\n+   SSU : constant := System.Storage_Unit;\n+\n+   function To_int32 is new Ada.Unchecked_Conversion (uint32, int32);\n+\n+   function Trim_Trailing_Nuls (Str : String) return String;\n+   --  Return a copy of a string with any trailing NUL characters truncated\n+\n+   procedure Check_Read_Offset (S : in out Mapped_Stream; Size : uint32);\n+   --  Check that the SIZE bytes at the current offset are still in the stream\n+\n+   -------------------------------------\n+   -- ELF object file format handling --\n+   -------------------------------------\n+\n+   generic\n+      type uword is mod <>;\n+\n+   package ELF_Ops is\n+\n+      --  ELF version codes\n+\n+      ELFCLASS32 : constant := 1;  --  32 bit ELF\n+      ELFCLASS64 : constant := 2;  --  64 bit ELF\n+\n+      --  ELF machine codes\n+\n+      EM_NONE        : constant :=  0; --  No machine\n+      EM_SPARC       : constant :=  2; --  SUN SPARC\n+      EM_386         : constant :=  3; --  Intel 80386\n+      EM_MIPS        : constant :=  8; --  MIPS RS3000 Big-Endian\n+      EM_MIPS_RS3_LE : constant := 10; --  MIPS RS3000 Little-Endian\n+      EM_SPARC32PLUS : constant := 18; --  Sun SPARC 32+\n+      EM_PPC         : constant := 20; --  PowerPC\n+      EM_PPC64       : constant := 21; --  PowerPC 64-bit\n+      EM_ARM         : constant := 40; --  ARM\n+      EM_SPARCV9     : constant := 43; --  SPARC v9 64-bit\n+      EM_IA_64       : constant := 50; --  Intel Merced\n+      EM_X86_64      : constant := 62; --  AMD x86-64 architecture\n+\n+      EN_NIDENT  : constant := 16;\n+\n+      type E_Ident_Type is array (0 .. EN_NIDENT - 1) of uint8;\n+\n+      type Header is record\n+         E_Ident     : E_Ident_Type; -- Magic number and other info\n+         E_Type      : uint16;       -- Object file type\n+         E_Machine   : uint16;       -- Architecture\n+         E_Version   : uint32;       -- Object file version\n+         E_Entry     : uword;        -- Entry point virtual address\n+         E_Phoff     : uword;        -- Program header table file offset\n+         E_Shoff     : uword;        -- Section header table file offset\n+         E_Flags     : uint32;       -- Processor-specific flags\n+         E_Ehsize    : uint16;       -- ELF header size in bytes\n+         E_Phentsize : uint16;       -- Program header table entry size\n+         E_Phnum     : uint16;       -- Program header table entry count\n+         E_Shentsize : uint16;       -- Section header table entry size\n+         E_Shnum     : uint16;       -- Section header table entry count\n+         E_Shstrndx  : uint16;       -- Section header string table index\n+      end record;\n+\n+      type Section_Header is record\n+         Sh_Name      : uint32; -- Section name string table index\n+         Sh_Type      : uint32; -- Section type\n+         Sh_Flags     : uword;  -- Section flags\n+         Sh_Addr      : uword;  -- Section virtual addr at execution\n+         Sh_Offset    : uword;  -- Section file offset\n+         Sh_Size      : uword;  -- Section size in bytes\n+         Sh_Link      : uint32; -- Link to another section\n+         Sh_Info      : uint32; -- Additional section information\n+         Sh_Addralign : uword;  -- Section alignment\n+         Sh_Entsize   : uword;  -- Entry size if section holds table\n+      end record;\n+\n+      SHF_ALLOC : constant := 2;\n+\n+      type Symtab_Entry32 is record\n+         St_Name  : uint32;  --  Name (string table index)\n+         St_Value : uint32;  --  Value\n+         St_Size  : uint32;  --  Size in bytes\n+         St_Info  : uint8;   --  Type and binding attributes\n+         St_Other : uint8;   --  Undefined\n+         St_Shndx : uint16;  --  Defining section\n+      end record;\n+\n+      type Symtab_Entry64 is record\n+         St_Name  : uint32;  --  Name (string table index)\n+         St_Info  : uint8;   --  Type and binding attributes\n+         St_Other : uint8;   --  Undefined\n+         St_Shndx : uint16;  --  Defining section\n+         St_Value : uint64;  --  Value\n+         St_Size  : uint64;  --  Size in bytes\n+      end record;\n+\n+      function Read_Header (F : in out Mapped_Stream) return Header;\n+      --  Read a header from an ELF format object\n+\n+      function First_Symbol\n+        (Obj : in out ELF_Object_File) return Object_Symbol;\n+      --  Return the first element in the symbol table, or Null_Symbol if the\n+      --  symbol table is empty.\n+\n+      function Read_Symbol\n+        (Obj : in out ELF_Object_File;\n+         Off : Offset) return Object_Symbol;\n+      --  Read a symbol at offset Off\n+\n+      function Name\n+        (Obj : in out ELF_Object_File;\n+         Sym : Object_Symbol) return String_Ptr_Len;\n+      --  Return the name of the symbol\n+\n+      function Name\n+        (Obj : in out ELF_Object_File;\n+         Sec : Object_Section) return String;\n+      --  Return the name of a section\n+\n+      function Get_Section\n+        (Obj   : in out ELF_Object_File;\n+         Shnum : uint32) return Object_Section;\n+      --  Fetch a section by index from zero\n+\n+      function Initialize\n+        (F            : Mapped_File;\n+         Hdr          : Header;\n+         In_Exception : Boolean) return ELF_Object_File;\n+      --  Initialize an object file\n+\n+   end ELF_Ops;\n+\n+   -----------------------------------\n+   -- PECOFF object format handling --\n+   -----------------------------------\n+\n+   package PECOFF_Ops is\n+\n+      --  Constants and data layout are taken from the document \"Microsoft\n+      --  Portable Executable and Common Object File Format Specification\"\n+      --  Revision 8.1.\n+\n+      Signature_Loc_Offset : constant := 16#3C#;\n+      --  Offset of pointer to the file signature\n+\n+      Size_Of_Standard_Header_Fields : constant := 16#18#;\n+      --  Length in bytes of the standard header record\n+\n+      Function_Symbol_Type : constant := 16#20#;\n+      --  Type field value indicating a symbol refers to a function\n+\n+      Not_Function_Symbol_Type : constant := 16#00#;\n+      --  Type field value indicating a symbol does not refer to a function\n+\n+      type Magic_Array is array (0 .. 3) of uint8;\n+      --  Array of magic numbers from the header\n+\n+      --  Magic numbers for PECOFF variants\n+\n+      VARIANT_PE32      : constant := 16#010B#;\n+      VARIANT_PE32_PLUS : constant := 16#020B#;\n+\n+      --  PECOFF machine codes\n+\n+      IMAGE_FILE_MACHINE_I386  : constant := 16#014C#;\n+      IMAGE_FILE_MACHINE_IA64  : constant := 16#0200#;\n+      IMAGE_FILE_MACHINE_AMD64 : constant := 16#8664#;\n+\n+      --  PECOFF Data layout\n+\n+      type Header is record\n+         Magics               : Magic_Array;\n+         Machine              : uint16;\n+         NumberOfSections     : uint16;\n+         TimeDateStamp        : uint32;\n+         PointerToSymbolTable : uint32;\n+         NumberOfSymbols      : uint32;\n+         SizeOfOptionalHeader : uint16;\n+         Characteristics      : uint16;\n+         Variant              : uint16;\n+      end record;\n+\n+      pragma Pack (Header);\n+\n+      type Optional_Header_PE32 is record\n+         Magic                       : uint16;\n+         MajorLinkerVersion          : uint8;\n+         MinorLinkerVersion          : uint8;\n+         SizeOfCode                  : uint32;\n+         SizeOfInitializedData       : uint32;\n+         SizeOfUninitializedData     : uint32;\n+         AddressOfEntryPoint         : uint32;\n+         BaseOfCode                  : uint32;\n+         BaseOfData                  : uint32; --  Note: not in PE32+\n+         ImageBase                   : uint32;\n+         SectionAlignment            : uint32;\n+         FileAlignment               : uint32;\n+         MajorOperatingSystemVersion : uint16;\n+         MinorOperationSystemVersion : uint16;\n+         MajorImageVersion           : uint16;\n+         MinorImageVersion           : uint16;\n+         MajorSubsystemVersion       : uint16;\n+         MinorSubsystemVersion       : uint16;\n+         Win32VersionValue           : uint32;\n+         SizeOfImage                 : uint32;\n+         SizeOfHeaders               : uint32;\n+         Checksum                    : uint32;\n+         Subsystem                   : uint16;\n+         DllCharacteristics          : uint16;\n+         SizeOfStackReserve          : uint32;\n+         SizeOfStackCommit           : uint32;\n+         SizeOfHeapReserve           : uint32;\n+         SizeOfHeapCommit            : uint32;\n+         LoaderFlags                 : uint32;\n+         NumberOfRvaAndSizes         : uint32;\n+      end record;\n+      pragma Pack (Optional_Header_PE32);\n+      pragma Assert (Optional_Header_PE32'Size = 96 * SSU);\n+\n+      type Optional_Header_PE64 is record\n+         Magic                       : uint16;\n+         MajorLinkerVersion          : uint8;\n+         MinorLinkerVersion          : uint8;\n+         SizeOfCode                  : uint32;\n+         SizeOfInitializedData       : uint32;\n+         SizeOfUninitializedData     : uint32;\n+         AddressOfEntryPoint         : uint32;\n+         BaseOfCode                  : uint32;\n+         ImageBase                   : uint64;\n+         SectionAlignment            : uint32;\n+         FileAlignment               : uint32;\n+         MajorOperatingSystemVersion : uint16;\n+         MinorOperationSystemVersion : uint16;\n+         MajorImageVersion           : uint16;\n+         MinorImageVersion           : uint16;\n+         MajorSubsystemVersion       : uint16;\n+         MinorSubsystemVersion       : uint16;\n+         Win32VersionValue           : uint32;\n+         SizeOfImage                 : uint32;\n+         SizeOfHeaders               : uint32;\n+         Checksum                    : uint32;\n+         Subsystem                   : uint16;\n+         DllCharacteristics          : uint16;\n+         SizeOfStackReserve          : uint64;\n+         SizeOfStackCommit           : uint64;\n+         SizeOfHeapReserve           : uint64;\n+         SizeOfHeapCommit            : uint64;\n+         LoaderFlags                 : uint32;\n+         NumberOfRvaAndSizes         : uint32;\n+      end record;\n+      pragma Pack (Optional_Header_PE64);\n+      pragma Assert (Optional_Header_PE64'Size = 112 * SSU);\n+\n+      subtype Name_Str is String (1 .. 8);\n+\n+      type Section_Header is record\n+         Name                 : Name_Str;\n+         VirtualSize          : uint32;\n+         VirtualAddress       : uint32;\n+         SizeOfRawData        : uint32;\n+         PointerToRawData     : uint32;\n+         PointerToRelocations : uint32;\n+         PointerToLinenumbers : uint32;\n+         NumberOfRelocations  : uint16;\n+         NumberOfLinenumbers  : uint16;\n+         Characteristics      : uint32;\n+      end record;\n+\n+      pragma Pack (Section_Header);\n+\n+      IMAGE_SCN_CNT_CODE : constant := 16#0020#;\n+\n+      type Symtab_Entry is record\n+         Name                  : Name_Str;\n+         Value                 : uint32;\n+         SectionNumber         : int16;\n+         TypeField             : uint16;\n+         StorageClass          : uint8;\n+         NumberOfAuxSymbols    : uint8;\n+      end record;\n+\n+      pragma Pack (Symtab_Entry);\n+\n+      type Auxent_Section is record\n+         Length              : uint32;\n+         NumberOfRelocations : uint16;\n+         NumberOfLinenumbers : uint16;\n+         CheckSum            : uint32;\n+         Number              : uint16;\n+         Selection           : uint8;\n+         Unused1             : uint8;\n+         Unused2             : uint8;\n+         Unused3             : uint8;\n+      end record;\n+\n+      for Auxent_Section'Size use 18 * 8;\n+\n+      function Read_Header (F : in out Mapped_Stream) return Header;\n+      --  Read the object file header\n+\n+      function First_Symbol\n+        (Obj : in out PECOFF_Object_File) return Object_Symbol;\n+      --  Return the first element in the symbol table, or Null_Symbol if the\n+      --  symbol table is empty.\n+\n+      function Read_Symbol\n+        (Obj : in out PECOFF_Object_File;\n+         Off : Offset) return Object_Symbol;\n+      --  Read a symbol at offset Off\n+\n+      function Name\n+        (Obj : in out PECOFF_Object_File;\n+         Sym : Object_Symbol) return String_Ptr_Len;\n+      --  Return the name of the symbol\n+\n+      function Name\n+        (Obj : in out PECOFF_Object_File;\n+         Sec : Object_Section) return String;\n+      --  Return the name of a section\n+\n+      function Get_Section\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : uint32) return Object_Section;\n+      --  Fetch a section by index from zero\n+\n+      function Initialize\n+        (F            : Mapped_File;\n+         Hdr          : Header;\n+         In_Exception : Boolean) return PECOFF_Object_File;\n+      --  Initialize an object file\n+\n+   end PECOFF_Ops;\n+\n+   -------------------------------------\n+   -- XCOFF-32 object format handling --\n+   -------------------------------------\n+\n+   package XCOFF32_Ops is\n+\n+      --  XCOFF Data layout\n+\n+      type Header is record\n+         f_magic  : uint16;\n+         f_nscns  : uint16;\n+         f_timdat : uint32;\n+         f_symptr : uint32;\n+         f_nsyms  : uint32;\n+         f_opthdr : uint16;\n+         f_flags  : uint16;\n+      end record;\n+\n+      type Auxiliary_Header is record\n+         o_mflag      : uint16;\n+         o_vstamp     : uint16;\n+         o_tsize      : uint32;\n+         o_dsize      : uint32;\n+         o_bsize      : uint32;\n+         o_entry      : uint32;\n+         o_text_start : uint32;\n+         o_data_start : uint32;\n+         o_toc        : uint32;\n+         o_snentry    : uint16;\n+         o_sntext     : uint16;\n+         o_sndata     : uint16;\n+         o_sntoc      : uint16;\n+         o_snloader   : uint16;\n+         o_snbss      : uint16;\n+         o_algntext   : uint16;\n+         o_algndata   : uint16;\n+         o_modtype    : uint16;\n+         o_cpuflag    : uint8;\n+         o_cputype    : uint8;\n+         o_maxstack   : uint32;\n+         o_maxdata    : uint32;\n+         o_debugger   : uint32;\n+         o_flags      : uint8;\n+         o_sntdata    : uint16;\n+         o_sntbss     : uint16;\n+      end record;\n+      pragma Unreferenced (Auxiliary_Header);\n+      --  Not used, but not removed (just in case)\n+\n+      subtype Name_Str is String (1 .. 8);\n+\n+      type Section_Header is record\n+         s_name    : Name_Str;\n+         s_paddr   : uint32;\n+         s_vaddr   : uint32;\n+         s_size    : uint32;\n+         s_scnptr  : uint32;\n+         s_relptr  : uint32;\n+         s_lnnoptr : uint32;\n+         s_nreloc  : uint16;\n+         s_nlnno   : uint16;\n+         s_flags   : uint32;\n+      end record;\n+\n+      pragma Pack (Section_Header);\n+\n+      STYP_TEXT : constant := 16#0020#;\n+\n+      type Symbol_Entry is record\n+         n_name   : Name_Str;\n+         n_value  : uint32;\n+         n_scnum  : uint16;\n+         n_type   : uint16;\n+         n_sclass : uint8;\n+         n_numaux : uint8;\n+      end record;\n+      for Symbol_Entry'Size use 18 * 8;\n+\n+      type Aux_Entry is record\n+         x_scnlen   : uint32;\n+         x_parmhash : uint32;\n+         x_snhash   : uint16;\n+         x_smtyp    : uint8;\n+         x_smclass  : uint8;\n+         x_stab     : uint32;\n+         x_snstab   : uint16;\n+      end record;\n+      for Aux_Entry'Size use 18 * 8;\n+\n+      pragma Pack (Aux_Entry);\n+\n+      C_EXT     : constant := 2;\n+      C_HIDEXT  : constant := 107;\n+      C_WEAKEXT : constant := 111;\n+\n+      XTY_LD : constant := 2;\n+      --  Magic constant should be documented, especially since it's changed???\n+\n+      function Read_Header (F : in out Mapped_Stream) return Header;\n+      --  Read the object file header\n+\n+      function First_Symbol\n+        (Obj : in out XCOFF32_Object_File) return Object_Symbol;\n+      --  Return the first element in the symbol table, or Null_Symbol if the\n+      --  symbol table is empty.\n+\n+      function Read_Symbol\n+        (Obj : in out XCOFF32_Object_File;\n+         Off : Offset) return Object_Symbol;\n+      --  Read a symbol at offset Off\n+\n+      function Name\n+        (Obj : in out XCOFF32_Object_File;\n+         Sym : Object_Symbol) return String_Ptr_Len;\n+      --  Return the name of the symbol\n+\n+      function Name\n+        (Obj : in out XCOFF32_Object_File;\n+         Sec : Object_Section) return String;\n+      --  Return the name of a section\n+\n+      function Initialize\n+        (F            : Mapped_File;\n+         Hdr          : Header;\n+         In_Exception : Boolean) return XCOFF32_Object_File;\n+      --  Initialize an object file\n+\n+      function Get_Section\n+          (Obj   : in out XCOFF32_Object_File;\n+           Index : uint32) return Object_Section;\n+      --  Fetch a section by index from zero\n+\n+   end XCOFF32_Ops;\n+\n+   -------------\n+   -- ELF_Ops --\n+   -------------\n+\n+   package body ELF_Ops is\n+\n+      function Get_String_Table (Obj : in out ELF_Object_File)\n+                                return Object_Section;\n+      --  Fetch the section containing the string table\n+\n+      function Get_Symbol_Table (Obj : in out ELF_Object_File)\n+                                return Object_Section;\n+      --  Fetch the section containing the symbol table\n+\n+      function Read_Section_Header\n+        (Obj   : in out ELF_Object_File;\n+         Shnum : uint32) return Section_Header;\n+      --  Read the header for an ELF format object section indexed from zero\n+\n+      ------------------\n+      -- First_Symbol --\n+      ------------------\n+\n+      function First_Symbol\n+        (Obj : in out ELF_Object_File) return Object_Symbol\n+      is\n+      begin\n+         if Obj.Symtab_Last = 0 then\n+            return Null_Symbol;\n+         else\n+            return Read_Symbol (Obj, 0);\n+         end if;\n+      end First_Symbol;\n+\n+      -----------------\n+      -- Get_Section --\n+      -----------------\n+\n+      function Get_Section\n+        (Obj   : in out ELF_Object_File;\n+         Shnum : uint32) return Object_Section\n+      is\n+         SHdr : constant Section_Header := Read_Section_Header (Obj, Shnum);\n+      begin\n+         return (Shnum,\n+                 Offset (SHdr.Sh_Offset),\n+                 uint64 (SHdr.Sh_Addr),\n+                 uint64 (SHdr.Sh_Size),\n+                 (SHdr.Sh_Flags and SHF_ALLOC) /= 0);\n+      end Get_Section;\n+\n+      ------------------------\n+      --  Get_String_Table  --\n+      ------------------------\n+\n+      function Get_String_Table\n+        (Obj : in out ELF_Object_File) return Object_Section\n+      is\n+      begin\n+         --  All cases except MIPS IRIX, string table located in .strtab\n+\n+         if Obj.Arch /= MIPS then\n+            return Get_Section (Obj, \".strtab\");\n+\n+         --  On IRIX only .dynstr is available\n+\n+         else\n+            return Get_Section (Obj, \".dynstr\");\n+         end if;\n+      end Get_String_Table;\n+\n+      ------------------------\n+      --  Get_Symbol_Table  --\n+      ------------------------\n+\n+      function Get_Symbol_Table\n+        (Obj : in out ELF_Object_File) return Object_Section\n+      is\n+      begin\n+         --  All cases except MIPS IRIX, symbol table located in .symtab\n+\n+         if Obj.Arch /= MIPS then\n+            return Get_Section (Obj, \".symtab\");\n+\n+         --  On IRIX, symbol table located somewhere other than .symtab\n+\n+         else\n+            return Get_Section (Obj, \".dynsym\");\n+         end if;\n+      end Get_Symbol_Table;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      function Initialize\n+        (F            : Mapped_File;\n+         Hdr          : Header;\n+         In_Exception : Boolean) return ELF_Object_File\n+      is\n+         Res : ELF_Object_File\n+           (Format => (case uword'Size is\n+                         when 64 => ELF64,\n+                         when 32 => ELF32,\n+                         when others => raise Program_Error));\n+         Sec : Object_Section;\n+      begin\n+         Res.MF := F;\n+         Res.In_Exception := In_Exception;\n+         Res.Num_Sections := uint32 (Hdr.E_Shnum);\n+\n+         case Hdr.E_Machine is\n+            when EM_SPARC\n+               | EM_SPARC32PLUS\n+            =>\n+               Res.Arch := SPARC;\n+\n+            when EM_386 =>\n+               Res.Arch := i386;\n+\n+            when EM_MIPS\n+               | EM_MIPS_RS3_LE\n+            =>\n+               Res.Arch := MIPS;\n+\n+            when EM_PPC =>\n+               Res.Arch := PPC;\n+\n+            when EM_PPC64 =>\n+               Res.Arch := PPC64;\n+\n+            when EM_SPARCV9 =>\n+               Res.Arch := SPARC64;\n+\n+            when EM_IA_64 =>\n+               Res.Arch := IA64;\n+\n+            when EM_X86_64 =>\n+               Res.Arch := x86_64;\n+\n+            when others =>\n+               raise Format_Error with \"unrecognized architecture\";\n+         end case;\n+\n+         --  Map section table and section string table\n+         Res.Sectab_Stream := Create_Stream\n+           (F, File_Size (Hdr.E_Shoff),\n+            File_Size (Hdr.E_Shnum) * File_Size (Hdr.E_Shentsize));\n+         Sec := Get_Section (Res, uint32 (Hdr.E_Shstrndx));\n+         Res.Secstr_Stream := Create_Stream (Res, Sec);\n+\n+         --  Map symbol and string table\n+         Sec := Get_Symbol_Table (Res);\n+         Res.Symtab_Stream := Create_Stream (Res, Sec);\n+         Res.Symtab_Last := Offset (Sec.Size);\n+\n+         Sec := Get_String_Table (Res);\n+         Res.Symstr_Stream := Create_Stream (Res, Sec);\n+\n+         return Res;\n+      end Initialize;\n+\n+      -----------------\n+      -- Read_Header --\n+      -----------------\n+\n+      function Read_Header (F : in out Mapped_Stream) return Header is\n+         Hdr : Header;\n+      begin\n+         Seek (F, 0);\n+         Read_Raw (F, Hdr'Address, uint32 (Hdr'Size / SSU));\n+         return Hdr;\n+      end Read_Header;\n+\n+      -------------------------\n+      -- Read_Section_Header --\n+      -------------------------\n+\n+      function Read_Section_Header\n+        (Obj   : in out ELF_Object_File;\n+         Shnum : uint32) return Section_Header\n+      is\n+         Shdr : Section_Header;\n+      begin\n+         Seek (Obj.Sectab_Stream, Offset (Shnum * Section_Header'Size / SSU));\n+         Read_Raw (Obj.Sectab_Stream, Shdr'Address, Section_Header'Size / SSU);\n+         return Shdr;\n+      end Read_Section_Header;\n+\n+      -----------------\n+      -- Read_Symbol --\n+      -----------------\n+\n+      function Read_Symbol\n+        (Obj : in out ELF_Object_File;\n+         Off : Offset) return Object_Symbol\n+      is\n+         ST_Entry32 : Symtab_Entry32;\n+         ST_Entry64 : Symtab_Entry64;\n+         Res        : Object_Symbol;\n+\n+      begin\n+         Seek (Obj.Symtab_Stream, Off);\n+\n+         case uword'Size is\n+            when 32 =>\n+               Read_Raw (Obj.Symtab_Stream, ST_Entry32'Address,\n+                         uint32 (ST_Entry32'Size / SSU));\n+               Res := (Off,\n+                       Off + ST_Entry32'Size / SSU,\n+                       uint64 (ST_Entry32.St_Value),\n+                       uint64 (ST_Entry32.St_Size));\n+\n+            when 64 =>\n+               Read_Raw (Obj.Symtab_Stream, ST_Entry64'Address,\n+                         uint32 (ST_Entry64'Size / SSU));\n+               Res := (Off,\n+                       Off + ST_Entry64'Size / SSU,\n+                       ST_Entry64.St_Value,\n+                       ST_Entry64.St_Size);\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         return Res;\n+      end Read_Symbol;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (Obj : in out ELF_Object_File;\n+         Sec : Object_Section) return String\n+      is\n+         SHdr : Section_Header;\n+      begin\n+         SHdr := Read_Section_Header (Obj, Sec.Num);\n+         return Offset_To_String (Obj.Secstr_Stream, Offset (SHdr.Sh_Name));\n+      end Name;\n+\n+      function Name\n+        (Obj : in out ELF_Object_File;\n+         Sym : Object_Symbol) return String_Ptr_Len\n+      is\n+         ST_Entry32 : Symtab_Entry32;\n+         ST_Entry64 : Symtab_Entry64;\n+         Name_Off   : Offset;\n+\n+      begin\n+         --  Test that this symbol is not null\n+\n+         if Sym = Null_Symbol then\n+            return (null, 0);\n+         end if;\n+\n+         --  Read the symbol table entry\n+\n+         Seek (Obj.Symtab_Stream, Sym.Off);\n+\n+         case uword'Size is\n+            when 32 =>\n+               Read_Raw (Obj.Symtab_Stream, ST_Entry32'Address,\n+                         uint32 (ST_Entry32'Size / SSU));\n+               Name_Off := Offset (ST_Entry32.St_Name);\n+\n+            when 64 =>\n+               Read_Raw (Obj.Symtab_Stream, ST_Entry64'Address,\n+                         uint32 (ST_Entry64'Size / SSU));\n+               Name_Off := Offset (ST_Entry64.St_Name);\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+         --  Fetch the name from the string table\n+\n+         Seek (Obj.Symstr_Stream, Name_Off);\n+         return Read (Obj.Symstr_Stream);\n+      end Name;\n+\n+   end ELF_Ops;\n+\n+   package ELF32_Ops is new ELF_Ops (uint32);\n+   package ELF64_Ops is new ELF_Ops (uint64);\n+\n+   ----------------\n+   -- PECOFF_Ops --\n+   ----------------\n+\n+   package body PECOFF_Ops is\n+\n+      function Decode_Name\n+        (Obj      : in out PECOFF_Object_File;\n+         Raw_Name : String) return String;\n+      --  A section name is an 8 byte field padded on the right with null\n+      --  characters, or a '\\' followed by an ASCII decimal string indicating\n+      --  an offset in to the string table. This routine decodes this\n+\n+      function Get_Section_Virtual_Address\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : uint32) return uint64;\n+      --  Fetch the address at which a section is loaded\n+\n+      function Read_Section_Header\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : uint32) return Section_Header;\n+      --  Read a header from section table\n+\n+      function String_Table\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : Offset) return String;\n+      --  Return an entry from the string table\n+\n+      -----------------\n+      -- Decode_Name --\n+      -----------------\n+\n+      function Decode_Name\n+        (Obj      : in out PECOFF_Object_File;\n+         Raw_Name : String) return String\n+      is\n+         Name_Or_Ref : constant String := Trim_Trailing_Nuls (Raw_Name);\n+         Off         : Offset;\n+\n+      begin\n+         --  We should never find a symbol with a zero length name. If we do it\n+         --  probably means we are not parsing the symbol table correctly. If\n+         --  this happens we raise a fatal error.\n+\n+         if Name_Or_Ref'Length = 0 then\n+            raise Format_Error with\n+              \"found zero length symbol in symbol table\";\n+         end if;\n+\n+         if Name_Or_Ref (1) /= '/' then\n+            return Name_Or_Ref;\n+         else\n+            Off := Offset'Value (Name_Or_Ref (2 .. Name_Or_Ref'Last));\n+            return String_Table (Obj, Off);\n+         end if;\n+      end Decode_Name;\n+\n+      ------------------\n+      -- First_Symbol --\n+      ------------------\n+\n+      function First_Symbol\n+        (Obj : in out PECOFF_Object_File) return Object_Symbol is\n+      begin\n+         --  Return Null_Symbol in the case that the symbol table is empty\n+\n+         if Obj.Symtab_Last = 0 then\n+            return Null_Symbol;\n+         end if;\n+\n+         return Read_Symbol (Obj, 0);\n+      end First_Symbol;\n+\n+      -----------------\n+      -- Get_Section --\n+      -----------------\n+\n+      function Get_Section\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : uint32) return Object_Section\n+      is\n+         Sec : constant Section_Header := Read_Section_Header (Obj, Index);\n+      begin\n+         --  Use VirtualSize instead of SizeOfRawData. The latter is rounded to\n+         --  the page size, so it may add garbage to the content. On the other\n+         --  side, the former may be larger than the latter in case of 0\n+         --  padding.\n+\n+         return (Index,\n+                 Offset (Sec.PointerToRawData),\n+                 uint64 (Sec.VirtualAddress) + Obj.ImageBase,\n+                 uint64 (Sec.VirtualSize),\n+                 (Sec.Characteristics and IMAGE_SCN_CNT_CODE) /= 0);\n+      end Get_Section;\n+\n+      ---------------------------------\n+      -- Get_Section_Virtual_Address --\n+      ---------------------------------\n+\n+      function Get_Section_Virtual_Address\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : uint32) return uint64\n+      is\n+         Sec : Section_Header;\n+\n+      begin\n+         --  Try cache\n+\n+         if Index = Obj.GSVA_Sec then\n+            return Obj.GSVA_Addr;\n+         end if;\n+\n+         Obj.GSVA_Sec := Index;\n+         Sec := Read_Section_Header (Obj, Index);\n+         Obj.GSVA_Addr := Obj.ImageBase + uint64 (Sec.VirtualAddress);\n+         return Obj.GSVA_Addr;\n+      end Get_Section_Virtual_Address;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      function Initialize\n+        (F            : Mapped_File;\n+         Hdr          : Header;\n+         In_Exception : Boolean) return PECOFF_Object_File\n+      is\n+         Res        : PECOFF_Object_File\n+           (Format => (case Hdr.Variant is\n+                         when PECOFF_Ops.VARIANT_PE32 => PECOFF,\n+                         when PECOFF_Ops.VARIANT_PE32_PLUS => PECOFF_PLUS,\n+                         when others => raise Program_Error\n+                                          with \"unrecognized PECOFF variant\"));\n+         Symtab_Size : constant Offset :=\n+           Offset (Hdr.NumberOfSymbols) * (Symtab_Entry'Size / SSU);\n+         Strtab_Size : uint32;\n+         Hdr_Offset : Offset;\n+         Opt_Offset : File_Size;\n+         Opt_Stream : Mapped_Stream;\n+      begin\n+         Res.MF := F;\n+         Res.In_Exception := In_Exception;\n+\n+         case Hdr.Machine is\n+            when PECOFF_Ops.IMAGE_FILE_MACHINE_I386  =>\n+               Res.Arch := i386;\n+            when PECOFF_Ops.IMAGE_FILE_MACHINE_IA64  =>\n+               Res.Arch := IA64;\n+            when PECOFF_Ops.IMAGE_FILE_MACHINE_AMD64 =>\n+               Res.Arch := x86_64;\n+            when others =>\n+               raise Format_Error with \"unrecognized architecture\";\n+         end case;\n+\n+         Res.Num_Sections := uint32 (Hdr.NumberOfSections);\n+\n+         --  Map symbol table and the first following word (which is the length\n+         --  of the string table).\n+\n+         Res.Symtab_Last  := Symtab_Size;\n+         Res.Symtab_Stream := Create_Stream\n+           (F,\n+            File_Size (Hdr.PointerToSymbolTable),\n+            File_Size (Symtab_Size + 4));\n+\n+         --  Map string table. The first 4 bytes are the length of the string\n+         --  table and are part of it.\n+\n+         Seek (Res.Symtab_Stream, Symtab_Size);\n+         Strtab_Size := Read (Res.Symtab_Stream);\n+         Res.Symstr_Stream := Create_Stream\n+           (F,\n+            File_Size (Hdr.PointerToSymbolTable) + File_Size (Symtab_Size),\n+            File_Size (Strtab_Size));\n+\n+         --  Map section table\n+\n+         Opt_Stream := Create_Stream (Res.Mf, Signature_Loc_Offset, 4);\n+         Hdr_Offset := Offset (uint32'(Read (Opt_Stream)));\n+         Close (Opt_Stream);\n+         Res.Sectab_Stream := Create_Stream\n+           (F,\n+            File_Size (Hdr_Offset +\n+                         Size_Of_Standard_Header_Fields +\n+                         Offset (Hdr.SizeOfOptionalHeader)),\n+            File_Size (Res.Num_Sections)\n+              * File_Size (Section_Header'Size / SSU));\n+\n+         --  Read optional header and extract image base\n+\n+         Opt_Offset := File_Size (Hdr_Offset + Size_Of_Standard_Header_Fields);\n+\n+         if Res.Format = PECOFF then\n+            declare\n+               Opt_32 : Optional_Header_PE32;\n+            begin\n+               Opt_Stream := Create_Stream\n+                 (Res.Mf, Opt_Offset, Opt_32'Size / SSU);\n+               Read_Raw\n+                 (Opt_Stream, Opt_32'Address, uint32 (Opt_32'Size / SSU));\n+               Res.ImageBase := uint64 (Opt_32.ImageBase);\n+               Close (Opt_Stream);\n+            end;\n+\n+         else\n+            declare\n+               Opt_64 : Optional_Header_PE64;\n+            begin\n+               Opt_Stream := Create_Stream\n+                 (Res.Mf, Opt_Offset, Opt_64'Size / SSU);\n+               Read_Raw\n+                 (Opt_Stream, Opt_64'Address, uint32 (Opt_64'Size / SSU));\n+               Res.ImageBase := Opt_64.ImageBase;\n+               Close (Opt_Stream);\n+            end;\n+         end if;\n+\n+         return Res;\n+      end Initialize;\n+\n+      -----------------\n+      -- Read_Symbol --\n+      -----------------\n+\n+      function Read_Symbol\n+        (Obj : in out PECOFF_Object_File;\n+         Off : Offset) return Object_Symbol\n+      is\n+         ST_Entry  : Symtab_Entry;\n+         ST_Last   : Symtab_Entry;\n+         Aux_Entry : Auxent_Section;\n+         Sz        : constant Offset := ST_Entry'Size / SSU;\n+         Result    : Object_Symbol;\n+         Noff      : Offset;\n+         Sym_Off   : Offset;\n+\n+      begin\n+         --  Seek to the successor of Prev\n+\n+         Noff := Off;\n+\n+         loop\n+            Sym_Off := Noff;\n+\n+            Seek (Obj.Symtab_Stream, Sym_Off);\n+            Read_Raw (Obj.Symtab_Stream, ST_Entry'Address, uint32 (Sz));\n+\n+            --  Skip AUX entries\n+\n+            Noff := Noff + Offset (1 + ST_Entry.NumberOfAuxSymbols) * Sz;\n+\n+            exit when ST_Entry.TypeField = Function_Symbol_Type\n+              and then ST_Entry.SectionNumber > 0;\n+\n+            if Noff >= Obj.Symtab_Last then\n+               return Null_Symbol;\n+            end if;\n+         end loop;\n+\n+         --  Construct the symbol\n+\n+         Result :=\n+           (Off   => Sym_Off,\n+            Next  => Noff,\n+            Value => uint64 (ST_Entry.Value),\n+            Size  => 0);\n+\n+         --  Set the size as accurately as possible\n+\n+         --  The size of a symbol is not directly available so we try scanning\n+         --  to the next function and assuming the code ends there.\n+\n+         loop\n+            --  Read symbol and AUX entries\n+\n+            Sym_Off := Noff;\n+            Seek (Obj.Symtab_Stream, Sym_Off);\n+            Read_Raw (Obj.Symtab_Stream, ST_Last'Address, uint32 (Sz));\n+\n+            for I in 1 .. ST_Last.NumberOfAuxSymbols loop\n+               Read_Raw (Obj.Symtab_Stream, Aux_Entry'Address, uint32 (Sz));\n+            end loop;\n+\n+            Noff := Noff + Offset (1 + ST_Last.NumberOfAuxSymbols) * Sz;\n+\n+            if ST_Last.TypeField = Function_Symbol_Type then\n+               if ST_Last.SectionNumber = ST_Entry.SectionNumber\n+                 and then ST_Last.Value >= ST_Entry.Value\n+               then\n+                  --  Symbol is a function past ST_Entry\n+\n+                  Result.Size := uint64 (ST_Last.Value - ST_Entry.Value);\n+\n+               else\n+                  --  Not correlated function\n+\n+                  Result.Next := Sym_Off;\n+               end if;\n+\n+               exit;\n+\n+            elsif ST_Last.SectionNumber = ST_Entry.SectionNumber\n+              and then ST_Last.TypeField = Not_Function_Symbol_Type\n+              and then ST_Last.StorageClass = 3\n+              and then ST_Last.NumberOfAuxSymbols = 1\n+            then\n+               --  Symbol is a section\n+\n+               Result.Size := uint64 (ST_Last.Value + Aux_Entry.Length\n+                                        - ST_Entry.Value);\n+               Result.Next := Noff;\n+               exit;\n+            end if;\n+\n+            exit when Noff >= Obj.Symtab_Last;\n+         end loop;\n+\n+         --  Relocate the address\n+\n+         Result.Value :=\n+           Result.Value + Get_Section_Virtual_Address\n+                            (Obj, uint32 (ST_Entry.SectionNumber - 1));\n+\n+         return Result;\n+      end Read_Symbol;\n+\n+      ------------------\n+      -- Read_Header  --\n+      ------------------\n+\n+      function Read_Header (F : in out Mapped_Stream) return Header is\n+         Hdr : Header;\n+         Off : int32;\n+\n+      begin\n+         --  Skip the MSDOS stub, and seek directly to the file offset\n+\n+         Seek (F, Signature_Loc_Offset);\n+         Off := Read (F);\n+\n+         --  Read the COFF file header\n+\n+         Seek (F, Offset (Off));\n+         Read_Raw (F, Hdr'Address, uint32 (Hdr'Size / SSU));\n+         return Hdr;\n+      end Read_Header;\n+\n+      -------------------------\n+      -- Read_Section_Header --\n+      -------------------------\n+\n+      function Read_Section_Header\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : uint32) return Section_Header\n+      is\n+         Sec : Section_Header;\n+      begin\n+         Seek (Obj.Sectab_Stream, Offset (Index * Section_Header'Size / SSU));\n+         Read_Raw (Obj.Sectab_Stream, Sec'Address, Section_Header'Size / SSU);\n+         return Sec;\n+      end Read_Section_Header;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (Obj : in out PECOFF_Object_File;\n+         Sec : Object_Section) return String\n+      is\n+         Shdr : constant Section_Header := Read_Section_Header (Obj, Sec.Num);\n+      begin\n+         return Decode_Name (Obj, Shdr.Name);\n+      end Name;\n+\n+      -------------------\n+      -- String_Table  --\n+      -------------------\n+\n+      function String_Table\n+        (Obj   : in out PECOFF_Object_File;\n+         Index : Offset) return String is\n+      begin\n+         --  An index of zero is used to represent an empty string, as the\n+         --  first word of the string table is specified to contain the length\n+         --  of the table rather than its contents.\n+\n+         if Index = 0 then\n+            return \"\";\n+\n+         else\n+            return Offset_To_String (Obj.Symstr_Stream, Index);\n+         end if;\n+      end String_Table;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (Obj : in out PECOFF_Object_File;\n+         Sym : Object_Symbol) return String_Ptr_Len\n+      is\n+         ST_Entry : Symtab_Entry;\n+\n+      begin\n+         Seek (Obj.Symtab_Stream, Sym.Off);\n+         Read_Raw (Obj.Symtab_Stream, ST_Entry'Address, ST_Entry'Size / SSU);\n+\n+         declare\n+            --  Symbol table entries are packed and Table_Entry.Name may not be\n+            --  sufficiently aligned to interpret as a 32 bit word, so it is\n+            --  copied to a temporary\n+\n+            Aligned_Name : Name_Str := ST_Entry.Name;\n+            for Aligned_Name'Alignment use 4;\n+\n+            First_Word : uint32;\n+            pragma Import (Ada, First_Word);\n+            --  Suppress initialization in Normalized_Scalars mode\n+            for First_Word'Address use Aligned_Name (1)'Address;\n+\n+            Second_Word : uint32;\n+            pragma Import (Ada, Second_Word);\n+            --  Suppress initialization in Normalized_Scalars mode\n+            for Second_Word'Address use Aligned_Name (5)'Address;\n+\n+         begin\n+            if First_Word = 0 then\n+               --  Second word is an offset in the symbol table\n+               if Second_Word = 0 then\n+                  return (null, 0);\n+               else\n+                  Seek (Obj.Symstr_Stream, int64 (Second_Word));\n+                  return Read (Obj.Symstr_Stream);\n+               end if;\n+            else\n+               --  Inlined symbol name\n+               Seek (Obj.Symtab_Stream, Sym.Off);\n+               return To_String_Ptr_Len (Read (Obj.Symtab_Stream), 8);\n+            end if;\n+         end;\n+      end Name;\n+\n+   end PECOFF_Ops;\n+\n+   -----------------\n+   -- XCOFF32_Ops --\n+   -----------------\n+\n+   package body XCOFF32_Ops is\n+\n+      function Read_Section_Header\n+        (Obj   : in out XCOFF32_Object_File;\n+         Index : uint32) return Section_Header;\n+      --  Read a header from section table\n+\n+      -----------------\n+      -- Read_Symbol --\n+      -----------------\n+\n+      function Read_Symbol\n+        (Obj : in out XCOFF32_Object_File;\n+         Off : Offset) return Object_Symbol\n+      is\n+         Sym     : Symbol_Entry;\n+         Sz      : constant Offset := Symbol_Entry'Size / SSU;\n+         Aux     : Aux_Entry;\n+         Result  : Object_Symbol;\n+         Noff    : Offset;\n+         Sym_Off : Offset;\n+\n+         procedure Read_LD_Symbol;\n+         --  Read the next LD symbol\n+\n+         --------------------\n+         -- Read_LD_Symbol --\n+         --------------------\n+\n+         procedure Read_LD_Symbol is\n+         begin\n+            loop\n+               Sym_Off := Noff;\n+\n+               Read_Raw (Obj.Symtab_Stream, Sym'Address, uint32 (Sz));\n+\n+               Noff := Noff + Offset (1 + Sym.n_numaux) * Sz;\n+\n+               for J in 1 .. Sym.n_numaux loop\n+                  Read_Raw (Obj.Symtab_Stream, Aux'Address, uint32 (Sz));\n+               end loop;\n+\n+               exit when Noff >= Obj.Symtab_Last;\n+\n+               exit when Sym.n_numaux = 1\n+                 and then Sym.n_scnum /= 0\n+                 and then (Sym.n_sclass = C_EXT\n+                           or else Sym.n_sclass = C_HIDEXT\n+                           or else Sym.n_sclass = C_WEAKEXT)\n+                 and then Aux.x_smtyp = XTY_LD;\n+            end loop;\n+         end Read_LD_Symbol;\n+\n+      --  Start of processing for Read_Symbol\n+\n+      begin\n+         Seek (Obj.Symtab_Stream, Off);\n+         Noff := Off;\n+         Read_LD_Symbol;\n+\n+         if Noff >= Obj.Symtab_Last then\n+            return Null_Symbol;\n+         end if;\n+\n+         --  Construct the symbol\n+\n+         Result := (Off   => Sym_Off,\n+                    Next  => Noff,\n+                    Value => uint64 (Sym.n_value),\n+                    Size  => 0);\n+\n+         --  Look for the next symbol to compute the size\n+\n+         Read_LD_Symbol;\n+\n+         if Noff >= Obj.Symtab_Last then\n+            return Null_Symbol;\n+         end if;\n+\n+         Result.Size := uint64 (Sym.n_value) - Result.Value;\n+         Result.Next := Sym_Off;\n+         return Result;\n+      end Read_Symbol;\n+\n+      ------------------\n+      -- First_Symbol --\n+      ------------------\n+\n+      function First_Symbol\n+        (Obj : in out XCOFF32_Object_File) return Object_Symbol\n+      is\n+      begin\n+         --  Return Null_Symbol in the case that the symbol table is empty\n+\n+         if Obj.Symtab_Last = 0 then\n+            return Null_Symbol;\n+         end if;\n+\n+         return Read_Symbol (Obj, 0);\n+      end First_Symbol;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      function Initialize\n+        (F            : Mapped_File;\n+         Hdr          : Header;\n+         In_Exception : Boolean) return XCOFF32_Object_File\n+      is\n+         Res : XCOFF32_Object_File (Format => XCOFF32);\n+         Strtab_Sz : uint32;\n+      begin\n+         Res.Mf := F;\n+         Res.In_Exception := In_Exception;\n+\n+         Res.Arch := PPC;\n+\n+         --  Map sections table\n+         Res.Num_Sections := uint32 (Hdr.f_nscns);\n+         Res.Sectab_Stream := Create_Stream\n+           (F,\n+            File_Size (Header'Size / SSU) + File_Size (Hdr.f_opthdr),\n+            File_Size (Hdr.f_nscns) * (Section_Header'Size / SSU));\n+\n+         --  Map symbols table\n+         Res.Symtab_Last := Offset (Hdr.f_nscns) * (Symbol_Entry'Size / SSU);\n+         Res.Symtab_Stream := Create_Stream\n+           (F,\n+            File_Size (Hdr.f_symptr),\n+            File_Size (Res.Symtab_Last) + 4);\n+\n+         --  Map string table\n+         Seek (Res.Symtab_Stream, Res.Symtab_Last);\n+         Strtab_Sz := Read (Res.Symtab_Stream);\n+         Res.Symstr_Stream := Create_Stream\n+           (F,\n+            File_Size (Res.Symtab_Last) + 4,\n+            File_Size (Strtab_Sz) - 4);\n+\n+         return Res;\n+      end Initialize;\n+\n+      -----------------\n+      -- Get_Section --\n+      -----------------\n+\n+      function Get_Section\n+        (Obj   : in out XCOFF32_Object_File;\n+         Index : uint32) return Object_Section\n+      is\n+         Sec : constant Section_Header := Read_Section_Header (Obj, Index);\n+      begin\n+         return (Index, Offset (Sec.s_scnptr),\n+                 uint64 (Sec.s_vaddr),\n+                 uint64 (Sec.s_size),\n+                 (Sec.s_flags and STYP_TEXT) /= 0);\n+      end Get_Section;\n+\n+      -----------------\n+      -- Read_Header --\n+      -----------------\n+\n+      function Read_Header (F : in out Mapped_Stream) return Header is\n+         Hdr : Header;\n+      begin\n+         Seek (F, 0);\n+         Read_Raw (F, Hdr'Address, uint32 (Hdr'Size / SSU));\n+         return Hdr;\n+      end Read_Header;\n+\n+      -------------------------\n+      -- Read_Section_Header --\n+      -------------------------\n+\n+      function Read_Section_Header\n+        (Obj   : in out XCOFF32_Object_File;\n+         Index : uint32) return Section_Header\n+      is\n+         Sec     : Section_Header;\n+\n+      begin\n+         --  Seek to the end of the object header\n+\n+         Seek (Obj.Sectab_Stream, Offset (Index * Section_Header'Size / SSU));\n+\n+         --  Read the section\n+\n+         Read_Raw (Obj.Sectab_Stream, Sec'Address, Section_Header'Size / SSU);\n+\n+         return Sec;\n+      end Read_Section_Header;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (Obj : in out XCOFF32_Object_File;\n+         Sec : Object_Section) return String\n+      is\n+         Hdr : Section_Header;\n+      begin\n+         Hdr := Read_Section_Header (Obj, Sec.Num);\n+         return Trim_Trailing_Nuls (Hdr.s_name);\n+      end Name;\n+\n+      ----------\n+      -- Name --\n+      ----------\n+\n+      function Name\n+        (Obj : in out XCOFF32_Object_File;\n+         Sym : Object_Symbol) return String_Ptr_Len\n+      is\n+         Symbol  : Symbol_Entry;\n+\n+      begin\n+         Seek (Obj.Symtab_Stream, Sym.Off);\n+         Read_Raw (Obj.Symtab_Stream, Symbol'Address, Symbol'Size / SSU);\n+\n+         declare\n+            First_Word : uint32;\n+            pragma Import (Ada, First_Word);\n+            --  Suppress initialization in Normalized_Scalars mode\n+            for First_Word'Address use Symbol.n_name (1)'Address;\n+\n+            Second_Word : uint32;\n+            pragma Import (Ada, Second_Word);\n+            --  Suppress initialization in Normalized_Scalars mode\n+            for Second_Word'Address use Symbol.n_name (5)'Address;\n+\n+         begin\n+            if First_Word = 0 then\n+               if Second_Word = 0 then\n+                  return (null, 0);\n+               else\n+                  Seek (Obj.Symstr_Stream, int64 (Second_Word));\n+                  return Read (Obj.Symstr_Stream);\n+               end if;\n+            else\n+               Seek (Obj.Symtab_Stream, Sym.Off);\n+               return To_String_Ptr_Len (Read (Obj.Symstr_Stream), 8);\n+            end if;\n+         end;\n+      end Name;\n+   end XCOFF32_Ops;\n+\n+   ----------\n+   -- Arch --\n+   ----------\n+\n+   function Arch (Obj : Object_File) return Object_Arch is\n+   begin\n+      return Obj.Arch;\n+   end Arch;\n+\n+   function Create_Stream\n+     (Mf : Mapped_File;\n+      File_Offset : File_Size;\n+      File_Length : File_Size)\n+     return Mapped_Stream\n+   is\n+      Region : Mapped_Region;\n+   begin\n+      Read (Mf, Region, File_Offset, File_Length, False);\n+      return (Region, 0, Offset (File_Length));\n+   end Create_Stream;\n+\n+   function Create_Stream\n+     (Obj : Object_File;\n+      Sec : Object_Section) return Mapped_Stream is\n+   begin\n+      return Create_Stream (Obj.Mf, File_Size (Sec.Off), File_Size (Sec.Size));\n+   end Create_Stream;\n+\n+   procedure Tell (Obj : in out Mapped_Stream; Off : out Offset) is\n+   begin\n+      Off := Obj.Off;\n+   end Tell;\n+\n+   function Tell (Obj : Mapped_Stream) return Offset is\n+   begin\n+      return Obj.Off;\n+   end Tell;\n+\n+   function Length (Obj : Mapped_Stream) return Offset is\n+   begin\n+      return Obj.Len;\n+   end Length;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (S : in out Mapped_Stream) is\n+   begin\n+      Free (S.Region);\n+   end Close;\n+\n+   procedure Close (Obj : in out Object_File) is\n+   begin\n+      Close (Obj.Symtab_Stream);\n+      Close (Obj.Symstr_Stream);\n+      Close (Obj.Sectab_Stream);\n+\n+      case Obj.Format is\n+         when ELF =>\n+            Close (Obj.Secstr_Stream);\n+         when Any_PECOFF =>\n+            null;\n+         when XCOFF32 =>\n+            null;\n+      end case;\n+\n+      Close (Obj.Mf);\n+   end Close;\n+\n+   ------------------------\n+   -- Strip_Leading_Char --\n+   ------------------------\n+\n+   function Strip_Leading_Char\n+     (Obj : in out Object_File;\n+      Sym : String_Ptr_Len) return Positive is\n+   begin\n+      if (Obj.Format = PECOFF  and then Sym.Ptr (1) = '_')\n+        or else\n+        (Obj.Format = XCOFF32 and then Sym.Ptr (1) = '.')\n+      then\n+         return 2;\n+      else\n+         return 1;\n+      end if;\n+   end Strip_Leading_Char;\n+\n+   ----------------------\n+   -- Decoded_Ada_Name --\n+   ----------------------\n+\n+   function Decoded_Ada_Name\n+     (Obj : in out Object_File;\n+      Sym : String_Ptr_Len) return String\n+   is\n+      procedure gnat_decode\n+        (Coded_Name_Addr : Address;\n+         Ada_Name_Addr   : Address;\n+         Verbose         : int);\n+      pragma Import (C, gnat_decode, \"__gnat_decode\");\n+\n+      subtype size_t is Interfaces.C.size_t;\n+\n+      Sym_Name : constant String :=\n+        String (Sym.Ptr (1 .. Sym.Len)) & ASCII.NUL;\n+      Decoded : char_array (0 .. size_t (Sym.Len) * 2 + 60);\n+      Off     : Natural;\n+   begin\n+      --  In the PECOFF case most but not all symbol table entries have an\n+      --  extra leading underscore. In this case we trim it.\n+\n+      Off := Strip_Leading_Char (Obj, Sym);\n+\n+      gnat_decode (Sym_Name (Off)'Address, Decoded'Address, 0);\n+\n+      return To_Ada (Decoded);\n+   end Decoded_Ada_Name;\n+\n+   ------------------\n+   -- First_Symbol --\n+   ------------------\n+\n+   function First_Symbol (Obj : in out Object_File) return Object_Symbol is\n+   begin\n+      case Obj.Format is\n+         when ELF32      => return ELF32_Ops.First_Symbol   (Obj);\n+         when ELF64      => return ELF64_Ops.First_Symbol   (Obj);\n+         when Any_PECOFF => return PECOFF_Ops.First_Symbol  (Obj);\n+         when XCOFF32    => return XCOFF32_Ops.First_Symbol (Obj);\n+      end case;\n+   end First_Symbol;\n+\n+   ------------\n+   -- Format --\n+   ------------\n+\n+   function Format (Obj : Object_File) return Object_Format is\n+   begin\n+      return Obj.Format;\n+   end Format;\n+\n+   ----------------------\n+   -- Get_Load_Address --\n+   ----------------------\n+\n+   function Get_Load_Address (Obj : Object_File) return uint64 is\n+   begin\n+      raise Format_Error with \"Get_Load_Address not implemented\";\n+      return 0;\n+   end Get_Load_Address;\n+\n+   -----------------\n+   -- Get_Section --\n+   -----------------\n+\n+   function Get_Section\n+     (Obj   : in out Object_File;\n+      Shnum : uint32) return Object_Section is\n+   begin\n+      case Obj.Format is\n+         when ELF32      => return ELF32_Ops.Get_Section   (Obj, Shnum);\n+         when ELF64      => return ELF64_Ops.Get_Section   (Obj, Shnum);\n+         when Any_PECOFF => return PECOFF_Ops.Get_Section  (Obj, Shnum);\n+         when XCOFF32    => return XCOFF32_Ops.Get_Section (Obj, Shnum);\n+      end case;\n+   end Get_Section;\n+\n+   function Get_Section\n+     (Obj      : in out Object_File;\n+      Sec_Name : String) return Object_Section\n+   is\n+      Sec : Object_Section;\n+\n+   begin\n+      for J in 0 .. Obj.Num_Sections - 1 loop\n+         Sec := Get_Section (Obj, J);\n+\n+         if Name (Obj, Sec) = Sec_Name then\n+            return Sec;\n+         end if;\n+      end loop;\n+\n+      if Obj.In_Exception then\n+         return Null_Section;\n+      else\n+         raise Format_Error with \"could not find section in object file\";\n+      end if;\n+   end Get_Section;\n+\n+   -----------------------\n+   -- Get_Memory_Bounds --\n+   -----------------------\n+\n+   procedure Get_Memory_Bounds\n+     (Obj   : in out Object_File;\n+      Low, High : out uint64) is\n+      Sec : Object_Section;\n+   begin\n+      --  First set as an empty range\n+      Low := uint64'Last;\n+      High := uint64'First;\n+\n+      for Idx in 1 .. Num_Sections (Obj) loop\n+         Sec := Get_Section (Obj, Idx - 1);\n+         if Sec.Flag_Alloc then\n+            if Sec.Addr < Low then\n+               Low := Sec.Addr;\n+            end if;\n+            if Sec.Addr + Sec.Size > High then\n+               High := Sec.Addr + Sec.Size;\n+            end if;\n+         end if;\n+      end loop;\n+   end Get_Memory_Bounds;\n+\n+   ----------\n+   -- Name --\n+   ----------\n+\n+   function Name\n+     (Obj : in out Object_File;\n+      Sec : Object_Section) return String is\n+   begin\n+      case Obj.Format is\n+         when ELF32      => return ELF32_Ops.Name   (Obj, Sec);\n+         when ELF64      => return ELF64_Ops.Name   (Obj, Sec);\n+         when Any_PECOFF => return PECOFF_Ops.Name  (Obj, Sec);\n+         when XCOFF32    => return XCOFF32_Ops.Name (Obj, Sec);\n+      end case;\n+   end Name;\n+\n+   function Name\n+     (Obj : in out Object_File;\n+      Sym : Object_Symbol) return String_Ptr_Len is\n+   begin\n+      case Obj.Format is\n+         when ELF32      => return ELF32_Ops.Name   (Obj, Sym);\n+         when ELF64      => return ELF64_Ops.Name   (Obj, Sym);\n+         when Any_PECOFF => return PECOFF_Ops.Name  (Obj, Sym);\n+         when XCOFF32    => return XCOFF32_Ops.Name (Obj, Sym);\n+      end case;\n+   end Name;\n+\n+   -----------------\n+   -- Next_Symbol --\n+   -----------------\n+\n+   function Next_Symbol\n+     (Obj  : in out Object_File;\n+      Prev : Object_Symbol) return Object_Symbol is\n+   begin\n+      --  Test whether we've reached the end of the symbol table\n+\n+      if Prev.Next >= Obj.Symtab_Last then\n+         return Null_Symbol;\n+      end if;\n+\n+      return Read_Symbol (Obj, Prev.Next);\n+   end Next_Symbol;\n+\n+   ---------\n+   -- Num --\n+   ---------\n+\n+   function Num (Sec : Object_Section) return uint32 is\n+   begin\n+      return Sec.Num;\n+   end Num;\n+\n+   ------------------\n+   -- Num_Sections --\n+   ------------------\n+\n+   function Num_Sections (Obj : Object_File) return uint32 is\n+   begin\n+      return Obj.Num_Sections;\n+   end Num_Sections;\n+\n+   ---------\n+   -- Off --\n+   ---------\n+\n+   function Off (Sec : Object_Section) return Offset is\n+   begin\n+      return Sec.Off;\n+   end Off;\n+\n+   function Off (Sym : Object_Symbol) return Offset is\n+   begin\n+      return Sym.Off;\n+   end Off;\n+\n+   ----------------------\n+   -- Offset_To_String --\n+   ----------------------\n+\n+   function Offset_To_String\n+     (S : in out Mapped_Stream;\n+      Off : Offset) return String\n+   is\n+      Buf     : Buffer;\n+   begin\n+      Seek (S, Off);\n+      Read_C_String (S, Buf);\n+      return To_String (Buf);\n+   end Offset_To_String;\n+\n+   ----------\n+   -- Open --\n+   ----------\n+\n+   function Open\n+     (File_Name    : String;\n+      In_Exception : Boolean := False) return Object_File_Access\n+   is\n+      F          : Mapped_File;\n+      Hdr_Stream : Mapped_Stream;\n+\n+   begin\n+      --  Open the file\n+\n+      F := Open_Read_No_Exception (File_Name);\n+\n+      if F = Invalid_Mapped_File then\n+         if In_Exception then\n+            return null;\n+         else\n+            raise IO_Error with \"could not open object file\";\n+         end if;\n+      end if;\n+\n+      Hdr_Stream := Create_Stream (F, 0, 4096);\n+\n+      declare\n+         Hdr : constant ELF32_Ops.Header := ELF32_Ops.Read_Header (Hdr_Stream);\n+\n+      begin\n+         --  Look for the magic numbers for the ELF case\n+\n+         if Hdr.E_Ident (0) = 16#7F#              and then\n+            Hdr.E_Ident (1) = Character'Pos ('E') and then\n+            Hdr.E_Ident (2) = Character'Pos ('L') and then\n+            Hdr.E_Ident (3) = Character'Pos ('F') and then\n+            Hdr.E_Ident (4) = ELF32_Ops.ELFCLASS32\n+         then\n+            Close (Hdr_Stream);\n+            return new Object_File'\n+                  (ELF32_Ops.Initialize (F, Hdr, In_Exception));\n+         end if;\n+      end;\n+\n+      declare\n+         Hdr : constant ELF64_Ops.Header :=\n+           ELF64_Ops.Read_Header (Hdr_Stream);\n+\n+      begin\n+         --  Look for the magic numbers for the ELF case\n+\n+         if Hdr.E_Ident (0) = 16#7F#              and then\n+            Hdr.E_Ident (1) = Character'Pos ('E') and then\n+            Hdr.E_Ident (2) = Character'Pos ('L') and then\n+            Hdr.E_Ident (3) = Character'Pos ('F') and then\n+            Hdr.E_Ident (4) = ELF32_Ops.ELFCLASS64\n+         then\n+            Close (Hdr_Stream);\n+            return new Object_File'\n+                         (ELF64_Ops.Initialize (F, Hdr, In_Exception));\n+         end if;\n+      end;\n+\n+      declare\n+         Hdr : constant PECOFF_Ops.Header :=\n+           PECOFF_Ops.Read_Header (Hdr_Stream);\n+\n+      begin\n+         --  Test the magic numbers\n+\n+         if Hdr.Magics (0) = Character'Pos ('P') and then\n+            Hdr.Magics (1) = Character'Pos ('E') and then\n+            Hdr.Magics (2) = 0                   and then\n+            Hdr.Magics (3) = 0\n+         then\n+            Close (Hdr_Stream);\n+            return new Object_File'\n+                         (PECOFF_Ops.Initialize (F, Hdr, In_Exception));\n+         end if;\n+\n+      exception\n+         --  If this is not a PECOFF file then we've done a seek and read to a\n+         --  random address, possibly raising IO_Error\n+\n+         when IO_Error =>\n+            null;\n+      end;\n+\n+      declare\n+         Hdr : constant XCOFF32_Ops.Header :=\n+           XCOFF32_Ops.Read_Header (Hdr_Stream);\n+\n+      begin\n+         --  Test the magic numbers\n+\n+         if Hdr.f_magic = 8#0737# then\n+            Close (Hdr_Stream);\n+            return new Object_File'\n+                         (XCOFF32_Ops.Initialize (F, Hdr, In_Exception));\n+         end if;\n+      end;\n+\n+      Close (Hdr_Stream);\n+\n+      if In_Exception then\n+         return null;\n+      else\n+         raise Format_Error with \"unrecognized object format\";\n+      end if;\n+   end Open;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   function Read (S : in out Mapped_Stream) return Mmap.Str_Access\n+   is\n+      function To_Str_Access is\n+         new Ada.Unchecked_Conversion (Address, Str_Access);\n+   begin\n+      return To_Str_Access (Data (S.Region) (Natural (S.Off + 1))'Address);\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return String_Ptr_Len is\n+   begin\n+      return To_String_Ptr_Len (Read (S));\n+   end Read;\n+\n+   procedure Check_Read_Offset (S : in out Mapped_Stream; Size : uint32) is\n+   begin\n+      if S.Off + Offset (Size) > Offset (Last (S.Region)) then\n+         raise IO_Error with \"could not read from object file\";\n+      end if;\n+   end Check_Read_Offset;\n+\n+   procedure Read_Raw\n+     (S    : in out Mapped_Stream;\n+      Addr : Address;\n+      Size : uint32)\n+   is\n+      function To_Str_Access is\n+         new Ada.Unchecked_Conversion (Address, Str_Access);\n+\n+      Sz : constant Offset := Offset (Size);\n+   begin\n+      --  Check size\n+\n+      pragma Debug (Check_Read_Offset (S, Size));\n+\n+      --  Copy data\n+\n+      To_Str_Access (Addr) (1 .. Positive (Sz)) :=\n+        Data (S.Region) (Positive (S.Off + 1) .. Positive (S.Off + Sz));\n+\n+      --  Update offset\n+\n+      S.Off := S.Off + Sz;\n+   end Read_Raw;\n+\n+   function Read (S : in out Mapped_Stream) return uint8 is\n+      Data : uint8;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return uint16 is\n+      Data : uint16;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return uint32 is\n+      Data : uint32;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return uint64 is\n+      Data : uint64;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return int8 is\n+      Data : int8;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return int16 is\n+      Data : int16;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return int32 is\n+      Data : int32;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   function Read (S : in out Mapped_Stream) return int64 is\n+      Data : int64;\n+   begin\n+      Read_Raw (S, Data'Address, Data'Size / SSU);\n+      return Data;\n+   end Read;\n+\n+   ------------------\n+   -- Read_Address --\n+   ------------------\n+\n+   function Read_Address\n+     (Obj : Object_File; S : in out Mapped_Stream) return uint64 is\n+      Address_32 : uint32;\n+      Address_64 : uint64;\n+\n+   begin\n+      case Obj.Arch is\n+         when i386\n+            | MIPS\n+            | PPC\n+            | SPARC\n+         =>\n+            Address_32 := Read (S);\n+            return uint64 (Address_32);\n+\n+         when IA64\n+            | PPC64\n+            | SPARC64\n+            | x86_64\n+         =>\n+            Address_64 := Read (S);\n+            return Address_64;\n+\n+         when Unknown =>\n+            raise Format_Error with \"unrecognized machine architecture\";\n+      end case;\n+   end Read_Address;\n+\n+   -------------------\n+   -- Read_C_String --\n+   -------------------\n+\n+   procedure Read_C_String (S : in out Mapped_Stream; B : out Buffer) is\n+      J : Integer := 0;\n+\n+   begin\n+      loop\n+         --  Handle overflow case\n+\n+         if J = B'Last then\n+            B (J) := 0;\n+            exit;\n+         end if;\n+\n+         B (J) := Read (S);\n+         exit when B (J) = 0;\n+         J := J + 1;\n+      end loop;\n+   end Read_C_String;\n+\n+   -------------------\n+   -- Read_C_String --\n+   -------------------\n+\n+   function Read_C_String (S : in out Mapped_Stream) return Str_Access is\n+      Res : constant Str_Access := Read (S);\n+\n+   begin\n+      for J in Res'Range loop\n+         if S.Off + Offset (J - 1) > Offset (Last (S.Region)) then\n+            raise IO_Error with \"could not read from object file\";\n+         end if;\n+\n+         if Res (J) = ASCII.NUL then\n+            S.Off := S.Off + Offset (J);\n+            return Res;\n+         end if;\n+      end loop;\n+\n+      --  Overflow case\n+      raise Constraint_Error;\n+   end Read_C_String;\n+\n+   -----------------\n+   -- Read_LEB128 --\n+   -----------------\n+\n+   function Read_LEB128 (S : in out Mapped_Stream) return uint32 is\n+      B     : uint8;\n+      Shift : Integer := 0;\n+      Res   : uint32 := 0;\n+\n+   begin\n+      loop\n+         B := Read (S);\n+         Res := Res or Shift_Left (uint32 (B and 16#7f#), Shift);\n+         exit when (B and 16#80#) = 0;\n+         Shift := Shift + 7;\n+      end loop;\n+\n+      return Res;\n+   end Read_LEB128;\n+\n+   function Read_LEB128 (S : in out Mapped_Stream) return int32 is\n+      B     : uint8;\n+      Shift : Integer := 0;\n+      Res   : uint32 := 0;\n+\n+   begin\n+      loop\n+         B := Read (S);\n+         Res := Res or Shift_Left (uint32 (B and 16#7f#), Shift);\n+         Shift := Shift + 7;\n+         exit when (B and 16#80#) = 0;\n+      end loop;\n+\n+      if Shift < 32 and then (Res and Shift_Left (1, Shift - 1)) /= 0 then\n+         Res := Res or Shift_Left (-1, Shift);\n+      end if;\n+\n+      return To_int32 (Res);\n+   end Read_LEB128;\n+\n+   -----------------\n+   -- Read_Symbol --\n+   -----------------\n+\n+   function Read_Symbol\n+     (Obj : in out Object_File;\n+      Off : Offset) return Object_Symbol is\n+   begin\n+      case Obj.Format is\n+         when ELF32      => return ELF32_Ops.Read_Symbol   (Obj, Off);\n+         when ELF64      => return ELF64_Ops.Read_Symbol   (Obj, Off);\n+         when Any_PECOFF => return PECOFF_Ops.Read_Symbol  (Obj, Off);\n+         when XCOFF32    => return XCOFF32_Ops.Read_Symbol (Obj, Off);\n+      end case;\n+   end Read_Symbol;\n+\n+   ----------\n+   -- Seek --\n+   ----------\n+\n+   procedure Seek (S : in out Mapped_Stream; Off : Offset) is\n+   begin\n+      if Off < 0 or else Off > Offset (Last (S.Region)) then\n+         raise IO_Error with \"could not seek to offset in object file\";\n+      end if;\n+\n+      S.Off := Off;\n+   end Seek;\n+\n+   ----------\n+   -- Size --\n+   ----------\n+\n+   function Size (Sec : Object_Section) return uint64 is\n+   begin\n+      return Sec.Size;\n+   end Size;\n+\n+   function Size (Sym : Object_Symbol) return uint64 is\n+   begin\n+      return Sym.Size;\n+   end Size;\n+\n+   ------------\n+   -- Strlen --\n+   ------------\n+\n+   function Strlen (Buf : Buffer) return int32 is\n+   begin\n+      return int32 (CRTL.strlen (Buf'Address));\n+   end Strlen;\n+\n+   -----------\n+   -- Spans --\n+   -----------\n+\n+   function Spans (Sym : Object_Symbol; Addr : uint64) return Boolean is\n+   begin\n+      return Addr >= Sym.Value and then Addr < Sym.Value + Sym.Size;\n+   end Spans;\n+\n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String (Buf : Buffer) return String is\n+      Result : String (1 .. Integer (CRTL.strlen (Buf'Address)));\n+      for Result'Address use Buf'Address;\n+      pragma Import (Ada, Result);\n+\n+   begin\n+      return Result;\n+   end To_String;\n+\n+   -----------------------\n+   -- To_String_Ptr_Len --\n+   -----------------------\n+\n+   function To_String_Ptr_Len\n+     (Ptr : Mmap.Str_Access;\n+      Max_Len : Natural := Natural'Last) return String_Ptr_Len is\n+   begin\n+      for I in 1 .. Max_Len loop\n+         if Ptr (I) = ASCII.NUL then\n+            return (Ptr, I - 1);\n+         end if;\n+      end loop;\n+      return (Ptr, Max_Len);\n+   end To_String_Ptr_Len;\n+\n+   ------------------------\n+   -- Trim_Trailing_Nuls --\n+   ------------------------\n+\n+   function Trim_Trailing_Nuls (Str : String) return String is\n+   begin\n+      for J in Str'Range loop\n+         if Str (J) = ASCII.NUL then\n+            return Str (Str'First .. J - 1);\n+         end if;\n+      end loop;\n+\n+      return Str;\n+   end Trim_Trailing_Nuls;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Sym : Object_Symbol) return uint64 is\n+   begin\n+      return Sym.Value;\n+   end Value;\n+\n+end System.Object_Reader;"}, {"sha": "1d485369b7967bd1c8bf6241b18b26167201840f", "filename": "gcc/ada/s-objrea.ads", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-objrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-objrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-objrea.ads?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,451 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . O B J E C T _ R E A D E R                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2009-2017, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements a simple, minimal overhead reader for object files\n+--  composed of sections of untyped heterogeneous binary data.\n+\n+with Interfaces;\n+with System.Mmap;\n+\n+package System.Object_Reader is\n+\n+   --------------\n+   --  Limits  --\n+   --------------\n+\n+   BUFFER_SIZE : constant := 8 * 1024;\n+\n+   ------------------\n+   -- Object files --\n+   ------------------\n+\n+   type Object_File (<>) is private;\n+\n+   type Object_File_Access is access Object_File;\n+\n+   ---------------------\n+   -- Object sections --\n+   ----------------------\n+\n+   type Object_Section is private;\n+\n+   Null_Section : constant Object_Section;\n+\n+   --------------------\n+   -- Object symbols --\n+   --------------------\n+\n+   type Object_Symbol is private;\n+\n+   ------------------------\n+   -- Object format type --\n+   ------------------------\n+\n+   type Object_Format is\n+     (ELF32,\n+      --  Object format is 32-bit ELF\n+\n+      ELF64,\n+      --  Object format is 64-bit ELF\n+\n+      PECOFF,\n+      --  Object format is Microsoft PECOFF\n+\n+      PECOFF_PLUS,\n+      --  Object format is Microsoft PECOFF+\n+\n+      XCOFF32);\n+      --  Object format is AIX 32-bit XCOFF\n+\n+   --  PECOFF | PECOFF_PLUS appears so often as a case choice, would\n+   --  seem a good idea to have a subtype name covering these two choices ???\n+\n+   ------------------------------\n+   -- Object architecture type --\n+   ------------------------------\n+\n+   type Object_Arch is\n+     (Unknown,\n+      --  The target architecture has not yet been determined\n+\n+      SPARC,\n+      --  32-bit SPARC\n+\n+      SPARC64,\n+      --  64-bit SPARC\n+\n+      i386,\n+      --  Intel IA32\n+\n+      MIPS,\n+      --  MIPS Technologies MIPS\n+\n+      x86_64,\n+      --  x86-64 (64-bit AMD/Intel)\n+\n+      IA64,\n+      --  Intel IA64\n+\n+      PPC,\n+      --  32-bit PowerPC\n+\n+      PPC64);\n+      --  64-bit PowerPC\n+\n+   ------------------\n+   -- Target types --\n+   ------------------\n+\n+   subtype Offset is Interfaces.Integer_64;\n+\n+   subtype uint8  is Interfaces.Unsigned_8;\n+   subtype uint16 is Interfaces.Unsigned_16;\n+   subtype uint32 is Interfaces.Unsigned_32;\n+   subtype uint64 is Interfaces.Unsigned_64;\n+\n+   subtype int8  is Interfaces.Integer_8;\n+   subtype int16 is Interfaces.Integer_16;\n+   subtype int32 is Interfaces.Integer_32;\n+   subtype int64 is Interfaces.Integer_64;\n+\n+   type Buffer is array (0 .. BUFFER_SIZE - 1) of uint8;\n+\n+   type String_Ptr_Len is record\n+      Ptr : Mmap.Str_Access;\n+      Len : Natural;\n+   end record;\n+   --  A string made from a pointer and a length. Not all strings for name\n+   --  are C strings: COFF inlined symbol names have a max length of 8.\n+\n+   -------------------------------------------\n+   -- Operations on buffers of untyped data --\n+   -------------------------------------------\n+\n+   function To_String (Buf : Buffer) return String;\n+   --  Construct string from C style null-terminated string stored in a buffer\n+\n+   function To_String_Ptr_Len\n+     (Ptr : Mmap.Str_Access;\n+      Max_Len : Natural := Natural'Last) return String_Ptr_Len;\n+   --  Convert PTR to a String_Ptr_Len.\n+\n+   function Strlen (Buf : Buffer) return int32;\n+   --  Return the length of a C style null-terminated string\n+\n+   -------------------------\n+   -- Opening and closing --\n+   -------------------------\n+\n+   function Open\n+     (File_Name    : String;\n+      In_Exception : Boolean := False) return Object_File_Access;\n+   --  Open the object file and initialize the reader. In_Exception is true\n+   --  when the parsing is done as part of an exception handler decorator. In\n+   --  this mode we do not want to raise an exception.\n+\n+   procedure Close (Obj : in out Object_File);\n+   --  Close the object file\n+\n+   -----------------------\n+   -- Sequential access --\n+   -----------------------\n+\n+   type Mapped_Stream is private;\n+   --  Provide an abstraction of a stream on a memory mapped file\n+\n+   function Create_Stream (Mf : System.Mmap.Mapped_File;\n+                           File_Offset : System.Mmap.File_Size;\n+                           File_Length : System.Mmap.File_Size)\n+                          return Mapped_Stream;\n+   --  Create a stream from Mf\n+\n+   procedure Close (S : in out Mapped_Stream);\n+   --  Close the stream (deallocate memory)\n+\n+   procedure Read_Raw\n+     (S   : in out Mapped_Stream;\n+      Addr  : Address;\n+      Size  : uint32);\n+   pragma Inline (Read_Raw);\n+   --  Read a number of fixed sized records\n+\n+   procedure Seek (S : in out Mapped_Stream; Off : Offset);\n+   --  Seek to an absolute offset in bytes\n+\n+   procedure Tell (Obj : in out Mapped_Stream; Off : out Offset)\n+     with Inline;\n+   function Tell (Obj : Mapped_Stream) return Offset\n+     with Inline;\n+   --  Fetch the current offset\n+\n+   function Length (Obj : Mapped_Stream) return Offset\n+     with Inline;\n+   --  Length of the stream\n+\n+   function Read (S : in out Mapped_Stream) return Mmap.Str_Access;\n+   --  Provide a pointer in memory at the current offset\n+\n+   function Read (S : in out Mapped_Stream) return String_Ptr_Len;\n+   --  Provide a pointer in memory at the current offset\n+\n+   function Read (S : in out Mapped_Stream) return uint8;\n+   function Read (S : in out Mapped_Stream) return uint16;\n+   function Read (S : in out Mapped_Stream) return uint32;\n+   function Read (S : in out Mapped_Stream) return uint64;\n+   function Read (S : in out Mapped_Stream) return int8;\n+   function Read (S : in out Mapped_Stream) return int16;\n+   function Read (S : in out Mapped_Stream) return int32;\n+   function Read (S : in out Mapped_Stream) return int64;\n+   --  Read a scalar\n+\n+   function Read_Address\n+     (Obj : Object_File; S : in out Mapped_Stream) return uint64;\n+   --  Read either a 64 or 32 bit address from the file stream depending on the\n+   --  address size of the target architecture and promote it to a 64 bit type.\n+\n+   function Read_LEB128 (S : in out Mapped_Stream) return uint32;\n+   function Read_LEB128 (S : in out Mapped_Stream) return int32;\n+   --  Read a value encoding in Little-Endian Base 128 format\n+\n+   procedure Read_C_String (S : in out Mapped_Stream; B : out Buffer);\n+   function Read_C_String (S : in out Mapped_Stream) return Mmap.Str_Access;\n+   --  Read a C style NULL terminated string\n+\n+   function Offset_To_String\n+     (S : in out Mapped_Stream;\n+      Off : Offset) return String;\n+   --  Construct a string from a C style NULL terminated string located at an\n+   --  offset into the object file.\n+\n+   ------------------------\n+   -- Object information --\n+   ------------------------\n+\n+   function Arch (Obj : Object_File) return Object_Arch;\n+   --  Return the object architecture\n+\n+   function Format (Obj : Object_File) return Object_Format;\n+   --  Return the object file format\n+\n+   function Get_Load_Address (Obj : Object_File) return uint64;\n+   --  Return the load address defined in Obj. May raise Format_Error if not\n+   --  implemented\n+\n+   function Num_Sections (Obj : Object_File) return uint32;\n+   --  Return the number of sections composing the object file\n+\n+   function Get_Section\n+     (Obj   : in out Object_File;\n+      Shnum : uint32) return Object_Section;\n+   --  Return the Nth section (numbered from zero)\n+\n+   function Get_Section\n+     (Obj      : in out Object_File;\n+      Sec_Name : String) return Object_Section;\n+   --  Return a section by name\n+\n+   function Create_Stream\n+     (Obj : Object_File;\n+      Sec : Object_Section) return Mapped_Stream;\n+   --  Create a stream for section Sec\n+\n+   procedure Get_Memory_Bounds\n+     (Obj   : in out Object_File;\n+      Low, High : out uint64);\n+   --  Return the low and high addresses of the code for the object file. Can\n+   --  be used to check if an address in within this object file. This\n+   --  procedure is not efficient and the result should be saved to avoid\n+   --  recomputation.\n+\n+   -------------------------\n+   -- Section information --\n+   -------------------------\n+\n+   function Name\n+     (Obj : in out Object_File;\n+      Sec : Object_Section) return String;\n+   --  Return the name of a section as a string\n+\n+   function Size (Sec : Object_Section) return uint64;\n+   --  Return the size of a section in bytes\n+\n+   function Num (Sec : Object_Section) return uint32;\n+   --  Return the index of a section from zero\n+\n+   function Off (Sec : Object_Section) return Offset;\n+   --  Return the byte offset of the section within the object\n+\n+   ------------------------------\n+   -- Symbol table information --\n+   ------------------------------\n+\n+   Null_Symbol : constant Object_Symbol;\n+   --  An empty symbol table entry.\n+\n+   function First_Symbol (Obj : in out Object_File) return Object_Symbol;\n+   --  Return the first element in the symbol table or Null_Symbol if the\n+   --  symbol table is empty.\n+\n+   function Next_Symbol\n+     (Obj  : in out Object_File;\n+      Prev : Object_Symbol) return Object_Symbol;\n+   --  Return the element following Prev in the symbol table, or Null_Symbol if\n+   --  Prev is the last symbol in the table.\n+\n+   function Read_Symbol\n+     (Obj : in out Object_File;\n+      Off : Offset) return Object_Symbol;\n+   --  Read symbol at Off\n+\n+   function Name\n+     (Obj : in out Object_File;\n+      Sym : Object_Symbol) return String_Ptr_Len;\n+   --  Return the name of the symbol\n+\n+   function Decoded_Ada_Name\n+     (Obj : in out Object_File;\n+      Sym : String_Ptr_Len) return String;\n+   --  Return the decoded name of a symbol encoded as per exp_dbug.ads\n+\n+   function Strip_Leading_Char\n+     (Obj : in out Object_File;\n+      Sym : String_Ptr_Len) return Positive;\n+   --  Return the index of the first character to decode the name. This can\n+   --  strip one character for ABI with a prefix (like x86 for PECOFF).\n+\n+   function Value (Sym : Object_Symbol) return uint64;\n+   --  Return the name of the symbol\n+\n+   function Size (Sym : Object_Symbol) return uint64;\n+   --  Return the size of the symbol in bytes\n+\n+   function Spans (Sym : Object_Symbol; Addr : uint64) return Boolean;\n+   --  Determine whether a particular address corresponds to the range\n+   --  referenced by this symbol.\n+\n+   function Off (Sym : Object_Symbol) return Offset;\n+   --  Return the offset of the symbol.\n+\n+   ----------------\n+   -- Exceptions --\n+   ----------------\n+\n+   IO_Error : exception;\n+   --  Input/Output error reading file\n+\n+   Format_Error : exception;\n+   --  Encountered a problem parsing the object\n+\n+private\n+   type Mapped_Stream is record\n+      Region : System.Mmap.Mapped_Region;\n+      Off    : Offset;\n+      Len    : Offset;\n+   end record;\n+\n+   subtype ELF is Object_Format range ELF32 .. ELF64;\n+   subtype Any_PECOFF is Object_Format range PECOFF .. PECOFF_PLUS;\n+\n+   type Object_File (Format : Object_Format) is record\n+      Mf           : System.Mmap.Mapped_File :=\n+                        System.Mmap.Invalid_Mapped_File;\n+      Arch         : Object_Arch := Unknown;\n+\n+      Num_Sections : uint32 := 0;\n+      --  Number of sections\n+\n+      Symtab_Last : Offset;       --  Last offset of symbol table\n+\n+      In_Exception : Boolean := False;\n+      --  True if the parsing is done as part of an exception handler\n+\n+      Sectab_Stream : Mapped_Stream;\n+      --  Section table\n+\n+      Symtab_Stream : Mapped_Stream;\n+      --  Symbol table\n+\n+      Symstr_Stream : Mapped_Stream;\n+      --  Symbol strings\n+\n+      case Format is\n+         when ELF =>\n+            Secstr_Stream : Mapped_Stream;\n+            --  Section strings\n+         when Any_PECOFF =>\n+            ImageBase   : uint64;       --  ImageBase value from header\n+\n+            --  Cache for latest result of Get_Section_Virtual_Address\n+\n+            GSVA_Sec  : uint32 := uint32'Last;\n+            GSVA_Addr : uint64;\n+         when XCOFF32 =>\n+            null;\n+      end case;\n+   end record;\n+\n+   subtype ELF_Object_File is Object_File; -- with\n+   --  Predicate => ELF_Object_File.Format in ELF;\n+   subtype PECOFF_Object_File is Object_File; -- with\n+   --  Predicate => PECOFF_Object_File.Format in Any_PECOFF;\n+   subtype XCOFF32_Object_File is Object_File; -- with\n+   --  Predicate => XCOFF32_Object_File.Format in XCOFF32;\n+   --  ???Above predicates cause the compiler to crash when instantiating\n+   --  ELF64_Ops (see package body).\n+\n+   type Object_Section is record\n+      Num        : uint32 := 0;\n+      --  Section index in the section table\n+\n+      Off        : Offset := 0;\n+      --  First byte of the section in the object file\n+\n+      Addr       : uint64 := 0;\n+      --  Load address of the section. Valid only when Flag_Alloc is true.\n+\n+      Size       : uint64 := 0;\n+      --  Length of the section in bytes\n+\n+      Flag_Alloc : Boolean := False;\n+      --  True if the section is mapped in memory by the OS loader\n+   end record;\n+\n+   Null_Section : constant Object_Section := (0, 0, 0, 0, False);\n+\n+   type Object_Symbol is record\n+      Off   : Offset := 0;  --  Offset of underlying symbol on disk\n+      Next  : Offset := 0;  --  Offset of the following symbol\n+      Value : uint64 := 0;  --  Value associated with this symbol\n+      Size  : uint64 := 0;  --  Size of the referenced entity\n+   end record;\n+\n+   Null_Symbol : constant Object_Symbol := (0, 0, 0, 0);\n+end System.Object_Reader;"}, {"sha": "9655722b923bdf5ba7817862edcca2f1a96b2430", "filename": "gcc/ada/s-trasym-dwarf.adb", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-trasym-dwarf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-trasym-dwarf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-trasym-dwarf.adb?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,689 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . T R A C E B A C K . S Y M B O L I C              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1999-2017, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Run-time symbolic traceback support for targets using DWARF debug data\n+\n+pragma Polling (Off);\n+--  We must turn polling off for this unit, because otherwise we can get\n+--  elaboration circularities when polling is turned on.\n+\n+with Ada.Unchecked_Deallocation;\n+\n+with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;\n+with Ada.Containers.Generic_Array_Sort;\n+\n+with System.Address_To_Access_Conversions;\n+with System.Soft_Links;\n+with System.CRTL;\n+with System.Dwarf_Lines;\n+with System.Exception_Traces;\n+with System.Standard_Library;\n+with System.Traceback_Entries;\n+with System.Strings;\n+with System.Bounded_Strings;\n+\n+package body System.Traceback.Symbolic is\n+\n+   use System.Bounded_Strings;\n+   use System.Dwarf_Lines;\n+\n+   subtype Big_String is String (Positive);\n+   --  To deal with C strings\n+\n+   package Big_String_Conv is new System.Address_To_Access_Conversions\n+     (Big_String);\n+\n+   type Module_Cache;\n+   type Module_Cache_Acc is access all Module_Cache;\n+\n+   type Module_Cache is record\n+      Name : Strings.String_Access;\n+      --  Name of the module\n+\n+      C : Dwarf_Context (In_Exception => True);\n+      --  Context to symbolize an address within this module\n+\n+      Chain : Module_Cache_Acc;\n+   end record;\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Module_Cache,\n+      Module_Cache_Acc);\n+\n+   Cache_Chain : Module_Cache_Acc;\n+   --  Simply linked list of modules\n+\n+   type Module_Array is array (Natural range <>) of Module_Cache_Acc;\n+   type Module_Array_Acc is access Module_Array;\n+\n+   Modules_Cache : Module_Array_Acc;\n+   --  Sorted array of cached modules (if not null)\n+\n+   Exec_Module : aliased Module_Cache;\n+   --  Context for the executable\n+\n+   type Init_State is (Uninitialized, Initialized, Failed);\n+   Exec_Module_State : Init_State := Uninitialized;\n+   --  How Exec_Module is initialized\n+\n+   procedure Init_Exec_Module;\n+   --  Initialize Exec_Module if not already initialized\n+\n+   function Symbolic_Traceback\n+     (Traceback    : System.Traceback_Entries.Tracebacks_Array;\n+      Suppress_Hex : Boolean) return String;\n+   function Symbolic_Traceback\n+     (E            : Ada.Exceptions.Exception_Occurrence;\n+      Suppress_Hex : Boolean) return String;\n+   --  Suppress_Hex means do not print any hexadecimal addresses, even if the\n+   --  symbol is not available.\n+\n+   function Lt (Left, Right : Module_Cache_Acc) return Boolean;\n+   --  Sort function for Module_Cache\n+\n+   procedure Init_Module\n+     (Module       : out Module_Cache;\n+      Success      : out Boolean;\n+      Module_Name  :     String;\n+      Load_Address :     Address := Null_Address);\n+   --  Initialize Module\n+\n+   procedure Close_Module (Module : in out Module_Cache);\n+   --  Finalize Module\n+\n+   function Value (Item : System.Address) return String;\n+   --  Return the String contained in Item, up until the first NUL character\n+\n+   pragma Warnings (Off, \"*Add_Module_To_Cache*\");\n+   procedure Add_Module_To_Cache (Module_Name : String);\n+   --  To be called by Build_Cache_For_All_Modules to add a new module to the\n+   --  list. May not be referenced.\n+\n+   package Module_Name is\n+\n+      procedure Build_Cache_For_All_Modules;\n+      --  Create the cache for all current modules\n+\n+      function Get (Addr : access System.Address) return String;\n+      --  Returns the module name for the given address, Addr may be updated\n+      --  to be set relative to a shared library. This depends on the platform.\n+      --  Returns an empty string for the main executable.\n+\n+      function Is_Supported return Boolean;\n+      pragma Inline (Is_Supported);\n+      --  Returns True if Module_Name is supported, so if the traceback is\n+      --  supported for shared libraries.\n+\n+   end Module_Name;\n+\n+   package body Module_Name is separate;\n+\n+   function Executable_Name return String;\n+   --  Returns the executable name as reported by argv[0]. If gnat_argv not\n+   --  initialized or if argv[0] executable not found in path, function returns\n+   --  an empty string.\n+\n+   function Get_Executable_Load_Address return System.Address;\n+   pragma Import\n+     (C,\n+      Get_Executable_Load_Address,\n+      \"__gnat_get_executable_load_address\");\n+   --  Get the load address of the executable, or Null_Address if not known\n+\n+   procedure Hexa_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String);\n+   --  Non-symbolic traceback (simply write addresses in hexa)\n+\n+   procedure Symbolic_Traceback_No_Lock\n+     (Traceback    :        Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String);\n+   --  Like the public Symbolic_Traceback_No_Lock except there is no provision\n+   --  against concurrent accesses.\n+\n+   procedure Module_Symbolic_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Module       :        Module_Cache;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String);\n+   --  Returns the Traceback for a given module\n+\n+   procedure Multi_Module_Symbolic_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String);\n+   --  Build string containing symbolic traceback for the given call chain\n+\n+   procedure Multi_Module_Symbolic_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Module       :        Module_Cache;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String);\n+   --  Likewise but using Module\n+\n+   Max_String_Length : constant := 4096;\n+   --  Arbitrary limit on Bounded_Str length\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Item : System.Address) return String is\n+   begin\n+      if Item /= Null_Address then\n+         for J in Big_String'Range loop\n+            if Big_String_Conv.To_Pointer (Item) (J) = ASCII.NUL then\n+               return Big_String_Conv.To_Pointer (Item) (1 .. J - 1);\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return \"\";\n+   end Value;\n+\n+   -------------------------\n+   -- Add_Module_To_Cache --\n+   -------------------------\n+\n+   procedure Add_Module_To_Cache (Module_Name : String) is\n+      Module  : Module_Cache_Acc;\n+      Success : Boolean;\n+   begin\n+      Module := new Module_Cache;\n+      Init_Module (Module.all, Success, Module_Name);\n+      if not Success then\n+         Free (Module);\n+         return;\n+      end if;\n+      Module.Chain := Cache_Chain;\n+      Cache_Chain  := Module;\n+   end Add_Module_To_Cache;\n+\n+   ----------------------\n+   -- Init_Exec_Module --\n+   ----------------------\n+\n+   procedure Init_Exec_Module is\n+   begin\n+      if Exec_Module_State = Uninitialized then\n+         declare\n+            Exec_Path : constant String  := Executable_Name;\n+            Exec_Load : constant Address := Get_Executable_Load_Address;\n+            Success   : Boolean;\n+         begin\n+            Init_Module (Exec_Module, Success, Exec_Path, Exec_Load);\n+\n+            if Success then\n+               Exec_Module_State := Initialized;\n+            else\n+               Exec_Module_State := Failed;\n+            end if;\n+         end;\n+      end if;\n+   end Init_Exec_Module;\n+\n+   --------\n+   -- Lt --\n+   --------\n+\n+   function Lt (Left, Right : Module_Cache_Acc) return Boolean is\n+   begin\n+      return Low (Left.C) < Low (Right.C);\n+   end Lt;\n+\n+   -----------------------------\n+   -- Module_Cache_Array_Sort --\n+   -----------------------------\n+\n+   procedure Module_Cache_Array_Sort is new Ada.Containers.Generic_Array_Sort\n+     (Natural,\n+      Module_Cache_Acc,\n+      Module_Array,\n+      Lt);\n+\n+   ------------------\n+   -- Enable_Cache --\n+   ------------------\n+\n+   procedure Enable_Cache (Include_Modules : Boolean := False) is\n+   begin\n+      --  Can be called at most once\n+      if Cache_Chain /= null then\n+         return;\n+      end if;\n+\n+      --  Add all modules\n+      Init_Exec_Module;\n+      Cache_Chain := Exec_Module'Access;\n+\n+      if Include_Modules then\n+         Module_Name.Build_Cache_For_All_Modules;\n+      end if;\n+\n+      --  Build and fill the array of modules\n+      declare\n+         Count  : Natural;\n+         Module : Module_Cache_Acc;\n+      begin\n+         for Phase in 1 .. 2 loop\n+            Count  := 0;\n+            Module := Cache_Chain;\n+            while Module /= null loop\n+               Count := Count + 1;\n+\n+               if Phase = 1 then\n+                  Enable_Cache (Module.C);\n+               else\n+                  Modules_Cache (Count) := Module;\n+               end if;\n+               Module := Module.Chain;\n+            end loop;\n+\n+            if Phase = 1 then\n+               Modules_Cache := new Module_Array (1 .. Count);\n+            end if;\n+         end loop;\n+      end;\n+\n+      --  Sort the array\n+      Module_Cache_Array_Sort (Modules_Cache.all);\n+   end Enable_Cache;\n+\n+   ---------------------\n+   -- Executable_Name --\n+   ---------------------\n+\n+   function Executable_Name return String is\n+      --  We have to import gnat_argv as an Address to match the type of\n+      --  gnat_argv in the binder generated file. Otherwise, we get spurious\n+      --  warnings about type mismatch when LTO is turned on.\n+\n+      Gnat_Argv : System.Address;\n+      pragma Import (C, Gnat_Argv, \"gnat_argv\");\n+\n+      type Argv_Array is array (0 .. 0) of System.Address;\n+      package Conv is new System.Address_To_Access_Conversions (Argv_Array);\n+\n+      function locate_exec_on_path (A : System.Address) return System.Address;\n+      pragma Import (C, locate_exec_on_path, \"__gnat_locate_exec_on_path\");\n+\n+   begin\n+      if Gnat_Argv = Null_Address then\n+         return \"\";\n+      end if;\n+\n+      declare\n+         Addr : constant System.Address :=\n+           locate_exec_on_path (Conv.To_Pointer (Gnat_Argv) (0));\n+         Result : constant String := Value (Addr);\n+\n+      begin\n+         --  The buffer returned by locate_exec_on_path was allocated using\n+         --  malloc, so we should use free to release the memory.\n+\n+         if Addr /= Null_Address then\n+            System.CRTL.free (Addr);\n+         end if;\n+\n+         return Result;\n+      end;\n+   end Executable_Name;\n+\n+   ------------------\n+   -- Close_Module --\n+   ------------------\n+\n+   procedure Close_Module (Module : in out Module_Cache) is\n+   begin\n+      Close (Module.C);\n+      Strings.Free (Module.Name);\n+   end Close_Module;\n+\n+   -----------------\n+   -- Init_Module --\n+   -----------------\n+\n+   procedure Init_Module\n+     (Module       : out Module_Cache;\n+      Success      : out Boolean;\n+      Module_Name  :     String;\n+      Load_Address :     Address := Null_Address)\n+   is\n+   begin\n+      --  Early return if the module is not known\n+\n+      if Module_Name = \"\" then\n+         Success := False;\n+         return;\n+      end if;\n+\n+      Open (Module_Name, Module.C, Success);\n+\n+      --  If a module can't be opened just return now, we just cannot give more\n+      --  information in this case.\n+\n+      if not Success then\n+         return;\n+      end if;\n+\n+      Set_Load_Address (Module.C, Load_Address);\n+\n+      Module.Name := new String'(Module_Name);\n+   end Init_Module;\n+\n+   -------------------------------\n+   -- Module_Symbolic_Traceback --\n+   -------------------------------\n+\n+   procedure Module_Symbolic_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Module       :        Module_Cache;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String)\n+   is\n+      Success : Boolean := False;\n+   begin\n+      if Symbolic.Module_Name.Is_Supported then\n+         Append (Res, '[');\n+         Append (Res, Module.Name.all);\n+         Append (Res, ']' & ASCII.LF);\n+      end if;\n+\n+      Dwarf_Lines.Symbolic_Traceback\n+        (Module.C,\n+         Traceback,\n+         Suppress_Hex,\n+         Success,\n+         Res);\n+\n+      if not Success then\n+         Hexa_Traceback (Traceback, Suppress_Hex, Res);\n+      end if;\n+\n+      --  We must not allow an unhandled exception here, since this function\n+      --  may be installed as a decorator for all automatic exceptions.\n+\n+   exception\n+      when others =>\n+         return;\n+   end Module_Symbolic_Traceback;\n+\n+   -------------------------------------\n+   -- Multi_Module_Symbolic_Traceback --\n+   -------------------------------------\n+\n+   procedure Multi_Module_Symbolic_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String)\n+   is\n+      F : constant Natural := Traceback'First;\n+   begin\n+      if Traceback'Length = 0 or else Is_Full (Res) then\n+         return;\n+      end if;\n+\n+      if Modules_Cache /= null then\n+         --  Search in the cache\n+\n+         declare\n+            Addr        : constant Address := Traceback (F);\n+            Hi, Lo, Mid : Natural;\n+         begin\n+            Lo := Modules_Cache'First;\n+            Hi := Modules_Cache'Last;\n+            while Lo <= Hi loop\n+               Mid := (Lo + Hi) / 2;\n+               if Addr < Low (Modules_Cache (Mid).C) then\n+                  Hi := Mid - 1;\n+               elsif Is_Inside (Modules_Cache (Mid).C, Addr) then\n+                  Multi_Module_Symbolic_Traceback\n+                    (Traceback,\n+                     Modules_Cache (Mid).all,\n+                     Suppress_Hex,\n+                     Res);\n+                  return;\n+               else\n+                  Lo := Mid + 1;\n+               end if;\n+            end loop;\n+\n+            --  Not found\n+            Hexa_Traceback (Traceback (F .. F), Suppress_Hex, Res);\n+            Multi_Module_Symbolic_Traceback\n+              (Traceback (F + 1 .. Traceback'Last),\n+               Suppress_Hex,\n+               Res);\n+         end;\n+      else\n+\n+         --  First try the executable\n+         if Is_Inside (Exec_Module.C, Traceback (F)) then\n+            Multi_Module_Symbolic_Traceback\n+              (Traceback,\n+               Exec_Module,\n+               Suppress_Hex,\n+               Res);\n+            return;\n+         end if;\n+\n+         --  Otherwise, try a shared library\n+         declare\n+            Addr    : aliased System.Address := Traceback (F);\n+            M_Name  : constant String        := Module_Name.Get (Addr'Access);\n+            Module  : Module_Cache;\n+            Success : Boolean;\n+         begin\n+            Init_Module (Module, Success, M_Name, System.Null_Address);\n+            if Success then\n+               Multi_Module_Symbolic_Traceback\n+                 (Traceback,\n+                  Module,\n+                  Suppress_Hex,\n+                  Res);\n+               Close_Module (Module);\n+            else\n+               --  Module not found\n+               Hexa_Traceback (Traceback (F .. F), Suppress_Hex, Res);\n+               Multi_Module_Symbolic_Traceback\n+                 (Traceback (F + 1 .. Traceback'Last),\n+                  Suppress_Hex,\n+                  Res);\n+            end if;\n+         end;\n+      end if;\n+   end Multi_Module_Symbolic_Traceback;\n+\n+   procedure Multi_Module_Symbolic_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Module       :        Module_Cache;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String)\n+   is\n+      Pos : Positive;\n+   begin\n+      --  Will symbolize the first address...\n+\n+      Pos := Traceback'First + 1;\n+\n+      --  ... and all addresses in the same module\n+\n+      Same_Module :\n+      loop\n+         exit Same_Module when Pos > Traceback'Last;\n+\n+         --  Get address to check for corresponding module name\n+\n+         exit Same_Module when not Is_Inside (Module.C, Traceback (Pos));\n+\n+         Pos := Pos + 1;\n+      end loop Same_Module;\n+\n+      Module_Symbolic_Traceback\n+        (Traceback (Traceback'First .. Pos - 1),\n+         Module,\n+         Suppress_Hex,\n+         Res);\n+      Multi_Module_Symbolic_Traceback\n+        (Traceback (Pos .. Traceback'Last),\n+         Suppress_Hex,\n+         Res);\n+   end Multi_Module_Symbolic_Traceback;\n+\n+   --------------------\n+   -- Hexa_Traceback --\n+   --------------------\n+\n+   procedure Hexa_Traceback\n+     (Traceback    :        Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String)\n+   is\n+      use System.Traceback_Entries;\n+   begin\n+      if Suppress_Hex then\n+         Append (Res, \"...\");\n+         Append (Res, ASCII.LF);\n+      else\n+         for J in Traceback'Range loop\n+            Append_Address (Res, PC_For (Traceback (J)));\n+            Append (Res, ASCII.LF);\n+         end loop;\n+      end if;\n+   end Hexa_Traceback;\n+\n+   --------------------------------\n+   -- Symbolic_Traceback_No_Lock --\n+   --------------------------------\n+\n+   procedure Symbolic_Traceback_No_Lock\n+     (Traceback    :        Tracebacks_Array;\n+      Suppress_Hex :        Boolean;\n+      Res          : in out Bounded_String)\n+   is\n+   begin\n+      if Symbolic.Module_Name.Is_Supported then\n+         Multi_Module_Symbolic_Traceback (Traceback, Suppress_Hex, Res);\n+      else\n+         if Exec_Module_State = Failed then\n+            Append (Res, \"Call stack traceback locations:\" & ASCII.LF);\n+            Hexa_Traceback (Traceback, Suppress_Hex, Res);\n+         else\n+            Module_Symbolic_Traceback\n+              (Traceback,\n+               Exec_Module,\n+               Suppress_Hex,\n+               Res);\n+         end if;\n+      end if;\n+   end Symbolic_Traceback_No_Lock;\n+\n+   ------------------------\n+   -- Symbolic_Traceback --\n+   ------------------------\n+\n+   function Symbolic_Traceback\n+     (Traceback    : Tracebacks_Array;\n+      Suppress_Hex : Boolean) return String\n+   is\n+      Res : Bounded_String (Max_Length => Max_String_Length);\n+   begin\n+      System.Soft_Links.Lock_Task.all;\n+      Init_Exec_Module;\n+      Symbolic_Traceback_No_Lock (Traceback, Suppress_Hex, Res);\n+      System.Soft_Links.Unlock_Task.all;\n+\n+      return To_String (Res);\n+\n+   exception\n+      when others =>\n+         System.Soft_Links.Unlock_Task.all;\n+         raise;\n+   end Symbolic_Traceback;\n+\n+   function Symbolic_Traceback\n+     (Traceback : System.Traceback_Entries.Tracebacks_Array) return String is\n+   begin\n+      return Symbolic_Traceback (Traceback, Suppress_Hex => False);\n+   end Symbolic_Traceback;\n+\n+   function Symbolic_Traceback_No_Hex\n+     (Traceback : System.Traceback_Entries.Tracebacks_Array) return String is\n+   begin\n+      return Symbolic_Traceback (Traceback, Suppress_Hex => True);\n+   end Symbolic_Traceback_No_Hex;\n+\n+   function Symbolic_Traceback\n+     (E            : Ada.Exceptions.Exception_Occurrence;\n+      Suppress_Hex : Boolean) return String\n+   is\n+   begin\n+      return Symbolic_Traceback\n+          (Ada.Exceptions.Traceback.Tracebacks (E),\n+           Suppress_Hex);\n+   end Symbolic_Traceback;\n+\n+   function Symbolic_Traceback\n+     (E : Ada.Exceptions.Exception_Occurrence) return String\n+   is\n+   begin\n+      return Symbolic_Traceback (E, Suppress_Hex => False);\n+   end Symbolic_Traceback;\n+\n+   function Symbolic_Traceback_No_Hex\n+     (E : Ada.Exceptions.Exception_Occurrence) return String is\n+   begin\n+      return Symbolic_Traceback (E, Suppress_Hex => True);\n+   end Symbolic_Traceback_No_Hex;\n+\n+   Exception_Tracebacks_Symbolic : Integer;\n+   pragma Import\n+     (C,\n+      Exception_Tracebacks_Symbolic,\n+      \"__gl_exception_tracebacks_symbolic\");\n+   --  Boolean indicating whether symbolic tracebacks should be generated.\n+\n+   use Standard_Library;\n+begin\n+   --  If this version of this package is available, and the binder switch -Es\n+   --  was given, then we want to use this as the decorator by default, and we\n+   --  want to turn on tracing for Unhandled_Raise_In_Main. Note that the user\n+   --  cannot have already set Exception_Trace, because the runtime library is\n+   --  elaborated before user-defined code.\n+\n+   if Exception_Tracebacks_Symbolic /= 0 then\n+      Exception_Traces.Set_Trace_Decorator (Symbolic_Traceback'Access);\n+      pragma Assert (Exception_Trace = RM_Convention);\n+      Exception_Trace := Unhandled_Raise_In_Main;\n+   end if;\n+end System.Traceback.Symbolic;"}, {"sha": "8c1f8b4ada8b3e5bbc5efaa23a25328a33b68ec6", "filename": "gcc/ada/s-tsmona-linux.adb", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-tsmona-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-tsmona-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tsmona-linux.adb?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,190 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--  G N A T . T R A C E B A C K . S Y M B O L I C . M O D U L E _ N A M E   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2012-2017, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the GNU/Linux specific version of this package\n+with Interfaces.C;              use Interfaces.C;\n+\n+with System.Address_Operations; use System.Address_Operations;\n+\n+separate (System.Traceback.Symbolic)\n+\n+package body Module_Name is\n+\n+   use System;\n+\n+   pragma Linker_Options (\"-ldl\");\n+\n+   function Is_Shared_Lib (Base : Address) return Boolean;\n+   --  Returns True if a shared library\n+\n+   --  The principle is:\n+\n+   --  1. We get information about the module containing the address.\n+\n+   --  2. We check that the full pathname is pointing to a shared library.\n+\n+   --  3. for shared libraries, we return the non relocated address (so\n+   --     the absolute address in the shared library).\n+\n+   --  4. we also return the full pathname of the module containing this\n+   --     address.\n+\n+   -------------------\n+   -- Is_Shared_Lib --\n+   -------------------\n+\n+   function Is_Shared_Lib (Base : Address) return Boolean is\n+      EI_NIDENT : constant := 16;\n+      type u16 is mod 2 ** 16;\n+\n+      --  Just declare the needed header information, we just need to read the\n+      --  type encoded in the second field.\n+\n+      type Elf32_Ehdr is record\n+         e_ident : char_array (1 .. EI_NIDENT);\n+         e_type  : u16;\n+      end record;\n+\n+      ET_DYN : constant := 3; -- A shared lib if e_type = ET_DYN\n+\n+      Header : Elf32_Ehdr;\n+      pragma Import (Ada, Header);\n+      --  Suppress initialization in Normalized_Scalars mode\n+      for Header'Address use Base;\n+\n+   begin\n+      return Header.e_type = ET_DYN;\n+   exception\n+      when others =>\n+         return False;\n+   end Is_Shared_Lib;\n+\n+   ---------------------------------\n+   -- Build_Cache_For_All_Modules --\n+   ---------------------------------\n+\n+   procedure Build_Cache_For_All_Modules is\n+      type link_map;\n+      type link_map_acc is access all link_map;\n+      pragma Convention (C, link_map_acc);\n+\n+      type link_map is record\n+         l_addr : Address;\n+         --  Base address of the shared object\n+\n+         l_name : Address;\n+         --  Null-terminated absolute file name\n+\n+         l_ld   : Address;\n+         --  Dynamic section\n+\n+         l_next, l_prev : link_map_acc;\n+         --  Chain\n+      end record;\n+      pragma Convention (C, link_map);\n+\n+      type r_debug_type is record\n+         r_version : Integer;\n+         r_map : link_map_acc;\n+      end record;\n+      pragma Convention (C, r_debug_type);\n+\n+      r_debug : r_debug_type;\n+      pragma Import (C, r_debug, \"_r_debug\");\n+\n+      lm : link_map_acc;\n+   begin\n+      lm := r_debug.r_map;\n+      while lm /= null loop\n+         if Big_String_Conv.To_Pointer (lm.l_name) (1) /= ASCII.NUL then\n+            --  Discard non-file (like the executable itself or the gate).\n+            Add_Module_To_Cache (Value (lm.l_name));\n+         end if;\n+         lm := lm.l_next;\n+      end loop;\n+   end Build_Cache_For_All_Modules;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get (Addr : access System.Address) return String is\n+\n+      --  Dl_info record for Linux, used to get sym reloc offset\n+\n+      type Dl_info is record\n+         dli_fname : System.Address;\n+         dli_fbase : System.Address;\n+         dli_sname : System.Address;\n+         dli_saddr : System.Address;\n+      end record;\n+\n+      function dladdr\n+        (addr : System.Address;\n+         info : not null access Dl_info) return int;\n+      pragma Import (C, dladdr, \"dladdr\");\n+      --  This is a Linux extension and not POSIX\n+\n+      info : aliased Dl_info;\n+\n+   begin\n+      if dladdr (Addr.all, info'Access) /= 0 then\n+\n+         --  If we have a shared library we need to adjust the address to\n+         --  be relative to the base address of the library.\n+\n+         if Is_Shared_Lib (info.dli_fbase) then\n+            Addr.all := SubA (Addr.all, info.dli_fbase);\n+         end if;\n+\n+         return Value (info.dli_fname);\n+\n+      --  Not found, fallback to executable name\n+\n+      else\n+         return \"\";\n+      end if;\n+\n+   exception\n+      when others =>\n+         return \"\";\n+   end Get;\n+\n+   ------------------\n+   -- Is_Supported --\n+   ------------------\n+\n+   function Is_Supported return Boolean is\n+   begin\n+      return True;\n+   end Is_Supported;\n+\n+end Module_Name;"}, {"sha": "46c35cd791a53e74ef930ebaf202669b43ba1953", "filename": "gcc/ada/s-tsmona-mingw.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-tsmona-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2529c0aa7712b562d28fde46257a36183b60eab/gcc%2Fada%2Fs-tsmona-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tsmona-mingw.adb?ref=a2529c0aa7712b562d28fde46257a36183b60eab", "patch": "@@ -0,0 +1,93 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--  G N A T . T R A C E B A C K . S Y M B O L I C . M O D U L E _ N A M E   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2012-2017, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Windows specific version of this package\n+\n+with System.Win32; use System.Win32;\n+\n+separate (System.Traceback.Symbolic)\n+\n+package body Module_Name is\n+\n+   use System;\n+\n+   ---------------------------------\n+   -- Build_Cache_For_All_Modules --\n+   ---------------------------------\n+\n+   procedure Build_Cache_For_All_Modules is\n+   begin\n+      null;\n+   end Build_Cache_For_All_Modules;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get (Addr : access System.Address) return String is\n+      Res     : DWORD;\n+      hModule : aliased HANDLE;\n+      Path    : String (1 .. 1_024);\n+\n+   begin\n+      if GetModuleHandleEx\n+           (GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+            Addr.all,\n+            hModule'Access) = Win32.TRUE\n+      then\n+         Res := GetModuleFileName (hModule, Path'Address, Path'Length);\n+\n+         if FreeLibrary (hModule) = Win32.FALSE then\n+            null;\n+         end if;\n+\n+         if Res > 0 then\n+            return Path (1 .. Positive (Res));\n+         end if;\n+      end if;\n+\n+      return \"\";\n+\n+   exception\n+      when others =>\n+         return \"\";\n+   end Get;\n+\n+   ------------------\n+   -- Is_Supported --\n+   ------------------\n+\n+   function Is_Supported return Boolean is\n+   begin\n+      return True;\n+   end Is_Supported;\n+\n+end Module_Name;"}]}