{"sha": "73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNmZmVmZDAxNzEyOGZlY2NjZGQ1MmFhOGI2ZmI5ZjA0MmUwYmJiOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:30Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:30Z"}, "message": "Initial revision\n\nFrom-SVN: r26246", "tree": {"sha": "e6d8fcc8767be9361e18c552ee43ecfc3b4fdea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6d8fcc8767be9361e18c552ee43ecfc3b4fdea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/comments", "author": null, "committer": null, "parents": [{"sha": "c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46bb2fd3d0119fff60915dbefc4e0aa3147e8a2"}], "stats": {"total": 28524, "additions": 28524, "deletions": 0}, "files": [{"sha": "c65a73e2eb82c34abc66fde5b439d6d631594825", "filename": "boehm-gc/BCC_MAKEFILE", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FBCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FBCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FBCC_MAKEFILE?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,82 @@\n+# Makefile for Borland C++ 4.5 on NT\r\n+# For Borland 5.0, replace bc45 by bc5.\r\n+# If you have the Borland assembler, remove \"-DUSE_GENERIC\"\r\n+#\r\n+bc=        c:\\bc45\r\n+bcbin=     $(bc)\\bin\r\n+bclib=     $(bc)\\lib\r\n+bcinclude= $(bc)\\include\r\n+\r\n+cc=      $(bcbin)\\bcc32\r\n+rc=      $(bcbin)\\brc32\r\n+lib=     $(bcbin)\\tlib\r\n+link=    $(bcbin)\\tlink32\r\n+cflags=  -R -v -vi -H -H=gc.csm -I$(bcinclude);cord -L$(bclib) \\\r\n+         -w-pro -w-aus -w-par -w-ccc -w-rch -a4 -D__STDC__=0\r\n+#defines= -DSILENT\r\n+defines= -DSMALL_CONFIG -DSILENT -DALL_INTERIOR_POINTERS -DUSE_GENERIC\r\n+\r\n+.c.obj:\r\n+\t$(cc) @&&|\r\n+        $(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.c\r\n+|\r\n+\r\n+.cpp.obj:\r\n+\t$(cc) @&&|\r\n+        $(cdebug) $(cflags) $(cvars) $(defines) -o$* -c $*.cpp\r\n+|\r\n+\r\n+.rc.res:\r\n+    $(rc) -i$(bcinclude) -r -fo$* $*.rc\r\n+\r\n+XXXOBJS= XXXalloc.obj XXXreclaim.obj XXXallchblk.obj XXXmisc.obj \\\r\n+    XXXmach_dep.obj XXXos_dep.obj XXXmark_rts.obj XXXheaders.obj XXXmark.obj \\\r\n+    XXXobj_map.obj XXXblacklst.obj XXXfinalize.obj XXXnew_hblk.obj \\\r\n+    XXXdbg_mlc.obj XXXmalloc.obj XXXstubborn.obj XXXdyn_load.obj \\\r\n+    XXXtypd_mlc.obj XXXptr_chck.obj XXXgc_cpp.obj XXXmallocx.obj\r\n+\r\n+OBJS= $(XXXOBJS:XXX=)\r\n+\r\n+all: gctest.exe cord\\de.exe test_cpp.exe\r\n+\r\n+$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h config.h MAKEFILE\r\n+\r\n+gc.lib: $(OBJS)\r\n+    -del gc.lib\r\n+\ttlib $* @&&|\r\n+        $(XXXOBJS:XXX=+)\r\n+|\r\n+\r\n+gctest.exe: test.obj gc.lib\r\n+    $(cc) @&&|\r\n+        $(cflags) -W -e$* test.obj gc.lib\r\n+|\r\n+\r\n+cord\\de.obj cord\\de_win.obj: cord\\cord.h cord\\private\\cord_pos.h cord\\de_win.h \\\r\n+    cord\\de_cmds.h\r\n+\r\n+cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj \\\r\n+        cord\\de_win.res gc.lib\r\n+\t$(cc) @&&|\r\n+        $(cflags) -W -e$* cord\\cordbscs.obj cord\\cordxtra.obj \\\r\n+        cord\\de.obj cord\\de_win.obj gc.lib\r\n+|\r\n+    $(rc) cord\\de_win.res cord\\de.exe\r\n+\r\n+gc_cpp.obj: gc_cpp.h gc.h\r\n+\r\n+gc_cpp.cpp: gc_cpp.cc\r\n+\tcopy gc_cpp.cc gc_cpp.cpp\r\n+\r\n+test_cpp.cpp: test_cpp.cc\r\n+\tcopy test_cpp.cc test_cpp.cpp\r\n+\r\n+test_cpp.exe: test_cpp.obj gc_cpp.h gc.h gc.lib\r\n+    $(cc) @&&|\r\n+        $(cflags) -W -e$* test_cpp.obj gc.lib\r\n+|\r\n+\r\n+scratch:\r\n+    -del *.obj *.res *.exe *.csm cord\\*.obj cord\\*.res cord\\*.exe cord\\*.csm\r\n+\r\n+\r"}, {"sha": "1ade12adc5c44523d87e1e8d618a4bf19eced947", "filename": "boehm-gc/EMX_MAKEFILE", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FEMX_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FEMX_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FEMX_MAKEFILE?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,141 @@\n+#\n+#  OS/2 specific Makefile for the EMX environment\n+#\n+#  You need GNU Make 3.71, gcc 2.5.7, emx 0.8h and GNU fileutils 3.9\n+#  or similar tools. C++ interface and de.exe weren't tested.\n+#\n+#  Rename this file \"Makefile\".\n+#\n+\n+# Primary targets:\n+# gc.a - builds basic library\n+# c++ - adds C++ interface to library and include directory\n+# cords - adds cords (heavyweight strings) to library and include directory\n+# test - prints porting information, then builds basic version of gc.a, and runs\n+#        some tests of collector and cords.  Does not add cords or c++ interface to gc.a\n+# cord/de.exe - builds dumb editor based on cords.\n+CC= gcc\n+CXX=g++\n+# Needed only for \"make c++\", which adds the c++ interface\n+\n+CFLAGS= -O -DALL_INTERIOR_POINTERS -DSILENT\n+# Setjmp_test may yield overly optimistic results when compiled\n+# without optimization.\n+# -DSILENT disables statistics printing, and improves performance.\n+# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+#   altered stubborn objects, at substantial performance cost.\n+# -DFIND_LEAK causes the collector to assume that all inaccessible\n+#   objects should have been explicitly deallocated, and reports exceptions\n+# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n+#   (Clients should also define SOLARIS_THREADS and then include\n+#   gc.h before performing thr_ or GC_ operations.)\n+# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n+#   of objects to be recognized.  (See gc_private.h for consequences.)\n+# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n+#   usually causing it to use less space in such situations.\n+#   Incremental collection no longer works in this case.\n+# -DDONT_ADD_BYTE_AT_END is meaningful only with\n+#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n+#   causes all objects to be padded so that pointers just past the end of\n+#   an object can be recognized.  This can be expensive.  (The padding\n+#   is normally more than one byte due to alignment constraints.)\n+#   -DDONT_ADD_BYTE_AT_END disables the padding.\n+\n+AR= ar\n+RANLIB= ar s\n+\n+# Redefining srcdir allows object code for the nonPCR version of the collector\n+# to be generated in different directories\n+srcdir = .\n+VPATH = $(srcdir)\n+\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o mallocx.o\n+\n+CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n+\n+CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n+           $(srcdir)/cord/cord_pos.h\n+\n+# Libraries needed for curses applications.  Only needed for de.\n+CURSES= -lcurses -ltermlib\n+\n+# The following is irrelevant on most systems.  But a few\n+# versions of make otherwise fork the shell specified in\n+# the SHELL environment variable.\n+SHELL= bash\n+\n+SPECIALCFLAGS = \n+# Alternative flags to the C compiler for mach_dep.c.\n+# Mach_dep.c often doesn't like optimization, and it's\n+# not time-critical anyway.\n+\n+all: gc.a gctest.exe\n+\n+$(OBJS) test.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n+    $(srcdir)/config.h $(srcdir)/gc_typed.h\n+# The dependency on Makefile is needed.  Changing\n+# options such as -DSILENT affects the size of GC_arrays,\n+# invalidating all .o files that rely on gc_priv.h\n+\n+mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n+\n+gc.a: $(OBJS)\n+\t$(AR) ru gc.a $(OBJS)\n+\t$(RANLIB) gc.a\n+\n+cords: $(CORD_OBJS) cord/cordtest.exe\n+\t$(AR) ru gc.a $(CORD_OBJS)\n+\t$(RANLIB) gc.a\n+\tcp $(srcdir)/cord/cord.h include/cord.h\n+\tcp $(srcdir)/cord/ec.h include/ec.h\n+\tcp $(srcdir)/cord/cord_pos.h include/cord_pos.h\n+\n+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h\n+\t$(CXX) -c -O $(srcdir)/gc_cpp.cc\n+\t\n+c++: gc_cpp.o $(srcdir)/gc_cpp.h\n+\t$(AR) ru gc.a gc_cpp.o\n+\t$(RANLIB) gc.a\n+\tcp $(srcdir)/gc_cpp.h include/gc_cpp.h \n+\n+mach_dep.o: $(srcdir)/mach_dep.c\n+\t$(CC) -o mach_dep.o -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n+\n+mark_rts.o: $(srcdir)/mark_rts.c\n+\t$(CC) -o mark_rts.o -c $(CFLAGS) $(srcdir)/mark_rts.c\n+\n+cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c -o  cord/cordbscs.o\n+\n+cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c -o  cord/cordxtra.o\n+\n+cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c -o cord/cordprnt.o\n+\n+cord/cordtest.exe: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a\n+\t$(CC) $(CFLAGS) -o cord/cordtest.exe $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a\n+\n+cord/de.exe: $(srcdir)/cord/de.c $(srcdir)/cord/cordbscs.o $(srcdir)/cord/cordxtra.o gc.a\n+\t$(CC) $(CFLAGS) -o cord/de.exe $(srcdir)/cord/de.c $(srcdir)/cord/cordbscs.o $(srcdir)/cord/cordxtra.o gc.a $(CURSES)\n+\n+clean: \n+\trm -f gc.a test.o gctest.exe output-local output-diff $(OBJS) \\\n+\t      setjmp_test  mon.out gmon.out a.out core \\\n+\t      $(CORD_OBJS) cord/cordtest.exe cord/de.exe\n+\t-rm -f *~\n+\n+gctest.exe: test.o gc.a\n+\t$(CC) $(CFLAGS) -o gctest.exe test.o gc.a\n+\n+# If an optimized setjmp_test generates a segmentation fault,\n+# odds are your compiler is broken.  Gctest may still work.\n+# Try compiling setjmp_t.c unoptimized.\n+setjmp_test.exe: $(srcdir)/setjmp_t.c $(srcdir)/gc.h\n+\t$(CC) $(CFLAGS) -o setjmp_test.exe $(srcdir)/setjmp_t.c\n+\n+test: setjmp_test.exe gctest.exe\n+\t./setjmp_test\n+\t./gctest\n+\tmake cord/cordtest.exe\n+\tcord/cordtest"}, {"sha": "420ea500e3e63cd79e9105c41f849171ea4c3cbe", "filename": "boehm-gc/MacOS.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMacOS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMacOS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMacOS.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,137 @@\n+/*\n+\tMacOS.c\n+\t\n+\tSome routines for the Macintosh OS port of the Hans-J. Boehm, Alan J. Demers\n+\tgarbage collector.\n+\t\n+\t<Revision History>\n+\t\n+\t11/22/94  pcb  StripAddress the temporary memory handle for 24-bit mode.\n+\t11/30/94  pcb  Tracking all memory usage so we can deallocate it all at once.\n+\t02/10/96  pcb  Added routine to perform a final collection when\n+unloading shared library.\n+\t\n+\tby Patrick C. Beard.\n+ */\n+/* Boehm, February 15, 1996 2:55 pm PST */\n+\n+#include <Resources.h>\n+#include <Memory.h>\n+#include <LowMem.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"gc.h\"\n+#include \"gc_priv.h\"\n+\n+// use 'CODE' resource 0 to get exact location of the beginning of global space.\n+\n+typedef struct {\n+\tunsigned long aboveA5;\n+\tunsigned long belowA5;\n+\tunsigned long JTSize;\n+\tunsigned long JTOffset;\n+} *CodeZeroPtr, **CodeZeroHandle;\n+\n+void* GC_MacGetDataStart()\n+{\n+\tCodeZeroHandle code0 = (CodeZeroHandle)GetResource('CODE', 0);\n+\tif (code0) {\n+\t\tlong belowA5Size = (**code0).belowA5;\n+\t\tReleaseResource((Handle)code0);\n+\t\treturn (LMGetCurrentA5() - belowA5Size);\n+\t}\n+\tfprintf(stderr, \"Couldn't load the jump table.\");\n+\texit(-1);\n+\treturn 0;\n+}\n+\n+/* track the use of temporary memory so it can be freed all at once. */\n+\n+typedef struct TemporaryMemoryBlock TemporaryMemoryBlock, **TemporaryMemoryHandle;\n+\n+struct TemporaryMemoryBlock {\n+\tTemporaryMemoryHandle nextBlock;\n+\tchar data[];\n+};\n+\n+static TemporaryMemoryHandle theTemporaryMemory = NULL;\n+static Boolean firstTime = true;\n+\n+void GC_MacFreeTemporaryMemory(void);\n+\n+Ptr GC_MacTemporaryNewPtr(size_t size, Boolean clearMemory)\n+{\n+\tstatic Boolean firstTime = true;\n+\tOSErr result;\n+\tTemporaryMemoryHandle tempMemBlock;\n+\tPtr tempPtr = nil;\n+\n+\ttempMemBlock = (TemporaryMemoryHandle)TempNewHandle(size + sizeof(TemporaryMemoryBlock), &result);\n+\tif (tempMemBlock && result == noErr) {\n+\t\tHLockHi((Handle)tempMemBlock);\n+\t\ttempPtr = (**tempMemBlock).data;\n+\t\tif (clearMemory) memset(tempPtr, 0, size);\n+\t\ttempPtr = StripAddress(tempPtr);\n+\n+\t\t// keep track of the allocated blocks.\n+\t\t(**tempMemBlock).nextBlock = theTemporaryMemory;\n+\t\ttheTemporaryMemory = tempMemBlock;\n+\t}\n+\t\n+#     if !defined(SHARED_LIBRARY_BUILD)\n+\t// install an exit routine to clean up the memory used at the end.\n+\tif (firstTime) {\n+\t\tatexit(&GC_MacFreeTemporaryMemory);\n+\t\tfirstTime = false;\n+\t}\n+#     endif\n+\t\n+\treturn tempPtr;\n+}\n+\n+extern word GC_fo_entries; \n+\n+static void perform_final_collection()\n+{\n+  unsigned i;\n+  word last_fo_entries = 0;\n+  \n+  /* adjust the stack bottom, because CFM calls us from another stack\n+     location. */\n+     GC_stackbottom = (ptr_t)&i;\n+\n+  /* try to collect and finalize everything in sight */\n+    for (i = 0; i < 2 || GC_fo_entries < last_fo_entries; i++) {\n+        last_fo_entries = GC_fo_entries;\n+        GC_gcollect();\n+    }\n+}\n+\n+\n+void GC_MacFreeTemporaryMemory()\n+{\n+# if defined(SHARED_LIBRARY_BUILD)\n+    /* if possible, collect all memory, and invoke all finalizers. */\n+      perform_final_collection();\n+# endif\n+\n+    if (theTemporaryMemory != NULL) {\n+\tlong totalMemoryUsed = 0;\n+\tTemporaryMemoryHandle tempMemBlock = theTemporaryMemory;\n+\twhile (tempMemBlock != NULL) {\n+\t\tTemporaryMemoryHandle nextBlock = (**tempMemBlock).nextBlock;\n+\t\ttotalMemoryUsed += GetHandleSize((Handle)tempMemBlock);\n+\t\tDisposeHandle((Handle)tempMemBlock);\n+\t\ttempMemBlock = nextBlock;\n+\t}\n+\ttheTemporaryMemory = NULL;\n+\n+#       if !defined(SILENT) && !defined(SHARED_LIBRARY_BUILD)\n+          fprintf(stdout, \"[total memory used:  %ld bytes.]\\n\",\n+                  totalMemoryUsed);\n+          fprintf(stdout, \"[total collections:  %ld.]\\n\", GC_gc_no);\n+#       endif\n+    }\n+}"}, {"sha": "99dff88b4cfbc1d2946cf9ec2ae82610e6139056", "filename": "boehm-gc/MacProjects.sit.hqx", "status": "added", "additions": 886, "deletions": 0, "changes": 886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMacProjects.sit.hqx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMacProjects.sit.hqx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMacProjects.sit.hqx?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,886 @@\n+(This file must be converted with BinHex 4.0)\n+\n+:$deKBe\"bEfTPBh4c,R0TG!\"6594%8dP8)3#3\"&)e!!!\"4UiT8dP8)3!(!!\"50A*\n+\n+-BA8#ZJ#3!aB\"#3d0#'GM,MBi5bkjBf038%-ZZ3#3%)Zi!*!8\"@`!N!6rN!4069\"\n+\n+568e$3`%!UbqAD+X`19S!!!Ba!!!,*J!!!F%!!!-PfTmj1`#3\"PET)d31)LTH6H4\n+\n+#*AqG5b5HI*)QjY$IIb00%ReTJSi6rG$jG(bZ,\"Rc,9Umf[IRj)6FZ-j`GfGR)#!\n+\n+m-#qLqB#cj'G%46qffB3q8AppLXKc+P&*il4FMJMq3N32r[U,(PlSNdrQm-J(4!p\n+\n+jK)NHmKJSHY!,&chS$4)pk%8mL3I)B0'$AU6S3'q)k%%[5[5J&ffa#68)0ZM&#T!\n+\n+!*fHC-2dFZ3i83[Vr[4Xh'+DNQrm'J)rrpqe%ST`,FeVi6b,*qHH\")4eQc28NFMN\n+\n+ZT*m,L\"Y%-`pdAk6RLHDaeVV0a,,@P(4UUK66rUM'8bf91llS(\"lTh81)MBQ+4*q\n+\n+rfHENEhD)Ke#3!09'M%bL[P1+G88fa$3e)5Gpf0kARpBf*6eIH*0`ZBHR%ii\"PbN\n+\n++D&*)688M)Sm$Bm[cCdDjh2YIjmAc`(TVpi*Vka((A*&Yl@'LTSH1M*AMP#,2[A$\n+\n+(FHA@S\"dL4dER#3b!EfBYem(C9P5iGH\"a-bb-AL(F\"bb-AL,F6)%a9pJUL,(hf%B\n+\n+TeQb[\"X5ib4DQXV!-fa6&mZf&3,(C&UDd-((SpeMBEIB`8Zc,BcZR3A5'X+jYj$'\n+\n+6)6HVV+R[!`#3!`X!(E@*MFQ%R4d\"))`m[3JM[c)bBS54Tj'M(AP+MK&f%VD5SdG\n+\n+SANFB@3Rqc$Am83(+)`\"G(D%A'9!bBQ6!b)b4Sq3SH8D1NDGNX$)bBi54!51--$*\n+\n+Kj0L!M\"KKK\"dC--,)-h+-6#KKC-$)-F)NamL!!Z06#X!!b&%bBUHp8RcN'%%6!b,\n+\n+i!!kV\"`\"DLHFaK*!!\"Ym4K,,2i2X4c[,`c5!GIPf!ZcNi'8'VfJFpSfdpq+CY$8j\n+\n+-V'f-DZr2[36#1(ael5hmfT@1cSU66D5pqDSA89pdTP-`Z[jj6T&!PmZBFZjal\"&\n+\n+5iG6#blE$+&kLh#QZ118&(0T1J(hZ,9)5MJ9ic*qPI!ac'RJ96QMZjSbkMq()Ui6\n+\n+B+f,,#'N1icbM4N\"aaBr1`3Z9U'8RY'XAiVXFKp#&k2D5Be%VCdh4%,+2QS'b\"Q2\n+\n+%0PNT4rE#%kTUFqYDM56bVjfe!p8MqmL)1VmjVkJY`U[*$&*L3AMSpB@LCQ*U&l%\n+\n+T+3890rL,V9klFN*4@f0UTf8Z&&afN!\"4GC6G8p3fN9$4+4[-@DAeK%lej\"@eAAL\n+\n+eU@&4[Tm28%mqqUkS(F+VDa#lB&'rlRAllRP&l460Qc,)MHR$jMh@$8Y4Xc'e`cd\n+\n+ZE2AUUiH+fK96feb$epq&'RAQeLG&lCDjmP+\"Kr8k9#qp'eI8RPf[6R$dS+$UcqI\n+\n+ELYSV[*ETFL&j[@lr803qd9I2A#bi4Vei3*d[+@Urk*!!&abe0HTVm%44\"i4A6JN\n+\n+c(2I!kjRl6a9e813DK\"A6p(LjRZZGaGH+1L5SiBT[(6ekd2*ILMSXU(l)#m3QMDB\n+\n+V+QTG!r*NG#RQai#DNh4,l0&!Ie`dYi98Y1%1A$5hKP4,`d9cHdKP'LkD@q4hYC*\n+\n+%dfdLeCCNN@i9UIBNLh5l5(8N68qhM&4R`d9cfdKP'bkD@dHU+qe&XRfNZSqc10j\n+\n+#8Me*&ZNfNZT0hSYd+dP&ri-FGM6G6P,p5D,rPNT0`dQLk5+6'NLb5\"HDe'$L)Pe\n+\n+X8N2bj-Z'$r$6-$NZjLGC)1lB-\"jQSff@[ak%LJ[rI#%p2ddAGREN(@\"V+,S6CI!\n+\n+I!!!0$3KRBbj38%-ZZ@0M8&\"$,VN!N\"#$BJ#3%4B!!!d'!*!%rj!%68e38Ne33d-\n+\n+\"!+X[PfqV-$P*!!!'-3!!&UB!!!(&!!!&C80(jji!N!BMM#0%$L)UANhN3L9rV@9\n+\n+B`f#c2p$XpAVVCc-[`k20Y5bJ+CTHPScj`Z'!lmr*#EPaRH(ZcR!J!!rqMKG\"q)#\n+\n+cj'G%46qffB3q8Aqp4R6FA83PM6`KUjaYD&IlZ@jDrY\"pk[b&AZrdH*kFbb9PM*S\n+\n+`4Kh$c8Lf0bVe+Y`Q$amM6mc%*C1(jF&1bFSdGIlLpc*04b#X&D8[&6R%+-#6HhJ\n+\n+kX\"#A+Bp6%6RGkB&kM%'jh$ZLmam[1Irq,r82rGM\"5H4bh1ZB+b\"Z%&-pD)5CL9(\n+\n+AP(4UUK6$!(lkH+UPFXFARF-MIHHMXf!5Nd%SZYRQj'pfL)G3N!$94X#(q25G8U`\n+\n+VXL'QU3Njk8[phV2@0Q92J#d6rA2N1[\"[!%c(M4X-8p,0IcYJf2lRBmD2c)*RQEF\n+\n+68m'9jqq*MjHTji&GqDp$kh501r9fqVPJe4iQDRS)L!)ELqiX08i#@40jpP1+F@p\n+\n+iC&))L)Qq4Bk-cK-i*h`cDlN1cMBUbZA3+beKhX*-&UD`X%ME%F91fHB3BaCC''Y\n+\n+KNba-C@(,\"-40Yl\"l,#c8`YCDf%#\"XGD%F4m3'*i'k\"iah[Ddam+k\"Xd3eV@02'B\n+\n+bj'D90I9p!!!-q)[jAU2HhQ[NiCQC&f(Ne`JR!hlN1''4Sjc`)hcL5IK+f(@8(q&\n+\n+(1&Nj2XreTBI[M!0dGB4'MK01#CFF2c,JK\"*1MNZ1(q&(11@5ii5EKimF*ja``Np\n+\n+#bA(#bBL6BpQ6jq5imT-m2mQ!dq2N'H&2RT2M%Nii'6$J,PF!#N#jGS3IS9Uba%G\n+\n+'A-)*8[#%!j-9'#r3@EpUPQ9+NL6$ldj*kVS6INIK@`*q'q$hGRJCPb,`pUJm(fQ\n+\n+3!#mGrdQqe$Nm22hkJ2cerNp\"i3$m4Z62S5YA40V([V`MbHF@)QPT2IN@3@$ceHm\n+\n+I&dT3GqF9K,'&&8[6LKMTbQ6@-*%bJE#4RM,b'FA*'VC5`0BBdTa\"@aNXM#)mU'\"\n+\n+N@d@XSIKMMiMh#RbbLSjLT49GG9\"F84)Q8QfN&![N1hK\"A'V5F,,dJIF@+`iNJEb\n+\n+H-(5Nar84j!\"*Q54MH+j&08dYQc,(ipT9I+aFqIQc-XP313&803UUPPD4*+UAIlj\n+\n+$U+jMAP1QUSfEYV2Qp4HKfZ#TYQTCT)hEaCbp+ZXH0\"m5USfHDV1HbL4cCT@41rr\n+\n+5+d+eL4&+'hR90)iLRp$LYcm)e5McQN@UMR#&$kKqr%eHU-DBejbUCC-k+P4N5r%\n+\n+Iha+Uc5aj)kVfm*'ej*8Dali5ULfHDLah-l$Zfer1#G9@6l8TTf*r,RKTZ2#Q8'h\n+\n+MA2&i%MYq(0aCicHKfPlfDYLeJ3*FFEG3l@\"HmfJbqFrdHU&IU+jRHE95BmQFkJF\n+\n+29)qp)93hX!aCGLfYP0!jSEU4HF9)-e8M9rADGfC4U(BbVVC66+8XR2Hj2RAmGk'\n+\n+kLDNk8`@p0[6F\"hrG,e3h`kmm(BhDMQjBm@`ejDH1pG)YbUXYM'Y'5aD`-H(VPZ)\n+\n+,*i6A,Nqe)D1Y'5@UV@HM3VAE)a3$3MT+9jAGa)HI#%*E@9ie+jmf-PA9dY#66`Z\n+\n+[fkMA!l&$eZ3)bP996crcal6`ZRdT$9NG0S#+V([`rRZ&eae,A%dMGB2V4H%9YPL\n+\n+LfZ3B194,NC[ik!QKZSYlaE\"deVc1$3[9(XVeFJIG0T,9**@'AVXJZ2Db$%'!,$a\n+\n+e+d2+8SES`Z&RD1(C`m,VlM*Aj)cP#M@ZlJI#Djp(U28`fl)VL9dKY+IXeFM!HRJ\n+\n+MVc0#YCpj6@!,M0VrHYh,CMQN!FBjl1ZVEPhjaCK)``\"6,6JiU@@ekMjdmEEPI@M\n+\n+3DpXKj3pi+f`LFFpIUPrF058)N4X)f4ZQ*P5c1[&!pGhC4i@Ue2BCE\"bRL&haLRk\n+\n+Thb#ZUK&ZK-Kc9k4Z-[QKhdaf&1KhN!#*#IdZ-XfJhdPQ)I6l#![SYjD'HXp$hdA\n+\n+f$1LhNlN-r4DbV8$I8iS[RSEqj#URqY@$9b3dJG1XG))%khUHJMX,Vh896Z%\"I%B\n+\n+PFK1MejpP2[@,$LpbTe[Q%h#[hhai0BBHF+r-MrTeL9G6k!!IKHa1rmf2qMf,9c6\n+\n+d)%I[5Hq$1hVVq60(`H@-9fb&cfkb$BBDc1-Ck@@#jrVH%0cXH$@cIK[C#F&2Q9X\n+\n+[qpl(HTpEQ9F`KqVA3&iYS3Pl6#ARpIXMVpCP6[+ma`PkbJPkbJPkbJPkbJPkbJP\n+\n+kbJPkbJPkbJPk1MHKTlbJTlbJpqGlF2RNe4CD`1XDTfUZEYjDHE@[F0T$,KbK\"Vc\n+\n+mA!9AAPiGS3Qjm[HQi+l-LraVj'p1i3&mcNKce1@eZ4pFX(PY@1(66rD18)Im\"eF\n+\n+YAJ1K#AYcK92peXpVBfM#AZAIKi*r&r$U$\"h)dkhp2[JI!kp0S3GjhdZZV))A!43\n+\n+jH4kk(TLQKF4pTXhHI!ITRb%hcX3KfeN#**1EI54a\"'@Z8(9Dm%D@b\"Y#qhm!N!-\n+\n+0!!PRBfaTBLda,VPM8&\"$,VN!N\"#ah3#3%!9X!!!I``#3\"2q3\"&\"56dT,38K-!3#\n+\n+TY1))Uc!eD!!!@F-!N!B563#3\"2$I!*!)22J1`2KbNQaPEr+hGEX``Jk!Vpa0&eT\n+\n+RDl*eSGZ&%EEAc@iGG+hAYBDRapHZd6ETQH'lV2AbpMVJ4lN,ck0G4lMb)fcKAQi\n+\n+*AeLhm1)VRfPGM,\"Zi8pBG1%a3VYZi@m,@rM#2'iAfhjHacE,K\"[bJGYB,ZcNP&#\n+\n+\"$cqJ[fRG`SmXR'aMC-H6r-)AXTaNHE+Fj\"HkN!\"0\"R[G!H4jITB&`!(!dKX\"PZ#\n+\n+Z+PX+S(dCS&YGZI3,cN3L+P4H)V5R@D3p,54$JD\"3'!j')mhRcl%mUJ)9e2PVUaF\n+\n+j[6lNX)ll!4,jajb6UrZK!hSTX[caD`$ZIHl,pdeVm&EaLeKG-YjQB6AKT)84pF,\n+\n+kB$+55%ID`b-4QF0T19ckfSl,d['15$X-4cTr0\"2!dIR5%1j[S4JQa0,J4lT!pkc\n+\n+\"EjcQ2ZmmNDF36,1DH)X!8($N3ihbR+mcX1GC!E!0fi)+ra)rCUL`#HU&V9)ke`6\n+\n+IhTB!b&RK%B!&4fA8Ecr8+8IBcr)4Z8L+$bmVaA0$-Lr)$3+SMf0Xkh!%1L(hiM$\n+\n+H56i!P'Q(V3ZXrmCRE,f[6f'0N!\"Z$E6%fl(AqCL20Ka-#kRdjh`qA&CRACe[!5i\n+\n++PSiKjh)6PJM4H$#5%&U%HF#GqF0F$MM6fH)T68dFSQ!hQ*[\"e3hGME'TS#e`Fmq\n+\n+Sl`'0qRTZMfEcM@b8M`(hV,a,kqB4N8iZ[4Sh5b!9ddQpT9YP#5UK!NX`BDbr,\"E\n+\n+!TME)X#08Bm,*$)fP2Ci@G1bTGUbETe@@q%4QL60h[2d5)BQGX-U5,*6)q)99'NX\n+\n+bP3a1pJZTH#BC&\"!P%4'5XP`!Fm82LidDE@#h&eejC#m'cSQd\"k1C&S(CD`*\"Va\"\n+\n+S%C+TmmkE6aJ*6S3kTd8)4GS&PNjQ\"#DY1419T&!JQT+cV-0*5@'9$$5+K-58Y\"%\n+\n+N8Ea'&)q3!*!!UeBZ'qd'!&14D\",LQVJ'$qTI1DUU3$%0cAD!e9HMkl`KaGAASBj\n+\n+TJ#pMhSb5Rq0c+LJ3l3LJkD2dcrJM2Q%3Kh&mZL-JR(&m+L$L-)j29b,%B4br8)j\n+\n+X!Y$j4ZUh`)[eI!A!R(d!4AHG`LH[d[f@re6*b2mAI`)H5F0aI+2XYq2iC)+N`6M\n+\n+qC$b5\"Z2ij,N%KHI*24K!$k@Plm*Hm'Rd8-bci0h@*rK6m%JDM[-[aZ1Nhq+IKNH\n+\n+UJA&mE-V&'KM(2a129!2Mq2,5(2qIrSHmNfTSR2rTH+3D'XHRfL81irM8FE,Ep4r\n+\n+eTUeM[5Ra8bilkJJ6f!)lF0e(0'p*Cke+2Nq9ccEjh#UIZq6c&[RmM(3ZV*!!cL0\n+\n+k&5l\"Jp4$Ilc)-m$9BDMqeV0m$l6LhM(EAX9A,10lG,aR)2GNb6Sm29&b0@CfmMd\n+\n+&Mr!pHLh'hX&p\"qiPVV#h)jIcaN(YAHVY!-im,lH&lp&Fc$pX!KD$+,qKqbMQh\",\n+\n+@BjDAX[M-KFF0&bH!le%r'GC@E`LVXP9mKXdeG)3QcED[U18Vq4jY2c-fD8XFl$a\n+\n+Jb0pEdXPRCYXVR!e1c(f%qF`GKAUQcPT3T6E-YjCF2GYHhq#[aqa0'*p@XJl4r*8\n+\n+qM(Fa(e1(MAb2DUZDVTq-SD2mJ+kFAj*ldAQmX-KFQf\"C5i,E1fA&P2jHj`!8*c4\n+\n+Cbq,eU+LUqmriLrQ-H$8\"RJ(GXC,YKXYCKk(M!EcN!3MV-HG3b@DB@MEAd\"P5,9[\n+\n+2CjDYplkH1ckr$1D5aNf'jH[,p0ehXaPCKe@(eI0#11SC',UQT)X9K3qD(G8hK#c\n+\n+C@GQUfADhU*AQPE#2X\"A&i-9KaAUdDe$\"bpQU)@mfJNfL,U61YQ4RBFiKFac+[hC\n+\n+Y@49Fi(Ye4UjKII9Fl[b`UM[(Ca+6ZhF[@mq`0Seer)R3*#Y$$IcK`pPc%EI6FKZ\n+\n+I`IV\"'%bLZK'Mdl!5jqQ+3J!feU'k*f(FZf(EGY@@N!!CGAmMqd9@CrDD68d'jf(\n+\n+3TlQV6AYhAEJlGh4$epjV3bSqBiDXKA!BPjeTVUYp1pI,DPfESAK1\"2eSD[B-elh\n+\n+H#\"KCEIFl0K-Um0E-CFr[,$HC6Hhc`fDr-eb-HmN5*`iSE-8)!#TL+mfKpUV\"jrc\n+\n+$X6fMXIlRYZ5'5$I94YXX-&C(`\"\"L$Dkf)VmVe*%)GZr'mh(#3i3EqlYKNKblRf*\n+\n+'9fi`h\"aV43`ejERI0DPfA\"MDB``XX)HHa#bYS3h1c!hCcPlQ0+mDh0Yr`mEU8Hk\n+\n+YrAmUXCIMj8SFBkA%6iNVCjRI%C(IMj&E3@l3G[C&a#hGId-rBQbXrT)c0e6q'2p\n+\n+eC)89`[fJmPd62,qrh\"5fBCA-$%rb1d1R5hbj`ddQ1G,60%Q1l'T#EqB1)110@)h\n+\n+%i!95M+ekEiM0HfqSHM1k9UQY&%V$jTQPB&VZFVm*4FmG\"[Acbff$#qbZ,a3IKUr\n+\n+B\"VZ2A1J-[B%elK$paa&k8Z63JaakNVNdL$c1fP%+A`QGIJ'bm6iH0ZklkX(0S\"E\n+\n+8jP*3Mb,[3pbE@&fLD'2RS@ZY1`pG\"kj1X1j#2R9*X*QX*TAMbYcVef*YX2)T6FA\n+\n+Q@D$Hf'AE5@VBGSP+2*elSqN#9T4Gc\"`I)\"SMr!P3K8hPL)Se--@E+!*#j8qBAdA\n+\n+F)f`H'*JMT!TSH@V*`'V2IZI1K@DpeEljYRXA2YJ9eU,IcfjLaVQJjXS%LTUELM'\n+\n+UNU1Q*M@HTVX(FV[-AA`QqadqFr3i9[JU81PlSB$r%d$A3iqhZfXV+KG!GjBeeU(\n+\n+[-cfI+9deX0(XqqDqeeCrEqGcqm6iUPf$i$#AQd`B@p0rSjJ6NR2d'hX'fX5-\"MQ\n+\n+MU,pRS%(-F-NCDZeUk[$*BA*h$2XG9RaZHj-D6bq3!1YJC6AD61@QEFZ@lXi09,[\n+\n+#3r`40LMRE\"V0'C!!FecYKJh1Q(D[`hN%90BLbX@@Y!c8C8j3QmY!ApD)[GhVGTJ\n+\n+**CcApF6MTA!ZjkemqUrh9AKG,PI[cVeVI+q#h6`$QIm$kKcXmZ\"@c&ph+[pbaRf\n+\n++-2[6I1-)JqV1YQR9UpZ-&Cd9Uc'6i5P6JCdV6\"8c-TKV%$1eQ*@af2(L22GJCe\"\n+\n+VaTDFcfaEffcXh1Pef-$Pm$Vic)0VQmqbL$(+mRVQJpGcr8kVcZZakIJ-9F5\"VJ2\n+\n+A)XVacTfpDfd&ZhSY\"9l2XleH6rpD3Epa6E1D10FlQJjH!G34SPGS&qM3*fC3Pe2\n+\n+L`2L%lVY,CV!*T39qcpXH[fHHVQRU'%UAhk2&Qk`VKaD[,i2ZHk`cX2[6K&iQRrQ\n+\n+lbPXmS@QX)1Y!&RH`da\"Y\"8BfPYDc4GPC#3lV4AhlG+E(2&HTGaMM!VD)&65CaPL\n+\n+Dr4lQB&J09`k9kE(,mhf[0f[T[[2#[mfpH2-6*6k4bk,U5Z`kcd%Ia$UcfEZ2Z!G\n+\n+1&'%PEF2B1aKl$'0hBH`R',X1BjX`pP1-h6AD-aHa8TJD0Z\"T@[KdIJ$5L*0!R+1\n+\n+)NmCi#mDEj(J5i`fS4KaV[49[Y[ASjjGJCfSIkdaR)f+)e-#cLpMMH4iTJQFE+B$\n+\n+RFiN4RXfXNFpBZGXAc[3QM,G2Yh*CMh@3!(q8lFE6#ID-P'YZ\"AefKT9M99N2Re%\n+\n+Z5UJ[cKd0UjR$Y@%N5eQr[bVdDANH1X3[2[#XjcJ0%Se1!jKa'U#f[M%BE`p&`TC\n+\n+@-mfEF*1J\"\"c`J'Sc4b0!`0Q1cH9X!e(3aCl!)H`k4qIhpfYS1)*',+EMMLJR'JM\n+\n+*XAVRp4,L3*6EFHJLENI+bThcfZ@BBX$BV8U1Sr-@+@iljX&F'M+D6*J-'5#(%1k\n+\n+[1&EhlT'(\"@L3!%(&RA-a6V0,2#9X9%3D8*&8fT'k`V(k5V),NCZX$kh*MY@GDYV\n+\n+4Y-8%c[bAlh!l-U6&69c*e@N4Mj-C)C2d+XbiMLZjUSJ3--Aq8HQ-$[R0RcMaPa8\n+\n+e&lLqlpUj[TGS[iMVqri'VZr9AUl[KhZi[J-YA0r\"GUl[d&eFhq'YA0rr0h*pEml\n+\n+RqYlHa2Ap\"212)[Ba!pGh2-6e$Gc+p3dqbr80[FMe`hbZAjA&I4IA2aN0'##DQ-I\n+\n+F0B%8$M1bX*!!6V&dUi!$KD&N2-DNDAZFBic&F2BrKF2r6-!j%\"D+4)8c'q,aD,f\n+\n+3!-3j51B9SJP@RdlLA(j+(8X++A@L25E3BD9ki@,HV9l@i1F0$6KDbP$RC(bL'2*\n+\n+%ikP8)(QCZL15MXe30%\"dDAVbI)DMURqBCV&i5b4dfDrbrk!LN!!@@#SGL#9B+*j\n+\n+N3JH#Y3HLV#@5r\"fhhq@IS5Jp9LM&BLQF6+PSMTk2cbS%9c)KQ@5a90K#Sf4N5PN\n+\n+S5M[3da4hiQK)k+XiA(ND$YpSYSe-m)LIZ,6N5rL%!p$M\"e)Z2G@JJJ8FXU,((EM\n+\n+pQ)@$C4*&(*ZN6`SqKSGP)q02Q+F@[iqA@RaFJFBHbCM4qfMF%h!%89`D('LN6e`\n+\n+k'KDkIh4i5)XM8r4*4)JcM9hKZ+)%Kcj2Rl4%aj+pAcSALTmN,qQmF&6[3Z`$k*0\n+\n+%H%M18RJEF-b22R&0qM&+6,@P[&-a!BIik*1U!BGKe64B611lY)`iBNHI9\"S+Ab9\n+\n+l)JjKd5HT3V25,H+!P%`9Z`rkT%9kNCS1THY!pHQ6Q&%@$8)T99L%Sfhd5H*hI$J\n+\n+64C28Y,C`Djl#m$6b!XGfTmrR*X8$d@L`Y6QkdK+%4i(E8[b59GP&,\"cqQPC3ih4\n+\n+MlA''N6k&X1iVfl4IfC%6%hNG3kaD8[4Nmd+LGcpXR+[Xb-XNFZZYEkLS`Q4G+Yd\n+\n+5L413!'S-T`$1NR'U9P55`+R)+U%aM8!K9-\"b-+[Xk$GR5FTkh)hN*rJB5@-L'EP\n+\n+%j(6IK+GdbSlH-e9\"XT!!TkM$335*3-%BFqd`miD+#P4)M`VKJ,5STAS-5DFJ,A9\n+\n+lRF6mdQ\"V)#Q+K-c,[YUNl&M9XNEZ@PkXmY(k8'eCj+P3G[5T%69*)e+cY5@CqV\"\n+\n+#$%SP0969B)9`fR3N*L#-jAfF#50kqURL8%pU-)M3+FmipZBILqkTH!E9YJip)aj\n+\n+%`mKhi\"GMeDhkeqSZq1IU*VIi[,SeRcM3\"dM$M['C$j!!BhcZ!m11mCN2&2k,$aK\n+\n+qi32[Hr5%Rh[d,hX-I&T(k6&F2UIBBc4(!m'9d93k(d+2NBr*-djj`D*SpBJAZ,f\n+\n+9j!86F'3iZ$+9LDAqShqJf[jh,cLPbr2V[SPKZ8BUA*j'UT'@jR\"M,2UIAFerUC*\n+\n+hbU&Hqqk24KaUB492qKV`$C4!&+Z\"V#$rQ\"GJ24rmKPrCa6X4KAZ0c$d@5+lmTal\n+\n+hVejS(qNI[*91V#iSP&p#b,2@2paR1A6E52mJe6FBBMJ1dGJL*2+9p3qIhj!![Bp\n+\n+M('C8fB\"h)XK)5,I&%TpfThIZ`BHa&(9Vm2+9kL#QA,kQIZdYiIaLYrARRVV2f2q\n+\n+YNG[k'UGr%8DeBN-EK0EmEAlarTd(p5,rIHIa&j&hIpETLXk#R@jbC@-b,9jkj$[\n+\n+SG20dc3jaep#MG,*Rm*9,kClGd#jFfLM2Qq@TmibVrRcNcU2@95h1CX5Efl\"&%5r\n+\n+8mURGV@U5ZdHGS,k4EYRemG4[EPCrFjZ4PqYQYFV$Li`LB4cI%5Ak4CIabTc4cV5\n+\n+Z`5pfTSPdXM(B'Xb,d*RQlCVl-6rbfNK(iUpddhemB9))4J14@\"k%hM42efh'efl\n+\n+%*i192U1qBE',qSa81Y2F(%qfjbIV-mbRlM2Dk!QiiGN-X@CeBXhQjHJG2R%#l)P\n+\n+%*m$r!\"'46R)DGS+2k[XNTp(qiGGq@r81$FI)IYZ`[)lZM!cTba)YbQKh2VHq(T'\n+\n+iYATPahXMf583L9i#-b!5'SA3JP$LMk5FV\"eL5P&e,)!2AM(fqq[&rAqqJEX3ZJ0\n+\n+4GUAcq1#I[$MlrpXrj3jb$ZiY+2BkkdRM@qKR3r\"mcb,mia%m2lM89dZ[Vqh!-,f\n+\n+QqNbpVjjZ29qJCq04M`2d!b+N'UT5MqGLqX832%q[Aej$mA2Gr%)2D,J,T!VQVUK\n+\n+`%6jhAB9V+HAI4,rjJHFl+Pb,m4eQEZZ5@KrPp5aF@N9GqC2+ql1S&YkPdTmG6Gr\n+\n+!qEV`09U+&4c&223NLQNk-DpALZNdR1mDqVXNM'QAB`crlBKL%mp(M*G\"*FCZ`&J\n+\n+DZ&cZG*Ki-f,J@mmLMhX`*R29E-FB[Qe,XDNr4DlPFZc[1GrDKlkqQYkKeBBaYUl\n+\n+YEqK(@E3aM+N[HKM14ThU%2X*Hb(-`McNHXhpB\"3j2BDaPJB6I!Ne%&qEaD`r`V`\n+\n+YU-G\"k\"3ar)MaKKaEKl'$NQC6hd1-Lq4B$Q0G-XB+e-BRajCJ,+'*V3bd4NrqAp,\n+\n+B[bJT[kddmXG*R(e#AIa5)9RRT[cr!`!!$3!*Cf0XD@)Y-LkjBe\"33bkj!*!3qL)\n+\n+!N\"!0\"J!!,h3!N!6rN!438Np+5d&)6!%!UE6L#+X`0A!!!#*k!*!'$d%!N!43[J#\n+\n+3#1j\"$F$iCXbcEQ9ffFS2dS@*jbZl63NYVcACZY$0##1XPDZ$V[@ke[$dmVQ6K5h\n+\n+FYGEmE+(Rmc@246PGf0D9hF)@VNAi`VhS`KGM(GQA+lmmdfiI)f`c`Tq`63P23V[\n+\n+Y`VEH`KHqX)9f(@(E*!Zrf-)@IZi)AhKXi3[E,M3j*432\"&!HrHaD@&$M#f(,qq3\n+\n+@XL1hN!$\"3Rk6AcKCb%+1%di@J&@\"\"TeG+a&(42abSQ*m9@@VL(4[%29TUPEGj%S\n+\n+NfN09'd1a&\"q0T8,*F(-`0#85E)pZZ-eZrEB+Z[80G6A,A6ir2'5jYd$i*mlPdrI\n+\n+-@8-1XA6I6r6dUG[h&cAjUSAPI(dbhQEPDb0*+mqX6fN-*U1*9$3@'8GN$c0%(%0\n+\n+GelfTH&Fd4Q0)jLrR%MNc2aM&pcf8d``Y,Ak!B(cHb*GQH1E2Phb'JLQq0Yi5)P*\n+\n+IZ&DMccNrDX`mDiN1BLbSE&MC!)B+3p!!(FM4Z3\"pmf##5,64Fd39&fA9Eck6N4(\n+\n+q-Kr+TK`qGQ`-&dGPAb51%'Q'J\"dB3bK$iZYMHPIm%$'QJ`j8f2l6cq5j@TmTYD&\n+\n+8Dh0,2)CCjkGqG*&J+Y5CqU@IDmIQUUrh9q!`X*4GG$59b(1#DBYLrXT3Hc`B6B4\n+\n+D3NZ)Zr'(SNLFq4ETPX+0#01J@-c9Mci&E\"ETe\"lZK'B2D682F5pVpcl#6cM0`cF\n+\n+VIh2RdI%LA6N'$6l@jXi1I@kfp+LX3395@i-*Bq1p(FdBDS-m*N)0#&FB@QXXRJV\n+\n+TqHr&d$F[UDca!YiDjchaf-C3%T1`bTUFNM26%1V@@T1GbH#dKP\"R2*d-KU#5L)D\n+\n+5FVQ)&NXr0\"XEY)Prh,6j`NN!Fk+aB(Zk*F3lDTZ$[P\"c5bMC1Arq8UD4i#5T15f\n+\n+KF$3@iP2*G)M2RB8&#LRFh0iTXfaMT'5S@aDD8))aK6DZ*\"9[2BV(P+51c4hG,L+\n+\n+c53S*k44Xa8Acmd49U9R$Xk-p6,4P'e,Rh4bZH3\"e6\"(G$Pjab5Ikh&MNk*3JKBH\n+\n+am`[rd,p4KJ)IdrpGAkQ!SYrdArSB+K6p(4q-kaYR%DeiK@MHTTrT+airpFpf(!c\n+\n+C6D6hMrH[fSGq[SpSi@NLdj2ApC8!q05rrM0pH5A%p,FGr*AqP!RpYPrTjl,kIr)\n+\n+Mrc0p)kiXJcl9Cb(1%'6hP`BRQ0MP'EU4U`lF@CCrSLp0(%#3!\"HAp98B52*lSGq\n+\n+&ZrfkrM3CD5@kEp'%2R+m!*ldPFM#f(9p0R-`C#rdT5&)cLr`#Kk#rMULrlIXZ[j\n+\n+d'6P$Y0N+!(Y!54rDdc&h'$\"brDYqB3l4$[hhr$0$4PE$2eXNb2ieb2fErJLM)1T\n+\n+RZCa*(rQIH68r2Xk[*I+#iKreEj!!r52r-kc1XRmYjSpI3ai@B(RaKIqI,BSqG$#\n+\n+E'MkH69X[ckB'iJEe$Qi`RhhAFB-&cq&lKKZFKRc\"-D9m50)#'Z6Fp%2+jFLffS0\n+\n+N5Tj%4@C5\"GI&cC(ZFcD,h$e838lFZmM*m-eX'F$dP%A,,mqff[SF8$&N-KPiM91\n+\n+9NF2XSa0J@f1fH(J8\"hGPCVYkTSRLJ,V55r6R486P'%J,\"U5PdFrVi(p*UM20Z#1\n+\n+AjGIGE[0r\"EdLeqdcjp[mNSplX,Y)hCYJ5aj0I@@G*jb-Gm65lHf-'iiR1d+aG!I\n+\n+M4Q-YACfKpTEfZ,40CpQLY-XkZ5B+lNFp6BS(cVppFXHLm)JE3biI%jRZ4TD29iR\n+\n+SY!R1P$QEBbjeBD*lqi'1GccMbIje'bEC1H@a56dI1a@*I@9pEqBF-qYcdaaAM`b\n+\n+5FjP9B(QLVT*e4Aa$'kXN*T*FX[j[jrbLXcJ8Me@X&Eh%AL-JTT!!Gd4B3#S&rjI\n+\n+6(0UBDSje*M'BT4+G-9BhC9*@-5jcH$[1@!XpJKl'$ZGDCHXmRb03ICB4reapCC!\n+\n+!(Mqj(\"6&rGSNfp+B@FQGKfZV'cfXb6ZLR8&V%2h\"l5[mJ8hjJPR%eT0&kPUA\"r-\n+\n+MPcHq*D-)FI[,GTp4[[$$5jiqJ&BGP+G#UkjaI6!H#dFM9NbNa28pDebXI1(,,(N\n+\n+ED'bUV!CChjPULFDCN!\"U8NG00mXke@ZV@1Ge4VY$ke-3#PpeT\"PAmJT`\"+9)V,N\n+\n+pTl6IHLkVI,'RZ6PAIkpR2HXM[+GCRdK'0dVZpqGr6kpmXC'CT5KCd3'NL33K%LA\n+\n+eT(2pQ21Q5[3dR+GDX116UUkC9$)S5UXm2KGcINq`Y6NTP421bhiMS(ba5j&Vj+N\n+\n+6f#aTQ1JNeElPhNVPLj`GVbDV%DYQDdZbmeS[j5Xpee4GLelLG+PS4`JbeUXka[&\n+\n+k0V$H4$f6H2FMHFHjNP0bI\"Sd(Fh4'2DERk5`R-%10TmaEFjrI`$I68b$mrG)kq6\n+\n+aHBBP*&LlQC0%8Xl9HQQfr9b!L@&XcMHPT*eJ*QI3,1Ibj`$iNqZ&q@YbPJ1Ha&!\n+\n+Tc3P+,rc(E-IjIaGE%9QEH@4l\"'92bccba&FiN!#)&l6[jHikPAbI*GrYmVe9[[I\n+\n+)phhbr86Z2U8bGeIk!)'b%TGV)mAiNDCMGeGHc9GI%IUT&GqZ\"BjUSA+ed+mA[-2\n+\n+LXC)(FAZaC\"ZB'D&IrCc3Ep!\"HarI&r!YF8GmAD,SLj2'YmVA4CaPLEK2k0IH*6a\n+\n+V*Vk$fS9GI4I\"H5aL!-[(@%*ka9$HA3N5qMA()VUDA4&9YPT)mi[cZX*6&cM@eJP\n+\n+93VpZN!!h\"R3P6RiqmI$[+mN)k3@15PH6#pcRH,qPD`T@&9NVUY3'[UeNf`)(%Um\n+\n+4l0h!LdSHK&T$P4pi$qrR04'Md+mkS'(0E3aI&)EejF*+mAAAd\"56T5l\"Ckd*lZ6\n+\n+dYG-(\"ec$9*M3CUehlN4&9Aer+0`PT+AR#H3GeRp3FMK[%pq9er8Y223JLKM!HEY\n+\n+N,mdU@jbA#DY@la65UhIkhK'(PTE4BPEM30kDR@@'[UIiiUc6TNIh[\"CTp`k2hPr\n+\n+5`jXLjbc1QSI$eZbmE28#KdHUPIB[)RkQV95-AKqV@,pZ+bUiLHmHp@@M''(eB8f\n+\n+f*6X2R,FYF5Vrc4ePeE6)rfDaf,5cCM&h@d69*`VTa,5qikYhmZK0Ble`+6c9aU-\n+\n+'$C(cf9ZKQl&q68LMIi$490Bh%PU%6PbL0f'aB1Hl9(X5aT1l$Kj@l3YE82GhXer\n+\n+JkbdqLcQ3!1Fk6iB8YmemmZL+iq,&A6dRGi493YT#@5[6iERXA%YphBr&!El1[CF\n+\n++&dD44l1b0lLIpNA*b0Ie[@mhS`,[c9hpkT&bXm8F@aUa0,JLKIL@V(3KLJm!)8*\n+\n+&l+8LDUmD1G8`KVdmJ3fHfLH1XVUTHZhcb&J6TE``hq4Z-c@i`ef*B0pah)HB(K3\n+\n+H'HbMU6,f$BBChH*)C%0(+c3dM1IjL9Re`SV`bmEQ#NIi'&Lk[$Dk84behl,DCHN\n+\n+H16RiF'r0K2I@`Gr,ZCIaFJ8(9XVm+EKbPreGN!$mr6@mUF84qbhVQ,I8i-1$d1L\n+\n+YqD*,(#erAVJEVY!Kh&Y92c(6UfI+c4%lZQ4ZC'U$+c`cjjFl(c$,5(pJUS`F$5#\n+\n+EZE0`h)YZC!jHBaAMZcmFjCGm1&U$M9+Ne&j+T4(,h&)bVh&lrSC-Tmk6jY8epT%\n+\n++KrZQ`[0dKhfNlm)+9rKGp,K6bKpRq*MNS4mHqT0LLL3I0lp35RH%Cbk#'pph)mE\n+\n+6[h0S,fP#'NXTD5D86d2hbhap`Y5EHAZ(lFME$j!!1d1fSr\"6Rb5lf@C@BB2jcJl\n+\n+d\"Pmq29\"SQ8HDhKll%9B0qe'T%Lq*l`B@mDEXREcc)d9M9,K%USLj(+VSJHQqK)Q\n+\n+BUR$*mLCd,r\",+)phKPA01S'YCFRQb(lRkmXX\"TYMlpHHARDS*k*$hLm)m'`$`C@\n+\n+&''S*&!*9bDJjS-&YYQGB2'VT%G,Cl`MTLd2Sm'j5'3C),I`f)I@3!2%1,)HU+UJ\n+\n+[bkq[4qlc\"L&GfMhFDr(rrZQrf[,p)kG15hMhd4&b@XV0CQ\"E\"aq41''CBqMY(fk\n+\n+6'%db`c6B2p`N-G`b3k2E`LC4PM$L%f0jKiiA$`FdZ,h'8JHGYGjZ,MFIA,hUZ$K\n+\n+Fiik-#KIi%CQcHi)c,(2FXEaGVJlG5DIV!UPX*XE&5&T'QM)AD5aPC#KEMpRZ(3F\n+\n+@d#@FcrhLGd[T9XjApG)IRkldZGhZJ5-RYrVI*)HP'-lr3A8KTMck#[J2AZG[`VV\n+\n+Jha3@r)a[((G3NfNVUYR5CUc-9'i\"NmFYABR*P@C*M$5iH4*6\"eEDLVfl+\"l+\"(8\n+\n+@M14#qZ$f$FE-%Cr66QkRcbQN$fhIF,09`KM,jee+2Zp$4fakRpHZ&p+X)mlfR0d\n+\n+\"PD(-NB(YG[A4!D[DjheP`1FGh\"ibp'lGS''H'jf\"FrF4Q`L4&ES+2A+LQ%dj*8l\n+\n+JqAe2P46cqDAU\"Zq2[3hH*IV!V%Q9RJD[$Y[IcD0hlLbM[MffBNarf[!E,'IqV1S\n+\n+aElL)9fHGF2%%2`0UDi(dPMEbbl2c%Kck4I2iE0i!RV[80kDaL&r1U`2Q5CH@\"Lr\n+\n+[j0%0QdI,$*Mbr0mIb&Vl[VlL6mAA(hfaa#pj@9j6KDPc$R)3I@Chp&h`$&mbSC-\n+\n+1!RXIf22!RJ6fYm!H!,BEf0m\"Hh*LCMEaT63VNSGE8@5Q-%`Tk#5JFa%k+H!Y`!-\n+\n+bRJ6HK'V%dHZYf,SBN!$R'c'C1LBRd`93$,0Ui1jQlR&I`LU#Zje9!2GEQ52F,Ia\n+\n+k)@hM(PmfejF`2MlEaQ@pYK(Kfraah#la*h*F5bXCXX8fMUr1HS@dXLKKFl&i-D,\n+\n+KRHjGikbVar'Y9la$l2RB6pmR,LdS'+0CVLaC,H`\"dT@r%Z!F2cScr3P3LVMhU0$\n+\n+RDQ6lXmIBIJ6h2FZaT-(pd#Tr(GX$[`!BEfIS4+1rNEepHBe0*1LCXfaR!QFkYKh\n+\n+\"[C!!E89`RpfiTTEKYhU%C9l5FSYb1eVZ[NShdqFHU(5[B[`[Xmd%lNp8ZZr%``V\n+\n+Z`-Sk2q2e,eY9c6DeamCH2MPq\"\"hf),AJ0Z`'mAk4BHU,`2\"fN@(D$$6B3eKJHLe\n+\n+ijh+BEJhfCmrNX\"X@BR0iMP35pJI3b\"!RLM2TKUm#`jj4mR%B@%X1Qrhh`&k8X3q\n+\n+\"I82'4(M5h,f&[F[64H#l[1e2f\"XKA3FdhPMh,0f#,XX(PR*-SARJ23cXC6*+rTj\n+\n+($GBeQHQ,U+Ad,JkXA`G[(hJpP*%d'S#PC1a\"B'rNDPDX\"RC'a[6!hT)eeX&I3XE\n+\n+f-%rDMYpUEQfrmLafmJQYmYTfr+%XjmL[Mpm65YCl'2rr!!d!#'GMG'9cG#kjZ@0\n+\n+38%-ZZ3#3%%0D!*!3(m-!!%+&!*!%rj!%8&*25NY\"5%`\"!+QdiJLV-$9B!!\"5l3#\n+\n+3\"K+K!*!%$I3!N!Me\"!i!pCQCc1abX2*Ef-,&mj8EA@KjV4fRQfkf--,fZP@[Eld\n+\n+Z$dq2VmN'A5Bp-hbAY9lHAJFXfQdl+AG,Z2)ME*&GEJRrA-libQIDl@-,fic`*fc\n+\n+6K5HKhAEKE`YIq-)mEQiRK(pXXmb@iapGq-+kKCfFELT3q1c,IZ&ZXPf1@pl#b%)\n+\n+ffjdZC,)F@FK#&m,)B+r,!D4[CPq-FBbaqZ@-eH&@A,@%-I9,M(@V+THFE3i'I@,\n+\n+PFV%p`R[E)f,)lA5*'SmV)SBMaKm`\"H(DkkSAQQdeb1%*lP8%I\"Kcj(3rX&H6m0M\n+\n+IZTkaqjrj`UCT$PZ9X*!!V`m&fSamV5GNj#ReR!CAb\"Z-H0XpDBqF`ePa(%eGaiT\n+\n+)S-2EcP+HcTr1B+bXmm9Kh'q$6Mf`X[$\"KF4R$RhYV2*CXk3m49H%V`fdL)`T\"cl\n+\n+J+-2j13Fpcq@-E8&E8'&IE%H%!Ne3,pZF#1HDf2Hf\"\"Q,&l1('*Yr8%EphJ1GXSF\n+\n+r%JrNr)3rGBV*(aq@mf,a)FC8Kq$ER2+`6KCr)B9h0\"r'+0,%0Xm[rQdqSqFB2cQ\n+\n+eBU69f4*S4krcbhc8LClZG$iIR'*cIAh0I\"abUXM3iXkAEq$(ilQ,49r!j3f+,H)\n+\n+maNhp56c112ejNK@\"P6JkPXIB&fjK8aKcR!drZX6iG+jqq&li[TdQiqM4U(!CR@&\n+\n+rGU+(,&FBA8QAdZJ+kKT@q*eSAPdm1Mm9!Sj'C\"RE!a%aQhqm(IAaK-)B'-FE!ha\n+\n+jS(fj'%,(Uc#'FK,*f-@9@FC3113DEaI$J@M)*3)Pk\"9$i'!+Qm`pccf[0,(*#J2\n+\n+h%ZcNS8*JE#k(6ij38,[0q$[cVaRB\"FIjhRDA,pSLmUCDTmXQ1P[%8(M@V%X))mK\n+\n+*81HhL'j[ZmK(3P'46jb,ab@$h%jI@)iU6J@&a*8bd!J5%NZ'TC%NDKY\",5%K9lA\n+\n+%%1kQ%f8Z9IE(4kQ5X*9Mq!UPK%dirih2+53-k[E(m!QELQ!-Rl#ccq$6B)6Z-I`\n+\n+FQ(52iC0Hd6f'2a&QlKPm`YDG`5GX%V)aI-*'%r+rq)3prJ`qB9260)C2f\"21i\"-\n+\n+feI!B2QRI@@I`#A[5'Ic*-1NH`dIV+GeMrFY8Q(52j8mG(mdXar#TGUKe(X1R`pq\n+\n+T1G'EYSlfTT4IFZ446jL-RfpLA2G!eYX*@kf3!1dTXPdLfkfbh5AE'fAlbB5G8j'\n+\n+`4rJkCZFXKT(SUhpj-0jKc0+KVIl1dd)2DmAG-GY8*93X&AUb\"HYJr,'#0E!H,EJ\n+\n+1NCe#Mr)KS8HMKZmGh)rJ,V\"iE\"haZ#h!9,BPYJl''HE&0`Sp@9F+$qSClfFqB9h\n+\n+h3F6FlY%JbNC43[653pSVJdcS86hQ89H[mbKL98+8Rk[YF1I00PeH*e3+2HTqAYH\n+\n+N,LMMCc%HqGX+1SASE&1&f@&'l%0mMD%M4m1VBND`e)EiiS,VCTXD(2B'40m'rl5\n+\n+#08#c9pE!hmAAm#U26ZK4E&E48%VR2LJ-CTF+Lq-[Q!rPj\"[UJRc-'14f6EKm3Rq\n+\n+[HC!!63aQaBb,eS*44IHY`T9#9\"TN-1YJpRX&fl4AmahDMZpMp-1B4i1Br38Ef*5\n+\n+LZGT1Yf,T@L'kG+hYpILK5iVBA1+i5A[CfL*0plhmp&KCF6DUCir(CadF[VkJLmr\n+\n+hl$189GrN0XCQaUTQQmSPVV*HpY33GT)apN++X4le+M\"i0Epbf\"EcSZR0GUYL,E'\n+\n+CL0P[#,$5,pp39-AQe,`b2HjB@cfAZmLMk)i,dH$ilTe,er+S69fpF0LG9mb$!l[\n+\n+R31a#i(BDla#LU\"ri@\"l9MH5GKNUFPjh[CUb%le$F&p6Y@VGPQf+Mf`$HhiaG`0F\n+\n+EE!CpNpCmJ'NLh(AkA6XZh4NrZ+jVe`eZK4!eX*L4F(JZ0X03ArHcH#pICpR!*Pl\n+\n+XK4j0L8ffh'rc-KeIere1L4i-[$eMkE2E5r8'IIXP(S2Gl*Q)Zf#a'@X,Qq&K$)b\n+\n+8&-E\"[@,S'A[+pp5)VrqCMI&KiNfa[Q3Qde9lQGE01baYqAD,Zb2SkYi*qa$K!H(\n+\n+QrQk@*rZq5ckG*6lNDIDh!N0&FHA[kK@2A1Tq5ZHFEh)rKLLeYSe0M3qAR,I8E&J\n+\n+jY+[rT[A9)lQhp[p4)R[CAjVd`eG)q5Ap59[1Ed$+lfq3!*Xb2P4bhK@8@k6rTRj\n+\n+JV+rq[$NqA2U`m\"9NK3VKAUem9mqHIDj8lbP\"PFc`j0R0lNQ*I,N$6AVCdp18*hY\n+\n+f0%'EZEh)H$fUN6,B3ica+pmIjZHp2ebp!DT9@&,)#Mf''B9-IjQPr#f@rm`\"TRV\n+\n+fXT+Kq5E,f4-2X#q@$(82A'Tf[iND,j2dTmcpQ*4$$h,S#F8M6-VMR%F+f4IGNqB\n+\n+J'pZ22,VGhpLkJDP%PD'3!+P'N!\"h!rF@[MkB[ljcr`h&frIIb#bGV(J(mUN2X4*\n+\n+pX9j4GNhmp4Y3'hcTK+D*KTP-YEkVC$Za8E*$BZ+*q*Y0FrMmf#+ql$LLcLXFCJU\n+\n+2[K5SU)%*YQ!q)e6KX1%9i!l`mjL@,h-VR'U\"@M4@E)Vpm1i&\"NfaDF-GpbrBfZ9\n+\n+43qpR0r'kZ8c&&BRN0640K&FKHr90+PMRPJr'GaLkK'MXKd,di#&8q%UQd23bTI\"\n+\n+9\"Y@$aT[+kbSUjl2Z'0pB$phR08+dF1AJHN20YhDrGZhcfjrC,IPAlKKLCBC5[4k\n+\n+q9Idh5c&Z18Dc[QH`6BT`b\"(jr6f$$LR#)NHSe0H#a(a5Q2KG+Ee$aFHh0DPJl5(\n+\n+93@8ePZK,p9Z@,YNC(kbfH)D&!Aj)MVPY*'C3MV'dDpHCrHTGCHB\"TLM1TeLdU%9\n+\n+-9@4Q+N-4da3eSVGlhF4QX!,1CRRd4iAX3Xj@qF4Il+k`@5b@hZfl9Y@m`Nb'kFM\n+\n+m(e%[4TI(rJ6aDdl'AmecRb,-rM4HPmkJZV0Y@[@eEEU+cSTV%FR$LPDJFf96T)J\n+\n+SBV95T\"T4851Qcr(ieNkAfS!@ABKZ@GfXkpaZ+bYKPM*EQ4$GZVVj(+2NSbLEp4*\n+\n+QXhjcHh'fc9U5,85T)[CflEd\"+)FkYrHZ,P(Zk$8UEGDRHfh@rY@LC[fUCKAPh&$\n+\n+@Y1rVM$T#D)9kIMCdBMTe139Pm1GfheX`RFmY90UY2l2DVI1bQkD-SR6CVHVV',Y\n+\n+QH0(D)YCpAr&dG(pClTG)CrkkmRDVHaU[M*8KLl[iXi\"f16cV#a[iKE'C33leSVV\n+\n+cA&k$1%ZK,B8aKer)+j[dSeNDl&DqM%FeA$0FT%'A9r0mEmcBIIHPIa9riGZ2&Y4\n+\n+)Z5bXVN6AH6jd%(9@BZSH+\"mmR)p+fJ,I1r!p$0mpm2dGI$I#GaYmI`rI25-pFcj\n+\n+Ib+CiY,#QH5B*Jb`#R#\"`$J)R!Rm,r%fb2`5r!f`%81ZYQ*CVS1I,dCQD4M[6f8\"\n+\n+d%aZ`,C3pl(R%#1`5BJ$fKC34E!2I+%5,Z6XAc,!&GAHH@mc&V-9$`JriRE!1mdm\n+\n+QBJfY6\"1EAXca96'V%%d15UJ[MKrdU2JbblTde+I(r2fRV)GU*0F[GKFZ'6FZ&@C\n+\n+!@&e$S`1V*BfZ3,[Ekc'f'QM#1TGaI6mfFAd[dRd&lTYa2mhe[DcQqPkGarAYVFD\n+\n+pRq[EGj!!kh[Gb2@pdFVerHebVZqYjlLqJ6bZladIehI`(Ul[(a4Fhf(J[@rMqRk\n+\n+qJHZ,jh2ph!,FAqIkPGrNqY@YA,rQDG`$A2piD5R$)dE#I+49a0+%1a6`miQp3Qa\n+\n+bq2hBFJaMcC%A-H[Lh9kI1084#2JDa\"!f3ALEk![b$C%30K$$+Rp)$+Z#lAk4M'@\n+\n+U\"BZ%FY95Keh3%Y-m5!m&aNNZUbm3$MY$+e3GhSKrHRQY-ib9%UaRb2XM&r&Bb[Q\n+\n+$#1m2Y(MG+riPr[FUR\"'4$dHFrL$[$S4iX30Jl8iIhq)0r5khhm926M)p@LJ6T9)\n+\n+i'P,4l,[)jI1kP[&L+-6l`aiMMHaaP!k@(kR(!$5jIF64)2HV9c\"fkm2Bb8M[NA,\n+\n+5*ahe$KKB9T9'TSPBKI4**`H4UR2Kk*+M&9J[`FHC*Q&NUD#pVUA83F[45Jadk'0\n+\n+F3Yf1$dpTM65,Hfl&AGM3!#1U'a&eQabGKF82I&eA%c-D$%HjjT%\"U4TMFAb*[&A\n+\n+h)@)HETXFRBf&$h`V0NVHj1U3!,`K#cY(qL511H*j`3MI14L%iN0H')LU%pY@kEb\n+\n+e@+I!ap@!&jDr$K6[395bNR+a,%&ISM6!LST@Uj*V5MUX3Y#A)\"$4+kM@NKY`il$\n+\n+S30pF$R`T#q@S*(BHeKMSieHp#Flf)`,0AQTaDcb@&2)PHQQ)5fb5Xdb1cXF+!Vj\n+\n+N8DB2,Ic5f4Kjid'T!M!XRlE0,$48%8&NcjVeLhiPLG[pfVbedR#BF'qX0CFl+(-\n+\n+SP#2N$)DCki1*FLTMEYAMF%qMfLlECUkT+5IZR$kIUlACYmcS)YhC12(&iZ3YB9'\n+\n+@5Q5*+ZHdkID)X$BCAmp+hXKTKT6AHm#U3r4C*hSQB(BrU*ZE[*&EJ[hH\"NF&f1H\n+\n+b`j%@Ei\"`&+-i5TRYhSDUbbZ*lE\"hTGJB!9#%@0JA5pj3Yh-5l&V,'fQFRq0a03C\n+\n+$hZ956TYb(mp1hP#k+8NN)bQBbZ-#L*FT4c0ATc*h9&5!)3dB`XSCTF08SdMC5D3\n+\n+Pj6BcCAk9Up8CNNK#jN9IDNVH8!QCSr)k39+0G(N`aFD&eSVN$99-XdNF%CZY,D(\n+\n+`\"a@L69D5SkS@&F+T)ekr#\"MM-CcF0*pfUMM`5Hd-*A450pjlk`mPT8VU\"Y9h0R3\n+\n+Mi#,4b)#J'D-9V[Mh#PIqZX**-8jAH0BrUp\"aT*4UR0)#8Sh6@T!!8Se6@T!!maX\n+\n+Yd(kN\"FGd1[HIG2TA[3DH,8Mf'TBDXp4V02ZFVQ8q2,U3!#'KemM%T\"XRp@#KVcU\n+\n+Y\"q@f5Y+$A#aMZCD&Srj`4S3qiL3hckljPY445pa8@+b09#FYcCj'[bpc@BGcr'Q\n+\n+!%69iq@)m[C*8URU(RG4!'ib%'PfYVS`*8j,-6\"h[aReIXbG[D8k5c,e@cYh[$#h\n+\n+lT)pilFFr65[(JLU\"+N',p`QF2Y40KM[Pq2-plHN1e&CT4R@a((P61@0C\"rU4'Q`\n+\n+blVmMh8FNDTaTr9MRD@`4JjR-qSM6-pGM1,T84T8160L3!*%BDI-(2jh'hIh8YR5\n+\n+r8BZ42Y@\"2cR5GhfQ,m$+0,B(FZ(*qFCchdR[JG5Dl3[K98[0EFBhc6Jf!k'Hj$p\n+\n+R)(rUIIG)ebZT#lVHd,,'8%3DJQ5UfdlEP\"@LKiU5A8P9!ff@U2hH-(@biF`FQ[(\n+\n+KV+6++NJeiI9JS(a#A@K@FPTGe,p@Pj4QR&)AdSc6kT,5M&2U3T15dqU5QT4mULl\n+\n+T5FPrl#eaeipXJ`L95k4YN!\"fmDV'M(FlXp`hrMJpBDZc9%XlCB(Q0M6#dJJhdpT\n+\n+%2bZdFd30'KTT[d-6#2rA22prCQFCZHEjar[pNj2C69PYp)K@DM)V+8'fT!3C%RU\n+\n+0$!Sc%%F&0K8NII&jQb@NScQPp1@%DKc0DD4,rDbV-ccd@PV(lCAPY$H4%a*G2UI\n+\n+ARl'MdM)(c3+5MpDF8)f1Rr4*kNc)faB*9I4DMcVDlZfJPej1UXfAEck8RMde1\"C\n+\n+Ci0@')p(QjN#S(A*Mr%a[J*8\"E)T3G!%pL5YhHBl+\"RVj4bhpa)5,Y@G#d)*M[FH\n+\n+rp@3IGap(N9*kF+TlbrUSQrlA5IIaD[aidXeYj&CVNMH83&CM+!&9RaC+%&Q\"[`%\n+\n+!PM5C'9(,)ph(*fUTr9!YMqT9DV2iP&iGfErj4+r'r8D[mMkHFibb02iMPNjf1PA\n+\n+[d(\"$VLh(CI8d(p1LX&VN*cJbP(8k[pfF2kE#ZPqTX(51-%LC%ZXU[a22)[*i8[E\n+\n+rZJ[cIcUGL4G#pHMBk,e2kCF0VX,2PP#E5Iik[#T1$qmHrqXJc[6'Fa2`XLUETTM\n+\n+$*YV-$D3cYp12%m#qEb(qhJ$feL8eGE5PqJMF0!YqXU&'QZAY39+9b(8[r8`\"-MX\n+\n+Ah$6![T!!ITF!pTb'bfV*EbNA&PMaKL[H#UA+i@kTX\"!qGeH&C3R&EkCI&X\"$k6d\n+\n+9PN9@f#m[VUY\"R%+aB%N90%@4PhahPUZj([c3IkY-$A%eUr''+[Q8\"m(LQS3[kcE\n+\n+1G+!PiF[1j8b6mBiYqG4I![EZK'rFji\"Ab\"55leDmdYV+9*,[$[MHa&2kj,XIH(K\n+\n+90KkIa-Ep'I$!Tj5(&h&2b4cN`,G2pSf$$kqZ5Vi*m(hh+pHLCV(B#pqMEAp*2`L\n+\n+K$S-ce482X[1!F4&mDd`jE#EL`-(e-DD6q,X(FCd12IXm1+#IdU#-2SFi1q)HB*d\n+\n+54KI`ANVie'C`8jVJFZTNa%85A%ip'ebqP1\"bkZr$jj-acJ0'8-Di!,i@'@-Q-2E\n+\n+*q68KTiMXZ`ja[9RqCFj@hp%rG\"RpQjINMlqNrpQ&-qA@\"ki53rAP&2rr!!!0$3p\n+\n+YGbpRBh4PFh3Z0MK,,VN!N\"\"453#3%#pd!!\"+8`#3\"2q3\"%e08&*0680$!3#V,jH\n+\n+ZUc!jB!!!\"M%!!\"R%!!!\"V3!!\"E(*MaZS!*!'[VXM4!iL+Pj0j%)PIdhl9fbRBC!\n+\n+!DR1(JAFp3hUJ2KNcZ@(k&LeHlIYc*cMM1X2GRCf\"!*`N(81C&iAQNTm4&Ifii1\"\n+\n+EpGII4h6#PiP+'R-jb[e$&IeM12rA3hh-XBk+D2XK9#@U!P9e!@eRU22XRT!!%ar\n+\n+%6jaP3[FjFKhiIjQ@hidE$&25cAm$`-IrIXai*1U*jZd88q%pXX1%F$M`RNJbAQS\n+\n+ih%%N0J*@A\"\"6p[pE#%1,cL9X%K8j[Z%i38$F)*'R%8!QpTQQT&06TCMf4amme9+\n+\n+jii[1iC(HE43E%aa#QlrCjZ4[GSL(8*!!e8D-E\"#r6LR@&GN3aF6F'028K*cdTGk\n+\n+aT$fkUhhK6F,P(Tj11!CFTLJ+QQSXDINp,M$RL-+Cm9q6j\"VK+Hr'rhrjXB16b1@\n+\n+iec&AC&Z,)bAP)A[QZNkT`brFF9bj0@L(b*(4H3)$i*YCbh9`YK90aj%$0a!Gm&!\n+\n+,de[B3!XlC'%$\"-Eme,D0'(Z229-8DlB`9Q$FC!Y6@9L'KA%@PQm[\")V0YM#PKBP\n+\n+$[mI#m!L#i#MfjAH50i4eE512Q3bj@@90I4m!N!--!'XcXfpJlh2Ij$4lRaZHF-P\n+\n+a`Tr-D)4&@%FjIAiV9hi5rZ3i@3NqRhV5`hI'm8m[3MNjENHi%AjN`!NMR\"`rbB$\n+\n+bTrc)FA,m$%r*F51Fm*03FTa`FTa`-Q#%%hlN'4R`Pa`RA(+FF+mMamRa)mq2m$2\n+\n+#bB!#GjN8B'@Y6-+0iUpN*rl)-F)*2m)*8[#%!j-9H\"9SN!!()1QkKK#+`Hm@K$S\n+\n+HJ&m,rN[#E`hmIJLEJ,q0bk)PQTCS@&q4J@q@4d\"9U,FU)md-(0Yrf-'kLSC3Ech\n+\n+QTZ6PDfM!,6kXTJh48\"8c3%-B$Af2ZR8CG9Ip2$-35k-p#&9[4Zd)$4`EE%%G46!\n+\n+,R0\"9-23T99CN34j4,-#2%@HJ4P(6T'aDQa#N[iMDX5G2a3J5j8hqU`G8AI)J-HU\n+\n+[2pc+8DXTel3Q5K1DDDe`rC'MeMLS#5QV5\"2QC-jFKV@(Y,XiDUf$'TI6Q941+fY\n+\n+NIrEXmabeMLSdTZC&6Ae8m48krm8h(,@HFXdUSU`BRMk!q[lRHBlD3,RQ4#QENT@\n+\n+#\"cXRI2X+4ie6jif)dMfM+mkEUadrc9%E(G5'h+TKlGFqRHHS#3He,LFDrPe`h($\n+\n+QCBlDa(3e*P+'jG[\"RP9riDM0,PI9V\"`8d09SikJYP'YH1C5kHVfHlZ'SDkKIpI4\n+\n+i+LIkaJ28)bpbe,88e9!N694cCG6ZNqFjkMUUN!\"T6DE6ZT(h&AViKGmikRVU\"NX\n+\n+TAdR(H9q1FY4@bY@D,XL9SfF2rY6286HiPp,*+'9G,aJIFG50p#Uce14Gj3Y'd81\n+\n+Ek\"h5cFV&)blrQ+1f8B8b8UTJU&0#eN-9cVh+8GXGe*U-j!-kU)P6p4b9*UB'dj*\n+\n+PCDb-E#IIrF$K4qBkCkfIRK)eFi@ZrFEXr4ae-h@$T1I(e%`C&K,!AUi3T&L#1U`\n+\n+I'P&bCG3h(rRp#Fje+d8&50fBrKHeFp&j@4Q5M3GV$pea1eGSfk+(0$9pa80R1GF\n+\n+ZCkfce*a5FDbGI1mKMRSpifUSq482fFRj!BlD6Id+#UPkaDr(MfcMU0YGVSSeRLY\n+\n+8Z0V[F05H43q4)19lk0aM\"lL(GMKViS\"LkT1'T(MH+rPeTkZ3!*U\"!([&H8FjkLl\n+\n++0@RS306mKfX[64ZJ+`31D\"5@fGUaCaUiVRd8Y@!C+5NVP42Ef6h&a0E[S,D5e*Z\n+\n+k$e*4k[,4R\"1qUq@S0cKV-k$Hk86c@fiEqT2V*rYSlLHcfePEppip1YM9Hl2Del9\n+\n+2!&`\"@TQ,U#F1&[Z''jdelZ4b1(ZHmdimH\"0(45eR)(&!*q9f)f6q6PCX0VTUBad\n+\n+IAd$pf!@`[ik1Br'KUlR)+fakrN\"cHF(H36)2h%jb&H(+NrX0&jMF9VMIj$*$&L)\n+\n+T\"p)0cLf`Yq1%\"AXR6JQ`Yq'FKMf0GB,GdbRXPYLiZ+lq4#IBL8k`%jeJ*cV\"6R5\n+\n+#RHJ%1p%*GU)6l%3Rf)P1h%qc#+[@Y15RS-eL8qhT&\"fJcd&k4dVkK,dC'pb'AVi\n+\n+MRZjKXmB'HccD3(IrcJ8G(KYmfk)&p1R\"5Hkrqa'fKQc`$Bdfm0&Ek'dF5*Cm&25\n+\n+6E\"T+qQc(16M5i\"iI4FpKHCCb3p#-XSR6I3[1YF$(e@dVrAm(hAhGA,f#1a4fVQ`\n+\n+D)a0bM1IcX19PNiJXd-QrQrjp$rTP0Nh4$ljDEE6C0*GdfSPEQNJ$[AaI\"9dkQjE\n+\n+)\"&rjZ5PSlpQXL6c)65I42'&jkHi((6HE659pGY(F%GhJrk#CBp-AQC!!QcfG`RF\n+\n+BE0C'2GbTm18(Qh@4\"hI+cbI\"'a-fkb-2I05,Qq*VI86`ZS90Dq6\"IEUNPpZrZ6d\n+\n+IkmP@hp@`f9$5UmK,\"LjZ2dGjKIdd'pTRSrf,Re6[[[HdcbYXX0R3aK[KcVI)#mr\n+\n+A-dm\"R8jJFcLjAc2T0r!1Xr%Ph(NRKdhm\"Y1PM9qd9#9(PFc#![X)[SNKr!e@jAm\n+\n+!N!-0$3pYGbpRBh4PFh3Z8&\"$,VN!N\"!4c!#3%%+&!*!)rj!%68e38Ne33d-\"!+X\n+\n+[PkkV-$P&!!!'-3!!'Z!!!!'T!!!&bE5F%03!N!B\"fL0%$L)UANhN3L9r6IYAE+G\n+\n+KN!\"UFiH\"Gce$HU!q'61jBIV#iB$[cjhJM1X-GhH'!`%ib6Q'-Lm+c58r)bVkFF(\n+\n+\"YqU[[irS4$#9MENFjIkKL[iaR2rVS6lQ@%G&Y2d3UK*9JDUkJ,Bce(Pf6fJm&6R\n+\n+b2Z8HRJiXa'A+ir\"\"h#2TreqK*11PKX-G4'@dI[MrP@fl(cXiL9b1Haec4BbeKmP\n+\n+aeJj\"iNA$iL1d#Y1J+HR89#QQrG%86l98l[LLFhLNlhad)NaL2JK&0pZFr-d1m4!\n+\n++XYS)fcSm[diTeKAC%-A8h\"M6e)5Fp+AHXD3p1ZNm1FY%rabj$[`E!$0bi`E$P26\n+\n+rG@!p\"$aQr-JXH*CjLX,-Um9UPGj1-5VH)fY@`*(4VHaDSf,&r6CPrlq&--R1K6X\n+\n+*#r!9a`Q#\"HZ@0$hdcLR&Z$Fm-LN%a%6I)NG'j`NF&EkCY9`(CaX9iFL4(fpK!IC\n+\n+B8#c-*P,XP1dG-@D4KE%@0XR#9\"C'PcdhhF,ZXE\"3#eYVB3-&a[CDHNU\"FB-@YXI\n+\n+#PPJD!bcX5f0T(aH0)DaV'hR-C-M0+Q[Uq``!Da0l'f3fmMSr\"jhCCQZ%N3NRNdf\n+\n+14LJRP\"rPR[a@3Sqr%8D1NjAJmk5Hp2#G-Ic6Le\"1MJm)Pachb(2###I(6c*J%8k\n+\n+j%8k1RiHRj,J46[K*+$P11$P11\"P3`JNrmS`-q)!-Z'6!D6eKj2L4C`f-F$+J`(8\n+\n+Q\"D$m9QE4e,T1r\"&qK,q%%k6J#3FQ+c!qS%%HJ+LU#N)S\",rE%'S`i2Fjq\"D$ha,\n+\n+iI4qf+2P[K53BJQi)Q['&0I#IjBQL)Y4CP\"42pjcUHm,'ZSf'8'HBF--Ck@qdLS0\n+\n+b3K-d'HXH'L*+S#ZS9C93Dp(hThY##E32SH*'Y!@KRP2p0@MV!TJ\"6QM*DZUi,'%\n+\n+T+JeJ!r\"$PM03TD!SBLUKM%E&Qd60d0-c)3Z*mVDqK3&9&I13!!6eTfr[iUM&P'Y\n+\n+#%F4446G@Z(l(88YXe)LB`Z+S2TE@Pf(0!mTp(,A84Uf3!\",*H&STD'4qmZcc(,@\n+\n+-+M3XC`4&IJbl#Phql%Z1'UCF8eL3!,#@e`G3hrdd`e(,+GHd)+EL%XlQBDHLAlh\n+\n+-85ZSm`B%mB'K&HG0PBjFj+L90QTjHXf`jUXI6h28L)eDPKBdpblBE[Mm*BjDaA6\n+\n+94Z1DiGV\"R*4rj+M9$PGCAcdSS+ZfQD2@8+iCI$4qqhSpdmj4DkPIeF4)2#fiaJ2\n+\n+8Bbpbe(889F1L)XMT!QVVKFXFYBiUT\"YMLB5UC9b&(RhKCikkRVV\"`)8VDEQKZf-\n+\n+V4kfRA)f*V,4kp-cqUedFGB0c+Hf-8Y$eQ[B\"4pe)Vc*,6IQVI%eEm0!QHSG8IIA\n+\n+L@5lrN!#MEUCQhhrr8(p,Ec3@kie#4,V\"pIbK)a`9-T!!GBlk-`E@KJ84,f%LG'i\n+\n+f[T!!!'KLUKNie$XiPM(N0&lQH[KU'dGYS\"j+L['X*Sp(8hPGSl0R1'UMM9U5&&e\n+\n+!'c8b%qDSN!\"L,3rTKL6Ki3+b'A[l2CZI0G[Y06`a,LMk#PhcpFQ(1'S6pDZSCSE\n+\n+PC!&fUR[r&Uj3-eASS(Td!+F,U1H1r2)8jpT#83&5e5EZS1kBGej+JZb9Kc82h(-\n+\n+h9kKehN1+R,MPS8ZFDjZpPPPABF@aCZbG`abeRA(9j-b+KmcBG!p(lD\"q\"B9NGG@\n+\n+[CimeFp5G$PGXM+5cUec0YcMUVRN2@9(2pG$Xii2F3jhf'KR%ZMUQL6M[[CaIGcX\n+\n++b8Q)f,HFGj+MGP'Z-8d&S[SrA2I32!5k3L5#cQ1CV4NkAXjer4pehS\"JT*BMJmh\n+\n+eq+jHMVUAFXdD@Pa-LB8NHQRI3K)PI3p-0D6jHqhb!-,0lkJIrAq#kpTYIkZh1S$\n+\n+iJj!!%H0,\"hSUqR8TjiTU6d$LH!3qd\"l'QVp5(*Z0MQj%N5IR8$IK#2YVk#b4%AU\n+\n+KAhRjVG*[D*cA0T*HB1mJp`hf9R+*B@mR9a,f0R*MBGp1mJVX655\"`0j)XK,X1mL\n+\n+pKlf\"*+irG2*l,$B1E[#\"6T2S$,#X@[56ejba+FlV&\"bJcm2dMZ6dm6Xk0U4jAES\n+\n+MHGhp&Sp0DH#\"lZkGmrT#0Q@\"!rVX)TRXhr[K0j4X`S%(2RS$[3RXDKCpj(@KE-T\n+\n+cqZ`NL6E3i\"kI4160319LE[\"D@$B9G'mQ#4Ai1,Ued1qGG(GeFr6blT!!hqqbU3a\n+\n+-b$&jRrZ0-TY)B)&1lYedll[ACE1T#Rl`e9TlcUBkTp0ZdVF%-H4Z[lGR8a1Bi#X\n+\n+h0hN[\"GM8\"KlNTJYSfQ*jrHjlI6UE66PpZQMZ#'l`[pH@XGNEQ*!!Qr-kq@mqf+`\n+\n+,HVK6rLX60R@\"\"hI+c5IHHaBfk`-2I,5(G,jrpK(H5aSfpB%(pqQkANlrj[4mV#G\n+\n+EHm2$CN01V`9H%R\"aqMR+bhpj`iDqe%&p8bAIR!qTj%[4$kpFY(MK'lcmYcPXk&Z\n+\n+H1lcmlTi0lIT[mPVbJIFUL!elGjRM4BM8c8\"+#$@\"@kr%qK5GrJGH8d5JeDSp%6Z\n+\n+S`aY94TZmpLQ+$H(Nh\"cl%r`RK-KrL#Vr!3#3!aq$!!!\"!*!$!43!N!-8!*!$-Tr\n+\n+lRLe!rr#`!,K[$#eZd!6rm2rdd\"lm`FAKdkSV8FY+$deKBe\"bEfTPBh4c,R0TG!)\n+\n+!N!06594%8dP8)3#3\"P0*9%46593K!*!BUc!jI3!!8M8!!!&'\"1\"2l'mDG@6JrHc\n+\n+K@5U#NI*HN@GK!Z\"2kQ`FG&2UN!\"S!!,L@5[48(adA`CdC!EJ6qj[8hJS!!EJEHl\n+\n+LEe5!)D$!FJC1ANl!*IrX51FI-#D`jL63G!*&0K!+1Li!&Ri!)VX-S\"lbUKQJ(Z`\n+\n+3!+SDI!$!#3ZT8,aIE!!!Q$!'8!6\"aG!!N!-3!#X!\"3%B!J#3\"`-!N!-\"!*!$!43\n+\n+!N!-8!*!$-J$j(l!@#J#3!a`!-J!!8f9dC`#3!`S!!2rr!*!&q@G%'@B:\n+"}, {"sha": "c95f4bb2f3e45d9298ee645f7afe5414be69e653", "filename": "boehm-gc/Mac_files/MacOS_Test_config.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2FMacOS_Test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2FMacOS_Test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2FMacOS_Test_config.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,91 @@\n+/*\n+\tMacOS_Test_config.h\n+\t\n+\tConfiguration flags for Macintosh development systems.\n+\t\n+\tTest version.\n+\t\n+ \t<Revision History>\n+\n+ \t11/16/95  pcb  Updated compilation flags to reflect latest 4.6 Makefile.\n+\t\n+\tby Patrick C. Beard.\n+ */\n+/* Boehm, November 17, 1995 12:05 pm PST */\n+\n+#ifdef __MWERKS__\n+\n+// for CodeWarrior Pro with Metrowerks Standard Library (MSL).\n+// #define MSL_USE_PRECOMPILED_HEADERS 0\n+#include <ansi_prefix.mac.h>\n+#ifndef __STDC__\n+#define __STDC__ 0\n+#endif\n+\n+#endif\n+\n+// these are defined again in gc_priv.h.\n+#undef TRUE\n+#undef FALSE\n+\n+#define ALL_INTERIOR_POINTERS\t// follows interior pointers.\n+//#define SILENT\t\t\t\t// want collection messages.\n+//#define DONT_ADD_BYTE_AT_END\t// no padding.\n+//#define SMALL_CONFIG\t\t\t// whether to a smaller heap.\n+#define NO_SIGNALS\t\t\t\t// signals aren't real on the Macintosh.\n+#define USE_TEMPORARY_MEMORY\t// use Macintosh temporary memory.\n+\n+// CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT\n+//\n+//LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n+//    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n+//    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n+//   Flags for building libgc.a -- the last two are required.\n+//\n+// Setjmp_test may yield overly optimistic results when compiled\n+// without optimization.\n+// -DSILENT disables statistics printing, and improves performance.\n+// -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+//   altered stubborn objects, at substantial performance cost.\n+//   Use only for incremental collector debugging.\n+// -DFIND_LEAK causes the collector to assume that all inaccessible\n+//   objects should have been explicitly deallocated, and reports exceptions.\n+//   Finalization and the test program are not usable in this mode.\n+// -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n+//   (Clients should also define SOLARIS_THREADS and then include\n+//   gc.h before performing thr_ or GC_ operations.)\n+//   This is broken on nonSPARC machines.\n+// -DALL_INTERIOR_POINTERS allows all pointers to the interior\n+//   of objects to be recognized.  (See gc_priv.h for consequences.)\n+// -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n+//   usually causing it to use less space in such situations.\n+//   Incremental collection no longer works in this case.\n+// -DLARGE_CONFIG tunes the collector for unusually large heaps.\n+//   Necessary for heaps larger than about 500 MB on most machines.\n+//   Recommended for heaps larger than about 64 MB.\n+// -DDONT_ADD_BYTE_AT_END is meaningful only with\n+//   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n+//   causes all objects to be padded so that pointers just past the end of\n+//   an object can be recognized.  This can be expensive.  (The padding\n+//   is normally more than one byte due to alignment constraints.)\n+//   -DDONT_ADD_BYTE_AT_END disables the padding.\n+// -DNO_SIGNALS does not disable signals during critical parts of\n+//   the GC process.  This is no less correct than many malloc \n+//   implementations, and it sometimes has a significant performance\n+//   impact.  However, it is dangerous for many not-quite-ANSI C\n+//   programs that call things like printf in asynchronous signal handlers.\n+// -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n+//   new syntax \"operator new[]\" for allocating and deleting arrays.\n+//   See gc_cpp.h for details.  No effect on the C part of the collector.\n+//   This is defined implicitly in a few environments.\n+// -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n+//   as aliases for X, GC_realloc, and GC_free, respectively.\n+//   Calloc is redefined in terms of the new malloc.  X should\n+//   be either GC_malloc or GC_malloc_uncollectable.\n+//   The former is occasionally useful for working around leaks in code\n+//   you don't want to (or can't) look at.  It may not work for\n+//   existing code, but it often does.  Neither works on all platforms,\n+//   since some ports use malloc or calloc to obtain system memory.\n+//   (Probably works for UNIX, and win32.)\n+// -DNO_DEBUG removes GC_dump and the debugging routines it calls.\n+//   Reduces code size slightly at the expense of debuggability."}, {"sha": "93c3c97a955b5bc573fb7b352e1c9ef9508bbe69", "filename": "boehm-gc/Mac_files/MacOS_config.h", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2FMacOS_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2FMacOS_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2FMacOS_config.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,89 @@\n+/*\n+\tMacOS_config.h\n+\t\n+\tConfiguration flags for Macintosh development systems.\n+\t\n+ \t<Revision History>\n+ \t\n+ \t11/16/95  pcb  Updated compilation flags to reflect latest 4.6 Makefile.\n+\t\n+\tby Patrick C. Beard.\n+ */\n+/* Boehm, November 17, 1995 12:10 pm PST */\n+\n+#ifdef __MWERKS__\n+\n+// for CodeWarrior Pro with Metrowerks Standard Library (MSL).\n+// #define MSL_USE_PRECOMPILED_HEADERS 0\n+#include <ansi_prefix.mac.h>\n+#ifndef __STDC__\n+#define __STDC__ 0\n+#endif\n+\n+#endif /* __MWERKS__ */\n+\n+// these are defined again in gc_priv.h.\n+#undef TRUE\n+#undef FALSE\n+\n+#define ALL_INTERIOR_POINTERS\t// follows interior pointers.\n+#define SILENT\t\t\t// no collection messages.\n+//#define DONT_ADD_BYTE_AT_END\t// no padding.\n+//#define SMALL_CONFIG\t\t// whether to use a smaller heap.\n+#define NO_SIGNALS\t\t// signals aren't real on the Macintosh.\n+#define USE_TEMPORARY_MEMORY\t// use Macintosh temporary memory.\n+\n+// CFLAGS= -O -DNO_SIGNALS -DSILENT -DALL_INTERIOR_POINTERS\n+//\n+//LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n+//    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n+//    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n+//   Flags for building libgc.a -- the last two are required.\n+//\n+// Setjmp_test may yield overly optimistic results when compiled\n+// without optimization.\n+// -DSILENT disables statistics printing, and improves performance.\n+// -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+//   altered stubborn objects, at substantial performance cost.\n+//   Use only for incremental collector debugging.\n+// -DFIND_LEAK causes the collector to assume that all inaccessible\n+//   objects should have been explicitly deallocated, and reports exceptions.\n+//   Finalization and the test program are not usable in this mode.\n+// -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n+//   (Clients should also define SOLARIS_THREADS and then include\n+//   gc.h before performing thr_ or GC_ operations.)\n+//   This is broken on nonSPARC machines.\n+// -DALL_INTERIOR_POINTERS allows all pointers to the interior\n+//   of objects to be recognized.  (See gc_priv.h for consequences.)\n+// -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n+//   usually causing it to use less space in such situations.\n+//   Incremental collection no longer works in this case.\n+// -DLARGE_CONFIG tunes the collector for unusually large heaps.\n+//   Necessary for heaps larger than about 500 MB on most machines.\n+//   Recommended for heaps larger than about 64 MB.\n+// -DDONT_ADD_BYTE_AT_END is meaningful only with\n+//   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n+//   causes all objects to be padded so that pointers just past the end of\n+//   an object can be recognized.  This can be expensive.  (The padding\n+//   is normally more than one byte due to alignment constraints.)\n+//   -DDONT_ADD_BYTE_AT_END disables the padding.\n+// -DNO_SIGNALS does not disable signals during critical parts of\n+//   the GC process.  This is no less correct than many malloc \n+//   implementations, and it sometimes has a significant performance\n+//   impact.  However, it is dangerous for many not-quite-ANSI C\n+//   programs that call things like printf in asynchronous signal handlers.\n+// -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n+//   new syntax \"operator new[]\" for allocating and deleting arrays.\n+//   See gc_cpp.h for details.  No effect on the C part of the collector.\n+//   This is defined implicitly in a few environments.\n+// -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n+//   as aliases for X, GC_realloc, and GC_free, respectively.\n+//   Calloc is redefined in terms of the new malloc.  X should\n+//   be either GC_malloc or GC_malloc_uncollectable.\n+//   The former is occasionally useful for working around leaks in code\n+//   you don't want to (or can't) look at.  It may not work for\n+//   existing code, but it often does.  Neither works on all platforms,\n+//   since some ports use malloc or calloc to obtain system memory.\n+//   (Probably works for UNIX, and win32.)\n+// -DNO_DEBUG removes GC_dump and the debugging routines it calls.\n+//   Reduces code size slightly at the expense of debuggability.\n\\ No newline at end of file"}, {"sha": "a3e3fe8446ffcfac74811b86cfe2050934b6aca2", "filename": "boehm-gc/Mac_files/dataend.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2Fdataend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2Fdataend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2Fdataend.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,9 @@\n+/*\n+\tdataend.c\n+\t\n+\tA hack to get the extent of global data for the Macintosh.\n+\t\n+\tby Patrick C. Beard.\n+ */\n+\n+long __dataend;"}, {"sha": "a9e0dd59410813c10891c3b9963c6e2ecf791333", "filename": "boehm-gc/Mac_files/datastart.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2Fdatastart.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMac_files%2Fdatastart.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMac_files%2Fdatastart.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,9 @@\n+/*\n+\tdatastart.c\n+\t\n+\tA hack to get the extent of global data for the Macintosh.\n+\t\n+\tby Patrick C. Beard.\n+ */\n+\n+long __datastart;"}, {"sha": "011f49d3bcf033a9cf8886fdf21e8f43084ea90b", "filename": "boehm-gc/Makefile.DLLs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMakefile.DLLs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMakefile.DLLs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.DLLs?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,107 @@\n+#-----------------------------------------------------------------------------#\n+\n+# Makefile.DLLs, version 0.4.\n+\n+# Contributed by Fergus Henderson.\n+\n+# This Makefile contains rules for creating DLLs on Windows using gnu-win32.\n+\n+#-----------------------------------------------------------------------------#\n+\n+# This rule creates a `.def' file, which lists the symbols that are exported\n+# from the DLL.  We use `nm' to get a list of all the exported text (`T')\n+# symbols and data symbols -- including uninitialized data (`B'),\n+# initialized data (`D'), read-only data (`R'), and common blocks (`C').\n+%.def: %.a\n+\techo EXPORTS > $@\n+\tnm $< | grep '^........ [BCDRT] _' | sed 's/[^_]*_//' >> $@\n+\n+# We need to use macros to access global data:\n+# the user of the DLL must refer to `foo' as `(*__imp_foo)'.\n+# This rule creates a `_globals.h' file, which contains macros\n+# for doing this.\n+\n+SYM_PREFIX = $(firstword $(SYM_PREFIX-$*) $*)\n+DLL_MACRO = $(SYM_PREFIX)_USE_DLL\n+IMP_MACRO = $(SYM_PREFIX)_IMP\n+GLOBAL_MACRO = $(SYM_PREFIX)_GLOBAL\n+\n+%_globals.h: %.a\n+\techo \"/* automatically generated by Makefile.DLLs */\"\t> $@\n+\techo \"#if defined(__GNUC__) && defined(_WIN32) \\\\\"\t>> $@\n+\techo \"\t&& defined($(DLL_MACRO))\"\t\t\t>> $@\n+\techo \"#  define $(IMP_MACRO)(name)\t__imp_##name\" \t>> $@\n+\techo \"#  define $(GLOBAL_MACRO)(name)\t(*$(IMP_MACRO)(name))\" >> $@\n+\techo \"#else\"\t\t\t\t\t\t>> $@\n+\techo \"#  define $(GLOBAL_MACRO)(name)\tname\"\t\t>> $@\n+\techo \"#endif\"\t\t\t\t\t\t>> $@\n+\techo \"\"\t\t\t\t\t\t\t>> $@\n+\tfor sym in `nm $< | grep '^........ [BCDR] _' | sed 's/[^_]*_//'`; do \\\n+\t\techo \"#define $$sym\t$(GLOBAL_MACRO)($$sym)\"\t>> $@; \\\n+\tdone\n+\n+# This rule creates the export object file (`foo.exp') which contains the\n+# jump table array; this export object file becomes part of the DLL. \n+# This rule also creates the import library (`foo_dll.a') which contains small\n+# stubs for all the functions exported by the DLL which jump to them via the\n+# jump table.  Executables that will use the DLL must be linked against this\n+# stub library.\n+%.exp %_dll.a : %.def\n+\tdlltool $(DLLTOOLFLAGS) $(DLLTOOLFLAGS-$*)\t\t\\\n+\t\t--def $<\t\t\t\t\t\\\n+\t\t--dllname $*.dll\t\t\t\t\\\n+\t\t--output-exp $*.exp\t\t\t\t\\\n+\t\t--output-lib $*_dll.a\n+\n+# The `sed' commands below are to convert DOS-style `C:\\foo\\bar'\n+# pathnames into Unix-style `//c/foo/bar' pathnames.\n+CYGWIN32_LIBS = $(shell echo\t\t\t\t\t\\\n+\t-L`dirname \\`gcc -print-file-name=libgcc.a |\t\t\\\n+\tsed -e 's@^\\\\\\\\([A-Za-z]\\\\\\\\):@//\\\\\\\\1@g' -e 's@\\\\\\\\\\\\\\\\@/@g' \\` ` \\\n+\t-L`dirname \\`gcc -print-file-name=libcygwin.a |\t\\\n+\tsed -e 's@^\\\\\\\\([A-Za-z]\\\\\\\\):@//\\\\\\\\1@g' -e 's@\\\\\\\\\\\\\\\\@/@g' \\` ` \\\n+\t-L`dirname \\`gcc -print-file-name=libkernel32.a | \\\n+\tsed -e 's@^\\\\\\\\([A-Za-z]\\\\\\\\):@//\\\\\\\\1@g' -e 's@\\\\\\\\\\\\\\\\@/@g' \\` ` \\\n+\t-lgcc -lcygwin -lkernel32 -lgcc)\n+\n+RELOCATABLE=yes\n+\n+ifeq \"$(strip $(RELOCATABLE))\" \"yes\"\n+\n+# to create relocatable DLLs, we need to do two passes\n+%.dll: %.exp %.a dll_fixup.o dll_init.o\n+\t$(LD) $(LDFLAGS) $(LDFLAGS-$*) --dll -o $*.base\t\t\t\\\n+\t\t-e _dll_entry@12 dll_init.o\t\t\t\t\\\n+\t\tdll_fixup.o $*.exp $*.a\t\t\t\t\t\\\n+\t\t$(LDLIBS) $(LDLIBS-$*)\t\t\t\t\t\\\n+\t\t$(CYGWIN32_LIBS)\n+\t$(LD) $(LDFLAGS) $(LDFLAGS-$*) --dll --base-file $*.base -o $@\t\\\n+\t\t-e _dll_entry@12 dll_init.o\t\t\t\t\\\n+\t\tdll_fixup.o $*.exp $*.a\t\t\t\t\t\\\n+\t\t$(LDLIBS) $(LDLIBS-$*)\t\t\t\t\t\\\n+\t\t$(CYGWIN32_LIBS)\n+\trm -f $*.base\n+else\n+\n+%.dll: %.exp %.a dll_fixup.o dll_init.o\n+\t$(LD) $(LDFLAGS) $(LDFLAGS-$*) --dll -o $@\t\t\t\\\n+\t\t-e _dll_entry@12 dll_init.o\t\t\t\t\\\n+\t\tdll_fixup.o $*.exp $*.a\t\t\t\t\t\\\n+\t\t$(LDLIBS) $(LDLIBS-$*)\t\t\t\t\t\\\n+\t\t$(CYGWIN32_LIBS)\n+\n+endif\n+\n+# This black magic piece of assembler needs to be linked in in order to\n+# properly terminate the list of imported DLLs.\n+dll_fixup.s:\n+\techo '.section .idata$$3' \t> dll_fixup.s\n+\techo '.long 0,0,0,0, 0,0,0,0'\t>> dll_fixup.s\n+\n+# This bit is necessary to provide an initialization function for the DLL.\n+dll_init.c:\n+\techo '__attribute__((stdcall))' > dll_init.c\n+\techo 'int dll_entry(int handle, int reason, void *ptr)' >> dll_init.c\n+\techo '{return 1; }' >> dll_init.c\n+\n+dont_throw_away: dll_fixup.o dll_init.o"}, {"sha": "979ac6f33e7790fa0e35c34aeef934a65d3dbce9", "filename": "boehm-gc/Makefile.dj", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,296 @@\n+# Primary targets:\n+# gc.a - builds basic library\n+# libgc.a - builds library for use with g++ \"-fgc-keyword\" extension\n+# c++ - adds C++ interface to library\n+# cords - adds cords (heavyweight strings) to library\n+# test - prints porting information, then builds basic version of gc.a,\n+#      \t and runs some tests of collector and cords.  Does not add cords or\n+#\t c++ interface to gc.a\n+# cord/de$(EXE_SUFFIX) - builds dumb editor based on cords.\n+CC=gcc\n+CXX=gcc -x c++\n+CXXLD=gxx\n+RM=rm -f\n+MV=mv\n+EXE_SUFFIX=.exe\n+RANLIB=ranlib\n+\n+CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT -DATOMIC_UNCOLLECTABLE\n+\n+# Setjmp_test may yield overly optimistic results when compiled\n+# without optimization.\n+# -DSILENT disables statistics printing, and improves performance.\n+# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+#   altered stubborn objects, at substantial performance cost.\n+#   Use only for incremental collector debugging.\n+# -DFIND_LEAK causes the collector to assume that all inaccessible\n+#   objects should have been explicitly deallocated, and reports exceptions.\n+#   Finalization and the test program are not usable in this mode.\n+# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n+#   (Clients should also define SOLARIS_THREADS and then include\n+#   gc.h before performing thr_ or dl* or GC_ operations.)\n+#   This is broken on nonSPARC machines.\n+# -DIRIX_THREADS enables support for Irix pthreads.  See README.irix.\n+# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n+#   of objects to be recognized.  (See gc_priv.h for consequences.)\n+# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n+#   usually causing it to use less space in such situations.\n+#   Incremental collection no longer works in this case.\n+# -DLARGE_CONFIG tunes the collector for unusually large heaps.\n+#   Necessary for heaps larger than about 500 MB on most machines.\n+#   Recommended for heaps larger than about 64 MB.\n+# -DDONT_ADD_BYTE_AT_END is meaningful only with\n+#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n+#   causes all objects to be padded so that pointers just past the end of\n+#   an object can be recognized.  This can be expensive.  (The padding\n+#   is normally more than one byte due to alignment constraints.)\n+#   -DDONT_ADD_BYTE_AT_END disables the padding.\n+# -DNO_SIGNALS does not disable signals during critical parts of\n+#   the GC process.  This is no less correct than many malloc \n+#   implementations, and it sometimes has a significant performance\n+#   impact.  However, it is dangerous for many not-quite-ANSI C\n+#   programs that call things like printf in asynchronous signal handlers.\n+# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n+#   have execute permission, i.e. it may be impossible to execute\n+#   code from the heap.  Currently this only affects the incremental\n+#   collector on UNIX machines.  It may greatly improve its performance,\n+#   since this may avoid some expensive cache synchronization.\n+# -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n+#   new syntax \"operator new[]\" for allocating and deleting arrays.\n+#   See gc_cpp.h for details.  No effect on the C part of the collector.\n+#   This is defined implicitly in a few environments.\n+# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n+#   as aliases for X, GC_realloc, and GC_free, respectively.\n+#   Calloc is redefined in terms of the new malloc.  X should\n+#   be either GC_malloc or GC_malloc_uncollectable.\n+#   The former is occasionally useful for working around leaks in code\n+#   you don't want to (or can't) look at.  It may not work for\n+#   existing code, but it often does.  Neither works on all platforms,\n+#   since some ports use malloc or calloc to obtain system memory.\n+#   (Probably works for UNIX, and win32.)\n+# -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n+#   -DREDIRECT_MALLOC.\n+# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n+#   Reduces code size slightly at the expense of debuggability.\n+# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of\n+#   order by specifying a nonstandard finalization mark procedure  (see\n+#   finalize.c).  Objects reachable from finalizable objects will be marked\n+#   in a sepearte postpass, and hence their memory won't be reclaimed.\n+#   Not recommended unless you are implementing a language that specifies\n+#   these semantics.\n+# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n+#   This is useful if either the vendor malloc implementation is poor,\n+#   or if REDIRECT_MALLOC is used.\n+\n+LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n+    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n+    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n+#   Flags for building libgc.a -- the last two are required.\n+\n+CXXFLAGS= $(CFLAGS) -DOPERATOR_NEW_ARRAY\n+AR= ar\n+RANLIB= ranlib\n+\n+\n+# Redefining srcdir allows object code for the nonPCR version of the collector\n+# to be generated in different directories.  In this case, the destination directory\n+# should contain a copy of the original include directory.\n+srcdir = .\n+VPATH = $(srcdir)\n+\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o typd_mlc.o ptr_chck.o mallocx.o\n+\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c typd_mlc.c ptr_chck.c mallocx.c\n+\n+CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c cord/cord.h cord/ec.h cord/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n+\n+CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n+\n+SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n+    sparc_mach_dep.s gc.h gc_typed.h gc_hdrs.h gc_priv.h gc_private.h \\\n+    config.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man \\\n+    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc gc_cpp.h weakpointer.h \\\n+    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h gc_alloc.h \\\n+    $(CORD_SRCS)\n+\n+OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n+           README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n+           SCoptions.amiga README.amiga README.win32 cord/README \\\n+           cord/gc.h include/gc.h include/gc_typed.h include/cord.h \\\n+           include/ec.h include/private/cord_pos.h include/private/config.h \\\n+           include/private/gc_hdrs.h include/private/gc_priv.h \\\n+\t   include/gc_cpp.h README.rs6000 \\\n+           include/weakpointer.h README.QUICK callprocs pc_excludes \\\n+           barrett_diagram README.OS2 README.Mac MacProjects.sit.hqx \\\n+           MacOS.c EMX_MAKEFILE makefile.depend README.debugging \\\n+           include/gc_cpp.h Mac_files/datastart.c Mac_files/dataend.c \\\n+           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n+           add_gc_prefix.c README.solaris2 README.sgi README.hp README.uts \\\n+\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj\n+\n+CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n+           $(srcdir)/cord/private/cord_pos.h\n+\n+UTILS= if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX) threadlibs$(EXE_SUFFIX)\n+\n+# Libraries needed for curses applications.  Only needed for de.\n+CURSES= -lcurses -ltermlib\n+\n+# The following is irrelevant on most systems.  But a few\n+# versions of make otherwise fork the shell specified in\n+# the SHELL environment variable.\n+SHELL= /bin/sh\n+\n+SPECIALCFLAGS = \n+# Alternative flags to the C compiler for mach_dep.c.\n+# Mach_dep.c often doesn't like optimization, and it's\n+# not time-critical anyway.\n+# Set SPECIALCFLAGS to -q nodirect_code on Encore.\n+\n+all: gc.a gctest$(EXE_SUFFIX)\n+\n+pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h config.h mach_dep.o $(SRCS)\n+\tmake -f PCR-Makefile depend\n+\tmake -f PCR-Makefile\n+\n+$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n+    $(srcdir)/config.h $(srcdir)/gc_typed.h Makefile\n+# The dependency on Makefile is needed.  Changing\n+# options such as -DSILENT affects the size of GC_arrays,\n+# invalidating all .o files that rely on gc_priv.h\n+\n+mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n+\n+base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n+\techo > base_lib\n+\t$(RM) on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n+\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(OBJS) dyn_load.o\n+\t-./if_not_there on_sparc_sunos5 $(RANLIB) gc.a\n+#\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n+\n+libgc.a: \n+\tmake CFLAGS=\"$(LIBGC_CFLAGS)\" clean gc.a gcc_support.o\n+\t$(MV) gc.a libgc.a\n+\t-$(RM) on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus libgc.a gcc_support.o\n+\t./if_not_there on_sparc_sunos5 $(AR) ru libgc.a gcc_support.o\n+\t-./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a\n+\n+cords: $(CORD_OBJS) cord/cordtest$(EXE_SUFFIX) $(UTILS)\n+\t-$(RM) on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n+\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(CORD_OBJS)\n+\t-./if_not_there on_sparc_sunos5 $(RANLIB) gc.a\n+\n+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makefile\n+\t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n+\n+test_cpp: $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h \\\n+base_lib $(UTILS)\n+\t-$(RM) test_cpp test_cpp$(EXE_SUFFIX)\n+\t./if_mach HP_PA \"\" $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a -ldld\n+\t./if_not_there test_cpp$(EXE_SUFFIX) $(CXXLD) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a\n+\t$(RM) test_cpp\n+\n+c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp\n+\t-$(RM) on_sparc_sunos5\n+\t$(AR) ru gc.a gc_cpp.o\n+\t$(RANLIB) gc.a\n+\t./test_cpp$(EXE_SUFFIX) 1\n+\techo > c++\n+\n+dyn_load_sunos53.o: dyn_load.c\n+\t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n+\n+mach_dep.o: $(srcdir)/mach_dep.c\n+\t-$(RM) mach_dep.o\n+\t$(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n+\n+mark_rts.o: $(srcdir)/mark_rts.c\n+\t-$(RM) mark_rts.o\n+\t$(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n+\n+cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c\n+\t$(MV) cordbscs.o cord/cordbscs.o\n+#  not all compilers understand -o filename\n+\n+cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c\n+\t$(MV) cordxtra.o cord/cordxtra.o\n+\n+cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c\n+\t$(MV) cordprnt.o cord/cordprnt.o\n+\n+cord/cordtest$(EXE_SUFFIX): $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n+\t-$(RM) cord/cordtest$(EXE_SUFFIX)\n+\t$(CC) $(CFLAGS) -o cordtest $(srcdir)/cord/cordtest.c\\\n+\t\t $(CORD_OBJS) gc.a\n+\t./if_not_there cord/cordtest$(EXE_SUFFIX) \\\n+\t\t$(MV) cordtest$(EXE_SUFFIX) cord/cordtest$(EXE_SUFFIX)\n+\n+cord/de$(EXE_SUFFIX): $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n+\t-$(RM) cord/de$(EXE_SUFFIX)\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n+cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n+cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld\n+\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n+cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n+cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n+cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES)\n+\t./if_not_there cord/de$(EXE_SUFFIX) \\\n+\t\t$(MV) de$(EXE_SUFFIX) cord/de$(EXE_SUFFIX)\n+\n+if_mach$(EXE_SUFFIX): $(srcdir)/if_mach.c $(srcdir)/config.h\n+\t$(CC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c\n+\t-$(RM) if_mach\n+\n+threadlibs$(EXE_SUFFIX): $(srcdir)/threadlibs.c $(srcdir)/config.h Makefile\n+\t$(CC) $(CFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n+\t-$(RM) threadlibs\n+\n+if_not_there$(EXE_SUFFIX): $(srcdir)/if_not_there.c\n+\t$(CC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n+\t-$(RM) if_not_there\n+\n+clean:\n+\t-$(RM) gc.a *.o\n+\t-$(RM) *.o\n+\t-$(RM) gctest gctest_dyn_link test_cpp \\\n+\t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n+\t      $(CORD_OBJS) cordtest cord/cordtest de cord/de\n+\t-$(RM) gctest$(EXE_SUFFIX) gctest_dyn_link$(EXE_SUFFIX) test_cpp$(EXE_SUFFIX) \\\n+\t      setjmp_test$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX) if_mach$(EXE_SUFFIX) \\\n+\t      cord/cordtest$(EXE_SUFFIX)\n+\t-$(RM) *~\n+\n+gctest$(EXE_SUFFIX): test.o gc.a\n+\t-$(RM) gctest$(EXE_SUFFIX)\n+\t$(CC) $(CFLAGS) -o gctest test.o gc.a\n+\t$(RM) gctest\n+\n+# If an optimized setjmp_test generates a segmentation fault,\n+# odds are your compiler is broken.  Gctest may still work.\n+# Try compiling setjmp_t.c unoptimized.\n+setjmp_test$(EXE_SUFFIX): $(srcdir)/setjmp_t.c $(srcdir)/gc.h \\\n+\t\tif_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n+\t-$(RM) setjmp_test$(EXE_SUFFIX)\n+\t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n+\t$(RM) setjmp_test\n+\n+test:  KandRtest cord/cordtest$(EXE_SUFFIX)\n+\t./cord/cordtest$(EXE_SUFFIX)\n+\n+# Those tests that work even with a K&R C compiler:\n+KandRtest: setjmp_test$(EXE_SUFFIX) gctest$(EXE_SUFFIX)\n+\t./setjmp_test$(EXE_SUFFIX)\n+\t./gctest$(EXE_SUFFIX)\n+"}, {"sha": "52f6f4ae3a08d4f42c9dc01408c9116476ef8952", "filename": "boehm-gc/NT_MAKEFILE", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FNT_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FNT_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_MAKEFILE?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,59 @@\n+# Makefile for Windows NT.  Assumes Microsoft compiler, and a single thread.\n+# DLLs are included in the root set under NT, but not under win32S.\n+# Use \"nmake nodebug=1 all\" for optimized versions of library, gctest and editor.\n+\n+CPU= i386\n+!include <ntwin32.mak>\n+\n+OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj\n+\n+all: gctest.exe cord\\de.exe test_cpp.exe\n+\n+.c.obj:\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -DSMALL_CONFIG -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ $*.c /Fo$*.obj\n+\n+.cpp.obj:\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -DSMALL_CONFIG -DSILENT -DALL_INTERIOR_POINTERS $*.CPP /Fo$*.obj\n+\n+$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h\n+\n+gc.lib: $(OBJS)\n+\tlib /MACHINE:i386 /out:gc.lib $(OBJS)\n+# The original NT SDK used lib32 instead of lib\n+\n+gctest.exe: test.obj gc.lib\n+#\tThe following works for win32 debugging.  For win32s debugging use debugtype:coff\n+#\tand add mapsympe line.\n+#  This produces a \"GUI\" applications that opens no windows and writes to the log file\n+#  \"gc.log\".  This is done to make the result runnable under win32s.\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe test.obj $(guilibs) gc.lib\n+#\tmapsympe -n -o gctest.sym gctest.exe\n+\n+cord\\de_win.rbj: cord\\de_win.res\n+\tcvtres -$(CPU) cord\\de_win.res -o cord\\de_win.rbj\n+\n+cord\\de.obj cord\\de_win.obj: cord\\cord.h cord\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n+\n+cord\\de_win.res: cord\\de_win.rc cord\\de_win.h cord\\de_cmds.h\n+\t$(rc) $(rcvars) -r -fo cord\\de_win.res $(cvars) cord\\de_win.rc\n+\n+# Cord/de is a real win32 gui application.\n+cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:cord\\de.exe  cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib $(guilibs)\n+\n+gc_cpp.obj: gc_cpp.h gc.h\n+\n+gc_cpp.cpp: gc_cpp.cc\n+\tcopy gc_cpp.cc gc_cpp.cpp\n+\n+test_cpp.cpp: test_cpp.cc\n+\tcopy test_cpp.cc test_cpp.cpp\n+\n+# This generates the C++ test executable.  The executable expects\n+# a single numeric argument, which is the number of iterations.\n+# The output appears in the file \"gc.log\".\n+test_cpp.exe: test_cpp.obj gc_cpp.h gc.h gc.lib\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:test_cpp.exe test_cpp.obj gc.lib $(guilibs)\n+\n+\n+"}, {"sha": "7b8162182069634d1fc4cedc92285f15d23d7730", "filename": "boehm-gc/OS2_MAKEFILE", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FOS2_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FOS2_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FOS2_MAKEFILE?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,45 @@\n+# Makefile for OS/2.  Assumes IBM's compiler, static linking, and a single thread.\n+# Adding dynamic linking support seems easy, but takes a little bit of work.\n+# Adding thread support may be nontrivial, since we haven't yet figured out how to\n+# look at another thread's registers.\n+\n+# Significantly revised for GC version 4.4 by Mark Boulter (Jan 1994).\n+\n+OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj typd_mlc.obj ptr_chck.obj mallocx.obj\n+\n+CORDOBJS= cord\\cordbscs.obj cord\\cordxtra.obj cord\\cordprnt.obj\n+\n+CC= icc\n+CFLAGS= /O /Q /DSILENT /DSMALL_CONFIG /DALL_INTERIOR_POINTERS\n+# Use /Ti instead of /O for debugging\n+# Setjmp_test may yield overly optimistic results when compiled\n+# without optimization.\n+\n+all: $(OBJS) gctest.exe cord\\cordtest.exe\n+\n+$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h\n+\n+## ERASE THE LIB FIRST - if it is already there then this command will fail\n+## (make sure its there or erase will fail!)\n+gc.lib: $(OBJS)\n+        echo . > gc.lib\n+        erase gc.lib\n+        LIB gc.lib $(OBJS), gc.lst\n+\n+mach_dep.obj: mach_dep.c\n+        $(CC) $(CFLAGS) /C mach_dep.c\n+\n+gctest.exe: test.obj gc.lib\n+        $(CC) $(CFLAGS) /B\"/STACK:524288\" /Fegctest test.obj gc.lib\n+\n+cord\\cordbscs.obj: cord\\cordbscs.c cord\\cord.h cord\\private\\cord_pos.h\n+        $(CC) $(CFLAGS) /C /Focord\\cordbscs cord\\cordbscs.c\n+\n+cord\\cordxtra.obj: cord\\cordxtra.c cord\\cord.h cord\\private\\cord_pos.h cord\\ec.h\n+        $(CC) $(CFLAGS) /C /Focord\\cordxtra cord\\cordxtra.c\n+\n+cord\\cordprnt.obj: cord\\cordprnt.c cord\\cord.h cord\\private\\cord_pos.h cord\\ec.h\n+        $(CC) $(CFLAGS) /C /Focord\\cordprnt cord\\cordprnt.c\n+\n+cord\\cordtest.exe: cord\\cordtest.c cord\\cord.h cord\\private\\cord_pos.h cord\\ec.h $(CORDOBJS) gc.lib\n+        $(CC) $(CFLAGS) /B\"/STACK:65536\" /Fecord\\cordtest cord\\cordtest.c gc.lib $(CORDOBJS)"}, {"sha": "7b80637fb293f01f30e2b1ab7e4d84c84bb79b06", "filename": "boehm-gc/PCR-Makefile", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FPCR-Makefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FPCR-Makefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FPCR-Makefile?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,68 @@\n+#\n+# Default target\n+#\n+\n+default: gc.o\n+\n+include ../config/common.mk\n+\n+#\n+# compilation flags, etc.\n+#\n+\n+\n+CPPFLAGS = $(INCLUDE) $(CONFIG_CPPFLAGS) \\\n+\t-DPCR_NO_RENAME -DPCR_NO_HOSTDEP_ERR\n+#CFLAGS\t= -DPCR -DSILENT $(CONFIG_CFLAGS)\n+CFLAGS\t= -DPCR $(CONFIG_CFLAGS)\n+SPECIALCFLAGS = \t# For code involving asm's\n+\n+ASPPFLAGS  = $(INCLUDE) $(CONFIG_ASPPFLAGS) \\\n+\t-DPCR_NO_RENAME -DPCR_NO_HOSTDEP_ERR -DASM\n+\n+ASFLAGS\t= $(CONFIG_ASFLAGS)\n+\n+LDRFLAGS = $(CONFIG_LDRFLAGS)\n+\n+LDFLAGS = $(CONFIG_LDFLAGS)\n+\n+#\n+#\n+#\n+#\n+# BEGIN PACKAGE-SPECIFIC PART\n+#\n+#\n+#\n+#\n+\n+# Fix to point to local pcr installation directory.\n+PCRDIR= ..\n+\n+COBJ= alloc.o reclaim.o allchblk.o misc.o os_dep.o mark_rts.o headers.o mark.o obj_map.o pcr_interface.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o typd_mlc.o ptr_chck.o mallocx.o\n+\n+CSRC= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c typd_mlc.c ptr_chck.c mallocx.c\n+\n+SHELL= /bin/sh\n+\n+default: gc.o\n+\n+gc.o: $(COBJ) mach_dep.o\n+\t$(LDR) $(CONFIG_LDRFLAGS) -o gc.o $(COBJ) mach_dep.o\n+\n+\n+mach_dep.o: mach_dep.c mips_mach_dep.s rs6000_mach_dep.s if_mach if_not_there\n+\trm -f mach_dep.o\n+\t./if_mach MIPS \"\" as -o mach_dep.o mips_mach_dep.s\n+\t./if_mach RS6000 \"\" as -o mach_dep.o rs6000_mach_dep.s\n+\t./if_mach ALPHA \"\" as -o mach_dep.o alpha_mach_dep.s\n+\t./if_mach SPARC SUNOS5 as -o mach_dep.o sparc_mach_dep.s\n+\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) mach_dep.c\n+\n+if_mach: if_mach.c config.h\n+\t$(CC) $(CFLAGS) -o if_mach if_mach.c\n+\n+if_not_there: if_not_there.c\n+\t$(CC) $(CFLAGS) -o if_not_there if_not_there.c\n+\n+"}, {"sha": "6d2fa74358d70b44ae6ab04a2eb799de0e81505a", "filename": "boehm-gc/README.Mac", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.Mac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.Mac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.Mac?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,385 @@\n+Patrick Beard's Notes for building GC v4.12 with CodeWarrior Pro 2:\n+----------------------------------------------------------------------------\n+The current build environment for the collector is CodeWarrior Pro 2.\n+Projects for CodeWarrior Pro 2 (and for quite a few older versions)\n+are distributed in the file Mac_projects.sit.hqx. The project file\n+:Mac_projects:gc.prj builds static library versions of the collector.\n+:Mac_projects:gctest.prj builds the GC test suite.\n+\n+Configuring the collector is still done by editing the files\n+:Mac_files:MacOS_config.h and :Mac_files:MacOS_Test_config.h.\n+\n+Lars Farm's suggestions on building the collector:\n+----------------------------------------------------------------------------\n+Garbage Collection on MacOS - a manual 'MakeFile'\n+-------------------------------------------------\n+\n+Project files and IDE's are great on the Macintosh, but they do have\n+problems when used as distribution media. This note tries to provide\n+porting instructions in pure TEXT form to avoid those problems. A manual\n+'makefile' if you like.\n+\n+    GC version:     4.12a2\n+    Codewarrior:    CWPro1\n+    date:           18 July 1997\n+\n+The notes may or may not apply to earlier or later versions of the\n+GC/CWPro. Actually, they do apply to earlier versions of both except that\n+until recently a project could only build one target so each target was a\n+separate project. The notes will most likely apply to future versions too.\n+Possibly with minor tweaks.\n+\n+This is just to record my experiences. These notes do not mean I now\n+provide a supported port of the GC to MacOS. It works for me. If it works\n+for you, great. If it doesn't, sorry, try again...;-) Still, if you find\n+errors, please let me know.\n+\n+    mailto:         lars.farm@ite.mh.se\n+\n+    address:        Lars Farm\n+                    Kr\ufffdnv\ufffdgen 33b\n+                    856 44 Sundsvall\n+                    Sweden\n+\n+Porting to MacOS is a bit more complex than it first seems. Which MacOS?\n+68K/PowerPC? Which compiler? Each supports both 68K and PowerPC and offer a\n+large number of (unique to each environment) compiler settings. Each\n+combination of compiler/68K/PPC/settings require a unique combination of\n+standard libraries. And the IDE's does not select them for you. They don't\n+even check that the library is built with compatible setting and this is\n+the major source of problems when porting the GC (and otherwise too).\n+\n+You will have to make choices when you configure the GC. I've made some\n+choices here, but there are other combinations of settings and #defines\n+that work too.\n+\n+As for target settings the major obstacles may be:\n+- 68K Processor: check \"4-byte Ints\".\n+- PPC Processor: uncheck \"Store Static Data in TOC\".\n+\n+What you need to do:\n+===================\n+\n+1) Build the GC as a library\n+2) Test that the library works with 'test.c'.\n+3) Test that the C++ interface 'gc_cpp.cc/h' works with 'test_cpp.cc'.\n+\n+1) The Libraries:\n+=================\n+I made one project with four targets (68K/PPC tempmem or appheap). One target\n+will suffice if you're able to decide which one you want. I wasn't...\n+\n+Codewarrior allows a large number of compiler/linker settings. I used these:\n+\n+Settings shared by all targets:\n+------------------------------\n+o Access Paths:\n+  - User Paths:   the GC folder\n+  - System Paths: {Compiler}:Metrowerks Standard Library:\n+                  {Compiler}:MacOS Support:Headers:\n+                  {Compiler}:MacOS Support:MacHeaders:\n+o C/C++ language:\n+  - inlining: normal\n+  - direct to SOM: off\n+  - enable/check: exceptions, RTTI, bool (and if you like pool strings)\n+\n+PowerPC target settings\n+-----------------------\n+o Target Settings:\n+  - name of target\n+  - MacOS PPC Linker\n+o PPC Target\n+  - name of library\n+o C/C++ language\n+  - prefix file as described below\n+o PPC Processor\n+  - Struct Alignment: PowerPC\n+  - uncheck \"Store Static Data in TOC\" -- important!\n+    I don't think the others matter, I use full optimization and its ok\n+o PPC Linker\n+  - Factory Settings (SYM file with full paths, faster linking, dead-strip\n+    static init, Main: __start)\n+\n+\n+68K target settings\n+-------------------\n+o Target Settings:\n+  - name of target\n+  - MacOS 68K Linker\n+o 68K Target\n+  - name of library\n+  - A5 relative data\n+o C/C++ language\n+  - prefix file as described below\n+o 68K Processor\n+  - Code model: smart\n+  - Struct alignment: 68K\n+  - FP: SANE\n+  - enable 4-Byte Ints -- important!\n+    I don't think the others matter. I selected...\n+  - enable: 68020\n+  - enable: global register allocation\n+o IR Optimizer\n+  - enable: Optimize Space, Optimize Speed\n+    I suppose the others would work too, but haven't tried...\n+o 68K Linker\n+  - Factory Settings (New Style MacsBug,SYM file with full paths,\n+    A6 Frames, fast link, Merge compiler glue into segment 1,\n+    dead-strip static init)\n+\n+Prefix Files to configure the GC sources\n+----------------------------------------\n+The Codewarrior equivalent of commandline compilers -DNAME=X is to use\n+prefix-files. A TEXT file that is automatically #included before the first byte\n+of every source file. I used these:\n+\n+---- ( cut here ) ----  gc_prefix_tempmem.h     -- 68K and PPC -----\n+    #include \"gc_prefix_common.h\"\n+    #undef USE_TEMPORARY_MEMORY\n+    #define USE_TEMPORARY_MEMORY\n+---- ( cut here ) ----  gc_prefix_appmem.h      -- 68K and PPC -----\n+    #include \"gc_prefix_common.h\"\n+    #undef USE_TEMPORARY_MEMORY\n+//  #define USE_TEMPORARY_MEMORY\n+\n+---- ( cut here ) ----  gc_prefix_common.h      --------------------\n+// gc_prefix_common.h\n+// ------------------\n+// Codewarrior prefix file to configure the GC libraries\n+//\n+//   prefix files are the Codewarrior equivalent of the\n+//   command line option -Dname=x frequently seen in makefiles\n+\n+#if !__MWERKS__\n+  #error only tried this with Codewarrior\n+#endif\n+\n+#if macintosh\n+  #define MSL_USE_PRECOMPILED_HEADERS 0\n+  #include <ansi_prefix.mac.h>\n+  #ifndef __STDC__\n+    #define __STDC__ 0\n+  #endif\n+\n+  //  See list of #defines to configure the library in: 'MakeFile'\n+  //  see also README\n+\n+  #define SILENT                // no collection messages. In case\n+                                // of trouble you might want this off\n+  #define ALL_INTERIOR_POINTERS // follows interior pointers.\n+//#define DONT_ADD_BYTE_AT_END  // disables the padding if defined.\n+//#define SMALL_CONFIG          // whether to use a smaller heap.\n+  #define NO_SIGNALS            // signals aren't real on the Macintosh.\n+  #define ATOMIC_UNCOLLECTABLE  // GC_malloc_atomic_uncollectable()\n+\n+  // define either or none as per personal preference\n+  //   used in malloc.c\n+  #define REDIRECT_MALLOC GC_malloc\n+//#define REDIRECT_MALLOC GC_malloc_uncollectable\n+  // if REDIRECT_MALLOC is #defined make sure that the GC library\n+  // is listed before the ANSI/ISO libs in the Codewarrior\n+  // 'Link order' panel\n+//#define IGNORE_FREE\n+\n+  // mac specific configs\n+//#define USE_TEMPORARY_MEMORY    // use Macintosh temporary memory.\n+//#define SHARED_LIBRARY_BUILD    // build for use in a shared library.\n+\n+#else\n+  // could build Win32 here too, or in the future\n+  // Rhapsody PPC-mach, Rhapsody PPC-MacOS,\n+  // Rhapsody Intel-mach, Rhapsody Intel-Win32,...\n+  // ... ugh this will get messy ...\n+#endif\n+\n+// make sure ints are at least 32-bit\n+// ( could be set to 16-bit by compiler settings (68K) )\n+\n+struct gc_private_assert_intsize_{ char x[ sizeof(int)>=4 ? 1 : 0 ]; };\n+\n+#if __powerc\n+  #if __option(toc_data)\n+    #error turn off \"store static data in TOC\" when using GC\n+    //     ... or find a way to add TOC to the root set...(?)\n+  #endif\n+#endif\n+---- ( cut here ) ----  end of gc_prefix_common.h  -----------------\n+\n+Files to  build the GC libraries:\n+--------------------------------\n+    allchblk.c\n+    alloc.c\n+    blacklst.c\n+    checksums.c\n+    dbg_mlc.c\n+    finalize.c\n+    headers.c\n+    mach_dep.c\n+    MacOS.c    -- contains MacOS code\n+    malloc.c\n+    mallocx.c\n+    mark.c\n+    mark_rts.c\n+    misc.c\n+    new_hblk.c\n+    obj_map.c\n+    os_dep.c   -- contains MacOS code\n+    ptr_chck.c\n+    reclaim.c\n+    stubborn.c\n+    typd_mlc.c\n+    gc++.cc    -- this is 'gc_cpp.cc' with less 'inline' and\n+               -- throw std::bad_alloc when out of memory\n+               -- gc_cpp.cc works just fine too\n+\n+2) Test that the library works with 'test.c'.\n+=============================================\n+\n+The test app is just an ordinary ANSI-C console app. Make sure settings\n+match the library you're testing.\n+\n+Files\n+-----\n+    test.c\n+    the GC library to test        -- link order before ANSI libs\n+    suitable Mac+ANSI libraries\n+\n+prefix:\n+------\n+---- ( cut here ) ----  gc_prefix_testlib.h     -- all libs -----\n+#define MSL_USE_PRECOMPILED_HEADERS 0\n+#include <ansi_prefix.mac.h>\n+#undef NDEBUG\n+\n+#define ALL_INTERIOR_POINTERS\t/* for GC_priv.h */\n+---- ( cut here ) ----\n+\n+3) Test that the C++ interface 'gc_cpp.cc/h' works with 'test_cpp.cc'.\n+\n+The test app is just an ordinary ANSI-C console app. Make sure settings match\n+the library you're testing.\n+\n+Files\n+-----\n+    test_cpp.cc\n+    the GC library to test        -- link order before ANSI libs\n+    suitable Mac+ANSI libraries\n+\n+prefix:\n+------\n+same as for test.c\n+\n+For convenience I used one test-project with several targets so that all\n+test apps are build at once. Two for each library to test: test.c and\n+gc_app.cc. When I was satisfied that the libraries were ok. I put the\n+libraries + gc.h + the c++ interface-file in a folder that I then put into\n+the MSL hierarchy so that I don't have to alter access-paths in projects\n+that use the GC.\n+\n+After that, just add the proper GC library to your project and the GC is in\n+action! malloc will call GC_malloc and free GC_free, new/delete too. You\n+don't have to call free or delete. You may have to be a bit cautious about\n+delete if you're freeing other resources than RAM. See gc_cpp.h. You can\n+also keep coding as always with delete/free. That works too. If you want,\n+\"include <gc.h> and tweak it's use a bit.\n+\n+Symantec SPM\n+============\n+It has been a while since I tried the GC in SPM, but I think that the above\n+instructions should be sufficient to guide you through in SPM too. SPM\n+needs to know where the global data is. Use the files 'datastart.c' and\n+'dataend.c'. Put 'datastart.c' at the top of your project and 'dataend.c'\n+at the bottom  of your project so that all data is surrounded. This is not\n+needed in Codewarrior because it provides intrinsic variables\n+__datastart__, __data_end__ that wraps all globals.\n+\n+Source Changes (GC 4.12a2)\n+==========================\n+Very few. Just one tiny in the GC, not strictly needed.\n+- MacOS.c line 131 in routine GC_MacFreeTemporaryMemory()\n+  change #       if !defined(SHARED_LIBRARY_BUILD)\n+  to     #       if !defined(SILENT) && !defined(SHARED_LIBRARY_BUILD)\n+  To turn off a message when the application quits (actually, I faked\n+  this change by #defining SHARED_LIBRARY_BUILD in a statically linked\n+  library for more than a year without ill effects but perhaps this is\n+  better).\n+\n+- test_cpp.cc\n+  made the first lines of main() look like this:\n+  ------------\n+  int main( int argc, char* argv[] ) {\n+  #endif\n+  #if macintosh                             // MacOS\n+    char* argv_[] = {\"test_cpp\",\"10\"};      //   doesn't\n+    argv=argv_;                             //     have a\n+    argc = sizeof(argv_)/sizeof(argv_[0]);  //       commandline\n+  #endif                                    //\n+\n+  int i, iters, n;\n+  # ifndef __GNUC__\n+   alloc dummy_to_fool_the_compiler_into_doing_things_it_currently_cant_handle;\n+  ------------\n+\n+- config.h\n+  __MWERKS__ does not have to mean MACOS. You can use Codewarrior to\n+  build a Win32 or BeOS library and soon a Rhapsody library. You may\n+  have to change that #if...\n+\n+\n+\n+   It worked for me, hope it works for you.\n+\n+   Lars Farm\n+   18 July 1997\n+----------------------------------------------------------------------------\n+\n+\n+Patrick Beard's instructions (may be dated):\n+\n+v4.3 of the collector now runs under Symantec C++/THINK C v7.0.4, and\n+Metrowerks C/C++ v4.5 both 68K and PowerPC. Project files are provided\n+to build and test the collector under both development systems.\n+\n+Configuration\n+-------------\n+\n+To configure the collector, under both development systems, a prefix file\n+is used to set preprocessor directives. This file is called \"MacOS_config.h\".\n+Also to test the collector, \"MacOS_Test_config.h\" is provided.\n+\n+Testing\n+-------\n+\n+To test the collector (always a good idea), build one of the gctest projects,\n+gctest.\ufffd (Symantec C++/THINK C), mw/gctest.68K.\ufffd, or mw/gctest.PPC.\ufffd. The\n+test will ask you how many times to run; 1 should be sufficient.\n+\n+Building \n+--------\n+\n+For your convenience project files for the major Macintosh development\n+systems are provided.\n+\n+For Symantec C++/THINK C, you must build the two projects gclib-1.\ufffd and\n+gclib-2.\ufffd. It has to be split up because the collector has more than 32k\n+of static data and no library can have more than this in the Symantec\n+environment. (Future versions will probably fix this.)\n+\n+For Metrowerks C/C++ 4.5 you build gc.68K.\ufffd/gc.PPC.\ufffd and the result will\n+be a library called gc.68K.lib/gc.PPC.lib.\n+\n+Using\n+-----\n+\n+Under Symantec C++/THINK C, you can just add the gclib-1.\ufffd and gclib-2.\ufffd\n+projects to your own project. Under Metrowerks, you add gc.68K.lib or\n+gc.PPC.lib and two additional files. You add the files called datastart.c\n+and dataend.c to your project, bracketing all files that use the collector.\n+See mw/gctest.\ufffd for an example.\n+\n+Include the projects/libraries you built above into your own project,\n+#include \"gc.h\", and call GC_malloc. You don't have to call GC_free.\n+\n+\n+Patrick C. Beard\n+January 4, 1995"}, {"sha": "5345bbd0f654592d01fcb0f4a6ae5fb1cac0170a", "filename": "boehm-gc/README.OS2", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.OS2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.OS2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.OS2?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,6 @@\n+The code assumes static linking, and a single thread.  The editor de has\n+not been ported.  The cord test program has.  The supplied OS2_MAKEFILE\n+assumes the IBM C Set/2 environment, but the code shouldn't.\n+\n+Since we haven't figured out hoe to do perform partial links or to build static\n+libraries, clients currently need to link against a long list of executables."}, {"sha": "3273c8ba4ebcddc82a670c48ebb498b170689b8c", "filename": "boehm-gc/README.QUICK", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.QUICK", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.QUICK", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.QUICK?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,41 @@\n+Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+\n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+Permission is hereby granted to use or copy this program\n+for any purpose,  provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is granted,\n+provided the above notices are retained, and a notice that the code was\n+modified is included with the above copyright notice.\n+\n+\n+For more details and the names of other contributors, see the\n+README file and gc.h.  This file describes typical use of\n+the collector on a machine that is already supported.\n+\n+INSTALLATION:\n+Under UN*X, type \"make test\".  Under OS/2 or Windows NT, copy the\n+appropriate makefile to MAKEFILE, read it, and type \"nmake test\".\n+Read the machine specific README if one exists.  The only way to\n+develop code with the collector for Windows 3.1 is to develop under\n+Windows NT, and then to use win32S.\n+\n+If you wish to use the cord (structured string) library type\n+\"make cords\". (This requires an ANSI C compiler.  You may need\n+to redefine CC in the Makefile.)\n+\n+If you wish to use the collector from C++, type\n+\"make c++\".  These add further files to gc.a and to the include\n+subdirectory.  See cord/cord.h and gc_c++.h.\n+\n+TYPICAL USE:\n+Include \"gc.h\" from this directory.  Link against the appropriate library\n+(\"gc.a\" under UN*X).  Replace calls to malloc by calls to GC_MALLOC,\n+and calls to realloc by calls to GC_REALLOC.  If the object is known\n+to never contain pointers, use GC_MALLOC_ATOMIC instead of\n+GC_MALLOC.\n+\n+Define GC_DEBUG before including gc.h for additional checking.\n+"}, {"sha": "b187fd5bc45a7706941f344eacc6fbfbd1d0226e", "filename": "boehm-gc/README.alpha", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.alpha", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.alpha", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.alpha?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,15 @@\n+Should work under OSF/1 and Linux.  Currently no VMS or NT support, though\n+the latter shouldn't be hard.\n+\n+Incremental gc not yet supported under Linux because signal handler\n+for SIGSEGV can't get a hold of fault address.  Dynamic library support\n+is also missing from Linux/alpha, probably for no good reason.\n+\n+From Philippe Queinnec:\n+\n+System: DEC/Alpha OSF1 v3.2, vendor cc\n+Problem: can't link if libgc has been compiled with \"cc -std1\".\n+         It works if the library has been compiled with either gcc or \"cc\"\n+         alone. The problem is because the variable \"end\" is not defined if\n+         compiling in std1 mode (see man ld).\n+Proposed fix: none. Don't use cc -std1 !"}, {"sha": "865642be4b412e406b6d5eb6ed1f7812175c3bec", "filename": "boehm-gc/README.amiga", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.amiga?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,133 @@\n+\n+===========================================================================\n+\t\t\t   Michel Schinz's notes\n+===========================================================================\n+WHO DID WHAT\n+\n+The original Amiga port was made by Jesper Peterson. I (Michel Schinz)\n+modified it slightly to reflect the changes made in the new official\n+distributions, and to take advantage of the new SAS/C 6.x features. I also\n+created a makefile to compile the \"cord\" package (see the cord\n+subdirectory).\n+\n+TECHNICAL NOTES\n+\n+In addition to Jesper's notes, I have the following to say:\n+\n+- Starting with version 4.3, gctest checks to see if the code segment is\n+  added to the root set or not, and complains if it is. Previous versions\n+  of this Amiga port added the code segment to the root set, so I tried to\n+  fix that. The only problem is that, as far as I know, it is impossible to\n+  know which segments are code segments and which are data segments (there\n+  are indeed solutions to this problem, like scanning the program on disk\n+  or patch the LoadSeg functions, but they are rather complicated). The\n+  solution I have chosen (see os_dep.c) is to test whether the program\n+  counter is in the segment we are about to add to the root set, and if it\n+  is, to skip the segment. The problems are that this solution is rather\n+  awkward and that it works only for one code segment. This means that if\n+  your program has more than one code segment, all of them but one will be\n+  added to the root set. This isn't a big problem in fact, since the\n+  collector will continue to work correctly, but it may be slower.\n+\n+  Anyway, the code which decides whether to skip a segment or not can be\n+  removed simply by not defining AMIGA_SKIP_SEG. But notice that if you do\n+  so, gctest will complain (it will say that \"GC_is_visible produced wrong\n+  failure indication\"). However, it may be useful if you happen to have\n+  pointers stored in a code segment (you really shouldn't).\n+\n+  If anyone has a good solution to the problem of finding, when a program\n+  is loaded in memory, whether a segment is a code or a data segment,\n+  please let me know.\n+\n+PROBLEMS\n+\n+If you have any problem with this version, please contact me at\n+schinz@alphanet.ch (but do *not* send long files, since we pay for\n+every mail!).\n+\n+===========================================================================\n+\t\t\t  Jesper Peterson's notes\n+===========================================================================\n+\n+ADDITIONAL NOTES FOR AMIGA PORT\n+\n+These notes assume some familiarity with Amiga internals.\n+\n+WHY I PORTED TO THE AMIGA\n+\n+The sole reason why I made this port was as a first step in getting\n+the Sather(*) language on the Amiga. A port of this language will\n+be done as soon as the Sather 1.0 sources are made available to me.\n+Given this motivation, the garbage collection (GC) port is rather\n+minimal.\n+\n+(*) For information on Sather read the comp.lang.sather newsgroup.\n+\n+LIMITATIONS\n+\n+This port assumes that the startup code linked with target programs\n+is that supplied with SAS/C versions 6.0 or later. This allows\n+assumptions to be made about where to find the stack base pointer\n+and data segments when programs are run from WorkBench, as opposed\n+to running from the CLI. The compiler dependent code is all in the\n+GC_get_stack_base() and GC_register_data_segments() functions, but\n+may spread as I add Amiga specific features.\n+\n+Given that SAS/C was assumed, the port is set up to be built with\n+\"smake\" using the \"SMakefile\". Compiler options in \"SCoptions\" can\n+be set with \"scopts\" program. Both \"smake\" and \"scopts\" are part of\n+the SAS/C commercial development system.\n+\n+In keeping with the porting philosophy outlined above, this port\n+will not behave well with Amiga specific code. Especially not inter-\n+process comms via messages, and setting up public structures like\n+Intuition objects or anything else in the system lists. For the\n+time being the use of this library is limited to single threaded\n+ANSI/POSIX  compliant or near-complient code. (ie. Stick to stdio\n+for now). Given this limitation there is currently no mechanism for\n+allocating \"CHIP\" or \"PUBLIC\" memory under the garbage collector.\n+I'll add this after giving it considerable thought. The major\n+problem is the entire physical address space may have to me scanned,\n+since there is no telling who we may have passed memory to.\n+\n+If you allocate your own stack in client code, you will have to\n+assign the pointer plus stack size to GC_stackbottom.\n+\n+The initial stack size of the target program can be compiled in by\n+setting the __stack symbol (see SAS documentaion). It can be over-\n+ridden from the CLI by running the AmigaDOS \"stack\" program, or from\n+the WorkBench by setting the stack size in the tool types window.\n+\n+SAS/C COMPILER OPTIONS (SCoptions)\n+\n+You may wish to check the \"CPU\" code option is appropriate for your\n+intended target system.\n+\n+Under no circumstances set the \"StackExtend\" code option in either\n+compiling the library or *ANY* client code.\n+\n+All benign compiler warnings have been suppressed. These mainly\n+involve lack of prototypes in the code, and dead assignments\n+detected by the optimizer.\n+\n+THE GOOD NEWS\n+\n+The library as it stands is compatible with the GigaMem commercial\n+virtual memory software, and probably similar PD software.\n+\n+The performance of \"gctest\" on an Amiga 2630 (68030 @ 25Mhz)\n+compares favourably with an HP9000 with similar architecture (a 325\n+with a 68030 I think).\n+\n+-----------------------------------------------------------------------\n+\n+The Amiga port has been brought to you by:\n+\n+Jesper Peterson.\n+\n+jep@mtiame.mtia.oz.au\t\t(preferred, but 1 week turnaround)\n+jep@orca1.vic.design.telecom.au (that's orca<one>, 1 day turnaround)\n+\n+At least one of these addresses should be around for a while, even\n+though I don't work for either of the companies involved.\n+"}, {"sha": "80635c2230168890518d56785419d33318d4b08f", "filename": "boehm-gc/README.debugging", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.debugging", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.debugging", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.debugging?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,58 @@\n+Debugging suggestions:\n+\n+****If you get a segmentation fault or bus error while debugging with a debugger:\n+If the fault occurred in GC_find_limit, or with incremental collection enabled, this is probably normal.  The collector installs handlers to take care of these.  You will not see these unless you are using a debugger.  Your debugger should allow you to continue.  It's preferable to tell the debugger to ignore SIGBUS and SIGSEGV (\"handle\" in gdb, \"ignore\" in most versions of dbx) and set a breakpoint in abort.  The collector will call abort if the signal had another cause, and there was not other handler previously installed.  I recommend debugging without incremental collection if possible.  (This applies directly to UNIX systems.  Debugging with incremental collection under win32 is worse.  See README.win32.)  \n+\n+****If you get warning messages informing you that the collector needed to allocate blacklisted blocks:\n+\n+0) Ignore these warnings while you are using GC_DEBUG.  Some of the routines mentioned below don't have debugging equivalents.  (Alternatively, write the missing routines and send them to me.)\n+\n+1) Replace allocator calls that request large blocks with calls to GC_malloc_ignore_off_page or GC_malloc_atomic_ignore_off_page.  You may want to set a breakpoint in GC_default_warn_proc to help you identify such calls.  Make sure that a pointer to somewhere near the beginning of the resulting block is maintained in a (preferably volatile) variable as long as the block is needed.\n+\n+2) If the large blocks are allocated with realloc, I suggest instead allocating them with something like the following.  Note that the realloc size increment should be fairly large (e.g. a factor of 3/2) for this to exhibit reasonable performance.  But we all know we should do that anyway.\n+\n+void * big_realloc(void *p, size_t new_size)\n+{\n+    size_t old_size = GC_size(p);\n+    void * result;\n+ \n+    if (new_size <= 10000) return(GC_realloc(p, new_size));\n+    if (new_size <= old_size) return(p);\n+    result = GC_malloc_ignore_off_page(new_size);\n+    if (result == 0) return(0);\n+    memcpy(result,p,old_size);\n+    GC_free(p);\n+    return(result);\n+}\n+\n+3) In the unlikely case that even relatively small object (<20KB) allocations are triggering these warnings, then your address space contains lots of \"bogus pointers\", i.e. values that appear to be pointers but aren't.  Usually this can be solved by using GC_malloc_atomic or the routines in gc_typed.h to allocate large pointerfree regions of bitmaps, etc.  Sometimes the problem can be solved with trivial changes of encoding in certain values.  It is possible, though not pleasant, to identify the source of the bogus pointers by setting a breakpoint in GC_add_to_black_list_stack, and looking at the value of current_p in the GC_mark_from_mark_stack frame.  Current_p contains the address of the bogus pointer.\n+\n+4) If you get only a fixed number of these warnings, you are probably only introducing a bounded leak by ignoring them.  If the data structures being allocated are intended to be permanent, then it is also safe to ignore them.  The warnings can be turned off by calling GC_set_warn_proc with a procedure that ignores these warnings (e.g. by doing absolutely nothing).\n+\n+\n+****If the collector dies in GC_malloc while trying to remove a free list element:\n+\n+1) With > 99% probability, you wrote past the end of an allocated object.  Try setting GC_DEBUG and using the debugging facilities in gc.h.\n+\n+\n+****If the heap grows too much:\n+\n+1) Consider using GC_malloc_atomic for objects containing nonpointers.  This is especially important for large arrays containg compressed data, pseudo-random numbers, and the like.  (This isn't all that likely to solve your problem, but it's a useful and easy optimization anyway, and this is a good time to try it.)   If you allocate large objects containg only one or two pointers at the beginning, either try the typed allocation primitives is gc.h, or separate out the pointerfree component.\n+2) If you are using the collector in its default mode, with interior pointer recognition enabled, consider using GC_malloc_ignore_off_page to allocate large objects.  (See gc.h and above for details.  Large means > 100K in most environments.)\n+3) GC_print_block_list() will print a list of all currently allocated heap blocks and what size objects they contain.  GC_print_hblkfreelist() will print a list of free heap blocks, and whether they are blacklisted.  GC_dump calls both of these, and also prints information about heap sections, and root segments.\n+4) Write a tool that traces back references to the appropriate root.  Send me the code.  (I have code that does this for old PCR.)\n+\n+\n+****If the collector appears to be losing objects:\n+\n+1) Replace all calls to GC_malloc_atomic and typed allocation by GC_malloc calls.  If this fixes the problem, gradually reinsert your optimizations.\n+2) You may also want to try the safe(r) pointer manipulation primitives in gc.h.  But those are hard to use until the preprocessor becomes available.\n+3) Try using the GC_DEBUG facilities.  This is less likely to be successful here than if the collector crashes.\n+[The rest of these are primarily for wizards.  You shouldn't need them unless you're doing something really strange, or debugging a collector port.]\n+4) Don't turn on incremental collection.  If that fixes the problem, suspect a bug in the dirty bit implementation.  Try compiling with -DCHECKSUMS to check for modified, but supposedly clean, pages.\n+5) On a SPARC, in a single-threaded environment, GC_print_callers(GC_arrays._last_stack) prints a cryptic stack trace as of the time of the last collection.  (You will need a debugger to decipher the result.)  The question to ask then is \"why should this object have been accessible at the time of the last collection?  Where was a pointer to it stored?\".  This facility should be easy to add for some other collector ports (namely if it's easy to traverse stack frames), but will be hard for others.\n+6) \"print *GC_find_header(p)\" in dbx or gdb will print the garbage collector block header information associated with the object p (e.g. object size, etc.)\n+7) GC_is_marked(p) determines whether p is the base address of a marked object.  Note that objects allocated since the last collection should not be marked, and that unmarked objects are reclaimed incrementally.  It's usually most interesting to set a breakpoint in GC_finish_collection and then to determine how much of the damaged data structure is marked at that point.\n+8) Look at the tracing facility in mark.c.  (Ignore this suggestion unless you are very familiar with collector internals.)\n+\n+"}, {"sha": "613bc423cb147d95368108f3fe233047d632d0d4", "filename": "boehm-gc/README.dj", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.dj?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,12 @@\n+[Original version supplied by Xiaokun Zhu <xiaokun@aero.gla.ac.uk>]\n+[This version came mostly from Gary Leavens.\t\t\t  ]\n+\n+Look first at Makefile.dj, and possibly change the definitions of\n+RM and MV if you don't have rm and mv installed.\n+Then use Makefile.dj to compile the garbage collector.\n+For example, you can do:\n+\n+\tmake -f Makefile.dj test\n+\n+All the tests should work fine.\n+"}, {"sha": "869aaea67c1d97671660cb3e63a7439e478a3a99", "filename": "boehm-gc/README.hp", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.hp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.hp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.hp?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,9 @@\n+Dynamic loading support requires that executables be linked with -ldld.\n+The alternative is to build the collector without defining DYNAMIC_LOADING\n+in config.h and ensuring that all garbage collectable objects are\n+accessible without considering statically allocated variables in dynamic\n+libraries.\n+\n+The collector should compile with either plain cc or cc -Ae.  CC -Aa\n+fails to define _HPUX_SOURCE and thus will not configure the collector\n+correctly."}, {"sha": "ffe735bc1824145789c692c30d599ea1a547817b", "filename": "boehm-gc/README.linux", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.linux?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,39 @@\n+See README.alpha for Linux on DEC AXP info.  This file applies to\n+Linux/Intel.\n+\n+Incremental GC is supported.\n+\n+Dynamic libraries are supported on an ELF system.  A static executable\n+should be linked with the gcc option \"-Wl,-defsym,_DYNAMIC=0\".\n+\n+The collector appears to work with Linux threads.  We have seen\n+intermittent hangs in sem_wait.  So far we have been unable to reproduce\n+these unless the process was being debugged or traced.  Thus it's\n+possible that the only real issue is that the debugger loses\n+signals on rare occasions.\n+\n+The garbage collector uses SIGPWR and SIGXCPU if it is used with\n+Linux threads.  These should not be touched by the client program.\n+\n+To use threads, you need to abide by the following requirements:\n+\n+1) You need to use LinuxThreads (which are included in libc6).\n+\n+   The collector relies on some implementation details of the LinuxThreads\n+   package.  It is unlikely that this code will work on other\n+   pthread implementations (in particular it will *not* work with\n+   MIT pthreads).\n+\n+2) You must compile the collector with -DLINUX_THREADS and -D_REENTRANT\n+   specified in the Makefile.\n+\n+3) Every file that makes thread calls should define LINUX_THREADS and \n+   _REENTRANT and then include gc.h.  Gc.h redefines some of the\n+   pthread primitives as macros which also provide the collector with\n+   information it requires.\n+\n+4) Currently dlopen() is probably not safe.  The collector must traverse\n+   the list of libraries maintained by the runtime loader.  That can\n+   probably be an inconsistent state when a thread calling the loader is\n+   is stopped for GC.  (It's possible that this is fixable in the\n+   same way it is handled for SOLARIS_THREADS, with GC_dlopen.)"}, {"sha": "0444ac4cce07af0f5976fb5e8b810e372d7dfdf6", "filename": "boehm-gc/README.rs6000", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.rs6000?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,6 @@\n+We have so far failed to find a good way to determine the stack base.\n+It is highly recommended that GC_stackbottom be set explicitly on program\n+startup.  The supplied value sometimes causes failure under AIX 4.1, though\n+it appears to work under 3.X.  HEURISTIC2 seems to work under 4.1, but\n+involves a substantial performance penalty, and will fail if there is\n+no limit on stack size."}, {"sha": "186e49771062e0f63b005b2439820ad493f9f6d1", "filename": "boehm-gc/README.sgi", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.sgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.sgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.sgi?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,37 @@\n+Performance of the incremental collector can be greatly enhanced with\n+-DNO_EXECUTE_PERMISSION.\n+\n+The collector should run with all of the -32, -n32 and -64 ABIs.  Remember to\n+define the AS macro in the Makefile to be \"as -64\", or \"as -n32\".\n+\n+If you use -DREDIRECT_MALLOC=GC_malloc with C++ code, your code should make\n+at least one explicit call to malloc instead of new to ensure that the proper\n+version of malloc is linked in.\n+\n+Sproc threads are not supported in this version, though there may exist other\n+ports.\n+\n+Pthreads support is provided.  This requires that:\n+\n+1) You compile the collector with -DIRIX_THREADS specified in the Makefile.\n+\n+2) You have the latest pthreads patches installed.  \n+\n+(Though the collector makes only documented pthread calls,\n+it relies on signal/threads interactions working just right in ways\n+that are not required by the standard.  It is unlikely that this code\n+will run on other pthreads platforms.  But please tell me if it does.)\n+\n+3) Every file that makes thread calls should define IRIX_THREADS and then\n+include gc.h.  Gc.h redefines some of the pthread primitives as macros which\n+also provide the collector with information it requires.\n+\n+4) pthread_cond_wait and pthread_cond_timed_wait should be prepared for\n+premature wakeups.  (I believe the pthreads and realted standards require this\n+anyway.  Irix pthreads often terminate a wait if a signal arrives.\n+The garbage collector uses signals to stop threads.)\n+\n+5) It is expensive to stop a thread waiting in IO at the time the request is\n+initiated.  Applications with many such threads may not exhibit acceptable\n+performance with the collector.  (Increasing the heap size may help.)\n+"}, {"sha": "9ef4648d04a5b1919aaa3dc15876d5a8b9b10943", "filename": "boehm-gc/README.solaris2", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.solaris2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.solaris2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.solaris2?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,65 @@\n+The collector supports both incremental collection and threads under\n+Solaris 2.  The incremental collector normally retrieves page dirty information\n+through the appropriate /proc calls.  But it can also be configured\n+(by defining MPROTECT_VDB instead of PROC_VDB in config.h) to use mprotect\n+and signals.  This may result in shorter pause times, but it is no longer\n+safe to issue arbitrary system calls that write to the heap.\n+\n+Under other UNIX versions,\n+the collector normally obtains memory through sbrk.  There is some reason\n+to expect that this is not safe if the client program also calls the system\n+malloc, or especially realloc.  The sbrk man page strongly suggests this is\n+not safe: \"Many library routines use malloc() internally, so use brk()\n+and sbrk() only when you know  that malloc() definitely will not be used by\n+any library routine.\"  This doesn't make a lot of sense to me, since there\n+seems to be no documentation as to which routines can transitively call malloc.\n+Nonetheless, under Solaris2, the collector now (since 4.12) allocates\n+memory using mmap by default.  (It defines USE_MMAP in config.h.)\n+You may want to reverse this decisions if you use -DREDIRECT_MALLOC=...\n+\n+\n+SOLARIS THREADS:\n+\n+The collector must be compiled with -DSOLARIS_THREADS to be thread safe.\n+It is also essential that gc.h be included in files that call thr_create,\n+thr_join, thr_suspend, thr_continue, or dlopen.  Gc.h macro defines\n+these to also do GC bookkeeping, etc.  Gc.h must be included with\n+SOLARIS_THREADS defined, otherwise these replacements are not visible.\n+A collector built in this way way only be used by programs that are\n+linked with the threads library.\n+\n+If you are using the Pthreads interface, also define _SOLARIS_PTHREADS.\n+\n+In this mode, the collector contains various workarounds for older Solaris\n+bugs.  Mostly, these should not be noticeable unless you look at system\n+call traces.  However, it cannot protect a guard page at the end of\n+a thread stack.  If you know that you will only be running Solaris2.5\n+or later, it should be possible to fix this by compiling the collector\n+with -DSOLARIS23_MPROTECT_BUG_FIXED.\n+\n+Jeremy Fitzhardinge points out that there is a problem with the dlopen\n+replacement, in that startup code in the library is run while the allocation\n+lock is held.  This appears to be difficult to fix, since the collector does\n+look at data structures maintained by dlopen, and hence some locking is needed\n+around the dlopen call.  Defining USE_PROC_FOR_LIBRARIES will get address\n+space layout information from /proc avoiding the dlopen lock.  But this has\n+other disadvanatages, e.g. mmapped files may be scanned.\n+\n+If solaris_threads are used on an X86 processor with malloc redirected to\n+GC_malloc, it is necessary to call GC_thr_init explicitly before forking the\n+first thread.  (This avoids a deadlock arising from calling GC_thr_init\n+with the allocation lock held.)\n+\n+It appears that there is a problem in using gc_cpp.h in conjunction with\n+Solaris threads and Sun's C++ runtime.  Apparently the overloaded new operator\n+is invoked by some iostream initialization code before threads are correctly\n+initialized.  As a result, call to thr_self() in garbage collector\n+initialization  segfaults.  Currently the only known workaround is to not\n+invoke the garbage collector from a user defined global operator new, or to\n+have it invoke the garbage-collector's allocators only after main has started.\n+(Note that the latter requires a moderately expensive test in operator\n+delete.)\n+\n+Hans-J. Boehm\n+(The above contains my personal opinions, which are probably not shared\n+by anyone else.)"}, {"sha": "6be49667d7b8852c8b38845514ad597e08a01184", "filename": "boehm-gc/README.uts", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.uts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.uts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.uts?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,2 @@\n+Alistair Crooks supplied the port.  He used Lexa C version 2.1.3 with\n+-Xa to compile."}, {"sha": "76c4c6e38165d8c64282182d50c19bf467982c09", "filename": "boehm-gc/README.win32", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.win32?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,163 @@\n+The collector has only been compiled under Windows NT, with the\n+original Microsoft SDK, with Visual C++ 2.0 and later, with\n+the GNU win32 environment, with Borland 4.5, and recently with\n+Watcom C.\n+\n+It runs under both win32s and win32, but with different semantics.\n+Under win32, all writable pages outside of the heaps and stack are\n+scanned for roots.  Thus the collector sees pointers in DLL data\n+segments.  Under win32s, only the main data segment is scanned.\n+(The main data segment should always be scanned.  Under some\n+versions of win32s, other regions may also be scanned.)\n+Thus all accessible objects should be accessible from local variables\n+or variables in the main data segment.  Alternatively, other data\n+segments (e.g. in DLLs) may be registered with the collector by\n+calling GC_init() and then GC_register_root_section(a), where\n+a is the address of some variable inside the data segment.  (Duplicate\n+registrations are ignored, but not terribly quickly.)\n+\n+(There are two reasons for this.  We didn't want to see many 16:16\n+pointers.  And the VirtualQuery call has different semantics under\n+the two systems, and under different versions of win32s.)\n+\n+The collector test program \"gctest\" is linked as a GUI application,\n+but does not open any windows.  Its output appears in the file\n+\"gc.log\".  It may be started from the file manager.  The hour glass\n+cursor will appear as long as it's running.\n+\n+The cord test program has not been ported (but should port\n+easily).  A toy editor (cord/de.exe) based on cords (heavyweight\n+strings represented as trees) has been ported and is included.\n+It runs fine under either win32 or win32S.  It serves as an example\n+of a true Windows application, except that it was written by a\n+nonexpert Windows programmer.  (There are some peculiarities\n+in the way files are displayed.  The <cr> is displayed explicitly\n+for standard DOS text files.  As in the UNIX version, control\n+characters are displayed explicitly, but in this case as red text.\n+This may be suboptimal for some tastes and/or sets of default\n+window colors.)\n+\n+For Microsoft development tools, rename NT_MAKEFILE as\n+MAKEFILE.  (Make sure that the CPU environment variable is defined\n+to be i386.)\n+\n+For GNU-win32, use the regular makefile, possibly after uncommenting\n+the line \"include Makefile.DLLs\".  The latter should be necessary only\n+if you want to package the collector as a DLL.  The GNU-win32 port is\n+believed to work only for b18, not b19, probably dues to linker changes\n+in b19.  This is probably fixable with a different definition of\n+DATASTART and DATAEND in config.h.\n+\n+For Borland tools, use BCC_MAKEFILE.  Note that\n+Borland's compiler defaults to 1 byte alignment in structures (-a1),\n+whereas Visual C++ appears to default to 8 byte alignment (/Zp8).\n+The garbage collector in its default configuration EXPECTS AT\n+LEAST 4 BYTE ALIGNMENT.  Thus the BORLAND DEFAULT MUST\n+BE OVERRIDDEN.  (In my opinion, it should usually be anyway.\n+I expect that -a1 introduces major performance penalties on a\n+486 or Pentium.)  Note that this changes structure layouts.  (As a last\n+resort, config.h can be changed to allow 1 byte alignment.  But\n+this has significant negative performance implications.)\n+The Makefile is set up to assume Borland 4.5.  If you have another\n+version, change the line near the top.  By default, it does not\n+require the assembler.  If you do have the assembler, I recommend\n+removing the -DUSE_GENERIC.\n+\n+Incremental collection support was recently added.  This is\n+currently pretty simpleminded.  Pages are protected.  Protection\n+faults are caught by a handler installed at the bottom of the handler\n+stack.  This is both slow and interacts poorly with a debugger.\n+Whenever possible, I recommend adding a call to\n+GC_enable_incremental at the last possible moment, after most\n+debugging is complete.  Unlike the UNIX versions, no system\n+calls are wrapped by the collector itself.  It may be necessary\n+to wrap ReadFile calls that use a buffer in the heap, so that the\n+call does not encounter a protection fault while it's running.\n+(As usual, none of this is an issue unless GC_enable_incremental\n+is called.)\n+\n+Note that incremental collection is disabled with -DSMALL_CONFIG,\n+which is the default for win32.  If you need incremental collection,\n+undefine SMALL_CONFIG.\n+\n+Incremental collection is not supported under win32s, and it may not\n+be possible to do so.  However, win32 applications that attempt to use\n+incremental collection should continue to run, since the\n+collector detects if it's running under win32s and turns calls to\n+GC_enable_incremental() into noops.\n+\n+James Clark has contributed the necessary code to support win32 threads.\n+This code is known to exhibit some problems with incremental collection\n+enabled.  Use NT_THREADS_MAKEFILE (a.k.a gc.mak) instead of NT_MAKEFILE\n+to build this version.  Note that this requires some files whose names\n+are more than 8 + 3 characters long.  Thus you should unpack the tar file\n+so that long file names are preserved.  To build the garbage collector\n+test with VC++ from the command line, use\n+\n+nmake /F \".\\gc.mak\" CFG=\"gctest - Win32 Release\"\n+\n+This requires that the subdirectory gctest\\Release exist.\n+\n+This version relies on the collector residing in a dll.\n+\n+This version currently supports incremental collection only if it is\n+enabled before any additional threads are created.\n+It is known to not be completely solid.  At a minimum it can deadlock\n+if a thread starts in the middle of an allocation.  There may be\n+other problems.  If you need solid support for win32 threads, you\n+check with Geodesic Systems.  I haven't tried it, but they claim\n+to support it.\n+\n+Hans\n+\n+Ivan V. Demakov's README for the Watcom port:\n+\n+[ He points out in a later message that there may be a problem compiling\n+  under Windows-3.11 for Windows NT. ]\n+\n+Watcom C/C++ 10.5, 10.6, 11.0 tested.\n+\n+The collector runs on WIN32 and DOS4GW dos-extender with both\n+stack and register based calling conventions (options -5r and -5s).\n+Incremental collection not supported.\n+\n+OS/2 not tested, but should work (only some #ifdef's added for OS/2 port).\n+\n+cord not ported. Watcom C fails to compile it, from first attempt.\n+Since I don't use it, I don't try to fix it.\n+\n+cpp_test succeeds, but not compiled automaticaly with WCC_MAKEFILE.\n+\n+\n+My changes:\n+\n+      * config.h      Added definitions for Watcom C/C++.\n+                      Undefined MPROTECT_VDB for Watcom C/C++ MSWIN32,\n+                      I don't have idea why it not work.\n+\n+      * gc.h          Explicitly declared GC_noop. This prevents\n+                      program crash, compiled with -5r option.\n+\n+      * gc_priv.h     Changed declaration for GC_push_one to make\n+                      compiler happy.\n+                      Added GC_dos4gw_get_mem declaration and\n+                      GET_MEM uses it in DOS4GW environment.\n+\n+      * os_dep.c      Added __WATCOMC__ and DOS4GW #ifdef's.\n+                      Added GC_dos4gw_get_mem.\n+\n+      * mach_dep.c    For Watcom used setjmp method of marking registers.\n+\n+      * WCC_MAKEFILE  New file. Makefile for Watcom C/C++.\n+\n+      * gc_watcom.asm New file. Some functions for DOS4GW.\n+                      This functions may (probably) be done in C,\n+                      but I can't figure out how do this for all\n+                      possible options of compiler.\n+\n+      * README.watcom This file.\n+\n+\n+  Ivan Demakov (email: dem@tgrad.nsk.su)\n+\n+"}, {"sha": "a61e0cb1f04d9ace58d42d08f7fbc06370c20397", "filename": "boehm-gc/SCoptions.amiga", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FSCoptions.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FSCoptions.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FSCoptions.amiga?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,16 @@\n+CPU=68030\n+NOSTACKCHECK\n+OPTIMIZE\n+VERBOSE\n+MAPHUNK\n+NOVERSION\n+NOICONS\n+OPTIMIZERTIME\n+DEFINE SILENT\n+DEFINE AMIGA_SKIP_SEG\n+IGNORE=85\n+IGNORE=154\n+IGNORE=161\n+IGNORE=100\n+OPTIMIZERCOMPLEXITY=4\n+OPTIMIZERDEPTH=3"}, {"sha": "b1aa340e5383d1db1537bd1cd9ec6ff8fabd3ac3", "filename": "boehm-gc/SMakefile.amiga", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FSMakefile.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FSMakefile.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FSMakefile.amiga?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,48 @@\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o\n+\n+INC=  gc_private.h gc_hdrs.h gc.h config.h\n+\n+all: gctest setjmp_t\n+\n+alloc.o : alloc.c $(INC)\n+reclaim.o : reclaim.c $(INC)\n+allchblk.o : allchblk.c $(INC)\n+misc.o : misc.c $(INC)\n+os_dep.o : os_dep.c $(INC)\n+mark_rts.o : mark_rts.c $(INC)\n+headers.o : headers.c $(INC)\n+mark.o : mark.c $(INC)\n+obj_map.o : obj_map.c $(INC)\n+blacklst.o : blacklst.c $(INC)\n+finalize.o : finalize.c $(INC)\n+  sc noopt finalize.c # There seems to be a bug in the optimizer (V6.51).\n+                      # gctest won't work if you remove this...\n+new_hblk.o : new_hblk.c $(INC)\n+real_malloc.o : real_malloc.c $(INC)\n+dyn_load.o : dyn_load.c $(INC)\n+dbg_mlc.o : dbg_mlc.c $(INC)\n+malloc.o : malloc.c $(INC)\n+mallocx.o : malloc.c $(INC)\n+stubborn.o : stubborn.c $(INC)\n+checksums.o : checksums.c $(INC)\n+typd_mlc.o: typd_mlc.c $(INC)\n+mach_dep.o : mach_dep.c $(INC)\n+ptr_chck.o: ptr_chck.c $(INC)\n+test.o : test.c $(INC)\n+\n+gc.lib: $(OBJS)\n+   oml gc.lib r $(OBJS)\n+\n+clean:\n+   delete gc.lib gctest setjmp_t \\#?.o\n+\n+gctest: gc.lib test.o\n+   slink LIB:c.o test.o to $@ lib gc.lib LIB:sc.lib LIB:scm.lib\n+\n+setjmp_t: setjmp_t.c gc.h\n+   sc setjmp_t.c\n+   slink LIB:c.o $@.o to $@ lib LIB:sc.lib\n+\n+test: setjmp_t gctest\n+   setjmp_t\n+   gctest"}, {"sha": "cc0ef1367421d883617da72af1c4432e0799d0de", "filename": "boehm-gc/WCC_MAKEFILE", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FWCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2FWCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FWCC_MAKEFILE?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,123 @@\n+# Makefile for Watcom C/C++ 10.5, 10.6, 11.0 on NT, OS2 and DOS4GW .\n+# May work with Watcom 10.0 .\n+#\n+\n+#\n+# Uncoment one of line for cross compiling\n+#SYSTEM=DOS4GW\n+#SYSTEM=MSWIN32\n+#SYSTEM=OS2\n+\n+!ifndef SYSTEM\n+\n+!ifdef __MSDOS__\n+SYSTEM=DOS4GW\n+!endif\n+\n+!ifdef __NT__\n+SYSTEM=MSWIN32\n+!endif\n+\n+!ifdef __OS2__\n+SYSTEM=OS2\n+!endif\n+\n+D_SYSTEM=\n+\n+!else\n+\n+D_SYSTEM=-D$(SYSTEM)\n+\n+!endif\n+\n+!define $(SYSTEM)\n+\n+\n+CC=wcc386\n+CXX=wpp386\n+AS=wasm\n+\n+\n+# Watcom before 11.0 not support option -oh\n+# Remove it if you get error\n+OPTIM=-oneatxh -s\n+\n+CALLING=-5s\n+\n+DEFS=-DALL_INTERIOR_POINTERS -DSILENT #-DSMALL_CONFIG #-DGC_DEBUG\n+\n+# ! -DUSE_GENERIC required !\n+CFLAGS=$(OPTIM) -zp4 $(CALLING) -zc -DUSE_GENERIC $(D_SYSTEM) $(DEFS)\n+CXXFLAGS= $(CFLAGS)\n+ASFLAGS=$(CALLING)\n+\n+OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj &\n+      mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj &\n+      obj_map.obj blacklst.obj finalize.obj new_hblk.obj &\n+      dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj &\n+      typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj\n+\n+\n+all: gc.lib gctest.exe\n+\n+# this file required for DOS4GW only\n+gc_watcom.obj: gc_watcom.asm WCC_MAKEFILE\n+      $(AS) $(ASFLAGS) gc_watcom.asm\n+\n+!ifdef DOS4GW\n+gc.lib: $(OBJS) gc_watcom.obj\n+      @%create $*.lb1\n+      @for %i in ($(OBJS)) do @%append $*.lb1 +'%i'\n+      @@%append $*.lb1 +'gc_watcom.obj'\n+      *wlib -b -c -n -p=512 $@ @$*.lb1\n+!else\n+gc.lib: $(OBJS)\n+        @%create $*.lb1\n+        @for %i in ($(OBJS)) do @%append $*.lb1 +'%i'\n+        *wlib -b -c -n -p=512 $@ @$*.lb1\n+!endif\n+\n+\n+test.obj: test.c\n+        $(CC) $(CFLAGS) $*.c\n+\n+gctest.exe: test.obj gc.lib\n+        %create $*.lnk\n+!ifdef DOS4GW\n+        @%append $*.lnk sys dos4g\n+!endif\n+!ifdef MSWIN32\n+        @%append $*.lnk sys nt\n+!endif\n+!ifdef OS2\n+        @%append $*.lnk sys os2v2\n+!endif\n+        @%append $*.lnk op case\n+        @%append $*.lnk op stack=256K\n+        @%append $*.lnk name $*\n+        @%append $*.lnk file test.obj\n+        @%append $*.lnk library gc.lib\n+        *wlink @$*.lnk\n+\n+\n+\n+.c.obj: .AUTODEPEND\n+        $(CC) $(CFLAGS) $*.c\n+\n+.cc.obj: .AUTODEPEND\n+        $(CXX) $(CXXFLAGS) $*.cc\n+\n+.cpp.obj: .AUTODEPEND\n+        $(CXX) $(CXXFLAGS) $*.cpp\n+\n+clean : .SYMBOLIC\n+    @if exist *.obj del *.obj\n+    @if exist *.map del *.map\n+    @if exist *.lnk del *.lnk\n+    @if exist *.lb1 del *.lb1\n+    @if exist *.sym del *.sym\n+    @if exist *.err del *.err\n+    @if exist *.tmp del *.tmp\n+    @if exist *.lst del *.lst\n+    @if exist *.exe del *.exe\n+    @if exist *.log del *.log"}, {"sha": "0d1ab6d4d3668d73cd50a9c39baab704830a9c48", "filename": "boehm-gc/add_gc_prefix.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fadd_gc_prefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fadd_gc_prefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fadd_gc_prefix.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,14 @@\n+# include <stdio.h>\n+ \n+int main(argc, argv, envp)\n+int argc;\n+char ** argv;\n+char ** envp;\n+{\n+    int i;\n+    \n+    for (i = 1; i < argc; i++) {\n+    \tprintf(\"gc/%s \", argv[i]);\n+    }\n+    return(0);\n+}"}, {"sha": "7a5a3a1c3ab480d175dd414ea982c9e78b603a12", "filename": "boehm-gc/allchblk.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,408 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1998 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, August 9, 1995 5:08 pm PDT */\n+\n+#define DEBUG\n+#undef DEBUG\n+#include <stdio.h>\n+#include \"gc_priv.h\"\n+\n+\n+/*\n+ * allocate/free routines for heap blocks\n+ * Note that everything called from outside the garbage collector\n+ * should be prepared to abort at any point as the result of a signal.\n+ */\n+\n+/*\n+ * Free heap blocks are kept on a list sorted by address.\n+ * The hb_hdr.hbh_sz field of a free heap block contains the length\n+ * (in bytes) of the entire block.\n+ * Neighbors are coalesced.\n+ */\n+ \n+# define MAX_BLACK_LIST_ALLOC (2*HBLKSIZE)\n+\t\t/* largest block we will allocate starting on a black   */\n+\t\t/* listed block.  Must be >= HBLKSIZE.\t\t\t*/\n+\n+struct hblk * GC_hblkfreelist = 0;\n+\n+struct hblk *GC_savhbp = (struct hblk *)0;  /* heap block preceding next */\n+\t\t\t\t\t /* block to be examined by   */\n+\t\t\t\t\t /* GC_allochblk.                */\n+\n+# if !defined(NO_DEBUGGING)\n+void GC_print_hblkfreelist()\n+{\n+    struct hblk * h = GC_hblkfreelist;\n+    word total_free = 0;\n+    hdr * hhdr = HDR(h);\n+    word sz;\n+    \n+    while (h != 0) {\n+        sz = hhdr -> hb_sz;\n+    \tGC_printf2(\"0x%lx size %lu \", (unsigned long)h, (unsigned long)sz);\n+    \ttotal_free += sz;\n+        if (GC_is_black_listed(h, HBLKSIZE) != 0) {\n+             GC_printf0(\"start black listed\\n\");\n+        } else if (GC_is_black_listed(h, hhdr -> hb_sz) != 0) {\n+             GC_printf0(\"partially black listed\\n\");\n+        } else {\n+             GC_printf0(\"not black listed\\n\");\n+        }\n+        h = hhdr -> hb_next;\n+        hhdr = HDR(h);\n+    }\n+    GC_printf1(\"Total of %lu bytes on free list\\n\", (unsigned long)total_free);\n+}\n+\n+# endif /* NO_DEBUGGING */\n+\n+/* Initialize hdr for a block containing the indicated size and \t*/\n+/* kind of objects.\t\t\t\t\t\t\t*/\n+/* Return FALSE on failure.\t\t\t\t\t\t*/\n+static GC_bool setup_header(hhdr, sz, kind, flags)\n+register hdr * hhdr;\n+word sz;\t/* object size in words */\n+int kind;\n+unsigned char flags;\n+{\n+    register word descr;\n+    \n+    /* Add description of valid object pointers */\n+      if (!GC_add_map_entry(sz)) return(FALSE);\n+      hhdr -> hb_map = GC_obj_map[sz > MAXOBJSZ? 0 : sz];\n+      \n+    /* Set size, kind and mark proc fields */\n+      hhdr -> hb_sz = sz;\n+      hhdr -> hb_obj_kind = kind;\n+      hhdr -> hb_flags = flags;\n+      descr = GC_obj_kinds[kind].ok_descriptor;\n+      if (GC_obj_kinds[kind].ok_relocate_descr) descr += WORDS_TO_BYTES(sz);\n+      hhdr -> hb_descr = descr;\n+      \n+    /* Clear mark bits */\n+      GC_clear_hdr_marks(hhdr);\n+      \n+    hhdr -> hb_last_reclaimed = (unsigned short)GC_gc_no;\n+    return(TRUE);\n+}\n+\n+#ifdef EXACT_FIRST\n+#   define LAST_TRIP 2\n+#else\n+#   define LAST_TRIP 1\n+#endif\n+\t\n+/*\n+ * Allocate (and return pointer to) a heap block\n+ *   for objects of size sz words.\n+ *\n+ * NOTE: We set obj_map field in header correctly.\n+ *       Caller is resposnsible for building an object freelist in block.\n+ *\n+ * We clear the block if it is destined for large objects, and if\n+ * kind requires that newly allocated objects be cleared.\n+ */\n+struct hblk *\n+GC_allochblk(sz, kind, flags)\n+word sz;\n+int kind;\n+unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n+{\n+    register struct hblk *thishbp;\n+    register hdr * thishdr;\t\t/* Header corr. to thishbp */\n+    register struct hblk *hbp;\n+    register hdr * hhdr;\t\t/* Header corr. to hbp */\n+    struct hblk *prevhbp;\n+    register hdr * phdr;\t\t/* Header corr. to prevhbp */\n+    signed_word size_needed;    /* number of bytes in requested objects */\n+    signed_word size_avail;\t/* bytes available in this block\t*/\n+    int trip_count = 0;\n+\n+    size_needed = HBLKSIZE * OBJ_SZ_TO_BLOCKS(sz);\n+\n+    /* search for a big enough block in free list */\n+\thbp = GC_savhbp;\n+\thhdr = HDR(hbp);\n+\tfor(;;) {\n+\n+\t    prevhbp = hbp;\n+\t    phdr = hhdr;\n+\t    hbp = (prevhbp == 0? GC_hblkfreelist : phdr->hb_next);\n+\t    hhdr = HDR(hbp);\n+\n+\t    if( prevhbp == GC_savhbp) {\n+\t\tif (trip_count == LAST_TRIP) return(0);\n+\t\t++trip_count;\n+\t    }\n+\n+\t    if( hbp == 0 ) continue;\n+\n+\t    size_avail = hhdr->hb_sz;\n+#\t    ifdef EXACT_FIRST\n+\t\tif (trip_count <= 1 && size_avail != size_needed) continue;\n+#\t    endif\n+\t    if (size_avail < size_needed) continue;\n+#\t    ifdef PRESERVE_LAST\n+\t\tif (size_avail != size_needed\n+\t\t    && !GC_incremental\n+\t\t    && GC_in_last_heap_sect(hbp) && GC_should_collect()) {\n+\t\t    continue;\n+\t\t} \n+#\t    endif\n+\t    /* If the next heap block is obviously better, go on.\t*/\n+\t    /* This prevents us from disassembling a single large block */\n+\t    /* to get tiny blocks.\t\t\t\t\t*/\n+\t    {\n+\t      signed_word next_size;\n+\t      \n+\t      thishbp = hhdr -> hb_next;\n+\t      if (thishbp == 0) thishbp = GC_hblkfreelist; \n+\t      thishdr = HDR(thishbp);\n+\t      next_size = (signed_word)(thishdr -> hb_sz);\n+\t      if (next_size < size_avail\n+\t          && next_size >= size_needed\n+\t          && !GC_is_black_listed(thishbp, (word)size_needed)) {\n+\t          continue;\n+\t      }\n+\t    }\n+\t    if ( !IS_UNCOLLECTABLE(kind) &&\n+\t         (kind != PTRFREE || size_needed > MAX_BLACK_LIST_ALLOC)) {\n+\t      struct hblk * lasthbp = hbp;\n+\t      ptr_t search_end = (ptr_t)hbp + size_avail - size_needed;\n+\t      signed_word orig_avail = size_avail;\n+\t      signed_word eff_size_needed = ((flags & IGNORE_OFF_PAGE)?\n+\t      \t\t\t\t\tHBLKSIZE\n+\t      \t\t\t\t\t: size_needed);\n+\t      \n+\t      \n+\t      while ((ptr_t)lasthbp <= search_end\n+\t             && (thishbp = GC_is_black_listed(lasthbp,\n+\t             \t\t\t\t      (word)eff_size_needed))) {\n+\t        lasthbp = thishbp;\n+\t      }\n+\t      size_avail -= (ptr_t)lasthbp - (ptr_t)hbp;\n+\t      thishbp = lasthbp;\n+\t      if (size_avail >= size_needed) {\n+\t        if (thishbp != hbp && GC_install_header(thishbp)) {\n+\t          /* Split the block at thishbp */\n+\t              thishdr = HDR(thishbp);\n+\t              /* GC_invalidate_map not needed, since we will\t*/\n+\t              /* allocate this block.\t\t\t\t*/\n+\t\t      thishdr -> hb_next = hhdr -> hb_next;\n+\t\t      thishdr -> hb_sz = size_avail;\n+\t\t      hhdr -> hb_sz = (ptr_t)thishbp - (ptr_t)hbp;\n+\t\t      hhdr -> hb_next = thishbp;\n+\t\t  /* Advance to thishbp */\n+\t\t      prevhbp = hbp;\n+\t\t      phdr = hhdr;\n+\t\t      hbp = thishbp;\n+\t\t      hhdr = thishdr;\n+\t\t}\n+\t      } else if (size_needed > (signed_word)BL_LIMIT\n+\t                 && orig_avail - size_needed\n+\t\t\t    > (signed_word)BL_LIMIT) {\n+\t        /* Punt, since anything else risks unreasonable heap growth. */\n+\t        WARN(\"Needed to allocate blacklisted block at 0x%lx\\n\",\n+\t\t     (word)hbp);\n+\t        thishbp = hbp;\n+\t        size_avail = orig_avail;\n+\t      } else if (size_avail == 0\n+\t      \t\t && size_needed == HBLKSIZE\n+\t      \t\t && prevhbp != 0) {\n+#\t\tifndef FIND_LEAK\n+\t      \t  static unsigned count = 0;\n+\t      \t  \n+\t      \t  /* The block is completely blacklisted.  We need \t*/\n+\t      \t  /* to drop some such blocks, since otherwise we spend */\n+\t      \t  /* all our time traversing them if pointerfree\t*/\n+\t      \t  /* blocks are unpopular.\t\t\t\t*/\n+\t          /* A dropped block will be reconsidered at next GC.\t*/\n+\t          if ((++count & 3) == 0) {\n+\t            /* Allocate and drop the block in small chunks, to\t*/\n+\t            /* maximize the chance that we will recover some\t*/\n+\t            /* later.\t\t\t\t\t\t*/\n+\t              struct hblk * limit = hbp + (hhdr->hb_sz/HBLKSIZE);\n+\t              struct hblk * h;\n+\t              \n+\t\t      GC_words_wasted += hhdr->hb_sz;\n+\t              phdr -> hb_next = hhdr -> hb_next;\n+\t              for (h = hbp; h < limit; h++) {\n+\t                if (h == hbp || GC_install_header(h)) {\n+\t                  hhdr = HDR(h);\n+\t                  (void) setup_header(\n+\t                \t  hhdr,\n+\t              \t\t  BYTES_TO_WORDS(HBLKSIZE - HDR_BYTES),\n+\t              \t\t  PTRFREE, 0); /* Cant fail */\n+\t              \t  if (GC_debugging_started) {\n+\t              \t    BZERO(hbp + HDR_BYTES, HBLKSIZE - HDR_BYTES);\n+\t              \t  }\n+\t                }\n+\t              }\n+\t            /* Restore hbp to point at free block */\n+\t              if (GC_savhbp == hbp) GC_savhbp = prevhbp;\n+\t              hbp = prevhbp;\n+\t              hhdr = phdr;\n+\t              if (hbp == GC_savhbp) --trip_count;\n+\t          }\n+#\t\tendif\n+\t      }\n+\t    }\n+\t    if( size_avail >= size_needed ) {\n+\t\t/* found a big enough block       */\n+\t\t/* let thishbp --> the block      */\n+\t\t/* set prevhbp, hbp to bracket it */\n+\t\t    thishbp = hbp;\n+\t\t    thishdr = hhdr;\n+\t\t    if( size_avail == size_needed ) {\n+\t\t\thbp = hhdr->hb_next;\n+\t\t\thhdr = HDR(hbp);\n+\t\t    } else {\n+\t\t\thbp = (struct hblk *)\n+\t\t\t    (((word)thishbp) + size_needed);\n+\t\t\tif (!GC_install_header(hbp)) {\n+\t\t\t    hbp = thishbp;\n+\t\t\t    continue;\n+\t\t\t}\n+\t\t\thhdr = HDR(hbp);\n+\t\t\tGC_invalidate_map(hhdr);\n+\t\t\thhdr->hb_next = thishdr->hb_next;\n+\t\t\thhdr->hb_sz = size_avail - size_needed;\n+\t\t    }\n+\t\t/* remove *thishbp from hblk freelist */\n+\t\t    if( prevhbp == 0 ) {\n+\t\t\tGC_hblkfreelist = hbp;\n+\t\t    } else {\n+\t\t\tphdr->hb_next = hbp;\n+\t\t    }\n+\t\t/* save current list search position */\n+\t\t    GC_savhbp = hbp;\n+\t\tbreak;\n+\t    }\n+\t}\n+\t\n+    /* Notify virtual dirty bit implementation that we are about to write. */\n+    \tGC_write_hint(thishbp);\n+    \n+    /* Add it to map of valid blocks */\n+    \tif (!GC_install_counts(thishbp, (word)size_needed)) return(0);\n+    \t/* This leaks memory under very rare conditions. */\n+    \t\t\n+    /* Set up header */\n+        if (!setup_header(thishdr, sz, kind, flags)) {\n+            GC_remove_counts(thishbp, (word)size_needed);\n+            return(0); /* ditto */\n+        }\n+        \n+    /* Clear block if necessary */\n+\tif (GC_debugging_started\n+\t    || sz > MAXOBJSZ && GC_obj_kinds[kind].ok_init) {\n+\t    BZERO(thishbp + HDR_BYTES,  size_needed - HDR_BYTES);\n+\t}\n+\n+    /* We just successfully allocated a block.  Restart count of\t*/\n+    /* consecutive failures.\t\t\t\t\t\t*/\n+    {\n+\textern unsigned GC_fail_count;\n+\t\n+\tGC_fail_count = 0;\n+    }\n+    \n+    return( thishbp );\n+}\n+ \n+struct hblk * GC_freehblk_ptr = 0;  /* Search position hint for GC_freehblk */\n+\n+/*\n+ * Free a heap block.\n+ *\n+ * Coalesce the block with its neighbors if possible.\n+ *\n+ * All mark words are assumed to be cleared.\n+ */\n+void\n+GC_freehblk(p)\n+register struct hblk *p;\n+{\n+register hdr *phdr;\t/* Header corresponding to p */\n+register struct hblk *hbp, *prevhbp;\n+register hdr *hhdr, *prevhdr;\n+register signed_word size;\n+\n+    /* GC_savhbp may become invalid due to coalescing.  Clear it. */\n+\tGC_savhbp = (struct hblk *)0;\n+\n+    phdr = HDR(p);\n+    size = phdr->hb_sz;\n+    size = HBLKSIZE * OBJ_SZ_TO_BLOCKS(size);\n+    GC_remove_counts(p, (word)size);\n+    phdr->hb_sz = size;\n+    GC_invalidate_map(phdr);\n+    prevhbp = 0;\n+    \n+    /* The following optimization was suggested by David Detlefs.\t*/\n+    /* Note that the header cannot be NIL, since there cannot be an\t*/\n+    /* intervening  call to GC_freehblk without resetting\t\t*/\n+    /* GC_freehblk_ptr.\t\t\t\t\t\t\t*/\n+    if (GC_freehblk_ptr != 0 &&\n+    \tHDR(GC_freehblk_ptr)->hb_map == GC_invalid_map &&\n+    \t(ptr_t)GC_freehblk_ptr < (ptr_t)p) {\n+      hbp = GC_freehblk_ptr;\n+    } else {\n+      hbp = GC_hblkfreelist;\n+    };\n+    hhdr = HDR(hbp);\n+\n+    while( (hbp != 0) && (hbp < p) ) {\n+\tprevhbp = hbp;\n+\tprevhdr = hhdr;\n+\thbp = hhdr->hb_next;\n+\thhdr = HDR(hbp);\n+    }\n+    GC_freehblk_ptr = prevhbp;\n+    \n+    /* Check for duplicate deallocation in the easy case */\n+      if (hbp != 0 && (ptr_t)p + size > (ptr_t)hbp\n+        || prevhbp != 0 && (ptr_t)prevhbp + prevhdr->hb_sz > (ptr_t)p) {\n+        GC_printf1(\"Duplicate large block deallocation of 0x%lx\\n\",\n+        \t   (unsigned long) p);\n+        GC_printf2(\"Surrounding free blocks are 0x%lx and 0x%lx\\n\",\n+           \t   (unsigned long) prevhbp, (unsigned long) hbp);\n+      }\n+\n+    /* Coalesce with successor, if possible */\n+      if( (((word)p)+size) == ((word)hbp) ) {\n+\tphdr->hb_next = hhdr->hb_next;\n+\tphdr->hb_sz += hhdr->hb_sz;\n+\tGC_remove_header(hbp);\n+      } else {\n+\tphdr->hb_next = hbp;\n+      }\n+\n+    \n+    if( prevhbp == 0 ) {\n+\tGC_hblkfreelist = p;\n+    } else if( (((word)prevhbp) + prevhdr->hb_sz)\n+      \t       == ((word)p) ) {\n+      /* Coalesce with predecessor */\n+\tprevhdr->hb_next = phdr->hb_next;\n+\tprevhdr->hb_sz += phdr->hb_sz;\n+\tGC_remove_header(p);\n+    } else {\n+\tprevhdr->hb_next = p;\n+    }\n+}\n+"}, {"sha": "d60544a32051efcb1a956100349fd05eb44df2f3", "filename": "boehm-gc/alloc.c", "status": "added", "additions": 849, "deletions": 0, "changes": 849, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,849 @@\n+/*\n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ */\n+/* Boehm, February 16, 1996 2:26 pm PST */\n+\n+\n+# include \"gc_priv.h\"\n+\n+# include <stdio.h>\n+# ifndef MACOS\n+#   include <signal.h>\n+#   include <sys/types.h>\n+# endif\n+\n+/*\n+ * Separate free lists are maintained for different sized objects\n+ * up to MAXOBJSZ.\n+ * The call GC_allocobj(i,k) ensures that the freelist for\n+ * kind k objects of size i points to a non-empty\n+ * free list. It returns a pointer to the first entry on the free list.\n+ * In a single-threaded world, GC_allocobj may be called to allocate\n+ * an object of (small) size i as follows:\n+ *\n+ *            opp = &(GC_objfreelist[i]);\n+ *            if (*opp == 0) GC_allocobj(i, NORMAL);\n+ *            ptr = *opp;\n+ *            *opp = obj_link(ptr);\n+ *\n+ * Note that this is very fast if the free list is non-empty; it should\n+ * only involve the execution of 4 or 5 simple instructions.\n+ * All composite objects on freelists are cleared, except for\n+ * their first word.\n+ */\n+\n+/*\n+ *  The allocator uses GC_allochblk to allocate large chunks of objects.\n+ * These chunks all start on addresses which are multiples of\n+ * HBLKSZ.   Each allocated chunk has an associated header,\n+ * which can be located quickly based on the address of the chunk.\n+ * (See headers.c for details.) \n+ * This makes it possible to check quickly whether an\n+ * arbitrary address corresponds to an object administered by the\n+ * allocator.\n+ */\n+\n+word GC_non_gc_bytes = 0;  /* Number of bytes not intended to be collected */\n+\n+word GC_gc_no = 0;\n+\n+int GC_incremental = 0;    /* By default, stop the world.\t*/\n+\n+int GC_full_freq = 4;\t   /* Every 5th collection is a full\t*/\n+\t\t\t   /* collection.\t\t\t*/\n+\n+char * GC_copyright[] =\n+{\"Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers \",\n+\"Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. \",\n+\"Copyright (c) 1996-1997 by Silicon Graphics.  All rights reserved. \",\n+\"THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY\",\n+\" EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\",\n+\"See source code for details.\" };\n+\n+# include \"version.h\"\n+\n+/* some more variables */\n+\n+extern signed_word GC_mem_found;  /* Number of reclaimed longwords\t*/\n+\t\t\t\t  /* after garbage collection      \t*/\n+\n+GC_bool GC_dont_expand = 0;\n+\n+word GC_free_space_divisor = 4;\n+\n+extern GC_bool GC_collection_in_progress();\n+\n+int GC_never_stop_func GC_PROTO((void)) { return(0); }\n+\n+CLOCK_TYPE GC_start_time;\n+\n+int GC_timeout_stop_func GC_PROTO((void))\n+{\n+    CLOCK_TYPE current_time;\n+    static unsigned count = 0;\n+    unsigned long time_diff;\n+    \n+    if ((count++ & 3) != 0) return(0);\n+    GET_TIME(current_time);\n+    time_diff = MS_TIME_DIFF(current_time,GC_start_time);\n+    if (time_diff >= TIME_LIMIT) {\n+#   \tifdef PRINTSTATS\n+\t    GC_printf0(\"Abandoning stopped marking after \");\n+\t    GC_printf1(\"%lu msecs\\n\", (unsigned long)time_diff);\n+#\tendif\n+    \treturn(1);\n+    }\n+    return(0);\n+}\n+\n+/* Return the minimum number of words that must be allocated between\t*/\n+/* collections to amortize the collection cost.\t\t\t\t*/\n+static word min_words_allocd()\n+{\n+#   ifdef THREADS\n+ \t/* We punt, for now. */\n+ \tregister signed_word stack_size = 10000;\n+#   else\n+        int dummy;\n+        register signed_word stack_size = (ptr_t)(&dummy) - GC_stackbottom;\n+#   endif\n+    register word total_root_size;  /* includes double stack size,\t*/\n+    \t\t\t\t    /* since the stack is expensive\t*/\n+    \t\t\t\t    /* to scan.\t\t\t\t*/\n+    \n+    if (stack_size < 0) stack_size = -stack_size;\n+    total_root_size = 2 * stack_size + GC_root_size;\n+    if (GC_incremental) {\n+        return(BYTES_TO_WORDS(GC_heapsize + total_root_size)\n+               / (2 * GC_free_space_divisor));\n+    } else {\n+        return(BYTES_TO_WORDS(GC_heapsize + total_root_size)\n+               / GC_free_space_divisor);\n+    }\n+}\n+\n+/* Return the number of words allocated, adjusted for explicit storage\t*/\n+/* management, etc..  This number is used in deciding when to trigger\t*/\n+/* collections.\t\t\t\t\t\t\t\t*/\n+word GC_adj_words_allocd()\n+{\n+    register signed_word result;\n+    register signed_word expl_managed =\n+    \t\tBYTES_TO_WORDS((long)GC_non_gc_bytes\n+    \t\t\t\t- (long)GC_non_gc_bytes_at_gc);\n+    \n+    /* Don't count what was explicitly freed, or newly allocated for\t*/\n+    /* explicit management.  Note that deallocating an explicitly\t*/\n+    /* managed object should not alter result, assuming the client\t*/\n+    /* is playing by the rules.\t\t\t\t\t\t*/\n+    result = (signed_word)GC_words_allocd\n+    \t     - (signed_word)GC_mem_freed - expl_managed;\n+    if (result > (signed_word)GC_words_allocd) {\n+        result = GC_words_allocd;\n+    \t/* probably client bug or unfortunate scheduling */\n+    }\n+    result += GC_words_finalized;\n+    \t/* We count objects enqueued for finalization as though they\t*/\n+    \t/* had been reallocated this round. Finalization is user\t*/\n+    \t/* visible progress.  And if we don't count this, we have\t*/\n+    \t/* stability problems for programs that finalize all objects.\t*/\n+    result += GC_words_wasted;\n+     \t/* This doesn't reflect useful work.  But if there is lots of\t*/\n+     \t/* new fragmentation, the same is probably true of the heap,\t*/\n+     \t/* and the collection will be correspondingly cheaper.\t\t*/\n+    if (result < (signed_word)(GC_words_allocd >> 3)) {\n+    \t/* Always count at least 1/8 of the allocations.  We don't want\t*/\n+    \t/* to collect too infrequently, since that would inhibit\t*/\n+    \t/* coalescing of free storage blocks.\t\t\t\t*/\n+    \t/* This also makes us partially robust against client bugs.\t*/\n+        return(GC_words_allocd >> 3);\n+    } else {\n+        return(result);\n+    }\n+}\n+\n+\n+/* Clear up a few frames worth of garbage left at the top of the stack.\t*/\n+/* This is used to prevent us from accidentally treating garbade left\t*/\n+/* on the stack by other parts of the collector as roots.  This \t*/\n+/* differs from the code in misc.c, which actually tries to keep the\t*/\n+/* stack clear of long-lived, client-generated garbage.\t\t\t*/\n+void GC_clear_a_few_frames()\n+{\n+#   define NWORDS 64\n+    word frames[NWORDS];\n+    register int i;\n+    \n+    for (i = 0; i < NWORDS; i++) frames[i] = 0;\n+}\n+\n+/* Have we allocated enough to amortize a collection? */\n+GC_bool GC_should_collect()\n+{\n+    return(GC_adj_words_allocd() >= min_words_allocd());\n+}\n+\n+void GC_notify_full_gc()\n+{\n+    if (GC_start_call_back != (void (*)())0) {\n+\t(*GC_start_call_back)();\n+    }\n+}\n+\n+/* \n+ * Initiate a garbage collection if appropriate.\n+ * Choose judiciously\n+ * between partial, full, and stop-world collections.\n+ * Assumes lock held, signals disabled.\n+ */\n+void GC_maybe_gc()\n+{\n+    static int n_partial_gcs = 0;\n+    if (GC_should_collect()) {\n+        if (!GC_incremental) {\n+\t    GC_notify_full_gc();\n+            GC_gcollect_inner();\n+            n_partial_gcs = 0;\n+            return;\n+        } else if (n_partial_gcs >= GC_full_freq) {\n+#   \t    ifdef PRINTSTATS\n+\t      GC_printf2(\n+\t        \"***>Full mark for collection %lu after %ld allocd bytes\\n\",\n+     \t\t(unsigned long) GC_gc_no+1,\n+\t   \t(long)WORDS_TO_BYTES(GC_words_allocd));\n+#           endif\n+\t    GC_promote_black_lists();\n+\t    (void)GC_reclaim_all((GC_stop_func)0, TRUE);\n+\t    GC_clear_marks();\n+            n_partial_gcs = 0;\n+\t    GC_notify_full_gc();\n+        } else {\n+            n_partial_gcs++;\n+        }\n+        /* We try to mark with the world stopped.\t*/\n+        /* If we run out of time, this turns into\t*/\n+        /* incremental marking.\t\t\t*/\n+        GET_TIME(GC_start_time);\n+        if (GC_stopped_mark(GC_timeout_stop_func)) {\n+#           ifdef SAVE_CALL_CHAIN\n+                GC_save_callers(GC_last_stack);\n+#           endif\n+            GC_finish_collection();\n+        }\n+    }\n+}\n+\n+\n+/*\n+ * Stop the world garbage collection.  Assumes lock held, signals disabled.\n+ * If stop_func is not GC_never_stop_func, then abort if stop_func returns TRUE.\n+ */\n+GC_bool GC_try_to_collect_inner(stop_func)\n+GC_stop_func stop_func;\n+{\n+    if (GC_collection_in_progress()) {\n+#   ifdef PRINTSTATS\n+\tGC_printf0(\n+\t    \"GC_try_to_collect_inner: finishing collection in progress\\n\");\n+#    endif /* PRINTSTATS */\n+      /* Just finish collection already in progress.\t*/\n+    \twhile(GC_collection_in_progress()) {\n+    \t    if (stop_func()) return(FALSE);\n+    \t    GC_collect_a_little_inner(1);\n+    \t}\n+    }\n+#   ifdef PRINTSTATS\n+\tGC_printf2(\n+\t   \"Initiating full world-stop collection %lu after %ld allocd bytes\\n\",\n+\t   (unsigned long) GC_gc_no+1,\n+\t   (long)WORDS_TO_BYTES(GC_words_allocd));\n+#   endif\n+    GC_promote_black_lists();\n+    /* Make sure all blocks have been reclaimed, so sweep routines\t*/\n+    /* don't see cleared mark bits.\t\t\t\t\t*/\n+    /* If we're guaranteed to finish, then this is unnecessary.\t\t*/\n+\tif (stop_func != GC_never_stop_func\n+\t    && !GC_reclaim_all(stop_func, FALSE)) {\n+\t    /* Aborted.  So far everything is still consistent.\t*/\n+\t    return(FALSE);\n+\t}\n+    GC_invalidate_mark_state();  /* Flush mark stack.\t*/\n+    GC_clear_marks();\n+#   ifdef SAVE_CALL_CHAIN\n+        GC_save_callers(GC_last_stack);\n+#   endif\n+    if (!GC_stopped_mark(stop_func)) {\n+      if (!GC_incremental) {\n+    \t/* We're partially done and have no way to complete or use \t*/\n+    \t/* current work.  Reestablish invariants as cheaply as\t\t*/\n+    \t/* possible.\t\t\t\t\t\t\t*/\n+    \tGC_invalidate_mark_state();\n+\tGC_unpromote_black_lists();\n+      } /* else we claim the world is already still consistent.  We'll \t*/\n+        /* finish incrementally.\t\t\t\t\t*/\n+      return(FALSE);\n+    }\n+    GC_finish_collection();\n+    return(TRUE);\n+}\n+\n+\n+\n+/*\n+ * Perform n units of garbage collection work.  A unit is intended to touch\n+ * roughly a GC_RATE pages.  Every once in a while, we do more than that.\n+ */\n+# define GC_RATE 8\n+\n+int GC_deficit = 0;\t/* The number of extra calls to GC_mark_some\t*/\n+\t\t\t/* that we have made.\t\t\t\t*/\n+\t\t\t/* Negative values are equivalent to 0.\t\t*/\n+\n+void GC_collect_a_little_inner(n)\n+int n;\n+{\n+    register int i;\n+    \n+    if (GC_collection_in_progress()) {\n+    \tfor (i = GC_deficit; i < GC_RATE*n; i++) {\n+    \t    if (GC_mark_some()) {\n+    \t        /* Need to finish a collection */\n+#     \t\tifdef SAVE_CALL_CHAIN\n+        \t    GC_save_callers(GC_last_stack);\n+#     \t\tendif\n+\t\t(void) GC_stopped_mark(GC_never_stop_func);\n+    \t        GC_finish_collection();\n+    \t        break;\n+    \t    }\n+    \t}\n+    \tif (GC_deficit > 0) GC_deficit -= GC_RATE*n;\n+    } else {\n+        GC_maybe_gc();\n+    }\n+}\n+\n+int GC_collect_a_little GC_PROTO(())\n+{\n+    int result;\n+    DCL_LOCK_STATE;\n+\n+    DISABLE_SIGNALS();\n+    LOCK();\n+    GC_collect_a_little_inner(1);\n+    result = (int)GC_collection_in_progress();\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+    return(result);\n+}\n+\n+/*\n+ * Assumes lock is held, signals are disabled.\n+ * We stop the world.\n+ * If final is TRUE, then we finish the collection, no matter how long\n+ * it takes.\n+ * Otherwise we may fail and return FALSE if this takes too long.\n+ * Increment GC_gc_no if we succeed.\n+ */\n+GC_bool GC_stopped_mark(stop_func)\n+GC_stop_func stop_func;\n+{\n+    register int i;\n+#   ifdef PRINTSTATS\n+\tCLOCK_TYPE start_time, current_time;\n+#   endif\n+\t\n+    STOP_WORLD();\n+#   ifdef PRINTSTATS\n+\tGET_TIME(start_time);\n+\tGC_printf1(\"--> Marking for collection %lu \",\n+\t           (unsigned long) GC_gc_no + 1);\n+\tGC_printf2(\"after %lu allocd bytes + %lu wasted bytes\\n\",\n+\t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_allocd),\n+\t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_wasted));\n+#   endif\n+\n+    /* Mark from all roots.  */\n+        /* Minimize junk left in my registers and on the stack */\n+            GC_clear_a_few_frames();\n+            GC_noop(0,0,0,0,0,0);\n+\tGC_initiate_gc();\n+\tfor(i = 0;;i++) {\n+\t    if ((*stop_func)()) {\n+#   \t\t    ifdef PRINTSTATS\n+\t\t    \tGC_printf0(\"Abandoned stopped marking after \");\n+\t\t\tGC_printf1(\"%lu iterations\\n\",\n+\t\t\t\t   (unsigned long)i);\n+#\t\t    endif\n+\t\t    GC_deficit = i; /* Give the mutator a chance. */\n+\t            START_WORLD();\n+\t            return(FALSE);\n+\t    }\n+\t    if (GC_mark_some()) break;\n+\t}\n+\t\n+    GC_gc_no++;\n+#   ifdef PRINTSTATS\n+      GC_printf2(\"Collection %lu reclaimed %ld bytes\",\n+\t\t  (unsigned long) GC_gc_no - 1,\n+\t   \t  (long)WORDS_TO_BYTES(GC_mem_found));\n+      GC_printf1(\" ---> heapsize = %lu bytes\\n\",\n+      \t        (unsigned long) GC_heapsize);\n+      /* Printf arguments may be pushed in funny places.  Clear the\t*/\n+      /* space.\t\t\t\t\t\t\t\t*/\n+      GC_printf0(\"\");\n+#   endif      \n+\n+    /* Check all debugged objects for consistency */\n+        if (GC_debugging_started) {\n+            (*GC_check_heap)();\n+        }\n+    \n+#   ifdef PRINTTIMES\n+\tGET_TIME(current_time);\n+\tGC_printf1(\"World-stopped marking took %lu msecs\\n\",\n+\t           MS_TIME_DIFF(current_time,start_time));\n+#   endif\n+    START_WORLD();\n+    return(TRUE);\n+}\n+\n+\n+/* Finish up a collection.  Assumes lock is held, signals are disabled,\t*/\n+/* but the world is otherwise running.\t\t\t\t\t*/\n+void GC_finish_collection()\n+{\n+#   ifdef PRINTTIMES\n+\tCLOCK_TYPE start_time;\n+\tCLOCK_TYPE finalize_time;\n+\tCLOCK_TYPE done_time;\n+\t\n+\tGET_TIME(start_time);\n+\tfinalize_time = start_time;\n+#   endif\n+\n+#   ifdef GATHERSTATS\n+        GC_mem_found = 0;\n+#   endif\n+#   ifdef FIND_LEAK\n+      /* Mark all objects on the free list.  All objects should be */\n+      /* marked when we're done.\t\t\t\t   */\n+\t{\n+\t  register word size;\t\t/* current object size\t\t*/\n+\t  register ptr_t p;\t/* pointer to current object\t*/\n+\t  register struct hblk * h;\t/* pointer to block containing *p */\n+\t  register hdr * hhdr;\n+\t  register int word_no;           /* \"index\" of *p in *q          */\n+\t  int kind;\n+\n+\t  for (kind = 0; kind < GC_n_kinds; kind++) {\n+\t    for (size = 1; size <= MAXOBJSZ; size++) {\n+\t      for (p= GC_obj_kinds[kind].ok_freelist[size];\n+\t           p != 0; p=obj_link(p)){\n+\t\th = HBLKPTR(p);\n+\t\thhdr = HDR(h);\n+\t\tword_no = (((word *)p) - ((word *)h));\n+\t\tset_mark_bit_from_hdr(hhdr, word_no);\n+\t      }\n+\t    }\n+\t  }\n+\t}\n+      /* Check that everything is marked */\n+\tGC_start_reclaim(TRUE);\n+#   else\n+\n+      GC_finalize();\n+#     ifdef STUBBORN_ALLOC\n+        GC_clean_changing_list();\n+#     endif\n+\n+#     ifdef PRINTTIMES\n+\tGET_TIME(finalize_time);\n+#     endif\n+\n+      /* Clear free list mark bits, in case they got accidentally marked   */\n+      /* Note: HBLKPTR(p) == pointer to head of block containing *p        */\n+      /* Also subtract memory remaining from GC_mem_found count.           */\n+      /* Note that composite objects on free list are cleared.             */\n+      /* Thus accidentally marking a free list is not a problem;  only     */\n+      /* objects on the list itself will be marked, and that's fixed here. */\n+      {\n+\tregister word size;\t\t/* current object size\t\t*/\n+\tregister ptr_t p;\t/* pointer to current object\t*/\n+\tregister struct hblk * h;\t/* pointer to block containing *p */\n+\tregister hdr * hhdr;\n+\tregister int word_no;           /* \"index\" of *p in *q          */\n+\tint kind;\n+\n+\tfor (kind = 0; kind < GC_n_kinds; kind++) {\n+\t  for (size = 1; size <= MAXOBJSZ; size++) {\n+\t    for (p= GC_obj_kinds[kind].ok_freelist[size];\n+\t         p != 0; p=obj_link(p)){\n+\t\th = HBLKPTR(p);\n+\t\thhdr = HDR(h);\n+\t\tword_no = (((word *)p) - ((word *)h));\n+\t\tclear_mark_bit_from_hdr(hhdr, word_no);\n+#\t\tifdef GATHERSTATS\n+\t\t    GC_mem_found -= size;\n+#\t\tendif\n+\t    }\n+\t  }\n+\t}\n+      }\n+\n+\n+#     ifdef PRINTSTATS\n+\tGC_printf1(\"Bytes recovered before sweep - f.l. count = %ld\\n\",\n+\t          (long)WORDS_TO_BYTES(GC_mem_found));\n+#     endif\n+\n+    /* Reconstruct free lists to contain everything not marked */\n+      GC_start_reclaim(FALSE);\n+    \n+#   endif /* !FIND_LEAK */\n+\n+#   ifdef PRINTSTATS\n+\tGC_printf2(\n+\t\t  \"Immediately reclaimed %ld bytes in heap of size %lu bytes\\n\",\n+\t          (long)WORDS_TO_BYTES(GC_mem_found),\n+\t          (unsigned long)GC_heapsize);\n+\tGC_printf2(\"%lu (atomic) + %lu (composite) collectable bytes in use\\n\",\n+\t           (unsigned long)WORDS_TO_BYTES(GC_atomic_in_use),\n+\t           (unsigned long)WORDS_TO_BYTES(GC_composite_in_use));\n+#   endif\n+\n+    /* Reset or increment counters for next cycle */\n+      GC_words_allocd_before_gc += GC_words_allocd;\n+      GC_non_gc_bytes_at_gc = GC_non_gc_bytes;\n+      GC_words_allocd = 0;\n+      GC_words_wasted = 0;\n+      GC_mem_freed = 0;\n+      \n+#   ifdef PRINTTIMES\n+\tGET_TIME(done_time);\n+\tGC_printf2(\"Finalize + initiate sweep took %lu + %lu msecs\\n\",\n+\t           MS_TIME_DIFF(finalize_time,start_time),\n+\t           MS_TIME_DIFF(done_time,finalize_time));\n+#   endif\n+}\n+\n+/* Externally callable routine to invoke full, stop-world collection */\n+# if defined(__STDC__) || defined(__cplusplus)\n+    int GC_try_to_collect(GC_stop_func stop_func)\n+# else\n+    int GC_try_to_collect(stop_func)\n+    GC_stop_func stop_func;\n+# endif\n+{\n+    int result;\n+    DCL_LOCK_STATE;\n+    \n+    GC_INVOKE_FINALIZERS();\n+    DISABLE_SIGNALS();\n+    LOCK();\n+    ENTER_GC();\n+    if (!GC_is_initialized) GC_init_inner();\n+    /* Minimize junk left in my registers */\n+      GC_noop(0,0,0,0,0,0);\n+    result = (int)GC_try_to_collect_inner(stop_func);\n+    EXIT_GC();\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+    if(result) GC_INVOKE_FINALIZERS();\n+    return(result);\n+}\n+\n+void GC_gcollect GC_PROTO(())\n+{\n+    GC_notify_full_gc();\n+    (void)GC_try_to_collect(GC_never_stop_func);\n+}\n+\n+word GC_n_heap_sects = 0;\t/* Number of sections currently in heap. */\n+\n+/*\n+ * Use the chunk of memory starting at p of syze bytes as part of the heap.\n+ * Assumes p is HBLKSIZE aligned, and bytes is a multiple of HBLKSIZE.\n+ */\n+void GC_add_to_heap(p, bytes)\n+struct hblk *p;\n+word bytes;\n+{\n+    word words;\n+    \n+    if (GC_n_heap_sects >= MAX_HEAP_SECTS) {\n+    \tABORT(\"Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS\");\n+    }\n+    if (!GC_install_header(p)) {\n+    \t/* This is extremely unlikely. Can't add it.  This will\t\t*/\n+    \t/* almost certainly result in a\t0 return from the allocator,\t*/\n+    \t/* which is entirely appropriate.\t\t\t\t*/\n+    \treturn;\n+    }\n+    GC_heap_sects[GC_n_heap_sects].hs_start = (ptr_t)p;\n+    GC_heap_sects[GC_n_heap_sects].hs_bytes = bytes;\n+    GC_n_heap_sects++;\n+    words = BYTES_TO_WORDS(bytes - HDR_BYTES);\n+    HDR(p) -> hb_sz = words;\n+    GC_freehblk(p);\n+    GC_heapsize += bytes;\n+    if ((ptr_t)p <= GC_least_plausible_heap_addr\n+        || GC_least_plausible_heap_addr == 0) {\n+        GC_least_plausible_heap_addr = (ptr_t)p - sizeof(word);\n+        \t/* Making it a little smaller than necessary prevents\t*/\n+        \t/* us from getting a false hit from the variable\t*/\n+        \t/* itself.  There's some unintentional reflection\t*/\n+        \t/* here.\t\t\t\t\t\t*/\n+    }\n+    if ((ptr_t)p + bytes >= GC_greatest_plausible_heap_addr) {\n+        GC_greatest_plausible_heap_addr = (ptr_t)p + bytes;\n+    }\n+}\n+\n+#ifdef PRESERVE_LAST\n+GC_bool GC_in_last_heap_sect(p)\n+ptr_t p;\n+{\n+    struct HeapSect * last_heap_sect = &(GC_heap_sects[GC_n_heap_sects-1]);\n+    ptr_t start = last_heap_sect -> hs_start;\n+    ptr_t end;\n+\n+    if (p < start) return FALSE;\n+    end = start + last_heap_sect -> hs_bytes;\n+    if (p >= end) return FALSE;\n+    return TRUE;\n+}\n+#endif\n+\n+# if !defined(NO_DEBUGGING)\n+void GC_print_heap_sects()\n+{\n+    register unsigned i;\n+    \n+    GC_printf1(\"Total heap size: %lu\\n\", (unsigned long) GC_heapsize);\n+    for (i = 0; i < GC_n_heap_sects; i++) {\n+        unsigned long start = (unsigned long) GC_heap_sects[i].hs_start;\n+        unsigned long len = (unsigned long) GC_heap_sects[i].hs_bytes;\n+        struct hblk *h;\n+        unsigned nbl = 0;\n+        \n+    \tGC_printf3(\"Section %ld from 0x%lx to 0x%lx \", (unsigned long)i,\n+    \t\t   start, (unsigned long)(start + len));\n+    \tfor (h = (struct hblk *)start; h < (struct hblk *)(start + len); h++) {\n+    \t    if (GC_is_black_listed(h, HBLKSIZE)) nbl++;\n+    \t}\n+    \tGC_printf2(\"%lu/%lu blacklisted\\n\", (unsigned long)nbl,\n+    \t\t   (unsigned long)(len/HBLKSIZE));\n+    }\n+}\n+# endif\n+\n+ptr_t GC_least_plausible_heap_addr = (ptr_t)ONES;\n+ptr_t GC_greatest_plausible_heap_addr = 0;\n+\n+ptr_t GC_max(x,y)\n+ptr_t x, y;\n+{\n+    return(x > y? x : y);\n+}\n+\n+ptr_t GC_min(x,y)\n+ptr_t x, y;\n+{\n+    return(x < y? x : y);\n+}\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_set_max_heap_size(GC_word n)\n+# else\n+    void GC_set_max_heap_size(n)\n+    GC_word n;\n+# endif\n+{\n+    GC_max_heapsize = n;\n+}\n+\n+GC_word GC_max_retries = 0;\n+\n+/*\n+ * this explicitly increases the size of the heap.  It is used\n+ * internally, but may also be invoked from GC_expand_hp by the user.\n+ * The argument is in units of HBLKSIZE.\n+ * Tiny values of n are rounded up.\n+ * Returns FALSE on failure.\n+ */\n+GC_bool GC_expand_hp_inner(n)\n+word n;\n+{\n+    word bytes;\n+    struct hblk * space;\n+    word expansion_slop;\t/* Number of bytes by which we expect the */\n+    \t\t\t\t/* heap to expand soon.\t\t\t  */\n+\n+    if (n < MINHINCR) n = MINHINCR;\n+    bytes = n * HBLKSIZE;\n+    /* Make sure bytes is a multiple of GC_page_size */\n+      {\n+\tword mask = GC_page_size - 1;\n+\tbytes += mask;\n+\tbytes &= ~mask;\n+      }\n+    \n+    if (GC_max_heapsize != 0 && GC_heapsize + bytes > GC_max_heapsize) {\n+        /* Exceeded self-imposed limit */\n+        return(FALSE);\n+    }\n+    space = GET_MEM(bytes);\n+    if( space == 0 ) {\n+\treturn(FALSE);\n+    }\n+#   ifdef PRINTSTATS\n+\tGC_printf2(\"Increasing heap size by %lu after %lu allocated bytes\\n\",\n+\t           (unsigned long)bytes,\n+\t           (unsigned long)WORDS_TO_BYTES(GC_words_allocd));\n+# \tifdef UNDEFINED\n+\t  GC_printf1(\"Root size = %lu\\n\", GC_root_size);\n+\t  GC_print_block_list(); GC_print_hblkfreelist();\n+\t  GC_printf0(\"\\n\");\n+#\tendif\n+#   endif\n+    expansion_slop = 8 * WORDS_TO_BYTES(min_words_allocd());\n+    if (5 * HBLKSIZE * MAXHINCR > expansion_slop) {\n+        expansion_slop = 5 * HBLKSIZE * MAXHINCR;\n+    }\n+    if (GC_last_heap_addr == 0 && !((word)space & SIGNB)\n+        || GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space) {\n+        /* Assume the heap is growing up */\n+        GC_greatest_plausible_heap_addr =\n+            GC_max(GC_greatest_plausible_heap_addr,\n+                   (ptr_t)space + bytes + expansion_slop);\n+    } else {\n+        /* Heap is growing down */\n+        GC_least_plausible_heap_addr =\n+            GC_min(GC_least_plausible_heap_addr,\n+                   (ptr_t)space - expansion_slop);\n+    }\n+    GC_prev_heap_addr = GC_last_heap_addr;\n+    GC_last_heap_addr = (ptr_t)space;\n+    GC_add_to_heap(space, bytes);\n+    return(TRUE);\n+}\n+\n+/* Really returns a bool, but it's externally visible, so that's clumsy. */\n+/* Arguments is in bytes.\t\t\t\t\t\t*/\n+# if defined(__STDC__) || defined(__cplusplus)\n+  int GC_expand_hp(size_t bytes)\n+# else\n+  int GC_expand_hp(bytes)\n+  size_t bytes;\n+# endif\n+{\n+    int result;\n+    DCL_LOCK_STATE;\n+    \n+    DISABLE_SIGNALS();\n+    LOCK();\n+    if (!GC_is_initialized) GC_init_inner();\n+    result = (int)GC_expand_hp_inner(divHBLKSZ((word)bytes));\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+    return(result);\n+}\n+\n+unsigned GC_fail_count = 0;  \n+\t\t\t/* How many consecutive GC/expansion failures?\t*/\n+\t\t\t/* Reset by GC_allochblk.\t\t\t*/\n+\n+GC_bool GC_collect_or_expand(needed_blocks, ignore_off_page)\n+word needed_blocks;\n+GC_bool ignore_off_page;\n+{\n+    \n+    if (!GC_incremental && !GC_dont_gc && GC_should_collect()) {\n+      GC_notify_full_gc();\n+      GC_gcollect_inner();\n+    } else {\n+      word blocks_to_get = GC_heapsize/(HBLKSIZE*GC_free_space_divisor)\n+      \t\t\t   + needed_blocks;\n+      \n+      if (blocks_to_get > MAXHINCR) {\n+          word slop;\n+          \n+          if (ignore_off_page) {\n+              slop = 4;\n+          } else {\n+\t      slop = 2*divHBLKSZ(BL_LIMIT);\n+\t      if (slop > needed_blocks) slop = needed_blocks;\n+\t  }\n+          if (needed_blocks + slop > MAXHINCR) {\n+              blocks_to_get = needed_blocks + slop;\n+          } else {\n+              blocks_to_get = MAXHINCR;\n+          }\n+      }\n+      if (!GC_expand_hp_inner(blocks_to_get)\n+        && !GC_expand_hp_inner(needed_blocks)) {\n+      \tif (GC_fail_count++ < GC_max_retries) {\n+      \t    WARN(\"Out of Memory!  Trying to continue ...\\n\", 0);\n+\t    GC_notify_full_gc();\n+\t    GC_gcollect_inner();\n+\t} else {\n+\t    WARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n+\t    return(FALSE);\n+\t}\n+      } else if (GC_fail_count) {\n+#\t  ifdef PRINTSTATS\n+\t    GC_printf0(\"Memory available again ...\\n\");\n+#\t  endif\n+      }\n+    }\n+    return(TRUE);\n+}\n+\n+/*\n+ * Make sure the object free list for sz is not empty.\n+ * Return a pointer to the first object on the free list.\n+ * The object MUST BE REMOVED FROM THE FREE LIST BY THE CALLER.\n+ * Assumes we hold the allocator lock and signals are disabled.\n+ *\n+ */\n+ptr_t GC_allocobj(sz, kind)\n+word sz;\n+int kind;\n+{\n+    register ptr_t * flh = &(GC_obj_kinds[kind].ok_freelist[sz]);\n+    \n+    if (sz == 0) return(0);\n+\n+    while (*flh == 0) {\n+      ENTER_GC();\n+      /* Do our share of marking work */\n+        if(GC_incremental && !GC_dont_gc) GC_collect_a_little_inner(1);\n+      /* Sweep blocks for objects of this size */\n+          GC_continue_reclaim(sz, kind);\n+      EXIT_GC();\n+      if (*flh == 0) {\n+        GC_new_hblk(sz, kind);\n+      }\n+      if (*flh == 0) {\n+        ENTER_GC();\n+        if (!GC_collect_or_expand((word)1,FALSE)) {\n+\t    EXIT_GC();\n+\t    return(0);\n+\t}\n+\tEXIT_GC();\n+      }\n+    }\n+    \n+    return(*flh);\n+}"}, {"sha": "27e80dc15cd103b5c3ad02a2cc60972370bd2842", "filename": "boehm-gc/barrett_diagram", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fbarrett_diagram", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fbarrett_diagram", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbarrett_diagram?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,106 @@\n+This is an ASCII diagram of the data structure used to check pointer\n+validity.  It was provided by Dave Barrett <barrett@asgard.cs.colorado.edu>,\n+and should be of use to others attempting to understand the code.\n+The data structure in GC4.X is essentially the same.   -HB\n+\n+\n+\n+\n+\t\tData Structure used by GC_base in gc3.7:\n+\t\t\t      21-Apr-94\n+\t\t\t \n+\t\t\t\n+\n+\n+    63                  LOG_TOP_SZ[11]  LOG_BOTTOM_SZ[10]   LOG_HBLKSIZE[13]\n+   +------------------+----------------+------------------+------------------+\n+ p:|                  |   TL_HASH(hi)  |                  |   HBLKDISPL(p)   |\n+   +------------------+----------------+------------------+------------------+\n+    \\-----------------------HBLKPTR(p)-------------------/\n+    \\------------hi-------------------/ \n+                      \\______ ________/ \\________ _______/ \\________ _______/\n+                             V                   V                  V\n+                             |                   |                  |\n+           GC_top_index[]    |                   |                  | \n+ ---      +--------------+   |                   |                  |  \n+  ^       |              |   |                   |                  |   \n+  |       |              |   |                   |                  |   \n+ TOP      +--------------+<--+                   |                  |      \n+ _SZ   +-<|      []      | *                     |                  |     \n+(items)|  +--------------+  if 0 < bi< HBLKSIZE  |                  |    \n+  |    |  |              | then large object     |                  |    \n+  |    |  |              | starts at the bi'th   |                  |    \n+  v    |  |              | HBLK before p.        |             i    |    \n+ ---   |  +--------------+                       |          (word-  |    \n+       v                                         |         aligned) |    \n+   bi= |GET_BI(p){->hash_link}->key==hi          |                  |   \n+       v                                         |                  |    \n+       |   (bottom_index)  \\ scratch_alloc'd     |                  |    \n+       |   ( struct  bi )  / by get_index()      |                  |    \n+ ---   +->+--------------+                       |                  |    \n+  ^       |              |                       |                  |\n+  ^       |              |                       |                  |\n+ BOTTOM   |              |   ha=GET_HDR_ADDR(p)  |                  |\n+_SZ(items)+--------------+<----------------------+          +-------+\n+  |   +--<|   index[]    |                                  |         \n+  |   |   +--------------+                      GC_obj_map: v              \n+  |   |   |              |              from      / +-+-+-----+-+-+-+-+  --- \n+  v   |   |              |              GC_add   < 0| | |     | | | | |   ^  \n+ ---  |   +--------------+             _map_entry \\ +-+-+-----+-+-+-+-+   |  \n+      |   |   asc_link   |                          +-+-+-----+-+-+-+-+ MAXOBJSZ\n+      |   +--------------+                      +-->| | |  j  | | | | |  +1   \n+      |   |     key      |                      |   +-+-+-----+-+-+-+-+   |  \n+      |   +--------------+                      |   +-+-+-----+-+-+-+-+   | \n+      |   |  hash_link   |                      |   | | |     | | | | |   v \n+      |   +--------------+                      |   +-+-+-----+-+-+-+-+  ---\n+      |                                         |   |<--MAX_OFFSET--->|   \n+      |                                         |         (bytes)\n+HDR(p)| GC_find_header(p)                       |   |<--MAP_ENTRIES-->| \n+      |                           \\ from        |    =HBLKSIZE/WORDSZ   \n+      |    (hdr) (struct hblkhdr) / alloc_hdr() |    (1024 on Alpha)\n+      +-->+----------------------+              |    (8/16 bits each)\n+GET_HDR(p)| word   hb_sz (words) |              |          \n+          +----------------------+              |     \n+          | struct hblk *hb_next |              |\n+          +----------------------+              |       \n+          |mark_proc hb_mark_proc|              |\n+          +----------------------+              |\n+          | char * hb_map        |>-------------+\n+          +----------------------+           \n+          | ushort hb_obj_kind   |           \n+          +----------------------+           \n+          |   hb_last_reclaimed  |           \n+ ---      +----------------------+                \n+  ^       |                      |\n+ MARK_BITS|       hb_marks[]     | *if hdr is free, hb_sz + DISCARD_WORDS\n+_SZ(words)|                      |  is the size of a heap chunk (struct hblk)\n+  v       |                      |  of at least MININCR*HBLKSIZE bytes (below),\n+ ---      +----------------------+  otherwise, size of each object in chunk.\n+\n+Dynamic data structures above are interleaved throughout the heap in blocks of \n+size MININCR * HBLKSIZE bytes as done by gc_scratch_alloc which cannot be\n+freed; free lists are used (e.g. alloc_hdr).  HBLKs's below are collected.\n+\n+\t      (struct hblk)      \n+ ---      +----------------------+ < HBLKSIZE ---         ---          DISCARD_\n+  ^       |garbage[DISCARD_WORDS]|   aligned   ^           ^ HDR_BYTES WORDS\n+  |       |                      |             |           v (bytes)   (words)\n+  |       +-----hb_body----------+ < WORDSZ    |          ---   ---   \n+  |       |                      |   aligned   |           ^     ^\n+  |       |      Object 0        |             |           hb_sz |\n+  |       |                      |           i |(word-    (words)|\n+  |       |                      |      (bytes)|aligned)   v     |\n+  |       + - - - - - - - - - - -+ ---         |          ---    |\n+  |       |                      |  ^          |           ^     |\n+  n *     |                      |  j (words)  |          hb_sz BODY_SZ \n+ HBLKSIZE |      Object 1        |  v          v           |   (words)\n+ (bytes)  |                      |---------------          v   MAX_OFFSET\n+  |       + - - - - - - - - - - -+                        ---  (bytes)\n+  |       |                      | !All_INTERIOR_PTRS      ^     |\n+  |       |                      | sets j only for       hb_sz   |\n+  |       |      Object N        | valid object offsets.   |     |\n+  v       |                      | All objects WORDSZ      v     v\n+ ---      +----------------------+ aligned.               ---   ---\n+\n+DISCARD_WORDS is normally zero.  Indeed the collector has not been tested\n+with another value in ages."}, {"sha": "44455e5ba4735c33d186357675a5da24dd45c9f5", "filename": "boehm-gc/blacklst.c", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fblacklst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fblacklst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fblacklst.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,286 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, August 9, 1995 6:09 pm PDT */\n+# include \"gc_priv.h\"\n+\n+/*\n+ * We maintain several hash tables of hblks that have had false hits.\n+ * Each contains one bit per hash bucket;  If any page in the bucket\n+ * has had a false hit, we assume that all of them have.\n+ * See the definition of page_hash_table in gc_private.h.\n+ * False hits from the stack(s) are much more dangerous than false hits\n+ * from elsewhere, since the former can pin a large object that spans the\n+ * block, eventhough it does not start on the dangerous block.\n+ */\n+ \n+/*\n+ * Externally callable routines are:\n+ \n+ * GC_add_to_black_list_normal\n+ * GC_add_to_black_list_stack\n+ * GC_promote_black_lists\n+ * GC_is_black_listed\n+ *\n+ * All require that the allocator lock is held.\n+ */\n+\n+/* Pointers to individual tables.  We replace one table by another by \t*/\n+/* switching these pointers. \t\t\t\t\t\t*/\n+word * GC_old_normal_bl;\n+\t\t/* Nonstack false references seen at last full\t\t*/\n+\t\t/* collection.\t\t\t\t\t\t*/\n+word * GC_incomplete_normal_bl;\n+\t\t/* Nonstack false references seen since last\t\t*/\n+\t\t/* full collection.\t\t\t\t\t*/\n+word * GC_old_stack_bl;\n+word * GC_incomplete_stack_bl;\n+\n+word GC_total_stack_black_listed;\n+\n+word GC_black_list_spacing = MINHINCR*HBLKSIZE;  /* Initial rough guess */\n+\n+void GC_clear_bl();\n+\n+void GC_default_print_heap_obj_proc(p)\n+ptr_t p;\n+{\n+    ptr_t base = GC_base(p);\n+\n+    GC_err_printf2(\"start: 0x%lx, appr. length: %ld\", base, GC_size(base));\n+}\n+\n+void (*GC_print_heap_obj)(/* char * s, ptr_t p */) =\n+\t\t\t\tGC_default_print_heap_obj_proc;\n+\n+void GC_print_source_ptr(ptr_t p)\n+{\n+    ptr_t base = GC_base(p);\n+    if (0 == base) {\n+\tGC_err_printf0(\"in root set\");\n+    } else {\n+\tGC_err_printf0(\"in object at \");\n+\t(*GC_print_heap_obj)(base);\n+    }\n+}\n+\n+void GC_bl_init()\n+{\n+# ifndef ALL_INTERIOR_POINTERS\n+    GC_old_normal_bl = (word *)\n+    \t\t\t GC_scratch_alloc((word)(sizeof (page_hash_table)));\n+    GC_incomplete_normal_bl = (word *)GC_scratch_alloc\n+    \t\t\t\t\t((word)(sizeof(page_hash_table)));\n+    if (GC_old_normal_bl == 0 || GC_incomplete_normal_bl == 0) {\n+        GC_err_printf0(\"Insufficient memory for black list\\n\");\n+        EXIT();\n+    }\n+    GC_clear_bl(GC_old_normal_bl);\n+    GC_clear_bl(GC_incomplete_normal_bl);\n+# endif\n+    GC_old_stack_bl = (word *)GC_scratch_alloc((word)(sizeof(page_hash_table)));\n+    GC_incomplete_stack_bl = (word *)GC_scratch_alloc\n+    \t\t\t\t\t((word)(sizeof(page_hash_table)));\n+    if (GC_old_stack_bl == 0 || GC_incomplete_stack_bl == 0) {\n+        GC_err_printf0(\"Insufficient memory for black list\\n\");\n+        EXIT();\n+    }\n+    GC_clear_bl(GC_old_stack_bl);\n+    GC_clear_bl(GC_incomplete_stack_bl);\n+}\n+\t\t\n+void GC_clear_bl(doomed)\n+word *doomed;\n+{\n+    BZERO(doomed, sizeof(page_hash_table));\n+}\n+\n+void GC_copy_bl(old, new)\n+word *new, *old;\n+{\n+    BCOPY(old, new, sizeof(page_hash_table));\n+}\n+\n+static word total_stack_black_listed();\n+\n+/* Signal the completion of a collection.  Turn the incomplete black\t*/\n+/* lists into new black lists, etc.\t\t\t\t\t*/\t\t\t \n+void GC_promote_black_lists()\n+{\n+    word * very_old_normal_bl = GC_old_normal_bl;\n+    word * very_old_stack_bl = GC_old_stack_bl;\n+    \n+    GC_old_normal_bl = GC_incomplete_normal_bl;\n+    GC_old_stack_bl = GC_incomplete_stack_bl;\n+#   ifndef ALL_INTERIOR_POINTERS\n+      GC_clear_bl(very_old_normal_bl);\n+#   endif\n+    GC_clear_bl(very_old_stack_bl);\n+    GC_incomplete_normal_bl = very_old_normal_bl;\n+    GC_incomplete_stack_bl = very_old_stack_bl;\n+    GC_total_stack_black_listed = total_stack_black_listed();\n+#   ifdef PRINTSTATS\n+  \tGC_printf1(\"%ld bytes in heap blacklisted for interior pointers\\n\",\n+  \t\t   (unsigned long)GC_total_stack_black_listed);\n+#   endif\n+    if (GC_total_stack_black_listed != 0) {\n+        GC_black_list_spacing =\n+\t\tHBLKSIZE*(GC_heapsize/GC_total_stack_black_listed);\n+    }\n+    if (GC_black_list_spacing < 3 * HBLKSIZE) {\n+    \tGC_black_list_spacing = 3 * HBLKSIZE;\n+    }\n+}\n+\n+void GC_unpromote_black_lists()\n+{\n+#   ifndef ALL_INTERIOR_POINTERS\n+      GC_copy_bl(GC_old_normal_bl, GC_incomplete_normal_bl);\n+#   endif\n+    GC_copy_bl(GC_old_stack_bl, GC_incomplete_stack_bl);\n+}\n+\n+# ifndef ALL_INTERIOR_POINTERS\n+/* P is not a valid pointer reference, but it falls inside\t*/\n+/* the plausible heap bounds.\t\t\t\t\t*/\n+/* Add it to the normal incomplete black list if appropriate.\t*/\n+#ifdef PRINT_BLACK_LIST\n+  void GC_add_to_black_list_normal(p, source)\n+  ptr_t source;\n+#else\n+  void GC_add_to_black_list_normal(p)\n+#endif\n+word p;\n+{\n+    if (!(GC_modws_valid_offsets[p & (sizeof(word)-1)])) return;\n+    {\n+        register int index = PHT_HASH(p);\n+        \n+        if (HDR(p) == 0 || get_pht_entry_from_index(GC_old_normal_bl, index)) {\n+#   \t    ifdef PRINT_BLACK_LIST\n+\t\tif (!get_pht_entry_from_index(GC_incomplete_normal_bl, index)) {\n+\t    \t  GC_err_printf2(\n+\t\t\t\"Black listing (normal) 0x%lx referenced from 0x%lx \",\n+\t    \t        (unsigned long) p, (unsigned long) source);\n+\t\t  GC_print_source_ptr(source);\n+\t\t  GC_err_puts(\"\\n\");\n+\t    \t}\n+#           endif\n+            set_pht_entry_from_index(GC_incomplete_normal_bl, index);\n+        } /* else this is probably just an interior pointer to an allocated */\n+          /* object, and isn't worth black listing.\t\t\t    */\n+    }\n+}\n+# endif\n+\n+/* And the same for false pointers from the stack. */\n+#ifdef PRINT_BLACK_LIST\n+  void GC_add_to_black_list_stack(p, source)\n+  ptr_t source;\n+#else\n+  void GC_add_to_black_list_stack(p)\n+#endif\n+word p;\n+{\n+    register int index = PHT_HASH(p);\n+        \n+    if (HDR(p) == 0 || get_pht_entry_from_index(GC_old_stack_bl, index)) {\n+#   \tifdef PRINT_BLACK_LIST\n+\t    if (!get_pht_entry_from_index(GC_incomplete_stack_bl, index)) {\n+\t    \t  GC_err_printf2(\n+\t\t\t\"Black listing (stack) 0x%lx referenced from 0x%lx \",\n+\t    \t        (unsigned long)p, (unsigned long)source);\n+\t\t  GC_print_source_ptr(source);\n+\t\t  GC_err_puts(\"\\n\");\n+\t    }\n+#       endif\n+\tset_pht_entry_from_index(GC_incomplete_stack_bl, index);\n+    }\n+}\n+\n+/*\n+ * Is the block starting at h of size len bytes black listed?   If so,\n+ * return the address of the next plausible r such that (r, len) might not\n+ * be black listed.  (R may not actually be in the heap.  We guarantee only\n+ * that every smaller value of r after h is also black listed.)\n+ * If (h,len) is not black listed, return 0.\n+ * Knows about the structure of the black list hash tables.\n+ */\n+struct hblk * GC_is_black_listed(h, len)\n+struct hblk * h;\n+word len;\n+{\n+    register int index = PHT_HASH((word)h);\n+    register word i;\n+    word nblocks = divHBLKSZ(len);\n+\n+#   ifndef ALL_INTERIOR_POINTERS\n+      if (get_pht_entry_from_index(GC_old_normal_bl, index)\n+          || get_pht_entry_from_index(GC_incomplete_normal_bl, index)) {\n+        return(h+1);\n+      }\n+#   endif\n+    \n+    for (i = 0; ; ) {\n+        if (GC_old_stack_bl[divWORDSZ(index)] == 0\n+            && GC_incomplete_stack_bl[divWORDSZ(index)] == 0) {\n+            /* An easy case */\n+            i += WORDSZ - modWORDSZ(index);\n+        } else {\n+          if (get_pht_entry_from_index(GC_old_stack_bl, index)\n+              || get_pht_entry_from_index(GC_incomplete_stack_bl, index)) {\n+            return(h+i+1);\n+          }\n+          i++;\n+        }\n+        if (i >= nblocks) break;\n+        index = PHT_HASH((word)(h+i));\n+    }\n+    return(0);\n+}\n+\n+\n+/* Return the number of blacklisted blocks in a given range.\t*/\n+/* Used only for statistical purposes.\t\t\t\t*/\n+/* Looks only at the GC_incomplete_stack_bl.\t\t\t*/\n+word GC_number_stack_black_listed(start, endp1)\n+struct hblk *start, *endp1;\n+{\n+    register struct hblk * h;\n+    word result = 0;\n+    \n+    for (h = start; h < endp1; h++) {\n+        register int index = PHT_HASH((word)h);\n+        \n+        if (get_pht_entry_from_index(GC_old_stack_bl, index)) result++;\n+    }\n+    return(result);\n+}\n+\n+\n+/* Return the total number of (stack) black-listed bytes. */\n+static word total_stack_black_listed()\n+{\n+    register unsigned i;\n+    word total = 0;\n+    \n+    for (i = 0; i < GC_n_heap_sects; i++) {\n+    \tstruct hblk * start = (struct hblk *) GC_heap_sects[i].hs_start;\n+    \tword len = (word) GC_heap_sects[i].hs_bytes;\n+    \tstruct hblk * endp1 = start + len/HBLKSIZE;\n+    \t\n+    \ttotal += GC_number_stack_black_listed(start, endp1);\n+    }\n+    return(total * HBLKSIZE);\n+}\n+"}, {"sha": "a8793f0b728193b52f202270c5dadf7f4c6d811c", "filename": "boehm-gc/callprocs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcallprocs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcallprocs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcallprocs?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,4 @@\n+#!/bin/sh\n+GC_DEBUG=1\n+export GC_DEBUG\n+$* 2>&1 | awk '{print \"0x3e=c\\\"\"$0\"\\\"\"};/^\\t##PC##=/ {if ($2 != 0) {print $2\"?i\"}}' | adb $1 | sed \"s/^\t\t>/>/\""}, {"sha": "212655f4cd436a83a7cbbce627b8a7c1ef2bed9c", "filename": "boehm-gc/checksums.c", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fchecksums.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fchecksums.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fchecksums.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 1992-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, March 29, 1995 12:51 pm PST */\n+# ifdef CHECKSUMS\n+\n+# include \"gc_priv.h\"\n+\n+/* This is debugging code intended to verify the results of dirty bit\t*/\n+/* computations. Works only in a single threaded environment.\t\t*/\n+/* We assume that stubborn objects are changed only when they are \t*/\n+/* enabled for writing.  (Certain kinds of writing are actually\t\t*/\n+/* safe under other conditions.)\t\t\t\t\t*/\n+# define NSUMS 2000\n+\n+# define OFFSET 0x10000\n+\n+typedef struct {\n+\tGC_bool new_valid;\n+\tword old_sum;\n+\tword new_sum;\n+\tstruct hblk * block;\t/* Block to which this refers + OFFSET  */\n+\t\t\t\t/* to hide it from colector.\t\t*/\n+} page_entry;\n+\n+page_entry GC_sums [NSUMS];\n+\n+word GC_checksum(h)\n+struct hblk *h;\n+{\n+    register word *p = (word *)h;\n+    register word *lim = (word *)(h+1);\n+    register word result = 0;\n+    \n+    while (p < lim) {\n+        result += *p++;\n+    }\n+    return(result | 0x80000000 /* doesn't look like pointer */);\n+}\n+\n+# ifdef STUBBORN_ALLOC\n+/* Check whether a stubborn object from the given block appears on\t*/\n+/* the appropriate free list.\t\t\t\t\t\t*/\n+GC_bool GC_on_free_list(h)\n+struct hblk *h;\n+{\n+    register hdr * hhdr = HDR(h);\n+    register int sz = hhdr -> hb_sz;\n+    ptr_t p;\n+    \n+    if (sz > MAXOBJSZ) return(FALSE);\n+    for (p = GC_sobjfreelist[sz]; p != 0; p = obj_link(p)) {\n+        if (HBLKPTR(p) == h) return(TRUE);\n+    }\n+    return(FALSE);\n+}\n+# endif\n+ \n+int GC_n_dirty_errors;\n+int GC_n_changed_errors;\n+int GC_n_clean;\n+int GC_n_dirty;\n+\n+void GC_update_check_page(h, index)\n+struct hblk *h;\n+int index;\n+{\n+    page_entry *pe = GC_sums + index;\n+    register hdr * hhdr = HDR(h);\n+    \n+    if (pe -> block != 0 && pe -> block != h + OFFSET) ABORT(\"goofed\");\n+    pe -> old_sum = pe -> new_sum;\n+    pe -> new_sum = GC_checksum(h);\n+#   ifndef MSWIN32\n+        if (pe -> new_sum != 0 && !GC_page_was_ever_dirty(h)) {\n+            GC_printf1(\"GC_page_was_ever_dirty(0x%lx) is wrong\\n\",\n+        \t       (unsigned long)h);\n+        }\n+#   endif\n+    if (GC_page_was_dirty(h)) {\n+    \tGC_n_dirty++;\n+    } else {\n+    \tGC_n_clean++;\n+    }\n+    if (pe -> new_valid && pe -> old_sum != pe -> new_sum) {\n+    \tif (!GC_page_was_dirty(h) || !GC_page_was_ever_dirty(h)) {\n+    \t    /* Set breakpoint here */GC_n_dirty_errors++;\n+    \t}\n+#\tifdef STUBBORN_ALLOC\n+    \t  if (!IS_FORWARDING_ADDR_OR_NIL(hhdr)\n+    \t    && hhdr -> hb_map != GC_invalid_map\n+    \t    && hhdr -> hb_obj_kind == STUBBORN\n+    \t    && !GC_page_was_changed(h)\n+    \t    && !GC_on_free_list(h)) {\n+    \t    /* if GC_on_free_list(h) then reclaim may have touched it\t*/\n+    \t    /* without any allocations taking place.\t\t\t*/\n+    \t    /* Set breakpoint here */GC_n_changed_errors++;\n+    \t  }\n+#\tendif\n+    }\n+    pe -> new_valid = TRUE;\n+    pe -> block = h + OFFSET;\n+}\n+\n+word GC_bytes_in_used_blocks;\n+\n+void GC_add_block(h, dummy)\n+struct hblk *h;\n+word dummy;\n+{\n+   register hdr * hhdr = HDR(h);\n+   register bytes = WORDS_TO_BYTES(hhdr -> hb_sz);\n+   \n+   bytes += HDR_BYTES + HBLKSIZE-1;\n+   bytes &= ~(HBLKSIZE-1);\n+   GC_bytes_in_used_blocks += bytes;\n+}\n+\n+void GC_check_blocks()\n+{\n+    word bytes_in_free_blocks = 0;\n+    struct hblk * h = GC_hblkfreelist;\n+    hdr * hhdr = HDR(h);\n+    word sz;\n+    \n+    GC_bytes_in_used_blocks = 0;\n+    GC_apply_to_all_blocks(GC_add_block, (word)0);\n+    while (h != 0) {\n+        sz = hhdr -> hb_sz;\n+        bytes_in_free_blocks += sz;\n+        h = hhdr -> hb_next;\n+        hhdr = HDR(h);\n+    }\n+    GC_printf2(\"GC_bytes_in_used_blocks = %ld, bytes_in_free_blocks = %ld \",\n+    \t\tGC_bytes_in_used_blocks, bytes_in_free_blocks);\n+    GC_printf1(\"GC_heapsize = %ld\\n\", GC_heapsize);\n+    if (GC_bytes_in_used_blocks + bytes_in_free_blocks != GC_heapsize) {\n+    \tGC_printf0(\"LOST SOME BLOCKS!!\\n\");\n+    }\n+}\n+\n+/* Should be called immediately after GC_read_dirty and GC_read_changed. */\n+void GC_check_dirty()\n+{\n+    register int index;\n+    register unsigned i;\n+    register struct hblk *h;\n+    register ptr_t start;\n+    \n+    GC_check_blocks();\n+    \n+    GC_n_dirty_errors = 0;\n+    GC_n_changed_errors = 0;\n+    GC_n_clean = 0;\n+    GC_n_dirty = 0;\n+    \n+    index = 0;\n+    for (i = 0; i < GC_n_heap_sects; i++) {\n+    \tstart = GC_heap_sects[i].hs_start;\n+        for (h = (struct hblk *)start;\n+             h < (struct hblk *)(start + GC_heap_sects[i].hs_bytes);\n+             h++) {\n+             GC_update_check_page(h, index);\n+             index++;\n+             if (index >= NSUMS) goto out;\n+        }\n+    }\n+out:\n+    GC_printf2(\"Checked %lu clean and %lu dirty pages\\n\",\n+    \t      (unsigned long) GC_n_clean, (unsigned long) GC_n_dirty);\n+    if (GC_n_dirty_errors > 0) {\n+        GC_printf1(\"Found %lu dirty bit errors\\n\",\n+        \t   (unsigned long)GC_n_dirty_errors);\n+    }\n+    if (GC_n_changed_errors > 0) {\n+    \tGC_printf1(\"Found %lu changed bit errors\\n\",\n+        \t   (unsigned long)GC_n_changed_errors);\n+\tGC_printf0(\"These may be benign (provoked by nonpointer changes)\\n\");\n+#\tifdef THREADS\n+\t    GC_printf0(\n+\t    \"Also expect 1 per thread currently allocating a stubborn obj.\\n\");\n+#\tendif\n+    }\n+}\n+\n+# else\n+\n+extern int GC_quiet;\n+\t/* ANSI C doesn't allow translation units to be empty.\t*/\n+\t/* So we guarantee this one is nonempty.\t\t*/\n+\n+# endif /* CHECKSUMS */"}, {"sha": "62101452313098510eeb0d0a11927f685fec1545", "filename": "boehm-gc/cord/README", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2FREADME?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,31 @@\n+Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+\n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+Permission is hereby granted to use or copy this program\n+for any purpose,  provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is granted,\n+provided the above notices are retained, and a notice that the code was\n+modified is included with the above copyright notice.\n+\n+Please send bug reports to Hans-J. Boehm (boehm@sgi.com).\n+\n+This is a string packages that uses a tree-based representation.\n+See cord.h for a description of the functions provided.  Ec.h describes\n+\"extensible cords\", which are essentially output streams that write\n+to a cord.  These allow for efficient construction of cords without\n+requiring a bound on the size of a cord.\n+\n+de.c is a very dumb text editor that illustrates the use of cords.\n+It maintains a list of file versions.  Each version is simply a\n+cord representing the file contents.  Nonetheless, standard\n+editing operations are efficient, even on very large files.\n+(Its 3 line \"user manual\" can be obtained by invoking it without\n+arguments.  Note that ^R^N and ^R^P move the cursor by\n+almost a screen.  It does not understand tabs, which will show\n+up as highlighred \"I\"s.  Use the UNIX \"expand\" program first.)\n+To build the editor, type \"make cord/de\" in the gc directory.\n+\n+This package assumes an ANSI C compiler such as gcc.  It will\n+not compile with an old-style K&R compiler."}, {"sha": "2a091970b8b009ce843ba1d86af94aaab2ff0994", "filename": "boehm-gc/cord/SCOPTIONS.amiga", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2FSCOPTIONS.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2FSCOPTIONS.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2FSCOPTIONS.amiga?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,14 @@\n+MATH=STANDARD\n+CPU=68030\n+NOSTACKCHECK\n+OPTIMIZE\n+VERBOSE\n+NOVERSION\n+NOICONS\n+OPTIMIZERTIME\n+INCLUDEDIR=/\n+DEFINE AMIGA\n+LIBRARY=cord.lib\n+LIBRARY=/gc.lib\n+IGNORE=100\n+IGNORE=161"}, {"sha": "5aef131e606f3b585d9cb61175f30b0a3bc5a3a9", "filename": "boehm-gc/cord/SMakefile.amiga", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2FSMakefile.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2FSMakefile.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2FSMakefile.amiga?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,20 @@\n+# Makefile for cord.lib\n+# Michel Schinz 1994/07/20\n+\n+OBJS = cordbscs.o cordprnt.o cordxtra.o\n+\n+all: cord.lib cordtest\n+\n+cordbscs.o: cordbscs.c\n+cordprnt.o: cordprnt.c\n+cordxtra.o: cordxtra.c\n+cordtest.o: cordtest.c\n+\n+cord.lib: $(OBJS)\n+\toml cord.lib r $(OBJS)\n+\n+cordtest: cordtest.o cord.lib\n+\tsc cordtest.o link\n+\n+clean:\n+\tdelete cord.lib cordtest \\#?.o \\#?.lnk"}, {"sha": "584112fd181089b8e61449db6fa02ca34f9157ad", "filename": "boehm-gc/cord/cord.h", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcord.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcord.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcord.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,327 @@\n+/* \n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n+ */\n+/* Boehm, October 5, 1995 4:20 pm PDT */\n+ \n+/*\n+ * Cords are immutable character strings.  A number of operations\n+ * on long cords are much more efficient than their strings.h counterpart.\n+ * In particular, concatenation takes constant time independent of the length\n+ * of the arguments.  (Cords are represented as trees, with internal\n+ * nodes representing concatenation and leaves consisting of either C\n+ * strings or a functional description of the string.)\n+ *\n+ * The following are reasonable applications of cords.  They would perform\n+ * unacceptably if C strings were used:\n+ * - A compiler that produces assembly language output by repeatedly\n+ *   concatenating instructions onto a cord representing the output file.\n+ * - A text editor that converts the input file to a cord, and then\n+ *   performs editing operations by producing a new cord representing\n+ *   the file after echa character change (and keeping the old ones in an\n+ *   edit history)\n+ *\n+ * For optimal performance, cords should be built by\n+ * concatenating short sections.\n+ * This interface is designed for maximum compatibility with C strings.\n+ * ASCII NUL characters may be embedded in cords using CORD_from_fn.\n+ * This is handled correctly, but CORD_to_char_star will produce a string\n+ * with embedded NULs when given such a cord. \n+ *\n+ * This interface is fairly big, largely for performance reasons.\n+ * The most basic constants and functions:\n+ *\n+ * CORD - the type fo a cord;\n+ * CORD_EMPTY - empty cord;\n+ * CORD_len(cord) - length of a cord;\n+ * CORD_cat(cord1,cord2) - concatenation of two cords;\n+ * CORD_substr(cord, start, len) - substring (or subcord);\n+ * CORD_pos i;  CORD_FOR(i, cord) {  ... CORD_pos_fetch(i) ... } -\n+ *    examine each character in a cord.  CORD_pos_fetch(i) is the char.\n+ * CORD_fetch(int i) - Retrieve i'th character (slowly).\n+ * CORD_cmp(cord1, cord2) - compare two cords.\n+ * CORD_from_file(FILE * f) - turn a read-only file into a cord.\n+ * CORD_to_char_star(cord) - convert to C string.\n+ *   (Non-NULL C constant strings are cords.)\n+ * CORD_printf (etc.) - cord version of printf. Use %r for cords.\n+ */\n+# ifndef CORD_H\n+\n+# define CORD_H\n+# include <stddef.h>\n+# include <stdio.h>\n+/* Cords have type const char *.  This is cheating quite a bit, and not\t*/\n+/* 100% portable.  But it means that nonempty character string\t\t*/\n+/* constants may be used as cords directly, provided the string is\t*/\n+/* never modified in place.  The empty cord is represented by, and\t*/\n+/* can be written as, 0.\t\t\t\t\t\t*/\n+\n+typedef const char * CORD;\n+\n+/* An empty cord is always represented as nil \t*/\n+# define CORD_EMPTY 0\n+\n+/* Is a nonempty cord represented as a C string? */\n+#define CORD_IS_STRING(s) (*(s) != '\\0')\n+\n+/* Concatenate two cords.  If the arguments are C strings, they may \t*/\n+/* not be subsequently altered.\t\t\t\t\t\t*/\n+CORD CORD_cat(CORD x, CORD y);\n+\n+/* Concatenate a cord and a C string with known length.  Except for the\t*/\n+/* empty string case, this is a special case of CORD_cat.  Since the\t*/\n+/* length is known, it can be faster.\t\t\t\t\t*/\n+/* The string y is shared with the resulting CORD.  Hence it should\t*/\n+/* not be altered by the caller.\t\t\t\t\t*/\n+CORD CORD_cat_char_star(CORD x, const char * y, size_t leny);\n+\n+/* Compute the length of a cord */\n+size_t CORD_len(CORD x);\n+\n+/* Cords may be represented by functions defining the ith character */\n+typedef char (* CORD_fn)(size_t i, void * client_data);\n+\n+/* Turn a functional description into a cord. \t*/\n+CORD CORD_from_fn(CORD_fn fn, void * client_data, size_t len);\n+\n+/* Return the substring (subcord really) of x with length at most n,\t*/\n+/* starting at position i.  (The initial character has position 0.)\t*/\n+CORD CORD_substr(CORD x, size_t i, size_t n);\n+\n+/* Return the argument, but rebalanced to allow more efficient   \t*/\n+/* character retrieval, substring operations, and comparisons.\t\t*/\n+/* This is useful only for cords that were built using repeated \t*/\n+/* concatenation.  Guarantees log time access to the result, unless\t*/\n+/* x was obtained through a large number of repeated substring ops\t*/\n+/* or the embedded functional descriptions take longer to evaluate.\t*/\n+/* May reallocate significant parts of the cord.  The argument is not\t*/\n+/* modified; only the result is balanced.\t\t\t\t*/\n+CORD CORD_balance(CORD x);\n+\n+/* The following traverse a cord by applying a function to each \t*/\n+/* character.  This is occasionally appropriate, especially where\t*/\n+/* speed is crucial.  But, since C doesn't have nested functions,\t*/\n+/* clients of this sort of traversal are clumsy to write.  Consider\t*/\n+/* the functions that operate on cord positions instead.\t\t*/\n+\n+/* Function to iteratively apply to individual characters in cord.\t*/\n+typedef int (* CORD_iter_fn)(char c, void * client_data);\n+\n+/* Function to apply to substrings of a cord.  Each substring is a \t*/\n+/* a C character string, not a general cord.\t\t\t\t*/\n+typedef int (* CORD_batched_iter_fn)(const char * s, void * client_data);\n+# define CORD_NO_FN ((CORD_batched_iter_fn)0)\n+\n+/* Apply f1 to each character in the cord, in ascending order,\t\t*/\n+/* starting at position i. If\t\t\t\t\t\t*/\n+/* f2 is not CORD_NO_FN, then multiple calls to f1 may be replaced by\t*/\n+/* a single call to f2.  The parameter f2 is provided only to allow\t*/\n+/* some optimization by the client.  This terminates when the right\t*/\n+/* end of this string is reached, or when f1 or f2 return != 0.  In the\t*/\n+/* latter case CORD_iter returns != 0.  Otherwise it returns 0.\t\t*/\n+/* The specified value of i must be < CORD_len(x).\t\t\t*/\n+int CORD_iter5(CORD x, size_t i, CORD_iter_fn f1,\n+\t       CORD_batched_iter_fn f2, void * client_data);\n+\n+/* A simpler version that starts at 0, and without f2:\t*/\n+int CORD_iter(CORD x, CORD_iter_fn f1, void * client_data);\n+# define CORD_iter(x, f1, cd) CORD_iter5(x, 0, f1, CORD_NO_FN, cd)\n+\n+/* Similar to CORD_iter5, but end-to-beginning.\tNo provisions for\t*/\n+/* CORD_batched_iter_fn.\t\t\t\t\t\t*/\n+int CORD_riter4(CORD x, size_t i, CORD_iter_fn f1, void * client_data);\n+\n+/* A simpler version that starts at the end:\t*/\n+int CORD_riter(CORD x, CORD_iter_fn f1, void * client_data);\n+\n+/* Functions that operate on cord positions.  The easy way to traverse\t*/\n+/* cords.  A cord position is logically a pair consisting of a cord\t*/\n+/* and an index into that cord.  But it is much faster to retrieve a\t*/\n+/* charcter based on a position than on an index.  Unfortunately,\t*/\n+/* positions are big (order of a few 100 bytes), so allocate them with\t*/\n+/* caution.\t\t\t\t\t\t\t\t*/\n+/* Things in cord_pos.h should be treated as opaque, except as\t\t*/\n+/* described below.  Also note that\t\t\t\t\t*/\n+/* CORD_pos_fetch, CORD_next and CORD_prev have both macro and function\t*/\n+/* definitions.  The former may evaluate their argument more than once. */\n+# include \"private/cord_pos.h\"\n+\n+/*\n+\tVisible definitions from above:\n+\t\n+\ttypedef <OPAQUE but fairly big> CORD_pos[1];\n+\t\n+\t* Extract the cord from a position:\n+\tCORD CORD_pos_to_cord(CORD_pos p);\n+\t\n+\t* Extract the current index from a position:\n+\tsize_t CORD_pos_to_index(CORD_pos p);\n+\t\n+\t* Fetch the character located at the given position:\n+\tchar CORD_pos_fetch(CORD_pos p);\n+\t\n+\t* Initialize the position to refer to the given cord and index.\n+\t* Note that this is the most expensive function on positions:\n+\tvoid CORD_set_pos(CORD_pos p, CORD x, size_t i);\n+\t\n+\t* Advance the position to the next character.\n+\t* P must be initialized and valid.\n+\t* Invalidates p if past end:\n+\tvoid CORD_next(CORD_pos p);\n+\t\n+\t* Move the position to the preceding character.\n+\t* P must be initialized and valid.\n+\t* Invalidates p if past beginning:\n+\tvoid CORD_prev(CORD_pos p);\n+\t\n+\t* Is the position valid, i.e. inside the cord?\n+\tint CORD_pos_valid(CORD_pos p);\n+*/\n+# define CORD_FOR(pos, cord) \\\n+    for (CORD_set_pos(pos, cord, 0); CORD_pos_valid(pos); CORD_next(pos))\n+\n+\t\t\t\n+/* An out of memory handler to call.  May be supplied by client.\t*/\n+/* Must not return.\t\t\t\t\t\t\t*/\n+extern void (* CORD_oom_fn)(void);\n+\n+/* Dump the representation of x to stdout in an implementation defined\t*/\n+/* manner.  Intended for debugging only.\t\t\t\t*/\n+void CORD_dump(CORD x);\n+\n+/* The following could easily be implemented by the client.  They are\t*/\n+/* provided in cordxtra.c for convenience.\t\t\t\t*/\n+\n+/* Concatenate a character to the end of a cord.\t*/\n+CORD CORD_cat_char(CORD x, char c);\n+\n+/* Concatenate n cords.\t*/\n+CORD CORD_catn(int n, /* CORD */ ...);\n+\n+/* Return the character in CORD_substr(x, i, 1)  \t*/\n+char CORD_fetch(CORD x, size_t i);\n+\n+/* Return < 0, 0, or > 0, depending on whether x < y, x = y, x > y\t*/\n+int CORD_cmp(CORD x, CORD y);\n+\n+/* A generalization that takes both starting positions for the \t\t*/\n+/* comparison, and a limit on the number of characters to be compared.\t*/\n+int CORD_ncmp(CORD x, size_t x_start, CORD y, size_t y_start, size_t len);\n+\n+/* Find the first occurrence of s in x at position start or later.\t*/\n+/* Return the position of the first character of s in x, or\t\t*/\n+/* CORD_NOT_FOUND if there is none.\t\t\t\t\t*/\n+size_t CORD_str(CORD x, size_t start, CORD s);\n+\n+/* Return a cord consisting of i copies of (possibly NUL) c.  Dangerous\t*/\n+/* in conjunction with CORD_to_char_star.\t\t\t\t*/\n+/* The resulting representation takes constant space, independent of i.\t*/\n+CORD CORD_chars(char c, size_t i);\n+# define CORD_nul(i) CORD_chars('\\0', (i))\n+\n+/* Turn a file into cord.  The file must be seekable.  Its contents\t*/\n+/* must remain constant.  The file may be accessed as an immediate\t*/\n+/* result of this call and/or as a result of subsequent accesses to \t*/\n+/* the cord.  Short files are likely to be immediately read, but\t*/\n+/* long files are likely to be read on demand, possibly relying on \t*/\n+/* stdio for buffering.\t\t\t\t\t\t\t*/\n+/* We must have exclusive access to the descriptor f, i.e. we may\t*/\n+/* read it at any time, and expect the file pointer to be\t\t*/\n+/* where we left it.  Normally this should be invoked as\t\t*/\n+/* CORD_from_file(fopen(...))\t\t\t\t\t\t*/\n+/* CORD_from_file arranges to close the file descriptor when it is no\t*/\n+/* longer needed (e.g. when the result becomes inaccessible).\t\t*/ \n+/* The file f must be such that ftell reflects the actual character\t*/\n+/* position in the file, i.e. the number of characters that can be \t*/\n+/* or were read with fread.  On UNIX systems this is always true.  On\t*/\n+/* MS Windows systems, f must be opened in binary mode.\t\t\t*/\n+CORD CORD_from_file(FILE * f);\n+\n+/* Equivalent to the above, except that the entire file will be read\t*/\n+/* and the file pointer will be closed immediately.\t\t\t*/\n+/* The binary mode restriction from above does not apply.\t\t*/\n+CORD CORD_from_file_eager(FILE * f);\n+\n+/* Equivalent to the above, except that the file will be read on demand.*/\n+/* The binary mode restriction applies.\t\t\t\t\t*/\n+CORD CORD_from_file_lazy(FILE * f);\n+\n+/* Turn a cord into a C string.\tThe result shares no structure with\t*/\n+/* x, and is thus modifiable.\t\t\t\t\t\t*/\n+char * CORD_to_char_star(CORD x);\n+\n+/* Turn a C string into a CORD.  The C string is copied, and so may\t*/\n+/* subsequently be modified.\t\t\t\t\t\t*/\n+CORD CORD_from_char_star(const char *s);\n+\n+/* Identical to the above, but the result may share structure with\t*/\n+/* the argument and is thus not modifiable.\t\t\t\t*/\n+const char * CORD_to_const_char_star(CORD x); \n+\n+/* Write a cord to a file, starting at the current position.  No\t*/\n+/* trailing NULs are newlines are added.\t\t\t\t*/\n+/* Returns EOF if a write error occurs, 1 otherwise.\t\t\t*/\n+int CORD_put(CORD x, FILE * f);\n+\n+/* \"Not found\" result for the following two functions.\t\t\t*/\n+# define CORD_NOT_FOUND ((size_t)(-1))\n+\n+/* A vague analog of strchr.  Returns the position (an integer, not\t*/\n+/* a pointer) of the first occurrence of (char) c inside x at position \t*/\n+/* i or later. The value i must be < CORD_len(x).\t\t\t*/\n+size_t CORD_chr(CORD x, size_t i, int c);\n+\n+/* A vague analog of strrchr.  Returns index of the last occurrence\t*/\n+/* of (char) c inside x at position i or earlier. The value i\t\t*/\n+/* must be < CORD_len(x).\t\t\t\t\t\t*/\n+size_t CORD_rchr(CORD x, size_t i, int c);\n+\n+\n+/* The following are also not primitive, but are implemented in \t*/\n+/* cordprnt.c.  They provide functionality similar to the ANSI C\t*/\n+/* functions with corresponding names, but with the following\t\t*/\n+/* additions and changes:\t\t\t\t\t\t*/\n+/* 1. A %r conversion specification specifies a CORD argument.  Field\t*/\n+/*    width, precision, etc. have the same semantics as for %s.\t\t*/\n+/*    (Note that %c,%C, and %S were already taken.)\t\t\t*/\n+/* 2. The format string is represented as a CORD.\t\t        */\n+/* 3. CORD_sprintf and CORD_vsprintf assign the result through the 1st\t*/ \t/*    argument.\tUnlike their ANSI C versions, there is no need to guess\t*/\n+/*    the correct buffer size.\t\t\t\t\t\t*/\n+/* 4. Most of the conversions are implement through the native \t\t*/\n+/*    vsprintf.  Hence they are usually no faster, and \t\t\t*/\n+/*    idiosyncracies of the native printf are preserved.  However,\t*/\n+/*    CORD arguments to CORD_sprintf and CORD_vsprintf are NOT copied;\t*/\n+/*    the result shares the original structure.  This may make them\t*/\n+/*    very efficient in some unusual applications.\t\t\t*/\n+/*    The format string is copied.\t\t\t\t\t*/\n+/* All functions return the number of characters generated or -1 on\t*/\n+/* error.  This complies with the ANSI standard, but is inconsistent\t*/\n+/* with some older implementations of sprintf.\t\t\t\t*/\n+\n+/* The implementation of these is probably less portable than the rest\t*/\n+/* of this package.\t\t\t\t\t\t\t*/\n+\n+#ifndef CORD_NO_IO\n+\n+#include <stdarg.h>\n+\n+int CORD_sprintf(CORD * out, CORD format, ...);\n+int CORD_vsprintf(CORD * out, CORD format, va_list args);\n+int CORD_fprintf(FILE * f, CORD format, ...);\n+int CORD_vfprintf(FILE * f, CORD format, va_list args);\n+int CORD_printf(CORD format, ...);\n+int CORD_vprintf(CORD format, va_list args);\n+\n+#endif /* CORD_NO_IO */\n+\n+# endif /* CORD_H */"}, {"sha": "b75f5812f1794f3620c57da5920f0b1e19014ed9", "filename": "boehm-gc/cord/cordbscs.c", "status": "added", "additions": 916, "deletions": 0, "changes": 916, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordbscs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordbscs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordbscs.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,916 @@\n+/*\n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n+ */\n+/* Boehm, October 3, 1994 5:19 pm PDT */\n+# include \"gc.h\"\n+# include \"cord.h\"\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <string.h>\n+\n+/* An implementation of the cord primitives.  These are the only \t*/\n+/* Functions that understand the representation.  We perform only\t*/\n+/* minimal checks on arguments to these functions.  Out of bounds\t*/\n+/* arguments to the iteration functions may result in client functions\t*/\n+/* invoked on garbage data.  In most cases, client functions should be\t*/\n+/* programmed defensively enough that this does not result in memory\t*/\n+/* smashes.\t\t\t\t\t\t\t\t*/ \n+\n+typedef void (* oom_fn)(void);\n+\n+oom_fn CORD_oom_fn = (oom_fn) 0;\n+\n+# define OUT_OF_MEMORY {  if (CORD_oom_fn != (oom_fn) 0) (*CORD_oom_fn)(); \\\n+\t\t\t  ABORT(\"Out of memory\\n\"); }\n+# define ABORT(msg) { fprintf(stderr, \"%s\\n\", msg); abort(); }\n+\n+typedef unsigned long word;\n+\n+typedef union {\n+    struct Concatenation {\n+    \tchar null;\n+\tchar header;\n+\tchar depth;\t/* concatenation nesting depth. */\n+\tunsigned char left_len;\n+\t\t\t/* Length of left child if it is sufficiently\t*/\n+\t\t\t/* short; 0 otherwise.\t\t\t\t*/\n+#\t    define MAX_LEFT_LEN 255\n+\tword len;\n+\tCORD left;\t/* length(left) > 0\t*/\n+\tCORD right;\t/* length(right) > 0\t*/\n+    } concatenation;\n+    struct Function {\n+\tchar null;\n+\tchar header;\n+\tchar depth;\t/* always 0\t*/\n+\tchar left_len;\t/* always 0\t*/\n+\tword len;\n+\tCORD_fn fn;\n+\tvoid * client_data;\n+    } function;\n+    struct Generic {\n+    \tchar null;\n+\tchar header;\n+\tchar depth;\n+\tchar left_len;\n+\tword len;\n+    } generic;\n+    char string[1];\n+} CordRep;\n+\n+# define CONCAT_HDR 1\n+\t\n+# define FN_HDR 4\n+# define SUBSTR_HDR 6\n+\t/* Substring nodes are a special case of function nodes.  \t*/\n+\t/* The client_data field is known to point to a substr_args\t*/\n+\t/* structure, and the function is either CORD_apply_access_fn \t*/\n+\t/* or CORD_index_access_fn.\t\t\t\t\t*/\n+\n+/* The following may be applied only to function and concatenation nodes: */\n+#define IS_CONCATENATION(s)  (((CordRep *)s)->generic.header == CONCAT_HDR)\n+\n+#define IS_FUNCTION(s)  ((((CordRep *)s)->generic.header & FN_HDR) != 0)\n+\n+#define IS_SUBSTR(s) (((CordRep *)s)->generic.header == SUBSTR_HDR)\n+\n+#define LEN(s) (((CordRep *)s) -> generic.len)\n+#define DEPTH(s) (((CordRep *)s) -> generic.depth)\n+#define GEN_LEN(s) (CORD_IS_STRING(s) ? strlen(s) : LEN(s))\n+\n+#define LEFT_LEN(c) ((c) -> left_len != 0? \\\n+\t\t\t\t(c) -> left_len \\\n+\t\t\t\t: (CORD_IS_STRING((c) -> left) ? \\\n+\t\t\t\t\t(c) -> len - GEN_LEN((c) -> right) \\\n+\t\t\t\t\t: LEN((c) -> left)))\n+\n+#define SHORT_LIMIT (sizeof(CordRep) - 1)\n+\t/* Cords shorter than this are C strings */\n+\n+\n+/* Dump the internal representation of x to stdout, with initial \t*/\n+/* indentation level n.\t\t\t\t\t\t\t*/\n+void CORD_dump_inner(CORD x, unsigned n)\n+{\n+    register size_t i;\n+    \n+    for (i = 0; i < (size_t)n; i++) {\n+        fputs(\"  \", stdout);\n+    }\n+    if (x == 0) {\n+      \tfputs(\"NIL\\n\", stdout);\n+    } else if (CORD_IS_STRING(x)) {\n+        for (i = 0; i <= SHORT_LIMIT; i++) {\n+            if (x[i] == '\\0') break;\n+            putchar(x[i]);\n+        }\n+        if (x[i] != '\\0') fputs(\"...\", stdout);\n+        putchar('\\n');\n+    } else if (IS_CONCATENATION(x)) {\n+        register struct Concatenation * conc =\n+        \t\t\t&(((CordRep *)x) -> concatenation);\n+        printf(\"Concatenation: %p (len: %d, depth: %d)\\n\",\n+               x, (int)(conc -> len), (int)(conc -> depth));\n+        CORD_dump_inner(conc -> left, n+1);\n+        CORD_dump_inner(conc -> right, n+1);\n+    } else /* function */{\n+        register struct Function * func =\n+        \t\t\t&(((CordRep *)x) -> function);\n+        if (IS_SUBSTR(x)) printf(\"(Substring) \");\n+        printf(\"Function: %p (len: %d): \", x, (int)(func -> len));\n+        for (i = 0; i < 20 && i < func -> len; i++) {\n+            putchar((*(func -> fn))(i, func -> client_data));\n+        }\n+        if (i < func -> len) fputs(\"...\", stdout);\n+        putchar('\\n');\n+    }\n+}\n+\n+/* Dump the internal representation of x to stdout\t*/\n+void CORD_dump(CORD x)\n+{\n+    CORD_dump_inner(x, 0);\n+    fflush(stdout);\n+}\n+\n+CORD CORD_cat_char_star(CORD x, const char * y, size_t leny)\n+{\n+    register size_t result_len;\n+    register size_t lenx;\n+    register int depth;\n+    \n+    if (x == CORD_EMPTY) return(y);\n+    if (leny == 0) return(x);\n+    if (CORD_IS_STRING(x)) {\n+        lenx = strlen(x);\n+        result_len = lenx + leny;\n+        if (result_len <= SHORT_LIMIT) {\n+            register char * result = GC_MALLOC_ATOMIC(result_len+1);\n+        \n+            if (result == 0) OUT_OF_MEMORY;\n+            memcpy(result, x, lenx);\n+            memcpy(result + lenx, y, leny);\n+            result[result_len] = '\\0';\n+            return((CORD) result);\n+        } else {\n+            depth = 1;\n+        }\n+    } else {\n+    \tregister CORD right;\n+    \tregister CORD left;\n+    \tregister char * new_right;\n+    \tregister size_t right_len;\n+    \t\n+    \tlenx = LEN(x);\n+    \t\n+        if (leny <= SHORT_LIMIT/2\n+    \t    && IS_CONCATENATION(x)\n+            && CORD_IS_STRING(right = ((CordRep *)x) -> concatenation.right)) {\n+            /* Merge y into right part of x. */\n+            if (!CORD_IS_STRING(left = ((CordRep *)x) -> concatenation.left)) {\n+            \tright_len = lenx - LEN(left);\n+            } else if (((CordRep *)x) -> concatenation.left_len != 0) {\n+                right_len = lenx - ((CordRep *)x) -> concatenation.left_len;\n+            } else {\n+            \tright_len = strlen(right);\n+            }\n+            result_len = right_len + leny;  /* length of new_right */\n+            if (result_len <= SHORT_LIMIT) {\n+            \tnew_right = GC_MALLOC_ATOMIC(result_len + 1);\n+            \tmemcpy(new_right, right, right_len);\n+            \tmemcpy(new_right + right_len, y, leny);\n+            \tnew_right[result_len] = '\\0';\n+            \ty = new_right;\n+            \tleny = result_len;\n+            \tx = left;\n+            \tlenx -= right_len;\n+            \t/* Now fall through to concatenate the two pieces: */\n+            }\n+            if (CORD_IS_STRING(x)) {\n+                depth = 1;\n+            } else {\n+                depth = DEPTH(x) + 1;\n+            }\n+        } else {\n+            depth = DEPTH(x) + 1;\n+        }\n+        result_len = lenx + leny;\n+    }\n+    {\n+      /* The general case; lenx, result_len is known: */\n+    \tregister struct Concatenation * result;\n+    \t\n+    \tresult = GC_NEW(struct Concatenation);\n+    \tif (result == 0) OUT_OF_MEMORY;\n+    \tresult->header = CONCAT_HDR;\n+    \tresult->depth = depth;\n+    \tif (lenx <= MAX_LEFT_LEN) result->left_len = lenx;\n+    \tresult->len = result_len;\n+    \tresult->left = x;\n+    \tresult->right = y;\n+    \tif (depth > MAX_DEPTH) {\n+    \t    return(CORD_balance((CORD)result));\n+    \t} else {\n+    \t    return((CORD) result);\n+    \t}\n+    }\n+}\n+\n+\n+CORD CORD_cat(CORD x, CORD y)\n+{\n+    register size_t result_len;\n+    register int depth;\n+    register size_t lenx;\n+    \n+    if (x == CORD_EMPTY) return(y);\n+    if (y == CORD_EMPTY) return(x);\n+    if (CORD_IS_STRING(y)) {\n+        return(CORD_cat_char_star(x, y, strlen(y)));\n+    } else if (CORD_IS_STRING(x)) {\n+        lenx = strlen(x);\n+        depth = DEPTH(y) + 1;\n+    } else {\n+        register int depthy = DEPTH(y);\n+        \n+        lenx = LEN(x);\n+        depth = DEPTH(x) + 1;\n+        if (depthy >= depth) depth = depthy + 1;\n+    }\n+    result_len = lenx + LEN(y);\n+    {\n+    \tregister struct Concatenation * result;\n+    \t\n+    \tresult = GC_NEW(struct Concatenation);\n+    \tif (result == 0) OUT_OF_MEMORY;\n+    \tresult->header = CONCAT_HDR;\n+    \tresult->depth = depth;\n+    \tif (lenx <= MAX_LEFT_LEN) result->left_len = lenx;\n+    \tresult->len = result_len;\n+    \tresult->left = x;\n+    \tresult->right = y;\n+    \treturn((CORD) result);\n+    }\n+}\n+\n+\n+\n+CORD CORD_from_fn(CORD_fn fn, void * client_data, size_t len)\n+{\n+    if (len <= 0) return(0);\n+    if (len <= SHORT_LIMIT) {\n+        register char * result;\n+        register size_t i;\n+        char buf[SHORT_LIMIT+1];\n+        register char c;\n+        \n+        for (i = 0; i < len; i++) {\n+            c = (*fn)(i, client_data);\n+            if (c == '\\0') goto gen_case;\n+            buf[i] = c;\n+        }\n+        buf[i] = '\\0';\n+        result = GC_MALLOC_ATOMIC(len+1);\n+        if (result == 0) OUT_OF_MEMORY;\n+        strcpy(result, buf);\n+        result[len] = '\\0';\n+        return((CORD) result);\n+    }\n+  gen_case:\n+    {\n+    \tregister struct Function * result;\n+    \t\n+    \tresult = GC_NEW(struct Function);\n+    \tif (result == 0) OUT_OF_MEMORY;\n+    \tresult->header = FN_HDR;\n+    \t/* depth is already 0 */\n+    \tresult->len = len;\n+    \tresult->fn = fn;\n+    \tresult->client_data = client_data;\n+    \treturn((CORD) result);\n+    }\n+}\n+\n+size_t CORD_len(CORD x)\n+{\n+    if (x == 0) {\n+     \treturn(0);\n+    } else {\n+\treturn(GEN_LEN(x));\n+    }\n+}\n+\n+struct substr_args {\n+    CordRep * sa_cord;\n+    size_t sa_index;\n+};\n+\n+char CORD_index_access_fn(size_t i, void * client_data)\n+{\n+    register struct substr_args *descr = (struct substr_args *)client_data;\n+    \n+    return(((char *)(descr->sa_cord))[i + descr->sa_index]);\n+}\n+\n+char CORD_apply_access_fn(size_t i, void * client_data)\n+{\n+    register struct substr_args *descr = (struct substr_args *)client_data;\n+    register struct Function * fn_cord = &(descr->sa_cord->function);\n+    \n+    return((*(fn_cord->fn))(i + descr->sa_index, fn_cord->client_data));\n+}\n+\n+/* A version of CORD_substr that simply returns a function node, thus\t*/\n+/* postponing its work.\tThe fourth argument is a function that may\t*/\n+/* be used for efficient access to the ith character.\t\t\t*/\n+/* Assumes i >= 0 and i + n < length(x).\t\t\t\t*/\n+CORD CORD_substr_closure(CORD x, size_t i, size_t n, CORD_fn f)\n+{\n+    register struct substr_args * sa = GC_NEW(struct substr_args);\n+    CORD result;\n+    \n+    if (sa == 0) OUT_OF_MEMORY;\n+    sa->sa_cord = (CordRep *)x;\n+    sa->sa_index = i;\n+    result = CORD_from_fn(f, (void *)sa, n);\n+    ((CordRep *)result) -> function.header = SUBSTR_HDR;\n+    return (result);\n+}\n+\n+# define SUBSTR_LIMIT (10 * SHORT_LIMIT)\n+\t/* Substrings of function nodes and flat strings shorter than \t*/\n+\t/* this are flat strings.  Othewise we use a functional \t*/\n+\t/* representation, which is significantly slower to access.\t*/\n+\n+/* A version of CORD_substr that assumes i >= 0, n > 0, and i + n < length(x).*/\n+CORD CORD_substr_checked(CORD x, size_t i, size_t n)\n+{\n+    if (CORD_IS_STRING(x)) {\n+        if (n > SUBSTR_LIMIT) {\n+            return(CORD_substr_closure(x, i, n, CORD_index_access_fn));\n+        } else {\n+            register char * result = GC_MALLOC_ATOMIC(n+1);\n+            register char * p = result;\n+            \n+            if (result == 0) OUT_OF_MEMORY;\n+            strncpy(result, x+i, n);\n+            result[n] = '\\0';\n+            return(result);\n+        }\n+    } else if (IS_CONCATENATION(x)) {\n+    \tregister struct Concatenation * conc\n+    \t\t\t= &(((CordRep *)x) -> concatenation);\n+    \tregister size_t left_len;\n+    \tregister size_t right_len;\n+    \t\n+    \tleft_len = LEFT_LEN(conc);\n+    \tright_len = conc -> len - left_len;\n+    \tif (i >= left_len) {\n+    \t    if (n == right_len) return(conc -> right);\n+    \t    return(CORD_substr_checked(conc -> right, i - left_len, n));\n+    \t} else if (i+n <= left_len) {\n+    \t    if (n == left_len) return(conc -> left);\n+    \t    return(CORD_substr_checked(conc -> left, i, n));\n+    \t} else {\n+    \t    /* Need at least one character from each side. */\n+    \t    register CORD left_part;\n+    \t    register CORD right_part;\n+    \t    register size_t left_part_len = left_len - i;\n+     \t\n+    \t    if (i == 0) {\n+    \t        left_part = conc -> left;\n+    \t    } else {\n+    \t        left_part = CORD_substr_checked(conc -> left, i, left_part_len);\n+    \t    }\n+    \t    if (i + n == right_len + left_len) {\n+    \t         right_part = conc -> right;\n+    \t    } else {\n+    \t         right_part = CORD_substr_checked(conc -> right, 0,\n+    \t    \t\t\t\t          n - left_part_len);\n+    \t    }\n+    \t    return(CORD_cat(left_part, right_part));\n+    \t}\n+    } else /* function */ {\n+        if (n > SUBSTR_LIMIT) {\n+            if (IS_SUBSTR(x)) {\n+            \t/* Avoid nesting substring nodes.\t*/\n+            \tregister struct Function * f = &(((CordRep *)x) -> function);\n+            \tregister struct substr_args *descr =\n+            \t\t\t(struct substr_args *)(f -> client_data);\n+            \t\n+            \treturn(CORD_substr_closure((CORD)descr->sa_cord,\n+            \t\t\t\t   i + descr->sa_index,\n+            \t\t\t\t   n, f -> fn));\n+            } else {\n+                return(CORD_substr_closure(x, i, n, CORD_apply_access_fn));\n+            }\n+        } else {\n+            char * result;\n+            register struct Function * f = &(((CordRep *)x) -> function);\n+            char buf[SUBSTR_LIMIT+1];\n+            register char * p = buf;\n+            register char c;\n+            register int j;\n+            register int lim = i + n;\n+            \n+            for (j = i; j < lim; j++) {\n+            \tc = (*(f -> fn))(j, f -> client_data);\n+            \tif (c == '\\0') {\n+            \t    return(CORD_substr_closure(x, i, n, CORD_apply_access_fn));\n+            \t}\n+            \t*p++ = c;\n+            }\n+            *p = '\\0';\n+            result = GC_MALLOC_ATOMIC(n+1);\n+            if (result == 0) OUT_OF_MEMORY;\n+            strcpy(result, buf);\n+            return(result);\n+        }\n+    }\n+}\n+\n+CORD CORD_substr(CORD x, size_t i, size_t n)\n+{\n+    register size_t len = CORD_len(x);\n+    \n+    if (i >= len || n <= 0) return(0);\n+    \t/* n < 0 is impossible in a correct C implementation, but\t*/\n+    \t/* quite possible  under SunOS 4.X.\t\t\t\t*/\n+    if (i + n > len) n = len - i;\n+#   ifndef __STDC__\n+      if (i < 0) ABORT(\"CORD_substr: second arg. negative\");\n+    \t/* Possible only if both client and C implementation are buggy.\t*/\n+    \t/* But empirically this happens frequently.\t\t\t*/\n+#   endif\n+    return(CORD_substr_checked(x, i, n));\n+}\n+\n+/* See cord.h for definition.  We assume i is in range.\t*/\n+int CORD_iter5(CORD x, size_t i, CORD_iter_fn f1,\n+\t\t\t CORD_batched_iter_fn f2, void * client_data)\n+{\n+    if (x == 0) return(0);\n+    if (CORD_IS_STRING(x)) {\n+    \tregister const char *p = x+i;\n+    \t\n+    \tif (*p == '\\0') ABORT(\"2nd arg to CORD_iter5 too big\");\n+        if (f2 != CORD_NO_FN) {\n+            return((*f2)(p, client_data));\n+        } else {\n+\t    while (*p) {\n+                if ((*f1)(*p, client_data)) return(1);\n+                p++;\n+\t    }\n+\t    return(0);\n+        }\n+    } else if (IS_CONCATENATION(x)) {\n+    \tregister struct Concatenation * conc\n+    \t\t\t= &(((CordRep *)x) -> concatenation);\n+    \t\n+    \t\n+    \tif (i > 0) {\n+    \t    register size_t left_len = LEFT_LEN(conc);\n+    \t    \n+    \t    if (i >= left_len) {\n+    \t        return(CORD_iter5(conc -> right, i - left_len, f1, f2,\n+    \t        \t\t  client_data));\n+    \t    }\n+    \t}\n+    \tif (CORD_iter5(conc -> left, i, f1, f2, client_data)) {\n+    \t    return(1);\n+    \t}\n+    \treturn(CORD_iter5(conc -> right, 0, f1, f2, client_data));\n+    } else /* function */ {\n+        register struct Function * f = &(((CordRep *)x) -> function);\n+        register size_t j;\n+        register size_t lim = f -> len;\n+        \n+        for (j = i; j < lim; j++) {\n+            if ((*f1)((*(f -> fn))(j, f -> client_data), client_data)) {\n+                return(1);\n+            }\n+        }\n+        return(0);\n+    }\n+}\n+\t\t\t\n+#undef CORD_iter\n+int CORD_iter(CORD x, CORD_iter_fn f1, void * client_data)\n+{\n+    return(CORD_iter5(x, 0, f1, CORD_NO_FN, client_data));\n+}\n+\n+int CORD_riter4(CORD x, size_t i, CORD_iter_fn f1, void * client_data)\n+{\n+    if (x == 0) return(0);\n+    if (CORD_IS_STRING(x)) {\n+\tregister const char *p = x + i;\n+\tregister char c;\n+               \n+\tfor(;;) {\n+\t    c = *p;\n+\t    if (c == '\\0') ABORT(\"2nd arg to CORD_riter4 too big\");\n+            if ((*f1)(c, client_data)) return(1);\n+\t    if (p == x) break;\n+            p--;\n+\t}\n+\treturn(0);\n+    } else if (IS_CONCATENATION(x)) {\n+    \tregister struct Concatenation * conc\n+    \t\t\t= &(((CordRep *)x) -> concatenation);\n+    \tregister CORD left_part = conc -> left;\n+    \tregister size_t left_len;\n+    \t\n+    \tleft_len = LEFT_LEN(conc);\n+    \tif (i >= left_len) {\n+    \t    if (CORD_riter4(conc -> right, i - left_len, f1, client_data)) {\n+    \t    \treturn(1);\n+    \t    }\n+    \t    return(CORD_riter4(left_part, left_len - 1, f1, client_data));\n+    \t} else {\n+    \t    return(CORD_riter4(left_part, i, f1, client_data));\n+    \t}\n+    } else /* function */ {\n+        register struct Function * f = &(((CordRep *)x) -> function);\n+        register size_t j;\n+        \n+        for (j = i; ; j--) {\n+            if ((*f1)((*(f -> fn))(j, f -> client_data), client_data)) {\n+                return(1);\n+            }\n+            if (j == 0) return(0);\n+        }\n+    }\n+}\n+\n+int CORD_riter(CORD x, CORD_iter_fn f1, void * client_data)\n+{\n+    return(CORD_riter4(x, CORD_len(x) - 1, f1, client_data));\n+}\n+\n+/*\n+ * The following functions are concerned with balancing cords.\n+ * Strategy:\n+ * Scan the cord from left to right, keeping the cord scanned so far\n+ * as a forest of balanced trees of exponentialy decreasing length.\n+ * When a new subtree needs to be added to the forest, we concatenate all\n+ * shorter ones to the new tree in the appropriate order, and then insert\n+ * the result into the forest.\n+ * Crucial invariants:\n+ * 1. The concatenation of the forest (in decreasing order) with the\n+ *     unscanned part of the rope is equal to the rope being balanced.\n+ * 2. All trees in the forest are balanced.\n+ * 3. forest[i] has depth at most i.\n+ */\n+\n+typedef struct {\n+    CORD c;\n+    size_t len;\t\t/* Actual length of c \t*/\n+} ForestElement;\n+\n+static size_t min_len [ MAX_DEPTH ];\n+\n+static int min_len_init = 0;\n+\n+int CORD_max_len;\n+\n+typedef ForestElement Forest [ MAX_DEPTH ];\n+\t\t\t/* forest[i].len >= fib(i+1)\t        */\n+\t\t\t/* The string is the concatenation\t*/\n+\t\t\t/* of the forest in order of DECREASING */\n+\t\t\t/* indices.\t\t\t\t*/\n+\n+void CORD_init_min_len()\n+{\n+    register int i;\n+    register size_t last, previous, current;\n+        \n+    min_len[0] = previous = 1;\n+    min_len[1] = last = 2;\n+    for (i = 2; i < MAX_DEPTH; i++) {\n+    \tcurrent = last + previous;\n+    \tif (current < last) /* overflow */ current = last;\n+    \tmin_len[i] = current;\n+    \tprevious = last;\n+    \tlast = current;\n+    }\n+    CORD_max_len = last - 1;\n+    min_len_init = 1;\n+}\n+\n+\n+void CORD_init_forest(ForestElement * forest, size_t max_len)\n+{\n+    register int i;\n+    \n+    for (i = 0; i < MAX_DEPTH; i++) {\n+    \tforest[i].c = 0;\n+    \tif (min_len[i] > max_len) return;\n+    }\n+    ABORT(\"Cord too long\");\n+}\n+\n+/* Add a leaf to the appropriate level in the forest, cleaning\t\t*/\n+/* out lower levels as necessary.\t\t\t\t\t*/\n+/* Also works if x is a balanced tree of concatenations; however\t*/\n+/* in this case an extra concatenation node may be inserted above x;\t*/\n+/* This node should not be counted in the statement of the invariants.\t*/\n+void CORD_add_forest(ForestElement * forest, CORD x, size_t len)\n+{\n+    register int i = 0;\n+    register CORD sum = CORD_EMPTY;\n+    register size_t sum_len = 0;\n+    \n+    while (len > min_len[i + 1]) {\n+    \tif (forest[i].c != 0) {\n+    \t    sum = CORD_cat(forest[i].c, sum);\n+    \t    sum_len += forest[i].len;\n+    \t    forest[i].c = 0;\n+    \t}\n+        i++;\n+    }\n+    /* Sum has depth at most 1 greter than what would be required \t*/\n+    /* for balance.\t\t\t\t\t\t\t*/\n+    sum = CORD_cat(sum, x);\n+    sum_len += len;\n+    /* If x was a leaf, then sum is now balanced.  To see this\t\t*/\n+    /* consider the two cases in which forest[i-1] either is or is \t*/\n+    /* not empty.\t\t\t\t\t\t\t*/\n+    while (sum_len >= min_len[i]) {\n+    \tif (forest[i].c != 0) {\n+    \t    sum = CORD_cat(forest[i].c, sum);\n+    \t    sum_len += forest[i].len;\n+    \t    /* This is again balanced, since sum was balanced, and has\t*/\n+    \t    /* allowable depth that differs from i by at most 1.\t*/\n+    \t    forest[i].c = 0;\n+    \t}\n+        i++;\n+    }\n+    i--;\n+    forest[i].c = sum;\n+    forest[i].len = sum_len;\n+}\n+\n+CORD CORD_concat_forest(ForestElement * forest, size_t expected_len)\n+{\n+    register int i = 0;\n+    CORD sum = 0;\n+    size_t sum_len = 0;\n+    \n+    while (sum_len != expected_len) {\n+    \tif (forest[i].c != 0) {\n+    \t    sum = CORD_cat(forest[i].c, sum);\n+    \t    sum_len += forest[i].len;\n+    \t}\n+        i++;\n+    }\n+    return(sum);\n+}\n+\n+/* Insert the frontier of x into forest.  Balanced subtrees are\t*/\n+/* treated as leaves.  This potentially adds one to the depth\t*/\n+/* of the final tree.\t\t\t\t\t\t*/\n+void CORD_balance_insert(CORD x, size_t len, ForestElement * forest)\n+{\n+    register int depth;\n+    \n+    if (CORD_IS_STRING(x)) {\n+        CORD_add_forest(forest, x, len);\n+    } else if (IS_CONCATENATION(x)\n+               && ((depth = DEPTH(x)) >= MAX_DEPTH\n+                   || len < min_len[depth])) {\n+    \tregister struct Concatenation * conc\n+    \t\t\t= &(((CordRep *)x) -> concatenation);\n+    \tsize_t left_len = LEFT_LEN(conc);\n+    \t\n+    \tCORD_balance_insert(conc -> left, left_len, forest);\n+    \tCORD_balance_insert(conc -> right, len - left_len, forest);\n+    } else /* function or balanced */ {\n+    \tCORD_add_forest(forest, x, len);\n+    }\n+}\n+\n+\n+CORD CORD_balance(CORD x)\n+{\n+    Forest forest;\n+    register size_t len;\n+    \n+    if (x == 0) return(0);\n+    if (CORD_IS_STRING(x)) return(x);\n+    if (!min_len_init) CORD_init_min_len();\n+    len = LEN(x);\n+    CORD_init_forest(forest, len);\n+    CORD_balance_insert(x, len, forest);\n+    return(CORD_concat_forest(forest, len));\n+}\n+\n+\n+/* Position primitives\t*/\n+\n+/* Private routines to deal with the hard cases only: */\n+\n+/* P contains a prefix of the  path to cur_pos.\tExtend it to a full\t*/\n+/* path and set up leaf info.\t\t\t\t\t\t*/\n+/* Return 0 if past the end of cord, 1 o.w.\t\t\t\t*/\n+void CORD__extend_path(register CORD_pos p)\n+{\n+     register struct CORD_pe * current_pe = &(p[0].path[p[0].path_len]);\n+     register CORD top = current_pe -> pe_cord;\n+     register size_t pos = p[0].cur_pos;\n+     register size_t top_pos = current_pe -> pe_start_pos;\n+     register size_t top_len = GEN_LEN(top);\n+     \n+     /* Fill in the rest of the path. */\n+       while(!CORD_IS_STRING(top) && IS_CONCATENATION(top)) {\n+     \t register struct Concatenation * conc =\n+     \t \t\t&(((CordRep *)top) -> concatenation);\n+     \t register size_t left_len;\n+     \t \n+     \t left_len = LEFT_LEN(conc);\n+     \t current_pe++;\n+     \t if (pos >= top_pos + left_len) {\n+     \t     current_pe -> pe_cord = top = conc -> right;\n+     \t     current_pe -> pe_start_pos = top_pos = top_pos + left_len;\n+     \t     top_len -= left_len;\n+     \t } else {\n+     \t     current_pe -> pe_cord = top = conc -> left;\n+     \t     current_pe -> pe_start_pos = top_pos;\n+     \t     top_len = left_len;\n+     \t }\n+     \t p[0].path_len++;\n+       }\n+     /* Fill in leaf description for fast access. */\n+       if (CORD_IS_STRING(top)) {\n+         p[0].cur_leaf = top;\n+         p[0].cur_start = top_pos;\n+         p[0].cur_end = top_pos + top_len;\n+       } else {\n+         p[0].cur_end = 0;\n+       }\n+       if (pos >= top_pos + top_len) p[0].path_len = CORD_POS_INVALID;\n+}\n+\n+char CORD__pos_fetch(register CORD_pos p)\n+{\n+    /* Leaf is a function node */\n+    struct CORD_pe * pe = &((p)[0].path[(p)[0].path_len]);\n+    CORD leaf = pe -> pe_cord;\n+    register struct Function * f = &(((CordRep *)leaf) -> function);\n+    \n+    if (!IS_FUNCTION(leaf)) ABORT(\"CORD_pos_fetch: bad leaf\");\n+    return ((*(f -> fn))(p[0].cur_pos - pe -> pe_start_pos, f -> client_data));\n+}\n+\n+void CORD__next(register CORD_pos p)\n+{\n+    register size_t cur_pos = p[0].cur_pos + 1;\n+    register struct CORD_pe * current_pe = &((p)[0].path[(p)[0].path_len]);\n+    register CORD leaf = current_pe -> pe_cord;\n+    \n+    /* Leaf is not a string or we're at end of leaf */\n+    p[0].cur_pos = cur_pos;\n+    if (!CORD_IS_STRING(leaf)) {\n+    \t/* Function leaf\t*/\n+    \tregister struct Function * f = &(((CordRep *)leaf) -> function);\n+    \tregister size_t start_pos = current_pe -> pe_start_pos;\n+    \tregister size_t end_pos = start_pos + f -> len;\n+    \t\n+    \tif (cur_pos < end_pos) {\n+    \t  /* Fill cache and return. */\n+    \t    register size_t i;\n+    \t    register size_t limit = cur_pos + FUNCTION_BUF_SZ;\n+    \t    register CORD_fn fn = f -> fn;\n+    \t    register void * client_data = f -> client_data;\n+    \t    \n+    \t    if (limit > end_pos) {\n+    \t        limit = end_pos;\n+    \t    }\n+    \t    for (i = cur_pos; i < limit; i++) {\n+    \t        p[0].function_buf[i - cur_pos] =\n+    \t        \t(*fn)(i - start_pos, client_data);\n+    \t    }\n+    \t    p[0].cur_start = cur_pos;\n+    \t    p[0].cur_leaf = p[0].function_buf;\n+    \t    p[0].cur_end = limit;\n+    \t    return;\n+    \t}\n+    }\n+    /* End of leaf\t*/\n+    /* Pop the stack until we find two concatenation nodes with the \t*/\n+    /* same start position: this implies we were in left part.\t\t*/\n+    {\n+    \twhile (p[0].path_len > 0\n+    \t       && current_pe[0].pe_start_pos != current_pe[-1].pe_start_pos) {\n+    \t    p[0].path_len--;\n+    \t    current_pe--;\n+    \t}\n+    \tif (p[0].path_len == 0) {\n+\t    p[0].path_len = CORD_POS_INVALID;\n+            return;\n+\t}\n+    }\n+    p[0].path_len--;\n+    CORD__extend_path(p);\n+}\n+\n+void CORD__prev(register CORD_pos p)\n+{\n+    register struct CORD_pe * pe = &(p[0].path[p[0].path_len]);\n+    \n+    if (p[0].cur_pos == 0) {\n+        p[0].path_len = CORD_POS_INVALID;\n+        return;\n+    }\n+    p[0].cur_pos--;\n+    if (p[0].cur_pos >= pe -> pe_start_pos) return;\n+    \n+    /* Beginning of leaf\t*/\n+    \n+    /* Pop the stack until we find two concatenation nodes with the \t*/\n+    /* different start position: this implies we were in right part.\t*/\n+    {\n+    \tregister struct CORD_pe * current_pe = &((p)[0].path[(p)[0].path_len]);\n+    \t\n+    \twhile (p[0].path_len > 0\n+    \t       && current_pe[0].pe_start_pos == current_pe[-1].pe_start_pos) {\n+    \t    p[0].path_len--;\n+    \t    current_pe--;\n+    \t}\n+    }\n+    p[0].path_len--;\n+    CORD__extend_path(p);\n+}\n+\n+#undef CORD_pos_fetch\n+#undef CORD_next\n+#undef CORD_prev\n+#undef CORD_pos_to_index\n+#undef CORD_pos_to_cord\n+#undef CORD_pos_valid\n+\n+char CORD_pos_fetch(register CORD_pos p)\n+{\n+    if (p[0].cur_start <= p[0].cur_pos && p[0].cur_pos < p[0].cur_end) {\n+    \treturn(p[0].cur_leaf[p[0].cur_pos - p[0].cur_start]);\n+    } else {\n+        return(CORD__pos_fetch(p));\n+    }\n+}\n+\n+void CORD_next(CORD_pos p)\n+{\n+    if (p[0].cur_pos < p[0].cur_end - 1) {\n+    \tp[0].cur_pos++;\n+    } else {\n+    \tCORD__next(p);\n+    }\n+}\n+\n+void CORD_prev(CORD_pos p)\n+{\n+    if (p[0].cur_end != 0 && p[0].cur_pos > p[0].cur_start) {\n+    \tp[0].cur_pos--;\n+    } else {\n+    \tCORD__prev(p);\n+    }\n+}\n+\n+size_t CORD_pos_to_index(CORD_pos p)\n+{\n+    return(p[0].cur_pos);\n+}\n+\n+CORD CORD_pos_to_cord(CORD_pos p)\n+{\n+    return(p[0].path[0].pe_cord);\n+}\n+\n+int CORD_pos_valid(CORD_pos p)\n+{\n+    return(p[0].path_len != CORD_POS_INVALID);\n+}\n+\n+void CORD_set_pos(CORD_pos p, CORD x, size_t i)\n+{\n+    if (x == CORD_EMPTY) {\n+    \tp[0].path_len = CORD_POS_INVALID;\n+    \treturn;\n+    }\n+    p[0].path[0].pe_cord = x;\n+    p[0].path[0].pe_start_pos = 0;\n+    p[0].path_len = 0;\n+    p[0].cur_pos = i;\n+    CORD__extend_path(p);\n+}"}, {"sha": "667560f2592cbc0ab54ed89562956858f9fc2df1", "filename": "boehm-gc/cord/cordprnt.c", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,389 @@\n+/* \n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* An sprintf implementation that understands cords.  This is probably\t*/\n+/* not terribly portable.  It assumes an ANSI stdarg.h.  It further\t*/\n+/* assumes that I can make copies of va_list variables, and read \t*/\n+/* arguments repeatedly by applyting va_arg to the copies.  This\t*/\n+/* could be avoided at some performance cost.\t\t\t\t*/\n+/* We also assume that unsigned and signed integers of various kinds\t*/\n+/* have the same sizes, and can be cast back and forth.\t\t\t*/\n+/* We assume that void * and char * have the same size.\t\t\t*/\n+/* All this cruft is needed because we want to rely on the underlying\t*/\n+/* sprintf implementation whenever possible.\t\t\t\t*/\n+/* Boehm, September 21, 1995 6:00 pm PDT */\n+\n+#include \"cord.h\"\n+#include \"ec.h\"\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include \"gc.h\"\n+\n+#define CONV_SPEC_LEN 50\t/* Maximum length of a single\t*/\n+\t\t\t\t/* conversion specification.\t*/\n+#define CONV_RESULT_LEN 50\t/* Maximum length of any \t*/\n+\t\t\t\t/* conversion with default\t*/\n+\t\t\t\t/* width and prec.\t\t*/\n+\n+\n+static int ec_len(CORD_ec x)\n+{\n+    return(CORD_len(x[0].ec_cord) + (x[0].ec_bufptr - x[0].ec_buf));\n+}\n+\n+/* Possible nonumeric precision values.\t*/\n+# define NONE -1\n+# define VARIABLE -2\n+/* Copy the conversion specification from CORD_pos into the buffer buf\t*/\n+/* Return negative on error.\t\t\t\t\t\t*/\n+/* Source initially points one past the leading %.\t\t\t*/\n+/* It is left pointing at the conversion type.\t\t\t\t*/\n+/* Assign field width and precision to *width and *prec.\t\t*/\n+/* If width or prec is *, VARIABLE is assigned.\t\t\t\t*/\n+/* Set *left to 1 if left adjustment flag is present.\t\t\t*/\n+/* Set *long_arg to 1 if long flag ('l' or 'L') is present, or to\t*/\n+/* -1 if 'h' is present.\t\t\t\t\t\t*/\n+static int extract_conv_spec(CORD_pos source, char *buf,\n+\t\t\t     int * width, int *prec, int *left, int * long_arg)\n+{\n+    register int result = 0;\n+    register int current_number = 0;\n+    register int saw_period = 0;\n+    register int saw_number;\n+    register int chars_so_far = 0;\n+    register char current;\n+    \n+    *width = NONE;\n+    buf[chars_so_far++] = '%';\n+    while(CORD_pos_valid(source)) {\n+        if (chars_so_far >= CONV_SPEC_LEN) return(-1);\n+        current = CORD_pos_fetch(source);\n+        buf[chars_so_far++] = current;\n+        switch(current) {\n+\t  case '*':\n+\t    saw_number = 1;\n+\t    current_number = VARIABLE;\n+\t    break;\n+          case '0':\n+            if (!saw_number) {\n+                /* Zero fill flag; ignore */\n+                break;\n+            } /* otherwise fall through: */\n+          case '1':\n+\t  case '2':\n+\t  case '3':\n+\t  case '4':\n+\t  case '5':\n+          case '6':\n+\t  case '7':\n+\t  case '8':\n+\t  case '9':\n+\t    saw_number = 1;\n+\t    current_number *= 10;\n+\t    current_number += current - '0';\n+\t    break;\n+\t  case '.':\n+\t    saw_period = 1;\n+\t    if(saw_number) {\n+\t        *width = current_number;\n+\t        saw_number = 0;\n+\t    }\n+\t    current_number = 0;\n+\t    break;\n+\t  case 'l':\n+\t  case 'L':\n+\t    *long_arg = 1;\n+\t    current_number = 0;\n+\t    break;\n+\t  case 'h':\n+\t    *long_arg = -1;\n+\t    current_number = 0;\n+\t    break;\n+\t  case ' ':\n+\t  case '+':\n+\t  case '#':\n+\t    current_number = 0;\n+\t    break;\n+\t  case '-':\n+\t    *left = 1;\n+\t    current_number = 0;\n+\t    break;\n+\t  case 'd':\n+\t  case 'i':\n+\t  case 'o':\n+\t  case 'u':\n+\t  case 'x':\n+\t  case 'X':\n+\t  case 'f':\n+\t  case 'e':\n+\t  case 'E':\n+\t  case 'g':\n+\t  case 'G':\n+\t  case 'c':\n+\t  case 'C':\n+\t  case 's':\n+\t  case 'S':\n+\t  case 'p':\n+\t  case 'n':\n+\t  case 'r':\n+\t    goto done;          \n+          default:\n+            return(-1);\n+        }\n+        CORD_next(source);\n+    }\n+    return(-1);\n+  done:\n+    if (saw_number) {\n+    \tif (saw_period) {\n+    \t    *prec = current_number;\n+    \t} else {\n+    \t    *prec = NONE;\n+    \t    *width = current_number;\n+    \t}\n+    } else {\n+    \t*prec = NONE;\n+    }\n+    buf[chars_so_far] = '\\0';\n+    return(result);\n+}\n+\n+int CORD_vsprintf(CORD * out, CORD format, va_list args)\n+{\n+    CORD_ec result;\n+    register int count;\n+    register char current;\n+    CORD_pos pos;\n+    char conv_spec[CONV_SPEC_LEN + 1];\n+    \n+    CORD_ec_init(result);\n+    for (CORD_set_pos(pos, format, 0); CORD_pos_valid(pos); CORD_next(pos)) {\n+       \tcurrent = CORD_pos_fetch(pos);\n+       \tif (current == '%') {\n+            CORD_next(pos);\n+            if (!CORD_pos_valid(pos)) return(-1);\n+            current = CORD_pos_fetch(pos);\n+            if (current == '%') {\n+               \tCORD_ec_append(result, current);\n+            } else {\n+             \tint width, prec;\n+             \tint left_adj = 0;\n+             \tint long_arg = 0;\n+\t\tCORD arg;\n+\t\tsize_t len;\n+               \n+              \tif (extract_conv_spec(pos, conv_spec,\n+              \t\t\t      &width, &prec,\n+              \t\t\t      &left_adj, &long_arg) < 0) {\n+              \t    return(-1);\n+              \t}\n+              \tcurrent = CORD_pos_fetch(pos);\n+            \tswitch(current) {\n+            \t    case 'n':\n+            \t    \t/* Assign length to next arg */\n+            \t    \tif (long_arg == 0) {\n+            \t    \t    int * pos_ptr;\n+            \t    \t    pos_ptr = va_arg(args, int *);\n+            \t    \t    *pos_ptr = ec_len(result);\n+            \t    \t} else if (long_arg > 0) {\n+            \t    \t    long * pos_ptr;\n+            \t    \t    pos_ptr = va_arg(args, long *);\n+            \t    \t    *pos_ptr = ec_len(result);\n+            \t    \t} else {\n+            \t    \t    short * pos_ptr;\n+            \t    \t    pos_ptr = va_arg(args, short *);\n+            \t    \t    *pos_ptr = ec_len(result);\n+            \t    \t}\n+            \t    \tgoto done;\n+            \t    case 'r':\n+            \t    \t/* Append cord and any padding\t*/\n+            \t    \tif (width == VARIABLE) width = va_arg(args, int);\n+            \t    \tif (prec == VARIABLE) prec = va_arg(args, int);\n+\t\t\targ = va_arg(args, CORD);\n+\t\t\tlen = CORD_len(arg);\n+\t\t\tif (prec != NONE && len > prec) {\n+\t\t\t  if (prec < 0) return(-1);\n+\t\t\t  arg = CORD_substr(arg, 0, prec);\n+\t\t\t  len = prec;\n+\t\t\t}\n+\t\t\tif (width != NONE && len < width) {\n+\t\t\t  char * blanks = GC_MALLOC_ATOMIC(width-len+1);\n+\n+\t\t\t  memset(blanks, ' ', width-len);\n+\t\t\t  blanks[width-len] = '\\0';\n+\t\t\t  if (left_adj) {\n+\t\t\t    arg = CORD_cat(arg, blanks);\n+\t\t\t  } else {\n+\t\t\t    arg = CORD_cat(blanks, arg);\n+\t\t\t  }\n+\t\t\t}\n+\t\t\tCORD_ec_append_cord(result, arg);\n+            \t    \tgoto done;\n+\t\t    case 'c':\n+\t\t\tif (width == NONE && prec == NONE) {\n+\t\t\t    register char c = va_arg(args, char);\n+\n+\t\t\t    CORD_ec_append(result, c);\n+\t\t\t    goto done;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t    case 's':\n+\t\t        if (width == NONE && prec == NONE) {\n+\t\t\t    char * str = va_arg(args, char *);\n+\t\t\t    register char c;\n+\n+\t\t\t    while (c = *str++) {\n+\t\t\t        CORD_ec_append(result, c);\n+\t\t\t    }\n+\t\t\t    goto done;\n+\t\t\t}\n+\t\t\tbreak;\n+            \t    default:\n+            \t        break;\n+            \t}\n+            \t/* Use standard sprintf to perform conversion */\n+            \t{\n+            \t    register char * buf;\n+            \t    va_list vsprintf_args = args;\n+            \t    \t/* The above does not appear to be sanctioned\t*/\n+            \t    \t/* by the ANSI C standard.\t\t\t*/\n+            \t    int max_size = 0;\n+            \t    int res;\n+            \t    \t\n+            \t    if (width == VARIABLE) width = va_arg(args, int);\n+            \t    if (prec == VARIABLE) prec = va_arg(args, int);\n+            \t    if (width != NONE) max_size = width;\n+            \t    if (prec != NONE && prec > max_size) max_size = prec;\n+            \t    max_size += CONV_RESULT_LEN;\n+            \t    if (max_size >= CORD_BUFSZ) {\n+            \t        buf = GC_MALLOC_ATOMIC(max_size + 1);\n+            \t    } else {\n+            \t        if (CORD_BUFSZ - (result[0].ec_bufptr-result[0].ec_buf)\n+            \t            < max_size) {\n+            \t            CORD_ec_flush_buf(result);\n+            \t        }\n+            \t        buf = result[0].ec_bufptr;\n+            \t    }\n+            \t    switch(current) {\n+            \t        case 'd':\n+            \t        case 'i':\n+            \t        case 'o':\n+            \t        case 'u':\n+            \t        case 'x':\n+            \t        case 'X':\n+            \t        case 'c':\n+            \t            if (long_arg <= 0) {\n+            \t              (void) va_arg(args, int);\n+            \t            } else if (long_arg > 0) {\n+            \t              (void) va_arg(args, long);\n+            \t            }\n+            \t            break;\n+            \t        case 's':\n+            \t        case 'p':\n+            \t            (void) va_arg(args, char *);\n+            \t            break;\n+            \t        case 'f':\n+            \t        case 'e':\n+            \t        case 'E':\n+            \t        case 'g':\n+            \t        case 'G':\n+            \t            (void) va_arg(args, double);\n+            \t            break;\n+            \t        default:\n+            \t            return(-1);\n+            \t    }\n+            \t    res = vsprintf(buf, conv_spec, vsprintf_args);\n+            \t    len = (size_t)res;\n+            \t    if ((char *)(GC_word)res == buf) {\n+            \t    \t/* old style vsprintf */\n+            \t    \tlen = strlen(buf);\n+            \t    } else if (res < 0) {\n+            \t        return(-1);\n+            \t    }\n+            \t    if (buf != result[0].ec_bufptr) {\n+            \t        register char c;\n+\n+\t\t\twhile (c = *buf++) {\n+\t\t\t    CORD_ec_append(result, c);\n+\t\t        }\n+\t\t    } else {\n+\t\t        result[0].ec_bufptr = buf + len;\n+\t\t    }\n+            \t}\n+              done:;\n+            }\n+        } else {\n+            CORD_ec_append(result, current);\n+        }\n+    }\n+    count = ec_len(result);\n+    *out = CORD_balance(CORD_ec_to_cord(result));\n+    return(count);\n+}\n+\n+int CORD_sprintf(CORD * out, CORD format, ...)\n+{\n+    va_list args;\n+    int result;\n+    \n+    va_start(args, format);\n+    result = CORD_vsprintf(out, format, args);\n+    va_end(args);\n+    return(result);\n+}\n+\n+int CORD_fprintf(FILE * f, CORD format, ...)\n+{\n+    va_list args;\n+    int result;\n+    CORD out;\n+    \n+    va_start(args, format);\n+    result = CORD_vsprintf(&out, format, args);\n+    va_end(args);\n+    if (result > 0) CORD_put(out, f);\n+    return(result);\n+}\n+\n+int CORD_vfprintf(FILE * f, CORD format, va_list args)\n+{\n+    int result;\n+    CORD out;\n+    \n+    result = CORD_vsprintf(&out, format, args);\n+    if (result > 0) CORD_put(out, f);\n+    return(result);\n+}\n+\n+int CORD_printf(CORD format, ...)\n+{\n+    va_list args;\n+    int result;\n+    CORD out;\n+    \n+    va_start(args, format);\n+    result = CORD_vsprintf(&out, format, args);\n+    va_end(args);\n+    if (result > 0) CORD_put(out, stdout);\n+    return(result);\n+}\n+\n+int CORD_vprintf(CORD format, va_list args)\n+{\n+    int result;\n+    CORD out;\n+    \n+    result = CORD_vsprintf(&out, format, args);\n+    if (result > 0) CORD_put(out, stdout);\n+    return(result);\n+}"}, {"sha": "d11d7dd44df49224ddc835a85e2cb88af6eb4e2c", "filename": "boehm-gc/cord/cordtest.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordtest.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,228 @@\n+/* \n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, August 24, 1994 11:58 am PDT */\n+# include \"cord.h\"\n+# include <string.h>\n+# include <stdio.h>\n+/* This is a very incomplete test of the cord package.  It knows about\t*/\n+/* a few internals of the package (e.g. when C strings are returned)\t*/\n+/* that real clients shouldn't rely on.\t\t\t\t\t*/\n+\n+# define ABORT(string) \\\n+{ int x = 0; fprintf(stderr, \"FAILED: %s\\n\", string); x = 1 / x; abort(); }\n+\n+int count;\n+\n+int test_fn(char c, void * client_data)\n+{\n+    if (client_data != (void *)13) ABORT(\"bad client data\");\n+    if (count < 64*1024+1) {\n+        if ((count & 1) == 0) {\n+            if (c != 'b') ABORT(\"bad char\");\n+        } else {\n+            if (c != 'a') ABORT(\"bad char\");\n+        }\n+        count++;\n+        return(0);\n+    } else {\n+        if (c != 'c') ABORT(\"bad char\");\n+        count++;\n+        return(1);\n+    }\n+}\n+\n+char id_cord_fn(size_t i, void * client_data)\n+{\n+    return((char)i);\n+}\n+\n+void test_basics()\n+{\n+    CORD x = CORD_from_char_star(\"ab\");\n+    register int i;\n+    char c;\n+    CORD y;\n+    CORD_pos p;\n+    \n+    x = CORD_cat(x,x);\n+    if (!CORD_IS_STRING(x)) ABORT(\"short cord should usually be a string\");\n+    if (strcmp(x, \"abab\") != 0) ABORT(\"bad CORD_cat result\");\n+    \n+    for (i = 1; i < 16; i++) {\n+        x = CORD_cat(x,x);\n+    }\n+    x = CORD_cat(x,\"c\");\n+    if (CORD_len(x) != 128*1024+1) ABORT(\"bad length\");\n+    \n+    count = 0;\n+    if (CORD_iter5(x, 64*1024-1, test_fn, CORD_NO_FN, (void *)13) == 0) {\n+        ABORT(\"CORD_iter5 failed\");\n+    }\n+    if (count != 64*1024 + 2) ABORT(\"CORD_iter5 failed\");\n+    \n+    count = 0;\n+    CORD_set_pos(p, x, 64*1024-1);\n+    while(CORD_pos_valid(p)) {\n+       \t(void) test_fn(CORD_pos_fetch(p), (void *)13);\n+\tCORD_next(p);\n+    }\n+    if (count != 64*1024 + 2) ABORT(\"Position based iteration failed\");\n+    \n+    y = CORD_substr(x, 1023, 5);\n+    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n+    if (strcmp(y, \"babab\") != 0) ABORT(\"bad CORD_substr result\");\n+    \n+    y = CORD_substr(x, 1024, 8);\n+    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n+    if (strcmp(y, \"abababab\") != 0) ABORT(\"bad CORD_substr result\");\n+    \n+    y = CORD_substr(x, 128*1024-1, 8);\n+    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n+    if (strcmp(y, \"bc\") != 0) ABORT(\"bad CORD_substr result\");\n+    \n+    x = CORD_balance(x);\n+    if (CORD_len(x) != 128*1024+1) ABORT(\"bad length\");\n+    \n+    count = 0;\n+    if (CORD_iter5(x, 64*1024-1, test_fn, CORD_NO_FN, (void *)13) == 0) {\n+        ABORT(\"CORD_iter5 failed\");\n+    }\n+    if (count != 64*1024 + 2) ABORT(\"CORD_iter5 failed\");\n+    \n+    y = CORD_substr(x, 1023, 5);\n+    if (!CORD_IS_STRING(y)) ABORT(\"short cord should usually be a string\");\n+    if (strcmp(y, \"babab\") != 0) ABORT(\"bad CORD_substr result\");\n+    y = CORD_from_fn(id_cord_fn, 0, 13);\n+    i = 0;\n+    CORD_set_pos(p, y, i);\n+    while(CORD_pos_valid(p)) {\n+        c = CORD_pos_fetch(p);\n+       \tif(c != i) ABORT(\"Traversal of function node failed\");\n+\tCORD_next(p); i++;\n+    }\n+    if (i != 13) ABORT(\"Bad apparent length for function node\");\n+}\n+\n+void test_extras()\n+{\n+#   if defined(__OS2__)\n+#\tdefine FNAME1 \"tmp1\"\n+#\tdefine FNAME2 \"tmp2\"\n+#   elif defined(AMIGA)\n+#\tdefine FNAME1 \"T:tmp1\"\n+#\tdefine FNAME2 \"T:tmp2\"\n+#   else\n+#\tdefine FNAME1 \"/tmp/cord_test\"\n+#\tdefine FNAME2 \"/tmp/cord_test2\"\n+#   endif\n+    register int i;\n+    CORD y = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n+    CORD x = \"{}\";\n+    CORD w, z;\n+    FILE *f;\n+    FILE *f1a, *f1b, *f2;\n+    \n+    w = CORD_cat(CORD_cat(y,y),y);\n+    z = CORD_catn(3,y,y,y);\n+    if (CORD_cmp(w,z) != 0) ABORT(\"CORD_catn comparison wrong\");\n+    for (i = 1; i < 100; i++) {\n+        x = CORD_cat(x, y);\n+    }\n+    z = CORD_balance(x);\n+    if (CORD_cmp(x,z) != 0) ABORT(\"balanced string comparison wrong\");\n+    if (CORD_cmp(x,CORD_cat(z, CORD_nul(13))) >= 0) ABORT(\"comparison 2\");\n+    if (CORD_cmp(CORD_cat(x, CORD_nul(13)), z) <= 0) ABORT(\"comparison 3\");\n+    if (CORD_cmp(x,CORD_cat(z, \"13\")) >= 0) ABORT(\"comparison 4\");\n+    if ((f = fopen(FNAME1, \"w\")) == 0) ABORT(\"open failed\");\n+    if (CORD_put(z,f) == EOF) ABORT(\"CORD_put failed\");\n+    if (fclose(f) == EOF) ABORT(\"fclose failed\");\n+    w = CORD_from_file(f1a = fopen(FNAME1, \"rb\"));\n+    if (CORD_len(w) != CORD_len(z)) ABORT(\"file length wrong\");\n+    if (CORD_cmp(w,z) != 0) ABORT(\"file comparison wrong\");\n+    if (CORD_cmp(CORD_substr(w, 50*36+2, 36), y) != 0)\n+    \tABORT(\"file substr wrong\");\n+    z = CORD_from_file_lazy(f1b = fopen(FNAME1, \"rb\"));\n+    if (CORD_cmp(w,z) != 0) ABORT(\"File conversions differ\");\n+    if (CORD_chr(w, 0, '9') != 37) ABORT(\"CORD_chr failed 1\");\n+    if (CORD_chr(w, 3, 'a') != 38) ABORT(\"CORD_chr failed 2\");\n+    if (CORD_rchr(w, CORD_len(w) - 1, '}') != 1) ABORT(\"CORD_rchr failed\");\n+    x = y;\n+    for (i = 1; i < 14; i++) {\n+        x = CORD_cat(x,x);\n+    }\n+    if ((f = fopen(FNAME2, \"w\")) == 0) ABORT(\"2nd open failed\");\n+    if (CORD_put(x,f) == EOF) ABORT(\"CORD_put failed\");\n+    if (fclose(f) == EOF) ABORT(\"fclose failed\");\n+    w = CORD_from_file(f2 = fopen(FNAME2, \"rb\"));\n+    if (CORD_len(w) != CORD_len(x)) ABORT(\"file length wrong\");\n+    if (CORD_cmp(w,x) != 0) ABORT(\"file comparison wrong\");\n+    if (CORD_cmp(CORD_substr(w, 1000*36, 36), y) != 0)\n+    \tABORT(\"file substr wrong\");\n+    if (strcmp(CORD_to_char_star(CORD_substr(w, 1000*36, 36)), y) != 0)\n+    \tABORT(\"char * file substr wrong\");\n+    if (strcmp(CORD_substr(w, 1000*36, 2), \"ab\") != 0)\n+    \tABORT(\"short file substr wrong\");\n+    if (CORD_str(x,1,\"9a\") != 35) ABORT(\"CORD_str failed 1\");\n+    if (CORD_str(x,0,\"9abcdefghijk\") != 35) ABORT(\"CORD_str failed 2\");\n+    if (CORD_str(x,0,\"9abcdefghijx\") != CORD_NOT_FOUND)\n+    \tABORT(\"CORD_str failed 3\");\n+    if (CORD_str(x,0,\"9>\") != CORD_NOT_FOUND) ABORT(\"CORD_str failed 4\");\n+    if (remove(FNAME1) != 0) {\n+    \t/* On some systems, e.g. OS2, this may fail if f1 is still open. */\n+    \tif ((fclose(f1a) == EOF) & (fclose(f1b) == EOF))\n+    \t\tABORT(\"fclose(f1) failed\");\n+    \tif (remove(FNAME1) != 0) ABORT(\"remove 1 failed\");\n+    }\n+    if (remove(FNAME2) != 0) {\n+    \tif (fclose(f2) == EOF) ABORT(\"fclose(f2) failed\");\n+    \tif (remove(FNAME2) != 0) ABORT(\"remove 2 failed\");\n+    }\n+}\n+\n+void test_printf()\n+{\n+    CORD result;\n+    char result2[200];\n+    long l;\n+    short s;\n+    CORD x;\n+    \n+    if (CORD_sprintf(&result, \"%7.2f%ln\", 3.14159F, &l) != 7)\n+    \tABORT(\"CORD_sprintf failed 1\");\n+    if (CORD_cmp(result, \"   3.14\") != 0)ABORT(\"CORD_sprintf goofed 1\");\n+    if (l != 7) ABORT(\"CORD_sprintf goofed 2\");\n+    if (CORD_sprintf(&result, \"%-7.2s%hn%c%s\", \"abcd\", &s, 'x', \"yz\") != 10)\n+    \tABORT(\"CORD_sprintf failed 2\");\n+    if (CORD_cmp(result, \"ab     xyz\") != 0)ABORT(\"CORD_sprintf goofed 3\");\n+    if (s != 7) ABORT(\"CORD_sprintf goofed 4\");\n+    x = \"abcdefghij\";\n+    x = CORD_cat(x,x);\n+    x = CORD_cat(x,x);\n+    x = CORD_cat(x,x);\n+    if (CORD_sprintf(&result, \"->%-120.78r!\\n\", x) != 124)\n+    \tABORT(\"CORD_sprintf failed 3\");\n+    (void) sprintf(result2, \"->%-120.78s!\\n\", CORD_to_char_star(x));\n+    if (CORD_cmp(result, result2) != 0)ABORT(\"CORD_sprintf goofed 5\");\n+}\n+\n+main()\n+{\n+#   ifdef THINK_C\n+        printf(\"cordtest:\\n\");\n+#   endif\n+    test_basics();\n+    test_extras();\n+    test_printf();\n+    CORD_fprintf(stderr, \"SUCCEEDED\\n\");\n+    return(0);\n+}"}, {"sha": "b306fbacceaae72466c4fbde23aec87a53f9ae69", "filename": "boehm-gc/cord/cordxtra.c", "status": "added", "additions": 621, "deletions": 0, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordxtra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fcordxtra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordxtra.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,621 @@\n+/*\n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n+ */\n+/*\n+ * These are functions on cords that do not need to understand their\n+ * implementation.  They serve also serve as example client code for\n+ * cord_basics.\n+ */\n+/* Boehm, December 8, 1995 1:53 pm PST */\n+# include <stdio.h>\n+# include <string.h>\n+# include <stdlib.h>\n+# include <stdarg.h>\n+# include \"cord.h\"\n+# include \"ec.h\"\n+# define I_HIDE_POINTERS\t/* So we get access to allocation lock.\t*/\n+\t\t\t\t/* We use this for lazy file reading, \t*/\n+\t\t\t\t/* so that we remain independent \t*/\n+\t\t\t\t/* of the threads primitives.\t\t*/\n+# include \"gc.h\"\n+\n+/* For now we assume that pointer reads and writes are atomic, \t*/\n+/* i.e. another thread always sees the state before or after\t*/\n+/* a write.  This might be false on a Motorola M68K with\t*/\n+/* pointers that are not 32-bit aligned.  But there probably\t*/\n+/* aren't too many threads packages running on those.\t\t*/\n+# define ATOMIC_WRITE(x,y) (x) = (y)\n+# define ATOMIC_READ(x) (*(x))\n+\n+/* The standard says these are in stdio.h, but they aren't always: */\n+# ifndef SEEK_SET\n+#   define SEEK_SET 0\n+# endif\n+# ifndef SEEK_END\n+#   define SEEK_END 2\n+# endif\n+\n+# define BUFSZ 2048\t/* Size of stack allocated buffers when\t\t*/\n+\t\t\t/* we want large buffers.\t\t\t*/\n+\n+typedef void (* oom_fn)(void);\n+\n+# define OUT_OF_MEMORY {  if (CORD_oom_fn != (oom_fn) 0) (*CORD_oom_fn)(); \\\n+\t\t\t  ABORT(\"Out of memory\\n\"); }\n+# define ABORT(msg) { fprintf(stderr, \"%s\\n\", msg); abort(); }\n+\n+CORD CORD_cat_char(CORD x, char c)\n+{\n+    register char * string;\n+    \n+    if (c == '\\0') return(CORD_cat(x, CORD_nul(1)));\n+    string = GC_MALLOC_ATOMIC(2);\n+    if (string == 0) OUT_OF_MEMORY;\n+    string[0] = c;\n+    string[1] = '\\0';\n+    return(CORD_cat_char_star(x, string, 1));\n+}\n+\n+CORD CORD_catn(int nargs, ...)\n+{\n+    register CORD result = CORD_EMPTY;\n+    va_list args;\n+    register int i;\n+\n+    va_start(args, nargs);\n+    for (i = 0; i < nargs; i++) {\n+        register CORD next = va_arg(args, CORD);\n+        result = CORD_cat(result, next);\n+    }\n+    va_end(args);\n+    return(result);\n+}\n+\n+typedef struct {\n+\tsize_t len;\n+\tsize_t count;\n+\tchar * buf;\n+} CORD_fill_data;\n+\n+int CORD_fill_proc(char c, void * client_data)\n+{\n+    register CORD_fill_data * d = (CORD_fill_data *)client_data;\n+    register size_t count = d -> count;\n+    \n+    (d -> buf)[count] = c;\n+    d -> count = ++count;\n+    if (count >= d -> len) {\n+    \treturn(1);\n+    } else {\n+    \treturn(0);\n+    }\n+}\n+\n+int CORD_batched_fill_proc(const char * s, void * client_data)\n+{\n+    register CORD_fill_data * d = (CORD_fill_data *)client_data;\n+    register size_t count = d -> count;\n+    register size_t max = d -> len;\n+    register char * buf = d -> buf;\n+    register const char * t = s;\n+    \n+    while((buf[count] = *t++) != '\\0') {\n+        count++;\n+        if (count >= max) {\n+            d -> count = count;\n+            return(1);\n+        }\n+    }\n+    d -> count = count;\n+    return(0);\n+}\n+\n+/* Fill buf with len characters starting at i.  \t\t\t*/\n+/* Assumes len characters are available.\t\t\t\t*/ \n+void CORD_fill_buf(CORD x, size_t i, size_t len, char * buf)\n+{\n+    CORD_fill_data fd;\n+    \n+    fd.len = len;\n+    fd.buf = buf;\n+    fd.count = 0;\n+    (void)CORD_iter5(x, i, CORD_fill_proc, CORD_batched_fill_proc, &fd);\n+}\n+\n+int CORD_cmp(CORD x, CORD y)\n+{\n+    CORD_pos xpos;\n+    CORD_pos ypos;\n+    register size_t avail, yavail;\n+    \n+    if (y == CORD_EMPTY) return(x != CORD_EMPTY);\n+    if (x == CORD_EMPTY) return(-1);\n+    if (CORD_IS_STRING(y) && CORD_IS_STRING(x)) return(strcmp(x,y));\n+    CORD_set_pos(xpos, x, 0);\n+    CORD_set_pos(ypos, y, 0);\n+    for(;;) {\n+        if (!CORD_pos_valid(xpos)) {\n+            if (CORD_pos_valid(ypos)) {\n+            \treturn(-1);\n+            } else {\n+                return(0);\n+            }\n+        }\n+        if (!CORD_pos_valid(ypos)) {\n+            return(1);\n+        }\n+        if ((avail = CORD_pos_chars_left(xpos)) <= 0\n+            || (yavail = CORD_pos_chars_left(ypos)) <= 0) {\n+            register char xcurrent = CORD_pos_fetch(xpos);\n+            register char ycurrent = CORD_pos_fetch(ypos);\n+            if (xcurrent != ycurrent) return(xcurrent - ycurrent);\n+            CORD_next(xpos);\n+            CORD_next(ypos);\n+        } else {\n+            /* process as many characters as we can\t*/\n+            register int result;\n+            \n+            if (avail > yavail) avail = yavail;\n+            result = strncmp(CORD_pos_cur_char_addr(xpos),\n+            \t\t     CORD_pos_cur_char_addr(ypos), avail);\n+            if (result != 0) return(result);\n+            CORD_pos_advance(xpos, avail);\n+            CORD_pos_advance(ypos, avail);\n+        }\n+    }\n+}\n+\n+int CORD_ncmp(CORD x, size_t x_start, CORD y, size_t y_start, size_t len)\n+{\n+    CORD_pos xpos;\n+    CORD_pos ypos;\n+    register size_t count;\n+    register long avail, yavail;\n+    \n+    CORD_set_pos(xpos, x, x_start);\n+    CORD_set_pos(ypos, y, y_start);\n+    for(count = 0; count < len;) {\n+        if (!CORD_pos_valid(xpos)) {\n+            if (CORD_pos_valid(ypos)) {\n+            \treturn(-1);\n+            } else {\n+                return(0);\n+            }\n+        }\n+        if (!CORD_pos_valid(ypos)) {\n+            return(1);\n+        }\n+        if ((avail = CORD_pos_chars_left(xpos)) <= 0\n+            || (yavail = CORD_pos_chars_left(ypos)) <= 0) {\n+            register char xcurrent = CORD_pos_fetch(xpos);\n+            register char ycurrent = CORD_pos_fetch(ypos);\n+            if (xcurrent != ycurrent) return(xcurrent - ycurrent);\n+            CORD_next(xpos);\n+            CORD_next(ypos);\n+            count++;\n+        } else {\n+            /* process as many characters as we can\t*/\n+            register int result;\n+            \n+            if (avail > yavail) avail = yavail;\n+            count += avail;\n+            if (count > len) avail -= (count - len);\n+            result = strncmp(CORD_pos_cur_char_addr(xpos),\n+            \t\t     CORD_pos_cur_char_addr(ypos), (size_t)avail);\n+            if (result != 0) return(result);\n+            CORD_pos_advance(xpos, (size_t)avail);\n+            CORD_pos_advance(ypos, (size_t)avail);\n+        }\n+    }\n+    return(0);\n+}\n+\n+char * CORD_to_char_star(CORD x)\n+{\n+    register size_t len = CORD_len(x);\n+    char * result = GC_MALLOC_ATOMIC(len + 1);\n+    \n+    if (result == 0) OUT_OF_MEMORY;\n+    CORD_fill_buf(x, 0, len, result);\n+    result[len] = '\\0';\n+    return(result);\n+}\n+\n+CORD CORD_from_char_star(const char *s)\n+{\n+    char * result;\n+    size_t len = strlen(s);\n+\n+    if (0 == len) return(CORD_EMPTY);\n+    result = GC_MALLOC_ATOMIC(len + 1);\n+    if (result == 0) OUT_OF_MEMORY;\n+    memcpy(result, s, len+1);\n+    return(result);\n+}\n+\n+const char * CORD_to_const_char_star(CORD x)\n+{\n+    if (x == 0) return(\"\");\n+    if (CORD_IS_STRING(x)) return((const char *)x);\n+    return(CORD_to_char_star(x));\n+}\n+\n+char CORD_fetch(CORD x, size_t i)\n+{\n+    CORD_pos xpos;\n+    \n+    CORD_set_pos(xpos, x, i);\n+    if (!CORD_pos_valid(xpos)) ABORT(\"bad index?\");\n+    return(CORD_pos_fetch(xpos));\n+}\n+\n+\n+int CORD_put_proc(char c, void * client_data)\n+{\n+    register FILE * f = (FILE *)client_data;\n+    \n+    return(putc(c, f) == EOF);\n+}\n+\n+int CORD_batched_put_proc(const char * s, void * client_data)\n+{\n+    register FILE * f = (FILE *)client_data;\n+    \n+    return(fputs(s, f) == EOF);\n+}\n+    \n+\n+int CORD_put(CORD x, FILE * f)\n+{\n+    if (CORD_iter5(x, 0, CORD_put_proc, CORD_batched_put_proc, f)) {\n+        return(EOF);\n+    } else {\n+    \treturn(1);\n+    }\n+}\n+\n+typedef struct {\n+    size_t pos;\t\t/* Current position in the cord */\n+    char target;\t/* Character we're looking for\t*/\n+} chr_data;\n+\n+int CORD_chr_proc(char c, void * client_data)\n+{\n+    register chr_data * d = (chr_data *)client_data;\n+    \n+    if (c == d -> target) return(1);\n+    (d -> pos) ++;\n+    return(0);\n+}\n+\n+int CORD_rchr_proc(char c, void * client_data)\n+{\n+    register chr_data * d = (chr_data *)client_data;\n+    \n+    if (c == d -> target) return(1);\n+    (d -> pos) --;\n+    return(0);\n+}\n+\n+int CORD_batched_chr_proc(const char *s, void * client_data)\n+{\n+    register chr_data * d = (chr_data *)client_data;\n+    register char * occ = strchr(s, d -> target);\n+    \n+    if (occ == 0) {\n+      \td -> pos += strlen(s);\n+      \treturn(0);\n+    } else {\n+    \td -> pos += occ - s;\n+    \treturn(1);\n+    }\n+}\n+\n+size_t CORD_chr(CORD x, size_t i, int c)\n+{\n+    chr_data d;\n+    \n+    d.pos = i;\n+    d.target = c;\n+    if (CORD_iter5(x, i, CORD_chr_proc, CORD_batched_chr_proc, &d)) {\n+        return(d.pos);\n+    } else {\n+    \treturn(CORD_NOT_FOUND);\n+    }\n+}\n+\n+size_t CORD_rchr(CORD x, size_t i, int c)\n+{\n+    chr_data d;\n+    \n+    d.pos = i;\n+    d.target = c;\n+    if (CORD_riter4(x, i, CORD_rchr_proc, &d)) {\n+        return(d.pos);\n+    } else {\n+    \treturn(CORD_NOT_FOUND);\n+    }\n+}\n+\n+/* Find the first occurrence of s in x at position start or later.\t*/\n+/* This uses an asymptotically poor algorithm, which should typically \t*/\n+/* perform acceptably.  We compare the first few characters directly,\t*/\n+/* and call CORD_ncmp whenever there is a partial match.\t\t*/\n+/* This has the advantage that we allocate very little, or not at all.\t*/\n+/* It's very fast if there are few close misses.\t\t\t*/\n+size_t CORD_str(CORD x, size_t start, CORD s)\n+{\n+    CORD_pos xpos;\n+    size_t xlen = CORD_len(x);\n+    size_t slen;\n+    register size_t start_len;\n+    const char * s_start;\n+    unsigned long s_buf = 0;\t/* The first few characters of s\t*/\n+    unsigned long x_buf = 0;\t/* Start of candidate substring.\t*/\n+    \t\t\t\t/* Initialized only to make compilers\t*/\n+    \t\t\t\t/* happy.\t\t\t\t*/\n+    unsigned long mask = 0;\n+    register size_t i;\n+    register size_t match_pos;\n+    \n+    if (s == CORD_EMPTY) return(start);\n+    if (CORD_IS_STRING(s)) {\n+        s_start = s;\n+        slen = strlen(s);\n+    } else {\n+        s_start = CORD_to_char_star(CORD_substr(s, 0, sizeof(unsigned long)));\n+        slen = CORD_len(s);\n+    }\n+    if (xlen < start || xlen - start < slen) return(CORD_NOT_FOUND);\n+    start_len = slen;\n+    if (start_len > sizeof(unsigned long)) start_len = sizeof(unsigned long);\n+    CORD_set_pos(xpos, x, start);\n+    for (i = 0; i < start_len; i++) {\n+        mask <<= 8;\n+        mask |= 0xff;\n+        s_buf <<= 8;\n+        s_buf |= s_start[i];\n+        x_buf <<= 8;\n+        x_buf |= CORD_pos_fetch(xpos);\n+        CORD_next(xpos);\n+    }\n+    for (match_pos = start; ; match_pos++) {\n+    \tif ((x_buf & mask) == s_buf) {\n+    \t    if (slen == start_len ||\n+    \t     \tCORD_ncmp(x, match_pos + start_len,\n+    \t     \t \t  s, start_len, slen - start_len) == 0) {\n+    \t        return(match_pos);\n+    \t    }\n+    \t}\n+\tif ( match_pos == xlen - slen ) {\n+\t    return(CORD_NOT_FOUND);\n+\t}\n+    \tx_buf <<= 8;\n+        x_buf |= CORD_pos_fetch(xpos);\n+        CORD_next(xpos);\n+    }\n+}\n+\n+void CORD_ec_flush_buf(CORD_ec x)\n+{\n+    register size_t len = x[0].ec_bufptr - x[0].ec_buf;\n+    char * s;\n+\n+    if (len == 0) return;\n+    s = GC_MALLOC_ATOMIC(len+1);\n+    memcpy(s, x[0].ec_buf, len);\n+    s[len] = '\\0';\n+    x[0].ec_cord = CORD_cat_char_star(x[0].ec_cord, s, len);\n+    x[0].ec_bufptr = x[0].ec_buf;\n+}\n+\n+void CORD_ec_append_cord(CORD_ec x, CORD s)\n+{\n+    CORD_ec_flush_buf(x);\n+    x[0].ec_cord = CORD_cat(x[0].ec_cord, s);\n+}\n+\n+/*ARGSUSED*/\n+char CORD_nul_func(size_t i, void * client_data)\n+{\n+    return((char)(unsigned long)client_data);\n+}\n+\n+\n+CORD CORD_chars(char c, size_t i)\n+{\n+    return(CORD_from_fn(CORD_nul_func, (void *)(unsigned long)c, i));\n+}\n+\n+CORD CORD_from_file_eager(FILE * f)\n+{\n+    register int c;\n+    CORD_ec ecord;\n+    \n+    CORD_ec_init(ecord);\n+    for(;;) {\n+        c = getc(f);\n+        if (c == 0) {\n+          /* Append the right number of NULs\t*/\n+          /* Note that any string of NULs is rpresented in 4 words,\t*/\n+          /* independent of its length.\t\t\t\t\t*/\n+            register size_t count = 1;\n+            \n+            CORD_ec_flush_buf(ecord);\n+            while ((c = getc(f)) == 0) count++;\n+            ecord[0].ec_cord = CORD_cat(ecord[0].ec_cord, CORD_nul(count));\n+        }\n+        if (c == EOF) break;\n+        CORD_ec_append(ecord, c);\n+    }\n+    (void) fclose(f);\n+    return(CORD_balance(CORD_ec_to_cord(ecord)));\n+}\n+\n+/* The state maintained for a lazily read file consists primarily\t*/\n+/* of a large direct-mapped cache of previously read values.\t\t*/\n+/* We could rely more on stdio buffering.  That would have 2\t\t*/\n+/* disadvantages:\t\t\t\t\t\t\t*/\n+/*  \t1) Empirically, not all fseek implementations preserve the\t*/\n+/*\t   buffer whenever they could.\t\t\t\t\t*/\n+/*\t2) It would fail if 2 different sections of a long cord\t\t*/\n+/*\t   were being read alternately.\t\t\t\t\t*/\n+/* We do use the stdio buffer for read ahead.\t\t\t\t*/\n+/* To guarantee thread safety in the presence of atomic pointer\t\t*/\n+/* writes, cache lines are always replaced, and never modified in\t*/\n+/* place.\t\t\t\t\t\t\t\t*/\n+\n+# define LOG_CACHE_SZ 14\n+# define CACHE_SZ (1 << LOG_CACHE_SZ)\n+# define LOG_LINE_SZ 9\n+# define LINE_SZ (1 << LOG_LINE_SZ)\n+\n+typedef struct {\n+    size_t tag;\n+    char data[LINE_SZ];\n+    \t/* data[i%LINE_SZ] = ith char in file if tag = i/LINE_SZ\t*/\n+} cache_line;\n+\n+typedef struct {\n+    FILE * lf_file;\n+    size_t lf_current;\t/* Current file pointer value */\n+    cache_line * volatile lf_cache[CACHE_SZ/LINE_SZ];\n+} lf_state;\n+\n+# define MOD_CACHE_SZ(n) ((n) & (CACHE_SZ - 1))\n+# define DIV_CACHE_SZ(n) ((n) >> LOG_CACHE_SZ)\n+# define MOD_LINE_SZ(n) ((n) & (LINE_SZ - 1))\n+# define DIV_LINE_SZ(n) ((n) >> LOG_LINE_SZ)\n+# define LINE_START(n) ((n) & ~(LINE_SZ - 1))\n+\n+typedef struct {\n+    lf_state * state;\n+    size_t file_pos;\t/* Position of needed character. */\n+    cache_line * new_cache;\n+} refill_data;\n+\n+/* Executed with allocation lock. */\n+static char refill_cache(client_data)\n+refill_data * client_data;\n+{\n+    register lf_state * state = client_data -> state;\n+    register size_t file_pos = client_data -> file_pos;\n+    FILE *f = state -> lf_file;\n+    size_t line_start = LINE_START(file_pos);\n+    size_t line_no = DIV_LINE_SZ(MOD_CACHE_SZ(file_pos));\n+    cache_line * new_cache = client_data -> new_cache;\n+    \n+    if (line_start != state -> lf_current\n+        && fseek(f, line_start, SEEK_SET) != 0) {\n+    \t    ABORT(\"fseek failed\");\n+    }\n+    if (fread(new_cache -> data, sizeof(char), LINE_SZ, f)\n+    \t<= file_pos - line_start) {\n+    \tABORT(\"fread failed\");\n+    }\n+    new_cache -> tag = DIV_LINE_SZ(file_pos);\n+    /* Store barrier goes here. */\n+    ATOMIC_WRITE(state -> lf_cache[line_no], new_cache);\n+    state -> lf_current = line_start + LINE_SZ;\n+    return(new_cache->data[MOD_LINE_SZ(file_pos)]);\n+}\n+\n+char CORD_lf_func(size_t i, void * client_data)\n+{\n+    register lf_state * state = (lf_state *)client_data;\n+    register cache_line * volatile * cl_addr =\n+\t\t&(state -> lf_cache[DIV_LINE_SZ(MOD_CACHE_SZ(i))]);\n+    register cache_line * cl = (cache_line *)ATOMIC_READ(cl_addr);\n+    \n+    if (cl == 0 || cl -> tag != DIV_LINE_SZ(i)) {\n+    \t/* Cache miss */\n+    \trefill_data rd;\n+    \t\n+        rd.state = state;\n+        rd.file_pos =  i;\n+        rd.new_cache = GC_NEW_ATOMIC(cache_line);\n+        if (rd.new_cache == 0) OUT_OF_MEMORY;\n+        return((char)(GC_word)\n+        \t  GC_call_with_alloc_lock((GC_fn_type) refill_cache, &rd));\n+    }\n+    return(cl -> data[MOD_LINE_SZ(i)]);\n+}    \n+\n+/*ARGSUSED*/\n+void CORD_lf_close_proc(void * obj, void * client_data)  \n+{\n+    if (fclose(((lf_state *)obj) -> lf_file) != 0) {\n+    \tABORT(\"CORD_lf_close_proc: fclose failed\");\n+    }\n+}\t\t\t\n+\n+CORD CORD_from_file_lazy_inner(FILE * f, size_t len)\n+{\n+    register lf_state * state = GC_NEW(lf_state);\n+    register int i;\n+    \n+    if (state == 0) OUT_OF_MEMORY;\n+    if (len != 0) {\n+\t/* Dummy read to force buffer allocation.  \t*/\n+\t/* This greatly increases the probability\t*/\n+\t/* of avoiding deadlock if buffer allocation\t*/\n+\t/* is redirected to GC_malloc and the\t\t*/\n+\t/* world is multithreaded.\t\t\t*/\n+\tchar buf[1];\n+\n+\t(void) fread(buf, 1, 1, f); \n+\trewind(f);\n+    }\n+    state -> lf_file = f;\n+    for (i = 0; i < CACHE_SZ/LINE_SZ; i++) {\n+        state -> lf_cache[i] = 0;\n+    }\n+    state -> lf_current = 0;\n+    GC_register_finalizer(state, CORD_lf_close_proc, 0, 0, 0);\n+    return(CORD_from_fn(CORD_lf_func, state, len));\n+}\n+\n+CORD CORD_from_file_lazy(FILE * f)\n+{\n+    register long len;\n+    \n+    if (fseek(f, 0l, SEEK_END) != 0) {\n+        ABORT(\"Bad fd argument - fseek failed\");\n+    }\n+    if ((len = ftell(f)) < 0) {\n+        ABORT(\"Bad fd argument - ftell failed\");\n+    }\n+    rewind(f);\n+    return(CORD_from_file_lazy_inner(f, (size_t)len));\n+}\n+\n+# define LAZY_THRESHOLD (128*1024 + 1)\n+\n+CORD CORD_from_file(FILE * f)\n+{\n+    register long len;\n+    \n+    if (fseek(f, 0l, SEEK_END) != 0) {\n+        ABORT(\"Bad fd argument - fseek failed\");\n+    }\n+    if ((len = ftell(f)) < 0) {\n+        ABORT(\"Bad fd argument - ftell failed\");\n+    }\n+    rewind(f);\n+    if (len < LAZY_THRESHOLD) {\n+        return(CORD_from_file_eager(f));\n+    } else {\n+        return(CORD_from_file_lazy_inner(f, (size_t)len));\n+    }\n+}"}, {"sha": "18625d2bb3784596b101489263c78d98233f79a2", "filename": "boehm-gc/cord/de.c", "status": "added", "additions": 604, "deletions": 0, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,604 @@\n+/*\n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n+ */\n+/*\n+ * A really simple-minded text editor based on cords.\n+ * Things it does right:\n+ * \tNo size bounds.\n+ *\tInbounded undo.\n+ *\tShouldn't crash no matter what file you invoke it on (e.g. /vmunix)\n+ *\t\t(Make sure /vmunix is not writable before you try this.)\n+ *\tScrolls horizontally.\n+ * Things it does wrong:\n+ *\tIt doesn't handle tabs reasonably (use \"expand\" first).\n+ *\tThe command set is MUCH too small.\n+ *\tThe redisplay algorithm doesn't let curses do the scrolling.\n+ *\tThe rule for moving the window over the file is suboptimal.\n+ */\n+/* Boehm, February 6, 1995 12:27 pm PST */\n+\n+/* Boehm, May 19, 1994 2:20 pm PDT */\n+#include <stdio.h>\n+#include \"gc.h\"\n+#include \"cord.h\"\n+\n+#ifdef THINK_C\n+#define MACINTOSH\n+#include <ctype.h>\n+#endif\n+\n+#if defined(__BORLANDC__) && !defined(WIN32)\n+    /* If this is DOS or win16, we'll fail anyway.\t*/\n+    /* Might as well assume win32.\t\t\t*/\n+#   define WIN32\n+#endif\n+\n+#if defined(WIN32)\n+#  include <windows.h>\n+#  include \"de_win.h\"\n+#elif defined(MACINTOSH)\n+#\tinclude <console.h>\n+/* curses emulation. */\n+#\tdefine initscr()\n+#\tdefine endwin()\n+#\tdefine nonl()\n+#\tdefine noecho() csetmode(C_NOECHO, stdout)\n+#\tdefine cbreak() csetmode(C_CBREAK, stdout)\n+#\tdefine refresh()\n+#\tdefine addch(c) putchar(c)\n+#\tdefine standout() cinverse(1, stdout)\n+#\tdefine standend() cinverse(0, stdout)\n+#\tdefine move(line,col) cgotoxy(col + 1, line + 1, stdout)\n+#\tdefine clrtoeol() ccleol(stdout)\n+#\tdefine de_error(s) { fprintf(stderr, s); getchar(); }\n+#\tdefine LINES 25\n+#\tdefine COLS 80\n+#else\n+#  include <curses.h>\n+#  define de_error(s) { fprintf(stderr, s); sleep(2); }\n+#endif\n+#include \"de_cmds.h\"\n+\n+/* List of line number to position mappings, in descending order. */\n+/* There may be holes.\t\t\t\t\t\t  */\n+typedef struct LineMapRep {\n+    int line;\n+    size_t pos;\n+    struct LineMapRep * previous;\n+} * line_map;\n+\n+/* List of file versions, one per edit operation */\n+typedef struct HistoryRep {\n+    CORD file_contents;\n+    struct HistoryRep * previous;\n+    line_map map;\t/* Invalid for first record \"now\" */\n+} * history;\n+\n+history now = 0;\n+CORD current;\t\t/* == now -> file_contents.\t*/\n+size_t current_len;\t/* Current file length.\t\t*/\n+line_map current_map = 0;\t/* Current line no. to pos. map\t */\n+size_t current_map_size = 0;\t/* Number of current_map entries.\t*/\n+\t\t\t\t/* Not always accurate, but reset\t*/\n+\t\t\t\t/* by prune_map.\t\t\t*/\n+# define MAX_MAP_SIZE 3000\n+\n+/* Current display position */\n+int dis_line = 0;\n+int dis_col = 0;\n+\n+# define ALL -1\n+# define NONE - 2\n+int need_redisplay = 0;\t/* Line that needs to be redisplayed.\t*/\n+\n+\n+/* Current cursor position. Always within file. */\n+int line = 0; \n+int col = 0;\n+size_t file_pos = 0;\t/* Character position corresponding to cursor.\t*/\n+\n+/* Invalidate line map for lines > i */\n+void invalidate_map(int i)\n+{\n+    while(current_map -> line > i) {\n+        current_map = current_map -> previous;\n+        current_map_size--;\n+    }\n+}\n+\n+/* Reduce the number of map entries to save space for huge files. */\n+/* This also affects maps in histories.\t\t\t\t  */\n+void prune_map()\n+{\n+    line_map map = current_map;\n+    int start_line = map -> line;\n+    \n+    current_map_size = 0;\n+    for(; map != 0; map = map -> previous) {\n+    \tcurrent_map_size++;\n+    \tif (map -> line < start_line - LINES && map -> previous != 0) {\n+    \t    map -> previous = map -> previous -> previous;\n+    \t}\n+    }\n+}\n+/* Add mapping entry */\n+void add_map(int line, size_t pos)\n+{\n+    line_map new_map = GC_NEW(struct LineMapRep);\n+    \n+    if (current_map_size >= MAX_MAP_SIZE) prune_map();\n+    new_map -> line = line;\n+    new_map -> pos = pos;\n+    new_map -> previous = current_map;\n+    current_map = new_map;\n+    current_map_size++;\n+}\n+\n+\n+\n+/* Return position of column *c of ith line in   */\n+/* current file. Adjust *c to be within the line.*/\n+/* A 0 pointer is taken as 0 column.\t\t */\n+/* Returns CORD_NOT_FOUND if i is too big.\t */\n+/* Assumes i > dis_line.\t\t\t */\n+size_t line_pos(int i, int *c)\n+{\n+    int j;\n+    size_t cur;\n+    size_t next;\n+    line_map map = current_map;\n+    \n+    while (map -> line > i) map = map -> previous;\n+    if (map -> line < i - 2) /* rebuild */ invalidate_map(i);\n+    for (j = map -> line, cur = map -> pos; j < i;) {\n+\tcur = CORD_chr(current, cur, '\\n');\n+        if (cur == current_len-1) return(CORD_NOT_FOUND);\n+        cur++;\n+        if (++j > current_map -> line) add_map(j, cur);\n+    }\n+    if (c != 0) {\n+        next = CORD_chr(current, cur, '\\n');\n+        if (next == CORD_NOT_FOUND) next = current_len - 1;\n+        if (next < cur + *c) {\n+            *c = next - cur;\n+        }\n+        cur += *c;\n+    }\n+    return(cur);\n+}\n+\n+void add_hist(CORD s)\n+{\n+    history new_file = GC_NEW(struct HistoryRep);\n+    \n+    new_file -> file_contents = current = s;\n+    current_len = CORD_len(s);\n+    new_file -> previous = now;\n+    if (now != 0) now -> map = current_map;\n+    now = new_file;\n+}\n+\n+void del_hist(void)\n+{\n+    now = now -> previous;\n+    current = now -> file_contents;\n+    current_map = now -> map;\n+    current_len = CORD_len(current);\n+}\n+\n+/* Current screen_contents; a dynamically allocated array of CORDs\t*/\n+CORD * screen = 0;\n+int screen_size = 0;\n+\n+# ifndef WIN32\n+/* Replace a line in the curses stdscr.\tAll control characters are\t*/\n+/* displayed as upper case characters in standout mode.  This isn't\t*/\n+/* terribly appropriate for tabs.\t\t\t\t\t\t\t\t\t*/\n+void replace_line(int i, CORD s)\n+{\n+    register int c;\n+    CORD_pos p;\n+    size_t len = CORD_len(s);\n+    \n+    if (screen == 0 || LINES > screen_size) {\n+        screen_size = LINES;\n+    \tscreen = (CORD *)GC_MALLOC(screen_size * sizeof(CORD));\n+    }\n+#   if !defined(MACINTOSH)\n+        /* A gross workaround for an apparent curses bug: */\n+        if (i == LINES-1 && len == COLS) {\n+            s = CORD_substr(s, 0, CORD_len(s) - 1);\n+        }\n+#   endif\n+    if (CORD_cmp(screen[i], s) != 0) {\n+        move(i, 0); clrtoeol(); move(i,0);\n+\n+        CORD_FOR (p, s) {\n+            c = CORD_pos_fetch(p) & 0x7f;\n+            if (iscntrl(c)) {\n+            \tstandout(); addch(c + 0x40); standend();\n+            } else {\n+    \t        addch(c);\n+    \t    }\n+    \t}\n+    \tscreen[i] = s;\n+    }\n+}\n+#else\n+# define replace_line(i,s) invalidate_line(i)\n+#endif\n+\n+/* Return up to COLS characters of the line of s starting at pos,\t*/\n+/* returning only characters after the given column.\t\t\t*/\n+CORD retrieve_line(CORD s, size_t pos, unsigned column)\n+{\n+    CORD candidate = CORD_substr(s, pos, column + COLS);\n+    \t\t\t/* avoids scanning very long lines\t*/\n+    int eol = CORD_chr(candidate, 0, '\\n');\n+    int len;\n+    \n+    if (eol == CORD_NOT_FOUND) eol = CORD_len(candidate);\n+    len = (int)eol - (int)column;\n+    if (len < 0) len = 0;\n+    return(CORD_substr(s, pos + column, len));\n+}\n+\n+# ifdef WIN32\n+#   define refresh();\n+\n+    CORD retrieve_screen_line(int i)\n+    {\n+    \tregister size_t pos;\n+    \t\n+    \tinvalidate_map(dis_line + LINES);\t/* Prune search */\n+    \tpos = line_pos(dis_line + i, 0);\n+    \tif (pos == CORD_NOT_FOUND) return(CORD_EMPTY);\n+    \treturn(retrieve_line(current, pos, dis_col));\n+    }\n+# endif\n+\n+/* Display the visible section of the current file\t */\n+void redisplay(void)\n+{\n+    register int i;\n+    \n+    invalidate_map(dis_line + LINES);\t/* Prune search */\n+    for (i = 0; i < LINES; i++) {\n+        if (need_redisplay == ALL || need_redisplay == i) {\n+            register size_t pos = line_pos(dis_line + i, 0);\n+            \n+            if (pos == CORD_NOT_FOUND) break;\n+            replace_line(i, retrieve_line(current, pos, dis_col));\n+            if (need_redisplay == i) goto done;\n+        }\n+    }\n+    for (; i < LINES; i++) replace_line(i, CORD_EMPTY);\n+done:\n+    refresh();\n+    need_redisplay = NONE;\n+}\n+\n+int dis_granularity;\n+\n+/* Update dis_line, dis_col, and dis_pos to make cursor visible.\t*/\n+/* Assumes line, col, dis_line, dis_pos are in bounds.\t\t\t*/\n+void normalize_display()\n+{\n+    int old_line = dis_line;\n+    int old_col = dis_col;\n+    \n+    dis_granularity = 1;\n+    if (LINES > 15 && COLS > 15) dis_granularity = 2;\n+    while (dis_line > line) dis_line -= dis_granularity;\n+    while (dis_col > col) dis_col -= dis_granularity;\n+    while (line >= dis_line + LINES) dis_line += dis_granularity;\n+    while (col >= dis_col + COLS) dis_col += dis_granularity;\n+    if (old_line != dis_line || old_col != dis_col) {\n+        need_redisplay = ALL;\n+    }\n+}\n+\n+# if defined(WIN32)\n+# elif defined(MACINTOSH)\n+#\t\tdefine move_cursor(x,y) cgotoxy(x + 1, y + 1, stdout)\n+# else\n+#\t\tdefine move_cursor(x,y) move(y,x)\n+# endif\n+\n+/* Adjust display so that cursor is visible; move cursor into position\t*/\n+/* Update screen if necessary.\t\t\t\t\t\t*/\n+void fix_cursor(void)\n+{\n+    normalize_display();\n+    if (need_redisplay != NONE) redisplay();\n+    move_cursor(col - dis_col, line - dis_line);\n+    refresh();\n+#   ifndef WIN32\n+      fflush(stdout);\n+#   endif\n+}\n+\n+/* Make sure line, col, and dis_pos are somewhere inside file.\t*/\n+/* Recompute file_pos.\tAssumes dis_pos is accurate or past eof\t*/\n+void fix_pos()\n+{\n+    int my_col = col;\n+    \n+    if ((size_t)line > current_len) line = current_len;\n+    file_pos = line_pos(line, &my_col);\n+    if (file_pos == CORD_NOT_FOUND) {\n+        for (line = current_map -> line, file_pos = current_map -> pos;\n+             file_pos < current_len;\n+             line++, file_pos = CORD_chr(current, file_pos, '\\n') + 1);\n+    \tline--;\n+        file_pos = line_pos(line, &col);\n+    } else {\n+    \tcol = my_col;\n+    }\n+}\n+\n+#if defined(WIN32)\n+#  define beep() Beep(1000 /* Hz */, 300 /* msecs */) \n+#elif defined(MACINTOSH)\n+#\tdefine beep() SysBeep(1)\n+#else\n+/*\n+ * beep() is part of some curses packages and not others.\n+ * We try to match the type of the builtin one, if any.\n+ */\n+#ifdef __STDC__\n+    int beep(void)\n+#else\n+    int beep()\n+#endif\n+{\n+    putc('\\007', stderr);\n+    return(0);\n+}\n+#endif\n+\n+#   define NO_PREFIX -1\n+#   define BARE_PREFIX -2\n+int repeat_count = NO_PREFIX;\t/* Current command prefix. */\n+\n+int locate_mode = 0;\t\t\t/* Currently between 2 ^Ls\t*/\n+CORD locate_string = CORD_EMPTY;\t/* Current search string.\t*/\n+\n+char * arg_file_name;\n+\n+#ifdef WIN32\n+/* Change the current position to whatever is currently displayed at\t*/\n+/* the given SCREEN coordinates.\t\t\t\t\t*/\n+void set_position(int c, int l)\n+{\n+    line = l + dis_line;\n+    col = c + dis_col;\n+    fix_pos();\n+    move_cursor(col - dis_col, line - dis_line);\n+}\n+#endif /* WIN32 */\n+\n+/* Perform the command associated with character c.  C may be an\t*/\n+/* integer > 256 denoting a windows command, one of the above control\t*/\n+/* characters, or another ASCII character to be used as either a \t*/\n+/* character to be inserted, a repeat count, or a search string, \t*/\n+/* depending on the current state.\t\t\t\t\t*/\n+void do_command(int c)\n+{\n+    int i;\n+    int need_fix_pos;\n+    FILE * out;\n+    \n+    if ( c == '\\r') c = '\\n';\n+    if (locate_mode) {\n+        size_t new_pos;\n+          \n+        if (c == LOCATE) {\n+              locate_mode = 0;\n+              locate_string = CORD_EMPTY;\n+              return;\n+        }\n+        locate_string = CORD_cat_char(locate_string, (char)c);\n+        new_pos = CORD_str(current, file_pos - CORD_len(locate_string) + 1,\n+          \t\t   locate_string);\n+        if (new_pos != CORD_NOT_FOUND) {\n+            need_redisplay = ALL;\n+            new_pos += CORD_len(locate_string);\n+            for (;;) {\n+              \tfile_pos = line_pos(line + 1, 0);\n+              \tif (file_pos > new_pos) break;\n+              \tline++;\n+            }\n+            col = new_pos - line_pos(line, 0);\n+            file_pos = new_pos;\n+            fix_cursor();\n+        } else {\n+            locate_string = CORD_substr(locate_string, 0,\n+              \t\t\t\tCORD_len(locate_string) - 1);\n+            beep();\n+        }\n+        return;\n+    }\n+    if (c == REPEAT) {\n+      \trepeat_count = BARE_PREFIX; return;\n+    } else if (c < 0x100 && isdigit(c)){\n+        if (repeat_count == BARE_PREFIX) {\n+          repeat_count = c - '0'; return;\n+        } else if (repeat_count != NO_PREFIX) {\n+          repeat_count = 10 * repeat_count + c - '0'; return;\n+        }\n+    }\n+    if (repeat_count == NO_PREFIX) repeat_count = 1;\n+    if (repeat_count == BARE_PREFIX && (c == UP || c == DOWN)) {\n+      \trepeat_count = LINES - dis_granularity;\n+    }\n+    if (repeat_count == BARE_PREFIX) repeat_count = 8;\n+    need_fix_pos = 0;\n+    for (i = 0; i < repeat_count; i++) {\n+        switch(c) {\n+          case LOCATE:\n+            locate_mode = 1;\n+            break;\n+          case TOP:\n+            line = col = file_pos = 0;\n+            break;\n+     \t  case UP:\n+     \t    if (line != 0) {\n+     \t        line--;\n+     \t        need_fix_pos = 1;\n+     \t    }\n+     \t    break;\n+     \t  case DOWN:\n+     \t    line++;\n+     \t    need_fix_pos = 1;\n+     \t    break;\n+     \t  case LEFT:\n+     \t    if (col != 0) {\n+     \t        col--; file_pos--;\n+     \t    }\n+     \t    break;\n+     \t  case RIGHT:\n+     \t    if (CORD_fetch(current, file_pos) == '\\n') break;\n+     \t    col++; file_pos++;\n+     \t    break;\n+     \t  case UNDO:\n+     \t    del_hist();\n+     \t    need_redisplay = ALL; need_fix_pos = 1;\n+     \t    break;\n+     \t  case BS:\n+     \t    if (col == 0) {\n+     \t        beep();\n+     \t        break;\n+     \t    }\n+     \t    col--; file_pos--;\n+     \t    /* fall through: */\n+     \t  case DEL:\n+     \t    if (file_pos == current_len-1) break;\n+     \t    \t/* Can't delete trailing newline */\n+     \t    if (CORD_fetch(current, file_pos) == '\\n') {\n+     \t        need_redisplay = ALL; need_fix_pos = 1;\n+     \t    } else {\n+     \t        need_redisplay = line - dis_line;\n+     \t    }\n+     \t    add_hist(CORD_cat(\n+     \t    \t\tCORD_substr(current, 0, file_pos),\n+     \t    \t\tCORD_substr(current, file_pos+1, current_len)));\n+     \t    invalidate_map(line);\n+     \t    break;\n+     \t  case WRITE:\n+\t    {\n+  \t\tCORD name = CORD_cat(CORD_from_char_star(arg_file_name),\n+\t\t\t\t     \".new\");\n+\n+    \t        if ((out = fopen(CORD_to_const_char_star(name), \"wb\")) == NULL\n+  \t            || CORD_put(current, out) == EOF) {\n+        \t    de_error(\"Write failed\\n\");\n+        \t    need_redisplay = ALL;\n+                } else {\n+                    fclose(out);\n+                }\n+\t    }\n+            break;\n+     \t  default:\n+     \t    {\n+     \t        CORD left_part = CORD_substr(current, 0, file_pos);\n+     \t        CORD right_part = CORD_substr(current, file_pos, current_len);\n+     \t        \n+     \t        add_hist(CORD_cat(CORD_cat_char(left_part, (char)c),\n+     \t        \t\t  right_part));\n+     \t        invalidate_map(line);\n+     \t        if (c == '\\n') {\n+     \t            col = 0; line++; file_pos++;\n+     \t            need_redisplay = ALL;\n+     \t        } else {\n+     \t            col++; file_pos++;\n+     \t            need_redisplay = line - dis_line;\n+     \t    \t}\n+     \t        break;\n+     \t    }\n+        }\n+    }\n+    if (need_fix_pos) fix_pos();\n+    fix_cursor();\n+    repeat_count = NO_PREFIX;\n+}\n+\n+/* OS independent initialization */\n+\n+void generic_init(void)\n+{\n+    FILE * f;\n+    CORD initial;\n+    \n+    if ((f = fopen(arg_file_name, \"rb\")) == NULL) {\n+     \tinitial = \"\\n\";\n+    } else {\n+        initial = CORD_from_file(f);\n+        if (initial == CORD_EMPTY\n+            || CORD_fetch(initial, CORD_len(initial)-1) != '\\n') {\n+            initial = CORD_cat(initial, \"\\n\");\n+        }\n+    }\n+    add_map(0,0);\n+    add_hist(initial);\n+    now -> map = current_map;\n+    now -> previous = now;  /* Can't back up further: beginning of the world */\n+    need_redisplay = ALL;\n+    fix_cursor();\n+}\n+\n+#ifndef WIN32\n+\n+main(argc, argv)\n+int argc;\n+char ** argv;\n+{\n+    int c;\n+    CORD initial;\n+\n+#if defined(MACINTOSH)\n+\tconsole_options.title = \"\\pDumb Editor\";\n+\tcshow(stdout);\n+\tGC_init();\n+\targc = ccommand(&argv);\n+#endif\n+    \n+    if (argc != 2) goto usage;\n+    arg_file_name = argv[1];\n+    setvbuf(stdout, GC_MALLOC_ATOMIC(8192), _IOFBF, 8192);\n+    initscr();\n+    noecho(); nonl(); cbreak();\n+    generic_init();\n+    while ((c = getchar()) != QUIT) {\n+\t\tif (c == EOF) break;\n+\t    do_command(c);\n+    }\n+done:\n+    move(LINES-1, 0);\n+    clrtoeol();\n+    refresh();\n+    nl();\n+    echo();\n+    endwin();\n+    exit(0);\n+usage:\n+    fprintf(stderr, \"Usage: %s file\\n\", argv[0]);\n+    fprintf(stderr, \"Cursor keys: ^B(left) ^F(right) ^P(up) ^N(down)\\n\");\n+    fprintf(stderr, \"Undo: ^U    Write to <file>.new: ^W\");\n+    fprintf(stderr, \"Quit:^D  Repeat count: ^R[n]\\n\");\n+    fprintf(stderr, \"Top: ^T   Locate (search, find): ^L text ^L\\n\");\n+    exit(1);\n+}\n+\n+#endif  /* !WIN32 */"}, {"sha": "f42ddcf2da73a604ec06aed74fe3c85be33fb1ca", "filename": "boehm-gc/cord/de_cmds.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_cmds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_cmds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_cmds.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, May 19, 1994 2:24 pm PDT */\n+\n+#ifndef DE_CMDS_H\n+\n+# define DE_CMDS_H\n+\n+# define UP     16\t/* ^P */\n+# define DOWN   14\t/* ^N */\n+# define LEFT   2\t/* ^B */\n+# define RIGHT  6\t/* ^F */\n+# define DEL\t127\t/* ^? */\n+# define BS     8\t/* ^H */\n+# define UNDO   21\t/* ^U */\n+# define WRITE  23\t/* ^W */\n+# define QUIT   4\t/* ^D */\n+# define REPEAT 18\t/* ^R */\n+# define LOCATE 12\t/* ^L */\n+# define TOP    20\t/* ^T */\n+\n+#endif\n+"}, {"sha": "b20ac3ee16a9c8751e2ee6ce3c757dfb1f687258", "filename": "boehm-gc/cord/de_win.ICO", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.ICO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.ICO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.ICO?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "554a300438911826f4151aebcae89dccf264b2a3", "filename": "boehm-gc/cord/de_win.RC", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.RC", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.RC", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.RC?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to copy this garbage collector for any purpose,\n+ * provided the above notices are retained on all copies.\n+ */\n+/* Boehm, May 13, 1994 9:50 am PDT */\n+\n+#include \"windows.h\"\n+#include \"de_cmds.h\"\n+#include \"de_win.h\"\n+\n+\n+\n+ABOUTBOX DIALOG 19, 21, 163, 47\n+STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU\n+CAPTION \"About Demonstration Text Editor\"\n+BEGIN\n+\tICON \"DE\", -1, 8, 8, 13, 13, WS_CHILD | WS_VISIBLE\n+\tLTEXT \"Demonstration Text Editor\", -1, 44, 8, 118, 8, WS_CHILD | WS_VISIBLE | WS_GROUP\n+\tLTEXT \"Version 4.1\", -1, 44, 16, 60, 8, WS_CHILD | WS_VISIBLE | WS_GROUP\n+\tPUSHBUTTON \"OK\", IDOK, 118, 27, 24, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP\n+END\n+\n+\n+DE MENU \n+BEGIN\n+\tPOPUP \"&File\"\n+\tBEGIN\n+\t\tMENUITEM \"&Save\\t^W\", IDM_FILESAVE\n+\t\tMENUITEM \"E&xit\\t^D\", IDM_FILEEXIT\n+\tEND\n+\n+\tPOPUP \"&Edit\"\n+\tBEGIN\n+\t    MENUITEM \"Page &Down\\t^R^N\", IDM_EDITPDOWN\n+\t    MENUITEM \"Page &Up\\t^R^P\", IDM_EDITPUP\n+\t\tMENUITEM \"U&ndo\\t^U\", IDM_EDITUNDO\n+\t\tMENUITEM \"&Locate\\t^L ... ^L\", IDM_EDITLOCATE\n+\t\tMENUITEM \"D&own\\t^N\", IDM_EDITDOWN\n+\t    MENUITEM \"U&p\\t^P\", IDM_EDITUP\n+\t    MENUITEM \"Le&ft\\t^B\", IDM_EDITLEFT\n+\t    MENUITEM \"&Right\\t^F\", IDM_EDITRIGHT\n+\t    MENUITEM \"Delete &Backward\\tBS\", IDM_EDITBS\n+\t    MENUITEM \"Delete F&orward\\tDEL\", IDM_EDITDEL\n+\t    MENUITEM \"&Top\\t^T\", IDM_EDITTOP\n+\tEND\n+\t\n+\tPOPUP \"&Help\"\n+\tBEGIN\n+\t\tMENUITEM \"&Contents\", IDM_HELPCONTENTS\n+\t\tMENUITEM \"&About...\", IDM_HELPABOUT\n+\tEND\n+\t\n+\tMENUITEM \"Page_&Down\", IDM_EDITPDOWN\n+\tMENUITEM \"Page_&Up\", IDM_EDITPUP\n+END\n+\n+\n+DE ACCELERATORS \n+BEGIN\n+    \"^R\", IDM_EDITREPEAT\n+    \"^N\", IDM_EDITDOWN\n+    \"^P\", IDM_EDITUP\n+    \"^L\", IDM_EDITLOCATE\n+    \"^B\", IDM_EDITLEFT\n+    \"^F\", IDM_EDITRIGHT\n+    \"^T\", IDM_EDITTOP\n+\tVK_DELETE, IDM_EDITDEL, VIRTKEY\n+\tVK_BACK, IDM_EDITBS, VIRTKEY\n+END\n+\n+\n+DE ICON cord\\de_win.ICO\n+"}, {"sha": "119d0fa044c6e607226c4bca7b19ff1cd377a363", "filename": "boehm-gc/cord/de_win.c", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, February 6, 1995 12:29 pm PST */\n+\n+/*\n+ * The MS Windows specific part of de.  \n+ * This started as the generic Windows application template\n+ * made available by Rob Haack (rhaack@polaris.unm.edu), but\n+ * significant parts didn't survive to the final version.\n+ *\n+ * This was written by a nonexpert windows programmer.\n+ */\n+\n+\n+#include \"windows.h\"\n+#include \"gc.h\"\n+#include \"cord.h\"\n+#include \"de_cmds.h\"\n+#include \"de_win.h\"\n+\n+int LINES = 0;\n+int COLS = 0;\n+\n+char       szAppName[]     = \"DE\";\n+char       FullAppName[]   = \"Demonstration Editor\";\n+\n+HWND        hwnd;\n+\n+void de_error(char *s)\n+{\n+    MessageBox( hwnd, (LPSTR) s,\n+                (LPSTR) FullAppName,\n+                MB_ICONINFORMATION | MB_OK );\n+    InvalidateRect(hwnd, NULL, TRUE);\n+}\n+\n+int APIENTRY WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,\n+                      LPSTR command_line, int nCmdShow)\n+{\n+   MSG         msg;\n+   WNDCLASS    wndclass;\n+   HANDLE      hAccel;\n+\n+   if (!hPrevInstance)\n+   {\n+      wndclass.style          = CS_HREDRAW | CS_VREDRAW;\n+      wndclass.lpfnWndProc    = WndProc;\n+      wndclass.cbClsExtra     = 0;\n+      wndclass.cbWndExtra     = DLGWINDOWEXTRA;\n+      wndclass.hInstance      = hInstance;\n+      wndclass.hIcon          = LoadIcon (hInstance, szAppName);\n+      wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW);\n+      wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);\n+      wndclass.lpszMenuName   = \"DE\";\n+      wndclass.lpszClassName  = szAppName;\n+\n+      if (RegisterClass (&wndclass) == 0) {\n+          char buf[50];\n+   \t\n+   \t  sprintf(buf, \"RegisterClass: error code: 0x%X\", GetLastError());\n+   \t  de_error(buf);\n+   \t  return(0);\n+      }\n+   }\n+   \n+   /* Empirically, the command line does not include the command name ...\n+   if (command_line != 0) {\n+       while (isspace(*command_line)) command_line++;\n+       while (*command_line != 0 && !isspace(*command_line)) command_line++;\n+       while (isspace(*command_line)) command_line++;\n+   } */\n+   \n+   if (command_line == 0 || *command_line == 0) {\n+        de_error(\"File name argument required\");\n+        return( 0 );\n+   } else {\n+        char *p = command_line;\n+        \n+        while (*p != 0 && !isspace(*p)) p++;\n+   \targ_file_name = CORD_to_char_star(\n+   \t\t\t    CORD_substr(command_line, 0, p - command_line));\n+   }\n+\n+   hwnd = CreateWindow (szAppName,\n+   \t\t\tFullAppName,\n+   \t\t\tWS_OVERLAPPEDWINDOW | WS_CAPTION, /* Window style */\n+   \t\t\tCW_USEDEFAULT, 0, /* default pos. */\n+   \t\t\tCW_USEDEFAULT, 0, /* default width, height */\n+   \t\t\tNULL,\t/* No parent */\n+   \t\t\tNULL, \t/* Window class menu */\n+   \t\t\thInstance, NULL);\n+   if (hwnd == NULL) {\n+   \tchar buf[50];\n+   \t\n+   \tsprintf(buf, \"CreateWindow: error code: 0x%X\", GetLastError());\n+   \tde_error(buf);\n+   \treturn(0);\n+   }\n+\n+   ShowWindow (hwnd, nCmdShow);\n+\n+   hAccel = LoadAccelerators( hInstance, szAppName );\n+   \n+   while (GetMessage (&msg, NULL, 0, 0))\n+   {\n+      if( !TranslateAccelerator( hwnd, hAccel, &msg ) )\n+      {\n+         TranslateMessage (&msg);\n+         DispatchMessage (&msg);\n+      }\n+   }\n+   return msg.wParam;\n+}\n+\n+/* Return the argument with all control characters replaced by blanks.\t*/\n+char * plain_chars(char * text, size_t len)\n+{\n+    char * result = GC_MALLOC_ATOMIC(len + 1);\n+    register size_t i;\n+    \n+    for (i = 0; i < len; i++) {\n+       if (iscntrl(text[i])) {\n+           result[i] = ' ';\n+       } else {\n+           result[i] = text[i];\n+       }\n+    }\n+    result[len] = '\\0';\n+    return(result);\n+}\n+\n+/* Return the argument with all non-control-characters replaced by \t*/\n+/* blank, and all control characters c replaced by c + 32.\t\t*/\n+char * control_chars(char * text, size_t len)\n+{\n+    char * result = GC_MALLOC_ATOMIC(len + 1);\n+    register size_t i;\n+    \n+    for (i = 0; i < len; i++) {\n+       if (iscntrl(text[i])) {\n+           result[i] = text[i] + 0x40;\n+       } else {\n+           result[i] = ' ';\n+       }\n+    }\n+    result[len] = '\\0';\n+    return(result);\n+}\n+\n+int char_width;\n+int char_height;\n+\n+void get_line_rect(int line, int win_width, RECT * rectp)\n+{\n+    rectp -> top = line * char_height;\n+    rectp -> bottom = rectp->top + char_height;\n+    rectp -> left = 0;\n+    rectp -> right = win_width;\n+}\n+\n+int caret_visible = 0;\t/* Caret is currently visible.\t*/\n+\n+int screen_was_painted = 0;/* Screen has been painted at least once.\t*/\n+\n+void update_cursor(void);\n+\n+LRESULT CALLBACK WndProc (HWND hwnd, UINT message,\n+                          WPARAM wParam, LPARAM lParam)\n+{\n+   static FARPROC lpfnAboutBox;\n+   static HANDLE  hInstance;\n+   HDC dc;\n+   PAINTSTRUCT ps;\n+   RECT client_area;\n+   RECT this_line;\n+   RECT dummy;\n+   TEXTMETRIC tm;\n+   register int i;\n+   int id;\n+\n+   switch (message)\n+   {\n+      case WM_CREATE:\n+           hInstance = ( (LPCREATESTRUCT) lParam)->hInstance;\n+           lpfnAboutBox = MakeProcInstance( (FARPROC) AboutBox, hInstance );\n+           dc = GetDC(hwnd);\n+           SelectObject(dc, GetStockObject(SYSTEM_FIXED_FONT));\n+           GetTextMetrics(dc, &tm);\n+           ReleaseDC(hwnd, dc);\n+           char_width = tm.tmAveCharWidth;\n+           char_height = tm.tmHeight + tm.tmExternalLeading;\n+           GetClientRect(hwnd, &client_area);\n+      \t   COLS = (client_area.right - client_area.left)/char_width;\n+      \t   LINES = (client_area.bottom - client_area.top)/char_height;\n+      \t   generic_init();\n+           return(0);\n+\n+      case WM_CHAR:\n+      \t   if (wParam == QUIT) {\n+      \t       SendMessage( hwnd, WM_CLOSE, 0, 0L );\n+      \t   } else {\n+      \t       do_command(wParam);\n+      \t   }\n+      \t   return(0);\n+      \n+      case WM_SETFOCUS:\n+      \t   CreateCaret(hwnd, NULL, char_width, char_height);\n+      \t   ShowCaret(hwnd);\n+      \t   caret_visible = 1;\n+      \t   update_cursor();\n+      \t   return(0);\n+      \t   \n+      case WM_KILLFOCUS:\n+      \t   HideCaret(hwnd);\n+      \t   DestroyCaret();\n+      \t   caret_visible = 0;\n+      \t   return(0);\n+      \t   \n+      case WM_LBUTTONUP:\n+      \t   {\n+      \t       unsigned xpos = LOWORD(lParam);\t/* From left\t*/\n+      \t       unsigned ypos = HIWORD(lParam);\t/* from top */\n+      \t       \n+      \t       set_position( xpos/char_width, ypos/char_height );\n+      \t       return(0);\n+      \t   }\n+      \t   \n+      case WM_COMMAND:\n+      \t   id = LOWORD(wParam);\n+      \t   if (id & EDIT_CMD_FLAG) {\n+               if (id & REPEAT_FLAG) do_command(REPEAT);\n+               do_command(CHAR_CMD(id));\n+               return( 0 );\n+           } else {\n+             switch(id) {\n+               case IDM_FILEEXIT:\n+                  SendMessage( hwnd, WM_CLOSE, 0, 0L );\n+                  return( 0 );\n+\n+               case IDM_HELPABOUT:\n+                  if( DialogBox( hInstance, \"ABOUTBOX\",\n+                                 hwnd, lpfnAboutBox ) );\n+                     InvalidateRect( hwnd, NULL, TRUE );\n+                  return( 0 );\n+\t       case IDM_HELPCONTENTS:\n+\t     \t  de_error(\n+\t     \t       \"Cursor keys: ^B(left) ^F(right) ^P(up) ^N(down)\\n\"\n+\t     \t       \"Undo: ^U    Write: ^W   Quit:^D  Repeat count: ^R[n]\\n\"\n+\t     \t       \"Top: ^T   Locate (search, find): ^L text ^L\\n\");\n+\t     \t  return( 0 );\n+\t     }\n+\t   }\n+           break;\n+\n+      case WM_CLOSE:\n+           DestroyWindow( hwnd );\n+           return 0;\n+\n+      case WM_DESTROY:\n+           PostQuitMessage (0);\n+           return 0;\n+      \n+      case WM_PAINT:\n+      \t   dc = BeginPaint(hwnd, &ps);\n+      \t   GetClientRect(hwnd, &client_area);\n+      \t   COLS = (client_area.right - client_area.left)/char_width;\n+      \t   LINES = (client_area.bottom - client_area.top)/char_height;\n+      \t   SelectObject(dc, GetStockObject(SYSTEM_FIXED_FONT));\n+      \t   for (i = 0; i < LINES; i++) {\n+      \t       get_line_rect(i, client_area.right, &this_line);\n+      \t       if (IntersectRect(&dummy, &this_line, &ps.rcPaint)) {\n+      \t           CORD raw_line = retrieve_screen_line(i);\n+      \t           size_t len = CORD_len(raw_line);\n+      \t           char * text = CORD_to_char_star(raw_line);\n+      \t           \t\t/* May contain embedded NULLs\t*/\n+      \t           char * plain = plain_chars(text, len);\n+      \t           char * blanks = CORD_to_char_star(CORD_chars(' ',\n+      \t           \t\t\t\t                COLS - len));\n+      \t           char * control = control_chars(text, len);\n+#\t\t   define RED RGB(255,0,0)\n+      \t           \n+      \t           SetBkMode(dc, OPAQUE);\n+      \t           SetTextColor(dc, GetSysColor(COLOR_WINDOWTEXT));\n+      \t           \n+      \t           TextOut(dc, this_line.left, this_line.top,\n+      \t           \t   plain, len);\n+      \t           TextOut(dc, this_line.left + len * char_width, this_line.top,\n+      \t           \t   blanks, COLS - len);\n+      \t           SetBkMode(dc, TRANSPARENT);\n+      \t           SetTextColor(dc, RED);\n+      \t           TextOut(dc, this_line.left, this_line.top,\n+      \t           \t   control, strlen(control));\n+      \t       }\n+      \t   }\n+      \t   EndPaint(hwnd, &ps);\n+      \t   screen_was_painted = 1;\n+      \t   return 0;\n+   }\n+   return DefWindowProc (hwnd, message, wParam, lParam);\n+}\n+\n+int last_col;\n+int last_line;\n+\n+void move_cursor(int c, int l)\n+{\n+    last_col = c;\n+    last_line = l;\n+    \n+    if (caret_visible) update_cursor();\n+}\n+\n+void update_cursor(void)\n+{\n+    SetCaretPos(last_col * char_width, last_line * char_height);\n+    ShowCaret(hwnd);\n+}\n+\n+void invalidate_line(int i)\n+{\n+    RECT line;\n+    \n+    if (!screen_was_painted) return;\n+    \t/* Invalidating a rectangle before painting seems result in a\t*/\n+    \t/* major performance problem.\t\t\t\t\t*/\n+    get_line_rect(i, COLS*char_width, &line);\n+    InvalidateRect(hwnd, &line, FALSE);\n+}\n+\n+LRESULT CALLBACK AboutBox( HWND hDlg, UINT message,\n+                           WPARAM wParam, LPARAM lParam )\n+{\n+   switch( message )\n+   {\n+      case WM_INITDIALOG:\n+           SetFocus( GetDlgItem( hDlg, IDOK ) );\n+           break;\n+\n+      case WM_COMMAND:\n+           switch( wParam )\n+           {\n+              case IDOK:\n+                   EndDialog( hDlg, TRUE );\n+                   break;\n+           }\n+           break;\n+\n+      case WM_CLOSE:\n+           EndDialog( hDlg, TRUE );\n+           return TRUE;\n+\n+   }\n+   return FALSE;\n+}\n+"}, {"sha": "57a47b45c4170d0ef8eadd0c1c07d3027a0a9a1a", "filename": "boehm-gc/cord/de_win.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fde_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde_win.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, May 19, 1994 2:25 pm PDT */\n+\n+/* cord.h, de_cmds.h, and windows.h should be included before this. */\n+\n+\n+# define OTHER_FLAG\t0x100\n+# define EDIT_CMD_FLAG\t0x200\n+# define REPEAT_FLAG\t0x400\n+\n+# define CHAR_CMD(i) ((i) & 0xff)\n+\n+/* MENU: DE */\n+#define IDM_FILESAVE\t\t(EDIT_CMD_FLAG + WRITE)\n+#define IDM_FILEEXIT\t\t(OTHER_FLAG + 1)\n+#define IDM_HELPABOUT\t\t(OTHER_FLAG + 2)\n+#define IDM_HELPCONTENTS\t(OTHER_FLAG + 3)\n+\n+#define IDM_EDITPDOWN\t\t(REPEAT_FLAG + EDIT_CMD_FLAG + DOWN)\n+#define IDM_EDITPUP\t\t(REPEAT_FLAG + EDIT_CMD_FLAG + UP)\n+#define IDM_EDITUNDO\t\t(EDIT_CMD_FLAG + UNDO)\n+#define IDM_EDITLOCATE\t\t(EDIT_CMD_FLAG + LOCATE)\n+#define IDM_EDITDOWN\t\t(EDIT_CMD_FLAG + DOWN)\n+#define IDM_EDITUP\t\t(EDIT_CMD_FLAG + UP)\n+#define IDM_EDITLEFT\t\t(EDIT_CMD_FLAG + LEFT)\n+#define IDM_EDITRIGHT\t\t(EDIT_CMD_FLAG + RIGHT)\n+#define IDM_EDITBS\t\t(EDIT_CMD_FLAG + BS)\n+#define IDM_EDITDEL\t\t(EDIT_CMD_FLAG + DEL)\n+#define IDM_EDITREPEAT\t\t(EDIT_CMD_FLAG + REPEAT)\n+#define IDM_EDITTOP\t\t(EDIT_CMD_FLAG + TOP)\n+\n+\n+\n+\n+/* Windows UI stuff\t*/\n+\n+LRESULT CALLBACK WndProc (HWND hwnd, UINT message,\n+\t\t\t  UINT wParam, LONG lParam);\n+\n+LRESULT CALLBACK AboutBox( HWND hDlg, UINT message,\n+\t\t\t   UINT wParam, LONG lParam );\n+\n+\n+/* Screen dimensions.  Maintained by de_win.c.\t*/\n+extern int LINES;\n+extern int COLS;\n+\n+/* File being edited.\t*/\n+extern char * arg_file_name;\n+\n+/* Current display position in file.  Maintained by de.c\t*/\n+extern int dis_line;\n+extern int dis_col;\n+\n+/* Current cursor position in file.\t\t\t\t*/\n+extern int line;\n+extern int col;\n+\n+/*\n+ *  Calls from de_win.c to de.c\n+ */\n+  \n+CORD retrieve_screen_line(int i);\n+\t\t\t/* Get the contents of i'th screen line.\t*/\n+\t\t\t/* Relies on COLS.\t\t\t\t*/\n+\n+void set_position(int x, int y);\n+\t\t\t/* Set column, row.  Upper left of window = (0,0). */\n+\n+void do_command(int);\n+\t\t\t/* Execute an editor command.\t\t\t*/\n+\t\t\t/* Agument is a command character or one\t*/\n+\t\t\t/* of the IDM_ commands.\t\t\t*/\n+\n+void generic_init(void);\n+\t\t\t/* OS independent initialization */\n+\n+\n+/*\n+ * Calls from de.c to de_win.c\n+ */\n+ \n+void move_cursor(int column, int line);\n+\t\t\t/* Physically move the cursor on the display,\t*/\n+\t\t\t/* so that it appears at\t\t\t*/\n+\t\t\t/* (column, line).\t\t\t\t*/\n+\n+void invalidate_line(int line);\n+\t\t\t/* Invalidate line i on the screen.\t*/\n+\n+void de_error(char *s);\n+\t\t\t/* Display error message.\t*/\n\\ No newline at end of file"}, {"sha": "c829b83ad110579334a525a9c964e53e155b2462", "filename": "boehm-gc/cord/ec.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fec.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,70 @@\n+# ifndef EC_H\n+# define EC_H\n+\n+# ifndef CORD_H\n+#  include \"cord.h\"\n+# endif\n+\n+/* Extensible cords are strings that may be destructively appended to.\t*/\n+/* They allow fast construction of cords from characters that are\t*/\n+/* being read from a stream.\t\t\t\t\t\t*/\n+/*\n+ * A client might look like:\n+ *\n+ *\t{\n+ *\t    CORD_ec x;\n+ *\t    CORD result;\n+ *\t    char c;\n+ *\t    FILE *f;\n+ *\n+ *\t    ...\n+ *\t    CORD_ec_init(x);\n+ *\t    while(...) {\n+ *\t\tc = getc(f);\n+ *\t\t...\n+ *\t\tCORD_ec_append(x, c);\n+ *\t    }\n+ *\t    result = CORD_balance(CORD_ec_to_cord(x));\n+ *\n+ * If a C string is desired as the final result, the call to CORD_balance\n+ * may be replaced by a call to CORD_to_char_star.\n+ */\n+\n+# ifndef CORD_BUFSZ\n+#   define CORD_BUFSZ 128\n+# endif\n+\n+typedef struct CORD_ec_struct {\n+    CORD ec_cord;\n+    char * ec_bufptr;\n+    char ec_buf[CORD_BUFSZ+1];\n+} CORD_ec[1];\n+\n+/* This structure represents the concatenation of ec_cord with\t\t*/\n+/* ec_buf[0 ... (ec_bufptr-ec_buf-1)]\t\t\t\t\t*/\n+\n+/* Flush the buffer part of the extended chord into ec_cord.\t*/\n+/* Note that this is almost the only real function, and it is\t*/\n+/* implemented in 6 lines in cordxtra.c\t\t\t\t*/\n+void CORD_ec_flush_buf(CORD_ec x);\n+      \n+/* Convert an extensible cord to a cord. */\n+# define CORD_ec_to_cord(x) (CORD_ec_flush_buf(x), (x)[0].ec_cord)\n+\n+/* Initialize an extensible cord. */\n+# define CORD_ec_init(x) ((x)[0].ec_cord = 0, (x)[0].ec_bufptr = (x)[0].ec_buf)\n+\n+/* Append a character to an extensible cord.\t*/\n+# define CORD_ec_append(x, c) \\\n+    {  \\\n+\tif ((x)[0].ec_bufptr == (x)[0].ec_buf + CORD_BUFSZ) { \\\n+\t  \tCORD_ec_flush_buf(x); \\\n+\t} \\\n+\t*((x)[0].ec_bufptr)++ = (c); \\\n+    }\n+\n+/* Append a cord to an extensible cord.  Structure remains shared with \t*/\n+/* original.\t\t\t\t\t\t\t\t*/\n+void CORD_ec_append_cord(CORD_ec x, CORD s);\n+\n+# endif /* EC_H */"}, {"sha": "09c8ca8196c865c4ee975329c045ad7ea49956fb", "filename": "boehm-gc/cord/gc.h", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fgc.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,698 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * Note that this defines a large number of tuning hooks, which can\n+ * safely be ignored in nearly all cases.  For normal use it suffices\n+ * to call only GC_MALLOC and perhaps GC_REALLOC.\n+ * For better performance, also look at GC_MALLOC_ATOMIC, and\n+ * GC_enable_incremental.  If you need an action to be performed\n+ * immediately before an object is collected, look at GC_register_finalizer.\n+ * If you are using Solaris threads, look at the end of this file.\n+ * Everything else is best ignored unless you encounter performance\n+ * problems.\n+ */\n+ \n+#ifndef _GC_H\n+\n+# define _GC_H\n+# define __GC\n+# include <stddef.h>\n+\n+#if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n+#include \"libgc_globals.h\"\n+#endif\n+\n+#if defined(_MSC_VER) && defined(_DLL)\n+#ifdef GC_BUILD\n+#define GC_API __declspec(dllexport)\n+#else\n+#define GC_API __declspec(dllimport)\n+#endif\n+#endif\n+\n+#ifndef GC_API\n+#define GC_API extern\n+#endif\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+#   define GC_PROTO(args) args\n+    typedef void * GC_PTR;\n+# else\n+#   define GC_PROTO(args) ()\n+    typedef char * GC_PTR;\n+#  endif\n+\n+# ifdef __cplusplus\n+    extern \"C\" {\n+# endif\n+\n+\n+/* Define word and signed_word to be unsigned and signed types of the \t*/\n+/* size as char * or void *.  There seems to be no way to do this\t*/\n+/* even semi-portably.  The following is probably no better/worse \t*/\n+/* than almost anything else.\t\t\t\t\t\t*/\n+/* The ANSI standard suggests that size_t and ptr_diff_t might be \t*/\n+/* better choices.  But those appear to have incorrect definitions\t*/\n+/* on may systems.  Notably \"typedef int size_t\" seems to be both\t*/\n+/* frequent and WRONG.\t\t\t\t\t\t\t*/\n+typedef unsigned long GC_word;\n+typedef long GC_signed_word;\n+\n+/* Public read-only variables */\n+\n+GC_API GC_word GC_gc_no;/* Counter incremented per collection.  \t*/\n+\t\t\t/* Includes empty GCs at startup.\t\t*/\n+\t\t\t\n+\n+/* Public R/W variables */\n+\n+GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n+\t\t\t/* When there is insufficient memory to satisfy */\n+\t\t\t/* an allocation request, we return\t\t*/\n+\t\t\t/* (*GC_oom_fn)().  By default this just\t*/\n+\t\t\t/* returns 0.\t\t\t\t\t*/\n+\t\t\t/* If it returns, it must return 0 or a valid\t*/\n+\t\t\t/* pointer to a previously allocated heap \t*/\n+\t\t\t/* object.\t\t\t\t\t*/\n+\n+GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n+\t\t\t/* collector has been compiled with statistics\t*/\n+\t\t\t/* enabled.  This involves a performance cost,\t*/\n+\t\t\t/* and is thus not the default.\t\t\t*/\n+\n+GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n+\t\t\t/* because it's not safe.\t\t\t  */\n+\n+GC_API int GC_dont_expand;\n+\t\t\t/* Dont expand heap unless explicitly requested */\n+\t\t\t/* or forced to.\t\t\t\t*/\n+\n+GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n+\t\t\t    /* full collections.  Matters only if\t*/\n+\t\t\t    /* GC_incremental is set.\t\t\t*/\n+\t\t\t\n+GC_API GC_word GC_non_gc_bytes;\n+\t\t\t/* Bytes not considered candidates for collection. */\n+\t\t\t/* Used only to control scheduling of collections. */\n+\n+GC_API GC_word GC_free_space_divisor;\n+\t\t\t/* We try to make sure that we allocate at \t*/\n+\t\t\t/* least N/GC_free_space_divisor bytes between\t*/\n+\t\t\t/* collections, where N is the heap size plus\t*/\n+\t\t\t/* a rough estimate of the root set size.\t*/\n+\t\t\t/* Initially, GC_free_space_divisor = 4.\t*/\n+\t\t\t/* Increasing its value will use less space\t*/\n+\t\t\t/* but more collection time.  Decreasing it\t*/\n+\t\t\t/* will appreciably decrease collection time\t*/\n+\t\t\t/* at the expense of space.\t\t\t*/\n+\t\t\t/* GC_free_space_divisor = 1 will effectively\t*/\n+\t\t\t/* disable collections.\t\t\t\t*/\n+\n+GC_API GC_word GC_max_retries;\n+\t\t\t/* The maximum number of GCs attempted before\t*/\n+\t\t\t/* reporting out of memory after heap\t\t*/\n+\t\t\t/* expansion fails.  Initially 0.\t\t*/\n+\t\t\t\n+\t\t\t\n+/* Public procedures */\n+/*\n+ * general purpose allocation routines, with roughly malloc calling conv.\n+ * The atomic versions promise that no relevant pointers are contained\n+ * in the object.  The nonatomic versions guarantee that the new object\n+ * is cleared.  GC_malloc_stubborn promises that no changes to the object\n+ * will occur after GC_end_stubborn_change has been called on the\n+ * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object\n+ * that is scanned for pointers to collectable objects, but is not itself\n+ * collectable.  GC_malloc_uncollectable and GC_free called on the resulting\n+ * object implicitly update GC_non_gc_bytes appropriately.\n+ */\n+GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_uncollectable GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_stubborn GC_PROTO((size_t size_in_bytes));\n+\n+/* The following is only defined if the library has been suitably\t*/\n+/* compiled:\t\t\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_malloc_atomic_uncollectable GC_PROTO((size_t size_in_bytes));\n+\n+/* Explicitly deallocate an object.  Dangerous if used incorrectly.     */\n+/* Requires a pointer to the base of an object.\t\t\t\t*/\n+/* If the argument is stubborn, it should not be changeable when freed. */\n+/* An object should not be enable for finalization when it is \t\t*/\n+/* explicitly deallocated.\t\t\t\t\t\t*/\n+/* GC_free(0) is a no-op, as required by ANSI C for free.\t\t*/\n+GC_API void GC_free GC_PROTO((GC_PTR object_addr));\n+\n+/*\n+ * Stubborn objects may be changed only if the collector is explicitly informed.\n+ * The collector is implicitly informed of coming change when such\n+ * an object is first allocated.  The following routines inform the\n+ * collector that an object will no longer be changed, or that it will\n+ * once again be changed.  Only nonNIL pointer stores into the object\n+ * are considered to be changes.  The argument to GC_end_stubborn_change\n+ * must be exacly the value returned by GC_malloc_stubborn or passed to\n+ * GC_change_stubborn.  (In the second case it may be an interior pointer\n+ * within 512 bytes of the beginning of the objects.)\n+ * There is a performance penalty for allowing more than\n+ * one stubborn object to be changed at once, but it is acceptable to\n+ * do so.  The same applies to dropping stubborn objects that are still\n+ * changeable.\n+ */\n+GC_API void GC_change_stubborn GC_PROTO((GC_PTR));\n+GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n+\n+/* Return a pointer to the base (lowest address) of an object given\t*/\n+/* a pointer to a location within the object.\t\t\t\t*/\n+/* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n+/* object.\t\t\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n+\n+/* Given a pointer to the base of an object, return its size in bytes.\t*/\n+/* The returned size may be slightly larger than what was originally\t*/\n+/* requested.\t\t\t\t\t\t\t\t*/\n+GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n+\n+/* For compatibility with C library.  This is occasionally faster than\t*/\n+/* a malloc followed by a bcopy.  But if you rely on that, either here\t*/\n+/* or with the standard C library, your code is broken.  In my\t\t*/\n+/* opinion, it shouldn't have been invented, but now we're stuck. -HB\t*/\n+/* The resulting object has the same kind as the original.\t\t*/\n+/* If the argument is stubborn, the result will have changes enabled.\t*/\n+/* It is an error to have changes enabled for the original object.\t*/\n+/* Follows ANSI comventions for NULL old_object.\t\t\t*/\n+GC_API GC_PTR GC_realloc GC_PROTO((GC_PTR old_object,\n+\t\t\t\t   size_t new_size_in_bytes));\n+\t\t\t\t   \n+/* Explicitly increase the heap size.\t*/\n+/* Returns 0 on failure, 1 on success.  */\n+GC_API int GC_expand_hp GC_PROTO((size_t number_of_bytes));\n+\n+/* Limit the heap size to n bytes.  Useful when you're debugging, \t*/\n+/* especially on systems that don't handle running out of memory well.\t*/\n+/* n == 0 ==> unbounded.  This is the default.\t\t\t\t*/\n+GC_API void GC_set_max_heap_size GC_PROTO((GC_word n));\n+\n+/* Inform the collector that a certain section of statically allocated\t*/\n+/* memory contains no pointers to garbage collected memory.  Thus it \t*/\n+/* need not be scanned.  This is sometimes important if the application */\n+/* maps large read/write files into the address space, which could be\t*/\n+/* mistaken for dynamic library data segments on some systems.\t\t*/\n+GC_API void GC_exclude_static_roots GC_PROTO((GC_PTR start, GC_PTR finish));\n+\n+/* Clear the set of root segments.  Wizards only. */\n+GC_API void GC_clear_roots GC_PROTO((void));\n+\n+/* Add a root segment.  Wizards only. */\n+GC_API void GC_add_roots GC_PROTO((char * low_address,\n+\t\t\t\t   char * high_address_plus_1));\n+\n+/* Add a displacement to the set of those considered valid by the\t*/\n+/* collector.  GC_register_displacement(n) means that if p was returned */\n+/* by GC_malloc, then (char *)p + n will be considered to be a valid\t*/\n+/* pointer to n.  N must be small and less than the size of p.\t\t*/\n+/* (All pointers to the interior of objects from the stack are\t\t*/\n+/* considered valid in any case.  This applies to heap objects and\t*/\n+/* static data.)\t\t\t\t\t\t\t*/\n+/* Preferably, this should be called before any other GC procedures.\t*/\n+/* Calling it later adds to the probability of excess memory\t\t*/\n+/* retention.\t\t\t\t\t\t\t\t*/\n+/* This is a no-op if the collector was compiled with recognition of\t*/\n+/* arbitrary interior pointers enabled, which is now the default.\t*/\n+GC_API void GC_register_displacement GC_PROTO((GC_word n));\n+\n+/* The following version should be used if any debugging allocation is\t*/\n+/* being done.\t\t\t\t\t\t\t\t*/\n+GC_API void GC_debug_register_displacement GC_PROTO((GC_word n));\n+\n+/* Explicitly trigger a full, world-stop collection. \t*/\n+GC_API void GC_gcollect GC_PROTO((void));\n+\n+/* Trigger a full world-stopped collection.  Abort the collection if \t*/\n+/* and when stop_func returns a nonzero value.  Stop_func will be \t*/\n+/* called frequently, and should be reasonably fast.  This works even\t*/\n+/* if virtual dirty bits, and hence incremental collection is not \t*/\n+/* available for this architecture.  Collections can be aborted faster\t*/\n+/* than normal pause times for incremental collection.  However,\t*/\n+/* aborted collections do no useful work; the next collection needs\t*/\n+/* to start from the beginning.\t\t\t\t\t\t*/\n+typedef int (* GC_stop_func) GC_PROTO((void));\n+GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n+\n+/* Return the number of bytes in the heap.  Excludes collector private\t*/\n+/* data structures.  Includes empty blocks and fragmentation loss.\t*/\n+/* Includes some pages that were allocated but never written.\t\t*/\n+GC_API size_t GC_get_heap_size GC_PROTO((void));\n+\n+/* Return the number of bytes allocated since the last collection.\t*/\n+GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n+\n+/* Enable incremental/generational collection.\t*/\n+/* Not advisable unless dirty bits are \t\t*/\n+/* available or most heap objects are\t\t*/\n+/* pointerfree(atomic) or immutable.\t\t*/\n+/* Don't use in leak finding mode.\t\t*/\n+/* Ignored if GC_dont_gc is true.\t\t*/\n+GC_API void GC_enable_incremental GC_PROTO((void));\n+\n+/* Perform some garbage collection work, if appropriate.\t*/\n+/* Return 0 if there is no more work to be done.\t\t*/\n+/* Typically performs an amount of work corresponding roughly\t*/\n+/* to marking from one page.  May do more work if further\t*/\n+/* progress requires it, e.g. if incremental collection is\t*/\n+/* disabled.  It is reasonable to call this in a wait loop\t*/\n+/* until it returns 0.\t\t\t\t\t\t*/\n+GC_API int GC_collect_a_little GC_PROTO((void));\n+\n+/* Allocate an object of size lb bytes.  The client guarantees that\t*/\n+/* as long as the object is live, it will be referenced by a pointer\t*/\n+/* that points to somewhere within the first 256 bytes of the object.\t*/\n+/* (This should normally be declared volatile to prevent the compiler\t*/\n+/* from invalidating this assertion.)  This routine is only useful\t*/\n+/* if a large array is being allocated.  It reduces the chance of \t*/\n+/* accidentally retaining such an array as a result of scanning an\t*/\n+/* integer that happens to be an address inside the array.  (Actually,\t*/\n+/* it reduces the chance of the allocator not finding space for such\t*/\n+/* an array, since it will try hard to avoid introducing such a false\t*/\n+/* reference.)  On a SunOS 4.X or MS Windows system this is recommended */\n+/* for arrays likely to be larger than 100K or so.  For other systems,\t*/\n+/* or if the collector is not configured to recognize all interior\t*/\n+/* pointers, the threshold is normally much higher.\t\t\t*/\n+GC_API GC_PTR GC_malloc_ignore_off_page GC_PROTO((size_t lb));\n+GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n+\n+#if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720\n+#   define GC_ADD_CALLER\n+#   define GC_RETURN_ADDR (GC_word)__return_address\n+#endif\n+\n+#ifdef GC_ADD_CALLER\n+#  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n+#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int\n+#else\n+#  define GC_EXTRAS __FILE__, __LINE__\n+#  define GC_EXTRA_PARAMS char * descr_string, int descr_int\n+#endif\n+\n+/* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n+/* objects allocated in this way for overwrites, etc.\t\t\t*/\n+GC_API GC_PTR GC_debug_malloc\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_atomic\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_uncollectable\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_stubborn\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));\n+GC_API GC_PTR GC_debug_realloc\n+\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,\n+  \t\t  GC_EXTRA_PARAMS));\n+  \t\t\t \t \n+GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));\n+GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n+# ifdef GC_DEBUG\n+#   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)\n+#   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \\\n+\t\t\t\t\t\t\tGC_EXTRAS)\n+#   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)\n+#   define GC_FREE(p) GC_debug_free(p)\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n+#   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n+#   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n+#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n+\tGC_general_register_disappearing_link(link, GC_base(obj))\n+#   define GC_REGISTER_DISPLACEMENT(n) GC_debug_register_displacement(n)\n+# else\n+#   define GC_MALLOC(sz) GC_malloc(sz)\n+#   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)\n+#   define GC_REALLOC(old, sz) GC_realloc(old, sz)\n+#   define GC_FREE(p) GC_free(p)\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_register_finalizer(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n+\tGC_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n+#   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n+#   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n+#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n+\tGC_general_register_disappearing_link(link, obj)\n+#   define GC_REGISTER_DISPLACEMENT(n) GC_register_displacement(n)\n+# endif\n+/* The following are included because they are often convenient, and\t*/\n+/* reduce the chance for a misspecifed size argument.  But calls may\t*/\n+/* expand to something syntactically incorrect if t is a complicated\t*/\n+/* type expression.  \t\t\t\t\t\t\t*/\n+# define GC_NEW(t) (t *)GC_MALLOC(sizeof (t))\n+# define GC_NEW_ATOMIC(t) (t *)GC_MALLOC_ATOMIC(sizeof (t))\n+# define GC_NEW_STUBBORN(t) (t *)GC_MALLOC_STUBBORN(sizeof (t))\n+# define GC_NEW_UNCOLLECTABLE(t) (t *)GC_MALLOC_UNCOLLECTABLE(sizeof (t))\n+\n+/* Finalization.  Some of these primitives are grossly unsafe.\t\t*/\n+/* The idea is to make them both cheap, and sufficient to build\t\t*/\n+/* a safer layer, closer to PCedar finalization.\t\t\t*/\n+/* The interface represents my conclusions from a long discussion\t*/\n+/* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, \t\t*/\n+/* Christian Jacobi, and Russ Atkinson.  It's not perfect, and\t\t*/\n+/* probably nobody else agrees with it.\t    Hans-J. Boehm  3/13/92\t*/\n+typedef void (*GC_finalization_proc)\n+  \tGC_PROTO((GC_PTR obj, GC_PTR client_data));\n+\n+GC_API void GC_register_finalizer\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\t/* When obj is no longer accessible, invoke\t\t*/\n+\t/* (*fn)(obj, cd).  If a and b are inaccessible, and\t*/\n+\t/* a points to b (after disappearing links have been\t*/\n+\t/* made to disappear), then only a will be\t\t*/\n+\t/* finalized.  (If this does not create any new\t\t*/\n+\t/* pointers to b, then b will be finalized after the\t*/\n+\t/* next collection.)  Any finalizable object that\t*/\n+\t/* is reachable from itself by following one or more\t*/\n+\t/* pointers will not be finalized (or collected).\t*/\n+\t/* Thus cycles involving finalizable objects should\t*/\n+\t/* be avoided, or broken by disappearing links.\t\t*/\n+\t/* All but the last finalizer registered for an object  */\n+\t/* is ignored.\t\t\t\t\t\t*/\n+\t/* Finalization may be removed by passing 0 as fn.\t*/\n+\t/* Finalizers are implicitly unregistered just before   */\n+\t/* they are invoked.\t\t\t\t\t*/\n+\t/* The old finalizer and client data are stored in\t*/\n+\t/* *ofn and *ocd.\t\t\t\t\t*/ \n+\t/* Fn is never invoked on an accessible object,\t\t*/\n+\t/* provided hidden pointers are converted to real \t*/\n+\t/* pointers only if the allocation lock is held, and\t*/\n+\t/* such conversions are not performed by finalization\t*/\n+\t/* routines.\t\t\t\t\t\t*/\n+\t/* If GC_register_finalizer is aborted as a result of\t*/\n+\t/* a signal, the object may be left with no\t\t*/\n+\t/* finalization, even if neither the old nor new\t*/\n+\t/* finalizer were NULL.\t\t\t\t\t*/\n+\t/* Obj should be the nonNULL starting address of an \t*/\n+\t/* object allocated by GC_malloc or friends.\t\t*/\n+\t/* Note that any garbage collectable object referenced\t*/\n+\t/* by cd will be considered accessible until the\t*/\n+\t/* finalizer is invoked.\t\t\t\t*/\n+\n+/* Another versions of the above follow.  It ignores\t\t*/\n+/* self-cycles, i.e. pointers from a finalizable object to\t*/\n+/* itself.  There is a stylistic argument that this is wrong,\t*/\n+/* but it's unavoidable for C++, since the compiler may\t\t*/\n+/* silently introduce these.  It's also benign in that specific\t*/\n+/* case.\t\t\t\t\t\t\t*/\n+GC_API void GC_register_finalizer_ignore_self\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer_ignore_self\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\n+/* The following routine may be used to break cycles between\t*/\n+/* finalizable objects, thus causing cyclic finalizable\t\t*/\n+/* objects to be finalized in the correct order.  Standard\t*/\n+/* use involves calling GC_register_disappearing_link(&p),\t*/\n+/* where p is a pointer that is not followed by finalization\t*/\n+/* code, and should not be considered in determining \t\t*/\n+/* finalization order.\t\t\t\t\t\t*/\n+GC_API int GC_register_disappearing_link GC_PROTO((GC_PTR * /* link */));\n+\t/* Link should point to a field of a heap allocated \t*/\n+\t/* object obj.  *link will be cleared when obj is\t*/\n+\t/* found to be inaccessible.  This happens BEFORE any\t*/\n+\t/* finalization code is invoked, and BEFORE any\t\t*/\n+\t/* decisions about finalization order are made.\t\t*/\n+\t/* This is useful in telling the finalizer that \t*/\n+\t/* some pointers are not essential for proper\t\t*/\n+\t/* finalization.  This may avoid finalization cycles.\t*/\n+\t/* Note that obj may be resurrected by another\t\t*/\n+\t/* finalizer, and thus the clearing of *link may\t*/\n+\t/* be visible to non-finalization code.  \t\t*/\n+\t/* There's an argument that an arbitrary action should  */\n+\t/* be allowed here, instead of just clearing a pointer. */\n+\t/* But this causes problems if that action alters, or \t*/\n+\t/* examines connectivity.\t\t\t\t*/\n+\t/* Returns 1 if link was already registered, 0\t\t*/\n+\t/* otherwise.\t\t\t\t\t\t*/\n+\t/* Only exists for backward compatibility.  See below:\t*/\n+\t\n+GC_API int GC_general_register_disappearing_link\n+\tGC_PROTO((GC_PTR * /* link */, GC_PTR obj));\n+\t/* A slight generalization of the above. *link is\t*/\n+\t/* cleared when obj first becomes inaccessible.  This\t*/\n+\t/* can be used to implement weak pointers easily and\t*/\n+\t/* safely. Typically link will point to a location\t*/\n+\t/* holding a disguised pointer to obj.  (A pointer \t*/\n+\t/* inside an \"atomic\" object is effectively  \t\t*/\n+\t/* disguised.)   In this way soft\t\t\t*/\n+\t/* pointers are broken before any object\t\t*/\n+\t/* reachable from them are finalized.  Each link\t*/\n+\t/* May be registered only once, i.e. with one obj\t*/\n+\t/* value.  This was added after a long email discussion */\n+\t/* with John Ellis.\t\t\t\t\t*/\n+\t/* Obj must be a pointer to the first word of an object */\n+\t/* we allocated.  It is unsafe to explicitly deallocate */\n+\t/* the object containing link.  Explicitly deallocating */\n+\t/* obj may or may not cause link to eventually be\t*/\n+\t/* cleared.\t\t\t\t\t\t*/\n+GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n+\t/* Returns 0 if link was not actually registered.\t*/\n+\t/* Undoes a registration by either of the above two\t*/\n+\t/* routines.\t\t\t\t\t\t*/\n+\n+/* Auxiliary fns to make finalization work correctly with displaced\t*/\n+/* pointers introduced by the debugging allocators.\t\t\t*/\n+GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n+GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n+\n+GC_API int GC_invoke_finalizers GC_PROTO((void));\n+\t/* Run finalizers for all objects that are ready to\t*/\n+\t/* be finalized.  Return the number of finalizers\t*/\n+\t/* that were run.  Normally this is also called\t\t*/\n+\t/* implicitly during some allocations.\tIf\t\t*/\n+\t/* FINALIZE_ON_DEMAND is defined, it must be called\t*/\n+\t/* explicitly.\t\t\t\t\t\t*/\n+\n+/* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n+/* p may not be a NULL pointer.\t\t\t\t\t\t*/\n+typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));\n+GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n+    /* Returns old warning procedure.\t*/\n+\t\n+/* The following is intended to be used by a higher level\t*/\n+/* (e.g. cedar-like) finalization facility.  It is expected\t*/\n+/* that finalization code will arrange for hidden pointers to\t*/\n+/* disappear.  Otherwise objects can be accessed after they\t*/\n+/* have been collected.\t\t\t\t\t\t*/\n+/* Note that putting pointers in atomic objects or in \t\t*/\n+/* nonpointer slots of \"typed\" objects is equivalent to \t*/\n+/* disguising them in this way, and may have other advantages.\t*/\n+# if defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)\n+    typedef GC_word GC_hidden_pointer;\n+#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))\n+#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))\n+    /* Converting a hidden pointer to a real pointer requires verifying\t*/\n+    /* that the object still exists.  This involves acquiring the  \t*/\n+    /* allocator lock to avoid a race with the collector.\t\t*/\n+# endif /* I_HIDE_POINTERS */\n+\n+typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));\n+GC_API GC_PTR GC_call_with_alloc_lock\n+        \tGC_PROTO((GC_fn_type fn, GC_PTR client_data));\n+\n+/* Check that p and q point to the same object.  \t\t*/\n+/* Fail conspicuously if they don't.\t\t\t\t*/\n+/* Returns the first argument.  \t\t\t\t*/\n+/* Succeeds if neither p nor q points to the heap.\t\t*/\n+/* May succeed if both p and q point to between heap objects.\t*/\n+GC_API GC_PTR GC_same_obj GC_PROTO((GC_PTR p, GC_PTR q));\n+\n+/* Checked pointer pre- and post- increment operations.  Note that\t*/\n+/* the second argument is in units of bytes, not multiples of the\t*/\n+/* object size.  This should either be invoked from a macro, or the\t*/\n+/* call should be automatically generated.\t\t\t\t*/\n+GC_API GC_PTR GC_pre_incr GC_PROTO((GC_PTR *p, size_t how_much));\n+GC_API GC_PTR GC_post_incr GC_PROTO((GC_PTR *p, size_t how_much));\n+\n+/* Check that p is visible\t\t\t\t\t\t*/\n+/* to the collector as a possibly pointer containing location.\t\t*/\n+/* If it isn't fail conspicuously.\t\t\t\t\t*/\n+/* Returns the argument in all cases.  May erroneously succeed\t\t*/\n+/* in hard cases.  (This is intended for debugging use with\t\t*/\n+/* untyped allocations.  The idea is that it should be possible, though\t*/\n+/* slow, to add such a call to all indirect pointer stores.)\t\t*/\n+/* Currently useless for multithreaded worlds.\t\t\t\t*/\n+GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));\n+\n+/* Check that if p is a pointer to a heap page, then it points to\t*/\n+/* a valid displacement within a heap object.\t\t\t\t*/\n+/* Fail conspicuously if this property does not hold.\t\t\t*/\n+/* Uninteresting with ALL_INTERIOR_POINTERS.\t\t\t\t*/\n+/* Always returns its argument.\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n+\n+/* Safer, but slow, pointer addition.  Probably useful mainly with \t*/\n+/* a preprocessor.  Useful only for heap pointers.\t\t\t*/\n+#ifdef GC_DEBUG\n+#   define GC_PTR_ADD3(x, n, type_of_result) \\\n+\t((type_of_result)GC_same_obj((x)+(n), (x)))\n+#   define GC_PRE_INCR3(x, n, type_of_result) \\\n+\t((type_of_result)GC_pre_incr(&(x), (n)*sizeof(*x))\n+#   define GC_POST_INCR2(x, type_of_result) \\\n+\t((type_of_result)GC_post_incr(&(x), sizeof(*x))\n+#   ifdef __GNUC__\n+#       define GC_PTR_ADD(x, n) \\\n+\t    GC_PTR_ADD3(x, n, typeof(x))\n+#   define GC_PRE_INCR(x, n) \\\n+\t    GC_PRE_INCR3(x, n, typeof(x))\n+#   define GC_POST_INCR(x, n) \\\n+\t    GC_POST_INCR3(x, typeof(x))\n+#   else\n+\t/* We can't do this right without typeof, which ANSI\t*/\n+\t/* decided was not sufficiently useful.  Repeatedly\t*/\n+\t/* mentioning the arguments seems too dangerous to be\t*/\n+\t/* useful.  So does not casting the result.\t\t*/\n+#   \tdefine GC_PTR_ADD(x, n) ((x)+(n))\n+#   endif\n+#else\t/* !GC_DEBUG */\n+#   define GC_PTR_ADD3(x, n, type_of_result) ((x)+(n))\n+#   define GC_PTR_ADD(x, n) ((x)+(n))\n+#   define GC_PRE_INCR3(x, n, type_of_result) ((x) += (n))\n+#   define GC_PRE_INCR(x, n) ((x) += (n))\n+#   define GC_POST_INCR2(x, n, type_of_result) ((x)++)\n+#   define GC_POST_INCR(x, n) ((x)++)\n+#endif\n+\n+/* Safer assignment of a pointer to a nonstack location.\t*/\n+#ifdef GC_DEBUG\n+# ifdef __STDC__\n+#   define GC_PTR_STORE(p, q) \\\n+\t(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))\n+# else\n+#   define GC_PTR_STORE(p, q) \\\n+\t(*(char **)GC_is_visible(p) = GC_is_valid_displacement(q))\n+# endif\n+#else /* !GC_DEBUG */\n+#   define GC_PTR_STORE(p, q) *((p) = (q))\n+#endif\n+\n+/* Fynctions called to report pointer checking errors */\n+GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));\n+\n+GC_API void (*GC_is_valid_displacement_print_proc)\n+\tGC_PROTO((GC_PTR p));\n+\n+GC_API void (*GC_is_visible_print_proc)\n+\tGC_PROTO((GC_PTR p));\n+\n+#ifdef SOLARIS_THREADS\n+/* We need to intercept calls to many of the threads primitives, so \t*/\n+/* that we can locate thread stacks and stop the world.\t\t\t*/\n+/* Note also that the collector cannot see thread specific data.\t*/\n+/* Thread specific data should generally consist of pointers to\t\t*/\n+/* uncollectable objects, which are deallocated using the destructor\t*/\n+/* facility in thr_keycreate.\t\t\t\t\t\t*/\n+# include <thread.h>\n+# include <signal.h>\n+  int GC_thr_create(void *stack_base, size_t stack_size,\n+                    void *(*start_routine)(void *), void *arg, long flags,\n+                    thread_t *new_thread);\n+  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n+  int GC_thr_suspend(thread_t target_thread);\n+  int GC_thr_continue(thread_t target_thread);\n+  void * GC_dlopen(const char *path, int mode);\n+\n+# ifdef _SOLARIS_PTHREADS\n+#   include <pthread.h>\n+    extern int GC_pthread_create(pthread_t *new_thread,\n+    \t\t\t         const pthread_attr_t *attr,\n+          \t\t\t void * (*thread_execp)(void *), void *arg);\n+    extern int GC_pthread_join(pthread_t wait_for, void **status);\n+\n+#   undef thread_t\n+\n+#   define pthread_join GC_pthread_join\n+#   define pthread_create GC_pthread_create\n+#endif\n+\n+# define thr_create GC_thr_create\n+# define thr_join GC_thr_join\n+# define thr_suspend GC_thr_suspend\n+# define thr_continue GC_thr_continue\n+# define dlopen GC_dlopen\n+\n+# endif /* SOLARIS_THREADS */\n+\n+\n+#if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+/* We treat these similarly. */\n+# include <pthread.h>\n+# include <signal.h>\n+\n+  int GC_pthread_create(pthread_t *new_thread,\n+                        const pthread_attr_t *attr,\n+\t\t        void *(*start_routine)(void *), void *arg);\n+  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n+  int GC_pthread_join(pthread_t thread, void **retval);\n+\n+# define pthread_create GC_pthread_create\n+# define pthread_sigmask GC_pthread_sigmask\n+# define pthread_join GC_pthread_join\n+\n+#endif /* IRIX_THREADS || LINUX_THREADS */\n+\n+#if defined(THREADS) && !defined(SRC_M3)\n+/* This returns a list of objects, linked through their first\t\t*/\n+/* word.  Its use can greatly reduce lock contention problems, since\t*/\n+/* the allocation lock can be acquired and released many fewer times.\t*/\n+GC_PTR GC_malloc_many(size_t lb);\n+#define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n+\t\t\t\t\t/* in returned list.\t\t*/\n+extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n+\n+#endif /* THREADS && !SRC_M3 */\n+\n+/*\n+ * If you are planning on putting\n+ * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n+ * from the statically loaded program section.\n+ * This circumvents a Solaris 2.X (X<=4) linker bug.\n+ */\n+#if defined(sparc) || defined(__sparc)\n+#   define GC_INIT() { extern end, etext; \\\n+\t\t       GC_noop(&end, &etext); }\n+#else\n+# if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n+    /*\n+     * Similarly gnu-win32 DLLs need explicit initialization\n+     */\n+#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n+# else\n+#   define GC_INIT()\n+# endif\n+#endif\n+\n+#ifdef __cplusplus\n+    }  /* end of extern \"C\" */\n+#endif\n+\n+#endif /* _GC_H */"}, {"sha": "d2b24bb8ab6d728608c4821ba93053d794f3ec34", "filename": "boehm-gc/cord/private/cord_pos.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fprivate%2Fcord_pos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fcord%2Fprivate%2Fcord_pos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fprivate%2Fcord_pos.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,118 @@\n+/* \n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, May 19, 1994 2:23 pm PDT */\n+# ifndef CORD_POSITION_H\n+\n+/* The representation of CORD_position.  This is private to the\t*/\n+/* implementation, but the size is known to clients.  Also\t*/\n+/* the implementation of some exported macros relies on it.\t*/\n+/* Don't use anything defined here and not in cord.h.\t\t*/\n+\n+# define MAX_DEPTH 48\n+\t/* The maximum depth of a balanced cord + 1.\t\t*/\n+\t/* We don't let cords get deeper than MAX_DEPTH.\t*/\n+\n+struct CORD_pe {\n+    CORD pe_cord;\n+    size_t pe_start_pos;\n+};\n+\n+/* A structure describing an entry on the path from the root \t*/\n+/* to current position.\t\t\t\t\t\t*/\n+typedef struct CORD_Pos {\n+    size_t cur_pos;\n+    int path_len;\n+#\tdefine CORD_POS_INVALID (0x55555555)\n+\t\t/* path_len == INVALID <==> position invalid */\n+    const char *cur_leaf;\t/* Current leaf, if it is a string.\t*/\n+    \t\t\t\t/* If the current leaf is a function,\t*/\n+    \t\t\t\t/* then this may point to function_buf\t*/\n+    \t\t\t\t/* containing the next few characters.\t*/\n+    \t\t\t\t/* Always points to a valid string\t*/\n+    \t\t\t\t/* containing the current character \t*/\n+    \t\t\t\t/* unless cur_end is 0.\t\t\t*/\n+    size_t cur_start;\t/* Start position of cur_leaf\t*/\n+    size_t cur_end;\t/* Ending position of cur_leaf\t*/\n+    \t\t\t/* 0 if cur_leaf is invalid.\t*/\n+    struct CORD_pe path[MAX_DEPTH + 1];\n+    \t/* path[path_len] is the leaf corresponding to cur_pos\t*/\n+    \t/* path[0].pe_cord is the cord we point to.\t\t*/\n+#   define FUNCTION_BUF_SZ 8\n+    char function_buf[FUNCTION_BUF_SZ];\t/* Space for next few chars\t*/\n+    \t\t\t\t\t/* from function node.\t\t*/\n+} CORD_pos[1];\n+\n+/* Extract the cord from a position:\t*/\n+CORD CORD_pos_to_cord(CORD_pos p);\n+\t\n+/* Extract the current index from a position:\t*/\n+size_t CORD_pos_to_index(CORD_pos p);\n+\t\n+/* Fetch the character located at the given position:\t*/\n+char CORD_pos_fetch(CORD_pos p);\n+\t\n+/* Initialize the position to refer to the give cord and index.\t*/\n+/* Note that this is the most expensive function on positions:\t*/\n+void CORD_set_pos(CORD_pos p, CORD x, size_t i);\n+\t\n+/* Advance the position to the next character.\t*/\n+/* P must be initialized and valid.\t\t*/\n+/* Invalidates p if past end:\t\t\t*/\n+void CORD_next(CORD_pos p);\n+\n+/* Move the position to the preceding character.\t*/\n+/* P must be initialized and valid.\t\t\t*/\n+/* Invalidates p if past beginning:\t\t\t*/\n+void CORD_prev(CORD_pos p);\n+\t\n+/* Is the position valid, i.e. inside the cord?\t\t*/\n+int CORD_pos_valid(CORD_pos p);\n+\n+char CORD__pos_fetch(CORD_pos);\n+void CORD__next(CORD_pos);\n+void CORD__prev(CORD_pos);\n+\n+#define CORD_pos_fetch(p)\t\\\n+    (((p)[0].cur_end != 0)? \\\n+     \t(p)[0].cur_leaf[(p)[0].cur_pos - (p)[0].cur_start] \\\n+     \t: CORD__pos_fetch(p))\n+\n+#define CORD_next(p)\t\\\n+    (((p)[0].cur_pos + 1 < (p)[0].cur_end)? \\\n+    \t(p)[0].cur_pos++ \\\n+    \t: (CORD__next(p), 0))\n+\n+#define CORD_prev(p)\t\\\n+    (((p)[0].cur_end != 0 && (p)[0].cur_pos > (p)[0].cur_start)? \\\n+    \t(p)[0].cur_pos-- \\\n+    \t: (CORD__prev(p), 0))\n+\n+#define CORD_pos_to_index(p) ((p)[0].cur_pos)\n+\n+#define CORD_pos_to_cord(p) ((p)[0].path[0].pe_cord)\n+\n+#define CORD_pos_valid(p) ((p)[0].path_len != CORD_POS_INVALID)\n+\n+/* Some grubby stuff for performance-critical friends:\t*/\n+#define CORD_pos_chars_left(p) ((long)((p)[0].cur_end) - (long)((p)[0].cur_pos))\n+\t/* Number of characters in cache.  <= 0 ==> none\t*/\n+\n+#define CORD_pos_advance(p,n) ((p)[0].cur_pos += (n) - 1, CORD_next(p))\n+\t/* Advance position by n characters\t*/\n+\t/* 0 < n < CORD_pos_chars_left(p)\t*/\n+\n+#define CORD_pos_cur_char_addr(p) \\\n+\t(p)[0].cur_leaf + ((p)[0].cur_pos - (p)[0].cur_start)\n+\t/* address of current character in cache.\t*/\n+\n+#endif"}, {"sha": "d825bf91a36acd0019bfb46a10773dbefa2b544e", "filename": "boehm-gc/finalize.c", "status": "added", "additions": 734, "deletions": 0, "changes": 734, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,734 @@\n+/*\n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n+\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, February 1, 1996 1:19 pm PST */\n+# define I_HIDE_POINTERS\n+# include \"gc_priv.h\"\n+# include \"gc_mark.h\"\n+\n+/* Type of mark procedure used for marking from finalizable object.\t*/\n+/* This procedure normally does not mark the object, only its\t\t*/\n+/* descendents.\t\t\t\t\t\t\t\t*/\n+typedef void finalization_mark_proc(/* ptr_t finalizable_obj_ptr */); \n+\n+# define HASH3(addr,size,log_size) \\\n+    ((((word)(addr) >> 3) ^ ((word)(addr) >> (3+(log_size)))) \\\n+    & ((size) - 1))\n+#define HASH2(addr,log_size) HASH3(addr, 1 << log_size, log_size)\n+\n+struct hash_chain_entry {\n+    word hidden_key;\n+    struct hash_chain_entry * next;\n+};\n+\n+unsigned GC_finalization_failures = 0;\n+\t/* Number of finalization requests that failed for lack of memory. */\n+\n+static struct disappearing_link {\n+    struct hash_chain_entry prolog;\n+#   define dl_hidden_link prolog.hidden_key\n+\t\t\t\t/* Field to be cleared.\t\t*/\n+#   define dl_next(x) (struct disappearing_link *)((x) -> prolog.next)\n+#   define dl_set_next(x,y) (x) -> prolog.next = (struct hash_chain_entry *)(y)\n+\n+    word dl_hidden_obj;\t\t/* Pointer to object base\t*/\n+} **dl_head = 0;\n+\n+static signed_word log_dl_table_size = -1;\n+\t\t\t/* Binary log of\t\t\t\t*/\n+\t\t\t/* current size of array pointed to by dl_head.\t*/\n+\t\t\t/* -1 ==> size is 0.\t\t\t\t*/\n+\n+word GC_dl_entries = 0;\t/* Number of entries currently in disappearing\t*/\n+\t\t\t/* link table.\t\t\t\t\t*/\n+\n+static struct finalizable_object {\n+    struct hash_chain_entry prolog;\n+#   define fo_hidden_base prolog.hidden_key\n+\t\t\t\t/* Pointer to object base.\t*/\n+\t\t\t\t/* No longer hidden once object */\n+\t\t\t\t/* is on finalize_now queue.\t*/\n+#   define fo_next(x) (struct finalizable_object *)((x) -> prolog.next)\n+#   define fo_set_next(x,y) (x) -> prolog.next = (struct hash_chain_entry *)(y)\n+    GC_finalization_proc fo_fn;\t/* Finalizer.\t\t\t*/\n+    ptr_t fo_client_data;\n+    word fo_object_size;\t/* In bytes.\t\t\t*/\n+    finalization_mark_proc * fo_mark_proc;\t/* Mark-through procedure */\n+} **fo_head = 0;\n+\n+struct finalizable_object * GC_finalize_now = 0;\n+\t/* LIst of objects that should be finalized now.\t*/\n+\n+static signed_word log_fo_table_size = -1;\n+\n+word GC_fo_entries = 0;\n+\n+# ifdef SRC_M3\n+void GC_push_finalizer_structures()\n+{\n+    GC_push_all((ptr_t)(&dl_head), (ptr_t)(&dl_head) + sizeof(word));\n+    GC_push_all((ptr_t)(&fo_head), (ptr_t)(&fo_head) + sizeof(word));\n+}\n+# endif\n+\n+/* Double the size of a hash table. *size_ptr is the log of its current\t*/\n+/* size.  May be a noop.\t\t\t\t\t\t*/\n+/* *table is a pointer to an array of hash headers.  If we succeed, we\t*/\n+/* update both *table and *log_size_ptr.\t\t\t\t*/\n+/* Lock is held.  Signals are disabled.\t\t\t\t\t*/\n+void GC_grow_table(table, log_size_ptr)\n+struct hash_chain_entry ***table;\n+signed_word * log_size_ptr;\n+{\n+    register word i;\n+    register struct hash_chain_entry *p;\n+    int log_old_size = *log_size_ptr;\n+    register int log_new_size = log_old_size + 1;\n+    word old_size = ((log_old_size == -1)? 0: (1 << log_old_size));\n+    register word new_size = 1 << log_new_size;\n+    struct hash_chain_entry **new_table = (struct hash_chain_entry **)\n+    \tGC_generic_malloc_inner_ignore_off_page(\n+    \t\t(size_t)new_size * sizeof(struct hash_chain_entry *), NORMAL);\n+    \n+    if (new_table == 0) {\n+    \tif (table == 0) {\n+    \t    ABORT(\"Insufficient space for initial table allocation\");\n+    \t} else {\n+    \t    return;\n+    \t}\n+    }\n+    for (i = 0; i < old_size; i++) {\n+      p = (*table)[i];\n+      while (p != 0) {\n+        register ptr_t real_key = (ptr_t)REVEAL_POINTER(p -> hidden_key);\n+        register struct hash_chain_entry *next = p -> next;\n+        register int new_hash = HASH3(real_key, new_size, log_new_size);\n+        \n+        p -> next = new_table[new_hash];\n+        new_table[new_hash] = p;\n+        p = next;\n+      }\n+    }\n+    *log_size_ptr = log_new_size;\n+    *table = new_table;\n+}\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    int GC_register_disappearing_link(GC_PTR * link)\n+# else\n+    int GC_register_disappearing_link(link)\n+    GC_PTR * link;\n+# endif\n+{\n+    ptr_t base;\n+    \n+    base = (ptr_t)GC_base((GC_PTR)link);\n+    if (base == 0)\n+    \tABORT(\"Bad arg to GC_register_disappearing_link\");\n+    return(GC_general_register_disappearing_link(link, base));\n+}\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    int GC_general_register_disappearing_link(GC_PTR * link,\n+    \t\t\t\t\t      GC_PTR obj)\n+# else\n+    int GC_general_register_disappearing_link(link, obj)\n+    GC_PTR * link;\n+    GC_PTR obj;\n+# endif\n+\n+{\n+    struct disappearing_link *curr_dl;\n+    int index;\n+    struct disappearing_link * new_dl;\n+    DCL_LOCK_STATE;\n+    \n+    if ((word)link & (ALIGNMENT-1))\n+    \tABORT(\"Bad arg to GC_general_register_disappearing_link\");\n+#   ifdef THREADS\n+    \tDISABLE_SIGNALS();\n+    \tLOCK();\n+#   endif\n+    if (log_dl_table_size == -1\n+        || GC_dl_entries > ((word)1 << log_dl_table_size)) {\n+#\tifndef THREADS\n+\t    DISABLE_SIGNALS();\n+#\tendif\n+    \tGC_grow_table((struct hash_chain_entry ***)(&dl_head),\n+    \t\t      &log_dl_table_size);\n+#\tifdef PRINTSTATS\n+\t    GC_printf1(\"Grew dl table to %lu entries\\n\",\n+\t    \t\t(unsigned long)(1 << log_dl_table_size));\n+#\tendif\n+#\tifndef THREADS\n+\t    ENABLE_SIGNALS();\n+#\tendif\n+    }\n+    index = HASH2(link, log_dl_table_size);\n+    curr_dl = dl_head[index];\n+    for (curr_dl = dl_head[index]; curr_dl != 0; curr_dl = dl_next(curr_dl)) {\n+        if (curr_dl -> dl_hidden_link == HIDE_POINTER(link)) {\n+            curr_dl -> dl_hidden_obj = HIDE_POINTER(obj);\n+#\t    ifdef THREADS\n+                UNLOCK();\n+    \t        ENABLE_SIGNALS();\n+#\t    endif\n+            return(1);\n+        }\n+    }\n+#   ifdef THREADS\n+      new_dl = (struct disappearing_link *)\n+    \tGC_generic_malloc_inner(sizeof(struct disappearing_link),NORMAL);\n+#   else\n+      new_dl = (struct disappearing_link *)\n+\tGC_malloc(sizeof(struct disappearing_link));\n+#   endif\n+    if (new_dl != 0) {\n+        new_dl -> dl_hidden_obj = HIDE_POINTER(obj);\n+        new_dl -> dl_hidden_link = HIDE_POINTER(link);\n+        dl_set_next(new_dl, dl_head[index]);\n+        dl_head[index] = new_dl;\n+        GC_dl_entries++;\n+    } else {\n+        GC_finalization_failures++;\n+    }\n+#   ifdef THREADS\n+        UNLOCK();\n+        ENABLE_SIGNALS();\n+#   endif\n+    return(0);\n+}\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+    int GC_unregister_disappearing_link(GC_PTR * link)\n+# else\n+    int GC_unregister_disappearing_link(link)\n+    GC_PTR * link;\n+# endif\n+{\n+    struct disappearing_link *curr_dl, *prev_dl;\n+    int index;\n+    DCL_LOCK_STATE;\n+    \n+    DISABLE_SIGNALS();\n+    LOCK();\n+    index = HASH2(link, log_dl_table_size);\n+    if (((unsigned long)link & (ALIGNMENT-1))) goto out;\n+    prev_dl = 0; curr_dl = dl_head[index];\n+    while (curr_dl != 0) {\n+        if (curr_dl -> dl_hidden_link == HIDE_POINTER(link)) {\n+            if (prev_dl == 0) {\n+                dl_head[index] = dl_next(curr_dl);\n+            } else {\n+                dl_set_next(prev_dl, dl_next(curr_dl));\n+            }\n+            GC_dl_entries--;\n+            UNLOCK();\n+    \t    ENABLE_SIGNALS();\n+            GC_free((GC_PTR)curr_dl);\n+            return(1);\n+        }\n+        prev_dl = curr_dl;\n+        curr_dl = dl_next(curr_dl);\n+    }\n+out:\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+    return(0);\n+}\n+\n+/* Possible finalization_marker procedures.  Note that mark stack\t*/\n+/* overflow is handled by the caller, and is not a disaster.\t\t*/\n+void GC_normal_finalize_mark_proc(p)\n+ptr_t p;\n+{\n+    hdr * hhdr = HDR(p);\n+    \n+    PUSH_OBJ((word *)p, hhdr, GC_mark_stack_top,\n+\t     &(GC_mark_stack[GC_mark_stack_size]));\n+}\n+\n+/* This only pays very partial attention to the mark descriptor.\t*/\n+/* It does the right thing for normal and atomic objects, and treats\t*/\n+/* most others as normal.\t\t\t\t\t\t*/\n+void GC_ignore_self_finalize_mark_proc(p)\n+ptr_t p;\n+{\n+    hdr * hhdr = HDR(p);\n+    word descr = hhdr -> hb_descr;\n+    ptr_t q, r;\n+    ptr_t scan_limit;\n+    ptr_t target_limit = p + WORDS_TO_BYTES(hhdr -> hb_sz) - 1;\n+    \n+    if ((descr & DS_TAGS) == DS_LENGTH) {\n+       scan_limit = p + descr - sizeof(word);\n+    } else {\n+       scan_limit = target_limit + 1 - sizeof(word);\n+    }\n+    for (q = p; q <= scan_limit; q += ALIGNMENT) {\n+    \tr = *(ptr_t *)q;\n+    \tif (r < p || r > target_limit) {\n+    \t    GC_PUSH_ONE_HEAP((word)r);\n+    \t}\n+    }\n+}\n+\n+/*ARGSUSED*/\n+void GC_null_finalize_mark_proc(p)\n+ptr_t p;\n+{\n+}\n+\n+\n+\n+/* Register a finalization function.  See gc.h for details.\t*/\n+/* in the nonthreads case, we try to avoid disabling signals,\t*/\n+/* since it can be expensive.  Threads packages typically\t*/\n+/* make it cheaper.\t\t\t\t\t\t*/\n+void GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, mp)\n+GC_PTR obj;\n+GC_finalization_proc fn;\n+GC_PTR cd;\n+GC_finalization_proc * ofn;\n+GC_PTR * ocd;\n+finalization_mark_proc * mp;\n+{\n+    ptr_t base;\n+    struct finalizable_object * curr_fo, * prev_fo;\n+    int index;\n+    struct finalizable_object *new_fo;\n+    DCL_LOCK_STATE;\n+\n+#   ifdef THREADS\n+\tDISABLE_SIGNALS();\n+\tLOCK();\n+#   endif\n+    if (log_fo_table_size == -1\n+        || GC_fo_entries > ((word)1 << log_fo_table_size)) {\n+#\tifndef THREADS\n+    \t    DISABLE_SIGNALS();\n+#\tendif\n+    \tGC_grow_table((struct hash_chain_entry ***)(&fo_head),\n+    \t\t      &log_fo_table_size);\n+#\tifdef PRINTSTATS\n+\t    GC_printf1(\"Grew fo table to %lu entries\\n\",\n+\t    \t\t(unsigned long)(1 << log_fo_table_size));\n+#\tendif\n+#\tifndef THREADS\n+\t    ENABLE_SIGNALS();\n+#\tendif\n+    }\n+    /* in the THREADS case signals are disabled and we hold allocation\t*/\n+    /* lock; otherwise neither is true.  Proceed carefully.\t\t*/\n+    base = (ptr_t)obj;\n+    index = HASH2(base, log_fo_table_size);\n+    prev_fo = 0; curr_fo = fo_head[index];\n+    while (curr_fo != 0) {\n+        if (curr_fo -> fo_hidden_base == HIDE_POINTER(base)) {\n+            /* Interruption by a signal in the middle of this\t*/\n+            /* should be safe.  The client may see only *ocd\t*/\n+            /* updated, but we'll declare that to be his\t*/\n+            /* problem.\t\t\t\t\t\t*/\n+            if (ocd) *ocd = (GC_PTR) curr_fo -> fo_client_data;\n+            if (ofn) *ofn = curr_fo -> fo_fn;\n+            /* Delete the structure for base. */\n+                if (prev_fo == 0) {\n+                  fo_head[index] = fo_next(curr_fo);\n+                } else {\n+                  fo_set_next(prev_fo, fo_next(curr_fo));\n+                }\n+            if (fn == 0) {\n+                GC_fo_entries--;\n+                  /* May not happen if we get a signal.  But a high\t*/\n+                  /* estimate will only make the table larger than\t*/\n+                  /* necessary.\t\t\t\t\t\t*/\n+#\t\tifndef THREADS\n+                  GC_free((GC_PTR)curr_fo);\n+#\t\tendif\n+            } else {\n+                curr_fo -> fo_fn = fn;\n+                curr_fo -> fo_client_data = (ptr_t)cd;\n+                curr_fo -> fo_mark_proc = mp;\n+\t\t/* Reinsert it.  We deleted it first to maintain\t*/\n+\t\t/* consistency in the event of a signal.\t\t*/\n+\t\tif (prev_fo == 0) {\n+                  fo_head[index] = curr_fo;\n+                } else {\n+                  fo_set_next(prev_fo, curr_fo);\n+                }\n+            }\n+#\t    ifdef THREADS\n+                UNLOCK();\n+    \t    \tENABLE_SIGNALS();\n+#\t    endif\n+            return;\n+        }\n+        prev_fo = curr_fo;\n+        curr_fo = fo_next(curr_fo);\n+    }\n+    if (ofn) *ofn = 0;\n+    if (ocd) *ocd = 0;\n+    if (fn == 0) {\n+#\tifdef THREADS\n+            UNLOCK();\n+    \t    ENABLE_SIGNALS();\n+#\tendif\n+        return;\n+    }\n+#   ifdef THREADS\n+      new_fo = (struct finalizable_object *)\n+    \tGC_generic_malloc_inner(sizeof(struct finalizable_object),NORMAL);\n+#   else\n+      new_fo = (struct finalizable_object *)\n+\tGC_malloc(sizeof(struct finalizable_object));\n+#   endif\n+    if (new_fo != 0) {\n+        new_fo -> fo_hidden_base = (word)HIDE_POINTER(base);\n+\tnew_fo -> fo_fn = fn;\n+\tnew_fo -> fo_client_data = (ptr_t)cd;\n+\tnew_fo -> fo_object_size = GC_size(base);\n+\tnew_fo -> fo_mark_proc = mp;\n+\tfo_set_next(new_fo, fo_head[index]);\n+\tGC_fo_entries++;\n+\tfo_head[index] = new_fo;\n+    } else {\n+     \tGC_finalization_failures++;\n+    }\n+#   ifdef THREADS\n+        UNLOCK();\n+    \tENABLE_SIGNALS();\n+#   endif\n+}\n+\n+# if defined(__STDC__)\n+    void GC_register_finalizer(void * obj,\n+\t\t\t       GC_finalization_proc fn, void * cd,\n+\t\t\t       GC_finalization_proc *ofn, void ** ocd)\n+# else\n+    void GC_register_finalizer(obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc * ofn;\n+    GC_PTR * ocd;\n+# endif\n+{\n+    GC_register_finalizer_inner(obj, fn, cd, ofn,\n+    \t\t\t\tocd, GC_normal_finalize_mark_proc);\n+}\n+\n+# if defined(__STDC__)\n+    void GC_register_finalizer_ignore_self(void * obj,\n+\t\t\t       GC_finalization_proc fn, void * cd,\n+\t\t\t       GC_finalization_proc *ofn, void ** ocd)\n+# else\n+    void GC_register_finalizer_ignore_self(obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc * ofn;\n+    GC_PTR * ocd;\n+# endif\n+{\n+    GC_register_finalizer_inner(obj, fn, cd, ofn,\n+    \t\t\t\tocd, GC_ignore_self_finalize_mark_proc);\n+}\n+\n+# if defined(__STDC__)\n+    void GC_register_finalizer_no_order(void * obj,\n+\t\t\t       GC_finalization_proc fn, void * cd,\n+\t\t\t       GC_finalization_proc *ofn, void ** ocd)\n+# else\n+    void GC_register_finalizer_no_order(obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc * ofn;\n+    GC_PTR * ocd;\n+# endif\n+{\n+    GC_register_finalizer_inner(obj, fn, cd, ofn,\n+    \t\t\t\tocd, GC_null_finalize_mark_proc);\n+}\n+\n+/* Called with world stopped.  Cause disappearing links to disappear,\t*/\n+/* and invoke finalizers.\t\t\t\t\t\t*/\n+void GC_finalize()\n+{\n+    struct disappearing_link * curr_dl, * prev_dl, * next_dl;\n+    struct finalizable_object * curr_fo, * prev_fo, * next_fo;\n+    ptr_t real_ptr, real_link;\n+    register int i;\n+    int dl_size = (log_dl_table_size == -1 ) ? 0 : (1 << log_dl_table_size);\n+    int fo_size = (log_fo_table_size == -1 ) ? 0 : (1 << log_fo_table_size);\n+    \n+  /* Make disappearing links disappear */\n+    for (i = 0; i < dl_size; i++) {\n+      curr_dl = dl_head[i];\n+      prev_dl = 0;\n+      while (curr_dl != 0) {\n+        real_ptr = (ptr_t)REVEAL_POINTER(curr_dl -> dl_hidden_obj);\n+        real_link = (ptr_t)REVEAL_POINTER(curr_dl -> dl_hidden_link);\n+        if (!GC_is_marked(real_ptr)) {\n+            *(word *)real_link = 0;\n+            next_dl = dl_next(curr_dl);\n+            if (prev_dl == 0) {\n+                dl_head[i] = next_dl;\n+            } else {\n+                dl_set_next(prev_dl, next_dl);\n+            }\n+            GC_clear_mark_bit((ptr_t)curr_dl);\n+            GC_dl_entries--;\n+            curr_dl = next_dl;\n+        } else {\n+            prev_dl = curr_dl;\n+            curr_dl = dl_next(curr_dl);\n+        }\n+      }\n+    }\n+  /* Mark all objects reachable via chains of 1 or more pointers\t*/\n+  /* from finalizable objects.\t\t\t\t\t\t*/\n+#   ifdef PRINTSTATS\n+        if (GC_mark_state != MS_NONE) ABORT(\"Bad mark state\");\n+#   endif\n+    for (i = 0; i < fo_size; i++) {\n+      for (curr_fo = fo_head[i]; curr_fo != 0; curr_fo = fo_next(curr_fo)) {\n+        real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n+        if (!GC_is_marked(real_ptr)) {\n+            GC_MARK_FO(real_ptr, curr_fo -> fo_mark_proc);\n+            if (GC_is_marked(real_ptr)) {\n+                WARN(\"Finalization cycle involving %lx\\n\", real_ptr);\n+            }\n+        }\n+      }\n+    }\n+  /* Enqueue for finalization all objects that are still\t\t*/\n+  /* unreachable.\t\t\t\t\t\t\t*/\n+    GC_words_finalized = 0;\n+    for (i = 0; i < fo_size; i++) {\n+      curr_fo = fo_head[i];\n+      prev_fo = 0;\n+      while (curr_fo != 0) {\n+        real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n+        if (!GC_is_marked(real_ptr)) {\n+#         ifndef JAVA_FINALIZATION\n+            GC_set_mark_bit(real_ptr);\n+#         endif\n+            /* Delete from hash table */\n+              next_fo = fo_next(curr_fo);\n+              if (prev_fo == 0) {\n+                fo_head[i] = next_fo;\n+              } else {\n+                fo_set_next(prev_fo, next_fo);\n+              }\n+              GC_fo_entries--;\n+            /* Add to list of objects awaiting finalization.\t*/\n+              fo_set_next(curr_fo, GC_finalize_now);\n+              GC_finalize_now = curr_fo;\n+              /* unhide object pointer so any future collections will\t*/\n+              /* see it.\t\t\t\t\t\t*/\n+              curr_fo -> fo_hidden_base = \n+              \t\t(word) REVEAL_POINTER(curr_fo -> fo_hidden_base);\n+              GC_words_finalized +=\n+                 \tALIGNED_WORDS(curr_fo -> fo_object_size)\n+              \t\t+ ALIGNED_WORDS(sizeof(struct finalizable_object));\n+#\t    ifdef PRINTSTATS\n+              if (!GC_is_marked((ptr_t)curr_fo)) {\n+                ABORT(\"GC_finalize: found accessible unmarked object\\n\");\n+              }\n+#\t    endif\n+            curr_fo = next_fo;\n+        } else {\n+            prev_fo = curr_fo;\n+            curr_fo = fo_next(curr_fo);\n+        }\n+      }\n+    }\n+\n+# ifdef JAVA_FINALIZATION\n+  /* make sure we mark everything reachable from objects finalized\n+     using the no_order mark_proc */\n+    for (curr_fo = GC_finalize_now; \n+\t curr_fo != NULL; curr_fo = fo_next(curr_fo)) {\n+\treal_ptr = (ptr_t)curr_fo -> fo_hidden_base;\n+\tif (!GC_is_marked(real_ptr)) {\n+\t    if (curr_fo -> fo_mark_proc == GC_null_finalize_mark_proc) {\n+\t        GC_MARK_FO(real_ptr, GC_normal_finalize_mark_proc);\n+\t    }\n+\t    GC_set_mark_bit(real_ptr);\n+\t}\n+    }\n+# endif\n+\n+  /* Remove dangling disappearing links. */\n+    for (i = 0; i < dl_size; i++) {\n+      curr_dl = dl_head[i];\n+      prev_dl = 0;\n+      while (curr_dl != 0) {\n+        real_link = GC_base((ptr_t)REVEAL_POINTER(curr_dl -> dl_hidden_link));\n+        if (real_link != 0 && !GC_is_marked(real_link)) {\n+            next_dl = dl_next(curr_dl);\n+            if (prev_dl == 0) {\n+                dl_head[i] = next_dl;\n+            } else {\n+                dl_set_next(prev_dl, next_dl);\n+            }\n+            GC_clear_mark_bit((ptr_t)curr_dl);\n+            GC_dl_entries--;\n+            curr_dl = next_dl;\n+        } else {\n+            prev_dl = curr_dl;\n+            curr_dl = dl_next(curr_dl);\n+        }\n+      }\n+    }\n+}\n+\n+#ifdef JAVA_FINALIZATION\n+\n+/* Enqueue all remaining finalizers to be run - Assumes lock is\n+ * held, and signals are disabled */\n+void GC_enqueue_all_finalizers()\n+{\n+    struct finalizable_object * curr_fo, * prev_fo, * next_fo;\n+    ptr_t real_ptr, real_link;\n+    register int i;\n+    int fo_size;\n+    \n+    fo_size = (log_fo_table_size == -1 ) ? 0 : (1 << log_fo_table_size);\n+    GC_words_finalized = 0;\n+    for (i = 0; i < fo_size; i++) {\n+        curr_fo = fo_head[i];\n+        prev_fo = 0;\n+      while (curr_fo != 0) {\n+          real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n+          GC_MARK_FO(real_ptr, GC_normal_finalize_mark_proc);\n+          GC_set_mark_bit(real_ptr);\n+ \n+          /* Delete from hash table */\n+          next_fo = fo_next(curr_fo);\n+          if (prev_fo == 0) {\n+              fo_head[i] = next_fo;\n+          } else {\n+              fo_set_next(prev_fo, next_fo);\n+          }\n+          GC_fo_entries--;\n+\n+          /* Add to list of objects awaiting finalization.\t*/\n+          fo_set_next(curr_fo, GC_finalize_now);\n+          GC_finalize_now = curr_fo;\n+\n+          /* unhide object pointer so any future collections will\t*/\n+          /* see it.\t\t\t\t\t\t*/\n+          curr_fo -> fo_hidden_base = \n+        \t\t(word) REVEAL_POINTER(curr_fo -> fo_hidden_base);\n+\n+          GC_words_finalized +=\n+           \tALIGNED_WORDS(curr_fo -> fo_object_size)\n+        \t\t+ ALIGNED_WORDS(sizeof(struct finalizable_object));\n+          curr_fo = next_fo;\n+        }\n+    }\n+\n+    return;\n+}\n+\n+/* Invoke all remaining finalizers that haven't yet been run. \n+ * This is needed for strict compliance with the Java standard, \n+ * which can make the runtime guarantee that all finalizers are run.\n+ * Unfortunately, the Java standard implies we have to keep running\n+ * finalizers until there are no more left, a potential infinite loop.\n+ * YUCK.  * This routine is externally callable, so is called without \n+ * the allocation lock \n+ */\n+void GC_finalize_all()\n+{\n+    DCL_LOCK_STATE;\n+\n+    DISABLE_SIGNALS();\n+    LOCK();\n+    while (GC_fo_entries > 0) {\n+      GC_enqueue_all_finalizers();\n+      UNLOCK();\n+      ENABLE_SIGNALS();\n+      GC_INVOKE_FINALIZERS();\n+      DISABLE_SIGNALS();\n+      LOCK();\n+    }\n+    UNLOCK();\n+    ENABLE_SIGNALS();\n+}\n+#endif\n+\n+/* Invoke finalizers for all objects that are ready to be finalized.\t*/\n+/* Should be called without allocation lock.\t\t\t\t*/\n+int GC_invoke_finalizers()\n+{\n+    register struct finalizable_object * curr_fo;\n+    register int count = 0;\n+    DCL_LOCK_STATE;\n+    \n+    while (GC_finalize_now != 0) {\n+#\tifdef THREADS\n+\t    DISABLE_SIGNALS();\n+\t    LOCK();\n+#\tendif\n+    \tcurr_fo = GC_finalize_now;\n+#\tifdef THREADS\n+ \t    if (curr_fo != 0) GC_finalize_now = fo_next(curr_fo);\n+\t    UNLOCK();\n+\t    ENABLE_SIGNALS();\n+\t    if (curr_fo == 0) break;\n+#\telse\n+\t    GC_finalize_now = fo_next(curr_fo);\n+#\tendif\n+ \tfo_set_next(curr_fo, 0);\n+    \t(*(curr_fo -> fo_fn))((ptr_t)(curr_fo -> fo_hidden_base),\n+    \t\t\t      curr_fo -> fo_client_data);\n+    \tcurr_fo -> fo_client_data = 0;\n+\t++count;\n+#\tifdef UNDEFINED\n+\t    /* This is probably a bad idea.  It throws off accounting if */\n+\t    /* nearly all objects are finalizable.  O.w. it shouldn't\t */\n+\t    /* matter.\t\t\t\t\t\t\t */\n+    \t    GC_free((GC_PTR)curr_fo);\n+#\tendif\n+    }\n+    return count;\n+}\n+\n+# ifdef __STDC__\n+    GC_PTR GC_call_with_alloc_lock(GC_fn_type fn,\n+    \t\t\t\t\t GC_PTR client_data)\n+# else\n+    GC_PTR GC_call_with_alloc_lock(fn, client_data)\n+    GC_fn_type fn;\n+    GC_PTR client_data;\n+# endif\n+{\n+    GC_PTR result;\n+    DCL_LOCK_STATE;\n+    \n+#   ifdef THREADS\n+      DISABLE_SIGNALS();\n+      LOCK();\n+      SET_LOCK_HOLDER();\n+#   endif\n+    result = (*fn)(client_data);\n+#   ifdef THREADS\n+      UNSET_LOCK_HOLDER();\n+      UNLOCK();\n+      ENABLE_SIGNALS();\n+#   endif\n+    return(result);\n+}"}, {"sha": "fdd0c9c6dc3999c58e845c388bfaded40734343f", "filename": "boehm-gc/gc.mak", "status": "added", "additions": 2087, "deletions": 0, "changes": 2087, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.mak?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,2087 @@\n+# Microsoft Developer Studio Generated NMAKE File, Format Version 4.10\n+# ** DO NOT EDIT **\n+\n+# TARGTYPE \"Win32 (x86) Application\" 0x0101\n+# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n+\n+!IF \"$(CFG)\" == \"\"\n+CFG=cord - Win32 Debug\n+!MESSAGE No configuration specified.  Defaulting to cord - Win32 Debug.\n+!ENDIF \n+\n+!IF \"$(CFG)\" != \"gc - Win32 Release\" && \"$(CFG)\" != \"gc - Win32 Debug\" &&\\\n+ \"$(CFG)\" != \"gctest - Win32 Release\" && \"$(CFG)\" != \"gctest - Win32 Debug\" &&\\\n+ \"$(CFG)\" != \"cord - Win32 Release\" && \"$(CFG)\" != \"cord - Win32 Debug\"\n+!MESSAGE Invalid configuration \"$(CFG)\" specified.\n+!MESSAGE You can specify a configuration when running NMAKE on this makefile\n+!MESSAGE by defining the macro CFG on the command line.  For example:\n+!MESSAGE \n+!MESSAGE NMAKE /f \"gc.mak\" CFG=\"cord - Win32 Debug\"\n+!MESSAGE \n+!MESSAGE Possible choices for configuration are:\n+!MESSAGE \n+!MESSAGE \"gc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"gc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n+!MESSAGE \"gctest - Win32 Release\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \"gctest - Win32 Debug\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \"cord - Win32 Release\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \"cord - Win32 Debug\" (based on \"Win32 (x86) Application\")\n+!MESSAGE \n+!ERROR An invalid configuration is specified.\n+!ENDIF \n+\n+!IF \"$(OS)\" == \"Windows_NT\"\n+NULL=\n+!ELSE \n+NULL=nul\n+!ENDIF \n+################################################################################\n+# Begin Project\n+# PROP Target_Last_Scanned \"gctest - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"Release\"\n+# PROP BASE Intermediate_Dir \"Release\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"Release\"\n+# PROP Intermediate_Dir \"Release\"\n+# PROP Target_Dir \"\"\n+OUTDIR=.\\Release\n+INTDIR=.\\Release\n+\n+ALL : \".\\Release\\gc.dll\" \".\\Release\\gc.bsc\"\n+\n+CLEAN : \n+\t-@erase \".\\Release\\allchblk.obj\"\n+\t-@erase \".\\Release\\allchblk.sbr\"\n+\t-@erase \".\\Release\\alloc.obj\"\n+\t-@erase \".\\Release\\alloc.sbr\"\n+\t-@erase \".\\Release\\blacklst.obj\"\n+\t-@erase \".\\Release\\blacklst.sbr\"\n+\t-@erase \".\\Release\\checksums.obj\"\n+\t-@erase \".\\Release\\checksums.sbr\"\n+\t-@erase \".\\Release\\dbg_mlc.obj\"\n+\t-@erase \".\\Release\\dbg_mlc.sbr\"\n+\t-@erase \".\\Release\\dyn_load.obj\"\n+\t-@erase \".\\Release\\dyn_load.sbr\"\n+\t-@erase \".\\Release\\finalize.obj\"\n+\t-@erase \".\\Release\\finalize.sbr\"\n+\t-@erase \".\\Release\\gc.bsc\"\n+\t-@erase \".\\Release\\gc.dll\"\n+\t-@erase \".\\Release\\gc.exp\"\n+\t-@erase \".\\Release\\gc.lib\"\n+\t-@erase \".\\Release\\headers.obj\"\n+\t-@erase \".\\Release\\headers.sbr\"\n+\t-@erase \".\\Release\\mach_dep.obj\"\n+\t-@erase \".\\Release\\mach_dep.sbr\"\n+\t-@erase \".\\Release\\malloc.obj\"\n+\t-@erase \".\\Release\\malloc.sbr\"\n+\t-@erase \".\\Release\\mallocx.obj\"\n+\t-@erase \".\\Release\\mallocx.sbr\"\n+\t-@erase \".\\Release\\mark.obj\"\n+\t-@erase \".\\Release\\mark.sbr\"\n+\t-@erase \".\\Release\\mark_rts.obj\"\n+\t-@erase \".\\Release\\mark_rts.sbr\"\n+\t-@erase \".\\Release\\misc.obj\"\n+\t-@erase \".\\Release\\misc.sbr\"\n+\t-@erase \".\\Release\\new_hblk.obj\"\n+\t-@erase \".\\Release\\new_hblk.sbr\"\n+\t-@erase \".\\Release\\obj_map.obj\"\n+\t-@erase \".\\Release\\obj_map.sbr\"\n+\t-@erase \".\\Release\\os_dep.obj\"\n+\t-@erase \".\\Release\\os_dep.sbr\"\n+\t-@erase \".\\Release\\ptr_chck.obj\"\n+\t-@erase \".\\Release\\ptr_chck.sbr\"\n+\t-@erase \".\\Release\\reclaim.obj\"\n+\t-@erase \".\\Release\\reclaim.sbr\"\n+\t-@erase \".\\Release\\stubborn.obj\"\n+\t-@erase \".\\Release\\stubborn.sbr\"\n+\t-@erase \".\\Release\\typd_mlc.obj\"\n+\t-@erase \".\\Release\\typd_mlc.sbr\"\n+\t-@erase \".\\Release\\win32_threads.obj\"\n+\t-@erase \".\\Release\\win32_threads.sbr\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n+ \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n+ \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\Release/\n+CPP_SBRS=.\\Release/\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /win32\n+MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n+# ADD RSC /l 0x809 /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gc.bsc\" \n+BSC32_SBRS= \\\n+\t\".\\Release\\allchblk.sbr\" \\\n+\t\".\\Release\\alloc.sbr\" \\\n+\t\".\\Release\\blacklst.sbr\" \\\n+\t\".\\Release\\checksums.sbr\" \\\n+\t\".\\Release\\dbg_mlc.sbr\" \\\n+\t\".\\Release\\dyn_load.sbr\" \\\n+\t\".\\Release\\finalize.sbr\" \\\n+\t\".\\Release\\headers.sbr\" \\\n+\t\".\\Release\\mach_dep.sbr\" \\\n+\t\".\\Release\\malloc.sbr\" \\\n+\t\".\\Release\\mallocx.sbr\" \\\n+\t\".\\Release\\mark.sbr\" \\\n+\t\".\\Release\\mark_rts.sbr\" \\\n+\t\".\\Release\\misc.sbr\" \\\n+\t\".\\Release\\new_hblk.sbr\" \\\n+\t\".\\Release\\obj_map.sbr\" \\\n+\t\".\\Release\\os_dep.sbr\" \\\n+\t\".\\Release\\ptr_chck.sbr\" \\\n+\t\".\\Release\\reclaim.sbr\" \\\n+\t\".\\Release\\stubborn.sbr\" \\\n+\t\".\\Release\\typd_mlc.sbr\" \\\n+\t\".\\Release\\win32_threads.sbr\"\n+\n+\".\\Release\\gc.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n+    $(BSC32) @<<\n+  $(BSC32_FLAGS) $(BSC32_SBRS)\n+<<\n+\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /dll /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gc.pdb\" /machine:I386 /out:\"$(OUTDIR)/gc.dll\"\\\n+ /implib:\"$(OUTDIR)/gc.lib\" \n+LINK32_OBJS= \\\n+\t\".\\Release\\allchblk.obj\" \\\n+\t\".\\Release\\alloc.obj\" \\\n+\t\".\\Release\\blacklst.obj\" \\\n+\t\".\\Release\\checksums.obj\" \\\n+\t\".\\Release\\dbg_mlc.obj\" \\\n+\t\".\\Release\\dyn_load.obj\" \\\n+\t\".\\Release\\finalize.obj\" \\\n+\t\".\\Release\\headers.obj\" \\\n+\t\".\\Release\\mach_dep.obj\" \\\n+\t\".\\Release\\malloc.obj\" \\\n+\t\".\\Release\\mallocx.obj\" \\\n+\t\".\\Release\\mark.obj\" \\\n+\t\".\\Release\\mark_rts.obj\" \\\n+\t\".\\Release\\misc.obj\" \\\n+\t\".\\Release\\new_hblk.obj\" \\\n+\t\".\\Release\\obj_map.obj\" \\\n+\t\".\\Release\\os_dep.obj\" \\\n+\t\".\\Release\\ptr_chck.obj\" \\\n+\t\".\\Release\\reclaim.obj\" \\\n+\t\".\\Release\\stubborn.obj\" \\\n+\t\".\\Release\\typd_mlc.obj\" \\\n+\t\".\\Release\\win32_threads.obj\"\n+\n+\".\\Release\\gc.dll\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \"Debug\"\n+# PROP BASE Intermediate_Dir \"Debug\"\n+# PROP BASE Target_Dir \"\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \"Debug\"\n+# PROP Intermediate_Dir \"Debug\"\n+# PROP Target_Dir \"\"\n+OUTDIR=.\\Debug\n+INTDIR=.\\Debug\n+\n+ALL : \".\\Debug\\gc.dll\" \".\\Debug\\gc.bsc\"\n+\n+CLEAN : \n+\t-@erase \".\\Debug\\allchblk.obj\"\n+\t-@erase \".\\Debug\\allchblk.sbr\"\n+\t-@erase \".\\Debug\\alloc.obj\"\n+\t-@erase \".\\Debug\\alloc.sbr\"\n+\t-@erase \".\\Debug\\blacklst.obj\"\n+\t-@erase \".\\Debug\\blacklst.sbr\"\n+\t-@erase \".\\Debug\\checksums.obj\"\n+\t-@erase \".\\Debug\\checksums.sbr\"\n+\t-@erase \".\\Debug\\dbg_mlc.obj\"\n+\t-@erase \".\\Debug\\dbg_mlc.sbr\"\n+\t-@erase \".\\Debug\\dyn_load.obj\"\n+\t-@erase \".\\Debug\\dyn_load.sbr\"\n+\t-@erase \".\\Debug\\finalize.obj\"\n+\t-@erase \".\\Debug\\finalize.sbr\"\n+\t-@erase \".\\Debug\\gc.bsc\"\n+\t-@erase \".\\Debug\\gc.dll\"\n+\t-@erase \".\\Debug\\gc.exp\"\n+\t-@erase \".\\Debug\\gc.lib\"\n+\t-@erase \".\\Debug\\gc.map\"\n+\t-@erase \".\\Debug\\gc.pdb\"\n+\t-@erase \".\\Debug\\headers.obj\"\n+\t-@erase \".\\Debug\\headers.sbr\"\n+\t-@erase \".\\Debug\\mach_dep.obj\"\n+\t-@erase \".\\Debug\\mach_dep.sbr\"\n+\t-@erase \".\\Debug\\malloc.obj\"\n+\t-@erase \".\\Debug\\malloc.sbr\"\n+\t-@erase \".\\Debug\\mallocx.obj\"\n+\t-@erase \".\\Debug\\mallocx.sbr\"\n+\t-@erase \".\\Debug\\mark.obj\"\n+\t-@erase \".\\Debug\\mark.sbr\"\n+\t-@erase \".\\Debug\\mark_rts.obj\"\n+\t-@erase \".\\Debug\\mark_rts.sbr\"\n+\t-@erase \".\\Debug\\misc.obj\"\n+\t-@erase \".\\Debug\\misc.sbr\"\n+\t-@erase \".\\Debug\\new_hblk.obj\"\n+\t-@erase \".\\Debug\\new_hblk.sbr\"\n+\t-@erase \".\\Debug\\obj_map.obj\"\n+\t-@erase \".\\Debug\\obj_map.sbr\"\n+\t-@erase \".\\Debug\\os_dep.obj\"\n+\t-@erase \".\\Debug\\os_dep.sbr\"\n+\t-@erase \".\\Debug\\ptr_chck.obj\"\n+\t-@erase \".\\Debug\\ptr_chck.sbr\"\n+\t-@erase \".\\Debug\\reclaim.obj\"\n+\t-@erase \".\\Debug\\reclaim.sbr\"\n+\t-@erase \".\\Debug\\stubborn.obj\"\n+\t-@erase \".\\Debug\\stubborn.sbr\"\n+\t-@erase \".\\Debug\\typd_mlc.obj\"\n+\t-@erase \".\\Debug\\typd_mlc.sbr\"\n+\t-@erase \".\\Debug\\vc40.idb\"\n+\t-@erase \".\\Debug\\vc40.pdb\"\n+\t-@erase \".\\Debug\\win32_threads.obj\"\n+\t-@erase \".\\Debug\\win32_threads.sbr\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n+ /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n+ \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n+ /Fd\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\Debug/\n+CPP_SBRS=.\\Debug/\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /win32\n+MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n+# ADD RSC /l 0x809 /d \"_DEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gc.bsc\" \n+BSC32_SBRS= \\\n+\t\".\\Debug\\allchblk.sbr\" \\\n+\t\".\\Debug\\alloc.sbr\" \\\n+\t\".\\Debug\\blacklst.sbr\" \\\n+\t\".\\Debug\\checksums.sbr\" \\\n+\t\".\\Debug\\dbg_mlc.sbr\" \\\n+\t\".\\Debug\\dyn_load.sbr\" \\\n+\t\".\\Debug\\finalize.sbr\" \\\n+\t\".\\Debug\\headers.sbr\" \\\n+\t\".\\Debug\\mach_dep.sbr\" \\\n+\t\".\\Debug\\malloc.sbr\" \\\n+\t\".\\Debug\\mallocx.sbr\" \\\n+\t\".\\Debug\\mark.sbr\" \\\n+\t\".\\Debug\\mark_rts.sbr\" \\\n+\t\".\\Debug\\misc.sbr\" \\\n+\t\".\\Debug\\new_hblk.sbr\" \\\n+\t\".\\Debug\\obj_map.sbr\" \\\n+\t\".\\Debug\\os_dep.sbr\" \\\n+\t\".\\Debug\\ptr_chck.sbr\" \\\n+\t\".\\Debug\\reclaim.sbr\" \\\n+\t\".\\Debug\\stubborn.sbr\" \\\n+\t\".\\Debug\\typd_mlc.sbr\" \\\n+\t\".\\Debug\\win32_threads.sbr\"\n+\n+\".\\Debug\\gc.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n+    $(BSC32) @<<\n+  $(BSC32_FLAGS) $(BSC32_SBRS)\n+<<\n+\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /incremental:no /map /debug /machine:I386\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /dll /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gc.pdb\" /map:\"$(INTDIR)/gc.map\" /debug /machine:I386\\\n+ /out:\"$(OUTDIR)/gc.dll\" /implib:\"$(OUTDIR)/gc.lib\" \n+LINK32_OBJS= \\\n+\t\".\\Debug\\allchblk.obj\" \\\n+\t\".\\Debug\\alloc.obj\" \\\n+\t\".\\Debug\\blacklst.obj\" \\\n+\t\".\\Debug\\checksums.obj\" \\\n+\t\".\\Debug\\dbg_mlc.obj\" \\\n+\t\".\\Debug\\dyn_load.obj\" \\\n+\t\".\\Debug\\finalize.obj\" \\\n+\t\".\\Debug\\headers.obj\" \\\n+\t\".\\Debug\\mach_dep.obj\" \\\n+\t\".\\Debug\\malloc.obj\" \\\n+\t\".\\Debug\\mallocx.obj\" \\\n+\t\".\\Debug\\mark.obj\" \\\n+\t\".\\Debug\\mark_rts.obj\" \\\n+\t\".\\Debug\\misc.obj\" \\\n+\t\".\\Debug\\new_hblk.obj\" \\\n+\t\".\\Debug\\obj_map.obj\" \\\n+\t\".\\Debug\\os_dep.obj\" \\\n+\t\".\\Debug\\ptr_chck.obj\" \\\n+\t\".\\Debug\\reclaim.obj\" \\\n+\t\".\\Debug\\stubborn.obj\" \\\n+\t\".\\Debug\\typd_mlc.obj\" \\\n+\t\".\\Debug\\win32_threads.obj\"\n+\n+\".\\Debug\\gc.dll\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"gctest\\Release\"\n+# PROP BASE Intermediate_Dir \"gctest\\Release\"\n+# PROP BASE Target_Dir \"gctest\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"gctest\\Release\"\n+# PROP Intermediate_Dir \"gctest\\Release\"\n+# PROP Target_Dir \"gctest\"\n+OUTDIR=.\\gctest\\Release\n+INTDIR=.\\gctest\\Release\n+\n+ALL : \"gc - Win32 Release\" \".\\Release\\gctest.exe\"\n+\n+CLEAN : \n+\t-@erase \".\\gctest\\Release\\test.obj\"\n+\t-@erase \".\\Release\\gctest.exe\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+ \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\"\\\n+ /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\gctest\\Release/\n+CPP_SBRS=.\\.\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /win32\n+MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n+# ADD RSC /l 0x809 /d \"NDEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gctest.bsc\" \n+BSC32_SBRS= \\\n+\t\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:\"Release/gctest.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gctest.pdb\" /machine:I386 /out:\"Release/gctest.exe\" \n+LINK32_OBJS= \\\n+\t\".\\gctest\\Release\\test.obj\" \\\n+\t\".\\Release\\gc.lib\"\n+\n+\".\\Release\\gctest.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \"gctest\\Debug\"\n+# PROP BASE Intermediate_Dir \"gctest\\Debug\"\n+# PROP BASE Target_Dir \"gctest\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \"gctest\\Debug\"\n+# PROP Intermediate_Dir \"gctest\\Debug\"\n+# PROP Target_Dir \"gctest\"\n+OUTDIR=.\\gctest\\Debug\n+INTDIR=.\\gctest\\Debug\n+\n+ALL : \"gc - Win32 Debug\" \".\\Debug\\gctest.exe\" \".\\gctest\\Debug\\gctest.bsc\"\n+\n+CLEAN : \n+\t-@erase \".\\Debug\\gctest.exe\"\n+\t-@erase \".\\gctest\\Debug\\gctest.bsc\"\n+\t-@erase \".\\gctest\\Debug\\gctest.map\"\n+\t-@erase \".\\gctest\\Debug\\gctest.pdb\"\n+\t-@erase \".\\gctest\\Debug\\test.obj\"\n+\t-@erase \".\\gctest\\Debug\\test.sbr\"\n+\t-@erase \".\\gctest\\Debug\\vc40.idb\"\n+\t-@erase \".\\gctest\\Debug\\vc40.pdb\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n+ /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n+ /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\gctest\\Debug/\n+CPP_SBRS=.\\gctest\\Debug/\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /win32\n+MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n+# ADD RSC /l 0x809 /d \"_DEBUG\"\n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/gctest.bsc\" \n+BSC32_SBRS= \\\n+\t\".\\gctest\\Debug\\test.sbr\"\n+\n+\".\\gctest\\Debug\\gctest.bsc\" : \"$(OUTDIR)\" $(BSC32_SBRS)\n+    $(BSC32) @<<\n+  $(BSC32_FLAGS) $(BSC32_SBRS)\n+<<\n+\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:no /map /debug /machine:I386 /out:\"Debug/gctest.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:no\\\n+ /pdb:\"$(OUTDIR)/gctest.pdb\" /map:\"$(INTDIR)/gctest.map\" /debug /machine:I386\\\n+ /out:\"Debug/gctest.exe\" \n+LINK32_OBJS= \\\n+\t\".\\Debug\\gc.lib\" \\\n+\t\".\\gctest\\Debug\\test.obj\"\n+\n+\".\\Debug\\gctest.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 0\n+# PROP BASE Output_Dir \"cord\\Release\"\n+# PROP BASE Intermediate_Dir \"cord\\Release\"\n+# PROP BASE Target_Dir \"cord\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 0\n+# PROP Output_Dir \"cord\\Release\"\n+# PROP Intermediate_Dir \"cord\\Release\"\n+# PROP Target_Dir \"cord\"\n+OUTDIR=.\\cord\\Release\n+INTDIR=.\\cord\\Release\n+\n+ALL : \"gc - Win32 Release\" \".\\Release\\de.exe\"\n+\n+CLEAN : \n+\t-@erase \".\\cord\\Release\\cordbscs.obj\"\n+\t-@erase \".\\cord\\Release\\cordxtra.obj\"\n+\t-@erase \".\\cord\\Release\\de.obj\"\n+\t-@erase \".\\cord\\Release\\de_win.obj\"\n+\t-@erase \".\\cord\\Release\\de_win.res\"\n+\t-@erase \".\\Release\\de.exe\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+ \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX /Fo\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\cord\\Release/\n+CPP_SBRS=.\\.\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n+# ADD MTL /nologo /D \"NDEBUG\" /win32\n+MTL_PROJ=/nologo /D \"NDEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"NDEBUG\"\n+# ADD RSC /l 0x809 /d \"NDEBUG\"\n+RSC_PROJ=/l 0x809 /fo\"$(INTDIR)/de_win.res\" /d \"NDEBUG\" \n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/cord.bsc\" \n+BSC32_SBRS= \\\n+\t\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:\"Release/de.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:no /pdb:\"$(OUTDIR)/de.pdb\"\\\n+ /machine:I386 /out:\"Release/de.exe\" \n+LINK32_OBJS= \\\n+\t\".\\cord\\Release\\cordbscs.obj\" \\\n+\t\".\\cord\\Release\\cordxtra.obj\" \\\n+\t\".\\cord\\Release\\de.obj\" \\\n+\t\".\\cord\\Release\\de_win.obj\" \\\n+\t\".\\cord\\Release\\de_win.res\" \\\n+\t\".\\Release\\gc.lib\"\n+\n+\".\\Release\\de.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+# PROP BASE Use_MFC 0\n+# PROP BASE Use_Debug_Libraries 1\n+# PROP BASE Output_Dir \"cord\\Debug\"\n+# PROP BASE Intermediate_Dir \"cord\\Debug\"\n+# PROP BASE Target_Dir \"cord\"\n+# PROP Use_MFC 0\n+# PROP Use_Debug_Libraries 1\n+# PROP Output_Dir \"cord\\Debug\"\n+# PROP Intermediate_Dir \"cord\\Debug\"\n+# PROP Target_Dir \"cord\"\n+OUTDIR=.\\cord\\Debug\n+INTDIR=.\\cord\\Debug\n+\n+ALL : \"gc - Win32 Debug\" \".\\Debug\\de.exe\"\n+\n+CLEAN : \n+\t-@erase \".\\cord\\Debug\\cordbscs.obj\"\n+\t-@erase \".\\cord\\Debug\\cordxtra.obj\"\n+\t-@erase \".\\cord\\Debug\\de.obj\"\n+\t-@erase \".\\cord\\Debug\\de.pdb\"\n+\t-@erase \".\\cord\\Debug\\de_win.obj\"\n+\t-@erase \".\\cord\\Debug\\de_win.res\"\n+\t-@erase \".\\cord\\Debug\\vc40.idb\"\n+\t-@erase \".\\cord\\Debug\\vc40.pdb\"\n+\t-@erase \".\\Debug\\de.exe\"\n+\t-@erase \".\\Debug\\de.ilk\"\n+\n+\"$(OUTDIR)\" :\n+    if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n+\n+CPP=cl.exe\n+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D\\\n+ \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX\\\n+ /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n+CPP_OBJS=.\\cord\\Debug/\n+CPP_SBRS=.\\.\n+\n+.c{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_OBJS)}.obj:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.c{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cpp{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+.cxx{$(CPP_SBRS)}.sbr:\n+   $(CPP) $(CPP_PROJ) $<  \n+\n+MTL=mktyplib.exe\n+# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n+# ADD MTL /nologo /D \"_DEBUG\" /win32\n+MTL_PROJ=/nologo /D \"_DEBUG\" /win32 \n+RSC=rc.exe\n+# ADD BASE RSC /l 0x809 /d \"_DEBUG\"\n+# ADD RSC /l 0x809 /d \"_DEBUG\"\n+RSC_PROJ=/l 0x809 /fo\"$(INTDIR)/de_win.res\" /d \"_DEBUG\" \n+BSC32=bscmake.exe\n+# ADD BASE BSC32 /nologo\n+# ADD BSC32 /nologo\n+BSC32_FLAGS=/nologo /o\"$(OUTDIR)/cord.bsc\" \n+BSC32_SBRS= \\\n+\t\n+LINK32=link.exe\n+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386\n+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /out:\"Debug/de.exe\"\n+LINK32_FLAGS=kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib\\\n+ advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib\\\n+ odbccp32.lib /nologo /subsystem:windows /incremental:yes\\\n+ /pdb:\"$(OUTDIR)/de.pdb\" /debug /machine:I386 /out:\"Debug/de.exe\" \n+LINK32_OBJS= \\\n+\t\".\\cord\\Debug\\cordbscs.obj\" \\\n+\t\".\\cord\\Debug\\cordxtra.obj\" \\\n+\t\".\\cord\\Debug\\de.obj\" \\\n+\t\".\\cord\\Debug\\de_win.obj\" \\\n+\t\".\\cord\\Debug\\de_win.res\" \\\n+\t\".\\Debug\\gc.lib\"\n+\n+\".\\Debug\\de.exe\" : \"$(OUTDIR)\" $(DEF_FILE) $(LINK32_OBJS)\n+    $(LINK32) @<<\n+  $(LINK32_FLAGS) $(LINK32_OBJS)\n+<<\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Target\n+\n+# Name \"gc - Win32 Release\"\n+# Name \"gc - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\reclaim.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\reclaim.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Release\\reclaim.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\reclaim.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Debug\\reclaim.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\os_dep.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_OS_DE=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OS_DE=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\".\\vd\\PCR_VD.h\"\\\n+\t\n+\n+\".\\Release\\os_dep.obj\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\".\\Release\\os_dep.sbr\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_OS_DE=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OS_DE=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\".\\vd\\PCR_VD.h\"\\\n+\t\n+\n+\".\\Debug\\os_dep.obj\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\".\\Debug\\os_dep.sbr\" : $(SOURCE) $(DEP_CPP_OS_DE) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\misc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MISC_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MISC_=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\misc.obj\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\".\\Release\\misc.sbr\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MISC_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MISC_=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\misc.obj\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\".\\Debug\\misc.sbr\" : $(SOURCE) $(DEP_CPP_MISC_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mark_rts.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MARK_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mark_rts.obj\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\".\\Release\\mark_rts.sbr\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MARK_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mark_rts.obj\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\".\\Debug\\mark_rts.sbr\" : $(SOURCE) $(DEP_CPP_MARK_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mach_dep.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MACH_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MACH_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mach_dep.obj\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\".\\Release\\mach_dep.sbr\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MACH_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MACH_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mach_dep.obj\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\".\\Debug\\mach_dep.sbr\" : $(SOURCE) $(DEP_CPP_MACH_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\headers.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_HEADE=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_HEADE=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\headers.obj\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\".\\Release\\headers.sbr\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_HEADE=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_HEADE=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\headers.obj\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\".\\Debug\\headers.sbr\" : $(SOURCE) $(DEP_CPP_HEADE) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\alloc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_ALLOC=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLOC=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\alloc.obj\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\".\\Release\\alloc.sbr\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_ALLOC=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLOC=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\alloc.obj\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\".\\Debug\\alloc.sbr\" : $(SOURCE) $(DEP_CPP_ALLOC) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\allchblk.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_ALLCH=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLCH=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\allchblk.obj\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\".\\Release\\allchblk.sbr\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_ALLCH=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_ALLCH=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\allchblk.obj\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\".\\Debug\\allchblk.sbr\" : $(SOURCE) $(DEP_CPP_ALLCH) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\stubborn.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_STUBB=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_STUBB=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\stubborn.obj\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\".\\Release\\stubborn.sbr\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_STUBB=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_STUBB=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\stubborn.obj\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\".\\Debug\\stubborn.sbr\" : $(SOURCE) $(DEP_CPP_STUBB) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\obj_map.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_OBJ_M=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OBJ_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\obj_map.obj\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\".\\Release\\obj_map.sbr\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_OBJ_M=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_OBJ_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\obj_map.obj\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\".\\Debug\\obj_map.sbr\" : $(SOURCE) $(DEP_CPP_OBJ_M) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\new_hblk.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_NEW_H=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_NEW_H=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\new_hblk.obj\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\".\\Release\\new_hblk.sbr\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_NEW_H=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_NEW_H=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\new_hblk.obj\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\".\\Debug\\new_hblk.sbr\" : $(SOURCE) $(DEP_CPP_NEW_H) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mark.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MARK_C=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mark.obj\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\".\\Release\\mark.sbr\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MARK_C=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MARK_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mark.obj\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\".\\Debug\\mark.sbr\" : $(SOURCE) $(DEP_CPP_MARK_C) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\malloc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MALLO=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLO=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\malloc.obj\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\".\\Release\\malloc.sbr\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MALLO=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLO=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\malloc.obj\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\".\\Debug\\malloc.sbr\" : $(SOURCE) $(DEP_CPP_MALLO) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\mallocx.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_MALLX=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLX=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\mallocx.obj\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\".\\Release\\mallocx.sbr\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_MALLX=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_MALLX=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\mallocx.obj\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\".\\Debug\\mallocx.sbr\" : $(SOURCE) $(DEP_CPP_MALLX) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\finalize.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_FINAL=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_FINAL=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\finalize.obj\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\".\\Release\\finalize.sbr\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_FINAL=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_FINAL=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\finalize.obj\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\".\\Debug\\finalize.sbr\" : $(SOURCE) $(DEP_CPP_FINAL) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\dbg_mlc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_DBG_M=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DBG_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\dbg_mlc.obj\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\".\\Release\\dbg_mlc.sbr\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_DBG_M=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DBG_M=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\dbg_mlc.obj\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\".\\Debug\\dbg_mlc.sbr\" : $(SOURCE) $(DEP_CPP_DBG_M) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\blacklst.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_BLACK=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_BLACK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\blacklst.obj\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\".\\Release\\blacklst.sbr\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_BLACK=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_BLACK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\blacklst.obj\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\".\\Debug\\blacklst.sbr\" : $(SOURCE) $(DEP_CPP_BLACK) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\typd_mlc.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_TYPD_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t\".\\gc_typed.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_TYPD_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\typd_mlc.obj\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\".\\Release\\typd_mlc.sbr\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_TYPD_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t\".\\gc_typed.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_TYPD_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\typd_mlc.obj\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\".\\Debug\\typd_mlc.sbr\" : $(SOURCE) $(DEP_CPP_TYPD_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\ptr_chck.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_PTR_C=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_PTR_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\ptr_chck.obj\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\".\\Release\\ptr_chck.sbr\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_PTR_C=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_mark.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_PTR_C=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\ptr_chck.obj\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\".\\Debug\\ptr_chck.sbr\" : $(SOURCE) $(DEP_CPP_PTR_C) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\dyn_load.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_DYN_L=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DYN_L=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\dyn_load.obj\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\".\\Release\\dyn_load.sbr\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_DYN_L=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_DYN_L=\\\n+\t\".\\il\\PCR_IL.h\"\\\n+\t\".\\mm\\PCR_MM.h\"\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\dyn_load.obj\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\".\\Debug\\dyn_load.sbr\" : $(SOURCE) $(DEP_CPP_DYN_L) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\win32_threads.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_WIN32=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_WIN32=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\win32_threads.obj\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\".\\Release\\win32_threads.sbr\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_WIN32=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_WIN32=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\win32_threads.obj\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\".\\Debug\\win32_threads.sbr\" : $(SOURCE) $(DEP_CPP_WIN32) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\checksums.c\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_CHECK=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_CHECK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\checksums.obj\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\".\\Release\\checksums.sbr\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_CHECK=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_CHECK=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\checksums.obj\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\".\\Debug\\checksums.sbr\" : $(SOURCE) $(DEP_CPP_CHECK) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+# End Target\n+################################################################################\n+# Begin Target\n+\n+# Name \"gctest - Win32 Release\"\n+# Name \"gctest - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Project Dependency\n+\n+# Project_Dep_Name \"gc\"\n+\n+!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+\"gc - Win32 Release\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Release\" \n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+\"gc - Win32 Debug\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Debug\" \n+\n+!ENDIF \n+\n+# End Project Dependency\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\test.c\n+DEP_CPP_TEST_=\\\n+\t\".\\config.h\"\\\n+\t\".\\gc.h\"\\\n+\t\".\\gc_hdrs.h\"\\\n+\t\".\\gc_priv.h\"\\\n+\t\".\\gc_typed.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_TEST_=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"gctest - Win32 Release\"\n+\n+\n+\".\\gctest\\Release\\test.obj\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gctest - Win32 Debug\"\n+\n+\n+\".\\gctest\\Debug\\test.obj\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n+\n+\".\\gctest\\Debug\\test.sbr\" : $(SOURCE) $(DEP_CPP_TEST_) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+# End Target\n+################################################################################\n+# Begin Target\n+\n+# Name \"cord - Win32 Release\"\n+# Name \"cord - Win32 Debug\"\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+!ENDIF \n+\n+################################################################################\n+# Begin Project Dependency\n+\n+# Project_Dep_Name \"gc\"\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\"gc - Win32 Release\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Release\" \n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\"gc - Win32 Debug\" : \n+   $(MAKE) /$(MAKEFLAGS) /F \".\\gc.mak\" CFG=\"gc - Win32 Debug\" \n+\n+!ENDIF \n+\n+# End Project Dependency\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\de_win.c\n+DEP_CPP_DE_WI=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\de_cmds.h\"\\\n+\t\".\\cord\\de_win.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_DE_WI=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\de_win.obj\" : $(SOURCE) $(DEP_CPP_DE_WI) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\de_win.obj\" : $(SOURCE) $(DEP_CPP_DE_WI) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\de.c\n+DEP_CPP_DE_C2e=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\de_cmds.h\"\\\n+\t\".\\cord\\de_win.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_DE_C2e=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\de.obj\" : $(SOURCE) $(DEP_CPP_DE_C2e) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\de.obj\" : $(SOURCE) $(DEP_CPP_DE_C2e) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\cordxtra.c\n+DEP_CPP_CORDX=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\ec.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_CORDX=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\cordxtra.obj\" : $(SOURCE) $(DEP_CPP_CORDX) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\cordxtra.obj\" : $(SOURCE) $(DEP_CPP_CORDX) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\cordbscs.c\n+DEP_CPP_CORDB=\\\n+\t\".\\cord\\cord.h\"\\\n+\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\n+NODEP_CPP_CORDB=\\\n+\t\".\\cord\\gc.h\"\\\n+\t\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\cordbscs.obj\" : $(SOURCE) $(DEP_CPP_CORDB) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\cordbscs.obj\" : $(SOURCE) $(DEP_CPP_CORDB) \"$(INTDIR)\"\n+   $(CPP) $(CPP_PROJ) $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n+SOURCE=.\\cord\\de_win.RC\n+\n+!IF  \"$(CFG)\" == \"cord - Win32 Release\"\n+\n+\n+\".\\cord\\Release\\de_win.res\" : $(SOURCE) \"$(INTDIR)\"\n+   $(RSC) /l 0x809 /fo\"$(INTDIR)/de_win.res\" /i \"cord\" /d \"NDEBUG\" $(SOURCE)\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"cord - Win32 Debug\"\n+\n+\n+\".\\cord\\Debug\\de_win.res\" : $(SOURCE) \"$(INTDIR)\"\n+   $(RSC) /l 0x809 /fo\"$(INTDIR)/de_win.res\" /i \"cord\" /d \"_DEBUG\" $(SOURCE)\n+\n+\n+!ENDIF \n+\n+# End Source File\n+# End Target\n+# End Project\n+################################################################################"}, {"sha": "5409e7065502e877616da445048632efbb23be78", "filename": "boehm-gc/gc.man", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc.man", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc.man", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.man?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,80 @@\n+.TH GC_MALLOC 1L \"12 February 1996\"\n+.SH NAME\n+GC_malloc, GC_malloc_atomic, GC_free, GC_realloc, GC_enable_incremental, GC_register_finalizer, GC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page, GC_set_warn_proc \\- Garbage collecting malloc replacement\n+.SH SYNOPSIS\n+#include \"gc.h\"\n+.br\n+# define malloc(n) GC_malloc(n)\n+.br\n+... malloc(...) ...\n+.br\n+.sp\n+cc ... gc.a\n+.LP\n+.SH DESCRIPTION\n+.I GC_malloc\n+and\n+.I GC_free\n+are plug-in replacements for standard malloc and free.  However,\n+.I\n+GC_malloc\n+will attempt to reclaim inaccessible space automatically by invoking a conservative garbage collector at appropriate points.  The collector traverses all data structures accessible by following pointers from the machines registers, stack(s), data, and bss segments.  Inaccessible structures will be reclaimed.  A machine word is considered to be a valid pointer if it is an address inside an object allocated by\n+.I\n+GC_malloc\n+or friends.\n+.LP\n+See the documentation in the include file gc_cpp.h for an alternate, C++ specific interface to the garbage collector.\n+.LP\n+Unlike the standard implementations of malloc,\n+.I\n+GC_malloc\n+clears the newly allocated storage.\n+.I\n+GC_malloc_atomic\n+does not.  Furthermore, it informs the collector that the resulting object will never contain any pointers, and should therefore not be scanned by the collector.\n+.LP\n+.I\n+GC_free\n+can be used to deallocate objects, but its use is optional, and generally discouraged.\n+.I\n+GC_realloc\n+has the standard realloc semantics.  It preserves pointer-free-ness.\n+.I\n+GC_register_finalizer\n+allows for registration of functions that are invoked when an object becomes inaccessible.\n+.LP\n+The garbage collector tries to avoid allocating memory at locations that already appear to be referenced before allocation.  (Such apparent ``pointers'' are usually large integers and the like that just happen to look like an address.)  This may make it hard to allocate very large objects.  An attempt to do so may generate a warning.\n+.LP\n+.I\n+GC_malloc_ignore_off_page\n+and\n+.I\n+GC_malloc_atomic_ignore_off_page\n+inform the collector that the client code will always maintain a pointer to near the beginning of the object (within the first 512 bytes), and that pointers beyond that can be ignored by the collector.  This makes it much easier for the collector to place large objects.  These are recommended for large object allocation.  (Objects expected to be larger than about 100KBytes should be allocated this way.)\n+.LP\n+It is also possible to use the collector to find storage leaks in programs destined to be run with standard malloc/free.  The collector can be compiled for thread-safe operation.  Unlike standard malloc, it is safe to call malloc after a previous malloc call was interrupted by a signal, provided the original malloc call is not resumed.\n+.LP\n+The collector may, on rare occasion produce warning messages.  On UNIX machines these appear on stderr.  Warning messages can be filtered, redirected, or ignored with\n+.I\n+GC_set_warn_proc.\n+This is recommended for production code.  See gc.h for details.\n+.LP\n+Debugging versions of many of the above routines are provided as macros.  Their names are identical to the above, but consist of all capital letters.  If GC_DEBUG is defined before gc.h is included, these routines do additional checking, and allow the leak detecting version of the collector to produce slightly more useful output.  Without GC_DEBUG defined, they behave exactly like the lower-case versions.\n+.LP\n+On some machines, collection will be performed incrementally after a call to\n+.I\n+GC_enable_incremental.\n+This may temporarily write protect pages in the heap.  See the README file for more information on how this interacts with system calls that write to the heap.\n+.LP\n+Other facilities not discussed here include limited facilities to support incremental collection on machines without appropriate VM support, provisions for providing more explicit object layout information to the garbage collector, more direct support for ``weak'' pointers, support for ``abortable'' garbage collections during idle time, etc.\n+.LP\n+.SH \"SEE ALSO\"\n+The README and gc.h files in the distribution.  More detailed definitions of the functions exported by the collector are given there.  (The above list is not complete.)\n+.LP\n+Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n+\\fISoftware Practice & Experience\\fP, September 1988, pp. 807-820.\n+.LP\n+The malloc(3) man page.\n+.LP\n+.SH AUTHOR\n+Hans-J. Boehm (boehm@parc.xerox.com).  Some of the code was written by others, most notably Alan Demers."}, {"sha": "1d912db2f0b0048df400dead3fb9a7f8b6cc7abe", "filename": "boehm-gc/gc_alloc.h", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_alloc.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+//\n+// This is a C++ header file that is intended to replace the SGI STL\n+// alloc.h.\n+//\n+// This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n+// and -DALL_INTERIOR_POINTERS.  We also recommend\n+// -DREDIRECT_MALLOC=GC_uncollectable_malloc.\n+//\n+// Some of this could be faster in the explicit deallocation case.  In particular,\n+// we spend too much time clearing objects on the free lists.  That could be avoided.\n+//\n+// This uses template classes with static members, and hence does not work\n+// with g++ 2.7.2 and earlier.\n+//\n+\n+#include \"gc.h\"\n+\n+#ifndef GC_ALLOC_H\n+\n+#define GC_ALLOC_H\n+#define __ALLOC_H\t// Prevent inclusion of the default version.  Ugly.\n+#define __SGI_STL_ALLOC_H\n+#define __SGI_STL_INTERNAL_ALLOC_H\n+\n+#ifndef __ALLOC\n+#   define __ALLOC alloc\n+#endif\n+\n+#include <stddef.h>\n+#include <string.h>\n+\n+// The following is just replicated from the conventional SGI alloc.h:\n+\n+template<class T, class alloc>\n+class simple_alloc {\n+\n+public:\n+    static T *allocate(size_t n)\n+                { return 0 == n? 0 : (T*) alloc::allocate(n * sizeof (T)); }\n+    static T *allocate(void)\n+                { return (T*) alloc::allocate(sizeof (T)); }\n+    static void deallocate(T *p, size_t n)\n+                { if (0 != n) alloc::deallocate(p, n * sizeof (T)); }\n+    static void deallocate(T *p)\n+                { alloc::deallocate(p, sizeof (T)); }\n+};\n+\n+#include \"gc.h\"\n+\n+// The following need to match collector data structures.\n+// We can't include gc_priv.h, since that pulls in way too much stuff.\n+// This should eventually be factored out into another include file.\n+\n+extern \"C\" {\n+    extern void ** const GC_objfreelist_ptr;\n+    extern void ** const GC_aobjfreelist_ptr;\n+    extern void ** const GC_uobjfreelist_ptr;\n+    extern void ** const GC_auobjfreelist_ptr;\n+\n+    extern void GC_incr_words_allocd(size_t words);\n+    extern void GC_incr_mem_freed(size_t words);\n+\n+    extern char * GC_generic_malloc_words_small(size_t word, int kind);\n+}\n+\n+// Object kinds; must match PTRFREE, NORMAL, UNCOLLECTABLE, and\n+// AUNCOLLECTABLE in gc_priv.h.\n+\n+enum { GC_PTRFREE = 0, GC_NORMAL = 1, GC_UNCOLLECTABLE = 2,\n+       GC_AUNCOLLECTABLE = 3 };\n+\n+enum { GC_max_fast_bytes = 255 };\n+\n+enum { GC_bytes_per_word = sizeof(char *) };\n+\n+enum { GC_byte_alignment = 8 };\n+\n+enum { GC_word_alignment = GC_byte_alignment/GC_bytes_per_word };\n+\n+inline void * &GC_obj_link(void * p)\n+{   return *(void **)p;  }\n+\n+// Compute a number of words >= n+1 bytes.\n+// The +1 allows for pointers one past the end.\n+inline size_t GC_round_up(size_t n)\n+{\n+    return ((n + GC_byte_alignment)/GC_byte_alignment)*GC_word_alignment;\n+}\n+\n+// The same but don't allow for extra byte.\n+inline size_t GC_round_up_uncollectable(size_t n)\n+{\n+    return ((n + GC_byte_alignment - 1)/GC_byte_alignment)*GC_word_alignment;\n+}\n+\n+template <int dummy>\n+class GC_aux_template {\n+public:\n+  // File local count of allocated words.  Occasionally this is\n+  // added into the global count.  A separate count is necessary since the\n+  // real one must be updated with a procedure call.\n+  static size_t GC_words_recently_allocd;\n+\n+  // Same for uncollectable mmory.  Not yet reflected in either\n+  // GC_words_recently_allocd or GC_non_gc_bytes.\n+  static size_t GC_uncollectable_words_recently_allocd;\n+\n+  // Similar counter for explicitly deallocated memory.\n+  static size_t GC_mem_recently_freed;\n+\n+  // Again for uncollectable memory.\n+  static size_t GC_uncollectable_mem_recently_freed;\n+\n+  static void * GC_out_of_line_malloc(size_t nwords, int kind);\n+};\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_words_recently_allocd = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_uncollectable_words_recently_allocd = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_mem_recently_freed = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_uncollectable_mem_recently_freed = 0;\n+\n+template <int dummy>\n+void * GC_aux_template<dummy>::GC_out_of_line_malloc(size_t nwords, int kind)\n+{\n+    GC_words_recently_allocd += GC_uncollectable_words_recently_allocd;\n+    GC_non_gc_bytes +=\n+                GC_bytes_per_word * GC_uncollectable_words_recently_allocd;\n+    GC_uncollectable_words_recently_allocd = 0;\n+\n+    GC_mem_recently_freed += GC_uncollectable_mem_recently_freed;\n+    GC_non_gc_bytes -= \n+                GC_bytes_per_word * GC_uncollectable_mem_recently_freed;\n+    GC_uncollectable_mem_recently_freed = 0;\n+\n+    GC_incr_words_allocd(GC_words_recently_allocd);\n+    GC_words_recently_allocd = 0;\n+\n+    GC_incr_mem_freed(GC_mem_recently_freed);\n+    GC_mem_recently_freed = 0;\n+\n+    return GC_generic_malloc_words_small(nwords, kind);\n+}\n+\n+typedef GC_aux_template<0> GC_aux;\n+\n+// A fast, single-threaded, garbage-collected allocator\n+// We assume the first word will be immediately overwritten.\n+// In this version, deallocation is not a noop, and explicit\n+// deallocation is likely to help performance.\n+template <int dummy>\n+class single_client_gc_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc(n);\n+\t    flh = GC_objfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_NORMAL);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic(n);\n+\t    flh = GC_aobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_PTRFREE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+\tstatic void deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes)  {\n+\t\tGC_free(p);\n+\t    } else {\n+\t        flh = GC_objfreelist_ptr + nwords;\n+\t        GC_obj_link(p) = *flh;\n+\t\tmemset((char *)p + GC_bytes_per_word, 0,\n+\t\t       GC_bytes_per_word * (nwords - 1));\n+\t        *flh = p;\n+\t        GC_aux::GC_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+\tstatic void ptr_free_deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes) {\n+\t\tGC_free(p);\n+\t    } else {\n+\t    \tflh = GC_aobjfreelist_ptr + nwords;\n+\t    \tGC_obj_link(p) = *flh;\n+\t    \t*flh = p;\n+\t    \tGC_aux::GC_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+};\n+\n+typedef single_client_gc_alloc_template<0> single_client_gc_alloc;\n+\n+// Once more, for uncollectable objects.\n+template <int dummy>\n+class single_client_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up_uncollectable(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_uncollectable(n);\n+\t    flh = GC_uobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_UNCOLLECTABLE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up_uncollectable(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic_uncollectable(n);\n+\t    flh = GC_auobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_AUNCOLLECTABLE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+\tstatic void deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up_uncollectable(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes)  {\n+\t\tGC_free(p);\n+\t    } else {\n+\t        flh = GC_uobjfreelist_ptr + nwords;\n+\t        GC_obj_link(p) = *flh;\n+\t        *flh = p;\n+\t        GC_aux::GC_uncollectable_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+\tstatic void ptr_free_deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up_uncollectable(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes) {\n+\t\tGC_free(p);\n+\t    } else {\n+\t    \tflh = GC_auobjfreelist_ptr + nwords;\n+\t    \tGC_obj_link(p) = *flh;\n+\t    \t*flh = p;\n+\t    \tGC_aux::GC_uncollectable_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+};\n+\n+typedef single_client_alloc_template<0> single_client_alloc;\n+\n+template < int dummy >\n+class gc_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n) { return GC_malloc(n); }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+\t\t{ return GC_malloc_atomic(n); }\n+\tstatic void deallocate(void *, size_t) { }\n+\tstatic void ptr_free_deallocate(void *, size_t) { }\n+};\n+\n+typedef gc_alloc_template < 0 > gc_alloc;\n+\n+template < int dummy >\n+class alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n) { return GC_malloc_uncollectable(n); }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+\t\t{ return GC_malloc_atomic_uncollectable(n); }\n+\tstatic void deallocate(void *p, size_t) { GC_free(p); }\n+\tstatic void ptr_free_deallocate(void *p, size_t) { GC_free(p); }\n+};\n+\n+typedef alloc_template < 0 > alloc;\n+\n+#ifdef _SGI_SOURCE\n+\n+// We want to specialize simple_alloc so that it does the right thing\n+// for all pointerfree types.  At the moment there is no portable way to\n+// even approximate that.  The following approximation should work for\n+// SGI compilers, and perhaps some others.\n+\n+# define __GC_SPECIALIZE(T,alloc) \\\n+class simple_alloc<T, alloc> { \\\n+public: \\\n+    static T *allocate(size_t n) \\\n+\t{ return 0 == n? 0 : \\\n+\t\t\t (T*) alloc::ptr_free_allocate(n * sizeof (T)); } \\\n+    static T *allocate(void) \\\n+\t{ return (T*) alloc::ptr_free_allocate(sizeof (T)); } \\\n+    static void deallocate(T *p, size_t n) \\\n+\t{ if (0 != n) alloc::ptr_free_deallocate(p, n * sizeof (T)); } \\\n+    static void deallocate(T *p) \\\n+\t{ alloc::ptr_free_deallocate(p, sizeof (T)); } \\\n+};\n+\n+__GC_SPECIALIZE(char, gc_alloc)\n+__GC_SPECIALIZE(int, gc_alloc)\n+__GC_SPECIALIZE(unsigned, gc_alloc)\n+__GC_SPECIALIZE(float, gc_alloc)\n+__GC_SPECIALIZE(double, gc_alloc)\n+\n+__GC_SPECIALIZE(char, alloc)\n+__GC_SPECIALIZE(int, alloc)\n+__GC_SPECIALIZE(unsigned, alloc)\n+__GC_SPECIALIZE(float, alloc)\n+__GC_SPECIALIZE(double, alloc)\n+\n+__GC_SPECIALIZE(char, single_client_gc_alloc)\n+__GC_SPECIALIZE(int, single_client_gc_alloc)\n+__GC_SPECIALIZE(unsigned, single_client_gc_alloc)\n+__GC_SPECIALIZE(float, single_client_gc_alloc)\n+__GC_SPECIALIZE(double, single_client_gc_alloc)\n+\n+__GC_SPECIALIZE(char, single_client_alloc)\n+__GC_SPECIALIZE(int, single_client_alloc)\n+__GC_SPECIALIZE(unsigned, single_client_alloc)\n+__GC_SPECIALIZE(float, single_client_alloc)\n+__GC_SPECIALIZE(double, single_client_alloc)\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+???copy stuff from stl_alloc.h or remove it to a different file ???\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+#endif /* _SGI_SOURCE */\n+\n+#endif /* GC_ALLOC_H */"}, {"sha": "a766a01a328ce168f14db6d04f90c27e4f27adb5", "filename": "boehm-gc/gc_cpp.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cc?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,46 @@\n+/*************************************************************************\n+Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ \n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ \n+    Last modified on Sat Nov 19 19:31:14 PST 1994 by ellis\n+                  on Sat Jun  8 15:10:00 PST 1994 by boehm\n+\n+Permission is hereby granted to copy this code for any purpose,\n+provided the above notices are retained on all copies.\n+\n+This implementation module for gc_c++.h provides an implementation of\n+the global operators \"new\" and \"delete\" that calls the Boehm\n+allocator.  All objects allocated by this implementation will be\n+non-collectable but part of the root set of the collector.\n+\n+You should ensure (using implementation-dependent techniques) that the\n+linker finds this module before the library that defines the default\n+built-in \"new\" and \"delete\".\n+\n+Authors: John R. Ellis and Jesse Hull\n+\n+**************************************************************************/\n+/* Boehm, December 20, 1994 7:26 pm PST */\n+\n+#include \"gc_cpp.h\"\n+\n+void* operator new( size_t size ) {\n+    return GC_MALLOC_UNCOLLECTABLE( size );}\n+  \n+void operator delete( void* obj ) {\n+    GC_FREE( obj );}\n+  \n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+void* operator new[]( size_t size ) {\n+    return GC_MALLOC_UNCOLLECTABLE( size );}\n+  \n+void operator delete[]( void* obj ) {\n+    GC_FREE( obj );}\n+\n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+"}, {"sha": "e2f456fb526a746b9405db0bb0b119aab99a414a", "filename": "boehm-gc/gc_cpp.h", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,287 @@\n+#ifndef GC_CPP_H\n+#define GC_CPP_H\n+/****************************************************************************\n+Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ \n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ \n+Permission is hereby granted to use or copy this program for any\n+purpose, provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is\n+granted, provided the above notices are retained, and a notice that\n+the code was modified is included with the above copyright notice.\n+****************************************************************************\n+\n+C++ Interface to the Boehm Collector\n+\n+    John R. Ellis and Jesse Hull \n+    Last modified on Mon Jul 24 15:43:42 PDT 1995 by ellis\n+\n+This interface provides access to the Boehm collector.  It provides\n+basic facilities similar to those described in \"Safe, Efficient\n+Garbage Collection for C++\", by John R. Elis and David L. Detlefs\n+(ftp.parc.xerox.com:/pub/ellis/gc).\n+\n+All heap-allocated objects are either \"collectable\" or\n+\"uncollectable\".  Programs must explicitly delete uncollectable\n+objects, whereas the garbage collector will automatically delete\n+collectable objects when it discovers them to be inaccessible.\n+Collectable objects may freely point at uncollectable objects and vice\n+versa.\n+\n+Objects allocated with the built-in \"::operator new\" are uncollectable.\n+\n+Objects derived from class \"gc\" are collectable.  For example:\n+\n+    class A: public gc {...};\n+    A* a = new A;       // a is collectable. \n+\n+Collectable instances of non-class types can be allocated using the GC\n+placement:\n+\n+    typedef int A[ 10 ];\n+    A* a = new (GC) A;\n+\n+Uncollectable instances of classes derived from \"gc\" can be allocated\n+using the NoGC placement:\n+\n+    class A: public gc {...};\n+    A* a = new (NoGC) A;   // a is uncollectable.\n+\n+Both uncollectable and collectable objects can be explicitly deleted\n+with \"delete\", which invokes an object's destructors and frees its\n+storage immediately.\n+\n+A collectable object may have a clean-up function, which will be\n+invoked when the collector discovers the object to be inaccessible.\n+An object derived from \"gc_cleanup\" or containing a member derived\n+from \"gc_cleanup\" has a default clean-up function that invokes the\n+object's destructors.  Explicit clean-up functions may be specified as\n+an additional placement argument:\n+\n+    A* a = ::new (GC, MyCleanup) A;\n+\n+An object is considered \"accessible\" by the collector if it can be\n+reached by a path of pointers from static variables, automatic\n+variables of active functions, or from some object with clean-up\n+enabled; pointers from an object to itself are ignored.\n+\n+Thus, if objects A and B both have clean-up functions, and A points at\n+B, B is considered accessible.  After A's clean-up is invoked and its\n+storage released, B will then become inaccessible and will have its\n+clean-up invoked.  If A points at B and B points to A, forming a\n+cycle, then that's considered a storage leak, and neither will be\n+collectable.  See the interface gc.h for low-level facilities for\n+handling such cycles of objects with clean-up.\n+\n+The collector cannot guarrantee that it will find all inaccessible\n+objects.  In practice, it finds almost all of them.\n+\n+\n+Cautions:\n+\n+1. Be sure the collector has been augmented with \"make c++\".\n+\n+2.  If your compiler supports the new \"operator new[]\" syntax, then\n+add -DOPERATOR_NEW_ARRAY to the Makefile.\n+\n+If your compiler doesn't support \"operator new[]\", beware that an\n+array of type T, where T is derived from \"gc\", may or may not be\n+allocated as a collectable object (it depends on the compiler).  Use\n+the explicit GC placement to make the array collectable.  For example:\n+\n+    class A: public gc {...};\n+    A* a1 = new A[ 10 ];        // collectable or uncollectable?\n+    A* a2 = new (GC) A[ 10 ];   // collectable\n+\n+3. The destructors of collectable arrays of objects derived from\n+\"gc_cleanup\" will not be invoked properly.  For example:\n+\n+    class A: public gc_cleanup {...};\n+    A* a = new (GC) A[ 10 ];    // destructors not invoked correctly\n+\n+Typically, only the destructor for the first element of the array will\n+be invoked when the array is garbage-collected.  To get all the\n+destructors of any array executed, you must supply an explicit\n+clean-up function:\n+\n+    A* a = new (GC, MyCleanUp) A[ 10 ];\n+\n+(Implementing clean-up of arrays correctly, portably, and in a way\n+that preserves the correct exception semantics requires a language\n+extension, e.g. the \"gc\" keyword.)\n+\n+4. Compiler bugs:\n+\n+* Solaris 2's CC (SC3.0) doesn't implement t->~T() correctly, so the\n+destructors of classes derived from gc_cleanup won't be invoked.\n+You'll have to explicitly register a clean-up function with\n+new-placement syntax.\n+\n+* Evidently cfront 3.0 does not allow destructors to be explicitly\n+invoked using the ANSI-conforming syntax t->~T().  If you're using\n+cfront 3.0, you'll have to comment out the class gc_cleanup, which\n+uses explicit invocation.\n+\n+****************************************************************************/\n+\n+#include \"gc.h\"\n+\n+#ifndef THINK_CPLUS\n+#define _cdecl\n+#endif\n+\n+#if ! defined( OPERATOR_NEW_ARRAY ) \\\n+    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6))\n+#   define OPERATOR_NEW_ARRAY\n+#endif\n+\n+enum GCPlacement {GC, NoGC, PointerFreeGC};\n+\n+class gc {public:\n+    inline void* operator new( size_t size );\n+    inline void* operator new( size_t size, GCPlacement gcp );\n+    inline void operator delete( void* obj );\n+\n+#ifdef OPERATOR_NEW_ARRAY\n+    inline void* operator new[]( size_t size );\n+    inline void* operator new[]( size_t size, GCPlacement gcp );\n+    inline void operator delete[]( void* obj );\n+#endif /* OPERATOR_NEW_ARRAY */\n+    };    \n+    /*\n+    Instances of classes derived from \"gc\" will be allocated in the \n+    collected heap by default, unless an explicit NoGC placement is\n+    specified. */\n+\n+class gc_cleanup: virtual public gc {public:\n+    inline gc_cleanup();\n+    inline virtual ~gc_cleanup();\n+private:\n+    inline static void _cdecl cleanup( void* obj, void* clientData );};\n+    /*\n+    Instances of classes derived from \"gc_cleanup\" will be allocated\n+    in the collected heap by default.  When the collector discovers an\n+    inaccessible object derived from \"gc_cleanup\" or containing a\n+    member derived from \"gc_cleanup\", its destructors will be\n+    invoked. */\n+\n+extern \"C\" {typedef void (*GCCleanUpFunc)( void* obj, void* clientData );}\n+\n+inline void* operator new( \n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup = 0,\n+    void* clientData = 0 );\n+    /*\n+    Allocates a collectable or uncollected object, according to the\n+    value of \"gcp\".\n+\n+    For collectable objects, if \"cleanup\" is non-null, then when the\n+    allocated object \"obj\" becomes inaccessible, the collector will\n+    invoke the function \"cleanup( obj, clientData )\" but will not\n+    invoke the object's destructors.  It is an error to explicitly\n+    delete an object allocated with a non-null \"cleanup\".\n+\n+    It is an error to specify a non-null \"cleanup\" with NoGC or for\n+    classes derived from \"gc_cleanup\" or containing members derived\n+    from \"gc_cleanup\". */\n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+inline void* operator new[](\n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup = 0,\n+    void* clientData = 0 );\n+    /*\n+    The operator new for arrays, identical to the above. */\n+\n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+/****************************************************************************\n+\n+Inline implementation\n+\n+****************************************************************************/\n+\n+inline void* gc::operator new( size_t size ) {\n+    return GC_MALLOC( size );}\n+    \n+inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n+    if (gcp == GC) \n+        return GC_MALLOC( size );\n+    else\n+        return GC_MALLOC_UNCOLLECTABLE( size );}\n+\n+inline void gc::operator delete( void* obj ) {\n+    GC_FREE( obj );}\n+    \n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+inline void* gc::operator new[]( size_t size ) {\n+    return gc::operator new( size );}\n+    \n+inline void* gc::operator new[]( size_t size, GCPlacement gcp ) {\n+    return gc::operator new( size, gcp );}\n+\n+inline void gc::operator delete[]( void* obj ) {\n+    gc::operator delete( obj );}\n+    \n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+\n+inline gc_cleanup::~gc_cleanup() {\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( this, 0, 0, 0, 0 );}\n+\n+inline void gc_cleanup::cleanup( void* obj, void* displ ) {\n+    ((gc_cleanup*) ((char*) obj + (ptrdiff_t) displ))->~gc_cleanup();}\n+\n+inline gc_cleanup::gc_cleanup() {\n+    GC_finalization_proc oldProc;\n+    void* oldData;\n+    void* base = GC_base( (void *) this );\n+    if (0 == base) return;\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( \n+        base, cleanup, (void*) ((char*) this - (char*) base), \n+        &oldProc, &oldData );\n+    if (0 != oldProc) {\n+        GC_REGISTER_FINALIZER_IGNORE_SELF( base, oldProc, oldData, 0, 0 );}}\n+\n+inline void* operator new( \n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup,\n+    void* clientData )\n+{\n+    void* obj;\n+\n+    if (gcp == GC) {\n+        obj = GC_MALLOC( size );\n+        if (cleanup != 0) \n+            GC_REGISTER_FINALIZER_IGNORE_SELF( \n+                obj, cleanup, clientData, 0, 0 );}\n+    else if (gcp == PointerFreeGC) {\n+        obj = GC_MALLOC_ATOMIC( size );}\n+    else {\n+        obj = GC_MALLOC_UNCOLLECTABLE( size );};\n+    return obj;}\n+        \n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+inline void* operator new[]( \n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup,\n+    void* clientData )\n+{\n+    return ::operator new( size, gcp, cleanup, clientData );}\n+\n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+\n+#endif /* GC_CPP_H */\n+"}, {"sha": "2f2d1bf9b8aa5f16b5b899298d8e3c8a33ed14ff", "filename": "boehm-gc/gc_hdrs.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_hdrs.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,133 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, July 11, 1995 11:54 am PDT */\n+# ifndef GC_HEADERS_H\n+# define GC_HEADERS_H\n+typedef struct hblkhdr hdr;\n+\n+# if CPP_WORDSZ != 32 && CPP_WORDSZ < 36\n+\t--> Get a real machine.\n+# endif\n+\n+/*\n+ * The 2 level tree data structure that is used to find block headers.\n+ * If there are more than 32 bits in a pointer, the top level is a hash\n+ * table.\n+ */\n+\n+# if CPP_WORDSZ > 32\n+#   define HASH_TL\n+# endif\n+\n+/* Define appropriate out-degrees for each of the two tree levels\t*/\n+# ifdef SMALL_CONFIG\n+#   define LOG_BOTTOM_SZ 11\n+\t/* Keep top index size reasonable with smaller blocks. */\n+# else\n+#   define LOG_BOTTOM_SZ 10\n+# endif\n+# ifndef HASH_TL\n+#   define LOG_TOP_SZ (WORDSZ - LOG_BOTTOM_SZ - LOG_HBLKSIZE)\n+# else\n+#   define LOG_TOP_SZ 11\n+# endif\n+# define TOP_SZ (1 << LOG_TOP_SZ)\n+# define BOTTOM_SZ (1 << LOG_BOTTOM_SZ)\n+\n+typedef struct bi {\n+    hdr * index[BOTTOM_SZ];\n+\t/*\n+ \t * The bottom level index contains one of three kinds of values:\n+\t * 0 means we're not responsible for this block.\n+\t * 1 < (long)X <= MAX_JUMP means the block starts at least\n+\t *        X * HBLKSIZE bytes before the current address.\n+\t * A valid pointer points to a hdr structure. (The above can't be\n+\t * valid pointers due to the GET_MEM return convention.)\n+\t */\n+    struct bi * asc_link;\t/* All indices are linked in\t*/\n+    \t\t\t\t/* ascending order.\t\t*/\n+    word key;\t\t\t/* high order address bits.\t*/\n+# ifdef HASH_TL\n+    struct bi * hash_link;\t/* Hash chain link.\t\t*/\n+# endif\n+} bottom_index;\n+\n+/* extern bottom_index GC_all_nils; - really part of GC_arrays */\n+\n+/* extern bottom_index * GC_top_index []; - really part of GC_arrays */\n+\t\t\t\t/* Each entry points to a bottom_index.\t*/\n+\t\t\t\t/* On a 32 bit machine, it points to \t*/\n+\t\t\t\t/* the index for a set of high order\t*/\n+\t\t\t\t/* bits equal to the index.  For longer\t*/\n+\t\t\t\t/* addresses, we hash the high order\t*/\n+\t\t\t\t/* bits to compute the index in \t*/\n+\t\t\t\t/* GC_top_index, and each entry points\t*/\n+\t\t\t\t/* to a hash chain.\t\t\t*/\n+\t\t\t\t/* The last entry in each chain is\t*/\n+\t\t\t\t/* GC_all_nils.\t\t\t\t*/\n+\n+\n+# define MAX_JUMP (HBLKSIZE - 1)\n+\n+# define HDR_FROM_BI(bi, p) \\\n+\t\t((bi)->index[((word)(p) >> LOG_HBLKSIZE) & (BOTTOM_SZ - 1)])\n+# ifndef HASH_TL\n+#   define BI(p) (GC_top_index \\\n+\t\t[(word)(p) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE)])\n+#   define HDR_INNER(p) HDR_FROM_BI(BI(p),p)\n+#   ifdef SMALL_CONFIG\n+#\tdefine HDR(p) GC_find_header((ptr_t)(p))\n+#   else\n+#\tdefine HDR(p) HDR_INNER(p)\n+#   endif\n+#   define GET_BI(p, bottom_indx) (bottom_indx) = BI(p)\n+#   define GET_HDR(p, hhdr) (hhdr) = HDR(p)\n+#   define SET_HDR(p, hhdr) HDR_INNER(p) = (hhdr)\n+#   define GET_HDR_ADDR(p, ha) (ha) = &(HDR_INNER(p))\n+# else /* hash */\n+/*  Hash function for tree top level */\n+#   define TL_HASH(hi) ((hi) & (TOP_SZ - 1))\n+/*  Set bottom_indx to point to the bottom index for address p */\n+#   define GET_BI(p, bottom_indx) \\\n+\t{ \\\n+\t    register word hi = \\\n+\t        (word)(p) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n+\t    register bottom_index * _bi = GC_top_index[TL_HASH(hi)]; \\\n+\t    \\\n+\t    while (_bi -> key != hi && _bi != GC_all_nils) \\\n+\t    \t_bi = _bi -> hash_link; \\\n+\t    (bottom_indx) = _bi; \\\n+\t}\n+#   define GET_HDR_ADDR(p, ha) \\\n+\t{ \\\n+\t    register bottom_index * bi; \\\n+\t    \\\n+\t    GET_BI(p, bi);\t\\\n+\t    (ha) = &(HDR_FROM_BI(bi, p)); \\\n+\t}\n+#   define GET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n+\t\t\t      (hhdr) = *_ha; }\n+#   define SET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n+\t\t\t      *_ha = (hhdr); }\n+#   define HDR(p) GC_find_header((ptr_t)(p))\n+# endif\n+\t\t\t    \n+/* Is the result a forwarding address to someplace closer to the\t*/\n+/* beginning of the block or NIL?\t\t\t\t\t*/\n+# define IS_FORWARDING_ADDR_OR_NIL(hhdr) ((unsigned long) (hhdr) <= MAX_JUMP)\n+\n+/* Get an HBLKSIZE aligned address closer to the beginning of the block */\n+/* h.  Assumes hhdr == HDR(h) and IS_FORWARDING_ADDR(hhdr).\t\t*/\n+# define FORWARDED_ADDR(h, hhdr) ((struct hblk *)(h) - (unsigned long)(hhdr))\n+# endif /*  GC_HEADERS_H */"}, {"sha": "ade98a91857dbdf86b19e6574d3a0e3a8f66c232", "filename": "boehm-gc/gc_mark.h", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_mark.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ */\n+/* Boehm, November 7, 1994 4:56 pm PST */\n+\n+/*\n+ * Declarations of mark stack.  Needed by marker and client supplied mark\n+ * routines.  To be included after gc_priv.h.\n+ */\n+#ifndef GC_MARK_H\n+# define GC_MARK_H\n+\n+/* A client supplied mark procedure.  Returns new mark stack pointer.\t*/\n+/* Primary effect should be to push new entries on the mark stack.\t*/\n+/* Mark stack pointer values are passed and returned explicitly.\t*/\n+/* Global variables decribing mark stack are not necessarily valid.\t*/\n+/* (This usually saves a few cycles by keeping things in registers.)\t*/\n+/* Assumed to scan about PROC_BYTES on average.  If it needs to do\t*/\n+/* much more work than that, it should do it in smaller pieces by\t*/\n+/* pushing itself back on the mark stack.\t\t\t\t*/\n+/* Note that it should always do some work (defined as marking some\t*/\n+/* objects) before pushing more than one entry on the mark stack.\t*/\n+/* This is required to ensure termination in the event of mark stack\t*/\n+/* overflows.\t\t\t\t\t\t\t\t*/\n+/* This procedure is always called with at least one empty entry on the */\n+/* mark stack.\t\t\t\t\t\t\t\t*/\n+/* Currently we require that mark procedures look for pointers in a\t*/\n+/* subset of the places the conservative marker would.  It must be safe\t*/\n+/* to invoke the normal mark procedure instead.\t\t\t\t*/\n+# define PROC_BYTES 100\n+typedef struct ms_entry * (*mark_proc)(/* word * addr, mark_stack_ptr,\n+\t\t\t\t\t  mark_stack_limit, env */);\n+\t\t\t\t\t  \n+# define LOG_MAX_MARK_PROCS 6\n+# define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n+extern mark_proc GC_mark_procs[MAX_MARK_PROCS];\n+extern word GC_n_mark_procs;\n+\n+/* Object descriptors on mark stack or in objects.  Low order two\t*/\n+/* bits are tags distinguishing among the following 4 possibilities\t*/\n+/* for the high order 30 bits.\t\t\t\t\t\t*/\n+#define DS_TAG_BITS 2\n+#define DS_TAGS   ((1 << DS_TAG_BITS) - 1)\n+#define DS_LENGTH 0\t/* The entire word is a length in bytes that\t*/\n+\t\t\t/* must be a multiple of 4.\t\t\t*/\n+#define DS_BITMAP 1\t/* 30 bits are a bitmap describing pointer\t*/\n+\t\t\t/* fields.  The msb is 1 iff the first word\t*/\n+\t\t\t/* is a pointer.\t\t\t\t*/\n+\t\t\t/* (This unconventional ordering sometimes\t*/\n+\t\t\t/* makes the marker slightly faster.)\t\t*/\n+\t\t\t/* Zeroes indicate definite nonpointers.  Ones\t*/\n+\t\t\t/* indicate possible pointers.\t\t\t*/\n+\t\t\t/* Only usable if pointers are word aligned.\t*/\n+#   define BITMAP_BITS (WORDSZ - DS_TAG_BITS)\n+#define DS_PROC   2\n+\t\t\t/* The objects referenced by this object can be */\n+\t\t\t/* pushed on the mark stack by invoking\t\t*/\n+\t\t\t/* PROC(descr).  ENV(descr) is passed as the\t*/\n+\t\t\t/* last argument.\t\t\t\t*/\n+#   define PROC(descr) \\\n+\t\t(GC_mark_procs[((descr) >> DS_TAG_BITS) & (MAX_MARK_PROCS-1)])\n+#   define ENV(descr) \\\n+\t\t((descr) >> (DS_TAG_BITS + LOG_MAX_MARK_PROCS))\n+#   define MAX_ENV \\\n+  \t      (((word)1 << (WORDSZ - DS_TAG_BITS - LOG_MAX_MARK_PROCS)) - 1)\n+#   define MAKE_PROC(proc_index, env) \\\n+\t    (((((env) << LOG_MAX_MARK_PROCS) | (proc_index)) << DS_TAG_BITS) \\\n+\t    | DS_PROC)\n+#define DS_PER_OBJECT 3\t/* The real descriptor is at the\t\t*/\n+\t\t\t/* byte displacement from the beginning of the\t*/\n+\t\t\t/* object given by descr & ~DS_TAGS\t\t*/\n+\t\t\t\n+typedef struct ms_entry {\n+    word * mse_start;   /* First word of object */\n+    word mse_descr;\t/* Descriptor; low order two bits are tags,\t*/\n+    \t\t\t/* identifying the upper 30 bits as one of the\t*/\n+    \t\t\t/* following:\t\t\t\t\t*/\n+} mse;\n+\n+extern word GC_mark_stack_size;\n+\n+extern mse * GC_mark_stack_top;\n+\n+extern mse * GC_mark_stack;\n+\n+word GC_find_start();\n+\n+mse * GC_signal_mark_stack_overflow();\n+\n+# ifdef GATHERSTATS\n+#   define ADD_TO_ATOMIC(sz) GC_atomic_in_use += (sz)\n+#   define ADD_TO_COMPOSITE(sz) GC_composite_in_use += (sz)\n+# else\n+#   define ADD_TO_ATOMIC(sz)\n+#   define ADD_TO_COMPOSITE(sz)\n+# endif\n+\n+/* Push the object obj with corresponding heap block header hhdr onto \t*/\n+/* the mark stack.\t\t\t\t\t\t\t*/\n+# define PUSH_OBJ(obj, hhdr, mark_stack_top, mark_stack_limit) \\\n+{ \\\n+    register word _descr = (hhdr) -> hb_descr; \\\n+        \\\n+    if (_descr == 0) { \\\n+    \tADD_TO_ATOMIC((hhdr) -> hb_sz); \\\n+    } else { \\\n+        ADD_TO_COMPOSITE((hhdr) -> hb_sz); \\\n+        mark_stack_top++; \\\n+        if (mark_stack_top >= mark_stack_limit) { \\\n+          mark_stack_top = GC_signal_mark_stack_overflow(mark_stack_top); \\\n+        } \\\n+        mark_stack_top -> mse_start = (obj); \\\n+        mark_stack_top -> mse_descr = _descr; \\\n+    } \\\n+}\n+\n+#ifdef PRINT_BLACK_LIST\n+#   define GC_FIND_START(current, hhdr, source) \\\n+\tGC_find_start(current, hhdr, source)\n+#else\n+#   define GC_FIND_START(current, hhdr, source) \\\n+\tGC_find_start(current, hhdr)\n+#endif\n+\n+/* Push the contents of current onto the mark stack if it is a valid\t*/\n+/* ptr to a currently unmarked object.  Mark it.\t\t\t*/\n+/* If we assumed a standard-conforming compiler, we could probably\t*/\n+/* generate the exit_label transparently.\t\t\t\t*/\n+# define PUSH_CONTENTS(current, mark_stack_top, mark_stack_limit, \\\n+\t\t       source, exit_label) \\\n+{ \\\n+    register int displ;  /* Displacement in block; first bytes, then words */ \\\n+    register hdr * hhdr; \\\n+    register map_entry_type map_entry; \\\n+    \\\n+    GET_HDR(current,hhdr); \\\n+    if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) { \\\n+         current = GC_FIND_START(current, hhdr, (word)source); \\\n+         if (current == 0) goto exit_label; \\\n+         hhdr = HDR(current); \\\n+    } \\\n+    displ = HBLKDISPL(current); \\\n+    map_entry = MAP_ENTRY((hhdr -> hb_map), displ); \\\n+    if (map_entry == OBJ_INVALID) { \\\n+        GC_ADD_TO_BLACK_LIST_NORMAL(current, source); goto exit_label; \\\n+    } \\\n+    displ = BYTES_TO_WORDS(displ); \\\n+    displ -= map_entry; \\\n+\t\\\n+    { \\\n+        register word * mark_word_addr = hhdr -> hb_marks + divWORDSZ(displ); \\\n+        register word mark_word = *mark_word_addr; \\\n+        register word mark_bit = (word)1 << modWORDSZ(displ); \\\n+          \\\n+        if (mark_word & mark_bit) { \\\n+\t      /* Mark bit is already set */ \\\n+\t      goto exit_label; \\\n+        } \\\n+        *mark_word_addr = mark_word | mark_bit; \\\n+    } \\\n+    PUSH_OBJ(((word *)(HBLKPTR(current)) + displ), hhdr, \\\n+    \t     mark_stack_top, mark_stack_limit) \\\n+  exit_label: ; \\\n+}\n+\n+\n+/*\n+ * Push a single value onto mark stack. Mark from the object pointed to by p.\n+ * GC_push_one is normally called by GC_push_regs, and thus must be defined.\n+ * P is considered valid even if it is an interior pointer.\n+ * Previously marked objects are not pushed.  Hence we make progress even\n+ * if the mark stack overflows.\n+ */\n+# define GC_PUSH_ONE_STACK(p) \\\n+    if ((ptr_t)(p) >= GC_least_plausible_heap_addr \t\\\n+\t && (ptr_t)(p) < GC_greatest_plausible_heap_addr) {\t\\\n+\t GC_push_one_checked(p,TRUE);\t\\\n+    }\n+\n+/*\n+ * As above, but interior pointer recognition as for\n+ * normal for heap pointers.\n+ */\n+# ifdef ALL_INTERIOR_POINTERS\n+#   define AIP TRUE\n+# else\n+#   define AIP FALSE\n+# endif\n+# define GC_PUSH_ONE_HEAP(p) \\\n+    if ((ptr_t)(p) >= GC_least_plausible_heap_addr \t\\\n+\t && (ptr_t)(p) < GC_greatest_plausible_heap_addr) {\t\\\n+\t GC_push_one_checked(p,AIP);\t\\\n+    }\n+\n+/*\n+ * Mark from one finalizable object using the specified\n+ * mark proc. May not mark the object pointed to by \n+ * real_ptr. That is the job of the caller, if appropriate\n+ */\n+# define GC_MARK_FO(real_ptr, mark_proc) \\\n+{ \\\n+    (*(mark_proc))(real_ptr); \\\n+    while (!GC_mark_stack_empty()) GC_mark_from_mark_stack(); \\\n+    if (GC_mark_state != MS_NONE) { \\\n+        GC_set_mark_bit(real_ptr); \\\n+        while (!GC_mark_some()); \\\n+    } \\\n+}\n+\n+extern GC_bool GC_mark_stack_too_small;\n+\t\t\t\t/* We need a larger mark stack.  May be\t*/\n+\t\t\t\t/* set by client supplied mark routines.*/\n+\n+typedef int mark_state_t;\t/* Current state of marking, as follows:*/\n+\t\t\t\t/* Used to remember where we are during */\n+\t\t\t\t/* concurrent marking.\t\t\t*/\n+\n+\t\t\t\t/* We say something is dirty if it was\t*/\n+\t\t\t\t/* written since the last time we\t*/\n+\t\t\t\t/* retrieved dirty bits.  We say it's \t*/\n+\t\t\t\t/* grungy if it was marked dirty in the\t*/\n+\t\t\t\t/* last set of bits we retrieved.\t*/\n+\t\t\t\t\n+\t\t\t\t/* Invariant I: all roots and marked\t*/\n+\t\t\t\t/* objects p are either dirty, or point */\n+\t\t\t\t/* objects q that are either marked or\t*/\n+\t\t\t\t/* a pointer to q appears in a range\t*/\n+\t\t\t\t/* on the mark stack.\t\t\t*/\n+\n+# define MS_NONE 0\t\t/* No marking in progress. I holds.\t*/\n+\t\t\t\t/* Mark stack is empty.\t\t\t*/\n+\n+# define MS_PUSH_RESCUERS 1\t/* Rescuing objects are currently \t*/\n+\t\t\t\t/* being pushed.  I holds, except\t*/\n+\t\t\t\t/* that grungy roots may point to \t*/\n+\t\t\t\t/* unmarked objects, as may marked\t*/\n+\t\t\t\t/* grungy objects above scan_ptr.\t*/\n+\n+# define MS_PUSH_UNCOLLECTABLE 2\n+\t\t\t\t/* I holds, except that marked \t\t*/\n+\t\t\t\t/* uncollectable objects above scan_ptr */\n+\t\t\t\t/* may point to unmarked objects.\t*/\n+\t\t\t\t/* Roots may point to unmarked objects\t*/\n+\n+# define MS_ROOTS_PUSHED 3\t/* I holds, mark stack may be nonempty  */\n+\n+# define MS_PARTIALLY_INVALID 4\t/* I may not hold, e.g. because of M.S. */\n+\t\t\t\t/* overflow.  However marked heap\t*/\n+\t\t\t\t/* objects below scan_ptr point to\t*/\n+\t\t\t\t/* marked or stacked objects.\t\t*/\n+\n+# define MS_INVALID 5\t\t/* I may not hold.\t\t\t*/\n+\n+extern mark_state_t GC_mark_state;\n+\n+#endif  /* GC_MARK_H */\n+"}, {"sha": "3dd7c8553bb687832fe3376bdd754d175166e277", "filename": "boehm-gc/gc_private.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_private.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_private.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_private.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1 @@\n+# include \"gc_priv.h\""}, {"sha": "e4a6b94756e767ab79281b2c1245b9ebc3cda939", "filename": "boehm-gc/gc_typed.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_typed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_typed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_typed.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,91 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright 1996 Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/*\n+ * Some simple primitives for allocation with explicit type information.\n+ * Facilities for dynamic type inference may be added later.\n+ * Should be used only for extremely performance critical applications,\n+ * or if conservative collector leakage is otherwise a problem (unlikely).\n+ * Note that this is implemented completely separately from the rest\n+ * of the collector, and is not linked in unless referenced.\n+ * This does not currently support GC_DEBUG in any interesting way.\n+ */\n+/* Boehm, May 19, 1994 2:13 pm PDT */\n+\n+#ifndef _GC_TYPED_H\n+# define _GC_TYPED_H\n+# ifndef _GC_H\n+#   include \"gc.h\"\n+# endif\n+\n+typedef GC_word * GC_bitmap;\n+\t/* The least significant bit of the first word is one if\t*/\n+\t/* the first word in the object may be a pointer.\t\t*/\n+\t\n+# define GC_get_bit(bm, index) \\\n+\t\t(((bm)[divWORDSZ(index)] >> modWORDSZ(index)) & 1)\n+# define GC_set_bit(bm, index) \\\n+\t\t(bm)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n+\n+typedef GC_word GC_descr;\n+\n+GC_API GC_descr GC_make_descriptor GC_PROTO((GC_bitmap bm, size_t len));\n+\t\t/* Return a type descriptor for the object whose layout\t*/\n+\t\t/* is described by the argument.\t\t\t*/\n+\t\t/* The least significant bit of the first word is one\t*/\n+\t\t/* if the first word in the object may be a pointer.\t*/\n+\t\t/* The second argument specifies the number of\t\t*/\n+\t\t/* meaningful bits in the bitmap.  The actual object \t*/\n+\t\t/* may be larger (but not smaller).  Any additional\t*/\n+\t\t/* words in the object are assumed not to contain \t*/\n+\t\t/* pointers.\t\t\t\t\t\t*/\n+\t\t/* Returns a conservative approximation in the\t\t*/\n+\t\t/* (unlikely) case of insufficient memory to build\t*/\n+\t\t/* the descriptor.  Calls to GC_make_descriptor\t\t*/\n+\t\t/* may consume some amount of a finite resource.  This\t*/\n+\t\t/* is intended to be called once per type, not once\t*/\n+\t\t/* per allocation.\t\t\t\t\t*/\n+\n+GC_API GC_PTR GC_malloc_explicitly_typed\n+\t\t\tGC_PROTO((size_t size_in_bytes, GC_descr d));\n+\t\t/* Allocate an object whose layout is described by d.\t*/\n+\t\t/* The resulting object MAY NOT BE PASSED TO REALLOC.\t*/\n+\n+GC_API GC_PTR GC_malloc_explicitly_typed_ignore_off_page\n+                        GC_PROTO((size_t size_in_bytes, GC_descr d));\n+\t\t\n+GC_API GC_PTR GC_calloc_explicitly_typed\n+\t\t\tGC_PROTO((size_t nelements,\n+  \t\t\t\t  size_t element_size_in_bytes,\n+  \t\t\t\t  GC_descr d));\n+  \t/* Allocate an array of nelements elements, each of the\t*/\n+  \t/* given size, and with the given descriptor.\t\t*/\n+  \t/* The elemnt size must be a multiple of the byte\t*/\n+  \t/* alignment required for pointers.  E.g. on a 32-bit\t*/\n+  \t/* machine with 16-bit aligned pointers, size_in_bytes\t*/\n+  \t/* must be a multiple of 2.\t\t\t\t*/\n+\n+#ifdef GC_DEBUG\n+#   define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) GC_MALLOC(bytes)\n+#   define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) GC_MALLOC(n*bytes)\n+#else\n+#  define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) \\\n+\tGC_malloc_explicitly_typed(bytes, d)\n+#  define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) \\\n+\tGC_calloc_explicitly_typed(n, bytes, d)\n+#endif /* !GC_DEBUG */\n+\n+\n+#endif /* _GC_TYPED_H */\n+"}, {"sha": "5131ab9650501d16fe8d62c8f5425bbeb2af670d", "filename": "boehm-gc/gc_watcom.asm", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_watcom.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgc_watcom.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_watcom.asm?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,51 @@\n+\n+        name    gc_watcom\n+\n+.386p\n+\n+        extrn   _edata              : byte  ; end of DATA (start of BSS)\n+        extrn   _end                : byte  ; end of BSS (start of STACK)\n+        extrn   __nullarea          : word\n+\n+        extrn   \"C\",_STACKLOW          : dword\n+        extrn   \"C\",_STACKTOP          : dword\n+\n+\n+DGROUP  group   _DATA\n+\n+_DATA   segment dword public 'DATA'\n+_DATA   ends\n+\n+_TEXT   segment para public use32 'CODE'\n+        assume  cs:_TEXT, ds:DGROUP, ss:DGROUP\n+\n+        public  Get_DATASTART\n+        align   4\n+Get_DATASTART   proc near\n+\n+        mov     eax,offset DGROUP:__nullarea\n+        ret\n+\n+Get_DATASTART   endp\n+\n+        public  Get_DATAEND\n+        align   4\n+Get_DATAEND     proc near\n+\n+        mov     eax,offset DGROUP:_end\n+        ret\n+\n+Get_DATAEND     endp\n+\n+        public  Get_STACKBOTTOM\n+        align   4\n+Get_STACKBOTTOM proc near\n+\n+        mov     eax,_STACKTOP\n+        ret\n+\n+Get_STACKBOTTOM endp\n+\n+_TEXT   ends\n+\n+        end"}, {"sha": "e8a7b8201db64d023a450690db4b7b21be950cdd", "filename": "boehm-gc/gcc_support.c", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgcc_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fgcc_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcc_support.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,516 @@\n+/***************************************************************************\n+\n+Interface between g++ and Boehm GC\n+\n+    Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+\n+    THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+    OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+    Permission is hereby granted to copy this code for any purpose,\n+    provided the above notices are retained on all copies.\n+\n+    Last modified on Sun Jul 16 23:21:14 PDT 1995 by ellis\n+\n+This module provides runtime support for implementing the\n+Ellis/Detlefs GC proposal, \"Safe, Efficient Garbage Collection for\n+C++\", within g++, using its -fgc-keyword extension.  It defines\n+versions of __builtin_new, __builtin_new_gc, __builtin_vec_new,\n+__builtin_vec_new_gc, __builtin_delete, and __builtin_vec_delete that\n+invoke the Bohem GC.  It also implements the WeakPointer.h interface.\n+\n+This module assumes the following configuration options of the Boehm GC:\n+\n+    -DALL_INTERIOR_POINTERS\n+    -DDONT_ADD_BYTE_AT_END   \n+\n+This module adds its own required padding to the end of objects to\n+support C/C++ \"one-past-the-object\" pointer semantics.\n+\n+****************************************************************************/\n+\n+#include <stddef.h>\n+#include \"gc.h\"\n+\n+#if defined(__STDC__) \n+#   define PROTO( args ) args\n+#else\n+#    define PROTO( args ) ()\n+#    endif\n+\n+#define BITSPERBYTE 8     \n+    /* What's the portable way to do this? */\n+\n+\n+typedef void (*vfp) PROTO(( void ));\n+extern vfp __new_handler;\n+extern void __default_new_handler PROTO(( void ));\n+\n+\n+/* A destructor_proc is the compiler generated procedure representing a \n+C++ destructor.  The \"flag\" argument is a hidden argument following some\n+compiler convention. */\n+\n+typedef (*destructor_proc) PROTO(( void* this, int flag ));\n+\n+\n+/***************************************************************************\n+\n+A BI_header is the header the compiler adds to the front of\n+new-allocated arrays of objects with destructors.  The header is\n+padded out to a double, because that's what the compiler does to\n+ensure proper alignment of array elements on some architectures.  \n+\n+int NUM_ARRAY_ELEMENTS (void* o)\n+    returns the number of array elements for array object o.\n+\n+char* FIRST_ELEMENT_P (void* o)\n+    returns the address of the first element of array object o.\n+\n+***************************************************************************/\n+\n+typedef struct BI_header {\n+    int nelts;\n+    char padding [sizeof( double ) - sizeof( int )]; \n+        /* Better way to do this? */\n+} BI_header;\n+\n+#define NUM_ARRAY_ELEMENTS( o ) \\\n+  (((BI_header*) o)->nelts)\n+\n+#define FIRST_ELEMENT_P( o ) \\\n+  ((char*) o + sizeof( BI_header ))\n+\n+\n+/***************************************************************************\n+\n+The __builtin_new routines add a descriptor word to the end of each\n+object.   The descriptor serves two purposes.  \n+\n+First, the descriptor acts as padding, implementing C/C++ pointer\n+semantics.  C and C++ allow a valid array pointer to be incremented\n+one past the end of an object.  The extra padding ensures that the\n+collector will recognize that such a pointer points to the object and\n+not the next object in memory.\n+\n+Second, the descriptor stores three extra pieces of information,\n+whether an object has a registered finalizer (destructor), whether it\n+may have any weak pointers referencing it, and for collectible arrays,\n+the element size of the array.  The element size is required for the\n+array's finalizer to iterate through the elements of the array.  (An\n+alternative design would have the compiler generate a finalizer\n+procedure for each different array type.  But given the overhead of\n+finalization, there isn't any efficiency to be gained by that.)\n+\n+The descriptor must be added to non-collectible as well as collectible\n+objects, since the Ellis/Detlefs proposal allows \"pointer to gc T\" to\n+be assigned to a \"pointer to T\", which could then be deleted.  Thus,\n+__builtin_delete must determine at runtime whether an object is\n+collectible, whether it has weak pointers referencing it, and whether\n+it may have a finalizer that needs unregistering.  Though\n+GC_REGISTER_FINALIZER doesn't care if you ask it to unregister a\n+finalizer for an object that doesn't have one, it is a non-trivial\n+procedure that does a hash look-up, etc.  The descriptor trades a\n+little extra space for a significant increase in time on the fast path\n+through delete.  (A similar argument applies to\n+GC_UNREGISTER_DISAPPEARING_LINK).\n+\n+For non-array types, the space for the descriptor could be shrunk to a\n+single byte for storing the \"has finalizer\" flag.  But this would save\n+space only on arrays of char (whose size is not a multiple of the word\n+size) and structs whose largest member is less than a word in size\n+(very infrequent).  And it would require that programmers actually\n+remember to call \"delete[]\" instead of \"delete\" (which they should,\n+but there are probably lots of buggy programs out there).  For the\n+moment, the space savings seems not worthwhile, especially considering\n+that the Boehm GC is already quite space competitive with other\n+malloc's.\n+\n+\n+Given a pointer o to the base of an object:\n+\n+Descriptor* DESCRIPTOR (void* o) \n+     returns a pointer to the descriptor for o.\n+\n+The implementation of descriptors relies on the fact that the GC\n+implementation allocates objects in units of the machine's natural\n+word size (e.g. 32 bits on a SPARC, 64 bits on an Alpha).\n+\n+**************************************************************************/\n+\n+typedef struct Descriptor {\n+    unsigned has_weak_pointers: 1;\n+    unsigned has_finalizer: 1;\n+    unsigned element_size: BITSPERBYTE * sizeof( unsigned ) - 2; \n+} Descriptor;\n+\n+#define DESCRIPTOR( o ) \\\n+  ((Descriptor*) ((char*)(o) + GC_size( o ) - sizeof( Descriptor )))\n+\n+\n+/**************************************************************************\n+\n+Implementations of global operator new() and operator delete()\n+\n+***************************************************************************/\n+\n+\n+void* __builtin_new( size ) \n+    size_t size;\n+    /* \n+    For non-gc non-array types, the compiler generates calls to\n+    __builtin_new, which allocates non-collected storage via\n+    GC_MALLOC_UNCOLLECTABLE.  This ensures that the non-collected\n+    storage will be part of the collector's root set, required by the\n+    Ellis/Detlefs semantics. */\n+{\n+    vfp handler = __new_handler ? __new_handler : __default_new_handler;\n+\n+    while (1) {\n+        void* o = GC_MALLOC_UNCOLLECTABLE( size + sizeof( Descriptor ) );\n+        if (o != 0) return o;\n+        (*handler) ();}}\n+\n+\n+void* __builtin_vec_new( size ) \n+    size_t size;\n+    /* \n+    For non-gc array types, the compiler generates calls to\n+    __builtin_vec_new. */\n+{\n+    return __builtin_new( size );}\n+\n+\n+void* __builtin_new_gc( size )\n+    size_t size;\n+    /* \n+    For gc non-array types, the compiler generates calls to\n+    __builtin_new_gc, which allocates collected storage via\n+    GC_MALLOC. */\n+{\n+    vfp handler = __new_handler ? __new_handler : __default_new_handler;\n+\n+    while (1) {\n+        void* o = GC_MALLOC( size + sizeof( Descriptor ) );\n+        if (o != 0) return o;\n+        (*handler) ();}}\n+\n+\n+void* __builtin_new_gc_a( size )\n+    size_t size;\n+    /* \n+    For non-pointer-containing gc non-array types, the compiler\n+    generates calls to __builtin_new_gc_a, which allocates collected\n+    storage via GC_MALLOC_ATOMIC. */\n+{\n+    vfp handler = __new_handler ? __new_handler : __default_new_handler;\n+\n+    while (1) {\n+        void* o = GC_MALLOC_ATOMIC( size + sizeof( Descriptor ) );\n+        if (o != 0) return o;\n+        (*handler) ();}}\n+\n+\n+void* __builtin_vec_new_gc( size )\n+    size_t size;\n+    /*\n+    For gc array types, the compiler generates calls to\n+    __builtin_vec_new_gc. */\n+{\n+    return __builtin_new_gc( size );}\n+\n+\n+void* __builtin_vec_new_gc_a( size )\n+    size_t size;\n+    /*\n+    For non-pointer-containing gc array types, the compiler generates\n+    calls to __builtin_vec_new_gc_a. */\n+{\n+    return __builtin_new_gc_a( size );}\n+\n+\n+static void call_destructor( o, data )\n+    void* o;\n+    void* data;\n+    /* \n+    call_destructor is the GC finalizer proc registered for non-array\n+    gc objects with destructors.  Its client data is the destructor\n+    proc, which it calls with the magic integer 2, a special flag\n+    obeying the compiler convention for destructors. */\n+{\n+    ((destructor_proc) data)( o, 2 );}\n+\n+\n+void* __builtin_new_gc_dtor( o, d )\n+    void* o;\n+    destructor_proc d;\n+    /* \n+    The compiler generates a call to __builtin_new_gc_dtor to register\n+    the destructor \"d\" of a non-array gc object \"o\" as a GC finalizer.\n+    The destructor is registered via\n+    GC_REGISTER_FINALIZER_IGNORE_SELF, which causes the collector to\n+    ignore pointers from the object to itself when determining when\n+    the object can be finalized.  This is necessary due to the self\n+    pointers used in the internal representation of multiply-inherited\n+    objects. */\n+{\n+    Descriptor* desc = DESCRIPTOR( o );\n+\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( o, call_destructor, d, 0, 0 );\n+    desc->has_finalizer = 1;}\n+\n+\n+static void call_array_destructor( o, data )\n+    void* o;\n+    void* data;\n+    /*\n+    call_array_destructor is the GC finalizer proc registered for gc\n+    array objects whose elements have destructors. Its client data is\n+    the destructor proc.  It iterates through the elements of the\n+    array in reverse order, calling the destructor on each. */\n+{\n+    int num = NUM_ARRAY_ELEMENTS( o );\n+    Descriptor* desc = DESCRIPTOR( o );\n+    size_t size = desc->element_size;\n+    char* first_p = FIRST_ELEMENT_P( o );\n+    char* p = first_p + (num - 1) * size;\n+\n+    if (num > 0) {\n+        while (1) {\n+            ((destructor_proc) data)( p, 2 );\n+            if (p == first_p) break;\n+            p -= size;}}}\n+\n+\n+void* __builtin_vec_new_gc_dtor( first_elem, d, element_size )\n+    void* first_elem;\n+    destructor_proc d;\n+    size_t element_size;\n+    /* \n+    The compiler generates a call to __builtin_vec_new_gc_dtor to\n+    register the destructor \"d\" of a gc array object as a GC\n+    finalizer.  \"first_elem\" points to the first element of the array,\n+    *not* the beginning of the object (this makes the generated call\n+    to this function smaller).  The elements of the array are of size\n+    \"element_size\".  The destructor is registered as in\n+    _builtin_new_gc_dtor. */\n+{\n+    void* o = (char*) first_elem - sizeof( BI_header );\n+    Descriptor* desc = DESCRIPTOR( o );\n+\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( o, call_array_destructor, d, 0, 0 );\n+    desc->element_size = element_size;\n+    desc->has_finalizer = 1;}\n+\n+\n+void __builtin_delete( o )\n+    void* o;\n+    /* \n+    The compiler generates calls to __builtin_delete for operator\n+    delete().  The GC currently requires that any registered\n+    finalizers be unregistered before explicitly freeing an object.\n+    If the object has any weak pointers referencing it, we can't\n+    actually free it now. */\n+{\n+  if (o != 0) { \n+      Descriptor* desc = DESCRIPTOR( o );\n+      if (desc->has_finalizer) GC_REGISTER_FINALIZER( o, 0, 0, 0, 0 );\n+      if (! desc->has_weak_pointers) GC_FREE( o );}}\n+\n+\n+void __builtin_vec_delete( o )\n+    void* o;\n+    /* \n+    The compiler generates calls to __builitn_vec_delete for operator\n+    delete[](). */\n+{\n+  __builtin_delete( o );}\n+\n+\n+/**************************************************************************\n+\n+Implementations of the template class WeakPointer from WeakPointer.h\n+\n+***************************************************************************/\n+\n+typedef struct WeakPointer {\n+    void* pointer; \n+} WeakPointer;\n+\n+\n+void* _WeakPointer_New( t )\n+    void* t;\n+{\n+    if (t == 0) {\n+        return 0;}\n+    else {\n+        void* base = GC_base( t );\n+        WeakPointer* wp = \n+            (WeakPointer*) GC_MALLOC_ATOMIC( sizeof( WeakPointer ) );\n+        Descriptor* desc = DESCRIPTOR( base );\n+\n+        wp->pointer = t;\n+        desc->has_weak_pointers = 1;\n+        GC_general_register_disappearing_link( &wp->pointer, base );\n+        return wp;}}\n+\n+\n+static void* PointerWithLock( wp ) \n+    WeakPointer* wp;\n+{\n+    if (wp == 0 || wp->pointer == 0) {\n+      return 0;}\n+    else {\n+        return (void*) wp->pointer;}}\n+\n+\n+void* _WeakPointer_Pointer( wp )\n+    WeakPointer* wp;\n+{\n+    return (void*) GC_call_with_alloc_lock( PointerWithLock, wp );}\n+\n+\n+typedef struct EqualClosure {\n+    WeakPointer* wp1;\n+    WeakPointer* wp2;\n+} EqualClosure;\n+\n+\n+static void* EqualWithLock( ec )\n+    EqualClosure* ec;\n+{\n+    if (ec->wp1 == 0 || ec->wp2 == 0) {\n+        return (void*) (ec->wp1 == ec->wp2);}\n+    else {\n+      return (void*) (ec->wp1->pointer == ec->wp2->pointer);}}\n+\n+\n+int _WeakPointer_Equal( wp1,  wp2 )\n+    WeakPointer* wp1;\n+    WeakPointer* wp2;\n+{\n+    EqualClosure ec;\n+\n+    ec.wp1 = wp1;\n+    ec.wp2 = wp2;\n+    return (int) GC_call_with_alloc_lock( EqualWithLock, &ec );}\n+\n+\n+int _WeakPointer_Hash( wp )\n+    WeakPointer* wp;\n+{\n+    return (int) _WeakPointer_Pointer( wp );}\n+\n+\n+/**************************************************************************\n+\n+Implementations of the template class CleanUp from WeakPointer.h\n+\n+***************************************************************************/\n+\n+typedef struct Closure {\n+    void (*c) PROTO(( void* d, void* t ));\n+    ptrdiff_t t_offset; \n+    void* d;\n+} Closure;\n+\n+\n+static void _CleanUp_CallClosure( obj, data ) \n+    void* obj;\n+    void* data;\n+{\n+    Closure* closure = (Closure*) data;\n+    closure->c( closure->d, (char*) obj + closure->t_offset );}\n+\n+\n+void _CleanUp_Set( t, c, d ) \n+    void* t;\n+    void (*c) PROTO(( void* d, void* t ));\n+    void* d;\n+{\n+    void* base = GC_base( t );\n+    Descriptor* desc = DESCRIPTOR( t );\n+\n+    if (c == 0) {\n+        GC_REGISTER_FINALIZER_IGNORE_SELF( base, 0, 0, 0, 0 );\n+        desc->has_finalizer = 0;}\n+    else {\n+        Closure* closure = (Closure*) GC_MALLOC( sizeof( Closure ) );\n+        closure->c = c;\n+        closure->t_offset = (char*) t - (char*) base;\n+        closure->d = d;\n+        GC_REGISTER_FINALIZER_IGNORE_SELF( base, _CleanUp_CallClosure, \n+                                           closure, 0, 0 );\n+        desc->has_finalizer = 1;}}\n+\n+\n+void _CleanUp_Call( t ) \n+    void* t;\n+{\n+      /* ? Aren't we supposed to deactivate weak pointers to t too? \n+         Why? */\n+    void* base = GC_base( t );\n+    void* d;\n+    GC_finalization_proc f;\n+\n+    GC_REGISTER_FINALIZER( base, 0, 0, &f, &d );\n+    f( base, d );}\n+\n+\n+typedef struct QueueElem {\n+    void* o;\n+    GC_finalization_proc f;\n+    void* d;\n+    struct QueueElem* next; \n+} QueueElem;\n+\n+\n+void* _CleanUp_Queue_NewHead()\n+{\n+    return GC_MALLOC( sizeof( QueueElem ) );}\n+    \n+     \n+static void _CleanUp_Queue_Enqueue( obj, data )\n+    void* obj; \n+    void* data;\n+{\n+    QueueElem* q = (QueueElem*) data;\n+    QueueElem* head = q->next;\n+\n+    q->o = obj;\n+    q->next = head->next;\n+    head->next = q;}\n+    \n+    \n+void _CleanUp_Queue_Set( h, t ) \n+    void* h;\n+    void* t;\n+{\n+    QueueElem* head = (QueueElem*) h;\n+    void* base = GC_base( t );\n+    void* d;\n+    GC_finalization_proc f;\n+    QueueElem* q = (QueueElem*) GC_MALLOC( sizeof( QueueElem ) );\n+     \n+    GC_REGISTER_FINALIZER( base, _CleanUp_Queue_Enqueue, q, &f, &d );\n+    q->f = f;\n+    q->d = d;\n+    q->next = head;}\n+    \n+\n+int _CleanUp_Queue_Call( h ) \n+    void* h;\n+{\n+    QueueElem* head = (QueueElem*) h;\n+    QueueElem* q = head->next;\n+\n+    if (q == 0) {\n+        return 0;}\n+    else {\n+        head->next = q->next;\n+        q->next = 0;\n+        if (q->f != 0) q->f( q->o, q->d );\n+        return 1;}}\n+\n+\n+"}, {"sha": "b5cc1af8a8da8087b31353cdc3ad04b97289aec6", "filename": "boehm-gc/headers.c", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fheaders.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fheaders.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fheaders.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,296 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+ \n+/*\n+ * This implements:\n+ * 1. allocation of heap block headers\n+ * 2. A map from addresses to heap block addresses to heap block headers\n+ *\n+ * Access speed is crucial.  We implement an index structure based on a 2\n+ * level tree.\n+ */\n+ \n+# include \"gc_priv.h\"\n+\n+bottom_index * GC_all_bottom_indices = 0;\n+ \n+/* Non-macro version of header location routine */\n+hdr * GC_find_header(h)\n+ptr_t h;\n+{\n+#   ifdef HASH_TL\n+\tregister hdr * result;\n+\tGET_HDR(h, result);\n+\treturn(result);\n+#   else\n+\treturn(HDR_INNER(h));\n+#   endif\n+}\n+ \n+/* Routines to dynamically allocate collector data structures that will */\n+/* never be freed.\t\t\t\t\t\t\t */\n+ \n+static ptr_t scratch_free_ptr = 0;\n+ \n+ptr_t GC_scratch_end_ptr = 0;\n+\n+ptr_t GC_scratch_last_end_ptr = 0;\n+\t\t/* End point of last obtained scratch area */\n+ \n+ptr_t GC_scratch_alloc(bytes)\n+register word bytes;\n+{\n+    register ptr_t result = scratch_free_ptr;\n+    register word bytes_needed = bytes;\n+\n+#   ifdef ALIGN_DOUBLE\n+#\tdefine GRANULARITY (2 * sizeof(word))\n+#   else\n+#\tdefine GRANULARITY sizeof(word)\n+#   endif\n+    bytes += GRANULARITY-1;\n+    bytes &= ~(GRANULARITY-1);\n+    scratch_free_ptr += bytes;\n+    if (scratch_free_ptr <= GC_scratch_end_ptr) {\n+        return(result);\n+    }\n+    {\n+        word bytes_to_get = MINHINCR * HBLKSIZE;\n+         \n+        if (bytes_to_get <= bytes) {\n+          /* Undo the damage, and get memory directly */\n+\t    bytes_to_get = bytes;\n+#\t    ifdef USE_MMAP\n+\t\tbytes_to_get += GC_page_size - 1;\n+\t\tbytes_to_get &= ~(GC_page_size - 1);\n+#\t    endif\n+   \t    result = (ptr_t)GET_MEM(bytes_to_get);\n+            scratch_free_ptr -= bytes;\n+\t    GC_scratch_last_end_ptr = result + bytes;\n+            return(result);\n+        }\n+        result = (ptr_t)GET_MEM(bytes_to_get);\n+        if (result == 0) {\n+#\t    ifdef PRINTSTATS\n+                GC_printf0(\"Out of memory - trying to allocate less\\n\");\n+#\t    endif\n+            scratch_free_ptr -= bytes;\n+\t    bytes_to_get = bytes;\n+#\t    ifdef USE_MMAP\n+\t\tbytes_to_get += GC_page_size - 1;\n+\t\tbytes_to_get &= (GC_page_size - 1);\n+#\t    endif\n+            return((ptr_t)GET_MEM(bytes_to_get));\n+        }\n+        scratch_free_ptr = result;\n+        GC_scratch_end_ptr = scratch_free_ptr + bytes_to_get;\n+        GC_scratch_last_end_ptr = GC_scratch_end_ptr;\n+        return(GC_scratch_alloc(bytes));\n+    }\n+}\n+\n+static hdr * hdr_free_list = 0;\n+\n+/* Return an uninitialized header */\n+static hdr * alloc_hdr()\n+{\n+    register hdr * result;\n+    \n+    if (hdr_free_list == 0) {\n+        result = (hdr *) GC_scratch_alloc((word)(sizeof(hdr)));\n+    } else {\n+        result = hdr_free_list;\n+        hdr_free_list = (hdr *) (result -> hb_next);\n+    }\n+    return(result);\n+}\n+\n+static void free_hdr(hhdr)\n+hdr * hhdr;\n+{\n+    hhdr -> hb_next = (struct hblk *) hdr_free_list;\n+    hdr_free_list = hhdr;\n+}\n+ \n+void GC_init_headers()\n+{\n+    register int i;\n+    \n+    GC_all_nils = (bottom_index *)GC_scratch_alloc((word)sizeof(bottom_index));\n+    BZERO(GC_all_nils, sizeof(bottom_index));\n+    for (i = 0; i < TOP_SZ; i++) {\n+        GC_top_index[i] = GC_all_nils;\n+    }\n+}\n+\n+/* Make sure that there is a bottom level index block for address addr  */\n+/* Return FALSE on failure.\t\t\t\t\t\t*/\n+static GC_bool get_index(addr)\n+register word addr;\n+{\n+    register word hi =\n+    \t\t(word)(addr) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE);\n+    register bottom_index * r;\n+    register bottom_index * p;\n+    register bottom_index ** prev;\n+#   ifdef HASH_TL\n+      register unsigned i = TL_HASH(hi);\n+      register bottom_index * old;\n+      \n+      old = p = GC_top_index[i];\n+      while(p != GC_all_nils) {\n+          if (p -> key == hi) return(TRUE);\n+          p = p -> hash_link;\n+      }\n+      r = (bottom_index*)GC_scratch_alloc((word)(sizeof (bottom_index)));\n+      if (r == 0) return(FALSE);\n+      BZERO(r, sizeof (bottom_index));\n+      r -> hash_link = old;\n+      GC_top_index[i] = r;\n+#   else\n+      if (GC_top_index[hi] != GC_all_nils) return(TRUE);\n+      r = (bottom_index*)GC_scratch_alloc((word)(sizeof (bottom_index)));\n+      if (r == 0) return(FALSE);\n+      GC_top_index[hi] = r;\n+      BZERO(r, sizeof (bottom_index));\n+# endif\n+    r -> key = hi;\n+    /* Add it to the list of bottom indices */\n+      prev = &GC_all_bottom_indices;\n+      while ((p = *prev) != 0 && p -> key < hi) prev = &(p -> asc_link);\n+      r -> asc_link = p;\n+      *prev = r;\n+    return(TRUE);\n+}\n+\n+/* Install a header for block h.  */\n+/* The header is uninitialized.\t  */\n+/* Returns FALSE on failure.\t  */\n+GC_bool GC_install_header(h)\n+register struct hblk * h;\n+{\n+    hdr * result;\n+    \n+    if (!get_index((word) h)) return(FALSE);\n+    result = alloc_hdr();\n+    SET_HDR(h, result);\n+    return(result != 0);\n+}\n+\n+/* Set up forwarding counts for block h of size sz */\n+GC_bool GC_install_counts(h, sz)\n+register struct hblk * h;\n+register word sz; /* bytes */\n+{\n+    register struct hblk * hbp;\n+    register int i;\n+    \n+    for (hbp = h; (char *)hbp < (char *)h + sz; hbp += BOTTOM_SZ) {\n+        if (!get_index((word) hbp)) return(FALSE);\n+    }\n+    if (!get_index((word)h + sz - 1)) return(FALSE);\n+    for (hbp = h + 1; (char *)hbp < (char *)h + sz; hbp += 1) {\n+        i = HBLK_PTR_DIFF(hbp, h);\n+        SET_HDR(hbp, (hdr *)(i > MAX_JUMP? MAX_JUMP : i));\n+    }\n+    return(TRUE);\n+}\n+\n+/* Remove the header for block h */\n+void GC_remove_header(h)\n+register struct hblk * h;\n+{\n+    hdr ** ha;\n+    \n+    GET_HDR_ADDR(h, ha);\n+    free_hdr(*ha);\n+    *ha = 0;\n+}\n+\n+/* Remove forwarding counts for h */\n+void GC_remove_counts(h, sz)\n+register struct hblk * h;\n+register word sz; /* bytes */\n+{\n+    register struct hblk * hbp;\n+    \n+    for (hbp = h+1; (char *)hbp < (char *)h + sz; hbp += 1) {\n+        SET_HDR(hbp, 0);\n+    }\n+}\n+\n+/* Apply fn to all allocated blocks */\n+/*VARARGS1*/\n+void GC_apply_to_all_blocks(fn, client_data)\n+void (*fn)(/* struct hblk *h, word client_data */);\n+word client_data;\n+{\n+    register int j;\n+    register bottom_index * index_p;\n+    \n+    for (index_p = GC_all_bottom_indices; index_p != 0;\n+         index_p = index_p -> asc_link) {\n+        for (j = BOTTOM_SZ-1; j >= 0;) {\n+            if (!IS_FORWARDING_ADDR_OR_NIL(index_p->index[j])) {\n+                if (index_p->index[j]->hb_map != GC_invalid_map) {\n+                    (*fn)(((struct hblk *)\n+                  \t      (((index_p->key << LOG_BOTTOM_SZ) + (word)j)\n+                  \t       << LOG_HBLKSIZE)),\n+                          client_data);\n+                }\n+                j--;\n+             } else if (index_p->index[j] == 0) {\n+                j--;\n+             } else {\n+                j -= (word)(index_p->index[j]);\n+             }\n+         }\n+     }\n+}\n+\n+/* Get the next valid block whose address is at least h\t*/\n+/* Return 0 if there is none.\t\t\t\t*/\n+struct hblk * GC_next_block(h)\n+struct hblk * h;\n+{\n+    register bottom_index * bi;\n+    register word j = ((word)h >> LOG_HBLKSIZE) & (BOTTOM_SZ-1);\n+    \n+    GET_BI(h, bi);\n+    if (bi == GC_all_nils) {\n+        register word hi = (word)h >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE);\n+        bi = GC_all_bottom_indices;\n+        while (bi != 0 && bi -> key < hi) bi = bi -> asc_link;\n+        j = 0;\n+    }\n+    while(bi != 0) {\n+        while (j < BOTTOM_SZ) {\n+            if (IS_FORWARDING_ADDR_OR_NIL(bi -> index[j])) {\n+                j++;\n+            } else {\n+                if (bi->index[j]->hb_map != GC_invalid_map) {\n+                    return((struct hblk *)\n+                  \t      (((bi -> key << LOG_BOTTOM_SZ) + j)\n+                  \t       << LOG_HBLKSIZE));\n+                } else {\n+                    j += divHBLKSZ(bi->index[j] -> hb_sz);\n+                }\n+            }\n+        }\n+        j = 0;\n+        bi = bi -> asc_link;\n+    }\n+    return(0);\n+}"}, {"sha": "da2b7f90a62bf823cf0ab1ddd58fce278be6a9d4", "filename": "boehm-gc/if_mach.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fif_mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fif_mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_mach.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,25 @@\n+/* Conditionally execute a command based on machine and OS from config.h */\n+/* Boehm, November 21, 1994 1:40 pm PST */\n+# include \"config.h\"\n+# include <stdio.h>\n+\n+int main(argc, argv, envp)\n+int argc;\n+char ** argv;\n+char ** envp;\n+{\n+    if (argc < 4) goto Usage;\n+    if (strcmp(MACH_TYPE, argv[1]) != 0) return(0);\n+    if (strcmp(OS_TYPE, \"\") != 0 && strcmp(argv[2], \"\") != 0\n+        && strcmp(OS_TYPE, argv[2]) != 0) return(0);\n+    printf(\"^^^^Starting command^^^^\\n\");\n+    execvp(argv[3], argv+3);\n+    perror(\"Couldn't execute\");\n+    \n+Usage:\n+    fprintf(stderr, \"Usage: %s mach_type os_type command\\n\", argv[0]);\n+    fprintf(stderr, \"Currently mach_type = %s, os_type = %s\\n\",\n+    \t    MACH_TYPE, OS_TYPE);\n+    return(1);\n+}\n+"}, {"sha": "9616309d824f95d992716982557187f03c55b37b", "filename": "boehm-gc/if_not_there.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fif_not_there.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fif_not_there.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_not_there.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,26 @@\n+/* Conditionally execute a command based if the file argv[1] doesn't exist */\n+/* Except for execvp, we stick to ANSI C.\t\t\t\t   */\n+# include \"config.h\"\n+# include <stdio.h>\n+\n+int main(argc, argv, envp)\n+int argc;\n+char ** argv;\n+char ** envp;\n+{\n+    FILE * f;\n+    if (argc < 3) goto Usage;\n+    if ((f = fopen(argv[1], \"rb\")) != 0\n+        || (f = fopen(argv[1], \"r\")) != 0) {\n+        fclose(f);\n+        return(0);\n+    }\n+    printf(\"^^^^Starting command^^^^\\n\");\n+    execvp(argv[2], argv+2);\n+    exit(1);\n+    \n+Usage:\n+    fprintf(stderr, \"Usage: %s file_name command\\n\", argv[0]);\n+    return(1);\n+}\n+"}, {"sha": "584112fd181089b8e61449db6fa02ca34f9157ad", "filename": "boehm-gc/include/cord.h", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fcord.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fcord.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fcord.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,327 @@\n+/* \n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n+ */\n+/* Boehm, October 5, 1995 4:20 pm PDT */\n+ \n+/*\n+ * Cords are immutable character strings.  A number of operations\n+ * on long cords are much more efficient than their strings.h counterpart.\n+ * In particular, concatenation takes constant time independent of the length\n+ * of the arguments.  (Cords are represented as trees, with internal\n+ * nodes representing concatenation and leaves consisting of either C\n+ * strings or a functional description of the string.)\n+ *\n+ * The following are reasonable applications of cords.  They would perform\n+ * unacceptably if C strings were used:\n+ * - A compiler that produces assembly language output by repeatedly\n+ *   concatenating instructions onto a cord representing the output file.\n+ * - A text editor that converts the input file to a cord, and then\n+ *   performs editing operations by producing a new cord representing\n+ *   the file after echa character change (and keeping the old ones in an\n+ *   edit history)\n+ *\n+ * For optimal performance, cords should be built by\n+ * concatenating short sections.\n+ * This interface is designed for maximum compatibility with C strings.\n+ * ASCII NUL characters may be embedded in cords using CORD_from_fn.\n+ * This is handled correctly, but CORD_to_char_star will produce a string\n+ * with embedded NULs when given such a cord. \n+ *\n+ * This interface is fairly big, largely for performance reasons.\n+ * The most basic constants and functions:\n+ *\n+ * CORD - the type fo a cord;\n+ * CORD_EMPTY - empty cord;\n+ * CORD_len(cord) - length of a cord;\n+ * CORD_cat(cord1,cord2) - concatenation of two cords;\n+ * CORD_substr(cord, start, len) - substring (or subcord);\n+ * CORD_pos i;  CORD_FOR(i, cord) {  ... CORD_pos_fetch(i) ... } -\n+ *    examine each character in a cord.  CORD_pos_fetch(i) is the char.\n+ * CORD_fetch(int i) - Retrieve i'th character (slowly).\n+ * CORD_cmp(cord1, cord2) - compare two cords.\n+ * CORD_from_file(FILE * f) - turn a read-only file into a cord.\n+ * CORD_to_char_star(cord) - convert to C string.\n+ *   (Non-NULL C constant strings are cords.)\n+ * CORD_printf (etc.) - cord version of printf. Use %r for cords.\n+ */\n+# ifndef CORD_H\n+\n+# define CORD_H\n+# include <stddef.h>\n+# include <stdio.h>\n+/* Cords have type const char *.  This is cheating quite a bit, and not\t*/\n+/* 100% portable.  But it means that nonempty character string\t\t*/\n+/* constants may be used as cords directly, provided the string is\t*/\n+/* never modified in place.  The empty cord is represented by, and\t*/\n+/* can be written as, 0.\t\t\t\t\t\t*/\n+\n+typedef const char * CORD;\n+\n+/* An empty cord is always represented as nil \t*/\n+# define CORD_EMPTY 0\n+\n+/* Is a nonempty cord represented as a C string? */\n+#define CORD_IS_STRING(s) (*(s) != '\\0')\n+\n+/* Concatenate two cords.  If the arguments are C strings, they may \t*/\n+/* not be subsequently altered.\t\t\t\t\t\t*/\n+CORD CORD_cat(CORD x, CORD y);\n+\n+/* Concatenate a cord and a C string with known length.  Except for the\t*/\n+/* empty string case, this is a special case of CORD_cat.  Since the\t*/\n+/* length is known, it can be faster.\t\t\t\t\t*/\n+/* The string y is shared with the resulting CORD.  Hence it should\t*/\n+/* not be altered by the caller.\t\t\t\t\t*/\n+CORD CORD_cat_char_star(CORD x, const char * y, size_t leny);\n+\n+/* Compute the length of a cord */\n+size_t CORD_len(CORD x);\n+\n+/* Cords may be represented by functions defining the ith character */\n+typedef char (* CORD_fn)(size_t i, void * client_data);\n+\n+/* Turn a functional description into a cord. \t*/\n+CORD CORD_from_fn(CORD_fn fn, void * client_data, size_t len);\n+\n+/* Return the substring (subcord really) of x with length at most n,\t*/\n+/* starting at position i.  (The initial character has position 0.)\t*/\n+CORD CORD_substr(CORD x, size_t i, size_t n);\n+\n+/* Return the argument, but rebalanced to allow more efficient   \t*/\n+/* character retrieval, substring operations, and comparisons.\t\t*/\n+/* This is useful only for cords that were built using repeated \t*/\n+/* concatenation.  Guarantees log time access to the result, unless\t*/\n+/* x was obtained through a large number of repeated substring ops\t*/\n+/* or the embedded functional descriptions take longer to evaluate.\t*/\n+/* May reallocate significant parts of the cord.  The argument is not\t*/\n+/* modified; only the result is balanced.\t\t\t\t*/\n+CORD CORD_balance(CORD x);\n+\n+/* The following traverse a cord by applying a function to each \t*/\n+/* character.  This is occasionally appropriate, especially where\t*/\n+/* speed is crucial.  But, since C doesn't have nested functions,\t*/\n+/* clients of this sort of traversal are clumsy to write.  Consider\t*/\n+/* the functions that operate on cord positions instead.\t\t*/\n+\n+/* Function to iteratively apply to individual characters in cord.\t*/\n+typedef int (* CORD_iter_fn)(char c, void * client_data);\n+\n+/* Function to apply to substrings of a cord.  Each substring is a \t*/\n+/* a C character string, not a general cord.\t\t\t\t*/\n+typedef int (* CORD_batched_iter_fn)(const char * s, void * client_data);\n+# define CORD_NO_FN ((CORD_batched_iter_fn)0)\n+\n+/* Apply f1 to each character in the cord, in ascending order,\t\t*/\n+/* starting at position i. If\t\t\t\t\t\t*/\n+/* f2 is not CORD_NO_FN, then multiple calls to f1 may be replaced by\t*/\n+/* a single call to f2.  The parameter f2 is provided only to allow\t*/\n+/* some optimization by the client.  This terminates when the right\t*/\n+/* end of this string is reached, or when f1 or f2 return != 0.  In the\t*/\n+/* latter case CORD_iter returns != 0.  Otherwise it returns 0.\t\t*/\n+/* The specified value of i must be < CORD_len(x).\t\t\t*/\n+int CORD_iter5(CORD x, size_t i, CORD_iter_fn f1,\n+\t       CORD_batched_iter_fn f2, void * client_data);\n+\n+/* A simpler version that starts at 0, and without f2:\t*/\n+int CORD_iter(CORD x, CORD_iter_fn f1, void * client_data);\n+# define CORD_iter(x, f1, cd) CORD_iter5(x, 0, f1, CORD_NO_FN, cd)\n+\n+/* Similar to CORD_iter5, but end-to-beginning.\tNo provisions for\t*/\n+/* CORD_batched_iter_fn.\t\t\t\t\t\t*/\n+int CORD_riter4(CORD x, size_t i, CORD_iter_fn f1, void * client_data);\n+\n+/* A simpler version that starts at the end:\t*/\n+int CORD_riter(CORD x, CORD_iter_fn f1, void * client_data);\n+\n+/* Functions that operate on cord positions.  The easy way to traverse\t*/\n+/* cords.  A cord position is logically a pair consisting of a cord\t*/\n+/* and an index into that cord.  But it is much faster to retrieve a\t*/\n+/* charcter based on a position than on an index.  Unfortunately,\t*/\n+/* positions are big (order of a few 100 bytes), so allocate them with\t*/\n+/* caution.\t\t\t\t\t\t\t\t*/\n+/* Things in cord_pos.h should be treated as opaque, except as\t\t*/\n+/* described below.  Also note that\t\t\t\t\t*/\n+/* CORD_pos_fetch, CORD_next and CORD_prev have both macro and function\t*/\n+/* definitions.  The former may evaluate their argument more than once. */\n+# include \"private/cord_pos.h\"\n+\n+/*\n+\tVisible definitions from above:\n+\t\n+\ttypedef <OPAQUE but fairly big> CORD_pos[1];\n+\t\n+\t* Extract the cord from a position:\n+\tCORD CORD_pos_to_cord(CORD_pos p);\n+\t\n+\t* Extract the current index from a position:\n+\tsize_t CORD_pos_to_index(CORD_pos p);\n+\t\n+\t* Fetch the character located at the given position:\n+\tchar CORD_pos_fetch(CORD_pos p);\n+\t\n+\t* Initialize the position to refer to the given cord and index.\n+\t* Note that this is the most expensive function on positions:\n+\tvoid CORD_set_pos(CORD_pos p, CORD x, size_t i);\n+\t\n+\t* Advance the position to the next character.\n+\t* P must be initialized and valid.\n+\t* Invalidates p if past end:\n+\tvoid CORD_next(CORD_pos p);\n+\t\n+\t* Move the position to the preceding character.\n+\t* P must be initialized and valid.\n+\t* Invalidates p if past beginning:\n+\tvoid CORD_prev(CORD_pos p);\n+\t\n+\t* Is the position valid, i.e. inside the cord?\n+\tint CORD_pos_valid(CORD_pos p);\n+*/\n+# define CORD_FOR(pos, cord) \\\n+    for (CORD_set_pos(pos, cord, 0); CORD_pos_valid(pos); CORD_next(pos))\n+\n+\t\t\t\n+/* An out of memory handler to call.  May be supplied by client.\t*/\n+/* Must not return.\t\t\t\t\t\t\t*/\n+extern void (* CORD_oom_fn)(void);\n+\n+/* Dump the representation of x to stdout in an implementation defined\t*/\n+/* manner.  Intended for debugging only.\t\t\t\t*/\n+void CORD_dump(CORD x);\n+\n+/* The following could easily be implemented by the client.  They are\t*/\n+/* provided in cordxtra.c for convenience.\t\t\t\t*/\n+\n+/* Concatenate a character to the end of a cord.\t*/\n+CORD CORD_cat_char(CORD x, char c);\n+\n+/* Concatenate n cords.\t*/\n+CORD CORD_catn(int n, /* CORD */ ...);\n+\n+/* Return the character in CORD_substr(x, i, 1)  \t*/\n+char CORD_fetch(CORD x, size_t i);\n+\n+/* Return < 0, 0, or > 0, depending on whether x < y, x = y, x > y\t*/\n+int CORD_cmp(CORD x, CORD y);\n+\n+/* A generalization that takes both starting positions for the \t\t*/\n+/* comparison, and a limit on the number of characters to be compared.\t*/\n+int CORD_ncmp(CORD x, size_t x_start, CORD y, size_t y_start, size_t len);\n+\n+/* Find the first occurrence of s in x at position start or later.\t*/\n+/* Return the position of the first character of s in x, or\t\t*/\n+/* CORD_NOT_FOUND if there is none.\t\t\t\t\t*/\n+size_t CORD_str(CORD x, size_t start, CORD s);\n+\n+/* Return a cord consisting of i copies of (possibly NUL) c.  Dangerous\t*/\n+/* in conjunction with CORD_to_char_star.\t\t\t\t*/\n+/* The resulting representation takes constant space, independent of i.\t*/\n+CORD CORD_chars(char c, size_t i);\n+# define CORD_nul(i) CORD_chars('\\0', (i))\n+\n+/* Turn a file into cord.  The file must be seekable.  Its contents\t*/\n+/* must remain constant.  The file may be accessed as an immediate\t*/\n+/* result of this call and/or as a result of subsequent accesses to \t*/\n+/* the cord.  Short files are likely to be immediately read, but\t*/\n+/* long files are likely to be read on demand, possibly relying on \t*/\n+/* stdio for buffering.\t\t\t\t\t\t\t*/\n+/* We must have exclusive access to the descriptor f, i.e. we may\t*/\n+/* read it at any time, and expect the file pointer to be\t\t*/\n+/* where we left it.  Normally this should be invoked as\t\t*/\n+/* CORD_from_file(fopen(...))\t\t\t\t\t\t*/\n+/* CORD_from_file arranges to close the file descriptor when it is no\t*/\n+/* longer needed (e.g. when the result becomes inaccessible).\t\t*/ \n+/* The file f must be such that ftell reflects the actual character\t*/\n+/* position in the file, i.e. the number of characters that can be \t*/\n+/* or were read with fread.  On UNIX systems this is always true.  On\t*/\n+/* MS Windows systems, f must be opened in binary mode.\t\t\t*/\n+CORD CORD_from_file(FILE * f);\n+\n+/* Equivalent to the above, except that the entire file will be read\t*/\n+/* and the file pointer will be closed immediately.\t\t\t*/\n+/* The binary mode restriction from above does not apply.\t\t*/\n+CORD CORD_from_file_eager(FILE * f);\n+\n+/* Equivalent to the above, except that the file will be read on demand.*/\n+/* The binary mode restriction applies.\t\t\t\t\t*/\n+CORD CORD_from_file_lazy(FILE * f);\n+\n+/* Turn a cord into a C string.\tThe result shares no structure with\t*/\n+/* x, and is thus modifiable.\t\t\t\t\t\t*/\n+char * CORD_to_char_star(CORD x);\n+\n+/* Turn a C string into a CORD.  The C string is copied, and so may\t*/\n+/* subsequently be modified.\t\t\t\t\t\t*/\n+CORD CORD_from_char_star(const char *s);\n+\n+/* Identical to the above, but the result may share structure with\t*/\n+/* the argument and is thus not modifiable.\t\t\t\t*/\n+const char * CORD_to_const_char_star(CORD x); \n+\n+/* Write a cord to a file, starting at the current position.  No\t*/\n+/* trailing NULs are newlines are added.\t\t\t\t*/\n+/* Returns EOF if a write error occurs, 1 otherwise.\t\t\t*/\n+int CORD_put(CORD x, FILE * f);\n+\n+/* \"Not found\" result for the following two functions.\t\t\t*/\n+# define CORD_NOT_FOUND ((size_t)(-1))\n+\n+/* A vague analog of strchr.  Returns the position (an integer, not\t*/\n+/* a pointer) of the first occurrence of (char) c inside x at position \t*/\n+/* i or later. The value i must be < CORD_len(x).\t\t\t*/\n+size_t CORD_chr(CORD x, size_t i, int c);\n+\n+/* A vague analog of strrchr.  Returns index of the last occurrence\t*/\n+/* of (char) c inside x at position i or earlier. The value i\t\t*/\n+/* must be < CORD_len(x).\t\t\t\t\t\t*/\n+size_t CORD_rchr(CORD x, size_t i, int c);\n+\n+\n+/* The following are also not primitive, but are implemented in \t*/\n+/* cordprnt.c.  They provide functionality similar to the ANSI C\t*/\n+/* functions with corresponding names, but with the following\t\t*/\n+/* additions and changes:\t\t\t\t\t\t*/\n+/* 1. A %r conversion specification specifies a CORD argument.  Field\t*/\n+/*    width, precision, etc. have the same semantics as for %s.\t\t*/\n+/*    (Note that %c,%C, and %S were already taken.)\t\t\t*/\n+/* 2. The format string is represented as a CORD.\t\t        */\n+/* 3. CORD_sprintf and CORD_vsprintf assign the result through the 1st\t*/ \t/*    argument.\tUnlike their ANSI C versions, there is no need to guess\t*/\n+/*    the correct buffer size.\t\t\t\t\t\t*/\n+/* 4. Most of the conversions are implement through the native \t\t*/\n+/*    vsprintf.  Hence they are usually no faster, and \t\t\t*/\n+/*    idiosyncracies of the native printf are preserved.  However,\t*/\n+/*    CORD arguments to CORD_sprintf and CORD_vsprintf are NOT copied;\t*/\n+/*    the result shares the original structure.  This may make them\t*/\n+/*    very efficient in some unusual applications.\t\t\t*/\n+/*    The format string is copied.\t\t\t\t\t*/\n+/* All functions return the number of characters generated or -1 on\t*/\n+/* error.  This complies with the ANSI standard, but is inconsistent\t*/\n+/* with some older implementations of sprintf.\t\t\t\t*/\n+\n+/* The implementation of these is probably less portable than the rest\t*/\n+/* of this package.\t\t\t\t\t\t\t*/\n+\n+#ifndef CORD_NO_IO\n+\n+#include <stdarg.h>\n+\n+int CORD_sprintf(CORD * out, CORD format, ...);\n+int CORD_vsprintf(CORD * out, CORD format, va_list args);\n+int CORD_fprintf(FILE * f, CORD format, ...);\n+int CORD_vfprintf(FILE * f, CORD format, va_list args);\n+int CORD_printf(CORD format, ...);\n+int CORD_vprintf(CORD format, va_list args);\n+\n+#endif /* CORD_NO_IO */\n+\n+# endif /* CORD_H */"}, {"sha": "c829b83ad110579334a525a9c964e53e155b2462", "filename": "boehm-gc/include/ec.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fec.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,70 @@\n+# ifndef EC_H\n+# define EC_H\n+\n+# ifndef CORD_H\n+#  include \"cord.h\"\n+# endif\n+\n+/* Extensible cords are strings that may be destructively appended to.\t*/\n+/* They allow fast construction of cords from characters that are\t*/\n+/* being read from a stream.\t\t\t\t\t\t*/\n+/*\n+ * A client might look like:\n+ *\n+ *\t{\n+ *\t    CORD_ec x;\n+ *\t    CORD result;\n+ *\t    char c;\n+ *\t    FILE *f;\n+ *\n+ *\t    ...\n+ *\t    CORD_ec_init(x);\n+ *\t    while(...) {\n+ *\t\tc = getc(f);\n+ *\t\t...\n+ *\t\tCORD_ec_append(x, c);\n+ *\t    }\n+ *\t    result = CORD_balance(CORD_ec_to_cord(x));\n+ *\n+ * If a C string is desired as the final result, the call to CORD_balance\n+ * may be replaced by a call to CORD_to_char_star.\n+ */\n+\n+# ifndef CORD_BUFSZ\n+#   define CORD_BUFSZ 128\n+# endif\n+\n+typedef struct CORD_ec_struct {\n+    CORD ec_cord;\n+    char * ec_bufptr;\n+    char ec_buf[CORD_BUFSZ+1];\n+} CORD_ec[1];\n+\n+/* This structure represents the concatenation of ec_cord with\t\t*/\n+/* ec_buf[0 ... (ec_bufptr-ec_buf-1)]\t\t\t\t\t*/\n+\n+/* Flush the buffer part of the extended chord into ec_cord.\t*/\n+/* Note that this is almost the only real function, and it is\t*/\n+/* implemented in 6 lines in cordxtra.c\t\t\t\t*/\n+void CORD_ec_flush_buf(CORD_ec x);\n+      \n+/* Convert an extensible cord to a cord. */\n+# define CORD_ec_to_cord(x) (CORD_ec_flush_buf(x), (x)[0].ec_cord)\n+\n+/* Initialize an extensible cord. */\n+# define CORD_ec_init(x) ((x)[0].ec_cord = 0, (x)[0].ec_bufptr = (x)[0].ec_buf)\n+\n+/* Append a character to an extensible cord.\t*/\n+# define CORD_ec_append(x, c) \\\n+    {  \\\n+\tif ((x)[0].ec_bufptr == (x)[0].ec_buf + CORD_BUFSZ) { \\\n+\t  \tCORD_ec_flush_buf(x); \\\n+\t} \\\n+\t*((x)[0].ec_bufptr)++ = (c); \\\n+    }\n+\n+/* Append a cord to an extensible cord.  Structure remains shared with \t*/\n+/* original.\t\t\t\t\t\t\t\t*/\n+void CORD_ec_append_cord(CORD_ec x, CORD s);\n+\n+# endif /* EC_H */"}, {"sha": "09c8ca8196c865c4ee975329c045ad7ea49956fb", "filename": "boehm-gc/include/gc.h", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,698 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+/*\n+ * Note that this defines a large number of tuning hooks, which can\n+ * safely be ignored in nearly all cases.  For normal use it suffices\n+ * to call only GC_MALLOC and perhaps GC_REALLOC.\n+ * For better performance, also look at GC_MALLOC_ATOMIC, and\n+ * GC_enable_incremental.  If you need an action to be performed\n+ * immediately before an object is collected, look at GC_register_finalizer.\n+ * If you are using Solaris threads, look at the end of this file.\n+ * Everything else is best ignored unless you encounter performance\n+ * problems.\n+ */\n+ \n+#ifndef _GC_H\n+\n+# define _GC_H\n+# define __GC\n+# include <stddef.h>\n+\n+#if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n+#include \"libgc_globals.h\"\n+#endif\n+\n+#if defined(_MSC_VER) && defined(_DLL)\n+#ifdef GC_BUILD\n+#define GC_API __declspec(dllexport)\n+#else\n+#define GC_API __declspec(dllimport)\n+#endif\n+#endif\n+\n+#ifndef GC_API\n+#define GC_API extern\n+#endif\n+\n+# if defined(__STDC__) || defined(__cplusplus)\n+#   define GC_PROTO(args) args\n+    typedef void * GC_PTR;\n+# else\n+#   define GC_PROTO(args) ()\n+    typedef char * GC_PTR;\n+#  endif\n+\n+# ifdef __cplusplus\n+    extern \"C\" {\n+# endif\n+\n+\n+/* Define word and signed_word to be unsigned and signed types of the \t*/\n+/* size as char * or void *.  There seems to be no way to do this\t*/\n+/* even semi-portably.  The following is probably no better/worse \t*/\n+/* than almost anything else.\t\t\t\t\t\t*/\n+/* The ANSI standard suggests that size_t and ptr_diff_t might be \t*/\n+/* better choices.  But those appear to have incorrect definitions\t*/\n+/* on may systems.  Notably \"typedef int size_t\" seems to be both\t*/\n+/* frequent and WRONG.\t\t\t\t\t\t\t*/\n+typedef unsigned long GC_word;\n+typedef long GC_signed_word;\n+\n+/* Public read-only variables */\n+\n+GC_API GC_word GC_gc_no;/* Counter incremented per collection.  \t*/\n+\t\t\t/* Includes empty GCs at startup.\t\t*/\n+\t\t\t\n+\n+/* Public R/W variables */\n+\n+GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n+\t\t\t/* When there is insufficient memory to satisfy */\n+\t\t\t/* an allocation request, we return\t\t*/\n+\t\t\t/* (*GC_oom_fn)().  By default this just\t*/\n+\t\t\t/* returns 0.\t\t\t\t\t*/\n+\t\t\t/* If it returns, it must return 0 or a valid\t*/\n+\t\t\t/* pointer to a previously allocated heap \t*/\n+\t\t\t/* object.\t\t\t\t\t*/\n+\n+GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n+\t\t\t/* collector has been compiled with statistics\t*/\n+\t\t\t/* enabled.  This involves a performance cost,\t*/\n+\t\t\t/* and is thus not the default.\t\t\t*/\n+\n+GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n+\t\t\t/* because it's not safe.\t\t\t  */\n+\n+GC_API int GC_dont_expand;\n+\t\t\t/* Dont expand heap unless explicitly requested */\n+\t\t\t/* or forced to.\t\t\t\t*/\n+\n+GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n+\t\t\t    /* full collections.  Matters only if\t*/\n+\t\t\t    /* GC_incremental is set.\t\t\t*/\n+\t\t\t\n+GC_API GC_word GC_non_gc_bytes;\n+\t\t\t/* Bytes not considered candidates for collection. */\n+\t\t\t/* Used only to control scheduling of collections. */\n+\n+GC_API GC_word GC_free_space_divisor;\n+\t\t\t/* We try to make sure that we allocate at \t*/\n+\t\t\t/* least N/GC_free_space_divisor bytes between\t*/\n+\t\t\t/* collections, where N is the heap size plus\t*/\n+\t\t\t/* a rough estimate of the root set size.\t*/\n+\t\t\t/* Initially, GC_free_space_divisor = 4.\t*/\n+\t\t\t/* Increasing its value will use less space\t*/\n+\t\t\t/* but more collection time.  Decreasing it\t*/\n+\t\t\t/* will appreciably decrease collection time\t*/\n+\t\t\t/* at the expense of space.\t\t\t*/\n+\t\t\t/* GC_free_space_divisor = 1 will effectively\t*/\n+\t\t\t/* disable collections.\t\t\t\t*/\n+\n+GC_API GC_word GC_max_retries;\n+\t\t\t/* The maximum number of GCs attempted before\t*/\n+\t\t\t/* reporting out of memory after heap\t\t*/\n+\t\t\t/* expansion fails.  Initially 0.\t\t*/\n+\t\t\t\n+\t\t\t\n+/* Public procedures */\n+/*\n+ * general purpose allocation routines, with roughly malloc calling conv.\n+ * The atomic versions promise that no relevant pointers are contained\n+ * in the object.  The nonatomic versions guarantee that the new object\n+ * is cleared.  GC_malloc_stubborn promises that no changes to the object\n+ * will occur after GC_end_stubborn_change has been called on the\n+ * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object\n+ * that is scanned for pointers to collectable objects, but is not itself\n+ * collectable.  GC_malloc_uncollectable and GC_free called on the resulting\n+ * object implicitly update GC_non_gc_bytes appropriately.\n+ */\n+GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_uncollectable GC_PROTO((size_t size_in_bytes));\n+GC_API GC_PTR GC_malloc_stubborn GC_PROTO((size_t size_in_bytes));\n+\n+/* The following is only defined if the library has been suitably\t*/\n+/* compiled:\t\t\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_malloc_atomic_uncollectable GC_PROTO((size_t size_in_bytes));\n+\n+/* Explicitly deallocate an object.  Dangerous if used incorrectly.     */\n+/* Requires a pointer to the base of an object.\t\t\t\t*/\n+/* If the argument is stubborn, it should not be changeable when freed. */\n+/* An object should not be enable for finalization when it is \t\t*/\n+/* explicitly deallocated.\t\t\t\t\t\t*/\n+/* GC_free(0) is a no-op, as required by ANSI C for free.\t\t*/\n+GC_API void GC_free GC_PROTO((GC_PTR object_addr));\n+\n+/*\n+ * Stubborn objects may be changed only if the collector is explicitly informed.\n+ * The collector is implicitly informed of coming change when such\n+ * an object is first allocated.  The following routines inform the\n+ * collector that an object will no longer be changed, or that it will\n+ * once again be changed.  Only nonNIL pointer stores into the object\n+ * are considered to be changes.  The argument to GC_end_stubborn_change\n+ * must be exacly the value returned by GC_malloc_stubborn or passed to\n+ * GC_change_stubborn.  (In the second case it may be an interior pointer\n+ * within 512 bytes of the beginning of the objects.)\n+ * There is a performance penalty for allowing more than\n+ * one stubborn object to be changed at once, but it is acceptable to\n+ * do so.  The same applies to dropping stubborn objects that are still\n+ * changeable.\n+ */\n+GC_API void GC_change_stubborn GC_PROTO((GC_PTR));\n+GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n+\n+/* Return a pointer to the base (lowest address) of an object given\t*/\n+/* a pointer to a location within the object.\t\t\t\t*/\n+/* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n+/* object.\t\t\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n+\n+/* Given a pointer to the base of an object, return its size in bytes.\t*/\n+/* The returned size may be slightly larger than what was originally\t*/\n+/* requested.\t\t\t\t\t\t\t\t*/\n+GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n+\n+/* For compatibility with C library.  This is occasionally faster than\t*/\n+/* a malloc followed by a bcopy.  But if you rely on that, either here\t*/\n+/* or with the standard C library, your code is broken.  In my\t\t*/\n+/* opinion, it shouldn't have been invented, but now we're stuck. -HB\t*/\n+/* The resulting object has the same kind as the original.\t\t*/\n+/* If the argument is stubborn, the result will have changes enabled.\t*/\n+/* It is an error to have changes enabled for the original object.\t*/\n+/* Follows ANSI comventions for NULL old_object.\t\t\t*/\n+GC_API GC_PTR GC_realloc GC_PROTO((GC_PTR old_object,\n+\t\t\t\t   size_t new_size_in_bytes));\n+\t\t\t\t   \n+/* Explicitly increase the heap size.\t*/\n+/* Returns 0 on failure, 1 on success.  */\n+GC_API int GC_expand_hp GC_PROTO((size_t number_of_bytes));\n+\n+/* Limit the heap size to n bytes.  Useful when you're debugging, \t*/\n+/* especially on systems that don't handle running out of memory well.\t*/\n+/* n == 0 ==> unbounded.  This is the default.\t\t\t\t*/\n+GC_API void GC_set_max_heap_size GC_PROTO((GC_word n));\n+\n+/* Inform the collector that a certain section of statically allocated\t*/\n+/* memory contains no pointers to garbage collected memory.  Thus it \t*/\n+/* need not be scanned.  This is sometimes important if the application */\n+/* maps large read/write files into the address space, which could be\t*/\n+/* mistaken for dynamic library data segments on some systems.\t\t*/\n+GC_API void GC_exclude_static_roots GC_PROTO((GC_PTR start, GC_PTR finish));\n+\n+/* Clear the set of root segments.  Wizards only. */\n+GC_API void GC_clear_roots GC_PROTO((void));\n+\n+/* Add a root segment.  Wizards only. */\n+GC_API void GC_add_roots GC_PROTO((char * low_address,\n+\t\t\t\t   char * high_address_plus_1));\n+\n+/* Add a displacement to the set of those considered valid by the\t*/\n+/* collector.  GC_register_displacement(n) means that if p was returned */\n+/* by GC_malloc, then (char *)p + n will be considered to be a valid\t*/\n+/* pointer to n.  N must be small and less than the size of p.\t\t*/\n+/* (All pointers to the interior of objects from the stack are\t\t*/\n+/* considered valid in any case.  This applies to heap objects and\t*/\n+/* static data.)\t\t\t\t\t\t\t*/\n+/* Preferably, this should be called before any other GC procedures.\t*/\n+/* Calling it later adds to the probability of excess memory\t\t*/\n+/* retention.\t\t\t\t\t\t\t\t*/\n+/* This is a no-op if the collector was compiled with recognition of\t*/\n+/* arbitrary interior pointers enabled, which is now the default.\t*/\n+GC_API void GC_register_displacement GC_PROTO((GC_word n));\n+\n+/* The following version should be used if any debugging allocation is\t*/\n+/* being done.\t\t\t\t\t\t\t\t*/\n+GC_API void GC_debug_register_displacement GC_PROTO((GC_word n));\n+\n+/* Explicitly trigger a full, world-stop collection. \t*/\n+GC_API void GC_gcollect GC_PROTO((void));\n+\n+/* Trigger a full world-stopped collection.  Abort the collection if \t*/\n+/* and when stop_func returns a nonzero value.  Stop_func will be \t*/\n+/* called frequently, and should be reasonably fast.  This works even\t*/\n+/* if virtual dirty bits, and hence incremental collection is not \t*/\n+/* available for this architecture.  Collections can be aborted faster\t*/\n+/* than normal pause times for incremental collection.  However,\t*/\n+/* aborted collections do no useful work; the next collection needs\t*/\n+/* to start from the beginning.\t\t\t\t\t\t*/\n+typedef int (* GC_stop_func) GC_PROTO((void));\n+GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n+\n+/* Return the number of bytes in the heap.  Excludes collector private\t*/\n+/* data structures.  Includes empty blocks and fragmentation loss.\t*/\n+/* Includes some pages that were allocated but never written.\t\t*/\n+GC_API size_t GC_get_heap_size GC_PROTO((void));\n+\n+/* Return the number of bytes allocated since the last collection.\t*/\n+GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n+\n+/* Enable incremental/generational collection.\t*/\n+/* Not advisable unless dirty bits are \t\t*/\n+/* available or most heap objects are\t\t*/\n+/* pointerfree(atomic) or immutable.\t\t*/\n+/* Don't use in leak finding mode.\t\t*/\n+/* Ignored if GC_dont_gc is true.\t\t*/\n+GC_API void GC_enable_incremental GC_PROTO((void));\n+\n+/* Perform some garbage collection work, if appropriate.\t*/\n+/* Return 0 if there is no more work to be done.\t\t*/\n+/* Typically performs an amount of work corresponding roughly\t*/\n+/* to marking from one page.  May do more work if further\t*/\n+/* progress requires it, e.g. if incremental collection is\t*/\n+/* disabled.  It is reasonable to call this in a wait loop\t*/\n+/* until it returns 0.\t\t\t\t\t\t*/\n+GC_API int GC_collect_a_little GC_PROTO((void));\n+\n+/* Allocate an object of size lb bytes.  The client guarantees that\t*/\n+/* as long as the object is live, it will be referenced by a pointer\t*/\n+/* that points to somewhere within the first 256 bytes of the object.\t*/\n+/* (This should normally be declared volatile to prevent the compiler\t*/\n+/* from invalidating this assertion.)  This routine is only useful\t*/\n+/* if a large array is being allocated.  It reduces the chance of \t*/\n+/* accidentally retaining such an array as a result of scanning an\t*/\n+/* integer that happens to be an address inside the array.  (Actually,\t*/\n+/* it reduces the chance of the allocator not finding space for such\t*/\n+/* an array, since it will try hard to avoid introducing such a false\t*/\n+/* reference.)  On a SunOS 4.X or MS Windows system this is recommended */\n+/* for arrays likely to be larger than 100K or so.  For other systems,\t*/\n+/* or if the collector is not configured to recognize all interior\t*/\n+/* pointers, the threshold is normally much higher.\t\t\t*/\n+GC_API GC_PTR GC_malloc_ignore_off_page GC_PROTO((size_t lb));\n+GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n+\n+#if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720\n+#   define GC_ADD_CALLER\n+#   define GC_RETURN_ADDR (GC_word)__return_address\n+#endif\n+\n+#ifdef GC_ADD_CALLER\n+#  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n+#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int\n+#else\n+#  define GC_EXTRAS __FILE__, __LINE__\n+#  define GC_EXTRA_PARAMS char * descr_string, int descr_int\n+#endif\n+\n+/* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n+/* objects allocated in this way for overwrites, etc.\t\t\t*/\n+GC_API GC_PTR GC_debug_malloc\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_atomic\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_uncollectable\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API GC_PTR GC_debug_malloc_stubborn\n+\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n+GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));\n+GC_API GC_PTR GC_debug_realloc\n+\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,\n+  \t\t  GC_EXTRA_PARAMS));\n+  \t\t\t \t \n+GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));\n+GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n+# ifdef GC_DEBUG\n+#   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)\n+#   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \\\n+\t\t\t\t\t\t\tGC_EXTRAS)\n+#   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)\n+#   define GC_FREE(p) GC_debug_free(p)\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n+#   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n+#   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n+#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n+\tGC_general_register_disappearing_link(link, GC_base(obj))\n+#   define GC_REGISTER_DISPLACEMENT(n) GC_debug_register_displacement(n)\n+# else\n+#   define GC_MALLOC(sz) GC_malloc(sz)\n+#   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)\n+#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)\n+#   define GC_REALLOC(old, sz) GC_realloc(old, sz)\n+#   define GC_FREE(p) GC_free(p)\n+#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n+\tGC_register_finalizer(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n+\tGC_register_finalizer_ignore_self(p, f, d, of, od)\n+#   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n+#   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n+#   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n+#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n+\tGC_general_register_disappearing_link(link, obj)\n+#   define GC_REGISTER_DISPLACEMENT(n) GC_register_displacement(n)\n+# endif\n+/* The following are included because they are often convenient, and\t*/\n+/* reduce the chance for a misspecifed size argument.  But calls may\t*/\n+/* expand to something syntactically incorrect if t is a complicated\t*/\n+/* type expression.  \t\t\t\t\t\t\t*/\n+# define GC_NEW(t) (t *)GC_MALLOC(sizeof (t))\n+# define GC_NEW_ATOMIC(t) (t *)GC_MALLOC_ATOMIC(sizeof (t))\n+# define GC_NEW_STUBBORN(t) (t *)GC_MALLOC_STUBBORN(sizeof (t))\n+# define GC_NEW_UNCOLLECTABLE(t) (t *)GC_MALLOC_UNCOLLECTABLE(sizeof (t))\n+\n+/* Finalization.  Some of these primitives are grossly unsafe.\t\t*/\n+/* The idea is to make them both cheap, and sufficient to build\t\t*/\n+/* a safer layer, closer to PCedar finalization.\t\t\t*/\n+/* The interface represents my conclusions from a long discussion\t*/\n+/* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, \t\t*/\n+/* Christian Jacobi, and Russ Atkinson.  It's not perfect, and\t\t*/\n+/* probably nobody else agrees with it.\t    Hans-J. Boehm  3/13/92\t*/\n+typedef void (*GC_finalization_proc)\n+  \tGC_PROTO((GC_PTR obj, GC_PTR client_data));\n+\n+GC_API void GC_register_finalizer\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\t/* When obj is no longer accessible, invoke\t\t*/\n+\t/* (*fn)(obj, cd).  If a and b are inaccessible, and\t*/\n+\t/* a points to b (after disappearing links have been\t*/\n+\t/* made to disappear), then only a will be\t\t*/\n+\t/* finalized.  (If this does not create any new\t\t*/\n+\t/* pointers to b, then b will be finalized after the\t*/\n+\t/* next collection.)  Any finalizable object that\t*/\n+\t/* is reachable from itself by following one or more\t*/\n+\t/* pointers will not be finalized (or collected).\t*/\n+\t/* Thus cycles involving finalizable objects should\t*/\n+\t/* be avoided, or broken by disappearing links.\t\t*/\n+\t/* All but the last finalizer registered for an object  */\n+\t/* is ignored.\t\t\t\t\t\t*/\n+\t/* Finalization may be removed by passing 0 as fn.\t*/\n+\t/* Finalizers are implicitly unregistered just before   */\n+\t/* they are invoked.\t\t\t\t\t*/\n+\t/* The old finalizer and client data are stored in\t*/\n+\t/* *ofn and *ocd.\t\t\t\t\t*/ \n+\t/* Fn is never invoked on an accessible object,\t\t*/\n+\t/* provided hidden pointers are converted to real \t*/\n+\t/* pointers only if the allocation lock is held, and\t*/\n+\t/* such conversions are not performed by finalization\t*/\n+\t/* routines.\t\t\t\t\t\t*/\n+\t/* If GC_register_finalizer is aborted as a result of\t*/\n+\t/* a signal, the object may be left with no\t\t*/\n+\t/* finalization, even if neither the old nor new\t*/\n+\t/* finalizer were NULL.\t\t\t\t\t*/\n+\t/* Obj should be the nonNULL starting address of an \t*/\n+\t/* object allocated by GC_malloc or friends.\t\t*/\n+\t/* Note that any garbage collectable object referenced\t*/\n+\t/* by cd will be considered accessible until the\t*/\n+\t/* finalizer is invoked.\t\t\t\t*/\n+\n+/* Another versions of the above follow.  It ignores\t\t*/\n+/* self-cycles, i.e. pointers from a finalizable object to\t*/\n+/* itself.  There is a stylistic argument that this is wrong,\t*/\n+/* but it's unavoidable for C++, since the compiler may\t\t*/\n+/* silently introduce these.  It's also benign in that specific\t*/\n+/* case.\t\t\t\t\t\t\t*/\n+GC_API void GC_register_finalizer_ignore_self\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer_ignore_self\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+\n+/* The following routine may be used to break cycles between\t*/\n+/* finalizable objects, thus causing cyclic finalizable\t\t*/\n+/* objects to be finalized in the correct order.  Standard\t*/\n+/* use involves calling GC_register_disappearing_link(&p),\t*/\n+/* where p is a pointer that is not followed by finalization\t*/\n+/* code, and should not be considered in determining \t\t*/\n+/* finalization order.\t\t\t\t\t\t*/\n+GC_API int GC_register_disappearing_link GC_PROTO((GC_PTR * /* link */));\n+\t/* Link should point to a field of a heap allocated \t*/\n+\t/* object obj.  *link will be cleared when obj is\t*/\n+\t/* found to be inaccessible.  This happens BEFORE any\t*/\n+\t/* finalization code is invoked, and BEFORE any\t\t*/\n+\t/* decisions about finalization order are made.\t\t*/\n+\t/* This is useful in telling the finalizer that \t*/\n+\t/* some pointers are not essential for proper\t\t*/\n+\t/* finalization.  This may avoid finalization cycles.\t*/\n+\t/* Note that obj may be resurrected by another\t\t*/\n+\t/* finalizer, and thus the clearing of *link may\t*/\n+\t/* be visible to non-finalization code.  \t\t*/\n+\t/* There's an argument that an arbitrary action should  */\n+\t/* be allowed here, instead of just clearing a pointer. */\n+\t/* But this causes problems if that action alters, or \t*/\n+\t/* examines connectivity.\t\t\t\t*/\n+\t/* Returns 1 if link was already registered, 0\t\t*/\n+\t/* otherwise.\t\t\t\t\t\t*/\n+\t/* Only exists for backward compatibility.  See below:\t*/\n+\t\n+GC_API int GC_general_register_disappearing_link\n+\tGC_PROTO((GC_PTR * /* link */, GC_PTR obj));\n+\t/* A slight generalization of the above. *link is\t*/\n+\t/* cleared when obj first becomes inaccessible.  This\t*/\n+\t/* can be used to implement weak pointers easily and\t*/\n+\t/* safely. Typically link will point to a location\t*/\n+\t/* holding a disguised pointer to obj.  (A pointer \t*/\n+\t/* inside an \"atomic\" object is effectively  \t\t*/\n+\t/* disguised.)   In this way soft\t\t\t*/\n+\t/* pointers are broken before any object\t\t*/\n+\t/* reachable from them are finalized.  Each link\t*/\n+\t/* May be registered only once, i.e. with one obj\t*/\n+\t/* value.  This was added after a long email discussion */\n+\t/* with John Ellis.\t\t\t\t\t*/\n+\t/* Obj must be a pointer to the first word of an object */\n+\t/* we allocated.  It is unsafe to explicitly deallocate */\n+\t/* the object containing link.  Explicitly deallocating */\n+\t/* obj may or may not cause link to eventually be\t*/\n+\t/* cleared.\t\t\t\t\t\t*/\n+GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n+\t/* Returns 0 if link was not actually registered.\t*/\n+\t/* Undoes a registration by either of the above two\t*/\n+\t/* routines.\t\t\t\t\t\t*/\n+\n+/* Auxiliary fns to make finalization work correctly with displaced\t*/\n+/* pointers introduced by the debugging allocators.\t\t\t*/\n+GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n+GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n+\n+GC_API int GC_invoke_finalizers GC_PROTO((void));\n+\t/* Run finalizers for all objects that are ready to\t*/\n+\t/* be finalized.  Return the number of finalizers\t*/\n+\t/* that were run.  Normally this is also called\t\t*/\n+\t/* implicitly during some allocations.\tIf\t\t*/\n+\t/* FINALIZE_ON_DEMAND is defined, it must be called\t*/\n+\t/* explicitly.\t\t\t\t\t\t*/\n+\n+/* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n+/* p may not be a NULL pointer.\t\t\t\t\t\t*/\n+typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));\n+GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n+    /* Returns old warning procedure.\t*/\n+\t\n+/* The following is intended to be used by a higher level\t*/\n+/* (e.g. cedar-like) finalization facility.  It is expected\t*/\n+/* that finalization code will arrange for hidden pointers to\t*/\n+/* disappear.  Otherwise objects can be accessed after they\t*/\n+/* have been collected.\t\t\t\t\t\t*/\n+/* Note that putting pointers in atomic objects or in \t\t*/\n+/* nonpointer slots of \"typed\" objects is equivalent to \t*/\n+/* disguising them in this way, and may have other advantages.\t*/\n+# if defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)\n+    typedef GC_word GC_hidden_pointer;\n+#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))\n+#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))\n+    /* Converting a hidden pointer to a real pointer requires verifying\t*/\n+    /* that the object still exists.  This involves acquiring the  \t*/\n+    /* allocator lock to avoid a race with the collector.\t\t*/\n+# endif /* I_HIDE_POINTERS */\n+\n+typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));\n+GC_API GC_PTR GC_call_with_alloc_lock\n+        \tGC_PROTO((GC_fn_type fn, GC_PTR client_data));\n+\n+/* Check that p and q point to the same object.  \t\t*/\n+/* Fail conspicuously if they don't.\t\t\t\t*/\n+/* Returns the first argument.  \t\t\t\t*/\n+/* Succeeds if neither p nor q points to the heap.\t\t*/\n+/* May succeed if both p and q point to between heap objects.\t*/\n+GC_API GC_PTR GC_same_obj GC_PROTO((GC_PTR p, GC_PTR q));\n+\n+/* Checked pointer pre- and post- increment operations.  Note that\t*/\n+/* the second argument is in units of bytes, not multiples of the\t*/\n+/* object size.  This should either be invoked from a macro, or the\t*/\n+/* call should be automatically generated.\t\t\t\t*/\n+GC_API GC_PTR GC_pre_incr GC_PROTO((GC_PTR *p, size_t how_much));\n+GC_API GC_PTR GC_post_incr GC_PROTO((GC_PTR *p, size_t how_much));\n+\n+/* Check that p is visible\t\t\t\t\t\t*/\n+/* to the collector as a possibly pointer containing location.\t\t*/\n+/* If it isn't fail conspicuously.\t\t\t\t\t*/\n+/* Returns the argument in all cases.  May erroneously succeed\t\t*/\n+/* in hard cases.  (This is intended for debugging use with\t\t*/\n+/* untyped allocations.  The idea is that it should be possible, though\t*/\n+/* slow, to add such a call to all indirect pointer stores.)\t\t*/\n+/* Currently useless for multithreaded worlds.\t\t\t\t*/\n+GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));\n+\n+/* Check that if p is a pointer to a heap page, then it points to\t*/\n+/* a valid displacement within a heap object.\t\t\t\t*/\n+/* Fail conspicuously if this property does not hold.\t\t\t*/\n+/* Uninteresting with ALL_INTERIOR_POINTERS.\t\t\t\t*/\n+/* Always returns its argument.\t\t\t\t\t\t*/\n+GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n+\n+/* Safer, but slow, pointer addition.  Probably useful mainly with \t*/\n+/* a preprocessor.  Useful only for heap pointers.\t\t\t*/\n+#ifdef GC_DEBUG\n+#   define GC_PTR_ADD3(x, n, type_of_result) \\\n+\t((type_of_result)GC_same_obj((x)+(n), (x)))\n+#   define GC_PRE_INCR3(x, n, type_of_result) \\\n+\t((type_of_result)GC_pre_incr(&(x), (n)*sizeof(*x))\n+#   define GC_POST_INCR2(x, type_of_result) \\\n+\t((type_of_result)GC_post_incr(&(x), sizeof(*x))\n+#   ifdef __GNUC__\n+#       define GC_PTR_ADD(x, n) \\\n+\t    GC_PTR_ADD3(x, n, typeof(x))\n+#   define GC_PRE_INCR(x, n) \\\n+\t    GC_PRE_INCR3(x, n, typeof(x))\n+#   define GC_POST_INCR(x, n) \\\n+\t    GC_POST_INCR3(x, typeof(x))\n+#   else\n+\t/* We can't do this right without typeof, which ANSI\t*/\n+\t/* decided was not sufficiently useful.  Repeatedly\t*/\n+\t/* mentioning the arguments seems too dangerous to be\t*/\n+\t/* useful.  So does not casting the result.\t\t*/\n+#   \tdefine GC_PTR_ADD(x, n) ((x)+(n))\n+#   endif\n+#else\t/* !GC_DEBUG */\n+#   define GC_PTR_ADD3(x, n, type_of_result) ((x)+(n))\n+#   define GC_PTR_ADD(x, n) ((x)+(n))\n+#   define GC_PRE_INCR3(x, n, type_of_result) ((x) += (n))\n+#   define GC_PRE_INCR(x, n) ((x) += (n))\n+#   define GC_POST_INCR2(x, n, type_of_result) ((x)++)\n+#   define GC_POST_INCR(x, n) ((x)++)\n+#endif\n+\n+/* Safer assignment of a pointer to a nonstack location.\t*/\n+#ifdef GC_DEBUG\n+# ifdef __STDC__\n+#   define GC_PTR_STORE(p, q) \\\n+\t(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))\n+# else\n+#   define GC_PTR_STORE(p, q) \\\n+\t(*(char **)GC_is_visible(p) = GC_is_valid_displacement(q))\n+# endif\n+#else /* !GC_DEBUG */\n+#   define GC_PTR_STORE(p, q) *((p) = (q))\n+#endif\n+\n+/* Fynctions called to report pointer checking errors */\n+GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));\n+\n+GC_API void (*GC_is_valid_displacement_print_proc)\n+\tGC_PROTO((GC_PTR p));\n+\n+GC_API void (*GC_is_visible_print_proc)\n+\tGC_PROTO((GC_PTR p));\n+\n+#ifdef SOLARIS_THREADS\n+/* We need to intercept calls to many of the threads primitives, so \t*/\n+/* that we can locate thread stacks and stop the world.\t\t\t*/\n+/* Note also that the collector cannot see thread specific data.\t*/\n+/* Thread specific data should generally consist of pointers to\t\t*/\n+/* uncollectable objects, which are deallocated using the destructor\t*/\n+/* facility in thr_keycreate.\t\t\t\t\t\t*/\n+# include <thread.h>\n+# include <signal.h>\n+  int GC_thr_create(void *stack_base, size_t stack_size,\n+                    void *(*start_routine)(void *), void *arg, long flags,\n+                    thread_t *new_thread);\n+  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n+  int GC_thr_suspend(thread_t target_thread);\n+  int GC_thr_continue(thread_t target_thread);\n+  void * GC_dlopen(const char *path, int mode);\n+\n+# ifdef _SOLARIS_PTHREADS\n+#   include <pthread.h>\n+    extern int GC_pthread_create(pthread_t *new_thread,\n+    \t\t\t         const pthread_attr_t *attr,\n+          \t\t\t void * (*thread_execp)(void *), void *arg);\n+    extern int GC_pthread_join(pthread_t wait_for, void **status);\n+\n+#   undef thread_t\n+\n+#   define pthread_join GC_pthread_join\n+#   define pthread_create GC_pthread_create\n+#endif\n+\n+# define thr_create GC_thr_create\n+# define thr_join GC_thr_join\n+# define thr_suspend GC_thr_suspend\n+# define thr_continue GC_thr_continue\n+# define dlopen GC_dlopen\n+\n+# endif /* SOLARIS_THREADS */\n+\n+\n+#if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+/* We treat these similarly. */\n+# include <pthread.h>\n+# include <signal.h>\n+\n+  int GC_pthread_create(pthread_t *new_thread,\n+                        const pthread_attr_t *attr,\n+\t\t        void *(*start_routine)(void *), void *arg);\n+  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n+  int GC_pthread_join(pthread_t thread, void **retval);\n+\n+# define pthread_create GC_pthread_create\n+# define pthread_sigmask GC_pthread_sigmask\n+# define pthread_join GC_pthread_join\n+\n+#endif /* IRIX_THREADS || LINUX_THREADS */\n+\n+#if defined(THREADS) && !defined(SRC_M3)\n+/* This returns a list of objects, linked through their first\t\t*/\n+/* word.  Its use can greatly reduce lock contention problems, since\t*/\n+/* the allocation lock can be acquired and released many fewer times.\t*/\n+GC_PTR GC_malloc_many(size_t lb);\n+#define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n+\t\t\t\t\t/* in returned list.\t\t*/\n+extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n+\n+#endif /* THREADS && !SRC_M3 */\n+\n+/*\n+ * If you are planning on putting\n+ * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n+ * from the statically loaded program section.\n+ * This circumvents a Solaris 2.X (X<=4) linker bug.\n+ */\n+#if defined(sparc) || defined(__sparc)\n+#   define GC_INIT() { extern end, etext; \\\n+\t\t       GC_noop(&end, &etext); }\n+#else\n+# if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n+    /*\n+     * Similarly gnu-win32 DLLs need explicit initialization\n+     */\n+#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n+# else\n+#   define GC_INIT()\n+# endif\n+#endif\n+\n+#ifdef __cplusplus\n+    }  /* end of extern \"C\" */\n+#endif\n+\n+#endif /* _GC_H */"}, {"sha": "1d912db2f0b0048df400dead3fb9a7f8b6cc7abe", "filename": "boehm-gc/include/gc_alloc.h", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_alloc.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+\n+//\n+// This is a C++ header file that is intended to replace the SGI STL\n+// alloc.h.\n+//\n+// This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n+// and -DALL_INTERIOR_POINTERS.  We also recommend\n+// -DREDIRECT_MALLOC=GC_uncollectable_malloc.\n+//\n+// Some of this could be faster in the explicit deallocation case.  In particular,\n+// we spend too much time clearing objects on the free lists.  That could be avoided.\n+//\n+// This uses template classes with static members, and hence does not work\n+// with g++ 2.7.2 and earlier.\n+//\n+\n+#include \"gc.h\"\n+\n+#ifndef GC_ALLOC_H\n+\n+#define GC_ALLOC_H\n+#define __ALLOC_H\t// Prevent inclusion of the default version.  Ugly.\n+#define __SGI_STL_ALLOC_H\n+#define __SGI_STL_INTERNAL_ALLOC_H\n+\n+#ifndef __ALLOC\n+#   define __ALLOC alloc\n+#endif\n+\n+#include <stddef.h>\n+#include <string.h>\n+\n+// The following is just replicated from the conventional SGI alloc.h:\n+\n+template<class T, class alloc>\n+class simple_alloc {\n+\n+public:\n+    static T *allocate(size_t n)\n+                { return 0 == n? 0 : (T*) alloc::allocate(n * sizeof (T)); }\n+    static T *allocate(void)\n+                { return (T*) alloc::allocate(sizeof (T)); }\n+    static void deallocate(T *p, size_t n)\n+                { if (0 != n) alloc::deallocate(p, n * sizeof (T)); }\n+    static void deallocate(T *p)\n+                { alloc::deallocate(p, sizeof (T)); }\n+};\n+\n+#include \"gc.h\"\n+\n+// The following need to match collector data structures.\n+// We can't include gc_priv.h, since that pulls in way too much stuff.\n+// This should eventually be factored out into another include file.\n+\n+extern \"C\" {\n+    extern void ** const GC_objfreelist_ptr;\n+    extern void ** const GC_aobjfreelist_ptr;\n+    extern void ** const GC_uobjfreelist_ptr;\n+    extern void ** const GC_auobjfreelist_ptr;\n+\n+    extern void GC_incr_words_allocd(size_t words);\n+    extern void GC_incr_mem_freed(size_t words);\n+\n+    extern char * GC_generic_malloc_words_small(size_t word, int kind);\n+}\n+\n+// Object kinds; must match PTRFREE, NORMAL, UNCOLLECTABLE, and\n+// AUNCOLLECTABLE in gc_priv.h.\n+\n+enum { GC_PTRFREE = 0, GC_NORMAL = 1, GC_UNCOLLECTABLE = 2,\n+       GC_AUNCOLLECTABLE = 3 };\n+\n+enum { GC_max_fast_bytes = 255 };\n+\n+enum { GC_bytes_per_word = sizeof(char *) };\n+\n+enum { GC_byte_alignment = 8 };\n+\n+enum { GC_word_alignment = GC_byte_alignment/GC_bytes_per_word };\n+\n+inline void * &GC_obj_link(void * p)\n+{   return *(void **)p;  }\n+\n+// Compute a number of words >= n+1 bytes.\n+// The +1 allows for pointers one past the end.\n+inline size_t GC_round_up(size_t n)\n+{\n+    return ((n + GC_byte_alignment)/GC_byte_alignment)*GC_word_alignment;\n+}\n+\n+// The same but don't allow for extra byte.\n+inline size_t GC_round_up_uncollectable(size_t n)\n+{\n+    return ((n + GC_byte_alignment - 1)/GC_byte_alignment)*GC_word_alignment;\n+}\n+\n+template <int dummy>\n+class GC_aux_template {\n+public:\n+  // File local count of allocated words.  Occasionally this is\n+  // added into the global count.  A separate count is necessary since the\n+  // real one must be updated with a procedure call.\n+  static size_t GC_words_recently_allocd;\n+\n+  // Same for uncollectable mmory.  Not yet reflected in either\n+  // GC_words_recently_allocd or GC_non_gc_bytes.\n+  static size_t GC_uncollectable_words_recently_allocd;\n+\n+  // Similar counter for explicitly deallocated memory.\n+  static size_t GC_mem_recently_freed;\n+\n+  // Again for uncollectable memory.\n+  static size_t GC_uncollectable_mem_recently_freed;\n+\n+  static void * GC_out_of_line_malloc(size_t nwords, int kind);\n+};\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_words_recently_allocd = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_uncollectable_words_recently_allocd = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_mem_recently_freed = 0;\n+\n+template <int dummy>\n+size_t GC_aux_template<dummy>::GC_uncollectable_mem_recently_freed = 0;\n+\n+template <int dummy>\n+void * GC_aux_template<dummy>::GC_out_of_line_malloc(size_t nwords, int kind)\n+{\n+    GC_words_recently_allocd += GC_uncollectable_words_recently_allocd;\n+    GC_non_gc_bytes +=\n+                GC_bytes_per_word * GC_uncollectable_words_recently_allocd;\n+    GC_uncollectable_words_recently_allocd = 0;\n+\n+    GC_mem_recently_freed += GC_uncollectable_mem_recently_freed;\n+    GC_non_gc_bytes -= \n+                GC_bytes_per_word * GC_uncollectable_mem_recently_freed;\n+    GC_uncollectable_mem_recently_freed = 0;\n+\n+    GC_incr_words_allocd(GC_words_recently_allocd);\n+    GC_words_recently_allocd = 0;\n+\n+    GC_incr_mem_freed(GC_mem_recently_freed);\n+    GC_mem_recently_freed = 0;\n+\n+    return GC_generic_malloc_words_small(nwords, kind);\n+}\n+\n+typedef GC_aux_template<0> GC_aux;\n+\n+// A fast, single-threaded, garbage-collected allocator\n+// We assume the first word will be immediately overwritten.\n+// In this version, deallocation is not a noop, and explicit\n+// deallocation is likely to help performance.\n+template <int dummy>\n+class single_client_gc_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc(n);\n+\t    flh = GC_objfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_NORMAL);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic(n);\n+\t    flh = GC_aobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_PTRFREE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+\tstatic void deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes)  {\n+\t\tGC_free(p);\n+\t    } else {\n+\t        flh = GC_objfreelist_ptr + nwords;\n+\t        GC_obj_link(p) = *flh;\n+\t\tmemset((char *)p + GC_bytes_per_word, 0,\n+\t\t       GC_bytes_per_word * (nwords - 1));\n+\t        *flh = p;\n+\t        GC_aux::GC_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+\tstatic void ptr_free_deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes) {\n+\t\tGC_free(p);\n+\t    } else {\n+\t    \tflh = GC_aobjfreelist_ptr + nwords;\n+\t    \tGC_obj_link(p) = *flh;\n+\t    \t*flh = p;\n+\t    \tGC_aux::GC_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+};\n+\n+typedef single_client_gc_alloc_template<0> single_client_gc_alloc;\n+\n+// Once more, for uncollectable objects.\n+template <int dummy>\n+class single_client_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up_uncollectable(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_uncollectable(n);\n+\t    flh = GC_uobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_UNCOLLECTABLE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+        {\n+\t    size_t nwords = GC_round_up_uncollectable(n);\n+\t    void ** flh;\n+\t    void * op;\n+\n+  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic_uncollectable(n);\n+\t    flh = GC_auobjfreelist_ptr + nwords;\n+\t    if (0 == (op = *flh)) {\n+\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_AUNCOLLECTABLE);\n+\t    }\n+\t    *flh = GC_obj_link(op);\n+\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n+\t    return op;\n+        }\n+\tstatic void deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up_uncollectable(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes)  {\n+\t\tGC_free(p);\n+\t    } else {\n+\t        flh = GC_uobjfreelist_ptr + nwords;\n+\t        GC_obj_link(p) = *flh;\n+\t        *flh = p;\n+\t        GC_aux::GC_uncollectable_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+\tstatic void ptr_free_deallocate(void *p, size_t n)\n+\t{\n+            size_t nwords = GC_round_up_uncollectable(n);\n+            void ** flh;\n+\t   \n+\t    if (n > GC_max_fast_bytes) {\n+\t\tGC_free(p);\n+\t    } else {\n+\t    \tflh = GC_auobjfreelist_ptr + nwords;\n+\t    \tGC_obj_link(p) = *flh;\n+\t    \t*flh = p;\n+\t    \tGC_aux::GC_uncollectable_mem_recently_freed += nwords;\n+\t    }\n+\t}\n+};\n+\n+typedef single_client_alloc_template<0> single_client_alloc;\n+\n+template < int dummy >\n+class gc_alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n) { return GC_malloc(n); }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+\t\t{ return GC_malloc_atomic(n); }\n+\tstatic void deallocate(void *, size_t) { }\n+\tstatic void ptr_free_deallocate(void *, size_t) { }\n+};\n+\n+typedef gc_alloc_template < 0 > gc_alloc;\n+\n+template < int dummy >\n+class alloc_template {\n+    public:\n+     \tstatic void * allocate(size_t n) { return GC_malloc_uncollectable(n); }\n+     \tstatic void * ptr_free_allocate(size_t n)\n+\t\t{ return GC_malloc_atomic_uncollectable(n); }\n+\tstatic void deallocate(void *p, size_t) { GC_free(p); }\n+\tstatic void ptr_free_deallocate(void *p, size_t) { GC_free(p); }\n+};\n+\n+typedef alloc_template < 0 > alloc;\n+\n+#ifdef _SGI_SOURCE\n+\n+// We want to specialize simple_alloc so that it does the right thing\n+// for all pointerfree types.  At the moment there is no portable way to\n+// even approximate that.  The following approximation should work for\n+// SGI compilers, and perhaps some others.\n+\n+# define __GC_SPECIALIZE(T,alloc) \\\n+class simple_alloc<T, alloc> { \\\n+public: \\\n+    static T *allocate(size_t n) \\\n+\t{ return 0 == n? 0 : \\\n+\t\t\t (T*) alloc::ptr_free_allocate(n * sizeof (T)); } \\\n+    static T *allocate(void) \\\n+\t{ return (T*) alloc::ptr_free_allocate(sizeof (T)); } \\\n+    static void deallocate(T *p, size_t n) \\\n+\t{ if (0 != n) alloc::ptr_free_deallocate(p, n * sizeof (T)); } \\\n+    static void deallocate(T *p) \\\n+\t{ alloc::ptr_free_deallocate(p, sizeof (T)); } \\\n+};\n+\n+__GC_SPECIALIZE(char, gc_alloc)\n+__GC_SPECIALIZE(int, gc_alloc)\n+__GC_SPECIALIZE(unsigned, gc_alloc)\n+__GC_SPECIALIZE(float, gc_alloc)\n+__GC_SPECIALIZE(double, gc_alloc)\n+\n+__GC_SPECIALIZE(char, alloc)\n+__GC_SPECIALIZE(int, alloc)\n+__GC_SPECIALIZE(unsigned, alloc)\n+__GC_SPECIALIZE(float, alloc)\n+__GC_SPECIALIZE(double, alloc)\n+\n+__GC_SPECIALIZE(char, single_client_gc_alloc)\n+__GC_SPECIALIZE(int, single_client_gc_alloc)\n+__GC_SPECIALIZE(unsigned, single_client_gc_alloc)\n+__GC_SPECIALIZE(float, single_client_gc_alloc)\n+__GC_SPECIALIZE(double, single_client_gc_alloc)\n+\n+__GC_SPECIALIZE(char, single_client_alloc)\n+__GC_SPECIALIZE(int, single_client_alloc)\n+__GC_SPECIALIZE(unsigned, single_client_alloc)\n+__GC_SPECIALIZE(float, single_client_alloc)\n+__GC_SPECIALIZE(double, single_client_alloc)\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+???copy stuff from stl_alloc.h or remove it to a different file ???\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+#endif /* _SGI_SOURCE */\n+\n+#endif /* GC_ALLOC_H */"}, {"sha": "e2f456fb526a746b9405db0bb0b119aab99a414a", "filename": "boehm-gc/include/gc_cpp.h", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,287 @@\n+#ifndef GC_CPP_H\n+#define GC_CPP_H\n+/****************************************************************************\n+Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ \n+THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ \n+Permission is hereby granted to use or copy this program for any\n+purpose, provided the above notices are retained on all copies.\n+Permission to modify the code and to distribute modified code is\n+granted, provided the above notices are retained, and a notice that\n+the code was modified is included with the above copyright notice.\n+****************************************************************************\n+\n+C++ Interface to the Boehm Collector\n+\n+    John R. Ellis and Jesse Hull \n+    Last modified on Mon Jul 24 15:43:42 PDT 1995 by ellis\n+\n+This interface provides access to the Boehm collector.  It provides\n+basic facilities similar to those described in \"Safe, Efficient\n+Garbage Collection for C++\", by John R. Elis and David L. Detlefs\n+(ftp.parc.xerox.com:/pub/ellis/gc).\n+\n+All heap-allocated objects are either \"collectable\" or\n+\"uncollectable\".  Programs must explicitly delete uncollectable\n+objects, whereas the garbage collector will automatically delete\n+collectable objects when it discovers them to be inaccessible.\n+Collectable objects may freely point at uncollectable objects and vice\n+versa.\n+\n+Objects allocated with the built-in \"::operator new\" are uncollectable.\n+\n+Objects derived from class \"gc\" are collectable.  For example:\n+\n+    class A: public gc {...};\n+    A* a = new A;       // a is collectable. \n+\n+Collectable instances of non-class types can be allocated using the GC\n+placement:\n+\n+    typedef int A[ 10 ];\n+    A* a = new (GC) A;\n+\n+Uncollectable instances of classes derived from \"gc\" can be allocated\n+using the NoGC placement:\n+\n+    class A: public gc {...};\n+    A* a = new (NoGC) A;   // a is uncollectable.\n+\n+Both uncollectable and collectable objects can be explicitly deleted\n+with \"delete\", which invokes an object's destructors and frees its\n+storage immediately.\n+\n+A collectable object may have a clean-up function, which will be\n+invoked when the collector discovers the object to be inaccessible.\n+An object derived from \"gc_cleanup\" or containing a member derived\n+from \"gc_cleanup\" has a default clean-up function that invokes the\n+object's destructors.  Explicit clean-up functions may be specified as\n+an additional placement argument:\n+\n+    A* a = ::new (GC, MyCleanup) A;\n+\n+An object is considered \"accessible\" by the collector if it can be\n+reached by a path of pointers from static variables, automatic\n+variables of active functions, or from some object with clean-up\n+enabled; pointers from an object to itself are ignored.\n+\n+Thus, if objects A and B both have clean-up functions, and A points at\n+B, B is considered accessible.  After A's clean-up is invoked and its\n+storage released, B will then become inaccessible and will have its\n+clean-up invoked.  If A points at B and B points to A, forming a\n+cycle, then that's considered a storage leak, and neither will be\n+collectable.  See the interface gc.h for low-level facilities for\n+handling such cycles of objects with clean-up.\n+\n+The collector cannot guarrantee that it will find all inaccessible\n+objects.  In practice, it finds almost all of them.\n+\n+\n+Cautions:\n+\n+1. Be sure the collector has been augmented with \"make c++\".\n+\n+2.  If your compiler supports the new \"operator new[]\" syntax, then\n+add -DOPERATOR_NEW_ARRAY to the Makefile.\n+\n+If your compiler doesn't support \"operator new[]\", beware that an\n+array of type T, where T is derived from \"gc\", may or may not be\n+allocated as a collectable object (it depends on the compiler).  Use\n+the explicit GC placement to make the array collectable.  For example:\n+\n+    class A: public gc {...};\n+    A* a1 = new A[ 10 ];        // collectable or uncollectable?\n+    A* a2 = new (GC) A[ 10 ];   // collectable\n+\n+3. The destructors of collectable arrays of objects derived from\n+\"gc_cleanup\" will not be invoked properly.  For example:\n+\n+    class A: public gc_cleanup {...};\n+    A* a = new (GC) A[ 10 ];    // destructors not invoked correctly\n+\n+Typically, only the destructor for the first element of the array will\n+be invoked when the array is garbage-collected.  To get all the\n+destructors of any array executed, you must supply an explicit\n+clean-up function:\n+\n+    A* a = new (GC, MyCleanUp) A[ 10 ];\n+\n+(Implementing clean-up of arrays correctly, portably, and in a way\n+that preserves the correct exception semantics requires a language\n+extension, e.g. the \"gc\" keyword.)\n+\n+4. Compiler bugs:\n+\n+* Solaris 2's CC (SC3.0) doesn't implement t->~T() correctly, so the\n+destructors of classes derived from gc_cleanup won't be invoked.\n+You'll have to explicitly register a clean-up function with\n+new-placement syntax.\n+\n+* Evidently cfront 3.0 does not allow destructors to be explicitly\n+invoked using the ANSI-conforming syntax t->~T().  If you're using\n+cfront 3.0, you'll have to comment out the class gc_cleanup, which\n+uses explicit invocation.\n+\n+****************************************************************************/\n+\n+#include \"gc.h\"\n+\n+#ifndef THINK_CPLUS\n+#define _cdecl\n+#endif\n+\n+#if ! defined( OPERATOR_NEW_ARRAY ) \\\n+    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6))\n+#   define OPERATOR_NEW_ARRAY\n+#endif\n+\n+enum GCPlacement {GC, NoGC, PointerFreeGC};\n+\n+class gc {public:\n+    inline void* operator new( size_t size );\n+    inline void* operator new( size_t size, GCPlacement gcp );\n+    inline void operator delete( void* obj );\n+\n+#ifdef OPERATOR_NEW_ARRAY\n+    inline void* operator new[]( size_t size );\n+    inline void* operator new[]( size_t size, GCPlacement gcp );\n+    inline void operator delete[]( void* obj );\n+#endif /* OPERATOR_NEW_ARRAY */\n+    };    \n+    /*\n+    Instances of classes derived from \"gc\" will be allocated in the \n+    collected heap by default, unless an explicit NoGC placement is\n+    specified. */\n+\n+class gc_cleanup: virtual public gc {public:\n+    inline gc_cleanup();\n+    inline virtual ~gc_cleanup();\n+private:\n+    inline static void _cdecl cleanup( void* obj, void* clientData );};\n+    /*\n+    Instances of classes derived from \"gc_cleanup\" will be allocated\n+    in the collected heap by default.  When the collector discovers an\n+    inaccessible object derived from \"gc_cleanup\" or containing a\n+    member derived from \"gc_cleanup\", its destructors will be\n+    invoked. */\n+\n+extern \"C\" {typedef void (*GCCleanUpFunc)( void* obj, void* clientData );}\n+\n+inline void* operator new( \n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup = 0,\n+    void* clientData = 0 );\n+    /*\n+    Allocates a collectable or uncollected object, according to the\n+    value of \"gcp\".\n+\n+    For collectable objects, if \"cleanup\" is non-null, then when the\n+    allocated object \"obj\" becomes inaccessible, the collector will\n+    invoke the function \"cleanup( obj, clientData )\" but will not\n+    invoke the object's destructors.  It is an error to explicitly\n+    delete an object allocated with a non-null \"cleanup\".\n+\n+    It is an error to specify a non-null \"cleanup\" with NoGC or for\n+    classes derived from \"gc_cleanup\" or containing members derived\n+    from \"gc_cleanup\". */\n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+inline void* operator new[](\n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup = 0,\n+    void* clientData = 0 );\n+    /*\n+    The operator new for arrays, identical to the above. */\n+\n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+/****************************************************************************\n+\n+Inline implementation\n+\n+****************************************************************************/\n+\n+inline void* gc::operator new( size_t size ) {\n+    return GC_MALLOC( size );}\n+    \n+inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n+    if (gcp == GC) \n+        return GC_MALLOC( size );\n+    else\n+        return GC_MALLOC_UNCOLLECTABLE( size );}\n+\n+inline void gc::operator delete( void* obj ) {\n+    GC_FREE( obj );}\n+    \n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+inline void* gc::operator new[]( size_t size ) {\n+    return gc::operator new( size );}\n+    \n+inline void* gc::operator new[]( size_t size, GCPlacement gcp ) {\n+    return gc::operator new( size, gcp );}\n+\n+inline void gc::operator delete[]( void* obj ) {\n+    gc::operator delete( obj );}\n+    \n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+\n+inline gc_cleanup::~gc_cleanup() {\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( this, 0, 0, 0, 0 );}\n+\n+inline void gc_cleanup::cleanup( void* obj, void* displ ) {\n+    ((gc_cleanup*) ((char*) obj + (ptrdiff_t) displ))->~gc_cleanup();}\n+\n+inline gc_cleanup::gc_cleanup() {\n+    GC_finalization_proc oldProc;\n+    void* oldData;\n+    void* base = GC_base( (void *) this );\n+    if (0 == base) return;\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( \n+        base, cleanup, (void*) ((char*) this - (char*) base), \n+        &oldProc, &oldData );\n+    if (0 != oldProc) {\n+        GC_REGISTER_FINALIZER_IGNORE_SELF( base, oldProc, oldData, 0, 0 );}}\n+\n+inline void* operator new( \n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup,\n+    void* clientData )\n+{\n+    void* obj;\n+\n+    if (gcp == GC) {\n+        obj = GC_MALLOC( size );\n+        if (cleanup != 0) \n+            GC_REGISTER_FINALIZER_IGNORE_SELF( \n+                obj, cleanup, clientData, 0, 0 );}\n+    else if (gcp == PointerFreeGC) {\n+        obj = GC_MALLOC_ATOMIC( size );}\n+    else {\n+        obj = GC_MALLOC_UNCOLLECTABLE( size );};\n+    return obj;}\n+        \n+\n+#ifdef OPERATOR_NEW_ARRAY\n+\n+inline void* operator new[]( \n+    size_t size, \n+    GCPlacement gcp,\n+    GCCleanUpFunc cleanup,\n+    void* clientData )\n+{\n+    return ::operator new( size, gcp, cleanup, clientData );}\n+\n+#endif /* OPERATOR_NEW_ARRAY */\n+\n+\n+#endif /* GC_CPP_H */\n+"}, {"sha": "700843bbf966c1bf7a0a7a497abea2b42b1dd553", "filename": "boehm-gc/include/gc_inl.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_inl.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,103 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, October 3, 1995 2:07 pm PDT */\n+ \n+# ifndef GC_PRIVATE_H\n+#   include \"private/gc_priv.h\"\n+# endif\n+\n+/* USE OF THIS FILE IS NOT RECOMMENDED unless the collector has been\t*/\n+/* compiled without -DALL_INTERIOR_POINTERS or with\t\t\t*/\n+/* -DDONT_ADD_BYTE_AT_END, or the specified size includes a pointerfree\t*/\n+/* word at the end.  In the standard collector configuration,\t\t*/\n+/* the final word of each object may not be scanned.\t\t\t*/\n+/* This is most useful for compilers that generate C.\t\t\t*/\n+/* Manual use is hereby discouraged.\t\t\t\t\t*/\n+\n+/* Allocate n words (NOT BYTES).  X is made to point to the result.\t*/\n+/* It is assumed that n < MAXOBJSZ, and\t\t\t\t\t*/\n+/* that n > 0.  On machines requiring double word alignment of some\t*/\n+/* data, we also assume that n is 1 or even.  This bypasses the\t\t*/\n+/* MERGE_SIZES mechanism.  In order to minimize the number of distinct\t*/\n+/* free lists that are maintained, the caller should ensure that a \t*/\n+/* small number of distinct values of n are used.  (The MERGE_SIZES\t*/\n+/* mechanism normally does this by ensuring that only the leading three\t*/\n+/* bits of n may be nonzero.  See misc.c for details.)  We really \t*/\n+/* recommend this only in cases in which n is a constant, and no\t*/\n+/* locking is required.\t\t\t\t\t\t\t*/\n+/* In that case it may allow the compiler to perform substantial\t*/\n+/* additional optimizations.\t\t\t\t\t\t*/\n+# define GC_MALLOC_WORDS(result,n) \\\n+{\t\\\n+    register ptr_t op;\t\\\n+    register ptr_t *opp;\t\\\n+    DCL_LOCK_STATE;\t\\\n+\t\\\n+    opp = &(GC_objfreelist[n]);\t\\\n+    FASTLOCK();\t\\\n+    if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\t\\\n+        FASTUNLOCK();\t\\\n+        (result) = GC_generic_malloc_words_small((n), NORMAL);\t\\\n+    } else { \t\\\n+        *opp = obj_link(op);\t\\\n+        obj_link(op) = 0;\t\\\n+        GC_words_allocd += (n);\t\\\n+        FASTUNLOCK();\t\\\n+        (result) = (GC_PTR) op;\t\\\n+    }\t\\\n+}\n+\n+\n+/* The same for atomic objects:\t*/\n+# define GC_MALLOC_ATOMIC_WORDS(result,n) \\\n+{\t\\\n+    register ptr_t op;\t\\\n+    register ptr_t *opp;\t\\\n+    DCL_LOCK_STATE;\t\\\n+\t\\\n+    opp = &(GC_aobjfreelist[n]);\t\\\n+    FASTLOCK();\t\\\n+    if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\t\\\n+        FASTUNLOCK();\t\\\n+        (result) = GC_generic_malloc_words_small((n), PTRFREE);\t\\\n+    } else { \t\\\n+        *opp = obj_link(op);\t\\\n+        obj_link(op) = 0;\t\\\n+        GC_words_allocd += (n);\t\\\n+        FASTUNLOCK();\t\\\n+        (result) = (GC_PTR) op;\t\\\n+    }\t\\\n+}\n+\n+/* And once more for two word initialized objects: */\n+# define GC_CONS(result, first, second) \\\n+{\t\\\n+    register ptr_t op;\t\\\n+    register ptr_t *opp;\t\\\n+    DCL_LOCK_STATE;\t\\\n+\t\\\n+    opp = &(GC_objfreelist[2]);\t\\\n+    FASTLOCK();\t\\\n+    if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\t\\\n+        FASTUNLOCK();\t\\\n+        op = GC_generic_malloc_words_small(2, NORMAL);\t\\\n+    } else {\t\\\n+        *opp = obj_link(op);\t\\\n+        GC_words_allocd += 2;\t\\\n+        FASTUNLOCK();\t\\\n+    } \\\n+    ((word *)op)[0] = (word)(first);\t\\\n+    ((word *)op)[1] = (word)(second);\t\\\n+    (result) = (GC_PTR) op;\t\\\n+}"}, {"sha": "db62d1d58a815eaef9a376d0627873eacaf938d8", "filename": "boehm-gc/include/gc_inline.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_inline.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1 @@\n+# include \"gc_inl.h\""}, {"sha": "e4a6b94756e767ab79281b2c1245b9ebc3cda939", "filename": "boehm-gc/include/gc_typed.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_typed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fgc_typed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_typed.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,91 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright 1996 Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/*\n+ * Some simple primitives for allocation with explicit type information.\n+ * Facilities for dynamic type inference may be added later.\n+ * Should be used only for extremely performance critical applications,\n+ * or if conservative collector leakage is otherwise a problem (unlikely).\n+ * Note that this is implemented completely separately from the rest\n+ * of the collector, and is not linked in unless referenced.\n+ * This does not currently support GC_DEBUG in any interesting way.\n+ */\n+/* Boehm, May 19, 1994 2:13 pm PDT */\n+\n+#ifndef _GC_TYPED_H\n+# define _GC_TYPED_H\n+# ifndef _GC_H\n+#   include \"gc.h\"\n+# endif\n+\n+typedef GC_word * GC_bitmap;\n+\t/* The least significant bit of the first word is one if\t*/\n+\t/* the first word in the object may be a pointer.\t\t*/\n+\t\n+# define GC_get_bit(bm, index) \\\n+\t\t(((bm)[divWORDSZ(index)] >> modWORDSZ(index)) & 1)\n+# define GC_set_bit(bm, index) \\\n+\t\t(bm)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n+\n+typedef GC_word GC_descr;\n+\n+GC_API GC_descr GC_make_descriptor GC_PROTO((GC_bitmap bm, size_t len));\n+\t\t/* Return a type descriptor for the object whose layout\t*/\n+\t\t/* is described by the argument.\t\t\t*/\n+\t\t/* The least significant bit of the first word is one\t*/\n+\t\t/* if the first word in the object may be a pointer.\t*/\n+\t\t/* The second argument specifies the number of\t\t*/\n+\t\t/* meaningful bits in the bitmap.  The actual object \t*/\n+\t\t/* may be larger (but not smaller).  Any additional\t*/\n+\t\t/* words in the object are assumed not to contain \t*/\n+\t\t/* pointers.\t\t\t\t\t\t*/\n+\t\t/* Returns a conservative approximation in the\t\t*/\n+\t\t/* (unlikely) case of insufficient memory to build\t*/\n+\t\t/* the descriptor.  Calls to GC_make_descriptor\t\t*/\n+\t\t/* may consume some amount of a finite resource.  This\t*/\n+\t\t/* is intended to be called once per type, not once\t*/\n+\t\t/* per allocation.\t\t\t\t\t*/\n+\n+GC_API GC_PTR GC_malloc_explicitly_typed\n+\t\t\tGC_PROTO((size_t size_in_bytes, GC_descr d));\n+\t\t/* Allocate an object whose layout is described by d.\t*/\n+\t\t/* The resulting object MAY NOT BE PASSED TO REALLOC.\t*/\n+\n+GC_API GC_PTR GC_malloc_explicitly_typed_ignore_off_page\n+                        GC_PROTO((size_t size_in_bytes, GC_descr d));\n+\t\t\n+GC_API GC_PTR GC_calloc_explicitly_typed\n+\t\t\tGC_PROTO((size_t nelements,\n+  \t\t\t\t  size_t element_size_in_bytes,\n+  \t\t\t\t  GC_descr d));\n+  \t/* Allocate an array of nelements elements, each of the\t*/\n+  \t/* given size, and with the given descriptor.\t\t*/\n+  \t/* The elemnt size must be a multiple of the byte\t*/\n+  \t/* alignment required for pointers.  E.g. on a 32-bit\t*/\n+  \t/* machine with 16-bit aligned pointers, size_in_bytes\t*/\n+  \t/* must be a multiple of 2.\t\t\t\t*/\n+\n+#ifdef GC_DEBUG\n+#   define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) GC_MALLOC(bytes)\n+#   define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) GC_MALLOC(n*bytes)\n+#else\n+#  define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) \\\n+\tGC_malloc_explicitly_typed(bytes, d)\n+#  define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) \\\n+\tGC_calloc_explicitly_typed(n, bytes, d)\n+#endif /* !GC_DEBUG */\n+\n+\n+#endif /* _GC_TYPED_H */\n+"}, {"sha": "fc8004cebe5668a8422ee4588c31102d08ae9434", "filename": "boehm-gc/include/private/config.h", "status": "added", "additions": 965, "deletions": 0, "changes": 965, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fconfig.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,965 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+ \n+#ifndef CONFIG_H\n+\n+# define CONFIG_H\n+\n+/* Machine dependent parameters.  Some tuning parameters can be found\t*/\n+/* near the top of gc_private.h.\t\t\t\t\t*/\n+\n+/* Machine specific parts contributed by various people.  See README file. */\n+\n+/* Determine the machine type: */\n+# if defined(sun) && defined(mc68000)\n+#    define M68K\n+#    define SUNOS4\n+#    define mach_type_known\n+# endif\n+# if defined(hp9000s300)\n+#    define M68K\n+#    define HP\n+#    define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(m68k)\n+#    define M68K\n+#    define NETBSD\n+#    define mach_type_known\n+# endif\n+# if defined(vax)\n+#    define VAX\n+#    ifdef ultrix\n+#\tdefine ULTRIX\n+#    else\n+#\tdefine BSD\n+#    endif\n+#    define mach_type_known\n+# endif\n+# if defined(mips) || defined(__mips)\n+#    define MIPS\n+#    if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n+#\tdefine ULTRIX\n+#    else\n+#\tif defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) || defined(__SYSTYPE_SVR4__)\n+#\t  define IRIX5   /* or IRIX 6.X */\n+#\telse\n+#\t  define RISCOS  /* or IRIX 4.X */\n+#\tendif\n+#    endif\n+#    define mach_type_known\n+# endif\n+# if defined(sequent) && defined(i386)\n+#    define I386\n+#    define SEQUENT\n+#    define mach_type_known\n+# endif\n+# if defined(sun) && defined(i386)\n+#    define I386\n+#    define SUNOS5\n+#    define mach_type_known\n+# endif\n+# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)\n+#    define I386\n+#    define OS2\n+#    define mach_type_known\n+# endif\n+# if defined(ibm032)\n+#   define RT\n+#   define mach_type_known\n+# endif\n+# if defined(sun) && (defined(sparc) || defined(__sparc))\n+#   define SPARC\n+    /* Test for SunOS 5.x */\n+#     include <errno.h>\n+#     ifdef ECHRNG\n+#       define SUNOS5\n+#     else\n+#\tdefine SUNOS4\n+#     endif\n+#   define mach_type_known\n+# endif\n+# if defined(sparc) && defined(unix) && !defined(sun)\n+#   define SPARC\n+#   define DRSNX\n+#   define mach_type_known\n+# endif\n+# if defined(_IBMR2)\n+#   define RS6000\n+#   define mach_type_known\n+# endif\n+# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)\n+\t/* The above test may need refinement\t*/\n+#   define I386\n+#   if defined(_SCO_ELF)\n+#     define SCO_ELF\n+#   else\n+#     define SCO\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(_AUX_SOURCE)\n+#   define M68K\n+#   define SYSV\n+#   define mach_type_known\n+# endif\n+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1)\n+#   define HP_PA\n+#   define mach_type_known\n+# endif\n+# if defined(linux) && defined(i386)\n+#    define I386\n+#    define LINUX\n+#    define mach_type_known\n+# endif\n+# if defined(linux) && defined(powerpc)\n+#    define POWERPC\n+#    define LINUX\n+#    define mach_type_known\n+# endif\n+# if defined(__alpha) || defined(__alpha__)\n+#   define ALPHA\n+#   if defined(linux) || defined(__linux__)\n+#     define LINUX\n+#   else\n+#     define OSF1\t/* a.k.a Digital Unix */\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(_AMIGA)\n+#   define M68K\n+#   define AMIGA\n+#   define mach_type_known\n+# endif\n+# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n+#   define M68K\n+#   define MACOS\n+#   define mach_type_known\n+# endif\n+# if defined(__MWERKS__) && defined(__powerc)\n+#   define POWERPC\n+#   define MACOS\n+#   define mach_type_known\n+# endif\n+# if defined(NeXT) && defined(mc68000)\n+#   define M68K\n+#   define NEXT\n+#   define mach_type_known\n+# endif\n+# if defined(NeXT) && defined(i386)\n+#   define I386\n+#   define NEXT\n+#   define mach_type_known\n+# endif\n+# if defined(__FreeBSD__) && defined(i386)\n+#   define I386\n+#   define FREEBSD\n+#   define mach_type_known\n+# endif\n+# if defined(__NetBSD__) && defined(i386)\n+#   define I386\n+#   define NETBSD\n+#   define mach_type_known\n+# endif\n+# if defined(bsdi) && defined(i386)\n+#    define I386\n+#    define BSDI\n+#    define mach_type_known\n+# endif\n+# if !defined(mach_type_known) && defined(__386BSD__)\n+#   define I386\n+#   define THREE86BSD\n+#   define mach_type_known\n+# endif\n+# if defined(_CX_UX) && defined(_M88K)\n+#   define M88K\n+#   define CX_UX\n+#   define mach_type_known\n+# endif\n+# if defined(DGUX)\n+#   define M88K\n+    /* DGUX defined */\n+#   define mach_type_known\n+# endif\n+# if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300)\n+#   define I386\n+#   define MSWIN32\t/* or Win32s */\n+#   define mach_type_known\n+# endif\n+# if defined(__DJGPP__)\n+#   define I386\n+#   ifndef DJGPP\n+#     define DJGPP  /* MSDOS running the DJGPP port of GCC */\n+#   endif\n+#   define mach_type_known\n+# endif\n+# if defined(__CYGWIN32__)\n+#   define I386\n+#   define CYGWIN32\n+#   define mach_type_known\n+# endif\n+# if defined(__BORLANDC__)\n+#   define I386\n+#   define MSWIN32\n+#   define mach_type_known\n+# endif\n+# if defined(_UTS) && !defined(mach_type_known)\n+#   define S370\n+#   define UTS4\n+#   define mach_type_known\n+# endif\n+/* Ivan Demakov */\n+# if defined(__WATCOMC__) && defined(__386__)\n+#   define I386\n+#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)\n+#     if defined(__OS2__)\n+#       define OS2\n+#     else\n+#       if defined(__WINDOWS_386__) || defined(__NT__)\n+#         define MSWIN32\n+#       else\n+#         define DOS4GW\n+#       endif\n+#     endif\n+#   endif\n+#   define mach_type_known\n+# endif\n+\n+/* Feel free to add more clauses here */\n+\n+/* Or manually define the machine type here.  A machine type is \t*/\n+/* characterized by the architecture.  Some\t\t\t\t*/\n+/* machine types are further subdivided by OS.\t\t\t\t*/\n+/* the macros ULTRIX, RISCOS, and BSD to distinguish.\t\t\t*/\n+/* Note that SGI IRIX is treated identically to RISCOS.\t\t\t*/\n+/* SYSV on an M68K actually means A/UX.\t\t\t\t\t*/\n+/* The distinction in these cases is usually the stack starting address */\n+# ifndef mach_type_known\n+\t--> unknown machine type\n+# endif\n+\t\t    /* Mapping is: M68K       ==> Motorola 680X0\t*/\n+\t\t    /*\t\t   (SUNOS4,HP,NEXT, and SYSV (A/UX),\t*/\n+\t\t    /*\t\t   MACOS and AMIGA variants)\t\t*/\n+\t\t    /*             I386       ==> Intel 386\t \t*/\n+\t\t    /*\t\t    (SEQUENT, OS2, SCO, LINUX, NETBSD,\t*/\n+\t\t    /*\t\t     FREEBSD, THREE86BSD, MSWIN32,\t*/\n+\t\t    /* \t\t     BSDI, SUNOS5, NEXT\tvariants)\t*/\n+                    /*             NS32K      ==> Encore Multimax \t*/\n+                    /*             MIPS       ==> R2000 or R3000\t*/\n+                    /*\t\t\t(RISCOS, ULTRIX variants)\t*/\n+                    /*\t\t   VAX\t      ==> DEC VAX\t\t*/\n+                    /*\t\t\t(BSD, ULTRIX variants)\t\t*/\n+                    /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n+                    /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n+                    /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n+                    /*\t\t\t\t  HP/UX\t\t\t*/\n+\t\t    /*\t\t   SPARC      ==> SPARC under SunOS\t*/\n+\t\t    /*\t\t\t(SUNOS4, SUNOS5,\t\t*/\n+\t\t    /*\t\t\t DRSNX variants)\t\t*/\n+\t\t    /* \t\t   ALPHA      ==> DEC Alpha \t\t*/\n+\t\t    /*\t\t\t(OSF1 and LINUX variants)\t*/\n+\t\t    /* \t\t   M88K       ==> Motorola 88XX0        */\n+\t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n+\t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n+\t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n+\n+\n+/*\n+ * For each architecture and OS, the following need to be defined:\n+ *\n+ * CPP_WORD_SZ is a simple integer constant representing the word size.\n+ * in bits.  We assume byte addressibility, where a byte has 8 bits.\n+ * We also assume CPP_WORD_SZ is either 32 or 64.\n+ * (We care about the length of pointers, not hardware\n+ * bus widths.  Thus a 64 bit processor with a C compiler that uses\n+ * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)\n+ *\n+ * MACH_TYPE is a string representation of the machine type.\n+ * OS_TYPE is analogous for the OS.\n+ *\n+ * ALIGNMENT is the largest N, such that\n+ * all pointer are guaranteed to be aligned on N byte boundaries.\n+ * defining it to be 1 will always work, but perform poorly.\n+ *\n+ * DATASTART is the beginning of the data segment.\n+ * On UNIX systems, the collector will scan the area between DATASTART\n+ * and DATAEND for root pointers.\n+ *\n+ * DATAEND, if not &end.\n+ *\n+ * ALIGN_DOUBLE of GC_malloc should return blocks aligned to twice\n+ * the pointer size.\n+ *\n+ * STACKBOTTOM is the cool end of the stack, which is usually the\n+ * highest address in the stack.\n+ * Under PCR or OS/2, we have other ways of finding thread stacks.\n+ * For each machine, the following should:\n+ * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and\n+ * 2) define exactly one of\n+ *\tSTACKBOTTOM (should be defined to be an expression)\n+ *\tHEURISTIC1\n+ *\tHEURISTIC2\n+ * If either of the last two macros are defined, then STACKBOTTOM is computed\n+ * during collector startup using one of the following two heuristics:\n+ * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to\n+ *\t\tthe next multiple of STACK_GRAN.\n+ * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly\n+ *\t\tin small steps (decrement if STACK_GROWS_UP), and read the value\n+ *\t\tat each location.  Remember the value when the first\n+ *\t\tSegmentation violation or Bus error is signalled.  Round that\n+ *\t\tto the nearest plausible page boundary, and use that instead\n+ *\t\tof STACKBOTTOM.\n+ *\n+ * If no expression for STACKBOTTOM can be found, and neither of the above\n+ * heuristics are usable, the collector can still be used with all of the above\n+ * undefined, provided one of the following is done:\n+ * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)\n+ *    without reference to STACKBOTTOM.  This is appropriate for use in\n+ *    conjunction with thread packages, since there will be multiple stacks.\n+ *    (Allocating thread stacks in the heap, and treating them as ordinary\n+ *    heap data objects is also possible as a last resort.  However, this is\n+ *    likely to introduce significant amounts of excess storage retention\n+ *    unless the dead parts of the thread stacks are periodically cleared.)\n+ * 2) Client code may set GC_stackbottom before calling any GC_ routines.\n+ *    If the author of the client code controls the main program, this is\n+ *    easily accomplished by introducing a new main program, setting\n+ *    GC_stackbottom to the address of a local variable, and then calling\n+ *    the original main program.  The new main program would read something\n+ *    like:\n+ *\n+ *\t\t# include \"gc_private.h\"\n+ *\n+ *\t\tmain(argc, argv, envp)\n+ *\t\tint argc;\n+ *\t\tchar **argv, **envp;\n+ *\t\t{\n+ *\t\t    int dummy;\n+ *\n+ *\t\t    GC_stackbottom = (ptr_t)(&dummy);\n+ *\t\t    return(real_main(argc, argv, envp));\n+ *\t\t}\n+ *\n+ *\n+ * Each architecture may also define the style of virtual dirty bit\n+ * implementation to be used:\n+ *   MPROTECT_VDB: Write protect the heap and catch faults.\n+ *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.\n+ *\n+ * An architecture may define DYNAMIC_LOADING if dynamic_load.c\n+ * defined GC_register_dynamic_libraries() for the architecture.\n+ */\n+\n+\n+# define STACK_GRAN 0x1000000\n+# ifdef M68K\n+#   define MACH_TYPE \"M68K\"\n+#   define ALIGNMENT 2\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef SUNOS4\n+#\tdefine OS_TYPE \"SUNOS4\"\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x1ffff) & ~0x1ffff))\n+#\tdefine HEURISTIC1\t/* differs\t*/\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef HP\n+#\tdefine OS_TYPE \"HP\"\n+\textern char etext;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       define STACKBOTTOM ((ptr_t) 0xffeffffc)\n+\t\t\t      /* empirically determined.  seems to work. */\n+#  \tinclude <unistd.h>\n+#\tdefine GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+#   endif\n+#   ifdef SYSV\n+#\tdefine OS_TYPE \"SYSV\"\n+\textern etext;\n+#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\t\t\t\t   & ~0x3fffff) \\\n+\t\t\t\t  +((word)&etext & 0x1fff))\n+\t/* This only works for shared-text binaries with magic number 0413.\n+\t   The other sorts of SysV binaries put the data at the end of the text,\n+\t   in which case the default of &etext would work.  Unfortunately,\n+\t   handling both would require having the magic-number available.\n+\t   \t   \t\t-- Parag\n+\t   */\n+#\tdefine STACKBOTTOM ((ptr_t)0xFFFFFFFE)\n+\t\t\t/* The stack starts at the top of memory, but   */\n+\t\t\t/* 0x0 cannot be used as setjump_test complains */\n+\t\t\t/* that the stack direction is incorrect.  Two  */\n+\t\t\t/* bytes down from 0x0 should be safe enough.   */\n+\t\t\t/* \t\t--Parag\t\t\t\t*/\n+#   \tinclude <sys/mmu.h>\n+#\tdefine GETPAGESIZE() PAGESIZE\t/* Is this still right? */\n+#   endif\n+#   ifdef AMIGA\n+#\tdefine OS_TYPE \"AMIGA\"\n+ \t    \t/* STACKBOTTOM and DATASTART handled specially\t*/\n+ \t    \t/* in os_dep.c\t\t\t\t\t*/\n+# \tdefine DATAEND\t/* not needed */\n+#\tdefine GETPAGESIZE() 4096\n+#   endif\n+#   ifdef MACOS\n+#     ifndef __LOWMEM__\n+#     include <LowMem.h>\n+#     endif\n+#     define OS_TYPE \"MACOS\"\n+\t\t\t/* see os_dep.c for details of global data segments. */\n+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n+#     define DATAEND\t/* not needed */\n+#     define GETPAGESIZE() 4096\n+#   endif\n+#   ifdef NEXT\n+#\tdefine OS_TYPE \"NEXT\"\n+#\tdefine DATASTART ((ptr_t) get_etext())\n+#\tdefine STACKBOTTOM ((ptr_t) 0x4000000)\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+# endif\n+\n+# ifdef POWERPC\n+#   define MACH_TYPE \"POWERPC\"\n+#   define ALIGNMENT 2\n+#   ifdef MACOS\n+#     ifndef __LOWMEM__\n+#     include <LowMem.h>\n+#     endif\n+#     define OS_TYPE \"MACOS\"\n+\t\t\t/* see os_dep.c for details of global data segments. */\n+#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n+#     define DATAEND  /* not needed */\n+#   endif\n+#   ifdef LINUX\n+#     define OS_TYPE \"LINUX\"\n+#     define STACKBOTTOM ((ptr_t)0x80000000)\n+#     define DATASTART GC_data_start\n+      extern int _end;\n+#     define DATAEND (&_end)\n+#   endif\n+# endif\n+\n+# ifdef VAX\n+#   define MACH_TYPE \"VAX\"\n+#   define ALIGNMENT 4\t/* Pointers are longword aligned by 4.2 C compiler */\n+    extern char etext;\n+#   define DATASTART ((ptr_t)(&etext))\n+#   ifdef BSD\n+#\tdefine OS_TYPE \"BSD\"\n+#\tdefine HEURISTIC1\n+\t\t\t/* HEURISTIC2 may be OK, but it's hard to test. */\n+#   endif\n+#   ifdef ULTRIX\n+#\tdefine OS_TYPE \"ULTRIX\"\n+#\tdefine STACKBOTTOM ((ptr_t) 0x7fffc800)\n+#   endif\n+# endif\n+\n+# ifdef RT\n+#   define MACH_TYPE \"RT\"\n+#   define ALIGNMENT 4\n+#   define DATASTART ((ptr_t) 0x10000000)\n+#   define STACKBOTTOM ((ptr_t) 0x1fffd800)\n+# endif\n+\n+# ifdef SPARC\n+#   define MACH_TYPE \"SPARC\"\n+#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+#   define ALIGN_DOUBLE\n+    extern int etext;\n+#   ifdef SUNOS5\n+#\tdefine OS_TYPE \"SUNOS5\"\n+\textern int _etext;\n+\textern int _end;\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tifndef USE_MMAP\n+#\t    define USE_MMAP\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#\tdefine PROC_VDB\n+#\tdefine HEURISTIC1\n+#\tinclude <unistd.h>\n+#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+\t\t/* getpagesize() appeared to be missing from at least one */\n+\t\t/* Solaris 5.4 installation.  Weird.\t\t\t  */\n+#   endif\n+#   ifdef SUNOS4\n+#\tdefine OS_TYPE \"SUNOS4\"\n+\t/* [If you have a weak stomach, don't read this.]\t\t*/\n+\t/* We would like to use:\t\t\t\t\t*/\n+/* #       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1fff) & ~0x1fff)) */\n+\t/* This fails occasionally, due to an ancient, but very \t*/\n+\t/* persistent ld bug.  &etext is set 32 bytes too high.\t\t*/\n+\t/* We instead read the text segment size from the a.out\t\t*/\n+\t/* header, which happens to be mapped into our address space\t*/\n+\t/* at the start of the text segment.  The detective work here\t*/\n+\t/* was done by Robert Ehrlich, Manuel Serrano, and Bernard\t*/\n+\t/* Serpette of INRIA.\t\t\t\t\t\t*/\n+\t/* This assumes ZMAGIC, i.e. demand-loadable executables.\t*/\n+#\tdefine TEXTSTART 0x2000\n+#       define DATASTART ((ptr_t)(*(int *)(TEXTSTART+0x4)+TEXTSTART))\n+#\tdefine MPROTECT_VDB\n+#\tdefine HEURISTIC1\n+#   endif\n+#   ifdef DRSNX\n+#       define CPP_WORDSZ 32\n+#\tdefine OS_TYPE \"DRSNX\"\n+\textern char * GC_SysVGetDataStart();\n+\textern int etext;\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#\tdefine MPROTECT_VDB\n+#       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n+#   endif\n+#   define DYNAMIC_LOADING\n+# endif\n+\n+# ifdef I386\n+#   define MACH_TYPE \"I386\"\n+#   define ALIGNMENT 4\t/* Appears to hold for all \"32 bit\" compilers\t*/\n+\t\t\t/* except Borland.  The -a4 option fixes \t*/\n+\t\t\t/* Borland.\t\t\t\t\t*/\n+                        /* Ivan Demakov: For Watcom the option is -zp4. */\n+#   ifndef SMALL_CONFIG\n+#     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n+\t\t\t  /* improvement on Pentiums.\t\t\t  */\n+#   endif\n+#   ifdef SEQUENT\n+#\tdefine OS_TYPE \"SEQUENT\"\n+\textern int etext;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n+#   endif\n+#   ifdef SUNOS5\n+#\tdefine OS_TYPE \"SUNOS5\"\n+  \textern int etext, _start;\n+  \textern char * GC_SysVGetDataStart();\n+#       define DATASTART GC_SysVGetDataStart(0x1000, &etext)\n+#\tdefine STACKBOTTOM ((ptr_t)(&_start))\n+/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n+/*#\tdefine PROC_VDB*/\n+#\tdefine DYNAMIC_LOADING\n+#\tifndef USE_MMAP\n+#\t    define USE_MMAP\n+#\tendif\n+#       ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x40000000\n+#       else\n+#\t  define HEAP_START DATAEND\n+#       endif\n+#   endif\n+#   ifdef SCO\n+#\tdefine OS_TYPE \"SCO\"\n+\textern int etext;\n+#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n+\t\t\t\t  & ~0x3fffff) \\\n+\t\t\t\t +((word)&etext & 0xfff))\n+#\tdefine STACKBOTTOM ((ptr_t) 0x7ffffffc)\n+#   endif\n+#   ifdef SCO_ELF\n+#       define OS_TYPE \"SCO_ELF\"\n+        extern int etext;\n+#       define DATASTART ((ptr_t)(&etext))\n+#       define STACKBOTTOM ((ptr_t) 0x08048000)\n+#       define DYNAMIC_LOADING\n+#\tdefine ELF_CLASS ELFCLASS32\n+#   endif\n+#   ifdef LINUX\n+#\tdefine OS_TYPE \"LINUX\"\n+#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n+\t/* Appears to be 0xe0000000 for at least one 2.1.91 kernel.\t*/\n+\t/* Probably needs to be more flexible, but I don't yet \t\t*/\n+\t/* fully understand how flexible.\t\t\t\t*/\n+#\tdefine MPROTECT_VDB\n+#       ifdef __ELF__\n+#            define DYNAMIC_LOADING\n+#\t     ifdef UNDEFINED\t/* includes ro data */\n+\t       extern int _etext;\n+#              define DATASTART ((ptr_t)((((word) (&_etext)) + 0xfff) & ~0xfff))\n+#\t     endif\n+#\t     include <linux/version.h>\n+#\t     include <features.h>\n+#\t     if LINUX_VERSION_CODE >= 0x20000 && defined(__GLIBC__) && __GLIBC__ >= 2\n+\t\t extern int __data_start;\n+#\t\t define DATASTART ((ptr_t)(&__data_start))\n+#\t     else\n+     \t         extern char **__environ;\n+#                define DATASTART ((ptr_t)(&__environ))\n+\t\t\t      /* hideous kludge: __environ is the first */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+\t\t\t      /* We could use _etext instead, but that  */\n+\t\t\t      /* would include .rodata, which may       */\n+\t\t\t      /* contain large read-only data tables    */\n+\t\t\t      /* that we'd rather not scan.\t\t*/\n+#\t     endif\n+\t     extern int _end;\n+#\t     define DATAEND (&_end)\n+#\telse\n+\t     extern int etext;\n+#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n+#       endif\n+#   endif\n+#   ifdef CYGWIN32\n+          extern int _data_start__;\n+          extern int _data_end__;\n+          extern int _bss_start__;\n+          extern int _bss_end__;\n+  \t/* For binutils 2.9.1, we have\t\t\t*/\n+  \t/*\tDATASTART   = _data_start__\t\t*/\n+  \t/*\tDATAEND\t    = _bss_end__\t\t*/\n+  \t/* whereas for some earlier versions it was\t*/\n+  \t/*\tDATASTART   = _bss_start__\t\t*/\n+  \t/*\tDATAEND\t    = _data_end__\t\t*/\n+  \t/* To get it right for both, we take the\t*/\n+  \t/* minumum/maximum of the two.\t\t\t*/\n+#   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n+#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n+#       define DATASTART ((ptr_t) MIN(_data_start__, _bss_start__))\n+#       define DATAEND\t ((ptr_t) MAX(_data_end__, _bss_end__))\n+#\tundef STACK_GRAN\n+#       define STACK_GRAN 0x10000\n+#       define HEURISTIC1\n+#   endif\n+#   ifdef OS2\n+#\tdefine OS_TYPE \"OS2\"\n+ \t    \t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c. OS2 actually has the right\t\t\t*/\n+\t\t/* system call!\t\t\t\t\t\t*/\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+#   ifdef MSWIN32\n+#\tdefine OS_TYPE \"MSWIN32\"\n+\t\t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c.\t\t\t\t\t\t*/\n+#       ifndef __WATCOMC__\n+#\t  define MPROTECT_VDB\n+#\tendif\n+#       define DATAEND  /* not needed */\n+#   endif\n+#   ifdef DJGPP\n+#       define OS_TYPE \"DJGPP\"\n+#       include \"stubinfo.h\"\n+        extern int etext;\n+        extern int _stklen;\n+#       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1ff) & ~0x1ff))\n+#       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \\\n+                                                     + _stklen))\n+\t\t/* This may not be right.  */\n+#   endif\n+#   ifdef FREEBSD\n+#\tdefine OS_TYPE \"FREEBSD\"\n+#\tdefine MPROTECT_VDB\n+#   endif\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#   endif\n+#   ifdef THREE86BSD\n+#\tdefine OS_TYPE \"THREE86BSD\"\n+#   endif\n+#   ifdef BSDI\n+#\tdefine OS_TYPE \"BSDI\"\n+#   endif\n+#   if defined(FREEBSD) || defined(NETBSD) \\\n+        || defined(THREE86BSD) || defined(BSDI)\n+#\tdefine HEURISTIC2\n+\textern char etext;\n+#\tdefine DATASTART ((ptr_t)(&etext))\n+#   endif\n+#   ifdef NEXT\n+#\tdefine OS_TYPE \"NEXT\"\n+#\tdefine DATASTART ((ptr_t) get_etext())\n+#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n+#\tdefine DATAEND\t/* not needed */\n+#   endif\n+#   ifdef DOS4GW\n+#     define OS_TYPE \"DOS4GW\"\n+      /* Get_DATASTART, Get_DATAEND, Get_STACKBOTTOM\n+       *      Defined in gc-watcom.asm\n+       */\n+      extern char* Get_DATASTART (void);\n+      extern char* Get_DATAEND (void);\n+      extern char* Get_STACKBOTTOM (void);\n+#     pragma aux Get_DATASTART \"*\" value [eax];\n+#     pragma aux Get_DATAEND \"*\" value [eax];\n+#     pragma aux Get_STACKBOTTOM \"*\" value [eax];\n+#     define DATASTART ((ptr_t) Get_DATASTART())\n+#     define STACKBOTTOM ((ptr_t) Get_STACKBOTTOM())\n+#     define DATAEND ((ptr_t) Get_DATAEND())\n+#   endif\n+# endif\n+\n+# ifdef NS32K\n+#   define MACH_TYPE \"NS32K\"\n+#   define ALIGNMENT 4\n+    extern char **environ;\n+#   define DATASTART ((ptr_t)(&environ))\n+\t\t\t      /* hideous kludge: environ is the first   */\n+\t\t\t      /* word in crt0.o, and delimits the start */\n+\t\t\t      /* of the data segment, no matter which   */\n+\t\t\t      /* ld options were passed through.        */\n+#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */\n+# endif\n+\n+# ifdef MIPS\n+#   define MACH_TYPE \"MIPS\"\n+#   ifndef IRIX5\n+#     define DATASTART (ptr_t)0x10000000\n+\t\t\t      /* Could probably be slightly higher since */\n+\t\t\t      /* startup code allocates lots of stuff.   */\n+#   else\n+      extern int _fdata;\n+#     define DATASTART ((ptr_t)(&_fdata))\n+#     ifdef USE_MMAP\n+#         define HEAP_START (ptr_t)0x30000000\n+#     else\n+#\t  define HEAP_START DATASTART\n+#     endif\n+\t\t\t      /* Lowest plausible heap address.\t\t*/\n+\t\t\t      /* In the MMAP case, we map there.\t*/\n+\t\t\t      /* In either case it is used to identify\t*/\n+\t\t\t      /* heap sections so they're not \t\t*/\n+\t\t\t      /* considered as roots.\t\t\t*/\n+#   endif /* IRIX5 */\n+#   define HEURISTIC2\n+/* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n+#   ifdef ULTRIX\n+#\tdefine OS_TYPE \"ULTRIX\"\n+#       define ALIGNMENT 4\n+#   endif\n+#   ifdef RISCOS\n+#\tdefine OS_TYPE \"RISCOS\"\n+#   \tdefine ALIGNMENT 4  /* Required by hardware */\n+#   endif\n+#   ifdef IRIX5\n+#\tdefine OS_TYPE \"IRIX5\"\n+#       define MPROTECT_VDB\n+#       ifdef _MIPS_SZPTR\n+#\t  define CPP_WORDSZ _MIPS_SZPTR\n+#\t  define ALIGNMENT (_MIPS_SZPTR/8)\n+#\t  if CPP_WORDSZ != 64\n+#\t    define ALIGN_DOUBLE\n+#\t  endif\n+#\telse\n+#         define ALIGNMENT 4\n+#\t  define ALIGN_DOUBLE\n+#\tendif\n+#\tdefine DYNAMIC_LOADING\n+#   endif\n+# endif\n+\n+# ifdef RS6000\n+#   define MACH_TYPE \"RS6000\"\n+#   define ALIGNMENT 4\n+#   define DATASTART ((ptr_t)0x20000000)\n+    extern int errno;\n+#   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n+#   define DYNAMIC_LOADING\n+\t/* For really old versions of AIX, this may have to be removed. */\n+# endif\n+\n+# ifdef HP_PA\n+#   define MACH_TYPE \"HP_PA\"\n+#   define ALIGNMENT 4\n+#   define ALIGN_DOUBLE\n+    extern int __data_start;\n+#   define DATASTART ((ptr_t)(&__data_start))\n+#   if 0\n+\t/* The following appears to work for 7xx systems running HP/UX\t*/\n+\t/* 9.xx Furthermore, it might result in much faster\t\t*/\n+\t/* collections than HEURISTIC2, which may involve scanning\t*/\n+\t/* segments that directly precede the stack.  It is not the\t*/\n+\t/* default, since it may not work on older machine/OS\t\t*/\n+\t/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering\t*/\n+\t/* this.)\t\t\t\t\t\t\t*/\n+#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */\n+#   else\n+#       define HEURISTIC2\n+#   endif\n+#   define STACK_GROWS_UP\n+#   define DYNAMIC_LOADING\n+#   include <unistd.h>\n+#   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n+\t/* They misspelled the Posix macro?\t*/\n+# endif\n+\n+# ifdef ALPHA\n+#   define MACH_TYPE \"ALPHA\"\n+#   define ALIGNMENT 8\n+#   ifdef OSF1\n+#\tdefine OS_TYPE \"OSF1\"\n+#   \tdefine DATASTART ((ptr_t) 0x140000000)\n+#   \tdefine HEURISTIC2\n+\t/* Normally HEURISTIC2 is too conervative, since\t\t*/\n+\t/* the text segment immediately follows the stack.\t\t*/\n+\t/* Hence we give an upper pound.\t\t\t\t*/\n+    \textern __start;\n+#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n+#   \tdefine CPP_WORDSZ 64\n+#   \tdefine MPROTECT_VDB\n+#   \tdefine DYNAMIC_LOADING\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define CPP_WORDSZ 64\n+#       define STACKBOTTOM ((ptr_t) 0x120000000)\n+#       ifdef __ELF__\n+            extern int __data_start;\n+#           define DATASTART &__data_start\n+#           define DYNAMIC_LOADING\n+#       else\n+#           define DATASTART ((ptr_t) 0x140000000)\n+#       endif\n+\textern int _end;\n+#\tdefine DATAEND (&_end)\n+\t/* As of 1.3.90, I couldn't find a way to retrieve the correct\t*/\n+\t/* fault address from a signal handler.\t\t\t\t*/\n+\t/* Hence MPROTECT_VDB is broken.\t\t\t\t*/\n+#   endif\n+# endif\n+\n+# ifdef M88K\n+#   define MACH_TYPE \"M88K\"\n+#   define ALIGNMENT 4\n+#   define ALIGN_DOUBLE\n+    extern int etext;\n+#   ifdef CX_UX\n+#\tdefine OS_TYPE \"CX_UX\"\n+#       define DATASTART ((((word)&etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n+#   endif\n+#   ifdef  DGUX\n+#\tdefine OS_TYPE \"DGUX\"\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n+#   endif\n+#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n+# endif\n+\n+# ifdef S370\n+#   define MACH_TYPE \"S370\"\n+#   define OS_TYPE \"UTS4\"\n+#   define ALIGNMENT 4\t/* Required by hardware\t*/\n+    extern int etext;\n+\textern int _etext;\n+\textern int _end;\n+\textern char * GC_SysVGetDataStart();\n+#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n+#\tdefine DATAEND (&_end)\n+#\tdefine HEURISTIC2\n+# endif\n+\n+# ifndef STACK_GROWS_UP\n+#   define STACK_GROWS_DOWN\n+# endif\n+\n+# ifndef CPP_WORDSZ\n+#   define CPP_WORDSZ 32\n+# endif\n+\n+# ifndef OS_TYPE\n+#   define OS_TYPE \"\"\n+# endif\n+\n+# ifndef DATAEND\n+    extern int end;\n+#   define DATAEND (&end)\n+# endif\n+\n+# if defined(SVR4) && !defined(GETPAGESIZE)\n+#    include <unistd.h>\n+#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n+# endif\n+\n+# ifndef GETPAGESIZE\n+#   if defined(SUNOS5) || defined(IRIX5)\n+#\tinclude <unistd.h>\n+#   endif\n+#   define GETPAGESIZE() getpagesize()\n+# endif\n+\n+# if defined(SUNOS5) || defined(DRSNX) || defined(UTS4)\n+    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n+#   define SVR4\n+# endif\n+\n+# if defined(SUNOS5) || defined(DRSNX)\n+    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n+    /* loader.\t\t\t\t\t\t\t\t*/\n+#   define SUNOS5DL\n+    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n+#   define SUNOS5SIGS\n+# endif\n+\n+# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n+   -> bad word size\n+# endif\n+\n+# ifdef PCR\n+#   undef DYNAMIC_LOADING\n+#   undef STACKBOTTOM\n+#   undef HEURISTIC1\n+#   undef HEURISTIC2\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+#   define PCR_VDB\n+# endif\n+\n+# ifdef SRC_M3\n+/* Postponed for now. */\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+# endif\n+\n+# ifdef SMALL_CONFIG\n+/* Presumably not worth the space it takes. */\n+#   undef PROC_VDB\n+#   undef MPROTECT_VDB\n+# endif\n+\n+# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n+#   define DEFAULT_VDB\n+# endif\n+\n+# if defined(IRIX_THREADS) && !defined(IRIX5)\n+--> inconsistent configuration\n+# endif\n+# if defined(LINUX_THREADS) && !defined(LINUX)\n+--> inconsistent configuration\n+# endif\n+# if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n+--> inconsistent configuration\n+# endif\n+# if defined(PCR) || defined(SRC_M3) || \\\n+\tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n+\tdefined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#   define THREADS\n+# endif\n+\n+# if defined(SPARC)\n+#   define SAVE_CALL_CHAIN\n+#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n+\t\t\t\t/* include assembly code to do it well.\t*/\n+# endif\n+\n+# endif"}, {"sha": "d2b24bb8ab6d728608c4821ba93053d794f3ec34", "filename": "boehm-gc/include/private/cord_pos.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fcord_pos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fcord_pos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fcord_pos.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,118 @@\n+/* \n+ * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, May 19, 1994 2:23 pm PDT */\n+# ifndef CORD_POSITION_H\n+\n+/* The representation of CORD_position.  This is private to the\t*/\n+/* implementation, but the size is known to clients.  Also\t*/\n+/* the implementation of some exported macros relies on it.\t*/\n+/* Don't use anything defined here and not in cord.h.\t\t*/\n+\n+# define MAX_DEPTH 48\n+\t/* The maximum depth of a balanced cord + 1.\t\t*/\n+\t/* We don't let cords get deeper than MAX_DEPTH.\t*/\n+\n+struct CORD_pe {\n+    CORD pe_cord;\n+    size_t pe_start_pos;\n+};\n+\n+/* A structure describing an entry on the path from the root \t*/\n+/* to current position.\t\t\t\t\t\t*/\n+typedef struct CORD_Pos {\n+    size_t cur_pos;\n+    int path_len;\n+#\tdefine CORD_POS_INVALID (0x55555555)\n+\t\t/* path_len == INVALID <==> position invalid */\n+    const char *cur_leaf;\t/* Current leaf, if it is a string.\t*/\n+    \t\t\t\t/* If the current leaf is a function,\t*/\n+    \t\t\t\t/* then this may point to function_buf\t*/\n+    \t\t\t\t/* containing the next few characters.\t*/\n+    \t\t\t\t/* Always points to a valid string\t*/\n+    \t\t\t\t/* containing the current character \t*/\n+    \t\t\t\t/* unless cur_end is 0.\t\t\t*/\n+    size_t cur_start;\t/* Start position of cur_leaf\t*/\n+    size_t cur_end;\t/* Ending position of cur_leaf\t*/\n+    \t\t\t/* 0 if cur_leaf is invalid.\t*/\n+    struct CORD_pe path[MAX_DEPTH + 1];\n+    \t/* path[path_len] is the leaf corresponding to cur_pos\t*/\n+    \t/* path[0].pe_cord is the cord we point to.\t\t*/\n+#   define FUNCTION_BUF_SZ 8\n+    char function_buf[FUNCTION_BUF_SZ];\t/* Space for next few chars\t*/\n+    \t\t\t\t\t/* from function node.\t\t*/\n+} CORD_pos[1];\n+\n+/* Extract the cord from a position:\t*/\n+CORD CORD_pos_to_cord(CORD_pos p);\n+\t\n+/* Extract the current index from a position:\t*/\n+size_t CORD_pos_to_index(CORD_pos p);\n+\t\n+/* Fetch the character located at the given position:\t*/\n+char CORD_pos_fetch(CORD_pos p);\n+\t\n+/* Initialize the position to refer to the give cord and index.\t*/\n+/* Note that this is the most expensive function on positions:\t*/\n+void CORD_set_pos(CORD_pos p, CORD x, size_t i);\n+\t\n+/* Advance the position to the next character.\t*/\n+/* P must be initialized and valid.\t\t*/\n+/* Invalidates p if past end:\t\t\t*/\n+void CORD_next(CORD_pos p);\n+\n+/* Move the position to the preceding character.\t*/\n+/* P must be initialized and valid.\t\t\t*/\n+/* Invalidates p if past beginning:\t\t\t*/\n+void CORD_prev(CORD_pos p);\n+\t\n+/* Is the position valid, i.e. inside the cord?\t\t*/\n+int CORD_pos_valid(CORD_pos p);\n+\n+char CORD__pos_fetch(CORD_pos);\n+void CORD__next(CORD_pos);\n+void CORD__prev(CORD_pos);\n+\n+#define CORD_pos_fetch(p)\t\\\n+    (((p)[0].cur_end != 0)? \\\n+     \t(p)[0].cur_leaf[(p)[0].cur_pos - (p)[0].cur_start] \\\n+     \t: CORD__pos_fetch(p))\n+\n+#define CORD_next(p)\t\\\n+    (((p)[0].cur_pos + 1 < (p)[0].cur_end)? \\\n+    \t(p)[0].cur_pos++ \\\n+    \t: (CORD__next(p), 0))\n+\n+#define CORD_prev(p)\t\\\n+    (((p)[0].cur_end != 0 && (p)[0].cur_pos > (p)[0].cur_start)? \\\n+    \t(p)[0].cur_pos-- \\\n+    \t: (CORD__prev(p), 0))\n+\n+#define CORD_pos_to_index(p) ((p)[0].cur_pos)\n+\n+#define CORD_pos_to_cord(p) ((p)[0].path[0].pe_cord)\n+\n+#define CORD_pos_valid(p) ((p)[0].path_len != CORD_POS_INVALID)\n+\n+/* Some grubby stuff for performance-critical friends:\t*/\n+#define CORD_pos_chars_left(p) ((long)((p)[0].cur_end) - (long)((p)[0].cur_pos))\n+\t/* Number of characters in cache.  <= 0 ==> none\t*/\n+\n+#define CORD_pos_advance(p,n) ((p)[0].cur_pos += (n) - 1, CORD_next(p))\n+\t/* Advance position by n characters\t*/\n+\t/* 0 < n < CORD_pos_chars_left(p)\t*/\n+\n+#define CORD_pos_cur_char_addr(p) \\\n+\t(p)[0].cur_leaf + ((p)[0].cur_pos - (p)[0].cur_start)\n+\t/* address of current character in cache.\t*/\n+\n+#endif"}, {"sha": "2f2d1bf9b8aa5f16b5b899298d8e3c8a33ed14ff", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,133 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, July 11, 1995 11:54 am PDT */\n+# ifndef GC_HEADERS_H\n+# define GC_HEADERS_H\n+typedef struct hblkhdr hdr;\n+\n+# if CPP_WORDSZ != 32 && CPP_WORDSZ < 36\n+\t--> Get a real machine.\n+# endif\n+\n+/*\n+ * The 2 level tree data structure that is used to find block headers.\n+ * If there are more than 32 bits in a pointer, the top level is a hash\n+ * table.\n+ */\n+\n+# if CPP_WORDSZ > 32\n+#   define HASH_TL\n+# endif\n+\n+/* Define appropriate out-degrees for each of the two tree levels\t*/\n+# ifdef SMALL_CONFIG\n+#   define LOG_BOTTOM_SZ 11\n+\t/* Keep top index size reasonable with smaller blocks. */\n+# else\n+#   define LOG_BOTTOM_SZ 10\n+# endif\n+# ifndef HASH_TL\n+#   define LOG_TOP_SZ (WORDSZ - LOG_BOTTOM_SZ - LOG_HBLKSIZE)\n+# else\n+#   define LOG_TOP_SZ 11\n+# endif\n+# define TOP_SZ (1 << LOG_TOP_SZ)\n+# define BOTTOM_SZ (1 << LOG_BOTTOM_SZ)\n+\n+typedef struct bi {\n+    hdr * index[BOTTOM_SZ];\n+\t/*\n+ \t * The bottom level index contains one of three kinds of values:\n+\t * 0 means we're not responsible for this block.\n+\t * 1 < (long)X <= MAX_JUMP means the block starts at least\n+\t *        X * HBLKSIZE bytes before the current address.\n+\t * A valid pointer points to a hdr structure. (The above can't be\n+\t * valid pointers due to the GET_MEM return convention.)\n+\t */\n+    struct bi * asc_link;\t/* All indices are linked in\t*/\n+    \t\t\t\t/* ascending order.\t\t*/\n+    word key;\t\t\t/* high order address bits.\t*/\n+# ifdef HASH_TL\n+    struct bi * hash_link;\t/* Hash chain link.\t\t*/\n+# endif\n+} bottom_index;\n+\n+/* extern bottom_index GC_all_nils; - really part of GC_arrays */\n+\n+/* extern bottom_index * GC_top_index []; - really part of GC_arrays */\n+\t\t\t\t/* Each entry points to a bottom_index.\t*/\n+\t\t\t\t/* On a 32 bit machine, it points to \t*/\n+\t\t\t\t/* the index for a set of high order\t*/\n+\t\t\t\t/* bits equal to the index.  For longer\t*/\n+\t\t\t\t/* addresses, we hash the high order\t*/\n+\t\t\t\t/* bits to compute the index in \t*/\n+\t\t\t\t/* GC_top_index, and each entry points\t*/\n+\t\t\t\t/* to a hash chain.\t\t\t*/\n+\t\t\t\t/* The last entry in each chain is\t*/\n+\t\t\t\t/* GC_all_nils.\t\t\t\t*/\n+\n+\n+# define MAX_JUMP (HBLKSIZE - 1)\n+\n+# define HDR_FROM_BI(bi, p) \\\n+\t\t((bi)->index[((word)(p) >> LOG_HBLKSIZE) & (BOTTOM_SZ - 1)])\n+# ifndef HASH_TL\n+#   define BI(p) (GC_top_index \\\n+\t\t[(word)(p) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE)])\n+#   define HDR_INNER(p) HDR_FROM_BI(BI(p),p)\n+#   ifdef SMALL_CONFIG\n+#\tdefine HDR(p) GC_find_header((ptr_t)(p))\n+#   else\n+#\tdefine HDR(p) HDR_INNER(p)\n+#   endif\n+#   define GET_BI(p, bottom_indx) (bottom_indx) = BI(p)\n+#   define GET_HDR(p, hhdr) (hhdr) = HDR(p)\n+#   define SET_HDR(p, hhdr) HDR_INNER(p) = (hhdr)\n+#   define GET_HDR_ADDR(p, ha) (ha) = &(HDR_INNER(p))\n+# else /* hash */\n+/*  Hash function for tree top level */\n+#   define TL_HASH(hi) ((hi) & (TOP_SZ - 1))\n+/*  Set bottom_indx to point to the bottom index for address p */\n+#   define GET_BI(p, bottom_indx) \\\n+\t{ \\\n+\t    register word hi = \\\n+\t        (word)(p) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n+\t    register bottom_index * _bi = GC_top_index[TL_HASH(hi)]; \\\n+\t    \\\n+\t    while (_bi -> key != hi && _bi != GC_all_nils) \\\n+\t    \t_bi = _bi -> hash_link; \\\n+\t    (bottom_indx) = _bi; \\\n+\t}\n+#   define GET_HDR_ADDR(p, ha) \\\n+\t{ \\\n+\t    register bottom_index * bi; \\\n+\t    \\\n+\t    GET_BI(p, bi);\t\\\n+\t    (ha) = &(HDR_FROM_BI(bi, p)); \\\n+\t}\n+#   define GET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n+\t\t\t      (hhdr) = *_ha; }\n+#   define SET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n+\t\t\t      *_ha = (hhdr); }\n+#   define HDR(p) GC_find_header((ptr_t)(p))\n+# endif\n+\t\t\t    \n+/* Is the result a forwarding address to someplace closer to the\t*/\n+/* beginning of the block or NIL?\t\t\t\t\t*/\n+# define IS_FORWARDING_ADDR_OR_NIL(hhdr) ((unsigned long) (hhdr) <= MAX_JUMP)\n+\n+/* Get an HBLKSIZE aligned address closer to the beginning of the block */\n+/* h.  Assumes hhdr == HDR(h) and IS_FORWARDING_ADDR(hhdr).\t\t*/\n+# define FORWARDED_ADDR(h, hhdr) ((struct hblk *)(h) - (unsigned long)(hhdr))\n+# endif /*  GC_HEADERS_H */"}, {"sha": "96ba1da104476113a06ad3574dc6ae12541d1807", "filename": "boehm-gc/include/private/gc_priv.h", "status": "added", "additions": 1561, "deletions": 0, "changes": 1561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,1561 @@\n+/* \n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/* Boehm, February 16, 1996 2:30 pm PST */\n+ \n+\n+# ifndef GC_PRIVATE_H\n+# define GC_PRIVATE_H\n+\n+#if defined(mips) && defined(SYSTYPE_BSD) && defined(sony_news)\n+    /* sony RISC NEWS, NEWSOS 4 */\n+#   define BSD_TIME\n+/*    typedef long ptrdiff_t;   -- necessary on some really old systems\t*/\n+#endif\n+\n+#if defined(mips) && defined(SYSTYPE_BSD43)\n+    /* MIPS RISCOS 4 */\n+#   define BSD_TIME\n+#endif\n+\n+#ifdef BSD_TIME\n+#   include <sys/types.h>\n+#   include <sys/time.h>\n+#   include <sys/resource.h>\n+#endif /* BSD_TIME */\n+\n+# ifndef GC_H\n+#   include \"gc.h\"\n+# endif\n+\n+typedef GC_word word;\n+typedef GC_signed_word signed_word;\n+\n+# ifndef CONFIG_H\n+#   include \"config.h\"\n+# endif\n+\n+# ifndef HEADERS_H\n+#   include \"gc_hdrs.h\"\n+# endif\n+\n+typedef int GC_bool;\n+# define TRUE 1\n+# define FALSE 0\n+\n+typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n+\t\t\t/* byte displacements.\t\t\t\t*/\n+\t\t\t/* Preferably identical to caddr_t, if it \t*/\n+\t\t\t/* exists.\t\t\t\t\t*/\n+\t\t\t\n+#if defined(__STDC__)\n+#   include <stdlib.h>\n+#   if !(defined( sony_news ) )\n+#       include <stddef.h>\n+#   endif\n+#   define VOLATILE volatile\n+#   define CONST const\n+#else\n+#   ifdef MSWIN32\n+#   \tinclude <stdlib.h>\n+#   endif\n+#   define VOLATILE\n+#   define CONST\n+#endif\n+\n+#ifdef AMIGA\n+#   define GC_FAR __far\n+#else\n+#   define GC_FAR\n+#endif\n+\n+/*********************************/\n+/*                               */\n+/* Definitions for conservative  */\n+/* collector                     */\n+/*                               */\n+/*********************************/\n+\n+/*********************************/\n+/*                               */\n+/* Easily changeable parameters  */\n+/*                               */\n+/*********************************/\n+\n+#define STUBBORN_ALLOC\t/* Define stubborn allocation primitives\t*/\n+#if defined(SRC_M3) || defined(SMALL_CONFIG)\n+# undef STUBBORN_ALLOC\n+#endif\n+\n+\n+/* #define ALL_INTERIOR_POINTERS */\n+\t\t    /* Forces all pointers into the interior of an \t*/\n+\t\t    /* object to be considered valid.  Also causes the\t*/\n+\t\t    /* sizes of all objects to be inflated by at least \t*/\n+\t\t    /* one byte.  This should suffice to guarantee\t*/\n+\t\t    /* that in the presence of a compiler that does\t*/\n+\t\t    /* not perform garbage-collector-unsafe\t\t*/\n+\t\t    /* optimizations, all portable, strictly ANSI\t*/\n+\t\t    /* conforming C programs should be safely usable\t*/\n+\t\t    /* with malloc replaced by GC_malloc and free\t*/\n+\t\t    /* calls removed.  There are several disadvantages: */\n+\t\t    /* 1. There are probably no interesting, portable,\t*/\n+\t\t    /*    strictly ANSI\tconforming C programs.\t\t*/\n+\t\t    /* 2. This option makes it hard for the collector\t*/\n+\t\t    /*    to allocate space that is not ``pointed to''  */\n+\t\t    /*    by integers, etc.  Under SunOS 4.X with a \t*/\n+\t\t    /*    statically linked libc, we empiricaly\t\t*/\n+\t\t    /*    observed that it would be difficult to \t*/\n+\t\t    /*\t  allocate individual objects larger than 100K.\t*/\n+\t\t    /* \t  Even if only smaller objects are allocated,\t*/\n+\t\t    /*    more swap space is likely to be needed.       */\n+\t\t    /*    Fortunately, much of this will never be\t*/\n+\t\t    /*    touched.\t\t\t\t\t*/\n+\t\t    /* If you can easily avoid using this option, do.\t*/\n+\t\t    /* If not, try to keep individual objects small.\t*/\n+\t\t    \n+#define PRINTSTATS  /* Print garbage collection statistics          \t*/\n+\t\t    /* For less verbose output, undefine in reclaim.c \t*/\n+\n+#define PRINTTIMES  /* Print the amount of time consumed by each garbage   */\n+\t\t    /* collection.                                         */\n+\n+#define PRINTBLOCKS /* Print object sizes associated with heap blocks,     */\n+\t\t    /* whether the objects are atomic or composite, and    */\n+\t\t    /* whether or not the block was found to be empty      */\n+\t\t    /* during the reclaim phase.  Typically generates       */\n+\t\t    /* about one screenful per garbage collection.         */\n+#undef PRINTBLOCKS\n+\n+#ifdef SILENT\n+#  ifdef PRINTSTATS\n+#    undef PRINTSTATS\n+#  endif\n+#  ifdef PRINTTIMES\n+#    undef PRINTTIMES\n+#  endif\n+#  ifdef PRINTNBLOCKS\n+#    undef PRINTNBLOCKS\n+#  endif\n+#endif\n+\n+#if defined(PRINTSTATS) && !defined(GATHERSTATS)\n+#   define GATHERSTATS\n+#endif\n+\n+#ifdef FINALIZE_ON_DEMAND\n+#   define GC_INVOKE_FINALIZERS()\n+#else\n+#   define GC_INVOKE_FINALIZERS() (void)GC_invoke_finalizers()\n+#endif\n+\n+#define MERGE_SIZES /* Round up some object sizes, so that fewer distinct */\n+\t\t    /* free lists are actually maintained.  This applies  */\n+\t\t    /* only to the top level routines in misc.c, not to   */\n+\t\t    /* user generated code that calls GC_allocobj and     */\n+\t\t    /* GC_allocaobj directly.                             */\n+\t\t    /* Slows down average programs slightly.  May however */\n+\t\t    /* substantially reduce fragmentation if allocation   */\n+\t\t    /* request sizes are widely scattered.                */\n+\t\t    /* May save significant amounts of space for obj_map  */\n+\t\t    /* entries.\t\t\t\t\t\t  */\n+\n+#ifndef OLD_BLOCK_ALLOC\n+   /* Macros controlling large block allocation strategy.\t*/\n+#  define EXACT_FIRST  \t/* Make a complete pass through the large object */\n+\t\t\t/* free list before splitting a block\t\t */\n+#  define PRESERVE_LAST /* Do not divide last allocated heap segment\t */\n+\t\t\t/* unless we would otherwise need to expand the\t */\n+\t\t\t/* heap.\t\t\t\t\t */\n+#endif\n+\n+/* ALIGN_DOUBLE requires MERGE_SIZES at present. */\n+# if defined(ALIGN_DOUBLE) && !defined(MERGE_SIZES)\n+#   define MERGE_SIZES\n+# endif\n+\n+#if defined(ALL_INTERIOR_POINTERS) && !defined(DONT_ADD_BYTE_AT_END)\n+# define ADD_BYTE_AT_END\n+#endif\n+\n+\n+# ifndef LARGE_CONFIG\n+#   define MINHINCR 16\t/* Minimum heap increment, in blocks of HBLKSIZE  */\n+\t\t\t/* Must be multiple of largest page size.\t  */\n+#   define MAXHINCR 512\t/* Maximum heap increment, in blocks              */\n+# else\n+#   define MINHINCR 64\n+#   define MAXHINCR 4096\n+# endif\n+\n+# define TIME_LIMIT 50\t   /* We try to keep pause times from exceeding\t */\n+\t\t\t   /* this by much. In milliseconds.\t\t */\n+\n+# define BL_LIMIT GC_black_list_spacing\n+\t\t\t   /* If we need a block of N bytes, and we have */\n+\t\t\t   /* a block of N + BL_LIMIT bytes available, \t */\n+\t\t\t   /* and N > BL_LIMIT,\t\t\t\t */\n+\t\t\t   /* but all possible positions in it are \t */\n+\t\t\t   /* blacklisted, we just use it anyway (and\t */\n+\t\t\t   /* print a warning, if warnings are enabled). */\n+\t\t\t   /* This risks subsequently leaking the block\t */\n+\t\t\t   /* due to a false reference.  But not using\t */\n+\t\t\t   /* the block risks unreasonable immediate\t */\n+\t\t\t   /* heap growth.\t\t\t\t */\n+\n+/*********************************/\n+/*                               */\n+/* Stack saving for debugging\t */\n+/*                               */\n+/*********************************/\n+\n+#ifdef SAVE_CALL_CHAIN\n+\n+/*\n+ * Number of frames and arguments to save in objects allocated by\n+ * debugging allocator.\n+ */\n+#   define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n+\t\t\t/* alignment reasons.\t\t\t\t*/\n+#   define NARGS 2\t/* Mumber of arguments to save for each call.\t*/\n+\n+#   define NEED_CALLINFO\n+\n+/* Fill in the pc and argument information for up to NFRAMES of my\t*/\n+/* callers.  Ignore my frame and my callers frame.\t\t\t*/\n+void GC_save_callers (/* struct callinfo info[NFRAMES] */);\n+\n+void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n+\n+#else\n+\n+# ifdef GC_ADD_CALLER\n+#   define NFRAMES 1\n+#   define NARGS 0\n+#   define NEED_CALLINFO\n+# endif\n+\n+#endif\n+\n+#ifdef NEED_CALLINFO\n+    struct callinfo {\n+\tword ci_pc;\n+#\tif NARGS > 0\n+\t    word ci_arg[NARGS];\t/* bit-wise complement to avoid retention */\n+#\tendif\n+#\tif defined(ALIGN_DOUBLE) && (NFRAMES * (NARGS + 1)) % 2 == 1\n+\t    /* Likely alignment problem. */\n+\t    word ci_dummy;\n+#\tendif\n+    };\n+#endif\n+\n+\n+/*********************************/\n+/*                               */\n+/* OS interface routines\t */\n+/*                               */\n+/*********************************/\n+\n+#ifdef BSD_TIME\n+#   undef CLOCK_TYPE\n+#   undef GET_TIME\n+#   undef MS_TIME_DIFF\n+#   define CLOCK_TYPE struct timeval\n+#   define GET_TIME(x) { struct rusage rusage; \\\n+\t\t\t getrusage (RUSAGE_SELF,  &rusage); \\\n+\t\t\t x = rusage.ru_utime; }\n+#   define MS_TIME_DIFF(a,b) ((double) (a.tv_sec - b.tv_sec) * 1000.0 \\\n+                               + (double) (a.tv_usec - b.tv_usec) / 1000.0)\n+#else /* !BSD_TIME */\n+#   include <time.h>\n+#   if !defined(__STDC__) && defined(SPARC) && defined(SUNOS4)\n+      clock_t clock();\t/* Not in time.h, where it belongs\t*/\n+#   endif\n+#   if defined(FREEBSD) && !defined(CLOCKS_PER_SEC)\n+#     include <machine/limits.h>\n+#     define CLOCKS_PER_SEC CLK_TCK\n+#   endif\n+#   if !defined(CLOCKS_PER_SEC)\n+#     define CLOCKS_PER_SEC 1000000\n+/*\n+ * This is technically a bug in the implementation.  ANSI requires that\n+ * CLOCKS_PER_SEC be defined.  But at least under SunOS4.1.1, it isn't.\n+ * Also note that the combination of ANSI C and POSIX is incredibly gross\n+ * here. The type clock_t is used by both clock() and times().  But on\n+ * some machines these use different notions of a clock tick,  CLOCKS_PER_SEC\n+ * seems to apply only to clock.  Hence we use it here.  On many machines,\n+ * including SunOS, clock actually uses units of microseconds (which are\n+ * not really clock ticks).\n+ */\n+#   endif\n+#   define CLOCK_TYPE clock_t\n+#   define GET_TIME(x) x = clock()\n+#   define MS_TIME_DIFF(a,b) ((unsigned long) \\\n+\t\t(1000.0*(double)((a)-(b))/(double)CLOCKS_PER_SEC))\n+#endif /* !BSD_TIME */\n+\n+/* We use bzero and bcopy internally.  They may not be available.\t*/\n+# if defined(SPARC) && defined(SUNOS4)\n+#   define BCOPY_EXISTS\n+# endif\n+# if defined(M68K) && defined(AMIGA)\n+#   define BCOPY_EXISTS\n+# endif\n+# if defined(M68K) && defined(NEXT)\n+#   define BCOPY_EXISTS\n+# endif\n+# if defined(VAX)\n+#   define BCOPY_EXISTS\n+# endif\n+# if defined(AMIGA)\n+#   include <string.h>\n+#   define BCOPY_EXISTS\n+# endif\n+\n+# ifndef BCOPY_EXISTS\n+#   include <string.h>\n+#   define BCOPY(x,y,n) memcpy(y, x, (size_t)(n))\n+#   define BZERO(x,n)  memset(x, 0, (size_t)(n))\n+# else\n+#   define BCOPY(x,y,n) bcopy((char *)(x),(char *)(y),(int)(n))\n+#   define BZERO(x,n) bzero((char *)(x),(int)(n))\n+# endif\n+\n+/* HBLKSIZE aligned allocation.  0 is taken to mean failure \t*/\n+/* space is assumed to be cleared.\t\t\t\t*/\n+/* In the case os USE_MMAP, the argument must also be a \t*/\n+/* physical page size.\t\t\t\t\t\t*/\n+# ifdef PCR\n+    char * real_malloc();\n+#   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n+\t\t\t\t  + GC_page_size-1)\n+# else\n+#   ifdef OS2\n+      void * os2_alloc(size_t bytes);\n+#     define GET_MEM(bytes) HBLKPTR((ptr_t)os2_alloc((size_t)bytes \\\n+\t\t\t\t    + GC_page_size) \\\n+                                    + GC_page_size-1)\n+#   else\n+#     if defined(AMIGA) || defined(NEXT) || defined(DOS4GW)\n+#       define GET_MEM(bytes) HBLKPTR((size_t) \\\n+\t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n+                                      + GC_page_size-1)\n+#     else\n+#\tifdef MSWIN32\n+          extern ptr_t GC_win32_get_mem();\n+#         define GET_MEM(bytes) (struct hblk *)GC_win32_get_mem(bytes)\n+#\telse\n+#\t  ifdef MACOS\n+#\t    if defined(USE_TEMPORARY_MEMORY)\n+\t\textern Ptr GC_MacTemporaryNewPtr(size_t size,\n+\t\t\t\t\t\t Boolean clearMemory);\n+#               define GET_MEM(bytes) HBLKPTR( \\\n+\t\t    GC_MacTemporaryNewPtr(bytes + GC_page_size, true) \\\n+\t\t    + GC_page_size-1)\n+#\t    else\n+#         \t    define GET_MEM(bytes) HBLKPTR( \\\n+\t\t\tNewPtrClear(bytes + GC_page_size) + GC_page_size-1)\n+#\t    endif\n+#\t  else\n+              extern ptr_t GC_unix_get_mem();\n+#             define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)\n+#\t  endif\n+#\tendif\n+#     endif\n+#   endif\n+# endif\n+\n+/*\n+ * Mutual exclusion between allocator/collector routines.\n+ * Needed if there is more than one allocator thread.\n+ * FASTLOCK() is assumed to try to acquire the lock in a cheap and\n+ * dirty way that is acceptable for a few instructions, e.g. by\n+ * inhibiting preemption.  This is assumed to have succeeded only\n+ * if a subsequent call to FASTLOCK_SUCCEEDED() returns TRUE.\n+ * FASTUNLOCK() is called whether or not FASTLOCK_SUCCEEDED().\n+ * If signals cannot be tolerated with the FASTLOCK held, then\n+ * FASTLOCK should disable signals.  The code executed under\n+ * FASTLOCK is otherwise immune to interruption, provided it is\n+ * not restarted.\n+ * DCL_LOCK_STATE declares any local variables needed by LOCK and UNLOCK\n+ * and/or DISABLE_SIGNALS and ENABLE_SIGNALS and/or FASTLOCK.\n+ * (There is currently no equivalent for FASTLOCK.)\n+ */  \n+# ifdef THREADS\n+#  ifdef PCR_OBSOLETE\t/* Faster, but broken with multiple lwp's\t*/\n+#    include  \"th/PCR_Th.h\"\n+#    include  \"th/PCR_ThCrSec.h\"\n+     extern struct PCR_Th_MLRep GC_allocate_ml;\n+#    define DCL_LOCK_STATE  PCR_sigset_t GC_old_sig_mask\n+#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml) \n+#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n+#    define FASTLOCK() PCR_ThCrSec_EnterSys()\n+     /* Here we cheat (a lot): */\n+#        define FASTLOCK_SUCCEEDED() (*(int *)(&GC_allocate_ml) == 0)\n+\t\t/* TRUE if nobody currently holds the lock */\n+#    define FASTUNLOCK() PCR_ThCrSec_ExitSys()\n+#  endif\n+#  ifdef PCR\n+#    include <base/PCR_Base.h>\n+#    include <th/PCR_Th.h>\n+     extern PCR_Th_ML GC_allocate_ml;\n+#    define DCL_LOCK_STATE \\\n+\t PCR_ERes GC_fastLockRes; PCR_sigset_t GC_old_sig_mask\n+#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml)\n+#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n+#    define FASTLOCK() (GC_fastLockRes = PCR_Th_ML_Try(&GC_allocate_ml))\n+#    define FASTLOCK_SUCCEEDED() (GC_fastLockRes == PCR_ERes_okay)\n+#    define FASTUNLOCK()  {\\\n+        if( FASTLOCK_SUCCEEDED() ) PCR_Th_ML_Release(&GC_allocate_ml); }\n+#  endif\n+#  ifdef SRC_M3\n+     extern word RT0u__inCritical;\n+#    define LOCK() RT0u__inCritical++\n+#    define UNLOCK() RT0u__inCritical--\n+#  endif\n+#  ifdef SOLARIS_THREADS\n+#    include <thread.h>\n+#    include <signal.h>\n+     extern mutex_t GC_allocate_ml;\n+#    define LOCK() mutex_lock(&GC_allocate_ml);\n+#    define UNLOCK() mutex_unlock(&GC_allocate_ml);\n+#  endif\n+#  ifdef LINUX_THREADS\n+#    include <pthread.h>\n+#    ifdef __i386__\n+       inline static GC_test_and_set(volatile unsigned int *addr) {\n+\t  int oldval;\n+\t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n+\t  __asm__ __volatile__(\"xchgl %0, %1\"\n+\t\t: \"=r\"(oldval), \"=m\"(*(addr))\n+\t\t: \"0\"(1), \"m\"(*(addr)));\n+\t  return oldval;\n+       }\n+#    else\n+       -- > Need implementation of GC_test_and_set()\n+#    endif\n+#    define GC_clear(addr) (*(addr) = 0)\n+\n+     extern volatile unsigned int GC_allocate_lock;\n+\t/* This is not a mutex because mutexes that obey the (optional)     */\n+\t/* POSIX scheduling rules are subject to convoys in high contention */\n+\t/* applications.  This is basically a spin lock.\t\t    */\n+     extern pthread_t GC_lock_holder;\n+     extern void GC_lock(void);\n+\t/* Allocation lock holder.  Only set if acquired by client through */\n+\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n+#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n+#    define NO_THREAD (pthread_t)(-1)\n+#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n+#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n+#    ifdef UNDEFINED\n+#    \tdefine LOCK() pthread_mutex_lock(&GC_allocate_ml)\n+#    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#    else\n+#\tdefine LOCK() \\\n+\t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n+#\tdefine UNLOCK() \\\n+\t\tGC_clear(&GC_allocate_lock)\n+#    endif\n+     extern GC_bool GC_collecting;\n+#    define ENTER_GC() \\\n+\t\t{ \\\n+\t\t    GC_collecting = 1; \\\n+\t\t}\n+#    define EXIT_GC() GC_collecting = 0;\n+#  endif /* LINUX_THREADS */\n+#  ifdef IRIX_THREADS\n+#    include <pthread.h>\n+#    include <mutex.h>\n+\n+#    if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n+#        define GC_test_and_set(addr, v) test_and_set(addr,v)\n+#    else\n+#\t  define GC_test_and_set(addr, v) __test_and_set(addr,v)\n+#    endif\n+     extern unsigned long GC_allocate_lock;\n+\t/* This is not a mutex because mutexes that obey the (optional) \t*/\n+\t/* POSIX scheduling rules are subject to convoys in high contention\t*/\n+\t/* applications.  This is basically a spin lock.\t\t\t*/\n+     extern pthread_t GC_lock_holder;\n+     extern void GC_lock(void);\n+\t/* Allocation lock holder.  Only set if acquired by client through */\n+\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n+#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n+#    define NO_THREAD (pthread_t)(-1)\n+#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n+#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n+#    ifdef UNDEFINED\n+#    \tdefine LOCK() pthread_mutex_lock(&GC_allocate_ml)\n+#    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#    else\n+#\tdefine LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n+#       if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64))\n+#\t    define UNLOCK() __lock_release(&GC_allocate_lock)\n+#\telse\n+#           define UNLOCK() GC_allocate_lock = 0\n+#\tendif\n+#    endif\n+     extern GC_bool GC_collecting;\n+#    define ENTER_GC() \\\n+\t\t{ \\\n+\t\t    GC_collecting = 1; \\\n+\t\t}\n+#    define EXIT_GC() GC_collecting = 0;\n+#  endif /* IRIX_THREADS */\n+#  ifdef WIN32_THREADS\n+#    include <windows.h>\n+     GC_API CRITICAL_SECTION GC_allocate_ml;\n+#    define LOCK() EnterCriticalSection(&GC_allocate_ml);\n+#    define UNLOCK() LeaveCriticalSection(&GC_allocate_ml);\n+#  endif\n+#  ifndef SET_LOCK_HOLDER\n+#      define SET_LOCK_HOLDER()\n+#      define UNSET_LOCK_HOLDER()\n+#      define I_HOLD_LOCK() FALSE\n+\t\t/* Used on platforms were locks can be reacquired,\t*/\n+\t\t/* so it doesn't matter if we lie.\t\t\t*/\n+#  endif\n+# else\n+#    define LOCK()\n+#    define UNLOCK()\n+# endif\n+# ifndef SET_LOCK_HOLDER\n+#   define SET_LOCK_HOLDER()\n+#   define UNSET_LOCK_HOLDER()\n+#   define I_HOLD_LOCK() FALSE\n+\t\t/* Used on platforms were locks can be reacquired,\t*/\n+\t\t/* so it doesn't matter if we lie.\t\t\t*/\n+# endif\n+# ifndef ENTER_GC\n+#   define ENTER_GC()\n+#   define EXIT_GC()\n+# endif\n+\n+# ifndef DCL_LOCK_STATE\n+#   define DCL_LOCK_STATE\n+# endif\n+# ifndef FASTLOCK\n+#   define FASTLOCK() LOCK()\n+#   define FASTLOCK_SUCCEEDED() TRUE\n+#   define FASTUNLOCK() UNLOCK()\n+# endif\n+\n+/* Delay any interrupts or signals that may abort this thread.  Data\t*/\n+/* structures are in a consistent state outside this pair of calls.\t*/\n+/* ANSI C allows both to be empty (though the standard isn't very\t*/\n+/* clear on that point).  Standard malloc implementations are usually\t*/\n+/* neither interruptable nor thread-safe, and thus correspond to\t*/\n+/* empty definitions.\t\t\t\t\t\t\t*/\n+# ifdef PCR\n+#   define DISABLE_SIGNALS() \\\n+\t\t PCR_Th_SetSigMask(PCR_allSigsBlocked,&GC_old_sig_mask)\n+#   define ENABLE_SIGNALS() \\\n+\t\tPCR_Th_SetSigMask(&GC_old_sig_mask, NIL)\n+# else\n+#   if defined(SRC_M3) || defined(AMIGA) || defined(SOLARIS_THREADS) \\\n+\t|| defined(MSWIN32) || defined(MACOS) || defined(DJGPP) \\\n+\t|| defined(NO_SIGNALS) || defined(IRIX_THREADS) \\\n+\t|| defined(LINUX_THREADS)\n+\t\t\t/* Also useful for debugging.\t\t*/\n+\t/* Should probably use thr_sigsetmask for SOLARIS_THREADS. */\n+#     define DISABLE_SIGNALS()\n+#     define ENABLE_SIGNALS()\n+#   else\n+#     define DISABLE_SIGNALS() GC_disable_signals()\n+\tvoid GC_disable_signals();\n+#     define ENABLE_SIGNALS() GC_enable_signals()\n+\tvoid GC_enable_signals();\n+#   endif\n+# endif\n+\n+/*\n+ * Stop and restart mutator threads.\n+ */\n+# ifdef PCR\n+#     include \"th/PCR_ThCtl.h\"\n+#     define STOP_WORLD() \\\n+ \tPCR_ThCtl_SetExclusiveMode(PCR_ThCtl_ExclusiveMode_stopNormal, \\\n+ \t\t\t\t   PCR_allSigsBlocked, \\\n+ \t\t\t\t   PCR_waitForever)\n+#     define START_WORLD() \\\n+\tPCR_ThCtl_SetExclusiveMode(PCR_ThCtl_ExclusiveMode_null, \\\n+ \t\t\t\t   PCR_allSigsBlocked, \\\n+ \t\t\t\t   PCR_waitForever);\n+# else\n+#   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n+\t|| defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+      void GC_stop_world();\n+      void GC_start_world();\n+#     define STOP_WORLD() GC_stop_world()\n+#     define START_WORLD() GC_start_world()\n+#   else\n+#     define STOP_WORLD()\n+#     define START_WORLD()\n+#   endif\n+# endif\n+\n+/* Abandon ship */\n+# ifdef PCR\n+#   define ABORT(s) PCR_Base_Panic(s)\n+# else\n+#   ifdef SMALL_CONFIG\n+#\tdefine ABORT(msg) abort();\n+#   else\n+\tGC_API void GC_abort();\n+#       define ABORT(msg) GC_abort(msg);\n+#   endif\n+# endif\n+\n+/* Exit abnormally, but without making a mess (e.g. out of memory) */\n+# ifdef PCR\n+#   define EXIT() PCR_Base_Exit(1,PCR_waitForever)\n+# else\n+#   define EXIT() (void)exit(1)\n+# endif\n+\n+/* Print warning message, e.g. almost out of memory.\t*/\n+# define WARN(msg,arg) (*GC_current_warn_proc)(msg, (GC_word)(arg))\n+extern GC_warn_proc GC_current_warn_proc;\n+\n+/*********************************/\n+/*                               */\n+/* Word-size-dependent defines   */\n+/*                               */\n+/*********************************/\n+\n+#if CPP_WORDSZ == 32\n+#  define WORDS_TO_BYTES(x)   ((x)<<2)\n+#  define BYTES_TO_WORDS(x)   ((x)>>2)\n+#  define LOGWL               ((word)5)    /* log[2] of CPP_WORDSZ */\n+#  define modWORDSZ(n) ((n) & 0x1f)        /* n mod size of word\t    */\n+#  if ALIGNMENT != 4\n+#\tdefine UNALIGNED\n+#  endif\n+#endif\n+\n+#if CPP_WORDSZ == 64\n+#  define WORDS_TO_BYTES(x)   ((x)<<3)\n+#  define BYTES_TO_WORDS(x)   ((x)>>3)\n+#  define LOGWL               ((word)6)    /* log[2] of CPP_WORDSZ */\n+#  define modWORDSZ(n) ((n) & 0x3f)        /* n mod size of word\t    */\n+#  if ALIGNMENT != 8\n+#\tdefine UNALIGNED\n+#  endif\n+#endif\n+\n+#define WORDSZ ((word)CPP_WORDSZ)\n+#define SIGNB  ((word)1 << (WORDSZ-1))\n+#define BYTES_PER_WORD      ((word)(sizeof (word)))\n+#define ONES                ((word)(-1))\n+#define divWORDSZ(n) ((n) >> LOGWL)\t   /* divide n by size of word      */\n+\n+/*********************/\n+/*                   */\n+/*  Size Parameters  */\n+/*                   */\n+/*********************/\n+\n+/*  heap block size, bytes. Should be power of 2 */\n+\n+#ifndef HBLKSIZE\n+# ifdef SMALL_CONFIG\n+#   define CPP_LOG_HBLKSIZE 10\n+# else\n+#   if CPP_WORDSZ == 32\n+#     define CPP_LOG_HBLKSIZE 12\n+#   else\n+#     define CPP_LOG_HBLKSIZE 13\n+#   endif\n+# endif\n+#else\n+# if HBLKSIZE == 512\n+#   define CPP_LOG_HBLKSIZE 9\n+# endif\n+# if HBLKSIZE == 1024\n+#   define CPP_LOG_HBLKSIZE 10\n+# endif\n+# if HBLKSIZE == 2048\n+#   define CPP_LOG_HBLKSIZE 11\n+# endif\n+# if HBLKSIZE == 4096\n+#   define CPP_LOG_HBLKSIZE 12\n+# endif\n+# if HBLKSIZE == 8192\n+#   define CPP_LOG_HBLKSIZE 13\n+# endif\n+# if HBLKSIZE == 16384\n+#   define CPP_LOG_HBLKSIZE 14\n+# endif\n+# ifndef CPP_LOG_HBLKSIZE\n+    --> fix HBLKSIZE\n+# endif\n+# undef HBLKSIZE\n+#endif\n+# define CPP_HBLKSIZE (1 << CPP_LOG_HBLKSIZE)\n+# define LOG_HBLKSIZE   ((word)CPP_LOG_HBLKSIZE)\n+# define HBLKSIZE ((word)CPP_HBLKSIZE)\n+\n+\n+/*  max size objects supported by freelist (larger objects may be   */\n+/*  allocated, but less efficiently)                                */\n+\n+#define CPP_MAXOBJSZ    BYTES_TO_WORDS(CPP_HBLKSIZE/2)\n+#define MAXOBJSZ ((word)CPP_MAXOBJSZ)\n+\t\t\n+# define divHBLKSZ(n) ((n) >> LOG_HBLKSIZE)\n+\n+# define HBLK_PTR_DIFF(p,q) divHBLKSZ((ptr_t)p - (ptr_t)q)\n+\t/* Equivalent to subtracting 2 hblk pointers.\t*/\n+\t/* We do it this way because a compiler should\t*/\n+\t/* find it hard to use an integer division\t*/\n+\t/* instead of a shift.  The bundled SunOS 4.1\t*/\n+\t/* o.w. sometimes pessimizes the subtraction to\t*/\n+\t/* involve a call to .div.\t\t\t*/\n+ \n+# define modHBLKSZ(n) ((n) & (HBLKSIZE-1))\n+ \n+# define HBLKPTR(objptr) ((struct hblk *)(((word) (objptr)) & ~(HBLKSIZE-1)))\n+\n+# define HBLKDISPL(objptr) (((word) (objptr)) & (HBLKSIZE-1))\n+\n+/* Round up byte allocation requests to integral number of words, etc. */\n+# ifdef ADD_BYTE_AT_END\n+#   define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1))\n+#   ifdef ALIGN_DOUBLE\n+#       define ALIGNED_WORDS(n) (BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2)) & ~1)\n+#   else\n+#       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n+#   endif\n+#   define SMALL_OBJ(bytes) ((bytes) < WORDS_TO_BYTES(MAXOBJSZ))\n+#   define ADD_SLOP(bytes) ((bytes)+1)\n+# else\n+#   define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + (WORDS_TO_BYTES(1) - 1))\n+#   ifdef ALIGN_DOUBLE\n+#       define ALIGNED_WORDS(n) \\\n+\t\t\t(BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2) - 1) & ~1)\n+#   else\n+#       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n+#   endif\n+#   define SMALL_OBJ(bytes) ((bytes) <= WORDS_TO_BYTES(MAXOBJSZ))\n+#   define ADD_SLOP(bytes) (bytes)\n+# endif\n+\n+\n+/*\n+ * Hash table representation of sets of pages.  This assumes it is\n+ * OK to add spurious entries to sets.\n+ * Used by black-listing code, and perhaps by dirty bit maintenance code.\n+ */\n+ \n+# ifdef LARGE_CONFIG\n+#   define LOG_PHT_ENTRIES  17\n+# else\n+#   define LOG_PHT_ENTRIES  14\t/* Collisions are likely if heap grows\t*/\n+\t\t\t\t/* to more than 16K hblks = 64MB.\t*/\n+\t\t\t\t/* Each hash table occupies 2K bytes.   */\n+# endif\n+# define PHT_ENTRIES ((word)1 << LOG_PHT_ENTRIES)\n+# define PHT_SIZE (PHT_ENTRIES >> LOGWL)\n+typedef word page_hash_table[PHT_SIZE];\n+\n+# define PHT_HASH(addr) ((((word)(addr)) >> LOG_HBLKSIZE) & (PHT_ENTRIES - 1))\n+\n+# define get_pht_entry_from_index(bl, index) \\\n+\t\t(((bl)[divWORDSZ(index)] >> modWORDSZ(index)) & 1)\n+# define set_pht_entry_from_index(bl, index) \\\n+\t\t(bl)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n+# define clear_pht_entry_from_index(bl, index) \\\n+\t\t(bl)[divWORDSZ(index)] &= ~((word)1 << modWORDSZ(index))\n+\t\n+\n+\n+/********************************************/\n+/*                                          */\n+/*    H e a p   B l o c k s                 */\n+/*                                          */\n+/********************************************/\n+\n+/*  heap block header */\n+#define HBLKMASK   (HBLKSIZE-1)\n+\n+#define BITS_PER_HBLK (HBLKSIZE * 8)\n+\n+#define MARK_BITS_PER_HBLK (BITS_PER_HBLK/CPP_WORDSZ)\n+\t   /* upper bound                                    */\n+\t   /* We allocate 1 bit/word.  Only the first word   */\n+\t   /* in each object is actually marked.             */\n+\n+# ifdef ALIGN_DOUBLE\n+#   define MARK_BITS_SZ (((MARK_BITS_PER_HBLK + 2*CPP_WORDSZ - 1) \\\n+\t\t\t  / (2*CPP_WORDSZ))*2)\n+# else\n+#   define MARK_BITS_SZ ((MARK_BITS_PER_HBLK + CPP_WORDSZ - 1)/CPP_WORDSZ)\n+# endif\n+\t   /* Upper bound on number of mark words per heap block  */\n+\n+struct hblkhdr {\n+    word hb_sz;  /* If in use, size in words, of objects in the block. */\n+\t\t /* if free, the size in bytes of the whole block      */\n+    struct hblk * hb_next; \t/* Link field for hblk free list\t */\n+    \t\t\t\t/* and for lists of chunks waiting to be */\n+    \t\t\t\t/* reclaimed.\t\t\t\t */\n+    word hb_descr;   \t\t/* object descriptor for marking.  See\t*/\n+    \t\t\t\t/* mark.h.\t\t\t\t*/\n+    char* hb_map;\t/* A pointer to a pointer validity map of the block. */\n+    \t\t      \t/* See GC_obj_map.\t\t\t\t     */\n+    \t\t     \t/* Valid for all blocks with headers.\t\t     */\n+    \t\t     \t/* Free blocks point to GC_invalid_map.\t\t     */\n+    unsigned char hb_obj_kind;\n+    \t\t\t /* Kind of objects in the block.  Each kind \t*/\n+    \t\t\t /* identifies a mark procedure and a set of \t*/\n+    \t\t\t /* list headers.  Sometimes called regions.\t*/\n+    unsigned char hb_flags;\n+#\tdefine IGNORE_OFF_PAGE\t1\t/* Ignore pointers that do not\t*/\n+\t\t\t\t\t/* point to the first page of \t*/\n+\t\t\t\t\t/* this object.\t\t\t*/\n+    unsigned short hb_last_reclaimed;\n+    \t\t\t\t/* Value of GC_gc_no when block was\t*/\n+    \t\t\t\t/* last allocated or swept. May wrap.   */\n+    word hb_marks[MARK_BITS_SZ];\n+\t\t\t    /* Bit i in the array refers to the             */\n+\t\t\t    /* object starting at the ith word (header      */\n+\t\t\t    /* INCLUDED) in the heap block.                 */\n+\t\t\t    /* The lsb of word 0 is numbered 0.\t\t    */\n+};\n+\n+/*  heap block body */\n+\n+# define DISCARD_WORDS 0\n+\t/* Number of words to be dropped at the beginning of each block\t*/\n+\t/* Must be a multiple of WORDSZ.  May reasonably be nonzero\t*/\n+\t/* on machines that don't guarantee longword alignment of\t*/\n+\t/* pointers, so that the number of false hits is minimized.\t*/\n+\t/* 0 and WORDSZ are probably the only reasonable values.\t*/\n+\n+# define BODY_SZ ((HBLKSIZE-WORDS_TO_BYTES(DISCARD_WORDS))/sizeof(word))\n+\n+struct hblk {\n+#   if (DISCARD_WORDS != 0)\n+        word garbage[DISCARD_WORDS];\n+#   endif\n+    word hb_body[BODY_SZ];\n+};\n+\n+# define HDR_WORDS ((word)DISCARD_WORDS)\n+# define HDR_BYTES ((word)WORDS_TO_BYTES(DISCARD_WORDS))\n+\n+# define OBJ_SZ_TO_BLOCKS(sz) \\\n+    divHBLKSZ(HDR_BYTES + WORDS_TO_BYTES(sz) + HBLKSIZE-1)\n+    /* Size of block (in units of HBLKSIZE) needed to hold objects of\t*/\n+    /* given sz (in words).\t\t\t\t\t\t*/\n+\n+/* Object free list link */\n+# define obj_link(p) (*(ptr_t *)(p))\n+\n+/*  lists of all heap blocks and free lists\t*/\n+/* These are grouped together in a struct\t*/\n+/* so that they can be easily skipped by the\t*/\n+/* GC_mark routine.\t\t\t\t*/\n+/* The ordering is weird to make GC_malloc\t*/\n+/* faster by keeping the important fields\t*/\n+/* sufficiently close together that a\t\t*/\n+/* single load of a base register will do.\t*/\n+/* Scalars that could easily appear to\t\t*/\n+/* be pointers are also put here.\t\t*/\n+/* The main fields should precede any \t\t*/\n+/* conditionally included fields, so that\t*/\n+/* gc_inl.h will work even if a different set\t*/\n+/* of macros is defined when the client is\t*/\n+/* compiled.\t\t\t\t\t*/\n+\n+struct _GC_arrays {\n+  word _heapsize;\n+  word _max_heapsize;\n+  ptr_t _last_heap_addr;\n+  ptr_t _prev_heap_addr;\n+  word _words_allocd_before_gc;\n+\t\t/* Number of words allocated before this\t*/\n+\t\t/* collection cycle.\t\t\t\t*/\n+  word _words_allocd;\n+  \t/* Number of words allocated during this collection cycle */\n+  word _words_wasted;\n+  \t/* Number of words wasted due to internal fragmentation\t*/\n+  \t/* in large objects, or due to dropping blacklisted     */\n+\t/* blocks, since last gc.  Approximate.                 */\n+  word _words_finalized;\n+  \t/* Approximate number of words in objects (and headers)\t*/\n+  \t/* That became ready for finalization in the last \t*/\n+  \t/* collection.\t\t\t\t\t\t*/\n+  word _non_gc_bytes_at_gc;\n+  \t/* Number of explicitly managed bytes of storage \t*/\n+  \t/* at last collection.\t\t\t\t\t*/\n+  word _mem_freed;\n+  \t/* Number of explicitly deallocated words of memory\t*/\n+  \t/* since last collection.\t\t\t\t*/\n+  \t\n+  ptr_t _objfreelist[MAXOBJSZ+1];\n+\t\t\t  /* free list for objects */\n+  ptr_t _aobjfreelist[MAXOBJSZ+1];\n+\t\t\t  /* free list for atomic objs \t*/\n+\n+  ptr_t _uobjfreelist[MAXOBJSZ+1];\n+\t\t\t  /* uncollectable but traced objs \t*/\n+\t\t\t  /* objects on this and auobjfreelist  */\n+\t\t\t  /* are always marked, except during   */\n+\t\t\t  /* garbage collections.\t\t*/\n+# ifdef ATOMIC_UNCOLLECTABLE\n+    ptr_t _auobjfreelist[MAXOBJSZ+1];\n+# endif\n+\t\t\t  /* uncollectable but traced objs \t*/\n+\n+# ifdef GATHERSTATS\n+    word _composite_in_use;\n+   \t\t/* Number of words in accessible composite\t*/\n+\t\t/* objects.\t\t\t\t\t*/\n+    word _atomic_in_use;\n+   \t\t/* Number of words in accessible atomic\t\t*/\n+\t\t/* objects.\t\t\t\t\t*/\n+# endif\n+# ifdef MERGE_SIZES\n+    unsigned _size_map[WORDS_TO_BYTES(MAXOBJSZ+1)];\n+    \t/* Number of words to allocate for a given allocation request in */\n+    \t/* bytes.\t\t\t\t\t\t\t */\n+# endif \n+\n+# ifdef STUBBORN_ALLOC\n+    ptr_t _sobjfreelist[MAXOBJSZ+1];\n+# endif\n+  \t\t\t  /* free list for immutable objects\t*/\n+  ptr_t _obj_map[MAXOBJSZ+1];\n+                       /* If not NIL, then a pointer to a map of valid  */\n+    \t\t       /* object addresses. _obj_map[sz][i] is j if the\t*/\n+    \t\t       /* address block_start+i is a valid pointer      */\n+    \t\t       /* to an object at\t\t\t\t*/\n+    \t\t       /* block_start+i&~3 - WORDS_TO_BYTES(j).\t\t*/\n+    \t\t       /* (If ALL_INTERIOR_POINTERS is defined, then\t*/\n+    \t\t       /* instead ((short *)(hbh_map[sz])[i] is j if\t*/\n+    \t\t       /* block_start+WORDS_TO_BYTES(i) is in the\t*/\n+    \t\t       /* interior of an object starting at\t\t*/\n+    \t\t       /* block_start+WORDS_TO_BYTES(i-j)).\t\t*/\n+    \t\t       /* It is OBJ_INVALID if\t\t\t\t*/\n+    \t\t       /* block_start+WORDS_TO_BYTES(i) is not\t\t*/\n+    \t\t       /* valid as a pointer to an object.              */\n+    \t\t       /* We assume all values of j <= OBJ_INVALID.\t*/\n+    \t\t       /* The zeroth entry corresponds to large objects.*/\n+#   ifdef ALL_INTERIOR_POINTERS\n+#\tdefine map_entry_type short\n+#       define OBJ_INVALID 0x7fff\n+#\tdefine MAP_ENTRY(map, bytes) \\\n+\t\t(((map_entry_type *)(map))[BYTES_TO_WORDS(bytes)])\n+#\tdefine MAP_ENTRIES BYTES_TO_WORDS(HBLKSIZE)\n+#\tdefine MAP_SIZE (MAP_ENTRIES * sizeof(map_entry_type))\n+#\tdefine OFFSET_VALID(displ) TRUE\n+#\tdefine CPP_MAX_OFFSET (HBLKSIZE - HDR_BYTES - 1)\n+#\tdefine MAX_OFFSET ((word)CPP_MAX_OFFSET)\n+#   else\n+#\tdefine map_entry_type char\n+#       define OBJ_INVALID 0x7f\n+#\tdefine MAP_ENTRY(map, bytes) \\\n+\t\t(map)[bytes]\n+#\tdefine MAP_ENTRIES HBLKSIZE\n+#\tdefine MAP_SIZE MAP_ENTRIES\n+#\tdefine CPP_MAX_OFFSET (WORDS_TO_BYTES(OBJ_INVALID) - 1)\t\n+#\tdefine MAX_OFFSET ((word)CPP_MAX_OFFSET)\n+# \tdefine VALID_OFFSET_SZ \\\n+\t  (CPP_MAX_OFFSET > WORDS_TO_BYTES(CPP_MAXOBJSZ)? \\\n+\t   CPP_MAX_OFFSET+1 \\\n+\t   : WORDS_TO_BYTES(CPP_MAXOBJSZ)+1)\n+  \tchar _valid_offsets[VALID_OFFSET_SZ];\n+\t\t\t\t/* GC_valid_offsets[i] == TRUE ==> i \t*/\n+\t\t\t\t/* is registered as a displacement.\t*/\n+#\tdefine OFFSET_VALID(displ) GC_valid_offsets[displ]\n+  \tchar _modws_valid_offsets[sizeof(word)];\n+\t\t\t\t/* GC_valid_offsets[i] ==>\t\t  */\n+\t\t\t\t/* GC_modws_valid_offsets[i%sizeof(word)] */\n+#   endif\n+# ifdef STUBBORN_ALLOC\n+      page_hash_table _changed_pages;\n+        /* Stubborn object pages that were changes since last call to\t*/\n+\t/* GC_read_changed.\t\t\t\t\t\t*/\n+      page_hash_table _prev_changed_pages;\n+        /* Stubborn object pages that were changes before last call to\t*/\n+\t/* GC_read_changed.\t\t\t\t\t\t*/\n+# endif\n+# if defined(PROC_VDB) || defined(MPROTECT_VDB)\n+      page_hash_table _grungy_pages; /* Pages that were dirty at last \t   */\n+\t\t\t\t     /* GC_read_dirty.\t\t\t   */\n+# endif\n+# ifdef LARGE_CONFIG\n+#   if CPP_WORDSZ > 32\n+#     define MAX_HEAP_SECTS 4096 \t/* overflows at roughly 64 GB\t   */\n+#   else\n+#     define MAX_HEAP_SECTS 768\t\t/* Separately added heap sections. */\n+#   endif\n+# else\n+#   define MAX_HEAP_SECTS 256\n+# endif\n+  struct HeapSect {\n+      ptr_t hs_start; word hs_bytes;\n+  } _heap_sects[MAX_HEAP_SECTS];\n+# ifdef MSWIN32\n+    ptr_t _heap_bases[MAX_HEAP_SECTS];\n+    \t\t/* Start address of memory regions obtained from kernel. */\n+# endif\n+  /* Block header index; see gc_headers.h */\n+  bottom_index * _all_nils;\n+  bottom_index * _top_index [TOP_SZ];\n+#ifdef SAVE_CALL_CHAIN\n+  struct callinfo _last_stack[NFRAMES];\t/* Stack at last garbage collection.*/\n+  \t\t\t\t\t/* Useful for debugging\tmysterious  */\n+  \t\t\t\t\t/* object disappearances.\t    */\n+  \t\t\t\t\t/* In the multithreaded case, we    */\n+  \t\t\t\t\t/* currently only save the calling  */\n+  \t\t\t\t\t/* stack.\t\t\t    */\n+#endif\n+};\n+\n+GC_API GC_FAR struct _GC_arrays GC_arrays; \n+\n+# define GC_objfreelist GC_arrays._objfreelist\n+# define GC_aobjfreelist GC_arrays._aobjfreelist\n+# define GC_uobjfreelist GC_arrays._uobjfreelist\n+# ifdef ATOMIC_UNCOLLECTABLE\n+#   define GC_auobjfreelist GC_arrays._auobjfreelist\n+# endif\n+# define GC_sobjfreelist GC_arrays._sobjfreelist\n+# define GC_valid_offsets GC_arrays._valid_offsets\n+# define GC_modws_valid_offsets GC_arrays._modws_valid_offsets\n+# ifdef STUBBORN_ALLOC\n+#    define GC_changed_pages GC_arrays._changed_pages\n+#    define GC_prev_changed_pages GC_arrays._prev_changed_pages\n+# endif\n+# define GC_obj_map GC_arrays._obj_map\n+# define GC_last_heap_addr GC_arrays._last_heap_addr\n+# define GC_prev_heap_addr GC_arrays._prev_heap_addr\n+# define GC_words_allocd GC_arrays._words_allocd\n+# define GC_words_wasted GC_arrays._words_wasted\n+# define GC_words_finalized GC_arrays._words_finalized\n+# define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n+# define GC_mem_freed GC_arrays._mem_freed\n+# define GC_heapsize GC_arrays._heapsize\n+# define GC_max_heapsize GC_arrays._max_heapsize\n+# define GC_words_allocd_before_gc GC_arrays._words_allocd_before_gc\n+# define GC_heap_sects GC_arrays._heap_sects\n+# define GC_last_stack GC_arrays._last_stack\n+# ifdef MSWIN32\n+#   define GC_heap_bases GC_arrays._heap_bases\n+# endif\n+# define GC_all_nils GC_arrays._all_nils\n+# define GC_top_index GC_arrays._top_index\n+# if defined(PROC_VDB) || defined(MPROTECT_VDB)\n+#   define GC_grungy_pages GC_arrays._grungy_pages\n+# endif\n+# ifdef GATHERSTATS\n+#   define GC_composite_in_use GC_arrays._composite_in_use\n+#   define GC_atomic_in_use GC_arrays._atomic_in_use\n+# endif\n+# ifdef MERGE_SIZES\n+#   define GC_size_map GC_arrays._size_map\n+# endif\n+\n+# define beginGC_arrays ((ptr_t)(&GC_arrays))\n+# define endGC_arrays (((ptr_t)(&GC_arrays)) + (sizeof GC_arrays))\n+\n+GC_API word GC_fo_entries;\n+\n+# define MAXOBJKINDS 16\n+\n+/* Object kinds: */\n+extern struct obj_kind {\n+   ptr_t *ok_freelist;\t/* Array of free listheaders for this kind of object */\n+   \t\t\t/* Point either to GC_arrays or to storage allocated */\n+   \t\t\t/* with GC_scratch_alloc.\t\t\t     */\n+   struct hblk **ok_reclaim_list;\n+   \t\t\t/* List headers for lists of blocks waiting to be */\n+   \t\t\t/* swept.\t\t\t\t\t  */\n+   word ok_descriptor;  /* Descriptor template for objects in this\t*/\n+   \t\t\t/* block.\t\t\t\t\t*/\n+   GC_bool ok_relocate_descr;\n+   \t\t\t/* Add object size in bytes to descriptor \t*/\n+   \t\t\t/* template to obtain descriptor.  Otherwise\t*/\n+   \t\t\t/* template is used as is.\t\t\t*/\n+   GC_bool ok_init;     /* Clear objects before putting them on the free list. */\n+} GC_obj_kinds[MAXOBJKINDS];\n+/* Predefined kinds: */\n+# define PTRFREE 0\n+# define NORMAL  1\n+# define UNCOLLECTABLE 2\n+# ifdef ATOMIC_UNCOLLECTABLE\n+#   define AUNCOLLECTABLE 3\n+#   define STUBBORN 4\n+#   define IS_UNCOLLECTABLE(k) (((k) & ~1) == UNCOLLECTABLE)\n+# else\n+#   define STUBBORN 3\n+#   define IS_UNCOLLECTABLE(k) ((k) == UNCOLLECTABLE)\n+# endif\n+\n+extern int GC_n_kinds;\n+\n+extern word GC_n_heap_sects;\t/* Number of separately added heap\t*/\n+\t\t\t\t/* sections.\t\t\t\t*/\n+\n+extern word GC_page_size;\n+\n+# ifdef MSWIN32\n+extern word GC_n_heap_bases;\t/* See GC_heap_bases.\t*/\n+# endif\n+\n+extern word GC_total_stack_black_listed;\n+\t\t\t/* Number of bytes on stack blacklist. \t*/\n+\n+extern word GC_black_list_spacing;\n+\t\t\t/* Average number of bytes between blacklisted\t*/\n+\t\t\t/* blocks. Approximate.\t\t\t\t*/\n+\t\t\t/* Counts only blocks that are \t\t\t*/\n+\t\t\t/* \"stack-blacklisted\", i.e. that are \t\t*/\n+\t\t\t/* problematic in the interior of an object.\t*/\n+\n+extern char * GC_invalid_map;\n+\t\t\t/* Pointer to the nowhere valid hblk map */\n+\t\t\t/* Blocks pointing to this map are free. */\n+\n+extern struct hblk * GC_hblkfreelist;\n+\t\t\t\t/* List of completely empty heap blocks\t*/\n+\t\t\t\t/* Linked through hb_next field of \t*/\n+\t\t\t\t/* header structure associated with\t*/\n+\t\t\t\t/* block.\t\t\t\t*/\n+\n+extern GC_bool GC_is_initialized;\t/* GC_init() has been run.\t*/\n+\n+extern GC_bool GC_objects_are_marked;\t/* There are marked objects in  */\n+\t\t\t\t\t/* the heap.\t\t\t*/\n+\n+extern GC_bool GC_incremental; /* Using incremental/generational collection. */\n+\n+extern GC_bool GC_dirty_maintained;\n+\t\t\t\t/* Dirty bits are being maintained, \t*/\n+\t\t\t\t/* either for incremental collection,\t*/\n+\t\t\t\t/* or to limit the root set.\t\t*/\n+\n+# ifndef PCR\n+    extern ptr_t GC_stackbottom;\t/* Cool end of user stack\t*/\n+# endif\n+\n+extern word GC_root_size;\t/* Total size of registered root sections */\n+\n+extern GC_bool GC_debugging_started;\t/* GC_debug_malloc has been called. */ \n+\n+extern ptr_t GC_least_plausible_heap_addr;\n+extern ptr_t GC_greatest_plausible_heap_addr;\n+\t\t\t/* Bounds on the heap.  Guaranteed valid\t*/\n+\t\t\t/* Likely to include future heap expansion.\t*/\n+\t\t\t\n+/* Operations */\n+# ifndef abs\n+#   define abs(x)  ((x) < 0? (-(x)) : (x))\n+# endif\n+\n+\n+/*  Marks are in a reserved area in                          */\n+/*  each heap block.  Each word has one mark bit associated  */\n+/*  with it. Only those corresponding to the beginning of an */\n+/*  object are used.                                         */\n+\n+\n+/* Mark bit operations */\n+\n+/*\n+ * Retrieve, set, clear the mark bit corresponding\n+ * to the nth word in a given heap block.\n+ *\n+ * (Recall that bit n corresponds to object beginning at word n\n+ * relative to the beginning of the block, including unused words)\n+ */\n+\n+# define mark_bit_from_hdr(hhdr,n) (((hhdr)->hb_marks[divWORDSZ(n)] \\\n+\t\t\t    >> (modWORDSZ(n))) & (word)1)\n+# define set_mark_bit_from_hdr(hhdr,n) (hhdr)->hb_marks[divWORDSZ(n)] \\\n+\t\t\t\t|= (word)1 << modWORDSZ(n)\n+\n+# define clear_mark_bit_from_hdr(hhdr,n) (hhdr)->hb_marks[divWORDSZ(n)] \\\n+\t\t\t\t&= ~((word)1 << modWORDSZ(n))\n+\n+/* Important internal collector routines */\n+\n+ptr_t GC_approx_sp();\n+\n+GC_bool GC_should_collect();\n+#ifdef PRESERVE_LAST\n+    GC_bool GC_in_last_heap_sect(/* ptr_t */);\n+\t/* In last added heap section?  If so, avoid breaking up.\t*/\n+#endif\n+void GC_apply_to_all_blocks(/*fn, client_data*/);\n+\t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n+\t\t\t/* allocated heap block.\t\t\t*/\n+struct hblk * GC_next_block(/* struct hblk * h */);\n+void GC_mark_init();\n+void GC_clear_marks();\t/* Clear mark bits for all heap objects. */\n+void GC_invalidate_mark_state();\t/* Tell the marker that\tmarked \t   */\n+\t\t\t\t\t/* objects may point to\tunmarked   */\n+\t\t\t\t\t/* ones, and roots may point to\t   */\n+\t\t\t\t\t/* unmarked objects.\t\t   */\n+\t\t\t\t\t/* Reset mark stack.\t\t   */\n+void GC_mark_from_mark_stack(); /* Mark from everything on the mark stack. */\n+\t\t\t\t/* Return after about one pages worth of   */\n+\t\t\t\t/* work.\t\t\t\t   */\n+GC_bool GC_mark_stack_empty();\n+GC_bool GC_mark_some();\t/* Perform about one pages worth of marking\t*/\n+\t\t\t/* work of whatever kind is needed.  Returns\t*/\n+\t\t\t/* quickly if no collection is in progress.\t*/\n+\t\t\t/* Return TRUE if mark phase finished.\t\t*/\n+void GC_initiate_gc();\t\t/* initiate collection.\t\t\t*/\n+\t\t\t\t/* If the mark state is invalid, this\t*/\n+\t\t\t\t/* becomes full colleection.  Otherwise */\n+\t\t\t\t/* it's partial.\t\t\t*/\n+void GC_push_all(/*b,t*/);\t/* Push everything in a range \t\t*/\n+\t\t\t\t/* onto mark stack.\t\t\t*/\n+void GC_push_dirty(/*b,t*/);      /* Push all possibly changed\t \t*/\n+\t\t\t\t  /* subintervals of [b,t) onto\t\t*/\n+\t\t\t\t  /* mark stack.\t\t\t*/\n+#ifndef SMALL_CONFIG\n+  void GC_push_conditional(/* ptr_t b, ptr_t t, GC_bool all*/);\n+#else\n+# define GC_push_conditional(b, t, all) GC_push_all(b, t)\n+#endif\n+                                /* Do either of the above, depending\t*/\n+\t\t\t\t/* on the third arg.\t\t\t*/\n+void GC_push_all_stack(/*b,t*/);    /* As above, but consider\t\t*/\n+\t\t\t\t    /*  interior pointers as valid  \t*/\n+void GC_push_roots(/* GC_bool all */); /* Push all or dirty roots.\t*/\n+extern void (*GC_push_other_roots)();\n+\t\t\t/* Push system or application specific roots\t*/\n+\t\t\t/* onto the mark stack.  In some environments\t*/\n+\t\t\t/* (e.g. threads environments) this is\t\t*/\n+\t\t\t/* predfined to be non-zero.  A client supplied */\n+\t\t\t/* replacement should also call the original\t*/\n+\t\t\t/* function.\t\t\t\t\t*/\n+extern void (*GC_start_call_back)(/* void */);\n+\t\t\t/* Called at start of full collections.\t\t*/\n+\t\t\t/* Not called if 0.  Called with allocation \t*/\n+\t\t\t/* lock held.\t\t\t\t\t*/\n+\t\t\t/* 0 by default.\t\t\t\t*/\n+void GC_push_regs();\t/* Push register contents onto mark stack.\t*/\n+void GC_remark();\t/* Mark from all marked objects.  Used\t*/\n+\t\t \t/* only if we had to drop something.\t*/\n+# if defined(MSWIN32)\n+  void __cdecl GC_push_one();\n+# else\n+  void GC_push_one(/*p*/);    /* If p points to an object, mark it    */\n+                              /* and push contents on the mark stack  */\n+# endif\n+void GC_push_one_checked(/*p*/); /* Ditto, omits plausibility test\t*/\n+void GC_push_marked(/* struct hblk h, hdr * hhdr */);\n+\t\t/* Push contents of all marked objects in h onto\t*/\n+\t\t/* mark stack.\t\t\t\t\t\t*/\n+#ifdef SMALL_CONFIG\n+# define GC_push_next_marked_dirty(h) GC_push_next_marked(h)\n+#else\n+  struct hblk * GC_push_next_marked_dirty(/* h */);\n+\t\t/* Invoke GC_push_marked on next dirty block above h.\t*/\n+\t\t/* Return a pointer just past the end of this block.\t*/\n+#endif /* !SMALL_CONFIG */\n+struct hblk * GC_push_next_marked(/* h */);\n+\t\t/* Ditto, but also mark from clean pages.\t*/\n+struct hblk * GC_push_next_marked_uncollectable(/* h */);\n+\t\t/* Ditto, but mark only from uncollectable pages.\t*/\n+GC_bool GC_stopped_mark(); /* Stop world and mark from all roots\t*/\n+\t\t\t/* and rescuers.\t\t\t*/\n+void GC_clear_hdr_marks(/* hhdr */);  /* Clear the mark bits in a header */\n+void GC_set_hdr_marks(/* hhdr */);  /* Set the mark bits in a header */\n+void GC_add_roots_inner();\n+GC_bool GC_is_static_root(/* ptr_t p */);\n+\t\t/* Is the address p in one of the registered static\t*/\n+\t\t/* root sections?\t\t\t\t\t*/\n+void GC_register_dynamic_libraries();\n+\t\t/* Add dynamic library data sections to the root set. */\n+\n+/* Machine dependent startup routines */\n+ptr_t GC_get_stack_base();\n+void GC_register_data_segments();\n+\n+/* Black listing: */\n+void GC_bl_init(); \t\n+# ifndef ALL_INTERIOR_POINTERS\n+    void GC_add_to_black_list_normal(/* bits, maybe source */);\n+\t\t\t/* Register bits as a possible future false\t*/\n+\t\t\t/* reference from the heap or static data\t*/\n+#   ifdef PRINT_BLACK_LIST\n+#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n+\t\t\tGC_add_to_black_list_normal(bits, source)\n+#   else\n+#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n+\t\t\tGC_add_to_black_list_normal(bits)\n+#   endif\n+# else\n+#   ifdef PRINT_BLACK_LIST\n+#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n+\t\t\tGC_add_to_black_list_stack(bits, source)\n+#   else\n+#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n+\t\t\tGC_add_to_black_list_stack(bits)\n+#   endif\n+# endif\n+\n+void GC_add_to_black_list_stack(/* bits, maybe source */);\n+struct hblk * GC_is_black_listed(/* h, len */);\n+\t\t\t/* If there are likely to be false references\t*/\n+\t\t\t/* to a block starting at h of the indicated    */\n+\t\t\t/* length, then return the next plausible\t*/\n+\t\t\t/* starting location for h that might avoid\t*/\n+\t\t\t/* these false references.\t\t\t*/\n+void GC_promote_black_lists();\n+\t\t\t/* Declare an end to a black listing phase.\t*/\n+void GC_unpromote_black_lists();\n+\t\t\t/* Approximately undo the effect of the above.\t*/\n+\t\t\t/* This actually loses some information, but\t*/\n+\t\t\t/* only in a reasonably safe way.\t\t*/\n+word GC_number_stack_black_listed(/*struct hblk *start, struct hblk *endp1 */);\n+\t\t\t/* Return the number of (stack) blacklisted\t*/\n+\t\t\t/* blocks in the range for statistical\t\t*/\n+\t\t\t/* purposes.\t\t\t\t\t*/\n+\t\t \t\n+ptr_t GC_scratch_alloc(/*bytes*/);\n+\t\t\t\t/* GC internal memory allocation for\t*/\n+\t\t\t\t/* small objects.  Deallocation is not  */\n+\t\t\t\t/* possible.\t\t\t\t*/\n+\t\n+/* Heap block layout maps: */\t\t\t\n+void GC_invalidate_map(/* hdr */);\n+\t\t\t\t/* Remove the object map associated\t*/\n+\t\t\t\t/* with the block.  This identifies\t*/\n+\t\t\t\t/* the block as invalid to the mark\t*/\n+\t\t\t\t/* routines.\t\t\t\t*/\n+GC_bool GC_add_map_entry(/*sz*/);\n+\t\t\t\t/* Add a heap block map for objects of\t*/\n+\t\t\t\t/* size sz to obj_map.\t\t\t*/\n+\t\t\t\t/* Return FALSE on failure.\t\t*/\n+void GC_register_displacement_inner(/*offset*/);\n+\t\t\t\t/* Version of GC_register_displacement\t*/\n+\t\t\t\t/* that assumes lock is already held\t*/\n+\t\t\t\t/* and signals are already disabled.\t*/\n+\n+/*  hblk allocation: */\t\t\n+void GC_new_hblk(/*size_in_words, kind*/);\n+\t\t\t\t/* Allocate a new heap block, and build */\n+\t\t\t\t/* a free list in it.\t\t\t*/\t\t\t\t\n+struct hblk * GC_allochblk(/*size_in_words, kind*/);\n+\t\t\t\t/* Allocate a heap block, clear it if\t*/\n+\t\t\t\t/* for composite objects, inform\t*/\n+\t\t\t\t/* the marker that block is valid\t*/\n+\t\t\t\t/* for objects of indicated size.\t*/\n+\t\t\t\t/* sz < 0 ==> atomic.\t\t\t*/ \n+void GC_freehblk();\t\t/* Deallocate a heap block and mark it  */\n+\t\t\t\t/* as invalid.\t\t\t\t*/\n+\t\t\t\t\n+/*  Misc GC: */\n+void GC_init_inner();\n+GC_bool GC_expand_hp_inner();\n+void GC_start_reclaim(/*abort_if_found*/);\n+\t\t\t\t/* Restore unmarked objects to free\t*/\n+\t\t\t\t/* lists, or (if abort_if_found is\t*/\n+\t\t\t\t/* TRUE) report them.\t\t\t*/\n+\t\t\t\t/* Sweeping of small object pages is\t*/\n+\t\t\t\t/* largely deferred.\t\t\t*/\n+void GC_continue_reclaim(/*size, kind*/);\n+\t\t\t\t/* Sweep pages of the given size and\t*/\n+\t\t\t\t/* kind, as long as possible, and\t*/\n+\t\t\t\t/* as long as the corr. free list is    */\n+\t\t\t\t/* empty.\t\t\t\t*/\n+void GC_reclaim_or_delete_all();\n+\t\t\t\t/* Arrange for all reclaim lists to be\t*/\n+\t\t\t\t/* empty.  Judiciously choose between\t*/\n+\t\t\t\t/* sweeping and discarding each page.\t*/\n+GC_bool GC_reclaim_all(/* GC_stop_func f*/);\n+\t\t\t\t/* Reclaim all blocks.  Abort (in a\t*/\n+\t\t\t\t/* consistent state) if f returns TRUE. */\n+GC_bool GC_block_empty(/* hhdr */); /* Block completely unmarked? \t*/\n+GC_bool GC_never_stop_func();\t/* Returns FALSE.\t\t*/\n+GC_bool GC_try_to_collect_inner(/* GC_stop_func f */);\n+\t\t\t\t/* Collect; caller must have acquired\t*/\n+\t\t\t\t/* lock and disabled signals.\t\t*/\n+\t\t\t\t/* Collection is aborted if f returns\t*/\n+\t\t\t\t/* TRUE.  Returns TRUE if it completes\t*/\n+\t\t\t\t/* successfully.\t\t\t*/\n+# define GC_gcollect_inner() \\\n+\t(void) GC_try_to_collect_inner(GC_never_stop_func)\n+void GC_finish_collection();\t/* Finish collection.  Mark bits are\t*/\n+\t\t\t\t/* consistent and lock is still held.\t*/\n+GC_bool GC_collect_or_expand(/* needed_blocks */);\n+\t\t\t\t/* Collect or expand heap in an attempt */\n+\t\t\t\t/* make the indicated number of free\t*/\n+\t\t\t\t/* blocks available.  Should be called\t*/\n+\t\t\t\t/* until the blocks are available or\t*/\n+\t\t\t\t/* until it fails by returning FALSE.\t*/\n+void GC_init();\t\t\t/* Initialize collector.\t\t*/\n+void GC_collect_a_little_inner(/* int n */);\n+\t\t\t\t/* Do n units worth of garbage \t\t*/\n+\t\t\t\t/* collection work, if appropriate.\t*/\n+\t\t\t\t/* A unit is an amount appropriate for  */\n+\t\t\t\t/* HBLKSIZE bytes of allocation.\t*/\n+ptr_t GC_generic_malloc(/* bytes, kind */);\n+\t\t\t\t/* Allocate an object of the given\t*/\n+\t\t\t\t/* kind.  By default, there are only\t*/\n+\t\t\t\t/* a few kinds: composite(pointerfree), */\n+\t\t\t\t/* atomic, uncollectable, etc.\t\t*/\n+\t\t\t\t/* We claim it's possible for clever\t*/\n+\t\t\t\t/* client code that understands GC\t*/\n+\t\t\t\t/* internals to add more, e.g. to\t*/\n+\t\t\t\t/* communicate object layout info\t*/\n+\t\t\t\t/* to the collector.\t\t\t*/\n+ptr_t GC_generic_malloc_ignore_off_page(/* bytes, kind */);\n+\t\t\t\t/* As above, but pointers past the \t*/\n+\t\t\t\t/* first page of the resulting object\t*/\n+\t\t\t\t/* are ignored.\t\t\t\t*/\n+ptr_t GC_generic_malloc_inner(/* bytes, kind */);\n+\t\t\t\t/* Ditto, but I already hold lock, etc.\t*/\n+ptr_t GC_generic_malloc_words_small GC_PROTO((size_t words, int kind));\n+\t\t\t\t/* As above, but size in units of words */\n+\t\t\t\t/* Bypasses MERGE_SIZES.  Assumes\t*/\n+\t\t\t\t/* words <= MAXOBJSZ.\t\t\t*/\n+ptr_t GC_generic_malloc_inner_ignore_off_page(/* bytes, kind */);\n+\t\t\t\t/* Allocate an object, where\t\t*/\n+\t\t\t\t/* the client guarantees that there\t*/\n+\t\t\t\t/* will always be a pointer to the \t*/\n+\t\t\t\t/* beginning of the object while the\t*/\n+\t\t\t\t/* object is live.\t\t\t*/\n+ptr_t GC_allocobj(/* sz_inn_words, kind */);\n+\t\t\t\t/* Make the indicated \t\t\t*/\n+\t\t\t\t/* free list nonempty, and return its\t*/\n+\t\t\t\t/* head.\t\t\t\t*/\n+\n+void GC_init_headers();\n+GC_bool GC_install_header(/*h*/);\n+\t\t\t\t/* Install a header for block h.\t*/\n+\t\t\t\t/* Return FALSE on failure.\t\t*/\n+GC_bool GC_install_counts(/*h, sz*/);\n+\t\t\t\t/* Set up forwarding counts for block\t*/\n+\t\t\t\t/* h of size sz.\t\t\t*/\n+\t\t\t\t/* Return FALSE on failure.\t\t*/\n+void GC_remove_header(/*h*/);\n+\t\t\t\t/* Remove the header for block h.\t*/\n+void GC_remove_counts(/*h, sz*/);\n+\t\t\t\t/* Remove forwarding counts for h.\t*/\n+hdr * GC_find_header(/*p*/);\t/* Debugging only.\t\t\t*/\n+\n+void GC_finalize();\t/* Perform all indicated finalization actions\t*/\n+\t\t\t/* on unmarked objects.\t\t\t\t*/\n+\t\t\t/* Unreachable finalizable objects are enqueued\t*/\n+\t\t\t/* for processing by GC_invoke_finalizers.\t*/\n+\t\t\t/* Invoked with lock.\t\t\t\t*/\n+\t\t\t\n+void GC_add_to_heap(/*p, bytes*/);\n+\t\t\t/* Add a HBLKSIZE aligned chunk to the heap.\t*/\n+\n+void GC_print_obj(/* ptr_t p */);\n+\t\t\t/* P points to somewhere inside an object with\t*/\n+\t\t\t/* debugging info.  Print a human readable\t*/\n+\t\t\t/* description of the object to stderr.\t\t*/\n+extern void (*GC_check_heap)();\n+\t\t\t/* Check that all objects in the heap with \t*/\n+\t\t\t/* debugging info are intact.  Print \t\t*/\n+\t\t\t/* descriptions of any that are not.\t\t*/\n+extern void (*GC_print_heap_obj)(/* ptr_t p */);\n+\t\t\t/* If possible print s followed by a more\t*/\n+\t\t\t/* detailed description of the object \t\t*/\n+\t\t\t/* referred to by p.\t\t\t\t*/\n+\t\t\t\n+/* Virtual dirty bit implementation:\t\t*/\n+/* Each implementation exports the following:\t*/\n+void GC_read_dirty();\t/* Retrieve dirty bits.\t*/\n+GC_bool GC_page_was_dirty(/* struct hblk * h  */);\n+\t\t\t/* Read retrieved dirty bits.\t*/\n+GC_bool GC_page_was_ever_dirty(/* struct hblk * h  */);\n+\t\t\t/* Could the page contain valid heap pointers?\t*/\n+void GC_is_fresh(/* struct hblk * h, word number_of_blocks  */);\n+\t\t\t/* Assert the region currently contains no\t*/\n+\t\t\t/* valid pointers.\t\t\t\t*/\n+void GC_write_hint(/* struct hblk * h  */);\n+\t\t\t/* h is about to be written.\t*/\n+void GC_dirty_init();\n+\n+/* Slow/general mark bit manipulation: */\n+GC_bool GC_is_marked();\n+void GC_clear_mark_bit();\n+void GC_set_mark_bit();\n+\n+/* Stubborn objects: */\n+void GC_read_changed();\t/* Analogous to GC_read_dirty */\n+GC_bool GC_page_was_changed(/* h */);\t/* Analogous to GC_page_was_dirty */\n+void GC_clean_changing_list();\t/* Collect obsolete changing list entries */\n+void GC_stubborn_init();\n+\n+/* Debugging print routines: */\n+void GC_print_block_list();\n+void GC_print_hblkfreelist();\n+void GC_print_heap_sects();\n+void GC_print_static_roots();\n+void GC_dump();\n+\n+/* Make arguments appear live to compiler */\n+# ifdef __WATCOMC__\n+  void GC_noop(void*, ...);\n+# else\n+  GC_API void GC_noop();\n+# endif\n+\n+void GC_noop1(/* word arg */);\n+\n+/* Logging and diagnostic output: \t*/\n+GC_API void GC_printf GC_PROTO((char * format, long, long, long, long, long, long));\n+\t\t\t/* A version of printf that doesn't allocate,\t*/\n+\t\t\t/* is restricted to long arguments, and\t\t*/\n+\t\t\t/* (unfortunately) doesn't use varargs for\t*/\n+\t\t\t/* portability.  Restricted to 6 args and\t*/\n+\t\t\t/* 1K total output length.\t\t\t*/\n+\t\t\t/* (We use sprintf.  Hopefully that doesn't\t*/\n+\t\t\t/* allocate for long arguments.)  \t\t*/\n+# define GC_printf0(f) GC_printf(f, 0l, 0l, 0l, 0l, 0l, 0l)\n+# define GC_printf1(f,a) GC_printf(f, (long)a, 0l, 0l, 0l, 0l, 0l)\n+# define GC_printf2(f,a,b) GC_printf(f, (long)a, (long)b, 0l, 0l, 0l, 0l)\n+# define GC_printf3(f,a,b,c) GC_printf(f, (long)a, (long)b, (long)c, 0l, 0l, 0l)\n+# define GC_printf4(f,a,b,c,d) GC_printf(f, (long)a, (long)b, (long)c, \\\n+\t\t\t\t\t    (long)d, 0l, 0l)\n+# define GC_printf5(f,a,b,c,d,e) GC_printf(f, (long)a, (long)b, (long)c, \\\n+\t\t\t\t\t      (long)d, (long)e, 0l)\n+# define GC_printf6(f,a,b,c,d,e,g) GC_printf(f, (long)a, (long)b, (long)c, \\\n+\t\t\t\t\t\t(long)d, (long)e, (long)g)\n+\n+void GC_err_printf(/* format, a, b, c, d, e, f */);\n+# define GC_err_printf0(f) GC_err_puts(f)\n+# define GC_err_printf1(f,a) GC_err_printf(f, (long)a, 0l, 0l, 0l, 0l, 0l)\n+# define GC_err_printf2(f,a,b) GC_err_printf(f, (long)a, (long)b, 0l, 0l, 0l, 0l)\n+# define GC_err_printf3(f,a,b,c) GC_err_printf(f, (long)a, (long)b, (long)c, \\\n+\t\t\t\t\t\t  0l, 0l, 0l)\n+# define GC_err_printf4(f,a,b,c,d) GC_err_printf(f, (long)a, (long)b, \\\n+\t\t\t\t\t\t    (long)c, (long)d, 0l, 0l)\n+# define GC_err_printf5(f,a,b,c,d,e) GC_err_printf(f, (long)a, (long)b, \\\n+\t\t\t\t\t\t      (long)c, (long)d, \\\n+\t\t\t\t\t\t      (long)e, 0l)\n+# define GC_err_printf6(f,a,b,c,d,e,g) GC_err_printf(f, (long)a, (long)b, \\\n+\t\t\t\t\t\t\t(long)c, (long)d, \\\n+\t\t\t\t\t\t\t(long)e, (long)g)\n+\t\t\t/* Ditto, writes to stderr.\t\t\t*/\n+\t\t\t\n+void GC_err_puts(/* char *s */);\n+\t\t\t/* Write s to stderr, don't buffer, don't add\t*/\n+\t\t\t/* newlines, don't ...\t\t\t\t*/\n+\n+\n+# endif /* GC_PRIVATE_H */"}, {"sha": "84906b00a68489f158f12c9e86dba9eb0d73a2a9", "filename": "boehm-gc/include/weakpointer.h", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fweakpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Finclude%2Fweakpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fweakpointer.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8", "patch": "@@ -0,0 +1,221 @@\n+#ifndef\t_weakpointer_h_\n+#define\t_weakpointer_h_\n+\n+/****************************************************************************\n+\n+WeakPointer and CleanUp\n+\n+    Copyright (c) 1991 by Xerox Corporation.  All rights reserved.\n+\n+    THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+    OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+\n+    Permission is hereby granted to copy this code for any purpose,\n+    provided the above notices are retained on all copies.\n+\n+    Last modified on Mon Jul 17 18:16:01 PDT 1995 by ellis\n+\n+****************************************************************************/\n+\n+/****************************************************************************\n+\n+WeakPointer\n+\n+A weak pointer is a pointer to a heap-allocated object that doesn't\n+prevent the object from being garbage collected. Weak pointers can be\n+used to track which objects haven't yet been reclaimed by the\n+collector. A weak pointer is deactivated when the collector discovers\n+its referent object is unreachable by normal pointers (reachability\n+and deactivation are defined more precisely below). A deactivated weak\n+pointer remains deactivated forever.\n+\n+****************************************************************************/\n+\n+\n+template< class T > class WeakPointer {\n+public:\n+\n+WeakPointer( T* t = 0 )\n+    /* Constructs a weak pointer for *t. t may be null. It is an error\n+       if t is non-null and *t is not a collected object. */\n+    {impl = _WeakPointer_New( t );}\n+\n+T* Pointer()\n+    /* wp.Pointer() returns a pointer to the referent object of wp or\n+       null if wp has been deactivated (because its referent object\n+       has been discovered unreachable by the collector). */\n+    {return (T*) _WeakPointer_Pointer( this->impl );}\n+\n+int operator==( WeakPointer< T > wp2 )\n+    /* Given weak pointers wp1 and wp2, if wp1 == wp2, then wp1 and\n+       wp2 refer to the same object. If wp1 != wp2, then either wp1\n+       and wp2 don't refer to the same object, or if they do, one or\n+       both of them has been deactivated. (Note: If objects t1 and t2\n+       are never made reachable by their clean-up functions, then\n+       WeakPointer<T>(t1) == WeakPointer<T>(t2) if and only t1 == t2.) */\n+    {return _WeakPointer_Equal( this->impl, wp2.impl );}\n+\n+int Hash()\n+    /* Returns a hash code suitable for use by multiplicative- and\n+       division-based hash tables. If wp1 == wp2, then wp1.Hash() ==\n+       wp2.Hash(). */\n+    {return _WeakPointer_Hash( this->impl );}\n+\n+private:\n+void* impl;\n+};\n+\n+/*****************************************************************************\n+\n+CleanUp\n+\n+A garbage-collected object can have an associated clean-up function\n+that will be invoked some time after the collector discovers the\n+object is unreachable via normal pointers. Clean-up functions can be\n+used to release resources such as open-file handles or window handles\n+when their containing objects become unreachable.  If a C++ object has\n+a non-empty explicit destructor (i.e. it contains programmer-written\n+code), the destructor will be automatically registered as the object's\n+initial clean-up function.\n+\n+There is no guarantee that the collector will detect every unreachable\n+object (though it will find almost all of them). Clients should not\n+rely on clean-up to cause some action to occur immediately -- clean-up\n+is only a mechanism for improving resource usage.\n+\n+Every object with a clean-up function also has a clean-up queue. When\n+the collector finds the object is unreachable, it enqueues it on its\n+queue. The clean-up function is applied when the object is removed\n+from the queue. By default, objects are enqueued on the garbage\n+collector's queue, and the collector removes all objects from its\n+queue after each collection. If a client supplies another queue for\n+objects, it is his responsibility to remove objects (and cause their\n+functions to be called) by polling it periodically.\n+\n+Clean-up queues allow clean-up functions accessing global data to\n+synchronize with the main program. Garbage collection can occur at any\n+time, and clean-ups invoked by the collector might access data in an\n+inconsistent state. A client can control this by defining an explicit\n+queue for objects and polling it at safe points.\n+\n+The following definitions are used by the specification below:\n+\n+Given a pointer t to a collected object, the base object BO(t) is the\n+value returned by new when it created the object. (Because of multiple\n+inheritance, t and BO(t) may not be the same address.)\n+\n+A weak pointer wp references an object *t if BO(wp.Pointer()) ==\n+BO(t).\n+\n+***************************************************************************/\n+\n+template< class T, class Data > class CleanUp {\n+public:\n+\n+static void Set( T* t, void c( Data* d, T* t ), Data* d = 0 )\n+    /* Sets the clean-up function of object BO(t) to be <c, d>,\n+       replacing any previously defined clean-up function for BO(t); c\n+       and d can be null, but t cannot. Sets the clean-up queue for\n+       BO(t) to be the collector's queue. When t is removed from its\n+       clean-up queue, its clean-up will be applied by calling c(d,\n+       t). It is an error if *t is not a collected object. */ \n+       {_CleanUp_Set( t, c, d );}\n+\n+static void Call( T* t )\n+    /* Sets the new clean-up function for BO(t) to be null and, if the\n+       old one is non-null, calls it immediately, even if BO(t) is\n+       still reachable. Deactivates any weak pointers to BO(t). */\n+       {_CleanUp_Call( t );}\n+\n+class Queue {public:\n+    Queue()\n+        /* Constructs a new queue. */\n+            {this->head = _CleanUp_Queue_NewHead();}\n+\n+    void Set( T* t )\n+        /* q.Set(t) sets the clean-up queue of BO(t) to be q. */\n+            {_CleanUp_Queue_Set( this->head, t );}\n+\n+    int Call()\n+        /* If q is non-empty, q.Call() removes the first object and\n+           calls its clean-up function; does nothing if q is\n+           empty. Returns true if there are more objects in the\n+           queue. */\n+           {return _CleanUp_Queue_Call( this->head );}\n+\n+    private:\n+    void* head;\n+    };\n+};\n+\n+/**********************************************************************\n+\n+Reachability and Clean-up\n+\n+An object O is reachable if it can be reached via a non-empty path of\n+normal pointers from the registers, stacks, global variables, or an\n+object with a non-null clean-up function (including O itself),\n+ignoring pointers from an object to itself.\n+\n+This definition of reachability ensures that if object B is accessible\n+from object A (and not vice versa) and if both A and B have clean-up\n+functions, then A will always be cleaned up before B. Note that as\n+long as an object with a clean-up function is contained in a cycle of\n+pointers, it will always be reachable and will never be cleaned up or\n+collected.\n+\n+When the collector finds an unreachable object with a null clean-up\n+function, it atomically deactivates all weak pointers referencing the\n+object and recycles its storage. If object B is accessible from object\n+A via a path of normal pointers, A will be discovered unreachable no\n+later than B, and a weak pointer to A will be deactivated no later\n+than a weak pointer to B.\n+\n+When the collector finds an unreachable object with a non-null\n+clean-up function, the collector atomically deactivates all weak\n+pointers referencing the object, redefines its clean-up function to be\n+null, and enqueues it on its clean-up queue. The object then becomes\n+reachable again and remains reachable at least until its clean-up\n+function executes.\n+\n+The clean-up function is assured that its argument is the only\n+accessible pointer to the object. Nothing prevents the function from\n+redefining the object's clean-up function or making the object\n+reachable again (for example, by storing the pointer in a global\n+variable).\n+\n+If the clean-up function does not make its object reachable again and\n+does not redefine its clean-up function, then the object will be\n+collected by a subsequent collection (because the object remains\n+unreachable and now has a null clean-up function). If the clean-up\n+function does make its object reachable again and a clean-up function\n+is subsequently redefined for the object, then the new clean-up\n+function will be invoked the next time the collector finds the object\n+unreachable.\n+\n+Note that a destructor for a collected object cannot safely redefine a\n+clean-up function for its object, since after the destructor executes,\n+the object has been destroyed into \"raw memory\". (In most\n+implementations, destroying an object mutates its vtbl.)\n+\n+Finally, note that calling delete t on a collected object first\n+deactivates any weak pointers to t and then invokes its clean-up\n+function (destructor).\n+\n+**********************************************************************/\n+\n+extern \"C\" {\n+    void* _WeakPointer_New( void* t );\n+    void* _WeakPointer_Pointer( void* wp );\n+    int _WeakPointer_Equal( void* wp1, void* wp2 );\n+    int _WeakPointer_Hash( void* wp );\n+    void _CleanUp_Set( void* t, void (*c)( void* d, void* t ), void* d );\n+    void _CleanUp_Call( void* t );\n+    void* _CleanUp_Queue_NewHead ();\n+    void _CleanUp_Queue_Set( void* h, void* t );\n+    int _CleanUp_Queue_Call( void* h );\n+}\n+\n+#endif /* _weakpointer_h_ */\n+\n+"}, {"sha": "f45c4631c6e0bd007e2f8c2976e8ab71ec4835cf", "filename": "boehm-gc/irix_threads.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "12e71cea1fe36d5f2b4e3f29929b6714db487706", "filename": "boehm-gc/linux_threads.c", "status": "added", "additions": 642, "deletions": 0, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "e6087d94684458263aa8dc7bbf48d3b78bde8d97", "filename": "boehm-gc/mach_dep.c", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "boehm-gc/makefile.depend", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmakefile.depend", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmakefile.depend", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmakefile.depend?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "41553b7f376c91750a1a28f6e2b2e02045d4f2c2", "filename": "boehm-gc/malloc.c", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "ae8bfffb8afd416e6f241ba4bee29f0bd1356e1e", "filename": "boehm-gc/mallocx.c", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "efe6b64058f61d65fcb14377b9d740ef03202b2a", "filename": "boehm-gc/mark_rts.c", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "03c4b98060cc36b0c1e136f0ddfe161140efaa68", "filename": "boehm-gc/mips_sgi_mach_dep.s", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmips_sgi_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmips_sgi_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmips_sgi_mach_dep.s?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "178224e31c8d6b6ad96d42a01e5373380222c5ec", "filename": "boehm-gc/mips_ultrix_mach_dep.s", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmips_ultrix_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fmips_ultrix_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmips_ultrix_mach_dep.s?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "9f32ae0dcb4cae5b555e758f2062771c6f50d48e", "filename": "boehm-gc/new_hblk.c", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fnew_hblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fnew_hblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnew_hblk.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "82ebf311983c07307c76fdf866a0c57730dbbfb1", "filename": "boehm-gc/obj_map.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fobj_map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fobj_map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fobj_map.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "52da43110cf425e48c17e6bf4175c30de0e23fd6", "filename": "boehm-gc/pc_excludes", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fpc_excludes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fpc_excludes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpc_excludes?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "4c950933704dde7e6a642c8796b86484be5e5a1d", "filename": "boehm-gc/pcr_interface.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fpcr_interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fpcr_interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpcr_interface.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "f3451ee6f8c41969e9ebfd7c001037164a12b595", "filename": "boehm-gc/ptr_chck.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fptr_chck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fptr_chck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fptr_chck.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "dece9fdc09cd419f4f99868d011bc67934ef7591", "filename": "boehm-gc/real_malloc.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Freal_malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Freal_malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freal_malloc.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "407b4c68194dc0b287f81a55e5ea88e0ae8b2162", "filename": "boehm-gc/reclaim.c", "status": "added", "additions": 723, "deletions": 0, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "e0dbe808596b1952a0c9ff114b7d70179abe5d53", "filename": "boehm-gc/rs6000_mach_dep.s", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Frs6000_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Frs6000_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Frs6000_mach_dep.s?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "9ed92138b6c1b5c19a3656f901b80f2daaebf0a4", "filename": "boehm-gc/setjmp_t.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsetjmp_t.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsetjmp_t.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsetjmp_t.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "1f5ebcdc39017ac8fda419480fbe7647e66cdc03", "filename": "boehm-gc/solaris_threads.c", "status": "added", "additions": 925, "deletions": 0, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "b2cdb36e98d9734447c77b3c41c5f4352362552a", "filename": "boehm-gc/solaris_threads.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsolaris_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsolaris_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "a6a0a2410800aa71e0847182391302594af64057", "filename": "boehm-gc/sparc_mach_dep.s", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsparc_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsparc_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_mach_dep.s?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "7accadd3dfb33dc114e5eb8802710f17fcd5b702", "filename": "boehm-gc/sparc_sunos4_mach_dep.s", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsparc_sunos4_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fsparc_sunos4_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_sunos4_mach_dep.s?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "bef7b98a48685950a0e6f97e9c87ff0f568805c3", "filename": "boehm-gc/stubborn.c", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fstubborn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fstubborn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fstubborn.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "2fc51e12ed77842e708cc71a3df2f72d559825bf", "filename": "boehm-gc/test.c", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftest.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "3160b0984bb340b923f7108580907c0ae99c8c87", "filename": "boehm-gc/test_cpp.cc", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ftest_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ftest_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftest_cpp.cc?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "c8530e6fe331bfad3d37eb06b1eda31649077fe8", "filename": "boehm-gc/threadlibs.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "387d23058296efbb5e367309c8356daf2db59baa", "filename": "boehm-gc/typd_mlc.c", "status": "added", "additions": 814, "deletions": 0, "changes": 814, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ftypd_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Ftypd_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftypd_mlc.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "5611487373c68ffc4b06baea4c8a41cfa80c617b", "filename": "boehm-gc/version.h", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "84906b00a68489f158f12c9e86dba9eb0d73a2a9", "filename": "boehm-gc/weakpointer.h", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fweakpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fweakpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fweakpointer.h?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}, {"sha": "eb485bdc064d1a4513da4023bec876288184a1f7", "filename": "boehm-gc/win32_threads.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ffefd017128fecccdd52aa8b6fb9f042e0bbb8/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=73ffefd017128fecccdd52aa8b6fb9f042e0bbb8"}]}