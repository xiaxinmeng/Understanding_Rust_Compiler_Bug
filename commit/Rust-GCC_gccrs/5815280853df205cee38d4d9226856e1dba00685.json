{"sha": "5815280853df205cee38d4d9226856e1dba00685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxNTI4MDg1M2RmMjA1Y2VlMzhkNGQ5MjI2ODU2ZTFkYmEwMDY4NQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-08-19T19:24:58Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-08-19T19:24:58Z"}, "message": "vec.h (VEC_lower_bound): New macro.\n\n2004-08-19  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* vec.h (VEC_lower_bound): New macro.\n\nFrom-SVN: r86262", "tree": {"sha": "5b47c7d93e50d2833953ebd3b70b833eb659c71e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b47c7d93e50d2833953ebd3b70b833eb659c71e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5815280853df205cee38d4d9226856e1dba00685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5815280853df205cee38d4d9226856e1dba00685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5815280853df205cee38d4d9226856e1dba00685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5815280853df205cee38d4d9226856e1dba00685/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d096936ca209de4adffbe8eb2f8b5a9f5af00be1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d096936ca209de4adffbe8eb2f8b5a9f5af00be1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d096936ca209de4adffbe8eb2f8b5a9f5af00be1"}], "stats": {"total": 75, "additions": 72, "deletions": 3}, "files": [{"sha": "770d2c0cf02804a907920d6bb64cb06c4173a9aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5815280853df205cee38d4d9226856e1dba00685/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5815280853df205cee38d4d9226856e1dba00685/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5815280853df205cee38d4d9226856e1dba00685", "patch": "@@ -1,3 +1,7 @@\n+2004-08-19  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* vec.h (VEC_lower_bound): New macro.\n+\t\n 2004-08-19  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR target/16446"}, {"sha": "a3eea311320e85c70f43e9c554ae37bcc83afa04", "filename": "gcc/vec.h", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5815280853df205cee38d4d9226856e1dba00685/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5815280853df205cee38d4d9226856e1dba00685/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=5815280853df205cee38d4d9226856e1dba00685", "patch": "@@ -75,6 +75,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    element ordering 'ordered_remove', and one which does not\n    'unordered_remove'.  The latter function copies the end element\n    into the removed slot, rather than invoke a memmove operation.\n+   The 'lower_bound' function will determine where to place an item in the\n+   array using insert that will maintain sorted order.\n \n    If you need to directly manipulate a vector, then the 'address'\n    accessor will return the address of the start of the vector.  Also\n@@ -300,6 +302,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define VEC_address(TDEF,V)\t\t(VEC_OP(TDEF,address)(V))\n \n+/* Find the first index in the vector not less than the object.\n+   unsigned VEC_T_lower_bound (VEC(T) *v, const T val, \n+                               bool (*lessthan) (const T, const T)); // Pointer\n+   unsigned VEC_T_lower_bound (VEC(T) *v, const T *val,\n+                               bool (*lessthan) (const T*, const T*)); // Object\n+   \n+   Find the first position in which VAL could be inserted without\n+   changing the ordering of V.  LESSTHAN is a function that returns\n+   true if the first argument is strictly less than the second.   */\n+   \n+#define VEC_lower_bound(TDEF,V,O,LT)    \\\n+       (VEC_OP(TDEF,lower_bound)(V,O,LT VEC_CHECK_INFO))\n+\n #if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n extern void *vec_p_reserve (void *, int MEM_STAT_DECL);\n@@ -475,7 +490,32 @@ static inline TDEF VEC_OP (TDEF,replace)\t\t  \t     \t  \\\n   return old_obj_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t     \t  \t  \\\n+static inline unsigned VEC_OP (TDEF,lower_bound)\t\t\t\\\n+     (VEC (TDEF) *vec_, const TDEF obj_, bool (*lessthan_)(const TDEF, const TDEF) VEC_CHECK_DECL) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+   unsigned int len_ = VEC_OP (TDEF, length) (vec_);\t\t\t\\\n+   unsigned int half_, middle_;\t\t\t\t\t\t\\\n+   unsigned int first_ = 0;\t\t\t\t\t\t\\\n+   while (len_ > 0)\t\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+        TDEF middle_elem_;\t\t\t\t\t\t\\\n+        half_ = len_ >> 1;\t\t\t\t\t\t\\\n+        middle_ = first_;\t\t\t\t\t\t\\\n+        middle_ += half_;\t\t\t\t\t\t\\\n+        middle_elem_ = VEC_OP (TDEF, index) (vec_, middle_ VEC_CHECK_PASS); \\\n+        if (lessthan_ (middle_elem_, obj_))\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+             first_ = middle_;\t\t\t\t\t\t\\\n+             ++first_;\t\t\t\t\t\t\t\\\n+             len_ = len_ - half_ - 1;\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+          len_ = half_;\t\t\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+   return first_;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t\\\n      (VEC (TDEF) *vec_, unsigned ix_, TDEF obj_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n@@ -670,8 +710,33 @@ static inline TDEF *VEC_OP (TDEF,replace)\t\t\t\t  \\\n   return slot_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, unsigned ix_, const TDEF *obj_ VEC_CHECK_DECL)\t  \\\n+static inline unsigned VEC_OP (TDEF,lower_bound)\t\t\t\\\n+     (VEC (TDEF) *vec_, const TDEF *obj_, bool (*lessthan_)(const TDEF *, const TDEF *) VEC_CHECK_DECL) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+   unsigned int len_ = VEC_OP (TDEF, length) (vec_);\t\t\t\\\n+   unsigned int half_, middle_;\t\t\t\t\t\t\\\n+   unsigned int first_ = 0;\t\t\t\t\t\t\\\n+   while (len_ > 0)\t\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+        TDEF *middle_elem_;\t\t\t\t\t\t\\\n+        half_ = len_ >> 1;\t\t\t\t\t\t\\\n+        middle_ = first_;\t\t\t\t\t\t\\\n+        middle_ += half_;\t\t\t\t\t\t\\\n+        middle_elem_ = VEC_OP (TDEF, index) (vec_, middle_ VEC_CHECK_PASS); \\\n+        if (lessthan_ (middle_elem_, obj_))\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+             first_ = middle_;\t\t\t\t\t\t\\\n+             ++first_;\t\t\t\t\t\t\t\\\n+             len_ = len_ - half_ - 1;\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+          len_ = half_;\t\t\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+   return first_;\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t\\\n+     (VEC (TDEF) *vec_, unsigned ix_, const TDEF *obj_ VEC_CHECK_DECL)\t\\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\"}]}