{"sha": "a2a76ce71b44712ae1979cb28c0978e30819b43e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJhNzZjZTcxYjQ0NzEyYWUxOTc5Y2IyOGMwOTc4ZTMwODE5YjQzZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-02-11T20:17:27Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-02-11T20:17:27Z"}, "message": "cpphash.c: Fix formatting, update commentary.\n\n\t* cpphash.c: Fix formatting, update commentary.\n\t(dump_definition): Take three separate arguments instead of a\n\tMACRODEF structure argument.\n\t* cpphash.h: Update prototype of dump_definition.\n\t* cppinit.c (cpp_finish): Update call of dump_definition.\n\n\t* cpplib.c (do_define): Always create new hash entry with\n\tT_MACRO type.  Remove redundant check for redefinition of\n\tpoisoned identifier.  Update call of dump_definition.\n\t(do_undef): Don't call check_macro_name.  Rename sym_length to\n\tlen.\n\t(do_error, do_warning): Don't use copy_rest_of_line or\n\tSKIP_WHITE_SPACE.\n\t(do_warning): Don't use pedwarn for the actual warning,\n\tonly the notice about its not being in the standard.  (Fixes\n\tbug with #warning in system headers.)\n\t(do_ident): Stricter argument checking - accept only a single\n\tstring after #ident.  Also, macro-expand the line.\n\t(do_xifdef): Use cpp_defined.  De-obfuscate.\n\n\t(do_pragma): Split out specific pragma handling to separate\n\tfunctions.  Use get_directive_token.  Update commentary.  Do\n\tnot pass on #pragma once or #pragma poison to the front end.\n\t(do_pragma_once, do_pragma_implementation, do_pragma_poison,\n\tdo_pragma_default): New.\n\nFrom-SVN: r31931", "tree": {"sha": "4e6ca8c2c0a5cca5b730a20801572a000aed5b2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e6ca8c2c0a5cca5b730a20801572a000aed5b2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2a76ce71b44712ae1979cb28c0978e30819b43e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2a76ce71b44712ae1979cb28c0978e30819b43e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2a76ce71b44712ae1979cb28c0978e30819b43e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2a76ce71b44712ae1979cb28c0978e30819b43e/comments", "author": null, "committer": null, "parents": [{"sha": "2144ddea76b1e7d190b3c9c4a63575fc7c86f54e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2144ddea76b1e7d190b3c9c4a63575fc7c86f54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2144ddea76b1e7d190b3c9c4a63575fc7c86f54e"}], "stats": {"total": 405, "additions": 241, "deletions": 164}, "files": [{"sha": "3b5ff570d2b5b6e68cf272566a2dddb69e0c5d5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2a76ce71b44712ae1979cb28c0978e30819b43e", "patch": "@@ -1,3 +1,31 @@\n+2000-02-11  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c: Fix formatting, update commentary.\n+\t(dump_definition): Take three separate arguments instead of a\n+\tMACRODEF structure argument.\n+\t* cpphash.h: Update prototype of dump_definition.\n+\t* cppinit.c (cpp_finish): Update call of dump_definition.\n+\n+\t* cpplib.c (do_define): Always create new hash entry with\n+\tT_MACRO type.  Remove redundant check for redefinition of\n+\tpoisoned identifier.  Update call of dump_definition.\n+\t(do_undef): Don't call check_macro_name.  Rename sym_length to\n+\tlen.\n+\t(do_error, do_warning): Don't use copy_rest_of_line or\n+\tSKIP_WHITE_SPACE.\n+\t(do_warning): Don't use pedwarn for the actual warning,\n+\tonly the notice about its not being in the standard.  (Fixes\n+\tbug with #warning in system headers.)\n+\t(do_ident): Stricter argument checking - accept only a single\n+\tstring after #ident.  Also, macro-expand the line.\n+\t(do_xifdef): Use cpp_defined.  De-obfuscate.\n+\n+\t(do_pragma): Split out specific pragma handling to separate\n+\tfunctions.  Use get_directive_token.  Update commentary.  Do\n+\tnot pass on #pragma once or #pragma poison to the front end.\n+\t(do_pragma_once, do_pragma_implementation, do_pragma_poison,\n+\tdo_pragma_default): New.\n+\n Feb 11 12:30:53 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* jump.c (jump_optimize_1): The first operand in a relational"}, {"sha": "fc2b8ff76d5076eb785ebd38f12c829592aa186d", "filename": "gcc/cpphash.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=a2a76ce71b44712ae1979cb28c0978e30819b43e", "patch": "@@ -89,8 +89,7 @@ struct argdata\n };\n \n \n-/* Return hash function on name.  must be compatible with the one\n-   computed a step at a time, elsewhere  */\n+/* Calculate hash function on a string.  */\n \n static unsigned int\n hashf (s, len)\n@@ -169,7 +168,6 @@ void\n delete_macro (hp)\n      HASHNODE *hp;\n {\n-\n   if (hp->prev != NULL)\n     hp->prev->next = hp->next;\n   if (hp->next != NULL)\n@@ -1575,15 +1573,15 @@ comp_def_part (first, beg1, len1, beg2, len2, last)\n    to be read back in again. */\n \n void\n-dump_definition (pfile, macro)\n+dump_definition (pfile, sym, len, defn)\n      cpp_reader *pfile;\n-     MACRODEF macro;\n+     const U_CHAR *sym;\n+     long len;\n+     DEFINITION *defn;\n {\n-  DEFINITION *defn = macro.defn;\n-\n-  CPP_RESERVE (pfile, macro.symlen + sizeof \"#define \");\n+  CPP_RESERVE (pfile, len + sizeof \"#define \");\n   CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" -1);\n-  CPP_PUTS_Q (pfile, macro.symnam, macro.symlen);\n+  CPP_PUTS_Q (pfile, sym, len);\n \n   if (defn->nargs == -1)\n     {"}, {"sha": "c9273d56db954d60f6641e8694e4b6c3193050d7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=a2a76ce71b44712ae1979cb28c0978e30819b43e", "patch": "@@ -107,6 +107,7 @@ extern MACRODEF create_definition PARAMS ((U_CHAR *, U_CHAR *,\n extern int compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n \t\t\t\t\t   DEFINITION *));\n extern void macroexpand\t\t  PARAMS ((cpp_reader *, HASHNODE *));\n-extern void dump_definition\t  PARAMS ((cpp_reader *, MACRODEF));\n+extern void dump_definition\t  PARAMS ((cpp_reader *, const U_CHAR *, long,\n+\t\t\t\t\t   DEFINITION *));\n \n #endif"}, {"sha": "d941546b1ba45d400974558ee16b5ea581435d6f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=a2a76ce71b44712ae1979cb28c0978e30819b43e", "patch": "@@ -1040,16 +1040,12 @@ cpp_finish (pfile)\n     {\n       int i;\n       HASHNODE *h;\n-      MACRODEF m;\n       for (i = HASHSIZE; --i >= 0;)\n \t{\n \t  for (h = pfile->hashtab[i]; h; h = h->next)\n \t    if (h->type == T_MACRO)\n \t      {\n-\t\tm.defn = h->value.defn;\n-\t\tm.symnam = h->name;\n-\t\tm.symlen = h->length;\n-\t\tdump_definition (pfile, m);\n+\t\tdump_definition (pfile, h->name, h->length, h->value.defn);\n \t\tCPP_PUTC (pfile, '\\n');\n \t      }\n \t}"}, {"sha": "9238d3346022893dffd184d02687e9b652a3e54c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 203, "deletions": 149, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2a76ce71b44712ae1979cb28c0978e30819b43e/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a2a76ce71b44712ae1979cb28c0978e30819b43e", "patch": "@@ -669,16 +669,10 @@ do_define (pfile, keyword)\n   HASHNODE *hp;\n   long here;\n   U_CHAR *macro, *buf, *end;\n-  enum node_type new_type;\n \n   here = CPP_WRITTEN (pfile);\n   copy_rest_of_line (pfile);\n \n-  if (keyword == NULL || keyword->type == T_DEFINE)\n-    new_type = T_MACRO;\n-  else\n-    new_type = T_POISON;\n-\n   /* Copy out the line so we can pop the token buffer. */\n   buf = pfile->token_buffer + here;\n   end = CPP_PWRITTEN (pfile);\n@@ -694,18 +688,19 @@ do_define (pfile, keyword)\n \n   if ((hp = cpp_lookup (pfile, mdef.symnam, mdef.symlen)) != NULL)\n     {\n-      int ok = 0;\n-      /* Redefining a poisoned identifier is even worse than `not ok'.  */\n-      if (hp->type == T_POISON)\n-\tok = -1;\n+      int ok;\n+\n       /* Redefining a macro is ok if the definitions are the same.  */\n-      else if (hp->type == T_MACRO)\n+      if (hp->type == T_MACRO)\n \tok = ! compare_defs (pfile, mdef.defn, hp->value.defn);\n       /* Redefining a constant is ok with -D.  */\n       else if (hp->type == T_CONST || hp->type == T_STDC)\n         ok = ! CPP_OPTIONS (pfile)->done_initializing;\n+      /* Otherwise it's not ok.  */\n+      else\n+\tok = 0;\n       /* Print the warning or error if it's not ok.  */\n-      if (ok <= 0)\n+      if (! ok)\n \t{\n \t  if (hp->type == T_POISON)\n \t    cpp_error (pfile, \"redefining poisoned `%.*s'\", \n@@ -720,19 +715,19 @@ do_define (pfile, keyword)\n       if (hp->type != T_POISON)\n \t{\n \t  /* Replace the old definition.  */\n-\t  hp->type = new_type;\n+\t  hp->type = T_MACRO;\n \t  free_definition (hp->value.defn);\n \t  hp->value.defn = mdef.defn;\n \t}\n     }\n   else\n-    cpp_install (pfile, mdef.symnam, mdef.symlen, new_type, (char *)mdef.defn);\n+    cpp_install (pfile, mdef.symnam, mdef.symlen, T_MACRO, (char *)mdef.defn);\n \n   if (keyword != NULL && keyword->type == T_DEFINE)\n     {\n       if (CPP_OPTIONS (pfile)->debug_output\n \t  || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n-\tdump_definition (pfile, mdef);\n+\tdump_definition (pfile, mdef.symnam, mdef.symlen, mdef.defn);\n       else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n \tpass_thru_directive (mdef.symnam, mdef.symlen, pfile, keyword);\n     }\n@@ -1444,7 +1439,7 @@ do_undef (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword;\n {\n-  int sym_length;\n+  int len;\n   HASHNODE *hp;\n   U_CHAR *buf, *name, *limit;\n   int c;\n@@ -1465,8 +1460,9 @@ do_undef (pfile, keyword)\n   limit = CPP_PWRITTEN(pfile);\n \n   /* Copy out the token so we can pop the token buffer. */\n-  name = (U_CHAR *) alloca (limit - buf + 1);\n-  bcopy(buf, name, limit - buf);\n+  len = limit - buf;\n+  name = (U_CHAR *) alloca (len + 1);\n+  memcpy (name, buf, len);\n   name[limit - buf] = '\\0';\n \n   token = get_directive_token (pfile);\n@@ -1478,14 +1474,12 @@ do_undef (pfile, keyword)\n \n   CPP_SET_WRITTEN (pfile, here);\n \n-  sym_length = check_macro_name (pfile, buf);\n-\n-  while ((hp = cpp_lookup (pfile, name, sym_length)) != NULL)\n+  while ((hp = cpp_lookup (pfile, name, len)) != NULL)\n     {\n       /* If we are generating additional info for debugging (with -g) we\n \t need to pass through all effective #undef commands.  */\n       if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\tpass_thru_directive (name, sym_length, pfile, keyword);\n+\tpass_thru_directive (name, len, pfile, keyword);\n       if (hp->type == T_POISON)\n \tcpp_error (pfile, \"cannot undefine poisoned `%s'\", hp->name);\n       else \n@@ -1529,14 +1523,14 @@ do_error (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  long here = CPP_WRITTEN (pfile);\n-  U_CHAR *text;\n-  copy_rest_of_line (pfile);\n-  text = pfile->token_buffer + here;\n-  SKIP_WHITE_SPACE(text);\n+  U_CHAR *text, *limit;\n \n-  cpp_error (pfile, \"#error %s\", text);\n-  CPP_SET_WRITTEN (pfile, here);\n+  cpp_skip_hspace (pfile);\n+  text = CPP_BUFFER (pfile)->cur;\n+  skip_rest_of_line (pfile);\n+  limit = CPP_BUFFER (pfile)->cur;\n+\n+  cpp_error (pfile, \"#error %.*s\", (int)(limit - text), text);\n   return 0;\n }\n \n@@ -1550,169 +1544,233 @@ do_warning (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  U_CHAR *text;\n-  long here = CPP_WRITTEN(pfile);\n-  copy_rest_of_line (pfile);\n-  text = pfile->token_buffer + here;\n-  SKIP_WHITE_SPACE(text);\n+  U_CHAR *text, *limit;\n+\n+  cpp_skip_hspace (pfile);\n+  text = CPP_BUFFER (pfile)->cur;\n+  skip_rest_of_line (pfile);\n+  limit = CPP_BUFFER (pfile)->cur;\n \n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#warning'\");\n \n-  /* Use `pedwarn' not `warning', because #warning isn't in the C Standard;\n-     if -pedantic-errors is given, #warning should cause an error.  */\n-  cpp_pedwarn (pfile, \"#warning %s\", text);\n-  CPP_SET_WRITTEN (pfile, here);\n+  cpp_warning (pfile, \"#warning %.*s\", (int)(limit - text), text);\n   return 0;\n }\n \n-/* Report program identification.\n-   This is not precisely what cccp does with #ident, however I believe\n-   it matches `closely enough' (behavior is identical as long as there\n-   are no macros on the #ident line, which is pathological in my opinion).  */\n+/* Report program identification.  */\n \n static int\n do_ident (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n+  long old_written = CPP_WRITTEN (pfile);\n+\n   /* Allow #ident in system headers, since that's not user's fault.  */\n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#ident'\");\n \n   CPP_PUTS (pfile, \"#ident \", 7);\n-  cpp_skip_hspace (pfile);\n-  copy_rest_of_line (pfile);\n+\n+  /* Next token should be a string constant.  */\n+  if (get_directive_token (pfile) == CPP_STRING)\n+    /* And then a newline.  */\n+    if (get_directive_token (pfile) == CPP_VSPACE)\n+      /* Good - ship it.  */\n+      return 0;\n+\n+  cpp_error (pfile, \"invalid #ident\");\n+  skip_rest_of_line (pfile);\n+  CPP_SET_WRITTEN (pfile, old_written);  /* discard directive */\n \n   return 0;\n }\n \n-/* Just check for some recognized pragmas that need validation here,\n-   and leave the text in the token buffer to be output. */\n+/* Pragmata handling.  We handle some of these, and pass the rest on\n+   to the front end.  C99 defines three pragmas and says that no macro\n+   expansion is to be performed on them; whether or not macro\n+   expansion happens for other pragmas is implementation defined.\n+   This implementation never macro-expands the text after #pragma.\n+\n+   We currently do not support the _Pragma operator.  Support for that\n+   has to be coordinated with the front end.  Proposed implementation:\n+   both #pragma blah blah and _Pragma(\"blah blah\") become\n+   __builtin_pragma(blah blah) and we teach the parser about that.  */\n+\n+/* Sub-handlers for the pragmas needing treatment here.\n+   They return 1 if the token buffer is to be popped, 0 if not. */\n+static int do_pragma_once\t\tPARAMS ((cpp_reader *));\n+static int do_pragma_implementation\tPARAMS ((cpp_reader *));\n+static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n+static int do_pragma_default\t\tPARAMS ((cpp_reader *));\n \n static int\n do_pragma (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  long here;\n+  long here, key;\n   U_CHAR *buf;\n+  int pop;\n \n-  CPP_PUTS (pfile, \"#pragma \", 8);\n-  cpp_skip_hspace (pfile);\n-  \n   here = CPP_WRITTEN (pfile);\n-  copy_rest_of_line (pfile);\n-  buf = pfile->token_buffer + here;\n-  \n-  if (!strncmp (buf, \"once\", 4))\n-    {\n-      cpp_buffer *ip = NULL;\n+  CPP_PUTS (pfile, \"#pragma \", 8);\n \n-      /* Allow #pragma once in system headers, since that's not the user's\n-\t fault.  */\n-      if (!CPP_BUFFER (pfile)->system_header_p)\n-\tcpp_warning (pfile, \"`#pragma once' is obsolete\");\n-      \n-      for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n-        {\n-\t  if (ip == CPP_NULL_BUFFER (pfile))\n-\t    return 0;\n-\t  if (ip->fname != NULL)\n-\t    break;\n-\t}\n+  key = CPP_WRITTEN (pfile);\n+  pfile->no_macro_expand++;\n+  if (get_directive_token (pfile) != CPP_NAME)\n+    goto skip;\n+\n+  buf = pfile->token_buffer + key;\n+  CPP_PUTC (pfile, ' ');\n+\n+#define tokis(x) !strncmp(buf, x, sizeof(x) - 1)\n+  if (tokis (\"once\"))\n+    pop = do_pragma_once (pfile);\n+  else if (tokis (\"implementation\"))\n+    pop = do_pragma_implementation (pfile);\n+  else if (tokis (\"poison\"))\n+    pop = do_pragma_poison (pfile);\n+  else\n+    pop = do_pragma_default (pfile);\n+#undef tokis\n \n-      if (CPP_PREV_BUFFER (ip) == CPP_NULL_BUFFER (pfile))\n-\tcpp_warning (pfile, \"`#pragma once' outside include file\");\n-      else\n-\tip->ihash->control_macro = \"\";  /* never repeat */\n-    }\n-  else if (!strncmp (buf, \"implementation\", 14))\n-    {\n-      /* Be quiet about `#pragma implementation' for a file only if it hasn't\n-\t been included yet.  */\n-      struct include_hash *ptr;\n-      U_CHAR *p = buf + 14, *fname, *fcopy;\n-      SKIP_WHITE_SPACE (p);\n-      if (*p == '\\n' || *p != '\\\"')\n-        return 0;\n+  if (get_directive_token (pfile) != CPP_VSPACE)\n+    goto skip;\n \n-      fname = p + 1;\n-      p = (U_CHAR *) index (fname, '\\\"');\n+  if (pop)\n+    CPP_SET_WRITTEN (pfile, here);\n+  pfile->no_macro_expand--;\n+  return 0;\n \n-      fcopy = (U_CHAR *) alloca (p - fname + 1);\n-      bcopy (fname, fcopy, p - fname);\n-      fcopy[p-fname] = '\\0';\n+ skip:\n+  cpp_error (pfile, \"malformed #pragma directive\");\n+  skip_rest_of_line (pfile);\n+  CPP_SET_WRITTEN (pfile, here);\n+  pfile->no_macro_expand--;\n+  return 0;\n+}\n \n-      ptr = include_hash (pfile, fcopy, 0);\n-      if (ptr)\n-        cpp_warning (pfile,\n-\t  \"`#pragma implementation' for `%s' appears after file is included\",\n-\t\t     fcopy);\n-    }\n-  else if (!strncmp (buf, \"poison\", 6))\n+static int\n+do_pragma_default (pfile)\n+     cpp_reader *pfile;\n+{\n+  while (get_directive_token (pfile) != CPP_VSPACE)\n+    CPP_PUTC (pfile, ' ');\n+  return 0;\n+}\n+\n+static int\n+do_pragma_once (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+\n+  if (ip->fname == NULL)\n     {\n-      /* Poison these symbols so that all subsequent usage produces an\n-\t error message.  */\n-      U_CHAR *p = buf + 6;\n-      size_t plen;\n-      U_CHAR *syms;\n-      int writeit;\n+      cpp_ice (pfile, \"ip->fname == NULL in do_pragma_once\");\n+      return 1;\n+    }\n+  \n+  /* Allow #pragma once in system headers, since that's not the user's\n+     fault.  */\n+  if (!ip->system_header_p)\n+    cpp_warning (pfile, \"`#pragma once' is obsolete\");\n+      \n+  if (CPP_PREV_BUFFER (ip) == CPP_NULL_BUFFER (pfile))\n+    cpp_warning (pfile, \"`#pragma once' outside include file\");\n+  else\n+    ip->ihash->control_macro = \"\";  /* never repeat */\n \n-      SKIP_WHITE_SPACE (p);\n-      plen = strlen(p) + 1;\n+  return 1;\n+}\n \n-      syms = (U_CHAR *) alloca (plen);\n-      memcpy (syms, p, plen);\n+static int\n+do_pragma_implementation (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* Be quiet about `#pragma implementation' for a file only if it hasn't\n+     been included yet.  */\n+  struct include_hash *ptr;\n+  enum cpp_token token;\n+  long written = CPP_WRITTEN (pfile);\n+  U_CHAR *name;\n+  U_CHAR *copy;\n \n-      /* As a rule, don't include #pragma poison commands in output,  \n-         unless the user asks for them.  */\n-      writeit = (CPP_OPTIONS (pfile)->debug_output\n-\t\t || CPP_OPTIONS (pfile)->dump_macros == dump_definitions\n-\t\t || CPP_OPTIONS (pfile)->dump_macros == dump_names);\n+  token = get_directive_token (pfile);\n+  if (token == CPP_VSPACE)\n+    return 0;\n+  else if (token != CPP_STRING)\n+    {\n+      cpp_error (pfile, \"malformed #pragma implementation\");\n+      return 1;\n+    }\n \n-      if (writeit)\n-\tCPP_SET_WRITTEN (pfile, here);\n-      else\n-\tCPP_SET_WRITTEN (pfile, here-8);\n+  name = pfile->token_buffer + written + 1;\n+  copy = xstrdup (name);\n+  copy[strlen(copy)] = '\\0';  /* trim trailing quote */\n+  \n+  ptr = include_hash (pfile, copy, 0);\n+  if (ptr)\n+    cpp_warning (pfile,\n+\t \"`#pragma implementation' for `%s' appears after file is included\",\n+\t\t copy);\n+  free (copy);\n+  return 0;\n+}\n \n-      if (writeit)\n+static int\n+do_pragma_poison (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* Poison these symbols so that all subsequent usage produces an\n+     error message.  */\n+  U_CHAR *p;\n+  HASHNODE *hp;\n+  long written;\n+  size_t len;\n+  enum cpp_token token;\n+  int writeit;\n+  /* As a rule, don't include #pragma poison commands in output,  \n+     unless the user asks for them.  */\n+  writeit = (CPP_OPTIONS (pfile)->debug_output\n+\t     || CPP_OPTIONS (pfile)->dump_macros == dump_definitions\n+\t     || CPP_OPTIONS (pfile)->dump_macros == dump_names);\n+\n+  for (;;)\n+    {\n+      written = CPP_WRITTEN (pfile);\n+      token = get_directive_token (pfile);\n+      if (token == CPP_VSPACE)\n+\tbreak;\n+      if (token != CPP_NAME)\n \t{\n-\t  CPP_RESERVE (pfile, plen + 7);\n-\t  CPP_PUTS_Q (pfile, \"poison\", 7);\n+\t  cpp_error (pfile, \"invalid #pragma poison directive\");\n+\t  skip_rest_of_line (pfile);\n+\t  return 1;\n \t}\n \n-      while (*syms != '\\0')\n+      p = pfile->token_buffer + written;\n+      len = strlen (p);\n+      if ((hp = cpp_lookup (pfile, p, len)))\n \t{\n-\t  U_CHAR *end = syms;\n-\t  \n-\t  while (is_idchar(*end))\n-\t    end++;\n-\n-\t  if (!is_hspace(*end) && *end != '\\0')\n-\t    {\n-\t      cpp_error (pfile, \"invalid #pragma poison directive\");\n-\t      return 1;\n-\t    }\n-\n-\t  if (cpp_push_buffer (pfile, syms, end - syms) != NULL)\n-\t    {\n-\t      do_define (pfile, keyword);\n-\t      cpp_pop_buffer (pfile);\n-\t    }\n-\t  if (writeit)\n+\t  if (hp->type != T_POISON)\n \t    {\n-\t      CPP_PUTC_Q (pfile, ' ');\n-\t      CPP_PUTS_Q (pfile, syms, end - syms);\n+\t      cpp_warning (pfile, \"poisoning existing macro `%s'\", p);\n+\t      free_definition (hp->value.defn);\n+\t      hp->value.defn = 0;\n+\t      hp->type = T_POISON;\n \t    }\n-\t  syms = end;\n-\t  SKIP_WHITE_SPACE (syms);\n \t}\n+      else\n+\tcpp_install (pfile, p, len, T_POISON, 0);\n+      if (writeit)\n+\tCPP_PUTC (pfile, ' ');\n     }\n-\n-  return 0;\n+  return !writeit;\n }\n-\n+ \n #ifdef SCCS_DIRECTIVE\n /* Just ignore #sccs, on systems where we define it at all.  */\n \n@@ -1727,7 +1785,6 @@ do_sccs (pfile, keyword)\n   return 0;\n }\n #endif\n-\f\n \n /* We've found an `#if' directive.  If the only thing before it in\n    this file is white space, and if it is of the form\n@@ -1933,18 +1990,15 @@ do_xifdef (pfile, keyword)\n     }\n   else if (token == CPP_NAME)\n     {\n-      HASHNODE *hp = cpp_lookup (pfile, ident, ident_length);\n-      skip = (hp == NULL) ^ (keyword->type == T_IFNDEF);\n+      skip = cpp_defined (pfile, ident, ident_length);\n+      if (keyword->type == T_IFDEF)\n+\tskip = !skip;\n+\n       if (start_of_file && !skip)\n \t{\n \t  control_macro = (U_CHAR *) xmalloc (ident_length + 1);\n \t  bcopy (ident, control_macro, ident_length + 1);\n \t}\n-      if (hp != NULL && hp->type == T_POISON)\n-\t{\n-\t  cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n-\t  skip = !skip;\n-\t}\n     }\n   else\n     {"}]}