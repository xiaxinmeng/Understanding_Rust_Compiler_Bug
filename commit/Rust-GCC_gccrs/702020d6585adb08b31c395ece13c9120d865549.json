{"sha": "702020d6585adb08b31c395ece13c9120d865549", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAyMDIwZDY1ODVhZGIwOGIzMWMzOTVlY2UxM2M5MTIwZDg2NTU0OQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-11-09T02:51:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-11-09T02:51:34Z"}, "message": "1750a.c: Fix comment formatting.\n\n\t* config/1750a/1750a.c: Fix comment formatting.\n\t* config/1750a/1750a.h: Likewise.\n\nFrom-SVN: r46871", "tree": {"sha": "790f01ccead676e548c080f77085b4279ba3a20b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/790f01ccead676e548c080f77085b4279ba3a20b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/702020d6585adb08b31c395ece13c9120d865549", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/702020d6585adb08b31c395ece13c9120d865549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/702020d6585adb08b31c395ece13c9120d865549", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/702020d6585adb08b31c395ece13c9120d865549/comments", "author": null, "committer": null, "parents": [{"sha": "cc9a08e014bf94a61e66515f9fefd8ec3e832301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9a08e014bf94a61e66515f9fefd8ec3e832301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9a08e014bf94a61e66515f9fefd8ec3e832301"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "09d9cbd95de4bb5ad2a6d5c216f73a5658b19a6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702020d6585adb08b31c395ece13c9120d865549/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702020d6585adb08b31c395ece13c9120d865549/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=702020d6585adb08b31c395ece13c9120d865549", "patch": "@@ -1,3 +1,8 @@\n+2001-11-08  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/1750a/1750a.c: Fix comment formatting.\n+\t* config/1750a/1750a.h: Likewise.\n+\n 2001-11-08  Phil Edwards  <pedwards@disaster.jaj.com>\n \n \t* configure.in (--enable-languages): Be more permissive about"}, {"sha": "a5ad52a15fdac0ea76bf33d2fe601b2e841d9280", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702020d6585adb08b31c395ece13c9120d865549/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702020d6585adb08b31c395ece13c9120d865549/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=702020d6585adb08b31c395ece13c9120d865549", "patch": "@@ -117,7 +117,7 @@ output_function_prologue (file, size)\n    The function epilogue should not depend on the current stack\n    pointer!  It should use the frame pointer only.  This is mandatory\n    because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning. */\n+   adjustments before returning.  */\n \n static void\n output_function_epilogue (file, size)\n@@ -157,7 +157,7 @@ notice_update_cc (exp)\n       /* Jumps do not alter the cc's.  */\n       if (SET_DEST (exp) == pc_rtx)\n \treturn;\n-      /* Moving a register or constant into memory doesn't alter the cc's. */\n+      /* Moving a register or constant into memory doesn't alter the cc's.  */\n       if (GET_CODE (SET_DEST (exp)) == MEM\n \t  && (src_code == REG || src_code == CONST_INT))\n \treturn;\n@@ -182,7 +182,7 @@ notice_update_cc (exp)\n \t  cc_status.value1 = SET_SRC (exp);\n \t  return;\n \t}\n-      /* Anything else will set cc_status. */\n+      /* Anything else will set cc_status.  */\n       cc_status.flags = CC_NO_OVERFLOW;\n       cc_status.value1 = SET_SRC (exp);\n       cc_status.value2 = SET_DEST (exp);"}, {"sha": "a7ddeb74f0530aa48dde55b851e76e9dd9be4ab2", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702020d6585adb08b31c395ece13c9120d865549/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702020d6585adb08b31c395ece13c9120d865549/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=702020d6585adb08b31c395ece13c9120d865549", "patch": "@@ -48,7 +48,7 @@ Boston, MA 02111-1307, USA.  */\n /*****************************************************************************/\n \n /* SPECIAL ADDITION FOR MIL-STD-1750A     by O.M.Kellogg, 15-Apr-1993 */\n-/* See file aux-output.c for the actual data instances. */\n+/* See file aux-output.c for the actual data instances.  */\n struct datalabel_array {\n     char *name;\n     char value[14];\n@@ -77,7 +77,7 @@ extern const char *const sectname[4];\n    Though 1750 actually counts bits in big-endian fashion, the sign bit\n    is still the most significant bit, which is leftmost. Therefore leaving\n    this little-endian. Adjust short before assembler output when needed:\n-   e.g. in QImode, a GCC bit n is a 1750 bit (15-n). */\n+   e.g. in QImode, a GCC bit n is a 1750 bit (15-n).  */\n #define BITS_BIG_ENDIAN 0 \n \n /* Define this if most significant byte of a word is the lowest numbered.  */\n@@ -87,7 +87,7 @@ extern const char *const sectname[4];\n \n /* Define this if most significant word of a multiword value is lowest\n    numbered.\n-   True for 1750. */\n+   True for 1750.  */\n #define WORDS_BIG_ENDIAN 1\n \n /* number of bits in an addressable storage unit */\n@@ -108,7 +108,7 @@ extern const char *const sectname[4];\n \n #define PTRDIFF_TYPE        \"int\"\n \n-/* Type to use for `size_t'. If undefined, uses `long unsigned int'. */\n+/* Type to use for `size_t'. If undefined, uses `long unsigned int'.  */\n #define SIZE_TYPE           \"int\"\n \n /* 1750a preliminary\n@@ -119,7 +119,7 @@ extern const char *const sectname[4];\n #define POINTER_BOUNDARY     16\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-/* 1750: should have had to make this 32 when BITS_PER_WORD is 32. */\n+/* 1750: should have had to make this 32 when BITS_PER_WORD is 32.  */\n #define PARM_BOUNDARY        16\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n@@ -135,37 +135,37 @@ extern const char *const sectname[4];\n #define BIGGEST_ALIGNMENT    16\n \n /* Define this to 1 if move instructions will actually fail to work\n-   when given unaligned data. */\n+   when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n \n /* Define number of bits in most basic integer type.\n    (If undefined, default is BITS_PER_WORD).\n    #define INT_TYPE_SIZE  16  */\n \n /* Define number of bits in short integer type.\n-   (If undefined, default is half of BITS_PER_WORD). */\n+   (If undefined, default is half of BITS_PER_WORD).  */\n #define SHORT_TYPE_SIZE 16\n \n /* Define number of bits in long integer type.\n-   (If undefined, default is BITS_PER_WORD). */\n+   (If undefined, default is BITS_PER_WORD).  */\n #define LONG_TYPE_SIZE  32\n \n /* Define number of bits in long long integer type.\n-   (If undefined, default is twice BITS_PER_WORD). */\n+   (If undefined, default is twice BITS_PER_WORD).  */\n /* 1750 PRELIMINARY : no processor support for `long long', therefore\n         need to check out the long-long opencodings ! */\n #define LONG_LONG_TYPE_SIZE  64\n \n /* Define number of bits in char type.\n-   (If undefined, default is one fourth of BITS_PER_WORD). */\n+   (If undefined, default is one fourth of BITS_PER_WORD).  */\n #define CHAR_TYPE_SIZE  16\n \n /* Define number of bits in float type.\n-   (If undefined, default is BITS_PER_WORD). */\n+   (If undefined, default is BITS_PER_WORD).  */\n #define FLOAT_TYPE_SIZE  32\n \n /* Define number of bits in double type.\n-   (If undefined, default is twice BITS_PER_WORD). */\n+   (If undefined, default is twice BITS_PER_WORD).  */\n #define DOUBLE_TYPE_SIZE  48\n \n /*****************************************************************************/\n@@ -176,12 +176,12 @@ extern const char *const sectname[4];\n    The hardware registers are assigned numbers for the compiler\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n    All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers. */\n+   even those that are not normally considered general registers.  */\n #define FIRST_PSEUDO_REGISTER 16\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n-   R15 is the 1750A stack pointer. R14 is the frame pointer. */\n+   R15 is the 1750A stack pointer. R14 is the frame pointer.  */\n \n #define FIXED_REGISTERS  \\\n  { 0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -214,17 +214,17 @@ extern const char *const sectname[4];\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n-   All 1750 registers are one word long. */\n+   All 1750 registers are one word long.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output. */\n+   for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t1\n \n /* Specify the registers used for certain standard purposes.\n@@ -242,7 +242,7 @@ extern const char *const sectname[4];\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c. */\n+   This is computed in `reload', in reload1.c.  */\n #define FRAME_POINTER_REQUIRED 0\n \n /* Base register for access to arguments of the function.  */\n@@ -253,7 +253,7 @@ extern const char *const sectname[4];\n    #define ARGS_GROW_DOWNWARD\n */\n \n-/* Register in which static-chain is passed to a function. */\n+/* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM 13\n \n /* Place in which caller passes the structure value address.\n@@ -270,7 +270,7 @@ extern const char *const sectname[4];\n    is passed to a function.  */\n #define STRUCT_VALUE_REGNUM 12\n \n-/* Define this to be 1 if all structure return values must be in memory. */\n+/* Define this to be 1 if all structure return values must be in memory.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n /*****************************************************************************/\n@@ -304,14 +304,14 @@ extern const char *const sectname[4];\n    Here's an example to drive this point home: in \"LBX B12,R5\"\n    B12 shall be called the \"index\" reg and R5 shall be the \"base\" reg.\n    This naming inversion is due to the GCC defined capabilities of\n-   \"Base\" vs. \"Index\" regs. */\n+   \"Base\" vs. \"Index\" regs.  */\n \n enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Since GENERAL_REGS is the same class as ALL_REGS,\n-   don't give it a different class number; just make it an alias. */\n+   don't give it a different class number; just make it an alias.  */\n #define GENERAL_REGS ALL_REGS\n \n /* Give names of register classes as strings for dump file.   */\n@@ -323,7 +323,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.\n    1750 \"index\" (remember, in the *GCC* sense!) regs are R12 through R15. \n-   The only 1750 register not usable as BASE_REG is R0. */\n+   The only 1750 register not usable as BASE_REG is R0.  */\n \n #define REG_CLASS_CONTENTS  { {0}, {0x0004}, {0x0003}, {0xf000}, {0xfffe}, {0xffff} }\n \n@@ -334,14 +334,14 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n #define REGNO_REG_CLASS(REGNO) ((REGNO) == 2 ? R2 : (REGNO) == 0 ? R0_1 : \\\n   (REGNO) >= 12 ? INDEX_REGS : (REGNO) >  0 ? BASE_REGS : ALL_REGS)\n \n-/* The class value for index registers, and the one for base regs. */\n+/* The class value for index registers, and the one for base regs.  */\n \n #define BASE_REG_CLASS  BASE_REGS\n #define INDEX_REG_CLASS INDEX_REGS\n \n /* Get reg_class from a letter such as appears in the machine description.\n    For the 1750, we have 'z' for R0_1, 't' for R2, 'b' for gcc Base regs \n-   and 'x' for gcc Index regs. */\n+   and 'x' for gcc Index regs.  */\n \n #define REG_CLASS_FROM_LETTER(C) ((C) == 't' ? R2 : \\\n \t\t\t\t  (C) == 'z' ? R0_1 : \\\n@@ -361,7 +361,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    `L' is used for unsigned 8-bit address displacements in instructions\n        of addressing mode \"Base Relative\",\n    `M' is for IM mode instructions et al.,\n-   `O' is a synonym for (const_int 0). */\n+   `O' is a synonym for (const_int 0).  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n   ((C) == 'I' ? (VALUE) > 0 && (VALUE) <=  16 :\t\t\t\\\n@@ -397,7 +397,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    On the 1750A, this is the size of MODE in words,\n-   since class doesn't make any difference. */\n+   since class doesn't make any difference.  */\n #define CLASS_MAX_NREGS(CLASS,MODE)  GET_MODE_SIZE(MODE)\n \n /*****************************************************************************/\n@@ -428,7 +428,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n    1750 note: what GCC calls a \"byte\" is really a 16-bit word,\n-   because BITS_PER_UNIT is 16. */\n+   because BITS_PER_UNIT is 16.  */\n \n #define PUSH_ROUNDING(BYTES) (BYTES)\n \n@@ -467,19 +467,19 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0. */\n+   otherwise, FUNC is 0.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n \n /* Define how to find the value returned by a library function\n-   assuming the value has mode MODE. */\n+   assuming the value has mode MODE.  */\n /* 1750 note: no libcalls yet */\n \n #define LIBCALL_VALUE(MODE)  printf(\"LIBCALL_VALUE called!\\n\"), \\\n   gen_rtx_REG (MODE, 0)\n \n-/* 1 if N is a possible register number for a function value. */\n+/* 1 if N is a possible register number for a function value.  */\n \n #define FUNCTION_VALUE_REGNO_P(N)  ((N) == 0)\n \n@@ -492,7 +492,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    structure and union values. \n    #define PCC_STATIC_STRUCT_RETURN  */\n \n-/* 1 if N is a possible register number for function argument passing. */\n+/* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(N)  ((N) < 12)\n \n@@ -546,7 +546,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    do not preserve any registers; in other words, if `CALL_USED_REGISTERS'\n    has 1 for all registers. This macro enables `-fcaller-saves' by\n    default. Eventually that option will be enabled by default on all\n-   machines and both the option and this macro will be eliminated. */\n+   machines and both the option and this macro will be eliminated.  */\n \n #define DEFAULT_CALLER_SAVES\n \n@@ -624,7 +624,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n /* Addressing modes, and classification of registers for them.  */\n \n-/* 1750 doesn't have a lot of auto-incr./decr. - just for the stack ptr. */\n+/* 1750 doesn't have a lot of auto-incr./decr. - just for the stack ptr.  */\n \n /* #define HAVE_POST_INCREMENT 0 just for R15 (stack pointer) */\n /* #define HAVE_POST_DECREMENT 0 */\n@@ -709,7 +709,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n    1750 note: Currently we don't implement address expressions that use\n    GCC \"Index\"-class regs. To be expanded to handle the 1750 \"Base with Index\"\n-   instructions (see also MAX_REGS_PER_ADDRESS and others). */\n+   instructions (see also MAX_REGS_PER_ADDRESS and others).  */\n \n #define GO_IF_BASED_ADDRESS(X, ADDR) {\t\t\t\t\t\\\n    if ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P(X)))\t\t\t\\\n@@ -736,15 +736,15 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output. */\n+   opportunities to optimize the output.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n    On the 68000, only predecrement and postincrement address depend thus\n    (the amount of decrement or increment being the length of the operand).  */\n-/* 1750: not used. */\n+/* 1750: not used.  */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n \n@@ -757,7 +757,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n    table.\n-   Do not define this if the table should contain absolute addresses. */\n+   Do not define this if the table should contain absolute addresses.  */\n /* #define CASE_VECTOR_PC_RELATIVE 1 */\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n@@ -785,7 +785,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n /* Define if shifts truncate the shift count\n    which implies one can omit a sign-extension or zero-extension\n-   of a shift count. */\n+   of a shift count.  */\n /* #define SHIFT_COUNT_TRUNCATED 1 */\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n@@ -835,7 +835,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n /* Here we define machine-dependent flags and fields in cc_status\n    (see `conditions.h').  */\n-/* MIL-STD-1750: none -- just has the garden variety C,P,Z,N flags. */\n+/* MIL-STD-1750: none -- just has the garden variety C,P,Z,N flags.  */\n \n /* Store in cc_status the expressions\n    that the condition codes will describe\n@@ -891,7 +891,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n             cum_size += datalbl[i].size;\t\t\t\t\\\n \t }\t\t\t\t\t\t\t\t\\\n          fprintf(FILE,\"\\n\\tinit\\n\");\t\t\t\t\t\\\n-         fprintf(FILE,\"\\tlim\\tr0,init_srel\\n\");           /* destin. */\t\\\n+         fprintf(FILE,\"\\tlim\\tr0,init_srel\\n\");           /* destin.  */\t\\\n          fprintf(FILE,\"\\tlim\\tr1,%d\\n\",cum_size);         /* count */\t\\\n          fprintf(FILE,\"\\tlim\\tr2,K%s\\n\",datalbl[0].name); /* source */\t\\\n          fprintf(FILE,\"\\tmov\\tr0,r2\\n\");\t\t\t\t\\\n@@ -967,7 +967,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n  { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \\\n    \"8\", \"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\" }\n \n-/* How to renumber registers for dbx and gdb. */\n+/* How to renumber registers for dbx and gdb.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n@@ -1021,7 +1021,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \t   fprintf (FILE, \"\\tglobal  %s\\t; export\\n\", NAME);\t\\\n   } while (0)\n \n-/* The prefix to add to user-visible assembler symbols. */\n+/* The prefix to add to user-visible assembler symbols.  */\n \n #define USER_LABEL_PREFIX \"\"\n \n@@ -1087,7 +1087,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n   } while(0)\n \n /* This is how to output an assembler line defining a 1750A `double'\n-    constant. */\n+    constant.  */\n \n #define ASM_OUTPUT_THREE_QUARTER_FLOAT(FILE,VALUE)\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n@@ -1174,7 +1174,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n \tfprintf (FILE, \"\\tPOPM R%s,R%s\\n\", reg_names[REGNO], \"FIXME: missing arg\")\n \n-/* This is how to output an element of a case-vector that is absolute. */\n+/* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)   \\\n \tfprintf (FILE, \"\\tdata\\tL%d ;addr_vec_elt\\n\", VALUE)"}]}