{"sha": "f68fc405bb5b38c545498c4a1dba203e51dade32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY4ZmM0MDViYjViMzhjNTQ1NDk4YzRhMWRiYTIwM2U1MWRhZGUzMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-20T10:38:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-20T10:38:41Z"}, "message": "[multiple changes]\n\n2017-01-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Check_Nonoverridable_Aspects); Refine check\n\tfor illegal inherited Implicit_Dereference aspects with renamed\n\tdiscriminants.\n\n2017-01-20  Javier Miranda  <miranda@adacore.com>\n\n\t* debug.adb (switch d.6): do not avoid declaring unreferenced itypes.\n\t* nlists.ads (Lock_Lists, Unlock_Lists): New subprograms.\n\t* nlists.adb (Lock_Lists, Unlock_Lists): New subprograms.\n\t(Set_First, Set_Last, Set_List_Link, Set_Next, Set_Parent,\n\tSet_Prev, Tree_Read): Adding assertion.\n\t* atree.ads (Lock_Nodes, Unlock_Nodes): New subprograms.\n\t* atree.adb (Lock_Nodes, Unlock_Nodes): New subprograms.\n\t(Set_Analyzed, Set_Check_Actuals, Set_Comes_From_Source,\n\tSet_Ekind, Set_Error_Posted, Set_Has_Aspects,\n\tSet_Is_Ignored_Ghost_Node, Set_Original_Node, Set_Paren_Count,\n\tSet_Parent, Set_Sloc, Set_Nkind, Set_FieldNN, Set_NodeNN,\n\tSet_ListNN, Set_ElistNN, Set_NameN, Set_StrN, Set_UintNN,\n\tSet_UrealNN, Set_FlagNNN, Set_NodeN_With_Parent,\n\tSet_ListN_With_Parent): Adding assertion.\n\n2017-01-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Process_Convention): Diagnose properly a pragma\n\timport that applies to several homograph subprograms. when one\n\tof them is declared by a subprogram body.\n\n2017-01-20  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Remove optimization\n\tthat nulls out calls to null procedures.\n\nFrom-SVN: r244699", "tree": {"sha": "57d5fd22e8f8871d01ffd76cb2d29d32468b518e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57d5fd22e8f8871d01ffd76cb2d29d32468b518e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f68fc405bb5b38c545498c4a1dba203e51dade32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f68fc405bb5b38c545498c4a1dba203e51dade32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f68fc405bb5b38c545498c4a1dba203e51dade32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f68fc405bb5b38c545498c4a1dba203e51dade32/comments", "author": null, "committer": null, "parents": [{"sha": "f4ef7b06ce8973846a7002c9325c576e099917d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ef7b06ce8973846a7002c9325c576e099917d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ef7b06ce8973846a7002c9325c576e099917d6"}], "stats": {"total": 694, "additions": 652, "deletions": 42}, "files": [{"sha": "654df038c67d2b70a27622f9065edbea97adc603", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -1,3 +1,37 @@\n+2017-01-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Nonoverridable_Aspects); Refine check\n+\tfor illegal inherited Implicit_Dereference aspects with renamed\n+\tdiscriminants.\n+\n+2017-01-20  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb (switch d.6): do not avoid declaring unreferenced itypes.\n+\t* nlists.ads (Lock_Lists, Unlock_Lists): New subprograms.\n+\t* nlists.adb (Lock_Lists, Unlock_Lists): New subprograms.\n+\t(Set_First, Set_Last, Set_List_Link, Set_Next, Set_Parent,\n+\tSet_Prev, Tree_Read): Adding assertion.\n+\t* atree.ads (Lock_Nodes, Unlock_Nodes): New subprograms.\n+\t* atree.adb (Lock_Nodes, Unlock_Nodes): New subprograms.\n+\t(Set_Analyzed, Set_Check_Actuals, Set_Comes_From_Source,\n+\tSet_Ekind, Set_Error_Posted, Set_Has_Aspects,\n+\tSet_Is_Ignored_Ghost_Node, Set_Original_Node, Set_Paren_Count,\n+\tSet_Parent, Set_Sloc, Set_Nkind, Set_FieldNN, Set_NodeNN,\n+\tSet_ListNN, Set_ElistNN, Set_NameN, Set_StrN, Set_UintNN,\n+\tSet_UrealNN, Set_FlagNNN, Set_NodeN_With_Parent,\n+\tSet_ListN_With_Parent): Adding assertion.\n+\n+2017-01-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Process_Convention): Diagnose properly a pragma\n+\timport that applies to several homograph subprograms. when one\n+\tof them is declared by a subprogram body.\n+\n+2017-01-20  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Remove optimization\n+\tthat nulls out calls to null procedures.\n+\n 2017-01-20  Yannick Moy  <moy@adacore.com>\n \n \t* inline.adb (Expand_Inlined_Call): Keep more"}, {"sha": "29251c226aae926b9c009a8ea338d2df9886b12f", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=f68fc405bb5b38c545498c4a1dba203e51dade32"}, {"sha": "0f3bef7e51d28142bea1724ef7bccafb3b9a0e0d", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -405,9 +405,18 @@ package Atree is\n    --  Called before the back end is invoked to lock the nodes table\n    --  Also called after Unlock to relock???\n \n+   procedure Lock_Nodes;\n+   --  Called to lock node modifications when assertions are enabled; without\n+   --  assertions calling this subprogram has no effect. The initial state of\n+   --  the lock is unlocked.\n+\n    procedure Unlock;\n    --  Unlocks nodes table, in cases where the back end needs to modify it\n \n+   procedure Unlock_Nodes;\n+   --  Called to unlock entity modifications when assertions are enabled; if\n+   --  assertions are not enabled calling this subprogram has no effect.\n+\n    procedure Tree_Read;\n    --  Initializes internal tables from current tree file using the relevant\n    --  Table.Tree_Read routines. Note that Initialize should not be called if"}, {"sha": "218179f5280a229499a2242664e41f584706b9fd", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -160,7 +160,7 @@ package body Debug is\n    --  d.3  Output debugging information from Exp_Unst\n    --  d.4  Do not delete generated C file in case of errors\n    --  d.5  Do not generate imported subprogram definitions in C code\n-   --  d.6\n+   --  d.6  Do not avoid declaring unreferenced itypes in C code\n    --  d.7\n    --  d.8\n    --  d.9\n@@ -777,6 +777,10 @@ package body Debug is\n    --       This debug flag disables this generation when generating C code,\n    --       assuming a proper #include will be used instead.\n \n+   --  d.6  By default the C back-end avoids declaring itypes that are not\n+   --       referenced by the generated C code. This debug flag restores the\n+   --       output of all the itypes.\n+\n    ------------------------------------------\n    -- Documentation for Binder Debug Flags --\n    ------------------------------------------"}, {"sha": "e76927b383c5fa92ea0b7b770cf769b5e227c22d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -3920,16 +3920,13 @@ package body Exp_Ch6 is\n \n       if Ekind_In (Subp, E_Function, E_Procedure) then\n \n-         --  We perform two simple optimization on calls:\n-\n-         --  a) replace calls to null procedures unconditionally;\n-\n-         --  b) for To_Address, just do an unchecked conversion. Not only is\n-         --  this efficient, but it also avoids order of elaboration problems\n-         --  when address clauses are inlined (address expression elaborated\n+         --  We perform a simple optimization on calls for To_Address by\n+         --  replacing them with an unchecked conversion. Not only is this\n+         --  efficient, but it also avoids order of elaboration problems when\n+         --  address clauses are inlined (address expression elaborated at the\n          --  at the wrong point).\n \n-         --  We perform these optimization regardless of whether we are in the\n+         --  We perform this optimization regardless of whether we are in the\n          --  main unit or in a unit in the context of the main unit, to ensure\n          --  that tree generated is the same in both cases, for CodePeer use.\n \n@@ -3938,10 +3935,6 @@ package body Exp_Ch6 is\n               Unchecked_Convert_To\n                 (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));\n             return;\n-\n-         elsif Is_Null_Procedure (Subp) then\n-            Rewrite (Call_Node, Make_Null_Statement (Loc));\n-            return;\n          end if;\n \n          --  Handle inlining. No action needed if the subprogram is not inlined"}, {"sha": "db6a5c88ea1fc12079b91070364eb405313e52b8", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -40,6 +40,10 @@ with Sinfo;  use Sinfo;\n with Table;\n \n package body Nlists is\n+   Locked : Boolean := False;\n+   --  Compiling with assertions enabled, list contents modifications are\n+   --  permitted only when this switch is set to False; compiling without\n+   --  assertions this lock has no effect.\n \n    use Atree_Private_Part;\n    --  Get access to Nodes table\n@@ -727,6 +731,16 @@ package body Nlists is\n       Next_Node.Release;\n    end Lock;\n \n+   ----------------\n+   -- Lock_Lists --\n+   ----------------\n+\n+   procedure Lock_Lists is\n+   begin\n+      pragma Assert (not Locked);\n+      Locked := True;\n+   end Lock_Lists;\n+\n    -------------------\n    -- New_Copy_List --\n    -------------------\n@@ -1403,6 +1417,7 @@ package body Nlists is\n \n    procedure Set_First (List : List_Id; To : Node_Or_Entity_Id) is\n    begin\n+      pragma Assert (not Locked);\n       Lists.Table (List).First := To;\n    end Set_First;\n \n@@ -1412,6 +1427,7 @@ package body Nlists is\n \n    procedure Set_Last (List : List_Id; To : Node_Or_Entity_Id) is\n    begin\n+      pragma Assert (not Locked);\n       Lists.Table (List).Last := To;\n    end Set_Last;\n \n@@ -1421,6 +1437,7 @@ package body Nlists is\n \n    procedure Set_List_Link (Node : Node_Or_Entity_Id; To : List_Id) is\n    begin\n+      pragma Assert (not Locked);\n       Nodes.Table (Node).Link := Union_Id (To);\n    end Set_List_Link;\n \n@@ -1430,6 +1447,7 @@ package body Nlists is\n \n    procedure Set_Next (Node : Node_Or_Entity_Id; To : Node_Or_Entity_Id) is\n    begin\n+      pragma Assert (not Locked);\n       Next_Node.Table (Node) := To;\n    end Set_Next;\n \n@@ -1439,6 +1457,7 @@ package body Nlists is\n \n    procedure Set_Parent (List : List_Id; Node : Node_Or_Entity_Id) is\n    begin\n+      pragma Assert (not Locked);\n       pragma Assert (List <= Lists.Last);\n       Lists.Table (List).Parent := Node;\n    end Set_Parent;\n@@ -1449,6 +1468,7 @@ package body Nlists is\n \n    procedure Set_Prev (Node : Node_Or_Entity_Id; To : Node_Or_Entity_Id) is\n    begin\n+      pragma Assert (not Locked);\n       Prev_Node.Table (Node) := To;\n    end Set_Prev;\n \n@@ -1458,6 +1478,7 @@ package body Nlists is\n \n    procedure Tree_Read is\n    begin\n+      pragma Assert (not Locked);\n       Lists.Tree_Read;\n       Next_Node.Tree_Read;\n       Prev_Node.Tree_Read;\n@@ -1485,4 +1506,14 @@ package body Nlists is\n       Next_Node.Locked := False;\n    end Unlock;\n \n+   ------------------\n+   -- Unlock_Lists --\n+   ------------------\n+\n+   procedure Unlock_Lists is\n+   begin\n+      pragma Assert (Locked);\n+      Locked := False;\n+   end Unlock_Lists;\n+\n end Nlists;"}, {"sha": "de3e28f626078e0bf6c953d1509f6868f4ab5bc2", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -340,9 +340,18 @@ package Nlists is\n    procedure Lock;\n    --  Called to lock tables before back end is called\n \n+   procedure Lock_Lists;\n+   --  Called to lock list contents when assertions are enabled. Without\n+   --  assertions calling this subprogram has no effect. The initial state\n+   --  of the lock is unlocked.\n+\n    procedure Unlock;\n    --  Unlock tables, in cases where the back end needs to modify them\n \n+   procedure Unlock_Lists;\n+   --  Called to unlock list contents when assertions are enabled; if\n+   --  assertions are not enabled calling this subprogram has no effect.\n+\n    procedure Tree_Read;\n    --  Initializes internal tables from current tree file using the relevant\n    --  Table.Tree_Read routines. Note that Initialize should not be called if"}, {"sha": "d8372737584c7012fdf92a094aabc47efee8bd18", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -2781,44 +2781,48 @@ package body Sem_Ch3 is\n       ----------------------------------\n \n       procedure Check_Nonoverridable_Aspects is\n-         Prev_Aspects   : constant List_Id :=\n-                            Aspect_Specifications (Parent (Def_Id));\n-         Par_Type       : Entity_Id;\n-\n-         function Has_Aspect_Spec\n-           (Specs : List_Id;\n-            Aspect_Name : Name_Id) return Boolean;\n+         function Get_Aspect_Spec\n+           (Specs       : List_Id;\n+            Aspect_Name : Name_Id) return Node_Id;\n          --  Check whether a list of aspect specifications includes an entry\n          --  for a specific aspect. The list is either that of a partial or\n          --  a full view.\n \n          ---------------------\n-         -- Has_Aspect_Spec --\n+         -- Get_Aspect_Spec --\n          ---------------------\n \n-         function Has_Aspect_Spec\n-           (Specs : List_Id;\n-            Aspect_Name : Name_Id) return Boolean\n+         function Get_Aspect_Spec\n+           (Specs       : List_Id;\n+            Aspect_Name : Name_Id) return Node_Id\n          is\n             Spec : Node_Id;\n+\n          begin\n             Spec := First (Specs);\n             while Present (Spec) loop\n                if Chars (Identifier (Spec)) = Aspect_Name then\n-                  return True;\n+                  return Spec;\n                end if;\n                Next (Spec);\n             end loop;\n-            return False;\n-         end Has_Aspect_Spec;\n+\n+            return Empty;\n+         end Get_Aspect_Spec;\n+\n+         --  Local variables\n+\n+         Prev_Aspects   : constant List_Id :=\n+                            Aspect_Specifications (Parent (Def_Id));\n+         Par_Type       : Entity_Id;\n+         Prev_Aspect    : Node_Id;\n \n       --  Start of processing for Check_Nonoverridable_Aspects\n \n       begin\n-\n-         --  Get parent type of derived type. Note that Prev is the entity\n-         --  in the partial declaration, but its contents are now those of\n-         --  full view, while Def_Id reflects the partial view.\n+         --  Get parent type of derived type. Note that Prev is the entity in\n+         --  the partial declaration, but its contents are now those of full\n+         --  view, while Def_Id reflects the partial view.\n \n          if Is_Private_Type (Def_Id) then\n             Par_Type := Etype (Full_View (Def_Id));\n@@ -2834,10 +2838,13 @@ package body Sem_Ch3 is\n            and then Present (Discriminant_Specifications (Parent (Prev)))\n            and then Present (Get_Reference_Discriminant (Par_Type))\n          then\n-            if\n-              not Has_Aspect_Spec (Prev_Aspects, Name_Implicit_Dereference)\n-                and then Present\n-                  (Discriminant_Specifications (Original_Node (Parent (Prev))))\n+            Prev_Aspect :=\n+              Get_Aspect_Spec (Prev_Aspects, Name_Implicit_Dereference);\n+\n+            if No (Prev_Aspect)\n+              and then Present\n+                         (Discriminant_Specifications\n+                           (Original_Node (Parent (Prev))))\n             then\n                Error_Msg_N\n                  (\"type does not inherit implicit dereference\", Prev);\n@@ -2847,14 +2854,28 @@ package body Sem_Ch3 is\n                --  is consistent with that of the parent.\n \n                declare\n-                  Par_Discr : constant Entity_Id :=\n+                  Par_Discr  : constant Entity_Id :=\n                                 Get_Reference_Discriminant (Par_Type);\n-                  Cur_Discr : constant Entity_Id :=\n+                  Cur_Discr  : constant Entity_Id :=\n                                 Get_Reference_Discriminant (Prev);\n+\n                begin\n                   if Corresponding_Discriminant (Cur_Discr) /= Par_Discr then\n                      Error_Msg_N (\"aspect incosistent with that of parent\", N);\n                   end if;\n+\n+                  --  Check that specification in partial view matches the\n+                  --  inherited aspect. Compare names directly because aspect\n+                  --  expression may not be analyzed.\n+\n+                  if Present (Prev_Aspect)\n+                    and then Nkind (Expression (Prev_Aspect)) = N_Identifier\n+                    and then Chars (Expression (Prev_Aspect)) /=\n+                               Chars (Cur_Discr)\n+                  then\n+                     Error_Msg_N\n+                       (\"aspect incosistent with that of parent\", N);\n+                  end if;\n                end;\n             end if;\n          end if;\n@@ -9666,9 +9687,8 @@ package body Sem_Ch3 is\n                   null;\n \n                elsif Nkind (Parent (Parent (Def))) = N_Component_Declaration\n-                 and then\n-                   Has_Per_Object_Constraint\n-                     (Defining_Identifier (Parent (Parent (Def))))\n+                 and then Has_Per_Object_Constraint\n+                            (Defining_Identifier (Parent (Parent (Def))))\n                then\n                   null;\n \n@@ -9688,7 +9708,7 @@ package body Sem_Ch3 is\n \n             if Ekind (Etype (Discr)) = E_Anonymous_Access_Type\n               and then not Is_Class_Wide_Type\n-                         (Designated_Type (Etype (Discr)))\n+                             (Designated_Type (Etype (Discr)))\n               and then Etype (Discr_Expr (J)) /= Any_Type\n               and then Is_Class_Wide_Type\n                          (Designated_Type (Etype (Discr_Expr (J))))\n@@ -9702,7 +9722,7 @@ package body Sem_Ch3 is\n             then\n                Error_Msg_NE\n                  (\"constraint for discriminant& must be access to variable\",\n-                    Def, Discr);\n+                  Def, Discr);\n             end if;\n          end if;\n "}, {"sha": "537fb7edd359cefaacc3df4a3e189b03dbd20873", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68fc405bb5b38c545498c4a1dba203e51dade32/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f68fc405bb5b38c545498c4a1dba203e51dade32", "patch": "@@ -7633,6 +7633,17 @@ package body Sem_Prag is\n                   goto Continue;\n                end if;\n \n+               if Is_Subprogram (E1)\n+                 and then Nkind (Parent (Declaration_Node (E1))) =\n+                            N_Subprogram_Body\n+                 and then not Relaxed_RM_Semantics\n+               then\n+                  Set_Has_Completion (E);  --  to prevent cascaded error\n+                  Error_Pragma_Ref\n+                    (\"pragma% requires separate spec and must come before \"\n+                     & \"body#\", E1);\n+               end if;\n+\n                --  Do not set the pragma on inherited operations or on formal\n                --  subprograms.\n "}]}