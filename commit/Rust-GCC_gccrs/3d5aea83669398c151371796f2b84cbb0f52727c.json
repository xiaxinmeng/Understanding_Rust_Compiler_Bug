{"sha": "3d5aea83669398c151371796f2b84cbb0f52727c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q1YWVhODM2NjkzOThjMTUxMzcxNzk2ZjJiODRjYmIwZjUyNzI3Yw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-07-30T20:24:18Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-07-30T20:24:18Z"}, "message": "natIconv.cc (done): New methods.\n\n2001-07-30  Tom Tromey  <tromey@redhat.com>\n\t    Corey Minyard  <minyard@acm.org>\n\n\t* gnu/gcj/convert/natIconv.cc (done): New methods.\n\t* gnu/gcj/convert/Output_iconv.java (done): New method.\n\t* gnu/gcj/convert/Input_iconv.java (done): New method.\n\t* gnu/gcj/convert/UnicodeToBytes.java (defaultEncodingClass):\n\tRemoved.\n\t(getDefaultEncodingClass): Removed.\n\t(getDefaultEncoder): Use getEncoder.\n\t(done): New method.\n\t(defaultEncoding, CACHE_SIZE, encoderCache, currCachePos): New\n\tstatic fields.\n\t* gnu/gcj/convert/BytesToUnicode.java (defaultDecodingClass):\n\tRemoved.\n\t(defaultEncoding, CACHE_SIZE, decoderCache, currCachePos): New\n\tstatic fields.\n\t(getDefaultDecodingClass): Removed.\n\t(getDefaultDecoder): Use getDecoder.\n\t(getDecoder): Look up decoder in cache.\n\t(done): New method.\n\t* java/lang/natString.cc (init): Call `done' on converter.\n\t(getBytes): Likewise.\n\nCo-Authored-By: Corey Minyard <minyard@acm.org>\n\nFrom-SVN: r44484", "tree": {"sha": "4008d0e99166835f26dd98f0224f49ecfaeb2e89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4008d0e99166835f26dd98f0224f49ecfaeb2e89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d5aea83669398c151371796f2b84cbb0f52727c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d5aea83669398c151371796f2b84cbb0f52727c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d5aea83669398c151371796f2b84cbb0f52727c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d5aea83669398c151371796f2b84cbb0f52727c/comments", "author": null, "committer": null, "parents": [{"sha": "a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08b260482d8972aaaa3eb2a0175f9cc175dbad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08b260482d8972aaaa3eb2a0175f9cc175dbad9"}], "stats": {"total": 276, "additions": 207, "deletions": 69}, "files": [{"sha": "a46d06bd016991aa413dac1032f8b19789cd8eee", "filename": "libjava/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -1,3 +1,27 @@\n+2001-07-30  Tom Tromey  <tromey@redhat.com>\n+\t    Corey Minyard  <minyard@acm.org>\n+\n+\t* gnu/gcj/convert/natIconv.cc (done): New methods.\n+\t* gnu/gcj/convert/Output_iconv.java (done): New method.\n+\t* gnu/gcj/convert/Input_iconv.java (done): New method.\n+\t* gnu/gcj/convert/UnicodeToBytes.java (defaultEncodingClass):\n+\tRemoved.\n+\t(getDefaultEncodingClass): Removed.\n+\t(getDefaultEncoder): Use getEncoder.\n+\t(done): New method.\n+\t(defaultEncoding, CACHE_SIZE, encoderCache, currCachePos): New\n+\tstatic fields.\n+\t* gnu/gcj/convert/BytesToUnicode.java (defaultDecodingClass):\n+\tRemoved.\n+\t(defaultEncoding, CACHE_SIZE, decoderCache, currCachePos): New\n+\tstatic fields.\n+\t(getDefaultDecodingClass): Removed.\n+\t(getDefaultDecoder): Use getDecoder.\n+\t(getDecoder): Look up decoder in cache.\n+\t(done): New method.\n+\t* java/lang/natString.cc (init): Call `done' on converter.\n+\t(getBytes): Likewise.\n+\n 2001-07-30  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/Integer.java: Merged with Classpath."}, {"sha": "e7d042baab3a9bb8ba40a8a5ac1d2c35b845d579", "filename": "libjava/gnu/gcj/convert/BytesToUnicode.java", "status": "modified", "additions": 74, "deletions": 32, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FBytesToUnicode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FBytesToUnicode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FBytesToUnicode.java?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -18,55 +18,79 @@ public abstract class BytesToUnicode extends IOConverter\n   /** End of valid bytes in buffer. */\n   public int inlength;\n \n-  static Class defaultDecodingClass;\n+  // The name of the default encoding.\n+  static String defaultEncoding;\n \n-  static synchronized void getDefaultDecodingClass()\n-  {\n-    // Test (defaultDecodingClass == null) again in case of race condition.\n-    if (defaultDecodingClass == null)\n-      {\n-\tString encoding = canonicalize (System.getProperty(\"file.encoding\"));\n-\tString className = \"gnu.gcj.convert.Input_\"+encoding;\n-\ttry\n-\t  {\n-\t    defaultDecodingClass = Class.forName(className);\n-\t  }\n-\tcatch (ClassNotFoundException ex)\n-\t  {\n-\t    throw new NoClassDefFoundError(\"missing default encoding \"\n-\t\t\t\t\t   + encoding + \" (class \"\n-\t\t\t\t\t   + className + \" not found)\");\n-\t  }\n-      }\n-  }\n+  /* These keep a small cache of decoders for reuse.  The array holds\n+     the actual decoders.  The currCachePos is the next value we are\n+     going to replace in the cache.  We don't just throw the data away\n+     if the cache is full, because if the cache filled up with stuff\n+     we don't need then the cache would be worthless.  We instead\n+     circulate through the cache the implement kind of an LRU\n+     algorithm. */\n+  private static final int CACHE_SIZE = 4;  // A power of 2 for speed\n+  private static BytesToUnicode[] decoderCache\n+    = new BytesToUnicode[CACHE_SIZE];\n+  private static int currCachePos = 0;\n \n   public abstract String getName();\n \n   public static BytesToUnicode getDefaultDecoder()\n   {\n     try\n       {\n-\tif (defaultDecodingClass == null)\n-\t  getDefaultDecodingClass();\n-\treturn (BytesToUnicode) defaultDecodingClass.newInstance();\n+\tsynchronized (BytesToUnicode.class)\n+\t  {\n+\t    if (defaultEncoding == null)\n+\t      {\n+\t\tString encoding\n+\t\t  = canonicalize (System.getProperty(\"file.encoding\",\n+\t\t\t\t\t\t     \"8859_1\"));\n+\t\tString className = \"gnu.gcj.convert.Input_\" + encoding;\n+\t\ttry\n+\t\t  {\n+\t\t    Class defaultDecodingClass = Class.forName(className);\n+\t\t    defaultEncoding = encoding;\n+\t\t  }\n+\t\tcatch (ClassNotFoundException ex)\n+\t\t  {\n+\t\t    throw new NoClassDefFoundError(\"missing default encoding \"\n+\t\t\t\t\t\t   + encoding + \" (class \"\n+\t\t\t\t\t\t   + className\n+\t\t\t\t\t\t   + \" not found)\");\n+\t\t  }\n+\t      }\n+\t  }\n+\treturn getDecoder (defaultEncoding);\n       }\n     catch (Throwable ex)\n       {\n-\ttry\n-\t  {\n-\t    return new Input_iconv (System.getProperty (\"file.encoding\"));\n-\t  }\n-\tcatch (Throwable ex2)\n-\t  {\n-\t    return new Input_8859_1();\n-\t  }\n+\treturn new Input_8859_1();\n       }\n   }\n \n   /** Get a byte-stream->char-stream converter given an encoding name. */\n   public static BytesToUnicode getDecoder (String encoding)\n     throws java.io.UnsupportedEncodingException\n   {\n+    /* First hunt in our cache to see if we have a decoder that is\n+       already allocated. */\n+    synchronized (BytesToUnicode.class)\n+      {\n+\tint i;\n+\tfor (i = 0; i < decoderCache.length; ++i)\n+\t  {\n+\t    if (decoderCache[i] != null\n+\t\t&& encoding.equals(decoderCache[i].getName ()))\n+\t      {\n+\t\tBytesToUnicode rv = decoderCache[i];\n+\t\tdecoderCache[i] = null;\n+\t\treturn rv;\n+\t    }\n+\t  }\n+      }\n+\n+    // It's not in the cache, so now we have to do real work.\n     String className = \"gnu.gcj.convert.Input_\" + canonicalize (encoding);\n     Class decodingClass;\n     try \n@@ -120,4 +144,22 @@ public final void setInput(byte[] buffer, int pos, int length)\n    * of the length parameter for a read request).\n    */\n   public abstract int read (char[] outbuffer, int outpos, int count);\n+\n+  /** Indicate that the converter is resuable.\n+   * This class keeps track of converters on a per-encoding basis.\n+   * When done with an encoder you may call this method to indicate\n+   * that it can be reused later.\n+   */\n+  public void done ()\n+  {\n+    synchronized (BytesToUnicode.class)\n+      {\n+\tthis.inbuffer = null;\n+\tthis.inpos = 0;\n+\tthis.inlength = 0;\n+\n+\tdecoderCache[currCachePos] = this;\n+\tcurrCachePos = (currCachePos + 1) % CACHE_SIZE;\n+      }\n+  }\n }"}, {"sha": "a87878eb0cbc267003b6d356bde975854b40f250", "filename": "libjava/gnu/gcj/convert/Input_iconv.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_iconv.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_iconv.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FInput_iconv.java?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -1,6 +1,6 @@\n // Input_iconv.java -- Java side of iconv() reader.\n \n-/* Copyright (C) 2000  Free Software Foundation\n+/* Copyright (C) 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -33,6 +33,7 @@ public Input_iconv (String encoding) throws UnsupportedEncodingException\n   private native void init (String encoding)\n     throws UnsupportedEncodingException;\n   public native int read (char[] outbuffer, int outpos, int count);\n+  public native void done ();\n \n   // The encoding we're using.\n   private String encoding;"}, {"sha": "aa071c00eea6e155ca361bc12af77f4b2bc1f77d", "filename": "libjava/gnu/gcj/convert/Output_iconv.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_iconv.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_iconv.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FOutput_iconv.java?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -1,6 +1,6 @@\n // Output_iconv.java -- Java side of iconv() writer.\n \n-/* Copyright (C) 2000  Free Software Foundation\n+/* Copyright (C) 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -33,6 +33,7 @@ public Output_iconv (String encoding) throws UnsupportedEncodingException\n   private native void init (String encoding)\n     throws UnsupportedEncodingException;\n   public native int write (char[] inbuffer, int inpos, int count);\n+  public native void done ();\n \n   // The encoding we're using.\n   private String encoding;"}, {"sha": "858be11f6747bb37f9eb5812b7606daf01c248bb", "filename": "libjava/gnu/gcj/convert/UnicodeToBytes.java", "status": "modified", "additions": 74, "deletions": 34, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FUnicodeToBytes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FUnicodeToBytes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FUnicodeToBytes.java?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -7,64 +7,87 @@\n details.  */\n \n package gnu.gcj.convert; \n- \n+\n public abstract class UnicodeToBytes extends IOConverter\n {\n   /** Buffer to emit bytes to.\n    * The locations buf[count] ... buf[buf.length-1] are available. */\n   public byte[] buf;\n   public int count;\n \n-  static Class defaultEncodingClass;\n+  // The name of the default encoding.\n+  static String defaultEncoding;\n \n-  static synchronized void getDefaultEncodingClass()\n-  {\n-    // Test (defaultEncodingClass == null) again in case of race condition.\n-    if (defaultEncodingClass == null)\n-      {\n-\tString encoding = canonicalize (System.getProperty(\"file.encoding\"));\n-\tString className = \"gnu.gcj.convert.Output_\"+encoding;\n-\ttry\n-\t  {\n-\t    defaultEncodingClass = Class.forName(className);\n-\t  }\n-\tcatch (ClassNotFoundException ex)\n-\t  {\n-\t    throw new NoClassDefFoundError(\"missing default encoding \"\n-\t\t\t\t\t   + encoding + \" (class \"\n-\t\t\t\t\t   + className + \" not found)\");\n-\t    \n-\t  }\n-      }\n-  }\n+  /* These keep a small cache of encoders for reuse.  The array holds\n+     the actual encoders.  The currCachePos is the next value we are\n+     going to replace in the cache.  We don't just throw the data away\n+     if the cache is full, because if the cache filled up with stuff we\n+     don't need then the cache would be worthless.  We instead\n+     circulate through the cache the implement kind of an LRU\n+     algorithm. */\n+  private static final int CACHE_SIZE = 4;  // A power of 2 for speed\n+  private static UnicodeToBytes[] encoderCache\n+    = new UnicodeToBytes[CACHE_SIZE];\n+  private static int currCachePos = 0;\n \n   public abstract String getName();\n \n   public static UnicodeToBytes getDefaultEncoder()\n   {\n     try\n       {\n-\tif (defaultEncodingClass == null)\n-\t  getDefaultEncodingClass();\n-\treturn (UnicodeToBytes) defaultEncodingClass.newInstance();\n+\tsynchronized (UnicodeToBytes.class)\n+\t  {\n+\t    if (defaultEncoding == null)\n+\t      {\n+\t\tString encoding\n+\t\t  = canonicalize (System.getProperty(\"file.encoding\",\n+\t\t\t\t\t\t     \"8859_1\"));\n+\t\tString className = \"gnu.gcj.convert.Output_\" + encoding;\n+\t\ttry\n+\t\t  {\n+\t\t    Class defaultEncodingClass = Class.forName(className);\n+\t\t    defaultEncoding = encoding;\n+\t\t  }\n+\t\tcatch (ClassNotFoundException ex)\n+\t\t  {\n+\t\t    throw new NoClassDefFoundError(\"missing default encoding \"\n+\t\t\t\t\t\t   + encoding + \" (class \"\n+\t\t\t\t\t\t   + className\n+\t\t\t\t\t\t   + \" not found)\");\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\treturn getEncoder (defaultEncoding);\n       }\n     catch (Throwable ex)\n       {\n-\ttry\n-\t  {\n-\t    return new Output_iconv (System.getProperty (\"file.encoding\"));\n-\t  }\n-\tcatch (Throwable ex2)\n-\t  {\n-\t    return new Output_8859_1();\n-\t  }\n+\treturn new Output_8859_1();\n       }\n   }\n \n   /** Get a char-stream->byte-stream converter given an encoding name. */\n   public static UnicodeToBytes getEncoder (String encoding)\n     throws java.io.UnsupportedEncodingException\n   {\n+    /* First hunt in our cache to see if we have a encoder that is\n+       already allocated. */\n+    synchronized (UnicodeToBytes.class)\n+      {\n+\tint i;\n+\tfor (i = 0; i < encoderCache.length; ++i)\n+\t  {\n+\t    if (encoderCache[i] != null\n+\t\t&& encoding.equals(encoderCache[i].getName ()))\n+\t      {\n+\t\tUnicodeToBytes rv = encoderCache[i];\n+\t\tencoderCache[i] = null;\n+\t\treturn rv;\n+\t    }\n+\t  }\n+      }\n+\n     String className = \"gnu.gcj.convert.Output_\" + canonicalize (encoding);\n     Class encodingClass;\n     try \n@@ -122,4 +145,21 @@ public int write (String str, int inpos, int inlength, char[] work)\n     str.getChars(inpos, srcEnd, work, 0);\n     return write(work, inpos, inlength);\n   }\n+\n+  /** Indicate that the converter is resuable.\n+   * This class keeps track of converters on a per-encoding basis.\n+   * When done with an encoder you may call this method to indicate\n+   * that it can be reused later.\n+   */\n+  public void done ()\n+  {\n+    synchronized (UnicodeToBytes.class)\n+      {\n+\tthis.buf = null;\n+\tthis.count = 0;\n+\n+\tencoderCache[currCachePos] = this;\n+\tcurrCachePos = (currCachePos + 1) % CACHE_SIZE;\n+      }\n+  }\n }"}, {"sha": "1eb869dd0f19f06b82f3e0b012728966f125311f", "filename": "libjava/gnu/gcj/convert/natIconv.cc", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatIconv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatIconv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fconvert%2FnatIconv.cc?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -91,7 +91,7 @@ gnu::gcj::convert::Input_iconv::read (jcharArray outbuffer,\n   if (r == (size_t) -1)\n     {\n       // Incomplete character.\n-      if (errno == EINVAL)\n+      if (errno == EINVAL || errno == E2BIG)\n \treturn 0;\n       throw new java::io::CharConversionException ();\n     }\n@@ -115,6 +115,20 @@ gnu::gcj::convert::Input_iconv::read (jcharArray outbuffer,\n #endif /* HAVE_ICONV */\n }\n \n+void\n+gnu::gcj::convert::Input_iconv::done ()\n+{\n+  // 50 bytes should be enough for any reset sequence.\n+  size_t avail = 50;\n+  char tmp[avail];\n+  char *p = tmp;\n+  // Calling iconv() with a NULL INBUF pointer will cause iconv() to\n+  // switch to its initial state.  We don't care about the output that\n+  // might be generated in that situation.\n+  iconv_adapter (iconv, (iconv_t) handle, NULL, NULL, &p, &avail);\n+  BytesToUnicode::done ();\n+}\n+\n void\n gnu::gcj::convert::Output_iconv::init (jstring encoding)\n {\n@@ -251,3 +265,17 @@ gnu::gcj::convert::IOConverter::iconv_init (void)\n #endif /* HAVE_ICONV */\n   return result;\n }\n+\n+void\n+gnu::gcj::convert::Output_iconv::done ()\n+{\n+  // 50 bytes should be enough for any reset sequence.\n+  size_t avail = 50;\n+  char tmp[avail];\n+  char *p = tmp;\n+  // Calling iconv() with a NULL INBUF pointer will cause iconv() to\n+  // switch to its initial state.  We don't care about the output that\n+  // might be generated in that situation.\n+  iconv_adapter (iconv, (iconv_t) handle, NULL, NULL, &p, &avail);\n+  UnicodeToBytes::done ();\n+}"}, {"sha": "ee31ba5bf417d33b218774da915db3ea0d90dab3", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d5aea83669398c151371796f2b84cbb0f52727c/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=3d5aea83669398c151371796f2b84cbb0f52727c", "patch": "@@ -523,6 +523,7 @@ java::lang::String::init (jbyteArray bytes, jint offset, jint count,\n \t  avail -= done;\n \t}\n     }\n+  converter->done ();\n   this->data = array;\n   this->boffset = (char *) elements (array) - (char *) array;\n   this->count = outpos;\n@@ -604,6 +605,7 @@ java::lang::String::getBytes (jstring enc)\n \t  todo -= converted;\n \t}\n     }\n+  converter->done ();\n   if (bufpos == buflen)\n     return buffer;\n   jbyteArray result = JvNewByteArray(bufpos);"}]}