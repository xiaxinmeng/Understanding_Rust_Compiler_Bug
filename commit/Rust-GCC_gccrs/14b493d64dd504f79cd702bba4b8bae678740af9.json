{"sha": "14b493d64dd504f79cd702bba4b8bae678740af9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiNDkzZDY0ZGQ1MDRmNzljZDcwMmJiYTRiOGJhZTY3ODc0MGFmOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-12-24T08:30:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-12-24T08:30:34Z"}, "message": "regmove.c: Fix comment typos.\n\n\t* regmove.c: Fix comment typos.\n\t* reload.c: Likewise.\n\t* reload1.c: Likewise.\n\t* resource.c: Likewise.\n\t* rtl.def: Likewise.\n\t* rtl.h: Likewise.\n\t* rtlanal.c: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* sibcall.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* ssa-ccp.c: Likewise.\n\t* ssa.c: Likewise.\n\t* stmt.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* system.h: Likewise.\n\t* tlink.c: Likewise.\n\t* toplev.c: Likewise.\n\t* tracer.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree.c: Likewise.\n\t* tree.h: Likewise.\n\t* unroll.c: Likewise.\n\t* varasm.c: Likewise.\n\nFrom-SVN: r60473", "tree": {"sha": "f527a7be9da17e50c26bf10cb61c24606588c777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f527a7be9da17e50c26bf10cb61c24606588c777"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14b493d64dd504f79cd702bba4b8bae678740af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b493d64dd504f79cd702bba4b8bae678740af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14b493d64dd504f79cd702bba4b8bae678740af9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b493d64dd504f79cd702bba4b8bae678740af9/comments", "author": null, "committer": null, "parents": [{"sha": "02aef83470d501c4fd44035ebc41f6b9449e3288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02aef83470d501c4fd44035ebc41f6b9449e3288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02aef83470d501c4fd44035ebc41f6b9449e3288"}], "stats": {"total": 133, "additions": 80, "deletions": 53}, "files": [{"sha": "388076dfa28196e1eee231d3c847530c18b6bbfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1,3 +1,30 @@\n+2002-12-24  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* regmove.c: Fix comment typos.\n+\t* reload.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* rtl.def: Likewise.\n+\t* rtl.h: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* sibcall.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* ssa-ccp.c: Likewise.\n+\t* ssa.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* system.h: Likewise.\n+\t* tlink.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tracer.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.h: Likewise.\n+\t* unroll.c: Likewise.\n+\t* varasm.c: Likewise.\n+\n 2002-12-23  Larin Hennessy  <larin@science.oregonstate.edu>\n \n \t* doc/install.texi: Remove i386-*-isc, i860-*-bsd,"}, {"sha": "653d1587c84bed913daea3b506985564ebdaccb4", "filename": "gcc/regmove.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -686,7 +686,7 @@ optimize_reg_copy_3 (insn, dest, src)\n       || SET_DEST (set) != src_reg)\n     return;\n \n-  /* Be conserative: although this optimization is also valid for\n+  /* Be conservative: although this optimization is also valid for\n      volatile memory references, that could cause trouble in later passes.  */\n   if (MEM_VOLATILE_P (SET_SRC (set)))\n     return;\n@@ -925,7 +925,7 @@ reg_is_remote_constant_p (reg, insn, first)\n      (set (reg100) (plus reg100 offset2-offset1))  */\n \n /* ??? What does this comment mean?  */\n-/* cse disrupts preincrement / postdecrement squences when it finds a\n+/* cse disrupts preincrement / postdecrement sequences when it finds a\n    hard register as ultimate source, like the frame pointer.  */\n \n static int\n@@ -1072,7 +1072,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n     return;\n \n   /* Find out where a potential flags register is live, and so that we\n-     can supress some optimizations in those zones.  */\n+     can suppress some optimizations in those zones.  */\n   mark_flags_life_zones (discover_flags_reg ());\n \n   regno_src_regno = (int *) xmalloc (sizeof *regno_src_regno * nregs);\n@@ -1339,7 +1339,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t     it produces worse code, as it eliminates no copy\n \t\t     instructions and the copy emitted will be produced by\n \t\t     reload anyway.  On patterns with multiple alternatives,\n-\t\t     there may be better sollution availble.\n+\t\t     there may be better solution available.\n \n \t\t     In particular this change produced slower code for numeric\n \t\t     i387 programs.  */\n@@ -1499,7 +1499,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t    }\n \n \t  /* If we weren't able to replace any of the alternatives, try an\n-\t     alternative appoach of copying the source to the destination.  */\n+\t     alternative approach of copying the source to the destination.  */\n \t  if (!success && copy_src != NULL_RTX)\n \t    copy_src_to_dest (insn, copy_src, copy_dst, old_max_uid);\n \n@@ -2315,7 +2315,7 @@ record_stack_memrefs (xp, data)\n \n \t We can't just compare with STACK_POINTER_RTX because the\n \t reference to the stack pointer might be in some other mode.\n-\t In particular, an explict clobber in an asm statement will\n+\t In particular, an explicit clobber in an asm statement will\n \t result in a QImode clober.  */\n       if (REGNO (x) == STACK_POINTER_REGNUM)\n \treturn 1;\n@@ -2374,7 +2374,7 @@ combine_stack_adjustments_for_block (bb)\n \t\t adjustment is now too large for a constant addition,\n \t\t we cannot merge the two stack adjustments.\n \n-\t\t Also we need to be carefull to not move stack pointer\n+\t\t Also we need to be careful to not move stack pointer\n \t\t such that we create stack accesses outside the allocated\n \t\t area.  We can combine an allocation into the first insn,\n \t\t or a deallocation into the second insn.  We can not"}, {"sha": "e61c3b12f8ef999f05a0eab2df4fd18ce9747bcc", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -2898,7 +2898,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t     by forcing the reload.\n \n \t\t     ??? When is it right at this stage to have a subreg\n-\t\t     of a mem that is _not_ to be handled specialy?  IMO\n+\t\t     of a mem that is _not_ to be handled specially?  IMO\n \t\t     those should have been reduced to just a mem.  */\n \t\t  || ((GET_CODE (operand) == MEM\n \t\t       || (GET_CODE (operand)== REG"}, {"sha": "aeb740ef91f3727dba1f88183c980b786f8ce411", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -7689,7 +7689,7 @@ delete_output_reload (insn, j, last_reload_reg)\n \n   /* The caller has already checked that REG dies or is set in INSN.\n      It has also checked that we are optimizing, and thus some\n-     inaccurancies in the debugging information are acceptable.\n+     inaccuracies in the debugging information are acceptable.\n      So we could just delete output_reload_insn.  But in some cases\n      we can improve the debugging information without sacrificing\n      optimization - maybe even improving the code: See if the pseudo\n@@ -7891,7 +7891,7 @@ delete_address_reloads_1 (dead_insn, x, current_insn)\n \t\t  return;\n \t      /* ??? We can't finish the loop here, because dst might be\n \t\t allocated to a pseudo in this block if no reload in this\n-\t\t block needs any of the clsses containing DST - see\n+\t\t block needs any of the classes containing DST - see\n \t\t spill_hard_reg.  There is no easy way to tell this, so we\n \t\t have to scan till the end of the basic block.  */\n \t    }\n@@ -8530,7 +8530,7 @@ reload_cse_simplify_operands (insn, testreg)\n \f\n /* If reload couldn't use reg+reg+offset addressing, try to use reg+reg\n    addressing now.\n-   This code might also be useful when reload gave up on reg+reg addresssing\n+   This code might also be useful when reload gave up on reg+reg addressing\n    because of clashes between the return register and INDEX_REG_CLASS.  */\n \n /* The maximum number of uses of a register we can keep track of to\n@@ -8551,7 +8551,7 @@ struct reg_use { rtx insn, *usep; };\n    last, of these uses.\n    STORE_RUID is always meaningful if we only want to use a value in a\n    register in a different place: it denotes the next insn in the insn\n-   stream (i.e. the last ecountered) that sets or clobbers the register.  */\n+   stream (i.e. the last encountered) that sets or clobbers the register.  */\n static struct\n   {\n     struct reg_use reg_use[RELOAD_COMBINE_MAX_USES];\n@@ -9054,7 +9054,7 @@ static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n \n-/* move2add_luid is linearily increased while scanning the instructions\n+/* move2add_luid is linearly increased while scanning the instructions\n    from first to last.  It is used to set reg_set_luid in\n    reload_cse_move2add and move2add_note_store.  */\n static int move2add_luid;\n@@ -9499,7 +9499,7 @@ fixup_abnormal_edges ()\n \t\t     If it's placed after a trapping call (i.e. that\n \t\t     call is the last insn anyway), we have no fallthru\n \t\t     edge.  Simply delete this use and don't try to insert\n-\t\t     on the non-existant edge.  */\n+\t\t     on the non-existent edge.  */\n \t\t  if (GET_CODE (PATTERN (insn)) != USE)\n \t\t    {\n \t\t      /* We're not deleting it, we're moving it.  */"}, {"sha": "f5424602f74fc1c1e2dd163de1f7538a72971794", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1245,7 +1245,7 @@ init_resource_info (epilogue_insn)\n   bb_ticks = (int *) xcalloc (last_basic_block, sizeof (int));\n }\n \f\n-/* Free up the resources allcated to mark_target_live_regs ().  This\n+/* Free up the resources allocated to mark_target_live_regs ().  This\n    should be invoked after the last call to mark_target_live_regs ().  */\n \n void"}, {"sha": "6341386474210732422ec9e1986451730db79629", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -960,7 +960,7 @@ DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", '<')\n DEF_RTL_EXPR(LEU, \"leu\", \"ee\", '<')\n DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", '<')\n \n-/* Additional floating point unordered comparision flavors.  */\n+/* Additional floating point unordered comparison flavors.  */\n DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", '<')\n DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", '<')\n "}, {"sha": "c873d9f6bd2055d002bd56cd0cd11d4211963824", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1838,7 +1838,7 @@ extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n #define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n \n /* This points to the Canonical Frame Address of the function.  This\n-   should corrospond to the CFA produced by INCOMING_FRAME_SP_OFFSET,\n+   should correspond to the CFA produced by INCOMING_FRAME_SP_OFFSET,\n    but is calculated relative to the arg pointer for simplicity; the\n    frame pointer nor stack pointer are necessarily fixed relative to\n    the CFA until after reload.  */"}, {"sha": "2aad022fc2673ea3395642a50c6d559738eda062", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -3336,7 +3336,7 @@ find_first_parameter_load (call_insn, boundary)\n   return before;\n }\n \n-/* Return true if we should avoid inserting code between INSN and preceeding\n+/* Return true if we should avoid inserting code between INSN and preceding\n    call instruction.  */\n \n bool\n@@ -3479,7 +3479,7 @@ can_hoist_insn_p (insn, val, live)\n \t    case USE:\n \t      /* We need to fix callers to really ensure availability\n \t         of all values inisn uses, but for now it is safe to prohibit\n-\t\t hoisting of any insn having such a hiden uses.  */\n+\t\t hoisting of any insn having such a hidden uses.  */\n \t      return false;\n \t      break;\n \t    case CLOBBER:"}, {"sha": "ec3df2c1596494ad1d8fd4705346c95e1bc8e769", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1533,7 +1533,7 @@ free_deps (deps)\n }\n \n /* If it is profitable to use them, initialize caches for tracking\n-   dependency informatino.  LUID is the number of insns to be scheduled,\n+   dependency information.  LUID is the number of insns to be scheduled,\n    it is used in the estimate of profitability.  */\n \n void"}, {"sha": "43fdef72cd8a192759c29081db3039a7b4d53dd7", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -276,7 +276,7 @@ static void compute_dom_prob_ps PARAMS ((int));\n #define INSN_BB(INSN) (BLOCK_TO_BB (BLOCK_NUM (INSN)))\n \n /* Parameters affecting the decision of rank_for_schedule().\n-   ??? Nope.  But MIN_PROBABILITY is used in copmute_trg_info.  */\n+   ??? Nope.  But MIN_PROBABILITY is used in compute_trg_info.  */\n #define MIN_PROBABILITY 40\n \n /* Speculative scheduling functions.  */\n@@ -802,7 +802,7 @@ find_rgns (edge_list, dom)\n       if (no_loops)\n \tSET_BIT (header, 0);\n \n-      /* Second travsersal:find reducible inner loops and topologically sort\n+      /* Second traversal:find reducible inner loops and topologically sort\n \t block of each region.  */\n \n       queue = (int *) xmalloc (n_basic_blocks * sizeof (int));\n@@ -1291,7 +1291,7 @@ debug_candidates (trg)\n     debug_candidate (i);\n }\n \n-/* Functions for speculative scheduing.  */\n+/* Functions for speculative scheduling.  */\n \n /* Return 0 if x is a set of a register alive in the beginning of one\n    of the split-blocks of src, otherwise return 1.  */\n@@ -2531,7 +2531,7 @@ propagate_deps (bb, pred_deps)\n /* Compute backward dependences inside bb.  In a multiple blocks region:\n    (1) a bb is analyzed after its predecessors, and (2) the lists in\n    effect at the end of bb (after analyzing for bb) are inherited by\n-   bb's successrs.\n+   bb's successors.\n \n    Specifically for reg-reg data dependences, the block insns are\n    scanned by sched_analyze () top-to-bottom.  Two lists are\n@@ -2712,7 +2712,7 @@ schedule_region (rgn)\n \n   init_deps_global ();\n \n-  /* Initializations for region data dependence analyisis.  */\n+  /* Initializations for region data dependence analysis.  */\n   bb_deps = (struct deps *) xmalloc (sizeof (struct deps) * current_nr_blocks);\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     init_deps (bb_deps + bb);"}, {"sha": "bfad98adac3bb9e5e4bbcb0d69c64e132bc69c95", "filename": "gcc/sibcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -693,7 +693,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \t      || current_function_calls_setjmp\n \t      /* Can't if more than one successor or single successor is not\n \t\t exit block.  These two tests prevent tail call optimization\n-\t\t in the presense of active exception handlers.  */\n+\t\t in the presence of active exception handlers.  */\n \t      || call_block->succ == NULL\n \t      || call_block->succ->succ_next != NULL\n \t      || (call_block->succ->dest != EXIT_BLOCK_PTR"}, {"sha": "1949f24f1a375a9a4f5ecca6a12eb3b4e21705f9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -2434,7 +2434,7 @@ simplify_subreg (outermode, op, innermode, byte)\n \t  if (GET_CODE (op) == CONST_INT)\n \t    val = INTVAL (op);\n \n-\t  /* We don't handle synthetizing of non-integral constants yet.  */\n+\t  /* We don't handle synthesizing of non-integral constants yet.  */\n \t  if (GET_MODE_CLASS (outermode) != MODE_INT)\n \t    return NULL_RTX;\n \n@@ -2571,7 +2571,7 @@ simplify_subreg (outermode, op, innermode, byte)\n \t  rtx x = gen_rtx_REG (outermode, final_regno);\n \n \t  /* Propagate original regno.  We don't have any way to specify\n-\t     the offset inside orignal regno, so do so only for lowpart.\n+\t     the offset inside original regno, so do so only for lowpart.\n \t     The information is used only by alias analysis that can not\n \t     grog partial register anyway.  */\n \n@@ -2656,7 +2656,7 @@ simplify_gen_subreg (outermode, op, innermode, byte)\n    This is the preferred entry point into the simplification routines;\n    however, we still allow passes to call the more specific routines.\n \n-   Right now GCC has three (yes, three) major bodies of RTL simplficiation\n+   Right now GCC has three (yes, three) major bodies of RTL simplification\n    code that need to be unified.\n \n \t1. fold_rtx in cse.c.  This code uses various CSE specific"}, {"sha": "085f18f27f8335636015bd063b93a9faf27b546c", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -815,7 +815,7 @@ optimize_unexecutable_edges (edges, executable_edges)\n \t  && bb->succ && bb->succ->succ_next == NULL)\n \t{\n \t  /* If the fallthru edge is the executable edge, then turn\n-\t     this jump into a nop jump, otherwise make it an unconditinoal\n+\t     this jump into a nop jump, otherwise make it an unconditional\n \t     jump to its target.  */\n \t  if (edge->flags & EDGE_FALLTHRU)\n \t    {"}, {"sha": "0a640ef53722ba6bddabe35466c42af98062a58e", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1828,7 +1828,7 @@ struct phi_coalesce_context\n \n /* Callback function for for_each_successor_phi.  If the set\n    destination and the phi alternative regs do not conflict, place\n-   them in the same paritition class.  DATA is a pointer to a\n+   them in the same partition class.  DATA is a pointer to a\n    phi_coalesce_context struct.  */\n \n static int"}, {"sha": "fbdf463ee5715391a93ee0b9f3be130b9682b0a9", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1122,7 +1122,7 @@ expand_asm (body)\n    will be true if the operand is read-write, i.e., if it is used as\n    an input as well as an output.  If *CONSTRAINT_P is not in\n    canonical form, it will be made canonical.  (Note that `+' will be\n-   rpelaced with `=' as part of this process.)\n+   replaced with `=' as part of this process.)\n \n    Returns TRUE if all went well; FALSE if an error occurred.  */\n \n@@ -2597,7 +2597,7 @@ expand_end_loop ()\n \tend_label:\n \n      We rely on the presence of NOTE_INSN_LOOP_END_TOP_COND to mark\n-     the end of the entry condtional.  Without this, our lexical scan\n+     the end of the entry conditional.  Without this, our lexical scan\n      can't tell the difference between an entry conditional and a\n      body conditional that exits the loop.  Mistaking the two means\n      that we can misplace the NOTE_INSN_LOOP_CONT note, which can"}, {"sha": "70eecc07a1c7023187383e1525ddbe4691450369", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1001,10 +1001,10 @@ place_field (rli, field)\n \tused in the record, and any additional adjacent long bitfields are\n \tpacked into the same chunk of 32 bits. However, if the size\n \tchanges, a new field of that size is allocated.)  In an unpacked\n-\trecord, this is the same as using alignment, but not eqivalent\n+\trecord, this is the same as using alignment, but not equivalent\n \twhen packing.\n \n-     Note: for compatability, we use the type size, not the type alignment\n+     Note: for compatibility, we use the type size, not the type alignment\n      to determine alignment, since that matches the documentation */\n \n   if ((* targetm.ms_bitfield_layout_p) (rli->t)\n@@ -1103,7 +1103,7 @@ place_field (rli, field)\n \t              TYPE_SIZE (TREE_TYPE (prev_saved)))\n \t       : !integer_zerop (DECL_SIZE (field)) ))\n \t{\n-\t  unsigned int type_align = 8;  /* Never below 8 for compatability */\n+\t  unsigned int type_align = 8;  /* Never below 8 for compatibility */\n \n \t  /* (When not a bitfield), we could be seeing a flex array (with\n \t     no DECL_SIZE).  Since we won't be using remaining_in_alignment\n@@ -1197,7 +1197,7 @@ place_field (rli, field)\n \n /* Assuming that all the fields have been laid out, this function uses\n    RLI to compute the final TYPE_SIZE, TYPE_ALIGN, etc. for the type\n-   inidicated by RLI.  */\n+   indicated by RLI.  */\n \n static void\n finalize_record_size (rli)"}, {"sha": "0d8106df09b145c4528c9835b4e282c90d51a609", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -470,7 +470,7 @@ extern void abort PARAMS ((void));\n \n /* Say how to test for an absolute pathname.  On Unix systems, this is if\n    it starts with a leading slash or a '$', the latter meaning the value of\n-   an environment variable is to be used.  On machien with DOS-based\n+   an environment variable is to be used.  On machine with DOS-based\n    file systems, it is also absolute if it starts with a drive identifier.  */\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n #define IS_ABSOLUTE_PATHNAME(STR) \\"}, {"sha": "706bd6e65bd87d5d7088eed1fd8152576be84442", "filename": "gcc/tlink.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -343,7 +343,7 @@ pfgets (stream)\n \n /* Subroutine of read_repo_file.  We are reading the repo file for file F,\n    which is coming in on STREAM, and the symbol that comes next in STREAM\n-   is offerred, chosen or provided if CHOSEN is 0, 1 or 2, respectively.\n+   is offered, chosen or provided if CHOSEN is 0, 1 or 2, respectively.\n \n    XXX \"provided\" is unimplemented, both here and in the compiler.  */\n "}, {"sha": "ccc061fc74031b9c7c3191a23129f1f760a7883f", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -750,7 +750,7 @@ int flag_schedule_insns_after_reload = 0;\n /* The following flags have effect only for scheduling before register\n    allocation:\n \n-   flag_schedule_interblock means schedule insns accross basic blocks.\n+   flag_schedule_interblock means schedule insns across basic blocks.\n    flag_schedule_speculative means allow speculative motion of non-load insns.\n    flag_schedule_speculative_load means allow speculative motion of some\n    load insns.\n@@ -2973,11 +2973,11 @@ rest_of_compilation (decl)\n \t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n   /* It may make more sense to mark constant functions after dead code is\n-     eliminated by life_analyzis, but we need to do it early, as -fprofile-arcs\n+     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n      may insert code making function non-constant, but we still must consider\n      it as constant, otherwise -fbranch-probabilities will not read data back.\n \n-     life_analyzis rarely eliminates modification of external memory.\n+     life_analysis rarely eliminates modification of external memory.\n    */\n   if (optimize)\n     mark_constant_function ();\n@@ -3478,7 +3478,7 @@ rest_of_compilation (decl)\n       open_dump_file (DFI_bbro, decl);\n \n       /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-\t splitting possibly introduced more crossjumping oppurtuntities.\n+\t splitting possibly introduced more crossjumping opportunities.\n \t Except that we can't actually run crossjumping without running\n \t another DCE pass, which we can't do after reg-stack.  */\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK"}, {"sha": "4c5aa76526d038f312d466852b604225a5579333", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -287,7 +287,7 @@ tail_duplicate ()\n \t      bb2 = cfg_layout_duplicate_bb (bb2, e);\n \n \t      /* Reconsider the original copy of block we've duplicated.\n-\t         Removing the most common predecesor may make it to be\n+\t         Removing the most common predecessor may make it to be\n \t         head.  */\n \t      blocks[old->index] =\n \t\tfibheap_insert (heap, -old->frequency, old);"}, {"sha": "110f93889c990cbcc9abb89155819159a6a6342f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1257,7 +1257,7 @@ expand_call_inline (tp, walk_subtrees, data)\n #endif /* INLINER_FOR_JAVA */\n \n   /* After the body of the function comes the RET_LABEL.  This must come\n-     before we evaluate the returned value below, because that evalulation\n+     before we evaluate the returned value below, because that evaluation\n      may cause RTL to be generated.  */\n #ifndef INLINER_FOR_JAVA\n   COMPOUND_BODY (stmt)"}, {"sha": "0247bb957dc14d4ebc597c16e0ff0174e84a141b", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1362,7 +1362,7 @@ save_expr (expr)\n   /* If we have simple operations applied to a SAVE_EXPR or to a SAVE_EXPR and\n      a constant, it will be more efficient to not make another SAVE_EXPR since\n      it will allow better simplification and GCSE will be able to merge the\n-     computations if they actualy occur.  */\n+     computations if they actually occur.  */\n   inner = t;\n   while (1)\n     {"}, {"sha": "f06a6666c1e9d12f62a7956ffc6cfa391e310023", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -1608,7 +1608,7 @@ struct tree_type GTY(())\n #define DECL_EXTERNAL(NODE) (DECL_CHECK (NODE)->decl.external_flag)\n \n /* In a VAR_DECL for a RECORD_TYPE, sets number for non-init_priority\n-   initializatons.  */\n+   initializations.  */\n #define DEFAULT_INIT_PRIORITY 65535\n #define MAX_INIT_PRIORITY 65535\n #define MAX_RESERVED_INIT_PRIORITY 100\n@@ -2421,7 +2421,7 @@ extern tree build_qualified_type        PARAMS ((tree, int));\n \n /* Like build_qualified_type, but only deals with the `const' and\n    `volatile' qualifiers.  This interface is retained for backwards\n-   compatiblity with the various front-ends; new code should use\n+   compatibility with the various front-ends; new code should use\n    build_qualified_type instead.  */\n \n #define build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t\t\\\n@@ -2675,7 +2675,7 @@ enum tree_node_structure_enum tree_node_structure PARAMS ((tree));\n \n extern tree unsave_expr\t\t\tPARAMS ((tree));\n \n-/* Reset EXP in place so that it can be expaned again.  Does not\n+/* Reset EXP in place so that it can be expanded again.  Does not\n    recurse into subtrees.  */\n \n extern void unsave_expr_1               PARAMS ((tree));"}, {"sha": "a371e4870f21a2156b7a9887e9af7824a1a7a15c", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -69,7 +69,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* ??? Improve control of which loops get unrolled.  Could use profiling\n    info to only unroll the most commonly executed loops.  Perhaps have\n-   a user specifyable option to control the amount of code expansion,\n+   a user specifiable option to control the amount of code expansion,\n    or the percent of loops to consider for unrolling.  Etc.  */\n \n /* ??? Look at the register copies inside the loop to see if they form a\n@@ -3792,7 +3792,7 @@ loop_iterations (loop)\n       if (inc_once == final_value)\n \t{\n \t  /* The iterator value once through the loop is equal to the\n-\t     comparision value.  Either we have an infinite loop, or\n+\t     comparison value.  Either we have an infinite loop, or\n \t     we'll loop twice.  */\n \t  if (increment == const0_rtx)\n \t    return 0;"}, {"sha": "948b1a91e3b2893b7a59accd153af6d234d7c669", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14b493d64dd504f79cd702bba4b8bae678740af9/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=14b493d64dd504f79cd702bba4b8bae678740af9", "patch": "@@ -3864,7 +3864,7 @@ initializer_constant_valid_p (value, endtype)\n \t  op1 = TREE_OPERAND (value, 1);\n \n \t  /* Like STRIP_NOPS except allow the operand mode to widen.\n-\t     This works around a feature of fold that simplfies\n+\t     This works around a feature of fold that simplifies\n \t     (int)(p1 - p2) to ((int)p1 - (int)p2) under the theory\n \t     that the narrower operation is cheaper.  */\n \n@@ -3938,7 +3938,7 @@ output_constant (exp, size, align)\n   enum tree_code code;\n   HOST_WIDE_INT thissize;\n \n-  /* Some front-ends use constants other than the standard language-indepdent\n+  /* Some front-ends use constants other than the standard language-independent\n      varieties, but which may still be output directly.  Give the front-end a\n      chance to convert EXP to a language-independent representation.  */\n   exp = (*lang_hooks.expand_constant) (exp);"}]}