{"sha": "927425dffe021ce15ded980b28a8a5f649b83934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3NDI1ZGZmZTAyMWNlMTVkZWQ5ODBiMjhhOGE1ZjY0OWI4MzkzNA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-11-14T16:41:56Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-11-14T16:41:56Z"}, "message": "re PR rtl-optimization/37397 (IRA performance impact on SPEC CPU 2K/2006)\n\n2008-11-14  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/37397\n\t* ira-int.h (struct ira_allocno): New member bad_spill_p.\n\t(ALLOCNO_BAD_SPILL_P): New macro.\n\n\t* ira-color.c (push_allocnos_to_stack): Check ALLOCNO_BAD_SPILL_P.\n\n\t* ira-build.c (ira_create_allocno): Initialize\n\tALLOCNO_BAD_SPILL_P.\n\t(create_cap_allocno, propagate_allocno_info,\n\tremove_unnecessary_allocnos): Set up or update\n\tALLOCNO_BAD_SPILL_P.\n\t(update_bad_spill_attribute): New function.\n\t(ira_build): Call it.\n\n\t* ira-costs.c (record_reg_classes): Set up ALLOCNO_BAD_SPILL_P.\n\nFrom-SVN: r141860", "tree": {"sha": "12060aac5280cd64ffa8d76772ce606ac96eab1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12060aac5280cd64ffa8d76772ce606ac96eab1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/927425dffe021ce15ded980b28a8a5f649b83934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927425dffe021ce15ded980b28a8a5f649b83934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/927425dffe021ce15ded980b28a8a5f649b83934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/927425dffe021ce15ded980b28a8a5f649b83934/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "487e299ba6e4f2ce394789ba58573e2e9ea59b45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487e299ba6e4f2ce394789ba58573e2e9ea59b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487e299ba6e4f2ce394789ba58573e2e9ea59b45"}], "stats": {"total": 124, "additions": 120, "deletions": 4}, "files": [{"sha": "67c796eab3855aed851fad9cc02166bd8b3bc1dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=927425dffe021ce15ded980b28a8a5f649b83934", "patch": "@@ -1,3 +1,21 @@\n+2008-11-14  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/37397\n+\t* ira-int.h (struct ira_allocno): New member bad_spill_p.\n+\t(ALLOCNO_BAD_SPILL_P): New macro.\n+\n+\t* ira-color.c (push_allocnos_to_stack): Check ALLOCNO_BAD_SPILL_P.\n+\n+\t* ira-build.c (ira_create_allocno): Initialize\n+\tALLOCNO_BAD_SPILL_P.\n+\t(create_cap_allocno, propagate_allocno_info,\n+\tremove_unnecessary_allocnos): Set up or update\n+\tALLOCNO_BAD_SPILL_P.\n+\t(update_bad_spill_attribute): New function.\n+\t(ira_build): Call it.\n+\n+\t* ira-costs.c (record_reg_classes): Set up ALLOCNO_BAD_SPILL_P.\n+\t\n 2008-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/38104"}, {"sha": "110da639a9c53c2b7368622c8c6311129abedfa7", "filename": "gcc/ira-build.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=927425dffe021ce15ded980b28a8a5f649b83934", "patch": "@@ -456,6 +456,7 @@ ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n   ALLOCNO_SOMEWHERE_RENAMED_P (a) = false;\n   ALLOCNO_CHILD_RENAMED_P (a) = false;\n   ALLOCNO_DONT_REASSIGN_P (a) = false;\n+  ALLOCNO_BAD_SPILL_P (a) = false;\n   ALLOCNO_IN_GRAPH_P (a) = false;\n   ALLOCNO_ASSIGNED_P (a) = false;\n   ALLOCNO_MAY_BE_SPILLED_P (a) = false;\n@@ -775,6 +776,7 @@ create_cap_allocno (ira_allocno_t a)\n   ira_allocate_and_copy_costs\n     (&ALLOCNO_CONFLICT_HARD_REG_COSTS (cap), cover_class,\n      ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n+  ALLOCNO_BAD_SPILL_P (cap) = ALLOCNO_BAD_SPILL_P (a);\n   ALLOCNO_NREFS (cap) = ALLOCNO_NREFS (a);\n   ALLOCNO_FREQ (cap) = ALLOCNO_FREQ (a);\n   ALLOCNO_CALL_FREQ (cap) = ALLOCNO_CALL_FREQ (a);\n@@ -1490,6 +1492,8 @@ propagate_allocno_info (void)\n \t  && bitmap_bit_p (ALLOCNO_LOOP_TREE_NODE (a)->border_allocnos,\n \t\t\t   ALLOCNO_NUM (a)))\n \t{\n+\t  if (! ALLOCNO_BAD_SPILL_P (a))\n+\t    ALLOCNO_BAD_SPILL_P (parent_a) = false;\n \t  ALLOCNO_NREFS (parent_a) += ALLOCNO_NREFS (a);\n \t  ALLOCNO_FREQ (parent_a) += ALLOCNO_FREQ (a);\n \t  ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n@@ -1777,6 +1781,8 @@ remove_unnecessary_allocnos (void)\n \t\t  += ALLOCNO_CALLS_CROSSED_NUM (a);\n \t\tALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t\t  += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n+\t\tif (! ALLOCNO_BAD_SPILL_P (a))\n+\t\t  ALLOCNO_BAD_SPILL_P (parent_a) = false;\n #ifdef STACK_REGS\n \t\tif (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n \t\t  ALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n@@ -1825,6 +1831,69 @@ remove_unnecessary_regions (void)\n \n \f\n \n+/* At this point true value of allocno attribute bad_spill_p means\n+   that there is an insn where allocno occurs and where the allocno\n+   can not be used as memory.  The function updates the attribute, now\n+   it can be true only for allocnos which can not be used as memory in\n+   an insn and in whose live ranges there is other allocno deaths.\n+   Spilling allocnos with true value will not improve the code because\n+   it will not make other allocnos colorable and additional reloads\n+   for the corresponding pseudo will be generated in reload pass for\n+   each insn it occurs.\n+\n+   This is a trick mentioned in one classic article of Chaitin etc\n+   which is frequently omitted in other implementations of RA based on\n+   graph coloring.  */\n+static void\n+update_bad_spill_attribute (void)\n+{\n+  int i;\n+  ira_allocno_t a;\n+  ira_allocno_iterator ai;\n+  allocno_live_range_t r;\n+  enum reg_class cover_class;\n+  bitmap_head dead_points[N_REG_CLASSES];\n+\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cover_class = ira_reg_class_cover[i];\n+      bitmap_initialize (&dead_points[cover_class], &reg_obstack);\n+    }\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      cover_class = ALLOCNO_COVER_CLASS (a);\n+      if (cover_class == NO_REGS)\n+\tcontinue;\n+      for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)\n+\tbitmap_set_bit (&dead_points[cover_class], r->finish);\n+    }\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      cover_class = ALLOCNO_COVER_CLASS (a);\n+      if (cover_class == NO_REGS)\n+\tcontinue;\n+      if (! ALLOCNO_BAD_SPILL_P (a))\n+\tcontinue;\n+      for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)\n+\t{\n+\t  for (i = r->start + 1; i < r->finish; i++)\n+\t    if (bitmap_bit_p (&dead_points[cover_class], i))\n+\t      break;\n+\t  if (i < r->finish)\n+\t    break;\n+\t}\n+      if (r != NULL)\n+\tALLOCNO_BAD_SPILL_P (a) = false;\n+    }\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cover_class = ira_reg_class_cover[i];\n+      bitmap_clear (&dead_points[cover_class]);\n+    }\n+}\n+\n+\f\n+\n /* Set up minimal and maximal live range points for allocnos.  */\n static void\n setup_min_max_allocno_live_range_point (void)\n@@ -2438,6 +2507,7 @@ ira_build (bool loops_p)\n   ira_create_allocno_live_ranges ();\n   remove_unnecessary_regions ();\n   ira_compress_allocno_live_ranges ();\n+  update_bad_spill_attribute ();\n   loops_p = more_one_region_p ();\n   if (loops_p)\n     {"}, {"sha": "eea3b2c67141f68fb3d3c521f6c9cf4cf394dff4", "filename": "gcc/ira-color.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=927425dffe021ce15ded980b28a8a5f649b83934", "patch": "@@ -1187,7 +1187,10 @@ push_allocnos_to_stack (void)\n \t\t\t  * ira_reg_class_nregs[ALLOCNO_COVER_CLASS\n \t\t\t\t\t\t(i_allocno)]\n \t\t\t  [ALLOCNO_MODE (i_allocno)] + 1));\n-\t\t  if (allocno == NULL || allocno_pri > i_allocno_pri\n+\t\t  if (allocno == NULL\n+\t\t      || (! ALLOCNO_BAD_SPILL_P (i_allocno)\n+\t\t\t  && ALLOCNO_BAD_SPILL_P (allocno))\n+\t\t      || allocno_pri > i_allocno_pri\n \t\t      || (allocno_pri == i_allocno_pri\n \t\t\t  && (allocno_cost > i_allocno_cost\n \t\t\t      || (allocno_cost == i_allocno_cost "}, {"sha": "280cbb51c9eb2bb881a8ab25204a27b8c80618ff", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=927425dffe021ce15ded980b28a8a5f649b83934", "patch": "@@ -187,6 +187,10 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n   int alt;\n   int i, j, k;\n   rtx set;\n+  int insn_allows_mem[MAX_RECOG_OPERANDS];\n+\n+  for (i = 0; i < n_ops; i++)\n+    insn_allows_mem[i] = 0;\n \n   /* Process each alternative, each time minimizing an operand's cost\n      with the cost for each operand in that alternative.  */\n@@ -236,6 +240,8 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t      j = p[0] - '0';\n \t      classes[i] = classes[j];\n \t      allows_mem[i] = allows_mem[j];\n+\t      if (allows_mem[i])\n+\t\tinsn_allows_mem[i] = 1;\n \n \t      if (! REG_P (op) || REGNO (op) < FIRST_PSEUDO_REGISTER)\n \t\t{\n@@ -302,6 +308,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t       + (recog_data.operand_type[i] != OP_OUT\n \t\t\t  ? ira_memory_move_cost[mode][classes[i]][1] : 0)\n \t\t       - allows_mem[i]) * frequency;\n+\n \t\t  /* If we have assigned a class to this allocno in our\n \t\t     first pass, add a cost to this alternative\n \t\t     corresponding to what we would add if this allocno\n@@ -380,7 +387,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  /* It doesn't seem worth distinguishing between\n \t\t     offsettable and non-offsettable addresses\n \t\t     here.  */\n-\t\t  allows_mem[i] = 1;\n+\t\t  insn_allows_mem[i] = allows_mem[i] = 1;\n \t\t  if (MEM_P (op))\n \t\t    win = 1;\n \t\t  break;\n@@ -456,7 +463,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t      || (CONSTANT_P (op)\n \t\t\t  && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))))\n \t\t    win = 1;\n-\t\t  allows_mem[i] = 1;\n+\t\t  insn_allows_mem[i] = allows_mem[i] = 1;\n \t\tcase 'r':\n \t\t  classes[i] = ira_reg_class_union[classes[i]][GENERAL_REGS];\n \t\t  break;\n@@ -472,7 +479,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t    {\n \t\t      /* Every MEM can be reloaded to fit.  */\n-\t\t      allows_mem[i] = 1;\n+\t\t      insn_allows_mem[i] = allows_mem[i] = 1;\n \t\t      if (MEM_P (op))\n \t\t\twin = 1;\n \t\t    }\n@@ -625,6 +632,18 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  }\n     }\n \n+  for (i = 0; i < n_ops; i++)\n+    {\n+      ira_allocno_t a;\n+      rtx op = ops[i];\n+\n+      if (! REG_P (op) || REGNO (op) < FIRST_PSEUDO_REGISTER)\n+\tcontinue;\n+      a = ira_curr_regno_allocno_map [REGNO (op)];\n+      if (! ALLOCNO_BAD_SPILL_P (a) && insn_allows_mem[i] == 0)\n+\tALLOCNO_BAD_SPILL_P (a) = true;\n+    }\n+\n   /* If this insn is a single set copying operand 1 to operand 0 and\n      one operand is an allocno with the other a hard reg or an allocno\n      that prefers a hard register that is in its own register class\n@@ -867,6 +886,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \tif (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t  break;\n \n+\tALLOCNO_BAD_SPILL_P (ira_curr_regno_allocno_map[REGNO (x)]) = true;\n \tpp = COSTS_OF_ALLOCNO (allocno_costs,\n \t\t\t       ALLOCNO_NUM (ira_curr_regno_allocno_map\n \t\t\t\t\t    [REGNO (x)]));"}, {"sha": "0ed1ec3a9ecc92baed4f1ec9cf25bad8d6fd0855", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/927425dffe021ce15ded980b28a8a5f649b83934/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=927425dffe021ce15ded980b28a8a5f649b83934", "patch": "@@ -351,6 +351,10 @@ struct ira_allocno\n      region and all its subregions recursively.  */\n   unsigned int no_stack_reg_p : 1, total_no_stack_reg_p : 1;\n #endif\n+  /* TRUE value means that there is no sense to spill the allocno\n+     during coloring because the spill will result in additional\n+     reloads in reload pass.  */\n+  unsigned int bad_spill_p : 1;\n   /* TRUE value means that the allocno was not removed yet from the\n      conflicting graph during colouring.  */\n   unsigned int in_graph_p : 1;\n@@ -435,6 +439,7 @@ struct ira_allocno\n #define ALLOCNO_NO_STACK_REG_P(A) ((A)->no_stack_reg_p)\n #define ALLOCNO_TOTAL_NO_STACK_REG_P(A) ((A)->total_no_stack_reg_p)\n #endif\n+#define ALLOCNO_BAD_SPILL_P(A) ((A)->bad_spill_p)\n #define ALLOCNO_IN_GRAPH_P(A) ((A)->in_graph_p)\n #define ALLOCNO_ASSIGNED_P(A) ((A)->assigned_p)\n #define ALLOCNO_MAY_BE_SPILLED_P(A) ((A)->may_be_spilled_p)"}]}