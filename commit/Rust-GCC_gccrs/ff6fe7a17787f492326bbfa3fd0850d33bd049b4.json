{"sha": "ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY2ZmU3YTE3Nzg3ZjQ5MjMyNmJiZmEzZmQwODUwZDMzYmQwNDliNA==", "commit": {"author": {"name": "Jeff Sturm", "email": "jsturm@gcc.gnu.org", "date": "2003-07-28T03:46:21Z"}, "committer": {"name": "Jeff Sturm", "email": "jsturm@gcc.gnu.org", "date": "2003-07-28T03:46:21Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r69874,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r69875", "tree": {"sha": "06d585e3eefe9c7d96d228670fe5e9787f57db5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06d585e3eefe9c7d96d228670fe5e9787f57db5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/comments", "author": null, "committer": null, "parents": [{"sha": "6991c6c926a5909c438c0ea92d98175b41014598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6991c6c926a5909c438c0ea92d98175b41014598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6991c6c926a5909c438c0ea92d98175b41014598"}], "stats": {"total": 3808, "additions": 3556, "deletions": 252}, "files": [{"sha": "0fe1c8f7d3609f8207634b025a41b69391921692", "filename": "boehm-gc/backgraph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fbackgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fbackgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbackgraph.c?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -307,6 +307,7 @@ static void add_back_edges(ptr_t p, word n_words, word gc_descr)\n     }\n   while (currentp < (word *)(p + gc_descr)) {\n     word current = *currentp++;\n+    FIXUP_POINTER(current);\n     if (current >= (word)GC_least_plausible_heap_addr && \n \tcurrent <= (word)GC_greatest_plausible_heap_addr) {\n        ptr_t target = GC_base((GC_PTR)current);"}, {"sha": "80bca2b3d9524463ecc69628b826d197b74b69b8", "filename": "boehm-gc/doc/README.ews4800", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2FREADME.ews4800", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2FREADME.ews4800", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.ews4800?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -73,3 +73,9 @@ GC on EWS4800\n --\n Hironori SAKAMOTO <hsaka@mth.biglobe.ne.jp>\n \n+\n+When using the new \"configure; make\" build process, please\n+run configure with the --disable-shared option.  \"Make check\" does not\n+yet pass with dynamic libraries.  Ther reasons for that are not yet\n+understood.  (HB, paraphrasing message from Hironori SAKAMOTO.)\n+"}, {"sha": "b5fe6796cc2d42d2905a5278d5e6015ac1d78f99", "filename": "boehm-gc/doc/README.macros", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2FREADME.macros", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2FREADME.macros", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.macros?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -51,7 +51,18 @@ _DLL\t\tDefined by Visual C++ if dynamic libraries are being built\n \t\t__declspec(dllexport) needs to be added to declarations\n \t\tto support the case in which the collector is in a dll.\n \n-GC_DLL\t\tUser-settable macro that forces the effect of _DLL.\n+GC_DLL\t\tUser-settable macro that forces the effect of _DLL.  Set\n+\t\tby gc.h if _DLL is defined and GC_NOT_DLL is undefined.\n+\t\tThis is the macro that is tested internally to determine\n+\t\twhether the GC is in its own dynamic library.  May need\n+\t\tto be set by clients before including gc.h.  Note that\n+\t\tinside the GC implementation it indicates that the\n+\t\tcollector is in its own dynamic library, should export\n+\t\tits symbols, etc.  But in clients it indicates that the\n+\t\tGC resides in a different DLL, its entry points should\n+\t\tbe referenced accordingly, and precautions may need to\n+\t\tbe taken to properly deal with statically allocated \n+\t\tvariables in the main program.  Used only for MS Windows.\n \n GC_NOT_DLL\tUser-settable macro that overrides _DLL, e.g. if dynamic\n \t\tlibraries are used, but the collector is in a static library."}, {"sha": "8ecbac8db62e6205e0cd3f9d2375ed2c5efd16b4", "filename": "boehm-gc/doc/gcdescr.html", "status": "modified", "additions": 124, "deletions": 42, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2Fgcdescr.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2Fgcdescr.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgcdescr.html?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -1,7 +1,7 @@\n <HTML>\n <HEAD>\n     <TITLE> Conservative GC Algorithmic Overview </TITLE>\n-    <AUTHOR> Hans-J. Boehm, Silicon Graphics</author>\n+    <AUTHOR> Hans-J. Boehm, HP Labs (Much of this was written at SGI)</author>\n </HEAD>\n <BODY>\n <H1> <I>This is under construction</i> </h1>\n@@ -96,20 +96,24 @@ <H2>Allocation</h2>\n <P>\n Large block sizes are rounded up to\n the next multiple of <TT>HBLKSIZE</tt> and then allocated by\n-<TT>GC_allochblk</tt>.  This uses roughly what Paul Wilson has termed\n-a \"next fit\" algorithm, i.e. first-fit with a rotating pointer.\n-The implementation does check for a better fitting immediately\n-adjacent block, which gives it somewhat better fragmentation characteristics.\n-I'm now convinced it should use a best fit algorithm.  The actual\n+<TT>GC_allochblk</tt>.  Recent versions of the collector\n+use an approximate best fit algorithm by keeping free lists for\n+several large block sizes.\n+The actual\n implementation of <TT>GC_allochblk</tt>\n is significantly complicated by black-listing issues\n (see below).\n <P>\n-Small blocks are allocated in blocks of size <TT>HBLKSIZE</tt>.\n-Each block is\n+Small blocks are allocated in chunks of size <TT>HBLKSIZE</tt>.\n+Each chunk is\n dedicated to only one object size and kind.  The allocator maintains\n separate free lists for each size and kind of object.\n <P>\n+Once a large block is split for use in smaller objects, it can only\n+be used for objects of that size, unless the collector discovers a completely\n+empty chunk.  Completely empty chunks are restored to the appropriate\n+large block free list.\n+<P>\n In order to avoid allocating blocks for too many distinct object sizes,\n the collector normally does not directly allocate objects of every possible\n request size.  Instead request are rounded up to one of a smaller number\n@@ -139,27 +143,35 @@ <H2>Allocation</h2>\n that the amount of garbage collection work per allocated byte remains\n constant.\n <P>\n-The above is in fat an oversimplification of the real heap expansion\n-heuristic, which adjusts slightly for root size and certain kinds of\n-fragmentation.  In particular, programs with a large root set size and\n+The above is in fact an oversimplification of the real heap expansion\n+and GC triggering heuristic, which adjusts slightly for root size\n+and certain kinds of\n+fragmentation.  In particular:\n+<UL>\n+<LI> Programs with a large root set size and\n little live heap memory will expand the heap to amortize the cost of\n-scanning the roots.\n-<P>\n-Versions 5.x of the collector actually collect more frequently in\n+scanning the roots.  \n+<LI> Versions 5.x of the collector actually collect more frequently in\n nonincremental mode.  The large block allocator usually refuses to split\n large heap blocks once the garbage collection threshold is\n reached.  This often has the effect of collecting well before the\n heap fills up, thus reducing fragmentation and working set size at the\n-expense of GC time.  6.x will chose an intermediate strategy depending\n+expense of GC time.  Versions 6.x choose an intermediate strategy depending\n on how much large object allocation has taken place in the past.\n (If the collector is configured to unmap unused pages, versions 6.x\n-will use the 5.x strategy.)\n-<P>\n-(It has been suggested that this should be adjusted so that we favor\n+use the 5.x strategy.)\n+<LI> In calculating the amount of allocation since the last collection we\n+give partial credit for objects we expect to be explicitly deallocated.\n+Even if all objects are explicitly managed, it is often desirable to collect\n+on rare occasion, since that is our only mechanism for coalescing completely\n+empty chunks.\n+</ul>\n+<P>\n+It has been suggested that this should be adjusted so that we favor\n expansion if the resulting heap still fits into physical memory.\n In many cases, that would no doubt help.  But it is tricky to do this\n in a way that remains robust if multiple application are contending\n-for a single pool of physical memory.)\n+for a single pool of physical memory.\n \n <H2>Mark phase</h2>\n \n@@ -204,7 +216,7 @@ <H2>Mark phase</h2>\n <LI> <TT>MS_NONE</tt> indicating that reachable objects are marked.\n </ol>\n \n-The core mark routine <TT>GC_mark_from_mark_stack</tt>, is called\n+The core mark routine <TT>GC_mark_from</tt>, is called\n repeatedly by several of the sub-phases when the mark stack starts to fill\n up.  It is also called repeatedly in <TT>MS_ROOTS_PUSHED</tt> state\n to empty the mark stack.\n@@ -213,6 +225,12 @@ <H2>Mark phase</h2>\n It is fairly carefully tuned, since it usually consumes a large majority\n of the garbage collection time.\n <P>\n+The fact that it perform a only a small amount of work per call also\n+allows it to be used as the core routine of the parallel marker.  In that\n+case it is normally invoked on thread-private mark stacks instead of the\n+global mark stack.  More details can be found in\n+<A HREF=\"scale.html\">scale.html</a>\n+<P>\n The marker correctly handles mark stack overflows.  Whenever the mark stack\n overflows, the mark state is reset to <TT>MS_INVALID</tt>.\n Since there are already marked objects in the heap,\n@@ -281,7 +299,8 @@ <H2>Sweep phase</h2>\n Each small object page is checked to see if all mark bits are clear.\n If so, the entire page is returned to the large object free list.\n Small object pages containing some reachable object are queued for later\n-sweeping.\n+sweeping, unless we determine that the page contains very little free\n+space, in which case it is not examined further.\n <P>\n This initial sweep pass touches only block headers, not\n the blocks themselves.  Thus it does not require significant paging, even\n@@ -341,26 +360,31 @@ <H2>Finalization</h2>\n a cycle involving the object.  This usually results in a warning from the\n collector.  Such objects are not finalized, since it may be\n unsafe to do so.  See the more detailed\n-<A HREF=\"finalization.html\"> discussion of finalization semantics</a>.\n+<A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/finalization.html\"> discussion of finalization semantics</a>.\n <P>\n Any objects remaining unmarked at the end of this process are added to\n a queue of objects whose finalizers can be run.  Depending on collector\n configuration, finalizers are dequeued and run either implicitly during\n allocation calls, or explicitly in response to a user request.\n+(Note that the former is unfortunately both the default and not generally safe.\n+If finalizers perform synchronization, it may result in deadlocks.\n+Nontrivial finalizers generally need to perform synchronization, and\n+thus require a different collector configuration.)\n <P>\n The collector provides a mechanism for replacing the procedure that is\n used to mark through objects.  This is used both to provide support for\n Java-style unordered finalization, and to ignore certain kinds of cycles,\n <I>e.g.</i> those arising from C++ implementations of virtual inheritance.\n \n <H2>Generational Collection and Dirty Bits</h2>\n-We basically use the parallel and generational GC algorithm described in\n-<A HREF=\"papers/pldi91.ps.gz\">\"Mostly Parallel Garbage Collection\"</a>,\n+We basically use the concurrent and generational GC algorithm described in\n+<A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/papers/pldi91.ps.Z\">\"Mostly Parallel Garbage Collection\"</a>,\n by Boehm, Demers, and Shenker.\n <P>\n The most significant modification is that\n-the collector always runs in the allocating thread.\n-There is no separate garbage collector thread.\n+the collector always starts running in the allocating thread.\n+There is no separate garbage collector thread.  (If parallel GC is\n+enabled, helper threads may also be woken up.)\n If an allocation attempt either requests a large object, or encounters\n an empty small object free list, and notices that there is a collection\n in progress, it immediately performs a small amount of marking work\n@@ -389,50 +413,108 @@ <H2>Generational Collection and Dirty Bits</h2>\n the set of modified pages is retrieved, and we mark once again from\n marked objects on those pages, this time with the mutator stopped.\n <P>\n-We keep track of modified pages using one of three distinct mechanisms:\n+We keep track of modified pages using one of several distinct mechanisms:\n <OL>\n <LI>\n Through explicit mutator cooperation.  Currently this requires\n-the use of <TT>GC_malloc_stubborn</tt>.\n+the use of <TT>GC_malloc_stubborn</tt>, and is rarely used.\n <LI>\n-By write-protecting physical pages and catching write faults.  This is\n+(<TT>MPROTECT_VDB</tt>) By write-protecting physical pages and\n+catching write faults.  This is\n implemented for many Unix-like systems and for win32.  It is not possible\n in a few environments.\n <LI>\n-By retrieving dirty bit information from /proc.  (Currently only Sun's\n+(<TT>PROC_VDB</tt>) By retrieving dirty bit information from /proc.\n+(Currently only Sun's\n Solaris supports this.  Though this is considerably cleaner, performance\n may actually be better with mprotect and signals.)\n+<LI>\n+(<TT>PCR_VDB</tt>) By relying on an external dirty bit implementation, in this\n+case the one in Xerox PCR.\n+<LI>\n+(<TT>DEFAULT_VDB</tt>) By treating all pages as dirty.  This is the default if \n+none of the other techniques is known to be usable, and\n+<TT>GC_malloc_stubborn</tt> is not used.  Practical only for testing, or if\n+the vast majority of objects use <TT>GC_malloc_stubborn</tt>.\n </ol>\n \n+<H2>Black-listing</h2>\n+\n+The collector implements <I>black-listing</i> of pages, as described\n+in\n+<A HREF=\"http://www.acm.org/pubs/citations/proceedings/pldi/155090/p197-boehm/\">\n+Boehm, ``Space Efficient Conservative Collection'', PLDI '93</a>, also available\n+<A HREF=\"papers/pldi93.ps.Z\">here</a>.\n+<P>\n+During the mark phase, the collector tracks ``near misses'', i.e. attempts\n+to follow a ``pointer'' to just outside the garbage-collected heap, or\n+to a currently unallocated page inside the heap.  Pages that have been\n+the targets of such near misses are likely to be the targets of\n+misidentified ``pointers'' in the future.  To minimize the future\n+damage caused by such misidentifications they will be allocated only to\n+small pointerfree objects. \n+<P>\n+The collector understands two different kinds of black-listing.  A\n+page may be black listed for interior pointer references\n+(<TT>GC_add_to_black_list_stack</tt>), if it was the target of a near\n+miss from a location that requires interior pointer recognition,\n+<I>e.g.</i> the stack, or the heap if <TT>GC_all_interior_pointers</tt>\n+is set.  In this case, we also avoid allocating large blocks that include\n+this page.\n+<P>\n+If the near miss came from a source that did not require interior\n+pointer recognition, it is black-listed with\n+<TT>GC_add_to_black_list_normal</tt>.\n+A page black-listed in this way may appear inside a large object,\n+so long as it is not the first page of a large object.\n+<P>\n+The <TT>GC_allochblk</tt> routine respects black-listing when assigning\n+a block to a particular object kind and size.  It occasionally\n+drops (i.e. allocates and forgets) blocks that are completely black-listed\n+in order to avoid excessively long large block free lists containing\n+only unusable blocks.  This would otherwise become an issue\n+if there is low demand for small pointerfree objects.\n+\n <H2>Thread support</h2>\n We support several different threading models.  Unfortunately Pthreads,\n the only reasonably well standardized thread model, supports too narrow\n an interface for conservative garbage collection.  There appears to be\n-no portable way to allow the collector to coexist with various Pthreads\n+no completely portable way to allow the collector to coexist with various Pthreads\n implementations.  Hence we currently support only a few of the more\n common Pthreads implementations.\n <P>\n In particular, it is very difficult for the collector to stop all other\n threads in the system and examine the register contents.  This is currently\n-accomplished with very different mechanisms for different Pthreads\n+accomplished with very different mechanisms for some Pthreads\n implementations.  The Solaris implementation temporarily disables much\n of the user-level threads implementation by stopping kernel-level threads\n-(\"lwp\"s).  The Irix implementation sends signals to individual Pthreads\n-and has them wait in the signal handler.  The Linux implementation\n-is similar in spirit to the Irix one.\n+(\"lwp\"s).  The Linux/HPUX/OSF1 and Irix implementations sends signals to\n+individual Pthreads and has them wait in the signal handler.\n <P>\n-The Irix implementation uses\n-only documented Pthreads calls, but relies on extensions to their semantics,\n-notably the use of mutexes and condition variables from signal\n-handlers.  The Linux implementation should be far closer to\n-portable, though impirically it is not completely portable.\n+The Linux and Irix implementations use\n+only documented Pthreads calls, but rely on extensions to their semantics.\n+The Linux implementation <TT>linux_threads.c</tt> relies on only very\n+mild extensions to the pthreads semantics, and already supports a large number\n+of other Unix-like pthreads implementations.  Our goal is to make this the\n+only pthread support in the collector.\n+<P>\n+(The Irix implementation is separate only for historical reasons and should\n+clearly be merged.  The current Solaris implementation probably performs\n+better in the uniprocessor case, but does not support thread operations in the\n+collector.  Hence it cannot support the parallel marker.)\n <P>\n All implementations must\n intercept thread creation and a few other thread-specific calls to allow\n enumeration of threads and location of thread stacks.  This is current\n-accomplished with <TT># define</tt>'s in <TT>gc.h</tt>, or optionally\n+accomplished with <TT># define</tt>'s in <TT>gc.h</tt>\n+(really <TT>gc_pthread_redirects.h</tt>), or optionally\n by using ld's function call wrapping mechanism under Linux.\n <P>\n Comments are appreciated.  Please send mail to\n-<A HREF=\"mailto:boehm@acm.org\"><TT>boehm@acm.org</tt></a>\n+<A HREF=\"mailto:boehm@acm.org\"><TT>boehm@acm.org</tt></a> or\n+<A HREF=\"mailto:Hans.Boehm@hp.com\"><TT>Hans.Boehm@hp.com</tt></a>\n+<P>\n+This is a modified copy of a page written while the author was at SGI.\n+The original was <A HREF=\"http://reality.sgi.com/boehm/gcdescr.html\">here</a>.\n </body>\n+</html>"}, {"sha": "c46a281cc6751195db7fe163285c60a1999836b1", "filename": "boehm-gc/doc/tree.html", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2Ftree.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fdoc%2Ftree.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Ftree.html?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -1,13 +1,14 @@\n <HTML>\n <HEAD>\n     <TITLE>  Two-Level Tree Structure for Fast Pointer Lookup</TITLE>\n-    <AUTHOR> Hans-J. Boehm, Silicon Graphics</author>\n+    <AUTHOR> Hans-J. Boehm, Silicon Graphics (now at HP)</author>\n </HEAD>\n <BODY>\n <H1>Two-Level Tree Structure for Fast Pointer Lookup</h1>\n <P>\n The conservative garbage collector described\n-<A HREF=\"gc.html\">here</a> uses a 2-level tree\n+<A HREF=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/\">here</a>\n+uses a 2-level tree\n data structure to aid in fast pointer identification.\n This data structure is described in a bit more detail here, since\n <OL>"}, {"sha": "398a88e1421823561abbf2d48ca8f263babc04d9", "filename": "boehm-gc/install-sh", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Finstall-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Finstall-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finstall-sh?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -109,7 +109,7 @@ then\n \techo \"install:\tno input file specified\"\n \texit 1\n else\n-\ttrue\n+\t:\n fi\n \n if [ x\"$dir_arg\" != x ]; then\n@@ -120,7 +120,7 @@ if [ x\"$dir_arg\" != x ]; then\n \t\tinstcmd=:\n \t\tchmodcmd=\"\"\n \telse\n-\t\tinstcmd=mkdir\n+\t\tinstcmd=$mkdirprog\n \tfi\n else\n \n@@ -130,7 +130,7 @@ else\n \n \tif [ -f $src -o -d $src ]\n \tthen\n-\t\ttrue\n+\t\t:\n \telse\n \t\techo \"install:  $src does not exist\"\n \t\texit 1\n@@ -141,7 +141,7 @@ else\n \t\techo \"install:\tno destination specified\"\n \t\texit 1\n \telse\n-\t\ttrue\n+\t\t:\n \tfi\n \n # If destination is a directory, append the input filename; if your system\n@@ -151,7 +151,7 @@ else\n \tthen\n \t\tdst=\"$dst\"/`basename $src`\n \telse\n-\t\ttrue\n+\t\t:\n \tfi\n fi\n \n@@ -163,8 +163,8 @@ dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`\n \n # Skip lots of stat calls in the usual case.\n if [ ! -d \"$dstdir\" ]; then\n-defaultIFS='\t\n-'\n+defaultIFS='\n+\t'\n IFS=\"${IFS-${defaultIFS}}\"\n \n oIFS=\"${IFS}\"\n@@ -183,7 +183,7 @@ while [ $# -ne 0 ] ; do\n         then\n \t\t$mkdirprog \"${pathcomp}\"\n \telse\n-\t\ttrue\n+\t\t:\n \tfi\n \n \tpathcomp=\"${pathcomp}/\"\n@@ -194,10 +194,10 @@ if [ x\"$dir_arg\" != x ]\n then\n \t$doit $instcmd $dst &&\n \n-\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dst; else true ; fi &&\n-\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&\n-\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dst; else true ; fi &&\n-\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dst; else true ; fi\n+\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dst; else : ; fi &&\n+\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dst; else : ; fi &&\n+\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dst; else : ; fi &&\n+\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dst; else : ; fi\n else\n \n # If we're going to rename the final executable, determine the name now.\n@@ -216,7 +216,7 @@ else\n \tthen\n \t\tdstfile=`basename $dst`\n \telse\n-\t\ttrue\n+\t\t:\n \tfi\n \n # Make a temp file name in the proper directory.\n@@ -235,10 +235,10 @@ else\n # ignore errors from any of these, just make sure not to ignore\n # errors from the above \"$doit $instcmd $src $dsttmp\" command.\n \n-\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&\n-\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&\n-\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&\n-\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&\n+\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dsttmp; else :;fi &&\n+\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dsttmp; else :;fi &&\n+\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dsttmp; else :;fi &&\n+\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dsttmp; else :;fi &&\n \n # Now rename the file to the real destination.\n "}, {"sha": "066bf6a5ce6dca41fad64dc0ad26ab172d94b6ac", "filename": "boehm-gc/libtool.m4", "status": "modified", "additions": 3320, "deletions": 182, "changes": 3502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Flibtool.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Flibtool.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flibtool.m4?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4"}, {"sha": "f9c37afd1b84e729f40b280cd4f56da5a9af6596", "filename": "boehm-gc/mkinstalldirs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fmkinstalldirs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff6fe7a17787f492326bbfa3fd0850d33bd049b4/boehm-gc%2Fmkinstalldirs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmkinstalldirs?ref=ff6fe7a17787f492326bbfa3fd0850d33bd049b4", "patch": "@@ -2,29 +2,90 @@\n # mkinstalldirs --- make directory hierarchy\n # Author: Noah Friedman <friedman@prep.ai.mit.edu>\n # Created: 1993-05-16\n-# Last modified: 1994-03-25\n # Public domain\n \n+# $Id: mkinstalldirs,v 1.13 1999/01/05 03:18:55 bje Exp $\n+\n errstatus=0\n+dirmode=\"\"\n+\n+usage=\"\\\n+Usage: mkinstalldirs [-h] [--help] [-m mode] dir ...\"\n+\n+# process command line arguments\n+while test $# -gt 0 ; do\n+   case \"${1}\" in\n+     -h | --help | --h* )\t\t\t# -h for help\n+\techo \"${usage}\" 1>&2; exit 0 ;;\n+     -m )\t\t\t\t\t# -m PERM arg\n+\tshift\n+\ttest $# -eq 0 && { echo \"${usage}\" 1>&2; exit 1; }\n+\tdirmode=\"${1}\"\n+\tshift ;;\n+     -- ) shift; break ;;\t\t\t# stop option processing\n+     -* ) echo \"${usage}\" 1>&2; exit 1 ;;\t# unknown option\n+     * )  break ;;\t\t\t\t# first non-opt arg\n+   esac\n+done\n+\n+for file\n+do\n+  if test -d \"$file\"; then\n+    shift\n+  else\n+    break\n+  fi\n+done\n+\n+case $# in\n+0) exit 0 ;;\n+esac\n \n-for file in ${1+\"$@\"} ; do \n+case $dirmode in\n+'')\n+  if mkdir -p -- . 2>/dev/null; then\n+    echo \"mkdir -p -- $*\"\n+    exec mkdir -p -- \"$@\"\n+  fi ;;\n+*)\n+  if mkdir -m \"$dirmode\" -p -- . 2>/dev/null; then\n+    echo \"mkdir -m $dirmode -p -- $*\"\n+    exec mkdir -m \"$dirmode\" -p -- \"$@\"\n+  fi ;;\n+esac\n+\n+for file\n+do\n    set fnord `echo \":$file\" | sed -ne 's/^:\\//#/;s/^://;s/\\// /g;s/^#/\\//;p'`\n    shift\n \n    pathcomp=\n-   for d in ${1+\"$@\"} ; do\n+   for d\n+   do\n      pathcomp=\"$pathcomp$d\"\n      case \"$pathcomp\" in\n        -* ) pathcomp=./$pathcomp ;;\n      esac\n \n      if test ! -d \"$pathcomp\"; then\n-        echo \"mkdir $pathcomp\" 1>&2\n-        mkdir \"$pathcomp\" > /dev/null 2>&1 || lasterr=$?\n-     fi\n+\techo \"mkdir $pathcomp\"\n \n-     if test ! -d \"$pathcomp\"; then\n-\terrstatus=$lasterr\n+\tmkdir \"$pathcomp\" || lasterr=$?\n+\n+\tif test ! -d \"$pathcomp\"; then\n+\t  errstatus=$lasterr\n+\telse\n+\t  if test ! -z \"$dirmode\"; then\n+\t     echo \"chmod $dirmode $pathcomp\"\n+\n+\t     lasterr=\"\"\n+\t     chmod \"$dirmode\" \"$pathcomp\" || lasterr=$?\n+\n+\t     if test ! -z \"$lasterr\"; then\n+\t       errstatus=$lasterr\n+\t     fi\n+\t  fi\n+\tfi\n      fi\n \n      pathcomp=\"$pathcomp/\"\n@@ -33,4 +94,8 @@ done\n \n exit $errstatus\n \n+# Local Variables:\n+# mode: shell-script\n+# sh-indentation: 3\n+# End:\n # mkinstalldirs ends here"}]}