{"sha": "18081149255f8a116512c3e28bf3469ed66d496e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgwODExNDkyNTVmOGExMTY1MTJjM2UyOGJmMzQ2OWVkNjZkNDk2ZQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2010-07-28T19:13:11Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-07-28T19:13:11Z"}, "message": "IVOPT performance tuning patch.\n\nIVOPT performance tuning patch. The main problem is a variant of maximal weight \nbipartite matching/assignment problem -- i.e., there is an additional global\ncost function. The complexity of the algorighm to find the optimial solution\n> O(n^2). The existing algorithm in gcc tries to find the solution in 3 stages:\n1) Find the initial solution set (dynamic programing style)\n2) Extend the solution set\n3) Prune the soultion set.\n\nThe problem is that in step 1, the initial set tends to be too large so that\nthe final solution is very likely local optimal.\n\nThis patch addresses the problem and sees very large SPEC improvements.\n\nAnother area of problem is that ivopts often creates loop invariant expressions, and\nsuch expressions increase register pressure which is not counted. This is addressed\nin this patch.\n\nThe third main problem is the profile data is not considered in cost computation\n\nThe forth problem is that loop invariant comptuation's cost is not properly adjusted.\n\n\n\nThere are more tuning opportuties, namely:\n\n1) Do not check ivs dependency during ivs set pruning (this improves deallII 8% on core2)\n2) Unconditionally consider all important candidates in partial set expansion (in addition\nto the extended solutino based on selected candidates)\n3) revisit the two stage initial set computation.\n\nFrom-SVN: r162653", "tree": {"sha": "a565fa6fb23aca1951c811e6fa17593d1d4ca811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a565fa6fb23aca1951c811e6fa17593d1d4ca811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18081149255f8a116512c3e28bf3469ed66d496e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18081149255f8a116512c3e28bf3469ed66d496e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18081149255f8a116512c3e28bf3469ed66d496e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18081149255f8a116512c3e28bf3469ed66d496e/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c5273a96ba8dbf98c40bc6d9d0a1587b4cfedb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c5273a96ba8dbf98c40bc6d9d0a1587b4cfedb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c5273a96ba8dbf98c40bc6d9d0a1587b4cfedb2"}], "stats": {"total": 686, "additions": 628, "deletions": 58}, "files": [{"sha": "10059b05a66dff26d2efc2e34014b87abef71151", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -1,3 +1,37 @@\n+2010-07-28  Xinliang David Li  <davidxl@google.com>\n+\n+\t* tree-ssa-loop-ivopts.c (avg_loop_niter): New function.\n+\t(dump_cand): Dump var_before/after.\n+\t(htab_inv_expr_eq): New function.\n+\t(htab_inv_expr_hash): New function.\n+\t(tree_ssa_iv_optimize_init): Support pseudo invariants.\n+\t(add_candidate_1): consider base type precision.\n+\t(set_use_iv_cost): New parameter.\n+\t(adjust_setup_cost): Use profile information.\n+\t(get_address_cost): Do not hard code width in computing address\n+\toffset limits.\n+\t(compare_aff_trees): New function.\n+\t(get_loop_invariant_expr_id): New function.\n+\t(get_computation_cost_at): New parameter and use profile information.\n+\t(get_computation_cost): New parameter.\n+\t(determine_use_iv_cost_generic): Pass new parameter.\n+\t(determine_use_iv_cost_address): Ditto.\n+\t(determine_use_iv_cost_condition): Ditto.\n+\t(autoinc_possible_for_pair): Ditto.\n+\t(determine_use_iv_costs): More dumps.\n+\t(iv_ca_get_num_inv_exprs): New function.\n+\t(iv_ca_recount_cost): Consider loop invariants in register pressure\n+\tcost.\n+\t(iv_ca_add_use): New parameter.\n+\t(iv_ca_dump): Better dumping.\n+\t(iv_ca_extend): New parameter.\n+\t(try_add_cand_for): Attempt to get better partial solution.\n+\t(try_improve_iv_set): Pass new parameter to iv_ca_extend.\n+\t(create_new-ivs): More dumps.\n+\t(rewrite_use_compare): Ditto.\n+\t(free_loop_data): More cleanup.\n+\t(treee_ssa_iv_optimize_finalize): Ditto.\n+\n 2010-07-28  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/i386.h (MCOUNT_NAME_BEFORE_PROLOGUE): New."}, {"sha": "60baa4bd336be78171f5dcd7040edf4f821718e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_1.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts\" } */\n+#define TYPE char*\n+\n+/* Testing that only one induction variable is selected after IVOPT on\n+   the given target instead of 3.  */\n+void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)\n+{\n+      int x;\n+       for( x = 0; x < i_width; x++ )\n+       {\n+           dst[x] = ( src1[x] + src2[x] + 1 ) >> 1;\n+       }\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"PHI <ivtmp\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "ba87b502cd35b1103170f529f1ad128a3e2044c5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_2.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts\" } */\n+\n+#define TYPE char*\n+\n+/* Testing on the given target, only one iv candidate instead of 3.  */\n+void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)\n+{\n+      int x;\n+       for( x = 0; x < i_width; x++ )\n+       {\n+           *dst++ = ( *src1++ + *src2++ + 1 ) >> 1;\n+       }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"PHI <ivtmp\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "ae4185a7a71a0967dea41ede8cbe9ef30573a0d6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_3.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts\" } */\n+\n+#define TYPE char*\n+\n+/* Make sure only 1 iv candidate is selected after IVOPT.  */\n+void foo (int i_width, char* dst, char* src1, char* src2)\n+{\n+      int x;\n+       for( x = 0; x < i_width; x++ )\n+       {\n+           *((TYPE)dst) = ( *((TYPE)src1) + *((TYPE)src2) + 1 ) >> 1;\n+\t   dst+=sizeof(TYPE);\n+\t   src1+=sizeof(TYPE);\n+\t   src2+=sizeof(TYPE);\n+       }\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"PHI <ivtmp\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "570664c9228978d26223073eeb7ef342b3ff17a9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_4.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts\" } */\n+\n+#ifndef TYPE\n+#define TYPE char*\n+#endif\n+\n+/* Make sure only 1 iv candidate is selected.  */\n+void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)\n+{\n+      TYPE dstn= dst + i_width;\n+       for( ; dst < dstn; )\n+       {\n+           *dst++ = ( *src1++ + *src2++ + 1 ) >> 1;\n+       }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"PHI <ivtmp\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "076f5118e99382d9f6eaabeaa27135db9873f98b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_1.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts-details\" } */\n+\n+#ifndef TYPE\n+#define TYPE char*\n+#endif\n+\n+int a[400];\n+\n+/* Testing inferred loop iteration from array -- exit test can be replaced.  */\n+void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)\n+{\n+      TYPE dstn= dst + i_width;\n+      TYPE dst0 = dst;\n+      unsigned long long i = 0;\n+       for( ; dst <= dstn; )\n+       {\n+           dst0[i] = ( src1[i] + src2[i] + 1 +a[i]) >> 1;\n+           dst++;\n+\t   i += 16;\n+       }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "4b7e197dd04bbf500727f19726bd2a7aa033c9c4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_infer_2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_infer_2.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts-details\" } */\n+\n+#ifndef TYPE\n+#define TYPE char*\n+#endif\n+\n+extern int a[];\n+\n+/* Can not infer loop iteration from array -- exit test can not be replaced.  */\n+void foo (int i_width, TYPE dst, TYPE src1, TYPE src2)\n+{\n+      TYPE dstn= dst + i_width;\n+      TYPE dst0 = dst;\n+      unsigned long long i = 0;\n+       for( ; dst <= dstn; )\n+       {\n+           dst0[i] = ( src1[i] + src2[i] + 1 +a[i]) >> 1;\n+           dst++;\n+\t   i += 16;\n+       }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 0 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "4e19dfd01e5230e18b2deef5ae0803e6a64497e8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_1.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts-details\" } */\n+\n+/* The test 'if (p2 > p_limit2)' can be replaced, so iv p2 can be\n+ * eliminated.  */\n+long foo(long* p, long* p2, int N1, int N2)\n+{\n+  int i = 0;\n+  long* p_limit = p + N1;\n+  long* p_limit2 = p2 + N2;\n+  long s = 0;\n+  while (p  <= p_limit)\n+    {\n+      p++;\n+      p2++;\n+      if (p2 > p_limit2)\n+        break;\n+      s += (*p);\n+    }\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "5e38df67be464419b902eb58c42f47c72c61f919", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_2.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts-details\" } */\n+\n+/* Exit tests 'i < N1' and 'p2 > p_limit2' can be replaced, so\n+ * two ivs i and p2 can be eliminate.  */\n+long foo(long* p, long* p2, int N1, int N2)\n+{\n+  int i = 0;\n+  long* p_limit2 = p2 + N2;\n+  long s = 0;\n+  while (i < N1)\n+    {\n+       p++;\n+       p2++;\n+       i++;\n+       if (p2 > p_limit2)\n+         break;\n+       s += (*p);\n+    }\n+\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 2 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "dc78a43f73f51021eacd9b2569063ddab8136dee", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_3.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts-details\" } */\n+\n+/* iv p2 can be eliminated.  */\n+long foo(long* p, long* p2, int N1, int N2)\n+{\n+  unsigned long  i = 0;\n+  long* p_limit2 = p2 + N2;\n+  long s = 0;\n+  while (i < N1)\n+    {\n+      p2++;\n+      i++;\n+      if (p2 > p_limit2)\n+        break;\n+      s += p[i];\n+    }\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 1 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "d2aa78d61e3a8f6a14334b39f698f7b5d9d82b78", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_4.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -0,0 +1,25 @@\n+\n+/* { dg-do compile { target {{ i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-options \"-O2 -m64 -fdump-tree-ivopts-details\" } */\n+\n+/* iv i's step 16 so its period is smaller than the max iterations\n+ * i.e. replacing if (p2 > p_limit2) with testing of i may result in\n+ * overflow.  */\n+long foo(long* p, long* p2, int N1, int N2)\n+{\n+  unsigned long  i = 0;\n+  long* p_limit2 = p2 + N2;\n+  long s = 0;\n+  while (i < N1)\n+    {\n+      p2++;\n+      i += 16;\n+      if (p2 > p_limit2)\n+        break;\n+     s += p[i];\n+  }\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 0 \"ivopts\"} } */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } } */"}, {"sha": "202ad1f4e2f845619556c20ba66ef2c9d1581324", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopts-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-3.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -8,5 +8,5 @@ void main (void)\n     f2 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"!= 0\" 4 \"ivopts\" } }  */\n+/* { dg-final { scan-tree-dump-times \"!= 0\" 5 \"ivopts\" } }  */\n /* { dg-final { cleanup-tree-dump \"ivopts\" } }  */"}, {"sha": "519f66e51d131b269a33b9660a5737d017aa2cc9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 373, "deletions": 57, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18081149255f8a116512c3e28bf3469ed66d496e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=18081149255f8a116512c3e28bf3469ed66d496e", "patch": "@@ -89,6 +89,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"tree-affine.h\"\n #include \"target.h\"\n+#include \"tree-inline.h\"\n #include \"tree-ssa-propagate.h\"\n \n /* FIXME: Expressions are expanded to RTL in this pass to determine the\n@@ -99,10 +100,21 @@ along with GCC; see the file COPYING3.  If not see\n /* The infinite cost.  */\n #define INFTY 10000000\n \n-/* The expected number of loop iterations.  TODO -- use profiling instead of\n-   this.  */\n #define AVG_LOOP_NITER(LOOP) 5\n \n+/* Returns the expected number of loop iterations for LOOP.\n+   The average trip count is computed from profile data if it\n+   exists. */\n+\n+static inline HOST_WIDE_INT\n+avg_loop_niter (struct loop *loop)\n+{\n+  HOST_WIDE_INT niter = estimated_loop_iterations_int (loop, false);\n+  if (niter == -1)\n+    return AVG_LOOP_NITER (loop);\n+\n+  return niter;\n+}\n \n /* Representation of the induction variable.  */\n struct iv\n@@ -158,6 +170,7 @@ struct cost_pair\n   tree value;\t\t/* For final value elimination, the expression for\n \t\t\t   the final value of the iv.  For iv elimination,\n \t\t\t   the new bound to compare with.  */\n+  int inv_expr_id;      /* Loop invariant expression id.  */\n };\n \n /* Use.  */\n@@ -212,6 +225,14 @@ struct iv_cand\n \t\t\t   biv.  */\n };\n \n+/* Loop invariant expression hashtable entry.  */\n+struct iv_inv_expr_ent\n+{\n+  tree expr;\n+  int id;\n+  hashval_t hash;\n+};\n+\n /* The data used by the induction variable optimizations.  */\n \n typedef struct iv_use *iv_use_p;\n@@ -239,6 +260,13 @@ struct ivopts_data\n   /* The array of information for the ssa names.  */\n   struct version_info *version_info;\n \n+  /* The hashtable of loop invariant expressions created\n+     by ivopt.  */\n+  htab_t inv_expr_tab;\n+\n+  /* Loop invariant expression id.  */\n+  int inv_expr_id;\n+\n   /* The bitmap of indices in version_info whose value was changed.  */\n   bitmap relevant;\n \n@@ -520,6 +548,19 @@ dump_cand (FILE *file, struct iv_cand *cand)\n       return;\n     }\n \n+  if (cand->var_before)\n+    {\n+      fprintf (file, \"  var_before \");\n+      print_generic_expr (file, cand->var_before, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  if (cand->var_after)\n+    {\n+      fprintf (file, \"  var_after \");\n+      print_generic_expr (file, cand->var_after, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+\n   switch (cand->pos)\n     {\n     case IP_NORMAL:\n@@ -776,6 +817,29 @@ niter_for_single_dom_exit (struct ivopts_data *data)\n   return niter_for_exit (data, exit, NULL);\n }\n \n+/* Hash table equality function for expressions.  */\n+\n+static int\n+htab_inv_expr_eq (const void *ent1, const void *ent2)\n+{\n+  const struct iv_inv_expr_ent *expr1 =\n+      (const struct iv_inv_expr_ent *)ent1;\n+  const struct iv_inv_expr_ent *expr2 =\n+      (const struct iv_inv_expr_ent *)ent2;\n+\n+  return operand_equal_p (expr1->expr, expr2->expr, 0);\n+}\n+\n+/* Hash function for loop invariant expressions.  */\n+\n+static hashval_t\n+htab_inv_expr_hash (const void *ent)\n+{\n+  const struct iv_inv_expr_ent *expr =\n+      (const struct iv_inv_expr_ent *)ent;\n+  return expr->hash;\n+}\n+\n /* Initializes data structures used by the iv optimization pass, stored\n    in DATA.  */\n \n@@ -790,6 +854,9 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->niters = NULL;\n   data->iv_uses = VEC_alloc (iv_use_p, heap, 20);\n   data->iv_candidates = VEC_alloc (iv_cand_p, heap, 20);\n+  data->inv_expr_tab = htab_create (10, htab_inv_expr_hash,\n+                                    htab_inv_expr_eq, free);\n+  data->inv_expr_id = 0;\n   decl_rtl_to_reset = VEC_alloc (tree, heap, 20);\n }\n \n@@ -1840,7 +1907,7 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n       phi = gsi_stmt (psi);\n       def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n       if (is_gimple_reg (def))\n-\tfind_interesting_uses_op (data, def);\n+        find_interesting_uses_op (data, def);\n     }\n }\n \n@@ -2157,7 +2224,9 @@ add_candidate_1 (struct ivopts_data *data,\n \tcontinue;\n \n       if (operand_equal_p (base, cand->iv->base, 0)\n-\t  && operand_equal_p (step, cand->iv->step, 0))\n+\t  && operand_equal_p (step, cand->iv->step, 0)\n+          && (TYPE_PRECISION (TREE_TYPE (base))\n+              == TYPE_PRECISION (TREE_TYPE (cand->iv->base))))\n \tbreak;\n     }\n \n@@ -2571,7 +2640,8 @@ infinite_cost_p (comp_cost cost)\n static void\n set_use_iv_cost (struct ivopts_data *data,\n \t\t struct iv_use *use, struct iv_cand *cand,\n-\t\t comp_cost cost, bitmap depends_on, tree value)\n+\t\t comp_cost cost, bitmap depends_on, tree value,\n+                 int inv_expr_id)\n {\n   unsigned i, s;\n \n@@ -2587,6 +2657,7 @@ set_use_iv_cost (struct ivopts_data *data,\n       use->cost_map[cand->id].cost = cost;\n       use->cost_map[cand->id].depends_on = depends_on;\n       use->cost_map[cand->id].value = value;\n+      use->cost_map[cand->id].inv_expr_id = inv_expr_id;\n       return;\n     }\n \n@@ -2606,6 +2677,7 @@ set_use_iv_cost (struct ivopts_data *data,\n   use->cost_map[i].cost = cost;\n   use->cost_map[i].depends_on = depends_on;\n   use->cost_map[i].value = value;\n+  use->cost_map[i].inv_expr_id = inv_expr_id;\n }\n \n /* Gets cost of (USE, CANDIDATE) pair.  */\n@@ -2956,7 +3028,7 @@ adjust_setup_cost (struct ivopts_data *data, unsigned cost)\n   if (cost == INFTY)\n     return cost;\n   else if (optimize_loop_for_speed_p (data->current_loop))\n-    return cost / AVG_LOOP_NITER (data->current_loop);\n+    return cost / avg_loop_niter (data->current_loop);\n   else\n     return cost;\n }\n@@ -3171,7 +3243,7 @@ get_address_cost (bool symbol_present, bool var_present,\n       HOST_WIDE_INT i;\n       HOST_WIDE_INT start = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n       HOST_WIDE_INT rat, off;\n-      int old_cse_not_expected;\n+      int old_cse_not_expected, width;\n       unsigned sym_p, var_p, off_p, rat_p, add_c;\n       rtx seq, addr, base;\n       rtx reg0, reg1;\n@@ -3180,8 +3252,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n \n+      width = (GET_MODE_BITSIZE (address_mode) <  HOST_BITS_PER_WIDE_INT - 2)\n+          ? GET_MODE_BITSIZE (address_mode) : HOST_BITS_PER_WIDE_INT - 2;\n       addr = gen_rtx_fmt_ee (PLUS, address_mode, reg1, NULL_RTX);\n-      for (i = start; i <= 1 << 20; i <<= 1)\n+      for (i = start; i <= 1ll << width; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, address_mode);\n \t  if (!memory_address_addr_space_p (mem_mode, addr, as))\n@@ -3190,7 +3264,7 @@ get_address_cost (bool symbol_present, bool var_present,\n       data->max_offset = i == start ? 0 : i >> 1;\n       off = data->max_offset;\n \n-      for (i = start; i <= 1 << 20; i <<= 1)\n+      for (i = start; i <= 1ll << width; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (-i, address_mode);\n \t  if (!memory_address_addr_space_p (mem_mode, addr, as))\n@@ -3201,12 +3275,12 @@ get_address_cost (bool symbol_present, bool var_present,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"get_address_cost:\\n\");\n-\t  fprintf (dump_file, \"  min offset %s %d\\n\",\n+\t  fprintf (dump_file, \"  min offset %s \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t   GET_MODE_NAME (mem_mode),\n-\t\t   (int) data->min_offset);\n-\t  fprintf (dump_file, \"  max offset %s %d\\n\",\n+\t\t   data->min_offset);\n+\t  fprintf (dump_file, \"  max offset %s \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t   GET_MODE_NAME (mem_mode),\n-\t\t   (int) data->max_offset);\n+\t\t   data->max_offset);\n \t}\n \n       rat = 1;\n@@ -3717,6 +3791,144 @@ difference_cost (struct ivopts_data *data,\n   return force_var_cost (data, aff_combination_to_tree (&aff_e1), depends_on);\n }\n \n+/* Returns true if AFF1 and AFF2 are identical.  */\n+\n+static bool\n+compare_aff_trees (aff_tree *aff1, aff_tree *aff2)\n+{\n+  unsigned i;\n+\n+  if (aff1->n != aff2->n)\n+    return false;\n+\n+  for (i = 0; i < aff1->n; i++)\n+    {\n+      if (double_int_cmp (aff1->elts[i].coef, aff2->elts[i].coef, 0) != 0)\n+        return false;\n+\n+      if (!operand_equal_p (aff1->elts[i].val, aff2->elts[i].val, 0))\n+        return false;\n+    }\n+  return true;\n+}\n+\n+/* Returns the pseudo expr id if expression UBASE - RATIO * CBASE\n+   requires a new compiler generated temporary.  Returns -1 otherwise.\n+   ADDRESS_P is a flag indicating if the expression is for address\n+   computation.  */\n+\n+static int\n+get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n+                            tree cbase, HOST_WIDE_INT ratio,\n+                            bool address_p)\n+{\n+  aff_tree ubase_aff, cbase_aff;\n+  tree expr, ub, cb;\n+  struct iv_inv_expr_ent ent;\n+  struct iv_inv_expr_ent **slot;\n+\n+  STRIP_NOPS (ubase);\n+  STRIP_NOPS (cbase);\n+  ub = ubase;\n+  cb = cbase;\n+\n+  if ((TREE_CODE (ubase) == INTEGER_CST)\n+      && (TREE_CODE (cbase) == INTEGER_CST))\n+    return -1;\n+\n+  /* Strips the constant part. */\n+  if (TREE_CODE (ubase) == PLUS_EXPR\n+      || TREE_CODE (ubase) == MINUS_EXPR\n+      || TREE_CODE (ubase) == POINTER_PLUS_EXPR)\n+    {\n+      if (TREE_CODE (TREE_OPERAND (ubase, 1)) == INTEGER_CST)\n+        ubase = TREE_OPERAND (ubase, 0);\n+    }\n+\n+  /* Strips the constant part. */\n+  if (TREE_CODE (cbase) == PLUS_EXPR\n+      || TREE_CODE (cbase) == MINUS_EXPR\n+      || TREE_CODE (cbase) == POINTER_PLUS_EXPR)\n+    {\n+      if (TREE_CODE (TREE_OPERAND (cbase, 1)) == INTEGER_CST)\n+        cbase = TREE_OPERAND (cbase, 0);\n+    }\n+\n+  if (address_p)\n+    {\n+      if (((TREE_CODE (ubase) == SSA_NAME)\n+           || (TREE_CODE (ubase) == ADDR_EXPR\n+               && is_gimple_min_invariant (ubase)))\n+          && (TREE_CODE (cbase) == INTEGER_CST))\n+        return -1;\n+\n+      if (((TREE_CODE (cbase) == SSA_NAME)\n+           || (TREE_CODE (cbase) == ADDR_EXPR\n+               && is_gimple_min_invariant (cbase)))\n+          && (TREE_CODE (ubase) == INTEGER_CST))\n+        return -1;\n+    }\n+\n+  if (ratio == 1)\n+    {\n+      if(operand_equal_p (ubase, cbase, 0))\n+        return -1;\n+\n+      if (TREE_CODE (ubase) == ADDR_EXPR\n+          && TREE_CODE (cbase) == ADDR_EXPR)\n+        {\n+          tree usym, csym;\n+\n+          usym = TREE_OPERAND (ubase, 0);\n+          csym = TREE_OPERAND (cbase, 0);\n+          if (TREE_CODE (usym) == ARRAY_REF)\n+            {\n+              tree ind = TREE_OPERAND (usym, 1);\n+              if (TREE_CODE (ind) == INTEGER_CST\n+                  && host_integerp (ind, 0)\n+                  && TREE_INT_CST_LOW (ind) == 0)\n+                usym = TREE_OPERAND (usym, 0);\n+            }\n+          if (TREE_CODE (csym) == ARRAY_REF)\n+            {\n+              tree ind = TREE_OPERAND (csym, 1);\n+              if (TREE_CODE (ind) == INTEGER_CST\n+                  && host_integerp (ind, 0)\n+                  && TREE_INT_CST_LOW (ind) == 0)\n+                csym = TREE_OPERAND (csym, 0);\n+            }\n+          if (operand_equal_p (usym, csym, 0))\n+            return -1;\n+        }\n+      /* Now do more complex comparison  */\n+      tree_to_aff_combination (ubase, TREE_TYPE (ubase), &ubase_aff);\n+      tree_to_aff_combination (cbase, TREE_TYPE (cbase), &cbase_aff);\n+      if (compare_aff_trees (&ubase_aff, &cbase_aff))\n+        return -1;\n+    }\n+\n+  tree_to_aff_combination (ub, TREE_TYPE (ub), &ubase_aff);\n+  tree_to_aff_combination (cb, TREE_TYPE (cb), &cbase_aff);\n+\n+  aff_combination_scale (&cbase_aff, shwi_to_double_int (-1 * ratio));\n+  aff_combination_add (&ubase_aff, &cbase_aff);\n+  expr = aff_combination_to_tree (&ubase_aff);\n+  ent.expr = expr;\n+  ent.hash = iterative_hash_expr (expr, 0);\n+  slot = (struct iv_inv_expr_ent **) htab_find_slot (data->inv_expr_tab,\n+                                                     &ent, INSERT);\n+  if (*slot)\n+    return (*slot)->id;\n+\n+  *slot = XNEW (struct iv_inv_expr_ent);\n+  (*slot)->expr = expr;\n+  (*slot)->hash = ent.hash;\n+  (*slot)->id = data->inv_expr_id++;\n+  return  (*slot)->id;\n+}\n+\n+\n+\n /* Determines the cost of the computation by that USE is expressed\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n    to create an address from it, otherwise we want to get it into\n@@ -3729,7 +3941,8 @@ static comp_cost\n get_computation_cost_at (struct ivopts_data *data,\n \t\t\t struct iv_use *use, struct iv_cand *cand,\n \t\t\t bool address_p, bitmap *depends_on, gimple at,\n-\t\t\t bool *can_autoinc)\n+\t\t\t bool *can_autoinc,\n+                         int *inv_expr_id)\n {\n   tree ubase = use->iv->base, ustep = use->iv->step;\n   tree cbase, cstep;\n@@ -3812,13 +4025,15 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t      ubase, build_int_cst (utype, 0),\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n+      cost.cost /= avg_loop_niter (data->current_loop);\n     }\n   else if (ratio == 1)\n     {\n       cost = difference_cost (data,\n \t\t\t      ubase, cbase,\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n+      cost.cost /= avg_loop_niter (data->current_loop);\n     }\n   else if (address_p\n \t   && !POINTER_TYPE_P (ctype)\n@@ -3832,16 +4047,27 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t      ubase, cbase,\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n+      cost.cost /= avg_loop_niter (data->current_loop);\n     }\n   else\n     {\n       cost = force_var_cost (data, cbase, depends_on);\n-      cost.cost += add_cost (TYPE_MODE (ctype), data->speed);\n       cost = add_costs (cost,\n \t\t\tdifference_cost (data,\n \t\t\t\t\t ubase, build_int_cst (utype, 0),\n \t\t\t\t\t &symbol_present, &var_present,\n \t\t\t\t\t &offset, depends_on));\n+      cost.cost /= avg_loop_niter (data->current_loop);\n+      cost.cost += add_cost (TYPE_MODE (ctype), data->speed);\n+    }\n+\n+  if (inv_expr_id)\n+    {\n+      *inv_expr_id =\n+          get_loop_invariant_expr_id (data, ubase, cbase, ratio, address_p);\n+      /* Clear depends on.  */\n+      if (*inv_expr_id != -1 && depends_on && *depends_on)\n+        bitmap_clear (*depends_on);\n     }\n \n   /* If we are after the increment, the value of the candidate is higher by\n@@ -3916,11 +4142,12 @@ get_computation_cost_at (struct ivopts_data *data,\n static comp_cost\n get_computation_cost (struct ivopts_data *data,\n \t\t      struct iv_use *use, struct iv_cand *cand,\n-\t\t      bool address_p, bitmap *depends_on, bool *can_autoinc)\n+\t\t      bool address_p, bitmap *depends_on,\n+                      bool *can_autoinc, int *inv_expr_id)\n {\n   return get_computation_cost_at (data,\n \t\t\t\t  use, cand, address_p, depends_on, use->stmt,\n-\t\t\t\t  can_autoinc);\n+\t\t\t\t  can_autoinc, inv_expr_id);\n }\n \n /* Determines cost of basing replacement of USE on CAND in a generic\n@@ -3932,6 +4159,7 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n {\n   bitmap depends_on;\n   comp_cost cost;\n+  int inv_expr_id = -1;\n \n   /* The simple case first -- if we need to express value of the preserved\n      original biv, the cost is 0.  This also prevents us from counting the\n@@ -3940,12 +4168,15 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n-      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE);\n+      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE, -1);\n       return true;\n     }\n \n-  cost = get_computation_cost (data, use, cand, false, &depends_on, NULL);\n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n+  cost = get_computation_cost (data, use, cand, false, &depends_on,\n+                               NULL, &inv_expr_id);\n+\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE,\n+                   inv_expr_id);\n \n   return !infinite_cost_p (cost);\n }\n@@ -3958,8 +4189,9 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n {\n   bitmap depends_on;\n   bool can_autoinc;\n+  int inv_expr_id = -1;\n   comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on,\n-\t\t\t\t\t &can_autoinc);\n+\t\t\t\t\t &can_autoinc, &inv_expr_id);\n \n   if (cand->ainc_use == use)\n     {\n@@ -3971,7 +4203,8 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n       else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)\n \tcost = infinite_cost;\n     }\n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE,\n+                   inv_expr_id);\n \n   return !infinite_cost_p (cost);\n }\n@@ -4151,12 +4384,13 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   bitmap depends_on_elim = NULL, depends_on_express = NULL, depends_on;\n   comp_cost elim_cost, express_cost, cost;\n   bool ok;\n+  int inv_expr_id = -1;\n   tree *control_var, *bound_cst;\n \n   /* Only consider real candidates.  */\n   if (!cand->iv)\n     {\n-      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE);\n+      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE, -1);\n       return false;\n     }\n \n@@ -4190,7 +4424,8 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n     elim_cost.cost -= 1;\n \n   express_cost = get_computation_cost (data, use, cand, false,\n-\t\t\t\t       &depends_on_express, NULL);\n+\t\t\t\t       &depends_on_express, NULL,\n+                                       &inv_expr_id);\n   fd_ivopts_data = data;\n   walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n \n@@ -4209,7 +4444,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       bound = NULL_TREE;\n     }\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on, bound);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, bound, inv_expr_id);\n \n   if (depends_on_elim)\n     BITMAP_FREE (depends_on_elim);\n@@ -4257,7 +4492,7 @@ autoinc_possible_for_pair (struct ivopts_data *data, struct iv_use *use,\n     return false;\n \n   cost = get_computation_cost (data, use, cand, true, &depends_on,\n-\t\t\t       &can_autoinc);\n+\t\t\t       &can_autoinc, NULL);\n \n   BITMAP_FREE (depends_on);\n \n@@ -4381,6 +4616,8 @@ determine_use_iv_costs (struct ivopts_data *data)\n \t      if (use->cost_map[j].depends_on)\n \t\tbitmap_print (dump_file,\n \t\t\t      use->cost_map[j].depends_on, \"\",\"\");\n+              if (use->cost_map[j].inv_expr_id != -1)\n+                fprintf (dump_file, \" inv_expr:%d\", use->cost_map[j].inv_expr_id);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n@@ -4556,14 +4793,54 @@ cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n   return false;\n }\n \n+\n+/* Returns candidate by that USE is expressed in IVS.  */\n+\n+static struct cost_pair *\n+iv_ca_cand_for_use (struct iv_ca *ivs, struct iv_use *use)\n+{\n+  return ivs->cand_for_use[use->id];\n+}\n+\n+\n+/* Returns the number of temps needed for new loop invariant\n+   expressions.  */\n+\n+static int\n+iv_ca_get_num_inv_exprs (struct ivopts_data *data, struct iv_ca *ivs)\n+{\n+  unsigned i, n = 0;\n+  unsigned *used_inv_expr = XCNEWVEC (unsigned, data->inv_expr_id + 1);\n+\n+  for (i = 0; i < ivs->upto; i++)\n+    {\n+      struct iv_use *use = iv_use (data, i);\n+      struct cost_pair *cp = iv_ca_cand_for_use (ivs, use);\n+      if (cp && cp->inv_expr_id != -1)\n+        {\n+          used_inv_expr[cp->inv_expr_id]++;\n+          if (used_inv_expr[cp->inv_expr_id] == 1)\n+            n++;\n+        }\n+    }\n+\n+  free (used_inv_expr);\n+  return n;\n+}\n+\n /* Computes the cost field of IVS structure.  */\n \n static void\n iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n {\n+  unsigned n_inv_exprs = 0;\n   comp_cost cost = ivs->cand_use_cost;\n+\n   cost.cost += ivs->cand_cost;\n-  cost.cost += ivopts_global_cost_for_size (data, ivs->n_regs);\n+\n+  n_inv_exprs = iv_ca_get_num_inv_exprs (data, ivs);\n+  cost.cost += ivopts_global_cost_for_size (data,\n+                                            ivs->n_regs + n_inv_exprs);\n \n   ivs->cost = cost;\n }\n@@ -4583,7 +4860,7 @@ iv_ca_set_remove_invariants (struct iv_ca *ivs, bitmap invs)\n     {\n       ivs->n_invariant_uses[iid]--;\n       if (ivs->n_invariant_uses[iid] == 0)\n-\tivs->n_regs--;\n+        ivs->n_regs--;\n     }\n }\n \n@@ -4638,7 +4915,7 @@ iv_ca_set_add_invariants (struct iv_ca *ivs, bitmap invs)\n     {\n       ivs->n_invariant_uses[iid]++;\n       if (ivs->n_invariant_uses[iid] == 1)\n-\tivs->n_regs++;\n+        ivs->n_regs++;\n     }\n }\n \n@@ -4682,14 +4959,16 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n }\n \n /* Extend set IVS by expressing USE by some of the candidates in it\n-   if possible.  */\n+   if possible. All important candidates will be considered\n+   if IMPORTANT_CANDIDATES is true.  */\n \n static void\n iv_ca_add_use (struct ivopts_data *data, struct iv_ca *ivs,\n-\t       struct iv_use *use)\n+\t       struct iv_use *use, bool important_candidates)\n {\n   struct cost_pair *best_cp = NULL, *cp;\n   bitmap_iterator bi;\n+  bitmap cands;\n   unsigned i;\n \n   gcc_assert (ivs->upto >= use->id);\n@@ -4700,9 +4979,12 @@ iv_ca_add_use (struct ivopts_data *data, struct iv_ca *ivs,\n       ivs->bad_uses++;\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, i, bi)\n+  cands = (important_candidates ? data->important_candidates : ivs->cands);\n+  EXECUTE_IF_SET_IN_BITMAP (cands, 0, i, bi)\n     {\n-      cp = get_use_iv_cost (data, use, iv_cand (data, i));\n+      struct iv_cand *cand = iv_cand (data, i);\n+\n+      cp = get_use_iv_cost (data, use, cand);\n \n       if (cheaper_cost_pair (cp, best_cp))\n \tbest_cp = cp;\n@@ -4782,14 +5064,6 @@ iv_ca_delta_join (struct iv_ca_delta *l1, struct iv_ca_delta *l2)\n   return l1;\n }\n \n-/* Returns candidate by that USE is expressed in IVS.  */\n-\n-static struct cost_pair *\n-iv_ca_cand_for_use (struct iv_ca *ivs, struct iv_use *use)\n-{\n-  return ivs->cand_for_use[use->id];\n-}\n-\n /* Reverse the list of changes DELTA, forming the inverse to it.  */\n \n static struct iv_ca_delta *\n@@ -4913,26 +5187,40 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n   unsigned i;\n   comp_cost cost = iv_ca_cost (ivs);\n \n-  fprintf (file, \"  cost %d (complexity %d)\\n\", cost.cost, cost.complexity);\n-  bitmap_print (file, ivs->cands, \"  candidates \",\"\\n\");\n+  fprintf (file, \"  cost: %d (complexity %d)\\n\", cost.cost, cost.complexity);\n+  fprintf (file, \"  cand_cost: %d\\n  cand_use_cost: %d (complexity %d)\\n\",\n+           ivs->cand_cost, ivs->cand_use_cost.cost, ivs->cand_use_cost.complexity);\n+  bitmap_print (file, ivs->cands, \"  candidates: \",\"\\n\");\n+\n+   for (i = 0; i < ivs->upto; i++)\n+    {\n+      struct iv_use *use = iv_use (data, i);\n+      struct cost_pair *cp = iv_ca_cand_for_use (ivs, use);\n+      if (cp)\n+        fprintf (file, \"   use:%d --> iv_cand:%d, cost=(%d,%d)\\n\",\n+                 use->id, cp->cand->id, cp->cost.cost, cp->cost.complexity);\n+      else\n+        fprintf (file, \"   use:%d --> ??\\n\", use->id);\n+    }\n \n   for (i = 1; i <= data->max_inv_id; i++)\n     if (ivs->n_invariant_uses[i])\n       {\n \tfprintf (file, \"%s%d\", pref, i);\n \tpref = \", \";\n       }\n-  fprintf (file, \"\\n\");\n+  fprintf (file, \"\\n\\n\");\n }\n \n /* Try changing candidate in IVS to CAND for each use.  Return cost of the\n    new set, and store differences in DELTA.  Number of induction variables\n-   in the new set is stored to N_IVS.  */\n+   in the new set is stored to N_IVS. MIN_NCAND is a flag. When it is true\n+   the function will try to find a solution with mimimal iv candidates.  */\n \n static comp_cost\n iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n \t      struct iv_cand *cand, struct iv_ca_delta **delta,\n-\t      unsigned *n_ivs)\n+\t      unsigned *n_ivs, bool min_ncand)\n {\n   unsigned i;\n   comp_cost cost;\n@@ -4953,11 +5241,11 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n       if (!new_cp)\n \tcontinue;\n \n-      if (!iv_ca_has_deps (ivs, new_cp))\n+      if (!min_ncand && !iv_ca_has_deps (ivs, new_cp))\n \tcontinue;\n \n-      if (!cheaper_cost_pair (new_cp, old_cp))\n-\tcontinue;\n+      if (!min_ncand && !cheaper_cost_pair (new_cp, old_cp))\n+        continue;\n \n       *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);\n     }\n@@ -5008,8 +5296,9 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t      cp = get_use_iv_cost (data, use, cnd);\n \t      if (!cp)\n \t\tcontinue;\n+\n \t      if (!iv_ca_has_deps (ivs, cp))\n-\t\tcontinue;\n+                continue; \n \n \t      if (!cheaper_cost_pair (cp, new_cp))\n \t\tcontinue;\n@@ -5121,10 +5410,18 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n   struct iv_ca_delta *best_delta = NULL, *act_delta;\n   struct cost_pair *cp;\n \n-  iv_ca_add_use (data, ivs, use);\n+  iv_ca_add_use (data, ivs, use, false);\n   best_cost = iv_ca_cost (ivs);\n \n   cp = iv_ca_cand_for_use (ivs, use);\n+  if (!cp)\n+    {\n+      ivs->upto--;\n+      ivs->bad_uses--;\n+      iv_ca_add_use (data, ivs, use, true);\n+      best_cost = iv_ca_cost (ivs);\n+      cp = iv_ca_cand_for_use (ivs, use);\n+    }\n   if (cp)\n     {\n       best_delta = iv_ca_delta_add (use, NULL, cp, NULL);\n@@ -5151,14 +5448,15 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \tcontinue;\n \n       if (iv_ca_cand_used_p (ivs, cand))\n-\tcontinue;\n+        continue;\n \n       cp = get_use_iv_cost (data, use, cand);\n       if (!cp)\n \tcontinue;\n \n       iv_ca_set_cp (data, ivs, use, cp);\n-      act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL);\n+      act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL,\n+                               true);\n       iv_ca_set_no_cp (data, ivs, use);\n       act_delta = iv_ca_delta_add (use, NULL, cp, act_delta);\n \n@@ -5196,7 +5494,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \n \t  act_delta = NULL;\n \t  iv_ca_set_cp (data, ivs, use, cp);\n-\t  act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL);\n+\t  act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL, true);\n \t  iv_ca_set_no_cp (data, ivs, use);\n \t  act_delta = iv_ca_delta_add (use, iv_ca_cand_for_use (ivs, use),\n \t\t\t\t       cp, act_delta);\n@@ -5256,7 +5554,7 @@ try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n       if (iv_ca_cand_used_p (ivs, cand))\n \tcontinue;\n \n-      acost = iv_ca_extend (data, ivs, cand, &act_delta, &n_ivs);\n+      acost = iv_ca_extend (data, ivs, cand, &act_delta, &n_ivs, false);\n       if (!act_delta)\n \tcontinue;\n \n@@ -5416,7 +5714,6 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)\n \n       /* Rewrite the increment so that it uses var_before directly.  */\n       find_interesting_uses_op (data, cand->var_after)->selected = cand;\n-\n       return;\n     }\n \n@@ -5444,8 +5741,18 @@ create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n       cand = iv_cand (data, i);\n       create_new_iv (data, cand);\n     }\n-}\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nSelected IV set: \\n\");\n+      EXECUTE_IF_SET_IN_BITMAP (set->cands, 0, i, bi)\n+        {\n+          cand = iv_cand (data, i);\n+          dump_cand (dump_file, cand);\n+        }\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n \n /* Rewrites USE (definition of iv used in a nonlinear expression)\n    using candidate CAND.  */\n@@ -5795,6 +6102,11 @@ rewrite_use_compare (struct ivopts_data *data,\n       tree var_type = TREE_TYPE (var);\n       gimple_seq stmts;\n \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        {\n+          fprintf (dump_file, \"Replacing exit test: \");\n+          print_gimple_stmt (dump_file, use->stmt, 0, TDF_SLIM);\n+        }\n       compare = iv_elimination_compare (data, use);\n       bound = unshare_expr (fold_convert (var_type, bound));\n       op = force_gimple_operand (bound, &stmts, true, NULL_TREE);\n@@ -5979,6 +6291,9 @@ free_loop_data (struct ivopts_data *data)\n     SET_DECL_RTL (obj, NULL_RTX);\n \n   VEC_truncate (tree, decl_rtl_to_reset, 0);\n+\n+  htab_empty (data->inv_expr_tab);\n+  data->inv_expr_id = 0;\n }\n \n /* Finalizes data structures used by the iv optimization pass.  LOOPS is the\n@@ -5995,6 +6310,7 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   VEC_free (tree, heap, decl_rtl_to_reset);\n   VEC_free (iv_use_p, heap, data->iv_uses);\n   VEC_free (iv_cand_p, heap, data->iv_candidates);\n+  htab_delete (data->inv_expr_tab);\n }\n \n /* Returns true if the loop body BODY includes any function calls.  */"}]}