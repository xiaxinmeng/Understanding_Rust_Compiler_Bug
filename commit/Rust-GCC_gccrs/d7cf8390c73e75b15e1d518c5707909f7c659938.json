{"sha": "d7cf8390c73e75b15e1d518c5707909f7c659938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjZjgzOTBjNzNlNzViMTVlMWQ1MThjNTcwNzkwOWY3YzY1OTkzOA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2005-05-24T20:48:25Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2005-05-24T20:48:25Z"}, "message": "libiberty.h (ACONCAT): Properly cast value of alloca().\n\ninclude/\n2005-05-24  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\t* libiberty.h (ACONCAT): Properly cast value of alloca().\n\n\t* ansidecl.h (ATTRIBUTE_UNUSED_LABEL): Don't define if\n\t__cplusplus.\n\nlibiberty/\n2005-05-24  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\t* configure.ac: Check declarations for calloc(), getenv(),\n\tmalloc(), realloc() and sbrk().\n\t* config.in: Regenerate.\n\t* configure: Likewise.\n\n\t* alloca.c (C_alloca): Change \"new\" to \"new_storage\".  Use XNEWVEC\n\tinstead of xmalloc.\n\t* choose-temp.c (choose_temp_base): Use XNEWVEC instea od xmalloc.\n\t* concat.c (liiberty_concat_ptr): Surround definition with an\n\textern \"C\" block, if __cplusplus.\n\t(concat): Use XNEWVEC instead of xmalloc.\n\t(reconcat): Likewise.\n\t* cp-demangle.c (struct d_print_template): Rename member\n\t\"template\" to \"template_decl\".  Adjust use throughout the file.\n\t(d_print_resize): Properly cast return value of realloc().\n\t(cplus_demangle_print): Same for malloc().\n\t(d_demangle): Likewise.\n\t* cp-demint.c (cplus_demangle_fill_builtin_type): Rename parameter\n\t\"typename\" to \"type_name\".\n\t* cplus-dem.c (grow_vect): Use XRESIZEVEC instead of xrealloc().\n\t(work_stuff_copy_to_from): Use XNEWVEC insteand of xmalloc().\n\t(demangle_template_value_parm): Likewise.\n\t(demangle_template): Likewise.\n\t(recursively_demangle): Likewise.\n\t(do_hpacc_template_literal): Likewise.\n\t(do_arg): Likewise.\n\t(remember_type): Likewise.\n\t(remember_Ktype): Likewise.\n\t(register_Btype): Likewise.\n\t(string_need): Use XRESIZEVEC instead of xrealloc().\n\t* dyn-string.c (dyn_string_init): Use XNEWVEC.\n\t(dyn_string_new): Use XNEW.\n\t(dyn_string_resize): Use XRESIZEVEC.\n\t* fnmatch.c (fnmatch): Rename local variable \"not\" to \"negate\".\n\t* getopt.c (getenv): Declare only if !__cplusplus and !getenv.\n\tOtherwise include <stdlib.h>.\n\t(exchange): Cast return value of malloc().\n\t* hashtab.c (htab_size): Define as both macro and non-inline\n\tfunction.\n\t(htab_elements): Likewise.\n\t* getpwd.c (getpwd): Use XNEWVEC.\n\t(htab_create_alloc_ex): Use C90 prototype-style.\n\t* lrealpath.c (lrealpath): Appropriately cast return value of\n\tmalloc().\n\t* make-relative-prefix.c (save_string): Likewise.\n\t* make-temp-file.c (try_dir): Rename from \"try\".  Adjust use in\n\tthe file.\n\t(choose_tmpdir): Use XNEWVEC.\n\t* mkstemps.c (mkstemps): Rename parameter \"template\" to \"pattern\".\n\t* pex-common.c (pex_init_common): Use XNEW.\n\t(pex_add_remove): Use XRESIZEVEC.\n\t(pex_run): Likewise.\n\t(pex_get_status_and_time): Likewise.\n\t* pex-djgpp.c (pex_djgpp_exec_child): Likewise.\n\t* pex-msdos.c (pex_init): Use XNEW.\n\t(pex_msdos_exec_child): Likewise.\n\t(pex_msdos_exec_child): Use XRESIZEVEC.\n\t* pex-unix.c (pex_wait): Use XNEW.\n\t* pex-win32.c (fix_argv): Use XNEWVEC.\n\t* pexecute.c (pwait): Likewise.\n\t* setenv.c (setenv): Properly cast return value of malloc().\n\t* sigsetmask.c (sigsetmask): Rename local variables \"old\" and\n\t\"new\" to \"old_sig\" and \"new_sig\".\n\t* sort.c (main): Use XNEWVEC.\n\t* spaces.c (spaces): Cast return value of malloc().\n\t* strndup.c (strndup): Likewise.\n\t* ternary.c (ternary_insert): Use XNEW.\n\t* xmalloc.c (malloc, realloc, calloc, sbrk): Surround declaration\n\twith an extern \"C\" block if __cplusplus.\n\t* xstrdup.c (xstrdup): Cast return value of memcpy().\n\t* xstrerror.c (strerror): Enclose declaration in an extern \"C\"\n\tblock if __cplusplus.\n\t* xstrndup.c (xstrndup): Use XNEW. Cast return value of memcpy().\n\nFrom-SVN: r100115", "tree": {"sha": "13f97526feeefc5d61bc37b423b5369846d3427a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13f97526feeefc5d61bc37b423b5369846d3427a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7cf8390c73e75b15e1d518c5707909f7c659938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cf8390c73e75b15e1d518c5707909f7c659938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cf8390c73e75b15e1d518c5707909f7c659938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cf8390c73e75b15e1d518c5707909f7c659938/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de3e06c62ca45ae267274fdd7942e9b10375097b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3e06c62ca45ae267274fdd7942e9b10375097b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de3e06c62ca45ae267274fdd7942e9b10375097b"}], "stats": {"total": 806, "additions": 651, "deletions": 155}, "files": [{"sha": "5265c311b8542671091463954c365d23b034748d", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -1,3 +1,10 @@\n+2005-05-24  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* libiberty.h (ACONCAT): Properly cast value of alloca().\n+\n+\t* ansidecl.h (ATTRIBUTE_UNUSED_LABEL): Don't define if\n+\t__cplusplus. \n+\n 2005-05-12  Steve Ellcey  <sje@cup.hp.com>\n \n \tlibiberty.h: Do not define empty basename prototype."}, {"sha": "380e7b35114cbbfa08a9bdcd9357f30c2b91a1a9", "filename": "include/ansidecl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/include%2Fansidecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/include%2Fansidecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fansidecl.h?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -258,11 +258,11 @@ So instead we use the macro below and test it against specific values.  */\n \n /* Attributes on labels were valid as of gcc 2.93. */\n #ifndef ATTRIBUTE_UNUSED_LABEL\n-# if (GCC_VERSION >= 2093)\n+# if (!defined (__cplusplus) && GCC_VERSION >= 2093)\n #  define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED\n # else\n #  define ATTRIBUTE_UNUSED_LABEL\n-# endif /* GNUC >= 2.93 */\n+# endif /* !__cplusplus && GNUC >= 2.93 */\n #endif /* ATTRIBUTE_UNUSED_LABEL */\n \n #ifndef ATTRIBUTE_UNUSED"}, {"sha": "9af981cd74ea95e73f11d28322d348aca2ef5bc1", "filename": "include/libiberty.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -156,7 +156,7 @@ extern char *libiberty_concat_ptr;\n    strings.  Allocates memory using alloca.  The arguments are\n    evaluated twice!  */\n #define ACONCAT(ACONCAT_PARAMS) \\\n-  (libiberty_concat_ptr = alloca (concat_length ACONCAT_PARAMS + 1), \\\n+  (libiberty_concat_ptr = (char *) alloca (concat_length ACONCAT_PARAMS + 1), \\\n    concat_copy2 ACONCAT_PARAMS)\n \n /* Check whether two file descriptors refer to the same file.  */"}, {"sha": "8f034b5f272fdf2804a779f6f73c72f9abf7d618", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -1,3 +1,79 @@\n+2005-05-24  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* configure.ac: Check declarations for calloc(), getenv(),\n+\tmalloc(), realloc() and sbrk(). \n+\t* config.in: Regenerate.\n+\t* configure: Likewise.\n+\n+\t* alloca.c (C_alloca): Change \"new\" to \"new_storage\".  Use XNEWVEC\n+\tinstead of xmalloc.\n+\t* choose-temp.c (choose_temp_base): Use XNEWVEC instea od xmalloc.\n+\t* concat.c (liiberty_concat_ptr): Surround definition with an\n+\textern \"C\" block, if __cplusplus.\n+\t(concat): Use XNEWVEC instead of xmalloc.\n+\t(reconcat): Likewise.\n+\t* cp-demangle.c (struct d_print_template): Rename member\n+\t\"template\" to \"template_decl\".  Adjust use throughout the file. \n+\t(d_print_resize): Properly cast return value of realloc().\n+\t(cplus_demangle_print): Same for malloc().\n+\t(d_demangle): Likewise.\n+\t* cp-demint.c (cplus_demangle_fill_builtin_type): Rename parameter\n+\t\"typename\" to \"type_name\".\n+\t* cplus-dem.c (grow_vect): Use XRESIZEVEC instead of xrealloc().\n+\t(work_stuff_copy_to_from): Use XNEWVEC insteand of xmalloc().\n+\t(demangle_template_value_parm): Likewise.\n+\t(demangle_template): Likewise.\n+\t(recursively_demangle): Likewise.\n+\t(do_hpacc_template_literal): Likewise.\n+\t(do_arg): Likewise.\n+\t(remember_type): Likewise.\n+\t(remember_Ktype): Likewise.\n+\t(register_Btype): Likewise.\n+\t(string_need): Use XRESIZEVEC instead of xrealloc().\n+\t* dyn-string.c (dyn_string_init): Use XNEWVEC.\n+\t(dyn_string_new): Use XNEW.\n+\t(dyn_string_resize): Use XRESIZEVEC.\n+\t* fnmatch.c (fnmatch): Rename local variable \"not\" to \"negate\".\n+\t* getopt.c (getenv): Declare only if !__cplusplus and !getenv.\n+\tOtherwise include <stdlib.h>.\n+\t(exchange): Cast return value of malloc().\n+\t* hashtab.c (htab_size): Define as both macro and non-inline\n+\tfunction.\n+\t(htab_elements): Likewise.\n+\t* getpwd.c (getpwd): Use XNEWVEC.\n+\t(htab_create_alloc_ex): Use C90 prototype-style.\n+\t* lrealpath.c (lrealpath): Appropriately cast return value of\n+\tmalloc(). \n+\t* make-relative-prefix.c (save_string): Likewise.\n+\t* make-temp-file.c (try_dir): Rename from \"try\".  Adjust use in\n+\tthe file.\n+\t(choose_tmpdir): Use XNEWVEC.\n+\t* mkstemps.c (mkstemps): Rename parameter \"template\" to \"pattern\".\n+\t* pex-common.c (pex_init_common): Use XNEW.\n+\t(pex_add_remove): Use XRESIZEVEC.\n+\t(pex_run): Likewise.\n+\t(pex_get_status_and_time): Likewise.\n+\t* pex-djgpp.c (pex_djgpp_exec_child): Likewise.\n+\t* pex-msdos.c (pex_init): Use XNEW.\n+\t(pex_msdos_exec_child): Likewise.\n+\t(pex_msdos_exec_child): Use XRESIZEVEC.\n+\t* pex-unix.c (pex_wait): Use XNEW.\n+\t* pex-win32.c (fix_argv): Use XNEWVEC.\n+\t* pexecute.c (pwait): Likewise.\n+\t* setenv.c (setenv): Properly cast return value of malloc().\n+\t* sigsetmask.c (sigsetmask): Rename local variables \"old\" and\n+\t\"new\" to \"old_sig\" and \"new_sig\".\n+\t* sort.c (main): Use XNEWVEC.\n+\t* spaces.c (spaces): Cast return value of malloc().\n+\t* strndup.c (strndup): Likewise.\n+\t* ternary.c (ternary_insert): Use XNEW.\n+\t* xmalloc.c (malloc, realloc, calloc, sbrk): Surround declaration\n+\twith an extern \"C\" block if __cplusplus.\n+\t* xstrdup.c (xstrdup): Cast return value of memcpy().\n+\t* xstrerror.c (strerror): Enclose declaration in an extern \"C\"\n+\tblock if __cplusplus.\n+\t* xstrndup.c (xstrndup): Use XNEW. Cast return value of memcpy().\n+\n 2005-05-16  Andreas Jaeger  <aj@suse.de>\n \n \t* getpwd.c: Remove unneeded prototype getcwd and move getwd so"}, {"sha": "9b2e9cb12b63b494b2de76ba74ec9a04629e8202", "filename": "libiberty/alloca.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Falloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Falloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Falloca.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -57,9 +57,15 @@ the possibility of a GCC built-in function.\n \n /* These variables are used by the ASTRDUP implementation that relies\n    on C_alloca.  */\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n const char *libiberty_optr;\n char *libiberty_nptr;\n unsigned long libiberty_len;\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n \n /* If your stack is a linked list of frames, you have to\n    provide an \"address metric\" ADDRESS_FUNCTION macro.  */\n@@ -191,20 +197,20 @@ C_alloca (size_t size)\n   /* Allocate combined header + user data storage.  */\n \n   {\n-    register PTR new = xmalloc (sizeof (header) + size);\n+    register void *new_storage = XNEWVEC (char, sizeof (header) + size);\n     /* Address of header.  */\n \n-    if (new == 0)\n+    if (new_storage == 0)\n       abort();\n \n-    ((header *) new)->h.next = last_alloca_header;\n-    ((header *) new)->h.deep = depth;\n+    ((header *) new_storage)->h.next = last_alloca_header;\n+    ((header *) new_storage)->h.deep = depth;\n \n-    last_alloca_header = (header *) new;\n+    last_alloca_header = (header *) new_storage;\n \n     /* User storage begins just after header.  */\n \n-    return (PTR) ((char *) new + sizeof (header));\n+    return (PTR) ((char *) new_storage + sizeof (header));\n   }\n }\n "}, {"sha": "0cba9905d5bb9e41778d5fca5af45ecd532bfc64", "filename": "libiberty/choose-temp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fchoose-temp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fchoose-temp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fchoose-temp.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -61,7 +61,7 @@ choose_temp_base (void)\n   int len;\n \n   len = strlen (base);\n-  temp_filename = xmalloc (len + TEMP_FILE_LEN + 1);\n+  temp_filename = XNEWVEC (char, len + TEMP_FILE_LEN + 1);\n   strcpy (temp_filename, base);\n   strcpy (temp_filename + len, TEMP_FILE);\n "}, {"sha": "1f329ea0e15d69689a962dc9b16fe5152259a944", "filename": "libiberty/concat.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconcat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconcat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconcat.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -127,7 +127,13 @@ concat_copy (char *dst, const char *first, ...)\n   return save_dst;\n }\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n char *libiberty_concat_ptr;\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n \n /* @undocumented concat_copy2 */\n \n@@ -150,7 +156,7 @@ concat (const char *first, ...)\n   /* First compute the size of the result and get sufficient memory.  */\n   VA_OPEN (args, first);\n   VA_FIXEDARG (args, const char *, first);\n-  newstr = (char *) xmalloc (vconcat_length (first, args) + 1);\n+  newstr = XNEWVEC (char, vconcat_length (first, args) + 1);\n   VA_CLOSE (args);\n \n   /* Now copy the individual pieces to the result string. */\n@@ -188,7 +194,7 @@ reconcat (char *optr, const char *first, ...)\n   VA_OPEN (args, first);\n   VA_FIXEDARG (args, char *, optr);\n   VA_FIXEDARG (args, const char *, first);\n-  newstr = (char *) xmalloc (vconcat_length (first, args) + 1);\n+  newstr = XNEWVEC (char, vconcat_length (first, args) + 1);\n   VA_CLOSE (args);\n \n   /* Now copy the individual pieces to the result string. */"}, {"sha": "0c2778b916f35869d5c099e5329aecf7d84b7950", "filename": "libiberty/config.in", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.in?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -45,9 +45,29 @@\n    don't. */\n #undef HAVE_DECL_BASENAME\n \n+/* Define to 1 if you have the declaration of `calloc', and to 0 if you don't.\n+   */\n+#undef HAVE_DECL_CALLOC\n+\n /* Define to 1 if you have the declaration of `ffs', and to 0 if you don't. */\n #undef HAVE_DECL_FFS\n \n+/* Define to 1 if you have the declaration of `getenv', and to 0 if you don't.\n+   */\n+#undef HAVE_DECL_GETENV\n+\n+/* Define to 1 if you have the declaration of `malloc', and to 0 if you don't.\n+   */\n+#undef HAVE_DECL_MALLOC\n+\n+/* Define to 1 if you have the declaration of `realloc', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_REALLOC\n+\n+/* Define to 1 if you have the declaration of `sbrk', and to 0 if you don't.\n+   */\n+#undef HAVE_DECL_SBRK\n+\n /* Define to 1 if you have the declaration of `vasprintf', and to 0 if you\n    don't. */\n #undef HAVE_DECL_VASPRINTF"}, {"sha": "931989dfc95a6ba3c7ee944a75978907e7acbb87", "filename": "libiberty/configure", "status": "modified", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -7214,6 +7214,358 @@ else\n _ACEOF\n \n \n+fi\n+\n+\n+  echo \"$as_me:$LINENO: checking whether calloc is declared\" >&5\n+echo $ECHO_N \"checking whether calloc is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_calloc+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef calloc\n+  char *p = (char *) calloc;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_calloc=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_calloc=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_calloc\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_calloc\" >&6\n+if test $ac_cv_have_decl_calloc = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_CALLOC 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_CALLOC 0\n+_ACEOF\n+\n+\n+fi\n+echo \"$as_me:$LINENO: checking whether getenv is declared\" >&5\n+echo $ECHO_N \"checking whether getenv is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_getenv+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef getenv\n+  char *p = (char *) getenv;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_getenv=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_getenv=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_getenv\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_getenv\" >&6\n+if test $ac_cv_have_decl_getenv = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_GETENV 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_GETENV 0\n+_ACEOF\n+\n+\n+fi\n+echo \"$as_me:$LINENO: checking whether malloc is declared\" >&5\n+echo $ECHO_N \"checking whether malloc is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_malloc+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef malloc\n+  char *p = (char *) malloc;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_malloc=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_malloc=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_malloc\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_malloc\" >&6\n+if test $ac_cv_have_decl_malloc = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_MALLOC 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_MALLOC 0\n+_ACEOF\n+\n+\n+fi\n+echo \"$as_me:$LINENO: checking whether realloc is declared\" >&5\n+echo $ECHO_N \"checking whether realloc is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_realloc+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef realloc\n+  char *p = (char *) realloc;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_realloc=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_realloc=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_realloc\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_realloc\" >&6\n+if test $ac_cv_have_decl_realloc = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_REALLOC 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_REALLOC 0\n+_ACEOF\n+\n+\n+fi\n+echo \"$as_me:$LINENO: checking whether sbrk is declared\" >&5\n+echo $ECHO_N \"checking whether sbrk is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_sbrk+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef sbrk\n+  char *p = (char *) sbrk;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_sbrk=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_sbrk=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_sbrk\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_sbrk\" >&6\n+if test $ac_cv_have_decl_sbrk = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_SBRK 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_SBRK 0\n+_ACEOF\n+\n+\n fi\n \n "}, {"sha": "bd1e458347759833b5b48de9f4c2d6963cd4de8e", "filename": "libiberty/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.ac?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -519,6 +519,7 @@ if test -z \"${setobjs}\"; then\n \n   AC_CHECK_FUNCS($checkfuncs)\n   AC_CHECK_DECLS([basename, ffs, asprintf, vasprintf])\n+  AC_CHECK_DECLS([calloc, getenv, malloc, realloc, sbrk])\n   libiberty_NEED_DECLARATION(canonicalize_file_name)\n fi\n "}, {"sha": "856fbd42cc9abd424cb8c1eb556adcba8ce2fc4a", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -210,7 +210,7 @@ struct d_print_template\n   /* Next template on the list.  */\n   struct d_print_template *next;\n   /* This template.  */\n-  const struct demangle_component *template;\n+  const struct demangle_component *template_decl;\n };\n \n /* A list of type modifiers.  This is used while printing.  */\n@@ -2551,7 +2551,7 @@ d_print_resize (struct d_print_info *dpi, size_t add)\n       char *newbuf;\n \n       newalc = dpi->alc * 2;\n-      newbuf = realloc (dpi->buf, newalc);\n+      newbuf = (char *) realloc (dpi->buf, newalc);\n       if (newbuf == NULL)\n \t{\n \t  free (dpi->buf);\n@@ -2629,7 +2629,7 @@ cplus_demangle_print (int options, const struct demangle_component *dc,\n   dpi.options = options;\n \n   dpi.alc = estimate + 1;\n-  dpi.buf = malloc (dpi.alc);\n+  dpi.buf = (char *) malloc (dpi.alc);\n   if (dpi.buf == NULL)\n     {\n       *palc = 1;\n@@ -2730,7 +2730,7 @@ d_print_comp (struct d_print_info *dpi,\n \t  {\n \t    dpt.next = dpi->templates;\n \t    dpi->templates = &dpt;\n-\t    dpt.template = typed_name;\n+\t    dpt.template_decl = typed_name;\n \t  }\n \n \t/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n@@ -2826,7 +2826,7 @@ d_print_comp (struct d_print_info *dpi,\n \t    return;\n \t  }\n \ti = dc->u.s_number.number;\n-\tfor (a = d_right (dpi->templates->template);\n+\tfor (a = d_right (dpi->templates->template_decl);\n \t     a != NULL;\n \t     a = d_right (a))\n \t  {\n@@ -3683,7 +3683,7 @@ d_print_cast (struct d_print_info *dpi,\n \n       dpt.next = dpi->templates;\n       dpi->templates = &dpt;\n-      dpt.template = d_left (dc);\n+      dpt.template_decl = d_left (dc);\n \n       d_print_comp (dpi, d_left (d_left (dc)));\n \n@@ -3764,7 +3764,7 @@ d_demangle (const char* mangled, int options, size_t *palc)\n     {\n       char *r;\n \n-      r = malloc (40 + len - 11);\n+      r = (char *) malloc (40 + len - 11);\n       if (r == NULL)\n \t*palc = 1;\n       else"}, {"sha": "2e8f8d2d0579d8032be40e511d3c05fa4bf8f2c0", "filename": "libiberty/cp-demint.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fcp-demint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fcp-demint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demint.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -130,18 +130,18 @@ cplus_demangle_fill_component (struct demangle_component *p,\n \n int\n cplus_demangle_fill_builtin_type (struct demangle_component *p,\n-                                  const char *typename)\n+                                  const char *type_name)\n {\n   int len;\n   unsigned int i;\n \n-  if (p == NULL || typename == NULL)\n+  if (p == NULL || type_name == NULL)\n     return 0;\n-  len = strlen (typename);\n+  len = strlen (type_name);\n   for (i = 0; i < D_BUILTIN_TYPE_COUNT; ++i)\n     {\n       if (len == cplus_demangle_builtin_types[i].len\n-\t  && strcmp (typename, cplus_demangle_builtin_types[i].name) == 0)\n+\t  && strcmp (type_name, cplus_demangle_builtin_types[i].name) == 0)\n \t{\n \t  p->type = DEMANGLE_COMPONENT_BUILTIN_TYPE;\n \t  p->u.s_builtin.type = &cplus_demangle_builtin_types[i];"}, {"sha": "8b60434a8882cc22ae0cfa9f0ad2b1d82239f89e", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -892,7 +892,7 @@ grow_vect (char **old_vect, size_t *size, size_t min_size, int element_size)\n       *size *= 2;\n       if (*size < min_size)\n \t*size = min_size;\n-      *old_vect = (void *) xrealloc (*old_vect, *size * element_size);\n+      *old_vect = XRESIZEVAR (char, *old_vect, *size * element_size);\n     }\n }\n \n@@ -1102,56 +1102,52 @@ work_stuff_copy_to_from (struct work_stuff *to, struct work_stuff *from)\n \n   /* Deep-copy dynamic storage.  */\n   if (from->typevec_size)\n-    to->typevec\n-      = (char **) xmalloc (from->typevec_size * sizeof (to->typevec[0]));\n+    to->typevec = XNEWVEC (char *, from->typevec_size);\n \n   for (i = 0; i < from->ntypes; i++)\n     {\n       int len = strlen (from->typevec[i]) + 1;\n \n-      to->typevec[i] = xmalloc (len);\n+      to->typevec[i] = XNEWVEC (char, len);\n       memcpy (to->typevec[i], from->typevec[i], len);\n     }\n \n   if (from->ksize)\n-    to->ktypevec\n-      = (char **) xmalloc (from->ksize * sizeof (to->ktypevec[0]));\n+    to->ktypevec = XNEWVEC (char *, from->ksize);\n \n   for (i = 0; i < from->numk; i++)\n     {\n       int len = strlen (from->ktypevec[i]) + 1;\n \n-      to->ktypevec[i] = xmalloc (len);\n+      to->ktypevec[i] = XNEWVEC (char, len);\n       memcpy (to->ktypevec[i], from->ktypevec[i], len);\n     }\n \n   if (from->bsize)\n-    to->btypevec\n-      = (char **) xmalloc (from->bsize * sizeof (to->btypevec[0]));\n+    to->btypevec = XNEWVEC (char *, from->bsize);\n \n   for (i = 0; i < from->numb; i++)\n     {\n       int len = strlen (from->btypevec[i]) + 1;\n \n-      to->btypevec[i] = xmalloc (len);\n+      to->btypevec[i] = XNEWVEC (char , len);\n       memcpy (to->btypevec[i], from->btypevec[i], len);\n     }\n \n   if (from->ntmpl_args)\n-    to->tmpl_argvec\n-      = (char **) xmalloc (from->ntmpl_args * sizeof (to->tmpl_argvec[0]));\n+    to->tmpl_argvec = XNEWVEC (char *, from->ntmpl_args);\n \n   for (i = 0; i < from->ntmpl_args; i++)\n     {\n       int len = strlen (from->tmpl_argvec[i]) + 1;\n \n-      to->tmpl_argvec[i] = xmalloc (len);\n+      to->tmpl_argvec[i] = XNEWVEC (char, len);\n       memcpy (to->tmpl_argvec[i], from->tmpl_argvec[i], len);\n     }\n \n   if (from->previous_argument)\n     {\n-      to->previous_argument = (string*) xmalloc (sizeof (string));\n+      to->previous_argument = XNEW (string);\n       string_init (to->previous_argument);\n       string_appends (to->previous_argument, from->previous_argument);\n     }\n@@ -1895,7 +1891,7 @@ demangle_template_value_parm (struct work_stuff *work, const char **mangled,\n \t    string_appendn (s, \"0\", 1);\n \t  else\n \t    {\n-\t      char *p = xmalloc (symbol_len + 1), *q;\n+\t      char *p = XNEWVEC (char, symbol_len + 1), *q;\n \t      strncpy (p, *mangled, symbol_len);\n \t      p [symbol_len] = '\\0';\n \t      /* We use cplus_demangle here, rather than\n@@ -2001,7 +1997,7 @@ demangle_template (struct work_stuff *work, const char **mangled,\n   if (!is_type)\n     {\n       /* Create an array for saving the template argument values. */\n-      work->tmpl_argvec = (char**) xmalloc (r * sizeof (char *));\n+      work->tmpl_argvec = XNEWVEC (char *, r);\n       work->ntmpl_args = r;\n       for (i = 0; i < r; i++)\n \twork->tmpl_argvec[i] = 0;\n@@ -2026,7 +2022,7 @@ demangle_template (struct work_stuff *work, const char **mangled,\n \t\t{\n \t\t  /* Save the template argument. */\n \t\t  int len = temp.p - temp.b;\n-\t\t  work->tmpl_argvec[i] = xmalloc (len + 1);\n+\t\t  work->tmpl_argvec[i] = XNEWVEC (char, len + 1);\n \t\t  memcpy (work->tmpl_argvec[i], temp.b, len);\n \t\t  work->tmpl_argvec[i][len] = '\\0';\n \t\t}\n@@ -2054,7 +2050,7 @@ demangle_template (struct work_stuff *work, const char **mangled,\n \t\t{\n \t\t  /* Save the template argument. */\n \t\t  int len = r2;\n-\t\t  work->tmpl_argvec[i] = xmalloc (len + 1);\n+\t\t  work->tmpl_argvec[i] = XNEWVEC (char, len + 1);\n \t\t  memcpy (work->tmpl_argvec[i], *mangled, len);\n \t\t  work->tmpl_argvec[i][len] = '\\0';\n \t\t}\n@@ -2100,7 +2096,7 @@ demangle_template (struct work_stuff *work, const char **mangled,\n \t  if (!is_type)\n \t    {\n \t      int len = s->p - s->b;\n-\t      work->tmpl_argvec[i] = xmalloc (len + 1);\n+\t      work->tmpl_argvec[i] = XNEWVEC (char, len + 1);\n \t      memcpy (work->tmpl_argvec[i], s->b, len);\n \t      work->tmpl_argvec[i][len] = '\\0';\n \n@@ -2998,7 +2994,7 @@ recursively_demangle(struct work_stuff *work, const char **mangled,\n   char * recurse = (char *)NULL;\n   char * recurse_dem = (char *)NULL;\n \n-  recurse = (char *) xmalloc (namelength + 1);\n+  recurse = XNEWVEC (char, namelength + 1);\n   memcpy (recurse, *mangled, namelength);\n   recurse[namelength] = '\\000';\n \n@@ -3969,7 +3965,7 @@ do_hpacc_template_literal (struct work_stuff *work, const char **mangled,\n   string_append (result, \"&\");\n \n   /* Now recursively demangle the literal name */\n-  recurse = (char *) xmalloc (literal_len + 1);\n+  recurse = XNEWVEC (char, literal_len + 1);\n   memcpy (recurse, *mangled, literal_len);\n   recurse[literal_len] = '\\000';\n \n@@ -4071,7 +4067,7 @@ do_arg (struct work_stuff *work, const char **mangled, string *result)\n   if (work->previous_argument)\n     string_delete (work->previous_argument);\n   else\n-    work->previous_argument = (string*) xmalloc (sizeof (string));\n+    work->previous_argument = XNEW (string);\n \n   if (!do_type (work, mangled, work->previous_argument))\n     return 0;\n@@ -4095,18 +4091,16 @@ remember_type (struct work_stuff *work, const char *start, int len)\n       if (work -> typevec_size == 0)\n \t{\n \t  work -> typevec_size = 3;\n-\t  work -> typevec\n-\t    = (char **) xmalloc (sizeof (char *) * work -> typevec_size);\n+\t  work -> typevec = XNEWVEC (char *, work->typevec_size);\n \t}\n       else\n \t{\n \t  work -> typevec_size *= 2;\n \t  work -> typevec\n-\t    = (char **) xrealloc ((char *)work -> typevec,\n-\t\t\t\t  sizeof (char *) * work -> typevec_size);\n+\t    = XRESIZEVEC (char *, work->typevec, work->typevec_size);\n \t}\n     }\n-  tem = xmalloc (len + 1);\n+  tem = XNEWVEC (char, len + 1);\n   memcpy (tem, start, len);\n   tem[len] = '\\0';\n   work -> typevec[work -> ntypes++] = tem;\n@@ -4124,18 +4118,16 @@ remember_Ktype (struct work_stuff *work, const char *start, int len)\n       if (work -> ksize == 0)\n \t{\n \t  work -> ksize = 5;\n-\t  work -> ktypevec\n-\t    = (char **) xmalloc (sizeof (char *) * work -> ksize);\n+\t  work -> ktypevec = XNEWVEC (char *, work->ksize);\n \t}\n       else\n \t{\n \t  work -> ksize *= 2;\n \t  work -> ktypevec\n-\t    = (char **) xrealloc ((char *)work -> ktypevec,\n-\t\t\t\t  sizeof (char *) * work -> ksize);\n+\t    = XRESIZEVEC (char *, work->ktypevec, work->ksize);\n \t}\n     }\n-  tem = xmalloc (len + 1);\n+  tem = XNEWVEC (char, len + 1);\n   memcpy (tem, start, len);\n   tem[len] = '\\0';\n   work -> ktypevec[work -> numk++] = tem;\n@@ -4155,15 +4147,13 @@ register_Btype (struct work_stuff *work)\n       if (work -> bsize == 0)\n \t{\n \t  work -> bsize = 5;\n-\t  work -> btypevec\n-\t    = (char **) xmalloc (sizeof (char *) * work -> bsize);\n+\t  work -> btypevec = XNEWVEC (char *, work->bsize);\n \t}\n       else\n \t{\n \t  work -> bsize *= 2;\n \t  work -> btypevec\n-\t    = (char **) xrealloc ((char *)work -> btypevec,\n-\t\t\t\t  sizeof (char *) * work -> bsize);\n+\t    = XRESIZEVEC (char *, work->btypevec, work->bsize);\n \t}\n     }\n   ret = work -> numb++;\n@@ -4179,7 +4169,7 @@ remember_Btype (struct work_stuff *work, const char *start,\n {\n   char *tem;\n \n-  tem = xmalloc (len + 1);\n+  tem = XNEWVEC (char, len + 1);\n   memcpy (tem, start, len);\n   tem[len] = '\\0';\n   work -> btypevec[index] = tem;\n@@ -4600,15 +4590,15 @@ string_need (string *s, int n)\n \t{\n \t  n = 32;\n \t}\n-      s->p = s->b = xmalloc (n);\n+      s->p = s->b = XNEWVEC (char, n);\n       s->e = s->b + n;\n     }\n   else if (s->e - s->p < n)\n     {\n       tem = s->p - s->b;\n       n += tem;\n       n *= 2;\n-      s->b = xrealloc (s->b, n);\n+      s->b = XRESIZEVEC (char, s->b, n);\n       s->p = s->b + tem;\n       s->e = s->b + n;\n     }"}, {"sha": "9de50eda0e863d1f345a2994ea4327e0fc6d2f17", "filename": "libiberty/dyn-string.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fdyn-string.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -67,7 +67,7 @@ dyn_string_init (struct dyn_string *ds_struct_ptr, int space)\n   if (ds_struct_ptr->s == NULL)\n     return 0;\n #else\n-  ds_struct_ptr->s = (char *) xmalloc (space);\n+  ds_struct_ptr->s = XNEWVEC (char, space);\n #endif\n   ds_struct_ptr->allocated = space;\n   ds_struct_ptr->length = 0;\n@@ -96,7 +96,7 @@ dyn_string_new (int space)\n       return NULL;\n     }\n #else\n-  result = (dyn_string_t) xmalloc (sizeof (struct dyn_string));\n+  result = XNEW (struct dyn_string);\n   dyn_string_init (result, space);\n #endif\n   return result;\n@@ -159,7 +159,7 @@ dyn_string_resize (dyn_string_t ds, int space)\n \t  return NULL;\n \t}\n #else\n-      ds->s = (char *) xrealloc (ds->s, ds->allocated);\n+      ds->s = XRESIZEVEC (char, ds->s, ds->allocated);\n #endif\n     }\n "}, {"sha": "fc897be2c6f7d7b289d2815485034f6ab8379284", "filename": "libiberty/fnmatch.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Ffnmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Ffnmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffnmatch.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -124,7 +124,7 @@ fnmatch (const char *pattern, const char *string, int flags)\n \tcase '[':\n \t  {\n \t    /* Nonzero if the sense of the character class is inverted.  */\n-\t    register int not;\n+\t    register int negate;\n \n \t    if (*n == '\\0')\n \t      return FNM_NOMATCH;\n@@ -133,8 +133,8 @@ fnmatch (const char *pattern, const char *string, int flags)\n \t\t(n == string || ((flags & FNM_FILE_NAME) && n[-1] == '/')))\n \t      return FNM_NOMATCH;\n \n-\t    not = (*p == '!' || *p == '^');\n-\t    if (not)\n+\t    negate = (*p == '!' || *p == '^');\n+\t    if (negate)\n \t      ++p;\n \n \t    c = *p++;\n@@ -177,7 +177,7 @@ fnmatch (const char *pattern, const char *string, int flags)\n \t\tif (c == ']')\n \t\t  break;\n \t      }\n-\t    if (!not)\n+\t    if (!negate)\n \t      return FNM_NOMATCH;\n \t    break;\n \n@@ -194,7 +194,7 @@ fnmatch (const char *pattern, const char *string, int flags)\n \t\t  /* XXX 1003.2d11 is unclear if this is right.  */\n \t\t  ++p;\n \t      }\n-\t    if (not)\n+\t    if (negate)\n \t      return FNM_NOMATCH;\n \t  }\n \t  break;"}, {"sha": "0b5c2e8f6aaabbb5ed97e09ec6bdafe16923e35b", "filename": "libiberty/getopt.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fgetopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fgetopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetopt.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -212,8 +212,16 @@ static char *posixly_correct;\n /* Avoid depending on library functions or files\n    whose names are inconsistent.  */\n \n-#ifndef getenv\n-extern char *getenv ();\n+#if HAVE_STDLIB_H && HAVE_DECL_GETENV\n+#  include <stdlib.h>\n+#elif !defined(getenv)\n+#  ifdef __cplusplus\n+extern \"C\" {\n+#  endif /* __cplusplus */\n+extern char *getenv (const char *);\n+#  ifdef __cplusplus\n+}\n+#  endif /* __cplusplus */\n #endif\n \n static char *\n@@ -325,7 +333,7 @@ exchange (char **argv)\n     {\n       /* We must extend the array.  The user plays games with us and\n \t presents new arguments.  */\n-      char *new_str = malloc (top + 1);\n+      char *new_str = (char *) malloc (top + 1);\n       if (new_str == NULL)\n \tnonoption_flags_len = nonoption_flags_max_len = 0;\n       else"}, {"sha": "fa5c132fd6b6e48c11efe723dfc492635ddc1522", "filename": "libiberty/getpwd.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fgetpwd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fgetpwd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetpwd.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -84,7 +84,7 @@ getpwd (void)\n \t     && dotstat.st_dev == pwdstat.st_dev))\n \n \t/* The shortcut didn't work.  Try the slow, ``sure'' way.  */\n-\tfor (s = GUESSPATHLEN;  ! getcwd (p = xmalloc (s), s);  s *= 2)\n+\tfor (s = GUESSPATHLEN;  !getcwd (p = XNEWVEC (char, s), s);  s *= 2)\n \t  {\n \t    int e = errno;\n \t    free (p);\n@@ -117,7 +117,7 @@ getpwd (void)\n   static char *pwd = 0;\n \n   if (!pwd)\n-    pwd = getcwd (xmalloc (MAXPATHLEN + 1), MAXPATHLEN + 1\n+    pwd = getcwd (XNEWVEC (char, MAXPATHLEN + 1), MAXPATHLEN + 1\n #ifdef VMS\n \t\t  , 0\n #endif"}, {"sha": "5557e0a96863ee6bbe124a093a59b0ccec64a038", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -216,20 +216,30 @@ eq_pointer (const PTR p1, const PTR p2)\n   return p1 == p2;\n }\n \n-/* Return the current size of given hash table. */\n \n-inline size_t\n-htab_size (htab_t htab)\n+/* The parens around the function names in the next two definitions\n+   are essential in order to prevent macro expansions of the name.\n+   The bodies, however, are expanded as expected, so they are not\n+   recursive definitions.  */\n+\n+/* Return the current size of given hash table.  */\n+\n+#define htab_size(htab)  ((htab)->size)\n+\n+size_t\n+(htab_size) (htab_t htab)\n {\n-  return htab->size;\n+  return htab_size (htab);\n }\n \n /* Return the current number of elements in given hash table. */\n \n-inline size_t\n-htab_elements (htab_t htab)\n+#define htab_elements(htab)  ((htab)->n_elements - (htab)->n_deleted)\n+\n+size_t\n+(htab_elements) (htab_t htab)\n {\n-  return htab->n_elements - htab->n_deleted;\n+  return htab_elements (htab);\n }\n \n /* Return X % Y.  */\n@@ -317,15 +327,10 @@ htab_create_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,\n    an extra argument.  */\n \n htab_t\n-htab_create_alloc_ex (size, hash_f, eq_f, del_f, alloc_arg, alloc_f,\n-\t\t      free_f)\n-     size_t size;\n-     htab_hash hash_f;\n-     htab_eq eq_f;\n-     htab_del del_f;\n-     PTR alloc_arg;\n-     htab_alloc_with_arg alloc_f;\n-     htab_free_with_arg free_f;\n+htab_create_alloc_ex (size_t size, htab_hash hash_f, htab_eq eq_f,\n+                      htab_del del_f, void *alloc_arg,\n+                      htab_alloc_with_arg alloc_f,\n+\t\t      htab_free_with_arg free_f)\n {\n   htab_t result;\n   unsigned int size_prime_index;"}, {"sha": "b27c8de990e974c7294dfc4024ef44fbd3844a52", "filename": "libiberty/lrealpath.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Flrealpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Flrealpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Flrealpath.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -117,7 +117,7 @@ lrealpath (const char *filename)\n       {\n \t/* PATH_MAX is bounded.  */\n \tchar *buf, *rp, *ret;\n-\tbuf = malloc (path_max);\n+\tbuf = (char *) malloc (path_max);\n \tif (buf == NULL)\n \t  return NULL;\n \trp = realpath (filename, buf);"}, {"sha": "66ddcaa471bf029b921c87fd7f397663aff830a6", "filename": "libiberty/make-relative-prefix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fmake-relative-prefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fmake-relative-prefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-relative-prefix.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -102,7 +102,7 @@ static void free_split_directories (char **);\n static char *\n save_string (const char *s, int len)\n {\n-  char *result = malloc (len + 1);\n+  char *result = (char *) malloc (len + 1);\n \n   memcpy (result, s, len);\n   result[len] = 0;"}, {"sha": "5e21414ad8eed1f8294879235c2775f13956a647", "filename": "libiberty/make-temp-file.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fmake-temp-file.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fmake-temp-file.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-temp-file.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -61,10 +61,10 @@ extern int mkstemps (char *, int);\n    If success, DIR is returned.\n    Otherwise NULL is returned.  */\n \n-static inline const char *try (const char *, const char *);\n+static inline const char *try_dir (const char *, const char *);\n \n static inline const char *\n-try (const char *dir, const char *base)\n+try_dir (const char *dir, const char *base)\n {\n   if (base != 0)\n     return base;\n@@ -103,18 +103,18 @@ choose_tmpdir (void)\n   if (memoized_tmpdir)\n     return memoized_tmpdir;\n \n-  base = try (getenv (\"TMPDIR\"), base);\n-  base = try (getenv (\"TMP\"), base);\n-  base = try (getenv (\"TEMP\"), base);\n+  base = try_dir (getenv (\"TMPDIR\"), base);\n+  base = try_dir (getenv (\"TMP\"), base);\n+  base = try_dir (getenv (\"TEMP\"), base);\n \n #ifdef P_tmpdir\n-  base = try (P_tmpdir, base);\n+  base = try_dir (P_tmpdir, base);\n #endif\n \n   /* Try /var/tmp, /usr/tmp, then /tmp.  */\n-  base = try (vartmp, base);\n-  base = try (usrtmp, base);\n-  base = try (tmp, base);\n+  base = try_dir (vartmp, base);\n+  base = try_dir (usrtmp, base);\n+  base = try_dir (tmp, base);\n  \n   /* If all else fails, use the current directory!  */\n   if (base == 0)\n@@ -123,7 +123,7 @@ choose_tmpdir (void)\n   /* Append DIR_SEPARATOR to the directory we've chosen\n      and return it.  */\n   len = strlen (base);\n-  tmpdir = xmalloc (len + 2);\n+  tmpdir = XNEWVEC (char, len + 2);\n   strcpy (tmpdir, base);\n   tmpdir[len] = DIR_SEPARATOR;\n   tmpdir[len+1] = '\\0';\n@@ -158,7 +158,7 @@ make_temp_file (const char *suffix)\n   base_len = strlen (base);\n   suffix_len = strlen (suffix);\n \n-  temp_filename = xmalloc (base_len\n+  temp_filename = XNEWVEC (char, base_len\n \t\t\t   + TEMP_FILE_LEN\n \t\t\t   + suffix_len + 1);\n   strcpy (temp_filename, base);"}, {"sha": "89b37d9f4805a4d1822f740603b86bf08c0a02bc", "filename": "libiberty/mkstemps.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fmkstemps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fmkstemps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmkstemps.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -51,17 +51,17 @@ typedef unsigned long gcc_uint64_t;\n \n /*\n \n-@deftypefn Replacement int mkstemps (char *@var{template}, int @var{suffix_len})\n+@deftypefn Replacement int mkstemps (char *@var{pattern}, int @var{suffix_len})\n \n-Generate a unique temporary file name from @var{template}.\n-@var{template} has the form:\n+Generate a unique temporary file name from @var{pattern}.\n+@var{pattern} has the form:\n \n @example\n    @var{path}/ccXXXXXX@var{suffix}\n @end example\n \n @var{suffix_len} tells us how long @var{suffix} is (it can be zero\n-length).  The last six characters of @var{template} before @var{suffix}\n+length).  The last six characters of @var{pattern} before @var{suffix}\n must be @samp{XXXXXX}; they are replaced with a string that makes the\n filename unique.  Returns a file descriptor open on the file for\n reading and writing.\n@@ -71,7 +71,7 @@ reading and writing.\n */\n \n int\n-mkstemps (char *template, int suffix_len)\n+mkstemps (char *pattern, int suffix_len)\n {\n   static const char letters[]\n     = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n@@ -83,15 +83,15 @@ mkstemps (char *template, int suffix_len)\n   size_t len;\n   int count;\n \n-  len = strlen (template);\n+  len = strlen (pattern);\n \n   if ((int) len < 6 + suffix_len\n-      || strncmp (&template[len - 6 - suffix_len], \"XXXXXX\", 6))\n+      || strncmp (&pattern[len - 6 - suffix_len], \"XXXXXX\", 6))\n     {\n       return -1;\n     }\n \n-  XXXXXX = &template[len - 6 - suffix_len];\n+  XXXXXX = &pattern[len - 6 - suffix_len];\n \n #ifdef HAVE_GETTIMEOFDAY\n   /* Get some more or less random data.  */\n@@ -119,7 +119,7 @@ mkstemps (char *template, int suffix_len)\n       v /= 62;\n       XXXXXX[5] = letters[v % 62];\n \n-      fd = open (template, O_RDWR|O_CREAT|O_EXCL, 0600);\n+      fd = open (pattern, O_RDWR|O_CREAT|O_EXCL, 0600);\n       if (fd >= 0)\n \t/* The file does not exist.  */\n \treturn fd;\n@@ -131,6 +131,6 @@ mkstemps (char *template, int suffix_len)\n     }\n \n   /* We return the null string if we can't find a unique file name.  */\n-  template[0] = '\\0';\n+  pattern[0] = '\\0';\n   return -1;\n }"}, {"sha": "b2ca6e08ce208151554088d44c7b103f5974e839", "filename": "libiberty/pex-common.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -55,7 +55,7 @@ pex_init_common (int flags, const char *pname, const char *tempbase,\n {\n   struct pex_obj *obj;\n \n-  obj = xmalloc (sizeof (*obj));\n+  obj = XNEW (struct pex_obj);\n   obj->flags = flags;\n   obj->pname = pname;\n   obj->tempbase = tempbase;\n@@ -83,7 +83,7 @@ pex_add_remove (struct pex_obj *obj, const char *name, int allocated)\n   char *add;\n \n   ++obj->remove_count;\n-  obj->remove = xrealloc (obj->remove, obj->remove_count * sizeof (char *));\n+  obj->remove = XRESIZEVEC (char *, obj->remove, obj->remove_count);\n   if (allocated)\n     add = (char *) name;\n   else\n@@ -280,7 +280,7 @@ pex_run (struct pex_obj *obj, int flags, const char *executable,\n     goto error_exit;\n \n   ++obj->count;\n-  obj->children = xrealloc (obj->children, obj->count * sizeof (long));\n+  obj->children = XRESIZEVEC (long, obj->children, obj->count);\n   obj->children[obj->count - 1] = pid;\n \n   return NULL;\n@@ -352,9 +352,9 @@ pex_get_status_and_time (struct pex_obj *obj, int done, const char **errmsg,\n   if (obj->number_waited == obj->count)\n     return 1;\n \n-  obj->status = xrealloc (obj->status, obj->count * sizeof (int));\n+  obj->status = XRESIZEVEC (int, obj->status, obj->count);\n   if ((obj->flags & PEX_RECORD_TIMES) != 0)\n-    obj->time = xrealloc (obj->time, obj->count * sizeof (struct pex_time));\n+    obj->time = XRESIZEVEC (struct pex_time, obj->time, obj->count);\n \n   ret = 1;\n   for (i = obj->number_waited; i < obj->count; ++i)"}, {"sha": "6e58e3fd8dcc864b975f7d220a5eb57e73a43387", "filename": "libiberty/pex-djgpp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-djgpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-djgpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-djgpp.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -257,7 +257,7 @@ pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n      is the number of children which have executed before this\n      one.  */\n   statuses = (int *) obj->sysdep;\n-  statuses = xrealloc (statuses, (obj->count + 1) * sizeof (int));\n+  statuses = XRESIZEVEC (int, statuses, obj->count + 1);\n   statuses[obj->count] = status;\n   obj->sysdep = (void *) statuses;\n "}, {"sha": "2256117d1bb0cb7d5d20c1224b01827ee5371023", "filename": "libiberty/pex-msdos.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-msdos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-msdos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-msdos.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -89,7 +89,7 @@ pex_init (int flags, const char *pname, const char *tempbase)\n \n   ret = pex_init_common (flags, pname, tempbase, funcs);\n \n-  ret->sysdep = xmalloc (sizeof (struct pex_msdos));\n+  ret->sysdep = XNEW (struct pex_msdos);\n   for (i = 0; i < PEX_MSDOS_FILE_COUNT; ++i)\n     ret->files[i] = NULL;\n   ret->statuses = NULL;\n@@ -210,7 +210,7 @@ pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n       outfile = ms->files[outindex];\n     }\n \n-  scmd = xmalloc (strlen (program)\n+  scmd = XNEWVEC (char, strlen (program)\n \t\t  + ((flags & PEXECUTE_SEARCH) != 0 ? 4 : 0)\n \t\t  + strlen (rf)\n \t\t  + strlen (infile)\n@@ -269,7 +269,7 @@ pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n   /* Save the exit status for later.  When we are called, obj->count\n      is the number of children which have executed before this\n      one.  */\n-  ms->statuses = xrealloc (ms->statuses, (obj->count + 1) * sizeof (int));\n+  ms->statuses = XRESIZEVEC(int, ms->statuses, obj->count + 1);\n   ms->statuses[obj->count] = status;\n \n   return obj->count;"}, {"sha": "35a545cb17b1dccebf2949472cb75d7df6afd9be", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -252,7 +252,7 @@ pex_wait (struct pex_obj *obj, pid_t pid, int *status, struct pex_time *time)\n \t  return cpid;\n \t}\n \n-      psl = xmalloc (sizeof (struct status_list));\n+      psl = XNEW (struct status_list);\n       psl->pid = cpid;\n       psl->status = *status;\n       if (time != NULL)"}, {"sha": "10262fbfeeddd66d3b9c393552967664437fda47", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -79,7 +79,7 @@ fix_argv (char * const *argvec)\n \n   for (i = 0; argvec[i] != NULL; i++)\n     ;\n-  argv = xmalloc ((i + 1) * sizeof (char *));\n+  argv = XNEWVEC (char *, i + 1);\n   for (i = 0; argvec[i] != NULL; i++)\n     argv[i] = xstrdup (argvec[i]);\n   argv[i] = NULL;\n@@ -105,7 +105,7 @@ fix_argv (char * const *argvec)\n         {\n           if (temp[j] == '\"')\n             {\n-              newtemp = xmalloc (len + 2);\n+              newtemp = XNEWVEC (char, len + 2);\n               strncpy (newtemp, temp, j);\n               newtemp [j] = '\\\\';\n               strncpy (&newtemp [j+1], &temp [j], len-j);\n@@ -150,7 +150,7 @@ fix_argv (char * const *argvec)\n \n \t  len += 2;\t\t\t/* and for the enclosing quotes. */\n \n-\t  temp = xmalloc (len + 1);\n+\t  temp = XNEWVEC (char, len + 1);\n \t  temp[0] = '\"';\n \t  strcpy (temp + 1, argv[i]);\n \t  if (trailing_backslash)"}, {"sha": "60a280b8e472931106d9d8bf7f800bdf17851872", "filename": "libiberty/pexecute.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -99,7 +99,7 @@ pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)\n     {\n       int *vector;\n \n-      vector = xmalloc (idx * sizeof (int));\n+      vector = XNEWVEC (int, idx);\n       if (!pex_get_status (pex, idx, vector))\n \treturn -1;\n       *status = vector[pid];"}, {"sha": "355af5a9dd673831c4feb0f45630feeb252294a9", "filename": "libiberty/setenv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fsetenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fsetenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsetenv.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -115,7 +115,7 @@ setenv (const char *name, const char *value, int replace)\n \t  return -1;\n \t}\n \n-      new_environ[size] = malloc (namelen + 1 + vallen);\n+      new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n       if (new_environ[size] == NULL)\n \t{\n \t  free ((char *) new_environ);\n@@ -142,13 +142,13 @@ setenv (const char *name, const char *value, int replace)\n       if (len + 1 < namelen + 1 + vallen)\n \t{\n \t  /* The existing string is too short; malloc a new one.  */\n-\t  char *new = malloc (namelen + 1 + vallen);\n-\t  if (new == NULL)\n+\t  char *new_string = (char *) malloc (namelen + 1 + vallen);\n+\t  if (new_string == NULL)\n \t    {\n \t      UNLOCK;\n \t      return -1;\n \t    }\n-\t  *ep = new;\n+\t  *ep = new_string;\n \t}\n       memcpy (*ep, name, namelen);\n       (*ep)[namelen] = '=';"}, {"sha": "3b708b16adb4f8148409060414718b89c0c0c082", "filename": "libiberty/sigsetmask.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fsigsetmask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fsigsetmask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsigsetmask.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -27,14 +27,14 @@ extern void abort (void) ATTRIBUTE_NORETURN;\n int\n sigsetmask (int set)\n {\n-    sigset_t new;\n-    sigset_t old;\n+    sigset_t new_sig;\n+    sigset_t old_sig;\n     \n-    sigemptyset (&new);\n+    sigemptyset (&new_sig);\n     if (set != 0) {\n       abort();\t/* FIXME, we don't know how to translate old mask to new */\n     }\n-    sigprocmask(SIG_SETMASK, &new, &old);\n+    sigprocmask(SIG_SETMASK, &new_sig, &old_sig);\n     return 1;\t/* FIXME, we always return 1 as old value.  */\n }\n #endif"}, {"sha": "3738dd733e5863502cbb3eef1ea677ca632952d6", "filename": "libiberty/sort.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fsort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fsort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsort.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -155,8 +155,8 @@ int main (int argc, char **argv)\n   else\n     k = 10;\n \n-  pointers = xmalloc (k * sizeof (void *));\n-  work = xmalloc (k * sizeof (void *));\n+  pointers = XNEWVEC (void*, k);\n+  work = XNEWVEC (void*, k);\n \n   for (i = 0; i < k; ++i)\n     {"}, {"sha": "67481c9bcd8ff026491b68699a97c5a9871b2bae", "filename": "libiberty/spaces.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fspaces.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fspaces.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fspaces.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -57,7 +57,7 @@ spaces (int count)\n \t{\n \t  free (buf);\n \t}\n-      buf = malloc (count + 1);\n+      buf = (char *) malloc (count + 1);\n       if (buf == (char *) 0)\n \treturn 0;\n       for (t = buf + count ; t != buf ; )"}, {"sha": "9e9b4e2991f833082acd176f48825f76d5a888b9", "filename": "libiberty/strndup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fstrndup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fstrndup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrndup.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -46,10 +46,10 @@ strndup (const char *s, size_t n)\n   if (n < len)\n     len = n;\n \n-  result = malloc (len + 1);\n+  result = (char *) malloc (len + 1);\n   if (!result)\n     return 0;\n \n   result[len] = '\\0';\n-  return memcpy (result, s, len);\n+  return (char *) memcpy (result, s, len);\n }"}, {"sha": "8fc561a4531530eb7fa373b9a77c56e21359bf84", "filename": "libiberty/ternary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fternary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fternary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fternary.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -74,7 +74,7 @@ ternary_insert (ternary_tree *root, const char *s, PTR data, int replace)\n   for (;;)\n     {\n       /* Allocate the memory for the node, and fill it in */\n-      *pcurr = (ternary_tree) xmalloc (sizeof (ternary_node));\n+      *pcurr = XNEW (ternary_node);\n       curr = *pcurr;\n       curr->splitchar = *s;\n       curr->lokid = curr->hikid = curr->eqkid = 0;"}, {"sha": "3e97aab563f0e409a3d65a6258ee911e89101eb5", "filename": "libiberty/xmalloc.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxmalloc.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -75,11 +75,23 @@ function will be called to print an error message and terminate execution.\n #include <unixlib.h>\n #else\n /* For systems with larger pointers than ints, these must be declared.  */\n-PTR malloc (size_t);\n-PTR realloc (PTR, size_t);\n-PTR calloc (size_t, size_t);\n-PTR sbrk (ptrdiff_t);\n-#endif\n+#  if HAVE_STDLIB_H && HAVE_UNISTD_H && HAVE_DECL_MALLOC \\\n+      && HAVE_DECL_REALLOC && HAVE_DECL_CALLOC && HAVE_DECL_SBRK\n+#    include <stdlib.h>\n+#    include <unistd.h>\n+#  else\n+#    ifdef __cplusplus\n+extern \"C\" {\n+#    endif /* __cplusplus */\n+void *malloc (size_t);\n+void *realloc (void *, size_t);\n+void *calloc (size_t, size_t);\n+void *sbrk (ptrdiff_t);\n+#    ifdef __cplusplus\n+}\n+#    endif /* __cplusplus */\n+#  endif /* HAVE_STDLIB_H ...  */\n+#endif /* VMS */\n \n /* The program name if set.  */\n static const char *name = \"\";"}, {"sha": "9ac2ea038f344e3b74b548b29cb49a4013262cc7", "filename": "libiberty/xstrdup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxstrdup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxstrdup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxstrdup.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -31,6 +31,6 @@ char *\n xstrdup (const char *s)\n {\n   register size_t len = strlen (s) + 1;\n-  register char *ret = xmalloc (len);\n+  register char *ret = XNEWVEC (char, len);\n   return (char *) memcpy (ret, s, len);\n }"}, {"sha": "2ea2200e9fcfc86d4a3bf6d4e656b37e963b7fc7", "filename": "libiberty/xstrerror.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxstrerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxstrerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxstrerror.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -19,15 +19,28 @@ will never return a @code{NULL} pointer.\n #include \"libiberty.h\"\n \n #ifdef VMS\n-#include <errno.h>\n-#if !defined (__STRICT_ANSI__) && !defined (__HIDE_FORBIDDEN_NAMES)\n+#  include <errno.h>\n+#  if !defined (__STRICT_ANSI__) && !defined (__HIDE_FORBIDDEN_NAMES)\n+#    ifdef __cplusplus\n+extern \"C\" {\n+#    endif /* __cplusplus */\n extern char *strerror (int,...);\n-#define DONT_DECLARE_STRERROR\n-#endif\n-#endif\t/* VMS */\n+#    define DONT_DECLARE_STRERROR\n+#    ifdef __cplusplus\n+}\n+#    endif /* __cplusplus */\n+#  endif\n+#endif  /* VMS */\n+\n \n #ifndef DONT_DECLARE_STRERROR\n+#  ifdef __cplusplus\n+extern \"C\" {\n+#  endif /* __cplusplus */\n extern char *strerror (int);\n+#  ifdef __cplusplus\n+}\n+#  endif /* __cplusplus */\n #endif\n \n /* If strerror returns NULL, we'll format the number into a static buffer.  */"}, {"sha": "0a41f608ec0b9c71ddebc4975c688c88bdde30a3", "filename": "libiberty/xstrndup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxstrndup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cf8390c73e75b15e1d518c5707909f7c659938/libiberty%2Fxstrndup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxstrndup.c?ref=d7cf8390c73e75b15e1d518c5707909f7c659938", "patch": "@@ -53,8 +53,8 @@ xstrndup (const char *s, size_t n)\n   if (n < len)\n     len = n;\n \n-  result = xmalloc (len + 1);\n+  result = XNEWVEC (char, len + 1);\n \n   result[len] = '\\0';\n-  return memcpy (result, s, len);\n+  return (char *) memcpy (result, s, len);\n }"}]}