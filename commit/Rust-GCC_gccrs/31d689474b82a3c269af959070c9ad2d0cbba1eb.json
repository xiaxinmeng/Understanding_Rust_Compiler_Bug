{"sha": "31d689474b82a3c269af959070c9ad2d0cbba1eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkNjg5NDc0YjgyYTNjMjY5YWY5NTkwNzBjOWFkMmQwY2JiYTFlYg==", "commit": {"author": {"name": "Alan Modra", "email": "alan@linuxcare.com.au", "date": "2001-02-18T07:27:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2001-02-18T07:27:59Z"}, "message": "pa.c (hppa_expand_prologue): Simplify code storing return pointer.\n\n \t* pa.c (hppa_expand_prologue): Simplify code storing return\n \tpointer.  For large (>=8k) frames with a post_store, adjust stack\n \tpointer by 8k-64 first rather than by 64.  When testing with\n \tVAL_14_BITS_P, always use the actual value rather than the value\n \tnegated.  Add blockage to prevent scheduling of spills before\n \tstack frame has been created.\n\t(hppa_expand_epilogue): Simplify code loading return pointer.\n \tAllow a slightly larger range for merge_sp_adjust_with_load case.\n \tWhen testing with VAL_14_BITS_P, always use the actual value.\n\nFrom-SVN: r39826", "tree": {"sha": "539286a74846c17c20be139b9012dd233dcebabb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/539286a74846c17c20be139b9012dd233dcebabb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31d689474b82a3c269af959070c9ad2d0cbba1eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d689474b82a3c269af959070c9ad2d0cbba1eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31d689474b82a3c269af959070c9ad2d0cbba1eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31d689474b82a3c269af959070c9ad2d0cbba1eb/comments", "author": null, "committer": null, "parents": [{"sha": "4096479e2edd3cc908b5d97caedfa8de4f3b4853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4096479e2edd3cc908b5d97caedfa8de4f3b4853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4096479e2edd3cc908b5d97caedfa8de4f3b4853"}], "stats": {"total": 241, "additions": 116, "deletions": 125}, "files": [{"sha": "c9ea2ef35d8e1ac692f9719be7332b6d4d3be2c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d689474b82a3c269af959070c9ad2d0cbba1eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d689474b82a3c269af959070c9ad2d0cbba1eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31d689474b82a3c269af959070c9ad2d0cbba1eb", "patch": "@@ -1,5 +1,15 @@\n 2001-02-18  Alan Modra <alan@linuxcare.com.au>\n \n+ \t* pa.c (hppa_expand_prologue): Simplify code storing return\n+ \tpointer.  For large (>=8k) frames with a post_store, adjust stack\n+ \tpointer by 8k-64 first rather than by 64.  When testing with\n+ \tVAL_14_BITS_P, always use the actual value rather than the value\n+ \tnegated.  Add blockage to prevent scheduling of spills before\n+ \tstack frame has been created.\n+ \t(hppa_expand_epilogue): Simplify code loading return pointer.\n+ \tAllow a slightly larger range for merge_sp_adjust_with_load case.\n+ \tWhen testing with VAL_14_BITS_P, always use the actual value.\n+\n \t* pa.c (pa_adjust_insn_length): Check that block move\n \tpattern is a set before looking at operands.\n "}, {"sha": "08cc435f248c0941979ab64441d75969591fbcbd", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 106, "deletions": 125, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31d689474b82a3c269af959070c9ad2d0cbba1eb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31d689474b82a3c269af959070c9ad2d0cbba1eb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=31d689474b82a3c269af959070c9ad2d0cbba1eb", "patch": "@@ -2989,70 +2989,75 @@ hppa_expand_prologue()\n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp-20 or sp - 16\n      depending on which ABI is in use.  */\n-  if ((regs_ever_live[2] || profile_flag) && TARGET_64BIT)\n-    store_reg (2, -16, STACK_POINTER_REGNUM);\n-\n-  if ((regs_ever_live[2] || profile_flag) && ! TARGET_64BIT)\n-    store_reg (2, -20, STACK_POINTER_REGNUM);\n+  if (regs_ever_live[2] || profile_flag)\n+    store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n-  if (actual_fsize)\n-  {\n-    if (frame_pointer_needed)\n-      {\n-\t/* Copy the old frame pointer temporarily into %r1.  Set up the\n-\t   new stack pointer, then store away the saved old frame pointer\n-\t   into the stack at sp+actual_fsize and at the same time update\n-\t   the stack pointer by actual_fsize bytes.  Two versions, first\n-\t   handles small (<8k) frames.  The second handles large (>8k)\n-\t   frames.  */\n-\temit_move_insn (tmpreg, frame_pointer_rtx);\n-\temit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-\tif (VAL_14_BITS_P (actual_fsize))\n-\t  emit_insn (gen_post_store (stack_pointer_rtx, tmpreg, size_rtx));\n-\telse\n-\t  {\n-\t    /* It is incorrect to store the saved frame pointer at *sp,\n-\t       then increment sp (writes beyond the current stack boundary).\n-\n-\t       So instead use stwm to store at *sp and post-increment the\n-\t       stack pointer as an atomic operation.  Then increment sp to\n-\t       finish allocating the new frame.  */\n-\t    emit_insn (gen_post_store (stack_pointer_rtx, tmpreg,\n-\t\t       GEN_INT (64)));\n+  if (actual_fsize != 0)\n+    {\n+      if (frame_pointer_needed)\n+\t{\n+\t  /* Copy the old frame pointer temporarily into %r1.  Set up the\n+\t     new stack pointer, then store away the saved old frame pointer\n+\t     into the stack at sp+actual_fsize and at the same time update\n+\t     the stack pointer by actual_fsize bytes.  Two versions, first\n+\t     handles small (<8k) frames.  The second handles large (>=8k)\n+\t     frames.  */\n+\t  emit_move_insn (tmpreg, frame_pointer_rtx);\n+\t  emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\t  if (VAL_14_BITS_P (actual_fsize))\n+\t    emit_insn (gen_post_store (stack_pointer_rtx, tmpreg, size_rtx));\n+\t  else\n+\t    {\n+\t      /* It is incorrect to store the saved frame pointer at *sp,\n+\t\t then increment sp (writes beyond the current stack boundary).\n+\n+\t\t So instead use stwm to store at *sp and post-increment the\n+\t\t stack pointer as an atomic operation.  Then increment sp to\n+\t\t finish allocating the new frame.  */\n+\t      int adjust1 = 8192 - 64;\n+\t      int adjust2 = actual_fsize - adjust1;\n+\t      rtx delta = GEN_INT (adjust1);\n+\t      emit_insn (gen_post_store (stack_pointer_rtx, tmpreg, delta));\n+\t      set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t      STACK_POINTER_REGNUM,\n+\t\t\t      adjust2);\n+\t    }\n+\t  /* Prevent register spills from being scheduled before the\n+\t     stack pointer is raised.  Necessary as we will be storing\n+\t     registers using the frame pointer as a base register, and\n+\t     we happen to set fp before raising sp.  */ \n+\t  emit_insn (gen_blockage ());\n+\t}\n+      /* no frame pointer needed.  */\n+      else\n+\t{\n+\t  /* In some cases we can perform the first callee register save\n+\t     and allocating the stack frame at the same time.   If so, just\n+\t     make a note of it and defer allocating the frame until saving\n+\t     the callee registers.  */\n+\t  if (VAL_14_BITS_P (actual_fsize)\n+\t      && local_fsize == 0\n+\t      && ! profile_flag\n+\t      && ! flag_pic)\n+\t    merge_sp_adjust_with_store = 1;\n+\t  /* Can not optimize.  Adjust the stack frame by actual_fsize\n+\t     bytes.  */\n+\t  else\n \t    set_reg_plus_d (STACK_POINTER_REGNUM,\n \t\t\t    STACK_POINTER_REGNUM,\n-\t\t\t    actual_fsize - 64);\n-\t  }\n-      }\n-    /* no frame pointer needed.  */\n-    else\n-      {\n-\t/* In some cases we can perform the first callee register save\n-\t   and allocating the stack frame at the same time.   If so, just\n-\t   make a note of it and defer allocating the frame until saving\n-\t   the callee registers.  */\n-\tif (VAL_14_BITS_P (-actual_fsize)\n-\t    && local_fsize == 0\n-\t    && ! profile_flag\n-\t    && ! flag_pic)\n-\t  merge_sp_adjust_with_store = 1;\n-\t/* Can not optimize.  Adjust the stack frame by actual_fsize bytes.  */\n-\telse if (actual_fsize != 0)\n-\t  set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t  STACK_POINTER_REGNUM,\n-\t\t\t  actual_fsize);\n-      }\n-  }\n+\t\t\t    actual_fsize);\n+\t}\n \n-  /* The hppa calling conventions say that %r19, the pic offset\n-     register, is saved at sp - 32 (in this function's frame)  when\n-     generating PIC code.  FIXME:  What is the correct thing to do\n-     for functions which make no calls and allocate no frame?  Do\n-     we need to allocate a frame, or can we just omit the save?   For\n-     now we'll just omit the save.  */\n-  if (actual_fsize != 0 && flag_pic && !TARGET_64BIT)\n-    store_reg (PIC_OFFSET_TABLE_REGNUM, -32, STACK_POINTER_REGNUM);\n+      /* The hppa calling conventions say that %r19, the pic offset\n+\t register, is saved at sp - 32 (in this function's frame)\n+\t when generating PIC code.  FIXME:  What is the correct thing\n+\t to do for functions which make no calls and allocate no\n+\t frame?  Do we need to allocate a frame, or can we just omit\n+\t the save?   For now we'll just omit the save.  */\n+      if (flag_pic && !TARGET_64BIT)\n+\tstore_reg (PIC_OFFSET_TABLE_REGNUM, -32, STACK_POINTER_REGNUM);\n+    }\n \n   /* Profiling code.\n \n@@ -3226,32 +3231,34 @@ void\n hppa_expand_epilogue ()\n {\n   rtx tmpreg;\n-  int offset,i;\n-  int merge_sp_adjust_with_load  = 0;\n+  int offset, i;\n+  int merge_sp_adjust_with_load = 0;\n+  int ret_off = 0;\n \n   /* We will use this often.  */\n   tmpreg = gen_rtx_REG (word_mode, 1);\n \n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n      be necessary even when we schedule the prologue and epilogue. */\n-  if (frame_pointer_needed\n-      && !TARGET_64BIT\n-      && (regs_ever_live [2] || profile_flag))\n-    load_reg (2, -20, FRAME_POINTER_REGNUM);\n-  else if (TARGET_64BIT && frame_pointer_needed\n-\t   && (regs_ever_live[2] || profile_flag))\n-    load_reg (2, -16, FRAME_POINTER_REGNUM);\n-  else if (TARGET_64BIT\n-\t   && ! frame_pointer_needed\n-\t   && (regs_ever_live[2] || profile_flag)\n-\t   && VAL_14_BITS_P (actual_fsize + 20))\n-    load_reg (2, - (actual_fsize + 16), STACK_POINTER_REGNUM);\n-  /* No frame pointer, and stack is smaller than 8k.  */\n-  else if (! frame_pointer_needed\n-\t   && VAL_14_BITS_P (actual_fsize + 20)\n-\t   && (regs_ever_live[2] || profile_flag))\n-    load_reg (2, - (actual_fsize + 20), STACK_POINTER_REGNUM);\n+  if (regs_ever_live [2] || profile_flag)\n+    {\n+      ret_off = TARGET_64BIT ? -16 : -20;\n+      if (frame_pointer_needed)\n+\t{\n+\t  load_reg (2, ret_off, FRAME_POINTER_REGNUM);\n+\t  ret_off = 0;\n+\t}\n+      else\n+\t{\n+\t  /* No frame pointer, and stack is smaller than 8k.  */\n+\t  if (VAL_14_BITS_P (ret_off - actual_fsize))\n+\t    {\n+\t      load_reg (2, ret_off - actual_fsize, STACK_POINTER_REGNUM);\n+\t      ret_off = 0;\n+\t    }\n+\t}\n+    }\n \n   /* General register restores.  */\n   if (frame_pointer_needed)\n@@ -3272,9 +3279,9 @@ hppa_expand_epilogue ()\n \t      /* Only for the first load.\n \t         merge_sp_adjust_with_load holds the register load\n \t         with which we will merge the sp adjustment.  */\n-\t      if (VAL_14_BITS_P (actual_fsize + 20)\n+\t      if (merge_sp_adjust_with_load == 0\n \t\t  && local_fsize == 0\n-\t\t  && ! merge_sp_adjust_with_load)\n+\t\t  && VAL_14_BITS_P (-actual_fsize))\n \t        merge_sp_adjust_with_load = i;\n \t      else\n \t        load_reg (i, offset, STACK_POINTER_REGNUM);\n@@ -3314,62 +3321,36 @@ hppa_expand_epilogue ()\n      This is necessary as we must not cut the stack back before all the\n      restores are finished.  */\n   emit_insn (gen_blockage ());\n-  /* No frame pointer, but we have a stack greater than 8k.  We restore\n-     %r2 very late in this case.  (All other cases are restored as early\n-     as possible.)  */\n-  if (! frame_pointer_needed\n-      && ! VAL_14_BITS_P (actual_fsize + 20)\n-      && ! TARGET_64BIT\n-      && (regs_ever_live[2] || profile_flag))\n-    {\n-      set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t      STACK_POINTER_REGNUM,\n-\t\t      - actual_fsize);\n-\n-      /* This used to try and be clever by not depending on the value in\n-\t %r30 and instead use the value held in %r1 (so that the 2nd insn\n-\t which sets %r30 could be put in the delay slot of the return insn).\n-\t\n-\t That won't work since if the stack is exactly 8k set_reg_plus_d\n-\t doesn't set %r1, just %r30.  */\n-      load_reg (2, - 20, STACK_POINTER_REGNUM);\n-    }\n-  else if (! frame_pointer_needed\n-\t   && ! VAL_14_BITS_P (actual_fsize + 20)\n-\t   && TARGET_64BIT\n-\t   && (regs_ever_live[2] || profile_flag))\n-    {\n-      set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t      STACK_POINTER_REGNUM,\n-\t\t      - actual_fsize);\n-\n-      /* This used to try and be clever by not depending on the value in\n-\t %r30 and instead use the value held in %r1 (so that the 2nd insn\n-\t which sets %r30 could be put in the delay slot of the return insn).\n-\t\n-\t That won't work since if the stack is exactly 8k set_reg_plus_d\n-\t doesn't set %r1, just %r30.  */\n-      load_reg (2, - 16, STACK_POINTER_REGNUM);\n-    }\n \n   /* Reset stack pointer (and possibly frame pointer).  The stack \n      pointer is initially set to fp + 64 to avoid a race condition.  */\n-  else if (frame_pointer_needed)\n+  if (frame_pointer_needed)\n     {\n       set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64);\n       emit_insn (gen_pre_load (frame_pointer_rtx, \n \t\t\t       stack_pointer_rtx,\n \t\t\t       GEN_INT (-64)));\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n-  else if (! frame_pointer_needed  && merge_sp_adjust_with_load)\n-    emit_insn (gen_pre_load (gen_rtx_REG (word_mode, merge_sp_adjust_with_load),\n-\t\t\t     stack_pointer_rtx,\n-\t\t\t     GEN_INT (- actual_fsize)));\n+  else if (merge_sp_adjust_with_load)\n+    {\n+      rtx delta = GEN_INT (-actual_fsize);\n+      emit_insn (gen_pre_load (gen_rtx_REG (word_mode,\n+\t\t\t\t\t    merge_sp_adjust_with_load),\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       delta));\n+    }\n   else if (actual_fsize != 0)\n-    set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t    STACK_POINTER_REGNUM,\n-\t\t    - actual_fsize);\n+    {\n+      set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t      STACK_POINTER_REGNUM,\n+\t\t      - actual_fsize);\n+    }\n+\n+  /* If we haven't restored %r2 yet (no frame pointer, and a stack\n+     frame greater than 8k), do so now.  */\n+  if (ret_off != 0)\n+    load_reg (2, ret_off, STACK_POINTER_REGNUM);\n }\n \n /* Set up a callee saved register for the pic offset table register.  */"}]}