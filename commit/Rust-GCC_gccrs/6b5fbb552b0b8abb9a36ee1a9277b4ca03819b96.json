{"sha": "6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1ZmJiNTUyYjBiOGFiYjlhMzZlZTFhOTI3N2I0Y2EwMzgxOWI5Ng==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-12T23:55:07Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-12T23:55:07Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11710", "tree": {"sha": "84ac919a75a7ef9a3abc47f1231f2e6ee3f56ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84ac919a75a7ef9a3abc47f1231f2e6ee3f56ef1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/comments", "author": null, "committer": null, "parents": [{"sha": "5ae5999cfe054bd1840277903b2aed4e905c2236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae5999cfe054bd1840277903b2aed4e905c2236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ae5999cfe054bd1840277903b2aed4e905c2236"}], "stats": {"total": 1777, "additions": 1054, "deletions": 723}, "files": [{"sha": "8cfe37d4afc60eb9a382cdb17a014a01eff48957", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1,3 +1,190 @@\n+Fri Apr 12 09:08:27 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* search.c (expand_upcast_fixups): Mark the new fixup as\n+\tDECL_ARTIFICIAL.\n+\n+Thu Apr 11 03:57:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_new): Use a TARGET_EXPR for alloc_expr.\n+\n+\t* class.c (set_rtti_entry): Fix for thunks.\n+\n+\t* decl2.c (import_export_decl): Still emit typeinfo fns for\n+\tcv-variants of builtin types.\n+\n+\t* rtti.c (expand_class_desc): Set up base_info_type_node here.\n+\t(init_rtti_processing): Instead of here.\n+\n+Wed Apr 10 14:17:13 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (init_rtti_processing): Do init regardless of -frtti.\n+\t(build_typeid): Only complain about taking dynamic typeid without\n+\t-frtti.\n+\n+\t* decl2.c: flag_rtti defaults to 1.\n+\n+\t* rtti.c (get_tinfo_var): The general class case is now smaller.\n+\t(init_rtti_processing): Pack the latter three fields of base_info\n+\tinto 32 bits.\n+\n+Wed Apr 10 13:50:14 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (expand_member_init): Don't dump if name is NULL_TREE.\n+\n+Wed Apr 10 12:56:02 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (make_memoized_table_entry): Undefer the pop, if necessary.\n+\t(push_memoized_context): Split out code to undefer pop_type_level to\n+\t(clear_memoized_cache): here.\n+\t(pop_memoized_context): We can only handle one layer of deferral of\n+\tpop_type_level so clear the cache, if there was a previous level.\n+\n+Tue Apr  9 23:06:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (init_rtti_processing): Build up base_info_type_node.\n+\t(expand_class_desc): Use one pointer to an array of base_info\n+\tstructs, passed using a CONSTRUCTOR.\n+\n+Tue Apr  9 14:20:57 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (build_vbase_path): Remove block extern for\n+\tflag_assume_nonnull_objects here.\n+\t(build_vfn_ref): Split out functionality into build_vtbl_ref.\n+\t(build_vtbl_ref): New routine.\n+\t(build_vtable): Set up rtti info here.\n+\t(add_virtual_function): Note in CLASSTYPE_RTTI the best\n+\tplace where we can get the rtti pointers from to avoid having to\n+\tsearch around for a place.\n+\t(finish_base_struct): Ditto.\n+\t(finish_struct_1): Ditto.  Never create totally new vtables with totally\n+\tnew vtable pointers for rtti.  Disable code to layout vtable pointers\n+\tbetter until we want to break binary compatibility.\n+\t* rtti.c (build_headof_sub): New routine to convert down to a\n+\tsub-object that has an rtti pointer in the vtable.\n+\t(build_headof): Use it.  Also, use build_vtbl_ref now to be more\n+\tmaintainable.\n+\t(build_dynamic_cast): Make sure we have saved it, if we need to.\n+\t* search.c (dfs_init_vbase_pointers): Disable code that deals with\n+\ta more efficient vtable layout, enable later.\n+\t* call.c (flag_assume_nonnull_objects): Moved declaration to\n+\t* cp-tree.h: here.  Declare build_vtbl_ref.\n+\t* pt.c (instantiate_class_template): Use NULL_TREE instead of 0 in\n+\tfunction calls that want a tree.\n+\n+Tue Apr  9 12:10:26 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (build_dynamic_cast): Handle downcasting to X* given\n+ \tother X subobjects in the most derived type.  Ack.\n+\n+\t* rtti.c (build_dynamic_cast): No need to strip cv-quals here,\n+ \tget_typeid will do it for us.\n+\t(get_typeid_1): Break out call-building for expand_*_desc to use.\n+\t(get_typeid): Call it.\n+\t(expand_*_desc): Ditto.\n+\t* decl.c (init_decl_processing): Don't set TYPE_BUILT_IN on char *\n+ \tand void *.\n+\t(init_decl_processing): Lose builtin_type_tdescs lossage.\n+\t* decl2.c (finish_vtable_vardecl): Remove obsolete code.\n+\n+Mon Apr  8 17:23:23 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* pt.c (tsubst): When calling set_nested_typename, use\n+ \tTYPE_NESTED_NAME (current_class_type) instead of\n+ \tcurrent_class_name.\n+\n+\t* decl.c (pushdecl): Ditto.\n+\t(pushdecl_class_level): Ditto.\n+\t(grokdeclarator): Use NULL_TREE instead of 0 in the call to\n+\tset_nested_typename.\n+\n+Sun Apr  7 10:44:31 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (synthesize_tinfo_fn): Handle arrays.\n+\n+\t* cp-tree.h (DECL_REALLY_EXTERN): New macro.\n+\n+Sat Apr  6 13:56:27 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (throw_bad_cast): Use entry point __throw_bad_cast.\n+\t(init_rtti_processing): Lose bad_cast_type.\n+\t(build_dynamic_cast): Use throw_bad_cast.\n+\n+\t* rtti.c (synthesize_tinfo_fn): Handle enums and pmfs.\n+\n+\t* decl2.c (finish_file): Don't synthesize artificial functions\n+ \tthat are external and not inline.\n+\n+\t* rtti.c (get_tinfo_fn): If at_eof, call import_export_decl.\n+\n+\t* decl2.c (finish_file): Handle having new inlines added to\n+ \tsaved_inlines by synthesis.\n+\n+\t* rtti.c (get_bad_cast_node): Don't require <typeinfo>.\n+\n+Fri Apr  5 17:02:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tRTTI rewrite to initialize nodes as needed, not require that\n+\tusers #include <typeinfo>, complete functionality and reduce wasted \n+\tspace.\n+\t* rtti.c (init_rtti_processing): New fn.\n+\t(build_typeid): The vtable entry is now a function.\n+\t(get_tinfo_var): New fn.\n+\t(get_tinfo_fn): Ditto.\n+\t(get_typeid): Use it.\n+\t(build_dynamic_cast): Declare and use entry point __dynamic_cast.\n+\t(build_*_desc): Rename to expand_*_desc and rewrite to use entry\n+\tpoints __rtti_*.\n+\t(add_uninstantiated_desc, get_def_to_follow, build_t_desc): Lose.\n+\t(synthesize_tinfo_fn): New fn.\n+\t* method.c (build_t_desc_overload): Lose.\n+\t(build_overload_with_type): More generic.\n+\t* decl.c (init_decl_processing): Call init_rtti_processing.\n+\t* class.c (set_rtti_entry): Use get_tinfo_fn.\n+\t* decl2.c (mark_vtable_entries): Mark the rtti function.\n+\t(finish_prevtable_vardecl): Don't build_t_desc.\n+\t(import_export_decl): Handle tinfo functions.\n+\t(finish_file): Ditto.\n+\t* typeck.c (inline_conversion): New fn.\n+\t(build_function_call_real): Use it.\n+\t* cp-tree.h: Add decls.\n+\n+\t* method.c (hack_identifier): Also convert component_refs from\n+ \treferences.\n+\n+\t* lex.c (cons_up_default_function): Use the type, not the name, in\n+ \tdeclspecs.\n+\n+\t* decl2.c (import_export_vtable): Fix weak vtables.\n+\n+Fri Apr  5 13:30:17 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* search.c (get_base_distance_recursive): Fix access checks for\n+ \tprotected bases.\n+\n+Fri Apr  5 11:02:06 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* call.c (unary_complex_lvalue): Delete unneeded decl, it's in\n+\tcp-tree.h.\n+\t(convert_harshness): Add prototypes wrapped by PROTO.\n+\t* decl2.c (grok_function_init): Likewise.\n+\t(do_toplevel_using_decl): Change to void return type.\n+\t* class.c (build_vtable_entry): Remove decl of make_thunk.\n+\t(merge_overrides): Fix order of arg definitions.\n+\t(finish_vtbls): Likewise.\n+\t(fixup_vtable_deltas): Likewise.\n+\t(modify_all_direct_vtables): Likewise.\n+\t(modify_all_indirect_vtables): Likewise.\n+\t* search.c (get_base_distance_recursive): Likewise.\n+\t(get_abstract_virtuals_1): Likewise.\n+\t(fixup_virtual_upcast_offsets): Likewise.\n+\t(lookup_fnfields_1): Add prototypes wrapped by PROTO.\n+\t* init.c (perform_member_init): Fix order of arg definitions.\n+\t(expand_aggr_init_1): Add prototypes wrapped by PROTO.\n+\t* cp-tree.h (make_thunk): Add decl.\n+\t(overload_template_name, push_template_decl): Add decls.\n+\t(do_toplevel_using_decl): Change to void return type.\n+\t(vec_binfo_member): Add decl.\n+\n Thu Apr  4 13:33:10 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* typeck.c (mark_addressable, convert_for_assignment,"}, {"sha": "7afd31917cba454556cc9a051b104345563a9f6f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -38,15 +38,11 @@ Boston, MA 02111-1307, USA.  */\n extern void sorry ();\n \n extern int inhibit_warnings;\n-extern int flag_assume_nonnull_objects;\n extern tree ctor_label, dtor_label;\n \n-/* From typeck.c:  */\n-extern tree unary_complex_lvalue ();\n-\n /* Compute the ease with which a conversion can be performed\n    between an expected and the given type.  */\n-static struct harshness_code convert_harshness ();\n+static struct harshness_code convert_harshness PROTO((register tree, register tree, tree));\n \n #define EVIL_RETURN(ARG)\t((ARG).code = EVIL_CODE, (ARG))\n #define STD_RETURN(ARG)\t\t((ARG).code = STD_CODE, (ARG))"}, {"sha": "bbf259c8df9b26189d97c0963bddb9c897d36056", "filename": "gcc/cp/class.c", "status": "modified", "additions": 157, "deletions": 137, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -240,7 +240,6 @@ build_vbase_path (code, type, expr, path, alias_this)\n \n \t      if (changed)\n \t\t{\n-\t\t  extern int flag_assume_nonnull_objects;\n \t\t  tree ind;\n \n \t\t  /* We already check for ambiguous things in the caller, just\n@@ -377,7 +376,6 @@ build_vtable_entry (delta, pfn)\n   if (flag_vtable_thunks)\n     {\n       HOST_WIDE_INT idelta = TREE_INT_CST_LOW (delta);\n-      extern tree make_thunk ();\n       if (idelta)\n \t{\n \t  pfn = build1 (ADDR_EXPR, vtable_entry_type,\n@@ -425,13 +423,12 @@ build_vtable_entry (delta, pfn)\n }\n \n /* Given an object INSTANCE, return an expression which yields the\n-   virtual function corresponding to INDEX.  There are many special\n-   cases for INSTANCE which we take care of here, mainly to avoid\n-   creating extra tree nodes when we don't have to.  */\n+   virtual function vtable element corresponding to INDEX.  There are\n+   many special cases for INSTANCE which we take care of here, mainly\n+   to avoid creating extra tree nodes when we don't have to.  */\n tree\n-build_vfn_ref (ptr_to_instptr, instance, idx)\n-     tree *ptr_to_instptr, instance;\n-     tree idx;\n+build_vtbl_ref (instance, idx)\n+     tree instance, idx;\n {\n   tree vtbl, aref;\n   tree basetype = TREE_TYPE (instance);\n@@ -487,23 +484,40 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n   assemble_external (vtbl);\n   aref = build_array_ref (vtbl, idx);\n \n-  /* Save the intermediate result in a SAVE_EXPR so we don't have to\n-     compute each component of the virtual function pointer twice.  */ \n-  if (TREE_CODE (aref) == INDIRECT_REF)\n-    TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n+  return aref;\n+}\n+\n+/* Given an object INSTANCE, return an expression which yields the\n+   virtual function corresponding to INDEX.  There are many special\n+   cases for INSTANCE which we take care of here, mainly to avoid\n+   creating extra tree nodes when we don't have to.  */\n+tree\n+build_vfn_ref (ptr_to_instptr, instance, idx)\n+     tree *ptr_to_instptr, instance;\n+     tree idx;\n+{\n+  tree aref = build_vtbl_ref (instance, idx);\n \n+  /* When using thunks, there is no extra delta, and we get the pfn\n+     directly.  */\n   if (flag_vtable_thunks)\n     return aref;\n-  else\n+\n+  if (ptr_to_instptr)\n     {\n-      if (ptr_to_instptr)\n-\t*ptr_to_instptr\n-\t  = build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n-\t\t   *ptr_to_instptr,\n-\t\t   convert (ptrdiff_type_node,\n-\t\t\t    build_component_ref (aref, delta_identifier, 0, 0)));\n-      return build_component_ref (aref, pfn_identifier, 0, 0);\n+      /* Save the intermediate result in a SAVE_EXPR so we don't have to\n+\t compute each component of the virtual function pointer twice.  */ \n+      if (TREE_CODE (aref) == INDIRECT_REF)\n+\tTREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n+\n+      *ptr_to_instptr\n+\t= build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n+\t\t *ptr_to_instptr,\n+\t\t convert (ptrdiff_type_node,\n+\t\t\t  build_component_ref (aref, delta_identifier, NULL_TREE, 0)));\n     }\n+\n+  return build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n }\n \n /* Return the name of the virtual function table (as an IDENTIFIER_NODE)\n@@ -530,6 +544,70 @@ get_vtable_name (type)\n   return get_identifier (buf);\n }\n \n+/* Return the offset to the main vtable for a given base BINFO.  */\n+tree\n+get_vfield_offset (binfo)\n+     tree binfo;\n+{\n+  return size_binop (PLUS_EXPR,\n+\t\t     size_binop (FLOOR_DIV_EXPR,\n+\t\t\t\t DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))),\n+\t\t\t\t size_int (BITS_PER_UNIT)),\n+\t\t     BINFO_OFFSET (binfo));\n+}\n+\n+/* Get the offset to the start of the original binfo that we derived\n+   this binfo from.  If we find TYPE first, return the offset only\n+   that far.  The shortened search is useful because the this pointer\n+   on method calling is expected to point to a DECL_CONTEXT (fndecl)\n+   object, and not a baseclass of it.  */\n+static tree\n+get_derived_offset (binfo, type)\n+     tree binfo, type;\n+{\n+  tree offset1 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n+  tree offset2;\n+  int i;\n+  while (BINFO_BASETYPES (binfo)\n+\t && (i=CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n+    {\n+      tree binfos = BINFO_BASETYPES (binfo);\n+      if (BINFO_TYPE (binfo) == type)\n+\tbreak;\n+      binfo = TREE_VEC_ELT (binfos, i);\n+    }\n+  offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n+  return size_binop (MINUS_EXPR, offset1, offset2);\n+}\n+\n+/* Update the rtti info for this class.  */\n+static void\n+set_rtti_entry (virtuals, offset, type)\n+     tree virtuals, offset, type;\n+{\n+  tree vfn;\n+\n+  if (flag_rtti)\n+    vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, get_tinfo_fn (type));\n+  else\n+    vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, integer_zero_node);\n+  TREE_CONSTANT (vfn) = 1;\n+\n+  if (! flag_vtable_thunks)\n+    TREE_VALUE (virtuals) = build_vtable_entry (offset, vfn);\n+  else\n+    {\n+      tree voff = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+      TREE_CONSTANT (voff) = 1;\n+\n+      TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, voff);\n+\n+      /* The second slot is for the tdesc pointer when thunks are used.  */\n+      TREE_VALUE (TREE_CHAIN (virtuals))\n+\t= build_vtable_entry (integer_zero_node, vfn);\n+    }\n+}\n+\n /* Build a virtual function for type TYPE.\n    If BINFO is non-NULL, build the vtable starting with the initial\n    approximation that it is the same as the one which is the head of\n@@ -543,8 +621,15 @@ build_vtable (binfo, type)\n \n   if (binfo)\n     {\n+      tree offset;\n+\n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n       decl = build_decl (VAR_DECL, name, TREE_TYPE (BINFO_VTABLE (binfo)));\n+\n+      /* Now do rtti stuff.  */\n+      offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n+      offset = size_binop (MINUS_EXPR, integer_zero_node, offset);\n+      set_rtti_entry (virtuals, offset, type);\n     }\n   else\n     {\n@@ -649,36 +734,6 @@ build_type_pathname (format, parent, type)\n   return id;\n }\n \n-/* Update the rtti info for this class.  */\n-static void\n-set_rtti_entry (virtuals, offset, type)\n-     tree virtuals, offset, type;\n-{\n-  if (! flag_vtable_thunks)\n-    TREE_VALUE (virtuals)\n-      = build_vtable_entry (offset,\n-\t\t\t    (flag_rtti\n-\t\t\t     ? build_t_desc (type, 0)\n-\t\t\t     : integer_zero_node));\n-  else\n-    {\n-      tree vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-      TREE_CONSTANT (vfn) = 1;\n-\n-      TREE_VALUE (virtuals)\n-\t= build_vtable_entry (integer_zero_node, vfn);\n-      /* The second slot is for the tdesc pointer when thunks are used.  */\n-      vfn = flag_rtti\n-\t     ? build_t_desc (type, 0)\n-\t     : integer_zero_node;\n-      vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, vfn);\n-      TREE_CONSTANT (vfn) = 1;\n-\n-      TREE_VALUE (TREE_CHAIN (virtuals))\n-\t= build_vtable_entry (integer_zero_node, vfn);\n-    }\n-}\n-\n /* Give TYPE a new virtual function table which is initialized\n    with a skeleton-copy of its original initialization.  The only\n    entry that changes is the `delta' entry, so we can really\n@@ -716,8 +771,18 @@ prepare_fresh_vtable (binfo, for_type)\n   BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n \n   if (TREE_VIA_VIRTUAL (binfo))\n-    offset = BINFO_OFFSET (binfo_member (BINFO_TYPE (binfo), \n-\t\t\t    CLASSTYPE_VBASECLASSES (for_type)));\n+    {\n+      tree binfo1 = binfo_member (BINFO_TYPE (binfo), \n+\t\t\t\t  CLASSTYPE_VBASECLASSES (for_type));\n+\n+      /* XXX - This should never happen, if it does, the caller should\n+\t ensure that the binfo is from for_type's binfos, not from any\n+\t base type's.  We can remove all this code after a while.  */\n+      if (binfo1 != binfo)\n+\twarning (\"internal inconsistency: binfo offset error for rtti\");\n+\n+      offset = BINFO_OFFSET (binfo1);\n+    }\n   else\n     offset = BINFO_OFFSET (binfo);\n \n@@ -844,11 +909,8 @@ add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n     {\n       tree entry;\n \n-      if (flag_rtti && *has_virtual == 0)\n-\t{\n-\t  /* CLASSTYPE_RTTI is only used as a Boolean (NULL or not). */\n-\t  CLASSTYPE_RTTI (t) = integer_one_node;\n-        }\n+      /* We remember that this was the base sub-object for rtti.  */\n+      CLASSTYPE_RTTI (t) = t;\n \n       /* If we are using thunks, use two slots at the front, one\n \t for the offset pointer, one for the tdesc pointer.  */\n@@ -1177,42 +1239,6 @@ alter_access (t, fdecl, access)\n   return 0;\n }\n \n-/* Return the offset to the main vtable for a given base BINFO.  */\n-tree\n-get_vfield_offset (binfo)\n-     tree binfo;\n-{\n-  return size_binop (PLUS_EXPR,\n-\t\t     size_binop (FLOOR_DIV_EXPR,\n-\t\t\t\t DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))),\n-\t\t\t\t size_int (BITS_PER_UNIT)),\n-\t\t     BINFO_OFFSET (binfo));\n-}\n-\n-/* Get the offset to the start of the original binfo that we derived\n-   this binfo from.  If we find TYPE first, return the offset only\n-   that far.  The shortened search is useful because the this pointer\n-   on method calling is expected to point to a DECL_CONTEXT (fndecl)\n-   object, and not a baseclass of it.  */\n-static tree\n-get_derived_offset (binfo, type)\n-     tree binfo, type;\n-{\n-  tree offset1 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n-  tree offset2;\n-  int i;\n-  while (BINFO_BASETYPES (binfo)\n-\t && (i=CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo))) != -1)\n-    {\n-      tree binfos = BINFO_BASETYPES (binfo);\n-      if (BINFO_TYPE (binfo) == type)\n-\tbreak;\n-      binfo = TREE_VEC_ELT (binfos, i);\n-    }\n-  offset2 = get_vfield_offset (TYPE_BINFO (BINFO_TYPE (binfo)));\n-  return size_binop (MINUS_EXPR, offset1, offset2);\n-}\n-\n /* If FOR_TYPE needs to reinitialize virtual function table pointers\n    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.\n    Returns BASE_INIT_LIST appropriately modified.  */\n@@ -1379,6 +1405,7 @@ struct base_info\n   int n_ancestors;\n   tree vfield;\n   tree vfields;\n+  tree rtti;\n   char cant_have_default_ctor;\n   char cant_have_const_ctor;\n   char cant_synth_copy_ctor;\n@@ -1478,14 +1505,6 @@ finish_base_struct (t, b, t_binfo)\n       TYPE_OVERLOADS_ARROW (t) |= TYPE_OVERLOADS_ARROW (basetype);\n \n       if (! TREE_VIA_VIRTUAL (base_binfo)\n-#if 0\n-\t  /* This cannot be done, as prepare_fresh_vtable wants to modify\n-\t     binfos associated with vfields anywhere in the hierarchy, not\n-\t     just immediate base classes.  Due to unsharing, the compiler\n-\t     might consume 3% more memory on a real program.\n-\t     */\n-\t  && ! BINFO_OFFSET_ZEROP (base_binfo)\n-#endif\n \t  && BINFO_BASETYPES (base_binfo))\n \t{\n \t  tree base_binfos = BINFO_BASETYPES (base_binfo);\n@@ -1523,6 +1542,11 @@ finish_base_struct (t, b, t_binfo)\n \t  /* Remember that the baseclass has virtual members. */\n \t  b->base_has_virtual = 1;\n \n+\t  /* Ensure that this is set from at least a virtual base\n+             class.  */\n+\t  if (b->rtti == NULL_TREE)\n+\t    b->rtti = CLASSTYPE_RTTI (basetype);\n+\n \t  /* Don't borrow virtuals from virtual baseclasses.  */\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n@@ -1658,6 +1682,11 @@ finish_base_struct (t, b, t_binfo)\n   if (b->vfield == 0)\n     /* If all virtual functions come only from virtual baseclasses.  */\n     return -1;\n+\n+  /* Update the rtti base if we have a non-virtual base class version\n+     of it.  */\n+  b->rtti = CLASSTYPE_RTTI (BINFO_TYPE (TREE_VEC_ELT (binfos, first_vfn_base_index)));\n+\n   return first_vfn_base_index;\n }\n \n@@ -2084,8 +2113,9 @@ duplicate_tag_error (t)\n /* finish up all new vtables. */\n static void\n finish_vtbls (binfo, do_self, t)\n-     tree binfo, t;\n+     tree binfo;\n      int do_self;\n+     tree t;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n@@ -2346,8 +2376,9 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n /* These are the ones that are not through virtual base classes. */\n static void\n modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n-     tree binfo, t, fndecl, pfn;\n+     tree binfo;\n      int do_self;\n+     tree t, fndecl, pfn;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n@@ -2445,8 +2476,9 @@ fixup_vtable_deltas1 (binfo, t)\n    hierarchy, because the layout of the virtual bases has changed.  */\n static void\n fixup_vtable_deltas (binfo, init_self, t)\n-     tree binfo, t;\n+     tree binfo;\n      int init_self;\n+     tree t;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n@@ -2469,8 +2501,9 @@ fixup_vtable_deltas (binfo, init_self, t)\n /* These are the ones that are through virtual base classes. */\n static void\n modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n-     tree binfo, t, fndecl, pfn;\n+     tree binfo;\n      int do_self, via_virtual;\n+     tree t, fndecl, pfn;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n@@ -2643,8 +2676,9 @@ override_one_vtable (binfo, old, t)\n    overrides.  */\n static void\n merge_overrides (binfo, old, do_self, t)\n-     tree binfo, old, t;\n+     tree binfo, old;\n      int do_self;\n+     tree t;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   tree old_binfos = BINFO_BASETYPES (old);\n@@ -3070,13 +3104,14 @@ finish_struct_1 (t, attributes, warn_anon)\n       fields = chainon (vf, fields);\n \n       first_vfn_base_index = finish_base_struct (t, &base_info, t_binfo);\n-      /* Remember where we got our vfield from */\n+      /* Remember where we got our vfield from. */\n       CLASSTYPE_VFIELD_PARENT (t) = first_vfn_base_index;\n       has_virtual = base_info.has_virtual;\n       max_has_virtual = base_info.max_has_virtual;\n       CLASSTYPE_N_SUPERCLASSES (t) += base_info.n_ancestors;\n       vfield = base_info.vfield;\n       vfields = base_info.vfields;\n+      CLASSTYPE_RTTI (t) = base_info.rtti;\n       cant_have_default_ctor = base_info.cant_have_default_ctor;\n       cant_have_const_ctor = base_info.cant_have_const_ctor;\n       cant_synth_copy_ctor = base_info.cant_synth_copy_ctor;\n@@ -3093,6 +3128,7 @@ finish_struct_1 (t, attributes, warn_anon)\n       max_has_virtual = has_virtual;\n       vfield = NULL_TREE;\n       vfields = NULL_TREE;\n+      CLASSTYPE_RTTI (t) = NULL_TREE;\n       last_x = NULL_TREE;\n       cant_have_default_ctor = 0;\n       cant_have_const_ctor = 0;\n@@ -3560,9 +3596,6 @@ finish_struct_1 (t, attributes, warn_anon)\n     }\n \n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n-  if (flag_rtti && (max_has_virtual > 0 || base_has_virtual) && \n-\thas_virtual == 0)\n-    has_virtual = 1;\n \n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n@@ -3728,20 +3761,23 @@ finish_struct_1 (t, attributes, warn_anon)\n       DECL_SAVED_INSNS (vfield) = NULL_RTX;\n       DECL_FIELD_SIZE (vfield) = 0;\n       DECL_ALIGN (vfield) = TYPE_ALIGN (ptr_type_node);\n-      if (CLASSTYPE_RTTI (t))\n-\t{\n-\t  /* vfield is always first entry in structure.  */\n-\t  TREE_CHAIN (vfield) = fields;\n-\t  fields = vfield;\n-\t}\n-      else if (last_x)\n+#if 0\n+      /* This is more efficient, but breaks binary compatibility, turn\n+\t it on sometime when we don't care.  If we turn it on, we also\n+\t have to enable the code in dfs_init_vbase_pointers.  */\n+      /* vfield is always first entry in structure.  */\n+      TREE_CHAIN (vfield) = fields;\n+      fields = vfield;\n+#else\n+      if (last_x)\n \t{\n \t  my_friendly_assert (TREE_CHAIN (last_x) == NULL_TREE, 175);\n \t  TREE_CHAIN (last_x) = vfield;\n \t  last_x = vfield;\n \t}\n       else\n \tfields = vfield;\n+#endif\n       vfields = chainon (vfields, CLASSTYPE_AS_LIST (t));\n     }\n \n@@ -3843,17 +3879,6 @@ finish_struct_1 (t, attributes, warn_anon)\n       vbases = CLASSTYPE_VBASECLASSES (t);\n       CLASSTYPE_N_VBASECLASSES (t) = list_length (vbases);\n \n-      /* The rtti code should do this.  (mrs) */\n-#if 0 \n-      while (vbases)\n-\t{\n-\t  /* Update rtti info with offsets for virtual baseclasses.  */\n-\t  if (flag_rtti && ! BINFO_NEW_VTABLE_MARKED (vbases))\n-\t    prepare_fresh_vtable (vbases, t);\n-\t  vbases = TREE_CHAIN (vbases);\n-\t}\n-#endif\n-\n       {\n \t/* Now fixup overrides of all functions in vtables from all\n \t   direct or indirect virtual base classes.  */\n@@ -3941,34 +3966,29 @@ finish_struct_1 (t, attributes, warn_anon)\n \n   /* Under our model of GC, every C++ class gets its own virtual\n      function table, at least virtually.  */\n-  if (pending_virtuals || (flag_rtti && TYPE_VIRTUAL_P (t)))\n+  if (pending_virtuals)\n     {\n       pending_virtuals = nreverse (pending_virtuals);\n       /* We must enter these virtuals into the table.  */\n       if (first_vfn_base_index < 0)\n \t{\n-\t  /* The first slot is for the rtti offset.  */\n-\t  pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n-\n \t  /* The second slot is for the tdesc pointer when thunks are used.  */\n \t  if (flag_vtable_thunks)\n \t    pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n \n+\t  /* The first slot is for the rtti offset.  */\n+\t  pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n+\n \t  set_rtti_entry (pending_virtuals, integer_zero_node, t);\n \t  build_vtable (NULL_TREE, t);\n \t}\n       else\n \t{\n-\t  tree offset;\n \t  /* Here we know enough to change the type of our virtual\n \t     function table, but we will wait until later this function.  */\n \n \t  if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n \t    build_vtable (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), first_vfn_base_index), t);\n-\n-\t  offset = get_derived_offset (TYPE_BINFO (t), NULL_TREE);\n-\t  offset = size_binop (MINUS_EXPR, integer_zero_node, offset);\n-\t  set_rtti_entry (TYPE_BINFO_VIRTUALS (t), offset, t);\n \t}\n \n       /* If this type has basetypes with constructors, then those"}, {"sha": "c8c9fd1bb3a0a604cc3af7b1e47c2583a4ecd297", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1403,6 +1403,9 @@ extern int flag_new_for_scope;\n #define DECL_NOT_REALLY_EXTERN(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.not_really_extern)\n \n+#define DECL_REALLY_EXTERN(NODE) \\\n+  (DECL_EXTERNAL (NODE) && ! DECL_NOT_REALLY_EXTERN (NODE))\n+\n #define DECL_PUBLIC(NODE) \\\n   (TREE_CODE (NODE) == FUNCTION_DECL \\\n    ? ! DECL_C_STATIC (NODE) : TREE_PUBLIC (NODE))\n@@ -1947,6 +1950,7 @@ extern char *dont_allow_type_definitions;\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n extern tree build_vtable_entry\t\t\tPROTO((tree, tree));\n+extern tree build_vtbl_ref\t\t\tPROTO((tree, tree));\n extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));\n@@ -2074,6 +2078,8 @@ extern void pop_cp_function_context\t\tPROTO((tree));\n extern void grok_op_properties\t\t\tPROTO((tree, int, int));\n \n /* in decl2.c */\n+extern int flag_assume_nonnull_objects;\n+\n extern int lang_decode_option\t\t\tPROTO((char *));\n extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n@@ -2112,7 +2118,7 @@ extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree check_cp_case_value\t\t\tPROTO((tree));\n-extern tree do_toplevel_using_decl\t\tPROTO((tree));\n+extern void do_toplevel_using_decl\t\tPROTO((tree));\n extern tree do_class_using_decl\t\t\tPROTO((tree));\n extern tree current_namespace_id\t\tPROTO((tree));\n extern tree get_namespace_id\t\t\tPROTO((void));\n@@ -2152,10 +2158,7 @@ extern void init_repo\t\t\t\tPROTO((char*));\n extern void finish_repo\t\t\t\tPROTO((void));\n \n /* in rtti.c */\n-extern tree build_classof\t\t\tPROTO((tree));\n-extern tree build_t_desc\t\t\tPROTO((tree, int));\n-extern tree build_i_desc\t\t\tPROTO((tree));\n-extern tree build_m_desc\t\t\tPROTO((tree));\n+extern tree get_tinfo_fn\t\t\tPROTO((tree));\n extern tree build_typeid\t\t\tPROTO((tree));\n extern tree get_typeid\t\t\t\tPROTO((tree));\n extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n@@ -2269,14 +2272,15 @@ extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree cplus_exception_name\t\tPROTO((tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n extern tree build_typename_overload\t\tPROTO((tree));\n-extern tree build_t_desc_overload\t\tPROTO((tree));\n+extern tree build_overload_with_type\t\tPROTO((tree, tree));\n extern void declare_overloaded\t\t\tPROTO((tree));\n #ifdef NO_AUTO_OVERLOAD\n extern int is_overloaded\t\t\tPROTO((tree));\n #endif\n extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPROTO((tree, tree));\n extern tree build_component_type_expr\t\tPROTO((tree, tree, tree, int));\n+extern tree make_thunk\t\t\t\tPROTO((tree, int));\n extern void synthesize_method\t\t\tPROTO((tree));\n \n /* in pt.c */\n@@ -2288,10 +2292,12 @@ extern void begin_template_parm_list\t\tPROTO((void));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n+extern void push_template_decl\t\t\tPROTO((tree));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree *));\n+extern void overload_template_name\t\tPROTO((tree));\n extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n@@ -2402,6 +2408,7 @@ extern tree build_unsave_expr\t\t\tPROTO((tree));\n extern tree unsave_expr\t\t\t\tPROTO((tree));\n extern int cp_expand_decl_cleanup\t\tPROTO((tree, tree));\n extern tree get_type_decl\t\t\tPROTO((tree));\n+extern tree vec_binfo_member\t\t\tPROTO((tree, tree));\n extern tree hack_decl_function_context \t\tPROTO((tree));\n \n /* in typeck.c */\n@@ -2428,6 +2435,7 @@ extern tree expr_sizeof\t\t\t\tPROTO((tree));\n extern tree c_sizeof\t\t\t\tPROTO((tree));\n extern tree c_sizeof_nowarn\t\t\tPROTO((tree));\n extern tree c_alignof\t\t\t\tPROTO((tree));\n+extern tree inline_conversion\t\t\tPROTO((tree));\n extern tree decay_conversion\t\t\tPROTO((tree));\n extern tree default_conversion\t\t\tPROTO((tree));\n extern tree build_object_ref\t\t\tPROTO((tree, tree, tree));"}, {"sha": "d32431b2da54ee4194182c27ea6d5fc61039f3e4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 46, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -3164,7 +3164,7 @@ pushdecl (x)\n \t     Any artificial decls that need DECL_NESTED_TYPENAME will have it\n \t     set in pushtag.  */\n \t  if (! DECL_NESTED_TYPENAME (x) && ! DECL_ARTIFICIAL (x))\n-\t    set_nested_typename (x, current_class_name, DECL_NAME (x), type);\n+\t    set_nested_typename (x, current_class_type != NULL_TREE ? TYPE_NESTED_NAME (current_class_type) : current_class_name, DECL_NAME (x), type);\n \n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n@@ -3491,7 +3491,7 @@ pushdecl_class_level (x)\n \t     Any artificial decls that need DECL_NESTED_TYPENAME will have it\n \t     set in pushtag.  */\n \t  if (! DECL_NESTED_TYPENAME (x) && ! DECL_ARTIFICIAL (x))\n-\t    set_nested_typename (x, current_class_name, name, TREE_TYPE (x));\n+\t    set_nested_typename (x, current_class_type != NULL_TREE ? TYPE_NESTED_NAME (current_class_type) : current_class_name, name, TREE_TYPE (x));\n \t}\n     }\n   return x;\n@@ -4655,32 +4655,6 @@ record_builtin_type (rid_index, name, type)\n \t  set_identifier_type_value (rname, NULL_TREE);\n \t}\n     }\n-\n-  if (flag_rtti)\n-    {\n-      if (builtin_type_tdescs_len+5 >= builtin_type_tdescs_max)\n-\t{\n-\t  builtin_type_tdescs_max *= 2;\n-\t  builtin_type_tdescs_arr\n-\t    = (tree *)xrealloc (builtin_type_tdescs_arr,\n-\t\t\t\tbuiltin_type_tdescs_max * sizeof (tree));\n-\t}\n-      builtin_type_tdescs_arr[builtin_type_tdescs_len++] = type;\n-      if (TREE_CODE (type) != POINTER_TYPE)\n-\t{\n-\t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n-\t    = build_pointer_type (type);\n-\t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n-\t    = build_pointer_type (build_type_variant (type, 1, 0));\n-\t}\n-      if (TREE_CODE (type) != VOID_TYPE)\n-\t{\n-\t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n-\t    = build_reference_type (type);\n-\t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n-\t    = build_reference_type (build_type_variant (type, 1, 0));\n-\t}\n-    }\n }\n \n /* Push overloaded decl, in global scope, with one argument so it\n@@ -4695,7 +4669,8 @@ push_overloaded_decl_1 (x)\n #ifdef __GNUC__\n __inline\n #endif\n-tree auto_function (name, type, code)\n+tree\n+auto_function (name, type, code)\n      tree name, type;\n      enum built_in_function code;\n {\n@@ -4772,11 +4747,6 @@ init_decl_processing ()\n #endif\n \n   gcc_obstack_init (&decl_obstack);\n-  if (flag_rtti)\n-    {\n-      builtin_type_tdescs_max = 100;\n-      builtin_type_tdescs_arr = (tree *)xmalloc (100 * sizeof (tree));\n-    }\n \n   /* Must lay these out before anything else gets laid out.  */\n   error_mark_node = make_node (ERROR_MARK);\n@@ -4944,7 +4914,9 @@ init_decl_processing ()\n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node =\n     build_pointer_type (build_type_variant (char_type_node, 1, 0));\n+#if 0\n   record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n+#endif\n \n   /* Make a type to be the domain of a few array types\n      whose domains don't really matter.\n@@ -4972,7 +4944,9 @@ init_decl_processing ()\n   ptr_type_node = build_pointer_type (void_type_node);\n   const_ptr_type_node =\n     build_pointer_type (build_type_variant (void_type_node, 1, 0));\n+#if 0\n   record_builtin_type (RID_MAX, NULL_PTR, ptr_type_node);\n+#endif\n   endlink = void_list_node;\n   int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);\n   double_endlink = tree_cons (NULL_TREE, double_type_node, endlink);\n@@ -5471,17 +5445,6 @@ init_decl_processing ()\n       finish_builtin_type (__m_desc_type_node, \"__m_desc\", fields, 7,\n \t\t\t   integer_type_node);\n     }\n-\n-  if (flag_rtti)\n-    {\n-      int i = builtin_type_tdescs_len;\n-      while (i > 0)\n-\t{\n-\t  tree tdesc = build_t_desc (builtin_type_tdescs_arr[--i], 0);\n-\t  TREE_ASM_WRITTEN (tdesc) = 1;\n-\t  TREE_PUBLIC (TREE_OPERAND (tdesc, 0)) = 1;\n-\t}\n-    }\n #endif /*flag_rtti*/\n \n   /* Now, C++.  */\n@@ -5517,6 +5480,7 @@ init_decl_processing ()\n   init_class_processing ();\n   init_init_processing ();\n   init_search_processing ();\n+  init_rtti_processing ();\n \n   if (flag_handle_exceptions)\n     init_exception_processing ();\n@@ -9029,7 +8993,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    tree d = TYPE_NAME (type), c = DECL_CONTEXT (d);\n \n \t    if (!c)\n-\t      set_nested_typename (d, 0, declarator, type);\n+\t      set_nested_typename (d, NULL_TREE, declarator, type);\n \t    else if (TREE_CODE (c) == FUNCTION_DECL)\n \t      set_nested_typename (d, DECL_ASSEMBLER_NAME (c),\n \t\t\t\t   declarator, type);"}, {"sha": "039b427053c4b4476dddf18575b004706b8465ec", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02111-1307, USA.  */\n \n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n-static void grok_function_init ();\n+static void grok_function_init PROTO((tree, tree));\n void import_export_decl ();\n extern int current_class_depth;\n \n@@ -318,7 +318,7 @@ int flag_int_enum_equivalence;\n \n /* Controls whether compiler generates 'type descriptor' that give\n    run-time type information.  */\n-int flag_rtti;\n+int flag_rtti = 1;\n \n /* Nonzero if we wish to output cross-referencing information\n    for the GNU class browser.  */\n@@ -2430,6 +2430,14 @@ mark_vtable_entries (decl)\n {\n   tree entries = CONSTRUCTOR_ELTS (DECL_INITIAL (decl));\n \n+  if (flag_rtti)\n+    {\n+      tree fnaddr = (flag_vtable_thunks ? TREE_VALUE (TREE_CHAIN (entries))\n+\t\t     : FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries)));\n+      tree fn = TREE_OPERAND (fnaddr, 0);\n+      TREE_ADDRESSABLE (fn) = 1;\n+      mark_used (fn);\n+    }\n   skip_rtti_stuff (&entries);\n \n   for (; entries; entries = TREE_CHAIN (entries))\n@@ -2500,7 +2508,10 @@ import_export_vtable (decl, type, final)\n \t    cp_error (\"all virtual functions redeclared inline\");\n #endif\n \t  if (flag_weak)\n-\t    DECL_WEAK (decl) = 1;\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_WEAK (decl) = 1;\n+\t    }\n \t  else\n \t    TREE_PUBLIC (decl) = 0;\n \t  DECL_EXTERNAL (decl) = 0;\n@@ -2557,21 +2568,6 @@ finish_prevtable_vardecl (prev, vars)\n     }\n \n   import_export_vtable (vars, ctype, 1);\n-\n-  /* We cannot use TREE_USED here, as it may be set by the expanding of a\n-     ctor that is used to build a global object.  The long term plan is to\n-     make the TD entries statically initialized and move this to\n-     finish_vtable_vardecl time.  */\n-  if (flag_rtti && write_virtuals >= 0\n-      && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || 1 || TREE_USED (vars)))\n-    {\n-      /* Kick out the type descriptor before we dump out global\n-\t initializers, as they are initialized at run time and\n-\t we have to find them when we scan for things that need initialized\n-\t at the top level.  */\n-      build_t_desc (ctype, 1);\n-    }\n-\n   return 1;\n }\n     \n@@ -2583,15 +2579,6 @@ finish_vtable_vardecl (prev, vars)\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars))\n       && ! TREE_ASM_WRITTEN (vars))\n     {\n-#if 0\n-      /* The long term plan it to make the TD entries statically initialized,\n-\t have the entries built and emitted here.  When that happens, this\n-\t can be enabled, and the other call to build_t_desc removed.  */\n-      /* Kick out the type descriptor before writing out the vtable.  */\n-      if (flag_rtti)\n-\tbuild_t_desc (DECL_CONTEXT (vars), 1);\n-#endif\n-\n       /* Write it out.  */\n       mark_vtable_entries (vars);\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n@@ -2763,6 +2750,23 @@ import_export_decl (decl)\n       else\n \tTREE_PUBLIC (decl) = 0;\n     }\n+  /* tinfo function */\n+  else if (DECL_ARTIFICIAL (decl) && DECL_MUTABLE_P (decl))\n+    {\n+      tree ctype = TREE_TYPE (DECL_NAME (decl));\n+      if (IS_AGGR_TYPE (ctype) && CLASSTYPE_INTERFACE_KNOWN (ctype))\n+\t{\n+\t  DECL_NOT_REALLY_EXTERN (decl)\n+\t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n+\t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n+\t}\n+      else if (TYPE_BUILT_IN (ctype) && ctype == TYPE_MAIN_VARIANT (ctype))\n+\tDECL_NOT_REALLY_EXTERN (decl) = 0;\n+      else if (flag_weak)\n+\tDECL_WEAK (decl) = 1;\n+      else\n+\tTREE_PUBLIC (decl) = 0;\n+    } \n   else if (DECL_C_STATIC (decl))\n     TREE_PUBLIC (decl) = 0;\n   else if (flag_weak)\n@@ -3095,10 +3099,6 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (fnname);\n       import_export_decl (decl);\n-      if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n-\t  && TREE_PUBLIC (decl) && ! DECL_WEAK (decl)\n-\t  && DECL_NOT_REALLY_EXTERN (decl))\n-\tsynthesize_method (decl);\n     }\n \n   /* Now write out inline functions which had their addresses taken and\n@@ -3126,14 +3126,21 @@ finish_file ()\n \t    tree decl = TREE_VALUE (*p);\n \n \t    if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n-\t\t&& TREE_USED (decl))\n+\t\t&& TREE_USED (decl)\n+\t\t&& (! DECL_REALLY_EXTERN (decl) || DECL_INLINE (decl)))\n \t      {\n-\t\tsynthesize_method (decl);\n+\t\tif (DECL_MUTABLE_P (decl))\n+\t\t  synthesize_tinfo_fn (decl);\n+\t\telse\n+\t\t  synthesize_method (decl);\n \t\treconsider = 1;\n \t      }\n \n-\t    if (TREE_ASM_WRITTEN (decl)\n-\t\t|| (DECL_SAVED_INSNS (decl) == 0 && ! DECL_ARTIFICIAL (decl)))\n+\t    if (decl != TREE_VALUE (*p))\n+\t      ;\n+\t    else if (TREE_ASM_WRITTEN (decl)\n+\t\t     || (DECL_SAVED_INSNS (decl) == 0\n+\t\t\t && ! DECL_ARTIFICIAL (decl)))\n \t      *p = TREE_CHAIN (*p);\n \t    else\n \t      p = &TREE_CHAIN (*p);\n@@ -3619,7 +3626,7 @@ do_namespace_alias (alias, namespace)\n   sorry (\"namespace alias\");\n }\n \n-tree\n+void\n do_toplevel_using_decl (decl)\n      tree decl;\n {"}, {"sha": "e5e186e4b9ccb6348381ed6adaea26a063c4c571", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -51,7 +51,7 @@ static void expand_aggr_vbase_init ();\n void expand_member_init ();\n void expand_aggr_init ();\n \n-static void expand_aggr_init_1 ();\n+static void expand_aggr_init_1 PROTO((tree, tree, tree, tree, int, int));\n static void expand_virtual_init PROTO((tree, tree));\n tree expand_vec_init ();\n \n@@ -152,8 +152,9 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n /* Subroutine of emit_base_init.  */\n static void\n perform_member_init (member, name, init, explicit, protect_list)\n-     tree member, name, init, *protect_list;\n+     tree member, name, init;\n      int explicit;\n+     tree *protect_list;\n {\n   tree decl;\n   tree type = TREE_TYPE (member);\n@@ -941,7 +942,7 @@ expand_member_init (exp, name, init)\n \n   type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n-  if (TREE_CODE (name) == TYPE_DECL)\n+  if (name && TREE_CODE (name) == TYPE_DECL)\n     {\n       basetype = TREE_TYPE (name);\n       name = DECL_NAME (name);\n@@ -2827,8 +2828,9 @@ build_new (placement, decl, init, use_global_new)\n \t not expanded as part of the RTL_EXPR for the initialization,\n \t so we can't just use save_expr here.  */\n \n-      alloc_temp = get_temp_name (TREE_TYPE (rval), 0);\n-      alloc_expr = build (MODIFY_EXPR, TREE_TYPE (rval), alloc_temp, rval);\n+      alloc_temp = build (VAR_DECL, TREE_TYPE (rval));\n+      layout_decl (alloc_temp, 0);\n+      alloc_expr = build (TARGET_EXPR, TREE_TYPE (rval), alloc_temp, rval, 0);\n       TREE_SIDE_EFFECTS (alloc_expr) = 1;\n       rval = alloc_temp;\n     }"}, {"sha": "bbc8b045f1e16fcecea881686e8630654c3387dc", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1650,7 +1650,7 @@ cons_up_default_function (type, full_name, kind)\n       /* Fall through...  */\n     case 6:\n       retref = 1;\n-      declspecs = build_decl_list (NULL_TREE, full_name);\n+      declspecs = build_decl_list (NULL_TREE, type);\n \n       name = ansi_opname [(int) MODIFY_EXPR];\n "}, {"sha": "8d1bba75f8ca7c64e07c765a64ea7d91f4b7812b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1073,49 +1073,14 @@ build_typename_overload (type)\n   return id;\n }\n \n-#ifndef NO_DOLLAR_IN_LABEL\n-#define T_DESC_FORMAT \"TD$\"\n-#define I_DESC_FORMAT \"ID$\"\n-#define M_DESC_FORMAT \"MD$\"\n-#else\n-#if !defined(NO_DOT_IN_LABEL)\n-#define T_DESC_FORMAT \"TD.\"\n-#define I_DESC_FORMAT \"ID.\"\n-#define M_DESC_FORMAT \"MD.\"\n-#else\n-#define T_DESC_FORMAT \"__t_desc_\"\n-#define I_DESC_FORMAT \"__i_desc_\"\n-#define M_DESC_FORMAT \"__m_desc_\"\n-#endif\n-#endif\n-\n-/* Build an overload name for the type expression TYPE.  */\n tree\n-build_t_desc_overload (type)\n-     tree type;\n+build_overload_with_type (name, type)\n+     tree name, type;\n {\n   OB_INIT ();\n-  OB_PUTS (T_DESC_FORMAT);\n+  OB_PUTID (name);\n   nofold = 1;\n \n-#if 0\n-  /* Use a different format if the type isn't defined yet.  */\n-  if (TYPE_SIZE (type) == NULL_TREE)\n-    {\n-      char *p;\n-      int changed;\n-\n-      for (p = tname; *p; p++)\n-\tif (isupper (*p))\n-\t  {\n-\t    changed = 1;\n-\t    *p = tolower (*p);\n-\t  }\n-      /* If there's no change, we have an inappropriate T_DESC_FORMAT.  */\n-      my_friendly_assert (changed != 0, 249);\n-    }\n-#endif\n-\n   build_overload_name (type, 0, 1);\n   return get_identifier (obstack_base (&scratch_obstack));\n }\n@@ -1580,10 +1545,9 @@ hack_identifier (value, name)\n \t this field was initialized by a base initializer,\n \t we can emit an error message.  */\n       TREE_USED (value) = 1;\n-      return build_component_ref (C_C_D, name, 0, 1);\n+      value = build_component_ref (C_C_D, name, 0, 1);\n     }\n-\n-  if (really_overloaded_fn (value))\n+  else if (really_overloaded_fn (value))\n     {\n #if 0\n       tree t = get_first_fn (value);\n@@ -1668,12 +1632,7 @@ hack_identifier (value, name)\n     }\n \n   if (TREE_CODE (type) == REFERENCE_TYPE && ! current_template_parms)\n-    {\n-      my_friendly_assert (TREE_CODE (value) == VAR_DECL\n-\t\t\t  || TREE_CODE (value) == PARM_DECL\n-\t\t\t  || TREE_CODE (value) == RESULT_DECL, 252);\n-      return convert_from_reference (value);\n-    }\n+    value = convert_from_reference (value);\n   return value;\n }\n "}, {"sha": "c1e422baeea688a4f6385504689e83d39fb1da07", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1185,7 +1185,7 @@ instantiate_class_template (type)\n \t  require_complete_type (tmp);\n \n       /* XXX handle attributes */\n-      type = finish_struct_1 (type, 0, 0);\n+      type = finish_struct_1 (type, NULL_TREE, 0);\n     }\n   else\n     {\n@@ -1578,7 +1578,7 @@ tsubst (t, args, nargs, in_decl)\n \ttree r = copy_node (t);\n \tTREE_TYPE (r) = type;\n \tDECL_CONTEXT (r) = current_class_type;\n-\tset_nested_typename (r, current_class_name, DECL_NAME (r), type);\n+\tset_nested_typename (r, current_class_type != NULL_TREE ? TYPE_NESTED_NAME (current_class_type) : current_class_name, DECL_NAME (r), type);\n \tTREE_CHAIN (r) = NULL_TREE;\n \treturn r;\n       }\t  "}, {"sha": "75eff1ded525f222dfc6cd9abe9d19d6dfea1e17", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 559, "deletions": 412, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1,5 +1,6 @@\n /* RunTime Type Identification\n    Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Mostly written by Jason Merrill (jason@cygnus.com).\n \n This file is part of GNU CC.\n \n@@ -32,16 +33,50 @@ extern tree define_function ();\n extern tree build_t_desc_overload ();\n extern struct obstack *permanent_obstack;\n \n+tree type_info_type_node;\n+tree tinfo_fn_id;\n+tree tinfo_fn_type;\n+\n /* in c-common.c */\n extern tree combine_strings PROTO((tree));\n \f\n-/* Given the expression EXP of type `class *', return the head\n-   of the object pointed to by EXP.  */\n+void\n+init_rtti_processing ()\n+{\n+  type_info_type_node = xref_tag\n+    (class_type_node, get_identifier (\"type_info\"), NULL_TREE, 1);\n+  tinfo_fn_id = get_identifier (\"__tf\");\n+  tinfo_fn_type = build_function_type\n+    (build_reference_type (build_type_variant (type_info_type_node, 1, 0)),\n+     void_list_node);\n+}\n+\n+/* Given a pointer to an object with at least one virtual table\n+   pointer somewhere, return a pointer to a possible sub-object that\n+   has a virtual table pointer in it that is the vtable parent for\n+   that sub-object.  */\n+static tree\n+build_headof_sub (exp)\n+     tree exp;\n+{\n+  tree type = TREE_TYPE (TREE_TYPE (exp));\n+  tree basetype = CLASSTYPE_RTTI (type);\n+  tree binfo = get_binfo (basetype, type, 0);\n+\n+  exp = convert_pointer_to_real (binfo, exp);\n+  return exp;\n+}\n+\n+/* Given the expression EXP of type `class *', return the head of the\n+   object pointed to by EXP with type cv void*, if the class has any\n+   virtual functions (TYPE_VIRTUAL_P), else just return the\n+   expression.  */\n static tree\n build_headof (exp)\n      tree exp;\n {\n   tree type = TREE_TYPE (exp);\n+  tree aref;\n   tree vptr, offset;\n \n   if (TREE_CODE (type) != POINTER_TYPE)\n@@ -51,22 +86,22 @@ build_headof (exp)\n     }\n   type = TREE_TYPE (type);\n \n-  if (!TYPE_VIRTUAL_P (type) || CLASSTYPE_VFIELD (type) == NULL_TREE)\n+  if (!TYPE_VIRTUAL_P (type))\n     return exp;\n \n-  vptr = fold (size_binop (PLUS_EXPR, \n-\t   size_binop (FLOOR_DIV_EXPR, \n-  \t     DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (type)),\n-\t     size_int (BITS_PER_UNIT)),\n- \t   exp)); \n-  vptr = build1 (INDIRECT_REF, build_pointer_type (vtable_entry_type), vptr);\n+  /* If we don't have rtti stuff, get to a sub-object that does.  */\n+  if (!CLASSTYPE_VFIELDS (TREE_TYPE (TREE_TYPE (exp))))\n+    exp = build_headof_sub (exp);\n+\n+  /* We use this a couple of times below, protect it.  */\n+  exp = save_expr (exp);\n+\n+  aref = build_vtbl_ref (build_indirect_ref (exp, NULL_PTR), integer_zero_node);\n \n   if (flag_vtable_thunks)\n-    offset = build_array_ref (vptr, integer_zero_node);\n+    offset = aref;\n   else\n-    offset = build_component_ref (build_array_ref (vptr, integer_zero_node),\n-\t\t\t\t  delta_identifier,\n-\t\t\t\t  NULL_TREE, 0);\n+    offset = build_component_ref (aref, delta_identifier, NULL_TREE, 0);\n \n   type = build_type_variant (ptr_type_node, TREE_READONLY (exp),\n \t\t\t     TREE_THIS_VOLATILE (exp));\n@@ -83,9 +118,6 @@ build_typeid (exp)\n {\n   tree type;\n \n-  if (!flag_rtti)\n-    cp_error (\"cannot take typeid of object when -frtti is not specified\");\n-\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n@@ -116,69 +148,189 @@ build_typeid (exp)\n       /* build reference to type_info from vtable.  */\n       tree t;\n \n+      if (! flag_rtti)\n+\twarning (\"taking dynamic typeid of object without -frtti\");\n+\n+      /* If we don't have rtti stuff, get to a sub-object that does.  */\n+      if (!CLASSTYPE_VFIELDS (TREE_TYPE (type)))\n+\t{\n+\t  exp = build_unary_op (ADDR_EXPR, exp, 0);\n+\t  exp = build_headof_sub (exp);\n+\t  exp = build_indirect_ref (exp, NULL_PTR);\n+\t}\n+\n       if (flag_vtable_thunks)\n-\tt = build_vfn_ref ((tree *) NULL_TREE, exp, integer_one_node);\n+\tt = build_vfn_ref ((tree *) 0, exp, integer_one_node);\n       else\n-\tt = build_vfn_ref ((tree *) NULL_TREE, exp, integer_zero_node);\n+\tt = build_vfn_ref ((tree *) 0, exp, integer_zero_node);\n+      TREE_TYPE (t) = build_pointer_type (tinfo_fn_type);\n \n-      TREE_TYPE (t) = build_pointer_type (__class_desc_type_node);\n-      t = build_indirect_ref (t, NULL);\n-      return t;\n+      t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type), t, NULL_TREE, 0);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      return convert_from_reference (t);\n     }\n \n   /* otherwise return the type_info for the static type of the expr.  */\n   return get_typeid (type);\n }\n \n+tree\n+get_tinfo_var (type)\n+     tree type;\n+{\n+  tree tname = build_overload_with_type (get_identifier (\"__ti\"), type);\n+  tree tdecl, arrtype;\n+  int size;\n+\n+  if (IDENTIFIER_GLOBAL_VALUE (tname))\n+    return IDENTIFIER_GLOBAL_VALUE (tname);\n+    \n+  /* Figure out how much space we need to allocate for the type_info object.\n+     If our struct layout or the type_info classes are changed, this will\n+     need to be modified.  */\n+  if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n+    size = 4 * POINTER_SIZE;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && ! (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n+\t\t || TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE))\n+    size = 3 * POINTER_SIZE;\n+  else if (IS_AGGR_TYPE (type))\n+    {\n+      if (CLASSTYPE_N_BASECLASSES (type) == 0)\n+\tsize = 2 * POINTER_SIZE;\n+      else if (! TYPE_USES_COMPLEX_INHERITANCE (type)\n+\t       && (TREE_VIA_PUBLIC\n+\t\t   (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0))))\n+\tsize = 3 * POINTER_SIZE;\n+      else\n+\tsize = 4 * POINTER_SIZE;\n+    }\n+  else\n+    size = 2 * POINTER_SIZE;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  /* The type for a character array of the appropriate size.  */\n+  arrtype = build_cplus_array_type\n+    (unsigned_char_type_node,\n+     build_index_type (size_int (size / BITS_PER_UNIT - 1)));\n+\n+  tdecl = build_decl (VAR_DECL, tname, arrtype);\n+  TREE_PUBLIC (tdecl) = 1;\n+  DECL_EXTERNAL (tdecl) = 1;\n+  DECL_ARTIFICIAL (tdecl) = 1;\n+  pushdecl_top_level (tdecl);\n+  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+\n+  pop_obstacks ();\n+\n+  return tdecl;\n+}\n+\n+tree\n+get_tinfo_fn (type)\n+     tree type;\n+{\n+  tree name = build_overload_with_type (tinfo_fn_id, type);\n+  tree d;\n+\n+  if (IDENTIFIER_GLOBAL_VALUE (name))\n+    return IDENTIFIER_GLOBAL_VALUE (name);\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  d = build_lang_decl (FUNCTION_DECL, name, tinfo_fn_type);\n+  DECL_EXTERNAL (d) = 1;\n+  TREE_PUBLIC (d) = 1;\n+  DECL_ARTIFICIAL (d) = 1;\n+  DECL_NOT_REALLY_EXTERN (d) = 1;\n+  DECL_MUTABLE_P (d) = 1;\n+  TREE_TYPE (name) = type;\n+  pushdecl_top_level (d);\n+  make_function_rtl (d);\n+  mark_inline_for_output (d);\n+  if (at_eof)\n+    import_export_decl (d);\n+\n+  pop_obstacks ();\n+\n+  return d;\n+}\n+\n+tree\n+get_typeid_1 (type)\n+     tree type;\n+{\n+  tree t = build (CALL_EXPR, TREE_TYPE (tinfo_fn_type),\n+\t\t  default_conversion (get_tinfo_fn (type)), NULL_TREE, 0);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  return convert_from_reference (t);\n+}\n+  \n /* Return the type_info object for TYPE, creating it if necessary.  */\n tree\n get_typeid (type)\n      tree type;\n {\n-  tree t, td;\n+  tree t;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n   \n-  /* Is it useful (and/or correct) to have different typeids for `T &'\n-     and `T'?  */\n+  /* If the type of the type-id is a reference type, the result of the\n+     typeid expression refers to a type_info object representing the\n+     referenced type.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  td = build_t_desc (type, 1);\n-  if (td == error_mark_node)\n-    return error_mark_node;\n+  /* The top-level cv-qualifiers of the lvalue expression or the type-id\n+     that is the operand of typeid are always ignored. */\n+  type = TYPE_MAIN_VARIANT (type);\n \n-  t = TREE_OPERAND (td, 0);\n-  return t;\n+  return get_typeid_1 (type);\n }\n \n /* Get a bad_cast node for the program to throw...\n \n-   See libstdc++::exception{,.cc} for __bad_cast_object */\n+   See libstdc++/exception.cc for __throw_bad_cast */\n+\n static tree\n-get_bad_cast_node ()\n+throw_bad_cast ()\n {\n-  static tree t;\n-  if (t == NULL_TREE\n-      && (t = lookup_name (get_identifier (\"__bad_cast_object\"), 0))\n-         == NULL_TREE)\n-    {\n-      error (\"you must #include <typeinfo>\");\n-      return error_mark_node;\n-    }\n-  return t;\n+  tree d = get_identifier (\"__throw_bad_cast\");\n+  tree type;\n+  \n+  if (IDENTIFIER_GLOBAL_VALUE (d))\n+    return IDENTIFIER_GLOBAL_VALUE (d);\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  type = build_function_type (void_type_node, void_list_node);\n+  d = build_lang_decl (FUNCTION_DECL, d, type);\n+  DECL_EXTERNAL (d) = 1;\n+  TREE_PUBLIC (d) = 1;\n+  DECL_ARTIFICIAL (d) = 1;\n+  pushdecl_top_level (d);\n+  make_function_rtl (d);\n+\n+  pop_obstacks ();\n+\n+  d = build (CALL_EXPR, void_type_node, default_conversion (d), NULL_TREE, 0);\n+  TREE_SIDE_EFFECTS (d) = 1;\n+  return d;\n }\n \n /* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n    paper.  */\n+\n tree\n build_dynamic_cast (type, expr)\n      tree type, expr;\n {\n   enum tree_code tc = TREE_CODE (type);\n   tree exprtype = TREE_TYPE (expr);\n   enum tree_code ec = TREE_CODE (exprtype);\n+  tree dcast_fn;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -264,12 +416,15 @@ build_dynamic_cast (type, expr)\n \t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE)\n \t    return build1 (NOP_EXPR, type, expr);\n \n-\t  return build_headof (expr);\n+\t  expr = build_headof (expr);\n+\t  if (TREE_TYPE (expr) != type)\n+\t    expr = build1 (NOP_EXPR, type, expr);\n+\t  return expr;\n \t}\n       else\n \t{\n \t  tree retval;\n-          tree result, td1, td2, elems, expr1;\n+          tree result, td1, td2, td3, elems, expr1, expr2;\n \n  \t  /* If we got here, we can't convert statically.  Therefore,\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n@@ -280,7 +435,7 @@ build_dynamic_cast (type, expr)\n \t\t{\n \t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      expr, type);\n-\t\t  return build_throw (get_bad_cast_node ());\n+\t\t  return throw_bad_cast ();\n \t\t}\n \t    }\n \t  /* Ditto for dynamic_cast<D*>(&b).  */\n@@ -298,29 +453,66 @@ build_dynamic_cast (type, expr)\n \t\t}\n \t    }\n \n+\t  /* Since expr is used twice below, save it.  */\n+\t  expr = save_expr (expr);\n+\n \t  expr1 = expr;\n \t  if (tc == REFERENCE_TYPE)\n \t    expr1 = build_unary_op (ADDR_EXPR, expr1, 0);\n \n \t  /* Build run-time conversion.  */\n-\t  expr1 = build_headof (expr1);\n+\t  expr2 = build_headof (expr1);\n \n \t  if (ec == POINTER_TYPE)\n \t    td1 = build_typeid (build_indirect_ref (expr, NULL_PTR));\n \t  else\n \t    td1 = build_typeid (expr);\n \t  \n-\t  td2 = get_typeid (TYPE_MAIN_VARIANT (TREE_TYPE (type)));\n-\n-          elems = tree_cons (NULL_TREE, td2,\n-            tree_cons (NULL_TREE, build_int_2 (1, 0),\n-\t      tree_cons (NULL_TREE, expr1, NULL_TREE)));\n-          result = build_method_call (td1,\n-            get_identifier (\"__rtti_match\"), elems, NULL_TREE, LOOKUP_NORMAL);\n+\t  td2 = get_typeid (TREE_TYPE (type));\n+\t  td3 = get_typeid (TREE_TYPE (exprtype));\n+\n+          elems = tree_cons\n+\t    (NULL_TREE, TREE_OPERAND (td1, 0), tree_cons\n+\t     (NULL_TREE, TREE_OPERAND (td2, 0), tree_cons\n+\t      (NULL_TREE, build_int_2 (1, 0), tree_cons\n+\t       (NULL_TREE, expr2, tree_cons\n+\t\t(NULL_TREE, TREE_OPERAND (td3, 0), tree_cons\n+\t\t (NULL_TREE, expr1, NULL_TREE))))));\n+\n+\t  dcast_fn = get_identifier (\"__dynamic_cast\");\n+\t  if (IDENTIFIER_GLOBAL_VALUE (dcast_fn))\n+\t    dcast_fn = IDENTIFIER_GLOBAL_VALUE (dcast_fn);\n+\t  else\n+\t    {\n+\t      tree tmp;\n+\n+\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t      tmp = build_reference_type\n+\t\t(build_type_variant (type_info_type_node, 1, 0));\n+\t      tmp = tree_cons\n+\t\t(NULL_TREE, tmp, tree_cons\n+\t\t (NULL_TREE, tmp, tree_cons\n+\t\t  (NULL_TREE, integer_type_node, tree_cons\n+\t\t   (NULL_TREE, ptr_type_node, tree_cons\n+\t\t    (NULL_TREE, tmp, tree_cons\n+\t\t     (NULL_TREE, ptr_type_node, void_list_node))))));\n+\t      tmp = build_function_type (ptr_type_node, tmp);\n+\t      dcast_fn = build_lang_decl (FUNCTION_DECL, dcast_fn, tmp);\n+\t      DECL_EXTERNAL (dcast_fn) = 1;\n+\t      TREE_PUBLIC (dcast_fn) = 1;\n+\t      DECL_ARTIFICIAL (dcast_fn) = 1;\n+\t      pushdecl_top_level (dcast_fn);\n+\t      make_function_rtl (dcast_fn);\n+\t      pop_obstacks ();\n+\t    }\n+\t  \n+          result = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (dcast_fn)),\n+\t\t\t  decay_conversion (dcast_fn), elems, 0);\n+\t  TREE_SIDE_EFFECTS (result) = 1;\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {\n-\t      expr1 = build_throw (get_bad_cast_node ());\n+\t      expr1 = throw_bad_cast ();\n \t      expr1 = build_compound_expr (tree_cons (NULL_TREE, expr1,\n \t\t\t\t\t\t      build_tree_list (NULL_TREE, convert (type, integer_zero_node))));\n \t      TREE_TYPE (expr1) = type;\n@@ -354,129 +546,67 @@ build_dynamic_cast (type, expr)\n    Note: these constructors always return the address of the descriptor\n    info, since that is simplest for their mutual interaction.  */\n \n-static tree\n-build_generic_desc (tdecl, type, elems)\n-     tree tdecl;\n-     tree type;\n-     tree elems;\n-{\n-  tree init = elems;\n-  int toplev = global_bindings_p ();\n+extern tree const_string_type_node;\n \n-  TREE_CONSTANT (init) = 1;\n-  TREE_STATIC (init) = 1;\n-  TREE_READONLY (init) = 1;\n+/* Build an initializer for a __si_type_info node.  */\n \n-  TREE_TYPE (tdecl) = type;\n-  DECL_INITIAL (tdecl) = init;\n-  TREE_STATIC (tdecl) = 1;\n-  DECL_SIZE (tdecl) = NULL_TREE;\n-  layout_decl (tdecl, 0);\n-  if (! toplev)\n-    push_to_top_level ();\n-  cp_finish_decl (tdecl, init, NULL_TREE, 0, 0);\n-  if (! toplev)\n-    pop_from_top_level ();\n-\n-  if (! TREE_USED (tdecl))\n-    {\n-      assemble_external (tdecl);\n-      TREE_USED (tdecl) = 1;\n-    }\n-\n-  return IDENTIFIER_AS_DESC (DECL_NAME (tdecl));\n-}\n-\n-/* Build an initializer for a __bltn_desc node.  */\n-static tree\n-build_bltn_desc (tdecl, type)\n+static void\n+expand_si_desc (tdecl, type)\n      tree tdecl;\n      tree type;\n {\n-  tree elems, t;\n-\n-  if (type == boolean_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_BOOL\"),\n-\t\t      0, 0);\n-  else if (type == char_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_CHAR\"),\n-\t\t      0, 0);\n-  else if (type == short_integer_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_SHORT\"),\n-\t\t      0, 0);\n-  else if (type == integer_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_INT\"),\n-\t\t      0, 0);\n-  else if (type == long_integer_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_LONG\"),\n-\t\t      0, 0);\n-  else if (type == long_long_integer_type_node)\n-    t = lookup_field (__bltn_desc_type_node, \n-\t\t      get_identifier(\"_RTTI_BI_LONGLONG\"), 0, 0);\n-  else if (type == float_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_FLOAT\"),\n-\t\t      0, 0);\n-  else if (type == double_type_node)\n-    t = lookup_field (__bltn_desc_type_node, \n-\t\t      get_identifier(\"_RTTI_BI_DOUBLE\"), 0, 0);\n-  else if (type == long_double_type_node)\n-    t = lookup_field (__bltn_desc_type_node, \n-\t\t      get_identifier(\"_RTTI_BI_LDOUBLE\"), 0, 0);\n-  else if (type == unsigned_char_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_UCHAR\"),\n-\t\t      0, 0);\n-  else if (type == short_unsigned_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_USHORT\"),\n-\t\t      0, 0);\n-  else if (type == unsigned_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_UINT\"),\n-\t\t      0, 0);\n-  else if (type == long_unsigned_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_ULONG\"),\n-\t\t      0, 0);\n-  else if (type == long_long_unsigned_type_node)\n-    t = lookup_field (__bltn_desc_type_node, \n-\t\t      get_identifier(\"_RTTI_BI_ULONGLONG\"), 0, 0);\n-  else if (type == signed_char_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_SCHAR\"),\n-\t\t      0, 0);\n-  else if (type == wchar_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_WCHAR\"),\n-\t\t      0, 0);\n-  else if (type == void_type_node)\n-    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_VOID\"),\n-\t\t      0, 0);\n+  tree t, elems, fn;\n+  char *name = build_overload_name (type, 1, 1);\n+  tree name_string = combine_strings (build_string (strlen (name), name));\n+\n+  type = BINFO_TYPE (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0));\n+  expand_expr_stmt (get_typeid_1 (type));\n+  t = decay_conversion (get_tinfo_var (type));\n+  elems = tree_cons\n+    (NULL_TREE, decay_conversion (tdecl), tree_cons\n+     (NULL_TREE, decay_conversion (name_string), tree_cons\n+      (NULL_TREE, t, NULL_TREE)));\n+\n+  fn = get_identifier (\"__rtti_si\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      cp_compiler_error (\"type `%T' not handled as a built-in type\");\n+      tree tmp;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      tmp = tree_cons\n+\t(NULL_TREE, ptr_type_node, tree_cons\n+\t (NULL_TREE, const_string_type_node, tree_cons\n+\t  (NULL_TREE, build_pointer_type (type_info_type_node),\n+\t   void_list_node)));\n+      tmp = build_function_type\t(void_type_node, tmp);\n+  \n+      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      pop_obstacks ();\n     }\n \n-  elems = tree_cons (NULL_TREE, t, NULL_TREE);\n-  return build_generic_desc (tdecl, __bltn_desc_type_node, elems);\n-}\n-\n-/* Build an initializer for a __user_desc node.  */\n-static tree\n-build_user_desc (tdecl)\n-     tree tdecl;\n-{\n-  tree elems, name_string;\n-  tree tname = DECL_NAME (tdecl);\n-\n-  name_string = combine_strings (build_string \n-    (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n-  elems = name_string;\n-  return build_generic_desc (tdecl, __user_desc_type_node, elems);\n+  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t      decay_conversion (fn), elems, 0);\n+  TREE_SIDE_EFFECTS (fn) = 1;\n+  expand_expr_stmt (fn);\n }\n \n /* Build an initializer for a __class_type_info node. */\n-static tree\n-build_class_desc (tdecl, type)\n+\n+static void\n+expand_class_desc (tdecl, type)\n      tree tdecl;\n      tree type;\n {\n-  tree tname = DECL_NAME (tdecl);\n+  tree tname = TYPE_NESTED_NAME (type);\n   tree name_string;\n+  tree fn, tmp;\n+  char *name;\n \n   int i = CLASSTYPE_N_BASECLASSES (type);\n   int base_cnt = 0;\n@@ -487,30 +617,50 @@ build_class_desc (tdecl, type)\n   int n_base = i;\n #endif\n   tree base, elems, access, offset, isvir;\n-  tree base_list, off_list, acc_list, isvir_list;\n-  static tree acc_pub = NULL_TREE;\n-  static tree acc_pro = NULL_TREE;\n-  static tree acc_pri = NULL_TREE;\n+  tree elt, elts = NULL_TREE;\n+  static tree base_info_type_node;\n \n-  if (acc_pub == NULL_TREE) \n+  if (base_info_type_node == NULL_TREE)\n     {\n-      acc_pub = lookup_field (__class_desc_type_node, \n-                                get_identifier(\"_RTTI_ACCESS_PUBLIC\"), 0, 0);\n-      acc_pro = lookup_field (__class_desc_type_node,\n-                                get_identifier(\"_RTTI_ACCESS_PROTECTED\"), 0, 0);\n-      acc_pri = lookup_field (__class_desc_type_node,\n-                                get_identifier(\"_RTTI_ACCESS_PRIVATE\"), 0, 0);\n+      tree fields [4];\n+\n+      /* A reasonably close approximation of __class_type_info::base_info */\n+\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      base_info_type_node = make_lang_type (RECORD_TYPE);\n+\n+      /* Actually const __user_type_info * */\n+      fields [0] = build_lang_field_decl\n+\t(FIELD_DECL, NULL_TREE,\n+\t build_pointer_type (build_type_variant (type_info_type_node, 1, 0)));\n+      fields [1] = build_lang_field_decl\n+\t(FIELD_DECL, NULL_TREE, sizetype);\n+      DECL_BIT_FIELD (fields[1]) = 1;\n+      DECL_FIELD_SIZE (fields[1]) = 29;\n+\n+      fields [2] = build_lang_field_decl\n+\t(FIELD_DECL, NULL_TREE, boolean_type_node);\n+      DECL_BIT_FIELD (fields[2]) = 1;\n+      DECL_FIELD_SIZE (fields[2]) = 1;\n+\n+      /* Actually enum access */\n+      fields [3] = build_lang_field_decl\n+\t(FIELD_DECL, NULL_TREE, integer_type_node);\n+      DECL_BIT_FIELD (fields[3]) = 1;\n+      DECL_FIELD_SIZE (fields[3]) = 2;\n+\n+      finish_builtin_type (base_info_type_node, \"__base_info\", fields,\n+\t\t\t   3, ptr_type_node);\n+      pop_obstacks ();\n     }\n \n-  base_list = build_tree_list (NULL_TREE, integer_zero_node);\n-  off_list = build_tree_list (NULL_TREE, integer_zero_node);\n-  acc_list = build_tree_list (NULL_TREE, integer_zero_node);\n-  isvir_list = build_tree_list (NULL_TREE, integer_zero_node);\n   while (--i >= 0)\n     {\n       tree binfo = TREE_VEC_ELT (binfos, i);\n \n-      base = build_t_desc (BINFO_TYPE (binfo), 1);\n+      expand_expr_stmt (get_typeid_1 (BINFO_TYPE (binfo)));\n+      base = decay_conversion (get_tinfo_var (BINFO_TYPE (binfo)));\n+\n       if (TREE_VIA_VIRTUAL (binfo))\n \t{\n \t  tree t = BINFO_TYPE (binfo);\n@@ -527,39 +677,43 @@ build_class_desc (tdecl, type)\n \toffset = BINFO_OFFSET (binfo);\n \n       if (TREE_VIA_PUBLIC (binfo))\n-        access = acc_pub;\n+        access = access_public_node;\n       else if (TREE_VIA_PROTECTED (binfo))\n-\taccess = acc_pro;\n+\taccess = access_protected_node;\n       else\n-\taccess = acc_pri;\n+\taccess = access_private_node;\n       if (TREE_VIA_VIRTUAL (binfo))\n-\tisvir = build_int_2 (1, 0);\n+\tisvir = boolean_true_node;\n       else\n-\tisvir = build_int_2 (0, 0);\n-\n-      base_list = tree_cons (NULL_TREE, base, base_list);\n-      isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);\n-      acc_list = tree_cons (NULL_TREE, access, acc_list);\n-      off_list = tree_cons (NULL_TREE, offset, off_list);\n+\tisvir = boolean_false_node;\n+\n+      elt = build\n+\t(CONSTRUCTOR, base_info_type_node, NULL_TREE, tree_cons\n+\t (NULL_TREE, base, tree_cons\n+\t  (NULL_TREE, offset, tree_cons\n+\t   (NULL_TREE, isvir, tree_cons\n+\t    (NULL_TREE, access, NULL_TREE)))));\n+      TREE_HAS_CONSTRUCTOR (elt) = TREE_CONSTANT (elt) = TREE_STATIC (elt) = 1;\n+      elts = tree_cons (NULL_TREE, elt, elts);\n       base_cnt++;\n     }\n #if 0\n   i = n_base;\n   while (vb)\n     {\n       tree b;\n-      access = acc_pub;\n+      access = access_public_node;\n       while (--i >= 0)\n \t{\n \t  b = TREE_VEC_ELT (binfos, i);\n \t  if (BINFO_TYPE (vb) == BINFO_TYPE (b) && TREE_VIA_VIRTUAL (b))\n \t    {\n \t      if (TREE_VIA_PUBLIC (b))\n-\t\taccess = acc_pub;\n+\t\taccess = access_public_node;\n \t      else if (TREE_VIA_PROTECTED (b))\n-\t\taccess = acc_pro;\n+\t\taccess = access_protected_node;\n \t      else\n-\t\taccess = acc_pri;\n+\t\taccess = access_private_node;\n \t      break;\n \t    }\n \t}\n@@ -576,278 +730,271 @@ build_class_desc (tdecl, type)\n       vb = TREE_CHAIN (vb);\n     }\n #endif\n-  base_list = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), \n-\t\t\t    base_list, 0);\n-  off_list = finish_table (NULL_TREE, integer_type_node, \n-\t\t\t    off_list, 0);\n-  isvir_list = finish_table (NULL_TREE, integer_type_node, \n-\t\t\t    isvir_list, 0);\n-  acc_list = finish_table (NULL_TREE, __access_mode_type_node, \n-\t\t\t    acc_list, 0);\n-\n \n-  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n+  name = build_overload_name (type, 1, 1);\n+  name_string = combine_strings (build_string (strlen (name), name));\n \n-  elems = tree_cons (NULL_TREE, name_string,\n-\t    tree_cons (NULL_TREE, default_conversion (base_list),\n-\t      tree_cons (NULL_TREE, default_conversion (off_list),\n-\t\ttree_cons (NULL_TREE, default_conversion (isvir_list),\n-\t\t  tree_cons (NULL_TREE, default_conversion (acc_list),\n-\t      \t    tree_cons (NULL_TREE, build_int_2 (base_cnt, 0), NULL_TREE))))));\n+  {\n+    tree arrtype = build_array_type (base_info_type_node, NULL_TREE);\n+    elts = build (CONSTRUCTOR, arrtype, NULL_TREE, elts);\n+    TREE_HAS_CONSTRUCTOR (elts) = TREE_CONSTANT (elts) =\n+      TREE_STATIC (elts) = 1;\n+    complete_array_type (arrtype, elts, 1);\n+  }\n \n-  return build_generic_desc (tdecl, __class_desc_type_node, elems);\n-}\n+  elems = tree_cons\n+    (NULL_TREE, decay_conversion (tdecl), tree_cons\n+     (NULL_TREE, decay_conversion (name_string), tree_cons\n+      (NULL_TREE, decay_conversion (elts), tree_cons\n+       (NULL_TREE, build_int_2 (base_cnt, 0), NULL_TREE))));\n \n-/* Build an initializer for a __pointer_type_info node.  */\n-static tree\n-build_ptr_desc (tdecl, type)\n-     tree tdecl;\n-     tree type;\n-{\n-  tree t, elems;\n+  fn = get_identifier (\"__rtti_class\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      tmp = tree_cons\n+\t(NULL_TREE, ptr_type_node, tree_cons\n+\t (NULL_TREE, const_string_type_node, tree_cons\n+\t  (NULL_TREE, build_pointer_type (base_info_type_node), tree_cons\n+\t   (NULL_TREE, sizetype, void_list_node))));\n+      tmp = build_function_type\t(void_type_node, tmp);\n+  \n+      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      pop_obstacks ();\n+    }\n \n-  t = TREE_TYPE (type);\n-  t = build_t_desc (t, 1);\n-  t = build_indirect_ref (t, NULL);\n-  elems = tree_cons (NULL_TREE, t, NULL_TREE);\n-  return build_generic_desc (tdecl, __ptr_desc_type_node,  elems);\n+  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t      decay_conversion (fn), elems, 0);\n+  TREE_SIDE_EFFECTS (fn) = 1;\n+  expand_expr_stmt (fn);\n }\n \n-/* Build an initializer for a __attr_type_info node.  */\n-static tree\n-build_attr_desc (tdecl, type)\n+/* Build an initializer for a __pointer_type_info node.  */\n+static void\n+expand_ptr_desc (tdecl, type)\n      tree tdecl;\n      tree type;\n {\n-  tree elems, t, attrval;\n+  tree t, elems, fn;\n+  char *name = build_overload_name (type, 1, 1);\n+  tree name_string = combine_strings (build_string (strlen (name), name));\n \n-  if (TYPE_READONLY (type))\n-    {\n-      if (TYPE_VOLATILE (type))\n-\tattrval = lookup_field (__attr_desc_type_node, \n-\t\t\t\tget_identifier(\"_RTTI_ATTR_CONSTVOL\"), 0, 0);\n-      else\n-\tattrval = lookup_field (__attr_desc_type_node, \n-\t\t\t\tget_identifier(\"_RTTI_ATTR_CONST\"), 0, 0);\n-    }\n+  type = TREE_TYPE (type);\n+  expand_expr_stmt (get_typeid_1 (type));\n+  t = decay_conversion (get_tinfo_var (type));\n+  elems = tree_cons\n+    (NULL_TREE, decay_conversion (tdecl), tree_cons\n+     (NULL_TREE, decay_conversion (name_string), tree_cons\n+      (NULL_TREE, t, NULL_TREE)));\n+\n+  fn = get_identifier (\"__rtti_ptr\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      if (TYPE_VOLATILE (type))\n-\tattrval = lookup_field (__attr_desc_type_node, \n-\t\t\t\tget_identifier(\"_RTTI_ATTR_VOLATILE\"), 0, 0);\n+      tree tmp;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      tmp = tree_cons\n+\t(NULL_TREE, ptr_type_node, tree_cons\n+\t (NULL_TREE, const_string_type_node, tree_cons\n+\t  (NULL_TREE, build_pointer_type (type_info_type_node),\n+\t   void_list_node)));\n+      tmp = build_function_type\t(void_type_node, tmp);\n+  \n+      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      pop_obstacks ();\n     }\n-  t = build_t_desc (TYPE_MAIN_VARIANT (type), 1);\n-  t = build_indirect_ref (t , NULL);\n-  elems = tree_cons (NULL_TREE, attrval, tree_cons (NULL_TREE, t, NULL_TREE));\n-  return build_generic_desc (tdecl, __attr_desc_type_node,  elems);\n-}\n-\n-/* Build an initializer for a __func_type_info node.  */\n-static tree\n-build_func_desc (tdecl)\n-     tree tdecl;\n-{\n-  tree elems, name_string;\n-  tree tname = DECL_NAME (tdecl);\n \n-  name_string = combine_strings (build_string \n-    (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n-  elems = name_string; \n-  return build_generic_desc (tdecl, __func_desc_type_node,  elems);\n+  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t      decay_conversion (fn), elems, 0);\n+  TREE_SIDE_EFFECTS (fn) = 1;\n+  expand_expr_stmt (fn);\n }\n \n-/* Build an initializer for a __ptmf_type_info node.  */\n-static tree\n-build_ptmf_desc (tdecl)\n-     tree tdecl;\n-{ \n-  tree elems, name_string;\n-  tree tname = DECL_NAME (tdecl);\n-\n-  name_string = combine_strings (build_string \n-    (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n-  elems = name_string; \n-  return build_generic_desc (tdecl, __ptmf_desc_type_node,  elems);\n-}\n-\n-/* Build an initializer for a __ptmd_type_info node.  */\n-static tree\n-build_ptmd_desc (tdecl, type)\n-     tree tdecl;\n-     tree type;\n-{\n-  tree tc, t, elems;\n-  tc = build_t_desc (TYPE_OFFSET_BASETYPE (type), 1);\n-  tc = build_indirect_ref (tc , NULL);\n-  t = build_t_desc (TREE_TYPE (type), 1);\n-  t = build_indirect_ref (t , NULL);\n-  elems = tree_cons (NULL_TREE, tc,\n-\t    tree_cons (NULL_TREE, t, NULL_TREE));\n-  return build_generic_desc (tdecl, __ptmd_desc_type_node,  elems);\n-}\n-\n-struct uninst_st {\n-  tree type;\n-  struct uninst_st *next;\n-};\n-typedef struct uninst_st uninst_node;\n-static uninst_node * uninst_desc = (uninst_node *)NULL;\n+/* Build an initializer for a __attr_type_info node.  */\n \n static void\n-add_uninstantiated_desc (type)\n+expand_attr_desc (tdecl, type)\n+     tree tdecl;\n      tree type;\n {\n-  uninst_node *t;\n+  tree elems, t, fn;\n+  char *name = build_overload_name (type, 1, 1);\n+  tree name_string = combine_strings (build_string (strlen (name), name));\n+  tree attrval = build_int_2\n+    (TYPE_READONLY (type) | TYPE_VOLATILE (type) * 2, 0);\n+\n+  expand_expr_stmt (get_typeid_1 (TYPE_MAIN_VARIANT (type)));\n+  t = decay_conversion (get_tinfo_var (TYPE_MAIN_VARIANT (type)));\n+  elems = tree_cons\n+    (NULL_TREE, decay_conversion (tdecl), tree_cons\n+     (NULL_TREE, decay_conversion (name_string), tree_cons\n+      (NULL_TREE, attrval, tree_cons (NULL_TREE, t, NULL_TREE))));\n+\n+  fn = get_identifier (\"__rtti_attr\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    {\n+      tree tmp;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      tmp = tree_cons\n+\t(NULL_TREE, ptr_type_node, tree_cons\n+\t (NULL_TREE, const_string_type_node, tree_cons\n+\t  (NULL_TREE, integer_type_node, tree_cons\n+\t   (NULL_TREE, build_pointer_type (type_info_type_node),\n+\t    void_list_node))));\n+      tmp = build_function_type\t(void_type_node, tmp);\n+  \n+      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      pop_obstacks ();\n+    }\n \n-  t = (uninst_node *) xmalloc (sizeof (struct uninst_st));\n-  t->type = type;\n-  t->next = uninst_desc;\n-  uninst_desc = t;\n+  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t      decay_conversion (fn), elems, 0);\n+  TREE_SIDE_EFFECTS (fn) = 1;\n+  expand_expr_stmt (fn);\n }\n \n-/* We may choose to link the emitting of certain high use TDs for certain\n-   objects, we do that here.  Return the type to link against if such a\n-   link exists, otherwise just return TYPE.  */\n+/* Build an initializer for a type_info node that just has a name.  */\n \n-static tree\n-get_def_to_follow (type)\n-     tree type;\n-{\n-#if 0\n-  /* For now we don't lay out T&, T* TDs with the main TD for the object.  */\n-  /* Let T* and T& be written only when T is written (if T is an aggr).\n-     We do this for const, but not for volatile, since volatile\n-     is rare and const is not.  */\n-  if (!TYPE_VOLATILE (taggr)\n-      && (TREE_CODE (taggr) == POINTER_TYPE\n-\t  || TREE_CODE (taggr) == REFERENCE_TYPE)\n-      && IS_AGGR_TYPE (TREE_TYPE (taggr)))\n-    taggr = TREE_TYPE (taggr);\n-#endif\n-  return type;\n-}\n-\n-/* build a general type_info node. */\n-tree\n-build_t_desc (type, definition)\n+static void\n+expand_generic_desc (tdecl, type, fnname)\n+     tree tdecl;\n      tree type;\n-     int definition;\n+     char *fnname;\n {\n-  tree tdecl, tname;\n-  tree t, taggr;\n-\n-  if (__ptmd_desc_type_node == NULL_TREE)\n-    {\n-      init_type_desc();\n-      if (__ptmd_desc_type_node)\n-\t{\n-          for ( ; uninst_desc; uninst_desc = uninst_desc->next )\n-\t    build_t_desc (uninst_desc->type, 1);\n-\t}\n-    }\n-  if (__t_desc_type_node == NULL_TREE)\n-    {\n-      static int warned = 0;\n-      if (! warned)\n-\t{\n-\t  cp_error (\"failed to build type descriptor node of '%T', maybe <typeinfo> not included\", type);\n-\t}\n-      warned = 1;\n-      return error_mark_node;\n-    }\n-  if (__ptmd_desc_type_node == NULL_TREE)\n-    {\n-      add_uninstantiated_desc (type);\n-      definition = 0;\n-    }\n-\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-  tname = build_t_desc_overload (type);\n-\n-  if (!IDENTIFIER_AS_DESC (tname))\n+  char *name = build_overload_name (type, 1, 1);\n+  tree name_string = combine_strings (build_string (strlen (name), name));\n+  tree elems = tree_cons\n+    (NULL_TREE, decay_conversion (tdecl), tree_cons\n+     (NULL_TREE, decay_conversion (name_string), NULL_TREE));\n+\n+  tree fn = get_identifier (fnname);\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n     {\n-      tdecl = build_decl (VAR_DECL, tname, __t_desc_type_node);\n-      DECL_EXTERNAL (tdecl) = 1;\n-      TREE_PUBLIC (tdecl) = 1;\n-      tdecl = pushdecl_top_level (tdecl);\n-      SET_IDENTIFIER_AS_DESC (tname, build_unary_op (ADDR_EXPR, tdecl, 0));\n-      if (!definition)\n-\tcp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+      tree tmp;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      tmp = tree_cons\n+\t(NULL_TREE, ptr_type_node, tree_cons\n+\t (NULL_TREE, const_string_type_node, void_list_node));\n+      tmp = build_function_type (void_type_node, tmp);\n+  \n+      fn = build_lang_decl (FUNCTION_DECL, fn, tmp);\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      pop_obstacks ();\n     }\n-  else\n-    tdecl = TREE_OPERAND (IDENTIFIER_AS_DESC (tname), 0);\n \n-  /* If it's not a definition, don't do anything more.  */\n-  if (!definition)\n-    return IDENTIFIER_AS_DESC (tname);\n+  fn = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t      decay_conversion (fn), elems, 0);\n+  TREE_SIDE_EFFECTS (fn) = 1;\n+  expand_expr_stmt (fn);\n+}\n \n-  /* If it has already been written, don't to anything more.  */\n-  /* Should this be on tdecl? */\n-  if (TREE_ASM_WRITTEN (IDENTIFIER_AS_DESC (tname)))\n-    return IDENTIFIER_AS_DESC (tname);\n+/* Generate the code for a type_info initialization function.\n+   Note that we take advantage of the passage\n \n-  /* If we previously defined it, return the defined result.  */\n-  if (DECL_INITIAL (tdecl))\n-    return IDENTIFIER_AS_DESC (tname);\n-    \n-  taggr = get_def_to_follow (type);\n+   5.2.7  Type identification                               [expr.typeid]\n+   \n+   Whether or not the destructor is called for the type_info object at the\n+   end of the program is unspecified.\n \n-  /* If we know that we don't need to write out this type's\n-     vtable, then don't write out it's type_info.  Somebody\n-     else will take care of that.  */\n-  if (IS_AGGR_TYPE (taggr) && CLASSTYPE_VFIELD (taggr))\n-    {\n-      /* Let's play follow the vtable. */\n-      TREE_PUBLIC (tdecl) = CLASSTYPE_INTERFACE_KNOWN (taggr);\n-      DECL_EXTERNAL (tdecl) = CLASSTYPE_INTERFACE_ONLY (taggr);\n-    }\n-  else\n-    {\n-      DECL_EXTERNAL (tdecl) = 0;\n-      TREE_PUBLIC (tdecl) = (definition > 1);\n-    }\n+   and don't bother to arrange for these objects to be destroyed.  It\n+   doesn't matter, anyway, since the destructors don't do anything.\n+       \n+   This must only be called from toplevel (i.e. from finish_file)!  */\n \n-  if (DECL_EXTERNAL (tdecl))\n-    return IDENTIFIER_AS_DESC (tname);\n+void\n+synthesize_tinfo_fn (fndecl)\n+     tree fndecl;\n+{\n+  tree type = TREE_TYPE (DECL_NAME (fndecl));\n+  tree tmp, addr;\n \n-  /* Show that we are defining the t_desc for this type.  */\n-  DECL_INITIAL (tdecl) = error_mark_node;\n-  t = DECL_CONTEXT (tdecl);\n-  if ( t && TREE_CODE_CLASS (TREE_CODE (t)) == 't') \n-    pushclass (t, 2);\n+  tree tdecl = get_tinfo_var (type);\n+  DECL_EXTERNAL (tdecl) = 0;\n+  TREE_STATIC (tdecl) = 1;\n+  DECL_COMMON (tdecl) = 1;\n+  TREE_USED (tdecl) = 1;\n+  DECL_ALIGN (tdecl) = TYPE_ALIGN (ptr_type_node);\n+  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+\n+  start_function (NULL_TREE, fndecl, NULL_TREE, NULL_TREE, 1);\n+  store_parm_decls ();\n+  clear_last_expr ();\n+  push_momentary ();\n+\n+  /* If the first word of the array (the vtable) is non-zero, we've already\n+     initialized the object, so don't do it again.  */\n+  addr = decay_conversion (tdecl);\n+  tmp = convert (build_pointer_type (ptr_type_node), addr);\n+  tmp = build_indirect_ref (tmp, 0);\n+  tmp = build_binary_op (EQ_EXPR, tmp, integer_zero_node, 1);\n+  expand_start_cond (tmp, 0);\n \n   if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n-    t = build_attr_desc (tdecl, type);\n+    expand_attr_desc (tdecl, type);\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n-    t = build_ptr_desc (tdecl, type);\n+    expand_generic_desc (tdecl, type, \"__rtti_array\");\n   else if (TREE_CODE (type) == POINTER_TYPE)\n     {\n       if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n-\t{\n-\t  type = TREE_TYPE (type);\n-\t  t = build_ptmd_desc (tdecl, type);\n-\t}\n+\texpand_generic_desc (tdecl, type, \"__rtti_ptmd\");\n+      else if (TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n+\texpand_generic_desc (tdecl, type, \"__rtti_ptmf\");\n       else\n-\t{\n-\t  t = build_ptr_desc (tdecl, type);\n-\t}\n+\texpand_ptr_desc (tdecl, type);\n     }\n-  else if (TYPE_BUILT_IN (type))\n-    t = build_bltn_desc (tdecl, type);\n+  else if (TYPE_PTRMEMFUNC_P (type))\n+    expand_generic_desc (tdecl, type, \"__rtti_ptmf\");\n   else if (IS_AGGR_TYPE (type))\n     {\n-      if (TYPE_PTRMEMFUNC_P (type))\n-\tt = build_ptmf_desc (tdecl);\n+      if (CLASSTYPE_N_BASECLASSES (type) == 0)\n+\texpand_generic_desc (tdecl, type, \"__rtti_user\");\n+      else if (! TYPE_USES_COMPLEX_INHERITANCE (type)\n+\t       && (TREE_VIA_PUBLIC\n+\t\t   (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0))))\n+\texpand_si_desc (tdecl, type);\n       else\n-\tt = build_class_desc (tdecl, type);\n+\texpand_class_desc (tdecl, type);\n     }\n+  else if (TREE_CODE (type) == ENUMERAL_TYPE)\n+    expand_generic_desc (tdecl, type, \"__rtti_user\");\n   else if (TREE_CODE (type) == FUNCTION_TYPE)\n-    t = build_func_desc (tdecl);\n-  else \n-    t = build_user_desc (tdecl);\n+    expand_generic_desc (tdecl, type, \"__rtti_func\");\n+  else\n+    my_friendly_abort (252);\n \n-  pop_obstacks ();\n-  return t;\n+  expand_end_cond ();\n+\n+  /* OK, now return the type_info object.  */\n+  tmp = convert (build_pointer_type (type_info_type_node), addr);\n+  tmp = build_indirect_ref (tmp, 0);\n+  c_expand_return (tmp);\n+  finish_function (lineno, 0, 0);\n }\n \n #if 0"}, {"sha": "ed97fc34617876c14db3a3516f5aaf3dc5d71ff6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -74,7 +74,7 @@ pop_stack_level (stack)\n static struct search_level *search_stack;\n \n static tree lookup_field_1 ();\n-static int lookup_fnfields_1 ();\n+static int lookup_fnfields_1 PROTO((tree, tree));\n static void dfs_walk ();\n static int markedp ();\n static void dfs_unmark ();\n@@ -246,6 +246,18 @@ my_new_memoized_entry (chain)\n   return p;\n }\n \n+/* Clears the deferred pop from pop_memoized_context, if any.  */\n+static void\n+clear_memoized_cache ()\n+{\n+  if (prev_type_stack)\n+    {\n+      type_stack = pop_type_level (prev_type_stack);\n+      prev_type_memoized = 0;\n+      prev_type_stack = 0;\n+    }\n+}\n+\n /* Make an entry in the memoized table for type TYPE\n    that the entry for NAME is FIELD.  */\n \n@@ -257,6 +269,10 @@ make_memoized_table_entry (type, name, function_p)\n   int index = MEMOIZED_HASH_FN (name);\n   tree entry, *prev_entry;\n \n+  /* Since we allocate from the type_obstack, we must pop any deferred\n+     levels.  */\n+   clear_memoized_cache ();\n+\n   memoized_adds[function_p] += 1;\n   if (CLASSTYPE_MTABLE_ENTRY (type) == 0)\n     {\n@@ -334,9 +350,7 @@ push_memoized_context (type, use_old)\n \t  return;\n \t}\n       /* Otherwise, need to pop old stack here.  */\n-      type_stack = pop_type_level (prev_type_stack);\n-      prev_type_memoized = 0;\n-      prev_type_stack = 0;\n+      clear_memoized_cache ();\n     }\n \n   type_stack = push_type_level ((struct stack_level *)type_stack,\n@@ -364,6 +378,9 @@ pop_memoized_context (use_old)\n       while (len--)\n \ttem[len*2+1] = (tree)CLASSTYPE_MTABLE_ENTRY (tem[len*2]);\n \n+      /* If there was a deferred pop, we need to pop it now.  */\n+      clear_memoized_cache ();\n+\n       prev_type_stack = type_stack;\n       prev_type_memoized = type_stack->type;\n     }\n@@ -494,14 +511,23 @@ get_binfo (parent, binfo, protect)\n static int\n get_base_distance_recursive (binfo, depth, is_private, rval,\n \t\t\t     rval_private_ptr, new_binfo_ptr, parent, path_ptr,\n-\t\t\t     protect, via_virtual_ptr, via_virtual)\n-     tree binfo, *new_binfo_ptr, parent, *path_ptr;\n-     int *rval_private_ptr, depth, is_private, rval, protect, *via_virtual_ptr,\n-       via_virtual;\n+\t\t\t     protect, via_virtual_ptr, via_virtual,\n+\t\t\t     current_scope_in_chain)\n+     tree binfo;\n+     int depth, is_private, rval;\n+     int *rval_private_ptr;\n+     tree *new_binfo_ptr, parent, *path_ptr;\n+     int protect, *via_virtual_ptr, via_virtual;\n+     int current_scope_in_chain;\n {\n   tree binfos;\n   int i, n_baselinks;\n \n+  if (protect\n+      && !current_scope_in_chain\n+      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n+    current_scope_in_chain = 1;\n+\n   if (BINFO_TYPE (binfo) == parent || binfo == parent)\n     {\n       if (rval == -1)\n@@ -556,6 +582,8 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n \t    = (protect\n \t       && (is_private\n \t\t   || (!TREE_VIA_PUBLIC (base_binfo)\n+\t\t       && !(TREE_VIA_PROTECTED (base_binfo)\n+\t\t\t    && current_scope_in_chain)\n \t\t       && !is_friend (BINFO_TYPE (binfo), current_scope ()))));\n \t  int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n \t  int was;\n@@ -572,7 +600,8 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n \t\t\t\t\t      rval, rval_private_ptr,\n \t\t\t\t\t      new_binfo_ptr, parent, path_ptr,\n \t\t\t\t\t      protect, via_virtual_ptr,\n-\t\t\t\t\t      this_virtual);\n+\t\t\t\t\t      this_virtual,\n+\t\t\t\t\t      current_scope_in_chain);\n \t  /* watch for updates; only update if path is good. */\n \t  if (path_ptr && WATCH_VALUES (rval, *via_virtual_ptr) != was)\n \t    BINFO_INHERITANCE_CHAIN (base_binfo) = binfo;\n@@ -652,7 +681,8 @@ get_base_distance (parent, binfo, protect, path_ptr)\n \n   rval = get_base_distance_recursive (binfo, 0, 0, -1,\n \t\t\t\t      &rval_private, &new_binfo, parent,\n-\t\t\t\t      path_ptr, watch_access, &via_virtual, 0);\n+\t\t\t\t      path_ptr, watch_access, &via_virtual, 0,\n+\t\t\t\t      0);\n \n   dfs_walk (binfo, dfs_unmark, markedp);\n \n@@ -2106,8 +2136,9 @@ get_matching_virtual (binfo, fndecl, dtorp)\n    expand_direct_vtbls_init for the style of search we do.  */\n static tree\n get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n-     tree binfo, abstract_virtuals;\n+     tree binfo;\n      int do_self;\n+     tree abstract_virtuals;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n@@ -2559,12 +2590,12 @@ dfs_init_vbase_pointers (binfo)\n \n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n \n-  /* If there is a rtti, it is the first field, though perhaps from\n-     the base class.  Otherwise, the first fields are virtual base class\n-     pointer fields.  */\n-  if (CLASSTYPE_RTTI (type) && VFIELD_NAME_P (DECL_NAME (fields)))\n-    /* Get past vtable for the object.  */\n+#if 0\n+  /* See finish_struct_1 for when we can enable this.  */\n+  /* If we have a vtable pointer first, skip it.  */\n+  if (VFIELD_NAME_P (DECL_NAME (fields)))\n     fields = TREE_CHAIN (fields);\n+#endif\n \n   if (fields == NULL_TREE\n       || DECL_NAME (fields) == NULL_TREE\n@@ -2736,6 +2767,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t      DECL_ALIGN (nvtbl) = MAX (TYPE_ALIGN (double_type_node),\n \t\t\t\t\tDECL_ALIGN (nvtbl));\n \t      TREE_READONLY (nvtbl) = 0;\n+\t      DECL_ARTIFICIAL (nvtbl) = 1;\n \t      nvtbl = pushdecl (nvtbl);\n \t      init = NULL_TREE;\n \t      cp_finish_decl (nvtbl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n@@ -2796,8 +2828,9 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n    expand_direct_vtbls_init.  */\n static void\n fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, orig_addr, type, vbase, vbase_offsets)\n-     tree real_binfo, binfo, addr, orig_addr, type, vbase, *vbase_offsets;\n+     tree real_binfo, binfo;\n      int init_self, can_elide;\n+     tree addr, orig_addr, type, vbase, *vbase_offsets;\n {\n   tree real_binfos = BINFO_BASETYPES (real_binfo);\n   tree binfos = BINFO_BASETYPES (binfo);"}, {"sha": "a2c79b47cb66c77302bcad3c0b9d430cfb1a272c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6b5fbb552b0b8abb9a36ee1a9277b4ca03819b96", "patch": "@@ -1572,6 +1572,22 @@ default_conversion (exp)\n \n   return exp;\n }\n+\n+/* Take the address of an inline function without setting TREE_ADDRESSABLE\n+   or TREE_USED.  */\n+\n+tree\n+inline_conversion (exp)\n+     tree exp;\n+{\n+  if (TREE_CODE (exp) == FUNCTION_DECL)\n+    {\n+      tree type = build_type_variant\n+\t(TREE_TYPE (exp), TREE_READONLY (exp), TREE_THIS_VOLATILE (exp));\n+      exp = build1 (ADDR_EXPR, build_pointer_type (type), exp);\n+    }\n+  return exp;\n+}\n \f\n tree\n build_object_ref (datum, basetype, field)\n@@ -2489,11 +2505,6 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t{\n \t  aref = save_expr (aref);\n \n-\t  /* Save the intermediate result in a SAVE_EXPR so we don't have to\n-\t     compute each component of the virtual function pointer twice.  */ \n-\t  if (TREE_CODE (aref) == INDIRECT_REF)\n-\t    TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n-      \n \t  delta = build_binary_op (PLUS_EXPR,\n \t\t\t\t   build_conditional_expr (e1, build_component_ref (aref, delta_identifier, 0, 0), integer_zero_node),\n \t\t\t\t   delta, 1);\n@@ -2575,10 +2586,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t      && current_function_decl)\n \t    synthesize_method (function);\n \n-\t  fntype = build_type_variant (TREE_TYPE (function),\n-\t\t\t\t       TREE_READONLY (function),\n-\t\t\t\t       TREE_THIS_VOLATILE (function));\n-\t  function = build1 (ADDR_EXPR, build_pointer_type (fntype), function);\n+\t  function = inline_conversion (function);\n \t}\n       else\n \tfunction = default_conversion (function);"}]}