{"sha": "59487769132b49401a4d63754558d9c08172a287", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0ODc3NjkxMzJiNDk0MDFhNGQ2Mzc1NDU1OGQ5YzA4MTcyYTI4Nw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-10-25T06:44:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-25T06:44:04Z"}, "message": "loop.c (note_set_pseudo_multiple_uses_retval): New variable.\n\n        * loop.c (note_set_pseudo_multiple_uses_retval): New variable.\n        (note_set_pseudo_multiple_uses): New function.\n        (check_dbra_loop): Use not_set_pseudo_multiple_uses to determine\n        if a pseudo set in the loop exit is used elsewhere.\n\nFrom-SVN: r30155", "tree": {"sha": "90b92346692e2b364eace0318b1709168984b340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90b92346692e2b364eace0318b1709168984b340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59487769132b49401a4d63754558d9c08172a287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59487769132b49401a4d63754558d9c08172a287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59487769132b49401a4d63754558d9c08172a287", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59487769132b49401a4d63754558d9c08172a287/comments", "author": null, "committer": null, "parents": [{"sha": "f9c4f105d5b6d9dd78f0d62cf730f523d85f55a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c4f105d5b6d9dd78f0d62cf730f523d85f55a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9c4f105d5b6d9dd78f0d62cf730f523d85f55a2"}], "stats": {"total": 61, "additions": 57, "deletions": 4}, "files": [{"sha": "d72d913bb40638cee99041dfda199cd34745abab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59487769132b49401a4d63754558d9c08172a287/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59487769132b49401a4d63754558d9c08172a287/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59487769132b49401a4d63754558d9c08172a287", "patch": "@@ -1,3 +1,10 @@\n+Mon Oct 25 00:42:35 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* loop.c (note_set_pseudo_multiple_uses_retval): New variable.\n+\t(note_set_pseudo_multiple_uses): New function.\n+\t(check_dbra_loop): Use not_set_pseudo_multiple_uses to determine\n+\tif a pseudo set in the loop exit is used elsewhere.\n+\n Sun Oct 24 20:52:40 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* i386.md (mulsi3): Tweak to work with SCO OSR5 COFF assembler."}, {"sha": "5ef10bd5b67b3c04ac4a0ccbacf6cd9667a1bcb4", "filename": "gcc/loop.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59487769132b49401a4d63754558d9c08172a287/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59487769132b49401a4d63754558d9c08172a287/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=59487769132b49401a4d63754558d9c08172a287", "patch": "@@ -269,6 +269,9 @@ static struct movable *the_movables;\n \n FILE *loop_dump_stream;\n \n+/* For communicating return values from note_set_pseudo_multiple_uses.  */\n+static int note_set_pseudo_multiple_uses_retval;\n+\n /* Forward declarations.  */\n \n static void verify_dominator PROTO((int));\n@@ -283,6 +286,7 @@ static void count_one_set PROTO((rtx, rtx, varray_type, rtx *));\n static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n \t\t\t\t       int *, int)); \n static void note_addr_stored PROTO((rtx, rtx));\n+static void note_set_pseudo_multiple_uses PROTO((rtx, rtx));\n static int loop_reg_used_before_p PROTO((rtx, rtx, rtx, rtx, rtx));\n static void scan_loop PROTO((rtx, rtx, rtx, int, int));\n #if 0\n@@ -3172,6 +3176,36 @@ note_addr_stored (x, y)\n \n   loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, x, loop_store_mems);\n }\n+\n+/* X is a value modified by an INSN that references a biv inside a loop\n+   exit test (ie, X is somehow related to the value of the biv).  If X\n+   is a pseudo that is used more than once, then the biv is (effectively)\n+   used more than once.  */\n+\n+static void\n+note_set_pseudo_multiple_uses (x, y)\n+     rtx x;\n+     rtx y ATTRIBUTE_UNUSED;\n+{\n+  if (x == 0)\n+    return;\n+\n+  while (GET_CODE (x) == STRICT_LOW_PART\n+\t || GET_CODE (x) == SIGN_EXTRACT\n+\t || GET_CODE (x) == ZERO_EXTRACT\n+\t || GET_CODE (x) == SUBREG)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) != REG || REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  /* If we do not have usage information, or if we know the register\n+     is used more than once, note that fact for check_dbra_loop.  */\n+  if (REGNO (x) >= max_reg_before_loop\n+      || ! VARRAY_RTX (reg_single_usage, REGNO (x))\n+      || VARRAY_RTX (reg_single_usage, REGNO (x)) == const0_rtx)\n+    note_set_pseudo_multiple_uses_retval = 1;\n+}\n \f\n /* Return nonzero if the rtx X is invariant over the current loop.\n \n@@ -7932,10 +7966,22 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t    && REGNO (SET_DEST (set)) == bl->regno)\n \t\t  /* An insn that sets the biv is okay.  */\n \t\t  ;\n-\t\telse if (p == prev_nonnote_insn (prev_nonnote_insn (loop_end))\n-\t\t\t || p == prev_nonnote_insn (loop_end))\n-\t\t  /* Don't bother about the end test.  */\n-\t\t  ;\n+\t\telse if ((p == prev_nonnote_insn (prev_nonnote_insn (loop_end))\n+\t\t\t  || p == prev_nonnote_insn (loop_end))\n+\t\t\t && reg_mentioned_p (bivreg, PATTERN (p)))\n+\t\t  {\n+\t\t    /* If either of these insns uses the biv and sets a pseudo\n+\t\t       that has more than one usage, then the biv has uses\n+\t\t       other than counting since it's used to derive a value\n+\t\t       that is used more than one time.  */\n+\t\t    note_set_pseudo_multiple_uses_retval = 0;\n+\t\t    note_stores (PATTERN (p), note_set_pseudo_multiple_uses);\n+\t\t    if (note_set_pseudo_multiple_uses_retval)\n+\t\t      {\n+\t\t\tno_use_except_counting = 0;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n \t\telse if (reg_mentioned_p (bivreg, PATTERN (p)))\n \t\t  {\n \t\t    no_use_except_counting = 0;"}]}