{"sha": "7424b7c13940c36700db8cd19a6f16d75af07b50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyNGI3YzEzOTQwYzM2NzAwZGI4Y2QxOWE2ZjE2ZDc1YWYwN2I1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-11-21T17:31:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-11-21T17:31:19Z"}, "message": "re PR ipa/87957 (ICE tree check: expected tree that contains \u2018decl minimal\u2019 structure, have \u2018identifier_node\u2019 in warn_odr, at ipa-devirt.c:1051 since r265519)\n\n\n\tPR lto/87957\n\t* tree.c (fld_decl_context): Break out from ...\n\t(free_lang_data_in_decl): ... here; free TREE_PUBLIC, TREE_PRIVATE\n\tDECL_ARTIFICIAL of TYPE_DECL; do not free TREE_TYPE of TYPE_DECL.\n\t(fld_incomplete_type_of): Build copy of TYP_DECL.\n\t* ipa-devirt.c (free_enum_values): Rename to ...\n\t(free_odr_warning_data): ... this one; free also duplicated TYPE_DECLs\n\tand TREE_TYPEs of TYPE_DECLs.\n\t(get_odr_type): Initialize odr_vtable_hash if needed.\n\nFrom-SVN: r266350", "tree": {"sha": "10c9100455747cf530c2ad6daaba7cbfcdb02bab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10c9100455747cf530c2ad6daaba7cbfcdb02bab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7424b7c13940c36700db8cd19a6f16d75af07b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7424b7c13940c36700db8cd19a6f16d75af07b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7424b7c13940c36700db8cd19a6f16d75af07b50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7424b7c13940c36700db8cd19a6f16d75af07b50/comments", "author": null, "committer": null, "parents": [{"sha": "6bdb055ea850bb5497e52b5b1acbd8dabe93e01f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdb055ea850bb5497e52b5b1acbd8dabe93e01f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdb055ea850bb5497e52b5b1acbd8dabe93e01f"}], "stats": {"total": 151, "additions": 105, "deletions": 46}, "files": [{"sha": "82a1710e4e467cf6bd4facf9801318bd7d591d70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7424b7c13940c36700db8cd19a6f16d75af07b50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7424b7c13940c36700db8cd19a6f16d75af07b50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7424b7c13940c36700db8cd19a6f16d75af07b50", "patch": "@@ -1,3 +1,15 @@\n+2018-11-21  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/87957\n+\t* tree.c (fld_decl_context): Break out from ...\n+\t(free_lang_data_in_decl): ... here; free TREE_PUBLIC, TREE_PRIVATE\n+\tDECL_ARTIFICIAL of TYPE_DECL; do not free TREE_TYPE of TYPE_DECL.\n+\t(fld_incomplete_type_of): Build copy of TYP_DECL.\n+\t* ipa-devirt.c (free_enum_values): Rename to ...\n+\t(free_odr_warning_data): ... this one; free also duplicated TYPE_DECLs\n+\tand TREE_TYPEs of TYPE_DECLs.\n+\t(get_odr_type): Initialize odr_vtable_hash if needed.\n+\n 2018-11-21  Alexandre Oliva <oliva@adacore.com>\n \n \t* final.c (compute_discriminator): Declare.  Renamed from..."}, {"sha": "8c375ff07bd5cd4275239ec2d818828260cb61d1", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7424b7c13940c36700db8cd19a6f16d75af07b50/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7424b7c13940c36700db8cd19a6f16d75af07b50/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=7424b7c13940c36700db8cd19a6f16d75af07b50", "patch": "@@ -2025,6 +2025,8 @@ get_odr_type (tree type, bool insert)\n   if ((!slot || !*slot) && in_lto_p && can_be_vtable_hashed_p (type))\n     {\n       hash = hash_odr_vtable (type);\n+      if (!odr_vtable_hash)\n+        odr_vtable_hash = new odr_vtable_hash_type (23);\n       vtable_slot = odr_vtable_hash->find_slot_with_hash (type, hash,\n \t\t\t\t\t           insert ? INSERT : NO_INSERT);\n     }\n@@ -2289,27 +2291,43 @@ dump_type_inheritance_graph (FILE *f)\n \t   \"%i duplicates overall\\n\", num_all_types, num_types, num_duplicates);\n }\n \n-/* Save some WPA->ltrans streaming by freeing enum values.  */\n+/* Save some WPA->ltrans streaming by freeing stuff needed only for good\n+   ODR warnings.\n+   We free TYPE_VALUES of enums and also make TYPE_DECLs to not point back\n+   to the type (which is needed to keep them in the same SCC and preserve\n+   location information to output warnings) and subsequently we make all\n+   TYPE_DECLS of same assembler name equivalent.  */\n \n static void\n-free_enum_values ()\n+free_odr_warning_data ()\n {\n-  static bool enum_values_freed = false;\n-  if (enum_values_freed || !flag_wpa || !odr_types_ptr)\n+  static bool odr_data_freed = false;\n+\n+  if (odr_data_freed || !flag_wpa || !odr_types_ptr)\n     return;\n-  enum_values_freed = true;\n-  unsigned int i;\n-  for (i = 0; i < odr_types.length (); i++)\n+\n+  odr_data_freed = true;\n+\n+  for (unsigned int i = 0; i < odr_types.length (); i++)\n     if (odr_types[i])\n       {\n-\tif (TREE_CODE (odr_types[i]->type) == ENUMERAL_TYPE)\n-\t  TYPE_VALUES (odr_types[i]->type) = NULL;\n+\ttree t = odr_types[i]->type;\n+\n+\tif (TREE_CODE (t) == ENUMERAL_TYPE)\n+\t  TYPE_VALUES (t) = NULL;\n+\tTREE_TYPE (TYPE_NAME (t)) = void_type_node;\n+\n \tif (odr_types[i]->types)\n           for (unsigned int j = 0; j < odr_types[i]->types->length (); j++)\n-\t    if (TREE_CODE ((*odr_types[i]->types)[j]) == ENUMERAL_TYPE)\n-\t      TYPE_VALUES ((*odr_types[i]->types)[j]) = NULL;\n+\t    {\n+\t      tree td = (*odr_types[i]->types)[j];\n+\n+\t      if (TREE_CODE (td) == ENUMERAL_TYPE)\n+\t        TYPE_VALUES (td) = NULL;\n+\t      TYPE_NAME (td) = TYPE_NAME (t);\n+\t    }\n       }\n-  enum_values_freed = true;\n+  odr_data_freed = true;\n }\n \n /* Initialize IPA devirt and build inheritance tree graph.  */\n@@ -2323,7 +2341,7 @@ build_type_inheritance_graph (void)\n \n   if (odr_hash)\n     {\n-      free_enum_values ();\n+      free_odr_warning_data ();\n       return;\n     }\n   timevar_push (TV_IPA_INHERITANCE);\n@@ -2370,7 +2388,7 @@ build_type_inheritance_graph (void)\n       dump_type_inheritance_graph (inheritance_dump_file);\n       dump_end (TDI_inheritance, inheritance_dump_file);\n     }\n-  free_enum_values ();\n+  free_odr_warning_data ();\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n "}, {"sha": "8264e9c7f141f1ab9149196de2a34b7822d80e70", "filename": "gcc/tree.c", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7424b7c13940c36700db8cd19a6f16d75af07b50/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7424b7c13940c36700db8cd19a6f16d75af07b50/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7424b7c13940c36700db8cd19a6f16d75af07b50", "patch": "@@ -5206,6 +5206,24 @@ fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,\n   return array;\n }\n \n+/* Return CTX after removal of contexts that are not relevant  */\n+\n+static tree\n+fld_decl_context (tree ctx)\n+{\n+  /* Variably modified types are needed for tree_is_indexable to decide\n+     whether the type needs to go to local or global section.\n+     This code is semi-broken but for now it is easiest to keep contexts\n+     as expected.  */\n+  if (ctx && TYPE_P (ctx)\n+      && !variably_modified_type_p (ctx, NULL_TREE))\n+     {\n+       while (ctx && TYPE_P (ctx))\n+\t ctx = TYPE_CONTEXT (ctx);\n+     }\n+  return ctx;\n+}\n+\n /* For T being aggregate type try to turn it into a incomplete variant.\n    Return T if no simplification is possible.  */\n \n@@ -5267,6 +5285,28 @@ fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n \t    }\n \t  else\n \t    TYPE_VALUES (copy) = NULL;\n+\n+\t  /* Build copy of TYPE_DECL in TYPE_NAME if necessary.\n+\t     This is needed for ODR violation warnings to come out right (we\n+\t     want duplicate TYPE_DECLs whenever the type is duplicated because\n+\t     of ODR violation.  Because lang data in the TYPE_DECL may not\n+\t     have been freed yet, rebuild it from scratch and copy relevant\n+\t     fields.  */\n+\t  TYPE_NAME (copy) = fld_simplified_type_name (copy);\n+\t  tree name = TYPE_NAME (copy);\n+\n+\t  if (name && TREE_CODE (name) == TYPE_DECL)\n+\t    {\n+\t      gcc_checking_assert (TREE_TYPE (name) == t);\n+\t      tree name2 = build_decl (DECL_SOURCE_LOCATION (name), TYPE_DECL,\n+\t\t\t\t       DECL_NAME (name), copy);\n+\t      if (DECL_ASSEMBLER_NAME_SET_P (name))\n+\t        SET_DECL_ASSEMBLER_NAME (name2, DECL_ASSEMBLER_NAME (name));\n+\t      SET_DECL_ALIGN (name2, 0);\n+\t      DECL_CONTEXT (name2) = fld_decl_context\n+\t\t\t\t\t (DECL_CONTEXT (name));\n+\t      TYPE_NAME (copy) = name2;\n+\t    }\n \t}\n       return copy;\n    }\n@@ -5423,7 +5463,8 @@ free_lang_data_in_type (tree type, struct free_lang_data_d *fld)\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n \t{\n \t  /* Type values are used only for C++ ODR checking.  Drop them\n-\t     for all type variants and non-ODR types.  */\n+\t     for all type variants and non-ODR types.\n+\t     For ODR types the data is freed in free_odr_warning_data.  */\n \t  if (TYPE_MAIN_VARIANT (type) != type\n \t      || !type_with_linkage_p (type))\n \t    TYPE_VALUES (type) = NULL;\n@@ -5455,11 +5496,7 @@ free_lang_data_in_type (tree type, struct free_lang_data_d *fld)\n       TYPE_CONTEXT (type) = ctx;\n     }\n \n-  /* Drop TYPE_DECLs in TYPE_NAME in favor of the identifier in the\n-     TYPE_DECL if the type doesn't have linkage.\n-     this must match fld_  */\n-  if (type != TYPE_MAIN_VARIANT (type) || ! type_with_linkage_p (type))\n-    TYPE_STUB_DECL (type) = NULL;\n+  TYPE_STUB_DECL (type) = NULL;\n   TYPE_NAME (type) = fld_simplified_type_name (type);\n }\n \n@@ -5486,16 +5523,19 @@ need_assembler_name_p (tree decl)\n      e.g.  -fno-signed-char/-fsigned-char mismatches to be handled well.\n      See cp/mangle.c:write_builtin_type for details.  */\n \n-  if (flag_lto_odr_type_mering\n-      && TREE_CODE (decl) == TYPE_DECL\n-      && DECL_NAME (decl)\n-      && decl == TYPE_NAME (TREE_TYPE (decl))\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TREE_TYPE (decl)\n-      && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n-      && (type_with_linkage_p (TREE_TYPE (decl))\n-\t  || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n-      && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n-    return !DECL_ASSEMBLER_NAME_SET_P (decl);\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      if (flag_lto_odr_type_mering\n+\t  && DECL_NAME (decl)\n+\t  && decl == TYPE_NAME (TREE_TYPE (decl))\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TREE_TYPE (decl)\n+\t  && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n+\t  && (type_with_linkage_p (TREE_TYPE (decl))\n+\t      || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n+\t  && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+\treturn !DECL_ASSEMBLER_NAME_SET_P (decl);\n+      return false;\n+    }\n   /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n   if (!VAR_OR_FUNCTION_DECL_P (decl))\n     return false;\n@@ -5649,13 +5689,15 @@ free_lang_data_in_decl (tree decl, struct free_lang_data_d *fld)\n     {\n       DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n       DECL_VISIBILITY_SPECIFIED (decl) = 0;\n-      /* TREE_PUBLIC is used to tell if type is anonymous.  */\n+      TREE_PUBLIC (decl) = 0;\n+      TREE_PRIVATE (decl) = 0;\n+      DECL_ARTIFICIAL (decl) = 0;\n       TYPE_DECL_SUPPRESS_DEBUG (decl) = 0;\n       DECL_INITIAL (decl) = NULL_TREE;\n       DECL_ORIGINAL_TYPE (decl) = NULL_TREE;\n       DECL_MODE (decl) = VOIDmode;\n-      TREE_TYPE (decl) = void_type_node;\n       SET_DECL_ALIGN (decl, 0);\n+      /* TREE_TYPE is cleared at WPA time in free_odr_warning_data.  */\n     }\n   else if (TREE_CODE (decl) == FIELD_DECL)\n     {\n@@ -5688,20 +5730,7 @@ free_lang_data_in_decl (tree decl, struct free_lang_data_d *fld)\n   if (TREE_CODE (decl) != FIELD_DECL\n       && ((TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n           || !DECL_VIRTUAL_P (decl)))\n-    {\n-      tree ctx = DECL_CONTEXT (decl);\n-      /* Variably modified types are needed for tree_is_indexable to decide\n-\t whether the type needs to go to local or global section.\n-\t This code is semi-broken but for now it is easiest to keep contexts\n-\t as expected.  */\n-      if (ctx && TYPE_P (ctx)\n-\t  && !variably_modified_type_p (ctx, NULL_TREE))\n-\t {\n-\t   while (ctx && TYPE_P (ctx))\n-\t     ctx = TYPE_CONTEXT (ctx);\n-\t   DECL_CONTEXT (decl) = ctx;\n-\t }\n-    }\n+    DECL_CONTEXT (decl) = fld_decl_context (DECL_CONTEXT (decl));\n }\n \n "}]}