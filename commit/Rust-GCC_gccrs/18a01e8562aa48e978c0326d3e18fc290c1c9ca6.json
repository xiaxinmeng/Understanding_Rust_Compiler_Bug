{"sha": "18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhMDFlODU2MmFhNDhlOTc4YzAzMjZkM2UxOGZjMjkwYzFjOWNhNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-01T13:03:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-01T13:03:10Z"}, "message": "Revert 2017-08-28 Nathan Sidwell <nathan@acm.org> Restore sorted_fields vector.\n\n\tRevert 2017-08-28  Nathan Sidwell  <nathan@acm.org>\n\tRestore sorted_fields vector.\n\t* cp-tree.h (lang_type): Restore sorted_fields vector.\n\t(CLASSTYPE_SORTED_FIELDS): Restore.\n\t(CLASSTYPE_BINDINGS): Delete.\n\t* name-lookup.c (lookup_field_1): Restore binary search.\n\t(sorted_fields_type_new, count_fields,\n\tadd_fields_to_record_type, add_enum_fields_to_record_type): Restore\n\t(set_class_bindings): Revert.\n\t(insert_late_enum_def_binding): Restore field_vec insertion.\n\nFrom-SVN: r251592", "tree": {"sha": "2c0373f74a6a2edbad3679aa8e80504d5352702f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c0373f74a6a2edbad3679aa8e80504d5352702f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "002618d87483cfb6481b0a044f113c9cf87d4ed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002618d87483cfb6481b0a044f113c9cf87d4ed6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002618d87483cfb6481b0a044f113c9cf87d4ed6"}], "stats": {"total": 202, "additions": 146, "deletions": 56}, "files": [{"sha": "020caf28982e3c56d63becbe9fa132e592d2c9d6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "patch": "@@ -1,3 +1,16 @@\n+2017-09-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRevert 2017-08-28  Nathan Sidwell  <nathan@acm.org>\n+\tRestore sorted_fields vector.\n+\t* cp-tree.h (lang_type): Restore sorted_fields vector.\n+\t(CLASSTYPE_SORTED_FIELDS): Restore.\n+\t(CLASSTYPE_BINDINGS): Delete.\n+\t* name-lookup.c (lookup_field_1): Restore binary search.\n+\t(sorted_fields_type_new, count_fields,\n+\tadd_fields_to_record_type, add_enum_fields_to_record_type): Restore\n+\t(set_class_bindings): Revert.\n+\t(insert_late_enum_def_binding): Restore field_vec insertion.\n+\n 2017-09-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/81887"}, {"sha": "d8fe9538d2e92cbf63b537e6ce28daf5b905ce05", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "patch": "@@ -2007,10 +2007,10 @@ struct GTY(()) lang_type {\n      as a list of adopted protocols or a pointer to a corresponding\n      @interface.  See objc/objc-act.h for details.  */\n   tree objc_info;\n-\n-  /* Map from IDENTIFIER nodes to DECLS.  */\n-  hash_map<lang_identifier *, tree> *bindings;\n-\n+  /* sorted_fields is sorted based on a pointer, so we need to be able\n+     to resort it if pointers get rearranged.  */\n+  struct sorted_fields_type * GTY ((reorder (\"resort_sorted_fields\")))\n+    sorted_fields;\n   /* FIXME reuse another field?  */\n   tree lambda_expr;\n };\n@@ -3236,9 +3236,10 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    && TREE_CODE (TYPE_NAME (NODE)) == TYPE_DECL\t\\\n    && TYPE_DECL_ALIAS_P (TYPE_NAME (NODE)))\n \n-/* The binding map for a class (not always present).  */\n-#define CLASSTYPE_BINDINGS(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->bindings)\n+/* For a class type: if this structure has many fields, we'll sort them\n+   and put them into a TREE_VEC.  */\n+#define CLASSTYPE_SORTED_FIELDS(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->sorted_fields)\n \n /* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL or\n    TEMPLATE_DECL, the entity is either a template specialization (if"}, {"sha": "7cd8f4a67b33efde7edc7580e78d1ad06d2ad897", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 125, "deletions": 49, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a01e8562aa48e978c0326d3e18fc290c1c9ca6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=18a01e8562aa48e978c0326d3e18fc290c1c9ca6", "patch": "@@ -1183,33 +1183,58 @@ lookup_fnfields_slot_nolazy (tree type, tree name)\n tree\n lookup_field_1 (tree type, tree name, bool want_type)\n {\n-  tree field = NULL_TREE;\n+  tree field;\n \n   gcc_assert (identifier_p (name) && RECORD_OR_UNION_TYPE_P (type));\n \n-  if (CLASSTYPE_BINDINGS (type))\n+  if (CLASSTYPE_SORTED_FIELDS (type))\n     {\n-      tree *slot = CLASSTYPE_BINDINGS (type)->get (name);\n+      tree *fields = &CLASSTYPE_SORTED_FIELDS (type)->elts[0];\n+      int lo = 0, hi = CLASSTYPE_SORTED_FIELDS (type)->len;\n+      int i;\n \n-      if (slot)\n+      while (lo < hi)\n \t{\n-\t  field = *slot;\n+\t  i = (lo + hi) / 2;\n \n-\t  if (STAT_HACK_P (field))\n+\t  if (DECL_NAME (fields[i]) > name)\n+\t    hi = i;\n+\t  else if (DECL_NAME (fields[i]) < name)\n+\t    lo = i + 1;\n+\t  else\n \t    {\n+\t      field = NULL_TREE;\n+\n+\t      /* We might have a nested class and a field with the\n+\t\t same name; we sorted them appropriately via\n+\t\t field_decl_cmp, so just look for the first or last\n+\t\t field with this name.  */\n \t      if (want_type)\n-\t\tfield = STAT_TYPE (field);\n+\t\t{\n+\t\t  do\n+\t\t    field = fields[i--];\n+\t\t  while (i >= lo && DECL_NAME (fields[i]) == name);\n+\t\t  if (!DECL_DECLARES_TYPE_P (field))\n+\t\t    field = NULL_TREE;\n+\t\t}\n \t      else\n-\t\tfield = STAT_DECL (field);\n-\t    }\n+\t\t{\n+\t\t  do\n+\t\t    field = fields[i++];\n+\t\t  while (i < hi && DECL_NAME (fields[i]) == name);\n+\t\t}\n+\n+\t      if (field)\n+\t      \t{\n+\t      \t  field = strip_using_decl (field);\n+\t      \t  if (is_overloaded_fn (field))\n+\t      \t    field = NULL_TREE;\n+\t      \t}\n \n-\t  field = strip_using_decl (field);\n-\t  if (OVL_P (field))\n-\t    field = NULL_TREE;\n-\t  else if (want_type && !DECL_DECLARES_TYPE_P (field))\n-\t    field = NULL_TREE;\n+\t      return field;\n+\t    }\n \t}\n-      return field;\n+      return NULL_TREE;\n     }\n \n   field = TYPE_FIELDS (type);\n@@ -1287,62 +1312,113 @@ lookup_fnfields_slot (tree type, tree name)\n   return lookup_fnfields_slot_nolazy (type, name);\n }\n \n-/* Add DECL into MAP under NAME.  Collisions fail silently.  Doesn't\n-   do sophisticated collision checking.  Deals with STAT_HACK.  */\n+/* Allocate and return an instance of struct sorted_fields_type with\n+   N fields.  */\n \n-static void\n-add_class_member (hash_map<lang_identifier *, tree> *map, tree name, tree decl)\n+static struct sorted_fields_type *\n+sorted_fields_type_new (int n)\n {\n-  bool existed;\n-  tree *slot = &map->get_or_insert (name, &existed);\n-  if (!existed)\n-    *slot = decl;\n-  else if (TREE_CODE (*slot) == TYPE_DECL && DECL_ARTIFICIAL (*slot))\n-    *slot = stat_hack (decl, *slot);\n-  else if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n-    *slot = stat_hack (*slot, decl);\n+  struct sorted_fields_type *sft;\n+  sft = (sorted_fields_type *) ggc_internal_alloc (sizeof (sorted_fields_type)\n+\t\t\t\t      + n * sizeof (tree));\n+  sft->len = n;\n \n-  /* Else ignore collision.  */\n+  return sft;\n }\n \n-/* Insert the chain FIELDS into MAP.  */\n+/* Subroutine of insert_into_classtype_sorted_fields.  Recursively\n+   count the number of fields in TYPE, including anonymous union\n+   members.  */\n \n-static void\n-add_class_members (hash_map<lang_identifier *, tree> *map, tree fields)\n+static int\n+count_fields (tree fields)\n {\n-  for (tree field = fields; field; field = DECL_CHAIN (field))\n+  tree x;\n+  int n_fields = 0;\n+  for (x = fields; x; x = DECL_CHAIN (x))\n     {\n-      if (TREE_CODE (field) == FIELD_DECL\n-\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\tadd_class_members (map, TYPE_FIELDS (TREE_TYPE (field)));\n-      else if (DECL_NAME (field))\n-\tadd_class_member (map, DECL_NAME (field), field);\n+      if (DECL_DECLARES_FUNCTION_P (x))\n+\t/* Functions are dealt with separately.  */;\n+      else if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+\tn_fields += count_fields (TYPE_FIELDS (TREE_TYPE (x)));\n+      else\n+\tn_fields += 1;\n     }\n+  return n_fields;\n }\n \n-/* Create the binding map of KLASS and insert FIELDS.  */\n+/* Subroutine of insert_into_classtype_sorted_fields.  Recursively add\n+   all the fields in the TREE_LIST FIELDS to the SORTED_FIELDS_TYPE\n+   elts, starting at offset IDX.  */\n+\n+static int\n+add_fields_to_record_type (tree fields, struct sorted_fields_type *field_vec,\n+\t\t\t   int idx)\n+{\n+  tree x;\n+  for (x = fields; x; x = DECL_CHAIN (x))\n+    {\n+      if (DECL_DECLARES_FUNCTION_P (x))\n+\t/* Functions are handled separately.  */;\n+      else if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+\tidx = add_fields_to_record_type (TYPE_FIELDS (TREE_TYPE (x)), field_vec, idx);\n+      else\n+\tfield_vec->elts[idx++] = x;\n+    }\n+  return idx;\n+}\n+\n+/* Add all of the enum values of ENUMTYPE, to the FIELD_VEC elts,\n+   starting at offset IDX.  */\n+\n+static int\n+add_enum_fields_to_record_type (tree enumtype,\n+\t\t\t\tstruct sorted_fields_type *field_vec,\n+\t\t\t\tint idx)\n+{\n+  tree values;\n+  for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))\n+    field_vec->elts[idx++] = TREE_VALUE (values);\n+  return idx;\n+}\n+\n+/* Insert FIELDS into KLASS for the sorted case if the FIELDS count is\n+   big enough.  */\n \n void \n set_class_bindings (tree klass, tree fields)\n {\n-  gcc_assert (!CLASSTYPE_BINDINGS (klass));\n-\n-  CLASSTYPE_BINDINGS (klass)\n-    = hash_map<lang_identifier *, tree>::create_ggc (8);\n-  add_class_members (CLASSTYPE_BINDINGS (klass), fields);\n+  int n_fields = count_fields (fields);\n+  if (n_fields >= 8)\n+    {\n+      struct sorted_fields_type *field_vec = sorted_fields_type_new (n_fields);\n+      add_fields_to_record_type (fields, field_vec, 0);\n+      qsort (field_vec->elts, n_fields, sizeof (tree), field_decl_cmp);\n+      CLASSTYPE_SORTED_FIELDS (klass) = field_vec;\n+    }\n }\n \n-/* Insert lately defined enum ENUMTYPE into T for the sorted case.  */\n+/* Insert lately defined enum ENUMTYPE into KLASS for the sorted case.  */\n \n void\n insert_late_enum_def_bindings (tree klass, tree enumtype)\n {\n-  hash_map<lang_identifier *, tree> *map = CLASSTYPE_BINDINGS (klass);\n+  struct sorted_fields_type *sorted_fields = CLASSTYPE_SORTED_FIELDS (klass);\n+  if (sorted_fields)\n+    {\n+      int i;\n+      int n_fields\n+\t= list_length (TYPE_VALUES (enumtype)) + sorted_fields->len;\n+      struct sorted_fields_type *field_vec = sorted_fields_type_new (n_fields);\n+      \n+      for (i = 0; i < sorted_fields->len; ++i)\n+\tfield_vec->elts[i] = sorted_fields->elts[i];\n \n-  for (tree values = TYPE_VALUES (enumtype);\n-       values; values = TREE_CHAIN (values))\n-    add_class_member (map, DECL_NAME (TREE_VALUE (values)),\n-\t\t      TREE_VALUE (values));\n+      add_enum_fields_to_record_type (enumtype, field_vec,\n+\t\t\t\t      sorted_fields->len);\n+      qsort (field_vec->elts, n_fields, sizeof (tree), field_decl_cmp);\n+      CLASSTYPE_SORTED_FIELDS (klass) = field_vec;\n+    }\n }\n \n /* Compute the chain index of a binding_entry given the HASH value of its"}]}