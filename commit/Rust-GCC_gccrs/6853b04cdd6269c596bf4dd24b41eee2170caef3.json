{"sha": "6853b04cdd6269c596bf4dd24b41eee2170caef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1M2IwNGNkZDYyNjljNTk2YmY0ZGQyNGI0MWVlZTIxNzBjYWVmMw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2015-09-01T08:39:47Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2015-09-01T08:39:47Z"}, "message": "re PR c++/61753 (poor diagnostic for constructor definition that starts with 'const')\n\n/cp\n2015-09-01  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/61753\n\t* decl.c (smallest_type_quals_location): New.\n\t(check_special_function_return_type): Use the latter; add int and\n\tconst location_t* parameters.\n\t(grokdeclarator): Adjust check_special_function_return_type call.\n\n/testsuite\n2015-09-01  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/61753\n\t* g++.dg/other/pr61753.C: New.\n\nFrom-SVN: r227361", "tree": {"sha": "fe4cdc38ad1d9ae22dbdec61b95b211090f74d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe4cdc38ad1d9ae22dbdec61b95b211090f74d89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6853b04cdd6269c596bf4dd24b41eee2170caef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6853b04cdd6269c596bf4dd24b41eee2170caef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6853b04cdd6269c596bf4dd24b41eee2170caef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6853b04cdd6269c596bf4dd24b41eee2170caef3/comments", "author": null, "committer": null, "parents": [{"sha": "e071af96da90ec5e2d224cdd9522b428b21f7d2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e071af96da90ec5e2d224cdd9522b428b21f7d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e071af96da90ec5e2d224cdd9522b428b21f7d2c"}], "stats": {"total": 129, "additions": 105, "deletions": 24}, "files": [{"sha": "477bb209388b6aafe38ec5f328fabfd674d0a596", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6853b04cdd6269c596bf4dd24b41eee2170caef3", "patch": "@@ -1,3 +1,11 @@\n+2015-09-01  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/61753\n+\t* decl.c (smallest_type_quals_location): New.\n+\t(check_special_function_return_type): Use the latter; add int and\n+\tconst location_t* parameters.\n+\t(grokdeclarator): Adjust check_special_function_return_type call.\n+\n 2015-08-29  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR c++/67371"}, {"sha": "96d735a36928a65023596d03d8f09fae0bf3df7b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6853b04cdd6269c596bf4dd24b41eee2170caef3", "patch": "@@ -113,7 +113,7 @@ static void end_cleanup_fn (void);\n static tree cp_make_fname_decl (location_t, tree, int);\n static void initialize_predefined_identifiers (void);\n static tree check_special_function_return_type\n-\t(special_function_kind, tree, tree);\n+       (special_function_kind, tree, tree, int, const location_t*);\n static tree push_cp_library_fn (enum tree_code, tree, int);\n static tree build_cp_library_fn (tree, enum tree_code, tree, int);\n static void store_parm_decls (tree);\n@@ -8924,24 +8924,51 @@ create_array_type_for_decl (tree name, tree type, tree size)\n   return build_cplus_array_type (type, itype);\n }\n \n-/* Check that it's OK to declare a function with the indicated TYPE.\n-   SFK indicates the kind of special function (if any) that this\n-   function is.  OPTYPE is the type given in a conversion operator\n-   declaration, or the class type for a constructor/destructor.\n-   Returns the actual return type of the function; that\n-   may be different than TYPE if an error occurs, or for certain\n-   special functions.  */\n+/* Returns the smallest location != UNKNOWN_LOCATION among the\n+   three stored in LOCATIONS[ds_const], LOCATIONS[ds_volatile],\n+   and LOCATIONS[ds_restrict].  */\n+\n+static location_t\n+smallest_type_quals_location (int type_quals, const location_t* locations)\n+{\n+  location_t loc = UNKNOWN_LOCATION;\n+\n+  if (type_quals & TYPE_QUAL_CONST)\n+    loc = locations[ds_const];\n+\n+  if ((type_quals & TYPE_QUAL_VOLATILE)\n+      && (loc == UNKNOWN_LOCATION || locations[ds_volatile] < loc))\n+    loc = locations[ds_volatile];\n+\n+  if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && (loc == UNKNOWN_LOCATION || locations[ds_restrict] < loc))\n+    loc = locations[ds_restrict];\n+\n+  return loc;\n+}\n+\n+/* Check that it's OK to declare a function with the indicated TYPE\n+   and TYPE_QUALS.  SFK indicates the kind of special function (if any)\n+   that this function is.  OPTYPE is the type given in a conversion\n+   operator declaration, or the class type for a constructor/destructor.\n+   Returns the actual return type of the function; that may be different\n+   than TYPE if an error occurs, or for certain special functions.  */\n \n static tree\n check_special_function_return_type (special_function_kind sfk,\n \t\t\t\t    tree type,\n-\t\t\t\t    tree optype)\n+\t\t\t\t    tree optype,\n+\t\t\t\t    int type_quals,\n+\t\t\t\t    const location_t* locations)\n {\n   switch (sfk)\n     {\n     case sfk_constructor:\n       if (type)\n \terror (\"return type specification for constructor invalid\");\n+      else if (type_quals != TYPE_UNQUALIFIED)\n+\terror_at (smallest_type_quals_location (type_quals, locations),\n+\t\t  \"qualifiers are not allowed on constructor declaration\");\n \n       if (targetm.cxx.cdtor_returns_this () && !TYPE_FOR_JAVA (optype))\n \ttype = build_pointer_type (optype);\n@@ -8952,6 +8979,10 @@ check_special_function_return_type (special_function_kind sfk,\n     case sfk_destructor:\n       if (type)\n \terror (\"return type specification for destructor invalid\");\n+      else if (type_quals != TYPE_UNQUALIFIED)\n+\terror_at (smallest_type_quals_location (type_quals, locations),\n+\t\t  \"qualifiers are not allowed on destructor declaration\");\n+\n       /* We can't use the proper return type here because we run into\n \t problems with ambiguous bases and covariant returns.\n \t Java classes are left unchanged because (void *) isn't a valid\n@@ -8964,7 +8995,12 @@ check_special_function_return_type (special_function_kind sfk,\n \n     case sfk_conversion:\n       if (type)\n-\terror (\"return type specified for %<operator %T%>\",  optype);\n+\terror (\"return type specified for %<operator %T%>\", optype);\n+      else if (type_quals != TYPE_UNQUALIFIED)\n+\terror_at (smallest_type_quals_location (type_quals, locations),\n+\t\t  \"qualifiers are not allowed on declaration of \"\n+\t\t  \"%<operator %T%>\", optype);\n+\n       type = optype;\n       break;\n \n@@ -9090,7 +9126,7 @@ grokdeclarator (const cp_declarator *declarator,\n      a member function.  */\n   cp_ref_qualifier rqual = REF_QUAL_NONE;\n   /* cv-qualifiers that apply to the type specified by the DECLSPECS.  */\n-  int type_quals;\n+  int type_quals = TYPE_UNQUALIFIED;\n   tree raises = NULL_TREE;\n   int template_count = 0;\n   tree returned_attrs = NULL_TREE;\n@@ -9137,6 +9173,13 @@ grokdeclarator (const cp_declarator *declarator,\n   if (concept_p)\n     constexpr_p = true;\n \n+  if (decl_spec_seq_has_spec_p (declspecs, ds_const))\n+    type_quals |= TYPE_QUAL_CONST;\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_volatile))\n+    type_quals |= TYPE_QUAL_VOLATILE;\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_restrict))\n+    type_quals |= TYPE_QUAL_RESTRICT;\n+\n   if (decl_context == FUNCDEF)\n     funcdef_flag = true, decl_context = NORMAL;\n   else if (decl_context == MEMFUNCDEF)\n@@ -9462,8 +9505,13 @@ grokdeclarator (const cp_declarator *declarator,\n     ctor_return_type = ctype;\n \n   if (sfk != sfk_none)\n-    type = check_special_function_return_type (sfk, type,\n-\t\t\t\t\t       ctor_return_type);\n+    {\n+      type = check_special_function_return_type (sfk, type,\n+\t\t\t\t\t\t ctor_return_type,\n+\t\t\t\t\t\t type_quals,\n+\t\t\t\t\t\t declspecs->locations);\n+      type_quals = TYPE_UNQUALIFIED;\n+    }\n   else if (type == NULL_TREE)\n     {\n       int is_main;\n@@ -9648,17 +9696,6 @@ grokdeclarator (const cp_declarator *declarator,\n \ttype = build_complex_type (type);\n     }\n \n-  type_quals = TYPE_UNQUALIFIED;\n-  if (decl_spec_seq_has_spec_p (declspecs, ds_const))\n-    type_quals |= TYPE_QUAL_CONST;\n-  if (decl_spec_seq_has_spec_p (declspecs, ds_volatile))\n-    type_quals |= TYPE_QUAL_VOLATILE;\n-  if (decl_spec_seq_has_spec_p (declspecs, ds_restrict))\n-    type_quals |= TYPE_QUAL_RESTRICT;\n-  if (sfk == sfk_conversion && type_quals != TYPE_UNQUALIFIED)\n-    error (\"qualifiers are not allowed on declaration of %<operator %T%>\",\n-\t   ctor_return_type);\n-\n   /* If we're using the injected-class-name to form a compound type or a\n      declaration, replace it with the underlying class so we don't get\n      redundant typedefs in the debug output.  But if we are returning the"}, {"sha": "b9d9f84ba749bf2d00425cbee273da38749b89ac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6853b04cdd6269c596bf4dd24b41eee2170caef3", "patch": "@@ -1,3 +1,8 @@\n+2015-09-01  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/61753\n+\t* g++.dg/other/pr61753.C: New.\n+\n 2015-08-31  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* gcc.dg/tree-ssa/cmp-1.c: New file."}, {"sha": "6c6a738e07e2b06d3b49254e74e0348d3f288e18", "filename": "gcc/testsuite/g++.dg/other/pr61753.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr61753.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6853b04cdd6269c596bf4dd24b41eee2170caef3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr61753.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr61753.C?ref=6853b04cdd6269c596bf4dd24b41eee2170caef3", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/61753\n+\n+class Rulec {\n+  Rulec();\n+};\n+\n+const Rulec::Rulec() { }      // { dg-error \"1:qualifiers\" }\n+\n+class Rulev {\n+  Rulev();\n+};\n+\n+volatile Rulev::Rulev() { }   // { dg-error \"1:qualifiers\" }\n+\n+class Ruler {\n+  Ruler();\n+};\n+\n+__restrict Ruler::Ruler() { }  // { dg-error \"1:qualifiers\" }\n+\n+class Rulecvr {\n+  Rulecvr();\n+};\n+\n+const volatile __restrict Rulecvr::Rulecvr() { }  // { dg-error \"1:qualifiers\" }\n+\n+class Rulervc {\n+  Rulervc();\n+};\n+\n+__restrict volatile const Rulervc::Rulervc() { }  // { dg-error \"1:qualifiers\" }"}]}