{"sha": "9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE5ZTI2NmIwYjc4YTM2ZjM5YjlkMWRjZGFkZDUyZGU4NGU2OGRhYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-05-10T07:50:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-05-10T07:50:33Z"}, "message": "sparc.c (fp_sethi_p): Test !SPARC_SIMM13_P and remove redundant test.\n\n\t* config/sparc/sparc.c (fp_sethi_p): Test !SPARC_SIMM13_P and\n\tremove redundant test.\n\t(fp_mov_p): Accept 0.\n\t(fp_high_losum_p): Remove redundant test.\n\t* config/sparc/predicates.md (const_high_operand): Explicitly test\n\t(not small_int_operand).\n\t(fp_const_high_losum_operand): New.\n\t* config/sparc/sparc.md (movsi_insn): Do not emit 'clr'.  Reorder.\n\t(movdi_insn_sp32_v9): Use canonical predicates.\n\t(movdi_insn_sp32): Test !TARGET_V9 instead of !TARGET_ARCH64.\n\t(movdi_insn_sp64_novis): Delete.\n\t(movdi_insn_sp64_vis): Rename into movdi_insn_sp64.\n\t(movsf_insn_novis): Delete.\n\t(movsf_insn_vis): Rename into movsf_insn.\n\t(movsf_no_f_insn): Rename into movsf_insn_no_fpu.\n\t(movsf_lo_sum): Use fp_const_high_losum_operand.\n\t(movsf_high): Likewise.\n\t(movsf_high_losum splitter): Likewise.\n\t(mov<V32:mode> expander): Use register_or_zero_operand.\n\t(mov<V64:mode> expander): Likewise.\n\t(movdf_insn_sp32): Use register_or_zero_operand.\n\t(movdf_no_e_insn_sp32): Use register_or_zero_operand.\n\tRename into movdf_insn_sp32_no_fpu.\n\t(movdf_no_e_insn_v9_sp32): Use register_or_zero_operand.\n\tRename into movdf_insn_sp32_v9_no_fpu.\n\t(movdf_insn_v9only_novis): Delete.\n\t(movdf_insn_v9only_vis): Rename into movdf_insn_sp32_v9.\n\t(movdf_insn_sp64_novis): Delete.\n\t(movdf_insn_sp64_vis): Rename into movdf_insn_sp64.\n\t(movdf_no_e_insn_sp64): Use register_or_zero_operand.\n\tRename into movdf_insn_sp64_no_fpu.\n\t(movtf expander): Use register_or_zero_operand.\n\t(movtf_insn_sp32): Delete.\n\t(movtf_insn_vis_sp32): Use register_or_zero_operand.\n\tRename into movtf_insn_sp32.\n\t(movtf_no_e_insn_sp32): Use register_or_zero_operand.\n\tRename into movtf_insn_sp32_no_fpu.\n\t(movtf_insn_hq_sp64): Delete.\n\t(movtf_insn_hq_vis_sp64): Use register_or_zero_operand.\n\tRename into movtf_insn_sp64_hq.\n\t(movtf_insn_sp64): Delete.\n\t(movtf_insn_vis_sp64): Use register_or_zero_operand.\n\tRename into movtf_insn_sp64.\n\t(movtf_no_e_insn_sp64): Use register_or_zero_operand.\n\tRename into movtf_insn_sp64_no_fpu.\n\nFrom-SVN: r99506", "tree": {"sha": "6e50e1693ee435afae2ed30e3b10613353fe22ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e50e1693ee435afae2ed30e3b10613353fe22ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4718bfd8f6ca96daedff76278d99423054d3a035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4718bfd8f6ca96daedff76278d99423054d3a035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4718bfd8f6ca96daedff76278d99423054d3a035"}], "stats": {"total": 437, "additions": 146, "deletions": 291}, "files": [{"sha": "847acee46e56630d647f999b06b819612c7273ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "patch": "@@ -1,3 +1,51 @@\n+2005-05-10  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.c (fp_sethi_p): Test !SPARC_SIMM13_P and\n+\tremove redundant test.\n+\t(fp_mov_p): Accept 0.\n+\t(fp_high_losum_p): Remove redundant test.\n+\t* config/sparc/predicates.md (const_high_operand): Explicitly test\n+\t(not small_int_operand).\n+\t(fp_const_high_losum_operand): New.\n+\t* config/sparc/sparc.md (movsi_insn): Do not emit 'clr'.  Reorder.\n+\t(movdi_insn_sp32_v9): Use canonical predicates.\n+\t(movdi_insn_sp32): Test !TARGET_V9 instead of !TARGET_ARCH64.\n+\t(movdi_insn_sp64_novis): Delete.\n+\t(movdi_insn_sp64_vis): Rename into movdi_insn_sp64.\n+\t(movsf_insn_novis): Delete.\n+\t(movsf_insn_vis): Rename into movsf_insn.\n+\t(movsf_no_f_insn): Rename into movsf_insn_no_fpu.\n+\t(movsf_lo_sum): Use fp_const_high_losum_operand.\n+\t(movsf_high): Likewise.\n+\t(movsf_high_losum splitter): Likewise.\n+\t(mov<V32:mode> expander): Use register_or_zero_operand.\n+\t(mov<V64:mode> expander): Likewise.\n+\t(movdf_insn_sp32): Use register_or_zero_operand.\n+\t(movdf_no_e_insn_sp32): Use register_or_zero_operand.\n+\tRename into movdf_insn_sp32_no_fpu.\n+\t(movdf_no_e_insn_v9_sp32): Use register_or_zero_operand.\n+\tRename into movdf_insn_sp32_v9_no_fpu.\n+\t(movdf_insn_v9only_novis): Delete.\n+\t(movdf_insn_v9only_vis): Rename into movdf_insn_sp32_v9.\n+\t(movdf_insn_sp64_novis): Delete.\n+\t(movdf_insn_sp64_vis): Rename into movdf_insn_sp64.\n+\t(movdf_no_e_insn_sp64): Use register_or_zero_operand. \n+\tRename into movdf_insn_sp64_no_fpu.\n+\t(movtf expander): Use register_or_zero_operand.\n+\t(movtf_insn_sp32): Delete.\n+\t(movtf_insn_vis_sp32): Use register_or_zero_operand.\n+\tRename into movtf_insn_sp32.\n+\t(movtf_no_e_insn_sp32): Use register_or_zero_operand.\n+\tRename into movtf_insn_sp32_no_fpu.\n+\t(movtf_insn_hq_sp64): Delete.\n+\t(movtf_insn_hq_vis_sp64): Use register_or_zero_operand.\n+\tRename into movtf_insn_sp64_hq.\n+\t(movtf_insn_sp64): Delete.\n+\t(movtf_insn_vis_sp64): Use register_or_zero_operand.\n+\tRename into movtf_insn_sp64.\n+\t(movtf_no_e_insn_sp64): Use register_or_zero_operand.\n+\tRename into movtf_insn_sp64_no_fpu.\n+\n 2005-05-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/stormy16/stormy16.c (xstormy16_emit_cbranch): Use"}, {"sha": "b56ae65af3563061cb6a7afa88c945f7ae7ac478", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "patch": "@@ -65,7 +65,7 @@\n ;; The first test avoids emitting sethi to load zero for example.\n (define_predicate \"const_high_operand\"\n   (and (match_code \"const_int\")\n-       (and (match_test \"INTVAL (op) & ~(HOST_WIDE_INT)0x3ff\")\n+       (and (not (match_operand 0 \"small_int_operand\"))\n             (match_test \"SPARC_SETHI_P (INTVAL (op) & GET_MODE_MASK (mode))\"))))\n \n ;; Return true if OP is a constant whose 1's complement can be loaded by the\n@@ -75,6 +75,16 @@\n        (and (not (match_operand 0 \"small_int_operand\"))\n             (match_test \"SPARC_SETHI_P (~INTVAL (op) & GET_MODE_MASK (mode))\"))))\n \n+;; Return true if OP is a FP constant that needs to be loaded by the sethi/losum\n+;; pair of instructions.\n+(define_predicate \"fp_const_high_losum_operand\"\n+  (match_operand 0 \"const_double_operand\")\n+{\n+  gcc_assert (mode == SFmode);\n+  return fp_high_losum_p (op);\n+})\n+\n+\n ;; Predicates for symbolic constants.\n \n ;; Return true if OP is either a symbol reference or a sum of a symbol"}, {"sha": "6715437dfe680668965e1dbb1980c8189aa122c7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "patch": "@@ -818,12 +818,8 @@ fp_sethi_p (rtx op)\n       long i;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-      if (REAL_VALUES_EQUAL (r, dconst0) &&\n-\t  ! REAL_VALUE_MINUS_ZERO (r))\n-\treturn 0;\n       REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-      if (SPARC_SETHI_P (i))\n-\treturn 1;\n+      return !SPARC_SIMM13_P (i) && SPARC_SETHI_P (i);\n     }\n \n   return 0;\n@@ -842,12 +838,8 @@ fp_mov_p (rtx op)\n       long i;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-      if (REAL_VALUES_EQUAL (r, dconst0) &&\n-\t  ! REAL_VALUE_MINUS_ZERO (r))\n-\treturn 0;\n       REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-      if (SPARC_SIMM13_P (i))\n-\treturn 1;\n+      return SPARC_SIMM13_P (i);\n     }\n \n   return 0;\n@@ -869,13 +861,8 @@ fp_high_losum_p (rtx op)\n       long i;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-      if (REAL_VALUES_EQUAL (r, dconst0) &&\n-\t  ! REAL_VALUE_MINUS_ZERO (r))\n-\treturn 0;\n       REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-      if (! SPARC_SETHI_P (i)\n-          && ! SPARC_SIMM13_P (i))\n-\treturn 1;\n+      return !SPARC_SIMM13_P (i) && !SPARC_SETHI_P (i);\n     }\n \n   return 0;"}, {"sha": "1e6ba93670245124675430339c94e9dd72c6d0be", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 84, "deletions": 274, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9e266b0b78a36f39b9d1dcdadd52de84e68dac/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=9a9e266b0b78a36f39b9d1dcdadd52de84e68dac", "patch": "@@ -1938,21 +1938,20 @@\n })\n \n (define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,f,r,r,r,f,m,m,d\")\n-\t(match_operand:SI 1 \"input_operand\"   \"rI,!f,K,J,m,!m,rJ,!f,J\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,!f,!f,!m,d\")\n+\t(match_operand:SI 1 \"input_operand\"   \"rI,K,m,rJ,f,m,f,J\"))]\n   \"(register_operand (operands[0], SImode)\n     || register_or_zero_operand (operands[1], SImode))\"\n   \"@\n    mov\\t%1, %0\n-   fmovs\\t%1, %0\n    sethi\\t%%hi(%a1), %0\n-   clr\\t%0\n-   ld\\t%1, %0\n    ld\\t%1, %0\n    st\\t%r1, %0\n+   fmovs\\t%1, %0\n+   ld\\t%1, %0\n    st\\t%1, %0\n    fzeros\\t%0\"\n-  [(set_attr \"type\" \"*,fpmove,*,*,load,fpload,store,fpstore,fga\")])\n+  [(set_attr \"type\" \"*,*,load,store,fpmove,fpload,fpstore,fga\")])\n \n (define_insn \"*movsi_lo_sum\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2127,8 +2126,10 @@\n \t\t\t\t\t\"=T,o,T,U,o,r,r,r,?T,?f,?f,?o,?e,?e,?W\")\n         (match_operand:DI 1 \"input_operand\"\n \t\t\t\t\t\" J,J,U,T,r,o,i,r, f, T, o, f, e, W, e\"))]\n-  \"! TARGET_ARCH64 && TARGET_V9\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+  \"! TARGET_ARCH64\n+   && TARGET_V9\n+   && (register_operand (operands[0], DImode)\n+       || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n    stx\\t%%g0, %0\n    #\n@@ -2154,7 +2155,7 @@\n \t\t\t\t\"=o,T,U,o,r,r,r,?T,?f,?f,?o,?f\")\n         (match_operand:DI 1 \"input_operand\"\n \t\t\t\t\" J,U,T,r,o,i,r, f, T, o, f, f\"))]\n-  \"! TARGET_ARCH64\n+  \"! TARGET_V9\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   \"@\n@@ -2173,46 +2174,27 @@\n   [(set_attr \"type\" \"store,store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n    (set_attr \"length\" \"2,*,*,2,2,2,2,*,*,2,2,2\")])\n \n-(define_insn \"*movdi_insn_sp64_novis\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?W\")\n-        (match_operand:DI 1 \"input_operand\"   \"rI,N,J,m,rJ,e,W,e\"))]\n-  \"TARGET_ARCH64 && ! TARGET_VIS\n-   && (register_operand (operands[0], DImode)\n-       || register_or_zero_operand (operands[1], DImode))\"\n-  \"@\n-   mov\\t%1, %0\n-   sethi\\t%%hi(%a1), %0\n-   clr\\t%0\n-   ldx\\t%1, %0\n-   stx\\t%r1, %0\n-   fmovd\\t%1, %0\n-   ldd\\t%1, %0\n-   std\\t%1, %0\"\n-  [(set_attr \"type\" \"*,*,*,load,store,fpmove,fpload,fpstore\")\n-   (set_attr \"fptype\" \"*,*,*,*,*,double,*,*\")])\n-\n ;; We don't define V1SI because SI should work just fine.\n (define_mode_macro V64 [DF V2SI V4HI V8QI])\n (define_mode_macro V32 [SF V2HI V4QI])\n \n-(define_insn \"*movdi_insn_sp64_vis\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?W,b\")\n-        (match_operand:DI 1 \"input_operand\"   \"rI,N,J,m,rJ,e,W,e,J\"))]\n-  \"TARGET_ARCH64 && TARGET_VIS &&\n-   (register_operand (operands[0], DImode)\n-    || register_or_zero_operand (operands[1], DImode))\"\n+(define_insn \"*movdi_insn_sp64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,m,?e,?e,?W,b\")\n+        (match_operand:DI 1 \"input_operand\"   \"rI,N,m,rJ,e,W,e,J\"))]\n+  \"TARGET_ARCH64\n+   && (register_operand (operands[0], DImode)\n+       || register_or_zero_operand (operands[1], DImode))\"\n   \"@\n    mov\\t%1, %0\n    sethi\\t%%hi(%a1), %0\n-   clr\\t%0\n    ldx\\t%1, %0\n    stx\\t%r1, %0\n    fmovd\\t%1, %0\n    ldd\\t%1, %0\n    std\\t%1, %0\n    fzero\\t%0\"\n-  [(set_attr \"type\" \"*,*,*,load,store,fpmove,fpload,fpstore,fga\")\n-   (set_attr \"fptype\" \"*,*,*,*,*,double,*,*,double\")])\n+  [(set_attr \"type\" \"*,*,load,store,fpmove,fpload,fpstore,fga\")\n+   (set_attr \"fptype\" \"*,*,*,*,double,*,*,double\")])\n \n (define_expand \"movdi_pic_label_ref\"\n   [(set (match_dup 3) (high:DI\n@@ -2566,16 +2548,16 @@\n   emit_insn (gen_movsi (adjust_address (operands[0], SImode, 4), const0_rtx));\n   DONE;\n })\n-\f\n-;; Floating point move insns\n \n-(define_insn \"*movsf_insn_novis\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,*r,*r,*r,*r,*r,f,m,m\")\n-\t(match_operand:SF 1 \"input_operand\"         \"f,G,Q,*rR,S,m,m,f,*rG\"))]\n-  \"(TARGET_FPU && ! TARGET_VIS)\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || const_zero_operand (operands[1], SFmode))\"\n+\n+;; Floating point and vector move instructions\n+\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:V32 0 \"nonimmediate_operand\" \"=d,f,*r,*r,*r,*r,f,m,m\")\n+\t(match_operand:V32 1 \"input_operand\"        \"GY,f,*rRY,Q,S,m,m,f,*rGY\"))]\n+  \"TARGET_FPU\n+   && (register_operand (operands[0], <V32:MODE>mode)\n+       || register_or_zero_operand (operands[1], <V32:MODE>mode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && (which_alternative == 2\n@@ -2593,90 +2575,42 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return \"fmovs\\t%1, %0\";\n+      return \"fzeros\\t%0\";\n     case 1:\n-      return \"clr\\t%0\";\n-    case 2:\n-      return \"sethi\\t%%hi(%a1), %0\";\n-    case 3:\n-      return \"mov\\t%1, %0\";\n-    case 4:\n-      return \"#\";\n-    case 5:\n-    case 6:\n-      return \"ld\\t%1, %0\";\n-    case 7:\n-    case 8:\n-      return \"st\\t%r1, %0\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fpmove,*,*,*,*,load,fpload,fpstore,store\")])\n-\n-(define_insn \"*movsf_insn_vis\"\n-  [(set (match_operand:V32 0 \"nonimmediate_operand\" \"=f,f,*r,*r,*r,*r,*r,f,m,m\")\n-\t(match_operand:V32 1 \"input_operand\"         \"f,GY,GY,Q,*rR,S,m,m,f,*rGY\"))]\n-  \"(TARGET_FPU && TARGET_VIS)\n-   && (register_operand (operands[0], <V32:MODE>mode)\n-       || register_operand (operands[1], <V32:MODE>mode)\n-       || const_zero_operand (operands[1], <V32:MODE>mode))\"\n-{\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      && (which_alternative == 3\n-          || which_alternative == 4\n-          || which_alternative == 5))\n-    {\n-      REAL_VALUE_TYPE r;\n-      long i;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-      REAL_VALUE_TO_TARGET_SINGLE (r, i);\n-      operands[1] = GEN_INT (i);\n-    }\n-\n-  switch (which_alternative)\n-    {\n-    case 0:\n       return \"fmovs\\t%1, %0\";\n-    case 1:\n-      return \"fzeros\\t%0\";\n     case 2:\n-      return \"clr\\t%0\";\n+      return \"mov\\t%1, %0\";\n     case 3:\n       return \"sethi\\t%%hi(%a1), %0\";\n     case 4:\n-      return \"mov\\t%1, %0\";\n-    case 5:\n       return \"#\";\n+    case 5:\n     case 6:\n-    case 7:\n       return \"ld\\t%1, %0\";\n+    case 7:\n     case 8:\n-    case 9:\n       return \"st\\t%r1, %0\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"fpmove,fga,*,*,*,*,load,fpload,fpstore,store\")])\n+  [(set_attr \"type\" \"fga,fpmove,*,*,*,load,fpload,fpstore,store\")])\n \n ;; Exactly the same as above, except that all `f' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `f' reg\n ;; when -mno-fpu.\n \n-(define_insn \"*movsf_no_f_insn\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m\")\n-\t(match_operand:SF 1 \"input_operand\"    \"G,Q,rR,S,m,rG\"))]\n+(define_insn \"*movsf_insn_no_fpu\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:SF 1 \"input_operand\"    \"rR,Q,S,m,rG\"))]\n   \"! TARGET_FPU\n    && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || const_zero_operand (operands[1], SFmode))\"\n+       || register_or_zero_operand (operands[1], SFmode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      && (which_alternative == 1\n-          || which_alternative == 2\n-          || which_alternative == 3))\n+      && (which_alternative == 0\n+          || which_alternative == 1\n+          || which_alternative == 2))\n     {\n       REAL_VALUE_TYPE r;\n       long i;\n@@ -2689,30 +2623,28 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return \"clr\\t%0\";\n+      return \"mov\\t%1, %0\";\n     case 1:\n       return \"sethi\\t%%hi(%a1), %0\";\n     case 2:\n-      return \"mov\\t%1, %0\";\n-    case 3:\n       return \"#\";\n-    case 4:\n+    case 3:\n       return \"ld\\t%1, %0\";\n-    case 5:\n+    case 4:\n       return \"st\\t%r1, %0\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"*,*,*,*,load,store\")])\n+  [(set_attr \"type\" \"*,*,*,load,store\")])\n \n ;; The following 3 patterns build SFmode constants in integer registers.\n \n (define_insn \"*movsf_lo_sum\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n         (lo_sum:SF (match_operand:SF 1 \"register_operand\" \"r\")\n-                   (match_operand:SF 2 \"const_double_operand\" \"S\")))]\n-  \"fp_high_losum_p (operands[2])\"\n+                   (match_operand:SF 2 \"fp_const_high_losum_operand\" \"S\")))]\n+  \"\"\n {\n   REAL_VALUE_TYPE r;\n   long i;\n@@ -2725,8 +2657,8 @@\n \n (define_insn \"*movsf_high\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-        (high:SF (match_operand:SF 1 \"const_double_operand\" \"S\")))]\n-  \"fp_high_losum_p (operands[1])\"\n+        (high:SF (match_operand:SF 1 \"fp_const_high_losum_operand\" \"S\")))]\n+  \"\"\n {\n   REAL_VALUE_TYPE r;\n   long i;\n@@ -2739,10 +2671,8 @@\n \n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n-        (match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"fp_high_losum_p (operands[1])\n-   && (GET_CODE (operands[0]) == REG\n-       && REGNO (operands[0]) < 32)\"\n+        (match_operand:SF 1 \"fp_const_high_losum_operand\" \"\"))]\n+  \"REG_P (operands[0]) && REGNO (operands[0]) < 32\"\n   [(set (match_dup 0) (high:SF (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n@@ -2778,8 +2708,7 @@\n   /* Handle sets of MEM first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], <V32:MODE>mode)\n-\t  || const_zero_operand (operands[1], <V32:MODE>mode))\n+      if (register_or_zero_operand (operands[1], <V32:MODE>mode))\n \tgoto movsf_is_ok;\n \n       if (! reload_in_progress)\n@@ -2842,8 +2771,7 @@\n   /* Handle MEM cases first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], <V64:MODE>mode)\n-\t  || const_zero_operand (operands[1], <V64:MODE>mode))\n+      if (register_or_zero_operand (operands[1], <V64:MODE>mode))\n \tgoto movdf_is_ok;\n \n       if (! reload_in_progress)\n@@ -2881,8 +2809,7 @@\n   \"TARGET_FPU\n    && ! TARGET_V9\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || const_zero_operand (operands[1], DFmode))\"\n+       || register_or_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\t%1, %0\n   std\\t%1, %0\n@@ -2897,15 +2824,13 @@\n  [(set_attr \"type\" \"fpload,fpstore,load,store,*,*,*,*,*,*\")\n   (set_attr \"length\" \"*,*,*,*,2,2,2,2,2,2\")])\n \n-(define_insn \"*movdf_no_e_insn_sp32\"\n+(define_insn \"*movdf_insn_sp32_no_fpu\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,o,r,o\")\n \t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,r\"))]\n   \"! TARGET_FPU\n    && ! TARGET_V9\n-   && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || const_zero_operand (operands[1], DFmode))\"\n+       || register_or_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\t%1, %0\n   std\\t%1, %0\n@@ -2915,15 +2840,14 @@\n   [(set_attr \"type\" \"load,store,*,*,*\")\n    (set_attr \"length\" \"*,*,2,2,2\")])\n \n-(define_insn \"*movdf_no_e_insn_v9_sp32\"\n+(define_insn \"*movdf_insn_sp32_v9_no_fpu\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,T,r,o\")\n \t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,rG\"))]\n   \"! TARGET_FPU\n    && TARGET_V9\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || const_zero_operand (operands[1], DFmode))\"\n+       || register_or_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\t%1, %0\n   std\\t%1, %0\n@@ -2933,43 +2857,15 @@\n   [(set_attr \"type\" \"load,store,store,*,*\")\n    (set_attr \"length\" \"*,*,*,2,2\")])\n \n-;; We have available v9 double floats but not 64-bit\n-;; integer registers and no VIS.\n-(define_insn \"*movdf_insn_v9only_novis\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,T,W,U,T,f,*r,o\")\n-        (match_operand:DF 1 \"input_operand\"    \"e,W#F,G,e,T,U,o#F,*roF,*rGf\"))]\n-  \"TARGET_FPU\n-   && TARGET_V9\n-   && ! TARGET_VIS\n-   && ! TARGET_ARCH64\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || const_zero_operand (operands[1], DFmode))\"\n-  \"@\n-  fmovd\\t%1, %0\n-  ldd\\t%1, %0\n-  stx\\t%r1, %0\n-  std\\t%1, %0\n-  ldd\\t%1, %0\n-  std\\t%1, %0\n-  #\n-  #\n-  #\"\n-  [(set_attr \"type\" \"fpmove,load,store,store,load,store,*,*,*\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,2,2,2\")\n-   (set_attr \"fptype\" \"double,*,*,*,*,*,*,*,*\")])\n-\n-;; We have available v9 double floats but not 64-bit\n-;; integer registers but we have VIS.\n-(define_insn \"*movdf_insn_v9only_vis\"\n-  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=e,e,e,T,W,U,T,f,*r,o\")\n+;; We have available v9 double floats but not 64-bit integer registers.\n+(define_insn \"*movdf_insn_sp32_v9\"\n+  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,e,e,T,W,U,T,f,*r,o\")\n         (match_operand:V64 1 \"input_operand\" \"GY,e,W#F,GY,e,T,U,o#F,*roGYF,*rGYf\"))]\n   \"TARGET_FPU\n-   && TARGET_VIS\n+   && TARGET_V9\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], <V64:MODE>mode)\n-       || register_operand (operands[1], <V64:MODE>mode)\n-       || const_zero_operand (operands[1], <V64:MODE>mode))\"\n+       || register_or_zero_operand (operands[1], <V64:MODE>mode))\"\n   \"@\n   fzero\\t%0\n   fmovd\\t%1, %0\n@@ -2985,40 +2881,14 @@\n    (set_attr \"length\" \"*,*,*,*,*,*,*,2,2,2\")\n    (set_attr \"fptype\" \"double,double,*,*,*,*,*,*,*,*\")])\n \n-;; We have available both v9 double floats and 64-bit\n-;; integer registers. No VIS though.\n-(define_insn \"*movdf_insn_sp64_novis\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,W,*r,*r,m,*r\")\n-        (match_operand:DF 1 \"input_operand\"    \"e,W#F,e,*rG,m,*rG,F\"))]\n-  \"TARGET_FPU\n-   && ! TARGET_VIS\n-   && TARGET_ARCH64\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || const_zero_operand (operands[1], DFmode))\"\n-  \"@\n-  fmovd\\t%1, %0\n-  ldd\\t%1, %0\n-  std\\t%1, %0\n-  mov\\t%r1, %0\n-  ldx\\t%1, %0\n-  stx\\t%r1, %0\n-  #\"\n-  [(set_attr \"type\" \"fpmove,load,store,*,load,store,*\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,2\")\n-   (set_attr \"fptype\" \"double,*,*,*,*,*,*\")])\n-\n-;; We have available both v9 double floats and 64-bit\n-;; integer registers. And we have VIS.\n-(define_insn \"*movdf_insn_sp64_vis\"\n-  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=e,e,e,W,*r,*r,m,*r\")\n+;; We have available both v9 double floats and 64-bit integer registers.\n+(define_insn \"*movdf_insn_sp64\"\n+  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,e,e,W,*r,*r,m,*r\")\n         (match_operand:V64 1 \"input_operand\"    \"GY,e,W#F,e,*rGY,m,*rGY,F\"))]\n   \"TARGET_FPU\n-   && TARGET_VIS\n    && TARGET_ARCH64\n    && (register_operand (operands[0], <V64:MODE>mode)\n-       || register_operand (operands[1], <V64:MODE>mode)\n-       || const_zero_operand (operands[1], <V64:MODE>mode))\"\n+       || register_or_zero_operand (operands[1], <V64:MODE>mode))\"\n   \"@\n   fzero\\t%0\n   fmovd\\t%1, %0\n@@ -3032,14 +2902,13 @@\n    (set_attr \"length\" \"*,*,*,*,*,*,*,2\")\n    (set_attr \"fptype\" \"double,double,*,*,*,*,*,*\")])\n \n-(define_insn \"*movdf_no_e_insn_sp64\"\n+(define_insn \"*movdf_insn_sp64_no_fpu\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n         (match_operand:DF 1 \"input_operand\"    \"r,m,rG\"))]\n   \"! TARGET_FPU\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || const_zero_operand (operands[1], DFmode))\"\n+       || register_or_zero_operand (operands[1], DFmode))\"\n   \"@\n   mov\\t%1, %0\n   ldx\\t%1, %0\n@@ -3293,8 +3162,7 @@\n      full 16-byte alignment for quads.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], TFmode)\n-\t  || const_zero_operand (operands[1], TFmode))\n+      if (register_or_zero_operand (operands[1], TFmode))\n \tgoto movtf_is_ok;\n \n       if (! reload_in_progress)\n@@ -3325,124 +3193,66 @@\n   ;\n })\n \n-;; Be careful, fmovq and {st,ld}{x,q} do not exist when !arch64 so\n-;; we must split them all.  :-(\n (define_insn \"*movtf_insn_sp32\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,U,r\")\n-\t(match_operand:TF 1 \"input_operand\"    \"oe,GeUr,o,roG\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=b,e,o,U,r\")\n+\t(match_operand:TF 1 \"input_operand\"    \"G,oe,GeUr,o,roG\"))]\n   \"TARGET_FPU\n-   && ! TARGET_VIS\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n-  \"#\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"*movtf_insn_vis_sp32\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,U,r\")\n-\t(match_operand:TF 1 \"input_operand\"    \"Goe,GeUr,o,roG\"))]\n-  \"TARGET_FPU\n-   && TARGET_VIS\n-   && ! TARGET_ARCH64\n-   && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n+       || register_or_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n ;; Exactly the same as above, except that all `e' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `e' reg\n ;; when -mno-fpu.\n \n-(define_insn \"*movtf_no_e_insn_sp32\"\n+(define_insn \"*movtf_insn_sp32_no_fpu\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=o,U,o,r,o\")\n \t(match_operand:TF 1 \"input_operand\"    \"G,o,U,roG,r\"))]\n   \"! TARGET_FPU\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n+       || register_or_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n-;; Now handle the float reg cases directly when arch64,\n-;; hard_quad, and proper reg number alignment are all true.\n-(define_insn \"*movtf_insn_hq_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,e,m,o,r\")\n-        (match_operand:TF 1 \"input_operand\"    \"e,m,e,Gr,roG\"))]\n+(define_insn \"*movtf_insn_sp64_hq\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=b,e,e,m,o,r\")\n+        (match_operand:TF 1 \"input_operand\"    \"G,e,m,e,rG,roG\"))]\n   \"TARGET_FPU\n-   && ! TARGET_VIS\n    && TARGET_ARCH64\n    && TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n+       || register_or_zero_operand (operands[1], TFmode))\"\n   \"@\n-  fmovq\\t%1, %0\n-  ldq\\t%1, %0\n-  stq\\t%1, %0\n   #\n-  #\"\n-  [(set_attr \"type\" \"fpmove,fpload,fpstore,*,*\")\n-   (set_attr \"length\" \"*,*,*,2,2\")])\n-\n-(define_insn \"*movtf_insn_hq_vis_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,e,m,eo,r,o\")\n-        (match_operand:TF 1 \"input_operand\"    \"e,m,e,G,roG,r\"))]\n-  \"TARGET_FPU\n-   && TARGET_VIS\n-   && TARGET_ARCH64\n-   && TARGET_HARD_QUAD\n-   && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n-  \"@\n   fmovq\\t%1, %0\n   ldq\\t%1, %0\n   stq\\t%1, %0\n   #\n-  #\n   #\"\n-  [(set_attr \"type\" \"fpmove,fpload,fpstore,*,*,*\")\n-   (set_attr \"length\" \"*,*,*,2,2,2\")])\n+  [(set_attr \"type\" \"*,fpmove,fpload,fpstore,*,*\")\n+   (set_attr \"length\" \"2,*,*,*,2,2\")])\n \n-;; Now we allow the integer register cases even when\n-;; only arch64 is true.\n (define_insn \"*movtf_insn_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,r\")\n-        (match_operand:TF 1 \"input_operand\"    \"oe,Ger,orG\"))]\n-  \"TARGET_FPU\n-   && ! TARGET_VIS\n-   && TARGET_ARCH64\n-   && ! TARGET_HARD_QUAD\n-   && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n-  \"#\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*movtf_insn_vis_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,r\")\n-        (match_operand:TF 1 \"input_operand\"    \"Goe,Ger,orG\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=b,e,o,r\")\n+        (match_operand:TF 1 \"input_operand\"    \"G,oe,Ger,roG\"))]\n   \"TARGET_FPU\n-   && TARGET_VIS\n    && TARGET_ARCH64\n    && ! TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n+       || register_or_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn \"*movtf_no_e_insn_sp64\"\n+(define_insn \"*movtf_insn_sp64_no_fpu\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o\")\n         (match_operand:TF 1 \"input_operand\"    \"orG,rG\"))]\n   \"! TARGET_FPU\n    && TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode)\n-       || const_zero_operand (operands[1], TFmode))\"\n+       || register_or_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n "}]}