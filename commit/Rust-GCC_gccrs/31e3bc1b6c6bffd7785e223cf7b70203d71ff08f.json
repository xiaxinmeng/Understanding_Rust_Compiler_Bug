{"sha": "31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlM2JjMWI2YzZiZmZkNzc4NWUyMjNjZjdiNzAyMDNkNzFmZjA4Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-06-13T13:30:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-06-13T13:30:29Z"}, "message": "Revert\n\t2012-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/decl.c (Has_Thiscall_Convention): New macro.\n\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Test it to set the thiscall\n\tcalling convention\n\t(get_minimal_subprog_decl): Likewise.\n\t(gnat_first_param_is_class): New predicate.\n\nFrom-SVN: r188512", "tree": {"sha": "807edccab0ae99b84067751fbe8d1cedcfc64934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/807edccab0ae99b84067751fbe8d1cedcfc64934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f/comments", "author": null, "committer": null, "parents": [{"sha": "c4cc7bc1ce2c87338f3a55ebfc4ce32d4a31cecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4cc7bc1ce2c87338f3a55ebfc4ce32d4a31cecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4cc7bc1ce2c87338f3a55ebfc4ce32d4a31cecc"}], "stats": {"total": 106, "additions": 23, "deletions": 83}, "files": [{"sha": "e0492032cddf70e908b6340a067819f79159a844", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "patch": "@@ -1,13 +1,13 @@\n-2012-06-11  Olivier Hainque  <hainque@adacore.com>\n+2012-06-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n-\t* gcc-interface/Makefile.in (GNATLIBCFLAGS_FOR_C): Remove\n-\t$(PIC_FLAG_FOR_TARGET).\n-\t(gnatlib-shared-default): Add $(PIC_FLAG_FOR_TARGET) to\n-\tGNATLIBCFLAGS_FOR_C passed to gnatlib.\n-\t(gnatlib-shared-win32): Likewise.\n-\t(gnatlib-shared-darwin): Likewise.\n-\t(gnatlib-shared-dual-win32): Pass PIC_FLAG_FOR_TARGET to\n-\tgnatlib-shared-win32.\n+\tRevert\n+\t2012-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (Has_Thiscall_Convention): New macro.\n+\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Test it to set the thiscall\n+\tcalling convention\n+\t(get_minimal_subprog_decl): Likewise.\n+\t(gnat_first_param_is_class): New predicate.\n \n 2012-06-12  Robert Dewar  <dewar@adacore.com>\n \n@@ -399,6 +399,17 @@\n \tof aspects to collect link name and external name if present,\n \tand verify that a complete pragma can be generated.\n \n+2012-06-11  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gcc-interface/Makefile.in (GNATLIBCFLAGS_FOR_C): Remove\n+\t$(PIC_FLAG_FOR_TARGET).\n+\t(gnatlib-shared-default): Add $(PIC_FLAG_FOR_TARGET) to\n+\tGNATLIBCFLAGS_FOR_C passed to gnatlib.\n+\t(gnatlib-shared-win32): Likewise.\n+\t(gnatlib-shared-darwin): Likewise.\n+\t(gnatlib-shared-dual-win32): Pass PIC_FLAG_FOR_TARGET to\n+\tgnatlib-shared-win32.\n+\n 2012-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Convert GNU_SIZE"}, {"sha": "169e03eea8a19bf25fa7f5cdbd156b1f88e04ad0", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 74, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e3bc1b6c6bffd7785e223cf7b70203d71ff08f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=31e3bc1b6c6bffd7785e223cf7b70203d71ff08f", "patch": "@@ -50,23 +50,19 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-/* \"stdcall\" and \"thiscall\" conventions should be processed in a specific way\n-   on 32-bit x86/Windows only.  The macros below are helpers to avoid having\n-   to check for a Windows specific attribute throughout this unit.  */\n+/* Convention_Stdcall should be processed in a specific way on 32 bits\n+   Windows targets only.  The macro below is a helper to avoid having to\n+   check for a Windows specific attribute throughout this unit.  */\n \n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n #ifdef TARGET_64BIT\n #define Has_Stdcall_Convention(E) \\\n   (!TARGET_64BIT && Convention (E) == Convention_Stdcall)\n-#define Has_Thiscall_Convention(E) \\\n-  (!TARGET_64BIT && gnat_first_param_is_class (E))\n #else\n #define Has_Stdcall_Convention(E) (Convention (E) == Convention_Stdcall)\n-#define Has_Thiscall_Convention(E) (gnat_first_param_is_class (E))\n #endif\n #else\n #define Has_Stdcall_Convention(E) 0\n-#define Has_Thiscall_Convention(E) 0\n #endif\n \n /* Stack realignment is necessary for functions with foreign conventions when\n@@ -130,7 +126,6 @@ DEF_VEC_ALLOC_O(variant_desc,heap);\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n \n-static bool gnat_first_param_is_class (Entity_Id) ATTRIBUTE_UNUSED;\n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute_to (struct attrib **,\n \t\t\t\t      enum attr_type, tree, tree, Node_Id);\n@@ -4418,11 +4413,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t     get_identifier (\"stdcall\"), NULL_TREE,\n \t     gnat_entity);\n-\telse if (Has_Thiscall_Convention (gnat_entity))\n-\t  prepend_one_attribute_to\n-\t    (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t     get_identifier (\"thiscall\"), NULL_TREE,\n-\t     gnat_entity);\n \n \t/* If we should request stack realignment for a foreign convention\n \t   subprogram, do so.  Note that this applies to task entry points in\n@@ -5286,10 +5276,6 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n     prepend_one_attribute_to (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n \t\t\t      get_identifier (\"stdcall\"), NULL_TREE,\n \t\t\t      gnat_entity);\n-  else if (Has_Thiscall_Convention (gnat_entity))\n-    prepend_one_attribute_to (&attr_list, ATTR_MACHINE_ATTRIBUTE,\n-\t\t\t      get_identifier (\"thiscall\"), NULL_TREE,\n-\t\t\t      gnat_entity);\n \n   if (No (Interface_Name (gnat_entity)) && gnu_ext_name == gnu_entity_name)\n     gnu_ext_name = NULL_TREE;\n@@ -5299,63 +5285,6 @@ get_minimal_subprog_decl (Entity_Id gnat_entity)\n \t\t\t false, true, true, true, attr_list, gnat_entity);\n }\n \n-/* Return whether the E_Subprogram_Type/E_Function/E_Procedure GNAT_ENTITY has\n-   a first parameter with a class or equivalent type.\n-\n-   We use the predicate on 32-bit x86/Windows to find out whether we need to\n-   use the \"thiscall\" calling convention for GNAT_ENTITY.  This convention is\n-   the one set for C++ methods (functions with METHOD_TYPE) by the back-end.\n-   Now in Ada primitive operations are regular subprograms (e.g. you can have\n-   common pointers to both) so we cannot compute an equivalent of METHOD_TYPE\n-   and so we set the calling convention in an uniform way.  */\n-\n-static bool\n-gnat_first_param_is_class (Entity_Id gnat_entity)\n-{\n-  Entity_Id gnat_param = First_Formal_With_Extras (gnat_entity);\n-  Entity_Id gnat_type;\n-  Node_Id node;\n-\n-  if (No (gnat_param))\n-    return false;\n-\n-  gnat_type = Underlying_Type (Etype (gnat_param));\n-\n-  /* This is the main case.  Note that we must return the same value for\n-     regular tagged types and CW types since dispatching calls have a CW\n-     type on the caller side and a tagged type on the callee side.  */\n-  if (Is_Tagged_Type (gnat_type))\n-    return True;\n-\n-  /* C++ classes with no virtual functions can be imported as limited\n-     record types, but we need to return true for the constructors.  */\n-  if (Is_CPP_Class (gnat_type))\n-    return True;\n-\n-  /* The language-level \"protected\" calling convention doesn't distinguish\n-     tagged protected types from non-tagged protected types (e.g. you can\n-     have common pointers to both) so we must use a single low-level calling\n-     convention for it.  Since tagged protected types can be derived from\n-     simple limited interfaces, we need to pick the calling convention of\n-     the latters.  */\n-  if (Is_Protected_Record_Type (gnat_type))\n-    return True;\n-\n-  /* If this is the special E_Subprogram_Type built for the declaration of\n-     an access to protected subprogram type, the first parameter will have\n-     type Address, but we must return true to be consistent with above.  */\n-  if (Is_Itype (gnat_entity)\n-      && Present (node = Associated_Node_For_Itype (gnat_entity))\n-      && Nkind (node) == N_Full_Type_Declaration\n-      && Ekind (Defining_Identifier (node)) == E_Access_Subprogram_Type\n-      && Present (node = Original_Access_Type (Defining_Identifier (node)))\n-      && (Ekind (node) == E_Access_Protected_Subprogram_Type\n-\t  || Ekind (node) == E_Anonymous_Access_Protected_Subprogram_Type))\n-    return True;\n-\n-  return False;\n-}\n-\n /* Finalize the processing of From_With_Type incomplete types.  */\n \n void"}]}