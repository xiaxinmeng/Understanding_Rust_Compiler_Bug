{"sha": "f8934be78727eb998f6bb04c001f3dda6cf1017c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5MzRiZTc4NzI3ZWI5OThmNmJiMDRjMDAxZjNkZGE2Y2YxMDE3Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-10-15T08:02:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-10-15T08:02:06Z"}, "message": "loop-unroll.c: (decide_unrolling_and_peeling): Rename to\n\n\n\t* loop-unroll.c: (decide_unrolling_and_peeling): Rename to\n\t(decide_unrolling): ... this one.\n\t(peel_loops_completely): Remove.\n\t(decide_peel_simple): Remove.\n\t(decide_peel_once_rolling): Remove.\n\t(decide_peel_completely): Remove.\n\t(peel_loop_simple): Remove.\n\t(peel_loop_completely): Remove.\n\t(unroll_and_peel_loops): Rename to ...\n\t(unroll_loops): ... this one; handle only unrolling.\n\t* cfgloop.h (lpt_dec): Remove LPT_PEEL_COMPLETELY and\n\tLPT_PEEL_SIMPLE.\n\t(UAP_PEEL): Remove.\n\t(unroll_and_peel_loops): Remove.\n\t(unroll_loops): New.\n\t* passes.def: Replace\n\tpass_rtl_unroll_and_peel_loops by pass_rtl_unroll_loops.\n\t* loop-init.c (gate_rtl_unroll_and_peel_loops,\n\trtl_unroll_and_peel_loops): Rename to ...\n\t(gate_rtl_unroll_loops, rtl_unroll_loops): ... these; update.\n\t(pass_rtl_unroll_and_peel_loops): Rename to ...\n\t(pass_rtl_unroll_loops): ... this one.\n\t* tree-pass.h (make_pass_rtl_unroll_and_peel_loops): Remove.\n\t(make_pass_rtl_unroll_loops): New.\n\t* tree-ssa-loop-ivcanon.c: (estimated_peeled_sequence_size, try_peel_loop): New.\n\t(canonicalize_loop_induction_variables): Update.\n\n\t* gcc.dg/tree-prof/peel-1.c: Update.\n\t* gcc.dg/tree-prof/unroll-1.c: Update.\n\t* gcc.dg/gcc.dg/unroll_1.c: Update.\n\t* gcc.dg/gcc.dg/unroll_2.c: Update.\n\t* gcc.dg/gcc.dg/unroll_3.c: Update.\n\t* gcc.dg/gcc.dg/unroll_4.c: Update.\n\nFrom-SVN: r216238", "tree": {"sha": "e4fe1dea885c050d43cd384f86a97b01f26934e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4fe1dea885c050d43cd384f86a97b01f26934e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8934be78727eb998f6bb04c001f3dda6cf1017c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8934be78727eb998f6bb04c001f3dda6cf1017c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8934be78727eb998f6bb04c001f3dda6cf1017c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8934be78727eb998f6bb04c001f3dda6cf1017c/comments", "author": null, "committer": null, "parents": [{"sha": "fa7fa585ea103c78d433ed615e6d2c7bb68f1ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa7fa585ea103c78d433ed615e6d2c7bb68f1ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa7fa585ea103c78d433ed615e6d2c7bb68f1ec2"}], "stats": {"total": 812, "additions": 268, "deletions": 544}, "files": [{"sha": "62b3e830661eac5d711c407f6ab9c20557bbcd44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,3 +1,32 @@\n+2014-10-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* loop-unroll.c: (decide_unrolling_and_peeling): Rename to\n+\t(decide_unrolling): ... this one.\n+\t(peel_loops_completely): Remove.\n+\t(decide_peel_simple): Remove.\n+\t(decide_peel_once_rolling): Remove.\n+\t(decide_peel_completely): Remove.\n+\t(peel_loop_simple): Remove.\n+\t(peel_loop_completely): Remove.\n+\t(unroll_and_peel_loops): Rename to ...\n+\t(unroll_loops): ... this one; handle only unrolling.\n+\t* cfgloop.h (lpt_dec): Remove LPT_PEEL_COMPLETELY and\n+\tLPT_PEEL_SIMPLE.\n+\t(UAP_PEEL): Remove.\n+\t(unroll_and_peel_loops): Remove.\n+\t(unroll_loops): New.\n+\t* passes.def: Replace\n+\tpass_rtl_unroll_and_peel_loops by pass_rtl_unroll_loops.\n+\t* loop-init.c (gate_rtl_unroll_and_peel_loops,\n+\trtl_unroll_and_peel_loops): Rename to ...\n+\t(gate_rtl_unroll_loops, rtl_unroll_loops): ... these; update.\n+\t(pass_rtl_unroll_and_peel_loops): Rename to ...\n+\t(pass_rtl_unroll_loops): ... this one.\n+\t* tree-pass.h (make_pass_rtl_unroll_and_peel_loops): Remove.\n+\t(make_pass_rtl_unroll_loops): New.\n+\t* tree-ssa-loop-ivcanon.c: (estimated_peeled_sequence_size, try_peel_loop): New.\n+\t(canonicalize_loop_induction_variables): Update.\n+\n 2014-10-14  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* config/xtensa/xtensa.h (TARGET_HARD_FLOAT_POSTINC): new macro."}, {"sha": "932465d99113975ed0024eacfc974fd921049c38", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -30,8 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n enum lpt_dec\n {\n   LPT_NONE,\n-  LPT_PEEL_COMPLETELY,\n-  LPT_PEEL_SIMPLE,\n   LPT_UNROLL_CONSTANT,\n   LPT_UNROLL_RUNTIME,\n   LPT_UNROLL_STUPID\n@@ -731,12 +729,11 @@ extern void loop_optimizer_finalize (void);\n /* Optimization passes.  */\n enum\n {\n-  UAP_PEEL = 1,\t\t/* Enables loop peeling.  */\n-  UAP_UNROLL = 2,\t/* Enables unrolling of loops if it seems profitable.  */\n-  UAP_UNROLL_ALL = 4\t/* Enables unrolling of all loops.  */\n+  UAP_UNROLL = 1,\t/* Enables unrolling of loops if it seems profitable.  */\n+  UAP_UNROLL_ALL = 2\t/* Enables unrolling of all loops.  */\n };\n \n-extern void unroll_and_peel_loops (int);\n+extern void unroll_loops (int);\n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n extern void scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound);"}, {"sha": "8a42650f63af2ac2735446ed7b361ba54196c03b", "filename": "gcc/loop-init.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -357,7 +357,6 @@ pass_loop2::gate (function *fun)\n   if (optimize > 0\n       && (flag_move_loop_invariants\n \t  || flag_unswitch_loops\n-\t  || flag_peel_loops\n \t  || flag_unroll_loops\n #ifdef HAVE_doloop_end\n \t  || (flag_branch_on_count_reg && HAVE_doloop_end)\n@@ -537,7 +536,7 @@ make_pass_rtl_move_loop_invariants (gcc::context *ctxt)\n \f\n namespace {\n \n-const pass_data pass_data_rtl_unroll_and_peel_loops =\n+const pass_data pass_data_rtl_unroll_loops =\n {\n   RTL_PASS, /* type */\n   \"loop2_unroll\", /* name */\n@@ -550,11 +549,11 @@ const pass_data pass_data_rtl_unroll_and_peel_loops =\n   0, /* todo_flags_finish */\n };\n \n-class pass_rtl_unroll_and_peel_loops : public rtl_opt_pass\n+class pass_rtl_unroll_loops : public rtl_opt_pass\n {\n public:\n-  pass_rtl_unroll_and_peel_loops (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_rtl_unroll_and_peel_loops, ctxt)\n+  pass_rtl_unroll_loops (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_rtl_unroll_loops, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -565,35 +564,33 @@ class pass_rtl_unroll_and_peel_loops : public rtl_opt_pass\n \n   virtual unsigned int execute (function *);\n \n-}; // class pass_rtl_unroll_and_peel_loops\n+}; // class pass_rtl_unroll_loops\n \n unsigned int\n-pass_rtl_unroll_and_peel_loops::execute (function *fun)\n+pass_rtl_unroll_loops::execute (function *fun)\n {\n   if (number_of_loops (fun) > 1)\n     {\n       int flags = 0;\n       if (dump_file)\n \tdf_dump (dump_file);\n \n-      if (flag_peel_loops)\n-\tflags |= UAP_PEEL;\n       if (flag_unroll_loops)\n \tflags |= UAP_UNROLL;\n       if (flag_unroll_all_loops)\n \tflags |= UAP_UNROLL_ALL;\n \n-      unroll_and_peel_loops (flags);\n+      unroll_loops (flags);\n     }\n   return 0;\n }\n \n } // anon namespace\n \n rtl_opt_pass *\n-make_pass_rtl_unroll_and_peel_loops (gcc::context *ctxt)\n+make_pass_rtl_unroll_loops (gcc::context *ctxt)\n {\n-  return new pass_rtl_unroll_and_peel_loops (ctxt);\n+  return new pass_rtl_unroll_loops (ctxt);\n }\n \n \f"}, {"sha": "2abb2f4d8d855f0c0d87b95ecf1bb8c91ed55e2e", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 63, "deletions": 507, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,4 +1,4 @@\n-/* Loop unrolling and peeling.\n+/* Loop unrolling.\n    Copyright (C) 2002-2014 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -34,8 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"dumpfile.h\"\n \n-/* This pass performs loop unrolling and peeling.  We only perform these\n-   optimizations on innermost loops (with single exception) because\n+/* This pass performs loop unrolling.  We only perform this\n+   optimization on innermost loops (with single exception) because\n    the impact on performance is greatest here, and we want to avoid\n    unnecessary code size growth.  The gain is caused by greater sequentiality\n    of code, better code to optimize for further passes and in some cases\n@@ -44,12 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n \n    What we do:\n \n-   -- complete peeling of once-rolling loops; this is the above mentioned\n-      exception, as this causes loop to be cancelled completely and\n-      does not cause code growth\n-   -- complete peeling of loops that roll (small) constant times.\n-   -- simple peeling of first iterations of loops that do not roll much\n-      (according to profile feedback)\n    -- unrolling of loops that roll constant times; this is almost always\n       win, as we get rid of exit condition tests.\n    -- unrolling of loops that roll number of times that we can compute\n@@ -62,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n    appropriate function below.\n \n    There is a lot of parameters (defined and described in params.def) that\n-   control how much we unroll/peel.\n+   control how much we unroll.\n \n    ??? A great problem is that we don't have a good way how to determine\n    how many times we should unroll the loop; the experiments I have made\n@@ -170,17 +164,11 @@ struct opt_info\n   basic_block loop_preheader;      /* The loop preheader basic block.  */\n };\n \n-static void decide_unrolling_and_peeling (int);\n-static void peel_loops_completely (int);\n-static void decide_peel_simple (struct loop *, int);\n-static void decide_peel_once_rolling (struct loop *, int);\n-static void decide_peel_completely (struct loop *, int);\n static void decide_unroll_stupid (struct loop *, int);\n static void decide_unroll_constant_iterations (struct loop *, int);\n static void decide_unroll_runtime_iterations (struct loop *, int);\n-static void peel_loop_simple (struct loop *);\n-static void peel_loop_completely (struct loop *);\n static void unroll_loop_stupid (struct loop *);\n+static void decide_unrolling (int);\n static void unroll_loop_constant_iterations (struct loop *);\n static void unroll_loop_runtime_iterations (struct loop *);\n static struct opt_info *analyze_insns_in_loop (struct loop *);\n@@ -197,15 +185,13 @@ static void combine_var_copies_in_loop_exit (struct var_to_expand *,\n \t\t\t\t\t     basic_block);\n static rtx get_expansion (struct var_to_expand *);\n \n-/* Emit a message summarizing the unroll or peel that will be\n+/* Emit a message summarizing the unroll that will be\n    performed for LOOP, along with the loop's location LOCUS, if\n    appropriate given the dump or -fopt-info settings.  */\n \n static void\n-report_unroll_peel (struct loop *loop, location_t locus)\n+report_unroll (struct loop *loop, location_t locus)\n {\n-  struct niter_desc *desc;\n-  int niters = 0;\n   int report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_RTL | TDF_DETAILS;\n \n   if (loop->lpt_decision.decision == LPT_NONE)\n@@ -214,169 +200,20 @@ report_unroll_peel (struct loop *loop, location_t locus)\n   if (!dump_enabled_p ())\n     return;\n \n-  /* In the special case where the loop never iterated, emit\n-     a different message so that we don't report an unroll by 0.\n-     This matches the equivalent message emitted during tree unrolling.  */\n-  if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY\n-      && !loop->lpt_decision.times)\n-    {\n-      dump_printf_loc (report_flags, locus,\n-                       \"loop turned into non-loop; it never loops.\\n\");\n-      return;\n-    }\n-\n-  desc = get_simple_loop_desc (loop);\n-\n-  if (desc->const_iter)\n-    niters = desc->niter;\n-  else if (loop->header->count)\n-    niters = expected_loop_iterations (loop);\n-\n-  if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n-    dump_printf_loc (report_flags, locus,\n-                     \"loop with %d iterations completely unrolled\",\n-\t\t     loop->lpt_decision.times + 1);\n-  else\n-    dump_printf_loc (report_flags, locus,\n-                     \"loop %s %d times\",\n-                     (loop->lpt_decision.decision == LPT_PEEL_SIMPLE\n-                       ? \"peeled\" : \"unrolled\"),\n-                     loop->lpt_decision.times);\n+  dump_printf_loc (report_flags, locus,\n+                   \"loop unrolled %d times\",\n+                   loop->lpt_decision.times);\n   if (profile_info)\n     dump_printf (report_flags,\n-                 \" (header execution count %d\",\n+                 \" (header execution count %d)\",\n                  (int)loop->header->count);\n-  if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n-    dump_printf (report_flags,\n-                 \"%s%s iterations %d)\",\n-                 profile_info ? \", \" : \" (\",\n-                 desc->const_iter ? \"const\" : \"average\",\n-                 niters);\n-  else if (profile_info)\n-    dump_printf (report_flags, \")\");\n \n   dump_printf (report_flags, \"\\n\");\n }\n \n-/* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n-void\n-unroll_and_peel_loops (int flags)\n-{\n-  struct loop *loop;\n-  bool changed = false;\n-\n-  /* First perform complete loop peeling (it is almost surely a win,\n-     and affects parameters for further decision a lot).  */\n-  peel_loops_completely (flags);\n-\n-  /* Now decide rest of unrolling and peeling.  */\n-  decide_unrolling_and_peeling (flags);\n-\n-  /* Scan the loops, inner ones first.  */\n-  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n-    {\n-      /* And perform the appropriate transformations.  */\n-      switch (loop->lpt_decision.decision)\n-\t{\n-\tcase LPT_PEEL_COMPLETELY:\n-\t  /* Already done.  */\n-\t  gcc_unreachable ();\n-\tcase LPT_PEEL_SIMPLE:\n-\t  peel_loop_simple (loop);\n-\t  changed = true;\n-\t  break;\n-\tcase LPT_UNROLL_CONSTANT:\n-\t  unroll_loop_constant_iterations (loop);\n-\t  changed = true;\n-\t  break;\n-\tcase LPT_UNROLL_RUNTIME:\n-\t  unroll_loop_runtime_iterations (loop);\n-\t  changed = true;\n-\t  break;\n-\tcase LPT_UNROLL_STUPID:\n-\t  unroll_loop_stupid (loop);\n-\t  changed = true;\n-\t  break;\n-\tcase LPT_NONE:\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-    if (changed)\n-      {\n-\tcalculate_dominance_info (CDI_DOMINATORS);\n-\tfix_loop_structure (NULL);\n-      }\n-\n-  iv_analysis_done ();\n-}\n-\n-/* Check whether exit of the LOOP is at the end of loop body.  */\n-\n-static bool\n-loop_exit_at_end_p (struct loop *loop)\n-{\n-  struct niter_desc *desc = get_simple_loop_desc (loop);\n-  rtx_insn *insn;\n-\n-  if (desc->in_edge->dest != loop->latch)\n-    return false;\n-\n-  /* Check that the latch is empty.  */\n-  FOR_BB_INSNS (loop->latch, insn)\n-    {\n-      if (NONDEBUG_INSN_P (insn))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Depending on FLAGS, check whether to peel loops completely and do so.  */\n-static void\n-peel_loops_completely (int flags)\n-{\n-  struct loop *loop;\n-  bool changed = false;\n-\n-  /* Scan the loops, the inner ones first.  */\n-  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n-    {\n-      loop->lpt_decision.decision = LPT_NONE;\n-      location_t locus = get_loop_location (loop);\n-\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (TDF_RTL, locus,\n-                         \";; *** Considering loop %d at BB %d for \"\n-                         \"complete peeling ***\\n\",\n-                         loop->num, loop->header->index);\n-\n-      loop->ninsns = num_loop_insns (loop);\n-\n-      decide_peel_once_rolling (loop, flags);\n-      if (loop->lpt_decision.decision == LPT_NONE)\n-\tdecide_peel_completely (loop, flags);\n-\n-      if (loop->lpt_decision.decision == LPT_PEEL_COMPLETELY)\n-\t{\n-\t  report_unroll_peel (loop, locus);\n-\t  peel_loop_completely (loop);\n-\t  changed = true;\n-\t}\n-    }\n-\n-    if (changed)\n-      {\n-\tcalculate_dominance_info (CDI_DOMINATORS);\n-\tfix_loop_structure (NULL);\n-      }\n-}\n-\n-/* Decide whether unroll or peel loops (depending on FLAGS) and how much.  */\n+/* Decide whether unroll loops and how much.  */\n static void\n-decide_unrolling_and_peeling (int flags)\n+decide_unrolling (int flags)\n {\n   struct loop *loop;\n \n@@ -389,7 +226,7 @@ decide_unrolling_and_peeling (int flags)\n       if (dump_enabled_p ())\n \tdump_printf_loc (TDF_RTL, locus,\n                          \";; *** Considering loop %d at BB %d for \"\n-                         \"unrolling and peeling ***\\n\",\n+                         \"unrolling ***\\n\",\n                          loop->num, loop->header->index);\n \n       /* Do not peel cold areas.  */\n@@ -428,204 +265,77 @@ decide_unrolling_and_peeling (int flags)\n \tdecide_unroll_runtime_iterations (loop, flags);\n       if (loop->lpt_decision.decision == LPT_NONE)\n \tdecide_unroll_stupid (loop, flags);\n-      if (loop->lpt_decision.decision == LPT_NONE)\n-\tdecide_peel_simple (loop, flags);\n \n-      report_unroll_peel (loop, locus);\n+      report_unroll (loop, locus);\n     }\n }\n \n-/* Decide whether the LOOP is once rolling and suitable for complete\n-   peeling.  */\n-static void\n-decide_peel_once_rolling (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n-{\n-  struct niter_desc *desc;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n;; Considering peeling once rolling loop\\n\");\n-\n-  /* Is the loop small enough?  */\n-  if ((unsigned) PARAM_VALUE (PARAM_MAX_ONCE_PEELED_INSNS) < loop->ninsns)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n-      return;\n-    }\n-\n-  /* Check for simple loops.  */\n-  desc = get_simple_loop_desc (loop);\n-\n-  /* Check number of iterations.  */\n-  if (!desc->simple_p\n-      || desc->assumptions\n-      || desc->infinite\n-      || !desc->const_iter\n-      || (desc->niter != 0\n-\t  && get_max_loop_iterations_int (loop) != 0))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \";; Unable to prove that the loop rolls exactly once\\n\");\n-      return;\n-    }\n-\n-  /* Success.  */\n-  loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n-}\n-\n-/* Decide whether the LOOP is suitable for complete peeling.  */\n-static void\n-decide_peel_completely (struct loop *loop, int flags ATTRIBUTE_UNUSED)\n+/* Unroll LOOPS.  */\n+void\n+unroll_loops (int flags)\n {\n-  unsigned npeel;\n-  struct niter_desc *desc;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n;; Considering peeling completely\\n\");\n-\n-  /* Skip non-innermost loops.  */\n-  if (loop->inner)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not considering loop, is not innermost\\n\");\n-      return;\n-    }\n-\n-  /* Do not peel cold areas.  */\n-  if (optimize_loop_for_size_p (loop))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not considering loop, cold area\\n\");\n-      return;\n-    }\n-\n-  /* Can the loop be manipulated?  */\n-  if (!can_duplicate_loop_p (loop))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \";; Not considering loop, cannot duplicate\\n\");\n-      return;\n-    }\n-\n-  /* npeel = number of iterations to peel.  */\n-  npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS) / loop->ninsns;\n-  if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n-    npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES);\n-\n-  /* Is the loop small enough?  */\n-  if (!npeel)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n-      return;\n-    }\n-\n-  /* Check for simple loops.  */\n-  desc = get_simple_loop_desc (loop);\n+  struct loop *loop;\n+  bool changed = false;\n \n-  /* Check number of iterations.  */\n-  if (!desc->simple_p\n-      || desc->assumptions\n-      || !desc->const_iter\n-      || desc->infinite)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \";; Unable to prove that the loop iterates constant times\\n\");\n-      return;\n-    }\n+  /* Now decide rest of unrolling.  */\n+  decide_unrolling (flags);\n \n-  if (desc->niter > npeel - 1)\n+  /* Scan the loops, inner ones first.  */\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n-      if (dump_file)\n+      /* And perform the appropriate transformations.  */\n+      switch (loop->lpt_decision.decision)\n \t{\n-\t  fprintf (dump_file,\n-\t\t   \";; Not peeling loop completely, rolls too much (\");\n-\t  fprintf (dump_file, \"%\"PRId64, desc->niter);\n-\t  fprintf (dump_file, \" iterations > %d [maximum peelings])\\n\", npeel);\n+\tcase LPT_UNROLL_CONSTANT:\n+\t  unroll_loop_constant_iterations (loop);\n+\t  changed = true;\n+\t  break;\n+\tcase LPT_UNROLL_RUNTIME:\n+\t  unroll_loop_runtime_iterations (loop);\n+\t  changed = true;\n+\t  break;\n+\tcase LPT_UNROLL_STUPID:\n+\t  unroll_loop_stupid (loop);\n+\t  changed = true;\n+\t  break;\n+\tcase LPT_NONE:\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      return;\n     }\n \n-  /* Success.  */\n-  loop->lpt_decision.decision = LPT_PEEL_COMPLETELY;\n-}\n-\n-/* Peel all iterations of LOOP, remove exit edges and cancel the loop\n-   completely.  The transformation done:\n+    if (changed)\n+      {\n+\tcalculate_dominance_info (CDI_DOMINATORS);\n+\tfix_loop_structure (NULL);\n+      }\n \n-   for (i = 0; i < 4; i++)\n-     body;\n+  iv_analysis_done ();\n+}\n \n-   ==>\n+/* Check whether exit of the LOOP is at the end of loop body.  */\n \n-   i = 0;\n-   body; i++;\n-   body; i++;\n-   body; i++;\n-   body; i++;\n-   */\n-static void\n-peel_loop_completely (struct loop *loop)\n+static bool\n+loop_exit_at_end_p (struct loop *loop)\n {\n-  sbitmap wont_exit;\n-  unsigned HOST_WIDE_INT npeel;\n-  unsigned i;\n-  edge ein;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n-  struct opt_info *opt_info = NULL;\n-\n-  npeel = desc->niter;\n-\n-  if (npeel)\n-    {\n-      bool ok;\n-\n-      wont_exit = sbitmap_alloc (npeel + 1);\n-      bitmap_ones (wont_exit);\n-      bitmap_clear_bit (wont_exit, 0);\n-      if (desc->noloop_assumptions)\n-\tbitmap_clear_bit (wont_exit, 1);\n-\n-      auto_vec<edge> remove_edges;\n-      if (flag_split_ivs_in_unroller)\n-        opt_info = analyze_insns_in_loop (loop);\n-\n-      opt_info_start_duplication (opt_info);\n-      ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t\t  npeel,\n-\t\t\t\t\t  wont_exit, desc->out_edge,\n-\t\t\t\t\t  &remove_edges,\n-\t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ\n-\t\t\t\t\t  | DLTHE_FLAG_COMPLETTE_PEEL\n-\t\t\t\t\t  | (opt_info\n-\t\t\t\t\t     ? DLTHE_RECORD_COPY_NUMBER : 0));\n-      gcc_assert (ok);\n+  rtx_insn *insn;\n \n-      free (wont_exit);\n+  /* We should never have conditional in latch block.  */\n+  gcc_assert (desc->in_edge->dest != loop->header);\n \n-      if (opt_info)\n- \t{\n- \t  apply_opt_in_copies (opt_info, npeel, false, true);\n- \t  free_opt_info (opt_info);\n- \t}\n+  if (desc->in_edge->dest != loop->latch)\n+    return false;\n \n-      /* Remove the exit edges.  */\n-      FOR_EACH_VEC_ELT (remove_edges, i, ein)\n-\tremove_path (ein);\n+  /* Check that the latch is empty.  */\n+  FOR_BB_INSNS (loop->latch, insn)\n+    {\n+      if (INSN_P (insn) && active_insn_p (insn))\n+\treturn false;\n     }\n \n-  ein = desc->in_edge;\n-  free_simple_loop_desc (loop);\n-\n-  /* Now remove the unreachable part of the last iteration and cancel\n-     the loop.  */\n-  remove_path (ein);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Peeled loop completely, %d times\\n\", (int) npeel);\n+  return true;\n }\n \n /* Decide whether to unroll LOOP iterating constant number of times\n@@ -1372,160 +1082,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \t     max_unroll, num_loop_insns (loop));\n }\n \n-/* Decide whether to simply peel LOOP and how much.  */\n-static void\n-decide_peel_simple (struct loop *loop, int flags)\n-{\n-  unsigned npeel;\n-  widest_int iterations;\n-\n-  if (!(flags & UAP_PEEL))\n-    {\n-      /* We were not asked to, just return back silently.  */\n-      return;\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n;; Considering simply peeling loop\\n\");\n-\n-  /* npeel = number of iterations to peel.  */\n-  npeel = PARAM_VALUE (PARAM_MAX_PEELED_INSNS) / loop->ninsns;\n-  if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_PEEL_TIMES))\n-    npeel = PARAM_VALUE (PARAM_MAX_PEEL_TIMES);\n-\n-  /* Skip big loops.  */\n-  if (!npeel)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not considering loop, is too big\\n\");\n-      return;\n-    }\n-\n-  /* Do not simply peel loops with branches inside -- it increases number\n-     of mispredicts.  \n-     Exception is when we do have profile and we however have good chance\n-     to peel proper number of iterations loop will iterate in practice.\n-     TODO: this heuristic needs tunning; while for complette unrolling\n-     the branch inside loop mostly eliminates any improvements, for\n-     peeling it is not the case.  Also a function call inside loop is\n-     also branch from branch prediction POV (and probably better reason\n-     to not unroll/peel).  */\n-  if (num_loop_branches (loop) > 1\n-      && profile_status_for_fn (cfun) != PROFILE_READ)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; Not peeling, contains branches\\n\");\n-      return;\n-    }\n-\n-  /* If we have realistic estimate on number of iterations, use it.  */\n-  if (get_estimated_loop_iterations (loop, &iterations))\n-    {\n-      if (wi::leu_p (npeel, iterations))\n-\t{\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \";; Not peeling loop, rolls too much (\");\n-\t      fprintf (dump_file, \"%\"PRId64,\n-\t\t       (int64_t) (iterations.to_shwi () + 1));\n-\t      fprintf (dump_file, \" iterations > %d [maximum peelings])\\n\",\n-\t\t       npeel);\n-\t    }\n-\t  return;\n-\t}\n-      npeel = iterations.to_shwi () + 1;\n-    }\n-  /* If we have small enough bound on iterations, we can still peel (completely\n-     unroll).  */\n-  else if (get_max_loop_iterations (loop, &iterations)\n-           && wi::ltu_p (iterations, npeel))\n-    npeel = iterations.to_shwi () + 1;\n-  else\n-    {\n-      /* For now we have no good heuristics to decide whether loop peeling\n-         will be effective, so disable it.  */\n-      if (dump_file)\n-\tfprintf (dump_file,\n-\t\t \";; Not peeling loop, no evidence it will be profitable\\n\");\n-      return;\n-    }\n-\n-  /* Success.  */\n-  loop->lpt_decision.decision = LPT_PEEL_SIMPLE;\n-  loop->lpt_decision.times = npeel;\n-}\n-\n-/* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation does this:\n-\n-   while (cond)\n-     body;\n-\n-   ==>  (LOOP->LPT_DECISION.TIMES == 3)\n-\n-   if (!cond) goto end;\n-   body;\n-   if (!cond) goto end;\n-   body;\n-   if (!cond) goto end;\n-   body;\n-   while (cond)\n-     body;\n-   end: ;\n-   */\n-static void\n-peel_loop_simple (struct loop *loop)\n-{\n-  sbitmap wont_exit;\n-  unsigned npeel = loop->lpt_decision.times;\n-  struct niter_desc *desc = get_simple_loop_desc (loop);\n-  struct opt_info *opt_info = NULL;\n-  bool ok;\n-\n-  if (flag_split_ivs_in_unroller && npeel > 1)\n-    opt_info = analyze_insns_in_loop (loop);\n-\n-  wont_exit = sbitmap_alloc (npeel + 1);\n-  bitmap_clear (wont_exit);\n-\n-  opt_info_start_duplication (opt_info);\n-\n-  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t      npeel, wont_exit, NULL,\n-\t\t\t\t      NULL, DLTHE_FLAG_UPDATE_FREQ\n-\t\t\t\t      | (opt_info\n-\t\t\t\t\t ? DLTHE_RECORD_COPY_NUMBER\n-\t\t\t\t\t   : 0));\n-  gcc_assert (ok);\n-\n-  free (wont_exit);\n-\n-  if (opt_info)\n-    {\n-      apply_opt_in_copies (opt_info, npeel, false, false);\n-      free_opt_info (opt_info);\n-    }\n-\n-  if (desc->simple_p)\n-    {\n-      if (desc->const_iter)\n-\t{\n-\t  desc->niter -= npeel;\n-\t  desc->niter_expr = GEN_INT (desc->niter);\n-\t  desc->noloop_assumptions = NULL_RTX;\n-\t}\n-      else\n-\t{\n-\t  /* We cannot just update niter_expr, as its value might be clobbered\n-\t     inside loop.  We could handle this by counting the number into\n-\t     temporary just like we do in runtime unrolling, but it does not\n-\t     seem worthwhile.  */\n-\t  free_simple_loop_desc (loop);\n-\t}\n-    }\n-  if (dump_file)\n-    fprintf (dump_file, \";; Peeling loop %d times\\n\", npeel);\n-}\n-\n /* Decide whether to unroll LOOP stupidly and how much.  */\n static void\n decide_unroll_stupid (struct loop *loop, int flags)"}, {"sha": "3dca63584caa0fa014a4e1346ebdb7531302cabb", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -359,7 +359,7 @@ along with GCC; see the file COPYING3.  If not see\n       PUSH_INSERT_PASSES_WITHIN (pass_loop2)\n \t  NEXT_PASS (pass_rtl_loop_init);\n \t  NEXT_PASS (pass_rtl_move_loop_invariants);\n-\t  NEXT_PASS (pass_rtl_unroll_and_peel_loops);\n+\t  NEXT_PASS (pass_rtl_unroll_loops);\n \t  NEXT_PASS (pass_rtl_doloop);\n \t  NEXT_PASS (pass_rtl_loop_done);\n \t  TERMINATE_PASS_LIST ()"}, {"sha": "fe795d6fd479ec2331bc6892829a5c685b98212a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,3 +1,12 @@\n+2014-10-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-prof/peel-1.c: Update.\n+\t* gcc.dg/tree-prof/unroll-1.c: Update.\n+\t* gcc.dg/gcc.dg/unroll_1.c: Update.\n+\t* gcc.dg/gcc.dg/unroll_2.c: Update.\n+\t* gcc.dg/gcc.dg/unroll_3.c: Update.\n+\t* gcc.dg/gcc.dg/unroll_4.c: Update.\n+\n 2014-10-14  DJ Delorie  <dj@redhat.com>\n \n \t* g++.dg/abi/mangle64.C: New."}, {"sha": "bcb89a456df0d4bde5ed8c4297734cb0a71ed72d", "filename": "gcc/testsuite/gcc.dg/tree-prof/peel-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpeel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpeel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpeel-1.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O3 -fdump-rtl-loop2_unroll -fno-unroll-loops -fpeel-loops\" } */\n+/* { dg-options \"-O3 -fdump-tree-cunroll-details -fno-unroll-loops -fpeel-loops\" } */\n void abort();\n \n int a[1000];"}, {"sha": "7c9495d0261e0a9df430697696d7664e923e94ac", "filename": "gcc/testsuite/gcc.dg/unroll_1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_1.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-rtl-loop2_unroll=stderr -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunroll -fdisable-tree-cunrolli -fenable-rtl-loop2 -fenable-rtl-loop2_unroll\" } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details=stderr -fno-peel-loops -fno-tree-vrp  -fdisable-tree-cunroll -fenable-tree-cunrolli\" } */\n \n unsigned a[100], b[100];\n inline void bar()\n@@ -11,7 +11,7 @@ int foo(void)\n {\n   int i;\n   bar();\n-  for (i = 0; i < 2; i++) /* { dg-message \"note: loop turned into non-loop; it never loops\" } */\n+  for (i = 0; i < 2; i++) /* { dg-message \"note: loop with 3 iterations completely unrolled\" } */\n   {\n      a[i]= b[i] + 1;\n   }\n@@ -21,7 +21,7 @@ int foo(void)\n int foo2(void)\n {\n   int i;\n-  for (i = 0; i < 2; i++) /* { dg-message \"note: loop turned into non-loop; it never loops\" } */\n+  for (i = 0; i < 2; i++) /* { dg-message \"note: loop with 3 iterations completely unrolled\" } */\n   {\n      a[i]= b[i] + 1;\n   }"}, {"sha": "d3b9637fa6a9d02eba1a443c66472c34e246f5c4", "filename": "gcc/testsuite/gcc.dg/unroll_2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_2.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-rtl-loop2_unroll -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunroll=foo -fdisable-tree-cunrolli=foo -fenable-rtl-loop2_unroll\" } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunrolli=foo -fenable-tree-cunrolli=foo\" } */\n \n unsigned a[100], b[100];\n inline void bar()\n@@ -28,5 +28,5 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"loop turned into non-loop; it never loops\" 1 \"loop2_unroll\" } } */\n-/* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunrolli\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "01378618ad492eb3e8db2c59f893b4cfbc8d84db", "filename": "gcc/testsuite/gcc.dg/unroll_3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_3.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-rtl-loop2_unroll -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunroll -fdisable-tree-cunrolli -fenable-rtl-loop2_unroll=foo\" } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunroll -fenable-tree-cunrolli=foo -fdisable-tree-cunrolli=foo2\" } */\n \n unsigned a[100], b[100];\n inline void bar()\n@@ -28,5 +28,5 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"loop turned into non-loop; it never loops\" 1 \"loop2_unroll\" } } */\n-/* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunrolli\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "679d8f916b62d19f0db033d766530220d7e4681f", "filename": "gcc/testsuite/gcc.dg/unroll_4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll_4.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-rtl-loop2_unroll -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunroll -fdisable-tree-cunrolli -fenable-rtl-loop2_unroll=foo2\" } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details -fno-peel-loops -fno-tree-vrp -fdisable-tree-cunroll -fenable-tree-cunrolli=foo2 -fdisable-tree-cunrolli=foo\" } */\n \n unsigned a[100], b[100];\n inline void bar()\n@@ -28,5 +28,5 @@ int foo2(void)\n   return 1;\n }\n \n-/* { dg-final { scan-rtl-dump-times \"loop turned into non-loop; it never loops\" 1 \"loop2_unroll\" } } */\n-/* { dg-final { cleanup-rtl-dump \"loop2_unroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 3 iterations completely unrolled\" 1 \"cunrolli\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "bfccf9820faa4101a9c814057d2192f288248b07", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -504,7 +504,7 @@ extern rtl_opt_pass *make_pass_outof_cfg_layout_mode (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_loop2 (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_rtl_loop_init (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_rtl_move_loop_invariants (gcc::context *ctxt);\n-extern rtl_opt_pass *make_pass_rtl_unroll_and_peel_loops (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_rtl_unroll_loops (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_rtl_doloop (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_rtl_loop_done (gcc::context *ctxt);\n "}, {"sha": "136b235a205f2c3314c127399b391afb8a2ad863", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 140, "deletions": 4, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8934be78727eb998f6bb04c001f3dda6cf1017c/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=f8934be78727eb998f6bb04c001f3dda6cf1017c", "patch": "@@ -28,9 +28,12 @@ along with GCC; see the file COPYING3.  If not see\n    variables.  In that case the created optimization possibilities are likely\n    to pay up.\n \n-   Additionally in case we detect that it is beneficial to unroll the\n-   loop completely, we do it right here to expose the optimization\n-   possibilities to the following passes.  */\n+   We also perform\n+     - complette unrolling (or peeling) when the loops is rolling few enough\n+       times\n+     - simple peeling (i.e. copying few initial iterations prior the loop)\n+       when number of iteration estimate is known (typically by the profile\n+       info).  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -657,11 +660,12 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t\t    HOST_WIDE_INT maxiter,\n \t\t\t    location_t locus)\n {\n-  unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n+  unsigned HOST_WIDE_INT n_unroll = 0, ninsns, max_unroll, unr_insns;\n   gimple cond;\n   struct loop_size size;\n   bool n_unroll_found = false;\n   edge edge_to_cancel = NULL;\n+  int report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_RTL | TDF_DETAILS;\n \n   /* See if we proved number of iterations to be low constant.\n \n@@ -821,6 +825,8 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t     loop->num);\n \t  return false;\n \t}\n+      dump_printf_loc (report_flags, locus,\n+                       \"loop turned into non-loop; it never loops.\\n\");\n \n       initialize_original_copy_tables ();\n       wont_exit = sbitmap_alloc (n_unroll + 1);\n@@ -902,6 +908,133 @@ try_unroll_loop_completely (struct loop *loop,\n   return true;\n }\n \n+/* Return number of instructions after peeling.  */\n+static unsigned HOST_WIDE_INT\n+estimated_peeled_sequence_size (struct loop_size *size,\n+\t\t\t        unsigned HOST_WIDE_INT npeel)\n+{\n+  return MAX (npeel * (HOST_WIDE_INT) (size->overall\n+\t\t\t     \t       - size->eliminated_by_peeling), 1);\n+}\n+\n+/* If the loop is expected to iterate N times and is\n+   small enough, duplicate the loop body N+1 times before\n+   the loop itself.  This way the hot path will never\n+   enter the loop.  \n+   Parameters are the same as for try_unroll_loops_completely */\n+\n+static bool\n+try_peel_loop (struct loop *loop,\n+\t       edge exit, tree niter,\n+\t       HOST_WIDE_INT maxiter)\n+{\n+  int npeel;\n+  struct loop_size size;\n+  int peeled_size;\n+  sbitmap wont_exit;\n+  unsigned i;\n+  vec<edge> to_remove = vNULL;\n+  edge e;\n+\n+  /* If the iteration bound is known and large, then we can safely eliminate\n+     the check in peeled copies.  */\n+  if (TREE_CODE (niter) != INTEGER_CST)\n+    exit = NULL;\n+\n+  if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0)\n+    return false;\n+\n+  /* Peel only innermost loops.  */\n+  if (loop->inner)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: outer loop\\n\");\n+      return false;\n+    }\n+\n+  if (!optimize_loop_for_speed_p (loop))\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: cold loop\\n\");\n+      return false;\n+    }\n+\n+  /* Check if there is an estimate on the number of iterations.  */\n+  npeel = estimated_loop_iterations_int (loop);\n+  if (npeel < 0)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: number of iterations is not \"\n+\t         \"estimated\\n\");\n+      return false;\n+    }\n+  if (maxiter >= 0 && maxiter <= npeel)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: upper bound is known so can \"\n+\t\t \"unroll complettely\\n\");\n+      return false;\n+    }\n+\n+  /* We want to peel estimated number of iterations + 1 (so we never\n+     enter the loop on quick path).  Check against PARAM_MAX_PEEL_TIMES\n+     and be sure to avoid overflows.  */\n+  if (npeel > PARAM_VALUE (PARAM_MAX_PEEL_TIMES) - 1)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: rolls too much \"\n+\t\t \"(%i + 1 > --param max-peel-times)\\n\", npeel);\n+      return false;\n+    }\n+  npeel++;\n+\n+  /* Check peeled loops size.  */\n+  tree_estimate_loop_size (loop, exit, NULL, &size,\n+\t\t\t   PARAM_VALUE (PARAM_MAX_PEELED_INSNS));\n+  if ((peeled_size = estimated_peeled_sequence_size (&size, npeel))\n+      > PARAM_VALUE (PARAM_MAX_PEELED_INSNS))\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"Not peeling: peeled sequence size is too large \"\n+\t\t \"(%i insns > --param max-peel-insns)\", peeled_size);\n+      return false;\n+    }\n+\n+  /* Duplicate possibly eliminating the exits.  */\n+  initialize_original_copy_tables ();\n+  wont_exit = sbitmap_alloc (npeel + 1);\n+  bitmap_ones (wont_exit);\n+  bitmap_clear_bit (wont_exit, 0);\n+  if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t     npeel, wont_exit,\n+\t\t\t\t\t     exit, &to_remove,\n+\t\t\t\t\t     DLTHE_FLAG_UPDATE_FREQ\n+\t\t\t\t\t     | DLTHE_FLAG_COMPLETTE_PEEL))\n+    {\n+      free_original_copy_tables ();\n+      free (wont_exit);\n+      return false;\n+    }\n+  FOR_EACH_VEC_ELT (to_remove, i, e)\n+    {\n+      bool ok = remove_path (e);\n+      gcc_assert (ok);\n+    }\n+  free (wont_exit);\n+  free_original_copy_tables ();\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Peeled loop %d, %i times.\\n\",\n+\t       loop->num, npeel);\n+    }\n+  if (loop->any_upper_bound)\n+    loop->nb_iterations_upper_bound -= npeel;\n+  loop->nb_iterations_estimate = 0;\n+  /* Make sure to mark loop cold so we do not try to peel it more.  */\n+  scale_loop_profile (loop, 1, 0);\n+  loop->header->count = 0;\n+  return true;\n+}\n /* Adds a canonical induction variable to LOOP if suitable.\n    CREATE_IV is true if we may create a new iv.  UL determines\n    which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try\n@@ -981,6 +1114,9 @@ canonicalize_loop_induction_variables (struct loop *loop,\n       && exit && just_once_each_iteration_p (loop, exit->src))\n     create_canonical_iv (loop, exit, niter);\n \n+  if (ul == UL_ALL)\n+    modified |= try_peel_loop (loop, exit, niter, maxiter);\n+\n   return modified;\n }\n "}]}