{"sha": "feebc22ba934f154aad6d8cad6cce0adf1d4610e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVlYmMyMmJhOTM0ZjE1NGFhZDZkOGNhZDZjY2UwYWRmMWQ0NjEwZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-13T14:27:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-15T10:35:54Z"}, "message": "Maintain (mis-)alignment info in the first element of a group\n\nThis changes us to maintain and compute (mis-)alignment info for\nthe first element of a group only rather than for each DR when\ndoing interleaving and for the earliest, first, or first in the SLP\nnode (or any pair or all three of those) when SLP vectorizing.\n\nFor this to work out the easiest way I have changed the accessors\nDR_MISALIGNMENT and DR_TARGET_ALIGNMENT to do the indirection to\nthe first element rather than adjusting all callers.\n\n2021-09-13  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (dr_misalignment): Move out of line.\n\t(dr_target_alignment): New.\n\t(DR_TARGET_ALIGNMENT): Wrap dr_target_alignment.\n\t(set_dr_target_alignment): New.\n\t(SET_DR_TARGET_ALIGNMENT): Wrap set_dr_target_alignment.\n\t* tree-vect-data-refs.c (dr_misalignment): Compute and\n\treturn the group members misalignment.\n\t(vect_compute_data_ref_alignment): Use SET_DR_TARGET_ALIGNMENT.\n\t(vect_analyze_data_refs_alignment): Compute alignment only\n\tfor the first element of a DR group.\n\t(vect_slp_analyze_node_alignment): Likewise.", "tree": {"sha": "30d80a51f6522cdb02d9aa0e3ff5cc1d54813076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30d80a51f6522cdb02d9aa0e3ff5cc1d54813076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feebc22ba934f154aad6d8cad6cce0adf1d4610e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feebc22ba934f154aad6d8cad6cce0adf1d4610e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feebc22ba934f154aad6d8cad6cce0adf1d4610e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feebc22ba934f154aad6d8cad6cce0adf1d4610e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4d3643361df1145b34265c398e901498548c6e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d3643361df1145b34265c398e901498548c6e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d3643361df1145b34265c398e901498548c6e6"}], "stats": {"total": 92, "additions": 60, "deletions": 32}, "files": [{"sha": "967d43726db812810e132613d7d5f294b09e8484", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feebc22ba934f154aad6d8cad6cce0adf1d4610e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feebc22ba934f154aad6d8cad6cce0adf1d4610e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=feebc22ba934f154aad6d8cad6cce0adf1d4610e", "patch": "@@ -887,6 +887,39 @@ vect_slp_analyze_instance_dependence (vec_info *vinfo, slp_instance instance)\n   return res;\n }\n \n+/* Return the misalignment of DR_INFO.  */\n+\n+int\n+dr_misalignment (dr_vec_info *dr_info)\n+{\n+  if (STMT_VINFO_GROUPED_ACCESS (dr_info->stmt))\n+    {\n+      dr_vec_info *first_dr\n+\t= STMT_VINFO_DR_INFO (DR_GROUP_FIRST_ELEMENT (dr_info->stmt));\n+      int misalign = first_dr->misalignment;\n+      gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n+      if (misalign == DR_MISALIGNMENT_UNKNOWN)\n+\treturn misalign;\n+      /* vect_analyze_data_ref_accesses guarantees that DR_INIT are\n+\t INTEGER_CSTs and the first element in the group has the lowest\n+\t address.  Likewise vect_compute_data_ref_alignment will\n+\t have ensured that target_alignment is constant and otherwise\n+\t set misalign to DR_MISALIGNMENT_UNKNOWN.  */\n+      HOST_WIDE_INT diff = (TREE_INT_CST_LOW (DR_INIT (dr_info->dr))\n+\t\t\t    - TREE_INT_CST_LOW (DR_INIT (first_dr->dr)));\n+      gcc_assert (diff >= 0);\n+      unsigned HOST_WIDE_INT target_alignment_c\n+\t= first_dr->target_alignment.to_constant ();\n+      return (misalign + diff) % target_alignment_c;\n+    }\n+  else\n+    {\n+      int misalign = dr_info->misalignment;\n+      gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n+      return misalign;\n+    }\n+}\n+\n /* Record the base alignment guarantee given by DRB, which occurs\n    in STMT_INFO.  */\n \n@@ -992,7 +1025,7 @@ vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n \n   poly_uint64 vector_alignment\n     = exact_div (vect_calculate_target_alignment (dr_info), BITS_PER_UNIT);\n-  DR_TARGET_ALIGNMENT (dr_info) = vector_alignment;\n+  SET_DR_TARGET_ALIGNMENT (dr_info, vector_alignment);\n \n   /* If the main loop has peeled for alignment we have no way of knowing\n      whether the data accesses in the epilogues are aligned.  We can't at\n@@ -2408,7 +2441,12 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n     {\n       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n       if (STMT_VINFO_VECTORIZABLE (dr_info->stmt))\n-\tvect_compute_data_ref_alignment (loop_vinfo, dr_info);\n+\t{\n+\t  if (STMT_VINFO_GROUPED_ACCESS (dr_info->stmt)\n+\t      && DR_GROUP_FIRST_ELEMENT (dr_info->stmt) != dr_info->stmt)\n+\t    continue;\n+\t  vect_compute_data_ref_alignment (loop_vinfo, dr_info);\n+\t}\n     }\n \n   return opt_result::success ();\n@@ -2420,13 +2458,9 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n static bool\n vect_slp_analyze_node_alignment (vec_info *vinfo, slp_tree node)\n {\n-  /* We vectorize from the first scalar stmt in the node unless\n-     the node is permuted in which case we start from the first\n-     element in the group.  */\n+  /* Alignment is maintained in the first element of the group.  */\n   stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-  dr_vec_info *first_dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n-  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-    first_stmt_info = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n+  first_stmt_info = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n \n   /* We need to commit to a vector type for the group now.  */\n   if (is_a <bb_vec_info> (vinfo)\n@@ -2440,22 +2474,8 @@ vect_slp_analyze_node_alignment (vec_info *vinfo, slp_tree node)\n     }\n \n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n-  vect_compute_data_ref_alignment (vinfo, dr_info);\n-  /* In several places we need alignment of the first element anyway.  */\n-  if (dr_info != first_dr_info)\n-    vect_compute_data_ref_alignment (vinfo, first_dr_info);\n-\n-  /* For creating the data-ref pointer we need alignment of the\n-     first element as well.  */\n-  first_stmt_info\n-    = vect_stmt_to_vectorize (vect_find_first_scalar_stmt_in_slp (node));\n-  if (first_stmt_info != SLP_TREE_SCALAR_STMTS (node)[0])\n-    {\n-      first_dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n-      if (dr_info != first_dr_info)\n-\tvect_compute_data_ref_alignment (vinfo, first_dr_info);\n-    }\n-\n+  if (dr_info->misalignment == DR_MISALIGNMENT_UNINITIALIZED)\n+    vect_compute_data_ref_alignment (vinfo, dr_info);\n   return true;\n }\n "}, {"sha": "c4c5678e7f1abafc25c465319dbacf3ef50f0ae9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feebc22ba934f154aad6d8cad6cce0adf1d4610e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feebc22ba934f154aad6d8cad6cce0adf1d4610e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=feebc22ba934f154aad6d8cad6cce0adf1d4610e", "patch": "@@ -1606,21 +1606,29 @@ set_dr_misalignment (dr_vec_info *dr_info, int val)\n   dr_info->misalignment = val;\n }\n \n-inline int\n-dr_misalignment (dr_vec_info *dr_info)\n-{\n-  int misalign = dr_info->misalignment;\n-  gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n-  return misalign;\n-}\n+extern int dr_misalignment (dr_vec_info *dr_info);\n \n /* Reflects actual alignment of first access in the vectorized loop,\n    taking into account peeling/versioning if applied.  */\n #define DR_MISALIGNMENT(DR) dr_misalignment (DR)\n #define SET_DR_MISALIGNMENT(DR, VAL) set_dr_misalignment (DR, VAL)\n \n /* Only defined once DR_MISALIGNMENT is defined.  */\n-#define DR_TARGET_ALIGNMENT(DR) ((DR)->target_alignment)\n+static inline const poly_uint64\n+dr_target_alignment (dr_vec_info *dr_info)\n+{\n+  if (STMT_VINFO_GROUPED_ACCESS (dr_info->stmt))\n+    dr_info = STMT_VINFO_DR_INFO (DR_GROUP_FIRST_ELEMENT (dr_info->stmt));\n+  return dr_info->target_alignment;\n+}\n+#define DR_TARGET_ALIGNMENT(DR) dr_target_alignment (DR)\n+\n+static inline void\n+set_dr_target_alignment (dr_vec_info *dr_info, poly_uint64 val)\n+{\n+  dr_info->target_alignment = val;\n+}\n+#define SET_DR_TARGET_ALIGNMENT(DR, VAL) set_dr_target_alignment (DR, VAL)\n \n /* Return true if data access DR_INFO is aligned to its target alignment\n    (which may be less than a full vector).  */"}]}