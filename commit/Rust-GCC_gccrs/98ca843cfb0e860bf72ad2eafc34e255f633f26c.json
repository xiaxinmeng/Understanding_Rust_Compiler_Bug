{"sha": "98ca843cfb0e860bf72ad2eafc34e255f633f26c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjYTg0M2NmYjBlODYwYmY3MmFkMmVhZmMzNGUyNTVmNjMzZjI2Yw==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2004-07-12T19:10:03Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-12T19:10:03Z"}, "message": "parser.c (cp_parser_class_head): Remove unused variable.\n\n2004-07-12  Eric Christopher  <echristo@redhat.com>\n\n        * parser.c (cp_parser_class_head): Remove unused variable.\n\nFrom-SVN: r84571", "tree": {"sha": "64786c2927961b1ed3026048254ae592ba8227df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64786c2927961b1ed3026048254ae592ba8227df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98ca843cfb0e860bf72ad2eafc34e255f633f26c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ca843cfb0e860bf72ad2eafc34e255f633f26c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ca843cfb0e860bf72ad2eafc34e255f633f26c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ca843cfb0e860bf72ad2eafc34e255f633f26c/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd4e150058df2a052cba522bff881d4ba618ab7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4e150058df2a052cba522bff881d4ba618ab7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd4e150058df2a052cba522bff881d4ba618ab7a"}], "stats": {"total": 163, "additions": 83, "deletions": 80}, "files": [{"sha": "988c71fed5cf099e942dc88e28c6755885a3532a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ca843cfb0e860bf72ad2eafc34e255f633f26c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ca843cfb0e860bf72ad2eafc34e255f633f26c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=98ca843cfb0e860bf72ad2eafc34e255f633f26c", "patch": "@@ -1,3 +1,7 @@\n+2004-07-12  Eric Christopher  <echristo@redhat.com>\n+\n+\t* parser.c (cp_parser_class_head): Remove unused variable.\n+\n 2004-07-12  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \t* decl.c (grok_op_properties): Reject [de-]allocation functions\n@@ -9,7 +13,7 @@\n \t* decl.c (xref_basetypes): Use make_tree_binfo directly.\n \t* tree.h (copy_base_binfos): Likewise.\n \t(make_binfo): Remove.\n-\t\n+\n \t* call.c (build_user_type_conversion_1, build_new_op,\n \tcheck_constructor_callable, build_temp,\n \tperform_direct_initialization_of_possible): Pass type directly to"}, {"sha": "53e5a936a7d7f2dab85aadd0440d9a09be1277fc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 78, "deletions": 79, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ca843cfb0e860bf72ad2eafc34e255f633f26c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ca843cfb0e860bf72ad2eafc34e255f633f26c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=98ca843cfb0e860bf72ad2eafc34e255f633f26c", "patch": "@@ -1015,19 +1015,19 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n    Other parts of the front end that need to create entities (like\n    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n \n-static cp_declarator *make_id_declarator \n+static cp_declarator *make_id_declarator\n   (tree);\n-static cp_declarator *make_call_declarator\t\n+static cp_declarator *make_call_declarator\n   (cp_declarator *, cp_parameter_declarator *, cp_cv_quals, tree);\n-static cp_declarator *make_array_declarator\t\n+static cp_declarator *make_array_declarator\n   (cp_declarator *, tree);\n-static cp_declarator *make_pointer_declarator\t\n+static cp_declarator *make_pointer_declarator\n   (cp_cv_quals, cp_declarator *);\n-static cp_declarator *make_reference_declarator\t\n+static cp_declarator *make_reference_declarator\n   (cp_cv_quals, cp_declarator *);\n-static cp_parameter_declarator *make_parameter_declarator \n+static cp_parameter_declarator *make_parameter_declarator\n   (cp_decl_specifier_seq *, cp_declarator *, tree);\n-static cp_declarator *make_ptrmem_declarator\t\n+static cp_declarator *make_ptrmem_declarator\n   (cp_cv_quals, tree, cp_declarator *);\n \n cp_declarator *cp_error_declarator;\n@@ -1066,7 +1066,7 @@ cp_declarator *\n make_id_declarator (tree id)\n {\n   cp_declarator *declarator;\n-  \n+\n   declarator = make_declarator (cdk_id);\n   declarator->u.id.name = id;\n   declarator->u.id.sfk = sfk_none;\n@@ -1129,7 +1129,7 @@ make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,\n    indicates what exceptions can be thrown.  */\n \n cp_declarator *\n-make_call_declarator (cp_declarator *target, \n+make_call_declarator (cp_declarator *target,\n \t\t      cp_parameter_declarator *parms,\n \t\t      cp_cv_quals cv_qualifiers,\n                       tree exception_specification)\n@@ -1166,13 +1166,13 @@ cp_parameter_declarator *no_parameters;\n    DECLARATOR and DEFAULT_ARGUMENT.  */\n \n cp_parameter_declarator *\n-make_parameter_declarator (cp_decl_specifier_seq *decl_specifiers, \n+make_parameter_declarator (cp_decl_specifier_seq *decl_specifiers,\n \t\t\t   cp_declarator *declarator,\n \t\t\t   tree default_argument)\n {\n   cp_parameter_declarator *parameter;\n \n-  parameter = ((cp_parameter_declarator *) \n+  parameter = ((cp_parameter_declarator *)\n \t       alloc_declarator (sizeof (cp_parameter_declarator)));\n   parameter->next = NULL;\n   if (decl_specifiers)\n@@ -1650,7 +1650,7 @@ static tree cp_parser_storage_class_specifier_opt\n static tree cp_parser_function_specifier_opt\n   (cp_parser *, cp_decl_specifier_seq *);\n static tree cp_parser_type_specifier\n-  (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, bool, \n+  (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, bool,\n    int *, bool *);\n static tree cp_parser_simple_type_specifier\n   (cp_parser *, cp_decl_specifier_seq *, cp_parser_flags);\n@@ -1874,7 +1874,7 @@ static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n static void cp_parser_set_storage_class\n   (cp_decl_specifier_seq *, cp_storage_class);\n-static void cp_parser_set_decl_spec_type \n+static void cp_parser_set_decl_spec_type\n   (cp_decl_specifier_seq *, tree, bool);\n static bool cp_parser_friend_p\n   (const cp_decl_specifier_seq *);\n@@ -2623,7 +2623,7 @@ cp_parser_translation_unit (cp_parser* parser)\n   static void *declarator_obstack_base;\n \n   bool success;\n-  \n+\n   /* Create the declarator obstack, if necessary.  */\n   if (!cp_error_declarator)\n     {\n@@ -2645,7 +2645,7 @@ cp_parser_translation_unit (cp_parser* parser)\n \t{\n \t  /* Consume the EOF token.  */\n \t  cp_parser_require (parser, CPP_EOF, \"end-of-file\");\n-\t  \n+\n \t  /* Finish up.  */\n \t  finish_translation_unit ();\n \n@@ -3764,7 +3764,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tif (parser->integral_constant_expression_p\n \t    && !dependent_type_p (type)\n \t    && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n-\t    && (cp_parser_non_integral_constant_expression \n+\t    && (cp_parser_non_integral_constant_expression\n \t\t(parser,\n \t\t \"a cast to a type other than an integral or \"\n \t\t \"enumeration type\")))\n@@ -3836,7 +3836,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \t  }\n \t/* `typeid' may not appear in an integral constant expression.  */\n-\tif (cp_parser_non_integral_constant_expression(parser, \n+\tif (cp_parser_non_integral_constant_expression(parser,\n \t\t\t\t\t\t       \"`typeid' operator\"))\n \t  return error_mark_node;\n \t/* Restore the saved message.  */\n@@ -3881,7 +3881,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t/* Create a TYPENAME_TYPE to represent the type to which the\n \t   functional cast is being performed.  */\n \telse\n-\t  type = make_typename_type (parser->scope, id, \n+\t  type = make_typename_type (parser->scope, id,\n \t\t\t\t     /*complain=*/1);\n \n \tpostfix_expression = cp_parser_functional_cast (parser, type);\n@@ -4114,7 +4114,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t     postfix-expression . pseudo-destructor-name\n \t     postfix-expression -> template [opt] id-expression\n \t     postfix-expression -> pseudo-destructor-name */\n-\t\n+\n \t  /* Consume the `.' or `->' operator.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \n@@ -4308,7 +4308,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t  parser->object_scope = NULL_TREE;\n \t}\n       if (scope && name && BASELINK_P (name))\n-\tadjust_result_of_qualified_name_lookup \n+\tadjust_result_of_qualified_name_lookup\n \t  (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n       postfix_expression\n \t= finish_class_member_access_expr (postfix_expression, name);\n@@ -4334,7 +4334,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   /* Outside of offsetof, these operators may not appear in\n      constant-expressions.  */\n   if (!for_offsetof\n-      && (cp_parser_non_integral_constant_expression \n+      && (cp_parser_non_integral_constant_expression\n \t  (parser, token_type == CPP_DEREF ? \"'->'\" : \"`.'\")))\n     postfix_expression = error_mark_node;\n \n@@ -4723,7 +4723,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  abort ();\n \t}\n \n-      if (non_constant_p \n+      if (non_constant_p\n \t  && cp_parser_non_integral_constant_expression (parser,\n \t\t\t\t\t\t\t non_constant_p))\n \texpression = error_mark_node;\n@@ -4808,7 +4808,7 @@ cp_parser_new_expression (cp_parser* parser)\n       type = cp_parser_type_id (parser);\n       /* Look for the closing `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-      /* There should not be a direct-new-declarator in this production, \n+      /* There should not be a direct-new-declarator in this production,\n          but GCC used to allowed this, so we check and emit a sensible error\n \t message for this case.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n@@ -4902,23 +4902,23 @@ cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n       outer_declarator = declarator;\n       declarator = declarator->declarator;\n     }\n-  while (declarator \n+  while (declarator\n \t && declarator->kind == cdk_array\n \t && declarator->declarator\n \t && declarator->declarator->kind == cdk_array)\n     {\n       outer_declarator = declarator;\n       declarator = declarator->declarator;\n     }\n-  \n+\n   if (declarator && declarator->kind == cdk_array)\n     {\n       *nelts = declarator->u.array.bounds;\n       if (*nelts == error_mark_node)\n \t*nelts = integer_one_node;\n       else if (!processing_template_decl)\n \t{\n-\t  if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, *nelts, \n+\t  if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, *nelts,\n \t\t\t\t\t   false))\n \t    pedwarn (\"size in array new must have integral type\");\n \t  *nelts = save_expr (cp_convert (sizetype, *nelts));\n@@ -5210,7 +5210,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \t  if (parser->integral_constant_expression_p\n \t      && !dependent_type_p (type)\n \t      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n-\t      && (cp_parser_non_integral_constant_expression \n+\t      && (cp_parser_non_integral_constant_expression\n \t\t  (parser,\n \t\t   \"a cast to a type other than an integral or \"\n \t\t   \"enumeration type\")))\n@@ -6443,7 +6443,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tfinish_for_expr (expression, statement);\n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-\t\n+\n \t/* Parse the body of the for-statement.  */\n \tparser->in_iteration_statement_p = true;\n \tcp_parser_already_scoped_statement (parser);\n@@ -6953,7 +6953,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n   /* In a block scope, a valid declaration must always have a\n      decl-specifier-seq.  By not trying to parse declarators, we can\n      resolve the declaration/expression ambiguity more quickly.  */\n-  if (!function_definition_allowed_p \n+  if (!function_definition_allowed_p\n       && !decl_specifiers.any_specifiers_p)\n     {\n       cp_parser_error (parser, \"expected declaration\");\n@@ -7094,7 +7094,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n         (i.e., a type declaration)\n      2: one of the decl-specifiers is an enum-specifier or a\n         class-specifier (i.e., a type definition)\n-   \n+\n    */\n \n static void\n@@ -7124,7 +7124,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       if (token->keyword == RID_ATTRIBUTE)\n \t{\n \t  /* Parse the attributes.  */\n-\t  decl_specs->attributes \n+\t  decl_specs->attributes\n \t    = chainon (decl_specs->attributes,\n \t\t       cp_parser_attributes_opt (parser));\n \t  continue;\n@@ -7225,10 +7225,10 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \n       /* Constructors are a special case.  The `S' in `S()' is not a\n \t decl-specifier; it is the beginning of the declarator.  */\n-      constructor_p \n+      constructor_p\n \t= (!found_decl_spec\n \t   && constructor_possible_p\n-\t   && (cp_parser_constructor_declarator_p \n+\t   && (cp_parser_constructor_declarator_p\n \t       (parser, decl_specs->specs[(int) ds_friend] != 0)));\n \n       /* If we don't have a DECL_SPEC yet, then we must be looking at\n@@ -7570,10 +7570,10 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n   if (cp_parser_parse_definitely (parser))\n     {\n       cp_declarator *declarator;\n-      \n+\n       /* Parse another optional declarator.  */\n       declarator = cp_parser_conversion_declarator_opt (parser);\n-      \n+\n       /* Create the representation of the declarator.  */\n       if (class_type)\n \tdeclarator = make_ptrmem_declarator (cv_quals, class_type,\n@@ -7582,7 +7582,7 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n \tdeclarator = make_pointer_declarator (cv_quals, declarator);\n       else\n \tdeclarator = make_reference_declarator (cv_quals, declarator);\n-      \n+\n       return declarator;\n    }\n \n@@ -8193,11 +8193,11 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n   parameter_declarator\n      = cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,\n \t\t\t\t\t/*parenthesized_p=*/NULL);\n-  return (build_tree_list \n+  return (build_tree_list\n \t  (parameter_declarator->default_argument,\n \t   grokdeclarator (parameter_declarator->declarator,\n \t\t\t   &parameter_declarator->decl_specifiers,\n-\t\t\t   PARM, /*initialized=*/0, \n+\t\t\t   PARM, /*initialized=*/0,\n \t\t\t   /*attrlist=*/NULL)));\n }\n \n@@ -8690,7 +8690,7 @@ cp_parser_template_name (cp_parser* parser,\n \t (and must) do name-lookup normally.  */\n       if (template_keyword_p\n \t  && (!parser->scope\n-\t      || (TYPE_P (parser->scope) \n+\t      || (TYPE_P (parser->scope)\n \t\t  && dependent_type_p (parser->scope))))\n \treturn identifier;\n     }\n@@ -9045,7 +9045,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       extension_specifier\n \t= cp_parser_storage_class_specifier_opt (parser);\n       if (!extension_specifier)\n-\textension_specifier \n+\textension_specifier\n \t  = cp_parser_function_specifier_opt (parser,\n \t\t\t\t\t      /*decl_specs=*/NULL);\n     }\n@@ -9252,8 +9252,8 @@ cp_parser_type_specifier (cp_parser* parser,\n \n     case RID_TYPENAME:\n       /* Look for an elaborated-type-specifier.  */\n-      type_spec \n-\t= (cp_parser_elaborated_type_specifier \n+      type_spec\n+\t= (cp_parser_elaborated_type_specifier\n \t   (parser,\n \t    decl_specs && decl_specs->specs[(int) ds_friend],\n \t    is_declaration));\n@@ -9272,7 +9272,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       if (is_cv_qualifier)\n \t*is_cv_qualifier = true;\n       break;\n-      \n+\n     case RID_VOLATILE:\n       ds = ds_volatile;\n       if (is_cv_qualifier)\n@@ -9307,7 +9307,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \n   /* If we do not already have a type-specifier, assume we are looking\n      at a simple-type-specifier.  */\n-  type_spec = cp_parser_simple_type_specifier (parser, \n+  type_spec = cp_parser_simple_type_specifier (parser,\n \t\t\t\t\t       decl_specs,\n \t\t\t\t\t       flags);\n \n@@ -9349,7 +9349,7 @@ cp_parser_type_specifier (cp_parser* parser,\n    appropriately updated.  */\n \n static tree\n-cp_parser_simple_type_specifier (cp_parser* parser, \n+cp_parser_simple_type_specifier (cp_parser* parser,\n \t\t\t\t cp_decl_specifier_seq *decl_specs,\n \t\t\t\t cp_parser_flags flags)\n {\n@@ -9420,7 +9420,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n \t\t\t\t      /*user_defined_p=*/true);\n-\t\n+\n       return type;\n \n     default:\n@@ -9438,7 +9438,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t      && token->keyword != RID_UNSIGNED\n \t      && token->keyword != RID_SHORT\n \t      && token->keyword != RID_LONG))\n-\tcp_parser_set_decl_spec_type (decl_specs, \n+\tcp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t      type,\n \t\t\t\t      /*user_defined=*/false);\n       if (decl_specs)\n@@ -9498,9 +9498,9 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       else\n \ttype = cp_parser_type_name (parser);\n       /* Keep track of all name-lookups performed in class scopes.  */\n-      if (type  \n+      if (type\n \t  && !qualified_p\n-\t  && TREE_CODE (type) == TYPE_DECL \n+\t  && TREE_CODE (type) == TYPE_DECL\n \t  && TREE_CODE (DECL_NAME (type)) == IDENTIFIER_NODE)\n \tmaybe_note_name_used_in_class (DECL_NAME (type), type);\n       /* If it didn't work out, we don't have a TYPE.  */\n@@ -11149,12 +11149,12 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  if (ctor_dtor_or_conv_p && declarator->u.id.sfk != sfk_none)\n \t\t    *ctor_dtor_or_conv_p = -1;\n \t\t  if (TREE_CODE (id) == SCOPE_REF\n-\t\t      && TREE_CODE (unqualified_name) == TYPE_DECL \n+\t\t      && TREE_CODE (unqualified_name) == TYPE_DECL\n \t\t      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n \t\t    {\n \t\t      error (\"invalid use of constructor as a template\");\n \t\t      inform (\"use `%T::%D' instead of `%T::%T' to name the \"\n-\t\t\t      \"constructor in a qualified name\", class_type, \n+\t\t\t      \"constructor in a qualified name\", class_type,\n \t\t\t      DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n \t\t\t      class_type, class_type);\n \t\t    }\n@@ -11299,7 +11299,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n    GNU Extension:\n \n    cv-qualifier:\n-     __restrict__ \n+     __restrict__\n \n    Returns a bitmask representing the cv-qualifiers.  */\n \n@@ -11312,7 +11312,7 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n     {\n       cp_token *token;\n       cp_cv_quals cv_qualifier;\n-      \n+\n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       /* See if it's a cv-qualifier.  */\n@@ -11321,20 +11321,20 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n \tcase RID_CONST:\n \t  cv_qualifier = TYPE_QUAL_CONST;\n \t  break;\n-\t  \n+\n \tcase RID_VOLATILE:\n \t  cv_qualifier = TYPE_QUAL_VOLATILE;\n \t  break;\n-\t  \n+\n \tcase RID_RESTRICT:\n \t  cv_qualifier = TYPE_QUAL_RESTRICT;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  cv_qualifier = TYPE_UNQUALIFIED;\n \t  break;\n \t}\n-      \n+\n       if (!cv_qualifier)\n \tbreak;\n \n@@ -11461,7 +11461,7 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n       /* Check for attributes first.  */\n       if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n \t{\n-\t  type_specifier_seq->attributes = \n+\t  type_specifier_seq->attributes =\n \t    chainon (type_specifier_seq->attributes,\n \t\t     cp_parser_attributes_opt (parser));\n \t  continue;\n@@ -11576,7 +11576,7 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n   /* Finish the parameter list.  */\n   if (parameters && ellipsis_p)\n     parameters->ellipsis_p = true;\n-  \n+\n   return parameters;\n }\n \n@@ -11782,7 +11782,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       parser->default_arg_ok_p = saved_default_arg_ok_p;\n       /* After the declarator, allow more attributes.  */\n       decl_specifiers.attributes\n-\t= chainon (decl_specifiers.attributes, \n+\t= chainon (decl_specifiers.attributes,\n \t\t   cp_parser_attributes_opt (parser));\n     }\n \n@@ -12040,7 +12040,7 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n      assignment-expression.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n     {\n-      initializer \n+      initializer\n \t= cp_parser_constant_expression (parser,\n \t\t\t\t\t/*allow_non_constant_p=*/true,\n \t\t\t\t\tnon_constant_p);\n@@ -12338,14 +12338,14 @@ cp_parser_class_specifier (cp_parser* parser)\n   if (nested_name_specifier_p)\n     pop_p = push_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n   type = begin_class_definition (type);\n-  \n+\n   if (type == error_mark_node)\n     /* If the type is erroneous, skip the entire body of the class.  */\n     cp_parser_skip_to_closing_brace (parser);\n   else\n     /* Parse the member-specification.  */\n     cp_parser_member_specification_opt (parser);\n-  \n+\n   /* Look for the trailing `}'.  */\n   cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n   /* We get better error messages by noticing a common problem: a\n@@ -12482,7 +12482,6 @@ cp_parser_class_head (cp_parser* parser,\n \t\t      bool* nested_name_specifier_p,\n \t\t      tree *attributes_p)\n {\n-  cp_token *token;\n   tree nested_name_specifier;\n   enum tag_types class_key;\n   tree id = NULL_TREE;\n@@ -12771,13 +12770,13 @@ cp_parser_class_head (cp_parser* parser,\n      is valid.  */\n   if (nested_name_specifier)\n     pop_p = push_scope (nested_name_specifier);\n-  \n+\n   bases = NULL_TREE;\n-  \n+\n   /* Get the list of base-classes, if there is one.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n     bases = cp_parser_base_clause (parser);\n-  \n+\n   /* Process the base classes.  */\n   xref_basetypes (type, bases);\n \n@@ -12988,7 +12987,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t\t  A<T>::B will be represented by a TYPENAME_TYPE, and\n \t\t  therefore not recognized by check_tag_decl.  */\n-\t       if (!type \n+\t       if (!type\n \t\t   && decl_specifiers.type\n \t\t   && TYPE_P (decl_specifiers.type))\n \t\t type = decl_specifiers.type;\n@@ -13069,7 +13068,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      attributes = chainon (prefix_attributes, attributes);\n \n \t      /* Create the bitfield declaration.  */\n-\t      decl = grokbitfield (identifier \n+\t      decl = grokbitfield (identifier\n \t\t\t\t   ? make_id_declarator (identifier)\n \t\t\t\t   : NULL,\n \t\t\t\t   &decl_specifiers,\n@@ -14418,7 +14417,7 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n     case cdk_pointer:\n     case cdk_reference:\n     case cdk_ptrmem:\n-      return (cp_parser_check_declarator_template_parameters \n+      return (cp_parser_check_declarator_template_parameters\n \t      (parser, declarator->declarator));\n \n     case cdk_error:\n@@ -14513,7 +14512,7 @@ cp_parser_binary_expression (cp_parser* parser,\n \t    /* Parse the right-hand side of the expression.  */\n \t    rhs = (*fn) (parser);\n \t    /* Build the binary tree node.  */\n-\t    lhs = build_x_binary_op (map_node->tree_type, lhs, rhs, \n+\t    lhs = build_x_binary_op (map_node->tree_type, lhs, rhs,\n \t\t\t\t     &overloaded_p);\n \t    /* If the binary operator required the use of an\n \t       overloaded operator, then this expression cannot be an\n@@ -14522,7 +14521,7 @@ cp_parser_binary_expression (cp_parser* parser,\n \t       permissible in an integral constant-expression if at\n \t       least one of the operands is of enumeration type.  */\n \t    if (overloaded_p\n-\t\t&& (cp_parser_non_integral_constant_expression \n+\t\t&& (cp_parser_non_integral_constant_expression\n \t\t    (parser, \"calls to overloaded operators\")))\n \t      lhs = error_mark_node;\n \t    break;\n@@ -14883,13 +14882,13 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       /* There are no access checks when parsing a template, as we do not\n          know if a specialization will be a friend.  */\n       push_deferring_access_checks (dk_no_check);\n-      \n+\n       decl = cp_parser_single_declaration (parser,\n \t\t\t\t\t   member_p,\n \t\t\t\t\t   &friend_p);\n \n       pop_deferring_access_checks ();\n-  \n+\n       /* If this is a member template declaration, let the front\n \t end know.  */\n       if (member_p && !friend_p && decl)\n@@ -15024,10 +15023,10 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n   cast = build_functional_cast (type, expression_list);\n   /* [expr.const]/1: In an integral constant expression \"only type\n      conversions to integral or enumeration type can be used\".  */\n-  if (cast != error_mark_node && !type_dependent_expression_p (type) \n+  if (cast != error_mark_node && !type_dependent_expression_p (type)\n       && !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (type)))\n     {\n-      if (cp_parser_non_integral_constant_expression \n+      if (cp_parser_non_integral_constant_expression\n \t  (parser, \"a call to a constructor\"))\n \treturn error_mark_node;\n     }\n@@ -15442,12 +15441,12 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n \t\t\t      bool user_defined_p)\n {\n   decl_specs->any_specifiers_p = true;\n- \n+\n   /* If the user tries to redeclare a built-in type (with, for example,\n      in \"typedef int wchar_t;\") we remember that this is what\n      happened.  In system headers, we ignore these declarations so\n      that G++ can work with system headers that are not C++-safe.  */\n-  if (decl_specs->specs[(int) ds_typedef] \n+  if (decl_specs->specs[(int) ds_typedef]\n       && !user_defined_p\n       && (decl_specs->type\n \t  || decl_specs->specs[(int) ds_long]\n@@ -15805,7 +15804,7 @@ cp_parser_cache_group (cp_parser *parser,\n   c_lex_string_translate = -1;\n \n   cp_parser_cache_group_1 (parser, cache, end, depth);\n-  \n+\n   c_lex_string_translate = saved_c_lex_string_translate;\n }\n "}]}