{"sha": "a65f3558e9ef5f11bf95414973c4ed88db04e250", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY1ZjM1NThlOWVmNWYxMWJmOTU0MTQ5NzNjNGVkODhkYjA0ZTI1MA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-21T20:49:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-21T20:49:10Z"}, "message": "gcse.c (dump_hash_table): Fix whitespace in declaration.\n\n\t* gcse.c (dump_hash_table): Fix whitespace in declaration.\n\t(compute_transpout): Renamed from pre_compute_transpout.\n\t(compute_pre_*): Deleted\n\t(pre_expr_reaches_here_p): New argument, CHECK_PRE_COMP.  All\n\tcallers changed.\n\t(insert_insn_end_bb): Renamed from pre_insert_insn.\n\t(pre_*): Delete unused variables.  Only leave local properties and\n\tglobal redundant/optimal computation points.\n\t(alloc_pre_mem, free_pre_mem): Corresponding changes.\n\t(compute_pre_data): Simplify and call pre_lcm to run the lazy\n\tcode motion dataflow analysis.\n\t(pre_insert, pre_insert_copies, pre_delete): Revamp to use LCM\n\tbased redundant and optimal computation points.\n\nFrom-SVN: r25886", "tree": {"sha": "d40f0c736e949f1bf6ff2731df1e480f6a9a11b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d40f0c736e949f1bf6ff2731df1e480f6a9a11b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a65f3558e9ef5f11bf95414973c4ed88db04e250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a65f3558e9ef5f11bf95414973c4ed88db04e250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a65f3558e9ef5f11bf95414973c4ed88db04e250", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a65f3558e9ef5f11bf95414973c4ed88db04e250/comments", "author": null, "committer": null, "parents": [{"sha": "077692c6150f16f02b8c7ec6da65e2ca7e848e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/077692c6150f16f02b8c7ec6da65e2ca7e848e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/077692c6150f16f02b8c7ec6da65e2ca7e848e3c"}], "stats": {"total": 635, "additions": 246, "deletions": 389}, "files": [{"sha": "b93a97eac75d8ad73a0a99bfc2de6f77aac0342f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a65f3558e9ef5f11bf95414973c4ed88db04e250/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a65f3558e9ef5f11bf95414973c4ed88db04e250/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a65f3558e9ef5f11bf95414973c4ed88db04e250", "patch": "@@ -1,5 +1,19 @@\n Sun Mar 21 17:33:48 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* gcse.c (dump_hash_table): Fix whitespace in declaration.\n+\t(compute_transpout): Renamed from pre_compute_transpout.\n+\t(compute_pre_*): Deleted\n+\t(pre_expr_reaches_here_p): New argument, CHECK_PRE_COMP.  All\n+\tcallers changed.\n+\t(insert_insn_end_bb): Renamed from pre_insert_insn.\n+\t(pre_*): Delete unused variables.  Only leave local properties and\n+\tglobal redundant/optimal computation points.\n+\t(alloc_pre_mem, free_pre_mem): Corresponding changes.\n+\t(compute_pre_data): Simplify and call pre_lcm to run the lazy\n+\tcode motion dataflow analysis.\n+\t(pre_insert, pre_insert_copies, pre_delete): Revamp to use LCM\n+\tbased redundant and optimal computation points.\n+\n \t* basic-block.h (pre_lcm, pre_rev_lcm): Declare.\n \n \t* toplev.c (main): A debug option without a level defaults to"}, {"sha": "dc970cd2446066e68232196a9ba14c7da4624eff", "filename": "gcc/gcse.c", "status": "modified", "additions": 232, "deletions": 389, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a65f3558e9ef5f11bf95414973c4ed88db04e250/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a65f3558e9ef5f11bf95414973c4ed88db04e250/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a65f3558e9ef5f11bf95414973c4ed88db04e250", "patch": "@@ -550,7 +550,8 @@ static void compute_set_hash_table    PROTO ((void));\n static void alloc_expr_hash_table     PROTO ((int));\n static void free_expr_hash_table      PROTO ((void));\n static void compute_expr_hash_table   PROTO ((void));\n-static void dump_hash_table\t   PROTO ((FILE *, const char *, struct expr **, int, int));\n+static void dump_hash_table\t   PROTO ((FILE *, const char *, struct expr **,\n+\t\t\t\t\t   int, int));\n static struct expr *lookup_expr       PROTO ((rtx));\n static struct expr *lookup_set\tPROTO ((int, rtx));\n static struct expr *next_set\t  PROTO ((int, struct expr *));\n@@ -564,6 +565,7 @@ static void mark_oprs_set\t     PROTO ((rtx));\n static void alloc_cprop_mem\t   PROTO ((int, int));\n static void free_cprop_mem\t    PROTO ((void));\n static void compute_transp\t    PROTO ((rtx, int, sbitmap *, int));\n+static void compute_transpout\t    PROTO ((void));\n static void compute_local_properties  PROTO ((sbitmap *, sbitmap *,\n \t\t\t\t\t      sbitmap *, int));\n static void compute_cprop_avinout     PROTO ((void));\n@@ -577,14 +579,10 @@ static int one_cprop_pass\t     PROTO ((int, int));\n \n static void alloc_pre_mem\t     PROTO ((int, int));\n static void free_pre_mem\t      PROTO ((void));\n-static void compute_pre_avinout       PROTO ((void));\n-static void compute_pre_antinout      PROTO ((void));\n-static void compute_pre_pavinout      PROTO ((void));\n-static void compute_pre_ppinout       PROTO ((void));\n static void compute_pre_data\t  PROTO ((void));\n-static int pre_expr_reaches_here_p    PROTO ((struct occr *, struct expr *,\n-\t\t\t\t\t      int, char *));\n-static void pre_insert_insn\t   PROTO ((struct expr *, int));\n+static int pre_expr_reaches_here_p    PROTO ((int, struct expr *,\n+\t\t\t\t\t      int, int, char *));\n+static void insert_insn_end_bb\tPROTO ((struct expr *, int, int));\n static void pre_insert\t\tPROTO ((struct expr **));\n static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n static void pre_insert_copies\t PROTO ((void));\n@@ -3924,363 +3922,88 @@ one_cprop_pass (pass, alter_jumps)\n   return changed;\n }\n \f\n-/* Compute PRE working variables.  */\n+/* Compute PRE+LCM working variables.  */\n \n /* Local properties of expressions.  */\n /* Nonzero for expressions that are transparent in the block.  */\n-static sbitmap *pre_transp;\n-/* Nonzero for expressions that are computed (available) in the block.  */\n-static sbitmap *pre_comp;\n-/* Nonzero for expressions that are locally anticipatable in the block.  */\n-static sbitmap *pre_antloc;\n-\n-/* Global properties (computed from the expression local properties).  */\n-/* Nonzero for expressions that are available on block entry/exit.  */\n-static sbitmap *pre_avin;\n-static sbitmap *pre_avout;\n-/* Nonzero for expressions that are anticipatable on block entry/exit.  */\n-static sbitmap *pre_antin;\n-static sbitmap *pre_antout;\n-/* Nonzero for expressions that are partially available on block entry/exit.  */\n-static sbitmap *pre_pavin;\n-static sbitmap *pre_pavout;\n-/* Nonzero for expressions that are \"placement possible\" on block entry/exit.  */\n-static sbitmap *pre_ppin;\n-static sbitmap *pre_ppout;\n+static sbitmap *transp;\n \n /* Nonzero for expressions that are transparent at the end of the block.\n    This is only zero for expressions killed by abnormal critical edge\n    created by a calls.  */\n-static sbitmap *pre_transpout;\n+static sbitmap *transpout;\n \n-/* Used while performing PRE to denote which insns are redundant.  */\n-static sbitmap pre_redundant;\n-\n-/* Allocate vars used for PRE analysis.  */\n-\n-static void\n-alloc_pre_mem (n_blocks, n_exprs)\n-     int n_blocks, n_exprs;\n-{\n-  pre_transp = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_comp = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_antloc = sbitmap_vector_alloc (n_blocks, n_exprs);\n+/* Nonzero for expressions that are computed (available) in the block.  */\n+static sbitmap *comp;\n \n-  pre_avin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_avout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_antin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_antout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+/* Nonzero for expressions that are locally anticipatable in the block.  */\n+static sbitmap *antloc;\n \n-  pre_pavin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_pavout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_ppin = sbitmap_vector_alloc (n_blocks, n_exprs);\n-  pre_ppout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+/* Nonzero for expressions where this block is an optimal computation\n+   point.  */\n+static sbitmap *pre_optimal;\n \n-  pre_transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-}\n+/* Nonzero for expressions which are redundant in a particular block.  */\n+static sbitmap *pre_redundant;\n \n-/* Free vars used for PRE analysis.  */\n+static sbitmap *temp_bitmap;\n \n-static void\n-free_pre_mem ()\n-{\n-  free (pre_transp);\n-  free (pre_comp);\n-  free (pre_antloc);\n-  free (pre_avin);\n-  free (pre_avout);\n-  free (pre_antin);\n-  free (pre_antout);\n-\n-  free (pre_pavin);\n-  free (pre_pavout);\n-  free (pre_ppin);\n-  free (pre_ppout);\n-  free (pre_transpout);\n-}\n+/* Redundant insns.  */\n+static sbitmap pre_redundant_insns;\n \n-/* Compute expression availability at entrance and exit of each block.  */\n-\n-static void\n-compute_pre_avinout ()\n-{\n-  int bb, changed, passes;\n-\n-  sbitmap_zero (pre_avin[0]);\n-  sbitmap_vector_ones (pre_avout, n_basic_blocks);\n-\n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  if (bb != 0)\n-\t    sbitmap_intersect_of_predecessors (pre_avin[bb], pre_avout,\n-\t\t\t\t\t       bb, s_preds);\n-\t  changed |= sbitmap_a_or_b_and_c (pre_avout[bb], pre_comp[bb],\n-\t\t\t\t\t   pre_transp[bb], pre_avin[bb]);\n-\t}\n-      passes++;\n-    }\n-\n-  if (gcse_file)\n-    fprintf (gcse_file, \"avail expr computation: %d passes\\n\", passes);\n-}\n-\n-/* Compute expression anticipatability at entrance and exit of each block.  */\n+/* Allocate vars used for PRE analysis.  */\n \n static void\n-compute_pre_antinout ()\n+alloc_pre_mem (n_blocks, n_exprs)\n+     int n_blocks, n_exprs;\n {\n-  int bb, changed, passes;\n-\n-  sbitmap_zero (pre_antout[n_basic_blocks - 1]);\n-  sbitmap_vector_ones (pre_antin, n_basic_blocks);\n-\n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      /* We scan the blocks in the reverse order to speed up\n-\t the convergence.  */\n-      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n-\t{\n-\t  if (bb != n_basic_blocks - 1)\n-\t    sbitmap_intersect_of_successors (pre_antout[bb], pre_antin,\n-\t\t\t\t\t     bb, s_succs);\n-\t  changed |= sbitmap_a_or_b_and_c (pre_antin[bb], pre_antloc[bb],\n-\t\t\t\t\t   pre_transp[bb], pre_antout[bb]);\n-\t}\n-      passes++;\n-    }\n-\n-  if (gcse_file)\n-    fprintf (gcse_file, \"antic expr computation: %d passes\\n\", passes);\n+  transp = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  comp = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  antloc = sbitmap_vector_alloc (n_blocks, n_exprs);\n+\n+  temp_bitmap = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  pre_optimal = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  pre_redundant = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n }\n \n-/* Compute expression partial availability at entrance and exit of\n-   each block.  */\n-\n-static void\n-compute_pre_pavinout ()\n-{\n-  int bb, changed, passes;\n-\n-  sbitmap_zero (pre_pavin[0]);\n-  sbitmap_vector_zero (pre_pavout, n_basic_blocks);\n-\n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  if (bb != 0)\n-\t    sbitmap_union_of_predecessors (pre_pavin[bb], pre_pavout,\n-\t\t\t\t\t   bb, s_preds);\n-\t  changed |= sbitmap_a_or_b_and_c (pre_pavout[bb], pre_comp[bb],\n-\t\t\t\t\t   pre_transp[bb], pre_pavin[bb]);\n-\t}\n-      passes++;\n-    }\n-\n-  if (gcse_file)\n-    fprintf (gcse_file, \"partially avail expr computation: %d passes\\n\", passes);\n-}\n-\n-/* Compute transparent outgoing information for each block.\n-\n-   An expression is transparent to an edge unless it is killed by\n-   the edge itself.  This can only happen with abnormal control flow,\n-   when the edge is traversed through a call.  This happens with\n-   non-local labels and exceptions.\n-\n-   This would not be necessary if we split the edge.  While this is\n-   normally impossible for abnormal critical edges, with some effort\n-   it should be possible with exception handling, since we still have\n-   control over which handler should be invoked.  But due to increased\n-   EH table sizes, this may not be worthwhile.  */\n-\n-static void\n-compute_pre_transpout ()\n-{\n-  int bb;\n-\n-  sbitmap_vector_ones (pre_transpout, n_basic_blocks);\n-\n-  for (bb = 0; bb < n_basic_blocks; ++bb)\n-    {\n-      int i;\n-\n-      /* Note that flow inserted a nop a the end of basic blocks that\n-\t end in call instructions for reasons other than abnormal\n-\t control flow.  */\n-      if (GET_CODE (BLOCK_END (bb)) != CALL_INSN)\n-\tcontinue;\n-\n-      for (i = 0; i < expr_hash_table_size; i++)\n-\t{\n-\t  struct expr *expr;\n-\t  for (expr = expr_hash_table[i]; expr ; expr = expr->next_same_hash)\n-\t    if (GET_CODE (expr->expr) == MEM)\n-\t      {\n-\t\trtx addr = XEXP (expr->expr, 0);\n-\n-\t\tif (GET_CODE (addr) == SYMBOL_REF\n-\t\t    && CONSTANT_POOL_ADDRESS_P (addr))\n-\t\t  continue;\n-\t\t\n-\t\t/* ??? Optimally, we would use interprocedural alias\n-\t\t   analysis to determine if this mem is actually killed\n-\t\t   by this call.  */\n-\t\tRESET_BIT (pre_transpout[bb], expr->bitmap_index);\n-\t      }\n-\t}\n-    }\n-}   \n-\n-/* Compute \"placement possible\" information on entrance and exit of\n-   each block.\n-\n-   From Fred Chow's Thesis:\n-   A computation `e' is PP at a point `p' if it is anticipated at `p' and\n-   all the anticipated e's can be rendered redundant by zero or more\n-   insertions at that point and some other points in the procedure, and\n-   these insertions satisfy the conditions that the insertions are always\n-   at points that `e' is anticipated and the first anticipated e's after the\n-   insertions are rendered redundant.  */\n+/* Free vars used for PRE analysis.  */\n \n static void\n-compute_pre_ppinout ()\n+free_pre_mem ()\n {\n-  int bb, i, changed, size, passes;\n-\n-  sbitmap_vector_ones (pre_ppin, n_basic_blocks);\n-  /* ??? Inefficient as we set pre_ppin[0] twice, but simple.  */\n-  sbitmap_zero (pre_ppin[0]);\n-\n-  sbitmap_vector_ones (pre_ppout, n_basic_blocks);\n-  /* ??? Inefficient as we set pre_ppout[n_basic_blocks-1] twice, but simple.  */\n-  sbitmap_zero (pre_ppout[n_basic_blocks - 1]);\n-\n-  size = pre_ppin[0]->size;\n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (bb = 1; bb < n_basic_blocks; bb++)\n-\t{\n-\t  sbitmap_ptr antin = pre_antin[bb]->elms;\n-\t  sbitmap_ptr pavin = pre_pavin[bb]->elms;\n-\t  sbitmap_ptr antloc = pre_antloc[bb]->elms;\n-\t  sbitmap_ptr transp = pre_transp[bb]->elms;\n-\t  sbitmap_ptr ppout = pre_ppout[bb]->elms;\n-\t  sbitmap_ptr ppin = pre_ppin[bb]->elms;\n-\n-\t  for (i = 0; i < size; i++)\n-\t    {\n-\t      int_list_ptr pred;\n-\t      SBITMAP_ELT_TYPE tmp = *antin & *pavin & (*antloc | (*transp & *ppout));\n-\t      SBITMAP_ELT_TYPE pred_val = (SBITMAP_ELT_TYPE) -1;\n-\n-\t      for (pred = s_preds[bb]; pred != NULL; pred = pred->next)\n-\t\t{\n-\t\t  int pred_bb = INT_LIST_VAL (pred);\n-\t\t  sbitmap_ptr ppout_j,avout_j;\n-\n-\t\t  if (pred_bb == ENTRY_BLOCK)\n-\t\t    continue;\n-\n-\t\t  /* If this is a back edge, propagate info along the back\n-\t\t     edge to allow for loop invariant code motion.\n-\n-\t\t     See FOLLOW_BACK_EDGES at the top of this file for a longer\n-\t\t     discussion about loop invariant code motion in pre.  */\n-\t\t  if (! FOLLOW_BACK_EDGES\n-\t\t      && (INSN_CUID (BLOCK_HEAD (bb))\n-\t\t\t  < INSN_CUID (BLOCK_END (pred_bb))))\n-\t\t    {\n-\t\t      pred_val = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      ppout_j = pre_ppout[pred_bb]->elms + i;\n-\t\t      avout_j = pre_avout[pred_bb]->elms + i;\n-\t\t      pred_val &= *ppout_j | *avout_j;\n-\t\t    }\n-\t\t}\n-\t      tmp &= pred_val;\n-\t      *ppin = tmp;\n-\t      antin++; pavin++; antloc++; transp++; ppout++; ppin++;\n-\t    }\n-\t}\n-\n-      for (bb = 0; bb < n_basic_blocks - 1; bb++)\n-\t{\n-\t  sbitmap_ptr ppout = pre_ppout[bb]->elms;\n-\t  sbitmap_ptr transpout = pre_transpout[bb]->elms;\n-\n-\t  for (i = 0; i < size; i++)\n-\t    {\n-\t      int_list_ptr succ;\n-\t      SBITMAP_ELT_TYPE tmp = *transpout;\n-\n-\t      for (succ = s_succs[bb]; succ != NULL; succ = succ->next)\n-\t\t{\n-\t\t  int succ_bb = INT_LIST_VAL (succ);\n-\t\t  sbitmap_ptr ppin;\n-\n-\t\t  if (succ_bb == EXIT_BLOCK)\n-\t\t    continue;\n-\n-\t\t  ppin = pre_ppin[succ_bb]->elms + i;\n-\t\t  tmp &= *ppin;\n-\t\t}\n-\n-\t      if (*ppout != tmp)\n-\t\t{\n-\t\t  changed = 1;\n-\t\t  *ppout = tmp;\n-\t\t}\n-\n-\t      ppout++; transpout++;\n-\t    }\n-\t}\n-\n-      passes++;\n-    }\n+  free (transp);\n+  free (comp);\n+  free (antloc);\n \n-  if (gcse_file)\n-    fprintf (gcse_file, \"placement possible computation: %d passes\\n\", passes);\n+  free (pre_optimal);\n+  free (pre_redundant);\n+  free (transpout);\n }\n \n /* Top level routine to do the dataflow analysis needed by PRE.  */\n \n static void\n compute_pre_data ()\n {\n-  compute_local_properties (pre_transp, pre_comp, pre_antloc, 0);\n-  compute_pre_avinout ();\n-  compute_pre_antinout ();\n-  compute_pre_pavinout ();\n-  compute_pre_transpout ();\n-  compute_pre_ppinout ();\n-  if (gcse_file)\n-    fprintf (gcse_file, \"\\n\");\n+  compute_local_properties (transp, comp, antloc, 0);\n+  compute_transpout ();\n+  pre_lcm (n_basic_blocks, n_exprs, s_preds, s_succs, transp,\n+\t   antloc, pre_redundant, pre_optimal);\n }\n+\n \f\n /* PRE utilities */\n \n-/* Return non-zero if occurrence OCCR of expression EXPR reaches block BB.\n+/* Return non-zero if an occurrence of expression EXPR in OCCR_BB would reach\n+   block BB.\n \n    VISITED is a pointer to a working buffer for tracking which BB's have\n    been visited.  It is NULL for the top-level call.\n \n+   CHECK_PRE_COMP controls whether or not we check for a computation of\n+   EXPR in OCCR_BB.\n+\n    We treat reaching expressions that go through blocks containing the same\n    reaching expression as \"not reaching\".  E.g. if EXPR is generated in blocks\n    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block\n@@ -4289,10 +4012,11 @@ compute_pre_data ()\n    the closest such expression.  */\n \n static int\n-pre_expr_reaches_here_p (occr, expr, bb, visited)\n-     struct occr *occr;\n+pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp, visited)\n+     int occr_bb;\n      struct expr *expr;\n      int bb;\n+     int check_pre_comp;\n      char *visited;\n {\n   int_list_ptr pred;\n@@ -4314,23 +4038,25 @@ pre_expr_reaches_here_p (occr, expr, bb, visited)\n \t  /* Nothing to do.  */\n \t}\n       /* Does this predecessor generate this expression?  */\n-      else if (TEST_BIT (pre_comp[pred_bb], expr->bitmap_index))\n+      else if ((!check_pre_comp && occr_bb == pred_bb)\n+\t       || TEST_BIT (comp[pred_bb], expr->bitmap_index))\n \t{\n \t  /* Is this the occurrence we're looking for?\n \t     Note that there's only one generating occurrence per block\n \t     so we just need to check the block number.  */\n-\t  if (BLOCK_NUM (occr->insn) == pred_bb)\n+\t  if (occr_bb == pred_bb)\n \t    return 1;\n \t  visited[pred_bb] = 1;\n \t}\n       /* Ignore this predecessor if it kills the expression.  */\n-      else if (! TEST_BIT (pre_transp[pred_bb], expr->bitmap_index))\n+      else if (! TEST_BIT (transp[pred_bb], expr->bitmap_index))\n \tvisited[pred_bb] = 1;\n       /* Neither gen nor kill.  */\n       else\n \t{\n \t  visited[pred_bb] = 1;\n-\t  if (pre_expr_reaches_here_p (occr, expr, pred_bb, visited))\n+\t  if (pre_expr_reaches_here_p (occr_bb, expr, pred_bb,\n+\t\t\t\t       check_pre_comp, visited))\n \t    return 1;\n \t}\n     }\n@@ -4339,20 +4065,33 @@ pre_expr_reaches_here_p (occr, expr, bb, visited)\n   return 0;\n }\n \f\n-/* Add EXPR to the end of basic block BB.  */\n+/* Add EXPR to the end of basic block BB.\n+\n+   This is used by both the PRE and code hoisting.\n+\n+   For PRE, we want to verify that the expr is either transparent\n+   or locally anticipatable in the target block.  This check makes\n+   no sense for code hoisting.  */\n \n static void\n-pre_insert_insn (expr, bb)\n+insert_insn_end_bb (expr, bb, pre)\n      struct expr *expr;\n      int bb;\n+     int pre;\n {\n   rtx insn = BLOCK_END (bb);\n   rtx new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n-  rtx pat;\n+  rtx pat, copied_expr;\n+  rtx first_new_insn;\n \n-  pat = gen_rtx_SET (VOIDmode, reg, copy_rtx (expr->expr));\n+  start_sequence ();\n+  copied_expr = copy_rtx (expr->expr);\n+  emit_move_insn (reg, copied_expr);\n+  first_new_insn = get_insns ();\n+  pat = gen_sequence ();\n+  end_sequence ();\n \n   /* If the last insn is a jump, insert EXPR in front [taking care to\n      handle cc0, etc. properly].  */\n@@ -4387,7 +4126,6 @@ pre_insert_insn (expr, bb)\n #endif\n       /* FIXME: What if something in cc0/jump uses value set in new insn?  */\n       new_insn = emit_insn_before (pat, insn);\n-      add_label_notes (SET_SRC (pat), new_insn);\n       if (BLOCK_HEAD (bb) == insn)\n \tBLOCK_HEAD (bb) = new_insn;\n     }\n@@ -4405,11 +4143,11 @@ pre_insert_insn (expr, bb)\n \t presumtion that we'll get better code elsewhere as well.  */\n \n       /* It should always be the case that we can put these instructions\n-\t anywhere in the basic block.  Check this.  */\n-      /* ??? Well, it would be the case if we'd split all critical edges.\n-\t Since we didn't, we may very well abort.  */\n-      if (!TEST_BIT (pre_antloc[bb], expr->bitmap_index)\n-\t  && !TEST_BIT (pre_transp[bb], expr->bitmap_index))\n+\t anywhere in the basic block with performing PRE optimizations.\n+\t Check this.  */\n+      if (pre\n+\t  && !TEST_BIT (antloc[bb], expr->bitmap_index)\n+          && !TEST_BIT (transp[bb], expr->bitmap_index))\n \tabort ();\n \n       /* Since different machines initialize their parameter registers\n@@ -4449,62 +4187,101 @@ pre_insert_insn (expr, bb)\n   else\n     {\n       new_insn = emit_insn_after (pat, insn);\n-      add_label_notes (SET_SRC (pat), new_insn);\n       BLOCK_END (bb) = new_insn;\n     }\n \n-  /* Keep block number table up to date.  */\n-  set_block_num (new_insn, bb);\n-  /* Keep register set table up to date.  */\n-  record_one_set (regno, new_insn);\n+  /* Keep block number table up to date.\n+     Note, PAT could be a multiple insn sequence, we have to make\n+     sure that each insn in the sequence is handled.  */\n+  if (GET_CODE (pat) == SEQUENCE)\n+    {\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx insn = XVECEXP (pat, 0, i);\n+\t  set_block_num (insn, bb);\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    add_label_notes (PATTERN (insn), new_insn);\n+\t  record_set_insn = insn;\n+\t  note_stores (PATTERN (insn), record_set_info);\n+\t}\n+    }\n+  else\n+    {\n+      add_label_notes (SET_SRC (pat), new_insn);\n+      set_block_num (new_insn, bb);\n+      /* Keep register set table up to date.  */\n+      record_one_set (regno, new_insn);\n+    }\n \n   gcse_create_count++;\n \n   if (gcse_file)\n     {\n-      fprintf (gcse_file, \"PRE: end of bb %d, insn %d, copying expression %d to reg %d\\n\",\n+      fprintf (gcse_file, \"PRE/HOIST: end of bb %d, insn %d, copying expression %d to reg %d\\n\",\n \t       bb, INSN_UID (new_insn), expr->bitmap_index, regno);\n     }\n }\n \n /* Insert partially redundant expressions at the ends of appropriate basic\n-   blocks making them now redundant.  */\n+   blocks making them fully redundant.  */\n \n static void\n pre_insert (index_map)\n      struct expr **index_map;\n {\n-  int bb, i, size;\n+  int bb, i, set_size;\n+  sbitmap *inserted;\n+\n+  /* Compute INSERT = PRE_OPTIMAL & ~PRE_REDUNDANT. \n+     Where INSERT is nonzero, we add the expression at the end of the basic\n+     block if it reaches any of the deleted expressions.  */\n \n-  /* Compute INSERT = PPOUT & (~AVOUT) & (~PPIN | ~TRANSP) for each\n-     expression.  Where INSERT == TRUE, add the expression at the end of\n-     the basic block.  */\n+  set_size = pre_optimal[0]->size;\n+  inserted = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n+  sbitmap_vector_zero (inserted, n_basic_blocks);\n \n-  size = pre_ppout[0]->size;\n   for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n       int indx;\n-      sbitmap_ptr ppout = pre_ppout[bb]->elms;\n-      sbitmap_ptr avout = pre_avout[bb]->elms;\n-      sbitmap_ptr ppin = pre_ppin[bb]->elms;\n-      sbitmap_ptr transp = pre_transp[bb]->elms;\n-\n-      for (i = indx = 0;\n-\t   i < size;\n-\t   i++, indx += SBITMAP_ELT_BITS, ppout++, avout++, ppin++, transp++)\n+\n+      /* This computes the number of potential insertions we need.  */\n+      sbitmap_not (temp_bitmap[bb], pre_redundant[bb]);\n+      sbitmap_a_and_b (temp_bitmap[bb], temp_bitmap[bb], pre_optimal[bb]);\n+\n+      /* TEMP_BITMAP[bb] now contains a bitmap of the expressions that we need\n+\t to insert at the end of this basic block.  */\n+      for (i = indx = 0; i < set_size; i++, indx += SBITMAP_ELT_BITS)\n \t{\n+\t  SBITMAP_ELT_TYPE insert = temp_bitmap[bb]->elms[i];\n \t  int j;\n-\t  SBITMAP_ELT_TYPE insert = *ppout & (~*avout) & (~*ppin | ~*transp);\n \n-\t  for (j = indx; insert != 0 && j < n_exprs; j++, insert >>= 1)\n+\t  for (j = indx; insert && j < n_exprs; j++, insert >>= 1)\n \t    {\n-\t      if ((insert & 1) != 0\n-\t\t  /* If the basic block isn't reachable, PPOUT will be TRUE.\n-\t\t     However, we don't want to insert a copy here because the\n-\t\t     expression may not really be redundant.  So only insert\n-\t\t     an insn if the expression was deleted.  */\n-\t\t  && index_map[j]->reaching_reg != NULL)\n-\t\tpre_insert_insn (index_map[j], bb);\n+\t      if ((insert & 1) != 0 && index_map[j]->reaching_reg != NULL_RTX)\n+\t\t{\n+\t\t  struct expr *expr = index_map[j];\n+\t\t  struct occr *occr;\n+\n+\t\t  /* Now look at each deleted occurence of this expression.  */\n+\t\t  for (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n+\t\t    {\n+\t\t      if (! occr->deleted_p)\n+\t\t\tcontinue;\n+\n+\t\t      /* Insert this expression at the end of BB if it would\n+\t\t\t reach the deleted occurence.  */\n+\t\t      if (!TEST_BIT (inserted[bb], j)\n+\t\t\t  && pre_expr_reaches_here_p (bb, expr,\n+\t\t\t\t\t\t   BLOCK_NUM (occr->insn), 0,\n+\t\t\t\t\t\t   NULL))\n+\t\t\t{\n+\t\t\t  SET_BIT (inserted[bb], j);\n+\t\t\t  insert_insn_end_bb (index_map[j], bb, 1);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n@@ -4548,7 +4325,12 @@ pre_insert_copy_insn (expr, insn)\n static void\n pre_insert_copies ()\n {\n-  int i;\n+  int i, bb;\n+\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n+    {\n+      sbitmap_a_and_b (temp_bitmap[bb], pre_optimal[bb], pre_redundant[bb]);\n+    }\n \n   /* For each available expression in the table, copy the result to\n      `reaching_reg' if the expression reaches a deleted one.\n@@ -4583,17 +4365,21 @@ pre_insert_copies ()\n \t      for (avail = expr->avail_occr; avail != NULL; avail = avail->next)\n \t\t{\n \t\t  rtx insn = avail->insn;\n+\t\t  int bb = BLOCK_NUM (insn);\n+\n+\t\t  if (!TEST_BIT (temp_bitmap[bb], expr->bitmap_index))\n+\t\t    continue;\n \n \t\t  /* No need to handle this one if handled already.  */\n \t\t  if (avail->copied_p)\n \t\t    continue;\n \t\t  /* Don't handle this one if it's a redundant one.  */\n-\t\t  if (TEST_BIT (pre_redundant, INSN_CUID (insn)))\n+\t\t  if (TEST_BIT (pre_redundant_insns, INSN_CUID (insn)))\n \t\t    continue;\n \t\t  /* Or if the expression doesn't reach the deleted one.  */\n-\t\t  if (! pre_expr_reaches_here_p (avail, expr,\n+\t\t  if (! pre_expr_reaches_here_p (BLOCK_NUM (avail->insn), expr,\n \t\t\t\t\t\t BLOCK_NUM (occr->insn),\n-\t\t\t\t\t\t NULL))\n+\t\t\t\t\t\t 1, NULL))\n \t\t    continue;\n \n \t\t  /* Copy the result of avail to reaching_reg.  */\n@@ -4606,7 +4392,6 @@ pre_insert_copies ()\n }\n \n /* Delete redundant computations.\n-   These are ones that satisy ANTLOC & PPIN.\n    Deletion is done by changing the insn to copy the `reaching_reg' of\n    the expression into the result of the SET.  It is left to later passes\n    (cprop, cse2, flow, combine, regmove) to propagate the copy or eliminate it.\n@@ -4616,7 +4401,15 @@ pre_insert_copies ()\n static int\n pre_delete ()\n {\n-  int i, changed;\n+  int i, bb, changed;\n+\n+  /* Compute the expressions which are redundant and need to be replaced by\n+     copies from the reaching reg to the target reg.  */\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n+    {\n+      sbitmap_not (temp_bitmap[bb], pre_optimal[bb]);\n+      sbitmap_a_and_b (temp_bitmap[bb], temp_bitmap[bb], pre_redundant[bb]);\n+    }\n \n   changed = 0;\n   for (i = 0; i < expr_hash_table_size; i++)\n@@ -4636,9 +4429,8 @@ pre_delete ()\n \t      rtx insn = occr->insn;\n \t      rtx set;\n \t      int bb = BLOCK_NUM (insn);\n-\t      sbitmap ppin = pre_ppin[bb];\n \n-\t      if (TEST_BIT (ppin, indx))\n+\t      if (TEST_BIT (temp_bitmap[bb], indx))\n \t\t{\n \t\t  set = single_set (insn);\n \t\t  if (! set)\n@@ -4662,14 +4454,15 @@ pre_delete ()\n \t\t\t\t       expr->reaching_reg, 0))\n \t\t    {\n \t\t      occr->deleted_p = 1;\n-\t\t      SET_BIT (pre_redundant, INSN_CUID (insn));\n+\t\t      SET_BIT (pre_redundant_insns, INSN_CUID (insn));\n \t\t      changed = 1;\n \t\t      gcse_subst_count++;\n \t\t    }\n \n \t\t  if (gcse_file)\n \t\t    {\n-\t\t      fprintf (gcse_file, \"PRE: redundant insn %d (expression %d) in bb %d, reaching reg is %d\\n\",\n+\t\t      fprintf (gcse_file,\n+\t\t\t       \"PRE: redundant insn %d (expression %d) in bb %d, reaching reg is %d\\n\",\n \t\t\t       INSN_UID (insn), indx, bb, REGNO (expr->reaching_reg));\n \t\t    }\n \t\t}\n@@ -4684,10 +4477,9 @@ pre_delete ()\n    This is called by one_pre_gcse_pass after all the dataflow analysis\n    has been done.\n \n-   This is based on the original Morel-Renvoise paper and Fred Chow's thesis.\n-\n-   The M-R paper uses \"TRANSP\" to describe an expression as being transparent\n-   in a block where as Chow's thesis uses \"ALTERED\".  We use TRANSP.\n+   This is based on the original Morel-Renvoise paper Fred Chow's thesis,\n+   and lazy code motion from Knoop, Ruthing and Steffen as described in\n+   Advanced Compiler Design and Implementation.\n \n    ??? A new pseudo reg is created to hold the reaching expression.\n    The nice thing about the classical approach is that it would try to\n@@ -4722,8 +4514,8 @@ pre_gcse ()\n     }\n \n   /* Reset bitmap used to track which insns are redundant.  */\n-  pre_redundant = sbitmap_alloc (max_cuid);\n-  sbitmap_zero (pre_redundant);\n+  pre_redundant_insns = sbitmap_alloc (max_cuid);\n+  sbitmap_zero (pre_redundant_insns);\n \n   /* Delete the redundant insns first so that\n      - we know what register to use for the new insns and for the other\n@@ -4739,7 +4531,7 @@ pre_gcse ()\n      specially allocated pseudo-reg that reaches the redundant expression.  */\n   pre_insert_copies ();\n \n-  free (pre_redundant);\n+  free (pre_redundant_insns);\n \n   return changed;\n }\n@@ -4824,3 +4616,54 @@ add_label_notes (x, insn)\n \t  add_label_notes (XVECEXP (x, i, j), insn);\n     }\n }\n+\n+/* Compute transparent outgoing information for each block.\n+\n+   An expression is transparent to an edge unless it is killed by\n+   the edge itself.  This can only happen with abnormal control flow,\n+   when the edge is traversed through a call.  This happens with\n+   non-local labels and exceptions.\n+\n+   This would not be necessary if we split the edge.  While this is\n+   normally impossible for abnormal critical edges, with some effort\n+   it should be possible with exception handling, since we still have\n+   control over which handler should be invoked.  But due to increased\n+   EH table sizes, this may not be worthwhile.  */\n+\n+static void\n+compute_transpout ()\n+{\n+  int bb;\n+\n+  sbitmap_vector_ones (transpout, n_basic_blocks);\n+\n+  for (bb = 0; bb < n_basic_blocks; ++bb)\n+    {\n+      int i;\n+\n+      /* Note that flow inserted a nop a the end of basic blocks that\n+\t end in call instructions for reasons other than abnormal\n+\t control flow.  */\n+      if (GET_CODE (BLOCK_END (bb)) != CALL_INSN)\n+\tcontinue;\n+\n+      for (i = 0; i < expr_hash_table_size; i++)\n+\t{\n+\t  struct expr *expr;\n+\t  for (expr = expr_hash_table[i]; expr ; expr = expr->next_same_hash)\n+\t    if (GET_CODE (expr->expr) == MEM)\n+\t      {\n+\t\trtx addr = XEXP (expr->expr, 0);\n+\n+\t\tif (GET_CODE (addr) == SYMBOL_REF\n+\t\t    && CONSTANT_POOL_ADDRESS_P (addr))\n+\t\t  continue;\n+\t\t\n+\t\t/* ??? Optimally, we would use interprocedural alias\n+\t\t   analysis to determine if this mem is actually killed\n+\t\t   by this call.  */\n+\t\tRESET_BIT (transpout[bb], expr->bitmap_index);\n+\t      }\n+\t}\n+    }\n+}"}]}