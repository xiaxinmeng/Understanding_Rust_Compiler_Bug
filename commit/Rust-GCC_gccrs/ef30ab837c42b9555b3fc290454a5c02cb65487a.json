{"sha": "ef30ab837c42b9555b3fc290454a5c02cb65487a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzMGFiODM3YzQyYjk1NTViM2ZjMjkwNDU0YTVjMDJjYjY1NDg3YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-10-19T20:19:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-10-19T20:19:15Z"}, "message": "asan.c (create_cond_insert_point): Do not update edge count.\n\n\n\t* asan.c (create_cond_insert_point): Do not update edge count.\n\t* auto-profile.c (afdo_propagate_edge): Update for edge count removal.\n\t(afdo_propagate_circuit): Likewise.\n\t(afdo_calculate_branch_prob): Likewise.\n\t(afdo_annotate_cfg): Likewise.\n\t* basic-block.h (struct edge_def): Remove count.\n\t(edge_def::count): New accessor.\n\t* bb-reorder.c (rotate_loop): Update.\n\t(find_traces_1_round): Update.\n\t(connect_traces): Update.\n\t(sanitize_hot_paths): Update.\n\t* cfg.c (unchecked_make_edge): Update.\n\t(make_single_succ_edge): Update.\n\t(check_bb_profile): Update.\n\t(dump_edge_info): Update.\n\t(update_bb_profile_for_threading): Update.\n\t(scale_bbs_frequencies_int): Update.\n\t(scale_bbs_frequencies_gcov_type): Update.\n\t(scale_bbs_frequencies_profile_count): Update.\n\t(scale_bbs_frequencies): Update.\n\t* cfganal.c (connect_infinite_loops_to_exit): Update.\n\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n\t(find_many_sub_basic_blocks): Update.\n\t* cfgcleanup.c (try_forward_edges): Update.\n\t(try_crossjump_to_edge): Update\n\t* cfgexpand.c (expand_gimple_cond): Update\n\t(expand_gimple_tailcall): Update\n\t(construct_exit_block): Update\n\t* cfghooks.c (verify_flow_info): Update\n\t(redirect_edge_succ_nodup): Update\n\t(split_edge): Update\n\t(make_forwarder_block): Update\n\t(duplicate_block): Update\n\t(account_profile_record): Update\n\t* cfgloop.c (find_subloop_latch_edge_by_profile): Update.\n\t* cfgloopanal.c (expected_loop_iterations_unbounded): Update.\n\t* cfgloopmanip.c (scale_loop_profile): Update.\n\t(loopify): Update.\n\t(lv_adjust_loop_entry_edge): Update.\n\t* cfgrtl.c (try_redirect_by_replacing_jump): Update.\n\t(force_nonfallthru_and_redirect): Update.\n\t(purge_dead_edges): Update.\n\t(rtl_flow_call_edges_add): Update.\n\t* cgraphunit.c (init_lowered_empty_function): Update.\n\t(cgraph_node::expand_thunk): Update.\n\t* gimple-pretty-print.c (dump_probability): Update.\n\t(dump_edge_probability): Update.\n\t* gimple-ssa-isolate-paths.c (isolate_path): Update.\n\t* haifa-sched.c (sched_create_recovery_edges): Update.\n\t* hsa-gen.c (convert_switch_statements): Update.\n\t* ifcvt.c (dead_or_predicable): Update.\n\t* ipa-inline-transform.c (inline_transform): Update.\n\t* ipa-split.c (split_function): Update.\n\t* ipa-utils.c (ipa_merge_profiles): Update.\n\t* loop-doloop.c (add_test): Update.\n\t* loop-unroll.c (unroll_loop_runtime_iterations): Update.\n\t* lto-streamer-in.c (input_cfg): Update.\n\t(input_function): Update.\n\t* lto-streamer-out.c (output_cfg): Update.\n\t* modulo-sched.c (sms_schedule): Update.\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Update.\n\t* predict.c (maybe_hot_edge_p): Update.\n\t(unlikely_executed_edge_p): Update.\n\t(probably_never_executed_edge_p): Update.\n\t(dump_prediction): Update.\n\t(drop_profile): Update.\n\t(propagate_unlikely_bbs_forward): Update.\n\t(determine_unlikely_bbs): Update.\n\t(force_edge_cold): Update.\n\t* profile.c (compute_branch_probabilities): Update.\n\t* reg-stack.c (better_edge): Update.\n\t* shrink-wrap.c (handle_simple_exit): Update.\n\t* tracer.c (better_p): Update.\n\t* trans-mem.c (expand_transaction): Update.\n\t(split_bb_make_tm_edge): Update.\n\t* tree-call-cdce.c: Update.\n\t* tree-cfg.c (gimple_find_sub_bbs): Update.\n\t(gimple_split_edge): Update.\n\t(gimple_duplicate_sese_region): Update.\n\t(gimple_duplicate_sese_tail): Update.\n\t(gimple_flow_call_edges_add): Update.\n\t(insert_cond_bb): Update.\n\t(execute_fixup_cfg): Update.\n\t* tree-cfgcleanup.c (cleanup_control_expr_graph): Update.\n\t* tree-complex.c (expand_complex_div_wide): Update.\n\t* tree-eh.c (lower_resx): Update.\n\t(unsplit_eh): Update.\n\t(cleanup_empty_eh_move_lp): Update.\n\t* tree-inline.c (copy_edges_for_bb): Update.\n\t(freqs_to_counts): Update.\n\t(copy_cfg_body): Update.\n\t* tree-ssa-dce.c (remove_dead_stmt): Update.\n\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Update.\n\t* tree-ssa-loop-im.c (execute_sm_if_changed): Update.\n\t* tree-ssa-loop-ivcanon.c (remove_exits_and_undefined_stmts): Update.\n\t(unloop_loops): Update.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n\t* tree-ssa-loop-split.c (connect_loops): Update.\n\t(split_loop): Update.\n\t* tree-ssa-loop-unswitch.c (hoist_guard): Update.\n\t* tree-ssa-phionlycprop.c (propagate_rhs_into_lhs): Update.\n\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Update.\n\t* tree-ssa-reassoc.c (branch_fixup): Update.\n\t* tree-ssa-tail-merge.c (replace_block_by): Update.\n\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Update.\n\t(compute_path_counts): Update.\n\t(update_profile): Update.\n\t(recompute_probabilities): Update.\n\t(update_joiner_offpath_counts): Update.\n\t(estimated_freqs_path): Update.\n\t(freqs_to_counts_path): Update.\n\t(clear_counts_path): Update.\n\t(ssa_fix_duplicate_block_edges): Update.\n\t(duplicate_thread_path): Update.\n\t* tree-switch-conversion.c (hoist_edge_and_branch_if_true): Update.\n\t(case_bit_test_cmp): Update.\n\t(collect_switch_conv_info): Update.\n\t(gen_inbound_check): Update.\n\t(do_jump_if_equal): Update.\n\t(emit_cmp_and_jump_insns): Update.\n\t* tree-tailcall.c (decrease_profile): Update.\n\t(eliminate_tail_call): Update.\n\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Update.\n\t(vect_do_peeling): Update.\n\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n\t* ubsan.c (ubsan_expand_null_ifn): Update.\n\t(ubsan_expand_ptr_ifn): Update.\n\t* value-prof.c (gimple_divmod_fixed_value): Update.\n\t(gimple_mod_pow2): Update.\n\t(gimple_mod_subtract): Update.\n\t(gimple_ic): Update.\n\t(gimple_stringop_fixed_value): Update.\n\nFrom-SVN: r253910", "tree": {"sha": "4369c2bc5c320d42e366fed603000b529e1d32b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4369c2bc5c320d42e366fed603000b529e1d32b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef30ab837c42b9555b3fc290454a5c02cb65487a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef30ab837c42b9555b3fc290454a5c02cb65487a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef30ab837c42b9555b3fc290454a5c02cb65487a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef30ab837c42b9555b3fc290454a5c02cb65487a/comments", "author": null, "committer": null, "parents": [{"sha": "68581ee1c343fb52065f6ff39ea0d84175b12a66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68581ee1c343fb52065f6ff39ea0d84175b12a66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68581ee1c343fb52065f6ff39ea0d84175b12a66"}], "stats": {"total": 1034, "additions": 386, "deletions": 648}, "files": [{"sha": "59bcbb4d5d78dd3996ed9b5ed286c192d03024d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1,3 +1,138 @@\n+2017-10-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* asan.c (create_cond_insert_point): Do not update edge count.\n+\t* auto-profile.c (afdo_propagate_edge): Update for edge count removal.\n+\t(afdo_propagate_circuit): Likewise.\n+\t(afdo_calculate_branch_prob): Likewise.\n+\t(afdo_annotate_cfg): Likewise.\n+\t* basic-block.h (struct edge_def): Remove count.\n+\t(edge_def::count): New accessor.\n+\t* bb-reorder.c (rotate_loop): Update.\n+\t(find_traces_1_round): Update.\n+\t(connect_traces): Update.\n+\t(sanitize_hot_paths): Update.\n+\t* cfg.c (unchecked_make_edge): Update.\n+\t(make_single_succ_edge): Update.\n+\t(check_bb_profile): Update.\n+\t(dump_edge_info): Update.\n+\t(update_bb_profile_for_threading): Update.\n+\t(scale_bbs_frequencies_int): Update.\n+\t(scale_bbs_frequencies_gcov_type): Update.\n+\t(scale_bbs_frequencies_profile_count): Update.\n+\t(scale_bbs_frequencies): Update.\n+\t* cfganal.c (connect_infinite_loops_to_exit): Update.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n+\t(find_many_sub_basic_blocks): Update.\n+\t* cfgcleanup.c (try_forward_edges): Update.\n+\t(try_crossjump_to_edge): Update\n+\t* cfgexpand.c (expand_gimple_cond): Update\n+\t(expand_gimple_tailcall): Update\n+\t(construct_exit_block): Update\n+\t* cfghooks.c (verify_flow_info): Update\n+\t(redirect_edge_succ_nodup): Update\n+\t(split_edge): Update\n+\t(make_forwarder_block): Update\n+\t(duplicate_block): Update\n+\t(account_profile_record): Update\n+\t* cfgloop.c (find_subloop_latch_edge_by_profile): Update.\n+\t* cfgloopanal.c (expected_loop_iterations_unbounded): Update.\n+\t* cfgloopmanip.c (scale_loop_profile): Update.\n+\t(loopify): Update.\n+\t(lv_adjust_loop_entry_edge): Update.\n+\t* cfgrtl.c (try_redirect_by_replacing_jump): Update.\n+\t(force_nonfallthru_and_redirect): Update.\n+\t(purge_dead_edges): Update.\n+\t(rtl_flow_call_edges_add): Update.\n+\t* cgraphunit.c (init_lowered_empty_function): Update.\n+\t(cgraph_node::expand_thunk): Update.\n+\t* gimple-pretty-print.c (dump_probability): Update.\n+\t(dump_edge_probability): Update.\n+\t* gimple-ssa-isolate-paths.c (isolate_path): Update.\n+\t* haifa-sched.c (sched_create_recovery_edges): Update.\n+\t* hsa-gen.c (convert_switch_statements): Update.\n+\t* ifcvt.c (dead_or_predicable): Update.\n+\t* ipa-inline-transform.c (inline_transform): Update.\n+\t* ipa-split.c (split_function): Update.\n+\t* ipa-utils.c (ipa_merge_profiles): Update.\n+\t* loop-doloop.c (add_test): Update.\n+\t* loop-unroll.c (unroll_loop_runtime_iterations): Update.\n+\t* lto-streamer-in.c (input_cfg): Update.\n+\t(input_function): Update.\n+\t* lto-streamer-out.c (output_cfg): Update.\n+\t* modulo-sched.c (sms_schedule): Update.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Update.\n+\t* predict.c (maybe_hot_edge_p): Update.\n+\t(unlikely_executed_edge_p): Update.\n+\t(probably_never_executed_edge_p): Update.\n+\t(dump_prediction): Update.\n+\t(drop_profile): Update.\n+\t(propagate_unlikely_bbs_forward): Update.\n+\t(determine_unlikely_bbs): Update.\n+\t(force_edge_cold): Update.\n+\t* profile.c (compute_branch_probabilities): Update.\n+\t* reg-stack.c (better_edge): Update.\n+\t* shrink-wrap.c (handle_simple_exit): Update.\n+\t* tracer.c (better_p): Update.\n+\t* trans-mem.c (expand_transaction): Update.\n+\t(split_bb_make_tm_edge): Update.\n+\t* tree-call-cdce.c: Update.\n+\t* tree-cfg.c (gimple_find_sub_bbs): Update.\n+\t(gimple_split_edge): Update.\n+\t(gimple_duplicate_sese_region): Update.\n+\t(gimple_duplicate_sese_tail): Update.\n+\t(gimple_flow_call_edges_add): Update.\n+\t(insert_cond_bb): Update.\n+\t(execute_fixup_cfg): Update.\n+\t* tree-cfgcleanup.c (cleanup_control_expr_graph): Update.\n+\t* tree-complex.c (expand_complex_div_wide): Update.\n+\t* tree-eh.c (lower_resx): Update.\n+\t(unsplit_eh): Update.\n+\t(cleanup_empty_eh_move_lp): Update.\n+\t* tree-inline.c (copy_edges_for_bb): Update.\n+\t(freqs_to_counts): Update.\n+\t(copy_cfg_body): Update.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Update.\n+\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Update.\n+\t* tree-ssa-loop-im.c (execute_sm_if_changed): Update.\n+\t* tree-ssa-loop-ivcanon.c (remove_exits_and_undefined_stmts): Update.\n+\t(unloop_loops): Update.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n+\t* tree-ssa-loop-split.c (connect_loops): Update.\n+\t(split_loop): Update.\n+\t* tree-ssa-loop-unswitch.c (hoist_guard): Update.\n+\t* tree-ssa-phionlycprop.c (propagate_rhs_into_lhs): Update.\n+\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Update.\n+\t* tree-ssa-reassoc.c (branch_fixup): Update.\n+\t* tree-ssa-tail-merge.c (replace_block_by): Update.\n+\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Update.\n+\t(compute_path_counts): Update.\n+\t(update_profile): Update.\n+\t(recompute_probabilities): Update.\n+\t(update_joiner_offpath_counts): Update.\n+\t(estimated_freqs_path): Update.\n+\t(freqs_to_counts_path): Update.\n+\t(clear_counts_path): Update.\n+\t(ssa_fix_duplicate_block_edges): Update.\n+\t(duplicate_thread_path): Update.\n+\t* tree-switch-conversion.c (hoist_edge_and_branch_if_true): Update.\n+\t(case_bit_test_cmp): Update.\n+\t(collect_switch_conv_info): Update.\n+\t(gen_inbound_check): Update.\n+\t(do_jump_if_equal): Update.\n+\t(emit_cmp_and_jump_insns): Update.\n+\t* tree-tailcall.c (decrease_profile): Update.\n+\t(eliminate_tail_call): Update.\n+\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Update.\n+\t(vect_do_peeling): Update.\n+\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n+\t* ubsan.c (ubsan_expand_null_ifn): Update.\n+\t(ubsan_expand_ptr_ifn): Update.\n+\t* value-prof.c (gimple_divmod_fixed_value): Update.\n+\t(gimple_mod_pow2): Update.\n+\t(gimple_mod_subtract): Update.\n+\t(gimple_ic): Update.\n+\t(gimple_stringop_fixed_value): Update.\n+\n 2017-10-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/82618"}, {"sha": "302ac4fcdecf20899c561a6124f6158b757c1cc3", "filename": "gcc/asan.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1807,7 +1807,6 @@ create_cond_insert_point (gimple_stmt_iterator *iter,\n   /* Set up the fallthrough basic block.  */\n   e = find_edge (cond_bb, fallthru_bb);\n   e->flags = EDGE_FALSE_VALUE;\n-  e->count = cond_bb->count;\n   e->probability = fallthrough_probability;\n \n   /* Update dominance info for the newly created then_bb; note that"}, {"sha": "378f48037ededcf4bc21e6d3ba2065830e80f861", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1234,7 +1234,7 @@ afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n       if (!is_edge_annotated (e, *annotated_edge))\n \tnum_unknown_edge++, unknown_edge = e;\n       else\n-\ttotal_known_count += e->count;\n+\ttotal_known_count += e->count ();\n \n     if (num_unknown_edge == 0)\n       {\n@@ -1251,7 +1251,8 @@ afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n       }\n     else if (num_unknown_edge == 1 && is_bb_annotated (bb, *annotated_bb))\n       {\n-        unknown_edge->count = bb->count - total_known_count;\n+        unknown_edge->probability\n+\t  = total_known_count.probability_in (bb->count);\n         set_edge_annotated (unknown_edge, annotated_edge);\n         changed = true;\n       }\n@@ -1349,15 +1350,13 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n           if (!e->probability.initialized_p ()\n \t      && !is_edge_annotated (ep, *annotated_edge))\n             {\n-              ep->probability = profile_probability::never ();\n-              ep->count = profile_count::zero ().afdo ();\n+              ep->probability = profile_probability::never ().afdo ();\n               set_edge_annotated (ep, annotated_edge);\n             }\n         }\n       if (total == 1 && !is_edge_annotated (only_one, *annotated_edge))\n         {\n           only_one->probability = e->probability;\n-          only_one->count = e->count;\n           set_edge_annotated (only_one, annotated_edge);\n         }\n     }\n@@ -1433,23 +1432,16 @@ afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n       if (!is_edge_annotated (e, *annotated_edge))\n         num_unknown_succ++;\n       else\n-        total_count += e->count;\n+        total_count += e->count ();\n     }\n     if (num_unknown_succ == 0 && total_count > profile_count::zero ())\n       {\n         FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->probability = e->count.probability_in (total_count);\n+          e->probability = e->count ().probability_in (total_count);\n       }\n   }\n   FOR_ALL_BB_FN (bb, cfun)\n-  {\n-    edge e;\n-    edge_iterator ei;\n-\n-    FOR_EACH_EDGE (e, ei, bb->succs)\n-      e->count = bb->count.apply_probability (e->probability);\n     bb->aux = NULL;\n-  }\n \n   loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n@@ -1551,7 +1543,7 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n        counters are zero when not seen by autoFDO.  */\n     bb->count = profile_count::zero ().afdo ();\n     FOR_EACH_EDGE (e, ei, bb->succs)\n-      e->count = profile_count::zero ().afdo ();\n+      e->probability = profile_probability::uninitialized ();\n \n     if (afdo_set_bb_count (bb, promoted_stmts))\n       set_bb_annotated (bb, &annotated_bb);"}, {"sha": "1505cce81bf589483c93495263830080f4590cd7", "filename": "gcc/basic-block.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -46,8 +46,9 @@ struct GTY((user)) edge_def {\n \n   int flags;\t\t\t/* see cfg-flags.def */\n   profile_probability probability;\n-  profile_count count;\t\t/* Expected number of executions calculated\n-\t\t\t\t   in profile.c  */\n+\n+  /* Return count of edge E.  */\n+  inline profile_count count () const;\n };\n \n /* Masks for edge.flags.  */\n@@ -639,4 +640,10 @@ has_abnormal_call_or_eh_pred_edge_p (basic_block bb)\n   return false;\n }\n \n+/* Return count of edge E.  */\n+inline profile_count edge_def::count () const\n+{\n+  return src->count.apply_probability (probability);\n+}\n+\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "dc2025fac9c19be07a9df451d4071e0b144ab1db", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -374,11 +374,11 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t{\n \t\t  /* The current edge E is also preferred.  */\n \t\t  int freq = EDGE_FREQUENCY (e);\n-\t\t  if (freq > best_freq || e->count > best_count)\n+\t\t  if (freq > best_freq || e->count () > best_count)\n \t\t    {\n \t\t      best_freq = freq;\n-\t\t      if (e->count.initialized_p ())\n-\t\t        best_count = e->count;\n+\t\t      if (e->count ().initialized_p ())\n+\t\t        best_count = e->count ();\n \t\t      best_edge = e;\n \t\t      best_bb = bb;\n \t\t    }\n@@ -392,17 +392,17 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t  /* The current edge E is preferred.  */\n \t\t  is_preferred = true;\n \t\t  best_freq = EDGE_FREQUENCY (e);\n-\t\t  best_count = e->count;\n+\t\t  best_count = e->count ();\n \t\t  best_edge = e;\n \t\t  best_bb = bb;\n \t\t}\n \t      else\n \t\t{\n \t\t  int freq = EDGE_FREQUENCY (e);\n-\t\t  if (!best_edge || freq > best_freq || e->count > best_count)\n+\t\t  if (!best_edge || freq > best_freq || e->count () > best_count)\n \t\t    {\n \t\t      best_freq = freq;\n-\t\t      best_count = e->count;\n+\t\t      best_count = e->count ();\n \t\t      best_edge = e;\n \t\t      best_bb = bb;\n \t\t    }\n@@ -571,7 +571,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  || !prob.initialized_p ()\n \t\t  || ((prob.to_reg_br_prob_base () < branch_th\n \t\t       || EDGE_FREQUENCY (e) < exec_th\n-\t\t      || e->count < count_th) && (!for_size)))\n+\t\t      || e->count () < count_th) && (!for_size)))\n \t\tcontinue;\n \n \t      /* If partitioning hot/cold basic blocks, don't consider edges\n@@ -656,7 +656,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t      || !prob.initialized_p ()\n \t\t      || prob.to_reg_br_prob_base () < branch_th\n \t\t      || freq < exec_th\n-\t\t      || e->count < count_th)\n+\t\t      || e->count () < count_th)\n \t\t    {\n \t\t      /* When partitioning hot/cold basic blocks, make sure\n \t\t\t the cold blocks (and only the cold blocks) all get\n@@ -1285,7 +1285,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t\t&& !connected[bbd[di].start_of_trace]\n \t\t\t\t&& BB_PARTITION (e2->dest) == current_partition\n \t\t\t\t&& EDGE_FREQUENCY (e2) >= freq_threshold\n-\t\t\t\t&& e2->count >= count_threshold\n+\t\t\t\t&& e2->count () >= count_threshold\n \t\t\t\t&& (!best2\n \t\t\t\t    || e2->probability > best2->probability\n \t\t\t\t    || (e2->probability == best2->probability\n@@ -1311,8 +1311,8 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t  && copy_bb_p (best->dest,\n \t\t\t\toptimize_edge_for_speed_p (best)\n \t\t\t\t&& EDGE_FREQUENCY (best) >= freq_threshold\n-\t\t\t\t&& (!best->count.initialized_p ()\n-\t\t\t\t    || best->count >= count_threshold)))\n+\t\t\t\t&& (!best->count ().initialized_p ()\n+\t\t\t\t    || best->count () >= count_threshold)))\n \t\t{\n \t\t  basic_block new_bb;\n \n@@ -1528,7 +1528,7 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n \n \t  /* Do not expect profile insanities when profile was not adjusted.  */\n \t  if (e->probability == profile_probability::never ()\n-\t      || e->count == profile_count::zero ())\n+\t      || e->count () == profile_count::zero ())\n \t    continue;\n \n           if (BB_PARTITION (reach_bb) != BB_COLD_PARTITION)\n@@ -1539,8 +1539,8 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n           /* The following loop will look for the hottest edge via\n              the edge count, if it is non-zero, then fallback to the edge\n              frequency and finally the edge probability.  */\n-          if (!highest_count.initialized_p () || e->count > highest_count)\n-            highest_count = e->count;\n+          if (!highest_count.initialized_p () || e->count () > highest_count)\n+            highest_count = e->count ();\n           int edge_freq = EDGE_FREQUENCY (e);\n           if (edge_freq > highest_freq)\n             highest_freq = edge_freq;\n@@ -1563,14 +1563,14 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n             continue;\n \t  /* Do not expect profile insanities when profile was not adjusted.  */\n \t  if (e->probability == profile_probability::never ()\n-\t      || e->count == profile_count::zero ())\n+\t      || e->count () == profile_count::zero ())\n \t    continue;\n           /* Select the hottest edge using the edge count, if it is non-zero,\n              then fallback to the edge frequency and finally the edge\n              probability.  */\n           if (highest_count > 0)\n             {\n-              if (e->count < highest_count)\n+              if (e->count () < highest_count)\n                 continue;\n             }\n           else if (highest_freq)"}, {"sha": "41002ec00910b50787ba5f010ce3dc95797a1a19", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -263,7 +263,6 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n   e = ggc_cleared_alloc<edge_def> ();\n   n_edges_for_fn (cfun)++;\n \n-  e->count = profile_count::uninitialized ();\n   e->probability = profile_probability::uninitialized ();\n   e->src = src;\n   e->dest = dst;\n@@ -334,7 +333,6 @@ make_single_succ_edge (basic_block src, basic_block dest, int flags)\n   edge e = make_edge (src, dest, flags);\n \n   e->probability = profile_probability::always ();\n-  e->count = src->count;\n   return e;\n }\n \n@@ -445,18 +443,6 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n \t\t       \";; %sInvalid sum of outgoing probabilities %.1f%%\\n\",\n \t\t       s_indent, isum * 100.0 / REG_BR_PROB_BASE);\n \t    }\n-\t  profile_count lsum = profile_count::zero ();\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    lsum += e->count;\n-\t  if (EDGE_COUNT (bb->succs) && lsum.differs_from_p (bb->count))\n-\t    {\n-\t      fprintf (file, \";; %sInvalid sum of outgoing counts \",\n-\t\t       s_indent);\n-\t      lsum.dump (file);\n-\t      fprintf (file, \", should be \");\n-\t      bb->count.dump (file);\n-\t      fprintf (file, \"\\n\");\n-\t    }\n \t}\n     }\n   if (bb != ENTRY_BLOCK_PTR_FOR_FN (fun))\n@@ -468,18 +454,6 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n \tfprintf (file,\n \t\t \";; %sInvalid sum of incoming frequencies %i, should be %i\\n\",\n \t\t s_indent, sum, bb->frequency);\n-      profile_count lsum = profile_count::zero ();\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tlsum += e->count;\n-      if (lsum.differs_from_p (bb->count))\n-\t{\n-\t  fprintf (file, \";; %sInvalid sum of incoming counts \",\n-\t\t   s_indent);\n-\t  lsum.dump (file);\n-\t  fprintf (file, \", should be \");\n-\t  bb->count.dump (file);\n-\t  fprintf (file, \"\\n\");\n-\t}\n     }\n   if (BB_PARTITION (bb) == BB_COLD_PARTITION)\n     {\n@@ -522,10 +496,10 @@ dump_edge_info (FILE *file, edge e, dump_flags_t flags, int do_succ)\n       fprintf (file, \"] \");\n     }\n \n-  if (e->count.initialized_p () && do_details)\n+  if (e->count ().initialized_p () && do_details)\n     {\n       fputs (\" count:\", file);\n-      e->count.dump (file);\n+      e->count ().dump (file);\n     }\n \n   if (e->flags && do_details)\n@@ -941,10 +915,6 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n     }\n \n   gcc_assert (bb == taken_edge->src);\n-  if (dump_file && taken_edge->count < count)\n-    fprintf (dump_file, \"edge %i->%i count became negative after threading\",\n-\t     taken_edge->src->index, taken_edge->dest->index);\n-  taken_edge->count -= count;\n }\n \n /* Multiply all frequencies of basic blocks in array BBS of length NBBS\n@@ -953,7 +923,6 @@ void\n scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n {\n   int i;\n-  edge e;\n   if (num < 0)\n     num = 0;\n \n@@ -973,14 +942,11 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n \n   for (i = 0; i < nbbs; i++)\n     {\n-      edge_iterator ei;\n       bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n       /* Make sure the frequencies do not grow over BB_FREQ_MAX.  */\n       if (bbs[i]->frequency > BB_FREQ_MAX)\n \tbbs[i]->frequency = BB_FREQ_MAX;\n       bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n-      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\te->count = e->count.apply_scale (num, den);\n     }\n }\n \n@@ -996,37 +962,27 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n \t\t\t\t gcov_type den)\n {\n   int i;\n-  edge e;\n   gcov_type fraction = RDIV (num * 65536, den);\n \n   gcc_assert (fraction >= 0);\n \n   if (num < MAX_SAFE_MULTIPLIER)\n     for (i = 0; i < nbbs; i++)\n       {\n-\tedge_iterator ei;\n \tbbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n \tif (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n \t  bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n \telse\n \t  bbs[i]->count = bbs[i]->count.apply_scale (fraction, 65536);\n-\tFOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\t  if (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n-\t    e->count =  e->count.apply_scale (num, den);\n-\t  else\n-\t    e->count = e->count.apply_scale (fraction, 65536);\n       }\n    else\n     for (i = 0; i < nbbs; i++)\n       {\n-\tedge_iterator ei;\n \tif (sizeof (gcov_type) > sizeof (int))\n \t  bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n \telse\n \t  bbs[i]->frequency = RDIV (bbs[i]->frequency * fraction, 65536);\n \tbbs[i]->count = bbs[i]->count.apply_scale (fraction, 65536);\n-\tFOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\t  e->count = e->count.apply_scale (fraction, 65536);\n       }\n }\n \n@@ -1038,16 +994,12 @@ scale_bbs_frequencies_profile_count (basic_block *bbs, int nbbs,\n \t\t\t\t     profile_count num, profile_count den)\n {\n   int i;\n-  edge e;\n \n   for (i = 0; i < nbbs; i++)\n     {\n-      edge_iterator ei;\n       bbs[i]->frequency = RDIV (bbs[i]->frequency * num.to_gcov_type (),\n \t\t\t\tden.to_gcov_type ());\n       bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n-      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\te->count =  e->count.apply_scale (num, den);\n     }\n }\n \n@@ -1059,15 +1011,11 @@ scale_bbs_frequencies (basic_block *bbs, int nbbs,\n \t\t       profile_probability p)\n {\n   int i;\n-  edge e;\n \n   for (i = 0; i < nbbs; i++)\n     {\n-      edge_iterator ei;\n       bbs[i]->frequency = p.apply (bbs[i]->frequency);\n       bbs[i]->count = bbs[i]->count.apply_probability (p);\n-      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\te->count =  e->count.apply_probability (p);\n     }\n }\n "}, {"sha": "c506067fdcd1962d8442b51c35aa21650538215f", "filename": "gcc/cfganal.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -612,7 +612,6 @@ connect_infinite_loops_to_exit (void)\n       basic_block deadend_block = dfs_find_deadend (unvisited_block);\n       edge e = make_edge (deadend_block, EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t\t\t  EDGE_FAKE);\n-      e->count = profile_count::zero ();\n       e->probability = profile_probability::never ();\n       dfs.add_bb (deadend_block);\n     }"}, {"sha": "c6d506ae474261c83974dcd6c05b674b4fe19e60", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -576,10 +576,8 @@ compute_outgoing_frequencies (basic_block b)\n \t  e = BRANCH_EDGE (b);\n \t  e->probability\n \t\t = profile_probability::from_reg_br_prob_note (probability);\n-\t  e->count = b->count.apply_probability (e->probability);\n \t  f = FALLTHRU_EDGE (b);\n \t  f->probability = e->probability.invert ();\n-\t  f->count = b->count - e->count;\n \t  return;\n \t}\n       else\n@@ -591,7 +589,6 @@ compute_outgoing_frequencies (basic_block b)\n     {\n       e = single_succ_edge (b);\n       e->probability = profile_probability::always ();\n-      e->count = b->count;\n       return;\n     }\n   else\n@@ -610,10 +607,6 @@ compute_outgoing_frequencies (basic_block b)\n       if (complex_edge)\n         guess_outgoing_edge_probabilities (b);\n     }\n-\n-  if (b->count.initialized_p ())\n-    FOR_EACH_EDGE (e, ei, b->succs)\n-      e->count = b->count.apply_probability (e->probability);\n }\n \n /* Assume that some pass has inserted labels or control flow\n@@ -679,9 +672,9 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t    bb->frequency = 0;\n \t    FOR_EACH_EDGE (e, ei, bb->preds)\n \t      {\n-\t\tif (e->count.initialized_p ())\n+\t\tif (e->count ().initialized_p ())\n \t\t  {\n-\t\t    bb->count += e->count;\n+\t\t    bb->count += e->count ();\n \t\t    initialized_src = true;\n \t\t  }\n \t\telse"}, {"sha": "c2b0434f179bde595dea280f9dece9315caeda86", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -558,7 +558,7 @@ try_forward_edges (int mode, basic_block b)\n       else\n \t{\n \t  /* Save the values now, as the edge may get removed.  */\n-\t  profile_count edge_count = e->count;\n+\t  profile_count edge_count = e->count ();\n \t  profile_probability edge_probability = e->probability;\n \t  int edge_frequency;\n \t  int n = 0;\n@@ -616,7 +616,6 @@ try_forward_edges (int mode, basic_block b)\n \t\t  t = single_succ_edge (first);\n \t\t}\n \n-\t      t->count -= edge_count;\n \t      first = t->dest;\n \t    }\n \t  while (first != target);\n@@ -2129,22 +2128,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \t    break;\n \t}\n \n-      s->count += s2->count;\n-\n       /* Take care to update possible forwarder blocks.  We verified\n \t that there is no more than one in the chain, so we can't run\n \t into infinite loop.  */\n       if (FORWARDER_BLOCK_P (s->dest))\n \t{\n-\t  single_succ_edge (s->dest)->count += s2->count;\n-\t  s->dest->count += s2->count;\n \t  s->dest->frequency += EDGE_FREQUENCY (s);\n \t}\n \n       if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n-\t  single_succ_edge (s2->dest)->count -= s2->count;\n-\t  s2->dest->count -= s2->count;\n \t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n \t  if (s2->dest->frequency < 0)\n \t    s2->dest->frequency = 0;"}, {"sha": "a255ac3c6f094c3a0a3b5e4e64c02114a70eeb7b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -2507,7 +2507,7 @@ expand_gimple_cond (basic_block bb, gcond *stmt)\n   dest = false_edge->dest;\n   redirect_edge_succ (false_edge, new_bb);\n   false_edge->flags |= EDGE_FALLTHRU;\n-  new_bb->count = false_edge->count;\n+  new_bb->count = false_edge->count ();\n   new_bb->frequency = EDGE_FREQUENCY (false_edge);\n   loop_p loop = find_common_loop (bb->loop_father, dest->loop_father);\n   add_bb_to_loop (new_bb, loop);\n@@ -3817,20 +3817,17 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n      the exit block.  */\n \n   probability = profile_probability::never ();\n-  profile_count count = profile_count::zero ();\n \n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n       if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n \t{\n \t  if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n-\t      e->dest->count -= e->count;\n \t      e->dest->frequency -= EDGE_FREQUENCY (e);\n \t      if (e->dest->frequency < 0)\n \t\te->dest->frequency = 0;\n \t    }\n-\t  count += e->count;\n \t  probability += e->probability;\n \t  remove_edge (e);\n \t}\n@@ -3860,7 +3857,6 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n   e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_ABNORMAL\n \t\t | EDGE_SIBCALL);\n   e->probability = probability;\n-  e->count = count;\n   BB_END (bb) = last;\n   update_bb_for_insn (bb);\n \n@@ -5930,8 +5926,7 @@ construct_exit_block (void)\n   FOR_EACH_EDGE (e2, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (e2 != e)\n       {\n-\te->count -= e2->count;\n-\texit_block->count -= e2->count;\n+\texit_block->count -= e2->count ();\n \texit_block->frequency -= EDGE_FREQUENCY (e2);\n       }\n   if (exit_block->frequency < 0)"}, {"sha": "320036bc7577ce185d147da884eb4141dc688654", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -176,12 +176,6 @@ verify_flow_info (void)\n \t\t     e->src->index, e->dest->index);\n \t      err = 1;\n \t    }\n-\t  if (!e->count.verify ())\n-\t    {\n-\t      error (\"verify_flow_info: Wrong count of edge %i->%i\",\n-\t\t     e->src->index, e->dest->index);\n-\t      err = 1;\n-\t    }\n \n \t  last_visited [e->dest->index] = bb;\n \n@@ -453,7 +447,6 @@ redirect_edge_succ_nodup (edge e, basic_block new_succ)\n     {\n       s->flags |= e->flags;\n       s->probability += e->probability;\n-      s->count += e->count;\n       /* FIXME: This should be called via a hook and only for IR_GIMPLE.  */\n       redirect_edge_var_map_dup (s, e);\n       remove_edge (e);\n@@ -632,7 +625,7 @@ basic_block\n split_edge (edge e)\n {\n   basic_block ret;\n-  profile_count count = e->count;\n+  profile_count count = e->count ();\n   int freq = EDGE_FREQUENCY (e);\n   edge f;\n   bool irr = (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n@@ -649,7 +642,6 @@ split_edge (edge e)\n   ret->count = count;\n   ret->frequency = freq;\n   single_succ_edge (ret)->probability = profile_probability::always ();\n-  single_succ_edge (ret)->count = count;\n \n   if (irr)\n     {\n@@ -878,7 +870,6 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   dummy = fallthru->src;\n   dummy->count = profile_count::zero ();\n   dummy->frequency = 0;\n-  fallthru->count = profile_count::zero ();\n   bb = fallthru->dest;\n \n   /* Redirect back edges we want to keep.  */\n@@ -892,8 +883,7 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \t  if (dummy->frequency > BB_FREQ_MAX)\n \t    dummy->frequency = BB_FREQ_MAX;\n \n-\t  dummy->count += e->count;\n-\t  fallthru->count += e->count;\n+\t  dummy->count += e->count ();\n \t  ei_next (&ei);\n \t  continue;\n \t}\n@@ -1079,7 +1069,7 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n {\n   edge s, n;\n   basic_block new_bb;\n-  profile_count new_count = e ? e->count : profile_count::uninitialized ();\n+  profile_count new_count = e ? e->count (): profile_count::uninitialized ();\n   edge_iterator ei;\n \n   if (!cfg_hooks->duplicate_block)\n@@ -1103,13 +1093,6 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n \t is no need to actually check for duplicated edges.  */\n       n = unchecked_make_edge (new_bb, s->dest, s->flags);\n       n->probability = s->probability;\n-      if (e && bb->count > profile_count::zero ())\n-\t{\n-\t  n->count = s->count.apply_scale (new_count, bb->count);\n-\t  s->count -= n->count;\n-\t}\n-      else\n-\tn->count = s->count;\n       n->aux = s->aux;\n     }\n \n@@ -1473,7 +1456,7 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t    record->num_mismatched_freq_out[after_pass]++;\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    lsum += e->count;\n+\t    lsum += e->count ();\n \t  if (EDGE_COUNT (bb->succs) && (lsum.differs_from_p (bb->count)))\n \t    record->num_mismatched_count_out[after_pass]++;\n \t}\n@@ -1489,7 +1472,7 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t    record->num_mismatched_freq_in[after_pass]++;\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    lsum += e->count;\n+\t    lsum += e->count ();\n \t  if (lsum.differs_from_p (bb->count))\n \t    record->num_mismatched_count_in[after_pass]++;\n \t}"}, {"sha": "4b0374abefa5a0968026627977eb47e4387afcb9", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -599,12 +599,12 @@ find_subloop_latch_edge_by_profile (vec<edge> latches)\n \n   FOR_EACH_VEC_ELT (latches, i, e)\n     {\n-      if (e->count > mcount)\n+      if (e->count ()> mcount)\n \t{\n \t  me = e;\n-\t  mcount = e->count;\n+\t  mcount = e->count();\n \t}\n-      tcount += e->count;\n+      tcount += e->count();\n     }\n \n   if (!tcount.initialized_p () || tcount < HEAVY_EDGE_MIN_SAMPLES"}, {"sha": "15b39e335fd04ec67f1143f5a2136aeddf71e736", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -253,9 +253,9 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n \n       FOR_EACH_EDGE (e, ei, loop->header->preds)\n \tif (e->src == loop->latch)\n-\t  count_latch = e->count;\n+\t  count_latch = e->count ();\n \telse\n-\t  count_in += e->count;\n+\t  count_in += e->count ();\n \n       if (!count_latch.initialized_p ())\n \t;"}, {"sha": "af65183bfaa4163c8f6708288ed6322b8243a3ae", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -546,16 +546,12 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n \n \t  /* Probability of exit must be 1/iterations.  */\n \t  freq_delta = EDGE_FREQUENCY (e);\n+\t  count_delta = e->count ();\n \t  e->probability = profile_probability::always ()\n \t\t\t\t.apply_scale (1, iteration_bound);\n \t  other_e->probability = e->probability.invert ();\n \t  freq_delta -= EDGE_FREQUENCY (e);\n-\n-\t  /* Adjust counts accordingly.  */\n-\t  count_delta = e->count;\n-\t  e->count = e->src->count.apply_probability (e->probability);\n-\t  other_e->count = e->src->count.apply_probability (other_e->probability);\n-\t  count_delta -= e->count;\n+\t  count_delta -= e->count ();\n \n \t  /* If latch exists, change its frequency and count, since we changed\n \t     probability of exit.  Theoretically we should update everything from\n@@ -582,7 +578,7 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n \n \t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n \t    if (e->src != loop->latch)\n-\t      count_in += e->count;\n+\t      count_in += e->count ();\n \n \t  if (count_in > profile_count::zero () )\n \t    {\n@@ -872,14 +868,12 @@ loopify (edge latch_edge, edge header_edge,\n   struct loop *outer = loop_outer (succ_bb->loop_father);\n   int freq;\n   profile_count cnt;\n-  edge e;\n-  edge_iterator ei;\n \n   loop->header = header_edge->dest;\n   loop->latch = latch_edge->src;\n \n   freq = EDGE_FREQUENCY (header_edge);\n-  cnt = header_edge->count;\n+  cnt = header_edge->count ();\n \n   /* Redirect edges.  */\n   loop_redirect_edge (latch_edge, loop->header);\n@@ -912,10 +906,6 @@ loopify (edge latch_edge, edge header_edge,\n     {\n       switch_bb->frequency = freq;\n       switch_bb->count = cnt;\n-      FOR_EACH_EDGE (e, ei, switch_bb->succs)\n-\t{\n-\t  e->count = switch_bb->count.apply_probability (e->probability);\n-\t}\n     }\n   scale_loop_frequencies (loop, false_scale);\n   scale_loop_frequencies (succ_bb->loop_father, true_scale);\n@@ -1650,8 +1640,6 @@ lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n \t\t  current_ir_type () == IR_GIMPLE ? EDGE_TRUE_VALUE : 0);\n   e1->probability = then_prob;\n   e->probability = else_prob;\n-  e1->count = e->count.apply_probability (e1->probability);\n-  e->count = e->count.apply_probability (e->probability);\n \n   set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n   set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);"}, {"sha": "65e25dc1293349f2ecdc3f309635a4d7d9879381", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1156,7 +1156,6 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n     e->flags = 0;\n \n   e->probability = profile_probability::always ();\n-  e->count = src->count;\n \n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n@@ -1505,9 +1504,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t  int prob = XINT (note, 0);\n \n \t  b->probability = profile_probability::from_reg_br_prob_note (prob);\n-\t  b->count = e->count.apply_probability (b->probability);\n \t  e->probability -= e->probability;\n-\t  e->count -= b->count;\n \t}\n     }\n \n@@ -1615,7 +1612,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n   if (EDGE_COUNT (e->src->succs) >= 2 || abnormal_edge_flags || asm_goto_edge)\n     {\n       rtx_insn *new_head;\n-      profile_count count = e->count;\n+      profile_count count = e->count ();\n       profile_probability probability = e->probability;\n       /* Create the new structures.  */\n \n@@ -1640,7 +1637,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       /* Wire edge in.  */\n       new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n       new_edge->probability = probability;\n-      new_edge->count = count;\n \n       /* Redirect old edge.  */\n       redirect_edge_pred (e, jump_block);\n@@ -1655,13 +1651,11 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       if (asm_goto_edge)\n \t{\n \t  new_edge->probability = new_edge->probability.apply_scale (1, 2);\n-\t  new_edge->count = new_edge->count.apply_scale (1, 2);\n \t  jump_block->count = jump_block->count.apply_scale (1, 2);\n \t  jump_block->frequency /= 2;\n \t  edge new_edge2 = make_edge (new_edge->src, target,\n \t\t\t\t      e->flags & ~EDGE_FALLTHRU);\n \t  new_edge2->probability = probability - new_edge->probability;\n-\t  new_edge2->count = count - new_edge->count;\n \t}\n \n       new_bb = jump_block;\n@@ -3155,7 +3149,6 @@ purge_dead_edges (basic_block bb)\n       if (single_succ_p (bb))\n \t{\n \t  single_succ_edge (bb)->probability = profile_probability::always ();\n-\t  single_succ_edge (bb)->count = bb->count;\n \t}\n       else\n \t{\n@@ -3168,8 +3161,6 @@ purge_dead_edges (basic_block bb)\n \t  b->probability = profile_probability::from_reg_br_prob_note\n \t\t\t\t\t (XINT (note, 0));\n \t  f->probability = b->probability.invert ();\n-\t  b->count = bb->count.apply_probability (b->probability);\n-\t  f->count = bb->count.apply_probability (f->probability);\n \t}\n \n       return purged;\n@@ -3221,7 +3212,6 @@ purge_dead_edges (basic_block bb)\n   gcc_assert (single_succ_p (bb));\n \n   single_succ_edge (bb)->probability = profile_probability::always ();\n-  single_succ_edge (bb)->count = bb->count;\n \n   if (dump_file)\n     fprintf (dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n@@ -4906,7 +4896,6 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \n \t      edge ne = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n \t      ne->probability = profile_probability::guessed_never ();\n-\t      ne->count = profile_count::guessed_zero ();\n \t    }\n \n \t  if (insn == BB_HEAD (bb))"}, {"sha": "ea52f43dc6a7d9a6be54635112c8614eec104d8e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1608,10 +1608,8 @@ init_lowered_empty_function (tree decl, bool in_ssa, profile_count count)\n   bb->count = count;\n   bb->frequency = BB_FREQ_MAX;\n   e = make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FALLTHRU);\n-  e->count = count;\n   e->probability = profile_probability::always ();\n   e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-  e->count = count;\n   e->probability = profile_probability::always ();\n   add_bb_to_loop (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n \n@@ -1988,17 +1986,14 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t  e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n \t\t  e->probability = profile_probability::guessed_always ()\n \t\t\t\t\t.apply_scale (1, 16);\n-\t\t  e->count = count - count.apply_scale (1, 16);\n \t\t  e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n \t\t  e->probability = profile_probability::guessed_always ()\n \t\t\t\t\t.apply_scale (1, 16);\n-\t\t  e->count = count.apply_scale (1, 16);\n \t\t  make_single_succ_edge (return_bb,\n \t\t\t\t\t EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \t\t  make_single_succ_edge (then_bb, return_bb, EDGE_FALLTHRU);\n \t\t  e = make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n \t\t  e->probability = profile_probability::always ();\n-\t\t  e->count = count.apply_scale (1, 16);\n \t\t  bsi = gsi_last_bb (then_bb);\n \t\t}\n "}, {"sha": "0da90740165b1063f994b63288b709f45426f6ae", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -109,7 +109,7 @@ dump_profile (int frequency, profile_count &count)\n    by xstrdup_for_dump.  */\n \n static const char *\n-dump_probability (profile_probability probability, profile_count &count)\n+dump_probability (profile_probability probability)\n {\n   float minimum = 0.01f;\n   float fvalue = -1;\n@@ -122,13 +122,10 @@ dump_probability (profile_probability probability, profile_count &count)\n     }\n \n   char *buf;\n-  if (count.initialized_p ())\n-    buf = xasprintf (\"[%.2f%%] [count: %\" PRId64 \"]\", fvalue,\n-\t\t     count.to_gcov_type ());\n-  else if (probability.initialized_p ())\n-    buf = xasprintf (\"[%.2f%%] [count: INV]\", fvalue);\n+  if (probability.initialized_p ())\n+    buf = xasprintf (\"[%.2f%%]\", fvalue);\n   else\n-    buf = xasprintf (\"[INV] [count: INV]\");\n+    buf = xasprintf (\"[INV]\");\n \n   const char *ret = xstrdup_for_dump (buf);\n   free (buf);\n@@ -141,7 +138,7 @@ dump_probability (profile_probability probability, profile_count &count)\n static void\n dump_edge_probability (pretty_printer *buffer, edge e)\n {\n-  pp_scalar (buffer, \" %s\", dump_probability (e->probability, e->count));\n+  pp_scalar (buffer, \" %s\", dump_probability (e->probability));\n }\n \n /* Print GIMPLE statement G to FILE using SPC indentation spaces and"}, {"sha": "ba5c6a3a715328ae41b148420850d1fe8f8c0a84", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -169,7 +169,6 @@ isolate_path (basic_block bb, basic_block duplicate,\n \n       /* Update profile only when redirection is really processed.  */\n       bb->frequency += EDGE_FREQUENCY (e);\n-      bb->count += e->count;\n     }\n \n   /* There may be more than one statement in DUPLICATE which exhibits"}, {"sha": "0c73003ebcaabd30e1f357518e89d9b30d4ceac3", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -8311,11 +8311,9 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n      'todo_spec' variable in create_check_block_twin and\n      in sel-sched.c `check_ds' in create_speculation_check.  */\n   e->probability = profile_probability::very_unlikely ();\n-  e->count = first_bb->count.apply_probability (e->probability);\n-  rec->count = e->count;\n+  rec->count = e->count ();\n   rec->frequency = EDGE_FREQUENCY (e);\n   e2->probability = e->probability.invert ();\n-  e2->count = first_bb->count - e2->count;\n \n   rtx_code_label *label = block_label (second_bb);\n   rtx_jump_insn *jump = emit_jump_insn_after (targetm.gen_jump (label),"}, {"sha": "a2cb8b24e16f55e827ef6077d4816d3129162f9d", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -6269,7 +6269,7 @@ convert_switch_statements (void)\n \t    tree label = gimple_switch_label (s, i);\n \t    basic_block label_bb = label_to_block_fn (func, CASE_LABEL (label));\n \t    edge e = find_edge (bb, label_bb);\n-\t    edge_counts.safe_push (e->count);\n+\t    edge_counts.safe_push (e->count ());\n \t    edge_probabilities.safe_push (e->probability);\n \t    gphi_iterator phi_gsi;\n \n@@ -6359,7 +6359,6 @@ convert_switch_statements (void)\n \t    if (prob_sum.initialized_p ())\n \t      new_edge->probability = edge_probabilities[i] / prob_sum;\n \n-\t    new_edge->count = edge_counts[i];\n \t    new_edges.safe_push (new_edge);\n \n \t    if (i < labels - 1)\n@@ -6375,9 +6374,6 @@ convert_switch_statements (void)\n \n \t\tedge next_edge = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n \t\tnext_edge->probability = new_edge->probability.invert ();\n-\t\tnext_edge->count = edge_counts[0]\n-\t\t  + sum_slice <profile_count> (edge_counts, i, labels,\n-\t\t\t\t\t       profile_count::zero ());\n \t\tnext_bb->frequency = EDGE_FREQUENCY (next_edge);\n \t\tcur_bb = next_bb;\n \t      }\n@@ -6386,7 +6382,6 @@ convert_switch_statements (void)\n \t      {\n \t\tedge e = make_edge (cur_bb, default_label_bb, EDGE_FALSE_VALUE);\n \t\te->probability = new_edge->probability.invert ();\n-\t\te->count = edge_counts[0];\n \t\tnew_edges.safe_insert (0, e);\n \t      }\n \t  }"}, {"sha": "72bab82491f48ad7f054f0931ac22751d881302c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -5283,8 +5283,6 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       redirect_edge_succ (BRANCH_EDGE (test_bb), new_dest);\n       if (reversep)\n \t{\n-\t  std::swap (BRANCH_EDGE (test_bb)->count,\n-\t\t     FALLTHRU_EDGE (test_bb)->count);\n \t  std::swap (BRANCH_EDGE (test_bb)->probability,\n \t\t     FALLTHRU_EDGE (test_bb)->probability);\n \t  update_br_prob_note (test_bb);"}, {"sha": "1e7fafa1bff88f916d135589416433a0339245b1", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -692,14 +692,7 @@ inline_transform (struct cgraph_node *node)\n \n \t  basic_block bb;\n \t  FOR_ALL_BB_FN (bb, cfun)\n-\t    {\n-\t      bb->count = bb->count.apply_scale (num, den);\n-\t\n-\t      edge e;\n-\t      edge_iterator ei;\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\te->count = e->count.apply_scale (num, den);\n-\t    }\n+\t    bb->count = bb->count.apply_scale (num, den);\n \t  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = node->count;\n \t}\n       todo = optimize_inline_calls (current_function_decl);"}, {"sha": "f2d1478d5903f066f7e16e0f7eb2b1283a1f9c5d", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1285,7 +1285,6 @@ split_function (basic_block return_bb, struct split_point *split_point,\n \t  FOR_EACH_EDGE (e, ei, return_bb->preds)\n \t    if (bitmap_bit_p (split_point->split_bbs, e->src->index))\n \t      {\n-\t\tnew_return_bb->count += e->count;\n \t\tnew_return_bb->frequency += EDGE_FREQUENCY (e);\n \t\tredirect_edge_and_branch (e, new_return_bb);\n \t\tredirected = true;"}, {"sha": "a27e406efec95e974342092f1f6f1913c0ff65e1", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -524,20 +524,28 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t  unsigned int i;\n \n \t  dstbb = BASIC_BLOCK_FOR_FN (dstcfun, srcbb->index);\n-\t  if (dstbb->count.initialized_p ())\n-\t    dstbb->count += srcbb->count;\n-\t  else\n-\t    dstbb->count = srcbb->count;\n-\t  for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n+\t  if (!dstbb->count.initialized_p ())\n \t    {\n-\t      edge srce = EDGE_SUCC (srcbb, i);\n-\t      edge dste = EDGE_SUCC (dstbb, i);\n-\t      if (dstbb->count.initialized_p ())\n-\t        dste->count += srce->count;\n-\t      else\n-\t\tdste->count = srce->count;\n-\t      if (dstbb->count > 0 && dste->count.initialized_p ())\n-\t\tdste->probability = dste->count.probability_in (dstbb->count);\n+\t      dstbb->count = srcbb->count;\n+\t      for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n+\t\t{\n+\t\t  edge srce = EDGE_SUCC (srcbb, i);\n+\t\t  edge dste = EDGE_SUCC (dstbb, i);\n+\t\t  if (srce->probability.initialized_p ())\n+\t\t    dste->probability = srce->probability;\n+\t\t}\n+\t    }\t\n+\t  else if (srcbb->count.initialized_p ())\n+\t    {\n+\t      for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n+\t\t{\n+\t\t  edge srce = EDGE_SUCC (srcbb, i);\n+\t\t  edge dste = EDGE_SUCC (dstbb, i);\n+\t\t  dste->probability = \n+\t\t    dste->probability * dstbb->count.probability_in (dstbb->count + srcbb->count)\n+\t\t    + srce->probability * srcbb->count.probability_in (dstbb->count + srcbb->count);\n+\t\t}\n+\t      dstbb->count += srcbb->count;\n \t    }\n \t}\n       push_cfun (dstcfun);"}, {"sha": "421b35513d2a72f7ec84e0cd4b9aeaed6c4dbff6", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -393,9 +393,7 @@ add_test (rtx cond, edge *e, basic_block dest)\n \n   edge e2 = make_edge (bb, dest, (*e)->flags & ~EDGE_FALLTHRU);\n   e2->probability = prob;\n-  e2->count = e2->src->count.apply_probability (prob);\n   (*e)->probability = prob.invert ();\n-  (*e)->count = (*e)->count.apply_probability (prob);\n   update_br_prob_note (e2->src);\n   return true;\n }"}, {"sha": "816302b9e70d85029b43151275b1428fb4ab142b", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -977,7 +977,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   iter_count = new_count = swtch->count.apply_scale (1, max_unroll + 1);\n   swtch->frequency = new_freq;\n   swtch->count = new_count;\n-  single_succ_edge (swtch)->count = new_count;\n \n   for (i = 0; i < n_peel; i++)\n     {\n@@ -999,7 +998,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       /* Add in frequency/count of edge from switch block.  */\n       preheader->frequency += iter_freq;\n       preheader->count += iter_count;\n-      single_succ_edge (preheader)->count = preheader->count;\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n \t\t\t\t\t  block_label (preheader), p,\n \t\t\t\t\t  NULL);\n@@ -1011,14 +1009,12 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       swtch = split_edge_and_insert (single_pred_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       single_succ_edge (swtch)->probability = p.invert ();\n-      single_succ_edge (swtch)->count = new_count;\n       new_freq += iter_freq;\n       new_count += iter_count;\n       swtch->frequency = new_freq;\n       swtch->count = new_count;\n       e = make_edge (swtch, preheader,\n \t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n-      e->count = iter_count;\n       e->probability = p;\n     }\n \n@@ -1035,7 +1031,6 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       /* Add in frequency/count of edge from switch block.  */\n       preheader->frequency += iter_freq;\n       preheader->count += iter_count;\n-      single_succ_edge (preheader)->count = preheader->count;\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n \t\t\t\t\t  block_label (preheader), p,\n \t\t\t\t\t  NULL);\n@@ -1044,10 +1039,8 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       swtch = split_edge_and_insert (single_succ_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       single_succ_edge (swtch)->probability = p.invert ();\n-      single_succ_edge (swtch)->count -= iter_count;\n       e = make_edge (swtch, preheader,\n \t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n-      e->count = iter_count;\n       e->probability = p;\n     }\n "}, {"sha": "ea6f92b174f5d65b1f88d9b5a4cb11661bff0a7f", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -715,8 +715,7 @@ make_new_block (struct function *fn, unsigned int index)\n \n static void\n input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n-\t   struct function *fn,\n-\t   int count_materialization_scale)\n+\t   struct function *fn)\n {\n   unsigned int bb_count;\n   basic_block p_bb;\n@@ -756,13 +755,10 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n \t  unsigned int edge_flags;\n \t  basic_block dest;\n \t  profile_probability probability;\n-\t  profile_count count;\n \t  edge e;\n \n \t  dest_index = streamer_read_uhwi (ib);\n \t  probability = profile_probability::stream_in (ib);\n-\t  count = profile_count::stream_in (ib).apply_scale\n-\t\t\t (count_materialization_scale, REG_BR_PROB_BASE);\n \t  edge_flags = streamer_read_uhwi (ib);\n \n \t  dest = BASIC_BLOCK_FOR_FN (fn, dest_index);\n@@ -772,7 +768,6 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n \n \t  e = make_edge (bb, dest, edge_flags);\n \t  e->probability = probability;\n-\t  e->count = count;\n \t}\n \n       index = streamer_read_hwi (ib);\n@@ -1070,7 +1065,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n   if (!node)\n     node = cgraph_node::create (fn_decl);\n   input_struct_function_base (fn, data_in, ib);\n-  input_cfg (ib_cfg, data_in, fn, node->count_materialization_scale);\n+  input_cfg (ib_cfg, data_in, fn);\n \n   /* Read all the SSA names.  */\n   input_ssa_names (ib, data_in, fn);"}, {"sha": "d007c0af5d66a37edc44b46a7ef5f51970a8086a", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1883,7 +1883,6 @@ output_cfg (struct output_block *ob, struct function *fn)\n \t{\n \t  streamer_write_uhwi (ob, e->dest->index);\n \t  e->probability.stream_out (ob);\n-\t  e->count.stream_out (ob);\n \t  streamer_write_uhwi (ob, e->flags);\n \t}\n     }"}, {"sha": "71b2a6160964f163c60e9c707ce996a7ce4dfe43", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1422,15 +1422,15 @@ sms_schedule (void)\n       get_ebb_head_tail (bb, bb, &head, &tail);\n       latch_edge = loop_latch_edge (loop);\n       gcc_assert (single_exit (loop));\n-      if (single_exit (loop)->count > profile_count::zero ())\n-\ttrip_count = latch_edge->count.to_gcov_type ()\n-\t\t     / single_exit (loop)->count.to_gcov_type ();\n+      if (single_exit (loop)->count () > profile_count::zero ())\n+\ttrip_count = latch_edge->count ().to_gcov_type ()\n+\t\t     / single_exit (loop)->count ().to_gcov_type ();\n \n       /* Perform SMS only on loops that their average count is above threshold.  */\n \n-      if ( latch_edge->count > profile_count::zero ()\n-          && (latch_edge->count\n-\t      < single_exit (loop)->count.apply_scale\n+      if ( latch_edge->count () > profile_count::zero ()\n+          && (latch_edge->count()\n+\t      < single_exit (loop)->count ().apply_scale\n \t\t\t\t (SMS_LOOP_AVERAGE_COUNT_THRESHOLD, 1)))\n \t{\n \t  if (dump_file)\n@@ -1552,9 +1552,9 @@ sms_schedule (void)\n \n       latch_edge = loop_latch_edge (loop);\n       gcc_assert (single_exit (loop));\n-      if (single_exit (loop)->count > profile_count::zero ())\n-\ttrip_count = latch_edge->count.to_gcov_type ()\n-\t\t     / single_exit (loop)->count.to_gcov_type ();\n+      if (single_exit (loop)->count ()> profile_count::zero ())\n+\ttrip_count = latch_edge->count ().to_gcov_type ()\n+\t\t     / single_exit (loop)->count ().to_gcov_type ();\n \n       if (dump_file)\n \t{"}, {"sha": "15fdb7e0cfe7767e559cd9ef6d5f66d3501ffd90", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1108,14 +1108,14 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \t    avail_insn = NULL;\n \t}\n \n-      if (EDGE_CRITICAL_P (pred) && pred->count.initialized_p ())\n-\tcritical_count += pred->count;\n+      if (EDGE_CRITICAL_P (pred) && pred->count ().initialized_p ())\n+\tcritical_count += pred->count ();\n \n       if (avail_insn != NULL_RTX)\n \t{\n \t  npred_ok++;\n-\t  if (pred->count.initialized_p ())\n-\t    ok_count = ok_count + pred->count;\n+\t  if (pred->count ().initialized_p ())\n+\t    ok_count = ok_count + pred->count ();\n \t  if (! set_noop_p (PATTERN (gen_move_insn (copy_rtx (dest),\n \t\t\t\t\t\t    copy_rtx (avail_reg)))))\n \t    {\n@@ -1139,8 +1139,8 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \t  /* Adding a load on a critical edge will cause a split.  */\n \t  if (EDGE_CRITICAL_P (pred))\n \t    critical_edge_split = true;\n-\t  if (pred->count.initialized_p ())\n-\t    not_ok_count = not_ok_count + pred->count;\n+\t  if (pred->count ().initialized_p ())\n+\t    not_ok_count = not_ok_count + pred->count ();\n \t  unoccr = (struct unoccr *) obstack_alloc (&unoccr_obstack,\n \t\t\t\t\t\t    sizeof (struct unoccr));\n \t  unoccr->insn = NULL;"}, {"sha": "0a85d0b00b43dc7850df7329eb124fbb34973d6d", "filename": "gcc/predict.c", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -203,7 +203,7 @@ maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n bool\n maybe_hot_edge_p (edge e)\n {\n-  if (!maybe_hot_count_p (cfun, e->count))\n+  if (!maybe_hot_count_p (cfun, e->count ()))\n     return false;\n   return maybe_hot_frequency_p (cfun, EDGE_FREQUENCY (e));\n }\n@@ -247,7 +247,7 @@ probably_never_executed_bb_p (struct function *fun, const_basic_block bb)\n static bool\n unlikely_executed_edge_p (edge e)\n {\n-  return (e->count == profile_count::zero ()\n+  return (e->count () == profile_count::zero ()\n \t  || e->probability == profile_probability::never ())\n \t || (e->flags & (EDGE_EH | EDGE_FAKE));\n }\n@@ -259,7 +259,7 @@ probably_never_executed_edge_p (struct function *fun, edge e)\n {\n   if (unlikely_executed_edge_p (e))\n     return true;\n-  return probably_never_executed (fun, e->count, EDGE_FREQUENCY (e));\n+  return probably_never_executed (fun, e->count (), EDGE_FREQUENCY (e));\n }\n \n /* Return true when current function should always be optimized for size.  */\n@@ -746,8 +746,8 @@ dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n       if (e)\n \t{\n \t  fprintf (file, \" hit \");\n-\t  e->count.dump (file);\n-\t  fprintf (file, \" (%.1f%%)\", e->count.to_gcov_type() * 100.0\n+\t  e->count ().dump (file);\n+\t  fprintf (file, \" (%.1f%%)\", e->count ().to_gcov_type() * 100.0\n \t\t   / bb->count.to_gcov_type ());\n \t}\n     }\n@@ -3199,21 +3199,14 @@ drop_profile (struct cgraph_node *node, profile_count call_count)\n   FOR_ALL_BB_FN (bb, fn)\n     {\n       bb->count = profile_count::uninitialized ();\n-\n-      edge_iterator ei;\n-      edge e;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\te->count = profile_count::uninitialized ();\n     }\n \n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_caller)\n     {\n-      e->count = profile_count::uninitialized ();\n       e->frequency = compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t\t     gimple_bb (e->call_stmt));\n     }\n-  node->count = profile_count::uninitialized ();\n   \n   profile_status_for_fn (fn)\n       = (flag_guess_branch_prob ? PROFILE_GUESSED : PROFILE_ABSENT);\n@@ -3396,7 +3389,7 @@ propagate_unlikely_bbs_forward (void)\n \t{\n \t  bb = worklist.pop ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (!(e->count == profile_count::zero ())\n+\t    if (!(e->count () == profile_count::zero ())\n \t\t&& !(e->dest->count == profile_count::zero ())\n \t\t&& !e->dest->aux)\n \t      {\n@@ -3417,8 +3410,6 @@ propagate_unlikely_bbs_forward (void)\n \t\t     bb->index);\n \t  bb->count = profile_count::zero ();\n \t  bb->frequency = 0;\n-          FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    e->count = profile_count::zero ();\n \t}\n       else\n         bb->aux = NULL;\n@@ -3450,20 +3441,16 @@ determine_unlikely_bbs ()\n \t}\n \n       if (bb->count == profile_count::zero ())\n-\t{\n-\t  bb->frequency = 0;\n-          FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    e->count = profile_count::zero ();\n-\t}\n+        bb->frequency = 0;\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (!(e->count == profile_count::zero ())\n+\tif (!(e->probability == profile_probability::never ())\n \t    && unlikely_executed_edge_p (e))\n \t  {\n             if (dump_file && (dump_flags & TDF_DETAILS))\n \t      fprintf (dump_file, \"Edge %i->%i is locally unlikely\\n\",\n \t\t       bb->index, e->dest->index);\n-\t    e->count = profile_count::zero ();\n+\t    e->probability = profile_probability::never ();\n \t  }\n \n       gcc_checking_assert (!bb->aux);\n@@ -3477,7 +3464,8 @@ determine_unlikely_bbs ()\n       {\n \tnsuccs[bb->index] = 0;\n         FOR_EACH_EDGE (e, ei, bb->succs)\n-\t  if (!(e->count == profile_count::zero ()))\n+\t  if (!(e->probability == profile_probability::never ())\n+\t      && !(e->dest->count == profile_count::zero ()))\n \t    nsuccs[bb->index]++;\n \tif (!nsuccs[bb->index])\n \t  worklist.safe_push (bb);\n@@ -3511,9 +3499,9 @@ determine_unlikely_bbs ()\n       bb->count = profile_count::zero ();\n       bb->frequency = 0;\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (!(e->count == profile_count::zero ()))\n+\tif (!(e->probability == profile_probability::never ()))\n \t  {\n-\t    e->count = profile_count::zero ();\n+\t    e->probability = profile_probability::never ();\n \t    if (!(e->src->count == profile_count::zero ()))\n \t      {\n \t        nsuccs[e->src->index]--;\n@@ -3928,22 +3916,20 @@ force_edge_cold (edge e, bool impossible)\n   profile_probability prob_sum = profile_probability::never ();\n   edge_iterator ei;\n   edge e2;\n-  profile_count old_count = e->count;\n-  profile_probability old_probability = e->probability;\n   bool uninitialized_exit = false;\n \n   profile_probability goal = (impossible ? profile_probability::never ()\n \t\t\t      : profile_probability::very_unlikely ());\n \n   /* If edge is already improbably or cold, just return.  */\n   if (e->probability <= goal\n-      && (!impossible || e->count == profile_count::zero ()))\n+      && (!impossible || e->count () == profile_count::zero ()))\n     return;\n   FOR_EACH_EDGE (e2, ei, e->src->succs)\n     if (e2 != e)\n       {\n-\tif (e2->count.initialized_p ())\n-\t  count_sum += e2->count;\n+\tif (e2->count ().initialized_p ())\n+\t  count_sum += e2->count ();\n \telse\n \t  uninitialized_exit = true;\n \tif (e2->probability.initialized_p ())\n@@ -3956,13 +3942,6 @@ force_edge_cold (edge e, bool impossible)\n     {\n       if (!(e->probability < goal))\n \te->probability = goal;\n-      if (impossible)\n-\te->count = profile_count::zero ();\n-      else if (old_probability > profile_probability::never ())\n-\te->count = e->count.apply_probability (e->probability\n-\t\t\t\t\t       / old_probability);\n-      else\n-        e->count = e->count.apply_scale (1, REG_BR_PROB_BASE);\n \n       profile_probability prob_comp = prob_sum / e->probability.invert ();\n \n@@ -3971,12 +3950,9 @@ force_edge_cold (edge e, bool impossible)\n \t\t \"probability to other edges.\\n\",\n \t\t e->src->index, e->dest->index,\n \t\t impossible ? \"impossible\" : \"cold\");\n-      profile_count count_sum2 = count_sum + old_count - e->count;\n       FOR_EACH_EDGE (e2, ei, e->src->succs)\n \tif (e2 != e)\n \t  {\n-\t    if (count_sum > 0)\n-\t      e2->count.apply_scale (count_sum2, count_sum);\n \t    e2->probability /= prob_comp;\n \t  }\n       if (current_ir_type () != IR_GIMPLE\n@@ -4027,7 +4003,6 @@ force_edge_cold (edge e, bool impossible)\n \t\tfprintf (dump_file,\n \t\t\t \"Making bb %i impossible and dropping count to 0.\\n\",\n \t\t\t e->src->index);\n-\t      e->count = profile_count::zero ();\n \t      e->src->count = profile_count::zero ();\n \t      FOR_EACH_EDGE (e2, ei, e->src->preds)\n \t\tforce_edge_cold (e2, impossible);\n@@ -4050,10 +4025,10 @@ force_edge_cold (edge e, bool impossible)\n \t\t     impossible ? \"impossible\" : \"cold\");\n \t  e->src->frequency = MIN (e->src->frequency, impossible ? 0 : 1);\n \t  if (impossible)\n-\t    e->src->count = e->count = profile_count::zero ();\n+\t    e->src->count = profile_count::zero ();\n \t  else\n-\t    e->src->count = e->count = e->count.apply_scale (e->src->frequency,\n-\t\t\t\t\t\t\t     old_frequency);\n+\t    e->src->count = e->count ().apply_scale (e->src->frequency,\n+\t\t\t\t\t\t     old_frequency);\n \t  force_edge_cold (single_pred_edge (e->src), impossible);\n \t}\n       else if (dump_file && (dump_flags & TDF_DETAILS)"}, {"sha": "95dd578a4937b0905f97c2ad8762463a2027e947", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -831,12 +831,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \n   FOR_ALL_BB_FN (bb, cfun)\n     {\n-      edge e;\n-      edge_iterator ei;\n-\n       bb->count = profile_count::from_gcov_type (bb_gcov_count (bb));\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = profile_count::from_gcov_type (edge_gcov_count (e));\n     }\n   bb_gcov_counts.release ();\n   delete edge_gcov_counts;"}, {"sha": "62f7d7b965373daafdb90b16a68a092779d23009", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -2961,9 +2961,9 @@ better_edge (edge e1, edge e2)\n   if (EDGE_FREQUENCY (e1) < EDGE_FREQUENCY (e2))\n     return e2;\n \n-  if (e1->count > e2->count)\n+  if (e1->count () > e2->count ())\n     return e1;\n-  if (e1->count < e2->count)\n+  if (e1->count () < e2->count ())\n     return e2;\n \n   /* Prefer critical edges to minimize inserting compensation code on"}, {"sha": "1a2802fbcc199ed90e465391d1261fa88beba2ec", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -561,7 +561,6 @@ handle_simple_exit (edge e)\n       BB_END (old_bb) = end;\n \n       redirect_edge_succ (e, new_bb);\n-      new_bb->count = e->count;\n       new_bb->frequency = EDGE_FREQUENCY (e);\n       e->flags |= EDGE_FALLTHRU;\n "}, {"sha": "f3e401b8b123f7245f3dbcf7d90ffcf84e9b579a", "filename": "gcc/tracer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -132,9 +132,9 @@ count_insns (basic_block bb)\n static bool\n better_p (const_edge e1, const_edge e2)\n {\n-  if (e1->count.initialized_p () && e2->count.initialized_p ()\n-      && !(e1->count == e2->count))\n-    return e1->count > e2->count;\n+  if (e1->count ().initialized_p () && e2->count ().initialized_p ()\n+      && ((e1->count () > e2->count ()) || (e1->count () < e2->count  ())))\n+    return e1->count () > e2->count ();\n   if (EDGE_FREQUENCY (e1) != EDGE_FREQUENCY (e2))\n     return EDGE_FREQUENCY (e1) > EDGE_FREQUENCY (e2);\n   /* This is needed to avoid changes in the decision after"}, {"sha": "2c701f0a546db9396b6ec998b7cf457a07d52eb9", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -2938,10 +2938,8 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       ei->probability = profile_probability::always ();\n       et->probability = profile_probability::likely ();\n       ef->probability = profile_probability::unlikely ();\n-      et->count = test_bb->count.apply_probability (et->probability);\n-      ef->count = test_bb->count.apply_probability (ef->probability);\n \n-      code_bb->count = et->count;\n+      code_bb->count = et->count ();\n       code_bb->frequency = EDGE_FREQUENCY (et);\n \n       transaction_bb = join_bb;\n@@ -2975,15 +2973,11 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       redirect_edge_pred (fallthru_edge, test_bb);\n       fallthru_edge->flags = EDGE_FALSE_VALUE;\n       fallthru_edge->probability = profile_probability::very_likely ();\n-      fallthru_edge->count = test_bb->count.apply_probability\n-\t\t\t\t(fallthru_edge->probability);\n \n       // Abort/over edge.\n       redirect_edge_pred (abort_edge, test_bb);\n       abort_edge->flags = EDGE_TRUE_VALUE;\n       abort_edge->probability = profile_probability::unlikely ();\n-      abort_edge->count = test_bb->count.apply_probability\n-\t\t\t\t(abort_edge->probability);\n \n       transaction_bb = test_bb;\n     }\n@@ -3011,7 +3005,7 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       // out of the fallthru edge.\n       edge e = make_edge (transaction_bb, test_bb, fallthru_edge->flags);\n       e->probability = fallthru_edge->probability;\n-      test_bb->count = e->count = fallthru_edge->count;\n+      test_bb->count = fallthru_edge->count ();\n       test_bb->frequency = EDGE_FREQUENCY (e);\n \n       // Now update the edges to the inst/uninist implementations.\n@@ -3022,14 +3016,10 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       redirect_edge_pred (inst_edge, test_bb);\n       inst_edge->flags = EDGE_FALSE_VALUE;\n       inst_edge->probability = profile_probability::even ();\n-      inst_edge->count\n-\t= test_bb->count.apply_probability (inst_edge->probability);\n \n       redirect_edge_pred (uninst_edge, test_bb);\n       uninst_edge->flags = EDGE_TRUE_VALUE;\n       uninst_edge->probability = profile_probability::even ();\n-      uninst_edge->count\n-\t= test_bb->count.apply_probability (uninst_edge->probability);\n     }\n \n   // If we have no previous special cases, and we have PHIs at the beginning\n@@ -3214,10 +3204,7 @@ split_bb_make_tm_edge (gimple *stmt, basic_block dest_bb,\n     }\n   edge e = make_edge (bb, dest_bb, EDGE_ABNORMAL);\n   if (e)\n-    {\n-      e->probability = profile_probability::guessed_never ();\n-      e->count = profile_count::guessed_zero ();\n-    }\n+    e->probability = profile_probability::guessed_never ();\n \n   // Record the need for the edge for the benefit of the rtl passes.\n   if (cfun->gimple_df->tm_restart == NULL)"}, {"sha": "43987721b25eefcfa2419639935caba5a7e80c14", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -913,21 +913,17 @@ shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n       gcc_assert (src_bb == nocall_edge->src);\n \n       call_edge->probability = profile_probability::very_unlikely ();\n-      call_edge->count\n-\t = src_bb->count.apply_probability (call_edge->probability);\n       nocall_edge->probability = profile_probability::always ()\n \t\t\t\t - call_edge->probability;\n-      nocall_edge->count = src_bb->count - call_edge->count;\n \n       unsigned int call_frequency\n \t = call_edge->probability.apply (src_bb->frequency);\n \n-      bi_call_bb->count += call_edge->count;\n+      bi_call_bb->count += call_edge->count ();\n       bi_call_bb->frequency += call_frequency;\n \n       if (nocall_edge->dest != join_tgt_bb)\n \t{\n-\t  nocall_edge->dest->count = nocall_edge->count;\n \t  nocall_edge->dest->frequency = src_bb->frequency - call_frequency;\n \t}\n     }"}, {"sha": "a7c7348ed298e0e22b48464c59e81d900f7ee1f3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1062,8 +1062,8 @@ gimple_find_sub_bbs (gimple_seq seq, gimple_stmt_iterator *gsi)\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n-\t  if (e->count.initialized_p ())\n-\t    cnt += e->count;\n+\t  if (e->count ().initialized_p ())\n+\t    cnt += e->count ();\n \t  else\n \t    all = false;\n \t  freq += EDGE_FREQUENCY (e);\n@@ -1072,8 +1072,6 @@ gimple_find_sub_bbs (gimple_seq seq, gimple_stmt_iterator *gsi)\n       if (all || profile_status_for_fn (cfun) == PROFILE_READ)\n         bb->count = cnt;\n       bb->frequency = freq;\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\te->count = bb->count.apply_probability (e->probability);\n \n       bb = bb->next_bb;\n     }\n@@ -2843,7 +2841,7 @@ gimple_split_edge (edge edge_in)\n \n   new_bb = create_empty_bb (after_bb);\n   new_bb->frequency = EDGE_FREQUENCY (edge_in);\n-  new_bb->count = edge_in->count;\n+  new_bb->count = edge_in->count ();\n \n   e = redirect_edge_and_branch (edge_in, new_bb);\n   gcc_assert (e == edge_in);\n@@ -6372,7 +6370,7 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n   if (entry->dest->count.initialized_p ())\n     {\n       total_count = entry->dest->count;\n-      entry_count = entry->count;\n+      entry_count = entry->count ();\n       /* Fix up corner cases, to avoid division by zero or creation of negative\n \t frequencies.  */\n       if (entry_count > total_count)\n@@ -6542,7 +6540,7 @@ gimple_duplicate_sese_tail (edge entry, edge exit,\n   if (exit->src->count > 0)\n     {\n       total_count = exit->src->count;\n-      exit_count = exit->count;\n+      exit_count = exit->count ();\n       /* Fix up corner cases, to avoid division by zero or creation of negative\n \t frequencies.  */\n       if (exit_count > total_count)\n@@ -6597,10 +6595,8 @@ gimple_duplicate_sese_tail (edge entry, edge exit,\n   sorig = single_succ_edge (switch_bb);\n   sorig->flags = exits[1]->flags;\n   sorig->probability = exits[1]->probability;\n-  sorig->count = exits[1]->count;\n   snew = make_edge (switch_bb, nentry_bb, exits[0]->flags);\n   snew->probability = exits[0]->probability;\n-  snew->count = exits[1]->count;\n   \n \n   /* Register the new edge from SWITCH_BB in loop exit lists.  */\n@@ -8335,7 +8331,6 @@ gimple_flow_call_edges_add (sbitmap blocks)\n \t\t    }\n \t\t  e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n \t\t  e->probability = profile_probability::guessed_never ();\n-\t\t  e->count = profile_count::guessed_zero ();\n \t\t}\n \t      gsi_prev (&gsi);\n \t    }\n@@ -8847,14 +8842,12 @@ insert_cond_bb (basic_block bb, gimple *stmt, gimple *cond,\n   new_bb = create_empty_bb (bb);\n   edge e = make_edge (bb, new_bb, EDGE_TRUE_VALUE);\n   e->probability = prob;\n-  e->count = bb->count.apply_probability (prob);\n-  new_bb->count = e->count;\n+  new_bb->count = e->count ();\n   new_bb->frequency = prob.apply (bb->frequency);\n   make_single_succ_edge (new_bb, fall->dest, EDGE_FALLTHRU);\n \n   /* Fix edge for split bb.  */\n   fall->flags = EDGE_FALSE_VALUE;\n-  fall->count -= e->count;\n   fall->probability -= e->probability;\n \n   /* Update dominance info.  */\n@@ -9252,8 +9245,6 @@ execute_fixup_cfg (void)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   int todo = 0;\n-  edge e;\n-  edge_iterator ei;\n   cgraph_node *node = cgraph_node::get (current_function_decl);\n   profile_count num = node->count;\n   profile_count den = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n@@ -9266,9 +9257,6 @@ execute_fixup_cfg (void)\n       ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = node->count;\n       EXIT_BLOCK_PTR_FOR_FN (cfun)->count\n         = EXIT_BLOCK_PTR_FOR_FN (cfun)->count.apply_scale (num, den);\n-\n-      FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n-\te->count = e->count.apply_scale (num, den);\n     }\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -9343,10 +9331,6 @@ execute_fixup_cfg (void)\n \t  gsi_next (&gsi);\n \t}\n \n-      if (scale)\n-\tFOR_EACH_EDGE (e, ei, bb->succs)\n-\t  e->count = e->count.apply_scale (num, den);\n-\n       /* If we have a basic block with no successors that does not\n \t end with a control statement or a noreturn call end it with\n \t a call to __builtin_unreachable.  This situation can occur"}, {"sha": "9b7f08c586c39d6d37fc15280f395a6e847706e0", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -195,7 +195,6 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi,\n \t\t}\n \n \t      taken_edge->probability += e->probability;\n-\t      taken_edge->count += e->count;\n \t      remove_edge_and_dominated_blocks (e);\n \t      retval = true;\n \t    }"}, {"sha": "e2d93b78eae5e2be7017f072ced3ac1cb5f4b958", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1192,13 +1192,11 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n \n       /* Wire the blocks together.  */\n       e->flags = EDGE_TRUE_VALUE;\n-      e->count = bb_true->count;\n       /* TODO: With value profile we could add an historgram to determine real\n \t branch outcome.  */\n       e->probability = profile_probability::even ();\n       redirect_edge_succ (e, bb_true);\n       edge e2 = make_edge (bb_cond, bb_false, EDGE_FALSE_VALUE);\n-      e2->count = bb_false->count;\n       e2->probability = profile_probability::even ();\n       make_single_succ_edge (bb_true, bb_join, EDGE_FALLTHRU);\n       make_single_succ_edge (bb_false, bb_join, EDGE_FALLTHRU);"}, {"sha": "e255e086bb54a1cba3db0a01bae8a5427fdcc9cf", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -3259,7 +3259,6 @@ lower_resx (basic_block bb, gresx *stmt,\n \t  gcc_assert (e->flags & EDGE_EH);\n \t  e->flags = (e->flags & ~EDGE_EH) | EDGE_FALLTHRU;\n \t  e->probability = profile_probability::always ();\n-\t  e->count = bb->count;\n \n \t  /* If there are no more EH users of the landing pad, delete it.  */\n \t  FOR_EACH_EDGE (e, ei, e->dest->preds)\n@@ -4099,7 +4098,6 @@ unsplit_eh (eh_landing_pad lp)\n   redirect_edge_pred (e_out, e_in->src);\n   e_out->flags = e_in->flags;\n   e_out->probability = e_in->probability;\n-  e_out->count = e_in->count;\n   remove_edge (e_in);\n \n   return true;\n@@ -4292,7 +4290,6 @@ cleanup_empty_eh_move_lp (basic_block bb, edge e_out,\n   /* Clean up E_OUT for the fallthru.  */\n   e_out->flags = (e_out->flags & ~EDGE_EH) | EDGE_FALLTHRU;\n   e_out->probability = profile_probability::always ();\n-  e_out->count = e_out->src->count;\n }\n \n /* A subroutine of cleanup_empty_eh.  Handle more complex cases of"}, {"sha": "597addbd4bb0bb67ba148742854c37a80d0397d7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -2215,7 +2215,7 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n    debug stmts are left after a statement that must end the basic block.  */\n \n static bool\n-copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n+copy_edges_for_bb (basic_block bb,\n \t\t   basic_block ret_bb, basic_block abnormal_goto_dest)\n {\n   basic_block new_bb = (basic_block) bb->aux;\n@@ -2224,8 +2224,6 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n   gimple_stmt_iterator si;\n   int flags;\n   bool need_debug_cleanup = false;\n-  bool scale = num.initialized_p ()\n-\t       && (den > 0 || num == profile_count::zero ());\n \n   /* Use the indices from the original blocks to create edges for the\n      new ones.  */\n@@ -2242,8 +2240,6 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n-\tif (scale)\n-\t  new_edge->count = old_edge->count.apply_scale (num, den);\n \tnew_edge->probability = old_edge->probability;\n       }\n \n@@ -2324,17 +2320,11 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n \t\t&& (e = find_edge (copy_stmt_bb,\n \t\t\t\t   (basic_block) old_edge->dest->aux))\n \t\t&& (e->flags & EDGE_EH))\n-\t      {\n-\t\te->probability = old_edge->probability;\n-\t\te->count = old_edge->count;\n-\t      }\n+\t      e->probability = old_edge->probability;\n \t    \n           FOR_EACH_EDGE (e, ei, copy_stmt_bb->succs)\n \t    if ((e->flags & EDGE_EH) && !e->probability.initialized_p ())\n-\t      {\n-\t        e->probability = profile_probability::never ();\n-\t        e->count = profile_count::zero ();\n-\t      }\n+\t      e->probability = profile_probability::never ();\n         }\n \n \n@@ -2700,16 +2690,10 @@ void\n freqs_to_counts (struct cgraph_node *node, profile_count count)\n {\n   basic_block bb;\n-  edge_iterator ei;\n-  edge e;\n   struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n \n   FOR_ALL_BB_FN(bb, fn)\n-    {\n-      bb->count = count.apply_scale (bb->frequency, BB_FREQ_MAX);\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = e->src->count.apply_probability (e->probability);\n-    }\n+    bb->count = count.apply_scale (bb->frequency, BB_FREQ_MAX);\n }\n \n /* Make a copy of the body of FN so that it can be inserted inline in\n@@ -2769,10 +2753,7 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n \n       FOR_EACH_EDGE (e, ei, new_entry->preds)\n \tif (!e->src->aux)\n-\t  {\n-\t    incoming_frequency += EDGE_FREQUENCY (e);\n-\t    incoming_count += e->count;\n-\t  }\n+\t  incoming_frequency += EDGE_FREQUENCY (e);\n       if (scale)\n         incoming_count = incoming_count.apply_scale (num, den);\n       else\n@@ -2826,14 +2807,13 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     if (!id->blocks_to_copy\n \t|| (bb->index > 0 && bitmap_bit_p (id->blocks_to_copy, bb->index)))\n-      need_debug_cleanup |= copy_edges_for_bb (bb, num, den, exit_block_map,\n+      need_debug_cleanup |= copy_edges_for_bb (bb, exit_block_map,\n \t\t\t\t\t       abnormal_goto_dest);\n \n   if (new_entry)\n     {\n       edge e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n       e->probability = profile_probability::always ();\n-      e->count = incoming_count;\n     }\n \n   /* Duplicate the loop tree, if available and wanted.  */"}, {"sha": "a5f0edf7893b10cb198d1af813c6bb559026e609", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1051,7 +1051,6 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n \t}\n       gcc_assert (e);\n       e->probability = profile_probability::always ();\n-      e->count = bb->count;\n \n       /* The edge is no longer associated with a conditional, so it does\n \t not have TRUE/FALSE flags."}, {"sha": "06d22693a1f1524eb2e8513b647b89316d1a68c8", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -358,10 +358,7 @@ update_profile_after_ifcombine (basic_block inner_cond_bb,\n      outer_cond_bb->(outer_to_inner)->inner_cond_bb->(inner_taken)\n      and probability of inner_not_taken updated.  */\n \n-  outer_to_inner->count = outer_cond_bb->count;\n   inner_cond_bb->count = outer_cond_bb->count;\n-  inner_taken->count += outer2->count;\n-  outer2->count = profile_count::zero ();\n \n   inner_taken->probability = outer2->probability + outer_to_inner->probability\n \t\t\t     * inner_taken->probability;"}, {"sha": "a1b8a0097453aefc108c9483856f05209c1fbb7a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1815,9 +1815,9 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \n   if (flag_probability.initialized_p ())\n     ;\n-  else if (ncount == nbbs && count_sum > 0 && preheader->count >= count_sum)\n+  else if (ncount == nbbs && count_sum > 0 && preheader->count () >= count_sum)\n     {\n-      flag_probability = count_sum.probability_in (preheader->count);\n+      flag_probability = count_sum.probability_in (preheader->count ());\n       if (flag_probability > cap)\n \tflag_probability = cap;\n     }\n@@ -1881,13 +1881,11 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   edge e2 = make_edge (new_bb, then_bb,\n \t               EDGE_TRUE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));\n   e2->probability = flag_probability;\n-  e2->count = then_bb->count;\n \n   e1->flags |= EDGE_FALSE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0);\n   e1->flags &= ~EDGE_FALLTHRU;\n \n   e1->probability = flag_probability.invert ();\n-  e1->count = new_bb->count - then_bb->count;\n \n   then_old_edge = make_single_succ_edge (then_bb, old_dest,\n \t\t\t     EDGE_FALLTHRU | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));"}, {"sha": "743bf1ad9d6d578512dedb4745ebec94535ed261", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -530,7 +530,6 @@ remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n \t  if (!loop_exit_edge_p (loop, exit_edge))\n \t    exit_edge = EDGE_SUCC (bb, 1);\n \t  exit_edge->probability = profile_probability::always ();\n-\t  exit_edge->count = exit_edge->src->count;\n \t  gcc_checking_assert (loop_exit_edge_p (loop, exit_edge));\n \t  gcond *cond_stmt = as_a <gcond *> (elt->stmt);\n \t  if (exit_edge->flags & EDGE_TRUE_VALUE)\n@@ -643,7 +642,6 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n       stmt = gimple_build_call (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n       latch_edge = make_edge (latch, create_basic_block (NULL, NULL, latch), flags);\n       latch_edge->probability = profile_probability::never ();\n-      latch_edge->count = profile_count::zero ();\n       latch_edge->flags |= flags;\n       latch_edge->goto_locus = locus;\n "}, {"sha": "5794dae75be56e23d22a55eaf03a41f016944ddc", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1294,12 +1294,10 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   /* Set the probability of new exit to the same of the old one.  Fix\n      the frequency of the latch block, by scaling it back by\n      1 - exit->probability.  */\n-  new_exit->count = exit->count;\n   new_exit->probability = exit->probability;\n   new_nonexit = single_pred_edge (loop->latch);\n   new_nonexit->probability = exit->probability.invert ();\n   new_nonexit->flags = EDGE_TRUE_VALUE;\n-  new_nonexit->count -= exit->count;\n   if (new_nonexit->probability.initialized_p ())\n     scale_bbs_frequencies (&loop->latch, 1, new_nonexit->probability);\n \n@@ -1371,7 +1369,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n      exit edge.  */\n \n   freq_h = loop->header->count;\n-  freq_e = (loop_preheader_edge (loop))->count;\n+  freq_e = (loop_preheader_edge (loop))->count ();\n   /* Use frequency only if counts are zero.  */\n   if (!(freq_h > 0) && !(freq_e > 0))\n     {\n@@ -1390,17 +1388,15 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \n   exit_bb = single_pred (loop->latch);\n   new_exit = find_edge (exit_bb, rest);\n-  new_exit->count = loop_preheader_edge (loop)->count;\n   new_exit->probability = profile_probability::always ()\n \t\t\t\t.apply_scale (1, new_est_niter + 1);\n \n-  rest->count += new_exit->count;\n+  rest->count += new_exit->count ();\n   rest->frequency += EDGE_FREQUENCY (new_exit);\n \n   new_nonexit = single_pred_edge (loop->latch);\n   prob = new_nonexit->probability;\n   new_nonexit->probability = new_exit->probability.invert ();\n-  new_nonexit->count = exit_bb->count - new_exit->count;\n   prob = new_nonexit->probability / prob;\n   if (prob.initialized_p ())\n     scale_bbs_frequencies (&loop->latch, 1, prob);"}, {"sha": "dcb7c1ee4c81dfaa264b041b87955bc063128c43", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -353,11 +353,8 @@ connect_loops (struct loop *loop1, struct loop *loop2)\n       new_e->flags |= EDGE_TRUE_VALUE;\n     }\n \n-  new_e->count = skip_bb->count;\n   new_e->probability = profile_probability::likely ();\n-  new_e->count = skip_e->count.apply_probability (PROB_LIKELY);\n-  skip_e->count -= new_e->count;\n-  skip_e->probability = profile_probability::unlikely ();\n+  skip_e->probability = new_e->probability.invert ();\n \n   return new_e;\n }\n@@ -560,7 +557,6 @@ split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n \tinitialize_original_copy_tables ();\n \tbasic_block cond_bb;\n \n-\t/* FIXME: probabilities seems wrong here.  */\n \tstruct loop *loop2 = loop_version (loop1, cond, &cond_bb,\n \t\t\t\t\t   profile_probability::always (),\n \t\t\t\t\t   profile_probability::always (),"}, {"sha": "4287c104f24f37fb46e456402227adc1d4b90dfa", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -853,16 +853,15 @@ hoist_guard (struct loop *loop, edge guard)\n      same average number of iterations regardless outcome of guard.  */\n   new_edge->probability = guard->probability;\n   profile_count skip_count = guard->src->count > 0\n-\t\t   ? guard->count.apply_scale (pre_header->count,\n+\t\t   ? guard->count ().apply_scale (pre_header->count,\n \t\t\t\t\t       guard->src->count)\n-\t\t   : guard->count.apply_probability (new_edge->probability);\n+\t\t   : guard->count ().apply_probability (new_edge->probability);\n \n-  if (skip_count > e->count)\n+  if (skip_count > e->count ())\n     {\n       fprintf (dump_file, \"  Capping count; expect profile inconsistency\\n\");\n-      skip_count = e->count;\n+      skip_count = e->count ();\n     }\n-  new_edge->count = skip_count;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"  Estimated probability of skipping loop is \");\n@@ -874,19 +873,14 @@ hoist_guard (struct loop *loop, edge guard)\n \n      First decrease count of path from newly hoisted loop guard\n      to loop header...  */\n-  e->count -= skip_count;\n   e->probability = new_edge->probability.invert ();\n-  e->dest->count = e->count;\n+  e->dest->count = e->count ();\n   e->dest->frequency = EDGE_FREQUENCY (e);\n \n   /* ... now update profile to represent that original guard will be optimized\n      away ...  */\n   guard->probability = profile_probability::never ();\n-  guard->count = profile_count::zero ();\n   not_guard->probability = profile_probability::always ();\n-  /* This count is wrong (frequency of not_guard does not change),\n-     but will be scaled later.  */\n-  not_guard->count = guard->src->count;\n \n   /* ... finally scale everything in the loop except for guarded basic blocks\n      where profile does not change.  */"}, {"sha": "fe39aa71f98b5f846d7826ca0727303a330684ad", "filename": "gcc/tree-ssa-phionlycprop.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-phionlycprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-phionlycprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phionlycprop.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -298,7 +298,6 @@ propagate_rhs_into_lhs (gimple *stmt, tree lhs, tree rhs,\n \n \t\t\t  te->probability += e->probability;\n \n-\t\t\t  te->count += e->count;\n \t\t\t  remove_edge (e);\n \t\t\t  cfg_altered = true;\n \t\t\t}"}, {"sha": "d0570c3fa9c1981bca00c645935624cfc7df3531", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -375,7 +375,6 @@ replace_phi_edge_with_variable (basic_block cond_block,\n       EDGE_SUCC (cond_block, 0)->flags |= EDGE_FALLTHRU;\n       EDGE_SUCC (cond_block, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n       EDGE_SUCC (cond_block, 0)->probability = profile_probability::always ();\n-      EDGE_SUCC (cond_block, 0)->count += EDGE_SUCC (cond_block, 1)->count;\n \n       block_to_remove = EDGE_SUCC (cond_block, 1)->dest;\n     }\n@@ -385,7 +384,6 @@ replace_phi_edge_with_variable (basic_block cond_block,\n       EDGE_SUCC (cond_block, 1)->flags\n \t&= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n       EDGE_SUCC (cond_block, 1)->probability = profile_probability::always ();\n-      EDGE_SUCC (cond_block, 1)->count += EDGE_SUCC (cond_block, 0)->count;\n \n       block_to_remove = EDGE_SUCC (cond_block, 0)->dest;\n     }"}, {"sha": "cb438c744b71519bb3bb3b50b98fb221ecd15e1d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -6033,12 +6033,10 @@ branch_fixup (void)\n \n       edge etrue = make_edge (cond_bb, merge_bb, EDGE_TRUE_VALUE);\n       etrue->probability = profile_probability::even ();\n-      etrue->count = cond_bb->count.apply_scale (1, 2);\n       edge efalse = find_edge (cond_bb, then_bb);\n       efalse->flags = EDGE_FALSE_VALUE;\n       efalse->probability -= etrue->probability;\n-      efalse->count -= etrue->count;\n-      then_bb->count -= etrue->count;\n+      then_bb->count -= etrue->count ();\n \n       tree othervar = NULL_TREE;\n       if (gimple_assign_rhs1 (use_stmt) == var)"}, {"sha": "c10289af78818c99f14b0e6b7915f573b1f1d170", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -1570,25 +1570,24 @@ replace_block_by (basic_block bb1, basic_block bb2)\n      making the bb count inconsistent with the edge weights.  */\n   FOR_EACH_EDGE (e1, ei, bb1->succs)\n     {\n-      if (e1->count.initialized_p ())\n-\tout_sum += e1->count;\n+      if (e1->count ().initialized_p ())\n+\tout_sum += e1->count ();\n       out_freq_sum += EDGE_FREQUENCY (e1);\n     }\n   FOR_EACH_EDGE (e1, ei, bb2->succs)\n     {\n-      if (e1->count.initialized_p ())\n-\tout_sum += e1->count;\n+      if (e1->count ().initialized_p ())\n+\tout_sum += e1->count ();\n       out_freq_sum += EDGE_FREQUENCY (e1);\n     }\n \n   FOR_EACH_EDGE (e1, ei, bb1->succs)\n     {\n       e2 = find_edge (bb2, e1->dest);\n       gcc_assert (e2);\n-      e2->count += e1->count;\n-      if (out_sum > 0 && e2->count.initialized_p ())\n+      if (out_sum > 0 && e2->count ().initialized_p ())\n \t{\n-\t  e2->probability = e2->count.probability_in (bb2->count);\n+\t  e2->probability = e2->count ().probability_in (bb2->count);\n \t}\n       else if (bb1->frequency && bb2->frequency)\n \te2->probability = e1->probability;\n@@ -1599,7 +1598,7 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \t\t(GCOV_COMPUTE_SCALE (EDGE_FREQUENCY (e1)\n \t\t\t\t     + EDGE_FREQUENCY (e2),\n \t\t\t\t     out_freq_sum));\n-      out_sum += e2->count;\n+      out_sum += e2->count ();\n     }\n   bb2->frequency += bb1->frequency;\n   if (bb2->frequency > BB_FREQ_MAX)"}, {"sha": "8681707651caf2eb3b0008bab443b23c79b675f2", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 83, "deletions": 162, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -303,7 +303,6 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n       else\n \t{\n \t  e->probability = profile_probability::always ();\n-\t  e->count = bb->count;\n \t  ei_next (&ei);\n \t}\n     }\n@@ -741,15 +740,15 @@ compute_path_counts (struct redirection_data *rd,\n \t     same last path edge in the case where the last edge has a nocopy\n \t     source block.  */\n \t  gcc_assert (ein_path->last ()->e == elast);\n-\t  path_in_count += ein->count;\n+\t  path_in_count += ein->count ();\n \t  path_in_freq += EDGE_FREQUENCY (ein);\n \t}\n       else if (!ein_path)\n \t{\n \t  /* Keep track of the incoming edges that are not on any jump-threading\n \t     path.  These counts will still flow out of original path after all\n \t     jump threading is complete.  */\n-\t    nonpath_count += ein->count;\n+\t    nonpath_count += ein->count ();\n \t}\n     }\n \n@@ -789,7 +788,7 @@ compute_path_counts (struct redirection_data *rd,\n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n-      profile_count cur_count = epath->count;\n+      profile_count cur_count = epath->count ();\n       if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n \t  has_joiner = true;\n@@ -809,13 +808,13 @@ compute_path_counts (struct redirection_data *rd,\n \t\t     they are redirected by an invocation of this routine.  */\n \t\t  && !bitmap_bit_p (local_info->duplicate_blocks,\n \t\t\t\t    ein->src->index))\n-\t\tnonpath_count += ein->count;\n+\t\tnonpath_count += ein->count ();\n \t    }\n \t}\n       if (cur_count < path_out_count)\n \tpath_out_count = cur_count;\n-      if (epath->count < min_path_count)\n-\tmin_path_count = epath->count;\n+      if (epath->count () < min_path_count)\n+\tmin_path_count = epath->count ();\n     }\n \n   /* We computed path_out_count above assuming that this path targeted\n@@ -830,12 +829,12 @@ compute_path_counts (struct redirection_data *rd,\n      (since any path through the joiner with a different elast will not\n      include a copy of this elast in its duplicated path).\n      So ensure that this path's path_out_count is at least the\n-     difference between elast->count and nonpath_count.  Otherwise the edge\n+     difference between elast->count () and nonpath_count.  Otherwise the edge\n      counts after threading will not be sane.  */\n   if (local_info->need_profile_correction\n-      && has_joiner && path_out_count < elast->count - nonpath_count)\n+      && has_joiner && path_out_count < elast->count () - nonpath_count)\n     {\n-      path_out_count = elast->count - nonpath_count;\n+      path_out_count = elast->count () - nonpath_count;\n       /* But neither can we go above the minimum count along the path\n \t we are duplicating.  This can be an issue due to profile\n \t insanities coming in to this pass.  */\n@@ -858,17 +857,54 @@ static void\n update_profile (edge epath, edge edup, profile_count path_in_count,\n \t\tprofile_count path_out_count, int path_in_freq)\n {\n+  if (!(path_in_count > 0))\n+    return;\n \n   /* First update the duplicated block's count / frequency.  */\n   if (edup)\n     {\n       basic_block dup_block = edup->src;\n-      gcc_assert (!dup_block->count.initialized_p ());\n+\n+      /* Edup's count is reduced by path_out_count.  We need to redistribute\n+         probabilities to the remaining edges.  */\n+\n+      edge esucc;\n+      edge_iterator ei;\n+      profile_probability edup_prob\n+\t = path_out_count.probability_in (path_in_count);\n+\n+      /* Either scale up or down the remaining edges.\n+\t probabilities are always in range <0,1> and thus we can't do\n+\t both by same loop.  */\n+      if (edup->probability > edup_prob)\n+\t{\n+\t   profile_probability rev_scale\n+\t     = (profile_probability::always () - edup->probability)\n+\t       / (profile_probability::always () - edup_prob);\n+\t   FOR_EACH_EDGE (esucc, ei, dup_block->succs)\n+\t     if (esucc != edup)\n+\t       esucc->probability /= rev_scale;\n+\t}\n+      else if (edup->probability < edup_prob)\n+\t{\n+\t   profile_probability scale\n+\t     = (profile_probability::always () - edup_prob)\n+\t       / (profile_probability::always () - edup->probability);\n+\t  FOR_EACH_EDGE (esucc, ei, dup_block->succs)\n+\t    if (esucc != edup)\n+\t      esucc->probability *= scale;\n+\t}\n+      edup->probability = edup_prob;\n+\n+      /* FIXME once freqs_to_counts is dropped re-enable this check.  */\n+      gcc_assert (!dup_block->count.initialized_p () || 1);\n       gcc_assert (dup_block->frequency == 0);\n       dup_block->count = path_in_count;\n       dup_block->frequency = path_in_freq;\n     }\n \n+  profile_count final_count = epath->count () - path_out_count;\n+\n   /* Now update the original block's count and frequency in the\n      opposite manner - remove the counts/freq that will flow\n      into the duplicated block.  Handle underflow due to precision/\n@@ -883,107 +919,31 @@ update_profile (edge epath, edge edup, profile_count path_in_count,\n      out of it (in the joiner case this is the count along the duplicated path\n      out of the duplicated joiner).  This count can then be removed from the\n      original path edge.  */\n-  if (edup)\n-    edup->count = path_out_count;\n-  epath->count -= path_out_count;\n-  /* FIXME: can epath->count be legally uninitialized here?  */\n-}\n-\n-\n-/* The duplicate and original joiner blocks may end up with different\n-   probabilities (different from both the original and from each other).\n-   Recompute the probabilities here once we have updated the edge\n-   counts and frequencies.  */\n-\n-static void\n-recompute_probabilities (basic_block bb)\n-{\n-  edge esucc;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (esucc, ei, bb->succs)\n-    {\n-      if (!(bb->count > 0))\n-\tcontinue;\n-\n-      /* Prevent overflow computation due to insane profiles.  */\n-      if (esucc->count < bb->count)\n-\tesucc->probability = esucc->count.probability_in (bb->count).guessed ();\n-      else\n-\t/* Can happen with missing/guessed probabilities, since we\n-\t   may determine that more is flowing along duplicated\n-\t   path than joiner succ probabilities allowed.\n-\t   Counts and freqs will be insane after jump threading,\n-\t   at least make sure probability is sane or we will\n-\t   get a flow verification error.\n-\t   Not much we can do to make counts/freqs sane without\n-\t   redoing the profile estimation.  */\n-\tesucc->probability = profile_probability::guessed_always ();\n-    }\n-}\n-\n-\n-/* Update the counts of the original and duplicated edges from a joiner\n-   that go off path, given that we have already determined that the\n-   duplicate joiner DUP_BB has incoming count PATH_IN_COUNT and\n-   outgoing count along the path PATH_OUT_COUNT.  The original (on-)path\n-   edge from joiner is EPATH.  */\n-\n-static void\n-update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n-\t\t\t      profile_count path_in_count,\n-\t\t\t      profile_count path_out_count)\n-{\n-  /* Compute the count that currently flows off path from the joiner.\n-     In other words, the total count of joiner's out edges other than\n-     epath.  Compute this by walking the successors instead of\n-     subtracting epath's count from the joiner bb count, since there\n-     are sometimes slight insanities where the total out edge count is\n-     larger than the bb count (possibly due to rounding/truncation\n-     errors).  */\n-  profile_count total_orig_off_path_count = profile_count::zero ();\n-  edge enonpath;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n+  if (epath->src->count > 0)\n     {\n-      if (enonpath == epath)\n-\tcontinue;\n-      total_orig_off_path_count += enonpath->count;\n-    }\n-\n-  /* For the path that we are duplicating, the amount that will flow\n-     off path from the duplicated joiner is the delta between the\n-     path's cumulative in count and the portion of that count we\n-     estimated above as flowing from the joiner along the duplicated\n-     path.  */\n-  profile_count total_dup_off_path_count = path_in_count - path_out_count;\n-\n-  /* Now do the actual updates of the off-path edges.  */\n-  FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n-    {\n-      /* Look for edges going off of the threading path.  */\n-      if (enonpath == epath)\n-\tcontinue;\n+      edge esucc;\n+      edge_iterator ei;\n+      profile_probability epath_prob = final_count.probability_in (epath->src->count);\n \n-      /* Find the corresponding edge out of the duplicated joiner.  */\n-      edge enonpathdup = find_edge (dup_bb, enonpath->dest);\n-      gcc_assert (enonpathdup);\n-\n-      /* We can't use the original probability of the joiner's out\n-\t edges, since the probabilities of the original branch\n-\t and the duplicated branches may vary after all threading is\n-\t complete.  But apportion the duplicated joiner's off-path\n-\t total edge count computed earlier (total_dup_off_path_count)\n-\t among the duplicated off-path edges based on their original\n-\t ratio to the full off-path count (total_orig_off_path_count).\n-\t */\n-      profile_probability scale\n-\t\t = enonpath->count.probability_in (total_orig_off_path_count);\n-      /* Give the duplicated offpath edge a portion of the duplicated\n-\t total.  */\n-      enonpathdup->count = total_dup_off_path_count.apply_probability (scale);\n-      /* Now update the original offpath edge count, handling underflow\n-\t due to rounding errors.  */\n-      enonpath->count -= enonpathdup->count;\n+      if (epath->probability > epath_prob)\n+\t{\n+\t   profile_probability rev_scale\n+\t     = (profile_probability::always () - epath->probability)\n+\t       / (profile_probability::always () - epath_prob);\n+\t   FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+\t     if (esucc != epath)\n+\t       esucc->probability /= rev_scale;\n+\t}\n+      else if (epath->probability < epath_prob)\n+\t{\n+\t   profile_probability scale\n+\t     = (profile_probability::always () - epath_prob)\n+\t       / (profile_probability::always () - epath->probability);\n+\t  FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+\t    if (esucc != epath)\n+\t      esucc->probability *= scale;\n+\t}\n+      epath->probability = epath_prob;\n     }\n }\n \n@@ -1002,7 +962,7 @@ estimated_freqs_path (struct redirection_data *rd)\n   bool non_zero_freq = false;\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n     {\n-      if (ein->count > 0)\n+      if (ein->count () > 0)\n \treturn false;\n       non_zero_freq |= ein->src->frequency != 0;\n     }\n@@ -1016,7 +976,7 @@ estimated_freqs_path (struct redirection_data *rd)\n       edge esucc;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n \t{\n-\t  if (esucc->count > 0)\n+\t  if (esucc->count () > 0)\n \t    return false;\n \t  non_zero_freq |= esucc->src->frequency != 0;\n \t}\n@@ -1042,34 +1002,19 @@ freqs_to_counts_path (struct redirection_data *rd)\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n   edge ein;\n   edge_iterator ei;\n-  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    {\n-      /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n-\t errors applying the probability when the frequencies are very\n-\t small.  */\n-      if (ein->probability.initialized_p ())\n-        ein->count = profile_count::from_gcov_type\n-\t\t  (apply_probability (ein->src->frequency * REG_BR_PROB_BASE,\n-\t\t\t\t        ein->probability\n-\t\t\t\t\t  .to_reg_br_prob_base ())).guessed ();\n-      else\n-\t/* FIXME: this is hack; we should track uninitialized values.  */\n-\tein->count = profile_count::zero ();\n-    }\n \n+  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n+    ein->src->count = profile_count::from_gcov_type\n+\t  (ein->src->frequency * REG_BR_PROB_BASE);\n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n-      edge esucc;\n       /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n \t errors applying the edge probability when the frequencies are very\n \t small.  */\n       epath->src->count = \n \tprofile_count::from_gcov_type\n \t  (epath->src->frequency * REG_BR_PROB_BASE);\n-      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\tesucc->count = \n-\t   esucc->src->count.apply_probability (esucc->probability);\n     }\n }\n \n@@ -1086,21 +1031,20 @@ clear_counts_path (struct redirection_data *rd)\n {\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-  edge ein, esucc;\n-  edge_iterator ei;\n   profile_count val = profile_count::uninitialized ();\n   if (profile_status_for_fn (cfun) == PROFILE_READ)\n     val = profile_count::zero ();\n \n+  edge ein;\n+  edge_iterator ei;\n+\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    ein->count = val;\n+    ein->src->count = val;\n \n   /* First clear counts along original path.  */\n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n-      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\tesucc->count = val;\n       epath->src->count = val;\n     }\n   /* Also need to clear the counts along duplicated path.  */\n@@ -1109,8 +1053,6 @@ clear_counts_path (struct redirection_data *rd)\n       basic_block dup = rd->dup_blocks[i];\n       if (!dup)\n \tcontinue;\n-      FOR_EACH_EDGE (esucc, ei, dup->succs)\n-\tesucc->count = val;\n       dup->count = val;\n     }\n }\n@@ -1230,17 +1172,6 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  update_profile (epath, e2, path_in_count, path_out_count,\n \t\t\t  path_in_freq);\n \n-\t  /* Next we need to update the counts of the original and duplicated\n-\t     edges from the joiner that go off path.  */\n-\t  update_joiner_offpath_counts (epath, e2->src, path_in_count,\n-\t\t\t\t\tpath_out_count);\n-\n-\t  /* Finally, we need to set the probabilities on the duplicated\n-\t     edges out of the duplicated joiner (e2->src).  The probabilities\n-\t     along the original path will all be updated below after we finish\n-\t     processing the whole path.  */\n-\t  recompute_probabilities (e2->src);\n-\n \t  /* Record the frequency flowing to the downstream duplicated\n \t     path blocks.  */\n \t  cur_path_freq = EDGE_FREQUENCY (e2);\n@@ -1263,8 +1194,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t     been updated at the end of that handling to the edge frequency\n \t     along the duplicated joiner path edge.  */\n \t  update_profile (epath, EDGE_SUCC (rd->dup_blocks[count], 0),\n-\t\t\t  path_out_count, path_out_count,\n-\t\t\t  cur_path_freq);\n+\t\t\t  path_out_count, path_out_count, cur_path_freq);\n \t}\n       else\n \t{\n@@ -1294,14 +1224,6 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t}\n     }\n \n-  /* Now walk orig blocks and update their probabilities, since the\n-     counts and freqs should be updated properly by above loop.  */\n-  for (unsigned int i = 1; i < path->length (); i++)\n-    {\n-      edge epath = (*path)[i]->e;\n-      recompute_probabilities (epath->src);\n-    }\n-\n   /* Done with all profile and frequency updates, clear counts if they\n      were copied.  */\n   if (do_freqs_to_counts)\n@@ -2247,7 +2169,7 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n      invalidating the property that is propagated by executing all the blocks of\n      the jump-thread path in order.  */\n \n-  curr_count = entry->count;\n+  curr_count = entry->count ();\n   curr_freq = EDGE_FREQUENCY (entry);\n \n   for (i = 0; i < n_region; i++)\n@@ -2300,7 +2222,7 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \t  if (i + 1 != n_region)\n \t    {\n \t      curr_freq = EDGE_FREQUENCY (single_succ_edge (bb));\n-\t      curr_count = single_succ_edge (bb)->count;\n+\t      curr_count = single_succ_edge (bb)->count ();\n \t    }\n \t  continue;\n \t}\n@@ -2331,7 +2253,7 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \telse\n \t  {\n \t    curr_freq = EDGE_FREQUENCY (e);\n-\t    curr_count = e->count;\n+\t    curr_count = e->count ();\n \t  }\n     }\n \n@@ -2353,7 +2275,6 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n     {\n       rescan_loop_exit (e, true, false);\n       e->probability = profile_probability::always ();\n-      e->count = region_copy[n_region - 1]->count;\n     }\n \n   /* Redirect the entry and add the phi node arguments.  */"}, {"sha": "a786377c038a1ef9b5ec0e65b798b50b5c002817", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -107,8 +107,7 @@ hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n   e_false->flags &= ~EDGE_FALLTHRU;\n   e_false->flags |= EDGE_FALSE_VALUE;\n   e_false->probability = e_true->probability.invert ();\n-  e_false->count = split_bb->count - e_true->count;\n-  new_bb->count = e_false->count;\n+  new_bb->count = e_false->count ();\n \n   if (update_dominators)\n     {\n@@ -239,9 +238,9 @@ case_bit_test_cmp (const void *p1, const void *p2)\n   const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n   const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n \n-  if (d2->target_edge->count < d1->target_edge->count)\n+  if (d2->target_edge->count () < d1->target_edge->count ())\n     return -1;\n-  if (d2->target_edge->count > d1->target_edge->count)\n+  if (d2->target_edge->count () > d1->target_edge->count ())\n     return 1;\n   if (d2->bits != d1->bits)\n     return d2->bits - d1->bits;\n@@ -635,10 +634,10 @@ collect_switch_conv_info (gswitch *swtch, struct switch_conv_info *info)\n     = label_to_block (CASE_LABEL (gimple_switch_default_label (swtch)));\n   e_default = find_edge (info->switch_bb, info->default_bb);\n   info->default_prob = e_default->probability;\n-  info->default_count = e_default->count;\n+  info->default_count = e_default->count ();\n   FOR_EACH_EDGE (e, ei, info->switch_bb->succs)\n     if (e != e_default)\n-      info->other_count += e->count;\n+      info->other_count += e->count ();\n \n   /* Get upper and lower bounds of case values, and the covered range.  */\n   min_case = gimple_switch_label (swtch, 1);\n@@ -1424,27 +1423,23 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n   if (!info->default_case_nonstandard)\n     e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n   e01->probability = info->default_prob.invert ();\n-  e01->count = info->other_count;\n \n   /* flags and profiles of the edge taking care of out-of-range values */\n   e02->flags &= ~EDGE_FALLTHRU;\n   e02->flags |= EDGE_FALSE_VALUE;\n   e02->probability = info->default_prob;\n-  e02->count = info->default_count;\n \n   bbf = info->final_bb;\n \n   e1f = make_edge (bb1, bbf, EDGE_FALLTHRU);\n   e1f->probability = profile_probability::always ();\n-  e1f->count = info->other_count;\n \n   if (info->default_case_nonstandard)\n     e2f = NULL;\n   else\n     {\n       e2f = make_edge (bb2, bbf, EDGE_FALLTHRU);\n       e2f->probability = profile_probability::always ();\n-      e2f->count = info->default_count;\n     }\n \n   /* frequencies of the new BBs */\n@@ -2248,12 +2243,10 @@ do_jump_if_equal (basic_block bb, tree op0, tree op1, basic_block label_bb,\n   edge false_edge = split_block (bb, cond);\n   false_edge->flags = EDGE_FALSE_VALUE;\n   false_edge->probability = prob.invert ();\n-  false_edge->count = bb->count.apply_probability (false_edge->probability);\n \n   edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n   fix_phi_operands_for_edge (true_edge, phi_mapping);\n   true_edge->probability = prob;\n-  true_edge->count = bb->count.apply_probability (true_edge->probability);\n \n   return false_edge->dest;\n }\n@@ -2293,12 +2286,10 @@ emit_cmp_and_jump_insns (basic_block bb, tree op0, tree op1,\n   edge false_edge = split_block (bb, cond);\n   false_edge->flags = EDGE_FALSE_VALUE;\n   false_edge->probability = prob.invert ();\n-  false_edge->count = bb->count.apply_probability (false_edge->probability);\n \n   edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n   fix_phi_operands_for_edge (true_edge, phi_mapping);\n   true_edge->probability = prob;\n-  true_edge->count = bb->count.apply_probability (true_edge->probability);\n \n   return false_edge->dest;\n }"}, {"sha": "9bcd1d6890ae68e7d7e572116022dd9606ff732a", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -807,7 +807,6 @@ adjust_return_value (basic_block bb, tree m, tree a)\n static void\n decrease_profile (basic_block bb, profile_count count, int frequency)\n {\n-  edge e;\n   bb->count = bb->count - count;\n   bb->frequency -= frequency;\n   if (bb->frequency < 0)\n@@ -817,8 +816,6 @@ decrease_profile (basic_block bb, profile_count count, int frequency)\n       gcc_assert (!EDGE_COUNT (bb->succs));\n       return;\n     }\n-  e = single_succ_edge (bb);\n-  e->count -= count;\n }\n \n /* Returns true if argument PARAM of the tail recursive call needs to be copied\n@@ -895,11 +892,11 @@ eliminate_tail_call (struct tailcall *t)\n \n   /* Number of executions of function has reduced by the tailcall.  */\n   e = single_succ_edge (gsi_bb (t->call_gsi));\n-  decrease_profile (EXIT_BLOCK_PTR_FOR_FN (cfun), e->count, EDGE_FREQUENCY (e));\n-  decrease_profile (ENTRY_BLOCK_PTR_FOR_FN (cfun), e->count,\n+  decrease_profile (EXIT_BLOCK_PTR_FOR_FN (cfun), e->count (), EDGE_FREQUENCY (e));\n+  decrease_profile (ENTRY_BLOCK_PTR_FOR_FN (cfun), e->count (),\n \t\t    EDGE_FREQUENCY (e));\n   if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-    decrease_profile (e->dest, e->count, EDGE_FREQUENCY (e));\n+    decrease_profile (e->dest, e->count (), EDGE_FREQUENCY (e));\n \n   /* Replace the call by a jump to the start of function.  */\n   e = redirect_edge_and_branch (single_succ_edge (gsi_bb (t->call_gsi)),"}, {"sha": "d4c233e0b5a1f4494860fbf9e25ea65dbd4bce18", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -563,13 +563,10 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n   /* Add new edge to connect guard block to the merge/loop-exit block.  */\n   new_e = make_edge (guard_bb, guard_to, EDGE_TRUE_VALUE);\n \n-  new_e->count = guard_bb->count;\n   new_e->probability = probability;\n-  new_e->count = enter_e->count.apply_probability (probability);\n   if (irreducible_p)\n     new_e->flags |= EDGE_IRREDUCIBLE_LOOP;\n \n-  enter_e->count -= new_e->count;\n   enter_e->probability = probability.invert ();\n   set_immediate_dominator (CDI_DOMINATORS, guard_to, dom_bb);\n \n@@ -1848,7 +1845,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t     a merge point of control flow.  */\n \t  guard_to->frequency = guard_bb->frequency;\n \t  guard_to->count = guard_bb->count;\n-\t  single_succ_edge (guard_to)->count = guard_to->count;\n \t  /* Scale probability of epilog loop back.\n \t     FIXME: We should avoid scaling down and back up.  Profile may\n \t     get lost if we scale down to 0.  */"}, {"sha": "7a0f9d5ad07a1968ea1a2af0372e59e6b52a4343", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -7224,7 +7224,7 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n   edge preheader = loop_preheader_edge (loop);\n   /* Reduce loop iterations by the vectorization factor.  */\n   gcov_type new_est_niter = niter_for_unrolled_loop (loop, vf);\n-  profile_count freq_h = loop->header->count, freq_e = preheader->count;\n+  profile_count freq_h = loop->header->count, freq_e = preheader->count ();\n \n   /* Use frequency only if counts are zero.  */\n   if (!(freq_h > 0) && !(freq_e > 0))\n@@ -7244,16 +7244,13 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n       scale_loop_frequencies (loop, p);\n     }\n \n-  basic_block exit_bb = single_pred (loop->latch);\n   edge exit_e = single_exit (loop);\n-  exit_e->count = loop_preheader_edge (loop)->count;\n   exit_e->probability = profile_probability::always ()\n \t\t\t\t .apply_scale (1, new_est_niter + 1);\n \n   edge exit_l = single_pred_edge (loop->latch);\n   profile_probability prob = exit_l->probability;\n   exit_l->probability = exit_e->probability.invert ();\n-  exit_l->count = exit_bb->count - exit_e->count;\n   if (prob.initialized_p () && exit_l->probability.initialized_p ())\n     scale_bbs_frequencies (&loop->latch, 1, exit_l->probability / prob);\n }"}, {"sha": "a6d446a69a84671afcf720ce4e5d3b09ee913cc0", "filename": "gcc/ubsan.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -813,7 +813,6 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n   /* Set up the fallthrough basic block.  */\n   e = find_edge (cond_bb, fallthru_bb);\n   e->flags = EDGE_FALSE_VALUE;\n-  e->count = cond_bb->count;\n   e->probability = profile_probability::very_likely ();\n \n   /* Update dominance info for the newly created then_bb; note that\n@@ -884,7 +883,6 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n \t  /* Set up the fallthrough basic block.  */\n \t  e = find_edge (cond1_bb, cond2_bb);\n \t  e->flags = EDGE_FALSE_VALUE;\n-\t  e->count = cond1_bb->count;\n \t  e->probability = profile_probability::very_likely ();\n \n \t  /* Update dominance info.  */\n@@ -1075,7 +1073,6 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n   e->flags = EDGE_FALSE_VALUE;\n   if (pos_neg != 3)\n     {\n-      e->count = cond_bb->count;\n       e->probability = profile_probability::very_likely ();\n \n       /* Connect 'then block' with the 'else block'.  This is needed\n@@ -1091,14 +1088,11 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n     }\n   else\n     {\n-      profile_count count = cond_bb->count.apply_probability (PROB_EVEN);\n-      e->count = count;\n       e->probability = profile_probability::even ();\n \n       e = split_block (fallthru_bb, (gimple *) NULL);\n       cond_neg_bb = e->src;\n       fallthru_bb = e->dest;\n-      e->count = count;\n       e->probability = profile_probability::very_likely ();\n       e->flags = EDGE_FALSE_VALUE;\n \n@@ -1109,14 +1103,12 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n       add_bb_to_loop (cond_pos_bb, cond_bb->loop_father);\n \n       e = make_edge (cond_bb, cond_pos_bb, EDGE_TRUE_VALUE);\n-      e->count = count;\n       e->probability = profile_probability::even ();\n \n       e = make_edge (cond_pos_bb, then_bb, EDGE_TRUE_VALUE);\n       e->probability = profile_probability::very_unlikely ();\n \n       e = make_edge (cond_pos_bb, fallthru_bb, EDGE_FALSE_VALUE);\n-      e->count = count;\n       e->probability = profile_probability::very_likely ();\n \n       make_single_succ_edge (then_bb, fallthru_bb, EDGE_FALLTHRU);"}, {"sha": "704900f9e8d4746a9afa26804a5ded0c3e4f26c8", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef30ab837c42b9555b3fc290454a5c02cb65487a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=ef30ab837c42b9555b3fc290454a5c02cb65487a", "patch": "@@ -745,20 +745,16 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, profile_probability prob,\n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = prob;\n-  e12->count = profile_count::from_gcov_type (count);\n \n   e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n   e13->probability = prob.invert ();\n-  e13->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e23);\n \n   e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n   e24->probability = profile_probability::always ();\n-  e24->count = profile_count::from_gcov_type (count);\n \n   e34->probability = profile_probability::always ();\n-  e34->count = profile_count::from_gcov_type (all - count);\n \n   return tmp2;\n }\n@@ -910,20 +906,16 @@ gimple_mod_pow2 (gassign *stmt, profile_probability prob, gcov_type count, gcov_\n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = prob;\n-  e12->count = profile_count::from_gcov_type (count);\n \n   e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n   e13->probability = prob.invert ();\n-  e13->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e23);\n \n   e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n   e24->probability = profile_probability::always ();\n-  e24->count = profile_count::from_gcov_type (count);\n \n   e34->probability = profile_probability::always ();\n-  e34->count = profile_count::from_gcov_type (all - count);\n \n   return result;\n }\n@@ -1076,26 +1068,21 @@ gimple_mod_subtract (gassign *stmt, profile_probability prob1,\n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = prob1.invert ();\n-  e12->count = profile_count::from_gcov_type (all - count1);\n \n   e14 = make_edge (bb, bb4, EDGE_TRUE_VALUE);\n   e14->probability = prob1;\n-  e14->count = profile_count::from_gcov_type (count1);\n \n   if (ncounts)  /* Assumed to be 0 or 1.  */\n     {\n       e23->flags &= ~EDGE_FALLTHRU;\n       e23->flags |= EDGE_FALSE_VALUE;\n-      e23->count = profile_count::from_gcov_type (all - count1 - count2);\n       e23->probability = prob2.invert ();\n \n       e24 = make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n       e24->probability = prob2;\n-      e24->count = profile_count::from_gcov_type (count2);\n     }\n \n   e34->probability = profile_probability::always ();\n-  e34->count = profile_count::from_gcov_type (all - count1 - count2);\n \n   return result;\n }\n@@ -1383,7 +1370,6 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n       if (e_ij != NULL)\n \t{\n \t  e_ij->probability = profile_probability::always ();\n-\t  e_ij->count = all - count;\n \t  e_ij = single_pred_edge (split_edge (e_ij));\n \t}\n     }\n@@ -1395,25 +1381,18 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n \n   e_cd->flags = (e_cd->flags & ~EDGE_FALLTHRU) | EDGE_TRUE_VALUE;\n   e_cd->probability = prob;\n-  e_cd->count = count;\n \n   e_ci = make_edge (cond_bb, icall_bb, EDGE_FALSE_VALUE);\n   e_ci->probability = prob.invert ();\n-  e_ci->count = all - count;\n \n   remove_edge (e_di);\n \n   if (e_ij != NULL)\n     {\n-      if ((dflags & ECF_NORETURN) != 0)\n-\te_ij->count = all;\n-      else\n+      if ((dflags & ECF_NORETURN) == 0)\n \t{\n \t  e_dj = make_edge (dcall_bb, join_bb, EDGE_FALLTHRU);\n \t  e_dj->probability = profile_probability::always ();\n-\t  e_dj->count = count;\n-\n-\t  e_ij->count = all - count;\n \t}\n       e_ij->probability = profile_probability::always ();\n     }\n@@ -1494,7 +1473,6 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n       {\n \te = make_edge (dcall_bb, e_eh->dest, e_eh->flags);\n \te->probability = e_eh->probability;\n-\te->count = e_eh->count;\n \tfor (gphi_iterator psi = gsi_start_phis (e_eh->dest);\n \t     !gsi_end_p (psi); gsi_next (&psi))\n \t  {\n@@ -1704,20 +1682,16 @@ gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, profile_probabi\n \n   e_ci->flags = (e_ci->flags & ~EDGE_FALLTHRU) | EDGE_TRUE_VALUE;\n   e_ci->probability = prob;\n-  e_ci->count = profile_count::from_gcov_type (count);\n \n   e_cv = make_edge (cond_bb, vcall_bb, EDGE_FALSE_VALUE);\n   e_cv->probability = prob.invert ();\n-  e_cv->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e_iv);\n \n   e_ij = make_edge (icall_bb, join_bb, EDGE_FALLTHRU);\n   e_ij->probability = profile_probability::always ();\n-  e_ij->count = profile_count::from_gcov_type (count);\n \n   e_vj->probability = profile_probability::always ();\n-  e_vj->count = profile_count::from_gcov_type (all - count);\n \n   /* Insert PHI node for the call result if necessary.  */\n   if (gimple_call_lhs (vcall_stmt)"}]}