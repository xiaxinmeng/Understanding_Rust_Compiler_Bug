{"sha": "4caaac22518cf777399a421aeaacdf3ab9491fa4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhYWFjMjI1MThjZjc3NzM5OWE0MjFhZWFhY2RmM2FiOTQ5MWZhNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-07-10T00:02:36Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-07-10T00:02:36Z"}, "message": "PR tree-optimization/86415 - strlen() not folded for substrings within constant arrays\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/strlenopt-53.c: New test.\n\nFrom-SVN: r262528", "tree": {"sha": "16e3d01890bc10b5c8693a768e088f0900098934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16e3d01890bc10b5c8693a768e088f0900098934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4caaac22518cf777399a421aeaacdf3ab9491fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4caaac22518cf777399a421aeaacdf3ab9491fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4caaac22518cf777399a421aeaacdf3ab9491fa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4caaac22518cf777399a421aeaacdf3ab9491fa4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b4d3a644222b7bd69b3a1e9c00e78f3dbf3eba"}], "stats": {"total": 121, "additions": 121, "deletions": 0}, "files": [{"sha": "8e2abceb459caa3bcc182322e3c50edd0ece0e90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caaac22518cf777399a421aeaacdf3ab9491fa4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caaac22518cf777399a421aeaacdf3ab9491fa4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4caaac22518cf777399a421aeaacdf3ab9491fa4", "patch": "@@ -1,3 +1,8 @@\n+2018-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/86415\n+\t* gcc.dg/strlenopt-53.c: New test.\n+\n 2018-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/77357"}, {"sha": "baa680d125b90b3c2d5355c613842df1a9b70a8c", "filename": "gcc/testsuite/gcc.dg/strlenopt-53.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4caaac22518cf777399a421aeaacdf3ab9491fa4/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4caaac22518cf777399a421aeaacdf3ab9491fa4/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-53.c?ref=4caaac22518cf777399a421aeaacdf3ab9491fa4", "patch": "@@ -0,0 +1,116 @@\n+/* PR tree-optimization/86415 - strlen() not folded for substrings\n+   within constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-gimple -fdump-tree-ccp\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+   call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+#define T(s, n) ELIM (strlen (s) == n)\n+\n+/*                              11111\n+\t\t\t\t0 1  23 4  567 8  901234  */\n+#define STR \"1\\00012\\000123\\0001234\\0\"\n+\n+const char a[]   = STR;\n+const char b[20] = STR;\n+\n+void test_literal (void)\n+{\n+  /* Verify that strlen() of substrings within a string literal are\n+     correctly folded.  */\n+  T (STR,      1);  T (STR +  1, 0);  T (STR +  2, 2);  T (STR +  3, 1);\n+  T (STR +  4, 0);  T (STR +  5, 3);  T (STR +  6, 2);  T (STR +  7, 1);\n+  T (STR +  8, 0);  T (STR +  9, 4);  T (STR + 10, 3);  T (STR + 11, 2);\n+  T (STR + 12, 1);  T (STR + 13, 0);  T (STR + 14, 0);\n+\n+  T (&(STR[0]),  1);  T (&(STR[ 1]), 0);  T (&(STR[ 2]), 2);\n+  T (&(STR[ 3]), 1);  T (&(STR[ 4]), 0);  T (&(STR[ 5]), 3);\n+  T (&(STR[ 6]), 2);  T (&(STR[ 7]), 1);  T (&(STR[ 8]), 0);\n+  T (&(STR[ 9]), 4);  T (&(STR[10]), 3);  T (&(STR[11]), 2);\n+  T (&(STR[12]), 1);  T (&(STR[13]), 0);  T (&(STR[14]), 0);\n+\n+  T (&(STR[0])  +  1, 0);  T (&(STR[ 1]) +  1, 2);  T (&(STR[ 2]) +  1, 1);\n+  T (&(STR[ 3]) +  1, 0);  T (&(STR[ 4]) +  1, 3);  T (&(STR[ 5]) +  1, 2);\n+  T (&(STR[ 6]) +  1, 1);  T (&(STR[ 7]) +  1, 0);  T (&(STR[ 8]) +  1, 4);\n+  T (&(STR[ 9]) +  1, 3);  T (&(STR[10]) +  1, 2);  T (&(STR[11]) +  1, 1);\n+  T (&(STR[12]) +  1, 0);  T (&(STR[13]) +  1, 0);  T (&(STR[13]) - 13, 1);\n+  T (&(STR[13]) - 12, 0);  T (&(STR[13]) - 11, 2);  T (&(STR[13]) - 10, 1);\n+}\n+\n+void test_array (void)\n+{\n+  /* Verify that strlen() of substrings within a fully initialized\n+     array are correctly folded.  */\n+  T (a,      1);  T (a +  1, 0);  T (a +  2, 2);  T (a +  3, 1);\n+  T (a +  4, 0);  T (a +  5, 3);  T (a +  6, 2);  T (a +  7, 1);\n+  T (a +  8, 0);  T (a +  9, 4);  T (a + 10, 3);  T (a + 11, 2);\n+  T (a + 12, 1);  T (a + 13, 0);  T (a + 14, 0);\n+\n+  /* Verify that strlen() of substrings within a partially initialized\n+     array are also correctly folded, including those referring to\n+     the empty substrings in the implicitly initialized elements.  */\n+  T (b,      1);  T (b +  1, 0);  T (b +  2, 2);  T (b +  3, 1);\n+  T (b +  4, 0);  T (b +  5, 3);  T (b +  6, 2);  T (b +  7, 1);\n+  T (b +  8, 0);  T (b +  9, 4);  T (b + 10, 3);  T (b + 11, 2);\n+  T (b + 12, 1);  T (b + 13, 0);  T (b + 14, 0);  T (b + 15, 0);\n+  T (b + 16, 0);  T (b + 17, 0);  T (b + 18, 0);  T (b + 19, 0);\n+}\n+\n+void test_array_ref_plus (void)\n+{\n+  /* Verify that strlen() of substrings within a fully initialized\n+     array referred to by array indices with offsets are correctly\n+     folded.  */\n+  T (&a[ 0],     1);  T (&a[ 0] + 1, 0);\n+  T (&a[ 1],     0);  T (&a[ 1] + 1, 2);\n+  T (&a[ 2],     2);  T (&a[ 2] + 1, 1);  T (&a[ 2] + 2, 0);\n+  T (&a[ 3],     1);  T (&a[ 3] + 1, 0);\n+  T (&a[ 4],     0);  T (&a[ 4] + 1, 3);\n+  T (&a[ 5],     3);  T (&a[ 5] + 1, 2);\n+  T (&a[ 5] + 2, 1);  T (&a[ 5] + 3, 0);  T (&a[ 5] + 4, 4);\n+  T (&a[ 6],     2);  T (&a[ 6] + 1, 1);  T (&a[ 6] + 2, 0);\n+  T (&a[ 7],     1);  T (&a[ 7] + 1, 0);\n+  T (&a[ 8],     0);  T (&a[ 8] + 1, 4);\n+  T (&a[ 9],     4);  T (&a[ 9] + 1, 3);  T (&a[ 9] + 2, 2);\n+  T (&a[ 9] + 3, 1);  T (&a[ 9] + 4, 0);  T (&a[ 9] + 5, 0);\n+  T (&a[10],     3);  T (&a[10] + 1, 2);  T (&a[10] + 2, 1);\n+  T (&a[10] + 3, 0);  T (&a[10] + 4, 0);\n+  T (&a[11],     2);  T (&a[11] + 1, 1);  T (&a[11] + 2, 0);\n+  T (&a[12],     1);  T (&a[12] + 1, 0);  T (&a[12] + 2, 0);\n+  T (&a[13],     0);  T (&a[13] + 1, 0);\n+  T (&a[14],     0);\n+}\n+\n+void test_array_ref (void)\n+{\n+  T (&a[ 0], 1);  T (&a[ 1], 0);  T (&a[ 2], 2);  T (&a[ 3], 1);\n+  T (&a[ 4], 0);  T (&a[ 5], 3);  T (&a[ 6], 2);  T (&a[ 7], 1);\n+  T (&a[ 8], 0);  T (&a[ 9], 4);  T (&a[10], 3);  T (&a[11], 2);\n+  T (&a[12], 1);  T (&a[13], 0);  T (&a[14], 0);\n+\n+  T (&b[ 0], 1);  T (&b[ 1], 0);  T (&b[ 2], 2);  T (&b[ 3], 1);\n+  T (&b[ 4], 0);  T (&b[ 5], 3);  T (&b[ 6], 2);  T (&b[ 7], 1);\n+  T (&b[ 8], 0);  T (&b[ 9], 4);  T (&b[10], 3);  T (&b[11], 2);\n+  T (&b[12], 1);  T (&b[13], 0);  T (&b[14], 0);  T (&b[15], 0);\n+  T (&b[16], 0);  T (&b[17], 0);  T (&b[18], 0);  T (&b[19], 0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"gimple\" } }\n+   { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"ccp1\" } } */"}]}