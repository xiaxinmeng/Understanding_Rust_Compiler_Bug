{"sha": "b664de3a04685f7558b80df9f172deb8decebeff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2NGRlM2EwNDY4NWY3NTU4YjgwZGY5ZjE3MmRlYjhkZWNlYmVmZg==", "commit": {"author": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-03-25T12:04:22Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-03-25T12:04:22Z"}, "message": "rtl.texi (RTX_FRAME_RELATED_P): Add documentation.\n\n \nThu Mar 25 14:04:54 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>\n\t* rtl.texi (RTX_FRAME_RELATED_P): Add documentation.\n\t* rtl.h (struct rtx_def): Update comment for frame_related field.\n\t(set_unique_reg_note): Declare prototype.\n\t* dwarf2out.c (dwarf2out_frame_debug_expr): Split out from\n\t'dwarf2out_frame_debug' to handle only expressions, and process\n\tcomponent parts of a PARALLEL expression.\n\t(dwarf2out_frame_debug): Process insns only, and call\n\tnew function 'dwarf2out_frame_debug_expr' for patterns.\n\t* emit-rtl.c (set_unique_reg_note): New function to add a reg note,\n\tbut if there is an existingone, deletes it first.\n\t* expmed.c (expand_mult, expand_divmod): Use set_unique_reg_note.\n\t* optabs.c (add_equal_note, expand_binop): Use set_unique_reg_note.\n\t(emit_no_conflict_block, emit_libcall_block): Use set_unique_reg_note.\n\t(expand_fix):  Use set_unique_reg_note.\n\nFrom-SVN: r25977", "tree": {"sha": "2807170ca4b3477caead2eefd8812ea0080b4eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2807170ca4b3477caead2eefd8812ea0080b4eb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b664de3a04685f7558b80df9f172deb8decebeff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b664de3a04685f7558b80df9f172deb8decebeff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b664de3a04685f7558b80df9f172deb8decebeff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b664de3a04685f7558b80df9f172deb8decebeff/comments", "author": null, "committer": null, "parents": [{"sha": "2b4b3e5f2199f5ac53d81e4dfca4242b6f58ea29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4b3e5f2199f5ac53d81e4dfca4242b6f58ea29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b4b3e5f2199f5ac53d81e4dfca4242b6f58ea29"}], "stats": {"total": 422, "additions": 229, "deletions": 193}, "files": [{"sha": "50d6937eb855aecebc3f360263cada58fe348aa0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 227, "deletions": 192, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b664de3a04685f7558b80df9f172deb8decebeff/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b664de3a04685f7558b80df9f172deb8decebeff/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b664de3a04685f7558b80df9f172deb8decebeff", "patch": "@@ -1186,6 +1186,230 @@ dwarf2out_stack_adjust (insn)\n   dwarf2out_args_size (label, args_size);\n }\n \n+/* A temporary register used in adjusting SP or setting up the store_reg.  */\n+static unsigned cfa_temp_reg;\n+\n+/* A temporary value used in adjusting SP or setting up the store_reg.  */\n+static long cfa_temp_value;\n+\n+/* Record call frame debugging information for an expression, which either\n+   sets SP or FP (adjusting how we calculate the frame address) or saves a\n+   register to the stack. */\n+\n+static void\n+dwarf2out_frame_debug_expr (expr, label)\n+     rtx expr;\n+     char *label;\n+{\n+  rtx src, dest;\n+  long offset;\n+    \n+  /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of \n+     the PARALLEL independantly. The first element is always processed if \n+     it is a SET. This is for backward compatability.   Other elements \n+     are processed only if they are SETs and the RTX_FRAME_RELATED_P \n+     flag is set in them. */\n+\n+  if (GET_CODE (expr) == PARALLEL)\n+    { \n+      int par_index;\n+      int limit = XVECLEN (expr, 0);\n+\n+      for (par_index = 0; par_index < limit; par_index++)\n+        {\n+          rtx x = XVECEXP (expr, 0, par_index);\n+          \n+          if (GET_CODE (x) == SET &&\n+\t      (RTX_FRAME_RELATED_P (x) || par_index == 0))\n+\t      dwarf2out_frame_debug_expr (x, label);\n+        }\n+      return;\n+    }\n+  \n+  if (GET_CODE (expr) != SET)\n+    abort ();\n+\n+  src = SET_SRC (expr);\n+  dest = SET_DEST (expr);\n+\n+  switch (GET_CODE (dest))\n+    {\n+    case REG:\n+      /* Update the CFA rule wrt SP or FP.  Make sure src is\n+         relative to the current CFA register.  */\n+      switch (GET_CODE (src))\n+        {\n+          /* Setting FP from SP.  */\n+        case REG:\n+          if (cfa_reg != (unsigned) REGNO (src))\n+            abort ();\n+          if (REGNO (dest) != STACK_POINTER_REGNUM\n+      \t&& !(frame_pointer_needed\n+      \t     && REGNO (dest) == HARD_FRAME_POINTER_REGNUM))\n+            abort ();\n+          cfa_reg = REGNO (dest);\n+          break;\n+\n+        case PLUS:\n+        case MINUS:\n+          if (dest == stack_pointer_rtx)\n+            {\n+      \t/* Adjusting SP.  */\n+      \tswitch (GET_CODE (XEXP (src, 1)))\n+      \t  {\n+      \t  case CONST_INT:\n+      \t    offset = INTVAL (XEXP (src, 1));\n+      \t    break;\n+      \t  case REG:\n+      \t    if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp_reg)\n+      \t      abort ();\n+      \t    offset = cfa_temp_value;\n+      \t    break;\n+      \t  default:\n+      \t    abort ();\n+      \t  }\n+\n+      \tif (XEXP (src, 0) == hard_frame_pointer_rtx)\n+      \t  {\n+      \t    /* Restoring SP from FP in the epilogue.  */\n+      \t    if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n+      \t      abort ();\n+      \t    cfa_reg = STACK_POINTER_REGNUM;\n+      \t  }\n+      \telse if (XEXP (src, 0) != stack_pointer_rtx)\n+      \t  abort ();\n+\n+      \tif (GET_CODE (src) == PLUS)\n+      \t  offset = -offset;\n+      \tif (cfa_reg == STACK_POINTER_REGNUM)\n+      \t  cfa_offset += offset;\n+      \tif (cfa_store_reg == STACK_POINTER_REGNUM)\n+      \t  cfa_store_offset += offset;\n+            }\n+          else if (dest == hard_frame_pointer_rtx)\n+            {\n+      \t/* Either setting the FP from an offset of the SP,\n+      \t   or adjusting the FP */\n+      \tif (! frame_pointer_needed\n+      \t    || REGNO (dest) != HARD_FRAME_POINTER_REGNUM)\n+      \t  abort ();\n+\n+      \tif (XEXP (src, 0) == stack_pointer_rtx\n+      \t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+      \t  {\n+      \t    if (cfa_reg != STACK_POINTER_REGNUM)\n+      \t      abort ();\n+      \t    offset = INTVAL (XEXP (src, 1));\n+      \t    if (GET_CODE (src) == PLUS)\n+      \t      offset = -offset;\n+      \t    cfa_offset += offset;\n+      \t    cfa_reg = HARD_FRAME_POINTER_REGNUM;\n+      \t  }\n+      \telse if (XEXP (src, 0) == hard_frame_pointer_rtx\n+      \t\t && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+      \t  {\n+      \t    if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n+      \t      abort ();\n+      \t    offset = INTVAL (XEXP (src, 1));\n+      \t    if (GET_CODE (src) == PLUS)\n+      \t      offset = -offset;\n+      \t    cfa_offset += offset;\n+      \t  }\n+\n+      \telse \n+      \t  abort();\n+            }\n+          else\n+            {\n+      \tif (GET_CODE (src) != PLUS\n+      \t    || XEXP (src, 1) != stack_pointer_rtx)\n+      \t  abort ();\n+      \tif (GET_CODE (XEXP (src, 0)) != REG\n+      \t    || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg)\n+      \t  abort ();\n+      \tif (cfa_reg != STACK_POINTER_REGNUM)\n+      \t  abort ();\n+      \tcfa_store_reg = REGNO (dest);\n+      \tcfa_store_offset = cfa_offset - cfa_temp_value;\n+            }\n+          break;\n+\n+        case CONST_INT:\n+          cfa_temp_reg = REGNO (dest);\n+          cfa_temp_value = INTVAL (src);\n+          break;\n+\n+        case IOR:\n+          if (GET_CODE (XEXP (src, 0)) != REG\n+      \t|| (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg\n+      \t|| (unsigned) REGNO (dest) != cfa_temp_reg\n+      \t|| GET_CODE (XEXP (src, 1)) != CONST_INT)\n+            abort ();\n+          cfa_temp_value |= INTVAL (XEXP (src, 1));\n+          break;\n+\n+        default:\n+          abort ();\n+        }\n+      dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n+    break;\n+\n+  case MEM:\n+    /* Saving a register to the stack.  Make sure dest is relative to the\n+       CFA register.  */\n+    if (GET_CODE (src) != REG)\n+      abort ();\n+    switch (GET_CODE (XEXP (dest, 0)))\n+      {\n+        /* With a push.  */\n+      case PRE_INC:\n+      case PRE_DEC:\n+        offset = GET_MODE_SIZE (GET_MODE (dest));\n+        if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n+          offset = -offset;\n+\n+        if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n+            || cfa_store_reg != STACK_POINTER_REGNUM)\n+          abort ();\n+        cfa_store_offset += offset;\n+        if (cfa_reg == STACK_POINTER_REGNUM)\n+          cfa_offset = cfa_store_offset;\n+\n+        offset = -cfa_store_offset;\n+        break;\n+\n+        /* With an offset.  */\n+      case PLUS:\n+      case MINUS:\n+        offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+        if (GET_CODE (XEXP (dest, 0)) == MINUS)\n+          offset = -offset;\n+\n+        if (cfa_store_reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n+          abort ();\n+        offset -= cfa_store_offset;\n+        break;\n+\n+        /* Without an offset.  */\n+      case REG:\n+        if (cfa_store_reg != (unsigned) REGNO (XEXP (dest, 0)))\n+          abort();\n+        offset = -cfa_store_offset;\n+        break;\n+\n+      default:\n+        abort ();\n+      }\n+    dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n+    dwarf2out_reg_save (label, REGNO (src), offset);\n+    break;\n+\n+  default:\n+    abort ();\n+  }\n+}\n+\n+\n /* Record call frame debugging information for INSN, which either\n    sets SP or FP (adjusting how we calculate the frame address) or saves a\n    register to the stack.  If INSN is NULL_RTX, initialize our state.  */\n@@ -1195,12 +1419,7 @@ dwarf2out_frame_debug (insn)\n      rtx insn;\n {\n   char *label;\n-  rtx src, dest;\n-  long offset;\n-\n-  /* A temporary register used in adjusting SP or setting up the store_reg.  */\n-  static unsigned cfa_temp_reg;\n-  static long cfa_temp_value;\n+  rtx src;\n \n   if (insn == NULL_RTX)\n     {\n@@ -1227,194 +1446,10 @@ dwarf2out_frame_debug (insn)\n   src = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n   if (src)\n     insn = XEXP (src, 0);\n-  else\n+  else \n     insn = PATTERN (insn);\n \n-  /* Assume that in a PARALLEL prologue insn, only the first elt is\n-     significant.  Currently this is true.  */\n-  if (GET_CODE (insn) == PARALLEL)\n-    insn = XVECEXP (insn, 0, 0);\n-  if (GET_CODE (insn) != SET)\n-    abort ();\n-\n-  src = SET_SRC (insn);\n-  dest = SET_DEST (insn);\n-\n-  switch (GET_CODE (dest))\n-    {\n-    case REG:\n-      /* Update the CFA rule wrt SP or FP.  Make sure src is\n-\t relative to the current CFA register.  */\n-      switch (GET_CODE (src))\n-\t{\n-\t  /* Setting FP from SP.  */\n-\tcase REG:\n-\t  if (cfa_reg != (unsigned) REGNO (src))\n-\t    abort ();\n-\t  if (REGNO (dest) != STACK_POINTER_REGNUM\n-\t      && !(frame_pointer_needed\n-\t\t   && REGNO (dest) == HARD_FRAME_POINTER_REGNUM))\n-\t    abort ();\n-\t  cfa_reg = REGNO (dest);\n-\t  break;\n-\n-\tcase PLUS:\n-\tcase MINUS:\n-\t  if (dest == stack_pointer_rtx)\n-\t    {\n-\t      /* Adjusting SP.  */\n-\t      switch (GET_CODE (XEXP (src, 1)))\n-\t\t{\n-\t\tcase CONST_INT:\n-\t\t  offset = INTVAL (XEXP (src, 1));\n-\t\t  break;\n-\t\tcase REG:\n-\t\t  if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp_reg)\n-\t\t    abort ();\n-\t\t  offset = cfa_temp_value;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n-\n-\t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n-\t\t{\n-\t\t  /* Restoring SP from FP in the epilogue.  */\n-\t\t  if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n-\t\t    abort ();\n-\t\t  cfa_reg = STACK_POINTER_REGNUM;\n-\t\t}\n-\t      else if (XEXP (src, 0) != stack_pointer_rtx)\n-\t\tabort ();\n-\n-\t      if (GET_CODE (src) == PLUS)\n-\t\toffset = -offset;\n-\t      if (cfa_reg == STACK_POINTER_REGNUM)\n-\t\tcfa_offset += offset;\n-\t      if (cfa_store_reg == STACK_POINTER_REGNUM)\n-\t\tcfa_store_offset += offset;\n-\t    }\n-          else if (dest == hard_frame_pointer_rtx)\n-            {\n-              /* Either setting the FP from an offset of the SP,\n-                 or adjusting the FP */\n-\t      if (! frame_pointer_needed\n-\t\t  || REGNO (dest) != HARD_FRAME_POINTER_REGNUM)\n-\t\tabort ();\n-\n-              if (XEXP (src, 0) == stack_pointer_rtx\n-                  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-                {\n-\t\t  if (cfa_reg != STACK_POINTER_REGNUM)\n-\t\t    abort ();\n-                  offset = INTVAL (XEXP (src, 1));\n-                  if (GET_CODE (src) == PLUS)\n-                    offset = -offset;\n-                  cfa_offset += offset;\n-                  cfa_reg = HARD_FRAME_POINTER_REGNUM;\n-                }\n-              else if (XEXP (src, 0) == hard_frame_pointer_rtx\n-                       && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-                {\n-\t\t  if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n-\t\t    abort ();\n-                  offset = INTVAL (XEXP (src, 1));\n-                  if (GET_CODE (src) == PLUS)\n-                    offset = -offset;\n-                  cfa_offset += offset;\n-                }\n-\n-              else \n-                abort();\n-            }\n-\t  else\n-\t    {\n-\t      if (GET_CODE (src) != PLUS\n-\t\t  || XEXP (src, 1) != stack_pointer_rtx)\n-\t\tabort ();\n-\t      if (GET_CODE (XEXP (src, 0)) != REG\n-\t\t  || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg)\n-\t\tabort ();\n-\t      if (cfa_reg != STACK_POINTER_REGNUM)\n-\t\tabort ();\n-\t      cfa_store_reg = REGNO (dest);\n-\t      cfa_store_offset = cfa_offset - cfa_temp_value;\n-\t    }\n-\t  break;\n-\n-\tcase CONST_INT:\n-\t  cfa_temp_reg = REGNO (dest);\n-\t  cfa_temp_value = INTVAL (src);\n-\t  break;\n-\n-\tcase IOR:\n-\t  if (GET_CODE (XEXP (src, 0)) != REG\n-\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg\n-\t      || (unsigned) REGNO (dest) != cfa_temp_reg\n-\t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n-\t    abort ();\n-\t  cfa_temp_value |= INTVAL (XEXP (src, 1));\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n-      break;\n-\n-    case MEM:\n-      /* Saving a register to the stack.  Make sure dest is relative to the\n-         CFA register.  */\n-      if (GET_CODE (src) != REG)\n-\tabort ();\n-      switch (GET_CODE (XEXP (dest, 0)))\n-\t{\n-\t  /* With a push.  */\n-\tcase PRE_INC:\n-\tcase PRE_DEC:\n-\t  offset = GET_MODE_SIZE (GET_MODE (dest));\n-\t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n-\t    offset = -offset;\n-\n-\t  if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n-\t      || cfa_store_reg != STACK_POINTER_REGNUM)\n-\t    abort ();\n-\t  cfa_store_offset += offset;\n-\t  if (cfa_reg == STACK_POINTER_REGNUM)\n-\t    cfa_offset = cfa_store_offset;\n-\n-\t  offset = -cfa_store_offset;\n-\t  break;\n-\n-\t  /* With an offset.  */\n-\tcase PLUS:\n-\tcase MINUS:\n-\t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n-\t  if (GET_CODE (src) == MINUS)\n-\t    offset = -offset;\n-\n-\t  if (cfa_store_reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n-\t    abort ();\n-\t  offset -= cfa_store_offset;\n-\t  break;\n-\n-\t  /* Without an offset.  */\n-\tcase REG:\n-\t  if (cfa_store_reg != (unsigned) REGNO (XEXP (dest, 0)))\n-\t    abort();\n-\t  offset = -cfa_store_offset;\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n-      dwarf2out_reg_save (label, REGNO (src), offset);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n+  dwarf2out_frame_debug_expr (insn, label);\n }\n \n /* Return the size of an unsigned LEB128 quantity.  */"}, {"sha": "a033733c8e4d3385589147e3b11571c303c9cc40", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b664de3a04685f7558b80df9f172deb8decebeff/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b664de3a04685f7558b80df9f172deb8decebeff/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b664de3a04685f7558b80df9f172deb8decebeff", "patch": "@@ -164,7 +164,7 @@ typedef struct rtx_def\n      In a REG, nonzero means this reg refers to the return value\n      of the current function.  */\n   unsigned integrated : 1;\n-  /* 1 in an INSN if this rtx is related to the call frame,\n+  /* 1 in an INSN or a SET if this rtx is related to the call frame,\n      either changing how we compute the frame address or saving and\n      restoring registers in the prologue and epilogue.  \n      1 in a MEM if the MEM refers to a scalar, rather than a member of\n@@ -997,6 +997,7 @@ extern rtx gen_mem_addressof\t\tPROTO((rtx, union tree_node *));\n extern rtx eliminate_constant_term\tPROTO((rtx, rtx *));\n extern rtx expand_complex_abs\t\tPROTO((enum machine_mode, rtx, rtx, int));\n extern enum machine_mode choose_hard_reg_mode PROTO((int, int));\n+extern void set_unique_reg_note         PROTO((rtx, enum reg_note, rtx));\n \n /* Functions in rtlanal.c */\n "}]}