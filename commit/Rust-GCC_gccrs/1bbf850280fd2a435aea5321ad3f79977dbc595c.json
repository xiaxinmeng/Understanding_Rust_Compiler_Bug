{"sha": "1bbf850280fd2a435aea5321ad3f79977dbc595c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJiZjg1MDI4MGZkMmE0MzVhZWE1MzIxYWQzZjc5OTc3ZGJjNTk1Yw==", "commit": {"author": {"name": "Duncan Sands", "email": "baldrick@free.fr", "date": "2007-06-10T18:36:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-06-10T18:36:40Z"}, "message": "decl.c (gnat_to_gnu_entity): Use pointers to dummy nodes...\n\n\t* decl.c (gnat_to_gnu_entity): Use pointers to dummy nodes, rather\n\tthan to void, for the fields when making a new fat pointer type.\n\t(gnat_substitute_in_type): Now substitute_in_type.\n\t* gigi.h (gnat_substitute_in_type): Likewise.\n\t* trans.c (gnat_gimplify_expr): Remove COMPONENT_REF kludge.\n\t* utils.c (update_pointer_to): Update fat pointers by updating the\n\tdummy node pointers used for the fields.\n\nFrom-SVN: r125602", "tree": {"sha": "05c191c3e0692e3f81ae4fa151888959b5108a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05c191c3e0692e3f81ae4fa151888959b5108a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bbf850280fd2a435aea5321ad3f79977dbc595c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbf850280fd2a435aea5321ad3f79977dbc595c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bbf850280fd2a435aea5321ad3f79977dbc595c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbf850280fd2a435aea5321ad3f79977dbc595c/comments", "author": {"login": "CunningBaldrick", "id": 1713707, "node_id": "MDQ6VXNlcjE3MTM3MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1713707?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CunningBaldrick", "html_url": "https://github.com/CunningBaldrick", "followers_url": "https://api.github.com/users/CunningBaldrick/followers", "following_url": "https://api.github.com/users/CunningBaldrick/following{/other_user}", "gists_url": "https://api.github.com/users/CunningBaldrick/gists{/gist_id}", "starred_url": "https://api.github.com/users/CunningBaldrick/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CunningBaldrick/subscriptions", "organizations_url": "https://api.github.com/users/CunningBaldrick/orgs", "repos_url": "https://api.github.com/users/CunningBaldrick/repos", "events_url": "https://api.github.com/users/CunningBaldrick/events{/privacy}", "received_events_url": "https://api.github.com/users/CunningBaldrick/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55edccf416b868b9b05a459a25487785eaaf7b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55edccf416b868b9b05a459a25487785eaaf7b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55edccf416b868b9b05a459a25487785eaaf7b63"}], "stats": {"total": 166, "additions": 82, "deletions": 84}, "files": [{"sha": "7acbf44389d8dc768a05ec7229951e438a938924", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1bbf850280fd2a435aea5321ad3f79977dbc595c", "patch": "@@ -1,3 +1,13 @@\n+2007-06-10  Duncan Sands  <baldrick@free.fr>\n+\n+\t* decl.c (gnat_to_gnu_entity): Use pointers to dummy nodes, rather\n+\tthan to void, for the fields when making a new fat pointer type.\n+\t(gnat_substitute_in_type): Now substitute_in_type.\n+\t* gigi.h (gnat_substitute_in_type): Likewise.\n+\t* trans.c (gnat_gimplify_expr): Remove COMPONENT_REF kludge.\n+\t* utils.c (update_pointer_to): Update fat pointers by updating the\n+\tdummy node pointers used for the fields.\n+\n 2007-06-06  Thomas Quinot  <quinot@adacore.com>\n \t    Bob Duff  <duff@adacore.com>\n "}, {"sha": "86a8dd7a609a11be3876fd602097414d24773c13", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=1bbf850280fd2a435aea5321ad3f79977dbc595c", "patch": "@@ -3041,13 +3041,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     && ! Is_Constrained (gnat_desig_rep));\n \n \t/* If we are pointing to an incomplete type whose completion is an\n-\t   unconstrained array, make a fat pointer type instead of a pointer\n-\t   to VOID.  The two types in our fields will be pointers to VOID and\n-\t   will be replaced in update_pointer_to.  Similarly, if the type\n-\t   itself is a dummy type or an unconstrained array.  Also make\n-\t   a dummy TYPE_OBJECT_RECORD_TYPE in case we have any thin\n-\t   pointers to it.  */\n-\n+\t   unconstrained array, make a fat pointer type.  The two types in our\n+\t   fields will be pointers to dummy nodes and will be replaced in\n+\t   update_pointer_to.  Similarly, if the type itself is a dummy type or\n+\t   an unconstrained array.  Also make a dummy TYPE_OBJECT_RECORD_TYPE\n+\t   in case we have any thin pointers to it.  */\n \tif (is_unconstrained_array\n \t    && (Present (gnat_desig_full)\n \t\t|| (present_gnu_tree (gnat_desig_equiv)\n@@ -3075,6 +3073,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_type = TYPE_POINTER_TO (gnu_old);\n \t    if (!gnu_type)\n \t      {\n+\t\ttree gnu_template_type = make_node (ENUMERAL_TYPE);\n+\t\ttree gnu_ptr_template = build_pointer_type (gnu_template_type);\n+\t\ttree gnu_array_type = make_node (ENUMERAL_TYPE);\n+\t\ttree gnu_ptr_array = build_pointer_type (gnu_array_type);\n+\n+\t\tTYPE_NAME (gnu_template_type)\n+\t\t  = concat_id_with_name (get_entity_name (gnat_desig_equiv),\n+\t\t\t\t\t \"XUB\");\n+\t\tTYPE_DUMMY_P (gnu_template_type) = 1;\n+\n+\t\tTYPE_NAME (gnu_array_type)\n+\t\t  = concat_id_with_name (get_entity_name (gnat_desig_equiv),\n+\t\t\t\t\t \"XUA\");\n+\t\tTYPE_DUMMY_P (gnu_array_type) = 1;\n+\n \t\tgnu_type = make_node (RECORD_TYPE);\n \t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_old);\n \t\tTYPE_POINTER_TO (gnu_old) = gnu_type;\n@@ -3084,10 +3097,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = chainon (chainon (NULL_TREE,\n \t\t\t\t      create_field_decl\n \t\t\t\t      (get_identifier (\"P_ARRAY\"),\n-\t\t\t\t       ptr_void_type_node, gnu_type,\n-\t\t\t\t       0, 0, 0, 0)),\n+\t\t\t\t       gnu_ptr_array,\n+\t\t\t\t       gnu_type, 0, 0, 0, 0)),\n \t\t\t     create_field_decl (get_identifier (\"P_BOUNDS\"),\n-\t\t\t\t\t\tptr_void_type_node,\n+\t\t\t\t\t\tgnu_ptr_template,\n \t\t\t\t\t\tgnu_type, 0, 0, 0, 0));\n \n \t\t/* Make sure we can place this into a register.  */\n@@ -6846,14 +6859,13 @@ compatible_signatures_p (tree ftype1, tree ftype2)\n   return 1;\n }\n \f\n-/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new type\n-   with all size expressions that contain F updated by replacing F with R.\n-   This is identical to GCC's substitute_in_type except that it knows about\n-   TYPE_INDEX_TYPE.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n+/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n+   type with all size expressions that contain F updated by replacing F\n+   with R.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n    nothing has changed.  */\n \n tree\n-gnat_substitute_in_type (tree t, tree f, tree r)\n+substitute_in_type (tree t, tree f, tree r)\n {\n   tree new = t;\n   tree tem;\n@@ -6875,7 +6887,7 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \t  new = build_range_type (TREE_TYPE (t), low, high);\n \t  if (TYPE_INDEX_TYPE (t))\n \t    SET_TYPE_INDEX_TYPE\n-\t      (new, gnat_substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n+\t      (new, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n \t  return new;\n \t}\n \n@@ -6902,7 +6914,7 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n       return t;\n \n     case COMPLEX_TYPE:\n-      tem = gnat_substitute_in_type (TREE_TYPE (t), f, r);\n+      tem = substitute_in_type (TREE_TYPE (t), f, r);\n       if (tem == TREE_TYPE (t))\n \treturn t;\n \n@@ -6917,8 +6929,8 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \n     case ARRAY_TYPE:\n       {\n-\ttree component = gnat_substitute_in_type (TREE_TYPE (t), f, r);\n-\ttree domain = gnat_substitute_in_type (TYPE_DOMAIN (t), f, r);\n+\ttree component = substitute_in_type (TREE_TYPE (t), f, r);\n+\ttree domain = substitute_in_type (TYPE_DOMAIN (t), f, r);\n \n \tif (component == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n@@ -6968,7 +6980,7 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \t    tree new_field = copy_node (field);\n \n \t    TREE_TYPE (new_field)\n-\t      = gnat_substitute_in_type (TREE_TYPE (new_field), f, r);\n+\t      = substitute_in_type (TREE_TYPE (new_field), f, r);\n \n \t    if (DECL_HAS_REP_P (field) && !DECL_INTERNAL_P (field))\n \t      field_has_rep = true;"}, {"sha": "d210c6135dd6ceacd6950730681d71179da5f75e", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=1bbf850280fd2a435aea5321ad3f79977dbc595c", "patch": "@@ -160,11 +160,11 @@ extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n    the value passed against the list of choices.  */\n extern tree choices_to_gnu (tree operand, Node_Id choices);\n \n-/* Given a type T, a FIELD_DECL F, and a replacement value R,\n-   return a new type with all size expressions that contain F\n-   updated by replacing F with R.  This is identical to GCC's\n-   substitute_in_type except that it knows about TYPE_INDEX_TYPE.  */\n-extern tree gnat_substitute_in_type (tree t, tree f, tree r);\n+/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n+   type with all size expressions that contain F updated by replacing F\n+   with R.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n+   nothing has changed.  */\n+extern tree substitute_in_type (tree t, tree f, tree r);\n \n /* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n    needed to represent the object.  */"}, {"sha": "54ab6087359f0f6607b71b2aea3514c4bf8399e2", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=1bbf850280fd2a435aea5321ad3f79977dbc595c", "patch": "@@ -5201,19 +5201,6 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t  return GS_ALL_DONE;\n \t}\n \n-      return GS_UNHANDLED;\n-\n-    case COMPONENT_REF:\n-      /* We have a kludge here.  If the FIELD_DECL is from a fat pointer and is\n-\t from an early dummy type, replace it with the proper FIELD_DECL.  */\n-      if (TYPE_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n-\t  && DECL_ORIGINAL_FIELD (TREE_OPERAND (*expr_p, 1)))\n-\t{\n-\t  TREE_OPERAND (*expr_p, 1)\n-\t    = DECL_ORIGINAL_FIELD (TREE_OPERAND (*expr_p, 1));\n-\t  return GS_OK;\n-\t}\n-\n       /* ... fall through ... */\n \n     default:"}, {"sha": "a8a673c06dea37c40f93217123c518f4f79963a4", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bbf850280fd2a435aea5321ad3f79977dbc595c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=1bbf850280fd2a435aea5321ad3f79977dbc595c", "patch": "@@ -3160,75 +3160,64 @@ update_pointer_to (tree old_type, tree new_type)\n     }\n \n   /* Now deal with the unconstrained array case. In this case the \"pointer\"\n-     is actually a RECORD_TYPE where the types of both fields are\n-     pointers to void.  In that case, copy the field list from the\n-     old type to the new one and update the fields' context. */\n+     is actually a RECORD_TYPE where both fields are pointers to dummy nodes.\n+     Turn them into pointers to the correct types using update_pointer_to.  */\n   else if (TREE_CODE (ptr) != RECORD_TYPE || !TYPE_IS_FAT_POINTER_P (ptr))\n     gcc_unreachable ();\n \n   else\n     {\n       tree new_obj_rec = TYPE_OBJECT_RECORD_TYPE (new_type);\n-      tree fields = TYPE_FIELDS (TYPE_POINTER_TO (new_type));\n-      tree new_fields, ptr_temp_type, new_ref, bounds, var;\n-\n-      /* Replace contents of old pointer with those of new pointer.  */\n-      new_fields = copy_node (fields);\n-      TREE_CHAIN (new_fields) = copy_node (TREE_CHAIN (fields));\n-\n-      SET_DECL_ORIGINAL_FIELD (TYPE_FIELDS (ptr), new_fields);\n-      SET_DECL_ORIGINAL_FIELD (TREE_CHAIN (TYPE_FIELDS (ptr)),\n-\t\t\t       TREE_CHAIN (new_fields));\n-\n-      TYPE_FIELDS (ptr) = new_fields;\n-      DECL_CONTEXT (new_fields) = ptr;\n-      DECL_CONTEXT (TREE_CHAIN (new_fields)) = ptr;\n-\n-      /* Rework the PLACEHOLDER_EXPR inside the reference to the template\n-\t bounds and update the pointers to them.\n-\n-\t ??? This is now the only use of gnat_substitute_in_type, which\n-\t is now a very \"heavy\" routine to do this, so it should be replaced\n-\t at some point.  */\n-      bounds = TREE_TYPE (TREE_TYPE (new_fields));\n-      ptr_temp_type = TREE_TYPE (TREE_CHAIN (new_fields));\n-      new_ref = build3 (COMPONENT_REF, ptr_temp_type,\n+      tree array_field = TYPE_FIELDS (ptr);\n+      tree bounds_field = TREE_CHAIN (TYPE_FIELDS (ptr));\n+      tree new_ptr = TYPE_POINTER_TO (new_type);\n+      tree new_ref;\n+      tree var;\n+\n+      /* Make pointers to the dummy template point to the real template.  */\n+      update_pointer_to\n+\t(TREE_TYPE (TREE_TYPE (bounds_field)),\n+\t TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_ptr)))));\n+\n+      /* The references to the template bounds present in the array type\n+\t are made through a PLACEHOLDER_EXPR of type new_ptr.  Since we\n+\t are updating ptr to make it a full replacement for new_ptr as\n+\t pointer to new_type, we must rework the PLACEHOLDER_EXPR so as\n+\t to make it of type ptr.  */\n+      new_ref = build3 (COMPONENT_REF, TREE_TYPE (bounds_field),\n \t\t\tbuild0 (PLACEHOLDER_EXPR, ptr),\n-\t\t\tTREE_CHAIN (new_fields), NULL_TREE);\n-      update_pointer_to (bounds,\n-\t\t\t gnat_substitute_in_type (bounds,\n-\t\t\t\t\t\t  TREE_CHAIN (fields),\n-\t\t\t\t\t\t  new_ref));\n+\t\t\tbounds_field, NULL_TREE);\n \n-      for (var = TYPE_MAIN_VARIANT (ptr); var; var = TYPE_NEXT_VARIANT (var))\n-\t{\n-\t  SET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n+      /* Create the new array for the new PLACEHOLDER_EXPR and make\n+\t pointers to the dummy array point to it.\n \n-\t  /* This may seem a bit gross, in particular wrt DECL_CONTEXT, but\n-\t     actually is in keeping with what build_qualified_type does.  */\n-\t  TYPE_FIELDS (var) = new_fields;\n-\t}\n+\t ??? This is now the only use of substitute_in_type,\n+\t which is a very \"heavy\" routine to do this, so it\n+\t should be replaced at some point.  */\n+      update_pointer_to\n+\t(TREE_TYPE (TREE_TYPE (array_field)),\n+\t substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))),\n+\t\t\t     TREE_CHAIN (TYPE_FIELDS (new_ptr)), new_ref));\n \n+      /* Make ptr the pointer to new_type.  */\n       TYPE_POINTER_TO (new_type) = TYPE_REFERENCE_TO (new_type)\n \t= TREE_TYPE (new_type) = ptr;\n \n+      for (var = TYPE_MAIN_VARIANT (ptr); var; var = TYPE_NEXT_VARIANT (var))\n+\tSET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n+\n       /* Now handle updating the allocation record, what the thin pointer\n \t points to.  Update all pointers from the old record into the new\n-\t one, update the types of the fields, and recompute the size.  */\n-\n+\t one, update the type of the array field, and recompute the size.  */\n       update_pointer_to (TYPE_OBJECT_RECORD_TYPE (old_type), new_obj_rec);\n \n-      TREE_TYPE (TYPE_FIELDS (new_obj_rec))\n-\t= TREE_TYPE (TREE_TYPE (TREE_CHAIN (new_fields)));\n-\n       TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TREE_TYPE (TREE_TYPE (new_fields));\n+\t= TREE_TYPE (TREE_TYPE (array_field));\n \n       /* The size recomputation needs to account for alignment constraints, so\n \t we let layout_type work it out.  This will reset the field offsets to\n \t what they would be in a regular record, so we shift them back to what\n \t we want them to be for a thin pointer designated type afterwards.  */\n-\n       DECL_SIZE (TYPE_FIELDS (new_obj_rec)) = 0;\n       DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))) = 0;\n       TYPE_SIZE (new_obj_rec) = 0;"}]}