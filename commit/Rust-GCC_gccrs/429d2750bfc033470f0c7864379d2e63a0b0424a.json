{"sha": "429d2750bfc033470f0c7864379d2e63a0b0424a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5ZDI3NTBiZmMwMzM0NzBmMGM3ODY0Mzc5ZDJlNjNhMGIwNDI0YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-05T16:43:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-05T16:43:19Z"}, "message": "predict.c (predicted_by_loop_heuristics_p): New function.\n\n\t* predict.c (predicted_by_loop_heuristics_p): New function.\n\t(predict_iv_comparison): Use it.\n\t(predict_loops): Walk from innermost loops; do not predict edges\n\tleaving multiple loops multiple times; implement\n\tPRED_LOOP_ITERATIONS_MAX heuristics.\n\t* predict.def (PRED_LOOP_ITERATIONS_MAX): New predictor.\n\t* gcc.dg/predict-9.c: Update template.\n\nFrom-SVN: r237103", "tree": {"sha": "f0969b97cc1c4b6c49e7a43b1e102512bbef6698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0969b97cc1c4b6c49e7a43b1e102512bbef6698"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/429d2750bfc033470f0c7864379d2e63a0b0424a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429d2750bfc033470f0c7864379d2e63a0b0424a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429d2750bfc033470f0c7864379d2e63a0b0424a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429d2750bfc033470f0c7864379d2e63a0b0424a/comments", "author": null, "committer": null, "parents": [{"sha": "46f1f3c1c267215d8951674d0d62a5027b870163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f1f3c1c267215d8951674d0d62a5027b870163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46f1f3c1c267215d8951674d0d62a5027b870163"}], "stats": {"total": 101, "additions": 77, "deletions": 24}, "files": [{"sha": "d7a2527cace04f694b7130caed671b5b9f9d53fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=429d2750bfc033470f0c7864379d2e63a0b0424a", "patch": "@@ -1,4 +1,13 @@\n-2016-06-03  Jan Hubicka  <hubicka@ucw.cz>\n+2016-06-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (predicted_by_loop_heuristics_p): New function.\n+\t(predict_iv_comparison): Use it.\n+\t(predict_loops): Walk from innermost loops; do not predict edges\n+\tleaving multiple loops multiple times; implement\n+\tPRED_LOOP_ITERATIONS_MAX heuristics.\n+\t* predict.def (PRED_LOOP_ITERATIONS_MAX): New predictor.\n+\n+2016-06-05  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cfg.c (check_bb_profile): Do not report mismatched profiles when\n \tonly edges out of BB are EH edges."}, {"sha": "32d45678f259891cb295cce4b1a306b0de714d65", "filename": "gcc/predict.c", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=429d2750bfc033470f0c7864379d2e63a0b0424a", "patch": "@@ -1215,6 +1215,27 @@ expr_coherent_p (tree t1, tree t2)\n     return false;\n }\n \n+/* Return true if E is predicted by one of loop heuristics.  */\n+\n+static bool\n+predicted_by_loop_heuristics_p (basic_block bb)\n+{\n+  struct edge_prediction *i;\n+  edge_prediction **preds = bb_predictions->get (bb);\n+\n+  if (!preds)\n+    return false;\n+\n+  for (i = *preds; i; i = i->ep_next)\n+    if (i->ep_predictor == PRED_LOOP_ITERATIONS_GUESSED\n+\t|| i->ep_predictor == PRED_LOOP_ITERATIONS_MAX\n+\t|| i->ep_predictor == PRED_LOOP_ITERATIONS\n+\t|| i->ep_predictor == PRED_LOOP_EXIT\n+\t|| i->ep_predictor == PRED_LOOP_EXTRA_EXIT)\n+      return true;\n+  return false;\n+}\n+\n /* Predict branch probability of BB when BB contains a branch that compares\n    an induction variable in LOOP with LOOP_IV_BASE_VAR to LOOP_BOUND_VAR. The\n    loop exit is compared using LOOP_BOUND_CODE, with step of LOOP_BOUND_STEP.\n@@ -1243,10 +1264,7 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n   edge then_edge;\n   edge_iterator ei;\n \n-  if (predicted_by_p (bb, PRED_LOOP_ITERATIONS_GUESSED)\n-      || predicted_by_p (bb, PRED_LOOP_ITERATIONS)\n-      || predicted_by_p (bb, PRED_LOOP_EXIT)\n-      || predicted_by_p (bb, PRED_LOOP_EXTRA_EXIT))\n+  if (predicted_by_loop_heuristics_p (bb))\n     return;\n \n   stmt = last_stmt (bb);\n@@ -1484,6 +1502,7 @@ predict_extra_loop_exits (edge exit_edge)\n     }\n }\n \n+\n /* Predict edge probabilities by exploiting loop structure.  */\n \n static void\n@@ -1493,10 +1512,10 @@ predict_loops (void)\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n-  FOR_EACH_LOOP (loop, 0)\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       basic_block bb, *bbs;\n-      unsigned j, n_exits;\n+      unsigned j, n_exits = 0;\n       vec<edge> exits;\n       struct tree_niter_desc niter_desc;\n       edge ex;\n@@ -1508,7 +1527,9 @@ predict_loops (void)\n       gcond *stmt = NULL;\n \n       exits = get_loop_exit_edges (loop);\n-      n_exits = exits.length ();\n+      FOR_EACH_VEC_ELT (exits, j, ex)\n+\tif (!(ex->flags & (EDGE_EH | EDGE_ABNORMAL_CALL | EDGE_FAKE)))\n+\t  n_exits ++;\n       if (!n_exits)\n \t{\n           exits.release ();\n@@ -1522,7 +1543,14 @@ predict_loops (void)\n \t  int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n \t  int probability;\n \t  enum br_predictor predictor;\n+\t  widest_int nit;\n \n+\t  if (ex->flags & (EDGE_EH | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n+\t    continue;\n+\t  /* Loop heuristics do not expect exit conditional to be inside\n+\t     inner loop.  We predict from innermost to outermost loop.  */\n+\t  if (predicted_by_loop_heuristics_p (ex->src))\n+\t    continue;\n \t  predict_extra_loop_exits (ex);\n \n \t  if (number_of_iterations_exit (loop, ex, &niter_desc, false, false))\n@@ -1543,25 +1571,34 @@ predict_loops (void)\n \t  /* If we have just one exit and we can derive some information about\n \t     the number of iterations of the loop from the statements inside\n \t     the loop, use it to predict this exit.  */\n-\t  else if (n_exits == 1)\n+\t  else if (n_exits == 1\n+\t\t   && estimated_stmt_executions (loop, &nit))\n \t    {\n-\t      nitercst = estimated_stmt_executions_int (loop);\n-\t      if (nitercst < 0)\n-\t\tcontinue;\n-\t      if (nitercst > max)\n+\t      if (wi::gtu_p (nit, max))\n \t\tnitercst = max;\n-\n+\t      else\n+\t\tnitercst = nit.to_shwi ();\n \t      predictor = PRED_LOOP_ITERATIONS_GUESSED;\n \t    }\n+\t  /* If we have likely upper bound, trust it for very small iteration\n+\t     counts.  Such loops would otherwise get mispredicted by standard\n+\t     LOOP_EXIT heuristics.  */\n+\t  else if (n_exits == 1\n+\t\t   && likely_max_stmt_executions (loop, &nit)\n+\t\t   && wi::ltu_p (nit,\n+\t\t\t\t RDIV (REG_BR_PROB_BASE,\n+\t\t\t\t       REG_BR_PROB_BASE\n+\t\t\t\t\t - predictor_info\n+\t\t\t\t\t\t [PRED_LOOP_EXIT].hitrate)))\n+\t    {\n+\t      nitercst = nit.to_shwi ();\n+\t      predictor = PRED_LOOP_ITERATIONS_MAX;\n+\t    }\n \t  else\n \t    continue;\n \n-\t  /* If the prediction for number of iterations is zero, do not\n-\t     predict the exit edges.  */\n-\t  if (nitercst == 0)\n-\t    continue;\n-\n-\t  probability = ((REG_BR_PROB_BASE + nitercst / 2) / nitercst);\n+\t  gcc_checking_assert (nitercst);\n+\t  probability = RDIV (REG_BR_PROB_BASE, nitercst);\n \t  predict_edge (ex, predictor, probability);\n \t}\n       exits.release ();\n@@ -1619,8 +1656,7 @@ predict_loops (void)\n \t  if (!header_found\n \t      /* If we already used more reliable loop exit predictors, do not\n \t\t bother with PRED_LOOP_EXIT.  */\n-\t      && !predicted_by_p (bb, PRED_LOOP_ITERATIONS_GUESSED)\n-\t      && !predicted_by_p (bb, PRED_LOOP_ITERATIONS))\n+\t      && !predicted_by_loop_heuristics_p (bb))\n \t    {\n \t      /* For loop with many exits we don't want to predict all exits\n \t         with the pretty large probability, because if all exits are"}, {"sha": "9c7db7ab0721617fe657cb609a79ddaf62a34a92", "filename": "gcc/predict.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=429d2750bfc033470f0c7864379d2e63a0b0424a", "patch": "@@ -73,6 +73,10 @@ DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n DEF_PREDICTOR (PRED_LOOP_ITERATIONS_GUESSED, \"guessed loop iterations\",\n \t       PROB_ALWAYS, PRED_FLAG_FIRST_MATCH)\n \n+/* Use number of loop iterations guessed by the contents of the loop.  */\n+DEF_PREDICTOR (PRED_LOOP_ITERATIONS_MAX, \"guessed loop iterations\",\n+\t       PROB_ALWAYS, PRED_FLAG_FIRST_MATCH)\n+\n /* Branch containing goto is probably not taken.  */\n DEF_PREDICTOR (PRED_CONTINUE, \"continue\", HITRATE (50), 0)\n "}, {"sha": "68881580d3b295880aa079e5b37a4c09284a380f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=429d2750bfc033470f0c7864379d2e63a0b0424a", "patch": "@@ -1,3 +1,7 @@\n+2016-06-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/predict-9.c: Update template.\n+\n 2016-06-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/49377"}, {"sha": "3cba9f9da2b6a4f74cbd6adfb383319148aa0364", "filename": "gcc/testsuite/gcc.dg/predict-9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429d2750bfc033470f0c7864379d2e63a0b0424a/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-9.c?ref=429d2750bfc033470f0c7864379d2e63a0b0424a", "patch": "@@ -19,5 +19,5 @@ void foo (int base)\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"first match heuristics: 2.0%\" 4 \"profile_estimate\"} } */\n-/* { dg-final { scan-tree-dump-times \"first match heuristics: 4.5%\" 0 \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump-times \"first match heuristics: 2.0%\" 3 \"profile_estimate\"} } */\n+/* { dg-final { scan-tree-dump-times \"first match heuristics: 4.5%\" 1 \"profile_estimate\"} } */"}]}