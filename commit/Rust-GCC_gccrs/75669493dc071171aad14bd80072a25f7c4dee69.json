{"sha": "75669493dc071171aad14bd80072a25f7c4dee69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU2Njk0OTNkYzA3MTE3MWFhZDE0YmQ4MDA3MmEyNWY3YzRkZWU2OQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-11-24T00:30:16Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-11-24T00:30:16Z"}, "message": "genattrtab.c (strcmp_check, [...]): New macros.\n\n\t* genattrtab.c (strcmp_check, DEF_ATTR_STRING): New macros.\n\t(length_str, delay_type_str, delay_1_0_str, num_delay_slots_str):\n\tNew variables.\n\t(main): Initialize them.\n\t(find_attr): Canonicalize the attribute name string.\n\t(attr_rtx_1, copy_boolean, expand_delays, gen_unit): Always canonicalize\n\tstring arguments.\n\t(attr_printf, attr_eq): Use DEF_ATTR_STRING.\n\t(check_attr_test, check_attr_value, make_length_attrs,\n\twrite_length_unit_log, simplify_by_exploding, gen_attr,\n\twrite_test_expr, write_attr_value, write_eligible_delay,\n\twrite_complex_function, make_internal_attr,\n\twrite_const_num_delay_slots): Changed due to change of type of\n\tfind_attr.\n\t(fill_attr, evaluate_eq_attr, simplify_and_tree,\n\tattr_rtx_cost, simplify_by_exploding, walk_attr_value): Use\n\tstrcmp_check.\n\nFrom-SVN: r73869", "tree": {"sha": "e7534535d130baf7a13b350599a666a4bf09edfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7534535d130baf7a13b350599a666a4bf09edfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75669493dc071171aad14bd80072a25f7c4dee69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75669493dc071171aad14bd80072a25f7c4dee69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75669493dc071171aad14bd80072a25f7c4dee69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75669493dc071171aad14bd80072a25f7c4dee69/comments", "author": null, "committer": null, "parents": [{"sha": "5069daefc3137ad5b52337c3249dda572bfa5d46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5069daefc3137ad5b52337c3249dda572bfa5d46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5069daefc3137ad5b52337c3249dda572bfa5d46"}], "stats": {"total": 164, "additions": 118, "deletions": 46}, "files": [{"sha": "16c2943a21612383a315a5587171f45aea7aea76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75669493dc071171aad14bd80072a25f7c4dee69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75669493dc071171aad14bd80072a25f7c4dee69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75669493dc071171aad14bd80072a25f7c4dee69", "patch": "@@ -1,3 +1,23 @@\n+2003-11-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* genattrtab.c (strcmp_check, DEF_ATTR_STRING): New macros.\n+\t(length_str, delay_type_str, delay_1_0_str, num_delay_slots_str):\n+\tNew variables.\n+\t(main): Initialize them.\n+\t(find_attr): Canonicalize the attribute name string.\n+\t(attr_rtx_1, copy_boolean, expand_delays, gen_unit): Always canonicalize\n+\tstring arguments.\n+\t(attr_printf, attr_eq): Use DEF_ATTR_STRING.\n+\t(check_attr_test, check_attr_value, make_length_attrs,\n+\twrite_length_unit_log, simplify_by_exploding, gen_attr,\n+\twrite_test_expr, write_attr_value, write_eligible_delay,\n+\twrite_complex_function, make_internal_attr,\n+\twrite_const_num_delay_slots): Changed due to change of type of\n+\tfind_attr.\n+\t(fill_attr, evaluate_eq_attr, simplify_and_tree,\n+\tattr_rtx_cost, simplify_by_exploding, walk_attr_value): Use\n+\tstrcmp_check.\n+\n 2003-11-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR target/13122"}, {"sha": "2398fb2dba07183fd80d48fa77b8cbef9afa7d8e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 98, "deletions": 46, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75669493dc071171aad14bd80072a25f7c4dee69/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75669493dc071171aad14bd80072a25f7c4dee69/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=75669493dc071171aad14bd80072a25f7c4dee69", "patch": "@@ -100,6 +100,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define ATTR_PERMANENT_P(RTX) (RTX_FLAG((RTX), integrated))\n #define ATTR_EQ_ATTR_P(RTX) (RTX_FLAG((RTX), volatil))\n \n+#if 1\n+#define strcmp_check(S1, S2) ((S1) == (S2)\t\t\\\n+\t\t\t      ? 0\t\t\t\\\n+\t\t\t      : (strcmp ((S1), (S2))\t\\\n+\t\t\t\t ? 1\t\t\t\\\n+\t\t\t\t : (abort (), 0)))\n+#else\n+#define strcmp_check(S1, S2) ((S1) != (S2))\n+#endif\n+\n #include \"bconfig.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -339,6 +349,10 @@ static rtx true_rtx, false_rtx;\n /* Used to reduce calls to `strcmp' */\n \n static char *alternative_name;\n+static const char *length_str;\n+static const char *delay_type_str;\n+static const char *delay_1_0_str;\n+static const char *num_delay_slots_str;\n \n /* Indicate that REG_DEAD notes are valid if dead_or_set_p is ever\n    called.  */\n@@ -365,6 +379,8 @@ int optimize = 0;\n     (EXP) = (XSTR ((EXP), 1) == current_alternative_string\t\\\n \t    ? true_rtx : false_rtx);\n \n+#define DEF_ATTR_STRING(S) (attr_string ((S), strlen (S)))\n+\n /* These are referenced by rtlanal.c and hence need to be defined somewhere.\n    They won't actually be used.  */\n \n@@ -449,7 +465,7 @@ static int write_expr_attr_cache (rtx, struct attr_desc *);\n static void write_toplevel_expr\t(rtx);\n static void write_const_num_delay_slots (void);\n static char *next_comma_elt\t(const char **);\n-static struct attr_desc *find_attr (const char *, int);\n+static struct attr_desc *find_attr (const char **, int);\n static struct attr_value *find_most_used  (struct attr_desc *);\n static rtx find_single_value\t(struct attr_desc *);\n static void extend_range\t(struct range *, int, int);\n@@ -605,8 +621,7 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n     {\n       char *arg0 = va_arg (p, char *);\n \n-      if (code == SYMBOL_REF)\n-\targ0 = attr_string (arg0, strlen (arg0));\n+      arg0 = DEF_ATTR_STRING (arg0);\n \n       hashcode = ((HOST_WIDE_INT) code + RTL_HASH (arg0));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n@@ -735,14 +750,13 @@ attr_printf (unsigned int len, const char *fmt, ...)\n   vsprintf (str, fmt, p);\n   va_end (p);\n \n-  return attr_string (str, strlen (str));\n+  return DEF_ATTR_STRING (str);\n }\n \n static rtx\n attr_eq (const char *name, const char *value)\n {\n-  return attr_rtx (EQ_ATTR, attr_string (name, strlen (name)),\n-\t\t   attr_string (value, strlen (value)));\n+  return attr_rtx (EQ_ATTR, DEF_ATTR_STRING (name), DEF_ATTR_STRING (value));\n }\n \n static const char *\n@@ -915,7 +929,7 @@ check_attr_test (rtx exp, int is_const, int lineno)\n \n       else if (n_comma_elts (XSTR (exp, 1)) == 1)\n \t{\n-\t  attr = find_attr (XSTR (exp, 0), 0);\n+\t  attr = find_attr (&XSTR (exp, 0), 0);\n \t  if (attr == NULL)\n \t    {\n \t      if (! strcmp (XSTR (exp, 0), \"alternative\"))\n@@ -1165,7 +1179,7 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n \n     case ATTR:\n       {\n-\tstruct attr_desc *attr2 = find_attr (XSTR (exp, 0), 0);\n+\tstruct attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n \tif (attr2 == NULL)\n \t  {\n \t    message_with_line (attr ? attr->lineno : 0,\n@@ -1325,7 +1339,7 @@ check_defs (void)\n \t  if (value == NULL_RTX)\n \t    continue;\n \n-\t  if ((attr = find_attr (XSTR (XEXP (value, 0), 0), 0)) == NULL)\n+\t  if ((attr = find_attr (&XSTR (XEXP (value, 0), 0), 0)) == NULL)\n \t    {\n \t      message_with_line (id->lineno, \"unknown attribute %s\",\n \t\t\t\t XSTR (XEXP (value, 0), 0));\n@@ -1363,6 +1377,8 @@ make_canonical (struct attr_desc *attr, rtx exp)\n \t    fatal (\"(attr_value \\\"*\\\") used in invalid context\");\n \t  exp = attr->default_val->value;\n \t}\n+      else\n+\tXSTR (exp, 0) = DEF_ATTR_STRING (XSTR (exp, 0));\n \n       break;\n \n@@ -1423,6 +1439,17 @@ copy_boolean (rtx exp)\n   if (GET_CODE (exp) == AND || GET_CODE (exp) == IOR)\n     return attr_rtx (GET_CODE (exp), copy_boolean (XEXP (exp, 0)),\n \t\t     copy_boolean (XEXP (exp, 1)));\n+  if (GET_CODE (exp) == MATCH_OPERAND)\n+    {\n+      XSTR (exp, 1) = DEF_ATTR_STRING (XSTR (exp, 1));\n+      XSTR (exp, 2) = DEF_ATTR_STRING (XSTR (exp, 2));\n+    }\n+  else if (GET_CODE (exp) == EQ_ATTR)\n+    {\n+      XSTR (exp, 0) = DEF_ATTR_STRING (XSTR (exp, 0));\n+      XSTR (exp, 1) = DEF_ATTR_STRING (XSTR (exp, 1));\n+    }\n+\n   return exp;\n }\n \n@@ -1503,7 +1530,7 @@ expand_delays (void)\n \t= make_numeric_value (XVECLEN (delay->def, 1) / 3);\n     }\n \n-  make_internal_attr (\"*num_delay_slots\", condexp, ATTR_NONE);\n+  make_internal_attr (num_delay_slots_str, condexp, ATTR_NONE);\n \n   /* If more than one delay type, do the same for computing the delay type.  */\n   if (num_delays > 1)\n@@ -1518,7 +1545,7 @@ expand_delays (void)\n \t  XVECEXP (condexp, 0, i + 1) = make_numeric_value (delay->num);\n \t}\n \n-      make_internal_attr (\"*delay_type\", condexp, ATTR_SPECIAL);\n+      make_internal_attr (delay_type_str, condexp, ATTR_SPECIAL);\n     }\n \n   /* For each delay possibility and delay slot, compute an eligibility\n@@ -2238,8 +2265,8 @@ fill_attr (struct attr_desc *attr)\n       value = NULL;\n       if (XVEC (id->def, id->vec_idx))\n \tfor (i = 0; i < XVECLEN (id->def, id->vec_idx); i++)\n-\t  if (! strcmp (XSTR (XEXP (XVECEXP (id->def, id->vec_idx, i), 0), 0),\n-\t\t\tattr->name))\n+\t  if (! strcmp_check (XSTR (XEXP (XVECEXP (id->def, id->vec_idx, i), 0), 0),\n+\t\t\t      attr->name))\n \t    value = XEXP (XVECEXP (id->def, id->vec_idx, i), 1);\n \n       if (value == NULL)\n@@ -2336,9 +2363,12 @@ substitute_address (rtx exp, rtx (*no_address_fn) (rtx),\n static void\n make_length_attrs (void)\n {\n-  static const char *const new_names[] = {\"*insn_default_length\",\n-\t\t\t\t      \"*insn_variable_length_p\",\n-\t\t\t\t      \"*insn_current_length\"};\n+  static const char *new_names[] =\n+    {\n+      \"*insn_default_length\",\n+      \"*insn_variable_length_p\",\n+      \"*insn_current_length\"\n+    };\n   static rtx (*const no_address_fn[]) (rtx) = {identity_fn, zero_fn, zero_fn};\n   static rtx (*const address_fn[]) (rtx) = {max_fn, one_fn, identity_fn};\n   size_t i;\n@@ -2348,7 +2378,7 @@ make_length_attrs (void)\n \n   /* See if length attribute is defined.  If so, it must be numeric.  Make\n      it special so we don't output anything for it.  */\n-  length_attr = find_attr (\"length\", 0);\n+  length_attr = find_attr (&length_str, 0);\n   if (length_attr == 0)\n     return;\n \n@@ -2365,7 +2395,7 @@ make_length_attrs (void)\n \t\t\t  substitute_address (length_attr->default_val->value,\n \t\t\t\t\t      no_address_fn[i], address_fn[i]),\n \t\t\t  ATTR_NONE);\n-      new_attr = find_attr (new_names[i], 0);\n+      new_attr = find_attr (&new_names[i], 0);\n       for (av = length_attr->first_value; av; av = av->next)\n \tfor (ie = av->first_insn; ie; ie = ie->next)\n \t  {\n@@ -2411,7 +2441,7 @@ max_fn (rtx exp)\n static void\n write_length_unit_log (void)\n {\n-  struct attr_desc *length_attr = find_attr (\"length\", 0);\n+  struct attr_desc *length_attr = find_attr (&length_str, 0);\n   struct attr_value *av;\n   struct insn_ent *ie;\n   unsigned int length_unit_log, length_or;\n@@ -2727,7 +2757,7 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \n   if (GET_CODE (value) == CONST_STRING)\n     {\n-      if (! strcmp (XSTR (value, 0), XSTR (exp, 1)))\n+      if (! strcmp_check (XSTR (value, 0), XSTR (exp, 1)))\n \tnewexp = true_rtx;\n       else\n \tnewexp = false_rtx;\n@@ -2751,7 +2781,7 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \n       newexp = attr_rtx (EQ, value,\n \t\t\t attr_rtx (SYMBOL_REF,\n-\t\t\t\t   attr_string (string, strlen (string))));\n+\t\t\t\t   DEF_ATTR_STRING (string)));\n     }\n   else if (GET_CODE (value) == COND)\n     {\n@@ -2898,7 +2928,7 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n       if (XSTR (exp, 0) != XSTR (*pterm, 0))\n \treturn exp;\n \n-      if (! strcmp (XSTR (exp, 1), XSTR (*pterm, 1)))\n+      if (! strcmp_check (XSTR (exp, 1), XSTR (*pterm, 1)))\n \treturn true_rtx;\n       else\n \treturn false_rtx;\n@@ -2910,7 +2940,7 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n       if (XSTR (*pterm, 0) != XSTR (XEXP (exp, 0), 0))\n \treturn exp;\n \n-      if (! strcmp (XSTR (*pterm, 1), XSTR (XEXP (exp, 0), 1)))\n+      if (! strcmp_check (XSTR (*pterm, 1), XSTR (XEXP (exp, 0), 1)))\n \treturn false_rtx;\n       else\n \treturn true_rtx;\n@@ -2922,7 +2952,7 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n       if (XSTR (exp, 0) != XSTR (XEXP (*pterm, 0), 0))\n \treturn exp;\n \n-      if (! strcmp (XSTR (exp, 1), XSTR (XEXP (*pterm, 0), 1)))\n+      if (! strcmp_check (XSTR (exp, 1), XSTR (XEXP (*pterm, 0), 1)))\n \treturn false_rtx;\n       else\n \t*pterm = true_rtx;\n@@ -3036,9 +3066,10 @@ attr_rtx_cost (rtx x)\n \treturn 10;\n       else\n \treturn 0;\n+\n     case EQ_ATTR:\n       /* Alternatives don't result into function call.  */\n-      if (!strcmp (XSTR (x, 0), \"alternative\"))\n+      if (!strcmp_check (XSTR (x, 0), alternative_name))\n \treturn 0;\n       else\n \treturn 5;\n@@ -3335,7 +3366,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n \t We normally can replace this comparison with the condition that\n \t would give this insn the values being tested for.  */\n       if (XSTR (exp, 0) != alternative_name\n-\t  && (attr = find_attr (XSTR (exp, 0), 0)) != NULL)\n+\t  && (attr = find_attr (&XSTR (exp, 0), 0)) != NULL)\n \tfor (av = attr->first_value; av; av = av->next)\n \t  for (ie = av->first_insn; ie; ie = ie->next)\n \t    if (ie->insn_code == insn_code)\n@@ -3499,7 +3530,10 @@ simplify_by_exploding (rtx exp)\n       const char *name = XSTR (XEXP (list, 0), 0);\n       rtx *prev;\n \n-      if ((space[ndim].attr = find_attr (name, 0)) == 0\n+      space[ndim].attr = find_attr (&name, 0);\n+      XSTR (XEXP (list, 0), 0) = name;\n+\n+      if (space[ndim].attr == 0\n \t  || space[ndim].attr->is_numeric)\n \t{\n \t  unmark_used_attributes (list, space, ndim);\n@@ -3511,7 +3545,7 @@ simplify_by_exploding (rtx exp)\n       space[ndim].values = 0;\n       prev = &list;\n       for (link = list; link; link = *prev)\n-\tif (! strcmp (XSTR (XEXP (link, 0), 0), name))\n+\tif (! strcmp_check (XSTR (XEXP (link, 0), 0), name))\n \t  {\n \t    space[ndim].num_values++;\n \t    *prev = XEXP (link, 1);\n@@ -3965,7 +3999,7 @@ gen_attr (rtx exp, int lineno)\n \n   /* Make a new attribute structure.  Check for duplicate by looking at\n      attr->default_val, since it is initialized by this routine.  */\n-  attr = find_attr (XSTR (exp, 0), 1);\n+  attr = find_attr (&XSTR (exp, 0), 1);\n   if (attr->default_val)\n     {\n       message_with_line (lineno, \"duplicate definition for attribute %s\",\n@@ -4007,7 +4041,7 @@ gen_attr (rtx exp, int lineno)\n       XEXP (exp, 2) = XEXP (XEXP (exp, 2), 0);\n     }\n \n-  if (! strcmp (attr->name, \"length\") && ! attr->is_numeric)\n+  if (! strcmp_check (attr->name, length_str) && ! attr->is_numeric)\n     {\n       message_with_line (lineno,\n \t\t\t \"`length' attribute must take numeric values\");\n@@ -4251,6 +4285,8 @@ gen_unit (rtx def, int lineno)\n       unit->first_lineno = lineno;\n       units = unit;\n     }\n+  else\n+    XSTR (def, 0) = unit->name;\n \n   /* Make a new operation class structure entry and initialize it.  */\n   op = oballoc (sizeof (struct function_unit_op));\n@@ -4443,7 +4479,7 @@ write_test_expr (rtx exp, int flags)\n \t  break;\n \t}\n \n-      attr = find_attr (XSTR (exp, 0), 0);\n+      attr = find_attr (&XSTR (exp, 0), 0);\n       if (! attr)\n \tabort ();\n \n@@ -4653,7 +4689,7 @@ walk_attr_value (rtx exp)\n     case EQ_ATTR:\n       if (XSTR (exp, 0) == alternative_name)\n \tmust_extract = must_constrain = 1;\n-      else if (strcmp (XSTR (exp, 0), \"length\") == 0)\n+      else if (strcmp_check (XSTR (exp, 0), length_str) == 0)\n \tlength_used = 1;\n       return;\n \n@@ -5116,7 +5152,7 @@ write_attr_value (struct attr_desc *attr, rtx value)\n \n     case ATTR:\n       {\n-\tstruct attr_desc *attr2 = find_attr (XSTR (value, 0), 0);\n+\tstruct attr_desc *attr2 = find_attr (&XSTR (value, 0), 0);\n \tprintf (\"get_attr_%s (%s)\", attr2->name,\n \t\t(attr2->is_const ? \"\" : \"insn\"));\n       }\n@@ -5190,6 +5226,7 @@ write_eligible_delay (const char *kind)\n   struct delay_desc *delay;\n   int max_slots;\n   char str[50];\n+  const char *pstr;\n   struct attr_desc *attr;\n   struct attr_value *av, *common_av;\n   int i;\n@@ -5218,7 +5255,7 @@ write_eligible_delay (const char *kind)\n \n   if (num_delays > 1)\n     {\n-      attr = find_attr (\"*delay_type\", 0);\n+      attr = find_attr (&delay_type_str, 0);\n       if (! attr)\n \tabort ();\n       common_av = find_most_used (attr);\n@@ -5247,7 +5284,7 @@ write_eligible_delay (const char *kind)\n       printf (\"  switch (recog_memoized (insn))\\n\");\n       printf (\"    {\\n\");\n \n-      attr = find_attr (\"*delay_1_0\", 0);\n+      attr = find_attr (&delay_1_0_str, 0);\n       if (! attr)\n \tabort ();\n       common_av = find_most_used (attr);\n@@ -5277,7 +5314,8 @@ write_eligible_delay (const char *kind)\n \t    printf (\"\\t{\\n\");\n \n \t    sprintf (str, \"*%s_%d_%d\", kind, delay->num, i / 3);\n-\t    attr = find_attr (str, 0);\n+\t    pstr = str;\n+\t    attr = find_attr (&pstr, 0);\n \t    if (! attr)\n \t      abort ();\n \t    common_av = find_most_used (attr);\n@@ -5381,6 +5419,7 @@ write_complex_function (struct function_unit *unit,\n   struct attr_value *av, *common_av;\n   rtx value;\n   char str[256];\n+  const char *pstr;\n   int using_case;\n   int i;\n \n@@ -5398,7 +5437,8 @@ write_complex_function (struct function_unit *unit,\n   if (strlen (unit->name) + sizeof \"*_cases\" > 256)\n     abort ();\n   sprintf (str, \"*%s_cases\", unit->name);\n-  case_attr = find_attr (str, 0);\n+  pstr = str;\n+  case_attr = find_attr (&pstr, 0);\n   if (! case_attr)\n     abort ();\n   common_av = find_most_used (case_attr);\n@@ -5432,7 +5472,8 @@ write_complex_function (struct function_unit *unit,\n \n       printf (\"    case %d:\\n\", i);\n       sprintf (str, \"*%s_%s_%d\", unit->name, connection, i);\n-      attr = find_attr (str, 0);\n+      pstr = str;\n+      attr = find_attr (&pstr, 0);\n       if (! attr)\n \tabort ();\n \n@@ -5484,13 +5525,15 @@ next_comma_elt (const char **pstr)\n }\n \n /* Return a `struct attr_desc' pointer for a given named attribute.  If CREATE\n-   is nonzero, build a new attribute, if one does not exist.  */\n+   is nonzero, build a new attribute, if one does not exist.  *NAME_P is\n+   replaced by a pointer to a canonical copy of the string.  */\n \n static struct attr_desc *\n-find_attr (const char *name, int create)\n+find_attr (const char **name_p, int create)\n {\n   struct attr_desc *attr;\n   int index;\n+  const char *name = *name_p;\n \n   /* Before we resort to using `strcmp', see if the string address matches\n      anywhere.  In most cases, it should have been canonicalized to do so.  */\n@@ -5505,19 +5548,24 @@ find_attr (const char *name, int create)\n   /* Otherwise, do it the slow way.  */\n   for (attr = attrs[index]; attr; attr = attr->next)\n     if (name[0] == attr->name[0] && ! strcmp (name, attr->name))\n-      return attr;\n+      {\n+\t*name_p = attr->name;\n+\treturn attr;\n+      }\n \n   if (! create)\n     return NULL;\n \n   attr = oballoc (sizeof (struct attr_desc));\n-  attr->name = attr_string (name, strlen (name));\n+  attr->name = DEF_ATTR_STRING (name);\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->negative_ok = attr->is_const = attr->is_special = 0;\n   attr->unsigned_p = attr->func_units_p = attr->blockage_p = attr->static_p = 0;\n   attr->next = attrs[index];\n   attrs[index] = attr;\n \n+  *name_p = attr->name;\n+\n   return attr;\n }\n \n@@ -5528,7 +5576,7 @@ make_internal_attr (const char *name, rtx value, int special)\n {\n   struct attr_desc *attr;\n \n-  attr = find_attr (name, 1);\n+  attr = find_attr (&name, 1);\n   if (attr->default_val)\n     abort ();\n \n@@ -5633,7 +5681,7 @@ copy_rtx_unchanging (rtx orig)\n static void\n write_const_num_delay_slots (void)\n {\n-  struct attr_desc *attr = find_attr (\"*num_delay_slots\", 0);\n+  struct attr_desc *attr = find_attr (&num_delay_slots_str, 0);\n   struct attr_value *av;\n   struct insn_ent *ie;\n \n@@ -5691,7 +5739,11 @@ main (int argc, char **argv)\n   ATTR_IND_SIMPLIFIED_P (true_rtx) = ATTR_IND_SIMPLIFIED_P (false_rtx) = 1;\n   ATTR_PERMANENT_P (true_rtx) = ATTR_PERMANENT_P (false_rtx) = 1;\n \n-  alternative_name = attr_string (\"alternative\", strlen (\"alternative\"));\n+  alternative_name = DEF_ATTR_STRING (\"alternative\");\n+  length_str = DEF_ATTR_STRING (\"length\");\n+  delay_type_str = DEF_ATTR_STRING (\"*delay_type\");\n+  delay_1_0_str = DEF_ATTR_STRING (\"*delay_1_0\");\n+  num_delay_slots_str = DEF_ATTR_STRING (\"*num_delay_slots\");\n \n   printf (\"/* Generated automatically by the program `genattrtab'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n@@ -5874,7 +5926,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n \t    insn_alts_p\n \t      = (attr->name [0] == '*'\n-\t\t && strcmp (&attr->name [1], INSN_ALTS_FUNC_NAME) == 0);\n+\t\t && strcmp (&attr->name[1], INSN_ALTS_FUNC_NAME) == 0);\n \t    if (insn_alts_p)\n \t      printf (\"\\n#if AUTOMATON_ALTS\\n\");\n \t    write_attr_get (attr);"}]}