{"sha": "e999b0c986e49756090018ec7187f2b8b21985c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk5OWIwYzk4NmU0OTc1NjA5MDAxOGVjNzE4N2YyYjhiMjE5ODVjNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-03-18T20:16:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-18T20:16:48Z"}, "message": "re PR debug/42873 (deadlock in var tracking in recent builds)\n\n\tPR debug/42873\n\t* var-tracking.c (canonicalize_vars_star): New.\n\t(dataflow_post_merge_adjust): Use it.\n\nFrom-SVN: r157548", "tree": {"sha": "b91b7524e4a0f89e9def1e74be1352bc81093cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b91b7524e4a0f89e9def1e74be1352bc81093cc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e999b0c986e49756090018ec7187f2b8b21985c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e999b0c986e49756090018ec7187f2b8b21985c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e999b0c986e49756090018ec7187f2b8b21985c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e999b0c986e49756090018ec7187f2b8b21985c7/comments", "author": null, "committer": null, "parents": [{"sha": "5644a3d0e39e5705bbf8bba5ff59f8ae336830d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5644a3d0e39e5705bbf8bba5ff59f8ae336830d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5644a3d0e39e5705bbf8bba5ff59f8ae336830d9"}], "stats": {"total": 68, "additions": 68, "deletions": 0}, "files": [{"sha": "3e74d3f5d64dbfab775fb1075e98323e029e02a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e999b0c986e49756090018ec7187f2b8b21985c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e999b0c986e49756090018ec7187f2b8b21985c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e999b0c986e49756090018ec7187f2b8b21985c7", "patch": "@@ -1,3 +1,9 @@\n+2010-03-18  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42873\n+\t* var-tracking.c (canonicalize_vars_star): New.\n+\t(dataflow_post_merge_adjust): Use it.\n+\n 2010-03-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/43058"}, {"sha": "12286ec4364b9c1224b6d2cd36b22092c472996c", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e999b0c986e49756090018ec7187f2b8b21985c7/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e999b0c986e49756090018ec7187f2b8b21985c7/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=e999b0c986e49756090018ec7187f2b8b21985c7", "patch": "@@ -3168,6 +3168,67 @@ canonicalize_values_star (void **slot, void *data)\n   return 1;\n }\n \n+/* Bind one-part variables to the canonical value in an equivalence\n+   set.  Not doing this causes dataflow convergence failure in rare\n+   circumstances, see PR42873.  Unfortunately we can't do this\n+   efficiently as part of canonicalize_values_star, since we may not\n+   have determined or even seen the canonical value of a set when we\n+   get to a variable that references another member of the set.  */\n+\n+static int\n+canonicalize_vars_star (void **slot, void *data)\n+{\n+  dataflow_set *set = (dataflow_set *)data;\n+  variable var = (variable) *slot;\n+  decl_or_value dv = var->dv;\n+  location_chain node;\n+  rtx cval;\n+  decl_or_value cdv;\n+  void **cslot;\n+  variable cvar;\n+  location_chain cnode;\n+\n+  if (!dv_onepart_p (dv) || dv_is_value_p (dv))\n+    return 1;\n+\n+  gcc_assert (var->n_var_parts == 1);\n+\n+  node = var->var_part[0].loc_chain;\n+\n+  if (GET_CODE (node->loc) != VALUE)\n+    return 1;\n+\n+  gcc_assert (!node->next);\n+  cval = node->loc;\n+\n+  /* Push values to the canonical one.  */\n+  cdv = dv_from_value (cval);\n+  cslot = shared_hash_find_slot_noinsert (set->vars, cdv);\n+  if (!cslot)\n+    return 1;\n+  cvar = (variable)*cslot;\n+  gcc_assert (cvar->n_var_parts == 1);\n+\n+  cnode = cvar->var_part[0].loc_chain;\n+\n+  /* CVAL is canonical if its value list contains non-VALUEs or VALUEs\n+     that are not \u201cmore canonical\u201d than it.  */\n+  if (GET_CODE (cnode->loc) != VALUE\n+      || !canon_value_cmp (cnode->loc, cval))\n+    return 1;\n+\n+  /* CVAL was found to be non-canonical.  Change the variable to point\n+     to the canonical VALUE.  */\n+  gcc_assert (!cnode->next);\n+  cval = cnode->loc;\n+\n+  slot = set_slot_part (set, cval, slot, dv, 0,\n+\t\t\tnode->init, node->set_src);\n+  slot = clobber_slot_part (set, cval, slot, 0, node->set_src);\n+\n+  return 1;\n+}\n+\n /* Combine variable or value in *S1SLOT (in DSM->cur) with the\n    corresponding entry in DSM->src.  Multi-part variables are combined\n    with variable_union, whereas onepart dvs are combined with\n@@ -3830,6 +3891,7 @@ dataflow_post_merge_adjust (dataflow_set *set, dataflow_set **permp)\n     htab_traverse (shared_hash_htab ((*permp)->vars),\n \t\t   variable_post_merge_perm_vals, &dfpm);\n   htab_traverse (shared_hash_htab (set->vars), canonicalize_values_star, set);\n+  htab_traverse (shared_hash_htab (set->vars), canonicalize_vars_star, set);\n }\n \n /* Return a node whose loc is a MEM that refers to EXPR in the"}]}