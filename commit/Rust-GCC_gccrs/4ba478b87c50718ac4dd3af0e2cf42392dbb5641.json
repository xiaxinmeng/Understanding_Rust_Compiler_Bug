{"sha": "4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJhNDc4Yjg3YzUwNzE4YWM0ZGQzYWYwZTJjZjQyMzkyZGJiNTY0MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-01-09T17:45:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-01-09T17:45:12Z"}, "message": "sched-int.h (struct deps): Add max_reg, reg_last_in_use...\n\n        * sched-int.h (struct deps): Add max_reg, reg_last_in_use; merge\n        reg_last_uses, reg_last_sets, reg_last_clobbers into struct deps_reg.\n        * sched-deps.c (sched_analyze_1): Update uses of struct deps.\n        (sched_analyze_2, sched_analyze_insn): Likewise.\n        (sched_analyze, init_deps): Likewise.\n        (free_deps): Likewise.  Iterate with EXECUTE_IF_SET_IN_REG_SET.\n        * sched-rgn.c (propagate_deps): Likewise.  Remove max_reg argument.\n        (compute_block_backward_dependences): Update propagate_deps call.\n\nFrom-SVN: r38835", "tree": {"sha": "1fe02ec542bf787c44dd766982d749861c7780fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fe02ec542bf787c44dd766982d749861c7780fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/comments", "author": null, "committer": null, "parents": [{"sha": "9c1fcbfbb6d9d51593faddb4a8e43e04303b3a09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c1fcbfbb6d9d51593faddb4a8e43e04303b3a09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c1fcbfbb6d9d51593faddb4a8e43e04303b3a09"}], "stats": {"total": 356, "additions": 181, "deletions": 175}, "files": [{"sha": "b976645bdd3eb050fb1a9d5be6bdbd53d3afdc51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "patch": "@@ -1,3 +1,14 @@\n+2001-01-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* sched-int.h (struct deps): Add max_reg, reg_last_in_use; merge\n+\treg_last_uses, reg_last_sets, reg_last_clobbers into struct deps_reg.\n+\t* sched-deps.c (sched_analyze_1): Update uses of struct deps.\n+\t(sched_analyze_2, sched_analyze_insn): Likewise.\n+\t(sched_analyze, init_deps): Likewise.\n+\t(free_deps): Likewise.  Iterate with EXECUTE_IF_SET_IN_REG_SET.\n+\t* sched-rgn.c (propagate_deps): Likewise.  Remove max_reg argument.\n+\t(compute_block_backward_dependences): Update propagate_deps call.\n+\n 2001-01-09  Mark Elbrecht  <snowball3@bigfoot.com>\n \n \t* gcc.c (process_command): Set switches[n_switches].ordering to 0."}, {"sha": "4a7f72b48df5cb5bda9bfe5b12feef4369ca45da", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 125, "deletions": 107, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "patch": "@@ -590,10 +590,10 @@ sched_analyze_1 (deps, x, insn)\n \t      int r = regno + i;\n \t      rtx u;\n \n-\t      for (u = deps->reg_last_uses[r]; u; u = XEXP (u, 1))\n+\t      for (u = deps->reg_last[r].uses; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n-\t      for (u = deps->reg_last_sets[r]; u; u = XEXP (u, 1))\n+\t      for (u = deps->reg_last[r].sets; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \n \t      /* Clobbers need not be ordered with respect to one\n@@ -602,8 +602,8 @@ sched_analyze_1 (deps, x, insn)\n \t      if (code == SET)\n \t\t{\n \t\t  if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n-\t\t    free_INSN_LIST_list (&deps->reg_last_uses[r]);\n-\t\t  for (u = deps->reg_last_clobbers[r]; u; u = XEXP (u, 1))\n+\t\t    free_INSN_LIST_list (&deps->reg_last[r].uses);\n+\t\t  for (u = deps->reg_last[r].clobbers; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \t\t  SET_REGNO_REG_SET (reg_pending_sets, r);\n \t\t}\n@@ -616,21 +616,30 @@ sched_analyze_1 (deps, x, insn)\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t    }\n \t}\n+      /* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that\n+\t it does not reload.  Ignore these as they have served their\n+\t purpose already.  */\n+      else if (regno >= deps->max_reg)\n+\t{\n+\t  if (GET_CODE (PATTERN (insn)) != USE\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\t    abort ();\n+\t}\n       else\n \t{\n \t  rtx u;\n \n-\t  for (u = deps->reg_last_uses[regno]; u; u = XEXP (u, 1))\n+\t  for (u = deps->reg_last[regno].uses; u; u = XEXP (u, 1))\n \t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n-\t  for (u = deps->reg_last_sets[regno]; u; u = XEXP (u, 1))\n+\t  for (u = deps->reg_last[regno].sets; u; u = XEXP (u, 1))\n \t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \n \t  if (code == SET)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n-\t\tfree_INSN_LIST_list (&deps->reg_last_uses[regno]);\n-\t      for (u = deps->reg_last_clobbers[regno]; u; u = XEXP (u, 1))\n+\t\tfree_INSN_LIST_list (&deps->reg_last[regno].uses);\n+\t      for (u = deps->reg_last[regno].clobbers; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \t      SET_REGNO_REG_SET (reg_pending_sets, regno);\n \t    }\n@@ -757,14 +766,15 @@ sched_analyze_2 (deps, x, insn)\n \t    while (--i >= 0)\n \t      {\n \t\tint r = regno + i;\n-\t\tdeps->reg_last_uses[r]\n-\t\t  = alloc_INSN_LIST (insn, deps->reg_last_uses[r]);\n+\t\tdeps->reg_last[r].uses\n+\t\t  = alloc_INSN_LIST (insn, deps->reg_last[r].uses);\n+\t\tSET_REGNO_REG_SET (&deps->reg_last_in_use, r);\n \n-\t\tfor (u = deps->reg_last_sets[r]; u; u = XEXP (u, 1))\n+\t\tfor (u = deps->reg_last[r].sets; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n \n \t\t/* ??? This should never happen.  */\n-\t\tfor (u = deps->reg_last_clobbers[r]; u; u = XEXP (u, 1))\n+\t\tfor (u = deps->reg_last[r].clobbers; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n \n \t\tif (call_used_regs[r] || global_regs[r])\n@@ -773,16 +783,26 @@ sched_analyze_2 (deps, x, insn)\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t      }\n \t  }\n+\t/* ??? Reload sometimes emits USEs and CLOBBERs of pseudos that\n+\t   it does not reload.  Ignore these as they have served their\n+\t   purpose already.  */\n+\telse if (regno >= deps->max_reg)\n+\t  {\n+\t    if (GET_CODE (PATTERN (insn)) != USE\n+\t\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n+\t      abort ();\n+\t  }\n \telse\n \t  {\n-\t    deps->reg_last_uses[regno]\n-\t      = alloc_INSN_LIST (insn, deps->reg_last_uses[regno]);\n+\t    deps->reg_last[regno].uses\n+\t      = alloc_INSN_LIST (insn, deps->reg_last[regno].uses);\n+\t    SET_REGNO_REG_SET (&deps->reg_last_in_use, regno);\n \n-\t    for (u = deps->reg_last_sets[regno]; u; u = XEXP (u, 1))\n+\t    for (u = deps->reg_last[regno].sets; u; u = XEXP (u, 1))\n \t      add_dependence (insn, XEXP (u, 0), 0);\n \n \t    /* ??? This should never happen.  */\n-\t    for (u = deps->reg_last_clobbers[regno]; u; u = XEXP (u, 1))\n+\t    for (u = deps->reg_last[regno].clobbers; u; u = XEXP (u, 1))\n \t      add_dependence (insn, XEXP (u, 0), 0);\n \n \t    /* Pseudos that are REG_EQUIV to something may be replaced\n@@ -867,19 +887,19 @@ sched_analyze_2 (deps, x, insn)\n \t   pseudo-regs because it might give an incorrectly rounded result.  */\n \tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n \t  {\n-\t    int max_reg = max_reg_num ();\n-\t    for (i = 0; i < max_reg; i++)\n+\t    for (i = 0; i < deps->max_reg; i++)\n \t      {\n-\t\tfor (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n-\t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t\tif (GET_CODE (PATTERN (insn)) != COND_EXEC)\n-\t\t  free_INSN_LIST_list (&deps->reg_last_uses[i]);\n+\t\tstruct deps_reg *reg_last = &deps->reg_last[i];\n \n-\t\tfor (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t\tfor (u = reg_last->uses; u; u = XEXP (u, 1))\n+\t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t\tfor (u = reg_last->sets; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n-\n-\t\tfor (u = deps->reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\tfor (u = reg_last->clobbers; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n+\n+\t\tif (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t\t  free_INSN_LIST_list (&reg_last->uses);\n \t      }\n \t    reg_pending_sets_all = 1;\n \n@@ -948,7 +968,6 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n {\n   register RTX_CODE code = GET_CODE (x);\n   rtx link;\n-  int maxreg = max_reg_num ();\n   int i;\n \n   if (code == COND_EXEC)\n@@ -1001,13 +1020,15 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n       next = next_nonnote_insn (insn);\n       if (next && GET_CODE (next) == BARRIER)\n \t{\n-\t  for (i = 0; i < maxreg; i++)\n+\t  for (i = 0; i < deps->max_reg; i++)\n \t    {\n-\t      for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\n+\t      for (u = reg_last->uses; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      for (u = deps->reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t      for (u = reg_last->sets; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      for (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t      for (u = reg_last->clobbers; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t    }\n \t}\n@@ -1017,13 +1038,13 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t  INIT_REG_SET (&tmp);\n \n \t  (*current_sched_info->compute_jump_reg_dependencies) (insn, &tmp);\n-\t  EXECUTE_IF_SET_IN_REG_SET \n-\t    (&tmp, 0, i,\n+\t  EXECUTE_IF_SET_IN_REG_SET (&tmp, 0, i,\n \t    {\n-\t      for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      for (u = reg_last->sets; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      deps->reg_last_uses[i]\n-\t\t= alloc_INSN_LIST (insn, deps->reg_last_uses[i]);\n+\t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n+\t      SET_REGNO_REG_SET (&deps->reg_last_in_use, i);\n \t    });\n \n \t  CLEAR_REG_SET (&tmp);\n@@ -1049,7 +1070,6 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \n   if (loop_notes)\n     {\n-      int max_reg = max_reg_num ();\n       int schedule_barrier_found = 0;\n       rtx link;\n \n@@ -1074,19 +1094,20 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n       /* Add dependencies if a scheduling barrier was found.  */\n       if (schedule_barrier_found)\n \t{\n-\t  for (i = 0; i < max_reg; i++)\n+\t  for (i = 0; i < deps->max_reg; i++)\n \t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      rtx u;\n-\t      for (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n-\t\tfree_INSN_LIST_list (&deps->reg_last_uses[i]);\n \n-\t      for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t      for (u = reg_last->uses; u; u = XEXP (u, 1))\n+\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t      for (u = reg_last->sets; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), 0);\n-\n-\t      for (u = deps->reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t      for (u = reg_last->clobbers; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), 0);\n+\n+\t      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t\tfree_INSN_LIST_list (&reg_last->uses);\n \t    }\n \t  reg_pending_sets_all = 1;\n \n@@ -1095,46 +1116,46 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \n     }\n \n-  /* Accumulate clobbers until the next set so that it will be output dependent\n-     on all of them.  At the next set we can clear the clobber list, since\n-     subsequent sets will be output dependent on it.  */\n-  EXECUTE_IF_SET_IN_REG_SET\n-    (reg_pending_sets, 0, i,\n+  /* Accumulate clobbers until the next set so that it will be output\n+     dependent on all of them.  At the next set we can clear the clobber\n+     list, since subsequent sets will be output dependent on it.  */\n+  if (reg_pending_sets_all)\n     {\n-      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+      reg_pending_sets_all = 0;\n+      for (i = 0; i < deps->max_reg; i++)\n \t{\n-\t  free_INSN_LIST_list (&deps->reg_last_sets[i]);\n-\t  free_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n-\t  deps->reg_last_sets[i] = 0;\n+\t  struct deps_reg *reg_last = &deps->reg_last[i];\n+\t  if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t    {\n+\t      free_INSN_LIST_list (&reg_last->sets);\n+\t      free_INSN_LIST_list (&reg_last->clobbers);\n+\t    }\n+\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n+\t  SET_REGNO_REG_SET (&deps->reg_last_in_use, i);\n \t}\n-      deps->reg_last_sets[i]\n-\t= alloc_INSN_LIST (insn, deps->reg_last_sets[i]);\n-    });\n-  EXECUTE_IF_SET_IN_REG_SET\n-    (reg_pending_clobbers, 0, i,\n-    {\n-      deps->reg_last_clobbers[i]\n-\t= alloc_INSN_LIST (insn, deps->reg_last_clobbers[i]);\n-    });\n-  CLEAR_REG_SET (reg_pending_sets);\n-  CLEAR_REG_SET (reg_pending_clobbers);\n-\n-  if (reg_pending_sets_all)\n+    }\n+  else\n     {\n-      for (i = 0; i < maxreg; i++)\n+      EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t{\n+\t  struct deps_reg *reg_last = &deps->reg_last[i];\n \t  if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n \t    {\n-\t      free_INSN_LIST_list (&deps->reg_last_sets[i]);\n-\t      free_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n-\t      deps->reg_last_sets[i] = 0;\n+\t      free_INSN_LIST_list (&reg_last->sets);\n+\t      free_INSN_LIST_list (&reg_last->clobbers);\n \t    }\n-\t  deps->reg_last_sets[i]\n-\t    = alloc_INSN_LIST (insn, deps->reg_last_sets[i]);\n-\t}\n-\n-      reg_pending_sets_all = 0;\n+\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n+\t  SET_REGNO_REG_SET (&deps->reg_last_in_use, i);\n+\t});\n+      EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i,\n+\t{\n+\t  struct deps_reg *reg_last = &deps->reg_last[i];\n+\t  reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n+\t  SET_REGNO_REG_SET (&deps->reg_last_in_use, i);\n+\t});\n     }\n+  CLEAR_REG_SET (reg_pending_sets);\n+  CLEAR_REG_SET (reg_pending_clobbers);\n \n   /* If a post-call group is still open, see if it should remain so.\n      This insn must be a simple move of a hard reg to a pseudo or\n@@ -1242,18 +1263,18 @@ sched_analyze (deps, head, tail)\n \t  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == NOTE\n \t      && NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_SETJMP)\n \t    {\n-\t      int max_reg = max_reg_num ();\n-\t      for (i = 0; i < max_reg; i++)\n+\t      for (i = 0; i < deps->max_reg; i++)\n \t\t{\n-\t\t  for (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t\t  struct deps_reg *reg_last = &deps->reg_last[i];\n+\t\t\n+\t\t  for (u = reg_last->uses; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t\t  free_INSN_LIST_list (&deps->reg_last_uses[i]);\n-\n-\t\t  for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t\t  for (u = reg_last->sets; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), 0);\n-\n-\t\t  for (u = deps->reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\t  for (u = reg_last->clobbers; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), 0);\n+\n+\t\t  free_INSN_LIST_list (&reg_last->uses);\n \t\t}\n \t      reg_pending_sets_all = 1;\n \n@@ -1272,10 +1293,9 @@ sched_analyze (deps, head, tail)\n \t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\tif (call_used_regs[i] || global_regs[i])\n \t\t  {\n-\t\t    for (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t\t    for (u = deps->reg_last[i].uses; u; u = XEXP (u, 1))\n \t\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\n-\t\t    for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t\t    for (u = deps->reg_last[i].sets; u; u = XEXP (u, 1))\n \t\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n \t\t    SET_REGNO_REG_SET (reg_pending_clobbers, i);\n@@ -1424,10 +1444,12 @@ void\n init_deps (deps)\n      struct deps *deps;\n {\n-  int maxreg = max_reg_num ();\n-  deps->reg_last_uses = (rtx *) xcalloc (maxreg, sizeof (rtx));\n-  deps->reg_last_sets = (rtx *) xcalloc (maxreg, sizeof (rtx));\n-  deps->reg_last_clobbers = (rtx *) xcalloc (maxreg, sizeof (rtx));\n+  int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n+\n+  deps->max_reg = max_reg;\n+  deps->reg_last = (struct deps_reg *)\n+    xcalloc (max_reg, sizeof (struct deps_reg));\n+  INIT_REG_SET (&deps->reg_last_in_use);\n \n   deps->pending_read_insns = 0;\n   deps->pending_read_mems = 0;\n@@ -1450,26 +1472,22 @@ void\n free_deps (deps)\n      struct deps *deps;\n {\n-  int max_reg = max_reg_num ();\n   int i;\n \n-  /* Note this loop is executed max_reg * nr_regions times.  It's first\n-     implementation accounted for over 90% of the calls to free_INSN_LIST_list.\n-     The list was empty for the vast majority of those calls.  On the PA, not\n-     calling free_INSN_LIST_list in those cases improves -O2 compile times by\n-     3-5% on average.  */\n-  for (i = 0; i < max_reg; ++i)\n+  /* Without the EXECUTE_IF_SET, this loop is executed max_reg * nr_regions\n+     times.  For a test case with 42000 regs and 8000 small basic blocks,\n+     this loop accounted for nearly 60% (84 sec) of the total -O2 runtime.  */\n+  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i,\n     {\n-      if (deps->reg_last_clobbers[i])\n-\tfree_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n-      if (deps->reg_last_sets[i])\n-\tfree_INSN_LIST_list (&deps->reg_last_sets[i]);\n-      if (deps->reg_last_uses[i])\n-\tfree_INSN_LIST_list (&deps->reg_last_uses[i]);\n-    }\n-  free (deps->reg_last_clobbers);\n-  free (deps->reg_last_sets);\n-  free (deps->reg_last_uses);\n+      struct deps_reg *reg_last = &deps->reg_last[i];\n+      free_INSN_LIST_list (&reg_last->uses);\n+      free_INSN_LIST_list (&reg_last->sets);\n+      free_INSN_LIST_list (&reg_last->clobbers);\n+    });\n+  CLEAR_REG_SET (&deps->reg_last_in_use);\n+\n+  free (deps->reg_last);\n+  deps->reg_last = NULL;\n }\n \n /* If it is profitable to use them, initialize caches for tracking"}, {"sha": "fdd49eadca707354d411572be096301de736b18e", "filename": "gcc/sched-int.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "patch": "@@ -78,13 +78,24 @@ struct deps\n      to ensure that they won't cross a call after scheduling is done.  */\n   rtx sched_before_next_call;\n \n+  /* The maximum register number for the following arrays.  Before reload\n+     this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n+  int max_reg;\n+\n   /* Element N is the next insn that sets (hard or pseudo) register\n      N within the current basic block; or zero, if there is no\n      such insn.  Needed for new registers which may be introduced\n      by splitting insns.  */\n-  rtx *reg_last_uses;\n-  rtx *reg_last_sets;\n-  rtx *reg_last_clobbers;\n+  struct deps_reg\n+    {\n+      rtx uses;\n+      rtx sets;\n+      rtx clobbers;\n+    } *reg_last;\n+\n+  /* Element N is set for each register that has any non-zero element\n+     in reg_last[N].{uses,sets,clobbers}.  */\n+  regset_head reg_last_in_use;\n };\n \n /* This structure holds some state of the current scheduling pass, and"}, {"sha": "13c358816b77667eff9f9f3b7e6d10cf86cc314c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 31, "deletions": 65, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba478b87c50718ac4dd3af0e2cf42392dbb5641/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=4ba478b87c50718ac4dd3af0e2cf42392dbb5641", "patch": "@@ -304,7 +304,7 @@ void debug_dependencies PARAMS ((void));\n \n static void init_regions PARAMS ((void));\n static void schedule_region PARAMS ((int));\n-static void propagate_deps PARAMS ((int, struct deps *, int));\n+static void propagate_deps PARAMS ((int, struct deps *));\n static void free_pending_lists PARAMS ((void));\n \n /* Functions for construction of the control flow graph.  */\n@@ -2440,13 +2440,11 @@ add_branch_dependences (head, tail)\n static struct deps *bb_deps;\n \n /* After computing the dependencies for block BB, propagate the dependencies\n-   found in TMP_DEPS to the successors of the block.  MAX_REG is the number\n-   of registers.  */\n+   found in TMP_DEPS to the successors of the block.  */\n static void\n-propagate_deps (bb, tmp_deps, max_reg)\n+propagate_deps (bb, tmp_deps)\n      int bb;\n      struct deps *tmp_deps;\n-     int max_reg;\n {\n   int b = BB_TO_BLOCK (bb);\n   int e, first_edge;\n@@ -2481,43 +2479,28 @@ propagate_deps (bb, tmp_deps, max_reg)\n \t  continue;\n \t}\n \n-      for (reg = 0; reg < max_reg; reg++)\n+      /* The reg_last lists are inherited by bb_succ.  */\n+      EXECUTE_IF_SET_IN_REG_SET (&tmp_deps->reg_last_in_use, 0, reg,\n \t{\n-\t  /* reg-last-uses lists are inherited by bb_succ.  */\n-\t  for (u = tmp_deps->reg_last_uses[reg]; u; u = XEXP (u, 1))\n-\t    {\n-\t      if (find_insn_list (XEXP (u, 0),\n-\t\t\t\t  succ_deps->reg_last_uses[reg]))\n-\t\tcontinue;\n-\n-\t      succ_deps->reg_last_uses[reg]\n-\t\t= alloc_INSN_LIST (XEXP (u, 0),\n-\t\t\t\t   succ_deps->reg_last_uses[reg]);\n-\t    }\n-\n-\t  /* reg-last-defs lists are inherited by bb_succ.  */\n-\t  for (u = tmp_deps->reg_last_sets[reg]; u; u = XEXP (u, 1))\n-\t    {\n-\t      if (find_insn_list (XEXP (u, 0),\n-\t\t\t\t  succ_deps->reg_last_sets[reg]))\n-\t\tcontinue;\n-\n-\t      succ_deps->reg_last_sets[reg]\n-\t\t= alloc_INSN_LIST (XEXP (u, 0),\n-\t\t\t\t   succ_deps->reg_last_sets[reg]);\n-\t    }\n-\n-\t  for (u = tmp_deps->reg_last_clobbers[reg]; u; u = XEXP (u, 1))\n-\t    {\n-\t      if (find_insn_list (XEXP (u, 0),\n-\t\t\t\t  succ_deps->reg_last_clobbers[reg]))\n-\t\tcontinue;\n-\n-\t      succ_deps->reg_last_clobbers[reg]\n-\t\t= alloc_INSN_LIST (XEXP (u, 0),\n-\t\t\t\t   succ_deps->reg_last_clobbers[reg]);\n-\t    }\n-\t}\n+\t  struct deps_reg *tmp_deps_reg = &tmp_deps->reg_last[reg];\n+\t  struct deps_reg *succ_deps_reg = &succ_deps->reg_last[reg];\n+\n+\t  for (u = tmp_deps_reg->uses; u; u = XEXP (u, 1))\n+\t    if (! find_insn_list (XEXP (u, 0), succ_deps_reg->uses))\n+\t      succ_deps_reg->uses\n+\t\t= alloc_INSN_LIST (XEXP (u, 0), succ_deps_reg->uses);\n+\n+\t  for (u = tmp_deps_reg->sets; u; u = XEXP (u, 1))\n+\t    if (! find_insn_list (XEXP (u, 0), succ_deps_reg->sets))\n+\t      succ_deps_reg->sets\n+\t\t= alloc_INSN_LIST (XEXP (u, 0), succ_deps_reg->sets);\n+\n+\t  for (u = tmp_deps_reg->clobbers; u; u = XEXP (u, 1))\n+\t    if (! find_insn_list (XEXP (u, 0), succ_deps_reg->clobbers))\n+\t      succ_deps_reg->clobbers\n+\t\t= alloc_INSN_LIST (XEXP (u, 0), succ_deps_reg->clobbers);\n+\t});\n+      IOR_REG_SET (&succ_deps->reg_last_in_use, &tmp_deps->reg_last_in_use);\n \n       /* Mem read/write lists are inherited by bb_succ.  */\n       link_insn = tmp_deps->pending_read_insns;\n@@ -2554,27 +2537,17 @@ propagate_deps (bb, tmp_deps, max_reg)\n \n       /* last_function_call is inherited by bb_succ.  */\n       for (u = tmp_deps->last_function_call; u; u = XEXP (u, 1))\n-\t{\n-\t  if (find_insn_list (XEXP (u, 0),\n-\t\t\t      succ_deps->last_function_call))\n-\t    continue;\n-\n+\tif (! find_insn_list (XEXP (u, 0), succ_deps->last_function_call))\n \t  succ_deps->last_function_call\n-\t    = alloc_INSN_LIST (XEXP (u, 0),\n-\t\t\t       succ_deps->last_function_call);\n-\t}\n+\t    = alloc_INSN_LIST (XEXP (u, 0), succ_deps->last_function_call);\n \n       /* last_pending_memory_flush is inherited by bb_succ.  */\n       for (u = tmp_deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t{\n-\t  if (find_insn_list (XEXP (u, 0),\n+\tif (! find_insn_list (XEXP (u, 0),\n \t\t\t      succ_deps->last_pending_memory_flush))\n-\t    continue;\n-\n \t  succ_deps->last_pending_memory_flush\n \t    = alloc_INSN_LIST (XEXP (u, 0),\n \t\t\t       succ_deps->last_pending_memory_flush);\n-\t}\n \n       /* sched_before_next_call is inherited by bb_succ.  */\n       x = LOG_LINKS (tmp_deps->sched_before_next_call);\n@@ -2594,8 +2567,8 @@ propagate_deps (bb, tmp_deps, max_reg)\n \n    Specifically for reg-reg data dependences, the block insns are\n    scanned by sched_analyze () top-to-bottom.  Two lists are\n-   maintained by sched_analyze (): reg_last_sets[] for register DEFs,\n-   and reg_last_uses[] for register USEs.\n+   maintained by sched_analyze (): reg_last[].sets for register DEFs,\n+   and reg_last[].uses for register USEs.\n \n    When analysis is completed for bb, we update for its successors:\n    ;  - DEFS[succ] = Union (DEFS [succ], DEFS [bb])\n@@ -2609,7 +2582,6 @@ compute_block_backward_dependences (bb)\n      int bb;\n {\n   rtx head, tail;\n-  int max_reg = max_reg_num ();\n   struct deps tmp_deps;\n \n   tmp_deps = bb_deps[bb];\n@@ -2620,18 +2592,12 @@ compute_block_backward_dependences (bb)\n   add_branch_dependences (head, tail);\n \n   if (current_nr_blocks > 1)\n-    propagate_deps (bb, &tmp_deps, max_reg);\n+    propagate_deps (bb, &tmp_deps);\n \n   /* Free up the INSN_LISTs.  */\n   free_deps (&tmp_deps);\n-\n-  /* Assert that we won't need bb_reg_last_* for this block anymore.  \n-     The vectors we're zeroing out have just been freed by the call to\n-     free_deps.  */\n-  bb_deps[bb].reg_last_uses = 0;\n-  bb_deps[bb].reg_last_sets = 0;\n-  bb_deps[bb].reg_last_clobbers = 0;\n }\n+\n /* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add\n    them to the unused_*_list variables, so that they can be reused.  */\n "}]}