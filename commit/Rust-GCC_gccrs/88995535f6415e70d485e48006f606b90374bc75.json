{"sha": "88995535f6415e70d485e48006f606b90374bc75", "node_id": "C_kwDOANBUbNoAKDg4OTk1NTM1ZjY0MTVlNzBkNDg1ZTQ4MDA2ZjYwNmI5MDM3NGJjNzU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-23T11:25:16Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-23T11:29:50Z"}, "message": "Support QualifiedPathInType's within the same Trait\n\nThe first implementation of qualified paths assumed that they only exist\nwithin trait-impl blocks. Trait impl blocks have the same canonical paths\nof <type as trait_path>::segment form but this type of path is more generic\nthan this.\n\nThis patch changes the name resolver to allow for failures in looking up\nthe qualified path within the type namespace since it will not exist in\nthis case and updates the type checking code to be more permissive when\nused outside of trait impl blocks to simply allow us to resolve this type\nto the associated trait item as we expect. Usually the code here tries\nto setup any associated types based on the associated impl block but this\nis a difference case.\n\nFixes #739", "tree": {"sha": "4d86b741b4a0519b1fb4d57400dd338ee548644b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d86b741b4a0519b1fb4d57400dd338ee548644b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88995535f6415e70d485e48006f606b90374bc75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88995535f6415e70d485e48006f606b90374bc75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88995535f6415e70d485e48006f606b90374bc75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88995535f6415e70d485e48006f606b90374bc75/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87da9922e66d64e2ef307d33076da86b8486bea0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87da9922e66d64e2ef307d33076da86b8486bea0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87da9922e66d64e2ef307d33076da86b8486bea0"}], "stats": {"total": 121, "additions": 73, "deletions": 48}, "files": [{"sha": "9e5b1e2af8b4afc03ede36de142981bf91be0c43", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88995535f6415e70d485e48006f606b90374bc75/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88995535f6415e70d485e48006f606b90374bc75/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=88995535f6415e70d485e48006f606b90374bc75", "patch": "@@ -191,28 +191,25 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n   using ResolveTypeToCanonicalPath::visit;\n \n public:\n-  static NodeId go (AST::QualifiedPathInType &path, NodeId parent,\n-\t\t    bool canonicalize_type_with_generics)\n+  static bool go (AST::QualifiedPathInType &path, NodeId parent,\n+\t\t  bool canonicalize_type_with_generics)\n   {\n+    // resolve the type and trait path\n     auto &qualified_path = path.get_qualified_path_type ();\n     CanonicalPath result = CanonicalPath::create_empty ();\n     if (!resolve_qual_seg (qualified_path, result))\n-      return UNKNOWN_NODEID;\n+      return false;\n \n-    // resolve the associated impl\n+    // resolve the associated impl if available but it can also be from a trait\n+    // and this is allowed to fail\n     auto resolver = Resolver::get ();\n     NodeId projection_resolved_id = UNKNOWN_NODEID;\n-    if (!resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n+    if (resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n       {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"failed to resolve associated path: %s\",\n-\t\t       result.get ().c_str ());\n-\n-\treturn UNKNOWN_NODEID;\n+\t// mark the resolution for this\n+\tresolver->insert_resolved_name (qualified_path.get_node_id (),\n+\t\t\t\t\tprojection_resolved_id);\n       }\n-    // mark the resolution for this\n-    resolver->insert_resolved_name (qualified_path.get_node_id (),\n-\t\t\t\t    projection_resolved_id);\n \n     // qualified types are similar to other paths in that we cannot guarantee\n     // that we can resolve the path at name resolution. We must look up\n@@ -224,18 +221,16 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n \n     associated->accept_vis (o);\n     if (o.failure_flag)\n-      return UNKNOWN_NODEID;\n+      return false;\n \n     for (auto &seg : path.get_segments ())\n       {\n \tseg->accept_vis (o);\n \tif (o.failure_flag)\n-\t  return UNKNOWN_NODEID;\n+\t  return false;\n       }\n \n-    // we only return the projection id for now since we need the type system to\n-    // resolve the associated types in this path\n-    return projection_resolved_id;\n+    return true;\n   }\n \n private:\n@@ -352,10 +347,8 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::QualifiedPathInType &path) override\n   {\n-    resolved_node\n-      = ResolveRelativeTypePath::go (path, parent,\n-\t\t\t\t     canonicalize_type_with_generics);\n-    ok = resolved_node != UNKNOWN_NODEID;\n+    ok = ResolveRelativeTypePath::go (path, parent,\n+\t\t\t\t      canonicalize_type_with_generics);\n   }\n \n   void visit (AST::ArrayType &type) override;"}, {"sha": "50cf34faa97393cf72daa1f38b7c914ba551ea62", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88995535f6415e70d485e48006f606b90374bc75/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88995535f6415e70d485e48006f606b90374bc75/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=88995535f6415e70d485e48006f606b90374bc75", "patch": "@@ -42,14 +42,22 @@ class TypeBoundsProbe : public TypeCheckBase\n   static bool is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n \t\t\t\t\t   TraitReference *ref)\n   {\n+    for (auto &bound : receiver->get_specified_bounds ())\n+      {\n+\tconst TraitReference *b = bound.get ();\n+\tif (b->is_equal (*ref))\n+\t  return true;\n+      }\n+\n     std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> bounds\n       = Probe (receiver);\n     for (auto &bound : bounds)\n       {\n-\tTraitReference *b = bound.first;\n-\tif (b == ref)\n+\tconst TraitReference *b = bound.first;\n+\tif (b->is_equal (*ref))\n \t  return true;\n       }\n+\n     return false;\n   }\n "}, {"sha": "42566549b4e47c1038e416f3a97a335ad45c08c4", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88995535f6415e70d485e48006f606b90374bc75/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88995535f6415e70d485e48006f606b90374bc75/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=88995535f6415e70d485e48006f606b90374bc75", "patch": "@@ -140,29 +140,16 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \n   // does this type actually implement this type-bound?\n   if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n-    return;\n-\n-  // we need resolve to the impl block\n-  NodeId impl_resolved_id = UNKNOWN_NODEID;\n-  bool ok = resolver->lookup_resolved_name (\n-    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-  rust_assert (ok);\n-\n-  HirId impl_block_id;\n-  ok = mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n-\t\t\t\t     impl_resolved_id, &impl_block_id);\n-  rust_assert (ok);\n-\n-  AssociatedImplTrait *lookup_associated = nullptr;\n-  bool found_impl_trait\n-    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n-  rust_assert (found_impl_trait);\n+    {\n+      rust_error_at (qual_path_type.get_locus (),\n+\t\t     \"root does not satisfy specified trait-bound\");\n+      return;\n+    }\n \n   std::unique_ptr<HIR::TypePathSegment> &item_seg\n     = path.get_associated_segment ();\n-\n   const TraitItemReference *trait_item_ref = nullptr;\n-  ok\n+  bool ok\n     = trait_ref->lookup_trait_item (item_seg->get_ident_segment ().as_string (),\n \t\t\t\t    &trait_item_ref);\n   if (!ok)\n@@ -171,16 +158,39 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       return;\n     }\n \n-  // project\n-  lookup_associated->setup_associated_types ();\n+  // this will be the placeholder from the trait but we may be able to project\n+  // it based on the impl block\n+  translated = trait_item_ref->get_tyty ();\n \n+  // this is the associated generics we need to potentially apply\n   HIR::GenericArgs trait_generics = qual_path_type.trait_has_generic_args ()\n \t\t\t\t      ? qual_path_type.get_trait_generic_args ()\n \t\t\t\t      : HIR::GenericArgs::create_empty ();\n \n-  translated = lookup_associated->get_projected_type (\n-    trait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n-    trait_generics, item_seg->get_locus ());\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool have_associated_impl = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  if (have_associated_impl)\n+    {\n+      HirId impl_block_id;\n+      bool ok\n+\t= mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n+\t\t\t\t\timpl_resolved_id, &impl_block_id);\n+      rust_assert (ok);\n+\n+      AssociatedImplTrait *lookup_associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t &lookup_associated);\n+      rust_assert (found_impl_trait);\n+\n+      // project\n+      lookup_associated->setup_associated_types ();\n+      translated = lookup_associated->get_projected_type (\n+\ttrait_item_ref, root, item_seg->get_mappings ().get_hirid (),\n+\ttrait_generics, item_seg->get_locus ());\n+    }\n \n   if (translated->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n     {"}, {"sha": "0d4b4c7923fcfe4ab21f0a09ab031efda1ed6e98", "filename": "gcc/testsuite/rust/compile/torture/associated_types1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88995535f6415e70d485e48006f606b90374bc75/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fassociated_types1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88995535f6415e70d485e48006f606b90374bc75/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fassociated_types1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fassociated_types1.rs?ref=88995535f6415e70d485e48006f606b90374bc75", "patch": "@@ -0,0 +1,14 @@\n+pub trait Foo {\n+    type A;\n+\n+    fn boo(&self) -> <Self as Foo>::A;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+}\n+\n+fn foo2<I: Foo>(x: I) {\n+    // { dg-warning \"function is never used: .foo2.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .foo2.\" \"\" { target *-*-* } .-2 }\n+    x.boo();\n+}\n+\n+pub fn main() {}"}]}