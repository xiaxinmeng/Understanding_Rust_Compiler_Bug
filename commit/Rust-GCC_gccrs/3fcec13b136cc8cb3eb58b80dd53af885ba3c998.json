{"sha": "3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "node_id": "C_kwDOANBUbNoAKDNmY2VjMTNiMTM2Y2M4Y2IzZWI1OGI4MGRkNTNhZjg4NWJhM2M5OTg", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-05-21T16:13:34Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-06-08T12:32:35Z"}, "message": "expand: Add derive proc macro draft\n\nAdd a first draft for derive proc macros based on the attribute expander\ncode. Convert the result back to a parsable entity and parse it.\nThe procedural macro expander was beginning to require almost all\nfunctionalities already provided by the macro expander, hence the merge.\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-ast-collector.h: Update enum name to match\n\tdefinition.\n\t* expand/rust-expand-visitor.cc (ExpandVisitor::expand_derive):\n\tAdd call to expander.\n\t(ExpandVisitor::expand_outer_attribute):\n\tChange call to macro expander.\n\t(ExpandVisitor::expand_inner_attribute): Likewise.\n\t* expand/rust-expand-visitor.h: Remove const attribute to match\n\tvisitor declaration. Attach result to the AST. Add condition for\n\titem erasure.\n\t* expand/rust-proc-macro.h: Add token collector and expansion\n\tcall. Add lexers and parsers for each proc macro type and uses\n\tthem to parse macro output.\n\t* expand/rust-macro-expand.h (struct MacroExpander): Add\n\tfunctions.\n\t* expand/rust-proc-macro.cc (ProcMacroExpander::import_proc_macros):\n\tMoved from here...\n\t* expand/rust-macro-expand.cc (MacroExpander::import_proc_macros):\n\t... to here. Unify procedural macro parsing under one function.\n\tAdd a flag to determine whether it originate from a derive\n\tmacro.\n\t(MacroExpander::parse_procmacro_output):\n\tParse macro output to statements. Store an error on parsing\n\tfailure.\n\t* Make-lang.in: Add const_TokenPtr specific lexer.\n\t* expand/rust-proc-macro-invoc-lexer.cc: New file.\n\t* expand/rust-proc-macro-invoc-lexer.h: New file.\n\t* rust-session-manager.cc (Session::expansion): Remove\n\tProcMacroExpander declaration.\n\t* ast/rust-ast-fragment.cc (Fragment::Fragment): Add overwrite\n\tflag.\n\t(Fragment::should_overwrite): Add a getter to determine whether\n\tthe fragment shall overwrite it's parent or be appended after.\n\t* ast/rust-ast-fragment.h: Add flag to declaration.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "618fd463312a92415543effa9092a58dfa41180f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/618fd463312a92415543effa9092a58dfa41180f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12131c106fdffe25c40fa4a309d8ead03b99a685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12131c106fdffe25c40fa4a309d8ead03b99a685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12131c106fdffe25c40fa4a309d8ead03b99a685"}], "stats": {"total": 541, "additions": 395, "deletions": 146}, "files": [{"sha": "b4342dd817e3bb062881fe67191220882937b503", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -93,6 +93,7 @@ GRS_OBJS = \\\n \trust/rust-derive-copy.o \\\n \trust/rust-proc-macro.o \\\n     rust/rust-macro-invoc-lexer.o \\\n+    rust/rust-proc-macro-invoc-lexer.o \\\n     rust/rust-macro-substitute-ctx.o \\\n     rust/rust-macro-builtins.o \\\n     rust/rust-hir.o \\"}, {"sha": "feb6c47f4e9899fbb3d17174862b4b881e1d065c", "filename": "gcc/rust/ast/rust-ast-collector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fast%2Frust-ast-collector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fast%2Frust-ast-collector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-collector.h?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -231,7 +231,7 @@ class TokenCollector : public ASTVisitor\n   void visit (EnumItemTuple &item);\n   void visit (EnumItemStruct &item);\n   void visit (EnumItemDiscriminant &item);\n-  void visit (Enum &enum_item);\n+  void visit (Enum &enumeration);\n   void visit (Union &union_item);\n   void visit (ConstantItem &const_item);\n   void visit (StaticItem &static_item);"}, {"sha": "dd2e8a8000e7899b3d7825f2a9fad7c56b06e706", "filename": "gcc/rust/ast/rust-ast-fragment.cc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.cc?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -23,7 +23,8 @@ namespace AST {\n \n Fragment::Fragment (FragmentKind kind, std::vector<SingleASTNode> nodes,\n \t\t    std::vector<std::unique_ptr<AST::Token>> tokens)\n-  : kind (kind), nodes (std::move (nodes)), tokens (std::move (tokens))\n+  : kind (kind), nodes (std::move (nodes)), tokens (std::move (tokens)),\n+    overwrite (true)\n {}\n \n Fragment::Fragment (Fragment const &other) : kind (other.get_kind ())\n@@ -46,6 +47,8 @@ Fragment::operator= (Fragment const &other)\n   for (auto &t : other.tokens)\n     tokens.emplace_back (t->clone_token ());\n \n+  overwrite = other.overwrite;\n+\n   return *this;\n }\n \n@@ -56,14 +59,15 @@ Fragment::create_error ()\n }\n \n Fragment::Fragment (std::vector<AST::SingleASTNode> nodes,\n-\t\t    std::vector<std::unique_ptr<AST::Token>> tokens)\n+\t\t    std::vector<std::unique_ptr<AST::Token>> tokens,\n+\t\t    bool overwrite)\n   : kind (FragmentKind::Complete), nodes (std::move (nodes)),\n-    tokens (std::move (tokens))\n+    tokens (std::move (tokens)), overwrite (overwrite)\n {}\n \n Fragment::Fragment (std::vector<AST::SingleASTNode> nodes,\n \t\t    std::unique_ptr<AST::Token> token)\n-  : kind (FragmentKind::Complete), nodes (std::move (nodes))\n+  : kind (FragmentKind::Complete), nodes (std::move (nodes)), overwrite (true)\n {\n   tokens.emplace_back (std::move (token));\n }\n@@ -98,6 +102,12 @@ Fragment::should_expand () const\n   return !is_error ();\n }\n \n+bool\n+Fragment::should_overwrite () const\n+{\n+  return overwrite;\n+}\n+\n bool\n Fragment::is_expression_fragment () const\n {"}, {"sha": "36f94db0fb70be99557e13d4a56648d6458bfeb8", "filename": "gcc/rust/ast/rust-ast-fragment.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.h?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -64,7 +64,8 @@ class Fragment\n    * Create a complete AST fragment\n    */\n   Fragment (std::vector<AST::SingleASTNode> nodes,\n-\t    std::vector<std::unique_ptr<AST::Token>> tokens);\n+\t    std::vector<std::unique_ptr<AST::Token>> tokens,\n+\t    bool overwrite = true);\n \n   /**\n    * Create a complete AST fragment made of a single token\n@@ -78,6 +79,7 @@ class Fragment\n \n   bool is_error () const;\n   bool should_expand () const;\n+  bool should_overwrite () const;\n \n   bool is_expression_fragment () const;\n   bool is_type_fragment () const;\n@@ -109,6 +111,12 @@ class Fragment\n    */\n   std::vector<std::unique_ptr<AST::Token>> tokens;\n \n+  /**\n+   * Whether the fragment should overwrite the original content. In most case\n+   * it should overwrite it, but not with derive procedural macros.\n+   */\n+  bool overwrite;\n+\n   /**\n    * We need to make a special case for Expression and Type fragments as only\n    * one Node will be extracted from the `nodes` vector"}, {"sha": "cb6c2993354090832240909689685a40c38268e8", "filename": "gcc/rust/expand/rust-expand-visitor.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -1553,7 +1553,7 @@ void\n ExpandVisitor::expand_outer_attribute (T &item, AST::SimplePath &path)\n {\n   // FIXME: Retrieve path from segments + local use statements instead of string\n-  proc_expander.expand_attribute_proc_macro (item, path);\n+  expander.expand_attribute_proc_macro (item, path);\n }\n \n template <typename T>\n@@ -1588,7 +1588,7 @@ void\n ExpandVisitor::expand_inner_attribute (T &item, AST::SimplePath &path)\n {\n   // FIXME: Retrieve path from segments + local use statements instead of string\n-  proc_expander.expand_attribute_proc_macro (item, path);\n+  expander.expand_attribute_proc_macro (item, path);\n }\n \n template <typename T>\n@@ -1621,15 +1621,15 @@ ExpandVisitor::visit_inner_attrs (T &item)\n \n template <typename T>\n void\n-ExpandVisitor::expand_derive (const T &item,\n-\t\t\t      std::unique_ptr<AST::TokenTree> &trait)\n+ExpandVisitor::expand_derive (T &item, std::unique_ptr<AST::TokenTree> trait)\n {\n-  // FIXME: Implement expansion for that particular trait\n+  auto trait_name = trait->as_string ();\n+  expander.expand_derive_proc_macro (item, trait_name);\n }\n \n template <typename T>\n void\n-ExpandVisitor::expand_derive (const T &item, AST::DelimTokenTree &attr)\n+ExpandVisitor::expand_derive (T &item, AST::DelimTokenTree &attr)\n {\n   // Item is const because even though the tokenstream might be modified, it\n   // should appear as the same input for every derive proc macro.\n@@ -1640,7 +1640,7 @@ ExpandVisitor::expand_derive (const T &item, AST::DelimTokenTree &attr)\n       for (auto it = trees.begin () + 1; it < trees.end () - 1;\n \t   it += 2 /* Increment + skip comma */)\n \t{\n-\t  expand_derive (item, *it);\n+\t  expand_derive (item, std::move (*it));\n \t}\n     }\n }"}, {"sha": "0dd5c9a21d198ffc3f3d664172ad7adfc0379766", "filename": "gcc/rust/expand/rust-expand-visitor.h", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -40,9 +40,7 @@ is_builtin (AST::Attribute &attr);\n class ExpandVisitor : public AST::ASTVisitor\n {\n public:\n-  ExpandVisitor (MacroExpander &expander, ProcMacroExpander &proc_expander)\n-    : expander (expander), proc_expander (proc_expander)\n-  {}\n+  ExpandVisitor (MacroExpander &expander) : expander (expander) {}\n \n   /* Expand all of the macro invocations currently contained in a crate */\n   void go (AST::Crate &crate);\n@@ -129,6 +127,8 @@ class ExpandVisitor : public AST::ASTVisitor\n \tvalue->accept_vis (*this);\n \n \tauto final_fragment = expander.take_expanded_fragment ();\n+\tauto proc_macro_fragment\n+\t  = expander.take_expanded_proc_macro_fragment ();\n \n \t// FIXME: Is that correct? It seems *extremely* dodgy\n \tif (final_fragment.should_expand ())\n@@ -144,6 +144,22 @@ class ExpandVisitor : public AST::ASTVisitor\n \t\t  }\n \t      }\n \t  }\n+\telse if (proc_macro_fragment.should_expand ())\n+\t  {\n+\t    if (proc_macro_fragment.should_overwrite ())\n+\t      it = values.erase (it);\n+\t    else\n+\t      it++;\n+\t    for (auto &node : proc_macro_fragment.get_nodes ())\n+\t      {\n+\t\tauto new_node = extractor (node);\n+\t\tif (new_node != nullptr)\n+\t\t  {\n+\t\t    it = values.insert (it, std::move (new_node));\n+\t\t    it++;\n+\t\t  }\n+\t      }\n+\t  }\n \telse\n \t  {\n \t    ++it;\n@@ -368,16 +384,14 @@ class ExpandVisitor : public AST::ASTVisitor\n   template <typename T> void visit_inner_attrs (T &item);\n \n   template <typename T>\n-  void expand_derive (const T &item, std::unique_ptr<AST::TokenTree> &trait);\n+  void expand_derive (T &item, std::unique_ptr<AST::TokenTree> trait);\n \n-  template <typename T>\n-  void expand_derive (const T &item, AST::DelimTokenTree &attr);\n+  template <typename T> void expand_derive (T &item, AST::DelimTokenTree &attr);\n \n   template <typename T> void visit_attrs_with_derive (T &item);\n \n private:\n   MacroExpander &expander;\n-  ProcMacroExpander &proc_expander;\n };\n \n } // namespace Rust"}, {"sha": "14c6cbc73103b2b8d12c8ddbb6e253c2789825d7", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -24,6 +24,8 @@\n #include \"rust-parse.h\"\n #include \"rust-cfg-strip.h\"\n #include \"rust-early-name-resolver.h\"\n+#include \"rust-session-manager.h\"\n+#include \"rust-proc-macro.h\"\n \n namespace Rust {\n \n@@ -1049,4 +1051,92 @@ MacroExpander::transcribe_rule (\n \n   return fragment;\n }\n+\n+// TODO: Move to early name resolver ?\n+void\n+MacroExpander::import_proc_macros (std::string extern_crate)\n+{\n+  auto path = session.extern_crates.find (extern_crate);\n+  if (path == session.extern_crates.end ())\n+    {\n+      // Extern crate path is not available.\n+      // FIXME: Emit error\n+      rust_error_at (Location (), \"Cannot find requested proc macro crate\");\n+      gcc_unreachable ();\n+    }\n+  auto macros = load_macros (path->second);\n+\n+  std::string prefix = extern_crate + \"::\";\n+  for (auto &macro : macros)\n+    {\n+      switch (macro.tag)\n+\t{\n+\tcase ProcMacro::CUSTOM_DERIVE:\n+\t  rust_debug (\"Found one derive proc macro.\");\n+\t  mappings->insert_derive_proc_macro (\n+\t    std::make_pair (extern_crate,\n+\t\t\t    macro.payload.custom_derive.trait_name),\n+\t    macro.payload.custom_derive);\n+\t  break;\n+\tcase ProcMacro::ATTR:\n+\t  rust_debug (\"Found one attribute proc macro.\");\n+\t  mappings->insert_attribute_proc_macro (\n+\t    std::make_pair (extern_crate, macro.payload.attribute.name),\n+\t    macro.payload.attribute);\n+\t  break;\n+\tcase ProcMacro::BANG:\n+\t  rust_debug (\"Found one bang proc macro.\");\n+\t  mappings->insert_bang_proc_macro (\n+\t    std::make_pair (extern_crate, macro.payload.bang.name),\n+\t    macro.payload.bang);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+void\n+MacroExpander::parse_procmacro_output (ProcMacro::TokenStream ts, bool derive)\n+{\n+  ProcMacroInvocLexer lex (convert (ts));\n+  Parser<ProcMacroInvocLexer> parser (lex);\n+\n+  std::vector<AST::SingleASTNode> nodes;\n+  switch (peek_context ())\n+    {\n+    case ContextType::ITEM:\n+      while (lex.peek_token ()->get_id () != END_OF_FILE)\n+\t{\n+\t  auto result = parser.parse_item (false);\n+\t  if (result == nullptr)\n+\t    break;\n+\t  nodes.push_back ({std::move (result)});\n+\t}\n+      break;\n+    case ContextType::BLOCK:\n+      while (lex.peek_token ()->get_id () != END_OF_FILE)\n+\t{\n+\t  auto result = parser.parse_stmt ();\n+\t  if (result == nullptr)\n+\t    break;\n+\t  nodes.push_back ({std::move (result)});\n+\t}\n+      break;\n+    case ContextType::TRAIT:\n+    case ContextType::IMPL:\n+    case ContextType::TRAIT_IMPL:\n+    case ContextType::EXTERN:\n+    case ContextType::TYPE:\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (parser.has_errors ())\n+    set_expanded_proc_macro_fragment (AST::Fragment::create_error ());\n+  else\n+    set_expanded_proc_macro_fragment (\n+      {nodes, std::vector<std::unique_ptr<AST::Token>> (), !derive});\n+}\n+\n } // namespace Rust"}, {"sha": "811417a9faef5fdf8f4d22a89ab4b21a00fb2002", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -28,6 +28,11 @@\n #include \"rust-early-name-resolver.h\"\n #include \"rust-name-resolver.h\"\n #include \"rust-macro-invoc-lexer.h\"\n+#include \"rust-proc-macro-invoc-lexer.h\"\n+#include \"rust-token-converter.h\"\n+#include \"rust-ast-collector.h\"\n+#include \"rust-system.h\"\n+#include \"libproc_macro/proc_macro.h\"\n \n // Provides objects and method prototypes for macro expansion\n \n@@ -231,6 +236,7 @@ struct MacroExpander\n     : cfg (cfg), crate (crate), session (session),\n       sub_stack (SubstitutionScope ()),\n       expanded_fragment (AST::Fragment::create_error ()),\n+      expanded_proc_macro_fragment (AST::Fragment::create_error ()),\n       has_changed_flag (false), resolver (Resolver::Resolver::get ()),\n       mappings (Analysis::Mappings::get ())\n   {}\n@@ -332,6 +338,126 @@ struct MacroExpander\n     return fragment;\n   }\n \n+  void set_expanded_proc_macro_fragment (AST::Fragment &&fragment)\n+  {\n+    if (!fragment.is_error ())\n+      has_changed_flag = true;\n+\n+    expanded_proc_macro_fragment = std::move (fragment);\n+  }\n+\n+  AST::Fragment take_expanded_proc_macro_fragment ()\n+  {\n+    auto fragment = std::move (expanded_proc_macro_fragment);\n+    expanded_proc_macro_fragment = AST::Fragment::create_error ();\n+\n+    return fragment;\n+  }\n+\n+  void import_proc_macros (std::string extern_crate);\n+\n+  template <typename T>\n+  void expand_derive_proc_macro (T &item, std::string &trait_name)\n+  {\n+    ProcMacro::CustomDerive macro;\n+\n+    // FIXME: Resolve crate name\n+    std::string crate = \"\";\n+    std::string name = trait_name;\n+\n+    if (!mappings->lookup_derive_proc_macro (std::make_pair (crate, name),\n+\t\t\t\t\t     macro))\n+      {\n+\t// FIXME: Resolve this path segment instead of taking it directly.\n+\timport_proc_macros (crate);\n+\tif (!mappings->lookup_derive_proc_macro (std::make_pair (crate, name),\n+\t\t\t\t\t\t macro))\n+\t  {\n+\t    rust_error_at (Location (), \"procedural macro %s not found\",\n+\t\t\t   name.c_str ());\n+\t    rust_assert (false);\n+\t  }\n+      }\n+\n+    std::vector<TokenPtr> tokens;\n+    AST::TokenCollector collector (tokens);\n+\n+    collector.visit (item);\n+\n+    auto c = collector.collect_tokens ();\n+    std::vector<const_TokenPtr> vec (c.cbegin (), c.cend ());\n+\n+    parse_procmacro_output (macro.macro (convert (vec)), true);\n+  }\n+\n+  template <typename T>\n+  void expand_bang_proc_macro (T &item, AST::SimplePath &path)\n+  {\n+    ProcMacro::Bang macro;\n+\n+    std::string crate = path.get_segments ()[0].get_segment_name ();\n+    std::string name = path.get_segments ()[1].get_segment_name ();\n+    if (!mappings->lookup_bang_proc_macro (std::make_pair (crate, name), macro))\n+      {\n+\t// FIXME: Resolve this path segment instead of taking it directly.\n+\timport_proc_macros (crate);\n+\n+\tif (!mappings->lookup_bang_proc_macro (std::make_pair (crate, name),\n+\t\t\t\t\t       macro))\n+\t  {\n+\t    rust_error_at (Location (), \"procedural macro %s not found\",\n+\t\t\t   name.c_str ());\n+\t    rust_assert (false);\n+\t  }\n+      }\n+\n+    std::vector<TokenPtr> tokens;\n+    AST::TokenCollector collector (tokens);\n+\n+    collector.visit (item);\n+\n+    auto c = collector.collect_tokens ();\n+    std::vector<const_TokenPtr> vec (c.cbegin (), c.cend ());\n+\n+    parse_procmacro_output (macro.macro (convert (vec)), false);\n+  }\n+\n+  template <typename T>\n+  void expand_attribute_proc_macro (T &item, AST::SimplePath &path)\n+  {\n+    ProcMacro::Attribute macro;\n+\n+    std::string crate = path.get_segments ()[0].get_segment_name ();\n+    std::string name = path.get_segments ()[1].get_segment_name ();\n+    if (!mappings->lookup_attribute_proc_macro (std::make_pair (crate, name),\n+\t\t\t\t\t\tmacro))\n+      {\n+\t// FIXME: Resolve this path segment instead of taking it directly.\n+\timport_proc_macros (crate);\n+\tif (!mappings->lookup_attribute_proc_macro (std::make_pair (crate,\n+\t\t\t\t\t\t\t\t    name),\n+\t\t\t\t\t\t    macro))\n+\t  {\n+\t    rust_error_at (Location (), \"procedural macro %s not found\",\n+\t\t\t   name.c_str ());\n+\t    rust_assert (false);\n+\t  }\n+      }\n+\n+    std::vector<TokenPtr> tokens;\n+    AST::TokenCollector collector (tokens);\n+\n+    collector.visit (item);\n+\n+    auto c = collector.collect_tokens ();\n+    std::vector<const_TokenPtr> vec (c.cbegin (), c.cend ());\n+\n+    // FIXME: Handle attributes\n+    parse_procmacro_output (\n+      macro.macro (ProcMacro::TokenStream::make_tokenstream (), convert (vec)),\n+      false);\n+  }\n+\n   /**\n    * Has the MacroExpander expanded a macro since its state was last reset?\n    */\n@@ -347,11 +473,14 @@ struct MacroExpander\n   AST::MacroInvocation *get_last_invocation () { return last_invoc; }\n \n private:\n+  void parse_procmacro_output (ProcMacro::TokenStream ts, bool derive);\n+\n   AST::Crate &crate;\n   Session &session;\n   SubstitutionScope sub_stack;\n   std::vector<ContextType> context;\n   AST::Fragment expanded_fragment;\n+  AST::Fragment expanded_proc_macro_fragment;\n   bool has_changed_flag;\n \n   AST::MacroRulesDefinition *last_def;"}, {"sha": "f365549bdc1c4a9f9a09d038e04f9cab8288b1cd", "filename": "gcc/rust/expand/rust-proc-macro-invoc-lexer.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro-invoc-lexer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro-invoc-lexer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-proc-macro-invoc-lexer.cc?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-proc-macro-invoc-lexer.h\"\n+#include \"rust-token.h\"\n+\n+namespace Rust {\n+\n+const_TokenPtr\n+ProcMacroInvocLexer::peek_token (int n)\n+{\n+  if ((offs + n) >= token_stream.size ())\n+    return Token::make (END_OF_FILE, Location ());\n+\n+  return token_stream.at (offs + n);\n+}\n+\n+// Advances current token to n + 1 tokens ahead of current position.\n+void\n+ProcMacroInvocLexer::skip_token (int n)\n+{\n+  offs += (n + 1);\n+}\n+\n+void\n+ProcMacroInvocLexer::split_current_token (TokenId new_left, TokenId new_right)\n+{\n+  auto &current_token = token_stream.at (offs);\n+  auto current_pos = token_stream.begin () + offs;\n+\n+  auto l_tok = Token::make (new_left, current_token->get_locus ());\n+  auto r_tok = Token::make (new_right, current_token->get_locus ());\n+\n+  token_stream.erase (current_pos);\n+\n+  // `insert` inserts before the specified position, so we insert the right one\n+  // then the left\n+  token_stream.insert (current_pos, l_tok);\n+  token_stream.insert (current_pos, r_tok);\n+}\n+\n+} // namespace Rust"}, {"sha": "7c047efb1f16dcdfa0658cdf200f0bdeb034d969", "filename": "gcc/rust/expand/rust-proc-macro-invoc-lexer.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro-invoc-lexer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro-invoc-lexer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-proc-macro-invoc-lexer.h?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PROC_MACRO_INVOC_LEXER_H\n+#define RUST_PROC_MACRO_INVOC_LEXER_H\n+\n+#include \"rust-lex.h\"\n+\n+namespace Rust {\n+class ProcMacroInvocLexer\n+{\n+public:\n+  ProcMacroInvocLexer (std::vector<const_TokenPtr> stream)\n+    : offs (0), token_stream (std::move (stream))\n+  {}\n+\n+  // Returns token n tokens ahead of current position.\n+  const_TokenPtr peek_token (int n);\n+\n+  // Peeks the current token.\n+  const_TokenPtr peek_token () { return peek_token (0); }\n+\n+  // Advances current token to n + 1 tokens ahead of current position.\n+  void skip_token (int n);\n+\n+  // Skips the current token.\n+  void skip_token () { skip_token (0); }\n+\n+  // Splits the current token into two. Intended for use with nested generics\n+  // closes (i.e. T<U<X>> where >> is wrongly lexed as one token). Note that\n+  // this will only work with \"simple\" tokens like punctuation.\n+  void split_current_token (TokenId new_left, TokenId new_right);\n+\n+  std::string get_filename () const\n+  {\n+    // FIXME\n+    gcc_unreachable ();\n+    return \"FIXME\";\n+  }\n+\n+  size_t get_offs () const { return offs; }\n+\n+private:\n+  size_t offs;\n+  std::vector<const_TokenPtr> token_stream;\n+};\n+} // namespace Rust\n+\n+#endif /* ! RUST_PROC_MACRO_INVOC_LEXER_H */"}, {"sha": "22744cb547d2c913b94e0ee84cbfb3cd18dba98c", "filename": "gcc/rust/expand/rust-proc-macro.cc", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-proc-macro.cc?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -61,47 +61,4 @@ load_macros (std::string path)\n \t\t\t\t\t    array->macros + array->length);\n }\n \n-void\n-ProcMacroExpander::import_proc_macros (std::string extern_crate)\n-{\n-  auto path = session.extern_crates.find (extern_crate);\n-  if (path == session.extern_crates.end ())\n-    {\n-      // Extern crate path is not available.\n-      // FIXME: Emit error\n-      rust_error_at (Location (), \"Cannot find requested proc macro crate\");\n-      gcc_unreachable ();\n-    }\n-  auto macros = load_macros (path->second);\n-\n-  std::string prefix = extern_crate + \"::\";\n-  for (auto &macro : macros)\n-    {\n-      switch (macro.tag)\n-\t{\n-\tcase ProcMacro::CUSTOM_DERIVE:\n-\t  rust_debug (\"Found one derive proc macro.\");\n-\t  mappings->insert_derive_proc_macro (\n-\t    std::make_pair (extern_crate,\n-\t\t\t    macro.payload.custom_derive.trait_name),\n-\t    macro.payload.custom_derive);\n-\t  break;\n-\tcase ProcMacro::ATTR:\n-\t  rust_debug (\"Found one attribute proc macro.\");\n-\t  mappings->insert_attribute_proc_macro (\n-\t    std::make_pair (extern_crate, macro.payload.attribute.name),\n-\t    macro.payload.attribute);\n-\t  break;\n-\tcase ProcMacro::BANG:\n-\t  rust_debug (\"Found one bang proc macro.\");\n-\t  mappings->insert_bang_proc_macro (\n-\t    std::make_pair (extern_crate, macro.payload.bang.name),\n-\t    macro.payload.bang);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-}\n-\n } // namespace Rust"}, {"sha": "7e9d7ecb609eab8b35a119613ba8d9c159d0f762", "filename": "gcc/rust/expand/rust-proc-macro.h", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Fexpand%2Frust-proc-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-proc-macro.h?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -17,97 +17,17 @@\n #ifndef RUST_PROC_MACRO_H\n #define RUST_PROC_MACRO_H\n \n-#include <string>\n-#include \"rust-hir-map.h\"\n-#include \"rust-name-resolver.h\"\n-#include \"rust-session-manager.h\"\n-#include \"rust-ast.h\"\n-#include \"rust-ast-collector.h\"\n-#include \"rust-token-converter.h\"\n #include \"libproc_macro/proc_macro.h\"\n \n namespace Rust {\n-\n /**\n- * Load a procedural macro library and return a pointer to it's entrypoint.\n+ * Load a procedural macro library and collect its entrypoints.\n  *\n  * @param The path to the shared object file to load.\n  */\n const std::vector<ProcMacro::Procmacro>\n load_macros (std::string path);\n \n-class ProcMacroExpander\n-{\n-public:\n-  ProcMacroExpander (Session &session)\n-    : session (session), has_changed_flag (false),\n-      resolver (Resolver::Resolver::get ()),\n-      mappings (Analysis::Mappings::get ())\n-\n-  {}\n-\n-  ~ProcMacroExpander () = default;\n-\n-  void import_proc_macros (std::string extern_crate);\n-\n-  template <typename T>\n-  void expand_derive_proc_macro (T &item, std::string &trait_name)\n-  {}\n-\n-  template <typename T>\n-  void expand_bang_proc_macro (T &item, AST::SimplePath &path)\n-  {}\n-\n-  template <typename T>\n-  void expand_attribute_proc_macro (T &item, AST::SimplePath &path)\n-  {\n-    ProcMacro::Attribute macro;\n-\n-    std::string crate = path.get_segments ()[0].get_segment_name ();\n-    std::string name = path.get_segments ()[1].get_segment_name ();\n-    if (!mappings->lookup_attribute_proc_macro (std::make_pair (crate, name),\n-\t\t\t\t\t\tmacro))\n-      {\n-\t// FIXME: Resolve this path segment instead of taking it directly.\n-\timport_proc_macros (crate);\n-      }\n-\n-    if (!mappings->lookup_attribute_proc_macro (std::make_pair (crate, name),\n-\t\t\t\t\t\tmacro))\n-      {\n-\trust_error_at (Location (), \"procedural macro %s not found\",\n-\t\t       name.c_str ());\n-\trust_assert (false);\n-      }\n-    // FIXME: Attach result back to the ast\n-    std::vector<TokenPtr> tokens;\n-    AST::TokenCollector collector (tokens);\n-\n-    collector.visit (item);\n-\n-    std::vector<const_TokenPtr> vec;\n-    for (auto i : collector.collect_tokens ())\n-      {\n-\tvec.push_back (std::const_pointer_cast<Token> (i));\n-      }\n-\n-    // FIXME: Handle attributes\n-    macro.macro (ProcMacro::TokenStream::make_tokenstream (), convert (vec));\n-  }\n-\n-  bool has_changed () const { return has_changed_flag; }\n-\n-  void reset_changed_state () { has_changed_flag = false; }\n-\n-private:\n-  Session &session;\n-  bool has_changed_flag;\n-\n-public:\n-  Resolver::Resolver *resolver;\n-  Analysis::Mappings *mappings;\n-};\n-\n } // namespace Rust\n \n #endif /* ! RUST_PROC_MACRO_H */"}, {"sha": "17f8465356b69eaab93d4a905ba0cee6abd4e4be", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcec13b136cc8cb3eb58b80dd53af885ba3c998/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=3fcec13b136cc8cb3eb58b80dd53af885ba3c998", "patch": "@@ -867,13 +867,12 @@ Session::expansion (AST::Crate &crate)\n   /* expand by calling cxtctxt object's monotonic_expander's expand_crate\n    * method. */\n   MacroExpander expander (crate, cfg, *this);\n-  ProcMacroExpander proc_expander (*this);\n \n   while (!fixed_point_reached && iterations < cfg.recursion_limit)\n     {\n       CfgStrip ().go (crate);\n       Resolver::EarlyNameResolver ().go (crate);\n-      ExpandVisitor (expander, proc_expander).go (crate);\n+      ExpandVisitor (expander).go (crate);\n \n       fixed_point_reached = !expander.has_changed ();\n       expander.reset_changed_state ();"}]}