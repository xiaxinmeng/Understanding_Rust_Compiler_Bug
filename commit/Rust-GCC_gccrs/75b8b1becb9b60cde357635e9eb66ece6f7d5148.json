{"sha": "75b8b1becb9b60cde357635e9eb66ece6f7d5148", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzViOGIxYmVjYjliNjBjZGUzNTc2MzVlOWViNjZlY2U2ZjdkNTE0OA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2006-03-23T23:15:46Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2006-03-23T23:15:46Z"}, "message": "ffitarget.h (enum ffi_abi): Add FFI_LINUX.\n\n\t* src/powerpc/ffitarget.h (enum ffi_abi): Add FFI_LINUX.  Default\n\tfor 32-bit using IBM extended double format.  Fix FFI_LAST_ABI.\n\t* src/powerpc/ffi.c (ffi_prep_args_SYSV): Handle linux variant of\n\tFFI_TYPE_LONGDOUBLE.\n\t(ffi_prep_args64): Assert using IBM extended double.\n\t(ffi_prep_cif_machdep): Don't munge FFI_TYPE_LONGDOUBLE type.\n\tHandle FFI_LINUX FFI_TYPE_LONGDOUBLE return and args.\n\t(ffi_call): Handle FFI_LINUX.\n\t(ffi_closure_helper_SYSV): Non FFI_LINUX long double return needs\n\tgpr3 return pointer as for struct return.  Handle FFI_LINUX\n\tFFI_TYPE_LONGDOUBLE return and args.  Don't increment \"nf\"\n\tunnecessarily.\n\t* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Load both f1 and f2\n\tfor FFI_TYPE_LONGDOUBLE.  Move epilogue insns into case table.\n\tDon't use r6 as pointer to results, instead use sp offset.  Don't\n\tmake a special call to load lr with case table address, instead\n\tuse offset from previous call.\n\t* src/powerpc/sysv.S (ffi_call_SYSV): Save long double return.\n\t* src/powerpc/linux64.S (ffi_call_LINUX64): Simplify long double\n\treturn.\n\nFrom-SVN: r112340", "tree": {"sha": "4ab557369299e8f713970f1befc75244eeb8c26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab557369299e8f713970f1befc75244eeb8c26a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75b8b1becb9b60cde357635e9eb66ece6f7d5148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b8b1becb9b60cde357635e9eb66ece6f7d5148", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b8b1becb9b60cde357635e9eb66ece6f7d5148", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b8b1becb9b60cde357635e9eb66ece6f7d5148/comments", "author": null, "committer": null, "parents": [{"sha": "5b314bb3ef9460b06abf33d911e1e361c2e37197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b314bb3ef9460b06abf33d911e1e361c2e37197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b314bb3ef9460b06abf33d911e1e361c2e37197"}], "stats": {"total": 382, "additions": 219, "deletions": 163}, "files": [{"sha": "1d8b23899dd9e37079a17edb0510fd72e22355a9", "filename": "libffi/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=75b8b1becb9b60cde357635e9eb66ece6f7d5148", "patch": "@@ -1,3 +1,26 @@\n+2006-03-24  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* src/powerpc/ffitarget.h (enum ffi_abi): Add FFI_LINUX.  Default\n+\tfor 32-bit using IBM extended double format.  Fix FFI_LAST_ABI.\n+\t* src/powerpc/ffi.c (ffi_prep_args_SYSV): Handle linux variant of\n+\tFFI_TYPE_LONGDOUBLE.\n+\t(ffi_prep_args64): Assert using IBM extended double.\n+\t(ffi_prep_cif_machdep): Don't munge FFI_TYPE_LONGDOUBLE type.\n+\tHandle FFI_LINUX FFI_TYPE_LONGDOUBLE return and args.\n+\t(ffi_call): Handle FFI_LINUX.\n+\t(ffi_closure_helper_SYSV): Non FFI_LINUX long double return needs\n+\tgpr3 return pointer as for struct return.  Handle FFI_LINUX\n+\tFFI_TYPE_LONGDOUBLE return and args.  Don't increment \"nf\"\n+\tunnecessarily.\n+\t* src/powerpc/ppc_closure.S (ffi_closure_SYSV): Load both f1 and f2\n+\tfor FFI_TYPE_LONGDOUBLE.  Move epilogue insns into case table.\n+\tDon't use r6 as pointer to results, instead use sp offset.  Don't\n+\tmake a special call to load lr with case table address, instead\n+\tuse offset from previous call.\n+\t* src/powerpc/sysv.S (ffi_call_SYSV): Save long double return.\n+\t* src/powerpc/linux64.S (ffi_call_LINUX64): Simplify long double\n+\treturn.\n+\n 2006-03-15  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* src/sh64/ffi.c (ffi_prep_cif_machdep): Handle float arguments"}, {"sha": "39460d1b05a5362acf4caa26947672953de9309f", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 96, "deletions": 27, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=75b8b1becb9b60cde357635e9eb66ece6f7d5148", "patch": "@@ -197,6 +197,38 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if (ecif->cif->abi != FFI_LINUX)\n+\t    goto do_struct;\n+\t  double_tmp = (*p_argv.d)[0];\n+\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n+\t    {\n+\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n+\t\t  && intarg_count % 2 != 0)\n+\t\t{\n+\t\t  intarg_count++;\n+\t\t  next_arg.u++;\n+\t\t}\n+\t      *next_arg.d = double_tmp;\n+\t      next_arg.u += 2;\n+\t      double_tmp = (*p_argv.d)[1];\n+\t      *next_arg.d = double_tmp;\n+\t      next_arg.u += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      *fpr_base.d++ = double_tmp;\n+\t      double_tmp = (*p_argv.d)[1];\n+\t      *fpr_base.d++ = double_tmp;\n+\t    }\n+\n+\t  fparg_count += 2;\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+#endif\n+\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)\n@@ -232,7 +264,7 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \n \tcase FFI_TYPE_STRUCT:\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n+\tdo_struct:\n #endif\n \t  struct_copy_size = ((*ptr)->size + 15) & ~0xF;\n \t  copy_space.c -= struct_copy_size;\n@@ -433,6 +465,7 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n \t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n+\t  FFI_ASSERT (__LDBL_MANT_DIG__ == 106);\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n #endif\n@@ -536,11 +569,6 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n       /* Space for the mandatory parm save area and general registers.  */\n       bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-      if (type == FFI_TYPE_LONGDOUBLE)\n-\ttype = FFI_TYPE_DOUBLE;\n-#endif\n     }\n \n   /* Return value handling.  The rules for SYSV are as follows:\n@@ -549,14 +577,24 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n      - 64-bit integer values and structures between 5 and 8 bytes are returned\n      in gpr3 and gpr4;\n      - Single/double FP values are returned in fpr1;\n-     - Larger structures and long double (if not equivalent to double) values\n-     are allocated space and a pointer is passed as the first argument.\n+     - Larger structures are allocated space and a pointer is passed as\n+     the first argument.\n+     - long doubles (if not equivalent to double) are returned in\n+     fpr1,fpr2 for Linux and as for large structs for SysV.\n      For LINUX64:\n      - integer values in gpr3;\n      - Structures/Unions by reference;\n      - Single/double FP values in fpr1, long double in fpr1,fpr2.  */\n   switch (type)\n     {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+    case FFI_TYPE_LONGDOUBLE:\n+      if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64)\n+\tgoto byref;\n+\n+      flags |= FLAG_RETURNS_128BITS;\n+      /* Fall through.  */\n+#endif\n     case FFI_TYPE_DOUBLE:\n       flags |= FLAG_RETURNS_64BITS;\n       /* Fall through.  */\n@@ -598,15 +636,8 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t\t}\n \t    }\n \t}\n-      /* else fall through.  */\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-    case FFI_TYPE_LONGDOUBLE:\n-      if (type == FFI_TYPE_LONGDOUBLE && cif->abi == FFI_LINUX64)\n-\t{\n-\t  flags |= FLAG_RETURNS_128BITS;\n-\t  flags |= FLAG_RETURNS_FP;\n-\t  break;\n-\t}\n+    byref:\n #endif\n       intarg_count++;\n       flags |= FLAG_RETVAL_REFERENCE;\n@@ -635,6 +666,13 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t    /* floating singles are not 8-aligned on stack */\n \t    break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t  case FFI_TYPE_LONGDOUBLE:\n+\t    if (cif->abi != FFI_LINUX)\n+\t      goto do_struct;\n+\t    fparg_count++;\n+\t    /* Fall thru */\n+#endif\n \t  case FFI_TYPE_DOUBLE:\n \t    fparg_count++;\n \t    /* If this FP arg is going on the stack, it must be\n@@ -664,7 +702,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n \t  case FFI_TYPE_STRUCT:\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  case FFI_TYPE_LONGDOUBLE:\n+\t  do_struct:\n #endif\n \t    /* We must allocate space for a copy of these to enforce\n \t       pass-by-value.  Pad the space up to a multiple of 16\n@@ -793,6 +831,7 @@ ffi_call(/*@dependent@*/ ffi_cif *cif,\n #ifndef POWERPC64\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n+    case FFI_LINUX:\n       /*@-usedef@*/\n       ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n@@ -920,14 +959,17 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n      For FFI_SYSV the result is passed in r3/r4 if the struct size is less\n      or equal 8 bytes.  */\n \n-  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+  if ((cif->rtype->type == FFI_TYPE_STRUCT\n+       && !((cif->abi == FFI_SYSV) && (size <= 8)))\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+      || (cif->rtype->type == FFI_TYPE_LONGDOUBLE\n+\t  && cif->abi != FFI_LINUX)\n+#endif\n+      )\n     {\n-      if (!((cif->abi == FFI_SYSV) && (size <= 8)))\n-\t{\n-\t  rvalue = (void *) *pgr;\n-\t  ng++;\n-\t  pgr++;\n-\t}\n+      rvalue = (void *) *pgr;\n+      ng++;\n+      pgr++;\n     }\n \n   i = 0;\n@@ -989,6 +1031,9 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tdo_struct:\n+#endif\n \t  /* Structs are passed by reference. The address will appear in a\n \t     gpr if it is one of the first 8 arguments.  */\n \t  if (ng < 8)\n@@ -1060,7 +1105,6 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t       * naughty thing to do but...\n \t       */\n \t      avalue[i] = pst;\n-\t      nf++;\n \t      pst += 1;\n \t    }\n \t  break;\n@@ -1080,11 +1124,32 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t      if (((long) pst) & 4)\n \t\tpst++;\n \t      avalue[i] = pst;\n-\t      nf++;\n \t      pst += 2;\n \t    }\n \t  break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if (cif->abi != FFI_LINUX)\n+\t    goto do_struct;\n+\n+\t  if (nf < 7)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr += 2;\n+\t      nf += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (((long) pst) & 4)\n+\t\tpst++;\n+\t      avalue[i] = pst;\n+\t      pst += 4;\n+\t      nf = 8;\n+\t    }\n+\t  break;\n+#endif\n+\n \tdefault:\n \t  FFI_ASSERT (0);\n \t}\n@@ -1101,8 +1166,12 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n   if (cif->abi == FFI_SYSV && cif->rtype->type == FFI_TYPE_STRUCT\n       && size <= 8)\n     return FFI_SYSV_TYPE_SMALL_STRUCT + size;\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+  else if (cif->rtype->type == FFI_TYPE_LONGDOUBLE\n+\t   && cif->abi != FFI_LINUX)\n+    return FFI_TYPE_STRUCT;\n+#endif\n   return cif->rtype->type;\n-\n }\n \n int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,"}, {"sha": "e7f62950371aa8454e976b0b08919e790b1f07f5", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=75b8b1becb9b60cde357635e9eb66ece6f7d5148", "patch": "@@ -43,10 +43,15 @@ typedef enum ffi_abi {\n   FFI_SYSV,\n   FFI_GCC_SYSV,\n   FFI_LINUX64,\n+  FFI_LINUX,\n # ifdef POWERPC64\n   FFI_DEFAULT_ABI = FFI_LINUX64,\n # else\n+#  if __LDBL_MANT_DIG__ == 106\n+  FFI_DEFAULT_ABI = FFI_LINUX,\n+#  else\n   FFI_DEFAULT_ABI = FFI_GCC_SYSV,\n+#  endif\n # endif\n #endif\n \n@@ -69,7 +74,7 @@ typedef enum ffi_abi {\n   FFI_DEFAULT_ABI = FFI_SYSV,\n #endif\n \n-  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+  FFI_LAST_ABI\n } ffi_abi;\n #endif\n "}, {"sha": "d72912da1edf8f492c6d0bab2834f2d07d8ae585", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=75b8b1becb9b60cde357635e9eb66ece6f7d5148", "patch": "@@ -120,12 +120,9 @@ ffi_call_LINUX64:\n \tblr\n \n .Lfp_return_value:\n-\tbt\t27, .Lfd_return_value\n \tbf\t28, .Lfloat_return_value\n \tstfd\t%f1, 0(%r30)\n-\tb\t.Ldone_return_value\n-.Lfd_return_value:\n-\tstfd\t%f1, 0(%r30)\n+\tbf\t27, .Ldone_return_value\n \tstfd\t%f2, 8(%r30)\n \tb\t.Ldone_return_value\n .Lfloat_return_value:"}, {"sha": "356a0e326208b9edf80396a62d1d463f9cc4c7fd", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 91, "deletions": 131, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=75b8b1becb9b60cde357635e9eb66ece6f7d5148", "patch": "@@ -58,218 +58,178 @@ ENTRY(ffi_closure_SYSV)\n \n \t# make the call\n \tbl ffi_closure_helper_SYSV@local\n-\n+.Lret:\n \t# now r3 contains the return type\n \t# so use it to look up in a table\n \t# so we know how to deal with each type\n \n \t# look up the proper starting point in table\n \t# by using return type as offset\n-\taddi %r6,%r1,112   # get pointer to results area\n-\tbl .Lget_ret_type0_addr # get pointer to .Lret_type0 into LR\n-\tmflr %r4           # move to r4\n-\tslwi %r3,%r3,4     # now multiply return type by 16\n-\tadd %r3,%r3,%r4    # add contents of table to table address\n+\n+\tmflr %r4\t\t# move address of .Lret to r4\n+\tslwi %r3,%r3,4\t\t# now multiply return type by 16\n+\taddi %r4, %r4, .Lret_type0 - .Lret\n+\tlwz %r0,148(%r1)\n+\tadd %r3,%r3,%r4\t\t# add contents of table to table address\n \tmtctr %r3\n-\tbctr               # jump to it\n+\tbctr\t\t\t# jump to it\n .LFE1:\n \n # Each of the ret_typeX code fragments has to be exactly 16 bytes long\n # (4 instructions). For cache effectiveness we align to a 16 byte boundary\n # first.\n \t.align 4\n-\n-\tnop\n-\tnop\n-\tnop\n-.Lget_ret_type0_addr:\n-\tblrl\n-\n # case FFI_TYPE_VOID\n .Lret_type0:\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \tnop\n \n # case FFI_TYPE_INT\n-.Lret_type1:\n-\tlwz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlwz %r3,112+0(%r1)\n+\tmtlr %r0\n+.Lfinish:\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_FLOAT\n-.Lret_type2:\n-\tlfs %f1,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlfs %f1,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_DOUBLE\n-.Lret_type3:\n-\tlfd %f1,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlfd %f1,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_LONGDOUBLE\n-.Lret_type4:\n-\tlfd %f1,0(%r6)\n+\tlfd %f1,112+0(%r1)\n+\tlfd %f2,112+8(%r1)\n+\tmtlr %r0\n \tb .Lfinish\n-\tnop\n-\tnop\n \n # case FFI_TYPE_UINT8\n-.Lret_type5:\n-\tlbz %r3,3(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlbz %r3,112+3(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_SINT8\n-.Lret_type6:\n-\tlbz %r3,3(%r6)\n+\tlbz %r3,112+3(%r1)\n \textsb %r3,%r3\n+\tmtlr %r0\n \tb .Lfinish\n-\tnop\n \n # case FFI_TYPE_UINT16\n-.Lret_type7:\n-\tlhz %r3,2(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlhz %r3,112+2(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_SINT16\n-.Lret_type8:\n-\tlha %r3,2(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlha %r3,112+2(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_UINT32\n-.Lret_type9:\n-\tlwz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlwz %r3,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_SINT32\n-.Lret_type10:\n-\tlwz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlwz %r3,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_TYPE_UINT64\n-.Lret_type11:\n-\tlwz %r3,0(%r6)\n-\tlwz %r4,4(%r6)\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n+\tmtlr %r0\n \tb .Lfinish\n-\tnop\n \n # case FFI_TYPE_SINT64\n-.Lret_type12:\n-\tlwz %r3,0(%r6)\n-\tlwz %r4,4(%r6)\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n+\tmtlr %r0\n \tb .Lfinish\n-\tnop\n \n # case FFI_TYPE_STRUCT\n-.Lret_type13:\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \tnop\n \n # case FFI_TYPE_POINTER\n-.Lret_type14:\n-\tlwz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlwz %r3,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # The return types below are only used when the ABI type is FFI_SYSV.\n # case FFI_SYSV_TYPE_SMALL_STRUCT + 1. One byte struct.\n-.Lret_type15:\n-# fall through.\n-\tlbz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlbz %r3,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 2. Two byte struct.\n-.Lret_type16:\n-# fall through.\n-\tlhz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlhz %r3,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 3. Three byte struct.\n-.Lret_type17:\n-# fall through.\n-\tlwz %r3,0(%r6)\n+\tlwz %r3,112+0(%r1)\n \tsrwi %r3,%r3,8\n+\tmtlr %r0\n \tb .Lfinish\n-\tnop\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 4. Four byte struct.\n-.Lret_type18:\n-# this one handles the structs from above too.\n-\tlwz %r3,0(%r6)\n-\tb .Lfinish\n-\tnop\n-\tnop\n+\tlwz %r3,112+0(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 5. Five byte struct.\n-.Lret_type19:\n-# fall through.\n-\tlwz %r3,0(%r6)\n-\tlwz %r4,4(%r6)\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n \tli %r5,24\n \tb .Lstruct567\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 6. Six byte struct.\n-.Lret_type20:\n-# fall through.\n-\tlwz %r3,0(%r6)\n-\tlwz %r4,4(%r6)\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n \tli %r5,16\n \tb .Lstruct567\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 7. Seven byte struct.\n-.Lret_type21:\n-# fall through.\n-\tlwz %r3,0(%r6)\n-\tlwz %r4,4(%r6)\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n \tli %r5,8\n \tb .Lstruct567\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 8. Eight byte struct.\n-.Lret_type22:\n-# this one handles the above unhandled structs.\n-\tlwz %r3,0(%r6)\n-\tlwz %r4,4(%r6)\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n+\tmtlr %r0\n \tb .Lfinish\n-\tnop\n \n-# case done\n-.Lfinish:\n-\n-\tlwz %r0,148(%r1)\n+.Lstruct567:\n+\tsubfic %r6,%r5,32\n+\tsrw %r4,%r4,%r5\n+\tslw %r6,%r3,%r6\n+\tsrw %r3,%r3,%r5\n+\tor %r4,%r6,%r4\n \tmtlr %r0\n \taddi %r1,%r1,144\n \tblr\n \n-.Lstruct567:\n-\tsubfic %r0,%r5,32\n-\tsrw %r4,%r4,%r5\n-\tslw %r0,%r3,%r0\n-\tsrw %r3,%r3,%r5\n-\tor %r4,%r0,%r4\n-\tb .Lfinish\n END(ffi_closure_SYSV)\n \n \t.section\t\".eh_frame\",EH_FRAME_FLAGS,@progbits"}, {"sha": "9a9a109d1ae9ad17fc3473071cbba350846fc1f2", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b8b1becb9b60cde357635e9eb66ece6f7d5148/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=75b8b1becb9b60cde357635e9eb66ece6f7d5148", "patch": "@@ -121,6 +121,8 @@ L(done_return_value):\n L(fp_return_value):\n \tbf\t28,L(float_return_value)\n \tstfd\t%f1,0(%r30)\n+\tbf\t27,L(done_return_value)\n+\tstfd\t%f2,8(%r30)\n \tb\tL(done_return_value)\n L(float_return_value):\n \tstfs\t%f1,0(%r30)"}]}