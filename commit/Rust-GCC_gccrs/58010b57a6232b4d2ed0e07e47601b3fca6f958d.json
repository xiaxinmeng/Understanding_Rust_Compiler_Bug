{"sha": "58010b57a6232b4d2ed0e07e47601b3fca6f958d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgwMTBiNTdhNjIzMmI0ZDJlZDBlMDdlNDc2MDFiM2ZjYTZmOTU4ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-16T03:10:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-16T03:10:12Z"}, "message": "class.c (handle_using_decl): Get TYPE_FIELDS and TYPE_METHODS out of the class...\n\n\t* class.c (handle_using_decl): Get TYPE_FIELDS and TYPE_METHODS\n\tout of the class, rather than taking them as parameters.\n\t(build_vbase_pointer_fields): Move here from tree.c.\n\t(build_vtbl_or_vbase_field): New function.\n\t(check_methods): Likewise.\n\t(remove_zero_width_bitfields): Likewise.\n\t(add_virtual_function): Use tree_cons instead of temp_tree_cons.\n\t(delete_duplicate_fields_1): Tidy.  Don't delete duplicate\n\tUSING_DECLs here.\n\t(finish_struct_methods): Handle the case where there are no\n\tmethods here.\n\t(get_basefndecls): Use tree_cons instead of temp_tree_cons.\n\t(check_field_decls): Call delete_duplicate_fields here.\n\t(finish_struct_1): Tidy.  Use check_methods and\n\tremove_zero_width_bitfields.\n\t* cp-tree.h (build_vbase_pointer_fields): Remove.\n\t* decl.c (grokdeclarator): Use tree_cons instead of\n\ttemp_tree_cons.\n\t* decl2.c (qualified_lookup_using_namespace): Use tree_cons\n\tinstead of temp_tree_cons.\n\t* lex.c (cons_up_default_function): Remove dead code.\n\t* method.c (fixup_pending_inline): New function, split out from\t...\n\t(do_inline_function_hair): ... here.\n\t* tree.c (build_vbase_pointer_fields): Remove.\n\nFrom-SVN: r30966", "tree": {"sha": "e7ba7a8f8231c8333666fa1e7664d71d2aeda976", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7ba7a8f8231c8333666fa1e7664d71d2aeda976"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58010b57a6232b4d2ed0e07e47601b3fca6f958d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58010b57a6232b4d2ed0e07e47601b3fca6f958d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58010b57a6232b4d2ed0e07e47601b3fca6f958d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58010b57a6232b4d2ed0e07e47601b3fca6f958d/comments", "author": null, "committer": null, "parents": [{"sha": "5afb79e7f856b5a9b4414ee34940b568aa77abe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5afb79e7f856b5a9b4414ee34940b568aa77abe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5afb79e7f856b5a9b4414ee34940b568aa77abe8"}], "stats": {"total": 645, "additions": 348, "deletions": 297}, "files": [{"sha": "ff70df40b346ac4067b8a1f36037ce86ae556b61", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -1,3 +1,30 @@\n+1999-12-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (handle_using_decl): Get TYPE_FIELDS and TYPE_METHODS\n+\tout of the class, rather than taking them as parameters.\n+\t(build_vbase_pointer_fields): Move here from tree.c.\n+\t(build_vtbl_or_vbase_field): New function.\n+\t(check_methods): Likewise.\n+\t(remove_zero_width_bitfields): Likewise.\n+\t(add_virtual_function): Use tree_cons instead of temp_tree_cons.\n+\t(delete_duplicate_fields_1): Tidy.  Don't delete duplicate\n+\tUSING_DECLs here.\n+\t(finish_struct_methods): Handle the case where there are no\n+\tmethods here.\n+\t(get_basefndecls): Use tree_cons instead of temp_tree_cons.\n+\t(check_field_decls): Call delete_duplicate_fields here.\n+\t(finish_struct_1): Tidy.  Use check_methods and\n+\tremove_zero_width_bitfields.\n+\t* cp-tree.h (build_vbase_pointer_fields): Remove.\n+\t* decl.c (grokdeclarator): Use tree_cons instead of\n+\ttemp_tree_cons.\n+\t* decl2.c (qualified_lookup_using_namespace): Use tree_cons\n+\tinstead of temp_tree_cons.\n+\t* lex.c (cons_up_default_function): Remove dead code.\n+\t* method.c (fixup_pending_inline): New function, split out from\t...\n+\t(do_inline_function_hair): ... here.\n+\t* tree.c (build_vbase_pointer_fields): Remove.\n+\t\n 1999-12-15  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* tree.c (walk_tree): Walk operand subtrees in forward order."}, {"sha": "7bd62dac5c3a815f394fcd69ff48346c49dbc396", "filename": "gcc/cp/class.c", "status": "modified", "additions": 318, "deletions": 209, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -94,7 +94,7 @@ static tree delete_duplicate_fields_1 PROTO((tree, tree));\n static void delete_duplicate_fields PROTO((tree));\n static void finish_struct_bits PROTO((tree, int));\n static int alter_access PROTO((tree, tree, tree, tree));\n-static void handle_using_decl PROTO((tree, tree, tree, tree));\n+static void handle_using_decl PROTO((tree, tree));\n static int overrides PROTO((tree, tree));\n static int strictly_overrides PROTO((tree, tree));\n static void merge_overrides PROTO((tree, tree, int, tree));\n@@ -125,6 +125,10 @@ static void check_bitfield_decl PROTO((tree));\n static void check_field_decl PROTO((tree, tree, int *, int *, int *, int *));\n static tree* check_field_decls PROTO((tree, tree *, int *, int *, int *, \n \t\t\t\t      int *));\n+static tree build_vbase_pointer_fields PROTO((tree, int *));\n+static tree build_vtbl_or_vbase_field PROTO((tree, tree, tree, tree, int *));\n+static void check_methods PROTO((tree));\n+static void remove_zero_width_bit_fields PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -1049,9 +1053,9 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n     {\n       /* Need an entry in some other virtual function table.\n          Deal with this after we have laid out our virtual base classes.  */\n-      pending_hard_virtuals = temp_tree_cons (NULL_TREE, \n-\t\t\t\t\t      fndecl, \n-\t\t\t\t\t      pending_hard_virtuals);\n+      pending_hard_virtuals = tree_cons (NULL_TREE, \n+\t\t\t\t\t fndecl, \n+\t\t\t\t\t pending_hard_virtuals);\n     }\n   *pv = pending_virtuals;\n   *phv = pending_hard_virtuals;\n@@ -1289,43 +1293,46 @@ delete_duplicate_fields_1 (field, fields)\n \t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n \t\t}\n \t    }\n-\t  else\n+\t  else if (TREE_CODE (field) == USING_DECL)\n+\t    /* A using declaration may is allowed to appear more than\n+\t       once.  We'll prune these from the field list later, and\n+\t       handle_using_decl will complain about invalid multiple\n+\t       uses.  */\n+\t    ;\n+\t  else if (DECL_NAME (field) == DECL_NAME (x))\n \t    {\n-\t      if (DECL_NAME (field) == DECL_NAME (x))\n+\t      if (TREE_CODE (field) == CONST_DECL\n+\t\t  && TREE_CODE (x) == CONST_DECL)\n+\t\tcp_error_at (\"duplicate enum value `%D'\", x);\n+\t      else if (TREE_CODE (field) == CONST_DECL\n+\t\t       || TREE_CODE (x) == CONST_DECL)\n+\t\tcp_error_at (\"duplicate field `%D' (as enum and non-enum)\",\n+\t\t\t     x);\n+\t      else if (DECL_DECLARES_TYPE_P (field)\n+\t\t       && DECL_DECLARES_TYPE_P (x))\n \t\t{\n-\t\t  if (TREE_CODE (field) == CONST_DECL\n-\t\t      && TREE_CODE (x) == CONST_DECL)\n-\t\t    cp_error_at (\"duplicate enum value `%D'\", x);\n-\t\t  else if (TREE_CODE (field) == CONST_DECL\n-\t\t\t   || TREE_CODE (x) == CONST_DECL)\n-\t\t    cp_error_at (\"duplicate field `%D' (as enum and non-enum)\",\n-\t\t\t\tx);\n-\t\t  else if (DECL_DECLARES_TYPE_P (field)\n-\t\t\t   && DECL_DECLARES_TYPE_P (x))\n-\t\t    {\n-\t\t      if (same_type_p (TREE_TYPE (field), TREE_TYPE (x)))\n-\t\t\tcontinue;\n-\t\t      cp_error_at (\"duplicate nested type `%D'\", x);\n-\t\t    }\n-\t\t  else if (DECL_DECLARES_TYPE_P (field)\n-\t\t\t   || DECL_DECLARES_TYPE_P (x))\n-\t\t    {\n-\t\t      /* Hide tag decls.  */\n-\t\t      if ((TREE_CODE (field) == TYPE_DECL\n-\t\t\t   && DECL_ARTIFICIAL (field))\n-\t\t\t  || (TREE_CODE (x) == TYPE_DECL\n-\t\t\t      && DECL_ARTIFICIAL (x)))\n-\t\t\tcontinue;\n-\t\t      cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n-\t\t\t\t   x);\n-\t\t    }\n-\t\t  else\n-\t\t    cp_error_at (\"duplicate member `%D'\", x);\n-\t\t  if (prev == 0)\n-\t\t    fields = TREE_CHAIN (fields);\n-\t\t  else\n-\t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n+\t\t  if (same_type_p (TREE_TYPE (field), TREE_TYPE (x)))\n+\t\t    continue;\n+\t\t  cp_error_at (\"duplicate nested type `%D'\", x);\n \t\t}\n+\t      else if (DECL_DECLARES_TYPE_P (field)\n+\t\t       || DECL_DECLARES_TYPE_P (x))\n+\t\t{\n+\t\t  /* Hide tag decls.  */\n+\t\t  if ((TREE_CODE (field) == TYPE_DECL\n+\t\t       && DECL_ARTIFICIAL (field))\n+\t\t      || (TREE_CODE (x) == TYPE_DECL\n+\t\t\t  && DECL_ARTIFICIAL (x)))\n+\t\t    continue;\n+\t\t  cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n+\t\t\t       x);\n+\t\t}\n+\t      else\n+\t\tcp_error_at (\"duplicate member `%D'\", x);\n+\t      if (prev == 0)\n+\t\tfields = TREE_CHAIN (fields);\n+\t      else\n+\t\tTREE_CHAIN (prev) = TREE_CHAIN (x);\n \t    }\n \t}\n     }\n@@ -1379,15 +1386,12 @@ alter_access (t, binfo, fdecl, access)\n   return 0;\n }\n \n-/* Process the USING_DECL, which is a member of T.  The METHOD_VEC, if\n-   non-NULL, is the methods of T.  The FIELDS are the fields of T.  */\n+/* Process the USING_DECL, which is a member of T.  */\n \n static void\n-handle_using_decl (using_decl, t, method_vec, fields)\n+handle_using_decl (using_decl, t)\n      tree using_decl;\n      tree t;\n-     tree method_vec;\n-     tree fields;\n {\n   tree ctype = DECL_INITIAL (using_decl);\n   tree name = DECL_NAME (using_decl);\n@@ -1397,6 +1401,8 @@ handle_using_decl (using_decl, t, method_vec, fields)\n     : access_public_node;\n   tree fdecl, binfo;\n   tree flist = NULL_TREE;\n+  tree fields = TYPE_FIELDS (t);\n+  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n   tree tmp;\n   int i;\n   int n_methods;\n@@ -1989,9 +1995,23 @@ finish_struct_methods (t)\n      tree t;\n {\n   tree fn_fields;\n-  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n+  tree method_vec;\n   tree ctor_name = constructor_name (t);\n-  int slot, len = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n+  int slot, len;\n+\n+  if (!TYPE_METHODS (t))\n+    {\n+      /* Clear these for safety; perhaps some parsing error could set\n+\t these incorrectly.  */\n+      TYPE_HAS_CONSTRUCTOR (t) = 0;\n+      TYPE_HAS_DESTRUCTOR (t) = 0;\n+      CLASSTYPE_METHOD_VEC (t) = NULL_TREE;\n+      return;\n+    }\n+\n+  my_friendly_assert (method_vec != NULL_TREE, 19991215);\n+  method_vec = CLASSTYPE_METHOD_VEC (t);\n+  len = TREE_VEC_LENGTH (method_vec);\n \n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n      and the next few with type conversion operators (if any).  */\n@@ -2051,9 +2071,6 @@ finish_struct_methods (t)\n      no methods, then some public defaults are generated.  */\n   maybe_warn_about_overly_private_class (t);\n \n-  if (method_vec == NULL_TREE)\n-    return;\n-\n   /* Now sort the methods.  */\n   while (len > 2 && TREE_VEC_ELT (method_vec, len-1) == NULL_TREE)\n     len--;\n@@ -2812,7 +2829,7 @@ get_basefndecls (fndecl, t)\n       if (TREE_CODE (methods) == FUNCTION_DECL\n \t  && DECL_VINDEX (methods) != NULL_TREE\n \t  && DECL_NAME (fndecl) == DECL_NAME (methods))\n-\tbase_fndecls = temp_tree_cons (fndecl, methods, base_fndecls);\n+\tbase_fndecls = tree_cons (fndecl, methods, base_fndecls);\n \n       methods = TREE_CHAIN (methods);\n     }\n@@ -3386,6 +3403,9 @@ check_field_decls (t, access_decls, empty_p,\n   int has_pointers;\n   int any_default_members;\n \n+  /* First, delete any duplicate fields.  */\n+  delete_duplicate_fields (TYPE_FIELDS (t));\n+\n   /* Assume there are no access declarations.  */\n   *access_decls = NULL_TREE;\n   /* Assume this class has no pointer members.  */\n@@ -3594,6 +3614,192 @@ check_field_decls (t, access_decls, empty_p,\n   return field;\n }\n \n+/* Return a FIELD_DECL for a pointer-to-virtual-table or\n+   pointer-to-virtual-base.  The NAME, ASSEMBLER_NAME, and TYPE of the\n+   field are as indicated.  The CLASS_TYPE in which this field occurs\n+   is also indicated.  *EMPTY_P is set to a non-zero value by this\n+   function to indicate that a class containing this field is\n+   non-empty.  */\n+\n+static tree\n+build_vtbl_or_vbase_field (name, assembler_name, type, class_type, \n+\t\t\t   empty_p)\n+     tree name;\n+     tree assembler_name;\n+     tree type;\n+     tree class_type;\n+     int *empty_p;\n+{\n+  tree field;\n+\n+  /* This class is non-empty.  */\n+  *empty_p = 0;\n+\n+  /* Build the FIELD_DECL.  */\n+  field = build_lang_decl (FIELD_DECL, name, type);\n+  DECL_ASSEMBLER_NAME (field) = assembler_name;\n+  DECL_VIRTUAL_P (field) = 1;\n+  DECL_ARTIFICIAL (field) = 1;\n+  DECL_FIELD_CONTEXT (field) = class_type;\n+  DECL_CLASS_CONTEXT (field) = class_type;\n+  DECL_FCONTEXT (field) = class_type;\n+  DECL_SAVED_INSNS (field) = 0;\n+  DECL_FIELD_SIZE (field) = 0;\n+  DECL_ALIGN (field) = TYPE_ALIGN (type);\n+\n+  /* Return it.  */\n+  return field;\n+}\n+\n+/* Returns list of virtual base class pointers in a FIELD_DECL chain.  */\n+\n+static tree\n+build_vbase_pointer_fields (rec, empty_p)\n+     tree rec;\n+     int *empty_p;\n+{\n+  /* Chain to hold all the new FIELD_DECLs which point at virtual\n+     base classes.  */\n+  tree vbase_decls = NULL_TREE;\n+  tree binfos = TYPE_BINFO_BASETYPES (rec);\n+  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  tree decl;\n+  int i;\n+\n+  /* Handle basetypes almost like fields, but record their\n+     offsets differently.  */\n+\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      register tree basetype = BINFO_TYPE (base_binfo);\n+\n+      if (TYPE_SIZE (basetype) == 0)\n+\t/* This error is now reported in xref_tag, thus giving better\n+\t   location information.  */\n+\tcontinue;\n+\n+      /* All basetypes are recorded in the association list of the\n+\t derived type.  */\n+\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t{\n+\t  int j;\n+\t  const char *name;\n+\n+\t  /* The offset for a virtual base class is only used in computing\n+\t     virtual function tables and for initializing virtual base\n+\t     pointers.  It is built once `get_vbase_types' is called.  */\n+\n+\t  /* If this basetype can come from another vbase pointer\n+\t     without an additional indirection, we will share\n+\t     that pointer.  If an indirection is involved, we\n+\t     make our own pointer.  */\n+\t  for (j = 0; j < n_baseclasses; j++)\n+\t    {\n+\t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n+\t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n+\t\t  && binfo_member (basetype,\n+\t\t\t\t   CLASSTYPE_VBASECLASSES (BINFO_TYPE\n+\t\t\t\t\t\t\t   (other_base_binfo))\n+\t\t\t\t   ))\n+\t\tgoto got_it;\n+\t    }\n+\t  FORMAT_VBASE_NAME (name, basetype);\n+\t  decl = build_vtbl_or_vbase_field (get_identifier (name), \n+\t\t\t\t\t    get_identifier (VTABLE_BASE),\n+\t\t\t\t\t    build_pointer_type (basetype),\n+\t\t\t\t\t    rec,\n+\t\t\t\t\t    empty_p);\n+\t  BINFO_VPTR_FIELD (base_binfo) = decl;\n+\t  TREE_CHAIN (decl) = vbase_decls;\n+\t  vbase_decls = decl;\n+\t  *empty_p = 0;\n+\n+\tgot_it:\n+\t  /* The space this decl occupies has already been accounted for.  */\n+\t  ;\n+\t}\n+    }\n+\n+  return vbase_decls;\n+}\n+\n+/* Go through the TYPE_METHODS of T issuing any appropriate\n+   diagnostics, figuring out which methods override which other\n+   methods, and so forth.  Returns non-zero if this class has any\n+   virtual methods.  */\n+\n+static void\n+check_methods (t)\n+     tree t;\n+{\n+  tree x;\n+  int has_virtual;\n+\n+  /* Assume there are no virtual methods.  */\n+  has_virtual = 0;\n+\n+  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+    {\n+      GNU_xref_member (current_class_name, x);\n+\n+      /* If this was an evil function, don't keep it in class.  */\n+      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n+\tcontinue;\n+\n+      /* Do both of these, even though they're in the same union;\n+\t if the insn `r' member and the size `i' member are\n+\t different sizes, as on the alpha, the larger of the two\n+\t will end up with garbage in it.  */\n+      DECL_SAVED_INSNS (x) = 0;\n+      DECL_FIELD_SIZE (x) = 0;\n+\n+      check_for_override (x, t);\n+      if (DECL_ABSTRACT_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n+\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n+\n+      /* The name of the field is the original field name\n+\t Save this in auxiliary field for later overloading.  */\n+      if (DECL_VINDEX (x))\n+\t{\n+\t  has_virtual = 1;\n+\t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n+\t    CLASSTYPE_ABSTRACT_VIRTUALS (t)\n+\t      = tree_cons (NULL_TREE, x, CLASSTYPE_ABSTRACT_VIRTUALS (t));\n+\t}\n+    }\n+\n+  /* A class with virtual functions needs constructing because, if\n+     nothing else, the vtable pointer must be initialized.  */\n+  TYPE_HAS_COMPLEX_INIT_REF (t) |= has_virtual;\n+  TYPE_NEEDS_CONSTRUCTING (t) |= has_virtual;\n+  /* [dcl.init.aggr]\n+\n+     An aggregate is a ... class ... with ... no virtual functions.  */\n+  CLASSTYPE_NON_AGGREGATE (t) |= has_virtual;\n+}\n+\n+/* Remove all zero-width bit-fields from T.  */\n+\n+static void\n+remove_zero_width_bit_fields (t)\n+     tree t;\n+{\n+  tree *fieldsp;\n+\n+  fieldsp = &TYPE_FIELDS (t); \n+  while (*fieldsp)\n+    {\n+      if (TREE_CODE (*fieldsp) == FIELD_DECL\n+\t  && DECL_C_BIT_FIELD (*fieldsp) \n+\t  && DECL_INITIAL (*fieldsp))\n+\t*fieldsp = TREE_CHAIN (*fieldsp);\n+      else\n+\tfieldsp = &TREE_CHAIN (*fieldsp);\n+    }\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -3626,13 +3832,12 @@ finish_struct_1 (t)\n      tree t;\n {\n   tree fields;\n-  tree x, method_vec;\n+  tree x;\n   tree *next_field;\n   int has_virtual;\n   int max_has_virtual;\n   tree pending_virtuals = NULL_TREE;\n   tree pending_hard_virtuals = NULL_TREE;\n-  tree abstract_virtuals = NULL_TREE;\n   tree vfield;\n   tree vfields;\n   tree virtual_dtor;\n@@ -3646,7 +3851,6 @@ finish_struct_1 (t)\n   int first_vfn_base_index;\n \n   int n_baseclasses;\n-  int const_sans_init = 0;\n   tree access_decls;\n   int aggregate = 1;\n   int empty = 1;\n@@ -3670,17 +3874,7 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n-  /* Install struct as DECL_FIELD_CONTEXT of each field decl.\n-     Also process specified field sizes.\n-     Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.\n-     The specified size is found in the DECL_INITIAL.\n-     Store 0 there, except for \": 0\" fields (so we can find them\n-     and delete them, below).  */\n-\n-  if (TYPE_BINFO_BASETYPES (t))\n-    n_baseclasses = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (t));\n-  else\n-    n_baseclasses = 0;\n+  n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n   if (n_baseclasses > 0)\n     {\n@@ -3692,7 +3886,9 @@ finish_struct_1 (t)\n       has_virtual = base_info.has_virtual;\n       max_has_virtual = base_info.max_has_virtual;\n       vfield = base_info.vfield;\n+      TYPE_VFIELD (t) = vfield;\n       vfields = base_info.vfields;\n+      CLASSTYPE_VFIELDS (t) = vfields;\n       CLASSTYPE_RTTI (t) = base_info.rtti;\n       cant_have_default_ctor = base_info.cant_have_default_ctor;\n       cant_have_const_ctor = base_info.cant_have_const_ctor;\n@@ -3703,7 +3899,7 @@ finish_struct_1 (t)\n     {\n       first_vfn_base_index = -1;\n       has_virtual = 0;\n-      max_has_virtual = has_virtual;\n+      max_has_virtual = 0;\n       vfield = NULL_TREE;\n       vfields = NULL_TREE;\n       CLASSTYPE_RTTI (t) = NULL_TREE;\n@@ -3712,75 +3908,42 @@ finish_struct_1 (t)\n       no_const_asn_ref = 0;\n     }\n \n-  /* The three of these are approximations which may later be\n-     modified.  Needed at this point to make add_virtual_function\n-     and modify_vtable_entries work.  */\n-  CLASSTYPE_VFIELDS (t) = vfields;\n-  TYPE_VFIELD (t) = vfield;\n-\n-  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n-    {\n-      GNU_xref_member (current_class_name, x);\n+  /* Check all the data member declarations.  */\n+  next_field = check_field_decls (t, &access_decls, &empty,\n+\t\t\t\t  &cant_have_default_ctor,\n+\t\t\t\t  &cant_have_const_ctor,\n+\t\t\t\t  &no_const_asn_ref);\n \n-      /* If this was an evil function, don't keep it in class.  */\n-      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n-\tcontinue;\n+  /* Add pointers to all of our virtual base-classes.  */\n+  if (n_baseclasses)\n+    TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, &empty),\n+\t\t\t       TYPE_FIELDS (t));\n \n-      /* Do both of these, even though they're in the same union;\n-\t if the insn `r' member and the size `i' member are\n-\t different sizes, as on the alpha, the larger of the two\n-\t will end up with garbage in it.  */\n-      DECL_SAVED_INSNS (x) = 0;\n-      DECL_FIELD_SIZE (x) = 0;\n+  /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n+  fields = TYPE_FIELDS (t);\n+  if (n_baseclasses)\n+    {\n+      TYPE_FIELDS (t) = chainon (build_base_fields (t), TYPE_FIELDS (t));\n \n-      check_for_override (x, t);\n-      if (DECL_ABSTRACT_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n-\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n+      /* If any base is non-empty, then we are non-empty.  */\n+      for (x = TYPE_FIELDS (t); empty && x != fields; x = TREE_CHAIN (x))\n+\tif (DECL_SIZE (x) != integer_zero_node)\n+\t  empty = 0;\n \n-      /* The name of the field is the original field name\n-\t Save this in auxiliary field for later overloading.  */\n-      if (DECL_VINDEX (x))\n-\t{\n-\t  add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n-\t\t\t\t&has_virtual, x, t);\n-\t  if (DECL_ABSTRACT_VIRTUAL_P (x))\n-\t    abstract_virtuals = tree_cons (NULL_TREE, x, abstract_virtuals);\n-#if 0\n-\t  /* XXX Why did I comment this out?  (jason) */\n-\t  else\n-\t    TREE_USED (x) = 1;\n-#endif\n-\t}\n+      fields = TYPE_FIELDS (t);\n     }\n \n-  if (n_baseclasses)\n-    TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t),\n-\t\t\t       TYPE_FIELDS (t));\n-\n-  /* Check all the data member declarations for legality.  */\n-  next_field = check_field_decls (t, &access_decls, &empty,\n-\t\t\t\t  &cant_have_default_ctor,\n-\t\t\t\t  &cant_have_const_ctor,\n-\t\t\t\t  &no_const_asn_ref);\n-  fields = TYPE_FIELDS (t);\n+  /* Check all the method declarations.  */\n+  check_methods (t);\n \n-  /* If this type has any constant members which did not come\n-     with their own initialization, mark that fact here.  It is\n-     not an error here, since such types can be saved either by their\n-     constructors, or by fortuitous initialization.  */\n-  CLASSTYPE_READONLY_FIELDS_NEED_INIT (t) = const_sans_init;\n-  CLASSTYPE_ABSTRACT_VIRTUALS (t) = abstract_virtuals;\n-  \n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n   TYPE_HAS_COMPLEX_INIT_REF (t)\n-    |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual);\n+    |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n   TYPE_NEEDS_CONSTRUCTING (t)\n-    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual);\n+    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n   CLASSTYPE_NON_AGGREGATE (t)\n-      = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n+      = ! aggregate || TYPE_HAS_CONSTRUCTOR (t);\n   CLASSTYPE_NON_POD_P (t)\n     |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n \t|| TYPE_HAS_ASSIGN_REF (t));\n@@ -3794,29 +3957,21 @@ finish_struct_1 (t)\n     = add_implicitly_declared_members (t, cant_have_default_ctor,\n \t\t\t\t       cant_have_const_ctor,\n \t\t\t\t       no_const_asn_ref);\n-  if (virtual_dtor)\n-    add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n-\t\t\t  &has_virtual, virtual_dtor, t);\n \n-  if (TYPE_METHODS (t))\n-    {\n-      finish_struct_methods (t);\n-      method_vec = CLASSTYPE_METHOD_VEC (t);\n-    }\n-  else\n-    {\n-      method_vec = 0;\n+  /* Loop over the virtual functions, adding them to our various\n+     vtables.  */\n+  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+    if (DECL_VINDEX (x))\n+      add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n+\t\t\t    &has_virtual, x, t);\n \n-      /* Just in case these got accidentally\n-\t filled in by syntax errors.  */\n-      TYPE_HAS_CONSTRUCTOR (t) = 0;\n-      TYPE_HAS_DESTRUCTOR (t) = 0;\n-    }\n+  /* Build and sort the CLASSTYPE_METHOD_VEC.  */\n+  finish_struct_methods (t);\n \n   /* Process the access-declarations.  */\n   while (access_decls)\n     {\n-      handle_using_decl (TREE_VALUE (access_decls), t, method_vec, fields); \n+      handle_using_decl (TREE_VALUE (access_decls), t);\n       access_decls = TREE_CHAIN (access_decls);\n     }\n \n@@ -3841,60 +3996,32 @@ finish_struct_1 (t)\n \t bounds.  That's better than using `void*' or some such; it's\n \t cleaner, and it let's the alias analysis code know that these\n \t stores cannot alias stores to void*!  */\n-      vfield = build_lang_decl (FIELD_DECL, get_vfield_name (t),\n-\t\t\t\t      vtbl_ptr_type_node);\n-      /* If you change any of the below, take a look at all the\n-\t other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n-\t them too.  */\n-      DECL_ASSEMBLER_NAME (vfield) = get_identifier (VFIELD_BASE);\n+      vfield = build_vtbl_or_vbase_field (get_vfield_name (t),\n+\t\t\t\t\t  get_identifier (VFIELD_BASE),\n+\t\t\t\t\t  vtbl_ptr_type_node,\n+\t\t\t\t\t  t,\n+\t\t\t\t\t  &empty);\n       TYPE_VFIELD (t) = vfield;\n-      DECL_VIRTUAL_P (vfield) = 1;\n-      DECL_ARTIFICIAL (vfield) = 1;\n-      DECL_FIELD_CONTEXT (vfield) = t;\n-      DECL_CLASS_CONTEXT (vfield) = t;\n-      DECL_FCONTEXT (vfield) = t;\n-      DECL_SAVED_INSNS (vfield) = 0;\n-      DECL_FIELD_SIZE (vfield) = 0;\n-      DECL_ALIGN (vfield) = TYPE_ALIGN (ptr_type_node);\n       *next_field = vfield;\n-      empty = 0;\n       vfields = chainon (vfields, build_tree_list (NULL_TREE, t));\n     }\n \n-  /* Now DECL_INITIAL is null on all members except for zero-width bit-fields.\n-\n-     C++: maybe we will support default field initialization some day...  */\n-\n-  /* Delete all duplicate fields from the fields */\n-  delete_duplicate_fields (fields);\n-\n-  /* Now we have the nearly final fieldlist for the data fields.  Record it,\n-     then lay out the structure or union (including the fields).  */\n-\n-  TYPE_FIELDS (t) = fields;\n-\n-  if (n_baseclasses)\n-    {\n-      TYPE_FIELDS (t) = chainon (build_base_fields (t), TYPE_FIELDS (t));\n-\n-      /* If all our bases are empty, we can be empty too.  */\n-      for (x = TYPE_FIELDS (t); empty && x != fields; x = TREE_CHAIN (x))\n-\tif (DECL_SIZE (x) != integer_zero_node)\n-\t  empty = 0;\n-    }\n-\n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n      we have to save this before we start modifying\n      TYPE_NONCOPIED_PARTS.  */\n   inline_friends = CLASSTYPE_INLINE_FRIENDS (t);\n   CLASSTYPE_INLINE_FRIENDS (t) = NULL_TREE;\n \n+  /* We make all structures have at least one element, so that they\n+     have non-zero size.  The field that we add here is fake, in the\n+     sense that, for example, we don't want people to be able to\n+     initialize it later.  So, we add it just long enough to let the\n+     back-end lay out the type, and then remove it.  */\n   if (empty)\n     {\n-      /* C++: do not let empty structures exist.  */\n       tree decl = build_lang_decl\n \t(FIELD_DECL, NULL_TREE, char_type_node);\n-      TREE_CHAIN (decl) = fields;\n+      TREE_CHAIN (decl) = TYPE_FIELDS (t);\n       TYPE_FIELDS (t) = decl;\n       TYPE_NONCOPIED_PARTS (t) \n \t= tree_cons (NULL_TREE, decl, TYPE_NONCOPIED_PARTS (t));\n@@ -3903,6 +4030,11 @@ finish_struct_1 (t)\n \n   layout_type (t);\n \n+  /* If we added an extra field to make this class non-empty, remove\n+     it now.  */\n+  if (empty)\n+    TYPE_FIELDS (t) = TREE_CHAIN (TYPE_FIELDS (t));\n+\n   /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n   if (empty && flag_new_abi)\n@@ -3930,22 +4062,10 @@ finish_struct_1 (t)\n   if (n_baseclasses)\n     /* layout_basetypes will remove the base subobject fields.  */\n     max_has_virtual = layout_basetypes (t, max_has_virtual);\n-  if (empty)\n-    TYPE_FIELDS (t) = fields;\n-\n-  my_friendly_assert (TYPE_FIELDS (t) == fields, 981117);\n \n-  /* Delete all zero-width bit-fields from the fieldlist */\n-  {\n-    tree *fieldsp = &fields;\n-    while (*fieldsp)\n-      if (TREE_CODE (*fieldsp) == FIELD_DECL\n-\t  && DECL_C_BIT_FIELD (*fieldsp) && DECL_INITIAL (*fieldsp))\n-\t*fieldsp = TREE_CHAIN (*fieldsp);\n-      else\n-\tfieldsp = &TREE_CHAIN (*fieldsp);\n-  }\n-  TYPE_FIELDS (t) = fields;\n+  /* Delete all zero-width bit-fields from the list of fields.  Now\n+     that we have layed out the type they are no longer important.  */\n+  remove_zero_width_bit_fields (t);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n@@ -3998,10 +4118,6 @@ finish_struct_1 (t)\n       TYPE_VFIELD (t) = vfield;\n     }\n     \n-#ifdef NOTQUITE\n-  cp_warning (\"Doing hard virtuals for %T...\", t);\n-#endif\n-\n   if (has_virtual > max_has_virtual)\n     max_has_virtual = has_virtual;\n   if (max_has_virtual > 0)\n@@ -4141,7 +4257,7 @@ finish_struct_1 (t)\n \n   /* Complete the rtl for any static member objects of the type we're\n      working on.  */\n-  for (x = fields; x; x = TREE_CHAIN (x))\n+  for (x = TYPE_FIELDS (t); x; x = TREE_CHAIN (x))\n     {\n       if (TREE_CODE (x) == VAR_DECL && TREE_STATIC (x)\n \t  && TREE_TYPE (x) == t)\n@@ -4152,20 +4268,18 @@ finish_struct_1 (t)\n     }\n \n   /* Done with FIELDS...now decide whether to sort these for\n-     faster lookups later.  Don't worry about optimizing\n-     for structs only declared in inline functions...they're\n-     not going to be referenced anywhere else.\n+     faster lookups later.\n \n      The C front-end only does this when n_fields > 15.  We use\n      a smaller number because most searches fail (succeeding\n      ultimately as the search bores through the inheritance\n      hierarchy), and we want this failure to occur quickly.  */\n \n-  n_fields = count_fields (fields);\n-  if (n_fields > 7 && !allocation_temporary_p ())\n+  n_fields = count_fields (TYPE_FIELDS (t));\n+  if (n_fields > 7)\n     {\n       tree field_vec = make_tree_vec (n_fields);\n-      add_fields_to_vec (fields, field_vec, 0);\n+      add_fields_to_vec (TYPE_FIELDS (t), field_vec, 0);\n       qsort (&TREE_VEC_ELT (field_vec, 0), n_fields, sizeof (tree),\n \t     (int (*)(const void *, const void *))field_decl_cmp);\n       if (! DECL_LANG_SPECIFIC (TYPE_MAIN_DECL (t)))\n@@ -4201,7 +4315,7 @@ finish_struct_1 (t)\n \t\t     vfield, TYPE_NONCOPIED_PARTS (t));\n \n       if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (t)\n-\t  && DECL_VINDEX (TREE_VEC_ELT (method_vec, 1)) == NULL_TREE)\n+\t  && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)\n \tcp_warning (\"`%#T' has virtual functions but non-virtual destructor\",\n \t\t    t);\n     }\n@@ -4211,11 +4325,6 @@ finish_struct_1 (t)\n   finish_vtbls (TYPE_BINFO (t), 1, t);\n   hack_incomplete_structures (t);\n \n-#if 0\n-  if (TYPE_NAME (t) && TYPE_IDENTIFIER (t))\n-    undo_template_name_overload (TYPE_IDENTIFIER (t), 1);\n-#endif\n-\n   if (warn_overloaded_virtual)\n     warn_hidden (t);\n "}, {"sha": "ea58f86d037a9e4af3a048adfaf1d83def655136", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -4012,7 +4012,6 @@ extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_staticfn_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n extern int layout_basetypes\t\t\tPROTO((tree, int));\n-extern tree build_vbase_pointer_fields\t\tPROTO((tree));\n extern tree build_base_fields\t\t\tPROTO((tree));\n extern tree hash_tree_cons\t\t\tPROTO((tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));"}, {"sha": "b08f4db1725c3225f66abd6fadae1b9e2dfa155d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -9293,8 +9293,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* Avoid giving two errors for this.  */\n \t    IDENTIFIER_CLASS_VALUE (dname) = NULL_TREE;\n \n-\t    declspecs = temp_tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\tdeclspecs);\n+\t    declspecs = tree_cons (NULL_TREE, integer_type_node, declspecs);\n \t    *next = dname;\n \t    next = 0;\n \t    break;"}, {"sha": "937a1647cdb1a79d5a0bd8365ca7880fa6b31caa", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -4335,7 +4335,7 @@ qualified_lookup_using_namespace (name, scope, result, flags)\n   tree usings;\n   while (scope && (result != error_mark_node))\n     {\n-      seen = temp_tree_cons (scope, NULL_TREE, seen);\n+      seen = tree_cons (scope, NULL_TREE, seen);\n       result = ambiguous_decl (name, result,\n                                binding_for_name (name, scope), flags);\n       if (!BINDING_VALUE (result) && !BINDING_TYPE (result))\n@@ -4345,7 +4345,7 @@ qualified_lookup_using_namespace (name, scope, result, flags)\n \t  /* If this was a real directive, and we have not seen it. */\n \t  if (!TREE_INDIRECT_USING (usings)\n \t      && !purpose_member (TREE_PURPOSE (usings), seen))\n-\t    todo = temp_tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n+\t    todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n       if (todo)\n \t{\n \t  scope = TREE_PURPOSE (todo);"}, {"sha": "01ec8fcb02d9b8f056de99d3669d6bafb9d738b0", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -2000,9 +2000,6 @@ cons_up_default_function (type, full_name, kind)\n   switch (kind)\n     {\n       /* Destructors.  */\n-    case 1:\n-      declspecs = build_decl_list (NULL_TREE, ridpointers [(int) RID_VIRTUAL]);\n-      /* Fall through...  */\n     case 0:\n       name = build_parse_node (BIT_NOT_EXPR, name);\n       args = void_list_node;"}, {"sha": "d50b4594987eff2f5786f04c3d5da569e2108b0f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58010b57a6232b4d2ed0e07e47601b3fca6f958d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=58010b57a6232b4d2ed0e07e47601b3fca6f958d", "patch": "@@ -989,86 +989,6 @@ build_base_fields (rec)\n   return base_decls;\n }\n \n-/* Returns list of virtual base class pointers in a FIELD_DECL chain.  */\n-\n-tree\n-build_vbase_pointer_fields (rec)\n-     tree rec;\n-{\n-  /* Chain to hold all the new FIELD_DECLs which point at virtual\n-     base classes.  */\n-  tree vbase_decls = NULL_TREE;\n-  tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree decl;\n-  int i;\n-\n-  /* Handle basetypes almost like fields, but record their\n-     offsets differently.  */\n-\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n-\n-      if (TYPE_SIZE (basetype) == 0)\n-\t/* This error is now reported in xref_tag, thus giving better\n-\t   location information.  */\n-\tcontinue;\n-\n-      /* All basetypes are recorded in the association list of the\n-\t derived type.  */\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  int j;\n-\t  const char *name;\n-\n-\t  /* The offset for a virtual base class is only used in computing\n-\t     virtual function tables and for initializing virtual base\n-\t     pointers.  It is built once `get_vbase_types' is called.  */\n-\n-\t  /* If this basetype can come from another vbase pointer\n-\t     without an additional indirection, we will share\n-\t     that pointer.  If an indirection is involved, we\n-\t     make our own pointer.  */\n-\t  for (j = 0; j < n_baseclasses; j++)\n-\t    {\n-\t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n-\t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n-\t\t  && binfo_member (basetype,\n-\t\t\t\t   CLASSTYPE_VBASECLASSES (BINFO_TYPE\n-\t\t\t\t\t\t\t   (other_base_binfo))\n-\t\t\t\t   ))\n-\t\tgoto got_it;\n-\t    }\n-\t  FORMAT_VBASE_NAME (name, basetype);\n-\t  decl = build_lang_decl (FIELD_DECL, get_identifier (name),\n-\t\t\t\t  build_pointer_type (basetype));\n-\t  /* If you change any of the below, take a look at all the\n-\t     other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n-\t     them too.  */\n-\t  DECL_ASSEMBLER_NAME (decl) = get_identifier (VTABLE_BASE);\n-\t  DECL_VIRTUAL_P (decl) = 1;\n-\t  DECL_ARTIFICIAL (decl) = 1;\n-\t  DECL_FIELD_CONTEXT (decl) = rec;\n-\t  DECL_CLASS_CONTEXT (decl) = rec;\n-\t  DECL_FCONTEXT (decl) = basetype;\n-\t  DECL_SAVED_INSNS (decl) = 0;\n-\t  DECL_FIELD_SIZE (decl) = 0;\n-\t  DECL_ALIGN (decl) = TYPE_ALIGN (ptr_type_node);\n-\t  TREE_CHAIN (decl) = vbase_decls;\n-\t  BINFO_VPTR_FIELD (base_binfo) = decl;\n-\t  vbase_decls = decl;\n-\n-\tgot_it:\n-\t  /* The space this decl occupies has already been accounted for.  */\n-\t  ;\n-\t}\n-    }\n-\n-  return vbase_decls;\n-}\n \f\n /* Hashing of lists so that we don't make duplicates.\n    The entry point is `list_hash_canon'.  */"}]}