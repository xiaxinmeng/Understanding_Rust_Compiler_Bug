{"sha": "ca54603f6a9b94cc240631068bbfd8bb4c8a7a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E1NDYwM2Y2YTliOTRjYzI0MDYzMTA2OGJiZmQ4YmI0YzhhN2E4OA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-01-06T17:57:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-06T17:57:29Z"}, "message": "calls.c (special_function_p): Push alloca test inside the large conditional which excludes functions not at...\n\n        * calls.c (special_function_p): Push alloca test inside the large\n        conditional which excludes functions not at file scope or not\n        extern.\n\nFrom-SVN: r24524", "tree": {"sha": "96e64d505348d8523d51431ac76828389cbc48a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e64d505348d8523d51431ac76828389cbc48a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88/comments", "author": null, "committer": null, "parents": [{"sha": "bc3ca41b4911ec74cd970904c5a91402bdeeb424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3ca41b4911ec74cd970904c5a91402bdeeb424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc3ca41b4911ec74cd970904c5a91402bdeeb424"}], "stats": {"total": 125, "additions": 113, "deletions": 12}, "files": [{"sha": "b7b8c7ad8327b1e0757a636c6b50530595d96c91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca54603f6a9b94cc240631068bbfd8bb4c8a7a88", "patch": "@@ -7,6 +7,10 @@ Wed Jan  6 17:55:19 1999  Robert Lipe  <robertlipe@usa.net>\n \n Wed Jan  6 16:08:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (special_function_p): Push alloca test inside the large\n+\tconditional which excludes functions not at file scope or not\n+\textern.  \n+\n \t* calls.c (special_function_p): New function broken out of\n \texpand_call.\n \t(precompute_register_parameters): Likewise."}, {"sha": "95a29f74be281c285a5d38fb494beed5e9b84d0b", "filename": "gcc/calls.c", "status": "modified", "additions": 109, "deletions": 12, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca54603f6a9b94cc240631068bbfd8bb4c8a7a88/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ca54603f6a9b94cc240631068bbfd8bb4c8a7a88", "patch": "@@ -33,6 +33,10 @@ Boston, MA 02111-1307, USA.  */\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n #endif\n \n+extern int frame_offset;\n+extern rtx tail_recursion_label;\n+extern rtx tail_recursion_reentry;\n+\n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n \n@@ -62,6 +66,8 @@ struct arg_data\n   rtx value;\n   /* Initially-compute RTL value for argument; only for const functions.  */\n   rtx initial_value;\n+  /*  */\n+  rtx sibcall_value;\n   /* Register to pass this argument in, 0 if passed on stack, or an\n      PARALLEL if the arg is to be copied into multiple non-contiguous\n      registers.  */\n@@ -515,17 +521,6 @@ special_function_p (name, fndecl, returns_twice, is_longjmp,\n   *is_malloc = 0;\n   *may_be_alloca = 0;\n \n-  /* We assume that alloca will always be called by name.  It\n-     makes no sense to pass it as a pointer-to-function to\n-     anything that does not understand its behavior.  */\n-  *may_be_alloca\n-    = (name && ((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n-\t\t && name[0] == 'a'\n-\t\t && ! strcmp (name, \"alloca\"))\n-\t\t|| (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n-\t\t    && name[0] == '_'\n-\t\t    && ! strcmp (name, \"__builtin_alloca\"))));\n-\n   if (name != 0 && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 17\n       /* Exclude functions not at the file scope, or not `extern',\n \t since they are not the magic functions we would otherwise\n@@ -534,6 +529,17 @@ special_function_p (name, fndecl, returns_twice, is_longjmp,\n     {\n       char *tname = name;\n \n+      /* We assume that alloca will always be called by name.  It\n+\t makes no sense to pass it as a pointer-to-function to\n+\t anything that does not understand its behavior.  */\n+      *may_be_alloca\n+\t= (((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n+\t     && name[0] == 'a'\n+\t     && ! strcmp (name, \"alloca\"))\n+\t    || (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n+\t\t&& name[0] == '_'\n+\t\t&& ! strcmp (name, \"__builtin_alloca\"))));\n+\n       /* Disregard prefix _, __ or __x.  */\n       if (name[0] == '_')\n \t{\n@@ -834,6 +840,7 @@ expand_call (exp, target, ignore)\n   tree actparms = TREE_OPERAND (exp, 1);\n   /* RTX for the function to be called.  */\n   rtx funexp;\n+  rtx tail_recursion_insns = NULL_RTX;\n   /* Data type of the function.  */\n   tree funtype;\n   /* Declaration of the function being called,\n@@ -1916,6 +1923,7 @@ expand_call (exp, target, ignore)\n      once we have started filling any specific hard regs.  */\n   precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n \n+\n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n \n   /* Save the fixed argument area if it's part of the caller's frame and\n@@ -2063,6 +2071,92 @@ expand_call (exp, target, ignore)\n \t}\n     }\n \n+  /* See if this is a potential tail recursive call.  We can not know for\n+     sure until we have expanded the entire function into RTL and can examine\n+     the cfg and other data.  But we have to mark it and save some information\n+     now so that we can optimize it later.  */\n+  if (optimize\n+      && TREE_CODE (exp) == CALL_EXPR\n+      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+      && TREE_OPERAND (TREE_OPERAND (exp, 0), 0) == current_function_decl)\n+    {\n+      tree actuals, formals, a, f;\n+      int i;\n+\n+      actuals = TREE_OPERAND (exp, 1);\n+      formals = DECL_ARGUMENTS (current_function_decl);\n+      /* The caller and callee must have the same number of arguments and\n+\t they must be of compatible types and modes.  */\n+      for (a = actuals, f = formals, i = 0;\n+\t   a != NULL_TREE && f != NULL_TREE;\n+\t   a = TREE_CHAIN (a) , f = TREE_CHAIN (f), i++)\n+\t{\n+\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (a)))\n+\t      != TYPE_MAIN_VARIANT (TREE_TYPE (f)))\n+\t    break;\n+\t  if (GET_CODE (DECL_RTL (f)) != REG || DECL_MODE (f) == BLKmode)\n+\t    break;\n+\t  if (!args[i].sibcall_value)\n+\t    args[i].sibcall_value = args[i].value;\n+\t}\n+\n+      \n+      if (a == NULL_TREE && f == NULL_TREE)\n+\t{\n+\t  /* Create the tail recursion label if it has not been created\n+\t     already.  */\n+\t  if (tail_recursion_label == 0)\n+\t    {\n+\t      tail_recursion_label = gen_label_rtx ();\n+\t      emit_label_after (tail_recursion_label, tail_recursion_reentry);\n+\t    }\n+\n+\t  /* We have a potential tail recursion site.\n+\n+\t     Start a new sequence for any RTL generated which might be used\n+\t     to implement tail recursion optimizations later.  */\n+\t  push_to_sequence (0);\n+\n+\t  /* Find which actual values refer to current values of previous\n+\t     formals.  Copy each of them now, before any formal is changed.  */\n+\t  for (a = actuals, i = 0; a != NULL_TREE; a = TREE_CHAIN (a), i++)\n+\t    {\n+\t      int copy = 0, j;\n+\n+\t      for (f = formals, j = 0; j < i; f = TREE_CHAIN (f), j++)\n+\t\tif (reg_mentioned_p (DECL_RTL (f), args[i].value))\n+\t\t  {\n+\t\t    copy = 1;\n+\t\t    break;\n+\t\t  }\n+\t      if (copy)\n+\t\targs[i].sibcall_value = copy_to_reg (args[i].value);\n+\t    }\n+\n+\t  /* Store the values of the actuals into the formals.  */\n+\t  for (f = formals, a = actuals, i = 0; f != NULL_TREE;\n+\t       f = TREE_CHAIN (f), a = TREE_CHAIN (a), i++)\n+\t    {\n+\t      if (GET_MODE (DECL_RTL (f)) == GET_MODE (args[i].sibcall_value))\n+\t\temit_move_insn (DECL_RTL (f), args[i].sibcall_value);\n+\t      else\n+\t\tconvert_move (DECL_RTL (f), args[i].sibcall_value,\n+\t\t\t      TREE_UNSIGNED (TREE_TYPE (TREE_VALUE (a))));\n+\t    }\n+\n+\t  /* Emit any queued operations.  */\n+\t  emit_queue ();\n+\n+\t  /* Goto the tail recursion label.  */\n+\t  expand_goto_internal (NULL_TREE, tail_recursion_label, get_last_insn);\n+\n+\t  tail_recursion_insns = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insns (tail_recursion_insns);  \n+\t  return;\n+\t}\n+    }\n+      \n   /* Perform postincrements before actually calling the function.  */\n   emit_queue ();\n \n@@ -3690,7 +3784,10 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n      arg->stack_slot and it matters when they are not the same.\n      It isn't totally clear that this is correct in all cases.  */\n   if (partial == 0)\n-    arg->value = arg->stack_slot;\n+    {\n+      arg->sibcall_value = arg->value;\n+      arg->value = arg->stack_slot;\n+    }\n \n   /* Once we have pushed something, pops can't safely\n      be deferred during the rest of the arguments.  */"}]}