{"sha": "9368208b083671159eaf9cdd55dd10aeb221ae88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM2ODIwOGIwODM2NzExNTllYWY5Y2RkNTVkZDEwYWViMjIxYWU4OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-18T09:21:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-18T09:21:06Z"}, "message": "class.c (find_final_overrider_data_s): Remove overriding_fn and overriding_base.\n\n\t* class.c (find_final_overrider_data_s): Remove overriding_fn and\n\toverriding_base.\n\t(dfs_base_derived_from): New function.\n\t(base_derived_from): Likewise.\n\t(dfs_find_final_overrider): Use base_derived_from.\n\t(find_final_overrider): Adjust.\n\n\t* g++.dg/inherit/override1.C: New test.\n\nFrom-SVN: r58283", "tree": {"sha": "c4f47126f106010ed5a2c2829b560d5739b22f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4f47126f106010ed5a2c2829b560d5739b22f0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9368208b083671159eaf9cdd55dd10aeb221ae88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9368208b083671159eaf9cdd55dd10aeb221ae88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9368208b083671159eaf9cdd55dd10aeb221ae88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9368208b083671159eaf9cdd55dd10aeb221ae88/comments", "author": null, "committer": null, "parents": [{"sha": "5275f2bf280fa76d637b1a6f4bfd522a6de2d507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5275f2bf280fa76d637b1a6f4bfd522a6de2d507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5275f2bf280fa76d637b1a6f4bfd522a6de2d507"}], "stats": {"total": 189, "additions": 82, "deletions": 107}, "files": [{"sha": "ced9a04cfed252b7394db524e10f50d2e96c9ebf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9368208b083671159eaf9cdd55dd10aeb221ae88", "patch": "@@ -1,3 +1,12 @@\n+2002-10-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (find_final_overrider_data_s): Remove overriding_fn and\n+\toverriding_base.\n+\t(dfs_base_derived_from): New function.\n+\t(base_derived_from): Likewise.\n+\t(dfs_find_final_overrider): Use base_derived_from.\n+\t(find_final_overrider): Adjust.\n+\n 2002-10-18  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/8080"}, {"sha": "0434337ea6b526a619b7a5600bcdb6c0c8f2a1aa", "filename": "gcc/cp/class.c", "status": "modified", "additions": 47, "deletions": 107, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9368208b083671159eaf9cdd55dd10aeb221ae88", "patch": "@@ -208,6 +208,8 @@ static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n static void warn_about_ambiguous_bases PARAMS ((tree));\n static bool type_requires_array_cookie PARAMS ((tree));\n static bool contains_empty_class_p (tree);\n+static tree dfs_base_derived_from (tree, void *);\n+static bool base_derived_from (tree, tree);\n \n /* Macros for dfs walking during vtt construction. See\n    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n@@ -2204,21 +2206,38 @@ same_signature_p (fndecl, base_fndecl)\n   return 0;\n }\n \n+/* Called from base_derived_from via dfs_walk.  */\n+\n+static tree\n+dfs_base_derived_from (tree binfo, void *data)\n+{\n+  tree base = (tree) data;\n+\n+  if (same_type_p (TREE_TYPE (base), TREE_TYPE (binfo))\n+      && tree_int_cst_equal (BINFO_OFFSET (base), BINFO_OFFSET (binfo)))\n+    return error_mark_node;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns TRUE if DERIVED is a binfo containing the binfo BASE as a\n+   subobject.  */\n+ \n+static bool\n+base_derived_from (tree derived, tree base)\n+{\n+  return dfs_walk (derived, dfs_base_derived_from, NULL, base);\n+}\n+\n typedef struct find_final_overrider_data_s {\n   /* The function for which we are trying to find a final overrider.  */\n   tree fn;\n   /* The base class in which the function was declared.  */\n   tree declaring_base;\n   /* The most derived class in the hierarchy.  */\n   tree most_derived_type;\n-  /* The final overriding function.  */\n-  tree overriding_fn;\n-  /* The functions that we thought might be final overriders, but\n-     aren't.  */\n+  /* The candidate overriders.  */\n   tree candidates;\n-  /* The BINFO for the class in which the final overriding function\n-     appears.  */\n-  tree overriding_base;\n } find_final_overrider_data;\n \n /* Called from find_final_overrider via dfs_walk.  */\n@@ -2243,118 +2262,41 @@ dfs_find_final_overrider (binfo, data)\n       /* We've found a path to the declaring base.  Walk down the path\n \t looking for an overrider for FN.  */\n       for (path = reverse_path (binfo);\n-\t   path; \n+\t   path;\n \t   path = TREE_CHAIN (path))\n \t{\n \t  method = look_for_overrides_here (BINFO_TYPE (TREE_VALUE (path)),\n \t\t\t\t\t    ffod->fn);\n \t  if (method)\n-\t    break;\n+\t    {\n+\t      path = TREE_VALUE (path);\n+\t      break;\n+\t    }\n \t}\n \n       /* If we found an overrider, record the overriding function, and\n \t the base from which it came.  */\n       if (path)\n \t{\n-\t  tree base;\n-\n-\t  /* Assume the path is non-virtual.  See if there are any\n-\t     virtual bases from (but not including) the overrider up\n-\t     to and including the base where the function is\n-\t     defined.  */\n-\t  for (base = TREE_CHAIN (path); base; base = TREE_CHAIN (base))\n-\t    if (TREE_VIA_VIRTUAL (TREE_VALUE (base)))\n-\t      {\n-\t\tbase = ffod->declaring_base;\n-\t\tbreak;\n-\t      }\n+\t  tree *candidate;\n \n-\t  /* If we didn't already have an overrider, or any\n-\t     candidates, then this function is the best candidate so\n-\t     far.  */\n-\t  if (!ffod->overriding_fn && !ffod->candidates)\n+\t  /* Remove any candidates overridden by this new function.  */\n+\t  candidate = &ffod->candidates;\n+\t  while (*candidate)\n \t    {\n-\t      ffod->overriding_fn = method;\n-\t      ffod->overriding_base = TREE_VALUE (path);\n-\t    }\n-\t  else if (ffod->overriding_fn)\n-\t    {\n-\t      /* We had a best overrider; let's see how this compares.  */\n-\n-\t      if (ffod->overriding_fn == method\n-\t\t  && (tree_int_cst_equal \n-\t\t      (BINFO_OFFSET (TREE_VALUE (path)),\n-\t\t       BINFO_OFFSET (ffod->overriding_base))))\n-\t\t/* We found the same overrider we already have, and in the\n-\t\t   same place; it's still the best.  */;\n-\t      else if (strictly_overrides (ffod->overriding_fn, method))\n-\t\t/* The old function overrides this function; it's still the\n-\t\t   best.  */;\n-\t      else if (strictly_overrides (method, ffod->overriding_fn))\n-\t\t{\n-\t\t  /* The new function overrides the old; it's now the\n-\t\t     best.  */\n-\t\t  ffod->overriding_fn = method;\n-\t\t  ffod->overriding_base = TREE_VALUE (path);\n-\t\t}\n+\t      /* If *CANDIDATE overrides METHOD, then METHOD\n+\t\t cannot override anything else on the list.  */\n+\t      if (base_derived_from (TREE_VALUE (*candidate), path))\n+\t\t  return NULL_TREE;\n+\t      /* If METHOD overrides *CANDIDATE, remove *CANDIDATE.  */\n+\t      if (base_derived_from (path, TREE_VALUE (*candidate)))\n+\t\t*candidate = TREE_CHAIN (*candidate);\n \t      else\n-\t\t{\n-\t\t  /* Ambiguous.  */\n-\t\t  ffod->candidates \n-\t\t    = build_tree_list (NULL_TREE,\n-\t\t\t\t       ffod->overriding_fn);\n-\t\t  if (method != ffod->overriding_fn)\n-\t\t    ffod->candidates \n-\t\t      = tree_cons (NULL_TREE, method, ffod->candidates);\n-\t\t  ffod->overriding_fn = NULL_TREE;\n-\t\t  ffod->overriding_base = NULL_TREE;\n-\t\t}\n+\t\tcandidate = &TREE_CHAIN (*candidate);\n \t    }\n-\t  else\n-\t    {\n-\t      /* We had a list of ambiguous overrides; let's see how this\n-\t\t new one compares.  */\n-\n-\t      tree candidates;\n-\t      bool incomparable = false;\n-\n-\t      /* If there were previous candidates, and this function\n-\t\t overrides all of them, then it is the new best\n-\t\t candidate.  */\n-\t      for (candidates = ffod->candidates;\n-\t\t   candidates;\n-\t\t   candidates = TREE_CHAIN (candidates))\n-\t\t{\n-\t\t  /* If the candidate overrides the METHOD, then we\n-\t\t     needn't worry about it any further.  */\n-\t\t  if (strictly_overrides (TREE_VALUE (candidates),\n-\t\t\t\t\t  method))\n-\t\t    {\n-\t\t      method = NULL_TREE;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* If the METHOD doesn't override the candidate,\n-\t\t     then it is incomporable.  */\n-\t\t  if (!strictly_overrides (method,\n-\t\t\t\t\t   TREE_VALUE (candidates)))\n-\t\t    incomparable = true;\n-\t\t}\n \n-\t      /* If METHOD overrode all the candidates, then it is the\n-\t\t new best candidate.  */\n-\t      if (!candidates && !incomparable)\n-\t\t{\n-\t\t  ffod->overriding_fn = method;\n-\t\t  ffod->overriding_base = TREE_VALUE (path);\n-\t\t  ffod->candidates = NULL_TREE;\n-\t\t}\n-\t      /* If METHOD didn't override all the candidates, then it\n-\t\t is another candidate.  */\n-\t      else if (method && incomparable)\n-\t\tffod->candidates \n-\t\t  = tree_cons (NULL_TREE, method, ffod->candidates);\n-\t    }\n+\t  /* Add the new function.  */\n+\t  ffod->candidates = tree_cons (method, path, ffod->candidates);\n \t}\n     }\n \n@@ -2395,8 +2337,6 @@ find_final_overrider (t, binfo, fn)\n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n   ffod.most_derived_type = t;\n-  ffod.overriding_fn = NULL_TREE;\n-  ffod.overriding_base = NULL_TREE;\n   ffod.candidates = NULL_TREE;\n \n   dfs_walk (TYPE_BINFO (t),\n@@ -2405,13 +2345,13 @@ find_final_overrider (t, binfo, fn)\n \t    &ffod);\n \n   /* If there was no winner, issue an error message.  */\n-  if (!ffod.overriding_fn)\n+  if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n     {\n       error (\"no unique final overrider for `%D' in `%T'\", fn, t);\n       return error_mark_node;\n     }\n \n-  return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n+  return ffod.candidates;\n }\n \n /* Returns the function from the BINFO_VIRTUALS entry in T which matches"}, {"sha": "9c16af2cd475026295b437b4271b261b397a5219", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9368208b083671159eaf9cdd55dd10aeb221ae88", "patch": "@@ -1,3 +1,11 @@\n+2002-10-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/inherit/override1.C: New test.\n+\n+\t* g++.dg/abi/mangle11.C: New test.\n+\t* g++.dg/abi/mangle14.C: New test.\n+\t* g++.dg/abi/mangle17.C: New test.\n+\n 2002-10-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/overload/member2.C: New test."}, {"sha": "04460edab7413ec0aa062f52e4e58835614e8afe", "filename": "gcc/testsuite/g++.dg/inherit/override1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Foverride1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9368208b083671159eaf9cdd55dd10aeb221ae88/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Foverride1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Foverride1.C?ref=9368208b083671159eaf9cdd55dd10aeb221ae88", "patch": "@@ -0,0 +1,18 @@\n+struct c0 { virtual void f (); };\n+struct c1 : public c0 {};\n+struct c2 : public c0 {};\n+struct c3 : virtual public c0, public c1, public c2 {};\n+struct c5 {};\n+struct c7 : virtual public c3 {};\n+struct c8 : virtual public c1 { virtual void f (); };\n+struct c9 {};\n+struct c10 : virtual public c8, virtual public c7 {};\n+struct c11 : virtual public c5 {};\n+struct c12 : virtual public c8, public c7 {};\n+struct c13 : public c9, public c3, virtual public c2 {};\n+struct c14 : virtual public c1, virtual public c5, virtual public c0,\n+\t     public c2 {};\n+struct c15 : public c14, public c12, virtual public c3 {};\n+struct c16 : public c12, public c10, public c2 { virtual void f (); };\n+struct c17 : virtual public c13, public c15, virtual public c0,\n+\t     virtual public c16 {};"}]}