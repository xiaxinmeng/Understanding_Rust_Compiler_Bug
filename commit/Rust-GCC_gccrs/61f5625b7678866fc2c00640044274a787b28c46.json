{"sha": "61f5625b7678866fc2c00640044274a787b28c46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmNTYyNWI3Njc4ODY2ZmMyYzAwNjQwMDQ0Mjc0YTc4N2IyOGM0Ng==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-01-19T16:32:27Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-01-19T16:32:27Z"}, "message": "reload1.c (move2add_note_store): Treat all registers about which no information is known as potential bases...\n\n* reload1.c (move2add_note_store): Treat all registers about which\nno information is known as potential bases, and treat all\nregisters directly or indirectly derived from it as members of the\nsame set of values.\n(reload_cse_move2add): Adjust accordingly.  Take mode and\noffset of base register into account.\n\nFrom-SVN: r39135", "tree": {"sha": "e943fabab9b5a5c7ff5c71741146b2c9c44d1e9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e943fabab9b5a5c7ff5c71741146b2c9c44d1e9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f5625b7678866fc2c00640044274a787b28c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f5625b7678866fc2c00640044274a787b28c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f5625b7678866fc2c00640044274a787b28c46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f5625b7678866fc2c00640044274a787b28c46/comments", "author": null, "committer": null, "parents": [{"sha": "5bea1ccf194e00a92d87df1b75e8639cb92bcbbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bea1ccf194e00a92d87df1b75e8639cb92bcbbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bea1ccf194e00a92d87df1b75e8639cb92bcbbf"}], "stats": {"total": 246, "additions": 155, "deletions": 91}, "files": [{"sha": "a50cebfb47163cf985d40c263ea2abc66fb79959", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f5625b7678866fc2c00640044274a787b28c46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f5625b7678866fc2c00640044274a787b28c46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61f5625b7678866fc2c00640044274a787b28c46", "patch": "@@ -1,3 +1,12 @@\n+Fri Jan 19 14:31:35 2001  Alexandre Oliva  <aoliva@redhat.com>, J\"orn Rennecke <amylaar@redhat.com>\n+\n+\t* reload1.c (move2add_note_store): Treat all registers about which\n+\tno information is known as potential bases, and treat all\n+\tregisters directly or indirectly derived from it as members of the\n+\tsame set of values.\n+\t(reload_cse_move2add): Adjust accordingly.  Take mode and\n+\toffset of base register into account.\n+\n Fri Jan 19 09:18:42 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* alias.c (find_base_value): Recognize TRUNCATE."}, {"sha": "4b0d0130f11a8df8f44c612fde431444e38ea9e3", "filename": "gcc/reload1.c", "status": "modified", "additions": 146, "deletions": 91, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f5625b7678866fc2c00640044274a787b28c46/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f5625b7678866fc2c00640044274a787b28c46/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=61f5625b7678866fc2c00640044274a787b28c46", "patch": "@@ -455,7 +455,7 @@ static void move2add_note_store\t\tPARAMS ((rtx, rtx, void *));\n #ifdef AUTO_INC_DEC\n static void add_auto_inc_notes\t\tPARAMS ((rtx, rtx));\n #endif\n-static rtx gen_mode_int\t\t\tPARAMS ((enum machine_mode,\n+static HOST_WIDE_INT sext_for_mode\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t HOST_WIDE_INT));\n static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n@@ -8950,25 +8950,23 @@ reload_combine_note_use (xp, insn)\n     }\n }\n \f\n-/* See if we can reduce the cost of a constant by replacing a move with\n-   an add.  */\n+/* See if we can reduce the cost of a constant by replacing a move\n+   with an add.  We track situations in which a register is set to a\n+   constant or to a register plus a constant.  */\n /* We cannot do our optimization across labels.  Invalidating all the\n    information about register contents we have would be costly, so we\n-   use last_label_luid (local variable of reload_cse_move2add) to note\n-   where the label is and then later disable any optimization that would\n-   cross it.\n+   use move2add_last_label_luid to note where the label is and then\n+   later disable any optimization that would cross it.\n    reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if\n-   reg_set_luid[n] is larger than last_label_luid[n] .  */\n+   reg_set_luid[n] is greater than last_label_luid[n] .  */\n static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n \n-/* reg_offset[n] has to be CONST_INT for it and reg_base_reg[n] /\n-   reg_mode[n] to be valid.\n-   If reg_offset[n] is a CONST_INT and reg_base_reg[n] is negative, register n\n-   has been set to reg_offset[n] in mode reg_mode[n] .\n-   If reg_offset[n] is a CONST_INT and reg_base_reg[n] is non-negative,\n-   register n has been set to the sum of reg_offset[n] and register\n-   reg_base_reg[n], calculated in mode reg_mode[n] .  */\n-static rtx reg_offset[FIRST_PSEUDO_REGISTER];\n+/* If reg_base_reg[n] is negative, register n has been set to\n+   reg_offset[n] in mode reg_mode[n] .\n+   If reg_base_reg[n] is non-negative, register n has been set to the\n+   sum of reg_offset[n] and the value of register reg_base_reg[n]\n+   before reg_set_luid[n], calculated in mode reg_mode[n] . */\n+static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n \n@@ -8977,10 +8975,14 @@ static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n    reload_cse_move2add and move2add_note_store.  */\n static int move2add_luid;\n \n+/* move2add_last_label_luid is set whenever a label is found.  Labels\n+   invalidate all previously collected reg_offset data.  */\n+static int move2add_last_label_luid;\n+\n /* Generate a CONST_INT and force it in the range of MODE.  */\n \n-static rtx\n-gen_mode_int (mode, value)\n+static HOST_WIDE_INT\n+sext_for_mode (mode, value)\n      enum machine_mode mode;\n      HOST_WIDE_INT value;\n {\n@@ -8993,28 +8995,42 @@ gen_mode_int (mode, value)\n       && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n     cval |= (HOST_WIDE_INT) -1 << width;\n \n-  return GEN_INT (cval);\n+  return cval;\n }\n \n+/* ??? We don't know how zero / sign extension is handled, hence we\n+   can't go from a narrower to a wider mode.  */\n+#define MODES_OK_FOR_MOVE2ADD(OUTMODE, INMODE) \\\n+  (GET_MODE_SIZE (OUTMODE) == GET_MODE_SIZE (INMODE) \\\n+   || (GET_MODE_SIZE (OUTMODE) <= GET_MODE_SIZE (INMODE) \\\n+       && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \\\n+\t\t\t\t GET_MODE_BITSIZE (INMODE))))\n+\n static void\n reload_cse_move2add (first)\n      rtx first;\n {\n   int i;\n   rtx insn;\n-  int last_label_luid;\n \n   for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n     reg_set_luid[i] = 0;\n \n-  last_label_luid = 0;\n-  move2add_luid = 1;\n+  move2add_last_label_luid = 0;\n+  move2add_luid = 2;\n   for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n     {\n       rtx pat, note;\n \n       if (GET_CODE (insn) == CODE_LABEL)\n-\tlast_label_luid = move2add_luid;\n+\t{\n+\t  move2add_last_label_luid = move2add_luid;\n+\t  /* We're going to increment move2add_luid twice after a\n+\t     label, so that we can use move2add_last_label_luid + 1 as\n+\t     the luid for constants.  */\n+\t  move2add_luid++;\n+\t  continue;\n+\t}\n       if (! INSN_P (insn))\n \tcontinue;\n       pat = PATTERN (insn);\n@@ -9029,16 +9045,8 @@ reload_cse_move2add (first)\n \n \t  /* Check if we have valid information on the contents of this\n \t     register in the mode of REG.  */\n-\t  /* ??? We don't know how zero / sign extension is handled, hence\n-\t     we can't go from a narrower to a wider mode.  */\n-\t  if (reg_set_luid[regno] > last_label_luid\n-\t      && ((GET_MODE_SIZE (GET_MODE (reg))\n-\t\t   == GET_MODE_SIZE (reg_mode[regno]))\n-\t\t  || ((GET_MODE_SIZE (GET_MODE (reg))\n-\t\t       <= GET_MODE_SIZE (reg_mode[regno]))\n-\t\t      && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE (reg)),\n-\t\t\t\t\t\tGET_MODE_BITSIZE (reg_mode[regno]))))\n-\t      && GET_CODE (reg_offset[regno]) == CONST_INT)\n+\t  if (reg_set_luid[regno] > move2add_last_label_luid\n+\t      && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno]))\n \t    {\n \t      /* Try to transform (set (REGX) (CONST_INT A))\n \t\t\t\t  ...\n@@ -9051,9 +9059,9 @@ reload_cse_move2add (first)\n \t      if (GET_CODE (src) == CONST_INT && reg_base_reg[regno] < 0)\n \t\t{\n \t\t  int success = 0;\n-\t\t  rtx new_src\n-\t\t    = gen_mode_int (GET_MODE (reg),\n-\t\t\t\t    INTVAL (src) - INTVAL (reg_offset[regno]));\n+\t\t  rtx new_src = GEN_INT (sext_for_mode (GET_MODE (reg),\n+\t\t\t\t\t\t\tINTVAL (src)\n+\t\t\t\t\t\t\t- reg_offset[regno]));\n \t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n \t\t     use (set (reg) (reg)) instead.\n \t\t     We don't delete this insn, nor do we convert it into a\n@@ -9068,7 +9076,7 @@ reload_cse_move2add (first)\n \t\t\t\t\t       gen_add2_insn (reg, new_src), 0);\n \t\t  reg_set_luid[regno] = move2add_luid;\n \t\t  reg_mode[regno] = GET_MODE (reg);\n-\t\t  reg_offset[regno] = src;\n+\t\t  reg_offset[regno] = INTVAL (src);\n \t\t  continue;\n \t\t}\n \n@@ -9083,25 +9091,29 @@ reload_cse_move2add (first)\n \t\t\t\t  ...\n \t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */\n \t      else if (GET_CODE (src) == REG\n-\t\t       && reg_base_reg[regno] == (int) REGNO (src)\n-\t\t       && reg_set_luid[regno] > reg_set_luid[REGNO (src)])\n+\t\t       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]\n+\t\t       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]\n+\t\t       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),\n+\t\t\t\t\t\t reg_mode[REGNO (src)]))\n \t\t{\n \t\t  rtx next = next_nonnote_insn (insn);\n \t\t  rtx set = NULL_RTX;\n \t\t  if (next)\n \t\t    set = single_set (next);\n-\t\t  if (next\n-\t\t      && set\n+\t\t  if (set\n \t\t      && SET_DEST (set) == reg\n \t\t      && GET_CODE (SET_SRC (set)) == PLUS\n \t\t      && XEXP (SET_SRC (set), 0) == reg\n \t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n \t\t    {\n \t\t      rtx src3 = XEXP (SET_SRC (set), 1);\n-\t\t      rtx new_src\n-\t\t\t= gen_mode_int (GET_MODE (reg),\n-\t\t\t\t\tINTVAL (src3)\n-\t\t\t\t\t- INTVAL (reg_offset[regno]));\n+\t\t      HOST_WIDE_INT added_offset = INTVAL (src3);\n+\t\t      HOST_WIDE_INT base_offset = reg_offset[REGNO (src)];\n+\t\t      HOST_WIDE_INT regno_offset = reg_offset[regno];\n+\t\t      rtx new_src = GEN_INT (sext_for_mode (GET_MODE (reg),\n+\t\t\t\t\t\t\t    added_offset\n+\t\t\t\t\t\t\t    + base_offset\n+\t\t\t\t\t\t\t    - regno_offset));\n \t\t      int success = 0;\n \n \t\t      if (new_src == const0_rtx)\n@@ -9124,9 +9136,10 @@ reload_cse_move2add (first)\n \t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t\t}\n \t\t      insn = next;\n-\t\t      reg_set_luid[regno] = move2add_luid;\n \t\t      reg_mode[regno] = GET_MODE (reg);\n-\t\t      reg_offset[regno] = src3;\n+\t\t      reg_offset[regno] = sext_for_mode (GET_MODE (reg),\n+\t\t\t\t\t\t\t added_offset\n+\t\t\t\t\t\t\t + base_offset);\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -9138,14 +9151,10 @@ reload_cse_move2add (first)\n \t  if (REG_NOTE_KIND (note) == REG_INC\n \t      && GET_CODE (XEXP (note, 0)) == REG)\n \t    {\n-\t      /* Indicate that this register has been recently written to,\n-\t\t but the exact contents are not available.  */\n+\t      /* Reset the information about this register.  */\n \t      int regno = REGNO (XEXP (note, 0));\n \t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  reg_set_luid[regno] = move2add_luid;\n-\t\t  reg_offset[regno] = note;\n-\t\t}\n+\t\treg_set_luid[regno] = 0;\n \t    }\n \t}\n       note_stores (PATTERN (insn), move2add_note_store, NULL);\n@@ -9156,10 +9165,8 @@ reload_cse_move2add (first)\n \t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n \t    {\n \t      if (call_used_regs[i])\n-\t\t{\n-\t\t  reg_set_luid[i] = move2add_luid;\n-\t\t  reg_offset[i] = insn;\t/* Invalidate contents.  */\n-\t\t}\n+\t\t/* Reset the information about this register.  */\n+\t\treg_set_luid[i] = 0;\n \t    }\n \t}\n     }\n@@ -9191,11 +9198,7 @@ move2add_note_store (dst, set, data)\n       dst = XEXP (dst, 0);\n       if (GET_CODE (dst) == PRE_INC || GET_CODE (dst) == POST_DEC\n \t  || GET_CODE (dst) == PRE_DEC || GET_CODE (dst) == POST_DEC)\n-\t{\n-\t  regno = REGNO (XEXP (dst, 0));\n-\t  reg_set_luid[regno] = move2add_luid;\n-\t  reg_offset[regno] = dst;\n-\t}\n+\treg_set_luid[REGNO (XEXP (dst, 0))] = 0;\n       return;\n     }\n   if (GET_CODE (dst) != REG)\n@@ -9209,54 +9212,106 @@ move2add_note_store (dst, set, data)\n       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n     {\n       rtx src = SET_SRC (set);\n+      rtx base_reg;\n+      HOST_WIDE_INT offset;\n+      int base_regno;\n+      /* This may be different from mode, if SET_DEST (set) is a\n+\t SUBREG.  */\n+      enum machine_mode dst_mode = GET_MODE (dst);\n \n-      reg_mode[regno] = mode;\n       switch (GET_CODE (src))\n \t{\n \tcase PLUS:\n-\t  {\n-\t    rtx src0 = XEXP (src, 0);\n-\n-\t    if (GET_CODE (src0) == REG)\n-\t      {\n-\t\tif (REGNO (src0) != regno\n-\t\t    || reg_offset[regno] != const0_rtx)\n-\t\t  reg_base_reg[regno] = REGNO (src0);\n+\t  if (GET_CODE (XEXP (src, 0)) == REG)\n+\t    {\n+\t      base_reg = XEXP (src, 0);\n+\n+\t      if (GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\toffset = INTVAL (XEXP (src, 1));\n+\t      else if (GET_CODE (XEXP (src, 1)) == REG\n+\t\t       && (reg_set_luid[REGNO (XEXP (src, 1))]\n+\t\t\t   > move2add_last_label_luid)\n+\t\t       && (MODES_OK_FOR_MOVE2ADD\n+\t\t\t   (dst_mode, reg_mode[REGNO (XEXP (src, 1))])))\n+\t\t{\n+\t\t  if (reg_base_reg[REGNO (XEXP (src, 1))] < 0)\n+\t\t    offset = reg_offset[REGNO (XEXP (src, 1))];\n+\t\t  /* Maybe the first register is known to be a\n+\t\t     constant.  */\n+\t\t  else if (reg_set_luid[REGNO (base_reg)]\n+\t\t\t   > move2add_last_label_luid\n+\t\t\t   && (MODES_OK_FOR_MOVE2ADD\n+\t\t\t       (dst_mode, reg_mode[REGNO (XEXP (src, 1))]))\n+\t\t\t   && reg_base_reg[REGNO (base_reg)] < 0)\n+\t\t    {\n+\t\t      offset = reg_offset[REGNO (base_reg)];\n+\t\t      base_reg = XEXP (src, 1);\n+\t\t    }\n+\t\t  else\n+\t\t    goto invalidate;\n+\t\t}\n+\t      else\n+\t\tgoto invalidate;\n \n-\t\treg_set_luid[regno] = move2add_luid;\n-\t\treg_offset[regno] = XEXP (src, 1);\n-\t\tbreak;\n-\t      }\n+\t      break;\n+\t    }\n \n-\t    reg_set_luid[regno] = move2add_luid;\n-\t    reg_offset[regno] = set;\t/* Invalidate contents.  */\n-\t    break;\n-\t  }\n+\t  goto invalidate;\n \n \tcase REG:\n-\t  reg_base_reg[regno] = REGNO (SET_SRC (set));\n-\t  reg_offset[regno] = const0_rtx;\n-\t  reg_set_luid[regno] = move2add_luid;\n+\t  base_reg = src;\n+\t  offset = 0;\n \t  break;\n \n-\tdefault:\n+\tcase CONST_INT:\n+\t  /* Start tracking the register as a constant.  */\n \t  reg_base_reg[regno] = -1;\n-\t  reg_offset[regno] = SET_SRC (set);\n-\t  reg_set_luid[regno] = move2add_luid;\n-\t  break;\n+\t  reg_offset[regno] = INTVAL (SET_SRC (set));\n+\t  /* We assign the same luid to all registers set to constants.  */\n+\t  reg_set_luid[regno] = move2add_last_label_luid + 1;\n+\t  reg_mode[regno] = mode;\n+\t  return;\n+\t  \n+\tdefault:\n+\tinvalidate:\n+\t  /* Invalidate the contents of the register.  */\n+\t  reg_set_luid[regno] = 0;\n+\t  return;\n \t}\n+\n+      base_regno = REGNO (base_reg);\n+      /* If information about the base register is not valid, set it\n+\t up as a new base register, pretending its value is known\n+\t starting from the current insn.  */\n+      if (reg_set_luid[base_regno] <= move2add_last_label_luid)\n+\t{\n+\t  reg_base_reg[base_regno] = base_regno;\n+\t  reg_offset[base_regno] = 0;\n+\t  reg_set_luid[base_regno] = move2add_luid;\n+\t  reg_mode[base_regno] = mode;\n+\t}\n+      else if (! MODES_OK_FOR_MOVE2ADD (dst_mode,\n+\t\t\t\t\treg_mode[base_regno]))\n+\tgoto invalidate;\n+\n+      reg_mode[regno] = mode;\n+\n+      /* Copy base information from our base register.  */\n+      reg_set_luid[regno] = reg_set_luid[base_regno];\n+      reg_base_reg[regno] = reg_base_reg[base_regno];\n+\n+      /* Compute the sum of the offsets or constants.  */\n+      reg_offset[regno] = sext_for_mode (dst_mode,\n+\t\t\t\t\t offset\n+\t\t\t\t\t + reg_offset[base_regno]);\n     }\n   else\n     {\n       unsigned int endregno = regno + HARD_REGNO_NREGS (regno, mode);\n \n       for (i = regno; i < endregno; i++)\n-\t{\n-\t  /* Indicate that this register has been recently written to,\n-\t     but the exact contents are not available.  */\n-\t  reg_set_luid[i] = move2add_luid;\n-\t  reg_offset[i] = dst;\n-\t}\n+\t/* Reset the information about this register.  */\n+\treg_set_luid[i] = 0;\n     }\n }\n "}]}