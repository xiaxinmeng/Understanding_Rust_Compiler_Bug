{"sha": "3d9784cb6fbfa0bc90b75c90c67557a136aace35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q5Nzg0Y2I2ZmJmYTBiYzkwYjc1YzkwYzY3NTU3YTEzNmFhY2UzNQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2011-07-21T22:57:40Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2011-07-21T22:57:40Z"}, "message": "Compute once and cache the LB and UB for each clast_name.\n\n2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-clast-to-gimple.c (struct clast_name_index): Add lb\n\tand ub fields.\n\t(new_clast_name_index): Add lb and ub parameters.\n\t(free_clast_name_index): New.\n\t(clast_name_to_lb_ub): New.\n\t(save_clast_name_index): Add lb and ub parameters.\n\t(compute_bounds_for_param): New.\n\t(type_for_level): Removed.\n\t(type_for_clast_for): Removed level parameter.  Do not call\n\ttype_for_level.\n\t(graphite_create_new_loop): Store the lb and ub for the clast_name\n\tof the iterator of the loop that has been generated.\n\t(graphite_create_new_loop_guard): Remove parameter level.\n\t(create_params_index): Store the lb and ub of each parameter.\n\t(gloog): Use free_clast_name_index.  Pass to create_params_index\n\tthe current scop.\n\nFrom-SVN: r176603", "tree": {"sha": "c61829c477e44899c53579483cea634511605058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c61829c477e44899c53579483cea634511605058"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d9784cb6fbfa0bc90b75c90c67557a136aace35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9784cb6fbfa0bc90b75c90c67557a136aace35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d9784cb6fbfa0bc90b75c90c67557a136aace35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d9784cb6fbfa0bc90b75c90c67557a136aace35/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12b30e6daea5c44df6cc3b9d6f03f9b11887e52a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12b30e6daea5c44df6cc3b9d6f03f9b11887e52a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12b30e6daea5c44df6cc3b9d6f03f9b11887e52a"}], "stats": {"total": 163, "additions": 121, "deletions": 42}, "files": [{"sha": "d3921eda98f88ebbc972cac4a021595fcd1a700b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9784cb6fbfa0bc90b75c90c67557a136aace35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9784cb6fbfa0bc90b75c90c67557a136aace35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d9784cb6fbfa0bc90b75c90c67557a136aace35", "patch": "@@ -1,3 +1,22 @@\n+2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (struct clast_name_index): Add lb\n+\tand ub fields.\n+\t(new_clast_name_index): Add lb and ub parameters.\n+\t(free_clast_name_index): New.\n+\t(clast_name_to_lb_ub): New.\n+\t(save_clast_name_index): Add lb and ub parameters.\n+\t(compute_bounds_for_param): New.\n+\t(type_for_level): Removed.\n+\t(type_for_clast_for): Removed level parameter.  Do not call\n+\ttype_for_level.\n+\t(graphite_create_new_loop): Store the lb and ub for the clast_name\n+\tof the iterator of the loop that has been generated.\n+\t(graphite_create_new_loop_guard): Remove parameter level.\n+\t(create_params_index): Store the lb and ub of each parameter.\n+\t(gloog): Use free_clast_name_index.  Pass to create_params_index\n+\tthe current scop.\n+\n 2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (max_signed_precision_type): Removed."}, {"sha": "6bc84d2a4b236333723a46da3395e8e705607330", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 102, "deletions": 42, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d9784cb6fbfa0bc90b75c90c67557a136aace35/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d9784cb6fbfa0bc90b75c90c67557a136aace35/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=3d9784cb6fbfa0bc90b75c90c67557a136aace35", "patch": "@@ -57,28 +57,46 @@ graphite_verify (void)\n }\n \n /* Stores the INDEX in a vector and the loop nesting LEVEL for a given\n-   clast NAME.  */\n+   clast NAME.  LB and UB represent the exact lower and upper bounds\n+   that can be inferred from the polyhedral representation.  */\n \n typedef struct clast_name_index {\n   int index;\n   int level;\n+  mpz_t lb, ub;\n   const char *name;\n } *clast_name_index_p;\n \n /* Returns a pointer to a new element of type clast_name_index_p built\n-   from NAME, LEVEL, and INDEX.  */\n+   from NAME, INDEX, LEVEL, LB, and UB.  */\n \n static inline clast_name_index_p\n-new_clast_name_index (const char *name, int index, int level)\n+new_clast_name_index (const char *name, int index, int level,\n+\t\t      mpz_t lb, mpz_t ub)\n {\n   clast_name_index_p res = XNEW (struct clast_name_index);\n \n   res->name = name;\n   res->level = level;\n   res->index = index;\n+  mpz_init (res->lb);\n+  mpz_init (res->ub);\n+  mpz_set (res->lb, lb);\n+  mpz_set (res->ub, ub);\n   return res;\n }\n \n+/* Free the memory taken by a clast_name_index struct.  */\n+\n+static void\n+free_clast_name_index (void *ptr)\n+{\n+  struct clast_name_index *c = (struct clast_name_index *) ptr;\n+  mpz_clear (c->lb);\n+  mpz_clear (c->ub);\n+  free (ptr);\n+}\n+\n /* For a given clast NAME, returns -1 if NAME is not in the\n    INDEX_TABLE, otherwise returns the loop level for the induction\n    variable NAME, or if it is a parameter, the parameter number in the\n@@ -130,11 +148,40 @@ clast_name_to_index (clast_name_p name, htab_t index_table)\n   return -1;\n }\n \n+/* For a given clast NAME, initializes the lower and upper bounds LB\n+   and UB stored in the INDEX_TABLE.  Returns true when NAME has been\n+   found in the INDEX_TABLE, false otherwise.  */\n+\n+static inline bool\n+clast_name_to_lb_ub (clast_name_p name, htab_t index_table, mpz_t lb, mpz_t ub)\n+{\n+  struct clast_name_index tmp;\n+  PTR *slot;\n+\n+#ifdef CLOOG_ORG\n+  gcc_assert (name->type == clast_expr_name);\n+  tmp.name = ((const struct clast_name *) name)->name;\n+#else\n+  tmp.name = name;\n+#endif\n+\n+  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    {\n+      mpz_set (lb, ((struct clast_name_index *) *slot)->lb);\n+      mpz_set (ub, ((struct clast_name_index *) *slot)->ub);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Records in INDEX_TABLE the INDEX and LEVEL for NAME.  */\n \n static inline void\n save_clast_name_index (htab_t index_table, const char *name,\n-\t\t       int index, int level)\n+\t\t       int index, int level, mpz_t lb, mpz_t ub)\n {\n   struct clast_name_index tmp;\n   PTR *slot;\n@@ -146,7 +193,7 @@ save_clast_name_index (htab_t index_table, const char *name,\n     {\n       free (*slot);\n \n-      *slot = new_clast_name_index (name, index, level);\n+      *slot = new_clast_name_index (name, index, level, lb, ub);\n     }\n }\n \n@@ -579,6 +626,24 @@ graphite_create_new_guard (edge entry_edge, struct clast_guard *stmt,\n   return exit_edge;\n }\n \n+/* Compute the lower bound LOW and upper bound UP for the parameter\n+   PARAM in scop SCOP based on the constraints in the context.  */\n+\n+static void\n+compute_bounds_for_param (scop_p scop, int param, mpz_t low, mpz_t up)\n+{\n+  ppl_Linear_Expression_t le;\n+\n+  /* Prepare the linear expression corresponding to the parameter that\n+     we want to maximize/minimize.  */\n+  ppl_new_Linear_Expression_with_dimension (&le, scop_nb_params (scop));\n+  ppl_set_coef (le, param, 1);\n+\n+  ppl_max_for_le_pointset (SCOP_CONTEXT (scop), le, up);\n+  ppl_min_for_le_pointset (SCOP_CONTEXT (scop), le, low);\n+  ppl_delete_Linear_Expression (le);\n+}\n+\n /* Compute the lower bound LOW and upper bound UP for the induction\n    variable at LEVEL for the statement PBB, based on the transformed\n    scattering of PBB: T|I|G|Cst, with T the scattering transform, I\n@@ -608,26 +673,6 @@ compute_bounds_for_level (poly_bb_p pbb, int level, mpz_t low, mpz_t up)\n   ppl_delete_Pointset_Powerset_C_Polyhedron (ps);\n }\n \n-/* Compute the type for the induction variable at LEVEL for the\n-   statement PBB, based on the transformed schedule of PBB.  */\n-\n-static tree\n-type_for_level (poly_bb_p pbb, int level)\n-{\n-  mpz_t low, up;\n-  tree type;\n-\n-  mpz_init (low);\n-  mpz_init (up);\n-\n-  compute_bounds_for_level (pbb, level, low, up);\n-  type = type_for_interval (low, up);\n-\n-  mpz_clear (low);\n-  mpz_clear (up);\n-  return type;\n-}\n-\n /* Walks a CLAST and returns the first statement in the body of a\n    loop.\n \n@@ -671,18 +716,12 @@ clast_get_body_of_loop (struct clast_stmt *stmt)\n    from STMT_FOR.  */\n \n static tree\n-type_for_clast_for (struct clast_for *stmt_for, int level,\n-\t\t    ivs_params_p ip)\n+type_for_clast_for (struct clast_for *stmt_for, ivs_params_p ip)\n {\n-  struct clast_stmt *stmt = (struct clast_stmt *) stmt_for;\n-  struct clast_user_stmt *body = clast_get_body_of_loop (stmt);\n-  CloogStatement *cs = body->statement;\n-  poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n   tree lb_type = type_for_clast_expr (stmt_for->LB, ip);\n   tree ub_type = type_for_clast_expr (stmt_for->UB, ip);\n \n-  return max_precision_type\n-    (lb_type, max_precision_type (ub_type, type_for_level (pbb, level)));\n+  return max_precision_type (lb_type, ub_type);\n }\n \n /* Creates a new LOOP corresponding to Cloog's STMT.  Inserts an\n@@ -698,6 +737,12 @@ graphite_create_new_loop (edge entry_edge, struct clast_for *stmt,\n \t\t\t  loop_p outer, tree type, tree lb, tree ub,\n \t\t\t  int level, ivs_params_p ip)\n {\n+  mpz_t low, up;\n+\n+  struct clast_user_stmt *body\n+    = clast_get_body_of_loop ((struct clast_stmt *) stmt);\n+  poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (body->statement);\n+\n   tree stride = gmp_cst_to_tree (type, stmt->stride);\n   tree ivvar = create_tmp_var (type, \"graphite_IV\");\n   tree iv, iv_after_increment;\n@@ -707,8 +752,13 @@ graphite_create_new_loop (edge entry_edge, struct clast_for *stmt,\n \n   add_referenced_var (ivvar);\n \n+  mpz_init (low);\n+  mpz_init (up);\n+  compute_bounds_for_level (pbb, level, low, up);\n   save_clast_name_index (ip->newivs_index, stmt->iterator,\n-\t\t\t VEC_length (tree, *(ip->newivs)), level);\n+\t\t\t VEC_length (tree, *(ip->newivs)), level, low, up);\n+  mpz_clear (low);\n+  mpz_clear (up);\n   VEC_safe_push (tree, heap, *(ip->newivs), iv);\n   return loop;\n }\n@@ -862,13 +912,13 @@ translate_clast_user (struct clast_user_stmt *stmt, edge next_e,\n \n static edge\n graphite_create_new_loop_guard (edge entry_edge, struct clast_for *stmt,\n-\t\t\t\tint level, tree *type, tree *lb, tree *ub,\n+\t\t\t\ttree *type, tree *lb, tree *ub,\n \t\t\t\tivs_params_p ip)\n {\n   tree cond_expr;\n   edge exit_edge;\n \n-  *type = type_for_clast_for (stmt, level, ip);\n+  *type = type_for_clast_for (stmt, ip);\n   *lb = clast_to_gcc_expression (*type, stmt->LB, ip);\n   *ub = clast_to_gcc_expression (*type, stmt->UB, ip);\n \n@@ -943,7 +993,7 @@ translate_clast_for (loop_p context_loop, struct clast_for *stmt, edge next_e,\n \t\t     htab_t bb_pbb_mapping, int level, ivs_params_p ip)\n {\n   tree type, lb, ub;\n-  edge last_e = graphite_create_new_loop_guard (next_e, stmt, level, &type,\n+  edge last_e = graphite_create_new_loop_guard (next_e, stmt, &type,\n \t\t\t\t\t\t&lb, &ub, ip);\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n \n@@ -1361,14 +1411,24 @@ debug_generated_program (scop_p scop)\n    back from CLooG names to GCC trees.  */\n \n static void\n-create_params_index (htab_t index_table, CloogProgram *prog) {\n+create_params_index (scop_p scop, htab_t index_table, CloogProgram *prog) {\n   CloogNames* names = cloog_program_names (prog);\n   int nb_parameters = cloog_names_nb_parameters (names);\n   char **parameters = cloog_names_parameters (names);\n   int i;\n+  mpz_t lb, ub;\n+\n+  mpz_init (lb);\n+  mpz_init (ub);\n \n   for (i = 0; i < nb_parameters; i++)\n-    save_clast_name_index (index_table, parameters[i], i, i);\n+    {\n+      compute_bounds_for_param (scop, i, lb, ub);\n+      save_clast_name_index (index_table, parameters[i], i, i, lb, ub);\n+    }\n+\n+  mpz_clear (lb);\n+  mpz_clear (ub);\n }\n \n /* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n@@ -1412,11 +1472,11 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n \n   context_loop = SESE_ENTRY (region)->src->loop_father;\n   newivs_index = htab_create (10, clast_name_index_elt_info,\n-\t\t\t      eq_clast_name_indexes, free);\n+\t\t\t      eq_clast_name_indexes, free_clast_name_index);\n   params_index = htab_create (10, clast_name_index_elt_info,\n-\t\t\t      eq_clast_name_indexes, free);\n+\t\t\t      eq_clast_name_indexes, free_clast_name_index);\n \n-  create_params_index (params_index, pc.prog);\n+  create_params_index (scop, params_index, pc.prog);\n \n   ip.newivs = &newivs;\n   ip.newivs_index = newivs_index;"}]}