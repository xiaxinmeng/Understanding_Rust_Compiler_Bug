{"sha": "85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmMjliM2JiNTM3NThmYWIzY2NhYWU5ODIzYzliMTM1YTI1ZTBmMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-01T20:48:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-01T20:48:52Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r30327,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r30328", "tree": {"sha": "5bb7e8782dbfa25b10b5b552d7e4dd7031e8900c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb7e8782dbfa25b10b5b552d7e4dd7031e8900c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/comments", "author": null, "committer": null, "parents": [{"sha": "fd6a6309db035c41f8a280d7acc75437cb7d5e43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6a6309db035c41f8a280d7acc75437cb7d5e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd6a6309db035c41f8a280d7acc75437cb7d5e43"}], "stats": {"total": 505, "additions": 428, "deletions": 77}, "files": [{"sha": "926089e86fbb18567aa48981aa68dc152f1e7b76", "filename": "boehm-gc/cord/cord.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fcord%2Fcord.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fcord%2Fcord.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcord.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -41,7 +41,7 @@\n  * This interface is fairly big, largely for performance reasons.\n  * The most basic constants and functions:\n  *\n- * CORD - the type fo a cord;\n+ * CORD - the type of a cord;\n  * CORD_EMPTY - empty cord;\n  * CORD_len(cord) - length of a cord;\n  * CORD_cat(cord1,cord2) - concatenation of two cords;"}, {"sha": "a5be10de58aed4ccd249f46ac036f0793d75d698", "filename": "boehm-gc/cord/cordxtra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fcord%2Fcordxtra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fcord%2Fcordxtra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordxtra.c?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -582,7 +582,7 @@ CORD CORD_from_file_lazy_inner(FILE * f, size_t len)\n         state -> lf_cache[i] = 0;\n     }\n     state -> lf_current = 0;\n-    GC_register_finalizer(state, CORD_lf_close_proc, 0, 0, 0);\n+    GC_REGISTER_FINALIZER(state, CORD_lf_close_proc, 0, 0, 0);\n     return(CORD_from_fn(CORD_lf_func, state, len));\n }\n "}, {"sha": "cc74765d098ef28993593971faef5d5105cefe2f", "filename": "boehm-gc/cord/gc.h", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fcord%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fcord%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fgc.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -58,9 +58,11 @@\n # if defined(__STDC__) || defined(__cplusplus)\n #   define GC_PROTO(args) args\n     typedef void * GC_PTR;\n+#   define GC_CONST const\n # else\n #   define GC_PROTO(args) ()\n     typedef char * GC_PTR;\n+#   define GC_CONST\n #  endif\n \n # ifdef __cplusplus\n@@ -96,11 +98,31 @@ GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n \t\t\t/* pointer to a previously allocated heap \t*/\n \t\t\t/* object.\t\t\t\t\t*/\n \n+GC_API int GC_find_leak;\n+\t\t\t/* Do not actually garbage collect, but simply\t*/\n+\t\t\t/* report inaccessible memory that was not\t*/\n+\t\t\t/* deallocated with GC_free.  Initial value\t*/\n+\t\t\t/* is determined by FIND_LEAK macro.\t\t*/\n+\n GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n \t\t\t/* collector has been compiled with statistics\t*/\n \t\t\t/* enabled.  This involves a performance cost,\t*/\n \t\t\t/* and is thus not the default.\t\t\t*/\n \n+GC_API int GC_finalize_on_demand;\n+\t\t\t/* If nonzero, finalizers will only be run in \t*/\n+\t\t\t/* response to an eplit GC_invoke_finalizers\t*/\n+\t\t\t/* call.  The default is determined by whether\t*/\n+\t\t\t/* the FINALIZE_ON_DEMAND macro is defined\t*/\n+\t\t\t/* when the collector is built.\t\t\t*/\n+\n+GC_API int GC_java_finalization;\n+\t\t\t/* Mark objects reachable from finalizable \t*/\n+\t\t\t/* objects in a separate postpass.  This makes\t*/\n+\t\t\t/* it a bit safer to use non-topologically-\t*/\n+\t\t\t/* ordered finalization.  Default value is\t*/\n+\t\t\t/* determined by JAVA_FINALIZATION macro.\t*/\n+\n GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n \t\t\t/* because it's not safe.\t\t\t  */\n \n@@ -111,6 +133,12 @@ GC_API int GC_dont_expand;\n GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n \t\t\t    /* full collections.  Matters only if\t*/\n \t\t\t    /* GC_incremental is set.\t\t\t*/\n+\t\t\t    /* Full collections are also triggered if\t*/\n+\t\t\t    /* the collector detects a substantial\t*/\n+\t\t\t    /* increase in the number of in-use heap\t*/\n+\t\t\t    /* blocks.  Values in the tens are now\t*/\n+\t\t\t    /* perfectly reasonable, unlike for\t\t*/\n+\t\t\t    /* earlier GC versions.\t\t\t*/\n \t\t\t\n GC_API GC_word GC_non_gc_bytes;\n \t\t\t/* Bytes not considered candidates for collection. */\n@@ -277,6 +305,9 @@ GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n /* Includes some pages that were allocated but never written.\t\t*/\n GC_API size_t GC_get_heap_size GC_PROTO((void));\n \n+/* Return a lower bound on the number of free bytes in the heap.\t*/\n+GC_API size_t GC_get_free_bytes GC_PROTO((void));\n+\n /* Return the number of bytes allocated since the last collection.\t*/\n GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n \n@@ -321,10 +352,11 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * descr_string,\n+\t\t          int descr_int\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_CONST char * descr_string, int descr_int\n #endif\n \n /* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n@@ -510,7 +542,7 @@ GC_API int GC_invoke_finalizers GC_PROTO((void));\n \t/* be finalized.  Return the number of finalizers\t*/\n \t/* that were run.  Normally this is also called\t\t*/\n \t/* implicitly during some allocations.\tIf\t\t*/\n-\t/* FINALIZE_ON_DEMAND is defined, it must be called\t*/\n+\t/* GC-finalize_on_demand is nonzero, it must be called\t*/\n \t/* explicitly.\t\t\t\t\t\t*/\n \n /* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n@@ -668,7 +700,7 @@ GC_API void (*GC_is_visible_print_proc)\n # endif /* SOLARIS_THREADS */\n \n \n-#if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n /* We treat these similarly. */\n # include <pthread.h>\n # include <signal.h>\n@@ -687,11 +719,12 @@ GC_API void (*GC_is_visible_print_proc)\n \n # if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS)\n+\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n    \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/\n+/* lb must be large enough to hold the pointer field.\t\t\t*/\n GC_PTR GC_malloc_many(size_t lb);\n #define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n \t\t\t\t\t/* in returned list.\t\t*/"}, {"sha": "a70010898d121dafd4f2a5bec183cf5cf259979c", "filename": "boehm-gc/gcconfig.h", "status": "modified", "additions": 138, "deletions": 16, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcconfig.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -43,11 +43,21 @@\n #    define OPENBSD\n #    define mach_type_known\n # endif\n+# if defined(__OpenBSD__) && defined(__sparc__)\n+#    define SPARC\n+#    define OPENBSD\n+#    define mach_type_known\n+# endif\n # if defined(__NetBSD__) && defined(m68k)\n #    define M68K\n #    define NETBSD\n #    define mach_type_known\n # endif\n+# if defined(__NetBSD__) && defined(arm32)\n+#    define ARM32\n+#    define NETBSD\n+#    define mach_type_known\n+# endif\n # if defined(vax)\n #    define VAX\n #    ifdef ultrix\n@@ -100,7 +110,8 @@\n #     endif\n #   define mach_type_known\n # endif\n-# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux)\n+# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \\\n+     && !defined(__OpenBSD__)\n #   define SPARC\n #   define DRSNX\n #   define mach_type_known\n@@ -124,15 +135,22 @@\n #   define SYSV\n #   define mach_type_known\n # endif\n-# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) \\\n+# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \\\n      || defined(hppa) || defined(__hppa__)\n #   define HP_PA\n+#   ifndef LINUX\n+#     define HPUX\n+#   endif\n #   define mach_type_known\n # endif\n-# if defined(LINUX) && defined(i386)\n+# if defined(LINUX) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define mach_type_known\n # endif\n+# if defined(LINUX) && (defined(__ia64__) || defined(__ia64))\n+#    define IA64\n+#    define mach_type_known\n+# endif\n # if defined(LINUX) && defined(powerpc)\n #    define POWERPC\n #    define mach_type_known\n@@ -141,9 +159,8 @@\n #    define M68K\n #    define mach_type_known\n # endif\n-# if defined(linux) && defined(sparc)\n+# if defined(LINUX) && defined(sparc)\n #    define SPARC\n-#    define LINUX\n #    define mach_type_known\n # endif\n # if defined(__alpha) || defined(__alpha__)\n@@ -153,9 +170,11 @@\n #   endif\n #   define mach_type_known\n # endif\n-# if defined(_AMIGA)\n-#   define M68K\n+# if defined(_AMIGA) && !defined(AMIGA)\n #   define AMIGA\n+# endif\n+# ifdef AMIGA \n+#   define M68K\n #   define mach_type_known\n # endif\n # if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n@@ -168,6 +187,11 @@\n #   define MACOS\n #   define mach_type_known\n # endif\n+# if defined(macosx)\n+#    define MACOSX\n+#    define POWERPC\n+#    define mach_type_known\n+# endif\n # if defined(NeXT) && defined(mc68000)\n #   define M68K\n #   define NEXT\n@@ -241,6 +265,10 @@\n #   define UTS4\n #   define mach_type_known\n # endif\n+# if defined(__pj__)\n+#   define PJ\n+#   define mach_type_known\n+# endif\n /* Ivan Demakov */\n # if defined(__WATCOMC__) && defined(__386__)\n #   define I386\n@@ -486,8 +514,8 @@\n \n # ifdef POWERPC\n #   define MACH_TYPE \"POWERPC\"\n-#   define ALIGNMENT 2\n #   ifdef MACOS\n+#     define ALIGNMENT 2  /* Still necessary?  Could it be 4?\t*/\n #     ifndef __LOWMEM__\n #     include <LowMem.h>\n #     endif\n@@ -497,14 +525,29 @@\n #     define DATAEND  /* not needed */\n #   endif\n #   ifdef LINUX\n+#     define ALIGNMENT 4\t/* Guess.  Can someone verify?\t*/\n+\t\t\t\t/* This was 2, but that didn't sound right. */\n #     define OS_TYPE \"LINUX\"\n #     define HEURISTIC1\n #     undef STACK_GRAN\n #     define STACK_GRAN 0x10000000\n+\t/* Stack usually starts at 0x80000000 */\n #     define DATASTART GC_data_start\n+\t/* Others have reported better success with */\n+        /*  \textern int __data_start;\t    */\n+\t/*#     define DATASTART (&__data_start)    */\n+\t/* and disabling the GC_data_start\t    */\n+\t/* initialization code.\t\t\t    */\n       extern int _end;\n #     define DATAEND (&_end)\n #   endif\n+#   ifdef MACOSX\n+#     define ALIGNMENT 4\n+#     define OS_TYPE \"MACOSX\"\n+#     define DATASTART ((ptr_t) get_etext())\n+#     define STACKBOTTOM ((ptr_t) 0xc0000000)\n+#     define DATAEND\t/* not needed */\n+#   endif\n # endif\n \n # ifdef VAX\n@@ -603,6 +646,11 @@\n #     define SVR4\n #     define STACKBOTTOM ((ptr_t) 0xf0000000)\n #   endif\n+#   ifdef OPENBSD\n+#     define OS_TYPE \"OPENBSD\"\n+#     define STACKBOTTOM ((ptr_t) 0xf8000000)\n+#     define DATASTART ((ptr_t)(&etext))\n+#   endif\n # endif\n \n # ifdef I386\n@@ -657,10 +705,13 @@\n #   endif\n #   ifdef LINUX\n #\tdefine OS_TYPE \"LINUX\"\n-#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n-\t/* Appears to be 0xe0000000 for at least one 2.1.91 kernel.\t*/\n-\t/* Probably needs to be more flexible, but I don't yet \t\t*/\n-\t/* fully understand how flexible.\t\t\t\t*/\n+#       define HEURISTIC1\n+#       undef STACK_GRAN\n+#       define STACK_GRAN 0x10000000\n+\t/* STACKBOTTOM is usually 0xc0000000, but this changes with\t*/\n+\t/* different kernel configurations.  In particular, systems\t*/\n+\t/* with 2GB physical memory will usually move the user\t\t*/\n+\t/* address space limit, and hence initial SP to 0x80000000.\t*/\n #       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n #\t    define MPROTECT_VDB\n #\telse\n@@ -862,9 +913,17 @@\n # endif\n \n # ifdef HP_PA\n+    /* OS is assumed to be HP/UX\t*/\n #   define MACH_TYPE \"HP_PA\"\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n+#   define OS_TYPE \"HPUX\"\n+#   ifdef __LP64__\n+#     define CPP_WORDSZ 64\n+#     define ALIGNMENT 8\n+#   else\n+#     define CPP_WORDSZ 32\n+#     define ALIGNMENT 4\n+#     define ALIGN_DOUBLE\n+#   endif\n     extern int __data_start;\n #   define DATASTART ((ptr_t)(&__data_start))\n #   if 0\n@@ -881,6 +940,9 @@\n #   endif\n #   define STACK_GROWS_UP\n #   define DYNAMIC_LOADING\n+#   ifndef HPUX_THREADS\n+#     define MPROTECT_VDB\n+#   endif\n #   include <unistd.h>\n #   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n \t/* They misspelled the Posix macro?\t*/\n@@ -909,9 +971,13 @@\n #       define CPP_WORDSZ 64\n #       define STACKBOTTOM ((ptr_t) 0x120000000)\n #       ifdef __ELF__\n+#   \t  if 0\n+\t    /* __data_start apparently disappeared in some recent releases. */\n             extern int __data_start;\n #           define DATASTART &__data_start\n-#           define DYNAMIC_LOADING\n+#\t  endif\n+#         define DATASTART GC_data_start\n+#         define DYNAMIC_LOADING\n #       else\n #           define DATASTART ((ptr_t) 0x140000000)\n #       endif\n@@ -923,6 +989,31 @@\n #   endif\n # endif\n \n+# ifdef IA64\n+#   define MACH_TYPE \"IA64\"\n+#   define ALIGN_DOUBLE\n+\t/* Requires 16 byte alignment for malloc */\n+#   define ALIGNMENT 8\n+#   ifdef HPUX\n+\t--> needs work\n+#   endif\n+#   ifdef LINUX\n+#       define OS_TYPE \"LINUX\"\n+#       define CPP_WORDSZ 64\n+\t/* This should really be done through /proc, but that\t*/\n+\t/* requires we run on an IA64 kernel.\t\t\t*/\n+#       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\n+\t/* We also need the base address of the register stack\t*/\n+\t/* backing store.  There is probably a better way to\t*/\n+\t/* get that, too ...\t\t\t\t\t*/\n+#\tdefine BACKING_STORE_BASE ((ptr_t) 0x9fffffff80000000l)\n+#       define DATASTART GC_data_start\n+#       define DYNAMIC_LOADING\n+\textern int _end;\n+#\tdefine DATAEND (&_end)\n+#   endif\n+# endif\n+\n # ifdef M88K\n #   define MACH_TYPE \"M88K\"\n #   define ALIGNMENT 4\n@@ -953,6 +1044,26 @@\n #\tdefine HEURISTIC2\n # endif\n \n+# if defined(PJ)\n+#   define ALIGNMENT 4\n+    extern int _etext;\n+#   define DATASTART ((ptr_t)(&_etext))\n+#   define HEURISTIC1\n+# endif\n+\n+# ifdef ARM32\n+#   define CPP_WORDSZ 32\n+#   define MACH_TYPE \"ARM32\"\n+#   define ALIGNMENT 4\n+#   ifdef NETBSD\n+#       define OS_TYPE \"NETBSD\"\n+#       define HEURISTIC2\n+        extern char etext;\n+#       define DATASTART ((ptr_t)(&etext))\n+#       define USE_GENERIC_PUSH_REGS\n+#   endif\n+#endif\n+\n # ifndef STACK_GROWS_UP\n #   define STACK_GROWS_DOWN\n # endif\n@@ -995,6 +1106,10 @@\n #   define SUNOS5SIGS\n # endif\n \n+# if defined(HPUX)\n+#   define SUNOS5SIGS\n+# endif\n+\n # if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n    -> bad word size\n # endif\n@@ -1021,6 +1136,10 @@\n #   undef MPROTECT_VDB\n # endif\n \n+# ifdef USE_MUNMAP\n+#   undef MPROTECT_VDB  /* Can't deal with address space holes. */\n+# endif\n+\n # if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n #   define DEFAULT_VDB\n # endif\n@@ -1040,10 +1159,13 @@\n # if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n --> inconsistent configuration\n # endif\n+# if defined(HPUX_THREADS) && !defined(HPUX)\n+--> inconsistent configuration\n+# endif\n # if defined(PCR) || defined(SRC_M3) || \\\n \tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS)\n+\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n #   define THREADS\n # endif\n "}, {"sha": "cc74765d098ef28993593971faef5d5105cefe2f", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -58,9 +58,11 @@\n # if defined(__STDC__) || defined(__cplusplus)\n #   define GC_PROTO(args) args\n     typedef void * GC_PTR;\n+#   define GC_CONST const\n # else\n #   define GC_PROTO(args) ()\n     typedef char * GC_PTR;\n+#   define GC_CONST\n #  endif\n \n # ifdef __cplusplus\n@@ -96,11 +98,31 @@ GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n \t\t\t/* pointer to a previously allocated heap \t*/\n \t\t\t/* object.\t\t\t\t\t*/\n \n+GC_API int GC_find_leak;\n+\t\t\t/* Do not actually garbage collect, but simply\t*/\n+\t\t\t/* report inaccessible memory that was not\t*/\n+\t\t\t/* deallocated with GC_free.  Initial value\t*/\n+\t\t\t/* is determined by FIND_LEAK macro.\t\t*/\n+\n GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n \t\t\t/* collector has been compiled with statistics\t*/\n \t\t\t/* enabled.  This involves a performance cost,\t*/\n \t\t\t/* and is thus not the default.\t\t\t*/\n \n+GC_API int GC_finalize_on_demand;\n+\t\t\t/* If nonzero, finalizers will only be run in \t*/\n+\t\t\t/* response to an eplit GC_invoke_finalizers\t*/\n+\t\t\t/* call.  The default is determined by whether\t*/\n+\t\t\t/* the FINALIZE_ON_DEMAND macro is defined\t*/\n+\t\t\t/* when the collector is built.\t\t\t*/\n+\n+GC_API int GC_java_finalization;\n+\t\t\t/* Mark objects reachable from finalizable \t*/\n+\t\t\t/* objects in a separate postpass.  This makes\t*/\n+\t\t\t/* it a bit safer to use non-topologically-\t*/\n+\t\t\t/* ordered finalization.  Default value is\t*/\n+\t\t\t/* determined by JAVA_FINALIZATION macro.\t*/\n+\n GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n \t\t\t/* because it's not safe.\t\t\t  */\n \n@@ -111,6 +133,12 @@ GC_API int GC_dont_expand;\n GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n \t\t\t    /* full collections.  Matters only if\t*/\n \t\t\t    /* GC_incremental is set.\t\t\t*/\n+\t\t\t    /* Full collections are also triggered if\t*/\n+\t\t\t    /* the collector detects a substantial\t*/\n+\t\t\t    /* increase in the number of in-use heap\t*/\n+\t\t\t    /* blocks.  Values in the tens are now\t*/\n+\t\t\t    /* perfectly reasonable, unlike for\t\t*/\n+\t\t\t    /* earlier GC versions.\t\t\t*/\n \t\t\t\n GC_API GC_word GC_non_gc_bytes;\n \t\t\t/* Bytes not considered candidates for collection. */\n@@ -277,6 +305,9 @@ GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n /* Includes some pages that were allocated but never written.\t\t*/\n GC_API size_t GC_get_heap_size GC_PROTO((void));\n \n+/* Return a lower bound on the number of free bytes in the heap.\t*/\n+GC_API size_t GC_get_free_bytes GC_PROTO((void));\n+\n /* Return the number of bytes allocated since the last collection.\t*/\n GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n \n@@ -321,10 +352,11 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * descr_string,\n+\t\t          int descr_int\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_CONST char * descr_string, int descr_int\n #endif\n \n /* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n@@ -510,7 +542,7 @@ GC_API int GC_invoke_finalizers GC_PROTO((void));\n \t/* be finalized.  Return the number of finalizers\t*/\n \t/* that were run.  Normally this is also called\t\t*/\n \t/* implicitly during some allocations.\tIf\t\t*/\n-\t/* FINALIZE_ON_DEMAND is defined, it must be called\t*/\n+\t/* GC-finalize_on_demand is nonzero, it must be called\t*/\n \t/* explicitly.\t\t\t\t\t\t*/\n \n /* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n@@ -668,7 +700,7 @@ GC_API void (*GC_is_visible_print_proc)\n # endif /* SOLARIS_THREADS */\n \n \n-#if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n /* We treat these similarly. */\n # include <pthread.h>\n # include <signal.h>\n@@ -687,11 +719,12 @@ GC_API void (*GC_is_visible_print_proc)\n \n # if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS)\n+\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n    \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/\n+/* lb must be large enough to hold the pointer field.\t\t\t*/\n GC_PTR GC_malloc_many(size_t lb);\n #define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n \t\t\t\t\t/* in returned list.\t\t*/"}, {"sha": "1f1d54aff95608531e53fb5f30bf5d1a1da18130", "filename": "boehm-gc/include/gc_alloc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_alloc.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -13,7 +13,7 @@\n \n //\n // This is a C++ header file that is intended to replace the SGI STL\n-// alloc.h.\n+// alloc.h.  This assumes SGI STL version < 3.0.\n //\n // This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n // and -DALL_INTERIOR_POINTERS.  We also recommend"}, {"sha": "54b7bd448d86d165873a9a8f9a028bdfbe368722", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -318,12 +318,10 @@ class traceable_alloc_template {\n \n typedef traceable_alloc_template < 0 > traceable_alloc;\n \n-#ifdef _SGI_SOURCE\n-\n // We want to specialize simple_alloc so that it does the right thing\n // for all pointerfree types.  At the moment there is no portable way to\n // even approximate that.  The following approximation should work for\n-// SGI compilers, and perhaps some others.\n+// SGI compilers, and recent versions of g++.\n \n # define __GC_SPECIALIZE(T,alloc) \\\n class simple_alloc<T, alloc> { \\\n@@ -451,6 +449,4 @@ __STL_END_NAMESPACE\n \n #endif /* __STL_USE_STD_ALLOCATORS */\n \n-#endif /* _SGI_SOURCE */\n-\n #endif /* GC_ALLOC_H */"}, {"sha": "60dc2ad37d6d4df5abca307d2786ffad7fafc52a", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -49,14 +49,16 @@ typedef struct bi {\n     hdr * index[BOTTOM_SZ];\n \t/*\n  \t * The bottom level index contains one of three kinds of values:\n-\t * 0 means we're not responsible for this block.\n+\t * 0 means we're not responsible for this block,\n+\t *   or this is a block other than the first one in a free block.\n \t * 1 < (long)X <= MAX_JUMP means the block starts at least\n \t *        X * HBLKSIZE bytes before the current address.\n \t * A valid pointer points to a hdr structure. (The above can't be\n \t * valid pointers due to the GET_MEM return convention.)\n \t */\n     struct bi * asc_link;\t/* All indices are linked in\t*/\n-    \t\t\t\t/* ascending order.\t\t*/\n+    \t\t\t\t/* ascending order...\t\t*/\n+    struct bi * desc_link;\t/* ... and in descending order.\t*/\n     word key;\t\t\t/* high order address bits.\t*/\n # ifdef HASH_TL\n     struct bi * hash_link;\t/* Hash chain link.\t\t*/"}, {"sha": "ac4d63a0b264f4307ccf85f55f2b87bf943ad398", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 156, "deletions": 29, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -1,6 +1,9 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n+ *\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -64,16 +67,16 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n #       include <stddef.h>\n #   endif\n #   define VOLATILE volatile\n-#   define CONST const\n #else\n #   ifdef MSWIN32\n #   \tinclude <stdlib.h>\n #   endif\n #   define VOLATILE\n-#   define CONST\n #endif\n \n-#ifdef AMIGA\n+#define CONST GC_CONST\n+\n+#if 0 /* was once defined for AMIGA */\n #   define GC_FAR __far\n #else\n #   define GC_FAR\n@@ -350,7 +353,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t\t\t    + GC_page_size) \\\n                                     + GC_page_size-1)\n #   else\n-#     if defined(AMIGA) || defined(NEXT) || defined(DOS4GW)\n+#     if defined(AMIGA) || defined(NEXT) || defined(MACOSX) || defined(DOS4GW)\n #       define GET_MEM(bytes) HBLKPTR((size_t) \\\n \t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n                                       + GC_page_size-1)\n@@ -436,7 +439,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #  endif\n #  ifdef LINUX_THREADS\n #    include <pthread.h>\n-#    ifdef __i386__\n+#    if defined(I386)\n        inline static int GC_test_and_set(volatile unsigned int *addr) {\n \t  int oldval;\n \t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n@@ -446,9 +449,57 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t  return oldval;\n        }\n #    else\n-       -- > Need implementation of GC_test_and_set()\n+#     if defined(POWERPC)\n+       inline static int GC_test_and_set(volatile unsigned int *addr) {\n+        int oldval;\n+        int temp = 1; // locked value\n+\n+        __asm__ __volatile__(\n+               \"1:\\tlwarx %0,0,%3\\n\"   // load and reserve\n+               \"\\tcmpwi %0, 0\\n\"       // if load is\n+               \"\\tbne 2f\\n\"            //   non-zero, return already set\n+               \"\\tstwcx. %2,0,%1\\n\"    // else store conditional\n+               \"\\tbne- 1b\\n\"           // retry if lost reservation\n+               \"2:\\t\\n\"                // oldval is zero if we set\n+              : \"=&r\"(oldval), \"=p\"(addr)\n+              : \"r\"(temp), \"1\"(addr)\n+              : \"memory\");\n+        return (int)oldval;\n+       }\n+#     else\n+#      ifdef ALPHA\n+         inline static int GC_test_and_set(volatile unsigned int *\n+addr)\n+         {\n+           unsigned long oldvalue;\n+           unsigned long temp;\n+\n+           __asm__ __volatile__(\n+                                \"1:     ldl_l %0,%1\\n\"\n+                                \"       and %0,%3,%2\\n\"\n+                                \"       bne %2,2f\\n\"\n+                                \"       xor %0,%3,%0\\n\"\n+                                \"       stl_c %0,%1\\n\"\n+                                \"       beq %0,3f\\n\"\n+                                \"       mb\\n\"\n+                                \"2:\\n\"\n+                                \".section .text2,\\\"ax\\\"\\n\"\n+                                \"3:     br 1b\\n\"\n+                                \".previous\"\n+                                :\"=&r\" (temp), \"=m\" (*addr), \"=&r\"\n+(oldvalue)\n+                                :\"Ir\" (1), \"m\" (*addr));\n+\n+           return oldvalue;\n+         }\n+#      else\n+         -- > Need implementation of GC_test_and_set()\n+#      endif\n+#     endif\n #    endif\n-#    define GC_clear(addr) (*(addr) = 0)\n+     inline static void GC_clear(volatile unsigned int *addr) {\n+          *(addr) = 0;\n+     }\n \n      extern volatile unsigned int GC_allocate_lock;\n \t/* This is not a mutex because mutexes that obey the (optional)     */\n@@ -462,31 +513,41 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #    define NO_THREAD (pthread_t)(-1)\n #    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n #    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    ifdef UNDEFINED\n-#    \tdefine LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n-#    else\n-#\tdefine LOCK() \\\n+#    define LOCK() \\\n \t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n-#\tdefine UNLOCK() \\\n+#    define UNLOCK() \\\n \t\tGC_clear(&GC_allocate_lock)\n-#    endif\n      extern GC_bool GC_collecting;\n #    define ENTER_GC() \\\n \t\t{ \\\n \t\t    GC_collecting = 1; \\\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n #  endif /* LINUX_THREADS */\n-#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS)\n+#  if defined(HPUX_THREADS)\n+#    include <pthread.h>\n+     extern pthread_mutex_t GC_allocate_ml;\n+#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n+#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#  endif\n+#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS) \n+     /* This may also eventually be appropriate for HPUX_THREADS */\n #    include <pthread.h>\n-#    include <mutex.h>\n+#    ifndef HPUX_THREADS\n+\t/* This probably should never be included, but I can't test\t*/\n+\t/* on Irix anymore.\t\t\t\t\t\t*/\n+#       include <mutex.h>\n+#    endif\n \n-#    if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n+#    ifndef HPUX_THREADS\n+#      if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n \t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n #        define GC_test_and_set(addr, v) test_and_set(addr,v)\n-#    else\n+#      else\n #\t define GC_test_and_set(addr, v) __test_and_set(addr,v)\n+#      endif\n+#    else\n+       /* I couldn't find a way to do this inline on HP/UX\t*/\n #    endif\n      extern unsigned long GC_allocate_lock;\n \t/* This is not a mutex because mutexes that obey the (optional) \t*/\n@@ -500,23 +561,25 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #    define NO_THREAD (pthread_t)(-1)\n #    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n #    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    ifdef UNDEFINED\n-#    \tdefine LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#    ifdef HPUX_THREADS\n+#      define LOCK() { if (!GC_test_and_clear(&GC_allocate_lock)) GC_lock(); }\n+       /* The following is INCORRECT, since the memory model is too weak. */\n+#      define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n+\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 1; }\n #    else\n-#\tdefine LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n-#       if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n+#      define LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n+#      if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n \t   && defined(_COMPILER_VERSION) && _COMPILER_VERSION >= 700\n #\t    define UNLOCK() __lock_release(&GC_allocate_lock)\n-#\telse\n+#      else\n \t    /* The function call in the following should prevent the\t*/\n \t    /* compiler from moving assignments to below the UNLOCK.\t*/\n \t    /* This is probably not necessary for ucode or gcc 2.8.\t*/\n \t    /* It may be necessary for Ragnarok and future gcc\t\t*/\n \t    /* versions.\t\t\t\t\t\t*/\n #           define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n \t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 0; }\n-#\tendif\n+#      endif\n #    endif\n      extern GC_bool GC_collecting;\n #    define ENTER_GC() \\\n@@ -607,7 +670,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n # else\n #   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n \t|| defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t|| defined(IRIX_JDK_THREADS)\n+\t|| defined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n       void GC_stop_world();\n       void GC_start_world();\n #     define STOP_WORLD() GC_stop_world()\n@@ -823,6 +886,7 @@ struct hblkhdr {\n     struct hblk * hb_next; \t/* Link field for hblk free list\t */\n     \t\t\t\t/* and for lists of chunks waiting to be */\n     \t\t\t\t/* reclaimed.\t\t\t\t */\n+    struct hblk * hb_prev;\t/* Backwards link for free list.\t*/\n     word hb_descr;   \t\t/* object descriptor for marking.  See\t*/\n     \t\t\t\t/* mark.h.\t\t\t\t*/\n     char* hb_map;\t/* A pointer to a pointer validity map of the block. */\n@@ -837,14 +901,28 @@ struct hblkhdr {\n #\tdefine IGNORE_OFF_PAGE\t1\t/* Ignore pointers that do not\t*/\n \t\t\t\t\t/* point to the first page of \t*/\n \t\t\t\t\t/* this object.\t\t\t*/\n+#\tdefine WAS_UNMAPPED 2\t/* This is a free block, which has\t*/\n+\t\t\t\t/* been unmapped from the address \t*/\n+\t\t\t\t/* space.\t\t\t\t*/\n+\t\t\t\t/* GC_remap must be invoked on it\t*/\n+\t\t\t\t/* before it can be reallocated.\t*/\n+\t\t\t\t/* Only set with USE_MUNMAP.\t\t*/\n     unsigned short hb_last_reclaimed;\n     \t\t\t\t/* Value of GC_gc_no when block was\t*/\n     \t\t\t\t/* last allocated or swept. May wrap.   */\n+\t\t\t\t/* For a free block, this is maintained */\n+\t\t\t\t/* unly for USE_MUNMAP, and indicates\t*/\n+\t\t\t\t/* when the header was allocated, or\t*/\n+\t\t\t\t/* when the size of the block last\t*/\n+\t\t\t\t/* changed.\t\t\t\t*/\n     word hb_marks[MARK_BITS_SZ];\n \t\t\t    /* Bit i in the array refers to the             */\n \t\t\t    /* object starting at the ith word (header      */\n \t\t\t    /* INCLUDED) in the heap block.                 */\n \t\t\t    /* The lsb of word 0 is numbered 0.\t\t    */\n+\t\t\t    /* Unused bits are invalid, and are \t    */\n+\t\t\t    /* occasionally set, e.g for uncollectable\t    */\n+\t\t\t    /* objects.\t\t\t\t\t    */\n };\n \n /*  heap block body */\n@@ -959,6 +1037,9 @@ struct _GC_arrays {\n   word _max_heapsize;\n   ptr_t _last_heap_addr;\n   ptr_t _prev_heap_addr;\n+  word _large_free_bytes;\n+\t/* Total bytes contained in blocks on large object free */\n+\t/* list.\t\t\t\t\t\t*/\n   word _words_allocd_before_gc;\n \t\t/* Number of words allocated before this\t*/\n \t\t/* collection cycle.\t\t\t\t*/\n@@ -1005,6 +1086,9 @@ struct _GC_arrays {\n    \t\t/* Number of words in accessible atomic\t\t*/\n \t\t/* objects.\t\t\t\t\t*/\n # endif\n+# ifdef USE_MUNMAP\n+    word _unmapped_bytes;\n+# endif\n # ifdef MERGE_SIZES\n     unsigned _size_map[WORDS_TO_BYTES(MAXOBJSZ+1)];\n     \t/* Number of words to allocate for a given allocation request in */\n@@ -1022,7 +1106,7 @@ struct _GC_arrays {\n     \t\t       /* to an object at\t\t\t\t*/\n     \t\t       /* block_start+i&~3 - WORDS_TO_BYTES(j).\t\t*/\n     \t\t       /* (If ALL_INTERIOR_POINTERS is defined, then\t*/\n-    \t\t       /* instead ((short *)(hbh_map[sz])[i] is j if\t*/\n+    \t\t       /* instead ((short *)(hb_map[sz])[i] is j if\t*/\n     \t\t       /* block_start+WORDS_TO_BYTES(i) is in the\t*/\n     \t\t       /* interior of an object starting at\t\t*/\n     \t\t       /* block_start+WORDS_TO_BYTES(i-j)).\t\t*/\n@@ -1135,6 +1219,7 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_prev_heap_addr GC_arrays._prev_heap_addr\n # define GC_words_allocd GC_arrays._words_allocd\n # define GC_words_wasted GC_arrays._words_wasted\n+# define GC_large_free_bytes GC_arrays._large_free_bytes\n # define GC_words_finalized GC_arrays._words_finalized\n # define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n # define GC_mem_freed GC_arrays._mem_freed\n@@ -1144,6 +1229,9 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_words_allocd_before_gc GC_arrays._words_allocd_before_gc\n # define GC_heap_sects GC_arrays._heap_sects\n # define GC_last_stack GC_arrays._last_stack\n+# ifdef USE_MUNMAP\n+#   define GC_unmapped_bytes GC_arrays._unmapped_bytes\n+# endif\n # ifdef MSWIN32\n #   define GC_heap_bases GC_arrays._heap_bases\n # endif\n@@ -1236,7 +1324,7 @@ extern char * GC_invalid_map;\n \t\t\t/* Pointer to the nowhere valid hblk map */\n \t\t\t/* Blocks pointing to this map are free. */\n \n-extern struct hblk * GC_hblkfreelist;\n+extern struct hblk * GC_hblkfreelist[];\n \t\t\t\t/* List of completely empty heap blocks\t*/\n \t\t\t\t/* Linked through hb_next field of \t*/\n \t\t\t\t/* header structure associated with\t*/\n@@ -1311,7 +1399,12 @@ GC_bool GC_should_collect();\n void GC_apply_to_all_blocks(/*fn, client_data*/);\n \t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n \t\t\t/* allocated heap block.\t\t\t*/\n-struct hblk * GC_next_block(/* struct hblk * h */);\n+struct hblk * GC_next_used_block(/* struct hblk * h */);\n+\t\t\t/* Return first in-use block >= h\t*/\n+struct hblk * GC_prev_block(/* struct hblk * h */);\n+\t\t\t/* Return last block <= h.  Returned block\t*/\n+\t\t\t/* is managed by GC, but may or may not be in\t*/\n+\t\t\t/* use.\t\t\t\t\t\t*/\n void GC_mark_init();\n void GC_clear_marks();\t/* Clear mark bits for all heap objects. */\n void GC_invalidate_mark_state();\t/* Tell the marker that\tmarked \t   */\n@@ -1384,8 +1477,14 @@ extern void (*GC_start_call_back)(/* void */);\n \t\t\t/* lock held.\t\t\t\t\t*/\n \t\t\t/* 0 by default.\t\t\t\t*/\n void GC_push_regs();\t/* Push register contents onto mark stack.\t*/\n+\t\t\t/* If NURSERY is defined, the default push\t*/\n+\t\t\t/* action can be overridden with GC_push_proc\t*/\n void GC_remark();\t/* Mark from all marked objects.  Used\t*/\n \t\t \t/* only if we had to drop something.\t*/\n+\n+# ifdef NURSERY\n+    extern void (*GC_push_proc)(ptr_t);\n+# endif\n # if defined(MSWIN32)\n   void __cdecl GC_push_one();\n # else\n@@ -1608,6 +1707,15 @@ extern void (*GC_print_heap_obj)(/* ptr_t p */);\n \t\t\t/* detailed description of the object \t\t*/\n \t\t\t/* referred to by p.\t\t\t\t*/\n \t\t\t\n+/* Memory unmapping: */\n+#ifdef USE_MUNMAP\n+  void GC_unmap_old(void);\n+  void GC_merge_unmapped(void);\n+  void GC_unmap(ptr_t start, word bytes);\n+  void GC_remap(ptr_t start, word bytes);\n+  void GC_unmap_gap(ptr_t start1, word bytes1, ptr_t start2, word bytes2);\n+#endif\n+\n /* Virtual dirty bit implementation:\t\t*/\n /* Each implementation exports the following:\t*/\n void GC_read_dirty();\t/* Retrieve dirty bits.\t*/\n@@ -1640,6 +1748,16 @@ void GC_print_heap_sects();\n void GC_print_static_roots();\n void GC_dump();\n \n+#ifdef KEEP_BACK_PTRS\n+   void GC_store_back_pointer(ptr_t source, ptr_t dest);\n+   void GC_marked_for_finalization(ptr_t dest);\n+#  define GC_STORE_BACK_PTR(source, dest) GC_store_back_pointer(source, dest)\n+#  define GC_MARKED_FOR_FINALIZATION(dest) GC_marked_for_finalization(dest)\n+#else\n+#  define GC_STORE_BACK_PTR(source, dest) \n+#  define GC_MARKED_FOR_FINALIZATION(dest)\n+#endif\n+\n /* Make arguments appear live to compiler */\n # ifdef __WATCOMC__\n   void GC_noop(void*, ...);\n@@ -1690,4 +1808,13 @@ void GC_err_puts(/* char *s */);\n \t\t\t/* newlines, don't ...\t\t\t\t*/\n \n \n+#   ifdef GC_ASSERTIONS\n+#\tdefine GC_ASSERT(expr) if(!(expr)) {\\\n+\t\tGC_err_printf2(\"Assertion failure: %s:%ld\\n\", \\\n+\t\t\t\t__FILE__, (unsigned long)__LINE__); \\\n+\t\tABORT(\"assertion failure\"); }\n+#   else \n+#\tdefine GC_ASSERT(expr)\n+#   endif\n+\n # endif /* GC_PRIVATE_H */"}, {"sha": "c9017d371a8a7f73ac9e08faf498d9f9ffa2aa93", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f29b3bb53758fab3ccaae9823c9b135a25e0f2/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=85f29b3bb53758fab3ccaae9823c9b135a25e0f2", "patch": "@@ -43,6 +43,11 @@\n #    define OPENBSD\n #    define mach_type_known\n # endif\n+# if defined(__OpenBSD__) && defined(__sparc__)\n+#    define SPARC\n+#    define OPENBSD\n+#    define mach_type_known\n+# endif\n # if defined(__NetBSD__) && defined(m68k)\n #    define M68K\n #    define NETBSD\n@@ -100,7 +105,8 @@\n #     endif\n #   define mach_type_known\n # endif\n-# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux)\n+# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \\\n+     && !defined(__OpenBSD__)\n #   define SPARC\n #   define DRSNX\n #   define mach_type_known\n@@ -129,7 +135,7 @@\n #   define HP_PA\n #   define mach_type_known\n # endif\n-# if defined(LINUX) && defined(i386)\n+# if defined(LINUX) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define mach_type_known\n # endif\n@@ -141,9 +147,8 @@\n #    define M68K\n #    define mach_type_known\n # endif\n-# if defined(linux) && defined(sparc)\n+# if defined(LINUX) && defined(sparc)\n #    define SPARC\n-#    define LINUX\n #    define mach_type_known\n # endif\n # if defined(__alpha) || defined(__alpha__)\n@@ -153,9 +158,11 @@\n #   endif\n #   define mach_type_known\n # endif\n-# if defined(_AMIGA)\n-#   define M68K\n+# if defined(_AMIGA) && !defined(AMIGA)\n #   define AMIGA\n+# endif\n+# ifdef AMIGA \n+#   define M68K\n #   define mach_type_known\n # endif\n # if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n@@ -168,6 +175,11 @@\n #   define MACOS\n #   define mach_type_known\n # endif\n+# if defined(macosx)\n+#    define MACOSX\n+#    define POWERPC\n+#    define mach_type_known\n+# endif\n # if defined(NeXT) && defined(mc68000)\n #   define M68K\n #   define NEXT\n@@ -486,8 +498,8 @@\n \n # ifdef POWERPC\n #   define MACH_TYPE \"POWERPC\"\n-#   define ALIGNMENT 2\n #   ifdef MACOS\n+#     define ALIGNMENT 2  /* Still necessary?  Could it be 4?\t*/\n #     ifndef __LOWMEM__\n #     include <LowMem.h>\n #     endif\n@@ -497,14 +509,24 @@\n #     define DATAEND  /* not needed */\n #   endif\n #   ifdef LINUX\n+#     define ALIGNMENT 4\t/* Guess.  Can someone verify?\t*/\n+\t\t\t\t/* This was 2, but that didn't sound right. */\n #     define OS_TYPE \"LINUX\"\n #     define HEURISTIC1\n #     undef STACK_GRAN\n #     define STACK_GRAN 0x10000000\n+\t/* Stack usually starts at 0x80000000 */\n #     define DATASTART GC_data_start\n       extern int _end;\n #     define DATAEND (&_end)\n #   endif\n+#   ifdef MACOSX\n+#     define ALIGNMENT 4\n+#     define OS_TYPE \"MACOSX\"\n+#     define DATASTART ((ptr_t) get_etext())\n+#     define STACKBOTTOM ((ptr_t) 0xc0000000)\n+#     define DATAEND\t/* not needed */\n+#   endif\n # endif\n \n # ifdef VAX\n@@ -603,6 +625,11 @@\n #     define SVR4\n #     define STACKBOTTOM ((ptr_t) 0xf0000000)\n #   endif\n+#   ifdef OPENBSD\n+#     define OS_TYPE \"OPENBSD\"\n+#     define STACKBOTTOM ((ptr_t) 0xf8000000)\n+#     define DATASTART ((ptr_t)(&etext))\n+#   endif\n # endif\n \n # ifdef I386\n@@ -657,10 +684,13 @@\n #   endif\n #   ifdef LINUX\n #\tdefine OS_TYPE \"LINUX\"\n-#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n-\t/* Appears to be 0xe0000000 for at least one 2.1.91 kernel.\t*/\n-\t/* Probably needs to be more flexible, but I don't yet \t\t*/\n-\t/* fully understand how flexible.\t\t\t\t*/\n+#       define HEURISTIC1\n+#       undef STACK_GRAN\n+#       define STACK_GRAN 0x10000000\n+\t/* STACKBOTTOM is usually 0xc0000000, but this changes with\t*/\n+\t/* different kernel configurations.  In particular, systems\t*/\n+\t/* with 2GB physical memory will usually move the user\t\t*/\n+\t/* address space limit, and hence initial SP to 0x80000000.\t*/\n #       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n #\t    define MPROTECT_VDB\n #\telse\n@@ -909,9 +939,13 @@\n #       define CPP_WORDSZ 64\n #       define STACKBOTTOM ((ptr_t) 0x120000000)\n #       ifdef __ELF__\n+#   \t  if 0\n+\t    /* __data_start apparently disappeared in some recent releases. */\n             extern int __data_start;\n #           define DATASTART &__data_start\n-#           define DYNAMIC_LOADING\n+#\t  endif\n+#         define DATASTART GC_data_start\n+#         define DYNAMIC_LOADING\n #       else\n #           define DATASTART ((ptr_t) 0x140000000)\n #       endif\n@@ -1021,6 +1055,10 @@\n #   undef MPROTECT_VDB\n # endif\n \n+# ifdef USE_MUNMAP\n+#   undef MPROTECT_VDB  /* Can't deal with address space holes. */\n+# endif\n+\n # if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n #   define DEFAULT_VDB\n # endif"}]}