{"sha": "6febd5819dbd5e3407b8880416f16c77018081ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlYmQ1ODE5ZGJkNWUzNDA3Yjg4ODA0MTZmMTZjNzcwMTgwODFhYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T12:03:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T12:03:05Z"}, "message": "(MASK and TARGET): Add new flags for POWER2 and PowerPC with square root.\n\n(ASSEMBLER_DIALECT): New macro.\n(CONDITIONAL_REGISTER_USAGE): Set MQ register fixed if not POWER.\n(SHIFT_COUNT_TRUNCATED): Conditional on POWER.\n(ASM_OUTPUT_REG_{PUSH,POP}): Mnemonics dependencies.\n\nFrom-SVN: r5746", "tree": {"sha": "43b3f850c156bf5676542f2f832f2c009662cf9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43b3f850c156bf5676542f2f832f2c009662cf9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6febd5819dbd5e3407b8880416f16c77018081ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6febd5819dbd5e3407b8880416f16c77018081ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6febd5819dbd5e3407b8880416f16c77018081ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6febd5819dbd5e3407b8880416f16c77018081ab/comments", "author": null, "committer": null, "parents": [{"sha": "5e2e29364041b050392c5c014b6c61e96610132e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2e29364041b050392c5c014b6c61e96610132e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2e29364041b050392c5c014b6c61e96610132e"}], "stats": {"total": 52, "additions": 41, "deletions": 11}, "files": [{"sha": "c73b9d60b90048e1efd907dfc70f4d051c5e09e6", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6febd5819dbd5e3407b8880416f16c77018081ab/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6febd5819dbd5e3407b8880416f16c77018081ab/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6febd5819dbd5e3407b8880416f16c77018081ab", "patch": "@@ -70,18 +70,24 @@ extern int target_flags;\n /* Use POWER architecture instructions and MQ register.  */\n #define MASK_POWER\t\t0x01\n \n+/* Use POWER2 extensions to POWER architecture.  */\n+#define MASK_POWER2\t\t0x02\n+\n /* Use PowerPC architecture instructions.  */\n-#define MASK_POWERPC\t\t0x02\n+#define MASK_POWERPC\t\t0x04\n+\n+/* Use PowerPC square root instructions.  */\n+#define MASK_POWERPCSQR\t\t0x08\n \n /* Use PowerPC-64 architecture instructions.  */\n-#define MASK_POWERPC64\t\t0x04\n+#define MASK_POWERPC64\t\t0x10\n \n /* Use revised mnemonic names defined for PowerPC architecture.  */\n-#define MASK_NEW_MNEMONICS\t0x08\n+#define MASK_NEW_MNEMONICS\t0x20\n \n /* Disable placing fp constants in the TOC; can be turned on when the\n    TOC overflows.  */\n-#define MASK_NO_FP_IN_TOC\t0x10\n+#define MASK_NO_FP_IN_TOC\t0x40\n \n /* Output only one TOC entry per module.  Normally linking fails if\n    there are more than 16K unique variables/constants in an executable.  With\n@@ -90,10 +96,12 @@ extern int target_flags;\n \n    This is at the cost of having 2 extra loads and one extra store per\n    function, and one less allocatable register.  */\n-#define MASK_MINIMAL_TOC\t0x20\n+#define MASK_MINIMAL_TOC\t0x80\n \n #define TARGET_POWER\t\t\t(target_flags & MASK_POWER)\n+#define TARGET_POWER2\t\t\t(target_flags & MASK_POWER2)\n #define TARGET_POWERPC\t\t\t(target_flags & MASK_POWERPC)\n+#define TARGET_POWERPCSQR\t\t(target_flags & MASK_POWERPCSQR)\n #define TARGET_POWERPC64\t\t(target_flags & MASK_POWERPC64)\n #define TARGET_NEW_MNEMONICS\t\t(target_flags & MASK_NEW_MNEMONICS)\n #define TARGET_NO_FP_IN_TOC\t\t(target_flags & MASK_NO_FP_IN_TOC)\n@@ -109,9 +117,13 @@ extern int target_flags;\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\\\n  {{\"power\",\t\tMASK_POWER},\t\t\t\t\\\n-  {\"no-power\",\t\t- MASK_POWER},\t\t\t\t\\\n+  {\"power2\",\t\tMASK_POWER | MASK_POWER2},\t\t\\\n+  {\"no-power2\",\t\t- MASK_POWER2},\t\t\t\t\\\n+  {\"no-power\",\t\t- (MASK_POWER | MASK_POWER2)},\t\t\\\n   {\"powerpc\",\t\tMASK_POWERPC},\t\t\t\t\\\n-  {\"no-powerpc\",\t- (MASK_POWERPC | MASK_POWERPC64)},\t\\\n+  {\"no-powerpc\",\t- (MASK_POWERPC | MASK_POWERPCSQR | MASK_POWERPC64)}, \\\n+  {\"powerpc-sqr\",\tMASK_POWERPC | MASK_POWERPCSQR},\t\\\n+  {\"no-powerpc-sqr\",\t- MASK_POWERPCSQR},\t\t\t\\\n   {\"powerpc64\",\t\tMASK_POWERPC | MASK_POWERPC64},\t\t\\\n   {\"no-powerpc64\",\t-MASK_POWERPC64},\t\t\t\\\n   {\"new-mnemonics\",\tMASK_NEW_MNEMONICS},\t\t\t\\\n@@ -142,6 +154,10 @@ extern enum processor_type rs6000_cpu;\n /* Define the default processor.  This is overridden by other tm.h files.  */\n #define PROCESSOR_DEFAULT PROCESSOR_RIOS1\n \n+/* Specify the dialect of assembler to use.  New mnemonics is dialect one\n+   and the old mnemonics are dialect zero.  */\n+#define ASSEMBLER_DIALECT TARGET_NEW_MNEMONICS ? 1 : 0\n+\n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n    initializer with a subgrouping for each command option.\n@@ -444,6 +460,15 @@ extern char *rs6000_cpu_string;\n   if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n     (COST) = 0; /* Anti or output dependence.  */\n \n+/* Define this macro to change register usage conditional on target flags.\n+   Set MQ register fixed (already call_used) if not POWER architecture\n+   (RIOS1, RIOS2, and PPC601) so that it will not be allocated.\n+   Provide alternate register names for ppcas assembler */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+    if (!TARGET_POWER)\t\t\t\t\t\t\t\\\n+\tfixed_regs[64] = 1;\n+\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n@@ -1342,8 +1367,12 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n #define NO_FUNCTION_CSE\n \n /* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits. */\n-#define SHIFT_COUNT_TRUNCATED 1\n+   few bits.\n+\n+   The sle and sre instructions which allow SHIFT_COUNT_TRUNCATED\n+   have been dropped from the PowerPC architecture.  */\n+\n+#define SHIFT_COUNT_TRUNCATED TARGET_POWER ? 1 : 0\n \n /* Use atexit for static constructors/destructors, instead of defining\n    our own exit function.  */\n@@ -1901,13 +1930,14 @@ toc_section ()\t\t\t\t\t\t\\\n    It need not be very fast code.  */\n \n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tstu %s,-4(r1)\\n\", reg_names[REGNO]);\n+  asm_fprintf (FILE, \"\\{tstu|stwu} %s,-4(r1)\\n\", reg_names[REGNO]);\n \n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tl %s,0(r1)\\n\\tai r1,r1,4\\n\", reg_names[REGNO])\n+  asm_fprintf (FILE, \"\\t{l|lwz} %s,0(r1)\\n\\t{ai|addic} r1,r1,4\\n\",  \\\n+    reg_names[REGNO])\n \n /* This is how to output an element of a case-vector that is absolute. \n    (RS/6000 does not use such vectors, but we must define this macro"}]}