{"sha": "f29d1b660c804bc72de196a8b33841c1033a90eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5ZDFiNjYwYzgwNGJjNzJkZTE5NmE4YjMzODQxYzEwMzNhOTBlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-05-19T07:33:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-05-19T07:33:33Z"}, "message": "mips-protos.h (final_prescan_insn, [...]): Remove.\n\n\t* config/mips/mips-protos.h (final_prescan_insn,\n\tmips_count_memory_refs, mips_fill_delay_slot): Remove.\n\t* config/mips/mips.h (delay_type, dslots_load_total,\n\tdslots_load_filled, dslots_jump_total, dslots_jump_filled,\n\tdslots_number_nops, num_refs, mips_load_reg, mips_load_reg2,\n\tmips_load_reg3, mips_load_reg4): Remove.\n\t(MASK_STATS): Remove.\n\t(MASK_EXPLICIT_RELOCS): Reuse its value.\n\t(TARGET_STATS): Remove.\n\t(TARGET_SWITCHES): Turn -mstats and -mno-stats into no-ops.\n\tWarn that -mstats is now ignored.\n\t(FINAL_PRESCAN_INSN): Undefine.\n\t(DBR_OUTPUT_SEQEND): Remove handling of dslot statistics.\n\t(ASM_OUTPUT_REG_POP): Likewise.\n\t* config/mips/mips.c (dslots_load_total, dslots_load_filled,\n\tdslots_jump_total, dslots_jump_filled, dslots_number_nops, num_refs,\n\tmips_load_reg, mips_load_reg2, mips_load_reg3, mips_load_reg4,\n\tmips_fill_delay_slot, mips_count_memory_refs,\n\tfinal_prescan_insn): Remove.\n\t(output_block_move): Remove calls to mips_count_memory_refs.\n\t(print_operand): Remove printing of #nop for TARGET_STATS.\n\t(mips_output_function_epilogue): Remove TARGET_STATS code.\n\tReorganize setting of fnnmae.\n\t* config/mips/mips.md: Remove handling of dslot statistics\n\tthroughout file.  Change all fcmp patterns into normal asm\n\ttemplates, removing calls to mips_fill_delay_slot.\n\t* doc/invoke.texi: Remove documentation of -mstats.\n\nFrom-SVN: r66951", "tree": {"sha": "40f3805c45d5d726442a521693b8381d84766dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40f3805c45d5d726442a521693b8381d84766dd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f29d1b660c804bc72de196a8b33841c1033a90eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29d1b660c804bc72de196a8b33841c1033a90eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29d1b660c804bc72de196a8b33841c1033a90eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29d1b660c804bc72de196a8b33841c1033a90eb/comments", "author": null, "committer": null, "parents": [{"sha": "30a38382e768b3113229585923e3f620cd23b375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a38382e768b3113229585923e3f620cd23b375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a38382e768b3113229585923e3f620cd23b375"}], "stats": {"total": 622, "additions": 96, "deletions": 526}, "files": [{"sha": "0822e65e0e84ce6c08179965b6f5bfce44567634", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f29d1b660c804bc72de196a8b33841c1033a90eb", "patch": "@@ -1,3 +1,33 @@\n+2003-05-19  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (final_prescan_insn,\n+\tmips_count_memory_refs, mips_fill_delay_slot): Remove.\n+\t* config/mips/mips.h (delay_type, dslots_load_total,\n+\tdslots_load_filled, dslots_jump_total, dslots_jump_filled,\n+\tdslots_number_nops, num_refs, mips_load_reg, mips_load_reg2,\n+\tmips_load_reg3, mips_load_reg4): Remove.\n+\t(MASK_STATS): Remove.\n+\t(MASK_EXPLICIT_RELOCS): Reuse its value.\n+\t(TARGET_STATS): Remove.\n+\t(TARGET_SWITCHES): Turn -mstats and -mno-stats into no-ops.\n+\tWarn that -mstats is now ignored.\n+\t(FINAL_PRESCAN_INSN): Undefine.\n+\t(DBR_OUTPUT_SEQEND): Remove handling of dslot statistics.\n+\t(ASM_OUTPUT_REG_POP): Likewise.\n+\t* config/mips/mips.c (dslots_load_total, dslots_load_filled,\n+\tdslots_jump_total, dslots_jump_filled, dslots_number_nops, num_refs,\n+\tmips_load_reg, mips_load_reg2, mips_load_reg3, mips_load_reg4,\n+\tmips_fill_delay_slot, mips_count_memory_refs,\n+\tfinal_prescan_insn): Remove.\n+\t(output_block_move): Remove calls to mips_count_memory_refs.\n+\t(print_operand): Remove printing of #nop for TARGET_STATS.\n+\t(mips_output_function_epilogue): Remove TARGET_STATS code.\n+\tReorganize setting of fnnmae.\n+\t* config/mips/mips.md: Remove handling of dslot statistics\n+\tthroughout file.  Change all fcmp patterns into normal asm\n+\ttemplates, removing calls to mips_fill_delay_slot.\n+\t* doc/invoke.texi: Remove documentation of -mstats.\n+\n 2003-05-19  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_class_max_nregs): Return the number of"}, {"sha": "ab760caec318515ae507a4e14ab7bc5552ae7ed8", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=f29d1b660c804bc72de196a8b33841c1033a90eb", "patch": "@@ -87,18 +87,13 @@ extern bool\t\tmips_expand_unaligned_load PARAMS ((rtx, rtx,\n extern bool\t\tmips_expand_unaligned_store PARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t     unsigned int,\n \t\t\t\t\t\t\t     int));\n-extern void\t\tfinal_prescan_insn PARAMS ((rtx, rtx *, int));\n extern void\t\tinit_cumulative_args PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t      tree, rtx));\n extern void\t\tgen_conditional_move PARAMS ((rtx *));\n extern void\t\tmips_gen_conditional_trap PARAMS ((rtx *));\n extern void\t\tmips_emit_fcc_reload PARAMS ((rtx, rtx, rtx));\n extern void\t\tmips_set_return_address PARAMS ((rtx, rtx));\n-extern void\t\tmips_count_memory_refs PARAMS ((rtx, int));\n extern HOST_WIDE_INT\tmips_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n-extern const char      *mips_fill_delay_slot PARAMS ((const char *,\n-\t\t\t\t\t\t      enum delay_type, rtx *,\n-\t\t\t\t\t\t      rtx));\n extern rtx\t\tmips_subword PARAMS ((rtx, int));\n extern bool\t\tmips_split_64bit_move_p PARAMS ((rtx, rtx));\n extern void\t\tmips_split_64bit_move PARAMS ((rtx, rtx));"}, {"sha": "29c0cd693a7b1b45b5246b4c9f47ebaa96172eeb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 7, "deletions": 340, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f29d1b660c804bc72de196a8b33841c1033a90eb", "patch": "@@ -485,21 +485,6 @@ int set_volatile;\n /* The next branch instruction is a branch likely, not branch normal.  */\n int mips_branch_likely;\n \n-/* Count of delay slots and how many are filled.  */\n-int dslots_load_total;\n-int dslots_load_filled;\n-int dslots_jump_total;\n-int dslots_jump_filled;\n-\n-/* # of nops needed by previous insn */\n-int dslots_number_nops;\n-\n-/* Number of 1/2/3 word references to data items (ie, not jal's).  */\n-int num_refs[3];\n-\n-/* registers to check for load delay */\n-rtx mips_load_reg, mips_load_reg2, mips_load_reg3, mips_load_reg4;\n-\n /* Cached operands, and operator to compare for use in set/branch/trap\n    on condition codes.  */\n rtx branch_cmp[2];\n@@ -2423,93 +2408,6 @@ m16_usym5_4 (op, mode)\n \n   return 0;\n }\n-\f\n-/* Returns an operand string for the given instruction's delay slot,\n-   after updating filled delay slot statistics.\n-\n-   We assume that operands[0] is the target register that is set.\n-\n-   In order to check the next insn, most of this functionality is moved\n-   to FINAL_PRESCAN_INSN, and we just set the global variables that\n-   it needs.  */\n-\n-/* ??? This function no longer does anything useful, because final_prescan_insn\n-   now will never emit a nop.  */\n-\n-const char *\n-mips_fill_delay_slot (ret, type, operands, cur_insn)\n-     const char *ret;\t\t/* normal string to return */\n-     enum delay_type type;\t/* type of delay */\n-     rtx operands[];\t\t/* operands to use */\n-     rtx cur_insn;\t\t/* current insn */\n-{\n-  register rtx set_reg;\n-  register enum machine_mode mode;\n-  register rtx next_insn = cur_insn ? NEXT_INSN (cur_insn) : NULL_RTX;\n-  register int num_nops;\n-\n-  if (type == DELAY_LOAD || type == DELAY_FCMP)\n-    num_nops = 1;\n-\n-  else if (type == DELAY_HILO)\n-    num_nops = 2;\n-\n-  else\n-    num_nops = 0;\n-\n-  /* Make sure that we don't put nop's after labels.  */\n-  next_insn = NEXT_INSN (cur_insn);\n-  while (next_insn != 0 && GET_CODE (next_insn) == NOTE)\n-    next_insn = NEXT_INSN (next_insn);\n-\n-  dslots_load_total += num_nops;\n-  if (TARGET_DEBUG_F_MODE\n-      || !optimize\n-      || type == DELAY_NONE\n-      || operands == 0\n-      || cur_insn == 0\n-      || next_insn == 0\n-      || GET_CODE (next_insn) == CODE_LABEL\n-      || (set_reg = operands[0]) == 0)\n-    {\n-      dslots_number_nops = 0;\n-      mips_load_reg  = 0;\n-      mips_load_reg2 = 0;\n-      mips_load_reg3 = 0;\n-      mips_load_reg4 = 0;\n-      return ret;\n-    }\n-\n-  set_reg = operands[0];\n-  if (set_reg == 0)\n-    return ret;\n-\n-  while (GET_CODE (set_reg) == SUBREG)\n-    set_reg = SUBREG_REG (set_reg);\n-\n-  mode = GET_MODE (set_reg);\n-  dslots_number_nops = num_nops;\n-  mips_load_reg = set_reg;\n-  if (GET_MODE_SIZE (mode)\n-      > (unsigned) (FP_REG_P (REGNO (set_reg)) ? UNITS_PER_FPREG : UNITS_PER_WORD))\n-    mips_load_reg2 = gen_rtx_REG (SImode, REGNO (set_reg) + 1);\n-  else\n-    mips_load_reg2 = 0;\n-\n-  if (type == DELAY_HILO)\n-    {\n-      mips_load_reg3 = gen_rtx_REG (SImode, MD_REG_FIRST);\n-      mips_load_reg4 = gen_rtx_REG (SImode, MD_REG_FIRST+1);\n-    }\n-  else\n-    {\n-      mips_load_reg3 = 0;\n-      mips_load_reg4 = 0;\n-    }\n-\n-  return ret;\n-}\n-\n \f\n static bool\n mips_rtx_costs (x, code, outer_code, total)\n@@ -2794,123 +2692,6 @@ mips_address_cost (addr)\n {\n   return mips_address_insns (addr, SImode);\n }\n-\n-/* Determine whether a memory reference takes one (based off of the GP\n-   pointer), two (normal), or three (label + reg) instructions, and bump the\n-   appropriate counter for -mstats.  */\n-\n-void\n-mips_count_memory_refs (op, num)\n-     rtx op;\n-     int num;\n-{\n-  int additional = 0;\n-  int n_words = 0;\n-  rtx addr, plus0, plus1;\n-  enum rtx_code code0, code1;\n-  int looping;\n-\n-  if (TARGET_DEBUG_B_MODE)\n-    {\n-      fprintf (stderr, \"\\n========== mips_count_memory_refs:\\n\");\n-      debug_rtx (op);\n-    }\n-\n-  /* Skip MEM if passed, otherwise handle movsi of address.  */\n-  addr = (GET_CODE (op) != MEM) ? op : XEXP (op, 0);\n-\n-  /* Loop, going through the address RTL.  */\n-  do\n-    {\n-      looping = FALSE;\n-      switch (GET_CODE (addr))\n-\t{\n-\tcase REG:\n-\tcase CONST_INT:\n-\tcase LO_SUM:\n-\t  break;\n-\n-\tcase PLUS:\n-\t  plus0 = XEXP (addr, 0);\n-\t  plus1 = XEXP (addr, 1);\n-\t  code0 = GET_CODE (plus0);\n-\t  code1 = GET_CODE (plus1);\n-\n-\t  if (code0 == REG)\n-\t    {\n-\t      additional++;\n-\t      addr = plus1;\n-\t      looping = 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (code0 == CONST_INT)\n-\t    {\n-\t      addr = plus1;\n-\t      looping = 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (code1 == REG)\n-\t    {\n-\t      additional++;\n-\t      addr = plus0;\n-\t      looping = 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (code1 == CONST_INT)\n-\t    {\n-\t      addr = plus0;\n-\t      looping = 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (code0 == SYMBOL_REF || code0 == LABEL_REF || code0 == CONST)\n-\t    {\n-\t      addr = plus0;\n-\t      looping = 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (code1 == SYMBOL_REF || code1 == LABEL_REF || code1 == CONST)\n-\t    {\n-\t      addr = plus1;\n-\t      looping = 1;\n-\t      continue;\n-\t    }\n-\n-\t  break;\n-\n-\tcase LABEL_REF:\n-\t  n_words = 2;\t\t/* always 2 words */\n-\t  break;\n-\n-\tcase CONST:\n-\t  addr = XEXP (addr, 0);\n-\t  looping = 1;\n-\t  continue;\n-\n-\tcase SYMBOL_REF:\n-\t  n_words = SYMBOL_REF_FLAG (addr) ? 1 : 2;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  while (looping);\n-\n-  if (n_words == 0)\n-    return;\n-\n-  n_words += additional;\n-  if (n_words > 3)\n-    n_words = 3;\n-\n-  num_refs[n_words-1] += num;\n-}\n-\n \f\n /* Return a pseudo that points to the address of the current function.\n    The first time it is called for a function, an initializer for the\n@@ -4167,9 +3948,6 @@ output_block_move (insn, operands, num_regs, move_type)\n     {\n       if (CONSTANT_P (src_reg))\n \t{\n-\t  if (TARGET_STATS)\n-\t    mips_count_memory_refs (operands[1], 1);\n-\n \t  src_reg = operands[3 + num_regs--];\n \t  if (move_type != BLOCK_MOVE_LAST)\n \t    {\n@@ -4184,9 +3962,6 @@ output_block_move (insn, operands, num_regs, move_type)\n \n       if (CONSTANT_P (dest_reg))\n \t{\n-\t  if (TARGET_STATS)\n-\t    mips_count_memory_refs (operands[0], 1);\n-\n \t  dest_reg = operands[3 + num_regs--];\n \t  if (move_type != BLOCK_MOVE_LAST)\n \t    {\n@@ -4349,30 +4124,14 @@ output_block_move (insn, operands, num_regs, move_type)\n \t  bytes--;\n \t}\n \n-      if (TARGET_STATS && move_type != BLOCK_MOVE_LAST)\n-\t{\n-\t  dslots_load_total++;\n-\t  dslots_load_filled++;\n-\n-\t  if (CONSTANT_P (src_reg))\n-\t    mips_count_memory_refs (src_reg, 1);\n-\n-\t  if (CONSTANT_P (dest_reg))\n-\t    mips_count_memory_refs (dest_reg, 1);\n-\t}\n-\n       /* Emit load/stores now if we have run out of registers or are\n \t at the end of the move.  */\n \n       if (++num == num_regs || bytes == 0)\n \t{\n \t  /* If only load/store, we need a NOP after the load.  */\n \t  if (num == 1)\n-\t    {\n-\t      load_store[0].load = load_store[0].load_nop;\n-\t      if (TARGET_STATS && move_type != BLOCK_MOVE_LAST)\n-\t\tdslots_load_filled--;\n-\t    }\n+\t    load_store[0].load = load_store[0].load_nop;\n \n \t  if (move_type != BLOCK_MOVE_LAST)\n \t    {\n@@ -6133,9 +5892,6 @@ print_operand (file, op, letter)\n \tcase '#':\n \t  if (set_noreorder != 0)\n \t    fputs (\"\\n\\tnop\", file);\n-\t  else if (TARGET_STATS)\n-\t    fputs (\"\\n\\t#nop\", file);\n-\n \t  break;\n \n \tcase '(':\n@@ -6691,59 +6447,6 @@ mips_output_ascii (stream, string_param, len)\n   fprintf (stream, \"\\\"\\n\");\n }\n \f\n-/* If defined, a C statement to be executed just prior to the output of\n-   assembler code for INSN, to modify the extracted operands so they will be\n-   output differently.\n-\n-   Here the argument OPVEC is the vector containing the operands extracted\n-   from INSN, and NOPERANDS is the number of elements of the vector which\n-   contain meaningful data for this insn.  The contents of this vector are\n-   what will be used to convert the insn template into assembler code, so you\n-   can change the assembler output by changing the contents of the vector.\n-\n-   We use it to check if the current insn needs a nop in front of it because\n-   of load delays, and also to update the delay slot statistics.  */\n-\n-/* ??? There is no real need for this function, because it never actually\n-   emits a NOP anymore.  */\n-\n-void\n-final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx opvec[] ATTRIBUTE_UNUSED;\n-     int noperands ATTRIBUTE_UNUSED;\n-{\n-  if (dslots_number_nops > 0)\n-    {\n-      rtx pattern = PATTERN (insn);\n-      int length = get_attr_length (insn);\n-\n-      /* Do we need to emit a NOP? */\n-      if (length == 0\n-\t  || (mips_load_reg != 0 && reg_mentioned_p (mips_load_reg,  pattern))\n-\t  || (mips_load_reg2 != 0 && reg_mentioned_p (mips_load_reg2, pattern))\n-\t  || (mips_load_reg3 != 0 && reg_mentioned_p (mips_load_reg3, pattern))\n-\t  || (mips_load_reg4 != 0\n-\t      && reg_mentioned_p (mips_load_reg4, pattern)))\n-\tfputs (\"\\t#nop\\n\", asm_out_file);\n-\n-      else\n-\tdslots_load_filled++;\n-\n-      while (--dslots_number_nops > 0)\n-\tfputs (\"\\t#nop\\n\", asm_out_file);\n-\n-      mips_load_reg = 0;\n-      mips_load_reg2 = 0;\n-      mips_load_reg3 = 0;\n-      mips_load_reg4 = 0;\n-    }\n-\n-  if (TARGET_STATS\n-      && (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CALL_INSN))\n-    dslots_jump_total++;\n-}\n-\f\n /* Output at beginning of assembler file.\n \n    If we are optimizing to use the global pointer, create a temporary file to\n@@ -8086,62 +7789,26 @@ mips_output_function_epilogue (file, size)\n      FILE *file ATTRIBUTE_UNUSED;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n-  const char *fnname = \"\";\t/* FIXME: Correct initialisation?  */\n   rtx string;\n \n #ifndef FUNCTION_NAME_ALREADY_DECLARED\n-  /* Get the function name the same way that toplev.c does before calling\n-     assemble_start_function.  This is needed so that the name used here\n-     exactly matches the name used in ASM_DECLARE_FUNCTION_NAME.  */\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-\n   if (!flag_inhibit_size_directive)\n     {\n+      const char *fnname;\n+\n+      /* Get the function name the same way that toplev.c does before calling\n+\t assemble_start_function.  This is needed so that the name used here\n+\t exactly matches the name used in ASM_DECLARE_FUNCTION_NAME.  */\n+      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n       fputs (\"\\t.end\\t\", file);\n       assemble_name (file, fnname);\n       fputs (\"\\n\", file);\n     }\n #endif\n \n-  if (TARGET_STATS)\n-    {\n-      int num_gp_regs = cfun->machine->frame.gp_reg_size / 4;\n-      int num_fp_regs = cfun->machine->frame.fp_reg_size / 8;\n-      int num_regs = num_gp_regs + num_fp_regs;\n-      const char *name = fnname;\n-\n-      if (name[0] == '*')\n-\tname++;\n-\n-      dslots_load_total += num_regs;\n-\n-      fprintf (stderr,\n-\t       \"%-20s fp=%c leaf=%c alloca=%c setjmp=%c stack=%4ld arg=%3d reg=%2d/%d delay=%3d/%3dL %3d/%3dJ refs=%3d/%3d/%3d\",\n-\t       name, frame_pointer_needed ? 'y' : 'n',\n-\t       (cfun->machine->frame.mask & RA_MASK) != 0 ? 'n' : 'y',\n-\t       current_function_calls_alloca ? 'y' : 'n',\n-\t       current_function_calls_setjmp ? 'y' : 'n',\n-\t       cfun->machine->frame.total_size,\n-\t       current_function_outgoing_args_size, num_gp_regs, num_fp_regs,\n-\t       dslots_load_total, dslots_load_filled,\n-\t       dslots_jump_total, dslots_jump_filled,\n-\t       num_refs[0], num_refs[1], num_refs[2]);\n-\n-      fputc ('\\n', stderr);\n-    }\n-\n   /* Reset state info for each function.  */\n   inside_function = 0;\n   ignore_line_number = 0;\n-  dslots_load_total = 0;\n-  dslots_jump_total = 0;\n-  dslots_load_filled = 0;\n-  dslots_jump_filled = 0;\n-  num_refs[0] = 0;\n-  num_refs[1] = 0;\n-  num_refs[2] = 0;\n-  mips_load_reg = 0;\n-  mips_load_reg2 = 0;\n \n   while (string_constants != NULL)\n     {"}, {"sha": "e6d994510e0bffa39c8e36cc0d79f0f1cf7d2e75", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f29d1b660c804bc72de196a8b33841c1033a90eb", "patch": "@@ -43,14 +43,6 @@ enum cmp_type {\n   CMP_MAX\t\t\t\t/* max comparison type */\n };\n \n-/* types of delay slot */\n-enum delay_type {\n-  DELAY_NONE,\t\t\t\t/* no delay slot */\n-  DELAY_LOAD,\t\t\t\t/* load from memory delay */\n-  DELAY_HILO,\t\t\t\t/* move from/to hi/lo registers */\n-  DELAY_FCMP\t\t\t\t/* delay after doing c.<xx>.{d,s} */\n-};\n-\n /* Which processor to schedule for.  Since there is no difference between\n    a R2000 and R3000 in terms of the scheduler, we collapse them into\n    just an R3000.  The elements of the enumeration must match exactly\n@@ -164,16 +156,6 @@ extern const char *mips_abi_string;\t/* for -mabi={32,n32,64} */\n extern const char *mips_entry_string;\t/* for -mentry */\n extern const char *mips_no_mips16_string;/* for -mno-mips16 */\n extern const char *mips_cache_flush_func;/* for -mflush-func= and -mno-flush-func */\n-extern int dslots_load_total;\t\t/* total # load related delay slots */\n-extern int dslots_load_filled;\t\t/* # filled load delay slots */\n-extern int dslots_jump_total;\t\t/* total # jump related delay slots */\n-extern int dslots_jump_filled;\t\t/* # filled jump delay slots */\n-extern int dslots_number_nops;\t\t/* # of nops needed by previous insn */\n-extern int num_refs[3];\t\t\t/* # 1/2/3 word references */\n-extern GTY(()) rtx mips_load_reg;\t/* register to check for load delay */\n-extern GTY(()) rtx mips_load_reg2;\t/* 2nd reg to check for load delay */\n-extern GTY(()) rtx mips_load_reg3;\t/* 3rd reg to check for load delay */\n-extern GTY(()) rtx mips_load_reg4;\t/* 4th reg to check for load delay */\n extern int mips_string_length;\t\t/* length of strings for mips16 */\n extern const struct mips_cpu_info mips_cpu_info_table[];\n extern const struct mips_cpu_info *mips_arch_info;\n@@ -202,7 +184,7 @@ extern void\t\tsbss_section PARAMS ((void));\n #define MASK_GPOPT\t   0x00000008\t/* Optimize for global pointer */\n #define MASK_GAS\t   0x00000010\t/* Gas used instead of MIPS as */\n #define MASK_NAME_REGS\t   0x00000020\t/* Use MIPS s/w reg name convention */\n-#define MASK_STATS\t   0x00000040\t/* print statistics to stderr */\n+#define MASK_EXPLICIT_RELOCS 0x00000040 /* Use relocation operators.  */\n #define MASK_MEMCPY\t   0x00000080\t/* call memcpy instead of inline code*/\n #define MASK_SOFT_FLOAT\t   0x00000100\t/* software floating point */\n #define MASK_FLOAT64\t   0x00000200\t/* fp registers are 64 bits */\n@@ -228,7 +210,6 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t\t   multiply-add operations.  */\n #define MASK_BRANCHLIKELY  0x02000000   /* Generate Branch Likely\n \t\t\t\t\t   instructions.  */\n-#define MASK_EXPLICIT_RELOCS 0x04000000 /* Use relocation operators.  */\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n@@ -274,9 +255,6 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t\t/* Optimize for Sdata/Sbss */\n #define TARGET_GP_OPT\t\t(target_flags & MASK_GPOPT)\n \n-\t\t\t\t\t/* print program statistics */\n-#define TARGET_STATS\t\t(target_flags & MASK_STATS)\n-\n \t\t\t\t\t/* call memcpy instead of inline code */\n #define TARGET_MEMCPY\t\t(target_flags & MASK_MEMCPY)\n \n@@ -590,9 +568,9 @@ extern void\t\tsbss_section PARAMS ((void));\n      N_(\"Don't use GP relative sdata/sbss sections\")},\t\t\t\\\n   {\"no-gpopt\",\t\t -MASK_GPOPT,\t\t\t\t\t\\\n      N_(\"Don't use GP relative sdata/sbss sections\")},\t\t\t\\\n-  {\"stats\",\t\t  MASK_STATS,\t\t\t\t\t\\\n-     N_(\"Output compiler statistics\")},\t\t\t\t\t\\\n-  {\"no-stats\",\t\t -MASK_STATS,\t\t\t\t\t\\\n+  {\"stats\",\t\t  0,\t\t\t\t\t\t\\\n+     N_(\"Output compiler statistics (now ignored)\")},\t\t\t\\\n+  {\"no-stats\",\t\t  0,\t\t\t\t\t\t\\\n      N_(\"Don't output compiler statistics\")},\t\t\t\t\\\n   {\"memcpy\",\t\t  MASK_MEMCPY,\t\t\t\t\t\\\n      N_(\"Don't optimize block moves\")},\t\t\t\t\t\\\n@@ -3403,26 +3381,6 @@ typedef struct mips_args {\n \n #define SPECIAL_MODE_PREDICATES \\\n   \"pc_or_label_operand\",\n-\n-\f\n-/* If defined, a C statement to be executed just prior to the\n-   output of assembler code for INSN, to modify the extracted\n-   operands so they will be output differently.\n-\n-   Here the argument OPVEC is the vector containing the operands\n-   extracted from INSN, and NOPERANDS is the number of elements of\n-   the vector which contain meaningful data for this insn.  The\n-   contents of this vector are what will be used to convert the\n-   insn template into assembler code, so you can change the\n-   assembler output by changing the contents of the vector.\n-\n-   We use it to check if the current insn needs a nop in front of it\n-   because of load delays, and also to update the delay slot\n-   statistics.  */\n-\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\t\t\\\n-  final_prescan_insn (INSN, OPVEC, NOPERANDS)\n-\n \f\n /* Control the assembler format that we output.  */\n \n@@ -3816,7 +3774,6 @@ do\t\t\t\t\t\t\t\t\t\\\n     if (set_noreorder > 0 && --set_noreorder == 0)\t\t\t\\\n       fputs (\"\\t.set\\treorder\\n\", STREAM);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    dslots_jump_filled++;\t\t\t\t\t\t\\\n     fputs (\"\\n\", STREAM);\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n@@ -4107,8 +4064,6 @@ do\t\t\t\t\t\t\t\t\t\\\n     if (! set_noreorder)\t\t\t\t\t\t\\\n       fprintf (STREAM, \"\\t.set\\tnoreorder\\n\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    dslots_load_total++;\t\t\t\t\t\t\\\n-    dslots_load_filled++;\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%s,0(%s)\\n\\t%s\\t%s,%s,8\\n\",\t\t\t\\\n \t     TARGET_64BIT ? \"ld\" : \"lw\",\t\t\t\t\\\n \t     reg_names[REGNO],\t\t\t\t\t\t\\"}, {"sha": "3284ba926e2b044dd80e4d43e9389b687b16041b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 54, "deletions": 122, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=f29d1b660c804bc72de196a8b33841c1033a90eb", "patch": "@@ -3444,8 +3444,6 @@\n   \"!TARGET_MIPS16\"\n   \"*\n {\n-  dslots_jump_total++;\n-  dslots_jump_filled++;\n   operands[2] = const0_rtx;\n \n   if (REGNO (operands[0]) == REGNO (operands[1]))\n@@ -3469,8 +3467,6 @@\n   \"*\n {\n   unsigned int regno1;\n-  dslots_jump_total++;\n-  dslots_jump_filled++;\n   operands[2] = const0_rtx;\n \n   if (GET_CODE (operands[1]) == REG)\n@@ -3520,8 +3516,6 @@\n   \"!TARGET_MIPS16\"\n   \"*\n {\n-  dslots_jump_total += 2;\n-  dslots_jump_filled += 2;\n   operands[4] = const0_rtx;\n \n   if (optimize && find_reg_note (insn, REG_DEAD, operands[1]))\n@@ -3556,8 +3550,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_64BIT && !TARGET_MIPS16\"\n   \"*\n {\n-  dslots_jump_total += 2;\n-  dslots_jump_filled += 2;\n   operands[4] = const0_rtx;\n \n   if (optimize && find_reg_note (insn, REG_DEAD, operands[1]))\n@@ -6560,8 +6552,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   operands[4] = const0_rtx;\n-  dslots_jump_total += 3;\n-  dslots_jump_filled += 2;\n \n   return \\\"sll\\\\t%3,%2,26\\\\n\\\\\n \\\\tbgez\\\\t%3,1f\\\\n\\\\\n@@ -6917,8 +6907,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   operands[4] = const0_rtx;\n-  dslots_jump_total += 3;\n-  dslots_jump_filled += 2;\n \n   return \\\"sll\\\\t%3,%2,26\\\\n\\\\\n \\\\tbgez\\\\t%3,1f\\\\n\\\\\n@@ -7297,8 +7285,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   operands[4] = const0_rtx;\n-  dslots_jump_total += 3;\n-  dslots_jump_filled += 2;\n \n   return \\\"sll\\\\t%3,%2,26\\\\n\\\\\n \\\\tbgez\\\\t%3,1f\\\\n\\\\\n@@ -9145,216 +9131,162 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(unordered:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t      (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.un.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.un.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sunlt_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(unlt:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.ult.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.ult.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"suneq_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(uneq:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.ueq.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.ueq.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sunle_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(unle:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.ule.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.ule.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"seq_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(eq:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.eq.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.eq.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"slt_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(lt:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.lt.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sle_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(le:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.le.d\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.le.d\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sgt_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(gt:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.lt.d\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.lt.d\\t%Z0%2,%1\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sge_df\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(ge:CC (match_operand:DF 1 \"register_operand\" \"f\")\n \t       (match_operand:DF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.le.d\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.le.d\\t%Z0%2,%1\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sunordered_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(unordered:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.un.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.un.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sunlt_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(unlt:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.ult.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.ult.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"suneq_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(uneq:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.ueq.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.ueq.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sunle_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(unle:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n- return mips_fill_delay_slot (\\\"c.ule.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"      \"fcmp\")\n-  (set_attr \"mode\"      \"FPSW\")])\n+  \"c.ule.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"seq_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(eq:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.eq.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.eq.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"slt_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(lt:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.lt.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sle_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(le:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.le.s\\\\t%Z0%1,%2\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.le.s\\t%Z0%1,%2\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sgt_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(gt:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.lt.s\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.lt.s\\t%Z0%2,%1\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n (define_insn \"sge_sf\"\n   [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n \t(ge:CC (match_operand:SF 1 \"register_operand\" \"f\")\n \t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  return mips_fill_delay_slot (\\\"c.le.s\\\\t%Z0%2,%1\\\", DELAY_FCMP, operands, insn);\n-}\"\n- [(set_attr \"type\"\t\"fcmp\")\n-  (set_attr \"mode\"\t\"FPSW\")])\n+  \"c.le.s\\t%Z0%2,%1\"\n+  [(set_attr \"type\" \"fcmp\")\n+   (set_attr \"mode\" \"FPSW\")])\n \n \f\n ;;"}, {"sha": "6a3a4a039b446519a8de52d9c95d6780b388d189", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29d1b660c804bc72de196a8b33841c1033a90eb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f29d1b660c804bc72de196a8b33841c1033a90eb", "patch": "@@ -472,7 +472,7 @@ in the following sections.\n -mno-memcpy  -mno-mips-tfile  -mno-rnames  -mno-stats @gol\n -mrnames  -msoft-float @gol\n -m4650  -msingle-float  -mmad @gol\n--mstats  -EL  -EB  -G @var{num}  -nocpp @gol\n+-EL  -EB  -G @var{num}  -nocpp @gol\n -mabi=32  -mabi=n32  -mabi=64  -mabi=eabi  -mabi-fake-default @gol\n -mfix7000  -mno-crt0 -mflush-func=@var{func} -mno-flush-func @gol\n -mbranch-likely -mno-branch-likely}\n@@ -7863,15 +7863,6 @@ assembler to generate one word memory references instead of using two\n words for short global or static data items.  This is on by default if\n optimization is selected.\n \n-@item -mstats\n-@itemx -mno-stats\n-@opindex mstats\n-@opindex mno-stats\n-For each non-inline function processed, the @option{-mstats} switch\n-causes the compiler to emit one line to the standard error file to\n-print statistics about the program (number of registers saved, stack\n-size, etc.).\n-\n @item -mmemcpy\n @itemx -mno-memcpy\n @opindex mmemcpy"}]}