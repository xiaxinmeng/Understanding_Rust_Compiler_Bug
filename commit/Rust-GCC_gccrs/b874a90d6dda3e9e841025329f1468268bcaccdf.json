{"sha": "b874a90d6dda3e9e841025329f1468268bcaccdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg3NGE5MGQ2ZGRhM2U5ZTg0MTAyNTMyOWYxNDY4MjY4YmNhY2NkZg==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2009-08-14T20:56:31Z"}, "committer": {"name": "Douglas Rupp", "email": "rupp@gcc.gnu.org", "date": "2009-08-14T20:56:31Z"}, "message": "fde-vms.c: New file.\n\n2009-08-14  Douglas B Rupp  <rupp@gnat.com>\n\n\t* config/ia64/fde-vms.c: New file.\n\t* config/ia64/fde-glibc.c (_Unwind_FindTableEntry): Add dummy arg.\n\t* config/ia64/unwind-ia64.c (UNW_ accessors): Move to unwind-ia64.h\n\t(MD_UNW_COMPATIBLE_PERSONALITY_P): Provide default.\n\t(uw_frame_state_for): Only register a personality routine if it is\n\tknown to be compatible with our expectations.\n\t(_Unwind_FindEnclosingFunction, uw_frame_state_for):\n\tDeclare unw_table_entry stack variable and\n\tmod all calls to _Unwind_FindTableEntry to add arg.\n\t* config/ia64/unwind-ia64.h (UNW_ accessors): Move here.\n\t(_Unwind_FindTableEntry): Add arg to prototype.\n\nFrom-SVN: r150778", "tree": {"sha": "319444e3ded8f724a8045ece29a0ef9a4e3deb1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/319444e3ded8f724a8045ece29a0ef9a4e3deb1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b874a90d6dda3e9e841025329f1468268bcaccdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b874a90d6dda3e9e841025329f1468268bcaccdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b874a90d6dda3e9e841025329f1468268bcaccdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b874a90d6dda3e9e841025329f1468268bcaccdf/comments", "author": null, "committer": null, "parents": [{"sha": "ac77b88e5267498679463fb578fe89ba973977e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac77b88e5267498679463fb578fe89ba973977e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac77b88e5267498679463fb578fe89ba973977e2"}], "stats": {"total": 249, "additions": 228, "deletions": 21}, "files": [{"sha": "48e96638d62d4c6fc38386cdf19ccd4149f191d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b874a90d6dda3e9e841025329f1468268bcaccdf", "patch": "@@ -1,3 +1,17 @@\n+2009-08-14  Douglas B Rupp  <rupp@gnat.com>\n+\n+\t* config/ia64/fde-vms.c: New file.\n+\t* config/ia64/fde-glibc.c (_Unwind_FindTableEntry): Add dummy arg.\n+\t* config/ia64/unwind-ia64.c (UNW_ accessors): Move to unwind-ia64.h\n+\t(MD_UNW_COMPATIBLE_PERSONALITY_P): Provide default.\n+\t(uw_frame_state_for): Only register a personality routine if it is\n+\tknown to be compatible with our expectations.\n+\t(_Unwind_FindEnclosingFunction, uw_frame_state_for):\n+\tDeclare unw_table_entry stack variable and\n+\tmod all calls to _Unwind_FindTableEntry to add arg.\n+\t* config/ia64/unwind-ia64.h (UNW_ accessors): Move here.\n+\t(_Unwind_FindTableEntry): Add arg to prototype.\n+\n 2009-08-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/ia64/unwind-ia64.c (struct _Unwind_Context): Add new"}, {"sha": "12760b96edabb166fc0a2c4685f31a5d2bf85186", "filename": "gcc/config/ia64/fde-glibc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ffde-glibc.c?ref=b874a90d6dda3e9e841025329f1468268bcaccdf", "patch": "@@ -145,7 +145,8 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \n struct unw_table_entry *\n _Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n-                        unsigned long *gp)\n+                        unsigned long *gp,\n+                        struct unw_table_entry *ent ATTRIBUTE_UNUSED)\n {\n   struct unw_ia64_callback_data data;\n "}, {"sha": "b310f0d11b663fd051b5bcb991596affc691575d", "filename": "gcc/config/ia64/fde-vms.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Ffde-vms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Ffde-vms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ffde-vms.c?ref=b874a90d6dda3e9e841025329f1468268bcaccdf", "patch": "@@ -0,0 +1,157 @@\n+/* Copyright (C) 2004, 2009 Free Software Foundation, Inc.\n+   Contributed by Douglas B Rupp <rupp@gnat.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Locate the FDE entry for a given address, using VMS Starlet routines\n+   to avoid register/deregister calls at DSO load/unload.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include \"unwind-ia64.h\"\n+\n+#define __int64 long\n+#include <vms/ossddef.h>\n+#ifndef SS$_NORMAL\n+#define SS$_NORMAL 1\n+#endif\n+\n+typedef struct\n+{\n+  unsigned long start_offset;\n+  unsigned long end_offset;\n+  unsigned long info_offset;\n+  unsigned long gp_value;\n+}  vms_unw_table_entry;\n+\n+typedef unsigned long long uqword;\n+\n+/* ENTRY is the unwind table entry found for a PC part of call chain we're\n+   unwinding through.  Return whether we should force the generic unwinder\n+   to resort to \"fallback\" processing.  */\n+   \n+static int\n+force_fallback_processing_for (void * pc, vms_unw_table_entry * entry)\n+{\n+  static int eh_debug = -1;\n+\n+  uqword * unw_info_block = (uqword *)entry->info_offset;\n+  uqword header = *unw_info_block;\n+\n+  /* We need to force fallback processing in two cases:\n+\n+     1/ The exception dispatch frame, since only our fallback\n+        processing knows how to properly unwind through it, and\n+\n+     2/ A bottom of stack frame, since only our fallback processing\n+        will ensure we don't try to unwind further past it, which\n+        would get us into unknown territory and likely cause a severe\n+        crash along the way.\n+\n+     The two cases are indicated by non-default values for specific\n+     bits in the OS Specific Data (OSSD) General Information block\n+     associated with such frames.  */\n+\n+  ossddef * ossd;\n+\n+  if (eh_debug == -1)\n+    {\n+      char * EH_DEBUG = getenv (\"EH_DEBUG\");\n+      eh_debug = EH_DEBUG ? atoi (EH_DEBUG) : 0;\n+    }\n+\n+  if (eh_debug)\n+    {\n+      printf (\"pc @ 0x%p, block @ 0x%p, header = 0x%016llx\\n\",\n+\t      pc, unw_info_block, header);\n+      printf (\"mode = %d, length = %ld, handler = %d\\n\",\n+\t      (int)UNW_IVMS_MODE (header), UNW_LENGTH (header),\n+\t      UNW_FLAG_EHANDLER (header) || UNW_FLAG_EHANDLER (header));\n+    }\n+\n+  /* An OSSD block is there for IVMS_MODE == 3 only.  */\n+  if (UNW_IVMS_MODE (header) != 3)\n+    return 0;\n+\n+  /* The OSSD block is found past the header, unwind descriptor area\n+     and condition handler pointer, if any.  */  \n+  ossd = (ossddef *)\n+    /* Beware: uqword pointer arithmetic below.  */\n+    (unw_info_block\n+     + 1\n+     + UNW_LENGTH (header)\n+     + (UNW_FLAG_EHANDLER (header) || UNW_FLAG_EHANDLER (header)));\n+\n+  /* \"A General Information segment may be omitted if all of its fields\n+      would have their default values.  If a General Information segment\n+      is present, it must be the first in the OSSD area.\"  So ...  */\n+  \n+  if (eh_debug)\n+    printf (\"ossd @ 0x%p\\n\", ossd);\n+      \n+  if (eh_debug && ossd->ossd$v_type == OSSD$K_GENERAL_INFO)\n+    printf (\"exc_frame = %d - bot_frame = %d - base_frame = %d\\n\",\n+\t    ossd->ossd$v_exception_frame, \n+\t    ossd->ossd$v_bottom_of_stack,\n+\t    ossd->ossd$v_base_frame);\n+\t\t\t\t\n+  return\n+    ossd->ossd$v_type == OSSD$K_GENERAL_INFO\n+    && (ossd->ossd$v_exception_frame\n+\t|| ossd->ossd$v_bottom_of_stack || ossd->ossd$v_base_frame);\n+}\n+\n+/* Return a pointer to the unwind table entry for the function\n+   containing PC, 0 if we cannot find an entry or if the one we find\n+   calls for fallback processing.  */\n+\n+struct unw_table_entry *\n+_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n+                        unsigned long *gp, struct unw_table_entry *ent)\n+{\n+  vms_unw_table_entry vueblock;\n+\n+  if (SYS$GET_UNWIND_ENTRY_INFO (pc, &vueblock, 0) != SS$_NORMAL)\n+    return 0;\n+\n+  /* If there is no unwind information, use fallback.  */\n+  if (vueblock.info_offset == 0)\n+    return 0;\n+\n+  /* If we need to force fallback processing, just pretend there is\n+     no entry.  */\n+  if (force_fallback_processing_for (pc, &vueblock))\n+    return 0;\n+\n+  *segment_base = 0; /* ??? Fixme. ??? */\n+  *gp = vueblock.gp_value;\n+  ent->start_offset = vueblock.start_offset;\n+  ent->end_offset = vueblock.end_offset;\n+  ent->info_offset = vueblock.info_offset;\n+\n+  return ent;\n+}"}, {"sha": "34258588292e144e7c9fa19103a8ad1d1772c85d", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=b874a90d6dda3e9e841025329f1468268bcaccdf", "patch": "@@ -41,12 +41,12 @@\n \n #ifndef __USING_SJLJ_EXCEPTIONS__\n \n-#define UNW_VER(x)\t\t((x) >> 48)\n-#define UNW_FLAG_MASK\t\t0x0000ffff00000000\n-#define UNW_FLAG_OSMASK\t\t0x0000f00000000000\n-#define UNW_FLAG_EHANDLER(x)\t((x) & 0x0000000100000000L)\n-#define UNW_FLAG_UHANDLER(x)\t((x) & 0x0000000200000000L)\n-#define UNW_LENGTH(x)\t\t((x) & 0x00000000ffffffffL)\n+\n+/* By default, assume personality routine interface compatibility with\n+   our expectations.  */\n+#ifndef MD_UNW_COMPATIBLE_PERSONALITY_P\n+#define MD_UNW_COMPATIBLE_PERSONALITY_P(HEADER) 1\n+#endif\n \n enum unw_application_register\n {\n@@ -442,7 +442,13 @@ decode_abreg (unsigned char abreg, int memory)\n {\n   switch (abreg)\n     {\n+#if TARGET_ABI_OPEN_VMS\n+    /* OpenVMS Calling Standard specifies R3 - R31.  */\n+    case 0x03 ... 0x1f: return UNW_REG_R2 + (abreg - 0x02);\n+#else\n+    /* Standard Intel ABI specifies GR 4 - 7.  */\n     case 0x04 ... 0x07: return UNW_REG_R4 + (abreg - 0x04);\n+#endif\n     case 0x22 ... 0x25: return UNW_REG_F2 + (abreg - 0x22);\n     case 0x30 ... 0x3f: return UNW_REG_F16 + (abreg - 0x30);\n     case 0x41 ... 0x45: return UNW_REG_B1 + (abreg - 0x41);\n@@ -1733,14 +1739,14 @@ _Unwind_GetRegionStart (struct _Unwind_Context *context)\n void *\n _Unwind_FindEnclosingFunction (void *pc)\n {\n-  struct unw_table_entry *ent;\n+  struct unw_table_entry *entp, ent;\n   unsigned long segment_base, gp;\n \n-  ent = _Unwind_FindTableEntry (pc, &segment_base, &gp);\n-  if (ent == NULL)\n+  entp = _Unwind_FindTableEntry (pc, &segment_base, &gp, &ent);\n+  if (entp == NULL)\n     return NULL;\n   else\n-    return (void *)(segment_base + ent->start_offset);\n+    return (void *)(segment_base + entp->start_offset);\n }\n \n /* Get the value of the CFA as saved in CONTEXT.  In GCC/Dwarf2 parlance,\n@@ -1768,7 +1774,7 @@ _Unwind_GetBSP (struct _Unwind_Context *context)\n static _Unwind_Reason_Code\n uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {\n-  struct unw_table_entry *ent;\n+  struct unw_table_entry *entp, ent;\n   unsigned long *unw, header, length;\n   unsigned char *insn, *insn_end;\n   unsigned long segment_base;\n@@ -1779,9 +1785,9 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n     r->when = UNW_WHEN_NEVER;\n   context->lsda = 0;\n \n-  ent = _Unwind_FindTableEntry ((void *) context->rp,\n-\t\t\t\t&segment_base, &context->gp);\n-  if (ent == NULL)\n+  entp = _Unwind_FindTableEntry ((void *) context->rp,\n+\t\t\t\t&segment_base, &context->gp, &ent);\n+  if (entp == NULL)\n     {\n       /* Couldn't find unwind info for this function.  Try an\n \t os-specific fallback mechanism.  This will necessarily\n@@ -1806,17 +1812,34 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n       return _URC_END_OF_STACK;\n     }\n \n-  context->region_start = ent->start_offset + segment_base;\n+  context->region_start = entp->start_offset + segment_base;\n   fs->when_target = ((context->rp & -16) - context->region_start) / 16 * 3\n \t\t    + (context->rp & 15);\n \n-  unw = (unsigned long *) (ent->info_offset + segment_base);\n+  unw = (unsigned long *) (entp->info_offset + segment_base);\n   header = *unw;\n   length = UNW_LENGTH (header);\n \n-  /* ??? Perhaps check UNW_VER / UNW_FLAG_OSMASK.  */\n+  /* Some operating systems use the personality routine slot in way not\n+     compatible with what we expect.  For instance, OpenVMS uses this slot to\n+     designate \"condition handlers\" with very different arguments than what we\n+     would be providing.  Such cases are typically identified from OS specific\n+     bits in the unwind information block header, and checked by the target\n+     MD_UNW_COMPATIBLE_PERSONALITY_P macro. \n+\n+     We just pretend there is no personality from our standpoint in such\n+     situations, and expect GCC not to set the identifying bits itself so that\n+     compatible personalities for GCC compiled code are called.\n+\n+     Of course, this raises the question of what combinations of native/GCC\n+     calls can be expected to behave properly exception handling-wise.  We are\n+     not to provide a magic answer here, merely to prevent crashes assuming\n+     users know what they are doing.\n+\n+     ??? Perhaps check UNW_VER / UNW_FLAG_OSMASK as well.  */\n \n-  if (UNW_FLAG_EHANDLER (header) | UNW_FLAG_UHANDLER (header))\n+  if (MD_UNW_COMPATIBLE_PERSONALITY_P (header)\n+      && (UNW_FLAG_EHANDLER (header) | UNW_FLAG_UHANDLER (header)))\n     {\n       fs->personality =\n \t*(_Unwind_Personality_Fn *) (unw[length + 1] + context->gp);"}, {"sha": "b98f048fdb500c2395cd387a610354c8385d0c5f", "filename": "gcc/config/ia64/unwind-ia64.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Funwind-ia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b874a90d6dda3e9e841025329f1468268bcaccdf/gcc%2Fconfig%2Fia64%2Funwind-ia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.h?ref=b874a90d6dda3e9e841025329f1468268bcaccdf", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000, 2001, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 1999, 2000, 2001, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod  <amacleod@cygnus.com>\n                   Andrew Haley  <aph@cygnus.com>\n \n@@ -25,7 +25,19 @@ struct unw_table_entry\n   unsigned long info_offset;\n };\n \n+/* Accessors to fields of an unwind info block header.  In this common file to\n+   be visible from all the units involved in a target implementation.  */\n+   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+#define UNW_VER(x)\t\t((x) >> 48)\n+#define UNW_FLAG_MASK\t\t0x0000ffff00000000\n+#define UNW_FLAG_OSMASK\t\t0x0000f00000000000\n+#define UNW_FLAG_EHANDLER(x)\t((x) & 0x0000000100000000L)\n+#define UNW_FLAG_UHANDLER(x)\t((x) & 0x0000000200000000L)\n+#define UNW_LENGTH(x)\t\t((x) & 0x00000000ffffffffL)\n+#endif\n+\n extern struct unw_table_entry *\n _Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n-\t\t\tunsigned long *gp)\n+\t\t\tunsigned long *gp, struct unw_table_entry *ent)\n \t\t\t__attribute__ ((__visibility__ (\"hidden\")));"}]}