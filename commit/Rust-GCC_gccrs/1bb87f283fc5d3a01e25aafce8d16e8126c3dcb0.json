{"sha": "1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJiODdmMjgzZmM1ZDNhMDFlMjVhYWZjZThkMTZlODEyNmMzZGNiMA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-01-30T20:58:19Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-01-30T20:58:19Z"}, "message": "Initial revision\n\nFrom-SVN: r255", "tree": {"sha": "fdeab0d9c1f246b96353e074460bbd301b77fc02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdeab0d9c1f246b96353e074460bbd301b77fc02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/comments", "author": null, "committer": null, "parents": [{"sha": "43b0eb42ea45c061e39a0597aed43ed91b49e2c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b0eb42ea45c061e39a0597aed43ed91b49e2c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43b0eb42ea45c061e39a0597aed43ed91b49e2c1"}], "stats": {"total": 2052, "additions": 2052, "deletions": 0}, "files": [{"sha": "6ec9d1515b7f15bd717ed6fa327a2dee8c81d920", "filename": "gcc/config/i386/sun.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fi386%2Fsun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fi386%2Fsun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsun.h?ref=1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "patch": "@@ -0,0 +1,97 @@\n+/* Definitions for Intel 386 running SunOS 4.0.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"i386.h\"\n+\n+/* Use the Sun assembler syntax.  */\n+\n+#include \"sun386.h\"\n+\n+/* By default, target has a 80387.  */\n+\n+#define TARGET_DEFAULT 1\n+\n+/* Use crt0.o as a startup file.  */\n+\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\"\n+\n+#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\\\n+%{g:-lg} %{sun386:}\"\n+/* That last item is just to prevent a spurious error.  */\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{!e*:-e _start} -dc -dp %{g:-Bstatic} %{static:-Bstatic}\"\n+\n+/* Extra switches to give the assembler.  */\n+\n+#define ASM_SPEC \"-i386\"\n+\n+/* Specify predefined symbols in preprocessor.  */\n+\n+#define CPP_PREDEFINES \"-Dunix -Di386 -Dsun386 -Dsun\"\n+\n+/* Allow #sccs in preprocessor.  */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+/* We don't want to output SDB debugging information.  */\n+\n+#undef SDB_DEBUGGING_INFO\n+\n+/* We want to output DBX debugging information.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Force structure alignment to the type used for a bitfield.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+#define VALUE_REGNO(MODE) \\\n+  (((MODE)==SFmode || (MODE)==DFmode) ? FIRST_FLOAT_REG : 0)\n+\n+/* 1 if N is a possible register number for a function value. */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N)== FIRST_FLOAT_REG)\n+\n+/* This is partly guess.  */\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n) \\\n+  ((n) == 0 ? 11 : (n)  == 1 ? 9 : (n) == 2 ? 10 : (n) == 3 ? 8\t\\\n+   : (n) == 4 ? 5 : (n) == 5 ? 4 : (n) == 6 ? 6 : (n))\n+\n+/* Every debugger symbol must be in the text section.\n+   Otherwise the assembler or the linker screws up.  */\n+\n+#define DEBUG_SYMS_TEXT"}, {"sha": "3b8e010ac3986826814c6661d296f820098a5dea", "filename": "gcc/config/m68k/sun2o4.h", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fm68k%2Fsun2o4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fm68k%2Fsun2o4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun2o4.h?ref=1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "patch": "@@ -0,0 +1,129 @@\n+/* Definitions of target machine for GNU compiler.  Sun 2 running Sunos 4.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"sun2.h\"\n+\n+\n+/* Define __HAVE_SKY__ in preprocessor, according to the -m flags.\n+   Also inform the program which CPU this is for.  */\n+\n+#undef CPP_SPEC\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"int\"\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 16\n+\n+#if TARGET_DEFAULT & 0200\n+\n+/* -msky is the default */\n+#define CPP_SPEC \\\n+\"%{!msoft-float:-D__HAVE_SKY__}\\\n+%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n+\n+#else\n+\n+/* -msoft-float is the default */\n+#define CPP_SPEC \\\n+\"%{msky:-D__HAVE_SKY__ }\\\n+%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n+\n+#endif\n+\n+/* STARTFILE_SPEC to include sun floating point initialization\n+   This is necessary (tr: Sun does it) for the sky routines.\n+   I'm not sure what would happen below if people gave contradictory\n+   arguments (eg. -msoft-float -mfpa) */\n+\n+#undef STARTFILE_SPEC\n+\n+#if TARGET_DEFAULT & 0200\n+/* -msky is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n+   %{msoft-float:Fcrt1.o%s}\t\t\t\t\\\n+   %{!msoft-float:Scrt1.o%s}\"\n+#else\n+/* -msoft-float is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n+   %{msky:Scrt1.o%s}\t\t\t\t\t\\\n+   %{!msky:Fcrt1.o%s}\"\n+#endif\n+\n+/* Specify library to handle `-a' basic block profiling.\n+   Control choice of libm.a (if user says -lm)\n+   based on fp arith default and options.  */\n+\n+#undef LIB_SPEC\n+\n+#if TARGET_DEFAULT & 0200\n+/* -msky is the default */\n+#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n+%{a:/usr/lib/bb_link.o -lc} %{g:-lg} \\\n+%{msoft-float:-L/usr/lib/fsoft} \\\n+%{!msoft_float:-L/usr/lib/fsky}\"\n+#else\n+/* -msoft-float is the default */\n+#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n+%{a:/usr/lib/bb_link.o -lc} %{g:-lg} \\\n+%{!msky:-L/usr/lib/fsoft} \\\n+%{msky:-L/usr/lib/ffpa}\"\n+#endif\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{!e*:-e start} -dc -dp %{g:-Bstatic} %{static:-Bstatic}\"\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"\\t.double 0r%s99e999\\n\", ((VALUE) > 0 ? \"\" : \"-\")) \\\n+   : REAL_VALUE_MINUS_ZERO ((VALUE))\t\t\t\t\t\\\n+   ? fprintf (FILE, \"\\t.long 0x80000000,0\\n\")\t\t\t\t\\\n+   : fprintf (FILE, \"\\t.double 0r%.20e\\n\", (VALUE)))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"\\t.single 0r%s99e999\\n\", ((VALUE) > 0 ? \"\" : \"-\")) \\\n+   : REAL_VALUE_MINUS_ZERO ((VALUE))\t\t\t\t\t\\\n+   ? fprintf (FILE, \"\\t.long 0x80000000\\n\")\t\t\t\t\\\n+   : fprintf (FILE, \"\\t.single 0r%.20e\\n\", (VALUE)))\n+\n+#undef ASM_OUTPUT_FLOAT_OPERAND\n+#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"#0r%s99e999\", ((VALUE) > 0 ? \"\" : \"-\")) \t\t\\\n+   : REAL_VALUE_MINUS_ZERO ((VALUE))\t\t\t\t\t\\\n+   ? fprintf (FILE, \"#0r-0.0\")\t\t\t\t\t\t\\\n+   : fprintf (FILE, \"#0r%.9g\", (VALUE)))\n+\n+#undef ASM_OUTPUT_DOUBLE_OPERAND\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? fprintf (FILE, \"#0r%s99e999\", ((VALUE) > 0 ? \"\" : \"-\"))\t\t\\\n+   : REAL_VALUE_MINUS_ZERO ((VALUE))\t\t\t\t\t\\\n+   ? fprintf (FILE, \"#0r-0.0\")\t\t\t\t\t\t\\\n+   : fprintf (FILE, \"#0r%.20g\", (VALUE)))"}, {"sha": "9c0afd8d31e2c9d4e26cfaa0b78477c789916f02", "filename": "gcc/config/m68k/sun3.h", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "patch": "@@ -0,0 +1,224 @@\n+/* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This comment is here to see if it will keep Sun's cpp from dying.  */\n+\n+/* If you do not need to generate floating point code for the optional\n+   Sun FPA board, you can safely comment out the SUPPORT_SUN_FPA define\n+   to gain a little speed and code size.  */\n+\n+#define SUPPORT_SUN_FPA\n+\n+#include \"m68k.h\"\n+\n+/* See m68k.h.  7 means 68020 with 68881.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 7\n+#endif\n+\n+/* Define __HAVE_FPA__ or __HAVE_68881__ in preprocessor,\n+   according to the -m flags.\n+   This will control the use of inline 68881 insns in certain macros.\n+   Also inform the program which CPU this is for.  */\n+\n+#if TARGET_DEFAULT & 02\n+\n+/* -m68881 is the default */\n+#define CPP_SPEC \\\n+\"%{!msoft-float:%{mfpa:-D__HAVE_FPA__ }%{!mfpa:-D__HAVE_68881__ }}\\\n+%{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n+\n+#else\n+#if TARGET_DEFAULT & 0100\n+\n+/* -mfpa is the default */\n+#define CPP_SPEC \\\n+\"%{!msoft-float:%{m68881:-D__HAVE_68881__ }%{!m68881:-D__HAVE_FPA__ }}\\\n+%{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n+\n+#else\n+\n+/* -msoft-float is the default */\n+#define CPP_SPEC \\\n+\"%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }\\\n+%{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n+\n+#endif\n+#endif\n+\n+/* Prevent error on `-sun3' and `-target sun3' options.  */\n+\n+#define CC1_SPEC \"%{sun3:} %{target:}\"\n+\n+#define PTRDIFF_TYPE \"int\"\n+#define SIZE_TYPE \"int\"\n+\n+/* We must override m68k.h.  */\n+#undef WCHAR_TYPE\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* These compiler options take an argument.  We ignore -target for now.  */\n+\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n+ (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\t\\\n+  || !strcmp (STR, \"imacros\") || !strcmp (STR, \"target\")\t\\\n+  || !strcmp (STR, \"assert\"))\n+\n+/* -m68000 requires special flags to the assembler.  */\n+\n+#define ASM_SPEC \\\n+ \"%{m68000:-mc68010}%{mc68000:-mc68010}%{!mc68000:%{!m68000:-mc68020}} \\\n+  %{fpic:-k} %{fPIC:-k}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dmc68000 -Dsun -Dunix\"\n+\n+/* STARTFILE_SPEC to include sun floating point initialization\n+   This is necessary (tr: Sun does it) for both the m68881 and the fpa\n+   routines.\n+   Note that includes knowledge of the default specs for gcc, ie. no\n+   args translates to the same effect as -m68881\n+   I'm not sure what would happen below if people gave contradictory\n+   arguments (eg. -msoft-float -mfpa) */\n+\n+#if TARGET_DEFAULT & 0100\n+/* -mfpa is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n+   %{m68881:Mcrt1.o%s}\t\t\t\t\t\\\n+   %{msoft-float:Fcrt1.o%s}\t\t\t\t\\\n+   %{!m68881:%{!msoft-float:Wcrt1.o%s}}\"\n+#else\n+#if TARGET_DEFAULT & 2\n+/* -m68881 is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n+   %{mfpa:Wcrt1.o%s}\t\t\t\t\t\\\n+   %{msoft-float:Fcrt1.o%s}\t\t\t\t\\\n+   %{!mfpa:%{!msoft-float:Mcrt1.o%s}}\"\n+#else\n+/* -msoft-float is the default */\n+#define STARTFILE_SPEC\t\t\t\t\t\\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n+   %{m68881:Mcrt1.o%s}\t\t\t\t\t\\\n+   %{mfpa:Wcrt1.o%s}\t\t\t\t\t\\\n+   %{!m68881:%{!mfpa:Fcrt1.o%s}}\"\n+#endif\n+#endif\n+\n+/* Specify library to handle `-a' basic block profiling.\n+   Control choice of libm.a (if user says -lm)\n+   based on fp arith default and options.  */\n+\n+#if TARGET_DEFAULT & 0100\n+/* -mfpa is the default */\n+#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n+%{a:/usr/lib/bb_link.o} %{g:-lg} \\\n+%{msoft-float:-L/usr/lib/fsoft}%{m68881:-L/usr/lib/f68881}\\\n+%{!msoft_float:%{!m68881:-L/usr/lib/ffpa}}\"\n+#else\n+#if TARGET_DEFAULT & 2\n+/* -m68881 is the default */\n+#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n+%{a:/usr/lib/bb_link.o} %{g:-lg} \\\n+%{msoft-float:-L/usr/lib/fsoft}%{!msoft-float:%{!mfpa:-L/usr/lib/f68881}}\\\n+%{mfpa:-L/usr/lib/ffpa}\"\n+#else\n+/* -msoft-float is the default */\n+#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n+%{a:/usr/lib/bb_link.o} %{g:-lg} \\\n+%{!m68881:%{!mfpa:-L/usr/lib/fsoft}}%{m68881:-L/usr/lib/f68881}\\\n+%{mfpa:-L/usr/lib/ffpa}\"\n+#endif\n+#endif\n+\n+/* Provide required defaults for linker -e and -d switches.\n+   Also, it is hard to debug with shared libraries,\n+   so don't use them if going to debug.  */\n+\n+#define LINK_SPEC \"%{!e*:-e start} -dc -dp %{g:-Bstatic} %{static:-Bstatic} \\\n+  %{assert*}\"\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* This is BSD, so it wants DBX format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Allow folding division by zero.  */\n+#define REAL_INFINITY\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n+    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunion { double d; long l[2];} t;\t\t\t\t\\\n+\tt.d = (VALUE);\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\", t.l[0], t.l[1]); \\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double 0r%.17g\\n\", VALUE);\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.single 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n+    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunion { float f; long l;} t;\t\t\t\t\t\\\n+\tt.f = (VALUE);\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.long 0x%lx\\n\", t.l);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.single 0r%.9g\\n\", VALUE);\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler lines defining floating operands.\n+   There's no way to output a NaN's fraction, so we lose it.  */\n+  \n+#undef ASM_OUTPUT_FLOAT_OPERAND\n+#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? (asm_fprintf (FILE, \"%I0r%s99e999\", ((VALUE) > 0 ? \"\" : \"-\")), 0)\t\\\n+   : (VALUE) == -0.0\t\t\t\t\t\t\t\\\n+   ? (asm_fprintf (FILE, \"%I0r-0.0\"), 0)\t\t\t\t\\\n+   : (asm_fprintf (FILE, \"%I0r%.9g\", (VALUE)), 0))\n+\n+#undef ASM_OUTPUT_DOUBLE_OPERAND\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  (REAL_VALUE_ISINF ((VALUE))\t\t\t\t\t\t\\\n+   ? (asm_fprintf (FILE, \"%I0r%s99e999\", ((VALUE) > 0 ? \"\" : \"-\")), 0)\t\\\n+   : (VALUE) == -0.0\t\t\t\t\t\t\t\\\n+   ? (asm_fprintf (FILE, \"%I0r-0.0\"), 0)\t\t\t\t\\\n+   : (asm_fprintf (FILE, \"%I0r%.17g\", (VALUE)), 0))"}, {"sha": "1f1d2c30f2522d67b7fcd0294143befab4899638", "filename": "gcc/config/sparc/sparc.h", "status": "added", "additions": 1602, "deletions": 0, "changes": 1602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=1bb87f283fc5d3a01e25aafce8d16e8126c3dcb0", "patch": "@@ -0,0 +1,1602 @@\n+/* Definitions of target machine for GNU compiler, for Sun SPARC.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} %{g:-lg}\"\n+\n+/* Provide required defaults for linker -e and -d switches.\n+   Also, it is hard to debug with shared libraries,\n+   so don't use them if going to debug.  */\n+\n+#define LINK_SPEC \"%{!e*:-e start} -dc -dp %{static:-Bstatic} %{assert*}\"\n+\n+/* Special flags to the Sun-4 assembler when using pipe for input.  */\n+\n+#define ASM_SPEC \" %{pipe:-} %{fpic:-k} %{fPIC:-k}\"\n+\n+/* Prevent error on `-dalign', `-sun4' and `-target sun4' options.  */\n+/* Also, make it easy to specify interesting optimization options.  */\n+\n+#define CC1_SPEC \"%{dalign:-malign} %{sun4:} %{target:}\"\n+\n+#define PTRDIFF_TYPE \"int\"\n+#define SIZE_TYPE \"int\"\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Omit frame pointer and enable caller-saves at high optimization levels.  */\n+\n+#define OPTIMIZATION_OPTIONS(OPTIMIZE) \\\n+{  \t\t\t\t\t\t\t\t\\\n+  if (OPTIMIZE >= 2) \t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      flag_omit_frame_pointer = 1;\t\t\t\t\\\n+      flag_caller_saves = 1;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* These compiler options take an argument.  We ignore -target for now.  */\n+\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n+ (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\t\\\n+  || !strcmp (STR, \"imacros\") || !strcmp (STR, \"target\")\t\\\n+  || !strcmp (STR, \"assert\"))\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dsparc -Dsun -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (sparc)\");\n+\n+/* Generate DBX debugging information.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Nonzero if we should generate code to use the fpu.  */\n+#define TARGET_FPU (target_flags & 1)\n+\n+/* Nonzero if we should use FUNCTION_EPILOGUE.  Otherwise, we\n+   use fast return insns, but lose some generality.  */\n+#define TARGET_EPILOGUE (target_flags & 2)\n+\n+/* Nonzero if we assume that all calls will fall within a 16MB\n+   pc-relative range.  Useful with -fomit-frame-pointer.  */\n+#define TARGET_TAIL_CALL (target_flags & 8)\n+\n+/* Nonzero means that references to doublewords are guaranteed\n+   aligned...if not, its a bug in the users program!  */\n+#define TARGET_ALIGN (target_flags & 16)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"fpu\", 1},\t\t\t\\\n+    {\"soft-float\", -1},\t\t\\\n+    {\"epilogue\", 2},\t\t\\\n+    {\"no-epilogue\", -2},\t\\\n+    {\"tail-call\", 8},\t\t\\\n+    {\"align\", 16},\t\t\\\n+   { \"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 3\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* This is true on the SPARC.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* Doubles are stored in memory with the high order word first.  This\n+   matters when cross-compiling.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+#define MAX_BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\n+/* Things that must be doubleword aligned cannot go in the text section,\n+   because the linker fails to align the text section enough!\n+   Put them in the data section.  */\n+#define MAX_TEXT_ALIGN 32\n+\n+#define SELECT_SECTION(T,RELOC)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (T) == VAR_DECL)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TREE_READONLY (T) && ! TREE_SIDE_EFFECTS (T)\t\t\t\\\n+\t  && DECL_ALIGN (T) <= MAX_TEXT_ALIGN\t\t\t\t\\\n+\t  && ! (flag_pic && (RELOC)))\t\t\t\t\t\\\n+\ttext_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (T) == CONSTRUCTOR)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (flag_pic != 0 && (RELOC) != 0)\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (*tree_code_type[(int) TREE_CODE (T)] == 'c')\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((TREE_CODE (T) == STRING_CST && flag_writable_strings)\t\\\n+\t  || TYPE_ALIGN (TREE_TYPE (T)) > MAX_TEXT_ALIGN)\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\ttext_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Use text section for a constant\n+   unless we need more alignment than that offers.  */\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\\\n+{\t\t\t\t\t\t\\\n+  if (GET_MODE_BITSIZE (MODE) <= MAX_TEXT_ALIGN \\\n+      && ! (flag_pic && symbolic_operand (X)))  \\\n+    text_section ();\t\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    data_section ();\t\t\t\t\\\n+}\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   SPARC has 32 integer registers and 32 floating point registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 64\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   0 is used for the condition code and not to represent %g0, which is\n+   hardwired to 0, so reg 0 is *not* fixed.\n+   2 and 3 are free to use as temporaries.\n+   4 through 7 are expected to become usefully defined in the future.\n+   Your milage may vary.  */\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On SPARC, ordinary registers hold 32 bits worth;\n+   this means both integer and floating point registers.\n+\n+   We use vectors to keep this information about registers.  */\n+\n+/* How many hard registers it takes to make a register of this mode.  */\n+extern int hard_regno_nregs[];\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if register/mode pair is acceptable on sparc.  */\n+extern int hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On SPARC, the cpu registers can hold any mode but the float registers\n+   can only hold SFmode or DFmode.  See sparc.c for how we\n+   initialize this.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((hard_regno_mode_ok[REGNO] & (1<<(int)(MODE))) != 0)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* SPARC pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 14\n+\n+/* Actual top-of-stack address is 92 greater than the contents\n+   of the stack pointer register.  92 = 68 + 24.  64 bytes reserving space\n+   for the ins and local registers, 4 byte for structure return address, and\n+   24 bytes for the 6 register parameters.  */\n+#define STACK_POINTER_OFFSET FIRST_PARM_OFFSET(0)\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 30\n+\n+#if 0\n+/* Register that is used for the return address.  */\n+#define RETURN_ADDR_REGNUM 15\n+#endif\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.\n+\n+   Used in flow.c, global-alloc.c, and reload1.c.  */\n+extern int leaf_function;\n+\n+#define FRAME_POINTER_REQUIRED \\\n+  (! (leaf_function_p () && only_leaf_regs_used ()))\n+\n+/* C statement to store the difference between the frame pointer\n+   and the stack pointer values immediately after the function prologue.\n+\n+   Note, we always pretend that this is a leaf function because if\n+   it's not, there's no point in trying to eliminate the\n+   frame pointer.  If it is a leaf function, we guessed right!  */\n+#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n+  do { (VAR) = compute_frame_size (get_frame_size (), 1); } while (0)\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 30\n+\n+/* Register in which static-chain is passed to a function.  */\n+/* ??? */\n+#define STATIC_CHAIN_REGNUM 1\n+\n+/* Register which holds offset table for position-independent\n+   data references.  */\n+\n+#define PIC_OFFSET_TABLE_REGNUM 23\n+\n+#define INITIALIZE_PIC initialize_pic ()\n+#define FINALIZE_PIC finalize_pic ()\n+\n+/* Functions which return large structures get the address\n+   to place the wanted value at offset 64 from the frame.\n+   Must reserve 64 bytes for the in and local registers.  */\n+/* Used only in other #defines in this file.  */\n+#define STRUCT_VALUE_OFFSET 64\n+\n+#define STRUCT_VALUE \\\n+  gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n+\t   gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\\\n+\t\t    gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET)))\n+#define STRUCT_VALUE_INCOMING \\\n+  gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n+\t   gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n+\t\t    gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET)))\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The SPARC has two kinds of registers, general and floating point.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#if 0 && defined (__GNUC__)\n+#define REG_CLASS_CONTENTS {0LL, 0xfffffffeLL, 0xffffffff00000000LL, 0xfffffffffffffffeLL}\n+#else\n+#define REG_CLASS_CONTENTS {{0, 0}, {-2, 0}, {0, -1}, {-2, -1}}\n+#endif\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) >= 32 ? FP_REGS : (REGNO) == 0 ? NO_REGS : GENERAL_REGS)\n+\n+/* This is the order in which to allocate registers\n+   normally.  */\n+#define REG_ALLOC_ORDER \\\n+{ 8, 9, 10, 11, 12, 13, 2, 15,\t\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23,\t\\\n+  24, 25, 26, 27, 28, 29, 3, 31,\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39,\t\\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n+  1, 4, 5, 6, 7, 0, 14, 30};\n+\n+/* This is the order in which to allocate registers for\n+   leaf functions.  If all registers can fit in the \"i\" registers,\n+   then we have the possibility of having a leaf function.  */\n+#define REG_LEAF_ALLOC_ORDER \\\n+{ 2, 3, 24, 25, 26, 27, 28, 29,\t\t\\\n+  15, 8, 9, 10, 11, 12, 13,\t\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23,\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39,\t\\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n+  1, 4, 5, 6, 7, 0, 14, 30, 31};\n+\n+#define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n+\n+#define LEAF_REGISTERS \\\n+{ 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 0, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1};\n+\n+extern char leaf_reg_remap[];\n+#define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n+extern char leaf_reg_backmap[];\n+#define LEAF_REG_BACKMAP(REGNO) (leaf_reg_backmap[REGNO])\n+\n+#define REG_USED_SO_FAR(REGNO) \\\n+  ((REGNO) >= 24 && (REGNO) < 30\t\\\n+   ? (regs_ever_live[24]\t\t\\\n+      || regs_ever_live[25]\t\t\\\n+      || regs_ever_live[26]\t\t\\\n+      || regs_ever_live[27]\t\t\\\n+      || regs_ever_live[28]\t\t\\\n+      || regs_ever_live[29]) : 0)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS : (C) == 'r' ? GENERAL_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For SPARC, `I' is used for the range of constants an insn\n+   can actually contain.\n+   `J' is used for the range which is just zero (since that is R0).\n+   `K' is used for the 5-bit operand of a compare insns.  */\n+\n+#define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x1000) < 0x2000)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? (unsigned) ((VALUE) + 0x1000) < 0x2000\t\\\n+   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n+   : (C) == 'K' ? ((VALUE) & 0x3ff) == 0\t\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n+  ((C) == 'G' ? CONST_DOUBLE_HIGH (VALUE) == 0\t\t\\\n+   && CONST_DOUBLE_LOW (VALUE) == 0\t\t\t\\\n+   : (C) == 'H' ? arith_double_operand (VALUE, DImode)\t\\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+\n+/* Return the register class of a scratch register needed to load IN into\n+   a register of class CLASS in MODE.\n+\n+   On the SPARC, when PIC, we need a temporary when loading some addresses\n+   into a register.  */\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN) \\\n+  (flag_pic && pic_address_needs_scratch (IN) ? GENERAL_REGS : NO_REGS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On SPARC, this is the size of MODE in words.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define the number of register that can hold parameters.\n+   These two macros are used only in other macro definitions below.  */\n+#define NPARM_REGS 6\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET (-16)\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On SPARC, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Offset of first parameter from the argument pointer register value.\n+   This is 64 for the ins and locals, plus 4 for the struct-return reg\n+   even if this function isn't going to use it.  */\n+#define FIRST_PARM_OFFSET(FNDECL) (STRUCT_VALUE_OFFSET + UNITS_PER_WORD)\n+\n+/* Offset from top-of-stack address to location to store the\n+   function parameter if it can't go in a register.\n+   Addresses for following parameters are computed relative to this one.  */\n+#define FIRST_PARM_CALLER_OFFSET(FNDECL)\t\\\n+  (STRUCT_VALUE_OFFSET + UNITS_PER_WORD - STACK_POINTER_OFFSET)\n+\n+/* When a parameter is passed in a register, stack space is still\n+   allocated for it.  */\n+#define REG_PARM_STACK_SPACE(DECL) (NPARM_REGS * UNITS_PER_WORD)\n+\n+/* Keep the stack pointer constant throughout the function.\n+   This is both an optimization and a neccessity: longjmp\n+   doesn't behave itself when the stack pointer moves within\n+   the function!  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Some subroutine macros specific to this machine.  */\n+#define BASE_RETURN_VALUE_REG(MODE) \\\n+ ((MODE) == SFmode || (MODE) == DFmode ? 32 : 8)\n+#define BASE_OUTGOING_VALUE_REG(MODE) \\\n+ ((MODE) == SFmode || (MODE) == DFmode ? 32 : 24)\n+#define BASE_PASSING_ARG_REG(MODE) (8)\n+#define BASE_INCOMING_ARG_REG(MODE) (24)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On SPARC the value is found in the first \"output\" register.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n+\n+/* But the called function leaves it in the first \"input\" register.  */\n+\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), BASE_OUTGOING_VALUE_REG (TYPE_MODE (VALTYPE)))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)\t\\\n+  gen_rtx (REG, MODE, BASE_RETURN_VALUE_REG (MODE))\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+   On SPARC, the first \"output\" reg is used for integer values,\n+   and the first floating point register is used for floating point values.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 8 || (N) == 32)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On SPARC, these are the \"output\" registers.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) ((N) < 14 && (N) > 7)\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On SPARC, this is a single integer, which is a number of words\n+   of arguments scanned so far (including the invisible argument,\n+   if any, which holds the structure-value-address).\n+   Thus 7 or more means all following args should go on the stack.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+#define ROUND_ADVANCE(SIZE)\t\\\n+  ((SIZE + UNITS_PER_WORD - 1)/UNITS_PER_WORD)\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On SPARC, the offset always starts at 0: the first parm reg is always\n+   the same reg.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\t\\\n+\t    ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n+\t    : ROUND_ADVANCE (int_size_in_bytes (TYPE))))\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On SPARC the first six args are normally in registers\n+   and the rest are pushed.  Any arg that starts within the first 6 words\n+   is at least partially passed in a register unless its data type forbids.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n+((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n+ && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n+ && ((TYPE)==0 || (MODE) != BLKmode || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\\\n+ ? gen_rtx (REG, (MODE), BASE_PASSING_ARG_REG (MODE) + (CUM)) : 0)\n+\n+/* Define where a function finds its arguments.\n+   This is different from FUNCTION_ARG because of register windows.  */\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n+ && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n+ && ((MODE) != BLKmode || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\\\n+ ? gen_rtx (REG, (MODE), BASE_INCOMING_ARG_REG (MODE) + (CUM)) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.\n+   Any arg that starts in the first 6 regs but won't entirely fit in them\n+   needs partial registers on the Sparc.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n+  (((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n+    && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n+    && ((TYPE)==0 || (MODE) != BLKmode || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\\\n+    && ((CUM)\t\t\t\t\t\t\t\t\\\n+\t+ ((MODE) == BLKmode\t\t\t\t\t\t\\\n+\t   ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\t\\\n+\t   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))) - NPARM_REGS > 0)\t\t\\\n+   ? (NPARM_REGS - (CUM))\t\t\t\t\t\t\\\n+   : 0)\n+\n+/* The SPARC ABI stipulates passing struct arguments (of any size)\n+   by invisible reference.  */\n+/* Must pass by reference if this is a structure/union type, and this is not\n+   target gnu or the address of this structure is needed somewhere.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  (TYPE && (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE (TYPE) == UNION_TYPE))\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def *sparc_compare_op0, *sparc_compare_op1;\n+\n+/* Define the function that build the compare insn for scc and bcc.  */\n+\n+extern struct rtx_def *gen_compare_reg ();\n+\f\n+/* Output the label for a function definition.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+{\t\t\t\t\t\t\t\\\n+  extern tree double_type_node, float_type_node;\t\\\n+  if (TREE_TYPE (DECL) == float_type_node)\t\t\\\n+    fprintf (FILE, \"\\t.proc 6\\n\");\t\t\t\\\n+  else if (TREE_TYPE (DECL) == double_type_node)\t\\\n+    fprintf (FILE, \"\\t.proc 7\\n\");\t\t\t\\\n+  else if (TREE_TYPE (DECL) == void_type_node)\t\t\\\n+    fprintf (FILE, \"\\t.proc 0\\n\");\t\t\t\\\n+  else fprintf (FILE, \"\\t.proc 1\\n\");\t\t\t\\\n+  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\\\n+}\n+\n+/* Two views of the size of the current frame.  */\n+extern int actual_fsize;\n+extern int apparent_fsize;\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+/* On SPARC, move-double insns between fpu and cpu need an 8-byte block\n+   of memory.  If any fpu reg is used in the function, we allocate\n+   such a block here, at the bottom of the frame, just in case it's needed.\n+\n+   If this function is a leaf procedure, then we may choose not\n+   to do a \"save\" insn.  The decision about whether or not\n+   to do this is made in regclass.c.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\\\n+  output_function_prologue (FILE, SIZE, leaf_function)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tsethi %%hi(LP%d),%%o0\\n\\tcall mcount\\n\\tor %%lo(LP%d),%%o0,%%o0\\n\", \\\n+\t   (LABELNO), (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tsethi %%hi(LPBX0),%%o0\\n\\tld [%%lo(LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne LPY%d\\n\\tadd %%o0,%%lo(LPBX0),%%o0\\n\\tcall ___bb_init_func\\n\\tnop\\nLPY%d:\\n\",  \\\n+\t   (LABELNO), (LABELNO))\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n+{\t\t\t\t\t\t\t\t\\\n+  int blockn = (BLOCKNO);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tsethi %%hi(LPBX2+%d),%%g1\\n\\tld [%%lo(LPBX2+%d)+%%g1],%%g2\\n\\\n+\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(LPBX2+%d)+%%g1]\\n\",\t\t\\\n+\t   4 * blockn, 4 * blockn, 4 * blockn);\t\t\t\\\n+}\n+\n+/* Output rtl to increment the entry-count for the LABELNO'th instrumented\n+   arc in this source file.  */\n+\n+#define ARC_PROFILER(ARCNO, INSERT_AFTER) \\\n+  output_arc_profiler (ARCNO, INSERT_AFTER)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+extern int current_function_calls_alloca;\n+extern int current_function_outgoing_args_size;\n+\n+#define EXIT_IGNORE_STACK\t\\\n+ (get_frame_size () != 0\t\\\n+  || current_function_calls_alloca || current_function_outgoing_args_size)\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+/* This declaration is needed due to traditional/ANSI\n+   incompatibilities which cannot be #ifdefed away\n+   because they occur inside of macros.  Sigh.  */\n+extern union tree_node *current_function_decl;\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n+  output_function_epilogue (FILE, SIZE, leaf_function, 1)\n+\n+#define DELAY_SLOTS_FOR_EPILOGUE 1\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\\n+  eligible_for_epilogue_delay (trial, slots_filled)\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the sparc, the trampoline contains five instructions:\n+     sethi #TOP_OF_FUNCTION,%g2\n+     or #BOTTOM_OF_FUNCTION,%g2,%g2\n+     sethi #TOP_OF_STATIC,%g1\n+     jmp g2\n+     or #BOTTOM_OF_STATIC,%g1,%g1  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x00000000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x00000000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x00000000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x81C08000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x00000000));\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   This takes 16 insns: 2 shifts & 2 ands (to split up addresses), 4 sethi\n+   (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes\n+   (to store insns).  This is a bit excessive.  Perhaps a different\n+   mechanism would be better here.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx high_cxt = expand_shift (RSHIFT_EXPR, SImode, CXT,\t\t\\\n+\t\t\t      size_int (10), 0, 1);\t\t\t\\\n+  rtx high_fn = expand_shift (RSHIFT_EXPR, SImode, FNADDR,\t\t\\\n+\t\t\t     size_int (10), 0, 1);\t\t\t\\\n+  rtx low_cxt = expand_and (CXT, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0); \\\n+  rtx low_fn = expand_and (FNADDR, gen_rtx (CONST_INT, VOIDmode, 0x3ff), 0); \\\n+  rtx g1_sethi = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x03000000));\t\\\n+  rtx g2_sethi = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 0x05000000));\t\\\n+  rtx g1_ori = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x82106000));\t\\\n+  rtx g2_ori = gen_rtx (HIGH, SImode,\t\t\t\t\t\\\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 0x8410A000));\t\\\n+  rtx tem = gen_reg_rtx (SImode);\t\t\t\t\t\\\n+  emit_move_insn (tem, g2_sethi);\t\t\t\t\t\\\n+  emit_insn (gen_iorsi3 (high_fn, high_fn, tem));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 0)), high_fn);\\\n+  emit_move_insn (tem, g2_ori);\t\t\t\t\t\t\\\n+  emit_insn (gen_iorsi3 (low_fn, low_fn, tem));\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), low_fn);\\\n+  emit_move_insn (tem, g1_sethi);\t\t\t\t\t\\\n+  emit_insn (gen_iorsi3 (high_cxt, high_cxt, tem));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 8)), high_cxt);\\\n+  emit_move_insn (tem, g1_ori);\t\t\t\t\t\t\\\n+  emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), low_cxt);\\\n+}\n+\n+/* Emit code for a call to builtin_saveregs.  We must emit USE insns which\n+   reference the 6 input registers.  Ordinarily they are not call used\n+   registers, but they are for _builtin_saveregs, so we must make this\n+   explicit.  */\n+\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST)\t\t\t\t\\\n+  (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, TImode, 24))),\t\\\n+   emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DImode, 28))),\t\\\n+   expand_call (exp, target, ignore))\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+(((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32) && (REGNO) != 0)\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+(((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32) && (REGNO) != 0)\n+#define REGNO_OK_FOR_FP_P(REGNO) \\\n+(((REGNO) ^ 0x20) < 32\t\\\n+ || (((REGNO) != 0) && (unsigned) (reg_renumber[REGNO] ^ 0x20) < 32))\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the SPARC, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) (CONSTANT_P (X))\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   Anything can be made to work except floating point constants.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+/* Optional extra constraints for this machine.  Borrowed from romp.h.\n+\n+   For the SPARC, `Q' means that this is a memory operand but not a\n+   symbolic memory operand.  Note that an unassigned pseudo register\n+   is such a memory operand.  Needed because reload will generate\n+   these things in insns and then not re-recognize the insns, causing\n+   constrain_operands to fail.\n+\n+   `R' handles the LO_SUM which can be an address for `Q'.\n+\n+   `S' handles constraints for calls.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) (((unsigned) REGNO (X)) - 32 >= 32 && REGNO (X) != 0)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (((unsigned) REGNO (X)) - 32 >= 32 && REGNO (X) != 0)\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ?\t\t\t\t\t\t\\\n+   ((GET_CODE (OP) == MEM\t\t\t\t\\\n+     && memory_address_p (GET_MODE (OP), XEXP (OP, 0))\t\\\n+     && ! symbolic_memory_operand (OP, VOIDmode)))\t\\\n+   : ((C) == 'R' ?\t\t\t\t\t\\\n+      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n+       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n+      : ((C) == 'S'\t\t\t\t\t\\\n+\t ? CONSTANT_P (OP) || memory_address_p (Pmode, OP) : 0)))\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ?\t\t\t\t\t\t\\\n+   (GET_CODE (OP) == REG ?\t\t\t\t\\\n+    (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n+     && reg_renumber[REGNO (OP)] < 0)\t\t\t\\\n+    : GET_CODE (OP) == MEM)\t\t\t\t\\\n+   : ((C) == 'R' ?\t\t\t\t\t\\\n+      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n+       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n+      : ((C) == 'S'\t\t\t\t\t\\\n+\t ? (CONSTANT_P (OP)\t\t\t\t\\\n+\t    || (GET_CODE (OP) == REG && reg_renumber[REGNO (OP)] > 0)\\\n+\t    || strict_memory_address_p (Pmode, OP)) : 0)))\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On SPARC, the actual legitimate addresses must be REG+REG or REG+SMALLINT\n+   ordinarily.  This changes a bit when generating PIC.\n+\n+   If you change this, execute \"rm explow.o recog.o reload.o\".  */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{ if (GET_CODE (X) == REG)\t\t\t\t\\\n+    { if (REG_OK_FOR_BASE_P (X)) goto ADDR; }\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (flag_pic && XEXP (X, 0) == pic_offset_table_rtx)\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t  else if (flag_pic == 1\t\t\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) != REG\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) != LO_SUM\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) != MEM)\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+\t      && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n+\t      && INTVAL (XEXP (X, 1)) >= -0x1000\t\\\n+\t      && INTVAL (XEXP (X, 1)) < 0x1000)\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+\t      && REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\\\n+\t      && INTVAL (XEXP (X, 0)) >= -0x1000\t\\\n+\t      && INTVAL (XEXP (X, 0)) < 0x1000)\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+\t   && CONSTANT_P (XEXP (X, 1)))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == SUBREG\t\t\\\n+\t   && GET_CODE (SUBREG_REG (XEXP (X, 0))) == REG\\\n+\t   && REG_OK_FOR_BASE_P (SUBREG_REG (XEXP (X, 0)))\\\n+\t   && CONSTANT_P (XEXP (X, 1)))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_INT && SMALL_INT (X))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+/* On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n+extern struct rtx_def *legitimize_pic_address ();\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n+{ rtx sparc_x = (X);\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 1),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n+    (X) = gen_rtx (PLUS, Pmode, force_operand (XEXP (X, 0), 0),\\\n+\t\t   XEXP (X, 1));\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n+    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+  if (sparc_x != (X) && memory_address_p (MODE, X))\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\\\n+  if (flag_pic) (X) = legitimize_pic_address (X, MODE, 0, 0);\t\\\n+  else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n+    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 0),\t\t\t\\\n+\t\t   copy_to_mode_reg (Pmode, XEXP (X, 1)));\t\\\n+  else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n+    (X) = gen_rtx (PLUS, Pmode, XEXP (X, 1),\t\t\t\\\n+\t\t   copy_to_mode_reg (Pmode, XEXP (X, 0)));\t\\\n+  else if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n+\t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n+    (X) = gen_rtx (LO_SUM, Pmode,\t\t\t\t\\\n+\t\t   copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode, X)), X); \\\n+  if (memory_address_p (MODE, X))\t\t\t\t\\\n+    goto WIN; }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the SPARC this is never true.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.\n+   For RISC chips, it means that access to memory by bytes is no\n+   better than access by words when possible, so grab a whole word\n+   and maybe make use of that.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   On the Sparc, we have a \"no-overflow\" mode which is used when an add or\n+   subtract insn is used to set the condition code.  Different branches are\n+   used in this case for some operations.\n+\n+   We also have a mode to indicate that the relevant condition code is\n+   in the floating-point condition code.  This really should be a separate\n+   register, but we don't want to go to 65 registers.  */\n+#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode\n+\n+/* Define the names for the modes specified above.  */\n+#define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\"\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  For floating-point, CCFPmode\n+   should be used.  CC_NOOVmode should be used when the first operand is a\n+   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n+   needed.  */\n+#define SELECT_CC_MODE(OP,X) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\t    \\\n+   : (GET_CODE (X) == PLUS || GET_CODE (X) == MINUS || GET_CODE (X) == NEG) \\\n+   ? CC_NOOVmode : CCmode)\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* alloca should avoid clobbering the old register save area.  */\n+#define SETJMP_VIA_SAVE_AREA\n+\n+/* Define subroutines to call to handle multiply and divide.\n+   Use the subroutines that Sun's library provides.\n+   The `*' prevents an underscore from being prepended by the compiler.  */\n+\n+#define DIVSI3_LIBCALL \"*.div\"\n+#define UDIVSI3_LIBCALL \"*.udiv\"\n+#define MODSI3_LIBCALL \"*.rem\"\n+#define UMODSI3_LIBCALL \"*.urem\"\n+/* .umul is a little faster than .mul.  */\n+#define MULSI3_LIBCALL \"*.umul\"\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) == 0)\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) < 0x1000 && INTVAL (RTX) >= -0x1000)\t\\\n+      return 1;\t\t\t\t\t\t\t\\\n+  case HIGH:\t\t\t\t\t\t\t\\\n+    return 2;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    if (GET_MODE (RTX) == DImode)\t\t\t\t\\\n+      if ((XINT (RTX, 3) == 0\t\t\t\t\t\\\n+\t   && (unsigned) XINT (RTX, 2) < 0x1000)\t\t\\\n+\t  || (XINT (RTX, 3) == -1\t\t\t\t\\\n+\t      && XINT (RTX, 2) < 0\t\t\t\t\\\n+\t      && XINT (RTX, 2) >= -0x1000))\t\t\t\\\n+\treturn 1;\t\t\t\t\t\t\\\n+    return 8;\n+\n+/* SPARC offers addressing modes which are \"as cheap as a register\".\n+   See sparc.c (or gcc.texinfo) for details.  */\n+\n+#define ADDRESS_COST(RTX) \\\n+  (GET_CODE (RTX) == REG ? 1 : sparc_address_cost (RTX))\n+\n+/* Compute extra cost of moving data between one register class\n+   and another.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) \\\n+  (((CLASS1 == FP_REGS && CLASS2 == GENERAL_REGS) \\\n+    || (CLASS1 == GENERAL_REGS && CLASS2 == FP_REGS)) ? 6 : 2)\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  The purpose for the cost of MULT is to encourage\n+   `synth_mult' to find a synthetic multiply when reasonable.\n+\n+   If we need more than 12 insns to do a multiply, then go out-of-line,\n+   since the call overhead will be < 10% of the cost of the multiply.  */\n+\n+#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (25);\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (20);\t\t\t\t\\\n+  /* Make FLOAT more expensive than CONST_DOUBLE,\t\\\n+     so that cse will favor the latter.  */\t\t\\\n+  case FLOAT:\t\t\t\t\t\t\\\n+    return 19;\n+\n+/* Conditional branches with empty delay slots have a length of two.  */\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\\\n+  if (GET_CODE (INSN) == CALL_INSN\t\t\t\t\t\\\n+      || (GET_CODE (INSN) == JUMP_INSN && ! simplejump_p (insn)))\t\\\n+    LENGTH += 1;\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(file)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"%g0\", \"%g1\", \"%g2\", \"%g3\", \"%g4\", \"%g5\", \"%g6\", \"%g7\",\t\t\\\n+ \"%o0\", \"%o1\", \"%o2\", \"%o3\", \"%o4\", \"%o5\", \"%sp\", \"%o7\",\t\t\\\n+ \"%l0\", \"%l1\", \"%l2\", \"%l3\", \"%l4\", \"%l5\", \"%l6\", \"%l7\",\t\t\\\n+ \"%i0\", \"%i1\", \"%i2\", \"%i3\", \"%i4\", \"%i5\", \"%fp\", \"%i7\",\t\t\\\n+ \"%f0\", \"%f1\", \"%f2\", \"%f3\", \"%f4\", \"%f5\", \"%f6\", \"%f7\",\t\t\\\n+ \"%f8\", \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\t\t\\\n+ \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\t\\\n+ \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\"}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* On Sun 4, this limit is 2048.  We use 1500 to be safe,\n+   since the length can run past this up to a continuation point.  */\n+#define DBX_CONTIN_LENGTH 1500\n+\n+/* This is how to output a note to DBX telling it the line number\n+   to which the following sequence of instructions corresponds.\n+\n+   This is needed for SunOS 4.0, and should not hurt for 3.2\n+   versions either.  */\n+#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\\\n+  { static int sym_lineno = 1;\t\t\t\t\\\n+    fprintf (file, \".stabn 68,0,%d,LM%d\\nLM%d:\\n\",\t\\\n+\t     line, sym_lineno, sym_lineno);\t\t\\\n+    sym_lineno += 1; }\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n+    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunion { double d; long l[2];} t;\t\t\t\t\\\n+\tt.d = (VALUE);\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.word 0x%lx\\n\\t.word 0x%lx\\n\", t.l[0], t.l[1]); \\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double 0r%.17g\\n\", VALUE);\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.single 0r%s99e999\\n\", (VALUE) > 0 ? \"\" : \"-\");\t\\\n+    else if (isnan (VALUE))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunion { float f; long l;} t;\t\t\t\t\t\\\n+\tt.f = (VALUE);\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.word 0x%lx\\n\", t.l);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.single 0r%.9g\\n\", VALUE);\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line defining a DImode constant.  */\n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n+  output_double_int (FILE, VALUE)\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (SPARC uses such vectors only when generating PIC.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word L%d-1b\\n\", VALUE)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (1<<(LOG)))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.skip %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.global \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fputs (\"\\n\\t.common \", (FILE)),\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u,\\\"bss\\\"\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\n\\t.reserve \", (FILE)),\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u,\\\"bss\\\"\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+  ((CHAR) == '@' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^')\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx base, index = 0;\t\t\t\t\t\\\n+  int offset = 0;\t\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\\\n+  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n+    fputs (reg_names[REGNO (addr)], FILE);\t\t\t\\\n+  else if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\\\n+\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\\\n+      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\\\n+\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\\\n+      else\t\t\t\t\t\t\t\\\n+\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\t\t\\\n+      fputs (reg_names[REGNO (base)], FILE);\t\t\t\\\n+      if (index == 0)\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"%+d\", offset);\t\t\t\t\\\n+      else if (GET_CODE (index) == REG)\t\t\t\t\\\n+\tfprintf (FILE, \"+%s\", reg_names[REGNO (index)]);\t\\\n+      else if (GET_CODE (index) == SYMBOL_REF)\t\t\t\\\n+\tfputc ('+', FILE), output_addr_const (FILE, index);\t\\\n+      else abort ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (addr) == MINUS\t\t\t\t\\\n+\t   && GET_CODE (XEXP (addr, 1)) == LABEL_REF)\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, XEXP (addr, 0));\t\t\t\\\n+      fputs (\"-(\", FILE);\t\t\t\t\t\\\n+      output_addr_const (FILE, XEXP (addr, 1));\t\t\t\\\n+      fputs (\"-.)\", FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (addr) == LO_SUM)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      output_operand (XEXP (addr, 0), 0);\t\t\t\\\n+      fputs (\"+%lo(\", FILE);\t\t\t\t\t\\\n+      output_address (XEXP (addr, 1));\t\t\t\t\\\n+      fputc (')', FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (flag_pic && GET_CODE (addr) == CONST\t\t\t\\\n+\t   && GET_CODE (XEXP (addr, 0)) == MINUS\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST\t\\\n+\t   && GET_CODE (XEXP (XEXP (XEXP (addr, 0), 1), 0)) == MINUS\t\\\n+\t   && XEXP (XEXP (XEXP (XEXP (addr, 0), 1), 0), 1) == pc_rtx)\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      addr = XEXP (addr, 0);\t\t\t\t\t\\\n+      output_addr_const (FILE, XEXP (addr, 0));\t\t\t\\\n+      /* Group the args of the second CONST in parenthesis.  */\t\\\n+      fputs (\"-(\", FILE);\t\t\t\t\t\\\n+      /* Skip past the second CONST--it does nothing for us.  */\\\n+      output_addr_const (FILE, XEXP (XEXP (addr, 1), 0));\t\\\n+      /* Close the parenthesis.  */\t\t\t\t\\\n+      fputc (')', FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, addr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Declare functions defined in sparc.c and used in templates.  */\n+\n+extern char *singlemove_string ();\n+extern char *output_move_double ();\n+extern char *output_fp_move_double ();\n+extern char *output_block_move ();\n+extern char *output_scc_insn ();\n+extern char *output_cbranch ();\n+extern char *output_return ();\n+extern char *output_floatsisf2 ();\n+extern char *output_floatsidf2 ();\n+\n+/* Defined in flags.h, but insn-emit.c does not include flags.h.  */\n+\n+extern int flag_pic;"}]}