{"sha": "9e25c7ed961ca501496015a68fea46563c177684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUyNWM3ZWQ5NjFjYTUwMTQ5NjAxNWE2OGZlYTQ2NTYzYzE3NzY4NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-02-28T14:14:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-02-28T14:14:12Z"}, "message": "c-ada-spec.c (dump_ada_double_name): New case.\n\n\t* c-ada-spec.c (dump_ada_double_name) <ENUMERAL_TYPE>: New case.\n\t(is_char_array): Take a type instead of a declaration.\n\t(dump_ada_array_type): Likewise.\n\t(is_simple_enum): Minor tweak.\n\t(dump_ada_enum_type): New function extracted from...\n\t(dump_ada_node) <ENUMERAL_TYPE>: ...here.  Invoke it.\n\t<INTEGER_TYPE>: Remove unreachable code.\n\t<RECORD_TYPE>: Likewise.  Minor tweaks.\n\t(dump_nested_type) <ARRAY_TYPE>: Adjust to above changes.\n\t<ENUMERAL_TYPE>: New case.\n\t<RECORD_TYPE>: Factor out common code.\n\t(dump_ada_declaration) <ARRAY_TYPE>: Adjust to above changes.\n\tMinor tweaks.  Deal with enumeral types.\n\t(dump_ada_structure): Minor tweaks.\n\nFrom-SVN: r258067", "tree": {"sha": "76cb9c639ac8d17db0c899e6499d15dd91702c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76cb9c639ac8d17db0c899e6499d15dd91702c4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e25c7ed961ca501496015a68fea46563c177684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e25c7ed961ca501496015a68fea46563c177684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e25c7ed961ca501496015a68fea46563c177684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e25c7ed961ca501496015a68fea46563c177684/comments", "author": null, "committer": null, "parents": [{"sha": "09de35509f92de3a11a1ca879b958c0f73e28b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09de35509f92de3a11a1ca879b958c0f73e28b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09de35509f92de3a11a1ca879b958c0f73e28b88"}], "stats": {"total": 451, "additions": 250, "deletions": 201}, "files": [{"sha": "7730c65fc4862915983cce0c0c5a5da37e4d6df5", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9e25c7ed961ca501496015a68fea46563c177684", "patch": "@@ -1,3 +1,20 @@\n+2018-02-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (dump_ada_double_name) <ENUMERAL_TYPE>: New case.\n+\t(is_char_array): Take a type instead of a declaration.\n+\t(dump_ada_array_type): Likewise.\n+\t(is_simple_enum): Minor tweak.\n+\t(dump_ada_enum_type): New function extracted from...\n+\t(dump_ada_node) <ENUMERAL_TYPE>: ...here.  Invoke it.\n+\t<INTEGER_TYPE>: Remove unreachable code.\n+\t<RECORD_TYPE>: Likewise.  Minor tweaks.\n+\t(dump_nested_type) <ARRAY_TYPE>: Adjust to above changes.\n+\t<ENUMERAL_TYPE>: New case.\n+\t<RECORD_TYPE>: Factor out common code.\n+\t(dump_ada_declaration) <ARRAY_TYPE>: Adjust to above changes.\n+\tMinor tweaks.  Deal with enumeral types.\n+\t(dump_ada_structure): Minor tweaks.\n+\n 2018-02-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (dump_ada_node) <POINTER_TYPE>: Do not use generic"}, {"sha": "254c79db5b772d97d827b9852d85c6e87fa8363a", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 200, "deletions": 201, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=9e25c7ed961ca501496015a68fea46563c177684", "patch": "@@ -1511,9 +1511,9 @@ compute_overloading_index (tree decl)\n   return index;\n }\n \n-/* Dump in BUFFER the name of a DECL node if set, following Ada syntax.\n-   LIMITED_ACCESS indicates whether NODE can be accessed via a limited\n-   'with' clause rather than a regular 'with' clause.  */\n+/* Dump in BUFFER the name of a DECL node if set, in Ada syntax.\n+   LIMITED_ACCESS indicates whether NODE can be accessed via a\n+   limited 'with' clause rather than a regular 'with' clause.  */\n \n static void\n dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n@@ -1571,6 +1571,9 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n     case ARRAY_TYPE:\n       pp_string (buffer, \"_array\");\n       break;\n+    case ENUMERAL_TYPE:\n+      pp_string (buffer, \"_enum\");\n+      break;\n     case RECORD_TYPE:\n       pp_string (buffer, \"_struct\");\n       break;\n@@ -1639,7 +1642,7 @@ check_name (pretty_printer *buffer, tree t)\n     }\n }\n \n-/* Dump in BUFFER a function declaration FUNC with Ada syntax.\n+/* Dump in BUFFER a function declaration FUNC in Ada syntax.\n    IS_METHOD indicates whether FUNC is a C++ method.\n    IS_CONSTRUCTOR whether FUNC is a C++ constructor.\n    IS_DESTRUCTOR whether FUNC is a C++ destructor.\n@@ -1777,7 +1780,7 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n }\n \n /* Dump in BUFFER all the domains associated with an array NODE,\n-   using Ada syntax.  SPC is the current indentation level.  */\n+   in Ada syntax.  SPC is the current indentation level.  */\n \n static void\n dump_ada_array_domains (pretty_printer *buffer, tree node, int spc)\n@@ -1837,66 +1840,58 @@ dump_sloc (pretty_printer *buffer, tree node)\n     }\n }\n \n-/* Return true if T designates a one dimension array of \"char\".  */\n+/* Return true if type T designates a 1-dimension array of \"char\".  */\n \n static bool\n is_char_array (tree t)\n {\n-  tree tmp;\n   int num_dim = 0;\n \n-  /* Retrieve array's type.  */\n-  tmp = t;\n-  while (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)\n+  while (TREE_CODE (t) == ARRAY_TYPE)\n     {\n       num_dim++;\n-      tmp = TREE_TYPE (tmp);\n+      t = TREE_TYPE (t);\n     }\n \n-  tmp = TREE_TYPE (tmp);\n   return num_dim == 1\n-\t && TREE_CODE (tmp) == INTEGER_TYPE\n-\t && id_equal (DECL_NAME (TYPE_NAME (tmp)), \"char\");\n+\t && TREE_CODE (t) == INTEGER_TYPE\n+\t && id_equal (DECL_NAME (TYPE_NAME (t)), \"char\");\n }\n \n-/* Dump in BUFFER an array type T in Ada syntax.  Assume that the \"type\"\n-   keyword and name have already been printed.  PARENT is the parent node of T.\n-   SPC is the indentation level.  */\n+/* Dump in BUFFER an array type NODE of type TYPE in Ada syntax.  SPC is the\n+   indentation level.  */\n \n static void\n-dump_ada_array_type (pretty_printer *buffer, tree t, tree parent, int spc)\n+dump_ada_array_type (pretty_printer *buffer, tree node, tree type, int spc)\n {\n-  const bool char_array = is_char_array (t);\n-  tree tmp;\n+  const bool char_array = is_char_array (node);\n \n   /* Special case char arrays.  */\n   if (char_array)\n-    {\n-      pp_string (buffer, \"Interfaces.C.char_array \");\n-    }\n+    pp_string (buffer, \"Interfaces.C.char_array \");\n   else\n     pp_string (buffer, \"array \");\n \n   /* Print the dimensions.  */\n-  dump_ada_array_domains (buffer, TREE_TYPE (t), spc);\n-\n-  /* Retrieve the element type.  */\n-  tmp = TREE_TYPE (t);\n-  while (TREE_CODE (tmp) == ARRAY_TYPE)\n-    tmp = TREE_TYPE (tmp);\n+  dump_ada_array_domains (buffer, node, spc);\n \n   /* Print array's type.  */\n   if (!char_array)\n     {\n+      /* Retrieve the element type.  */\n+      tree tmp = node;\n+      while (TREE_CODE (tmp) == ARRAY_TYPE)\n+\ttmp = TREE_TYPE (tmp);\n+\n       pp_string (buffer, \" of \");\n \n       if (TREE_CODE (tmp) != POINTER_TYPE)\n \tpp_string (buffer, \"aliased \");\n \n       if (TYPE_NAME (tmp) || !RECORD_OR_UNION_TYPE_P (tmp))\n-\tdump_ada_node (buffer, tmp, TREE_TYPE (t), spc, false, true);\n+\tdump_ada_node (buffer, tmp, node, spc, false, true);\n       else\n-\tdump_ada_double_name (buffer, parent, get_underlying_decl (tmp));\n+\tdump_ada_double_name (buffer, type, get_underlying_decl (tmp));\n     }\n }\n \n@@ -2008,9 +2003,8 @@ static bool\n is_simple_enum (tree node)\n {\n   HOST_WIDE_INT count = 0;\n-  tree value;\n \n-  for (value = TYPE_VALUES (node); value; value = TREE_CHAIN (value))\n+  for (tree value = TYPE_VALUES (node); value; value = TREE_CHAIN (value))\n     {\n       tree int_val = TREE_VALUE (value);\n \n@@ -2028,6 +2022,73 @@ is_simple_enum (tree node)\n   return true;\n }\n \n+/* Dump in BUFFER an enumeral type NODE of type TYPE in Ada syntax.  SPC is\n+   the indentation level.  If DISPLAY_CONVENTION is true, also print the\n+   pragma Convention for NODE.  */\n+\n+static void\n+dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, int spc,\n+\t\t    bool display_convention)\n+{\n+  if (is_simple_enum (node))\n+    {\n+      bool first = true;\n+      spc += INDENT_INCR;\n+      newline_and_indent (buffer, spc - 1);\n+      pp_left_paren (buffer);\n+      for (tree value = TYPE_VALUES (node); value; value = TREE_CHAIN (value))\n+\t{\n+\t  if (first)\n+\t    first = false;\n+\t  else\n+\t    {\n+\t      pp_comma (buffer);\n+\t      newline_and_indent (buffer, spc);\n+\t    }\n+\n+\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, 0, false);\n+\t}\n+      pp_string (buffer, \");\");\n+      spc -= INDENT_INCR;\n+      newline_and_indent (buffer, spc);\n+\n+      if (display_convention)\n+\t{\n+\t  pp_string (buffer, \"pragma Convention (C, \");\n+\t  dump_ada_node (buffer, DECL_NAME (type) ? type : TYPE_NAME (node),\n+\t\t     type, spc, false, true);\n+\t  pp_right_paren (buffer);\n+\t}\n+    }\n+  else\n+    {\n+      if (TYPE_UNSIGNED (node))\n+\tpp_string (buffer, \"unsigned\");\n+      else\n+\tpp_string (buffer, \"int\");\n+      for (tree value = TYPE_VALUES (node); value; value = TREE_CHAIN (value))\n+\t{\n+\t  pp_semicolon (buffer);\n+\t  newline_and_indent (buffer, spc);\n+\n+\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, 0, false);\n+\t  pp_string (buffer, \" : constant \");\n+\n+\t  if (TYPE_UNSIGNED (node))\n+\t    pp_string (buffer, \"unsigned\");\n+\t  else\n+\t    pp_string (buffer, \"int\");\n+\n+\t  pp_string (buffer, \" := \");\n+\t  dump_ada_node (buffer,\n+\t\t\t TREE_CODE (TREE_VALUE (value)) == INTEGER_CST\n+\t\t\t ? TREE_VALUE (value)\n+\t\t\t : DECL_INITIAL (TREE_VALUE (value)),\n+\t\t\t node, spc, false, true);\n+\t}\n+    }\n+}\n+\n static bool bitfield_used = false;\n \n /* Recursively dump in BUFFER Ada declarations corresponding to NODE of type\n@@ -2087,117 +2148,42 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (name_only)\n \tdump_ada_node (buffer, TYPE_NAME (node), node, spc, false, true);\n       else\n-\t{\n-\t  tree value = TYPE_VALUES (node);\n-\n-\t  if (is_simple_enum (node))\n-\t    {\n-\t      bool first = true;\n-\t      spc += INDENT_INCR;\n-\t      newline_and_indent (buffer, spc - 1);\n-\t      pp_left_paren (buffer);\n-\t      for (; value; value = TREE_CHAIN (value))\n-\t\t{\n-\t\t  if (first)\n-\t\t    first = false;\n-\t\t  else\n-\t\t    {\n-\t\t      pp_comma (buffer);\n-\t\t      newline_and_indent (buffer, spc);\n-\t\t    }\n-\n-\t\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node,\n-\t\t\t\t\t  0, false);\n-\t\t}\n-\t      pp_string (buffer, \");\");\n-\t      spc -= INDENT_INCR;\n-\t      newline_and_indent (buffer, spc);\n-\t      pp_string (buffer, \"pragma Convention (C, \");\n-\t      dump_ada_node (buffer,\n-\t\t\t     DECL_NAME (type) ? type : TYPE_NAME (node),\n-\t\t\t     type, spc, false, true);\n-\t      pp_right_paren (buffer);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TYPE_UNSIGNED (node))\n-\t\tpp_string (buffer, \"unsigned\");\n-\t      else\n-\t\tpp_string (buffer, \"int\");\n-\t      for (; value; value = TREE_CHAIN (value))\n-\t\t{\n-\t\t  pp_semicolon (buffer);\n-\t\t  newline_and_indent (buffer, spc);\n-\n-\t\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node,\n-\t\t\t\t\t  0, false);\n-\t\t  pp_string (buffer, \" : constant \");\n-\n-\t\t  dump_ada_node (buffer,\n-\t\t\t\t DECL_NAME (type) ? type : TYPE_NAME (node),\n-\t\t\t\t type, spc, false, true);\n-\n-\t\t  pp_string (buffer, \" := \");\n-\t\t  dump_ada_node (buffer,\n-\t\t\t\t TREE_CODE (TREE_VALUE (value)) == INTEGER_CST\n-\t\t\t\t ? TREE_VALUE (value)\n-\t\t\t\t : DECL_INITIAL (TREE_VALUE (value)),\n-\t\t\t\t node, spc, false, true);\n-\t\t}\n-\t    }\n-\t}\n+\tdump_ada_enum_type (buffer, node, type, spc, true);\n       break;\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n     case FIXED_POINT_TYPE:\n     case BOOLEAN_TYPE:\n-      {\n-\tenum tree_code_class tclass;\n-\n-\ttclass = TREE_CODE_CLASS (TREE_CODE (node));\n-\n-\tif (tclass == tcc_declaration)\n-\t  {\n-\t    if (DECL_NAME (node))\n-\t      pp_ada_tree_identifier (buffer, DECL_NAME (node), NULL_TREE, 0,\n-\t\t\t\t      limited_access);\n-\t    else\n-\t      pp_string (buffer, \"<unnamed type decl>\");\n-\t  }\n-\telse if (tclass == tcc_type)\n-\t  {\n-\t    if (TYPE_NAME (node))\n-\t      {\n-\t\tif (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n-\t\t  pp_ada_tree_identifier (buffer, TYPE_NAME (node), node, 0,\n-\t\t\t\t\t  limited_access);\n-\t\telse if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n-\t\t\t && DECL_NAME (TYPE_NAME (node)))\n-\t\t  dump_ada_decl_name (buffer, TYPE_NAME (node), limited_access);\n-\t\telse\n-\t\t  pp_string (buffer, \"<unnamed type>\");\n-\t      }\n-\t    else if (TREE_CODE (node) == INTEGER_TYPE)\n-\t      {\n-\t\tappend_withs (\"Interfaces.C.Extensions\", false);\n-\t\tbitfield_used = true;\n+      if (TYPE_NAME (node))\n+\t{\n+\t  if (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n+\t    pp_ada_tree_identifier (buffer, TYPE_NAME (node), node, 0,\n+\t\t\t\t    limited_access);\n+\t  else if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n+\t\t   && DECL_NAME (TYPE_NAME (node)))\n+\t    dump_ada_decl_name (buffer, TYPE_NAME (node), limited_access);\n+\t  else\n+\t    pp_string (buffer, \"<unnamed type>\");\n+\t}\n+      else if (TREE_CODE (node) == INTEGER_TYPE)\n+\t{\n+\t  append_withs (\"Interfaces.C.Extensions\", false);\n+\t  bitfield_used = true;\n \n-\t\tif (TYPE_PRECISION (node) == 1)\n-\t\t  pp_string (buffer, \"Extensions.Unsigned_1\");\n-\t\telse\n-\t\t  {\n-\t\t    pp_string (buffer, (TYPE_UNSIGNED (node)\n-\t\t\t\t\t? \"Extensions.Unsigned_\"\n-\t\t\t\t\t: \"Extensions.Signed_\"));\n-\t\t    pp_decimal_int (buffer, TYPE_PRECISION (node));\n-\t\t  }\n-\t      }\n-\t    else\n-\t      pp_string (buffer, \"<unnamed type>\");\n-\t  }\n-\tbreak;\n-      }\n+\t  if (TYPE_PRECISION (node) == 1)\n+\t    pp_string (buffer, \"Extensions.Unsigned_1\");\n+\t  else\n+\t    {\n+\t      pp_string (buffer, TYPE_UNSIGNED (node)\n+\t\t\t\t ? \"Extensions.Unsigned_\"\n+\t\t\t\t : \"Extensions.Signed_\");\n+\t      pp_decimal_int (buffer, TYPE_PRECISION (node));\n+\t    }\n+\t}\n+      else\n+\tpp_string (buffer, \"<unnamed type>\");\n+      break;\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -2212,8 +2198,8 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t  else\n \t    pp_string (buffer, \"access function\");\n \n-\t  dump_ada_function_declaration\n-\t    (buffer, node, false, false, false, spc + INDENT_INCR);\n+\t  dump_ada_function_declaration (buffer, node, false, false, false,\n+\t\t\t\t\t spc + INDENT_INCR);\n \n \t  /* If we are dumping the full type, it means we are part of a\n \t     type definition and need also a Convention C pragma.  */\n@@ -2335,16 +2321,8 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n     case RECORD_TYPE:\n     case UNION_TYPE:\n       if (name_only)\n-\t{\n-\t  if (TYPE_NAME (node))\n-\t    dump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n-\t\t\t   true);\n-\t  else\n-\t    {\n-\t      pp_string (buffer, \"anon_\");\n-\t      pp_scalar (buffer, \"%d\", TYPE_UID (node));\n-\t    }\n-\t}\n+\tdump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n+\t\t       true);\n       else\n \tdump_ada_structure (buffer, node, type, spc, true);\n       break;\n@@ -2410,7 +2388,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t{\n \t  if (is_tagged_type (TREE_TYPE (node)))\n \t    {\n-\t      int first = 1;\n+\t      int first = true;\n \n \t      /* Look for ancestors.  */\n \t      for (tree fld = TYPE_FIELDS (TREE_TYPE (node));\n@@ -2422,7 +2400,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t      if (first)\n \t\t\t{\n \t\t\t  pp_string (buffer, \"limited new \");\n-\t\t\t  first = 0;\n+\t\t\t  first = false;\n \t\t\t}\n \t\t      else\n \t\t\tpp_string (buffer, \" and \");\n@@ -2594,63 +2572,83 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \tdump_forward_type (buffer, TREE_TYPE (tmp), t, spc);\n \n       /* Special case char arrays.  */\n-      if (is_char_array (field))\n-\tpp_string (buffer, \"sub\");\n+      if (is_char_array (field_type))\n+\tpp_string (buffer, \"subtype \");\n+      else\n+\tpp_string (buffer, \"type \");\n \n-      pp_string (buffer, \"type \");\n       dump_ada_double_name (buffer, parent, field);\n       pp_string (buffer, \" is \");\n-      dump_ada_array_type (buffer, field, parent, spc);\n+      dump_ada_array_type (buffer, field_type, parent, spc);\n       pp_semicolon (buffer);\n       newline_and_indent (buffer, spc);\n       break;\n \n+    case ENUMERAL_TYPE:\n+      if (is_simple_enum (field_type))\n+\tpp_string (buffer, \"type \");\n+      else\n+\tpp_string (buffer, \"subtype \");\n+\n+      if (TYPE_NAME (field_type))\n+\tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n+      else\n+\tdump_ada_double_name (buffer, parent, field);\n+      pp_string (buffer, \" is \");\n+      dump_ada_enum_type (buffer, field_type, t, spc, false);\n+\n+      if (is_simple_enum (field_type))\n+\t{\n+\t  pp_string (buffer, \"pragma Convention (C, \");\n+\t  if (TYPE_NAME (field_type))\n+\t    dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n+\t  else\n+\t    dump_ada_double_name (buffer, parent, field);\n+\t  pp_string (buffer, \");\");\n+\t  newline_and_indent (buffer, spc);\n+\t}\n+      else\n+\t{\n+\t  pp_semicolon (buffer);\n+\t  newline_and_indent (buffer, spc);\n+\t}\n+      break;\n+\n     case RECORD_TYPE:\n     case UNION_TYPE:\n       dump_nested_types (buffer, field, t, spc);\n \n       pp_string (buffer, \"type \");\n \n       if (TYPE_NAME (field_type))\n-\t{\n-\t  dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n-\t  if (TREE_CODE (field_type) == UNION_TYPE)\n-\t    pp_string (buffer, \" (discr : unsigned := 0)\");\n-\t  pp_string (buffer, \" is \");\n-\t  dump_ada_structure (buffer, field_type, t, spc, false);\n+\tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n+      else\n+\tdump_ada_double_name (buffer, parent, field);\n \n-\t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t  dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n-\t  pp_string (buffer, \");\");\n-\t  newline_and_indent (buffer, spc);\n+      if (TREE_CODE (field_type) == UNION_TYPE)\n+\tpp_string (buffer, \" (discr : unsigned := 0)\");\n \n-\t  if (TREE_CODE (field_type) == UNION_TYPE)\n-\t    {\n-\t      pp_string (buffer, \"pragma Unchecked_Union (\");\n-\t      dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n-\t      pp_string (buffer, \");\");\n-\t    }\n-\t}\n+      pp_string (buffer, \" is \");\n+      dump_ada_structure (buffer, field_type, t, spc, false);\n+\n+      pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n+      if (TYPE_NAME (field_type))\n+\tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n       else\n-\t{\n-\t  dump_ada_double_name (buffer, parent, field);\n-\t  if (TREE_CODE (field_type) == UNION_TYPE)\n-\t    pp_string (buffer, \" (discr : unsigned := 0)\");\n-\t  pp_string (buffer, \" is \");\n-\t  dump_ada_structure (buffer, field_type, t, spc, false);\n+\tdump_ada_double_name (buffer, parent, field);\n+      pp_string (buffer, \");\");\n+      newline_and_indent (buffer, spc);\n \n-\t  pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-\t  dump_ada_double_name (buffer, parent, field);\n+      if (TREE_CODE (field_type) == UNION_TYPE)\n+\t{\n+\t  pp_string (buffer, \"pragma Unchecked_Union (\");\n+\t  if (TYPE_NAME (field_type))\n+\t    dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n+\t  else\n+\t    dump_ada_double_name (buffer, parent, field);\n \t  pp_string (buffer, \");\");\n-\t  newline_and_indent (buffer, spc);\n-\n-\t  if (TREE_CODE (field_type) == UNION_TYPE)\n-\t    {\n-\t      pp_string (buffer, \"pragma Unchecked_Union (\");\n-\t      dump_ada_double_name (buffer, parent, field);\n-\t      pp_string (buffer, \");\");\n-\t    }\n \t}\n+      break;\n \n     default:\n       break;\n@@ -2815,7 +2813,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t    /* fallthrough */\n \n \t  case ARRAY_TYPE:\n-\t    if ((orig && TYPE_NAME (orig)) || is_char_array (t))\n+\t    if ((orig && TYPE_NAME (orig)) || is_char_array (TREE_TYPE (t)))\n \t      pp_string (buffer, \"subtype \");\n \t    else\n \t      pp_string (buffer, \"type \");\n@@ -2865,7 +2863,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  if (orig && TYPE_NAME (orig))\n \t    dump_ada_node (buffer, TYPE_NAME (orig), type, spc, false, true);\n \t  else\n-\t    dump_ada_array_type (buffer, t, type, spc);\n+\t    dump_ada_array_type (buffer, TREE_TYPE (t), type, spc);\n \t}\n       else\n \t{\n@@ -2884,7 +2882,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  else if (type)\n \t    dump_ada_double_name (buffer, type, t);\n \t  else\n-\t    dump_ada_array_type (buffer, t, type, spc);\n+\t    dump_ada_array_type (buffer, TREE_TYPE (t), type, spc);\n \t}\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n@@ -3092,9 +3090,12 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t  pp_string (buffer, \" : \");\n \n-\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t)))\n+\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n+\t      || TREE_CODE (TREE_TYPE (t)) == ENUMERAL_TYPE)\n \t    {\n-\t      pp_string (buffer, \"aliased \");\n+\t      if (TYPE_NAME (TREE_TYPE (t))\n+\t\t  || TREE_CODE (TREE_TYPE (t)) != ENUMERAL_TYPE)\n+\t\tpp_string (buffer, \"aliased \");\n \n \t      if (TREE_READONLY (t) && TREE_CODE (t) != FIELD_DECL)\n \t\tpp_string (buffer, \"constant \");\n@@ -3114,8 +3115,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t      if (TREE_READONLY (t) && TREE_CODE (t) != FIELD_DECL)\n \t\tpp_string (buffer, \"constant \");\n \n-\t      dump_ada_node (buffer, TREE_TYPE (t), TREE_TYPE (t), spc, false,\n-\t\t\t     true);\n+\t      dump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \t    }\n \t}\n     }\n@@ -3150,14 +3150,13 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n }\n \n /* Dump in BUFFER a structure NODE of type TYPE: name, fields, and methods\n-   with Ada syntax.  SPC is the indentation level.  If DISPLAY_CONVENTION is\n+   in Ada syntax.  SPC is the indentation level.  If DISPLAY_CONVENTION is\n    true, also print the pragma Convention for NODE.  */\n \n static void\n dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t    bool display_convention)\n {\n-  tree tmp;\n   const bool is_union = (TREE_CODE (node) == UNION_TYPE);\n   char buf[32];\n   int field_num = 0;\n@@ -3179,7 +3178,7 @@ dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n   pp_newline (buffer);\n \n   /* Print the non-static fields of the structure.  */\n-  for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n+  for (tree tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n     {\n       /* Add parent field if needed.  */\n       if (!DECL_NAME (tmp))\n@@ -3199,8 +3198,8 @@ dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t      sprintf (buf, \"field_%d : aliased \", field_num + 1);\n \t\t      pp_string (buffer, buf);\n \t\t    }\n-\t\t  dump_ada_decl_name\n-\t\t    (buffer, TYPE_NAME (TREE_TYPE (tmp)), false);\n+\t\t  dump_ada_decl_name (buffer, TYPE_NAME (TREE_TYPE (tmp)),\n+\t\t\t\t      false);\n \t\t  pp_semicolon (buffer);\n \t\t}\n \n@@ -3296,7 +3295,7 @@ dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n   need_semicolon = !dump_ada_methods (buffer, node, spc);\n \n   /* Print the static fields of the structure, if any.  */\n-  for (tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n+  for (tree tmp = TYPE_FIELDS (node); tmp; tmp = TREE_CHAIN (tmp))\n     {\n       if (TREE_CODE (tmp) == VAR_DECL && DECL_NAME (tmp))\n \t{"}, {"sha": "8e963816087bded93500432da5f82948a3ba7f87", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e25c7ed961ca501496015a68fea46563c177684", "patch": "@@ -1,3 +1,8 @@\n+2018-02-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-c++-common/dump-ada-spec-12.c: New test.\n+\t* c-c++-common/dump-ada-spec-13.c: Likewise.\n+\n 2018-02-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-c++-common/dump-ada-spec-11.c: New test."}, {"sha": "8e6edc05fbdf9ef86b7f74f506c9fe7247fb4a07", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-12.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-12.c?ref=9e25c7ed961ca501496015a68fea46563c177684", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec\" } */\n+\n+struct S1\n+{\n+  enum { Blue, Red, Green } E;\n+};\n+\n+struct S2\n+{\n+  enum { One = 1, Two, Three } E;\n+};\n+\n+/* { dg-final { cleanup-ada-spec } } */"}, {"sha": "c5f60f0ce46b4ecbad594cd6f7a3c7dea27ab127", "filename": "gcc/testsuite/c-c++-common/dump-ada-spec-13.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e25c7ed961ca501496015a68fea46563c177684/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdump-ada-spec-13.c?ref=9e25c7ed961ca501496015a68fea46563c177684", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec\" } */\n+\n+struct S1\n+{\n+  enum T1 { Blue, Red, Green } E;\n+};\n+\n+struct S2\n+{\n+  enum T2 { One = 1, Two, Three } E;\n+};\n+\n+/* { dg-final { cleanup-ada-spec } } */"}]}