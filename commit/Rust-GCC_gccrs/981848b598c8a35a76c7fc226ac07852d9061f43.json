{"sha": "981848b598c8a35a76c7fc226ac07852d9061f43", "node_id": "C_kwDOANBUbNoAKDk4MTg0OGI1OThjOGEzNWE3NmM3ZmMyMjZhYzA3ODUyZDkwNjFmNDM", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2022-10-13T20:51:08Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-07T08:36:33Z"}, "message": "ada: Suppress warnings on derived True/False\n\nGNAT normally warns on \"return ...;\" if the \"...\" is known to be True or\nFalse, but not when it is a Boolean literal True or False. This patch\nalso suppresses the warning when the type is derived from Boolean, and\nhas convention C or Fortran (and therefore True is represented as\n\"nonzero\").\n\nWithout this fix, GNAT would give warnings like \"False is always False\".\n\ngcc/ada/\n\n\t* sem_warn.adb\n\t(Check_For_Warnings): Remove unnecessary exception handler.\n\t(Warn_On_Known_Condition): Suppress warning when we detect a True\n\tor False that has been turned into a more complex expression\n\tbecause True is represented as \"nonzero\". (Note that the complex\n\texpression will subsequently be constant-folded to a Boolean True\n\tor False). Also simplify to always print \"condition is always ...\"\n\tinstead of special-casing object names. The special case was\n\tunhelpful, and indeed wrong when the expression is a literal.", "tree": {"sha": "38beba3b6c053dd4791a3d9c306fe6a7073d62d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38beba3b6c053dd4791a3d9c306fe6a7073d62d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/981848b598c8a35a76c7fc226ac07852d9061f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981848b598c8a35a76c7fc226ac07852d9061f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981848b598c8a35a76c7fc226ac07852d9061f43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981848b598c8a35a76c7fc226ac07852d9061f43/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214b1cb8a829568c7ef675b7c3e6a2d8b9a96875"}], "stats": {"total": 119, "additions": 49, "deletions": 70}, "files": [{"sha": "0a46c66ae80e7d89595bb3fe30e15beda84c35f6", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981848b598c8a35a76c7fc226ac07852d9061f43/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981848b598c8a35a76c7fc226ac07852d9061f43/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=981848b598c8a35a76c7fc226ac07852d9061f43", "patch": "@@ -2948,21 +2948,6 @@ package body Sem_Warn is\n \n    begin\n       return Traverse (N) = Abandon;\n-\n-   --  If any exception occurs, then something has gone wrong, and this is\n-   --  only a minor aesthetic issue anyway, so just say we did not find what\n-   --  we are looking for, rather than blow up.\n-\n-   exception\n-      when others =>\n-         --  With debug flag K we will get an exception unless an error has\n-         --  already occurred (useful for debugging).\n-\n-         if Debug_Flag_K then\n-            Check_Error_Detected;\n-         end if;\n-\n-         return False;\n    end Operand_Has_Warnings_Suppressed;\n \n    -----------------------------------------\n@@ -3379,11 +3364,10 @@ package body Sem_Warn is\n       --  determined, and Test_Result is set True/False accordingly. Otherwise\n       --  False is returned, and Test_Result is unchanged.\n \n-      procedure Track (N : Node_Id; Loc : Node_Id);\n+      procedure Track (N : Node_Id);\n       --  Adds continuation warning(s) pointing to reason (assignment or test)\n       --  for the operand of the conditional having a known value (or at least\n-      --  enough is known about the value to issue the warning). N is the node\n-      --  which is judged to have a known value. Loc is the warning location.\n+      --  enough is known about the value to issue the warning).\n \n       ---------------------\n       -- Is_Known_Branch --\n@@ -3417,36 +3401,45 @@ package body Sem_Warn is\n       -- Track --\n       -----------\n \n-      procedure Track (N : Node_Id; Loc : Node_Id) is\n-         Nod : constant Node_Id := Original_Node (N);\n+      procedure Track (N : Node_Id) is\n \n-      begin\n-         if Nkind (Nod) in N_Op_Compare then\n-            Track (Left_Opnd (Nod), Loc);\n-            Track (Right_Opnd (Nod), Loc);\n+         procedure Rec (Sub_N : Node_Id);\n+         --  Recursive helper to do the work of Track, so we can refer to N's\n+         --  Sloc in error messages. Sub_N is initially N, and a proper subnode\n+         --  when recursively walking comparison operations.\n \n-         elsif Is_Entity_Name (Nod) and then Is_Object (Entity (Nod)) then\n-            declare\n-               CV : constant Node_Id := Current_Value (Entity (Nod));\n+         procedure Rec (Sub_N : Node_Id) is\n+            Orig : constant Node_Id := Original_Node (Sub_N);\n+         begin\n+            if Nkind (Orig) in N_Op_Compare then\n+               Rec (Left_Opnd (Orig));\n+               Rec (Right_Opnd (Orig));\n \n-            begin\n-               if Present (CV) then\n-                  Error_Msg_Sloc := Sloc (CV);\n+            elsif Is_Entity_Name (Orig) and then Is_Object (Entity (Orig)) then\n+               declare\n+                  CV : constant Node_Id := Current_Value (Entity (Orig));\n+               begin\n+                  if Present (CV) then\n+                     Error_Msg_Sloc := Sloc (CV);\n \n-                  if Nkind (CV) not in N_Subexpr then\n-                     Error_Msg_N (\"\\\\??(see test #)\", Loc);\n+                     if Nkind (CV) not in N_Subexpr then\n+                        Error_Msg_N (\"\\\\??(see test #)\", N);\n \n-                  elsif Nkind (Parent (CV)) =\n-                          N_Case_Statement_Alternative\n-                  then\n-                     Error_Msg_N (\"\\\\??(see case alternative #)\", Loc);\n+                     elsif Nkind (Parent (CV)) =\n+                             N_Case_Statement_Alternative\n+                     then\n+                        Error_Msg_N (\"\\\\??(see case alternative #)\", N);\n \n-                  else\n-                     Error_Msg_N (\"\\\\??(see assignment #)\", Loc);\n+                     else\n+                        Error_Msg_N (\"\\\\??(see assignment #)\", N);\n+                     end if;\n                   end if;\n-               end if;\n-            end;\n-         end if;\n+               end;\n+            end if;\n+         end Rec;\n+\n+      begin\n+         Rec (N);\n       end Track;\n \n       --  Local variables\n@@ -3464,11 +3457,8 @@ package body Sem_Warn is\n         and then Is_Known_Branch\n       then\n          declare\n-            Atrue : Boolean;\n-\n+            Atrue : Boolean := Test_Result;\n          begin\n-            Atrue := Test_Result;\n-\n             if Present (Parent (C)) and then Nkind (Parent (C)) = N_Op_Not then\n                Atrue := not Atrue;\n             end if;\n@@ -3550,7 +3540,6 @@ package body Sem_Warn is\n             declare\n                True_Branch : Boolean := Test_Result;\n                Cond        : Node_Id := C;\n-\n             begin\n                if Present (Parent (C))\n                  and then Nkind (Parent (C)) = N_Op_Not\n@@ -3559,37 +3548,27 @@ package body Sem_Warn is\n                   Cond := Parent (C);\n                end if;\n \n-               --  Condition always True\n-\n-               if True_Branch then\n-                  if Is_Entity_Name (Original_Node (C))\n-                    and then Nkind (Cond) /= N_Op_Not\n-                  then\n-                     Error_Msg_NE\n-                       (\"object & is always True at this point?c?\",\n-                        Cond, Original_Node (C));\n-                     Track (Original_Node (C), Cond);\n+               --  Suppress warning if this is True/False of a derived boolean\n+               --  type with Nonzero_Is_True, which gets rewritten as Boolean\n+               --  True/False.\n \n-                  else\n-                     Error_Msg_N (\"condition is always True?c?\", Cond);\n-                     Track (Cond, Cond);\n-                  end if;\n+               if Is_Entity_Name (Original_Node (C))\n+                 and then Ekind (Entity (Original_Node (C)))\n+                                 = E_Enumeration_Literal\n+                 and then Nonzero_Is_True (Etype (Original_Node (C)))\n+               then\n+                  null;\n \n-               --  Condition always False\n+               --  Give warning for nontrivial always True/False case\n \n                else\n-                  if Is_Entity_Name (Original_Node (C))\n-                    and then Nkind (Cond) /= N_Op_Not\n-                  then\n-                     Error_Msg_NE\n-                       (\"object & is always False at this point?c?\",\n-                        Cond, Original_Node (C));\n-                     Track (Original_Node (C), Cond);\n-\n+                  if True_Branch then\n+                     Error_Msg_N (\"condition is always True?c?\", Cond);\n                   else\n                      Error_Msg_N (\"condition is always False?c?\", Cond);\n-                     Track (Cond, Cond);\n                   end if;\n+\n+                  Track (Cond);\n                end if;\n             end;\n          end if;"}]}