{"sha": "c89f2d24685de5663523d328814541165a0d97c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg5ZjJkMjQ2ODVkZTU2NjM1MjNkMzI4ODE0NTQxMTY1YTBkOTdjMw==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2018-01-15T11:32:24Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2018-01-15T11:32:24Z"}, "message": "Make optional conditionally trivially_{copy,move}_{constructible,assignable}\n\n* include/std/optional (_Optional_payload): Fix the comment in\nthe class head and turn into a primary and one specialization.\n(_Optional_payload::_M_engaged): Strike the NSDMI.\n(_Optional_payload<_Tp, false>::operator=(const _Optional_payload&)):\nNew.\n(_Optional_payload<_Tp, false>::operator=(_Optional_payload&&)):\nLikewise.\n(_Optional_payload<_Tp, false>::_M_get): Likewise.\n(_Optional_payload<_Tp, false>::_M_reset): Likewise.\n(_Optional_base_impl): Likewise.\n(_Optional_base): Turn into a primary and three specializations.\n(optional(nullopt)): Change the base init.\n* testsuite/20_util/optional/assignment/8.cc: New.\n* testsuite/20_util/optional/cons/trivial.cc: Likewise.\n* testsuite/20_util/optional/cons/value_neg.cc: Adjust.\n\nFrom-SVN: r256694", "tree": {"sha": "c070209d003e7d226cbc6a6f84721259e9368bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c070209d003e7d226cbc6a6f84721259e9368bc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c89f2d24685de5663523d328814541165a0d97c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89f2d24685de5663523d328814541165a0d97c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c89f2d24685de5663523d328814541165a0d97c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89f2d24685de5663523d328814541165a0d97c3/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1759d1167a0d747c9c8578034586ed5fcdb48219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1759d1167a0d747c9c8578034586ed5fcdb48219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1759d1167a0d747c9c8578034586ed5fcdb48219"}], "stats": {"total": 590, "additions": 455, "deletions": 135}, "files": [{"sha": "92d96c46fb74eba5df1e2254471a5a96c2e04d31", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c89f2d24685de5663523d328814541165a0d97c3", "patch": "@@ -1,3 +1,23 @@\n+2018-01-15  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tMake optional conditionally\n+\ttrivially_{copy,move}_{constructible,assignable}\n+\t* include/std/optional (_Optional_payload): Fix the comment in\n+\tthe class head and turn into a primary and one specialization.\n+\t(_Optional_payload::_M_engaged): Strike the NSDMI.\n+\t(_Optional_payload<_Tp, false>::operator=(const _Optional_payload&)):\n+\tNew.\n+\t(_Optional_payload<_Tp, false>::operator=(_Optional_payload&&)):\n+\tLikewise.\n+\t(_Optional_payload<_Tp, false>::_M_get): Likewise.\n+\t(_Optional_payload<_Tp, false>::_M_reset): Likewise.\n+\t(_Optional_base_impl): Likewise.\n+\t(_Optional_base): Turn into a primary and three specializations.\n+\t(optional(nullopt)): Change the base init.\n+\t* testsuite/20_util/optional/assignment/8.cc: New.\n+\t* testsuite/20_util/optional/cons/trivial.cc: Likewise.\n+\t* testsuite/20_util/optional/cons/value_neg.cc: Adjust.\n+\n 2018-01-15  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/80276"}, {"sha": "01fc06bb7248b8419504fd037666d036d785387c", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 284, "deletions": 132, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=c89f2d24685de5663523d328814541165a0d97c3", "patch": "@@ -100,15 +100,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Payload for constexpr optionals.\n   template <typename _Tp,\n-\t    bool /*_TrivialCopyMove*/ =\n-\t      is_trivially_copy_constructible<_Tp>::value\n-\t      && is_trivially_move_constructible<_Tp>::value,\n-\t    bool /*_ShouldProvideDestructor*/ =\n+\t    bool /*_HasTrivialDestructor*/ =\n \t      is_trivially_destructible<_Tp>::value>\n     struct _Optional_payload\n     {\n       constexpr _Optional_payload()\n-\t: _M_empty() {}\n+\t: _M_empty(), _M_engaged(false) {}\n \n       template<typename... _Args>\n       constexpr _Optional_payload(in_place_t, _Args&&... __args)\n@@ -131,7 +128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {}\n \n       constexpr _Optional_payload(__ctor_tag<void>)\n-\t: _M_empty()\n+\t: _M_empty(), _M_engaged(false)\n       {}\n \n       constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n@@ -161,12 +158,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n       };\n-      bool _M_engaged = false;\n+      bool _M_engaged;\n     };\n \n-  // Payload for non-constexpr optionals with non-trivial destructor.\n+  // Payload for optionals with non-trivial destructor.\n   template <typename _Tp>\n-    struct _Optional_payload<_Tp, false, false>\n+    struct _Optional_payload<_Tp, false>\n     {\n       constexpr _Optional_payload()\n \t: _M_empty() {}\n@@ -203,6 +200,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  this->_M_construct(std::move(__other._M_payload));\n       }\n \n+      _Optional_payload&\n+      operator=(const _Optional_payload& __other)\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(__other._M_get());\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      _Optional_payload&\n+      operator=(_Optional_payload&& __other)\n+      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n+\t\t      is_nothrow_move_assignable<_Tp>>())\n+      {\n+\tif (this->_M_engaged && __other._M_engaged)\n+\t  this->_M_get() = std::move(__other._M_get());\n+\telse\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(std::move(__other._M_get()));\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n       using _Stored_type = remove_const_t<_Tp>;\n       struct _Empty_byte { };\n       union {\n@@ -226,95 +255,87 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n             _Stored_type(std::forward<_Args>(__args)...);\n           this->_M_engaged = true;\n         }\n-    };\n \n-  // Payload for non-constexpr optionals with trivial destructor.\n-  template <typename _Tp>\n-    struct _Optional_payload<_Tp, false, true>\n-    {\n-      constexpr _Optional_payload()\n-\t: _M_empty() {}\n-\n-      template <typename... _Args>\n-      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n-\n-      template<typename _Up, typename... _Args>\n-      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n-\t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n-      constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-\t: _Optional_payload(__other)\n-      {}\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-\t: _Optional_payload(std::move(__other))\n-      {}\n-\n-      constexpr _Optional_payload(const _Optional_payload& __other)\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n       {\n-\tif (__other._M_engaged)\n-\t  this->_M_construct(__other._M_payload);\n+\treturn this->_M_payload;\n       }\n \n-      constexpr _Optional_payload(_Optional_payload&& __other)\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n       {\n-\tif (__other._M_engaged)\n-\t  this->_M_construct(std::move(__other._M_payload));\n+\treturn this->_M_payload;\n       }\n \n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset() noexcept\n+      {\n+\tif (this->_M_engaged)\n+\t  {\n+\t    this->_M_engaged = false;\n+\t    this->_M_payload.~_Stored_type();\n+\t  }\n+      }\n+    };\n+  \n+  template<typename _Tp, typename _Dp>\n+    class _Optional_base_impl\n+    {\n+    protected:\n       using _Stored_type = remove_const_t<_Tp>;\n-      struct _Empty_byte { };\n-      union {\n-          _Empty_byte _M_empty;\n-          _Stored_type _M_payload;\n-      };\n-      bool _M_engaged = false;\n-\n+      \n+      // The _M_construct operation has !_M_engaged as a precondition\n+      // while _M_destruct has _M_engaged as a precondition.\n       template<typename... _Args>\n-        void\n-        _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n-        {\n-          ::new ((void *) std::__addressof(this->_M_payload))\n-            _Stored_type(std::forward<_Args>(__args)...);\n-          this->_M_engaged = true;\n-        }\n-    };\n+      void\n+      _M_construct(_Args&&... __args)\n+\tnoexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+      {\n+\t::new\n+\t  (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))\n+\t  _Stored_type(std::forward<_Args>(__args)...);\n+\tstatic_cast<_Dp*>(this)->_M_payload._M_engaged = true;\n+      }\n+      \n+      void\n+      _M_destruct() noexcept\n+      {\n+\tstatic_cast<_Dp*>(this)->_M_payload._M_engaged = false;\n+\tstatic_cast<_Dp*>(this)->_M_payload._M_payload.~_Stored_type();\n+      }\n+      \n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset() noexcept\n+      {\n+\tif (static_cast<_Dp*>(this)->_M_payload._M_engaged)\n+\t  static_cast<_Dp*>(this)->_M_destruct();\n+      }\n+  };\n \n   /**\n-    * @brief Class template that holds the necessary state for @ref optional\n-    * and that has the responsibility for construction and the special members.\n+    * @brief Class template that takes care of copy/move constructors\n+    of optional\n     *\n     * Such a separate base class template is necessary in order to\n-    * conditionally enable the special members (e.g. copy/move constructors).\n-    * Note that this means that @ref _Optional_base implements the\n-    * functionality for copy and move assignment, but not for converting\n-    * assignment.\n-    *\n+    * conditionally make copy/move constructors trivial.\n     * @see optional, _Enable_special_members\n     */\n-  template<typename _Tp>\n+  template<typename _Tp,\n+\t   bool = is_trivially_copy_constructible_v<_Tp>,\n+\t   bool = is_trivially_move_constructible_v<_Tp>>\n     class _Optional_base\n+    // protected inheritance because optional needs to reach that base too\n+      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n     {\n-    private:\n-      // Remove const to avoid prohibition of reusing object storage for\n-      // const-qualified types in [3.8/9]. This is strictly internal\n-      // and even optional itself is oblivious to it.\n-      using _Stored_type = remove_const_t<_Tp>;\n-\n+      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n     public:\n \n       // Constructors for disengaged optionals.\n-      constexpr _Optional_base() noexcept\n-      { }\n-\n-      constexpr _Optional_base(nullopt_t) noexcept\n-      { }\n+      constexpr _Optional_base() = default;\n \n       // Constructors for engaged optionals.\n       template<typename... _Args,\n@@ -347,84 +368,216 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n       // Assignment operators.\n-      _Optional_base&\n-      operator=(const _Optional_base& __other)\n+      _Optional_base& operator=(const _Optional_base&) = default;\n+      _Optional_base& operator=(_Optional_base&&) = default;\n+\n+    protected:\n+\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_payload._M_engaged; }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n       {\n-        if (this->_M_payload._M_engaged && __other._M_payload._M_engaged)\n-          this->_M_get() = __other._M_get();\n-        else\n-\t  {\n-\t    if (__other._M_payload._M_engaged)\n-\t      this->_M_construct(__other._M_get());\n-\t    else\n-\t      this->_M_reset();\n-\t  }\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn this->_M_payload._M_payload;\n+      }\n \n-        return *this;\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n+      {\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn this->_M_payload._M_payload;\n       }\n \n-      _Optional_base&\n-      operator=(_Optional_base&& __other)\n-      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n-\t\t      is_nothrow_move_assignable<_Tp>>())\n+    private:\n+      _Optional_payload<_Tp> _M_payload;\n+    };\n+\n+  template<typename _Tp>\n+    class _Optional_base<_Tp, false, true>\n+      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    {\n+      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n+    public:\n+\n+      // Constructors for disengaged optionals.\n+      constexpr _Optional_base() = default;\n+\n+      // Constructors for engaged optionals.\n+      template<typename... _Args,\n+\t       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(in_place,\n+\t\t     std::forward<_Args>(__args)...) { }\n+\n+      template<typename _Up, typename... _Args,\n+               enable_if_t<is_constructible_v<_Tp,\n+\t\t\t\t\t      initializer_list<_Up>&,\n+\t\t\t\t\t      _Args&&...>, bool> = false>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(in_place,\n+\t\t     __il, std::forward<_Args>(__args)...)\n+        { }\n+\n+      // Copy and move constructors.\n+      constexpr _Optional_base(const _Optional_base& __other)\n+\t: _M_payload(__other._M_payload._M_engaged,\n+\t\t     __other._M_payload)\n+      { }\n+\n+      constexpr _Optional_base(_Optional_base&& __other) = default;\n+\n+      // Assignment operators.\n+      _Optional_base& operator=(const _Optional_base&) = default;\n+      _Optional_base& operator=(_Optional_base&&) = default;\n+\n+    protected:\n+\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_payload._M_engaged; }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n       {\n-\tif (this->_M_payload._M_engaged && __other._M_payload._M_engaged)\n-\t  this->_M_get() = std::move(__other._M_get());\n-\telse\n-\t  {\n-\t    if (__other._M_payload._M_engaged)\n-\t      this->_M_construct(std::move(__other._M_get()));\n-\t    else\n-\t      this->_M_reset();\n-\t  }\n-\treturn *this;\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn this->_M_payload._M_payload;\n+      }\n+\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n+      {\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn this->_M_payload._M_payload;\n       }\n-      // The following functionality is also needed by optional, hence the\n-      // protected accessibility.\n+\n+    private:\n+      _Optional_payload<_Tp> _M_payload;\n+    };\n+\n+  template<typename _Tp>\n+    class _Optional_base<_Tp, true, false>\n+      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    {\n+      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n+    public:\n+\n+      // Constructors for disengaged optionals.\n+      constexpr _Optional_base() = default;\n+\n+      // Constructors for engaged optionals.\n+      template<typename... _Args,\n+\t       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(in_place,\n+\t\t     std::forward<_Args>(__args)...) { }\n+\n+      template<typename _Up, typename... _Args,\n+               enable_if_t<is_constructible_v<_Tp,\n+\t\t\t\t\t      initializer_list<_Up>&,\n+\t\t\t\t\t      _Args&&...>, bool> = false>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(in_place,\n+\t\t     __il, std::forward<_Args>(__args)...)\n+        { }\n+\n+      // Copy and move constructors.\n+      constexpr _Optional_base(const _Optional_base& __other) = default;\n+\n+      constexpr _Optional_base(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>())\n+\t: _M_payload(__other._M_payload._M_engaged,\n+\t\t     std::move(__other._M_payload))\n+      { }\n+\n+      // Assignment operators.\n+      _Optional_base& operator=(const _Optional_base&) = default;\n+      _Optional_base& operator=(_Optional_base&&) = default;\n+\n     protected:\n+\n       constexpr bool _M_is_engaged() const noexcept\n       { return this->_M_payload._M_engaged; }\n \n       // The _M_get operations have _M_engaged as a precondition.\n       constexpr _Tp&\n-      _M_get() noexcept\n+\t_M_get() noexcept\n       {\n-\t__glibcxx_assert(_M_is_engaged());\n+\t__glibcxx_assert(this->_M_is_engaged());\n \treturn this->_M_payload._M_payload;\n       }\n \n       constexpr const _Tp&\n-      _M_get() const noexcept\n+\t_M_get() const noexcept\n       {\n-\t__glibcxx_assert(_M_is_engaged());\n+\t__glibcxx_assert(this->_M_is_engaged());\n \treturn this->_M_payload._M_payload;\n       }\n \n-      // The _M_construct operation has !_M_engaged as a precondition\n-      // while _M_destruct has _M_engaged as a precondition.\n-      template<typename... _Args>\n-        void\n-        _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n-        {\n-          ::new (std::__addressof(this->_M_payload._M_payload))\n-            _Stored_type(std::forward<_Args>(__args)...);\n-          this->_M_payload._M_engaged = true;\n-        }\n+    private:\n+      _Optional_payload<_Tp> _M_payload;\n+    };\n \n-      void\n-      _M_destruct()\n+  template<typename _Tp>\n+    class _Optional_base<_Tp, true, true>\n+      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    {\n+      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n+    public:\n+\n+      // Constructors for disengaged optionals.\n+      constexpr _Optional_base() = default;\n+\n+      // Constructors for engaged optionals.\n+      template<typename... _Args,\n+\t       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(in_place,\n+\t\t     std::forward<_Args>(__args)...) { }\n+\n+      template<typename _Up, typename... _Args,\n+               enable_if_t<is_constructible_v<_Tp,\n+\t\t\t\t\t      initializer_list<_Up>&,\n+\t\t\t\t\t      _Args&&...>, bool> = false>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(in_place,\n+\t\t     __il, std::forward<_Args>(__args)...)\n+        { }\n+\n+      // Copy and move constructors.\n+      constexpr _Optional_base(const _Optional_base& __other) = default;\n+      constexpr _Optional_base(_Optional_base&& __other) = default;\n+\n+      // Assignment operators.\n+      _Optional_base& operator=(const _Optional_base&) = default;\n+      _Optional_base& operator=(_Optional_base&&) = default;\n+\n+    protected:\n+\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_payload._M_engaged; }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n       {\n-        this->_M_payload._M_engaged = false;\n-        this->_M_payload._M_payload.~_Stored_type();\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn this->_M_payload._M_payload;\n       }\n \n-      // _M_reset is a 'safe' operation with no precondition.\n-      void\n-      _M_reset()\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n       {\n-        if (this->_M_payload._M_engaged)\n-          this->_M_destruct();\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn this->_M_payload._M_payload;\n       }\n \n     private:\n@@ -482,8 +635,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       constexpr optional() = default;\n \n-      constexpr optional(nullopt_t) noexcept\n-\t: _Base(nullopt) { }\n+      constexpr optional(nullopt_t) noexcept { }\n \n       // Converting constructors for engaged optionals.\n       template <typename _Up = _Tp,"}, {"sha": "d57313793c46773e80531115abe4bf76baebde84", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/8.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F8.cc?ref=c89f2d24685de5663523d328814541165a0d97c3", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct X\n+{\n+  ~X();\n+};\n+\n+struct Y\n+{\n+  Y& operator=(const Y&) = default;\n+  Y& operator=(Y&&);\n+  Y(const Y&) = default;\n+  Y(Y&&) = default;\n+};\n+\n+struct Z\n+{\n+  Z& operator=(const Z&);\n+  Z& operator=(Z&&) = default;\n+  Z(const Z&) = default;\n+};\n+\n+struct Y2\n+{\n+  Y2& operator=(const Y2&) = default;\n+  Y2& operator=(Y2&&);\n+};\n+\n+struct Z2\n+{\n+  Z2& operator=(const Z2&);\n+  Z2& operator=(Z2&&) = default;\n+};\n+\n+static_assert(std::is_trivially_copy_assignable_v<std::optional<int>>);\n+static_assert(std::is_trivially_move_assignable_v<std::optional<int>>);\n+static_assert(!std::is_trivially_copy_assignable_v<std::optional<X>>);\n+static_assert(!std::is_trivially_move_assignable_v<std::optional<X>>);\n+static_assert(std::is_trivially_copy_assignable_v<std::optional<Y>>);\n+static_assert(!std::is_trivially_move_assignable_v<std::optional<Y>>);\n+static_assert(!std::is_trivially_copy_assignable_v<std::optional<Z>>);\n+static_assert(std::is_trivially_move_assignable_v<std::optional<Z>>);\n+static_assert(std::is_trivially_copy_assignable_v<Y2>);\n+static_assert(!std::is_trivially_move_assignable_v<Y2>);\n+static_assert(!std::is_trivially_copy_assignable_v<std::optional<Y2>>);\n+static_assert(!std::is_trivially_move_assignable_v<std::optional<Y2>>);\n+static_assert(!std::is_trivially_copy_assignable_v<Z2>);\n+static_assert(std::is_trivially_move_assignable_v<Z2>);\n+static_assert(!std::is_trivially_copy_assignable_v<std::optional<Z2>>);\n+static_assert(!std::is_trivially_move_assignable_v<std::optional<Z2>>);\n+\n+\n+struct S {\n+  S(const S&&) = delete;\n+  S& operator=(const S&) = default;\n+};\n+static_assert(std::is_trivially_copy_assignable_v<S>);\n+\n+union U {\n+  char dummy;\n+  S s;\n+};\n+static_assert(std::is_trivially_copy_assignable_v<U>);\n+\n+static_assert(!std::is_trivially_copy_assignable_v<std::optional<S>>);\n+static_assert(!std::is_copy_assignable_v<std::optional<S>>);\n+\n+struct S2 {\n+  S2(S2&&) = delete;\n+  S2& operator=(const S2&) = default;\n+};\n+static_assert(std::is_trivially_move_assignable_v<S2>);\n+\n+union U2 {\n+  char dummy;\n+  S2 s;\n+};\n+static_assert(std::is_trivially_move_assignable_v<U2>);\n+\n+static_assert(!std::is_trivially_move_assignable_v<std::optional<S2>>);\n+static_assert(!std::is_move_assignable_v<std::optional<S2>>);"}, {"sha": "84a8e10154710862dcebfed7f2f644bab9ec159f", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/trivial.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Ftrivial.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Ftrivial.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Ftrivial.cc?ref=c89f2d24685de5663523d328814541165a0d97c3", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct X\n+{\n+  ~X();\n+};\n+\n+struct Y\n+{\n+  Y(const Y&) = default;\n+  Y(Y&&);\n+};\n+\n+struct Z\n+{\n+  Z(const Z&);\n+  Z(Z&&) = default;\n+};\n+\n+static_assert(std::is_trivially_copy_constructible_v<std::optional<int>>);\n+static_assert(std::is_trivially_move_constructible_v<std::optional<int>>);\n+static_assert(!std::is_trivially_copy_constructible_v<std::optional<X>>);\n+static_assert(!std::is_trivially_move_constructible_v<std::optional<X>>);\n+static_assert(std::is_trivially_copy_constructible_v<std::optional<Y>>);\n+static_assert(!std::is_trivially_move_constructible_v<std::optional<Y>>);\n+static_assert(!std::is_trivially_copy_constructible_v<std::optional<Z>>);\n+static_assert(std::is_trivially_move_constructible_v<std::optional<Z>>);"}, {"sha": "c448996994329dff1887dd83f141f1688653d91c", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c89f2d24685de5663523d328814541165a0d97c3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc?ref=c89f2d24685de5663523d328814541165a0d97c3", "patch": "@@ -37,8 +37,8 @@ int main()\n     std::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error \"conversion\" }\n     struct U { explicit U(std::in_place_t); };\n     std::optional<U> ou(std::in_place); // { dg-error \"no matching\" }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 495 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 505 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 562 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 647 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 657 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 714 }\n   }\n }"}]}