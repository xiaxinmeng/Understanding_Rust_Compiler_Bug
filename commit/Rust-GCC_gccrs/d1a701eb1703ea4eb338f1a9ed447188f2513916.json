{"sha": "d1a701eb1703ea4eb338f1a9ed447188f2513916", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFhNzAxZWIxNzAzZWE0ZWIzMzhmMWE5ZWQ0NDcxODhmMjUxMzkxNg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2006-02-15T12:19:49Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2006-02-15T12:19:49Z"}, "message": "re PR middle-end/22275 (bitfield layout change)\n\n        PR middle-end/22275\n\n        * stor-layout.c (layout_decl): Zero-width bitfields aren't\n        influenced by maximum_field_alignment or DECL_PACKED.\n        (update_alignment_for_field): Ditto.\n        (place_field): Ditto.\n        * doc/extend.texi (<#pragma pack>, <Type Attributes>): Document\n        this behaviour.\n\nFrom-SVN: r111109", "tree": {"sha": "253df9cb43aef0d0e3cdaa8b0fefeab54a75456e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/253df9cb43aef0d0e3cdaa8b0fefeab54a75456e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1a701eb1703ea4eb338f1a9ed447188f2513916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a701eb1703ea4eb338f1a9ed447188f2513916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1a701eb1703ea4eb338f1a9ed447188f2513916", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a701eb1703ea4eb338f1a9ed447188f2513916/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b98e315984edf44807d166f1ada5ee9a8eaec8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b98e315984edf44807d166f1ada5ee9a8eaec8db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b98e315984edf44807d166f1ada5ee9a8eaec8db"}], "stats": {"total": 68, "additions": 51, "deletions": 17}, "files": [{"sha": "2a287c0e90c3b1832fb1cd55bd2aa98a04365242", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a701eb1703ea4eb338f1a9ed447188f2513916/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a701eb1703ea4eb338f1a9ed447188f2513916/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1a701eb1703ea4eb338f1a9ed447188f2513916", "patch": "@@ -1,3 +1,14 @@\n+2006-02-15  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/22275\n+\n+\t* stor-layout.c (layout_decl): Zero-width bitfields aren't\n+\tinfluenced by maximum_field_alignment or DECL_PACKED.\n+\t(update_alignment_for_field): Ditto.\n+\t(place_field): Ditto.\n+\t* doc/extend.texi (<#pragma pack>, <Type Attributes>): Document\n+\tthis behaviour.\n+\n 2006-02-15  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* cfg.c (dump_flow_info): Get dump flags as an additional parameter."}, {"sha": "cf1545826b906af24cfe481e0243d057a843beb8", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a701eb1703ea4eb338f1a9ed447188f2513916/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a701eb1703ea4eb338f1a9ed447188f2513916/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d1a701eb1703ea4eb338f1a9ed447188f2513916", "patch": "@@ -3329,9 +3329,10 @@ alignment.  See your linker documentation for further information.\n \n @item packed\n This attribute, attached to @code{struct} or @code{union} type\n-definition, specifies that each member of the structure or union is\n-placed to minimize the memory required.  When attached to an @code{enum}\n-definition, it indicates that the smallest integral type should be used.\n+definition, specifies that each member (other than zero-width bitfields)\n+of the structure or union is placed to minimize the memory required.  When\n+attached to an @code{enum} definition, it indicates that the smallest\n+integral type should be used.\n \n @opindex fshort-enums\n Specifying this attribute for @code{struct} and @code{union} types is\n@@ -9518,10 +9519,10 @@ way of knowing that that happened.)\n @subsection Structure-Packing Pragmas\n \n For compatibility with Win32, GCC supports a set of @code{#pragma}\n-directives which change the maximum alignment of members of structures,\n-unions, and classes subsequently defined.  The @var{n} value below always\n-is required to be a small power of two and specifies the new alignment\n-in bytes.\n+directives which change the maximum alignment of members of structures\n+(other than zero-width bitfields), unions, and classes subsequently\n+defined.  The @var{n} value below always is required to be a small power\n+of two and specifies the new alignment in bytes.\n \n @enumerate\n @item @code{#pragma pack(@var{n})} simply sets the new alignment."}, {"sha": "bf25e97c629b7a09489712097f5846ecbabe371d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1a701eb1703ea4eb338f1a9ed447188f2513916/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1a701eb1703ea4eb338f1a9ed447188f2513916/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d1a701eb1703ea4eb338f1a9ed447188f2513916", "patch": "@@ -339,17 +339,22 @@ layout_decl (tree decl, unsigned int known_align)\n     /* For fields, it's a bit more complicated...  */\n     {\n       bool old_user_align = DECL_USER_ALIGN (decl);\n+      bool zero_bitfield = false;\n+      bool packed_p = DECL_PACKED (decl);\n+      unsigned int mfa;\n \n       if (DECL_BIT_FIELD (decl))\n \t{\n \t  DECL_BIT_FIELD_TYPE (decl) = type;\n \n \t  /* A zero-length bit-field affects the alignment of the next\n-\t     field.  */\n+\t     field.  In essence such bit-fields are not influenced by\n+\t     any packing due to #pragma pack or attribute packed.  */\n \t  if (integer_zerop (DECL_SIZE (decl))\n-\t      && ! DECL_PACKED (decl)\n \t      && ! targetm.ms_bitfield_layout_p (DECL_FIELD_CONTEXT (decl)))\n \t    {\n+\t      zero_bitfield = true;\n+\t      packed_p = false;\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n \t      if (PCC_BITFIELD_TYPE_MATTERS)\n \t\tdo_type_align (type, decl);\n@@ -393,7 +398,7 @@ layout_decl (tree decl, unsigned int known_align)\n \t      && DECL_ALIGN (decl) >= TYPE_ALIGN (type))\n \t    DECL_BIT_FIELD (decl) = 0;\n \t}\n-      else if (DECL_PACKED (decl) && DECL_USER_ALIGN (decl))\n+      else if (packed_p && DECL_USER_ALIGN (decl))\n \t/* Don't touch DECL_ALIGN.  For other packed fields, go ahead and\n \t   round up; we'll reduce it again below.  We want packing to\n \t   supersede USER_ALIGN inherited from the type, but defer to\n@@ -408,14 +413,14 @@ layout_decl (tree decl, unsigned int known_align)\n \n \t Note that do_type_align may set DECL_USER_ALIGN, so we need to\n \t check old_user_align instead.  */\n-      if (DECL_PACKED (decl)\n+      if (packed_p\n \t  && !old_user_align\n \t  && (DECL_NONADDRESSABLE_P (decl)\n \t      || DECL_SIZE_UNIT (decl) == 0\n \t      || TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST))\n \tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);\n \n-      if (! DECL_USER_ALIGN (decl) && ! DECL_PACKED (decl))\n+      if (! packed_p && ! DECL_USER_ALIGN (decl))\n \t{\n \t  /* Some targets (i.e. i386, VMS) limit struct field alignment\n \t     to a lower boundary than alignment of variables unless\n@@ -429,9 +434,13 @@ layout_decl (tree decl, unsigned int known_align)\n #endif\n \t}\n \n+      if (zero_bitfield)\n+        mfa = initial_max_fld_align * BITS_PER_UNIT;\n+      else\n+\tmfa = maximum_field_alignment;\n       /* Should this be controlled by DECL_USER_ALIGN, too?  */\n-      if (maximum_field_alignment != 0)\n-\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);\n+      if (mfa != 0)\n+\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), mfa);\n     }\n \n   /* Evaluate nonconstant size only once, either now or as soon as safe.  */\n@@ -715,7 +724,16 @@ update_alignment_for_field (record_layout_info rli, tree field,\n \t    type_align = ADJUST_FIELD_ALIGN (field, type_align);\n #endif\n \n-\t  if (maximum_field_alignment != 0)\n+\t  /* Targets might chose to handle unnamed and hence possibly\n+\t     zero-width bitfield.  Those are not influenced by #pragmas\n+\t     or packed attributes.  */\n+\t  if (integer_zerop (DECL_SIZE (field)))\n+\t    {\n+\t      if (initial_max_fld_align)\n+\t        type_align = MIN (type_align,\n+\t\t\t\t  initial_max_fld_align * BITS_PER_UNIT);\n+\t    }\n+\t  else if (maximum_field_alignment != 0)\n \t    type_align = MIN (type_align, maximum_field_alignment);\n \t  else if (DECL_PACKED (field))\n \t    type_align = MIN (type_align, BITS_PER_UNIT);\n@@ -1177,6 +1195,10 @@ place_field (record_layout_info rli, tree field)\n   if (DECL_BIT_FIELD_TYPE (field))\n     {\n       unsigned int type_align = TYPE_ALIGN (type);\n+      unsigned int mfa = maximum_field_alignment;\n+\n+      if (integer_zerop (DECL_SIZE (field)))\n+        mfa = initial_max_fld_align * BITS_PER_UNIT;\n \n       /* Only the MS bitfields use this.  We used to also put any kind of\n \t packed bit fields into prev_field, but that makes no sense, because\n@@ -1185,8 +1207,8 @@ place_field (record_layout_info rli, tree field)\n \t are also not fulfilled.\n \t There is no sane value to set rli->remaining_in_alignment to when\n \t a packed bitfield in prev_field is unaligned.  */\n-      if (maximum_field_alignment != 0)\n-\ttype_align = MIN (type_align, maximum_field_alignment);\n+      if (mfa != 0)\n+\ttype_align = MIN (type_align, mfa);\n       gcc_assert (rli->prev_field\n \t\t  || actual_align >= type_align || DECL_PACKED (field)\n \t\t  || integer_zerop (DECL_SIZE (field))"}]}