{"sha": "9157ccb29f552d2cb1a0c668658503580757c4ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE1N2NjYjI5ZjU1MmQyY2IxYTBjNjY4NjU4NTAzNTgwNzU3YzRhZA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-07-17T09:57:19Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-07-17T09:57:19Z"}, "message": "trans-array.c (gfc_free_ss): Don't free beyond ss rank.\n\n2010-07-17  Mikael Morin  <mikael@gcc.gnu.org>\n\n\t* trans-array.c (gfc_free_ss): Don't free beyond ss rank.\n\tAccess subscript through the \"dim\" field index.\n\t(gfc_trans_create_temp_array): Access ss info through the \"dim\" field\n\tindex.\n\t(gfc_conv_array_index_offset): Ditto.\n\t(gfc_conv_loop_setup): Ditto.\n\t(gfc_conv_expr_descriptor): Ditto.\n\t(gfc_conv_ss_startstride): Ditto.  Update call to\n\tgfc_conv_section_startstride.\n\t(gfc_conv_section_startstride): Set values along the array dimension.\n\tGet array dimension directly from the argument.\n\nFrom-SVN: r162276", "tree": {"sha": "dfe040e3cb597dd59cec2457c3fe5d55ccaf1d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe040e3cb597dd59cec2457c3fe5d55ccaf1d5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9157ccb29f552d2cb1a0c668658503580757c4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9157ccb29f552d2cb1a0c668658503580757c4ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9157ccb29f552d2cb1a0c668658503580757c4ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9157ccb29f552d2cb1a0c668658503580757c4ad/comments", "author": null, "committer": null, "parents": [{"sha": "77198d71e127a52e2b2bf9606074c7c9f68d9224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77198d71e127a52e2b2bf9606074c7c9f68d9224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77198d71e127a52e2b2bf9606074c7c9f68d9224"}], "stats": {"total": 272, "additions": 152, "deletions": 120}, "files": [{"sha": "81722a1b7b51c337d842795ed1fe6b670ff8e884", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9157ccb29f552d2cb1a0c668658503580757c4ad/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9157ccb29f552d2cb1a0c668658503580757c4ad/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9157ccb29f552d2cb1a0c668658503580757c4ad", "patch": "@@ -1,3 +1,17 @@\n+2010-07-17  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_free_ss): Don't free beyond ss rank.\n+\tAccess subscript through the \"dim\" field index.\n+\t(gfc_trans_create_temp_array): Access ss info through the \"dim\" field\n+\tindex.\n+\t(gfc_conv_array_index_offset): Ditto.\n+\t(gfc_conv_loop_setup): Ditto.\n+\t(gfc_conv_expr_descriptor): Ditto.\n+\t(gfc_conv_ss_startstride): Ditto.  Update call to\n+\tgfc_conv_section_startstride.\n+\t(gfc_conv_section_startstride): Set values along the array dimension.\n+\tGet array dimension directly from the argument.\n+\n 2010-07-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans.h (gfc_string_to_single_character): New prototype.\n@@ -75,7 +89,7 @@\n \n \t* trans-array.c (gfc_conv_section_upper_bound): Remove\n \t(gfc_conv_section_startstride): Don't set the upper bound in the \n-\tvector subscript case. \n+\tvector subscript case.\n \t(gfc_conv_loop_setup): Don't use gfc_conv_section_upper_bound\n \n 2010-07-14  Janus Weil  <janus@gcc.gnu.org>\n@@ -200,11 +214,11 @@\n \t* trans-stmt.c (ADD_FIELD): Ditto.\n \t* trans-types.c\n \t(gfc_get_derived_type): Ditto. Don't create backend_decl for C_PTR's\n-\tC_ADDRESS field. \n+\tC_ADDRESS field.\n \t(gfc_add_field_to_struct_1): Set TYPE_FIELDS(context) instead of\n \tfieldlist, remove fieldlist from argument list.\n \t(gfc_add_field_to_struct): Update call to gfc_add_field_to_struct_1\n-\tand remove fieldlist from argument list. \n+\tand remove fieldlist from argument list.\n \t(gfc_get_desc_dim_type, gfc_get_array_descriptor_base,\n \tgfc_get_mixed_entry_union): Move setting\n \tTYPE_FIELDS to gfc_add_field_to_struct_1 and update calls to it."}, {"sha": "d4f1cdf8f6783b84a3b411d1a6a0aca83106b61c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 133, "deletions": 115, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9157ccb29f552d2cb1a0c668658503580757c4ad/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9157ccb29f552d2cb1a0c668658503580757c4ad/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=9157ccb29f552d2cb1a0c668658503580757c4ad", "patch": "@@ -434,10 +434,10 @@ gfc_free_ss (gfc_ss * ss)\n   switch (ss->type)\n     {\n     case GFC_SS_SECTION:\n-      for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n+      for (n = 0; n < ss->data.info.dimen; n++)\n \t{\n-\t  if (ss->data.info.subscript[n])\n-\t    gfc_free_ss_chain (ss->data.info.subscript[n]);\n+\t  if (ss->data.info.subscript[ss->data.info.dim[n]])\n+\t    gfc_free_ss_chain (ss->data.info.subscript[ss->data.info.dim[n]]);\n \t}\n       break;\n \n@@ -762,25 +762,28 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   for (n = 0; n < info->dimen; n++)\n      {\n+      dim = info->dim[n];\n+\n       if (size == NULL_TREE)\n \t{\n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n-\t  tmp =\n-\t    fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[n]),\n-\t\t\t gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]));\n+\t  tmp = fold_build2 (\n+\t\tMINUS_EXPR, gfc_array_index_type,\n+\t\tgfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]),\n+\t\tgfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]));\n \t  loop->to[n] = tmp;\n \t  continue;\n \t}\n \t\n       /* Store the stride and bound components in the descriptor.  */\n-      gfc_conv_descriptor_stride_set (pre, desc, gfc_rank_cst[n], size);\n+      gfc_conv_descriptor_stride_set (pre, desc, gfc_rank_cst[dim], size);\n \n-      gfc_conv_descriptor_lbound_set (pre, desc, gfc_rank_cst[n],\n+      gfc_conv_descriptor_lbound_set (pre, desc, gfc_rank_cst[dim],\n \t\t\t\t      gfc_index_zero_node);\n \n-      gfc_conv_descriptor_ubound_set (pre, desc, gfc_rank_cst[n], loop->to[n]);\n+      gfc_conv_descriptor_ubound_set (pre, desc, gfc_rank_cst[dim],\n+\t\t\t\t      loop->to[n]);\n \n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t loop->to[n], gfc_index_one_node);\n@@ -2387,7 +2390,8 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n \n \n /* Return the offset for an index.  Performs bound checking for elemental\n-   dimensions.  Single element references are processed separately.  */\n+   dimensions.  Single element references are processed separately.\n+   DIM is the array dimension, I is the loop dimension.  */\n \n static tree\n gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n@@ -2448,14 +2452,14 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t  /* Scalarized dimension.  */\n \t  gcc_assert (info && se->loop);\n \n-          /* Multiply the loop variable by the stride and delta.  */\n+\t  /* Multiply the loop variable by the stride and delta.  */\n \t  index = se->loop->loopvar[i];\n-\t  if (!integer_onep (info->stride[i]))\n+\t  if (!integer_onep (info->stride[dim]))\n \t    index = fold_build2 (MULT_EXPR, gfc_array_index_type, index,\n-\t\t\t\t info->stride[i]);\n-\t  if (!integer_zerop (info->delta[i]))\n+\t\t\t\t info->stride[dim]);\n+\t  if (!integer_zerop (info->delta[dim]))\n \t    index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index,\n-\t\t\t\t info->delta[i]);\n+\t\t\t\t info->delta[dim]);\n \t  break;\n \n \tdefault:\n@@ -2467,9 +2471,9 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n       /* Temporary array or derived type component.  */\n       gcc_assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n-      if (!integer_zerop (info->delta[i]))\n+      if (!integer_zerop (info->delta[dim]))\n \tindex = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     index, info->delta[i]);\n+\t\t\t     index, info->delta[dim]);\n     }\n \n   /* Multiply by the stride.  */\n@@ -2967,27 +2971,25 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n /* Calculate the lower bound of an array section.  */\n \n static void\n-gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n+gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n {\n   gfc_expr *start;\n   gfc_expr *end;\n   gfc_expr *stride;\n   tree desc;\n   gfc_se se;\n   gfc_ss_info *info;\n-  int dim;\n \n   gcc_assert (ss->type == GFC_SS_SECTION);\n \n   info = &ss->data.info;\n-  dim = info->dim[n];\n \n   if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n     {\n       /* We use a zero-based index to access the vector.  */\n-      info->start[n] = gfc_index_zero_node;\n-      info->stride[n] = gfc_index_one_node;\n-      info->end[n] = NULL;\n+      info->start[dim] = gfc_index_zero_node;\n+      info->stride[dim] = gfc_index_one_node;\n+      info->end[dim] = NULL;\n       return;\n     }\n \n@@ -3005,14 +3007,14 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_type (&se, start, gfc_array_index_type);\n       gfc_add_block_to_block (&loop->pre, &se.pre);\n-      info->start[n] = se.expr;\n+      info->start[dim] = se.expr;\n     }\n   else\n     {\n       /* No lower bound specified so use the bound of the array.  */\n-      info->start[n] = gfc_conv_array_lbound (desc, dim);\n+      info->start[dim] = gfc_conv_array_lbound (desc, dim);\n     }\n-  info->start[n] = gfc_evaluate_now (info->start[n], &loop->pre);\n+  info->start[dim] = gfc_evaluate_now (info->start[dim], &loop->pre);\n \n   /* Similarly calculate the end.  Although this is not used in the\n      scalarizer, it is needed when checking bounds and where the end\n@@ -3023,24 +3025,24 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_type (&se, end, gfc_array_index_type);\n       gfc_add_block_to_block (&loop->pre, &se.pre);\n-      info->end[n] = se.expr;\n+      info->end[dim] = se.expr;\n     }\n   else\n     {\n       /* No upper bound specified so use the bound of the array.  */\n-      info->end[n] = gfc_conv_array_ubound (desc, dim);\n+      info->end[dim] = gfc_conv_array_ubound (desc, dim);\n     }\n-  info->end[n] = gfc_evaluate_now (info->end[n], &loop->pre);\n+  info->end[dim] = gfc_evaluate_now (info->end[dim], &loop->pre);\n \n   /* Calculate the stride.  */\n   if (stride == NULL)\n-    info->stride[n] = gfc_index_one_node;\n+    info->stride[dim] = gfc_index_one_node;\n   else\n     {\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_type (&se, stride, gfc_array_index_type);\n       gfc_add_block_to_block (&loop->pre, &se.pre);\n-      info->stride[n] = gfc_evaluate_now (se.expr, &loop->pre);\n+      info->stride[dim] = gfc_evaluate_now (se.expr, &loop->pre);\n     }\n }\n \n@@ -3105,7 +3107,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n \n \t  for (n = 0; n < ss->data.info.dimen; n++)\n-\t    gfc_conv_section_startstride (loop, ss, n);\n+\t    gfc_conv_section_startstride (loop, ss, ss->data.info.dim[n]);\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -3180,39 +3182,38 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\tcheck_upper = true;\n \n \t      /* Zero stride is not allowed.  */\n-\t      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[n],\n+\t      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[dim],\n \t\t\t\t gfc_index_zero_node);\n \t      asprintf (&msg, \"Zero stride is not allowed, for dimension %d \"\n-\t\t\t\"of array '%s'\", info->dim[n]+1,\n-\t\t\tss->expr->symtree->name);\n+\t\t\t\"of array '%s'\", dim + 1, ss->expr->symtree->name);\n \t      gfc_trans_runtime_check (true, false, tmp, &inner,\n \t\t\t\t       &ss->expr->where, msg);\n \t      gfc_free (msg);\n \n \t      desc = ss->data.info.descriptor;\n \n \t      /* This is the run-time equivalent of resolve.c's\n-\t         check_dimension().  The logical is more readable there\n-\t         than it is here, with all the trees.  */\n+\t\t check_dimension().  The logical is more readable there\n+\t\t than it is here, with all the trees.  */\n \t      lbound = gfc_conv_array_lbound (desc, dim);\n-\t      end = info->end[n];\n+\t      end = info->end[dim];\n \t      if (check_upper)\n \t\tubound = gfc_conv_array_ubound (desc, dim);\n \t      else\n \t\tubound = NULL;\n \n \t      /* non_zerosized is true when the selected range is not\n-\t         empty.  */\n+\t\t empty.  */\n \t      stride_pos = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\tinfo->stride[n], gfc_index_zero_node);\n-\t      tmp = fold_build2 (LE_EXPR, boolean_type_node, info->start[n],\n+\t\t\t\t\tinfo->stride[dim], gfc_index_zero_node);\n+\t      tmp = fold_build2 (LE_EXPR, boolean_type_node, info->start[dim],\n \t\t\t\t end);\n \t      stride_pos = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\tstride_pos, tmp);\n \n \t      stride_neg = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\tinfo->stride[n], gfc_index_zero_node);\n-\t      tmp = fold_build2 (GE_EXPR, boolean_type_node, info->start[n],\n+\t\t\t\t\tinfo->stride[dim], gfc_index_zero_node);\n+\t      tmp = fold_build2 (GE_EXPR, boolean_type_node, info->start[dim],\n \t\t\t\t end);\n \t      stride_neg = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\tstride_neg, tmp);\n@@ -3225,41 +3226,41 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t error message.  */\n \t      if (check_upper)\n \t\t{\n-\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node, \n-\t\t\t\t     info->start[n], lbound);\n+\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t     info->start[dim], lbound);\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n \t\t  tmp2 = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t      info->start[n], ubound);\n+\t\t\t\t      info->start[dim], ubound);\n \t\t  tmp2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t      non_zerosized, tmp2);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n-\t\t\t    \"outside of expected range (%%ld:%%ld)\", \n-\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (true, false, tmp, &inner, \n+\t\t\t    \"outside of expected range (%%ld:%%ld)\",\n+\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n \t\t\t\t\t   &ss->expr->where, msg,\n-\t\t     fold_convert (long_integer_type_node, info->start[n]),\n-\t\t     fold_convert (long_integer_type_node, lbound), \n+\t\t     fold_convert (long_integer_type_node, info->start[dim]),\n+\t\t     fold_convert (long_integer_type_node, lbound),\n \t\t     fold_convert (long_integer_type_node, ubound));\n-\t\t  gfc_trans_runtime_check (true, false, tmp2, &inner, \n+\t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n \t\t\t\t\t   &ss->expr->where, msg,\n-\t\t     fold_convert (long_integer_type_node, info->start[n]),\n-\t\t     fold_convert (long_integer_type_node, lbound), \n+\t\t     fold_convert (long_integer_type_node, info->start[dim]),\n+\t\t     fold_convert (long_integer_type_node, lbound),\n \t\t     fold_convert (long_integer_type_node, ubound));\n \t\t  gfc_free (msg);\n \t\t}\n \t      else\n \t\t{\n-\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node, \n-\t\t\t\t     info->start[n], lbound);\n+\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t     info->start[dim], lbound);\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n-\t\t\t    \"below lower bound of %%ld\", \n-\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n-\t\t  gfc_trans_runtime_check (true, false, tmp, &inner, \n+\t\t\t    \"below lower bound of %%ld\",\n+\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n \t\t\t\t\t   &ss->expr->where, msg,\n-\t\t     fold_convert (long_integer_type_node, info->start[n]),\n+\t\t     fold_convert (long_integer_type_node, info->start[dim]),\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  gfc_free (msg);\n \t\t}\n@@ -3269,9 +3270,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t and check it against both lower and upper bounds.  */\n \n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t  info->start[n]);\n+\t\t\t\t  info->start[dim]);\n \t      tmp = fold_build2 (TRUNC_MOD_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t  info->stride[n]);\n+\t\t\t\t  info->stride[dim]);\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n \t\t\t\t  tmp);\n \t      tmp2 = fold_build2 (LT_EXPR, boolean_type_node, tmp, lbound);\n@@ -3283,8 +3284,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  tmp3 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t      non_zerosized, tmp3);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n-\t\t\t    \"outside of expected range (%%ld:%%ld)\", \n-\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n+\t\t\t    \"outside of expected range (%%ld:%%ld)\",\n+\t\t\t    dim + 1, ss->expr->symtree->name);\n \t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n \t\t\t\t\t   &ss->expr->where, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n@@ -3300,32 +3301,32 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      else\n \t\t{\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n-\t\t\t    \"below lower bound of %%ld\", \n-\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n+\t\t\t    \"below lower bound of %%ld\",\n+\t\t\t    dim + 1, ss->expr->symtree->name);\n \t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n \t\t\t\t\t   &ss->expr->where, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  gfc_free (msg);\n \t\t}\n-\t      \n+\n \t      /* Check the section sizes match.  */\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t info->start[n]);\n+\t\t\t\t info->start[dim]);\n \t      tmp = fold_build2 (FLOOR_DIV_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t info->stride[n]);\n+\t\t\t\t info->stride[dim]);\n \t      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t\t gfc_index_one_node, tmp);\n \t      tmp = fold_build2 (MAX_EXPR, gfc_array_index_type, tmp,\n \t\t\t\t build_int_cst (gfc_array_index_type, 0));\n \t      /* We remember the size of the first section, and check all the\n-\t         others against this.  */\n+\t\t others against this.  */\n \t      if (size[n])\n \t\t{\n \t\t  tmp3 = fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n \t\t  asprintf (&msg, \"Array bound mismatch for dimension %d \"\n \t\t\t    \"of array '%s' (%%ld/%%ld)\",\n-\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n+\t\t\t    dim + 1, ss->expr->symtree->name);\n \n \t\t  gfc_trans_runtime_check (true, false, tmp3, &inner,\n \t\t\t\t\t   &ss->expr->where, msg,\n@@ -3517,7 +3518,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n void\n gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n {\n-  int n;\n+  int n, dim, spec_dim;\n   gfc_ss_info *info;\n   gfc_ss_info *specinfo;\n   gfc_ss *ss;\n@@ -3533,14 +3534,34 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n       loopspec[n] = NULL;\n       dynamic[n] = false;\n       /* We use one SS term, and use that to determine the bounds of the\n-         loop for this dimension.  We try to pick the simplest term.  */\n+\t loop for this dimension.  We try to pick the simplest term.  */\n       for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n \t{\n+\t  if (ss->type == GFC_SS_SCALAR || ss->type == GFC_SS_REFERENCE)\n+\t    continue;\n+\n+\t  info = &ss->data.info;\n+\t  dim = info->dim[n];\n+\n+\t  if (loopspec[n] != NULL)\n+\t    {\n+\t      specinfo = &loopspec[n]->data.info;\n+\t      spec_dim = specinfo->dim[n];\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Silence unitialized warnings.  */\n+\t      specinfo = NULL;\n+\t      spec_dim = 0;\n+\t    }\n+\n \t  if (ss->shape)\n \t    {\n+\t      gcc_assert (ss->shape[dim]);\n \t      /* The frontend has worked out the size for us.  */\n-\t      if (!loopspec[n] || !loopspec[n]->shape\n-\t\t    || !integer_zerop (loopspec[n]->data.info.start[n]))\n+\t      if (!loopspec[n]\n+\t\t  || !loopspec[n]->shape\n+\t\t  || !integer_zerop (specinfo->start[spec_dim]))\n \t\t/* Prefer zero-based descriptors if possible.  */\n \t\tloopspec[n] = ss;\n \t      continue;\n@@ -3567,22 +3588,16 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \n \t  /* TODO: Pick the best bound if we have a choice between a\n \t     function and something else.  */\n-          if (ss->type == GFC_SS_FUNCTION)\n-            {\n-              loopspec[n] = ss;\n-              continue;\n-            }\n+\t  if (ss->type == GFC_SS_FUNCTION)\n+\t    {\n+\t      loopspec[n] = ss;\n+\t      continue;\n+\t    }\n \n \t  if (ss->type != GFC_SS_SECTION)\n \t    continue;\n \n-\t  if (loopspec[n])\n-\t    specinfo = &loopspec[n]->data.info;\n-\t  else\n-\t    specinfo = NULL;\n-\t  info = &ss->data.info;\n-\n-\t  if (!specinfo)\n+\t  if (!loopspec[n])\n \t    loopspec[n] = ss;\n \t  /* Criteria for choosing a loop specifier (most important first):\n \t     doesn't need realloc\n@@ -3593,14 +3608,14 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t   */\n \t  else if (loopspec[n]->type == GFC_SS_CONSTRUCTOR && dynamic[n])\n \t    loopspec[n] = ss;\n-\t  else if (integer_onep (info->stride[n])\n-\t\t   && !integer_onep (specinfo->stride[n]))\n+\t  else if (integer_onep (info->stride[dim])\n+\t\t   && !integer_onep (specinfo->stride[spec_dim]))\n \t    loopspec[n] = ss;\n-\t  else if (INTEGER_CST_P (info->stride[n])\n-\t\t   && !INTEGER_CST_P (specinfo->stride[n]))\n+\t  else if (INTEGER_CST_P (info->stride[dim])\n+\t\t   && !INTEGER_CST_P (specinfo->stride[spec_dim]))\n \t    loopspec[n] = ss;\n-\t  else if (INTEGER_CST_P (info->start[n])\n-\t\t   && !INTEGER_CST_P (specinfo->start[n]))\n+\t  else if (INTEGER_CST_P (info->start[dim])\n+\t\t   && !INTEGER_CST_P (specinfo->start[spec_dim]))\n \t    loopspec[n] = ss;\n \t  /* We don't work out the upper bound.\n \t     else if (INTEGER_CST_P (info->finish[n])\n@@ -3613,26 +3628,27 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n       gcc_assert (loopspec[n]);\n \n       info = &loopspec[n]->data.info;\n+      dim = info->dim[n];\n \n       /* Set the extents of this range.  */\n       cshape = loopspec[n]->shape;\n-      if (cshape && INTEGER_CST_P (info->start[n])\n-\t  && INTEGER_CST_P (info->stride[n]))\n+      if (cshape && INTEGER_CST_P (info->start[dim])\n+\t  && INTEGER_CST_P (info->stride[dim]))\n \t{\n-\t  loop->from[n] = info->start[n];\n+\t  loop->from[n] = info->start[dim];\n \t  mpz_set (i, cshape[n]);\n \t  mpz_sub_ui (i, i, 1);\n \t  /* To = from + (size - 1) * stride.  */\n \t  tmp = gfc_conv_mpz_to_tree (i, gfc_index_integer_kind);\n-\t  if (!integer_onep (info->stride[n]))\n+\t  if (!integer_onep (info->stride[dim]))\n \t    tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t       tmp, info->stride[n]);\n+\t\t\t       tmp, info->stride[dim]);\n \t  loop->to[n] = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t\t     loop->from[n], tmp);\n \t}\n       else\n \t{\n-\t  loop->from[n] = info->start[n];\n+\t  loop->from[n] = info->start[dim];\n \t  switch (loopspec[n]->type)\n \t    {\n \t    case GFC_SS_CONSTRUCTOR:\n@@ -3644,7 +3660,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t    case GFC_SS_SECTION:\n \t      /* Use the end expression if it exists and is not constant,\n \t\t so that it is only evaluated once.  */\n-\t      loop->to[n] = info->end[n];\n+\t      loop->to[n] = info->end[dim];\n \t      break;\n \n \t    case GFC_SS_FUNCTION:\n@@ -3658,20 +3674,20 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t}\n \n       /* Transform everything so we have a simple incrementing variable.  */\n-      if (integer_onep (info->stride[n]))\n-\tinfo->delta[n] = gfc_index_zero_node;\n+      if (integer_onep (info->stride[dim]))\n+\tinfo->delta[dim] = gfc_index_zero_node;\n       else\n \t{\n \t  /* Set the delta for this section.  */\n-\t  info->delta[n] = gfc_evaluate_now (loop->from[n], &loop->pre);\n+\t  info->delta[dim] = gfc_evaluate_now (loop->from[n], &loop->pre);\n \t  /* Number of iterations is (end - start + step) / step.\n \t     with start = 0, this simplifies to\n \t     last = end / step;\n \t     for (i = 0; i<=last; i++){...};  */\n \t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t     loop->to[n], loop->from[n]);\n-\t  tmp = fold_build2 (FLOOR_DIV_EXPR, gfc_array_index_type, \n-\t\t\t     tmp, info->stride[n]);\n+\t  tmp = fold_build2 (FLOOR_DIV_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, info->stride[dim]);\n \t  tmp = fold_build2 (MAX_EXPR, gfc_array_index_type, tmp,\n \t\t\t     build_int_cst (gfc_array_index_type, -1));\n \t  loop->to[n] = gfc_evaluate_now (tmp, &loop->pre);\n@@ -3732,18 +3748,20 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t  /* If we are specifying the range the delta is already set.  */\n \t  if (loopspec[n] != ss)\n \t    {\n+\t      dim = ss->data.info.dim[n];\n+\n \t      /* Calculate the offset relative to the loop variable.\n-\t         First multiply by the stride.  */\n+\t\t First multiply by the stride.  */\n \t      tmp = loop->from[n];\n-\t      if (!integer_onep (info->stride[n]))\n+\t      if (!integer_onep (info->stride[dim]))\n \t\ttmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t   tmp, info->stride[n]);\n+\t\t\t\t   tmp, info->stride[dim]);\n \n \t      /* Then subtract this from our starting value.  */\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t info->start[n], tmp);\n+\t\t\t\t info->start[dim], tmp);\n \n-\t      info->delta[n] = gfc_evaluate_now (tmp, &loop->pre);\n+\t      info->delta[dim] = gfc_evaluate_now (tmp, &loop->pre);\n \t    }\n \t}\n     }\n@@ -5296,7 +5314,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t      gcc_assert (info->dim[dim] == n);\n \n \t      /* Evaluate and remember the start of the section.  */\n-\t      start = info->start[dim];\n+\t      start = info->start[n];\n \t      stride = gfc_evaluate_now (stride, &loop.pre);\n \t    }\n \n@@ -5343,11 +5361,11 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Multiply the stride by the section stride to get the\n \t     total stride.  */\n \t  stride = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\tstride, info->stride[dim]);\n+\t\t\t\tstride, info->stride[n]);\n \n \t  if (se->direct_byref\n-\t\t&& info->ref\n-\t\t&& info->ref->u.ar.type != AR_FULL)\n+\t      && info->ref\n+\t      && info->ref->u.ar.type != AR_FULL)\n \t    {\n \t      base = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n \t\t\t\t  base, stride);"}, {"sha": "db782c0a0ff04ffe404a1a11bf0b7d02cde6ac44", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9157ccb29f552d2cb1a0c668658503580757c4ad/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9157ccb29f552d2cb1a0c668658503580757c4ad/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=9157ccb29f552d2cb1a0c668658503580757c4ad", "patch": "@@ -114,8 +114,8 @@ typedef struct gfc_ss_info\n   tree stride[GFC_MAX_DIMENSIONS];\n   tree delta[GFC_MAX_DIMENSIONS];\n \n-  /* Translation from scalarizer dimensions to actual dimensions.\n-     actual = dim[scalarizer]  */\n+  /* Translation from loop dimensions to actual dimensions.\n+     actual_dim = dim[loop_dim]  */\n   int dim[GFC_MAX_DIMENSIONS];\n }\n gfc_ss_info;"}]}