{"sha": "c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjNmY3ODVjOGU4OTNlYzdiY2FjZDFhMjMxOWNlMzA5ZDI0NTBmMg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-05-01T00:25:27Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T19:09:39Z"}, "message": "Adding Rust target hook documentation\nAdded powerpc target hook and improved aarch64 feature handling\nAdded DEC Alpha target hook\nAdded ARC target hook\nCreated ARM target hook (at least preliminary support)", "tree": {"sha": "390cd5960fb125655ab707cb12567d2a9a0ffeb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/390cd5960fb125655ab707cb12567d2a9a0ffeb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7266d66d2321562ef74daf90ffb1ad70d081d890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7266d66d2321562ef74daf90ffb1ad70d081d890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7266d66d2321562ef74daf90ffb1ad70d081d890"}], "stats": {"total": 7420, "additions": 3906, "deletions": 3514}, "files": [{"sha": "1af578b939c69832a9557078c553cbac29936b3f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -560,6 +560,8 @@ tm_p_file_list=@tm_p_file_list@\n tm_p_include_list=@tm_p_include_list@\n tm_d_file_list=@tm_d_file_list@\n tm_d_include_list=@tm_d_include_list@\n+tm_rust_file_list=@tm_rust_file_list@\n+tm_rust_include_list=@tm_rust_include_list@\n build_xm_file_list=@build_xm_file_list@\n build_xm_include_list=@build_xm_include_list@\n build_xm_defines=@build_xm_defines@\n@@ -855,6 +857,7 @@ CONFIG_H  = config.h  $(host_xm_file_list)\n TCONFIG_H = tconfig.h $(xm_file_list)\n TM_P_H    = tm_p.h    $(tm_p_file_list)\n TM_D_H    = tm_d.h    $(tm_d_file_list)\n+TM_RUST_H = tm_rust.h $(tm_rust_file_list)\n GTM_H     = tm.h      $(tm_file_list) insn-constants.h\n TM_H      = $(GTM_H) insn-flags.h $(OPTIONS_H)\n \n@@ -917,6 +920,7 @@ TARGET_H = $(TM_H) target.h $(TARGET_DEF) insn-modes.h insn-codes.h\n C_TARGET_H = c-family/c-target.h $(C_TARGET_DEF)\n COMMON_TARGET_H = common/common-target.h $(INPUT_H) $(COMMON_TARGET_DEF)\n D_TARGET_H = d/d-target.h $(D_TARGET_DEF)\n+RUST_TARGET_H = rust/rust-target.h $(RUST_TARGET_DEF)\n MACHMODE_H = machmode.h mode-classes.def\n HOOKS_H = hooks.h\n HOSTHOOKS_DEF_H = hosthooks-def.h $(HOOKS_H)\n@@ -1203,6 +1207,9 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n # Target specific, D specific object file\n D_TARGET_OBJS=@d_target_objs@\n \n+# Target specific, D specific object file\n+RUST_TARGET_OBJS=@rust_target_objs@\n+\n # Target specific, Fortran specific object file\n FORTRAN_TARGET_OBJS=@fortran_target_objs@\n \n@@ -1876,6 +1883,7 @@ tconfig.h: cs-tconfig.h ; @true\n tm.h: cs-tm.h ; @true\n tm_p.h: cs-tm_p.h ; @true\n tm_d.h: cs-tm_d.h ; @true\n+tm_rust.h: cs-tm_rust.h ; @true\n \n cs-config.h: Makefile\n \tTARGET_CPU_DEFAULT=\"\" \\\n@@ -1907,6 +1915,11 @@ cs-tm_d.h: Makefile\n \tHEADERS=\"$(tm_d_include_list)\" DEFINES=\"\" \\\n \t$(SHELL) $(srcdir)/mkconfig.sh tm_d.h\n \n+cs-tm_rust.h: Makefile\n+\tTARGET_CPU_DEFAULT=\"\" \\\n+\tHEADERS=\"$(tm_rust_include_list)\" DEFINES=\"\" \\\n+\t$(SHELL) $(srcdir)/mkconfig.sh tm_rust.h\n+\n # Don't automatically run autoconf, since configure.ac might be accidentally\n # newer than configure.  Also, this writes into the source directory which\n # might be on a read-only file system.  If configured for maintainer mode\n@@ -2243,6 +2256,12 @@ default-d.o: config/default-d.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+# Files used by the Rust language front end.\n+\n+default-rust.o: config/default-rust.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n # Language-independent files.\n \n DRIVER_DEFINES = \\\n@@ -2553,6 +2572,15 @@ s-d-target-hooks-def-h: build/genhooks$(build_exeext)\n \t\t\t\t\t     d/d-target-hooks-def.h\n \t$(STAMP) s-d-target-hooks-def-h\n \n+rust/rust-target-hooks-def.h: s-rust-target-hooks-def-h; @true\n+\n+s-rust-target-hooks-def-h: build/genhooks$(build_exeext)\n+\t$(RUN_GEN) build/genhooks$(build_exeext) \"Rust Target Hook\" \\\n+\t\t\t\t\t     > tmp-rust-target-hooks-def.h\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-rust-target-hooks-def.h \\\n+\t\t\t\t\t     rust/rust-target-hooks-def.h\n+\t$(STAMP) s-rust-target-hooks-def-h\n+\n # check if someone mistakenly only changed tm.texi.\n # We use a different pathname here to avoid a circular dependency.\n s-tm-texi: $(srcdir)/doc/../doc/tm.texi\n@@ -2577,6 +2605,7 @@ s-tm-texi: build/genhooks$(build_exeext) $(srcdir)/doc/tm.texi.in\n \t    || test $(srcdir)/doc/tm.texi -nt $(srcdir)/c-family/c-target.def \\\n \t    || test $(srcdir)/doc/tm.texi -nt $(srcdir)/common/common-target.def \\\n \t    || test $(srcdir)/doc/tm.texi -nt $(srcdir)/d/d-target.def \\\n+\t    || test $(srcdir)/doc/tm.texi -nt $(srcdir)/rust/rust-target.def \\\n \t  ); then \\\n \t  echo >&2 ; \\\n \t  echo You should edit $(srcdir)/doc/tm.texi.in rather than $(srcdir)/doc/tm.texi . >&2 ; \\\n@@ -2721,15 +2750,15 @@ s-gtype: build/gengtype$(build_exeext) $(filter-out [%], $(GTFILES)) \\\n                     -r gtype.state\n \t$(STAMP) s-gtype\n \n-generated_files = config.h tm.h $(TM_P_H) $(TM_D_H) $(TM_H) multilib.h \\\n-       $(simple_generated_h) specs.h \\\n+generated_files = config.h tm.h $(TM_P_H) $(TM_D_H) $(TM_RUST_H) $(TM_H) \\\n+       multilib.h $(simple_generated_h) specs.h \\\n        tree-check.h genrtl.h insn-modes.h insn-modes-inline.h \\\n        tm-preds.h tm-constrs.h \\\n        $(ALL_GTFILES_H) gtype-desc.c gtype-desc.h gcov-iov.h \\\n        options.h target-hooks-def.h insn-opinit.h \\\n        common/common-target-hooks-def.h pass-instances.def \\\n        c-family/c-target-hooks-def.h d/d-target-hooks-def.h \\\n-       case-cfn-macros.h \\\n+       rust/rust-target-hooks-def.h case-cfn-macros.h \\\n        cfn-operators.pd omp-device-properties.h\n \n #\f"}, {"sha": "a9fd6a7899c59d5bb757440a8f302966f5e1cab5", "filename": "gcc/config.gcc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -89,6 +89,9 @@\n #  tm_d_file\t\tA list of headers with definitions of target hook\n #\t\t\tmacros for the D compiler.\n #\n+#  tm_rust_file\t\tA list of headers with definitions of target hook\n+#\t\t\tmacros for the Rust compiler.\n+#\n #  out_file\t\tThe name of the machine description C support\n #\t\t\tfile, if different from \"$cpu_type/$cpu_type.c\".\n #\n@@ -145,6 +148,9 @@\n #  d_target_objs\tList of extra target-dependent objects that be\n #\t\t\tlinked into the D compiler only.\n #\n+#  rust_target_objs\tList of extra target-dependent objects that be\n+#\t\t\tlinked into the Rust compiler only.\n+#\n #  fortran_target_objs\tList of extra target-dependent objects that be\n #\t\t\tlinked into the fortran compiler only.\n #\n@@ -200,6 +206,9 @@\n #\n #  target_has_targetdm\tSet to yes or no depending on whether the target\n #\t\t\thas its own definition of targetdm.\n+#\n+#  target_has_targetrustm\tSet to yes or no depending on whether the target\n+#\t\t\thas its own definition of targetrustm.\n \n out_file=\n common_out_file=\n@@ -216,6 +225,7 @@ extra_options=\n c_target_objs=\n cxx_target_objs=\n d_target_objs=\n+rust_target_objs=\n fortran_target_objs=\n target_has_targetcm=no\n target_has_targetm_common=yes\n@@ -321,12 +331,14 @@ aarch64*-*-*)\n \tc_target_objs=\"aarch64-c.o\"\n \tcxx_target_objs=\"aarch64-c.o\"\n \td_target_objs=\"aarch64-d.o\"\n+\trust_target_objs=\"aarch64-rust.o\"\n \textra_objs=\"aarch64-builtins.o aarch-common.o aarch64-sve-builtins.o aarch64-sve-builtins-shapes.o aarch64-sve-builtins-base.o aarch64-sve-builtins-sve2.o cortex-a57-fma-steering.o aarch64-speculation.o falkor-tag-collision-avoidance.o aarch64-bti-insert.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/aarch64/aarch64-builtins.c \\$(srcdir)/config/aarch64/aarch64-sve-builtins.h \\$(srcdir)/config/aarch64/aarch64-sve-builtins.cc\"\n \ttarget_has_targetm_common=yes\n \t;;\n alpha*-*-*)\n \tcpu_type=alpha\n+\trust_target_objs=\"alpha-rust.o\"\n \textra_options=\"${extra_options} g.opt\"\n \t;;\n amdgcn*)\n@@ -340,6 +352,7 @@ arc*-*-*)\n \tcpu_type=arc\n \tc_target_objs=\"arc-c.o\"\n \tcxx_target_objs=\"arc-c.o\"\n+\trust_target_objs=\"arc-rust.o\"\n \textra_options=\"${extra_options} arc/arc-tables.opt g.opt\"\n \textra_headers=\"arc-simd.h\"\n \t;;\n@@ -351,6 +364,7 @@ arm*-*-*)\n \tc_target_objs=\"arm-c.o\"\n \tcxx_target_objs=\"arm-c.o\"\n \td_target_objs=\"arm-d.o\"\n+\trust_target_objs=\"arm-rust.o\"\n \textra_options=\"${extra_options} arm/arm-tables.opt\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/arm/arm-builtins.c\"\n \t;;\n@@ -384,6 +398,7 @@ i[34567]86-*-*)\n \tc_target_objs=\"i386-c.o\"\n \tcxx_target_objs=\"i386-c.o\"\n \td_target_objs=\"i386-d.o\"\n+\trust_target_objs=\"i386-rust.o\"\n \textra_objs=\"x86-tune-sched.o x86-tune-sched-bd.o x86-tune-sched-atom.o x86-tune-sched-core.o i386-options.o i386-builtins.o i386-expand.o i386-features.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/i386-builtins.c \\$(srcdir)/config/i386/i386-expand.c \\$(srcdir)/config/i386/i386-options.c\"\n \textra_options=\"${extra_options} fused-madd.opt\"\n@@ -421,6 +436,7 @@ x86_64-*-*)\n \tc_target_objs=\"i386-c.o\"\n \tcxx_target_objs=\"i386-c.o\"\n \td_target_objs=\"i386-d.o\"\n+\trust_target_objs=\"i386-rust.o\"\n \textra_options=\"${extra_options} fused-madd.opt\"\n \textra_objs=\"x86-tune-sched.o x86-tune-sched-bd.o x86-tune-sched-atom.o x86-tune-sched-core.o i386-options.o i386-builtins.o i386-expand.o i386-features.o\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/i386-builtins.c \\$(srcdir)/config/i386/i386-expand.c \\$(srcdir)/config/i386/i386-options.c\"\n@@ -578,10 +594,12 @@ esac\n \n tm_file=${cpu_type}/${cpu_type}.h\n tm_d_file=${cpu_type}/${cpu_type}.h\n+tm_rust_file=${cpu_type}/${cpu_type}.h\n if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-protos.h\n then\n \ttm_p_file=${cpu_type}/${cpu_type}-protos.h\n \ttm_d_file=\"${tm_d_file} ${cpu_type}/${cpu_type}-protos.h\"\n+\ttm_rust_file=\"${tm_rust_file} ${cpu_type}/${cpu_type}-protos.h\"\n fi\n \n extra_modes=\n@@ -3593,6 +3611,10 @@ if [ \"$target_has_targetdm\" = \"no\" ]; then\n   d_target_objs=\"$d_target_objs default-d.o\"\n fi\n \n+if [ \"$target_has_targetrustm\" = \"no\" ]; then\n+  rust_target_objs=\"$rust_target_objs default-rust.o\"\n+fi\n+\n # Support for --with-cpu and related options (and a few unrelated options,\n # too).\n case ${with_cpu} in\n@@ -5338,6 +5360,7 @@ case ${target} in\n \t\tc_target_objs=\"${c_target_objs} ${cpu_type}-c.o\"\n \t\tcxx_target_objs=\"${cxx_target_objs} ${cpu_type}-c.o\"\n \t\td_target_objs=\"${d_target_objs} ${cpu_type}-d.o\"\n+\t\trust_target_objs=\"${rust_target_objs} ${cpu_type}-rust.o\"\t\t\n \t\ttmake_file=\"${cpu_type}/t-${cpu_type} ${tmake_file}\"\n \t\t;;\n "}, {"sha": "c1a4e738b5508534345fcab25e895cb69ece0335", "filename": "gcc/config/aarch64/aarch64-rust.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Faarch64%2Faarch64-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Faarch64%2Faarch64-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -0,0 +1,126 @@\n+/* Subroutines for the Rust front end on the AArch64 architecture.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rust/rust-target.h\"\n+#include \"rust/rust-target-def.h\"\n+\n+/* Implement TARGET_RUST_CPU_INFO for AArch64 targets.  */\n+\n+void\n+aarch64_rust_target_cpu_info (void)\n+{\n+  rust_add_target_info (\"target_arch\", \"aarch64\");\n+\n+  // TODO: properly change at some point instead of macro def\n+#ifndef isa_flag\n+# define isa_flag aarch64_isa_flags\n+# define isa_flag2 aarch64_isa_flags2\n+//# define fpmath aarch64_fpmath\n+#else\n+# error \"isa_flag and isa_flag2 already defined in aarch64-rust.c - weird things might happen\"\n+#endif\n+  // FIXME: almost feature-complete with rustc, missing \"ras\" feature (which may not be in gcc)\n+\n+  if (TARGET_SIMD) \n+    rust_add_target_info (\"target_feature\", \"neon\");\n+  /* appears to be what is referred to what seems to be referred to\n+  as \"fp-armv8\" in rust, at least in target def, based on closeness of it in aarch64.h to TARGET_SIMD */\n+  if (TARGET_FLOAT) {\n+    rust_add_target_info (\"target_feature\", \"fp-armv8\");\n+    // seems to be translated to \"fp\", but can't tell if \"fp-armv8\" exists too\n+    rust_add_target_info (\"target_feature\", \"fp\");\n+  }\n+  /*if (TARGET_CYCLONE) - need to find this feature (if it exists)\n+    rust_add_target_info (\"target_feature\", \"cyclone\");*/  \n+  /* appears to be what is referred to what seems to be referred to\n+  as \"strict-align\" in rust, at least in target def according to notes in aarch64.h \n+  otherwise strict-align could be STRICT_ALIGNMENT (which evaluates to same thing unless macro redefed) */\n+  if (TARGET_STRICT_ALIGN) \n+    rust_add_target_info (\"target_feature\", \"strict-align\");\n+  // below all derived from llvm code - i'm pretty sure they correspond\n+  if (TARGET_CRC32) \n+    rust_add_target_info (\"target_feature\", \"crc\");\n+  if (TARGET_CRYPTO) \n+    rust_add_target_info (\"target_feature\", \"crypto\");\n+  if (TARGET_DOTPROD) \n+    rust_add_target_info (\"target_feature\", \"dotprod\");\n+  if (TARGET_F16FML) \n+    rust_add_target_info (\"target_feature\", \"fp16fml\");\n+  if (TARGET_FP_F16INST) {\n+    rust_add_target_info (\"target_feature\", \"fullfp16\");\n+    // seems to be translated to \"fp16\", but not sure, so keep that here too\n+    rust_add_target_info (\"target_feature\", \"fp16\");\n+  }\n+  // TODO: some feature relating to profiling with feature name \"spe\" - can't find atm\n+  if (TARGET_LSE)\n+    rust_add_target_info (\"target_feature\", \"lse\");\n+  // hope this is the right thing - llvm calls it \"rdm\" - TODO ensure that it is\n+  if (AARCH64_ISA_RDMA)\n+    rust_add_target_info (\"target_feature\", \"rdm\");\n+  if (TARGET_SVE)\n+    rust_add_target_info (\"target_feature\", \"sve\");\n+  if (TARGET_SVE2)\n+    rust_add_target_info (\"target_feature\", \"sve2\");\n+  if (isa_flag & AARCH64_FL_SVE2_AES)\n+    rust_add_target_info (\"target_feature\", \"sve2-aes\");\n+  if (isa_flag & AARCH64_FL_SVE2_SM4)\n+    rust_add_target_info (\"target_feature\", \"sve2-sm4\");\n+  if (isa_flag & AARCH64_FL_SVE2_SHA3)\n+    rust_add_target_info (\"target_feature\", \"sve2-sha3\");\n+  if (isa_flag & AARCH64_FL_SVE2_BITPERM)\n+    rust_add_target_info (\"target_feature\", \"sve2-bitperm\");\n+  // TODO: assuming that this is the correct RCPC and that the AARCH64_FL_RCPC8_4 is not\n+  if (isa_flag & AARCH64_FL_RCPC)\n+    rust_add_target_info (\"target_feature\", \"rcpc\");\n+  // TODO: find below target features if they exist\n+  /*if (TARGET_ZCM)\n+    rust_add_target_info (\"target_feature\", \"zcm\");*/\n+  /*if (TARGET_ZCZ)\n+    rust_add_target_info (\"target_feature\", \"zcz\");*/\n+  // some possible target features: \"thumb-mode\"\n+  if (TARGET_SM4)\n+    rust_add_target_info (\"target_feature\", \"sm4\");\n+  if (TARGET_SHA3)\n+    rust_add_target_info (\"target_feature\", \"sha3\");\n+  if (TARGET_SHA2)\n+    rust_add_target_info (\"target_feature\", \"sha2\");\n+  if (TARGET_AES)\n+    rust_add_target_info (\"target_feature\", \"aes\");\n+  if (TARGET_TME)\n+    rust_add_target_info (\"target_feature\", \"tme\");\n+  if (TARGET_MEMTAG)\n+    rust_add_target_info (\"target_feature\", \"mte\");\n+\n+  if (AARCH64_ISA_V8_1)\n+    rust_add_target_info (\"target_feature\", \"v8.1a\");\n+  if (AARCH64_ISA_V8_2)\n+    rust_add_target_info (\"target_feature\", \"v8.2a\");\n+  if (AARCH64_ISA_V8_3)\n+    rust_add_target_info (\"target_feature\", \"v8.3a\");\n+  if (AARCH64_ISA_V8_4)\n+    rust_add_target_info (\"target_feature\", \"v8.4a\");\n+  if (AARCH64_ISA_V8_5)\n+    rust_add_target_info (\"target_feature\", \"v8.5a\");\n+    \n+#undef isa_flag\n+#undef isa_flag2\n+//#undef fpmath\n+}"}, {"sha": "a0115a5c7e1e5add17ef9e8c2a2c14b208e906e3", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -29,6 +29,9 @@\n /* Target CPU versions for D.  */\n #define TARGET_D_CPU_VERSIONS aarch64_d_target_versions\n \n+/* Target CPU info for Rust.  */\n+#define TARGET_RUST_CPU_INFO aarch64_rust_target_cpu_info\n+\n \f\n \n #define REGISTER_TARGET_PRAGMAS() aarch64_register_pragmas ()"}, {"sha": "c4a2296910e9fd3833057ba1727cda37dfabeefc", "filename": "gcc/config/aarch64/t-aarch64", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -118,6 +118,10 @@ aarch64-d.o: $(srcdir)/config/aarch64/aarch64-d.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+aarch64-rust.o: $(srcdir)/config/aarch64/aarch64-rust.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n PASSES_EXTRA += $(srcdir)/config/aarch64/aarch64-passes.def\n \n cortex-a57-fma-steering.o: $(srcdir)/config/aarch64/cortex-a57-fma-steering.c \\"}, {"sha": "8748c53a6aef91e726a81cf2d5f775fb70dabc4f", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -112,6 +112,9 @@ extern bool some_small_symbolic_operand_int (rtx);\n extern int tls_symbolic_operand_1 (rtx, int, int);\n extern rtx resolve_reload_operand (rtx);\n \n+/* Declare functions in alpha-rust.c  */\n+extern void alpha_rust_target_cpu_info (void);\n+\n namespace gcc { class context; }\n class rtl_opt_pass;\n "}, {"sha": "48f03a52fd49efef0542e70845ac7cd2a298205f", "filename": "gcc/config/alpha/alpha-rust.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Falpha-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Falpha-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -0,0 +1,44 @@\n+/* Subroutines for the Rust front end on the DEC Alpha.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rust/rust-target.h\"\n+#include \"rust/rust-target-def.h\"\n+\n+/* Implement TARGET_RUST_CPU_INFO for DEC Alpha targets.  */\n+\n+void\n+alpha_rust_target_cpu_info (void)\n+{\n+  /* i couldn't actually confirm that this was the arch name (removed from llvm and no rustc support),\n+   * but i don't think they would choose something different to gcc */\n+  rust_add_target_info (\"target_arch\", \"alpha\");\n+\n+  // CIX was actually the only llvm option available when it was removed, but adding other gcc ones\n+  if (TARGET_CIX)\t\n+    rust_add_target_info (\"target_feature\", \"cix\");\t\n+  if (TARGET_FIX)\t\n+    rust_add_target_info (\"target_feature\", \"fix\");\t\n+  if (TARGET_BWX)\t\n+    rust_add_target_info (\"target_feature\", \"bwx\");\t\n+  // may be called \"mvi\" under rustc (but they have no support for it atm, so who cares amirite?)\n+  if (TARGET_MAX)\t\n+    rust_add_target_info (\"target_feature\", \"max\");\t\n+}"}, {"sha": "d35db6e89db17e729ab2b70432e9640e6db20366", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -94,6 +94,9 @@ along with GCC; see the file COPYING3.  If not see\n   while (0)\n #endif\n \n+/* Target CPU info for Rust.  */\n+#define TARGET_RUST_CPU_INFO alpha_rust_target_cpu_info\n+\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n /* Which processor to schedule for. The cpu attribute defines a list that"}, {"sha": "6820af91608b7d7ccee57a4dd4af202c69737afc", "filename": "gcc/config/alpha/t-alpha", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Ft-alpha", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Falpha%2Ft-alpha", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-alpha?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -17,3 +17,7 @@\n # <http://www.gnu.org/licenses/>.\n \n PASSES_EXTRA += $(srcdir)/config/alpha/alpha-passes.def\n+\n+alpha-rust.o: $(srcdir)/config/alpha/alpha-rust.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)"}, {"sha": "cfe7e321f1c3be217b7b4f72a4644b2323d86edd", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -110,5 +110,8 @@ extern bool arc_is_jli_call_p (rtx);\n extern void arc_file_end (void);\n extern bool arc_is_secure_call_p (rtx);\n \n+/* Declare functions in arc-rust.c  */\n+extern void arc_rust_target_cpu_info (void);\n+\n rtl_opt_pass * make_pass_arc_ifcvt (gcc::context *ctxt);\n rtl_opt_pass * make_pass_arc_predicate_delay_insns (gcc::context *ctxt);"}, {"sha": "ab5fd62beb7c83f6b06998edf32e3ea15a40c667", "filename": "gcc/config/arc/arc-rust.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Farc-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Farc-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -0,0 +1,104 @@\n+/* Subroutines for the Rust front end on the Synopsys DesignWare ARC cpu.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rust/rust-target.h\"\n+#include \"rust/rust-target-def.h\"\n+\n+/* Implement TARGET_RUST_CPU_INFO for Synopsys DesignWare ARC targets.  */\n+\n+void\n+arc_rust_target_cpu_info (void)\n+{\n+  rust_add_target_info (\"target_arch\", \"arc\");\n+\n+  /* in llvm, the arc target has no \"subtargets\" (features according to rustc) as far as I can tell\n+   * gcc has a bunch of target macros that look like they could represent features, which I've added\n+   * provisionally. TODO add and rename features based on llvm. */\n+  if (TARGET_NORM)\n+    rust_add_target_info (\"target_feature\", \"norm\");\n+  if (TARGET_OPTFPE)\n+    rust_add_target_info (\"target_feature\", \"optfpe\");\n+  if (TARGET_SWAP)\n+    rust_add_target_info (\"target_feature\", \"swap\");\n+\n+  if (TARGET_UNALIGN_BRANCH)\n+    rust_add_target_info (\"target_feature\", \"unalign-branch\");\n+  if (TARGET_PAD_RETURN)\n+    rust_add_target_info (\"target_feature\", \"pad-return\");\n+  if (TARGET_AT_DBR_CONDEXEC)\n+    rust_add_target_info (\"target_feature\", \"at-dbr-condexec\");\n+\n+  // TODO: maybe define different cpu types? \n+\n+  // TODO: are all these below needed and useful?\n+  if (TARGET_MPYW)\n+    rust_add_target_info (\"target_feature\", \"mpyw\");\n+  if (TARGET_MULTI)\n+    rust_add_target_info (\"target_feature\", \"multi\");\n+  if (TARGET_MPY)\n+    rust_add_target_info (\"target_feature\", \"mpy\");\n+  if (TARGET_ARC700_MPY)\n+    rust_add_target_info (\"target_feature\", \"arc700-mpy\");\n+  if (TARGET_ANY_MPY)\n+    rust_add_target_info (\"target_feature\", \"any-mpy\");\n+  if (TARGET_PLUS_DMPY)\n+    rust_add_target_info (\"target_feature\", \"plus-dmpy\");\n+  if (TARGET_PLUS_MACD)\n+    rust_add_target_info (\"target_feature\", \"plus-macd\");\n+  if (TARGET_PLUS_QMACW)\n+    rust_add_target_info (\"target_feature\", \"plus-qmacw\");\n+  if (TARGET_LP_WR_INTERLOCK)\n+    rust_add_target_info (\"target_feature\", \"lp-wr-interlock\");\n+\n+  // TODO: should different cpu families be removed?\n+  if (TARGET_ARC600_FAMILY)\n+    rust_add_target_info (\"target_feature\", \"arc600-family\");\n+  if (TARGET_ARCOMPACT_FAMILY)\n+    rust_add_target_info (\"target_feature\", \"arcompact-family\");\n+\n+  if (TARGET_HARD_FLOAT)\n+    rust_add_target_info (\"target_feature\", \"hard-float\");\n+  if (TARGET_FP_SP_BASE)\n+    rust_add_target_info (\"target_feature\", \"fp-sp-base\");\n+  if (TARGET_FP_DP_BASE)\n+    rust_add_target_info (\"target_feature\", \"fp-dp-base\");\n+  if (TARGET_FP_SP_FUSED)\n+    rust_add_target_info (\"target_feature\", \"fp-sp-fused\");\n+  if (TARGET_FP_DP_FUSED)\n+    rust_add_target_info (\"target_feature\", \"fp-dp-fused\");\n+  if (TARGET_FP_SP_CONV)\n+    rust_add_target_info (\"target_feature\", \"fp-sp-conv\");\n+  if (TARGET_FP_DP_CONV)\n+    rust_add_target_info (\"target_feature\", \"fp-dp-conv\");\n+  if (TARGET_FP_SP_SQRT)\n+    rust_add_target_info (\"target_feature\", \"fp-sp-sqrt\");\n+  if (TARGET_FP_DP_SQRT)\n+    rust_add_target_info (\"target_feature\", \"fp-dp-sqrt\");\n+  if (TARGET_FP_DP_AX)\n+    rust_add_target_info (\"target_feature\", \"fp-dp-ax\");\n+  if (TARGET_FPX_QUARK)\n+    rust_add_target_info (\"target_feature\", \"fpx-quark\");\n+  if (TARGET_DBNZ)\n+    rust_add_target_info (\"target_feature\", \"dbnz\");\n+  \n+  if (TARGET_BI_BIH)\n+    rust_add_target_info (\"target_feature\", \"bi-bih\");\n+}"}, {"sha": "838f4eb4f4d5d193f2f471da0ef078a15e67e1aa", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -52,6 +52,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Names to predefine in the preprocessor for this target machine.  */\n #define TARGET_CPU_CPP_BUILTINS() arc_cpu_cpp_builtins (pfile)\n \n+/* CPU info for Rust for this target machine.  */\n+#define TARGET_RUST_CPU_INFO arc_rust_target_cpu_info\n+\n /* Macros enabled by specific command line option.  FIXME: to be\n    deprecatd.  */\n #define CPP_SPEC \"\\"}, {"sha": "da2e0e33f3a9d1d0ae157e644f22bd9dbe66195e", "filename": "gcc/config/arc/t-arc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Ft-arc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farc%2Ft-arc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Ft-arc?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -28,6 +28,11 @@ $(TREE_H) $(TM_H) $(TM_P_H) coretypes.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/arc/arc-c.c\n \n+arc-rust.o: $(srcdir)/config/arc/arc-rust.c $(CONFIG_H) $(SYSTEM_H) \\\n+$(TREE_H) $(TM_H) $(TM_P_H) coretypes.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/arc/arc-rust.c\n+\n #Run `arc-cpus` if you changed something in arc-cpus.def\n \n .PHONY: arc-cpus"}, {"sha": "6e5a220ad5f4a9d2fb7dddf374892d63bfeea261", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -398,6 +398,9 @@ extern void arm_cpu_cpp_builtins (struct cpp_reader *);\n /* Defined in arm-d.c  */\n extern void arm_d_target_versions (void);\n \n+/* Defined in arm-rust.c  */\n+extern void arm_rust_target_cpu_info (void);\n+\n extern bool arm_is_constant_pool_ref (rtx);\n \n /* The bits in this mask specify which instruction scheduling options should"}, {"sha": "7c83e3fa3a64b2f2bb9849edee3dbb290173bd8f", "filename": "gcc/config/arm/arm-rust.c", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Farm-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Farm-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -0,0 +1,304 @@\n+/* Subroutines for the Rust front end on the ARM architecture.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tm_p.h\"\n+#include \"rust/rust-target.h\"\n+#include \"rust/rust-target-def.h\"\n+\n+/* Implement TARGET_RUST_CPU_INFO for ARM targets.  */\n+\n+void arm_rust_target_cpu_info(void) {\n+    rust_add_target_info(\"target_arch\", \"arm\");\n+\n+    /* TODO: further research support for CLREX, acquire-release (lda/ldaex), slow-fp-brcc (slow FP\n+     * compare and branch), perfmon, trustzone, fpao, fuse-aes, fuse-literals, read-tp-hard, zcz,\n+     * prof-unpr, slow-vgetlni32, slow-vdup32, prefer-vmovsr, prefer-ishst, muxed-units, slow-odd-reg,\n+     * slow-load-D-subreg, wide-stride-vfp, dont-widen-vmovs, splat-vfp-neon, expand-fp-mlx,\n+     * vmlx-hazards, neon-fpmovs, neonfp (as in using neon for scalar fp), vldn-align,\n+     * nonpipelined-vfp, slowfpvmlx, slowfpvfmx, vmlx-forwarding, 32bit (prefer 32-bit Thumb),\n+     * loop-align, mve1beat, mve2beat, mve4beat, avoid-partial-cpsr, cheap-predictable-cpsr,\n+     * avoid-movs-shop, ret-addr-stack, no-branch-predictor, virtualization, nacl-trap, execute-only,\n+     * reserve-r9, no-movt, no-neg-immediates, use-misched, disable-postra-scheduler, lob (Low\n+     * Overhead Branch), noarm, cde - can't find them. */\n+    /* TODO: figure out if gcc has an equivalent to \"fpregs\" (floating-point registers even if only\n+     * used for integer - shared between VFP and MVE).  */\n+    if (TARGET_VFPD32)\n+        rust_add_target_info(\"target_feature\", \"d32\");\n+    bool hasFeatureVFP2 = bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2) && TARGET_VFP_DOUBLE;\n+    if (hasFeatureVFP2) {\n+        rust_add_target_info(\"target_feature\", \"vfp2\");\n+\n+        // also added implied features that aren't separately supported in gcc\n+        rust_add_target_info(\"target_feature\", \"vfp2sp\");\n+    }\n+    // minimal VFPv3 support - support for instruction set, not necessarily full\n+    bool minVFP3 = TARGET_VFP3 && bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv2);\n+    if (minVFP3) {\n+        rust_add_target_info(\"target_feature\", \"vfp3d16sp\");\n+\n+        if (TARGET_VFPD32)\n+            rust_add_target_info(\"target_feature\", \"vfp3sp\");\n+\n+        if (TARGET_VFP_DOUBLE) {\n+            rust_add_target_info(\"target_feature\", \"vfp3d16\");\n+\n+            if (TARGET_VFPD32) {\n+                rust_add_target_info(\"target_feature\", \"vfp3\");\n+\n+                if (bitmap_bit_p(arm_active_target.isa, isa_bit_neon))\n+                    rust_add_target_info(\"target_feature\", \"neon\");\n+            }\n+        }\n+    }\n+    bool hasFeatureVFP3 = minVFP3 && TARGET_VFP_DOUBLE && TARGET_VFPD32;\n+    bool hasFeatureFP16 = bitmap_bit_p(arm_active_target.isa, isa_bit_fp16conv);\n+    if (hasFeatureFP16)\n+        rust_add_target_info(\"target_info\", \"fp16\");\n+    bool minVFP4 = minVFP3 && bitmap_bit_p(arm_active_target.isa, isa_bit_vfpv4) && hasFeatureFP16;\n+    if (minVFP4) {\n+        rust_add_target_info(\"target_feature\", \"vfp4d16sp\");\n+\n+        if (TARGET_VFPD32)\n+            rust_add_target_info(\"target_feature\", \"vfp4sp\");\n+\n+        if (TARGET_VFP_DOUBLE) {\n+            rust_add_target_info(\"target_feature\", \"vfp4d16\");\n+\n+            if (TARGET_VFPD32) {\n+                rust_add_target_info(\"target_feature\", \"vfp4\");\n+            }\n+        }\n+    }\n+    // NOTE: supposedly \"fp-armv8\" features in llvm are the same as \"fpv5\", so creating them based on\n+    // that\n+    bool minFP_ARMv8 = minVFP4 && TARGET_VFP5;\n+    if (minFP_ARMv8) {\n+        rust_add_target_info(\"target_feature\", \"fp-armv8d16sp\");\n+\n+        if (TARGET_VFPD32)\n+            rust_add_target_info(\"target_feature\", \"fp-armv8sp\");\n+\n+        if (TARGET_VFP_DOUBLE) {\n+            rust_add_target_info(\"target_feature\", \"fp-armv8d16\");\n+\n+            if (TARGET_VFPD32) {\n+                rust_add_target_info(\"target_feature\", \"fp-armv8\");\n+            }\n+        }\n+\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16)) {\n+            rust_add_target_info(\"target_feature\", \"fullfp16\");\n+\n+            if (bitmap_bit_p(arm_active_target.isa, isa_bit_fp16fml))\n+                rust_add_target_info(\"target_feature\", \"fp16fml\");\n+        }\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_tdiv))\n+        rust_add_target_info(\"target_feature\", \"hwdiv\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_adiv))\n+        rust_add_target_info(\"target_feature\", \"hwdiv-arm\");\n+    // TODO: I'm not sure if there's an exact correlation here (data barrier), so maybe research\n+    // There's also the question of whether this also means \"full data barrier\" (\"fdb\" in llvm)\n+    if (TARGET_HAVE_MEMORY_BARRIER)\n+        rust_add_target_info(\"target_feature\", \"db\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cmse))\n+        rust_add_target_info(\"target_feature\", \"8msecext\");\n+    /* TODO: note that sha2 is an option for aarch64 in gcc but not for arm, so no feature here\n+     * possible. The same goes for aes. However, as llvm has them as prerequisites for crypto, they\n+     * are enabled with it. */\n+    if (TARGET_CRYPTO) {\n+        rust_add_target_info(\"target_feature\", \"crypto\");\n+        rust_add_target_info(\"target_feature\", \"sha2\");\n+        rust_add_target_info(\"target_feature\", \"aes\");\n+    }\n+    if (TARGET_CRC32)\n+        rust_add_target_info(\"target_feature\", \"crc\");\n+    if (TARGET_DOTPROD)\n+        rust_add_target_info(\"target_feature\", \"dotprod\");\n+    // TODO: supposedly gcc supports RAS, but I couldn't find the option, so leaving out \"ras\" for now\n+    if (TARGET_DSP_MULTIPLY)\n+        rust_add_target_info(\"target_feature\", \"dsp\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_mp))\n+        rust_add_target_info(\"target_feature\", \"mp\");\n+    // TODO: figure out the exact strict-align feature, which I'm pretty sure GCC has\n+    // TODO: figure out how to access long call data (which is in GCC) for \"long-calls\"\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_sb))\n+        rust_add_target_info(\"target_feature\", \"sb\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_bf16))\n+        rust_add_target_info(\"target_feature\", \"bf16\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_i8mm))\n+        rust_add_target_info(\"target_feature\", \"i8mm\");\n+    switch (TARGET_ARM_ARCH_PROFILE) {\n+        case 'A':\n+            rust_add_target_info(\"target_feature\", \"aclass\");\n+            break;\n+        case 'R':\n+            rust_add_target_info(\"target_feature\", \"rclass\");\n+            break;\n+        case 'M':\n+            rust_add_target_info(\"target_feature\", \"mclass\");\n+            break;\n+        default:\n+            fprintf(stderr, \"Screwed up profile selection in arm-rust.c - unknown profile '%c'\",\n+              TARGET_ARM_ARCH_PROFILE);\n+            break;\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_thumb2))\n+        rust_add_target_info(\"target_feature\", \"thumb2\");\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv4)\n+        && bitmap_bit_p(arm_active_target.isa, isa_bit_notm)\n+        && bitmap_bit_p(arm_active_target.isa, isa_bit_thumb)) {\n+        rust_add_target_info(\"target_feature\", \"v4t\");\n+\n+        if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv5t)) {\n+            rust_add_target_info(\"target_feature\", \"v5t\");\n+\n+            if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv5te)) {\n+                rust_add_target_info(\"target_feature\", \"v5te\");\n+\n+                if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv6)\n+                    && bitmap_bit_p(arm_active_target.isa, isa_bit_be8)) {\n+                    rust_add_target_info(\"target_feature\", \"v6\");\n+\n+                    // note: this definition of \"ARMv6m\" listed as \"suspect\" in arm-cpus.in\n+                    rust_add_target_info(\"target_feature\", \"v6m\");\n+\n+                    bool hasV8BaselineOps = bitmap_bit_p(arm_active_target.isa, isa_bit_armv8)\n+                                            && bitmap_bit_p(arm_active_target.isa, isa_bit_cmse)\n+                                            && bitmap_bit_p(arm_active_target.isa, isa_bit_tdiv);\n+                    if (hasV8BaselineOps)\n+                        rust_add_target_info(\"target_feature\", \"v8m\");\n+\n+                    bool hasV6kOps = bitmap_bit_p(arm_active_target.isa, isa_bit_armv6k);\n+                    if (hasV6kOps) {\n+                        rust_add_target_info(\"target_feature\", \"v6k\");\n+                    }\n+\n+                    if (bitmap_bit_p(arm_active_target.isa, isa_bit_thumb2) && hasV8BaselineOps\n+                        && hasV6kOps) {\n+                        rust_add_target_info(\"target_feature\", \"v6t2\");\n+\n+                        // note that arm-cpus.in refers to this (ARMv7) as suspect\n+                        if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv7)) {\n+                            rust_add_target_info(\"target_feature\", \"v7\");\n+\n+                            rust_add_target_info(\"target_feature\", \"v8m.main\");\n+\n+                            if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_1m_main))\n+                                rust_add_target_info(\"target_feature\", \"v8.1m.main\");\n+\n+                            // dummy: can't find feature acquire-release, so dummy true variable\n+                            bool hasAcquireRelease = true;\n+                            if (hasAcquireRelease && bitmap_bit_p(arm_active_target.isa, isa_bit_adiv)\n+                                && bitmap_bit_p(arm_active_target.isa, isa_bit_lpae)\n+                                && bitmap_bit_p(arm_active_target.isa, isa_bit_mp)\n+                                && bitmap_bit_p(arm_active_target.isa, isa_bit_sec)) {\n+                                rust_add_target_info(\"target_feature\", \"v8\");\n+\n+                                if (TARGET_CRC32\n+                                    && bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_1)) {\n+                                    rust_add_target_info(\"target_feature\", \"v8.1a\");\n+\n+                                    if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_2)) {\n+                                        rust_add_target_info(\"target_feature\", \"v8.2a\");\n+\n+                                        if (bitmap_bit_p(arm_active_target.isa, isa_bit_armv8_3)) {\n+                                            rust_add_target_info(\"target_feature\", \"v8.3a\");\n+\n+                                            if (bitmap_bit_p(\n+                                                  arm_active_target.isa, isa_bit_armv8_4)) {\n+                                                rust_add_target_info(\"target_feature\", \"v8.4a\");\n+                                                // note: llvm, but not gcc, also wants dotprod for\n+                                                // v8.4\n+\n+                                                if (bitmap_bit_p(arm_active_target.isa, isa_bit_sb)\n+                                                    && bitmap_bit_p(\n+                                                      arm_active_target.isa, isa_bit_predres)\n+                                                    && bitmap_bit_p(\n+                                                      arm_active_target.isa, isa_bit_armv8_5)) {\n+                                                    rust_add_target_info(\"target_feature\", \"v8.5a\");\n+\n+                                                    if (bitmap_bit_p(\n+                                                          arm_active_target.isa, isa_bit_armv8_6))\n+                                                        rust_add_target_info(\n+                                                          \"target_feature\", \"v8.6a\");\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_mve)\n+        && bitmap_bit_p(arm_active_target.isa, isa_bit_vfp_base)\n+        && bitmap_bit_p(arm_active_target.isa, isa_bit_armv7em)) {\n+        rust_add_target_info(\"target_feature\", \"mve\");\n+\n+        if (minFP_ARMv8 && bitmap_bit_p(arm_active_target.isa, isa_bit_fp16)\n+            && bitmap_bit_p(arm_active_target.isa, isa_bit_mve_float))\n+            rust_add_target_info(\"target_feature\", \"mve.fp\");\n+    }\n+    // Note: no direct option for \"cde\" found, but it is implicitly activated via cdecpx, so do it\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp0)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp0\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp1)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp1\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp2)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp2\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp3)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp3\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp4)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp4\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp5)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp5\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp6)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp6\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (bitmap_bit_p(arm_active_target.isa, isa_bit_cdecp7)) {\n+        rust_add_target_info(\"target_feature\", \"cdecp7\");\n+        rust_add_target_info(\"target_feature\", \"cde\");\n+    }\n+    if (TARGET_SOFT_FLOAT)\n+        rust_add_target_info(\"target_feature\", \"soft-float\");\n+    // should be correct option (i.e. thumb mode rather than just thumb-aware) as TARGET_ARM is\n+    // inverse\n+    if (TARGET_THUMB)\n+        rust_add_target_info(\"target_feature\", \"thumb-mode\");\n+    // TODO: consider doing the processors as target features, but honestly they don't seem to fit\n+}"}, {"sha": "8ea4c7f773134d74b255e5c85fc962ae436f382b", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -50,6 +50,9 @@ extern char arm_arch_name[];\n /* Target CPU versions for D.  */\n #define TARGET_D_CPU_VERSIONS arm_d_target_versions\n \n+/* Target CPU info for Rust.  */\n+#define TARGET_RUST_CPU_INFO arm_rust_target_cpu_info\n+\n #include \"config/arm/arm-opts.h\"\n \n /* The processor for which instructions should be scheduled.  */"}, {"sha": "de70aea5944b4a042163ee8d9afba68c4004336d", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -162,6 +162,10 @@ arm-d.o: $(srcdir)/config/arm/arm-d.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+arm-rust.o: $(srcdir)/config/arm/arm-rust.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n arm-common.o: arm-cpu-cdata.h\n \n driver-arm.o: arm-native.h"}, {"sha": "2ac1ecab2c2dcce4617246005943f9a0d880a0b4", "filename": "gcc/config/default-rust.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fdefault-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fdefault-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdefault-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -0,0 +1,26 @@\n+/* Default Rust language target hooks initializer.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"memmodel.h\"\n+#include \"tm_rust.h\"\n+#include \"rust/rust-target.h\"\n+#include \"rust/rust-target-def.h\"\n+\n+struct gcc_targetrustm targetrustm = TARGETRUSTM_INITIALIZER;"}, {"sha": "f092d90cb810cc6cc0a4f57769f7529bd7da4b82", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -265,6 +265,9 @@ extern void ix86_register_pragmas (void);\n /* In i386-d.c  */\n extern void ix86_d_target_versions (void);\n \n+/* In i386-rust.c  */\n+extern void ix86_rust_target_cpu_info (void);\n+\n /* In winnt.c  */\n extern void i386_pe_unique_section (tree, int);\n extern void i386_pe_declare_function_type (FILE *, const char *, int);"}, {"sha": "86a1842f60d48ece80b722427d59662e72317fca", "filename": "gcc/config/i386/i386-rust.c", "status": "modified", "additions": 92, "deletions": 76, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fi386%2Fi386-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fi386%2Fi386-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -22,9 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rust/rust-target.h\"\n #include \"rust/rust-target-def.h\"\n \n-// FIXME: remove: this is only here to make intellisense happy\n-#include \"i386.h\"\n-\n // HACK: allows conversion of (presumably) numeric values to string\n #ifndef STR_HELPER_RUST\n  #define STR_HELPER_RUST(x) #x\n@@ -47,12 +44,13 @@ ix86_rust_target_cpu_info (void)\n         rust_add_target_info(\"target_arch\", \"x86_64\");\n \n         // TODO: should these go here or is there a platform-neutral way of getting them (since they aren't defined in i386-c.c or i386-d.c)?\n-        rust_add_target_info(\"target_pointer_width\", STRINGIFY_RUST(POINTER_SIZE));\n-        rust_add_target_info(\"target_endian\", BYTES_BIG_ENDIAN ? \"big\" : \"little\");\n+        //rust_add_target_info(\"target_pointer_width\", STRINGIFY_RUST(POINTER_SIZE)); // this did not work\n+        //rust_add_target_info(\"target_endian\", BYTES_BIG_ENDIAN ? \"big\" : \"little\");\n+        // there is a platform-neutral way actually, I'm pretty sure - see cppbuiltins.c\n \n         if (TARGET_X32) {\n             // this means it uses 32-bit pointers with 64-bit, basically (ILP32)\n-            rust_add_target_info(\"target_pointer_width\", \"32\");\n+            //rust_add_target_info(\"target_pointer_width\", \"32\");\n             // TODO: may also change x86_64-...-linux-gnu to x86_64-...-linux-gnux32\n \n             // is this better than just putting in pointer width outside of if statement?\n@@ -71,16 +69,26 @@ ix86_rust_target_cpu_info (void)\n \n     // note: options that don't seem to have a target feature in rust are commented out\n \n-    if (isa_flag2 & OPTION_MASK_ISA_WBNOINVD)\n-    //def_or_undef (parse_in, \"__WBNOINVD__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_AVX512VP2INTERSECT)\n-    //def_or_undef (parse_in, \"__AVX512VP2INTERSECT__\");\n+    // TODO: properly change at some point instead of macro def\n+#ifndef isa_flag\n+# define isa_flag ix86_isa_flags\n+# define isa_flag2 ix86_isa_flags2\n+# define fpmath ix86_fpmath\n+#else\n+# error \"isa_flag and isa_flag2 already defined in i386-rust.c - weird things might happen\"\n+#endif\n+\n+    // options should be feature complete for rustc atm\n+  if (isa_flag2 & OPTION_MASK_ISA2_WBNOINVD)\n+    ; //def_or_undef (parse_in, \"__WBNOINVD__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_AVX512VP2INTERSECT)\n+    ; //def_or_undef (parse_in, \"__AVX512VP2INTERSECT__\");\n   if (isa_flag & OPTION_MASK_ISA_MMX)\n     rust_add_target_info(\"target_feature\", \"mmx\");\n   if (isa_flag & OPTION_MASK_ISA_3DNOW)\n-    //def_or_undef (parse_in, \"__3dNOW__\");\n+    ; //def_or_undef (parse_in, \"__3dNOW__\");\n   if (isa_flag & OPTION_MASK_ISA_3DNOW_A)\n-    //def_or_undef (parse_in, \"__3dNOW_A__\");\n+    ; //def_or_undef (parse_in, \"__3dNOW_A__\");\n   if (isa_flag & OPTION_MASK_ISA_SSE)\n     rust_add_target_info(\"target_feature\", \"sse\");\n   if (isa_flag & OPTION_MASK_ISA_SSE2)\n@@ -98,139 +106,147 @@ ix86_rust_target_cpu_info (void)\n   if (isa_flag & OPTION_MASK_ISA_SHA)\n     rust_add_target_info(\"target_feature\", \"sha\");\n   if (isa_flag & OPTION_MASK_ISA_PCLMUL)\n-    //def_or_undef (parse_in, \"__PCLMUL__\");\n+    ; //def_or_undef (parse_in, \"__PCLMUL__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX)\n     rust_add_target_info(\"target_feature\", \"avx\");\n   if (isa_flag & OPTION_MASK_ISA_AVX2)\n     rust_add_target_info(\"target_feature\", \"avx2\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512F)\n-    //def_or_undef (parse_in, \"__AVX512F__\");\n+    rust_add_target_info(\"target_feature\", \"avx512f\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512ER)\n-    //def_or_undef (parse_in, \"__AVX512ER__\");\n+    rust_add_target_info(\"target_feature\", \"avx512er\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512CD)\n-    //def_or_undef (parse_in, \"__AVX512CD__\");\n+    rust_add_target_info(\"target_feature\", \"avx512cd\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512PF)\n-    //def_or_undef (parse_in, \"__AVX512PF__\");\n+    rust_add_target_info(\"target_feature\", \"avx512pf\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512DQ)\n-    //def_or_undef (parse_in, \"__AVX512DQ__\");\n+    rust_add_target_info(\"target_feature\", \"avx512dq\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512BW)\n-    //def_or_undef (parse_in, \"__AVX512BW__\");\n+    rust_add_target_info(\"target_feature\", \"avx512bw\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512VL)\n-    //def_or_undef (parse_in, \"__AVX512VL__\");\n+    rust_add_target_info(\"target_feature\", \"avx512vl\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512VBMI)\n-    //def_or_undef (parse_in, \"__AVX512VBMI__\");\n+    rust_add_target_info(\"target_feature\", \"avx512vbmi\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512IFMA)\n-    //def_or_undef (parse_in, \"__AVX512IFMA__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_AVX5124VNNIW)\n-    //def_or_undef (parse_in, \"__AVX5124VNNIW__\");\n+    rust_add_target_info(\"target_feature\", \"avx512ifma\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_AVX5124VNNIW)\n+    ; //def_or_undef (parse_in, \"__AVX5124VNNIW__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512VBMI2)\n-    //def_or_undef (parse_in, \"__AVX512VBMI2__\");\n+    ; //def_or_undef (parse_in, \"__AVX512VBMI2__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512VNNI)\n-    //def_or_undef (parse_in, \"__AVX512VNNI__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_PCONFIG)\n-    //def_or_undef (parse_in, \"__PCONFIG__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_SGX)\n-    //def_or_undef (parse_in, \"__SGX__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_AVX5124FMAPS)\n-    //def_or_undef (parse_in, \"__AVX5124FMAPS__\");\n+    ; //def_or_undef (parse_in, \"__AVX512VNNI__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_PCONFIG)\n+    ; //def_or_undef (parse_in, \"__PCONFIG__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_SGX)\n+    ; //def_or_undef (parse_in, \"__SGX__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_AVX5124FMAPS)\n+    ; //def_or_undef (parse_in, \"__AVX5124FMAPS__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512BITALG)\n-    //def_or_undef (parse_in, \"__AVX512BITALG__\");\n+    ; //def_or_undef (parse_in, \"__AVX512BITALG__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX512VPOPCNTDQ)\n-    //def_or_undef (parse_in, \"__AVX512VPOPCNTDQ__\");\n+    rust_add_target_info(\"target_feature\", \"avx512vpopcntdq\");\n   if (isa_flag & OPTION_MASK_ISA_FMA)\n     rust_add_target_info(\"target_feature\", \"fma\");\n   if (isa_flag & OPTION_MASK_ISA_RTM)\n-    //def_or_undef (parse_in, \"__RTM__\");\n+    rust_add_target_info(\"target_feature\", \"rtm\");\n   if (isa_flag & OPTION_MASK_ISA_SSE4A)\n-    //def_or_undef (parse_in, \"__SSE4A__\");\n+    rust_add_target_info(\"target_feature\", \"sse4a\");\n   if (isa_flag & OPTION_MASK_ISA_FMA4)\n-    //def_or_undef (parse_in, \"__FMA4__\");\n+    ; //def_or_undef (parse_in, \"__FMA4__\");\n   if (isa_flag & OPTION_MASK_ISA_XOP)\n-    //def_or_undef (parse_in, \"__XOP__\");\n+    ; //def_or_undef (parse_in, \"__XOP__\");\n   if (isa_flag & OPTION_MASK_ISA_LWP)\n-    //def_or_undef (parse_in, \"__LWP__\");\n+    ; //def_or_undef (parse_in, \"__LWP__\");\n   if (isa_flag & OPTION_MASK_ISA_ABM)\n-    //def_or_undef (parse_in, \"__ABM__\");\n+    ; //def_or_undef (parse_in, \"__ABM__\");\n   if (isa_flag & OPTION_MASK_ISA_BMI)\n     rust_add_target_info(\"target_feature\", \"bmi1\");\n   if (isa_flag & OPTION_MASK_ISA_BMI2)\n     rust_add_target_info(\"target_feature\", \"bmi2\");\n   if (isa_flag & OPTION_MASK_ISA_LZCNT)\n     rust_add_target_info(\"target_feature\", \"lzcnt\");\n   if (isa_flag & OPTION_MASK_ISA_TBM)\n-    //def_or_undef (parse_in, \"__TBM__\");\n+    rust_add_target_info(\"target_feature\", \"tbm\");\n   if (isa_flag & OPTION_MASK_ISA_POPCNT)\n     rust_add_target_info(\"target_feature\", \"popcnt\");\n   if (isa_flag & OPTION_MASK_ISA_FSGSBASE)\n-    //def_or_undef (parse_in, \"__FSGSBASE__\");\n+    ; //def_or_undef (parse_in, \"__FSGSBASE__\");\n   if (isa_flag & OPTION_MASK_ISA_RDRND)\n     rust_add_target_info(\"target_feature\", \"rdrand\");\n   if (isa_flag & OPTION_MASK_ISA_F16C)\n-    //def_or_undef (parse_in, \"__F16C__\");\n+    rust_add_target_info(\"target_feature\", \"f16c\");\n   if (isa_flag & OPTION_MASK_ISA_RDSEED)\n     rust_add_target_info(\"target_feature\", \"rdseed\");\n   if (isa_flag & OPTION_MASK_ISA_PRFCHW)\n-    //def_or_undef (parse_in, \"__PRFCHW__\");\n+    ; //def_or_undef (parse_in, \"__PRFCHW__\");\n   if (isa_flag & OPTION_MASK_ISA_ADX)\n-    //def_or_undef (parse_in, \"__ADX__\");\n+    rust_add_target_info(\"target_feature\", \"adx\");\n   if (isa_flag & OPTION_MASK_ISA_FXSR)\n     rust_add_target_info(\"target_feature\", \"fxsr\");\n   if (isa_flag & OPTION_MASK_ISA_XSAVE)\n     rust_add_target_info(\"target_feature\", \"xsave\");\n   if (isa_flag & OPTION_MASK_ISA_XSAVEOPT)\n     rust_add_target_info(\"target_feature\", \"xsaveopt\");\n   if (isa_flag & OPTION_MASK_ISA_PREFETCHWT1)\n-    //def_or_undef (parse_in, \"__PREFETCHWT1__\");\n+    ; //def_or_undef (parse_in, \"__PREFETCHWT1__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE))\n-    //def_or_undef (parse_in, \"__SSE_MATH__\");\n+    ; //def_or_undef (parse_in, \"__SSE_MATH__\");\n   if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))\n-    //def_or_undef (parse_in, \"__SSE2_MATH__\");\n+    ; //def_or_undef (parse_in, \"__SSE2_MATH__\");\n   if (isa_flag & OPTION_MASK_ISA_CLFLUSHOPT)\n-    //def_or_undef (parse_in, \"__CLFLUSHOPT__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_CLZERO)\n-    //def_or_undef (parse_in, \"__CLZERO__\");\n+    ; //def_or_undef (parse_in, \"__CLFLUSHOPT__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_CLZERO)\n+    ; //def_or_undef (parse_in, \"__CLZERO__\");\n   if (isa_flag & OPTION_MASK_ISA_XSAVEC)\n     rust_add_target_info(\"target_feature\", \"xsavec\");\n   if (isa_flag & OPTION_MASK_ISA_XSAVES)\n     rust_add_target_info(\"target_feature\", \"xsaves\");\n   if (isa_flag & OPTION_MASK_ISA_CLWB)\n-    //def_or_undef (parse_in, \"__CLWB__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_MWAITX)\n-    //def_or_undef (parse_in, \"__MWAITX__\");\n+    ; //def_or_undef (parse_in, \"__CLWB__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_MWAITX)\n+    ; //def_or_undef (parse_in, \"__MWAITX__\");\n   if (isa_flag & OPTION_MASK_ISA_PKU)\n-    //def_or_undef (parse_in, \"__PKU__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_RDPID)\n-    //def_or_undef (parse_in, \"__RDPID__\");\n+    ; //def_or_undef (parse_in, \"__PKU__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_RDPID)\n+    ; //def_or_undef (parse_in, \"__RDPID__\");\n   if (isa_flag & OPTION_MASK_ISA_GFNI)\n-    //def_or_undef (parse_in, \"__GFNI__\");\n+    ; //def_or_undef (parse_in, \"__GFNI__\");\n   if ((isa_flag & OPTION_MASK_ISA_SHSTK))\n-    //def_or_undef (parse_in, \"__SHSTK__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_VAES)\n-    //def_or_undef (parse_in, \"__VAES__\");\n+    ; //def_or_undef (parse_in, \"__SHSTK__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_VAES)\n+    ; //def_or_undef (parse_in, \"__VAES__\");\n   if (isa_flag & OPTION_MASK_ISA_VPCLMULQDQ)\n     rust_add_target_info(\"target_feature\", \"pclmulqdq\");\n   if (isa_flag & OPTION_MASK_ISA_MOVDIRI)\n-    //def_or_undef (parse_in, \"__MOVDIRI__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_MOVDIR64B)\n-    //def_or_undef (parse_in, \"__MOVDIR64B__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_WAITPKG)\n-    //def_or_undef (parse_in, \"__WAITPKG__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_CLDEMOTE)\n-    //def_or_undef (parse_in, \"__CLDEMOTE__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_PTWRITE)\n-    //def_or_undef (parse_in, \"__PTWRITE__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_AVX512BF16)\n-    //def_or_undef (parse_in, \"__AVX512BF16__\");\n+    ; //def_or_undef (parse_in, \"__MOVDIRI__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_MOVDIR64B)\n+    ; //def_or_undef (parse_in, \"__MOVDIR64B__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_WAITPKG)\n+    ; //def_or_undef (parse_in, \"__WAITPKG__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_CLDEMOTE)\n+    ; //def_or_undef (parse_in, \"__CLDEMOTE__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_PTWRITE)\n+    ; //def_or_undef (parse_in, \"__PTWRITE__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_AVX512BF16)\n+    ; //def_or_undef (parse_in, \"__AVX512BF16__\");\n   if (TARGET_MMX_WITH_SSE)\n-    //def_or_undef (parse_in, \"__MMX_WITH_SSE__\");\n-  if (isa_flag2 & OPTION_MASK_ISA_ENQCMD)\n-    //def_or_undef (parse_in, \"__ENQCMD__\");\n+    ; //def_or_undef (parse_in, \"__MMX_WITH_SSE__\");\n+  if (isa_flag2 & OPTION_MASK_ISA2_ENQCMD)\n+    ; //def_or_undef (parse_in, \"__ENQCMD__\");\n   if (TARGET_IAMCU)\n     {\n       //def_or_undef (parse_in, \"__iamcu\");\n       //def_or_undef (parse_in, \"__iamcu__\");\n     }\n+  if (TARGET_CMPXCHG16B)\n+    rust_add_target_info(\"target_feature\", \"cmpxchg16b\");\n+  if (TARGET_MOVBE)\n+    rust_add_target_info(\"target_feature\", \"movbe\");\n+\n+#undef isa_flag\n+#undef isa_flag2\n+#undef fpmath\n }\n \n #undef STR_HELPER_RUST\n-#undef STRINGIFY_RUST\n\\ No newline at end of file\n+#undef STRINGIFY_RUST"}, {"sha": "f7fd0652b2f75b5f28e04ca9c2df92d285b40b76", "filename": "gcc/config/i386/linux-common.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fi386%2Flinux-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Fi386%2Flinux-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-common.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -34,7 +34,13 @@ along with GCC; see the file COPYING3.  If not see\n   ANDROID_TARGET_RUST_OS_INFO();\n // TODO: decide on whether following c frontend style or d one - leaning towards c\n \n-#undef TARGET_RUST_OS_INFO\n+\n+/*#ifdef TARGET_RUST_OS_INFO\n+# error \"TARGET_RUST_OS_INFO already defined in linux-common.h (i386) - c++ undefines it and redefines it.\"\n+# error \"note that this above error (linux-common-i386) is expected due to already defining EXTRA_TARGET stuff\"\n+#endif*/\n+/* This is previously defined in gnu-user-common.h, but has no linux-specific info.  */\n+#undef TARGET_RUST_OS_INFO \n #define TARGET_RUST_OS_INFO()               \\\n   do {                                      \\\n     GNU_USER_TARGET_RUST_OS_INFO();         \\"}, {"sha": "9d40cf2b11cde92a497e0a1b38c1ef923697d7b8", "filename": "gcc/config/linux.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -72,6 +72,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   builtin_rust_info (\"target_vendor\", \"unknown\");\t\t\t\\\n   /*is there way of determining target_os and target_env here since could also be android?*/\t\t\\\n   /*target_vendor may not be \"unknown\" - FIXME ensure it is*/  \\\n+  if (OPTION_GLIBC)\t\t\t\\\n+      builtin_rust_info (\"target_env\", \"gnu\");\t\t\t\\\n+  else if (OPTION_MUSL)\t\t\t\\\n+      builtin_rust_info (\"target_env\", \"musl\");\t\t\t\\\n+  else /*TODO: determine if bionic and uclibc are considered to be different envs in rustc*/ \\\n+      builtin_rust_info (\"target_env\", \"\");\t\t\t\\\n     } while (0)\n \n /* Determine which dynamic linker to use depending on whether GLIBC or"}, {"sha": "0a6bff23a66c1385dfcb18bff403fee1cbb250db", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -293,6 +293,9 @@ extern void (*rs6000_target_modify_macros_ptr) (bool, HOST_WIDE_INT,\n /* Declare functions in rs6000-d.c  */\n extern void rs6000_d_target_versions (void);\n \n+/* Declare functions in rs6000-rust.c  */\n+extern void rs6000_rust_target_cpu_info (void);\n+\n #ifdef NO_DOLLAR_IN_LABEL\n const char * rs6000_xcoff_strip_dollar (const char *);\n #endif"}, {"sha": "d28ed9f9f7dcf75ea66a19098a83b06f051c371b", "filename": "gcc/config/rs6000/rs6000-rust.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Frs6000-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Frs6000-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-rust.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -0,0 +1,81 @@\n+/* Subroutines for the Rust front end on the PowerPC architecture.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rust/rust-target.h\"\n+#include \"rust/rust-target-def.h\"\n+\n+/* Implement TARGET_RUST_CPU_INFO for PowerPC targets.  */\n+\n+void\n+rs6000_rust_target_cpu_info (void)\n+{\n+  // note that rustc makes no arch distinction between powerpc64 and powerpc64 little endian\n+  if (TARGET_64BIT)\n+    rust_add_target_info (\"target_arch\", \"powerpc64\");\n+  else\n+    rust_add_target_info (\"target_arch\", \"powerpc\");\n+\n+  // TODO: define properly instead of macros\n+#ifdef flags\n+# error \"multiple flags already defined in rs6000-rust.c\"\n+#endif\n+#define flags rs6000_isa_flags\n+\n+  // options should be (almost at least - i.e. power8-altivec and the like) feature complete with rustc\n+  if ((flags & OPTION_MASK_ALTIVEC) != 0)\n+    rust_add_target_info (\"target_feature\", \"altivec\");\n+  if ((flags & OPTION_MASK_VSX) != 0)\n+    rust_add_target_info (\"target_feature\", \"vsx\");\n+  /* I can't find any separate gcc equivalent to \"power8-altivec\" in llvm, but power8-vector has it as a\n+   * prerequisite, so just implicitly enable it when enabling the vector. TODO search for it. */\n+  if ((flags & OPTION_MASK_P8_VECTOR) != 0) {\n+    rust_add_target_info (\"target_feature\", \"power8-vector\");\n+    rust_add_target_info (\"target_feature\", \"power8-altivec\");\n+  }\n+  if ((flags & OPTION_MASK_CRYPTO) != 0)\n+    rust_add_target_info (\"target_feature\", \"crypto\");\n+  if ((flags & OPTION_MASK_HTM) != 0)\n+    rust_add_target_info (\"target_feature\", \"htm\");\n+  if ((flags & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n+    rust_add_target_info (\"target_feature\", \"float128\");\n+  // Same implicit enabling of power9-altivec happens with power9-vector.\n+  if ((flags & OPTION_MASK_P9_VECTOR) != 0) {\n+    rust_add_target_info (\"target_feature\", \"power9-vector\");\n+    rust_add_target_info (\"target_feature\", \"power9-altivec\");\n+  }\n+  if ((flags & OPTION_MASK_DIRECT_MOVE) != 0)\n+    rust_add_target_info (\"target_feature\", \"direct-move\");\n+\n+  if (TARGET_SECURE_PLT)\n+    rust_add_target_info (\"target_feature\", \"secure-plt\");\n+\n+  if ((flags & OPTION_MASK_SOFT_FLOAT) != 0)\n+    ; // apparently not an option - TODO find out if it is\n+  else\n+    rust_add_target_info (\"target_feature\", \"hard-float\");\n+\n+  // TODO: some possible features (in rustc, listed under powerpc-wrs-vxworks-spe) - \"msync\"\n+  // other possible features (in clang) - \"qpx\" (when cpu = \"a2q\"), \"bpermd\", \"extdiv\", \"spe\"\n+\n+  // note: in gcc, it is possible bpermd is available if popcntd is available (which is power 7)\n+\n+#undef flags\n+}"}, {"sha": "cf3651c2740aa32bc674c5c50f4ddbdea36684be", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -643,6 +643,9 @@ extern unsigned char rs6000_recip_bits[];\n /* Target CPU versions for D.  */\n #define TARGET_D_CPU_VERSIONS rs6000_d_target_versions\n \n+/* Target CPU info for Rust.  */\n+#define TARGET_RUST_CPU_INFO rs6000_rust_target_cpu_info\n+\n /* This is used by rs6000_cpu_cpp_builtins to indicate the byte order\n    we're compiling for.  Some configurations may need to override it.  */\n #define RS6000_CPU_CPP_ENDIAN_BUILTINS()\t\\"}, {"sha": "7b6b8781f7d39953eacf7aadcb642be884cd5673", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -39,6 +39,10 @@ rs6000-d.o: $(srcdir)/config/rs6000/rs6000-d.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+rs6000-rust.o: $(srcdir)/config/rs6000/rs6000-rust.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n rs6000-logue.o: $(srcdir)/config/rs6000/rs6000-logue.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)"}, {"sha": "695335d6f3a4a8870c2dea9bb4086f93fda9b4d4", "filename": "gcc/configure", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -645,6 +645,7 @@ GMPINC\n GMPLIBS\n target_cpu_default\n d_target_objs\n+rust_target_objs\n fortran_target_objs\n cxx_target_objs\n c_target_objs\n@@ -654,6 +655,8 @@ xm_include_list\n xm_file_list\n tm_d_include_list\n tm_d_file_list\n+tm_rust_include_list\n+tm_rust_file_list\n tm_p_include_list\n tm_p_file_list\n tm_defines\n@@ -12498,6 +12501,7 @@ fi\n tm_file=\"${tm_file} defaults.h\"\n tm_p_file=\"${tm_p_file} tm-preds.h\"\n tm_d_file=\"${tm_d_file} defaults.h\"\n+tm_rust_file=\"${tm_rust_file} defaults.h\"\n host_xm_file=\"auto-host.h ansidecl.h ${host_xm_file}\"\n build_xm_file=\"${build_auto} ansidecl.h ${build_xm_file}\"\n # We don't want ansidecl.h in target files, write code there in ISO/GNU C.\n@@ -12906,6 +12910,21 @@ for f in $tm_d_file; do\n   esac\n done\n \n+tm_rust_file_list=\n+tm_rust_include_list=\"options.h insn-constants.h\"\n+for f in $tm_rust_file; do\n+  case $f in\n+    defaults.h )\n+       tm_rust_file_list=\"${tm_rust_file_list} \\$(srcdir)/$f\"\n+       tm_rust_include_list=\"${tm_rust_include_list} $f\"\n+       ;;\n+    * )\n+       tm_rust_file_list=\"${tm_rust_file_list} \\$(srcdir)/config/$f\"\n+       tm_rust_include_list=\"${tm_rust_include_list} config/$f\"\n+       ;;\n+  esac\n+done\n+\n xm_file_list=\n xm_include_list=\n for f in $xm_file; do"}, {"sha": "d9df20f49b0f4a9a926ff0bb48d0c4111609dff7", "filename": "gcc/configure.ac", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -1994,6 +1994,7 @@ AC_SUBST(HAVE_AUTO_BUILD)\n tm_file=\"${tm_file} defaults.h\"\n tm_p_file=\"${tm_p_file} tm-preds.h\"\n tm_d_file=\"${tm_d_file} defaults.h\"\n+tm_rust_file=\"${tm_rust_file} defaults.h\"\n host_xm_file=\"auto-host.h ansidecl.h ${host_xm_file}\"\n build_xm_file=\"${build_auto} ansidecl.h ${build_xm_file}\"\n # We don't want ansidecl.h in target files, write code there in ISO/GNU C.\n@@ -2251,6 +2252,21 @@ for f in $tm_d_file; do\n   esac\n done\n \n+tm_rust_file_list=\n+tm_rust_include_list=\"options.h insn-constants.h\"\n+for f in $tm_rust_file; do\n+  case $f in\n+    defaults.h )\n+       tm_rust_file_list=\"${tm_rust_file_list} \\$(srcdir)/$f\"\n+       tm_rust_include_list=\"${tm_rust_include_list} $f\"\n+       ;;\n+    * )\n+       tm_rust_file_list=\"${tm_rust_file_list} \\$(srcdir)/config/$f\"\n+       tm_rust_include_list=\"${tm_rust_include_list} config/$f\"\n+       ;;\n+  esac\n+done\n+\n xm_file_list=\n xm_include_list=\n for f in $xm_file; do\n@@ -7070,6 +7086,8 @@ AC_SUBST(tm_p_file_list)\n AC_SUBST(tm_p_include_list)\n AC_SUBST(tm_d_file_list)\n AC_SUBST(tm_d_include_list)\n+AC_SUBST(tm_rust_file_list)\n+AC_SUBST(tm_rust_include_list)\n AC_SUBST(xm_file_list)\n AC_SUBST(xm_include_list)\n AC_SUBST(xm_defines)\n@@ -7078,6 +7096,7 @@ AC_SUBST(c_target_objs)\n AC_SUBST(cxx_target_objs)\n AC_SUBST(fortran_target_objs)\n AC_SUBST(d_target_objs)\n+AC_SUBST(rust_target_objs)\n AC_SUBST(target_cpu_default)\n \n AC_SUBST_FILE(language_hooks)"}, {"sha": "39da82788b50e01e512d5d9d36537a3620076d35", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -53,6 +53,7 @@ through the macros defined in the @file{.h} file.\n * PCH Target::          Validity checking for precompiled headers.\n * C++ ABI::             Controlling C++ ABI changes.\n * D Language and ABI::  Controlling D ABI changes.\n+* Rust Language and ABI:: Controlling Rust ABI changes.\n * Named Address Spaces:: Adding support for named address spaces\n * Misc::                Everything else.\n @end menu\n@@ -10822,6 +10823,22 @@ Similarly to @code{TARGET_D_CPU_VERSIONS}, but is used for versions\n relating to the target operating system.\n @end deftypefn\n \n+@node Rust Language and ABI\n+@section Rust ABI parameters\n+@cindex parameters, rust abi\n+\n+@deftypefn {Rust Target Hook} void TARGET_RUST_CPU_INFO (void)\n+Declare all environmental CPU info and features relating to the target CPU\n+using the function @code{rust_add_target_info}, which takes a string representing\n+the feature key and a string representing the feature value.  Configuration pairs\n+predefined by this hook apply to all files that are being compiled.\n+@end deftypefn\n+\n+@deftypefn {Rust Target Hook} void TARGET_RUST_OS_INFO (void)\n+Similarly to @code{TARGET_RUST_CPU_INFO}, but is used for configuration info\n+relating to the target operating system.\n+@end deftypefn\n+\n @node Named Address Spaces\n @section Adding support for named address spaces\n @cindex named address spaces"}, {"sha": "e658e385cfbba3521a40aea95b2f8e3a57d8beca", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -53,6 +53,7 @@ through the macros defined in the @file{.h} file.\n * PCH Target::          Validity checking for precompiled headers.\n * C++ ABI::             Controlling C++ ABI changes.\n * D Language and ABI::  Controlling D ABI changes.\n+* Rust Language and ABI:: Controlling Rust ABI changes.\n * Named Address Spaces:: Adding support for named address spaces\n * Misc::                Everything else.\n @end menu\n@@ -7353,6 +7354,14 @@ floating-point support; they are not included in this mechanism.\n \n @hook TARGET_D_OS_VERSIONS\n \n+@node Rust Language and ABI\n+@section Rust ABI parameters\n+@cindex parameters, rust abi\n+\n+@hook TARGET_RUST_CPU_INFO\n+\n+@hook TARGET_RUST_OS_INFO\n+\n @node Named Address Spaces\n @section Adding support for named address spaces\n @cindex named address spaces"}, {"sha": "bee121251142a6aed52610d427af09ebdcb97350", "filename": "gcc/genhooks.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fgenhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Fgenhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenhooks.c?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -35,6 +35,7 @@ static struct hook_desc hook_array[] = {\n #include \"c-family/c-target.def\"\n #include \"common/common-target.def\"\n #include \"d/d-target.def\"\n+#include \"rust/rust-target.def\"\n #undef DEFHOOK\n };\n "}, {"sha": "1a5622e3415745e6f9ee41ff1e218665749e3aa8", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -72,12 +72,15 @@ GRS_OBJS = \\\n     $(END)\n # removed object files from here \n \n-rust_OBJS = $(GRS_OBJS) rust/rustspec.o\n+# All language-specific object files for Rust.\n+RUST_ALL_OBJS = $(GRS_OBJS) $(RUST_TARGET_OBJS)\n+\n+rust_OBJS = $(RUST_ALL_OBJS) rust/rustspec.o\n \n # The compiler itself is called rust1 (formerly grs1)\n-rust1$(exeext): $(GRS_OBJS) attribs.o  $(BACKEND) $(LIBDEPS)\n+rust1$(exeext): $(RUST_ALL_OBJS) attribs.o  $(BACKEND) $(LIBDEPS)\n \t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t      $(GRS_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n+\t      $(RUST_ALL_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n \n # Build hooks.\n \n@@ -169,7 +172,7 @@ rust.install-plugin:\n rust.uninstall:\n #\t-rm -rf $(DESTDIR)/$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n \t-rm -f gccrs$(exeext) grs1$(exeext)\n-\t-rm -f $(GRS_OBJS)\n+\t-rm -f $(RUST_ALL_OBJS)\n # ^those two are a maybe\n \n # No rust-specific selftests"}, {"sha": "54adf488ac94b15e81f07c529a691b6f77f125d6", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 2045, "deletions": 2481, "changes": 4526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2"}, {"sha": "8e9e4a35bc0d59e533ab05b0fe577689123b6c16", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 714, "deletions": 748, "changes": 1462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -5,6 +5,7 @@\n \n #include \"target.h\"\n #include \"tm.h\"\n+#include \"tm_p.h\"\n \n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n@@ -13,799 +14,764 @@\n \n #include <algorithm>\n \n-extern Linemap *\n-rust_get_linemap ();\n+extern Linemap* rust_get_linemap();\n \n namespace Rust {\n-// Simple wrapper for FILE* that simplifies destruction.\n-struct RAIIFile\n-{\n-  FILE *file;\n-\n-  RAIIFile (const char *filename) : file (fopen (filename, \"r\")) {}\n-\n-  ~RAIIFile () { fclose (file); }\n-};\n-\n-// Implicitly enable a target_feature (and recursively enable dependencies).\n-void\n-Session::implicitly_enable_feature (::std::string feature_name)\n-{\n-  // TODO: is this really required since features added would be complete via\n-  // target spec?\n-\n-  if (!options.target_data.has_key_value_pair (\"target_data\", feature_name))\n-    {\n-      // if feature has dependencies, enable them\n-      if (feature_name == \"aes\")\n-\t{\n-\t  implicitly_enable_feature (\"sse2\");\n-\t}\n-      else if (feature_name == \"avx\")\n-\t{\n-\t  implicitly_enable_feature (\"sse4.2\");\n-\t}\n-      else if (feature_name == \"avx2\")\n-\t{\n-\t  implicitly_enable_feature (\"avx\");\n-\t}\n-      else if (feature_name == \"fma\")\n-\t{\n-\t  implicitly_enable_feature (\"avx\");\n-\t}\n-      else if (feature_name == \"pclmulqdq\")\n-\t{\n-\t  implicitly_enable_feature (\"sse2\");\n-\t}\n-      else if (feature_name == \"sha\")\n-\t{\n-\t  implicitly_enable_feature (\"sse2\");\n-\t}\n-      else if (feature_name == \"sse2\")\n-\t{\n-\t  implicitly_enable_feature (\"sse\");\n-\t}\n-      else if (feature_name == \"sse3\")\n-\t{\n-\t  implicitly_enable_feature (\"sse2\");\n-\t}\n-      else if (feature_name == \"sse4.1\")\n-\t{\n-\t  implicitly_enable_feature (\"sse3\");\n-\t}\n-      else if (feature_name == \"sse4.2\")\n-\t{\n-\t  implicitly_enable_feature (\"sse4.1\");\n-\t}\n-      else if (feature_name == \"ssse3\")\n-\t{\n-\t  implicitly_enable_feature (\"sse3\");\n-\t}\n-\n-      options.target_data.insert_key_value_pair (\"target_feature\",\n-\t\t\t\t\t\t ::std::move (feature_name));\n+    // Simple wrapper for FILE* that simplifies destruction.\n+    struct RAIIFile {\n+        FILE* file;\n+\n+        RAIIFile(const char* filename) : file(fopen(filename, \"r\")) {}\n+\n+        ~RAIIFile() {\n+            fclose(file);\n+        }\n+    };\n+\n+    // Implicitly enable a target_feature (and recursively enable dependencies).\n+    void Session::implicitly_enable_feature(::std::string feature_name) {\n+        // TODO: is this really required since features added would be complete via target spec?\n+\n+        if (!options.target_data.has_key_value_pair(\"target_data\", feature_name)) {\n+            // if feature has dependencies, enable them\n+            if (feature_name == \"aes\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"avx\") {\n+                implicitly_enable_feature(\"sse4.2\");\n+            } else if (feature_name == \"avx2\") {\n+                implicitly_enable_feature(\"avx\");\n+            } else if (feature_name == \"fma\") {\n+                implicitly_enable_feature(\"avx\");\n+            } else if (feature_name == \"pclmulqdq\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"sha\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"sse2\") {\n+                implicitly_enable_feature(\"sse\");\n+            } else if (feature_name == \"sse3\") {\n+                implicitly_enable_feature(\"sse2\");\n+            } else if (feature_name == \"sse4.1\") {\n+                implicitly_enable_feature(\"sse3\");\n+            } else if (feature_name == \"sse4.2\") {\n+                implicitly_enable_feature(\"sse4.1\");\n+            } else if (feature_name == \"ssse3\") {\n+                implicitly_enable_feature(\"sse3\");\n+            }\n+\n+            options.target_data.insert_key_value_pair(\"target_feature\", ::std::move(feature_name));\n+        }\n     }\n-}\n \n-// Meant to enable all target features. As this will be done by target hook,\n-// this method's deprecated.\n-void\n-Session::enable_features ()\n-{\n-  bool has_target_crt_static = false;\n-  const char *target = \"PLACEHOLDER\";\n-\n-  fprintf (\n-    stderr,\n-    \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n-\n-  if (has_target_crt_static)\n-    {\n-      // enable \"crt-static\" attribute\n+    // Meant to enable all target features. As this will be done by target hook, this method's\n+    // deprecated.\n+    void Session::enable_features() {\n+        bool has_target_crt_static = false;\n+        const char* target = \"PLACEHOLDER\";\n+\n+        fprintf(stderr, \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n+\n+        if (has_target_crt_static) {\n+            // enable \"crt-static\" attribute\n+        }\n+\n+        /* TODO: do this via target hook. have one for each target that implicitly enables the\n+         * features for that platform. Would probably have to make custom target hook. */\n+\n+        /*\n+        if (target == \"x86\" || target == \"x86_64\") {\n+            if (TARGET_ISA_AES) {\n+                // enable aes, implicitly enable sse2\n+                implicitly_enable_feature(\"aes\");\n+            }\n+\n+            if (TARGET_ISA_AVX) {\n+                // enable avx, implicitly enable sse4.2\n+                implicitly_enable_feature(\"sse4.2\");\n+            }\n+\n+            if (TARGET_ISA_AVX2) {\n+                // enable avx2, implicitly enable avx\n+                implicitly_enable_feature(\"avx\");\n+            }\n+\n+            if (TARGET_ISA_BMI) {\n+                // enable bmi1\n+                implicitly_enable_feature(\"bmi1\");\n+            }\n+\n+            if (TARGET_ISA_BMI2) {\n+                // enable bmi2\n+                implicitly_enable_feature(\"bmi2\");\n+            }\n+\n+            if (TARGET_ISA_FMA) {\n+                // enable fma, implicitly enable avx\n+                implicitly_enable_feature(\"fma\");\n+            }\n+\n+            if (TARGET_ISA_FXSR) {\n+                // enable fxsr\n+                implicitly_enable_feature(\"fxsr\");\n+            }\n+\n+            if (TARGET_ISA_LZCNT) {\n+                // enable lzcnt\n+                implicitly_enable_feature(\"lzcnt\");\n+            }\n+\n+            if (TARGET_ISA_VPCLMULQDQ) {\n+                // enable pclmulqdq, implicitly enable sse2\n+                implicitly_enable_feature(\"pclmulqdq\");\n+            }\n+\n+            if (TARGET_ISA_POPCNT) {\n+                // enable popcnt\n+                implicitly_enable_feature(\"popcnt\");\n+            }\n+\n+            if (TARGET_ISA_RDRND) {\n+                // enable rdrand\n+                implicitly_enable_feature(\"rdrand\");\n+            }\n+\n+            if (TARGET_ISA_RDSEED) {\n+                // enable rdseed\n+                implicitly_enable_feature(\"rdseed\");\n+            }\n+\n+            if (TARGET_ISA_SHA) {\n+                // enable sha, implicitly enable sse2\n+                implicitly_enable_feature(\"sha\");\n+            }\n+\n+            if (TARGET_ISA_SSE) {\n+                // enable sse\n+                implicitly_enable_feature(\"sse\");\n+            }\n+\n+            if (TARGET_ISA_SSE2) {\n+                // enable sse2, implicitly enable sse\n+                implicitly_enable_feature(\"sse2\");\n+            }\n+\n+            if (TARGET_ISA_SSE3) {\n+                // enable sse3, implicitly enable sse2\n+                implicitly_enable_feature(\"sse3\");\n+            }\n+\n+            if (TARGET_ISA_SSE4_1) {\n+                // enable sse4.1, implicitly enable sse3\n+                implicitly_enable_feature(\"sse4.1\");\n+            }\n+\n+            if (TARGET_ISA_SSE4_2) {\n+                // enable sse4.2, implicitly enable sse4.1\n+                implicitly_enable_feature(\"sse4.2\");\n+            }\n+\n+            if (TARGET_ISA_SSSE3) {\n+                // enable ssse3, implicitly enable sse3\n+                implicitly_enable_feature(\"ssse3\");\n+            }\n+\n+            if (TARGET_ISA_XSAVE) {\n+                // enable xsave\n+                implicitly_enable_feature(\"xsave\");\n+            }\n+\n+            if (TARGET_ISA_XSAVEC) {\n+                // enable xsavec\n+                implicitly_enable_feature(\"xsavec\");\n+            }\n+\n+            if (TARGET_ISA_XSAVEOPT) {\n+                // enable xsaveopt\n+                implicitly_enable_feature(\"xsaveopt\");\n+            }\n+\n+            if (TARGET_ISA_XSAVES) {\n+                // enable xsaves\n+                implicitly_enable_feature(\"xsaves\");\n+            }\n+        }\n+        options.target_data.features.shrink_to_fit();\n+        ::std::sort(options.target_data.features.begin(), options.target_data.features.end());*/\n     }\n \n-  /* TODO: do this via target hook. have one for each target that implicitly\n-   * enables the\n-   * features for that platform. Would probably have to make custom target hook.\n-   */\n-\n-  /*\n-  if (target == \"x86\" || target == \"x86_64\") {\n-      if (TARGET_ISA_AES) {\n-\t  // enable aes, implicitly enable sse2\n-\t  implicitly_enable_feature(\"aes\");\n-      }\n-\n-      if (TARGET_ISA_AVX) {\n-\t  // enable avx, implicitly enable sse4.2\n-\t  implicitly_enable_feature(\"sse4.2\");\n-      }\n-\n-      if (TARGET_ISA_AVX2) {\n-\t  // enable avx2, implicitly enable avx\n-\t  implicitly_enable_feature(\"avx\");\n-      }\n-\n-      if (TARGET_ISA_BMI) {\n-\t  // enable bmi1\n-\t  implicitly_enable_feature(\"bmi1\");\n-      }\n-\n-      if (TARGET_ISA_BMI2) {\n-\t  // enable bmi2\n-\t  implicitly_enable_feature(\"bmi2\");\n-      }\n-\n-      if (TARGET_ISA_FMA) {\n-\t  // enable fma, implicitly enable avx\n-\t  implicitly_enable_feature(\"fma\");\n-      }\n-\n-      if (TARGET_ISA_FXSR) {\n-\t  // enable fxsr\n-\t  implicitly_enable_feature(\"fxsr\");\n-      }\n-\n-      if (TARGET_ISA_LZCNT) {\n-\t  // enable lzcnt\n-\t  implicitly_enable_feature(\"lzcnt\");\n-      }\n-\n-      if (TARGET_ISA_VPCLMULQDQ) {\n-\t  // enable pclmulqdq, implicitly enable sse2\n-\t  implicitly_enable_feature(\"pclmulqdq\");\n-      }\n-\n-      if (TARGET_ISA_POPCNT) {\n-\t  // enable popcnt\n-\t  implicitly_enable_feature(\"popcnt\");\n-      }\n-\n-      if (TARGET_ISA_RDRND) {\n-\t  // enable rdrand\n-\t  implicitly_enable_feature(\"rdrand\");\n-      }\n-\n-      if (TARGET_ISA_RDSEED) {\n-\t  // enable rdseed\n-\t  implicitly_enable_feature(\"rdseed\");\n-      }\n-\n-      if (TARGET_ISA_SHA) {\n-\t  // enable sha, implicitly enable sse2\n-\t  implicitly_enable_feature(\"sha\");\n-      }\n-\n-      if (TARGET_ISA_SSE) {\n-\t  // enable sse\n-\t  implicitly_enable_feature(\"sse\");\n-      }\n-\n-      if (TARGET_ISA_SSE2) {\n-\t  // enable sse2, implicitly enable sse\n-\t  implicitly_enable_feature(\"sse2\");\n-      }\n-\n-      if (TARGET_ISA_SSE3) {\n-\t  // enable sse3, implicitly enable sse2\n-\t  implicitly_enable_feature(\"sse3\");\n-      }\n-\n-      if (TARGET_ISA_SSE4_1) {\n-\t  // enable sse4.1, implicitly enable sse3\n-\t  implicitly_enable_feature(\"sse4.1\");\n-      }\n-\n-      if (TARGET_ISA_SSE4_2) {\n-\t  // enable sse4.2, implicitly enable sse4.1\n-\t  implicitly_enable_feature(\"sse4.2\");\n-      }\n-\n-      if (TARGET_ISA_SSSE3) {\n-\t  // enable ssse3, implicitly enable sse3\n-\t  implicitly_enable_feature(\"ssse3\");\n-      }\n-\n-      if (TARGET_ISA_XSAVE) {\n-\t  // enable xsave\n-\t  implicitly_enable_feature(\"xsave\");\n-      }\n-\n-      if (TARGET_ISA_XSAVEC) {\n-\t  // enable xsavec\n-\t  implicitly_enable_feature(\"xsavec\");\n-      }\n-\n-      if (TARGET_ISA_XSAVEOPT) {\n-\t  // enable xsaveopt\n-\t  implicitly_enable_feature(\"xsaveopt\");\n-      }\n-\n-      if (TARGET_ISA_XSAVES) {\n-\t  // enable xsaves\n-\t  implicitly_enable_feature(\"xsaves\");\n-      }\n-  }\n-  options.target_data.features.shrink_to_fit();\n-  ::std::sort(options.target_data.features.begin(),\n-  options.target_data.features.end());*/\n-}\n-\n-void\n-Session::init ()\n-{\n-  // nothing yet\n-}\n-\n-// Initialise default options. Actually called before handle_option, unlike init\n-// itself.\n-void\n-Session::init_options ()\n-{\n-  options.dump_option = CompileOptions::NO_DUMP;\n-}\n-\n-// Handle option selection.\n-bool\n-Session::handle_option (\n-  enum opt_code code, const char *arg, HOST_WIDE_INT value ATTRIBUTE_UNUSED,\n-  int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n-  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n-{\n-  // used to store whether results of various stuff are successful\n-  bool ret = true;\n-\n-  // Handles options as listed in lang.opt.\n-  switch (code)\n-    {\n-    case OPT_I:\n-      // TODO: add search path\n-      break;\n-    case OPT_L:\n-      // TODO: add library link path or something\n-      break;\n-    case OPT_frust_dump_:\n-      // enable dump and return whether this was successful\n-      if (arg != NULL)\n-\t{\n-\t  ret = enable_dump (::std::string (arg));\n-\t}\n-      else\n-\t{\n-\t  ret = false;\n-\t}\n-      break;\n-    // no option handling for -o\n-    default:\n-      // return 1 to indicate option is valid\n-      break;\n+    void Session::init() {\n+#ifndef TARGET_RUST_OS_INFO\n+# define TARGET_RUST_OS_INFO()\n+#endif\n+//#define builtin_rust_info(KEY, VALUE) rust_add_target_info (KEY, VALUE)\n+// might as well use c++ stuff\n+#define builtin_rust_info(KEY, VALUE) options.target_data.insert_key_value_pair(KEY, VALUE)\n+\n+        // initialise target hooks\n+        //targetrustm.rust_cpu_info();\n+        //targetrustm.rust_os_info();\n+        // ok, that's not working too well TODO - see if can salvage old implementation \n+        TARGET_RUST_CPU_INFO();\n+        TARGET_RUST_OS_INFO();\n+        \n+#undef builtin_rust_info\n+\n+        // target-independent values that should exist in all targets\n+        options.target_data.insert_key_value_pair(\"target_pointer_width\", std::to_string(POINTER_SIZE));\n+        options.target_data.insert_key_value_pair(\"target_endian\", BYTES_BIG_ENDIAN ? \"big\" : \"little\");\n+\n+        // TODO: find min atomic width and max atomic width\n+        // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if inside bounds)\n+        // in rustc, min atomic width is a known quantity (or 8 if not known), and max is also a known quantity (or is pointer size if not known)\n+        // TODO: add atomic pointer if some criteria is satisfied\n+\n+        // TODO: find whether target has \"atomic cas\"\n+\n+        // add debug_assertions if enabled and proc_macro if crate type has it or whatever\n+\n+        // derived values from hook\n+        options.target_data.init_derived_values();\n     }\n \n-  return ret;\n-}\n-\n-/* Enables a certain dump depending on the name passed in. Returns true if name\n- * is valid, false otherwise. */\n-bool\n-Session::enable_dump (::std::string arg)\n-{\n-  // FIXME: change dumping algorithm when new non-inhibiting dump system is\n-  // created\n-  if (arg == \"all\")\n-    {\n-      error_at (\n-\tUNKNOWN_LOCATION,\n-\t\"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n-      return false;\n-    }\n-  else if (arg == \"lex\")\n-    {\n-      options.dump_option = CompileOptions::LEXER_DUMP;\n-    }\n-  else if (arg == \"parse\")\n-    {\n-      options.dump_option = CompileOptions::PARSER_AST_DUMP;\n-    }\n-  else if (arg == \"register_plugins\")\n-    {\n-      options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n+    // Initialise default options. Actually called before handle_option, unlike init itself.\n+    void Session::init_options() {\n+        options.dump_option = CompileOptions::NO_DUMP;\n     }\n-  else if (arg == \"injection\")\n-    {\n-      options.dump_option = CompileOptions::INJECTION_DUMP;\n-    }\n-  else if (arg == \"expansion\")\n-    {\n-      options.dump_option = CompileOptions::EXPANSION_DUMP;\n-    }\n-  else if (arg == \"name_resolution\")\n-    {\n-      options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n-    }\n-  else if (arg == \"\")\n-    {\n-      error_at (UNKNOWN_LOCATION,\n-\t\t\"dump option was not given a name. choose 'lex' or 'parse'\");\n-      return false;\n-    }\n-  else\n-    {\n-      error_at (UNKNOWN_LOCATION,\n-\t\t\"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n-\t\targ.c_str ());\n-      return false;\n-    }\n-  return true;\n-}\n \n-/* Actual main entry point for front-end. Called from langhook to parse files.\n- */\n-void\n-Session::parse_files (int num_files, const char **files)\n-{\n-  for (int i = 0; i < num_files; i++)\n-    {\n-      parse_file (files[i]);\n+    // Handle option selection.\n+    bool Session::handle_option(enum opt_code code, const char* arg,\n+      HOST_WIDE_INT value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n+      location_t loc ATTRIBUTE_UNUSED, const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n+        // used to store whether results of various stuff are successful\n+        bool ret = true;\n+\n+        // Handles options as listed in lang.opt.\n+        switch (code) {\n+            case OPT_I:\n+                // TODO: add search path\n+                break;\n+            case OPT_L:\n+                // TODO: add library link path or something\n+                break;\n+            case OPT_frust_dump_:\n+                // enable dump and return whether this was successful\n+                if (arg != NULL) {\n+                    ret = enable_dump(::std::string(arg));\n+                } else {\n+                    ret = false;\n+                }\n+                break;\n+            // no option handling for -o\n+            default:\n+                // return 1 to indicate option is valid\n+                break;\n+        }\n+\n+        return ret;\n     }\n-  // TODO: should semantic analysis be dealed with here? or per file? for now,\n-  // per-file.\n-}\n-\n-// Parses a single file with filename filename.\n-void\n-Session::parse_file (const char *filename)\n-{\n-  RAIIFile file_wrap (filename);\n \n-  if (file_wrap.file == NULL)\n-    {\n-      fatal_error (UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n+    /* Enables a certain dump depending on the name passed in. Returns true if name is valid, false\n+     * otherwise. */\n+    bool Session::enable_dump(::std::string arg) {\n+        // FIXME: change dumping algorithm when new non-inhibiting dump system is created\n+        if (arg == \"all\") {\n+            error_at(\n+              UNKNOWN_LOCATION, \"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n+            return false;\n+        } else if (arg == \"lex\") {\n+            options.dump_option = CompileOptions::LEXER_DUMP;\n+        } else if (arg == \"parse\") {\n+            options.dump_option = CompileOptions::PARSER_AST_DUMP;\n+        } else if (arg == \"register_plugins\") {\n+            options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n+        } else if (arg == \"injection\") {\n+            options.dump_option = CompileOptions::INJECTION_DUMP;\n+        } else if (arg == \"expansion\") {\n+            options.dump_option = CompileOptions::EXPANSION_DUMP;\n+        } else if (arg == \"name_resolution\") {\n+            options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n+        } else if (arg == \"target_options\") {\n+            // special case - dump all target options, and then quit compilation\n+            // nope, option handling called before init, so have to make this an actual compile option\n+            //options.target_data.dump_target_options();\n+            //return false;\n+            options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n+        } else if (arg == \"\") {\n+            error_at(UNKNOWN_LOCATION, \"dump option was not given a name. choose 'lex' or 'parse'\");\n+            return false;\n+        } else {\n+            error_at(UNKNOWN_LOCATION, \"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n+              arg.c_str());\n+            return false;\n+        }\n+        return true;\n     }\n \n-  // parse file here\n-  // create lexer and parser - these are file-specific and so aren't instance\n-  // variables\n-  Rust::Lexer lex (filename, file_wrap.file, rust_get_linemap ());\n-  Rust::Parser parser (lex);\n-\n-  // determine parsing method from options\n-  /* FIXME: currently, the dump means that full compilation will not occur as of\n-   * present. In future, dumps should not inhibit full compilation. */\n-  switch (options.dump_option)\n-    {\n-    case CompileOptions::NO_DUMP:\n-      fatal_error (UNKNOWN_LOCATION,\n-\t\t   \"no-dump parsing has not been enabled yet\");\n-      return;\n-    case CompileOptions::LEXER_DUMP:\n-      parser.debug_dump_lex_output ();\n-      return;\n-    case CompileOptions::PARSER_AST_DUMP:\n-      parser.debug_dump_ast_output ();\n-      return;\n-    case CompileOptions::REGISTER_PLUGINS_DUMP:\n-    case CompileOptions::INJECTION_DUMP:\n-    case CompileOptions::EXPANSION_DUMP:\n-    case CompileOptions::NAME_RESOLUTION_DUMP:\n-      // will break later after more stages\n-      break;\n-    // semantic analysis when completed\n-    default:\n-      fatal_error (UNKNOWN_LOCATION, \"unrecognised dump option: '%u'\",\n-\t\t   options.dump_option);\n-      return;\n+    /* Actual main entry point for front-end. Called from langhook to parse files. */\n+    void Session::parse_files(int num_files, const char** files) {\n+        for (int i = 0; i < num_files; i++) {\n+            parse_file(files[i]);\n+        }\n+        // TODO: should semantic analysis be dealed with here? or per file? for now, per-file.\n     }\n \n-  /* basic pipeline:\n-   *  - lex\n-   *  - parse\n-   *  - register plugins (dummy stage for now) - attribute injection? what is\n-   * this? (attribute injection is injecting attributes specified in command\n-   * line into crate root)\n-   *  - injection (some lint checks or dummy, register builtin macros, crate\n-   * injection)\n-   *  - expansion (expands all macros, maybe build test harness, AST validation,\n-   * maybe macro crate)\n-   *  - name resolution (name resolution, maybe feature checking, maybe buffered\n-   * lints)\n-   *  TODO not done */\n-\n-  // generate crate from parser\n-  AST::Crate parsed_crate = parser.parse_crate ();\n-\n-  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n-\n-  // register plugins pipeline stage\n-  register_plugins (parsed_crate);\n-  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP)\n-    {\n-      // TODO: what do I dump here?\n-      return;\n-    }\n-\n-  // injection pipeline stage\n-  injection (parsed_crate);\n-  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::INJECTION_DUMP)\n-    {\n-      // TODO: what do I dump here? injected crate names?\n-      return;\n+    // Parses a single file with filename filename.\n+    void Session::parse_file(const char* filename) {\n+        RAIIFile file_wrap(filename);\n+\n+        if (file_wrap.file == NULL) {\n+            fatal_error(UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n+        }\n+\n+        // parse file here\n+        // create lexer and parser - these are file-specific and so aren't instance variables\n+        Rust::Lexer lex(filename, file_wrap.file, rust_get_linemap());\n+        Rust::Parser parser(lex);\n+\n+        // determine parsing method from options\n+        /* FIXME: currently, the dump means that full compilation will not occur as of present. In\n+         * future, dumps should not inhibit full compilation. */\n+        switch (options.dump_option) {\n+            case CompileOptions::NO_DUMP:\n+                fatal_error(UNKNOWN_LOCATION, \"no-dump parsing has not been enabled yet\");\n+                return;\n+            case CompileOptions::LEXER_DUMP:\n+                parser.debug_dump_lex_output();\n+                return;\n+            case CompileOptions::PARSER_AST_DUMP:\n+                parser.debug_dump_ast_output();\n+                return;\n+            case CompileOptions::REGISTER_PLUGINS_DUMP:\n+            case CompileOptions::INJECTION_DUMP:\n+            case CompileOptions::EXPANSION_DUMP:\n+            case CompileOptions::NAME_RESOLUTION_DUMP:\n+                // will break later after more stages\n+                break;\n+            // semantic analysis when completed\n+            case CompileOptions::TARGET_OPTION_DUMP:\n+                options.target_data.dump_target_options();\n+                return;\n+            default:\n+                fatal_error(UNKNOWN_LOCATION, \"unrecognised dump option: '%u'\", options.dump_option);\n+                return;\n+        }\n+\n+        /* basic pipeline:\n+         *  - lex\n+         *  - parse\n+         *  - register plugins (dummy stage for now) - attribute injection? what is this?\n+         *    (attribute injection is injecting attributes specified in command line into crate root)\n+         *  - injection (some lint checks or dummy, register builtin macros, crate injection)\n+         *  - expansion (expands all macros, maybe build test harness, AST validation, maybe macro\n+         * crate)\n+         *  - name resolution (name resolution, maybe feature checking, maybe buffered lints)\n+         *  TODO not done */\n+\n+        // generate crate from parser\n+        AST::Crate parsed_crate = parser.parse_crate();\n+\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n+\n+        // register plugins pipeline stage\n+        register_plugins(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP) {\n+            // TODO: what do I dump here?\n+            return;\n+        }\n+\n+        // injection pipeline stage\n+        injection(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::INJECTION_DUMP) {\n+            // TODO: what do I dump here? injected crate names?\n+            return;\n+        }\n+\n+        // expansion pipeline stage\n+        expansion(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::EXPANSION_DUMP) {\n+            // TODO: what do I dump here? expanded macros? AST with expanded macros?\n+            return;\n+        }\n+\n+        // name resolution pipeline stage\n+        name_resolution(parsed_crate);\n+        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n+\n+        if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP) {\n+            // TODO: what do I dump here? resolved names? AST with resolved names?\n+            return;\n+        }\n     }\n \n-  // expansion pipeline stage\n-  expansion (parsed_crate);\n-  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n+    // Checks whether 'cfg' attribute prevents compilation.\n+    bool check_cfg(const AST::Attribute& attr ATTRIBUTE_UNUSED) {\n+        // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n \n-  if (options.dump_option == CompileOptions::EXPANSION_DUMP)\n-    {\n-      // TODO: what do I dump here? expanded macros? AST with expanded macros?\n-      return;\n-    }\n-\n-  // name resolution pipeline stage\n-  name_resolution (parsed_crate);\n-  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n+        // TODO: actually implement. assume true for now\n \n-  if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP)\n-    {\n-      // TODO: what do I dump here? resolved names? AST with resolved names?\n-      return;\n+        return true;\n     }\n-}\n+    // TODO: deprecated - don't use\n \n-// Checks whether 'cfg' attribute prevents compilation.\n-bool\n-check_cfg (const AST::Attribute &attr ATTRIBUTE_UNUSED)\n-{\n-  // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n+    // Checks whether any 'cfg' attribute on the item prevents compilation of that item.\n+    bool check_item_cfg(::std::vector<AST::Attribute> attrs) {\n+        for (const auto& attr : attrs) {\n+            if (attr.get_path() == \"cfg\" && !check_cfg(attr)) {\n+                return false;\n+            }\n+        }\n \n-  // TODO: actually implement. assume true for now\n-\n-  return true;\n-}\n-// TODO: deprecated - don't use\n-\n-// Checks whether any 'cfg' attribute on the item prevents compilation of that\n-// item.\n-bool\n-check_item_cfg (::std::vector<AST::Attribute> attrs)\n-{\n-  for (const auto &attr : attrs)\n-    {\n-      if (attr.get_path () == \"cfg\" && !check_cfg (attr))\n-\t{\n-\t  return false;\n-\t}\n+        return true;\n     }\n-\n-  return true;\n-}\n-// TODO: deprecated - don't use\n-\n-// TODO: actually implement method\n-void\n-load_extern_crate (::std::string crate_name ATTRIBUTE_UNUSED)\n-{}\n-// TODO: deprecated - don't use\n-\n-// Parses up to the \"load (external) crates\" part of the frontend.\n-// TODO: lots of this code is probably actually useful outside of dumping, so\n-// maybe split off function\n-void\n-Session::debug_dump_load_crates (Parser &parser)\n-{\n-  // parse crate as AST\n-  AST::Crate crate = parser.parse_crate ();\n-\n-  /* TODO: search through inner attrs and see whether any of those attr paths\n-   * contain \"no_core\", \"no_std\", \"compiler_builtins\". If so/not, save certain\n-   * crate names. In these names, insert items at beginning of crate items. This\n-   * is crate injection. Also, inject prelude use decl at beginning (first name\n-   * is assumed to be prelude - prelude is a use decl automatically generated to\n-   * enable using Option and Copy without qualifying it or importing it via\n-   * 'use' manually) */\n-\n-  ::std::vector< ::std::string> crate_names;\n-  for (const auto &item : crate.items)\n-    {\n-      // if item is extern crate, add name? to list of stuff ONLY IF config is\n-      // checked if item is module, iterate this loop inside it as well\n-      // (recursive?) ONLY IF config is checked\n-\n-      // TODO: actually do the checks somewhere - probably in the items\n-\n-      item->add_crate_name (crate_names);\n+    // TODO: deprecated - don't use\n+\n+    // TODO: actually implement method\n+    void load_extern_crate(::std::string crate_name ATTRIBUTE_UNUSED) {}\n+    // TODO: deprecated - don't use\n+\n+    // Parses up to the \"load (external) crates\" part of the frontend.\n+    // TODO: lots of this code is probably actually useful outside of dumping, so maybe split off\n+    // function\n+    void Session::debug_dump_load_crates(Parser& parser) {\n+        // parse crate as AST\n+        AST::Crate crate = parser.parse_crate();\n+\n+        /* TODO: search through inner attrs and see whether any of those attr paths contain \"no_core\",\n+         * \"no_std\", \"compiler_builtins\". If so/not, save certain crate names. In these names, insert\n+         * items at beginning of crate items. This is crate injection. Also, inject prelude use decl\n+         * at beginning (first name is assumed to be prelude - prelude is a use decl automatically\n+         * generated to enable using Option and Copy without qualifying it or importing it via 'use'\n+         * manually) */\n+\n+        ::std::vector< ::std::string> crate_names;\n+        for (const auto& item : crate.items) {\n+            // if item is extern crate, add name? to list of stuff ONLY IF config is checked\n+            // if item is module, iterate this loop inside it as well (recursive?) ONLY IF config is\n+            // checked\n+\n+            // TODO: actually do the checks somewhere - probably in the items\n+\n+            item->add_crate_name(crate_names);\n+        }\n+\n+        /* loop through list of crate names/paths/whatever, attempting to load each one. save loaded\n+         * crates to a Session variable? Or save to current AST::Crate? */\n+        for (const auto& name : crate_names) {\n+            load_extern_crate(name /*, basename = \"\"?*/);\n+        }\n+        //  for each loaded crate, load dependencies of it as well\n     }\n+    // TODO: deprecated - don't use\n \n-  /* loop through list of crate names/paths/whatever, attempting to load each\n-   * one. save loaded crates to a Session variable? Or save to current\n-   * AST::Crate? */\n-  for (const auto &name : crate_names)\n-    {\n-      load_extern_crate (name /*, basename = \"\"?*/);\n+    void Session::register_plugins(AST::Crate& crate ATTRIBUTE_UNUSED) {\n+        fprintf(stderr, \"ran register_plugins (with no body)\\n\");\n     }\n-  //  for each loaded crate, load dependencies of it as well\n-}\n-// TODO: deprecated - don't use\n \n-void\n-Session::register_plugins (AST::Crate &crate ATTRIBUTE_UNUSED)\n-{\n-  fprintf (stderr, \"ran register_plugins (with no body)\\n\");\n-}\n+    // TODO: move somewhere else\n+    bool contains_name(const std::vector<AST::Attribute>& attrs, std::string name) {\n+        for (const auto& attr : attrs) {\n+            if (attr.get_path() == name) {\n+                return true;\n+            }\n+        }\n \n-// TODO: move somewhere else\n-bool\n-contains_name (::std::vector<AST::Attribute> attrs, ::std::string name)\n-{\n-  for (const auto &attr : attrs)\n-    {\n-      if (attr.get_path () == name)\n-\t{\n-\t  return true;\n-\t}\n+        return false;\n     }\n \n-  return false;\n-}\n-\n-void\n-Session::injection (AST::Crate &crate)\n-{\n-  fprintf (stderr, \"started injection\\n\");\n-\n-  // lint checks in future maybe?\n-\n-  // register builtin macros\n-  /* In rustc, builtin macros are divided into 3 categories depending on use -\n-   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings of\n-   * these categories should be fairly obvious to anyone who has used rust.\n-   * Builtin macro list by category: Bang\n-   *      - asm\n-   *      - assert\n-   *      - cfg\n-   *      - column\n-   *      - compile_error\n-   *      - concat_idents\n-   *      - concat\n-   *      - env\n-   *      - file\n-   *      - format_args_nl\n-   *      - format_args\n-   *      - global_asm\n-   *      - include_bytes\n-   *      - include_str\n-   *      - include\n-   *      - line\n-   *      - log_syntax\n-   *      - module_path\n-   *      - option_env\n-   *      - stringify\n-   *      - trace_macros\n-   *  Attr\n-   *      - bench\n-   *      - global_allocator\n-   *      - test\n-   *      - test_case\n-   *  Derive\n-   *      - Clone\n-   *      - Copy\n-   *      - Debug\n-   *      - Default\n-   *      - Eq\n-   *      - Hash\n-   *      - Ord\n-   *      - PartialEq\n-   *      - PartialOrd\n-   *      - RustcDecodable\n-   *      - RustcEncodable\n-   * rustc also has a \"quote\" macro that is defined differently and is\n-   * supposedly not stable so eh. */\n-  /* TODO: actually implement injection of these macros. In particular, derive\n-   * macros, cfg, and\n-   * test should be prioritised since they seem to be used the most. */\n-\n-  // crate injection\n-  ::std::vector< ::std::string> names;\n-  if (contains_name (crate.inner_attrs, \"no_core\"))\n-    {\n-      // no prelude\n-      injected_crate_name = \"\";\n+    void Session::injection(AST::Crate& crate) {\n+        fprintf(stderr, \"started injection\\n\");\n+\n+        // lint checks in future maybe?\n+\n+        // register builtin macros\n+        /* In rustc, builtin macros are divided into 3 categories depending on use - \"bang\" macros,\n+         * \"attr\" macros, and \"derive\" macros. I think the meanings of these categories should be\n+         * fairly obvious to anyone who has used rust. Builtin macro list by category: Bang\n+         *      - asm\n+         *      - assert\n+         *      - cfg\n+         *      - column\n+         *      - compile_error\n+         *      - concat_idents\n+         *      - concat\n+         *      - env\n+         *      - file\n+         *      - format_args_nl\n+         *      - format_args\n+         *      - global_asm\n+         *      - include_bytes\n+         *      - include_str\n+         *      - include\n+         *      - line\n+         *      - log_syntax\n+         *      - module_path\n+         *      - option_env\n+         *      - stringify\n+         *      - trace_macros\n+         *  Attr\n+         *      - bench\n+         *      - global_allocator\n+         *      - test\n+         *      - test_case\n+         *  Derive\n+         *      - Clone\n+         *      - Copy\n+         *      - Debug\n+         *      - Default\n+         *      - Eq\n+         *      - Hash\n+         *      - Ord\n+         *      - PartialEq\n+         *      - PartialOrd\n+         *      - RustcDecodable\n+         *      - RustcEncodable\n+         * rustc also has a \"quote\" macro that is defined differently and is supposedly not stable so\n+         * eh. */\n+        /* TODO: actually implement injection of these macros. In particular, derive macros, cfg, and\n+         * test should be prioritised since they seem to be used the most. */\n+\n+        // crate injection\n+        ::std::vector< ::std::string> names;\n+        if (contains_name(crate.inner_attrs, \"no_core\")) {\n+            // no prelude\n+            injected_crate_name = \"\";\n+        } else if (contains_name(crate.inner_attrs, \"no_std\")) {\n+            names.push_back(\"core\");\n+\n+            if (!contains_name(crate.inner_attrs, \"compiler_builtins\")) {\n+                names.push_back(\"compiler_builtins\");\n+            }\n+\n+            injected_crate_name = \"core\";\n+        } else {\n+            names.push_back(\"std\");\n+\n+            injected_crate_name = \"std\";\n+        }\n+\n+        // reverse iterate through names to insert crate items in \"forward\" order at beginning of\n+        // crate\n+        for (auto it = names.rbegin(); it != names.rend(); ++it) {\n+            // create \"macro use\" attribute for use on extern crate item to enable loading macros from\n+            // it\n+            AST::Attribute attr(AST::SimplePath::from_str(\"macro_use\"), NULL);\n+\n+            // create \"extern crate\" item with the name\n+            ::std::unique_ptr<AST::ExternCrate> extern_crate(\n+              new AST::ExternCrate(*it, AST::Visibility::create_error(), { ::std::move(attr) },\n+              Linemap::unknown_location()));\n+\n+            // insert at beginning\n+            crate.items.insert(crate.items.begin(), ::std::move(extern_crate));\n+        }\n+\n+        // create use tree path\n+        // prelude is injected_crate_name\n+        ::std::vector<AST::SimplePathSegment> segments\n+          = { AST::SimplePathSegment(injected_crate_name), AST::SimplePathSegment(\"prelude\"),\n+                AST::SimplePathSegment(\"v1\") };\n+        // create use tree and decl\n+        ::std::unique_ptr<AST::UseTreeGlob> use_tree(new AST::UseTreeGlob(\n+          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), Location()));\n+        AST::Attribute prelude_attr(AST::SimplePath::from_str(\"prelude_import\"), NULL);\n+        ::std::unique_ptr<AST::UseDeclaration> use_decl(new AST::UseDeclaration(::std::move(use_tree),\n+          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, Location()));\n+\n+        crate.items.insert(crate.items.begin(), ::std::move(use_decl));\n+\n+        /* TODO: potentially add checking attribute crate type? I can't figure out what this does\n+         * currently comment says \"Unconditionally collect crate types from attributes to make them\n+         * used\", which presumably refers to checking the linkage info by \"crate_type\". It also seems\n+         * to ensure that an invalid crate type is not specified, so maybe just do that. Valid crate\n+         * types: bin lib dylib staticlib cdylib rlib proc-macro */\n+\n+        fprintf(stderr, \"finished injection\\n\");\n     }\n-  else if (contains_name (crate.inner_attrs, \"no_std\"))\n-    {\n-      names.push_back (\"core\");\n \n-      if (!contains_name (crate.inner_attrs, \"compiler_builtins\"))\n-\t{\n-\t  names.push_back (\"compiler_builtins\");\n-\t}\n+    void Session::expansion(AST::Crate& crate ATTRIBUTE_UNUSED) {\n+        fprintf(stderr, \"started expansion\\n\");\n \n-      injected_crate_name = \"core\";\n-    }\n-  else\n-    {\n-      names.push_back (\"std\");\n+        // rustc has a modification to windows PATH temporarily here, which may end up being required\n \n-      injected_crate_name = \"std\";\n-    }\n-\n-  // reverse iterate through names to insert crate items in \"forward\" order\n-  // at beginning of crate\n-  for (auto it = names.rbegin (); it != names.rend (); ++it)\n-    {\n-      // create \"macro use\" attribute for use on extern crate item to enable\n-      // loading macros from it\n-      AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\"), NULL);\n-\n-      // create \"extern crate\" item with the name\n-      ::std::unique_ptr<AST::ExternCrate> extern_crate (\n-\tnew AST::ExternCrate (*it, AST::Visibility::create_error (),\n-\t\t\t      {::std::move (attr)},\n-\t\t\t      Linemap::unknown_location ()));\n-\n-      // insert at beginning\n-      crate.items.insert (crate.items.begin (), ::std::move (extern_crate));\n-    }\n+        // create macro expansion config?\n+        // if not, would at least have to configure recursion_limit\n \n-  // create use tree path\n-  // prelude is injected_crate_name\n-  ::std::vector<AST::SimplePathSegment> segments\n-    = {AST::SimplePathSegment (injected_crate_name),\n-       AST::SimplePathSegment (\"prelude\"), AST::SimplePathSegment (\"v1\")};\n-  // create use tree and decl\n-  ::std::unique_ptr<AST::UseTreeGlob> use_tree (\n-    new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n-\t\t\t  AST::SimplePath (::std::move (segments)),\n-\t\t\t  Location ()));\n-  AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\"),\n-\t\t\t       NULL);\n-  ::std::unique_ptr<AST::UseDeclaration> use_decl (\n-    new AST::UseDeclaration (::std::move (use_tree),\n-\t\t\t     AST::Visibility::create_error (),\n-\t\t\t     {::std::move (prelude_attr)}, Location ()));\n-\n-  crate.items.insert (crate.items.begin (), ::std::move (use_decl));\n-\n-  /* TODO: potentially add checking attribute crate type? I can't figure out\n-   * what this does currently comment says \"Unconditionally collect crate\n-   * types from attributes to make them used\", which presumably refers to\n-   * checking the linkage info by \"crate_type\". It also seems to ensure that\n-   * an invalid crate type is not specified, so maybe just do that. Valid\n-   * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n-\n-  fprintf (stderr, \"finished injection\\n\");\n-}\n+        // create extctxt? from parse session, cfg, and resolver?\n+        // expand by calling cxtctxt object's monotonic_expander's expand_crate method.\n \n-void\n-Session::expansion (AST::Crate &crate ATTRIBUTE_UNUSED)\n-{\n-  fprintf (stderr, \"started expansion\\n\");\n+        // error reporting - check unused macros, get missing fragment specifiers\n \n-  // rustc has a modification to windows PATH temporarily here, which may end\n-  // up being required\n+        // build test harness\n \n-  // create macro expansion config?\n-  // if not, would at least have to configure recursion_limit\n+        // ast validation (also with proc macro decls)\n \n-  // create extctxt? from parse session, cfg, and resolver?\n-  // expand by calling cxtctxt object's monotonic_expander's expand_crate\n-  // method.\n+        // maybe create macro crate if not rustdoc\n \n-  // error reporting - check unused macros, get missing fragment specifiers\n+        fprintf(stderr, \"finished expansion\\n\");\n+    }\n \n-  // build test harness\n+    void Session::name_resolution(AST::Crate& crate ATTRIBUTE_UNUSED) {\n+        fprintf(stderr, \"started name resolution\\n\");\n \n-  // ast validation (also with proc macro decls)\n+        fprintf(stderr, \"finished name resolution\\n\");\n+    }\n \n-  // maybe create macro crate if not rustdoc\n+    void TargetOptions::dump_target_options() const {\n+        fprintf(stderr, \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n+        for (const auto& pairs : features) {\n+            for (const auto& value : pairs.second) {\n+                fprintf(stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str(), value.c_str());\n+            }\n+            if (pairs.second.empty()) {\n+                fprintf(stderr, \"%s\\n\", pairs.first.c_str());\n+            }\n+        }\n+        if (features.empty()) {\n+            fprintf(stderr, \"No target options available!\\n\");\n+        }\n+\n+        fprintf(stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n+    }\n \n-  fprintf (stderr, \"finished expansion\\n\");\n-}\n+    void TargetOptions::init_derived_values() {\n+        // enable derived values based on target families\n+        if (has_key_value_pair(\"target_family\", \"unix\"))\n+            insert_key(\"unix\");\n+        if (has_key_value_pair(\"target_family\", \"windows\"))\n+            insert_key(\"windows\");\n+        \n+        // implicitly enable features\n+        if (has_key_value_pair(\"target_feature\", \"aes\"))\n+            enable_implicit_feature_reqs(\"aes\");\n+        if (has_key_value_pair(\"target_feature\", \"avx\"))\n+            enable_implicit_feature_reqs(\"sse4.2\");\n+        if (has_key_value_pair(\"target_feature\", \"avx2\"))\n+            enable_implicit_feature_reqs(\"avx\");\n+        if (has_key_value_pair(\"target_feature\", \"pclmulqdq\"))\n+            enable_implicit_feature_reqs(\"sse2\");\n+        if (has_key_value_pair(\"target_feature\", \"sha\"))\n+            enable_implicit_feature_reqs(\"sse2\");\n+        if (has_key_value_pair(\"target_feature\", \"sse2\"))\n+            enable_implicit_feature_reqs(\"sse\");\n+        if (has_key_value_pair(\"target_feature\", \"sse3\"))\n+            enable_implicit_feature_reqs(\"sse2\");\n+        if (has_key_value_pair(\"target_feature\", \"sse4.1\"))\n+            enable_implicit_feature_reqs(\"sse3\");\n+        if (has_key_value_pair(\"target_feature\", \"sse4.2\"))\n+            enable_implicit_feature_reqs(\"sse4.1\");\n+        if (has_key_value_pair(\"target_feature\", \"ssse3\"))\n+            enable_implicit_feature_reqs(\"sse3\");\n+    }\n \n-void\n-Session::name_resolution (AST::Crate &crate ATTRIBUTE_UNUSED)\n-{\n-  fprintf (stderr, \"started name resolution\\n\");\n+    void TargetOptions::enable_implicit_feature_reqs(std::string feature) {\n+        if (feature == \"aes\") \n+            enable_implicit_feature_reqs(\"sse2\");\n+        else if (feature == \"avx\")\n+            enable_implicit_feature_reqs(\"sse4.2\");\n+        else if (feature == \"avx2\")\n+            enable_implicit_feature_reqs(\"avx\");\n+        else if (feature == \"fma\")\n+            enable_implicit_feature_reqs(\"avx\");\n+        else if (feature == \"pclmulqdq\") \n+            enable_implicit_feature_reqs(\"sse2\");\n+        else if (feature == \"sha\")\n+            enable_implicit_feature_reqs(\"sse2\");\n+        else if (feature == \"sse2\")\n+            enable_implicit_feature_reqs(\"sse\");\n+        else if (feature == \"sse3\")\n+            enable_implicit_feature_reqs(\"sse2\");\n+        else if (feature == \"sse4.1\")\n+            enable_implicit_feature_reqs(\"sse3\");\n+        else if (feature == \"sse4.2\")\n+            enable_implicit_feature_reqs(\"sse4.1\");\n+        else if (feature == \"ssse3\")\n+            enable_implicit_feature_reqs(\"sse3\");\n+\n+        if (!has_key_value_pair(\"target_feature\", feature))\n+            insert_key_value_pair(\"target_feature\", feature);\n+    }\n \n-  fprintf (stderr, \"finished name resolution\\n\");\n+    // NOTEs:\n+    /* mrustc compile pipeline:\n+     *  - target load (pass target spec to parser?)\n+     *  - parse (convert source to AST)\n+     *  - load crates (load any explicitly mentioned extern crates [not all of them])\n+     *  - expand (AST transformations from attributes and macros, loads remaining extern crates\n+     * [std/core and any triggered by macro expansion])\n+     *  - implicit crates (test harness, allocator crate, panic crate)\n+     *  - resolve use (annotate every 'use' item with source [supposedly handles nasty recursion])\n+     *  - resolve index (generate index of visible items for every module [avoids recursion in next\n+     * pass])\n+     *  - resolve absolute (resolve all paths into either variable names [types/values] or absolute\n+     * paths)\n+     *  - HIR lower (convert modified AST to simpler HIR [both expressions and module tree])\n+     *  - resolve type aliases (replace any usages of type aliases with actual type [except associated\n+     *    types])\n+     *  - resolve bind (iterate HIR tree and set binding annotations on all concrete types [avoids\n+     * path lookups later])\n+     *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...] for all types\n+     *  - sort impls (small pass - sort impls into groups)\n+     *  - resolve UFCS outer (determine source trait for all top-level <T>::Type [qualified] paths)\n+     *  - resolve UFCS paths (do the same, but include for exprs this time. also normalises results of\n+     *    previous pass [expanding known associated types])\n+     *  - constant evaluate (evaluate all constants)\n+     *  - typecheck outer (checks impls are sane)\n+     *  - typecheck expressions (resolve and check types for all exprs)\n+     *  - expand HIR annotate (annotate how exprs are used - used for closure extractions and\n+     * reborrows)\n+     *  - expand HIR closures (extract closures into structs implementing Fn* traits)\n+     *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n+     *  - expand HIR calls (converts method and callable calls into explicit function calls)\n+     *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of 'v'])\n+     *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true type)\n+     *  - typecheck expressions (validate - double check that previous passes haven't broke type\n+     * system rules)\n+     *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n+     *  - MIR validate (check that the generated MIR is consistent)\n+     *  - MIR cleanup (perform various transformations on MIR - replace reads of const items with the\n+     * item itself; convert casts to unsized types into 'MakeDst' operations)\n+     *  - MIR optimise (perform various simple optimisations on the MIR - constant propagation, dead\n+     * code elimination, borrow elimination, some inlining)\n+     *  - MIR validate PO (re-validate the MIR)\n+     *  - MIR validate full (optionally: perform expensive state-tracking validation on MIR)\n+     *  - trans enumerate (enumerate all items needed for code generation, primarily types used for\n+     * generics)\n+     *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n+     *  - trans monomorph (generate monomorphised copies of all functions [with generics replaced with\n+     * real types])\n+     *  - MIR optimise inline (run optimisation again, this time with full type info [primarily for\n+     * inlining])\n+     *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n+     *  - trans codegen (generate final output file: emit C source file and call C compiler) */\n+\n+    /* rustc compile pipeline (basic, in way less detail):\n+     *  - parse input (parse .rs to AST)\n+     *  - name resolution, macro expansion, and configuration (process AST recursively, resolving\n+     * paths, expanding macros, processing #[cfg] nodes [i.e. maybe stripping stuff from AST])\n+     *  - lower to HIR\n+     *  - type check and other analyses (e.g. privacy checking)\n+     *  - lower to MIR and post-processing (and do stuff like borrow checking)\n+     *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n+     *  - linking (link together .o files) */\n+\n+    /* Pierced-together rustc compile pipeline (from source):\n+     *  - parse input (parse file to crate)\n+     *  - register plugins (attributes injection, set various options, register lints, load plugins)\n+     *  - expansion/configure and expand (initial 'cfg' processing, 'loading compiler plugins',\n+     *    syntax expansion, secondary 'cfg' expansion, synthesis of a test harness if required,\n+     * injection of any std lib dependency and prelude, and name resolution) - actually documented\n+     * inline\n+     *      - seeming pierced-together order: pre-AST expansion lint checks, registering builtin\n+     * macros, crate injection, then expand all macros, then maybe build test harness, AST validation,\n+     *        maybe create a macro crate (if not rustdoc), name resolution, complete gated feature\n+     * checking, add all buffered lints\n+     *  - create global context (lower to HIR)\n+     *  - analysis on global context (HIR optimisations? create MIR?)\n+     *  - code generation\n+     *  - link */\n }\n-\n-// NOTEs:\n-/* mrustc compile pipeline:\n- *  - target load (pass target spec to parser?)\n- *  - parse (convert source to AST)\n- *  - load crates (load any explicitly mentioned extern crates [not all of\n- * them])\n- *  - expand (AST transformations from attributes and macros, loads remaining\n- * extern crates [std/core and any triggered by macro expansion])\n- *  - implicit crates (test harness, allocator crate, panic crate)\n- *  - resolve use (annotate every 'use' item with source [supposedly handles\n- * nasty recursion])\n- *  - resolve index (generate index of visible items for every module [avoids\n- * recursion in next pass])\n- *  - resolve absolute (resolve all paths into either variable names\n- * [types/values] or absolute paths)\n- *  - HIR lower (convert modified AST to simpler HIR [both expressions and\n- * module tree])\n- *  - resolve type aliases (replace any usages of type aliases with actual\n- * type [except associated types])\n- *  - resolve bind (iterate HIR tree and set binding annotations on all\n- * concrete types [avoids path lookups later])\n- *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...]\n- * for all types\n- *  - sort impls (small pass - sort impls into groups)\n- *  - resolve UFCS outer (determine source trait for all top-level <T>::Type\n- * [qualified] paths)\n- *  - resolve UFCS paths (do the same, but include for exprs this time. also\n- * normalises results of previous pass [expanding known associated types])\n- *  - constant evaluate (evaluate all constants)\n- *  - typecheck outer (checks impls are sane)\n- *  - typecheck expressions (resolve and check types for all exprs)\n- *  - expand HIR annotate (annotate how exprs are used - used for closure\n- * extractions and reborrows)\n- *  - expand HIR closures (extract closures into structs implementing Fn*\n- * traits)\n- *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n- *  - expand HIR calls (converts method and callable calls into explicit\n- * function calls)\n- *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of\n- * 'v'])\n- *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the\n- * true type)\n- *  - typecheck expressions (validate - double check that previous passes\n- * haven't broke type system rules)\n- *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n- *  - MIR validate (check that the generated MIR is consistent)\n- *  - MIR cleanup (perform various transformations on MIR - replace reads of\n- * const items with the item itself; convert casts to unsized types into\n- * 'MakeDst' operations)\n- *  - MIR optimise (perform various simple optimisations on the MIR - constant\n- * propagation, dead code elimination, borrow elimination, some inlining)\n- *  - MIR validate PO (re-validate the MIR)\n- *  - MIR validate full (optionally: perform expensive state-tracking\n- * validation on MIR)\n- *  - trans enumerate (enumerate all items needed for code generation,\n- * primarily types used for generics)\n- *  - trans auto impls (create magic trait impls as enumerated in previous\n- * pass)\n- *  - trans monomorph (generate monomorphised copies of all functions [with\n- * generics replaced with real types])\n- *  - MIR optimise inline (run optimisation again, this time with full type\n- * info [primarily for inlining])\n- *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n- *  - trans codegen (generate final output file: emit C source file and call C\n- * compiler) */\n-\n-/* rustc compile pipeline (basic, in way less detail):\n- *  - parse input (parse .rs to AST)\n- *  - name resolution, macro expansion, and configuration (process AST\n- * recursively, resolving paths, expanding macros, processing #[cfg] nodes\n- * [i.e. maybe stripping stuff from AST])\n- *  - lower to HIR\n- *  - type check and other analyses (e.g. privacy checking)\n- *  - lower to MIR and post-processing (and do stuff like borrow checking)\n- *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n- *  - linking (link together .o files) */\n-\n-/* Pierced-together rustc compile pipeline (from source):\n- *  - parse input (parse file to crate)\n- *  - register plugins (attributes injection, set various options, register\n- * lints, load plugins)\n- *  - expansion/configure and expand (initial 'cfg' processing, 'loading\n- * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis\n- * of a test harness if required, injection of any std lib dependency and\n- * prelude, and name resolution) - actually documented inline\n- *      - seeming pierced-together order: pre-AST expansion lint checks,\n- * registering builtin macros, crate injection, then expand all macros, then\n- * maybe build test harness, AST validation, maybe create a macro crate (if\n- * not rustdoc), name resolution, complete gated feature checking, add all\n- * buffered lints\n- *  - create global context (lower to HIR)\n- *  - analysis on global context (HIR optimisations? create MIR?)\n- *  - code generation\n- *  - link */\n-} // namespace Rust"}, {"sha": "ee43232c758c18ae3746c3c5cfbdac493968ee21", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 178, "deletions": 200, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -18,206 +18,184 @@\n #include <utility>\n \n namespace Rust {\n-// parser forward decl\n-class Parser;\n-// crate forward decl\n-namespace AST {\n-struct Crate;\n+    // parser forward decl\n+    class Parser;\n+    // crate forward decl\n+    namespace AST {\n+        struct Crate;\n+    }\n+\n+    // Data related to target, most useful for conditional compilation and whatever.\n+    struct TargetOptions {\n+        // TODO: maybe make private and access through helpers to allow changes to impl\n+        std::unordered_map<std::string, std::unordered_set<std::string>> features;\n+\n+      public:\n+        // Returns whether a key is defined in the feature set.\n+        bool has_key(std::string key) const {\n+            return features.find(key) != features.end();\n+        }\n+\n+        // Returns whether a key exists with the given value in the feature set.\n+        bool has_key_value_pair(std::string key, std::string value) const {\n+            auto it = features.find(key);\n+            if (it != features.end()) {\n+                auto set = it->second;\n+                auto it2 = set.find(value);\n+                if (it2 != set.end())\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        // Returns the singular value from the key, or if the key has multiple, an empty string.\n+        std::string get_singular_value(std::string key) const {\n+            auto it = features.find(key);\n+            if (it != features.end()) {\n+                auto set = it->second;\n+                if (set.size() == 1)\n+                    return *set.begin();\n+            }\n+            return \"\";\n+        }\n+\n+        // Returns all values associated with a key (including none), or an empty set if no key is found.\n+        std::unordered_set< ::std::string> get_values_for_key(std::string key) const {\n+            auto it = features.find(key);\n+            if (it != features.end()) {\n+                return it->second;\n+            }\n+            return {};\n+        }\n+\n+        /* Inserts a key (no value) into the feature set. This will do nothing if the key already exists. \n+         * This returns whether the insertion was successful (i.e. whether key already existed). */\n+        bool insert_key(std::string key) {\n+            return features.insert(std::make_pair(key, std::unordered_set<std::string>())).second;\n+        }\n+\n+        // Inserts a key-value pair into the feature set. \n+        void insert_key_value_pair(std::string key, std::string value) {\n+            auto existing_set = get_values_for_key(key);\n+            existing_set.insert(std::move(value));\n+            features[std::move(key)] = std::move(existing_set);\n+        }\n+\n+        // Dump all target options to stderr.\n+        void dump_target_options() const; \n+\n+        // Creates derived values and implicit enables after all target info is added (e.g. \"unix\").\n+        void init_derived_values();\n+\n+        // Enables all requirements for the feature given, and will enable feature itself if not enabled.\n+        void enable_implicit_feature_reqs(std::string feature);\n+\n+        /* According to reference, Rust uses either multi-map key-values or just values (although\n+         * values may be aliases for a key-value value). This seems like overkill. Thus, depending on\n+         * whether the attributes used in cfg are fixed or not, I think I'll either put each\n+         * non-multimap \"key-value\" as a separate field and have the multimap \"key-values\" in a\n+         * regular map for that one key, or actually use a multimap.\n+         *\n+         * rustc itself uses a set of key-value tuples where the second tuple element is optional.\n+         * This gets rid of the requirement to make a multi-map, I guess, but seems like it might make\n+         * search slow (unless all \"is defined\"-only ones have empty string as second element). */\n+        /* cfg attributes:\n+         * - target_arch: single value\n+         * - target_feature: multiple values possible\n+         * - target_os: single value\n+         * - target_family: single value (or no value?)\n+         * - unix: set when target_family = \"unix\"\n+         * - windows: set when target_family = \"windows\"\n+         *  - if these are just syntactic sugar, then maybe have a separate set or map for this kind\n+         * of stuff\n+         * - target_env: set when needed for disambiguation about ABI - usually empty string for GNU,\n+         * complicated\n+         *  - seems to be a single value (if any)\n+         * - target_endian: single value; \"little\" or \"big\"\n+         * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n+         * - target_vendor, single value\n+         * - test: set when testing is being done\n+         *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like unix\n+         * - debug_assertions: seems to \"is defined\"\n+         * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\" */\n+    };\n+\n+    // Defines compiler options (e.g. dump, etc.).\n+    struct CompileOptions {\n+        // TODO: use bitfield for smaller memory requirements?\n+\n+        // FIXME: this is set up for \"instead of\" dumping - in future, dumps should not inhibit\n+        // compilation\n+        enum DumpOptions {\n+            NO_DUMP,\n+            LEXER_DUMP,\n+            PARSER_AST_DUMP,\n+            REGISTER_PLUGINS_DUMP,\n+            INJECTION_DUMP,\n+            EXPANSION_DUMP,\n+            NAME_RESOLUTION_DUMP,\n+            TARGET_OPTION_DUMP,\n+            // TODO: add more?\n+        } dump_option;\n+\n+        // configuration options - actually useful for conditional compilation and whatever\n+        // data related to target arch, features, os, family, env, endian, pointer width, vendor\n+        TargetOptions target_data;\n+        bool enable_test = false;\n+        bool debug_assertions = false;\n+        bool proc_macro = false;\n+    };\n+\n+    /* Defines a compiler session. This is for a single compiler invocation, so potentially includes\n+     * parsing multiple crates. */\n+    struct Session {\n+        CompileOptions options;\n+        // This should really be in a per-crate storage area but it is wiped with every file so eh.\n+        ::std::string injected_crate_name;\n+\n+        // backend wrapper to GCC GENERIC\n+        Backend* backend;\n+\n+        // backend linemap\n+        Linemap* linemap;\n+\n+        // TODO: replace raw pointers with smart pointers?\n+\n+      public:\n+        /* Initialise compiler session. Corresponds to langhook grs_langhook_init(). Note that this is\n+         * called after option handling. */\n+        void init();\n+        bool handle_option(enum opt_code code, const char* arg, HOST_WIDE_INT value, int kind,\n+          location_t loc, const struct cl_option_handlers* handlers);\n+        void parse_files(int num_files, const char** files);\n+        void init_options();\n+\n+      private:\n+        // TODO: should this be private or public?\n+        void parse_file(const char* filename);\n+        bool enable_dump(::std::string arg);\n+\n+        void debug_dump_load_crates(Parser& parser);\n+\n+        void implicitly_enable_feature(::std::string feature_name);\n+        void enable_features();\n+\n+        // pipeline stages - TODO maybe move?\n+        /* Register plugins pipeline stage. TODO maybe move to another object? Currently dummy stage.\n+         * In future will handle attribute injection (top-level inner attribute creation from command\n+         * line arguments), setting options maybe, registering lints maybe, loading plugins maybe. */\n+        void register_plugins(AST::Crate& crate);\n+        /* Injection pipeline stage. TODO maybe move to another object? Maybe have some lint checks\n+         * (in future, obviously), register builtin macros, crate injection. */\n+        void injection(AST::Crate& crate);\n+        /* Expansion pipeline stage. TODO maybe move to another object? Expands all macros, maybe\n+         * build test harness in future, AST validation, maybe create macro crate (if not rustdoc).*/\n+        void expansion(AST::Crate& crate);\n+        /* Name resolution pipeline stage. TODO maybe move to another object. Performs name\n+         * resolution, maybe complete gated feature checking, maybe create buffered lints in future.\n+         */\n+        void name_resolution(AST::Crate& crate);\n+    };\n }\n \n-// Data related to target, most useful for conditional compilation and whatever.\n-struct TargetOptions\n-{\n-  // TODO: maybe make private and access through helpers to allow changes to\n-  // impl\n-  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n-\n-public:\n-  // Returns whether a key is defined in the feature set.\n-  bool has_key (std::string key) const\n-  {\n-    return features.find (key) != features.end ();\n-  }\n-\n-  // Returns whether a key exists with the given value in the feature set.\n-  bool has_key_value_pair (std::string key, std::string value) const\n-  {\n-    auto it = features.find (key);\n-    if (it != features.end ())\n-      {\n-\tauto set = it->second;\n-\tauto it2 = set.find (value);\n-\tif (it2 != set.end ())\n-\t  return true;\n-      }\n-    return false;\n-  }\n-\n-  // Returns the singular value from the key, or if the key has multiple, an\n-  // empty string.\n-  std::string get_singular_value (std::string key) const\n-  {\n-    auto it = features.find (key);\n-    if (it != features.end ())\n-      {\n-\tauto set = it->second;\n-\tif (set.size () == 1)\n-\t  return *set.begin ();\n-      }\n-    return \"\";\n-  }\n-\n-  // Returns all values associated with a key (including none), or an empty set\n-  // if no key is found.\n-  std::unordered_set< ::std::string> get_values_for_key (std::string key) const\n-  {\n-    auto it = features.find (key);\n-    if (it != features.end ())\n-      {\n-\treturn it->second;\n-      }\n-    return {};\n-  }\n-\n-  /* Inserts a key (no value) into the feature set. This will do nothing if the\n-   * key already exists.\n-   * This returns whether the insertion was successful (i.e. whether key already\n-   * existed). */\n-  bool insert_key (std::string key)\n-  {\n-    return features\n-      .insert (std::make_pair (key, std::unordered_set<std::string> ()))\n-      .second;\n-  }\n-\n-  // Inserts a key-value pair into the feature set.\n-  void insert_key_value_pair (std::string key, std::string value)\n-  {\n-    auto existing_set = get_values_for_key (key);\n-    existing_set.insert (std::move (value));\n-    features[std::move (key)] = std::move (existing_set);\n-  }\n-\n-  /* According to reference, Rust uses either multi-map key-values or just\n-   * values (although values may be aliases for a key-value value). This seems\n-   * like overkill. Thus, depending on whether the attributes used in cfg are\n-   * fixed or not, I think I'll either put each non-multimap \"key-value\" as a\n-   * separate field and have the multimap \"key-values\" in a regular map for that\n-   * one key, or actually use a multimap.\n-   *\n-   * rustc itself uses a set of key-value tuples where the second tuple element\n-   * is optional. This gets rid of the requirement to make a multi-map, I guess,\n-   * but seems like it might make\n-   * search slow (unless all \"is defined\"-only ones have empty string as second\n-   * element). */\n-  /* cfg attributes:\n-   * - target_arch: single value\n-   * - target_feature: multiple values possible\n-   * - target_os: single value\n-   * - target_family: single value (or no value?)\n-   * - unix: set when target_family = \"unix\"\n-   * - windows: set when target_family = \"windows\"\n-   *  - if these are just syntactic sugar, then maybe have a separate set or map\n-   * for this kind of stuff\n-   * - target_env: set when needed for disambiguation about ABI - usually empty\n-   * string for GNU, complicated\n-   *  - seems to be a single value (if any)\n-   * - target_endian: single value; \"little\" or \"big\"\n-   * - target_pointer_width: single value, \"32\" for 32-bit pointers, etc.\n-   * - target_vendor, single value\n-   * - test: set when testing is being done\n-   *  - again, seems similar to a \"is defined\" rather than \"is equal to\" like\n-   * unix\n-   * - debug_assertions: seems to \"is defined\"\n-   * - proc_macro: no idea, bad docs. seems to be boolean, so maybe \"is defined\"\n-   */\n-};\n-\n-// Defines compiler options (e.g. dump, etc.).\n-struct CompileOptions\n-{\n-  // TODO: use bitfield for smaller memory requirements?\n-\n-  // FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n-  // not inhibit compilation\n-  enum DumpOptions\n-  {\n-    NO_DUMP,\n-    LEXER_DUMP,\n-    PARSER_AST_DUMP,\n-    REGISTER_PLUGINS_DUMP,\n-    INJECTION_DUMP,\n-    EXPANSION_DUMP,\n-    NAME_RESOLUTION_DUMP,\n-    // TODO: add more?\n-  } dump_option;\n-\n-  // configuration options - actually useful for conditional compilation and\n-  // whatever data related to target arch, features, os, family, env, endian,\n-  // pointer width, vendor\n-  TargetOptions target_data;\n-  bool enable_test = false;\n-  bool debug_assertions = false;\n-  bool proc_macro = false;\n-};\n-\n-/* Defines a compiler session. This is for a single compiler invocation, so\n- * potentially includes parsing multiple crates. */\n-struct Session\n-{\n-  CompileOptions options;\n-  // This should really be in a per-crate storage area but it is wiped with\n-  // every file so eh.\n-  ::std::string injected_crate_name;\n-\n-  // backend wrapper to GCC GENERIC\n-  Backend *backend;\n-\n-  // backend linemap\n-  Linemap *linemap;\n-\n-  // TODO: replace raw pointers with smart pointers?\n-\n-public:\n-  /* Initialise compiler session. Corresponds to langhook grs_langhook_init().\n-   * Note that this is called after option handling. */\n-  void init ();\n-  bool handle_option (enum opt_code code, const char *arg, HOST_WIDE_INT value,\n-\t\t      int kind, location_t loc,\n-\t\t      const struct cl_option_handlers *handlers);\n-  void parse_files (int num_files, const char **files);\n-  void init_options ();\n-\n-private:\n-  // TODO: should this be private or public?\n-  void parse_file (const char *filename);\n-  bool enable_dump (::std::string arg);\n-\n-  void debug_dump_load_crates (Parser &parser);\n-\n-  void implicitly_enable_feature (::std::string feature_name);\n-  void enable_features ();\n-\n-  // pipeline stages - TODO maybe move?\n-  /* Register plugins pipeline stage. TODO maybe move to another object?\n-   * Currently dummy stage. In future will handle attribute injection (top-level\n-   * inner attribute creation from command line arguments), setting options\n-   * maybe, registering lints maybe, loading plugins maybe. */\n-  void register_plugins (AST::Crate &crate);\n-  /* Injection pipeline stage. TODO maybe move to another object? Maybe have\n-   * some lint checks (in future, obviously), register builtin macros, crate\n-   * injection. */\n-  void injection (AST::Crate &crate);\n-  /* Expansion pipeline stage. TODO maybe move to another object? Expands all\n-   * macros, maybe build test harness in future, AST validation, maybe create\n-   * macro crate (if not rustdoc).*/\n-  void expansion (AST::Crate &crate);\n-  /* Name resolution pipeline stage. TODO maybe move to another object. Performs\n-   * name resolution, maybe complete gated feature checking, maybe create\n-   * buffered lints in future.\n-   */\n-  void name_resolution (AST::Crate &crate);\n-};\n-} // namespace Rust\n-\n #endif"}, {"sha": "13cf3e5ef93895d56fc2cbb0db56e3b52a5b5a55", "filename": "gcc/rust/rust-target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Frust-target.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2/gcc%2Frust%2Frust-target.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-target.def?ref=c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "patch": "@@ -43,7 +43,7 @@ predefined by this hook apply to all files that are being compiled.\",\n /* Environmental OS info relating to the target OS.  */\n DEFHOOK\n (/*d_os_versions*/rust_os_info,\n- \"Similarly to @code{TARGET_RUST_CPU_INFO}, but is used for configuration info\\n\\\n+ \"Similar to @code{TARGET_RUST_CPU_INFO}, but is used for configuration info\\n\\\n relating to the target operating system.\",\n  void, (void),\n  hook_void_void)"}]}