{"sha": "6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVjNmQ1NThlZDM0ZTZiMzFhNWI5ODRjZjZmYjllYWQ2YTZhYzdiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-04-15T01:28:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-15T01:28:04Z"}, "message": "i386.md (ashlsi patterns): Call output_ashl instead of output_ashlsi3.\n\n        * i386.md (ashlsi patterns): Call output_ashl instead of output_ashlsi3.\n        (ashlqi): Use expander, separate LEA and SAL / ADD patterns; call\n        output_ashl.\n        (ashlhi): Likewise.\n        * i386.h (output_ashl): Renamed from output_ashlsi3.\n        * i386.c (output_ashl): Likewise; support HImode and QImode operands\n        as well.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r26467", "tree": {"sha": "b8c13a2285138948aa5081bd3b92d4bcbe478ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8c13a2285138948aa5081bd3b92d4bcbe478ad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/comments", "author": null, "committer": null, "parents": [{"sha": "ad98bad83e190ee6610068730e316bf4511aa1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad98bad83e190ee6610068730e316bf4511aa1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad98bad83e190ee6610068730e316bf4511aa1f6"}], "stats": {"total": 190, "additions": 127, "deletions": 63}, "files": [{"sha": "30d9a68c27623596297d52a9fc13bce57141c4b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "patch": "@@ -1,6 +1,14 @@\n Thu Apr 15 01:03:21 1999  Jan Hubicka <hubicka@freesoft.cz>\n \t\t\t  Jeff Law <law@cygnus.com>\n \n+\t* i386.md (ashlsi patterns): Call output_ashl instead of output_ashlsi3.\n+\t(ashlqi): Use expander, separate LEA and SAL / ADD patterns; call\n+\toutput_ashl.\n+\t(ashlhi): Likewise.\n+\t* i386.h (output_ashl): Renamed from output_ashlsi3.\n+\t* i386.c (output_ashl): Likewise; support HImode and QImode operands\n+\tas well.\n+\n \t* i386.md (notsi, nothi, xorsi, xorhi, and xorqi patterns): Call\n \tmemory_address_displacement_length instead of memory_address_length.\n \t* i386.c (memory_address_info): Renamed from memory_address_length."}, {"sha": "50acbb1c0edc7e70f89aff0a5f4fbe5df7eb47c6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 82, "deletions": 20, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "patch": "@@ -5497,7 +5497,7 @@ x86_adjust_cost (insn, link, dep_insn, cost)\n \n       /* Stores stalls one cycle longer than other insns.  */\n       if (is_fp_insn (insn) && cost && is_fp_store (dep_insn))\n-        cost++;\n+\tcost++;\n \n     case PROCESSOR_K6:\n     default:\n@@ -5543,52 +5543,98 @@ x86_adjust_cost (insn, link, dep_insn, cost)\n      TARGET_DOUBLE_WITH_ADD.  */\n \n char *\n-output_ashlsi3 (operands)\n-     rtx *operands;\n+output_ashl (insn, operands)\n+     rtx insn, *operands;\n {\n   /* Handle case where srcreg != dstreg.  */\n   if (REG_P (operands[0]) && REGNO (operands[0]) != REGNO (operands[1]))\n     {\n       if (TARGET_DOUBLE_WITH_ADD && INTVAL (operands[2]) == 1)\n-\t{\n-\t  output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n-\t  return AS2 (add%L0,%1,%0);\n-\t}\n+\tswitch (GET_MODE (operands[0]))\n+\t  {\n+\t  case SImode:\n+\t    output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n+\t    return AS2 (add%L0,%1,%0);\n+\t  case HImode:\n+\t    output_asm_insn (AS2 (mov%L0,%k1,%k0), operands);\n+\t    if (i386_cc_probably_useless_p (insn))\n+\t      {\n+\t\tCC_STATUS_INIT;\n+\t\treturn AS2 (add%L0,%k1,%k0);\n+\t      }\n+\t    return AS2 (add%W0,%k1,%k0);\n+\t  case QImode:\n+\t    output_asm_insn (AS2 (mov%B0,%1,%0), operands);\n+\t    return AS2 (add%B0,%1,%0);\n+\t  default:\n+\t    abort ();\n+\t  }\n       else\n-        {\n-          CC_STATUS_INIT;\n+\t{\n+\t  CC_STATUS_INIT;\n \n \t  /* This should be extremely rare (impossible?).  We can not encode a\n \t     shift of the stack pointer using an lea instruction.  So copy the\n \t     stack pointer into the destination register and use an lea.  */\n \t  if (operands[1] == stack_pointer_rtx)\n \t    {\n-\t      output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n+\t      output_asm_insn (AS2 (mov%L0,%k1,%k0), operands);\n \t      operands[1] = operands[0];\n \t    }\n \n \t  /* For shifts up to and including 3 bits, use lea.  */\n-          operands[1] = gen_rtx_MULT (SImode, operands[1],\n+\t  operands[1] = gen_rtx_MULT (SImode,\n+\t\t\t\t      gen_rtx_REG (SImode, REGNO (operands[1])),\n \t\t\t\t      GEN_INT (1 << INTVAL (operands[2])));\n-\t  return AS2 (lea%L0,%a1,%0);\n+\t  return AS2 (lea%L0,%a1,%k0);\n \t}\n     }\n \n   /* Source and destination match.  */\n \n   /* Handle variable shift.  */\n   if (REG_P (operands[2]))\n-    return AS2 (sal%L0,%b2,%0);\n+    switch (GET_MODE (operands[0]))\n+      {\n+      case SImode:\n+\treturn AS2 (sal%L0,%b2,%0);\n+      case HImode:\n+\tif (REG_P (operands[0]) && i386_cc_probably_useless_p (insn))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    return AS2 (sal%L0,%b2,%k0);\n+\t  }\n+\telse\n+\t  return AS2 (sal%W0,%b2,%0);\n+      case QImode:\n+\treturn AS2 (sal%B0,%b2,%0);\n+      default:\n+\tabort ();\n+      }\n \n   /* Always perform shift by 1 using an add instruction.  */\n   if (REG_P (operands[0]) && operands[2] == const1_rtx)\n-    return AS2 (add%L0,%0,%0);\n+    switch (GET_MODE (operands[0]))\n+      {\n+      case SImode:\n+\treturn AS2 (add%L0,%0,%0);\n+      case HImode:\n+\tif (REG_P (operands[0]) && i386_cc_probably_useless_p (insn))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    return AS2 (add%L0,%k0,%k0);\n+\t  }\n+\telse\n+\t  return AS2 (add%W0,%0,%0);\n+      case QImode:\n+\t  return AS2 (add%B0,%0,%0);\n+      default:\n+\t  abort ();\n+      }\n \n #if 0\n-  /* ??? Currently disabled.  reg-stack currently stomps on the mode of\n-     each insn.  Thus, we can not easily detect when we should use lea to\n-     improve issue characteristics.  Until reg-stack is fixed, fall back to\n-     sal instruction for Pentiums to avoid AGI stall.  */\n+  /* ??? Currently disabled.  Because our model of Pentium is far from being\n+     exact, this change will need some benchmarking.  */\n   /* Shift reg by 2 or 3 use an lea instruction for Pentium if this is\n      insn is expected to issue into the V pipe (the insn's mode will be\n      TImode for a U pipe, and !TImode for a V pipe instruction).  */\n@@ -5600,14 +5646,30 @@ output_ashlsi3 (operands)\n       && GET_MODE (insn) != TImode)\n     {\n       CC_STATUS_INIT;\n-      operands[1] = gen_rtx_MULT (SImode, operands[1],\n+      operands[1] = gen_rtx_MULT (SImode, gen_rtx_REG (SImode, REGNO (operands[1])),\n \t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n       return AS2 (lea%L0,%a1,%0);\n     }\n #endif\n \n   /* Otherwise use a shift instruction.  */\n-  return AS2 (sal%L0,%2,%0);\n+  switch (GET_MODE (operands[0]))\n+    {\n+    case SImode:\n+      return AS2 (sal%L0,%2,%0);\n+    case HImode:\n+      if (REG_P (operands[0]) && i386_cc_probably_useless_p (insn))\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return AS2 (sal%L0,%2,%k0);\n+\t}\n+      else\n+\treturn AS2 (sal%W0,%2,%0);\n+    case QImode:\n+      return AS2 (sal%B0,%2,%0);\n+    default:\n+      abort ();\n+    }\n }\n \n /* Given the memory address ADDR, calculate the length of the address or"}, {"sha": "a455d2d24f029a47a5153d2c37addee2ee3fb115", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "patch": "@@ -2765,7 +2765,7 @@ extern char *output_int_conditional_move ();\n extern char *output_fp_conditional_move ();\n extern int ix86_can_use_return_insn_p ();\n extern int small_shift_operand ();\n-extern char *output_ashlsi3 ();\n+extern char *output_ashl ();\n extern int memory_address_info ();\n \n #ifdef NOTYET"}, {"sha": "39a06f2b233608c02b1ec789230424d9da72ce88", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6ec6d558ed34e6b31a5b984cf6fb9ead6a6ac7b1", "patch": "@@ -5079,18 +5079,33 @@ byte_xor_operation:\n   \"\"\n   \"\")\n \n+(define_expand \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n+\t\t   (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n ;; Pattern for shifts which can be encoded into an lea instruction.\n ;; This is kept as a separate pattern so that regmove can optimize cases\n ;; where we know the source and destination must match.\n ;;\n ;; Do not expose this pattern when optimizing for size since we never want\n ;; to use lea when optimizing for size since mov+sal is smaller than lea.\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,r\")\n \t\t   (match_operand:SI 2 \"small_shift_operand\" \"M,M\")))]\n   \"! optimize_size\"\n-  \"* return output_ashlsi3 (operands);\")\n+  \"* return output_ashl (insn, operands);\")\n \n ;; Generic left shift pattern to catch all cases not handled by the\n ;; shift pattern above.\n@@ -5099,58 +5114,37 @@ byte_xor_operation:\n \t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n-  \"* return output_ashlsi3 (operands);\")\n+  \"* return output_ashl (insn, operands);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r\")\n+\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,r\")\n+\t\t   (match_operand:HI 2 \"small_shift_operand\" \"M,M\")))]\n+  \"! optimize_size\"\n+  \"* return output_ashl (insn, operands);\")\n \n-(define_insn \"ashlhi3\"\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n \t\t   (match_operand:HI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n-  \"*\n-{\n-  if (REG_P (operands[2]))\n-    {\n-      if (REG_P (operands[0]) && i386_cc_probably_useless_p (insn))\n-        {\n-          CC_STATUS_INIT;\n-          return AS2 (sal%L0,%b2,%k0);\n-        }\n-      return AS2 (sal%W0,%b2,%0);\n-    }\n+  \"* return output_ashl (insn, operands);\")\n \n-  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n-    {\n-      if (i386_cc_probably_useless_p (insn))\n-        {\n-          CC_STATUS_INIT;\n-          return AS2 (add%L0,%k0,%k0);\n-        }\n-      return AS2 (add%W0,%0,%0);\n-    }\n-\n-  if (REG_P (operands[0]) && i386_cc_probably_useless_p (insn))\n-    {\n-      CC_STATUS_INIT;\n-      return AS2 (sal%L0,%2,%k0);\n-    }\n-  return AS2 (sal%W0,%2,%0);\n-}\")\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,q\")\n+\t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,q\")\n+\t\t   (match_operand:QI 2 \"small_shift_operand\" \"M,M\")))]\n+  \"! optimize_size\"\n+  \"* return output_ashl (insn, operands);\")\n \n-(define_insn \"ashlqi3\"\n+;; Generic left shift pattern to catch all cases not handled by the\n+;; shift pattern above.\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n \t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))]\n   \"\"\n-  \"*\n-{\n-  if (REG_P (operands[2]))\n-    return AS2 (sal%B0,%b2,%0);\n-\n-  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n-    return AS2 (add%B0,%0,%0);\n-\n-  return AS2 (sal%B0,%2,%0);\n-}\")\n+  \"* return output_ashl (insn, operands);\")\n \n ;; See comment above `ashldi3' about how this works.\n "}]}