{"sha": "090fa0ab610a8735d967f854f2e0e4517a3d3602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkwZmEwYWI2MTBhODczNWQ5NjdmODU0ZjJlMGU0NTE3YTNkMzYwMg==", "commit": {"author": {"name": "Grigori Fursin", "email": "grigori.fursin@inria.fr", "date": "2009-12-01T19:12:29Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2009-12-01T19:12:29Z"}, "message": "cgraphunit.c (plugin.h): Include.\n\n2009-12-01  Grigori Fursin  <grigori.fursin@inria.fr>\n            Joern Rennecke  <amylaar@spamcop.net>\n\n        * cgraphunit.c (plugin.h): Include.\n        (ipa_passes): Invoke PLUGIN_ALL_IPA_PASSES_START /\n        PLUGIN_ALL_IPA_PASSES_END at start / end of processing.\n        * gcc-plugin.h (highlev-plugin-common.h, hashtab.h): Include.\n        (enum plugin_event): Define by including plugin.def.\n        Last enumerator is now called PLUGIN_EVENT_FIRST_DYNAMIC.\n        (plugin_event_name): Change type to const char **.\n        (get_event_last, get_named_event_id, unregister_callback): Declare.\n        (register_callback): Change type of event argument to int.\n        (highlev-plugin-common.h): New file.\n        * Makefile.in (GCC_PLUGIN_H): Add highlev-plugin-common.h and\n        $(HASHTAB_H)\n        (tree-optimize.o passes.o): Depend on $(PLUGIN_H).\n        (PLUGIN_HEADERS): Add opts.h, $(PARAMS_H) and plugin.def.\n        (s-header-vars): New rule.\n        (install-plugin): Depend on s-header-vars.  Install b-header-vars.\n        * params.c (get_num_compiler_params): New function.\n        * params.h (get_num_compiler_params): Declare.\n        * passes.c (plugin.h): Include.\n        (make_pass_instance): Invoke PLUGIN_NEW_PASS.\n        (do_per_function_toporder, pass_init_dump_file): No longer static.\n        (pass_fini_dump_file): Likewise.\n        (execute_one_pass): Likewise.  Invoke PLUGIN_OVERRIDE_GATE and\n        PLUGIN_PASS_EXECUTION.\n        (execute_ipa_pass_list): Invoke PLUGIN_EARLY_GIMPLE_PASSES_START and\n        PLUGIN_EARLY_GIMPLE_PASSES_END.\n        * plugin.c (plugin_event_name_init): New array, defined by\n        including plugin.def.\n        (FMT_FOR_PLUGIN_EVENT): Update.\n        (plugin_event_name): Change type to const char ** and initialize\n        to plugin_event_name_init.\n        (event_tab, event_last, event_horizon): New variable.\n        (get_event_last): New function.\n        (plugin_callbacks_init): New array.\n        (plugin_callbacks: Change type to struct callback_info **.\n        Initialize to plugin_callbacks_init.\n        (htab_event_eq, get_named_event_id, unregister_callback): New function.\n        (invoke_plugin_va_callbacks): Likewise.\n        (register_callback): Change type of event argument to int.\n        Handle new events.  Allow dynamic events.\n        (invoke_plugin_callbacks): Likewise.  Return success status.\n        (plugins_active_p): Allow dynamic callbacks.\n        * plugin.def: New file.\n        * plugin.h (invoke_plugin_callbacks): Update prototype.\n        (invoke_plugin_va_callbacks): Declare.\n        * tree-optimize.c (plugin.h): Include.\n        (tree_rest_of_compilation): Invoke PLUGIN_ALL_PASSES_START and\n        PLUGIN_ALL_PASSES_END.\n        * tree-pass.h (execute_one_pass, pass_init_dump_file): Declare.\n        (pass_fini_dump_file, do_per_function_toporder): Likewise.\n        * doc/plugin.texi: Document new event types.\n\nCo-Authored-By: Joern Rennecke <amylaar@spamcop.net>\n\nFrom-SVN: r154877", "tree": {"sha": "5cb060dd65f054dc0a5dfd551c6f71e558fcdb9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cb060dd65f054dc0a5dfd551c6f71e558fcdb9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/090fa0ab610a8735d967f854f2e0e4517a3d3602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/090fa0ab610a8735d967f854f2e0e4517a3d3602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/090fa0ab610a8735d967f854f2e0e4517a3d3602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/090fa0ab610a8735d967f854f2e0e4517a3d3602/comments", "author": null, "committer": null, "parents": [{"sha": "d0d565e1b0134910f6f5b85e812de0970ea5b60b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d565e1b0134910f6f5b85e812de0970ea5b60b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d565e1b0134910f6f5b85e812de0970ea5b60b"}], "stats": {"total": 580, "additions": 509, "deletions": 71}, "files": [{"sha": "1b822330ca5bb3455a930de28a7c1142ed5335d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -1,3 +1,58 @@\n+2009-12-01  Grigori Fursin  <grigori.fursin@inria.fr>\n+\t    Joern Rennecke  <amylaar@spamcop.net>\n+\n+\t* cgraphunit.c (plugin.h): Include.\n+\t(ipa_passes): Invoke PLUGIN_ALL_IPA_PASSES_START /\n+\tPLUGIN_ALL_IPA_PASSES_END at start / end of processing.\n+\t* gcc-plugin.h (highlev-plugin-common.h, hashtab.h): Include.\n+\t(enum plugin_event): Define by including plugin.def.\n+\tLast enumerator is now called PLUGIN_EVENT_FIRST_DYNAMIC.\n+\t(plugin_event_name): Change type to const char **.\n+\t(get_event_last, get_named_event_id, unregister_callback): Declare.\n+\t(register_callback): Change type of event argument to int.\n+\t(highlev-plugin-common.h): New file.\n+\t* Makefile.in (GCC_PLUGIN_H): Add highlev-plugin-common.h and\n+\t$(HASHTAB_H)\n+\t(tree-optimize.o passes.o): Depend on $(PLUGIN_H).\n+\t(PLUGIN_HEADERS): Add opts.h, $(PARAMS_H) and plugin.def.\n+\t(s-header-vars): New rule.\n+\t(install-plugin): Depend on s-header-vars.  Install b-header-vars.\n+\t* params.c (get_num_compiler_params): New function.\n+\t* params.h (get_num_compiler_params): Declare.\n+\t* passes.c (plugin.h): Include.\n+\t(make_pass_instance): Invoke PLUGIN_NEW_PASS.\n+\t(do_per_function_toporder, pass_init_dump_file): No longer static.\n+\t(pass_fini_dump_file): Likewise.\n+\t(execute_one_pass): Likewise.  Invoke PLUGIN_OVERRIDE_GATE and\n+\tPLUGIN_PASS_EXECUTION.\n+\t(execute_ipa_pass_list): Invoke PLUGIN_EARLY_GIMPLE_PASSES_START and\n+\tPLUGIN_EARLY_GIMPLE_PASSES_END.\n+\t* plugin.c (plugin_event_name_init): New array, defined by\n+\tincluding plugin.def.\n+\t(FMT_FOR_PLUGIN_EVENT): Update.\n+\t(plugin_event_name): Change type to const char ** and initialize\n+\tto plugin_event_name_init.\n+\t(event_tab, event_last, event_horizon): New variable.\n+\t(get_event_last): New function.\n+\t(plugin_callbacks_init): New array.\n+\t(plugin_callbacks: Change type to struct callback_info **.\n+\tInitialize to plugin_callbacks_init.\n+\t(htab_event_eq, get_named_event_id, unregister_callback): New function.\n+\t(invoke_plugin_va_callbacks): Likewise.\n+\t(register_callback): Change type of event argument to int.\n+\tHandle new events.  Allow dynamic events.\n+\t(invoke_plugin_callbacks): Likewise.  Return success status.\n+\t(plugins_active_p): Allow dynamic callbacks.\n+\t* plugin.def: New file.\n+\t* plugin.h (invoke_plugin_callbacks): Update prototype.\n+\t(invoke_plugin_va_callbacks): Declare.\n+\t* tree-optimize.c (plugin.h): Include.\n+\t(tree_rest_of_compilation): Invoke PLUGIN_ALL_PASSES_START and\n+\tPLUGIN_ALL_PASSES_END.\n+\t* tree-pass.h (execute_one_pass, pass_init_dump_file): Declare.\n+\t(pass_fini_dump_file, do_per_function_toporder): Likewise.\n+\t* doc/plugin.texi: Document new event types.\n+\n 2009-12-01  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/42237"}, {"sha": "9379a206304de23424df228fa378ebb66594e102", "filename": "gcc/Makefile.in", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -943,7 +943,8 @@ TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) vec.h $(CGRAPH_H)\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n-GCC_PLUGIN_H = gcc-plugin.h $(CONFIG_H) $(SYSTEM_H)\n+GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h $(CONFIG_H) $(SYSTEM_H) \\\n+\t\t$(HASHTAB_H)\n PLUGIN_H = plugin.h $(GCC_PLUGIN_H)\n PLUGIN_VERSION_H = plugin-version.h configargs.h\n \n@@ -2503,8 +2504,9 @@ tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    langhooks.h alloc-pool.h pointer-set.h $(CFGLOOP_H)\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) hard-reg-set.h $(EXPR_H) $(GGC_H) output.h \\\n-   $(DIAGNOSTIC_H) $(BASIC_BLOCK_H) $(FLAGS_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n-   $(TREE_DUMP_H) $(TOPLEV_H) $(FUNCTION_H) langhooks.h $(FLAGS_H) $(CGRAPH_H) \\\n+   $(DIAGNOSTIC_H) $(BASIC_BLOCK_H) $(FLAGS_H) $(TIMEVAR_H) $(TM_H) \\\n+   coretypes.h $(TREE_DUMP_H) $(TOPLEV_H) $(FUNCTION_H) langhooks.h \\\n+   $(FLAGS_H) $(CGRAPH_H) $(PLUGIN_H) \\\n    $(TREE_INLINE_H) tree-mudflap.h $(GGC_H) graph.h $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(CFGLOOP_H) $(EXCEPT_H)\n \n@@ -2725,7 +2727,8 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) $(TREE_PASS_H) $(TREE_DUMP_H) \\\n    $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n-   gt-passes.h $(DF_H) $(PREDICT_H) $(LTO_HEADER_H) $(LTO_SECTION_OUT_H)\n+   gt-passes.h $(DF_H) $(PREDICT_H) $(LTO_HEADER_H) $(LTO_SECTION_OUT_H) \\\n+   $(PLUGIN_H)\n \n plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TOPLEV_H) $(TREE_H) $(TREE_PASS_H) intl.h $(PLUGIN_VERSION_H) $(GGC_H)\n@@ -4264,7 +4267,7 @@ installdirs:\n \n PLUGIN_HEADERS = $(TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(TOPLEV_H) $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_PASS_H) $(GCC_PLUGIN_H) \\\n-  $(GGC_H) $(TREE_DUMP_H) $(PRETTY_PRINT_H) \\\n+  $(GGC_H) $(TREE_DUMP_H) $(PRETTY_PRINT_H) opts.h $(PARAMS_H) plugin.def \\\n   $(tm_file_list) $(tm_include_list) $(tm_p_file_list) $(tm_p_include_list) \\\n   $(host_xm_file_list) $(host_xm_include_list) $(xm_include_list) \\\n   intl.h $(PLUGIN_VERSION_H) $(DIAGNOSTIC_H) $(C_COMMON_H) $(C_PRETTY_PRINT_H) \\\n@@ -4273,8 +4276,15 @@ PLUGIN_HEADERS = $(TREE_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(C_PRAGMA_H)  $(CPPLIB_H)  $(FUNCTION_H) \\\n   cppdefault.h flags.h $(MD5_H) params.def params.h prefix.h tree-inline.h\n \n+# generate the 'build fragment' b-header-vars\n+s-header-vars: Makefile\n+\trm -f tmp-header-vars\n+\t$(foreach header_var,$(shell sed < Makefile -e 's/^\\([A-Z0-9_]*_H\\)[      ]*=.*/\\1/p' -e d),echo $(header_var)=$(shell echo $($(header_var):$(srcdir)/%=.../%) | sed -e 's~\\.\\.\\./config/~config/~' -e 's~\\.\\.\\..*/~~') >> tmp-header-vars;) \\\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-header-vars b-header-vars\n+\t$(STAMP) s-header-vars\n+\n # Install the headers needed to build a plugin.\n-install-plugin: installdirs lang.install-plugin\n+install-plugin: installdirs lang.install-plugin s-header-vars\n # We keep the directory structure for files in config and .def files. All\n # other files are flattened to a single directory.\n \t$(mkinstalldirs) $(DESTDIR)$(plugin_includedir)\n@@ -4298,6 +4308,7 @@ install-plugin: installdirs lang.install-plugin\n \t  $(mkinstalldirs) $(DESTDIR)$$dir; \\\n \t  $(INSTALL_DATA) $$path $(DESTDIR)$$dest; \\\n \tdone\n+\t$(INSTALL_DATA) b-header-vars $(DESTDIR)$(plugin_includedir)/b-header-vars\n \n # Install the compiler executables built during cross compilation.\n install-common: native lang.install-common installdirs"}, {"sha": "51ead06bc4a26a09e4e00c1ea38ba40d34b0678e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -135,6 +135,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"output.h\"\n #include \"coverage.h\"\n+#include \"plugin.h\"\n \n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n@@ -1712,6 +1713,8 @@ ipa_passes (void)\n   gimple_register_cfg_hooks ();\n   bitmap_obstack_initialize (NULL);\n \n+  invoke_plugin_callbacks (PLUGIN_ALL_IPA_PASSES_START, NULL);\n+\n   if (!in_lto_p)\n     execute_ipa_pass_list (all_small_ipa_passes);\n \n@@ -1730,7 +1733,8 @@ ipa_passes (void)\n       current_function_decl = NULL;\n       cgraph_process_new_functions ();\n \n-      execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_regular_ipa_passes);\n+      execute_ipa_summary_passes\n+\t((struct ipa_opt_pass_d *) all_regular_ipa_passes);\n     }\n   execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_lto_gen_passes);\n \n@@ -1739,6 +1743,7 @@ ipa_passes (void)\n \n   if (!flag_ltrans)\n     execute_ipa_pass_list (all_regular_ipa_passes);\n+  invoke_plugin_callbacks (PLUGIN_ALL_IPA_PASSES_END, NULL);\n \n   bitmap_obstack_release (NULL);\n }"}, {"sha": "8aac0f7b65c11f2567817029665966561b4723c6", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -156,18 +156,42 @@ enum plugin_event\n   PLUGIN_ATTRIBUTES,            /* Called during attribute registration */\n   PLUGIN_START_UNIT,            /* Called before processing a translation unit.  */\n   PLUGIN_PRAGMAS,\t        /* Called during pragma registration. */\n-  PLUGIN_EVENT_LAST             /* Dummy event used for indexing callback\n+  /* Called before first pass from all_passes.  */\n+  PLUGIN_ALL_PASSES_START,\n+  /* Called after last pass from all_passes.  */\n+  PLUGIN_ALL_PASSES_END,\n+  /* Called before first ipa pass.  */\n+  PLUGIN_ALL_IPA_PASSES_START,\n+  /* Called after last ipa pass.  */\n+  PLUGIN_ALL_IPA_PASSES_END,\n+  /* Allows to override pass gate decision for current_pass.  */\n+  PLUGIN_OVERRIDE_GATE,\n+  /* Called before executing a pass.  */\n+  PLUGIN_PASS_EXECUTION,\n+  /* Called before executing subpasses of a GIMPLE_PASS in\n+     execute_ipa_pass_list.  */\n+  PLUGIN_EARLY_GIMPLE_PASSES_START,\n+  /* Called after executing subpasses of a GIMPLE_PASS in\n+     execute_ipa_pass_list.  */\n+  PLUGIN_EARLY_GIMPLE_PASSES_END,\n+  /* Called when a pass is first instantiated.  */\n+  PLUGIN_NEW_PASS,\n+\n+  PLUGIN_EVENT_FIRST_DYNAMIC    /* Dummy event used for indexing callback\n                                    array.  */\n @};\n @end smallexample\n \n+In addition, plugins can also look up the enumerator of a named event,\n+and / or generate new events dynamically, by calling the function\n+@code{get_named_event_id}.\n \n To register a callback, the plugin calls @code{register_callback} with\n the arguments:\n \n @itemize\n @item @code{char *name}: Plugin name.\n-@item @code{enum plugin_event event}: The event code.\n+@item @code{int event}: The event code.\n @item @code{plugin_callback_func callback}: The function that handles @code{event}.\n @item @code{void *user_data}: Pointer to plugin-specific data.\n @end itemize\n@@ -337,6 +361,41 @@ It is suggested to pass @code{\"GCCPLUGIN\"} (or a short name identifying\n your plugin) as the ``space'' argument of your pragma. \n \n \n+@section Recording information about pass execution\n+\n+The event PLUGIN_PASS_EXECUTION passes the pointer to the executed pass\n+(the same as current_pass) as @code{gcc_data} to the callback.  You can also\n+inspect cfun to find out about which function this pass is executed for.\n+Note that this event will only be invoked if the gate check (if\n+applicable, modified by PLUGIN_OVERRIDE_GATE) succeeds.\n+You can use other hooks, like @code{PLUGIN_ALL_PASSES_START},\n+@code{PLUGIN_ALL_PASSES_END}, @code{PLUGIN_ALL_IPA_PASSES_START},\n+@code{PLUGIN_ALL_IPA_PASSES_END}, @code{PLUGIN_EARLY_GIMPLE_PASSES_START},\n+and/or @code{PLUGIN_EARLY_GIMPLE_PASSES_END} to manipulate global state\n+in your plugin(s) in order to get context for the pass execution.\n+\n+\n+@section Controlling which passes are being run\n+\n+After the original gate function for a pass is called, its result\n+- the gate status - is stored as an integer.\n+Then the event @code{PLUGIN_OVERRIDE_GATE} is invoked, with a pointer\n+to the gate status in the @code{gcc_data} parameter to the callback function.\n+A nonzero value of the gate status means that the pass is to be executed.\n+You can both read and write the gate status via the passed pointer.\n+\n+\n+@section Keeping track of available passes\n+\n+When your plugin is loaded, you can inspect the various\n+pass lists to determine what passes are available.  However, other\n+plugins might add new passes.  Also, future changes to GCC might cause\n+generic passes to be added after plugin loading.\n+When a pass is first added to one of the pass lists, the event\n+@code{PLUGIN_NEW_PASS} is invoked, with the callback parameter\n+@code{gcc_data} pointing to the new pass.\n+\n+\n @section Building GCC plugins\n \n If plugins are enabled, GCC installs the headers needed to build a"}, {"sha": "ec12265417de92897a0f16371eac9d0e81141b74", "filename": "gcc/gcc-plugin.h", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fgcc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fgcc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-plugin.h?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -26,29 +26,19 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"highlev-plugin-common.h\"\n+#include \"hashtab.h\"\n \n-/* Event names.  Keep in sync with plugin_event_name[].  */\n+/* Event names.  */\n enum plugin_event\n {\n-  PLUGIN_PASS_MANAGER_SETUP,    /* To hook into pass manager.  */\n-  PLUGIN_FINISH_TYPE,           /* After finishing parsing a type.  */\n-  PLUGIN_FINISH_UNIT,           /* Useful for summary processing.  */\n-  PLUGIN_CXX_CP_PRE_GENERICIZE, /* Allows to see low level AST in C++ FE.  */\n-  PLUGIN_FINISH,                /* Called before GCC exits.  */\n-  PLUGIN_INFO,                  /* Information about the plugin. */\n-  PLUGIN_GGC_START,\t\t/* Called at start of GCC Garbage Collection. */\n-  PLUGIN_GGC_MARKING,\t\t/* Extend the GGC marking. */\n-  PLUGIN_GGC_END,\t\t/* Called at end of GGC. */\n-  PLUGIN_REGISTER_GGC_ROOTS,\t/* Register an extra GGC root table. */\n-  PLUGIN_REGISTER_GGC_CACHES,\t/* Register an extra GGC cache table. */\n-  PLUGIN_ATTRIBUTES,            /* Called during attribute registration.  */\n-  PLUGIN_START_UNIT,            /* Called before processing a translation unit.  */\n-  PLUGIN_PRAGMAS,\t        /* Called during pragma registration.  */\n-  PLUGIN_EVENT_LAST             /* Dummy event used for indexing callback\n-                                   array.  */\n+# define DEFEVENT(NAME) NAME,\n+# include \"plugin.def\"\n+# undef DEFEVENT\n+  PLUGIN_EVENT_FIRST_DYNAMIC\n };\n \n-extern const char *plugin_event_name[];\n+extern const char **plugin_event_name;\n \n struct plugin_argument\n {\n@@ -127,14 +117,22 @@ typedef void (*plugin_callback_func) (void *gcc_data, void *user_data);\n    USER_DATA   - plugin-provided data.\n */\n \n+/* Number of event ids / names registered so far.  */\n+\n+extern int get_event_last (void);\n+\n+int get_named_event_id (const char *name, enum insert_option insert);\n+\n /* This is also called without a callback routine for the\n    PLUGIN_PASS_MANAGER_SETUP, PLUGIN_INFO, PLUGIN_REGISTER_GGC_ROOTS and\n    PLUGIN_REGISTER_GGC_CACHES pseudo-events, with a specific user_data.\n   */\n \n extern void register_callback (const char *plugin_name,\n-                               enum plugin_event event,\n+\t\t\t       int event,\n                                plugin_callback_func callback,\n                                void *user_data);\n \n+extern int unregister_callback (const char *plugin_name, int event);\n+\n #endif /* GCC_PLUGIN_H */"}, {"sha": "7af2d0a3f9c5844f469bdc10907e4c997497a0d0", "filename": "gcc/highlev-plugin-common.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fhighlev-plugin-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fhighlev-plugin-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhighlev-plugin-common.h?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -0,0 +1,33 @@\n+/* Interface for high-level plugins in GCC - Parts common between GCC,\n+   ICI and high-level plugins.\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   Contributed by INRIA.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef HIGHLEV_PLUGIN_COMMON_H\n+#define HIGHLEV_PLUGIN_COMMON_H\n+\n+/* Return codes for invoke_plugin_callbacks / call_plugin_event .  */\n+#define PLUGEVT_SUCCESS         0\n+#define PLUGEVT_NO_EVENTS       1\n+#define PLUGEVT_NO_SUCH_EVENT   2\n+#define PLUGEVT_NO_CALLBACK     3\n+\n+#endif /* HIGHLEV_PLUGIN_COMMON_H */"}, {"sha": "04eff112055f8bd488bb1ce6a2fe96ce3418717f", "filename": "gcc/params.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n param_info *compiler_params;\n \n /* The number of entries in the table.  */\n-\n static size_t num_compiler_params;\n \n /* Add the N PARAMS to the current list of compiler parameters.  */\n@@ -85,3 +84,12 @@ set_param_value (const char *name, int value)\n   /* If we didn't find this parameter, issue an error message.  */\n   error (\"invalid parameter %qs\", name);\n }\n+\n+/* Return the current value of num_compiler_params, for the benefit of\n+   plugins that use parameters as features.  */\n+\n+size_t\n+get_num_compiler_params (void)\n+{\n+  return num_compiler_params;\n+}"}, {"sha": "833fc3bb2f14de61c4f1a27bda3cdfdddab60e25", "filename": "gcc/params.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -65,6 +65,9 @@ typedef struct param_info\n \n extern param_info *compiler_params;\n \n+/* Returns the number of entries in the table, for the use by plugins.  */\n+extern size_t get_num_compiler_params (void);\n+\n /* Add the N PARAMS to the current list of compiler parameters.  */\n \n extern void add_params (const param_info params[], size_t n);"}, {"sha": "818adde18e0b94fd9153caf9cb3b8f1897313f2c", "filename": "gcc/passes.c", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"predict.h\"\n #include \"lto-streamer.h\"\n+#include \"plugin.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n@@ -104,7 +105,8 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n /* This is used for debugging.  It allows the current pass to printed\n-   from anywhere in compilation.  */\n+   from anywhere in compilation.\n+   The variable current_pass is also used for statistics and plugins.  */\n struct opt_pass *current_pass;\n \n /* Call from anywhere to find out what pass this is.  Useful for\n@@ -479,6 +481,8 @@ make_pass_instance (struct opt_pass *pass, bool track_duplicates)\n     {\n       pass->todo_flags_start |= TODO_mark_first_instance;\n       pass->static_pass_number = -1;\n+\n+      invoke_plugin_callbacks (PLUGIN_NEW_PASS, pass);\n     }\n   return pass;\n }\n@@ -1090,9 +1094,9 @@ static GTY ((length (\"nnodes\"))) struct cgraph_node **order;\n \n /* If we are in IPA mode (i.e., current_function_decl is NULL), call\n    function CALLBACK for every function in the call graph.  Otherwise,\n-   call CALLBACK on the current function.  */\n-\n-static void\n+   call CALLBACK on the current function.\n+   This function is global so that plugins can use it.  */\n+void\n do_per_function_toporder (void (*callback) (void *data), void *data)\n {\n   int i;\n@@ -1317,8 +1321,9 @@ verify_curr_properties (void *data)\n #endif\n \n /* Initialize pass dump file.  */\n+/* This is non-static so that the plugins can use it.  */\n \n-static bool\n+bool\n pass_init_dump_file (struct opt_pass *pass)\n {\n   /* If a dump file name is present, open it if enabled.  */\n@@ -1347,8 +1352,9 @@ pass_init_dump_file (struct opt_pass *pass)\n }\n \n /* Flush PASS dump file.  */\n+/* This is non-static so that plugins can use it.  */\n \n-static void\n+void\n pass_fini_dump_file (struct opt_pass *pass)\n {\n   /* Flush and close dump file.  */\n@@ -1476,12 +1482,14 @@ execute_all_ipa_transforms (void)\n \n /* Execute PASS. */\n \n-static bool\n+bool\n execute_one_pass (struct opt_pass *pass)\n {\n   bool initializing_dump;\n   unsigned int todo_after = 0;\n \n+  bool gate_status;\n+\n   /* IPA passes are executed on whole program, so cfun should be NULL.\n      Other passes need function context set.  */\n   if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)\n@@ -1491,9 +1499,22 @@ execute_one_pass (struct opt_pass *pass)\n \n   current_pass = pass;\n \n-  /* See if we're supposed to run this pass.  */\n-  if (pass->gate && !pass->gate ())\n-    return false;\n+  /* Check whether gate check should be avoided.\n+     User controls the value of the gate through the parameter \"gate_status\". */\n+  gate_status = (pass->gate == NULL) ? true : pass->gate();\n+\n+  /* Override gate with plugin.  */\n+  invoke_plugin_callbacks (PLUGIN_OVERRIDE_GATE, &gate_status);\n+\n+  if (!gate_status)\n+    {\n+      current_pass = NULL;\n+      return false;\n+    }\n+\n+  /* Pass execution event trigger: useful to identify passes being\n+     executed.  */\n+  invoke_plugin_callbacks (PLUGIN_PASS_EXECUTION, pass);\n \n   if (!quiet_flag && !cfun)\n     fprintf (stderr, \" <%s>\", pass->name ? pass->name : \"\");\n@@ -1756,8 +1777,12 @@ execute_ipa_pass_list (struct opt_pass *pass)\n       if (execute_one_pass (pass) && pass->sub)\n \t{\n \t  if (pass->sub->type == GIMPLE_PASS)\n-\t    do_per_function_toporder ((void (*)(void *))execute_pass_list,\n-\t\t\t\t      pass->sub);\n+\t    {\n+\t      invoke_plugin_callbacks (PLUGIN_EARLY_GIMPLE_PASSES_START, NULL);\n+\t      do_per_function_toporder ((void (*)(void *))execute_pass_list,\n+\t\t\t\t\tpass->sub);\n+\t      invoke_plugin_callbacks (PLUGIN_EARLY_GIMPLE_PASSES_END, NULL);\n+\t    }\n \t  else if (pass->sub->type == SIMPLE_IPA_PASS\n \t\t   || pass->sub->type == IPA_PASS)\n \t    execute_ipa_pass_list (pass->sub);"}, {"sha": "84c9f4434dc81a28949fd81f4af231842e97a4c3", "filename": "gcc/plugin.c", "status": "modified", "additions": 161, "deletions": 29, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -44,28 +44,30 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin-version.h\"\n #endif\n \n+#define GCC_PLUGIN_STRINGIFY0(X) #X\n+#define GCC_PLUGIN_STRINGIFY1(X) GCC_PLUGIN_STRINGIFY0 (X)\n+\n /* Event names as strings.  Keep in sync with enum plugin_event.  */\n-const char *plugin_event_name[] =\n+static const char *plugin_event_name_init[] =\n {\n-  \"PLUGIN_PASS_MANAGER_SETUP\",\n-  \"PLUGIN_FINISH_TYPE\",\n-  \"PLUGIN_FINISH_UNIT\",\n-  \"PLUGIN_CXX_CP_PRE_GENERICIZE\",\n-  \"PLUGIN_FINISH\",\n-  \"PLUGIN_INFO\",\n-  \"PLUGIN_GGC_START\",\n-  \"PLUGIN_GGC_MARKING\",\n-  \"PLUGIN_GGC_END\",\n-  \"PLUGIN_REGISTER_GGC_ROOTS\",\n-  \"PLUGIN_REGISTER_GGC_CACHES\",\n-  \"PLUGIN_ATTRIBUTES\",\n-  \"PLUGIN_START_UNIT\",\n-  \"PLUGIN_PRAGMAS\",\n-  \"PLUGIN_EVENT_LAST\"\n+# define DEFEVENT(NAME) GCC_PLUGIN_STRINGIFY1 (NAME),\n+# include \"plugin.def\"\n+# undef DEFEVENT\n };\n \n /* A printf format large enough for the largest event above.  */\n-#define FMT_FOR_PLUGIN_EVENT \"%-26s\"\n+#define FMT_FOR_PLUGIN_EVENT \"%-32s\"\n+\n+const char **plugin_event_name = plugin_event_name_init;\n+\n+/* A hash table to map event names to the position of the names in the\n+   plugin_event_name table.  */\n+static htab_t event_tab;\n+\n+/* Keep track of the limit of allocated events and space ready for\n+   allocating events.  */\n+static int event_last = PLUGIN_EVENT_FIRST_DYNAMIC;\n+static int event_horizon = PLUGIN_EVENT_FIRST_DYNAMIC;\n \n /* Hash table for the plugin_name_args objects created during command-line\n    parsing.  */\n@@ -81,7 +83,8 @@ struct callback_info\n };\n \n /* An array of lists of 'callback_info' objects indexed by the event id.  */\n-static struct callback_info *plugin_callbacks[PLUGIN_EVENT_LAST] = { NULL };\n+static struct callback_info *plugin_callbacks_init[PLUGIN_EVENT_FIRST_DYNAMIC];\n+static struct callback_info **plugin_callbacks = plugin_callbacks_init;\n \n \n #ifdef ENABLE_PLUGIN\n@@ -290,6 +293,71 @@ register_plugin_info (const char* name, struct plugin_info *info)\n   plugin->help = info->help;\n }\n \n+/* Helper function for the event hash table that compares the name of an\n+   existing entry (E1) with the given string (S2).  */\n+\n+static int\n+htab_event_eq (const void *e1, const void *s2)\n+{\n+  const char *s1= *(const char * const *) e1;\n+  return !strcmp (s1, (const char *) s2);\n+}\n+\n+/* Look up the event id for NAME.  If the name is not found, return -1\n+   if INSERT is NO_INSERT.  */\n+\n+int\n+get_named_event_id (const char *name, enum insert_option insert)\n+{\n+  void **slot;\n+\n+  if (!event_tab)\n+    {\n+      int i;\n+\n+      event_tab = htab_create (150, htab_hash_string, htab_event_eq, NULL);\n+      for (i = 0; i < PLUGIN_EVENT_FIRST_DYNAMIC; i++)\n+\t{\n+\t  slot = htab_find_slot (event_tab, plugin_event_name[i], INSERT);\n+\t  gcc_assert (*slot == HTAB_EMPTY_ENTRY);\n+\t  *slot = &plugin_event_name[i];\n+\t}\n+    }\n+  slot = htab_find_slot (event_tab, name, insert);\n+  if (slot == NULL)\n+    return -1;\n+  if (*slot != HTAB_EMPTY_ENTRY)\n+    return (const char **) *slot - &plugin_event_name[0];\n+\n+  if (event_last >= event_horizon)\n+    {\n+      event_horizon = event_last * 2;\n+      if (plugin_event_name == plugin_event_name_init)\n+\t{\n+\t  plugin_event_name = XNEWVEC (const char *, event_horizon);\n+\t  memcpy (plugin_event_name, plugin_event_name_init,\n+\t\t  sizeof plugin_event_name_init);\n+\t  plugin_callbacks = XNEWVEC (struct callback_info *, event_horizon);\n+\t  memcpy (plugin_callbacks, plugin_callbacks_init,\n+\t\t  sizeof plugin_callbacks_init);\n+\t}\n+      else\n+\t{\n+\t  plugin_event_name\n+\t    = XRESIZEVEC (const char *, plugin_event_name, event_horizon);\n+\t  plugin_callbacks = XRESIZEVEC (struct callback_info *,\n+\t\t\t\t\t plugin_callbacks, event_horizon);\n+\t}\n+      /* All the pointers in the hash table will need to be updated.  */\n+      htab_delete (event_tab);\n+      event_tab = NULL;\n+    }\n+  else\n+    *slot = &plugin_event_name[event_last];\n+  plugin_event_name[event_last] = name;\n+  return event_last++;\n+}\n+\n /* Called from the plugin's initialization code. Register a single callback.\n    This function can be called multiple times.\n \n@@ -300,7 +368,7 @@ register_plugin_info (const char* name, struct plugin_info *info)\n \n void\n register_callback (const char *plugin_name,\n-                   enum plugin_event event,\n+\t\t   int event,\n                    plugin_callback_func callback,\n                    void *user_data)\n {\n@@ -322,6 +390,15 @@ register_callback (const char *plugin_name,\n \tgcc_assert (!callback);\n         ggc_register_cache_tab ((const struct ggc_cache_tab*) user_data);\n \tbreak;\n+      case PLUGIN_EVENT_FIRST_DYNAMIC:\n+      default:\n+\tif (event < PLUGIN_EVENT_FIRST_DYNAMIC || event >= event_last)\n+\t  {\n+\t    error (\"Unknown callback event registered by plugin %s\",\n+\t\t   plugin_name);\n+\t    return;\n+\t  }\n+      /* Fall through.  */\n       case PLUGIN_FINISH_TYPE:\n       case PLUGIN_START_UNIT:\n       case PLUGIN_FINISH_UNIT:\n@@ -332,6 +409,15 @@ register_callback (const char *plugin_name,\n       case PLUGIN_ATTRIBUTES:\n       case PLUGIN_PRAGMAS:\n       case PLUGIN_FINISH:\n+      case PLUGIN_ALL_PASSES_START:\n+      case PLUGIN_ALL_PASSES_END:\n+      case PLUGIN_ALL_IPA_PASSES_START:\n+      case PLUGIN_ALL_IPA_PASSES_END:\n+      case PLUGIN_OVERRIDE_GATE:\n+      case PLUGIN_PASS_EXECUTION:\n+      case PLUGIN_EARLY_GIMPLE_PASSES_START:\n+      case PLUGIN_EARLY_GIMPLE_PASSES_END:\n+      case PLUGIN_NEW_PASS:\n         {\n           struct callback_info *new_callback;\n           if (!callback)\n@@ -348,27 +434,52 @@ register_callback (const char *plugin_name,\n           plugin_callbacks[event] = new_callback;\n         }\n         break;\n-      case PLUGIN_EVENT_LAST:\n-      default:\n-        error (\"Unknown callback event registered by plugin %s\",\n-               plugin_name);\n     }\n }\n \n+/* Remove a callback for EVENT which has been registered with for a plugin\n+   PLUGIN_NAME.  Return PLUGEVT_SUCCESS if a matching callback was\n+   found & removed, PLUGEVT_NO_CALLBACK if the event does not have a matching\n+   callback, and PLUGEVT_NO_SUCH_EVENT if EVENT is invalid.  */\n+int\n+unregister_callback (const char *plugin_name, int event)\n+{\n+  struct callback_info *callback, **cbp;\n+\n+  if (event >= event_last)\n+    return PLUGEVT_NO_SUCH_EVENT;\n+\n+  for (cbp = &plugin_callbacks[event]; (callback = *cbp); cbp = &callback->next)\n+    if (strcmp (callback->plugin_name, plugin_name) == 0)\n+      {\n+\t*cbp = callback->next;\n+\treturn PLUGEVT_SUCCESS;\n+      }\n+  return PLUGEVT_NO_CALLBACK;\n+}\n \n /* Called from inside GCC.  Invoke all plug-in callbacks registered with\n    the specified event.\n+   Return PLUGEVT_SUCCESS if at least one callback was called,\n+   PLUGEVT_NO_CALLBACK if there was no callback.\n \n    EVENT    - the event identifier\n    GCC_DATA - event-specific data provided by the compiler  */\n \n-void\n-invoke_plugin_callbacks (enum plugin_event event, void *gcc_data)\n+int\n+invoke_plugin_callbacks (int event, void *gcc_data)\n {\n+  int retval = PLUGEVT_SUCCESS;\n+\n   timevar_push (TV_PLUGIN_RUN);\n \n   switch (event)\n     {\n+      case PLUGIN_EVENT_FIRST_DYNAMIC:\n+      default:\n+\tgcc_assert (event >= PLUGIN_EVENT_FIRST_DYNAMIC);\n+\tgcc_assert (event < event_last);\n+      /* Fall through.  */\n       case PLUGIN_FINISH_TYPE:\n       case PLUGIN_START_UNIT:\n       case PLUGIN_FINISH_UNIT:\n@@ -379,24 +490,35 @@ invoke_plugin_callbacks (enum plugin_event event, void *gcc_data)\n       case PLUGIN_GGC_START:\n       case PLUGIN_GGC_MARKING:\n       case PLUGIN_GGC_END:\n+      case PLUGIN_ALL_PASSES_START:\n+      case PLUGIN_ALL_PASSES_END:\n+      case PLUGIN_ALL_IPA_PASSES_START:\n+      case PLUGIN_ALL_IPA_PASSES_END:\n+      case PLUGIN_OVERRIDE_GATE:\n+      case PLUGIN_PASS_EXECUTION:\n+      case PLUGIN_EARLY_GIMPLE_PASSES_START:\n+      case PLUGIN_EARLY_GIMPLE_PASSES_END:\n+      case PLUGIN_NEW_PASS:\n         {\n           /* Iterate over every callback registered with this event and\n              call it.  */\n           struct callback_info *callback = plugin_callbacks[event];\n+\n+\t  if (!callback)\n+\t    retval = PLUGEVT_NO_CALLBACK;\n           for ( ; callback; callback = callback->next)\n             (*callback->func) (gcc_data, callback->user_data);\n         }\n         break;\n \n       case PLUGIN_PASS_MANAGER_SETUP:\n-      case PLUGIN_EVENT_LAST:\n       case PLUGIN_REGISTER_GGC_ROOTS:\n       case PLUGIN_REGISTER_GGC_CACHES:\n-      default:\n         gcc_assert (false);\n     }\n \n   timevar_pop (TV_PLUGIN_RUN);\n+  return retval;\n }\n \n #ifdef ENABLE_PLUGIN\n@@ -621,7 +743,7 @@ plugins_active_p (void)\n {\n   int event;\n \n-  for (event = PLUGIN_PASS_MANAGER_SETUP; event < PLUGIN_EVENT_LAST; event++)\n+  for (event = PLUGIN_PASS_MANAGER_SETUP; event < event_last; event++)\n     if (plugin_callbacks[event])\n       return true;\n \n@@ -641,7 +763,7 @@ dump_active_plugins (FILE *file)\n     return;\n \n   fprintf (file, FMT_FOR_PLUGIN_EVENT \" | %s\\n\", _(\"Event\"), _(\"Plugins\"));\n-  for (event = PLUGIN_PASS_MANAGER_SETUP; event < PLUGIN_EVENT_LAST; event++)\n+  for (event = PLUGIN_PASS_MANAGER_SETUP; event < event_last; event++)\n     if (plugin_callbacks[event])\n       {\n \tstruct callback_info *ci;\n@@ -686,3 +808,13 @@ plugin_default_version_check (struct plugin_gcc_version *gcc_version,\n     return false;\n   return true;\n }\n+\n+/* Return the current value of event_last, so that plugins which provide\n+   additional functionality for events for the benefit of high-level plugins\n+   know how many valid entries plugin_event_name holds.  */\n+\n+int\n+get_event_last (void)\n+{\n+  return event_last;\n+}"}, {"sha": "b4e541e3c1748066e91e5ab2d00c01e0292e7eb1", "filename": "gcc/plugin.def", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fplugin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fplugin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.def?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -0,0 +1,94 @@\n+/* This file contains the definitions for plugin events in GCC.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* To hook into pass manager.  */\n+DEFEVENT (PLUGIN_PASS_MANAGER_SETUP)\n+\n+/* After finishing parsing a type.  */\n+DEFEVENT (PLUGIN_FINISH_TYPE)\n+\n+/* Useful for summary processing.  */\n+DEFEVENT (PLUGIN_FINISH_UNIT)\n+\n+/* Allows to see low level AST in C++ FE.  */\n+DEFEVENT (PLUGIN_CXX_CP_PRE_GENERICIZE)\n+\n+/* Called before GCC exits.  */\n+DEFEVENT (PLUGIN_FINISH)\n+\n+/* Information about the plugin. */\n+DEFEVENT (PLUGIN_INFO)\n+\n+/* Called at start of GCC Garbage Collection. */\n+DEFEVENT (PLUGIN_GGC_START)\n+\n+/* Extend the GGC marking. */\n+DEFEVENT (PLUGIN_GGC_MARKING)\n+\n+/* Called at end of GGC. */\n+DEFEVENT (PLUGIN_GGC_END)\n+\n+/* Register an extra GGC root table. */\n+DEFEVENT (PLUGIN_REGISTER_GGC_ROOTS)\n+\n+/* Register an extra GGC cache table. */\n+DEFEVENT (PLUGIN_REGISTER_GGC_CACHES)\n+\n+/* Called during attribute registration.  */\n+DEFEVENT (PLUGIN_ATTRIBUTES)\n+\n+/* Called before processing a translation unit.  */\n+DEFEVENT (PLUGIN_START_UNIT)\n+\n+/* Called during pragma registration.  */\n+DEFEVENT (PLUGIN_PRAGMAS)\n+\n+/* Called before first pass from all_passes.  */\n+DEFEVENT (PLUGIN_ALL_PASSES_START)\n+\n+/* Called after last pass from all_passes.  */\n+DEFEVENT (PLUGIN_ALL_PASSES_END)\n+\n+/* Called before first ipa pass.  */\n+DEFEVENT (PLUGIN_ALL_IPA_PASSES_START)\n+\n+/* Called after last ipa pass.  */\n+DEFEVENT (PLUGIN_ALL_IPA_PASSES_END)\n+\n+/* Allows to override pass gate decision for current_pass.  */\n+DEFEVENT (PLUGIN_OVERRIDE_GATE)\n+\n+/* Called before executing a pass.  */\n+DEFEVENT (PLUGIN_PASS_EXECUTION)\n+\n+/* Called before executing subpasses of a GIMPLE_PASS in\n+   execute_ipa_pass_list.  */\n+DEFEVENT (PLUGIN_EARLY_GIMPLE_PASSES_START)\n+\n+/* Called after executing subpasses of a GIMPLE_PASS in\n+   execute_ipa_pass_list.  */\n+DEFEVENT (PLUGIN_EARLY_GIMPLE_PASSES_END)\n+\n+/* Called when a pass is first instantiated.  */\n+DEFEVENT (PLUGIN_NEW_PASS)\n+\n+/* After the hard-coded events above, plugins can dynamically allocate events\n+   at run time.\n+   PLUGIN_EVENT_FIRST_DYNAMIC only appears as last enum element.  */"}, {"sha": "1e1dd594937cbd34d27e0e2b2c57395b214ded58", "filename": "gcc/plugin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fplugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Fplugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.h?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -26,7 +26,7 @@ struct attribute_spec;\n \n extern void add_new_plugin (const char *);\n extern void parse_plugin_arg_opt (const char *);\n-extern void invoke_plugin_callbacks (enum plugin_event, void *);\n+extern int invoke_plugin_callbacks (int, void *);\n extern void initialize_plugins (void);\n extern bool plugins_active_p (void);\n extern void dump_active_plugins (FILE *);"}, {"sha": "42e7d10b128229a47aca55c00beb8ae420a94c27", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graph.h\"\n #include \"cfgloop.h\"\n #include \"except.h\"\n+#include \"plugin.h\"\n \n \n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n@@ -405,8 +406,15 @@ tree_rest_of_compilation (tree fndecl)\n   execute_all_ipa_transforms ();\n \n   /* Perform all tree transforms and optimizations.  */\n+\n+  /* Signal the start of passes.  */\n+  invoke_plugin_callbacks (PLUGIN_ALL_PASSES_START, NULL);\n+\n   execute_pass_list (all_passes);\n \n+  /* Signal the end of passes.  */\n+  invoke_plugin_callbacks (PLUGIN_ALL_PASSES_END, NULL);\n+\n   bitmap_obstack_release (&reg_obstack);\n \n   /* Release the default bitmap obstack.  */"}, {"sha": "b997eb126ece3b0e8e4008b7e9304eee933d65ec", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090fa0ab610a8735d967f854f2e0e4517a3d3602/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=090fa0ab610a8735d967f854f2e0e4517a3d3602", "patch": "@@ -566,12 +566,16 @@ extern struct opt_pass *all_passes, *all_small_ipa_passes, *all_lowering_passes,\n extern struct opt_pass *current_pass;\n \n extern struct opt_pass * get_pass_for_id (int);\n+extern bool execute_one_pass (struct opt_pass *);\n extern void execute_pass_list (struct opt_pass *);\n extern void execute_ipa_pass_list (struct opt_pass *);\n extern void execute_ipa_summary_passes (struct ipa_opt_pass_d *);\n extern void execute_all_ipa_transforms (void);\n extern void execute_all_ipa_stmt_fixups (struct cgraph_node *, gimple *);\n+extern bool pass_init_dump_file (struct opt_pass *);\n+extern void pass_fini_dump_file (struct opt_pass *);\n \n+extern const char *get_current_pass_name (void);\n extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n extern void ipa_write_summaries (void);\n@@ -591,4 +595,7 @@ extern void register_pass (struct register_pass_info *);\n    directly in jump threading, and avoid peeling them next time.  */\n extern bool first_pass_instance;\n \n+/* Declare for plugins.  */\n+extern void do_per_function_toporder (void (*) (void *), void *);\n+\n #endif /* GCC_TREE_PASS_H */"}]}