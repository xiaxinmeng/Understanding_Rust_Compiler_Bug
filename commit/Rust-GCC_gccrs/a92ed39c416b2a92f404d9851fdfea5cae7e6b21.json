{"sha": "a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "node_id": "C_kwDOANBUbNoAKGE5MmVkMzljNDE2YjJhOTJmNDA0ZDk4NTFmZGZlYTVjYWU3ZTZiMjE", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-09T11:47:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-11T13:38:19Z"}, "message": "[c++] Add module attachment\n\nThis adds module attachment as a distinct flag to 'in module purview'.\nA declaration may have neither or both (as before), but can also have\njust the 'in [named-module] purview', which was previously not\nrepresentable.\n\nThis new state allows some cleanup of redeclarations (particularly the\nbuiltins), which was a little warty.  Some other internal APIs get\nsimilarly clarified.\n\n\tgcc/cp/\n\t* cp-tree.h (DECL_MODULE_ATTACH_P): New.\n\t(struct lang_decl_base): Add module_attach_p flag.\n\t* decl.cc (duplicate_decls): Rework module redeclaration\n\tchecking.\n\t* module.cc (trees_out::lang_decl_bools): Write attach flag.\n\t(trees_in::lang_decl_bools): ... and read it back.\n\t(trees_out::decl_value): Rework module attachment handling.\n\t(trees_in::decl_value): Rename local var to reflect meaning.\n\t(trees_in::key_mergeable): Likewise.\n\t(get_originating_module): Use DECL_MODULE_ATTACH_P.  No need\n\tto special-case mangling.\n\t(module_may_redeclare): Reimplement.\n\t(set_originating_module): Deal with attachment.\n\t* name-lookup.cc (maybe_record_mergeable_decl): Deal with\n\tattachment.\n\t(mergeable_namespace_slots): Likewise.\n\t(do_nonmember_using_decl): Likewise.\n\t* name-lookup.h (mergeable_namespace_slots): Adjust parm\n\tmeaning.\n\t* ptree.cc (cxx_print_decl): Adjust purview & attach printing.", "tree": {"sha": "937940a8cb1ba7ff82afc2385926cdc4519874c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/937940a8cb1ba7ff82afc2385926cdc4519874c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a8220fa9188470c677abfef50c1b120c0b6c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a8220fa9188470c677abfef50c1b120c0b6c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a8220fa9188470c677abfef50c1b120c0b6c76"}], "stats": {"total": 193, "additions": 114, "deletions": 79}, "files": [{"sha": "e16b8d708463fa7734400e77c264bb3dce4a1b1e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "patch": "@@ -1725,6 +1725,11 @@ check_constraint_info (tree t)\n #define DECL_MODULE_PURVIEW_P(N) \\\n   (DECL_LANG_SPECIFIC (DECL_MODULE_CHECK (N))->u.base.module_purview_p)\n \n+/* Attached to the named module it is in the purview of.  Decls\n+   attached to the global module will have this false.  */\n+#define DECL_MODULE_ATTACH_P(N) \\\n+  (DECL_LANG_SPECIFIC (DECL_MODULE_CHECK (N))->u.base.module_attach_p)\n+\n /* True if the live version of the decl was imported.  */\n #define DECL_MODULE_IMPORT_P(NODE) \\\n   (DECL_LANG_SPECIFIC (DECL_MODULE_CHECK (NODE))->u.base.module_import_p)\n@@ -2827,13 +2832,8 @@ struct GTY(()) lang_decl_base {\n \n   /* The following apply to VAR, FUNCTION, TYPE, CONCEPT, & NAMESPACE\n      decls.  */\n-  // FIXME: Purview and Attachment are not the same thing, due to\n-  // linkage-declarations.  The modules code presumes they are the\n-  // same.  (For context, linkage-decl semantics was a very late\n-  // change). We need a module_attachment_p flag, and this will allow\n-  // some simplification of how we handle header unit entities.\n-  // Hurrah!\n-  unsigned module_purview_p : 1;\t   /* in module purview (not GMF) */\n+  unsigned module_purview_p : 1;\t   // in named-module purview\n+  unsigned module_attach_p : 1;\t\t   // attached to named module\n   unsigned module_import_p : 1;     \t   /* from an import */\n   unsigned module_entity_p : 1;\t\t   /* is in the entitity ary &\n \t\t\t\t\t      hash.  */"}, {"sha": "5654bc754e636ae34cc1c1bed098af57ed77ff56", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "patch": "@@ -2108,30 +2108,31 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n       && TREE_CODE (olddecl) != NAMESPACE_DECL\n       && !hiding)\n     {\n-      if (DECL_ARTIFICIAL (olddecl))\n+      if (!module_may_redeclare (olddecl))\n \t{\n-\t  if (module_attach_p ())\n+\t  if (DECL_ARTIFICIAL (olddecl))\n \t    error (\"declaration %qD conflicts with builtin\", newdecl);\n \t  else\n-\t    DECL_MODULE_EXPORT_P (olddecl) = DECL_MODULE_EXPORT_P (newdecl);\n-\t}\n-      else\n-\t{\n-\t  if (!module_may_redeclare (olddecl))\n \t    {\n \t      error (\"declaration %qD conflicts with import\", newdecl);\n \t      inform (olddecl_loc, \"import declared %q#D here\", olddecl);\n-\n-\t      return error_mark_node;\n \t    }\n \n-\t  if (DECL_MODULE_EXPORT_P (newdecl)\n-\t      && !DECL_MODULE_EXPORT_P (olddecl))\n+\t  return error_mark_node;\n+\t}\n+\n+      tree not_tmpl = STRIP_TEMPLATE (olddecl);\n+      if (DECL_LANG_SPECIFIC (not_tmpl) && DECL_MODULE_ATTACH_P (not_tmpl))\n+\t{\n+\t  if (DECL_MODULE_EXPORT_P (STRIP_TEMPLATE (newdecl))\n+\t      && !DECL_MODULE_EXPORT_P (not_tmpl))\n \t    {\n \t      error (\"conflicting exporting declaration %qD\", newdecl);\n \t      inform (olddecl_loc, \"previous declaration %q#D here\", olddecl);\n \t    }\n \t}\n+      else if (DECL_MODULE_EXPORT_P (newdecl))\n+\tDECL_MODULE_EXPORT_P (not_tmpl) = true;\n     }\n \n   /* We have committed to returning OLDDECL at this point.  */"}, {"sha": "547bf360c4f2a9c39c7bfb35e59a0c4bdcece103", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 69, "deletions": 48, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "patch": "@@ -47,10 +47,14 @@ along with GCC; see the file COPYING3.  If not see\n    module-local index.\n \n    Each importable DECL contains several flags.  The simple set are\n-   DECL_EXPORT_P, DECL_MODULE_PURVIEW_P and DECL_MODULE_IMPORT_P.  The\n-   first indicates whether it is exported, the second whether it is in\n-   the module purview (as opposed to the global module fragment), and\n-   the third indicates whether it was an import into this TU or not.\n+   DECL_MODULE_EXPORT_P, DECL_MODULE_PURVIEW_P, DECL_MODULE_ATTACH_P\n+   and DECL_MODULE_IMPORT_P.  The first indicates whether it is\n+   exported, the second whether it is in module or header-unit\n+   purview.  The third indicates it is attached to the named module in\n+   whose purview it resides and the fourth indicates whether it was an\n+   import into this TU or not.  DECL_MODULE_ATTACH_P will be false for\n+   all decls in a header-unit, and for those in a named module inside\n+   a linkage declaration.\n \n    The more detailed flags are DECL_MODULE_PARTITION_P,\n    DECL_MODULE_ENTITY_P.  The first is set in a primary interface unit\n@@ -2927,7 +2931,7 @@ class trees_in : public bytes_in {\n public:\n   tree decl_container ();\n   tree key_mergeable (int tag, merge_kind, tree decl, tree inner, tree type,\n-\t\t      tree container, bool is_mod);\n+\t\t      tree container, bool is_attached);\n   unsigned binfo_mergeable (tree *);\n \n private:\n@@ -5529,9 +5533,11 @@ trees_out::lang_decl_bools (tree t)\n   WB (lang->u.base.concept_p);\n   WB (lang->u.base.var_declared_inline_p);\n   WB (lang->u.base.dependent_init_p);\n-  /* When building a header unit, everthing is marked as purview, but\n-     that's the GM purview, so not what the importer will mean  */\n+  /* When building a header unit, everthing is marked as purview, (so\n+     we know which decls to write).  But when we import them we do not\n+     want to mark them as in module purview.  */\n   WB (lang->u.base.module_purview_p && !header_module_p ());\n+  WB (lang->u.base.module_attach_p);\n   if (VAR_OR_FUNCTION_DECL_P (t))\n     WB (lang->u.base.module_keyed_decls_p);\n   switch (lang->u.base.selector)\n@@ -5602,6 +5608,7 @@ trees_in::lang_decl_bools (tree t)\n   RB (lang->u.base.var_declared_inline_p);\n   RB (lang->u.base.dependent_init_p);\n   RB (lang->u.base.module_purview_p);\n+  RB (lang->u.base.module_attach_p);\n   if (VAR_OR_FUNCTION_DECL_P (t))\n     RB (lang->u.base.module_keyed_decls_p);\n   switch (lang->u.base.selector)\n@@ -7535,14 +7542,14 @@ trees_out::decl_value (tree decl, depset *dep)\n \t\t or a module entity.  This bool merges into the next block\n \t\t of bools.  Sneaky.  */\n \t      tree o = get_originating_module_decl (decl);\n-\t      bool is_mod = false;\n+\t      bool is_attached = false;\n \n \t      tree not_tmpl = STRIP_TEMPLATE (o);\n \t      if (DECL_LANG_SPECIFIC (not_tmpl)\n-\t\t  && DECL_MODULE_PURVIEW_P (not_tmpl))\n-\t\tis_mod = true;\n+\t\t  && DECL_MODULE_ATTACH_P (not_tmpl))\n+\t\tis_attached = true;\n \n-\t      b (is_mod);\n+\t      b (is_attached);\n \t    }\n \t  b (dep && dep->has_defn ());\n \t}\n@@ -7791,7 +7798,7 @@ tree\n trees_in::decl_value ()\n {\n   int tag = 0;\n-  bool is_mod = false;\n+  bool is_attached = false;\n   bool has_defn = false;\n   unsigned mk_u = u ();\n   if (mk_u >= MK_hwm || !merge_kind_name[mk_u])\n@@ -7812,7 +7819,7 @@ trees_in::decl_value ()\n \t{\n \t  if (!(mk & MK_template_mask) && !state->is_header ())\n \t    /* See note in trees_out about where this bool is sequenced.  */\n-\t    is_mod = b ();\n+\t    is_attached = b ();\n \n \t  has_defn = b ();\n \t}\n@@ -7916,7 +7923,8 @@ trees_in::decl_value ()\n   if (TREE_CODE (inner) == FUNCTION_DECL)\n     parm_tag = fn_parms_init (inner);\n \n-  tree existing = key_mergeable (tag, mk, decl, inner, type, container, is_mod);\n+  tree existing = key_mergeable (tag, mk, decl, inner, type, container,\n+\t\t\t\t is_attached);\n   tree existing_inner = existing;\n   if (existing)\n     {\n@@ -10652,7 +10660,7 @@ check_mergeable_decl (merge_kind mk, tree decl, tree ovl, merge_key const &key)\n \n tree\n trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n-\t\t\t tree type, tree container, bool is_mod)\n+\t\t\t tree type, tree container, bool is_attached)\n {\n   const char *kind = \"new\";\n   tree existing = NULL_TREE;\n@@ -10792,22 +10800,23 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\t\t  }\n \t\t      }\n \t      }\n-\t    else if (is_mod && !(state->is_module () || state->is_partition ()))\n+\t    else if (is_attached\n+\t\t     && !(state->is_module () || state->is_partition ()))\n \t      kind = \"unique\";\n \t    else\n \t      {\n \t\tgcc_checking_assert (mk == MK_named || mk == MK_enum);\n \t\ttree mvec;\n \t\ttree *vslot = mergeable_namespace_slots (container, name,\n-\t\t\t\t\t\t\t !is_mod, &mvec);\n+\t\t\t\t\t\t\t is_attached, &mvec);\n \t\texisting = check_mergeable_decl (mk, decl, *vslot, key);\n \t\tif (!existing)\n \t\t  add_mergeable_namespace_entity (vslot, decl);\n \t\telse\n \t\t  {\n \t\t    /* Note that we now have duplicates to deal with in\n \t\t       name lookup.  */\n-\t\t    if (is_mod)\n+\t\t    if (is_attached)\n \t\t      BINDING_VECTOR_PARTITION_DUPS_P (mvec) = true;\n \t\t    else\n \t\t      BINDING_VECTOR_GLOBAL_DUPS_P (mvec) = true;\n@@ -10824,7 +10833,7 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t    break;\n \n \t  case TYPE_DECL:\n-\t    if (is_mod && !(state->is_module () || state->is_partition ())\n+\t    if (is_attached && !(state->is_module () || state->is_partition ())\n \t\t/* Implicit member functions can come from\n \t\t   anywhere.  */\n \t\t&& !(DECL_ARTIFICIAL (decl)\n@@ -18389,14 +18398,11 @@ get_originating_module (tree decl, bool for_mangle)\n   if (!DECL_LANG_SPECIFIC (not_tmpl))\n     return for_mangle ? -1 : 0;\n \n-  if (for_mangle && !DECL_MODULE_PURVIEW_P (not_tmpl))\n+  if (for_mangle && !DECL_MODULE_ATTACH_P (not_tmpl))\n     return -1;\n \n   int mod = !DECL_MODULE_IMPORT_P (not_tmpl) ? 0 : get_importing_module (owner);\n-\n-  if (for_mangle && (*modules)[mod]->is_header ())\n-    return -1;\n-\n+  gcc_checking_assert (!for_mangle || !(*modules)[mod]->is_header ());\n   return mod;\n }\n \n@@ -18416,9 +18422,34 @@ get_importing_module (tree decl, bool flexible)\n bool\n module_may_redeclare (tree decl)\n {\n+  for (;;)\n+    {\n+      tree ctx = CP_DECL_CONTEXT (decl);\n+      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\t// Found the namespace-scope decl.\n+\tbreak;\n+      if (!CLASS_TYPE_P (ctx))\n+\t// We've met a non-class scope.  Such a thing is not\n+\t// reopenable, so we must be ok.\n+\treturn true;\n+      decl = TYPE_NAME (ctx);\n+    }\n+\n+  tree not_tmpl = STRIP_TEMPLATE (decl);\n+\n+  int use_tpl = 0;\n+  if (node_template_info (not_tmpl, use_tpl) && use_tpl)\n+    // Specializations of any kind can be redeclared anywhere.\n+    // FIXME: Should we be checking this in more places on the scope chain?\n+    return true;\n+\n+  if (!DECL_LANG_SPECIFIC (not_tmpl) || !DECL_MODULE_ATTACH_P (not_tmpl))\n+    // Decl is attached to global module.  Current scope needs to be too.\n+    return !module_attach_p ();\n+\n   module_state *me = (*modules)[0];\n   module_state *them = me;\n-  tree not_tmpl = STRIP_TEMPLATE (decl);\n+\n   if (DECL_LANG_SPECIFIC (not_tmpl) && DECL_MODULE_IMPORT_P (not_tmpl))\n     {\n       /* We can be given the TEMPLATE_RESULT.  We want the\n@@ -18446,30 +18477,14 @@ module_may_redeclare (tree decl)\n       them = import_entity_module (index);\n     }\n \n-  if (them->is_header ())\n-    {\n-      if (!header_module_p ())\n-\treturn !module_purview_p ();\n-\n-      if (DECL_SOURCE_LOCATION (decl) == BUILTINS_LOCATION)\n-\t/* This is a builtin, being declared in header-unit.  We\n-\t   now need to mark it as an export.  */\n-\tDECL_MODULE_EXPORT_P (decl) = true;\n-\n-      /* If it came from a header, it's in the global module.  */\n-      return true;\n-    }\n+  // Decl is attached to named module.  Current scope needs to be\n+  // attaching to the same module.\n+  if (!module_attach_p ())\n+    return false;\n \n+  // Both attached to named module.\n   if (me == them)\n-    return ((DECL_LANG_SPECIFIC (not_tmpl) && DECL_MODULE_PURVIEW_P (not_tmpl))\n-\t    == module_purview_p ());\n-\n-  if (!me->name)\n-    me = me->parent;\n-\n-  /* We can't have found a GMF entity from a named module.  */\n-  gcc_checking_assert (DECL_LANG_SPECIFIC (not_tmpl)\n-\t\t       && DECL_MODULE_PURVIEW_P (not_tmpl));\n+    return true;\n \n   return me && get_primary (them) == get_primary (me);\n }\n@@ -18554,11 +18569,17 @@ set_originating_module (tree decl, bool friend_p ATTRIBUTE_UNUSED)\n {\n   set_instantiating_module (decl);\n \n-  if (TREE_CODE (CP_DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n+  if (!DECL_NAMESPACE_SCOPE_P (decl))\n     return;\n \n   gcc_checking_assert (friend_p || decl == get_originating_module_decl (decl));\n \n+  if (module_attach_p ())\n+    {\n+      retrofit_lang_decl (decl);\n+      DECL_MODULE_ATTACH_P (decl) = true;\n+    }\n+\n   if (!module_exporting_p ())\n     return;\n "}, {"sha": "6bed9dac63f1aa6e8ded2d042337f33cffa7d83a", "filename": "gcc/cp/name-lookup.cc", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fname-lookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fname-lookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.cc?ref=a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "patch": "@@ -3493,11 +3493,13 @@ maybe_record_mergeable_decl (tree *slot, tree name, tree decl)\n     /* Internal linkage.  */\n     return;\n \n-  bool partition = named_module_p ();\n+  bool is_attached = (DECL_LANG_SPECIFIC (not_tmpl)\n+\t\t      && DECL_MODULE_ATTACH_P (not_tmpl));\n   tree *gslot = get_fixed_binding_slot\n-    (slot, name, partition ? BINDING_SLOT_PARTITION : BINDING_SLOT_GLOBAL, true);\n+    (slot, name, is_attached ? BINDING_SLOT_PARTITION : BINDING_SLOT_GLOBAL,\n+     true);\n \n-  if (!partition)\n+  if (!is_attached)\n     {\n       binding_slot &orig\n \t= BINDING_VECTOR_CLUSTER (*slot, 0).slots[BINDING_SLOT_CURRENT];\n@@ -3841,11 +3843,12 @@ pushdecl (tree decl, bool hiding)\n    GMF slot or a module-specific one.  */\n \n tree *\n-mergeable_namespace_slots (tree ns, tree name, bool is_global, tree *vec)\n+mergeable_namespace_slots (tree ns, tree name, bool is_attached, tree *vec)\n {\n   tree *mslot = find_namespace_slot (ns, name, true);\n   tree *vslot = get_fixed_binding_slot\n-    (mslot, name, is_global ? BINDING_SLOT_GLOBAL : BINDING_SLOT_PARTITION, true);\n+    (mslot, name, is_attached ? BINDING_SLOT_PARTITION : BINDING_SLOT_GLOBAL,\n+     true);\n \n   gcc_checking_assert (TREE_CODE (*mslot) == BINDING_VECTOR);\n   *vec = *mslot;\n@@ -4832,10 +4835,10 @@ do_nonmember_using_decl (name_lookup &lookup, bool fn_scope_p,\n \t  if (exporting)\n \t    {\n \t      /* If the using decl is exported, the things it refers\n-\t\t to must also be exported (or not in module purview).  */\n+\t\t to must also be exported (or not habve module attachment).  */\n \t      if (!DECL_MODULE_EXPORT_P (new_fn)\n \t\t  && (DECL_LANG_SPECIFIC (new_fn)\n-\t\t      && DECL_MODULE_PURVIEW_P (new_fn)))\n+\t\t      && DECL_MODULE_ATTACH_P (new_fn)))\n \t\t{\n \t\t  error (\"%q#D does not have external linkage\", new_fn);\n \t\t  inform (DECL_SOURCE_LOCATION (new_fn),"}, {"sha": "999db33a7e00bd5576949e1822f5beb8ada2ec31", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "patch": "@@ -471,7 +471,7 @@ extern void pop_from_top_level (void);\n extern void push_using_decl_bindings (tree, tree);\n \n /* Lower level interface for modules. */\n-extern tree *mergeable_namespace_slots (tree ns, tree name, bool is_global,\n+extern tree *mergeable_namespace_slots (tree ns, tree name, bool is_attached,\n \t\t\t\t\ttree *mvec);\n extern void add_mergeable_namespace_entity (tree *slot, tree decl);\n extern tree lookup_class_binding (tree ctx, tree name);"}, {"sha": "53ce06ccd2df3aef1de9432f820e10fbcb23d513", "filename": "gcc/cp/ptree.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fptree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92ed39c416b2a92f404d9851fdfea5cae7e6b21/gcc%2Fcp%2Fptree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.cc?ref=a92ed39c416b2a92f404d9851fdfea5cae7e6b21", "patch": "@@ -79,12 +79,22 @@ cxx_print_decl (FILE *file, tree node, int indent)\n \t  need_indent = false;\n \t}\n \n-      if (DECL_LANG_SPECIFIC (ntnode) && DECL_MODULE_PURVIEW_P (ntnode))\n+      if (DECL_LANG_SPECIFIC (ntnode))\n \t{\n-\t  if (need_indent)\n-\t    indent_to (file, indent + 3);\n-\t  fprintf (file, \" purview\");\n-\t  need_indent = false;\n+\t  if (DECL_MODULE_PURVIEW_P (ntnode))\n+\t    {\n+\t      if (need_indent)\n+\t\tindent_to (file, indent + 3);\n+\t      fprintf (file, \" purview\");\n+\t      need_indent = false;\n+\t    }\n+\t  if (DECL_MODULE_ATTACH_P (ntnode))\n+\t    {\n+\t      if (need_indent)\n+\t\tindent_to (file, indent + 3);\n+\t      fprintf (file, \" attached\");\n+\t      need_indent = false;\n+\t    }\n \t}\n     }\n "}]}