{"sha": "6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlY2Y0Y2UzYzc0YmMwYjA0YjJkZTc2MmRlOGIwMTIzYzE3ODZiNA==", "commit": {"author": {"name": "Chris Smith", "email": "cks@gnu.org", "date": "1993-05-07T11:54:24Z"}, "committer": {"name": "Chris Smith", "email": "cks@gnu.org", "date": "1993-05-07T11:54:24Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r4377", "tree": {"sha": "3b74de5d3d2e10b0a3e552e4d529612ba9bae562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b74de5d3d2e10b0a3e552e4d529612ba9bae562"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/comments", "author": null, "committer": null, "parents": [{"sha": "dba15dfd3c8f7767c2c27b4943d52f7c83b4b3b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba15dfd3c8f7767c2c27b4943d52f7c83b4b3b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dba15dfd3c8f7767c2c27b4943d52f7c83b4b3b3"}], "stats": {"total": 3591, "additions": 2665, "deletions": 926}, "files": [{"sha": "90d430839a9152989d0216ea9f84e174a44c4220", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 907, "deletions": 112, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Convex.\n-   Copyright (C) 1989,1991 Free Software Foundation, Inc.\n+   Copyright (C) 1988,1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,86 +18,243 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"config.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"real.h\"\n #include \"insn-config.h\"\n #include \"conditions.h\"\n #include \"insn-flags.h\"\n-#include \"output.h\"\n #include \"insn-attr.h\"\n+#include \"output.h\"\n+#include \"expr.h\"\n+\n+#undef NULL\n+#include <stdio.h>\n+\n+/* Tables used in convex.h */\n+\n+char regno_ok_for_index_p_base[1 + LAST_VIRTUAL_REGISTER + 1];\n+enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n+enum reg_class reg_class_from_letter[256];\n+\n+/* Target cpu index. */\n+\n+int target_cpu;\n \n /* Boolean to keep track of whether the current section is .text or not.\n    Used by .align handler in convex.h. */\n \n int current_section_is_text;\n \n-/* set_cmp saves the operands of a \"cmp\" insn, along with the type character\n- * to be used in the compare instruction.\n- *\n- * gen_cmp finds out what comparison is to be performed and outputs the\n- * necessary instructions, e.g.\n- *    \"eq.w a1,a2\\;jbra.t L5\"\n- * for (cmpsi a1 a2) (beq L5)  */\n- \n-static rtx xop0, xop1;\n-static char typech, regch;\n+/* Communication between output_compare and output_condjump. */\n+\n+static rtx cmp_operand0, cmp_operand1;\n+static char cmp_modech;\n+\n+/* Forwards */\n+\n+static rtx frame_argblock;\n+static int frame_argblock_size;\n+static rtx convert_arg_pushes ();\n+static void expand_movstr_call ();\n+\n+/* Here from OVERRIDE_OPTIONS at startup.  Initialize constant tables. */\n+\n+init_convex ()\n+{\n+  int regno;\n+\n+  /* Set A and S reg classes. */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (A_REGNO_P (regno))\n+      {\n+\tregno_ok_for_index_p[regno] = 1;\n+\tregno_reg_class[regno] = INDEX_REGS;\n+      }\n+    else\n+      {\n+\tregno_ok_for_index_p[regno] = 0;\n+\tregno_reg_class[regno] = S_REGS;\n+      }\n+\n+  /* Can't index off the stack pointer, register 0. */\n+  regno_ok_for_index_p[STACK_POINTER_REGNUM] = 0;\n+  regno_reg_class[STACK_POINTER_REGNUM] = SP_REGS;\n+\n+  /* Can't index off aliases of the stack pointer.  */\n+  regno_ok_for_index_p[VIRTUAL_INCOMING_ARGS_REGNUM] = 1;\n+  regno_ok_for_index_p[VIRTUAL_STACK_VARS_REGNUM] = 1;\n+  regno_ok_for_index_p[VIRTUAL_STACK_DYNAMIC_REGNUM] = 0;\n+  regno_ok_for_index_p[VIRTUAL_OUTGOING_ARGS_REGNUM] = 0;\n+\n+  /* Can't index off hard reg -1 == pseudos not assigned */\n+  regno_ok_for_index_p[-1] = 0;\n+\n+  /* Set reg class letters */\n+  reg_class_from_letter['a'] = A_REGS;\n+  reg_class_from_letter['A'] = INDEX_REGS;\n+  reg_class_from_letter['d'] = S_REGS;\n+\n+  /* Turn off floating point exception enables in the psw. */\n+  psw_disable_float ();\n+}\n+\n+psw_disable_float ()\n+{\n+#if __convex__ && __GNUC__\n+  register int *p;\n+  asm (\"mov fp,%0\" : \"=a\" (p));\n+  while (p)\n+    {\n+      p[1] &= ~0x1000c400;\n+      p = (int *) p[2];\n+    }\n+#endif  \n+}\n+\f\n+/* Here to output code for a compare insn.  Output nothing, just\n+   record the operands and their mode. */\n \n char *\n-set_cmp (op0, op1, typechr)\n-     rtx op0, op1;\n-     char typechr;\n-{\n-  xop0 = op0;\n-  xop1 = op1;\n-  typech = typechr;\n-  if (GET_CODE (op0) == REG)\n-    regch = A_REGNO_P (REGNO (op0)) ? 'a' : 's';\n-  else if (GET_CODE (op1) == REG)\n-    regch = A_REGNO_P (REGNO (op1)) ? 'a' : 's';\n-  else abort ();\n+output_cmp (operand0, operand1, modech)\n+     rtx operand0, operand1;\n+     char modech;\n+{\n+  cmp_operand0 = operand0;\n+  cmp_operand1 = operand1;\n+  cmp_modech = modech;\n   return \"\";\n }\n \n+/* Output code for a conditional jump.  The preceding instruction\n+   is necessarily a compare.  Output two instructions, for example\n+       eq.w a1,a2\n+       jbra.t L5\n+   for\n+       (cmpsi a1 a2)\n+       (beq L5)\n+ */\n+\n char *\n-gen_cmp (label, cmpop, tf)\n+output_condjump (label, cond, jbr_sense)\n      rtx label;\n-     char *cmpop;\n-     char tf;\n+     char *cond;\n+     char jbr_sense;\n {\n+  rtx operands[3];\n+  char cmp_op[4];\n   char buf[80];\n-  char revop[4];\n-  rtx ops[3];\n+  char jbr_regch;\n+\n+  strcpy (cmp_op, cond);\n+\n+  /* [BL] mean the value is being compared against immediate 0.\n+     Use neg.x, which produces the same carry that eq.x #0 would if it\n+     existed.  In this case operands[1] is a scratch register, not a\n+     compare operand. */\n \n-  ops[2] = label;\n+  if (cmp_modech == 'B' || cmp_modech == 'L')\n+    {\n+      cmp_modech = cmp_modech - 'A' + 'a';\n+      strcpy (cmp_op, \"neg\");\n+    }\n+\n+  /* [WH] mean the value being compared resulted from \"add.[wh] #-1,rk\"\n+     when rk was nonnegative -- we can omit equality compares against -1\n+     or inequality compares against 0. */\n+\n+  else if (cmp_modech == 'W' || cmp_modech == 'H')\n+    {\n+      if (! strcmp (cmp_op, \"eq\") && cmp_operand1 == constm1_rtx)\n+\tjbr_sense ^= 't' ^ 'f';\n+      else if (! strcmp (cmp_op, \"lt\") && cmp_operand1 == const0_rtx)\n+\t;\n+      else\n+\tcmp_modech = cmp_modech - 'A' + 'a';\n+    }\n \n   /* Constant must be first; swap operands if necessary.\n      If lt, le, ltu, leu are swapped, change to le, lt, leu, ltu\n      and reverse the sense of the jump. */\n \n-  if (CONSTANT_P (xop1))\n+  if (! REG_P (cmp_operand1))\n     {\n-      ops[0] = xop1;\n-      ops[1] = xop0;\n-      if (cmpop[0] == 'l')\n+      operands[0] = cmp_operand1;\n+      operands[1] = cmp_operand0;\n+      if (cmp_op[0] == 'l')\n \t{\n-\t  bcopy (cmpop, revop, sizeof revop);\n-\t  revop[1] ^= 'e' ^ 't';\n-\t  tf ^= 't' ^ 'f';\n-\t  cmpop = revop;\n+\t  cmp_op[1] ^= 'e' ^ 't';\n+\t  jbr_sense ^= 't' ^ 'f';\n \t}\n     }\n   else\n     {\n-      ops[0] = xop0;\n-      ops[1] = xop1;\n+      operands[0] = cmp_operand0;\n+      operands[1] = cmp_operand1;\n     }\n \n-  sprintf (buf, \"%s.%c %%0,%%1\\n\\tjbr%c.%c %%l2\", cmpop, typech, regch, tf);\n-  output_asm_insn (buf, ops);\n+  operands[2] = label;\n+\n+  if (S_REG_P (operands[1]))\n+    jbr_regch = 's';\n+  else if (A_REG_P (operands[1]))\n+    jbr_regch = 'a';\n+  else\n+    abort ();\n+\n+  if (cmp_modech == 'W' || cmp_modech == 'H')\n+    sprintf (buf, \"jbr%c.%c %%l2\", jbr_regch, jbr_sense);\n+  else\n+    sprintf (buf, \"%s.%c %%0,%%1\\n\\tjbr%c.%c %%l2\",\n+\t     cmp_op, cmp_modech, jbr_regch, jbr_sense);\n+  output_asm_insn (buf, operands);\n   return \"\";\n }\n+\n+/* Return 1 if OP is valid for cmpsf.\n+   In IEEE mode, +/- zero compares are not handled by \n+     the immediate versions of eq.s and on some machines, lt.s, and le.s.  \n+   So disallow 0.0 as the immediate operand of xx.s compares in IEEE mode. */\n+\n+int\n+nonmemory_cmpsf_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+#if _IEEE_FLOAT_\n+  if (op == CONST0_RTX (SFmode))\n+    return 0;\n+#endif\n+\n+  return nonmemory_operand (op, mode);\n+}\n+\f\n+/* Convex /bin/as does not like unary minus in some contexts.\n+   Simplify CONST addresses to remove it. */\n+\n+rtx\n+simplify_for_convex (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case MINUS:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) < 0)\n+\t{\n+\t  PUT_CODE (x, PLUS);\n+\t  XEXP (x, 1) = GEN_INT (- INTVAL (XEXP (x, 1)));\n+\t}\n+      break;\n+\n+    case CONST:\n+      return simplify_for_convex (XEXP (x, 0));\n+    }\n+\n+  return x;\n+}\n \f\n /* Routines to separate CONST_DOUBLEs into component parts. */\n \n@@ -121,100 +278,738 @@ const_double_low_int (x)\n     return CONST_DOUBLE_LOW (x);\n }\n \f\n-/* Return the number of args in the call insn X. */\n+/* Inline block copy. */\n \n-static int\n-call_num_args (x)\n-     rtx x;\n+void\n+expand_movstr (operands)\n+     rtx *operands;\n {\n-  if (GET_CODE (x) == CALL)\n-    return INTVAL (x->fld[1].rtx);\n-  if (GET_CODE (x) == SET)\n-    return call_num_args (SET_SRC (x));\n-  abort ();\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int align = INTVAL (operands[3]);\n+  int nregs, maxsize;\n+  unsigned len;\n+  enum machine_mode mode;\n+  rtx reg, load, store, prev_store, prev_store_2;\n+  int size;\n+\n+  /* Decide how many regs to use, depending on load latency, and what\n+     size pieces to move, depending on whether machine does unaligned\n+     loads and stores efficiently. */\n+\n+  if (TARGET_C1)\n+    {\n+      /* ld.l latency is 4, no alignment problems. */\n+      nregs = 3, maxsize = 8;\n+    }\n+  else if (TARGET_C2)\n+    {\n+      /* loads are latency 2 if we avoid ld.l not at least word aligned. */\n+      if (align >= 4)\n+\tnregs = 2, maxsize = 8;\n+      else\n+\tnregs = 2, maxsize = 4;\n+    }\n+  else if (TARGET_C34)\n+    {\n+      /* latency is 4 if aligned, horrible if not. */\n+      nregs = 3, maxsize = align;\n+    }\n+  else if (TARGET_C38)\n+    {\n+      /* latency is 2 if at least word aligned, 3 or 4 if unaligned. */\n+      if (align >= 4)\n+\tnregs = 2, maxsize = 8;\n+      else\n+\tnregs = 3, maxsize = 8;\n+    }\n+  else\n+    abort ();\n+\n+  /* Caller is not necessarily prepared for us to fail in this\n+     expansion.  So fall back by generating memcpy call here. */\n+\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || (len = INTVAL (operands[2])) > (unsigned) 32 * maxsize)\n+    {\n+      expand_movstr_call (operands);\n+      return;\n+    }\n+\n+  reg = 0;\n+  prev_store = prev_store_2 = 0;\n+\n+  while (len > 0)\n+    {\n+      if (len >= 8 && maxsize >= 8)\n+\tmode = DImode;\n+      else if (len >= 4 && maxsize >= 4)\n+\tmode = SImode;\n+      else if (len >= 2 && maxsize >= 2)\n+\tmode = HImode;\n+      else\n+\tmode = QImode;\n+\n+      /* If no temp pseudo to reuse, or not the right mode, make one */\n+      if (! reg || GET_MODE (reg) != mode)\n+\treg = gen_reg_rtx (mode);\n+\n+      /* Get src and dest in the right mode */\n+      if (GET_MODE (src) != mode)\n+\tsrc = change_address (src, mode, 0),\n+\tdest = change_address (dest, mode, 0);\n+\n+      /* Make load and store patterns for this piece */\n+      load = gen_rtx (SET, VOIDmode, reg, src);\n+      store = gen_rtx (SET, VOIDmode, dest, reg);\n+\n+      /* Emit the load and the store from last time. \n+\t When we emit a store, we can reuse its temp reg. */\n+      emit_insn (load);\n+      if (prev_store)\n+\t{\n+\t  reg = SET_SRC (prev_store);\n+\t  emit_insn (prev_store);\n+\t}\n+      else\n+\treg = 0;\n+\n+      /* Queue up the store, for next time or the time after that. */\n+      if (nregs == 2)\n+\tprev_store = store;\n+      else\n+\tprev_store = prev_store_2, prev_store_2 = store;\n+\n+      /* Advance to next piece. */\n+      size = GET_MODE_SIZE (mode);\n+      src = adj_offsettable_operand (src, size);\n+      dest = adj_offsettable_operand (dest, size);\n+      len -= size;\n+    }\n+\n+  /* Finally, emit the last stores. */\n+  if (prev_store)\n+    emit_insn (prev_store);\n+  if (prev_store_2)\n+    emit_insn (prev_store_2);\n }\n \n-/* Scan forward from a call to decide whether we need to reload AP\n-   from 12(FP) after it.  We need to if there can be a reference to\n-   arg_pointer_rtx before the next call, which will clobber AP.\n-   Look forward in the instruction list until encountering a call\n-   (don't need the load), or a reference to AP (do need it), or\n-   a jump (don't know, do the load).  */\n+static void\n+expand_movstr_call (operands)\n+     rtx *operands;\n+{\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+\t\t     VOIDmode, 3,\n+\t\t     XEXP (operands[0], 0), Pmode,\n+\t\t     XEXP (operands[1], 0), Pmode,\n+\t\t     operands[2], SImode);\n+}\n+\f\n+#if _IEEE_FLOAT_\n+#define MAX_FLOAT 3.4028234663852886e+38\n+#define MIN_FLOAT 1.1754943508222875e-38\n+#else\n+#define MAX_FLOAT 1.7014117331926443e+38\n+#define MIN_FLOAT 2.9387358770557188e-39\n+#endif\n \n-static int\n-ap_reload_needed (insn)\n-     rtx insn;\n+void\n+check_float_value (mode, dp)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE *dp;\n {\n-  for (;;)\n+  REAL_VALUE_TYPE d = *dp;\n+\n+  if (mode == SFmode)\n     {\n-      insn = NEXT_INSN (insn);\n-      switch (GET_CODE (insn))\n+      if (d > MAX_FLOAT)\n \t{\n-\tcase JUMP_INSN:\n-\t  /* Basic block ends.  If return, no AP needed, else assume it is. */\n-\t  return GET_CODE (PATTERN (insn)) != RETURN;\n-\tcase CALL_INSN:\n-\t  /* A subsequent call.  AP isn't needed unless the call itself\n-\t     requires it.  But zero-arg calls don't clobber AP, so\n-\t     don't terminate the search in that case. */\n-\t  if (reg_mentioned_p (arg_pointer_rtx, PATTERN (insn)))\n-\t    return 1;\n-\t  if (! TARGET_ARGCOUNT && call_num_args (PATTERN (insn)) == 0)\n-\t    break;\n-\t  return 0;\n-\tcase BARRIER:\n-\t  /* Barrier, don't need AP. */\n-\t  return 0;\n-\tcase INSN:\n-\t  /* Other insn may need AP; if not, keep looking. */\n-\t  if (reg_mentioned_p (arg_pointer_rtx, PATTERN (insn)))\n-\t    return 1;\n+\t  error (\"magnitude of constant too large for `float'\");\n+\t  *dp = MAX_FLOAT;\n+\t}\n+      else if (d < -MAX_FLOAT)\n+\t{\n+\t  error (\"magnitude of constant too large for `float'\");\n+\t  *dp = -MAX_FLOAT;\n+\t}\t\n+      else if ((d > 0 && d < MIN_FLOAT) || (d < 0 && d > -MIN_FLOAT))\n+\t{\n+\t  warning (\"`float' constant truncated to zero\");\n+\t  *dp = 0.0;\n \t}\n     }\n }\n+\f\n+/* Output the label at the start of a function.\n+   Precede it with the number of formal args so debuggers will have\n+   some idea of how many args to print. */\n \n-/* Output the insns needed to do a call. */\n+void\n+asm_declare_function_name (file, name, decl)\n+    FILE *file;\n+    char *name;\n+    tree decl;\n+{\n+  tree parms;\n+  int nargs = list_length (DECL_ARGUMENTS (decl));\n \n-char *\n-output_call (insn, address, argcount)\n-    rtx insn, address, argcount;\n+  char *p, c;\n+  extern char *version_string;\n+  static char vers[4];\n+  int i;\n+  \n+  p = version_string;\n+  for (i = 0; i < 3; ) {\n+    c = *p;\n+    if (c - '0' < (unsigned) 10)\n+      vers[i++] = c;\n+    if (c == 0 || c == ' ')\n+      vers[i++] = '0';\n+    else\n+      p++;\n+  }\n+  fprintf (file, \"\\tds.b \\\"g%s\\\"\\n\", vers);\n+\n+  if (nargs < 100)\n+    fprintf (file, \"\\tds.b \\\"+%02d\\\\0\\\"\\n\", nargs);\n+  else\n+    fprintf (file, \"\\tds.b \\\"+00\\\\0\\\"\\n\");\n+\n+  ASM_OUTPUT_LABEL (file, name);\n+}\n+\f\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'. */\n+/* Convex codes:\n+    %u prints a CONST_DOUBLE's high word\n+    %v prints a CONST_DOUBLE's low word\n+    %z prints a CONST_INT shift count as a multiply operand -- viz. 1 << n.\n+ */\n+\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     char code;\n {\n-  int set_ap = TARGET_ARGCOUNT || argcount != const0_rtx;\n+  long u[2];\n+  REAL_VALUE_TYPE d;\n \n-  /* If AP is used by the call address, evaluate the address into a temp. */\n-  if (reg_mentioned_p (arg_pointer_rtx, address))\n-    if (set_ap)\n-      {\n-\taddress = XEXP (address, 0);\n-\toutput_asm_insn (\"ld.w %0,a1\", &address);\n-\taddress = gen_rtx (MEM, QImode, gen_rtx (REG, Pmode, 9));\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      break;\n+\n+    case MEM:\n+      output_address (XEXP (x, 0));\n+      break;\n+\n+    case CONST_DOUBLE:\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+      switch (GET_MODE (x)) {\n+      case DFmode:\n+#if 0 /* doesn't work, produces dfloats */\n+\tREAL_VALUE_TO_TARGET_DOUBLE (d, u); \n+#else\n+\t{\n+\t  union { double d; int i[2]; } t;\n+\t  t.d = d;\n+\t  u[0] = t.i[0];\n+\t  u[1] = t.i[1];\n+\t}\n+#endif\n+\tif (code == 'u')\n+\t  fprintf (file, \"#%#x\", u[0]);\n+\telse if (code == 'v')\n+\t  fprintf (file, \"#%#x\", u[1]);\n+\telse\n+\t  outfloat (file, d, \"%.17e\", \"#\", \"\");\n+\tbreak;\n+      case SFmode:\n+\toutfloat (file, d, \"%.9e\", \"#\", \"\");\n+\tbreak;\n+      default:\n+\tif (code == 'u')\n+\t  fprintf (file, \"#%d\", CONST_DOUBLE_HIGH (x));\n+\telse\n+\t  fprintf (file, \"#%d\", CONST_DOUBLE_LOW (x));\n       }\n+      break;\n \n-  /* If there are args, point AP to them. */\n-  if (set_ap)\n-    output_asm_insn (\"mov sp,ap\", 0);\n+    default:\n+      if (code == 'z')\n+\t{\n+\t  if (GET_CODE (x) != CONST_INT)\n+\t    abort ();\n+\t  fprintf (file, \"#%d\", 1 << INTVAL (x));\n+\t}\n+      else\n+\t{\n+\t  putc ('#', file);\n+\t  output_addr_const (file, x);\n+\t}\n+    }\n+}\n \n-  /* If we are passing an arg count, convert it to words and push it. */\n-  if (TARGET_ARGCOUNT)\n+/* Print a memory operand whose address is X, on file FILE. */\n+\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  rtx index = 0;\n+  rtx offset = 0;\n+\n+  if (GET_CODE (addr) == MEM)\n     {\n-      argcount = gen_rtx (CONST_INT, VOIDmode, (INTVAL (argcount) + 3) / 4);\n-      output_asm_insn (\"pshea %a0\", &argcount);\n+      fprintf (file, \"@\");\n+      addr = XEXP (addr, 0);\n     }\n \n-  /* The call. */\n-  output_asm_insn (\"calls %0\", &address);\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      index = addr;\n+      break;\n \n-  /* If we clobbered AP, reload it if it is live. */\n-  if (set_ap)\n-    if (ap_reload_needed (insn))\n-      output_asm_insn (\"ld.w 12(fp),ap\", 0);\n+    case PLUS:\n+      index = XEXP (addr, 0);\n+      if (REG_P (index))\n+\toffset = XEXP (addr, 1);\n+      else\n+\t{\n+\t  offset = XEXP (addr, 0);\n+\t  index = XEXP (addr, 1);\n+\t  if (! REG_P (index))\n+\t    abort ();\n+        }\n+      break;\n \n-  /* If we pushed an arg count, pop it and the args. */\n-  if (TARGET_ARGCOUNT)\n-    {\n-      argcount = gen_rtx (CONST_INT, VOIDmode, INTVAL (argcount) * 4 + 4);\n-      output_asm_insn (\"add.w %0,sp\", &argcount);\n+    default:\n+      offset = addr;\n+      break;\n     }\n+\n+  if (offset)\n+    output_addr_const (file, offset);\n+\n+  if (index)\n+    fprintf (file, \"(%s)\", reg_names[REGNO (index)]);\n+}\n+\n+/* Output a float to FILE, value VALUE, format FMT, preceded by PFX\n+   and followed by SFX. */\n+\n+outfloat (file, value, fmt, pfx, sfx)\n+     FILE *file;\n+     REAL_VALUE_TYPE value;\n+     char *fmt, *pfx, *sfx;\n+{\n+  char buf[64];\n+  fputs (pfx, file);\n+  REAL_VALUE_TO_DECIMAL (value, fmt, buf);\n+  fputs (buf, file);\n+  fputs (sfx, file);\n+}\n+\f\n+/* Here during RTL generation of return.  If we are at the final return\n+   in a function, go through the function and replace pushes with stores\n+   into a frame arg block.  This is similar to what ACCUMULATE_OUTGOING_ARGS\n+   does, but we must index off the frame pointer, not the stack pointer,\n+   and the calling sequence does not require the arg block to be at the\n+   top of the stack.  */\n+\n+replace_arg_pushes ()\n+{\n+  end_sequence ();\n+  replace_arg_pushes_1 ();\n+  start_sequence ();\n+}\n+\n+replace_arg_pushes_1 ()\n+{\n+  rtx insn, argblock;\n+  int size;\n+  int n;\n+\n+  /* Look back to see if we are at the return at the end of the function. */\n+  n = 0;\n+  for (insn = get_last_insn (); ; insn = PREV_INSN (insn))\n+    if (! insn || ++n > 5)\n+      return;\n+    else if (GET_CODE (insn) == NOTE\n+\t     && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END)\n+      break;\n+\n+  /* Yes, we are.  Find the max stack depth used by fixable arg pushes. */\n+  size = replace_pushes (0);\n+\n+  /* Allocate block in frame to hold all arg lists. */\n+  argblock = assign_stack_local (BLKmode, size, STACK_BOUNDARY);\n+  \n+  /* Replace pushes with stores into the block. */\n+  replace_pushes (plus_constant (XEXP (argblock, 0), size));\n+}\n+\n+int\n+replace_pushes (arg_addr)\n+     rtx arg_addr;\n+{\n+  struct slot_info { rtx insn; int offs; int size; };\n+#define MAXSLOTS 1024\n+  struct slot_info slots[MAXSLOTS];\n+  rtx insn, pattern, dest;\n+  enum machine_mode mode;\n+  int offs, minoffs;\n+  int nslot, islot;\n+  int args_size, slots_size;\n   \n+  nslot = 0;\n+  offs = 0;\n+  minoffs = 0;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    switch (GET_CODE (insn))\n+      {\n+      case INSN:\n+\tpattern = PATTERN (insn);\n+\tif (GET_CODE (pattern) == SET)\n+\t  {\n+\t    dest = SET_DEST (pattern);\n+\t    mode = GET_MODE (dest);\n+\t    if (push_operand (dest, mode))\n+\t      {\n+\t\toffs -= \n+\t\t  slots[nslot].size = PUSH_ROUNDING (GET_MODE_SIZE (mode));\n+\t\tslots[nslot].offs = offs;\n+\t\tslots[nslot].insn = insn;\n+\t\tnslot++;\n+\t      }\n+\t    else if (dest == stack_pointer_rtx)\n+\t      {\n+\t\trtx src = SET_SRC (pattern);\n+\t\tif (GET_CODE (src) == PLUS\n+\t\t    && XEXP (src, 0) == stack_pointer_rtx\n+\t\t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t  {\n+\t\t    offs -=\n+\t\t      slots[nslot].size = - INTVAL (XEXP (src, 1));\n+\t\t    slots[nslot].offs = 0;\n+\t\t    slots[nslot].insn = insn;\n+\t\t    nslot++;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    slots[nslot].size = 0;\n+\t\t    slots[nslot].offs = 0;\n+\t\t    slots[nslot].insn = 0;\n+\t\t    nslot++;\n+\t\t  }\n+\t      }\n+\t    else if (reg_mentioned_p (stack_pointer_rtx, pattern))\n+\t      {\n+\t\tslots[nslot].size = 0;\n+\t\tslots[nslot].offs = 0;\n+\t\tslots[nslot].insn = 0;\n+\t\tnslot++;\n+\t      }\n+\t    else if (reg_mentioned_p (virtual_stack_dynamic_rtx, pattern)\n+\t\t     || reg_mentioned_p (virtual_outgoing_args_rtx, pattern))\n+\t      {\n+\t\tslots[nslot].size = 0;\n+\t\tslots[nslot].offs = 0;\n+\t\tslots[nslot].insn = 0;\n+\t\tnslot++;\n+\t      }\n+\t  }\n+\telse\n+\t  if (reg_mentioned_p (stack_pointer_rtx, pattern)\n+\t      || reg_mentioned_p (virtual_stack_dynamic_rtx, pattern)\n+\t      || reg_mentioned_p (virtual_outgoing_args_rtx, pattern)\n+\t      || reg_mentioned_p (frame_pointer_rtx, pattern))\n+\t    abort ();\n+\n+\tbreak;\n+\n+      case CALL_INSN:\n+\t{\n+\t  pattern = PATTERN (insn);\n+\t  if (GET_CODE (pattern) != PARALLEL)\n+\t    abort ();\n+\t  pattern = XVECEXP (pattern, 0, 0);\n+\t  if (GET_CODE (pattern) == SET)\n+\t    pattern = SET_SRC (pattern);\n+\t  if (GET_CODE (pattern) != CALL)\n+\t    abort ();\n+\t  args_size = INTVAL (XEXP (pattern, 1));\n+\n+\t  slots_size = 0;\n+\t  for (islot = nslot; islot > 0; islot--)\n+\t    {\n+\t      if (slots[islot - 1].insn == 0)\n+\t\tbreak;\n+\t      if (slots_size >= args_size)\n+\t\tbreak;\n+\t      slots_size += slots[islot - 1].size;\n+\t    }\n+\n+\t  if (slots_size != args_size)\n+\t    {\n+\t      offs += args_size;\n+\t      if (offs > 0)\n+\t\toffs = 0;\n+\t      slots[nslot].size = 0;\n+\t      slots[nslot].offs = 0;\n+\t      slots[nslot].insn = 0;\n+\t      nslot++;\n+\n+\t      if (arg_addr)\n+\t\t{\n+\t\t  /* add insn to pop arg list if left on stack */\n+\t\t  rtx pop_size = XVECEXP (PATTERN (insn), 0, 2);\n+\t\t  if (pop_size != const0_rtx)\n+\t\t    emit_insn_after (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t pop_size),\n+\t\t\t\t     insn);\n+\t\t  insn = NEXT_INSN (insn);\n+\t\t}\n+\t      break;\n+\t    }\n+\n+\t  /* Record size of arg block */\n+\t  if (offs < minoffs)\n+\t    minoffs = offs;\n+\n+\t  /*printf (\"call %d, args\", INSN_UID (insn));*/\n+\t  if (arg_addr)\n+\t    {\n+\t      /* store arg block + offset as arg list address for call */\n+\t      XVECEXP (PATTERN (insn), 0, 3) = plus_constant (arg_addr, offs);\n+\n+\t      /* rewrite arg instructions to use block */\n+\t      while (nslot > islot)\n+\t\t{\n+\t\t  nslot--;\n+\t\t  /*printf (\" insn %d size %d offs %d\",\n+\t\t\t  INSN_UID(slots[nslot].insn),\n+\t\t\t  slots[nslot].size,\n+\t\t\t  slots[nslot].offs);*/\n+\n+\t\t  if (slots[nslot].offs == 0)\n+\t\t    delete_insn (slots[nslot].insn);\n+\t\t  else\n+\t\t    {\n+\t\t      rtx pattern = PATTERN (slots[nslot].insn);\n+\t\t      enum machine_mode mode = GET_MODE (SET_DEST (pattern));\n+\t\t      if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (SImode))\n+\t\t\t{\n+\t\t\t  SET_SRC (pattern) =\n+\t\t\t    gen_lowpart (SImode, SET_SRC (pattern));\n+\t\t\t  SET_DEST (pattern) =\n+\t\t\t    gen_rtx (MEM, SImode,\n+\t\t\t\t     plus_constant (arg_addr,\n+\t\t\t\t\t\t    slots[nslot].offs));\n+\t\t\t}\n+\t\t      else\n+\t\t\tSET_DEST (pattern) = \n+\t\t\t  gen_rtx (MEM, mode,\n+\t\t\t\t   plus_constant (arg_addr,\n+\t\t\t\t\t\t  slots[nslot].offs));\n+\t\t    }\n+\t\t}\n+\t      /*printf (\"\\n\");*/\n+\t    }\n+\n+\t  nslot = islot;\n+\n+\t  offs += args_size;\n+\t  if (offs > 0)\n+\t    abort ();\n+\t}\n+\tbreak;\n+\n+      case CODE_LABEL:\n+      case JUMP_INSN:\n+      case BARRIER:\n+\tnslot = offs = 0;\n+      }\n+\n+  /*printf (\"min offset %d\\n\", minoffs);*/\n+  return -minoffs;\n+}\n+\n+/* Output the insns needed to do a call.  operands[] are\n+     0 - MEM, the place to call\n+     1 - CONST_INT, the number of bytes in the arg list\n+     2 - CONST_INT, the number of arguments\n+     3 - address of the arg list.  \n+ */\n+\n+char *\n+output_call (insn, operands)\n+     rtx insn, *operands;\n+{\n+  /*if (operands[3] == stack_pointer_rtx)\n+    output_asm_insn (\"mov sp,ap\");\n+  else\n+    output_asm_insn (\"ldea %a4,ap\", operands);*/\n+\n+  if (TARGET_ARGCOUNT)\n+    output_asm_insn (\"pshea %a2\", operands);\n+\n+  output_asm_insn (\"calls %0\", operands);\n+\n+  /*output_asm_insn (\"ld.w 12(fp),ap\");*/\n+\n+  /*if (operands[3] == stack_pointer_rtx && operands[1] != const0_rtx)\n+    output_asm_insn (\"add.w %1,sp\", operands);*/\n+\n   return \"\";\n }\n+\n+\n+/* Here after reloading, before the second scheduling pass.\n+   Insert explicit AP moves. */\n+\n+emit_ap_optimizations ()\n+{\n+  end_sequence ();\n+  insert_ap_loads ();\n+  start_sequence ();\n+}\n+\n+#define LABEL_DEAD_AP(INSN) ((INSN)->volatil)\n+\n+insert_ap_loads ()\n+{\n+  rtx insn, pattern, src;\n+  int ap_is_live, doagain;\n+\n+  /* Check that code_label->volatil is not being used for something else */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_DEAD_AP (insn))\n+\tabort ();\n+\n+  ap_is_live = 0;\n+\n+  do\n+    {\n+      doagain = 0;\n+      for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+\tswitch (GET_CODE (insn))\n+\t  {\n+\t  case INSN:\n+\t    pattern = PATTERN (insn);\n+\t    if (! ap_is_live)\n+\t      {\n+\t\tif (reg_mentioned_p (arg_pointer_rtx, pattern))\n+\t\t  ap_is_live = 1;\n+\t      }\n+\t    break;\n+\n+\t  case CALL_INSN:\n+\t    pattern = PATTERN (insn);\n+\t    if (XVECEXP (pattern, 0, 2) != const0_rtx)\n+\t      ap_is_live = reg_mentioned_p (arg_pointer_rtx, pattern);\n+\t    break;\n+\n+\t  case CODE_LABEL:\n+\t    if (! ap_is_live)\n+\t      {\n+\t\tif (! LABEL_DEAD_AP (insn))\n+\t\t  doagain = 1;\n+\t\tLABEL_DEAD_AP (insn) = 1;\n+\t      }\n+\t    break;\n+\n+\t  case JUMP_INSN:\n+\t    pattern = PATTERN (insn);\n+\t    if (GET_CODE (pattern) == RETURN)\n+\t      ap_is_live = 0;\n+\t    else if (JUMP_LABEL (insn))\n+\t      {\n+\t\tif (simplejump_p (insn))\n+\t\t  ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n+\t\telse if (! ap_is_live && condjump_p (insn))\n+\t\t  ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n+\t\telse\n+\t\t  ap_is_live = 1;\n+\t      }\n+\t    else\n+\t      ap_is_live = 1;\n+\t    break;\n+\n+\t  case BARRIER:\n+\t    ap_is_live = 0;\n+\t    break;\n+\t  }\n+    } while (doagain);\n+\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    switch (GET_CODE (insn))\n+      {\n+      case INSN:\n+\tpattern = PATTERN (insn);\n+\tif (! ap_is_live)\n+\t  {\n+\t    if (reg_mentioned_p (arg_pointer_rtx, pattern))\n+\t      ap_is_live = 1;\n+\t  }\n+\tbreak;\n+\n+      case CALL_INSN:\n+\tpattern = PATTERN (insn);\n+\tif (XVECEXP (pattern, 0, 2) != const0_rtx)\n+\t  {\n+\t    rtx arg_addr = XVECEXP (pattern, 0, 3);\n+\t    emit_insn_before (gen_movsi (arg_pointer_rtx, arg_addr), insn);\n+\t    if (ap_is_live)\n+\t      emit_insn_after (gen_movsi (arg_pointer_rtx,\n+\t\t\t\t\t  gen_rtx (MEM, SImode,\n+\t\t\t\t\t\t   gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t\t\t    frame_pointer_rtx,\n+\t\t\t\t\t\t\t    GEN_INT (12)))),\n+\t\t\t       insn);\n+\t    XVECEXP (pattern, 0, 3) = const0_rtx;\n+\t    insn = PREV_INSN (insn);\n+\t    ap_is_live = 0;\n+\t  }\n+\tbreak;\n+\n+      case CODE_LABEL:\n+\tif (ap_is_live != ! LABEL_DEAD_AP (insn))\n+\t  abort ();\n+\tbreak;\n+\n+      case JUMP_INSN:\n+\tpattern = PATTERN (insn);\n+\tif (GET_CODE (pattern) == RETURN)\n+\t  ap_is_live = 0;\n+\telse if (JUMP_LABEL (insn))\n+\t  {\n+\t    if (simplejump_p (insn))\n+\t      ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n+\t    else if (! ap_is_live && condjump_p (insn))\n+\t      ap_is_live = ! LABEL_DEAD_AP (JUMP_LABEL (insn));\n+\t    else\n+\t      ap_is_live = 1;\n+\t  }\n+\telse\n+\t  ap_is_live = 1;\n+\tbreak;\n+\n+      case BARRIER:\n+\tap_is_live = 0;\n+\tbreak;\n+      }\n+\n+  /* Clear code-label flag recording dead ap's. */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == CODE_LABEL)\n+      LABEL_DEAD_AP (insn) = 0;\n+}"}, {"sha": "1400ab4988ba9ac0746a903e77d6bafff0a0f43b", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 613, "deletions": 270, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Convex version.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -22,28 +22,75 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n extern int target_flags;\n \n-/* Interface to convex.c. */\n+/* Convex machine-specific flags\n+   -mc1\t\t      target instruction set, libraries, scheduling \n+   -mc2\t\n+   -mc32\n+   -mc34\n+   -mc38\n+   -margcount\t      use standard calling sequence, with arg count word\n+   -mno-argcount      don't push arg count, depend on symbol table\n+   -margcount-nop     place arg count in a nop instruction (faster than push)\n+   -mvolatile-cache   use data cache for volatile mem refs (default)\n+   -mvolatile-nocache  bypass data cache for volatile mem refs\n+   -mlong32\t      cc- and libc-compatible 32-bit longs\n+   -mlong64\t      64-bit longs\n+*/\n \n-extern int current_section_is_text;\n-extern int const_double_low_int ();\n-extern int const_double_high_int ();\n-extern char *set_cmp (), *gen_cmp ();\n-extern char *output_call ();\n+/* Macro to define tables used to set -mXXX flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n \n-/* Use the proper incantation to search Posix-compliant libraries. */\n+#ifndef TARGET_DEFAULT\n+#error Use one of convex1.h, convex2.h, etc.\n+#endif\n \n-#define LINK_SPEC \\\n-\"%{!traditional:-Eposix}%{traditional:-Enoposix}\\\n- -A__iob=___ap$iob\\\n- -A_use_libc_sema=___ap$use_libc_sema\\\n- -L /usr/lib\"\n+#define TARGET_SWITCHES \\\n+  { { \"c1\", 001 }, \t\\\n+    { \"c2\", 002 },\t\\\n+    { \"c32\", 004 },\t\\\n+    { \"c34\", 010 },\t\\\n+    { \"c38\", 020 },\t\\\n+    { \"argcount\", 0100 }, \\\n+    { \"argcount-nop\", 0200 }, \\\n+    { \"no-argcount\", -0300 }, \\\n+    { \"volatile-cache\", -0400 }, \\\n+    { \"no-volatile-cache\", 0400 }, \\\n+    { \"volatile-nocache\", 0400 }, \\\n+    { \"long64\", 01000 }, \\\n+    { \"long32\", -01000 }, \\\n+    { \"\", TARGET_DEFAULT }}\n \n-/* Use the matching startup files. */\n+/* Macros used in the machine description to test the flags.  */\n \n-#define STARTFILE_SPEC \\\n-\"%{pg:/usr/lib/crt/gcrt0.o}\\\n-%{!pg:%{p:/usr/lib/crt/mcrt0.o}\\\n-%{!p:/usr/lib/crt/crt0.o}}\"\n+#define TARGET_C1 (target_cpu == 0)\n+#define TARGET_C2 (target_cpu == 1)\n+#define TARGET_C34 (target_cpu == 2)\n+#define TARGET_C38 (target_cpu == 3)\n+#define TARGET_ARGCOUNT (target_flags & 0100)\n+#define TARGET_ARGCOUNT_NOP (target_flags & 0200)\n+#define TARGET_LONG64 (target_flags & 01000)\n+#define TARGET_VOLATILE_NOCACHE (target_flags & 0400)\n+\n+#define OVERRIDE_OPTIONS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern int dollars_in_ident;\t\t\t\t\t\t\\\n+  init_convex ();\t\t\t\t\t\t\t\\\n+  /* To compile system header files, allow $ in identifiers even if -ansi */ \\\n+  dollars_in_ident = 1;\t\t\t\t\t\t\t\\\n+  if ((target_flags & 077) != (TARGET_DEFAULT & 077))\t\t\t\\\n+    target_flags &= ~TARGET_DEFAULT;\t\t\t\t\t\\\n+  if (target_flags & 001)\t\t\t\t\t\t\\\n+    target_cpu = 0;\t\t\t\t\t\t\t\\\n+  else if (target_flags & 006)\t\t\t\t\t\t\\\n+    target_cpu = 1;\t\t\t\t\t\t\t\\\n+  else if (target_flags & 010)\t\t\t\t\t\t\\\n+    target_cpu = 2;\t\t\t\t\t\t\t\\\n+  else if (target_flags & 020)\t\t\t\t\t\t\\\n+    target_cpu = 3;\t\t\t\t\t\t\t\\\n+}\n \n /* Names to predefine in the preprocessor for this target machine.  */\n \n@@ -53,52 +100,338 @@ extern char *output_call ();\n \n #define TARGET_VERSION fprintf (stderr, \" (convex)\");\n \n-/* Macros used in the machine description to test the flags.  */\n+/* Target-dependent specs.\n+   Some libraries come in c1 and c2+ versions; use the appropriate ones.\n+   Make a target-dependent __convex_cxx__ define to relay the target cpu\n+   to the program being compiled. */\n+\n+#if TARGET_DEFAULT & 1\n+\n+/* C1 default */\n+\n+#if _IEEE_FLOAT_\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{!mc2:%{!mc32:%{!mc34:%{!mc38:-D__convex_c1__}}}}\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n \n-/* \n-   -mc1\t\tC1 target (avoid C2-only instructions)\n-   -mc2\t\tC2 target\n-   -mc32\tvitesse\n-   -mc34\tjavelin\n-   -mc38\tneptune\n-   -margcount\tuse standard calling sequence, with arg count word\n-   -mnoargcount don't push arg count, depend on symbol table\n-*/\n+#else\n \n-#define TARGET_C1 (target_flags & 1)\n-#define TARGET_C2 (target_flags & 2)\n-#define TARGET_C34 (target_flags & 4)\n-#define TARGET_C38 (target_flags & 010)\n-#define TARGET_INDIRECTS (1)\n-#define TARGET_ARGCOUNT (target_flags & 040)\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{!mc2:%{!mc32:%{!mc34:%{!mc38:-D__convex_c1__}}}}\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n \n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n+#endif\n \n-#define TARGET_SWITCHES \\\n-  { { \"c1\", 021 }, \t\\\n-    { \"c2\", 022 },\t\\\n-    { \"c32\", 022 },\t\\\n-    { \"c34\", 006 },\t\\\n-    { \"c38\", 012 },\t\\\n-    { \"noc1\", -001 }, \t\\\n-    { \"noc2\", -002 },\t\\\n-    { \"argcount\", 040 },  \\\n-    { \"noargcount\", -040 }, \\\n-    { \"\", TARGET_DEFAULT }}\n+#define LIB_SPEC\t\t\t\t\t\t\t\\\n+\"%{!mc2:%{!mc32:%{!mc34:%{!mc38:-lC1%{traditional:_old}%{p:_p}%{pg:_p}}}}} \\\n+ %{mc2:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc32:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc34:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ -lc%{traditional:_old}%{p:_p}%{pg:_p}\"\n \n-/* Default target_flags if no switches specified.  */\n+#endif\n+\n+#if TARGET_DEFAULT & 2\n+\n+/* C2 default */\n+\n+#if _IEEE_FLOAT_\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc32:%{!mc34:%{!mc38:-D__convex_c2__}}}}\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#else\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc32:%{!mc34:%{!mc38:-D__convex_c2__}}}}\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#endif\n+\n+#define LIB_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-lC1%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{!mc1:%{!mc32:%{!mc34:%{!mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}}}} \\\n+ %{mc32:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc34:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ -lc%{traditional:_old}%{p:_p}%{pg:_p}\"\n+\n+#endif\n+\n+#if TARGET_DEFAULT & 4\n+\n+/* C32 default */\n+\n+#if _IEEE_FLOAT_\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc34:%{!mc38:-D__convex_c32__}}}}\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#else\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc34:%{!mc38:-D__convex_c32__}}}}\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#endif\n+\n+#define LIB_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-lC1%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc2:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc34:%{!mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}}}} \\\n+ %{mc34:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ -lc%{traditional:_old}%{p:_p}%{pg:_p}\"\n+\n+#endif\n+\n+#if TARGET_DEFAULT & 010\n+\n+/* C34 default */\n+\n+#if _IEEE_FLOAT_\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc32:%{!mc38:-D__convex_c34__}}}}\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#else\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc32:%{!mc38:-D__convex_c34__}}}}\t\t\t\\\n+ %{mc38:-D__convex_c38__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#endif\n+\n+#define LIB_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-lC1%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc2:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc32:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc32:%{!mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}}}} \\\n+ %{mc38:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ -lc%{traditional:_old}%{p:_p}%{pg:_p}\"\n+\n+#endif\n+\n+#if TARGET_DEFAULT & 020\n+\n+/* C38 default */\n+\n+#if _IEEE_FLOAT_\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_IEEE_FLOAT_\t\t\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc32:%{!mc34:-D__convex_c38__}}}}\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#else\n+\n+#define CPP_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-D__convex_c1__}\t\t\t\t\t\t\t\\\n+ %{mc2:-D__convex_c2__}\t\t\t\t\t\t\t\\\n+ %{mc32:-D__convex_c32__}\t\t\t\t\t\t\\\n+ %{mc34:-D__convex_c34__}\t\t\t\t\t\t\\\n+ %{fno-builtin:-D__NO_INLINE}\t\t\t\t\t\t\\\n+ -D__NO_INLINE_MATH -D__NO_INLINE_STDLIB\t\t\t\t\\\n+ -D_CONVEX_FLOAT_\t\t\t\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc32:%{!mc34:-D__convex_c38__}}}}\t\t\t\\\n+ %{.S:-P}\t\t\t\t\t\t\t\t\\\n+ %{!traditional:-D__stdc__}\t\t\t\t\t\t\\\n+ %{!traditional:-D_LONGLONG}\t\t\t\t\t\t\\\n+ %{!traditional:-Ds64_t=long\\\\ long -Du64_t=unsigned\\\\ long\\\\ long}\t\\\n+ %{!ansi:-D_POSIX_SOURCE}\t\t\t\t\t\t\\\n+ %{!ansi:-D_CONVEX_SOURCE}\"\n+\n+#endif\n+\n+#define LIB_SPEC\t\t\t\t\t\t\t\\\n+\"%{mc1:-lC1%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc2:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc32:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{mc34:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}\t\t\t\t\\\n+ %{!mc1:%{!mc2:%{!mc32:%{!mc34:-lC2%{traditional:_old}%{p:_p}%{pg:_p}}}}} \\\n+ -lc%{traditional:_old}%{p:_p}%{pg:_p}\"\n+\n+#endif\n+\n+#if _IEEE_FLOAT_\n+\n+/* ieee default */\n+\n+#define ASM_SPEC \"-fi\"\n+\n+#define LINK_SPEC\t\t\t\t\t\t\t\\\n+\"-E%{traditional:no}posix\t\t\t\t\t\t\\\n+ -X\t\t\t\t\t\t\t\t\t\\\n+ %{F} %{M*} %{y*}\t\t\t\t\t\t\t\\\n+ -fi\t\t\t\t\t\t\t\t\t\\\n+ -A__iob=___ap$iob\t\t\t\t\t\t\t\\\n+ -A_use_libc_sema=___ap$use_libc_sema\t\t\t\t\t\\\n+ %{traditional:-A__gcc_cleanup=__cleanup}\t\t\t\t\\\n+ %{!traditional:-A__gcc_cleanup=___ap$do_registered_functions}\t\t\\\n+ -L/usr/lib\"\n+\n+#define STARTFILE_SPEC\t\t\t\t\t\t\t\\\n+\"%{!pg:%{!p:/usr/lib/crt/crt0.o}}\t\t\t\t\t\\\n+ %{!pg:%{p:/usr/lib/crt/mcrt0.o}}\t\t\t\t\t\\\n+ %{pg:/usr/lib/crt/gcrt0.o}\t\t\t\t\t\t\\\n+ /usr/lib/crt/fpmode_i.o\"\n+\n+#else\n+\n+/* native default */\n+\n+#define ASM_SPEC \"-fn\"\n+\n+#define LINK_SPEC\t\t\t\t\t\t\t\\\n+\"-E%{traditional:no}posix\t\t\t\t\t\t\\\n+ -X\t\t\t\t\t\t\t\t\t\\\n+ %{F} %{M*} %{y*}\t\t\t\t\t\t\t\\\n+ -fn\t\t\t\t\t\t\t\t\t\\\n+ -A__iob=___ap$iob\t\t\t\t\t\t\t\\\n+ -A_use_libc_sema=___ap$use_libc_sema\t\t\t\t\t\\\n+ %{traditional:-A___gcc_cleanup=__cleanup}\t\t\t\t\\\n+ %{!traditional:-A___gcc_cleanup=___ap$do_registered_functions}\t\t\\\n+ -L/usr/lib\"\n+\n+#define STARTFILE_SPEC\t\t\t\t\t\t\t\\\n+\"%{!pg:%{!p:/usr/lib/crt/crt0.o}}\t\t\t\t\t\\\n+ %{!pg:%{p:/usr/lib/crt/mcrt0.o}}\t\t\t\t\t\\\n+ %{pg:/usr/lib/crt/gcrt0.o}\"\n \n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n #endif\n \n+/* Use /path/libgcc.a instead of -lgcc, makes bootstrap work more smoothly. */\n+\n+#define LINK_LIBGCC_SPECIAL\n+\n /* Allow $ in identifiers. */\n \n #define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* Since IEEE support was added to gcc, most things seem to like it\n+   better if we disable exceptions and check afterward for infinity. */\n+\n+#if __convex__\n+#if _IEEE_FLOAT_\n+#define REAL_VALUE_ISNAN(x) 0\n+#define REAL_VALUE_ISINF(x) ((*(short *) &(x) & 0x7ff0) == 0x7ff0)\n+#else\n+#define REAL_VALUE_ISNAN(x) 0\n+#define REAL_VALUE_ISINF(x) ((*(short *) &(x) & 0xfff0) == 0x8000)\n+#endif\n+#endif\n \f\n /* Target machine storage layout */\n \n@@ -132,7 +465,7 @@ extern char *output_call ();\n #define PARM_BOUNDARY 32\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 32\n+#define STACK_BOUNDARY 64\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 16\n@@ -147,7 +480,7 @@ extern char *output_call ();\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n /* No data type wants to be aligned rounder than this.  */\n-/* beware of doubles in structs -- 64 is incompatible with pcc */\n+/* beware of doubles in structs -- 64 is incompatible with cc */\n #define BIGGEST_ALIGNMENT 32\n \n /* Set this nonzero if move instructions will actually fail to work\n@@ -159,7 +492,7 @@ extern char *output_call ();\n #define CHAR_TYPE_SIZE\t\t8\n #define SHORT_TYPE_SIZE\t\t16\n #define INT_TYPE_SIZE\t\t32\n-#define LONG_TYPE_SIZE\t\t32\n+#define LONG_TYPE_SIZE\t\t(TARGET_LONG64 ? 64 : 32)\n #define LONG_LONG_TYPE_SIZE\t64\n #define FLOAT_TYPE_SIZE\t\t32\n #define DOUBLE_TYPE_SIZE\t64\n@@ -183,15 +516,23 @@ extern char *output_call ();\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    For Convex, these are AP, FP, and SP.  */\n-#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1} \n+#define FIXED_REGISTERS \\\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n+#define CALL_USED_REGISTERS \\\n+  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+   For Convex, put S0 (the return register) last. */\n+#define REG_ALLOC_ORDER \\\n+  { 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 0, 8, 14, 15 }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -203,30 +544,28 @@ extern char *output_call ();\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On Convex, S registers can hold any type, A registers any nonfloat. */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((REGNO) < 8 || (GET_MODE_CLASS (MODE) != MODE_FLOAT &&\t\t\\\n-\t\t   GET_MODE_CLASS (MODE) != MODE_COMPLEX_FLOAT &&\t\\\n-\t\t   (MODE) != DImode))\n+  (S_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n+   || (GET_MODE_SIZE (MODE) <= 4 && (MODE) != SFmode))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)  \\\n-    ((GET_MODE_CLASS (MODE1) == MODE_FLOAT \\\n-      || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT \\\n-      || (MODE1) == DImode) \\\n-     == (GET_MODE_CLASS (MODE2) == MODE_FLOAT \\\n-\t || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT \\\n-\t || (MODE2) == DImode))\n+  ((GET_MODE_SIZE (MODE1) <= 4 && (MODE1) != SFmode)\t\t\t\\\n+   == (GET_MODE_SIZE (MODE2) <= 4 && (MODE2) != SFmode))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n+#define S0_REGNUM 0\n+#define A0_REGNUM 8\n+\n /* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 8\n+#define STACK_POINTER_REGNUM A0_REGNUM\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 15\n+#define FRAME_POINTER_REGNUM (A0_REGNUM + 7)\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -235,16 +574,16 @@ extern char *output_call ();\n #define FRAME_POINTER_REQUIRED 1\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 14\n+#define ARG_POINTER_REGNUM (A0_REGNUM + 6)\n \n /* Register in which static-chain is passed to a function.\n    Use S0, not an A reg, because this rare use would otherwise prevent\n    an A reg from being available to global-alloc across calls.  */\n-#define STATIC_CHAIN_REGNUM 0\n+#define STATIC_CHAIN_REGNUM S0_REGNUM\n \n /* Register in which address to store a structure value\n    is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 9\n+#define STRUCT_VALUE_REGNUM (A0_REGNUM + 1)\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -268,10 +607,11 @@ extern char *output_call ();\n    \n /* Convex has classes A (address) and S (scalar).\n    A is further divided into SP_REGS (stack pointer) and INDEX_REGS.\n-   Seems to work better to put S first, here and in the md. */\n+   SI_REGS is S_REGS + INDEX_REGS -- all the regs except SP. */\n \n enum reg_class {\n-  NO_REGS, S_REGS, INDEX_REGS, SP_REGS, A_REGS, ALL_REGS, LIM_REG_CLASSES \n+  NO_REGS, S_REGS, INDEX_REGS, SP_REGS, A_REGS, SI_REGS,\n+  ALL_REGS, LIM_REG_CLASSES \n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n@@ -284,24 +624,26 @@ enum reg_class {\n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"S_REGS\", \"INDEX_REGS\", \"SP_REGS\", \"A_REGS\", \"ALL_REGS\" }\n+ {\"NO_REGS\", \"S_REGS\", \"INDEX_REGS\", \"SP_REGS\", \"A_REGS\", \"SI_REGS\", \\\n+  \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS {0, 0x00ff, 0xfe00, 0x0100, 0xff00, 0xffff}\n+#define REG_CLASS_CONTENTS \\\n+  { 0, 0x00ff, 0xfe00, 0x0100, 0xff00, 0xfeff, 0xffff }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n #define REGNO_REG_CLASS(REGNO) \\\n-  (S_REGNO_P (REGNO) ? S_REGS : REGNO == 8 ? SP_REGS : INDEX_REGS)\n+  ((REGNO) >= FIRST_PSEUDO_REGISTER ? abort() : regno_reg_class[REGNO])\n \n-#define S_REGNO_P(REGNO) ((REGNO) < 8)\n-#define A_REGNO_P(REGNO) ((REGNO) >= 8)\n+#define S_REGNO_P(REGNO) (((REGNO) - S0_REGNUM) < (unsigned) 8)\n+#define A_REGNO_P(REGNO) (((REGNO) - A0_REGNUM) < (unsigned) 8)\n \n #define S_REG_P(X) (REG_P (X) && S_REGNO_P (REGNO (X)))\n #define A_REG_P(X) (REG_P (X) && A_REGNO_P (REGNO (X)))\n@@ -312,56 +654,60 @@ enum reg_class {\n #define BASE_REG_CLASS INDEX_REGS\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n-/* S regs use the letter 'd' because 's' is taken. */\n+/* a => A_REGS\n+   d => S_REGS  ('s' is taken)\n+   A => INDEX_REGS  (i.e., A_REGS except sp) */\n \n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'a' ? A_REGS : \\\n-   (C) == 'd' ? S_REGS : \\\n-   (C) == 'A' ? INDEX_REGS : \\\n-   NO_REGS)\n+  reg_class_from_letter[(unsigned char) (C)]\n \n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n    This macro defines what the ranges are.\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.  */\n+/* 'I' is used to pass any CONST_INT and reject any CONST_DOUBLE.\n+   CONST_DOUBLE integers are handled by G and H constraint chars. */\n \n-/* Convex uses only I:\n-   32-bit value with sign bit off, usable as immediate in DImode logical \n-     instructions and, or, xor */ \n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  ((VALUE) >= 0)\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  1\n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.  */\n-/* Convex uses only G:\n+/* Convex uses G, H:\n    value usable in ld.d (low word 0) or ld.l (high word all sign) */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-  (LD_D_P (VALUE) || LD_L_P (VALUE))\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  (((C) == 'G' && LD_D_P (VALUE)) ||\t\t\t\t\t\\\n+   ((C) == 'H' && LD_L_P (VALUE)) ||\t\t\t\t\t\\\n+   0)\n \n #define LD_D_P(X) (const_double_low_int (X) == 0)\n \n #define LD_L_P(X) (const_double_low_int (X) >= 0 \\\n \t\t   ? const_double_high_int (X) == 0 \\\n \t\t   : const_double_high_int (X) == -1)\n \n+/* Optional extra constraints for this machine.\n+   For Convex, 'Q' means that OP is a volatile MEM.\n+   For volatile scalars, we use instructions that bypass the data cache. */\n+\n+#define EXTRA_CONSTRAINT(OP, C) \\\n+  ((C) == 'Q' ? (GET_CODE (OP) == MEM && MEM_VOLATILE_P (OP)\t\t\\\n+\t\t && ! TARGET_C1 && TARGET_VOLATILE_NOCACHE)   \t\t\\\n+   : 0)\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n \n-/* CONST_DOUBLEs (constraint 'F') are passed by LEGITIMATE_CONSTANT_P\n-   without regard to their value.  Constraint 'G' is used by instructions\n-   that need to reject non-immediate values.  The rejected values are\n-   dealt with by reload -- PREFERRED_RELOAD_CLASS returns NO_REGS for\n-   nonimmediate values, causing reload to put them in memory.  Every insn\n-   that uses 'G' must have an alternative that accepts memory.  */\n+/* Put 2-word constants that can't be immediate operands into memory. */\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n-  (GET_CODE (X) != CONST_DOUBLE ? (CLASS) : \\\n-   (GET_MODE (X) != TFmode && (LD_L_P (X) || LD_D_P (X))) ? (CLASS) : NO_REGS)\n-   \n+  ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n+    || GET_MODE (X) == SFmode\t\t\t\t\t\t\\\n+    || LD_L_P (X) || LD_D_P (X))  ? (CLASS) : NO_REGS)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)  ((GET_MODE_SIZE (MODE) + 7) / 8)\n@@ -399,27 +745,21 @@ enum reg_class {\n    FUNTYPE is the data type of the function (as a tree),\n    or for a library call it is an identifier node for the subroutine name.\n    SIZE is the number of bytes of arguments passed on the stack.  */\n-/* The standard Convex call, with arg count word, includes popping the\n-   args as part of the call template.  We optionally omit the arg count\n-   word and let gcc combine the arg pops. */\n-#define RETURN_POPS_ARGS(FUNTYPE, SIZE) (TARGET_ARGCOUNT ? (SIZE) : 0)\n+\n+#define RETURN_POPS_ARGS(FUNTYPE, SIZE) (SIZE)\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n-/* On Convex the return value is in S0 regardless.  */   \n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), S0_REGNUM)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-/* On Convex the return value is in S0 regardless.  */   \n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, S0_REGNUM)\n \n /* Define this if PCC uses the nonreentrant convention for returning\n    structure and union values.  */\n@@ -429,7 +769,7 @@ enum reg_class {\n /* 1 if N is a possible register number for a function value.\n    On the Convex, S0 is the only register thus used.  */\n \n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == S0_REGNUM)\n \n /* 1 if N is a possible register number for function argument passing. */\n \n@@ -439,30 +779,24 @@ enum reg_class {\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On convex, this is a single integer, which is a number of bytes\n-   of arguments scanned so far.  */\n+   such as FUNCTION_ARG to determine where the next arg should go. */\n+/* On convex, simply count the arguments in case TARGET_ARGCOUNT is set. */\n \n #define CUMULATIVE_ARGS int\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On Convex, the offset starts at 0.  */\n+   For a library call, FNTYPE is 0. */\n \n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n- ((CUM) = 0)\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) \\\n+  ((CUM) = 0)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+  ((CUM) += 1)\n \n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n@@ -475,11 +809,13 @@ enum reg_class {\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n    NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+    (otherwise it is an extra parameter matching an ellipsis).\n \n-/* On Convex, all args are pushed.  */   \n+    Convex: all args go on the stack.  But return the arg count\n+    as the \"next arg register\" to be passed to gen_call.  */\n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  ((MODE) == VOIDmode ? gen_rtx (CONST_INT, VOIDmode, (CUM)) : 0)\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n@@ -489,8 +825,23 @@ enum reg_class {\n    is ever used in the function.  This macro is responsible for\n    knowing which registers should not be saved even if used.  */\n \n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{  if ((SIZE) != 0) fprintf (FILE, \"\\tsub.w #%d,sp\\n\", ((SIZE) + 3) & -4);}\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int size = ((SIZE) + 7) & -8;\t\t\t\t\t\t\\\n+  if (size != 0)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tsub.w #%d,sp\\n\", size);\t\t\t\t\\\n+}\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Follow function with a zero to stop c34 icache prefetching. */\t\\\n+  fprintf (FILE, \"\\tds.h 0\\n\");\t\t\t\t\t\t\\\n+}\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n@@ -501,12 +852,8 @@ enum reg_class {\n \n #define TRAMPOLINE_TEMPLATE(FILE) \\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x11c8));\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x0140));\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tld.w #69696969,s0\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tjmp 52525252\\n\");\t\t\t\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */\n@@ -521,10 +868,10 @@ enum reg_class {\n {\t\t\t\t\t\t\t\t\t\\\n   emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 2)), CXT);\t\\\n   emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 8)), FNADDR); \\\n-  emit_call_insn (gen_call (gen_rtx (MEM, QImode,\t\t\t\\\n-\t\t\t\t     gen_rtx (SYMBOL_REF, Pmode,\t\\\n-\t\t\t\t\t      \"__enable_execute_stack\")), \\\n-\t\t\t    const0_rtx));\t\t\t\t\\\n+  emit_call_insn (gen_call_pop (gen_rtx (MEM, QImode,\t\t\t\\\n+\t\t\t\t\t gen_rtx (SYMBOL_REF, Pmode,\t\\\n+\t\t\t\t\t\t  \"__enable_execute_stack\")), \\\n+\t\t\t\tconst0_rtx, const0_rtx, const0_rtx));\t\\\n }\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n@@ -540,19 +887,12 @@ enum reg_class {\n \n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-/* #define FUNCTION_EPILOGUE(FILE, SIZE)  */\n-\n /* Store in the variable DEPTH the initial difference between the\n    frame pointer reg contents and the stack pointer reg contents,\n    as of the start of the function body.  This depends on the layout\n    of the fixed parts of the stack frame and on how registers are saved.  */\n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n-{ (DEPTH) = get_frame_size (); }\n+{ (DEPTH) = (get_frame_size () + 7) & -8; }\n \f\n /* Addressing modes, and classification of registers for them.  */\n \n@@ -571,8 +911,9 @@ enum reg_class {\n    has been allocated, which happens in local-alloc.c.  */\n \n #define REGNO_OK_FOR_INDEX_P(regno)  \\\n-  ((((regno) ^ 010) < 8 || ((reg_renumber[regno] ^ 010) & -8) == 0) \\\n-   && regno != 8)\n+  ((regno) <= LAST_VIRTUAL_REGISTER\t\t\t\t\t\\\n+    ? regno_ok_for_index_p[regno]\t\t\t\t\t\\\n+    : regno_ok_for_index_p[reg_renumber[regno]])\n \n #define REGNO_OK_FOR_BASE_P(regno)  REGNO_OK_FOR_INDEX_P (regno)\n \f\n@@ -590,11 +931,12 @@ enum reg_class {\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-/* For convex, any single-word constant is ok; the only contexts\n-   allowing general_operand of mode DI or DF are movdi and movdf. */\n+/* For convex, bounce 2-word constants that can't be immediate operands. */\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) != CONST_DOUBLE ? 1 : (LD_D_P (X) || LD_L_P (X)))\n+  (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\t\\\n+   || GET_MODE (X) == SFmode\t\t\t\t\t\t\\\n+   || LD_L_P (X) || LD_D_P (X))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -614,10 +956,8 @@ enum reg_class {\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) > 8 \\\n-   && REGNO (X) != VIRTUAL_STACK_VARS_REGNUM \\\n-   && REGNO (X) != VIRTUAL_STACK_DYNAMIC_REGNUM \\\n-   && REGNO (X) != VIRTUAL_OUTGOING_ARGS_REGNUM)\n+  (REGNO (X) > LAST_VIRTUAL_REGISTER || regno_ok_for_index_p[REGNO (X)])\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) REG_OK_FOR_INDEX_P (X)\n@@ -626,6 +966,7 @@ enum reg_class {\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n@@ -641,8 +982,8 @@ enum reg_class {\n    where indirectable is \n        const, reg, (PLUS reg const)\n \n-   On C3-series processors, we avoid indirection since it's substantially\n-   slower.  */\n+   We don't use indirection since with insn scheduling, load + indexing\n+   is better. */\n \n /* 1 if X is an address that we could indirect through.  */\n #define INDIRECTABLE_ADDRESS_P(X)  \\\n@@ -662,14 +1003,9 @@ enum reg_class {\n { register rtx xfoob = (X);\t\t\t\t\t\t\\\n   if (INDIRECTABLE_ADDRESS_P (xfoob))\t\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n-  xfoob = XEXP (X, 0);\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == MEM\t\t\t\t\t\t\\\n-      && TARGET_INDIRECTS\t\t\t\t\t\t\\\n-      && INDIRECTABLE_ADDRESS_P (xfoob))\t\t\t\t\\\n+  if (GET_CODE (xfoob) == PRE_DEC && XEXP (xfoob, 0) == stack_pointer_rtx) \\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PRE_DEC && REG_P (xfoob)\t\t\t\t\\\n-      && REGNO (xfoob) == STACK_POINTER_REGNUM)\t\t\t\t\\\n-    goto ADDR; }\n+}\n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n@@ -728,7 +1064,7 @@ enum reg_class {\n /* #define SLOW_ZERO_EXTEND */\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n+#define SLOW_BYTE_ACCESS (! TARGET_C2)\n \n /* Define if shifts truncate the shift count\n    which implies one can omit a sign-extension or zero-extension\n@@ -766,24 +1102,29 @@ enum reg_class {\n   case LABEL_REF: \\\n   case SYMBOL_REF: \\\n   case CONST_INT: \\\n-    return 0; \\\n   case CONST_DOUBLE: \\\n-    return 2;\n+    return 0;\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. \n-   On C1 and C2, multiply is faster than shift. */\n+   switch on CODE.  */\n \n #define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case PLUS:\t\t\t\t\t\t\t\t\\\n+    if (regno_pointer_flag != 0\t\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\t\\\n+\t&& REGNO_POINTER_FLAG (REGNO (XEXP (RTX, 0)))\t\t\t\\\n+\t&& GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    else break;\t\t\t\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n-    total = COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n+    return 4 * (char) (0x03060403 >> target_cpu * 8);\t\t\t\\\n   case LSHIFT:\t\t\t\t\t\t\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\t\t\\\n-    total = COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n-    break;\n+    return 4 * (char) (0x03010403 >> target_cpu * 8);\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\t\t\\\n+    return 5;\n \n /* Compute the cost of an address.  This is meant to approximate the size\n    and/or execution delay of an insn using that address.  If the cost is\n@@ -793,31 +1134,53 @@ enum reg_class {\n    this macro should be a constant.  The value of this macro only matters\n    for valid addresses.  */\n \n-#define ADDRESS_COST(RTX) (GET_CODE (RTX) == MEM ? 3 : 1)\n+#define ADDRESS_COST(RTX) 0\n \n /* Specify the cost of a branch insn; roughly the number of extra insns that\n    should be added to avoid a branch.  */\n \n #define BRANCH_COST 0\n \n-/* Check a `double' value for validity for a particular machine mode.  */\n+/* Adjust the cost of dependences. */\n+\n+#define ADJUST_COST(INSN,LINK,DEP,COST) \t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  /* Antidependencies don't block issue. */\t\t\t\t\\\n+  if (REG_NOTE_KIND (LINK) != 0)\t\t\t\t\t\\\n+    (COST) = 0;\t\t\t\t\t\t\t\t\\\n+  /* C38 situations where delay depends on context */\t\t\t\\\n+  else if (TARGET_C38\t\t\t\t\t\t\t\\\n+\t   && GET_CODE (PATTERN (INSN)) == SET\t\t\t\t\\\n+\t   && GET_CODE (PATTERN (DEP)) == SET)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      enum attr_type insn_type = get_attr_type (INSN);\t\t\t\\\n+      enum attr_type dep_type = get_attr_type (DEP);\t\t\t\\\n+      /* index register must be ready one cycle early */\t\t\\\n+      if (insn_type == TYPE_MLDW || insn_type == TYPE_MLDL\t\t\\\n+          || (insn_type == TYPE_MST\t\t\t\t\t\\\n+\t      && reg_mentioned_p (SET_DEST (PATTERN (DEP)),\t\t\\\n+\t\t\t\t  SET_SRC (PATTERN (INSN)))))\t\t\\\n+\t(COST) += 1;\t\t\t\t\t\t\t\\\n+      /* alu forwarding off alu takes two */\t\t\t\t\\\n+      if (dep_type == TYPE_ALU\t\t\t\t\t\t\\\n+\t  && insn_type != TYPE_ALU\t\t\t\t\t\\\n+\t  && ! (insn_type == TYPE_MST\t\t\t\t\t\\\n+\t\t&& SET_DEST (PATTERN (DEP)) == SET_SRC (PATTERN (INSN)))) \\\n+\t(COST) += 1;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n \n+/* Convex uses Vax or IEEE floats.\n+   Follow the host format. */\n+#define TARGET_FLOAT_FORMAT HOST_FLOAT_FORMAT\n+\n+/* But must prevent real.c from constructing Vax dfloats */\n+#define REAL_VALUE_ATOF(X,S) atof (X)\n+extern double atof();\n+\n+/* Check a `double' value for validity for a particular machine mode.  */\n #define CHECK_FLOAT_VALUE(mode, d) \\\n-  if ((mode) == SFmode) \\\n-    { \\\n-      if ((d) > 1.7014117331926443e+38) \\\n-\t{ error (\"magnitude of constant too large for `float'\"); \\\n-\t  (d) = 1.7014117331926443e+38; } \\\n-      else if ((d) < -1.7014117331926443e+38) \\\n-\t{ error (\"magnitude of constant too large for `float'\"); \\\n-\t  (d) = -1.7014117331926443e+38; } \\\n-      else if (((d) > 0) && ((d) < 2.9387358770557188e-39)) \\\n-\t{ warning (\"`float' constant truncated to zero\"); \\\n-\t  (d) = 0.0; } \\\n-      else if (((d) < 0) && ((d) > -2.9387358770557188e-39)) \\\n-\t{ warning (\"`float' constant truncated to zero\"); \\\n-\t  (d) = 0.0; } \\\n-    }\n+    check_float_value ((mode), &(d))\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n@@ -835,7 +1198,11 @@ enum reg_class {\n \n /* Output at beginning of assembler file.  */\n \n-#define ASM_FILE_START(FILE) fprintf (FILE, \";NO_APP\\n\")\n+#if _IEEE_FLOAT_\n+#define ASM_FILE_START(FILE)  fprintf (FILE, \";NO_APP\\n.fpmode ieee\\n\")\n+#else\n+#define ASM_FILE_START(FILE)  fprintf (FILE, \";NO_APP\\n.fpmode native\\n\")\n+#endif\n \n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n@@ -847,12 +1214,6 @@ enum reg_class {\n \n #define ASM_APP_OFF \";NO_APP\\n\"\n \n-/* Output something following the gcc2_compiled tag to keep that label from\n-   hiding a real function name for tools like adb and prof. */\n-\n-#define ASM_IDENTIFY_GCC(FILE) \\\n-  fprintf (FILE, \"gcc2_compiled.:\\n\\tds.h 0\\n\");\n-\n /* Alignment with Convex's assembler goes like this:\n    .text can be .aligned up to a halfword.\n    .data and .bss can be .aligned up to a longword.\n@@ -904,9 +1265,11 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-#define REGISTER_NAMES \\\n-{\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \\\n- \"sp\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"ap\", \"fp\"}\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \t\t\t\\\n+  \"sp\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"ap\", \"fp\",\t\t\t\\\n+}\n \n /* This is BSD, so it wants DBX format.  */\n \n@@ -972,20 +1335,22 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n \n /* This is how to output an assembler line defining a `double' constant.  */\n \n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tds.d %.17e\\n\", (VALUE))\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE) \\\n+  outfloat (FILE, VALUE, \"%.17e\", \"\\tds.d \", \"\\n\")\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\tds.s %.9e\\n\", (VALUE))\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE) \\\n+  outfloat (FILE, VALUE, \"%.9e\", \"\\tds.s \", \"\\n\")\n \n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\tds.w \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tds.w \");\t\t\t\t\t\t\\\n+  output_addr_const (FILE, simplify_for_convex (VALUE));\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+}\n \n /* Likewise for a `long long int' constant.  */\n \n@@ -1090,6 +1455,11 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n+/* Output an arg count before function entries. */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n+  asm_declare_function_name (FILE, NAME, DECL)\n+\n /* Define the parentheses used to group arithmetic operations\n    in assembler code.  */\n \n@@ -1110,60 +1480,12 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n    if `%z3' was used to print operand 3, then CODE is 'z'. */\n \n #define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n-\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      fprintf (FILE, \"#%.9e\", u.d); }\t\t\t \t\t\\\n-  else { putc ('#', FILE); output_addr_const (FILE, X); }}\n+    print_operand (FILE, X, CODE)\n \n /* Print a memory operand whose address is X, on file FILE. */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n-{ \t\t\t\t\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  register rtx index = 0;\t\t\t\t\t\t\\\n-  register rtx offset = 0;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (addr) == MEM)\t\t\t\t\t\t\\\n-    {  \t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"@\");\t\t\t\t\t\t\\\n-      addr = XEXP (addr, 0);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      index = addr;\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      index = XEXP (addr, 0);\t\t\t\t\t\t\\\n-      if (REG_P (index))\t\t\t\t\t\t\\\n-\toffset = XEXP (addr, 1);\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  index = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  if (! REG_P (index)) abort ();\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      offset = addr;\t\t\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (offset)\t\t\t\t\t\t\t\t\\\n-    output_addr_const (FILE, offset);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (index) \t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"(%s)\", reg_names[REGNO (index)]);\t\t\t\\\n-}\n+    print_operand_address (FILE, ADDR)\n \f\n /* Definitions for g++.  */\n \n@@ -1180,17 +1502,38 @@ bss_section ()\t\t\t\t\t\t\t\t\\\n #define SET_DECL_VINDEX(DECL, INDEX) \\\n   (DECL_VINDEX (DECL) = (INDEX))\n \n-#if 0 /* collect2.c should no longer need these.  */\n-/* Defs for compiling collect2.c in -pcc mode during bootstrap. */\n+/* __gcc_cleanup is loader-aliased to __ap$do_registered_functions if we\n+   are linking against standard libc, 0 if old (-traditional) libc. */\n \n-#ifdef COLLECT\n-\n-#ifndef __STDC__\n+#define EXIT_BODY \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void __gcc_cleanup ();\t\t\t\t\t\t\\\n+  if (__gcc_cleanup != _cleanup)\t\t\t\t\t\\\n+    __gcc_cleanup ();\t\t\t\t\t\t\t\\\n+  _cleanup ();\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* cexp.y uses LONG_TYPE_SIZE which depends on target_flags, which it\n+   doesn't have.  Until some better way exists, provide a def here. */\n+#ifdef YYBISON\n+int target_flags;\n+#endif\n \n-#define WTERMSIG(x) (((union wait *) &(x))->w_termsig)\n-#define WEXITSTATUS(x) (((union wait *) &(x))->w_retcode)\n+/* Header for convex.c.\n+   Here at the end so we can use types defined above. */\n \n-#endif\n+extern int target_cpu;\n+extern int current_section_is_text;\n+extern enum reg_class regno_reg_class[];\n+extern enum reg_class reg_class_from_letter[];\n+extern char regno_ok_for_index_p_base[];\n+#define regno_ok_for_index_p (regno_ok_for_index_p_base + 1)\n \n-#endif /* COLLECT */\n-#endif /* 0 */\n+extern int const_double_low_int ();\n+extern int const_double_high_int ();\n+extern char *output_cmp ();\n+extern char *output_condjump ();\n+extern char *output_call ();\n+extern void gen_ap_for_call ();\n+extern void check_float_value ();\n+extern void asm_declare_function_name ();"}, {"sha": "4cc642d9e6fab642ad7e2a286b2421c0ef26dcb2", "filename": "gcc/config/convex/convex.md", "status": "modified", "additions": 1135, "deletions": 527, "changes": 1662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fconvex.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fconvex.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.md?ref=6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for GNU compiler\n ;;- Convex Version\n-;;   Copyright (C) 1991 Free Software Foundation, Inc.\n+;;   Copyright (C) 1988, 1993 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -17,350 +17,356 @@\n ;; You should have received a copy of the GNU General Public License\n ;; along with GNU CC; see the file COPYING.  If not, write to\n ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\f\n+;; Attribute specifications\n+\n+; Target CPU\n+(define_attr \"cpu\" \"c1,c32,c34,c38\"\n+  (const (symbol_ref \"(enum attr_cpu) target_cpu\")))\n+\n+;; Instruction classification\n+\n+(define_attr \"type\"\n+  \"alu,xalu,mldw,mldl,mldb,mst,adds,addd,mulw,mull,muls,muld,divw,divl,divs,divd,shfw,shfl,cvts,cvtd\"\n+  (const_string \"alu\"))\n+\n+;; Instruction times\n+\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mldw\")) 2 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mldl\")) 4 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mldw,mldl\")) 2 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mldw,mldl\")) 4 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mldw,mldl\")) 2 0)\n+\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mldb\")) 9 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mldb\")) 36 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mldb\")) 21 0)\n+\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"xalu\")) 1 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"xalu\")) 1 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"xalu\")) 5 0)\n+(define_function_unit \"mem\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"xalu\")) 2 0)\n+\n+(define_function_unit \"add\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"adds,addd\")) 3 2)\n+(define_function_unit \"add\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"adds,addd\")) 2 1)\n+(define_function_unit \"add\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"adds,addd\")) 5 2)\n+(define_function_unit \"add\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"adds,addd\")) 2 1)\n+\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mulw,muls\")) 3 2)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mulw,muls\")) 4 2)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mulw,muls\")) 6 2)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mulw,muls\")) 3 2)\n+\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"mull,muld\")) 4 3)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"mull\")) 10 7)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"muld\")) 5 2)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"mull,muld\")) 7 3)\n+(define_function_unit \"mul\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"mull,muld\")) 4 3)\n+\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divw\")) 24 24)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divw\")) 44 6)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divw\")) 14 10)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divw\")) 11 10)\n+\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divl\")) 41 42)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divl\")) 76 5)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divl\")) 22 18)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divl\")) 19 18)\n+\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divs\")) 22 22)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divs\")) 8 6)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divs\")) 13 9)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divs\")) 10 9)\n+\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"divd\")) 37 38)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"divd\")) 12 8)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"divd\")) 20 16)\n+(define_function_unit \"div\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"divd\")) 17 16)\n+\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"cvts,cvtd\")) 4 3)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"cvts\")) 9 7)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"cvtd\")) 9 6)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"cvts\")) 6 2)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c34\") (eq_attr \"type\" \"cvtd\")) 6 1)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"cvts,cvtd\")) 3 1)\n+\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c1\") (eq_attr \"type\" \"shfw,shfl\")) 3 2)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"shfw\")) 7 5)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c32\") (eq_attr \"type\" \"shfl\")) 7 4)\n+(define_function_unit \"misc\" 1 0\n+  (and (eq_attr \"cpu\" \"c38\") (eq_attr \"type\" \"shfw,shfl\")) 3 1)\n+\n+(define_function_unit \"mystery_latch\" 1 1\n+  (and (eq_attr \"type\" \"!alu,mldw,mldl,adds,addd\") (eq_attr \"cpu\" \"c32\")) 2 2)\n+\n+;(define_function_unit \"ip\" 1 1\n+;  (and (eq_attr \"cpu\" \"c1\")\n+;       (eq_attr \"type\" \"divw,divl,divs,divd,xalu\")) 2 2)\n+;(define_function_unit \"ip\" 1 1\n+;  (and (eq_attr \"cpu\" \"c1\")\n+;       (eq_attr \"type\" \"!divw,divl,divs,divd,xalu\")) 1 1)\n+;(define_function_unit \"ip\" 1 1\n+;  (and (eq_attr \"cpu\" \"c32\")\n+;       (eq_attr \"type\" \"mull,muld,divl,divd,shfl,cvtd,xalu\")) 2 2)\n+;(define_function_unit \"ip\" 1 1\n+;  (and (eq_attr \"cpu\" \"c32\")\n+;       (eq_attr \"type\" \"!mull,muld,divl,divd,shfl,cvtd,xalu\")) 1 1)\n+;(define_function_unit \"ip\" 1 1\n+;  (and (eq_attr \"cpu\" \"c34\")\n+;       (eq_attr \"type\" \"addd,mull,muld,divl,divd,cvtd,xalu\")) 2 2)\n+;(define_function_unit \"ip\" 1 1\n+;  (and (eq_attr \"cpu\" \"c34\")\n+;       (eq_attr \"type\" \"!addd,mull,muld,divl,divd,cvtd,xalu\")) 1 1)\n+\f\n+;; Make the first thing a real insn in case of genattrtab bug\n \n-;; Scheduling defs\n-;;\n-;; Insn scheduling is not used at present.  Scheduling increases\n-;; register pressure so much that many spills are generated\n-;; even for very small functions.\n-\n-;; Compares\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"* return set_cmp (operands[0], const0_rtx, 'w');\")\n-\n-(define_insn \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"* return set_cmp (operands[0], const0_rtx, 'h');\")\n-\n-(define_expand \"tstqi\"\n-  [(set (match_dup 1)\n-\t(sign_extend:SI (match_operand:QI 0 \"register_operand\" \"r\")))\n-   (set (cc0)\n-\t(match_dup 1))]\n+(define_insn \"nop\"\n+  [(const_int 0)]\n   \"\"\n-  \"operands[1] = gen_reg_rtx (SImode);\")\n+  \"nop\")\n+\f\n+;; Moves\n \n-(define_expand \"tstdi\"\n-  [(parallel [(set (cc0) (match_operand:DI 0 \"register_operand\" \"d\"))\n-\t      (use (match_dup 1))])]\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"operands[1] = force_reg (DImode, const0_rtx);\")\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (DFmode, operands[1]);\")\n \n (define_insn \"\"\n-  [(set (cc0) (match_operand:DI 0 \"register_operand\" \"d\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 'l');\")\n-\n-(define_expand \"tstdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"register_operand\" \"d\")\n-\t\t (match_dup 1)))]\n-  \"\"\n-  \"operands[1] = force_reg (DFmode, CONST0_RTX (DFmode));\")\n-\n-(define_insn \"tstsf\"\n-  [(set (cc0)\n-\t(match_operand:SF 0 \"register_operand\" \"d\"))]\n-  \"\"\n-  \"* return set_cmp (operands[0], CONST0_RTX (SFmode), 's');\")\n-\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"d,a,i,r\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"d,a,r,i\")))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 'w');\")\n-\n-(define_insn \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\" \"d,a,r,i\")\n-\t\t (match_operand:HI 1 \"nonmemory_operand\" \"d,a,i,r\")))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 'h');\")\n-\n-(define_insn \"cmpqi\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"register_operand\" \"d\")\n-\t\t (match_operand:QI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 'b');\")\n-\n-(define_insn \"cmpdi\"\n-  [(set (cc0)\n-\t(compare (match_operand:DI 0 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 'l');\")\n-\n-(define_insn \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"register_operand\" \"d\")\n-\t\t (match_operand:DF 1 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 'd');\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=d,d,d,d,d,<,m\")\n+\t(match_operand:DF 1 \"general_operand\"  \"d,Q,m,G,H,d,d\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"@\n+   mov %1,%0\n+   ldb.d %1,%0\n+   ld.d %1,%0\n+   ld.d %u1,%0\n+   ld.l %v1,%0\n+   psh.l %1\n+   st.d %1,%0\"\n+  [(set_attr \"type\" \"alu,mldb,mldl,alu,alu,alu,mst\")])\n+\n+;; This is here so we can load any result of RTL constant folding\n+;; but do not use it on constants that can be loaded from memory.\n+;; It is never better and can be worse.\n \n-(define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"nonmemory_operand\" \"dF,d\")\n-\t\t (match_operand:SF 1 \"nonmemory_operand\" \"d,F\")))]\n-  \"\"\n-  \"* return set_cmp (operands[0], operands[1], 's');\")\n-\f\n-;; Moves\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(match_operand:DF 1 \"const_double_operand\" \"F\"))]\n+  \"CONST_DOUBLE_MEM (operands[1]) == const0_rtx\"\n+  \"ld.u %u1,%0\\;ld.w %v1,%0\"\n+  [(set_attr \"type\" \"xalu\")])\n \n-;(define_insn \"movtf\"\n-;  [(set (match_operand:TF 0 \"general_operand\" \"=g,d\")\n-;\t(match_operand:TF 1 \"general_operand\" \"d,g\"))]\n-;  \"\"\n-;  \"*\n-;{\n-;  rtx opaddr = 0;\n-;  rtx xoperands[4];\n-;  xoperands[0] = operands[0];\n-;  xoperands[2] = operands[1];\n-;\n-;  if (REG_P (operands[0]))\n-;    xoperands[1] = gen_rtx (REG, TFmode, REGNO (operands[0]) + 1);\n-;  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-;    xoperands[1] = 0;\n-;  else if (offsettable_memref_p (operands[0]))\n-;    xoperands[1] = adj_offsettable_operand (operands[0], 8);\n-;  else\n-;    {\n-;      opaddr = XEXP (operands[0], 0);\n-;      xoperands[0] = gen_rtx (MEM, TFmode, gen_rtx (REG, SImode, 13));\n-;      xoperands[1] = adj_offsettable_operand (xoperands[0], 8);\n-;    }\n-;\n-;  if (REG_P (operands[1]))\n-;    xoperands[3] = gen_rtx (REG, TFmode, REGNO (operands[1]) + 1);\n-;  else if (offsettable_memref_p (operands[1]))\n-;    xoperands[3] = adj_offsettable_operand (operands[1], 8);\n-;  else\n-;    {\n-;      opaddr = XEXP (operands[1], 0);\n-;      xoperands[2] = gen_rtx (MEM, TFmode, gen_rtx (REG, SImode, 13));\n-;      xoperands[3] = adj_offsettable_operand (xoperands[2], 8);\n-;    }\n-;\n-;  if (opaddr)\n-;    output_asm_insn (\\\"psh.w a5\\;ld.w %0,a5\\\", &opaddr);\n-;  if (push_operand (operands[0], TFmode))\n-;    output_asm_insn (\\\"psh.l %3\\;psh.l %2\\\", xoperands);\n-;  else if (GET_CODE (operands[0]) == MEM)\n-;    output_asm_insn (\\\"st.l %2,%0\\;st.l %3,%1\\\", xoperands);\n-;  else if (GET_CODE (operands[1]) == REG)\n-;    output_asm_insn (\\\"mov %2,%0\\;mov %3,%1\\\", xoperands);\n-;  else\n-;    output_asm_insn (\\\"ld.l %2,%0\\;ld.l %3,%1\\\", xoperands);\n-;  if (opaddr)\n-;    output_asm_insn (\\\"pop.w a5\\\");\n-;  return \\\"\\\";\n-;}\")\n-\n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=g,d\")\n-\t(match_operand:DF 1 \"general_operand\" \"d,dmG\"))]\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], DFmode))\n-    return \\\"psh.l %1\\\";\n-  else if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.l %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == REG)\n-    return \\\"mov %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == CONST_DOUBLE && LD_D_P (operands[1]))\n-    {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     const_double_high_int (operands[1]));\n-      return \\\"ld.d %1,%0\\\";\n-    }\n-  else if (GET_CODE (operands[1]) == CONST_DOUBLE && LD_L_P (operands[1]))\n-    {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     const_double_low_int (operands[1]));\n-      return \\\"ld.l %1,%0\\\";\n-    }\n-  else\n-    return \\\"ld.l %1,%0\\\";\n-}\")\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (SFmode, operands[1]);\")\n \n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=g,d\")\n-\t(match_operand:SF 1 \"general_operand\" \"d,gF\"))]\n-  \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SFmode))\n-    return \\\"psh.w %1\\\";\n-  else if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.s %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == REG)\n-    return \\\"mov.s %1,%0\\\";\n-  else\n-    return \\\"ld.s %1,%0\\\";\n-}\")\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=d,d,d,d,<,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"d,Q,m,F,d,d\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n+  \"@\n+   mov.s %1,%0\n+   ldb.s %1,%0\n+   ld.s %1,%0\n+   ld.s %1,%0\n+   psh.w %1\n+   st.s %1,%0\"\n+  [(set_attr \"type\" \"alu,mldb,mldw,alu,alu,mst\")])\n \n-(define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=g,d\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,dmiG\"))]\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], DImode))\n-    return \\\"psh.l %1\\\";\n-  else if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.l %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == REG)\n-    return \\\"mov %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == CONST_DOUBLE && LD_D_P (operands[1]))\n-    {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     const_double_high_int (operands[1]));\n-      return \\\"ld.d %1,%0\\\";\n-    }\n-  else\n-    return \\\"ld.l %1,%0\\\";\n-}\")\n-\n-;; Special case of movsi, needed to express A-reg preference.\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (DImode, operands[1]);\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"a\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"operands[1] != stack_pointer_rtx\"\n-  \"pshea %a2(%1)\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,d,<,m\")\n+\t(match_operand:DI 1 \"general_operand\" \"d,Q,m,G,HI,d,d\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\"\n+  \"@\n+   mov %1,%0\n+   ldb.l %1,%0\n+   ld.l %1,%0\n+   ld.d %u1,%0\n+   ld.l %1,%0\n+   psh.l %1\n+   st.l %1,%0\"\n+  [(set_attr \"type\" \"alu,mldb,mldl,alu,alu,alu,mst\")])\n+\n+;; This is here so we can load any result of RTL constant folding\n+;; but do not use it on constants that can be loaded from memory.\n+;; It is never better and can be worse.\n \n-;; General movsi.  Constraints will be selected based on TARGET_INDIRECTS\n-;; to avoid indirect addressing on C3, where it is slow.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(match_operand:DI 1 \"const_double_operand\" \"F\"))]\n+  \"CONST_DOUBLE_MEM (operands[1]) == const0_rtx\"\n+  \"ld.u %u1,%0\\;ld.w %v1,%0\"\n+  [(set_attr \"type\" \"xalu\")])\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\")\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (SImode, operands[1]);\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SI 1 \"general_operand\" \"Ad,io\"))]\n+\t(match_operand:SI 1 \"nonmemory_operand\" \"Ad,i\"))]\n   \"\"\n   \"@\n    psh.w %1\n    pshea %a1\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g,r,<\")\n-\t(match_operand:SI 1 \"general_operand\" \"r,g,io\"))]\n-  \"TARGET_INDIRECTS\"\n-  \"*\n-{ \n-  if (push_operand (operands[0], SImode))\n-    {\n-      if (GET_CODE (operands[1]) == REG)\n-\treturn \\\"psh.w %1\\\";\n-      else\n-        return \\\"pshea %a1\\\";\n-    }\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.w %1,%0\\\";\n-  if (GET_CODE (operands[1]) != REG)\n-    return \\\"ld.w %1,%0\\\";\n-  if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n-    return \\\"mov.w %1,%0\\\";\n-  return \\\"mov %1,%0\\\";\n-}\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,r,d,r,r,m\")\n+\t(match_operand:SI 1 \"general_operand\" \"d,r,Q,m,i,r\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+   mov.w %1,%0\n+   mov %1,%0\n+   ldb.w %1,%0\n+   ld.w %1,%0\n+   ld.w %1,%0\n+   st.w %1,%0\"\n+  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,mst\")])\n+\n+(define_expand \"movstrictsi\"\n+  [(set (strict_low_part (match_operand:SI 0 \"general_operand\" \"\"))\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (SImode, operands[1]);\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g,r,<\")\n-\t(match_operand:SI 1 \"general_operand\" \"r,g,i\"))]\n-  \"! TARGET_INDIRECTS\"\n-  \"*\n-{ \n-  if (push_operand (operands[0], SImode))\n-    {\n-      if (GET_CODE (operands[1]) == REG)\n-\treturn \\\"psh.w %1\\\";\n-      else\n-        return \\\"pshea %a1\\\";\n-    }\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.w %1,%0\\\";\n-  if (GET_CODE (operands[1]) != REG)\n-    return \\\"ld.w %1,%0\\\";\n-  if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n-    return \\\"mov.w %1,%0\\\";\n-  return \\\"mov %1,%0\\\";\n-}\")\n+  [(set (strict_low_part (match_operand:SI 0 \"general_operand\" \"=d,r,d,r,r,m\"))\n+\t(match_operand:SI 1 \"general_operand\" \"d,r,Q,m,i,r\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+   mov.w %1,%0\n+   mov %1,%0\n+   ldb.w %1,%0\n+   ld.w %1,%0\n+   ld.w %1,%0\n+   st.w %1,%0\"\n+  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,mst\")])\n \n-(define_insn \"movstrictsi\"\n-  [(set (strict_low_part (match_operand:SI 0 \"general_operand\" \"+g,r\"))\n-\t(match_operand:SI 1 \"general_operand\" \"r,g\"))]\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"*\n-{ \n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.w %1,%0\\\";\n-  if (GET_CODE (operands[1]) != REG)\n-    return \\\"ld.w %1,%0\\\";\n-  if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n-    return \\\"mov.w %1,%0\\\";\n-  return \\\"mov %1,%0\\\";\n-}\")\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (HImode, operands[1]);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,r,d,r,r,<,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"d,r,Q,m,i,Ad,r\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"@\n+   mov.w %1,%0\n+   mov %1,%0\n+   ldb.h %1,%0\n+   ld.h %1,%0\n+   ld.w %1,%0\n+   psh.w %1\n+   st.h %1,%0\"\n+  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,alu,mst\")])\n \n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=g,r\")\n-\t(match_operand:HI 1 \"general_operand\" \"r,g\"))]\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], HImode))\n-    abort ();\n-  else if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.h %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == REG) \n-    {\n-      if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n-\treturn \\\"mov.w %1,%0\\\";\n-      else\n-        return \\\"mov %1,%0\\\";\n-    }\n-  else if (GET_CODE (operands[1]) == CONST_INT)\n-    return \\\"ld.w %1,%0\\\";\n-  else\n-    return \\\"ld.h %1,%0\\\";\n-}\")\n+  \"if (GET_CODE (operands[0]) != REG)\n+     operands[1] = force_reg (QImode, operands[1]);\")\n \n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=g,r\")\n-\t(match_operand:QI 1 \"general_operand\" \"r,g\"))]\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,r,d,r,r,<,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"d,r,Q,m,i,Ad,r\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+   mov.w %1,%0\n+   mov %1,%0\n+   ldb.b %1,%0\n+   ld.b %1,%0\n+   ld.w %1,%0\n+   psh.w %1\n+   st.b %1,%0\"\n+  [(set_attr \"type\" \"alu,alu,mldb,mldw,alu,alu,mst\")])\n+\n+;; Expand block moves manually to get code that pipelines the loads.\n+\n+(define_expand \"movstrsi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"m\"))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"i\"))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"i\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], QImode))\n-    abort ();\n-  else if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.b %1,%0\\\";\n-  else if (GET_CODE (operands[1]) == REG)\n-    {\n-      if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n-\treturn \\\"mov.w %1,%0\\\";\n-      else\n-        return \\\"mov %1,%0\\\";\n-    }\n-  else if (GET_CODE (operands[1]) == CONST_INT)\n-    return \\\"ld.w %1,%0\\\";\n-  else\n-    return \\\"ld.b %1,%0\\\";\n-}\")\n+  \" expand_movstr (operands); DONE; \")\n \f\n ;; Extension and truncation insns.\n ;; Those for integer source operand\n@@ -418,13 +424,15 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"cvts.d %1,%0\")\n+  \"cvts.d %1,%0\"\n+  [(set_attr \"type\" \"cvts\")])\n \n (define_insn \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"cvtd.s %1,%0\")\n+  \"cvtd.s %1,%0\"\n+  [(set_attr \"type\" \"cvtd\")])\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -461,56 +469,125 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"cvtw.s %1,%0\")\n+  \"cvtw.s %1,%0\"\n+  [(set_attr \"type\" \"cvts\")])\n \n (define_insn \"floatdisf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(float:SF (match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"cvtl.s %1,%0\")\n+  \"cvtl.s %1,%0\"\n+  [(set_attr \"type\" \"cvtd\")])\n \n (define_insn \"floatsidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_C2\"\n-  \"cvtw.d %1,%0\")\n+  \"! TARGET_C1\"\n+  \"cvtw.d %1,%0\"\n+  [(set_attr \"type\" \"cvts\")])\n \n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(float:DF (match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"cvtl.d %1,%0\")\n+  \"cvtl.d %1,%0\"\n+  [(set_attr \"type\" \"cvtd\")])\n+\n+;; These are a little slower than gcc's normal way of doing unsigned\n+;; DI floats (if the DI number is \"negative\") but they avoid double\n+;; rounding and they avoid explicit constants.\n+\n+(define_expand \"floatunsdidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(float:DF (match_operand:DI 1 \"register_operand\" \"d\")))\n+   (set (cc0) (compare:DI (match_dup 3) (match_dup 1)))\n+   (set (pc)\n+\t(if_then_else (le (cc0) (const_int 0))\n+\t\t      (label_ref (match_dup 4))\n+\t\t      (pc)))\n+   (set (match_dup 2) (lshiftrt:DI (match_dup 1) (const_int 1)))\n+   (set (match_dup 0) (float:DF (match_dup 2)))\n+   (set (match_dup 0) (plus:DF (match_dup 0) (match_dup 0)))\n+   (match_dup 4)\n+   (set (match_dup 0) (match_dup 0))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = force_reg (DImode, const0_rtx);\n+  operands[4] = gen_label_rtx ();\n+}\")\n+\n+(define_expand \"floatunsdisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(float:SF (match_operand:DI 1 \"register_operand\" \"d\")))\n+   (set (cc0) (compare:DI (match_dup 3) (match_dup 1)))\n+   (set (pc)\n+\t(if_then_else (le (cc0) (const_int 0))\n+\t\t      (label_ref (match_dup 4))\n+\t\t      (pc)))\n+   (set (match_dup 2) (lshiftrt:DI (match_dup 1) (const_int 1)))\n+   (set (match_dup 0) (float:SF (match_dup 2)))\n+   (set (match_dup 0) (plus:SF (match_dup 0) (match_dup 0)))\n+   (match_dup 4)\n+   (set (match_dup 0) (match_dup 0))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = force_reg (DImode, const0_rtx);\n+  operands[4] = gen_label_rtx ();\n+}\")\n+\n+;; These patterns are identical to gcc's default action \n+;; if DI->DF and DI->SF are not present.  There are here\n+;; only to prevent SI->*F from promoting to DI->*F.\n+\n+(define_expand \"floatunssidf2\"\n+  [(set (match_dup 2)\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(float:DF (match_dup 2)))]\n+  \"\"\n+  \"operands[2] = gen_reg_rtx (DImode);\")\n+\n+(define_expand \"floatunssisf2\"\n+  [(set (match_dup 2)\n+        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (match_operand:SF 0 \"register_operand\" \"\")\n+        (float:SF (match_dup 2)))]\n+  \"\"\n+  \"operands[2] = gen_reg_rtx (DImode);\")\n \f\n ;; Float-to-fix conversion insns.\n \n (define_insn \"fix_truncsfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"d\"))))]\n   \"\"\n-  \"cvts.w %1,%0\")\n+  \"cvts.w %1,%0\"\n+  [(set_attr \"type\" \"cvts\")])\n \n (define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"d\"))))]\n   \"\"\n-  \"cvts.l %1,%0\")\n+  \"cvts.l %1,%0\"\n+  [(set_attr \"type\" \"cvts\")])\n \n (define_insn \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"d\"))))]\n   \"\"\n-  \"*\n-{\n-  if (TARGET_C2)\n-    return \\\"cvtd.w %1,%0\\\";\n-  return \\\"cvtd.l %1,%0\\\";\n-}\")\n+  \"cvtd.l %1,%0\"\n+  [(set_attr \"type\" \"cvtd\")])\n \n (define_insn \"fix_truncdfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"d\"))))]\n   \"\"\n-  \"cvtd.l %1,%0\")\n+  \"cvtd.l %1,%0\"\n+  [(set_attr \"type\" \"cvtd\")])\n \f\n ;;- All kinds of add instructions.\n \n@@ -519,14 +596,16 @@\n \t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n \t\t (match_operand:DF 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"add.d %2,%0\")\n+  \"add.d %2,%0\"\n+  [(set_attr \"type\" \"addd\")])\n \n (define_insn \"addsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n \t\t (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n   \"\"\n-  \"add.s %2,%0\")\n+  \"add.s %2,%0\"\n+  [(set_attr \"type\" \"adds\")])\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -535,33 +614,54 @@\n   \"\"\n   \"add.l %2,%0\")\n \n-;; special case of addsi3, needed to specify an A reg for the destination \n-;; when the source is a sum involving FP or AP.\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%A\")\n \t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"operands[1] == frame_pointer_rtx || operands[1] == arg_pointer_rtx\"\n   \"ldea %a2(%1),%0\")\n \n-(define_insn \"addsi3\"\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%a\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"operands[1] == stack_pointer_rtx && operands[0] != stack_pointer_rtx\"\n+  \"mov %1,%0\\;add.w %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"A\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"operands[1] != stack_pointer_rtx\"\n+  \"pshea %a2(%1)\"\n+  [(set_attr \"type\" \"mst\")])\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a\")\n-\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%0,0,a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,A\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ri,i\")))]\n+  \"TARGET_C1\"\n+  \"@\n+   add.w %2,%0\n+   add.w %2,%0\n+   ldea %a2(%1),%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,A\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ri,i\")))]\n   \"\"\n-  \"* switch (which_alternative) \n-{\n- case 0:\n- case 1: \n-   return \\\"add.w %2,%0\\\";\n- case 2:\n-   if ((TARGET_C2 || A_REG_P (operands[0]))\n-       && operands[1] != stack_pointer_rtx)\n-     return \\\"ldea %a2(%1),%0\\\";\n-   else\n-     return \\\"mov %1,%0\\;add.w %2,%0\\\";\n-}\")\n+  \"@\n+   add.w %2,%0\n+   add.w %2,%0\n+   ldea %a2(%1),%0\")\n \n (define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n@@ -571,11 +671,13 @@\n   \"add.h %2,%0\")\n \n (define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n-\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"register_operand\" \"d\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,d\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"d,i\")))]\n   \"\"\n-  \"add.b %2,%0\")\n+  \"@\n+   add.b %2,%0\n+   add.w %2,%0\")\n \f\n ;;- All kinds of subtract instructions.\n \n@@ -584,14 +686,16 @@\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"0\")\n \t\t  (match_operand:DF 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"sub.d %2,%0\")\n+  \"sub.d %2,%0\"\n+  [(set_attr \"type\" \"addd\")])\n \n (define_insn \"subsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(minus:SF (match_operand:SF 1 \"register_operand\" \"0\")\n \t\t  (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n   \"\"\n-  \"sub.s %2,%0\")\n+  \"sub.s %2,%0\"\n+  [(set_attr \"type\" \"adds\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -601,11 +705,15 @@\n   \"sub.l %2,%0\")\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,?d,?a\")\n+\t(minus:SI (match_operand:SI 1 \"nonmemory_operand\" \"0,0,di,ai\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"di,ai,0,0\")))]\n   \"\"\n-  \"sub.w %2,%0\")\n+  \"@\n+  sub.w %2,%0\n+  sub.w %2,%0\n+  sub.w %1,%0\\;neg.w %0,%0\n+  sub.w %1,%0\\;neg.w %0,%0\")\n \n (define_insn \"subhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n@@ -615,11 +723,13 @@\n   \"sub.h %2,%0\")\n \n (define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n-\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:QI 2 \"register_operand\" \"d\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,d\")\n+\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"d,i\")))]\n   \"\"\n-  \"sub.b %2,%0\")\n+  \"@\n+   sub.b %2,%0\n+   sub.w %2,%0\")\n \f\n ;;- Multiply instructions.\n \n@@ -628,42 +738,50 @@\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n \t\t (match_operand:DF 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"mul.d %2,%0\")\n+  \"mul.d %2,%0\"\n+  [(set_attr \"type\" \"muld\")])\n \n (define_insn \"mulsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n \t\t (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n   \"\"\n-  \"mul.s %2,%0\")\n+  \"mul.s %2,%0\"\n+  [(set_attr \"type\" \"muls\")])\n \n (define_insn \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"mul.l %2,%0\")\n+  \"mul.l %2,%0\"\n+  [(set_attr \"type\" \"mull\")])\n \n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n   \"\"\n-  \"mul.w %2,%0\")\n+  \"mul.w %2,%0\"\n+  [(set_attr \"type\" \"mulw\")])\n \n (define_insn \"mulhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n \t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n \t\t (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n   \"\"\n-  \"mul.h %2,%0\")\n+  \"mul.h %2,%0\"\n+  [(set_attr \"type\" \"mulw\")])\n \n (define_insn \"mulqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n-\t(mult:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"register_operand\" \"d\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,d\")\n+\t(mult:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"d,i\")))]\n   \"\"\n-  \"mul.b %2,%0\")\n+  \"@\n+   mul.b %2,%0\n+   mul.w %2,%0\"\n+  [(set_attr \"type\" \"mulw,mulw\")])\n \f\n ;;- Divide instructions.\n \n@@ -672,21 +790,37 @@\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"0\")\n \t\t(match_operand:DF 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"div.d %2,%0\")\n+  \"div.d %2,%0\"\n+  [(set_attr \"type\" \"divd\")])\n \n (define_insn \"divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(div:SF (match_operand:SF 1 \"register_operand\" \"0\")\n \t\t(match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n   \"\"\n-  \"div.s %2,%0\")\n+  \"div.s %2,%0\"\n+  [(set_attr \"type\" \"divs\")])\n \n (define_insn \"divdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(div:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"div.l %2,%0\")\n+  \"div.l %2,%0\"\n+  [(set_attr \"type\" \"divl\")])\n+\n+(define_expand \"udivsi3\"\n+  [(set (match_dup 3)\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (match_dup 4)\n+\t(zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set (match_dup 3)\n+\t(div:DI (match_dup 3) (match_dup 4)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(subreg:SI (match_dup 3) 0))]\n+  \"\"\n+  \"operands[3] = gen_reg_rtx (DImode);\n+   operands[4] = gen_reg_rtx (DImode); \")\n \n (define_insn \"udivdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -700,28 +834,31 @@\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n   \"\"\n-  \"div.w %2,%0\")\n+  \"div.w %2,%0\"\n+  [(set_attr \"type\" \"divw\")])\n \n (define_insn \"divhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n \t(div:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n \t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n   \"\"\n-  \"div.h %2,%0\")\n+  \"div.h %2,%0\"\n+  [(set_attr \"type\" \"divw\")])\n \n (define_insn \"divqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(div:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t(match_operand:QI 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"div.b %2,%0\")\n+  \"div.b %2,%0\"\n+  [(set_attr \"type\" \"divw\")])\n \f\n-;; - and, or, xor\n+;;- Bit clear instructions.\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(and:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"immediate_operand\" \"Fn\")))]\n+\t\t(match_operand:DI 2 \"\" \"\")))]\n   \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n    || (GET_CODE (operands[2]) == CONST_DOUBLE\n        && CONST_DOUBLE_HIGH (operands[2]) == -1)\"\n@@ -760,7 +897,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"immediate_operand\" \"Fn\")))]\n+\t\t(match_operand:DI 2 \"\" \"\")))]\n   \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0)\n    || (GET_CODE (operands[2]) == CONST_DOUBLE\n        && CONST_DOUBLE_HIGH (operands[2]) == 0)\"\n@@ -799,7 +936,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"immediate_operand\" \"Fn\")))]\n+\t\t(match_operand:DI 2 \"\" \"\")))]\n   \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0)\n    || (GET_CODE (operands[2]) == CONST_DOUBLE\n        && CONST_DOUBLE_HIGH (operands[2]) == 0)\"\n@@ -837,13 +974,15 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"neg.d %1,%0\")\n+  \"neg.d %1,%0\"\n+  [(set_attr \"type\" \"addd\")])\n \n (define_insn \"negsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"d\")))]\n   \"\"\n-  \"neg.s %1,%0\")\n+  \"neg.s %1,%0\"\n+  [(set_attr \"type\" \"adds\")])\n \n (define_insn \"negdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -893,42 +1032,164 @@\n   \"\"\n   \"not %1,%0\")\n \f\n-;;- shifts\n+;;- Shifts\n ;;\n-;; Convex shift instructions are logical shifts.\n-;; To make signed right shifts:\n-;; for SImode, sign extend to DImode and shift, works for 0..32\n-;; for DImode, shift and then extend the sign, works for 0..63 -- but not 64\n+;; The extreme profusion of patterns here is due to the different-speed\n+;; shifts on different machines, and the C1's lack of word shift S-register\n+;; instructions.\n+\n+;; SImode\n+\n+;; Logical left 1, 1 cycle on all machines via add\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add.w %0,%0\")\n+\n+;; C34 general shift is 1 cycle\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"TARGET_C34\"\n+  \"@\n+   shf.w %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfw,shfw\")])\n+\n+;; else shift left 0..7 is 1 cycle if we use an A register\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"ai,di\")))]\n+  \"TARGET_C1 && INTVAL (operands[2]) < (unsigned) 8\"\n+  \"@\n+   shf %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"alu,shfl\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"ai,di\")))]\n+  \"INTVAL (operands[2]) < (unsigned) 8\"\n+  \"@\n+   shf %2,%0\n+   shf.w %2,%0\"\n+  [(set_attr \"type\" \"alu,shfw\")])\n+\n+;; else general left shift\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"TARGET_C1\"\n+  \"@\n+   shf %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfl,shfw\")])\n+\n+;; (but C2 shift left by a constant can is faster via multiply)\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n+  \"TARGET_C2 && INTVAL (operands[2]) < (unsigned) 32\"\n+  \"mul.w %z2,%0\"\n+  [(set_attr \"type\" \"mulw\")])\n \n (define_insn \"lshlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n \t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n   \"\"\n-  \"*\n-{\n-  if (operands[2] == const1_rtx)\n-    return \\\"add.w %0,%0\\\";\n-  else if (TARGET_C2 && S_REG_P (operands[0]))\n-    return \\\"shf.w %2,%0\\\";\n-  else\n-    return \\\"shf %2,%0\\\";\n-}\")\n+  \"@\n+   shf.w %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfw,shfw\")])\n+\n+;; Arithmetic left 1, 1 cycle on all machines via add\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add.w %0,%0\")\n+\n+;; C34 general shift is 1 cycle\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"TARGET_C34\"\n+  \"@\n+   shf.w %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfw,shfw\")])\n+\n+;; else shift left 0..7 is 1 cycle if we use an A register\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"ai,di\")))]\n+  \"TARGET_C1 && INTVAL (operands[2]) < (unsigned) 8\"\n+  \"@\n+   shf %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"alu,shfl\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"ai,di\")))]\n+  \"INTVAL (operands[2]) < (unsigned) 8\"\n+  \"@\n+   shf %2,%0\n+   shf.w %2,%0\"\n+  [(set_attr \"type\" \"alu,shfw\")])\n+\n+;; else general left shift\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"TARGET_C1\"\n+  \"@\n+   shf %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfl,shfw\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n+  \"TARGET_C2 && INTVAL (operands[2]) < (unsigned) 32\"\n+  \"mul.w %z2,%0\"\n+  [(set_attr \"type\" \"mulw\")])\n \n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n   \"\"\n-  \"*\n-{\n-  if (operands[2] == const1_rtx)\n-    return \\\"add.w %0,%0\\\";\n-  else if (TARGET_C2 && S_REG_P (operands[0]))\n-    return \\\"shf.w %2,%0\\\";\n-  else\n-    return \\\"shf %2,%0\\\";\n-}\")\n+  \"@\n+   shf.w %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfw,shfw\")])\n+\n+;; Logical right, general\n+;; The hardware wants the negative of the shift count\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -937,77 +1198,146 @@\n   \"\"\n   \"operands[2] = negate_rtx (SImode, operands[2]);\")\n \n+;; C1 lacks word shift S reg\n+\n+(define_insn \"\"\n+  [(set\n+    (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n+    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"ai,di\"))))]\n+  \"TARGET_C1\"\n+  \"@\n+   shf %2,%0\n+   ld.u #0,%0\\;shf %2,%0\"\n+  [(set_attr \"type\" \"shfw,shfl\")])\n+\n+;; general case\n+\n (define_insn \"\"\n   [(set\n     (match_operand:SI 0 \"register_operand\" \"=d,a\")\n     (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\"))))]\n   \"\"\n-  \"*\n-{\n-  if (A_REG_P (operands[0]))\n-    return \\\"shf %2,%0\\\";\n-  else if (TARGET_C2)\n-    return \\\"shf.w %2,%0\\\";\n-  else\n-    return \\\"ld.u #0,%0\\;shf %2,%0\\\";\n-}\")\n+  \"@\n+   shf.w %2,%0\n+   shf %2,%0\"\n+  [(set_attr \"type\" \"shfw,shfw\")])\n+\n+;; Patterns without neg produced by constant folding\n \n (define_insn \"\"\n   [(set\n-    (match_operand:SI 0 \"register_operand\" \"=r\")\n-    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+    (match_operand:SI 0 \"register_operand\" \"=a,?d\")\n+    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n+  \"TARGET_C1\"\n+  \"@\n+   shf #%n2,%0\n+   ld.u #0,%0\\;shf #%n2,%0\"\n+  [(set_attr \"type\" \"shfw,shfl\")])\n+\n+(define_insn \"\"\n+  [(set\n+    (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n   \"\"\n-  \"*\n-{\n-  if (A_REG_P (operands[0]))\n-    return \\\"shf #%n2,%0\\\";\n-  else if (TARGET_C2)\n-    return \\\"shf.w #%n2,%0\\\";\n-  else\n-    return \\\"ld.u #0,%0\\;shf #%n2,%0\\\";\n-}\")\n+  \"@\n+   shf.w #%n2,%0\n+   shf #%n2,%0\"\n+  [(set_attr \"type\" \"shfw,shfw\")])\n+\n+;; Arithmetic right, general\n+;; Sign-extend to 64 bits, then shift that.  Works for 0..32.\n \n (define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n   \"\"\n   \"operands[2] = negate_rtx (SImode, operands[2]);\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,&d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n+\t\t     (neg:SI\n+\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"di,di\"))))]\n   \"\"\n-  \"cvtw.l %1,%0\\;shf %2,%0\")\n+  \"cvtw.l %1,%0\\;shf %2,%0\"\n+  [(set_attr \"type\" \"shfl,shfl\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"cvtw.l %1,%0\\;shf #%n2,%0\")\n+  \"cvtw.l %1,%0\\;shf #%n2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n+\n+;; DImode\n+;; Logical left, 1-cycle\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add.l %0,%0\")\n+\n+;; Logical left, general\n \n (define_insn \"lshldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(lshift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n   \"\"\n-  \"shf %2,%0\")\n+  \"shf %2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n+\n+;; Arithmetic left, 1-cycle\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add.l %0,%0\")\n+\n+;; Arithmetic left, general\n \n (define_insn \"ashldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n   \"\"\n-  \"shf %2,%0\")\n+  \"shf %2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n \n-(define_expand \"lshrdi3\"\n+;; Can omit zero- or sign-extend if shift is 32 or more.\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+\t(ashift:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n+  \"INTVAL (operands[2]) >= 32\"\n+  \"shf %2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashift:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0\"))\n+\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n+  \"INTVAL (operands[2]) >= 32\"\n+  \"shf %2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n+\n+;; Logical right, general\n+\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n   \"\"\n   \"operands[2] = negate_rtx (SImode, operands[2]);\")\n \n@@ -1016,88 +1346,126 @@\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n   \"\"\n-  \"shf %2,%0\")\n+  \"shf %2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"shf #%n2,%0\")\n+  \"shf #%n2,%0\"\n+  [(set_attr \"type\" \"shfl\")])\n \n-;; signed  a >> b  is\n+;; Arithmetic right, general\n+;; Use\n ;;     ((a >> b) ^ signbit) - signbit\n ;; where signbit is (1 << 63) >> b\n+;; Works for 0..63.  Does not work for 64; unfortunate but legal.\n \n (define_expand \"ashrdi3\"\n-  [(match_operand:DI 0 \"register_operand\" \"\")\n-   (match_operand:DI 1 \"register_operand\" \"\")\n-   (match_operand:SI 2 \"nonmemory_operand\" \"\")\n-   (match_dup 3)]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))\n+   (set (match_dup 3) (lshiftrt:DI (match_dup 3) (neg:SI (match_dup 2))))\n+   (set (match_dup 0) (xor:DI (match_dup 0) (match_dup 3)))\n+   (set (match_dup 0) (minus:DI (match_dup 0) (match_dup 3)))]\n   \"\"\n   \"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      int rshift = INTVAL (operands[2]);\n-      if (rshift < 0)\n-\toperands[3] = force_reg (DImode, immed_double_const (0, 0, DImode));\n-      else if (rshift < 32)\n-\toperands[3] =\n-\t  force_reg (DImode,\n-\t\t     immed_double_const (0, 1 << (31 - rshift), DImode));\n-      else if (rshift < 64)\n-\toperands[3] =\n-\t  force_reg (DImode,\n-\t\t     immed_double_const (1 << (63 - rshift), 0, DImode));\n-      else\n-\toperands[3] = force_reg (DImode, immed_double_const (0, 0, DImode));\n-    }\n-  else\n-    {\n-      operands[3] =\n-\t  force_reg (DImode, immed_double_const (0, 1 << 31, DImode));\n-      emit_insn (gen_lshrdi3 (operands[3], operands[3], operands[2]));\n-    }\n-\n-  emit_insn (gen_lshrdi3 (operands[0], operands[1], operands[2]));\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t      gen_rtx (XOR, DImode, operands[0], operands[3])));\n-  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t      gen_rtx (MINUS, DImode, operands[0], operands[3])));\n-  DONE;\n+    switch (INTVAL (operands[2]))\n+      {\n+      case 32:\n+\temit_insn (gen_ashrdi3_32 (operands[0], operands[1]));\n+\tDONE;\n+      }\n+\n+  operands[2] = negate_rtx (SImode, operands[2]);\n+  operands[3] = force_reg (DImode, immed_double_const (0, 1 << 31, DImode));\n }\")\n+\n+;; Arithmetic right 32, a common case that can save a couple of insns.\n+\n+(define_expand \"ashrdi3_32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 32)))\n+   (set (match_dup 0)\n+\t(sign_extend:DI (subreg:SI (match_dup 0) 0)))]\n+  \"\"\n+  \"\")\n \f\n ;; __builtin instructions\n \n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_C2\"\n-  \"sqrt.d %0\")\n+  \"! TARGET_C1 && flag_fast_math\"\n+  \"sqrt.d %0\"\n+  [(set_attr \"type\" \"divd\")])\n \n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_C2\"\n-  \"sqrt.s %0\")\n-\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-;\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-;\t\t  (const_int 1)))]\n-;  \"\"\n-;  \"tzc %1,%0\\;le.w #32,%0\\;jbrs.f .+6\\;ld.w #-1,%0\")\n-;\n-;(define_expand \"ffssi2\"\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-;\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-;\t\t  (const_int 1)))\n-;   (set (match_dup 0)\n-;\t(plus:SI (match_dup 0)\n-;\t\t (const_int 1)))]\n-;  \"\"\n-;  \"\")\n+  \"! TARGET_C1 && flag_fast_math\"\n+  \"sqrt.s %0\"\n+  [(set_attr \"type\" \"divs\")])\n+\n+(define_insn \"sindf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n+  \"! TARGET_C1 && flag_fast_math\"\n+  \"sin.d %0\")\n+\n+(define_insn \"sinsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 1))]\n+  \"! TARGET_C1 && flag_fast_math\"\n+  \"sin.s %0\")\n+\n+(define_insn \"cosdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 2))]\n+  \"! TARGET_C1 && flag_fast_math\"\n+  \"cos.d %0\")\n+\n+(define_insn \"cossf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 2))]\n+  \"! TARGET_C1 && flag_fast_math\"\n+  \"cos.s %0\")\n+\n+(define_insn \"ftruncdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(fix:DF (match_operand:DF 1 \"register_operand\" \"d\")))]\n+  \"! TARGET_C1\"\n+  \"frint.d %1,%0\"\n+  [(set_attr \"type\" \"cvtd\")])\n+\n+(define_insn \"ftruncsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(fix:SF (match_operand:SF 1 \"register_operand\" \"d\")))]\n+  \"! TARGET_C1\"\n+  \"frint.s %1,%0\"\n+  [(set_attr \"type\" \"cvts\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t  (const_int 1)))]\n+  \"\"\n+  \"tzc %1,%0\\;le.w #32,%0\\;jbrs.f L0%=\\;ld.w #-1,%0\\\\nL0%=:\")\n+\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t  (const_int 1)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"\")\n \n (define_insn \"abssf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n@@ -1111,9 +1479,208 @@\n \t\t(match_dup 2)))]\n   \"\"\n   \"operands[2] = force_reg (DImode,\n-\t\t\t    immed_double_const (-1, 0x7fffffff, DImode));\")\n+                            immed_double_const (-1, 0x7fffffff, DImode));\")\n \f\n-;; Jumps\n+;;- Compares\n+\n+(define_insn \"cmpdi\"\n+  [(set (cc0)\n+\t(compare (match_operand:DI 0 \"register_operand\" \"d\")\n+\t\t (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'l');\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (match_operand:DI 0 \"register_operand\" \"d\"))\n+   (clobber (match_scratch:DI 1 \"=d\"))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"* return output_cmp (operands[0], operands[1], 'L');\")\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"d,a\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'w');\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"d,a\")\n+\t\t (match_operand:HI 1 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'h');\")\n+\n+; cmpqi is intentionally omitted.\n+;\n+; gcc will sign-extend or zero-extend the operands to the next\n+; wider mode, HImode.\n+;\n+; For reg .cmp. constant, we just go with the halfword immediate\n+; instruction.  Perhaps the widening insn can be cse'd or combined away.\n+; If not, we're still as good as loading a byte constant into a register\n+; to do a reg-reg byte compare.\n+;\n+; The following patterns pick up cases that can use reg .cmp. reg after all.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare\n+\t (sign_extend:HI (match_operand:QI 0 \"register_operand\" \"d\"))\n+\t (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'b');\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare\n+\t (ashift:HI (subreg:HI (match_operand:QI 0 \"register_operand\" \"d\") 0)\n+\t\t    (const_int 8))\n+\t (ashift:HI (subreg:HI (match_operand:QI 1 \"register_operand\" \"d\") 0)\n+\t\t    (const_int 8))))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'b');\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"d\")\n+\t\t (match_operand:QI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'b');\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"d,a\"))\n+   (clobber (match_scratch:QI 1 \"=d,a\"))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"* return output_cmp (operands[0], operands[1], 'B');\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (subreg (match_operand:QI 0 \"register_operand\" \"d,a\") 0))\n+   (clobber (match_scratch:QI 1 \"=d,a\"))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"* return output_cmp (operands[0], operands[1], 'B');\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extend (subreg (match_operand:QI 0 \"register_operand\" \"d,a\") 0)))\n+   (clobber (match_scratch:QI 1 \"=d,a\"))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"* return output_cmp (operands[0], operands[1], 'B');\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"register_operand\" \"d\")\n+\t\t (match_operand:DF 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 'd');\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"register_operand\" \"d\")\n+\t\t (match_operand:SF 1 \"nonmemory_cmpsf_operand\" \"dF\")))]\n+  \"\"\n+  \"* return output_cmp (operands[0], operands[1], 's');\")\n+\f\n+;; decrement-and-set-cc0 insns.\n+;;\n+;; The most important case where we can use the carry bit from an\n+;; arithmetic insn to eliminate a redundant compare is the decrement in\n+;; constructs like while (n--) and while (--n >= 0).  \n+;;\n+;; We do it with combine patterns instead of NOTICE_UPDATE_CC because\n+;; the decrement needs to be kept at the end of the block during scheduling.\n+;; \n+;; These patterns must have memory alternatives because reload refuses\n+;; to do output reloads for an insn that sets cc0 (since it does not\n+;; want to clobber cc0 with its moves).  Convex moves do not clobber\n+;; cc0, but there is no evident way to get reload to know that.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"+r,*m\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      output_cmp (operands[0], constm1_rtx, 'W');\n+      return \\\"add.w #-1,%0\\\";\n+    }\n+  else\n+    {\n+      output_cmp (gen_rtx (REG, SImode, 7), constm1_rtx, 'W');\n+      return \\\"psh.w s7\\;ld.w %0,s7\\;add.w #-1,s7\\;st.w s7,%0\\;pop.w s7\\\";\n+    }\n+}\")\n+     \n+(define_insn \"\"\n+  [(set (cc0)\n+\t(plus:SI (match_operand:SI 0 \"register_operand\" \"+r,*m\")\n+\t\t (const_int -1)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"find_reg_note (next_cc0_user (insn), REG_NONNEG, 0)\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      output_cmp (operands[0], const0_rtx, 'W');\n+      return \\\"add.w #-1,%0\\\";\n+    }\n+  else\n+    {\n+      output_cmp (gen_rtx (REG, SImode, 7), const0_rtx, 'W');\n+      return \\\"psh.w s7\\;ld.w %0,s7\\;add.w #-1,s7\\;st.w s7,%0\\;pop.w s7\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"register_operand\" \"+r,*m\"))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      output_cmp (operands[0], constm1_rtx, 'W');\n+      return \\\"add.w #-1,%0\\\";\n+    }\n+  else\n+    {\n+      output_cmp (gen_rtx (REG, HImode, 7), constm1_rtx, 'W');\n+      return \\\"psh.w s7\\;ld.h %0,s7\\;add.h #-1,s7\\;st.h s7,%0\\;pop.w s7\\\";\n+    }\n+}\")\n+     \n+(define_insn \"\"\n+  [(set (cc0)\n+\t(plus:HI (match_operand:HI 0 \"register_operand\" \"+r,*m\")\n+\t\t (const_int -1)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"find_reg_note (next_cc0_user (insn), REG_NONNEG, 0)\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      output_cmp (operands[0], const0_rtx, 'W');\n+      return \\\"add.w #-1,%0\\\";\n+    }\n+  else\n+    {\n+      output_cmp (gen_rtx (REG, HImode, 7), const0_rtx, 'W');\n+      return \\\"psh.w s7\\;ld.h %0,s7\\;add.h #-1,s7\\;st.h s7,%0\\;pop.w s7\\\";\n+    }\n+}\")\n+\f\n+;;- Jumps\n \n (define_insn \"jump\"\n   [(set (pc)\n@@ -1128,7 +1695,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"eq\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"eq\\\", 't'); \")\n \n (define_insn \"bne\"\n   [(set (pc)\n@@ -1137,7 +1704,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"eq\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"eq\\\", 'f'); \")\n \n (define_insn \"bgt\"\n   [(set (pc)\n@@ -1146,7 +1713,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"le\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"le\\\", 'f'); \")\n \n (define_insn \"bgtu\"\n   [(set (pc)\n@@ -1155,7 +1722,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"leu\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"leu\\\", 'f'); \")\n \n (define_insn \"blt\"\n   [(set (pc)\n@@ -1164,7 +1731,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"lt\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"lt\\\", 't'); \")\n \n (define_insn \"bltu\"\n   [(set (pc)\n@@ -1173,7 +1740,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"ltu\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"ltu\\\", 't'); \")\n \n (define_insn \"bge\"\n   [(set (pc)\n@@ -1182,7 +1749,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"lt\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"lt\\\", 'f'); \")\n \n (define_insn \"bgeu\"\n   [(set (pc)\n@@ -1191,7 +1758,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"ltu\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"ltu\\\", 'f'); \")\n \n (define_insn \"ble\"\n   [(set (pc)\n@@ -1200,7 +1767,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"le\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"le\\\", 't'); \")\n \n (define_insn \"bleu\"\n   [(set (pc)\n@@ -1209,7 +1776,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"leu\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"leu\\\", 't'); \")\n \f\n (define_insn \"\"\n   [(set (pc)\n@@ -1218,7 +1785,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"eq\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"eq\\\", 'f'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1227,7 +1794,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"eq\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"eq\\\", 't'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1236,7 +1803,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"le\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"le\\\", 't'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1245,7 +1812,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"leu\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"leu\\\", 't'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1254,7 +1821,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"lt\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"lt\\\", 'f'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1263,7 +1830,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"ltu\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"ltu\\\", 'f'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1272,7 +1839,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"lt\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"lt\\\", 't'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1281,7 +1848,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"ltu\\\", 't'); \")\n+  \"* return output_condjump (operands[0], \\\"ltu\\\", 't'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1290,7 +1857,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"le\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"le\\\", 'f'); \")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -1299,35 +1866,66 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"* return gen_cmp (operands[0], \\\"leu\\\", 'f'); \")\n+  \"* return output_condjump (operands[0], \\\"leu\\\", 'f'); \")\n \f\n-;;  - Calls\n-;;\n-;; arg count word may be omitted to save a push and let gcc try to\n-;; combine the arg list pop.  RETURN_POPS_ARGS from tm.h decides this.\n+;;- Calls\n \n-(define_insn \"call\"\n+(define_expand \"call_pop\"\n+  [(parallel [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t\t    (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+\t      (match_operand:SI 2 \"const_int_operand\" \"i\")\n+\t      (match_operand:SI 3 \"const_int_operand\" \"i\")\n+\t      (reg:SI 8)])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (match_operand 1 \"\" \"g\"))]\n+\t (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+   (match_operand:SI 2 \"const_int_operand\" \"i\")\n+   (match_operand:SI 3 \"const_int_operand\" \"i\")\n+   (match_operand:SI 4 \"\" \"\")]\n   \"\"\n-  \"* return output_call (insn, operands[0], operands[1]);\")\n+  \"* return output_call (insn, &operands[0]);\")\n \n-(define_insn \"call_value\"\n+(define_expand \"call_value_pop\"\n+  [(parallel [(set (match_operand 0 \"\" \"=g\")\n+\t\t   (call (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")))\n+\t      (match_operand:SI 3 \"const_int_operand\" \"i\")\n+\t      (match_operand:SI 4 \"const_int_operand\" \"i\")\n+\t      (reg:SI 8)])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n   [(set (match_operand 0 \"\" \"=g\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (match_operand 2 \"\" \"g\")))]\n+\t      (match_operand:SI 2 \"const_int_operand\" \"i\")))\n+   (match_operand:SI 3 \"const_int_operand\" \"i\")\n+   (match_operand:SI 4 \"const_int_operand\" \"i\")\n+   (match_operand:SI 5 \"\" \"\")]\n+  \"\"\n+  \"* return output_call (insn, &operands[1]); \")\n+\n+(define_expand \"return\"\n+  [(return)]\n   \"\"\n-  \"* return output_call (insn, operands[1], operands[2]);\")\n+  \" replace_arg_pushes (); \")\n \n-(define_insn \"return\"\n+(define_insn \"\"\n   [(return)]\n   \"\"\n   \"rtn\")\n \n-(define_insn \"nop\"\n+(define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n-  \"nop\")\n+  \"\n+{\n+  emit_ap_optimizations ();\n+  DONE; \n+}\")\n \n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n@@ -1339,3 +1937,13 @@\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n   \"\"\n   \"jmp %a0\")\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}, {"sha": "e1fbe742d03750f1bf1a8b9881597ce0fdfccaa1", "filename": "gcc/config/convex/x-convex", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fx-convex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fx-convex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fx-convex?ref=6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "patch": "@@ -1,3 +1,5 @@\n-# Use -pcc to avoid surprises.\n+# ld can make exe's c2-only if this lib is searched even though not loaded\n+CCLIBFLAGS = -tm c1 \n \n+# Use -pcc to avoid surprises.\n CC = cc -pcc"}, {"sha": "38e717f390939ea403115892375697886f9d7fdf", "filename": "gcc/config/convex/xm-convex.h", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fxm-convex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cecf4ce3c74bc0b04b2de762de8b0123c1786b4/gcc%2Fconfig%2Fconvex%2Fxm-convex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fxm-convex.h?ref=6cecf4ce3c74bc0b04b2de762de8b0123c1786b4", "patch": "@@ -1,5 +1,5 @@\n /* Configuration for GNU C-compiler for Convex.\n-   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -41,26 +41,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define alloca __builtin_alloca\n #endif\n \n-#ifdef _POSIX_SOURCE\n-\n /* Convex ships /tmp as a separate file system - thus it\n    usually has more free space than /usr/tmp */\n \n #define P_tmpdir\t\"/tmp/\"\n \n-/* Un-hide names hidden in Posix include files.  */\n-\n-#define S_IFMT _S_IFMT\n-#define S_IFREG _S_IFREG\n+/* Use memcpy and memset -- either would work but these get inlined. */\n \n-#else\n+#define bcopy(a,b,c) memcpy (b,a,c)\n+#define bzero(a,b) memset (a,0,b)\n \n-/* This definition is to prevent 8.0 include files from declaring prototypes.\n-   Those include files ANSIfied, but the prototypes sometimes do not match.\n-   There is no effect on pre-8.0 OS versions.  */\n-\n-#ifndef _PROTO\n-#define _PROTO(X) ()\n-#endif\n+/* Convex uses Vax or IEEE floats.\n+   Both formats have Vax semantics. */\n \n-#endif /* _POSIX_SOURCE */\n+#define HOST_FLOAT_FORMAT VAX_FLOAT_FORMAT"}]}