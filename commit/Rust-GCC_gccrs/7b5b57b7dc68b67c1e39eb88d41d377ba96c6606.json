{"sha": "7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I1YjU3YjdkYzY4YjY3YzFlMzllYjg4ZDQxZDM3N2JhOTZjNjYwNg==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-05-30T14:37:25Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-05-30T14:37:25Z"}, "message": "re PR fortran/15620 (Statement functions and optimization cause IC)\n\n\tPR fortran/15620\n\t* trans-decl.c (gfc_shadow_sym, gfc_restore_sym): New functions.\n\t* trans-expr.c (gfc_trans_string_copy): New function.\n\t(gfc_conv_statement_function): Use them.  Create temp vars.  Enforce\n\tcharacter lengths.\n\t(gfc_conv_string_parameter): Use gfc_trans_string_copy.\n\t* trans-stmt.c (gfc_trans_forall_1): Use gfc_{shadow,restore}_sym.\n\t* trans.h (struct gfc_saved_var): Define.\n\t(gfc_shadow_sym, gfc_restore_sym): Add prototypes.\ntestsuite/\n\t* gfortran.fortran-torture/execute/st_function_1.f90: New test.\n\t* gfortran.fortran-torture/execute/st_function_2.f90: New test.\n\nFrom-SVN: r82452", "tree": {"sha": "00a8818dcf5ba37c109c3fc7ee836662eddd859e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00a8818dcf5ba37c109c3fc7ee836662eddd859e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/comments", "author": null, "committer": null, "parents": [{"sha": "7a70d70c54f4b73e25f7860f56bcd8f9e532f16c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a70d70c54f4b73e25f7860f56bcd8f9e532f16c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a70d70c54f4b73e25f7860f56bcd8f9e532f16c"}], "stats": {"total": 248, "additions": 186, "deletions": 62}, "files": [{"sha": "fa09538d58587cf70968a54977b42b168c55f300", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -1,3 +1,15 @@\n+2004-05-30  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/15620\n+\t* trans-decl.c (gfc_shadow_sym, gfc_restore_sym): New functions.\n+\t* trans-expr.c (gfc_trans_string_copy): New function.\n+\t(gfc_conv_statement_function): Use them.  Create temp vars.  Enforce\n+\tcharacter lengths.\n+\t(gfc_conv_string_parameter): Use gfc_trans_string_copy.\n+\t* trans-stmt.c (gfc_trans_forall_1): Use gfc_{shadow,restore}_sym.\n+\t* trans.h (struct gfc_saved_var): Define.\n+\t(gfc_shadow_sym, gfc_restore_sym): Add prototypes.\n+\n 2004-05-30  Steven G. Kargl  <kargls@comcast.net>\n \n \t* iresolve.c (gfc_resolve_random_number): Clean up conditional."}, {"sha": "7bd912e751583998b2dbe8031586d566c0d899cb", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -866,6 +866,32 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n }\n \n \n+/* Substitute a temporary variable in place of the real one.  */\n+\n+void\n+gfc_shadow_sym (gfc_symbol * sym, tree decl, gfc_saved_var * save)\n+{\n+  save->attr = sym->attr;\n+  save->decl = sym->backend_decl;\n+\n+  gfc_clear_attr (&sym->attr);\n+  sym->attr.referenced = 1;\n+  sym->attr.flavor = FL_VARIABLE;\n+\n+  sym->backend_decl = decl;\n+}\n+\n+\n+/* Restore the original variable.  */\n+\n+void\n+gfc_restore_sym (gfc_symbol * sym, gfc_saved_var * save)\n+{\n+  sym->attr = save->attr;\n+  sym->backend_decl = save->decl;\n+}\n+\n+\n /* Get a basic decl for an external function.  */\n \n tree"}, {"sha": "a1a8d4691326152c99a650958a0699f7168e4861", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 74, "deletions": 37, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -1182,6 +1182,24 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n }\n \n \n+/* Generate code to copy a string.  */\n+\n+static void\n+gfc_trans_string_copy (stmtblock_t * block, tree dlen, tree dest,\n+\t\t       tree slen, tree src)\n+{\n+  tree tmp;\n+\n+  tmp = NULL_TREE;\n+  tmp = gfc_chainon_list (tmp, dlen);\n+  tmp = gfc_chainon_list (tmp, dest);\n+  tmp = gfc_chainon_list (tmp, slen);\n+  tmp = gfc_chainon_list (tmp, src);\n+  tmp = gfc_build_function_call (gfor_fndecl_copy_string, tmp);\n+  gfc_add_expr_to_block (block, tmp);\n+}\n+\n+\n /* Translate a statement function.\n    The value of a statement function reference is obtained by evaluating the\n    expression using the values of the actual arguments for the values of the\n@@ -1196,69 +1214,98 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n   gfc_actual_arglist *args;\n   gfc_se lse;\n   gfc_se rse;\n+  gfc_saved_var *saved_vars;\n+  tree *temp_vars;\n+  tree type;\n+  tree tmp;\n+  int n;\n \n   sym = expr->symtree->n.sym;\n   args = expr->value.function.actual;\n   gfc_init_se (&lse, NULL);\n   gfc_init_se (&rse, NULL);\n \n+  n = 0;\n   for (fargs = sym->formal; fargs; fargs = fargs->next)\n+    n++;\n+  saved_vars = (gfc_saved_var *)gfc_getmem (n * sizeof (gfc_saved_var));\n+  temp_vars = (tree *)gfc_getmem (n * sizeof (tree));\n+\n+  for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n     {\n       /* Each dummy shall be specified, explicitly or implicitly, to be\n          scalar.  */\n       assert (fargs->sym->attr.dimension == 0);\n       fsym = fargs->sym;\n-      assert (fsym->backend_decl);\n \n-      /* Convert non-pointer string dummy.  */\n-      if (fsym->ts.type == BT_CHARACTER && !fsym->attr.pointer)\n+      /* Create a temporary to hold the value.  */\n+      type = gfc_typenode_for_spec (&fsym->ts);\n+      temp_vars[n] = gfc_create_var (type, fsym->name);\n+\n+      if (fsym->ts.type == BT_CHARACTER)\n         {\n-          tree len1;\n-          tree len2;\n-          tree arg;\n-          tree tmp;\n-          tree type;\n-          tree var;\n+\t  /* Copy string arguments.  */\n+          tree arglen;\n \n           assert (fsym->ts.cl && fsym->ts.cl->length\n                   && fsym->ts.cl->length->expr_type == EXPR_CONSTANT);\n \n-          type = gfc_get_character_type (fsym->ts.kind, fsym->ts.cl);\n-          len1 = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-          var = gfc_build_addr_expr (build_pointer_type (type),\n-\t\t\t\t     fsym->backend_decl);\n+          arglen = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+          tmp = gfc_build_addr_expr (build_pointer_type (type),\n+\t\t\t\t     temp_vars[n]);\n \n           gfc_conv_expr (&rse, args->expr);\n           gfc_conv_string_parameter (&rse);\n-          len2 = rse.string_length;\n           gfc_add_block_to_block (&se->pre, &lse.pre);\n           gfc_add_block_to_block (&se->pre, &rse.pre);\n \n-          arg = NULL_TREE;\n-          arg = gfc_chainon_list (arg, len1);\n-          arg = gfc_chainon_list (arg, var);\n-          arg = gfc_chainon_list (arg, len2);\n-          arg = gfc_chainon_list (arg, rse.expr);\n-          tmp = gfc_build_function_call (gfor_fndecl_copy_string, arg);\n-          gfc_add_expr_to_block (&se->pre, tmp);\n+\t  gfc_trans_string_copy (&se->pre, arglen, tmp, rse.string_length,\n+\t\t\t\t rse.expr);\n           gfc_add_block_to_block (&se->pre, &lse.post);\n           gfc_add_block_to_block (&se->pre, &rse.post);\n         }\n       else\n         {\n           /* For everything else, just evaluate the expression.  */\n-          if (fsym->attr.pointer == 1)\n-            lse.want_pointer = 1;\n-\n           gfc_conv_expr (&lse, args->expr);\n \n           gfc_add_block_to_block (&se->pre, &lse.pre);\n-          gfc_add_modify_expr (&se->pre, fsym->backend_decl, lse.expr);\n+          gfc_add_modify_expr (&se->pre, temp_vars[n], lse.expr);\n           gfc_add_block_to_block (&se->pre, &lse.post);\n         }\n+\n       args = args->next;\n     }\n+\n+  /* Use the temporary variables in place of the real ones.  */\n+  for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n+    gfc_shadow_sym (fargs->sym, temp_vars[n], &saved_vars[n]);\n+\n   gfc_conv_expr (se, sym->value);\n+\n+  if (sym->ts.type == BT_CHARACTER)\n+    {\n+      gfc_conv_const_charlen (sym->ts.cl);\n+\n+      /* Force the expression to the correct length.  */\n+      if (!INTEGER_CST_P (se->string_length)\n+\t  || tree_int_cst_lt (se->string_length,\n+\t\t\t      sym->ts.cl->backend_decl))\n+\t{\n+\t  type = gfc_get_character_type (sym->ts.kind, sym->ts.cl);\n+\t  tmp = gfc_create_var (type, sym->name);\n+\t  tmp = gfc_build_addr_expr (build_pointer_type (type), tmp);\n+\t  gfc_trans_string_copy (&se->pre, sym->ts.cl->backend_decl, tmp,\n+\t\t\t\t se->string_length, se->expr);\n+\t  se->expr = tmp;\n+\t}\n+      se->string_length = sym->ts.cl->backend_decl;\n+    }\n+\n+  /* Resore the original variables.  */\n+  for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n+    gfc_restore_sym (fargs->sym, &saved_vars[n]);\n+  gfc_free (saved_vars);\n }\n \n \n@@ -1617,17 +1664,12 @@ gfc_conv_string_parameter (gfc_se * se)\n tree\n gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, bt type)\n {\n-  tree tmp;\n-  tree args;\n   stmtblock_t block;\n \n   gfc_init_block (&block);\n \n-\n   if (type == BT_CHARACTER)\n     {\n-      args = NULL_TREE;\n-\n       assert (lse->string_length != NULL_TREE\n \t      && rse->string_length != NULL_TREE);\n \n@@ -1637,13 +1679,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, bt type)\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n \n-      args = gfc_chainon_list (args, lse->string_length);\n-      args = gfc_chainon_list (args, lse->expr);\n-      args = gfc_chainon_list (args, rse->string_length);\n-      args = gfc_chainon_list (args, rse->expr);\n-\n-      tmp = gfc_build_function_call (gfor_fndecl_copy_string, args);\n-      gfc_add_expr_to_block (&block, tmp);\n+      gfc_trans_string_copy (&block, lse->string_length, lse->expr,\n+\t\t\t     rse->string_length, rse->expr);\n     }\n   else\n     {"}, {"sha": "bbaa19d1123ca8640607f381e7fb038337464c26", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -2121,8 +2121,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   gfc_forall_iterator *fa;\n   gfc_se se;\n   gfc_code *c;\n-  tree *saved_var_decl;\n-  symbol_attribute *saved_var_attr;\n+  gfc_saved_var *saved_vars;\n   iter_info *this_forall, *iter_tmp;\n   forall_info *info, *forall_tmp;\n   temporary_list *temp;\n@@ -2141,9 +2140,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   end = (tree *) gfc_getmem (nvar * sizeof (tree));\n   step = (tree *) gfc_getmem (nvar * sizeof (tree));\n   varexpr = (gfc_expr **) gfc_getmem (nvar * sizeof (gfc_expr *));\n-  saved_var_decl = (tree *) gfc_getmem (nvar * sizeof (tree));\n-  saved_var_attr = (symbol_attribute *)\n-    gfc_getmem (nvar * sizeof (symbol_attribute));\n+  saved_vars = (gfc_saved_var *) gfc_getmem (nvar * sizeof (gfc_saved_var));\n \n   /* Allocate the space for info.  */\n   info = (forall_info *) gfc_getmem (sizeof (forall_info));\n@@ -2155,20 +2152,11 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       /* allocate space for this_forall.  */\n       this_forall = (iter_info *) gfc_getmem (sizeof (iter_info));\n \n-      /* Save the FORALL index's backend_decl.  */\n-      saved_var_decl[n] = sym->backend_decl;\n-\n-      /* Save the attribute.  */\n-      saved_var_attr[n] = sym->attr;\n-\n-      /* Set the proper attributes. */\n-      gfc_clear_attr (&sym->attr);\n-      sym->attr.referenced = 1;\n-      sym->attr.flavor = FL_VARIABLE;\n-\n       /* Create a temporary variable for the FORALL index.  */\n       tmp = gfc_typenode_for_spec (&sym->ts);\n       var[n] = gfc_create_var (tmp, sym->name);\n+      gfc_shadow_sym (sym, var[n], &saved_vars[n]);\n+\n       /* Record it in this_forall.  */\n       this_forall->var = var[n];\n \n@@ -2396,22 +2384,17 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       c = c->next;\n     }\n \n-  /* Restore the index original backend_decl and the attribute.  */\n-  for (fa = code->ext.forall_iterator, n=0; fa; fa = fa->next, n++)\n-    {\n-      gfc_symbol *sym = fa->var->symtree->n.sym;\n-      sym->backend_decl = saved_var_decl[n];\n-      sym->attr = saved_var_attr[n];\n-    }\n+  /* Restore the original index variables.  */\n+  for (fa = code->ext.forall_iterator, n = 0; fa; fa = fa->next, n++)\n+    gfc_restore_sym (fa->var->symtree->n.sym, &saved_vars[n]);\n \n   /* Free the space for var, start, end, step, varexpr.  */\n   gfc_free (var);\n   gfc_free (start);\n   gfc_free (end);\n   gfc_free (step);\n   gfc_free (varexpr);\n-  gfc_free (saved_var_decl);\n-  gfc_free (saved_var_attr);\n+  gfc_free (saved_vars);\n \n   if (pmask)\n     {"}, {"sha": "1c205ef0afdfd4b05aa7197150521547f903a9a6", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -235,6 +235,16 @@ typedef struct gfc_loopinfo\n }\n gfc_loopinfo;\n \n+\n+/* Information about a symbol that has been shadowed by a temporary.  */\n+typedef struct\n+{\n+  symbol_attribute attr;\n+  tree decl;\n+}\n+gfc_saved_var;\n+\n+\n /* Advance the SS chain to the next term.  */\n void gfc_advance_se_ss_chain (gfc_se *);\n \n@@ -364,6 +374,12 @@ void gfc_build_builtin_function_decls (void);\n /* Return the variable decl for a symbol.  */\n tree gfc_get_symbol_decl (gfc_symbol *);\n \n+/* Substitute a temporary variable in place of the real one.  */\n+void gfc_shadow_sym (gfc_symbol *, tree, gfc_saved_var *);\n+\n+/* Restore the original variable.  */\n+void gfc_restore_sym (gfc_symbol *, gfc_saved_var *);\n+\n /* Allocate the lang-spcific part of a decl node.  */\n void gfc_allocate_lang_decl (tree);\n "}, {"sha": "6d0c44bf1ea20c5396caddeab83ece1bff597e1b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -1,3 +1,9 @@\n+2004-05-30  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/15620\n+\t* gfortran.fortran-torture/execute/st_function_1.f90: New test.\n+\t* gfortran.fortran-torture/execute/st_function_2.f90: New test.\n+\n 2004-05-30  Steven G. Kargl  <kargls@comcast.net>\n \n \t* gfortran.fortran-torture/execute/random_1.f90: New test."}, {"sha": "0387a5f71c7afa254e99034235e651cbefed05a3", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/st_function_1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fst_function_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fst_function_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fst_function_1.f90?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -0,0 +1,23 @@\n+! Check that character valued statement functions honour length parameters\n+program st_function_1\n+  character(8) :: foo\n+  character(15) :: bar\n+  character(6) :: p\n+  character (7) :: s\n+  foo(p) = p // \"World\"\n+  bar(p) = p // \"World\"\n+  \n+  ! Expression longer than function, actual arg shorter than dummy.\n+  call check (foo(\"Hello\"), \"Hello Wo\")\n+\n+  ! Expression shorter than function, actual arg longer than dummy.\n+  ! Result shorter than type\n+  s = \"Hello\"\n+  call check (bar(s), \"Hello World    \")\n+contains\n+subroutine check(a, b)\n+  character (len=*) :: a, b\n+\n+  if ((a .ne. b) .or. (len(a) .ne. len(b))) call abort ()\n+end subroutine\n+end program"}, {"sha": "2dec735625fabce77d19950a7aa807ffad68bd49", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/st_function_2.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fst_function_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b5b57b7dc68b67c1e39eb88d41d377ba96c6606/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fst_function_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fst_function_2.f90?ref=7b5b57b7dc68b67c1e39eb88d41d377ba96c6606", "patch": "@@ -0,0 +1,21 @@\n+! PR15620\n+! Check that evaluating a statement function doesn't affect the value of\n+! its dummy argument variables.\n+program st_function_2\n+  integer fn, a, b\n+  fn(a, b) = a + b\n+  if (foo(1) .ne. 43) call abort\n+\n+  ! Check that values aren't modified when avaluating the arguments.\n+  a = 1\n+  b = 5\n+  if (fn (b + 2, a + 3) .ne. 11) call abort\n+contains\n+function foo (x) \n+  integer z, y, foo, x \n+  bar(z) = z*z \n+  z = 42 \n+  t = bar(x) \n+  foo = t + z \n+end function \n+end program "}]}