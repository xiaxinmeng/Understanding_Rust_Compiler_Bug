{"sha": "be3d702cc47e210ccf01db87bd9a2d451c20b677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzZDcwMmNjNDdlMjEwY2NmMDFkYjg3YmQ5YTJkNDUxYzIwYjY3Nw==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-10-21T10:44:39Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2004-10-21T10:44:39Z"}, "message": "configure.ac (SIGNAL_HANDLER): Set to include/sh-signal.h for all sh*-*-linux* targets.\n\n\t* configure.ac (SIGNAL_HANDLER): Set to include/sh-signal.h\n\tfor all sh*-*-linux* targets.\n\t* configure: Regenerate.\n\t* include/sh-signal.h: New file.\n\nFrom-SVN: r89368", "tree": {"sha": "b1ec917af2424cc72dd6332067c5e81ea53eb3d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1ec917af2424cc72dd6332067c5e81ea53eb3d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be3d702cc47e210ccf01db87bd9a2d451c20b677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3d702cc47e210ccf01db87bd9a2d451c20b677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3d702cc47e210ccf01db87bd9a2d451c20b677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3d702cc47e210ccf01db87bd9a2d451c20b677/comments", "author": null, "committer": null, "parents": [{"sha": "2989a2f55b22a24feb7cb04968823dea606874ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2989a2f55b22a24feb7cb04968823dea606874ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2989a2f55b22a24feb7cb04968823dea606874ff"}], "stats": {"total": 111, "additions": 107, "deletions": 4}, "files": [{"sha": "2bad1d497502aff0293662a3f28b141b9ae251aa", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=be3d702cc47e210ccf01db87bd9a2d451c20b677", "patch": "@@ -1,3 +1,10 @@\n+2004-10-21  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* configure.ac (SIGNAL_HANDLER): Set to include/sh-signal.h\n+\tfor all sh*-*-linux* targets.\n+\t* configure: Regenerate.\n+\t* include/sh-signal.h: New file.\n+\n 2004-10-21  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>\n \n \t* java/lang/ieeefp.h: Add m32r support."}, {"sha": "d3ce0509d0fba934dd0ce4eb1a7ccaa577829655", "filename": "libjava/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=be3d702cc47e210ccf01db87bd9a2d451c20b677", "patch": "@@ -16211,8 +16211,8 @@ case \"${host}\" in\n  sparc*-*-linux*)\n     SIGNAL_HANDLER=include/dwarf2-signal.h\n     ;;\n- sh-*-linux* | sh[34]*-*-linux*)\n-    SIGNAL_HANDLER=include/dwarf2-signal.h\n+ sh*-*-linux*)\n+    SIGNAL_HANDLER=include/sh-signal.h\n     ;;\n  *mingw*)\n     SIGNAL_HANDLER=include/win32-signal.h"}, {"sha": "80775ab6219ab576223e1b3ebda73e3ac388db3b", "filename": "libjava/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=be3d702cc47e210ccf01db87bd9a2d451c20b677", "patch": "@@ -1310,8 +1310,8 @@ case \"${host}\" in\n  sparc*-*-linux*)\n     SIGNAL_HANDLER=include/dwarf2-signal.h\n     ;;\n- sh-*-linux* | sh[[34]]*-*-linux*)\n-    SIGNAL_HANDLER=include/dwarf2-signal.h\n+ sh*-*-linux*)\n+    SIGNAL_HANDLER=include/sh-signal.h\n     ;;\n  *mingw*)\n     SIGNAL_HANDLER=include/win32-signal.h"}, {"sha": "9c76b5716bebf1465787822ba3810faae5688ef2", "filename": "libjava/include/sh-signal.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2Finclude%2Fsh-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3d702cc47e210ccf01db87bd9a2d451c20b677/libjava%2Finclude%2Fsh-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fsh-signal.h?ref=be3d702cc47e210ccf01db87bd9a2d451c20b677", "patch": "@@ -0,0 +1,96 @@\n+// sh-signal.h - Catch runtime signals and turn them into exceptions\n+// on a SuperH based Linux system.\n+\n+/* Copyright (C) 2004  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+\n+#ifndef JAVA_SIGNAL_H\n+#define JAVA_SIGNAL_H 1\n+\n+#include <signal.h>\n+#include <sys/syscall.h>\n+\n+#define HANDLE_SEGV 1\n+#define HANDLE_FPE 1\n+\n+/* The third parameter to the signal handler points to something with\n+ * this structure defined in asm/ucontext.h, but the name clashes with\n+ * struct ucontext from sys/ucontext.h so this private copy is used.  */\n+typedef struct _sig_ucontext {\n+  unsigned long uc_flags;\n+  struct _sig_ucontext *uc_link;\n+  stack_t uc_stack;\n+  struct sigcontext uc_mcontext;\n+  sigset_t uc_sigmask;\n+} sig_ucontext_t;\n+\n+#define SIGNAL_HANDLER(_name)\t\t\t\t\t\t\\\n+  static void _name (int , siginfo_t *, sig_ucontext_t *_uc)\n+\n+/* SH either leaves PC pointing at a faulting instruction or the\n+   following instruction, depending on the signal.  SEGV always does\n+   the former, so we adjust the saved PC to point to the following\n+   instruction. This is what the handler in libgcc expects.  */\n+\n+#ifdef __SH5__\n+#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    volatile struct sigcontext *_sc = &_uc->uc_mcontext;\t\t\\ \n+    _sc->sc_pc += 4;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#else\n+#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    volatile struct sigcontext *_sc = &_uc->uc_mcontext;\t\t\\ \n+    _sc->sc_pc += 2;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#endif\n+\n+/* For an explanation why we cannot simply use sigaction to\n+   install the handlers, see i386-signal.h.  */\n+\n+/* We use kernel_old_sigaction here because we're calling the kernel\n+   directly rather than via glibc.  The sigaction structure that the\n+   syscall uses is a different shape from the one in userland and not\n+   visible to us in a header file so we define it here.  */\n+\n+struct kernel_old_sigaction {\n+  void (*k_sa_handler) (int, siginfo_t *, sig_ucontext_t *);\n+  unsigned long k_sa_mask;\n+  unsigned long k_sa_flags;\n+  void (*k_sa_restorer) (void);\n+};\n+\n+#define INIT_SEGV\t\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    struct kernel_old_sigaction kact;\t\t\t\t\t\\\n+    kact.k_sa_handler = catch_segv;\t\t\t\t\t\\\n+    kact.k_sa_mask = 0;\t\t\t\t\t\t\t\\\n+    kact.k_sa_flags = SA_SIGINFO | SA_NODEFER;\t\t\t\t\\\n+    syscall (SYS_sigaction, SIGSEGV, &kact, NULL);\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)  \n+\n+#define INIT_FPE\t\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    struct kernel_old_sigaction kact;\t\t\t\t\t\\\n+    kact.k_sa_handler = catch_fpe;\t\t\t\t\t\\\n+    kact.k_sa_mask = 0;\t\t\t\t\t\t\t\\\n+    kact.k_sa_flags = SA_SIGINFO | SA_NODEFER;\t\t\t\t\\\n+    syscall (SYS_sigaction, SIGFPE, &kact, NULL);\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#endif /* JAVA_SIGNAL_H */"}]}