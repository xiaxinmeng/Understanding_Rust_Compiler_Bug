{"sha": "0020519f3a37ac314f6f2e407c301b8dfbb53dd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyMDUxOWYzYTM3YWMzMTRmNmYyZTQwN2MzMDFiOGRmYmI1M2RkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-25T22:11:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-25T22:11:11Z"}, "message": "(output_decl): Check for DECL_INITIAL == NULL_TREE rather than DECL_EXTERNAL !=...\n\n(output_decl): Check for DECL_INITIAL == NULL_TREE rather than\nDECL_EXTERNAL != 0 when trying to see if we have a mere function\ndeclaration rather than a function definition.\n(dwarfout_file_scope_decl): Likewise.  Also, don't bother checking\nTREE_USED for file-scope functions, since it isn't 100% accurate until\nthe end of compilation anyway.\n\nFrom-SVN: r4225", "tree": {"sha": "62d922bbf27aca1c81f493153fed69fa4188d5c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62d922bbf27aca1c81f493153fed69fa4188d5c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0020519f3a37ac314f6f2e407c301b8dfbb53dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0020519f3a37ac314f6f2e407c301b8dfbb53dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0020519f3a37ac314f6f2e407c301b8dfbb53dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0020519f3a37ac314f6f2e407c301b8dfbb53dd7/comments", "author": null, "committer": null, "parents": [{"sha": "1934ceca8c3e283f28a36778cd4259f3c90abf48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1934ceca8c3e283f28a36778cd4259f3c90abf48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1934ceca8c3e283f28a36778cd4259f3c90abf48"}], "stats": {"total": 52, "additions": 36, "deletions": 16}, "files": [{"sha": "d81d4620e8b2361710f807a75210ce7e962f62d0", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0020519f3a37ac314f6f2e407c301b8dfbb53dd7/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0020519f3a37ac314f6f2e407c301b8dfbb53dd7/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=0020519f3a37ac314f6f2e407c301b8dfbb53dd7", "patch": "@@ -4346,11 +4346,11 @@ output_decl (decl, containing_scope)\n \n     case FUNCTION_DECL:\n       /* If we are in terse mode, don't output any DIEs to represent\n-\t mere external function declarations.  Also, if we are conforming\n+\t mere function declarations.  Also, if we are conforming\n \t to the DWARF version 1 specification, don't output DIEs for\n-\t mere external function declarations.  */\n+\t mere function declarations.  */\n \n-      if (DECL_EXTERNAL (decl))\n+      if (DECL_INITIAL (decl) == NULL_TREE)\n #if (DWARF_VERSION > 1)\n \tif (debug_info_level <= DINFO_LEVEL_TERSE)\n #endif\n@@ -4393,11 +4393,11 @@ output_decl (decl, containing_scope)\n \t ends with a void_type_node then there should *not* be an ellipsis\n \t at the end.  */\n \n-      /* In the case where we are describing an external function, all\n+      /* In the case where we are describing a mere function declaration, all\n \t we need to do here (and all we *can* do here) is to describe\n \t the *types* of its formal parameters.  */\n \n-      if (DECL_EXTERNAL (decl))\n+      if (DECL_INITIAL (decl) == NULL_TREE)\n \toutput_formal_types (TREE_TYPE (decl));\n       else\n \t{\n@@ -4738,17 +4738,37 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n       if (DECL_EXTERNAL (decl) && DECL_FUNCTION_CODE (decl))\n         return;\n \n-      /* Ignore this FUNCTION_DECL if it refers to a file-scope extern\n-\t function declaration and if the declaration was never even\n-\t referenced from within this entire compilation unit.  We\n-\t suppress these DIEs in order to save space in the .debug section\n-\t (by eliminating entries which are probably useless).  Note that\n-\t we must not suppress block-local extern declarations (whether\n-\t used or not) because that would screw-up the debugger's name\n-\t lookup mechanism and cause it to miss things which really ought\n-\t to be in scope at a given point.  */\n-\n-      if (DECL_EXTERNAL (decl) && !TREE_USED (decl))\n+      /* What we would really like to do here is to filter out all mere\n+\t file-scope declarations of file-scope functions which are never\n+\t referenced later within this translation unit (and keep all of\n+\t ones that *are* referenced later on) but we aren't clarvoiant,\n+\t so we have no idea which functions will be referenced in the\n+\t future (i.e. later on within the current translation unit).\n+\t So here we just ignore all file-scope function declarations\n+\t which are not also definitions.  If and when the debugger needs\n+\t to know something about these funcstion, it wil have to hunt\n+\t around and find the DWARF information associated with the\n+\t *definition* of the function.\n+\n+\t Note that we can't just check `DECL_EXTERNAL' to find out which\n+\t FUNCTION_DECL nodes represent definitions and which ones represent\n+\t mere declarations.  We have to check `DECL_INITIAL' instead.  That's\n+\t because the C front-end supports some weird semantics for \"extern\n+\t inline\" function definitions.  These can get inlined within the\n+\t current translation unit (an thus, we need to generate DWARF info\n+\t for their abstract instances so that the DWARF info for the\n+\t concrete inlined instances can have something to refer to) but\n+\t the compiler never generates any out-of-lines instances of such\n+\t things (despite the fact that they *are* definitions).  The\n+\t important point is that the C front-end marks these \"extern inline\"\n+\t functions as DECL_EXTERNAL, but we need to generate DWARf for them\n+\t anyway.\n+\n+\t Note that the C++ front-end also plays some similar games for inline\n+\t function definitions appearing within include files which also\n+\t contain `#pragma interface' pragmas.  */\n+\n+      if (DECL_INITIAL (decl) == NULL_TREE)\n \treturn;\n \n       if (TREE_PUBLIC (decl)"}]}