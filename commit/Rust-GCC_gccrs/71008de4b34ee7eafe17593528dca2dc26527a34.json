{"sha": "71008de4b34ee7eafe17593528dca2dc26527a34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwMDhkZTRiMzRlZTdlYWZlMTc1OTM1MjhkY2EyZGMyNjUyN2EzNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-16T02:09:03Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-16T02:09:03Z"}, "message": "re PR target/42235 (redundant memory move from parameter space to spill space)\n\n\tPR target/42235\n\t* function.c (record_hard_reg_sets): New static function.\n\t(assign_parm_setup_reg): If an optab for extending exists and the\n\tgenerated code clobbbers no hard regs, emit the insn directly and\n\tcreate a REG_EQUIV note.\n\nFrom-SVN: r162240", "tree": {"sha": "fca2df406b7642d903d53fd0e3a5ea8bcaddc821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fca2df406b7642d903d53fd0e3a5ea8bcaddc821"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71008de4b34ee7eafe17593528dca2dc26527a34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71008de4b34ee7eafe17593528dca2dc26527a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71008de4b34ee7eafe17593528dca2dc26527a34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71008de4b34ee7eafe17593528dca2dc26527a34/comments", "author": null, "committer": null, "parents": [{"sha": "f7587ed0d8089741a2eca0417aa618565d531596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7587ed0d8089741a2eca0417aa618565d531596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7587ed0d8089741a2eca0417aa618565d531596"}], "stats": {"total": 107, "additions": 97, "deletions": 10}, "files": [{"sha": "9e31ff0f762a2dca84f9eb9feb929a03208f0884", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71008de4b34ee7eafe17593528dca2dc26527a34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71008de4b34ee7eafe17593528dca2dc26527a34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71008de4b34ee7eafe17593528dca2dc26527a34", "patch": "@@ -1,3 +1,11 @@\n+2010-07-16  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/42235\n+\t* function.c (record_hard_reg_sets): New static function.\n+\t(assign_parm_setup_reg): If an optab for extending exists and the\n+\tgenerated code clobbbers no hard regs, emit the insn directly and\n+\tcreate a REG_EQUIV note.\n+\n 2010-07-15  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* c-decl.c (detect_field_duplicates): Use DECL_CHAIN insted of"}, {"sha": "74672c38249ceb7770742b8a2c75d8ee07c44590", "filename": "gcc/function.c", "status": "modified", "additions": 89, "deletions": 10, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71008de4b34ee7eafe17593528dca2dc26527a34/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71008de4b34ee7eafe17593528dca2dc26527a34/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=71008de4b34ee7eafe17593528dca2dc26527a34", "patch": "@@ -2854,17 +2854,34 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n   SET_DECL_RTL (parm, stack_parm);\n }\n \n+/* A subroutine of assign_parm_setup_reg, called through note_stores.\n+   This collects sets and clobbers of hard registers in a HARD_REG_SET,\n+   which is pointed to by DATA.  */\n+static void\n+record_hard_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  HARD_REG_SET *pset = (HARD_REG_SET *)data;\n+  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    {\n+      int nregs = hard_regno_nregs[REGNO (x)][GET_MODE (x)];\n+      while (nregs-- > 0)\n+\tSET_HARD_REG_BIT (*pset, REGNO (x) + nregs);\n+    }\n+}\n+\n /* A subroutine of assign_parms.  Allocate a pseudo to hold the current\n    parameter.  Get it there.  Perform all ABI specified conversions.  */\n \n static void\n assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t\t       struct assign_parm_data_one *data)\n {\n-  rtx parmreg;\n+  rtx parmreg, validated_mem;\n+  rtx equiv_stack_parm;\n   enum machine_mode promoted_nominal_mode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (parm));\n   bool did_conversion = false;\n+  bool need_conversion, moved;\n \n   /* Store the parm in a pseudoregister during the function, but we may\n      need to do it in a wider mode.  Using 2 here makes the result\n@@ -2893,11 +2910,16 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n   /* Copy the value into the register, thus bridging between\n      assign_parm_find_data_types and expand_expr_real_1.  */\n-  if (data->nominal_mode != data->passed_mode\n-      || promoted_nominal_mode != data->promoted_mode)\n-    {\n-      int save_tree_used;\n \n+  equiv_stack_parm = data->stack_parm;\n+  validated_mem = validize_mem (data->entry_parm);\n+\n+  need_conversion = (data->nominal_mode != data->passed_mode\n+\t\t     || promoted_nominal_mode != data->promoted_mode);\n+  moved = false;\n+\n+  if (need_conversion)\n+    {\n       /* ENTRY_PARM has been converted to PROMOTED_MODE, its\n \t mode, by the caller.  We now have to convert it to\n \t NOMINAL_MODE, if different.  However, PARMREG may be in\n@@ -2913,13 +2935,70 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n \t In addition, the conversion may involve a call, which could\n \t clobber parameters which haven't been copied to pseudo\n-\t registers yet.  Therefore, we must first copy the parm to\n-\t a pseudo reg here, and save the conversion until after all\n+\t registers yet.\n+\n+\t First, we try to emit an insn which performs the necessary\n+\t conversion.  We verify that this insn does not clobber any\n+\t hard registers.  */\n+\n+      enum insn_code icode;\n+      rtx op0, op1;\n+\n+      icode = can_extend_p (promoted_nominal_mode, data->passed_mode,\n+\t\t\t    unsignedp);\n+\n+      op0 = parmreg;\n+      op1 = validated_mem;\n+      if (icode != CODE_FOR_nothing\n+\t  && insn_data[icode].operand[0].predicate (op0, promoted_nominal_mode)\n+\t  && insn_data[icode].operand[1].predicate (op1, data->passed_mode))\n+\t{\n+\t  enum rtx_code code = unsignedp ? ZERO_EXTEND : SIGN_EXTEND;\n+\t  rtx insn, insns;\n+\t  HARD_REG_SET hardregs;\n+\n+\t  start_sequence ();\n+\t  insn = gen_extend_insn (op0, op1, promoted_nominal_mode,\n+\t\t\t\t  data->passed_mode, unsignedp);\n+\t  emit_insn (insn);\n+\t  insns = get_insns ();\n+\n+\t  moved = true;\n+\t  CLEAR_HARD_REG_SET (hardregs);\n+\t  for (insn = insns; insn && moved; insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (INSN_P (insn))\n+\t\tnote_stores (PATTERN (insn), record_hard_reg_sets,\n+\t\t\t     &hardregs);\n+\t      if (!hard_reg_set_empty_p (hardregs))\n+\t\tmoved = false;\n+\t    }\n+\n+\t  end_sequence ();\n+\n+\t  if (moved)\n+\t    {\n+\t      emit_insn (insns);\n+\t      equiv_stack_parm = gen_rtx_fmt_e (code, GET_MODE (parmreg),\n+\t\t\t\t\t\tequiv_stack_parm);\n+\t    }\n+\t}\n+    }\n+\n+  if (moved)\n+    /* Nothing to do.  */\n+    ;\n+  else if (need_conversion)\n+    {\n+      /* We did not have an insn to convert directly, or the sequence\n+\t generated appeared unsafe.  We must first copy the parm to a\n+\t pseudo reg, and save the conversion until after all\n \t parameters have been moved.  */\n \n+      int save_tree_used;\n       rtx tempreg = gen_reg_rtx (GET_MODE (data->entry_parm));\n \n-      emit_move_insn (tempreg, validize_mem (data->entry_parm));\n+      emit_move_insn (tempreg, validated_mem);\n \n       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);\n       tempreg = convert_to_mode (data->nominal_mode, tempreg, unsignedp);\n@@ -2949,7 +3028,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n       did_conversion = true;\n     }\n   else\n-    emit_move_insn (parmreg, validize_mem (data->entry_parm));\n+    emit_move_insn (parmreg, validated_mem);\n \n   /* If we were passed a pointer but the actual value can safely live\n      in a register, put it in one.  */\n@@ -3034,7 +3113,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t}\n       else if ((set = single_set (linsn)) != 0\n \t       && SET_DEST (set) == parmreg)\n-\tset_unique_reg_note (linsn, REG_EQUIV, data->stack_parm);\n+\tset_unique_reg_note (linsn, REG_EQUIV, equiv_stack_parm);\n     }\n \n   /* For pointer data type, suggest pointer register.  */"}]}