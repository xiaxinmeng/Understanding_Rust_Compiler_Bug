{"sha": "1f4eb0e985e71a20e5778963cf98e591054dd51b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY0ZWIwZTk4NWU3MWEyMGU1Nzc4OTYzY2Y5OGU1OTEwNTRkZDUxYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-26T19:56:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-26T19:56:25Z"}, "message": "cgraph.c (cgraph_update_edges_for_call_stmt_node): Do not bring dead calls back to live.\n\n\n\t* cgraph.c (cgraph_update_edges_for_call_stmt_node): Do not bring\n\tdead calls back to live.\n\t(cgraph_edge::verify_count_and_frequency): Move cgraph/cfg frequency\n\tcross check to ...\n\t(cgraph_node::verify_node): ... here; verify only callee edges,\n\tnot caller.\n\nFrom-SVN: r221707", "tree": {"sha": "b2926b95a08345ab4f4ab5ea78f628f989ec25e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2926b95a08345ab4f4ab5ea78f628f989ec25e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f4eb0e985e71a20e5778963cf98e591054dd51b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f4eb0e985e71a20e5778963cf98e591054dd51b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f4eb0e985e71a20e5778963cf98e591054dd51b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f4eb0e985e71a20e5778963cf98e591054dd51b/comments", "author": null, "committer": null, "parents": [{"sha": "5058c037581a2015d2e2ea86c50628dcde72f646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5058c037581a2015d2e2ea86c50628dcde72f646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5058c037581a2015d2e2ea86c50628dcde72f646"}], "stats": {"total": 78, "additions": 57, "deletions": 21}, "files": [{"sha": "896477060efa85f8e27706500d1584a1823b1052", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4eb0e985e71a20e5778963cf98e591054dd51b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4eb0e985e71a20e5778963cf98e591054dd51b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f4eb0e985e71a20e5778963cf98e591054dd51b", "patch": "@@ -1,3 +1,12 @@\n+2015-03-26  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_update_edges_for_call_stmt_node): Do not bring\n+\tdead calls back to live.\n+\t(cgraph_edge::verify_count_and_frequency): Move cgraph/cfg frequency\n+\tcross check to ...\n+\t(cgraph_node::verify_node): ... here; verify only callee edges,\n+\tnot caller.\n+\n 2015-03-26  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline-analysis.c (redirect_to_unreachable): New function."}, {"sha": "0d2b826a5e7c9912a27571280b59739fa5bd6dd7", "filename": "gcc/cgraph.c", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f4eb0e985e71a20e5778963cf98e591054dd51b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f4eb0e985e71a20e5778963cf98e591054dd51b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1f4eb0e985e71a20e5778963cf98e591054dd51b", "patch": "@@ -1515,6 +1515,15 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \n       if (e)\n \t{\n+\t  /* Keep calls marked as dead dead.  */\n+\t  if (e->callee\n+\t      && DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_UNREACHABLE)\n+\t    {\n+              node->get_edge (old_stmt)->set_call_stmt\n+\t\t (as_a <gcall *> (new_stmt));\n+\t      return;\n+\t    }\n \t  /* See if the edge is already there and has the correct callee.  It\n \t     might be so because of indirect inlining has already updated\n \t     it.  We also might've cloned and redirected the edge.  */\n@@ -2661,25 +2670,6 @@ cgraph_edge::verify_count_and_frequency ()\n       error (\"caller edge frequency is too large\");\n       error_found = true;\n     }\n-  if (gimple_has_body_p (caller->decl)\n-      && !caller->global.inlined_to\n-      && !speculative\n-      /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n-\t Remove this once edges are actually removed from the function at that time.  */\n-      && (frequency\n-\t  || (inline_edge_summary_vec.exists ()\n-\t      && ((inline_edge_summary_vec.length () <= (unsigned) uid)\n-\t          || !inline_edge_summary (this)->predicate)))\n-      && (frequency\n-\t  != compute_call_stmt_bb_frequency (caller->decl,\n-\t\t\t\t\t     gimple_bb (call_stmt))))\n-    {\n-      error (\"caller edge frequency %i does not match BB frequency %i\",\n-\t     frequency,\n-\t     compute_call_stmt_bb_frequency (caller->decl,\n-\t\t\t\t\t     gimple_bb (call_stmt)));\n-      error_found = true;\n-    }\n   return error_found;\n }\n \n@@ -2848,9 +2838,46 @@ cgraph_node::verify_node (void)\n \t    error_found = true;\n \t  }\n     }\n+  for (e = callees; e; e = e->next_callee)\n+    {\n+      if (e->verify_count_and_frequency ())\n+\terror_found = true;\n+      if (gimple_has_body_p (e->caller->decl)\n+\t  && !e->caller->global.inlined_to\n+\t  && !e->speculative\n+\t  /* Optimized out calls are redirected to __builtin_unreachable.  */\n+\t  && (e->frequency\n+\t      || e->callee->decl\n+\t\t != builtin_decl_implicit (BUILT_IN_UNREACHABLE))\n+\t  && (e->frequency\n+\t      != compute_call_stmt_bb_frequency (e->caller->decl,\n+\t\t\t\t\t\t gimple_bb (e->call_stmt))))\n+\t{\n+\t  error (\"caller edge frequency %i does not match BB frequency %i\",\n+\t\t e->frequency,\n+\t\t compute_call_stmt_bb_frequency (e->caller->decl,\n+\t\t\t\t\t\t gimple_bb (e->call_stmt)));\n+\t  error_found = true;\n+\t}\n+    }\n   for (e = indirect_calls; e; e = e->next_callee)\n-    if (e->verify_count_and_frequency ())\n-      error_found = true;\n+    {\n+      if (e->verify_count_and_frequency ())\n+\terror_found = true;\n+      if (gimple_has_body_p (e->caller->decl)\n+\t  && !e->caller->global.inlined_to\n+\t  && !e->speculative\n+\t  && (e->frequency\n+\t      != compute_call_stmt_bb_frequency (e->caller->decl,\n+\t\t\t\t\t\t gimple_bb (e->call_stmt))))\n+\t{\n+\t  error (\"indirect call frequency %i does not match BB frequency %i\",\n+\t\t e->frequency,\n+\t\t compute_call_stmt_bb_frequency (e->caller->decl,\n+\t\t\t\t\t\t gimple_bb (e->call_stmt)));\n+\t  error_found = true;\n+\t}\n+    }\n   if (!callers && global.inlined_to)\n     {\n       error (\"inlined_to pointer is set but no predecessors found\");"}]}