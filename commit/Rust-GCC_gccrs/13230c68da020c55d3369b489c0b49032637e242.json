{"sha": "13230c68da020c55d3369b489c0b49032637e242", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMyMzBjNjhkYTAyMGM1NWQzMzY5YjQ4OWMwYjQ5MDMyNjM3ZTI0Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:27:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:27:01Z"}, "message": "[multiple changes]\n\n2017-01-23  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* checks.adb: Minor fix in comment.\n\n2017-01-23  Philippe Gil  <gil@adacore.com>\n\n\t* g-debpoo.adb (Do_Report) remove freed chunks from chunks\n\tcount in Sort = Memory_Usage or Allocations_Count\n\n2017-01-23  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch3.adb: Code cleanup.\n\n2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Move all global\n\tvariables to the local variable section. Update the profile\n\tof various nested routine that previously had visibility\n\tof those globals. One the matching phase has completed,\n\tremove certain classes of clauses which are considered noise.\n\t(Check_Dependency_Clause): Properly detect a match between two\n\t'Result attributes. Update the various post-match cases to use\n\tIs_Already_Matched as this routine now automatically recognizes\n\ta previously matched 'Result attribute.\n\t(Is_Already_Matched): New routine.\n\t(Remove_Extra_Clauses): New routine.\n\t(Report_Extra_Clauses): Remove the detection of ... => null\n\tclauses as this is now done in Remove_Extra_Clauses.\n\nFrom-SVN: r244782", "tree": {"sha": "8cdc249dd45beb4e3f181872744f6515019607d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cdc249dd45beb4e3f181872744f6515019607d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13230c68da020c55d3369b489c0b49032637e242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13230c68da020c55d3369b489c0b49032637e242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13230c68da020c55d3369b489c0b49032637e242", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13230c68da020c55d3369b489c0b49032637e242/comments", "author": null, "committer": null, "parents": [{"sha": "0d1e3cc99536b30a6eec4b3cb373cfc6bbafebd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d1e3cc99536b30a6eec4b3cb373cfc6bbafebd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d1e3cc99536b30a6eec4b3cb373cfc6bbafebd5"}], "stats": {"total": 483, "additions": 347, "deletions": 136}, "files": [{"sha": "72ba34ba215a62776c208eaa923aa2fe40e2f948", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=13230c68da020c55d3369b489c0b49032637e242", "patch": "@@ -1,3 +1,32 @@\n+2017-01-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb: Minor fix in comment.\n+\n+2017-01-23  Philippe Gil  <gil@adacore.com>\n+\n+\t* g-debpoo.adb (Do_Report) remove freed chunks from chunks\n+\tcount in Sort = Memory_Usage or Allocations_Count\n+\n+2017-01-23  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch3.adb: Code cleanup.\n+\n+2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Refined_Depends_In_Decl_Part): Move all global\n+\tvariables to the local variable section. Update the profile\n+\tof various nested routine that previously had visibility\n+\tof those globals. One the matching phase has completed,\n+\tremove certain classes of clauses which are considered noise.\n+\t(Check_Dependency_Clause): Properly detect a match between two\n+\t'Result attributes. Update the various post-match cases to use\n+\tIs_Already_Matched as this routine now automatically recognizes\n+\ta previously matched 'Result attribute.\n+\t(Is_Already_Matched): New routine.\n+\t(Remove_Extra_Clauses): New routine.\n+\t(Report_Extra_Clauses): Remove the detection of ... => null\n+\tclauses as this is now done in Remove_Extra_Clauses.\n+\n 2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_aggr.adb (Resolve_Array_Aggregate): In ASIS mode do not"}, {"sha": "7f4a5894696b5097b17504a74a866fa4562efa6f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=13230c68da020c55d3369b489c0b49032637e242", "patch": "@@ -826,10 +826,10 @@ package body Checks is\n    -- Apply_Arithmetic_Overflow_Strict --\n    --------------------------------------\n \n-   --  This routine is called only if the type is an integer type, and a\n-   --  software arithmetic overflow check may be needed for op (add, subtract,\n-   --  or multiply). This check is performed only if Software_Overflow_Checking\n-   --  is enabled and Do_Overflow_Check is set. In this case we expand the\n+   --  This routine is called only if the type is an integer type and an\n+   --  arithmetic overflow check may be needed for op (add, subtract, or\n+   --  multiply). This check is performed if Backend_Overflow_Checks_On_Target\n+   --  is not enabled and Do_Overflow_Check is set. In this case we expand the\n    --  operation into a more complex sequence of tests that ensures that\n    --  overflow is properly caught.\n "}, {"sha": "9f8d57cd7271826c2a9369a4af214b1ea4fc67b6", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=13230c68da020c55d3369b489c0b49032637e242", "patch": "@@ -2028,14 +2028,23 @@ package body GNAT.Debug_Pools is\n \n                P := Percent (100.0 * Float (Total) / Grand_Total);\n \n-               if Sort = Marked_Blocks then\n-                  Put (P'Img & \"%:\"\n-                       & Max (M).Count'Img & \" chunks /\"\n-                       & Integer (Grand_Total)'Img & \" at\");\n-               else\n-                  Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n-                       & Max (M).Count'Img & \" chunks at\");\n-               end if;\n+               case Sort is\n+                  when Memory_Usage | Allocations_Count | All_Reports =>\n+                     declare\n+                        Count : constant Natural :=\n+                          Max (M).Count - Max (M).Frees;\n+                     begin\n+                        Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n+                             & Count'Img & \" chunks at\");\n+                     end;\n+                  when Sort_Total_Allocs =>\n+                     Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n+                          & Max (M).Count'Img & \" chunks at\");\n+                  when Marked_Blocks =>\n+                     Put (P'Img & \"%:\"\n+                          & Max (M).Count'Img & \" chunks /\"\n+                          & Integer (Grand_Total)'Img & \" at\");\n+               end case;\n             end;\n \n             for J in Max (M).Traceback'Range loop"}, {"sha": "e1b73538b5400b9d17f577868b370904079d1da4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=13230c68da020c55d3369b489c0b49032637e242", "patch": "@@ -2634,10 +2634,12 @@ package body Sem_Ch3 is\n \n          elsif not Analyzed (Next_Decl) and then Is_Body (Next_Decl) then\n \n-            --  If there is an array type that uses a private type from an\n-            --  enclosing package which is in the same scope as an expression\n-            --  function that is not a completion then we cannot freeze here.\n-            --  So identify the case here and delay freezing.\n+            --  Check for an edge case that may cause premature freezing of a\n+            --  private type.\n+\n+            --  If there is an array type which uses a private type from an\n+            --  enclosing package that is in the same scope as a non-completing\n+            --  expression function then we cannot freeze here.\n \n             Ignore_Freezing := False;\n \n@@ -2646,9 +2648,9 @@ package body Sem_Ch3 is\n               and then not Is_Compilation_Unit (Current_Scope)\n               and then not Is_Generic_Instance (Current_Scope)\n             then\n-\n                --  Loop through all entities in the current scope to identify\n-               --  an instance of the edge case outlined above.\n+               --  an instance of the edge-case outlined above and ignore\n+               --  freezeing if it is detected.\n \n                declare\n                   Curr : Entity_Id := First_Entity (Current_Scope);\n@@ -2691,7 +2693,8 @@ package body Sem_Ch3 is\n                --  ??? A cleaner approach may be possible and/or this solution\n                --  could be extended to general-purpose late primitives, TBD.\n \n-               if not ASIS_Mode and then not Body_Seen\n+               if not ASIS_Mode\n+                 and then not Body_Seen\n                  and then not Is_Body (Decl)\n                then\n                   Body_Seen := True;"}, {"sha": "c44c2ab7ff27bb1dfd93aa4fcf3f35eaad2bfbc0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 287, "deletions": 117, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13230c68da020c55d3369b489c0b49032637e242/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=13230c68da020c55d3369b489c0b49032637e242", "patch": "@@ -23772,45 +23772,35 @@ package body Sem_Prag is\n    ------------------------------------------\n \n    procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id) is\n-      Body_Inputs  : Elist_Id := No_Elist;\n-      Body_Outputs : Elist_Id := No_Elist;\n-      --  The inputs and outputs of the subprogram body synthesized from pragma\n-      --  Refined_Depends.\n-\n-      Dependencies : List_Id := No_List;\n-      Depends      : Node_Id;\n-      --  The corresponding Depends pragma along with its clauses\n-\n-      Matched_Items : Elist_Id := No_Elist;\n-      --  A list containing the entities of all successfully matched items\n-      --  found in pragma Depends.\n-\n-      Refinements : List_Id := No_List;\n-      --  The clauses of pragma Refined_Depends\n-\n-      Spec_Id : Entity_Id;\n-      --  The entity of the subprogram subject to pragma Refined_Depends\n-\n-      Spec_Inputs  : Elist_Id := No_Elist;\n-      Spec_Outputs : Elist_Id := No_Elist;\n-      --  The inputs and outputs of the subprogram spec synthesized from pragma\n-      --  Depends.\n-\n       procedure Check_Dependency_Clause\n-        (States     : Elist_Id;\n-         Dep_Clause : Node_Id);\n+        (Spec_Id       : Entity_Id;\n+         Dep_Clause    : Node_Id;\n+         Dep_States    : Elist_Id;\n+         Refinements   : List_Id;\n+         Matched_Items : in out Elist_Id);\n       --  Try to match a single dependency clause Dep_Clause against one or\n       --  more refinement clauses found in list Refinements. Each successful\n       --  match eliminates at least one refinement clause from Refinements.\n-      --  States is a list of states appearing in dependencies obtained by\n-      --  calling Get_States_Seen.\n-\n-      procedure Check_Output_States;\n+      --  Spec_Id denotes the entity of the related subprogram. Dep_States\n+      --  denotes the entities of all abstract states which appear in pragma\n+      --  Depends. Matched_Items contains the entities of all successfully\n+      --  matched items found in pragma Depends.\n+\n+      procedure Check_Output_States\n+        (Spec_Id      : Entity_Id;\n+         Spec_Inputs  : Elist_Id;\n+         Spec_Outputs : Elist_Id;\n+         Body_Inputs  : Elist_Id;\n+         Body_Outputs : Elist_Id);\n       --  Determine whether pragma Depends contains an output state with a\n       --  visible refinement and if so, ensure that pragma Refined_Depends\n-      --  mentions all its constituents as outputs.\n+      --  mentions all its constituents as outputs. Spec_Id is the entity of\n+      --  the related subprograms. Spec_Inputs and Spec_Outputs denote the\n+      --  inputs and outputs of the subprogram spec synthesized from pragma\n+      --  Depends. Body_Inputs and Body_Outputs denote the inputs and outputs\n+      --  of the subprogram body synthesized from pragma Refined_Depends.\n \n-      function Get_States_Seen (Dependencies : List_Id) return Elist_Id;\n+      function Collect_States (Clauses : List_Id) return Elist_Id;\n       --  Given a normalized list of dependencies obtained from calling\n       --  Normalize_Clauses, return a list containing the entities of all\n       --  states appearing in dependencies. It helps in checking refinements\n@@ -23822,20 +23812,38 @@ package body Sem_Prag is\n       --  each clause by creating multiple dependencies with exactly one input\n       --  and one output.\n \n-      procedure Report_Extra_Clauses;\n-      --  Emit an error for each extra clause found in list Refinements\n+      procedure Remove_Extra_Clauses\n+        (Clauses       : List_Id;\n+         Matched_Items : Elist_Id);\n+      --  Given a list of refinement clauses Clauses, remove all clauses whose\n+      --  inputs and/or outputs have been previously matched. See the body for\n+      --  all special cases. Matched_Items contains the entities of all matched\n+      --  items found in pragma Depends.\n+\n+      procedure Report_Extra_Clauses\n+        (Spec_Id : Entity_Id;\n+         Clauses : List_Id);\n+      --  Emit an error for each extra clause found in list Clauses. Spec_Id\n+      --  denotes the entity of the related subprogram.\n \n       -----------------------------\n       -- Check_Dependency_Clause --\n       -----------------------------\n \n       procedure Check_Dependency_Clause\n-        (States     : Elist_Id;\n-         Dep_Clause : Node_Id)\n+        (Spec_Id       : Entity_Id;\n+         Dep_Clause    : Node_Id;\n+         Dep_States    : Elist_Id;\n+         Refinements   : List_Id;\n+         Matched_Items : in out Elist_Id)\n       is\n          Dep_Input  : constant Node_Id := Expression (Dep_Clause);\n          Dep_Output : constant Node_Id := First (Choices (Dep_Clause));\n \n+         function Is_Already_Matched (Dep_Item : Node_Id) return Boolean;\n+         --  Determine whether dependency item Dep_Item has been matched in a\n+         --  previous clause.\n+\n          function Is_In_Out_State_Clause return Boolean;\n          --  Determine whether dependence clause Dep_Clause denotes an abstract\n          --  state that depends on itself (State => State).\n@@ -23874,6 +23882,28 @@ package body Sem_Prag is\n          procedure Record_Item (Item_Id : Entity_Id);\n          --  Store the entity of an item denoted by Item_Id in Matched_Items\n \n+         ------------------------\n+         -- Is_Already_Matched --\n+         ------------------------\n+\n+         function Is_Already_Matched (Dep_Item : Node_Id) return Boolean is\n+            Item_Id : Entity_Id := Empty;\n+\n+         begin\n+            --  When the dependency item denotes attribute 'Result, check for\n+            --  the entity of the related subprogram.\n+\n+            if Is_Attribute_Result (Dep_Item) then\n+               Item_Id := Spec_Id;\n+\n+            elsif Is_Entity_Name (Dep_Item) then\n+               Item_Id := Available_View (Entity_Of (Dep_Item));\n+            end if;\n+\n+            return\n+              Present (Item_Id) and then Contains (Matched_Items, Item_Id);\n+         end Is_Already_Matched;\n+\n          ----------------------------\n          -- Is_In_Out_State_Clause --\n          ----------------------------\n@@ -23950,9 +23980,14 @@ package body Sem_Prag is\n \n             --  Attribute 'Result matches attribute 'Result\n \n-            --  ??? this is incorrect, Ref_Item should be checked as well\n+            elsif Is_Attribute_Result (Dep_Item)\n+              and then Is_Attribute_Result (Ref_Item)\n+            then\n+               --  Put the entity of the related function on the list of\n+               --  matched items because attribute 'Result does not carry\n+               --  an entity similar to states and constituents.\n \n-            elsif Is_Attribute_Result (Dep_Item) then\n+               Record_Item (Spec_Id);\n                Matched := True;\n \n             --  Abstract states, current instances of concurrent types,\n@@ -23988,7 +24023,7 @@ package body Sem_Prag is\n                                                   E_Variable)\n                           and then Present (Encapsulating_State (Ref_Item_Id))\n                           and then Find_Encapsulating_State\n-                                     (States, Ref_Item_Id) = Dep_Item_Id\n+                                     (Dep_States, Ref_Item_Id) = Dep_Item_Id\n                         then\n                            Record_Item (Dep_Item_Id);\n                            Matched := True;\n@@ -24029,9 +24064,11 @@ package body Sem_Prag is\n \n          procedure Record_Item (Item_Id : Entity_Id) is\n          begin\n-            if not Contains (Matched_Items, Item_Id) then\n-               Append_New_Elmt (Item_Id, Matched_Items);\n+            if No (Matched_Items) then\n+               Matched_Items := New_Elmt_List;\n             end if;\n+\n+            Append_Unique_Elmt (Item_Id, Matched_Items);\n          end Record_Item;\n \n          --  Local variables\n@@ -24130,8 +24167,8 @@ package body Sem_Prag is\n          --  Depending on the order or composition of refinement clauses, an\n          --  In_Out state clause may not be directly refinable.\n \n-         --    Depends         => ((Output, State) => (Input, State))\n          --    Refined_State   => (State => (Constit_1, Constit_2))\n+         --    Depends         => ((Output, State) => (Input, State))\n          --    Refined_Depends => (Constit_1 => Input, Output => Constit_2)\n \n          --  Matching normalized clause (State => State) fails because there is\n@@ -24143,25 +24180,24 @@ package body Sem_Prag is\n \n          if not Clause_Matched\n            and then Is_In_Out_State_Clause\n-           and then\n-             Contains (Matched_Items, Available_View (Entity_Of (Dep_Input)))\n+           and then Is_Already_Matched (Dep_Input)\n          then\n             Clause_Matched := True;\n          end if;\n \n          --  A clause where the input is an abstract state with visible null\n-         --  refinement is implicitly matched when the output has already been\n-         --  matched in a previous clause.\n+         --  refinement or a 'Result attribute is implicitly matched when the\n+         --  output has already been matched in a previous clause.\n \n-         --    Depends         => (Output => State)  --  implicitly OK\n          --    Refined_State   => (State => null)\n+         --    Depends         => (Output => State)      --  implicitly OK\n          --    Refined_Depends => (Output => ...)\n+         --    Depends         => (...'Result => State)  --  implicitly OK\n+         --    Refined_Depends => (...'Result => ...)\n \n          if not Clause_Matched\n            and then Is_Null_Refined_State (Dep_Input)\n-           and then Is_Entity_Name (Dep_Output)\n-           and then\n-             Contains (Matched_Items, Available_View (Entity_Of (Dep_Output)))\n+           and then Is_Already_Matched (Dep_Output)\n          then\n             Clause_Matched := True;\n          end if;\n@@ -24170,15 +24206,13 @@ package body Sem_Prag is\n          --  refinement is implicitly matched when the input has already been\n          --  matched in a previous clause.\n \n-         --    Depends           => (State => Input)  --  implicitly OK\n          --    Refined_State     => (State => null)\n+         --    Depends           => (State => Input)  --  implicitly OK\n          --    Refined_Depends   => (... => Input)\n \n          if not Clause_Matched\n            and then Is_Null_Refined_State (Dep_Output)\n-           and then Is_Entity_Name (Dep_Input)\n-           and then\n-             Contains (Matched_Items, Available_View (Entity_Of (Dep_Input)))\n+           and then Is_Already_Matched (Dep_Input)\n          then\n             Clause_Matched := True;\n          end if;\n@@ -24187,8 +24221,8 @@ package body Sem_Prag is\n          --  pragma Refined_Depends contains a solitary null. Only an abstract\n          --  state with null refinement can possibly match these cases.\n \n-         --    Depends         => (State => null)\n          --    Refined_State   => (State => null)\n+         --    Depends         => (State => null)\n          --    Refined_Depends =>  null            --  OK\n \n          if not Clause_Matched then\n@@ -24220,7 +24254,13 @@ package body Sem_Prag is\n       -- Check_Output_States --\n       -------------------------\n \n-      procedure Check_Output_States is\n+      procedure Check_Output_States\n+        (Spec_Id      : Entity_Id;\n+         Spec_Inputs  : Elist_Id;\n+         Spec_Outputs : Elist_Id;\n+         Body_Inputs  : Elist_Id;\n+         Body_Outputs : Elist_Id)\n+      is\n          procedure Check_Constituent_Usage (State_Id : Entity_Id);\n          --  Determine whether all constituents of state State_Id with full\n          --  visible refinement are used as outputs in pragma Refined_Depends.\n@@ -24350,54 +24390,63 @@ package body Sem_Prag is\n          end if;\n       end Check_Output_States;\n \n-      ---------------------\n-      -- Get_States_Seen --\n-      ---------------------\n-\n-      function Get_States_Seen (Dependencies : List_Id) return Elist_Id is\n-         States_Seen : Elist_Id := No_Elist;\n+      --------------------\n+      -- Collect_States --\n+      --------------------\n \n-         procedure Get_State (Glob_Item : Node_Id);\n-         --  Add global item to States_Seen when it corresponds to a state\n+      function Collect_States (Clauses : List_Id) return Elist_Id is\n+         procedure Collect_State\n+           (Item   : Node_Id;\n+            States : in out Elist_Id);\n+         --  Add the entity of Item to list States when it denotes to a state\n \n-         ---------------\n-         -- Get_State --\n-         ---------------\n+         -------------------\n+         -- Collect_State --\n+         -------------------\n \n-         procedure Get_State (Glob_Item : Node_Id) is\n+         procedure Collect_State\n+           (Item   : Node_Id;\n+            States : in out Elist_Id)\n+         is\n             Id : Entity_Id;\n+\n          begin\n-            if Is_Entity_Name (Glob_Item) then\n-               Id := Entity_Of (Glob_Item);\n+            if Is_Entity_Name (Item) then\n+               Id := Entity_Of (Item);\n \n                if Ekind (Id) = E_Abstract_State then\n-                  Append_New_Elmt (Id, States_Seen);\n+                  if No (States) then\n+                     States := New_Elmt_List;\n+                  end if;\n+\n+                  Append_Unique_Elmt (Id, States);\n                end if;\n             end if;\n-         end Get_State;\n+         end Collect_State;\n \n          --  Local variables\n \n-         Dep_Clause : Node_Id;\n-         Dep_Input  : Node_Id;\n-         Dep_Output : Node_Id;\n+         Clause : Node_Id;\n+         Input  : Node_Id;\n+         Output : Node_Id;\n+         States : Elist_Id := No_Elist;\n \n-      --  Start of processing for Get_States_Seen\n+      --  Start of processing for Collect_States\n \n       begin\n-         Dep_Clause := First (Dependencies);\n-         while Present (Dep_Clause) loop\n-            Dep_Input  := Expression (Dep_Clause);\n-            Dep_Output := First (Choices (Dep_Clause));\n+         Clause := First (Clauses);\n+         while Present (Clause) loop\n+            Input  := Expression (Clause);\n+            Output := First (Choices (Clause));\n \n-            Get_State (Dep_Input);\n-            Get_State (Dep_Output);\n+            Collect_State (Input,  States);\n+            Collect_State (Output, States);\n \n-            Next (Dep_Clause);\n+            Next (Clause);\n          end loop;\n \n-         return States_Seen;\n-      end Get_States_Seen;\n+         return States;\n+      end Collect_States;\n \n       -----------------------\n       -- Normalize_Clauses --\n@@ -24564,11 +24613,91 @@ package body Sem_Prag is\n          end loop;\n       end Normalize_Clauses;\n \n+      --------------------------\n+      -- Remove_Extra_Clauses --\n+      --------------------------\n+\n+      procedure Remove_Extra_Clauses\n+        (Clauses       : List_Id;\n+         Matched_Items : Elist_Id)\n+      is\n+         Clause      : Node_Id;\n+         Input       : Node_Id;\n+         Input_Id    : Entity_Id;\n+         Next_Clause : Node_Id;\n+         Output      : Node_Id;\n+         State_Id    : Entity_Id;\n+\n+      begin\n+         Clause := First (Clauses);\n+         while Present (Clause) loop\n+            Next_Clause := Next (Clause);\n+\n+            Input  := Expression (Clause);\n+            Output := First (Choices (Clause));\n+\n+            --  Recognize a clause of the form\n+\n+            --    null => Input\n+\n+            --  where Input is a constituent of a state which was already\n+            --  successfully matched. This clause must be removed because it\n+            --  simply indicates that some of the constituents of the state\n+            --  are not used.\n+\n+            --    Refined_State   => (State => (Constit_1, Constit_2))\n+            --    Depends         => (Output => State)\n+            --    Refined_Depends => ((Output => Constit_1),  --  State matched\n+            --                        (null => Constit_2))    --  OK\n+\n+            if Nkind (Output) = N_Null and then Is_Entity_Name (Input) then\n+\n+               --  Handle abstract views generated for limited with clauses\n+\n+               Input_Id := Available_View (Entity_Of (Input));\n+\n+               --  The input must be a constituent of a state\n+\n+               if Ekind_In (Input_Id, E_Abstract_State,\n+                                      E_Constant,\n+                                      E_Variable)\n+                 and then Present (Encapsulating_State (Input_Id))\n+               then\n+                  State_Id := Encapsulating_State (Input_Id);\n+\n+                  --  The state must have a non-null visible refinement and be\n+                  --  matched in a previous clause.\n+\n+                  if Has_Non_Null_Visible_Refinement (State_Id)\n+                    and then Contains (Matched_Items, State_Id)\n+                  then\n+                     Remove (Clause);\n+                  end if;\n+               end if;\n+\n+            --  Recognize a clause of the form\n+\n+            --    Output => null\n+\n+            --  where Output is an arbitrary item. This clause must be removed\n+            --  because a null input legitimately matches anything.\n+\n+            elsif Nkind (Input) = N_Null then\n+               Remove (Clause);\n+            end if;\n+\n+            Clause := Next_Clause;\n+         end loop;\n+      end Remove_Extra_Clauses;\n+\n       --------------------------\n       -- Report_Extra_Clauses --\n       --------------------------\n \n-      procedure Report_Extra_Clauses is\n+      procedure Report_Extra_Clauses\n+        (Spec_Id : Entity_Id;\n+         Clauses : List_Id)\n+      is\n          Clause : Node_Id;\n \n       begin\n@@ -24578,23 +24707,12 @@ package body Sem_Prag is\n          if Is_Generic_Instance (Spec_Id) then\n             null;\n \n-         elsif Present (Refinements) then\n-            Clause := First (Refinements);\n+         elsif Present (Clauses) then\n+            Clause := First (Clauses);\n             while Present (Clause) loop\n-\n-               --  Do not complain about a null input refinement, since a null\n-               --  input legitimately matches anything.\n-\n-               if Nkind (Clause) = N_Component_Association\n-                 and then Nkind (Expression (Clause)) = N_Null\n-               then\n-                  null;\n-\n-               else\n-                  SPARK_Msg_N\n-                    (\"unmatched or extra clause in dependence refinement\",\n-                     Clause);\n-               end if;\n+               SPARK_Msg_N\n+                 (\"unmatched or extra clause in dependence refinement\",\n+                  Clause);\n \n                Next (Clause);\n             end loop;\n@@ -24606,9 +24724,39 @@ package body Sem_Prag is\n       Body_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Body_Id   : constant Entity_Id := Defining_Entity (Body_Decl);\n       Errors    : constant Nat       := Serious_Errors_Detected;\n-      Deps      : Node_Id;\n-      Dummy     : Boolean;\n-      Refs      : Node_Id;\n+\n+      Clause : Node_Id;\n+      Deps   : Node_Id;\n+      Dummy  : Boolean;\n+      Refs   : Node_Id;\n+\n+      Body_Inputs  : Elist_Id := No_Elist;\n+      Body_Outputs : Elist_Id := No_Elist;\n+      --  The inputs and outputs of the subprogram body synthesized from pragma\n+      --  Refined_Depends.\n+\n+      Dependencies : List_Id := No_List;\n+      Depends      : Node_Id;\n+      --  The corresponding Depends pragma along with its clauses\n+\n+      Matched_Items : Elist_Id := No_Elist;\n+      --  A list containing the entities of all successfully matched items\n+      --  found in pragma Depends.\n+\n+      Refinements : List_Id := No_List;\n+      --  The clauses of pragma Refined_Depends\n+\n+      Spec_Id : Entity_Id;\n+      --  The entity of the subprogram subject to pragma Refined_Depends\n+\n+      Spec_Inputs  : Elist_Id := No_Elist;\n+      Spec_Outputs : Elist_Id := No_Elist;\n+      --  The inputs and outputs of the subprogram spec synthesized from pragma\n+      --  Depends.\n+\n+      States : Elist_Id := No_Elist;\n+      --  A list containing the entities of all states whose constituents\n+      --  appear in pragma Depends.\n \n    --  Start of processing for Analyze_Refined_Depends_In_Decl_Part\n \n@@ -24690,7 +24838,12 @@ package body Sem_Prag is\n             --  For an output state with a visible refinement, ensure that all\n             --  constituents appear as outputs in the dependency refinement.\n \n-            Check_Output_States;\n+            Check_Output_States\n+              (Spec_Id      => Spec_Id,\n+               Spec_Inputs  => Spec_Inputs,\n+               Spec_Outputs => Spec_Outputs,\n+               Body_Inputs  => Body_Inputs,\n+               Body_Outputs => Body_Outputs);\n          end if;\n \n          --  Matching is disabled in ASIS because clauses are not normalized as\n@@ -24708,6 +24861,10 @@ package body Sem_Prag is\n          Dependencies := New_Copy_List_Tree (Component_Associations (Deps));\n          Normalize_Clauses (Dependencies);\n \n+         --  Gather all states which appear in Depends\n+\n+         States := Collect_States (Dependencies);\n+\n          Refs := Expression (Get_Argument (N, Spec_Id));\n \n          if Nkind (Refs) = N_Null then\n@@ -24727,20 +24884,33 @@ package body Sem_Prag is\n          --  and one input. Examine all clauses of pragma Depends looking for\n          --  matching clauses in pragma Refined_Depends.\n \n-         declare\n-            States_Seen : constant Elist_Id := Get_States_Seen (Dependencies);\n-            Clause      : Node_Id;\n+         Clause := First (Dependencies);\n+         while Present (Clause) loop\n+            Check_Dependency_Clause\n+              (Spec_Id       => Spec_Id,\n+               Dep_Clause    => Clause,\n+               Dep_States    => States,\n+               Refinements   => Refinements,\n+               Matched_Items => Matched_Items);\n \n-         begin\n-            Clause := First (Dependencies);\n-            while Present (Clause) loop\n-               Check_Dependency_Clause (States_Seen, Clause);\n-               Next (Clause);\n-            end loop;\n-         end;\n+            Next (Clause);\n+         end loop;\n+\n+         --  Pragma Refined_Depends may contain multiple clarification clauses\n+         --  which indicate that certain constituents do not influence the data\n+         --  flow in any way. Such clauses must be removed as long as the state\n+         --  has been matched, otherwise they will be incorrectly flagged as\n+         --  unmatched.\n+\n+         --    Refined_State   => (State => (Constit_1, Constit_2))\n+         --    Depends         => (Output => State)\n+         --    Refined_Depends => ((Output => Constit_1),  --  State matched\n+         --                        (null => Constit_2))    --  must be removed\n+\n+         Remove_Extra_Clauses (Refinements, Matched_Items);\n \n          if Serious_Errors_Detected = Errors then\n-            Report_Extra_Clauses;\n+            Report_Extra_Clauses (Spec_Id, Refinements);\n          end if;\n       end if;\n "}]}