{"sha": "a87104d913a70d59e0641e9a68a88f3cd8671b9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3MTA0ZDkxM2E3MGQ1OWUwNjQxZTlhNjhhODhmM2NkODY3MWI5ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-27T16:50:26Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-27T16:50:26Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r840", "tree": {"sha": "2a54fe412e812fad0c0da2879d7ef89f1ed16a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a54fe412e812fad0c0da2879d7ef89f1ed16a79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a87104d913a70d59e0641e9a68a88f3cd8671b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87104d913a70d59e0641e9a68a88f3cd8671b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87104d913a70d59e0641e9a68a88f3cd8671b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87104d913a70d59e0641e9a68a88f3cd8671b9d/comments", "author": null, "committer": null, "parents": [{"sha": "bec2e3595757d4d7d43972b78fc4eee87e1be753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec2e3595757d4d7d43972b78fc4eee87e1be753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec2e3595757d4d7d43972b78fc4eee87e1be753"}], "stats": {"total": 57, "additions": 53, "deletions": 4}, "files": [{"sha": "e1537d09e11ed66b5928e61cf7484d655cf2a376", "filename": "gcc/collect2.c", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a87104d913a70d59e0641e9a68a88f3cd8671b9d/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a87104d913a70d59e0641e9a68a88f3cd8671b9d/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=a87104d913a70d59e0641e9a68a88f3cd8671b9d", "patch": "@@ -168,6 +168,7 @@ extern char *version_string;\n \n static int vflag;\t\t\t/* true if -v */\n static int rflag;\t\t\t/* true if -r */\n+static int strip_flag;\t\t\t/* true if -s */\n \n static int debug;\t\t\t/* true if -debug */\n \n@@ -176,6 +177,7 @@ static char *temp_filename;\t\t/* Base of temp filenames */\n static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list. */\n static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list. */\n static char *nm_file_name;\t\t/* pathname of nm */\n+static char *strip_file_name;\t\t/* pathname of strip */\n \n static struct head constructors;\t/* list of constructors found */\n static struct head destructors;\t\t/* list of destructors found */\n@@ -465,7 +467,7 @@ main (argc, argv)\n   signal (SIGSEGV, handler);\n   signal (SIGBUS,  handler);\n \n-  /* Try to discover a valid linker/assembler/nm to use.  */\n+  /* Try to discover a valid linker/assembler/nm/strip to use.  */\n   len = strlen (argv[0]);\n   prefix = (char *)0;\n   if (len >= sizeof (\"ld\")-1)\n@@ -519,9 +521,12 @@ main (argc, argv)\n     clen = sizeof (STANDARD_EXEC_PREFIX) - 1;\n #endif\n \n+  /* Allocate enough string space for the longest possible pathnames.  */\n   ld_file_name = xcalloc (len + sizeof (\"real-ld\"), 1);\n   nm_file_name = xcalloc (len + sizeof (\"gnm\"), 1);\n+  strip_file_name = xcalloc (len + sizeof (\"gstrip\"), 1);\n \n+  /* Determine the full path name of the ld program to use.  */\n   memcpy (ld_file_name, prefix, len);\n   strcpy (ld_file_name + len, \"real-ld\");\n   if (access (ld_file_name, X_OK) < 0)\n@@ -533,11 +538,13 @@ main (argc, argv)\n #ifdef REAL_LD_FILE_NAME\n \t  ld_file_name = REAL_LD_FILE_NAME;\n #else\n-\t  ld_file_name = (access (\"/usr/bin/ld\", X_OK) == 0) ? \"/usr/bin/ld\" : \"/bin/ld\";\n+\t  ld_file_name = (access (\"/usr/bin/ld\", X_OK) == 0\n+\t\t\t  ? \"/usr/bin/ld\" : \"/bin/ld\");\n #endif\n \t}\n     }\n \n+  /* Determine the full path name of the C compiler to use.  */\n   c_file_name = getenv (\"COLLECT_GCC\");\n   if (c_file_name == 0 || c_file_name[0] != '/')\n     {\n@@ -564,6 +571,7 @@ main (argc, argv)\n \t}\n     }\n \n+  /* Determine the full path name of the nm to use.  */\n   memcpy (nm_file_name, prefix, len);\n   strcpy (nm_file_name + len, \"nm\");\n   if (access (nm_file_name, X_OK) < 0)\n@@ -575,7 +583,26 @@ main (argc, argv)\n #ifdef REAL_NM_FILE_NAME\n \t  nm_file_name = REAL_NM_FILE_NAME;\n #else\n-\t  nm_file_name = (access (\"/usr/bin/nm\", X_OK) == 0) ? \"/usr/bin/nm\" : \"/bin/nm\";\n+\t  nm_file_name = (access (\"/usr/bin/nm\", X_OK) == 0\n+\t\t\t  ? \"/usr/bin/nm\" : \"/bin/nm\");\n+#endif\n+\t}\n+    }\n+\n+  /* Determine the full pathname of the strip to use.  */\n+  memcpy (strip_file_name, prefix, len);\n+  strcpy (strip_file_name + len, \"strip\");\n+  if (access (strip_file_name, X_OK) < 0)\n+    {\n+      strcpy (strip_file_name + len, \"gstrip\");\n+      if (access (strip_file_name, X_OK) < 0)\n+\t{\n+\t  free (strip_file_name);\n+#ifdef REAL_STRIP_FILE_NAME\n+\t  strip_file_name = REAL_STRIP_FILE_NAME;\n+#else\n+\t  strip_file_name = (access (\"/usr/bin/strip\", X_OK) == 0\n+\t\t\t     ? \"/usr/bin/strip\" : \"/bin/strip\");\n #endif\n \t}\n     }\n@@ -630,6 +657,17 @@ main (argc, argv)\n \t\trflag = 1;\n \t      break;\n \n+\t    case 's':\n+\t      if (arg[2] == '\\0')\n+\t\t{\n+\t\t  /* We must strip after the nm run, otherwise C++ linking\n+\t\t     won't work.  Thus we strip in the second ld run, or\n+\t\t     else with strip if there is no second ld run.  */\n+\t\t  strip_flag = 1;\n+\t\t  ld1--;\n+\t\t}\n+\t      break;\n+\n \t    case 'v':\n \t      if (arg[2] == '\\0')\n \t\tvflag = 1;\n@@ -720,7 +758,18 @@ main (argc, argv)\n     }\n \n   if (constructors.number == 0 && destructors.number == 0)\n-    return 0;\n+    {\n+      /* Strip now if it was requested on the command line.  */\n+      if (strip_flag)\n+\t{\n+\t  char **strip_argv = (char **) xcalloc (sizeof (char *), 3);\n+\t  strip_argv[0] = \"strip\";\n+\t  strip_argv[1] = outfile;\n+\t  strip_argv[2] = (char *) 0;\n+\t  fork_execute (strip_file_name, strip_argv);\n+\t}\n+      return 0;\n+    }\n \n   outf = fopen (c_file, \"w\");\n   if (outf == (FILE *)0)"}]}