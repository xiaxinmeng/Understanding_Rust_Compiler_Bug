{"sha": "b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjMDU2ZmU5ZjFhMmNlMzhjMTQ5NWZiZmRjNzA4ZDQ2ZDlkMmVkMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-17T14:32:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-17T14:32:15Z"}, "message": "Add missing hunk for previous patch.\n\nFrom-SVN: r158467", "tree": {"sha": "2f166c54c4bca022abd3d5d5de6d6f5a6f2d00be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f166c54c4bca022abd3d5d5de6d6f5a6f2d00be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0/comments", "author": null, "committer": null, "parents": [{"sha": "728936bb9200245a354a6a3d259c86795de5b6a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728936bb9200245a354a6a3d259c86795de5b6a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728936bb9200245a354a6a3d259c86795de5b6a2"}], "stats": {"total": 68, "additions": 37, "deletions": 31}, "files": [{"sha": "f9d88a6a9bb829bdda07e40a90985b9ba308514f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b6c056fe9f1a2ce38c1495fbfdc708d46d9d2ed0", "patch": "@@ -1889,55 +1889,59 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    char field_name[16];\n \t    tree gnu_index_base_type\n \t      = get_unpadded_type (Base_Type (Etype (gnat_index)));\n-\t    tree gnu_low_field, gnu_high_field, gnu_low, gnu_high, gnu_max;\n+\t    tree gnu_lb_field, gnu_hb_field, gnu_orig_min, gnu_orig_max;\n+\t    tree gnu_min, gnu_max, gnu_high;\n \n \t    /* Make the FIELD_DECLs for the low and high bounds of this\n \t       type and then make extractions of these fields from the\n \t       template.  */\n \t    sprintf (field_name, \"LB%d\", index);\n-\t    gnu_low_field = create_field_decl (get_identifier (field_name),\n-\t\t\t\t\t       gnu_index_base_type,\n-\t\t\t\t\t       gnu_template_type, 0,\n-\t\t\t\t\t       NULL_TREE, NULL_TREE, 0);\n+\t    gnu_lb_field = create_field_decl (get_identifier (field_name),\n+\t\t\t\t\t      gnu_index_base_type,\n+\t\t\t\t\t      gnu_template_type, 0,\n+\t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n-\t\t\t   &DECL_SOURCE_LOCATION (gnu_low_field));\n+\t\t\t   &DECL_SOURCE_LOCATION (gnu_lb_field));\n \n \t    field_name[0] = 'U';\n-\t    gnu_high_field = create_field_decl (get_identifier (field_name),\n-\t\t\t\t\t        gnu_index_base_type,\n-\t\t\t\t\t        gnu_template_type, 0,\n-\t\t\t\t\t        NULL_TREE, NULL_TREE, 0);\n+\t    gnu_hb_field = create_field_decl (get_identifier (field_name),\n+\t\t\t\t\t      gnu_index_base_type,\n+\t\t\t\t\t      gnu_template_type, 0,\n+\t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n-\t\t\t   &DECL_SOURCE_LOCATION (gnu_high_field));\n+\t\t\t   &DECL_SOURCE_LOCATION (gnu_hb_field));\n \n-\t    gnu_temp_fields[index] = chainon (gnu_low_field, gnu_high_field);\n+\t    gnu_temp_fields[index] = chainon (gnu_lb_field, gnu_hb_field);\n \n \t    /* We can't use build_component_ref here since the template type\n \t       isn't complete yet.  */\n-\t    gnu_low = build3 (COMPONENT_REF, gnu_index_base_type,\n-\t\t\t      gnu_template_reference, gnu_low_field,\n-\t\t\t      NULL_TREE);\n-\t    gnu_high = build3 (COMPONENT_REF, gnu_index_base_type,\n-\t\t\t       gnu_template_reference, gnu_high_field,\n-\t\t\t       NULL_TREE);\n-\t    TREE_READONLY (gnu_low) = TREE_READONLY (gnu_high) = 1;\n-\n-\t    /* Compute the size of this dimension.  */\n-\t    gnu_max\n-\t      = build3 (COND_EXPR, gnu_index_base_type,\n-\t\t\tbuild2 (GE_EXPR, boolean_type_node, gnu_high, gnu_low),\n-\t\t\tgnu_high,\n-\t\t\tbuild2 (MINUS_EXPR, gnu_index_base_type,\n-\t\t\t\tgnu_low, fold_convert (gnu_index_base_type,\n-\t\t\t\t\t\t       integer_one_node)));\n+\t    gnu_orig_min = build3 (COMPONENT_REF, gnu_index_base_type,\n+\t\t\t\t   gnu_template_reference, gnu_lb_field,\n+\t\t\t\t   NULL_TREE);\n+\t    gnu_orig_max = build3 (COMPONENT_REF, gnu_index_base_type,\n+\t\t\t\t   gnu_template_reference, gnu_hb_field,\n+\t\t\t\t   NULL_TREE);\n+\t    TREE_READONLY (gnu_orig_min) = TREE_READONLY (gnu_orig_max) = 1;\n+\n+\t    gnu_min = convert (sizetype, gnu_orig_min);\n+\t    gnu_max = convert (sizetype, gnu_orig_max);\n+\n+\t    /* Compute the size of this dimension.  See the E_Array_Subtype\n+\t       case below for the rationale.  */\n+\t    gnu_high\n+\t      = build3 (COND_EXPR, sizetype,\n+\t\t\tbuild2 (GE_EXPR, boolean_type_node,\n+\t\t\t\tgnu_orig_max, gnu_orig_min),\n+\t\t\tgnu_max,\n+\t\t\tsize_binop (MINUS_EXPR, gnu_min, size_one_node));\n \n \t    /* Make a range type with the new range in the Ada base type.\n \t       Then make an index type with the size range in sizetype.  */\n \t    gnu_index_types[index]\n-\t      = create_index_type (convert (sizetype, gnu_low),\n-\t\t\t\t   convert (sizetype, gnu_max),\n+\t      = create_index_type (gnu_min, gnu_high,\n \t\t\t\t   create_range_type (gnu_index_base_type,\n-\t\t\t\t\t\t      gnu_low, gnu_high),\n+\t\t\t\t\t\t      gnu_orig_min,\n+\t\t\t\t\t\t      gnu_orig_max),\n \t\t\t\t   gnat_entity);\n \n \t    /* Update the maximum size of the array in elements.  */\n@@ -2209,6 +2213,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t     size_binop (MINUS_EXPR, gnu_min,\n \t\t\t\t\t\t size_one_node));\n \n+\t      /* Reuse the index type for the range type.  Then make an index\n+\t\t type with the size range in sizetype.  */\n \t      gnu_index_types[index]\n \t\t= create_index_type (gnu_min, gnu_high, gnu_index_type,\n \t\t\t\t     gnat_entity);"}]}