{"sha": "e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk4OTIwMmYwMWUzNDRlZThmMGNhZmM4ZDNmMGU5YWRkYmJlNmRjOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-11-05T11:29:33Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-11-05T11:29:33Z"}, "message": "bfin.c (n_dregs_to_save, [...]): New argument IS_INTHANDLER; all callers changed.\n\n\t* config/bfin/bfin.c (n_dregs_to_save, n_pregs_to_save,\n\texpand_prologue_reg_save, expand_epilogue_reg_restore): New argument\n\tIS_INTHANDLER; all callers changed.\n\t(n_regs_saved_by_prologue): Take interrupt handler attributes into\n\taccount.\n\t(do_link, do_unlink): New argument ALL; all callers changed.\n\t(expand_interrupt_handler_prologue, expand_interrupt_handler_epilogue):\n\tIf function isn't leaf, save and restore all registers.\n\t(bfin_function_ok_for_sibcall): Only true if not an interrupt or\n\texception handler.\n\nFrom-SVN: r106526", "tree": {"sha": "5bcf7bbd2f9f6163b05471cb42850dbddbfa018f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bcf7bbd2f9f6163b05471cb42850dbddbfa018f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8/comments", "author": null, "committer": null, "parents": [{"sha": "460d832b00a3580ed4dcf175894d99159535deaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460d832b00a3580ed4dcf175894d99159535deaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460d832b00a3580ed4dcf175894d99159535deaf"}], "stats": {"total": 105, "additions": 69, "deletions": 36}, "files": [{"sha": "b556cc57bfe20a5ae0705e5c0720d9cdba804127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8", "patch": "@@ -1,3 +1,16 @@\n+2005-11-05  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (n_dregs_to_save, n_pregs_to_save,\n+\texpand_prologue_reg_save, expand_epilogue_reg_restore): New argument\n+\tIS_INTHANDLER; all callers changed.\n+\t(n_regs_saved_by_prologue): Take interrupt handler attributes into\n+\taccount.\n+\t(do_link, do_unlink): New argument ALL; all callers changed.\n+\t(expand_interrupt_handler_prologue, expand_interrupt_handler_epilogue):\n+\tIf function isn't leaf, save and restore all registers.\n+\t(bfin_function_ok_for_sibcall): Only true if not an interrupt or\n+\texception handler.\n+\n 2005-11-05  Jan Hubicka  <jh@suse.cz>\n \n \tPR rtl-optimization/23490"}, {"sha": "be028f74528277f07ead54f06159fa92f7e7d206", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 56, "deletions": 36, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e989202f01e344ee8f0cafc8d3f0e9addbbe6dc8", "patch": "@@ -212,16 +212,18 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n \n /* Compute the number of DREGS to save with a push_multiple operation.\n    This could include registers that aren't modified in the function,\n-   since push_multiple only takes a range of registers.  */\n+   since push_multiple only takes a range of registers.\n+   If IS_INTHANDLER, then everything that is live must be saved, even\n+   if normally call-clobbered.  */\n \n static int\n-n_dregs_to_save (void)\n+n_dregs_to_save (bool is_inthandler)\n {\n   unsigned i;\n \n   for (i = REG_R0; i <= REG_R7; i++)\n     {\n-      if (regs_ever_live[i] && ! call_used_regs[i])\n+      if (regs_ever_live[i] && (is_inthandler || ! call_used_regs[i]))\n \treturn REG_R7 - i + 1;\n \n       if (current_function_calls_eh_return)\n@@ -244,12 +246,12 @@ n_dregs_to_save (void)\n /* Like n_dregs_to_save, but compute number of PREGS to save.  */\n \n static int\n-n_pregs_to_save (void)\n+n_pregs_to_save (bool is_inthandler)\n {\n   unsigned i;\n \n   for (i = REG_P0; i <= REG_P5; i++)\n-    if ((regs_ever_live[i] && ! call_used_regs[i])\n+    if ((regs_ever_live[i] && (is_inthandler || ! call_used_regs[i]))\n \t|| (i == PIC_OFFSET_TABLE_REGNUM\n \t    && (current_function_uses_pic_offset_table\n \t\t|| (TARGET_ID_SHARED_LIBRARY && ! current_function_is_leaf))))\n@@ -262,7 +264,7 @@ n_pregs_to_save (void)\n static bool\n must_save_fp_p (void)\n {\n-  return (frame_pointer_needed || regs_ever_live[REG_FP]);\n+  return frame_pointer_needed || regs_ever_live[REG_FP];\n }\n \n static bool\n@@ -277,13 +279,14 @@ stack_frame_needed_p (void)\n \n /* Emit code to save registers in the prologue.  SAVEALL is nonzero if we\n    must save all registers; this is used for interrupt handlers.\n-   SPREG contains (reg:SI REG_SP).  */\n+   SPREG contains (reg:SI REG_SP).  IS_INTHANDLER is true if we're doing\n+   this for an interrupt (or exception) handler.  */\n \n static void\n-expand_prologue_reg_save (rtx spreg, int saveall)\n+expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n {\n-  int ndregs = saveall ? 8 : n_dregs_to_save ();\n-  int npregs = saveall ? 6 : n_pregs_to_save ();\n+  int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler);\n+  int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler);\n   int dregno = REG_R7 + 1 - ndregs;\n   int pregno = REG_P5 + 1 - npregs;\n   int total = ndregs + npregs;\n@@ -328,13 +331,14 @@ expand_prologue_reg_save (rtx spreg, int saveall)\n \n /* Emit code to restore registers in the epilogue.  SAVEALL is nonzero if we\n    must save all registers; this is used for interrupt handlers.\n-   SPREG contains (reg:SI REG_SP).  */\n+   SPREG contains (reg:SI REG_SP).  IS_INTHANDLER is true if we're doing\n+   this for an interrupt (or exception) handler.  */\n \n static void\n-expand_epilogue_reg_restore (rtx spreg, int saveall)\n+expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n {\n-  int ndregs = saveall ? 8 : n_dregs_to_save ();\n-  int npregs = saveall ? 6 : n_pregs_to_save ();\n+  int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler);\n+  int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler);\n   int total = ndregs + npregs;\n   int i, regno;\n   rtx pat, insn;\n@@ -449,9 +453,15 @@ static int\n n_regs_saved_by_prologue (void)\n {\n   e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n-  int n = n_dregs_to_save () + n_pregs_to_save ();\n+  bool is_inthandler = fkind != SUBROUTINE;\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  bool all = (lookup_attribute (\"saveall\", attrs) != NULL_TREE\n+\t      || (is_inthandler && !current_function_is_leaf));\n+  int ndregs = all ? 8 : n_dregs_to_save (is_inthandler);\n+  int npregs = all ? 6 : n_pregs_to_save (is_inthandler);  \n+  int n = ndregs + npregs;\n \n-  if (stack_frame_needed_p ())\n+  if (all || stack_frame_needed_p ())\n     /* We use a LINK instruction in this case.  */\n     n += 2;\n   else\n@@ -464,8 +474,6 @@ n_regs_saved_by_prologue (void)\n \n   if (fkind != SUBROUTINE)\n     {\n-      tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n-      tree all = lookup_attribute (\"saveall\", attrs);\n       int i;\n \n       /* Increment once for ASTAT.  */\n@@ -640,14 +648,16 @@ arg_area_size (void)\n   return 0;\n }\n \n-/* Save RETS and FP, and allocate a stack frame.  */\n+/* Save RETS and FP, and allocate a stack frame.  ALL is true if the\n+   function must save all its registers (true only for certain interrupt\n+   handlers).  */\n \n static void\n-do_link (rtx spreg, HOST_WIDE_INT frame_size)\n+do_link (rtx spreg, HOST_WIDE_INT frame_size, bool all)\n {\n   frame_size += arg_area_size ();\n \n-  if (stack_frame_needed_p ()\n+  if (all || stack_frame_needed_p ()\n       || (must_save_fp_p () && ! current_function_is_leaf))\n     emit_link_insn (spreg, frame_size);\n   else\n@@ -675,11 +685,11 @@ do_link (rtx spreg, HOST_WIDE_INT frame_size)\n /* Like do_link, but used for epilogues to deallocate the stack frame.  */\n \n static void\n-do_unlink (rtx spreg, HOST_WIDE_INT frame_size)\n+do_unlink (rtx spreg, HOST_WIDE_INT frame_size, bool all)\n {\n   frame_size += arg_area_size ();\n \n-  if (stack_frame_needed_p ())\n+  if (all || stack_frame_needed_p ())\n     emit_insn (gen_unlink ());\n   else \n     {\n@@ -713,7 +723,7 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n   rtx predec = gen_rtx_MEM (SImode, predec1);\n   rtx insn;\n   tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n-  tree all = lookup_attribute (\"saveall\", attrs);\n+  bool all = lookup_attribute (\"saveall\", attrs) != NULL_TREE;\n   tree kspisusp = lookup_attribute (\"kspisusp\", attrs);\n \n   if (kspisusp)\n@@ -733,7 +743,11 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n   insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n   RTX_FRAME_RELATED_P (insn) = 1;\n \n-  expand_prologue_reg_save (spreg, all != NULL_TREE);\n+  /* If we're calling other functions, they won't save their call-clobbered\n+     registers, so we must save everything here.  */\n+  if (!current_function_is_leaf)\n+    all = true;\n+  expand_prologue_reg_save (spreg, all, true);\n \n   for (i = REG_P7 + 1; i < REG_CC; i++)\n     if (all \n@@ -757,7 +771,7 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  do_link (spreg, frame_size);\n+  do_link (spreg, frame_size, all);\n \n   if (fkind == EXCPT_HANDLER)\n     {\n@@ -792,19 +806,19 @@ expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n    SPREG contains (reg:SI REG_SP).  */\n \n static void\n-expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind) \n+expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n {\n   int i;\n   rtx postinc1 = gen_rtx_POST_INC (SImode, spreg);\n   rtx postinc = gen_rtx_MEM (SImode, postinc1);\n   tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n-  tree all = lookup_attribute (\"saveall\", attrs);\n+  bool all = lookup_attribute (\"saveall\", attrs) != NULL_TREE;\n \n   /* A slightly crude technique to stop flow from trying to delete \"dead\"\n      insns.  */\n   MEM_VOLATILE_P (postinc) = 1;\n \n-  do_unlink (spreg, get_frame_size ());\n+  do_unlink (spreg, get_frame_size (), all);\n \n   if (lookup_attribute (\"nesting\", attrs))\n     {\n@@ -814,9 +828,14 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n       emit_move_insn (srcreg, postinc);\n     }\n \n+  /* If we're calling other functions, they won't save their call-clobbered\n+     registers, so we must save (and restore) everything here.  */\n+  if (!current_function_is_leaf)\n+    all = true;\n+\n   for (i = REG_CC - 1; i > REG_P7; i--)\n     if (all\n-\t|| regs_ever_live[i] \n+\t|| regs_ever_live[i]\n \t|| (!leaf_function_p () && call_used_regs[i]))\n       {\n \tif (i == REG_A0 || i == REG_A1)\n@@ -829,7 +848,7 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n \t  emit_move_insn (gen_rtx_REG (SImode, i), postinc);\n       }\n \n-  expand_epilogue_reg_restore (spreg, all != NULL_TREE);\n+  expand_epilogue_reg_restore (spreg, all, true);\n \n   emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n \n@@ -909,9 +928,9 @@ bfin_expand_prologue (void)\n       emit_insn (gen_compare_lt (bfin_cc_rtx, spreg, lim));\n       emit_insn (gen_trapifcc ());\n     }\n-  expand_prologue_reg_save (spreg, 0);\n+  expand_prologue_reg_save (spreg, 0, false);\n \n-  do_link (spreg, frame_size);\n+  do_link (spreg, frame_size, false);\n \n   if (TARGET_ID_SHARED_LIBRARY\n       && (current_function_uses_pic_offset_table\n@@ -935,9 +954,9 @@ bfin_expand_epilogue (int need_return, int eh_return)\n       return;\n     }\n \n-  do_unlink (spreg, get_frame_size ());\n+  do_unlink (spreg, get_frame_size (), false);\n \n-  expand_epilogue_reg_restore (spreg, 0);\n+  expand_epilogue_reg_restore (spreg, false, false);\n \n   /* Omit the return insn if this is for a sibcall.  */\n   if (! need_return)\n@@ -1469,7 +1488,8 @@ static bool\n bfin_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n \t\t\t      tree exp ATTRIBUTE_UNUSED)\n {\n-  return true;\n+  e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n+  return fkind == SUBROUTINE;\n }\n \f\n /* Emit RTL insns to initialize the variable parts of a trampoline at"}]}