{"sha": "28c95eff94412989fb44ac2386ce1934af5a8b20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhjOTVlZmY5NDQxMjk4OWZiNDRhYzIzODZjZTE5MzRhZjVhOGIyMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-03-07T11:22:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-03-07T11:22:10Z"}, "message": "haifa-sched.c (reg_last_clobbers): New.\n\n        * haifa-sched.c (reg_last_clobbers): New.\n        (reg_pending_clobbers, bb_reg_last_clobbers): New.\n        (compute_block_backward_dependences): Allocate memory for them.\n        (schedule_region): Likewise.\n        (sched_analyze_1): Clobbers don't interfere with one another.\n        They do interfere with sets ...\n        (sched_analyze_2): ... and uses.\n        (sched_analyze): Likewise.\n        (sched_analyze_insn): Update reg_last_clobbers appropriately.\n\nFrom-SVN: r25628", "tree": {"sha": "b4a6e80a50f7c1c40d1f569ecfd789a090577a7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4a6e80a50f7c1c40d1f569ecfd789a090577a7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28c95eff94412989fb44ac2386ce1934af5a8b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c95eff94412989fb44ac2386ce1934af5a8b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c95eff94412989fb44ac2386ce1934af5a8b20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c95eff94412989fb44ac2386ce1934af5a8b20/comments", "author": null, "committer": null, "parents": [{"sha": "3bb5de61eb6b1008cb560be1a769f316860fe930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb5de61eb6b1008cb560be1a769f316860fe930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb5de61eb6b1008cb560be1a769f316860fe930"}], "stats": {"total": 118, "additions": 102, "deletions": 16}, "files": [{"sha": "4bb5592e04ff1e10eedad117f48b5458a586235b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c95eff94412989fb44ac2386ce1934af5a8b20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c95eff94412989fb44ac2386ce1934af5a8b20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28c95eff94412989fb44ac2386ce1934af5a8b20", "patch": "@@ -1,3 +1,15 @@\n+Sun Mar  7 11:21:02 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (reg_last_clobbers): New.\n+\t(reg_pending_clobbers, bb_reg_last_clobbers): New.\n+\t(compute_block_backward_dependences): Allocate memory for them.\n+\t(schedule_region): Likewise.\n+\t(sched_analyze_1): Clobbers don't interfere with one another.\n+\tThey do interfere with sets ...\n+\t(sched_analyze_2): ... and uses.\n+\t(sched_analyze): Likewise.\n+\t(sched_analyze_insn): Update reg_last_clobbers appropriately.\n+\n Sun Mar  7 08:30:37 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gmon-sol2.c: Include config.h and system.h.  Don't redundantly"}, {"sha": "3e3985163107456d2b6bbb7e9d21e3cffb8cd54c", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 90, "deletions": 16, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c95eff94412989fb44ac2386ce1934af5a8b20/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c95eff94412989fb44ac2386ce1934af5a8b20/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=28c95eff94412989fb44ac2386ce1934af5a8b20", "patch": "@@ -251,7 +251,9 @@ static int current_block_num;\n    by splitting insns.  */\n static rtx *reg_last_uses;\n static rtx *reg_last_sets;\n+static rtx *reg_last_clobbers;\n static regset reg_pending_sets;\n+static regset reg_pending_clobbers;\n static int reg_pending_sets_all;\n \n /* Vector indexed by INSN_UID giving the original ordering of the insns.  */\n@@ -1054,6 +1056,7 @@ static rtx last_scheduled_insn;\n \n static rtx **bb_reg_last_uses;\n static rtx **bb_reg_last_sets;\n+static rtx **bb_reg_last_clobbers;\n \n static rtx *bb_pending_read_insns;\n static rtx *bb_pending_read_mems;\n@@ -3309,6 +3312,7 @@ sched_analyze_1 (x, insn)\n {\n   register int regno;\n   register rtx dest = SET_DEST (x);\n+  enum rtx_code code = GET_CODE (x);\n \n   if (dest == 0)\n     return;\n@@ -3358,10 +3362,20 @@ sched_analyze_1 (x, insn)\n \t      for (u = reg_last_sets[regno + i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \n-\t      SET_REGNO_REG_SET (reg_pending_sets, regno + i);\n+\t      /* Clobbers need not be ordered with respect to one another,\n+\t\t but sets must be ordered with respect to a pending clobber. */\n+\t      if (code == SET)\n+\t\t{\n+\t          for (u = reg_last_clobbers[regno + i]; u; u = XEXP (u, 1))\n+\t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n+\t          SET_REGNO_REG_SET (reg_pending_sets, regno + i);\n+\t\t}\n+\t      else\n+\t\tSET_REGNO_REG_SET (reg_pending_clobbers, regno + i);\n \n-\t      if ((call_used_regs[regno + i] || global_regs[regno + i]))\n-\t\t/* Function calls clobber all call_used regs.  */\n+\t      /* Function calls clobber all call_used regs.  */\n+\t      if (global_regs[regno + i]\n+\t\t  || (code == SET && call_used_regs[regno + i]))\n \t\tfor (u = last_function_call; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t    }\n@@ -3377,7 +3391,10 @@ sched_analyze_1 (x, insn)\n \t  for (u = reg_last_sets[regno]; u; u = XEXP (u, 1))\n \t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \n-\t  SET_REGNO_REG_SET (reg_pending_sets, regno);\n+\t  if (code == SET)\n+\t    SET_REGNO_REG_SET (reg_pending_sets, regno);\n+\t  else\n+\t    SET_REGNO_REG_SET (reg_pending_clobbers, regno);\n \n \t  /* Pseudos that are REG_EQUIV to something may be replaced\n \t     by that during reloading.  We need only add dependencies for\n@@ -3528,6 +3545,10 @@ sched_analyze_2 (x, insn)\n \t\tfor (u = reg_last_sets[regno + i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n \n+\t\t/* ??? This should never happen.  */\n+\t\tfor (u = reg_last_clobbers[regno + i]; u; u = XEXP (u, 1))\n+\t\t  add_dependence (insn, XEXP (u, 0), 0);\n+\n \t\tif ((call_used_regs[regno + i] || global_regs[regno + i]))\n \t\t  /* Function calls clobber all call_used regs.  */\n \t\t  for (u = last_function_call; u; u = XEXP (u, 1))\n@@ -3541,6 +3562,10 @@ sched_analyze_2 (x, insn)\n \t    for (u = reg_last_sets[regno]; u; u = XEXP (u, 1))\n \t      add_dependence (insn, XEXP (u, 0), 0);\n \n+\t    /* ??? This should never happen.  */\n+\t    for (u = reg_last_clobbers[regno]; u; u = XEXP (u, 1))\n+\t      add_dependence (insn, XEXP (u, 0), 0);\n+\n \t    /* Pseudos that are REG_EQUIV to something may be replaced\n \t       by that during reloading.  We need only add dependencies for\n \t       the address in the REG_EQUIV note.  */\n@@ -3631,9 +3656,11 @@ sched_analyze_2 (x, insn)\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t\treg_last_uses[i] = 0;\n \n-\t\t/* reg_last_sets[r] is now a list of insns */\n \t\tfor (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n+\n+\t\tfor (u = reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\t  add_dependence (insn, XEXP (u, 0), 0);\n \t      }\n \t    reg_pending_sets_all = 1;\n \n@@ -3762,9 +3789,11 @@ sched_analyze_insn (x, insn, loop_notes)\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t      reg_last_uses[i] = 0;\n \n-\t      /* reg_last_sets[r] is now a list of insns */\n \t      for (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), 0);\n+\n+\t      for (u = reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\tadd_dependence (insn, XEXP (u, 0), 0);\n \t    }\n \t  reg_pending_sets_all = 1;\n \n@@ -3773,20 +3802,29 @@ sched_analyze_insn (x, insn, loop_notes)\n \n     }\n \n+  /* Accumulate clobbers until the next set so that it will be output dependant\n+     on all of them.  At the next set we can clear the clobber list, since\n+     subsequent sets will be output dependant on it.  */\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t\t\t     {\n-\t\t\t       /* reg_last_sets[r] is now a list of insns */\n \t\t\t       free_list (&reg_last_sets[i], &unused_insn_list);\n+\t\t\t       free_list (&reg_last_clobbers[i],\n+\t\t\t\t\t  &unused_insn_list);\n \t\t\t       reg_last_sets[i]\n \t\t\t\t = alloc_INSN_LIST (insn, NULL_RTX);\n \t\t\t     });\n+  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i,\n+\t\t\t     {\n+\t\t\t       reg_last_clobbers[i]\n+\t\t\t\t = alloc_INSN_LIST (insn, reg_last_clobbers[i]);\n+\t\t\t     });\n   CLEAR_REG_SET (reg_pending_sets);\n+  CLEAR_REG_SET (reg_pending_clobbers);\n \n   if (reg_pending_sets_all)\n     {\n       for (i = 0; i < maxreg; i++)\n \t{\n-\t  /* reg_last_sets[r] is now a list of insns */\n \t  free_list (&reg_last_sets[i], &unused_insn_list);\n \t  reg_last_sets[i] = alloc_INSN_LIST (insn, NULL_RTX);\n \t}\n@@ -3884,9 +3922,11 @@ sched_analyze (head, tail)\n \n \t\t  reg_last_uses[i] = 0;\n \n-\t\t  /* reg_last_sets[r] is now a list of insns */\n \t\t  for (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), 0);\n+\n+\t\t  for (u = reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\t    add_dependence (insn, XEXP (u, 0), 0);\n \t\t}\n \t      reg_pending_sets_all = 1;\n \n@@ -3909,10 +3949,13 @@ sched_analyze (head, tail)\n \t\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t\t    reg_last_uses[i] = 0;\n \n-\t\t    /* reg_last_sets[r] is now a list of insns */\n \t\t    for (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n+\t\t    if (global_regs[i])\n+\t\t      for (u = reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\t        add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\n \t\t    SET_REGNO_REG_SET (reg_pending_sets, i);\n \t\t  }\n \t    }\n@@ -7232,9 +7275,11 @@ compute_block_backward_dependences (bb)\n     {\n       reg_last_uses = (rtx *) alloca (max_reg * sizeof (rtx));\n       reg_last_sets = (rtx *) alloca (max_reg * sizeof (rtx));\n+      reg_last_clobbers = (rtx *) alloca (max_reg * sizeof (rtx));\n \n       bzero ((char *) reg_last_uses, max_reg * sizeof (rtx));\n       bzero ((char *) reg_last_sets, max_reg * sizeof (rtx));\n+      bzero ((char *) reg_last_clobbers, max_reg * sizeof (rtx));\n \n       pending_read_insns = 0;\n       pending_read_mems = 0;\n@@ -7252,6 +7297,7 @@ compute_block_backward_dependences (bb)\n     {\n       reg_last_uses = bb_reg_last_uses[bb];\n       reg_last_sets = bb_reg_last_sets[bb];\n+      reg_last_clobbers = bb_reg_last_clobbers[bb];\n \n       pending_read_insns = bb_pending_read_insns[bb];\n       pending_read_mems = bb_pending_read_mems[bb];\n@@ -7323,6 +7369,16 @@ compute_block_backward_dependences (bb)\n \t\t      = alloc_INSN_LIST (XEXP (u, 0),\n \t\t\t\t\t (bb_reg_last_sets[bb_succ])[reg]);\n \t\t  }\n+\n+\t\tfor (u = reg_last_clobbers[reg]; u; u = XEXP (u, 1))\n+\t\t  {\n+\t\t    if (find_insn_list (XEXP (u, 0), (bb_reg_last_clobbers[bb_succ])[reg]))\n+\t\t      continue;\n+\n+\t\t    (bb_reg_last_clobbers[bb_succ])[reg]\n+\t\t      = alloc_INSN_LIST (XEXP (u, 0),\n+\t\t\t\t\t (bb_reg_last_clobbers[bb_succ])[reg]);\n+\t\t  }\n \t      }\n \n \t    /* mem read/write lists are inherited by bb_succ */\n@@ -7397,6 +7453,8 @@ compute_block_backward_dependences (bb)\n      3-5% on average.  */\n   for (b = 0; b < max_reg; ++b)\n     {\n+      if (reg_last_clobbers[b])\n+\tfree_list (&reg_last_clobbers[b], &unused_insn_list);\n       if (reg_last_sets[b])\n \tfree_list (&reg_last_sets[b], &unused_insn_list);\n       if (reg_last_uses[b])\n@@ -7408,6 +7466,7 @@ compute_block_backward_dependences (bb)\n     {\n       bb_reg_last_uses[bb] = (rtx *) NULL_RTX;\n       bb_reg_last_sets[bb] = (rtx *) NULL_RTX;\n+      bb_reg_last_clobbers[bb] = (rtx *) NULL_RTX;\n     }\n }\n \n@@ -7560,6 +7619,7 @@ schedule_region (rgn)\n   current_blocks = RGN_BLOCKS (rgn);\n \n   reg_pending_sets = ALLOCA_REG_SET ();\n+  reg_pending_clobbers = ALLOCA_REG_SET ();\n   reg_pending_sets_all = 0;\n \n   /* initializations for region data dependence analyisis */\n@@ -7571,21 +7631,34 @@ schedule_region (rgn)\n       bb_reg_last_uses = (rtx **) alloca (current_nr_blocks * sizeof (rtx *));\n       space = (rtx *) alloca (current_nr_blocks * maxreg * sizeof (rtx));\n       bzero ((char *) space, current_nr_blocks * maxreg * sizeof (rtx));\n-      init_rtx_vector (bb_reg_last_uses, space, current_nr_blocks, maxreg * sizeof (rtx *));\n+      init_rtx_vector (bb_reg_last_uses, space, current_nr_blocks,\n+\t\t       maxreg * sizeof (rtx *));\n \n       bb_reg_last_sets = (rtx **) alloca (current_nr_blocks * sizeof (rtx *));\n       space = (rtx *) alloca (current_nr_blocks * maxreg * sizeof (rtx));\n       bzero ((char *) space, current_nr_blocks * maxreg * sizeof (rtx));\n-      init_rtx_vector (bb_reg_last_sets, space, current_nr_blocks, maxreg * sizeof (rtx *));\n+      init_rtx_vector (bb_reg_last_sets, space, current_nr_blocks,\n+\t\t       maxreg * sizeof (rtx *));\n+\n+      bb_reg_last_clobbers =\n+\t(rtx **) alloca (current_nr_blocks * sizeof (rtx *));\n+      space = (rtx *) alloca (current_nr_blocks * maxreg * sizeof (rtx));\n+      bzero ((char *) space, current_nr_blocks * maxreg * sizeof (rtx));\n+      init_rtx_vector (bb_reg_last_clobbers, space, current_nr_blocks,\n+\t\t       maxreg * sizeof (rtx *));\n \n       bb_pending_read_insns = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n       bb_pending_read_mems = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n-      bb_pending_write_insns = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+      bb_pending_write_insns =\n+\t(rtx *) alloca (current_nr_blocks * sizeof (rtx));\n       bb_pending_write_mems = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n-      bb_pending_lists_length = (int *) alloca (current_nr_blocks * sizeof (int));\n-      bb_last_pending_memory_flush = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+      bb_pending_lists_length =\n+\t(int *) alloca (current_nr_blocks * sizeof (int));\n+      bb_last_pending_memory_flush =\n+\t(rtx *) alloca (current_nr_blocks * sizeof (rtx));\n       bb_last_function_call = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n-      bb_sched_before_next_call = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+      bb_sched_before_next_call =\n+\t(rtx *) alloca (current_nr_blocks * sizeof (rtx));\n \n       init_rgn_data_dependences (current_nr_blocks);\n     }\n@@ -7703,6 +7776,7 @@ schedule_region (rgn)\n   free_pending_lists ();\n \n   FREE_REG_SET (reg_pending_sets);\n+  FREE_REG_SET (reg_pending_clobbers);\n }\n \n /* Subroutine of update_flow_info.  Determines whether any new REG_NOTEs are"}]}