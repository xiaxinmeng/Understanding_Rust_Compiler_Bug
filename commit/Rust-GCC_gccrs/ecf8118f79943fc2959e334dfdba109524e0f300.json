{"sha": "ecf8118f79943fc2959e334dfdba109524e0f300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNmODExOGY3OTk0M2ZjMjk1OWUzMzRkZmRiYTEwOTUyNGUwZjMwMA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:24:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:24:06Z"}, "message": "lib-xref.ads, [...]: Modify the loop that collects type references...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* lib-xref.ads, lib-xref.adb: \n\tModify the loop that collects type references, to include interface\n\ttypes that the type implements. List each of these interfaces when\n\tbuilding the entry for the type.\n\t(Generate_Definition): Initialize component Def and Typ of new entry\n\tin table Xrefs, to avoid to have these components unitialized.\n\t(Output_References): Split Is_Abstract flag into\n\tIs_Abstract_Subprogram and Is_Abstract_Type.\n\t(Generate_Reference): Add barrier to do not generate the warning\n\tassociated with Ada 2005 entities with entities generated by the\n\texpander.\n\nFrom-SVN: r123583", "tree": {"sha": "db1ca9236ba65795a25432cd5cc213a926e90cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db1ca9236ba65795a25432cd5cc213a926e90cbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecf8118f79943fc2959e334dfdba109524e0f300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecf8118f79943fc2959e334dfdba109524e0f300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecf8118f79943fc2959e334dfdba109524e0f300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecf8118f79943fc2959e334dfdba109524e0f300/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff5066d40b3d80ecc7ab688b3936d09019c42e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5066d40b3d80ecc7ab688b3936d09019c42e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5066d40b3d80ecc7ab688b3936d09019c42e02"}], "stats": {"total": 252, "additions": 177, "deletions": 75}, "files": [{"sha": "3c8291915f126e02186b9167d5541094448721b0", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 172, "deletions": 74, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf8118f79943fc2959e334dfdba109524e0f300/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf8118f79943fc2959e334dfdba109524e0f300/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=ecf8118f79943fc2959e334dfdba109524e0f300", "patch": "@@ -137,7 +137,9 @@ package body Lib.Xref is\n          Loc  := Original_Location (Sloc (E));\n \n          Xrefs.Table (Indx).Ent := E;\n+         Xrefs.Table (Indx).Def := No_Location;\n          Xrefs.Table (Indx).Loc := No_Location;\n+         Xrefs.Table (Indx).Typ := ' ';\n          Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n          Xrefs.Table (Indx).Lun := No_Unit;\n          Set_Has_Xref_Entry (E);\n@@ -306,7 +308,8 @@ package body Lib.Xref is\n       --  Warn if reference to Ada 2005 entity not in Ada 2005 mode. We only\n       --  detect real explicit references (modifications and references).\n \n-      if Is_Ada_2005_Only (E)\n+      if Comes_From_Source (N)\n+        and then Is_Ada_2005_Only (E)\n         and then Ada_Version < Ada_05\n         and then Warn_On_Ada_2005_Compatibility\n         and then (Typ = 'm' or else Typ = 'r')\n@@ -920,29 +923,57 @@ package body Lib.Xref is\n       --  referenced in the main unit, which may mean that there is no xref\n       --  entry for this entity yet in the list of references.\n \n-      --  If we don't do something about this, we will end with an orphan\n-      --  type reference, i.e. it will point to an entity that does not\n-      --  appear within the generated references in the ali file. That is\n-      --  not good for tools using the xref information.\n+      --  If we don't do something about this, we will end with an orphan type\n+      --  reference, i.e. it will point to an entity that does not appear\n+      --  within the generated references in the ali file. That is not good for\n+      --  tools using the xref information.\n \n-      --  To fix this, we go through the references adding definition\n-      --  entries for any unreferenced entities that can be referenced\n-      --  in a type reference. There is a recursion problem here, and\n-      --  that is dealt with by making sure that this traversal also\n-      --  traverses any entries that get added by the traversal.\n+      --  To fix this, we go through the references adding definition entries\n+      --  for any unreferenced entities that can be referenced in a type\n+      --  reference. There is a recursion problem here, and that is dealt with\n+      --  by making sure that this traversal also traverses any entries that\n+      --  get added by the traversal.\n \n-      declare\n+      Handle_Orphan_Type_References : declare\n          J    : Nat;\n          Tref : Entity_Id;\n          L, R : Character;\n          Indx : Nat;\n          Ent  : Entity_Id;\n          Loc  : Source_Ptr;\n \n+         procedure New_Entry (E : Entity_Id);\n+         --  Make an additional entry into the Xref table for a type entity\n+         --  that is related to the current entity (parent, type. ancestor,\n+         --  progenitor, etc.).\n+\n+         ----------------\n+         -- New_Entry --\n+         ----------------\n+\n+         procedure New_Entry (E : Entity_Id) is\n+         begin\n+            if Present (E)\n+              and then not Has_Xref_Entry (E)\n+              and then Sloc (E) > No_Location\n+            then\n+               Xrefs.Increment_Last;\n+               Indx := Xrefs.Last;\n+               Loc  := Original_Location (Sloc (E));\n+               Xrefs.Table (Indx).Ent := E;\n+               Xrefs.Table (Indx).Loc := No_Location;\n+               Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n+               Xrefs.Table (Indx).Lun := No_Unit;\n+               Set_Has_Xref_Entry (E);\n+            end if;\n+         end New_Entry;\n+\n+      --  Start of processing for Handle_Orphan_Type_References\n+\n       begin\n          --  Note that this is not a for loop for a very good reason. The\n-         --  processing of items in the table can add new items to the\n-         --  table, and they must be processed as well\n+         --  processing of items in the table can add new items to the table,\n+         --  and they must be processed as well\n \n          J := 1;\n          while J <= Xrefs.Last loop\n@@ -953,14 +984,25 @@ package body Lib.Xref is\n               and then not Has_Xref_Entry (Tref)\n               and then Sloc (Tref) > No_Location\n             then\n-               Xrefs.Increment_Last;\n-               Indx := Xrefs.Last;\n-               Loc  := Original_Location (Sloc (Tref));\n-               Xrefs.Table (Indx).Ent := Tref;\n-               Xrefs.Table (Indx).Loc := No_Location;\n-               Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n-               Xrefs.Table (Indx).Lun := No_Unit;\n-               Set_Has_Xref_Entry (Tref);\n+               New_Entry (Tref);\n+\n+               if Is_Record_Type (Ent)\n+                 and then Present (Abstract_Interfaces (Ent))\n+               then\n+                  --  Add an entry for each one of the given interfaces\n+                  --  implemented by type Ent.\n+\n+                  declare\n+                     Elmt : Elmt_Id;\n+\n+                  begin\n+                     Elmt := First_Elmt (Abstract_Interfaces (Ent));\n+                     while Present (Elmt) loop\n+                        New_Entry (Node (Elmt));\n+                        Next_Elmt (Elmt);\n+                     end loop;\n+                  end;\n+               end if;\n             end if;\n \n             --  Collect inherited primitive operations that may be\n@@ -1021,7 +1063,7 @@ package body Lib.Xref is\n \n             J := J + 1;\n          end loop;\n-      end;\n+      end Handle_Orphan_Type_References;\n \n       --  Now we have all the references, including those for any embedded\n       --  type references, so we can sort them, and output them.\n@@ -1228,6 +1270,15 @@ package body Lib.Xref is\n                Right : Character;\n                --  Used for {} or <> or () for type reference\n \n+               procedure Check_Type_Reference\n+                 (Ent : Entity_Id;\n+                  List_Interface : Boolean);\n+               --  Find whether there is a meaningful type reference for\n+               --  Ent, and display it accordingly. If List_Interface is\n+               --  true, then Ent is a progenitor interface of the current\n+               --  type entity being listed. In that case list it as is,\n+               --  without looking for a type reference for it.\n+\n                procedure Output_Instantiation_Refs (Loc : Source_Ptr);\n                --  Recursive procedure to output instantiation references for\n                --  the given source ptr in [file|line[...]] form. No output\n@@ -1237,6 +1288,82 @@ package body Lib.Xref is\n                --  For a subprogram that is overriding, display information\n                --  about the inherited operation that it overrides.\n \n+               --------------------------\n+               -- Check_Type_Reference --\n+               --------------------------\n+\n+               procedure Check_Type_Reference\n+                 (Ent : Entity_Id;\n+                  List_Interface : Boolean)\n+               is\n+               begin\n+                  if List_Interface then\n+\n+                     --  This is a progenitor interface of the type for\n+                     --  which xref information is being generated.\n+\n+                     Tref  := Ent;\n+                     Left  := '<';\n+                     Right := '>';\n+\n+                  else\n+                     Get_Type_Reference (Ent, Tref, Left, Right);\n+                  end if;\n+\n+                  if Present (Tref) then\n+\n+                     --  Case of standard entity, output name\n+\n+                     if Sloc (Tref) = Standard_Location then\n+                        Write_Info_Char (Left);\n+                        Write_Info_Name (Chars (Tref));\n+                        Write_Info_Char (Right);\n+\n+                     --  Case of source entity, output location\n+\n+                     else\n+                        Write_Info_Char (Left);\n+                        Trunit := Get_Source_Unit (Sloc (Tref));\n+\n+                        if Trunit /= Curxu then\n+                           Write_Info_Nat (Dependency_Num (Trunit));\n+                           Write_Info_Char ('|');\n+                        end if;\n+\n+                        Write_Info_Nat\n+                          (Int (Get_Logical_Line_Number (Sloc (Tref))));\n+\n+                        declare\n+                           Ent  : Entity_Id := Tref;\n+                           Kind : constant Entity_Kind := Ekind (Ent);\n+                           Ctyp : Character := Xref_Entity_Letters (Kind);\n+\n+                        begin\n+                           if Ctyp = '+'\n+                             and then Present (Full_View (Ent))\n+                           then\n+                              Ent := Underlying_Type (Ent);\n+\n+                              if Present (Ent) then\n+                                 Ctyp := Xref_Entity_Letters (Ekind (Ent));\n+                              end if;\n+                           end if;\n+\n+                           Write_Info_Char (Ctyp);\n+                        end;\n+\n+                        Write_Info_Nat\n+                          (Int (Get_Column_Number (Sloc (Tref))));\n+\n+                        --  If the type comes from an instantiation,\n+                        --  add the corresponding info.\n+\n+                        Output_Instantiation_Refs (Sloc (Tref));\n+                        Write_Info_Char (Right);\n+                     end if;\n+                  end if;\n+               end Check_Type_Reference;\n+\n                -------------------------------\n                -- Output_Instantiation_Refs --\n                -------------------------------\n@@ -1397,12 +1524,21 @@ package body Lib.Xref is\n \n                --  Special handling for abstract types and operations\n \n-               if Is_Abstract (XE.Ent) then\n+               if Is_Overloadable (XE.Ent)\n+                 and then Is_Abstract_Subprogram (XE.Ent)\n+               then\n                   if Ctyp = 'U' then\n                      Ctyp := 'x';            --  abstract procedure\n \n                   elsif Ctyp = 'V' then\n                      Ctyp := 'y';            --  abstract function\n+                  end if;\n+\n+               elsif Is_Type (XE.Ent)\n+                 and then Is_Abstract_Type (XE.Ent)\n+               then\n+                  if Is_Interface (XE.Ent) then\n+                     Ctyp := 'h';\n \n                   elsif Ctyp = 'R' then\n                      Ctyp := 'H';            --  abstract type\n@@ -1705,59 +1841,21 @@ package body Lib.Xref is\n \n                      --  See if we have a type reference and if so output\n \n-                     Get_Type_Reference (XE.Ent, Tref, Left, Right);\n-\n-                     if Present (Tref) then\n-\n-                        --  Case of standard entity, output name\n-\n-                        if Sloc (Tref) = Standard_Location then\n-                           Write_Info_Char (Left);\n-                           Write_Info_Name (Chars (Tref));\n-                           Write_Info_Char (Right);\n+                     Check_Type_Reference (XE.Ent, False);\n \n-                        --  Case of source entity, output location\n-\n-                        else\n-                           Write_Info_Char (Left);\n-                           Trunit := Get_Source_Unit (Sloc (Tref));\n-\n-                           if Trunit /= Curxu then\n-                              Write_Info_Nat (Dependency_Num (Trunit));\n-                              Write_Info_Char ('|');\n-                           end if;\n-\n-                           Write_Info_Nat\n-                             (Int (Get_Logical_Line_Number (Sloc (Tref))));\n-\n-                           declare\n-                              Ent  : Entity_Id := Tref;\n-                              Kind : constant Entity_Kind := Ekind (Ent);\n-                              Ctyp : Character := Xref_Entity_Letters (Kind);\n-\n-                           begin\n-                              if Ctyp = '+'\n-                                and then Present (Full_View (Ent))\n-                              then\n-                                 Ent := Underlying_Type (Ent);\n-\n-                                 if Present (Ent) then\n-                                    Ctyp := Xref_Entity_Letters (Ekind (Ent));\n-                                 end if;\n-                              end if;\n-\n-                              Write_Info_Char (Ctyp);\n-                           end;\n-\n-                           Write_Info_Nat\n-                             (Int (Get_Column_Number (Sloc (Tref))));\n-\n-                           --  If the type comes from an instantiation,\n-                           --  add the corresponding info.\n+                     if Is_Record_Type (XE.Ent)\n+                       and then Present (Abstract_Interfaces (XE.Ent))\n+                     then\n+                        declare\n+                           Elmt : Elmt_Id;\n \n-                           Output_Instantiation_Refs (Sloc (Tref));\n-                           Write_Info_Char (Right);\n-                        end if;\n+                        begin\n+                           Elmt := First_Elmt (Abstract_Interfaces (XE.Ent));\n+                           while Present (Elmt) loop\n+                              Check_Type_Reference (Node (Elmt), True);\n+                              Next_Elmt (Elmt);\n+                           end loop;\n+                        end;\n                      end if;\n \n                      --  If the entity is an overriding operation, write"}, {"sha": "670eaf4d9ce21d4685203e418b02c2c80e5ccea8", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecf8118f79943fc2959e334dfdba109524e0f300/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecf8118f79943fc2959e334dfdba109524e0f300/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=ecf8118f79943fc2959e334dfdba109524e0f300", "patch": "@@ -114,6 +114,10 @@ package Lib.Xref is\n    --          enumeration literals (points to enum type)  LR={}\n    --          objects and components (points to type)     LR={}\n \n+   --          For a type that implements multiple interfaces, there is an\n+   --          entry of the form  LR=<> for each of the interfaces appearing\n+   --          in the type declaration.\n+\n    --          In the above list LR shows the brackets used in the output,\n    --          which has one of the two following forms:\n \n@@ -493,7 +497,7 @@ package Lib.Xref is\n    --    e     non-Boolean enumeration object  non_Boolean enumeration type\n    --    f     floating-point object           floating-point type\n    --    g     (unused)                        (unused)\n-   --    h     (unused)                        Abstract type\n+   --    h     Interface (Ada 2005)            Abstract type\n    --    i     signed integer object           signed integer type\n    --    j     (unused)                        (unused)\n    --    k     generic package                 package"}]}