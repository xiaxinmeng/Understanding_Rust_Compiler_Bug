{"sha": "6390c5047adb75960f86d56582e6322aaa4d9281", "node_id": "C_kwDOANBUbNoAKDYzOTBjNTA0N2FkYjc1OTYwZjg2ZDU2NTgyZTYzMjJhYWE0ZDkyODE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-18T08:36:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-27T08:24:12Z"}, "message": "Allow different vector types for stmt groups\n\nThis allows vectorization (in practice non-loop vectorization) to\nhave a stmt participate in different vector type vectorizations.\nIt allows us to remove vect_update_shared_vectype and replace it\nby pushing/popping STMT_VINFO_VECTYPE from SLP_TREE_VECTYPE around\nvect_analyze_stmt and vect_transform_stmt.\n\nFor data-ref the situation is a bit more complicated since we\nanalyze alignment info with a specific vector type in mind which\ndoesn't play well when that changes.\n\nSo the bulk of the change is passing down the actual vector type\nused for a vectorized access to the various accessors of alignment\ninfo, first and foremost dr_misalignment but also aligned_access_p,\nknown_alignment_for_access_p, vect_known_alignment_in_bytes and\nvect_supportable_dr_alignment.  I took the liberty to replace\nALL_CAPS macro accessors with the lower-case function invocations.\n\nThe actual changes to the behavior are in dr_misalignment which now\nis the place factoring in the negative step adjustment as well as\nhandling alignment queries for a vector type with bigger alignment\nrequirements than what we can (or have) analyze(d).\n\nvect_slp_analyze_node_alignment makes use of this and upon receiving\na vector type with a bigger alingment desire re-analyzes the DR\nwith respect to it but keeps an older more precise result if possible.\nIn this context it might be possible to do the analysis just once\nbut instead of analyzing with respect to a specific desired alignment\nlook for the biggest alignment we can compute a not unknown alignment.\n\nThe ChangeLog includes the functional changes but not the bulk due\nto the alignment accessor API changes - I hope that's something good.\n\n2021-09-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97351\n\tPR tree-optimization/97352\n\tPR tree-optimization/82426\n\t* tree-vectorizer.h (dr_misalignment): Add vector type\n\targument.\n\t(aligned_access_p): Likewise.\n\t(known_alignment_for_access_p): Likewise.\n\t(vect_supportable_dr_alignment): Likewise.\n\t(vect_known_alignment_in_bytes): Likewise.  Refactor.\n\t(DR_MISALIGNMENT): Remove.\n\t(vect_update_shared_vectype): Likewise.\n\t* tree-vect-data-refs.c (dr_misalignment): Refactor, handle\n\ta vector type with larger alignment requirement and apply\n\tthe negative step adjustment here.\n\t(vect_calculate_target_alignment): Remove.\n\t(vect_compute_data_ref_alignment): Get explicit vector type\n\targument, do not apply a negative step alignment adjustment\n\there.\n\t(vect_slp_analyze_node_alignment): Re-analyze alignment\n\twhen we re-visit the DR with a bigger desired alignment but\n\tkeep more precise results from smaller alignments.\n\t* tree-vect-slp.c (vect_update_shared_vectype): Remove.\n\t(vect_slp_analyze_node_operations_1): Do not update the\n\tshared vector type on stmts.\n\t* tree-vect-stmts.c (vect_analyze_stmt): Push/pop the\n\tvector type of an SLP node to the representative stmt-info.\n\t(vect_transform_stmt): Likewise.\n\n\t* gcc.target/i386/vect-pr82426.c: New testcase.\n\t* gcc.target/i386/vect-pr97352.c: Likewise.", "tree": {"sha": "b3f3817652f28f26ddf2bc354c87f37c68736fb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3f3817652f28f26ddf2bc354c87f37c68736fb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6390c5047adb75960f86d56582e6322aaa4d9281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6390c5047adb75960f86d56582e6322aaa4d9281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6390c5047adb75960f86d56582e6322aaa4d9281", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6390c5047adb75960f86d56582e6322aaa4d9281/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7b8d7020052110e5717230104e647f6235dd2c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7b8d7020052110e5717230104e647f6235dd2c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7b8d7020052110e5717230104e647f6235dd2c1"}], "stats": {"total": 448, "additions": 235, "deletions": 213}, "files": [{"sha": "03b10adff9b6bad6dafac9210cf7fcbe8cefcbf4", "filename": "gcc/testsuite/gcc.target/i386/vect-pr82426.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-pr82426.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-pr82426.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-pr82426.c?ref=6390c5047adb75960f86d56582e6322aaa4d9281", "patch": "@@ -0,0 +1,31 @@\n+/* i?86 does not have V2SF, x32 does though.  */\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O3 -mavx -mfma\" } */\n+\n+struct Matrix\n+{\n+  float m11;\n+  float m12;\n+  float m21;\n+  float m22;\n+  float dx;\n+  float dy;\n+};\n+\n+struct Matrix multiply(const struct Matrix *a, const struct Matrix *b)\n+{\n+  struct Matrix out;\n+  out.m11 = a->m11*b->m11 + a->m12*b->m21;\n+  out.m12 = a->m11*b->m12 + a->m12*b->m22;\n+  out.m21 = a->m21*b->m11 + a->m22*b->m21;\n+  out.m22 = a->m21*b->m12 + a->m22*b->m22;\n+\n+  out.dx = a->dx*b->m11  + a->dy*b->m21 + b->dx;\n+  out.dy = a->dx*b->m12  + a->dy*b->m22 + b->dy;\n+  return out;\n+}\n+\n+/* The whole kernel should be vectorized with V4SF and V2SF operations.  */\n+/* { dg-final { scan-assembler-times \"vadd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vmul\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vfma\" 2 } } */"}, {"sha": "d0e120600dbcc580bece74d4b4ea2763262b4c58", "filename": "gcc/testsuite/gcc.target/i386/vect-pr97352.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-pr97352.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-pr97352.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-pr97352.c?ref=6390c5047adb75960f86d56582e6322aaa4d9281", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mavx\" } */\n+\n+double x[2], a[4], b[4], c[5];\n+\n+void foo ()\n+{\n+  a[0] = c[0];\n+  a[1] = c[1];\n+  a[2] = c[0];\n+  a[3] = c[1];\n+  b[0] = c[2];\n+  b[1] = c[3];\n+  b[2] = c[2];\n+  b[3] = c[3];\n+  x[0] = c[4];\n+  x[1] = c[4];\n+}\n+\n+/* We should vectorize all three stores and the load from c apart\n+   from c[4] which should be duped.  */\n+/* { dg-final { scan-assembler-times \"vmov.pd\" 4 } } */"}, {"sha": "a0366fddbf36e8c94066a6fbfbf099051c54233d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 119, "deletions": 108, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=6390c5047adb75960f86d56582e6322aaa4d9281", "patch": "@@ -887,37 +887,53 @@ vect_slp_analyze_instance_dependence (vec_info *vinfo, slp_instance instance)\n   return res;\n }\n \n-/* Return the misalignment of DR_INFO.  */\n+/* Return the misalignment of DR_INFO accessed in VECTYPE.  */\n \n int\n-dr_misalignment (dr_vec_info *dr_info)\n+dr_misalignment (dr_vec_info *dr_info, tree vectype)\n {\n+  HOST_WIDE_INT diff = 0;\n+  /* Alignment is only analyzed for the first element of a DR group,\n+     use that but adjust misalignment by the offset of the access.  */\n   if (STMT_VINFO_GROUPED_ACCESS (dr_info->stmt))\n     {\n       dr_vec_info *first_dr\n \t= STMT_VINFO_DR_INFO (DR_GROUP_FIRST_ELEMENT (dr_info->stmt));\n-      int misalign = first_dr->misalignment;\n-      gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n-      if (misalign == DR_MISALIGNMENT_UNKNOWN)\n-\treturn misalign;\n       /* vect_analyze_data_ref_accesses guarantees that DR_INIT are\n \t INTEGER_CSTs and the first element in the group has the lowest\n-\t address.  Likewise vect_compute_data_ref_alignment will\n-\t have ensured that target_alignment is constant and otherwise\n-\t set misalign to DR_MISALIGNMENT_UNKNOWN.  */\n-      HOST_WIDE_INT diff = (TREE_INT_CST_LOW (DR_INIT (dr_info->dr))\n-\t\t\t    - TREE_INT_CST_LOW (DR_INIT (first_dr->dr)));\n+\t address.  */\n+      diff = (TREE_INT_CST_LOW (DR_INIT (dr_info->dr))\n+\t      - TREE_INT_CST_LOW (DR_INIT (first_dr->dr)));\n       gcc_assert (diff >= 0);\n-      unsigned HOST_WIDE_INT target_alignment_c\n-\t= first_dr->target_alignment.to_constant ();\n-      return (misalign + diff) % target_alignment_c;\n-    }\n-  else\n-    {\n-      int misalign = dr_info->misalignment;\n-      gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n-      return misalign;\n+      dr_info = first_dr;\n     }\n+\n+  int misalign = dr_info->misalignment;\n+  gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n+  if (misalign == DR_MISALIGNMENT_UNKNOWN)\n+    return misalign;\n+\n+  /* If the access is only aligned for a vector type with smaller alignment\n+     requirement the access has unknown misalignment.  */\n+  if (maybe_lt (dr_info->target_alignment * BITS_PER_UNIT,\n+\t\ttargetm.vectorize.preferred_vector_alignment (vectype)))\n+    return DR_MISALIGNMENT_UNKNOWN;\n+\n+  /* If this is a backward running DR then first access in the larger\n+     vectype actually is N-1 elements before the address in the DR.\n+     Adjust misalign accordingly.  */\n+  poly_int64 misalignment = misalign + diff;\n+  if (tree_int_cst_sgn (DR_STEP (dr_info->dr)) < 0)\n+    misalignment += ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n+\t\t     * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n+\n+  /* vect_compute_data_ref_alignment will have ensured that target_alignment\n+     is constant and otherwise set misalign to DR_MISALIGNMENT_UNKNOWN.  */\n+  unsigned HOST_WIDE_INT target_alignment_c\n+    = dr_info->target_alignment.to_constant ();\n+  if (!known_misalignment (misalignment, target_alignment_c, &misalign))\n+    return DR_MISALIGNMENT_UNKNOWN;\n+  return misalign;\n }\n \n /* Record the base alignment guarantee given by DRB, which occurs\n@@ -978,34 +994,26 @@ vect_record_base_alignments (vec_info *vinfo)\n     }\n }\n \n-/* Return the target alignment for the vectorized form of DR_INFO.  */\n-\n-static poly_uint64\n-vect_calculate_target_alignment (dr_vec_info *dr_info)\n-{\n-  tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n-  return targetm.vectorize.preferred_vector_alignment (vectype);\n-}\n-\n /* Function vect_compute_data_ref_alignment\n \n-   Compute the misalignment of the data reference DR_INFO.\n+   Compute the misalignment of the data reference DR_INFO when vectorizing\n+   with VECTYPE.\n \n    Output:\n-   1. DR_MISALIGNMENT (DR_INFO) is defined.\n+   1. initialized misalignment info for DR_INFO\n \n    FOR NOW: No analysis is actually performed. Misalignment is calculated\n    only for trivial cases. TODO.  */\n \n static void\n-vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n+vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n+\t\t\t\t tree vectype)\n {\n   stmt_vec_info stmt_info = dr_info->stmt;\n   vec_base_alignments *base_alignments = &vinfo->base_alignments;\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   class loop *loop = NULL;\n   tree ref = DR_REF (dr_info->dr);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1024,7 +1032,8 @@ vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n   bool step_preserves_misalignment_p;\n \n   poly_uint64 vector_alignment\n-    = exact_div (vect_calculate_target_alignment (dr_info), BITS_PER_UNIT);\n+    = exact_div (targetm.vectorize.preferred_vector_alignment (vectype),\n+\t\t BITS_PER_UNIT);\n   SET_DR_TARGET_ALIGNMENT (dr_info, vector_alignment);\n \n   /* If the main loop has peeled for alignment we have no way of knowing\n@@ -1147,14 +1156,6 @@ vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n   poly_int64 misalignment\n     = base_misalignment + wi::to_poly_offset (drb->init).force_shwi ();\n \n-  /* If this is a backward running DR then first access in the larger\n-     vectype actually is N-1 elements before the address in the DR.\n-     Adjust misalign accordingly.  */\n-  if (tree_int_cst_sgn (drb->step) < 0)\n-    /* PLUS because STEP is negative.  */\n-    misalignment += ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n-\t\t     * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n-\n   unsigned int const_misalignment;\n   if (!known_misalignment (misalignment, vect_align_c, &const_misalignment))\n     {\n@@ -1169,7 +1170,7 @@ vect_compute_data_ref_alignment (vec_info *vinfo, dr_vec_info *dr_info)\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t     \"misalign = %d bytes of ref %T\\n\",\n-\t\t     DR_MISALIGNMENT (dr_info), ref);\n+\t\t     const_misalignment, ref);\n \n   return;\n }\n@@ -1237,14 +1238,15 @@ vect_update_misalignment_for_peel (dr_vec_info *dr_info,\n     }\n \n   unsigned HOST_WIDE_INT alignment;\n+  tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n   if (DR_TARGET_ALIGNMENT (dr_info).is_constant (&alignment)\n-      && known_alignment_for_access_p (dr_info)\n-      && known_alignment_for_access_p (dr_peel_info))\n+      && known_alignment_for_access_p (dr_info, vectype)\n+      && known_alignment_for_access_p (dr_peel_info, vectype))\n     {\n-      int misal = DR_MISALIGNMENT (dr_info);\n+      int misal = dr_misalignment (dr_info, vectype);\n       misal += npeel * TREE_INT_CST_LOW (DR_STEP (dr_info->dr));\n       misal &= alignment - 1;\n-      SET_DR_MISALIGNMENT (dr_info, misal);\n+      set_dr_misalignment (dr_info, misal);\n       return;\n     }\n \n@@ -1316,31 +1318,32 @@ vector_alignment_reachable_p (dr_vec_info *dr_info)\n       int elem_size, mis_in_elements;\n \n       /* FORNOW: handle only known alignment.  */\n-      if (!known_alignment_for_access_p (dr_info))\n+      if (!known_alignment_for_access_p (dr_info, vectype))\n \treturn false;\n \n       poly_uint64 nelements = TYPE_VECTOR_SUBPARTS (vectype);\n       poly_uint64 vector_size = GET_MODE_SIZE (TYPE_MODE (vectype));\n       elem_size = vector_element_size (vector_size, nelements);\n-      mis_in_elements = DR_MISALIGNMENT (dr_info) / elem_size;\n+      mis_in_elements = dr_misalignment (dr_info, vectype) / elem_size;\n \n       if (!multiple_p (nelements - mis_in_elements, DR_GROUP_SIZE (stmt_info)))\n \treturn false;\n     }\n \n   /* If misalignment is known at the compile time then allow peeling\n      only if natural alignment is reachable through peeling.  */\n-  if (known_alignment_for_access_p (dr_info) && !aligned_access_p (dr_info))\n+  if (known_alignment_for_access_p (dr_info, vectype)\n+      && !aligned_access_p (dr_info, vectype))\n     {\n       HOST_WIDE_INT elmsize =\n \t\tint_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t                   \"data size = %wd. misalignment = %d.\\n\", elmsize,\n-\t\t\t   DR_MISALIGNMENT (dr_info));\n+\t\t\t   dr_misalignment (dr_info, vectype));\n \t}\n-      if (DR_MISALIGNMENT (dr_info) % elmsize)\n+      if (dr_misalignment (dr_info, vectype) % elmsize)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1349,7 +1352,7 @@ vector_alignment_reachable_p (dr_vec_info *dr_info)\n \t}\n     }\n \n-  if (!known_alignment_for_access_p (dr_info))\n+  if (!known_alignment_for_access_p (dr_info, vectype))\n     {\n       tree type = TREE_TYPE (DR_REF (dr_info->dr));\n       bool is_packed = not_size_aligned (DR_REF (dr_info->dr));\n@@ -1441,8 +1444,9 @@ vect_peeling_hash_insert (hash_table<peel_info_hasher> *peeling_htab,\n {\n   struct _vect_peel_info elem, *slot;\n   _vect_peel_info **new_slot;\n+  tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n   bool supportable_dr_alignment\n-    = vect_supportable_dr_alignment (loop_vinfo, dr_info, true);\n+    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype, true);\n \n   elem.npeel = npeel;\n   slot = peeling_htab->find (&elem);\n@@ -1508,7 +1512,7 @@ vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n \tcontinue;\n \n       int save_misalignment;\n-      save_misalignment = DR_MISALIGNMENT (dr_info);\n+      save_misalignment = dr_info->misalignment;\n       if (npeel == 0)\n \t;\n       else if (unknown_misalignment && dr_info == dr0_info)\n@@ -1625,10 +1629,11 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n       if (!vect_relevant_for_alignment_p (dr_info))\n \tcontinue;\n \n-      save_misalignment = DR_MISALIGNMENT (dr_info);\n+      save_misalignment = dr_info->misalignment;\n       vect_update_misalignment_for_peel (dr_info, dr0_info, npeel);\n+      tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n       supportable_dr_alignment\n-\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, false);\n+\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype, false);\n       SET_DR_MISALIGNMENT (dr_info, save_misalignment);\n \n       if (!supportable_dr_alignment)\n@@ -1782,7 +1787,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   bool one_misalignment_unknown = false;\n   bool one_dr_unsupportable = false;\n   dr_vec_info *unsupportable_dr_info = NULL;\n-  unsigned int mis, dr0_same_align_drs = 0, first_store_same_align_drs = 0;\n+  unsigned int dr0_same_align_drs = 0, first_store_same_align_drs = 0;\n   hash_table<peel_info_hasher> peeling_htab (1);\n \n   DUMP_VECT_SCOPE (\"vect_enhance_data_refs_alignment\");\n@@ -1878,12 +1883,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \tcontinue;\n \n       stmt_vec_info stmt_info = dr_info->stmt;\n+      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       supportable_dr_alignment\n-\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, true);\n+\t= vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype, true);\n       do_peeling = vector_alignment_reachable_p (dr_info);\n       if (do_peeling)\n         {\n-          if (known_alignment_for_access_p (dr_info))\n+\t  if (known_alignment_for_access_p (dr_info, vectype))\n             {\n \t      unsigned int npeel_tmp = 0;\n \t      bool negative = tree_int_cst_compare (DR_STEP (dr),\n@@ -1896,10 +1902,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      unsigned int target_align =\n \t\tDR_TARGET_ALIGNMENT (dr_info).to_constant ();\n \t      unsigned int dr_size = vect_get_scalar_dr_size (dr_info);\n-\t      mis = (negative\n-\t\t     ? DR_MISALIGNMENT (dr_info)\n-\t\t     : -DR_MISALIGNMENT (dr_info));\n-\t      if (DR_MISALIGNMENT (dr_info) != 0)\n+\t      unsigned int mis = dr_misalignment (dr_info, vectype);\n+\t      mis = negative ? mis : -mis;\n+\t      if (mis != 0)\n \t\tnpeel_tmp = (mis & (target_align - 1)) / dr_size;\n \n               /* For multiple types, it is possible that the bigger type access\n@@ -1982,7 +1987,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         }\n       else\n         {\n-          if (!aligned_access_p (dr_info))\n+\t  if (!aligned_access_p (dr_info, vectype))\n             {\n               if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2152,7 +2157,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   if (do_peeling)\n     {\n       stmt_vec_info stmt_info = dr0_info->stmt;\n-      if (known_alignment_for_access_p (dr0_info))\n+      if (known_alignment_for_access_p (dr0_info,\n+\t\t\t\t\tSTMT_VINFO_VECTYPE (stmt_info)))\n         {\n \t  bool negative = tree_int_cst_compare (DR_STEP (dr0_info->dr),\n \t\t\t\t\t\tsize_zero_node) < 0;\n@@ -2163,9 +2169,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  updating DR_MISALIGNMENT values.  The peeling factor is the\n                  vectorization factor minus the misalignment as an element\n                  count.  */\n-\t      mis = (negative\n-\t\t     ? DR_MISALIGNMENT (dr0_info)\n-\t\t     : -DR_MISALIGNMENT (dr0_info));\n+\t      unsigned int mis\n+\t\t= dr_misalignment (dr0_info, STMT_VINFO_VECTYPE (stmt_info));\n+\t      mis = negative ? mis : -mis;\n \t      /* If known_alignment_for_access_p then we have set\n \t         DR_MISALIGNMENT which is only done if we know it at compiler\n \t         time, so it is safe to assume target alignment is constant.\n@@ -2192,7 +2198,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \tdo_peeling = false;\n \n       /* Check if all datarefs are supportable and log.  */\n-      if (do_peeling && known_alignment_for_access_p (dr0_info) && npeel == 0)\n+      if (do_peeling\n+\t  && npeel == 0\n+\t  && known_alignment_for_access_p (dr0_info,\n+\t\t\t\t\t   STMT_VINFO_VECTYPE (stmt_info)))\n \treturn opt_result::success ();\n \n       /* Cost model #1 - honor --param vect-max-peeling-for-alignment.  */\n@@ -2304,36 +2313,31 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       FOR_EACH_VEC_ELT (datarefs, i, dr)\n         {\n \t  dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-\t  if (aligned_access_p (dr_info)\n+\t  stmt_vec_info stmt_info = dr_info->stmt;\n+\t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t  if (aligned_access_p (dr_info, vectype)\n \t      || !vect_relevant_for_alignment_p (dr_info))\n \t    continue;\n \n-\t  stmt_vec_info stmt_info = dr_info->stmt;\n \t  if (STMT_VINFO_STRIDED_P (stmt_info))\n \t    {\n \t      do_versioning = false;\n \t      break;\n \t    }\n \n \t  supportable_dr_alignment\n-\t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, false);\n-\n+\t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n+\t\t\t\t\t     false);\n           if (!supportable_dr_alignment)\n             {\n-              int mask;\n-              tree vectype;\n-\n-              if (known_alignment_for_access_p (dr_info)\n+\t      if (known_alignment_for_access_p (dr_info, vectype)\n                   || LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).length ()\n \t\t  >= (unsigned) param_vect_max_version_for_alignment_checks)\n                 {\n                   do_versioning = false;\n                   break;\n                 }\n \n-\t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t      gcc_assert (vectype);\n-\n \t      /* At present we don't support versioning for alignment\n \t\t with variable VF, since there's no guarantee that the\n \t\t VF is a power of two.  We could relax this if we added\n@@ -2363,7 +2367,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  Construct the mask needed for this test.  For example,\n                  GET_MODE_SIZE for the vector mode V4SI is 16 bytes so the\n                  mask must be 15 = 0xf. */\n-\t      mask = size - 1;\n+\t      int mask = size - 1;\n \n \t      /* FORNOW: use the same mask to test all potentially unaligned\n \t\t references in the loop.  */\n@@ -2444,7 +2448,8 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  if (STMT_VINFO_GROUPED_ACCESS (dr_info->stmt)\n \t      && DR_GROUP_FIRST_ELEMENT (dr_info->stmt) != dr_info->stmt)\n \t    continue;\n-\t  vect_compute_data_ref_alignment (loop_vinfo, dr_info);\n+\t  vect_compute_data_ref_alignment (loop_vinfo, dr_info,\n+\t\t\t\t\t   STMT_VINFO_VECTYPE (dr_info->stmt));\n \t}\n     }\n \n@@ -2460,21 +2465,30 @@ vect_slp_analyze_node_alignment (vec_info *vinfo, slp_tree node)\n   /* Alignment is maintained in the first element of the group.  */\n   stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n   first_stmt_info = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n-\n-  /* We need to commit to a vector type for the group now.  */\n-  if (is_a <bb_vec_info> (vinfo)\n-      && !vect_update_shared_vectype (first_stmt_info, SLP_TREE_VECTYPE (node)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"desired vector type conflicts with earlier one \"\n-\t\t\t \"for %G\", first_stmt_info->stmt);\n-      return false;\n-    }\n-\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n+  tree vectype = SLP_TREE_VECTYPE (node);\n+  poly_uint64 vector_alignment\n+    = exact_div (targetm.vectorize.preferred_vector_alignment (vectype),\n+\t\t BITS_PER_UNIT);\n   if (dr_info->misalignment == DR_MISALIGNMENT_UNINITIALIZED)\n-    vect_compute_data_ref_alignment (vinfo, dr_info);\n+    vect_compute_data_ref_alignment (vinfo, dr_info, SLP_TREE_VECTYPE (node));\n+  /* Re-analyze alignment when we're facing a vectorization with a bigger\n+     alignment requirement.  */\n+  else if (known_lt (dr_info->target_alignment, vector_alignment))\n+    {\n+      poly_uint64 old_target_alignment = dr_info->target_alignment;\n+      int old_misalignment = dr_info->misalignment;\n+      vect_compute_data_ref_alignment (vinfo, dr_info, SLP_TREE_VECTYPE (node));\n+      /* But keep knowledge about a smaller alignment.  */\n+      if (old_misalignment != DR_MISALIGNMENT_UNKNOWN\n+\t  && dr_info->misalignment == DR_MISALIGNMENT_UNKNOWN)\n+\t{\n+\t  dr_info->target_alignment = old_target_alignment;\n+\t  dr_info->misalignment = old_misalignment;\n+\t}\n+    }\n+  /* When we ever face unordered target alignments the first one wins in terms\n+     of analyzing and the other will become unknown in dr_misalignment.  */\n   return true;\n }\n \n@@ -3259,12 +3273,12 @@ vect_vfa_access_size (vec_info *vinfo, dr_vec_info *dr_info)\n       gcc_assert (DR_GROUP_FIRST_ELEMENT (stmt_vinfo) == stmt_vinfo);\n       access_size *= DR_GROUP_SIZE (stmt_vinfo) - DR_GROUP_GAP (stmt_vinfo);\n     }\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   if (STMT_VINFO_VEC_STMTS (stmt_vinfo).exists ()\n-      && (vect_supportable_dr_alignment (vinfo, dr_info, false)\n+      && (vect_supportable_dr_alignment (vinfo, dr_info, vectype, false)\n \t  == dr_explicit_realign_optimized))\n     {\n       /* We might access a full vector's worth.  */\n-      tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n       access_size += tree_to_uhwi (TYPE_SIZE_UNIT (vectype)) - ref_size;\n     }\n   return access_size;\n@@ -4733,7 +4747,7 @@ vect_create_addr_base_for_vector_ref (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t\t  unshare_expr (DR_REF (dr)));\n     }\n \n-  vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n+  vect_ptr_type = build_pointer_type (TREE_TYPE (DR_REF (dr)));\n   dest = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var, base_name);\n   addr_base = force_gimple_operand (addr_base, &seq, true, dest);\n   gimple_seq_add_seq (new_stmt_list, seq);\n@@ -6580,17 +6594,16 @@ vect_can_force_dr_alignment_p (const_tree decl, poly_uint64 alignment)\n \n enum dr_alignment_support\n vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n-                               bool check_aligned_accesses)\n+\t\t\t       tree vectype, bool check_aligned_accesses)\n {\n   data_reference *dr = dr_info->dr;\n   stmt_vec_info stmt_info = dr_info->stmt;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   machine_mode mode = TYPE_MODE (vectype);\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   class loop *vect_loop = NULL;\n   bool nested_in_vect_loop = false;\n \n-  if (aligned_access_p (dr_info) && !check_aligned_accesses)\n+  if (aligned_access_p (dr_info, vectype) && !check_aligned_accesses)\n     return dr_aligned;\n \n   /* For now assume all conditional loads/stores support unaligned\n@@ -6679,8 +6692,6 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n \t  && (!targetm.vectorize.builtin_mask_for_load\n \t      || targetm.vectorize.builtin_mask_for_load ()))\n \t{\n-\t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\n \t  /* If we are doing SLP then the accesses need not have the\n \t     same alignment, instead it depends on the SLP group size.  */\n \t  if (loop_vinfo\n@@ -6698,11 +6709,11 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n \t  else\n \t    return dr_explicit_realign_optimized;\n \t}\n-      if (!known_alignment_for_access_p (dr_info))\n+      if (!known_alignment_for_access_p (dr_info, vectype))\n \tis_packed = not_size_aligned (DR_REF (dr));\n \n       if (targetm.vectorize.support_vector_misalignment\n-\t    (mode, type, DR_MISALIGNMENT (dr_info), is_packed))\n+\t    (mode, type, dr_misalignment (dr_info, vectype), is_packed))\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n@@ -6711,11 +6722,11 @@ vect_supportable_dr_alignment (vec_info *vinfo, dr_vec_info *dr_info,\n       bool is_packed = false;\n       tree type = (TREE_TYPE (DR_REF (dr)));\n \n-      if (!known_alignment_for_access_p (dr_info))\n+      if (!known_alignment_for_access_p (dr_info, vectype))\n \tis_packed = not_size_aligned (DR_REF (dr));\n \n      if (targetm.vectorize.support_vector_misalignment\n-\t   (mode, type, DR_MISALIGNMENT (dr_info), is_packed))\n+\t   (mode, type, dr_misalignment (dr_info, vectype), is_packed))\n        return dr_unaligned_supported;\n     }\n "}, {"sha": "c70d06e5f20ceb413b670c57e4bb9bad6d9290e9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6390c5047adb75960f86d56582e6322aaa4d9281", "patch": "@@ -779,56 +779,6 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n   return 0;\n }\n \n-/* Try to assign vector type VECTYPE to STMT_INFO for BB vectorization.\n-   Return true if we can, meaning that this choice doesn't conflict with\n-   existing SLP nodes that use STMT_INFO.  */\n-\n-bool\n-vect_update_shared_vectype (stmt_vec_info stmt_info, tree vectype)\n-{\n-  tree old_vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  if (old_vectype)\n-    return useless_type_conversion_p (vectype, old_vectype);\n-\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      /* We maintain the invariant that if any statement in the group is\n-\t used, all other members of the group have the same vector type.  */\n-      stmt_vec_info first_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      stmt_vec_info member_info = first_info;\n-      for (; member_info; member_info = DR_GROUP_NEXT_ELEMENT (member_info))\n-\tif (is_pattern_stmt_p (member_info)\n-\t    && !useless_type_conversion_p (vectype,\n-\t\t\t\t\t   STMT_VINFO_VECTYPE (member_info)))\n-\t  break;\n-\n-      if (!member_info)\n-\t{\n-\t  for (member_info = first_info; member_info;\n-\t       member_info = DR_GROUP_NEXT_ELEMENT (member_info))\n-\t    STMT_VINFO_VECTYPE (member_info) = vectype;\n-\t  return true;\n-\t}\n-    }\n-  else if (!is_pattern_stmt_p (stmt_info))\n-    {\n-      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n-      return true;\n-    }\n-\n-  if (dump_enabled_p ())\n-    {\n-      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t       \"Build SLP failed: incompatible vector\"\n-\t\t       \" types for: %G\", stmt_info->stmt);\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"    old vector type: %T\\n\", old_vectype);\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"    new vector type: %T\\n\", vectype);\n-    }\n-  return false;\n-}\n-\n /* Return true if call statements CALL1 and CALL2 are similar enough\n    to be combined into the same SLP group.  */\n \n@@ -4508,15 +4458,6 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n     return vectorizable_slp_permutation (vinfo, NULL, node, cost_vec);\n \n   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n-  if (is_a <bb_vec_info> (vinfo)\n-      && !vect_update_shared_vectype (stmt_info, SLP_TREE_VECTYPE (node)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"desired vector type conflicts with earlier one \"\n-\t\t\t \"for %G\", stmt_info->stmt);\n-      return false;\n-    }\n \n   bool dummy;\n   return vect_analyze_stmt (vinfo, stmt_info, &dummy,"}, {"sha": "a9c9e3d7c3737330957abea48f1dcbe929638417", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6390c5047adb75960f86d56582e6322aaa4d9281", "patch": "@@ -1026,8 +1026,9 @@ vect_get_store_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n \t\t     stmt_vector_for_cost *body_cost_vec)\n {\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int alignment_support_scheme\n-    = vect_supportable_dr_alignment (vinfo, dr_info, false);\n+    = vect_supportable_dr_alignment (vinfo, dr_info, vectype, false);\n \n   switch (alignment_support_scheme)\n     {\n@@ -1048,7 +1049,7 @@ vect_get_store_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n         /* Here, we assign an additional cost for the unaligned store.  */\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n \t\t\t\t\t  unaligned_store, stmt_info,\n-\t\t\t\t\t  DR_MISALIGNMENT (dr_info),\n+\t\t\t\t\t  dr_misalignment (dr_info, vectype),\n \t\t\t\t\t  vect_body);\n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1216,8 +1217,9 @@ vect_get_load_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n \t\t    bool record_prologue_costs)\n {\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int alignment_support_scheme\n-    = vect_supportable_dr_alignment (vinfo, dr_info, false);\n+    = vect_supportable_dr_alignment (vinfo, dr_info, vectype, false);\n \n   switch (alignment_support_scheme)\n     {\n@@ -1237,7 +1239,7 @@ vect_get_load_cost (vec_info *vinfo, stmt_vec_info stmt_info, int ncopies,\n         /* Here, we assign an additional cost for the unaligned load.  */\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n \t\t\t\t\t  unaligned_load, stmt_info,\n-\t\t\t\t\t  DR_MISALIGNMENT (dr_info),\n+\t\t\t\t\t  dr_misalignment (dr_info, vectype),\n \t\t\t\t\t  vect_body);\n \n         if (dump_enabled_p ())\n@@ -1984,8 +1986,8 @@ get_negative_load_store_type (vec_info *vinfo,\n       return VMAT_ELEMENTWISE;\n     }\n \n-  alignment_support_scheme = vect_supportable_dr_alignment (vinfo,\n-\t\t\t\t\t\t\t    dr_info, false);\n+  alignment_support_scheme = vect_supportable_dr_alignment (vinfo, dr_info,\n+\t\t\t\t\t\t\t    vectype, false);\n   if (alignment_support_scheme != dr_aligned\n       && alignment_support_scheme != dr_unaligned_supported)\n     {\n@@ -2169,7 +2171,8 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t     be a multiple of B and so we are guaranteed to access a\n \t     non-gap element in the same B-sized block.  */\n \t  if (overrun_p\n-\t      && gap < (vect_known_alignment_in_bytes (first_dr_info)\n+\t      && gap < (vect_known_alignment_in_bytes (first_dr_info,\n+\t\t\t\t\t\t       vectype)\n \t\t\t/ vect_get_scalar_dr_size (first_dr_info)))\n \t    overrun_p = false;\n \n@@ -2182,8 +2185,8 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t  if (overrun_p\n \t      && !masked_p\n \t      && (((alignment_support_scheme\n-\t\t      = vect_supportable_dr_alignment (vinfo,\n-\t\t\t\t\t\t       first_dr_info, false)))\n+\t\t      = vect_supportable_dr_alignment (vinfo, first_dr_info,\n+\t\t\t\t\t\t       vectype, false)))\n \t\t   == dr_aligned\n \t\t  || alignment_support_scheme == dr_unaligned_supported)\n \t      && known_eq (nunits, (group_size - gap) * 2)\n@@ -2240,7 +2243,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t same B-sized block.  */\n       if (would_overrun_p\n \t  && !masked_p\n-\t  && gap < (vect_known_alignment_in_bytes (first_dr_info)\n+\t  && gap < (vect_known_alignment_in_bytes (first_dr_info, vectype)\n \t\t    / vect_get_scalar_dr_size (first_dr_info)))\n \twould_overrun_p = false;\n \n@@ -2294,7 +2297,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n     *alignment_support_scheme = dr_unaligned_supported;\n   else\n     *alignment_support_scheme\n-      = vect_supportable_dr_alignment (vinfo, first_dr_info, false);\n+      = vect_supportable_dr_alignment (vinfo, first_dr_info, vectype, false);\n \n   if (vls_type != VLS_LOAD && first_stmt_info == stmt_info)\n     {\n@@ -2435,7 +2438,7 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t  *alignment_support_scheme\n \t    = vect_supportable_dr_alignment (vinfo,\n \t\t\t\t\t     STMT_VINFO_DR_INFO (stmt_info),\n-\t\t\t\t\t     false);\n+\t\t\t\t\t     vectype, false);\n \t}\n     }\n \n@@ -7907,7 +7910,7 @@ vectorizable_store (vec_info *vinfo,\n     alignment_support_scheme = dr_unaligned_supported;\n   else\n     alignment_support_scheme\n-      = vect_supportable_dr_alignment (vinfo, first_dr_info, false);\n+      = vect_supportable_dr_alignment (vinfo, first_dr_info, vectype, false);\n \n   gcc_assert (alignment_support_scheme);\n   vec_loop_masks *loop_masks\n@@ -8218,15 +8221,16 @@ vectorizable_store (vec_info *vinfo,\n \t\tvec_oprnd = result_chain[i];\n \n \t      align = known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));\n-\t      if (aligned_access_p (first_dr_info))\n+\t      if (aligned_access_p (first_dr_info, vectype))\n \t\tmisalign = 0;\n-\t      else if (DR_MISALIGNMENT (first_dr_info) == -1)\n+\t      else if (dr_misalignment (first_dr_info, vectype)\n+\t\t       == DR_MISALIGNMENT_UNKNOWN)\n \t\t{\n \t\t  align = dr_alignment (vect_dr_behavior (vinfo, first_dr_info));\n \t\t  misalign = 0;\n \t\t}\n \t      else\n-\t\tmisalign = DR_MISALIGNMENT (first_dr_info);\n+\t\tmisalign = dr_misalignment (first_dr_info, vectype);\n \t      if (dataref_offset == NULL_TREE\n \t\t  && TREE_CODE (dataref_ptr) == SSA_NAME)\n \t\tset_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n@@ -8303,7 +8307,7 @@ vectorizable_store (vec_info *vinfo,\n \t\t\t\t\t  dataref_offset\n \t\t\t\t\t  ? dataref_offset\n \t\t\t\t\t  : build_int_cst (ref_type, 0));\n-\t\t  if (aligned_access_p (first_dr_info))\n+\t\t  if (aligned_access_p (first_dr_info, vectype))\n \t\t    ;\n \t\t  else\n \t\t    TREE_TYPE (data_ref)\n@@ -9551,17 +9555,17 @@ vectorizable_load (vec_info *vinfo,\n \t\t      known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {\n-\t\t\tgcc_assert (aligned_access_p (first_dr_info));\n+\t\t\tgcc_assert (aligned_access_p (first_dr_info, vectype));\n \t\t\tmisalign = 0;\n \t\t      }\n-\t\t    else if (DR_MISALIGNMENT (first_dr_info) == -1)\n+\t\t    else if (dr_misalignment (first_dr_info, vectype) == -1)\n \t\t      {\n \t\t\talign = dr_alignment\n \t\t\t  (vect_dr_behavior (vinfo, first_dr_info));\n \t\t\tmisalign = 0;\n \t\t      }\n \t\t    else\n-\t\t      misalign = DR_MISALIGNMENT (first_dr_info);\n+\t\t      misalign = dr_misalignment (first_dr_info, vectype);\n \t\t    if (dataref_offset == NULL_TREE\n \t\t\t&& TREE_CODE (dataref_ptr) == SSA_NAME)\n \t\t      set_ptr_info_alignment (get_ptr_info (dataref_ptr),\n@@ -9624,7 +9628,8 @@ vectorizable_load (vec_info *vinfo,\n \t\t\tunsigned HOST_WIDE_INT gap\n \t\t\t  = DR_GROUP_GAP (first_stmt_info);\n \t\t\tunsigned int vect_align\n-\t\t\t  = vect_known_alignment_in_bytes (first_dr_info);\n+\t\t\t  = vect_known_alignment_in_bytes (first_dr_info,\n+\t\t\t\t\t\t\t   vectype);\n \t\t\tunsigned int scalar_dr_size\n \t\t\t  = vect_get_scalar_dr_size (first_dr_info);\n \t\t\t/* If there's no peeling for gaps but we have a gap\n@@ -10897,6 +10902,10 @@ vect_analyze_stmt (vec_info *vinfo,\n         gcc_unreachable ();\n     }\n \n+  tree saved_vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  if (node)\n+    STMT_VINFO_VECTYPE (stmt_info) = SLP_TREE_VECTYPE (node);\n+\n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n       gcall *call = dyn_cast <gcall *> (stmt_info->stmt);\n@@ -10967,6 +10976,9 @@ vect_analyze_stmt (vec_info *vinfo,\n \t      || vectorizable_phi (vinfo, stmt_info, NULL, node, cost_vec));\n     }\n \n+  if (node)\n+    STMT_VINFO_VECTYPE (stmt_info) = saved_vectype;\n+\n   if (!ok)\n     return opt_result::failure_at (stmt_info->stmt,\n \t\t\t\t   \"not vectorized:\"\n@@ -11005,6 +11017,10 @@ vect_transform_stmt (vec_info *vinfo,\n \n   gcc_assert (slp_node || !PURE_SLP_STMT (stmt_info));\n \n+  tree saved_vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  if (slp_node)\n+    STMT_VINFO_VECTYPE (stmt_info) = SLP_TREE_VECTYPE (slp_node);\n+\n   switch (STMT_VINFO_TYPE (stmt_info))\n     {\n     case type_demotion_vec_info_type:\n@@ -11123,16 +11139,19 @@ vect_transform_stmt (vec_info *vinfo,\n   if (!slp_node && vec_stmt)\n     gcc_assert (STMT_VINFO_VEC_STMTS (stmt_info).exists ());\n \n-  if (STMT_VINFO_TYPE (stmt_info) == store_vec_info_type)\n-    return is_store;\n+  if (STMT_VINFO_TYPE (stmt_info) != store_vec_info_type)\n+    {\n+      /* Handle stmts whose DEF is used outside the loop-nest that is\n+\t being vectorized.  */\n+      done = can_vectorize_live_stmts (vinfo, stmt_info, gsi, slp_node,\n+\t\t\t\t       slp_node_instance, true, NULL);\n+      gcc_assert (done);\n+    }\n \n-  /* Handle stmts whose DEF is used outside the loop-nest that is\n-     being vectorized.  */\n-  done = can_vectorize_live_stmts (vinfo, stmt_info, gsi, slp_node,\n-\t\t\t\t   slp_node_instance, true, NULL);\n-  gcc_assert (done);\n+  if (slp_node)\n+    STMT_VINFO_VECTYPE (stmt_info) = saved_vectype;\n \n-  return false;\n+  return is_store;\n }\n \n "}, {"sha": "ed4a7ff646cc8445534d06c282b940d156b4cdb0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6390c5047adb75960f86d56582e6322aaa4d9281/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6390c5047adb75960f86d56582e6322aaa4d9281", "patch": "@@ -1606,11 +1606,8 @@ set_dr_misalignment (dr_vec_info *dr_info, int val)\n   dr_info->misalignment = val;\n }\n \n-extern int dr_misalignment (dr_vec_info *dr_info);\n+extern int dr_misalignment (dr_vec_info *dr_info, tree vectype);\n \n-/* Reflects actual alignment of first access in the vectorized loop,\n-   taking into account peeling/versioning if applied.  */\n-#define DR_MISALIGNMENT(DR) dr_misalignment (DR)\n #define SET_DR_MISALIGNMENT(DR, VAL) set_dr_misalignment (DR, VAL)\n \n /* Only defined once DR_MISALIGNMENT is defined.  */\n@@ -1630,35 +1627,37 @@ set_dr_target_alignment (dr_vec_info *dr_info, poly_uint64 val)\n }\n #define SET_DR_TARGET_ALIGNMENT(DR, VAL) set_dr_target_alignment (DR, VAL)\n \n-/* Return true if data access DR_INFO is aligned to its target alignment\n-   (which may be less than a full vector).  */\n+/* Return true if data access DR_INFO is aligned to the targets\n+   preferred alignment for VECTYPE (which may be less than a full vector).  */\n \n static inline bool\n-aligned_access_p (dr_vec_info *dr_info)\n+aligned_access_p (dr_vec_info *dr_info, tree vectype)\n {\n-  return (DR_MISALIGNMENT (dr_info) == 0);\n+  return (dr_misalignment (dr_info, vectype) == 0);\n }\n \n-/* Return TRUE if the alignment of the data access is known, and FALSE\n+/* Return TRUE if the (mis-)alignment of the data access is known with\n+   respect to the targets preferred alignment for VECTYPE, and FALSE\n    otherwise.  */\n \n static inline bool\n-known_alignment_for_access_p (dr_vec_info *dr_info)\n+known_alignment_for_access_p (dr_vec_info *dr_info, tree vectype)\n {\n-  return (DR_MISALIGNMENT (dr_info) != DR_MISALIGNMENT_UNKNOWN);\n+  return (dr_misalignment (dr_info, vectype) != DR_MISALIGNMENT_UNKNOWN);\n }\n \n /* Return the minimum alignment in bytes that the vectorized version\n    of DR_INFO is guaranteed to have.  */\n \n static inline unsigned int\n-vect_known_alignment_in_bytes (dr_vec_info *dr_info)\n+vect_known_alignment_in_bytes (dr_vec_info *dr_info, tree vectype)\n {\n-  if (DR_MISALIGNMENT (dr_info) == DR_MISALIGNMENT_UNKNOWN)\n+  int misalignment = dr_misalignment (dr_info, vectype);\n+  if (misalignment == DR_MISALIGNMENT_UNKNOWN)\n     return TYPE_ALIGN_UNIT (TREE_TYPE (DR_REF (dr_info->dr)));\n-  if (DR_MISALIGNMENT (dr_info) == 0)\n+  else if (misalignment == 0)\n     return known_alignment (DR_TARGET_ALIGNMENT (dr_info));\n-  return DR_MISALIGNMENT (dr_info) & -DR_MISALIGNMENT (dr_info);\n+  return misalignment & -misalignment;\n }\n \n /* Return the behavior of DR_INFO with respect to the vectorization context\n@@ -1971,7 +1970,7 @@ extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info, unsigned int = 0);\n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, poly_uint64);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n-                                           (vec_info *, dr_vec_info *, bool);\n+\t\t\t\t   (vec_info *, dr_vec_info *, tree, bool);\n extern tree vect_get_smallest_scalar_type (stmt_vec_info, tree);\n extern opt_result vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n extern bool vect_slp_analyze_instance_dependence (vec_info *, slp_instance);\n@@ -2110,7 +2109,6 @@ extern bool can_duplicate_and_interleave_p (vec_info *, unsigned int, tree,\n extern void duplicate_and_interleave (vec_info *, gimple_seq *, tree,\n \t\t\t\t      const vec<tree> &, unsigned int, vec<tree> &);\n extern int vect_get_place_in_interleaving_chain (stmt_vec_info, stmt_vec_info);\n-extern bool vect_update_shared_vectype (stmt_vec_info, tree);\n extern slp_tree vect_create_new_slp_node (unsigned, tree_code);\n extern void vect_free_slp_tree (slp_tree);\n "}]}