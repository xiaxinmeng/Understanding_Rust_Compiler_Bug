{"sha": "d84db1ed8ab30d720ca46e008bb8864d06fac02b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg0ZGIxZWQ4YWIzMGQ3MjBjYTQ2ZTAwOGJiODg2NGQwNmZhYzAyYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-06-21T06:43:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-06-21T06:43:39Z"}, "message": "gimple-fold.c (gimple_extract_devirt_binfo_from_cst): Use types_same_for_odr.\n\n\t* gimple-fold.c (gimple_extract_devirt_binfo_from_cst): Use\n\ttypes_same_for_odr.\n\t* tree.c (decls_same_for_odr): New function.\n\t(same_for_edr): New function.\n\t(types_same_for_odr): New function.\n\t(get_binfo_at_offset): Use it.\n\t* tree.h (types_same_for_odr): Declare.\n\nFrom-SVN: r200288", "tree": {"sha": "bcd4e436084bd33e82d78d3f7a748097b5c85733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcd4e436084bd33e82d78d3f7a748097b5c85733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d84db1ed8ab30d720ca46e008bb8864d06fac02b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84db1ed8ab30d720ca46e008bb8864d06fac02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84db1ed8ab30d720ca46e008bb8864d06fac02b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84db1ed8ab30d720ca46e008bb8864d06fac02b/comments", "author": null, "committer": null, "parents": [{"sha": "bc6ad87f60c29b76fddc2a4c770c26291d399556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6ad87f60c29b76fddc2a4c770c26291d399556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc6ad87f60c29b76fddc2a4c770c26291d399556"}], "stats": {"total": 139, "additions": 136, "deletions": 3}, "files": [{"sha": "c18f056d06e2e6675c3877dcf42723454d3feb6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d84db1ed8ab30d720ca46e008bb8864d06fac02b", "patch": "@@ -1,3 +1,13 @@\n+2013-06-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimple-fold.c (gimple_extract_devirt_binfo_from_cst): Use\n+\ttypes_same_for_odr.\n+\t* tree.c (decls_same_for_odr): New function.\n+\t(same_for_edr): New function.\n+\t(types_same_for_odr): New function.\n+\t(get_binfo_at_offset): Use it.\n+\t* tree.h (types_same_for_odr): Declare.\n+\n 2013-06-20  Oleg Endo <oleg.endo@t-online.de>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "728d3610f11cdd57b6a02a2cb77192e7899c0a2e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d84db1ed8ab30d720ca46e008bb8864d06fac02b", "patch": "@@ -1038,7 +1038,7 @@ gimple_extract_devirt_binfo_from_cst (tree cst)\n       HOST_WIDE_INT pos, size;\n       tree fld;\n \n-      if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (expected_type))\n+      if (types_same_for_odr (type, expected_type))\n \tbreak;\n       if (offset < 0)\n \treturn NULL_TREE;"}, {"sha": "ab1173525c71396621f4888cf3a434d61660e62a", "filename": "gcc/tree.c", "status": "modified", "additions": 124, "deletions": 2, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d84db1ed8ab30d720ca46e008bb8864d06fac02b", "patch": "@@ -218,6 +218,7 @@ static void print_value_expr_statistics (void);\n static int type_hash_marked_p (const void *);\n static unsigned int type_hash_list (const_tree, hashval_t);\n static unsigned int attribute_hash_list (const_tree, hashval_t);\n+static bool decls_same_for_odr (tree decl1, tree decl2);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -11711,6 +11712,127 @@ lhd_gcc_personality (void)\n   return gcc_eh_personality_decl;\n }\n \n+/* For languages with One Definition Rule, work out if\n+   trees are actually the same even if the tree representation\n+   differs.  This handles only decls appearing in TYPE_NAME\n+   and TYPE_CONTEXT.  That is NAMESPACE_DECL, TYPE_DECL,\n+   RECORD_TYPE and IDENTIFIER_NODE.  */\n+\n+static bool\n+same_for_odr (tree t1, tree t2)\n+{\n+  if (t1 == t2)\n+    return true;\n+  if (!t1 || !t2)\n+    return false;\n+  /* C and C++ FEs differ by using IDENTIFIER_NODE and TYPE_DECL.  */\n+  if (TREE_CODE (t1) == IDENTIFIER_NODE\n+      && TREE_CODE (t2) == TYPE_DECL\n+      && DECL_FILE_SCOPE_P (t1))\n+    {\n+      t2 = DECL_NAME (t2);\n+      gcc_assert (TREE_CODE (t2) == IDENTIFIER_NODE);\n+    }\n+  if (TREE_CODE (t2) == IDENTIFIER_NODE\n+      && TREE_CODE (t1) == TYPE_DECL\n+      && DECL_FILE_SCOPE_P (t2))\n+    {\n+      t1 = DECL_NAME (t1);\n+      gcc_assert (TREE_CODE (t1) == IDENTIFIER_NODE);\n+    }\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+  if (TYPE_P (t1))\n+    return types_same_for_odr (t1, t2);\n+  if (DECL_P (t1))\n+    return decls_same_for_odr (t1, t2);\n+  return false;\n+}\n+\n+/* For languages with One Definition Rule, work out if\n+   decls are actually the same even if the tree representation\n+   differs.  This handles only decls appearing in TYPE_NAME\n+   and TYPE_CONTEXT.  That is NAMESPACE_DECL, TYPE_DECL,\n+   RECORD_TYPE and IDENTIFIER_NODE.  */\n+\n+static bool\n+decls_same_for_odr (tree decl1, tree decl2)\n+{\n+  if (decl1 && TREE_CODE (decl1) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (decl1))\n+    decl1 = DECL_ORIGINAL_TYPE (decl1);\n+  if (decl2 && TREE_CODE (decl2) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (decl2))\n+    decl2 = DECL_ORIGINAL_TYPE (decl2);\n+  if (decl1 == decl2)\n+    return true;\n+  if (!decl1 || !decl2)\n+    return false;\n+  gcc_checking_assert (DECL_P (decl1) && DECL_P (decl2));\n+  if (TREE_CODE (decl1) != TREE_CODE (decl2))\n+    return false;\n+  if (TREE_CODE (decl1) == TRANSLATION_UNIT_DECL)\n+    return true;\n+  if (TREE_CODE (decl1) != NAMESPACE_DECL\n+      && TREE_CODE (decl1) != TYPE_DECL)\n+    return false;\n+  if (!DECL_NAME (decl1))\n+    return false;\n+  gcc_checking_assert (TREE_CODE (DECL_NAME (decl1)) == IDENTIFIER_NODE);\n+  gcc_checking_assert (!DECL_NAME (decl2)\n+\t\t       ||  TREE_CODE (DECL_NAME (decl2)) == IDENTIFIER_NODE);\n+  if (DECL_NAME (decl1) != DECL_NAME (decl2))\n+    return false;\n+  return same_for_odr (DECL_CONTEXT (decl1),\n+\t\t       DECL_CONTEXT (decl2));\n+}\n+\n+/* For languages with One Definition Rule, work out if\n+   types are same even if the tree representation differs. \n+   This is non-trivial for LTO where minnor differences in\n+   the type representation may have prevented type merging\n+   to merge two copies of otherwise equivalent type.  */\n+\n+bool\n+types_same_for_odr (tree type1, tree type2)\n+{\n+  gcc_checking_assert (TYPE_P (type1) && TYPE_P (type2));\n+  type1 = TYPE_MAIN_VARIANT (type1);\n+  type2 = TYPE_MAIN_VARIANT (type2);\n+  if (type1 == type2)\n+    return true;\n+\n+  /* If types are not structuraly same, do not bother to contnue.\n+     Match in the remainder of code would mean ODR violation.  */\n+  if (!types_compatible_p (type1, type2))\n+    return false;\n+\n+#ifndef ENABLE_CHECKING\n+  if (!in_lto_p)\n+    return false;\n+#endif\n+\n+  /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n+     on the corresponding TYPE_STUB_DECL.  */\n+  if (TYPE_STUB_DECL (type1) != TYPE_STUB_DECL (type2)\n+      && (!TYPE_STUB_DECL (type1)\n+\t  || !TYPE_STUB_DECL (type2)\n+\t  || !TREE_PUBLIC (TYPE_STUB_DECL (type1))\n+\t  || !TREE_PUBLIC (TYPE_STUB_DECL (type2))))\n+    return false;\n+\n+  if (!TYPE_NAME (type1))\n+    return false;\n+  if (!decls_same_for_odr (TYPE_NAME (type1), TYPE_NAME (type2)))\n+    return false;\n+  if (!same_for_odr (TYPE_CONTEXT (type1), TYPE_CONTEXT (type2)))\n+    return false;\n+  /* When not in LTO the MAIN_VARIANT check should be the same.  */\n+  gcc_assert (in_lto_p);\n+    \n+  return true;\n+}\n+\n /* Try to find a base info of BINFO that would have its field decl at offset\n    OFFSET within the BINFO type and which is of EXPECTED_TYPE.  If it can be\n    found, return, otherwise return NULL_TREE.  */\n@@ -11726,7 +11848,7 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n       tree fld;\n       int i;\n \n-      if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (expected_type))\n+      if (types_same_for_odr (type, expected_type))\n \t  return binfo;\n       if (offset < 0)\n \treturn NULL_TREE;\n@@ -11756,7 +11878,7 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n \t{\n \t  tree base_binfo, found_binfo = NULL_TREE;\n \t  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-\t    if (TREE_TYPE (base_binfo) == TREE_TYPE (fld))\n+\t    if (types_same_for_odr (TREE_TYPE (base_binfo), TREE_TYPE (fld)))\n \t      {\n \t\tfound_binfo = base_binfo;\n \t\tbreak;"}, {"sha": "b4445170088e5398604af105b5491b9f6ae9d4bb", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d84db1ed8ab30d720ca46e008bb8864d06fac02b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d84db1ed8ab30d720ca46e008bb8864d06fac02b", "patch": "@@ -5974,6 +5974,7 @@ extern location_t tree_nonartificial_location (tree);\n extern tree block_ultimate_origin (const_tree);\n \n extern tree get_binfo_at_offset (tree, HOST_WIDE_INT, tree);\n+extern bool types_same_for_odr (tree type1, tree type2);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n extern bool contains_bitfld_component_ref_p (const_tree);"}]}