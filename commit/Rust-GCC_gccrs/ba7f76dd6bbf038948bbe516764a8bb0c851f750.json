{"sha": "ba7f76dd6bbf038948bbe516764a8bb0c851f750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE3Zjc2ZGQ2YmJmMDM4OTQ4YmJlNTE2NzY0YThiYjBjODUxZjc1MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-21T06:41:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-21T06:41:36Z"}, "message": "Replace current_vector_size with vec_info::vector_size\n\n2019-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vec_info::vector_size): New member variable.\n\t(vect_update_max_nunits): Update comment.\n\t(current_vector_size): Delete.\n\t* tree-vect-stmts.c (current_vector_size): Likewise.\n\t(get_vectype_for_scalar_type): Use vec_info::vector_size instead\n\tof current_vector_size.\n\t(get_mask_type_for_scalar_type): Likewise.\n\t* tree-vectorizer.c (try_vectorize_loop_1): Likewise.\n\t* tree-vect-loop.c (vect_update_vf_for_slp): Likewise.\n\t(vect_analyze_loop, vect_halve_mask_nunits): Likewise.\n\t(vect_double_mask_nunits, vect_transform_loop): Likewise.\n\t* tree-vect-slp.c (can_duplicate_and_interleave_p): Likewise.\n\t(vect_make_slp_decision, vect_slp_bb_region): Likewise.\n\nFrom-SVN: r277235", "tree": {"sha": "f3be76e89e790a406b0c57e1b4957c8d2c696686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3be76e89e790a406b0c57e1b4957c8d2c696686"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba7f76dd6bbf038948bbe516764a8bb0c851f750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba7f76dd6bbf038948bbe516764a8bb0c851f750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba7f76dd6bbf038948bbe516764a8bb0c851f750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba7f76dd6bbf038948bbe516764a8bb0c851f750/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d1473958808fe4714ec24991ac83ee6cbf45397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1473958808fe4714ec24991ac83ee6cbf45397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1473958808fe4714ec24991ac83ee6cbf45397"}], "stats": {"total": 93, "additions": 55, "deletions": 38}, "files": [{"sha": "fbde37cf4adfebef33d78196a49d840620492a80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba7f76dd6bbf038948bbe516764a8bb0c851f750", "patch": "@@ -1,3 +1,19 @@\n+2019-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vec_info::vector_size): New member variable.\n+\t(vect_update_max_nunits): Update comment.\n+\t(current_vector_size): Delete.\n+\t* tree-vect-stmts.c (current_vector_size): Likewise.\n+\t(get_vectype_for_scalar_type): Use vec_info::vector_size instead\n+\tof current_vector_size.\n+\t(get_mask_type_for_scalar_type): Likewise.\n+\t* tree-vectorizer.c (try_vectorize_loop_1): Likewise.\n+\t* tree-vect-loop.c (vect_update_vf_for_slp): Likewise.\n+\t(vect_analyze_loop, vect_halve_mask_nunits): Likewise.\n+\t(vect_double_mask_nunits, vect_transform_loop): Likewise.\n+\t* tree-vect-slp.c (can_duplicate_and_interleave_p): Likewise.\n+\t(vect_make_slp_decision, vect_slp_bb_region): Likewise.\n+\n 2019-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_double_mask_nunits): Take a vec_info."}, {"sha": "d073620befb2e3c5d355a74b9f2a7af01f363ee1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ba7f76dd6bbf038948bbe516764a8bb0c851f750", "patch": "@@ -1414,7 +1414,7 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Loop contains SLP and non-SLP stmts\\n\");\n       /* Both the vectorization factor and unroll factor have the form\n-\t current_vector_size * X for some rational X, so they must have\n+\t loop_vinfo->vector_size * X for some rational X, so they must have\n \t a common multiple.  */\n       vectorization_factor\n \t= force_common_multiple (vectorization_factor,\n@@ -2311,7 +2311,6 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n   auto_vector_sizes vector_sizes;\n \n   /* Autodetect first vector size we try.  */\n-  current_vector_size = 0;\n   targetm.vectorize.autovectorize_vector_sizes (&vector_sizes,\n \t\t\t\t\t\tloop->simdlen != 0);\n   unsigned int next_size = 0;\n@@ -2333,7 +2332,7 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n   unsigned n_stmts = 0;\n   poly_uint64 autodetected_vector_size = 0;\n   opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-  poly_uint64 first_vector_size = 0;\n+  poly_uint64 next_vector_size = 0;\n   while (1)\n     {\n       /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n@@ -2347,6 +2346,7 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \t  gcc_checking_assert (first_loop_vinfo == NULL);\n \t  return loop_vinfo;\n \t}\n+      loop_vinfo->vector_size = next_vector_size;\n \n       bool fatal = false;\n \n@@ -2365,7 +2365,6 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \t      if (first_loop_vinfo == NULL)\n \t\t{\n \t\t  first_loop_vinfo = loop_vinfo;\n-\t\t  first_vector_size = current_vector_size;\n \t\t  loop->aux = NULL;\n \t\t}\n \t      else\n@@ -2381,7 +2380,7 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \tdelete loop_vinfo;\n \n       if (next_size == 0)\n-\tautodetected_vector_size = current_vector_size;\n+\tautodetected_vector_size = loop_vinfo->vector_size;\n \n       if (next_size < vector_sizes.length ()\n \t  && known_eq (vector_sizes[next_size], autodetected_vector_size))\n@@ -2394,17 +2393,16 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \t}\n \n       if (next_size == vector_sizes.length ()\n-\t  || known_eq (current_vector_size, 0U))\n+\t  || known_eq (loop_vinfo->vector_size, 0U))\n \t{\n \t  if (first_loop_vinfo)\n \t    {\n-\t      current_vector_size = first_vector_size;\n \t      loop->aux = (loop_vec_info) first_loop_vinfo;\n \t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t   \"***** Choosing vector size \");\n-\t\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t\t  dump_dec (MSG_NOTE, first_loop_vinfo->vector_size);\n \t\t  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \t      return first_loop_vinfo;\n@@ -2414,13 +2412,13 @@ vect_analyze_loop (class loop *loop, loop_vec_info orig_loop_vinfo,\n \t}\n \n       /* Try the next biggest vector size.  */\n-      current_vector_size = vector_sizes[next_size++];\n+      next_vector_size = vector_sizes[next_size++];\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"***** Re-trying analysis with \"\n \t\t\t   \"vector size \");\n-\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t  dump_dec (MSG_NOTE, next_vector_size);\n \t  dump_printf (MSG_NOTE, \"\\n\");\n \t}\n     }\n@@ -7745,19 +7743,19 @@ loop_niters_no_overflow (loop_vec_info loop_vinfo)\n /* Return a mask type with half the number of elements as TYPE.  */\n \n tree\n-vect_halve_mask_nunits (vec_info *, tree type)\n+vect_halve_mask_nunits (vec_info *vinfo, tree type)\n {\n   poly_uint64 nunits = exact_div (TYPE_VECTOR_SUBPARTS (type), 2);\n-  return build_truth_vector_type (nunits, current_vector_size);\n+  return build_truth_vector_type (nunits, vinfo->vector_size);\n }\n \n /* Return a mask type with twice as many elements as TYPE.  */\n \n tree\n-vect_double_mask_nunits (vec_info *, tree type)\n+vect_double_mask_nunits (vec_info *vinfo, tree type)\n {\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (type) * 2;\n-  return build_truth_vector_type (nunits, current_vector_size);\n+  return build_truth_vector_type (nunits, vinfo->vector_size);\n }\n \n /* Record that a fully-masked version of LOOP_VINFO would need MASKS to\n@@ -8243,7 +8241,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"LOOP EPILOGUE VECTORIZED (VS=\");\n-\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t  dump_dec (MSG_NOTE, loop_vinfo->vector_size);\n \t  dump_printf (MSG_NOTE, \")\\n\");\n \t}\n     }\n@@ -8295,14 +8293,14 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  unsigned int ratio;\n \t  while (next_size < vector_sizes.length ()\n-\t\t && !(constant_multiple_p (current_vector_size,\n+\t\t && !(constant_multiple_p (loop_vinfo->vector_size,\n \t\t\t\t\t   vector_sizes[next_size], &ratio)\n \t\t      && eiters >= lowest_vf / ratio))\n \t    next_size += 1;\n \t}\n       else\n \twhile (next_size < vector_sizes.length ()\n-\t       && maybe_lt (current_vector_size, vector_sizes[next_size]))\n+\t       && maybe_lt (loop_vinfo->vector_size, vector_sizes[next_size]))\n \t  next_size += 1;\n \n       if (next_size == vector_sizes.length ())"}, {"sha": "29e68efb319b31e0892dd6407800fb5859196592", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ba7f76dd6bbf038948bbe516764a8bb0c851f750", "patch": "@@ -233,7 +233,7 @@ vect_get_place_in_interleaving_chain (stmt_vec_info stmt_info,\n    (if nonnull).  */\n \n bool\n-can_duplicate_and_interleave_p (vec_info *, unsigned int count,\n+can_duplicate_and_interleave_p (vec_info *vinfo, unsigned int count,\n \t\t\t\tmachine_mode elt_mode,\n \t\t\t\tunsigned int *nvectors_out,\n \t\t\t\ttree *vector_type_out,\n@@ -246,7 +246,7 @@ can_duplicate_and_interleave_p (vec_info *, unsigned int count,\n     {\n       scalar_int_mode int_mode;\n       poly_int64 elt_bits = elt_bytes * BITS_PER_UNIT;\n-      if (multiple_p (current_vector_size, elt_bytes, &nelts)\n+      if (multiple_p (vinfo->vector_size, elt_bytes, &nelts)\n \t  && int_mode_for_size (elt_bits, 0).exists (&int_mode))\n \t{\n \t  tree int_type = build_nonstandard_integer_type\n@@ -431,7 +431,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t    }\n \t  if ((dt == vect_constant_def\n \t       || dt == vect_external_def)\n-\t      && !current_vector_size.is_constant ()\n+\t      && !vinfo->vector_size.is_constant ()\n \t      && (TREE_CODE (type) == BOOLEAN_TYPE\n \t\t  || !can_duplicate_and_interleave_p (vinfo, stmts.length (),\n \t\t\t\t\t\t      TYPE_MODE (type))))\n@@ -2250,7 +2250,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       /* FORNOW: SLP if you can.  */\n-      /* All unroll factors have the form current_vector_size * X for some\n+      /* All unroll factors have the form vinfo->vector_size * X for some\n \t rational X, so they must have a common multiple.  */\n       unrolling_factor\n \t= force_common_multiple (unrolling_factor,\n@@ -2986,7 +2986,7 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n   auto_vector_sizes vector_sizes;\n \n   /* Autodetect first vector size we try.  */\n-  current_vector_size = 0;\n+  poly_uint64 next_vector_size = 0;\n   targetm.vectorize.autovectorize_vector_sizes (&vector_sizes, false);\n   unsigned int next_size = 0;\n \n@@ -3005,6 +3005,7 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \tbb_vinfo->shared->save_datarefs ();\n       else\n \tbb_vinfo->shared->check_datarefs ();\n+      bb_vinfo->vector_size = next_vector_size;\n \n       if (vect_slp_analyze_bb_1 (bb_vinfo, n_stmts, fatal)\n \t  && dbg_cnt (vect_slp))\n@@ -3018,7 +3019,7 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \t  unsigned HOST_WIDE_INT bytes;\n \t  if (dump_enabled_p ())\n \t    {\n-\t      if (current_vector_size.is_constant (&bytes))\n+\t      if (bb_vinfo->vector_size.is_constant (&bytes))\n \t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t\t\t \"basic block part vectorized using %wu byte \"\n \t\t\t\t \"vectors\\n\", bytes);\n@@ -3030,31 +3031,32 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \n \t  vectorized = true;\n \t}\n-      delete bb_vinfo;\n \n       if (next_size == 0)\n-\tautodetected_vector_size = current_vector_size;\n+\tautodetected_vector_size = bb_vinfo->vector_size;\n+\n+      delete bb_vinfo;\n \n       if (next_size < vector_sizes.length ()\n \t  && known_eq (vector_sizes[next_size], autodetected_vector_size))\n \tnext_size += 1;\n \n       if (vectorized\n \t  || next_size == vector_sizes.length ()\n-\t  || known_eq (current_vector_size, 0U)\n+\t  || known_eq (bb_vinfo->vector_size, 0U)\n \t  /* If vect_slp_analyze_bb_1 signaled that analysis for all\n \t     vector sizes will fail do not bother iterating.  */\n \t  || fatal)\n \treturn vectorized;\n \n       /* Try the next biggest vector size.  */\n-      current_vector_size = vector_sizes[next_size++];\n+      next_vector_size = vector_sizes[next_size++];\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"***** Re-trying analysis with \"\n \t\t\t   \"vector size \");\n-\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t  dump_dec (MSG_NOTE, next_vector_size);\n \t  dump_printf (MSG_NOTE, \"\\n\");\n \t}\n     }"}, {"sha": "d744a84fb2a06f0256db7bc4c6fde6234dbd86e7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ba7f76dd6bbf038948bbe516764a8bb0c851f750", "patch": "@@ -11133,22 +11133,20 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n   return vectype;\n }\n \n-poly_uint64 current_vector_size;\n-\n /* Function get_vectype_for_scalar_type.\n \n    Returns the vector type corresponding to SCALAR_TYPE as supported\n    by the target.  */\n \n tree\n-get_vectype_for_scalar_type (vec_info *, tree scalar_type)\n+get_vectype_for_scalar_type (vec_info *vinfo, tree scalar_type)\n {\n   tree vectype;\n   vectype = get_vectype_for_scalar_type_and_size (scalar_type,\n-\t\t\t\t\t\t  current_vector_size);\n+\t\t\t\t\t\t  vinfo->vector_size);\n   if (vectype\n-      && known_eq (current_vector_size, 0U))\n-    current_vector_size = GET_MODE_SIZE (TYPE_MODE (vectype));\n+      && known_eq (vinfo->vector_size, 0U))\n+    vinfo->vector_size = GET_MODE_SIZE (TYPE_MODE (vectype));\n   return vectype;\n }\n \n@@ -11166,7 +11164,7 @@ get_mask_type_for_scalar_type (vec_info *vinfo, tree scalar_type)\n     return NULL;\n \n   return build_truth_vector_type (TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t  current_vector_size);\n+\t\t\t\t  vinfo->vector_size);\n }\n \n /* Function get_same_sized_vectype"}, {"sha": "30dcc442c4c440c44ef3ba29a03182834229ba35", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ba7f76dd6bbf038948bbe516764a8bb0c851f750", "patch": "@@ -971,7 +971,7 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n   unsigned HOST_WIDE_INT bytes;\n   if (dump_enabled_p ())\n     {\n-      if (current_vector_size.is_constant (&bytes))\n+      if (loop_vinfo->vector_size.is_constant (&bytes))\n \tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t\t \"loop vectorized using %wu byte vectors\\n\", bytes);\n       else"}, {"sha": "59dced75c06dcb021bcf0437313e7620a98ddc8a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba7f76dd6bbf038948bbe516764a8bb0c851f750/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ba7f76dd6bbf038948bbe516764a8bb0c851f750", "patch": "@@ -326,6 +326,10 @@ class vec_info {\n   /* Cost data used by the target cost model.  */\n   void *target_cost_data;\n \n+  /* The vector size for this loop in bytes, or 0 if we haven't picked\n+     a size yet.  */\n+  poly_uint64 vector_size;\n+\n private:\n   stmt_vec_info new_stmt_vec_info (gimple *stmt);\n   void set_vinfo_for_stmt (gimple *, stmt_vec_info);\n@@ -1472,7 +1476,7 @@ vect_get_num_copies (loop_vec_info loop_vinfo, tree vectype)\n static inline void\n vect_update_max_nunits (poly_uint64 *max_nunits, poly_uint64 nunits)\n {\n-  /* All unit counts have the form current_vector_size * X for some\n+  /* All unit counts have the form vec_info::vector_size * X for some\n      rational X, so two unit sizes must have a common multiple.\n      Everything is a multiple of the initial value of 1.  */\n   *max_nunits = force_common_multiple (*max_nunits, nunits);\n@@ -1588,7 +1592,6 @@ extern dump_user_location_t find_loop_location (class loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n-extern poly_uint64 current_vector_size;\n extern tree get_vectype_for_scalar_type (vec_info *, tree);\n extern tree get_vectype_for_scalar_type_and_size (tree, poly_uint64);\n extern tree get_mask_type_for_scalar_type (vec_info *, tree);"}]}