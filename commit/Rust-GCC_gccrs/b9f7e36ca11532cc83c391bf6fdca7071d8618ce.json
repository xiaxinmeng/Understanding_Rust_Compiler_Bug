{"sha": "b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlmN2UzNmNhMTE1MzJjYzgzYzM5MWJmNmZkY2E3MDcxZDg2MThjZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-10-14T15:11:04Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-10-14T15:11:04Z"}, "message": "decl.c (runtime_exception_type_node, [...]): New global variables.\n\nTue Oct 13 03:50:28 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* decl.c (runtime_exception_type_node, error_exception_type_node):\n \tNew global variables.\n\t(init_decl_processing): Initialized.\n\t* expr.c (java_lang_expand_expr): Set caught exception type to\n \tnull if catch handler argument doesn't exit.\n\t* java-tree.def (SYNCHRONIZED_EXPR, THROW_EXPR): New Java specific\n \ttree codes.\n\t* java-tree.h (runtime_exception_type_node,\n \terror_exception_type_node): Global variables declared.\n\t(DECL_FUNCTION_THROWS): New macro.\n\t(DECL_FUNCTION_BODY): Modified comment.\n\t(DECL_SPECIFIC_COUNT): Likewise.\n\t(struct lang_decl): New field throws_list.\n\t(IS_UNCHECKED_EXPRESSION_P): New macro.\n\t* lex.c (java_lex): Generate location information for THROW_TK.\n\t* parse.h (PUSH_EXCEPTIONS, POP_EXCEPTIONS, IN_TRY_BLOCK_P,\n \tEXCEPTIONS_P): New macros.\n\t(enum jdep_code): New value JDEP_EXCEPTION.\n\t(BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT,\n \tBUILD_ASSIGN_EXCEPTION_INFO, BUILD_THROW, SET_WFL_OPERATOR,\n \tPATCH_METHOD_RETURN_ERROR): New macros.\n\t(patch_method_invocation_stmt): Added new argument to prototype.\n\t(patch_synchronized_statement, patch_throw_statement,\n \tcheck_thrown_exceptions, check_thrown_exceptions_do,\n \tpurge_unchecked_exceptions, check_throws_clauses): New function\n \tprototypes.\n\t* parse.y Fixed typo in keyword section.\n\t(throw:): Rule tagged <node>.\n\t(THROW_TK): Keyword tagged <operator>.\n\t(method_header:): Last argument to call to method_header passed\n \tfrom throws: rule.\n\t(throws:, class_type_list:, throw_statement:,\n \tsynchronized_statement:, synchronized:): Defined actions.\n\t(method_header): New local variable current. Register exceptions\n \tfrom throws clause.\n\t(java_complete_tree): Complete and verify exceptions from throws\n \tclause.\n\t(complete_class_report_errors): Error message on exceptions not\n \tfound\n\t(java_check_regular_methods): Fixed typo. Shortcut on private\n \toverriding methods. Changed error message on method\n \tredefinition. Check for throws clause compatibility.\n\t(check_throws_clauses): New function.\n\t(java_check_abstract_methods): Use DECL_NAME for wfl or current\n \tmethod. Changed error message on method redefinition.\n\t(currently_caught_type_list): New static variable.\n\t(java_complete_expand_methods): Purge unchecked exceptions from\n \tthrows clause list. Call PUSH_EXCEPTIONS before walk and\n \tPOP_EXCEPTIONS after.\n\t(resolve_qualified_expression_name): Pass new argument as NULL to\n \tpatch_method_invocation_stmt.\n\t(patch_method_invocation_stmt): New argument ref_decl. Invoke\n \tPATCH_METHOD_RETURN_ERROR when returning with error. Reverse\n \targument list when appropriate. Use new argument if non null to\n \tstore selected method decl.\n\t(patch_invoke): Convert if necessary args of builtin types before\n \tforming CALL_EXPR. Argument list no longer reversed here.\n\t(invocation_mode): Treat final methods as static methods.\n\t(java_complete_tree): New cases for THROW_EXPR: and\n \tSYNCHRONIZED_EXPR:. Check thrown exceptions when completing\n \tfunction call.\n\t(complete_function_arguments): No more RECORD_TYPE\n \tconversion. Function parameter nodes no longer saved.\n\t(valid_ref_assignconv_cast_p): Avoid handling null type.\n\t(patch_binop): Fixed null constant reference handling.\n\t(build_try_statement): Use BUILD_ASSIGN_EXCEPTION_INFO and\n \tBUILD_THROW macros.\n\t(patch_try_statement): Fixed comments. Record caught types in\n \tlist, push the list, expand try block and pop the list.\n\t(patch_synchronized_statement, patch_throw_statement,\n \tcheck_thrown_exceptions, check_thrown_exceptions_do,\n \tpurge_unchecked_exceptions): New functions.\n\t* typeck.c (lookup_argument_method): Allow WFL in place of method\n \tDECL_NAME during method definition check\nImplements the `synchronized' statement, the `throw' statements and\nthe `throws' clause. Fixes method invocation bugs.\n\nFrom-SVN: r23087", "tree": {"sha": "abdec231f9282d5f9096a1af817d6c94aeaa30b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abdec231f9282d5f9096a1af817d6c94aeaa30b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/comments", "author": null, "committer": null, "parents": [{"sha": "8e30605ec7cb35fe97378ce25dec6ef99920c6a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e30605ec7cb35fe97378ce25dec6ef99920c6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e30605ec7cb35fe97378ce25dec6ef99920c6a7"}], "stats": {"total": 701, "additions": 619, "deletions": 82}, "files": [{"sha": "64aa6e0473201cbdc09f494b77dbe66041bfba7d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -47,6 +47,83 @@ Tue Oct 13 23:34:12 1998  Jeffrey A Law  (law@cygnus.com)\n \t(disassemble_method): Undefine RET to avoid clash with\n \tconfig/i386/i386.h.\n \n+Tue Oct 13 03:50:28 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* decl.c (runtime_exception_type_node, error_exception_type_node):\n+ \tNew global variables.\n+\t(init_decl_processing): Initialized.\n+\t* expr.c (java_lang_expand_expr): Set caught exception type to\n+ \tnull if catch handler argument doesn't exit.\n+\t* java-tree.def (SYNCHRONIZED_EXPR, THROW_EXPR): New Java specific\n+ \ttree codes.\n+\t* java-tree.h (runtime_exception_type_node,\n+ \terror_exception_type_node): Global variables declared.\n+\t(DECL_FUNCTION_THROWS): New macro.\n+\t(DECL_FUNCTION_BODY): Modified comment.\n+\t(DECL_SPECIFIC_COUNT): Likewise.\n+\t(struct lang_decl): New field throws_list.\n+\t(IS_UNCHECKED_EXPRESSION_P): New macro.\n+\t* lex.c (java_lex): Generate location information for THROW_TK.\n+\t* parse.h (PUSH_EXCEPTIONS, POP_EXCEPTIONS, IN_TRY_BLOCK_P,\n+ \tEXCEPTIONS_P): New macros.\n+\t(enum jdep_code): New value JDEP_EXCEPTION.\n+\t(BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT,\n+ \tBUILD_ASSIGN_EXCEPTION_INFO, BUILD_THROW, SET_WFL_OPERATOR,\n+ \tPATCH_METHOD_RETURN_ERROR): New macros.\n+\t(patch_method_invocation_stmt): Added new argument to prototype.\n+\t(patch_synchronized_statement, patch_throw_statement,\n+ \tcheck_thrown_exceptions, check_thrown_exceptions_do,\n+ \tpurge_unchecked_exceptions, check_throws_clauses): New function\n+ \tprototypes.\n+\t* parse.y Fixed typo in keyword section.\n+\t(throw:): Rule tagged <node>.\n+\t(THROW_TK): Keyword tagged <operator>.\n+\t(method_header:): Last argument to call to method_header passed\n+ \tfrom throws: rule.\n+\t(throws:, class_type_list:, throw_statement:,\n+ \tsynchronized_statement:, synchronized:): Defined actions.\n+\t(method_header): New local variable current. Register exceptions\n+ \tfrom throws clause.\n+\t(java_complete_tree): Complete and verify exceptions from throws\n+ \tclause.\n+\t(complete_class_report_errors): Error message on exceptions not\n+ \tfound\n+\t(java_check_regular_methods): Fixed typo. Shortcut on private\n+ \toverriding methods. Changed error message on method\n+ \tredefinition. Check for throws clause compatibility.\n+\t(check_throws_clauses): New function.\n+\t(java_check_abstract_methods): Use DECL_NAME for wfl or current\n+ \tmethod. Changed error message on method redefinition.\n+\t(currently_caught_type_list): New static variable.\n+\t(java_complete_expand_methods): Purge unchecked exceptions from\n+ \tthrows clause list. Call PUSH_EXCEPTIONS before walk and\n+ \tPOP_EXCEPTIONS after.\n+\t(resolve_qualified_expression_name): Pass new argument as NULL to\n+ \tpatch_method_invocation_stmt.\n+\t(patch_method_invocation_stmt): New argument ref_decl. Invoke\n+ \tPATCH_METHOD_RETURN_ERROR when returning with error. Reverse\n+ \targument list when appropriate. Use new argument if non null to\n+ \tstore selected method decl.\n+\t(patch_invoke): Convert if necessary args of builtin types before\n+ \tforming CALL_EXPR. Argument list no longer reversed here.\n+\t(invocation_mode): Treat final methods as static methods.\n+\t(java_complete_tree): New cases for THROW_EXPR: and\n+ \tSYNCHRONIZED_EXPR:. Check thrown exceptions when completing\n+ \tfunction call.\n+\t(complete_function_arguments): No more RECORD_TYPE\n+ \tconversion. Function parameter nodes no longer saved.\n+\t(valid_ref_assignconv_cast_p): Avoid handling null type.\n+\t(patch_binop): Fixed null constant reference handling.\n+\t(build_try_statement): Use BUILD_ASSIGN_EXCEPTION_INFO and\n+ \tBUILD_THROW macros.\n+\t(patch_try_statement): Fixed comments. Record caught types in\n+ \tlist, push the list, expand try block and pop the list.\n+\t(patch_synchronized_statement, patch_throw_statement,\n+ \tcheck_thrown_exceptions, check_thrown_exceptions_do,\n+ \tpurge_unchecked_exceptions): New functions.\n+\t* typeck.c (lookup_argument_method): Allow WFL in place of method\n+ \tDECL_NAME during method definition check\n+\t\n 1998-10-09  Tom Tromey  <tromey@cygnus.com>\n \n \t* gjavah.c (decode_signature_piece): New function."}, {"sha": "4ec66398db255a9c3211caf331b17c8984a505ce", "filename": "gcc/java/decl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -250,6 +250,8 @@ tree object_type_node;\n tree object_ptr_type_node;\n tree string_type_node;\n tree throwable_type_node;\n+tree runtime_exception_type_node;\n+tree error_exception_type_node;\n \n tree boolean_type_node;\n \n@@ -518,6 +520,10 @@ init_decl_processing ()\n   string_type_node = lookup_class (get_identifier (\"java.lang.String\"));\n   class_type_node = lookup_class (get_identifier (\"java.lang.Class\"));\n   throwable_type_node = lookup_class (get_identifier (\"java.lang.Throwable\"));\n+  runtime_exception_type_node = \n+    lookup_class (get_identifier (\"java.lang.RuntimeException\"));\n+  error_exception_type_node = \n+    lookup_class (get_identifier (\"java.lang.Error\"));\n \n   methodtable_type = make_node (RECORD_TYPE);\n   layout_type (methodtable_type);"}, {"sha": "5759b6b7782ec69a2b83879a87dcf4f49561884a", "filename": "gcc/java/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -1750,7 +1750,7 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t    {\n \t      tree catch = java_get_catch_block (current, has_finally_p);\n \t      tree decl = BLOCK_EXPR_DECLS (catch);\n-\t      type = TREE_TYPE (TREE_TYPE (decl));\n+\t      type = (decl ? TREE_TYPE (TREE_TYPE (decl)) : NULL_TREE);\n \t    }\n \t  start_catch_handler (prepare_eh_table_type (type));\n \t  expand_expr_stmt (TREE_OPERAND (current, 0));\n@@ -1772,7 +1772,8 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       if (has_finally_p)\n \t{\n \t  tree finally = TREE_OPERAND (exp, 2);\n-\t  emit_label (label_rtx (FINALLY_EXPR_LABEL (finally)));\n+\t  if (FINALLY_EXPR_LABEL (finally))\n+\t    emit_label (label_rtx (FINALLY_EXPR_LABEL (finally)));\n \t  expand_expr_stmt (FINALLY_EXPR_BLOCK (finally));\n \t}\n       expand_end_all_catch ();"}, {"sha": "bdaf30077fcbe47acca278023de4f50046ee84a8", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -55,3 +55,12 @@ DEFTREECODE (CATCH_EXPR, \"catch\", '1', 1)\n    Operand 0 is the finally label.\n    Operand 1 is the finally block.  */\n DEFTREECODE (FINALLY_EXPR, \"finally\", 'e', 2) \n+\n+/* Synchronized statement.\n+   Operand 0 is the expression on which we whish to synchronize,\n+   Operand 1 is the synchronized expression block.  */\n+DEFTREECODE (SYNCHRONIZED_EXPR, \"synchronized\", 'e', 2)\n+\n+/* Throw statement.\n+   Operand 0 is the throw expresion.  */\n+DEFTREECODE (THROW_EXPR, \"throw\", '1', 1)"}, {"sha": "926d7e328a06a7694cf106e1eb9fe9a2c093b99b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -175,6 +175,8 @@ extern tree object_type_node;\n extern tree object_ptr_type_node;\n extern tree string_type_node;\n extern tree throwable_type_node;\n+extern tree runtime_exception_type_node;\n+extern tree error_exception_type_node;\n \n extern tree byte_array_type_node;\n extern tree short_array_type_node;\n@@ -317,8 +319,14 @@ struct lang_identifier\n #define DECL_MAX_STACK(DECL) (DECL_LANG_SPECIFIC(DECL)->max_stack)\n /* Number of local variable slots needed for the arguments of this function. */\n #define DECL_ARG_SLOT_COUNT(DECL) (DECL_LANG_SPECIFIC(DECL)->arg_slot_count)\n-/* Pointer to the function's COMPOUND_EXPR tree */\n+/* List of checked thrown exceptions, as specified with the `throws'\n+   keyword */\n+#define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->throws_list)\n+/* Pointer to the function's current's COMPOUND_EXPR tree (while\n+   completing its body) or the function's block */\n #define DECL_FUNCTION_BODY(DECL) (DECL_LANG_SPECIFIC(DECL)->function_decl_body)\n+/* How specific the function is (for method selection - Java source\n+   code front-end */\n #define DECL_SPECIFIC_COUNT(DECL) DECL_ARG_SLOT_COUNT(DECL)\n \n /* In a LABEL_DECL, a TREE_VEC that saves the type_map at that point. */\n@@ -391,6 +399,7 @@ struct lang_decl\n   long localvariables_offset;\n   int arg_slots;\n   int max_locals, max_stack, arg_slot_count;\n+  tree throws_list;\t\t/* Exception specified by `throws' */\n   tree function_decl_body;\t/* Hold all function's statements */\n };\n \n@@ -726,3 +735,8 @@ extern tree *type_map;\n \n /* Using a CATCH_EXPR node */\n #define CATCH_EXPR_GET_EXPR(NODE, V) (V ? LABELED_BLOCK_BODY (NODE) : (NODE))\n+\n+/* Non zero if TYPE is an unchecked expression */\n+#define IS_UNCHECKED_EXPRESSION_P(TYPE)\t\t\t\t\\\n+  (inherits_from_p ((TYPE), runtime_exception_type_node)\t\\\n+   || inherits_from_p ((TYPE), error_exception_type_node))"}, {"sha": "6ab4e4de335d04270c22d6b6774a127dc5c4a7e3", "filename": "gcc/java/lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -1209,6 +1209,7 @@ java_lex (java_lval)\n \t    case CONTINUE_TK:\n \t    case TRY_TK:\n \t    case CATCH_TK:\n+\t    case THROW_TK:\n \t      BUILD_OPERATOR (kw->token);\n \n \t    default:"}, {"sha": "09d25baa92e88fdcce4d1baaab1a32f45026efc9", "filename": "gcc/java/parse.h", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -262,6 +262,24 @@ extern tree stabilize_reference PROTO ((tree));\n   }\n #define POP_LOOP() ctxp->current_loop = TREE_CHAIN (ctxp->current_loop)\n \n+#define PUSH_EXCEPTIONS(E)\t\t\t\t\t\\\n+  currently_caught_type_list =\t\t\t\t\t\\\n+    tree_cons (NULL_TREE, (E), currently_caught_type_list);\n+\n+#define POP_EXCEPTIONS()\t\t\t\t\t\t\\\n+  currently_caught_type_list = TREE_CHAIN (currently_caught_type_list)\n+\n+/* Check that we're inside a try block */\n+#define IN_TRY_BLOCK_P()\t\t\t\t\\\n+  (currently_caught_type_list \t\t\t\t\\\n+   && ((TREE_VALUE (currently_caught_type_list) !=\t\\\n+\tDECL_FUNCTION_THROWS (current_function_decl))\t\\\n+       || TREE_CHAIN (currently_caught_type_list)))\n+\n+/* Check that we have exceptions in E */\n+#define EXCEPTIONS_P(E) ((E) ? TREE_VALUE (E) : NULL_TREE)\n+\n+\n /* Invocation modes, as returned by invocation_mode (). */\n enum {\n   INVOKE_STATIC,\n@@ -317,6 +335,7 @@ enum jdep_code {\n   JDEP_TYPE,\t\t\t/* Patch a random tree node type,\n                                    without the need for any specific\n                                    actions */\n+  JDEP_EXCEPTION,\t\t/* Patch exceptions specified by `throws' */\n };\n \n typedef struct _jdep {\n@@ -431,6 +450,51 @@ static jdeplist *reverse_jdep_list ();\n   build_new_invocation (wfl_string_buffer, \t\t\t\t      \\\n \t\t\t(ARG ? build_tree_list (NULL, (ARG)) : NULL_TREE))\n \n+/* For exception handling, build diverse function calls */\n+#define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n+\t\t     build_address_of (soft_monitorenter_node),\t\\\n+\t\t     build_tree_list (NULL_TREE, (ARG)));\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n+  }\n+\n+#define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n+\t\t     build_address_of (soft_monitorexit_node),\t\\\n+\t\t     build_tree_list (NULL_TREE, (ARG)));\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n+  }\n+\n+#define BUILD_ASSIGN_EXCEPTION_INFO(WHERE, TO)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    (WHERE) = build (MODIFY_EXPR, void_type_node, (TO),\t\\\n+\t\t     soft_exceptioninfo_call_node);\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\\\n+  }\n+\n+#define BUILD_THROW(WHERE, WHAT)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build (CALL_EXPR, void_type_node,\t\t\t\t\\\n+\t\t  build_address_of (throw_node),\t\t\t\\\n+\t\t  build_tree_list (NULL_TREE, (WHAT)), NULL_TREE);\t\\\n+    TREE_SIDE_EFFECTS ((WHERE)) = 1;\t\t\t\t\t\\\n+  }\n+\n+/* Set wfl_operator for the most accurate error location */\n+#define SET_WFL_OPERATOR(WHICH, NODE, WFL)\t\t\\\n+  EXPR_WFL_LINECOL (WHICH) =\t\t\t\t\\\n+    (TREE_CODE (WFL) == EXPR_WITH_FILE_LOCATION ?\t\\\n+     EXPR_WFL_LINECOL (WFL) : EXPR_WFL_LINECOL (NODE))\n+\n+#define PATCH_METHOD_RETURN_ERROR()\t\t\\\n+  {\t\t\t\t\t\t\\\n+    if (ret_decl)\t\t\t\t\\\n+      *ret_decl = NULL_TREE;\t\t\t\\\n+    return error_mark_node;\t\t\t\\\n+  }\n+     \n /* Parser context data structure. */\n struct parser_ctxt {\n \n@@ -527,7 +591,7 @@ static tree lookup_java_interface_method2 PROTO ((tree, tree));\n static tree resolve_expression_name PROTO ((tree));\n static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n static int check_class_interface_creation PROTO ((int, int, tree, tree, tree, tree));\n-static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, int *));\n+static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, int *, tree *));\n static int breakdown_qualified PROTO ((tree *, tree *, tree));\n static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));\n@@ -613,6 +677,12 @@ static tree patch_string PROTO ((tree));\n static tree build_jump_to_finally PROTO ((tree, tree, tree, tree));\n static tree build_try_statement PROTO ((int, tree, tree, tree));\n static tree patch_try_statement PROTO ((tree));\n+static tree patch_synchronized_statement PROTO ((tree, tree));\n+static tree patch_throw_statement PROTO ((tree, tree));\n+static void check_thrown_exceptions PROTO ((int, tree));\n+static int check_thrown_exceptions_do PROTO ((int, tree));\n+static void purge_unchecked_exceptions PROTO ((tree));\n+static void check_throws_clauses PROTO ((tree, tree, tree));\n \n void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));"}, {"sha": "ebca948957bca332e9dc3f1f5fccfccca865d433", "filename": "gcc/java/parse.y", "status": "modified", "additions": 431, "deletions": 76, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -195,7 +195,7 @@ static tree wfl_to_string = NULL_TREE;\n %type\t <node>\t\tclass_body_declarations\n %type    <node>\t\tclass_or_interface_type class_type class_type_list\n \t\t\tconstructor_declarator explicit_constructor_invocation\n-%type    <node>         dim_expr dim_exprs this_or_super\n+%type    <node>         dim_expr dim_exprs this_or_super throws\n \n %type\t <node>\t\tvariable_declarator_id variable_declarator\n \t\t\tvariable_declarators variable_initializer\n@@ -245,8 +245,9 @@ static tree wfl_to_string = NULL_TREE;\n %token   <operator>     BOOL_AND_TK AND_TK BOOL_OR_TK OR_TK INCR_TK PLUS_TK\n %token   <operator>     DECR_TK MINUS_TK MULT_TK DIV_TK XOR_TK REM_TK NEQ_TK\n %token   <operator>     NEG_TK REL_QM_TK REL_CL_TK NOT_TK LT_TK\n-%token   <operator>     OP_TK OSB_TK DOT_TK\n-%type    <operator>\tTHIS_TK SUPER_TK RETURN_TK BREAK_TK CONTINUE_TK CASE_TK%type\t<operator>     DEFAULT_TK TRY_TK CATCH_TK\n+%token   <operator>     OP_TK OSB_TK DOT_TK THROW_TK\n+%type    <operator>\tTHIS_TK SUPER_TK RETURN_TK BREAK_TK CONTINUE_TK \n+%type\t <operator>     CASE_TK DEFAULT_TK TRY_TK CATCH_TK SYNCHRONIZED_TK\n \n %type\t <node>\t\tmethod_body \n \t\n@@ -661,13 +662,13 @@ method_declaration:\n \n method_header:\t\n \ttype method_declarator throws\n-\t\t{ $$ = method_header (0, $1, $2, NULL); }\n+\t\t{ $$ = method_header (0, $1, $2, $3); }\n |\tVOID_TK method_declarator throws\n-\t\t{ $$ = method_header (0, void_type_node, $2, NULL); }\n+\t\t{ $$ = method_header (0, void_type_node, $2, $3); }\n |\tmodifiers type method_declarator throws\n-\t\t{ $$ = method_header ($1, $2, $3, NULL); }\n+\t\t{ $$ = method_header ($1, $2, $3, $4); }\n |\tmodifiers VOID_TK method_declarator throws\n-\t\t{ $$ = method_header ($1, void_type_node, $3, NULL); }\n+\t\t{ $$ = method_header ($1, void_type_node, $3, $4); }\n |\ttype error\n \t\t{RECOVER;}\n |\tmodifiers type error\n@@ -730,14 +731,18 @@ formal_parameter:\n ;\n \n throws:\n+\t\t{ $$ = NULL_TREE; }\n |\tTHROWS_TK class_type_list\n+\t\t{ $$ = $2; }\n |\tTHROWS_TK error\n \t\t{yyerror (\"Missing class type term\"); RECOVER;}\n ;\n \n class_type_list:\n \tclass_type\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n |\tclass_type_list C_TK class_type\n+\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n |\tclass_type_list C_TK error\n \t\t{yyerror (\"Missing class type term\"); RECOVER;}\n ;\n@@ -1395,7 +1400,10 @@ return_statement:\n \n throw_statement:\n \tTHROW_TK expression SC_TK\n-\t\t{ $$ = NULL_TREE;\t\t/* FIXME */ }\n+\t\t{ \n+\t\t  $$ = build1 (THROW_EXPR, NULL_TREE, $2);\n+\t\t  EXPR_WFL_LINECOL ($$) = $1.location;\n+\t\t}\n |\tTHROW_TK error\n \t\t{yyerror (\"Missing term\"); RECOVER;}\n |\tTHROW_TK expression error\n@@ -1404,7 +1412,11 @@ throw_statement:\n \n synchronized_statement:\n \tsynchronized OP_TK expression CP_TK block\n-\t\t{ $$ = NULL_TREE;\t\t/* FIXME */ }\n+\t\t{ \n+\t\t  $$ = build (SYNCHRONIZED_EXPR, NULL_TREE, $3, $5);\n+\t\t  EXPR_WFL_LINECOL ($$) = \n+\t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n+\t\t}\n |\tsynchronized OP_TK expression CP_TK error\n \t\t{yyerror (\"'{' expected\"); RECOVER;}\n |\tsynchronized error\n@@ -1415,10 +1427,11 @@ synchronized_statement:\n \t\t{yyerror (\"Missing term\"); RECOVER;}\n ;\n \n-synchronized:\t\t\t/* Test lval.sub_token here */\n+synchronized:\n \tMODIFIER_TK\n \t\t{\n-\t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", $1));\n+\t\t  if ((1 << $1) != ACC_SYNCHRONIZED)\n+\t\t    fatal (\"synchronized was '%d' - yyparse\", (1 << $1));\n \t\t}\n ;\n \n@@ -2852,7 +2865,7 @@ method_header (flags, type, mdecl, throws)\n   tree id = TREE_PURPOSE (mdecl);\n   tree this_class = TREE_TYPE (ctxp->current_parsed_class);\n   tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);\n-  tree meth_name, returned_type;\n+  tree meth_name, returned_type, current;\n   int saved_lineno;\n   \n   check_modifiers_consistency (flags);\n@@ -2957,6 +2970,24 @@ method_header (flags, type, mdecl, throws)\n     }\n   DECL_MAX_LOCALS (meth) = ctxp->formal_parameter_number+1;\n   lineno = saved_lineno;\n+\n+  /* Register exception specified by the `throws' keyword for\n+     resolution and set the method decl appropriate field to the list.\n+     Note: the grammar ensures that what we get here are class\n+     types. */\n+  if (throws)\n+    {\n+      throws = nreverse (throws);\n+      for (current = throws; current; current = TREE_CHAIN (current))\n+\t{\n+\t  register_incomplete_type (JDEP_EXCEPTION, TREE_VALUE (current),\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+\t  JDEP_GET_PATCH (CLASSD_LAST (ctxp->classd_list)) = \n+\t    &TREE_VALUE (current);\n+\t}\n+      DECL_FUNCTION_THROWS (meth) = throws;\n+    }\n+\n   /* We set the DECL_NAME to ID so we can track the location where\n      the function was declared. This allow us to report\n      redefinition error accurately. When method are verified,\n@@ -3456,6 +3487,24 @@ java_complete_class ()\n \t\t  tree_code_name [TREE_CODE (JDEP_DECL (dep))]));\n \t      break;\n \n+\t    case JDEP_EXCEPTION:\n+\t      /* Check for righteous inheritance here */\n+\t      if (!inherits_from_p (TREE_TYPE (decl), throwable_type_node))\n+\t\t {\n+\t\t   parse_error_context \n+\t\t     (JDEP_WFL (dep), \"Class `%s' in `throws' clause must be \"\n+\t\t      \"a subclass of class `java.lang.Throwable'\",\n+\t\t      IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))));\n+\t\t }\n+\t      else \n+\t\t{\n+\t\t  JDEP_APPLY_PATCH (dep, TREE_TYPE (decl));\n+\t\t  SOURCE_FRONTEND_DEBUG \n+\t\t    ((\"Completing `%s' `throws' argument node\",\n+\t\t      IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)))));\n+\t\t}\n+\t      break;\n+\n \t    default:\n \t      fatal (\"incomplete switch - java_complete_class\");\n \t    }\n@@ -3664,6 +3713,11 @@ complete_class_report_errors (dep)\n \t\t\t   (EXPR_WFL_NODE (JDEP_WFL (dep)))),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n+    case JDEP_EXCEPTION:\t/* As specified by `throws' */\n+      parse_error_context \n+\t  (JDEP_WFL (dep), \"Class `%s' not found in `throws'\",\n+\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))));\n+      break;\n     }\n }\n \n@@ -3731,7 +3785,7 @@ java_check_regular_methods (class_decl)\n       tree method_wfl = DECL_NAME (method);\n       int aflags;\n \n-      if (DECL_CONSTRUCTOR_P (method))\n+     if (DECL_CONSTRUCTOR_P (method))\n \tseen_constructor = 1;\n \n       /* Check for redefinitions */\n@@ -3741,16 +3795,24 @@ java_check_regular_methods (class_decl)\n       sig = build_java_argument_signature (TREE_TYPE (method));\n \n       found = lookup_argument_method (super_class, DECL_NAME (method), sig);\n-      if (! found)\n+\n+      /* Nothing overrides or it's a private method */\n+      if (!found || (found && METHOD_PRIVATE (found)))\n         continue;\n       /* Can't override a method with the same name and different return\n \t types. */\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n-\tparse_warning_context \n-\t  (method_wfl,\n-\t   \"Method `%s' redefined with different return type in class `%s'\",\n-\t   lang_printable_name (found),\n-\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t{\n+\t  char *t = strdup ((char *)lang_printable_name (TREE_TYPE \n+\t\t\t\t\t\t\t (TREE_TYPE (found))));\n+\t  parse_error_context \n+\t    (method_wfl, \n+\t     \"Method `%s' was defined with return type `%s' in class `%s'\", \n+\t     lang_printable_name (found), t,\n+\t     IDENTIFIER_POINTER \n+\t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t  free (t);\n+\t}\n \n       /* Can't override final. Can't override static. */\n       if (METHOD_FINAL (found) || METHOD_STATIC (found))\n@@ -3796,9 +3858,13 @@ java_check_regular_methods (class_decl)\n \t  continue;\n \t}\n \n+      /* Overriding methods must have compatible `throws' clauses on checked\n+\t exceptions, if any */\n+      check_throws_clauses (method, method_wfl, found);\n+\n       /* If the method has default access in an other package, then\n-      issue a warning that the current method doesn't override the one\n-      that was found elsewhere */\n+\t issue a warning that the current method doesn't override the\n+\t one that was found elsewhere */\n       aflags = get_access_flags_from_decl (found);\n       if ((!aflags || (aflags > ACC_PROTECTED))\n \t  && !class_in_current_package (DECL_CONTEXT (found)))\n@@ -3832,6 +3898,40 @@ java_check_regular_methods (class_decl)\n     }\n }\n \n+/* Return a non zero value if the `throws' clause of METHOD (if any)\n+   is incompatible with the `throws' clause of FOUND (if any).  */\n+\n+static void\n+check_throws_clauses (method, method_wfl, found)\n+     tree method, method_wfl, found;\n+{\n+  tree mthrows, fthrows;\n+\n+  for (mthrows = DECL_FUNCTION_THROWS (method);\n+       mthrows; mthrows = TREE_CHAIN (mthrows))\n+    {\n+      /* We don't verify unchecked expressions */\n+      if (IS_UNCHECKED_EXPRESSION_P (TREE_VALUE (mthrows)))\n+\tcontinue;\n+      /* Checked expression must be compatible */\n+      for (fthrows = DECL_FUNCTION_THROWS (found); \n+\t   fthrows; fthrows = TREE_CHAIN (fthrows))\n+\tif (inherits_from_p (TREE_VALUE (mthrows), TREE_VALUE (fthrows)))\n+\t  break;\n+      if (!fthrows)\n+\t{\n+\t  parse_error_context \n+\t    (method_wfl, \"Invalid checked exception class `%s' in \"\n+\t     \"`throws' clause. The exception must be a subclass of an \"\n+\t     \"exception thrown by `%s' from class `%s'\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))),\n+\t     lang_printable_name (found),\n+\t     IDENTIFIER_POINTER \n+\t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t}\n+    }\n+}\n+\n /* Check abstract method of interface INTERFACE */\n \n static void\n@@ -3844,24 +3944,26 @@ java_check_abstract_methods (interface)\n   for (method = TYPE_METHODS (interface); method; method = TREE_CHAIN (method))\n     {\n       char *csig;\n-      tree name = DECL_NAME (method);\n+      tree method_wfl = DECL_NAME (method);\n \n       /* 2- Check for double definition inside the defining interface */\n       if (check_method_redefinition (interface, method))\n \tcontinue;\n \n       /* 3- Overriding is OK as far as we preserve the return type and\n-\t the thrown exceptions */\n+\t the thrown exceptions (FIXME) */\n       found = lookup_java_interface_method2 (interface, method);\n       if (found)\n \t{\n+\t  char *t = strdup ((char *)lang_printable_name (TREE_TYPE \n+\t\t\t\t\t\t\t (TREE_TYPE (found))));\n \t  parse_error_context \n-\t    (lookup_cl (method),\n-\t     \"Method `%s' previously defined in interface `%s' is \"\n-\t     \"redefined with different return type in interface `%s'\",\n-\t     lang_printable_name (found),\n-\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))),\n-\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (interface))));\n+\t    (method_wfl,\n+\t     \"Method `%s' was defined with return type `%s' in class `%s \",\n+\t     lang_printable_name (found), t,\n+\t     IDENTIFIER_POINTER \n+\t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t  free (t);\n \t  continue;\n \t}\n     }\n@@ -4659,6 +4761,10 @@ java_complete_expand_methods ()\n     }\n }\n \n+/* Hold a list of catch clauses list. The first element of this list is\n+   the list of the catch clauses of the currently analysed try block. */\n+static tree currently_caught_type_list;\n+\n /* Complete and expand a method.  */\n \n static void\n@@ -4720,12 +4826,23 @@ java_complete_expand_method (mdecl)\n \t= (!METHOD_STATIC (mdecl) ? \n \t   BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl)) : NULL_TREE);\n \n+      /* Purge the `throws' list of unchecked exceptions */\n+      purge_unchecked_exceptions (mdecl);\n+\n+      /* Install exceptions thrown with `throws' */\n+      PUSH_EXCEPTIONS (DECL_FUNCTION_THROWS (mdecl));\n+\n       if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) && no_ac_found)\n \tjava_complete_tree (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)));\n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n \tsource_end_java_method ();\n+\n+      /* Pop the exceptions and sanity check */\n+      POP_EXCEPTIONS();\n+      if (currently_caught_type_list)\n+\tfatal (\"Exception list non empty - java_complete_expand_method\");\n     }\n }\n \n@@ -5007,7 +5124,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  if (complete_function_arguments (qual_wfl))\n \t    return 1;\n \t  *where_found = \n-\t    patch_method_invocation_stmt (qual_wfl, decl, type, &is_static);\n+\t    patch_method_invocation_stmt (qual_wfl, decl, type,\n+\t\t\t\t\t  &is_static, NULL);\n \t  if (*where_found == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (*where_found);\n@@ -5352,9 +5470,10 @@ maybe_access_field (decl, where, type)\n    used. IS_STATIC is set to 1 if the invoked function is static. */\n \n static tree\n-patch_method_invocation_stmt (patch, primary, where, is_static)\n+patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n      tree patch, primary, where;\n      int *is_static;\n+     tree *ret_decl;\n {\n   tree wfl = TREE_OPERAND (patch, 0);\n   tree args = TREE_OPERAND (patch, 1);\n@@ -5396,7 +5515,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t  parse_error_context (wfl, \"Can't search method `%s' in package \"\n \t\t\t       \"`%s'\",IDENTIFIER_POINTER (identifier),\n \t\t\t       IDENTIFIER_POINTER (remainder));\n-\t  return error_mark_node;\n+\t  PATCH_METHOD_RETURN_ERROR ();\n \t}\n       /* We're resolving a call from a type */\n       else if (RESOLVE_TYPE_NAME_P (wfl))\n@@ -5412,7 +5531,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t\t(identifier_wfl, \"Can't make static reference to method \"\n \t\t \"`%s' in interface `%s'\", IDENTIFIER_POINTER (identifier), \n \t\t IDENTIFIER_POINTER (name));\n-\t      return error_mark_node;\n+\t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n \t  /* Look the method up in the type selector. The method ought\n              to be static. */\n@@ -5427,7 +5546,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t\t lang_printable_name (TREE_TYPE (TREE_TYPE (list))), fct_name, \n \t\t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t      free (fct_name);\n-\t      return error_mark_node;\n+\t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n \t}\n       /* We're resolving an expression name */\n@@ -5438,7 +5557,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t  /* 1- Find the field to which the call applies */\n \t  field = resolve_field_access (wfl, NULL, &type);\n \t  if (field == error_mark_node)\n-\t    return error_mark_node;\n+\t    PATCH_METHOD_RETURN_ERROR ();\n \t  \n \t  /* 2- Do the layout of the class where the last field\n \t     was found, so we can search it. */\n@@ -5451,7 +5570,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t\t\t\t       identifier, args);\n \n \t  /* 4- Add the field as an argument */\n-\t  args = tree_cons (NULL_TREE, field, args);\n+\t  args = tree_cons (NULL_TREE, field, nreverse (args));\n \t}\n \n       /* CLASS_TYPE is used during the call to not_accessible_p and\n@@ -5475,7 +5594,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t      parse_error_context \n \t\t(wfl, \"Class `%s' not found in type declaration\",\n \t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n-\t      return error_mark_node;\n+\t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n \t  \n \t  /* Can't instantiate an abstract class */\n@@ -5484,7 +5603,7 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t      parse_error_context \n \t\t(wfl, \"Class `%s' is an abstract class. It can't be \"\n \t\t \"instantiated\", IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n-\t      return error_mark_node;\n+\t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n \t  class_to_search = TREE_TYPE (class_to_search);\n \t  lc = 1;\n@@ -5504,16 +5623,18 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \n       /* Don't continue if no method were found, as the next statement\n          can't be executed then. */\n-      if (!list) return error_mark_node;\n+      if (!list)\n+\tPATCH_METHOD_RETURN_ERROR ();\n \n       /* Check for static reference if non static methods */\n       if (check_for_static_method_reference (wfl, patch, list, \n \t\t\t\t\t     class_to_search, primary))\n-\treturn error_mark_node;\n+\tPATCH_METHOD_RETURN_ERROR ();\n \n       /* Non static/constructor methods are called with the current\n \t object extra argument. If method is resolved as a primary,\n \t use the primary otherwise use the current THIS. */\n+      args = nreverse (args);\n       if (!CALL_CONSTRUCTOR_P (patch) && !METHOD_STATIC (list))\n \targs = tree_cons (NULL_TREE, primary ? primary : current_this, args);\n \n@@ -5522,7 +5643,8 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \n   /* Merge point of all resolution schemes. If we have nothing, this\n      is an error, already signaled */\n-  if (!list) return error_mark_node;\n+  if (!list) \n+    PATCH_METHOD_RETURN_ERROR ();\n \n   /* Check accessibility, position the is_static flag, build and\n      return the call */\n@@ -5536,12 +5658,16 @@ patch_method_invocation_stmt (patch, primary, where, is_static)\n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class_type))), fct_name,\n \t IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n       free (fct_name);\n-      return error_mark_node;\n+      PATCH_METHOD_RETURN_ERROR ();\n     }\n   \n   if (is_static) \n     *is_static = METHOD_STATIC (list);\n   java_parser_context_restore_global ();\n+  /* Sometimes, we want the decl of the selected method. Such as for\n+     EH checking */\n+  if (ret_decl)\n+    *ret_decl = list;\n   return patch_invoke (patch, list, args, wfl);\n }\n \n@@ -5574,29 +5700,35 @@ patch_invoke (patch, method, args, cl)\n      tree patch, method, args;\n      tree cl;\n {\n+  int im;\n   tree dtable, func;\n   tree signature = build_java_signature (TREE_TYPE (method));\n-  tree original_call;\n+  tree original_call, node, t, ta;\n \n-  switch (invocation_mode (method, 0))\n+  /* Last step for args: convert build-in types */\n+  for (t = TYPE_ARG_TYPES (TREE_TYPE (method)),\n+       ta = args; t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n+    if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n+\tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n+      TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n+       \n+  switch ((im = invocation_mode (method, 0)))\n     {\n     case INVOKE_VIRTUAL:\n       dtable = invoke_build_dtable (0, args);\n       func = build_invokevirtual (dtable, method);\n       break;\n+\n     case INVOKE_STATIC:\n       func = build_known_method_ref (method, TREE_TYPE (method),\n-\t\t\t\t     DECL_CONTEXT (method),\n-\t\t\t\t     signature, args);\n-      args = nreverse (args);\n+\t\t\t\t     DECL_CONTEXT (method), signature, args);\n       break;\n \n     default:\n       fatal (\"Unknown invocation mode - build_invoke\");\n       return NULL_TREE;\n     }\n \n-\n   /* Ensure self_type is initialized, (invokestatic). FIXME */\n   func = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (method)), func);\n   TREE_TYPE (patch) = TREE_TYPE (TREE_TYPE (method));\n@@ -5638,7 +5770,7 @@ invocation_mode (method, super)\n {\n   int access = get_access_flags_from_decl (method);\n \n-  if (access & ACC_STATIC)\n+  if (access & ACC_STATIC || access & ACC_FINAL)\n     return INVOKE_STATIC;\n \n   if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n@@ -6113,6 +6245,17 @@ java_complete_tree (node)\n \n       /* 2- They are expressions but ultimately deal with statements */\n \n+    case THROW_EXPR:\n+      wfl_op1 = TREE_OPERAND (node, 0);\n+      COMPLETE_CHECK_OP_0 (node);\n+      return patch_throw_statement (node, wfl_op1);\n+\n+    case SYNCHRONIZED_EXPR:\n+      wfl_op1 = TREE_OPERAND (node, 0);\n+      COMPLETE_CHECK_OP_0 (node);\n+      COMPLETE_CHECK_OP_1 (node);\n+      return patch_synchronized_statement (node, wfl_op1);\n+\n     case TRY_EXPR:\n       return patch_try_statement (node);\n \n@@ -6219,7 +6362,7 @@ java_complete_tree (node)\n \t    }\n \t  else\n \t    {\n-\t      TREE_VALUE (cn) = save_expr (dim);\n+\t      TREE_VALUE (cn) = dim;\n \t      /* Setup the location of the current dimension, for\n \t\t later error report. */\n \t      TREE_PURPOSE (cn) = \n@@ -6237,7 +6380,14 @@ java_complete_tree (node)\n       if (complete_function_arguments (node))\n \treturn error_mark_node;\n       else\n-\treturn patch_method_invocation_stmt (node, NULL_TREE, NULL_TREE, NULL);\n+\t{\n+\t  tree decl;\n+\t  node = patch_method_invocation_stmt (node, NULL_TREE, \n+\t\t\t\t\t       NULL_TREE, 0, &decl);\n+\t  if (node != error_mark_node)\n+\t    check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n+\t  return node;\n+\t}\n \n     case MODIFY_EXPR:\n       /* Save potential wfls */\n@@ -6407,12 +6557,9 @@ complete_function_arguments (node)\n \t crafted string buffer, as a result of use of the the String\n \t `+' operator. Build `parm.toString()' and expand it. */\n       if ((temp = patch_string (parm)))\n-\tparm = TREE_VALUE (cn) = temp;\n-      \n-      if (TREE_CODE (TREE_TYPE (parm)) == RECORD_TYPE)\n-\tTREE_VALUE (cn) = convert (promote_type (TREE_TYPE (parm)), parm);\n-      else\n-\tTREE_VALUE (cn) = save_expr (parm);\n+\tparm = temp;\n+      TREE_VALUE (cn) = parm;\n+\n       if (not_initialized_as_it_should_p (parm))\n \t{\n \t  ERROR_VARIABLE_NOT_INITIALIZED (wfl, EXPR_WFL_NODE (wfl));\n@@ -6943,6 +7090,9 @@ valid_ref_assignconv_cast_p (source, dest, cast)\n \t  tree source_element_type = TYPE_ARRAY_ELEMENT (source);\n \t  tree dest_element_type = TYPE_ARRAY_ELEMENT (dest);\n \t  \n+\t  /* In case of severe errors, they turn out null */\n+\t  if (!dest_element_type || !source_element_type)\n+\t    return 0;\n \t  if (source_element_type == dest_element_type)\n \t    return 1;\n \t  return valid_ref_assignconv_cast_p (source_element_type,\n@@ -7289,12 +7439,9 @@ patch_binop (node, wfl_op1, wfl_op2)\n       \n       /* 15.20.3 Reference Equality Operators == and != */\n       /* Types have to be either references or the null type */\n-      else if ((op1 == null_pointer_node || op2 == null_pointer_node \n-\t\t|| JREFERENCE_TYPE_P (op1_type) \n-\t\t|| JREFERENCE_TYPE_P (op2_type))\n-\t       && ((op1_type == op2_type)\n-\t\t   /* There should use a valid_cast_to_p() */\n-\t\t   ))\n+      else if (op1 == null_pointer_node || op2 == null_pointer_node \n+\t       || (JREFERENCE_TYPE_P (op1_type) && JREFERENCE_TYPE_P (op2_type)\n+\t\t   && ((op1_type == op2_type))))\n \t;\t\t\t/* Nothing to do here */\n \t  \n       /* Else we have an error figure what can't be converted into\n@@ -8768,18 +8915,13 @@ build_try_statement (location, try_block, catches, finally)\n \t\t   exception_parameter */\n \t  catch_decl = build_decl_no_layout (VAR_DECL, generate_name (),\n \t\t\t\t\t     ptr_type_node);\n-\t  stmt = build (MODIFY_EXPR, void_type_node, catch_decl,\n-\t\t\tsoft_exceptioninfo_call_node);\n-\t  TREE_SIDE_EFFECTS (stmt) = 1;\n+\t  BUILD_ASSIGN_EXCEPTION_INFO (stmt, catch_decl);\n \t  catch_block = build_expr_block (stmt, NULL_TREE);\n \t  catch_block = build_jump_to_finally (catch_block, rff, \n \t\t\t\t\t       FINALLY_EXPR_LABEL (finally), \n \t\t\t\t\t       void_type_node);\n-\t  stmt = build (CALL_EXPR, void_type_node,\n-\t\t\tbuild_address_of (throw_node),\n-\t\t\tbuild_tree_list (NULL_TREE, catch_decl), NULL_TREE);\n+\t  BUILD_THROW (stmt, catch_decl);\n \t  catch_block = build_expr_block (catch_block, catch_decl);\n-\t  TREE_SIDE_EFFECTS (stmt) = 1;\n \t  add_stmt_to_block (catch_block, void_type_node, stmt);\n \n \t  /* Link the new handler to the existing list as the first\n@@ -8822,14 +8964,12 @@ patch_try_statement (node)\n   tree catch = nreverse (TREE_OPERAND (node, 1));\n   tree finally = TREE_OPERAND (node, 2);\n   int finally_p = (finally ? 1 : 0);\n-  tree current;\n-\n-  /* Walk the try block */\n-  if ((try = java_complete_tree (try)) == error_mark_node)\n-    error_found = 1;\n+  tree current, caught_type_list = NULL_TREE;\n \n   /* Check catch clauses, if any. Every time we find an error, we try\n-     to process the next catch clause. */\n+     to process the next catch clause. We process the catch clause before\n+     the try block so that when processing the try block we can check thrown\n+     exceptions againts the caught type list. */\n   for (current = catch; current; current = TREE_CHAIN (current))\n     {\n       tree carg_decl, carg_type;\n@@ -8908,6 +9048,11 @@ patch_try_statement (node)\n       if (unreachable)\n \tcontinue;\n \n+      /* Things to do here: the exception must be thrown */\n+\n+      /* Link this type to the caught type list */\n+      caught_type_list = tree_cons (NULL_TREE, carg_type, caught_type_list);\n+\n       /* Complete the catch clause block */\n       catch_block = java_complete_tree (TREE_OPERAND (current, 0));\n       if (catch_block == error_mark_node)\n@@ -8918,6 +9063,11 @@ patch_try_statement (node)\n       TREE_OPERAND (current, 0) = catch_block;\n     }\n \n+  PUSH_EXCEPTIONS (caught_type_list);\n+  if ((try = java_complete_tree (try)) == error_mark_node)\n+    error_found = 1;\n+  POP_EXCEPTIONS ();\n+\n   /* Process finally */\n   if (finally)\n     {\n@@ -8937,3 +9087,208 @@ patch_try_statement (node)\n   TREE_TYPE (node) = void_type_node;\n   return node;\n }\n+\n+/* 14.17 The synchronized Statement */\n+\n+static tree\n+patch_synchronized_statement (node, wfl_op1)\n+    tree node, wfl_op1;\n+{\n+  tree expr = TREE_OPERAND (node, 0);\n+  tree block = TREE_OPERAND (node, 1);\n+  tree try_block, catch_all, stmt, compound, decl;\n+\n+  /* The TYPE of expr must be a reference type */\n+  if (!JREFERENCE_TYPE_P (TREE_TYPE (TREE_OPERAND (node, 0))))\n+    {\n+      SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n+      parse_error_context (wfl_operator, \"Incompatible type for `synchronized'\"\n+\t\t\t   \". Can't convert `%s' to `java.lang.Object'\",\n+\t\t\t   lang_printable_name (TREE_TYPE (expr)));\n+      return error_mark_node;\n+    }\n+\n+  /* Generate a try-finally for the synchronized statement, except\n+     that the handler that catches all throw exception calls\n+     _Jv_MonitorExit and then rethrow the exception.\n+     The synchronized statement is then implemented as:\n+     TRY \n+       {\n+         _Jv_MonitorEnter (expression)\n+\t synchronized_block\n+         _Jv_MonitorExit (expression)\n+       }\n+     CATCH_ALL\n+       {\n+         e = _Jv_exception_info ();\n+\t _Jv_MonitorExit (expression)\n+\t Throw (e);\n+       } */\n+\n+  /* TRY block */\n+  BUILD_MONITOR_ENTER (stmt, expr);\n+  compound = add_stmt_to_compound (NULL_TREE, int_type_node, stmt);\n+  compound = add_stmt_to_compound (compound, void_type_node, block);\n+  BUILD_MONITOR_EXIT (stmt, expr);\n+  compound = add_stmt_to_compound (compound, int_type_node, stmt);\n+  try_block = build_expr_block (compound, NULL_TREE);\n+\n+  /* CATCH_ALL block */\n+  decl = build_decl_no_layout (VAR_DECL, generate_name (), ptr_type_node);\n+  BUILD_ASSIGN_EXCEPTION_INFO (stmt, decl);\n+  compound = add_stmt_to_compound (NULL_TREE, void_type_node, stmt);\n+  BUILD_MONITOR_EXIT (stmt, expr);\n+  compound = add_stmt_to_compound (compound, int_type_node, stmt);\n+  BUILD_THROW (stmt, decl);\n+  compound = add_stmt_to_compound (compound, void_type_node, stmt);\n+  catch_all = build_expr_block (compound, decl);\n+  catch_all = build_expr_block (catch_all, NULL_TREE);\n+  catch_all = build1 (CATCH_EXPR, void_type_node, catch_all);\n+\n+  /* TRY-CATCH statement */\n+  return build (TRY_EXPR, void_type_node, try_block, catch_all, NULL_TREE);\n+}\n+\n+/* 14.16 The throw Statement */\n+\n+static tree\n+patch_throw_statement (node, wfl_op1)\n+    tree node, wfl_op1;\n+{\n+  tree expr = TREE_OPERAND (node, 0);\n+  tree type = TREE_TYPE (expr);\n+  int unchecked_ok = 0, tryblock_throws_ok = 0;\n+\n+  /* Thrown expression must be assignable to java.lang.Throwable */\n+  if (!try_reference_assignconv (throwable_type_node, expr))\n+    {\n+      SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n+      parse_error_context (wfl_operator, \"Can't throw `%s'; it must be a \"\n+\t\t\t   \"subclass of class `java.lang.Throwable'\",\n+\t\t\t   lang_printable_name (type));\n+      /* If the thrown expression was a reference, we further the\n+         compile-time check. */\n+      if (!JREFERENCE_TYPE_P (type))\n+\treturn error_mark_node;\n+    }\n+\n+  /* At least one of the following must be true */\n+\n+  /* The type of the throw expression is a not checked exception,\n+     i.e. is a unchecked expression. */\n+  unchecked_ok = IS_UNCHECKED_EXPRESSION_P (TREE_TYPE (type));\n+\n+  /* Throw is contained in a try statement and at least one catch\n+     clause can receive the thrown expression or the current method is\n+     declared to throw such an exception. Or, the throw statement is\n+     contained in a method or constructor declaration and the type of\n+     the Expression is assignable to at least one type listed in the\n+     throws clause the declaration. */\n+  SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n+  if (!unchecked_ok)\n+    tryblock_throws_ok = \n+      check_thrown_exceptions_do (EXPR_WFL_LINECOL (wfl_operator), \n+\t\t\t\t  TREE_TYPE (expr));\n+  if (!(unchecked_ok || tryblock_throws_ok))\n+    {\n+      /* If there is a surrounding try block that has no matching\n+\t clatch clause, report it first. A surrounding try block exits\n+\t only if there is something after the list of checked\n+\t exception thrown by the current function (if any). */\n+      if (IN_TRY_BLOCK_P ())\n+\tparse_error_context (wfl_operator, \"Checked exception `%s' can't be \"\n+\t\t\t     \"caught by any of the catch clause(s) \"\n+\t\t\t     \"of the surrounding `try' block\",\n+\t\t\t     lang_printable_name (type));\n+      /* If we have no surrounding try statement and the method doesn't have\n+\t any throws, report it now. FIXME */\n+      else if (!EXCEPTIONS_P (currently_caught_type_list) \n+\t       && !tryblock_throws_ok)\n+\tparse_error_context (wfl_operator, \"Checked exception `%s' isn't \"\n+\t\t\t     \"thrown from a `try' block\", \n+\t\t\t     lang_printable_name (type));\n+      /* Otherwise, the current method doesn't have the appropriate\n+         throws declaration */\n+      else\n+\tparse_error_context (wfl_operator, \"Checked exception `%s' doesn't \"\n+\t\t\t     \"match any of current method's `throws' \"\n+\t\t\t     \"declaration(s)\", \n+\t\t\t     lang_printable_name (type));\n+      return error_mark_node;\n+    }\n+\n+  /* If a throw statement is contained in a static initializer, then a\n+     compile-time check ensures that either its value is always an\n+     unchecked exception or its value is always caught by some try\n+     statement that contains it. FIXME, static initializer. */\n+  \n+  BUILD_THROW (node, expr);\n+  return node;\n+}\n+\n+/* Check that exception said to be thrown by method DECL can be\n+   effectively caught from where DECL is invoked.  */\n+\n+static void\n+check_thrown_exceptions (location, decl)\n+     int location;\n+     tree decl;\n+{\n+  tree throws;\n+  /* For all the unchecked exceptions thrown by DECL */\n+  for (throws = DECL_FUNCTION_THROWS (decl); throws; \n+       throws = TREE_CHAIN (throws)) \n+    if (!check_thrown_exceptions_do (location, TREE_VALUE (throws)))\n+      {\n+\tEXPR_WFL_LINECOL (wfl_operator) = location;\n+\tparse_error_context \n+\t  (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n+\t   \"declared in the `throws' clause of `%s'\", \n+\t   lang_printable_name (TREE_VALUE (throws)),\n+\t   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+      }\n+}\n+\n+/* Return 1 if EXCEPTION is caught at the current nesting level of\n+   try-catch blocks, OR is listed in the `throws' clause of the\n+   current method.  */\n+\n+static int\n+check_thrown_exceptions_do (location, exception)\n+     int location;\n+     tree exception;\n+{\n+  tree list = currently_caught_type_list;\n+  /* First, all the nested try-catch-finally at that stage. The\n+     last element contains `throws' clause exceptions, if any. */\n+  while (list)\n+    {\n+      tree caught;\n+      for (caught = TREE_VALUE (list); caught; caught = TREE_CHAIN (caught))\n+\tif (valid_ref_assignconv_cast_p (exception, TREE_VALUE (caught), 0))\n+\t  return 1;\n+      list = TREE_CHAIN (list);\n+    }\n+  return 0;\n+}\n+\n+static void\n+purge_unchecked_exceptions (mdecl)\n+     tree mdecl;\n+{\n+  tree throws = DECL_FUNCTION_THROWS (mdecl);\n+  tree new = NULL_TREE;\n+\n+  while (throws)\n+    {\n+      tree next = TREE_CHAIN (throws);\n+      if (!IS_UNCHECKED_EXPRESSION_P (TREE_VALUE (throws)))\n+\t{\n+\t  TREE_CHAIN (throws) = new;\n+\t  new = throws;\n+\t}\n+      throws = next;\n+    }\n+  /* List is inverted here, but it doesn't matter */\n+  DECL_FUNCTION_THROWS (mdecl) = new;\n+}"}, {"sha": "3a8d81f08a57e7c4f0edc70abf04116fa847fe4c", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f7e36ca11532cc83c391bf6fdca7071d8618ce/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=b9f7e36ca11532cc83c391bf6fdca7071d8618ce", "patch": "@@ -662,7 +662,10 @@ lookup_argument_method (clas, method_name, method_signature)\n \t   method != NULL_TREE;  method = TREE_CHAIN (method))\n \t{\n \t  tree method_sig = build_java_argument_signature (TREE_TYPE (method));\n-\t  if (DECL_NAME (method) == method_name && method_sig == method_signature)\n+\t  tree name = DECL_NAME (method);\n+\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n+\t       EXPR_WFL_NODE (DECL_NAME (method)) : name) == method_name \n+\t      && method_sig == method_signature)\n \t    return method;\n \t}\n       clas = CLASSTYPE_SUPER (clas);\n@@ -686,7 +689,8 @@ lookup_java_method (clas, method_name, method_signature)\n \t   method != NULL_TREE;  method = TREE_CHAIN (method))\n \t{\n \t  tree method_sig = build_java_signature (TREE_TYPE (method));\n-\t  if (DECL_NAME (method) == method_name && method_sig == method_signature)\n+\t  if (DECL_NAME (method) == method_name \n+\t      && method_sig == method_signature)\n \t    return method;\n \t}\n       clas = CLASSTYPE_SUPER (clas);"}]}