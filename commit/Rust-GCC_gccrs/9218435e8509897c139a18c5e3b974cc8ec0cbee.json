{"sha": "9218435e8509897c139a18c5e3b974cc8ec0cbee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIxODQzNWU4NTA5ODk3YzEzOWExOGM1ZTNiOTc0Y2M4ZWMwY2JlZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-29T21:03:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-29T21:03:47Z"}, "message": "* gcc.c: Fix formatting.\n\nFrom-SVN: r36050", "tree": {"sha": "5d08ae342d52f4e7f3a3d383b723e0b5bc9dd53e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d08ae342d52f4e7f3a3d383b723e0b5bc9dd53e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9218435e8509897c139a18c5e3b974cc8ec0cbee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9218435e8509897c139a18c5e3b974cc8ec0cbee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9218435e8509897c139a18c5e3b974cc8ec0cbee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9218435e8509897c139a18c5e3b974cc8ec0cbee/comments", "author": null, "committer": null, "parents": [{"sha": "fba0bfd4546bb2b864a841cf1d43957dbaa38a89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba0bfd4546bb2b864a841cf1d43957dbaa38a89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba0bfd4546bb2b864a841cf1d43957dbaa38a89"}], "stats": {"total": 158, "additions": 77, "deletions": 81}, "files": [{"sha": "c560553b74c05badcc0845171eaf47cb64735bbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9218435e8509897c139a18c5e3b974cc8ec0cbee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9218435e8509897c139a18c5e3b974cc8ec0cbee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9218435e8509897c139a18c5e3b974cc8ec0cbee", "patch": "@@ -1,3 +1,7 @@\n+2000-08-29  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* gcc.c: Fix formatting.\n+\n 2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* flags.h (time_report, mem_report): New global flags."}, {"sha": "c5378c4b4cd025c11e009c12b4176773feca0a5f", "filename": "gcc/gcc.c", "status": "modified", "additions": 73, "deletions": 81, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9218435e8509897c139a18c5e3b974cc8ec0cbee/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9218435e8509897c139a18c5e3b974cc8ec0cbee/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=9218435e8509897c139a18c5e3b974cc8ec0cbee", "patch": "@@ -1,5 +1,5 @@\n /* Compiler driver program that can handle many languages.\n-   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -32,7 +32,6 @@ CC recognizes how to compile each input file by suffixes in the file names.\n Once it knows which kind of compilation to perform, the procedure for\n compilation is specified by a string called a \"spec\".  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include <signal.h>\n@@ -636,7 +635,6 @@ static struct user_specs *user_specs_head, *user_specs_tail;\n #define WORD_SWITCH_TAKES_ARG(STR) DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\n #endif\n \f\n-\n #ifdef HAVE_EXECUTABLE_SUFFIX\n /* This defines which switches stop a full compilation.  */\n #define DEFAULT_SWITCH_CURTAILS_COMPILATION(CHAR) \\\n@@ -1060,7 +1058,7 @@ struct spec_list\n };\n \n #define INIT_STATIC_SPEC(NAME,PTR) \\\n-{ NAME, NULL_PTR, PTR, (struct spec_list *)0, sizeof (NAME)-1, 0 }\n+{ NAME, NULL_PTR, PTR, (struct spec_list *) 0, sizeof (NAME)-1, 0 }\n \n /* List of statically defined specs.  */\n static struct spec_list static_specs[] =\n@@ -1103,21 +1101,20 @@ struct spec_list_1\n };\n \n static struct spec_list_1 extra_specs_1[] = { EXTRA_SPECS };\n-static struct spec_list * extra_specs = (struct spec_list *)0;\n+static struct spec_list * extra_specs = (struct spec_list *) 0;\n #endif\n \n /* List of dynamically allocates specs that have been defined so far.  */\n \n-static struct spec_list *specs = (struct spec_list *)0;\n-\n+static struct spec_list *specs = (struct spec_list *) 0;\n \f\n /* Initialize the specs lookup routines.  */\n \n static void\n init_spec ()\n {\n-  struct spec_list *next = (struct spec_list *)0;\n-  struct spec_list *sl   = (struct spec_list *)0;\n+  struct spec_list *next = (struct spec_list *) 0;\n+  struct spec_list *sl   = (struct spec_list *) 0;\n   int i;\n \n   if (specs)\n@@ -1129,7 +1126,7 @@ init_spec ()\n #ifdef EXTRA_SPECS\n   extra_specs = (struct spec_list *)\n     xcalloc (sizeof (struct spec_list), ARRAY_SIZE (extra_specs_1));\n-  \n+\n   for (i = ARRAY_SIZE (extra_specs_1) - 1; i >= 0; i--)\n     {\n       sl = &extra_specs[i];\n@@ -1151,7 +1148,6 @@ init_spec ()\n \n   specs = sl;\n }\n-\n \f\n /* Change the value of spec NAME to SPEC.  If SPEC is empty, then the spec is\n    removed; If the spec starts with a + then SPEC is added to the end of the\n@@ -1170,7 +1166,7 @@ set_spec (name, spec)\n   /* If this is the first call, initialize the statically allocated specs.  */\n   if (!specs)\n     {\n-      struct spec_list *next = (struct spec_list *)0;\n+      struct spec_list *next = (struct spec_list *) 0;\n       for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)\n \t{\n \t  sl = &static_specs[i];\n@@ -1380,7 +1376,7 @@ store_arg (arg, delete_always, delete_failure)\n }\n \f\n /* Load specs from a file name named FILENAME, replacing occurances of\n-   various different types of line-endings, \\r\\n, \\n\\r and just \\r, with \n+   various different types of line-endings, \\r\\n, \\n\\r and just \\r, with\n    a single \\n.  */\n \n static char*\n@@ -1534,12 +1530,12 @@ read_specs (filename, main_p)\n \t      while (*p1 == ' ' || *p1 == '\\t')\n \t\tp1++;\n \n-\t      if (! ISALPHA ((unsigned char)*p1))\n+\t      if (! ISALPHA ((unsigned char) *p1))\n \t\tfatal (\"specs %%rename syntax malformed after %ld characters\",\n \t\t       (long) (p1 - buffer));\n \n \t      p2 = p1;\n-\t      while (*p2 && !ISSPACE ((unsigned char)*p2))\n+\t      while (*p2 && !ISSPACE ((unsigned char) *p2))\n \t\tp2++;\n \n \t      if (*p2 != ' ' && *p2 != '\\t')\n@@ -1551,13 +1547,13 @@ read_specs (filename, main_p)\n \t      while (*p2 == ' ' || *p2 == '\\t')\n \t\tp2++;\n \n-\t      if (! ISALPHA ((unsigned char)*p2))\n+\t      if (! ISALPHA ((unsigned char) *p2))\n \t\tfatal (\"specs %%rename syntax malformed after %ld characters\",\n \t\t       (long) (p2 - buffer));\n \n \t      /* Get new spec name */\n \t      p3 = p2;\n-\t      while (*p3 && !ISSPACE ((unsigned char)*p3))\n+\t      while (*p3 && !ISSPACE ((unsigned char) *p3))\n \t\tp3++;\n \n \t      if (p3 != p-1)\n@@ -1889,7 +1885,7 @@ build_search_list (paths, prefix, check_dir_p)\n \t{\n \t  if (!first_time)\n \t    obstack_1grow (&collect_obstack, PATH_SEPARATOR);\n-\t    \n+\n \t  first_time = FALSE;\n \t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n \t  obstack_grow (&collect_obstack, machine_suffix, suffix_len);\n@@ -1902,7 +1898,7 @@ build_search_list (paths, prefix, check_dir_p)\n \t{\n \t  if (! first_time)\n \t    obstack_1grow (&collect_obstack, PATH_SEPARATOR);\n-\t    \n+\n \t  first_time = FALSE;\n \t  obstack_grow (&collect_obstack, pprefix->prefix, len);\n \t  obstack_grow (&collect_obstack, just_machine_suffix,\n@@ -2122,7 +2118,7 @@ make_relative_prefix (progname, bin_prefix, prefix)\n \t  std_loc_p = 1;\n \t  free_split_directories (prog_dirs);\n \t  free_split_directories (bin_dirs);\n-\t  prog_dirs = bin_dirs = (char **)0;\n+\t  prog_dirs = bin_dirs = (char **) 0;\n \t  return NULL_PTR;\n \t}\n     }\n@@ -2334,7 +2330,7 @@ find_a_file (pprefix, name, mode)\n }\n \n /* Ranking of prefixes in the sort list. -B prefixes are put before\n-   all others. */\n+   all others.  */\n \n enum path_prefix_priority\n {\n@@ -2418,7 +2414,6 @@ unused_prefix_warnings (pprefix)\n       pl = pl->next;\n     }\n }\n-\n \f\n /* Execute the command specified by the arguments on the current line of spec.\n    When using pipes, this includes several piped-together commands\n@@ -2485,7 +2480,7 @@ execute ()\n       /* For help listings, put a blank line between sub-processes.  */\n       if (print_help_list)\n \tfputc ('\\n', stderr);\n-      \n+\n       /* Print each piped command as a separate line.  */\n       for (i = 0; i < n_commands ; i++)\n \t{\n@@ -2575,7 +2570,7 @@ execute ()\n \t    d.tv_sec = rus.ru_utime.tv_sec - prus.ru_utime.tv_sec;\n \t    d.tv_usec = rus.ru_utime.tv_usec - prus.ru_utime.tv_usec;\n \t    ut = (double)d.tv_sec + (double)d.tv_usec / 1.0e6;\n-\t    \n+\n \t    d.tv_sec = rus.ru_stime.tv_sec - prus.ru_stime.tv_sec;\n \t    d.tv_usec = rus.ru_stime.tv_usec - prus.ru_stime.tv_usec;\n \t    st = (double)d.tv_sec + (double)d.tv_usec / 1.0e6;\n@@ -2687,7 +2682,6 @@ static int warn_std;\n \n /* Gives value to pass as \"warn\" to add_prefix for standard prefixes.  */\n static int *warn_std_ptr = 0;\n-\n \f\n #if defined(HAVE_OBJECT_SUFFIX) || defined(HAVE_EXECUTABLE_SUFFIX)\n \n@@ -2704,7 +2698,7 @@ convert_filename (name, do_exe)\n \n   if (name == NULL)\n     return NULL;\n-  \n+\n   len = strlen (name);\n \n #ifdef HAVE_OBJECT_SUFFIX\n@@ -2798,27 +2792,27 @@ on to these processes the -W<letter> options must be used.\\n\\\n      sub-processes.  */\n }\n \n-static void \t\t\t\t\t\t\t\t\n-add_preprocessor_option (option, len)\t\t\t\t\t\n+static void\n+add_preprocessor_option (option, len)\n      const char * option;\n      int len;\n-{\t\t\t\t\t\t\t\t\t\n+{\n   n_preprocessor_options++;\n-\t\t\t\t\t\t\t\t\t\n+\n   if (! preprocessor_options)\n     preprocessor_options\n       = (char **) xmalloc (n_preprocessor_options * sizeof (char *));\n   else\n     preprocessor_options\n       = (char **) xrealloc (preprocessor_options,\n \t\t\t    n_preprocessor_options * sizeof (char *));\n-  \t\t\t\t\t\t\t\t\t\n+\n   preprocessor_options [n_preprocessor_options - 1] =\n     save_string (option, len);\n }\n-     \n-static void \t\t\t\t\t\t\t\t\n-add_assembler_option (option, len)\t\t\t\t\t\n+\n+static void\n+add_assembler_option (option, len)\n      const char * option;\n      int len;\n {\n@@ -2834,9 +2828,9 @@ add_assembler_option (option, len)\n \n   assembler_options [n_assembler_options - 1] = save_string (option, len);\n }\n-     \n-static void \t\t\t\t\t\t\t\t\n-add_linker_option (option, len)\t\t\t\t\t\n+\n+static void\n+add_linker_option (option, len)\n      const char * option;\n      int    len;\n {\n@@ -2878,7 +2872,7 @@ process_command (argc, argv)\n \n   /* Figure compiler version from version string.  */\n \n-  compiler_version = temp1 = xstrdup (version_string); \n+  compiler_version = temp1 = xstrdup (version_string);\n \n   for (; *temp1; ++temp1)\n     {\n@@ -3067,7 +3061,7 @@ process_command (argc, argv)\n \t  /* We will be passing a dummy file on to the sub-processes.  */\n \t  n_infiles++;\n \t  n_switches++;\n-\t  \n+\n \t  add_preprocessor_option (\"--help\", 6);\n \t  add_assembler_option (\"--help\", 6);\n \t  add_linker_option (\"--help\", 6);\n@@ -3102,7 +3096,7 @@ process_command (argc, argv)\n \t\tadd_assembler_option (argv[i] + prev, j - prev);\n \t\tprev = j + 1;\n \t      }\n-\t  \n+\n \t  /* Record the part after the last comma.  */\n \t  add_assembler_option (argv[i] + prev, j - prev);\n \t}\n@@ -3119,7 +3113,7 @@ process_command (argc, argv)\n \t\tadd_preprocessor_option (argv[i] + prev, j - prev);\n \t\tprev = j + 1;\n \t      }\n-\t  \n+\n \t  /* Record the part after the last comma.  */\n \t  add_preprocessor_option (argv[i] + prev, j - prev);\n \t}\n@@ -3155,7 +3149,7 @@ process_command (argc, argv)\n \t  if (++i >= argc)\n \t    fatal (\"argument to `-specs' is missing\");\n \n-\t  user->next = (struct user_specs *)0;\n+\t  user->next = (struct user_specs *) 0;\n \t  user->filename = argv[i];\n \t  if (user_specs_tail)\n \t    user_specs_tail->next = user;\n@@ -3170,7 +3164,7 @@ process_command (argc, argv)\n \t  if (strlen (argv[i]) == 7)\n \t    fatal (\"argument to `-specs=' is missing\");\n \n-\t  user->next = (struct user_specs *)0;\n+\t  user->next = (struct user_specs *) 0;\n \t  user->filename = argv[i]+7;\n \t  if (user_specs_tail)\n \t    user_specs_tail->next = user;\n@@ -3311,7 +3305,7 @@ process_command (argc, argv)\n \t      if (! have_c)\n \t\t{\n \t\t  int skip;\n-\t\t  \n+\n \t\t  /* Forward scan, just in case -S or -c is specified\n \t\t     after -o.  */\n \t\t  int j = i + 1;\n@@ -3384,7 +3378,7 @@ process_command (argc, argv)\n   add_prefix (&startfile_prefixes, standard_exec_prefix_1, \"BINUTILS\",\n \t      PREFIX_PRIORITY_LAST, 1, warn_std_ptr);\n \n-  tooldir_prefix = concat (tooldir_base_prefix, spec_machine, \n+  tooldir_prefix = concat (tooldir_base_prefix, spec_machine,\n \t\t\t   dir_separator_str, NULL_PTR);\n \n   /* If tooldir is relative, base it on exec_prefixes.  A relative\n@@ -3403,21 +3397,21 @@ process_command (argc, argv)\n \t\t      spec_version, dir_separator_str, tooldir_prefix, NULL_PTR);\n \n \t  add_prefix (&exec_prefixes,\n-\t\t      concat (gcc_exec_tooldir_prefix, \"bin\", \n+\t\t      concat (gcc_exec_tooldir_prefix, \"bin\",\n \t\t\t      dir_separator_str, NULL_PTR),\n \t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t  add_prefix (&startfile_prefixes,\n-\t\t      concat (gcc_exec_tooldir_prefix, \"lib\", \n+\t\t      concat (gcc_exec_tooldir_prefix, \"lib\",\n \t\t\t      dir_separator_str, NULL_PTR),\n \t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n \t}\n \n       tooldir_prefix = concat (standard_exec_prefix, spec_machine,\n-\t\t\t       dir_separator_str, spec_version, \n+\t\t\t       dir_separator_str, spec_version,\n \t\t\t       dir_separator_str, tooldir_prefix, NULL_PTR);\n     }\n \n-  add_prefix (&exec_prefixes, \n+  add_prefix (&exec_prefixes,\n               concat (tooldir_prefix, \"bin\", dir_separator_str, NULL_PTR),\n \t      \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n   add_prefix (&startfile_prefixes,\n@@ -3427,7 +3421,6 @@ process_command (argc, argv)\n   /* More prefixes are enabled in main, after we read the specs file\n      and determine whether this is cross-compilation or not.  */\n \n-\n   /* Then create the space for the vectors and scan again.  */\n \n   switches = ((struct switchstr *)\n@@ -3470,14 +3463,14 @@ process_command (argc, argv)\n \t\t the various sub-processes.  */\n \t      infiles[n_infiles].language = \"c\";\n \t      infiles[n_infiles++].name   = \"help-dummy\";\n-\t      \n+\n \t      /* Preserve the --help switch so that it can be caught by the\n \t\t cc1 spec string.  */\n \t      switches[n_switches].part1     = \"--help\";\n \t      switches[n_switches].args      = 0;\n \t      switches[n_switches].live_cond = SWITCH_OK;\n \t      switches[n_switches].validated     = 0;\n-\t      \n+\n \t      n_switches++;\n \t    }\n \t}\n@@ -3590,7 +3583,7 @@ process_command (argc, argv)\n \t      char *tmp;\n \t      part1[0] = c;\n \t      part1[1] = '\\0';\n-\t      \n+\n \t      switches[n_switches].part1 = part1;\n \t      switches[n_switches].args\n \t\t= (const char **) xmalloc (2 * sizeof (const char *));\n@@ -3977,7 +3970,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n               /* If save_temps_flag is off, and the HOST_BIT_BUCKET is defined,\n                  and it is not a directory, and it is writable, use it.\n                  Otherwise, fall through and treat this like any other\n-                 temporary file. */\n+                 temporary file.  */\n \n               if ((!save_temps_flag)\n                   && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))\n@@ -4005,14 +3998,14 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\tconst char *suffix = p;\n \t\tchar *saved_suffix = NULL;\n \n-\t\twhile (*p == '.' || ISALPHA ((unsigned char)*p))\n+\t\twhile (*p == '.' || ISALPHA ((unsigned char) *p))\n \t\t  p++;\n \t\tsuffix_length = p - suffix;\n \t\tif (p[0] == '%' && p[1] == 'O')\n \t\t  {\n \t\t    p += 2;\n \t\t    /* We don't support extra suffix characters after %O.  */\n-\t\t    if (*p == '.' || ISALPHA ((unsigned char)*p))\n+\t\t    if (*p == '.' || ISALPHA ((unsigned char) *p))\n \t\t      abort ();\n \t\t    if (suffix_length == 0)\n \t\t      suffix = OBJECT_SUFFIX;\n@@ -4307,7 +4300,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t\t      if (*y != '_'\n \t\t\t  || (*(y+1) != '_'\n-\t\t\t      && ! ISUPPER ((unsigned char)*(y+1))))\n+\t\t\t      && ! ISUPPER ((unsigned char) *(y+1))))\n \t\t        {\n \t\t\t  /* Stick __ at front of macro name.  */\n \t\t\t  if (*y != '_')\n@@ -4355,7 +4348,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t\t      if (*y != '_'\n \t\t\t  || (*(y+1) != '_'\n-\t\t\t      && ! ISUPPER ((unsigned char)*(y+1))))\n+\t\t\t      && ! ISUPPER ((unsigned char) *(y+1))))\n \t\t        {\n \t\t\t  /* Stick -D__ at front of macro name.  */\n \t\t\t  *x++ = '-';\n@@ -4687,7 +4680,7 @@ handle_braces (p)\n \n \t  while (*q++ != ':') continue;\n \t  body = q;\n-\t  \n+\n \t  while (count > 0)\n \t    {\n \t      if (*q == '{')\n@@ -5027,11 +5020,11 @@ is_directory (path1, path2, linker)\n   /* Exclude directories that the linker is known to search.  */\n   if (linker\n       && ((cp - path == 6\n-\t   && strcmp (path, concat (dir_separator_str, \"lib\", \n+\t   && strcmp (path, concat (dir_separator_str, \"lib\",\n \t\t\t\t    dir_separator_str, \".\", NULL_PTR)) == 0)\n \t  || (cp - path == 10\n-\t      && strcmp (path, concat (dir_separator_str, \"usr\", \n-\t\t\t\t       dir_separator_str, \"lib\", \n+\t      && strcmp (path, concat (dir_separator_str, \"usr\",\n+\t\t\t\t       dir_separator_str, \"lib\",\n \t\t\t\t       dir_separator_str, \".\", NULL_PTR)) == 0)))\n     return 0;\n \n@@ -5049,7 +5042,7 @@ set_input (filename)\n \n   input_filename = filename;\n   input_filename_length = strlen (input_filename);\n-  \n+\n   input_basename = input_filename;\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n   /* Skip drive name so 'x:foo' is handled properly.  */\n@@ -5164,7 +5157,7 @@ main (argc, argv)\n \n     obstack_1grow (&multilib_obstack, 0);\n     multilib_exclusions = obstack_finish (&multilib_obstack);\n-    \n+\n     need_space = FALSE;\n     for (i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)\n       {\n@@ -5277,7 +5270,7 @@ main (argc, argv)\n   strcat (specs_file, \"specs\");\n   if (access (specs_file, R_OK) == 0)\n     read_specs (specs_file, TRUE);\n- \n+\n   /* If not cross-compiling, look for startfiles in the standard places.  */\n   if (*cross_compile == '0')\n     {\n@@ -5324,7 +5317,7 @@ main (argc, argv)\n \t\t\t      machine_suffix,\n \t\t\t      standard_startfile_prefix, NULL_PTR),\n \t\t      NULL_PTR, PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n-\t}\t\t       \n+\t}\n \n       add_prefix (&startfile_prefixes, standard_startfile_prefix_1,\n \t\t  \"BINUTILS\", PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n@@ -5427,15 +5420,15 @@ main (argc, argv)\n \t{\n \t  printf (_(\"\\nFor bug reporting instructions, please see:\\n\"));\n \t  printf (\"%s.\\n\", GCCBUGURL);\n-\t  \n+\n \t  return (0);\n \t}\n \n       /* We do not exit here.  Instead we have created a fake input file\n \t called 'help-dummy' which needs to be compiled, and we pass this\n \t on the the various sub-processes, along with the --help switch.  */\n     }\n-  \n+\n   if (verbose_flag)\n     {\n       int n;\n@@ -5542,7 +5535,7 @@ main (argc, argv)\n     {\n       int tmp = execution_count;\n \n-      /* We'll use ld if we can't find collect2. */\n+      /* We'll use ld if we can't find collect2.  */\n       if (! strcmp (linker_name_spec, \"collect2\"))\n \t{\n \t  char *s = find_a_file (&exec_prefixes, \"collect2\", X_OK);\n@@ -5584,7 +5577,7 @@ main (argc, argv)\n       printf ((\"\\nFor bug reporting instructions, please see:\\n\"));\n       printf (\"%s\\n\", GCCBUGURL);\n     }\n-  \n+\n   return (signal_count != 0 ? 2\n \t  : error_count > 0 ? (pass_exit_codes ? greatest_status : 1)\n \t  : 0);\n@@ -5654,7 +5647,7 @@ lookup_compiler (name, length, language)\n       if (cp->spec[0] != '@')\n \t/* A non-alias entry: return it.  */\n \treturn cp;\n-      \n+\n       /* An alias entry maps a suffix to a language.\n \t Search for the language; pass 0 for NAME and LENGTH\n \t to avoid infinite recursion if language not found.  */\n@@ -5781,7 +5774,6 @@ notice VPARAMS ((const char *msgid, ...))\n   vfprintf (stderr, _(msgid), ap);\n   va_end (ap);\n }\n-\n \f\n static void\n validate_all_switches ()\n@@ -5938,7 +5930,7 @@ used_arg (p, len)\n \t      {\n \t\tmswitches[n_mswitches].str = matches[j].replace;\n \t\tmswitches[n_mswitches].len = matches[j].rep_len;\n-\t\tmswitches[n_mswitches].replace = (char *)0;\n+\t\tmswitches[n_mswitches].replace = (char *) 0;\n \t\tmswitches[n_mswitches].rep_len = 0;\n \t\tn_mswitches++;\n \t\tbreak;\n@@ -6039,7 +6031,7 @@ set_multilib_dir ()\n               not_arg = 1;\n               ++this_arg;\n             }\n-  \n+\n \t  ok = used_arg (this_arg, p - this_arg);\n \t  if (not_arg)\n \t    ok = ! ok;\n@@ -6136,7 +6128,7 @@ set_multilib_dir ()\n \t}\n \n       ++p;\n-    }      \n+    }\n }\n \n /* Print out the multiple library subdirectory selection\n@@ -6185,14 +6177,14 @@ print_multilib_info ()\n \n \t  while (*e != '\\0')\n \t    {\n-\t      int m = 1;\t\n+\t      int m = 1;\n \t      /* Ignore newlines.  */\n \t      if (*e == '\\n')\n \t        {\n \t          ++e;\n \t          continue;\n \t        }\n-\t      \n+\n \t      /* Check the arguments.  */\n \t      while (*e != ';')\n \t        {\n@@ -6216,7 +6208,7 @@ print_multilib_info ()\n \t                abort ();\n \t              ++e;\n \t            }\n-\t\t  \n+\n   \t\t  q = p + 1;\n \t\t  while (*q != ';')\n \t\t    {\n@@ -6225,7 +6217,7 @@ print_multilib_info ()\n \n \t\t      if (*q == '\\0')\n \t\t\tabort ();\n-\t\n+\n \t\t      arg = q;\n \n \t\t      while (*q != ' ' && *q != ';')\n@@ -6252,7 +6244,7 @@ print_multilib_info ()\n \t          if (*e == ' ')\n \t            ++e;\n \t        }\n-\t      \n+\n \t      if (m)\n \t        {\n \t\t  skip = 1;\n@@ -6375,7 +6367,7 @@ print_multilib_info ()\n \t\t    }\n \t\t}\n \t    }\n-\t  \n+\n \t  putchar ('\\n');\n \t}\n "}]}