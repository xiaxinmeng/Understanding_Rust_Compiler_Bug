{"sha": "b20cd0c743b8823d8ac4437bf893ce691fb820e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwY2QwYzc0M2I4ODIzZDhhYzQ0MzdiZjg5M2NlNjkxZmI4MjBlOA==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-11-25T09:30:29Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-12-03T09:39:27Z"}, "message": "RISC-V: Canonicalize --with-arch\n\n - We would like to canonicalize the arch string for --with-arch for\n   easier handling multilib, so split canonicalization part to a stand\n   along script to shared the logic.\n\ngcc/ChangeLog:\n\n\t* config/riscv/multilib-generator (arch_canonicalize): Move\n\tcode to arch-canonicalize, and call that script to canonicalize arch\n\tstring.\n\t(canonical_order): Move code to arch-canonicalize.\n\t(LONG_EXT_PREFIXES): Ditto.\n\t(IMPLIED_EXT): Ditto.\n\t* config/riscv/arch-canonicalize: New.\n\t* config.gcc (riscv*-*-*): Canonicalize --with-arch.", "tree": {"sha": "363b3b0a3f83fa65cccee3ad0e3cc7b0008a8f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/363b3b0a3f83fa65cccee3ad0e3cc7b0008a8f91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b20cd0c743b8823d8ac4437bf893ce691fb820e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20cd0c743b8823d8ac4437bf893ce691fb820e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20cd0c743b8823d8ac4437bf893ce691fb820e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20cd0c743b8823d8ac4437bf893ce691fb820e8/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48ff86adfd96a0f5132273719932b48a14941881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ff86adfd96a0f5132273719932b48a14941881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ff86adfd96a0f5132273719932b48a14941881"}], "stats": {"total": 186, "additions": 111, "deletions": 75}, "files": [{"sha": "7b138d1bee166857bb9487cf1918a11880730a98", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20cd0c743b8823d8ac4437bf893ce691fb820e8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20cd0c743b8823d8ac4437bf893ce691fb820e8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b20cd0c743b8823d8ac4437bf893ce691fb820e8", "patch": "@@ -4615,6 +4615,7 @@ case \"${target}\" in\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n+\t\twith_arch=`${srcdir}/config/riscv/arch-canonicalize ${with_arch}`\n \t\ttm_defines=\"${tm_defines} TARGET_RISCV_DEFAULT_ARCH=${with_arch}\"\n \n \t\t# Make sure --with-abi is valid.  If it was not specified,"}, {"sha": "2b4289e320d78558f356592df6d904c7e5d1d5a3", "filename": "gcc/config/riscv/arch-canonicalize", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20cd0c743b8823d8ac4437bf893ce691fb820e8/gcc%2Fconfig%2Friscv%2Farch-canonicalize", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20cd0c743b8823d8ac4437bf893ce691fb820e8/gcc%2Fconfig%2Friscv%2Farch-canonicalize", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Farch-canonicalize?ref=b20cd0c743b8823d8ac4437bf893ce691fb820e8", "patch": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python\n+\n+# Tool for canonical RISC-V architecture string.\n+# Copyright (C) 2011-2020 Free Software Foundation, Inc.\n+# Contributed by Andrew Waterman (andrew@sifive.com).\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+from __future__ import print_function\n+import sys\n+import collections\n+import itertools\n+from functools import reduce\n+\n+\n+CANONICAL_ORDER = \"mafdgqlcbjtpvn\"\n+LONG_EXT_PREFIXES = ['z', 's', 'h', 'x']\n+\n+#\n+# IMPLIED_EXT(ext) -> implied extension list.\n+#\n+IMPLIED_EXT = {\n+  \"d\" : [\"f\"],\n+}\n+\n+def arch_canonicalize(arch):\n+  # TODO: Support extension version.\n+  new_arch = \"\"\n+  if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:\n+    # TODO: We should expand g to imad_zifencei once we support newer spec.\n+    new_arch = arch[:5].replace(\"g\", \"imafd\")\n+  else:\n+    raise Exception(\"Unexpected arch: `%s`\" % arch[:5])\n+\n+  # Find any Z, S, H or X\n+  long_ext_prefixes_idx = map(lambda x: arch.find(x), LONG_EXT_PREFIXES)\n+\n+  # Filter out any non-existent index.\n+  long_ext_prefixes_idx = list(filter(lambda x: x != -1, long_ext_prefixes_idx))\n+  if long_ext_prefixes_idx:\n+    first_long_ext_idx = min(long_ext_prefixes_idx)\n+    long_exts = arch[first_long_ext_idx:].split(\"_\")\n+    std_exts = list(arch[5:first_long_ext_idx])\n+  else:\n+    long_exts = []\n+    std_exts = list(arch[5:])\n+\n+  #\n+  # Handle implied extensions.\n+  #\n+  for ext in std_exts + long_exts:\n+    if ext in IMPLIED_EXT:\n+      implied_exts = IMPLIED_EXT[ext]\n+      for implied_ext in implied_exts:\n+        if implied_ext not in std_exts + long_exts:\n+          long_exts.append(implied_ext)\n+\n+  # Single letter extension might appear in the long_exts list,\n+  # becasue we just append extensions list to the arch string.\n+  std_exts += list(filter(lambda x:len(x) == 1, long_exts))\n+\n+  # Multi-letter extension must be in lexicographic order.\n+  long_exts = list(sorted(filter(lambda x:len(x) != 1, long_exts)))\n+\n+  # Put extensions in canonical order.\n+  for ext in CANONICAL_ORDER:\n+    if ext in std_exts:\n+      new_arch += ext\n+\n+  # Check every extension is processed.\n+  for ext in std_exts:\n+    if ext == '_':\n+      continue\n+    if ext not in CANONICAL_ORDER:\n+      raise Exception(\"Unsupported extension `%s`\" % ext)\n+\n+  # Concat rest of the multi-char extensions.\n+  if long_exts:\n+    new_arch += \"_\" + \"_\".join(long_exts)\n+  return new_arch\n+\n+if len(sys.argv) < 2:\n+  print (\"Usage: %s <arch_str> [<arch_str>*]\" % sys.argv)\n+  sys.exit(1)\n+\n+for arg in sys.argv[1:]:\n+  print (arch_canonicalize(arg))"}, {"sha": "53c51dfa53f1df0b9a94fd681dbaa48a23cf0d37", "filename": "gcc/config/riscv/multilib-generator", "status": "modified", "additions": 8, "deletions": 75, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20cd0c743b8823d8ac4437bf893ce691fb820e8/gcc%2Fconfig%2Friscv%2Fmultilib-generator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20cd0c743b8823d8ac4437bf893ce691fb820e8/gcc%2Fconfig%2Friscv%2Fmultilib-generator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fmultilib-generator?ref=b20cd0c743b8823d8ac4437bf893ce691fb820e8", "patch": "@@ -35,9 +35,11 @@\n \n from __future__ import print_function\n import sys\n+import os\n import collections\n import itertools\n from functools import reduce\n+import subprocess\n \n #\n # TODO: Add test for this script.\n@@ -48,82 +50,13 @@ abis = collections.OrderedDict()\n required = []\n reuse = []\n \n-canonical_order = \"mafdgqlcbjtpvn\"\n-LONG_EXT_PREFIXES = ['z', 's', 'h', 'x']\n-\n-#\n-# IMPLIED_EXT(ext) -> implied extension list.\n-#\n-IMPLIED_EXT = {\n-  \"d\" : [\"f\"],\n-}\n-\n def arch_canonicalize(arch):\n-  # TODO: Support extension version.\n-  new_arch = \"\"\n-  if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:\n-    # TODO: We should expand g to imad_zifencei once we support newer spec.\n-    new_arch = arch[:5].replace(\"g\", \"imafd\")\n-  else:\n-    raise Exception(\"Unexpected arch: `%s`\" % arch[:5])\n-\n-  # Find any Z, S, H or X\n-  long_ext_prefixes_idx = map(lambda x: arch.find(x), LONG_EXT_PREFIXES)\n-\n-  # Filter out any non-existent index.\n-  long_ext_prefixes_idx = list(filter(lambda x: x != -1, long_ext_prefixes_idx))\n-  if long_ext_prefixes_idx:\n-    first_long_ext_idx = min(long_ext_prefixes_idx)\n-    long_exts = arch[first_long_ext_idx:].split(\"_\")\n-    std_exts = list(arch[5:first_long_ext_idx])\n-  else:\n-    long_exts = []\n-    std_exts = list(arch[5:])\n-\n-  #\n-  # Handle implied extensions.\n-  #\n-  for ext in std_exts + long_exts:\n-    if ext in IMPLIED_EXT:\n-      implied_exts = IMPLIED_EXT[ext]\n-      for implied_ext in implied_exts:\n-        if implied_ext not in std_exts + long_exts:\n-          long_exts.append(implied_ext)\n-\n-  # Single letter extension might appear in the long_exts list,\n-  # becasue we just append extensions list to the arch string.\n-  std_exts += list(filter(lambda x:len(x) == 1, long_exts))\n-\n-  # Multi-letter extension must be in lexicographic order.\n-  long_exts = list(sorted(filter(lambda x:len(x) != 1, long_exts)))\n-\n-  # Put extensions in canonical order.\n-  for ext in canonical_order:\n-    if ext in std_exts:\n-      new_arch += ext\n-\n-  # Check every extension is processed.\n-  for ext in std_exts:\n-    if ext == '_':\n-      continue\n-    if ext not in canonical_order:\n-      raise Exception(\"Unsupported extension `%s`\" % ext)\n-\n-  # Concat rest of the multi-char extensions.\n-  if long_exts:\n-    new_arch += \"_\" + \"_\".join(long_exts)\n-  return new_arch\n-\n-#\n-# add underline for each multi-char extensions.\n-# e.g. [\"a\", \"zfh\"] -> [\"a\", \"_zfh\"]\n-#\n-def add_underline_prefix(ext):\n-  for long_ext_prefix in LONG_EXT_PREFIXES:\n-    if ext.startswith(long_ext_prefix):\n-      return \"_\" + ext\n-\n-  return ext\n+  this_file = os.path.abspath(os.path.join( __file__))\n+  arch_can_script = \\\n+    os.path.join(os.path.dirname(this_file), \"arch-canonicalize\")\n+  proc = subprocess.Popen([arch_can_script, arch], stdout=subprocess.PIPE)\n+  out, err = proc.communicate()\n+  return out.strip()\n \n #\n # Handle expansion operation."}]}