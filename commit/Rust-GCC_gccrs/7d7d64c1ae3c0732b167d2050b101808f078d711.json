{"sha": "7d7d64c1ae3c0732b167d2050b101808f078d711", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q3ZDY0YzFhZTNjMDczMmIxNjdkMjA1MGIxMDE4MDhmMDc4ZDcxMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-01-06T23:26:02Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-01-06T23:26:02Z"}, "message": "libgo: Add sources for go, cgo, and gofmt commands.\n\nThe new commands are not yet built.  That will be done\nseparately.\n\nAlso include a few changes to go/build to support them.\n\nFrom-SVN: r219272", "tree": {"sha": "40ecf33efd29feac369ae050140bc3fefed352e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40ecf33efd29feac369ae050140bc3fefed352e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d7d64c1ae3c0732b167d2050b101808f078d711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7d64c1ae3c0732b167d2050b101808f078d711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d7d64c1ae3c0732b167d2050b101808f078d711", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7d64c1ae3c0732b167d2050b101808f078d711/comments", "author": null, "committer": null, "parents": [{"sha": "efcdb22fe3288fbfa4cd8ba9554b3a561c4d6e08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efcdb22fe3288fbfa4cd8ba9554b3a561c4d6e08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efcdb22fe3288fbfa4cd8ba9554b3a561c4d6e08"}], "stats": {"total": 18994, "additions": 18991, "deletions": 3}, "files": [{"sha": "526b656a30954716b54720df9020f4f44ca53969", "filename": "libgo/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -26,6 +26,7 @@ STAMP = echo timestamp >\n toolexecdir = $(glibgo_toolexecdir)\n toolexeclibdir = $(glibgo_toolexeclibdir)\n toolexeclibgodir = $(nover_glibgo_toolexeclibdir)/go/$(gcc_version)/$(target_alias)\n+libexecsubdir = $(libexecdir)/gcc/$(target_alias)/$(gcc_version)\n \n LIBFFI = @LIBFFI@\n LIBFFIINCS = @LIBFFIINCS@\n@@ -1007,6 +1008,7 @@ s-version: Makefile\n \techo 'const theVersion = \"'`$(GOC) --version | sed 1q`'\"' >> version.go.tmp\n \techo 'const theGoarch = \"'$(GOARCH)'\"' >> version.go.tmp\n \techo 'const theGoos = \"'$(GOOS)'\"' >> version.go.tmp\n+\techo 'const theGccgoToolDir = \"$(libexecsubdir)\"' >> version.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n \t$(STAMP) $@\n "}, {"sha": "2254478aebe27ad2b8e1f202ce37d582ac7bee2b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -454,6 +454,7 @@ STAMP = echo timestamp >\n toolexecdir = $(glibgo_toolexecdir)\n toolexeclibdir = $(glibgo_toolexeclibdir)\n toolexeclibgodir = $(nover_glibgo_toolexeclibdir)/go/$(gcc_version)/$(target_alias)\n+libexecsubdir = $(libexecdir)/gcc/$(target_alias)/$(gcc_version)\n WARN_CFLAGS = $(WARN_FLAGS) $(WERROR)\n \n # -I/-D flags to pass when compiling.\n@@ -4392,6 +4393,7 @@ s-version: Makefile\n \techo 'const theVersion = \"'`$(GOC) --version | sed 1q`'\"' >> version.go.tmp\n \techo 'const theGoarch = \"'$(GOARCH)'\"' >> version.go.tmp\n \techo 'const theGoos = \"'$(GOOS)'\"' >> version.go.tmp\n+\techo 'const theGccgoToolDir = \"$(libexecsubdir)\"' >> version.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n \t$(STAMP) $@\n "}, {"sha": "7757efa1bc31b13217311a29db73371c90e6aaf8", "filename": "libgo/go/cmd/cgo/ast.go", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,460 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Parse input AST and prepare Prog structure.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+func parse(name string, flags parser.Mode) *ast.File {\n+\tast1, err := parser.ParseFile(fset, name, nil, flags)\n+\tif err != nil {\n+\t\tif list, ok := err.(scanner.ErrorList); ok {\n+\t\t\t// If err is a scanner.ErrorList, its String will print just\n+\t\t\t// the first error and then (+n more errors).\n+\t\t\t// Instead, turn it into a new Error that will return\n+\t\t\t// details for all the errors.\n+\t\t\tfor _, e := range list {\n+\t\t\t\tfmt.Fprintln(os.Stderr, e)\n+\t\t\t}\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\tfatalf(\"parsing %s: %s\", name, err)\n+\t}\n+\treturn ast1\n+}\n+\n+func sourceLine(n ast.Node) int {\n+\treturn fset.Position(n.Pos()).Line\n+}\n+\n+// ReadGo populates f with information learned from reading the\n+// Go source file with the given file name.  It gathers the C preamble\n+// attached to the import \"C\" comment, a list of references to C.xxx,\n+// a list of exported functions, and the actual AST, to be rewritten and\n+// printed.\n+func (f *File) ReadGo(name string) {\n+\t// Create absolute path for file, so that it will be used in error\n+\t// messages and recorded in debug line number information.\n+\t// This matches the rest of the toolchain. See golang.org/issue/5122.\n+\tif aname, err := filepath.Abs(name); err == nil {\n+\t\tname = aname\n+\t}\n+\n+\t// Two different parses: once with comments, once without.\n+\t// The printer is not good enough at printing comments in the\n+\t// right place when we start editing the AST behind its back,\n+\t// so we use ast1 to look for the doc comments on import \"C\"\n+\t// and on exported functions, and we use ast2 for translating\n+\t// and reprinting.\n+\tast1 := parse(name, parser.ParseComments)\n+\tast2 := parse(name, 0)\n+\n+\tf.Package = ast1.Name.Name\n+\tf.Name = make(map[string]*Name)\n+\n+\t// In ast1, find the import \"C\" line and get any extra C preamble.\n+\tsawC := false\n+\tfor _, decl := range ast1.Decls {\n+\t\td, ok := decl.(*ast.GenDecl)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, spec := range d.Specs {\n+\t\t\ts, ok := spec.(*ast.ImportSpec)\n+\t\t\tif !ok || string(s.Path.Value) != `\"C\"` {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tsawC = true\n+\t\t\tif s.Name != nil {\n+\t\t\t\terror_(s.Path.Pos(), `cannot rename import \"C\"`)\n+\t\t\t}\n+\t\t\tcg := s.Doc\n+\t\t\tif cg == nil && len(d.Specs) == 1 {\n+\t\t\t\tcg = d.Doc\n+\t\t\t}\n+\t\t\tif cg != nil {\n+\t\t\t\tf.Preamble += fmt.Sprintf(\"#line %d %q\\n\", sourceLine(cg), name)\n+\t\t\t\tf.Preamble += commentText(cg) + \"\\n\"\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif !sawC {\n+\t\terror_(token.NoPos, `cannot find import \"C\"`)\n+\t}\n+\n+\t// In ast2, strip the import \"C\" line.\n+\tw := 0\n+\tfor _, decl := range ast2.Decls {\n+\t\td, ok := decl.(*ast.GenDecl)\n+\t\tif !ok {\n+\t\t\tast2.Decls[w] = decl\n+\t\t\tw++\n+\t\t\tcontinue\n+\t\t}\n+\t\tws := 0\n+\t\tfor _, spec := range d.Specs {\n+\t\t\ts, ok := spec.(*ast.ImportSpec)\n+\t\t\tif !ok || string(s.Path.Value) != `\"C\"` {\n+\t\t\t\td.Specs[ws] = spec\n+\t\t\t\tws++\n+\t\t\t}\n+\t\t}\n+\t\tif ws == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\td.Specs = d.Specs[0:ws]\n+\t\tast2.Decls[w] = d\n+\t\tw++\n+\t}\n+\tast2.Decls = ast2.Decls[0:w]\n+\n+\t// Accumulate pointers to uses of C.x.\n+\tif f.Ref == nil {\n+\t\tf.Ref = make([]*Ref, 0, 8)\n+\t}\n+\tf.walk(ast2, \"prog\", (*File).saveRef)\n+\n+\t// Accumulate exported functions.\n+\t// The comments are only on ast1 but we need to\n+\t// save the function bodies from ast2.\n+\t// The first walk fills in ExpFunc, and the\n+\t// second walk changes the entries to\n+\t// refer to ast2 instead.\n+\tf.walk(ast1, \"prog\", (*File).saveExport)\n+\tf.walk(ast2, \"prog\", (*File).saveExport2)\n+\n+\tf.Comments = ast1.Comments\n+\tf.AST = ast2\n+}\n+\n+// Like ast.CommentGroup's Text method but preserves\n+// leading blank lines, so that line numbers line up.\n+func commentText(g *ast.CommentGroup) string {\n+\tif g == nil {\n+\t\treturn \"\"\n+\t}\n+\tvar pieces []string\n+\tfor _, com := range g.List {\n+\t\tc := string(com.Text)\n+\t\t// Remove comment markers.\n+\t\t// The parser has given us exactly the comment text.\n+\t\tswitch c[1] {\n+\t\tcase '/':\n+\t\t\t//-style comment (no newline at the end)\n+\t\t\tc = c[2:] + \"\\n\"\n+\t\tcase '*':\n+\t\t\t/*-style comment */\n+\t\t\tc = c[2 : len(c)-2]\n+\t\t}\n+\t\tpieces = append(pieces, c)\n+\t}\n+\treturn strings.Join(pieces, \"\")\n+}\n+\n+// Save references to C.xxx for later processing.\n+func (f *File) saveRef(x interface{}, context string) {\n+\tn, ok := x.(*ast.Expr)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\tif sel, ok := (*n).(*ast.SelectorExpr); ok {\n+\t\t// For now, assume that the only instance of capital C is\n+\t\t// when used as the imported package identifier.\n+\t\t// The parser should take care of scoping in the future,\n+\t\t// so that we will be able to distinguish a \"top-level C\"\n+\t\t// from a local C.\n+\t\tif l, ok := sel.X.(*ast.Ident); ok && l.Name == \"C\" {\n+\t\t\tif context == \"as2\" {\n+\t\t\t\tcontext = \"expr\"\n+\t\t\t}\n+\t\t\tif context == \"embed-type\" {\n+\t\t\t\terror_(sel.Pos(), \"cannot embed C type\")\n+\t\t\t}\n+\t\t\tgoname := sel.Sel.Name\n+\t\t\tif goname == \"errno\" {\n+\t\t\t\terror_(sel.Pos(), \"cannot refer to errno directly; see documentation\")\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif goname == \"_CMalloc\" {\n+\t\t\t\terror_(sel.Pos(), \"cannot refer to C._CMalloc; use C.malloc\")\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif goname == \"malloc\" {\n+\t\t\t\tgoname = \"_CMalloc\"\n+\t\t\t}\n+\t\t\tname := f.Name[goname]\n+\t\t\tif name == nil {\n+\t\t\t\tname = &Name{\n+\t\t\t\t\tGo: goname,\n+\t\t\t\t}\n+\t\t\t\tf.Name[goname] = name\n+\t\t\t}\n+\t\t\tf.Ref = append(f.Ref, &Ref{\n+\t\t\t\tName:    name,\n+\t\t\t\tExpr:    n,\n+\t\t\t\tContext: context,\n+\t\t\t})\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// If a function should be exported add it to ExpFunc.\n+func (f *File) saveExport(x interface{}, context string) {\n+\tn, ok := x.(*ast.FuncDecl)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\tif n.Doc == nil {\n+\t\treturn\n+\t}\n+\tfor _, c := range n.Doc.List {\n+\t\tif !strings.HasPrefix(string(c.Text), \"//export \") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tname := strings.TrimSpace(string(c.Text[9:]))\n+\t\tif name == \"\" {\n+\t\t\terror_(c.Pos(), \"export missing name\")\n+\t\t}\n+\n+\t\tif name != n.Name.Name {\n+\t\t\terror_(c.Pos(), \"export comment has wrong name %q, want %q\", name, n.Name.Name)\n+\t\t}\n+\n+\t\tf.ExpFunc = append(f.ExpFunc, &ExpFunc{\n+\t\t\tFunc:    n,\n+\t\t\tExpName: name,\n+\t\t})\n+\t\tbreak\n+\t}\n+}\n+\n+// Make f.ExpFunc[i] point at the Func from this AST instead of the other one.\n+func (f *File) saveExport2(x interface{}, context string) {\n+\tn, ok := x.(*ast.FuncDecl)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\tfor _, exp := range f.ExpFunc {\n+\t\tif exp.Func.Name.Name == n.Name.Name {\n+\t\t\texp.Func = n\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+// walk walks the AST x, calling visit(f, x, context) for each node.\n+func (f *File) walk(x interface{}, context string, visit func(*File, interface{}, string)) {\n+\tvisit(f, x, context)\n+\tswitch n := x.(type) {\n+\tcase *ast.Expr:\n+\t\tf.walk(*n, context, visit)\n+\n+\t// everything else just recurs\n+\tdefault:\n+\t\terror_(token.NoPos, \"unexpected type %T in walk\", x, visit)\n+\t\tpanic(\"unexpected type\")\n+\n+\tcase nil:\n+\n+\t// These are ordered and grouped to match ../../pkg/go/ast/ast.go\n+\tcase *ast.Field:\n+\t\tif len(n.Names) == 0 && context == \"field\" {\n+\t\t\tf.walk(&n.Type, \"embed-type\", visit)\n+\t\t} else {\n+\t\t\tf.walk(&n.Type, \"type\", visit)\n+\t\t}\n+\tcase *ast.FieldList:\n+\t\tfor _, field := range n.List {\n+\t\t\tf.walk(field, context, visit)\n+\t\t}\n+\tcase *ast.BadExpr:\n+\tcase *ast.Ident:\n+\tcase *ast.Ellipsis:\n+\tcase *ast.BasicLit:\n+\tcase *ast.FuncLit:\n+\t\tf.walk(n.Type, \"type\", visit)\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\tcase *ast.CompositeLit:\n+\t\tf.walk(&n.Type, \"type\", visit)\n+\t\tf.walk(n.Elts, \"expr\", visit)\n+\tcase *ast.ParenExpr:\n+\t\tf.walk(&n.X, context, visit)\n+\tcase *ast.SelectorExpr:\n+\t\tf.walk(&n.X, \"selector\", visit)\n+\tcase *ast.IndexExpr:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.Index, \"expr\", visit)\n+\tcase *ast.SliceExpr:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tif n.Low != nil {\n+\t\t\tf.walk(&n.Low, \"expr\", visit)\n+\t\t}\n+\t\tif n.High != nil {\n+\t\t\tf.walk(&n.High, \"expr\", visit)\n+\t\t}\n+\tcase *ast.TypeAssertExpr:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.Type, \"type\", visit)\n+\tcase *ast.CallExpr:\n+\t\tif context == \"as2\" {\n+\t\t\tf.walk(&n.Fun, \"call2\", visit)\n+\t\t} else {\n+\t\t\tf.walk(&n.Fun, \"call\", visit)\n+\t\t}\n+\t\tf.walk(n.Args, \"expr\", visit)\n+\tcase *ast.StarExpr:\n+\t\tf.walk(&n.X, context, visit)\n+\tcase *ast.UnaryExpr:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\tcase *ast.BinaryExpr:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.Y, \"expr\", visit)\n+\tcase *ast.KeyValueExpr:\n+\t\tf.walk(&n.Key, \"expr\", visit)\n+\t\tf.walk(&n.Value, \"expr\", visit)\n+\n+\tcase *ast.ArrayType:\n+\t\tf.walk(&n.Len, \"expr\", visit)\n+\t\tf.walk(&n.Elt, \"type\", visit)\n+\tcase *ast.StructType:\n+\t\tf.walk(n.Fields, \"field\", visit)\n+\tcase *ast.FuncType:\n+\t\tf.walk(n.Params, \"param\", visit)\n+\t\tif n.Results != nil {\n+\t\t\tf.walk(n.Results, \"param\", visit)\n+\t\t}\n+\tcase *ast.InterfaceType:\n+\t\tf.walk(n.Methods, \"field\", visit)\n+\tcase *ast.MapType:\n+\t\tf.walk(&n.Key, \"type\", visit)\n+\t\tf.walk(&n.Value, \"type\", visit)\n+\tcase *ast.ChanType:\n+\t\tf.walk(&n.Value, \"type\", visit)\n+\n+\tcase *ast.BadStmt:\n+\tcase *ast.DeclStmt:\n+\t\tf.walk(n.Decl, \"decl\", visit)\n+\tcase *ast.EmptyStmt:\n+\tcase *ast.LabeledStmt:\n+\t\tf.walk(n.Stmt, \"stmt\", visit)\n+\tcase *ast.ExprStmt:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\tcase *ast.SendStmt:\n+\t\tf.walk(&n.Chan, \"expr\", visit)\n+\t\tf.walk(&n.Value, \"expr\", visit)\n+\tcase *ast.IncDecStmt:\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\tcase *ast.AssignStmt:\n+\t\tf.walk(n.Lhs, \"expr\", visit)\n+\t\tif len(n.Lhs) == 2 && len(n.Rhs) == 1 {\n+\t\t\tf.walk(n.Rhs, \"as2\", visit)\n+\t\t} else {\n+\t\t\tf.walk(n.Rhs, \"expr\", visit)\n+\t\t}\n+\tcase *ast.GoStmt:\n+\t\tf.walk(n.Call, \"expr\", visit)\n+\tcase *ast.DeferStmt:\n+\t\tf.walk(n.Call, \"expr\", visit)\n+\tcase *ast.ReturnStmt:\n+\t\tf.walk(n.Results, \"expr\", visit)\n+\tcase *ast.BranchStmt:\n+\tcase *ast.BlockStmt:\n+\t\tf.walk(n.List, context, visit)\n+\tcase *ast.IfStmt:\n+\t\tf.walk(n.Init, \"stmt\", visit)\n+\t\tf.walk(&n.Cond, \"expr\", visit)\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(n.Else, \"stmt\", visit)\n+\tcase *ast.CaseClause:\n+\t\tif context == \"typeswitch\" {\n+\t\t\tcontext = \"type\"\n+\t\t} else {\n+\t\t\tcontext = \"expr\"\n+\t\t}\n+\t\tf.walk(n.List, context, visit)\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\tcase *ast.SwitchStmt:\n+\t\tf.walk(n.Init, \"stmt\", visit)\n+\t\tf.walk(&n.Tag, \"expr\", visit)\n+\t\tf.walk(n.Body, \"switch\", visit)\n+\tcase *ast.TypeSwitchStmt:\n+\t\tf.walk(n.Init, \"stmt\", visit)\n+\t\tf.walk(n.Assign, \"stmt\", visit)\n+\t\tf.walk(n.Body, \"typeswitch\", visit)\n+\tcase *ast.CommClause:\n+\t\tf.walk(n.Comm, \"stmt\", visit)\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\tcase *ast.SelectStmt:\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\tcase *ast.ForStmt:\n+\t\tf.walk(n.Init, \"stmt\", visit)\n+\t\tf.walk(&n.Cond, \"expr\", visit)\n+\t\tf.walk(n.Post, \"stmt\", visit)\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\tcase *ast.RangeStmt:\n+\t\tf.walk(&n.Key, \"expr\", visit)\n+\t\tf.walk(&n.Value, \"expr\", visit)\n+\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(n.Body, \"stmt\", visit)\n+\n+\tcase *ast.ImportSpec:\n+\tcase *ast.ValueSpec:\n+\t\tf.walk(&n.Type, \"type\", visit)\n+\t\tf.walk(n.Values, \"expr\", visit)\n+\tcase *ast.TypeSpec:\n+\t\tf.walk(&n.Type, \"type\", visit)\n+\n+\tcase *ast.BadDecl:\n+\tcase *ast.GenDecl:\n+\t\tf.walk(n.Specs, \"spec\", visit)\n+\tcase *ast.FuncDecl:\n+\t\tif n.Recv != nil {\n+\t\t\tf.walk(n.Recv, \"param\", visit)\n+\t\t}\n+\t\tf.walk(n.Type, \"type\", visit)\n+\t\tif n.Body != nil {\n+\t\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\t}\n+\n+\tcase *ast.File:\n+\t\tf.walk(n.Decls, \"decl\", visit)\n+\n+\tcase *ast.Package:\n+\t\tfor _, file := range n.Files {\n+\t\t\tf.walk(file, \"file\", visit)\n+\t\t}\n+\n+\tcase []ast.Decl:\n+\t\tfor _, d := range n {\n+\t\t\tf.walk(d, context, visit)\n+\t\t}\n+\tcase []ast.Expr:\n+\t\tfor i := range n {\n+\t\t\tf.walk(&n[i], context, visit)\n+\t\t}\n+\tcase []ast.Stmt:\n+\t\tfor _, s := range n {\n+\t\t\tf.walk(s, context, visit)\n+\t\t}\n+\tcase []ast.Spec:\n+\t\tfor _, s := range n {\n+\t\t\tf.walk(s, context, visit)\n+\t\t}\n+\t}\n+}"}, {"sha": "69c7ce893c3d1516c8fba1316f3c128c9bbd988a", "filename": "libgo/go/cmd/cgo/doc.go", "status": "added", "additions": 748, "deletions": 0, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,748 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+\n+Cgo enables the creation of Go packages that call C code.\n+\n+Using cgo with the go command\n+\n+To use cgo write normal Go code that imports a pseudo-package \"C\".\n+The Go code can then refer to types such as C.size_t, variables such\n+as C.stdout, or functions such as C.putchar.\n+\n+If the import of \"C\" is immediately preceded by a comment, that\n+comment, called the preamble, is used as a header when compiling\n+the C parts of the package.  For example:\n+\n+\t// #include <stdio.h>\n+\t// #include <errno.h>\n+\timport \"C\"\n+\n+See $GOROOT/misc/cgo/stdio and $GOROOT/misc/cgo/gmp for examples.  See\n+\"C? Go? Cgo!\" for an introduction to using cgo:\n+http://golang.org/doc/articles/c_go_cgo.html.\n+\n+CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS may be defined with pseudo #cgo\n+directives within these comments to tweak the behavior of the C or C++\n+compiler.  Values defined in multiple directives are concatenated\n+together.  The directive can include a list of build constraints limiting its\n+effect to systems satisfying one of the constraints\n+(see http://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax).\n+For example:\n+\n+\t// #cgo CFLAGS: -DPNG_DEBUG=1\n+\t// #cgo amd64 386 CFLAGS: -DX86=1\n+\t// #cgo LDFLAGS: -lpng\n+\t// #include <png.h>\n+\timport \"C\"\n+\n+Alternatively, CPPFLAGS and LDFLAGS may be obtained via the pkg-config\n+tool using a '#cgo pkg-config:' directive followed by the package names.\n+For example:\n+\n+\t// #cgo pkg-config: png cairo\n+\t// #include <png.h>\n+\timport \"C\"\n+\n+When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS and\n+CGO_LDFLAGS environment variables are added to the flags derived from\n+these directives.  Package-specific flags should be set using the\n+directives, not the environment variables, so that builds work in\n+unmodified environments.\n+\n+All the cgo CPPFLAGS and CFLAGS directives in a package are concatenated and\n+used to compile C files in that package.  All the CPPFLAGS and CXXFLAGS\n+directives in a package are concatenated and used to compile C++ files in that\n+package.  All the LDFLAGS directives in any package in the program are\n+concatenated and used at link time.  All the pkg-config directives are\n+concatenated and sent to pkg-config simultaneously to add to each appropriate\n+set of command-line flags.\n+\n+When the Go tool sees that one or more Go files use the special import\n+\"C\", it will look for other non-Go files in the directory and compile\n+them as part of the Go package.  Any .c, .s, or .S files will be\n+compiled with the C compiler.  Any .cc, .cpp, or .cxx files will be\n+compiled with the C++ compiler.  Any .h, .hh, .hpp, or .hxx files will\n+not be compiled separately, but, if these header files are changed,\n+the C and C++ files will be recompiled.  The default C and C++\n+compilers may be changed by the CC and CXX environment variables,\n+respectively; those environment variables may include command line\n+options.\n+\n+To enable cgo during cross compiling builds, set the CGO_ENABLED\n+environment variable to 1 when building the Go tools with make.bash.\n+Also, set CC_FOR_TARGET to the C cross compiler for the target.  CC will\n+be used for compiling for the host.\n+\n+After the Go tools are built, when running the go command, CC_FOR_TARGET is\n+ignored.  The value of CC_FOR_TARGET when running make.bash is the default\n+compiler.  However, you can set the environment variable CC, not CC_FOR_TARGET,\n+to control the compiler when running the go tool.\n+\n+CXX_FOR_TARGET works in a similar way for C++ code.\n+\n+Go references to C\n+\n+Within the Go file, C's struct field names that are keywords in Go\n+can be accessed by prefixing them with an underscore: if x points at a C\n+struct with a field named \"type\", x._type accesses the field.\n+C struct fields that cannot be expressed in Go, such as bit fields\n+or misaligned data, are omitted in the Go struct, replaced by\n+appropriate padding to reach the next field or the end of the struct.\n+\n+The standard C numeric types are available under the names\n+C.char, C.schar (signed char), C.uchar (unsigned char),\n+C.short, C.ushort (unsigned short), C.int, C.uint (unsigned int),\n+C.long, C.ulong (unsigned long), C.longlong (long long),\n+C.ulonglong (unsigned long long), C.float, C.double.\n+The C type void* is represented by Go's unsafe.Pointer.\n+\n+To access a struct, union, or enum type directly, prefix it with\n+struct_, union_, or enum_, as in C.struct_stat.\n+\n+As Go doesn't have support for C's union type in the general case,\n+C's union types are represented as a Go byte array with the same length.\n+\n+Go structs cannot embed fields with C types.\n+\n+Cgo translates C types into equivalent unexported Go types.\n+Because the translations are unexported, a Go package should not\n+expose C types in its exported API: a C type used in one Go package\n+is different from the same C type used in another.\n+\n+Any C function (even void functions) may be called in a multiple\n+assignment context to retrieve both the return value (if any) and the\n+C errno variable as an error (use _ to skip the result value if the\n+function returns void).  For example:\n+\n+\tn, err := C.sqrt(-1)\n+\t_, err := C.voidFunc()\n+\n+Calling C function pointers is currently not supported, however you can\n+declare Go variables which hold C function pointers and pass them\n+back and forth between Go and C. C code may call function pointers\n+received from Go. For example:\n+\n+\tpackage main\n+\n+\t// typedef int (*intFunc) ();\n+\t//\n+\t// int\n+\t// bridge_int_func(intFunc f)\n+\t// {\n+\t//\t\treturn f();\n+\t// }\n+\t//\n+\t// int fortytwo()\n+\t// {\n+\t//\t    return 42;\n+\t// }\n+\timport \"C\"\n+\timport \"fmt\"\n+\n+\tfunc main() {\n+\t\tf := C.intFunc(C.fortytwo)\n+\t\tfmt.Println(int(C.bridge_int_func(f)))\n+\t\t// Output: 42\n+\t}\n+\n+In C, a function argument written as a fixed size array\n+actually requires a pointer to the first element of the array.\n+C compilers are aware of this calling convention and adjust\n+the call accordingly, but Go cannot.  In Go, you must pass\n+the pointer to the first element explicitly: C.f(&x[0]).\n+\n+A few special functions convert between Go and C types\n+by making copies of the data.  In pseudo-Go definitions:\n+\n+\t// Go string to C string\n+\t// The C string is allocated in the C heap using malloc.\n+\t// It is the caller's responsibility to arrange for it to be\n+\t// freed, such as by calling C.free (be sure to include stdlib.h\n+\t// if C.free is needed).\n+\tfunc C.CString(string) *C.char\n+\n+\t// C string to Go string\n+\tfunc C.GoString(*C.char) string\n+\n+\t// C string, length to Go string\n+\tfunc C.GoStringN(*C.char, C.int) string\n+\n+\t// C pointer, length to Go []byte\n+\tfunc C.GoBytes(unsafe.Pointer, C.int) []byte\n+\n+C references to Go\n+\n+Go functions can be exported for use by C code in the following way:\n+\n+\t//export MyFunction\n+\tfunc MyFunction(arg1, arg2 int, arg3 string) int64 {...}\n+\n+\t//export MyFunction2\n+\tfunc MyFunction2(arg1, arg2 int, arg3 string) (int64, *C.char) {...}\n+\n+They will be available in the C code as:\n+\n+\textern int64 MyFunction(int arg1, int arg2, GoString arg3);\n+\textern struct MyFunction2_return MyFunction2(int arg1, int arg2, GoString arg3);\n+\n+found in the _cgo_export.h generated header, after any preambles\n+copied from the cgo input files. Functions with multiple\n+return values are mapped to functions returning a struct.\n+Not all Go types can be mapped to C types in a useful way.\n+\n+Using //export in a file places a restriction on the preamble:\n+since it is copied into two different C output files, it must not\n+contain any definitions, only declarations. Definitions must be\n+placed in preambles in other files, or in C source files.\n+\n+Using cgo directly\n+\n+Usage:\n+\tgo tool cgo [cgo options] [-- compiler options] file.go\n+\n+Cgo transforms the input file.go into four output files: two Go source\n+files, a C file for 6c (or 8c or 5c), and a C file for gcc.\n+\n+The compiler options are passed through uninterpreted when\n+invoking the C compiler to compile the C parts of the package.\n+\n+The following options are available when running cgo directly:\n+\n+\t-dynimport file\n+\t\tWrite list of symbols imported by file. Write to\n+\t\t-dynout argument or to standard output. Used by go\n+\t\tbuild when building a cgo package.\n+\t-dynout file\n+\t\tWrite -dynimport output to file.\n+\t-dynlinker\n+\t\tWrite dynamic linker as part of -dynimport output.\n+\t-godefs\n+\t\tWrite out input file in Go syntax replacing C package\n+\t\tnames with real values. Used to generate files in the\n+\t\tsyscall package when bootstrapping a new target.\n+\t-cdefs\n+\t\tLike -godefs, but write file in C syntax.\n+\t\tUsed to generate files in the runtime package when\n+\t\tbootstrapping a new target.\n+\t-objdir directory\n+\t\tPut all generated files in directory.\n+\t-gccgo\n+\t\tGenerate output for the gccgo compiler rather than the\n+\t\tgc compiler.\n+\t-gccgoprefix prefix\n+\t\tThe -fgo-prefix option to be used with gccgo.\n+\t-gccgopkgpath path\n+\t\tThe -fgo-pkgpath option to be used with gccgo.\n+\t-import_runtime_cgo\n+\t\tIf set (which it is by default) import runtime/cgo in\n+\t\tgenerated output.\n+\t-import_syscall\n+\t\tIf set (which it is by default) import syscall in\n+\t\tgenerated output.\n+\t-debug-define\n+\t\tDebugging option. Print #defines.\n+\t-debug-gcc\n+\t\tDebugging option. Trace C compiler execution and output.\n+*/\n+package main\n+\n+/*\n+Implementation details.\n+\n+Cgo provides a way for Go programs to call C code linked into the same\n+address space. This comment explains the operation of cgo.\n+\n+Cgo reads a set of Go source files and looks for statements saying\n+import \"C\". If the import has a doc comment, that comment is\n+taken as literal C code to be used as a preamble to any C code\n+generated by cgo. A typical preamble #includes necessary definitions:\n+\n+\t// #include <stdio.h>\n+\timport \"C\"\n+\n+For more details about the usage of cgo, see the documentation\n+comment at the top of this file.\n+\n+Understanding C\n+\n+Cgo scans the Go source files that import \"C\" for uses of that\n+package, such as C.puts. It collects all such identifiers. The next\n+step is to determine each kind of name. In C.xxx the xxx might refer\n+to a type, a function, a constant, or a global variable. Cgo must\n+decide which.\n+\n+The obvious thing for cgo to do is to process the preamble, expanding\n+#includes and processing the corresponding C code. That would require\n+a full C parser and type checker that was also aware of any extensions\n+known to the system compiler (for example, all the GNU C extensions) as\n+well as the system-specific header locations and system-specific\n+pre-#defined macros. This is certainly possible to do, but it is an\n+enormous amount of work.\n+\n+Cgo takes a different approach. It determines the meaning of C\n+identifiers not by parsing C code but by feeding carefully constructed\n+programs into the system C compiler and interpreting the generated\n+error messages, debug information, and object files. In practice,\n+parsing these is significantly less work and more robust than parsing\n+C source.\n+\n+Cgo first invokes gcc -E -dM on the preamble, in order to find out\n+about simple #defines for constants and the like. These are recorded\n+for later use.\n+\n+Next, cgo needs to identify the kinds for each identifier. For the\n+identifiers C.foo and C.bar, cgo generates this C program:\n+\n+\t<preamble>\n+\t#line 1 \"not-declared\"\n+\tvoid __cgo_f_xxx_1(void) { __typeof__(foo) *__cgo_undefined__; }\n+\t#line 1 \"not-type\"\n+\tvoid __cgo_f_xxx_2(void) { foo *__cgo_undefined__; }\n+\t#line 1 \"not-const\"\n+\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (foo)*1 }; }\n+\t#line 2 \"not-declared\"\n+\tvoid __cgo_f_xxx_1(void) { __typeof__(bar) *__cgo_undefined__; }\n+\t#line 2 \"not-type\"\n+\tvoid __cgo_f_xxx_2(void) { bar *__cgo_undefined__; }\n+\t#line 2 \"not-const\"\n+\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (bar)*1 }; }\n+\n+This program will not compile, but cgo can use the presence or absence\n+of an error message on a given line to deduce the information it\n+needs. The program is syntactically valid regardless of whether each\n+name is a type or an ordinary identifier, so there will be no syntax\n+errors that might stop parsing early.\n+\n+An error on not-declared:1 indicates that foo is undeclared.\n+An error on not-type:1 indicates that foo is not a type (if declared at all, it is an identifier).\n+An error on not-const:1 indicates that foo is not an integer constant.\n+\n+The line number specifies the name involved. In the example, 1 is foo and 2 is bar.\n+\n+Next, cgo must learn the details of each type, variable, function, or\n+constant. It can do this by reading object files. If cgo has decided\n+that t1 is a type, v2 and v3 are variables or functions, and c4, c5,\n+and c6 are constants, it generates:\n+\n+\t<preamble>\n+\t__typeof__(t1) *__cgo__1;\n+\t__typeof__(v2) *__cgo__2;\n+\t__typeof__(v3) *__cgo__3;\n+\t__typeof__(c4) *__cgo__4;\n+\tenum { __cgo_enum__4 = c4 };\n+\t__typeof__(c5) *__cgo__5;\n+\tenum { __cgo_enum__5 = c5 };\n+\t__typeof__(c6) *__cgo__6;\n+\tenum { __cgo_enum__6 = c6 };\n+\n+\tlong long __cgo_debug_data[] = {\n+\t\t0, // t1\n+\t\t0, // v2\n+\t\t0, // v3\n+\t\tc4,\n+\t\tc5,\n+\t\tc6,\n+\t\t1\n+\t};\n+\n+and again invokes the system C compiler, to produce an object file\n+containing debug information. Cgo parses the DWARF debug information\n+for __cgo__N to learn the type of each identifier. (The types also\n+distinguish functions from global variables.) If using a standard gcc,\n+cgo can parse the DWARF debug information for the __cgo_enum__N to\n+learn the identifier's value. The LLVM-based gcc on OS X emits\n+incomplete DWARF information for enums; in that case cgo reads the\n+constant values from the __cgo_debug_data from the object file's data\n+segment.\n+\n+At this point cgo knows the meaning of each C.xxx well enough to start\n+the translation process.\n+\n+Translating Go\n+\n+[The rest of this comment refers to 6g and 6c, the Go and C compilers\n+that are part of the amd64 port of the gc Go toolchain. Everything here\n+applies to another architecture's compilers as well.]\n+\n+Given the input Go files x.go and y.go, cgo generates these source\n+files:\n+\n+\tx.cgo1.go       # for 6g\n+\ty.cgo1.go       # for 6g\n+\t_cgo_gotypes.go # for 6g\n+\t_cgo_defun.c    # for 6c\n+\tx.cgo2.c        # for gcc\n+\ty.cgo2.c        # for gcc\n+\t_cgo_export.c   # for gcc\n+\t_cgo_main.c     # for gcc\n+\n+The file x.cgo1.go is a copy of x.go with the import \"C\" removed and\n+references to C.xxx replaced with names like _Cfunc_xxx or _Ctype_xxx.\n+The definitions of those identifiers, written as Go functions, types,\n+or variables, are provided in _cgo_gotypes.go.\n+\n+Here is a _cgo_gotypes.go containing definitions for C.flush (provided\n+in the preamble) and C.puts (from stdio):\n+\n+\ttype _Ctype_char int8\n+\ttype _Ctype_int int32\n+\ttype _Ctype_void [0]byte\n+\n+\tfunc _Cfunc_CString(string) *_Ctype_char\n+\tfunc _Cfunc_flush() _Ctype_void\n+\tfunc _Cfunc_puts(*_Ctype_char) _Ctype_int\n+\n+For functions, cgo only writes an external declaration in the Go\n+output. The implementation is in a combination of C for 6c (meaning\n+any gc-toolchain compiler) and C for gcc.\n+\n+The 6c file contains the definitions of the functions. They all have\n+similar bodies that invoke runtime\u00b7cgocall to make a switch from the\n+Go runtime world to the system C (GCC-based) world.\n+\n+For example, here is the definition of _Cfunc_puts:\n+\n+\tvoid _cgo_be59f0f25121_Cfunc_puts(void*);\n+\n+\tvoid\n+\t\u00b7_Cfunc_puts(struct{uint8 x[1];}p)\n+\t{\n+\t\truntime\u00b7cgocall(_cgo_be59f0f25121_Cfunc_puts, &p);\n+\t}\n+\n+The hexadecimal number is a hash of cgo's input, chosen to be\n+deterministic yet unlikely to collide with other uses. The actual\n+function _cgo_be59f0f25121_Cfunc_puts is implemented in a C source\n+file compiled by gcc, the file x.cgo2.c:\n+\n+\tvoid\n+\t_cgo_be59f0f25121_Cfunc_puts(void *v)\n+\t{\n+\t\tstruct {\n+\t\t\tchar* p0;\n+\t\t\tint r;\n+\t\t\tchar __pad12[4];\n+\t\t} __attribute__((__packed__, __gcc_struct__)) *a = v;\n+\t\ta->r = puts((void*)a->p0);\n+\t}\n+\n+It extracts the arguments from the pointer to _Cfunc_puts's argument\n+frame, invokes the system C function (in this case, puts), stores the\n+result in the frame, and returns.\n+\n+Linking\n+\n+Once the _cgo_export.c and *.cgo2.c files have been compiled with gcc,\n+they need to be linked into the final binary, along with the libraries\n+they might depend on (in the case of puts, stdio). 6l has been\n+extended to understand basic ELF files, but it does not understand ELF\n+in the full complexity that modern C libraries embrace, so it cannot\n+in general generate direct references to the system libraries.\n+\n+Instead, the build process generates an object file using dynamic\n+linkage to the desired libraries. The main function is provided by\n+_cgo_main.c:\n+\n+\tint main() { return 0; }\n+\tvoid crosscall2(void(*fn)(void*, int), void *a, int c) { }\n+\tvoid _cgo_allocate(void *a, int c) { }\n+\tvoid _cgo_panic(void *a, int c) { }\n+\n+The extra functions here are stubs to satisfy the references in the C\n+code generated for gcc. The build process links this stub, along with\n+_cgo_export.c and *.cgo2.c, into a dynamic executable and then lets\n+cgo examine the executable. Cgo records the list of shared library\n+references and resolved names and writes them into a new file\n+_cgo_import.c, which looks like:\n+\n+\t#pragma cgo_dynamic_linker \"/lib64/ld-linux-x86-64.so.2\"\n+\t#pragma cgo_import_dynamic puts puts#GLIBC_2.2.5 \"libc.so.6\"\n+\t#pragma cgo_import_dynamic __libc_start_main __libc_start_main#GLIBC_2.2.5 \"libc.so.6\"\n+\t#pragma cgo_import_dynamic stdout stdout#GLIBC_2.2.5 \"libc.so.6\"\n+\t#pragma cgo_import_dynamic fflush fflush#GLIBC_2.2.5 \"libc.so.6\"\n+\t#pragma cgo_import_dynamic _ _ \"libpthread.so.0\"\n+\t#pragma cgo_import_dynamic _ _ \"libc.so.6\"\n+\n+In the end, the compiled Go package, which will eventually be\n+presented to 6l as part of a larger program, contains:\n+\n+\t_go_.6        # 6g-compiled object for _cgo_gotypes.go *.cgo1.go\n+\t_cgo_defun.6  # 6c-compiled object for _cgo_defun.c\n+\t_all.o        # gcc-compiled object for _cgo_export.c, *.cgo2.c\n+\t_cgo_import.6 # 6c-compiled object for _cgo_import.c\n+\n+The final program will be a dynamic executable, so that 6l can avoid\n+needing to process arbitrary .o files. It only needs to process the .o\n+files generated from C files that cgo writes, and those are much more\n+limited in the ELF or other features that they use.\n+\n+In essence, the _cgo_import.6 file includes the extra linking\n+directives that 6l is not sophisticated enough to derive from _all.o\n+on its own. Similarly, the _all.o uses dynamic references to real\n+system object code because 6l is not sophisticated enough to process\n+the real code.\n+\n+The main benefits of this system are that 6l remains relatively simple\n+(it does not need to implement a complete ELF and Mach-O linker) and\n+that gcc is not needed after the package is compiled. For example,\n+package net uses cgo for access to name resolution functions provided\n+by libc. Although gcc is needed to compile package net, gcc is not\n+needed to link programs that import package net.\n+\n+Runtime\n+\n+When using cgo, Go must not assume that it owns all details of the\n+process. In particular it needs to coordinate with C in the use of\n+threads and thread-local storage. The runtime package, in its own\n+(6c-compiled) C code, declares a few uninitialized (default bss)\n+variables:\n+\n+\tbool\truntime\u00b7iscgo;\n+\tvoid\t(*libcgo_thread_start)(void*);\n+\tvoid\t(*initcgo)(G*);\n+\n+Any package using cgo imports \"runtime/cgo\", which provides\n+initializations for these variables. It sets iscgo to 1, initcgo to a\n+gcc-compiled function that can be called early during program startup,\n+and libcgo_thread_start to a gcc-compiled function that can be used to\n+create a new thread, in place of the runtime's usual direct system\n+calls.\n+\n+Internal and External Linking\n+\n+The text above describes \"internal\" linking, in which 6l parses and\n+links host object files (ELF, Mach-O, PE, and so on) into the final\n+executable itself. Keeping 6l simple means we cannot possibly\n+implement the full semantics of the host linker, so the kinds of\n+objects that can be linked directly into the binary is limited (other\n+code can only be used as a dynamic library). On the other hand, when\n+using internal linking, 6l can generate Go binaries by itself.\n+\n+In order to allow linking arbitrary object files without requiring\n+dynamic libraries, cgo will soon support an \"external\" linking mode\n+too. In external linking mode, 6l does not process any host object\n+files. Instead, it collects all the Go code and writes a single go.o\n+object file containing it. Then it invokes the host linker (usually\n+gcc) to combine the go.o object file and any supporting non-Go code\n+into a final executable. External linking avoids the dynamic library\n+requirement but introduces a requirement that the host linker be\n+present to create such a binary.\n+\n+Most builds both compile source code and invoke the linker to create a\n+binary. When cgo is involved, the compile step already requires gcc, so\n+it is not problematic for the link step to require gcc too.\n+\n+An important exception is builds using a pre-compiled copy of the\n+standard library. In particular, package net uses cgo on most systems,\n+and we want to preserve the ability to compile pure Go code that\n+imports net without requiring gcc to be present at link time. (In this\n+case, the dynamic library requirement is less significant, because the\n+only library involved is libc.so, which can usually be assumed\n+present.)\n+\n+This conflict between functionality and the gcc requirement means we\n+must support both internal and external linking, depending on the\n+circumstances: if net is the only cgo-using package, then internal\n+linking is probably fine, but if other packages are involved, so that there\n+are dependencies on libraries beyond libc, external linking is likely\n+to work better. The compilation of a package records the relevant\n+information to support both linking modes, leaving the decision\n+to be made when linking the final binary.\n+\n+Linking Directives\n+\n+In either linking mode, package-specific directives must be passed\n+through to 6l. These are communicated by writing #pragma directives\n+in a C source file compiled by 6c. The directives are copied into the .6 object file\n+and then processed by the linker.\n+\n+The directives are:\n+\n+#pragma cgo_import_dynamic <local> [<remote> [\"<library>\"]]\n+\n+\tIn internal linking mode, allow an unresolved reference to\n+\t<local>, assuming it will be resolved by a dynamic library\n+\tsymbol. The optional <remote> specifies the symbol's name and\n+\tpossibly version in the dynamic library, and the optional \"<library>\"\n+\tnames the specific library where the symbol should be found.\n+\n+\tIn the <remote>, # or @ can be used to introduce a symbol version.\n+\n+\tExamples:\n+\t#pragma cgo_import_dynamic puts\n+\t#pragma cgo_import_dynamic puts puts#GLIBC_2.2.5\n+\t#pragma cgo_import_dynamic puts puts#GLIBC_2.2.5 \"libc.so.6\"\n+\n+\tA side effect of the cgo_import_dynamic directive with a\n+\tlibrary is to make the final binary depend on that dynamic\n+\tlibrary. To get the dependency without importing any specific\n+\tsymbols, use _ for local and remote.\n+\n+\tExample:\n+\t#pragma cgo_import_dynamic _ _ \"libc.so.6\"\n+\n+\tFor compatibility with current versions of SWIG,\n+\t#pragma dynimport is an alias for #pragma cgo_import_dynamic.\n+\n+#pragma cgo_dynamic_linker \"<path>\"\n+\n+\tIn internal linking mode, use \"<path>\" as the dynamic linker\n+\tin the final binary. This directive is only needed from one\n+\tpackage when constructing a binary; by convention it is\n+\tsupplied by runtime/cgo.\n+\n+\tExample:\n+\t#pragma cgo_dynamic_linker \"/lib/ld-linux.so.2\"\n+\n+#pragma cgo_export_dynamic <local> <remote>\n+\n+\tIn internal linking mode, put the Go symbol\n+\tnamed <local> into the program's exported symbol table as\n+\t<remote>, so that C code can refer to it by that name. This\n+\tmechanism makes it possible for C code to call back into Go or\n+\tto share Go's data.\n+\n+\tFor compatibility with current versions of SWIG,\n+\t#pragma dynexport is an alias for #pragma cgo_export_dynamic.\n+\n+#pragma cgo_import_static <local>\n+\n+\tIn external linking mode, allow unresolved references to\n+\t<local> in the go.o object file prepared for the host linker,\n+\tunder the assumption that <local> will be supplied by the\n+\tother object files that will be linked with go.o.\n+\n+\tExample:\n+\t#pragma cgo_import_static puts_wrapper\n+\n+#pragma cgo_export_static <local> <remote>\n+\n+\tIn external linking mode, put the Go symbol\n+\tnamed <local> into the program's exported symbol table as\n+\t<remote>, so that C code can refer to it by that name. This\n+\tmechanism makes it possible for C code to call back into Go or\n+\tto share Go's data.\n+\n+#pragma cgo_ldflag \"<arg>\"\n+\n+\tIn external linking mode, invoke the host linker (usually gcc)\n+\twith \"<arg>\" as a command-line argument following the .o files.\n+\tNote that the arguments are for \"gcc\", not \"ld\".\n+\n+\tExample:\n+\t#pragma cgo_ldflag \"-lpthread\"\n+\t#pragma cgo_ldflag \"-L/usr/local/sqlite3/lib\"\n+\n+A package compiled with cgo will include directives for both\n+internal and external linking; the linker will select the appropriate\n+subset for the chosen linking mode.\n+\n+Example\n+\n+As a simple example, consider a package that uses cgo to call C.sin.\n+The following code will be generated by cgo:\n+\n+\t// compiled by 6g\n+\n+\ttype _Ctype_double float64\n+\tfunc _Cfunc_sin(_Ctype_double) _Ctype_double\n+\n+\t// compiled by 6c\n+\n+\t#pragma cgo_import_dynamic sin sin#GLIBC_2.2.5 \"libm.so.6\"\n+\n+\t#pragma cgo_import_static _cgo_gcc_Cfunc_sin\n+\t#pragma cgo_ldflag \"-lm\"\n+\n+\tvoid _cgo_gcc_Cfunc_sin(void*);\n+\n+\tvoid\n+\t\u00b7_Cfunc_sin(struct{uint8 x[16];}p)\n+\t{\n+\t\truntime\u00b7cgocall(_cgo_gcc_Cfunc_sin, &p);\n+\t}\n+\n+\t// compiled by gcc, into foo.cgo2.o\n+\n+\tvoid\n+\t_cgo_gcc_Cfunc_sin(void *v)\n+\t{\n+\t\tstruct {\n+\t\t\tdouble p0;\n+\t\t\tdouble r;\n+\t\t} __attribute__((__packed__)) *a = v;\n+\t\ta->r = sin(a->p0);\n+\t}\n+\n+What happens at link time depends on whether the final binary is linked\n+using the internal or external mode. If other packages are compiled in\n+\"external only\" mode, then the final link will be an external one.\n+Otherwise the link will be an internal one.\n+\n+The directives in the 6c-compiled file are used according to the kind\n+of final link used.\n+\n+In internal mode, 6l itself processes all the host object files, in\n+particular foo.cgo2.o. To do so, it uses the cgo_import_dynamic and\n+cgo_dynamic_linker directives to learn that the otherwise undefined\n+reference to sin in foo.cgo2.o should be rewritten to refer to the\n+symbol sin with version GLIBC_2.2.5 from the dynamic library\n+\"libm.so.6\", and the binary should request \"/lib/ld-linux.so.2\" as its\n+runtime dynamic linker.\n+\n+In external mode, 6l does not process any host object files, in\n+particular foo.cgo2.o. It links together the 6g- and 6c-generated\n+object files, along with any other Go code, into a go.o file. While\n+doing that, 6l will discover that there is no definition for\n+_cgo_gcc_Cfunc_sin, referred to by the 6c-compiled source file. This\n+is okay, because 6l also processes the cgo_import_static directive and\n+knows that _cgo_gcc_Cfunc_sin is expected to be supplied by a host\n+object file, so 6l does not treat the missing symbol as an error when\n+creating go.o. Indeed, the definition for _cgo_gcc_Cfunc_sin will be\n+provided to the host linker by foo2.cgo.o, which in turn will need the\n+symbol 'sin'. 6l also processes the cgo_ldflag directives, so that it\n+knows that the eventual host link command must include the -lm\n+argument, so that the host linker will be able to find 'sin' in the\n+math library.\n+\n+6l Command Line Interface\n+\n+The go command and any other Go-aware build systems invoke 6l\n+to link a collection of packages into a single binary. By default, 6l will\n+present the same interface it does today:\n+\n+\t6l main.a\n+\n+produces a file named 6.out, even if 6l does so by invoking the host\n+linker in external linking mode.\n+\n+By default, 6l will decide the linking mode as follows: if the only\n+packages using cgo are those on a whitelist of standard library\n+packages (net, os/user, runtime/cgo), 6l will use internal linking\n+mode. Otherwise, there are non-standard cgo packages involved, and 6l\n+will use external linking mode. The first rule means that a build of\n+the godoc binary, which uses net but no other cgo, can run without\n+needing gcc available. The second rule means that a build of a\n+cgo-wrapped library like sqlite3 can generate a standalone executable\n+instead of needing to refer to a dynamic library. The specific choice\n+can be overridden using a command line flag: 6l -linkmode=internal or\n+6l -linkmode=external.\n+\n+In an external link, 6l will create a temporary directory, write any\n+host object files found in package archives to that directory (renamed\n+to avoid conflicts), write the go.o file to that directory, and invoke\n+the host linker. The default value for the host linker is $CC, split\n+into fields, or else \"gcc\". The specific host linker command line can\n+be overridden using command line flags: 6l -extld=clang\n+-extldflags='-ggdb -O3'.  If any package in a build includes a .cc or\n+other file compiled by the C++ compiler, the go tool will use the\n+-extld option to set the host linker to the C++ compiler.\n+\n+These defaults mean that Go-aware build systems can ignore the linking\n+changes and keep running plain '6l' and get reasonable results, but\n+they can also control the linking details if desired.\n+\n+*/"}, {"sha": "f55cfbac447f559758e6e36becaaeecd4143c0ab", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "added", "additions": 1728, "deletions": 0, "changes": 1728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,1728 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Annotate Ref in Prog with C types by parsing gcc debug output.\n+// Conversion of debug output to Go types.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"debug/dwarf\"\n+\t\"debug/elf\"\n+\t\"debug/macho\"\n+\t\"debug/pe\"\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+var debugDefine = flag.Bool(\"debug-define\", false, \"print relevant #defines\")\n+var debugGcc = flag.Bool(\"debug-gcc\", false, \"print gcc invocations\")\n+\n+var nameToC = map[string]string{\n+\t\"schar\":         \"signed char\",\n+\t\"uchar\":         \"unsigned char\",\n+\t\"ushort\":        \"unsigned short\",\n+\t\"uint\":          \"unsigned int\",\n+\t\"ulong\":         \"unsigned long\",\n+\t\"longlong\":      \"long long\",\n+\t\"ulonglong\":     \"unsigned long long\",\n+\t\"complexfloat\":  \"float complex\",\n+\t\"complexdouble\": \"double complex\",\n+}\n+\n+// cname returns the C name to use for C.s.\n+// The expansions are listed in nameToC and also\n+// struct_foo becomes \"struct foo\", and similarly for\n+// union and enum.\n+func cname(s string) string {\n+\tif t, ok := nameToC[s]; ok {\n+\t\treturn t\n+\t}\n+\n+\tif strings.HasPrefix(s, \"struct_\") {\n+\t\treturn \"struct \" + s[len(\"struct_\"):]\n+\t}\n+\tif strings.HasPrefix(s, \"union_\") {\n+\t\treturn \"union \" + s[len(\"union_\"):]\n+\t}\n+\tif strings.HasPrefix(s, \"enum_\") {\n+\t\treturn \"enum \" + s[len(\"enum_\"):]\n+\t}\n+\tif strings.HasPrefix(s, \"sizeof_\") {\n+\t\treturn \"sizeof(\" + cname(s[len(\"sizeof_\"):]) + \")\"\n+\t}\n+\treturn s\n+}\n+\n+// DiscardCgoDirectives processes the import C preamble, and discards\n+// all #cgo CFLAGS and LDFLAGS directives, so they don't make their\n+// way into _cgo_export.h.\n+func (f *File) DiscardCgoDirectives() {\n+\tlinesIn := strings.Split(f.Preamble, \"\\n\")\n+\tlinesOut := make([]string, 0, len(linesIn))\n+\tfor _, line := range linesIn {\n+\t\tl := strings.TrimSpace(line)\n+\t\tif len(l) < 5 || l[:4] != \"#cgo\" || !unicode.IsSpace(rune(l[4])) {\n+\t\t\tlinesOut = append(linesOut, line)\n+\t\t} else {\n+\t\t\tlinesOut = append(linesOut, \"\")\n+\t\t}\n+\t}\n+\tf.Preamble = strings.Join(linesOut, \"\\n\")\n+}\n+\n+// addToFlag appends args to flag.  All flags are later written out onto the\n+// _cgo_flags file for the build system to use.\n+func (p *Package) addToFlag(flag string, args []string) {\n+\tp.CgoFlags[flag] = append(p.CgoFlags[flag], args...)\n+\tif flag == \"CFLAGS\" {\n+\t\t// We'll also need these when preprocessing for dwarf information.\n+\t\tp.GccOptions = append(p.GccOptions, args...)\n+\t}\n+}\n+\n+// splitQuoted splits the string s around each instance of one or more consecutive\n+// white space characters while taking into account quotes and escaping, and\n+// returns an array of substrings of s or an empty list if s contains only white space.\n+// Single quotes and double quotes are recognized to prevent splitting within the\n+// quoted region, and are removed from the resulting substrings. If a quote in s\n+// isn't closed err will be set and r will have the unclosed argument as the\n+// last element.  The backslash is used for escaping.\n+//\n+// For example, the following string:\n+//\n+//     `a b:\"c d\" 'e''f'  \"g\\\"\"`\n+//\n+// Would be parsed as:\n+//\n+//     []string{\"a\", \"b:c d\", \"ef\", `g\"`}\n+//\n+func splitQuoted(s string) (r []string, err error) {\n+\tvar args []string\n+\targ := make([]rune, len(s))\n+\tescaped := false\n+\tquoted := false\n+\tquote := '\\x00'\n+\ti := 0\n+\tfor _, r := range s {\n+\t\tswitch {\n+\t\tcase escaped:\n+\t\t\tescaped = false\n+\t\tcase r == '\\\\':\n+\t\t\tescaped = true\n+\t\t\tcontinue\n+\t\tcase quote != 0:\n+\t\t\tif r == quote {\n+\t\t\t\tquote = 0\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\tcase r == '\"' || r == '\\'':\n+\t\t\tquoted = true\n+\t\t\tquote = r\n+\t\t\tcontinue\n+\t\tcase unicode.IsSpace(r):\n+\t\t\tif quoted || i > 0 {\n+\t\t\t\tquoted = false\n+\t\t\t\targs = append(args, string(arg[:i]))\n+\t\t\t\ti = 0\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\targ[i] = r\n+\t\ti++\n+\t}\n+\tif quoted || i > 0 {\n+\t\targs = append(args, string(arg[:i]))\n+\t}\n+\tif quote != 0 {\n+\t\terr = errors.New(\"unclosed quote\")\n+\t} else if escaped {\n+\t\terr = errors.New(\"unfinished escaping\")\n+\t}\n+\treturn args, err\n+}\n+\n+var safeBytes = []byte(`+-.,/0123456789:=ABCDEFGHIJKLMNOPQRSTUVWXYZ\\_abcdefghijklmnopqrstuvwxyz`)\n+\n+func safeName(s string) bool {\n+\tif s == \"\" {\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif c := s[i]; c < 0x80 && bytes.IndexByte(safeBytes, c) < 0 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// Translate rewrites f.AST, the original Go input, to remove\n+// references to the imported package C, replacing them with\n+// references to the equivalent Go types, functions, and variables.\n+func (p *Package) Translate(f *File) {\n+\tfor _, cref := range f.Ref {\n+\t\t// Convert C.ulong to C.unsigned long, etc.\n+\t\tcref.Name.C = cname(cref.Name.Go)\n+\t}\n+\tp.loadDefines(f)\n+\tneedType := p.guessKinds(f)\n+\tif len(needType) > 0 {\n+\t\tp.loadDWARF(f, needType)\n+\t}\n+\tp.rewriteRef(f)\n+}\n+\n+// loadDefines coerces gcc into spitting out the #defines in use\n+// in the file f and saves relevant renamings in f.Name[name].Define.\n+func (p *Package) loadDefines(f *File) {\n+\tvar b bytes.Buffer\n+\tb.WriteString(f.Preamble)\n+\tb.WriteString(builtinProlog)\n+\tstdout := p.gccDefines(b.Bytes())\n+\n+\tfor _, line := range strings.Split(stdout, \"\\n\") {\n+\t\tif len(line) < 9 || line[0:7] != \"#define\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tline = strings.TrimSpace(line[8:])\n+\n+\t\tvar key, val string\n+\t\tspaceIndex := strings.Index(line, \" \")\n+\t\ttabIndex := strings.Index(line, \"\\t\")\n+\n+\t\tif spaceIndex == -1 && tabIndex == -1 {\n+\t\t\tcontinue\n+\t\t} else if tabIndex == -1 || (spaceIndex != -1 && spaceIndex < tabIndex) {\n+\t\t\tkey = line[0:spaceIndex]\n+\t\t\tval = strings.TrimSpace(line[spaceIndex:])\n+\t\t} else {\n+\t\t\tkey = line[0:tabIndex]\n+\t\t\tval = strings.TrimSpace(line[tabIndex:])\n+\t\t}\n+\n+\t\tif n := f.Name[key]; n != nil {\n+\t\t\tif *debugDefine {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"#define %s %s\\n\", key, val)\n+\t\t\t}\n+\t\t\tn.Define = val\n+\t\t}\n+\t}\n+}\n+\n+// guessKinds tricks gcc into revealing the kind of each\n+// name xxx for the references C.xxx in the Go input.\n+// The kind is either a constant, type, or variable.\n+func (p *Package) guessKinds(f *File) []*Name {\n+\t// Determine kinds for names we already know about,\n+\t// like #defines or 'struct foo', before bothering with gcc.\n+\tvar names, needType []*Name\n+\tfor _, n := range f.Name {\n+\t\t// If we've already found this name as a #define\n+\t\t// and we can translate it as a constant value, do so.\n+\t\tif n.Define != \"\" {\n+\t\t\tisConst := false\n+\t\t\tif _, err := strconv.Atoi(n.Define); err == nil {\n+\t\t\t\tisConst = true\n+\t\t\t} else if n.Define[0] == '\"' || n.Define[0] == '\\'' {\n+\t\t\t\tif _, err := parser.ParseExpr(n.Define); err == nil {\n+\t\t\t\t\tisConst = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif isConst {\n+\t\t\t\tn.Kind = \"const\"\n+\t\t\t\t// Turn decimal into hex, just for consistency\n+\t\t\t\t// with enum-derived constants.  Otherwise\n+\t\t\t\t// in the cgo -godefs output half the constants\n+\t\t\t\t// are in hex and half are in whatever the #define used.\n+\t\t\t\ti, err := strconv.ParseInt(n.Define, 0, 64)\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", i)\n+\t\t\t\t} else {\n+\t\t\t\t\tn.Const = n.Define\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif isName(n.Define) {\n+\t\t\t\tn.C = n.Define\n+\t\t\t}\n+\t\t}\n+\n+\t\tneedType = append(needType, n)\n+\n+\t\t// If this is a struct, union, or enum type name, no need to guess the kind.\n+\t\tif strings.HasPrefix(n.C, \"struct \") || strings.HasPrefix(n.C, \"union \") || strings.HasPrefix(n.C, \"enum \") {\n+\t\t\tn.Kind = \"type\"\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Otherwise, we'll need to find out from gcc.\n+\t\tnames = append(names, n)\n+\t}\n+\n+\t// Bypass gcc if there's nothing left to find out.\n+\tif len(names) == 0 {\n+\t\treturn needType\n+\t}\n+\n+\t// Coerce gcc into telling us whether each name is a type, a value, or undeclared.\n+\t// For names, find out whether they are integer constants.\n+\t// We used to look at specific warning or error messages here, but that tied the\n+\t// behavior too closely to specific versions of the compilers.\n+\t// Instead, arrange that we can infer what we need from only the presence or absence\n+\t// of an error on a specific line.\n+\t//\n+\t// For each name, we generate these lines, where xxx is the index in toSniff plus one.\n+\t//\n+\t//\t#line xxx \"not-declared\"\n+\t//\tvoid __cgo_f_xxx_1(void) { __typeof__(name) *__cgo_undefined__; }\n+\t//\t#line xxx \"not-type\"\n+\t//\tvoid __cgo_f_xxx_2(void) { name *__cgo_undefined__; }\n+\t//\t#line xxx \"not-const\"\n+\t//\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (name)*1 }; }\n+\t//\n+\t// If we see an error at not-declared:xxx, the corresponding name is not declared.\n+\t// If we see an error at not-type:xxx, the corresponding name is a type.\n+\t// If we see an error at not-const:xxx, the corresponding name is not an integer constant.\n+\t// If we see no errors, we assume the name is an expression but not a constant\n+\t// (so a variable or a function).\n+\t//\n+\t// The specific input forms are chosen so that they are valid C syntax regardless of\n+\t// whether name denotes a type or an expression.\n+\n+\tvar b bytes.Buffer\n+\tb.WriteString(f.Preamble)\n+\tb.WriteString(builtinProlog)\n+\n+\tfor i, n := range names {\n+\t\tfmt.Fprintf(&b, \"#line %d \\\"not-declared\\\"\\n\"+\n+\t\t\t\"void __cgo_f_%d_1(void) { __typeof__(%s) *__cgo_undefined__; }\\n\"+\n+\t\t\t\"#line %d \\\"not-type\\\"\\n\"+\n+\t\t\t\"void __cgo_f_%d_2(void) { %s *__cgo_undefined__; }\\n\"+\n+\t\t\t\"#line %d \\\"not-const\\\"\\n\"+\n+\t\t\t\"void __cgo_f_%d_3(void) { enum { __cgo__undefined__ = (%s)*1 }; }\\n\",\n+\t\t\ti+1, i+1, n.C,\n+\t\t\ti+1, i+1, n.C,\n+\t\t\ti+1, i+1, n.C)\n+\t}\n+\tfmt.Fprintf(&b, \"#line 1 \\\"completed\\\"\\n\"+\n+\t\t\"int __cgo__1 = __cgo__2;\\n\")\n+\n+\tstderr := p.gccErrors(b.Bytes())\n+\tif stderr == \"\" {\n+\t\tfatalf(\"%s produced no output\\non input:\\n%s\", p.gccBaseCmd()[0], b.Bytes())\n+\t}\n+\n+\tcompleted := false\n+\tsniff := make([]int, len(names))\n+\tconst (\n+\t\tnotType = 1 << iota\n+\t\tnotConst\n+\t)\n+\tfor _, line := range strings.Split(stderr, \"\\n\") {\n+\t\tif !strings.Contains(line, \": error:\") {\n+\t\t\t// we only care about errors.\n+\t\t\t// we tried to turn off warnings on the command line, but one never knows.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tc1 := strings.Index(line, \":\")\n+\t\tif c1 < 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tc2 := strings.Index(line[c1+1:], \":\")\n+\t\tif c2 < 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tc2 += c1 + 1\n+\n+\t\tfilename := line[:c1]\n+\t\ti, _ := strconv.Atoi(line[c1+1 : c2])\n+\t\ti--\n+\t\tif i < 0 || i >= len(names) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch filename {\n+\t\tcase \"completed\":\n+\t\t\t// Strictly speaking, there is no guarantee that seeing the error at completed:1\n+\t\t\t// (at the end of the file) means we've seen all the errors from earlier in the file,\n+\t\t\t// but usually it does. Certainly if we don't see the completed:1 error, we did\n+\t\t\t// not get all the errors we expected.\n+\t\t\tcompleted = true\n+\n+\t\tcase \"not-declared\":\n+\t\t\terror_(token.NoPos, \"%s\", strings.TrimSpace(line[c2+1:]))\n+\t\tcase \"not-type\":\n+\t\t\tsniff[i] |= notType\n+\t\tcase \"not-const\":\n+\t\t\tsniff[i] |= notConst\n+\t\t}\n+\t}\n+\n+\tif !completed {\n+\t\tfatalf(\"%s did not produce error at completed:1\\non input:\\n%s\", p.gccBaseCmd()[0], b.Bytes())\n+\t}\n+\n+\tfor i, n := range names {\n+\t\tswitch sniff[i] {\n+\t\tcase 0:\n+\t\t\terror_(token.NoPos, \"could not determine kind of name for C.%s\", fixGo(n.Go))\n+\t\tcase notType:\n+\t\t\tn.Kind = \"const\"\n+\t\tcase notConst:\n+\t\t\tn.Kind = \"type\"\n+\t\tcase notConst | notType:\n+\t\t\tn.Kind = \"not-type\"\n+\t\t}\n+\t}\n+\tif nerrors > 0 {\n+\t\tfatalf(\"unresolved names\")\n+\t}\n+\n+\tneedType = append(needType, names...)\n+\treturn needType\n+}\n+\n+// loadDWARF parses the DWARF debug information generated\n+// by gcc to learn the details of the constants, variables, and types\n+// being referred to as C.xxx.\n+func (p *Package) loadDWARF(f *File, names []*Name) {\n+\t// Extract the types from the DWARF section of an object\n+\t// from a well-formed C program.  Gcc only generates DWARF info\n+\t// for symbols in the object file, so it is not enough to print the\n+\t// preamble and hope the symbols we care about will be there.\n+\t// Instead, emit\n+\t//\t__typeof__(names[i]) *__cgo__i;\n+\t// for each entry in names and then dereference the type we\n+\t// learn for __cgo__i.\n+\tvar b bytes.Buffer\n+\tb.WriteString(f.Preamble)\n+\tb.WriteString(builtinProlog)\n+\tfor i, n := range names {\n+\t\tfmt.Fprintf(&b, \"__typeof__(%s) *__cgo__%d;\\n\", n.C, i)\n+\t\tif n.Kind == \"const\" {\n+\t\t\tfmt.Fprintf(&b, \"enum { __cgo_enum__%d = %s };\\n\", i, n.C)\n+\t\t}\n+\t}\n+\n+\t// Apple's LLVM-based gcc does not include the enumeration\n+\t// names and values in its DWARF debug output.  In case we're\n+\t// using such a gcc, create a data block initialized with the values.\n+\t// We can read them out of the object file.\n+\tfmt.Fprintf(&b, \"long long __cgodebug_data[] = {\\n\")\n+\tfor _, n := range names {\n+\t\tif n.Kind == \"const\" {\n+\t\t\tfmt.Fprintf(&b, \"\\t%s,\\n\", n.C)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(&b, \"\\t0,\\n\")\n+\t\t}\n+\t}\n+\t// for the last entry, we can not use 0, otherwise\n+\t// in case all __cgodebug_data is zero initialized,\n+\t// LLVM-based gcc will place the it in the __DATA.__common\n+\t// zero-filled section (our debug/macho doesn't support\n+\t// this)\n+\tfmt.Fprintf(&b, \"\\t1\\n\")\n+\tfmt.Fprintf(&b, \"};\\n\")\n+\n+\td, bo, debugData := p.gccDebug(b.Bytes())\n+\tenumVal := make([]int64, len(debugData)/8)\n+\tfor i := range enumVal {\n+\t\tenumVal[i] = int64(bo.Uint64(debugData[i*8:]))\n+\t}\n+\n+\t// Scan DWARF info for top-level TagVariable entries with AttrName __cgo__i.\n+\ttypes := make([]dwarf.Type, len(names))\n+\tenums := make([]dwarf.Offset, len(names))\n+\tnameToIndex := make(map[*Name]int)\n+\tfor i, n := range names {\n+\t\tnameToIndex[n] = i\n+\t}\n+\tnameToRef := make(map[*Name]*Ref)\n+\tfor _, ref := range f.Ref {\n+\t\tnameToRef[ref.Name] = ref\n+\t}\n+\tr := d.Reader()\n+\tfor {\n+\t\te, err := r.Next()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"reading DWARF entry: %s\", err)\n+\t\t}\n+\t\tif e == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tswitch e.Tag {\n+\t\tcase dwarf.TagEnumerationType:\n+\t\t\toffset := e.Offset\n+\t\t\tfor {\n+\t\t\t\te, err := r.Next()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfatalf(\"reading DWARF entry: %s\", err)\n+\t\t\t\t}\n+\t\t\t\tif e.Tag == 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif e.Tag == dwarf.TagEnumerator {\n+\t\t\t\t\tentryName := e.Val(dwarf.AttrName).(string)\n+\t\t\t\t\tif strings.HasPrefix(entryName, \"__cgo_enum__\") {\n+\t\t\t\t\t\tn, _ := strconv.Atoi(entryName[len(\"__cgo_enum__\"):])\n+\t\t\t\t\t\tif 0 <= n && n < len(names) {\n+\t\t\t\t\t\t\tenums[n] = offset\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase dwarf.TagVariable:\n+\t\t\tname, _ := e.Val(dwarf.AttrName).(string)\n+\t\t\ttypOff, _ := e.Val(dwarf.AttrType).(dwarf.Offset)\n+\t\t\tif name == \"\" || typOff == 0 {\n+\t\t\t\tfatalf(\"malformed DWARF TagVariable entry\")\n+\t\t\t}\n+\t\t\tif !strings.HasPrefix(name, \"__cgo__\") {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\ttyp, err := d.Type(typOff)\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"loading DWARF type: %s\", err)\n+\t\t\t}\n+\t\t\tt, ok := typ.(*dwarf.PtrType)\n+\t\t\tif !ok || t == nil {\n+\t\t\t\tfatalf(\"internal error: %s has non-pointer type\", name)\n+\t\t\t}\n+\t\t\ti, err := strconv.Atoi(name[7:])\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"malformed __cgo__ name: %s\", name)\n+\t\t\t}\n+\t\t\tif enums[i] != 0 {\n+\t\t\t\tt, err := d.Type(enums[i])\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tfatalf(\"loading DWARF type: %s\", err)\n+\t\t\t\t}\n+\t\t\t\ttypes[i] = t\n+\t\t\t} else {\n+\t\t\t\ttypes[i] = t.Type\n+\t\t\t}\n+\t\t}\n+\t\tif e.Tag != dwarf.TagCompileUnit {\n+\t\t\tr.SkipChildren()\n+\t\t}\n+\t}\n+\n+\t// Record types and typedef information.\n+\tvar conv typeConv\n+\tconv.Init(p.PtrSize, p.IntSize)\n+\tfor i, n := range names {\n+\t\tif types[i] == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tpos := token.NoPos\n+\t\tif ref, ok := nameToRef[n]; ok {\n+\t\t\tpos = ref.Pos()\n+\t\t}\n+\t\tf, fok := types[i].(*dwarf.FuncType)\n+\t\tif n.Kind != \"type\" && fok {\n+\t\t\tn.Kind = \"func\"\n+\t\t\tn.FuncType = conv.FuncType(f, pos)\n+\t\t} else {\n+\t\t\tn.Type = conv.Type(types[i], pos)\n+\t\t\tif enums[i] != 0 && n.Type.EnumValues != nil {\n+\t\t\t\tk := fmt.Sprintf(\"__cgo_enum__%d\", i)\n+\t\t\t\tn.Kind = \"const\"\n+\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", n.Type.EnumValues[k])\n+\t\t\t\t// Remove injected enum to ensure the value will deep-compare\n+\t\t\t\t// equally in future loads of the same constant.\n+\t\t\t\tdelete(n.Type.EnumValues, k)\n+\t\t\t}\n+\t\t\t// Prefer debug data over DWARF debug output, if we have it.\n+\t\t\tif n.Kind == \"const\" && i < len(enumVal) {\n+\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", enumVal[i])\n+\t\t\t}\n+\t\t}\n+\t\tconv.FinishType(pos)\n+\t}\n+}\n+\n+// mangleName does name mangling to translate names\n+// from the original Go source files to the names\n+// used in the final Go files generated by cgo.\n+func (p *Package) mangleName(n *Name) {\n+\t// When using gccgo variables have to be\n+\t// exported so that they become global symbols\n+\t// that the C code can refer to.\n+\tprefix := \"_C\"\n+\tif *gccgo && n.IsVar() {\n+\t\tprefix = \"C\"\n+\t}\n+\tn.Mangle = prefix + n.Kind + \"_\" + n.Go\n+}\n+\n+// rewriteRef rewrites all the C.xxx references in f.AST to refer to the\n+// Go equivalents, now that we have figured out the meaning of all\n+// the xxx.  In *godefs or *cdefs mode, rewriteRef replaces the names\n+// with full definitions instead of mangled names.\n+func (p *Package) rewriteRef(f *File) {\n+\t// Keep a list of all the functions, to remove the ones\n+\t// only used as expressions and avoid generating bridge\n+\t// code for them.\n+\tfunctions := make(map[string]bool)\n+\n+\t// Assign mangled names.\n+\tfor _, n := range f.Name {\n+\t\tif n.Kind == \"not-type\" {\n+\t\t\tn.Kind = \"var\"\n+\t\t}\n+\t\tif n.Mangle == \"\" {\n+\t\t\tp.mangleName(n)\n+\t\t}\n+\t\tif n.Kind == \"func\" {\n+\t\t\tfunctions[n.Go] = false\n+\t\t}\n+\t}\n+\n+\t// Now that we have all the name types filled in,\n+\t// scan through the Refs to identify the ones that\n+\t// are trying to do a ,err call.  Also check that\n+\t// functions are only used in calls.\n+\tfor _, r := range f.Ref {\n+\t\tif r.Name.Kind == \"const\" && r.Name.Const == \"\" {\n+\t\t\terror_(r.Pos(), \"unable to find value of constant C.%s\", fixGo(r.Name.Go))\n+\t\t}\n+\t\tvar expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default\n+\t\tswitch r.Context {\n+\t\tcase \"call\", \"call2\":\n+\t\t\tif r.Name.Kind != \"func\" {\n+\t\t\t\tif r.Name.Kind == \"type\" {\n+\t\t\t\t\tr.Context = \"type\"\n+\t\t\t\t\texpr = r.Name.Type.Go\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\terror_(r.Pos(), \"call of non-function C.%s\", fixGo(r.Name.Go))\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfunctions[r.Name.Go] = true\n+\t\t\tif r.Context == \"call2\" {\n+\t\t\t\tif r.Name.Go == \"_CMalloc\" {\n+\t\t\t\t\terror_(r.Pos(), \"no two-result form for C.malloc\")\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\t// Invent new Name for the two-result function.\n+\t\t\t\tn := f.Name[\"2\"+r.Name.Go]\n+\t\t\t\tif n == nil {\n+\t\t\t\t\tn = new(Name)\n+\t\t\t\t\t*n = *r.Name\n+\t\t\t\t\tn.AddError = true\n+\t\t\t\t\tn.Mangle = \"_C2func_\" + n.Go\n+\t\t\t\t\tf.Name[\"2\"+r.Name.Go] = n\n+\t\t\t\t}\n+\t\t\t\texpr = ast.NewIdent(n.Mangle)\n+\t\t\t\tr.Name = n\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\tcase \"expr\":\n+\t\t\tif r.Name.Kind == \"func\" {\n+\t\t\t\t// Function is being used in an expression, to e.g. pass around a C function pointer.\n+\t\t\t\t// Create a new Name for this Ref which causes the variable to be declared in Go land.\n+\t\t\t\tfpName := \"fp_\" + r.Name.Go\n+\t\t\t\tname := f.Name[fpName]\n+\t\t\t\tif name == nil {\n+\t\t\t\t\tname = &Name{\n+\t\t\t\t\t\tGo:   fpName,\n+\t\t\t\t\t\tC:    r.Name.C,\n+\t\t\t\t\t\tKind: \"fpvar\",\n+\t\t\t\t\t\tType: &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"void*\"), Go: ast.NewIdent(\"unsafe.Pointer\")},\n+\t\t\t\t\t}\n+\t\t\t\t\tp.mangleName(name)\n+\t\t\t\t\tf.Name[fpName] = name\n+\t\t\t\t}\n+\t\t\t\tr.Name = name\n+\t\t\t\texpr = ast.NewIdent(name.Mangle)\n+\t\t\t} else if r.Name.Kind == \"type\" {\n+\t\t\t\t// Okay - might be new(T)\n+\t\t\t\texpr = r.Name.Type.Go\n+\t\t\t} else if r.Name.Kind == \"var\" {\n+\t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n+\t\t\t}\n+\n+\t\tcase \"type\":\n+\t\t\tif r.Name.Kind != \"type\" {\n+\t\t\t\terror_(r.Pos(), \"expression C.%s used as type\", fixGo(r.Name.Go))\n+\t\t\t} else if r.Name.Type == nil {\n+\t\t\t\t// Use of C.enum_x, C.struct_x or C.union_x without C definition.\n+\t\t\t\t// GCC won't raise an error when using pointers to such unknown types.\n+\t\t\t\terror_(r.Pos(), \"type C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n+\t\t\t} else {\n+\t\t\t\texpr = r.Name.Type.Go\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tif r.Name.Kind == \"func\" {\n+\t\t\t\terror_(r.Pos(), \"must call C.%s\", fixGo(r.Name.Go))\n+\t\t\t}\n+\t\t}\n+\t\tif *godefs || *cdefs {\n+\t\t\t// Substitute definition for mangled type name.\n+\t\t\tif id, ok := expr.(*ast.Ident); ok {\n+\t\t\t\tif t := typedef[id.Name]; t != nil {\n+\t\t\t\t\texpr = t.Go\n+\t\t\t\t}\n+\t\t\t\tif id.Name == r.Name.Mangle && r.Name.Const != \"\" {\n+\t\t\t\t\texpr = ast.NewIdent(r.Name.Const)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Copy position information from old expr into new expr,\n+\t\t// in case expression being replaced is first on line.\n+\t\t// See golang.org/issue/6563.\n+\t\tpos := (*r.Expr).Pos()\n+\t\tswitch x := expr.(type) {\n+\t\tcase *ast.Ident:\n+\t\t\texpr = &ast.Ident{NamePos: pos, Name: x.Name}\n+\t\t}\n+\n+\t\t*r.Expr = expr\n+\t}\n+\n+\t// Remove functions only used as expressions, so their respective\n+\t// bridge functions are not generated.\n+\tfor name, used := range functions {\n+\t\tif !used {\n+\t\t\tdelete(f.Name, name)\n+\t\t}\n+\t}\n+}\n+\n+// gccBaseCmd returns the start of the compiler command line.\n+// It uses $CC if set, or else $GCC, or else the compiler recorded\n+// during the initial build as defaultCC.\n+// defaultCC is defined in zdefaultcc.go, written by cmd/dist.\n+func (p *Package) gccBaseCmd() []string {\n+\t// Use $CC if set, since that's what the build uses.\n+\tif ret := strings.Fields(os.Getenv(\"CC\")); len(ret) > 0 {\n+\t\treturn ret\n+\t}\n+\t// Try $GCC if set, since that's what we used to use.\n+\tif ret := strings.Fields(os.Getenv(\"GCC\")); len(ret) > 0 {\n+\t\treturn ret\n+\t}\n+\treturn strings.Fields(defaultCC)\n+}\n+\n+// gccMachine returns the gcc -m flag to use, either \"-m32\", \"-m64\" or \"-marm\".\n+func (p *Package) gccMachine() []string {\n+\tswitch goarch {\n+\tcase \"amd64\":\n+\t\treturn []string{\"-m64\"}\n+\tcase \"386\":\n+\t\treturn []string{\"-m32\"}\n+\tcase \"arm\":\n+\t\treturn []string{\"-marm\"} // not thumb\n+\t}\n+\treturn nil\n+}\n+\n+func gccTmp() string {\n+\treturn *objDir + \"_cgo_.o\"\n+}\n+\n+// gccCmd returns the gcc command line to use for compiling\n+// the input.\n+func (p *Package) gccCmd() []string {\n+\tc := append(p.gccBaseCmd(),\n+\t\t\"-w\",          // no warnings\n+\t\t\"-Wno-error\",  // warnings are not errors\n+\t\t\"-o\"+gccTmp(), // write object to tmp\n+\t\t\"-gdwarf-2\",   // generate DWARF v2 debugging symbols\n+\t\t\"-c\",          // do not link\n+\t\t\"-xc\",         // input language is C\n+\t)\n+\tif strings.Contains(c[0], \"clang\") {\n+\t\tc = append(c,\n+\t\t\t\"-ferror-limit=0\",\n+\t\t\t// Apple clang version 1.7 (tags/Apple/clang-77) (based on LLVM 2.9svn)\n+\t\t\t// doesn't have -Wno-unneeded-internal-declaration, so we need yet another\n+\t\t\t// flag to disable the warning. Yes, really good diagnostics, clang.\n+\t\t\t\"-Wno-unknown-warning-option\",\n+\t\t\t\"-Wno-unneeded-internal-declaration\",\n+\t\t\t\"-Wno-unused-function\",\n+\t\t\t\"-Qunused-arguments\",\n+\t\t\t// Clang embeds prototypes for some builtin functions,\n+\t\t\t// like malloc and calloc, but all size_t parameters are\n+\t\t\t// incorrectly typed unsigned long. We work around that\n+\t\t\t// by disabling the builtin functions (this is safe as\n+\t\t\t// it won't affect the actual compilation of the C code).\n+\t\t\t// See: http://golang.org/issue/6506.\n+\t\t\t\"-fno-builtin\",\n+\t\t)\n+\t}\n+\n+\tc = append(c, p.GccOptions...)\n+\tc = append(c, p.gccMachine()...)\n+\tc = append(c, \"-\") //read input from standard input\n+\treturn c\n+}\n+\n+// gccDebug runs gcc -gdwarf-2 over the C program stdin and\n+// returns the corresponding DWARF data and, if present, debug data block.\n+func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte) {\n+\trunGcc(stdin, p.gccCmd())\n+\n+\tisDebugData := func(s string) bool {\n+\t\t// Some systems use leading _ to denote non-assembly symbols.\n+\t\treturn s == \"__cgodebug_data\" || s == \"___cgodebug_data\"\n+\t}\n+\n+\tif f, err := macho.Open(gccTmp()); err == nil {\n+\t\tdefer f.Close()\n+\t\td, err := f.DWARF()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n+\t\t}\n+\t\tvar data []byte\n+\t\tif f.Symtab != nil {\n+\t\t\tfor i := range f.Symtab.Syms {\n+\t\t\t\ts := &f.Symtab.Syms[i]\n+\t\t\t\tif isDebugData(s.Name) {\n+\t\t\t\t\t// Found it.  Now find data section.\n+\t\t\t\t\tif i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata = sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn d, f.ByteOrder, data\n+\t}\n+\n+\tif f, err := elf.Open(gccTmp()); err == nil {\n+\t\tdefer f.Close()\n+\t\td, err := f.DWARF()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n+\t\t}\n+\t\tvar data []byte\n+\t\tsymtab, err := f.Symbols()\n+\t\tif err == nil {\n+\t\t\tfor i := range symtab {\n+\t\t\t\ts := &symtab[i]\n+\t\t\t\tif isDebugData(s.Name) {\n+\t\t\t\t\t// Found it.  Now find data section.\n+\t\t\t\t\tif i := int(s.Section); 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata = sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn d, f.ByteOrder, data\n+\t}\n+\n+\tif f, err := pe.Open(gccTmp()); err == nil {\n+\t\tdefer f.Close()\n+\t\td, err := f.DWARF()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n+\t\t}\n+\t\tvar data []byte\n+\t\tfor _, s := range f.Symbols {\n+\t\t\tif isDebugData(s.Name) {\n+\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\tdata = sdat[s.Value:]\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn d, binary.LittleEndian, data\n+\t}\n+\n+\tfatalf(\"cannot parse gcc output %s as ELF, Mach-O, PE object\", gccTmp())\n+\tpanic(\"not reached\")\n+}\n+\n+// gccDefines runs gcc -E -dM -xc - over the C program stdin\n+// and returns the corresponding standard output, which is the\n+// #defines that gcc encountered while processing the input\n+// and its included files.\n+func (p *Package) gccDefines(stdin []byte) string {\n+\tbase := append(p.gccBaseCmd(), \"-E\", \"-dM\", \"-xc\")\n+\tbase = append(base, p.gccMachine()...)\n+\tstdout, _ := runGcc(stdin, append(append(base, p.GccOptions...), \"-\"))\n+\treturn stdout\n+}\n+\n+// gccErrors runs gcc over the C program stdin and returns\n+// the errors that gcc prints.  That is, this function expects\n+// gcc to fail.\n+func (p *Package) gccErrors(stdin []byte) string {\n+\t// TODO(rsc): require failure\n+\targs := p.gccCmd()\n+\n+\tif *debugGcc {\n+\t\tfmt.Fprintf(os.Stderr, \"$ %s <<EOF\\n\", strings.Join(args, \" \"))\n+\t\tos.Stderr.Write(stdin)\n+\t\tfmt.Fprint(os.Stderr, \"EOF\\n\")\n+\t}\n+\tstdout, stderr, _ := run(stdin, args)\n+\tif *debugGcc {\n+\t\tos.Stderr.Write(stdout)\n+\t\tos.Stderr.Write(stderr)\n+\t}\n+\treturn string(stderr)\n+}\n+\n+// runGcc runs the gcc command line args with stdin on standard input.\n+// If the command exits with a non-zero exit status, runGcc prints\n+// details about what was run and exits.\n+// Otherwise runGcc returns the data written to standard output and standard error.\n+// Note that for some of the uses we expect useful data back\n+// on standard error, but for those uses gcc must still exit 0.\n+func runGcc(stdin []byte, args []string) (string, string) {\n+\tif *debugGcc {\n+\t\tfmt.Fprintf(os.Stderr, \"$ %s <<EOF\\n\", strings.Join(args, \" \"))\n+\t\tos.Stderr.Write(stdin)\n+\t\tfmt.Fprint(os.Stderr, \"EOF\\n\")\n+\t}\n+\tstdout, stderr, ok := run(stdin, args)\n+\tif *debugGcc {\n+\t\tos.Stderr.Write(stdout)\n+\t\tos.Stderr.Write(stderr)\n+\t}\n+\tif !ok {\n+\t\tos.Stderr.Write(stderr)\n+\t\tos.Exit(2)\n+\t}\n+\treturn string(stdout), string(stderr)\n+}\n+\n+// A typeConv is a translator from dwarf types to Go types\n+// with equivalent memory layout.\n+type typeConv struct {\n+\t// Cache of already-translated or in-progress types.\n+\tm       map[dwarf.Type]*Type\n+\ttypedef map[string]ast.Expr\n+\n+\t// Map from types to incomplete pointers to those types.\n+\tptrs map[dwarf.Type][]*Type\n+\n+\t// Fields to be processed by godefsField after completing pointers.\n+\ttodoFlds [][]*ast.Field\n+\n+\t// Predeclared types.\n+\tbool                                   ast.Expr\n+\tbyte                                   ast.Expr // denotes padding\n+\tint8, int16, int32, int64              ast.Expr\n+\tuint8, uint16, uint32, uint64, uintptr ast.Expr\n+\tfloat32, float64                       ast.Expr\n+\tcomplex64, complex128                  ast.Expr\n+\tvoid                                   ast.Expr\n+\tunsafePointer                          ast.Expr\n+\tstring                                 ast.Expr\n+\tgoVoid                                 ast.Expr // _Ctype_void, denotes C's void\n+\n+\tptrSize int64\n+\tintSize int64\n+}\n+\n+var tagGen int\n+var typedef = make(map[string]*Type)\n+var goIdent = make(map[string]*ast.Ident)\n+\n+func (c *typeConv) Init(ptrSize, intSize int64) {\n+\tc.ptrSize = ptrSize\n+\tc.intSize = intSize\n+\tc.m = make(map[dwarf.Type]*Type)\n+\tc.ptrs = make(map[dwarf.Type][]*Type)\n+\tc.bool = c.Ident(\"bool\")\n+\tc.byte = c.Ident(\"byte\")\n+\tc.int8 = c.Ident(\"int8\")\n+\tc.int16 = c.Ident(\"int16\")\n+\tc.int32 = c.Ident(\"int32\")\n+\tc.int64 = c.Ident(\"int64\")\n+\tc.uint8 = c.Ident(\"uint8\")\n+\tc.uint16 = c.Ident(\"uint16\")\n+\tc.uint32 = c.Ident(\"uint32\")\n+\tc.uint64 = c.Ident(\"uint64\")\n+\tc.uintptr = c.Ident(\"uintptr\")\n+\tc.float32 = c.Ident(\"float32\")\n+\tc.float64 = c.Ident(\"float64\")\n+\tc.complex64 = c.Ident(\"complex64\")\n+\tc.complex128 = c.Ident(\"complex128\")\n+\tc.unsafePointer = c.Ident(\"unsafe.Pointer\")\n+\tc.void = c.Ident(\"void\")\n+\tc.string = c.Ident(\"string\")\n+\tc.goVoid = c.Ident(\"_Ctype_void\")\n+}\n+\n+// base strips away qualifiers and typedefs to get the underlying type\n+func base(dt dwarf.Type) dwarf.Type {\n+\tfor {\n+\t\tif d, ok := dt.(*dwarf.QualType); ok {\n+\t\t\tdt = d.Type\n+\t\t\tcontinue\n+\t\t}\n+\t\tif d, ok := dt.(*dwarf.TypedefType); ok {\n+\t\t\tdt = d.Type\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn dt\n+}\n+\n+// Map from dwarf text names to aliases we use in package \"C\".\n+var dwarfToName = map[string]string{\n+\t\"long int\":               \"long\",\n+\t\"long unsigned int\":      \"ulong\",\n+\t\"unsigned int\":           \"uint\",\n+\t\"short unsigned int\":     \"ushort\",\n+\t\"short int\":              \"short\",\n+\t\"long long int\":          \"longlong\",\n+\t\"long long unsigned int\": \"ulonglong\",\n+\t\"signed char\":            \"schar\",\n+\t\"float complex\":          \"complexfloat\",\n+\t\"double complex\":         \"complexdouble\",\n+}\n+\n+const signedDelta = 64\n+\n+// String returns the current type representation.  Format arguments\n+// are assembled within this method so that any changes in mutable\n+// values are taken into account.\n+func (tr *TypeRepr) String() string {\n+\tif len(tr.Repr) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tif len(tr.FormatArgs) == 0 {\n+\t\treturn tr.Repr\n+\t}\n+\treturn fmt.Sprintf(tr.Repr, tr.FormatArgs...)\n+}\n+\n+// Empty returns true if the result of String would be \"\".\n+func (tr *TypeRepr) Empty() bool {\n+\treturn len(tr.Repr) == 0\n+}\n+\n+// Set modifies the type representation.\n+// If fargs are provided, repr is used as a format for fmt.Sprintf.\n+// Otherwise, repr is used unprocessed as the type representation.\n+func (tr *TypeRepr) Set(repr string, fargs ...interface{}) {\n+\ttr.Repr = repr\n+\ttr.FormatArgs = fargs\n+}\n+\n+// FinishType completes any outstanding type mapping work.\n+// In particular, it resolves incomplete pointer types and also runs\n+// godefsFields on any new struct types.\n+func (c *typeConv) FinishType(pos token.Pos) {\n+\t// Completing one pointer type might produce more to complete.\n+\t// Keep looping until they're all done.\n+\tfor len(c.ptrs) > 0 {\n+\t\tfor dtype := range c.ptrs {\n+\t\t\t// Note Type might invalidate c.ptrs[dtype].\n+\t\t\tt := c.Type(dtype, pos)\n+\t\t\tfor _, ptr := range c.ptrs[dtype] {\n+\t\t\t\tptr.Go.(*ast.StarExpr).X = t.Go\n+\t\t\t\tptr.C.Set(\"%s*\", t.C)\n+\t\t\t}\n+\t\t\tdelete(c.ptrs, dtype)\n+\t\t}\n+\t}\n+\n+\t// Now that pointer types are completed, we can invoke godefsFields\n+\t// to rewrite struct definitions.\n+\tfor _, fld := range c.todoFlds {\n+\t\tgodefsFields(fld)\n+\t}\n+\tc.todoFlds = nil\n+}\n+\n+// Type returns a *Type with the same memory layout as\n+// dtype when used as the type of a variable or a struct field.\n+func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n+\tif t, ok := c.m[dtype]; ok {\n+\t\tif t.Go == nil {\n+\t\t\tfatalf(\"%s: type conversion loop at %s\", lineno(pos), dtype)\n+\t\t}\n+\t\treturn t\n+\t}\n+\n+\t// clang won't generate DW_AT_byte_size for pointer types,\n+\t// so we have to fix it here.\n+\tif dt, ok := base(dtype).(*dwarf.PtrType); ok && dt.ByteSize == -1 {\n+\t\tdt.ByteSize = c.ptrSize\n+\t}\n+\n+\tt := new(Type)\n+\tt.Size = dtype.Size() // note: wrong for array of pointers, corrected below\n+\tt.Align = -1\n+\tt.C = &TypeRepr{Repr: dtype.Common().Name}\n+\tc.m[dtype] = t\n+\n+\tswitch dt := dtype.(type) {\n+\tdefault:\n+\t\tfatalf(\"%s: unexpected type: %s\", lineno(pos), dtype)\n+\n+\tcase *dwarf.AddrType:\n+\t\tif t.Size != c.ptrSize {\n+\t\t\tfatalf(\"%s: unexpected: %d-byte address type - %s\", lineno(pos), t.Size, dtype)\n+\t\t}\n+\t\tt.Go = c.uintptr\n+\t\tt.Align = t.Size\n+\n+\tcase *dwarf.ArrayType:\n+\t\tif dt.StrideBitSize > 0 {\n+\t\t\t// Cannot represent bit-sized elements in Go.\n+\t\t\tt.Go = c.Opaque(t.Size)\n+\t\t\tbreak\n+\t\t}\n+\t\tsub := c.Type(dt.Type, pos)\n+\t\tt.Align = sub.Align\n+\t\tt.Go = &ast.ArrayType{\n+\t\t\tLen: c.intExpr(dt.Count),\n+\t\t\tElt: sub.Go,\n+\t\t}\n+\t\tt.C.Set(\"__typeof__(%s[%d])\", sub.C, dt.Count)\n+\n+\tcase *dwarf.BoolType:\n+\t\tt.Go = c.bool\n+\t\tt.Align = 1\n+\n+\tcase *dwarf.CharType:\n+\t\tif t.Size != 1 {\n+\t\t\tfatalf(\"%s: unexpected: %d-byte char type - %s\", lineno(pos), t.Size, dtype)\n+\t\t}\n+\t\tt.Go = c.int8\n+\t\tt.Align = 1\n+\n+\tcase *dwarf.EnumType:\n+\t\tif t.Align = t.Size; t.Align >= c.ptrSize {\n+\t\t\tt.Align = c.ptrSize\n+\t\t}\n+\t\tt.C.Set(\"enum \" + dt.EnumName)\n+\t\tsigned := 0\n+\t\tt.EnumValues = make(map[string]int64)\n+\t\tfor _, ev := range dt.Val {\n+\t\t\tt.EnumValues[ev.Name] = ev.Val\n+\t\t\tif ev.Val < 0 {\n+\t\t\t\tsigned = signedDelta\n+\t\t\t}\n+\t\t}\n+\t\tswitch t.Size + int64(signed) {\n+\t\tdefault:\n+\t\t\tfatalf(\"%s: unexpected: %d-byte enum type - %s\", lineno(pos), t.Size, dtype)\n+\t\tcase 1:\n+\t\t\tt.Go = c.uint8\n+\t\tcase 2:\n+\t\t\tt.Go = c.uint16\n+\t\tcase 4:\n+\t\t\tt.Go = c.uint32\n+\t\tcase 8:\n+\t\t\tt.Go = c.uint64\n+\t\tcase 1 + signedDelta:\n+\t\t\tt.Go = c.int8\n+\t\tcase 2 + signedDelta:\n+\t\t\tt.Go = c.int16\n+\t\tcase 4 + signedDelta:\n+\t\t\tt.Go = c.int32\n+\t\tcase 8 + signedDelta:\n+\t\t\tt.Go = c.int64\n+\t\t}\n+\n+\tcase *dwarf.FloatType:\n+\t\tswitch t.Size {\n+\t\tdefault:\n+\t\t\tfatalf(\"%s: unexpected: %d-byte float type - %s\", lineno(pos), t.Size, dtype)\n+\t\tcase 4:\n+\t\t\tt.Go = c.float32\n+\t\tcase 8:\n+\t\t\tt.Go = c.float64\n+\t\t}\n+\t\tif t.Align = t.Size; t.Align >= c.ptrSize {\n+\t\t\tt.Align = c.ptrSize\n+\t\t}\n+\n+\tcase *dwarf.ComplexType:\n+\t\tswitch t.Size {\n+\t\tdefault:\n+\t\t\tfatalf(\"%s: unexpected: %d-byte complex type - %s\", lineno(pos), t.Size, dtype)\n+\t\tcase 8:\n+\t\t\tt.Go = c.complex64\n+\t\tcase 16:\n+\t\t\tt.Go = c.complex128\n+\t\t}\n+\t\tif t.Align = t.Size; t.Align >= c.ptrSize {\n+\t\t\tt.Align = c.ptrSize\n+\t\t}\n+\n+\tcase *dwarf.FuncType:\n+\t\t// No attempt at translation: would enable calls\n+\t\t// directly between worlds, but we need to moderate those.\n+\t\tt.Go = c.uintptr\n+\t\tt.Align = c.ptrSize\n+\n+\tcase *dwarf.IntType:\n+\t\tif dt.BitSize > 0 {\n+\t\t\tfatalf(\"%s: unexpected: %d-bit int type - %s\", lineno(pos), dt.BitSize, dtype)\n+\t\t}\n+\t\tswitch t.Size {\n+\t\tdefault:\n+\t\t\tfatalf(\"%s: unexpected: %d-byte int type - %s\", lineno(pos), t.Size, dtype)\n+\t\tcase 1:\n+\t\t\tt.Go = c.int8\n+\t\tcase 2:\n+\t\t\tt.Go = c.int16\n+\t\tcase 4:\n+\t\t\tt.Go = c.int32\n+\t\tcase 8:\n+\t\t\tt.Go = c.int64\n+\t\t}\n+\t\tif t.Align = t.Size; t.Align >= c.ptrSize {\n+\t\t\tt.Align = c.ptrSize\n+\t\t}\n+\n+\tcase *dwarf.PtrType:\n+\t\tt.Align = c.ptrSize\n+\n+\t\t// Translate void* as unsafe.Pointer\n+\t\tif _, ok := base(dt.Type).(*dwarf.VoidType); ok {\n+\t\t\tt.Go = c.unsafePointer\n+\t\t\tt.C.Set(\"void*\")\n+\t\t\tbreak\n+\t\t}\n+\n+\t\t// Placeholder initialization; completed in FinishType.\n+\t\tt.Go = &ast.StarExpr{}\n+\t\tt.C.Set(\"<incomplete>*\")\n+\t\tc.ptrs[dt.Type] = append(c.ptrs[dt.Type], t)\n+\n+\tcase *dwarf.QualType:\n+\t\t// Ignore qualifier.\n+\t\tt = c.Type(dt.Type, pos)\n+\t\tc.m[dtype] = t\n+\t\treturn t\n+\n+\tcase *dwarf.StructType:\n+\t\t// Convert to Go struct, being careful about alignment.\n+\t\t// Have to give it a name to simulate C \"struct foo\" references.\n+\t\ttag := dt.StructName\n+\t\tif dt.ByteSize < 0 && tag == \"\" { // opaque unnamed struct - should not be possible\n+\t\t\tbreak\n+\t\t}\n+\t\tif tag == \"\" {\n+\t\t\ttag = \"__\" + strconv.Itoa(tagGen)\n+\t\t\ttagGen++\n+\t\t} else if t.C.Empty() {\n+\t\t\tt.C.Set(dt.Kind + \" \" + tag)\n+\t\t}\n+\t\tname := c.Ident(\"_Ctype_\" + dt.Kind + \"_\" + tag)\n+\t\tt.Go = name // publish before recursive calls\n+\t\tgoIdent[name.Name] = name\n+\t\tif dt.ByteSize < 0 {\n+\t\t\t// Size calculation in c.Struct/c.Opaque will die with size=-1 (unknown),\n+\t\t\t// so execute the basic things that the struct case would do\n+\t\t\t// other than try to determine a Go representation.\n+\t\t\ttt := *t\n+\t\t\ttt.C = &TypeRepr{\"%s %s\", []interface{}{dt.Kind, tag}}\n+\t\t\ttt.Go = c.Ident(\"struct{}\")\n+\t\t\ttypedef[name.Name] = &tt\n+\t\t\tbreak\n+\t\t}\n+\t\tswitch dt.Kind {\n+\t\tcase \"class\", \"union\":\n+\t\t\tt.Go = c.Opaque(t.Size)\n+\t\t\tif t.C.Empty() {\n+\t\t\t\tt.C.Set(\"__typeof__(unsigned char[%d])\", t.Size)\n+\t\t\t}\n+\t\t\tt.Align = 1 // TODO: should probably base this on field alignment.\n+\t\t\ttypedef[name.Name] = t\n+\t\tcase \"struct\":\n+\t\t\tg, csyntax, align := c.Struct(dt, pos)\n+\t\t\tif t.C.Empty() {\n+\t\t\t\tt.C.Set(csyntax)\n+\t\t\t}\n+\t\t\tt.Align = align\n+\t\t\ttt := *t\n+\t\t\tif tag != \"\" {\n+\t\t\t\ttt.C = &TypeRepr{\"struct %s\", []interface{}{tag}}\n+\t\t\t}\n+\t\t\ttt.Go = g\n+\t\t\ttypedef[name.Name] = &tt\n+\t\t}\n+\n+\tcase *dwarf.TypedefType:\n+\t\t// Record typedef for printing.\n+\t\tif dt.Name == \"_GoString_\" {\n+\t\t\t// Special C name for Go string type.\n+\t\t\t// Knows string layout used by compilers: pointer plus length,\n+\t\t\t// which rounds up to 2 pointers after alignment.\n+\t\t\tt.Go = c.string\n+\t\t\tt.Size = c.ptrSize * 2\n+\t\t\tt.Align = c.ptrSize\n+\t\t\tbreak\n+\t\t}\n+\t\tif dt.Name == \"_GoBytes_\" {\n+\t\t\t// Special C name for Go []byte type.\n+\t\t\t// Knows slice layout used by compilers: pointer, length, cap.\n+\t\t\tt.Go = c.Ident(\"[]byte\")\n+\t\t\tt.Size = c.ptrSize + 4 + 4\n+\t\t\tt.Align = c.ptrSize\n+\t\t\tbreak\n+\t\t}\n+\t\tname := c.Ident(\"_Ctype_\" + dt.Name)\n+\t\tgoIdent[name.Name] = name\n+\t\tsub := c.Type(dt.Type, pos)\n+\t\tt.Go = name\n+\t\tt.Size = sub.Size\n+\t\tt.Align = sub.Align\n+\t\toldType := typedef[name.Name]\n+\t\tif oldType == nil {\n+\t\t\ttt := *t\n+\t\t\ttt.Go = sub.Go\n+\t\t\ttypedef[name.Name] = &tt\n+\t\t}\n+\n+\t\t// If sub.Go.Name is \"_Ctype_struct_foo\" or \"_Ctype_union_foo\" or \"_Ctype_class_foo\",\n+\t\t// use that as the Go form for this typedef too, so that the typedef will be interchangeable\n+\t\t// with the base type.\n+\t\t// In -godefs and -cdefs mode, do this for all typedefs.\n+\t\tif isStructUnionClass(sub.Go) || *godefs || *cdefs {\n+\t\t\tt.Go = sub.Go\n+\n+\t\t\tif isStructUnionClass(sub.Go) {\n+\t\t\t\t// Use the typedef name for C code.\n+\t\t\t\ttypedef[sub.Go.(*ast.Ident).Name].C = t.C\n+\t\t\t}\n+\n+\t\t\t// If we've seen this typedef before, and it\n+\t\t\t// was an anonymous struct/union/class before\n+\t\t\t// too, use the old definition.\n+\t\t\t// TODO: it would be safer to only do this if\n+\t\t\t// we verify that the types are the same.\n+\t\t\tif oldType != nil && isStructUnionClass(oldType.Go) {\n+\t\t\t\tt.Go = oldType.Go\n+\t\t\t}\n+\t\t}\n+\n+\tcase *dwarf.UcharType:\n+\t\tif t.Size != 1 {\n+\t\t\tfatalf(\"%s: unexpected: %d-byte uchar type - %s\", lineno(pos), t.Size, dtype)\n+\t\t}\n+\t\tt.Go = c.uint8\n+\t\tt.Align = 1\n+\n+\tcase *dwarf.UintType:\n+\t\tif dt.BitSize > 0 {\n+\t\t\tfatalf(\"%s: unexpected: %d-bit uint type - %s\", lineno(pos), dt.BitSize, dtype)\n+\t\t}\n+\t\tswitch t.Size {\n+\t\tdefault:\n+\t\t\tfatalf(\"%s: unexpected: %d-byte uint type - %s\", lineno(pos), t.Size, dtype)\n+\t\tcase 1:\n+\t\t\tt.Go = c.uint8\n+\t\tcase 2:\n+\t\t\tt.Go = c.uint16\n+\t\tcase 4:\n+\t\t\tt.Go = c.uint32\n+\t\tcase 8:\n+\t\t\tt.Go = c.uint64\n+\t\t}\n+\t\tif t.Align = t.Size; t.Align >= c.ptrSize {\n+\t\t\tt.Align = c.ptrSize\n+\t\t}\n+\n+\tcase *dwarf.VoidType:\n+\t\tt.Go = c.goVoid\n+\t\tt.C.Set(\"void\")\n+\t\tt.Align = 1\n+\t}\n+\n+\tswitch dtype.(type) {\n+\tcase *dwarf.AddrType, *dwarf.BoolType, *dwarf.CharType, *dwarf.IntType, *dwarf.FloatType, *dwarf.UcharType, *dwarf.UintType:\n+\t\ts := dtype.Common().Name\n+\t\tif s != \"\" {\n+\t\t\tif ss, ok := dwarfToName[s]; ok {\n+\t\t\t\ts = ss\n+\t\t\t}\n+\t\t\ts = strings.Join(strings.Split(s, \" \"), \"\") // strip spaces\n+\t\t\tname := c.Ident(\"_Ctype_\" + s)\n+\t\t\ttt := *t\n+\t\t\ttypedef[name.Name] = &tt\n+\t\t\tif !*godefs && !*cdefs {\n+\t\t\t\tt.Go = name\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif t.Size <= 0 {\n+\t\t// Clang does not record the size of a pointer in its DWARF entry,\n+\t\t// so if dtype is an array, the call to dtype.Size at the top of the function\n+\t\t// computed the size as the array length * 0 = 0.\n+\t\t// The type switch called Type (this function) recursively on the pointer\n+\t\t// entry, and the code near the top of the function updated the size to\n+\t\t// be correct, so calling dtype.Size again will produce the correct value.\n+\t\tt.Size = dtype.Size()\n+\t\tif t.Size < 0 {\n+\t\t\t// Unsized types are [0]byte, unless they're typedefs of other types\n+\t\t\t// or structs with tags.\n+\t\t\t// if so, use the name we've already defined.\n+\t\t\tt.Size = 0\n+\t\t\tswitch dt := dtype.(type) {\n+\t\t\tcase *dwarf.TypedefType:\n+\t\t\t\t// ok\n+\t\t\tcase *dwarf.StructType:\n+\t\t\t\tif dt.StructName != \"\" {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tt.Go = c.Opaque(0)\n+\t\t\tdefault:\n+\t\t\t\tt.Go = c.Opaque(0)\n+\t\t\t}\n+\t\t\tif t.C.Empty() {\n+\t\t\t\tt.C.Set(\"void\")\n+\t\t\t}\n+\t\t\treturn t\n+\t\t}\n+\t}\n+\n+\tif t.C.Empty() {\n+\t\tfatalf(\"%s: internal error: did not create C name for %s\", lineno(pos), dtype)\n+\t}\n+\n+\treturn t\n+}\n+\n+// isStructUnionClass reports whether the type described by the Go syntax x\n+// is a struct, union, or class with a tag.\n+func isStructUnionClass(x ast.Expr) bool {\n+\tid, ok := x.(*ast.Ident)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tname := id.Name\n+\treturn strings.HasPrefix(name, \"_Ctype_struct_\") ||\n+\t\tstrings.HasPrefix(name, \"_Ctype_union_\") ||\n+\t\tstrings.HasPrefix(name, \"_Ctype_class_\")\n+}\n+\n+// FuncArg returns a Go type with the same memory layout as\n+// dtype when used as the type of a C function argument.\n+func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n+\tt := c.Type(dtype, pos)\n+\tswitch dt := dtype.(type) {\n+\tcase *dwarf.ArrayType:\n+\t\t// Arrays are passed implicitly as pointers in C.\n+\t\t// In Go, we must be explicit.\n+\t\ttr := &TypeRepr{}\n+\t\ttr.Set(\"%s*\", t.C)\n+\t\treturn &Type{\n+\t\t\tSize:  c.ptrSize,\n+\t\t\tAlign: c.ptrSize,\n+\t\t\tGo:    &ast.StarExpr{X: t.Go},\n+\t\t\tC:     tr,\n+\t\t}\n+\tcase *dwarf.TypedefType:\n+\t\t// C has much more relaxed rules than Go for\n+\t\t// implicit type conversions.  When the parameter\n+\t\t// is type T defined as *X, simulate a little of the\n+\t\t// laxness of C by making the argument *X instead of T.\n+\t\tif ptr, ok := base(dt.Type).(*dwarf.PtrType); ok {\n+\t\t\t// Unless the typedef happens to point to void* since\n+\t\t\t// Go has special rules around using unsafe.Pointer.\n+\t\t\tif _, void := base(ptr.Type).(*dwarf.VoidType); void {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tt = c.Type(ptr, pos)\n+\t\t\tif t == nil {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\t// Remember the C spelling, in case the struct\n+\t\t\t// has __attribute__((unavailable)) on it.  See issue 2888.\n+\t\t\tt.Typedef = dt.Name\n+\t\t}\n+\t}\n+\treturn t\n+}\n+\n+// FuncType returns the Go type analogous to dtype.\n+// There is no guarantee about matching memory layout.\n+func (c *typeConv) FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType {\n+\tp := make([]*Type, len(dtype.ParamType))\n+\tgp := make([]*ast.Field, len(dtype.ParamType))\n+\tfor i, f := range dtype.ParamType {\n+\t\t// gcc's DWARF generator outputs a single DotDotDotType parameter for\n+\t\t// function pointers that specify no parameters (e.g. void\n+\t\t// (*__cgo_0)()).  Treat this special case as void.  This case is\n+\t\t// invalid according to ISO C anyway (i.e. void (*__cgo_1)(...) is not\n+\t\t// legal).\n+\t\tif _, ok := f.(*dwarf.DotDotDotType); ok && i == 0 {\n+\t\t\tp, gp = nil, nil\n+\t\t\tbreak\n+\t\t}\n+\t\tp[i] = c.FuncArg(f, pos)\n+\t\tgp[i] = &ast.Field{Type: p[i].Go}\n+\t}\n+\tvar r *Type\n+\tvar gr []*ast.Field\n+\tif _, ok := dtype.ReturnType.(*dwarf.VoidType); ok {\n+\t\tgr = []*ast.Field{{Type: c.goVoid}}\n+\t} else if dtype.ReturnType != nil {\n+\t\tr = c.Type(dtype.ReturnType, pos)\n+\t\tgr = []*ast.Field{{Type: r.Go}}\n+\t}\n+\treturn &FuncType{\n+\t\tParams: p,\n+\t\tResult: r,\n+\t\tGo: &ast.FuncType{\n+\t\t\tParams:  &ast.FieldList{List: gp},\n+\t\t\tResults: &ast.FieldList{List: gr},\n+\t\t},\n+\t}\n+}\n+\n+// Identifier\n+func (c *typeConv) Ident(s string) *ast.Ident {\n+\treturn ast.NewIdent(s)\n+}\n+\n+// Opaque type of n bytes.\n+func (c *typeConv) Opaque(n int64) ast.Expr {\n+\treturn &ast.ArrayType{\n+\t\tLen: c.intExpr(n),\n+\t\tElt: c.byte,\n+\t}\n+}\n+\n+// Expr for integer n.\n+func (c *typeConv) intExpr(n int64) ast.Expr {\n+\treturn &ast.BasicLit{\n+\t\tKind:  token.INT,\n+\t\tValue: strconv.FormatInt(n, 10),\n+\t}\n+}\n+\n+// Add padding of given size to fld.\n+func (c *typeConv) pad(fld []*ast.Field, size int64) []*ast.Field {\n+\tn := len(fld)\n+\tfld = fld[0 : n+1]\n+\tfld[n] = &ast.Field{Names: []*ast.Ident{c.Ident(\"_\")}, Type: c.Opaque(size)}\n+\treturn fld\n+}\n+\n+// Struct conversion: return Go and (6g) C syntax for type.\n+func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.StructType, csyntax string, align int64) {\n+\tvar buf bytes.Buffer\n+\tbuf.WriteString(\"struct {\")\n+\tfld := make([]*ast.Field, 0, 2*len(dt.Field)+1) // enough for padding around every field\n+\toff := int64(0)\n+\n+\t// Rename struct fields that happen to be named Go keywords into\n+\t// _{keyword}.  Create a map from C ident -> Go ident.  The Go ident will\n+\t// be mangled.  Any existing identifier that already has the same name on\n+\t// the C-side will cause the Go-mangled version to be prefixed with _.\n+\t// (e.g. in a struct with fields '_type' and 'type', the latter would be\n+\t// rendered as '__type' in Go).\n+\tident := make(map[string]string)\n+\tused := make(map[string]bool)\n+\tfor _, f := range dt.Field {\n+\t\tident[f.Name] = f.Name\n+\t\tused[f.Name] = true\n+\t}\n+\n+\tif !*godefs && !*cdefs {\n+\t\tfor cid, goid := range ident {\n+\t\t\tif token.Lookup(goid).IsKeyword() {\n+\t\t\t\t// Avoid keyword\n+\t\t\t\tgoid = \"_\" + goid\n+\n+\t\t\t\t// Also avoid existing fields\n+\t\t\t\tfor _, exist := used[goid]; exist; _, exist = used[goid] {\n+\t\t\t\t\tgoid = \"_\" + goid\n+\t\t\t\t}\n+\n+\t\t\t\tused[goid] = true\n+\t\t\t\tident[cid] = goid\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tanon := 0\n+\tfor _, f := range dt.Field {\n+\t\tif f.ByteOffset > off {\n+\t\t\tfld = c.pad(fld, f.ByteOffset-off)\n+\t\t\toff = f.ByteOffset\n+\t\t}\n+\t\tt := c.Type(f.Type, pos)\n+\t\ttgo := t.Go\n+\t\tsize := t.Size\n+\t\ttalign := t.Align\n+\t\tif f.BitSize > 0 {\n+\t\t\tif f.BitSize%8 != 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tsize = f.BitSize / 8\n+\t\t\tname := tgo.(*ast.Ident).String()\n+\t\t\tif strings.HasPrefix(name, \"int\") {\n+\t\t\t\tname = \"int\"\n+\t\t\t} else {\n+\t\t\t\tname = \"uint\"\n+\t\t\t}\n+\t\t\ttgo = ast.NewIdent(name + fmt.Sprint(f.BitSize))\n+\t\t\ttalign = size\n+\t\t}\n+\n+\t\tif talign > 0 && f.ByteOffset%talign != 0 {\n+\t\t\t// Drop misaligned fields, the same way we drop integer bit fields.\n+\t\t\t// The goal is to make available what can be made available.\n+\t\t\t// Otherwise one bad and unneeded field in an otherwise okay struct\n+\t\t\t// makes the whole program not compile. Much of the time these\n+\t\t\t// structs are in system headers that cannot be corrected.\n+\t\t\tcontinue\n+\t\t}\n+\t\tn := len(fld)\n+\t\tfld = fld[0 : n+1]\n+\t\tname := f.Name\n+\t\tif name == \"\" {\n+\t\t\tname = fmt.Sprintf(\"anon%d\", anon)\n+\t\t\tanon++\n+\t\t\tident[name] = name\n+\t\t}\n+\t\tfld[n] = &ast.Field{Names: []*ast.Ident{c.Ident(ident[name])}, Type: tgo}\n+\t\toff += size\n+\t\tbuf.WriteString(t.C.String())\n+\t\tbuf.WriteString(\" \")\n+\t\tbuf.WriteString(name)\n+\t\tbuf.WriteString(\"; \")\n+\t\tif talign > align {\n+\t\t\talign = talign\n+\t\t}\n+\t}\n+\tif off < dt.ByteSize {\n+\t\tfld = c.pad(fld, dt.ByteSize-off)\n+\t\toff = dt.ByteSize\n+\t}\n+\tif off != dt.ByteSize {\n+\t\tfatalf(\"%s: struct size calculation error off=%d bytesize=%d\", lineno(pos), off, dt.ByteSize)\n+\t}\n+\tbuf.WriteString(\"}\")\n+\tcsyntax = buf.String()\n+\n+\tif *godefs || *cdefs {\n+\t\tc.todoFlds = append(c.todoFlds, fld)\n+\t}\n+\texpr = &ast.StructType{Fields: &ast.FieldList{List: fld}}\n+\treturn\n+}\n+\n+func upper(s string) string {\n+\tif s == \"\" {\n+\t\treturn \"\"\n+\t}\n+\tr, size := utf8.DecodeRuneInString(s)\n+\tif r == '_' {\n+\t\treturn \"X\" + s\n+\t}\n+\treturn string(unicode.ToUpper(r)) + s[size:]\n+}\n+\n+// godefsFields rewrites field names for use in Go or C definitions.\n+// It strips leading common prefixes (like tv_ in tv_sec, tv_usec)\n+// converts names to upper case, and rewrites _ into Pad_godefs_n,\n+// so that all fields are exported.\n+func godefsFields(fld []*ast.Field) {\n+\tprefix := fieldPrefix(fld)\n+\tnpad := 0\n+\tfor _, f := range fld {\n+\t\tfor _, n := range f.Names {\n+\t\t\tif n.Name != prefix {\n+\t\t\t\tn.Name = strings.TrimPrefix(n.Name, prefix)\n+\t\t\t}\n+\t\t\tif n.Name == \"_\" {\n+\t\t\t\t// Use exported name instead.\n+\t\t\t\tn.Name = \"Pad_cgo_\" + strconv.Itoa(npad)\n+\t\t\t\tnpad++\n+\t\t\t}\n+\t\t\tif !*cdefs {\n+\t\t\t\tn.Name = upper(n.Name)\n+\t\t\t}\n+\t\t}\n+\t\tp := &f.Type\n+\t\tt := *p\n+\t\tif star, ok := t.(*ast.StarExpr); ok {\n+\t\t\tstar = &ast.StarExpr{X: star.X}\n+\t\t\t*p = star\n+\t\t\tp = &star.X\n+\t\t\tt = *p\n+\t\t}\n+\t\tif id, ok := t.(*ast.Ident); ok {\n+\t\t\tif id.Name == \"unsafe.Pointer\" {\n+\t\t\t\t*p = ast.NewIdent(\"*byte\")\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// fieldPrefix returns the prefix that should be removed from all the\n+// field names when generating the C or Go code.  For generated\n+// C, we leave the names as is (tv_sec, tv_usec), since that's what\n+// people are used to seeing in C.  For generated Go code, such as\n+// package syscall's data structures, we drop a common prefix\n+// (so sec, usec, which will get turned into Sec, Usec for exporting).\n+func fieldPrefix(fld []*ast.Field) string {\n+\tif *cdefs {\n+\t\treturn \"\"\n+\t}\n+\tprefix := \"\"\n+\tfor _, f := range fld {\n+\t\tfor _, n := range f.Names {\n+\t\t\t// Ignore field names that don't have the prefix we're\n+\t\t\t// looking for.  It is common in C headers to have fields\n+\t\t\t// named, say, _pad in an otherwise prefixed header.\n+\t\t\t// If the struct has 3 fields tv_sec, tv_usec, _pad1, then we\n+\t\t\t// still want to remove the tv_ prefix.\n+\t\t\t// The check for \"orig_\" here handles orig_eax in the\n+\t\t\t// x86 ptrace register sets, which otherwise have all fields\n+\t\t\t// with reg_ prefixes.\n+\t\t\tif strings.HasPrefix(n.Name, \"orig_\") || strings.HasPrefix(n.Name, \"_\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ti := strings.Index(n.Name, \"_\")\n+\t\t\tif i < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif prefix == \"\" {\n+\t\t\t\tprefix = n.Name[:i+1]\n+\t\t\t} else if prefix != n.Name[:i+1] {\n+\t\t\t\treturn \"\"\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn prefix\n+}"}, {"sha": "ce5ac2736c56a3b27d12918720469a2acd6cac2f", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,294 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/printer\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+// godefs returns the output for -godefs mode.\n+func (p *Package) godefs(f *File, srcfile string) string {\n+\tvar buf bytes.Buffer\n+\n+\tfmt.Fprintf(&buf, \"// Created by cgo -godefs - DO NOT EDIT\\n\")\n+\tfmt.Fprintf(&buf, \"// %s\\n\", strings.Join(os.Args, \" \"))\n+\tfmt.Fprintf(&buf, \"\\n\")\n+\n+\toverride := make(map[string]string)\n+\n+\t// Allow source file to specify override mappings.\n+\t// For example, the socket data structures refer\n+\t// to in_addr and in_addr6 structs but we want to be\n+\t// able to treat them as byte arrays, so the godefs\n+\t// inputs in package syscall say\n+\t//\n+\t//\t// +godefs map struct_in_addr [4]byte\n+\t//\t// +godefs map struct_in_addr6 [16]byte\n+\t//\n+\tfor _, g := range f.Comments {\n+\t\tfor _, c := range g.List {\n+\t\t\ti := strings.Index(c.Text, \"+godefs map\")\n+\t\t\tif i < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ts := strings.TrimSpace(c.Text[i+len(\"+godefs map\"):])\n+\t\t\ti = strings.Index(s, \" \")\n+\t\t\tif i < 0 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"invalid +godefs map comment: %s\\n\", c.Text)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\toverride[\"_Ctype_\"+strings.TrimSpace(s[:i])] = strings.TrimSpace(s[i:])\n+\t\t}\n+\t}\n+\tfor _, n := range f.Name {\n+\t\tif s := override[n.Go]; s != \"\" {\n+\t\t\toverride[n.Mangle] = s\n+\t\t}\n+\t}\n+\n+\t// Otherwise, if the source file says type T C.whatever,\n+\t// use \"T\" as the mangling of C.whatever,\n+\t// except in the definition (handled at end of function).\n+\trefName := make(map[*ast.Expr]*Name)\n+\tfor _, r := range f.Ref {\n+\t\trefName[r.Expr] = r.Name\n+\t}\n+\tfor _, d := range f.AST.Decls {\n+\t\td, ok := d.(*ast.GenDecl)\n+\t\tif !ok || d.Tok != token.TYPE {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, s := range d.Specs {\n+\t\t\ts := s.(*ast.TypeSpec)\n+\t\t\tn := refName[&s.Type]\n+\t\t\tif n != nil && n.Mangle != \"\" {\n+\t\t\t\toverride[n.Mangle] = s.Name.Name\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Extend overrides using typedefs:\n+\t// If we know that C.xxx should format as T\n+\t// and xxx is a typedef for yyy, make C.yyy format as T.\n+\tfor typ, def := range typedef {\n+\t\tif new := override[typ]; new != \"\" {\n+\t\t\tif id, ok := def.Go.(*ast.Ident); ok {\n+\t\t\t\toverride[id.Name] = new\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Apply overrides.\n+\tfor old, new := range override {\n+\t\tif id := goIdent[old]; id != nil {\n+\t\t\tid.Name = new\n+\t\t}\n+\t}\n+\n+\t// Any names still using the _C syntax are not going to compile,\n+\t// although in general we don't know whether they all made it\n+\t// into the file, so we can't warn here.\n+\t//\n+\t// The most common case is union types, which begin with\n+\t// _Ctype_union and for which typedef[name] is a Go byte\n+\t// array of the appropriate size (such as [4]byte).\n+\t// Substitute those union types with byte arrays.\n+\tfor name, id := range goIdent {\n+\t\tif id.Name == name && strings.Contains(name, \"_Ctype_union\") {\n+\t\t\tif def := typedef[name]; def != nil {\n+\t\t\t\tid.Name = gofmt(def)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tconf.Fprint(&buf, fset, f.AST)\n+\n+\treturn buf.String()\n+}\n+\n+// cdefs returns the output for -cdefs mode.\n+// The easiest way to do this is to translate the godefs Go to C.\n+func (p *Package) cdefs(f *File, srcfile string) string {\n+\tgodefsOutput := p.godefs(f, srcfile)\n+\n+\tlines := strings.Split(godefsOutput, \"\\n\")\n+\tlines[0] = \"// Created by cgo -cdefs - DO NOT EDIT\"\n+\n+\tfor i, line := range lines {\n+\t\tlines[i] = strings.TrimSpace(line)\n+\t}\n+\n+\tvar out bytes.Buffer\n+\tprintf := func(format string, args ...interface{}) { fmt.Fprintf(&out, format, args...) }\n+\n+\tdidTypedef := false\n+\tfor i := 0; i < len(lines); i++ {\n+\t\tline := lines[i]\n+\n+\t\t// Delete\n+\t\t//\tpackage x\n+\t\tif strings.HasPrefix(line, \"package \") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Convert\n+\t\t//\tconst (\n+\t\t//\t\tA = 1\n+\t\t//\t\tB = 2\n+\t\t//\t)\n+\t\t//\n+\t\t// to\n+\t\t//\n+\t\t//\tenum {\n+\t\t//\t\tA = 1,\n+\t\t//\t\tB = 2,\n+\t\t//\t};\n+\t\tif line == \"const (\" {\n+\t\t\tprintf(\"enum {\\n\")\n+\t\t\tfor i++; i < len(lines) && lines[i] != \")\"; i++ {\n+\t\t\t\tline = lines[i]\n+\t\t\t\tif line != \"\" {\n+\t\t\t\t\tprintf(\"\\t%s,\", line)\n+\t\t\t\t}\n+\t\t\t\tprintf(\"\\n\")\n+\t\t\t}\n+\t\t\tprintf(\"};\\n\")\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Convert\n+\t\t//\tconst A = 1\n+\t\t// to\n+\t\t//\tenum { A = 1 };\n+\t\tif strings.HasPrefix(line, \"const \") {\n+\t\t\tprintf(\"enum { %s };\\n\", line[len(\"const \"):])\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// On first type definition, typedef all the structs\n+\t\t// in case there are dependencies between them.\n+\t\tif !didTypedef && strings.HasPrefix(line, \"type \") {\n+\t\t\tdidTypedef = true\n+\t\t\tfor _, line := range lines {\n+\t\t\t\tline = strings.TrimSpace(line)\n+\t\t\t\tif strings.HasPrefix(line, \"type \") && strings.HasSuffix(line, \" struct {\") {\n+\t\t\t\t\ts := strings.TrimSuffix(strings.TrimPrefix(line, \"type \"), \" struct {\")\n+\t\t\t\t\tprintf(\"typedef struct %s %s;\\n\", s, s)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tprintf(\"\\n\")\n+\t\t\tprintf(\"#pragma pack on\\n\")\n+\t\t\tprintf(\"\\n\")\n+\t\t}\n+\n+\t\t// Convert\n+\t\t//\ttype T struct {\n+\t\t//\t\tX int64\n+\t\t//\t\tY *int32\n+\t\t//\t\tZ [4]byte\n+\t\t//\t}\n+\t\t//\n+\t\t// to\n+\t\t//\n+\t\t//\tstruct T {\n+\t\t//\t\tint64 X;\n+\t\t//\t\tint32 *Y;\n+\t\t//\t\tbyte Z[4];\n+\t\t//\t}\n+\t\tif strings.HasPrefix(line, \"type \") && strings.HasSuffix(line, \" struct {\") {\n+\t\t\tif len(lines) > i+1 && lines[i+1] == \"}\" {\n+\t\t\t\t// do not output empty struct\n+\t\t\t\ti++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ts := line[len(\"type \") : len(line)-len(\" struct {\")]\n+\t\t\tprintf(\"struct %s {\\n\", s)\n+\t\t\tfor i++; i < len(lines) && lines[i] != \"}\"; i++ {\n+\t\t\t\tline := lines[i]\n+\t\t\t\tif line != \"\" {\n+\t\t\t\t\tf := strings.Fields(line)\n+\t\t\t\t\tif len(f) != 2 {\n+\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"cgo: cannot parse struct field: %s\\n\", line)\n+\t\t\t\t\t\tnerrors++\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tprintf(\"\\t%s;\", cdecl(f[0], f[1]))\n+\t\t\t\t}\n+\t\t\t\tprintf(\"\\n\")\n+\t\t\t}\n+\t\t\tprintf(\"};\\n\")\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Convert\n+\t\t//\ttype T int\n+\t\t// to\n+\t\t//\ttypedef int T;\n+\t\tif strings.HasPrefix(line, \"type \") {\n+\t\t\tf := strings.Fields(line[len(\"type \"):])\n+\t\t\tif len(f) != 2 {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"cgo: cannot parse type definition: %s\\n\", line)\n+\t\t\t\tnerrors++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tprintf(\"typedef\\t%s;\\n\", cdecl(f[0], f[1]))\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tprintf(\"%s\\n\", line)\n+\t}\n+\n+\tif didTypedef {\n+\t\tprintf(\"\\n\")\n+\t\tprintf(\"#pragma pack off\\n\")\n+\t}\n+\n+\treturn out.String()\n+}\n+\n+// cdecl returns the C declaration for the given Go name and type.\n+// It only handles the specific cases necessary for converting godefs output.\n+func cdecl(name, typ string) string {\n+\t// X *[0]byte -> X *void\n+\tif strings.HasPrefix(typ, \"*[0]\") {\n+\t\ttyp = \"*void\"\n+\t}\n+\t// X [4]byte -> X[4] byte\n+\tfor strings.HasPrefix(typ, \"[\") {\n+\t\ti := strings.Index(typ, \"]\") + 1\n+\t\tname = name + typ[:i]\n+\t\ttyp = typ[i:]\n+\t}\n+\t// X *byte -> *X byte\n+\tfor strings.HasPrefix(typ, \"*\") {\n+\t\tname = \"*\" + name\n+\t\ttyp = typ[1:]\n+\t}\n+\t// X T -> T X\n+\t// Handle the special case: 'unsafe.Pointer' is 'void *'\n+\tif typ == \"unsafe.Pointer\" {\n+\t\ttyp = \"void\"\n+\t\tname = \"*\" + name\n+\t}\n+\treturn typ + \"\\t\" + name\n+}\n+\n+var gofmtBuf bytes.Buffer\n+\n+// gofmt returns the gofmt-formatted string for an AST node.\n+func gofmt(n interface{}) string {\n+\tgofmtBuf.Reset()\n+\terr := printer.Fprint(&gofmtBuf, fset, n)\n+\tif err != nil {\n+\t\treturn \"<\" + err.Error() + \">\"\n+\t}\n+\treturn gofmtBuf.String()\n+}"}, {"sha": "ea4b9c2c70db9943e8e6a55895d91e7640f6796c", "filename": "libgo/go/cmd/cgo/main.go", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,360 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Cgo; see gmp.go for an overview.\n+\n+// TODO(rsc):\n+//\tEmit correct line number annotations.\n+//\tMake 6g understand the annotations.\n+\n+package main\n+\n+import (\n+\t\"crypto/md5\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/printer\"\n+\t\"go/token\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+// A Package collects information about the package we're going to write.\n+type Package struct {\n+\tPackageName string // name of package\n+\tPackagePath string\n+\tPtrSize     int64\n+\tIntSize     int64\n+\tGccOptions  []string\n+\tCgoFlags    map[string][]string // #cgo flags (CFLAGS, LDFLAGS)\n+\tWritten     map[string]bool\n+\tName        map[string]*Name // accumulated Name from Files\n+\tExpFunc     []*ExpFunc       // accumulated ExpFunc from Files\n+\tDecl        []ast.Decl\n+\tGoFiles     []string // list of Go files\n+\tGccFiles    []string // list of gcc output files\n+\tPreamble    string   // collected preamble for _cgo_export.h\n+}\n+\n+// A File collects information about a single Go input file.\n+type File struct {\n+\tAST      *ast.File           // parsed AST\n+\tComments []*ast.CommentGroup // comments from file\n+\tPackage  string              // Package name\n+\tPreamble string              // C preamble (doc comment on import \"C\")\n+\tRef      []*Ref              // all references to C.xxx in AST\n+\tExpFunc  []*ExpFunc          // exported functions for this file\n+\tName     map[string]*Name    // map from Go name to Name\n+}\n+\n+func nameKeys(m map[string]*Name) []string {\n+\tvar ks []string\n+\tfor k := range m {\n+\t\tks = append(ks, k)\n+\t}\n+\tsort.Strings(ks)\n+\treturn ks\n+}\n+\n+// A Ref refers to an expression of the form C.xxx in the AST.\n+type Ref struct {\n+\tName    *Name\n+\tExpr    *ast.Expr\n+\tContext string // \"type\", \"expr\", \"call\", or \"call2\"\n+}\n+\n+func (r *Ref) Pos() token.Pos {\n+\treturn (*r.Expr).Pos()\n+}\n+\n+// A Name collects information about C.xxx.\n+type Name struct {\n+\tGo       string // name used in Go referring to package C\n+\tMangle   string // name used in generated Go\n+\tC        string // name used in C\n+\tDefine   string // #define expansion\n+\tKind     string // \"const\", \"type\", \"var\", \"fpvar\", \"func\", \"not-type\"\n+\tType     *Type  // the type of xxx\n+\tFuncType *FuncType\n+\tAddError bool\n+\tConst    string // constant definition\n+}\n+\n+// IsVar returns true if Kind is either \"var\" or \"fpvar\"\n+func (n *Name) IsVar() bool {\n+\treturn n.Kind == \"var\" || n.Kind == \"fpvar\"\n+}\n+\n+// A ExpFunc is an exported function, callable from C.\n+// Such functions are identified in the Go input file\n+// by doc comments containing the line //export ExpName\n+type ExpFunc struct {\n+\tFunc    *ast.FuncDecl\n+\tExpName string // name to use from C\n+}\n+\n+// A TypeRepr contains the string representation of a type.\n+type TypeRepr struct {\n+\tRepr       string\n+\tFormatArgs []interface{}\n+}\n+\n+// A Type collects information about a type in both the C and Go worlds.\n+type Type struct {\n+\tSize       int64\n+\tAlign      int64\n+\tC          *TypeRepr\n+\tGo         ast.Expr\n+\tEnumValues map[string]int64\n+\tTypedef    string\n+}\n+\n+// A FuncType collects information about a function type in both the C and Go worlds.\n+type FuncType struct {\n+\tParams []*Type\n+\tResult *Type\n+\tGo     *ast.FuncType\n+}\n+\n+func usage() {\n+\tfmt.Fprint(os.Stderr, \"usage: cgo -- [compiler options] file.go ...\\n\")\n+\tflag.PrintDefaults()\n+\tos.Exit(2)\n+}\n+\n+var ptrSizeMap = map[string]int64{\n+\t\"386\":   4,\n+\t\"amd64\": 8,\n+\t\"arm\":   4,\n+\t\"ppc64\": 8,\n+\t\"ppc64le\": 8,\n+\t\"s390x\": 8,\n+}\n+\n+var intSizeMap = map[string]int64{\n+\t\"386\":   4,\n+\t\"amd64\": 8,\n+\t\"arm\":   4,\n+\t\"ppc64\": 8,\n+\t\"ppc64le\": 8,\n+\t\"s390x\": 8,\n+}\n+\n+var cPrefix string\n+\n+var fset = token.NewFileSet()\n+\n+var dynobj = flag.String(\"dynimport\", \"\", \"if non-empty, print dynamic import data for that file\")\n+var dynout = flag.String(\"dynout\", \"\", \"write -dynobj output to this file\")\n+var dynlinker = flag.Bool(\"dynlinker\", false, \"record dynamic linker information in dynimport mode\")\n+\n+// These flags are for bootstrapping a new Go implementation,\n+// to generate Go and C headers that match the data layout and\n+// constant values used in the host's C libraries and system calls.\n+var godefs = flag.Bool(\"godefs\", false, \"for bootstrap: write Go definitions for C file to standard output\")\n+var cdefs = flag.Bool(\"cdefs\", false, \"for bootstrap: write C definitions for C file to standard output\")\n+var objDir = flag.String(\"objdir\", \"\", \"object directory\")\n+\n+var gccgo = flag.Bool(\"gccgo\", false, \"generate files for use with gccgo\")\n+var gccgoprefix = flag.String(\"gccgoprefix\", \"\", \"-fgo-prefix option used with gccgo\")\n+var gccgopkgpath = flag.String(\"gccgopkgpath\", \"\", \"-fgo-pkgpath option used with gccgo\")\n+var importRuntimeCgo = flag.Bool(\"import_runtime_cgo\", true, \"import runtime/cgo in generated code\")\n+var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generated code\")\n+var goarch, goos string\n+\n+func main() {\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\n+\tif *dynobj != \"\" {\n+\t\t// cgo -dynimport is essentially a separate helper command\n+\t\t// built into the cgo binary.  It scans a gcc-produced executable\n+\t\t// and dumps information about the imported symbols and the\n+\t\t// imported libraries.  The 'go build' rules for cgo prepare an\n+\t\t// appropriate executable and then use its import information\n+\t\t// instead of needing to make the linkers duplicate all the\n+\t\t// specialized knowledge gcc has about where to look for imported\n+\t\t// symbols and which ones to use.\n+\t\tdynimport(*dynobj)\n+\t\treturn\n+\t}\n+\n+\tif *godefs && *cdefs {\n+\t\tfmt.Fprintf(os.Stderr, \"cgo: cannot use -cdefs and -godefs together\\n\")\n+\t\tos.Exit(2)\n+\t}\n+\n+\tif *godefs || *cdefs {\n+\t\t// Generating definitions pulled from header files,\n+\t\t// to be checked into Go repositories.\n+\t\t// Line numbers are just noise.\n+\t\tconf.Mode &^= printer.SourcePos\n+\t}\n+\n+\targs := flag.Args()\n+\tif len(args) < 1 {\n+\t\tusage()\n+\t}\n+\n+\t// Find first arg that looks like a go file and assume everything before\n+\t// that are options to pass to gcc.\n+\tvar i int\n+\tfor i = len(args); i > 0; i-- {\n+\t\tif !strings.HasSuffix(args[i-1], \".go\") {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif i == len(args) {\n+\t\tusage()\n+\t}\n+\n+\tgoFiles := args[i:]\n+\n+\tp := newPackage(args[:i])\n+\n+\t// Record CGO_LDFLAGS from the environment for external linking.\n+\tif ldflags := os.Getenv(\"CGO_LDFLAGS\"); ldflags != \"\" {\n+\t\targs, err := splitQuoted(ldflags)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"bad CGO_LDFLAGS: %q (%s)\", ldflags, err)\n+\t\t}\n+\t\tp.addToFlag(\"LDFLAGS\", args)\n+\t}\n+\n+\t// Need a unique prefix for the global C symbols that\n+\t// we use to coordinate between gcc and ourselves.\n+\t// We already put _cgo_ at the beginning, so the main\n+\t// concern is other cgo wrappers for the same functions.\n+\t// Use the beginning of the md5 of the input to disambiguate.\n+\th := md5.New()\n+\tfor _, input := range goFiles {\n+\t\tf, err := os.Open(input)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tio.Copy(h, f)\n+\t\tf.Close()\n+\t}\n+\tcPrefix = fmt.Sprintf(\"_%x\", h.Sum(nil)[0:6])\n+\n+\tfs := make([]*File, len(goFiles))\n+\tfor i, input := range goFiles {\n+\t\tf := new(File)\n+\t\tf.ReadGo(input)\n+\t\tf.DiscardCgoDirectives()\n+\t\tfs[i] = f\n+\t}\n+\n+\tif *objDir == \"\" {\n+\t\t// make sure that _obj directory exists, so that we can write\n+\t\t// all the output files there.\n+\t\tos.Mkdir(\"_obj\", 0777)\n+\t\t*objDir = \"_obj\"\n+\t}\n+\t*objDir += string(filepath.Separator)\n+\n+\tfor i, input := range goFiles {\n+\t\tf := fs[i]\n+\t\tp.Translate(f)\n+\t\tfor _, cref := range f.Ref {\n+\t\t\tswitch cref.Context {\n+\t\t\tcase \"call\", \"call2\":\n+\t\t\t\tif cref.Name.Kind != \"type\" {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\t*cref.Expr = cref.Name.Type.Go\n+\t\t\t}\n+\t\t}\n+\t\tif nerrors > 0 {\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\tpkg := f.Package\n+\t\tif dir := os.Getenv(\"CGOPKGPATH\"); dir != \"\" {\n+\t\t\tpkg = filepath.Join(dir, pkg)\n+\t\t}\n+\t\tp.PackagePath = pkg\n+\t\tp.Record(f)\n+\t\tif *godefs {\n+\t\t\tos.Stdout.WriteString(p.godefs(f, input))\n+\t\t} else if *cdefs {\n+\t\t\tos.Stdout.WriteString(p.cdefs(f, input))\n+\t\t} else {\n+\t\t\tp.writeOutput(f, input)\n+\t\t}\n+\t}\n+\n+\tif !*godefs && !*cdefs {\n+\t\tp.writeDefs()\n+\t}\n+\tif nerrors > 0 {\n+\t\tos.Exit(2)\n+\t}\n+}\n+\n+// newPackage returns a new Package that will invoke\n+// gcc with the additional arguments specified in args.\n+func newPackage(args []string) *Package {\n+\tgoarch = runtime.GOARCH\n+\tif s := os.Getenv(\"GOARCH\"); s != \"\" {\n+\t\tgoarch = s\n+\t}\n+\tgoos = runtime.GOOS\n+\tif s := os.Getenv(\"GOOS\"); s != \"\" {\n+\t\tgoos = s\n+\t}\n+\tptrSize := ptrSizeMap[goarch]\n+\tif ptrSize == 0 {\n+\t\tfatalf(\"unknown ptrSize for $GOARCH %q\", goarch)\n+\t}\n+\tintSize := intSizeMap[goarch]\n+\tif intSize == 0 {\n+\t\tfatalf(\"unknown intSize for $GOARCH %q\", goarch)\n+\t}\n+\n+\t// Reset locale variables so gcc emits English errors [sic].\n+\tos.Setenv(\"LANG\", \"en_US.UTF-8\")\n+\tos.Setenv(\"LC_ALL\", \"C\")\n+\n+\tp := &Package{\n+\t\tPtrSize:  ptrSize,\n+\t\tIntSize:  intSize,\n+\t\tCgoFlags: make(map[string][]string),\n+\t\tWritten:  make(map[string]bool),\n+\t}\n+\tp.addToFlag(\"CFLAGS\", args)\n+\treturn p\n+}\n+\n+// Record what needs to be recorded about f.\n+func (p *Package) Record(f *File) {\n+\tif p.PackageName == \"\" {\n+\t\tp.PackageName = f.Package\n+\t} else if p.PackageName != f.Package {\n+\t\terror_(token.NoPos, \"inconsistent package names: %s, %s\", p.PackageName, f.Package)\n+\t}\n+\n+\tif p.Name == nil {\n+\t\tp.Name = f.Name\n+\t} else {\n+\t\tfor k, v := range f.Name {\n+\t\t\tif p.Name[k] == nil {\n+\t\t\t\tp.Name[k] = v\n+\t\t\t} else if !reflect.DeepEqual(p.Name[k], v) {\n+\t\t\t\terror_(token.NoPos, \"inconsistent definitions for C.%s\", fixGo(k))\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif f.ExpFunc != nil {\n+\t\tp.ExpFunc = append(p.ExpFunc, f.ExpFunc...)\n+\t\tp.Preamble += \"\\n\" + f.Preamble\n+\t}\n+\tp.Decl = append(p.Decl, f.AST.Decls...)\n+}"}, {"sha": "76c7247af0dcf7a0885cf9c21929ec86054fab9e", "filename": "libgo/go/cmd/cgo/out.go", "status": "added", "additions": 1299, "deletions": 0, "changes": 1299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,1299 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"debug/elf\"\n+\t\"debug/macho\"\n+\t\"debug/pe\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/printer\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+var conf = printer.Config{Mode: printer.SourcePos, Tabwidth: 8}\n+\n+// writeDefs creates output files to be compiled by 6g, 6c, and gcc.\n+// (The comments here say 6g and 6c but the code applies to the 8 and 5 tools too.)\n+func (p *Package) writeDefs() {\n+\tfgo2 := creat(*objDir + \"_cgo_gotypes.go\")\n+\tfc := creat(*objDir + \"_cgo_defun.c\")\n+\tfm := creat(*objDir + \"_cgo_main.c\")\n+\n+\tvar gccgoInit bytes.Buffer\n+\n+\tfflg := creat(*objDir + \"_cgo_flags\")\n+\tfor k, v := range p.CgoFlags {\n+\t\tfmt.Fprintf(fflg, \"_CGO_%s=%s\\n\", k, strings.Join(v, \" \"))\n+\t\tif k == \"LDFLAGS\" && !*gccgo {\n+\t\t\tfor _, arg := range v {\n+\t\t\t\tfmt.Fprintf(fc, \"#pragma cgo_ldflag %q\\n\", arg)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfflg.Close()\n+\n+\t// Write C main file for using gcc to resolve imports.\n+\tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n+\tif *importRuntimeCgo {\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c) { }\\n\")\n+\t} else {\n+\t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n+\t\t// which provides crosscall2.  We just need a prototype.\n+\t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int), void *a, int c);\\n\")\n+\t}\n+\tfmt.Fprintf(fm, \"void _cgo_allocate(void *a, int c) { }\\n\")\n+\tfmt.Fprintf(fm, \"void _cgo_panic(void *a, int c) { }\\n\")\n+\n+\t// Write second Go output: definitions of _C_xxx.\n+\t// In a separate file so that the import of \"unsafe\" does not\n+\t// pollute the original file.\n+\tfmt.Fprintf(fgo2, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n+\tfmt.Fprintf(fgo2, \"package %s\\n\\n\", p.PackageName)\n+\tfmt.Fprintf(fgo2, \"import \\\"unsafe\\\"\\n\\n\")\n+\tif *importSyscall {\n+\t\tfmt.Fprintf(fgo2, \"import \\\"syscall\\\"\\n\\n\")\n+\t}\n+\tif !*gccgo && *importRuntimeCgo {\n+\t\tfmt.Fprintf(fgo2, \"import _ \\\"runtime/cgo\\\"\\n\\n\")\n+\t}\n+\tfmt.Fprintf(fgo2, \"type _ unsafe.Pointer\\n\\n\")\n+\tif *importSyscall {\n+\t\tfmt.Fprintf(fgo2, \"func _Cerrno(dst *error, x int32) { *dst = syscall.Errno(x) }\\n\")\n+\t}\n+\n+\ttypedefNames := make([]string, 0, len(typedef))\n+\tfor name := range typedef {\n+\t\ttypedefNames = append(typedefNames, name)\n+\t}\n+\tsort.Strings(typedefNames)\n+\tfor _, name := range typedefNames {\n+\t\tdef := typedef[name]\n+\t\tfmt.Fprintf(fgo2, \"type %s \", name)\n+\t\tconf.Fprint(fgo2, fset, def.Go)\n+\t\tfmt.Fprintf(fgo2, \"\\n\\n\")\n+\t}\n+\tif *gccgo {\n+\t\tfmt.Fprintf(fgo2, \"type _Ctype_void byte\\n\")\n+\t} else {\n+\t\tfmt.Fprintf(fgo2, \"type _Ctype_void [0]byte\\n\")\n+\t}\n+\n+\tif *gccgo {\n+\t\tfmt.Fprintf(fc, p.cPrologGccgo())\n+\t} else {\n+\t\tfmt.Fprintf(fc, cProlog)\n+\t}\n+\n+\tgccgoSymbolPrefix := p.gccgoSymbolPrefix()\n+\n+\tcVars := make(map[string]bool)\n+\tfor _, key := range nameKeys(p.Name) {\n+\t\tn := p.Name[key]\n+\t\tif !n.IsVar() {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif !cVars[n.C] {\n+\t\t\tfmt.Fprintf(fm, \"extern char %s[];\\n\", n.C)\n+\t\t\tfmt.Fprintf(fm, \"void *_cgohack_%s = %s;\\n\\n\", n.C, n.C)\n+\n+\t\t\tif !*gccgo {\n+\t\t\t\tfmt.Fprintf(fc, \"#pragma cgo_import_static %s\\n\", n.C)\n+\t\t\t}\n+\n+\t\t\tfmt.Fprintf(fc, \"extern byte *%s;\\n\", n.C)\n+\n+\t\t\tcVars[n.C] = true\n+\t\t}\n+\t\tvar amp string\n+\t\tvar node ast.Node\n+\t\tif n.Kind == \"var\" {\n+\t\t\tamp = \"&\"\n+\t\t\tnode = &ast.StarExpr{X: n.Type.Go}\n+\t\t} else if n.Kind == \"fpvar\" {\n+\t\t\tnode = n.Type.Go\n+\t\t\tif *gccgo {\n+\t\t\t\tamp = \"&\"\n+\t\t\t}\n+\t\t} else {\n+\t\t\tpanic(fmt.Errorf(\"invalid var kind %q\", n.Kind))\n+\t\t}\n+\t\tif *gccgo {\n+\t\t\tfmt.Fprintf(fc, `extern void *%s __asm__(\"%s.%s\");`, n.Mangle, gccgoSymbolPrefix, n.Mangle)\n+\t\t\tfmt.Fprintf(&gccgoInit, \"\\t%s = %s%s;\\n\", n.Mangle, amp, n.C)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(fc, \"void *\u00b7%s = %s%s;\\n\", n.Mangle, amp, n.C)\n+\t\t}\n+\t\tfmt.Fprintf(fc, \"\\n\")\n+\n+\t\tfmt.Fprintf(fgo2, \"var %s \", n.Mangle)\n+\t\tconf.Fprint(fgo2, fset, node)\n+\t\tfmt.Fprintf(fgo2, \"\\n\")\n+\t}\n+\tfmt.Fprintf(fc, \"\\n\")\n+\n+\tfor _, key := range nameKeys(p.Name) {\n+\t\tn := p.Name[key]\n+\t\tif n.Const != \"\" {\n+\t\t\tfmt.Fprintf(fgo2, \"const _Cconst_%s = %s\\n\", n.Go, n.Const)\n+\t\t}\n+\t}\n+\tfmt.Fprintf(fgo2, \"\\n\")\n+\n+\tfor _, key := range nameKeys(p.Name) {\n+\t\tn := p.Name[key]\n+\t\tif n.FuncType != nil {\n+\t\t\tp.writeDefsFunc(fc, fgo2, n)\n+\t\t}\n+\t}\n+\n+\tif *gccgo {\n+\t\tp.writeGccgoExports(fgo2, fc, fm)\n+\t} else {\n+\t\tp.writeExports(fgo2, fc, fm)\n+\t}\n+\n+\tinit := gccgoInit.String()\n+\tif init != \"\" {\n+\t\tfmt.Fprintln(fc, \"static void init(void) __attribute__ ((constructor));\")\n+\t\tfmt.Fprintln(fc, \"static void init(void) {\")\n+\t\tfmt.Fprint(fc, init)\n+\t\tfmt.Fprintln(fc, \"}\")\n+\t}\n+\n+\tfgo2.Close()\n+\tfc.Close()\n+}\n+\n+func dynimport(obj string) {\n+\tstdout := os.Stdout\n+\tif *dynout != \"\" {\n+\t\tf, err := os.Create(*dynout)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tstdout = f\n+\t}\n+\n+\tif f, err := elf.Open(obj); err == nil {\n+\t\tif *dynlinker {\n+\t\t\t// Emit the cgo_dynamic_linker line.\n+\t\t\tif sec := f.Section(\".interp\"); sec != nil {\n+\t\t\t\tif data, err := sec.Data(); err == nil && len(data) > 1 {\n+\t\t\t\t\t// skip trailing \\0 in data\n+\t\t\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_dynamic_linker %q\\n\", string(data[:len(data)-1]))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tsym, err := f.ImportedSymbols()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported symbols from ELF file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, s := range sym {\n+\t\t\ttarg := s.Name\n+\t\t\tif s.Version != \"\" {\n+\t\t\t\ttarg += \"#\" + s.Version\n+\t\t\t}\n+\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic %s %s %q\\n\", s.Name, targ, s.Library)\n+\t\t}\n+\t\tlib, err := f.ImportedLibraries()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported libraries from ELF file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, l := range lib {\n+\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic _ _ %q\\n\", l)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif f, err := macho.Open(obj); err == nil {\n+\t\tsym, err := f.ImportedSymbols()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported symbols from Mach-O file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, s := range sym {\n+\t\t\tif len(s) > 0 && s[0] == '_' {\n+\t\t\t\ts = s[1:]\n+\t\t\t}\n+\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic %s %s %q\\n\", s, s, \"\")\n+\t\t}\n+\t\tlib, err := f.ImportedLibraries()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported libraries from Mach-O file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, l := range lib {\n+\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic _ _ %q\\n\", l)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif f, err := pe.Open(obj); err == nil {\n+\t\tsym, err := f.ImportedSymbols()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"cannot load imported symbols from PE file %s: %v\", obj, err)\n+\t\t}\n+\t\tfor _, s := range sym {\n+\t\t\tss := strings.Split(s, \":\")\n+\t\t\tname := strings.Split(ss[0], \"@\")[0]\n+\t\t\tfmt.Fprintf(stdout, \"#pragma cgo_import_dynamic %s %s %q\\n\", name, ss[0], strings.ToLower(ss[1]))\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tfatalf(\"cannot parse %s as ELF, Mach-O or PE\", obj)\n+}\n+\n+// Construct a gcc struct matching the 6c argument frame.\n+// Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.\n+// These assumptions are checked by the gccProlog.\n+// Also assumes that 6c convention is to word-align the\n+// input and output parameters.\n+func (p *Package) structType(n *Name) (string, int64) {\n+\tvar buf bytes.Buffer\n+\tfmt.Fprint(&buf, \"struct {\\n\")\n+\toff := int64(0)\n+\tfor i, t := range n.FuncType.Params {\n+\t\tif off%t.Align != 0 {\n+\t\t\tpad := t.Align - off%t.Align\n+\t\t\tfmt.Fprintf(&buf, \"\\t\\tchar __pad%d[%d];\\n\", off, pad)\n+\t\t\toff += pad\n+\t\t}\n+\t\tc := t.Typedef\n+\t\tif c == \"\" {\n+\t\t\tc = t.C.String()\n+\t\t}\n+\t\tfmt.Fprintf(&buf, \"\\t\\t%s p%d;\\n\", c, i)\n+\t\toff += t.Size\n+\t}\n+\tif off%p.PtrSize != 0 {\n+\t\tpad := p.PtrSize - off%p.PtrSize\n+\t\tfmt.Fprintf(&buf, \"\\t\\tchar __pad%d[%d];\\n\", off, pad)\n+\t\toff += pad\n+\t}\n+\tif t := n.FuncType.Result; t != nil {\n+\t\tif off%t.Align != 0 {\n+\t\t\tpad := t.Align - off%t.Align\n+\t\t\tfmt.Fprintf(&buf, \"\\t\\tchar __pad%d[%d];\\n\", off, pad)\n+\t\t\toff += pad\n+\t\t}\n+\t\tqual := \"\"\n+\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\t\t\tqual = \"const \"\n+\t\t}\n+\t\tfmt.Fprintf(&buf, \"\\t\\t%s%s r;\\n\", qual, t.C)\n+\t\toff += t.Size\n+\t}\n+\tif off%p.PtrSize != 0 {\n+\t\tpad := p.PtrSize - off%p.PtrSize\n+\t\tfmt.Fprintf(&buf, \"\\t\\tchar __pad%d[%d];\\n\", off, pad)\n+\t\toff += pad\n+\t}\n+\tif n.AddError {\n+\t\tfmt.Fprint(&buf, \"\\t\\tint e[2*sizeof(void *)/sizeof(int)]; /* error */\\n\")\n+\t\toff += 2 * p.PtrSize\n+\t}\n+\tif off == 0 {\n+\t\tfmt.Fprintf(&buf, \"\\t\\tchar unused;\\n\") // avoid empty struct\n+\t}\n+\tfmt.Fprintf(&buf, \"\\t}\")\n+\treturn buf.String(), off\n+}\n+\n+func (p *Package) writeDefsFunc(fc, fgo2 *os.File, n *Name) {\n+\tname := n.Go\n+\tgtype := n.FuncType.Go\n+\tvoid := gtype.Results == nil || len(gtype.Results.List) == 0\n+\tif n.AddError {\n+\t\t// Add \"error\" to return type list.\n+\t\t// Type list is known to be 0 or 1 element - it's a C function.\n+\t\terr := &ast.Field{Type: ast.NewIdent(\"error\")}\n+\t\tl := gtype.Results.List\n+\t\tif len(l) == 0 {\n+\t\t\tl = []*ast.Field{err}\n+\t\t} else {\n+\t\t\tl = []*ast.Field{l[0], err}\n+\t\t}\n+\t\tt := new(ast.FuncType)\n+\t\t*t = *gtype\n+\t\tt.Results = &ast.FieldList{List: l}\n+\t\tgtype = t\n+\t}\n+\n+\t// Go func declaration.\n+\td := &ast.FuncDecl{\n+\t\tName: ast.NewIdent(n.Mangle),\n+\t\tType: gtype,\n+\t}\n+\n+\t// Builtins defined in the C prolog.\n+\tinProlog := name == \"CString\" || name == \"GoString\" || name == \"GoStringN\" || name == \"GoBytes\" || name == \"_CMalloc\"\n+\n+\tif *gccgo {\n+\t\t// Gccgo style hooks.\n+\t\tfmt.Fprint(fgo2, \"\\n\")\n+\t\tcname := fmt.Sprintf(\"_cgo%s%s\", cPrefix, n.Mangle)\n+\t\tparamnames := []string(nil)\n+\t\tfor i, param := range d.Type.Params.List {\n+\t\t\tparamName := fmt.Sprintf(\"p%d\", i)\n+\t\t\tparam.Names = []*ast.Ident{ast.NewIdent(paramName)}\n+\t\t\tparamnames = append(paramnames, paramName)\n+\t\t}\n+\n+\t\tconf.Fprint(fgo2, fset, d)\n+\t\tfmt.Fprint(fgo2, \" {\\n\")\n+\t\tif !inProlog {\n+\t\t\tfmt.Fprint(fgo2, \"\\tdefer syscall.CgocallDone()\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"\\tsyscall.Cgocall()\\n\")\n+\t\t}\n+\t\tif n.AddError {\n+\t\t\tfmt.Fprint(fgo2, \"\\tsyscall.SetErrno(0)\\n\")\n+\t\t}\n+\t\tfmt.Fprint(fgo2, \"\\t\")\n+\t\tif !void {\n+\t\t\tfmt.Fprint(fgo2, \"r := \")\n+\t\t}\n+\t\tfmt.Fprintf(fgo2, \"%s(%s)\\n\", cname, strings.Join(paramnames, \", \"))\n+\n+\t\tif n.AddError {\n+\t\t\tfmt.Fprint(fgo2, \"\\te := syscall.GetErrno()\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"\\tif e != 0 {\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"\\t\\treturn \")\n+\t\t\tif !void {\n+\t\t\t\tfmt.Fprint(fgo2, \"r, \")\n+\t\t\t}\n+\t\t\tfmt.Fprint(fgo2, \"e\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"\\t}\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"\\treturn \")\n+\t\t\tif !void {\n+\t\t\t\tfmt.Fprint(fgo2, \"r, \")\n+\t\t\t}\n+\t\t\tfmt.Fprint(fgo2, \"nil\\n\")\n+\t\t} else if !void {\n+\t\t\tfmt.Fprint(fgo2, \"\\treturn r\\n\")\n+\t\t}\n+\n+\t\tfmt.Fprint(fgo2, \"}\\n\")\n+\n+\t\t// declare the C function.\n+\t\tfmt.Fprintf(fgo2, \"//extern _cgo%s%s\\n\", cPrefix, n.Mangle)\n+\t\td.Name = ast.NewIdent(cname)\n+\t\tif n.AddError {\n+\t\t\tl := d.Type.Results.List\n+\t\t\td.Type.Results.List = l[:len(l)-1]\n+\t\t}\n+\t\tconf.Fprint(fgo2, fset, d)\n+\t\tfmt.Fprint(fgo2, \"\\n\")\n+\n+\t\treturn\n+\t}\n+\tconf.Fprint(fgo2, fset, d)\n+\tfmt.Fprint(fgo2, \"\\n\")\n+\n+\tif inProlog {\n+\t\treturn\n+\t}\n+\n+\tvar argSize int64\n+\t_, argSize = p.structType(n)\n+\n+\t// C wrapper calls into gcc, passing a pointer to the argument frame.\n+\tfmt.Fprintf(fc, \"#pragma cgo_import_static _cgo%s%s\\n\", cPrefix, n.Mangle)\n+\tfmt.Fprintf(fc, \"void _cgo%s%s(void*);\\n\", cPrefix, n.Mangle)\n+\tfmt.Fprintf(fc, \"\\n\")\n+\tfmt.Fprintf(fc, \"void\\n\")\n+\tif argSize == 0 {\n+\t\targSize++\n+\t}\n+\t// TODO(rsc): The struct here should declare pointers only where\n+\t// there are pointers in the actual argument frame.\n+\t// This is a workaround for golang.org/issue/6397.\n+\tfmt.Fprintf(fc, \"\u00b7%s(struct{\", n.Mangle)\n+\tif n := argSize / p.PtrSize; n > 0 {\n+\t\tfmt.Fprintf(fc, \"void *y[%d];\", n)\n+\t}\n+\tif n := argSize % p.PtrSize; n > 0 {\n+\t\tfmt.Fprintf(fc, \"uint8 x[%d];\", n)\n+\t}\n+\tfmt.Fprintf(fc, \"}p)\\n\")\n+\tfmt.Fprintf(fc, \"{\\n\")\n+\tfmt.Fprintf(fc, \"\\truntime\u00b7cgocall(_cgo%s%s, &p);\\n\", cPrefix, n.Mangle)\n+\tif n.AddError {\n+\t\t// gcc leaves errno in first word of interface at end of p.\n+\t\t// check whether it is zero; if so, turn interface into nil.\n+\t\t// if not, turn interface into errno.\n+\t\t// Go init function initializes \u00b7_Cerrno with an os.Errno\n+\t\t// for us to copy.\n+\t\tfmt.Fprintln(fc, `\t{\n+\t\t\tint32 e;\n+\t\t\tvoid **v;\n+\t\t\tv = (void**)(&p+1) - 2;\t/* v = final two void* of p */\n+\t\t\te = *(int32*)v;\n+\t\t\tv[0] = (void*)0xdeadbeef;\n+\t\t\tv[1] = (void*)0xdeadbeef;\n+\t\t\tif(e == 0) {\n+\t\t\t\t/* nil interface */\n+\t\t\t\tv[0] = 0;\n+\t\t\t\tv[1] = 0;\n+\t\t\t} else {\n+\t\t\t\t\u00b7_Cerrno(v, e);\t/* fill in v as error for errno e */\n+\t\t\t}\n+\t\t}`)\n+\t}\n+\tfmt.Fprintf(fc, \"}\\n\")\n+\tfmt.Fprintf(fc, \"\\n\")\n+}\n+\n+// writeOutput creates stubs for a specific source file to be compiled by 6g\n+// (The comments here say 6g and 6c but the code applies to the 8 and 5 tools too.)\n+func (p *Package) writeOutput(f *File, srcfile string) {\n+\tbase := srcfile\n+\tif strings.HasSuffix(base, \".go\") {\n+\t\tbase = base[0 : len(base)-3]\n+\t}\n+\tbase = strings.Map(slashToUnderscore, base)\n+\tfgo1 := creat(*objDir + base + \".cgo1.go\")\n+\tfgcc := creat(*objDir + base + \".cgo2.c\")\n+\n+\tp.GoFiles = append(p.GoFiles, base+\".cgo1.go\")\n+\tp.GccFiles = append(p.GccFiles, base+\".cgo2.c\")\n+\n+\t// Write Go output: Go input with rewrites of C.xxx to _C_xxx.\n+\tfmt.Fprintf(fgo1, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n+\tconf.Fprint(fgo1, fset, f.AST)\n+\n+\t// While we process the vars and funcs, also write 6c and gcc output.\n+\t// Gcc output starts with the preamble.\n+\tfmt.Fprintf(fgcc, \"%s\\n\", f.Preamble)\n+\tfmt.Fprintf(fgcc, \"%s\\n\", gccProlog)\n+\n+\tfor _, key := range nameKeys(f.Name) {\n+\t\tn := f.Name[key]\n+\t\tif n.FuncType != nil {\n+\t\t\tp.writeOutputFunc(fgcc, n)\n+\t\t}\n+\t}\n+\n+\tfgo1.Close()\n+\tfgcc.Close()\n+}\n+\n+// fixGo converts the internal Name.Go field into the name we should show\n+// to users in error messages. There's only one for now: on input we rewrite\n+// C.malloc into C._CMalloc, so change it back here.\n+func fixGo(name string) string {\n+\tif name == \"_CMalloc\" {\n+\t\treturn \"malloc\"\n+\t}\n+\treturn name\n+}\n+\n+var isBuiltin = map[string]bool{\n+\t\"_Cfunc_CString\":   true,\n+\t\"_Cfunc_GoString\":  true,\n+\t\"_Cfunc_GoStringN\": true,\n+\t\"_Cfunc_GoBytes\":   true,\n+\t\"_Cfunc__CMalloc\":  true,\n+}\n+\n+func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n+\tname := n.Mangle\n+\tif isBuiltin[name] || p.Written[name] {\n+\t\t// The builtins are already defined in the C prolog, and we don't\n+\t\t// want to duplicate function definitions we've already done.\n+\t\treturn\n+\t}\n+\tp.Written[name] = true\n+\n+\tif *gccgo {\n+\t\tp.writeGccgoOutputFunc(fgcc, n)\n+\t\treturn\n+\t}\n+\n+\tctype, _ := p.structType(n)\n+\n+\t// Gcc wrapper unpacks the C argument struct\n+\t// and calls the actual C function.\n+\tfmt.Fprintf(fgcc, \"void\\n\")\n+\tfmt.Fprintf(fgcc, \"_cgo%s%s(void *v)\\n\", cPrefix, n.Mangle)\n+\tfmt.Fprintf(fgcc, \"{\\n\")\n+\tif n.AddError {\n+\t\tfmt.Fprintf(fgcc, \"\\terrno = 0;\\n\")\n+\t}\n+\t// We're trying to write a gcc struct that matches 6c/8c/5c's layout.\n+\t// Use packed attribute to force no padding in this struct in case\n+\t// gcc has different packing requirements.\n+\tfmt.Fprintf(fgcc, \"\\t%s %v *a = v;\\n\", ctype, p.packedAttribute())\n+\tfmt.Fprintf(fgcc, \"\\t\")\n+\tif t := n.FuncType.Result; t != nil {\n+\t\tfmt.Fprintf(fgcc, \"a->r = \")\n+\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\t\t\tfmt.Fprint(fgcc, \"(__typeof__(a->r)) \")\n+\t\t}\n+\t}\n+\tfmt.Fprintf(fgcc, \"%s(\", n.C)\n+\tfor i, t := range n.FuncType.Params {\n+\t\tif i > 0 {\n+\t\t\tfmt.Fprintf(fgcc, \", \")\n+\t\t}\n+\t\t// We know the type params are correct, because\n+\t\t// the Go equivalents had good type params.\n+\t\t// However, our version of the type omits the magic\n+\t\t// words const and volatile, which can provoke\n+\t\t// C compiler warnings.  Silence them by casting\n+\t\t// all pointers to void*.  (Eventually that will produce\n+\t\t// other warnings.)\n+\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n+\t\t}\n+\t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n+\t}\n+\tfmt.Fprintf(fgcc, \");\\n\")\n+\tif n.AddError {\n+\t\tfmt.Fprintf(fgcc, \"\\t*(int*)(a->e) = errno;\\n\")\n+\t}\n+\tfmt.Fprintf(fgcc, \"}\\n\")\n+\tfmt.Fprintf(fgcc, \"\\n\")\n+}\n+\n+// Write out a wrapper for a function when using gccgo.  This is a\n+// simple wrapper that just calls the real function.  We only need a\n+// wrapper to support static functions in the prologue--without a\n+// wrapper, we can't refer to the function, since the reference is in\n+// a different file.\n+func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n+\tif t := n.FuncType.Result; t != nil {\n+\t\tfmt.Fprintf(fgcc, \"%s\\n\", t.C.String())\n+\t} else {\n+\t\tfmt.Fprintf(fgcc, \"void\\n\")\n+\t}\n+\tfmt.Fprintf(fgcc, \"_cgo%s%s(\", cPrefix, n.Mangle)\n+\tfor i, t := range n.FuncType.Params {\n+\t\tif i > 0 {\n+\t\t\tfmt.Fprintf(fgcc, \", \")\n+\t\t}\n+\t\tc := t.Typedef\n+\t\tif c == \"\" {\n+\t\t\tc = t.C.String()\n+\t\t}\n+\t\tfmt.Fprintf(fgcc, \"%s p%d\", c, i)\n+\t}\n+\tfmt.Fprintf(fgcc, \")\\n\")\n+\tfmt.Fprintf(fgcc, \"{\\n\")\n+\tfmt.Fprintf(fgcc, \"\\t\")\n+\tif t := n.FuncType.Result; t != nil {\n+\t\tfmt.Fprintf(fgcc, \"return \")\n+\t\t// Cast to void* to avoid warnings due to omitted qualifiers.\n+\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n+\t\t}\n+\t}\n+\tfmt.Fprintf(fgcc, \"%s(\", n.C)\n+\tfor i, t := range n.FuncType.Params {\n+\t\tif i > 0 {\n+\t\t\tfmt.Fprintf(fgcc, \", \")\n+\t\t}\n+\t\t// Cast to void* to avoid warnings due to omitted qualifiers.\n+\t\tif c := t.C.String(); c[len(c)-1] == '*' {\n+\t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n+\t\t}\n+\t\tfmt.Fprintf(fgcc, \"p%d\", i)\n+\t}\n+\tfmt.Fprintf(fgcc, \");\\n\")\n+\tfmt.Fprintf(fgcc, \"}\\n\")\n+\tfmt.Fprintf(fgcc, \"\\n\")\n+}\n+\n+// packedAttribute returns host compiler struct attribute that will be\n+// used to match 6c/8c/5c's struct layout. For example, on 386 Windows,\n+// gcc wants to 8-align int64s, but 8c does not.\n+// Use __gcc_struct__ to work around http://gcc.gnu.org/PR52991 on x86,\n+// and http://golang.org/issue/5603.\n+func (p *Package) packedAttribute() string {\n+\ts := \"__attribute__((__packed__\"\n+\tif !strings.Contains(p.gccBaseCmd()[0], \"clang\") && (goarch == \"amd64\" || goarch == \"386\") {\n+\t\ts += \", __gcc_struct__\"\n+\t}\n+\treturn s + \"))\"\n+}\n+\n+// Write out the various stubs we need to support functions exported\n+// from Go so that they are callable from C.\n+func (p *Package) writeExports(fgo2, fc, fm *os.File) {\n+\tfgcc := creat(*objDir + \"_cgo_export.c\")\n+\tfgcch := creat(*objDir + \"_cgo_export.h\")\n+\n+\tfmt.Fprintf(fgcch, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n+\tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n+\n+\tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\")\n+\n+\tfmt.Fprintf(fgcc, \"\\nextern void crosscall2(void (*fn)(void *, int), void *, int);\\n\\n\")\n+\n+\tfor _, exp := range p.ExpFunc {\n+\t\tfn := exp.Func\n+\n+\t\t// Construct a gcc struct matching the 6c argument and\n+\t\t// result frame.  The gcc struct will be compiled with\n+\t\t// __attribute__((packed)) so all padding must be accounted\n+\t\t// for explicitly.\n+\t\tctype := \"struct {\\n\"\n+\t\toff := int64(0)\n+\t\tnpad := 0\n+\t\tif fn.Recv != nil {\n+\t\t\tt := p.cgoType(fn.Recv.List[0].Type)\n+\t\t\tctype += fmt.Sprintf(\"\\t\\t%s recv;\\n\", t.C)\n+\t\t\toff += t.Size\n+\t\t}\n+\t\tfntype := fn.Type\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tt := p.cgoType(atype)\n+\t\t\t\tif off%t.Align != 0 {\n+\t\t\t\t\tpad := t.Align - off%t.Align\n+\t\t\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n+\t\t\t\t\toff += pad\n+\t\t\t\t\tnpad++\n+\t\t\t\t}\n+\t\t\t\tctype += fmt.Sprintf(\"\\t\\t%s p%d;\\n\", t.C, i)\n+\t\t\t\toff += t.Size\n+\t\t\t})\n+\t\tif off%p.PtrSize != 0 {\n+\t\t\tpad := p.PtrSize - off%p.PtrSize\n+\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n+\t\t\toff += pad\n+\t\t\tnpad++\n+\t\t}\n+\t\tforFieldList(fntype.Results,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tt := p.cgoType(atype)\n+\t\t\t\tif off%t.Align != 0 {\n+\t\t\t\t\tpad := t.Align - off%t.Align\n+\t\t\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n+\t\t\t\t\toff += pad\n+\t\t\t\t\tnpad++\n+\t\t\t\t}\n+\t\t\t\tctype += fmt.Sprintf(\"\\t\\t%s r%d;\\n\", t.C, i)\n+\t\t\t\toff += t.Size\n+\t\t\t})\n+\t\tif off%p.PtrSize != 0 {\n+\t\t\tpad := p.PtrSize - off%p.PtrSize\n+\t\t\tctype += fmt.Sprintf(\"\\t\\tchar __pad%d[%d];\\n\", npad, pad)\n+\t\t\toff += pad\n+\t\t\tnpad++\n+\t\t}\n+\t\tif ctype == \"struct {\\n\" {\n+\t\t\tctype += \"\\t\\tchar unused;\\n\" // avoid empty struct\n+\t\t}\n+\t\tctype += \"\\t}\"\n+\n+\t\t// Get the return type of the wrapper function\n+\t\t// compiled by gcc.\n+\t\tgccResult := \"\"\n+\t\tif fntype.Results == nil || len(fntype.Results.List) == 0 {\n+\t\t\tgccResult = \"void\"\n+\t\t} else if len(fntype.Results.List) == 1 && len(fntype.Results.List[0].Names) <= 1 {\n+\t\t\tgccResult = p.cgoType(fntype.Results.List[0].Type).C.String()\n+\t\t} else {\n+\t\t\tfmt.Fprintf(fgcch, \"\\n/* Return type for %s */\\n\", exp.ExpName)\n+\t\t\tfmt.Fprintf(fgcch, \"struct %s_return {\\n\", exp.ExpName)\n+\t\t\tforFieldList(fntype.Results,\n+\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\tfmt.Fprintf(fgcch, \"\\t%s r%d;\\n\", p.cgoType(atype).C, i)\n+\t\t\t\t})\n+\t\t\tfmt.Fprintf(fgcch, \"};\\n\")\n+\t\t\tgccResult = \"struct \" + exp.ExpName + \"_return\"\n+\t\t}\n+\n+\t\t// Build the wrapper function compiled by gcc.\n+\t\ts := fmt.Sprintf(\"%s %s(\", gccResult, exp.ExpName)\n+\t\tif fn.Recv != nil {\n+\t\t\ts += p.cgoType(fn.Recv.List[0].Type).C.String()\n+\t\t\ts += \" recv\"\n+\t\t}\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tif i > 0 || fn.Recv != nil {\n+\t\t\t\t\ts += \", \"\n+\t\t\t\t}\n+\t\t\t\ts += fmt.Sprintf(\"%s p%d\", p.cgoType(atype).C, i)\n+\t\t\t})\n+\t\ts += \")\"\n+\t\tfmt.Fprintf(fgcch, \"\\nextern %s;\\n\", s)\n+\n+\t\tfmt.Fprintf(fgcc, \"extern void _cgoexp%s_%s(void *, int);\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fgcc, \"\\n%s\\n\", s)\n+\t\tfmt.Fprintf(fgcc, \"{\\n\")\n+\t\tfmt.Fprintf(fgcc, \"\\t%s %v a;\\n\", ctype, p.packedAttribute())\n+\t\tif gccResult != \"void\" && (len(fntype.Results.List) > 1 || len(fntype.Results.List[0].Names) > 1) {\n+\t\t\tfmt.Fprintf(fgcc, \"\\t%s r;\\n\", gccResult)\n+\t\t}\n+\t\tif fn.Recv != nil {\n+\t\t\tfmt.Fprintf(fgcc, \"\\ta.recv = recv;\\n\")\n+\t\t}\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tfmt.Fprintf(fgcc, \"\\ta.p%d = p%d;\\n\", i, i)\n+\t\t\t})\n+\t\tfmt.Fprintf(fgcc, \"\\tcrosscall2(_cgoexp%s_%s, &a, %d);\\n\", cPrefix, exp.ExpName, off)\n+\t\tif gccResult != \"void\" {\n+\t\t\tif len(fntype.Results.List) == 1 && len(fntype.Results.List[0].Names) <= 1 {\n+\t\t\t\tfmt.Fprintf(fgcc, \"\\treturn a.r0;\\n\")\n+\t\t\t} else {\n+\t\t\t\tforFieldList(fntype.Results,\n+\t\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\t\tfmt.Fprintf(fgcc, \"\\tr.r%d = a.r%d;\\n\", i, i)\n+\t\t\t\t\t})\n+\t\t\t\tfmt.Fprintf(fgcc, \"\\treturn r;\\n\")\n+\t\t\t}\n+\t\t}\n+\t\tfmt.Fprintf(fgcc, \"}\\n\")\n+\n+\t\t// Build the wrapper function compiled by 6c/8c\n+\t\tgoname := exp.Func.Name.Name\n+\t\tif fn.Recv != nil {\n+\t\t\tgoname = \"_cgoexpwrap\" + cPrefix + \"_\" + fn.Recv.List[0].Names[0].Name + \"_\" + goname\n+\t\t}\n+\t\tfmt.Fprintf(fc, \"#pragma cgo_export_dynamic %s\\n\", goname)\n+\t\tfmt.Fprintf(fc, \"extern void \u00b7%s();\\n\\n\", goname)\n+\t\tfmt.Fprintf(fc, \"#pragma cgo_export_static _cgoexp%s_%s\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fc, \"#pragma textflag 7\\n\") // no split stack, so no use of m or g\n+\t\tfmt.Fprintf(fc, \"void\\n\")\n+\t\tfmt.Fprintf(fc, \"_cgoexp%s_%s(void *a, int32 n)\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fc, \"{\\n\")\n+\t\tfmt.Fprintf(fc, \"\\truntime\u00b7cgocallback(\u00b7%s, a, n);\\n\", goname)\n+\t\tfmt.Fprintf(fc, \"}\\n\")\n+\n+\t\tfmt.Fprintf(fm, \"int _cgoexp%s_%s;\\n\", cPrefix, exp.ExpName)\n+\n+\t\t// Calling a function with a receiver from C requires\n+\t\t// a Go wrapper function.\n+\t\tif fn.Recv != nil {\n+\t\t\tfmt.Fprintf(fgo2, \"func %s(recv \", goname)\n+\t\t\tconf.Fprint(fgo2, fset, fn.Recv.List[0].Type)\n+\t\t\tforFieldList(fntype.Params,\n+\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\tfmt.Fprintf(fgo2, \", p%d \", i)\n+\t\t\t\t\tconf.Fprint(fgo2, fset, atype)\n+\t\t\t\t})\n+\t\t\tfmt.Fprintf(fgo2, \")\")\n+\t\t\tif gccResult != \"void\" {\n+\t\t\t\tfmt.Fprint(fgo2, \" (\")\n+\t\t\t\tforFieldList(fntype.Results,\n+\t\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\t\tif i > 0 {\n+\t\t\t\t\t\t\tfmt.Fprint(fgo2, \", \")\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tconf.Fprint(fgo2, fset, atype)\n+\t\t\t\t\t})\n+\t\t\t\tfmt.Fprint(fgo2, \")\")\n+\t\t\t}\n+\t\t\tfmt.Fprint(fgo2, \" {\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"\\t\")\n+\t\t\tif gccResult != \"void\" {\n+\t\t\t\tfmt.Fprint(fgo2, \"return \")\n+\t\t\t}\n+\t\t\tfmt.Fprintf(fgo2, \"recv.%s(\", exp.Func.Name)\n+\t\t\tforFieldList(fntype.Params,\n+\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\tif i > 0 {\n+\t\t\t\t\t\tfmt.Fprint(fgo2, \", \")\n+\t\t\t\t\t}\n+\t\t\t\t\tfmt.Fprintf(fgo2, \"p%d\", i)\n+\t\t\t\t})\n+\t\t\tfmt.Fprint(fgo2, \")\\n\")\n+\t\t\tfmt.Fprint(fgo2, \"}\\n\")\n+\t\t}\n+\t}\n+}\n+\n+// Write out the C header allowing C code to call exported gccgo functions.\n+func (p *Package) writeGccgoExports(fgo2, fc, fm *os.File) {\n+\tfgcc := creat(*objDir + \"_cgo_export.c\")\n+\tfgcch := creat(*objDir + \"_cgo_export.h\")\n+\n+\tgccgoSymbolPrefix := p.gccgoSymbolPrefix()\n+\n+\tfmt.Fprintf(fgcch, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n+\tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n+\n+\tfmt.Fprintf(fgcc, \"/* Created by cgo - DO NOT EDIT. */\\n\")\n+\tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\")\n+\n+\tfmt.Fprintf(fm, \"#include \\\"_cgo_export.h\\\"\\n\")\n+\n+\tfor _, exp := range p.ExpFunc {\n+\t\tfn := exp.Func\n+\t\tfntype := fn.Type\n+\n+\t\tcdeclBuf := new(bytes.Buffer)\n+\t\tresultCount := 0\n+\t\tforFieldList(fntype.Results,\n+\t\t\tfunc(i int, atype ast.Expr) { resultCount++ })\n+\t\tswitch resultCount {\n+\t\tcase 0:\n+\t\t\tfmt.Fprintf(cdeclBuf, \"void\")\n+\t\tcase 1:\n+\t\t\tforFieldList(fntype.Results,\n+\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\tt := p.cgoType(atype)\n+\t\t\t\t\tfmt.Fprintf(cdeclBuf, \"%s\", t.C)\n+\t\t\t\t})\n+\t\tdefault:\n+\t\t\t// Declare a result struct.\n+\t\t\tfmt.Fprintf(fgcch, \"struct %s_result {\\n\", exp.ExpName)\n+\t\t\tforFieldList(fntype.Results,\n+\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\tt := p.cgoType(atype)\n+\t\t\t\t\tfmt.Fprintf(fgcch, \"\\t%s r%d;\\n\", t.C, i)\n+\t\t\t\t})\n+\t\t\tfmt.Fprintf(fgcch, \"};\\n\")\n+\t\t\tfmt.Fprintf(cdeclBuf, \"struct %s_result\", exp.ExpName)\n+\t\t}\n+\n+\t\tcRet := cdeclBuf.String()\n+\n+\t\tcdeclBuf = new(bytes.Buffer)\n+\t\tfmt.Fprintf(cdeclBuf, \"(\")\n+\t\tif fn.Recv != nil {\n+\t\t\tfmt.Fprintf(cdeclBuf, \"%s recv\", p.cgoType(fn.Recv.List[0].Type).C.String())\n+\t\t}\n+\t\t// Function parameters.\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tif i > 0 || fn.Recv != nil {\n+\t\t\t\t\tfmt.Fprintf(cdeclBuf, \", \")\n+\t\t\t\t}\n+\t\t\t\tt := p.cgoType(atype)\n+\t\t\t\tfmt.Fprintf(cdeclBuf, \"%s p%d\", t.C, i)\n+\t\t\t})\n+\t\tfmt.Fprintf(cdeclBuf, \")\")\n+\t\tcParams := cdeclBuf.String()\n+\n+\t\t// We need to use a name that will be exported by the\n+\t\t// Go code; otherwise gccgo will make it static and we\n+\t\t// will not be able to link against it from the C\n+\t\t// code.\n+\t\tgoName := \"Cgoexp_\" + exp.ExpName\n+\t\tfmt.Fprintf(fgcch, `extern %s %s %s __asm__(\"%s.%s\");`, cRet, goName, cParams, gccgoSymbolPrefix, goName)\n+\t\tfmt.Fprint(fgcch, \"\\n\")\n+\n+\t\t// Use a #define so that the C code that includes\n+\t\t// cgo_export.h will be able to refer to the Go\n+\t\t// function using the expected name.\n+\t\tfmt.Fprintf(fgcch, \"#define %s %s\\n\", exp.ExpName, goName)\n+\n+\t\t// Use a #undef in _cgo_export.c so that we ignore the\n+\t\t// #define from cgo_export.h, since here we are\n+\t\t// defining the real function.\n+\t\tfmt.Fprintf(fgcc, \"#undef %s\\n\", exp.ExpName)\n+\n+\t\tfmt.Fprint(fgcc, \"\\n\")\n+\t\tfmt.Fprintf(fgcc, \"%s %s %s {\\n\", cRet, exp.ExpName, cParams)\n+\t\tfmt.Fprint(fgcc, \"\\t\")\n+\t\tif resultCount > 0 {\n+\t\t\tfmt.Fprint(fgcc, \"return \")\n+\t\t}\n+\t\tfmt.Fprintf(fgcc, \"%s(\", goName)\n+\t\tif fn.Recv != nil {\n+\t\t\tfmt.Fprint(fgcc, \"recv\")\n+\t\t}\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tif i > 0 || fn.Recv != nil {\n+\t\t\t\t\tfmt.Fprintf(fgcc, \", \")\n+\t\t\t\t}\n+\t\t\t\tfmt.Fprintf(fgcc, \"p%d\", i)\n+\t\t\t})\n+\t\tfmt.Fprint(fgcc, \");\\n\")\n+\t\tfmt.Fprint(fgcc, \"}\\n\")\n+\n+\t\t// Dummy declaration for _cgo_main.c\n+\t\tfmt.Fprintf(fm, \"%s %s %s {}\\n\", cRet, goName, cParams)\n+\n+\t\t// For gccgo we use a wrapper function in Go, in order\n+\t\t// to call CgocallBack and CgocallBackDone.\n+\n+\t\t// This code uses printer.Fprint, not conf.Fprint,\n+\t\t// because we don't want //line comments in the middle\n+\t\t// of the function types.\n+\t\tfmt.Fprint(fgo2, \"\\n\")\n+\t\tfmt.Fprintf(fgo2, \"func %s(\", goName)\n+\t\tif fn.Recv != nil {\n+\t\t\tfmt.Fprint(fgo2, \"recv \")\n+\t\t\tprinter.Fprint(fgo2, fset, fn.Recv.List[0].Type)\n+\t\t}\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tif i > 0 || fn.Recv != nil {\n+\t\t\t\t\tfmt.Fprintf(fgo2, \", \")\n+\t\t\t\t}\n+\t\t\t\tfmt.Fprintf(fgo2, \"p%d \", i)\n+\t\t\t\tprinter.Fprint(fgo2, fset, atype)\n+\t\t\t})\n+\t\tfmt.Fprintf(fgo2, \")\")\n+\t\tif resultCount > 0 {\n+\t\t\tfmt.Fprintf(fgo2, \" (\")\n+\t\t\tforFieldList(fntype.Results,\n+\t\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\t\tif i > 0 {\n+\t\t\t\t\t\tfmt.Fprint(fgo2, \", \")\n+\t\t\t\t\t}\n+\t\t\t\t\tprinter.Fprint(fgo2, fset, atype)\n+\t\t\t\t})\n+\t\t\tfmt.Fprint(fgo2, \")\")\n+\t\t}\n+\t\tfmt.Fprint(fgo2, \" {\\n\")\n+\t\tfmt.Fprint(fgo2, \"\\tsyscall.CgocallBack()\\n\")\n+\t\tfmt.Fprint(fgo2, \"\\tdefer syscall.CgocallBackDone()\\n\")\n+\t\tfmt.Fprint(fgo2, \"\\t\")\n+\t\tif resultCount > 0 {\n+\t\t\tfmt.Fprint(fgo2, \"return \")\n+\t\t}\n+\t\tif fn.Recv != nil {\n+\t\t\tfmt.Fprint(fgo2, \"recv.\")\n+\t\t}\n+\t\tfmt.Fprintf(fgo2, \"%s(\", exp.Func.Name)\n+\t\tforFieldList(fntype.Params,\n+\t\t\tfunc(i int, atype ast.Expr) {\n+\t\t\t\tif i > 0 {\n+\t\t\t\t\tfmt.Fprint(fgo2, \", \")\n+\t\t\t\t}\n+\t\t\t\tfmt.Fprintf(fgo2, \"p%d\", i)\n+\t\t\t})\n+\t\tfmt.Fprint(fgo2, \")\\n\")\n+\t\tfmt.Fprint(fgo2, \"}\\n\")\n+\t}\n+}\n+\n+// Return the package prefix when using gccgo.\n+func (p *Package) gccgoSymbolPrefix() string {\n+\tif !*gccgo {\n+\t\treturn \"\"\n+\t}\n+\n+\tclean := func(r rune) rune {\n+\t\tswitch {\n+\t\tcase 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',\n+\t\t\t'0' <= r && r <= '9':\n+\t\t\treturn r\n+\t\t}\n+\t\treturn '_'\n+\t}\n+\n+\tif *gccgopkgpath != \"\" {\n+\t\treturn strings.Map(clean, *gccgopkgpath)\n+\t}\n+\tif *gccgoprefix == \"\" && p.PackageName == \"main\" {\n+\t\treturn \"main\"\n+\t}\n+\tprefix := strings.Map(clean, *gccgoprefix)\n+\tif prefix == \"\" {\n+\t\tprefix = \"go\"\n+\t}\n+\treturn prefix + \".\" + p.PackageName\n+}\n+\n+// Call a function for each entry in an ast.FieldList, passing the\n+// index into the list and the type.\n+func forFieldList(fl *ast.FieldList, fn func(int, ast.Expr)) {\n+\tif fl == nil {\n+\t\treturn\n+\t}\n+\ti := 0\n+\tfor _, r := range fl.List {\n+\t\tif r.Names == nil {\n+\t\t\tfn(i, r.Type)\n+\t\t\ti++\n+\t\t} else {\n+\t\t\tfor _ = range r.Names {\n+\t\t\t\tfn(i, r.Type)\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func c(repr string, args ...interface{}) *TypeRepr {\n+\treturn &TypeRepr{repr, args}\n+}\n+\n+// Map predeclared Go types to Type.\n+var goTypes = map[string]*Type{\n+\t\"bool\":       {Size: 1, Align: 1, C: c(\"GoUint8\")},\n+\t\"byte\":       {Size: 1, Align: 1, C: c(\"GoUint8\")},\n+\t\"int\":        {Size: 0, Align: 0, C: c(\"GoInt\")},\n+\t\"uint\":       {Size: 0, Align: 0, C: c(\"GoUint\")},\n+\t\"rune\":       {Size: 4, Align: 4, C: c(\"GoInt32\")},\n+\t\"int8\":       {Size: 1, Align: 1, C: c(\"GoInt8\")},\n+\t\"uint8\":      {Size: 1, Align: 1, C: c(\"GoUint8\")},\n+\t\"int16\":      {Size: 2, Align: 2, C: c(\"GoInt16\")},\n+\t\"uint16\":     {Size: 2, Align: 2, C: c(\"GoUint16\")},\n+\t\"int32\":      {Size: 4, Align: 4, C: c(\"GoInt32\")},\n+\t\"uint32\":     {Size: 4, Align: 4, C: c(\"GoUint32\")},\n+\t\"int64\":      {Size: 8, Align: 8, C: c(\"GoInt64\")},\n+\t\"uint64\":     {Size: 8, Align: 8, C: c(\"GoUint64\")},\n+\t\"float32\":    {Size: 4, Align: 4, C: c(\"GoFloat32\")},\n+\t\"float64\":    {Size: 8, Align: 8, C: c(\"GoFloat64\")},\n+\t\"complex64\":  {Size: 8, Align: 8, C: c(\"GoComplex64\")},\n+\t\"complex128\": {Size: 16, Align: 16, C: c(\"GoComplex128\")},\n+}\n+\n+// Map an ast type to a Type.\n+func (p *Package) cgoType(e ast.Expr) *Type {\n+\tswitch t := e.(type) {\n+\tcase *ast.StarExpr:\n+\t\tx := p.cgoType(t.X)\n+\t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"%s*\", x.C)}\n+\tcase *ast.ArrayType:\n+\t\tif t.Len == nil {\n+\t\t\t// Slice: pointer, len, cap.\n+\t\t\treturn &Type{Size: p.PtrSize * 3, Align: p.PtrSize, C: c(\"GoSlice\")}\n+\t\t}\n+\tcase *ast.StructType:\n+\t\t// TODO\n+\tcase *ast.FuncType:\n+\t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"void*\")}\n+\tcase *ast.InterfaceType:\n+\t\treturn &Type{Size: 2 * p.PtrSize, Align: p.PtrSize, C: c(\"GoInterface\")}\n+\tcase *ast.MapType:\n+\t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"GoMap\")}\n+\tcase *ast.ChanType:\n+\t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"GoChan\")}\n+\tcase *ast.Ident:\n+\t\t// Look up the type in the top level declarations.\n+\t\t// TODO: Handle types defined within a function.\n+\t\tfor _, d := range p.Decl {\n+\t\t\tgd, ok := d.(*ast.GenDecl)\n+\t\t\tif !ok || gd.Tok != token.TYPE {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, spec := range gd.Specs {\n+\t\t\t\tts, ok := spec.(*ast.TypeSpec)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif ts.Name.Name == t.Name {\n+\t\t\t\t\treturn p.cgoType(ts.Type)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif def := typedef[t.Name]; def != nil {\n+\t\t\treturn def\n+\t\t}\n+\t\tif t.Name == \"uintptr\" {\n+\t\t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"GoUintptr\")}\n+\t\t}\n+\t\tif t.Name == \"string\" {\n+\t\t\t// The string data is 1 pointer + 1 (pointer-sized) int.\n+\t\t\treturn &Type{Size: 2 * p.PtrSize, Align: p.PtrSize, C: c(\"GoString\")}\n+\t\t}\n+\t\tif t.Name == \"error\" {\n+\t\t\treturn &Type{Size: 2 * p.PtrSize, Align: p.PtrSize, C: c(\"GoInterface\")}\n+\t\t}\n+\t\tif r, ok := goTypes[t.Name]; ok {\n+\t\t\tif r.Size == 0 { // int or uint\n+\t\t\t\trr := new(Type)\n+\t\t\t\t*rr = *r\n+\t\t\t\trr.Size = p.IntSize\n+\t\t\t\trr.Align = p.IntSize\n+\t\t\t\tr = rr\n+\t\t\t}\n+\t\t\tif r.Align > p.PtrSize {\n+\t\t\t\tr.Align = p.PtrSize\n+\t\t\t}\n+\t\t\treturn r\n+\t\t}\n+\t\terror_(e.Pos(), \"unrecognized Go type %s\", t.Name)\n+\t\treturn &Type{Size: 4, Align: 4, C: c(\"int\")}\n+\tcase *ast.SelectorExpr:\n+\t\tid, ok := t.X.(*ast.Ident)\n+\t\tif ok && id.Name == \"unsafe\" && t.Sel.Name == \"Pointer\" {\n+\t\t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"void*\")}\n+\t\t}\n+\t}\n+\terror_(e.Pos(), \"Go type not supported in export: %s\", gofmt(e))\n+\treturn &Type{Size: 4, Align: 4, C: c(\"int\")}\n+}\n+\n+const gccProlog = `\n+// Usual nonsense: if x and y are not equal, the type will be invalid\n+// (have a negative array count) and an inscrutable error will come\n+// out of the compiler and hopefully mention \"name\".\n+#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];\n+\n+// Check at compile time that the sizes we use match our expectations.\n+#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)\n+\n+__cgo_size_assert(char, 1)\n+__cgo_size_assert(short, 2)\n+__cgo_size_assert(int, 4)\n+typedef long long __cgo_long_long;\n+__cgo_size_assert(__cgo_long_long, 8)\n+__cgo_size_assert(float, 4)\n+__cgo_size_assert(double, 8)\n+\n+#include <errno.h>\n+#include <string.h>\n+`\n+\n+const builtinProlog = `\n+#include <sys/types.h> /* for size_t below */\n+\n+/* Define intgo when compiling with GCC.  */\n+#ifdef __PTRDIFF_TYPE__\n+typedef __PTRDIFF_TYPE__ intgo;\n+#elif defined(_LP64)\n+typedef long long intgo;\n+#else\n+typedef int intgo;\n+#endif\n+\n+typedef struct { char *p; intgo n; } _GoString_;\n+typedef struct { char *p; intgo n; intgo c; } _GoBytes_;\n+_GoString_ GoString(char *p);\n+_GoString_ GoStringN(char *p, int l);\n+_GoBytes_ GoBytes(void *p, int n);\n+char *CString(_GoString_);\n+void *_CMalloc(size_t);\n+`\n+\n+const cProlog = `\n+#include \"runtime.h\"\n+#include \"cgocall.h\"\n+\n+void \u00b7_Cerrno(void*, int32);\n+\n+void\n+\u00b7_Cfunc_GoString(int8 *p, String s)\n+{\n+\ts = runtime\u00b7gostring((byte*)p);\n+\tFLUSH(&s);\n+}\n+\n+void\n+\u00b7_Cfunc_GoStringN(int8 *p, int32 l, String s)\n+{\n+\ts = runtime\u00b7gostringn((byte*)p, l);\n+\tFLUSH(&s);\n+}\n+\n+void\n+\u00b7_Cfunc_GoBytes(int8 *p, int32 l, Slice s)\n+{\n+\ts = runtime\u00b7gobytes((byte*)p, l);\n+\tFLUSH(&s);\n+}\n+\n+void\n+\u00b7_Cfunc_CString(String s, int8 *p)\n+{\n+\tp = runtime\u00b7cmalloc(s.len+1);\n+\truntime\u00b7memmove((byte*)p, s.str, s.len);\n+\tp[s.len] = 0;\n+\tFLUSH(&p);\n+}\n+\n+void\n+\u00b7_Cfunc__CMalloc(uintptr n, int8 *p)\n+{\n+\tp = runtime\u00b7cmalloc(n);\n+\tFLUSH(&p);\n+}\n+`\n+\n+func (p *Package) cPrologGccgo() string {\n+\treturn strings.Replace(cPrologGccgo, \"PREFIX\", cPrefix, -1)\n+}\n+\n+const cPrologGccgo = `\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+typedef unsigned char byte;\n+typedef intptr_t intgo;\n+\n+struct __go_string {\n+\tconst unsigned char *__data;\n+\tintgo __length;\n+};\n+\n+typedef struct __go_open_array {\n+\tvoid* __values;\n+\tintgo __count;\n+\tintgo __capacity;\n+} Slice;\n+\n+struct __go_string __go_byte_array_to_string(const void* p, intgo len);\n+struct __go_open_array __go_string_to_byte_array (struct __go_string str);\n+\n+const char *_cgoPREFIX_Cfunc_CString(struct __go_string s) {\n+\tchar *p = malloc(s.__length+1);\n+\tmemmove(p, s.__data, s.__length);\n+\tp[s.__length] = 0;\n+\treturn p;\n+}\n+\n+struct __go_string _cgoPREFIX_Cfunc_GoString(char *p) {\n+\tintgo len = (p != NULL) ? strlen(p) : 0;\n+\treturn __go_byte_array_to_string(p, len);\n+}\n+\n+struct __go_string _cgoPREFIX_Cfunc_GoStringN(char *p, int32_t n) {\n+\treturn __go_byte_array_to_string(p, n);\n+}\n+\n+Slice _cgoPREFIX_Cfunc_GoBytes(char *p, int32_t n) {\n+\tstruct __go_string s = { (const unsigned char *)p, n };\n+\treturn __go_string_to_byte_array(s);\n+}\n+\n+extern void runtime_throw(const char *);\n+void *_cgoPREFIX_Cfunc__CMalloc(size_t n) {\n+        void *p = malloc(n);\n+        if(p == NULL && n == 0)\n+                p = malloc(1);\n+        if(p == NULL)\n+                runtime_throw(\"runtime: C malloc failed\");\n+        return p;\n+}\n+`\n+\n+func (p *Package) gccExportHeaderProlog() string {\n+\treturn strings.Replace(gccExportHeaderProlog, \"GOINTBITS\", fmt.Sprint(8*p.IntSize), -1)\n+}\n+\n+const gccExportHeaderProlog = `\n+typedef signed char GoInt8;\n+typedef unsigned char GoUint8;\n+typedef short GoInt16;\n+typedef unsigned short GoUint16;\n+typedef int GoInt32;\n+typedef unsigned int GoUint32;\n+typedef long long GoInt64;\n+typedef unsigned long long GoUint64;\n+typedef GoIntGOINTBITS GoInt;\n+typedef GoUintGOINTBITS GoUint;\n+typedef __SIZE_TYPE__ GoUintptr;\n+typedef float GoFloat32;\n+typedef double GoFloat64;\n+typedef __complex float GoComplex64;\n+typedef __complex double GoComplex128;\n+\n+typedef struct { char *p; GoInt n; } GoString;\n+typedef void *GoMap;\n+typedef void *GoChan;\n+typedef struct { void *t; void *v; } GoInterface;\n+typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;\n+`"}, {"sha": "4e7800d12722148525f6811825dc460b23361cc2", "filename": "libgo/go/cmd/cgo/util.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Futil.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"os/exec\"\n+)\n+\n+// run runs the command argv, feeding in stdin on standard input.\n+// It returns the output to standard output and standard error.\n+// ok indicates whether the command exited successfully.\n+func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {\n+\tp := exec.Command(argv[0], argv[1:]...)\n+\tp.Stdin = bytes.NewReader(stdin)\n+\tvar bout, berr bytes.Buffer\n+\tp.Stdout = &bout\n+\tp.Stderr = &berr\n+\terr := p.Run()\n+\tif _, ok := err.(*exec.ExitError); err != nil && !ok {\n+\t\tfatalf(\"%s\", err)\n+\t}\n+\tok = p.ProcessState.Success()\n+\tstdout, stderr = bout.Bytes(), berr.Bytes()\n+\treturn\n+}\n+\n+func lineno(pos token.Pos) string {\n+\treturn fset.Position(pos).String()\n+}\n+\n+// Die with an error message.\n+func fatalf(msg string, args ...interface{}) {\n+\t// If we've already printed other errors, they might have\n+\t// caused the fatal condition.  Assume they're enough.\n+\tif nerrors == 0 {\n+\t\tfmt.Fprintf(os.Stderr, msg+\"\\n\", args...)\n+\t}\n+\tos.Exit(2)\n+}\n+\n+var nerrors int\n+\n+func error_(pos token.Pos, msg string, args ...interface{}) {\n+\tnerrors++\n+\tif pos.IsValid() {\n+\t\tfmt.Fprintf(os.Stderr, \"%s: \", fset.Position(pos).String())\n+\t}\n+\tfmt.Fprintf(os.Stderr, msg, args...)\n+\tfmt.Fprintf(os.Stderr, \"\\n\")\n+}\n+\n+// isName returns true if s is a valid C identifier\n+func isName(s string) bool {\n+\tfor i, v := range s {\n+\t\tif v != '_' && (v < 'A' || v > 'Z') && (v < 'a' || v > 'z') && (v < '0' || v > '9') {\n+\t\t\treturn false\n+\t\t}\n+\t\tif i == 0 && '0' <= v && v <= '9' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn s != \"\"\n+}\n+\n+func creat(name string) *os.File {\n+\tf, err := os.Create(name)\n+\tif err != nil {\n+\t\tfatalf(\"%s\", err)\n+\t}\n+\treturn f\n+}\n+\n+func slashToUnderscore(c rune) rune {\n+\tif c == '/' || c == '\\\\' || c == ':' {\n+\t\tc = '_'\n+\t}\n+\treturn c\n+}"}, {"sha": "dc7ed5f4c0689af7c2f666db03503012615e2f3b", "filename": "libgo/go/cmd/go/bootstrap.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbootstrap.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build cmd_go_bootstrap\n+\n+// This code is compiled only into the bootstrap 'go' binary.\n+// These stubs avoid importing packages with large dependency\n+// trees, like the use of \"net/http\" in vcs.go.\n+\n+package main\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+)\n+\n+var errHTTP = errors.New(\"no http in bootstrap go command\")\n+\n+func httpGET(url string) ([]byte, error) {\n+\treturn nil, errHTTP\n+}\n+\n+func httpsOrHTTP(importPath string) (string, io.ReadCloser, error) {\n+\treturn \"\", nil, errHTTP\n+}\n+\n+func parseMetaGoImports(r io.Reader) ([]metaImport, error) {\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "c9957930a12e062a0aa02ef768684dcc502cf8fb", "filename": "libgo/go/cmd/go/build.go", "status": "added", "additions": 2594, "deletions": 0, "changes": 2594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,2594 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"container/heap\"\n+\t\"errors\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+var cmdBuild = &Command{\n+\tUsageLine: \"build [-o output] [-i] [build flags] [packages]\",\n+\tShort:     \"compile packages and dependencies\",\n+\tLong: `\n+Build compiles the packages named by the import paths,\n+along with their dependencies, but it does not install the results.\n+\n+If the arguments are a list of .go files, build treats them as a list\n+of source files specifying a single package.\n+\n+When the command line specifies a single main package,\n+build writes the resulting executable to output.\n+Otherwise build compiles the packages but discards the results,\n+serving only as a check that the packages can be built.\n+\n+The -o flag specifies the output file name. If not specified, the\n+output file name depends on the arguments and derives from the name\n+of the package, such as p.a for package p, unless p is 'main'. If\n+the package is main and file names are provided, the file name\n+derives from the first file name mentioned, such as f1 for 'go build\n+f1.go f2.go'; with no files provided ('go build'), the output file\n+name is the base name of the containing directory.\n+\n+The -i flag installs the packages that are dependencies of the target.\n+\n+The build flags are shared by the build, clean, get, install, list, run,\n+and test commands:\n+\n+\t-a\n+\t\tforce rebuilding of packages that are already up-to-date.\n+\t-n\n+\t\tprint the commands but do not run them.\n+\t-p n\n+\t\tthe number of builds that can be run in parallel.\n+\t\tThe default is the number of CPUs available.\n+\t-race\n+\t\tenable data race detection.\n+\t\tSupported only on linux/amd64, darwin/amd64 and windows/amd64.\n+\t-v\n+\t\tprint the names of packages as they are compiled.\n+\t-work\n+\t\tprint the name of the temporary work directory and\n+\t\tdo not delete it when exiting.\n+\t-x\n+\t\tprint the commands.\n+\n+\t-ccflags 'arg list'\n+\t\targuments to pass on each 5c, 6c, or 8c compiler invocation.\n+\t-compiler name\n+\t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n+\t-gccgoflags 'arg list'\n+\t\targuments to pass on each gccgo compiler/linker invocation.\n+\t-gcflags 'arg list'\n+\t\targuments to pass on each 5g, 6g, or 8g compiler invocation.\n+\t-installsuffix suffix\n+\t\ta suffix to use in the name of the package installation directory,\n+\t\tin order to keep output separate from default builds.\n+\t\tIf using the -race flag, the install suffix is automatically set to race\n+\t\tor, if set explicitly, has _race appended to it.\n+\t-ldflags 'flag list'\n+\t\targuments to pass on each 5l, 6l, or 8l linker invocation.\n+\t-tags 'tag list'\n+\t\ta list of build tags to consider satisfied during the build.\n+\t\tFor more information about build tags, see the description of\n+\t\tbuild constraints in the documentation for the go/build package.\n+\n+The list flags accept a space-separated list of strings. To embed spaces\n+in an element in the list, surround it with either single or double quotes.\n+\n+For more about specifying packages, see 'go help packages'.\n+For more about where packages and binaries are installed,\n+run 'go help gopath'.  For more about calling between Go and C/C++,\n+run 'go help c'.\n+\n+See also: go install, go get, go clean.\n+\t`,\n+}\n+\n+func init() {\n+\t// break init cycle\n+\tcmdBuild.Run = runBuild\n+\tcmdInstall.Run = runInstall\n+\n+\tcmdBuild.Flag.BoolVar(&buildI, \"i\", false, \"\")\n+\n+\taddBuildFlags(cmdBuild)\n+\taddBuildFlags(cmdInstall)\n+}\n+\n+// Flags set by multiple commands.\n+var buildA bool               // -a flag\n+var buildN bool               // -n flag\n+var buildP = runtime.NumCPU() // -p flag\n+var buildV bool               // -v flag\n+var buildX bool               // -x flag\n+var buildI bool               // -i flag\n+var buildO = cmdBuild.Flag.String(\"o\", \"\", \"output file\")\n+var buildWork bool           // -work flag\n+var buildGcflags []string    // -gcflags flag\n+var buildCcflags []string    // -ccflags flag\n+var buildLdflags []string    // -ldflags flag\n+var buildGccgoflags []string // -gccgoflags flag\n+var buildRace bool           // -race flag\n+\n+var reqPkgSrc bool           // req src for Imports\n+var buildContext = build.Default\n+var buildToolchain toolchain = noToolchain{}\n+\n+// buildCompiler implements flag.Var.\n+// It implements Set by updating both\n+// buildToolchain and buildContext.Compiler.\n+type buildCompiler struct{}\n+\n+func (c buildCompiler) Set(value string) error {\n+\tswitch value {\n+\tcase \"gc\":\n+\t\tbuildToolchain = gcToolchain{}\n+\tcase \"gccgo\":\n+\t\tbuildToolchain = gccgoToolchain{}\n+\tdefault:\n+\t\treturn fmt.Errorf(\"unknown compiler %q\", value)\n+\t}\n+\tbuildContext.Compiler = value\n+\treturn nil\n+}\n+\n+func (c buildCompiler) String() string {\n+\treturn buildContext.Compiler\n+}\n+\n+func init() {\n+\tswitch build.Default.Compiler {\n+\tcase \"gc\":\n+\t\tbuildToolchain = gcToolchain{}\n+\tcase \"gccgo\":\n+\t\tbuildToolchain = gccgoToolchain{}\n+\t}\n+}\n+\n+// addBuildFlags adds the flags common to the build, clean, get,\n+// install, list, run, and test commands.\n+func addBuildFlags(cmd *Command) {\n+\t// NOTE: If you add flags here, also add them to testflag.go.\n+\tcmd.Flag.BoolVar(&buildA, \"a\", false, \"\")\n+\tcmd.Flag.BoolVar(&buildN, \"n\", false, \"\")\n+\tcmd.Flag.IntVar(&buildP, \"p\", buildP, \"\")\n+\tcmd.Flag.StringVar(&buildContext.InstallSuffix, \"installsuffix\", \"\", \"\")\n+\tcmd.Flag.BoolVar(&buildV, \"v\", false, \"\")\n+\tcmd.Flag.BoolVar(&buildX, \"x\", false, \"\")\n+\tcmd.Flag.BoolVar(&buildWork, \"work\", false, \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildGcflags), \"gcflags\", \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildCcflags), \"ccflags\", \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildLdflags), \"ldflags\", \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildGccgoflags), \"gccgoflags\", \"\")\n+\tcmd.Flag.Var((*stringsFlag)(&buildContext.BuildTags), \"tags\", \"\")\n+\tcmd.Flag.Var(buildCompiler{}, \"compiler\", \"\")\n+\tcmd.Flag.BoolVar(&buildRace, \"race\", false, \"\")\n+\tswitch build.Default.Compiler {\n+\tcase \"gc\":\n+\t\treqPkgSrc = true\n+\tcase \"gccgo\":\n+\t\treqPkgSrc = false\n+\t}\n+}\n+\n+func addBuildFlagsNX(cmd *Command) {\n+\tcmd.Flag.BoolVar(&buildN, \"n\", false, \"\")\n+\tcmd.Flag.BoolVar(&buildX, \"x\", false, \"\")\n+}\n+\n+func isSpaceByte(c byte) bool {\n+\treturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'\n+}\n+\n+// fileExtSplit expects a filename and returns the name\n+// and ext (without the dot). If the file has no\n+// extension, ext will be empty.\n+func fileExtSplit(file string) (name, ext string) {\n+\tdotExt := filepath.Ext(file)\n+\tname = file[:len(file)-len(dotExt)]\n+\tif dotExt != \"\" {\n+\t\text = dotExt[1:]\n+\t}\n+\treturn\n+}\n+\n+type stringsFlag []string\n+\n+func (v *stringsFlag) Set(s string) error {\n+\tvar err error\n+\t*v, err = splitQuotedFields(s)\n+\tif *v == nil {\n+\t\t*v = []string{}\n+\t}\n+\treturn err\n+}\n+\n+func splitQuotedFields(s string) ([]string, error) {\n+\t// Split fields allowing '' or \"\" around elements.\n+\t// Quotes further inside the string do not count.\n+\tvar f []string\n+\tfor len(s) > 0 {\n+\t\tfor len(s) > 0 && isSpaceByte(s[0]) {\n+\t\t\ts = s[1:]\n+\t\t}\n+\t\tif len(s) == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\t// Accepted quoted string. No unescaping inside.\n+\t\tif s[0] == '\"' || s[0] == '\\'' {\n+\t\t\tquote := s[0]\n+\t\t\ts = s[1:]\n+\t\t\ti := 0\n+\t\t\tfor i < len(s) && s[i] != quote {\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t\tif i >= len(s) {\n+\t\t\t\treturn nil, fmt.Errorf(\"unterminated %c string\", quote)\n+\t\t\t}\n+\t\t\tf = append(f, s[:i])\n+\t\t\ts = s[i+1:]\n+\t\t\tcontinue\n+\t\t}\n+\t\ti := 0\n+\t\tfor i < len(s) && !isSpaceByte(s[i]) {\n+\t\t\ti++\n+\t\t}\n+\t\tf = append(f, s[:i])\n+\t\ts = s[i:]\n+\t}\n+\treturn f, nil\n+}\n+\n+func (v *stringsFlag) String() string {\n+\treturn \"<stringsFlag>\"\n+}\n+\n+func runBuild(cmd *Command, args []string) {\n+\traceInit()\n+\tvar b builder\n+\tb.init()\n+\n+\tpkgs := packagesForBuild(args)\n+\n+\tif len(pkgs) == 1 && pkgs[0].Name == \"main\" && *buildO == \"\" {\n+\t\t_, *buildO = path.Split(pkgs[0].ImportPath)\n+\t\t*buildO += exeSuffix\n+\t}\n+\n+\t// sanity check some often mis-used options\n+\tswitch buildContext.Compiler {\n+\tcase \"gccgo\":\n+\t\tif len(buildGcflags) != 0 {\n+\t\t\tfmt.Println(\"go build: when using gccgo toolchain, please pass compiler flags using -gccgoflags, not -gcflags\")\n+\t\t}\n+\t\tif len(buildLdflags) != 0 {\n+\t\t\tfmt.Println(\"go build: when using gccgo toolchain, please pass linker flags using -gccgoflags, not -ldflags\")\n+\t\t}\n+\tcase \"gc\":\n+\t\tif len(buildGccgoflags) != 0 {\n+\t\t\tfmt.Println(\"go build: when using gc toolchain, please pass compile flags using -gcflags, and linker flags using -ldflags\")\n+\t\t}\n+\t}\n+\n+\tif *buildO != \"\" {\n+\t\tif len(pkgs) > 1 {\n+\t\t\tfatalf(\"go build: cannot use -o with multiple packages\")\n+\t\t}\n+\t\tp := pkgs[0]\n+\t\tp.target = \"\" // must build - not up to date\n+\t\ta := b.action(modeInstall, modeBuild, p)\n+\t\ta.target = *buildO\n+\t\tb.do(a)\n+\t\treturn\n+\t}\n+\n+\ta := &action{}\n+\tdepMode := modeBuild\n+\tif buildI {\n+\t\tdepMode = modeInstall\n+\t}\n+\tfor _, p := range packages(args) {\n+\t\ta.deps = append(a.deps, b.action(modeBuild, depMode, p))\n+\t}\n+\tb.do(a)\n+}\n+\n+var cmdInstall = &Command{\n+\tUsageLine: \"install [build flags] [packages]\",\n+\tShort:     \"compile and install packages and dependencies\",\n+\tLong: `\n+Install compiles and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+For more about the build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go get, go clean.\n+\t`,\n+}\n+\n+func runInstall(cmd *Command, args []string) {\n+\traceInit()\n+\tpkgs := packagesForBuild(args)\n+\n+\tfor _, p := range pkgs {\n+\t\tif p.Target == \"\" && (!p.Standard || p.ImportPath != \"unsafe\") {\n+\t\t\tif p.cmdline {\n+\t\t\t\terrorf(\"go install: no install location for .go files listed on command line (GOBIN not set)\")\n+\t\t\t} else if p.ConflictDir != \"\" {\n+\t\t\t\terrorf(\"go install: no install location for %s: hidden by %s\", p.Dir, p.ConflictDir)\n+\t\t\t} else {\n+\t\t\t\terrorf(\"go install: no install location for directory %s outside GOPATH\", p.Dir)\n+\t\t\t}\n+\t\t}\n+\t}\n+\texitIfErrors()\n+\n+\tvar b builder\n+\tb.init()\n+\ta := &action{}\n+\tfor _, p := range pkgs {\n+\t\ta.deps = append(a.deps, b.action(modeInstall, modeInstall, p))\n+\t}\n+\tb.do(a)\n+}\n+\n+// Global build parameters (used during package load)\n+var (\n+\tgoarch    string\n+\tgoos      string\n+\tarchChar  string\n+\texeSuffix string\n+)\n+\n+func init() {\n+\tgoarch = buildContext.GOARCH\n+\tgoos = buildContext.GOOS\n+\tif goos == \"windows\" {\n+\t\texeSuffix = \".exe\"\n+\t}\n+\tvar err error\n+\tarchChar, err = build.ArchChar(goarch)\n+\tif err != nil {\n+\t\tif _, isgc := buildToolchain.(gcToolchain); isgc {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\t// archChar is only required for gcToolchain, if we're using\n+\t\t// another toolchain leave it blank.\n+\t\tarchChar = \"\"\n+\t}\n+}\n+\n+// A builder holds global state about a build.\n+// It does not hold per-package state, because we\n+// build packages in parallel, and the builder is shared.\n+type builder struct {\n+\twork        string               // the temporary work directory (ends in filepath.Separator)\n+\tactionCache map[cacheKey]*action // a cache of already-constructed actions\n+\tmkdirCache  map[string]bool      // a cache of created directories\n+\tprint       func(args ...interface{}) (int, error)\n+\n+\toutput    sync.Mutex\n+\tscriptDir string // current directory in printed script\n+\n+\texec      sync.Mutex\n+\treadySema chan bool\n+\tready     actionQueue\n+}\n+\n+// An action represents a single action in the action graph.\n+type action struct {\n+\tp          *Package      // the package this action works on\n+\tdeps       []*action     // actions that must happen before this one\n+\ttriggers   []*action     // inverse of deps\n+\tcgo        *action       // action for cgo binary if needed\n+\targs       []string      // additional args for runProgram\n+\ttestOutput *bytes.Buffer // test output buffer\n+\n+\tf          func(*builder, *action) error // the action itself (nil = no-op)\n+\tignoreFail bool                          // whether to run f even if dependencies fail\n+\n+\t// Generated files, directories.\n+\tlink   bool   // target is executable, not just package\n+\tpkgdir string // the -I or -L argument to use when importing this package\n+\tobjdir string // directory for intermediate objects\n+\tobjpkg string // the intermediate package .a file created during the action\n+\ttarget string // goal of the action: the created package or executable\n+\n+\t// Execution state.\n+\tpending  int  // number of deps yet to complete\n+\tpriority int  // relative execution priority\n+\tfailed   bool // whether the action failed\n+}\n+\n+// cacheKey is the key for the action cache.\n+type cacheKey struct {\n+\tmode buildMode\n+\tp    *Package\n+}\n+\n+// buildMode specifies the build mode:\n+// are we just building things or also installing the results?\n+type buildMode int\n+\n+const (\n+\tmodeBuild buildMode = iota\n+\tmodeInstall\n+)\n+\n+var (\n+\tgoroot       = filepath.Clean(runtime.GOROOT())\n+\tgobin        = os.Getenv(\"GOBIN\")\n+\tgorootBin    = filepath.Join(goroot, \"bin\")\n+\tgorootSrcPkg = filepath.Join(goroot, \"src/pkg\")\n+\tgorootPkg    = filepath.Join(goroot, \"pkg\")\n+\tgorootSrc    = filepath.Join(goroot, \"src\")\n+)\n+\n+func (b *builder) init() {\n+\tvar err error\n+\tb.print = func(a ...interface{}) (int, error) {\n+\t\treturn fmt.Fprint(os.Stderr, a...)\n+\t}\n+\tb.actionCache = make(map[cacheKey]*action)\n+\tb.mkdirCache = make(map[string]bool)\n+\n+\tif buildN {\n+\t\tb.work = \"$WORK\"\n+\t} else {\n+\t\tb.work, err = ioutil.TempDir(\"\", \"go-build\")\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tif buildX || buildWork {\n+\t\t\tfmt.Fprintf(os.Stderr, \"WORK=%s\\n\", b.work)\n+\t\t}\n+\t\tif !buildWork {\n+\t\t\tworkdir := b.work\n+\t\t\tatexit(func() { os.RemoveAll(workdir) })\n+\t\t}\n+\t}\n+}\n+\n+// goFilesPackage creates a package for building a collection of Go files\n+// (typically named on the command line).  The target is named p.a for\n+// package p or named after the first Go file for package main.\n+func goFilesPackage(gofiles []string) *Package {\n+\t// TODO: Remove this restriction.\n+\tfor _, f := range gofiles {\n+\t\tif !strings.HasSuffix(f, \".go\") {\n+\t\t\tfatalf(\"named files must be .go files\")\n+\t\t}\n+\t}\n+\n+\tvar stk importStack\n+\tctxt := buildContext\n+\tctxt.UseAllFiles = true\n+\n+\t// Synthesize fake \"directory\" that only shows the named files,\n+\t// to make it look like this is a standard package or\n+\t// command directory.  So that local imports resolve\n+\t// consistently, the files must all be in the same directory.\n+\tvar dirent []os.FileInfo\n+\tvar dir string\n+\tfor _, file := range gofiles {\n+\t\tfi, err := os.Stat(file)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tif fi.IsDir() {\n+\t\t\tfatalf(\"%s is a directory, should be a Go file\", file)\n+\t\t}\n+\t\tdir1, _ := filepath.Split(file)\n+\t\tif dir == \"\" {\n+\t\t\tdir = dir1\n+\t\t} else if dir != dir1 {\n+\t\t\tfatalf(\"named files must all be in one directory; have %s and %s\", dir, dir1)\n+\t\t}\n+\t\tdirent = append(dirent, fi)\n+\t}\n+\tctxt.ReadDir = func(string) ([]os.FileInfo, error) { return dirent, nil }\n+\n+\tif !filepath.IsAbs(dir) {\n+\t\tdir = filepath.Join(cwd, dir)\n+\t}\n+\n+\tbp, err := ctxt.ImportDir(dir, 0)\n+\tpkg := new(Package)\n+\tpkg.local = true\n+\tpkg.cmdline = true\n+\tpkg.load(&stk, bp, err)\n+\tpkg.localPrefix = dirToImportPath(dir)\n+\tpkg.ImportPath = \"command-line-arguments\"\n+\tpkg.target = \"\"\n+\n+\tif pkg.Name == \"main\" {\n+\t\t_, elem := filepath.Split(gofiles[0])\n+\t\texe := elem[:len(elem)-len(\".go\")] + exeSuffix\n+\t\tif *buildO == \"\" {\n+\t\t\t*buildO = exe\n+\t\t}\n+\t\tif gobin != \"\" {\n+\t\t\tpkg.target = filepath.Join(gobin, exe)\n+\t\t}\n+\t} else {\n+\t\tif *buildO == \"\" {\n+\t\t\t*buildO = pkg.Name + \".a\"\n+\t\t}\n+\t}\n+\tpkg.Target = pkg.target\n+\tpkg.Stale = true\n+\n+\tcomputeStale(pkg)\n+\treturn pkg\n+}\n+\n+// action returns the action for applying the given operation (mode) to the package.\n+// depMode is the action to use when building dependencies.\n+func (b *builder) action(mode buildMode, depMode buildMode, p *Package) *action {\n+\tkey := cacheKey{mode, p}\n+\ta := b.actionCache[key]\n+\tif a != nil {\n+\t\treturn a\n+\t}\n+\n+\ta = &action{p: p, pkgdir: p.build.PkgRoot}\n+\tif p.pkgdir != \"\" { // overrides p.t\n+\t\ta.pkgdir = p.pkgdir\n+\t}\n+\n+\tb.actionCache[key] = a\n+\n+\tfor _, p1 := range p.imports {\n+\t\ta.deps = append(a.deps, b.action(depMode, depMode, p1))\n+\t}\n+\n+\t// If we are not doing a cross-build, then record the binary we'll\n+\t// generate for cgo as a dependency of the build of any package\n+\t// using cgo, to make sure we do not overwrite the binary while\n+\t// a package is using it.  If this is a cross-build, then the cgo we\n+\t// are writing is not the cgo we need to use.\n+\n+\tif goos == runtime.GOOS && goarch == runtime.GOARCH && !buildRace {\n+\t\tif reqPkgSrc {\n+\t\t\tif len(p.CgoFiles) > 0 || p.Standard && p.ImportPath == \"runtime/cgo\" {\n+\t\t\t\tvar stk importStack\n+\t\t\t\tp1 := loadPackage(\"cmd/cgo\", &stk)\n+\t\t\t\tif p1.Error != nil {\n+\t\t\t\t\tfatalf(\"load cmd/cgo: %v\", p1.Error)\n+\t\t\t\t}\n+\t\t\t\ta.cgo = b.action(depMode, depMode, p1)\n+\t\t\t\ta.deps = append(a.deps, a.cgo)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif p.Standard {\n+\t\tswitch p.ImportPath {\n+\t\tcase \"builtin\", \"unsafe\":\n+\t\t\t// Fake packages - nothing to build.\n+\t\t\treturn a\n+\t\t}\n+\t\t// gccgo standard library is \"fake\" too.\n+\t\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n+\t\t\t// the target name is needed for cgo.\n+\t\t\ta.target = p.target\n+\t\t\treturn a\n+\t\t}\n+\t}\n+\n+\tif !p.Stale && p.target != \"\" {\n+\t\t// p.Stale==false implies that p.target is up-to-date.\n+\t\t// Record target name for use by actions depending on this one.\n+\t\ta.target = p.target\n+\t\treturn a\n+\t}\n+\n+\tif p.local && p.target == \"\" {\n+\t\t// Imported via local path.  No permanent target.\n+\t\tmode = modeBuild\n+\t}\n+\twork := p.pkgdir\n+\tif work == \"\" {\n+\t\twork = b.work\n+\t}\n+\ta.objdir = filepath.Join(work, a.p.ImportPath, \"_obj\") + string(filepath.Separator)\n+\ta.objpkg = buildToolchain.pkgpath(work, a.p)\n+\ta.link = p.Name == \"main\"\n+\n+\tswitch mode {\n+\tcase modeInstall:\n+\t\ta.f = (*builder).install\n+\t\ta.deps = []*action{b.action(modeBuild, depMode, p)}\n+\t\ta.target = a.p.target\n+\tcase modeBuild:\n+\t\ta.f = (*builder).build\n+\t\ta.target = a.objpkg\n+\t\tif a.link {\n+\t\t\t// An executable file. (This is the name of a temporary file.)\n+\t\t\t// Because we run the temporary file in 'go run' and 'go test',\n+\t\t\t// the name will show up in ps listings. If the caller has specified\n+\t\t\t// a name, use that instead of a.out. The binary is generated\n+\t\t\t// in an otherwise empty subdirectory named exe to avoid\n+\t\t\t// naming conflicts.  The only possible conflict is if we were\n+\t\t\t// to create a top-level package named exe.\n+\t\t\tname := \"a.out\"\n+\t\t\tif p.exeName != \"\" {\n+\t\t\t\tname = p.exeName\n+\t\t\t}\n+\t\t\ta.target = a.objdir + filepath.Join(\"exe\", name) + exeSuffix\n+\t\t}\n+\t}\n+\n+\treturn a\n+}\n+\n+// actionList returns the list of actions in the dag rooted at root\n+// as visited in a depth-first post-order traversal.\n+func actionList(root *action) []*action {\n+\tseen := map[*action]bool{}\n+\tall := []*action{}\n+\tvar walk func(*action)\n+\twalk = func(a *action) {\n+\t\tif seen[a] {\n+\t\t\treturn\n+\t\t}\n+\t\tseen[a] = true\n+\t\tfor _, a1 := range a.deps {\n+\t\t\twalk(a1)\n+\t\t}\n+\t\tall = append(all, a)\n+\t}\n+\twalk(root)\n+\treturn all\n+}\n+\n+// do runs the action graph rooted at root.\n+func (b *builder) do(root *action) {\n+\t// Build list of all actions, assigning depth-first post-order priority.\n+\t// The original implementation here was a true queue\n+\t// (using a channel) but it had the effect of getting\n+\t// distracted by low-level leaf actions to the detriment\n+\t// of completing higher-level actions.  The order of\n+\t// work does not matter much to overall execution time,\n+\t// but when running \"go test std\" it is nice to see each test\n+\t// results as soon as possible.  The priorities assigned\n+\t// ensure that, all else being equal, the execution prefers\n+\t// to do what it would have done first in a simple depth-first\n+\t// dependency order traversal.\n+\tall := actionList(root)\n+\tfor i, a := range all {\n+\t\ta.priority = i\n+\t}\n+\n+\tb.readySema = make(chan bool, len(all))\n+\n+\t// Initialize per-action execution state.\n+\tfor _, a := range all {\n+\t\tfor _, a1 := range a.deps {\n+\t\t\ta1.triggers = append(a1.triggers, a)\n+\t\t}\n+\t\ta.pending = len(a.deps)\n+\t\tif a.pending == 0 {\n+\t\t\tb.ready.push(a)\n+\t\t\tb.readySema <- true\n+\t\t}\n+\t}\n+\n+\t// Handle runs a single action and takes care of triggering\n+\t// any actions that are runnable as a result.\n+\thandle := func(a *action) {\n+\t\tvar err error\n+\t\tif a.f != nil && (!a.failed || a.ignoreFail) {\n+\t\t\terr = a.f(b, a)\n+\t\t}\n+\n+\t\t// The actions run in parallel but all the updates to the\n+\t\t// shared work state are serialized through b.exec.\n+\t\tb.exec.Lock()\n+\t\tdefer b.exec.Unlock()\n+\n+\t\tif err != nil {\n+\t\t\tif err == errPrintedOutput {\n+\t\t\t\tsetExitStatus(2)\n+\t\t\t} else {\n+\t\t\t\terrorf(\"%s\", err)\n+\t\t\t}\n+\t\t\ta.failed = true\n+\t\t}\n+\n+\t\tfor _, a0 := range a.triggers {\n+\t\t\tif a.failed {\n+\t\t\t\ta0.failed = true\n+\t\t\t}\n+\t\t\tif a0.pending--; a0.pending == 0 {\n+\t\t\t\tb.ready.push(a0)\n+\t\t\t\tb.readySema <- true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif a == root {\n+\t\t\tclose(b.readySema)\n+\t\t}\n+\t}\n+\n+\tvar wg sync.WaitGroup\n+\n+\t// Kick off goroutines according to parallelism.\n+\t// If we are using the -n flag (just printing commands)\n+\t// drop the parallelism to 1, both to make the output\n+\t// deterministic and because there is no real work anyway.\n+\tpar := buildP\n+\tif buildN {\n+\t\tpar = 1\n+\t}\n+\tfor i := 0; i < par; i++ {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase _, ok := <-b.readySema:\n+\t\t\t\t\tif !ok {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\t// Receiving a value from b.readySema entitles\n+\t\t\t\t\t// us to take from the ready queue.\n+\t\t\t\t\tb.exec.Lock()\n+\t\t\t\t\ta := b.ready.pop()\n+\t\t\t\t\tb.exec.Unlock()\n+\t\t\t\t\thandle(a)\n+\t\t\t\tcase <-interrupted:\n+\t\t\t\t\tsetExitStatus(1)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\twg.Wait()\n+}\n+\n+// hasString reports whether s appears in the list of strings.\n+func hasString(strings []string, s string) bool {\n+\tfor _, t := range strings {\n+\t\tif s == t {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// build is the action for building a single package or command.\n+func (b *builder) build(a *action) (err error) {\n+\t// Return an error if the package has CXX files but it's not using\n+\t// cgo nor SWIG, since the CXX files can only be processed by cgo\n+\t// and SWIG (it's possible to have packages with C files without\n+\t// using cgo, they will get compiled with the plan9 C compiler and\n+\t// linked with the rest of the package).\n+\tif len(a.p.CXXFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {\n+\t\treturn fmt.Errorf(\"can't build package %s because it contains C++ files (%s) but it's not using cgo nor SWIG\",\n+\t\t\ta.p.ImportPath, strings.Join(a.p.CXXFiles, \",\"))\n+\t}\n+\t// Same as above for Objective-C files\n+\tif len(a.p.MFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {\n+\t\treturn fmt.Errorf(\"can't build package %s because it contains Objective-C files (%s) but it's not using cgo nor SWIG\",\n+\t\t\ta.p.ImportPath, strings.Join(a.p.MFiles, \",\"))\n+\t}\n+\tdefer func() {\n+\t\tif err != nil && err != errPrintedOutput {\n+\t\t\terr = fmt.Errorf(\"go build %s: %v\", a.p.ImportPath, err)\n+\t\t}\n+\t}()\n+\tif buildN {\n+\t\t// In -n mode, print a banner between packages.\n+\t\t// The banner is five lines so that when changes to\n+\t\t// different sections of the bootstrap script have to\n+\t\t// be merged, the banners give patch something\n+\t\t// to use to find its context.\n+\t\tfmt.Printf(\"\\n#\\n# %s\\n#\\n\\n\", a.p.ImportPath)\n+\t}\n+\n+\tif buildV {\n+\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", a.p.ImportPath)\n+\t}\n+\n+\tif a.p.Standard && a.p.ImportPath == \"runtime\" && buildContext.Compiler == \"gc\" &&\n+\t\t!hasString(a.p.HFiles, \"zasm_\"+buildContext.GOOS+\"_\"+buildContext.GOARCH+\".h\") {\n+\t\treturn fmt.Errorf(\"%s/%s must be bootstrapped using make%v\", buildContext.GOOS, buildContext.GOARCH, defaultSuffix())\n+\t}\n+\n+\t// Make build directory.\n+\tobj := a.objdir\n+\tif err := b.mkdir(obj); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// make target directory\n+\tdir, _ := filepath.Split(a.target)\n+\tif dir != \"\" {\n+\t\tif err := b.mkdir(dir); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tvar gofiles, cfiles, sfiles, objects, cgoObjects []string\n+\n+\tgofiles = append(gofiles, a.p.GoFiles...)\n+\tcfiles = append(cfiles, a.p.CFiles...)\n+\tsfiles = append(sfiles, a.p.SFiles...)\n+\n+\t// Run cgo.\n+\tif a.p.usesCgo() {\n+\t\t// In a package using cgo, cgo compiles the C, C++ and assembly files with gcc.\n+\t\t// There is one exception: runtime/cgo's job is to bridge the\n+\t\t// cgo and non-cgo worlds, so it necessarily has files in both.\n+\t\t// In that case gcc only gets the gcc_* files.\n+\t\tvar gccfiles []string\n+\t\tif a.p.Standard && a.p.ImportPath == \"runtime/cgo\" {\n+\t\t\tfilter := func(files, nongcc, gcc []string) ([]string, []string) {\n+\t\t\t\tfor _, f := range files {\n+\t\t\t\t\tif strings.HasPrefix(f, \"gcc_\") {\n+\t\t\t\t\t\tgcc = append(gcc, f)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tnongcc = append(nongcc, f)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn nongcc, gcc\n+\t\t\t}\n+\t\t\tcfiles, gccfiles = filter(cfiles, cfiles[:0], gccfiles)\n+\t\t\tsfiles, gccfiles = filter(sfiles, sfiles[:0], gccfiles)\n+\t\t} else {\n+\t\t\tgccfiles = append(cfiles, sfiles...)\n+\t\t\tcfiles = nil\n+\t\t\tsfiles = nil\n+\t\t}\n+\n+\t\tcgoExe := tool(\"cgo\")\n+\t\tif a.cgo != nil && a.cgo.target != \"\" {\n+\t\t\tcgoExe = a.cgo.target\n+\t\t}\n+\t\toutGo, outObj, err := b.cgo(a.p, cgoExe, obj, gccfiles, a.p.CXXFiles, a.p.MFiles)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tcgoObjects = append(cgoObjects, outObj...)\n+\t\tgofiles = append(gofiles, outGo...)\n+\t}\n+\n+\t// Run SWIG.\n+\tif a.p.usesSwig() {\n+\t\t// In a package using SWIG, any .c or .s files are\n+\t\t// compiled with gcc.\n+\t\tgccfiles := append(cfiles, sfiles...)\n+\t\tcfiles = nil\n+\t\tsfiles = nil\n+\t\toutGo, outObj, err := b.swig(a.p, obj, gccfiles, a.p.CXXFiles, a.p.MFiles)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tcgoObjects = append(cgoObjects, outObj...)\n+\t\tgofiles = append(gofiles, outGo...)\n+\t}\n+\n+\tif len(gofiles) == 0 {\n+\t\treturn &build.NoGoError{a.p.Dir}\n+\t}\n+\n+\t// If we're doing coverage, preprocess the .go files and put them in the work directory\n+\tif a.p.coverMode != \"\" {\n+\t\tfor i, file := range gofiles {\n+\t\t\tvar sourceFile string\n+\t\t\tvar coverFile string\n+\t\t\tvar key string\n+\t\t\tif strings.HasSuffix(file, \".cgo1.go\") {\n+\t\t\t\t// cgo files have absolute paths\n+\t\t\t\tbase := filepath.Base(file)\n+\t\t\t\tsourceFile = file\n+\t\t\t\tcoverFile = filepath.Join(obj, base)\n+\t\t\t\tkey = strings.TrimSuffix(base, \".cgo1.go\") + \".go\"\n+\t\t\t} else {\n+\t\t\t\tsourceFile = filepath.Join(a.p.Dir, file)\n+\t\t\t\tcoverFile = filepath.Join(obj, file)\n+\t\t\t\tkey = file\n+\t\t\t}\n+\t\t\tcover := a.p.coverVars[key]\n+\t\t\tif cover == nil || isTestFile(file) {\n+\t\t\t\t// Not covering this file.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := b.cover(a, coverFile, sourceFile, 0666, cover.Var); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tgofiles[i] = coverFile\n+\t\t}\n+\t}\n+\n+\t// Prepare Go import path list.\n+\tinc := b.includeArgs(\"-I\", a.deps)\n+\n+\t// Compile Go.\n+\tofile, out, err := buildToolchain.gc(b, a.p, a.objpkg, obj, inc, gofiles)\n+\tif len(out) > 0 {\n+\t\tb.showOutput(a.p.Dir, a.p.ImportPath, b.processOutput(out))\n+\t\tif err != nil {\n+\t\t\treturn errPrintedOutput\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif ofile != a.objpkg {\n+\t\tobjects = append(objects, ofile)\n+\t}\n+\n+\t// Copy .h files named for goos or goarch or goos_goarch\n+\t// to names using GOOS and GOARCH.\n+\t// For example, defs_linux_amd64.h becomes defs_GOOS_GOARCH.h.\n+\t_goos_goarch := \"_\" + goos + \"_\" + goarch\n+\t_goos := \"_\" + goos\n+\t_goarch := \"_\" + goarch\n+\tfor _, file := range a.p.HFiles {\n+\t\tname, ext := fileExtSplit(file)\n+\t\tswitch {\n+\t\tcase strings.HasSuffix(name, _goos_goarch):\n+\t\t\ttarg := file[:len(name)-len(_goos_goarch)] + \"_GOOS_GOARCH.\" + ext\n+\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\tcase strings.HasSuffix(name, _goarch):\n+\t\t\ttarg := file[:len(name)-len(_goarch)] + \"_GOARCH.\" + ext\n+\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\tcase strings.HasSuffix(name, _goos):\n+\t\t\ttarg := file[:len(name)-len(_goos)] + \"_GOOS.\" + ext\n+\t\t\tif err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0644); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tobjExt := archChar\n+\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n+\t\tobjExt = \"o\"\n+\t}\n+\n+\tfor _, file := range cfiles {\n+\t\tout := file[:len(file)-len(\".c\")] + \".\" + objExt\n+\t\tif err := buildToolchain.cc(b, a.p, obj, obj+out, file); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tobjects = append(objects, out)\n+\t}\n+\n+\t// Assemble .s files.\n+\tfor _, file := range sfiles {\n+\t\tout := file[:len(file)-len(\".s\")] + \".\" + objExt\n+\t\tif err := buildToolchain.asm(b, a.p, obj, obj+out, file); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tobjects = append(objects, out)\n+\t}\n+\n+\t// NOTE(rsc): On Windows, it is critically important that the\n+\t// gcc-compiled objects (cgoObjects) be listed after the ordinary\n+\t// objects in the archive.  I do not know why this is.\n+\t// http://golang.org/issue/2601\n+\tobjects = append(objects, cgoObjects...)\n+\n+\t// Add system object files.\n+\tfor _, syso := range a.p.SysoFiles {\n+\t\tobjects = append(objects, filepath.Join(a.p.Dir, syso))\n+\t}\n+\n+\t// Pack into archive in obj directory.\n+\t// If the Go compiler wrote an archive, we only need to add the\n+\t// object files for non-Go sources to the archive.\n+\t// If the Go compiler wrote an archive and the package is entirely\n+\t// Go sources, there is no pack to execute at all.\n+\tif len(objects) > 0 {\n+\t\tif err := buildToolchain.pack(b, a.p, obj, a.objpkg, objects); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// Link if needed.\n+\tif a.link {\n+\t\t// The compiler only cares about direct imports, but the\n+\t\t// linker needs the whole dependency tree.\n+\t\tall := actionList(a)\n+\t\tall = all[:len(all)-1] // drop a\n+\t\tif err := buildToolchain.ld(b, a.p, a.target, all, a.objpkg, objects); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// install is the action for installing a single package or executable.\n+func (b *builder) install(a *action) (err error) {\n+\tdefer func() {\n+\t\tif err != nil && err != errPrintedOutput {\n+\t\t\terr = fmt.Errorf(\"go install %s: %v\", a.p.ImportPath, err)\n+\t\t}\n+\t}()\n+\ta1 := a.deps[0]\n+\tperm := os.FileMode(0644)\n+\tif a1.link {\n+\t\tperm = 0755\n+\t}\n+\n+\t// make target directory\n+\tdir, _ := filepath.Split(a.target)\n+\tif dir != \"\" {\n+\t\tif err := b.mkdir(dir); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// remove object dir to keep the amount of\n+\t// garbage down in a large build.  On an operating system\n+\t// with aggressive buffering, cleaning incrementally like\n+\t// this keeps the intermediate objects from hitting the disk.\n+\tif !buildWork {\n+\t\tdefer os.RemoveAll(a1.objdir)\n+\t\tdefer os.Remove(a1.target)\n+\t}\n+\n+\treturn b.moveOrCopyFile(a, a.target, a1.target, perm)\n+}\n+\n+// includeArgs returns the -I or -L directory list for access\n+// to the results of the list of actions.\n+func (b *builder) includeArgs(flag string, all []*action) []string {\n+\tinc := []string{}\n+\tincMap := map[string]bool{\n+\t\tb.work:    true, // handled later\n+\t\tgorootPkg: true,\n+\t\t\"\":        true, // ignore empty strings\n+\t}\n+\n+\t// Look in the temporary space for results of test-specific actions.\n+\t// This is the $WORK/my/package/_test directory for the\n+\t// package being built, so there are few of these.\n+\tfor _, a1 := range all {\n+\t\tif dir := a1.pkgdir; dir != a1.p.build.PkgRoot && !incMap[dir] {\n+\t\t\tincMap[dir] = true\n+\t\t\tinc = append(inc, flag, dir)\n+\t\t}\n+\t}\n+\n+\t// Also look in $WORK for any non-test packages that have\n+\t// been built but not installed.\n+\tinc = append(inc, flag, b.work)\n+\n+\t// Finally, look in the installed package directories for each action.\n+\tfor _, a1 := range all {\n+\t\tif dir := a1.pkgdir; dir == a1.p.build.PkgRoot && !incMap[dir] {\n+\t\t\tincMap[dir] = true\n+\t\t\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n+\t\t\t\tdir = filepath.Join(dir, \"gccgo_\"+goos+\"_\"+goarch)\n+\t\t\t} else {\n+\t\t\t\tdir = filepath.Join(dir, goos+\"_\"+goarch)\n+\t\t\t\tif buildContext.InstallSuffix != \"\" {\n+\t\t\t\t\tdir += \"_\" + buildContext.InstallSuffix\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tinc = append(inc, flag, dir)\n+\t\t}\n+\t}\n+\n+\treturn inc\n+}\n+\n+// moveOrCopyFile is like 'mv src dst' or 'cp src dst'.\n+func (b *builder) moveOrCopyFile(a *action, dst, src string, perm os.FileMode) error {\n+\tif buildN {\n+\t\tb.showcmd(\"\", \"mv %s %s\", src, dst)\n+\t\treturn nil\n+\t}\n+\n+\t// If we can update the mode and rename to the dst, do it.\n+\t// Otherwise fall back to standard copy.\n+\tif err := os.Chmod(src, perm); err == nil {\n+\t\tif err := os.Rename(src, dst); err == nil {\n+\t\t\tif buildX {\n+\t\t\t\tb.showcmd(\"\", \"mv %s %s\", src, dst)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\treturn b.copyFile(a, dst, src, perm)\n+}\n+\n+// copyFile is like 'cp src dst'.\n+func (b *builder) copyFile(a *action, dst, src string, perm os.FileMode) error {\n+\tif buildN || buildX {\n+\t\tb.showcmd(\"\", \"cp %s %s\", src, dst)\n+\t\tif buildN {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tsf, err := os.Open(src)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer sf.Close()\n+\n+\t// Be careful about removing/overwriting dst.\n+\t// Do not remove/overwrite if dst exists and is a directory\n+\t// or a non-object file.\n+\tif fi, err := os.Stat(dst); err == nil {\n+\t\tif fi.IsDir() {\n+\t\t\treturn fmt.Errorf(\"build output %q already exists and is a directory\", dst)\n+\t\t}\n+\t\tif !isObject(dst) {\n+\t\t\treturn fmt.Errorf(\"build output %q already exists and is not an object file\", dst)\n+\t\t}\n+\t}\n+\n+\t// On Windows, remove lingering ~ file from last attempt.\n+\tif toolIsWindows {\n+\t\tif _, err := os.Stat(dst + \"~\"); err == nil {\n+\t\t\tos.Remove(dst + \"~\")\n+\t\t}\n+\t}\n+\n+\tos.Remove(dst)\n+\tdf, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n+\tif err != nil && toolIsWindows {\n+\t\t// Windows does not allow deletion of a binary file\n+\t\t// while it is executing.  Try to move it out of the way.\n+\t\t// If the move fails, which is likely, we'll try again the\n+\t\t// next time we do an install of this binary.\n+\t\tif err := os.Rename(dst, dst+\"~\"); err == nil {\n+\t\t\tos.Remove(dst + \"~\")\n+\t\t}\n+\t\tdf, err = os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n+\t}\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t_, err = io.Copy(df, sf)\n+\tdf.Close()\n+\tif err != nil {\n+\t\tos.Remove(dst)\n+\t\treturn fmt.Errorf(\"copying %s to %s: %v\", src, dst, err)\n+\t}\n+\treturn nil\n+}\n+\n+// cover runs, in effect,\n+//\tgo tool cover -mode=b.coverMode -var=\"varName\" -o dst.go src.go\n+func (b *builder) cover(a *action, dst, src string, perm os.FileMode, varName string) error {\n+\treturn b.run(a.objdir, \"cover \"+a.p.ImportPath, nil,\n+\t\ttool(\"cover\"),\n+\t\t\"-mode\", a.p.coverMode,\n+\t\t\"-var\", varName,\n+\t\t\"-o\", dst,\n+\t\tsrc)\n+}\n+\n+var objectMagic = [][]byte{\n+\t{'!', '<', 'a', 'r', 'c', 'h', '>', '\\n'},        // Package archive\n+\t{'\\x7F', 'E', 'L', 'F'},                          // ELF\n+\t{0xFE, 0xED, 0xFA, 0xCE},                         // Mach-O big-endian 32-bit\n+\t{0xFE, 0xED, 0xFA, 0xCF},                         // Mach-O big-endian 64-bit\n+\t{0xCE, 0xFA, 0xED, 0xFE},                         // Mach-O little-endian 32-bit\n+\t{0xCF, 0xFA, 0xED, 0xFE},                         // Mach-O little-endian 64-bit\n+\t{0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x04, 0x00}, // PE (Windows) as generated by 6l/8l\n+\t{0x00, 0x00, 0x01, 0xEB},                         // Plan 9 i386\n+\t{0x00, 0x00, 0x8a, 0x97},                         // Plan 9 amd64\n+}\n+\n+func isObject(s string) bool {\n+\tf, err := os.Open(s)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tdefer f.Close()\n+\tbuf := make([]byte, 64)\n+\tio.ReadFull(f, buf)\n+\tfor _, magic := range objectMagic {\n+\t\tif bytes.HasPrefix(buf, magic) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// fmtcmd formats a command in the manner of fmt.Sprintf but also:\n+//\n+//\tIf dir is non-empty and the script is not in dir right now,\n+//\tfmtcmd inserts \"cd dir\\n\" before the command.\n+//\n+//\tfmtcmd replaces the value of b.work with $WORK.\n+//\tfmtcmd replaces the value of goroot with $GOROOT.\n+//\tfmtcmd replaces the value of b.gobin with $GOBIN.\n+//\n+//\tfmtcmd replaces the name of the current directory with dot (.)\n+//\tbut only when it is at the beginning of a space-separated token.\n+//\n+func (b *builder) fmtcmd(dir string, format string, args ...interface{}) string {\n+\tcmd := fmt.Sprintf(format, args...)\n+\tif dir != \"\" && dir != \"/\" {\n+\t\tcmd = strings.Replace(\" \"+cmd, \" \"+dir, \" .\", -1)[1:]\n+\t\tif b.scriptDir != dir {\n+\t\t\tb.scriptDir = dir\n+\t\t\tcmd = \"cd \" + dir + \"\\n\" + cmd\n+\t\t}\n+\t}\n+\tif b.work != \"\" {\n+\t\tcmd = strings.Replace(cmd, b.work, \"$WORK\", -1)\n+\t}\n+\treturn cmd\n+}\n+\n+// showcmd prints the given command to standard output\n+// for the implementation of -n or -x.\n+func (b *builder) showcmd(dir string, format string, args ...interface{}) {\n+\tb.output.Lock()\n+\tdefer b.output.Unlock()\n+\tb.print(b.fmtcmd(dir, format, args...) + \"\\n\")\n+}\n+\n+// showOutput prints \"# desc\" followed by the given output.\n+// The output is expected to contain references to 'dir', usually\n+// the source directory for the package that has failed to build.\n+// showOutput rewrites mentions of dir with a relative path to dir\n+// when the relative path is shorter.  This is usually more pleasant.\n+// For example, if fmt doesn't compile and we are in src/pkg/html,\n+// the output is\n+//\n+//\t$ go build\n+//\t# fmt\n+//\t../fmt/print.go:1090: undefined: asdf\n+//\t$\n+//\n+// instead of\n+//\n+//\t$ go build\n+//\t# fmt\n+//\t/usr/gopher/go/src/pkg/fmt/print.go:1090: undefined: asdf\n+//\t$\n+//\n+// showOutput also replaces references to the work directory with $WORK.\n+//\n+func (b *builder) showOutput(dir, desc, out string) {\n+\tprefix := \"# \" + desc\n+\tsuffix := \"\\n\" + out\n+\tif reldir := shortPath(dir); reldir != dir {\n+\t\tsuffix = strings.Replace(suffix, \" \"+dir, \" \"+reldir, -1)\n+\t\tsuffix = strings.Replace(suffix, \"\\n\"+dir, \"\\n\"+reldir, -1)\n+\t}\n+\tsuffix = strings.Replace(suffix, \" \"+b.work, \" $WORK\", -1)\n+\n+\tb.output.Lock()\n+\tdefer b.output.Unlock()\n+\tb.print(prefix, suffix)\n+}\n+\n+// shortPath returns an absolute or relative name for path, whatever is shorter.\n+func shortPath(path string) string {\n+\tif rel, err := filepath.Rel(cwd, path); err == nil && len(rel) < len(path) {\n+\t\treturn rel\n+\t}\n+\treturn path\n+}\n+\n+// relPaths returns a copy of paths with absolute paths\n+// made relative to the current directory if they would be shorter.\n+func relPaths(paths []string) []string {\n+\tvar out []string\n+\tpwd, _ := os.Getwd()\n+\tfor _, p := range paths {\n+\t\trel, err := filepath.Rel(pwd, p)\n+\t\tif err == nil && len(rel) < len(p) {\n+\t\t\tp = rel\n+\t\t}\n+\t\tout = append(out, p)\n+\t}\n+\treturn out\n+}\n+\n+// errPrintedOutput is a special error indicating that a command failed\n+// but that it generated output as well, and that output has already\n+// been printed, so there's no point showing 'exit status 1' or whatever\n+// the wait status was.  The main executor, builder.do, knows not to\n+// print this error.\n+var errPrintedOutput = errors.New(\"already printed output - no need to show error\")\n+\n+var cgoLine = regexp.MustCompile(`\\[[^\\[\\]]+\\.cgo1\\.go:[0-9]+\\]`)\n+var cgoTypeSigRe = regexp.MustCompile(`\\b_Ctype_\\B`)\n+\n+// run runs the command given by cmdline in the directory dir.\n+// If the command fails, run prints information about the failure\n+// and returns a non-nil error.\n+func (b *builder) run(dir string, desc string, env []string, cmdargs ...interface{}) error {\n+\tout, err := b.runOut(dir, desc, env, cmdargs...)\n+\tif len(out) > 0 {\n+\t\tif desc == \"\" {\n+\t\t\tdesc = b.fmtcmd(dir, \"%s\", strings.Join(stringList(cmdargs...), \" \"))\n+\t\t}\n+\t\tb.showOutput(dir, desc, b.processOutput(out))\n+\t\tif err != nil {\n+\t\t\terr = errPrintedOutput\n+\t\t}\n+\t}\n+\treturn err\n+}\n+\n+// processOutput prepares the output of runOut to be output to the console.\n+func (b *builder) processOutput(out []byte) string {\n+\tif out[len(out)-1] != '\\n' {\n+\t\tout = append(out, '\\n')\n+\t}\n+\tmessages := string(out)\n+\t// Fix up output referring to cgo-generated code to be more readable.\n+\t// Replace x.go:19[/tmp/.../x.cgo1.go:18] with x.go:19.\n+\t// Replace *[100]_Ctype_foo with *[100]C.foo.\n+\t// If we're using -x, assume we're debugging and want the full dump, so disable the rewrite.\n+\tif !buildX && cgoLine.MatchString(messages) {\n+\t\tmessages = cgoLine.ReplaceAllString(messages, \"\")\n+\t\tmessages = cgoTypeSigRe.ReplaceAllString(messages, \"C.\")\n+\t}\n+\treturn messages\n+}\n+\n+// runOut runs the command given by cmdline in the directory dir.\n+// It returns the command output and any errors that occurred.\n+func (b *builder) runOut(dir string, desc string, env []string, cmdargs ...interface{}) ([]byte, error) {\n+\tcmdline := stringList(cmdargs...)\n+\tif buildN || buildX {\n+\t\tvar envcmdline string\n+\t\tfor i := range env {\n+\t\t\tenvcmdline += env[i]\n+\t\t\tenvcmdline += \" \"\n+\t\t}\n+\t\tenvcmdline += joinUnambiguously(cmdline)\n+\t\tb.showcmd(dir, \"%s\", envcmdline)\n+\t\tif buildN {\n+\t\t\treturn nil, nil\n+\t\t}\n+\t}\n+\n+\tnbusy := 0\n+\tfor {\n+\t\tvar buf bytes.Buffer\n+\t\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\t\tcmd.Stdout = &buf\n+\t\tcmd.Stderr = &buf\n+\t\tcmd.Dir = dir\n+\t\tcmd.Env = mergeEnvLists(env, envForDir(cmd.Dir))\n+\t\terr := cmd.Run()\n+\n+\t\t// cmd.Run will fail on Unix if some other process has the binary\n+\t\t// we want to run open for writing.  This can happen here because\n+\t\t// we build and install the cgo command and then run it.\n+\t\t// If another command was kicked off while we were writing the\n+\t\t// cgo binary, the child process for that command may be holding\n+\t\t// a reference to the fd, keeping us from running exec.\n+\t\t//\n+\t\t// But, you might reasonably wonder, how can this happen?\n+\t\t// The cgo fd, like all our fds, is close-on-exec, so that we need\n+\t\t// not worry about other processes inheriting the fd accidentally.\n+\t\t// The answer is that running a command is fork and exec.\n+\t\t// A child forked while the cgo fd is open inherits that fd.\n+\t\t// Until the child has called exec, it holds the fd open and the\n+\t\t// kernel will not let us run cgo.  Even if the child were to close\n+\t\t// the fd explicitly, it would still be open from the time of the fork\n+\t\t// until the time of the explicit close, and the race would remain.\n+\t\t//\n+\t\t// On Unix systems, this results in ETXTBSY, which formats\n+\t\t// as \"text file busy\".  Rather than hard-code specific error cases,\n+\t\t// we just look for that string.  If this happens, sleep a little\n+\t\t// and try again.  We let this happen three times, with increasing\n+\t\t// sleep lengths: 100+200+400 ms = 0.7 seconds.\n+\t\t//\n+\t\t// An alternate solution might be to split the cmd.Run into\n+\t\t// separate cmd.Start and cmd.Wait, and then use an RWLock\n+\t\t// to make sure that copyFile only executes when no cmd.Start\n+\t\t// call is in progress.  However, cmd.Start (really syscall.forkExec)\n+\t\t// only guarantees that when it returns, the exec is committed to\n+\t\t// happen and succeed.  It uses a close-on-exec file descriptor\n+\t\t// itself to determine this, so we know that when cmd.Start returns,\n+\t\t// at least one close-on-exec file descriptor has been closed.\n+\t\t// However, we cannot be sure that all of them have been closed,\n+\t\t// so the program might still encounter ETXTBSY even with such\n+\t\t// an RWLock.  The race window would be smaller, perhaps, but not\n+\t\t// guaranteed to be gone.\n+\t\t//\n+\t\t// Sleeping when we observe the race seems to be the most reliable\n+\t\t// option we have.\n+\t\t//\n+\t\t// http://golang.org/issue/3001\n+\t\t//\n+\t\tif err != nil && nbusy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n+\t\t\ttime.Sleep(100 * time.Millisecond << uint(nbusy))\n+\t\t\tnbusy++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treturn buf.Bytes(), err\n+\t}\n+}\n+\n+// joinUnambiguously prints the slice, quoting where necessary to make the\n+// output unambiguous.\n+// TODO: See issue 5279. The printing of commands needs a complete redo.\n+func joinUnambiguously(a []string) string {\n+\tvar buf bytes.Buffer\n+\tfor i, s := range a {\n+\t\tif i > 0 {\n+\t\t\tbuf.WriteByte(' ')\n+\t\t}\n+\t\tq := strconv.Quote(s)\n+\t\tif s == \"\" || strings.Contains(s, \" \") || len(q) > len(s)+2 {\n+\t\t\tbuf.WriteString(q)\n+\t\t} else {\n+\t\t\tbuf.WriteString(s)\n+\t\t}\n+\t}\n+\treturn buf.String()\n+}\n+\n+// mkdir makes the named directory.\n+func (b *builder) mkdir(dir string) error {\n+\tb.exec.Lock()\n+\tdefer b.exec.Unlock()\n+\t// We can be a little aggressive about being\n+\t// sure directories exist.  Skip repeated calls.\n+\tif b.mkdirCache[dir] {\n+\t\treturn nil\n+\t}\n+\tb.mkdirCache[dir] = true\n+\n+\tif buildN || buildX {\n+\t\tb.showcmd(\"\", \"mkdir -p %s\", dir)\n+\t\tif buildN {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tif err := os.MkdirAll(dir, 0777); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// mkAbs returns an absolute path corresponding to\n+// evaluating f in the directory dir.\n+// We always pass absolute paths of source files so that\n+// the error messages will include the full path to a file\n+// in need of attention.\n+func mkAbs(dir, f string) string {\n+\t// Leave absolute paths alone.\n+\t// Also, during -n mode we use the pseudo-directory $WORK\n+\t// instead of creating an actual work directory that won't be used.\n+\t// Leave paths beginning with $WORK alone too.\n+\tif filepath.IsAbs(f) || strings.HasPrefix(f, \"$WORK\") {\n+\t\treturn f\n+\t}\n+\treturn filepath.Join(dir, f)\n+}\n+\n+type toolchain interface {\n+\t// gc runs the compiler in a specific directory on a set of files\n+\t// and returns the name of the generated output file.\n+\t// The compiler runs in the directory dir.\n+\tgc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, out []byte, err error)\n+\t// cc runs the toolchain's C compiler in a directory on a C file\n+\t// to produce an output file.\n+\tcc(b *builder, p *Package, objdir, ofile, cfile string) error\n+\t// asm runs the assembler in a specific directory on a specific file\n+\t// to generate the named output file.\n+\tasm(b *builder, p *Package, obj, ofile, sfile string) error\n+\t// pkgpath builds an appropriate path for a temporary package file.\n+\tpkgpath(basedir string, p *Package) string\n+\t// pack runs the archive packer in a specific directory to create\n+\t// an archive from a set of object files.\n+\t// typically it is run in the object directory.\n+\tpack(b *builder, p *Package, objDir, afile string, ofiles []string) error\n+\t// ld runs the linker to create a package starting at mainpkg.\n+\tld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error\n+\n+\tcompiler() string\n+\tlinker() string\n+}\n+\n+type noToolchain struct{}\n+\n+func noCompiler() error {\n+\tlog.Fatalf(\"unknown compiler %q\", buildContext.Compiler)\n+\treturn nil\n+}\n+\n+func (noToolchain) compiler() string {\n+\tnoCompiler()\n+\treturn \"\"\n+}\n+\n+func (noToolchain) linker() string {\n+\tnoCompiler()\n+\treturn \"\"\n+}\n+\n+func (noToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, out []byte, err error) {\n+\treturn \"\", nil, noCompiler()\n+}\n+\n+func (noToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n+\treturn noCompiler()\n+}\n+\n+func (noToolchain) pkgpath(basedir string, p *Package) string {\n+\tnoCompiler()\n+\treturn \"\"\n+}\n+\n+func (noToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles []string) error {\n+\treturn noCompiler()\n+}\n+\n+func (noToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+\treturn noCompiler()\n+}\n+\n+func (noToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n+\treturn noCompiler()\n+}\n+\n+// The Go toolchain.\n+type gcToolchain struct{}\n+\n+func (gcToolchain) compiler() string {\n+\treturn tool(archChar + \"g\")\n+}\n+\n+func (gcToolchain) linker() string {\n+\treturn tool(archChar + \"l\")\n+}\n+\n+func (gcToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n+\tif archive != \"\" {\n+\t\tofile = archive\n+\t} else {\n+\t\tout := \"_go_.\" + archChar\n+\t\tofile = obj + out\n+\t}\n+\n+\tgcargs := []string{\"-p\", p.ImportPath}\n+\tif p.Standard && p.ImportPath == \"runtime\" {\n+\t\t// runtime compiles with a special 6g flag to emit\n+\t\t// additional reflect type data.\n+\t\tgcargs = append(gcargs, \"-+\")\n+\t}\n+\n+\t// If we're giving the compiler the entire package (no C etc files), tell it that,\n+\t// so that it can give good error messages about forward declarations.\n+\t// Exceptions: a few standard packages have forward declarations for\n+\t// pieces supplied behind-the-scenes by package runtime.\n+\textFiles := len(p.CgoFiles) + len(p.CFiles) + len(p.CXXFiles) + len(p.MFiles) + len(p.SFiles) + len(p.SysoFiles) + len(p.SwigFiles) + len(p.SwigCXXFiles)\n+\tif p.Standard {\n+\t\tswitch p.ImportPath {\n+\t\tcase \"os\", \"runtime/pprof\", \"sync\", \"time\":\n+\t\t\textFiles++\n+\t\t}\n+\t}\n+\tif extFiles == 0 {\n+\t\tgcargs = append(gcargs, \"-complete\")\n+\t}\n+\tif buildContext.InstallSuffix != \"\" {\n+\t\tgcargs = append(gcargs, \"-installsuffix\", buildContext.InstallSuffix)\n+\t}\n+\n+\targs := stringList(tool(archChar+\"g\"), \"-o\", ofile, \"-trimpath\", b.work, buildGcflags, gcargs, \"-D\", p.localPrefix, importArgs)\n+\tif ofile == archive {\n+\t\targs = append(args, \"-pack\")\n+\t}\n+\tfor _, f := range gofiles {\n+\t\targs = append(args, mkAbs(p.Dir, f))\n+\t}\n+\n+\toutput, err = b.runOut(p.Dir, p.ImportPath, nil, args)\n+\treturn ofile, output, err\n+}\n+\n+func (gcToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n+\tsfile = mkAbs(p.Dir, sfile)\n+\treturn b.run(p.Dir, p.ImportPath, nil, tool(archChar+\"a\"), \"-trimpath\", b.work, \"-I\", obj, \"-o\", ofile, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, sfile)\n+}\n+\n+func (gcToolchain) pkgpath(basedir string, p *Package) string {\n+\tend := filepath.FromSlash(p.ImportPath + \".a\")\n+\treturn filepath.Join(basedir, end)\n+}\n+\n+func (gcToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles []string) error {\n+\tvar absOfiles []string\n+\tfor _, f := range ofiles {\n+\t\tabsOfiles = append(absOfiles, mkAbs(objDir, f))\n+\t}\n+\tcmd := \"c\"\n+\tabsAfile := mkAbs(objDir, afile)\n+\tappending := false\n+\tif _, err := os.Stat(absAfile); err == nil {\n+\t\tappending = true\n+\t\tcmd = \"r\"\n+\t}\n+\n+\tcmdline := stringList(\"pack\", cmd, absAfile, absOfiles)\n+\n+\tif appending {\n+\t\tif buildN || buildX {\n+\t\t\tb.showcmd(p.Dir, \"%s # internal\", joinUnambiguously(cmdline))\n+\t\t}\n+\t\tif buildN {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif err := packInternal(b, absAfile, absOfiles); err != nil {\n+\t\t\tb.showOutput(p.Dir, p.ImportPath, err.Error()+\"\\n\")\n+\t\t\treturn errPrintedOutput\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\t// Need actual pack.\n+\tcmdline[0] = tool(\"pack\")\n+\treturn b.run(p.Dir, p.ImportPath, nil, cmdline)\n+}\n+\n+func packInternal(b *builder, afile string, ofiles []string) error {\n+\tdst, err := os.OpenFile(afile, os.O_WRONLY|os.O_APPEND, 0)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer dst.Close() // only for error returns or panics\n+\tw := bufio.NewWriter(dst)\n+\n+\tfor _, ofile := range ofiles {\n+\t\tsrc, err := os.Open(ofile)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tfi, err := src.Stat()\n+\t\tif err != nil {\n+\t\t\tsrc.Close()\n+\t\t\treturn err\n+\t\t}\n+\t\t// Note: Not using %-16.16s format because we care\n+\t\t// about bytes, not runes.\n+\t\tname := fi.Name()\n+\t\tif len(name) > 16 {\n+\t\t\tname = name[:16]\n+\t\t} else {\n+\t\t\tname += strings.Repeat(\" \", 16-len(name))\n+\t\t}\n+\t\tsize := fi.Size()\n+\t\tfmt.Fprintf(w, \"%s%-12d%-6d%-6d%-8o%-10d`\\n\",\n+\t\t\tname, 0, 0, 0, 0644, size)\n+\t\tn, err := io.Copy(w, src)\n+\t\tsrc.Close()\n+\t\tif err == nil && n < size {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t} else if err == nil && n > size {\n+\t\t\terr = fmt.Errorf(\"file larger than size reported by stat\")\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"copying %s to %s: %v\", ofile, afile, err)\n+\t\t}\n+\t\tif size&1 != 0 {\n+\t\t\tw.WriteByte(0)\n+\t\t}\n+\t}\n+\n+\tif err := w.Flush(); err != nil {\n+\t\treturn err\n+\t}\n+\treturn dst.Close()\n+}\n+\n+func (gcToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+\timportArgs := b.includeArgs(\"-L\", allactions)\n+\tcxx := false\n+\tfor _, a := range allactions {\n+\t\tif a.p != nil && len(a.p.CXXFiles) > 0 {\n+\t\t\tcxx = true\n+\t\t}\n+\t}\n+\tldflags := buildLdflags\n+\t// Limit slice capacity so that concurrent appends do not race on the shared array.\n+\tldflags = ldflags[:len(ldflags):len(ldflags)]\n+\tif buildContext.InstallSuffix != \"\" {\n+\t\tldflags = append(ldflags, \"-installsuffix\", buildContext.InstallSuffix)\n+\t}\n+\tif p.omitDWARF {\n+\t\tldflags = append(ldflags, \"-w\")\n+\t}\n+\n+\t// If the user has not specified the -extld option, then specify the\n+\t// appropriate linker. In case of C++ code, use the compiler named\n+\t// by the CXX environment variable or defaultCXX if CXX is not set.\n+\t// Else, use the CC environment variable and defaultCC as fallback.\n+\textld := false\n+\tfor _, f := range ldflags {\n+\t\tif f == \"-extld\" || strings.HasPrefix(f, \"-extld=\") {\n+\t\t\textld = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif !extld {\n+\t\tvar compiler []string\n+\t\tif cxx {\n+\t\t\tcompiler = envList(\"CXX\", defaultCXX)\n+\t\t} else {\n+\t\t\tcompiler = envList(\"CC\", defaultCC)\n+\t\t}\n+\t\tldflags = append(ldflags, \"-extld=\"+compiler[0])\n+\t\tif len(compiler) > 1 {\n+\t\t\textldflags := false\n+\t\t\tadd := strings.Join(compiler[1:], \" \")\n+\t\t\tfor i, f := range ldflags {\n+\t\t\t\tif f == \"-extldflags\" && i+1 < len(ldflags) {\n+\t\t\t\t\tldflags[i+1] = add + \" \" + ldflags[i+1]\n+\t\t\t\t\textldflags = true\n+\t\t\t\t\tbreak\n+\t\t\t\t} else if strings.HasPrefix(f, \"-extldflags=\") {\n+\t\t\t\t\tldflags[i] = \"-extldflags=\" + add + \" \" + ldflags[i][len(\"-extldflags=\"):]\n+\t\t\t\t\textldflags = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif !extldflags {\n+\t\t\t\tldflags = append(ldflags, \"-extldflags=\"+add)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn b.run(\".\", p.ImportPath, nil, tool(archChar+\"l\"), \"-o\", out, importArgs, ldflags, mainpkg)\n+}\n+\n+func (gcToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n+\tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n+\tcfile = mkAbs(p.Dir, cfile)\n+\targs := stringList(tool(archChar+\"c\"), \"-F\", \"-V\", \"-w\", \"-trimpath\", b.work, \"-I\", objdir, \"-I\", inc, \"-o\", ofile, buildCcflags, \"-D\", \"GOOS_\"+goos, \"-D\", \"GOARCH_\"+goarch, cfile)\n+\treturn b.run(p.Dir, p.ImportPath, nil, args)\n+}\n+\n+// The Gccgo toolchain.\n+type gccgoToolchain struct{}\n+\n+var gccgoBin, _ = exec.LookPath(\"gccgo\")\n+\n+func (gccgoToolchain) compiler() string {\n+\treturn gccgoBin\n+}\n+\n+func (gccgoToolchain) linker() string {\n+\treturn gccgoBin\n+}\n+\n+func (gccgoToolchain) gc(b *builder, p *Package, archive, obj string, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {\n+\tout := p.Name + \".o\"\n+\tofile = obj + out\n+\tgcargs := []string{\"-g\"}\n+\tgcargs = append(gcargs, b.gccArchArgs()...)\n+\tif pkgpath := gccgoPkgpath(p); pkgpath != \"\" {\n+\t\tgcargs = append(gcargs, \"-fgo-pkgpath=\"+pkgpath)\n+\t}\n+\tif p.localPrefix != \"\" {\n+\t\tgcargs = append(gcargs, \"-fgo-relative-import-path=\"+p.localPrefix)\n+\t}\n+\targs := stringList(\"gccgo\", importArgs, \"-c\", gcargs, \"-o\", ofile, buildGccgoflags)\n+\tfor _, f := range gofiles {\n+\t\targs = append(args, mkAbs(p.Dir, f))\n+\t}\n+\n+\toutput, err = b.runOut(p.Dir, p.ImportPath, nil, args)\n+\treturn ofile, output, err\n+}\n+\n+func (gccgoToolchain) asm(b *builder, p *Package, obj, ofile, sfile string) error {\n+\tsfile = mkAbs(p.Dir, sfile)\n+\tdefs := []string{\"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch}\n+\tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n+\t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n+\t}\n+\tdefs = append(defs, b.gccArchArgs()...)\n+\treturn b.run(p.Dir, p.ImportPath, nil, \"gccgo\", \"-I\", obj, \"-o\", ofile, defs, sfile)\n+}\n+\n+func (gccgoToolchain) pkgpath(basedir string, p *Package) string {\n+\tend := filepath.FromSlash(p.ImportPath + \".a\")\n+\tafile := filepath.Join(basedir, end)\n+\t// add \"lib\" to the final element\n+\treturn filepath.Join(filepath.Dir(afile), \"lib\"+filepath.Base(afile))\n+}\n+\n+func (gccgoToolchain) pack(b *builder, p *Package, objDir, afile string, ofiles []string) error {\n+\tvar absOfiles []string\n+\tfor _, f := range ofiles {\n+\t\tabsOfiles = append(absOfiles, mkAbs(objDir, f))\n+\t}\n+\treturn b.run(p.Dir, p.ImportPath, nil, \"ar\", \"cru\", mkAbs(objDir, afile), absOfiles)\n+}\n+\n+func (tools gccgoToolchain) ld(b *builder, p *Package, out string, allactions []*action, mainpkg string, ofiles []string) error {\n+\t// gccgo needs explicit linking with all package dependencies,\n+\t// and all LDFLAGS from cgo dependencies.\n+\tapackagesSeen := make(map[*Package]bool)\n+\tafiles := []string{}\n+\tldflags := b.gccArchArgs()\n+\tcgoldflags := []string{}\n+\tusesCgo := false\n+\tcxx := false\n+\tobjc := false\n+\n+\t// Prefer the output of an install action to the output of a build action,\n+\t// because the install action will delete the output of the build action.\n+\t// Iterate over the list backward (reverse dependency order) so that we\n+\t// always see the install before the build.\n+\tfor i := len(allactions) - 1; i >= 0; i-- {\n+\t\ta := allactions[i]\n+\t\tif !a.p.Standard {\n+\t\t\tif a.p != nil && !apackagesSeen[a.p] {\n+\t\t\t\tapackagesSeen[a.p] = true\n+\t\t\t\tif a.p.fake {\n+\t\t\t\t\t// move _test files to the top of the link order\n+\t\t\t\t\tafiles = append([]string{a.target}, afiles...)\n+\t\t\t\t} else {\n+\t\t\t\t\tafiles = append(afiles, a.target)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor _, a := range allactions {\n+\t\tif a.p != nil {\n+\t\t\tcgoldflags = append(cgoldflags, a.p.CgoLDFLAGS...)\n+\t\t\tif len(a.p.CgoFiles) > 0 {\n+\t\t\t\tusesCgo = true\n+\t\t\t}\n+\t\t\tif a.p.usesSwig() {\n+\t\t\t\tusesCgo = true\n+\t\t\t}\n+\t\t\tif len(a.p.CXXFiles) > 0 {\n+\t\t\t\tcxx = true\n+\t\t\t}\n+\t\t\tif len(a.p.MFiles) > 0 {\n+\t\t\t\tobjc = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tldflags = append(ldflags, afiles...)\n+\tldflags = append(ldflags, cgoldflags...)\n+\tldflags = append(ldflags, p.CgoLDFLAGS...)\n+\tif usesCgo && goos == \"linux\" {\n+\t\tldflags = append(ldflags, \"-Wl,-E\")\n+\t}\n+\tif cxx {\n+\t\tldflags = append(ldflags, \"-lstdc++\")\n+\t}\n+\tif objc {\n+\t\tldflags = append(ldflags, \"-lobjc\")\n+\t}\n+\treturn b.run(\".\", p.ImportPath, nil, \"gccgo\", \"-o\", out, ofiles, \"-Wl,-(\", ldflags, \"-Wl,-)\", buildGccgoflags)\n+}\n+\n+func (gccgoToolchain) cc(b *builder, p *Package, objdir, ofile, cfile string) error {\n+\tinc := filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s\", goos, goarch))\n+\tcfile = mkAbs(p.Dir, cfile)\n+\tdefs := []string{\"-D\", \"GOOS_\" + goos, \"-D\", \"GOARCH_\" + goarch}\n+\tdefs = append(defs, b.gccArchArgs()...)\n+\tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n+\t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n+\t}\n+\t// TODO: Support using clang here (during gccgo build)?\n+\treturn b.run(p.Dir, p.ImportPath, nil, \"gcc\", \"-Wall\", \"-g\",\n+\t\t\"-I\", objdir, \"-I\", inc, \"-o\", ofile, defs, \"-c\", cfile)\n+}\n+\n+func gccgoPkgpath(p *Package) string {\n+\tif p.build.IsCommand() && !p.forceLibrary {\n+\t\treturn \"\"\n+\t}\n+\treturn p.ImportPath\n+}\n+\n+func gccgoCleanPkgpath(p *Package) string {\n+\tclean := func(r rune) rune {\n+\t\tswitch {\n+\t\tcase 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',\n+\t\t\t'0' <= r && r <= '9':\n+\t\t\treturn r\n+\t\t}\n+\t\treturn '_'\n+\t}\n+\treturn strings.Map(clean, gccgoPkgpath(p))\n+}\n+\n+// libgcc returns the filename for libgcc, as determined by invoking gcc with\n+// the -print-libgcc-file-name option.\n+func (b *builder) libgcc(p *Package) (string, error) {\n+\tvar buf bytes.Buffer\n+\n+\tgccCmd := b.gccCmd(p.Dir)\n+\n+\tprev := b.print\n+\tif buildN {\n+\t\t// In -n mode we temporarily swap out the builder's\n+\t\t// print function to capture the command-line. This\n+\t\t// let's us assign it to $LIBGCC and produce a valid\n+\t\t// buildscript for cgo packages.\n+\t\tb.print = func(a ...interface{}) (int, error) {\n+\t\t\treturn fmt.Fprint(&buf, a...)\n+\t\t}\n+\t}\n+\tf, err := b.runOut(p.Dir, p.ImportPath, nil, gccCmd, \"-print-libgcc-file-name\")\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"gcc -print-libgcc-file-name: %v (%s)\", err, f)\n+\t}\n+\tif buildN {\n+\t\ts := fmt.Sprintf(\"LIBGCC=$(%s)\\n\", buf.Next(buf.Len()-1))\n+\t\tb.print = prev\n+\t\tb.print(s)\n+\t\treturn \"$LIBGCC\", nil\n+\t}\n+\n+\t// clang might not be able to find libgcc, and in that case,\n+\t// it will simply return \"libgcc.a\", which is of no use to us.\n+\tif strings.Contains(gccCmd[0], \"clang\") && !filepath.IsAbs(string(f)) {\n+\t\treturn \"\", nil\n+\t}\n+\n+\treturn strings.Trim(string(f), \"\\r\\n\"), nil\n+}\n+\n+// gcc runs the gcc C compiler to create an object from a single C file.\n+func (b *builder) gcc(p *Package, out string, flags []string, cfile string) error {\n+\treturn b.ccompile(p, out, flags, cfile, b.gccCmd(p.Dir))\n+}\n+\n+// gxx runs the g++ C++ compiler to create an object from a single C++ file.\n+func (b *builder) gxx(p *Package, out string, flags []string, cxxfile string) error {\n+\treturn b.ccompile(p, out, flags, cxxfile, b.gxxCmd(p.Dir))\n+}\n+\n+// ccompile runs the given C or C++ compiler and creates an object from a single source file.\n+func (b *builder) ccompile(p *Package, out string, flags []string, file string, compiler []string) error {\n+\tfile = mkAbs(p.Dir, file)\n+\treturn b.run(p.Dir, p.ImportPath, nil, compiler, flags, \"-o\", out, \"-c\", file)\n+}\n+\n+// gccld runs the gcc linker to create an executable from a set of object files.\n+func (b *builder) gccld(p *Package, out string, flags []string, obj []string) error {\n+\tvar cmd []string\n+\tif len(p.CXXFiles) > 0 {\n+\t\tcmd = b.gxxCmd(p.Dir)\n+\t} else {\n+\t\tcmd = b.gccCmd(p.Dir)\n+\t}\n+\treturn b.run(p.Dir, p.ImportPath, nil, cmd, \"-o\", out, obj, flags)\n+}\n+\n+// gccCmd returns a gcc command line prefix\n+// defaultCC is defined in zdefaultcc.go, written by cmd/dist.\n+func (b *builder) gccCmd(objdir string) []string {\n+\treturn b.ccompilerCmd(\"CC\", defaultCC, objdir)\n+}\n+\n+// gxxCmd returns a g++ command line prefix\n+// defaultCXX is defined in zdefaultcc.go, written by cmd/dist.\n+func (b *builder) gxxCmd(objdir string) []string {\n+\treturn b.ccompilerCmd(\"CXX\", defaultCXX, objdir)\n+}\n+\n+// ccompilerCmd returns a command line prefix for the given environment\n+// variable and using the default command when the variable is empty.\n+func (b *builder) ccompilerCmd(envvar, defcmd, objdir string) []string {\n+\t// NOTE: env.go's mkEnv knows that the first three\n+\t// strings returned are \"gcc\", \"-I\", objdir (and cuts them off).\n+\n+\tcompiler := envList(envvar, defcmd)\n+\ta := []string{compiler[0], \"-I\", objdir}\n+\ta = append(a, compiler[1:]...)\n+\n+\t// Definitely want -fPIC but on Windows gcc complains\n+\t// \"-fPIC ignored for target (all code is position independent)\"\n+\tif goos != \"windows\" {\n+\t\ta = append(a, \"-fPIC\")\n+\t}\n+\ta = append(a, b.gccArchArgs()...)\n+\t// gcc-4.5 and beyond require explicit \"-pthread\" flag\n+\t// for multithreading with pthread library.\n+\tif buildContext.CgoEnabled {\n+\t\tswitch goos {\n+\t\tcase \"windows\":\n+\t\t\ta = append(a, \"-mthreads\")\n+\t\tdefault:\n+\t\t\ta = append(a, \"-pthread\")\n+\t\t}\n+\t}\n+\n+\tif strings.Contains(a[0], \"clang\") {\n+\t\t// disable ASCII art in clang errors, if possible\n+\t\ta = append(a, \"-fno-caret-diagnostics\")\n+\t\t// clang is too smart about command-line arguments\n+\t\ta = append(a, \"-Qunused-arguments\")\n+\t}\n+\n+\t// disable word wrapping in error messages\n+\ta = append(a, \"-fmessage-length=0\")\n+\n+\t// On OS X, some of the compilers behave as if -fno-common\n+\t// is always set, and the Mach-O linker in 6l/8l assumes this.\n+\t// See http://golang.org/issue/3253.\n+\tif goos == \"darwin\" {\n+\t\ta = append(a, \"-fno-common\")\n+\t}\n+\n+\treturn a\n+}\n+\n+// gccArchArgs returns arguments to pass to gcc based on the architecture.\n+func (b *builder) gccArchArgs() []string {\n+\tswitch archChar {\n+\tcase \"8\":\n+\t\treturn []string{\"-m32\"}\n+\tcase \"6\":\n+\t\treturn []string{\"-m64\"}\n+\tcase \"5\":\n+\t\treturn []string{\"-marm\"} // not thumb\n+\t}\n+\treturn nil\n+}\n+\n+// envList returns the value of the given environment variable broken\n+// into fields, using the default value when the variable is empty.\n+func envList(key, def string) []string {\n+\tv := os.Getenv(key)\n+\tif v == \"\" {\n+\t\tv = def\n+\t}\n+\treturn strings.Fields(v)\n+}\n+\n+// Return the flags to use when invoking the C or C++ compilers, or cgo.\n+func (b *builder) cflags(p *Package, def bool) (cppflags, cflags, cxxflags, ldflags []string) {\n+\tvar defaults string\n+\tif def {\n+\t\tdefaults = \"-g -O2\"\n+\t}\n+\n+\tcppflags = stringList(envList(\"CGO_CPPFLAGS\", \"\"), p.CgoCPPFLAGS)\n+\tcflags = stringList(envList(\"CGO_CFLAGS\", defaults), p.CgoCFLAGS)\n+\tcxxflags = stringList(envList(\"CGO_CXXFLAGS\", defaults), p.CgoCXXFLAGS)\n+\tldflags = stringList(envList(\"CGO_LDFLAGS\", defaults), p.CgoLDFLAGS)\n+\treturn\n+}\n+\n+var cgoRe = regexp.MustCompile(`[/\\\\:]`)\n+\n+var (\n+\tcgoLibGccFile     string\n+\tcgoLibGccErr      error\n+\tcgoLibGccFileOnce sync.Once\n+)\n+\n+func (b *builder) cgo(p *Package, cgoExe, obj string, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoLDFLAGS := b.cflags(p, true)\n+\t_, cgoexeCFLAGS, _, _ := b.cflags(p, false)\n+\n+\t// If we are compiling Objective-C code, then we need to link against libobjc\n+\tif len(mfiles) > 0 {\n+\t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-lobjc\")\n+\t}\n+\n+\tif pkgs := p.CgoPkgConfig; len(pkgs) > 0 {\n+\t\tout, err := b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--cflags\", pkgs)\n+\t\tif err != nil {\n+\t\t\tb.showOutput(p.Dir, \"pkg-config --cflags \"+strings.Join(pkgs, \" \"), string(out))\n+\t\t\tb.print(err.Error() + \"\\n\")\n+\t\t\treturn nil, nil, errPrintedOutput\n+\t\t}\n+\t\tif len(out) > 0 {\n+\t\t\tcgoCPPFLAGS = append(cgoCPPFLAGS, strings.Fields(string(out))...)\n+\t\t}\n+\t\tout, err = b.runOut(p.Dir, p.ImportPath, nil, \"pkg-config\", \"--libs\", pkgs)\n+\t\tif err != nil {\n+\t\t\tb.showOutput(p.Dir, \"pkg-config --libs \"+strings.Join(pkgs, \" \"), string(out))\n+\t\t\tb.print(err.Error() + \"\\n\")\n+\t\t\treturn nil, nil, errPrintedOutput\n+\t\t}\n+\t\tif len(out) > 0 {\n+\t\t\tcgoLDFLAGS = append(cgoLDFLAGS, strings.Fields(string(out))...)\n+\t\t}\n+\t}\n+\n+\t// Allows including _cgo_export.h from .[ch] files in the package.\n+\tcgoCPPFLAGS = append(cgoCPPFLAGS, \"-I\", obj)\n+\n+\t// cgo\n+\t// TODO: CGOPKGPATH, CGO_FLAGS?\n+\tgofiles := []string{obj + \"_cgo_gotypes.go\"}\n+\tcfiles := []string{\"_cgo_main.c\", \"_cgo_export.c\"}\n+\tfor _, fn := range p.CgoFiles {\n+\t\tf := cgoRe.ReplaceAllString(fn[:len(fn)-2], \"_\")\n+\t\tgofiles = append(gofiles, obj+f+\"cgo1.go\")\n+\t\tcfiles = append(cfiles, f+\"cgo2.c\")\n+\t}\n+\tdefunC := obj + \"_cgo_defun.c\"\n+\n+\tcgoflags := []string{}\n+\t// TODO: make cgo not depend on $GOARCH?\n+\n+\tobjExt := archChar\n+\n+\tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n+\t\tcgoflags = append(cgoflags, \"-import_runtime_cgo=false\")\n+\t}\n+\tif p.Standard && (p.ImportPath == \"runtime/race\" || p.ImportPath == \"runtime/cgo\") {\n+\t\tcgoflags = append(cgoflags, \"-import_syscall=false\")\n+\t}\n+\n+\t// Update $CGO_LDFLAGS with p.CgoLDFLAGS.\n+\tvar cgoenv []string\n+\tif len(cgoLDFLAGS) > 0 {\n+\t\tflags := make([]string, len(cgoLDFLAGS))\n+\t\tfor i, f := range cgoLDFLAGS {\n+\t\t\tflags[i] = strconv.Quote(f)\n+\t\t}\n+\t\tcgoenv = []string{\"CGO_LDFLAGS=\" + strings.Join(flags, \" \")}\n+\t}\n+\n+\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n+\t\tcgoflags = append(cgoflags, \"-gccgo\")\n+\t\tif pkgpath := gccgoPkgpath(p); pkgpath != \"\" {\n+\t\t\tcgoflags = append(cgoflags, \"-gccgopkgpath=\"+pkgpath)\n+\t\t}\n+\t\tobjExt = \"o\"\n+\t}\n+\tif err := b.run(p.Dir, p.ImportPath, cgoenv, cgoExe, \"-objdir\", obj, cgoflags, \"--\", cgoCPPFLAGS, cgoexeCFLAGS, p.CgoFiles); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\toutGo = append(outGo, gofiles...)\n+\n+\t// cc _cgo_defun.c\n+\tdefunObj := obj + \"_cgo_defun.\" + objExt\n+\tif err := buildToolchain.cc(b, p, obj, defunObj, defunC); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\toutObj = append(outObj, defunObj)\n+\n+\t// gcc\n+\tvar linkobj []string\n+\n+\tvar bareLDFLAGS []string\n+\t// filter out -lsomelib, -l somelib, *.{so,dll,dylib}, and (on Darwin) -framework X\n+\tfor i := 0; i < len(cgoLDFLAGS); i++ {\n+\t\tf := cgoLDFLAGS[i]\n+\t\tswitch {\n+\t\t// skip \"-lc\" or \"-l somelib\"\n+\t\tcase strings.HasPrefix(f, \"-l\"):\n+\t\t\tif f == \"-l\" {\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t// skip \"-framework X\" on Darwin\n+\t\tcase goos == \"darwin\" && f == \"-framework\":\n+\t\t\ti++\n+\t\t// skip \"*.{dylib,so,dll}\"\n+\t\tcase strings.HasSuffix(f, \".dylib\"),\n+\t\t\tstrings.HasSuffix(f, \".so\"),\n+\t\t\tstrings.HasSuffix(f, \".dll\"):\n+\t\t\tcontinue\n+\t\tdefault:\n+\t\t\tbareLDFLAGS = append(bareLDFLAGS, f)\n+\t\t}\n+\t}\n+\n+\tcgoLibGccFileOnce.Do(func() {\n+\t\tcgoLibGccFile, cgoLibGccErr = b.libgcc(p)\n+\t})\n+\tif cgoLibGccFile == \"\" && cgoLibGccErr != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar staticLibs []string\n+\tif goos == \"windows\" {\n+\t\t// libmingw32 and libmingwex might also use libgcc, so libgcc must come last,\n+\t\t// and they also have some inter-dependencies, so must use linker groups.\n+\t\tstaticLibs = []string{\"-Wl,--start-group\", \"-lmingwex\", \"-lmingw32\", \"-Wl,--end-group\"}\n+\t}\n+\tif cgoLibGccFile != \"\" {\n+\t\tstaticLibs = append(staticLibs, cgoLibGccFile)\n+\t}\n+\n+\tcflags := stringList(cgoCPPFLAGS, cgoCFLAGS)\n+\tfor _, cfile := range cfiles {\n+\t\tofile := obj + cfile[:len(cfile)-1] + \"o\"\n+\t\tif err := b.gcc(p, ofile, cflags, obj+cfile); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tlinkobj = append(linkobj, ofile)\n+\t\tif !strings.HasSuffix(ofile, \"_cgo_main.o\") {\n+\t\t\toutObj = append(outObj, ofile)\n+\t\t}\n+\t}\n+\n+\tfor _, file := range gccfiles {\n+\t\tofile := obj + cgoRe.ReplaceAllString(file[:len(file)-1], \"_\") + \"o\"\n+\t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tlinkobj = append(linkobj, ofile)\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n+\tcxxflags := stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n+\tfor _, file := range gxxfiles {\n+\t\t// Append .o to the file, just in case the pkg has file.c and file.cpp\n+\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tif err := b.gxx(p, ofile, cxxflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tlinkobj = append(linkobj, ofile)\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n+\tfor _, file := range mfiles {\n+\t\t// Append .o to the file, just in case the pkg has file.c and file.m\n+\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tlinkobj = append(linkobj, ofile)\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n+\tlinkobj = append(linkobj, p.SysoFiles...)\n+\tdynobj := obj + \"_cgo_.o\"\n+\tif goarch == \"arm\" && goos == \"linux\" { // we need to use -pie for Linux/ARM to get accurate imported sym\n+\t\tcgoLDFLAGS = append(cgoLDFLAGS, \"-pie\")\n+\t}\n+\tif err := b.gccld(p, dynobj, cgoLDFLAGS, linkobj); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tif goarch == \"arm\" && goos == \"linux\" { // but we don't need -pie for normal cgo programs\n+\t\tcgoLDFLAGS = cgoLDFLAGS[0 : len(cgoLDFLAGS)-1]\n+\t}\n+\n+\tif _, ok := buildToolchain.(gccgoToolchain); ok {\n+\t\t// we don't use dynimport when using gccgo.\n+\t\treturn outGo, outObj, nil\n+\t}\n+\n+\t// cgo -dynimport\n+\timportC := obj + \"_cgo_import.c\"\n+\tcgoflags = []string{}\n+\tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n+\t\tcgoflags = append(cgoflags, \"-dynlinker\") // record path to dynamic linker\n+\t}\n+\tif err := b.run(p.Dir, p.ImportPath, nil, cgoExe, \"-objdir\", obj, \"-dynimport\", dynobj, \"-dynout\", importC, cgoflags); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\t// cc _cgo_import.ARCH\n+\timportObj := obj + \"_cgo_import.\" + objExt\n+\tif err := buildToolchain.cc(b, p, obj, importObj, importC); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tofile := obj + \"_all.o\"\n+\tvar gccObjs, nonGccObjs []string\n+\tfor _, f := range outObj {\n+\t\tif strings.HasSuffix(f, \".o\") {\n+\t\t\tgccObjs = append(gccObjs, f)\n+\t\t} else {\n+\t\t\tnonGccObjs = append(nonGccObjs, f)\n+\t\t}\n+\t}\n+\tif err := b.gccld(p, ofile, stringList(bareLDFLAGS, \"-Wl,-r\", \"-nostdlib\", staticLibs), gccObjs); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\t// NOTE(rsc): The importObj is a 5c/6c/8c object and on Windows\n+\t// must be processed before the gcc-generated objects.\n+\t// Put it first.  http://golang.org/issue/2601\n+\toutObj = stringList(importObj, nonGccObjs, ofile)\n+\n+\treturn outGo, outObj, nil\n+}\n+\n+// Run SWIG on all SWIG input files.\n+// TODO: Don't build a shared library, once SWIG emits the necessary\n+// pragmas for external linking.\n+func (b *builder) swig(p *Package, obj string, gccfiles, gxxfiles, mfiles []string) (outGo, outObj []string, err error) {\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n+\tcflags := stringList(cgoCPPFLAGS, cgoCFLAGS)\n+\tcxxflags := stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n+\n+\tfor _, file := range gccfiles {\n+\t\tofile := obj + cgoRe.ReplaceAllString(file[:len(file)-1], \"_\") + \"o\"\n+\t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n+\tfor _, file := range gxxfiles {\n+\t\t// Append .o to the file, just in case the pkg has file.c and file.cpp\n+\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tif err := b.gxx(p, ofile, cxxflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n+\tfor _, file := range mfiles {\n+\t\t// Append .o to the file, just in case the pkg has file.c and file.cpp\n+\t\tofile := obj + cgoRe.ReplaceAllString(file, \"_\") + \".o\"\n+\t\tif err := b.gcc(p, ofile, cflags, file); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\toutObj = append(outObj, ofile)\n+\t}\n+\n+\tif err := b.swigVersionCheck(); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tintgosize, err := b.swigIntSize(obj)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tfor _, f := range p.SwigFiles {\n+\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, false, intgosize)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tif goFile != \"\" {\n+\t\t\toutGo = append(outGo, goFile)\n+\t\t}\n+\t\tif objFile != \"\" {\n+\t\t\toutObj = append(outObj, objFile)\n+\t\t}\n+\t\tif gccObjFile != \"\" {\n+\t\t\toutObj = append(outObj, gccObjFile)\n+\t\t}\n+\t}\n+\tfor _, f := range p.SwigCXXFiles {\n+\t\tgoFile, objFile, gccObjFile, err := b.swigOne(p, f, obj, true, intgosize)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tif goFile != \"\" {\n+\t\t\toutGo = append(outGo, goFile)\n+\t\t}\n+\t\tif objFile != \"\" {\n+\t\t\toutObj = append(outObj, objFile)\n+\t\t}\n+\t\tif gccObjFile != \"\" {\n+\t\t\toutObj = append(outObj, gccObjFile)\n+\t\t}\n+\t}\n+\treturn outGo, outObj, nil\n+}\n+\n+// Make sure SWIG is new enough.\n+var (\n+\tswigCheckOnce sync.Once\n+\tswigCheck     error\n+)\n+\n+func (b *builder) swigDoVersionCheck() error {\n+\tout, err := b.runOut(\"\", \"\", nil, \"swig\", \"-version\")\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tre := regexp.MustCompile(`[vV]ersion +([\\d])`)\n+\tmatches := re.FindSubmatch(out)\n+\tif matches == nil {\n+\t\t// Can't find version number; hope for the best.\n+\t\treturn nil\n+\t}\n+\tmajor, err := strconv.Atoi(string(matches[1]))\n+\tif err != nil {\n+\t\t// Can't find version number; hope for the best.\n+\t\treturn nil\n+\t}\n+\tif major < 3 {\n+\t\treturn errors.New(\"must have SWIG version >= 3.0\")\n+\t}\n+\treturn nil\n+}\n+\n+func (b *builder) swigVersionCheck() error {\n+\tswigCheckOnce.Do(func() {\n+\t\tswigCheck = b.swigDoVersionCheck()\n+\t})\n+\treturn swigCheck\n+}\n+\n+// This code fails to build if sizeof(int) <= 32\n+const swigIntSizeCode = `\n+package main\n+const i int = 1 << 32\n+`\n+\n+// Determine the size of int on the target system for the -intgosize option\n+// of swig >= 2.0.9\n+func (b *builder) swigIntSize(obj string) (intsize string, err error) {\n+\tif buildN {\n+\t\treturn \"$INTBITS\", nil\n+\t}\n+\tsrc := filepath.Join(b.work, \"swig_intsize.go\")\n+\tif err = ioutil.WriteFile(src, []byte(swigIntSizeCode), 0644); err != nil {\n+\t\treturn\n+\t}\n+\tsrcs := []string{src}\n+\n+\tp := goFilesPackage(srcs)\n+\n+\tif _, _, e := buildToolchain.gc(b, p, \"\", obj, nil, srcs); e != nil {\n+\t\treturn \"32\", nil\n+\t}\n+\treturn \"64\", nil\n+}\n+\n+// Run SWIG on one SWIG input file.\n+func (b *builder) swigOne(p *Package, file, obj string, cxx bool, intgosize string) (outGo, outObj, objGccObj string, err error) {\n+\tcgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _ := b.cflags(p, true)\n+\tvar cflags []string\n+\tif cxx {\n+\t\tcflags = stringList(cgoCPPFLAGS, cgoCXXFLAGS)\n+\t} else {\n+\t\tcflags = stringList(cgoCPPFLAGS, cgoCFLAGS)\n+\t}\n+\n+\tn := 5 // length of \".swig\"\n+\tif cxx {\n+\t\tn = 8 // length of \".swigcxx\"\n+\t}\n+\tbase := file[:len(file)-n]\n+\tgoFile := base + \".go\"\n+\tcBase := base + \"_gc.\"\n+\tgccBase := base + \"_wrap.\"\n+\tgccExt := \"c\"\n+\tif cxx {\n+\t\tgccExt = \"cxx\"\n+\t}\n+\n+\t_, gccgo := buildToolchain.(gccgoToolchain)\n+\n+\t// swig\n+\targs := []string{\n+\t\t\"-go\",\n+\t\t\"-intgosize\", intgosize,\n+\t\t\"-module\", base,\n+\t\t\"-o\", obj + gccBase + gccExt,\n+\t\t\"-outdir\", obj,\n+\t}\n+\tif gccgo {\n+\t\targs = append(args, \"-gccgo\")\n+\t\tif pkgpath := gccgoPkgpath(p); pkgpath != \"\" {\n+\t\t\targs = append(args, \"-go-pkgpath\", pkgpath)\n+\t\t}\n+\t}\n+\tif cxx {\n+\t\targs = append(args, \"-c++\")\n+\t}\n+\n+\tif out, err := b.runOut(p.Dir, p.ImportPath, nil, \"swig\", args, file); err != nil {\n+\t\tif len(out) > 0 {\n+\t\t\tif bytes.Contains(out, []byte(\"Unrecognized option -intgosize\")) {\n+\t\t\t\treturn \"\", \"\", \"\", errors.New(\"must have SWIG version >= 3.0\")\n+\t\t\t}\n+\t\t\tb.showOutput(p.Dir, p.ImportPath, b.processOutput(out))\n+\t\t\treturn \"\", \"\", \"\", errPrintedOutput\n+\t\t}\n+\t\treturn \"\", \"\", \"\", err\n+\t}\n+\n+\tvar cObj string\n+\tif !gccgo {\n+\t\t// cc\n+\t\tcObj = obj + cBase + archChar\n+\t\tif err := buildToolchain.cc(b, p, obj, cObj, obj+cBase+\"c\"); err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n+\t\t}\n+\t}\n+\n+\t// gcc\n+\tgccObj := obj + gccBase + \"o\"\n+\tif !cxx {\n+\t\tif err := b.gcc(p, gccObj, cflags, obj+gccBase+gccExt); err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n+\t\t}\n+\t} else {\n+\t\tif err := b.gxx(p, gccObj, cflags, obj+gccBase+gccExt); err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n+\t\t}\n+\t}\n+\n+\treturn obj + goFile, cObj, gccObj, nil\n+}\n+\n+// An actionQueue is a priority queue of actions.\n+type actionQueue []*action\n+\n+// Implement heap.Interface\n+func (q *actionQueue) Len() int           { return len(*q) }\n+func (q *actionQueue) Swap(i, j int)      { (*q)[i], (*q)[j] = (*q)[j], (*q)[i] }\n+func (q *actionQueue) Less(i, j int) bool { return (*q)[i].priority < (*q)[j].priority }\n+func (q *actionQueue) Push(x interface{}) { *q = append(*q, x.(*action)) }\n+func (q *actionQueue) Pop() interface{} {\n+\tn := len(*q) - 1\n+\tx := (*q)[n]\n+\t*q = (*q)[:n]\n+\treturn x\n+}\n+\n+func (q *actionQueue) push(a *action) {\n+\theap.Push(q, a)\n+}\n+\n+func (q *actionQueue) pop() *action {\n+\treturn heap.Pop(q).(*action)\n+}\n+\n+func raceInit() {\n+\tif !buildRace {\n+\t\treturn\n+\t}\n+\tif goarch != \"amd64\" || goos != \"linux\" && goos != \"darwin\" && goos != \"windows\" {\n+\t\tfmt.Fprintf(os.Stderr, \"go %s: -race is only supported on linux/amd64, darwin/amd64 and windows/amd64\\n\", flag.Args()[0])\n+\t\tos.Exit(2)\n+\t}\n+\tbuildGcflags = append(buildGcflags, \"-race\")\n+\tbuildLdflags = append(buildLdflags, \"-race\")\n+\tbuildCcflags = append(buildCcflags, \"-D\", \"RACE\")\n+\tif buildContext.InstallSuffix != \"\" {\n+\t\tbuildContext.InstallSuffix += \"_\"\n+\t}\n+\tbuildContext.InstallSuffix += \"race\"\n+\tbuildContext.BuildTags = append(buildContext.BuildTags, \"race\")\n+}\n+\n+// defaultSuffix returns file extension used for command files in\n+// current os environment.\n+func defaultSuffix() string {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\treturn \".bat\"\n+\tcase \"plan9\":\n+\t\treturn \".rc\"\n+\tdefault:\n+\t\treturn \".bash\"\n+\t}\n+}"}, {"sha": "16054a5b5bc33869a78ac1eaac2fe4a19c6a8587", "filename": "libgo/go/cmd/go/clean.go", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fclean.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,248 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+var cmdClean = &Command{\n+\tUsageLine: \"clean [-i] [-r] [-n] [-x] [build flags] [packages]\",\n+\tShort:     \"remove object files\",\n+\tLong: `\n+Clean removes object files from package source directories.\n+The go command builds most objects in a temporary directory,\n+so go clean is mainly concerned with object files left by other\n+tools or by manual invocations of go build.\n+\n+Specifically, clean removes the following files from each of the\n+source directories corresponding to the import paths:\n+\n+\t_obj/            old object directory, left from Makefiles\n+\t_test/           old test directory, left from Makefiles\n+\t_testmain.go     old gotest file, left from Makefiles\n+\ttest.out         old test log, left from Makefiles\n+\tbuild.out        old test log, left from Makefiles\n+\t*.[568ao]        object files, left from Makefiles\n+\n+\tDIR(.exe)        from go build\n+\tDIR.test(.exe)   from go test -c\n+\tMAINFILE(.exe)   from go build MAINFILE.go\n+\t*.so             from SWIG\n+\n+In the list, DIR represents the final path element of the\n+directory, and MAINFILE is the base name of any Go source\n+file in the directory that is not included when building\n+the package.\n+\n+The -i flag causes clean to remove the corresponding installed\n+archive or binary (what 'go install' would create).\n+\n+The -n flag causes clean to print the remove commands it would execute,\n+but not run them.\n+\n+The -r flag causes clean to be applied recursively to all the\n+dependencies of the packages named by the import paths.\n+\n+The -x flag causes clean to print remove commands as it executes them.\n+\n+For more about build flags, see 'go help build'.\n+\n+For more about specifying packages, see 'go help packages'.\n+\t`,\n+}\n+\n+var cleanI bool // clean -i flag\n+var cleanR bool // clean -r flag\n+\n+func init() {\n+\t// break init cycle\n+\tcmdClean.Run = runClean\n+\n+\tcmdClean.Flag.BoolVar(&cleanI, \"i\", false, \"\")\n+\tcmdClean.Flag.BoolVar(&cleanR, \"r\", false, \"\")\n+\t// -n and -x are important enough to be\n+\t// mentioned explicitly in the docs but they\n+\t// are part of the build flags.\n+\n+\taddBuildFlags(cmdClean)\n+}\n+\n+func runClean(cmd *Command, args []string) {\n+\tfor _, pkg := range packagesAndErrors(args) {\n+\t\tclean(pkg)\n+\t}\n+}\n+\n+var cleaned = map[*Package]bool{}\n+\n+// TODO: These are dregs left by Makefile-based builds.\n+// Eventually, can stop deleting these.\n+var cleanDir = map[string]bool{\n+\t\"_test\": true,\n+\t\"_obj\":  true,\n+}\n+\n+var cleanFile = map[string]bool{\n+\t\"_testmain.go\": true,\n+\t\"test.out\":     true,\n+\t\"build.out\":    true,\n+\t\"a.out\":        true,\n+}\n+\n+var cleanExt = map[string]bool{\n+\t\".5\":  true,\n+\t\".6\":  true,\n+\t\".8\":  true,\n+\t\".a\":  true,\n+\t\".o\":  true,\n+\t\".so\": true,\n+}\n+\n+func clean(p *Package) {\n+\tif cleaned[p] {\n+\t\treturn\n+\t}\n+\tcleaned[p] = true\n+\n+\tif p.Dir == \"\" {\n+\t\terrorf(\"can't load package: %v\", p.Error)\n+\t\treturn\n+\t}\n+\tdirs, err := ioutil.ReadDir(p.Dir)\n+\tif err != nil {\n+\t\terrorf(\"go clean %s: %v\", p.Dir, err)\n+\t\treturn\n+\t}\n+\n+\tvar b builder\n+\tb.print = fmt.Print\n+\n+\tpackageFile := map[string]bool{}\n+\tif p.Name != \"main\" {\n+\t\t// Record which files are not in package main.\n+\t\t// The others are.\n+\t\tkeep := func(list []string) {\n+\t\t\tfor _, f := range list {\n+\t\t\t\tpackageFile[f] = true\n+\t\t\t}\n+\t\t}\n+\t\tkeep(p.GoFiles)\n+\t\tkeep(p.CgoFiles)\n+\t\tkeep(p.TestGoFiles)\n+\t\tkeep(p.XTestGoFiles)\n+\t}\n+\n+\t_, elem := filepath.Split(p.Dir)\n+\tvar allRemove []string\n+\n+\t// Remove dir-named executable only if this is package main.\n+\tif p.Name == \"main\" {\n+\t\tallRemove = append(allRemove,\n+\t\t\telem,\n+\t\t\telem+\".exe\",\n+\t\t)\n+\t}\n+\n+\t// Remove package test executables.\n+\tallRemove = append(allRemove,\n+\t\telem+\".test\",\n+\t\telem+\".test.exe\",\n+\t)\n+\n+\t// Remove a potential executable for each .go file in the directory that\n+\t// is not part of the directory's package.\n+\tfor _, dir := range dirs {\n+\t\tname := dir.Name()\n+\t\tif packageFile[name] {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !dir.IsDir() && strings.HasSuffix(name, \".go\") {\n+\t\t\t// TODO(adg,rsc): check that this .go file is actually\n+\t\t\t// in \"package main\", and therefore capable of building\n+\t\t\t// to an executable file.\n+\t\t\tbase := name[:len(name)-len(\".go\")]\n+\t\t\tallRemove = append(allRemove, base, base+\".exe\")\n+\t\t}\n+\t}\n+\n+\tif buildN || buildX {\n+\t\tb.showcmd(p.Dir, \"rm -f %s\", strings.Join(allRemove, \" \"))\n+\t}\n+\n+\ttoRemove := map[string]bool{}\n+\tfor _, name := range allRemove {\n+\t\ttoRemove[name] = true\n+\t}\n+\tfor _, dir := range dirs {\n+\t\tname := dir.Name()\n+\t\tif dir.IsDir() {\n+\t\t\t// TODO: Remove once Makefiles are forgotten.\n+\t\t\tif cleanDir[name] {\n+\t\t\t\tif buildN || buildX {\n+\t\t\t\t\tb.showcmd(p.Dir, \"rm -r %s\", name)\n+\t\t\t\t\tif buildN {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif err := os.RemoveAll(filepath.Join(p.Dir, name)); err != nil {\n+\t\t\t\t\terrorf(\"go clean: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif buildN {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif cleanFile[name] || cleanExt[filepath.Ext(name)] || toRemove[name] {\n+\t\t\tremoveFile(filepath.Join(p.Dir, name))\n+\t\t}\n+\t}\n+\n+\tif cleanI && p.target != \"\" {\n+\t\tif buildN || buildX {\n+\t\t\tb.showcmd(\"\", \"rm -f %s\", p.target)\n+\t\t}\n+\t\tif !buildN {\n+\t\t\tremoveFile(p.target)\n+\t\t}\n+\t}\n+\n+\tif cleanR {\n+\t\tfor _, p1 := range p.imports {\n+\t\t\tclean(p1)\n+\t\t}\n+\t}\n+}\n+\n+// removeFile tries to remove file f, if error other than file doesn't exist\n+// occurs, it will report the error.\n+func removeFile(f string) {\n+\terr := os.Remove(f)\n+\tif err == nil || os.IsNotExist(err) {\n+\t\treturn\n+\t}\n+\t// Windows does not allow deletion of a binary file while it is executing.\n+\tif toolIsWindows {\n+\t\t// Remove lingering ~ file from last attempt.\n+\t\tif _, err2 := os.Stat(f + \"~\"); err2 == nil {\n+\t\t\tos.Remove(f + \"~\")\n+\t\t}\n+\t\t// Try to move it out of the way. If the move fails,\n+\t\t// which is likely, we'll try again the\n+\t\t// next time we do an install of this binary.\n+\t\tif err2 := os.Rename(f, f+\"~\"); err2 == nil {\n+\t\t\tos.Remove(f + \"~\")\n+\t\t\treturn\n+\t\t}\n+\t}\n+\terrorf(\"go clean: %v\", err)\n+}"}, {"sha": "68e518259f45b3798db7e738808ca0aafc038b37", "filename": "libgo/go/cmd/go/context.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fcontext.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"go/build\"\n+)\n+\n+type Context struct {\n+\tGOARCH        string   `json:\",omitempty\"` // target architecture\n+\tGOOS          string   `json:\",omitempty\"` // target operating system\n+\tGOROOT        string   `json:\",omitempty\"` // Go root\n+\tGOPATH        string   `json:\",omitempty\"` // Go path\n+\tCgoEnabled    bool     `json:\",omitempty\"` // whether cgo can be used\n+\tUseAllFiles   bool     `json:\",omitempty\"` // use files regardless of +build lines, file names\n+\tCompiler      string   `json:\",omitempty\"` // compiler to assume when computing target paths\n+\tBuildTags     []string `json:\",omitempty\"` // build constraints to match in +build lines\n+\tReleaseTags   []string `json:\",omitempty\"` // releases the current release is compatible with\n+\tInstallSuffix string   `json:\",omitempty\"` // suffix to use in the name of the install dir\n+}\n+\n+func newContext(c *build.Context) *Context {\n+\treturn &Context{\n+\t\tGOARCH:        c.GOARCH,\n+\t\tGOOS:          c.GOOS,\n+\t\tGOROOT:        c.GOROOT,\n+\t\tCgoEnabled:    c.CgoEnabled,\n+\t\tUseAllFiles:   c.UseAllFiles,\n+\t\tCompiler:      c.Compiler,\n+\t\tBuildTags:     c.BuildTags,\n+\t\tReleaseTags:   c.ReleaseTags,\n+\t\tInstallSuffix: c.InstallSuffix,\n+\t}\n+}"}, {"sha": "b9f42799546e306f8f3762d00d2c6d273d3e50a2", "filename": "libgo/go/cmd/go/discovery.go", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdiscovery.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !cmd_go_bootstrap\n+\n+// This code is compiled into the real 'go' binary, but it is not\n+// compiled into the binary that is built during all.bash, so as\n+// to avoid needing to build net (and thus use cgo) during the\n+// bootstrap process.\n+\n+package main\n+\n+import (\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+)\n+\n+// charsetReader returns a reader for the given charset. Currently\n+// it only supports UTF-8 and ASCII. Otherwise, it returns a meaningful\n+// error which is printed by go get, so the user can find why the package\n+// wasn't downloaded if the encoding is not supported. Note that, in\n+// order to reduce potential errors, ASCII is treated as UTF-8 (i.e. characters\n+// greater than 0x7f are not rejected).\n+func charsetReader(charset string, input io.Reader) (io.Reader, error) {\n+\tswitch strings.ToLower(charset) {\n+\tcase \"ascii\":\n+\t\treturn input, nil\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"can't decode XML document using charset %q\", charset)\n+\t}\n+}\n+\n+// parseMetaGoImports returns meta imports from the HTML in r.\n+// Parsing ends at the end of the <head> section or the beginning of the <body>.\n+func parseMetaGoImports(r io.Reader) (imports []metaImport, err error) {\n+\td := xml.NewDecoder(r)\n+\td.CharsetReader = charsetReader\n+\td.Strict = false\n+\tvar t xml.Token\n+\tfor {\n+\t\tt, err = d.Token()\n+\t\tif err != nil {\n+\t\t\tif err == io.EOF {\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tif e, ok := t.(xml.StartElement); ok && strings.EqualFold(e.Name.Local, \"body\") {\n+\t\t\treturn\n+\t\t}\n+\t\tif e, ok := t.(xml.EndElement); ok && strings.EqualFold(e.Name.Local, \"head\") {\n+\t\t\treturn\n+\t\t}\n+\t\te, ok := t.(xml.StartElement)\n+\t\tif !ok || !strings.EqualFold(e.Name.Local, \"meta\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif attrValue(e.Attr, \"name\") != \"go-import\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f := strings.Fields(attrValue(e.Attr, \"content\")); len(f) == 3 {\n+\t\t\timports = append(imports, metaImport{\n+\t\t\t\tPrefix:   f[0],\n+\t\t\t\tVCS:      f[1],\n+\t\t\t\tRepoRoot: f[2],\n+\t\t\t})\n+\t\t}\n+\t}\n+}\n+\n+// attrValue returns the attribute value for the case-insensitive key\n+// `name', or the empty string if nothing is found.\n+func attrValue(attrs []xml.Attr, name string) string {\n+\tfor _, a := range attrs {\n+\t\tif strings.EqualFold(a.Name.Local, name) {\n+\t\t\treturn a.Value\n+\t\t}\n+\t}\n+\treturn \"\"\n+}"}, {"sha": "9840804ce74c9e81e7ae971b34ed550a2b6974a1", "filename": "libgo/go/cmd/go/doc.go", "status": "added", "additions": 990, "deletions": 0, "changes": 990, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fdoc.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,990 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// DO NOT EDIT THIS FILE. GENERATED BY mkdoc.sh.\n+// Edit the documentation in other files and rerun mkdoc.sh to generate this one.\n+\n+/*\n+Go is a tool for managing Go source code.\n+\n+Usage:\n+\n+\tgo command [arguments]\n+\n+The commands are:\n+\n+    build       compile packages and dependencies\n+    clean       remove object files\n+    env         print Go environment information\n+    fix         run go tool fix on packages\n+    fmt         run gofmt on package sources\n+    get         download and install packages and dependencies\n+    install     compile and install packages and dependencies\n+    list        list packages\n+    run         compile and run Go program\n+    test        test packages\n+    tool        run specified go tool\n+    version     print Go version\n+    vet         run go tool vet on packages\n+\n+Use \"go help [command]\" for more information about a command.\n+\n+Additional help topics:\n+\n+    c           calling between Go and C\n+    filetype    file types\n+    gopath      GOPATH environment variable\n+    importpath  import path syntax\n+    packages    description of package lists\n+    testflag    description of testing flags\n+    testfunc    description of testing functions\n+\n+Use \"go help [topic]\" for more information about that topic.\n+\n+\n+Compile packages and dependencies\n+\n+Usage:\n+\n+\tgo build [-o output] [-i] [build flags] [packages]\n+\n+Build compiles the packages named by the import paths,\n+along with their dependencies, but it does not install the results.\n+\n+If the arguments are a list of .go files, build treats them as a list\n+of source files specifying a single package.\n+\n+When the command line specifies a single main package,\n+build writes the resulting executable to output.\n+Otherwise build compiles the packages but discards the results,\n+serving only as a check that the packages can be built.\n+\n+The -o flag specifies the output file name. If not specified, the\n+output file name depends on the arguments and derives from the name\n+of the package, such as p.a for package p, unless p is 'main'. If\n+the package is main and file names are provided, the file name\n+derives from the first file name mentioned, such as f1 for 'go build\n+f1.go f2.go'; with no files provided ('go build'), the output file\n+name is the base name of the containing directory.\n+\n+The -i flag installs the packages that are dependencies of the target.\n+\n+The build flags are shared by the build, clean, get, install, list, run,\n+and test commands:\n+\n+\t-a\n+\t\tforce rebuilding of packages that are already up-to-date.\n+\t-n\n+\t\tprint the commands but do not run them.\n+\t-p n\n+\t\tthe number of builds that can be run in parallel.\n+\t\tThe default is the number of CPUs available.\n+\t-race\n+\t\tenable data race detection.\n+\t\tSupported only on linux/amd64, darwin/amd64 and windows/amd64.\n+\t-v\n+\t\tprint the names of packages as they are compiled.\n+\t-work\n+\t\tprint the name of the temporary work directory and\n+\t\tdo not delete it when exiting.\n+\t-x\n+\t\tprint the commands.\n+\n+\t-ccflags 'arg list'\n+\t\targuments to pass on each 5c, 6c, or 8c compiler invocation.\n+\t-compiler name\n+\t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n+\t-gccgoflags 'arg list'\n+\t\targuments to pass on each gccgo compiler/linker invocation.\n+\t-gcflags 'arg list'\n+\t\targuments to pass on each 5g, 6g, or 8g compiler invocation.\n+\t-installsuffix suffix\n+\t\ta suffix to use in the name of the package installation directory,\n+\t\tin order to keep output separate from default builds.\n+\t\tIf using the -race flag, the install suffix is automatically set to race\n+\t\tor, if set explicitly, has _race appended to it.\n+\t-ldflags 'flag list'\n+\t\targuments to pass on each 5l, 6l, or 8l linker invocation.\n+\t-tags 'tag list'\n+\t\ta list of build tags to consider satisfied during the build.\n+\t\tFor more information about build tags, see the description of\n+\t\tbuild constraints in the documentation for the go/build package.\n+\n+The list flags accept a space-separated list of strings. To embed spaces\n+in an element in the list, surround it with either single or double quotes.\n+\n+For more about specifying packages, see 'go help packages'.\n+For more about where packages and binaries are installed,\n+run 'go help gopath'.  For more about calling between Go and C/C++,\n+run 'go help c'.\n+\n+See also: go install, go get, go clean.\n+\n+\n+Remove object files\n+\n+Usage:\n+\n+\tgo clean [-i] [-r] [-n] [-x] [build flags] [packages]\n+\n+Clean removes object files from package source directories.\n+The go command builds most objects in a temporary directory,\n+so go clean is mainly concerned with object files left by other\n+tools or by manual invocations of go build.\n+\n+Specifically, clean removes the following files from each of the\n+source directories corresponding to the import paths:\n+\n+\t_obj/            old object directory, left from Makefiles\n+\t_test/           old test directory, left from Makefiles\n+\t_testmain.go     old gotest file, left from Makefiles\n+\ttest.out         old test log, left from Makefiles\n+\tbuild.out        old test log, left from Makefiles\n+\t*.[568ao]        object files, left from Makefiles\n+\n+\tDIR(.exe)        from go build\n+\tDIR.test(.exe)   from go test -c\n+\tMAINFILE(.exe)   from go build MAINFILE.go\n+\t*.so             from SWIG\n+\n+In the list, DIR represents the final path element of the\n+directory, and MAINFILE is the base name of any Go source\n+file in the directory that is not included when building\n+the package.\n+\n+The -i flag causes clean to remove the corresponding installed\n+archive or binary (what 'go install' would create).\n+\n+The -n flag causes clean to print the remove commands it would execute,\n+but not run them.\n+\n+The -r flag causes clean to be applied recursively to all the\n+dependencies of the packages named by the import paths.\n+\n+The -x flag causes clean to print remove commands as it executes them.\n+\n+For more about build flags, see 'go help build'.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+\n+Print Go environment information\n+\n+Usage:\n+\n+\tgo env [var ...]\n+\n+Env prints Go environment information.\n+\n+By default env prints information as a shell script\n+(on Windows, a batch file).  If one or more variable\n+names is given as arguments,  env prints the value of\n+each named variable on its own line.\n+\n+\n+Run go tool fix on packages\n+\n+Usage:\n+\n+\tgo fix [packages]\n+\n+Fix runs the Go fix command on the packages named by the import paths.\n+\n+For more about fix, see 'godoc fix'.\n+For more about specifying packages, see 'go help packages'.\n+\n+To run fix with specific options, run 'go tool fix'.\n+\n+See also: go fmt, go vet.\n+\n+\n+Run gofmt on package sources\n+\n+Usage:\n+\n+\tgo fmt [-n] [-x] [packages]\n+\n+Fmt runs the command 'gofmt -l -w' on the packages named\n+by the import paths.  It prints the names of the files that are modified.\n+\n+For more about gofmt, see 'godoc gofmt'.\n+For more about specifying packages, see 'go help packages'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+To run gofmt with specific options, run gofmt itself.\n+\n+See also: go fix, go vet.\n+\n+\n+Download and install packages and dependencies\n+\n+Usage:\n+\n+\tgo get [-d] [-fix] [-t] [-u] [build flags] [packages]\n+\n+Get downloads and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+The -d flag instructs get to stop after downloading the packages; that is,\n+it instructs get not to install the packages.\n+\n+The -fix flag instructs get to run the fix tool on the downloaded packages\n+before resolving dependencies or building the code.\n+\n+The -t flag instructs get to also download the packages required to build\n+the tests for the specified packages.\n+\n+The -u flag instructs get to use the network to update the named packages\n+and their dependencies.  By default, get uses the network to check out\n+missing packages but does not use it to look for updates to existing packages.\n+\n+Get also accepts build flags to control the installation. See 'go help build'.\n+\n+When checking out or updating a package, get looks for a branch or tag\n+that matches the locally installed version of Go. The most important\n+rule is that if the local installation is running version \"go1\", get\n+searches for a branch or tag named \"go1\". If no such version exists it\n+retrieves the most recent version of the package.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+For more about how 'go get' finds source code to\n+download, see 'go help importpath'.\n+\n+See also: go build, go install, go clean.\n+\n+\n+Compile and install packages and dependencies\n+\n+Usage:\n+\n+\tgo install [build flags] [packages]\n+\n+Install compiles and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+For more about the build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go get, go clean.\n+\n+\n+List packages\n+\n+Usage:\n+\n+\tgo list [-e] [-f format] [-json] [build flags] [packages]\n+\n+List lists the packages named by the import paths, one per line.\n+\n+The default output shows the package import path:\n+\n+    code.google.com/p/google-api-go-client/books/v1\n+    code.google.com/p/goauth2/oauth\n+    code.google.com/p/sqlite\n+\n+The -f flag specifies an alternate format for the list, using the\n+syntax of package template.  The default output is equivalent to -f\n+'{{.ImportPath}}'. The struct being passed to the template is:\n+\n+    type Package struct {\n+        Dir        string // directory containing package sources\n+        ImportPath string // import path of package in dir\n+        Name       string // package name\n+        Doc        string // package documentation string\n+        Target     string // install path\n+        Goroot     bool   // is this package in the Go root?\n+        Standard   bool   // is this package part of the standard Go library?\n+        Stale      bool   // would 'go install' do anything for this package?\n+        Root       string // Go root or Go path dir containing this package\n+\n+        // Source files\n+        GoFiles  []string       // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles []string       // .go sources files that import \"C\"\n+        IgnoredGoFiles []string // .go sources ignored due to build constraints\n+        CFiles   []string       // .c source files\n+        CXXFiles []string       // .cc, .cxx and .cpp source files\n+        MFiles   []string       // .m source files\n+        HFiles   []string       // .h, .hh, .hpp and .hxx source files\n+        SFiles   []string       // .s source files\n+        SwigFiles []string      // .swig files\n+        SwigCXXFiles []string   // .swigcxx files\n+        SysoFiles []string      // .syso object files to add to archive\n+\n+        // Cgo directives\n+        CgoCFLAGS    []string // cgo: flags for C compiler\n+        CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n+        CgoCXXFLAGS  []string // cgo: flags for C++ compiler\n+        CgoLDFLAGS   []string // cgo: flags for linker\n+        CgoPkgConfig []string // cgo: pkg-config names\n+\n+        // Dependency information\n+        Imports []string // import paths used by this package\n+        Deps    []string // all (recursively) imported dependencies\n+\n+        // Error information\n+        Incomplete bool            // this package or a dependency has an error\n+        Error      *PackageError   // error loading package\n+        DepsErrors []*PackageError // errors loading dependencies\n+\n+        TestGoFiles  []string // _test.go files in package\n+        TestImports  []string // imports from TestGoFiles\n+        XTestGoFiles []string // _test.go files outside package\n+        XTestImports []string // imports from XTestGoFiles\n+    }\n+\n+The template function \"join\" calls strings.Join.\n+\n+The template function \"context\" returns the build context, defined as:\n+\n+\ttype Context struct {\n+\t\tGOARCH        string   // target architecture\n+\t\tGOOS          string   // target operating system\n+\t\tGOROOT        string   // Go root\n+\t\tGOPATH        string   // Go path\n+\t\tCgoEnabled    bool     // whether cgo can be used\n+\t\tUseAllFiles   bool     // use files regardless of +build lines, file names\n+\t\tCompiler      string   // compiler to assume when computing target paths\n+\t\tBuildTags     []string // build constraints to match in +build lines\n+\t\tReleaseTags   []string // releases the current release is compatible with\n+\t\tInstallSuffix string   // suffix to use in the name of the install dir\n+\t}\n+\n+For more information about the meaning of these fields see the documentation\n+for the go/build package's Context type.\n+\n+The -json flag causes the package data to be printed in JSON format\n+instead of using the template format.\n+\n+The -e flag changes the handling of erroneous packages, those that\n+cannot be found or are malformed.  By default, the list command\n+prints an error to standard error for each erroneous package and\n+omits the packages from consideration during the usual printing.\n+With the -e flag, the list command never prints errors to standard\n+error and instead processes the erroneous packages with the usual\n+printing.  Erroneous packages will have a non-empty ImportPath and\n+a non-nil Error field; other information may or may not be missing\n+(zeroed).\n+\n+For more about build flags, see 'go help build'.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+\n+Compile and run Go program\n+\n+Usage:\n+\n+\tgo run [build flags] [-exec xprog] gofiles... [arguments...]\n+\n+Run compiles and runs the main package comprising the named Go source files.\n+A Go source file is defined to be a file ending in a literal \".go\" suffix.\n+\n+By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n+If the -exec flag is given, 'go run' invokes the binary using xprog: 'xprog a.out arguments...'.\n+If the -exec flag is not given, GOOS or GOARCH is different from the system\n+default, and a program named go_$GOOS_$GOARCH_exec can be found\n+on the current search path, 'go run' invokes the binary using that program,\n+for example 'go_nacl_386_exec a.out arguments...'. This allows execution of\n+cross-compiled programs when a simulator or other execution method is\n+available.\n+\n+For more about build flags, see 'go help build'.\n+\n+See also: go build.\n+\n+\n+Test packages\n+\n+Usage:\n+\n+\tgo test [-c] [-i] [build and test flags] [packages] [flags for test binary]\n+\n+'Go test' automates testing the packages named by the import paths.\n+It prints a summary of the test results in the format:\n+\n+\tok   archive/tar   0.011s\n+\tFAIL archive/zip   0.022s\n+\tok   compress/gzip 0.033s\n+\t...\n+\n+followed by detailed output for each failed package.\n+\n+'Go test' recompiles each package along with any files with names matching\n+the file pattern \"*_test.go\".\n+Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n+These additional files can contain test functions, benchmark functions, and\n+example functions.  See 'go help testfunc' for more.\n+Each listed package causes the execution of a separate test binary.\n+\n+Test files that declare a package with the suffix \"_test\" will be compiled as a\n+separate package, and then linked and run with the main test binary.\n+\n+By default, go test needs no arguments.  It compiles and tests the package\n+with source in the current directory, including tests, and runs the tests.\n+\n+The package is built in a temporary directory so it does not interfere with the\n+non-test installation.\n+\n+In addition to the build flags, the flags handled by 'go test' itself are:\n+\n+\t-c  Compile the test binary to pkg.test but do not run it.\n+\t    (Where pkg is the last element of the package's import path.)\n+\n+\t-i\n+\t    Install packages that are dependencies of the test.\n+\t    Do not run the test.\n+\n+\t-exec xprog\n+\t    Run the test binary using xprog. The behavior is the same as\n+\t    in 'go run'. See 'go help run' for details.\n+\n+The test binary also accepts flags that control execution of the test; these\n+flags are also accessible by 'go test'.  See 'go help testflag' for details.\n+\n+If the test binary needs any other flags, they should be presented after the\n+package names. The go tool treats as a flag the first argument that begins with\n+a minus sign that it does not recognize itself; that argument and all subsequent\n+arguments are passed as arguments to the test binary.\n+\n+For more about build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go vet.\n+\n+\n+Run specified go tool\n+\n+Usage:\n+\n+\tgo tool [-n] command [args...]\n+\n+Tool runs the go tool command identified by the arguments.\n+With no arguments it prints the list of known tools.\n+\n+The -n flag causes tool to print the command that would be\n+executed but not execute it.\n+\n+For more about each tool command, see 'go tool command -h'.\n+\n+\n+Print Go version\n+\n+Usage:\n+\n+\tgo version\n+\n+Version prints the Go version, as reported by runtime.Version.\n+\n+\n+Run go tool vet on packages\n+\n+Usage:\n+\n+\tgo vet [-n] [-x] [packages]\n+\n+Vet runs the Go vet command on the packages named by the import paths.\n+\n+For more about vet, see 'godoc code.google.com/p/go.tools/cmd/vet'.\n+For more about specifying packages, see 'go help packages'.\n+\n+To run the vet tool with specific options, run 'go tool vet'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+See also: go fmt, go fix.\n+\n+\n+Calling between Go and C\n+\n+There are two different ways to call between Go and C/C++ code.\n+\n+The first is the cgo tool, which is part of the Go distribution.  For\n+information on how to use it see the cgo documentation (godoc cmd/cgo).\n+\n+The second is the SWIG program, which is a general tool for\n+interfacing between languages.  For information on SWIG see\n+http://swig.org/.  When running go build, any file with a .swig\n+extension will be passed to SWIG.  Any file with a .swigcxx extension\n+will be passed to SWIG with the -c++ option.\n+\n+When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n+or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n+compiler.  The CC or CXX environment variables may be set to determine\n+the C or C++ compiler, respectively, to use.\n+\n+\n+File types\n+\n+The go command examines the contents of a restricted set of files\n+in each directory. It identifies which files to examine based on\n+the extension of the file name. These extensions are:\n+\n+\t.go\n+\t\tGo source files.\n+\t.c, .h\n+\t\tC source files.\n+\t\tIf the package uses cgo, these will be compiled with the\n+\t\tOS-native compiler (typically gcc); otherwise they will be\n+\t\tcompiled with the Go-specific support compiler,\n+\t\t5c, 6c, or 8c, etc. as appropriate.\n+\t.cc, .cpp, .cxx, .hh, .hpp, .hxx\n+\t\tC++ source files. Only useful with cgo or SWIG, and always\n+\t\tcompiled with the OS-native compiler.\n+\t.m\n+\t\tObjective-C source files. Only useful with cgo, and always\n+\t\tcompiled with the OS-native compiler.\n+\t.s, .S\n+\t\tAssembler source files.\n+\t\tIf the package uses cgo, these will be assembled with the\n+\t\tOS-native assembler (typically gcc (sic)); otherwise they\n+\t\twill be assembled with the Go-specific support assembler,\n+\t\t5a, 6a, or 8a, etc., as appropriate.\n+\t.swig, .swigcxx\n+\t\tSWIG definition files.\n+\t.syso\n+\t\tSystem object files.\n+\n+Files of each of these types except .syso may contain build\n+constraints, but the go command stops scanning for build constraints\n+at the first item in the file that is not a blank line or //-style\n+line comment.\n+\n+\n+GOPATH environment variable\n+\n+The Go path is used to resolve import statements.\n+It is implemented by and documented in the go/build package.\n+\n+The GOPATH environment variable lists places to look for Go code.\n+On Unix, the value is a colon-separated string.\n+On Windows, the value is a semicolon-separated string.\n+On Plan 9, the value is a list.\n+\n+GOPATH must be set to get, build and install packages outside the\n+standard Go tree.\n+\n+Each directory listed in GOPATH must have a prescribed structure:\n+\n+The src/ directory holds source code.  The path below 'src'\n+determines the import path or executable name.\n+\n+The pkg/ directory holds installed package objects.\n+As in the Go tree, each target operating system and\n+architecture pair has its own subdirectory of pkg\n+(pkg/GOOS_GOARCH).\n+\n+If DIR is a directory listed in the GOPATH, a package with\n+source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n+has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n+\n+The bin/ directory holds compiled commands.\n+Each command is named for its source directory, but only\n+the final element, not the entire path.  That is, the\n+command with source in DIR/src/foo/quux is installed into\n+DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n+so that you can add DIR/bin to your PATH to get at the\n+installed commands.  If the GOBIN environment variable is\n+set, commands are installed to the directory it names instead\n+of DIR/bin.\n+\n+Here's an example directory layout:\n+\n+    GOPATH=/home/user/gocode\n+\n+    /home/user/gocode/\n+        src/\n+            foo/\n+                bar/               (go code in package bar)\n+                    x.go\n+                quux/              (go code in package main)\n+                    y.go\n+        bin/\n+            quux                   (installed command)\n+        pkg/\n+            linux_amd64/\n+                foo/\n+                    bar.a          (installed package object)\n+\n+Go searches each directory listed in GOPATH to find source code,\n+but new packages are always downloaded into the first directory\n+in the list.\n+\n+\n+Import path syntax\n+\n+An import path (see 'go help packages') denotes a package\n+stored in the local file system.  In general, an import path denotes\n+either a standard package (such as \"unicode/utf8\") or a package\n+found in one of the work spaces (see 'go help gopath').\n+\n+Relative import paths\n+\n+An import path beginning with ./ or ../ is called a relative path.\n+The toolchain supports relative import paths as a shortcut in two ways.\n+\n+First, a relative path can be used as a shorthand on the command line.\n+If you are working in the directory containing the code imported as\n+\"unicode\" and want to run the tests for \"unicode/utf8\", you can type\n+\"go test ./utf8\" instead of needing to specify the full path.\n+Similarly, in the reverse situation, \"go test ..\" will test \"unicode\" from\n+the \"unicode/utf8\" directory. Relative patterns are also allowed, like\n+\"go test ./...\" to test all subdirectories. See 'go help packages' for details\n+on the pattern syntax.\n+\n+Second, if you are compiling a Go program not in a work space,\n+you can use a relative path in an import statement in that program\n+to refer to nearby code also not in a work space.\n+This makes it easy to experiment with small multipackage programs\n+outside of the usual work spaces, but such programs cannot be\n+installed with \"go install\" (there is no work space in which to install them),\n+so they are rebuilt from scratch each time they are built.\n+To avoid ambiguity, Go programs cannot use relative import paths\n+within a work space.\n+\n+Remote import paths\n+\n+Certain import paths also\n+describe how to obtain the source code for the package using\n+a revision control system.\n+\n+A few common code hosting sites have special syntax:\n+\n+\tBitbucket (Git, Mercurial)\n+\n+\t\timport \"bitbucket.org/user/project\"\n+\t\timport \"bitbucket.org/user/project/sub/directory\"\n+\n+\tGitHub (Git)\n+\n+\t\timport \"github.com/user/project\"\n+\t\timport \"github.com/user/project/sub/directory\"\n+\n+\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n+\n+\t\timport \"code.google.com/p/project\"\n+\t\timport \"code.google.com/p/project/sub/directory\"\n+\n+\t\timport \"code.google.com/p/project.subrepository\"\n+\t\timport \"code.google.com/p/project.subrepository/sub/directory\"\n+\n+\tLaunchpad (Bazaar)\n+\n+\t\timport \"launchpad.net/project\"\n+\t\timport \"launchpad.net/project/series\"\n+\t\timport \"launchpad.net/project/series/sub/directory\"\n+\n+\t\timport \"launchpad.net/~user/project/branch\"\n+\t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n+\n+For code hosted on other servers, import paths may either be qualified\n+with the version control type, or the go tool can dynamically fetch\n+the import path over https/http and discover where the code resides\n+from a <meta> tag in the HTML.\n+\n+To declare the code location, an import path of the form\n+\n+\trepository.vcs/path\n+\n+specifies the given repository, with or without the .vcs suffix,\n+using the named version control system, and then the path inside\n+that repository.  The supported version control systems are:\n+\n+\tBazaar      .bzr\n+\tGit         .git\n+\tMercurial   .hg\n+\tSubversion  .svn\n+\n+For example,\n+\n+\timport \"example.org/user/foo.hg\"\n+\n+denotes the root directory of the Mercurial repository at\n+example.org/user/foo or foo.hg, and\n+\n+\timport \"example.org/repo.git/foo/bar\"\n+\n+denotes the foo/bar directory of the Git repository at\n+example.org/repo or repo.git.\n+\n+When a version control system supports multiple protocols,\n+each is tried in turn when downloading.  For example, a Git\n+download tries git://, then https://, then http://.\n+\n+If the import path is not a known code hosting site and also lacks a\n+version control qualifier, the go tool attempts to fetch the import\n+over https/http and looks for a <meta> tag in the document's HTML\n+<head>.\n+\n+The meta tag has the form:\n+\n+\t<meta name=\"go-import\" content=\"import-prefix vcs repo-root\">\n+\n+The import-prefix is the import path corresponding to the repository\n+root. It must be a prefix or an exact match of the package being\n+fetched with \"go get\". If it's not an exact match, another http\n+request is made at the prefix to verify the <meta> tags match.\n+\n+The vcs is one of \"git\", \"hg\", \"svn\", etc,\n+\n+The repo-root is the root of the version control system\n+containing a scheme and not containing a .vcs qualifier.\n+\n+For example,\n+\n+\timport \"example.org/pkg/foo\"\n+\n+will result in the following request(s):\n+\n+\thttps://example.org/pkg/foo?go-get=1 (preferred)\n+\thttp://example.org/pkg/foo?go-get=1  (fallback)\n+\n+If that page contains the meta tag\n+\n+\t<meta name=\"go-import\" content=\"example.org git https://code.org/r/p/exproj\">\n+\n+the go tool will verify that https://example.org/?go-get=1 contains the\n+same meta tag and then git clone https://code.org/r/p/exproj into\n+GOPATH/src/example.org.\n+\n+New downloaded packages are written to the first directory\n+listed in the GOPATH environment variable (see 'go help gopath').\n+\n+The go command attempts to download the version of the\n+package appropriate for the Go release being used.\n+Run 'go help install' for more.\n+\n+\n+Description of package lists\n+\n+Many commands apply to a set of packages:\n+\n+\tgo action [packages]\n+\n+Usually, [packages] is a list of import paths.\n+\n+An import path that is a rooted path or that begins with\n+a . or .. element is interpreted as a file system path and\n+denotes the package in that directory.\n+\n+Otherwise, the import path P denotes the package found in\n+the directory DIR/src/P for some DIR listed in the GOPATH\n+environment variable (see 'go help gopath').\n+\n+If no import paths are given, the action applies to the\n+package in the current directory.\n+\n+There are three reserved names for paths that should not be used\n+for packages to be built with the go tool:\n+\n+- \"main\" denotes the top-level package in a stand-alone executable.\n+\n+- \"all\" expands to all package directories found in all the GOPATH\n+trees. For example, 'go list all' lists all the packages on the local\n+system.\n+\n+- \"std\" is like all but expands to just the packages in the standard\n+Go library.\n+\n+An import path is a pattern if it includes one or more \"...\" wildcards,\n+each of which can match any string, including the empty string and\n+strings containing slashes.  Such a pattern expands to all package\n+directories found in the GOPATH trees with names matching the\n+patterns.  As a special case, x/... matches x as well as x's subdirectories.\n+For example, net/... expands to net and packages in its subdirectories.\n+\n+An import path can also name a package to be downloaded from\n+a remote repository.  Run 'go help importpath' for details.\n+\n+Every package in a program must have a unique import path.\n+By convention, this is arranged by starting each path with a\n+unique prefix that belongs to you.  For example, paths used\n+internally at Google all begin with 'google', and paths\n+denoting remote repositories begin with the path to the code,\n+such as 'code.google.com/p/project'.\n+\n+As a special case, if the package list is a list of .go files from a\n+single directory, the command is applied to a single synthesized\n+package made up of exactly those files, ignoring any build constraints\n+in those files and ignoring any other files in the directory.\n+\n+File names that begin with \".\" or \"_\" are ignored by the go tool.\n+\n+\n+Description of testing flags\n+\n+The 'go test' command takes both flags that apply to 'go test' itself\n+and flags that apply to the resulting test binary.\n+\n+Several of the flags control profiling and write an execution profile\n+suitable for \"go tool pprof\"; run \"go tool pprof help\" for more\n+information.  The --alloc_space, --alloc_objects, and --show_bytes\n+options of pprof control how the information is presented.\n+\n+The following flags are recognized by the 'go test' command and\n+control the execution of any test:\n+\n+\t-bench regexp\n+\t    Run benchmarks matching the regular expression.\n+\t    By default, no benchmarks run. To run all benchmarks,\n+\t    use '-bench .' or '-bench=.'.\n+\n+\t-benchmem\n+\t    Print memory allocation statistics for benchmarks.\n+\n+\t-benchtime t\n+\t    Run enough iterations of each benchmark to take t, specified\n+\t    as a time.Duration (for example, -benchtime 1h30s).\n+\t    The default is 1 second (1s).\n+\n+\t-blockprofile block.out\n+\t    Write a goroutine blocking profile to the specified file\n+\t    when all tests are complete.\n+\n+\t-blockprofilerate n\n+\t    Control the detail provided in goroutine blocking profiles by\n+\t    calling runtime.SetBlockProfileRate with n.\n+\t    See 'godoc runtime SetBlockProfileRate'.\n+\t    The profiler aims to sample, on average, one blocking event every\n+\t    n nanoseconds the program spends blocked.  By default,\n+\t    if -test.blockprofile is set without this flag, all blocking events\n+\t    are recorded, equivalent to -test.blockprofilerate=1.\n+\n+\t-cover\n+\t    Enable coverage analysis.\n+\n+\t-covermode set,count,atomic\n+\t    Set the mode for coverage analysis for the package[s]\n+\t    being tested. The default is \"set\" unless -race is enabled,\n+\t    in which case it is \"atomic\".\n+\t    The values:\n+\t\tset: bool: does this statement run?\n+\t\tcount: int: how many times does this statement run?\n+\t\tatomic: int: count, but correct in multithreaded tests;\n+\t\t\tsignificantly more expensive.\n+\t    Sets -cover.\n+\n+\t-coverpkg pkg1,pkg2,pkg3\n+\t    Apply coverage analysis in each test to the given list of packages.\n+\t    The default is for each test to analyze only the package being tested.\n+\t    Packages are specified as import paths.\n+\t    Sets -cover.\n+\n+\t-coverprofile cover.out\n+\t    Write a coverage profile to the specified file after all tests\n+\t    have passed.\n+\t    Sets -cover.\n+\n+\t-cpu 1,2,4\n+\t    Specify a list of GOMAXPROCS values for which the tests or\n+\t    benchmarks should be executed.  The default is the current value\n+\t    of GOMAXPROCS.\n+\n+\t-cpuprofile cpu.out\n+\t    Write a CPU profile to the specified file before exiting.\n+\n+\t-memprofile mem.out\n+\t    Write a memory profile to the specified file after all tests\n+\t    have passed.\n+\n+\t-memprofilerate n\n+\t    Enable more precise (and expensive) memory profiles by setting\n+\t    runtime.MemProfileRate.  See 'godoc runtime MemProfileRate'.\n+\t    To profile all memory allocations, use -test.memprofilerate=1\n+\t    and pass --alloc_space flag to the pprof tool.\n+\n+\t-outputdir directory\n+\t    Place output files from profiling in the specified directory,\n+\t    by default the directory in which \"go test\" is running.\n+\n+\t-parallel n\n+\t    Allow parallel execution of test functions that call t.Parallel.\n+\t    The value of this flag is the maximum number of tests to run\n+\t    simultaneously; by default, it is set to the value of GOMAXPROCS.\n+\n+\t-run regexp\n+\t    Run only those tests and examples matching the regular\n+\t    expression.\n+\n+\t-short\n+\t    Tell long-running tests to shorten their run time.\n+\t    It is off by default but set during all.bash so that installing\n+\t    the Go tree can run a sanity check but not spend time running\n+\t    exhaustive tests.\n+\n+\t-timeout t\n+\t    If a test runs longer than t, panic.\n+\n+\t-v\n+\t    Verbose output: log all tests as they are run. Also print all\n+\t    text from Log and Logf calls even if the test succeeds.\n+\n+The test binary, called pkg.test where pkg is the name of the\n+directory containing the package sources, can be invoked directly\n+after building it with 'go test -c'. When invoking the test binary\n+directly, each of the standard flag names must be prefixed with 'test.',\n+as in -test.run=TestMyFunc or -test.v.\n+\n+When running 'go test', flags not listed above are passed through\n+unaltered. For instance, the command\n+\n+\tgo test -x -v -cpuprofile=prof.out -dir=testdata -update\n+\n+will compile the test binary and then run it as\n+\n+\tpkg.test -test.v -test.cpuprofile=prof.out -dir=testdata -update\n+\n+The test flags that generate profiles (other than for coverage) also\n+leave the test binary in pkg.test for use when analyzing the profiles.\n+\n+Flags not recognized by 'go test' must be placed after any specified packages.\n+\n+\n+Description of testing functions\n+\n+The 'go test' command expects to find test, benchmark, and example functions\n+in the \"*_test.go\" files corresponding to the package under test.\n+\n+A test function is one named TestXXX (where XXX is any alphanumeric string\n+not starting with a lower case letter) and should have the signature,\n+\n+\tfunc TestXXX(t *testing.T) { ... }\n+\n+A benchmark function is one named BenchmarkXXX and should have the signature,\n+\n+\tfunc BenchmarkXXX(b *testing.B) { ... }\n+\n+An example function is similar to a test function but, instead of using\n+*testing.T to report success or failure, prints output to os.Stdout.\n+That output is compared against the function's \"Output:\" comment, which\n+must be the last comment in the function body (see example below). An\n+example with no such comment, or with no text after \"Output:\" is compiled\n+but not executed.\n+\n+Godoc displays the body of ExampleXXX to demonstrate the use\n+of the function, constant, or variable XXX.  An example of a method M with\n+receiver type T or *T is named ExampleT_M.  There may be multiple examples\n+for a given function, constant, or variable, distinguished by a trailing _xxx,\n+where xxx is a suffix not beginning with an upper case letter.\n+\n+Here is an example of an example:\n+\n+\tfunc ExamplePrintln() {\n+\t\tPrintln(\"The output of\\nthis example.\")\n+\t\t// Output: The output of\n+\t\t// this example.\n+\t}\n+\n+The entire test file is presented as the example when it contains a single\n+example function, at least one other function, type, variable, or constant\n+declaration, and no test or benchmark functions.\n+\n+See the documentation of the testing package for more information.\n+\n+\n+*/\n+package main"}, {"sha": "26d37df4f9b7766b02b0752dfcea95f9ff3dc28a", "filename": "libgo/go/cmd/go/env.go", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strings\"\n+)\n+\n+var cmdEnv = &Command{\n+\tRun:       runEnv,\n+\tUsageLine: \"env [var ...]\",\n+\tShort:     \"print Go environment information\",\n+\tLong: `\n+Env prints Go environment information.\n+\n+By default env prints information as a shell script\n+(on Windows, a batch file).  If one or more variable\n+names is given as arguments,  env prints the value of\n+each named variable on its own line.\n+\t`,\n+}\n+\n+type envVar struct {\n+\tname, value string\n+}\n+\n+func mkEnv() []envVar {\n+\tvar b builder\n+\tb.init()\n+\n+\tenv := []envVar{\n+\t\t{\"GOARCH\", goarch},\n+\t\t{\"GOBIN\", gobin},\n+\t\t{\"GOCHAR\", archChar},\n+\t\t{\"GOEXE\", exeSuffix},\n+\t\t{\"GOHOSTARCH\", runtime.GOARCH},\n+\t\t{\"GOHOSTOS\", runtime.GOOS},\n+\t\t{\"GOOS\", goos},\n+\t\t{\"GOPATH\", os.Getenv(\"GOPATH\")},\n+\t\t{\"GORACE\", os.Getenv(\"GORACE\")},\n+\t\t{\"GOROOT\", goroot},\n+\t\t{\"GOTOOLDIR\", toolDir},\n+\n+\t\t// disable escape codes in clang errors\n+\t\t{\"TERM\", \"dumb\"},\n+\t}\n+\n+\tif goos != \"plan9\" {\n+\t\tcmd := b.gccCmd(\".\")\n+\t\tenv = append(env, envVar{\"CC\", cmd[0]})\n+\t\tenv = append(env, envVar{\"GOGCCFLAGS\", strings.Join(cmd[3:], \" \")})\n+\t\tcmd = b.gxxCmd(\".\")\n+\t\tenv = append(env, envVar{\"CXX\", cmd[0]})\n+\t}\n+\n+\tif buildContext.CgoEnabled {\n+\t\tenv = append(env, envVar{\"CGO_ENABLED\", \"1\"})\n+\t} else {\n+\t\tenv = append(env, envVar{\"CGO_ENABLED\", \"0\"})\n+\t}\n+\n+\treturn env\n+}\n+\n+func findEnv(env []envVar, name string) string {\n+\tfor _, e := range env {\n+\t\tif e.name == name {\n+\t\t\treturn e.value\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func runEnv(cmd *Command, args []string) {\n+\tenv := mkEnv()\n+\tif len(args) > 0 {\n+\t\tfor _, name := range args {\n+\t\t\tfmt.Printf(\"%s\\n\", findEnv(env, name))\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tfor _, e := range env {\n+\t\tif e.name != \"TERM\" {\n+\t\t\tswitch runtime.GOOS {\n+\t\t\tdefault:\n+\t\t\t\tfmt.Printf(\"%s=\\\"%s\\\"\\n\", e.name, e.value)\n+\t\t\tcase \"plan9\":\n+\t\t\t\tif strings.IndexByte(e.value, '\\x00') < 0 {\n+\t\t\t\t\tfmt.Printf(\"%s='%s'\\n\", e.name, strings.Replace(e.value, \"'\", \"''\", -1))\n+\t\t\t\t} else {\n+\t\t\t\t\tv := strings.Split(e.value, \"\\x00\")\n+\t\t\t\t\tfmt.Printf(\"%s=(\", e.name)\n+\t\t\t\t\tfor x, s := range v {\n+\t\t\t\t\t\tif x > 0 {\n+\t\t\t\t\t\t\tfmt.Printf(\" \")\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tfmt.Printf(\"%s\", s)\n+\t\t\t\t\t}\n+\t\t\t\t\tfmt.Printf(\")\\n\")\n+\t\t\t\t}\n+\t\t\tcase \"windows\":\n+\t\t\t\tfmt.Printf(\"set %s=%s\\n\", e.name, e.value)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "8736cce3e2a18f1a7096cd2bd7041d64481687f3", "filename": "libgo/go/cmd/go/fix.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ffix.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+var cmdFix = &Command{\n+\tRun:       runFix,\n+\tUsageLine: \"fix [packages]\",\n+\tShort:     \"run go tool fix on packages\",\n+\tLong: `\n+Fix runs the Go fix command on the packages named by the import paths.\n+\n+For more about fix, see 'godoc fix'.\n+For more about specifying packages, see 'go help packages'.\n+\n+To run fix with specific options, run 'go tool fix'.\n+\n+See also: go fmt, go vet.\n+\t`,\n+}\n+\n+func runFix(cmd *Command, args []string) {\n+\tfor _, pkg := range packages(args) {\n+\t\t// Use pkg.gofiles instead of pkg.Dir so that\n+\t\t// the command only applies to this package,\n+\t\t// not to packages in subdirectories.\n+\t\trun(stringList(tool(\"fix\"), relPaths(pkg.allgofiles)))\n+\t}\n+}"}, {"sha": "65dc3ca5990bc7921993e56c311457045fc3eb19", "filename": "libgo/go/cmd/go/fmt.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ffmt.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+func init() {\n+\taddBuildFlagsNX(cmdFmt)\n+}\n+\n+var cmdFmt = &Command{\n+\tRun:       runFmt,\n+\tUsageLine: \"fmt [-n] [-x] [packages]\",\n+\tShort:     \"run gofmt on package sources\",\n+\tLong: `\n+Fmt runs the command 'gofmt -l -w' on the packages named\n+by the import paths.  It prints the names of the files that are modified.\n+\n+For more about gofmt, see 'godoc gofmt'.\n+For more about specifying packages, see 'go help packages'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+To run gofmt with specific options, run gofmt itself.\n+\n+See also: go fix, go vet.\n+\t`,\n+}\n+\n+func runFmt(cmd *Command, args []string) {\n+\tfor _, pkg := range packages(args) {\n+\t\t// Use pkg.gofiles instead of pkg.Dir so that\n+\t\t// the command only applies to this package,\n+\t\t// not to packages in subdirectories.\n+\t\trun(stringList(\"gofmt\", \"-l\", \"-w\", relPaths(pkg.allgofiles)))\n+\t}\n+}"}, {"sha": "e708fcf779fc2591a37ffbe5437b5b0989d97ce9", "filename": "libgo/go/cmd/go/get.go", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fget.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,429 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+var cmdGet = &Command{\n+\tUsageLine: \"get [-d] [-fix] [-t] [-u] [build flags] [packages]\",\n+\tShort:     \"download and install packages and dependencies\",\n+\tLong: `\n+Get downloads and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+The -d flag instructs get to stop after downloading the packages; that is,\n+it instructs get not to install the packages.\n+\n+The -fix flag instructs get to run the fix tool on the downloaded packages\n+before resolving dependencies or building the code.\n+\n+The -t flag instructs get to also download the packages required to build\n+the tests for the specified packages.\n+\n+The -u flag instructs get to use the network to update the named packages\n+and their dependencies.  By default, get uses the network to check out\n+missing packages but does not use it to look for updates to existing packages.\n+\n+Get also accepts build flags to control the installation. See 'go help build'.\n+\n+When checking out or updating a package, get looks for a branch or tag\n+that matches the locally installed version of Go. The most important\n+rule is that if the local installation is running version \"go1\", get\n+searches for a branch or tag named \"go1\". If no such version exists it\n+retrieves the most recent version of the package.\n+\n+For more about specifying packages, see 'go help packages'.\n+\n+For more about how 'go get' finds source code to\n+download, see 'go help importpath'.\n+\n+See also: go build, go install, go clean.\n+\t`,\n+}\n+\n+var getD = cmdGet.Flag.Bool(\"d\", false, \"\")\n+var getT = cmdGet.Flag.Bool(\"t\", false, \"\")\n+var getU = cmdGet.Flag.Bool(\"u\", false, \"\")\n+var getFix = cmdGet.Flag.Bool(\"fix\", false, \"\")\n+\n+func init() {\n+\taddBuildFlags(cmdGet)\n+\tcmdGet.Run = runGet // break init loop\n+}\n+\n+func runGet(cmd *Command, args []string) {\n+\t// Phase 1.  Download/update.\n+\tvar stk importStack\n+\tfor _, arg := range downloadPaths(args) {\n+\t\tdownload(arg, &stk, *getT)\n+\t}\n+\texitIfErrors()\n+\n+\t// Phase 2. Rescan packages and re-evaluate args list.\n+\n+\t// Code we downloaded and all code that depends on it\n+\t// needs to be evicted from the package cache so that\n+\t// the information will be recomputed.  Instead of keeping\n+\t// track of the reverse dependency information, evict\n+\t// everything.\n+\tfor name := range packageCache {\n+\t\tdelete(packageCache, name)\n+\t}\n+\n+\targs = importPaths(args)\n+\n+\t// Phase 3.  Install.\n+\tif *getD {\n+\t\t// Download only.\n+\t\t// Check delayed until now so that importPaths\n+\t\t// has a chance to print errors.\n+\t\treturn\n+\t}\n+\n+\trunInstall(cmd, args)\n+}\n+\n+// downloadPaths prepares the list of paths to pass to download.\n+// It expands ... patterns that can be expanded.  If there is no match\n+// for a particular pattern, downloadPaths leaves it in the result list,\n+// in the hope that we can figure out the repository from the\n+// initial ...-free prefix.\n+func downloadPaths(args []string) []string {\n+\targs = importPathsNoDotExpansion(args)\n+\tvar out []string\n+\tfor _, a := range args {\n+\t\tif strings.Contains(a, \"...\") {\n+\t\t\tvar expand []string\n+\t\t\t// Use matchPackagesInFS to avoid printing\n+\t\t\t// warnings.  They will be printed by the\n+\t\t\t// eventual call to importPaths instead.\n+\t\t\tif build.IsLocalImport(a) {\n+\t\t\t\texpand = matchPackagesInFS(a)\n+\t\t\t} else {\n+\t\t\t\texpand = matchPackages(a)\n+\t\t\t}\n+\t\t\tif len(expand) > 0 {\n+\t\t\t\tout = append(out, expand...)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tout = append(out, a)\n+\t}\n+\treturn out\n+}\n+\n+// downloadCache records the import paths we have already\n+// considered during the download, to avoid duplicate work when\n+// there is more than one dependency sequence leading to\n+// a particular package.\n+var downloadCache = map[string]bool{}\n+\n+// downloadRootCache records the version control repository\n+// root directories we have already considered during the download.\n+// For example, all the packages in the code.google.com/p/codesearch repo\n+// share the same root (the directory for that path), and we only need\n+// to run the hg commands to consider each repository once.\n+var downloadRootCache = map[string]bool{}\n+\n+// download runs the download half of the get command\n+// for the package named by the argument.\n+func download(arg string, stk *importStack, getTestDeps bool) {\n+\tp := loadPackage(arg, stk)\n+\tif p.Error != nil && p.Error.hard {\n+\t\terrorf(\"%s\", p.Error)\n+\t\treturn\n+\t}\n+\n+\t// There's nothing to do if this is a package in the standard library.\n+\tif p.Standard {\n+\t\treturn\n+\t}\n+\n+\t// Only process each package once.\n+\tif downloadCache[arg] {\n+\t\treturn\n+\t}\n+\tdownloadCache[arg] = true\n+\n+\tpkgs := []*Package{p}\n+\twildcardOkay := len(*stk) == 0\n+\tisWildcard := false\n+\n+\t// Download if the package is missing, or update if we're using -u.\n+\tif p.Dir == \"\" || *getU {\n+\t\t// The actual download.\n+\t\tstk.push(p.ImportPath)\n+\t\terr := downloadPackage(p)\n+\t\tif err != nil {\n+\t\t\terrorf(\"%s\", &PackageError{ImportStack: stk.copy(), Err: err.Error()})\n+\t\t\tstk.pop()\n+\t\t\treturn\n+\t\t}\n+\n+\t\targs := []string{arg}\n+\t\t// If the argument has a wildcard in it, re-evaluate the wildcard.\n+\t\t// We delay this until after reloadPackage so that the old entry\n+\t\t// for p has been replaced in the package cache.\n+\t\tif wildcardOkay && strings.Contains(arg, \"...\") {\n+\t\t\tif build.IsLocalImport(arg) {\n+\t\t\t\targs = matchPackagesInFS(arg)\n+\t\t\t} else {\n+\t\t\t\targs = matchPackages(arg)\n+\t\t\t}\n+\t\t\tisWildcard = true\n+\t\t}\n+\n+\t\t// Clear all relevant package cache entries before\n+\t\t// doing any new loads.\n+\t\tfor _, arg := range args {\n+\t\t\tp := packageCache[arg]\n+\t\t\tif p != nil {\n+\t\t\t\tdelete(packageCache, p.Dir)\n+\t\t\t\tdelete(packageCache, p.ImportPath)\n+\t\t\t}\n+\t\t}\n+\n+\t\tpkgs = pkgs[:0]\n+\t\tfor _, arg := range args {\n+\t\t\tstk.push(arg)\n+\t\t\tp := loadPackage(arg, stk)\n+\t\t\tstk.pop()\n+\t\t\tif p.Error != nil {\n+\t\t\t\terrorf(\"%s\", p.Error)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tpkgs = append(pkgs, p)\n+\t\t}\n+\t}\n+\n+\t// Process package, which might now be multiple packages\n+\t// due to wildcard expansion.\n+\tfor _, p := range pkgs {\n+\t\tif *getFix {\n+\t\t\trun(stringList(tool(\"fix\"), relPaths(p.allgofiles)))\n+\n+\t\t\t// The imports might have changed, so reload again.\n+\t\t\tp = reloadPackage(arg, stk)\n+\t\t\tif p.Error != nil {\n+\t\t\t\terrorf(\"%s\", p.Error)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tif isWildcard {\n+\t\t\t// Report both the real package and the\n+\t\t\t// wildcard in any error message.\n+\t\t\tstk.push(p.ImportPath)\n+\t\t}\n+\n+\t\t// Process dependencies, now that we know what they are.\n+\t\tfor _, dep := range p.deps {\n+\t\t\t// Don't get test dependencies recursively.\n+\t\t\tdownload(dep.ImportPath, stk, false)\n+\t\t}\n+\t\tif getTestDeps {\n+\t\t\t// Process test dependencies when -t is specified.\n+\t\t\t// (Don't get test dependencies for test dependencies.)\n+\t\t\tfor _, path := range p.TestImports {\n+\t\t\t\tdownload(path, stk, false)\n+\t\t\t}\n+\t\t\tfor _, path := range p.XTestImports {\n+\t\t\t\tdownload(path, stk, false)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif isWildcard {\n+\t\t\tstk.pop()\n+\t\t}\n+\t}\n+}\n+\n+// downloadPackage runs the create or download command\n+// to make the first copy of or update a copy of the given package.\n+func downloadPackage(p *Package) error {\n+\tvar (\n+\t\tvcs            *vcsCmd\n+\t\trepo, rootPath string\n+\t\terr            error\n+\t)\n+\tif p.build.SrcRoot != \"\" {\n+\t\t// Directory exists.  Look for checkout along path to src.\n+\t\tvcs, rootPath, err = vcsForDir(p)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\trepo = \"<local>\" // should be unused; make distinctive\n+\t} else {\n+\t\t// Analyze the import path to determine the version control system,\n+\t\t// repository, and the import path for the root of the repository.\n+\t\trr, err := repoRootForImportPath(p.ImportPath)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tvcs, repo, rootPath = rr.vcs, rr.repo, rr.root\n+\t}\n+\n+\tif p.build.SrcRoot == \"\" {\n+\t\t// Package not found.  Put in first directory of $GOPATH.\n+\t\tlist := filepath.SplitList(buildContext.GOPATH)\n+\t\tif len(list) == 0 {\n+\t\t\treturn fmt.Errorf(\"cannot download, $GOPATH not set. For more details see: go help gopath\")\n+\t\t}\n+\t\t// Guard against people setting GOPATH=$GOROOT.\n+\t\tif list[0] == goroot {\n+\t\t\treturn fmt.Errorf(\"cannot download, $GOPATH must not be set to $GOROOT. For more details see: go help gopath\")\n+\t\t}\n+\t\tp.build.SrcRoot = filepath.Join(list[0], \"src\")\n+\t\tp.build.PkgRoot = filepath.Join(list[0], \"pkg\")\n+\t}\n+\troot := filepath.Join(p.build.SrcRoot, rootPath)\n+\t// If we've considered this repository already, don't do it again.\n+\tif downloadRootCache[root] {\n+\t\treturn nil\n+\t}\n+\tdownloadRootCache[root] = true\n+\n+\tif buildV {\n+\t\tfmt.Fprintf(os.Stderr, \"%s (download)\\n\", rootPath)\n+\t}\n+\n+\t// Check that this is an appropriate place for the repo to be checked out.\n+\t// The target directory must either not exist or have a repo checked out already.\n+\tmeta := filepath.Join(root, \".\"+vcs.cmd)\n+\tst, err := os.Stat(meta)\n+\tif err == nil && !st.IsDir() {\n+\t\treturn fmt.Errorf(\"%s exists but is not a directory\", meta)\n+\t}\n+\tif err != nil {\n+\t\t// Metadata directory does not exist.  Prepare to checkout new copy.\n+\t\t// Some version control tools require the target directory not to exist.\n+\t\t// We require that too, just to avoid stepping on existing work.\n+\t\tif _, err := os.Stat(root); err == nil {\n+\t\t\treturn fmt.Errorf(\"%s exists but %s does not - stale checkout?\", root, meta)\n+\t\t}\n+\t\t// Some version control tools require the parent of the target to exist.\n+\t\tparent, _ := filepath.Split(root)\n+\t\tif err = os.MkdirAll(parent, 0777); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = vcs.create(root, repo); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t} else {\n+\t\t// Metadata directory does exist; download incremental updates.\n+\t\tif err = vcs.download(root); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tif buildN {\n+\t\t// Do not show tag sync in -n; it's noise more than anything,\n+\t\t// and since we're not running commands, no tag will be found.\n+\t\t// But avoid printing nothing.\n+\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s sync/update\\n\", root, vcs.cmd)\n+\t\treturn nil\n+\t}\n+\n+\t// Select and sync to appropriate version of the repository.\n+\ttags, err := vcs.tags(root)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvers := runtime.Version()\n+\tif i := strings.Index(vers, \" \"); i >= 0 {\n+\t\tvers = vers[:i]\n+\t}\n+\tif err := vcs.tagSync(root, selectTag(vers, tags)); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+// goTag matches go release tags such as go1 and go1.2.3.\n+// The numbers involved must be small (at most 4 digits),\n+// have no unnecessary leading zeros, and the version cannot\n+// end in .0 - it is go1, not go1.0 or go1.0.0.\n+var goTag = regexp.MustCompile(\n+\t`^go((0|[1-9][0-9]{0,3})\\.)*([1-9][0-9]{0,3})$`,\n+)\n+\n+// selectTag returns the closest matching tag for a given version.\n+// Closest means the latest one that is not after the current release.\n+// Version \"goX\" (or \"goX.Y\" or \"goX.Y.Z\") matches tags of the same form.\n+// Version \"release.rN\" matches tags of the form \"go.rN\" (N being a floating-point number).\n+// Version \"weekly.YYYY-MM-DD\" matches tags like \"go.weekly.YYYY-MM-DD\".\n+//\n+// NOTE(rsc): Eventually we will need to decide on some logic here.\n+// For now, there is only \"go1\".  This matches the docs in go help get.\n+func selectTag(goVersion string, tags []string) (match string) {\n+\tfor _, t := range tags {\n+\t\tif t == \"go1\" {\n+\t\t\treturn \"go1\"\n+\t\t}\n+\t}\n+\treturn \"\"\n+\n+\t/*\n+\t\tif goTag.MatchString(goVersion) {\n+\t\t\tv := goVersion\n+\t\t\tfor _, t := range tags {\n+\t\t\t\tif !goTag.MatchString(t) {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif cmpGoVersion(match, t) < 0 && cmpGoVersion(t, v) <= 0 {\n+\t\t\t\t\tmatch = t\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn match\n+\t*/\n+}\n+\n+// cmpGoVersion returns -1, 0, +1 reporting whether\n+// x < y, x == y, or x > y.\n+func cmpGoVersion(x, y string) int {\n+\t// Malformed strings compare less than well-formed strings.\n+\tif !goTag.MatchString(x) {\n+\t\treturn -1\n+\t}\n+\tif !goTag.MatchString(y) {\n+\t\treturn +1\n+\t}\n+\n+\t// Compare numbers in sequence.\n+\txx := strings.Split(x[len(\"go\"):], \".\")\n+\tyy := strings.Split(y[len(\"go\"):], \".\")\n+\n+\tfor i := 0; i < len(xx) && i < len(yy); i++ {\n+\t\t// The Atoi are guaranteed to succeed\n+\t\t// because the versions match goTag.\n+\t\txi, _ := strconv.Atoi(xx[i])\n+\t\tyi, _ := strconv.Atoi(yy[i])\n+\t\tif xi < yi {\n+\t\t\treturn -1\n+\t\t} else if xi > yi {\n+\t\t\treturn +1\n+\t\t}\n+\t}\n+\n+\tif len(xx) < len(yy) {\n+\t\treturn -1\n+\t}\n+\tif len(xx) > len(yy) {\n+\t\treturn +1\n+\t}\n+\treturn 0\n+}"}, {"sha": "8a434dfed1ca7f6c3601e9056c8b82b67e8d86b4", "filename": "libgo/go/cmd/go/go11.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build go1.1\n+\n+package main\n+\n+// Test that go1.1 tag above is included in builds. main.go refers to this definition.\n+const go11tag = true"}, {"sha": "40da7e1f5eee87eab8abf389a32e8f934e32c046", "filename": "libgo/go/cmd/go/help.go", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,337 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+var helpC = &Command{\n+\tUsageLine: \"c\",\n+\tShort:     \"calling between Go and C\",\n+\tLong: `\n+There are two different ways to call between Go and C/C++ code.\n+\n+The first is the cgo tool, which is part of the Go distribution.  For\n+information on how to use it see the cgo documentation (godoc cmd/cgo).\n+\n+The second is the SWIG program, which is a general tool for\n+interfacing between languages.  For information on SWIG see\n+http://swig.org/.  When running go build, any file with a .swig\n+extension will be passed to SWIG.  Any file with a .swigcxx extension\n+will be passed to SWIG with the -c++ option.\n+\n+When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n+or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n+compiler.  The CC or CXX environment variables may be set to determine\n+the C or C++ compiler, respectively, to use.\n+\t`,\n+}\n+\n+var helpPackages = &Command{\n+\tUsageLine: \"packages\",\n+\tShort:     \"description of package lists\",\n+\tLong: `\n+Many commands apply to a set of packages:\n+\n+\tgo action [packages]\n+\n+Usually, [packages] is a list of import paths.\n+\n+An import path that is a rooted path or that begins with\n+a . or .. element is interpreted as a file system path and\n+denotes the package in that directory.\n+\n+Otherwise, the import path P denotes the package found in\n+the directory DIR/src/P for some DIR listed in the GOPATH\n+environment variable (see 'go help gopath').\n+\n+If no import paths are given, the action applies to the\n+package in the current directory.\n+\n+There are three reserved names for paths that should not be used\n+for packages to be built with the go tool:\n+\n+- \"main\" denotes the top-level package in a stand-alone executable.\n+\n+- \"all\" expands to all package directories found in all the GOPATH\n+trees. For example, 'go list all' lists all the packages on the local\n+system.\n+\n+- \"std\" is like all but expands to just the packages in the standard\n+Go library.\n+\n+An import path is a pattern if it includes one or more \"...\" wildcards,\n+each of which can match any string, including the empty string and\n+strings containing slashes.  Such a pattern expands to all package\n+directories found in the GOPATH trees with names matching the\n+patterns.  As a special case, x/... matches x as well as x's subdirectories.\n+For example, net/... expands to net and packages in its subdirectories.\n+\n+An import path can also name a package to be downloaded from\n+a remote repository.  Run 'go help importpath' for details.\n+\n+Every package in a program must have a unique import path.\n+By convention, this is arranged by starting each path with a\n+unique prefix that belongs to you.  For example, paths used\n+internally at Google all begin with 'google', and paths\n+denoting remote repositories begin with the path to the code,\n+such as 'code.google.com/p/project'.\n+\n+As a special case, if the package list is a list of .go files from a\n+single directory, the command is applied to a single synthesized\n+package made up of exactly those files, ignoring any build constraints\n+in those files and ignoring any other files in the directory.\n+\n+File names that begin with \".\" or \"_\" are ignored by the go tool.\n+\t`,\n+}\n+\n+var helpImportPath = &Command{\n+\tUsageLine: \"importpath\",\n+\tShort:     \"import path syntax\",\n+\tLong: `\n+\n+An import path (see 'go help packages') denotes a package\n+stored in the local file system.  In general, an import path denotes\n+either a standard package (such as \"unicode/utf8\") or a package\n+found in one of the work spaces (see 'go help gopath').\n+\n+Relative import paths\n+\n+An import path beginning with ./ or ../ is called a relative path.\n+The toolchain supports relative import paths as a shortcut in two ways.\n+\n+First, a relative path can be used as a shorthand on the command line.\n+If you are working in the directory containing the code imported as\n+\"unicode\" and want to run the tests for \"unicode/utf8\", you can type\n+\"go test ./utf8\" instead of needing to specify the full path.\n+Similarly, in the reverse situation, \"go test ..\" will test \"unicode\" from\n+the \"unicode/utf8\" directory. Relative patterns are also allowed, like\n+\"go test ./...\" to test all subdirectories. See 'go help packages' for details\n+on the pattern syntax.\n+\n+Second, if you are compiling a Go program not in a work space,\n+you can use a relative path in an import statement in that program\n+to refer to nearby code also not in a work space.\n+This makes it easy to experiment with small multipackage programs\n+outside of the usual work spaces, but such programs cannot be\n+installed with \"go install\" (there is no work space in which to install them),\n+so they are rebuilt from scratch each time they are built.\n+To avoid ambiguity, Go programs cannot use relative import paths\n+within a work space.\n+\n+Remote import paths\n+\n+Certain import paths also\n+describe how to obtain the source code for the package using\n+a revision control system.\n+\n+A few common code hosting sites have special syntax:\n+\n+\tBitbucket (Git, Mercurial)\n+\n+\t\timport \"bitbucket.org/user/project\"\n+\t\timport \"bitbucket.org/user/project/sub/directory\"\n+\n+\tGitHub (Git)\n+\n+\t\timport \"github.com/user/project\"\n+\t\timport \"github.com/user/project/sub/directory\"\n+\n+\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n+\n+\t\timport \"code.google.com/p/project\"\n+\t\timport \"code.google.com/p/project/sub/directory\"\n+\n+\t\timport \"code.google.com/p/project.subrepository\"\n+\t\timport \"code.google.com/p/project.subrepository/sub/directory\"\n+\n+\tLaunchpad (Bazaar)\n+\n+\t\timport \"launchpad.net/project\"\n+\t\timport \"launchpad.net/project/series\"\n+\t\timport \"launchpad.net/project/series/sub/directory\"\n+\n+\t\timport \"launchpad.net/~user/project/branch\"\n+\t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n+\n+For code hosted on other servers, import paths may either be qualified\n+with the version control type, or the go tool can dynamically fetch\n+the import path over https/http and discover where the code resides\n+from a <meta> tag in the HTML.\n+\n+To declare the code location, an import path of the form\n+\n+\trepository.vcs/path\n+\n+specifies the given repository, with or without the .vcs suffix,\n+using the named version control system, and then the path inside\n+that repository.  The supported version control systems are:\n+\n+\tBazaar      .bzr\n+\tGit         .git\n+\tMercurial   .hg\n+\tSubversion  .svn\n+\n+For example,\n+\n+\timport \"example.org/user/foo.hg\"\n+\n+denotes the root directory of the Mercurial repository at\n+example.org/user/foo or foo.hg, and\n+\n+\timport \"example.org/repo.git/foo/bar\"\n+\n+denotes the foo/bar directory of the Git repository at\n+example.org/repo or repo.git.\n+\n+When a version control system supports multiple protocols,\n+each is tried in turn when downloading.  For example, a Git\n+download tries git://, then https://, then http://.\n+\n+If the import path is not a known code hosting site and also lacks a\n+version control qualifier, the go tool attempts to fetch the import\n+over https/http and looks for a <meta> tag in the document's HTML\n+<head>.\n+\n+The meta tag has the form:\n+\n+\t<meta name=\"go-import\" content=\"import-prefix vcs repo-root\">\n+\n+The import-prefix is the import path corresponding to the repository\n+root. It must be a prefix or an exact match of the package being\n+fetched with \"go get\". If it's not an exact match, another http\n+request is made at the prefix to verify the <meta> tags match.\n+\n+The vcs is one of \"git\", \"hg\", \"svn\", etc,\n+\n+The repo-root is the root of the version control system\n+containing a scheme and not containing a .vcs qualifier.\n+\n+For example,\n+\n+\timport \"example.org/pkg/foo\"\n+\n+will result in the following request(s):\n+\n+\thttps://example.org/pkg/foo?go-get=1 (preferred)\n+\thttp://example.org/pkg/foo?go-get=1  (fallback)\n+\n+If that page contains the meta tag\n+\n+\t<meta name=\"go-import\" content=\"example.org git https://code.org/r/p/exproj\">\n+\n+the go tool will verify that https://example.org/?go-get=1 contains the\n+same meta tag and then git clone https://code.org/r/p/exproj into\n+GOPATH/src/example.org.\n+\n+New downloaded packages are written to the first directory\n+listed in the GOPATH environment variable (see 'go help gopath').\n+\n+The go command attempts to download the version of the\n+package appropriate for the Go release being used.\n+Run 'go help install' for more.\n+\t`,\n+}\n+\n+var helpGopath = &Command{\n+\tUsageLine: \"gopath\",\n+\tShort:     \"GOPATH environment variable\",\n+\tLong: `\n+The Go path is used to resolve import statements.\n+It is implemented by and documented in the go/build package.\n+\n+The GOPATH environment variable lists places to look for Go code.\n+On Unix, the value is a colon-separated string.\n+On Windows, the value is a semicolon-separated string.\n+On Plan 9, the value is a list.\n+\n+GOPATH must be set to get, build and install packages outside the\n+standard Go tree.\n+\n+Each directory listed in GOPATH must have a prescribed structure:\n+\n+The src/ directory holds source code.  The path below 'src'\n+determines the import path or executable name.\n+\n+The pkg/ directory holds installed package objects.\n+As in the Go tree, each target operating system and\n+architecture pair has its own subdirectory of pkg\n+(pkg/GOOS_GOARCH).\n+\n+If DIR is a directory listed in the GOPATH, a package with\n+source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n+has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n+\n+The bin/ directory holds compiled commands.\n+Each command is named for its source directory, but only\n+the final element, not the entire path.  That is, the\n+command with source in DIR/src/foo/quux is installed into\n+DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n+so that you can add DIR/bin to your PATH to get at the\n+installed commands.  If the GOBIN environment variable is\n+set, commands are installed to the directory it names instead\n+of DIR/bin.\n+\n+Here's an example directory layout:\n+\n+    GOPATH=/home/user/gocode\n+\n+    /home/user/gocode/\n+        src/\n+            foo/\n+                bar/               (go code in package bar)\n+                    x.go\n+                quux/              (go code in package main)\n+                    y.go\n+        bin/\n+            quux                   (installed command)\n+        pkg/\n+            linux_amd64/\n+                foo/\n+                    bar.a          (installed package object)\n+\n+Go searches each directory listed in GOPATH to find source code,\n+but new packages are always downloaded into the first directory\n+in the list.\n+\t`,\n+}\n+\n+var helpFileType = &Command{\n+\tUsageLine: \"filetype\",\n+\tShort:     \"file types\",\n+\tLong: `\n+The go command examines the contents of a restricted set of files\n+in each directory. It identifies which files to examine based on\n+the extension of the file name. These extensions are:\n+\n+\t.go\n+\t\tGo source files.\n+\t.c, .h\n+\t\tC source files.\n+\t\tIf the package uses cgo, these will be compiled with the\n+\t\tOS-native compiler (typically gcc); otherwise they will be\n+\t\tcompiled with the Go-specific support compiler,\n+\t\t5c, 6c, or 8c, etc. as appropriate.\n+\t.cc, .cpp, .cxx, .hh, .hpp, .hxx\n+\t\tC++ source files. Only useful with cgo or SWIG, and always\n+\t\tcompiled with the OS-native compiler.\n+\t.m\n+\t\tObjective-C source files. Only useful with cgo, and always\n+\t\tcompiled with the OS-native compiler.\n+\t.s, .S\n+\t\tAssembler source files.\n+\t\tIf the package uses cgo, these will be assembled with the\n+\t\tOS-native assembler (typically gcc (sic)); otherwise they\n+\t\twill be assembled with the Go-specific support assembler,\n+\t\t5a, 6a, or 8a, etc., as appropriate.\n+\t.swig, .swigcxx\n+\t\tSWIG definition files.\n+\t.syso\n+\t\tSystem object files.\n+\n+Files of each of these types except .syso may contain build\n+constraints, but the go command stops scanning for build constraints\n+at the first item in the file that is not a blank line or //-style\n+line comment.\n+\t`,\n+}"}, {"sha": "107b820f28c52c6da056998c18a6fc6cc207be35", "filename": "libgo/go/cmd/go/http.go", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhttp.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !cmd_go_bootstrap\n+\n+// This code is compiled into the real 'go' binary, but it is not\n+// compiled into the binary that is built during all.bash, so as\n+// to avoid needing to build net (and thus use cgo) during the\n+// bootstrap process.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"net/url\"\n+)\n+\n+// httpClient is the default HTTP client, but a variable so it can be\n+// changed by tests, without modifying http.DefaultClient.\n+var httpClient = http.DefaultClient\n+\n+// httpGET returns the data from an HTTP GET request for the given URL.\n+func httpGET(url string) ([]byte, error) {\n+\tresp, err := httpClient.Get(url)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer resp.Body.Close()\n+\tif resp.StatusCode != 200 {\n+\t\treturn nil, fmt.Errorf(\"%s: %s\", url, resp.Status)\n+\t}\n+\tb, err := ioutil.ReadAll(resp.Body)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s: %v\", url, err)\n+\t}\n+\treturn b, nil\n+}\n+\n+// httpsOrHTTP returns the body of either the importPath's\n+// https resource or, if unavailable, the http resource.\n+func httpsOrHTTP(importPath string) (urlStr string, body io.ReadCloser, err error) {\n+\tfetch := func(scheme string) (urlStr string, res *http.Response, err error) {\n+\t\tu, err := url.Parse(scheme + \"://\" + importPath)\n+\t\tif err != nil {\n+\t\t\treturn \"\", nil, err\n+\t\t}\n+\t\tu.RawQuery = \"go-get=1\"\n+\t\turlStr = u.String()\n+\t\tif buildV {\n+\t\t\tlog.Printf(\"Fetching %s\", urlStr)\n+\t\t}\n+\t\tres, err = httpClient.Get(urlStr)\n+\t\treturn\n+\t}\n+\tcloseBody := func(res *http.Response) {\n+\t\tif res != nil {\n+\t\t\tres.Body.Close()\n+\t\t}\n+\t}\n+\turlStr, res, err := fetch(\"https\")\n+\tif err != nil || res.StatusCode != 200 {\n+\t\tif buildV {\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Printf(\"https fetch failed.\")\n+\t\t\t} else {\n+\t\t\t\tlog.Printf(\"ignoring https fetch with status code %d\", res.StatusCode)\n+\t\t\t}\n+\t\t}\n+\t\tcloseBody(res)\n+\t\turlStr, res, err = fetch(\"http\")\n+\t}\n+\tif err != nil {\n+\t\tcloseBody(res)\n+\t\treturn \"\", nil, err\n+\t}\n+\t// Note: accepting a non-200 OK here, so people can serve a\n+\t// meta import in their http 404 page.\n+\tif buildV {\n+\t\tlog.Printf(\"Parsing meta tags from %s (status code %d)\", urlStr, res.StatusCode)\n+\t}\n+\treturn urlStr, res.Body, nil\n+}"}, {"sha": "0ead4350238231d8b41fc3be12ce9fcae1abaea3", "filename": "libgo/go/cmd/go/list.go", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Flist.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"encoding/json\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/template\"\n+)\n+\n+var cmdList = &Command{\n+\tUsageLine: \"list [-e] [-f format] [-json] [build flags] [packages]\",\n+\tShort:     \"list packages\",\n+\tLong: `\n+List lists the packages named by the import paths, one per line.\n+\n+The default output shows the package import path:\n+\n+    code.google.com/p/google-api-go-client/books/v1\n+    code.google.com/p/goauth2/oauth\n+    code.google.com/p/sqlite\n+\n+The -f flag specifies an alternate format for the list, using the\n+syntax of package template.  The default output is equivalent to -f\n+'{{.ImportPath}}'. The struct being passed to the template is:\n+\n+    type Package struct {\n+        Dir        string // directory containing package sources\n+        ImportPath string // import path of package in dir\n+        Name       string // package name\n+        Doc        string // package documentation string\n+        Target     string // install path\n+        Goroot     bool   // is this package in the Go root?\n+        Standard   bool   // is this package part of the standard Go library?\n+        Stale      bool   // would 'go install' do anything for this package?\n+        Root       string // Go root or Go path dir containing this package\n+\n+        // Source files\n+        GoFiles  []string       // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+        CgoFiles []string       // .go sources files that import \"C\"\n+        IgnoredGoFiles []string // .go sources ignored due to build constraints\n+        CFiles   []string       // .c source files\n+        CXXFiles []string       // .cc, .cxx and .cpp source files\n+        MFiles   []string       // .m source files\n+        HFiles   []string       // .h, .hh, .hpp and .hxx source files\n+        SFiles   []string       // .s source files\n+        SwigFiles []string      // .swig files\n+        SwigCXXFiles []string   // .swigcxx files\n+        SysoFiles []string      // .syso object files to add to archive\n+\n+        // Cgo directives\n+        CgoCFLAGS    []string // cgo: flags for C compiler\n+        CgoCPPFLAGS  []string // cgo: flags for C preprocessor\n+        CgoCXXFLAGS  []string // cgo: flags for C++ compiler\n+        CgoLDFLAGS   []string // cgo: flags for linker\n+        CgoPkgConfig []string // cgo: pkg-config names\n+\n+        // Dependency information\n+        Imports []string // import paths used by this package\n+        Deps    []string // all (recursively) imported dependencies\n+\n+        // Error information\n+        Incomplete bool            // this package or a dependency has an error\n+        Error      *PackageError   // error loading package\n+        DepsErrors []*PackageError // errors loading dependencies\n+\n+        TestGoFiles  []string // _test.go files in package\n+        TestImports  []string // imports from TestGoFiles\n+        XTestGoFiles []string // _test.go files outside package\n+        XTestImports []string // imports from XTestGoFiles\n+    }\n+\n+The template function \"join\" calls strings.Join.\n+\n+The template function \"context\" returns the build context, defined as:\n+\n+\ttype Context struct {\n+\t\tGOARCH        string   // target architecture\n+\t\tGOOS          string   // target operating system\n+\t\tGOROOT        string   // Go root\n+\t\tGOPATH        string   // Go path\n+\t\tCgoEnabled    bool     // whether cgo can be used\n+\t\tUseAllFiles   bool     // use files regardless of +build lines, file names\n+\t\tCompiler      string   // compiler to assume when computing target paths\n+\t\tBuildTags     []string // build constraints to match in +build lines\n+\t\tReleaseTags   []string // releases the current release is compatible with\n+\t\tInstallSuffix string   // suffix to use in the name of the install dir\n+\t}\n+\n+For more information about the meaning of these fields see the documentation\n+for the go/build package's Context type.\n+\n+The -json flag causes the package data to be printed in JSON format\n+instead of using the template format.\n+\n+The -e flag changes the handling of erroneous packages, those that\n+cannot be found or are malformed.  By default, the list command\n+prints an error to standard error for each erroneous package and\n+omits the packages from consideration during the usual printing.\n+With the -e flag, the list command never prints errors to standard\n+error and instead processes the erroneous packages with the usual\n+printing.  Erroneous packages will have a non-empty ImportPath and\n+a non-nil Error field; other information may or may not be missing\n+(zeroed).\n+\n+For more about build flags, see 'go help build'.\n+\n+For more about specifying packages, see 'go help packages'.\n+\t`,\n+}\n+\n+func init() {\n+\tcmdList.Run = runList // break init cycle\n+\taddBuildFlags(cmdList)\n+}\n+\n+var listE = cmdList.Flag.Bool(\"e\", false, \"\")\n+var listFmt = cmdList.Flag.String(\"f\", \"{{.ImportPath}}\", \"\")\n+var listJson = cmdList.Flag.Bool(\"json\", false, \"\")\n+var nl = []byte{'\\n'}\n+\n+func runList(cmd *Command, args []string) {\n+\tout := newTrackingWriter(os.Stdout)\n+\tdefer out.w.Flush()\n+\n+\tvar do func(*Package)\n+\tif *listJson {\n+\t\tdo = func(p *Package) {\n+\t\t\tb, err := json.MarshalIndent(p, \"\", \"\\t\")\n+\t\t\tif err != nil {\n+\t\t\t\tout.Flush()\n+\t\t\t\tfatalf(\"%s\", err)\n+\t\t\t}\n+\t\t\tout.Write(b)\n+\t\t\tout.Write(nl)\n+\t\t}\n+\t} else {\n+\t\tvar cachedCtxt *Context\n+\t\tcontext := func() *Context {\n+\t\t\tif cachedCtxt == nil {\n+\t\t\t\tcachedCtxt = newContext(&buildContext)\n+\t\t\t}\n+\t\t\treturn cachedCtxt\n+\t\t}\n+\t\tfm := template.FuncMap{\n+\t\t\t\"join\":    strings.Join,\n+\t\t\t\"context\": context,\n+\t\t}\n+\t\ttmpl, err := template.New(\"main\").Funcs(fm).Parse(*listFmt)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%s\", err)\n+\t\t}\n+\t\tdo = func(p *Package) {\n+\t\t\tif err := tmpl.Execute(out, p); err != nil {\n+\t\t\t\tout.Flush()\n+\t\t\t\tfatalf(\"%s\", err)\n+\t\t\t}\n+\t\t\tif out.NeedNL() {\n+\t\t\t\tout.Write(nl)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tload := packages\n+\tif *listE {\n+\t\tload = packagesAndErrors\n+\t}\n+\n+\tfor _, pkg := range load(args) {\n+\t\tdo(pkg)\n+\t}\n+}\n+\n+// TrackingWriter tracks the last byte written on every write so\n+// we can avoid printing a newline if one was already written or\n+// if there is no output at all.\n+type TrackingWriter struct {\n+\tw    *bufio.Writer\n+\tlast byte\n+}\n+\n+func newTrackingWriter(w io.Writer) *TrackingWriter {\n+\treturn &TrackingWriter{\n+\t\tw:    bufio.NewWriter(w),\n+\t\tlast: '\\n',\n+\t}\n+}\n+\n+func (t *TrackingWriter) Write(p []byte) (n int, err error) {\n+\tn, err = t.w.Write(p)\n+\tif n > 0 {\n+\t\tt.last = p[n-1]\n+\t}\n+\treturn\n+}\n+\n+func (t *TrackingWriter) Flush() {\n+\tt.w.Flush()\n+}\n+\n+func (t *TrackingWriter) NeedNL() bool {\n+\treturn t.last != '\\n'\n+}"}, {"sha": "5b1194aaa34d3c55a290d44debd95a706b929f54", "filename": "libgo/go/cmd/go/main.go", "status": "added", "additions": 722, "deletions": 0, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,722 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"text/template\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+// A Command is an implementation of a go command\n+// like go build or go fix.\n+type Command struct {\n+\t// Run runs the command.\n+\t// The args are the arguments after the command name.\n+\tRun func(cmd *Command, args []string)\n+\n+\t// UsageLine is the one-line usage message.\n+\t// The first word in the line is taken to be the command name.\n+\tUsageLine string\n+\n+\t// Short is the short description shown in the 'go help' output.\n+\tShort string\n+\n+\t// Long is the long message shown in the 'go help <this-command>' output.\n+\tLong string\n+\n+\t// Flag is a set of flags specific to this command.\n+\tFlag flag.FlagSet\n+\n+\t// CustomFlags indicates that the command will do its own\n+\t// flag parsing.\n+\tCustomFlags bool\n+}\n+\n+// Name returns the command's name: the first word in the usage line.\n+func (c *Command) Name() string {\n+\tname := c.UsageLine\n+\ti := strings.Index(name, \" \")\n+\tif i >= 0 {\n+\t\tname = name[:i]\n+\t}\n+\treturn name\n+}\n+\n+func (c *Command) Usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\\n\", c.UsageLine)\n+\tfmt.Fprintf(os.Stderr, \"%s\\n\", strings.TrimSpace(c.Long))\n+\tos.Exit(2)\n+}\n+\n+// Runnable reports whether the command can be run; otherwise\n+// it is a documentation pseudo-command such as importpath.\n+func (c *Command) Runnable() bool {\n+\treturn c.Run != nil\n+}\n+\n+// Commands lists the available commands and help topics.\n+// The order here is the order in which they are printed by 'go help'.\n+var commands = []*Command{\n+\tcmdBuild,\n+\tcmdClean,\n+\tcmdEnv,\n+\tcmdFix,\n+\tcmdFmt,\n+\tcmdGet,\n+\tcmdInstall,\n+\tcmdList,\n+\tcmdRun,\n+\tcmdTest,\n+\tcmdTool,\n+\tcmdVersion,\n+\tcmdVet,\n+\n+\thelpC,\n+\thelpFileType,\n+\thelpGopath,\n+\thelpImportPath,\n+\thelpPackages,\n+\thelpTestflag,\n+\thelpTestfunc,\n+}\n+\n+var exitStatus = 0\n+var exitMu sync.Mutex\n+\n+func setExitStatus(n int) {\n+\texitMu.Lock()\n+\tif exitStatus < n {\n+\t\texitStatus = n\n+\t}\n+\texitMu.Unlock()\n+}\n+\n+func main() {\n+\t_ = go11tag\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\tlog.SetFlags(0)\n+\n+\targs := flag.Args()\n+\tif len(args) < 1 {\n+\t\tusage()\n+\t}\n+\n+\tif args[0] == \"help\" {\n+\t\thelp(args[1:])\n+\t\treturn\n+\t}\n+\n+\t// Diagnose common mistake: GOPATH==GOROOT.\n+\t// This setting is equivalent to not setting GOPATH at all,\n+\t// which is not what most people want when they do it.\n+\tif gopath := os.Getenv(\"GOPATH\"); gopath == runtime.GOROOT() {\n+\t\tfmt.Fprintf(os.Stderr, \"warning: GOPATH set to GOROOT (%s) has no effect\\n\", gopath)\n+\t} else {\n+\t\tfor _, p := range filepath.SplitList(gopath) {\n+\t\t\t// Note: using HasPrefix instead of Contains because a ~ can appear\n+\t\t\t// in the middle of directory elements, such as /tmp/git-1.8.2~rc3\n+\t\t\t// or C:\\PROGRA~1. Only ~ as a path prefix has meaning to the shell.\n+\t\t\tif strings.HasPrefix(p, \"~\") {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: GOPATH entry cannot start with shell metacharacter '~': %q\\n\", p)\n+\t\t\t\tos.Exit(2)\n+\t\t\t}\n+\t\t\tif build.IsLocalImport(p) {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go: GOPATH entry is relative; must be absolute path: %q.\\nRun 'go help gopath' for usage.\\n\", p)\n+\t\t\t\tos.Exit(2)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif fi, err := os.Stat(goroot); err != nil || !fi.IsDir() {\n+\t\tfmt.Fprintf(os.Stderr, \"go: cannot find GOROOT directory: %v\\n\", goroot)\n+\t\tos.Exit(2)\n+\t}\n+\n+\tfor _, cmd := range commands {\n+\t\tif cmd.Name() == args[0] && cmd.Run != nil {\n+\t\t\tcmd.Flag.Usage = func() { cmd.Usage() }\n+\t\t\tif cmd.CustomFlags {\n+\t\t\t\targs = args[1:]\n+\t\t\t} else {\n+\t\t\t\tcmd.Flag.Parse(args[1:])\n+\t\t\t\targs = cmd.Flag.Args()\n+\t\t\t}\n+\t\t\tcmd.Run(cmd, args)\n+\t\t\texit()\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfmt.Fprintf(os.Stderr, \"go: unknown subcommand %q\\nRun 'go help' for usage.\\n\", args[0])\n+\tsetExitStatus(2)\n+\texit()\n+}\n+\n+var usageTemplate = `Go is a tool for managing Go source code.\n+\n+Usage:\n+\n+\tgo command [arguments]\n+\n+The commands are:\n+{{range .}}{{if .Runnable}}\n+    {{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\n+Use \"go help [command]\" for more information about a command.\n+\n+Additional help topics:\n+{{range .}}{{if not .Runnable}}\n+    {{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\n+Use \"go help [topic]\" for more information about that topic.\n+\n+`\n+\n+var helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}\n+\n+{{end}}{{.Long | trim}}\n+`\n+\n+var documentationTemplate = `// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// DO NOT EDIT THIS FILE. GENERATED BY mkdoc.sh.\n+// Edit the documentation in other files and rerun mkdoc.sh to generate this one.\n+\n+/*\n+{{range .}}{{if .Short}}{{.Short | capitalize}}\n+\n+{{end}}{{if .Runnable}}Usage:\n+\n+\tgo {{.UsageLine}}\n+\n+{{end}}{{.Long | trim}}\n+\n+\n+{{end}}*/\n+package main\n+`\n+\n+// tmpl executes the given template text on data, writing the result to w.\n+func tmpl(w io.Writer, text string, data interface{}) {\n+\tt := template.New(\"top\")\n+\tt.Funcs(template.FuncMap{\"trim\": strings.TrimSpace, \"capitalize\": capitalize})\n+\ttemplate.Must(t.Parse(text))\n+\tif err := t.Execute(w, data); err != nil {\n+\t\tpanic(err)\n+\t}\n+}\n+\n+func capitalize(s string) string {\n+\tif s == \"\" {\n+\t\treturn s\n+\t}\n+\tr, n := utf8.DecodeRuneInString(s)\n+\treturn string(unicode.ToTitle(r)) + s[n:]\n+}\n+\n+func printUsage(w io.Writer) {\n+\ttmpl(w, usageTemplate, commands)\n+}\n+\n+func usage() {\n+\t// special case \"go test -h\"\n+\tif len(os.Args) > 1 && os.Args[1] == \"test\" {\n+\t\thelp([]string{\"testflag\"})\n+\t\tos.Exit(2)\n+\t}\n+\tprintUsage(os.Stderr)\n+\tos.Exit(2)\n+}\n+\n+// help implements the 'help' command.\n+func help(args []string) {\n+\tif len(args) == 0 {\n+\t\tprintUsage(os.Stdout)\n+\t\t// not exit 2: succeeded at 'go help'.\n+\t\treturn\n+\t}\n+\tif len(args) != 1 {\n+\t\tfmt.Fprintf(os.Stderr, \"usage: go help command\\n\\nToo many arguments given.\\n\")\n+\t\tos.Exit(2) // failed at 'go help'\n+\t}\n+\n+\targ := args[0]\n+\n+\t// 'go help documentation' generates doc.go.\n+\tif arg == \"documentation\" {\n+\t\tbuf := new(bytes.Buffer)\n+\t\tprintUsage(buf)\n+\t\tusage := &Command{Long: buf.String()}\n+\t\ttmpl(os.Stdout, documentationTemplate, append([]*Command{usage}, commands...))\n+\t\treturn\n+\t}\n+\n+\tfor _, cmd := range commands {\n+\t\tif cmd.Name() == arg {\n+\t\t\ttmpl(os.Stdout, helpTemplate, cmd)\n+\t\t\t// not exit 2: succeeded at 'go help cmd'.\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfmt.Fprintf(os.Stderr, \"Unknown help topic %#q.  Run 'go help'.\\n\", arg)\n+\tos.Exit(2) // failed at 'go help cmd'\n+}\n+\n+// importPathsNoDotExpansion returns the import paths to use for the given\n+// command line, but it does no ... expansion.\n+func importPathsNoDotExpansion(args []string) []string {\n+\tif len(args) == 0 {\n+\t\treturn []string{\".\"}\n+\t}\n+\tvar out []string\n+\tfor _, a := range args {\n+\t\t// Arguments are supposed to be import paths, but\n+\t\t// as a courtesy to Windows developers, rewrite \\ to /\n+\t\t// in command-line arguments.  Handles .\\... and so on.\n+\t\tif filepath.Separator == '\\\\' {\n+\t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n+\t\t}\n+\n+\t\t// Put argument in canonical form, but preserve leading ./.\n+\t\tif strings.HasPrefix(a, \"./\") {\n+\t\t\ta = \"./\" + path.Clean(a)\n+\t\t\tif a == \"./.\" {\n+\t\t\t\ta = \".\"\n+\t\t\t}\n+\t\t} else {\n+\t\t\ta = path.Clean(a)\n+\t\t}\n+\t\tif a == \"all\" || a == \"std\" {\n+\t\t\tout = append(out, allPackages(a)...)\n+\t\t\tcontinue\n+\t\t}\n+\t\tout = append(out, a)\n+\t}\n+\treturn out\n+}\n+\n+// importPaths returns the import paths to use for the given command line.\n+func importPaths(args []string) []string {\n+\targs = importPathsNoDotExpansion(args)\n+\tvar out []string\n+\tfor _, a := range args {\n+\t\tif strings.Contains(a, \"...\") {\n+\t\t\tif build.IsLocalImport(a) {\n+\t\t\t\tout = append(out, allPackagesInFS(a)...)\n+\t\t\t} else {\n+\t\t\t\tout = append(out, allPackages(a)...)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tout = append(out, a)\n+\t}\n+\treturn out\n+}\n+\n+var atexitFuncs []func()\n+\n+func atexit(f func()) {\n+\tatexitFuncs = append(atexitFuncs, f)\n+}\n+\n+func exit() {\n+\tfor _, f := range atexitFuncs {\n+\t\tf()\n+\t}\n+\tos.Exit(exitStatus)\n+}\n+\n+func fatalf(format string, args ...interface{}) {\n+\terrorf(format, args...)\n+\texit()\n+}\n+\n+func errorf(format string, args ...interface{}) {\n+\tlog.Printf(format, args...)\n+\tsetExitStatus(1)\n+}\n+\n+var logf = log.Printf\n+\n+func exitIfErrors() {\n+\tif exitStatus != 0 {\n+\t\texit()\n+\t}\n+}\n+\n+func run(cmdargs ...interface{}) {\n+\tcmdline := stringList(cmdargs...)\n+\tif buildN || buildX {\n+\t\tfmt.Printf(\"%s\\n\", strings.Join(cmdline, \" \"))\n+\t\tif buildN {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tif err := cmd.Run(); err != nil {\n+\t\terrorf(\"%v\", err)\n+\t}\n+}\n+\n+func runOut(dir string, cmdargs ...interface{}) []byte {\n+\tcmdline := stringList(cmdargs...)\n+\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\tcmd.Dir = dir\n+\tout, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tos.Stderr.Write(out)\n+\t\terrorf(\"%v\", err)\n+\t\tout = nil\n+\t}\n+\treturn out\n+}\n+\n+// envForDir returns a copy of the environment\n+// suitable for running in the given directory.\n+// The environment is the current process's environment\n+// but with an updated $PWD, so that an os.Getwd in the\n+// child will be faster.\n+func envForDir(dir string) []string {\n+\tenv := os.Environ()\n+\t// Internally we only use rooted paths, so dir is rooted.\n+\t// Even if dir is not rooted, no harm done.\n+\treturn mergeEnvLists([]string{\"PWD=\" + dir}, env)\n+}\n+\n+// mergeEnvLists merges the two environment lists such that\n+// variables with the same name in \"in\" replace those in \"out\".\n+func mergeEnvLists(in, out []string) []string {\n+NextVar:\n+\tfor _, inkv := range in {\n+\t\tk := strings.SplitAfterN(inkv, \"=\", 2)[0]\n+\t\tfor i, outkv := range out {\n+\t\t\tif strings.HasPrefix(outkv, k) {\n+\t\t\t\tout[i] = inkv\n+\t\t\t\tcontinue NextVar\n+\t\t\t}\n+\t\t}\n+\t\tout = append(out, inkv)\n+\t}\n+\treturn out\n+}\n+\n+// matchPattern(pattern)(name) reports whether\n+// name matches pattern.  Pattern is a limited glob\n+// pattern in which '...' means 'any string' and there\n+// is no other special syntax.\n+func matchPattern(pattern string) func(name string) bool {\n+\tre := regexp.QuoteMeta(pattern)\n+\tre = strings.Replace(re, `\\.\\.\\.`, `.*`, -1)\n+\t// Special case: foo/... matches foo too.\n+\tif strings.HasSuffix(re, `/.*`) {\n+\t\tre = re[:len(re)-len(`/.*`)] + `(/.*)?`\n+\t}\n+\treg := regexp.MustCompile(`^` + re + `$`)\n+\treturn func(name string) bool {\n+\t\treturn reg.MatchString(name)\n+\t}\n+}\n+\n+// hasPathPrefix reports whether the path s begins with the\n+// elements in prefix.\n+func hasPathPrefix(s, prefix string) bool {\n+\tswitch {\n+\tdefault:\n+\t\treturn false\n+\tcase len(s) == len(prefix):\n+\t\treturn s == prefix\n+\tcase len(s) > len(prefix):\n+\t\tif prefix != \"\" && prefix[len(prefix)-1] == '/' {\n+\t\t\treturn strings.HasPrefix(s, prefix)\n+\t\t}\n+\t\treturn s[len(prefix)] == '/' && s[:len(prefix)] == prefix\n+\t}\n+}\n+\n+// treeCanMatchPattern(pattern)(name) reports whether\n+// name or children of name can possibly match pattern.\n+// Pattern is the same limited glob accepted by matchPattern.\n+func treeCanMatchPattern(pattern string) func(name string) bool {\n+\twildCard := false\n+\tif i := strings.Index(pattern, \"...\"); i >= 0 {\n+\t\twildCard = true\n+\t\tpattern = pattern[:i]\n+\t}\n+\treturn func(name string) bool {\n+\t\treturn len(name) <= len(pattern) && hasPathPrefix(pattern, name) ||\n+\t\t\twildCard && strings.HasPrefix(name, pattern)\n+\t}\n+}\n+\n+// allPackages returns all the packages that can be found\n+// under the $GOPATH directories and $GOROOT matching pattern.\n+// The pattern is either \"all\" (all packages), \"std\" (standard packages)\n+// or a path including \"...\".\n+func allPackages(pattern string) []string {\n+\tpkgs := matchPackages(pattern)\n+\tif len(pkgs) == 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n+\t}\n+\treturn pkgs\n+}\n+\n+func matchPackages(pattern string) []string {\n+\tmatch := func(string) bool { return true }\n+\ttreeCanMatch := func(string) bool { return true }\n+\tif pattern != \"all\" && pattern != \"std\" {\n+\t\tmatch = matchPattern(pattern)\n+\t\ttreeCanMatch = treeCanMatchPattern(pattern)\n+\t}\n+\n+\thave := map[string]bool{\n+\t\t\"builtin\": true, // ignore pseudo-package that exists only for documentation\n+\t}\n+\tif !buildContext.CgoEnabled {\n+\t\thave[\"runtime/cgo\"] = true // ignore during walk\n+\t}\n+\tvar pkgs []string\n+\n+\t// Commands\n+\tcmd := filepath.Join(goroot, \"src/cmd\") + string(filepath.Separator)\n+\tfilepath.Walk(cmd, func(path string, fi os.FileInfo, err error) error {\n+\t\tif err != nil || !fi.IsDir() || path == cmd {\n+\t\t\treturn nil\n+\t\t}\n+\t\tname := path[len(cmd):]\n+\t\tif !treeCanMatch(name) {\n+\t\t\treturn filepath.SkipDir\n+\t\t}\n+\t\t// Commands are all in cmd/, not in subdirectories.\n+\t\tif strings.Contains(name, string(filepath.Separator)) {\n+\t\t\treturn filepath.SkipDir\n+\t\t}\n+\n+\t\t// We use, e.g., cmd/gofmt as the pseudo import path for gofmt.\n+\t\tname = \"cmd/\" + name\n+\t\tif have[name] {\n+\t\t\treturn nil\n+\t\t}\n+\t\thave[name] = true\n+\t\tif !match(name) {\n+\t\t\treturn nil\n+\t\t}\n+\t\t_, err = buildContext.ImportDir(path, 0)\n+\t\tif err != nil {\n+\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n+\t\t\t\tlog.Print(err)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t\tpkgs = append(pkgs, name)\n+\t\treturn nil\n+\t})\n+\n+\tfor _, src := range buildContext.SrcDirs() {\n+\t\tif pattern == \"std\" && src != gorootSrcPkg {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n+\t\tfilepath.Walk(src, func(path string, fi os.FileInfo, err error) error {\n+\t\t\tif err != nil || !fi.IsDir() || path == src {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\t// Avoid .foo, _foo, and testdata directory trees.\n+\t\t\t_, elem := filepath.Split(path)\n+\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n+\t\t\t\treturn filepath.SkipDir\n+\t\t\t}\n+\n+\t\t\tname := filepath.ToSlash(path[len(src):])\n+\t\t\tif pattern == \"std\" && strings.Contains(name, \".\") {\n+\t\t\t\treturn filepath.SkipDir\n+\t\t\t}\n+\t\t\tif !treeCanMatch(name) {\n+\t\t\t\treturn filepath.SkipDir\n+\t\t\t}\n+\t\t\tif have[name] {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\thave[name] = true\n+\t\t\tif !match(name) {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\t_, err = buildContext.ImportDir(path, 0)\n+\t\t\tif err != nil {\n+\t\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tpkgs = append(pkgs, name)\n+\t\t\treturn nil\n+\t\t})\n+\t}\n+\treturn pkgs\n+}\n+\n+// allPackagesInFS is like allPackages but is passed a pattern\n+// beginning ./ or ../, meaning it should scan the tree rooted\n+// at the given directory.  There are ... in the pattern too.\n+func allPackagesInFS(pattern string) []string {\n+\tpkgs := matchPackagesInFS(pattern)\n+\tif len(pkgs) == 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n+\t}\n+\treturn pkgs\n+}\n+\n+func matchPackagesInFS(pattern string) []string {\n+\t// Find directory to begin the scan.\n+\t// Could be smarter but this one optimization\n+\t// is enough for now, since ... is usually at the\n+\t// end of a path.\n+\ti := strings.Index(pattern, \"...\")\n+\tdir, _ := path.Split(pattern[:i])\n+\n+\t// pattern begins with ./ or ../.\n+\t// path.Clean will discard the ./ but not the ../.\n+\t// We need to preserve the ./ for pattern matching\n+\t// and in the returned import paths.\n+\tprefix := \"\"\n+\tif strings.HasPrefix(pattern, \"./\") {\n+\t\tprefix = \"./\"\n+\t}\n+\tmatch := matchPattern(pattern)\n+\n+\tvar pkgs []string\n+\tfilepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n+\t\tif err != nil || !fi.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif path == dir {\n+\t\t\t// filepath.Walk starts at dir and recurses. For the recursive case,\n+\t\t\t// the path is the result of filepath.Join, which calls filepath.Clean.\n+\t\t\t// The initial case is not Cleaned, though, so we do this explicitly.\n+\t\t\t//\n+\t\t\t// This converts a path like \"./io/\" to \"io\". Without this step, running\n+\t\t\t// \"cd $GOROOT/src/pkg; go list ./io/...\" would incorrectly skip the io\n+\t\t\t// package, because prepending the prefix \"./\" to the unclean path would\n+\t\t\t// result in \"././io\", and match(\"././io\") returns false.\n+\t\t\tpath = filepath.Clean(path)\n+\t\t}\n+\n+\t\t// Avoid .foo, _foo, and testdata directory trees, but do not avoid \".\" or \"..\".\n+\t\t_, elem := filepath.Split(path)\n+\t\tdot := strings.HasPrefix(elem, \".\") && elem != \".\" && elem != \"..\"\n+\t\tif dot || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n+\t\t\treturn filepath.SkipDir\n+\t\t}\n+\n+\t\tname := prefix + filepath.ToSlash(path)\n+\t\tif !match(name) {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif _, err = build.ImportDir(path, 0); err != nil {\n+\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n+\t\t\t\tlog.Print(err)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t\tpkgs = append(pkgs, name)\n+\t\treturn nil\n+\t})\n+\treturn pkgs\n+}\n+\n+// stringList's arguments should be a sequence of string or []string values.\n+// stringList flattens them into a single []string.\n+func stringList(args ...interface{}) []string {\n+\tvar x []string\n+\tfor _, arg := range args {\n+\t\tswitch arg := arg.(type) {\n+\t\tcase []string:\n+\t\t\tx = append(x, arg...)\n+\t\tcase string:\n+\t\t\tx = append(x, arg)\n+\t\tdefault:\n+\t\t\tpanic(\"stringList: invalid argument\")\n+\t\t}\n+\t}\n+\treturn x\n+}\n+\n+// toFold returns a string with the property that\n+//\tstrings.EqualFold(s, t) iff toFold(s) == toFold(t)\n+// This lets us test a large set of strings for fold-equivalent\n+// duplicates without making a quadratic number of calls\n+// to EqualFold. Note that strings.ToUpper and strings.ToLower\n+// have the desired property in some corner cases.\n+func toFold(s string) string {\n+\t// Fast path: all ASCII, no upper case.\n+\t// Most paths look like this already.\n+\tfor i := 0; i < len(s); i++ {\n+\t\tc := s[i]\n+\t\tif c >= utf8.RuneSelf || 'A' <= c && c <= 'Z' {\n+\t\t\tgoto Slow\n+\t\t}\n+\t}\n+\treturn s\n+\n+Slow:\n+\tvar buf bytes.Buffer\n+\tfor _, r := range s {\n+\t\t// SimpleFold(x) cycles to the next equivalent rune > x\n+\t\t// or wraps around to smaller values. Iterate until it wraps,\n+\t\t// and we've found the minimum value.\n+\t\tfor {\n+\t\t\tr0 := r\n+\t\t\tr = unicode.SimpleFold(r0)\n+\t\t\tif r <= r0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\t// Exception to allow fast path above: A-Z => a-z\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\tr += 'a' - 'A'\n+\t\t}\n+\t\tbuf.WriteRune(r)\n+\t}\n+\treturn buf.String()\n+}\n+\n+// foldDup reports a pair of strings from the list that are\n+// equal according to strings.EqualFold.\n+// It returns \"\", \"\" if there are no such strings.\n+func foldDup(list []string) (string, string) {\n+\tclash := map[string]string{}\n+\tfor _, s := range list {\n+\t\tfold := toFold(s)\n+\t\tif t := clash[fold]; t != \"\" {\n+\t\t\tif s > t {\n+\t\t\t\ts, t = t, s\n+\t\t\t}\n+\t\t\treturn s, t\n+\t\t}\n+\t\tclash[fold] = s\n+\t}\n+\treturn \"\", \"\"\n+}"}, {"sha": "38b9b115e7c0be2f093595f4e977067f6ef8f826", "filename": "libgo/go/cmd/go/match_test.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"testing\"\n+\n+var matchPatternTests = []stringPairTest{\n+\t{\"...\", \"foo\", true},\n+\t{\"net\", \"net\", true},\n+\t{\"net\", \"net/http\", false},\n+\t{\"net/http\", \"net\", false},\n+\t{\"net/http\", \"net/http\", true},\n+\t{\"net...\", \"netchan\", true},\n+\t{\"net...\", \"net\", true},\n+\t{\"net...\", \"net/http\", true},\n+\t{\"net...\", \"not/http\", false},\n+\t{\"net/...\", \"netchan\", false},\n+\t{\"net/...\", \"net\", true},\n+\t{\"net/...\", \"net/http\", true},\n+\t{\"net/...\", \"not/http\", false},\n+}\n+\n+func TestMatchPattern(t *testing.T) {\n+\ttestStringPairs(t, \"matchPattern\", matchPatternTests, func(pattern, name string) bool {\n+\t\treturn matchPattern(pattern)(name)\n+\t})\n+}\n+\n+var treeCanMatchPatternTests = []stringPairTest{\n+\t{\"...\", \"foo\", true},\n+\t{\"net\", \"net\", true},\n+\t{\"net\", \"net/http\", false},\n+\t{\"net/http\", \"net\", true},\n+\t{\"net/http\", \"net/http\", true},\n+\t{\"net...\", \"netchan\", true},\n+\t{\"net...\", \"net\", true},\n+\t{\"net...\", \"net/http\", true},\n+\t{\"net...\", \"not/http\", false},\n+\t{\"net/...\", \"netchan\", false},\n+\t{\"net/...\", \"net\", true},\n+\t{\"net/...\", \"net/http\", true},\n+\t{\"net/...\", \"not/http\", false},\n+\t{\"abc.../def\", \"abcxyz\", true},\n+\t{\"abc.../def\", \"xyxabc\", false},\n+\t{\"x/y/z/...\", \"x\", true},\n+\t{\"x/y/z/...\", \"x/y\", true},\n+\t{\"x/y/z/...\", \"x/y/z\", true},\n+\t{\"x/y/z/...\", \"x/y/z/w\", true},\n+\t{\"x/y/z\", \"x\", true},\n+\t{\"x/y/z\", \"x/y\", true},\n+\t{\"x/y/z\", \"x/y/z\", true},\n+\t{\"x/y/z\", \"x/y/z/w\", false},\n+\t{\"x/.../y/z\", \"x/a/b/c\", true},\n+\t{\"x/.../y/z\", \"y/x/a/b/c\", false},\n+}\n+\n+func TestChildrenCanMatchPattern(t *testing.T) {\n+\ttestStringPairs(t, \"treeCanMatchPattern\", treeCanMatchPatternTests, func(pattern, name string) bool {\n+\t\treturn treeCanMatchPattern(pattern)(name)\n+\t})\n+}\n+\n+var hasPathPrefixTests = []stringPairTest{\n+\t{\"abc\", \"a\", false},\n+\t{\"a/bc\", \"a\", true},\n+\t{\"a\", \"a\", true},\n+\t{\"a/bc\", \"a/\", true},\n+}\n+\n+func TestHasPathPrefix(t *testing.T) {\n+\ttestStringPairs(t, \"hasPathPrefix\", hasPathPrefixTests, hasPathPrefix)\n+}\n+\n+type stringPairTest struct {\n+\tin1 string\n+\tin2 string\n+\tout bool\n+}\n+\n+func testStringPairs(t *testing.T, name string, tests []stringPairTest, f func(string, string) bool) {\n+\tfor _, tt := range tests {\n+\t\tif out := f(tt.in1, tt.in2); out != tt.out {\n+\t\t\tt.Errorf(\"%s(%q, %q) = %v, want %v\", name, tt.in1, tt.in2, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "12fd7ba3e7f62e4fc874cb1581be9d332767a60b", "filename": "libgo/go/cmd/go/mkdoc.sh", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fmkdoc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fmkdoc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmkdoc.sh?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,9 @@\n+#!/bin/sh\n+# Copyright 2012 The Go Authors.  All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+go install # So the next line will produce updated documentation.\n+go help documentation > doc.go\n+gofmt -w doc.go\n+"}, {"sha": "b700ad5c9a20cd9b2a95cb05c1e8bbc2dce52812", "filename": "libgo/go/cmd/go/pkg.go", "status": "added", "additions": 856, "deletions": 0, "changes": 856, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,856 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"os\"\n+\tpathpkg \"path\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"time\"\n+\t\"unicode\"\n+)\n+\n+// A Package describes a single package found in a directory.\n+type Package struct {\n+\t// Note: These fields are part of the go command's public API.\n+\t// See list.go.  It is okay to add fields, but not to change or\n+\t// remove existing ones.  Keep in sync with list.go\n+\tDir         string `json:\",omitempty\"` // directory containing package sources\n+\tImportPath  string `json:\",omitempty\"` // import path of package in dir\n+\tName        string `json:\",omitempty\"` // package name\n+\tDoc         string `json:\",omitempty\"` // package documentation string\n+\tTarget      string `json:\",omitempty\"` // install path\n+\tGoroot      bool   `json:\",omitempty\"` // is this package found in the Go root?\n+\tStandard    bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n+\tStale       bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n+\tRoot        string `json:\",omitempty\"` // Go root or Go path dir containing this package\n+\tConflictDir string `json:\",omitempty\"` // Dir is hidden by this other directory\n+\n+\t// Source files\n+\tGoFiles        []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+\tCgoFiles       []string `json:\",omitempty\"` // .go sources files that import \"C\"\n+\tIgnoredGoFiles []string `json:\",omitempty\"` // .go sources ignored due to build constraints\n+\tCFiles         []string `json:\",omitempty\"` // .c source files\n+\tCXXFiles       []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n+\tMFiles         []string `json:\",omitempty\"` // .m source files\n+\tHFiles         []string `json:\",omitempty\"` // .h, .hh, .hpp and .hxx source files\n+\tSFiles         []string `json:\",omitempty\"` // .s source files\n+\tSwigFiles      []string `json:\",omitempty\"` // .swig files\n+\tSwigCXXFiles   []string `json:\",omitempty\"` // .swigcxx files\n+\tSysoFiles      []string `json:\",omitempty\"` // .syso system object files added to package\n+\n+\t// Cgo directives\n+\tCgoCFLAGS    []string `json:\",omitempty\"` // cgo: flags for C compiler\n+\tCgoCPPFLAGS  []string `json:\",omitempty\"` // cgo: flags for C preprocessor\n+\tCgoCXXFLAGS  []string `json:\",omitempty\"` // cgo: flags for C++ compiler\n+\tCgoLDFLAGS   []string `json:\",omitempty\"` // cgo: flags for linker\n+\tCgoPkgConfig []string `json:\",omitempty\"` // cgo: pkg-config names\n+\n+\t// Dependency information\n+\tImports []string `json:\",omitempty\"` // import paths used by this package\n+\tDeps    []string `json:\",omitempty\"` // all (recursively) imported dependencies\n+\n+\t// Error information\n+\tIncomplete bool            `json:\",omitempty\"` // was there an error loading this package or dependencies?\n+\tError      *PackageError   `json:\",omitempty\"` // error loading this package (not dependencies)\n+\tDepsErrors []*PackageError `json:\",omitempty\"` // errors loading dependencies\n+\n+\t// Test information\n+\tTestGoFiles  []string `json:\",omitempty\"` // _test.go files in package\n+\tTestImports  []string `json:\",omitempty\"` // imports from TestGoFiles\n+\tXTestGoFiles []string `json:\",omitempty\"` // _test.go files outside package\n+\tXTestImports []string `json:\",omitempty\"` // imports from XTestGoFiles\n+\n+\t// Unexported fields are not part of the public API.\n+\tbuild        *build.Package\n+\tpkgdir       string // overrides build.PkgDir\n+\timports      []*Package\n+\tdeps         []*Package\n+\tgofiles      []string // GoFiles+CgoFiles+TestGoFiles+XTestGoFiles files, absolute paths\n+\tsfiles       []string\n+\tallgofiles   []string             // gofiles + IgnoredGoFiles, absolute paths\n+\ttarget       string               // installed file for this package (may be executable)\n+\tfake         bool                 // synthesized package\n+\tforceBuild   bool                 // this package must be rebuilt\n+\tforceLibrary bool                 // this package is a library (even if named \"main\")\n+\tcmdline      bool                 // defined by files listed on command line\n+\tlocal        bool                 // imported via local path (./ or ../)\n+\tlocalPrefix  string               // interpret ./ and ../ imports relative to this prefix\n+\texeName      string               // desired name for temporary executable\n+\tcoverMode    string               // preprocess Go source files with the coverage tool in this mode\n+\tcoverVars    map[string]*CoverVar // variables created by coverage analysis\n+\tomitDWARF    bool                 // tell linker not to write DWARF information\n+}\n+\n+// CoverVar holds the name of the generated coverage variables targeting the named file.\n+type CoverVar struct {\n+\tFile string // local file name\n+\tVar  string // name of count struct\n+}\n+\n+func (p *Package) copyBuild(pp *build.Package) {\n+\tp.build = pp\n+\n+\tp.Dir = pp.Dir\n+\tp.ImportPath = pp.ImportPath\n+\tp.Name = pp.Name\n+\tp.Doc = pp.Doc\n+\tp.Root = pp.Root\n+\tp.ConflictDir = pp.ConflictDir\n+\t// TODO? Target\n+\tp.Goroot = pp.Goroot\n+\tp.Standard = p.Goroot && p.ImportPath != \"\" && !strings.Contains(p.ImportPath, \".\")\n+\tp.GoFiles = pp.GoFiles\n+\tp.CgoFiles = pp.CgoFiles\n+\tp.IgnoredGoFiles = pp.IgnoredGoFiles\n+\tp.CFiles = pp.CFiles\n+\tp.CXXFiles = pp.CXXFiles\n+\tp.MFiles = pp.MFiles\n+\tp.HFiles = pp.HFiles\n+\tp.SFiles = pp.SFiles\n+\tp.SwigFiles = pp.SwigFiles\n+\tp.SwigCXXFiles = pp.SwigCXXFiles\n+\tp.SysoFiles = pp.SysoFiles\n+\tp.CgoCFLAGS = pp.CgoCFLAGS\n+\tp.CgoCPPFLAGS = pp.CgoCPPFLAGS\n+\tp.CgoCXXFLAGS = pp.CgoCXXFLAGS\n+\tp.CgoLDFLAGS = pp.CgoLDFLAGS\n+\tp.CgoPkgConfig = pp.CgoPkgConfig\n+\tp.Imports = pp.Imports\n+\tp.TestGoFiles = pp.TestGoFiles\n+\tp.TestImports = pp.TestImports\n+\tp.XTestGoFiles = pp.XTestGoFiles\n+\tp.XTestImports = pp.XTestImports\n+}\n+\n+// A PackageError describes an error loading information about a package.\n+type PackageError struct {\n+\tImportStack   []string // shortest path from package named on command line to this one\n+\tPos           string   // position of error\n+\tErr           string   // the error itself\n+\tisImportCycle bool     // the error is an import cycle\n+\thard          bool     // whether the error is soft or hard; soft errors are ignored in some places\n+}\n+\n+func (p *PackageError) Error() string {\n+\t// Import cycles deserve special treatment.\n+\tif p.isImportCycle {\n+\t\treturn fmt.Sprintf(\"%s\\npackage %s\\n\", p.Err, strings.Join(p.ImportStack, \"\\n\\timports \"))\n+\t}\n+\tif p.Pos != \"\" {\n+\t\t// Omit import stack.  The full path to the file where the error\n+\t\t// is the most important thing.\n+\t\treturn p.Pos + \": \" + p.Err\n+\t}\n+\tif len(p.ImportStack) == 0 {\n+\t\treturn p.Err\n+\t}\n+\treturn \"package \" + strings.Join(p.ImportStack, \"\\n\\timports \") + \": \" + p.Err\n+}\n+\n+// An importStack is a stack of import paths.\n+type importStack []string\n+\n+func (s *importStack) push(p string) {\n+\t*s = append(*s, p)\n+}\n+\n+func (s *importStack) pop() {\n+\t*s = (*s)[0 : len(*s)-1]\n+}\n+\n+func (s *importStack) copy() []string {\n+\treturn append([]string{}, *s...)\n+}\n+\n+// shorterThan returns true if sp is shorter than t.\n+// We use this to record the shortest import sequence\n+// that leads to a particular package.\n+func (sp *importStack) shorterThan(t []string) bool {\n+\ts := *sp\n+\tif len(s) != len(t) {\n+\t\treturn len(s) < len(t)\n+\t}\n+\t// If they are the same length, settle ties using string ordering.\n+\tfor i := range s {\n+\t\tif s[i] != t[i] {\n+\t\t\treturn s[i] < t[i]\n+\t\t}\n+\t}\n+\treturn false // they are equal\n+}\n+\n+// packageCache is a lookup cache for loadPackage,\n+// so that if we look up a package multiple times\n+// we return the same pointer each time.\n+var packageCache = map[string]*Package{}\n+\n+// reloadPackage is like loadPackage but makes sure\n+// not to use the package cache.\n+func reloadPackage(arg string, stk *importStack) *Package {\n+\tp := packageCache[arg]\n+\tif p != nil {\n+\t\tdelete(packageCache, p.Dir)\n+\t\tdelete(packageCache, p.ImportPath)\n+\t}\n+\treturn loadPackage(arg, stk)\n+}\n+\n+// dirToImportPath returns the pseudo-import path we use for a package\n+// outside the Go path.  It begins with _/ and then contains the full path\n+// to the directory.  If the package lives in c:\\home\\gopher\\my\\pkg then\n+// the pseudo-import path is _/c_/home/gopher/my/pkg.\n+// Using a pseudo-import path like this makes the ./ imports no longer\n+// a special case, so that all the code to deal with ordinary imports works\n+// automatically.\n+func dirToImportPath(dir string) string {\n+\treturn pathpkg.Join(\"_\", strings.Map(makeImportValid, filepath.ToSlash(dir)))\n+}\n+\n+func makeImportValid(r rune) rune {\n+\t// Should match Go spec, compilers, and ../../pkg/go/parser/parser.go:/isValidImport.\n+\tconst illegalChars = `!\"#$%&'()*,:;<=>?[\\]^{|}` + \"`\\uFFFD\"\n+\tif !unicode.IsGraphic(r) || unicode.IsSpace(r) || strings.ContainsRune(illegalChars, r) {\n+\t\treturn '_'\n+\t}\n+\treturn r\n+}\n+\n+// loadImport scans the directory named by path, which must be an import path,\n+// but possibly a local import path (an absolute file system path or one beginning\n+// with ./ or ../).  A local relative path is interpreted relative to srcDir.\n+// It returns a *Package describing the package found in that directory.\n+func loadImport(path string, srcDir string, stk *importStack, importPos []token.Position) *Package {\n+\tstk.push(path)\n+\tdefer stk.pop()\n+\n+\t// Determine canonical identifier for this package.\n+\t// For a local import the identifier is the pseudo-import path\n+\t// we create from the full directory to the package.\n+\t// Otherwise it is the usual import path.\n+\timportPath := path\n+\tisLocal := build.IsLocalImport(path)\n+\tif isLocal {\n+\t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n+\t}\n+\tif p := packageCache[importPath]; p != nil {\n+\t\treturn reusePackage(p, stk)\n+\t}\n+\n+\tp := new(Package)\n+\tp.local = isLocal\n+\tp.ImportPath = importPath\n+\tpackageCache[importPath] = p\n+\n+\t// Load package.\n+\t// Import always returns bp != nil, even if an error occurs,\n+\t// in order to return partial information.\n+\t//\n+\t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n+\t// See issue 3268 for mistakes to avoid.\n+\tbp, err := buildContext.Import(path, srcDir, 0)\n+\tbp.ImportPath = importPath\n+\tif gobin != \"\" {\n+\t\tbp.BinDir = gobin\n+\t}\n+\tp.load(stk, bp, err)\n+\tif p.Error != nil && len(importPos) > 0 {\n+\t\tpos := importPos[0]\n+\t\tpos.Filename = shortPath(pos.Filename)\n+\t\tp.Error.Pos = pos.String()\n+\t}\n+\n+\treturn p\n+}\n+\n+// reusePackage reuses package p to satisfy the import at the top\n+// of the import stack stk.  If this use causes an import loop,\n+// reusePackage updates p's error information to record the loop.\n+func reusePackage(p *Package, stk *importStack) *Package {\n+\t// We use p.imports==nil to detect a package that\n+\t// is in the midst of its own loadPackage call\n+\t// (all the recursion below happens before p.imports gets set).\n+\tif p.imports == nil {\n+\t\tif p.Error == nil {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack:   stk.copy(),\n+\t\t\t\tErr:           \"import cycle not allowed\",\n+\t\t\t\tisImportCycle: true,\n+\t\t\t}\n+\t\t}\n+\t\tp.Incomplete = true\n+\t}\n+\t// Don't rewrite the import stack in the error if we have an import cycle.\n+\t// If we do, we'll lose the path that describes the cycle.\n+\tif p.Error != nil && !p.Error.isImportCycle && stk.shorterThan(p.Error.ImportStack) {\n+\t\tp.Error.ImportStack = stk.copy()\n+\t}\n+\treturn p\n+}\n+\n+type targetDir int\n+\n+const (\n+\ttoRoot targetDir = iota // to bin dir inside package root (default)\n+\ttoTool                  // GOROOT/pkg/tool\n+\ttoBin                   // GOROOT/bin\n+)\n+\n+// goTools is a map of Go program import path to install target directory.\n+var goTools = map[string]targetDir{\n+\t\"cmd/addr2line\":                        toTool,\n+\t\"cmd/api\":                              toTool,\n+\t\"cmd/cgo\":                              toTool,\n+\t\"cmd/fix\":                              toTool,\n+\t\"cmd/link\":                             toTool,\n+\t\"cmd/nm\":                               toTool,\n+\t\"cmd/objdump\":                          toTool,\n+\t\"cmd/pack\":                             toTool,\n+\t\"cmd/yacc\":                             toTool,\n+\t\"code.google.com/p/go.tools/cmd/cover\": toTool,\n+\t\"code.google.com/p/go.tools/cmd/godoc\": toBin,\n+\t\"code.google.com/p/go.tools/cmd/vet\":   toTool,\n+}\n+\n+// expandScanner expands a scanner.List error into all the errors in the list.\n+// The default Error method only shows the first error.\n+func expandScanner(err error) error {\n+\t// Look for parser errors.\n+\tif err, ok := err.(scanner.ErrorList); ok {\n+\t\t// Prepare error with \\n before each message.\n+\t\t// When printed in something like context: %v\n+\t\t// this will put the leading file positions each on\n+\t\t// its own line.  It will also show all the errors\n+\t\t// instead of just the first, as err.Error does.\n+\t\tvar buf bytes.Buffer\n+\t\tfor _, e := range err {\n+\t\t\te.Pos.Filename = shortPath(e.Pos.Filename)\n+\t\t\tbuf.WriteString(\"\\n\")\n+\t\t\tbuf.WriteString(e.Error())\n+\t\t}\n+\t\treturn errors.New(buf.String())\n+\t}\n+\treturn err\n+}\n+\n+var raceExclude = map[string]bool{\n+\t\"runtime/race\": true,\n+\t\"runtime/cgo\":  true,\n+\t\"cmd/cgo\":      true,\n+\t\"syscall\":      true,\n+\t\"errors\":       true,\n+}\n+\n+var cgoExclude = map[string]bool{\n+\t\"runtime/cgo\": true,\n+}\n+\n+var cgoSyscallExclude = map[string]bool{\n+\t\"runtime/cgo\":  true,\n+\t\"runtime/race\": true,\n+}\n+\n+// load populates p using information from bp, err, which should\n+// be the result of calling build.Context.Import.\n+func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package {\n+\tp.copyBuild(bp)\n+\n+\t// The localPrefix is the path we interpret ./ imports relative to.\n+\t// Synthesized main packages sometimes override this.\n+\tp.localPrefix = dirToImportPath(p.Dir)\n+\n+\tif err != nil {\n+\t\tp.Incomplete = true\n+\t\terr = expandScanner(err)\n+\t\tp.Error = &PackageError{\n+\t\t\tImportStack: stk.copy(),\n+\t\t\tErr:         err.Error(),\n+\t\t}\n+\t\treturn p\n+\t}\n+\n+\tif p.Name == \"main\" {\n+\t\t_, elem := filepath.Split(p.Dir)\n+\t\tfull := buildContext.GOOS + \"_\" + buildContext.GOARCH + \"/\" + elem\n+\t\tif buildContext.GOOS != toolGOOS || buildContext.GOARCH != toolGOARCH {\n+\t\t\t// Install cross-compiled binaries to subdirectories of bin.\n+\t\t\telem = full\n+\t\t}\n+\t\tif p.build.BinDir != gobin && goTools[p.ImportPath] == toBin {\n+\t\t\t// Override BinDir.\n+\t\t\t// This is from a subrepo but installs to $GOROOT/bin\n+\t\t\t// by default anyway (like godoc).\n+\t\t\tp.target = filepath.Join(gorootBin, elem)\n+\t\t} else if p.build.BinDir != \"\" {\n+\t\t\t// Install to GOBIN or bin of GOPATH entry.\n+\t\t\tp.target = filepath.Join(p.build.BinDir, elem)\n+\t\t}\n+\t\tif goTools[p.ImportPath] == toTool {\n+\t\t\t// This is for 'go tool'.\n+\t\t\t// Override all the usual logic and force it into the tool directory.\n+\t\t\tp.target = filepath.Join(gorootPkg, \"tool\", full)\n+\t\t}\n+\t\tif p.target != \"\" && buildContext.GOOS == \"windows\" {\n+\t\t\tp.target += \".exe\"\n+\t\t}\n+\t} else if p.local {\n+\t\t// Local import turned into absolute path.\n+\t\t// No permanent install target.\n+\t\tp.target = \"\"\n+\t} else {\n+\t\tp.target = p.build.PkgObj\n+\t}\n+\n+\timportPaths := p.Imports\n+\t// Packages that use cgo import runtime/cgo implicitly.\n+\t// Packages that use cgo also import syscall implicitly,\n+\t// to wrap errno.\n+\t// Exclude certain packages to avoid circular dependencies.\n+\tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoExclude[p.ImportPath]) {\n+\t\timportPaths = append(importPaths, \"runtime/cgo\")\n+\t}\n+\tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n+\t\timportPaths = append(importPaths, \"syscall\")\n+\t}\n+\t// Everything depends on runtime, except runtime and unsafe.\n+\tif !p.Standard || (p.ImportPath != \"runtime\" && p.ImportPath != \"unsafe\") {\n+\t\timportPaths = append(importPaths, \"runtime\")\n+\t\t// When race detection enabled everything depends on runtime/race.\n+\t\t// Exclude certain packages to avoid circular dependencies.\n+\t\tif buildRace && (!p.Standard || !raceExclude[p.ImportPath]) {\n+\t\t\timportPaths = append(importPaths, \"runtime/race\")\n+\t\t}\n+\t}\n+\n+\t// Build list of full paths to all Go files in the package,\n+\t// for use by commands like go fmt.\n+\tp.gofiles = stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles)\n+\tfor i := range p.gofiles {\n+\t\tp.gofiles[i] = filepath.Join(p.Dir, p.gofiles[i])\n+\t}\n+\tsort.Strings(p.gofiles)\n+\n+\tp.sfiles = stringList(p.SFiles)\n+\tfor i := range p.sfiles {\n+\t\tp.sfiles[i] = filepath.Join(p.Dir, p.sfiles[i])\n+\t}\n+\tsort.Strings(p.sfiles)\n+\n+\tp.allgofiles = stringList(p.IgnoredGoFiles)\n+\tfor i := range p.allgofiles {\n+\t\tp.allgofiles[i] = filepath.Join(p.Dir, p.allgofiles[i])\n+\t}\n+\tp.allgofiles = append(p.allgofiles, p.gofiles...)\n+\tsort.Strings(p.allgofiles)\n+\n+\t// Check for case-insensitive collision of input files.\n+\t// To avoid problems on case-insensitive files, we reject any package\n+\t// where two different input files have equal names under a case-insensitive\n+\t// comparison.\n+\tf1, f2 := foldDup(stringList(\n+\t\tp.GoFiles,\n+\t\tp.CgoFiles,\n+\t\tp.IgnoredGoFiles,\n+\t\tp.CFiles,\n+\t\tp.CXXFiles,\n+\t\tp.MFiles,\n+\t\tp.HFiles,\n+\t\tp.SFiles,\n+\t\tp.SysoFiles,\n+\t\tp.SwigFiles,\n+\t\tp.SwigCXXFiles,\n+\t\tp.TestGoFiles,\n+\t\tp.XTestGoFiles,\n+\t))\n+\tif f1 != \"\" {\n+\t\tp.Error = &PackageError{\n+\t\t\tImportStack: stk.copy(),\n+\t\t\tErr:         fmt.Sprintf(\"case-insensitive file name collision: %q and %q\", f1, f2),\n+\t\t}\n+\t\treturn p\n+\t}\n+\n+\t// Build list of imported packages and full dependency list.\n+\timports := make([]*Package, 0, len(p.Imports))\n+\tdeps := make(map[string]bool)\n+\tfor i, path := range importPaths {\n+\t\tif path == \"C\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tp1 := loadImport(path, p.Dir, stk, p.build.ImportPos[path])\n+\t\tif !reqPkgSrc && p1.Root == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p1.local {\n+\t\t\tif !p.local && p.Error == nil {\n+\t\t\t\tp.Error = &PackageError{\n+\t\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\t\tErr:         fmt.Sprintf(\"local import %q in non-local package\", path),\n+\t\t\t\t}\n+\t\t\t\tpos := p.build.ImportPos[path]\n+\t\t\t\tif len(pos) > 0 {\n+\t\t\t\t\tp.Error.Pos = pos[0].String()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tpath = p1.ImportPath\n+\t\t\timportPaths[i] = path\n+\t\t}\n+\t\tdeps[path] = true\n+\t\timports = append(imports, p1)\n+\t\tfor _, dep := range p1.Deps {\n+\t\t\tdeps[dep] = true\n+\t\t}\n+\t\tif p1.Incomplete {\n+\t\t\tp.Incomplete = true\n+\t\t}\n+\t}\n+\tp.imports = imports\n+\n+\tp.Deps = make([]string, 0, len(deps))\n+\tfor dep := range deps {\n+\t\tp.Deps = append(p.Deps, dep)\n+\t}\n+\tsort.Strings(p.Deps)\n+\tfor _, dep := range p.Deps {\n+\t\tp1 := packageCache[dep]\n+\t\tif p1 == nil {\n+\t\t\tpanic(\"impossible: missing entry in package cache for \" + dep + \" imported by \" + p.ImportPath)\n+\t\t}\n+\t\tp.deps = append(p.deps, p1)\n+\t\tif p1.Error != nil {\n+\t\t\tp.DepsErrors = append(p.DepsErrors, p1.Error)\n+\t\t}\n+\t}\n+\n+\t// unsafe is a fake package.\n+\tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n+\t\tp.target = \"\"\n+\t}\n+\tp.Target = p.target\n+\n+\t// In the absence of errors lower in the dependency tree,\n+\t// check for case-insensitive collisions of import paths.\n+\tif len(p.DepsErrors) == 0 {\n+\t\tdep1, dep2 := foldDup(p.Deps)\n+\t\tif dep1 != \"\" {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tErr:         fmt.Sprintf(\"case-insensitive import collision: %q and %q\", dep1, dep2),\n+\t\t\t}\n+\t\t\treturn p\n+\t\t}\n+\t}\n+\n+\treturn p\n+}\n+\n+// usesSwig reports whether the package needs to run SWIG.\n+func (p *Package) usesSwig() bool {\n+\treturn len(p.SwigFiles) > 0 || len(p.SwigCXXFiles) > 0\n+}\n+\n+// usesCgo reports whether the package needs to run cgo\n+func (p *Package) usesCgo() bool {\n+\treturn len(p.CgoFiles) > 0\n+}\n+\n+// packageList returns the list of packages in the dag rooted at roots\n+// as visited in a depth-first post-order traversal.\n+func packageList(roots []*Package) []*Package {\n+\tseen := map[*Package]bool{}\n+\tall := []*Package{}\n+\tvar walk func(*Package)\n+\twalk = func(p *Package) {\n+\t\tif seen[p] {\n+\t\t\treturn\n+\t\t}\n+\t\tseen[p] = true\n+\t\tfor _, p1 := range p.imports {\n+\t\t\twalk(p1)\n+\t\t}\n+\t\tall = append(all, p)\n+\t}\n+\tfor _, root := range roots {\n+\t\twalk(root)\n+\t}\n+\treturn all\n+}\n+\n+// computeStale computes the Stale flag in the package dag that starts\n+// at the named pkgs (command-line arguments).\n+func computeStale(pkgs ...*Package) {\n+\ttopRoot := map[string]bool{}\n+\tfor _, p := range pkgs {\n+\t\ttopRoot[p.Root] = true\n+\t}\n+\n+\tfor _, p := range packageList(pkgs) {\n+\t\tp.Stale = isStale(p, topRoot)\n+\t}\n+}\n+\n+// isStale reports whether package p needs to be rebuilt.\n+func isStale(p *Package, topRoot map[string]bool) bool {\n+\tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n+\t\t// fake, builtin package\n+\t\treturn false\n+\t}\n+\tif p.Error != nil {\n+\t\treturn true\n+\t}\n+\n+\t// A package without Go sources means we only found\n+\t// the installed .a file.  Since we don't know how to rebuild\n+\t// it, it can't be stale, even if -a is set.  This enables binary-only\n+\t// distributions of Go packages, although such binaries are\n+\t// only useful with the specific version of the toolchain that\n+\t// created them.\n+\tif len(p.gofiles) == 0 && !p.usesSwig() {\n+\t\treturn false\n+\t}\n+\n+\tif buildA || p.target == \"\" || p.Stale {\n+\t\treturn true\n+\t}\n+\n+\t// Package is stale if completely unbuilt.\n+\tvar built time.Time\n+\tif fi, err := os.Stat(p.target); err == nil {\n+\t\tbuilt = fi.ModTime()\n+\t}\n+\tif built.IsZero() {\n+\t\treturn true\n+\t}\n+\n+\tolderThan := func(file string) bool {\n+\t\tfi, err := os.Stat(file)\n+\t\treturn err != nil || fi.ModTime().After(built)\n+\t}\n+\n+\t// Package is stale if a dependency is, or if a dependency is newer.\n+\tfor _, p1 := range p.deps {\n+\t\tif p1.Stale || p1.target != \"\" && olderThan(p1.target) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// As a courtesy to developers installing new versions of the compiler\n+\t// frequently, define that packages are stale if they are\n+\t// older than the compiler, and commands if they are older than\n+\t// the linker.  This heuristic will not work if the binaries are\n+\t// back-dated, as some binary distributions may do, but it does handle\n+\t// a very common case.\n+\t// See issue 3036.\n+\t// Assume code in $GOROOT is up to date, since it may not be writeable.\n+\t// See issue 4106.\n+\tif p.Root != goroot {\n+\t\tif olderThan(buildToolchain.compiler()) {\n+\t\t\treturn true\n+\t\t}\n+\t\tif p.build.IsCommand() && olderThan(buildToolchain.linker()) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// Have installed copy, probably built using current compilers,\n+\t// and built after its imported packages.  The only reason now\n+\t// that we'd have to rebuild it is if the sources were newer than\n+\t// the package.   If a package p is not in the same tree as any\n+\t// package named on the command-line, assume it is up-to-date\n+\t// no matter what the modification times on the source files indicate.\n+\t// This avoids rebuilding $GOROOT packages when people are\n+\t// working outside the Go root, and it effectively makes each tree\n+\t// listed in $GOPATH a separate compilation world.\n+\t// See issue 3149.\n+\tif p.Root != \"\" && !topRoot[p.Root] {\n+\t\treturn false\n+\t}\n+\n+\tsrcs := stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n+\tfor _, src := range srcs {\n+\t\tif olderThan(filepath.Join(p.Dir, src)) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+var cwd, _ = os.Getwd()\n+\n+var cmdCache = map[string]*Package{}\n+\n+// loadPackage is like loadImport but is used for command-line arguments,\n+// not for paths found in import statements.  In addition to ordinary import paths,\n+// loadPackage accepts pseudo-paths beginning with cmd/ to denote commands\n+// in the Go command directory, as well as paths to those directories.\n+func loadPackage(arg string, stk *importStack) *Package {\n+\tif build.IsLocalImport(arg) {\n+\t\tdir := arg\n+\t\tif !filepath.IsAbs(dir) {\n+\t\t\tif abs, err := filepath.Abs(dir); err == nil {\n+\t\t\t\t// interpret relative to current directory\n+\t\t\t\tdir = abs\n+\t\t\t}\n+\t\t}\n+\t\tif sub, ok := hasSubdir(gorootSrc, dir); ok && strings.HasPrefix(sub, \"cmd/\") && !strings.Contains(sub[4:], \"/\") {\n+\t\t\targ = sub\n+\t\t}\n+\t}\n+\tif strings.HasPrefix(arg, \"cmd/\") {\n+\t\tif p := cmdCache[arg]; p != nil {\n+\t\t\treturn p\n+\t\t}\n+\t\tstk.push(arg)\n+\t\tdefer stk.pop()\n+\n+\t\tif strings.Contains(arg[4:], \"/\") {\n+\t\t\tp := &Package{\n+\t\t\t\tError: &PackageError{\n+\t\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\t\tErr:         fmt.Sprintf(\"invalid import path: cmd/... is reserved for Go commands\"),\n+\t\t\t\t\thard:        true,\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\treturn p\n+\t\t}\n+\n+\t\tbp, err := buildContext.ImportDir(filepath.Join(gorootSrc, arg), 0)\n+\t\tbp.ImportPath = arg\n+\t\tbp.Goroot = true\n+\t\tbp.BinDir = gorootBin\n+\t\tif gobin != \"\" {\n+\t\t\tbp.BinDir = gobin\n+\t\t}\n+\t\tbp.Root = goroot\n+\t\tbp.SrcRoot = gorootSrc\n+\t\tp := new(Package)\n+\t\tcmdCache[arg] = p\n+\t\tp.load(stk, bp, err)\n+\t\tif p.Error == nil && p.Name != \"main\" {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tErr:         fmt.Sprintf(\"expected package main but found package %s in %s\", p.Name, p.Dir),\n+\t\t\t}\n+\t\t}\n+\t\treturn p\n+\t}\n+\n+\t// Wasn't a command; must be a package.\n+\t// If it is a local import path but names a standard package,\n+\t// we treat it as if the user specified the standard package.\n+\t// This lets you run go test ./ioutil in package io and be\n+\t// referring to io/ioutil rather than a hypothetical import of\n+\t// \"./ioutil\".\n+\tif build.IsLocalImport(arg) {\n+\t\tbp, _ := buildContext.ImportDir(filepath.Join(cwd, arg), build.FindOnly)\n+\t\tif bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n+\t\t\targ = bp.ImportPath\n+\t\t}\n+\t}\n+\n+\treturn loadImport(arg, cwd, stk, nil)\n+}\n+\n+// packages returns the packages named by the\n+// command line arguments 'args'.  If a named package\n+// cannot be loaded at all (for example, if the directory does not exist),\n+// then packages prints an error and does not include that\n+// package in the results.  However, if errors occur trying\n+// to load dependencies of a named package, the named\n+// package is still returned, with p.Incomplete = true\n+// and details in p.DepsErrors.\n+func packages(args []string) []*Package {\n+\tvar pkgs []*Package\n+\tfor _, pkg := range packagesAndErrors(args) {\n+\t\tif pkg.Error != nil {\n+\t\t\terrorf(\"can't load package: %s\", pkg.Error)\n+\t\t\tcontinue\n+\t\t}\n+\t\tpkgs = append(pkgs, pkg)\n+\t}\n+\treturn pkgs\n+}\n+\n+// packagesAndErrors is like 'packages' but returns a\n+// *Package for every argument, even the ones that\n+// cannot be loaded at all.\n+// The packages that fail to load will have p.Error != nil.\n+func packagesAndErrors(args []string) []*Package {\n+\tif len(args) > 0 && strings.HasSuffix(args[0], \".go\") {\n+\t\treturn []*Package{goFilesPackage(args)}\n+\t}\n+\n+\targs = importPaths(args)\n+\tvar pkgs []*Package\n+\tvar stk importStack\n+\tvar set = make(map[string]bool)\n+\n+\tfor _, arg := range args {\n+\t\tif !set[arg] {\n+\t\t\tpkgs = append(pkgs, loadPackage(arg, &stk))\n+\t\t\tset[arg] = true\n+\t\t}\n+\t}\n+\tcomputeStale(pkgs...)\n+\n+\treturn pkgs\n+}\n+\n+// packagesForBuild is like 'packages' but fails if any of\n+// the packages or their dependencies have errors\n+// (cannot be built).\n+func packagesForBuild(args []string) []*Package {\n+\tpkgs := packagesAndErrors(args)\n+\tprinted := map[*PackageError]bool{}\n+\tfor _, pkg := range pkgs {\n+\t\tif pkg.Error != nil {\n+\t\t\terrorf(\"can't load package: %s\", pkg.Error)\n+\t\t}\n+\t\tfor _, err := range pkg.DepsErrors {\n+\t\t\t// Since these are errors in dependencies,\n+\t\t\t// the same error might show up multiple times,\n+\t\t\t// once in each package that depends on it.\n+\t\t\t// Only print each once.\n+\t\t\tif !printed[err] {\n+\t\t\t\tprinted[err] = true\n+\t\t\t\terrorf(\"%s\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\texitIfErrors()\n+\treturn pkgs\n+}\n+\n+// hasSubdir reports whether dir is a subdirectory of\n+// (possibly multiple levels below) root.\n+// If so, it sets rel to the path fragment that must be\n+// appended to root to reach dir.\n+func hasSubdir(root, dir string) (rel string, ok bool) {\n+\tif p, err := filepath.EvalSymlinks(root); err == nil {\n+\t\troot = p\n+\t}\n+\tif p, err := filepath.EvalSymlinks(dir); err == nil {\n+\t\tdir = p\n+\t}\n+\tconst sep = string(filepath.Separator)\n+\troot = filepath.Clean(root)\n+\tif !strings.HasSuffix(root, sep) {\n+\t\troot += sep\n+\t}\n+\tdir = filepath.Clean(dir)\n+\tif !strings.HasPrefix(dir, root) {\n+\t\treturn \"\", false\n+\t}\n+\treturn filepath.ToSlash(dir[len(root):]), true\n+}"}, {"sha": "06b9f0ac6ebcb0fe1802756c8355edc86d07b72d", "filename": "libgo/go/cmd/go/pkg_test.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var foldDupTests = []struct {\n+\tlist   []string\n+\tf1, f2 string\n+}{\n+\t{stringList(\"math/rand\", \"math/big\"), \"\", \"\"},\n+\t{stringList(\"math\", \"strings\"), \"\", \"\"},\n+\t{stringList(\"strings\"), \"\", \"\"},\n+\t{stringList(\"strings\", \"strings\"), \"strings\", \"strings\"},\n+\t{stringList(\"Rand\", \"rand\", \"math\", \"math/rand\", \"math/Rand\"), \"Rand\", \"rand\"},\n+}\n+\n+func TestFoldDup(t *testing.T) {\n+\tfor _, tt := range foldDupTests {\n+\t\tf1, f2 := foldDup(tt.list)\n+\t\tif f1 != tt.f1 || f2 != tt.f2 {\n+\t\t\tt.Errorf(\"foldDup(%q) = %q, %q, want %q, %q\", tt.list, f1, f2, tt.f1, tt.f2)\n+\t\t}\n+\t}\n+}\n+\n+var parseMetaGoImportsTests = []struct {\n+\tin  string\n+\tout []metaImport\n+}{\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t<meta name=\"go-import\" content=\"baz/quux git http://github.com/rsc/baz/quux\">`,\n+\t\t[]metaImport{\n+\t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n+\t\t\t{\"baz/quux\", \"git\", \"http://github.com/rsc/baz/quux\"},\n+\t\t},\n+\t},\n+\t{\n+\t\t`<head>\n+\t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t</head>`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t<body>`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+}\n+\n+func TestParseMetaGoImports(t *testing.T) {\n+\tfor i, tt := range parseMetaGoImportsTests {\n+\t\tout, err := parseMetaGoImports(strings.NewReader(tt.in))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"test#%d: %v\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !reflect.DeepEqual(out, tt.out) {\n+\t\t\tt.Errorf(\"test#%d:\\n\\thave %q\\n\\twant %q\", i, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "ef8aa95a351aa3c938bc258dc78d2140a97d6f94", "filename": "libgo/go/cmd/go/run.go", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Frun.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strings\"\n+)\n+\n+var execCmd []string // -exec flag, for run and test\n+\n+func findExecCmd() []string {\n+\tif execCmd != nil {\n+\t\treturn execCmd\n+\t}\n+\texecCmd = []string{} // avoid work the second time\n+\tif goos == runtime.GOOS && goarch == runtime.GOARCH {\n+\t\treturn execCmd\n+\t}\n+\tpath, err := exec.LookPath(fmt.Sprintf(\"go_%s_%s_exec\", goos, goarch))\n+\tif err == nil {\n+\t\texecCmd = []string{path}\n+\t}\n+\treturn execCmd\n+}\n+\n+var cmdRun = &Command{\n+\tUsageLine: \"run [build flags] [-exec xprog] gofiles... [arguments...]\",\n+\tShort:     \"compile and run Go program\",\n+\tLong: `\n+Run compiles and runs the main package comprising the named Go source files.\n+A Go source file is defined to be a file ending in a literal \".go\" suffix.\n+\n+By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n+If the -exec flag is given, 'go run' invokes the binary using xprog: 'xprog a.out arguments...'.\n+If the -exec flag is not given, GOOS or GOARCH is different from the system\n+default, and a program named go_$GOOS_$GOARCH_exec can be found\n+on the current search path, 'go run' invokes the binary using that program,\n+for example 'go_nacl_386_exec a.out arguments...'. This allows execution of\n+cross-compiled programs when a simulator or other execution method is\n+available.\n+\n+For more about build flags, see 'go help build'.\n+\n+See also: go build.\n+\t`,\n+}\n+\n+func init() {\n+\tcmdRun.Run = runRun // break init loop\n+\n+\taddBuildFlags(cmdRun)\n+\tcmdRun.Flag.Var((*stringsFlag)(&execCmd), \"exec\", \"\")\n+}\n+\n+func printStderr(args ...interface{}) (int, error) {\n+\treturn fmt.Fprint(os.Stderr, args...)\n+}\n+\n+func runRun(cmd *Command, args []string) {\n+\traceInit()\n+\tvar b builder\n+\tb.init()\n+\tb.print = printStderr\n+\ti := 0\n+\tfor i < len(args) && strings.HasSuffix(args[i], \".go\") {\n+\t\ti++\n+\t}\n+\tfiles, cmdArgs := args[:i], args[i:]\n+\tif len(files) == 0 {\n+\t\tfatalf(\"go run: no go files listed\")\n+\t}\n+\tfor _, file := range files {\n+\t\tif strings.HasSuffix(file, \"_test.go\") {\n+\t\t\t// goFilesPackage is going to assign this to TestGoFiles.\n+\t\t\t// Reject since it won't be part of the build.\n+\t\t\tfatalf(\"go run: cannot run *_test.go files (%s)\", file)\n+\t\t}\n+\t}\n+\tp := goFilesPackage(files)\n+\tif p.Error != nil {\n+\t\tfatalf(\"%s\", p.Error)\n+\t}\n+\tp.omitDWARF = true\n+\tfor _, err := range p.DepsErrors {\n+\t\terrorf(\"%s\", err)\n+\t}\n+\texitIfErrors()\n+\tif p.Name != \"main\" {\n+\t\tfatalf(\"go run: cannot run non-main package\")\n+\t}\n+\tp.target = \"\" // must build - not up to date\n+\tvar src string\n+\tif len(p.GoFiles) > 0 {\n+\t\tsrc = p.GoFiles[0]\n+\t} else if len(p.CgoFiles) > 0 {\n+\t\tsrc = p.CgoFiles[0]\n+\t} else {\n+\t\t// this case could only happen if the provided source uses cgo\n+\t\t// while cgo is disabled.\n+\t\thint := \"\"\n+\t\tif !buildContext.CgoEnabled {\n+\t\t\thint = \" (cgo is disabled)\"\n+\t\t}\n+\t\tfatalf(\"go run: no suitable source files%s\", hint)\n+\t}\n+\tp.exeName = src[:len(src)-len(\".go\")] // name temporary executable for first go file\n+\ta1 := b.action(modeBuild, modeBuild, p)\n+\ta := &action{f: (*builder).runProgram, args: cmdArgs, deps: []*action{a1}}\n+\tb.do(a)\n+}\n+\n+// runProgram is the action for running a binary that has already\n+// been compiled.  We ignore exit status.\n+func (b *builder) runProgram(a *action) error {\n+\tcmdline := stringList(findExecCmd(), a.deps[0].target, a.args)\n+\tif buildN || buildX {\n+\t\tb.showcmd(\"\", \"%s\", strings.Join(cmdline, \" \"))\n+\t\tif buildN {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\trunStdin(cmdline)\n+\treturn nil\n+}\n+\n+// runStdin is like run, but connects Stdin.\n+func runStdin(cmdline []string) {\n+\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\tcmd.Stdin = os.Stdin\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tstartSigHandlers()\n+\tif err := cmd.Run(); err != nil {\n+\t\terrorf(\"%v\", err)\n+\t}\n+}"}, {"sha": "340a7e824cafd64b280d8e50454d752f2f0d0640", "filename": "libgo/go/cmd/go/script", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fscript", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fscript", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,23 @@\n+#!/bin/sh\n+\n+x() {\n+\techo '--- ' \"$@\"\n+\t\"$@\"\n+\techo '---'\n+\techo\n+}\n+\n+x go help\n+x go help build\n+x go help clean\n+x go help install\n+x go help fix\n+x go help fmt\n+x go help get\n+x go help list\n+x go help test\n+x go help version\n+x go help vet\n+x go help gopath\n+x go help importpath\n+x go help remote"}, {"sha": "a672146584e6cae5c5606e25d9effd8a94a2093a", "filename": "libgo/go/cmd/go/script.txt", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fscript.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fscript.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript.txt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,352 @@\n+---  go help\n+usage: go command [arguments]\n+\n+go manages Go source code.\n+\n+The commands are:\n+\n+    build       compile and install packages and dependencies\n+    clean       remove intermediate objects\n+    fix         run gofix on packages\n+    fmt         run gofmt -w on packages\n+    get         download and install packages and dependencies\n+    install     install packages and dependencies\n+    list        list packages\n+    test        test packages\n+    version     print Go version\n+    vet         run govet on packages\n+\n+Use \"go help [command]\" for more information about a command.\n+\n+Additional help topics:\n+\n+    gopath      GOPATH environment variable\n+    importpath  description of import paths\n+    remote      remote import path syntax\n+\n+Use \"go help [topic]\" for more information about that topic.\n+\n+---\n+\n+---  go help build\n+usage: go build [-n] [-v] [importpath...]\n+\n+Build compiles the packages named by the import paths,\n+along with their dependencies, but it does not install the results.\n+\n+The -n flag prints the commands but does not run them.\n+The -v flag prints the commands.\n+\n+For more about import paths, see 'go help importpath'.\n+\n+See also: go install, go get, go clean.\n+---\n+\n+---  go help clean\n+usage: go clean [-nuke] [importpath...]\n+\n+Clean removes intermediate object files generated during\n+the compilation of the packages named by the import paths,\n+but by default it does not remove the installed package binaries.\n+\n+The -nuke flag causes clean to remove the installed package binaries too.\n+\n+TODO: Clean does not clean dependencies of the packages.\n+\n+For more about import paths, see 'go help importpath'.\n+---\n+\n+---  go help install\n+usage: go install [-n] [-v] [importpath...]\n+\n+Install compiles and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+The -n flag prints the commands but does not run them.\n+The -v flag prints the commands.\n+\n+For more about import paths, see 'go help importpath'.\n+\n+See also: go build, go get, go clean.\n+---\n+\n+---  go help fix\n+usage: go fix [importpath...]\n+\n+Fix runs the gofix command on the packages named by the import paths.\n+\n+For more about gofix, see 'godoc gofix'.\n+For more about import paths, see 'go help importpath'.\n+\n+To run gofix with specific options, run gofix itself.\n+\n+See also: go fmt, go vet.\n+---\n+\n+---  go help fmt\n+usage: go fmt [importpath...]\n+\n+Fmt runs the command 'gofmt -w' on the packages named by the import paths.\n+\n+For more about gofmt, see 'godoc gofmt'.\n+For more about import paths, see 'go help importpath'.\n+\n+To run gofmt with specific options, run gofmt itself.\n+\n+See also: go fix, go vet.\n+---\n+\n+---  go help get\n+usage: go get [importpath...]\n+\n+Get downloads and installs the packages named by the import paths,\n+along with their dependencies.\n+\n+After downloading the code, 'go get' looks for a tag beginning\n+with \"go.\" that corresponds to the local Go version.\n+For Go \"release.r58\" it looks for a tag named \"go.r58\".\n+For \"weekly.2011-06-03\" it looks for \"go.weekly.2011-06-03\".\n+If the specific \"go.X\" tag is not found, it uses the latest earlier\n+version it can find.  Otherwise, it uses the default version for\n+the version control system: HEAD for git, tip for Mercurial,\n+and so on.\n+\n+TODO: Explain versions better.\n+\n+For more about import paths, see 'go help importpath'.\n+\n+For more about how 'go get' finds source code to\n+download, see 'go help remote'.\n+\n+See also: go build, go install, go clean.\n+---\n+\n+---  go help list\n+usage: go list [-f format] [-json] [importpath...]\n+\n+List lists the packages named by the import paths.\n+\n+The default output shows the package name and file system location:\n+\n+    books /home/you/src/google-api-go-client.googlecode.com/hg/books/v1\n+    oauth /home/you/src/goauth2.googlecode.com/hg/oauth\n+    sqlite /home/you/src/gosqlite.googlecode.com/hg/sqlite\n+\n+The -f flag specifies an alternate format for the list,\n+using the syntax of package template.  The default output\n+is equivalent to -f '{{.Name}} {{.Dir}}'  The struct\n+being passed to the template is:\n+\n+    type Package struct {\n+        Name string         // package name\n+        Doc string          // package documentation string\n+        GoFiles []string    // names of Go source files in package\n+        ImportPath string   // import path denoting package\n+        Imports []string    // import paths used by this package\n+        Deps []string       // all (recursively) imported dependencies\n+        Dir string          // directory containing package sources\n+        Version string      // version of installed package\n+    }\n+\n+The -json flag causes the package data to be printed in JSON format.\n+\n+For more about import paths, see 'go help importpath'.\n+---\n+\n+---  go help test\n+usage: go test [importpath...]\n+\n+Test runs gotest to test the packages named by the import paths.\n+It prints a summary of the test results in the format:\n+\n+\ttest archive/tar\n+\tFAIL archive/zip\n+\ttest compress/gzip\n+\t...\n+\n+followed by gotest output for each failed package.\n+\n+For more about import paths, see 'go help importpath'.\n+\n+See also: go build, go compile, go vet.\n+---\n+\n+---  go help version\n+usage: go version\n+\n+Version prints the Go version, as reported by runtime.Version.\n+---\n+\n+---  go help vet\n+usage: go vet [importpath...]\n+\n+Vet runs the govet command on the packages named by the import paths.\n+\n+For more about govet, see 'godoc govet'.\n+For more about import paths, see 'go help importpath'.\n+\n+To run govet with specific options, run govet itself.\n+\n+See also: go fmt, go fix.\n+---\n+\n+---  go help gopath\n+The GOPATH environment variable lists places to look for Go code.\n+On Unix, the value is a colon-separated string.\n+On Windows, the value is a semicolon-separated string.\n+On Plan 9, the value is a list.\n+\n+GOPATH must be set to build and install packages outside the\n+standard Go tree.\n+\n+Each directory listed in GOPATH must have a prescribed structure:\n+\n+The src/ directory holds source code.  The path below 'src'\n+determines the import path or executable name.\n+\n+The pkg/ directory holds installed package objects.\n+As in the Go tree, each target operating system and\n+architecture pair has its own subdirectory of pkg\n+(pkg/GOOS_GOARCH).\n+\n+If DIR is a directory listed in the GOPATH, a package with\n+source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n+has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n+\n+The bin/ directory holds compiled commands.\n+Each command is named for its source directory, but only\n+the final element, not the entire path.  That is, the\n+command with source in DIR/src/foo/quux is installed into\n+DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n+so that you can add DIR/bin to your PATH to get at the\n+installed commands.\n+\n+Here's an example directory layout:\n+\n+    GOPATH=/home/user/gocode\n+\n+    /home/user/gocode/\n+        src/\n+            foo/\n+                bar/               (go code in package bar)\n+                    x.go\n+                quux/              (go code in package main)\n+                    y.go\n+        bin/\n+            quux                   (installed command)\n+\t\tpkg/\n+\t\t    linux_amd64/\n+\t\t        foo/\n+\t\t            bar.a          (installed package object)\n+\n+Go searches each directory listed in GOPATH to find source code,\n+but new packages are always downloaded into the first directory \n+in the list.\n+---\n+\n+---  go help importpath\n+Many commands apply to a set of packages named by import paths:\n+\n+\tgo action [importpath...]\n+\n+An import path that is a rooted path or that begins with\n+a . or .. element is interpreted as a file system path and\n+denotes the package in that directory.\n+\n+Otherwise, the import path P denotes the package found in\n+the directory DIR/src/P for some DIR listed in the GOPATH\n+environment variable (see 'go help gopath'). \n+\n+If no import paths are given, the action applies to the\n+package in the current directory.\n+\n+The special import path \"all\" expands to all package directories\n+found in all the GOPATH trees.  For example, 'go list all' \n+lists all the packages on the local system.\n+\n+An import path can also name a package to be downloaded from\n+a remote repository.  Run 'go help remote' for details.\n+\n+Every package in a program must have a unique import path.\n+By convention, this is arranged by starting each path with a\n+unique prefix that belongs to you.  For example, paths used\n+internally at Google all begin with 'google', and paths\n+denoting remote repositories begin with the path to the code,\n+such as 'project.googlecode.com/'.\n+---\n+\n+---  go help remote\n+An import path (see 'go help importpath') denotes a package\n+stored in the local file system.  Certain import paths also\n+describe how to obtain the source code for the package using\n+a revision control system.\n+\n+A few common code hosting sites have special syntax:\n+\n+\tBitBucket (Mercurial)\n+\n+\t\timport \"bitbucket.org/user/project\"\n+\t\timport \"bitbucket.org/user/project/sub/directory\"\n+\n+\tGitHub (Git)\n+\n+\t\timport \"github.com/user/project\"\n+\t\timport \"github.com/user/project/sub/directory\"\n+\n+\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n+\n+\t\timport \"project.googlecode.com/git\"\n+\t\timport \"project.googlecode.com/git/sub/directory\"\n+\n+\t\timport \"project.googlecode.com/hg\"\n+\t\timport \"project.googlecode.com/hg/sub/directory\"\n+\n+\t\timport \"project.googlecode.com/svn/trunk\"\n+\t\timport \"project.googlecode.com/svn/trunk/sub/directory\"\n+\n+\tLaunchpad (Bazaar)\n+\n+\t\timport \"launchpad.net/project\"\n+\t\timport \"launchpad.net/project/series\"\n+\t\timport \"launchpad.net/project/series/sub/directory\"\n+\n+\t\timport \"launchpad.net/~user/project/branch\"\n+\t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n+\n+For code hosted on other servers, an import path of the form\n+\n+\trepository.vcs/path\n+\n+specifies the given repository, with or without the .vcs suffix,\n+using the named version control system, and then the path inside\n+that repository.  The supported version control systems are:\n+\n+\tBazaar      .bzr\n+\tGit         .git\n+\tMercurial   .hg\n+\tSubversion  .svn\n+\n+For example,\n+\n+\timport \"example.org/user/foo.hg\"\n+\n+denotes the root directory of the Mercurial repository at\n+example.org/user/foo or foo.hg, and\n+\n+\timport \"example.org/repo.git/foo/bar\"\n+\n+denotes the foo/bar directory of the Git repository at\n+example.com/repo or repo.git.\n+\n+When a version control system supports multiple protocols,\n+each is tried in turn when downloading.  For example, a Git\n+download tries git://, then https://, then http://.\n+\n+New downloaded packages are written to the first directory\n+listed in the GOPATH environment variable (see 'go help gopath').\n+\n+The go command attempts to download the version of the\n+package appropriate for the Go release being used.\n+Run 'go help install' for more.\n+---\n+"}, {"sha": "e8ba0d36556ad4efd9f2a83e8c8b37cf0e95c24e", "filename": "libgo/go/cmd/go/signal.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"sync\"\n+)\n+\n+// interrupted is closed, if go process is interrupted.\n+var interrupted = make(chan struct{})\n+\n+// processSignals setups signal handler.\n+func processSignals() {\n+\tsig := make(chan os.Signal)\n+\tsignal.Notify(sig, signalsToIgnore...)\n+\tgo func() {\n+\t\t<-sig\n+\t\tclose(interrupted)\n+\t}()\n+}\n+\n+var onceProcessSignals sync.Once\n+\n+// startSigHandlers start signal handlers.\n+func startSigHandlers() {\n+\tonceProcessSignals.Do(processSignals)\n+}"}, {"sha": "29aa9d8c209ada3ee07d17dbb1e623b98bc6e379", "filename": "libgo/go/cmd/go/signal_notunix.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal_notunix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal_notunix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal_notunix.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build plan9 windows\n+\n+package main\n+\n+import (\n+\t\"os\"\n+)\n+\n+var signalsToIgnore = []os.Signal{os.Interrupt}\n+\n+// signalTrace is the signal to send to make a Go program\n+// crash with a stack trace.\n+var signalTrace os.Signal = nil"}, {"sha": "e86cd4652311ccdb851d7cfa72c596a6dbb2fdf9", "filename": "libgo/go/cmd/go/signal_unix.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fsignal_unix.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n+\n+package main\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+var signalsToIgnore = []os.Signal{os.Interrupt, syscall.SIGQUIT}\n+\n+// signalTrace is the signal to send to make a Go program\n+// crash with a stack trace.\n+var signalTrace os.Signal = syscall.SIGQUIT"}, {"sha": "ffe218c7b6d5d77154e2428c12837f08b8871dc2", "filename": "libgo/go/cmd/go/tag_test.go", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftag_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"testing\"\n+\n+var selectTagTestTags = []string{\n+\t\"go.r58\",\n+\t\"go.r58.1\",\n+\t\"go.r59\",\n+\t\"go.r59.1\",\n+\t\"go.r61\",\n+\t\"go.r61.1\",\n+\t\"go.weekly.2010-01-02\",\n+\t\"go.weekly.2011-10-12\",\n+\t\"go.weekly.2011-10-12.1\",\n+\t\"go.weekly.2011-10-14\",\n+\t\"go.weekly.2011-11-01\",\n+\t\"go1\",\n+\t\"go1.0.1\",\n+\t\"go1.999\",\n+\t\"go1.9.2\",\n+\t\"go5\",\n+\n+\t// these should be ignored:\n+\t\"release.r59\",\n+\t\"release.r59.1\",\n+\t\"release\",\n+\t\"weekly.2011-10-12\",\n+\t\"weekly.2011-10-12.1\",\n+\t\"weekly\",\n+\t\"foo\",\n+\t\"bar\",\n+\t\"go.f00\",\n+\t\"go!r60\",\n+\t\"go.1999-01-01\",\n+\t\"go.2x\",\n+\t\"go.20000000000000\",\n+\t\"go.2.\",\n+\t\"go.2.0\",\n+\t\"go2x\",\n+\t\"go20000000000000\",\n+\t\"go2.\",\n+\t\"go2.0\",\n+}\n+\n+var selectTagTests = []struct {\n+\tversion  string\n+\tselected string\n+}{\n+\t/*\n+\t\t{\"release.r57\", \"\"},\n+\t\t{\"release.r58.2\", \"go.r58.1\"},\n+\t\t{\"release.r59\", \"go.r59\"},\n+\t\t{\"release.r59.1\", \"go.r59.1\"},\n+\t\t{\"release.r60\", \"go.r59.1\"},\n+\t\t{\"release.r60.1\", \"go.r59.1\"},\n+\t\t{\"release.r61\", \"go.r61\"},\n+\t\t{\"release.r66\", \"go.r61.1\"},\n+\t\t{\"weekly.2010-01-01\", \"\"},\n+\t\t{\"weekly.2010-01-02\", \"go.weekly.2010-01-02\"},\n+\t\t{\"weekly.2010-01-02.1\", \"go.weekly.2010-01-02\"},\n+\t\t{\"weekly.2010-01-03\", \"go.weekly.2010-01-02\"},\n+\t\t{\"weekly.2011-10-12\", \"go.weekly.2011-10-12\"},\n+\t\t{\"weekly.2011-10-12.1\", \"go.weekly.2011-10-12.1\"},\n+\t\t{\"weekly.2011-10-13\", \"go.weekly.2011-10-12.1\"},\n+\t\t{\"weekly.2011-10-14\", \"go.weekly.2011-10-14\"},\n+\t\t{\"weekly.2011-10-14.1\", \"go.weekly.2011-10-14\"},\n+\t\t{\"weekly.2011-11-01\", \"go.weekly.2011-11-01\"},\n+\t\t{\"weekly.2014-01-01\", \"go.weekly.2011-11-01\"},\n+\t\t{\"weekly.3000-01-01\", \"go.weekly.2011-11-01\"},\n+\t\t{\"go1\", \"go1\"},\n+\t\t{\"go1.1\", \"go1.0.1\"},\n+\t\t{\"go1.998\", \"go1.9.2\"},\n+\t\t{\"go1.1000\", \"go1.999\"},\n+\t\t{\"go6\", \"go5\"},\n+\n+\t\t// faulty versions:\n+\t\t{\"release.f00\", \"\"},\n+\t\t{\"weekly.1999-01-01\", \"\"},\n+\t\t{\"junk\", \"\"},\n+\t\t{\"\", \"\"},\n+\t\t{\"go2x\", \"\"},\n+\t\t{\"go200000000000\", \"\"},\n+\t\t{\"go2.\", \"\"},\n+\t\t{\"go2.0\", \"\"},\n+\t*/\n+\t{\"anything\", \"go1\"},\n+}\n+\n+func TestSelectTag(t *testing.T) {\n+\tfor _, c := range selectTagTests {\n+\t\tselected := selectTag(c.version, selectTagTestTags)\n+\t\tif selected != c.selected {\n+\t\t\tt.Errorf(\"selectTag(%q) = %q, want %q\", c.version, selected, c.selected)\n+\t\t}\n+\t}\n+}"}, {"sha": "0060ce2185f3f8e2f3d3545344db5b2814ee9306", "filename": "libgo/go/cmd/go/test.bash", "status": "added", "additions": 820, "deletions": 0, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.bash?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,820 @@\n+#!/bin/bash\n+# Copyright 2012 The Go Authors.  All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+set -e\n+go build -o testgo\n+go() {\n+\techo TEST ERROR: ran go, not testgo: go \"$@\" >&2\n+\texit 2\n+}\n+\n+started=false\n+TEST() {\n+\tif $started; then\n+\t\tstop\n+\tfi\n+\techo TEST: \"$@\"\n+\tstarted=true\n+\tok=true\n+}\n+stop() {\n+\tif ! $started; then\n+\t\techo TEST ERROR: stop missing start >&2\n+\t\texit 2\n+\tfi\n+\tstarted=false\n+\tif $ok; then\n+\t\techo PASS\n+\telse\n+\t\techo FAIL\n+\t\tallok=false\n+\tfi\n+}\n+\n+ok=true\n+allok=true\n+\n+unset GOBIN\n+unset GOPATH\n+unset GOROOT\n+\n+TEST 'file:line in error messages'\n+# Test that error messages have file:line information at beginning of\n+# the line. Also test issue 4917: that the error is on stderr.\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+fn=$d/err.go\n+echo \"package main\" > $fn\n+echo 'import \"bar\"' >> $fn\n+./testgo run $fn 2>$d/err.out || true\n+if ! grep -q \"^$fn:\" $d/err.out; then\n+\techo \"missing file:line in error message\"\n+\tcat $d/err.out\n+\tok=false\n+fi\n+rm -r $d\n+\n+# Test local (./) imports.\n+testlocal() {\n+\tlocal=\"$1\"\n+\tTEST local imports $2 '(easy)'\n+\t./testgo build -o hello \"testdata/$local/easy.go\"\n+\t./hello >hello.out\n+\tif ! grep -q '^easysub\\.Hello' hello.out; then\n+\t\techo \"testdata/$local/easy.go did not generate expected output\"\n+\t\tcat hello.out\n+\t\tok=false\n+\tfi\n+\t\n+\tTEST local imports $2 '(easysub)'\n+\t./testgo build -o hello \"testdata/$local/easysub/main.go\"\n+\t./hello >hello.out\n+\tif ! grep -q '^easysub\\.Hello' hello.out; then\n+\t\techo \"testdata/$local/easysub/main.go did not generate expected output\"\n+\t\tcat hello.out\n+\t\tok=false\n+\tfi\n+\t\n+\tTEST local imports $2 '(hard)'\n+\t./testgo build -o hello \"testdata/$local/hard.go\"\n+\t./hello >hello.out\n+\tif ! grep -q '^sub\\.Hello' hello.out || ! grep -q '^subsub\\.Hello' hello.out ; then\n+\t\techo \"testdata/$local/hard.go did not generate expected output\"\n+\t\tcat hello.out\n+\t\tok=false\n+\tfi\n+\t\n+\trm -f hello.out hello\n+\t\n+\t# Test that go install x.go fails.\n+\tTEST local imports $2 '(go install should fail)'\n+\tif ./testgo install \"testdata/$local/easy.go\" >/dev/null 2>&1; then\n+\t\techo \"go install testdata/$local/easy.go succeeded\"\n+\t\tok=false\n+\tfi\n+}\n+\n+# Test local imports\n+testlocal local ''\n+\n+# Test local imports again, with bad characters in the directory name.\n+bad='#$%:, &()*;<=>?\\^{}'\n+rm -rf \"testdata/$bad\"\n+cp -R testdata/local \"testdata/$bad\"\n+testlocal \"$bad\" 'with bad characters in path'\n+rm -rf \"testdata/$bad\"\n+\n+TEST error message for syntax error in test go file says FAIL\n+export GOPATH=$(pwd)/testdata\n+if ./testgo test syntaxerror 2>testdata/err; then\n+\techo 'go test syntaxerror succeeded'\n+\tok=false\n+elif ! grep FAIL testdata/err >/dev/null; then\n+\techo 'go test did not say FAIL:'\n+\tcat testdata/err\n+\tok=false\n+fi\n+rm -f ./testdata/err\n+unset GOPATH\n+\n+TEST wildcards do not look in useless directories\n+export GOPATH=$(pwd)/testdata\n+if ./testgo list ... >testdata/err 2>&1; then\n+\techo \"go list ... succeeded\"\n+\tok=false\n+elif ! grep badpkg testdata/err >/dev/null; then\n+\techo \"go list ... failure does not mention badpkg\"\n+\tcat testdata/err\n+\tok=false\n+elif ! ./testgo list m... >testdata/err 2>&1; then\n+\techo \"go list m... failed\"\n+\tok=false\n+fi\n+rm -rf ./testdata/err\n+unset GOPATH\n+\n+# Test tests with relative imports.\n+TEST relative imports '(go test)'\n+if ! ./testgo test ./testdata/testimport; then\n+\techo \"go test ./testdata/testimport failed\"\n+\tok=false\n+fi\n+\n+# Test installation with relative imports.\n+TEST relative imports '(go test -i)'\n+if ! ./testgo test -i ./testdata/testimport; then\n+    echo \"go test -i ./testdata/testimport failed\"\n+    ok=false\n+fi\n+\n+# Test tests with relative imports in packages synthesized\n+# from Go files named on the command line.\n+TEST relative imports in command-line package\n+if ! ./testgo test ./testdata/testimport/*.go; then\n+\techo \"go test ./testdata/testimport/*.go failed\"\n+\tok=false\n+fi\n+\n+TEST version control error message includes correct directory\n+export GOPATH=$(pwd)/testdata/shadow/root1\n+if ./testgo get -u foo 2>testdata/err; then\n+\techo \"go get -u foo succeeded unexpectedly\"\n+\tok=false\n+elif ! grep testdata/shadow/root1/src/foo testdata/err >/dev/null; then\n+\techo \"go get -u error does not mention shadow/root1/src/foo:\"\n+\tcat testdata/err\n+\tok=false\n+fi\n+unset GOPATH\n+\n+TEST go install fails with no buildable files\n+export GOPATH=$(pwd)/testdata\n+export CGO_ENABLED=0\n+if ./testgo install cgotest 2>testdata/err; then\n+\techo \"go install cgotest succeeded unexpectedly\"\n+elif ! grep 'no buildable Go source files' testdata/err >/dev/null; then\n+\techo \"go install cgotest did not report 'no buildable Go source files'\"\n+\tcat testdata/err\n+\tok=false\n+fi\n+unset CGO_ENABLED\n+unset GOPATH\n+\n+# Test that without $GOBIN set, binaries get installed\n+# into the GOPATH bin directory.\n+TEST install into GOPATH\n+rm -rf testdata/bin\n+if ! GOPATH=$(pwd)/testdata ./testgo install go-cmd-test; then\n+\techo \"go install go-cmd-test failed\"\n+\tok=false\n+elif ! test -x testdata/bin/go-cmd-test; then\n+\techo \"go install go-cmd-test did not write to testdata/bin/go-cmd-test\"\n+\tok=false\n+fi\n+\n+TEST package main_test imports archive not binary\n+export GOBIN=$(pwd)/testdata/bin\n+mkdir -p $GOBIN\n+export GOPATH=$(pwd)/testdata\n+touch ./testdata/src/main_test/m.go\n+if ! ./testgo test main_test; then\n+\techo \"go test main_test failed without install\"\n+\tok=false\n+elif ! ./testgo install main_test; then\n+\techo \"go test main_test failed\"\n+\tok=false\n+elif [ \"$(./testgo list -f '{{.Stale}}' main_test)\" != false ]; then\n+\techo \"after go install, main listed as stale\"\n+\tok=false\n+elif ! ./testgo test main_test; then\n+\techo \"go test main_test failed after install\"\n+\tok=false\n+fi\n+rm -rf $GOBIN\n+unset GOBIN\n+\n+# And with $GOBIN set, binaries get installed to $GOBIN.\n+TEST install into GOBIN\n+if ! GOBIN=$(pwd)/testdata/bin1 GOPATH=$(pwd)/testdata ./testgo install go-cmd-test; then\n+\techo \"go install go-cmd-test failed\"\n+\tok=false\n+elif ! test -x testdata/bin1/go-cmd-test; then\n+\techo \"go install go-cmd-test did not write to testdata/bin1/go-cmd-test\"\n+\tok=false\n+fi\n+\n+# Without $GOBIN set, installing a program outside $GOPATH should fail\n+# (there is nowhere to install it).\n+TEST install without destination fails\n+if ./testgo install testdata/src/go-cmd-test/helloworld.go 2>testdata/err; then\n+\techo \"go install testdata/src/go-cmd-test/helloworld.go should have failed, did not\"\n+\tok=false\n+elif ! grep 'no install location for .go files listed on command line' testdata/err; then\n+\techo \"wrong error:\"\n+\tcat testdata/err\n+\tok=false\n+fi\n+rm -f testdata/err\n+\n+# With $GOBIN set, should install there.\n+TEST install to GOBIN '(command-line package)'\n+if ! GOBIN=$(pwd)/testdata/bin1 ./testgo install testdata/src/go-cmd-test/helloworld.go; then\n+\techo \"go install testdata/src/go-cmd-test/helloworld.go failed\"\n+\tok=false\n+elif ! test -x testdata/bin1/helloworld; then\n+\techo \"go install testdata/src/go-cmd-test/helloworld.go did not write testdata/bin1/helloworld\"\n+\tok=false\n+fi\n+\n+TEST godoc installs into GOBIN\n+d=$(mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir $d/gobin\n+GOBIN=$d/gobin ./testgo get code.google.com/p/go.tools/cmd/godoc\n+if [ ! -x $d/gobin/godoc ]; then\n+\techo did not install godoc to '$GOBIN'\n+\tGOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' code.google.com/p/go.tools/cmd/godoc\n+\tok=false\n+fi\n+\n+TEST godoc installs into GOROOT\n+GOROOT=$(./testgo env GOROOT)\n+rm -f $GOROOT/bin/godoc\n+./testgo install code.google.com/p/go.tools/cmd/godoc\n+if [ ! -x $GOROOT/bin/godoc ]; then\n+\techo did not install godoc to '$GOROOT/bin'\n+\t./testgo list -f 'Target: {{.Target}}' code.google.com/p/go.tools/cmd/godoc\n+\tok=false\n+fi\n+\n+TEST cmd/fix installs into tool\n+GOOS=$(./testgo env GOOS)\n+GOARCH=$(./testgo env GOARCH)\n+rm -f $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix\n+./testgo install cmd/fix\n+if [ ! -x $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix ]; then\n+\techo 'did not install cmd/fix to $GOROOT/pkg/tool'\n+\tGOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' cmd/fix\n+\tok=false\n+fi\n+rm -f $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix\n+GOBIN=$d/gobin ./testgo install cmd/fix\n+if [ ! -x $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix ]; then\n+\techo 'did not install cmd/fix to $GOROOT/pkg/tool with $GOBIN set'\n+\tGOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' cmd/fix\n+\tok=false\n+fi\n+\n+TEST gopath program installs into GOBIN\n+mkdir $d/src/progname\n+echo 'package main; func main() {}' >$d/src/progname/p.go\n+GOBIN=$d/gobin ./testgo install progname\n+if [ ! -x $d/gobin/progname ]; then\n+\techo 'did not install progname to $GOBIN/progname'\n+\t./testgo list -f 'Target: {{.Target}}' cmd/api\n+\tok=false\n+fi\n+rm -f $d/gobin/progname $d/bin/progname\n+\n+TEST gopath program installs into GOPATH/bin\n+./testgo install progname\n+if [ ! -x $d/bin/progname ]; then\n+\techo 'did not install progname to $GOPATH/bin/progname'\n+\t./testgo list -f 'Target: {{.Target}}' progname\n+\tok=false\n+fi\n+\n+unset GOPATH\n+rm -rf $d\n+\n+# Reject relative paths in GOPATH.\n+TEST reject relative paths in GOPATH '(command-line package)'\n+if GOPATH=. ./testgo build testdata/src/go-cmd-test/helloworld.go; then\n+    echo 'GOPATH=\".\" go build should have failed, did not'\n+    ok=false\n+fi\n+\n+TEST reject relative paths in GOPATH \n+if GOPATH=:$(pwd)/testdata:. ./testgo build go-cmd-test; then\n+    echo 'GOPATH=\":$(pwd)/testdata:.\" go build should have failed, did not'\n+    ok=false\n+fi\n+\n+# issue 4104\n+TEST go test with package listed multiple times\n+if [ $(./testgo test fmt fmt fmt fmt fmt | wc -l) -ne 1 ] ; then\n+    echo 'go test fmt fmt fmt fmt fmt tested the same package multiple times'\n+    ok=false\n+fi\n+\n+# ensure that output of 'go list' is consistent between runs\n+TEST go list is consistent\n+./testgo list std > test_std.list\n+if ! ./testgo list std | cmp -s test_std.list - ; then\n+\techo \"go list std ordering is inconsistent\"\n+\tok=false\n+fi\n+rm -f test_std.list\n+\n+# issue 4096. Validate the output of unsuccessful go install foo/quxx \n+TEST unsuccessful go install should mention missing package\n+if [ $(./testgo install 'foo/quxx' 2>&1 | grep -c 'cannot find package \"foo/quxx\" in any of') -ne 1 ] ; then\n+\techo 'go install foo/quxx expected error: .*cannot find package \"foo/quxx\" in any of'\n+\tok=false\n+fi \n+# test GOROOT search failure is reported\n+TEST GOROOT search failure reporting\n+if [ $(./testgo install 'foo/quxx' 2>&1 | egrep -c 'foo/quxx \\(from \\$GOROOT\\)$') -ne 1 ] ; then\n+        echo 'go install foo/quxx expected error: .*foo/quxx (from $GOROOT)'\n+        ok=false\n+fi\n+# test multiple GOPATH entries are reported separately\n+TEST multiple GOPATH entries reported separately\n+if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/./src/foo/quxx') -ne 2 ] ; then\n+        echo 'go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)\\n.*testdata/b/src/foo/quxx'\n+        ok=false\n+fi\n+# test (from $GOPATH) annotation is reported for the first GOPATH entry\n+TEST mention GOPATH in first GOPATH entry\n+if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/a/src/foo/quxx \\(from \\$GOPATH\\)$') -ne 1 ] ; then\n+        echo 'go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)'\n+        ok=false\n+fi\n+# but not on the second\n+TEST but not the second entry\n+if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/b/src/foo/quxx$') -ne 1 ] ; then\n+        echo 'go install foo/quxx expected error: .*testdata/b/src/foo/quxx'\n+        ok=false\n+fi\n+# test missing GOPATH is reported\n+TEST missing GOPATH is reported\n+if [ $(GOPATH= ./testgo install 'foo/quxx' 2>&1 | egrep -c '\\(\\$GOPATH not set\\)$') -ne 1 ] ; then\n+        echo 'go install foo/quxx expected error: ($GOPATH not set)'\n+        ok=false\n+fi\n+\n+# issue 4186. go get cannot be used to download packages to $GOROOT\n+# Test that without GOPATH set, go get should fail\n+TEST without GOPATH, go get fails\n+d=$(mktemp -d -t testgoXXX)\n+mkdir -p $d/src/pkg\n+if GOPATH= GOROOT=$d ./testgo get -d code.google.com/p/go.codereview/cmd/hgpatch ; then \n+\techo 'go get code.google.com/p/go.codereview/cmd/hgpatch should not succeed with $GOPATH unset'\n+\tok=false\n+fi\t\n+rm -rf $d\n+\n+# Test that with GOPATH=$GOROOT, go get should fail\n+TEST with GOPATH=GOROOT, go get fails\n+d=$(mktemp -d -t testgoXXX)\n+mkdir -p $d/src/pkg\n+if GOPATH=$d GOROOT=$d ./testgo get -d code.google.com/p/go.codereview/cmd/hgpatch ; then\n+        echo 'go get code.google.com/p/go.codereview/cmd/hgpatch should not succeed with GOPATH=$GOROOT'\n+        ok=false\n+fi\n+rm -rf $d\n+\n+TEST ldflags arguments with spaces '(issue 3941)'\n+d=$(mktemp -d -t testgoXXX)\n+cat >$d/main.go<<EOF\n+package main\n+var extern string\n+func main() {\n+\tprintln(extern)\n+}\n+EOF\n+./testgo run -ldflags '-X main.extern \"hello world\"' $d/main.go 2>hello.out\n+if ! grep -q '^hello world' hello.out; then\n+\techo \"ldflags -X main.extern 'hello world' failed. Output:\"\n+\tcat hello.out\n+\tok=false\n+fi\n+rm -rf $d hello.out\n+\n+TEST go test -cpuprofile leaves binary behind\n+./testgo test -cpuprofile strings.prof strings || ok=false\n+if [ ! -x strings.test ]; then\n+\techo \"go test -cpuprofile did not create strings.test\"\n+\tok=false\n+fi\n+rm -f strings.prof strings.test\n+\n+TEST symlinks do not confuse go list '(issue 4568)'\n+old=$(pwd)\n+tmp=$(cd /tmp && pwd -P)\n+d=$(TMPDIR=$tmp mktemp -d -t testgoXXX)\n+mkdir -p $d/src\n+(\n+\tln -s $d $d/src/dir1\n+\tcd $d/src\n+\techo package p >dir1/p.go\n+\texport GOPATH=$d\n+\tif [ \"$($old/testgo list -f '{{.Root}}' dir1)\" != \"$d\" ]; then\n+\t\techo Confused by symlinks.\n+\t\techo \"Package in current directory $(pwd) should have Root $d\"\n+\t\tenv|grep WD\n+\t\t$old/testgo list -json . dir1\n+\t\ttouch $d/failed\n+\tfi\t\t\n+)\n+if [ -f $d/failed ]; then\n+\tok=false\n+fi\n+rm -rf $d\n+\n+TEST 'install with tags (issue 4515)'\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+mkdir -p $d/src/example/a $d/src/example/b $d/bin\n+cat >$d/src/example/a/main.go <<EOF\n+package main\n+func main() {}\n+EOF\n+cat >$d/src/example/b/main.go <<EOF\n+// +build mytag\n+\n+package main\n+func main() {}\n+EOF\n+GOPATH=$d ./testgo install -tags mytag example/a example/b || ok=false\n+if [ ! -x $d/bin/a -o ! -x $d/bin/b ]; then\n+\techo go install example/a example/b did not install binaries\n+\tok=false\n+fi\n+rm -f $d/bin/*\n+GOPATH=$d ./testgo install -tags mytag example/... || ok=false\n+if [ ! -x $d/bin/a -o ! -x $d/bin/b ]; then\n+\techo go install example/... did not install binaries\n+\tok=false\n+fi\n+rm -f $d/bin/*go\n+export GOPATH=$d\n+if [ \"$(./testgo list -tags mytag example/b...)\" != \"example/b\" ]; then\n+\techo go list example/b did not find example/b\n+\tok=false\n+fi\n+unset GOPATH\n+rm -rf $d\n+\n+TEST case collisions '(issue 4773)'\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir -p $d/src/example/{a/pkg,a/Pkg,b}\n+cat >$d/src/example/a/a.go <<EOF\n+package p\n+import (\n+\t_ \"example/a/pkg\"\n+\t_ \"example/a/Pkg\"\n+)\n+EOF\n+cat >$d/src/example/a/pkg/pkg.go <<EOF\n+package pkg\n+EOF\n+cat >$d/src/example/a/Pkg/pkg.go <<EOF\n+package pkg\n+EOF\n+if ./testgo list example/a 2>$d/out; then\n+\techo go list example/a should have failed, did not.\n+\tok=false\n+elif ! grep \"case-insensitive import collision\" $d/out >/dev/null; then\n+\techo go list example/a did not report import collision.\n+\tok=false\n+fi\n+cat >$d/src/example/b/file.go <<EOF\n+package b\n+EOF\n+cat >$d/src/example/b/FILE.go <<EOF\n+package b\n+EOF\n+if [ $(ls $d/src/example/b | wc -l) = 2 ]; then\n+\t# case-sensitive file system, let directory read find both files\n+\targs=\"example/b\"\n+else\n+\t# case-insensitive file system, list files explicitly on command line.\n+\targs=\"$d/src/example/b/file.go $d/src/example/b/FILE.go\"\n+fi\n+if ./testgo list $args 2>$d/out; then\n+\techo go list example/b should have failed, did not.\n+\tok=false\n+elif ! grep \"case-insensitive file name collision\" $d/out >/dev/null; then\n+\techo go list example/b did not report file name collision.\n+\tok=false\n+fi\n+\n+TEST go get cover\n+./testgo get code.google.com/p/go.tools/cmd/cover || ok=false\n+\n+unset GOPATH\n+rm -rf $d\n+\n+TEST shadowing logic\n+export GOPATH=$(pwd)/testdata/shadow/root1:$(pwd)/testdata/shadow/root2\n+\n+# The math in root1 is not \"math\" because the standard math is.\n+cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root1/src/math)\n+if [ \"$cdir\" != \"(_$(pwd)/testdata/shadow/root1/src/math) ($GOROOT/src/pkg/math)\" ]; then\n+\techo shadowed math is not shadowed: \"$cdir\"\n+\tok=false\n+fi\n+\n+# The foo in root1 is \"foo\".\n+cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root1/src/foo)\n+if [ \"$cdir\" != \"(foo) ()\" ]; then\n+\techo unshadowed foo is shadowed: \"$cdir\"\n+\tok=false\n+fi\n+\n+# The foo in root2 is not \"foo\" because the foo in root1 got there first.\n+cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root2/src/foo)\n+if [ \"$cdir\" != \"(_$(pwd)/testdata/shadow/root2/src/foo) ($(pwd)/testdata/shadow/root1/src/foo)\" ]; then\n+\techo shadowed foo is not shadowed: \"$cdir\"\n+\tok=false\n+fi\n+\n+# The error for go install should mention the conflicting directory.\n+err=$(! ./testgo install ./testdata/shadow/root2/src/foo 2>&1)\n+if [ \"$err\" != \"go install: no install location for $(pwd)/testdata/shadow/root2/src/foo: hidden by $(pwd)/testdata/shadow/root1/src/foo\" ]; then\n+\techo wrong shadowed install error: \"$err\"\n+\tok=false\n+fi\n+\n+# Only succeeds if source order is preserved.\n+TEST source file name order preserved\n+./testgo test testdata/example[12]_test.go || ok=false\n+\n+# Check that coverage analysis works at all.\n+# Don't worry about the exact numbers but require not 0.0%.\n+checkcoverage() {\n+\tif grep '[^0-9]0\\.0%' testdata/cover.txt >/dev/null; then\n+\t\techo 'some coverage results are 0.0%'\n+\t\tok=false\n+\tfi\n+\tcat testdata/cover.txt\n+\trm -f testdata/cover.txt\n+}\n+\t\n+TEST coverage runs\n+./testgo test -short -coverpkg=strings strings regexp >testdata/cover.txt 2>&1 || ok=false\n+./testgo test -short -cover strings math regexp >>testdata/cover.txt 2>&1 || ok=false\n+checkcoverage\n+\n+# Check that coverage analysis uses set mode.\n+TEST coverage uses set mode\n+if ./testgo test -short -cover encoding/binary -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then\n+\tif ! grep -q 'mode: set' testdata/cover.out; then\n+\t\tok=false\n+\tfi\n+\tcheckcoverage\n+else\n+\tok=false\n+fi\n+rm -f testdata/cover.out testdata/cover.txt\n+\n+TEST coverage uses atomic mode for -race.\n+if ./testgo test -short -race -cover encoding/binary -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then\n+\tif ! grep -q 'mode: atomic' testdata/cover.out; then\n+\t\tok=false\n+\tfi\n+\tcheckcoverage\n+else\n+\tok=false\n+fi\n+rm -f testdata/cover.out\n+\n+TEST coverage uses actual setting to override even for -race.\n+if ./testgo test -short -race -cover encoding/binary -covermode=count -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then\n+\tif ! grep -q 'mode: count' testdata/cover.out; then\n+\t\tok=false\n+\tfi\n+\tcheckcoverage\n+else\n+\tok=false\n+fi\n+rm -f testdata/cover.out\n+\n+TEST coverage with cgo\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+./testgo test -short -cover ./testdata/cgocover >testdata/cover.txt 2>&1 || ok=false\n+checkcoverage\n+\n+TEST cgo depends on syscall\n+rm -rf $GOROOT/pkg/*_race\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir -p $d/src/foo\n+echo '\n+package foo\n+//#include <stdio.h>\n+import \"C\"\n+' >$d/src/foo/foo.go\n+./testgo build -race foo || ok=false\n+rm -rf $d\n+unset GOPATH\n+\n+TEST cgo shows full path names\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir -p $d/src/x/y/dirname\n+echo '\n+package foo\n+import \"C\"\n+func f() {\n+' >$d/src/x/y/dirname/foo.go\n+if ./testgo build x/y/dirname >$d/err 2>&1; then\n+\techo build succeeded unexpectedly.\n+\tok=false\n+elif ! grep x/y/dirname $d/err >/dev/null; then\n+\techo error did not use full path.\n+\tcat $d/err\n+\tok=false\n+fi\n+rm -rf $d\n+unset GOPATH\n+\n+TEST 'cgo handles -Wl,$ORIGIN'\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir -p $d/src/origin\n+echo '\n+package origin\n+// #cgo !darwin LDFLAGS: -Wl,-rpath -Wl,$ORIGIN\n+// void f(void) {}\n+import \"C\"\n+\n+func f() { C.f() }\n+' >$d/src/origin/origin.go\n+if ! ./testgo build origin; then\n+\techo build failed\n+\tok=false\n+fi\n+rm -rf $d\n+unset GOPATH\n+\n+TEST 'Issue 6480: \"go test -c -test.bench=XXX fmt\" should not hang'\n+if ! ./testgo test -c -test.bench=XXX fmt; then\n+\techo build test failed\n+\tok=false\n+fi\n+rm -f fmt.test\n+\n+TEST 'Issue 7573: cmd/cgo: undefined reference when linking a C-library using gccgo'\n+d=$(mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir -p $d/src/cgoref\n+ldflags=\"-L alibpath -lalib\"\n+echo \"\n+package main\n+// #cgo LDFLAGS: $ldflags\n+// void f(void) {}\n+import \\\"C\\\"\n+\n+func main() { C.f() }\n+\" >$d/src/cgoref/cgoref.go\n+go_cmds=\"$(./testgo build -n -compiler gccgo cgoref 2>&1 1>/dev/null)\"\n+ldflags_count=\"$(echo \"$go_cmds\" | egrep -c \"^gccgo.*$(echo $ldflags | sed -e 's/-/\\\\-/g')\" || true)\"\n+if [ \"$ldflags_count\" -lt 1 ]; then\n+\techo \"No Go-inline \"#cgo LDFLAGS:\" (\\\"$ldflags\\\") passed to gccgo linking stage.\"\n+\tok=false\n+fi\n+rm -rf $d\n+unset ldflags_count\n+unset go_cmds\n+unset ldflags\n+unset GOPATH\n+\n+TEST list template can use context function\n+if ! ./testgo list -f \"GOARCH: {{context.GOARCH}}\"; then \n+\techo unable to use context in list template\n+\tok=false\n+fi\n+\n+TEST 'Issue 7108: cmd/go: \"go test\" should fail if package does not build'\n+export GOPATH=$(pwd)/testdata\n+if ./testgo test notest >/dev/null 2>&1; then\n+\techo 'go test notest succeeded, but should fail'\n+\tok=false\n+fi\n+unset GOPATH\n+\n+TEST 'Issue 6844: cmd/go: go test -a foo does not rebuild regexp'\n+if ! ./testgo test -x -a -c testdata/dep_test.go 2>deplist; then\n+\techo \"go test -x -a -c testdata/dep_test.go failed\"\n+\tok=false\n+elif ! grep -q regexp deplist; then\n+\techo \"go test -x -a -c testdata/dep_test.go did not rebuild regexp\"\n+\tok=false\n+fi\n+rm -f deplist\n+rm -f deps.test\n+\n+TEST list template can use context function\n+if ! ./testgo list -f \"GOARCH: {{context.GOARCH}}\"; then \n+\techo unable to use context in list template\n+\tok=false\n+fi\n+\n+TEST build -i installs dependencies\n+d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n+export GOPATH=$d\n+mkdir -p $d/src/x/y/foo $d/src/x/y/bar\n+echo '\n+package foo\n+func F() {}\n+' >$d/src/x/y/foo/foo.go\n+echo '\n+package bar\n+import \"x/y/foo\"\n+func F() { foo.F() }\n+' >$d/src/x/y/bar/bar.go\n+if ! ./testgo build -v -i x/y/bar &> $d/err; then\n+\techo build -i failed\n+\tcat $d/err\n+\tok=false\n+elif ! grep x/y/foo $d/err >/dev/null; then\n+\techo first build -i did not build x/y/foo\n+\tcat $d/err\n+\tok=false\n+fi\n+if ! ./testgo build -v -i x/y/bar &> $d/err; then\n+\techo second build -i failed\n+\tcat $d/err\n+\tok=false\n+elif grep x/y/foo $d/err >/dev/null; then\n+\techo second build -i built x/y/foo\n+\tcat $d/err\n+\tok=false\n+fi\n+rm -rf $d\n+unset GOPATH\n+\n+TEST 'go build in test-only directory fails with a good error'\n+if ./testgo build ./testdata/testonly 2>testdata/err.out; then\n+\techo \"go build ./testdata/testonly succeeded, should have failed\"\n+\tok=false\n+elif ! grep 'no buildable Go' testdata/err.out >/dev/null; then\n+\techo \"go build ./testdata/testonly produced unexpected error:\"\n+\tcat testdata/err.out\n+\tok=false\n+fi\n+rm -f testdata/err.out\n+\n+TEST 'go test detects test-only import cycles'\n+export GOPATH=$(pwd)/testdata\n+if ./testgo test -c testcycle/p3 2>testdata/err.out; then\n+\techo \"go test testcycle/p3 succeeded, should have failed\"\n+\tok=false\n+elif ! grep 'import cycle not allowed in test' testdata/err.out >/dev/null; then\n+\techo \"go test testcycle/p3 produced unexpected error:\"\n+\tcat testdata/err.out\n+\tok=false\n+fi\n+rm -f testdata/err.out\n+unset GOPATH\n+\n+TEST 'go test foo_test.go works'\n+if ! ./testgo test testdata/standalone_test.go; then\n+\techo \"go test testdata/standalone_test.go failed\"\n+\tok=false\n+fi\n+\n+TEST 'go test xtestonly works'\n+export GOPATH=$(pwd)/testdata\n+./testgo clean -i xtestonly\n+if ! ./testgo test xtestonly >/dev/null; then\n+\techo \"go test xtestonly failed\"\n+\tok=false\n+fi\n+unset GOPATH\n+\n+\n+# clean up\n+if $started; then stop; fi\n+rm -rf testdata/bin testdata/bin1\n+rm -f testgo\n+\n+if $allok; then\n+\techo PASS\n+else\n+\techo FAIL\n+\texit 1\n+fi"}, {"sha": "f7ae9c01fba50fdb4a659f7f6838d6ad2be91ff3", "filename": "libgo/go/cmd/go/test.go", "status": "added", "additions": 1308, "deletions": 0, "changes": 1308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,1308 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/build\"\n+\t\"go/doc\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"text/template\"\n+\t\"time\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+// Break init loop.\n+func init() {\n+\tcmdTest.Run = runTest\n+}\n+\n+var cmdTest = &Command{\n+\tCustomFlags: true,\n+\tUsageLine:   \"test [-c] [-i] [build and test flags] [packages] [flags for test binary]\",\n+\tShort:       \"test packages\",\n+\tLong: `\n+'Go test' automates testing the packages named by the import paths.\n+It prints a summary of the test results in the format:\n+\n+\tok   archive/tar   0.011s\n+\tFAIL archive/zip   0.022s\n+\tok   compress/gzip 0.033s\n+\t...\n+\n+followed by detailed output for each failed package.\n+\n+'Go test' recompiles each package along with any files with names matching\n+the file pattern \"*_test.go\". \n+Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n+These additional files can contain test functions, benchmark functions, and\n+example functions.  See 'go help testfunc' for more.\n+Each listed package causes the execution of a separate test binary.\n+\n+Test files that declare a package with the suffix \"_test\" will be compiled as a\n+separate package, and then linked and run with the main test binary.\n+\n+By default, go test needs no arguments.  It compiles and tests the package\n+with source in the current directory, including tests, and runs the tests.\n+\n+The package is built in a temporary directory so it does not interfere with the\n+non-test installation.\n+\n+In addition to the build flags, the flags handled by 'go test' itself are:\n+\n+\t-c  Compile the test binary to pkg.test but do not run it.\n+\t    (Where pkg is the last element of the package's import path.)\n+\n+\t-i\n+\t    Install packages that are dependencies of the test.\n+\t    Do not run the test.\n+\n+\t-exec xprog\n+\t    Run the test binary using xprog. The behavior is the same as\n+\t    in 'go run'. See 'go help run' for details.\n+\n+The test binary also accepts flags that control execution of the test; these\n+flags are also accessible by 'go test'.  See 'go help testflag' for details.\n+\n+If the test binary needs any other flags, they should be presented after the\n+package names. The go tool treats as a flag the first argument that begins with\n+a minus sign that it does not recognize itself; that argument and all subsequent\n+arguments are passed as arguments to the test binary.\n+\n+For more about build flags, see 'go help build'.\n+For more about specifying packages, see 'go help packages'.\n+\n+See also: go build, go vet.\n+`,\n+}\n+\n+var helpTestflag = &Command{\n+\tUsageLine: \"testflag\",\n+\tShort:     \"description of testing flags\",\n+\tLong: `\n+The 'go test' command takes both flags that apply to 'go test' itself\n+and flags that apply to the resulting test binary.\n+\n+Several of the flags control profiling and write an execution profile\n+suitable for \"go tool pprof\"; run \"go tool pprof help\" for more\n+information.  The --alloc_space, --alloc_objects, and --show_bytes\n+options of pprof control how the information is presented.\n+\n+The following flags are recognized by the 'go test' command and\n+control the execution of any test:\n+\n+\t-bench regexp\n+\t    Run benchmarks matching the regular expression.\n+\t    By default, no benchmarks run. To run all benchmarks,\n+\t    use '-bench .' or '-bench=.'.\n+\n+\t-benchmem\n+\t    Print memory allocation statistics for benchmarks.\n+\n+\t-benchtime t\n+\t    Run enough iterations of each benchmark to take t, specified\n+\t    as a time.Duration (for example, -benchtime 1h30s).\n+\t    The default is 1 second (1s).\n+\n+\t-blockprofile block.out\n+\t    Write a goroutine blocking profile to the specified file\n+\t    when all tests are complete.\n+\n+\t-blockprofilerate n\n+\t    Control the detail provided in goroutine blocking profiles by\n+\t    calling runtime.SetBlockProfileRate with n.\n+\t    See 'godoc runtime SetBlockProfileRate'.\n+\t    The profiler aims to sample, on average, one blocking event every\n+\t    n nanoseconds the program spends blocked.  By default,\n+\t    if -test.blockprofile is set without this flag, all blocking events\n+\t    are recorded, equivalent to -test.blockprofilerate=1.\n+\n+\t-cover\n+\t    Enable coverage analysis.\n+\n+\t-covermode set,count,atomic\n+\t    Set the mode for coverage analysis for the package[s]\n+\t    being tested. The default is \"set\" unless -race is enabled,\n+\t    in which case it is \"atomic\".\n+\t    The values:\n+\t\tset: bool: does this statement run?\n+\t\tcount: int: how many times does this statement run?\n+\t\tatomic: int: count, but correct in multithreaded tests;\n+\t\t\tsignificantly more expensive.\n+\t    Sets -cover.\n+\n+\t-coverpkg pkg1,pkg2,pkg3\n+\t    Apply coverage analysis in each test to the given list of packages.\n+\t    The default is for each test to analyze only the package being tested.\n+\t    Packages are specified as import paths.\n+\t    Sets -cover.\n+\n+\t-coverprofile cover.out\n+\t    Write a coverage profile to the specified file after all tests\n+\t    have passed.\n+\t    Sets -cover.\n+\n+\t-cpu 1,2,4\n+\t    Specify a list of GOMAXPROCS values for which the tests or\n+\t    benchmarks should be executed.  The default is the current value\n+\t    of GOMAXPROCS.\n+\n+\t-cpuprofile cpu.out\n+\t    Write a CPU profile to the specified file before exiting.\n+\n+\t-memprofile mem.out\n+\t    Write a memory profile to the specified file after all tests\n+\t    have passed.\n+\n+\t-memprofilerate n\n+\t    Enable more precise (and expensive) memory profiles by setting\n+\t    runtime.MemProfileRate.  See 'godoc runtime MemProfileRate'.\n+\t    To profile all memory allocations, use -test.memprofilerate=1\n+\t    and pass --alloc_space flag to the pprof tool.\n+\n+\t-outputdir directory\n+\t    Place output files from profiling in the specified directory,\n+\t    by default the directory in which \"go test\" is running.\n+\n+\t-parallel n\n+\t    Allow parallel execution of test functions that call t.Parallel.\n+\t    The value of this flag is the maximum number of tests to run\n+\t    simultaneously; by default, it is set to the value of GOMAXPROCS.\n+\n+\t-run regexp\n+\t    Run only those tests and examples matching the regular\n+\t    expression.\n+\n+\t-short\n+\t    Tell long-running tests to shorten their run time.\n+\t    It is off by default but set during all.bash so that installing\n+\t    the Go tree can run a sanity check but not spend time running\n+\t    exhaustive tests.\n+\n+\t-timeout t\n+\t    If a test runs longer than t, panic.\n+\n+\t-v\n+\t    Verbose output: log all tests as they are run. Also print all\n+\t    text from Log and Logf calls even if the test succeeds.\n+\n+The test binary, called pkg.test where pkg is the name of the\n+directory containing the package sources, can be invoked directly\n+after building it with 'go test -c'. When invoking the test binary\n+directly, each of the standard flag names must be prefixed with 'test.',\n+as in -test.run=TestMyFunc or -test.v.\n+\n+When running 'go test', flags not listed above are passed through\n+unaltered. For instance, the command\n+\n+\tgo test -x -v -cpuprofile=prof.out -dir=testdata -update\n+\n+will compile the test binary and then run it as\n+\n+\tpkg.test -test.v -test.cpuprofile=prof.out -dir=testdata -update\n+\n+The test flags that generate profiles (other than for coverage) also\n+leave the test binary in pkg.test for use when analyzing the profiles.\n+\n+Flags not recognized by 'go test' must be placed after any specified packages.\n+`,\n+}\n+\n+var helpTestfunc = &Command{\n+\tUsageLine: \"testfunc\",\n+\tShort:     \"description of testing functions\",\n+\tLong: `\n+The 'go test' command expects to find test, benchmark, and example functions\n+in the \"*_test.go\" files corresponding to the package under test.\n+\n+A test function is one named TestXXX (where XXX is any alphanumeric string\n+not starting with a lower case letter) and should have the signature,\n+\n+\tfunc TestXXX(t *testing.T) { ... }\n+\n+A benchmark function is one named BenchmarkXXX and should have the signature,\n+\n+\tfunc BenchmarkXXX(b *testing.B) { ... }\n+\n+An example function is similar to a test function but, instead of using\n+*testing.T to report success or failure, prints output to os.Stdout.\n+That output is compared against the function's \"Output:\" comment, which\n+must be the last comment in the function body (see example below). An\n+example with no such comment, or with no text after \"Output:\" is compiled\n+but not executed.\n+\n+Godoc displays the body of ExampleXXX to demonstrate the use\n+of the function, constant, or variable XXX.  An example of a method M with\n+receiver type T or *T is named ExampleT_M.  There may be multiple examples\n+for a given function, constant, or variable, distinguished by a trailing _xxx,\n+where xxx is a suffix not beginning with an upper case letter.\n+\n+Here is an example of an example:\n+\n+\tfunc ExamplePrintln() {\n+\t\tPrintln(\"The output of\\nthis example.\")\n+\t\t// Output: The output of\n+\t\t// this example.\n+\t}\n+\n+The entire test file is presented as the example when it contains a single\n+example function, at least one other function, type, variable, or constant\n+declaration, and no test or benchmark functions.\n+\n+See the documentation of the testing package for more information.\n+`,\n+}\n+\n+var (\n+\ttestC            bool       // -c flag\n+\ttestCover        bool       // -cover flag\n+\ttestCoverMode    string     // -covermode flag\n+\ttestCoverPaths   []string   // -coverpkg flag\n+\ttestCoverPkgs    []*Package // -coverpkg flag\n+\ttestProfile      bool       // some profiling flag\n+\ttestNeedBinary   bool       // profile needs to keep binary around\n+\ttestV            bool       // -v flag\n+\ttestFiles        []string   // -file flag(s)  TODO: not respected\n+\ttestTimeout      string     // -timeout flag\n+\ttestArgs         []string\n+\ttestBench        bool\n+\ttestStreamOutput bool // show output as it is generated\n+\ttestShowPass     bool // show passing output\n+\n+\ttestKillTimeout = 10 * time.Minute\n+)\n+\n+var testMainDeps = map[string]bool{\n+\t// Dependencies for testmain.\n+\t\"testing\": true,\n+\t\"regexp\":  true,\n+}\n+\n+func runTest(cmd *Command, args []string) {\n+\tvar pkgArgs []string\n+\tpkgArgs, testArgs = testFlags(args)\n+\n+\tfindExecCmd() // initialize cached result\n+\n+\traceInit()\n+\tpkgs := packagesForBuild(pkgArgs)\n+\tif len(pkgs) == 0 {\n+\t\tfatalf(\"no packages to test\")\n+\t}\n+\n+\tif testC && len(pkgs) != 1 {\n+\t\tfatalf(\"cannot use -c flag with multiple packages\")\n+\t}\n+\tif testProfile && len(pkgs) != 1 {\n+\t\tfatalf(\"cannot use test profile flag with multiple packages\")\n+\t}\n+\n+\t// If a test timeout was given and is parseable, set our kill timeout\n+\t// to that timeout plus one minute.  This is a backup alarm in case\n+\t// the test wedges with a goroutine spinning and its background\n+\t// timer does not get a chance to fire.\n+\tif dt, err := time.ParseDuration(testTimeout); err == nil && dt > 0 {\n+\t\ttestKillTimeout = dt + 1*time.Minute\n+\t}\n+\n+\t// show passing test output (after buffering) with -v flag.\n+\t// must buffer because tests are running in parallel, and\n+\t// otherwise the output will get mixed.\n+\ttestShowPass = testV\n+\n+\t// stream test output (no buffering) when no package has\n+\t// been given on the command line (implicit current directory)\n+\t// or when benchmarking.\n+\t// Also stream if we're showing output anyway with a\n+\t// single package under test.  In that case, streaming the\n+\t// output produces the same result as not streaming,\n+\t// just more immediately.\n+\ttestStreamOutput = len(pkgArgs) == 0 || testBench ||\n+\t\t(len(pkgs) <= 1 && testShowPass)\n+\n+\tvar b builder\n+\tb.init()\n+\n+\tif buildI {\n+\t\tbuildV = testV\n+\n+\t\tdeps := make(map[string]bool)\n+\t\tfor dep := range testMainDeps {\n+\t\t\tdeps[dep] = true\n+\t\t}\n+\n+\t\tfor _, p := range pkgs {\n+\t\t\t// Dependencies for each test.\n+\t\t\tfor _, path := range p.Imports {\n+\t\t\t\tdeps[path] = true\n+\t\t\t}\n+\t\t\tfor _, path := range p.TestImports {\n+\t\t\t\tdeps[path] = true\n+\t\t\t}\n+\t\t\tfor _, path := range p.XTestImports {\n+\t\t\t\tdeps[path] = true\n+\t\t\t}\n+\t\t}\n+\n+\t\t// translate C to runtime/cgo\n+\t\tif deps[\"C\"] {\n+\t\t\tdelete(deps, \"C\")\n+\t\t\tdeps[\"runtime/cgo\"] = true\n+\t\t\tif buildContext.GOOS == runtime.GOOS && buildContext.GOARCH == runtime.GOARCH {\n+\t\t\t\tdeps[\"cmd/cgo\"] = true\n+\t\t\t}\n+\t\t}\n+\t\t// Ignore pseudo-packages.\n+\t\tdelete(deps, \"unsafe\")\n+\n+\t\tall := []string{}\n+\t\tif reqPkgSrc {\n+\t\t\tfor path := range deps {\n+\t\t\t\tif !build.IsLocalImport(path) {\n+\t\t\t\t\tall = append(all, path)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tsort.Strings(all)\n+\n+\t\ta := &action{}\n+\t\tfor _, p := range packagesForBuild(all) {\n+\t\t\ta.deps = append(a.deps, b.action(modeInstall, modeInstall, p))\n+\t\t}\n+\t\tb.do(a)\n+\t\tif !testC || a.failed {\n+\t\t\treturn\n+\t\t}\n+\t\tb.init()\n+\t}\n+\n+\tvar builds, runs, prints []*action\n+\n+\tif testCoverPaths != nil {\n+\t\t// Load packages that were asked about for coverage.\n+\t\t// packagesForBuild exits if the packages cannot be loaded.\n+\t\ttestCoverPkgs = packagesForBuild(testCoverPaths)\n+\n+\t\t// Warn about -coverpkg arguments that are not actually used.\n+\t\tused := make(map[string]bool)\n+\t\tfor _, p := range pkgs {\n+\t\t\tused[p.ImportPath] = true\n+\t\t\tfor _, dep := range p.Deps {\n+\t\t\t\tused[dep] = true\n+\t\t\t}\n+\t\t}\n+\t\tfor _, p := range testCoverPkgs {\n+\t\t\tif !used[p.ImportPath] {\n+\t\t\t\tlog.Printf(\"warning: no packages being tested depend on %s\", p.ImportPath)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Mark all the coverage packages for rebuilding with coverage.\n+\t\tfor _, p := range testCoverPkgs {\n+\t\t\tp.Stale = true // rebuild\n+\t\t\tp.fake = true  // do not warn about rebuild\n+\t\t\tp.coverMode = testCoverMode\n+\t\t\tvar coverFiles []string\n+\t\t\tcoverFiles = append(coverFiles, p.GoFiles...)\n+\t\t\tcoverFiles = append(coverFiles, p.CgoFiles...)\n+\t\t\tcoverFiles = append(coverFiles, p.TestGoFiles...)\n+\t\t\tp.coverVars = declareCoverVars(p.ImportPath, coverFiles...)\n+\t\t}\n+\t}\n+\n+\t// Prepare build + run + print actions for all packages being tested.\n+\tfor _, p := range pkgs {\n+\t\tbuildTest, runTest, printTest, err := b.test(p)\n+\t\tif err != nil {\n+\t\t\tstr := err.Error()\n+\t\t\tif strings.HasPrefix(str, \"\\n\") {\n+\t\t\t\tstr = str[1:]\n+\t\t\t}\n+\t\t\tfailed := fmt.Sprintf(\"FAIL\\t%s [setup failed]\\n\", p.ImportPath)\n+\n+\t\t\tif p.ImportPath != \"\" {\n+\t\t\t\terrorf(\"# %s\\n%s\\n%s\", p.ImportPath, str, failed)\n+\t\t\t} else {\n+\t\t\t\terrorf(\"%s\\n%s\", str, failed)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tbuilds = append(builds, buildTest)\n+\t\truns = append(runs, runTest)\n+\t\tprints = append(prints, printTest)\n+\t}\n+\n+\t// Ultimately the goal is to print the output.\n+\troot := &action{deps: prints}\n+\n+\t// Force the printing of results to happen in order,\n+\t// one at a time.\n+\tfor i, a := range prints {\n+\t\tif i > 0 {\n+\t\t\ta.deps = append(a.deps, prints[i-1])\n+\t\t}\n+\t}\n+\n+\t// Force benchmarks to run in serial.\n+\tif !testC && testBench {\n+\t\t// The first run must wait for all builds.\n+\t\t// Later runs must wait for the previous run's print.\n+\t\tfor i, run := range runs {\n+\t\t\tif i == 0 {\n+\t\t\t\trun.deps = append(run.deps, builds...)\n+\t\t\t} else {\n+\t\t\t\trun.deps = append(run.deps, prints[i-1])\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// If we are building any out-of-date packages other\n+\t// than those under test, warn.\n+\tokBuild := map[*Package]bool{}\n+\tfor _, p := range pkgs {\n+\t\tokBuild[p] = true\n+\t}\n+\twarned := false\n+\tfor _, a := range actionList(root) {\n+\t\tif a.p == nil || okBuild[a.p] {\n+\t\t\tcontinue\n+\t\t}\n+\t\tokBuild[a.p] = true // warn at most once\n+\n+\t\t// Don't warn about packages being rebuilt because of\n+\t\t// things like coverage analysis.\n+\t\tfor _, p1 := range a.p.imports {\n+\t\t\tif p1.fake {\n+\t\t\t\ta.p.fake = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif a.f != nil && !okBuild[a.p] && !a.p.fake && !a.p.local {\n+\t\t\tif !warned {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: building out-of-date packages:\\n\")\n+\t\t\t\twarned = true\n+\t\t\t}\n+\t\t\tfmt.Fprintf(os.Stderr, \"\\t%s\\n\", a.p.ImportPath)\n+\t\t}\n+\t}\n+\tif warned {\n+\t\targs := strings.Join(pkgArgs, \" \")\n+\t\tif args != \"\" {\n+\t\t\targs = \" \" + args\n+\t\t}\n+\t\textraOpts := \"\"\n+\t\tif buildRace {\n+\t\t\textraOpts = \"-race \"\n+\t\t}\n+\t\tfmt.Fprintf(os.Stderr, \"installing these packages with 'go test %s-i%s' will speed future tests.\\n\\n\", extraOpts, args)\n+\t}\n+\n+\tb.do(root)\n+}\n+\n+func contains(x []string, s string) bool {\n+\tfor _, t := range x {\n+\t\tif t == s {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func (b *builder) test(p *Package) (buildAction, runAction, printAction *action, err error) {\n+\tif len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {\n+\t\tbuild := b.action(modeBuild, modeBuild, p)\n+\t\trun := &action{p: p, deps: []*action{build}}\n+\t\tprint := &action{f: (*builder).notest, p: p, deps: []*action{run}}\n+\t\treturn build, run, print, nil\n+\t}\n+\n+\t// Build Package structs describing:\n+\t//\tptest - package + test files\n+\t//\tpxtest - package of external test files\n+\t//\tpmain - pkg.test binary\n+\tvar ptest, pxtest, pmain *Package\n+\n+\tvar imports, ximports []*Package\n+\tvar stk importStack\n+\tstk.push(p.ImportPath + \" (test)\")\n+\tfor _, path := range p.TestImports {\n+\t\tp1 := loadImport(path, p.Dir, &stk, p.build.TestImportPos[path])\n+\t\tif !reqPkgSrc && p1.Root == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p1.Error != nil {\n+\t\t\treturn nil, nil, nil, p1.Error\n+\t\t}\n+\t\tif contains(p1.Deps, p.ImportPath) {\n+\t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n+\t\t\t// Can't change that code, because that code is only for loading the\n+\t\t\t// non-test copy of a package.\n+\t\t\terr := &PackageError{\n+\t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n+\t\t\t\tErr:           \"import cycle not allowed in test\",\n+\t\t\t\tisImportCycle: true,\n+\t\t\t}\n+\t\t\treturn nil, nil, nil, err\n+\t\t}\n+\t\timports = append(imports, p1)\n+\t}\n+\tstk.pop()\n+\tstk.push(p.ImportPath + \"_test\")\n+\tpxtestNeedsPtest := false\n+\tfor _, path := range p.XTestImports {\n+\t\tif path == p.ImportPath {\n+\t\t\tpxtestNeedsPtest = true\n+\t\t\tcontinue\n+\t\t}\n+\t\tp1 := loadImport(path, p.Dir, &stk, p.build.XTestImportPos[path])\n+\t\tif !reqPkgSrc && p1.Root == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p1.Error != nil {\n+\t\t\treturn nil, nil, nil, p1.Error\n+\t\t}\n+\t\tximports = append(ximports, p1)\n+\t}\n+\tstk.pop()\n+\n+\t// Use last element of import path, not package name.\n+\t// They differ when package name is \"main\".\n+\t// But if the import path is \"command-line-arguments\",\n+\t// like it is during 'go run', use the package name.\n+\tvar elem string\n+\tif p.ImportPath == \"command-line-arguments\" {\n+\t\telem = p.Name\n+\t} else {\n+\t\t_, elem = path.Split(p.ImportPath)\n+\t}\n+\ttestBinary := elem + \".test\"\n+\n+\t// The ptest package needs to be importable under the\n+\t// same import path that p has, but we cannot put it in\n+\t// the usual place in the temporary tree, because then\n+\t// other tests will see it as the real package.\n+\t// Instead we make a _test directory under the import path\n+\t// and then repeat the import path there.  We tell the\n+\t// compiler and linker to look in that _test directory first.\n+\t//\n+\t// That is, if the package under test is unicode/utf8,\n+\t// then the normal place to write the package archive is\n+\t// $WORK/unicode/utf8.a, but we write the test package archive to\n+\t// $WORK/unicode/utf8/_test/unicode/utf8.a.\n+\t// We write the external test package archive to\n+\t// $WORK/unicode/utf8/_test/unicode/utf8_test.a.\n+\ttestDir := filepath.Join(b.work, filepath.FromSlash(p.ImportPath+\"/_test\"))\n+\tptestObj := buildToolchain.pkgpath(testDir, p)\n+\n+\t// Create the directory for the .a files.\n+\tptestDir, _ := filepath.Split(ptestObj)\n+\tif err := b.mkdir(ptestDir); err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\n+\t// Should we apply coverage analysis locally,\n+\t// only for this package and only for this test?\n+\t// Yes, if -cover is on but -coverpkg has not specified\n+\t// a list of packages for global coverage.\n+\tlocalCover := testCover && testCoverPaths == nil\n+\n+\t// Test package.\n+\tif len(p.TestGoFiles) > 0 || localCover || p.Name == \"main\" {\n+\t\tptest = new(Package)\n+\t\t*ptest = *p\n+\t\tptest.GoFiles = nil\n+\t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n+\t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n+\t\tptest.target = \"\"\n+\t\tptest.Imports = stringList(p.Imports, p.TestImports)\n+\t\tptest.imports = append(append([]*Package{}, p.imports...), imports...)\n+\t\tptest.pkgdir = testDir\n+\t\tptest.fake = true\n+\t\tptest.forceLibrary = true\n+\t\tptest.Stale = true\n+\t\tptest.build = new(build.Package)\n+\t\t*ptest.build = *p.build\n+\t\tm := map[string][]token.Position{}\n+\t\tfor k, v := range p.build.ImportPos {\n+\t\t\tm[k] = append(m[k], v...)\n+\t\t}\n+\t\tfor k, v := range p.build.TestImportPos {\n+\t\t\tm[k] = append(m[k], v...)\n+\t\t}\n+\t\tptest.build.ImportPos = m\n+\n+\t\tif localCover {\n+\t\t\tptest.coverMode = testCoverMode\n+\t\t\tvar coverFiles []string\n+\t\t\tcoverFiles = append(coverFiles, ptest.GoFiles...)\n+\t\t\tcoverFiles = append(coverFiles, ptest.CgoFiles...)\n+\t\t\tptest.coverVars = declareCoverVars(ptest.ImportPath, coverFiles...)\n+\t\t}\n+\t} else {\n+\t\tptest = p\n+\t}\n+\n+\t// External test package.\n+\tif len(p.XTestGoFiles) > 0 {\n+\t\tpxtest = &Package{\n+\t\t\tName:        p.Name + \"_test\",\n+\t\t\tImportPath:  p.ImportPath + \"_test\",\n+\t\t\tlocalPrefix: p.localPrefix,\n+\t\t\tRoot:        p.Root,\n+\t\t\tDir:         p.Dir,\n+\t\t\tGoFiles:     p.XTestGoFiles,\n+\t\t\tImports:     p.XTestImports,\n+\t\t\tbuild: &build.Package{\n+\t\t\t\tImportPos: p.build.XTestImportPos,\n+\t\t\t},\n+\t\t\timports: ximports,\n+\t\t\tpkgdir:  testDir,\n+\t\t\tfake:    true,\n+\t\t\tStale:   true,\n+\t\t}\n+\t\tif pxtestNeedsPtest {\n+\t\t\tpxtest.imports = append(pxtest.imports, ptest)\n+\t\t}\n+\t}\n+\n+\t// Action for building pkg.test.\n+\tpmain = &Package{\n+\t\tName:       \"main\",\n+\t\tDir:        testDir,\n+\t\tGoFiles:    []string{\"_testmain.go\"},\n+\t\tImportPath: \"testmain\",\n+\t\tRoot:       p.Root,\n+\t\tbuild:      &build.Package{Name: \"main\"},\n+\t\tpkgdir:     testDir,\n+\t\tfake:       true,\n+\t\tStale:      true,\n+\t\tomitDWARF:  !testC && !testNeedBinary,\n+\t}\n+\n+\t// The generated main also imports testing and regexp.\n+\tstk.push(\"testmain\")\n+\tfor dep := range testMainDeps {\n+\t\tif dep == ptest.ImportPath {\n+\t\t\tpmain.imports = append(pmain.imports, ptest)\n+\t\t} else {\n+\t\t\tp1 := loadImport(dep, \"\", &stk, nil)\n+\t\t\tif !reqPkgSrc && p1.Root == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif p1.Error != nil {\n+\t\t\t\treturn nil, nil, nil, p1.Error\n+\t\t\t}\n+\t\t\tpmain.imports = append(pmain.imports, p1)\n+\t\t}\n+\t}\n+\n+\tif testCoverPkgs != nil {\n+\t\t// Add imports, but avoid duplicates.\n+\t\tseen := map[*Package]bool{p: true, ptest: true}\n+\t\tfor _, p1 := range pmain.imports {\n+\t\t\tseen[p1] = true\n+\t\t}\n+\t\tfor _, p1 := range testCoverPkgs {\n+\t\t\tif !seen[p1] {\n+\t\t\t\tseen[p1] = true\n+\t\t\t\tpmain.imports = append(pmain.imports, p1)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Do initial scan for metadata needed for writing _testmain.go\n+\t// Use that metadata to update the list of imports for package main.\n+\t// The list of imports is used by recompileForTest and by the loop\n+\t// afterward that gathers t.Cover information.\n+\tt, err := loadTestFuncs(ptest)\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\tif t.NeedTest || ptest.coverMode != \"\" {\n+\t\tpmain.imports = append(pmain.imports, ptest)\n+\t}\n+\tif t.NeedXtest {\n+\t\tpmain.imports = append(pmain.imports, pxtest)\n+\t}\n+\n+\tif ptest != p && localCover {\n+\t\t// We have made modifications to the package p being tested\n+\t\t// and are rebuilding p (as ptest), writing it to the testDir tree.\n+\t\t// Arrange to rebuild, writing to that same tree, all packages q\n+\t\t// such that the test depends on q, and q depends on p.\n+\t\t// This makes sure that q sees the modifications to p.\n+\t\t// Strictly speaking, the rebuild is only necessary if the\n+\t\t// modifications to p change its export metadata, but\n+\t\t// determining that is a bit tricky, so we rebuild always.\n+\t\t//\n+\t\t// This will cause extra compilation, so for now we only do it\n+\t\t// when testCover is set. The conditions are more general, though,\n+\t\t// and we may find that we need to do it always in the future.\n+\t\trecompileForTest(pmain, p, ptest, testDir)\n+\t}\n+\n+\tfor _, cp := range pmain.imports {\n+\t\tif len(cp.coverVars) > 0 {\n+\t\t\tt.Cover = append(t.Cover, coverInfo{cp, cp.coverVars})\n+\t\t}\n+\t}\n+\n+\t// writeTestmain writes _testmain.go. This must happen after recompileForTest,\n+\t// because recompileForTest modifies XXX.\n+\tif err := writeTestmain(filepath.Join(testDir, \"_testmain.go\"), t); err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\n+\tcomputeStale(pmain)\n+\n+\tif ptest != p {\n+\t\ta := b.action(modeBuild, modeBuild, ptest)\n+\t\ta.objdir = testDir + string(filepath.Separator) + \"_obj_test\" + string(filepath.Separator)\n+\t\ta.objpkg = ptestObj\n+\t\ta.target = ptestObj\n+\t\ta.link = false\n+\t}\n+\n+\tif pxtest != nil {\n+\t\ta := b.action(modeBuild, modeBuild, pxtest)\n+\t\ta.objdir = testDir + string(filepath.Separator) + \"_obj_xtest\" + string(filepath.Separator)\n+\t\ta.objpkg = buildToolchain.pkgpath(testDir, pxtest)\n+\t\ta.target = a.objpkg\n+\t}\n+\n+\ta := b.action(modeBuild, modeBuild, pmain)\n+\ta.objdir = testDir + string(filepath.Separator)\n+\ta.objpkg = filepath.Join(testDir, \"main.a\")\n+\ta.target = filepath.Join(testDir, testBinary) + exeSuffix\n+\tpmainAction := a\n+\n+\tif testC || testNeedBinary {\n+\t\t// -c or profiling flag: create action to copy binary to ./test.out.\n+\t\trunAction = &action{\n+\t\t\tf:      (*builder).install,\n+\t\t\tdeps:   []*action{pmainAction},\n+\t\t\tp:      pmain,\n+\t\t\ttarget: filepath.Join(cwd, testBinary+exeSuffix),\n+\t\t}\n+\t\tpmainAction = runAction // in case we are running the test\n+\t}\n+\tif testC {\n+\t\tprintAction = &action{p: p, deps: []*action{runAction}} // nop\n+\t} else {\n+\t\t// run test\n+\t\trunAction = &action{\n+\t\t\tf:          (*builder).runTest,\n+\t\t\tdeps:       []*action{pmainAction},\n+\t\t\tp:          p,\n+\t\t\tignoreFail: true,\n+\t\t}\n+\t\tcleanAction := &action{\n+\t\t\tf:    (*builder).cleanTest,\n+\t\t\tdeps: []*action{runAction},\n+\t\t\tp:    p,\n+\t\t}\n+\t\tprintAction = &action{\n+\t\t\tf:    (*builder).printTest,\n+\t\t\tdeps: []*action{cleanAction},\n+\t\t\tp:    p,\n+\t\t}\n+\t}\n+\n+\treturn pmainAction, runAction, printAction, nil\n+}\n+\n+func testImportStack(top string, p *Package, target string) []string {\n+\tstk := []string{top, p.ImportPath}\n+Search:\n+\tfor p.ImportPath != target {\n+\t\tfor _, p1 := range p.imports {\n+\t\t\tif p1.ImportPath == target || contains(p1.Deps, target) {\n+\t\t\t\tstk = append(stk, p1.ImportPath)\n+\t\t\t\tp = p1\n+\t\t\t\tcontinue Search\n+\t\t\t}\n+\t\t}\n+\t\t// Can't happen, but in case it does...\n+\t\tstk = append(stk, \"<lost path to cycle>\")\n+\t\tbreak\n+\t}\n+\treturn stk\n+}\n+\n+func recompileForTest(pmain, preal, ptest *Package, testDir string) {\n+\t// The \"test copy\" of preal is ptest.\n+\t// For each package that depends on preal, make a \"test copy\"\n+\t// that depends on ptest. And so on, up the dependency tree.\n+\ttestCopy := map[*Package]*Package{preal: ptest}\n+\tfor _, p := range packageList([]*Package{pmain}) {\n+\t\t// Copy on write.\n+\t\tdidSplit := false\n+\t\tsplit := func() {\n+\t\t\tif didSplit {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdidSplit = true\n+\t\t\tif p.pkgdir != testDir {\n+\t\t\t\tp1 := new(Package)\n+\t\t\t\ttestCopy[p] = p1\n+\t\t\t\t*p1 = *p\n+\t\t\t\tp1.imports = make([]*Package, len(p.imports))\n+\t\t\t\tcopy(p1.imports, p.imports)\n+\t\t\t\tp = p1\n+\t\t\t\tp.pkgdir = testDir\n+\t\t\t\tp.target = \"\"\n+\t\t\t\tp.fake = true\n+\t\t\t\tp.Stale = true\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Update p.deps and p.imports to use at test copies.\n+\t\tfor i, dep := range p.deps {\n+\t\t\tif p1 := testCopy[dep]; p1 != nil && p1 != dep {\n+\t\t\t\tsplit()\n+\t\t\t\tp.deps[i] = p1\n+\t\t\t}\n+\t\t}\n+\t\tfor i, imp := range p.imports {\n+\t\t\tif p1 := testCopy[imp]; p1 != nil && p1 != imp {\n+\t\t\t\tsplit()\n+\t\t\t\tp.imports[i] = p1\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var coverIndex = 0\n+\n+// isTestFile reports whether the source file is a set of tests and should therefore\n+// be excluded from coverage analysis.\n+func isTestFile(file string) bool {\n+\t// We don't cover tests, only the code they test.\n+\treturn strings.HasSuffix(file, \"_test.go\")\n+}\n+\n+// declareCoverVars attaches the required cover variables names\n+// to the files, to be used when annotating the files.\n+func declareCoverVars(importPath string, files ...string) map[string]*CoverVar {\n+\tcoverVars := make(map[string]*CoverVar)\n+\tfor _, file := range files {\n+\t\tif isTestFile(file) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tcoverVars[file] = &CoverVar{\n+\t\t\tFile: filepath.Join(importPath, file),\n+\t\t\tVar:  fmt.Sprintf(\"GoCover_%d\", coverIndex),\n+\t\t}\n+\t\tcoverIndex++\n+\t}\n+\treturn coverVars\n+}\n+\n+// runTest is the action for running a test binary.\n+func (b *builder) runTest(a *action) error {\n+\targs := stringList(findExecCmd(), a.deps[0].target, testArgs)\n+\ta.testOutput = new(bytes.Buffer)\n+\n+\tif buildN || buildX {\n+\t\tb.showcmd(\"\", \"%s\", strings.Join(args, \" \"))\n+\t\tif buildN {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tif a.failed {\n+\t\t// We were unable to build the binary.\n+\t\ta.failed = false\n+\t\tfmt.Fprintf(a.testOutput, \"FAIL\\t%s [build failed]\\n\", a.p.ImportPath)\n+\t\tsetExitStatus(1)\n+\t\treturn nil\n+\t}\n+\n+\tcmd := exec.Command(args[0], args[1:]...)\n+\tcmd.Dir = a.p.Dir\n+\tcmd.Env = envForDir(cmd.Dir)\n+\tvar buf bytes.Buffer\n+\tif testStreamOutput {\n+\t\tcmd.Stdout = os.Stdout\n+\t\tcmd.Stderr = os.Stderr\n+\t} else {\n+\t\tcmd.Stdout = &buf\n+\t\tcmd.Stderr = &buf\n+\t}\n+\n+\t// If there are any local SWIG dependencies, we want to load\n+\t// the shared library from the build directory.\n+\tif a.p.usesSwig() {\n+\t\tenv := cmd.Env\n+\t\tfound := false\n+\t\tprefix := \"LD_LIBRARY_PATH=\"\n+\t\tfor i, v := range env {\n+\t\t\tif strings.HasPrefix(v, prefix) {\n+\t\t\t\tenv[i] = v + \":.\"\n+\t\t\t\tfound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\tenv = append(env, \"LD_LIBRARY_PATH=.\")\n+\t\t}\n+\t\tcmd.Env = env\n+\t}\n+\n+\tt0 := time.Now()\n+\terr := cmd.Start()\n+\n+\t// This is a last-ditch deadline to detect and\n+\t// stop wedged test binaries, to keep the builders\n+\t// running.\n+\tif err == nil {\n+\t\ttick := time.NewTimer(testKillTimeout)\n+\t\tstartSigHandlers()\n+\t\tdone := make(chan error)\n+\t\tgo func() {\n+\t\t\tdone <- cmd.Wait()\n+\t\t}()\n+\tOuter:\n+\t\tselect {\n+\t\tcase err = <-done:\n+\t\t\t// ok\n+\t\tcase <-tick.C:\n+\t\t\tif signalTrace != nil {\n+\t\t\t\t// Send a quit signal in the hope that the program will print\n+\t\t\t\t// a stack trace and exit. Give it five seconds before resorting\n+\t\t\t\t// to Kill.\n+\t\t\t\tcmd.Process.Signal(signalTrace)\n+\t\t\t\tselect {\n+\t\t\t\tcase err = <-done:\n+\t\t\t\t\tfmt.Fprintf(&buf, \"*** Test killed with %v: ran too long (%v).\\n\", signalTrace, testKillTimeout)\n+\t\t\t\t\tbreak Outer\n+\t\t\t\tcase <-time.After(5 * time.Second):\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcmd.Process.Kill()\n+\t\t\terr = <-done\n+\t\t\tfmt.Fprintf(&buf, \"*** Test killed: ran too long (%v).\\n\", testKillTimeout)\n+\t\t}\n+\t\ttick.Stop()\n+\t}\n+\tout := buf.Bytes()\n+\tt := fmt.Sprintf(\"%.3fs\", time.Since(t0).Seconds())\n+\tif err == nil {\n+\t\tif testShowPass {\n+\t\t\ta.testOutput.Write(out)\n+\t\t}\n+\t\tfmt.Fprintf(a.testOutput, \"ok  \\t%s\\t%s%s\\n\", a.p.ImportPath, t, coveragePercentage(out))\n+\t\treturn nil\n+\t}\n+\n+\tsetExitStatus(1)\n+\tif len(out) > 0 {\n+\t\ta.testOutput.Write(out)\n+\t\t// assume printing the test binary's exit status is superfluous\n+\t} else {\n+\t\tfmt.Fprintf(a.testOutput, \"%s\\n\", err)\n+\t}\n+\tfmt.Fprintf(a.testOutput, \"FAIL\\t%s\\t%s\\n\", a.p.ImportPath, t)\n+\n+\treturn nil\n+}\n+\n+// coveragePercentage returns the coverage results (if enabled) for the\n+// test. It uncovers the data by scanning the output from the test run.\n+func coveragePercentage(out []byte) string {\n+\tif !testCover {\n+\t\treturn \"\"\n+\t}\n+\t// The string looks like\n+\t//\ttest coverage for encoding/binary: 79.9% of statements\n+\t// Extract the piece from the percentage to the end of the line.\n+\tre := regexp.MustCompile(`coverage: (.*)\\n`)\n+\tmatches := re.FindSubmatch(out)\n+\tif matches == nil {\n+\t\t// Probably running \"go test -cover\" not \"go test -cover fmt\".\n+\t\t// The coverage output will appear in the output directly.\n+\t\treturn \"\"\n+\t}\n+\treturn fmt.Sprintf(\"\\tcoverage: %s\", matches[1])\n+}\n+\n+// cleanTest is the action for cleaning up after a test.\n+func (b *builder) cleanTest(a *action) error {\n+\tif buildWork {\n+\t\treturn nil\n+\t}\n+\trun := a.deps[0]\n+\ttestDir := filepath.Join(b.work, filepath.FromSlash(run.p.ImportPath+\"/_test\"))\n+\tos.RemoveAll(testDir)\n+\treturn nil\n+}\n+\n+// printTest is the action for printing a test result.\n+func (b *builder) printTest(a *action) error {\n+\tclean := a.deps[0]\n+\trun := clean.deps[0]\n+\tos.Stdout.Write(run.testOutput.Bytes())\n+\trun.testOutput = nil\n+\treturn nil\n+}\n+\n+// notest is the action for testing a package with no test files.\n+func (b *builder) notest(a *action) error {\n+\tfmt.Printf(\"?   \\t%s\\t[no test files]\\n\", a.p.ImportPath)\n+\treturn nil\n+}\n+\n+// isTest tells whether name looks like a test (or benchmark, according to prefix).\n+// It is a Test (say) if there is a character after Test that is not a lower-case letter.\n+// We don't want TesticularCancer.\n+func isTest(name, prefix string) bool {\n+\tif !strings.HasPrefix(name, prefix) {\n+\t\treturn false\n+\t}\n+\tif len(name) == len(prefix) { // \"Test\" is ok\n+\t\treturn true\n+\t}\n+\trune, _ := utf8.DecodeRuneInString(name[len(prefix):])\n+\treturn !unicode.IsLower(rune)\n+}\n+\n+type coverInfo struct {\n+\tPackage *Package\n+\tVars    map[string]*CoverVar\n+}\n+\n+// loadTestFuncs returns the testFuncs describing the tests that will be run.\n+func loadTestFuncs(ptest *Package) (*testFuncs, error) {\n+\tt := &testFuncs{\n+\t\tPackage: ptest,\n+\t}\n+\tfor _, file := range ptest.TestGoFiles {\n+\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_test\", &t.NeedTest); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tfor _, file := range ptest.XTestGoFiles {\n+\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_xtest\", &t.NeedXtest); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\treturn t, nil\n+}\n+\n+// writeTestmain writes the _testmain.go file for t to the file named out.\n+func writeTestmain(out string, t *testFuncs) error {\n+\tf, err := os.Create(out)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\n+\tif err := testmainTmpl.Execute(f, t); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+type testFuncs struct {\n+\tTests      []testFunc\n+\tBenchmarks []testFunc\n+\tExamples   []testFunc\n+\tPackage    *Package\n+\tNeedTest   bool\n+\tNeedXtest  bool\n+\tCover      []coverInfo\n+}\n+\n+func (t *testFuncs) CoverMode() string {\n+\treturn testCoverMode\n+}\n+\n+func (t *testFuncs) CoverEnabled() bool {\n+\treturn testCover\n+}\n+\n+// Covered returns a string describing which packages are being tested for coverage.\n+// If the covered package is the same as the tested package, it returns the empty string.\n+// Otherwise it is a comma-separated human-readable list of packages beginning with\n+// \" in\", ready for use in the coverage message.\n+func (t *testFuncs) Covered() string {\n+\tif testCoverPaths == nil {\n+\t\treturn \"\"\n+\t}\n+\treturn \" in \" + strings.Join(testCoverPaths, \", \")\n+}\n+\n+// Tested returns the name of the package being tested.\n+func (t *testFuncs) Tested() string {\n+\treturn t.Package.Name\n+}\n+\n+type testFunc struct {\n+\tPackage string // imported package name (_test or _xtest)\n+\tName    string // function name\n+\tOutput  string // output, for examples\n+}\n+\n+var testFileSet = token.NewFileSet()\n+\n+func (t *testFuncs) load(filename, pkg string, seen *bool) error {\n+\tf, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)\n+\tif err != nil {\n+\t\treturn expandScanner(err)\n+\t}\n+\tfor _, d := range f.Decls {\n+\t\tn, ok := d.(*ast.FuncDecl)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif n.Recv != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tname := n.Name.String()\n+\t\tswitch {\n+\t\tcase isTest(name, \"Test\"):\n+\t\t\tt.Tests = append(t.Tests, testFunc{pkg, name, \"\"})\n+\t\t\t*seen = true\n+\t\tcase isTest(name, \"Benchmark\"):\n+\t\t\tt.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, \"\"})\n+\t\t\t*seen = true\n+\t\t}\n+\t}\n+\tex := doc.Examples(f)\n+\tsort.Sort(byOrder(ex))\n+\tfor _, e := range ex {\n+\t\tif e.Output == \"\" && !e.EmptyOutput {\n+\t\t\t// Don't run examples with no output.\n+\t\t\tcontinue\n+\t\t}\n+\t\tt.Examples = append(t.Examples, testFunc{pkg, \"Example\" + e.Name, e.Output})\n+\t\t*seen = true\n+\t}\n+\treturn nil\n+}\n+\n+type byOrder []*doc.Example\n+\n+func (x byOrder) Len() int           { return len(x) }\n+func (x byOrder) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }\n+func (x byOrder) Less(i, j int) bool { return x[i].Order < x[j].Order }\n+\n+var testmainTmpl = template.Must(template.New(\"main\").Parse(`\n+package main\n+\n+import (\n+\t\"regexp\"\n+\t\"testing\"\n+\n+{{if .NeedTest}}\n+\t_test {{.Package.ImportPath | printf \"%q\"}}\n+{{end}}\n+{{if .NeedXtest}}\n+\t_xtest {{.Package.ImportPath | printf \"%s_test\" | printf \"%q\"}}\n+{{end}}\n+{{range $i, $p := .Cover}}\n+\t_cover{{$i}} {{$p.Package.ImportPath | printf \"%q\"}}\n+{{end}}\n+)\n+\n+var tests = []testing.InternalTest{\n+{{range .Tests}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}},\n+{{end}}\n+}\n+\n+var benchmarks = []testing.InternalBenchmark{\n+{{range .Benchmarks}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}},\n+{{end}}\n+}\n+\n+var examples = []testing.InternalExample{\n+{{range .Examples}}\n+\t{\"{{.Name}}\", {{.Package}}.{{.Name}}, {{.Output | printf \"%q\"}}},\n+{{end}}\n+}\n+\n+var matchPat string\n+var matchRe *regexp.Regexp\n+\n+func matchString(pat, str string) (result bool, err error) {\n+\tif matchRe == nil || matchPat != pat {\n+\t\tmatchPat = pat\n+\t\tmatchRe, err = regexp.Compile(matchPat)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn matchRe.MatchString(str), nil\n+}\n+\n+{{if .CoverEnabled}}\n+\n+// Only updated by init functions, so no need for atomicity.\n+var (\n+\tcoverCounters = make(map[string][]uint32)\n+\tcoverBlocks = make(map[string][]testing.CoverBlock)\n+)\n+\n+func init() {\n+\t{{range $i, $p := .Cover}}\n+\t{{range $file, $cover := $p.Vars}}\n+\tcoverRegisterFile({{printf \"%q\" $cover.File}}, _cover{{$i}}.{{$cover.Var}}.Count[:], _cover{{$i}}.{{$cover.Var}}.Pos[:], _cover{{$i}}.{{$cover.Var}}.NumStmt[:])\n+\t{{end}}\n+\t{{end}}\n+}\n+\n+func coverRegisterFile(fileName string, counter []uint32, pos []uint32, numStmts []uint16) {\n+\tif 3*len(counter) != len(pos) || len(counter) != len(numStmts) {\n+\t\tpanic(\"coverage: mismatched sizes\")\n+\t}\n+\tif coverCounters[fileName] != nil {\n+\t\t// Already registered.\n+\t\treturn\n+\t}\n+\tcoverCounters[fileName] = counter\n+\tblock := make([]testing.CoverBlock, len(counter))\n+\tfor i := range counter {\n+\t\tblock[i] = testing.CoverBlock{\n+\t\t\tLine0: pos[3*i+0],\n+\t\t\tCol0: uint16(pos[3*i+2]),\n+\t\t\tLine1: pos[3*i+1],\n+\t\t\tCol1: uint16(pos[3*i+2]>>16),\n+\t\t\tStmts: numStmts[i],\n+\t\t}\n+\t}\n+\tcoverBlocks[fileName] = block\n+}\n+{{end}}\n+\n+func main() {\n+{{if .CoverEnabled}}\n+\ttesting.RegisterCover(testing.Cover{\n+\t\tMode: {{printf \"%q\" .CoverMode}},\n+\t\tCounters: coverCounters,\n+\t\tBlocks: coverBlocks,\n+\t\tCoveredPackages: {{printf \"%q\" .Covered}},\n+\t})\n+{{end}}\n+\ttesting.Main(matchString, tests, benchmarks, examples)\n+}\n+\n+`))"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/cgocover/p.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fcgocover%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fcgocover%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fcgocover%2Fp.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,19 @@\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}"}, {"sha": "a8f057e358767230643d2cb226c69cfb75303b52", "filename": "libgo/go/cmd/go/testdata/cgocover/p_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fcgocover%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fcgocover%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fcgocover%2Fp_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package p\n+\n+import \"testing\"\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "0c53ac4f963517191f614aa17044b1df0d63f0c8", "filename": "libgo/go/cmd/go/testdata/dep_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fdep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fdep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fdep_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package deps\n+\n+import _ \"testing\""}, {"sha": "ec7092e972b712211df90d7c7fc45966625310b0", "filename": "libgo/go/cmd/go/testdata/example1_test.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample1_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Make sure that go test runs Example_Z before Example_A, preserving source order.\n+\n+package p\n+\n+import \"fmt\"\n+\n+var n int\n+\n+func Example_Z() {\n+\tn++\n+\tfmt.Println(n)\n+\t// Output: 1\n+}\n+\n+func Example_A() {\n+\tn++\n+\tfmt.Println(n)\n+\t// Output: 2\n+}"}, {"sha": "1e0e80b80f03e1157654014df0b21b7d379150f0", "filename": "libgo/go/cmd/go/testdata/example2_test.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fexample2_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Make sure that go test runs Example_Y before Example_B, preserving source order.\n+\n+package p\n+\n+import \"fmt\"\n+\n+func Example_Y() {\n+\tn++\n+\tfmt.Println(n)\n+\t// Output: 3\n+}\n+\n+func Example_B() {\n+\tn++\n+\tfmt.Println(n)\n+\t// Output: 4\n+}"}, {"sha": "4eeb517da15acf0bf8bc9f46a344fb85dfb46cda", "filename": "libgo/go/cmd/go/testdata/local/easy.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasy.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+import \"./easysub\"\n+\n+func main() {\n+\teasysub.Hello()\n+}"}, {"sha": "07040daee57991188df9d044c1e4502542555bda", "filename": "libgo/go/cmd/go/testdata/local/easysub/easysub.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Feasysub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Feasysub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Feasysub.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package easysub\n+\n+import \"fmt\"\n+\n+func Hello() {\n+\tfmt.Println(\"easysub.Hello\")\n+}"}, {"sha": "6c30b52362e45ed4d01d567a7452f4c729766165", "filename": "libgo/go/cmd/go/testdata/local/easysub/main.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Fmain.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,9 @@\n+// +build ignore\n+\n+package main\n+\n+import \".\"\n+\n+func main() {\n+\teasysub.Hello()\n+}"}, {"sha": "2ffac3fd73bc65874b0e8edc8141049685622edf", "filename": "libgo/go/cmd/go/testdata/local/hard.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fhard.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fhard.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fhard.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+import \"./sub\"\n+\n+func main() {\n+\tsub.Hello()\n+}"}, {"sha": "d5dbf6d5fa5bbe0a79e1e3c1163cb7d5d5f25376", "filename": "libgo/go/cmd/go/testdata/local/sub/sub.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+package sub\n+\n+import (\n+\t\"fmt\"\n+\n+\tsubsub \"./sub\"\n+)\n+\n+func Hello() {\n+\tfmt.Println(\"sub.Hello\")\n+\tsubsub.Hello()\n+}"}, {"sha": "4cc72233e13ee42317ed013074331f1ccdadc10b", "filename": "libgo/go/cmd/go/testdata/local/sub/sub/subsub.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub%2Fsubsub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub%2Fsubsub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub%2Fsubsub.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package subsub\n+\n+import \"fmt\"\n+\n+func Hello() {\n+\tfmt.Println(\"subsub.Hello\")\n+}"}, {"sha": "f52652b1ba78cfe439c9719d0d3dfb51ed9d44d8", "filename": "libgo/go/cmd/go/testdata/shadow/root1/src/foo/foo.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Ffoo%2Ffoo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Ffoo%2Ffoo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Ffoo%2Ffoo.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1 @@\n+package foo"}, {"sha": "c91c24e967cccde6aa7be55a6e77ed22991bf9e9", "filename": "libgo/go/cmd/go/testdata/shadow/root1/src/math/math.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Fmath%2Fmath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Fmath%2Fmath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot1%2Fsrc%2Fmath%2Fmath.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1 @@\n+package math"}, {"sha": "f52652b1ba78cfe439c9719d0d3dfb51ed9d44d8", "filename": "libgo/go/cmd/go/testdata/shadow/root2/src/foo/foo.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot2%2Fsrc%2Ffoo%2Ffoo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot2%2Fsrc%2Ffoo%2Ffoo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fshadow%2Froot2%2Fsrc%2Ffoo%2Ffoo.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1 @@\n+package foo"}, {"sha": "dda35e8ed3db96f40fe93a0f5a6ba71cb13180d1", "filename": "libgo/go/cmd/go/testdata/src/badpkg/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadpkg%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadpkg%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadpkg%2Fx.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1 @@\n+pkg badpkg"}, {"sha": "4d68307cf0dbaee3064123c54e068da54146fa62", "filename": "libgo/go/cmd/go/testdata/src/cgotest/m.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgotest%2Fm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgotest%2Fm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgotest%2Fm.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,5 @@\n+package cgotest\n+\n+import \"C\"\n+\n+var _ C.int"}, {"sha": "002a5c740c7d288d40d490a43aae9297488a2433", "filename": "libgo/go/cmd/go/testdata/src/go-cmd-test/helloworld.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgo-cmd-test%2Fhelloworld.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgo-cmd-test%2Fhelloworld.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgo-cmd-test%2Fhelloworld.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,5 @@\n+package main\n+\n+func main() {\n+\tprintln(\"hello world\")\n+}"}, {"sha": "c682f030b4eb33e1dfe819ec320806076ff7131a", "filename": "libgo/go/cmd/go/testdata/src/main_test/m.go", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,4 @@\n+package main\n+\n+func F()    {}\n+func main() {}"}, {"sha": "f865b7734f0e5d56fe6e62dd0f540efc00eb783a", "filename": "libgo/go/cmd/go/testdata/src/main_test/m_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+package main_test\n+\n+import (\n+\t. \"main_test\"\n+\t\"testing\"\n+)\n+\n+func Test1(t *testing.T) {\n+\tF()\n+}"}, {"sha": "7c42c32fb0abcae9ad478b2e9b324b4de4814526", "filename": "libgo/go/cmd/go/testdata/src/notest/hello.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnotest%2Fhello.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnotest%2Fhello.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnotest%2Fhello.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,6 @@\n+package notest\n+\n+func hello() {\n+\tprintln(\"hello world\")\n+}\n+Hello world"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/syntaxerror/x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "2460743e50186d66712857889ed1506286f2b53f", "filename": "libgo/go/cmd/go/testdata/src/syntaxerror/x_test.go", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,4 @@\n+package p\n+\n+func f() (x.y, z int) {\n+}"}, {"sha": "65ab76d4e1e8bafc5e3a1e10dd5be1200625228f", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p1/p1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package p1\n+\n+import _ \"testcycle/p2\"\n+\n+func init() {\n+\tprintln(\"p1 init\")\n+}"}, {"sha": "75abb13e6d0349938d6d1e1136e225e230ab19f4", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p1/p1_test.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,6 @@\n+package p1\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+}"}, {"sha": "7e26cdf19c913f3c4638944540967e93a507caa5", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p2/p2.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp2%2Fp2.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+package p2\n+\n+import _ \"testcycle/p3\"\n+\n+func init() {\n+\tprintln(\"p2 init\")\n+}"}, {"sha": "bb0a2f4f6569229b75b37b6636c5dede5d35fc62", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p3/p3.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,5 @@\n+package p3\n+\n+func init() {\n+\tprintln(\"p3 init\")\n+}"}, {"sha": "9b4b0757f82acca7121fbceb6223c0700e322bb1", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p3/p3_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+package p3\n+\n+import (\n+\t\"testing\"\n+\n+\t_ \"testcycle/p1\"\n+)\n+\n+func Test(t *testing.T) {\n+}"}, {"sha": "dac039e1ad0ed1c0b00c4338abe5f5e46fc39a66", "filename": "libgo/go/cmd/go/testdata/src/xtestonly/f.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+package xtestonly\n+\n+func F() int { return 42 }"}, {"sha": "01f6e83730c3911929f1d218739bb7c94810850f", "filename": "libgo/go/cmd/go/testdata/src/xtestonly/f_test.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fxtestonly%2Ff_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+package xtestonly_test\n+\n+import (\n+\t\"testing\"\n+\t\"xtestonly\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tif x := xtestonly.F(); x != 42 {\n+\t\tt.Errorf(\"f.F() = %d, want 42\", x)\n+\t}\n+}"}, {"sha": "59cf918b9bc8dcb0a8a9cc8dca67ab3e520ad961", "filename": "libgo/go/cmd/go/testdata/standalone_test.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,6 @@\n+package standalone_test\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+}"}, {"sha": "f94d2cd0e66c2b19547f2a04039695a555140f1d", "filename": "libgo/go/cmd/go/testdata/testimport/p.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+package p\n+\n+func F() int { return 1 }"}, {"sha": "fd315272ea21d544f0db689c99bce227ca20617c", "filename": "libgo/go/cmd/go/testdata/testimport/p1/p1.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp1%2Fp1.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+package p1\n+\n+func F() int { return 1 }"}, {"sha": "d4888865ddb7a88b8abd553b67ce7bc78eedcbbc", "filename": "libgo/go/cmd/go/testdata/testimport/p2/p2.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp2%2Fp2.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+package p2\n+\n+func F() int { return 1 }"}, {"sha": "a3fb4a9e2780b84bec390a6c8d800bcd8e86f66c", "filename": "libgo/go/cmd/go/testdata/testimport/p_test.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fp_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,13 @@\n+package p\n+\n+import (\n+\t\"./p1\"\n+\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tif F() != p1.F() {\n+\t\tt.Fatal(F())\n+\t}\n+}"}, {"sha": "b253e3fd2dd9453d8c812acff968c21953bf98ad", "filename": "libgo/go/cmd/go/testdata/testimport/x_test.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestimport%2Fx_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+package p_test\n+\n+import (\n+\t. \"../testimport\"\n+\n+\t\"./p2\"\n+\n+\t\"testing\"\n+)\n+\n+func TestF1(t *testing.T) {\n+\tif F() != p2.F() {\n+\t\tt.Fatal(F())\n+\t}\n+}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/testonly/p_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Ftestonly%2Fp_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1 @@\n+package p"}, {"sha": "73f311e5f69e6e3a99c610e40b066ea353315f91", "filename": "libgo/go/cmd/go/testflag.go", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,318 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+// The flag handling part of go test is large and distracting.\n+// We can't use the flag package because some of the flags from\n+// our command line are for us, and some are for 6.out, and\n+// some are for both.\n+\n+var usageMessage = `Usage of go test:\n+  -c=false: compile but do not run the test binary\n+  -file=file_test.go: specify file to use for tests;\n+      use multiple times for multiple files\n+  -p=n: build and test up to n packages in parallel\n+  -x=false: print command lines as they are executed\n+\n+  // These flags can be passed with or without a \"test.\" prefix: -v or -test.v.\n+  -bench=\"\": passes -test.bench to test\n+  -benchmem=false: print memory allocation statistics for benchmarks\n+  -benchtime=1s: passes -test.benchtime to test\n+  -cover=false: enable coverage analysis\n+  -covermode=\"set\": specifies mode for coverage analysis\n+  -coverpkg=\"\": comma-separated list of packages for coverage analysis\n+  -coverprofile=\"\": passes -test.coverprofile to test if -cover\n+  -cpu=\"\": passes -test.cpu to test\n+  -cpuprofile=\"\": passes -test.cpuprofile to test\n+  -memprofile=\"\": passes -test.memprofile to test\n+  -memprofilerate=0: passes -test.memprofilerate to test\n+  -blockprofile=\"\": pases -test.blockprofile to test\n+  -blockprofilerate=0: passes -test.blockprofilerate to test\n+  -outputdir=$PWD: passes -test.outputdir to test\n+  -parallel=0: passes -test.parallel to test\n+  -run=\"\": passes -test.run to test\n+  -short=false: passes -test.short to test\n+  -timeout=0: passes -test.timeout to test\n+  -v=false: passes -test.v to test\n+`\n+\n+// usage prints a usage message and exits.\n+func testUsage() {\n+\tfmt.Fprint(os.Stderr, usageMessage)\n+\tsetExitStatus(2)\n+\texit()\n+}\n+\n+// testFlagSpec defines a flag we know about.\n+type testFlagSpec struct {\n+\tname       string\n+\tboolVar    *bool\n+\tpassToTest bool // pass to Test\n+\tmultiOK    bool // OK to have multiple instances\n+\tpresent    bool // flag has been seen\n+}\n+\n+// testFlagDefn is the set of flags we process.\n+var testFlagDefn = []*testFlagSpec{\n+\t// local.\n+\t{name: \"c\", boolVar: &testC},\n+\t{name: \"file\", multiOK: true},\n+\t{name: \"cover\", boolVar: &testCover},\n+\t{name: \"coverpkg\"},\n+\n+\t// build flags.\n+\t{name: \"a\", boolVar: &buildA},\n+\t{name: \"n\", boolVar: &buildN},\n+\t{name: \"p\"},\n+\t{name: \"x\", boolVar: &buildX},\n+\t{name: \"i\", boolVar: &buildI},\n+\t{name: \"work\", boolVar: &buildWork},\n+\t{name: \"ccflags\"},\n+\t{name: \"gcflags\"},\n+\t{name: \"exec\"},\n+\t{name: \"ldflags\"},\n+\t{name: \"gccgoflags\"},\n+\t{name: \"tags\"},\n+\t{name: \"compiler\"},\n+\t{name: \"race\", boolVar: &buildRace},\n+\t{name: \"installsuffix\"},\n+\n+\t// passed to 6.out, adding a \"test.\" prefix to the name if necessary: -v becomes -test.v.\n+\t{name: \"bench\", passToTest: true},\n+\t{name: \"benchmem\", boolVar: new(bool), passToTest: true},\n+\t{name: \"benchtime\", passToTest: true},\n+\t{name: \"covermode\"},\n+\t{name: \"coverprofile\", passToTest: true},\n+\t{name: \"cpu\", passToTest: true},\n+\t{name: \"cpuprofile\", passToTest: true},\n+\t{name: \"memprofile\", passToTest: true},\n+\t{name: \"memprofilerate\", passToTest: true},\n+\t{name: \"blockprofile\", passToTest: true},\n+\t{name: \"blockprofilerate\", passToTest: true},\n+\t{name: \"outputdir\", passToTest: true},\n+\t{name: \"parallel\", passToTest: true},\n+\t{name: \"run\", passToTest: true},\n+\t{name: \"short\", boolVar: new(bool), passToTest: true},\n+\t{name: \"timeout\", passToTest: true},\n+\t{name: \"v\", boolVar: &testV, passToTest: true},\n+}\n+\n+// testFlags processes the command line, grabbing -x and -c, rewriting known flags\n+// to have \"test\" before them, and reading the command line for the 6.out.\n+// Unfortunately for us, we need to do our own flag processing because go test\n+// grabs some flags but otherwise its command line is just a holding place for\n+// pkg.test's arguments.\n+// We allow known flags both before and after the package name list,\n+// to allow both\n+//\tgo test fmt -custom-flag-for-fmt-test\n+//\tgo test -x math\n+func testFlags(args []string) (packageNames, passToTest []string) {\n+\tinPkg := false\n+\toutputDir := \"\"\n+\tfor i := 0; i < len(args); i++ {\n+\t\tif !strings.HasPrefix(args[i], \"-\") {\n+\t\t\tif !inPkg && packageNames == nil {\n+\t\t\t\t// First package name we've seen.\n+\t\t\t\tinPkg = true\n+\t\t\t}\n+\t\t\tif inPkg {\n+\t\t\t\tpackageNames = append(packageNames, args[i])\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tif inPkg {\n+\t\t\t// Found an argument beginning with \"-\"; end of package list.\n+\t\t\tinPkg = false\n+\t\t}\n+\n+\t\tf, value, extraWord := testFlag(args, i)\n+\t\tif f == nil {\n+\t\t\t// This is a flag we do not know; we must assume\n+\t\t\t// that any args we see after this might be flag\n+\t\t\t// arguments, not package names.\n+\t\t\tinPkg = false\n+\t\t\tif packageNames == nil {\n+\t\t\t\t// make non-nil: we have seen the empty package list\n+\t\t\t\tpackageNames = []string{}\n+\t\t\t}\n+\t\t\tpassToTest = append(passToTest, args[i])\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar err error\n+\t\tswitch f.name {\n+\t\t// bool flags.\n+\t\tcase \"a\", \"c\", \"i\", \"n\", \"x\", \"v\", \"race\", \"cover\", \"work\":\n+\t\t\tsetBoolFlag(f.boolVar, value)\n+\t\tcase \"p\":\n+\t\t\tsetIntFlag(&buildP, value)\n+\t\tcase \"exec\":\n+\t\t\texecCmd, err = splitQuotedFields(value)\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n+\t\t\t}\n+\t\tcase \"ccflags\":\n+\t\t\tbuildCcflags, err = splitQuotedFields(value)\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n+\t\t\t}\n+\t\tcase \"gcflags\":\n+\t\t\tbuildGcflags, err = splitQuotedFields(value)\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n+\t\t\t}\n+\t\tcase \"ldflags\":\n+\t\t\tbuildLdflags, err = splitQuotedFields(value)\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n+\t\t\t}\n+\t\tcase \"gccgoflags\":\n+\t\t\tbuildGccgoflags, err = splitQuotedFields(value)\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n+\t\t\t}\n+\t\tcase \"tags\":\n+\t\t\tbuildContext.BuildTags = strings.Fields(value)\n+\t\tcase \"compiler\":\n+\t\t\tbuildCompiler{}.Set(value)\n+\t\tcase \"file\":\n+\t\t\ttestFiles = append(testFiles, value)\n+\t\tcase \"bench\":\n+\t\t\t// record that we saw the flag; don't care about the value\n+\t\t\ttestBench = true\n+\t\tcase \"timeout\":\n+\t\t\ttestTimeout = value\n+\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\":\n+\t\t\ttestProfile = true\n+\t\t\ttestNeedBinary = true\n+\t\tcase \"coverpkg\":\n+\t\t\ttestCover = true\n+\t\t\tif value == \"\" {\n+\t\t\t\ttestCoverPaths = nil\n+\t\t\t} else {\n+\t\t\t\ttestCoverPaths = strings.Split(value, \",\")\n+\t\t\t}\n+\t\tcase \"coverprofile\":\n+\t\t\ttestCover = true\n+\t\t\ttestProfile = true\n+\t\tcase \"covermode\":\n+\t\t\tswitch value {\n+\t\t\tcase \"set\", \"count\", \"atomic\":\n+\t\t\t\ttestCoverMode = value\n+\t\t\tdefault:\n+\t\t\t\tfatalf(\"invalid flag argument for -cover: %q\", value)\n+\t\t\t}\n+\t\t\ttestCover = true\n+\t\tcase \"outputdir\":\n+\t\t\toutputDir = value\n+\t\t}\n+\t\tif extraWord {\n+\t\t\ti++\n+\t\t}\n+\t\tif f.passToTest {\n+\t\t\tpassToTest = append(passToTest, \"-test.\"+f.name+\"=\"+value)\n+\t\t}\n+\t}\n+\n+\tif testCoverMode == \"\" {\n+\t\ttestCoverMode = \"set\"\n+\t\tif buildRace {\n+\t\t\t// Default coverage mode is atomic when -race is set.\n+\t\t\ttestCoverMode = \"atomic\"\n+\t\t}\n+\t}\n+\n+\t// Tell the test what directory we're running in, so it can write the profiles there.\n+\tif testProfile && outputDir == \"\" {\n+\t\tdir, err := os.Getwd()\n+\t\tif err != nil {\n+\t\t\tfatalf(\"error from os.Getwd: %s\", err)\n+\t\t}\n+\t\tpassToTest = append(passToTest, \"-test.outputdir\", dir)\n+\t}\n+\treturn\n+}\n+\n+// testFlag sees if argument i is a known flag and returns its definition, value, and whether it consumed an extra word.\n+func testFlag(args []string, i int) (f *testFlagSpec, value string, extra bool) {\n+\targ := args[i]\n+\tif strings.HasPrefix(arg, \"--\") { // reduce two minuses to one\n+\t\targ = arg[1:]\n+\t}\n+\tswitch arg {\n+\tcase \"-?\", \"-h\", \"-help\":\n+\t\tusage()\n+\t}\n+\tif arg == \"\" || arg[0] != '-' {\n+\t\treturn\n+\t}\n+\tname := arg[1:]\n+\t// If there's already \"test.\", drop it for now.\n+\tname = strings.TrimPrefix(name, \"test.\")\n+\tequals := strings.Index(name, \"=\")\n+\tif equals >= 0 {\n+\t\tvalue = name[equals+1:]\n+\t\tname = name[:equals]\n+\t}\n+\tfor _, f = range testFlagDefn {\n+\t\tif name == f.name {\n+\t\t\t// Booleans are special because they have modes -x, -x=true, -x=false.\n+\t\t\tif f.boolVar != nil {\n+\t\t\t\tif equals < 0 { // otherwise, it's been set and will be verified in setBoolFlag\n+\t\t\t\t\tvalue = \"true\"\n+\t\t\t\t} else {\n+\t\t\t\t\t// verify it parses\n+\t\t\t\t\tsetBoolFlag(new(bool), value)\n+\t\t\t\t}\n+\t\t\t} else { // Non-booleans must have a value.\n+\t\t\t\textra = equals < 0\n+\t\t\t\tif extra {\n+\t\t\t\t\tif i+1 >= len(args) {\n+\t\t\t\t\t\ttestSyntaxError(\"missing argument for flag \" + f.name)\n+\t\t\t\t\t}\n+\t\t\t\t\tvalue = args[i+1]\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif f.present && !f.multiOK {\n+\t\t\t\ttestSyntaxError(f.name + \" flag may be set only once\")\n+\t\t\t}\n+\t\t\tf.present = true\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tf = nil\n+\treturn\n+}\n+\n+// setBoolFlag sets the addressed boolean to the value.\n+func setBoolFlag(flag *bool, value string) {\n+\tx, err := strconv.ParseBool(value)\n+\tif err != nil {\n+\t\ttestSyntaxError(\"illegal bool flag value \" + value)\n+\t}\n+\t*flag = x\n+}\n+\n+// setIntFlag sets the addressed integer to the value.\n+func setIntFlag(flag *int, value string) {\n+\tx, err := strconv.Atoi(value)\n+\tif err != nil {\n+\t\ttestSyntaxError(\"illegal int flag value \" + value)\n+\t}\n+\t*flag = x\n+}\n+\n+func testSyntaxError(msg string) {\n+\tfmt.Fprintf(os.Stderr, \"go test: %s\\n\", msg)\n+\tfmt.Fprintf(os.Stderr, `run \"go help test\" or \"go help testflag\" for more information`+\"\\n\")\n+\tos.Exit(2)\n+}"}, {"sha": "6d26f7a4b4ada01e83c84ce2c2b7ca1719b5cb12", "filename": "libgo/go/cmd/go/tool.go", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftool.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+var cmdTool = &Command{\n+\tRun:       runTool,\n+\tUsageLine: \"tool [-n] command [args...]\",\n+\tShort:     \"run specified go tool\",\n+\tLong: `\n+Tool runs the go tool command identified by the arguments.\n+With no arguments it prints the list of known tools.\n+\n+The -n flag causes tool to print the command that would be\n+executed but not execute it.\n+\n+For more about each tool command, see 'go tool command -h'.\n+`,\n+}\n+\n+var (\n+\ttoolGOOS      = runtime.GOOS\n+\ttoolGOARCH    = runtime.GOARCH\n+\ttoolIsWindows = toolGOOS == \"windows\"\n+\ttoolDir       = build.ToolDir\n+\n+\ttoolN bool\n+)\n+\n+func init() {\n+\tcmdTool.Flag.BoolVar(&toolN, \"n\", false, \"\")\n+}\n+\n+const toolWindowsExtension = \".exe\"\n+\n+func tool(toolName string) string {\n+\ttoolPath := filepath.Join(toolDir, toolName)\n+\tif toolIsWindows && toolName != \"pprof\" {\n+\t\ttoolPath += toolWindowsExtension\n+\t}\n+\t// Give a nice message if there is no tool with that name.\n+\tif _, err := os.Stat(toolPath); err != nil {\n+\t\tif isInGoToolsRepo(toolName) {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q; to install:\\n\\tgo get code.google.com/p/go.tools/cmd/%s\\n\", toolName, toolName)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n+\t\t}\n+\t\tsetExitStatus(3)\n+\t\texit()\n+\t}\n+\treturn toolPath\n+}\n+\n+func isInGoToolsRepo(toolName string) bool {\n+\tswitch toolName {\n+\tcase \"cover\", \"vet\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func runTool(cmd *Command, args []string) {\n+\tif len(args) == 0 {\n+\t\tlistTools()\n+\t\treturn\n+\t}\n+\ttoolName := args[0]\n+\t// The tool name must be lower-case letters, numbers or underscores.\n+\tfor _, c := range toolName {\n+\t\tswitch {\n+\t\tcase 'a' <= c && c <= 'z', '0' <= c && c <= '9', c == '_':\n+\t\tdefault:\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: bad tool name %q\\n\", toolName)\n+\t\t\tsetExitStatus(2)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\ttoolPath := tool(toolName)\n+\tif toolPath == \"\" {\n+\t\treturn\n+\t}\n+\tif toolIsWindows && toolName == \"pprof\" {\n+\t\targs = append([]string{\"perl\", toolPath}, args[1:]...)\n+\t\tvar err error\n+\t\ttoolPath, err = exec.LookPath(\"perl\")\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: perl not found\\n\")\n+\t\t\tsetExitStatus(3)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tif toolN {\n+\t\tfmt.Printf(\"%s %s\\n\", toolPath, strings.Join(args[1:], \" \"))\n+\t\treturn\n+\t}\n+\ttoolCmd := &exec.Cmd{\n+\t\tPath:   toolPath,\n+\t\tArgs:   args,\n+\t\tStdin:  os.Stdin,\n+\t\tStdout: os.Stdout,\n+\t\tStderr: os.Stderr,\n+\t}\n+\terr := toolCmd.Run()\n+\tif err != nil {\n+\t\t// Only print about the exit status if the command\n+\t\t// didn't even run (not an ExitError) or it didn't exit cleanly\n+\t\t// or we're printing command lines too (-x mode).\n+\t\t// Assume if command exited cleanly (even with non-zero status)\n+\t\t// it printed any messages it wanted to print.\n+\t\tif e, ok := err.(*exec.ExitError); !ok || !e.Exited() || buildX {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool %s: %s\\n\", toolName, err)\n+\t\t}\n+\t\tsetExitStatus(1)\n+\t\treturn\n+\t}\n+}\n+\n+// listTools prints a list of the available tools in the tools directory.\n+func listTools() {\n+\tf, err := os.Open(toolDir)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"go tool: no tool directory: %s\\n\", err)\n+\t\tsetExitStatus(2)\n+\t\treturn\n+\t}\n+\tdefer f.Close()\n+\tnames, err := f.Readdirnames(-1)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"go tool: can't read directory: %s\\n\", err)\n+\t\tsetExitStatus(2)\n+\t\treturn\n+\t}\n+\n+\tsort.Strings(names)\n+\tfor _, name := range names {\n+\t\t// Unify presentation by going to lower case.\n+\t\tname = strings.ToLower(name)\n+\t\t// If it's windows, don't show the .exe suffix.\n+\t\tif toolIsWindows && strings.HasSuffix(name, toolWindowsExtension) {\n+\t\t\tname = name[:len(name)-len(toolWindowsExtension)]\n+\t\t}\n+\t\tfmt.Println(name)\n+\t}\n+}"}, {"sha": "8f0bae0b755daaa41cbb78aea18275a5ca536f40", "filename": "libgo/go/cmd/go/vcs.go", "status": "added", "additions": 728, "deletions": 0, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,728 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strings\"\n+)\n+\n+// A vcsCmd describes how to use a version control system\n+// like Mercurial, Git, or Subversion.\n+type vcsCmd struct {\n+\tname string\n+\tcmd  string // name of binary to invoke command\n+\n+\tcreateCmd   string // command to download a fresh copy of a repository\n+\tdownloadCmd string // command to download updates into an existing repository\n+\n+\ttagCmd         []tagCmd // commands to list tags\n+\ttagLookupCmd   []tagCmd // commands to lookup tags before running tagSyncCmd\n+\ttagSyncCmd     string   // command to sync to specific tag\n+\ttagSyncDefault string   // command to sync to default tag\n+\n+\tscheme  []string\n+\tpingCmd string\n+}\n+\n+// A tagCmd describes a command to list available tags\n+// that can be passed to tagSyncCmd.\n+type tagCmd struct {\n+\tcmd     string // command to list tags\n+\tpattern string // regexp to extract tags from list\n+}\n+\n+// vcsList lists the known version control systems\n+var vcsList = []*vcsCmd{\n+\tvcsHg,\n+\tvcsGit,\n+\tvcsSvn,\n+\tvcsBzr,\n+}\n+\n+// vcsByCmd returns the version control system for the given\n+// command name (hg, git, svn, bzr).\n+func vcsByCmd(cmd string) *vcsCmd {\n+\tfor _, vcs := range vcsList {\n+\t\tif vcs.cmd == cmd {\n+\t\t\treturn vcs\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// vcsHg describes how to use Mercurial.\n+var vcsHg = &vcsCmd{\n+\tname: \"Mercurial\",\n+\tcmd:  \"hg\",\n+\n+\tcreateCmd:   \"clone -U {repo} {dir}\",\n+\tdownloadCmd: \"pull\",\n+\n+\t// We allow both tag and branch names as 'tags'\n+\t// for selecting a version.  This lets people have\n+\t// a go.release.r60 branch and a go1 branch\n+\t// and make changes in both, without constantly\n+\t// editing .hgtags.\n+\ttagCmd: []tagCmd{\n+\t\t{\"tags\", `^(\\S+)`},\n+\t\t{\"branches\", `^(\\S+)`},\n+\t},\n+\ttagSyncCmd:     \"update -r {tag}\",\n+\ttagSyncDefault: \"update default\",\n+\n+\tscheme:  []string{\"https\", \"http\", \"ssh\"},\n+\tpingCmd: \"identify {scheme}://{repo}\",\n+}\n+\n+// vcsGit describes how to use Git.\n+var vcsGit = &vcsCmd{\n+\tname: \"Git\",\n+\tcmd:  \"git\",\n+\n+\tcreateCmd:   \"clone {repo} {dir}\",\n+\tdownloadCmd: \"pull --ff-only\",\n+\n+\ttagCmd: []tagCmd{\n+\t\t// tags/xxx matches a git tag named xxx\n+\t\t// origin/xxx matches a git branch named xxx on the default remote repository\n+\t\t{\"show-ref\", `(?:tags|origin)/(\\S+)$`},\n+\t},\n+\ttagLookupCmd: []tagCmd{\n+\t\t{\"show-ref tags/{tag} origin/{tag}\", `((?:tags|origin)/\\S+)$`},\n+\t},\n+\ttagSyncCmd:     \"checkout {tag}\",\n+\ttagSyncDefault: \"checkout master\",\n+\n+\tscheme:  []string{\"git\", \"https\", \"http\", \"git+ssh\"},\n+\tpingCmd: \"ls-remote {scheme}://{repo}\",\n+}\n+\n+// vcsBzr describes how to use Bazaar.\n+var vcsBzr = &vcsCmd{\n+\tname: \"Bazaar\",\n+\tcmd:  \"bzr\",\n+\n+\tcreateCmd: \"branch {repo} {dir}\",\n+\n+\t// Without --overwrite bzr will not pull tags that changed.\n+\t// Replace by --overwrite-tags after http://pad.lv/681792 goes in.\n+\tdownloadCmd: \"pull --overwrite\",\n+\n+\ttagCmd:         []tagCmd{{\"tags\", `^(\\S+)`}},\n+\ttagSyncCmd:     \"update -r {tag}\",\n+\ttagSyncDefault: \"update -r revno:-1\",\n+\n+\tscheme:  []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n+\tpingCmd: \"info {scheme}://{repo}\",\n+}\n+\n+// vcsSvn describes how to use Subversion.\n+var vcsSvn = &vcsCmd{\n+\tname: \"Subversion\",\n+\tcmd:  \"svn\",\n+\n+\tcreateCmd:   \"checkout {repo} {dir}\",\n+\tdownloadCmd: \"update\",\n+\n+\t// There is no tag command in subversion.\n+\t// The branch information is all in the path names.\n+\n+\tscheme:  []string{\"https\", \"http\", \"svn\", \"svn+ssh\"},\n+\tpingCmd: \"info {scheme}://{repo}\",\n+}\n+\n+func (v *vcsCmd) String() string {\n+\treturn v.name\n+}\n+\n+// run runs the command line cmd in the given directory.\n+// keyval is a list of key, value pairs.  run expands\n+// instances of {key} in cmd into value, but only after\n+// splitting cmd into individual arguments.\n+// If an error occurs, run prints the command line and the\n+// command's combined stdout+stderr to standard error.\n+// Otherwise run discards the command's output.\n+func (v *vcsCmd) run(dir string, cmd string, keyval ...string) error {\n+\t_, err := v.run1(dir, cmd, keyval, true)\n+\treturn err\n+}\n+\n+// runVerboseOnly is like run but only generates error output to standard error in verbose mode.\n+func (v *vcsCmd) runVerboseOnly(dir string, cmd string, keyval ...string) error {\n+\t_, err := v.run1(dir, cmd, keyval, false)\n+\treturn err\n+}\n+\n+// runOutput is like run but returns the output of the command.\n+func (v *vcsCmd) runOutput(dir string, cmd string, keyval ...string) ([]byte, error) {\n+\treturn v.run1(dir, cmd, keyval, true)\n+}\n+\n+// run1 is the generalized implementation of run and runOutput.\n+func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([]byte, error) {\n+\tm := make(map[string]string)\n+\tfor i := 0; i < len(keyval); i += 2 {\n+\t\tm[keyval[i]] = keyval[i+1]\n+\t}\n+\targs := strings.Fields(cmdline)\n+\tfor i, arg := range args {\n+\t\targs[i] = expand(m, arg)\n+\t}\n+\n+\t_, err := exec.LookPath(v.cmd)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr,\n+\t\t\t\"go: missing %s command. See http://golang.org/s/gogetcmd\\n\",\n+\t\t\tv.name)\n+\t\treturn nil, err\n+\t}\n+\n+\tcmd := exec.Command(v.cmd, args...)\n+\tcmd.Dir = dir\n+\tcmd.Env = envForDir(cmd.Dir)\n+\tif buildX {\n+\t\tfmt.Printf(\"cd %s\\n\", dir)\n+\t\tfmt.Printf(\"%s %s\\n\", v.cmd, strings.Join(args, \" \"))\n+\t}\n+\tvar buf bytes.Buffer\n+\tcmd.Stdout = &buf\n+\tcmd.Stderr = &buf\n+\terr = cmd.Run()\n+\tout := buf.Bytes()\n+\tif err != nil {\n+\t\tif verbose || buildV {\n+\t\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s %s\\n\", dir, v.cmd, strings.Join(args, \" \"))\n+\t\t\tos.Stderr.Write(out)\n+\t\t}\n+\t\treturn nil, err\n+\t}\n+\treturn out, nil\n+}\n+\n+// ping pings to determine scheme to use.\n+func (v *vcsCmd) ping(scheme, repo string) error {\n+\treturn v.runVerboseOnly(\".\", v.pingCmd, \"scheme\", scheme, \"repo\", repo)\n+}\n+\n+// create creates a new copy of repo in dir.\n+// The parent of dir must exist; dir must not.\n+func (v *vcsCmd) create(dir, repo string) error {\n+\treturn v.run(\".\", v.createCmd, \"dir\", dir, \"repo\", repo)\n+}\n+\n+// download downloads any new changes for the repo in dir.\n+func (v *vcsCmd) download(dir string) error {\n+\tif err := v.fixDetachedHead(dir); err != nil {\n+\t\treturn err\n+\t}\n+\treturn v.run(dir, v.downloadCmd)\n+}\n+\n+// fixDetachedHead switches a Git repository in dir from a detached head to the master branch.\n+// Go versions before 1.2 downloaded Git repositories in an unfortunate way\n+// that resulted in the working tree state being on a detached head.\n+// That meant the repository was not usable for normal Git operations.\n+// Go 1.2 fixed that, but we can't pull into a detached head, so if this is\n+// a Git repository we check for being on a detached head and switch to the\n+// real branch, almost always called \"master\".\n+// TODO(dsymonds): Consider removing this for Go 1.3.\n+func (v *vcsCmd) fixDetachedHead(dir string) error {\n+\tif v != vcsGit {\n+\t\treturn nil\n+\t}\n+\n+\t// \"git symbolic-ref HEAD\" succeeds iff we are not on a detached head.\n+\tif err := v.runVerboseOnly(dir, \"symbolic-ref HEAD\"); err == nil {\n+\t\t// not on a detached head\n+\t\treturn nil\n+\t}\n+\tif buildV {\n+\t\tlog.Printf(\"%s on detached head; repairing\", dir)\n+\t}\n+\treturn v.run(dir, \"checkout master\")\n+}\n+\n+// tags returns the list of available tags for the repo in dir.\n+func (v *vcsCmd) tags(dir string) ([]string, error) {\n+\tvar tags []string\n+\tfor _, tc := range v.tagCmd {\n+\t\tout, err := v.runOutput(dir, tc.cmd)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tre := regexp.MustCompile(`(?m-s)` + tc.pattern)\n+\t\tfor _, m := range re.FindAllStringSubmatch(string(out), -1) {\n+\t\t\ttags = append(tags, m[1])\n+\t\t}\n+\t}\n+\treturn tags, nil\n+}\n+\n+// tagSync syncs the repo in dir to the named tag,\n+// which either is a tag returned by tags or is v.tagDefault.\n+func (v *vcsCmd) tagSync(dir, tag string) error {\n+\tif v.tagSyncCmd == \"\" {\n+\t\treturn nil\n+\t}\n+\tif tag != \"\" {\n+\t\tfor _, tc := range v.tagLookupCmd {\n+\t\t\tout, err := v.runOutput(dir, tc.cmd, \"tag\", tag)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tre := regexp.MustCompile(`(?m-s)` + tc.pattern)\n+\t\t\tm := re.FindStringSubmatch(string(out))\n+\t\t\tif len(m) > 1 {\n+\t\t\t\ttag = m[1]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif tag == \"\" && v.tagSyncDefault != \"\" {\n+\t\treturn v.run(dir, v.tagSyncDefault)\n+\t}\n+\treturn v.run(dir, v.tagSyncCmd, \"tag\", tag)\n+}\n+\n+// A vcsPath describes how to convert an import path into a\n+// version control system and repository name.\n+type vcsPath struct {\n+\tprefix string                              // prefix this description applies to\n+\tre     string                              // pattern for import path\n+\trepo   string                              // repository to use (expand with match of re)\n+\tvcs    string                              // version control system to use (expand with match of re)\n+\tcheck  func(match map[string]string) error // additional checks\n+\tping   bool                                // ping for scheme to use to download repo\n+\n+\tregexp *regexp.Regexp // cached compiled form of re\n+}\n+\n+// vcsForDir inspects dir and its parents to determine the\n+// version control system and code repository to use.\n+// On return, root is the import path\n+// corresponding to the root of the repository\n+// (thus root is a prefix of importPath).\n+func vcsForDir(p *Package) (vcs *vcsCmd, root string, err error) {\n+\t// Clean and double-check that dir is in (a subdirectory of) srcRoot.\n+\tdir := filepath.Clean(p.Dir)\n+\tsrcRoot := filepath.Clean(p.build.SrcRoot)\n+\tif len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {\n+\t\treturn nil, \"\", fmt.Errorf(\"directory %q is outside source root %q\", dir, srcRoot)\n+\t}\n+\n+\torigDir := dir\n+\tfor len(dir) > len(srcRoot) {\n+\t\tfor _, vcs := range vcsList {\n+\t\t\tif fi, err := os.Stat(filepath.Join(dir, \".\"+vcs.cmd)); err == nil && fi.IsDir() {\n+\t\t\t\treturn vcs, dir[len(srcRoot)+1:], nil\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Move to parent.\n+\t\tndir := filepath.Dir(dir)\n+\t\tif len(ndir) >= len(dir) {\n+\t\t\t// Shouldn't happen, but just in case, stop.\n+\t\t\tbreak\n+\t\t}\n+\t\tdir = ndir\n+\t}\n+\n+\treturn nil, \"\", fmt.Errorf(\"directory %q is not using a known version control system\", origDir)\n+}\n+\n+// repoRoot represents a version control system, a repo, and a root of\n+// where to put it on disk.\n+type repoRoot struct {\n+\tvcs *vcsCmd\n+\n+\t// repo is the repository URL, including scheme\n+\trepo string\n+\n+\t// root is the import path corresponding to the root of the\n+\t// repository\n+\troot string\n+}\n+\n+var httpPrefixRE = regexp.MustCompile(`^https?:`)\n+\n+// repoRootForImportPath analyzes importPath to determine the\n+// version control system, and code repository to use.\n+func repoRootForImportPath(importPath string) (*repoRoot, error) {\n+\trr, err := repoRootForImportPathStatic(importPath, \"\")\n+\tif err == errUnknownSite {\n+\t\trr, err = repoRootForImportDynamic(importPath)\n+\n+\t\t// repoRootForImportDynamic returns error detail\n+\t\t// that is irrelevant if the user didn't intend to use a\n+\t\t// dynamic import in the first place.\n+\t\t// Squelch it.\n+\t\tif err != nil {\n+\t\t\tif buildV {\n+\t\t\t\tlog.Printf(\"import %q: %v\", importPath, err)\n+\t\t\t}\n+\t\t\terr = fmt.Errorf(\"unrecognized import path %q\", importPath)\n+\t\t}\n+\t}\n+\n+\tif err == nil && strings.Contains(importPath, \"...\") && strings.Contains(rr.root, \"...\") {\n+\t\t// Do not allow wildcards in the repo root.\n+\t\trr = nil\n+\t\terr = fmt.Errorf(\"cannot expand ... in %q\", importPath)\n+\t}\n+\treturn rr, err\n+}\n+\n+var errUnknownSite = errors.New(\"dynamic lookup required to find mapping\")\n+\n+// repoRootForImportPathStatic attempts to map importPath to a\n+// repoRoot using the commonly-used VCS hosting sites in vcsPaths\n+// (github.com/user/dir), or from a fully-qualified importPath already\n+// containing its VCS type (foo.com/repo.git/dir)\n+//\n+// If scheme is non-empty, that scheme is forced.\n+func repoRootForImportPathStatic(importPath, scheme string) (*repoRoot, error) {\n+\t// A common error is to use https://packagepath because that's what\n+\t// hg and git require. Diagnose this helpfully.\n+\tif loc := httpPrefixRE.FindStringIndex(importPath); loc != nil {\n+\t\t// The importPath has been cleaned, so has only one slash. The pattern\n+\t\t// ignores the slashes; the error message puts them back on the RHS at least.\n+\t\treturn nil, fmt.Errorf(\"%q not allowed in import path\", importPath[loc[0]:loc[1]]+\"//\")\n+\t}\n+\tfor _, srv := range vcsPaths {\n+\t\tif !strings.HasPrefix(importPath, srv.prefix) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tm := srv.regexp.FindStringSubmatch(importPath)\n+\t\tif m == nil {\n+\t\t\tif srv.prefix != \"\" {\n+\t\t\t\treturn nil, fmt.Errorf(\"invalid %s import path %q\", srv.prefix, importPath)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Build map of named subexpression matches for expand.\n+\t\tmatch := map[string]string{\n+\t\t\t\"prefix\": srv.prefix,\n+\t\t\t\"import\": importPath,\n+\t\t}\n+\t\tfor i, name := range srv.regexp.SubexpNames() {\n+\t\t\tif name != \"\" && match[name] == \"\" {\n+\t\t\t\tmatch[name] = m[i]\n+\t\t\t}\n+\t\t}\n+\t\tif srv.vcs != \"\" {\n+\t\t\tmatch[\"vcs\"] = expand(match, srv.vcs)\n+\t\t}\n+\t\tif srv.repo != \"\" {\n+\t\t\tmatch[\"repo\"] = expand(match, srv.repo)\n+\t\t}\n+\t\tif srv.check != nil {\n+\t\t\tif err := srv.check(match); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t\tvcs := vcsByCmd(match[\"vcs\"])\n+\t\tif vcs == nil {\n+\t\t\treturn nil, fmt.Errorf(\"unknown version control system %q\", match[\"vcs\"])\n+\t\t}\n+\t\tif srv.ping {\n+\t\t\tif scheme != \"\" {\n+\t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n+\t\t\t} else {\n+\t\t\t\tfor _, scheme := range vcs.scheme {\n+\t\t\t\t\tif vcs.ping(scheme, match[\"repo\"]) == nil {\n+\t\t\t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\trr := &repoRoot{\n+\t\t\tvcs:  vcs,\n+\t\t\trepo: match[\"repo\"],\n+\t\t\troot: match[\"root\"],\n+\t\t}\n+\t\treturn rr, nil\n+\t}\n+\treturn nil, errUnknownSite\n+}\n+\n+// repoRootForImportDynamic finds a *repoRoot for a custom domain that's not\n+// statically known by repoRootForImportPathStatic.\n+//\n+// This handles \"vanity import paths\" like \"name.tld/pkg/foo\".\n+func repoRootForImportDynamic(importPath string) (*repoRoot, error) {\n+\tslash := strings.Index(importPath, \"/\")\n+\tif slash < 0 {\n+\t\treturn nil, errors.New(\"import path doesn't contain a slash\")\n+\t}\n+\thost := importPath[:slash]\n+\tif !strings.Contains(host, \".\") {\n+\t\treturn nil, errors.New(\"import path doesn't contain a hostname\")\n+\t}\n+\turlStr, body, err := httpsOrHTTP(importPath)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"http/https fetch: %v\", err)\n+\t}\n+\tdefer body.Close()\n+\timports, err := parseMetaGoImports(body)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", importPath, err)\n+\t}\n+\tmetaImport, err := matchGoImport(imports, importPath)\n+\tif err != nil {\n+\t\tif err != errNoMatch {\n+\t\t\treturn nil, fmt.Errorf(\"parse %s: %v\", urlStr, err)\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags\", urlStr)\n+\t}\n+\tif buildV {\n+\t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, metaImport, urlStr)\n+\t}\n+\t// If the import was \"uni.edu/bob/project\", which said the\n+\t// prefix was \"uni.edu\" and the RepoRoot was \"evilroot.com\",\n+\t// make sure we don't trust Bob and check out evilroot.com to\n+\t// \"uni.edu\" yet (possibly overwriting/preempting another\n+\t// non-evil student).  Instead, first verify the root and see\n+\t// if it matches Bob's claim.\n+\tif metaImport.Prefix != importPath {\n+\t\tif buildV {\n+\t\t\tlog.Printf(\"get %q: verifying non-authoritative meta tag\", importPath)\n+\t\t}\n+\t\turlStr0 := urlStr\n+\t\turlStr, body, err = httpsOrHTTP(metaImport.Prefix)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"fetch %s: %v\", urlStr, err)\n+\t\t}\n+\t\timports, err := parseMetaGoImports(body)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", importPath, err)\n+\t\t}\n+\t\tif len(imports) == 0 {\n+\t\t\treturn nil, fmt.Errorf(\"fetch %s: no go-import meta tag\", urlStr)\n+\t\t}\n+\t\tmetaImport2, err := matchGoImport(imports, importPath)\n+\t\tif err != nil || metaImport != metaImport2 {\n+\t\t\treturn nil, fmt.Errorf(\"%s and %s disagree about go-import for %s\", urlStr0, urlStr, metaImport.Prefix)\n+\t\t}\n+\t}\n+\n+\tif !strings.Contains(metaImport.RepoRoot, \"://\") {\n+\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q; no scheme\", urlStr, metaImport.RepoRoot)\n+\t}\n+\trr := &repoRoot{\n+\t\tvcs:  vcsByCmd(metaImport.VCS),\n+\t\trepo: metaImport.RepoRoot,\n+\t\troot: metaImport.Prefix,\n+\t}\n+\tif rr.vcs == nil {\n+\t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", urlStr, metaImport.VCS)\n+\t}\n+\treturn rr, nil\n+}\n+\n+// metaImport represents the parsed <meta name=\"go-import\"\n+// content=\"prefix vcs reporoot\" /> tags from HTML files.\n+type metaImport struct {\n+\tPrefix, VCS, RepoRoot string\n+}\n+\n+// errNoMatch is returned from matchGoImport when there's no applicable match.\n+var errNoMatch = errors.New(\"no import match\")\n+\n+// matchGoImport returns the metaImport from imports matching importPath.\n+// An error is returned if there are multiple matches.\n+// errNoMatch is returned if none match.\n+func matchGoImport(imports []metaImport, importPath string) (_ metaImport, err error) {\n+\tmatch := -1\n+\tfor i, im := range imports {\n+\t\tif !strings.HasPrefix(importPath, im.Prefix) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif match != -1 {\n+\t\t\terr = fmt.Errorf(\"multiple meta tags match import path %q\", importPath)\n+\t\t\treturn\n+\t\t}\n+\t\tmatch = i\n+\t}\n+\tif match == -1 {\n+\t\terr = errNoMatch\n+\t\treturn\n+\t}\n+\treturn imports[match], nil\n+}\n+\n+// expand rewrites s to replace {k} with match[k] for each key k in match.\n+func expand(match map[string]string, s string) string {\n+\tfor k, v := range match {\n+\t\ts = strings.Replace(s, \"{\"+k+\"}\", v, -1)\n+\t}\n+\treturn s\n+}\n+\n+// vcsPaths lists the known vcs paths.\n+var vcsPaths = []*vcsPath{\n+\t// Google Code - new syntax\n+\t{\n+\t\tprefix: \"code.google.com/\",\n+\t\tre:     `^(?P<root>code\\.google\\.com/p/(?P<project>[a-z0-9\\-]+)(\\.(?P<subrepo>[a-z0-9\\-]+))?)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\trepo:   \"https://{root}\",\n+\t\tcheck:  googleCodeVCS,\n+\t},\n+\n+\t// Google Code - old syntax\n+\t{\n+\t\tre:    `^(?P<project>[a-z0-9_\\-.]+)\\.googlecode\\.com/(git|hg|svn)(?P<path>/.*)?$`,\n+\t\tcheck: oldGoogleCode,\n+\t},\n+\n+\t// Github\n+\t{\n+\t\tprefix: \"github.com/\",\n+\t\tre:     `^(?P<root>github\\.com/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tvcs:    \"git\",\n+\t\trepo:   \"https://{root}\",\n+\t\tcheck:  noVCSSuffix,\n+\t},\n+\n+\t// Bitbucket\n+\t{\n+\t\tprefix: \"bitbucket.org/\",\n+\t\tre:     `^(?P<root>bitbucket\\.org/(?P<bitname>[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\trepo:   \"https://{root}\",\n+\t\tcheck:  bitbucketVCS,\n+\t},\n+\n+\t// Launchpad\n+\t{\n+\t\tprefix: \"launchpad.net/\",\n+\t\tre:     `^(?P<root>launchpad\\.net/((?P<project>[A-Za-z0-9_.\\-]+)(?P<series>/[A-Za-z0-9_.\\-]+)?|~[A-Za-z0-9_.\\-]+/(\\+junk|[A-Za-z0-9_.\\-]+)/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tvcs:    \"bzr\",\n+\t\trepo:   \"https://{root}\",\n+\t\tcheck:  launchpadVCS,\n+\t},\n+\n+\t// General syntax for any server.\n+\t{\n+\t\tre:   `^(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?/[A-Za-z0-9_.\\-/]*?)\\.(?P<vcs>bzr|git|hg|svn))(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tping: true,\n+\t},\n+}\n+\n+func init() {\n+\t// fill in cached regexps.\n+\t// Doing this eagerly discovers invalid regexp syntax\n+\t// without having to run a command that needs that regexp.\n+\tfor _, srv := range vcsPaths {\n+\t\tsrv.regexp = regexp.MustCompile(srv.re)\n+\t}\n+}\n+\n+// noVCSSuffix checks that the repository name does not\n+// end in .foo for any version control system foo.\n+// The usual culprit is \".git\".\n+func noVCSSuffix(match map[string]string) error {\n+\trepo := match[\"repo\"]\n+\tfor _, vcs := range vcsList {\n+\t\tif strings.HasSuffix(repo, \".\"+vcs.cmd) {\n+\t\t\treturn fmt.Errorf(\"invalid version control suffix in %s path\", match[\"prefix\"])\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+var googleCheckout = regexp.MustCompile(`id=\"checkoutcmd\">(hg|git|svn)`)\n+\n+// googleCodeVCS determines the version control system for\n+// a code.google.com repository, by scraping the project's\n+// /source/checkout page.\n+func googleCodeVCS(match map[string]string) error {\n+\tif err := noVCSSuffix(match); err != nil {\n+\t\treturn err\n+\t}\n+\tdata, err := httpGET(expand(match, \"https://code.google.com/p/{project}/source/checkout?repo={subrepo}\"))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif m := googleCheckout.FindSubmatch(data); m != nil {\n+\t\tif vcs := vcsByCmd(string(m[1])); vcs != nil {\n+\t\t\t// Subversion requires the old URLs.\n+\t\t\t// TODO: Test.\n+\t\t\tif vcs == vcsSvn {\n+\t\t\t\tif match[\"subrepo\"] != \"\" {\n+\t\t\t\t\treturn fmt.Errorf(\"sub-repositories not supported in Google Code Subversion projects\")\n+\t\t\t\t}\n+\t\t\t\tmatch[\"repo\"] = expand(match, \"https://{project}.googlecode.com/svn\")\n+\t\t\t}\n+\t\t\tmatch[\"vcs\"] = vcs.cmd\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\treturn fmt.Errorf(\"unable to detect version control system for code.google.com/ path\")\n+}\n+\n+// oldGoogleCode is invoked for old-style foo.googlecode.com paths.\n+// It prints an error giving the equivalent new path.\n+func oldGoogleCode(match map[string]string) error {\n+\treturn fmt.Errorf(\"invalid Google Code import path: use %s instead\",\n+\t\texpand(match, \"code.google.com/p/{project}{path}\"))\n+}\n+\n+// bitbucketVCS determines the version control system for a\n+// Bitbucket repository, by using the Bitbucket API.\n+func bitbucketVCS(match map[string]string) error {\n+\tif err := noVCSSuffix(match); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar resp struct {\n+\t\tSCM string `json:\"scm\"`\n+\t}\n+\turl := expand(match, \"https://api.bitbucket.org/1.0/repositories/{bitname}\")\n+\tdata, err := httpGET(url)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif err := json.Unmarshal(data, &resp); err != nil {\n+\t\treturn fmt.Errorf(\"decoding %s: %v\", url, err)\n+\t}\n+\n+\tif vcsByCmd(resp.SCM) != nil {\n+\t\tmatch[\"vcs\"] = resp.SCM\n+\t\tif resp.SCM == \"git\" {\n+\t\t\tmatch[\"repo\"] += \".git\"\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\treturn fmt.Errorf(\"unable to detect version control system for bitbucket.org/ path\")\n+}\n+\n+// launchpadVCS solves the ambiguity for \"lp.net/project/foo\". In this case,\n+// \"foo\" could be a series name registered in Launchpad with its own branch,\n+// and it could also be the name of a directory within the main project\n+// branch one level up.\n+func launchpadVCS(match map[string]string) error {\n+\tif match[\"project\"] == \"\" || match[\"series\"] == \"\" {\n+\t\treturn nil\n+\t}\n+\t_, err := httpGET(expand(match, \"https://code.launchpad.net/{project}{series}/.bzr/branch-format\"))\n+\tif err != nil {\n+\t\tmatch[\"root\"] = expand(match, \"launchpad.net/{project}\")\n+\t\tmatch[\"repo\"] = expand(match, \"https://{root}\")\n+\t}\n+\treturn nil\n+}"}, {"sha": "a41f4a7361546d1067cf076697f82a68178b30e2", "filename": "libgo/go/cmd/go/version.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fversion.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"runtime\"\n+)\n+\n+var cmdVersion = &Command{\n+\tRun:       runVersion,\n+\tUsageLine: \"version\",\n+\tShort:     \"print Go version\",\n+\tLong:      `Version prints the Go version, as reported by runtime.Version.`,\n+}\n+\n+func runVersion(cmd *Command, args []string) {\n+\tif len(args) != 0 {\n+\t\tcmd.Usage()\n+\t}\n+\n+\tfmt.Printf(\"go version %s %s/%s\\n\", runtime.Version(), runtime.GOOS, runtime.GOARCH)\n+}"}, {"sha": "ffb4318373bcc374d971b4235b0bf0e8fc8066ef", "filename": "libgo/go/cmd/go/vet.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+func init() {\n+\taddBuildFlagsNX(cmdVet)\n+}\n+\n+var cmdVet = &Command{\n+\tRun:       runVet,\n+\tUsageLine: \"vet [-n] [-x] [packages]\",\n+\tShort:     \"run go tool vet on packages\",\n+\tLong: `\n+Vet runs the Go vet command on the packages named by the import paths.\n+\n+For more about vet, see 'godoc code.google.com/p/go.tools/cmd/vet'.\n+For more about specifying packages, see 'go help packages'.\n+\n+To run the vet tool with specific options, run 'go tool vet'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+See also: go fmt, go fix.\n+\t`,\n+}\n+\n+func runVet(cmd *Command, args []string) {\n+\tfor _, pkg := range packages(args) {\n+\t\t// Use pkg.gofiles instead of pkg.Dir so that\n+\t\t// the command only applies to this package,\n+\t\t// not to packages in subdirectories.\n+\t\trun(tool(\"vet\"), relPaths(stringList(pkg.gofiles, pkg.sfiles)))\n+\t}\n+}"}, {"sha": "8f73ef5b9ddd57574f7088ca7dfb01cc296ad177", "filename": "libgo/go/cmd/gofmt/doc.go", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Gofmt formats Go programs.\n+It uses tabs (width = 8) for indentation and blanks for alignment.\n+\n+Without an explicit path, it processes the standard input.  Given a file,\n+it operates on that file; given a directory, it operates on all .go files in\n+that directory, recursively.  (Files starting with a period are ignored.)\n+By default, gofmt prints the reformatted sources to standard output.\n+\n+Usage:\n+\tgofmt [flags] [path ...]\n+\n+The flags are:\n+\t-d\n+\t\tDo not print reformatted sources to standard output.\n+\t\tIf a file's formatting is different than gofmt's, print diffs\n+\t\tto standard output.\n+\t-e\n+\t\tPrint all (including spurious) errors.\n+\t-l\n+\t\tDo not print reformatted sources to standard output.\n+\t\tIf a file's formatting is different from gofmt's, print its name\n+\t\tto standard output.\n+\t-r rule\n+\t\tApply the rewrite rule to the source before reformatting.\n+\t-s\n+\t\tTry to simplify code (after applying the rewrite rule, if any).\n+\t-w\n+\t\tDo not print reformatted sources to standard output.\n+\t\tIf a file's formatting is different from gofmt's, overwrite it\n+\t\twith gofmt's version.\n+\n+Debugging support:\n+\t-cpuprofile filename\n+\t\tWrite cpu profile to the specified file.\n+\n+\n+The rewrite rule specified with the -r flag must be a string of the form:\n+\n+\tpattern -> replacement\n+\n+Both pattern and replacement must be valid Go expressions.\n+In the pattern, single-character lowercase identifiers serve as\n+wildcards matching arbitrary sub-expressions; those expressions\n+will be substituted for the same identifiers in the replacement.\n+\n+When gofmt reads from standard input, it accepts either a full Go program\n+or a program fragment.  A program fragment must be a syntactically\n+valid declaration list, statement list, or expression.  When formatting\n+such a fragment, gofmt preserves leading indentation as well as leading\n+and trailing spaces, so that individual sections of a Go program can be\n+formatted by piping them through gofmt.\n+\n+Examples\n+\n+To check files for unnecessary parentheses:\n+\n+\tgofmt -r '(a) -> a' -l *.go\n+\n+To remove the parentheses:\n+\n+\tgofmt -r '(a) -> a' -w *.go\n+\n+To convert the package tree from explicit slice upper bounds to implicit ones:\n+\n+\tgofmt -r '\u03b1[\u03b2:len(\u03b1)] -> \u03b1[\u03b2:]' -w $GOROOT/src/pkg\n+\n+The simplify command\n+\n+When invoked with -s gofmt will make the following source transformations where possible.\n+\n+\tAn array, slice, or map composite literal of the form:\n+\t\t[]T{T{}, T{}}\n+\twill be simplified to:\n+\t\t[]T{{}, {}}\n+\n+\tA slice expression of the form:\n+\t\ts[a:len(s)]\n+\twill be simplified to:\n+\t\ts[a:]\n+\n+\tA range of the form:\n+\t\tfor x, _ = range v {...}\n+\twill be simplified to:\n+\t\tfor x = range v {...}\n+*/\n+package main\n+\n+// BUG(rsc): The implementation of -r is a bit slow."}, {"sha": "576cae5228e8dd6db916d7f3792283f5dc973736", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,344 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/printer\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime/pprof\"\n+\t\"strings\"\n+)\n+\n+var (\n+\t// main operation modes\n+\tlist        = flag.Bool(\"l\", false, \"list files whose formatting differs from gofmt's\")\n+\twrite       = flag.Bool(\"w\", false, \"write result to (source) file instead of stdout\")\n+\trewriteRule = flag.String(\"r\", \"\", \"rewrite rule (e.g., 'a[b:len(a)] -> a[b:]')\")\n+\tsimplifyAST = flag.Bool(\"s\", false, \"simplify code\")\n+\tdoDiff      = flag.Bool(\"d\", false, \"display diffs instead of rewriting files\")\n+\tallErrors   = flag.Bool(\"e\", false, \"report all errors (not just the first 10 on different lines)\")\n+\n+\t// debugging\n+\tcpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to this file\")\n+)\n+\n+const (\n+\ttabWidth    = 8\n+\tprinterMode = printer.UseSpaces | printer.TabIndent\n+)\n+\n+var (\n+\tfileSet    = token.NewFileSet() // per process FileSet\n+\texitCode   = 0\n+\trewrite    func(*ast.File) *ast.File\n+\tparserMode parser.Mode\n+)\n+\n+func report(err error) {\n+\tscanner.PrintError(os.Stderr, err)\n+\texitCode = 2\n+}\n+\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: gofmt [flags] [path ...]\\n\")\n+\tflag.PrintDefaults()\n+\tos.Exit(2)\n+}\n+\n+func initParserMode() {\n+\tparserMode = parser.ParseComments\n+\tif *allErrors {\n+\t\tparserMode |= parser.AllErrors\n+\t}\n+}\n+\n+func isGoFile(f os.FileInfo) bool {\n+\t// ignore non-Go files\n+\tname := f.Name()\n+\treturn !f.IsDir() && !strings.HasPrefix(name, \".\") && strings.HasSuffix(name, \".go\")\n+}\n+\n+// If in == nil, the source is the contents of the file with the given filename.\n+func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error {\n+\tif in == nil {\n+\t\tf, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tin = f\n+\t}\n+\n+\tsrc, err := ioutil.ReadAll(in)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfile, adjust, err := parse(fileSet, filename, src, stdin)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif rewrite != nil {\n+\t\tif adjust == nil {\n+\t\t\tfile = rewrite(file)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(os.Stderr, \"warning: rewrite ignored for incomplete programs\\n\")\n+\t\t}\n+\t}\n+\n+\tast.SortImports(fileSet, file)\n+\n+\tif *simplifyAST {\n+\t\tsimplify(file)\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\terr = (&printer.Config{Mode: printerMode, Tabwidth: tabWidth}).Fprint(&buf, fileSet, file)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tres := buf.Bytes()\n+\tif adjust != nil {\n+\t\tres = adjust(src, res)\n+\t}\n+\n+\tif !bytes.Equal(src, res) {\n+\t\t// formatting has changed\n+\t\tif *list {\n+\t\t\tfmt.Fprintln(out, filename)\n+\t\t}\n+\t\tif *write {\n+\t\t\terr = ioutil.WriteFile(filename, res, 0)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\tif *doDiff {\n+\t\t\tdata, err := diff(src, res)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"computing diff: %s\", err)\n+\t\t\t}\n+\t\t\tfmt.Printf(\"diff %s gofmt/%s\\n\", filename, filename)\n+\t\t\tout.Write(data)\n+\t\t}\n+\t}\n+\n+\tif !*list && !*write && !*doDiff {\n+\t\t_, err = out.Write(res)\n+\t}\n+\n+\treturn err\n+}\n+\n+func visitFile(path string, f os.FileInfo, err error) error {\n+\tif err == nil && isGoFile(f) {\n+\t\terr = processFile(path, nil, os.Stdout, false)\n+\t}\n+\tif err != nil {\n+\t\treport(err)\n+\t}\n+\treturn nil\n+}\n+\n+func walkDir(path string) {\n+\tfilepath.Walk(path, visitFile)\n+}\n+\n+func main() {\n+\t// call gofmtMain in a separate function\n+\t// so that it can use defer and have them\n+\t// run before the exit.\n+\tgofmtMain()\n+\tos.Exit(exitCode)\n+}\n+\n+func gofmtMain() {\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\n+\tif *cpuprofile != \"\" {\n+\t\tf, err := os.Create(*cpuprofile)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"creating cpu profile: %s\\n\", err)\n+\t\t\texitCode = 2\n+\t\t\treturn\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tpprof.StartCPUProfile(f)\n+\t\tdefer pprof.StopCPUProfile()\n+\t}\n+\n+\tinitParserMode()\n+\tinitRewrite()\n+\n+\tif flag.NArg() == 0 {\n+\t\tif err := processFile(\"<standard input>\", os.Stdin, os.Stdout, true); err != nil {\n+\t\t\treport(err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tfor i := 0; i < flag.NArg(); i++ {\n+\t\tpath := flag.Arg(i)\n+\t\tswitch dir, err := os.Stat(path); {\n+\t\tcase err != nil:\n+\t\t\treport(err)\n+\t\tcase dir.IsDir():\n+\t\t\twalkDir(path)\n+\t\tdefault:\n+\t\t\tif err := processFile(path, nil, os.Stdout, false); err != nil {\n+\t\t\t\treport(err)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func diff(b1, b2 []byte) (data []byte, err error) {\n+\tf1, err := ioutil.TempFile(\"\", \"gofmt\")\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer os.Remove(f1.Name())\n+\tdefer f1.Close()\n+\n+\tf2, err := ioutil.TempFile(\"\", \"gofmt\")\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer os.Remove(f2.Name())\n+\tdefer f2.Close()\n+\n+\tf1.Write(b1)\n+\tf2.Write(b2)\n+\n+\tdata, err = exec.Command(\"diff\", \"-u\", f1.Name(), f2.Name()).CombinedOutput()\n+\tif len(data) > 0 {\n+\t\t// diff exits with a non-zero status when the files don't match.\n+\t\t// Ignore that failure as long as we get output.\n+\t\terr = nil\n+\t}\n+\treturn\n+\n+}\n+\n+// parse parses src, which was read from filename,\n+// as a Go source file or statement list.\n+func parse(fset *token.FileSet, filename string, src []byte, stdin bool) (*ast.File, func(orig, src []byte) []byte, error) {\n+\t// Try as whole source file.\n+\tfile, err := parser.ParseFile(fset, filename, src, parserMode)\n+\tif err == nil {\n+\t\treturn file, nil, nil\n+\t}\n+\t// If the error is that the source file didn't begin with a\n+\t// package line and this is standard input, fall through to\n+\t// try as a source fragment.  Stop and return on any other error.\n+\tif !stdin || !strings.Contains(err.Error(), \"expected 'package'\") {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\t// If this is a declaration list, make it a source file\n+\t// by inserting a package clause.\n+\t// Insert using a ;, not a newline, so that the line numbers\n+\t// in psrc match the ones in src.\n+\tpsrc := append([]byte(\"package p;\"), src...)\n+\tfile, err = parser.ParseFile(fset, filename, psrc, parserMode)\n+\tif err == nil {\n+\t\tadjust := func(orig, src []byte) []byte {\n+\t\t\t// Remove the package clause.\n+\t\t\t// Gofmt has turned the ; into a \\n.\n+\t\t\tsrc = src[len(\"package p\\n\"):]\n+\t\t\treturn matchSpace(orig, src)\n+\t\t}\n+\t\treturn file, adjust, nil\n+\t}\n+\t// If the error is that the source file didn't begin with a\n+\t// declaration, fall through to try as a statement list.\n+\t// Stop and return on any other error.\n+\tif !strings.Contains(err.Error(), \"expected declaration\") {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\t// If this is a statement list, make it a source file\n+\t// by inserting a package clause and turning the list\n+\t// into a function body.  This handles expressions too.\n+\t// Insert using a ;, not a newline, so that the line numbers\n+\t// in fsrc match the ones in src.\n+\tfsrc := append(append([]byte(\"package p; func _() {\"), src...), '}')\n+\tfile, err = parser.ParseFile(fset, filename, fsrc, parserMode)\n+\tif err == nil {\n+\t\tadjust := func(orig, src []byte) []byte {\n+\t\t\t// Remove the wrapping.\n+\t\t\t// Gofmt has turned the ; into a \\n\\n.\n+\t\t\tsrc = src[len(\"package p\\n\\nfunc _() {\"):]\n+\t\t\tsrc = src[:len(src)-len(\"}\\n\")]\n+\t\t\t// Gofmt has also indented the function body one level.\n+\t\t\t// Remove that indent.\n+\t\t\tsrc = bytes.Replace(src, []byte(\"\\n\\t\"), []byte(\"\\n\"), -1)\n+\t\t\treturn matchSpace(orig, src)\n+\t\t}\n+\t\treturn file, adjust, nil\n+\t}\n+\n+\t// Failed, and out of options.\n+\treturn nil, nil, err\n+}\n+\n+func cutSpace(b []byte) (before, middle, after []byte) {\n+\ti := 0\n+\tfor i < len(b) && (b[i] == ' ' || b[i] == '\\t' || b[i] == '\\n') {\n+\t\ti++\n+\t}\n+\tj := len(b)\n+\tfor j > 0 && (b[j-1] == ' ' || b[j-1] == '\\t' || b[j-1] == '\\n') {\n+\t\tj--\n+\t}\n+\tif i <= j {\n+\t\treturn b[:i], b[i:j], b[j:]\n+\t}\n+\treturn nil, nil, b[j:]\n+}\n+\n+// matchSpace reformats src to use the same space context as orig.\n+// 1) If orig begins with blank lines, matchSpace inserts them at the beginning of src.\n+// 2) matchSpace copies the indentation of the first non-blank line in orig\n+//    to every non-blank line in src.\n+// 3) matchSpace copies the trailing space from orig and uses it in place\n+//   of src's trailing space.\n+func matchSpace(orig []byte, src []byte) []byte {\n+\tbefore, _, after := cutSpace(orig)\n+\ti := bytes.LastIndex(before, []byte{'\\n'})\n+\tbefore, indent := before[:i+1], before[i+1:]\n+\n+\t_, src, _ = cutSpace(src)\n+\n+\tvar b bytes.Buffer\n+\tb.Write(before)\n+\tfor len(src) > 0 {\n+\t\tline := src\n+\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n+\t\t\tline, src = line[:i+1], line[i+1:]\n+\t\t} else {\n+\t\t\tsrc = nil\n+\t\t}\n+\t\tif len(line) > 0 && line[0] != '\\n' { // not blank\n+\t\t\tb.Write(indent)\n+\t\t}\n+\t\tb.Write(line)\n+\t}\n+\tb.Write(after)\n+\treturn b.Bytes()\n+}"}, {"sha": "b9335b8f3db8f61636fd905026b7fad0da5aedaa", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func runTest(t *testing.T, in, out, flags string) {\n+\t// process flags\n+\t*simplifyAST = false\n+\t*rewriteRule = \"\"\n+\tstdin := false\n+\tfor _, flag := range strings.Split(flags, \" \") {\n+\t\telts := strings.SplitN(flag, \"=\", 2)\n+\t\tname := elts[0]\n+\t\tvalue := \"\"\n+\t\tif len(elts) == 2 {\n+\t\t\tvalue = elts[1]\n+\t\t}\n+\t\tswitch name {\n+\t\tcase \"\":\n+\t\t\t// no flags\n+\t\tcase \"-r\":\n+\t\t\t*rewriteRule = value\n+\t\tcase \"-s\":\n+\t\t\t*simplifyAST = true\n+\t\tcase \"-stdin\":\n+\t\t\t// fake flag - pretend input is from stdin\n+\t\t\tstdin = true\n+\t\tdefault:\n+\t\t\tt.Errorf(\"unrecognized flag name: %s\", name)\n+\t\t}\n+\t}\n+\n+\tinitParserMode()\n+\tinitRewrite()\n+\n+\tvar buf bytes.Buffer\n+\terr := processFile(in, nil, &buf, stdin)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\texpected, err := ioutil.ReadFile(out)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tif got := buf.Bytes(); !bytes.Equal(got, expected) {\n+\t\tt.Errorf(\"(gofmt %s) != %s (see %s.gofmt)\", in, out, in)\n+\t\td, err := diff(expected, got)\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"%s\", d)\n+\t\t}\n+\t\tif err := ioutil.WriteFile(in+\".gofmt\", got, 0666); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t}\n+}\n+\n+var tests = []struct {\n+\tin, flags string\n+}{\n+\t{\"gofmt.go\", \"\"},\n+\t{\"gofmt_test.go\", \"\"},\n+\t{\"testdata/composites.input\", \"-s\"},\n+\t{\"testdata/slices1.input\", \"-s\"},\n+\t{\"testdata/slices2.input\", \"-s\"},\n+\t{\"testdata/old.input\", \"\"},\n+\t{\"testdata/rewrite1.input\", \"-r=Foo->Bar\"},\n+\t{\"testdata/rewrite2.input\", \"-r=int->bool\"},\n+\t{\"testdata/rewrite3.input\", \"-r=x->x\"},\n+\t{\"testdata/rewrite4.input\", \"-r=(x)->x\"},\n+\t{\"testdata/rewrite5.input\", \"-r=x+x->2*x\"},\n+\t{\"testdata/rewrite6.input\", \"-r=fun(x)->Fun(x)\"},\n+\t{\"testdata/rewrite7.input\", \"-r=fun(x...)->Fun(x)\"},\n+\t{\"testdata/rewrite8.input\", \"-r=interface{}->int\"},\n+\t{\"testdata/stdin*.input\", \"-stdin\"},\n+\t{\"testdata/comments.input\", \"\"},\n+\t{\"testdata/import.input\", \"\"},\n+\t{\"testdata/crlf.input\", \"\"},       // test case for issue 3961; see also TestCRLF\n+\t{\"testdata/typeswitch.input\", \"\"}, // test case for issue 4470\n+}\n+\n+func TestRewrite(t *testing.T) {\n+\tfor _, test := range tests {\n+\t\tmatch, err := filepath.Glob(test.in)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, in := range match {\n+\t\t\tout := in\n+\t\t\tif strings.HasSuffix(in, \".input\") {\n+\t\t\t\tout = in[:len(in)-len(\".input\")] + \".golden\"\n+\t\t\t}\n+\t\t\trunTest(t, in, out, test.flags)\n+\t\t\tif in != out {\n+\t\t\t\t// Check idempotence.\n+\t\t\t\trunTest(t, out, out, test.flags)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestCRLF(t *testing.T) {\n+\tconst input = \"testdata/crlf.input\"   // must contain CR/LF's\n+\tconst golden = \"testdata/crlf.golden\" // must not contain any CR's\n+\n+\tdata, err := ioutil.ReadFile(input)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif bytes.Index(data, []byte(\"\\r\\n\")) < 0 {\n+\t\tt.Errorf(\"%s contains no CR/LF's\", input)\n+\t}\n+\n+\tdata, err = ioutil.ReadFile(golden)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif bytes.Index(data, []byte(\"\\r\")) >= 0 {\n+\t\tt.Errorf(\"%s contains CR's\", golden)\n+\t}\n+}"}, {"sha": "108278b3369d42c05fa5e166b51e73a1217e9dc6", "filename": "libgo/go/cmd/gofmt/long_test.go", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Flong_test.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This test applies gofmt to all Go files under -root.\n+// To test specific files provide a list of comma-separated\n+// filenames via the -files flag: go test -files=gofmt.go .\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/printer\"\n+\t\"go/token\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var (\n+\troot    = flag.String(\"root\", runtime.GOROOT(), \"test root directory\")\n+\tfiles   = flag.String(\"files\", \"\", \"comma-separated list of files to test\")\n+\tngo     = flag.Int(\"n\", runtime.NumCPU(), \"number of goroutines used\")\n+\tverbose = flag.Bool(\"verbose\", false, \"verbose mode\")\n+\tnfiles  int // number of files processed\n+)\n+\n+func gofmt(fset *token.FileSet, filename string, src *bytes.Buffer) error {\n+\tf, _, err := parse(fset, filename, src.Bytes(), false)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tast.SortImports(fset, f)\n+\tsrc.Reset()\n+\treturn (&printer.Config{Mode: printerMode, Tabwidth: tabWidth}).Fprint(src, fset, f)\n+}\n+\n+func testFile(t *testing.T, b1, b2 *bytes.Buffer, filename string) {\n+\t// open file\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\t// read file\n+\tb1.Reset()\n+\t_, err = io.Copy(b1, f)\n+\tf.Close()\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\t// exclude files w/ syntax errors (typically test cases)\n+\tfset := token.NewFileSet()\n+\tif _, _, err = parse(fset, filename, b1.Bytes(), false); err != nil {\n+\t\tif *verbose {\n+\t\t\tfmt.Fprintf(os.Stderr, \"ignoring %s\\n\", err)\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\t// gofmt file\n+\tif err = gofmt(fset, filename, b1); err != nil {\n+\t\tt.Errorf(\"1st gofmt failed: %v\", err)\n+\t\treturn\n+\t}\n+\n+\t// make a copy of the result\n+\tb2.Reset()\n+\tb2.Write(b1.Bytes())\n+\n+\t// gofmt result again\n+\tif err = gofmt(fset, filename, b2); err != nil {\n+\t\tt.Errorf(\"2nd gofmt failed: %v\", err)\n+\t\treturn\n+\t}\n+\n+\t// the first and 2nd result should be identical\n+\tif !bytes.Equal(b1.Bytes(), b2.Bytes()) {\n+\t\tt.Errorf(\"gofmt %s not idempotent\", filename)\n+\t}\n+}\n+\n+func testFiles(t *testing.T, filenames <-chan string, done chan<- int) {\n+\tb1 := new(bytes.Buffer)\n+\tb2 := new(bytes.Buffer)\n+\tfor filename := range filenames {\n+\t\ttestFile(t, b1, b2, filename)\n+\t}\n+\tdone <- 0\n+}\n+\n+func genFilenames(t *testing.T, filenames chan<- string) {\n+\tdefer close(filenames)\n+\n+\thandleFile := func(filename string, fi os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tif isGoFile(fi) {\n+\t\t\tfilenames <- filename\n+\t\t\tnfiles++\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\t// test Go files provided via -files, if any\n+\tif *files != \"\" {\n+\t\tfor _, filename := range strings.Split(*files, \",\") {\n+\t\t\tfi, err := os.Stat(filename)\n+\t\t\thandleFile(filename, fi, err)\n+\t\t}\n+\t\treturn // ignore files under -root\n+\t}\n+\n+\t// otherwise, test all Go files under *root\n+\tfilepath.Walk(*root, handleFile)\n+}\n+\n+func TestAll(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\tif *ngo < 1 {\n+\t\t*ngo = 1 // make sure test is run\n+\t}\n+\tif *verbose {\n+\t\tfmt.Printf(\"running test using %d goroutines\\n\", *ngo)\n+\t}\n+\n+\t// generate filenames\n+\tfilenames := make(chan string, 32)\n+\tgo genFilenames(t, filenames)\n+\n+\t// launch test goroutines\n+\tdone := make(chan int)\n+\tfor i := 0; i < *ngo; i++ {\n+\t\tgo testFiles(t, filenames, done)\n+\t}\n+\n+\t// wait for all test goroutines to complete\n+\tfor i := 0; i < *ngo; i++ {\n+\t\t<-done\n+\t}\n+\n+\tif *verbose {\n+\t\tfmt.Printf(\"processed %d files\\n\", nfiles)\n+\t}\n+}"}, {"sha": "fb6c6fc811af3b98b3397a8bba29c8b8cb5ad515", "filename": "libgo/go/cmd/gofmt/rewrite.go", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,306 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+func initRewrite() {\n+\tif *rewriteRule == \"\" {\n+\t\trewrite = nil // disable any previous rewrite\n+\t\treturn\n+\t}\n+\tf := strings.Split(*rewriteRule, \"->\")\n+\tif len(f) != 2 {\n+\t\tfmt.Fprintf(os.Stderr, \"rewrite rule must be of the form 'pattern -> replacement'\\n\")\n+\t\tos.Exit(2)\n+\t}\n+\tpattern := parseExpr(f[0], \"pattern\")\n+\treplace := parseExpr(f[1], \"replacement\")\n+\trewrite = func(p *ast.File) *ast.File { return rewriteFile(pattern, replace, p) }\n+}\n+\n+// parseExpr parses s as an expression.\n+// It might make sense to expand this to allow statement patterns,\n+// but there are problems with preserving formatting and also\n+// with what a wildcard for a statement looks like.\n+func parseExpr(s, what string) ast.Expr {\n+\tx, err := parser.ParseExpr(s)\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"parsing %s %s at %s\\n\", what, s, err)\n+\t\tos.Exit(2)\n+\t}\n+\treturn x\n+}\n+\n+// Keep this function for debugging.\n+/*\n+func dump(msg string, val reflect.Value) {\n+\tfmt.Printf(\"%s:\\n\", msg)\n+\tast.Print(fileSet, val.Interface())\n+\tfmt.Println()\n+}\n+*/\n+\n+// rewriteFile applies the rewrite rule 'pattern -> replace' to an entire file.\n+func rewriteFile(pattern, replace ast.Expr, p *ast.File) *ast.File {\n+\tcmap := ast.NewCommentMap(fileSet, p, p.Comments)\n+\tm := make(map[string]reflect.Value)\n+\tpat := reflect.ValueOf(pattern)\n+\trepl := reflect.ValueOf(replace)\n+\n+\tvar rewriteVal func(val reflect.Value) reflect.Value\n+\trewriteVal = func(val reflect.Value) reflect.Value {\n+\t\t// don't bother if val is invalid to start with\n+\t\tif !val.IsValid() {\n+\t\t\treturn reflect.Value{}\n+\t\t}\n+\t\tfor k := range m {\n+\t\t\tdelete(m, k)\n+\t\t}\n+\t\tval = apply(rewriteVal, val)\n+\t\tif match(m, pat, val) {\n+\t\t\tval = subst(m, repl, reflect.ValueOf(val.Interface().(ast.Node).Pos()))\n+\t\t}\n+\t\treturn val\n+\t}\n+\n+\tr := apply(rewriteVal, reflect.ValueOf(p)).Interface().(*ast.File)\n+\tr.Comments = cmap.Filter(r).Comments() // recreate comments list\n+\treturn r\n+}\n+\n+// set is a wrapper for x.Set(y); it protects the caller from panics if x cannot be changed to y.\n+func set(x, y reflect.Value) {\n+\t// don't bother if x cannot be set or y is invalid\n+\tif !x.CanSet() || !y.IsValid() {\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tif x := recover(); x != nil {\n+\t\t\tif s, ok := x.(string); ok &&\n+\t\t\t\t(strings.Contains(s, \"type mismatch\") || strings.Contains(s, \"not assignable\")) {\n+\t\t\t\t// x cannot be set to y - ignore this rewrite\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tpanic(x)\n+\t\t}\n+\t}()\n+\tx.Set(y)\n+}\n+\n+// Values/types for special cases.\n+var (\n+\tobjectPtrNil = reflect.ValueOf((*ast.Object)(nil))\n+\tscopePtrNil  = reflect.ValueOf((*ast.Scope)(nil))\n+\n+\tidentType     = reflect.TypeOf((*ast.Ident)(nil))\n+\tobjectPtrType = reflect.TypeOf((*ast.Object)(nil))\n+\tpositionType  = reflect.TypeOf(token.NoPos)\n+\tcallExprType  = reflect.TypeOf((*ast.CallExpr)(nil))\n+\tscopePtrType  = reflect.TypeOf((*ast.Scope)(nil))\n+)\n+\n+// apply replaces each AST field x in val with f(x), returning val.\n+// To avoid extra conversions, f operates on the reflect.Value form.\n+func apply(f func(reflect.Value) reflect.Value, val reflect.Value) reflect.Value {\n+\tif !val.IsValid() {\n+\t\treturn reflect.Value{}\n+\t}\n+\n+\t// *ast.Objects introduce cycles and are likely incorrect after\n+\t// rewrite; don't follow them but replace with nil instead\n+\tif val.Type() == objectPtrType {\n+\t\treturn objectPtrNil\n+\t}\n+\n+\t// similarly for scopes: they are likely incorrect after a rewrite;\n+\t// replace them with nil\n+\tif val.Type() == scopePtrType {\n+\t\treturn scopePtrNil\n+\t}\n+\n+\tswitch v := reflect.Indirect(val); v.Kind() {\n+\tcase reflect.Slice:\n+\t\tfor i := 0; i < v.Len(); i++ {\n+\t\t\te := v.Index(i)\n+\t\t\tset(e, f(e))\n+\t\t}\n+\tcase reflect.Struct:\n+\t\tfor i := 0; i < v.NumField(); i++ {\n+\t\t\te := v.Field(i)\n+\t\t\tset(e, f(e))\n+\t\t}\n+\tcase reflect.Interface:\n+\t\te := v.Elem()\n+\t\tset(v, f(e))\n+\t}\n+\treturn val\n+}\n+\n+func isWildcard(s string) bool {\n+\trune, size := utf8.DecodeRuneInString(s)\n+\treturn size == len(s) && unicode.IsLower(rune)\n+}\n+\n+// match returns true if pattern matches val,\n+// recording wildcard submatches in m.\n+// If m == nil, match checks whether pattern == val.\n+func match(m map[string]reflect.Value, pattern, val reflect.Value) bool {\n+\t// Wildcard matches any expression.  If it appears multiple\n+\t// times in the pattern, it must match the same expression\n+\t// each time.\n+\tif m != nil && pattern.IsValid() && pattern.Type() == identType {\n+\t\tname := pattern.Interface().(*ast.Ident).Name\n+\t\tif isWildcard(name) && val.IsValid() {\n+\t\t\t// wildcards only match valid (non-nil) expressions.\n+\t\t\tif _, ok := val.Interface().(ast.Expr); ok && !val.IsNil() {\n+\t\t\t\tif old, ok := m[name]; ok {\n+\t\t\t\t\treturn match(nil, old, val)\n+\t\t\t\t}\n+\t\t\t\tm[name] = val\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Otherwise, pattern and val must match recursively.\n+\tif !pattern.IsValid() || !val.IsValid() {\n+\t\treturn !pattern.IsValid() && !val.IsValid()\n+\t}\n+\tif pattern.Type() != val.Type() {\n+\t\treturn false\n+\t}\n+\n+\t// Special cases.\n+\tswitch pattern.Type() {\n+\tcase identType:\n+\t\t// For identifiers, only the names need to match\n+\t\t// (and none of the other *ast.Object information).\n+\t\t// This is a common case, handle it all here instead\n+\t\t// of recursing down any further via reflection.\n+\t\tp := pattern.Interface().(*ast.Ident)\n+\t\tv := val.Interface().(*ast.Ident)\n+\t\treturn p == nil && v == nil || p != nil && v != nil && p.Name == v.Name\n+\tcase objectPtrType, positionType:\n+\t\t// object pointers and token positions always match\n+\t\treturn true\n+\tcase callExprType:\n+\t\t// For calls, the Ellipsis fields (token.Position) must\n+\t\t// match since that is how f(x) and f(x...) are different.\n+\t\t// Check them here but fall through for the remaining fields.\n+\t\tp := pattern.Interface().(*ast.CallExpr)\n+\t\tv := val.Interface().(*ast.CallExpr)\n+\t\tif p.Ellipsis.IsValid() != v.Ellipsis.IsValid() {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tp := reflect.Indirect(pattern)\n+\tv := reflect.Indirect(val)\n+\tif !p.IsValid() || !v.IsValid() {\n+\t\treturn !p.IsValid() && !v.IsValid()\n+\t}\n+\n+\tswitch p.Kind() {\n+\tcase reflect.Slice:\n+\t\tif p.Len() != v.Len() {\n+\t\t\treturn false\n+\t\t}\n+\t\tfor i := 0; i < p.Len(); i++ {\n+\t\t\tif !match(m, p.Index(i), v.Index(i)) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\n+\tcase reflect.Struct:\n+\t\tif p.NumField() != v.NumField() {\n+\t\t\treturn false\n+\t\t}\n+\t\tfor i := 0; i < p.NumField(); i++ {\n+\t\t\tif !match(m, p.Field(i), v.Field(i)) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\n+\tcase reflect.Interface:\n+\t\treturn match(m, p.Elem(), v.Elem())\n+\t}\n+\n+\t// Handle token integers, etc.\n+\treturn p.Interface() == v.Interface()\n+}\n+\n+// subst returns a copy of pattern with values from m substituted in place\n+// of wildcards and pos used as the position of tokens from the pattern.\n+// if m == nil, subst returns a copy of pattern and doesn't change the line\n+// number information.\n+func subst(m map[string]reflect.Value, pattern reflect.Value, pos reflect.Value) reflect.Value {\n+\tif !pattern.IsValid() {\n+\t\treturn reflect.Value{}\n+\t}\n+\n+\t// Wildcard gets replaced with map value.\n+\tif m != nil && pattern.Type() == identType {\n+\t\tname := pattern.Interface().(*ast.Ident).Name\n+\t\tif isWildcard(name) {\n+\t\t\tif old, ok := m[name]; ok {\n+\t\t\t\treturn subst(nil, old, reflect.Value{})\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif pos.IsValid() && pattern.Type() == positionType {\n+\t\t// use new position only if old position was valid in the first place\n+\t\tif old := pattern.Interface().(token.Pos); !old.IsValid() {\n+\t\t\treturn pattern\n+\t\t}\n+\t\treturn pos\n+\t}\n+\n+\t// Otherwise copy.\n+\tswitch p := pattern; p.Kind() {\n+\tcase reflect.Slice:\n+\t\tv := reflect.MakeSlice(p.Type(), p.Len(), p.Len())\n+\t\tfor i := 0; i < p.Len(); i++ {\n+\t\t\tv.Index(i).Set(subst(m, p.Index(i), pos))\n+\t\t}\n+\t\treturn v\n+\n+\tcase reflect.Struct:\n+\t\tv := reflect.New(p.Type()).Elem()\n+\t\tfor i := 0; i < p.NumField(); i++ {\n+\t\t\tv.Field(i).Set(subst(m, p.Field(i), pos))\n+\t\t}\n+\t\treturn v\n+\n+\tcase reflect.Ptr:\n+\t\tv := reflect.New(p.Type()).Elem()\n+\t\tif elem := p.Elem(); elem.IsValid() {\n+\t\t\tv.Set(subst(m, elem, pos).Addr())\n+\t\t}\n+\t\treturn v\n+\n+\tcase reflect.Interface:\n+\t\tv := reflect.New(p.Type()).Elem()\n+\t\tif elem := p.Elem(); elem.IsValid() {\n+\t\t\tv.Set(subst(m, elem, pos))\n+\t\t}\n+\t\treturn v\n+\t}\n+\n+\treturn pattern\n+}"}, {"sha": "45d000d675e8cdbccf155d4351765b20698cc1ff", "filename": "libgo/go/cmd/gofmt/simplify.go", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fsimplify.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"go/ast\"\n+\t\"go/token\"\n+\t\"reflect\"\n+)\n+\n+type simplifier struct {\n+\thasDotImport bool // package file contains: import . \"some/import/path\"\n+}\n+\n+func (s *simplifier) Visit(node ast.Node) ast.Visitor {\n+\tswitch n := node.(type) {\n+\tcase *ast.CompositeLit:\n+\t\t// array, slice, and map composite literals may be simplified\n+\t\touter := n\n+\t\tvar eltType ast.Expr\n+\t\tswitch typ := outer.Type.(type) {\n+\t\tcase *ast.ArrayType:\n+\t\t\teltType = typ.Elt\n+\t\tcase *ast.MapType:\n+\t\t\teltType = typ.Value\n+\t\t}\n+\n+\t\tif eltType != nil {\n+\t\t\ttyp := reflect.ValueOf(eltType)\n+\t\t\tfor i, x := range outer.Elts {\n+\t\t\t\tpx := &outer.Elts[i]\n+\t\t\t\t// look at value of indexed/named elements\n+\t\t\t\tif t, ok := x.(*ast.KeyValueExpr); ok {\n+\t\t\t\t\tx = t.Value\n+\t\t\t\t\tpx = &t.Value\n+\t\t\t\t}\n+\t\t\t\tast.Walk(s, x) // simplify x\n+\t\t\t\t// if the element is a composite literal and its literal type\n+\t\t\t\t// matches the outer literal's element type exactly, the inner\n+\t\t\t\t// literal type may be omitted\n+\t\t\t\tif inner, ok := x.(*ast.CompositeLit); ok {\n+\t\t\t\t\tif match(nil, typ, reflect.ValueOf(inner.Type)) {\n+\t\t\t\t\t\tinner.Type = nil\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// if the outer literal's element type is a pointer type *T\n+\t\t\t\t// and the element is & of a composite literal of type T,\n+\t\t\t\t// the inner &T may be omitted.\n+\t\t\t\tif ptr, ok := eltType.(*ast.StarExpr); ok {\n+\t\t\t\t\tif addr, ok := x.(*ast.UnaryExpr); ok && addr.Op == token.AND {\n+\t\t\t\t\t\tif inner, ok := addr.X.(*ast.CompositeLit); ok {\n+\t\t\t\t\t\t\tif match(nil, reflect.ValueOf(ptr.X), reflect.ValueOf(inner.Type)) {\n+\t\t\t\t\t\t\t\tinner.Type = nil // drop T\n+\t\t\t\t\t\t\t\t*px = inner      // drop &\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// node was simplified - stop walk (there are no subnodes to simplify)\n+\t\t\treturn nil\n+\t\t}\n+\n+\tcase *ast.SliceExpr:\n+\t\t// a slice expression of the form: s[a:len(s)]\n+\t\t// can be simplified to: s[a:]\n+\t\t// if s is \"simple enough\" (for now we only accept identifiers)\n+\t\tif s.hasDotImport {\n+\t\t\t// if dot imports are present, we cannot be certain that an\n+\t\t\t// unresolved \"len\" identifier refers to the predefined len()\n+\t\t\tbreak\n+\t\t}\n+\t\tif s, _ := n.X.(*ast.Ident); s != nil && s.Obj != nil {\n+\t\t\t// the array/slice object is a single, resolved identifier\n+\t\t\tif call, _ := n.High.(*ast.CallExpr); call != nil && len(call.Args) == 1 && !call.Ellipsis.IsValid() {\n+\t\t\t\t// the high expression is a function call with a single argument\n+\t\t\t\tif fun, _ := call.Fun.(*ast.Ident); fun != nil && fun.Name == \"len\" && fun.Obj == nil {\n+\t\t\t\t\t// the function called is \"len\" and it is not locally defined; and\n+\t\t\t\t\t// because we don't have dot imports, it must be the predefined len()\n+\t\t\t\t\tif arg, _ := call.Args[0].(*ast.Ident); arg != nil && arg.Obj == s.Obj {\n+\t\t\t\t\t\t// the len argument is the array/slice object\n+\t\t\t\t\t\tn.High = nil\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// Note: We could also simplify slice expressions of the form s[0:b] to s[:b]\n+\t\t//       but we leave them as is since sometimes we want to be very explicit\n+\t\t//       about the lower bound.\n+\t\t// An example where the 0 helps:\n+\t\t//       x, y, z := b[0:2], b[2:4], b[4:6]\n+\t\t// An example where it does not:\n+\t\t//       x, y := b[:n], b[n:]\n+\n+\tcase *ast.RangeStmt:\n+\t\t// a range of the form: for x, _ = range v {...}\n+\t\t// can be simplified to: for x = range v {...}\n+\t\tif ident, _ := n.Value.(*ast.Ident); ident != nil && ident.Name == \"_\" {\n+\t\t\tn.Value = nil\n+\t\t}\n+\t}\n+\n+\treturn s\n+}\n+\n+func simplify(f *ast.File) {\n+\tvar s simplifier\n+\n+\t// determine if f contains dot imports\n+\tfor _, imp := range f.Imports {\n+\t\tif imp.Name != nil && imp.Name.Name == \".\" {\n+\t\t\ts.hasDotImport = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tast.Walk(&s, f)\n+}"}, {"sha": "ad6bcafafa2382a02bd9c83fbc8c7ed61773f318", "filename": "libgo/go/cmd/gofmt/testdata/comments.golden", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomments.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,9 @@\n+package main\n+\n+func main() {}\n+\n+// comment here\n+\n+func f() {}\n+\n+//line foo.go:1"}, {"sha": "ad6bcafafa2382a02bd9c83fbc8c7ed61773f318", "filename": "libgo/go/cmd/gofmt/testdata/comments.input", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomments.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,9 @@\n+package main\n+\n+func main() {}\n+\n+// comment here\n+\n+func f() {}\n+\n+//line foo.go:1"}, {"sha": "b2825e732aa516d1612e6d95270206c79c40f8bd", "filename": "libgo/go/cmd/gofmt/testdata/composites.golden", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,202 @@\n+package P\n+\n+type T struct {\n+\tx, y int\n+}\n+\n+var _ = [42]T{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = [...]T{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = []T{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = []T{\n+\t{},\n+\t10: {1, 2},\n+\t20: {3, 4},\n+}\n+\n+var _ = []struct {\n+\tx, y int\n+}{\n+\t{},\n+\t10: {1, 2},\n+\t20: {3, 4},\n+}\n+\n+var _ = []interface{}{\n+\tT{},\n+\t10: T{1, 2},\n+\t20: T{3, 4},\n+}\n+\n+var _ = [][]int{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = [][]int{\n+\t([]int{}),\n+\t([]int{1, 2}),\n+\t{3, 4},\n+}\n+\n+var _ = [][][]int{\n+\t{},\n+\t{\n+\t\t{},\n+\t\t{0, 1, 2, 3},\n+\t\t{4, 5},\n+\t},\n+}\n+\n+var _ = map[string]T{\n+\t\"foo\": {},\n+\t\"bar\": {1, 2},\n+\t\"bal\": {3, 4},\n+}\n+\n+var _ = map[string]struct {\n+\tx, y int\n+}{\n+\t\"foo\": {},\n+\t\"bar\": {1, 2},\n+\t\"bal\": {3, 4},\n+}\n+\n+var _ = map[string]interface{}{\n+\t\"foo\": T{},\n+\t\"bar\": T{1, 2},\n+\t\"bal\": T{3, 4},\n+}\n+\n+var _ = map[string][]int{\n+\t\"foo\": {},\n+\t\"bar\": {1, 2},\n+\t\"bal\": {3, 4},\n+}\n+\n+var _ = map[string][]int{\n+\t\"foo\": ([]int{}),\n+\t\"bar\": ([]int{1, 2}),\n+\t\"bal\": {3, 4},\n+}\n+\n+// from exp/4s/data.go\n+var pieces4 = []Piece{\n+\t{0, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n+\t{1, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n+\t{2, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n+\t{3, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n+}\n+\n+var _ = [42]*T{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = [...]*T{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = []*T{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = []*T{\n+\t{},\n+\t10: {1, 2},\n+\t20: {3, 4},\n+}\n+\n+var _ = []*struct {\n+\tx, y int\n+}{\n+\t{},\n+\t10: {1, 2},\n+\t20: {3, 4},\n+}\n+\n+var _ = []interface{}{\n+\t&T{},\n+\t10: &T{1, 2},\n+\t20: &T{3, 4},\n+}\n+\n+var _ = []*[]int{\n+\t{},\n+\t{1, 2},\n+\t{3, 4},\n+}\n+\n+var _ = []*[]int{\n+\t(&[]int{}),\n+\t(&[]int{1, 2}),\n+\t{3, 4},\n+}\n+\n+var _ = []*[]*[]int{\n+\t{},\n+\t{\n+\t\t{},\n+\t\t{0, 1, 2, 3},\n+\t\t{4, 5},\n+\t},\n+}\n+\n+var _ = map[string]*T{\n+\t\"foo\": {},\n+\t\"bar\": {1, 2},\n+\t\"bal\": {3, 4},\n+}\n+\n+var _ = map[string]*struct {\n+\tx, y int\n+}{\n+\t\"foo\": {},\n+\t\"bar\": {1, 2},\n+\t\"bal\": {3, 4},\n+}\n+\n+var _ = map[string]interface{}{\n+\t\"foo\": &T{},\n+\t\"bar\": &T{1, 2},\n+\t\"bal\": &T{3, 4},\n+}\n+\n+var _ = map[string]*[]int{\n+\t\"foo\": {},\n+\t\"bar\": {1, 2},\n+\t\"bal\": {3, 4},\n+}\n+\n+var _ = map[string]*[]int{\n+\t\"foo\": (&[]int{}),\n+\t\"bar\": (&[]int{1, 2}),\n+\t\"bal\": {3, 4},\n+}\n+\n+var pieces4 = []*Piece{\n+\t{0, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n+\t{1, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n+\t{2, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},\n+\t{3, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},\n+}"}, {"sha": "7210dafc96c1820371efffa9c2e3e5d6e3d6330b", "filename": "libgo/go/cmd/gofmt/testdata/composites.input", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcomposites.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,202 @@\n+package P\n+\n+type T struct {\n+\tx, y int\n+}\n+\n+var _ = [42]T{\n+\tT{},\n+\tT{1, 2},\n+\tT{3, 4},\n+}\n+\n+var _ = [...]T{\n+\tT{},\n+\tT{1, 2},\n+\tT{3, 4},\n+}\n+\n+var _ = []T{\n+\tT{},\n+\tT{1, 2},\n+\tT{3, 4},\n+}\n+\n+var _ = []T{\n+\tT{},\n+\t10: T{1, 2},\n+\t20: T{3, 4},\n+}\n+\n+var _ = []struct {\n+\tx, y int\n+}{\n+\tstruct{ x, y int }{},\n+\t10: struct{ x, y int }{1, 2},\n+\t20: struct{ x, y int }{3, 4},\n+}\n+\n+var _ = []interface{}{\n+\tT{},\n+\t10: T{1, 2},\n+\t20: T{3, 4},\n+}\n+\n+var _ = [][]int{\n+\t[]int{},\n+\t[]int{1, 2},\n+\t[]int{3, 4},\n+}\n+\n+var _ = [][]int{\n+\t([]int{}),\n+\t([]int{1, 2}),\n+\t[]int{3, 4},\n+}\n+\n+var _ = [][][]int{\n+\t[][]int{},\n+\t[][]int{\n+\t\t[]int{},\n+\t\t[]int{0, 1, 2, 3},\n+\t\t[]int{4, 5},\n+\t},\n+}\n+\n+var _ = map[string]T{\n+\t\"foo\": T{},\n+\t\"bar\": T{1, 2},\n+\t\"bal\": T{3, 4},\n+}\n+\n+var _ = map[string]struct {\n+\tx, y int\n+}{\n+\t\"foo\": struct{ x, y int }{},\n+\t\"bar\": struct{ x, y int }{1, 2},\n+\t\"bal\": struct{ x, y int }{3, 4},\n+}\n+\n+var _ = map[string]interface{}{\n+\t\"foo\": T{},\n+\t\"bar\": T{1, 2},\n+\t\"bal\": T{3, 4},\n+}\n+\n+var _ = map[string][]int{\n+\t\"foo\": []int{},\n+\t\"bar\": []int{1, 2},\n+\t\"bal\": []int{3, 4},\n+}\n+\n+var _ = map[string][]int{\n+\t\"foo\": ([]int{}),\n+\t\"bar\": ([]int{1, 2}),\n+\t\"bal\": []int{3, 4},\n+}\n+\n+// from exp/4s/data.go\n+var pieces4 = []Piece{\n+\tPiece{0, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},\n+\tPiece{1, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},\n+\tPiece{2, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},\n+\tPiece{3, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},\n+}\n+\n+var _ = [42]*T{\n+\t&T{},\n+\t&T{1, 2},\n+\t&T{3, 4},\n+}\n+\n+var _ = [...]*T{\n+\t&T{},\n+\t&T{1, 2},\n+\t&T{3, 4},\n+}\n+\n+var _ = []*T{\n+\t&T{},\n+\t&T{1, 2},\n+\t&T{3, 4},\n+}\n+\n+var _ = []*T{\n+\t&T{},\n+\t10: &T{1, 2},\n+\t20: &T{3, 4},\n+}\n+\n+var _ = []*struct {\n+\tx, y int\n+}{\n+\t&struct{ x, y int }{},\n+\t10: &struct{ x, y int }{1, 2},\n+\t20: &struct{ x, y int }{3, 4},\n+}\n+\n+var _ = []interface{}{\n+\t&T{},\n+\t10: &T{1, 2},\n+\t20: &T{3, 4},\n+}\n+\n+var _ = []*[]int{\n+\t&[]int{},\n+\t&[]int{1, 2},\n+\t&[]int{3, 4},\n+}\n+\n+var _ = []*[]int{\n+\t(&[]int{}),\n+\t(&[]int{1, 2}),\n+\t&[]int{3, 4},\n+}\n+\n+var _ = []*[]*[]int{\n+\t&[]*[]int{},\n+\t&[]*[]int{\n+\t\t&[]int{},\n+\t\t&[]int{0, 1, 2, 3},\n+\t\t&[]int{4, 5},\n+\t},\n+}\n+\n+var _ = map[string]*T{\n+\t\"foo\": &T{},\n+\t\"bar\": &T{1, 2},\n+\t\"bal\": &T{3, 4},\n+}\n+\n+var _ = map[string]*struct {\n+\tx, y int\n+}{\n+\t\"foo\": &struct{ x, y int }{},\n+\t\"bar\": &struct{ x, y int }{1, 2},\n+\t\"bal\": &struct{ x, y int }{3, 4},\n+}\n+\n+var _ = map[string]interface{}{\n+\t\"foo\": &T{},\n+\t\"bar\": &T{1, 2},\n+\t\"bal\": &T{3, 4},\n+}\n+\n+var _ = map[string]*[]int{\n+\t\"foo\": &[]int{},\n+\t\"bar\": &[]int{1, 2},\n+\t\"bal\": &[]int{3, 4},\n+}\n+\n+var _ = map[string]*[]int{\n+\t\"foo\": (&[]int{}),\n+\t\"bar\": (&[]int{1, 2}),\n+\t\"bal\": &[]int{3, 4},\n+}\n+\n+var pieces4 = []*Piece{\n+\t&Piece{0, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},\n+\t&Piece{1, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},\n+\t&Piece{2, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},\n+\t&Piece{3, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},\n+}"}, {"sha": "57679f770fe2b3b2f9415c043efe4c281737c377", "filename": "libgo/go/cmd/gofmt/testdata/crlf.golden", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+/*\n+\tSource containing CR/LF line endings.\n+\tThe gofmt'ed output must only have LF\n+\tline endings.\n+*/\n+package main\n+\n+func main() {\n+\t// line comment\n+\tprintln(\"hello, world!\") // another line comment\n+\tprintln()\n+}"}, {"sha": "61a1aa0b4ee7e1a0e32dd98cc9893e099e896abe", "filename": "libgo/go/cmd/gofmt/testdata/crlf.input", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fcrlf.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+/*\r\n+\tSource containing CR/LF line endings.\r\n+\tThe gofmt'ed output must only have LF\r\n+\tline endings.\r\n+*/\r\n+package main\r\n+\r\n+func main() {\r\n+\t// line comment\r\n+\tprintln(\"hello, world!\") // another line comment\r\n+\tprintln()\r\n+}\r"}, {"sha": "51d7be79dfab7aea7bec5c32fd02b6fdefebafec", "filename": "libgo/go/cmd/gofmt/testdata/import.golden", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,126 @@\n+package main\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"math\"\n+)\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"math\"\n+\n+\t\"log\"\n+\n+\t\"errors\"\n+\n+\t\"io\"\n+)\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"math\"\n+\n+\t\"fmt\"\n+\n+\t\"math\"\n+\n+\t\"log\"\n+\n+\t\"errors\"\n+\n+\t\"io\"\n+)\n+\n+import (\n+\t// a block with comments\n+\t\"errors\"\n+\t\"fmt\" // for Printf\n+\t\"io\"  // for Reader\n+\t\"log\" // for Fatal\n+\t\"math\"\n+)\n+\n+import (\n+\t\"fmt\" // for Printf\n+\n+\t\"math\"\n+\n+\t\"log\" // for Fatal\n+\n+\t\"errors\"\n+\n+\t\"io\" // for Reader\n+)\n+\n+import (\n+\t// for Printf\n+\t\"fmt\"\n+\n+\t\"math\"\n+\n+\t// for Fatal\n+\t\"log\"\n+\n+\t\"errors\"\n+\n+\t// for Reader\n+\t\"io\"\n+)\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\" // for Printf\n+\t\"io\"  // for Reader\n+\t\"log\" // for Fatal\n+\t\"math\"\n+\n+\t\"fmt\" // for Printf\n+\n+\t\"math\"\n+\n+\t\"log\" // for Fatal\n+\n+\t\"errors\"\n+\n+\t\"io\" // for Reader\n+)\n+\n+import (\n+\t\"fmt\" // for Printf\n+\n+\t\"errors\"\n+\t\"io\"  // for Reader\n+\t\"log\" // for Fatal\n+\t\"math\"\n+\n+\t\"errors\"\n+\t\"fmt\" // for Printf\n+\t\"io\"  // for Reader\n+\t\"log\" // for Fatal\n+\t\"math\"\n+)\n+\n+// Test deduping and extended sorting\n+import (\n+\ta \"A\" // aA\n+\tb \"A\" // bA1\n+\tb \"A\" // bA2\n+\t\"B\"   // B\n+\t. \"B\" // .B\n+\t_ \"B\" // _b\n+\t\"C\"\n+\ta \"D\" // aD\n+)\n+\n+import (\n+\t\"dedup_by_group\"\n+\n+\t\"dedup_by_group\"\n+)"}, {"sha": "9a4b09dbf9108ca8cd642e122a340887dee79b46", "filename": "libgo/go/cmd/gofmt/testdata/import.input", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,131 @@\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"log\"\n+\t\"errors\"\n+\t\"io\"\n+)\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"math\"\n+\n+\t\"log\"\n+\n+\t\"errors\"\n+\n+\t\"io\"\n+)\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"log\"\n+\t\"errors\"\n+\t\"io\"\n+\n+\t\"fmt\"\n+\n+\t\"math\"\n+\n+\t\"log\"\n+\n+\t\"errors\"\n+\n+\t\"io\"\n+)\n+\n+import (\n+\t// a block with comments\n+\t\"fmt\" // for Printf\n+\t\"math\"\n+\t\"log\" // for Fatal\n+\t\"errors\"\n+\t\"io\" // for Reader\n+)\n+\n+import (\n+\t\"fmt\" // for Printf\n+\n+\t\"math\"\n+\n+\t\"log\" // for Fatal\n+\n+\t\"errors\"\n+\n+\t\"io\" // for Reader\n+)\n+\n+import (\n+\t// for Printf\n+\t\"fmt\"\n+\n+\t\"math\"\n+\n+\t// for Fatal\n+\t\"log\"\n+\n+\t\"errors\"\n+\n+\t// for Reader\n+\t\"io\"\n+)\n+\n+import (\n+\t\"fmt\" // for Printf\n+\t\"math\"\n+\t\"log\" // for Fatal\n+\t\"errors\"\n+\t\"io\" // for Reader\n+\n+\t\"fmt\" // for Printf\n+\n+\t\"math\"\n+\n+\t\"log\" // for Fatal\n+\n+\t\"errors\"\n+\n+\t\"io\" // for Reader\n+)\n+\n+import (\n+\t\"fmt\" // for Printf\n+\n+\t\"math\"\n+\t\"log\" // for Fatal\n+\t\"errors\"\n+\t\"io\" // for Reader\n+\n+\t\"fmt\" // for Printf\n+\t\"math\"\n+\t\"log\" // for Fatal\n+\t\"errors\"\n+\t\"io\" // for Reader\n+)\n+\n+// Test deduping and extended sorting\n+import (\n+\t\"B\" // B\n+\ta \"A\" // aA\n+\tb \"A\" // bA2\n+\tb \"A\" // bA1\n+\t. \"B\" // .B\n+\t. \"B\"\n+\t\"C\"\n+\t\"C\"\n+\t\"C\"\n+\ta \"D\" // aD\n+\t\"B\"\n+\t_ \"B\" // _b\n+)\n+\n+import (\n+\t\"dedup_by_group\"\n+\t\"dedup_by_group\"\n+\n+\t\"dedup_by_group\"\n+)"}, {"sha": "95a0b72a0e09926bf1d29adef13eed603c3fca66", "filename": "libgo/go/cmd/gofmt/testdata/old.golden", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fold.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fold.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fold.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,9 @@\n+package P\n+\n+func f() {\n+\tif x {\n+\t\ty\n+\t} else {\n+\t\tz\n+\t}\n+}"}, {"sha": "e24eed215d3b868fc8b7bdbb71c543ad69589fed", "filename": "libgo/go/cmd/gofmt/testdata/old.input", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fold.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fold.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fold.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,8 @@\n+package P\n+\n+func f() {\n+\tif x {\n+\t\ty\n+\t} else\n+\t\tz\n+}"}, {"sha": "d9beb370582c9eb7a392447312f5873886183814", "filename": "libgo/go/cmd/gofmt/testdata/rewrite1.golden", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+type Bar int\n+\n+func main() {\n+\tvar a Bar\n+\tprintln(a)\n+}"}, {"sha": "bdb894320d37f26417707e82873d94b0b859a34a", "filename": "libgo/go/cmd/gofmt/testdata/rewrite1.input", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite1.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+type Foo int\n+\n+func main() {\n+\tvar a Foo\n+\tprintln(a)\n+}"}, {"sha": "64c67ffa67b460e05e8ba31014fdf26df79613d9", "filename": "libgo/go/cmd/gofmt/testdata/rewrite2.golden", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+// Slices have nil Len values in the corresponding ast.ArrayType\n+// node and reflect.NewValue(slice.Len) is an invalid reflect.Value.\n+// The rewriter must not crash in that case. Was issue 1696.\n+func f() []bool {}"}, {"sha": "21171447a10fd7ccb4c0710cf789d665de0b33bb", "filename": "libgo/go/cmd/gofmt/testdata/rewrite2.input", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite2.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+// Slices have nil Len values in the corresponding ast.ArrayType\n+// node and reflect.NewValue(slice.Len) is an invalid reflect.Value.\n+// The rewriter must not crash in that case. Was issue 1696.\n+func f() []int {}"}, {"sha": "0d16d16011be2687128966552db1eb1f7446d46b", "filename": "libgo/go/cmd/gofmt/testdata/rewrite3.golden", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Field tags are *ast.BasicLit nodes that are nil when the tag is\n+// absent. These nil nodes must not be mistaken for expressions,\n+// the rewriter should not try to dereference them. Was issue 2410.\n+type Foo struct {\n+\tField int\n+}"}, {"sha": "0d16d16011be2687128966552db1eb1f7446d46b", "filename": "libgo/go/cmd/gofmt/testdata/rewrite3.input", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite3.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Field tags are *ast.BasicLit nodes that are nil when the tag is\n+// absent. These nil nodes must not be mistaken for expressions,\n+// the rewriter should not try to dereference them. Was issue 2410.\n+type Foo struct {\n+\tField int\n+}"}, {"sha": "8dfc81a0746bdc0aa7a5ddd55cc3207158b92ed5", "filename": "libgo/go/cmd/gofmt/testdata/rewrite4.golden", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of parenthesized expressions (x) -> x\n+// must not drop parentheses if that would lead to\n+// wrong association of the operands.\n+// Was issue 1847.\n+\n+package main\n+\n+// From example 1 of issue 1847.\n+func _() {\n+\tvar t = (&T{1000}).Id()\n+}\n+\n+// From example 2 of issue 1847.\n+func _() {\n+\tfmt.Println((*xpp).a)\n+}\n+\n+// Some more test cases.\n+func _() {\n+\t_ = (-x).f\n+\t_ = (*x).f\n+\t_ = (&x).f\n+\t_ = (!x).f\n+\t_ = -x.f\n+\t_ = *x.f\n+\t_ = &x.f\n+\t_ = !x.f\n+\t(-x).f()\n+\t(*x).f()\n+\t(&x).f()\n+\t(!x).f()\n+\t_ = -x.f()\n+\t_ = *x.f()\n+\t_ = &x.f()\n+\t_ = !x.f()\n+\n+\t_ = (-x).f\n+\t_ = (*x).f\n+\t_ = (&x).f\n+\t_ = (!x).f\n+\t_ = -x.f\n+\t_ = *x.f\n+\t_ = &x.f\n+\t_ = !x.f\n+\t(-x).f()\n+\t(*x).f()\n+\t(&x).f()\n+\t(!x).f()\n+\t_ = -x.f()\n+\t_ = *x.f()\n+\t_ = &x.f()\n+\t_ = !x.f()\n+\n+\t_ = -x.f\n+\t_ = *x.f\n+\t_ = &x.f\n+\t_ = !x.f\n+\t_ = -x.f\n+\t_ = *x.f\n+\t_ = &x.f\n+\t_ = !x.f\n+\t_ = -x.f()\n+\t_ = *x.f()\n+\t_ = &x.f()\n+\t_ = !x.f()\n+\t_ = -x.f()\n+\t_ = *x.f()\n+\t_ = &x.f()\n+\t_ = !x.f()\n+}"}, {"sha": "164cc0451f3874563b48adc53f960699d1680468", "filename": "libgo/go/cmd/gofmt/testdata/rewrite4.input", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite4.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of parenthesized expressions (x) -> x\n+// must not drop parentheses if that would lead to\n+// wrong association of the operands.\n+// Was issue 1847.\n+\n+package main\n+\n+// From example 1 of issue 1847.\n+func _() {\n+\tvar t = (&T{1000}).Id()\n+}\n+\n+// From example 2 of issue 1847.\n+func _() {\n+       fmt.Println((*xpp).a)\n+}\n+\n+// Some more test cases.\n+func _() {\n+\t_ = (-x).f\n+\t_ = (*x).f\n+\t_ = (&x).f\n+\t_ = (!x).f\n+\t_ = (-x.f)\n+\t_ = (*x.f)\n+\t_ = (&x.f)\n+\t_ = (!x.f)\n+\t(-x).f()\n+\t(*x).f()\n+\t(&x).f()\n+\t(!x).f()\n+\t_ = (-x.f())\n+\t_ = (*x.f())\n+\t_ = (&x.f())\n+\t_ = (!x.f())\n+\n+\t_ = ((-x)).f\n+\t_ = ((*x)).f\n+\t_ = ((&x)).f\n+\t_ = ((!x)).f\n+\t_ = ((-x.f))\n+\t_ = ((*x.f))\n+\t_ = ((&x.f))\n+\t_ = ((!x.f))\n+\t((-x)).f()\n+\t((*x)).f()\n+\t((&x)).f()\n+\t((!x)).f()\n+\t_ = ((-x.f()))\n+\t_ = ((*x.f()))\n+\t_ = ((&x.f()))\n+\t_ = ((!x.f()))\n+\n+\t_ = -(x).f\n+\t_ = *(x).f\n+\t_ = &(x).f\n+\t_ = !(x).f\n+\t_ = -x.f\n+\t_ = *x.f\n+\t_ = &x.f\n+\t_ = !x.f\n+\t_ = -(x).f()\n+\t_ = *(x).f()\n+\t_ = &(x).f()\n+\t_ = !(x).f()\n+\t_ = -x.f()\n+\t_ = *x.f()\n+\t_ = &x.f()\n+\t_ = !x.f()\n+}"}, {"sha": "5a448a63d37e1205b51b4a1a9190cc33a24a440f", "filename": "libgo/go/cmd/gofmt/testdata/rewrite5.golden", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of expressions containing nodes with associated comments to\n+// expressions without those nodes must also eliminate the associated\n+// comments.\n+\n+package p\n+\n+func f(x int) int {\n+\t_ = 2 * x // this comment remains in the rewrite\n+\t_ = 2 * x\n+\treturn 2 * x\n+}"}, {"sha": "0d759e69b6db29e8cdf7f395ebe3f6a78bf90fd3", "filename": "libgo/go/cmd/gofmt/testdata/rewrite5.input", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite5.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of expressions containing nodes with associated comments to\n+// expressions without those nodes must also eliminate the associated\n+// comments.\n+\n+package p\n+\n+func f(x int) int {\n+\t_ = x + x // this comment remains in the rewrite\n+\t_ = x /* this comment must not be in the rewrite */ + x\n+\treturn x /* this comment must not be in the rewrite */ + x\n+}"}, {"sha": "e565dbdd97b57feff54c1b6c067970a6bd4ad46c", "filename": "libgo/go/cmd/gofmt/testdata/rewrite6.golden", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of calls must take the ... (ellipsis)\n+// attribute for the last argument into account.\n+\n+package p\n+\n+func fun(x []int) {}\n+\n+func g(x []int) {\n+\tFun(x)    // -r='fun(x)->Fun(x)' should rewrite this to Fun(x)\n+\tfun(x...) // -r='fun(x)->Fun(x)' should not rewrite this\n+}"}, {"sha": "8c088b3e87873c6afd613f99d7d4cd4d792cdf95", "filename": "libgo/go/cmd/gofmt/testdata/rewrite6.input", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite6.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of calls must take the ... (ellipsis)\n+// attribute for the last argument into account.\n+\n+package p\n+\n+func fun(x []int) {}\n+\n+func g(x []int) {\n+\tfun(x)    // -r='fun(x)->Fun(x)' should rewrite this to Fun(x)\n+\tfun(x...) // -r='fun(x)->Fun(x)' should not rewrite this\n+}"}, {"sha": "29babad9f94124a6498928cb452affc188de52c0", "filename": "libgo/go/cmd/gofmt/testdata/rewrite7.golden", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of calls must take the ... (ellipsis)\n+// attribute for the last argument into account.\n+\n+package p\n+\n+func fun(x []int) {}\n+\n+func g(x []int) {\n+\tfun(x) // -r='fun(x...)->Fun(x)' should not rewrite this\n+\tFun(x) // -r='fun(x...)->Fun(x)' should rewrite this to Fun(x)\n+}"}, {"sha": "073e2a3e6f8ac57343328e3ac720f07e8d01c96e", "filename": "libgo/go/cmd/gofmt/testdata/rewrite7.input", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite7.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Rewriting of calls must take the ... (ellipsis)\n+// attribute for the last argument into account.\n+\n+package p\n+\n+func fun(x []int) {}\n+\n+func g(x []int) {\n+\tfun(x)    // -r='fun(x...)->Fun(x)' should not rewrite this\n+\tfun(x...) // -r='fun(x...)->Fun(x)' should rewrite this to Fun(x)\n+}"}, {"sha": "cfc452b031007ed2e47f86d459b6a50aa2242a57", "filename": "libgo/go/cmd/gofmt/testdata/rewrite8.golden", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Check that literal type expression rewrites are accepted.\n+// Was issue 4406.\n+\n+package p\n+\n+type T int"}, {"sha": "235efa91cc69a8a920f13b99966fe8dfc0b1f0ba", "filename": "libgo/go/cmd/gofmt/testdata/rewrite8.input", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite8.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Check that literal type expression rewrites are accepted.\n+// Was issue 4406.\n+\n+package p\n+\n+type T interface{}"}, {"sha": "61e074f68a808a81d9be1e82583d3c2ce8bbd104", "filename": "libgo/go/cmd/gofmt/testdata/slices1.golden", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,58 @@\n+// Test cases for slice expression simplification.\n+package p\n+\n+var (\n+\ta [10]byte\n+\tb [20]float32\n+\ts []int\n+\tt struct {\n+\t\ts []byte\n+\t}\n+\n+\t_ = a[0:]\n+\t_ = a[1:10]\n+\t_ = a[2:]\n+\t_ = a[3:(len(a))]\n+\t_ = a[len(a) : len(a)-1]\n+\t_ = a[0:len(b)]\n+\n+\t_ = a[:]\n+\t_ = a[:10]\n+\t_ = a[:]\n+\t_ = a[:(len(a))]\n+\t_ = a[:len(a)-1]\n+\t_ = a[:len(b)]\n+\n+\t_ = s[0:]\n+\t_ = s[1:10]\n+\t_ = s[2:]\n+\t_ = s[3:(len(s))]\n+\t_ = s[len(a) : len(s)-1]\n+\t_ = s[0:len(b)]\n+\n+\t_ = s[:]\n+\t_ = s[:10]\n+\t_ = s[:]\n+\t_ = s[:(len(s))]\n+\t_ = s[:len(s)-1]\n+\t_ = s[:len(b)]\n+\n+\t_ = t.s[0:]\n+\t_ = t.s[1:10]\n+\t_ = t.s[2:len(t.s)]\n+\t_ = t.s[3:(len(t.s))]\n+\t_ = t.s[len(a) : len(t.s)-1]\n+\t_ = t.s[0:len(b)]\n+\n+\t_ = t.s[:]\n+\t_ = t.s[:10]\n+\t_ = t.s[:len(t.s)]\n+\t_ = t.s[:(len(t.s))]\n+\t_ = t.s[:len(t.s)-1]\n+\t_ = t.s[:len(b)]\n+)\n+\n+func _() {\n+\ts := s[0:]\n+\t_ = s\n+}"}, {"sha": "4d2cbfff4004644082c741cb9df9504822849d7b", "filename": "libgo/go/cmd/gofmt/testdata/slices1.input", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices1.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,58 @@\n+// Test cases for slice expression simplification.\n+package p\n+\n+var (\n+\ta [10]byte\n+\tb [20]float32\n+\ts []int\n+\tt struct {\n+\t\ts []byte\n+\t}\n+\n+\t_ = a[0:]\n+\t_ = a[1:10]\n+\t_ = a[2:len(a)]\n+\t_ = a[3:(len(a))]\n+\t_ = a[len(a) : len(a)-1]\n+\t_ = a[0:len(b)]\n+\n+\t_ = a[:]\n+\t_ = a[:10]\n+\t_ = a[:len(a)]\n+\t_ = a[:(len(a))]\n+\t_ = a[:len(a)-1]\n+\t_ = a[:len(b)]\n+\n+\t_ = s[0:]\n+\t_ = s[1:10]\n+\t_ = s[2:len(s)]\n+\t_ = s[3:(len(s))]\n+\t_ = s[len(a) : len(s)-1]\n+\t_ = s[0:len(b)]\n+\n+\t_ = s[:]\n+\t_ = s[:10]\n+\t_ = s[:len(s)]\n+\t_ = s[:(len(s))]\n+\t_ = s[:len(s)-1]\n+\t_ = s[:len(b)]\n+\n+\t_ = t.s[0:]\n+\t_ = t.s[1:10]\n+\t_ = t.s[2:len(t.s)]\n+\t_ = t.s[3:(len(t.s))]\n+\t_ = t.s[len(a) : len(t.s)-1]\n+\t_ = t.s[0:len(b)]\n+\n+\t_ = t.s[:]\n+\t_ = t.s[:10]\n+\t_ = t.s[:len(t.s)]\n+\t_ = t.s[:(len(t.s))]\n+\t_ = t.s[:len(t.s)-1]\n+\t_ = t.s[:len(b)]\n+)\n+\n+func _() {\n+\ts := s[0:len(s)]\n+\t_ = s\n+}"}, {"sha": "433788e1ee6911ab72c748d413345e0b2ebef818", "filename": "libgo/go/cmd/gofmt/testdata/slices2.golden", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,61 @@\n+// Test cases for slice expression simplification.\n+// Because of a dot import, these slices must remain untouched.\n+package p\n+\n+import . \"math\"\n+\n+var (\n+\ta [10]byte\n+\tb [20]float32\n+\ts []int\n+\tt struct {\n+\t\ts []byte\n+\t}\n+\n+\t_ = a[0:]\n+\t_ = a[1:10]\n+\t_ = a[2:len(a)]\n+\t_ = a[3:(len(a))]\n+\t_ = a[len(a) : len(a)-1]\n+\t_ = a[0:len(b)]\n+\n+\t_ = a[:]\n+\t_ = a[:10]\n+\t_ = a[:len(a)]\n+\t_ = a[:(len(a))]\n+\t_ = a[:len(a)-1]\n+\t_ = a[:len(b)]\n+\n+\t_ = s[0:]\n+\t_ = s[1:10]\n+\t_ = s[2:len(s)]\n+\t_ = s[3:(len(s))]\n+\t_ = s[len(a) : len(s)-1]\n+\t_ = s[0:len(b)]\n+\n+\t_ = s[:]\n+\t_ = s[:10]\n+\t_ = s[:len(s)]\n+\t_ = s[:(len(s))]\n+\t_ = s[:len(s)-1]\n+\t_ = s[:len(b)]\n+\n+\t_ = t.s[0:]\n+\t_ = t.s[1:10]\n+\t_ = t.s[2:len(t.s)]\n+\t_ = t.s[3:(len(t.s))]\n+\t_ = t.s[len(a) : len(t.s)-1]\n+\t_ = t.s[0:len(b)]\n+\n+\t_ = t.s[:]\n+\t_ = t.s[:10]\n+\t_ = t.s[:len(t.s)]\n+\t_ = t.s[:(len(t.s))]\n+\t_ = t.s[:len(t.s)-1]\n+\t_ = t.s[:len(b)]\n+)\n+\n+func _() {\n+\ts := s[0:len(s)]\n+\t_ = s\n+}"}, {"sha": "433788e1ee6911ab72c748d413345e0b2ebef818", "filename": "libgo/go/cmd/gofmt/testdata/slices2.input", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fslices2.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,61 @@\n+// Test cases for slice expression simplification.\n+// Because of a dot import, these slices must remain untouched.\n+package p\n+\n+import . \"math\"\n+\n+var (\n+\ta [10]byte\n+\tb [20]float32\n+\ts []int\n+\tt struct {\n+\t\ts []byte\n+\t}\n+\n+\t_ = a[0:]\n+\t_ = a[1:10]\n+\t_ = a[2:len(a)]\n+\t_ = a[3:(len(a))]\n+\t_ = a[len(a) : len(a)-1]\n+\t_ = a[0:len(b)]\n+\n+\t_ = a[:]\n+\t_ = a[:10]\n+\t_ = a[:len(a)]\n+\t_ = a[:(len(a))]\n+\t_ = a[:len(a)-1]\n+\t_ = a[:len(b)]\n+\n+\t_ = s[0:]\n+\t_ = s[1:10]\n+\t_ = s[2:len(s)]\n+\t_ = s[3:(len(s))]\n+\t_ = s[len(a) : len(s)-1]\n+\t_ = s[0:len(b)]\n+\n+\t_ = s[:]\n+\t_ = s[:10]\n+\t_ = s[:len(s)]\n+\t_ = s[:(len(s))]\n+\t_ = s[:len(s)-1]\n+\t_ = s[:len(b)]\n+\n+\t_ = t.s[0:]\n+\t_ = t.s[1:10]\n+\t_ = t.s[2:len(t.s)]\n+\t_ = t.s[3:(len(t.s))]\n+\t_ = t.s[len(a) : len(t.s)-1]\n+\t_ = t.s[0:len(b)]\n+\n+\t_ = t.s[:]\n+\t_ = t.s[:10]\n+\t_ = t.s[:len(t.s)]\n+\t_ = t.s[:(len(t.s))]\n+\t_ = t.s[:len(t.s)-1]\n+\t_ = t.s[:len(b)]\n+)\n+\n+func _() {\n+\ts := s[0:len(s)]\n+\t_ = s\n+}"}, {"sha": "ff8b0b7ab484ade2a19216f4bcbd0c2b94d16921", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.golden", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\tif x {\n+\t\ty\n+\t}"}, {"sha": "1f888877d010ec034726048c6a0b1a72dfdac91f", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.golden.gofmt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.golden.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\tif x {\n+\ty\n+}"}, {"sha": "ff8b0b7ab484ade2a19216f4bcbd0c2b94d16921", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.input", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\tif x {\n+\t\ty\n+\t}"}, {"sha": "1f888877d010ec034726048c6a0b1a72dfdac91f", "filename": "libgo/go/cmd/gofmt/testdata/stdin1.input.gofmt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin1.input.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\tif x {\n+\ty\n+}"}, {"sha": "7eb1b54fec058ebbc4f248f05a63fddb63112380", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.golden", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,11 @@\n+\n+\n+var x int\n+\n+func f() {\n+\ty := z\n+\t/* this is a comment */\n+\t// this is a comment too\n+}\n+\n+"}, {"sha": "85e80030081c3ed9724b918e437e773e2e0772b8", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.golden.gofmt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.golden.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,10 @@\n+\n+\n+\n+var x int\n+\n+func f() {\n+\ty := z\n+}\n+\n+"}, {"sha": "99defd2d10c5c3cb53e294fbcf9f955fe2a26f9f", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.input", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,11 @@\n+\n+\n+var x int\n+\n+\n+func f() { y := z\n+\t/* this is a comment */\n+\t// this is a comment too\n+}\n+\n+"}, {"sha": "7eb1b54fec058ebbc4f248f05a63fddb63112380", "filename": "libgo/go/cmd/gofmt/testdata/stdin2.input.gofmt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin2.input.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,11 @@\n+\n+\n+var x int\n+\n+func f() {\n+\ty := z\n+\t/* this is a comment */\n+\t// this is a comment too\n+}\n+\n+"}, {"sha": "1bf2f5a483f9a0e0c0a10a959045f5a44911547b", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.golden", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,6 @@\n+\n+\t\t/* note: no newline at end of file */\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\ts += i\n+\t\t}\n+\t\n\\ No newline at end of file"}, {"sha": "b4d1d4663ed0694d32504732a78bbf20061c0447", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.golden.gofmt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.golden.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+\n+\n+\t\t/* note: no newline at end of file */\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\ts += i\n+\t\t}\n+\t\n\\ No newline at end of file"}, {"sha": "d963bd0d21bc54f829799e8596c84d7c35c5707a", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.input", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,4 @@\n+\n+\t\t/* note: no newline at end of file */\n+\t\tfor i := 0; i < 10; i++ { s += i }\n+\t\n\\ No newline at end of file"}, {"sha": "b4d1d4663ed0694d32504732a78bbf20061c0447", "filename": "libgo/go/cmd/gofmt/testdata/stdin3.input.gofmt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin3.input.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,7 @@\n+\n+\n+\t\t/* note: no newline at end of file */\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\ts += i\n+\t\t}\n+\t\n\\ No newline at end of file"}, {"sha": "5f73435517f4376404e5915844df18113b8fb338", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.golden", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\t// comment\n+\n+\ti := 0"}, {"sha": "5f73435517f4376404e5915844df18113b8fb338", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.golden.gofmt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.golden.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\t// comment\n+\n+\ti := 0"}, {"sha": "f02a54fb1a9dbdf052093eb45172e64c309907e0", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.input", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\t// comment\n+\t\n+\ti := 0"}, {"sha": "5f73435517f4376404e5915844df18113b8fb338", "filename": "libgo/go/cmd/gofmt/testdata/stdin4.input.gofmt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input.gofmt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input.gofmt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fstdin4.input.gofmt?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,3 @@\n+\t// comment\n+\n+\ti := 0"}, {"sha": "2b1905edd3b4fc1c965cbe800ddc3db7a049772e", "filename": "libgo/go/cmd/gofmt/testdata/typeswitch.golden", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypeswitch.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypeswitch.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypeswitch.golden?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,60 @@\n+/*\n+\tParenthesized type switch expressions originally\n+\taccepted by gofmt must continue to be rewritten\n+\tinto the correct unparenthesized form.\n+\n+\tOnly type-switches that didn't declare a variable\n+\tin the type switch type assertion and which\n+\tcontained only \"expression-like\" (named) types in their\n+\tcases were permitted to have their type assertion parenthesized\n+\tby go/parser (due to a weak predicate in the parser). All others\n+\twere rejected always, either with a syntax error in the\n+\ttype switch header or in the case.\n+\n+\tSee also issue 4470.\n+*/\n+package p\n+\n+func f() {\n+\tvar x interface{}\n+\tswitch x.(type) { // should remain the same\n+\t}\n+\tswitch x.(type) { // should become: switch x.(type) {\n+\t}\n+\n+\tswitch x.(type) { // should remain the same\n+\tcase int:\n+\t}\n+\tswitch x.(type) { // should become: switch x.(type) {\n+\tcase int:\n+\t}\n+\n+\tswitch x.(type) { // should remain the same\n+\tcase []int:\n+\t}\n+\n+\t// Parenthesized (x.(type)) in type switches containing cases\n+\t// with unnamed (literal) types were never permitted by gofmt;\n+\t// thus there won't be any code in the wild using this style if\n+\t// the code was gofmt-ed.\n+\t/*\n+\t\tswitch (x.(type)) {\n+\t\tcase []int:\n+\t\t}\n+\t*/\n+\n+\tswitch t := x.(type) { // should remain the same\n+\tdefault:\n+\t\t_ = t\n+\t}\n+\n+\t// Parenthesized (x.(type)) in type switches declaring a variable\n+\t// were never permitted by gofmt; thus there won't be any code in\n+\t// the wild using this style if the code was gofmt-ed.\n+\t/*\n+\t\tswitch t := (x.(type)) {\n+\t\tdefault:\n+\t\t\t_ = t\n+\t\t}\n+\t*/\n+}"}, {"sha": "8f8cba9b855abd4f0893422de34a91d9183b2f6c", "filename": "libgo/go/cmd/gofmt/testdata/typeswitch.input", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypeswitch.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypeswitch.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Ftypeswitch.input?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -0,0 +1,60 @@\n+/*\n+\tParenthesized type switch expressions originally\n+\taccepted by gofmt must continue to be rewritten\n+\tinto the correct unparenthesized form.\n+\n+\tOnly type-switches that didn't declare a variable\n+\tin the type switch type assertion and which\n+\tcontained only \"expression-like\" (named) types in their\n+\tcases were permitted to have their type assertion parenthesized\n+\tby go/parser (due to a weak predicate in the parser). All others\n+\twere rejected always, either with a syntax error in the\n+\ttype switch header or in the case.\n+\n+\tSee also issue 4470.\n+*/\n+package p\n+\n+func f() {\n+\tvar x interface{}\n+\tswitch x.(type) { // should remain the same\n+\t}\n+\tswitch (x.(type)) { // should become: switch x.(type) {\n+\t}\n+\n+\tswitch x.(type) { // should remain the same\n+\tcase int:\n+\t}\n+\tswitch (x.(type)) { // should become: switch x.(type) {\n+\tcase int:\n+\t}\n+\n+\tswitch x.(type) { // should remain the same\n+\tcase []int:\n+\t}\n+\n+\t// Parenthesized (x.(type)) in type switches containing cases\n+\t// with unnamed (literal) types were never permitted by gofmt;\n+\t// thus there won't be any code in the wild using this style if\n+\t// the code was gofmt-ed.\n+\t/*\n+\tswitch (x.(type)) {\n+\tcase []int:\n+\t}\n+\t*/\n+\n+\tswitch t := x.(type) { // should remain the same\n+\tdefault:\n+\t\t_ = t\n+\t}\n+\n+\t// Parenthesized (x.(type)) in type switches declaring a variable\n+\t// were never permitted by gofmt; thus there won't be any code in\n+\t// the wild using this style if the code was gofmt-ed.\n+\t/*\n+\tswitch t := (x.(type)) {\n+\tdefault:\n+\t\t_ = t\n+\t}\n+\t*/\n+}"}, {"sha": "5fe7dcb6b2f8e5dfc50384e5b930ee37df9ac963", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -268,6 +268,8 @@ var cgoEnabled = map[string]bool{\n \t\"linux/386\":       true,\n \t\"linux/amd64\":     true,\n \t\"linux/arm\":       true,\n+\t\"linux/ppc64\":     true,\n+\t\"linux/ppc64le\":   true,\n \t\"linux/s390\":      true,\n \t\"linux/s390x\":     true,\n \t\"netbsd/386\":      true,\n@@ -1196,8 +1198,15 @@ func init() {\n \t}\n }\n \n-// ToolDir is the directory containing build tools.\n-var ToolDir = filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+func getToolDir() string {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\treturn runtime.GCCGOTOOLDIR\n+\t} else {\n+\t\treturn filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+\t}\n+}\n+\n+var ToolDir = getToolDir()\n \n // IsLocalImport reports whether the import path is\n // a local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n@@ -1218,6 +1227,8 @@ func ArchChar(goarch string) (string, error) {\n \t\treturn \"5\", nil\n \tcase \"arm64\":\n \t\treturn \"7\", nil\n+\tcase \"ppc64\", \"ppc64le\":\n+\t\treturn \"9\", nil\n \t}\n \treturn \"\", errors.New(\"unsupported GOARCH \" + goarch)\n }"}, {"sha": "393984c7d577f818821a2bc30869d7d362a3fe4b", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -201,5 +201,8 @@ func Version() string {\n const GOOS string = theGoos\n \n // GOARCH is the running program's architecture target:\n-// 386, amd64, arm or arm64.\n+// 386, amd64, arm, arm64, ppc64, ppc64le.\n const GOARCH string = theGoarch\n+\n+// GCCGOTOOLDIR is the Tool Dir for the gccgo build\n+const GCCGOTOOLDIR string = theGccgoToolDir"}, {"sha": "fb0d1afe82ff938df946f08e2ae0ca978c8f8061", "filename": "libgo/merge.sh", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7d64c1ae3c0732b167d2050b101808f078d711/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=7d7d64c1ae3c0732b167d2050b101808f078d711", "patch": "@@ -163,6 +163,36 @@ done\n   done\n done\n \n+cmdlist=\"cgo go gofmt\"\n+for c in $cmdlist; do\n+  (cd ${NEWDIR}/src/cmd/$c && find . -name '*.go' -print) | while read f; do\n+    oldfile=${OLDDIR}/src/cmd/$c/$f\n+    newfile=${NEWDIR}/src/cmd/$c/$f\n+    libgofile=go/cmd/$c/$f\n+    merge $f ${oldfile} ${newfile} ${libgofile}\n+  done\n+\n+  (cd ${NEWDIR}/src/cmd/$c && find . -name testdata -print) | while read d; do\n+    oldtd=${OLDDIR}/src/cmd/$c/$d\n+    newtd=${NEWDIR}/src/cmd/$c/$d\n+    libgotd=go/cmd/$c/$d\n+    if ! test -d ${oldtd}; then\n+      continue\n+    fi\n+    (cd ${oldtd} && hg status -A .) | while read f; do\n+      if test \"`basename $f`\" = \".hgignore\"; then\n+        continue\n+      fi\n+      f=`echo $f | sed -e 's/^..//'`\n+      name=$d/$f\n+      oldfile=${oldtd}/$f\n+      newfile=${newtd}/$f\n+      libgofile=${libgotd}/$f\n+      merge ${name} ${oldfile} ${newfile} ${libgofile}\n+    done\n+  done\n+done\n+\n runtime=\"chan.goc chan.h cpuprof.goc env_posix.c heapdump.c lock_futex.c lfstack.goc lock_sema.c mcache.c mcentral.c mfixalloc.c mgc0.c mgc0.h mheap.c msize.c netpoll.goc netpoll_epoll.c netpoll_kqueue.c netpoll_stub.c panic.c print.c proc.c race.h rdebug.goc runtime.c runtime.h signal_unix.c signal_unix.h malloc.h malloc.goc mprof.goc parfor.c runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n for f in $runtime; do\n   merge_c $f $f"}]}