{"sha": "c73433339781b21b25b4f9f0e489291635da0d63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzczNDMzMzM5NzgxYjIxYjI1YjRmOWYwZTQ4OTI5MTYzNWRhMGQ2Mw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-07-23T18:15:08Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-07-23T18:15:08Z"}, "message": "Half-pic and float->int fixes\n\nFrom-SVN: r1672", "tree": {"sha": "ea4f9d487bd9b6e5e92b53f43ed2434808b2f815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea4f9d487bd9b6e5e92b53f43ed2434808b2f815"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c73433339781b21b25b4f9f0e489291635da0d63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73433339781b21b25b4f9f0e489291635da0d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c73433339781b21b25b4f9f0e489291635da0d63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73433339781b21b25b4f9f0e489291635da0d63/comments", "author": null, "committer": null, "parents": [{"sha": "a25432837c9ef7b23ed59edbbd915777c39190cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25432837c9ef7b23ed59edbbd915777c39190cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25432837c9ef7b23ed59edbbd915777c39190cb"}], "stats": {"total": 173, "additions": 62, "deletions": 111}, "files": [{"sha": "37707cd5f64d3e6ae994044a6af065b8fa01e539", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73433339781b21b25b4f9f0e489291635da0d63/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73433339781b21b25b4f9f0e489291635da0d63/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c73433339781b21b25b4f9f0e489291635da0d63", "patch": "@@ -1023,11 +1023,11 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t target, so zero/sign extend can use this code as well.  */\n \t      switch (GET_MODE (op1))\n \t\t{\n-\t\tdefault:      break;\n-\t\tcase SFmode: ret = \"lw\\t%0,%1\"; break;\n-\t\tcase SImode: ret = \"lw\\t%0,%1\"; break;\n-\t\tcase HImode: ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\"; break;\n-\t\tcase QImode: ret = (unsignedp) ? \"lbu\\t%0,%1\" : \"lb\\t%0,%1\"; break;\n+\t\tdefault:\t\t\t\t\t\t\tbreak;\n+\t\tcase SFmode: ret = \"lw\\t%0,%1\";\t\t\t\t\tbreak;\n+\t\tcase SImode: ret = \"lw\\t%0,%1\";\t\t\t\t\tbreak;\n+\t\tcase HImode: ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\";\tbreak;\n+\t\tcase QImode: ret = (unsignedp) ? \"lbu\\t%0,%1\" : \"lb\\t%0,%1\";\tbreak;\n \t\t}\n \t    }\n \n@@ -1085,21 +1085,51 @@ mips_move_1word (operands, insn, unsignedp)\n \t}\n \n       else if (code1 == LABEL_REF)\n-\tret = \"la\\t%0,%a1\";\n-\n-      else if (code1 == SYMBOL_REF || code1 == CONST)\n \t{\n \t  if (TARGET_STATS)\n \t    mips_count_memory_refs (op1, 1);\n \n+\t  ret = \"la\\t%0,%a1\";\n+\t}\n+\n+      else if (code1 == SYMBOL_REF || code1 == CONST)\n+\t{\n \t  if (HALF_PIC_P () && CONSTANT_P (op1) && HALF_PIC_ADDRESS_P (op1))\n \t    {\n-\t      delay = DELAY_LOAD;\n-\t      ret = \"lw\\t%0,%2\\t\\t# pic reference\";\n-\t      operands[2] = HALF_PIC_PTR (op1);\n+\t      rtx offset = const0_rtx;\n+\n+\t      if (GET_CODE (op1) == CONST)\n+\t\top1 = eliminate_constant_term (XEXP (op1, 0), &offset);\n+\n+\t      if (GET_CODE (op1) == SYMBOL_REF)\n+\t\t{\n+\t\t  operands[2] = HALF_PIC_PTR (op1);\n+\n+\t\t  if (TARGET_STATS)\n+\t\t    mips_count_memory_refs (operands[2], 1);\n+\n+\t\t  if (INTVAL (offset) == 0)\n+\t\t    {\n+\t\t      delay = DELAY_LOAD;\n+\t\t      ret = \"lw\\t%0,%2\";\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      dslots_load_total++;\n+\t\t      operands[3] = offset;\n+\t\t      ret = (SMALL_INT (offset))\n+\t\t\t\t? \"lw\\t%0,%2%#\\n\\tadd\\t%0,%0,%3\"\n+\t\t\t\t: \"lw\\t%0,%2%#\\n\\t%[li\\t%@,%3\\n\\tadd\\t%0,%0,%@%]\";\n+\t\t    }\n+\t\t}\n \t    }\n \t  else\n-\t    ret = \"la\\t%0,%a1\";\n+\t    {\n+\t      if (TARGET_STATS)\n+\t\tmips_count_memory_refs (op1, 1);\n+\n+\t      ret = \"la\\t%0,%a1\";\n+\t    }\n \t}\n \n       else if (code1 == PLUS)"}, {"sha": "12edab96cd7ea48e6b559722e34caa6a041c9877", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 20, "deletions": 99, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73433339781b21b25b4f9f0e489291635da0d63/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73433339781b21b25b4f9f0e489291635da0d63/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=c73433339781b21b25b4f9f0e489291635da0d63", "patch": "@@ -51,10 +51,9 @@\n ;; fsqrt\tfloating point square root\n ;; multi\tmultiword sequence (or user asm statements)\n ;; nop\t\tno operation\n-;; pic\t\tOSF/rose half pic load\n \n (define_attr \"type\"\n-  \"unknown,branch,jump,call,load,store,move,xfer,hilo,arith,darith,imul,idiv,icmp,fadd,fmul,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,multi,nop,pic\"\n+  \"unknown,branch,jump,call,load,store,move,xfer,hilo,arith,darith,imul,idiv,icmp,fadd,fmul,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,multi,nop\"\n   (const_string \"unknown\"))\n \n ;; Main data type used by the insn\n@@ -65,7 +64,7 @@\n \n ;; whether or not an instruction has a mandatory delay slot\n (define_attr \"dslot\" \"no,yes\"\n-  (if_then_else (eq_attr \"type\" \"branch,jump,call,load,xfer,hilo,fcmp,pic\")\n+  (if_then_else (eq_attr \"type\" \"branch,jump,call,load,xfer,hilo,fcmp\")\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n@@ -129,11 +128,11 @@\n ;; Make the default case (PROCESSOR_DEFAULT) handle the worst case\n \n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load,pic\") (eq_attr \"cpu\" \"!r3000\"))\n+  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"!r3000\"))\n   3 0)\n \n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load,pic\") (eq_attr \"cpu\" \"r3000\"))\n+  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"r3000\"))\n   2 0)\n \n (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"store\") 1 0)\n@@ -242,7 +241,7 @@\n ;; The following functional units do not use the cpu type, and use\n ;; much less memory in genattrtab.c.\n \n-;; (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"load,pic\")                            3   0)\n+;; (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"load\")                                3   0)\n ;; (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"store\")                               1   0)\n ;;       \n ;; (define_function_unit \"fp_comp\"  1 0 (eq_attr \"type\" \"fcmp\")                                2   0)\n@@ -1454,11 +1453,11 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\n ;;  ....................\n \n-(define_insn \"fix_truncdfsi2_internal\"\n+(define_insn \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=d,*f,R,o\")\n \t(fix:SI (match_operand:DF 1 \"register_operand\" \"f,*f,f,f\")))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"d,*d,d,d\"))\n-   (clobber (match_operand:DF 3 \"register_operand\" \"f,*f,f,f\"))]\n+   (clobber (match_scratch:SI 2 \"=d,*d,d,d\"))\n+   (clobber (match_scratch:DF 3 \"=f,*X,f,f\"))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n@@ -1476,28 +1475,14 @@ move\\\\t%0,%z4\\\\n\\\\\n }\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"14,12,13,14\")])\n+   (set_attr \"length\"\t\"11,9,10,11\")])\n \n \n-(define_expand \"fix_truncdfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t\t   (fix:SI (match_operand:DF 1 \"register_operand\" \"f\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_HARD_FLOAT\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (SImode);\t/* gp reg that saves FP status bits */\n-  operands[3] = gen_reg_rtx (DFmode);\t/* fp reg that gets the conversion */\n-\n-  /* Fall through and generate default code */\n-}\")\n-\n-(define_insn \"fix_truncsfsi2_internal\"\n+(define_insn \"fix_truncsfsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=d,*f,R,o\")\n \t(fix:SI (match_operand:SF 1 \"register_operand\" \"f,*f,f,f\")))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"d,*d,d,d\"))\n-   (clobber (match_operand:SF 3 \"register_operand\" \"f,*f,f,f\"))]\n+   (clobber (match_scratch:SI 2 \"=d,*d,d,d\"))\n+   (clobber (match_scratch:SF 3 \"=f,*X,f,f\"))]\n   \"TARGET_HARD_FLOAT\"\n   \"*\n {\n@@ -1515,22 +1500,7 @@ move\\\\t%0,%z4\\\\n\\\\\n }\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"14,12,13,14\")])\n-\n-\n-(define_expand \"fix_truncsfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n-\t\t   (fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n-  \"TARGET_HARD_FLOAT\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (SImode);\t/* gp reg that saves FP status bits */\n-  operands[3] = gen_reg_rtx (SFmode);\t/* fp reg that gets the conversion */\n-\n-  /* Fall through and generate default code */\n-}\")\n+   (set_attr \"length\"\t\"11,9,10,11\")])\n \n \n (define_insn \"floatsidf2\"\n@@ -1549,6 +1519,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"3,4,3\")])\n \n+\n (define_insn \"floatsisf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n \t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n@@ -1609,6 +1580,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n+\n (define_expand \"fixuns_truncsfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:SF 1 \"register_operand\" \"\")))]\n@@ -1839,58 +1811,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-\n-  /* If this is a half-pic address being loaded, convert the address\n-     into a load, so that scheduling and stuff works properly.  */\n-\n-  if (HALF_PIC_P()\n-      && CONSTANT_P (op1)\n-      && HALF_PIC_ADDRESS_P (op1))\n-    {\n-      rtx offset = const0_rtx;\n-      rtx ptr;\n-\n-      if (GET_CODE (op1) == CONST)\n-\top1 = eliminate_constant_term (XEXP (op1, 0), &offset);\n-\n-      ptr = HALF_PIC_PTR (op1);\n-      if (GET_CODE (ptr) == SYMBOL_REF\n-\t  && GET_CODE (op1) == SYMBOL_REF\n-\t  && XSTR (ptr, 0) != XSTR (op1, 0))\n-\t{\n-\t  rtx mem = gen_rtx (MEM, Pmode, ptr);\n-\n-\t  if (INTVAL (offset) == 0)\n-\t    emit_move_insn (op0, mem);\n-\n-\t  else if (reload_in_progress)\n-\t    {\n-\t      emit_move_insn (op0, mem);\n-\t      emit_insn (gen_addsi3 (op0, op0, offset));\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      rtx reg = gen_reg_rtx (Pmode);\n-\n-\t      if (!SMALL_INT (offset))\n-\t\t{\n-\t\t  rtx reg2 = gen_reg_rtx (Pmode);\n-\t\t  emit_move_insn (reg2, offset);\n-\t\t  offset = reg2;\n-\t\t}\n-\n-\t      emit_move_insn (reg, mem);\n-\t      emit_insn (gen_addsi3 (op0, reg, offset));\n-\t    }\n-\t  DONE;\n-\t}\n-    }\n-}\")\n+  \"\")\n \n ;; The difference between these two is whether or not ints are allowed\n ;; in FP registers (off by default, use -mdebugh to enable).\n@@ -1900,18 +1821,18 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*fz,*d,*f,*R,*m,*f,*f,*d,*x\"))]\n   \"TARGET_DEBUG_H_MODE\"\n   \"* return mips_move_1word (operands, insn, TRUE);\"\n-  [(set_attr \"type\"\t\"move,pic,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,4,1,2,1,2,1,2,1,1,1,1,2,1,2,1,1\")])\n+   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,1,1,2,1,2,1,1\")])\n \n (define_insn \"movsi_internal2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*d,*x\")\n \t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,*x,*d\"))]\n   \"!TARGET_DEBUG_H_MODE\"\n   \"* return mips_move_1word (operands, insn, TRUE);\"\n-  [(set_attr \"type\"\t\"move,pic,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,4,1,2,1,2,1,2,1,1,1,1\")])\n+   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,1,1\")])\n \n \n ;; 16-bit Integer moves"}]}