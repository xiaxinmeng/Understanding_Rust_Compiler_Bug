{"sha": "70eff705513d3d3cd387a7b54af5e0818727a8f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBlZmY3MDU1MTNkM2QzY2QzODdhN2I1NGFmNWUwODE4NzI3YThmMA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-08-21T06:27:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-08-21T06:27:14Z"}, "message": "wide-int-range.cc (wide_int_range_abs): New.\n\n\t* wide-int-range.cc (wide_int_range_abs): New.\n\t(wide_int_range_order_set): Rename from wide_int_range_min_max.\n\t* wide-int-range.h (wide_int_range_abs): New.\n\t(wide_int_range_min_max): New.\n\t* tree-vrp.c (extract_range_from_unary_expr): Rewrite ABS_EXPR\n\tcase to call wide_int_range_abs.\n\tRewrite MIN/MAX_EXPR to call wide_int_range_min_max.\n\t(extract_range_from_abs_expr): Delete.\n\nFrom-SVN: r263685", "tree": {"sha": "fc819ab84ec6dd98e2d5b3f7999a9b4c3e138c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc819ab84ec6dd98e2d5b3f7999a9b4c3e138c16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70eff705513d3d3cd387a7b54af5e0818727a8f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70eff705513d3d3cd387a7b54af5e0818727a8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70eff705513d3d3cd387a7b54af5e0818727a8f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70eff705513d3d3cd387a7b54af5e0818727a8f0/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "316a03a633443f0201a980f30f67aac4aaf43e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316a03a633443f0201a980f30f67aac4aaf43e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/316a03a633443f0201a980f30f67aac4aaf43e28"}], "stats": {"total": 257, "additions": 130, "deletions": 127}, "files": [{"sha": "ad722fde33c5e0de96501ee6ac55b4b19dab3e9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70eff705513d3d3cd387a7b54af5e0818727a8f0", "patch": "@@ -1,3 +1,14 @@\n+2018-08-21  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* wide-int-range.cc (wide_int_range_abs): New.\n+\t(wide_int_range_order_set): Rename from wide_int_range_min_max.\n+\t* wide-int-range.h (wide_int_range_abs): New.\n+\t(wide_int_range_min_max): New.\n+\t* tree-vrp.c (extract_range_from_unary_expr): Rewrite ABS_EXPR\n+\tcase to call wide_int_range_abs.\n+\tRewrite MIN/MAX_EXPR to call wide_int_range_min_max.\n+\t(extract_range_from_abs_expr): Delete.\n+\n 2018-08-20  Michael Meissner  <meissner@linux.ibm.com>\n \n \tPR target/87033"}, {"sha": "24e089b019b715b049d218d648e481f093aafcdf", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 32, "deletions": 123, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=70eff705513d3d3cd387a7b54af5e0818727a8f0", "patch": "@@ -1594,50 +1594,19 @@ extract_range_from_binary_expr_1 (value_range *vr,\n   else if (code == MIN_EXPR\n \t   || code == MAX_EXPR)\n     {\n-      if (vr0.type == VR_RANGE\n-\t  && !symbolic_range_p (&vr0))\n-\t{\n-\t  type = VR_RANGE;\n-\t  if (vr1.type == VR_RANGE\n-\t      && !symbolic_range_p (&vr1))\n-\t    {\n-\t      /* For operations that make the resulting range directly\n-\t\t proportional to the original ranges, apply the operation to\n-\t\t the same end of each range.  */\n-\t      min = int_const_binop (code, vr0.min, vr1.min);\n-\t      max = int_const_binop (code, vr0.max, vr1.max);\n-\t    }\n-\t  else if (code == MIN_EXPR)\n-\t    {\n-\t      min = vrp_val_min (expr_type);\n-\t      max = vr0.max;\n-\t    }\n-\t  else if (code == MAX_EXPR)\n-\t    {\n-\t      min = vr0.min;\n-\t      max = vrp_val_max (expr_type);\n-\t    }\n-\t}\n-      else if (vr1.type == VR_RANGE\n-\t       && !symbolic_range_p (&vr1))\n-\t{\n-\t  type = VR_RANGE;\n-\t  if (code == MIN_EXPR)\n-\t    {\n-\t      min = vrp_val_min (expr_type);\n-\t      max = vr1.max;\n-\t    }\n-\t  else if (code == MAX_EXPR)\n-\t    {\n-\t      min = vr1.min;\n-\t      max = vrp_val_max (expr_type);\n-\t    }\n-\t}\n+      wide_int wmin, wmax;\n+      wide_int vr0_min, vr0_max;\n+      wide_int vr1_min, vr1_max;\n+      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n+      extract_range_into_wide_ints (&vr1, sign, prec, &vr1_min, &vr1_max);\n+      if (wide_int_range_min_max (wmin, wmax, code, sign, prec,\n+\t\t\t\t  vr0_min, vr0_max, vr1_min, vr1_max))\n+\tset_value_range (vr, VR_RANGE,\n+\t\t\t wide_int_to_tree (expr_type, wmin),\n+\t\t\t wide_int_to_tree (expr_type, wmax), NULL);\n       else\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n+\tset_value_range_to_varying (vr);\n+      return;\n     }\n   else if (code == MULT_EXPR)\n     {\n@@ -1924,85 +1893,6 @@ extract_range_from_binary_expr_1 (value_range *vr,\n     set_value_range (vr, type, min, max, NULL);\n }\n \n-/* Calculates the absolute value of a range and puts the result in VR.\n-   VR0 is the input range.  TYPE is the type of the resulting\n-   range.  */\n-\n-static void\n-extract_range_from_abs_expr (value_range &vr, tree type, value_range &vr0)\n-{\n-  /* Pass through vr0 in the easy cases.  */\n-  if (TYPE_UNSIGNED (type)\n-      || value_range_nonnegative_p (&vr0))\n-    {\n-      copy_value_range (&vr, &vr0);\n-      return;\n-    }\n-\n-  /* For the remaining varying or symbolic ranges we can't do anything\n-     useful.  */\n-  if (vr0.type == VR_VARYING\n-      || symbolic_range_p (&vr0))\n-    {\n-      set_value_range_to_varying (&vr);\n-      return;\n-    }\n-\n-  /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n-     useful range.  */\n-  if (!TYPE_OVERFLOW_UNDEFINED (type)\n-      && ((vr0.type == VR_RANGE\n-\t   && vrp_val_is_min (vr0.min))\n-\t  || (vr0.type == VR_ANTI_RANGE\n-\t      && !vrp_val_is_min (vr0.min))))\n-    {\n-      set_value_range_to_varying (&vr);\n-      return;\n-    }\n-\n-  /* ABS_EXPR may flip the range around, if the original range\n-     included negative values.  */\n-  tree min, max;\n-  if (!vrp_val_is_min (vr0.min))\n-    min = fold_unary_to_constant (ABS_EXPR, type, vr0.min);\n-  else\n-    min = TYPE_MAX_VALUE (type);\n-\n-  if (!vrp_val_is_min (vr0.max))\n-    max = fold_unary_to_constant (ABS_EXPR, type, vr0.max);\n-  else\n-    max = TYPE_MAX_VALUE (type);\n-\n-  int cmp = compare_values (min, max);\n-  gcc_assert (vr0.type != VR_ANTI_RANGE);\n-\n-  /* If the range contains zero then we know that the minimum value in the\n-     range will be zero.  */\n-  if (range_includes_zero_p (vr0.min, vr0.max) == 1)\n-    {\n-      if (cmp == 1)\n-\tmax = min;\n-      min = build_int_cst (type, 0);\n-    }\n-  else\n-    {\n-      /* If the range was reversed, swap MIN and MAX.  */\n-      if (cmp == 1)\n-\tstd::swap (min, max);\n-    }\n-\n-  cmp = compare_values (min, max);\n-  if (cmp == -2 || cmp == 1)\n-    {\n-      /* If the new range has its limits swapped around (MIN > MAX),\n-\t then the operation caused one of them to wrap around, mark\n-\t the new range VARYING.  */\n-      set_value_range_to_varying (&vr);\n-    }\n-  else\n-    set_value_range (&vr, vr0.type, min, max, NULL);\n-}\n-\n /* Extract range information from a unary operation CODE based on\n    the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.\n    The resulting range is stored in *VR.  */\n@@ -2012,6 +1902,8 @@ extract_range_from_unary_expr (value_range *vr,\n \t\t\t       enum tree_code code, tree type,\n \t\t\t       value_range *vr0_, tree op0_type)\n {\n+  signop sign = TYPE_SIGN (type);\n+  unsigned int prec = TYPE_PRECISION (type);\n   value_range vr0 = *vr0_, vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;\n \n   /* VRP only operates on integral and pointer types.  */\n@@ -2133,7 +2025,24 @@ extract_range_from_unary_expr (value_range *vr,\n       return;\n     }\n   else if (code == ABS_EXPR)\n-    return extract_range_from_abs_expr (*vr, type, vr0);\n+    {\n+      if (vr0.type != VR_RANGE || symbolic_range_p (&vr0))\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+      wide_int wmin, wmax;\n+      wide_int vr0_min, vr0_max;\n+      extract_range_into_wide_ints (&vr0, sign, prec, &vr0_min, &vr0_max);\n+      if (wide_int_range_abs (wmin, wmax, sign, prec, vr0_min, vr0_max,\n+\t\t\t      TYPE_OVERFLOW_UNDEFINED (type)))\n+\tset_value_range (vr, VR_RANGE,\n+\t\t\t wide_int_to_tree (type, wmin),\n+\t\t\t wide_int_to_tree (type, wmax), NULL);\n+      else\n+\tset_value_range_to_varying (vr);\n+      return;\n+    }\n \n   /* For unhandled operations fall back to varying.  */\n   set_value_range_to_varying (vr);"}, {"sha": "a202b5fd503660590e20d4171802ae8158d36d84", "filename": "gcc/wide-int-range.cc", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2Fwide-int-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2Fwide-int-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.cc?ref=70eff705513d3d3cd387a7b54af5e0818727a8f0", "patch": "@@ -119,9 +119,10 @@ wide_int_range_set_zero_nonzero_bits (signop sign,\n    accordingly.  */\n \n static void\n-wide_int_range_min_max (wide_int &min, wide_int &max,\n-\t\t\twide_int &w0, wide_int &w1, wide_int &w2, wide_int &w3,\n-\t\t\tsignop sign)\n+wide_int_range_order_set (wide_int &min, wide_int &max,\n+\t\t\t  wide_int &w0, wide_int &w1,\n+\t\t\t  wide_int &w2, wide_int &w3,\n+\t\t\t  signop sign)\n {\n   /* Order pairs w0,w1 and w2,w3.  */\n   if (wi::gt_p (w0, w1, sign))\n@@ -177,7 +178,7 @@ wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n \t\t\t\t     overflow_undefined))\n     return false;\n \n-  wide_int_range_min_max (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);\n+  wide_int_range_order_set (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);\n   return true;\n }\n \n@@ -605,3 +606,60 @@ wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n     tmp = wi::zero (prec);\n   wmax = wi::min (wmax, tmp, sign);\n }\n+\n+/* Calculate ABS_EXPR on a range and store the result in [MIN, MAX].  */\n+\n+bool\n+wide_int_range_abs (wide_int &min, wide_int &max,\n+\t\t    signop sign, unsigned prec,\n+\t\t    const wide_int &vr0_min, const wide_int &vr0_max,\n+\t\t    bool overflow_undefined)\n+{\n+  /* Pass through VR0 the easy cases.  */\n+  if (sign == UNSIGNED || wi::ge_p (vr0_min, 0, sign))\n+    {\n+      min = vr0_min;\n+      max = vr0_max;\n+      return true;\n+    }\n+\n+  /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n+     useful range.  */\n+  wide_int min_value = wi::min_value (prec, sign);\n+  wide_int max_value = wi::max_value (prec, sign);\n+  if (!overflow_undefined && wi::eq_p (vr0_min, min_value))\n+    return false;\n+\n+  /* ABS_EXPR may flip the range around, if the original range\n+     included negative values.  */\n+  if (wi::eq_p (vr0_min, min_value))\n+    min = max_value;\n+  else\n+    min = wi::abs (vr0_min);\n+  if (wi::eq_p (vr0_max, min_value))\n+    max = max_value;\n+  else\n+    max = wi::abs (vr0_max);\n+\n+  /* If the range contains zero then we know that the minimum value in the\n+     range will be zero.  */\n+  if (wi::le_p (vr0_min, 0, sign) && wi::ge_p (vr0_max, 0, sign))\n+    {\n+      if (wi::gt_p (min, max, sign))\n+\tmax = min;\n+      min = wi::zero (prec);\n+    }\n+  else\n+    {\n+      /* If the range was reversed, swap MIN and MAX.  */\n+      if (wi::gt_p (min, max, sign))\n+\tstd::swap (min, max);\n+    }\n+\n+  /* If the new range has its limits swapped around (MIN > MAX), then\n+     the operation caused one of them to wrap around, mark the new\n+     range VARYING.  */\n+  if (wi::gt_p (min, max, sign))\n+      return false;\n+  return true;\n+}"}, {"sha": "41198e05b1352a96e5f9e66638c717d2b69305c4", "filename": "gcc/wide-int-range.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2Fwide-int-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70eff705513d3d3cd387a7b54af5e0818727a8f0/gcc%2Fwide-int-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.h?ref=70eff705513d3d3cd387a7b54af5e0818727a8f0", "patch": "@@ -94,6 +94,11 @@ extern void wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n \t\t\t\t      const wide_int &vr0_max,\n \t\t\t\t      const wide_int &vr1_min,\n \t\t\t\t      const wide_int &vr1_max);\n+extern bool wide_int_range_abs (wide_int &min, wide_int &max,\n+\t\t\t\tsignop sign, unsigned prec,\n+\t\t\t\tconst wide_int &vr0_min,\n+\t\t\t\tconst wide_int &vr0_max,\n+\t\t\t\tbool overflow_undefined);\n \n /* Return TRUE if shifting by range [MIN, MAX] is undefined behavior.  */\n \n@@ -112,4 +117,24 @@ wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n   return wi::lt_p (min, 0, sign) || wi::ge_p (max, prec, sign);\n }\n \n+/* Calculate MIN/MAX_EXPR of two ranges and store the result in [MIN, MAX].  */\n+\n+inline bool\n+wide_int_range_min_max (wide_int &min, wide_int &max,\n+\t\t\ttree_code code,\n+\t\t\tsignop sign, unsigned prec,\n+\t\t\tconst wide_int &vr0_min, const wide_int &vr0_max,\n+\t\t\tconst wide_int &vr1_min, const wide_int &vr1_max)\n+{\n+  wi::overflow_type overflow;\n+  wide_int_binop (min, code, vr0_min, vr1_min, sign, &overflow);\n+  wide_int_binop (max, code, vr0_max, vr1_max, sign, &overflow);\n+  /* If the new range covers the entire domain, that's really no range\n+     at all.  */\n+  if (min == wi::min_value (prec, sign)\n+      && max == wi::max_value (prec, sign))\n+    return false;\n+  return true;\n+}\n+\n #endif /* GCC_WIDE_INT_RANGE_H */"}]}