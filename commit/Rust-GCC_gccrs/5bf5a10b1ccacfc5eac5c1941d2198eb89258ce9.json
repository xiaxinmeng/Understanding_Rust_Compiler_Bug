{"sha": "5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJmNWExMGIxY2NhY2ZjNWVhYzVjMTk0MWQyMTk4ZWI4OTI1OGNlOQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-01-19T00:40:16Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2006-01-19T00:40:16Z"}, "message": "Introduce TLS descriptors for i386 and x86_64.\n\n* config/i386/i386.h (TARGET_GNU2_TLS): New macro.\n(TARGET_ANY_GNU_TLS): New macro.\n(enum tls_dialect): Added TLS_DIALECT_GNU2.\n(struct machine_function): Add tls_descriptor_call_expanded_p.\n(ix86_tls_descriptor_calls_expande_in_cfun): New macro.\n(ix86_current_function_calls_tls_descriptor): Likewise.\n* config/i386/i386.c (ix86_tls_dialect): Fix typo in comment.\n(override_options): Introduce gnu2 tls dialect.\n(ix86_frame_pointer_required): Functions containing TLSCALLs are\nnot leaves.\n(ix86_select_alt_pic_regnum, ix86_compute_frame_layout):\nLikewise.\n(legitimize_tls_address): Adjust logic for GNU2 TLS.\n(ix86_init_machine_status): Initialize new field.\n(ix86_tls_get_addr): Use TARGET_ANY_GNU_TLS.\n(ix86_tls_module_base): New.\n* config/i386/i386-protos.h (ix86_tls_module_base): Declare it.\n* config/i386/i386.md (UNSPEC_TLSDESC): New constant.\n(tls_global_dynamic_32, tls_global_dynamic_64): Handle GNU2 TLS.\n(tls_local_dynamic_base_32, tls_local_dynamic_base_64): Likewise.\n(tls_dynamic_gnu2_32, *tls_dynamic_lea_32): New patterns.\n(*tls_dynamic_call_32, *tls_dynamic_gnu2_combine_32): Likewise.\n(tls_dynamic_gnu2_64, *tls_dynamic_lea_64): Likewise.\n(*tls_dynamic_call_64, *tls_dynamic_gnu2_combine_64): Likewise.\n* config/i386/predicates.md (tls_modbase_operand): New.\n(tp_or_register_operand): New.\n\nFrom-SVN: r109934", "tree": {"sha": "94f58d4a859c01b37a27221773f73c4611397049", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94f58d4a859c01b37a27221773f73c4611397049"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/comments", "author": null, "committer": null, "parents": [{"sha": "7dbca013b298ba0506921f40622ae17fe9442b99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbca013b298ba0506921f40622ae17fe9442b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dbca013b298ba0506921f40622ae17fe9442b99"}], "stats": {"total": 322, "additions": 301, "deletions": 21}, "files": [{"sha": "9511cdba0412356cd359a738c73a27b19272afcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "patch": "@@ -1,3 +1,33 @@\n+2006-01-18  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tIntroduce TLS descriptors for i386 and x86_64.\n+\t* config/i386/i386.h (TARGET_GNU2_TLS): New macro.\n+\t(TARGET_ANY_GNU_TLS): New macro.\n+\t(enum tls_dialect): Added TLS_DIALECT_GNU2.\n+\t(struct machine_function): Add tls_descriptor_call_expanded_p.\n+\t(ix86_tls_descriptor_calls_expande_in_cfun): New macro.\n+\t(ix86_current_function_calls_tls_descriptor): Likewise.\n+\t* config/i386/i386.c (ix86_tls_dialect): Fix typo in comment.\n+\t(override_options): Introduce gnu2 tls dialect.\n+\t(ix86_frame_pointer_required): Functions containing TLSCALLs are\n+\tnot leaves.\n+\t(ix86_select_alt_pic_regnum, ix86_compute_frame_layout):\n+\tLikewise.\n+\t(legitimize_tls_address): Adjust logic for GNU2 TLS.\n+\t(ix86_init_machine_status): Initialize new field.\n+\t(ix86_tls_get_addr): Use TARGET_ANY_GNU_TLS.\n+\t(ix86_tls_module_base): New.\n+\t* config/i386/i386-protos.h (ix86_tls_module_base): Declare it.\n+\t* config/i386/i386.md (UNSPEC_TLSDESC): New constant.\n+\t(tls_global_dynamic_32, tls_global_dynamic_64): Handle GNU2 TLS.\n+\t(tls_local_dynamic_base_32, tls_local_dynamic_base_64): Likewise.\n+\t(tls_dynamic_gnu2_32, *tls_dynamic_lea_32): New patterns.\n+\t(*tls_dynamic_call_32, *tls_dynamic_gnu2_combine_32): Likewise.\n+\t(tls_dynamic_gnu2_64, *tls_dynamic_lea_64): Likewise.\n+\t(*tls_dynamic_call_64, *tls_dynamic_gnu2_combine_64): Likewise.\n+\t* config/i386/predicates.md (tls_modbase_operand): New.\n+\t(tp_or_register_operand): New.\n+\n 2006-01-18  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* ipa-reference.c (check_operand):  Allow FUNCTION_DECL."}, {"sha": "ed9d4f3d62e74cde6254b63b65926712a7543eb6", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "patch": "@@ -1,6 +1,7 @@\n /* Definitions of target machine for GCC for IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -179,6 +180,7 @@ extern int x86_field_alignment (tree, int);\n #endif\n \n extern rtx ix86_tls_get_addr (void);\n+extern rtx ix86_tls_module_base (void);\n \n extern void ix86_expand_vector_init (bool, rtx, rtx);\n extern void ix86_expand_vector_set (bool, rtx, rtx, int);"}, {"sha": "e45d2a266bd53ad029ea056e0e37c7fa7932f6d5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 69, "deletions": 17, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -876,7 +876,7 @@ struct ix86_frame\n enum cmodel ix86_cmodel;\n /* Asm dialect.  */\n enum asm_dialect ix86_asm_dialect = ASM_ATT;\n-/* TLS dialext.  */\n+/* TLS dialects.  */\n enum tls_dialect ix86_tls_dialect = TLS_DIALECT_GNU;\n \n /* Which unit we are generating floating point math for.  */\n@@ -1626,6 +1626,8 @@ override_options (void)\n     {\n       if (strcmp (ix86_tls_dialect_string, \"gnu\") == 0)\n \tix86_tls_dialect = TLS_DIALECT_GNU;\n+      else if (strcmp (ix86_tls_dialect_string, \"gnu2\") == 0)\n+\tix86_tls_dialect = TLS_DIALECT_GNU2;\n       else if (strcmp (ix86_tls_dialect_string, \"sun\") == 0)\n \tix86_tls_dialect = TLS_DIALECT_SUN;\n       else\n@@ -4415,7 +4417,8 @@ ix86_frame_pointer_required (void)\n      the frame pointer by default.  Turn it back on now if we've not\n      got a leaf function.  */\n   if (TARGET_OMIT_LEAF_FRAME_POINTER\n-      && (!current_function_is_leaf))\n+      && (!current_function_is_leaf\n+\t  || ix86_current_function_calls_tls_descriptor))\n     return 1;\n \n   if (current_function_profile)\n@@ -4597,7 +4600,8 @@ gen_push (rtx arg)\n static unsigned int\n ix86_select_alt_pic_regnum (void)\n {\n-  if (current_function_is_leaf && !current_function_profile)\n+  if (current_function_is_leaf && !current_function_profile\n+      && !ix86_current_function_calls_tls_descriptor)\n     {\n       int i;\n       for (i = 2; i >= 0; --i)\n@@ -4788,7 +4792,8 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      expander assumes that last current_function_outgoing_args_size\n      of stack frame are unused.  */\n   if (ACCUMULATE_OUTGOING_ARGS\n-      && (!current_function_is_leaf || current_function_calls_alloca))\n+      && (!current_function_is_leaf || current_function_calls_alloca\n+\t  || ix86_current_function_calls_tls_descriptor))\n     {\n       offset += current_function_outgoing_args_size;\n       frame->outgoing_arguments_size = current_function_outgoing_args_size;\n@@ -4798,7 +4803,8 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   /* Align stack boundary.  Only needed if we're calling another function\n      or using alloca.  */\n-  if (!current_function_is_leaf || current_function_calls_alloca)\n+  if (!current_function_is_leaf || current_function_calls_alloca\n+      || ix86_current_function_calls_tls_descriptor)\n     frame->padding2 = ((offset + preferred_alignment - 1)\n \t\t       & -preferred_alignment) - offset;\n   else\n@@ -4819,7 +4825,8 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n     frame->save_regs_using_mov = false;\n \n   if (TARGET_RED_ZONE && current_function_sp_is_unchanging\n-      && current_function_is_leaf)\n+      && current_function_is_leaf\n+      && !ix86_current_function_calls_tls_descriptor)\n     {\n       frame->red_zone_size = frame->to_allocate;\n       if (frame->save_regs_using_mov)\n@@ -6351,14 +6358,16 @@ get_thread_pointer (int to_reg)\n static rtx\n legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n {\n-  rtx dest, base, off, pic;\n+  rtx dest, base, off, pic, tp;\n   int type;\n \n   switch (model)\n     {\n     case TLS_MODEL_GLOBAL_DYNAMIC:\n       dest = gen_reg_rtx (Pmode);\n-      if (TARGET_64BIT)\n+      tp = TARGET_GNU2_TLS ? get_thread_pointer (1) : 0;\n+\n+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)\n \t{\n \t  rtx rax = gen_rtx_REG (Pmode, 0), insns;\n \n@@ -6369,13 +6378,24 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \n \t  emit_libcall_block (insns, dest, rax, x);\n \t}\n+      else if (TARGET_64BIT && TARGET_GNU2_TLS)\n+\temit_insn (gen_tls_global_dynamic_64 (dest, x));\n       else\n \temit_insn (gen_tls_global_dynamic_32 (dest, x));\n+\n+      if (TARGET_GNU2_TLS)\n+\t{\n+\t  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, dest));\n+\n+\t  set_unique_reg_note (get_last_insn (), REG_EQUIV, x);\n+\t}\n       break;\n \n     case TLS_MODEL_LOCAL_DYNAMIC:\n       base = gen_reg_rtx (Pmode);\n-      if (TARGET_64BIT)\n+      tp = TARGET_GNU2_TLS ? get_thread_pointer (1) : 0;\n+\n+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)\n \t{\n \t  rtx rax = gen_rtx_REG (Pmode, 0), insns, note;\n \n@@ -6388,13 +6408,25 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \t  note = gen_rtx_EXPR_LIST (VOIDmode, ix86_tls_get_addr (), note);\n \t  emit_libcall_block (insns, base, rax, note);\n \t}\n+      else if (TARGET_64BIT && TARGET_GNU2_TLS)\n+\temit_insn (gen_tls_local_dynamic_base_64 (base));\n       else\n \temit_insn (gen_tls_local_dynamic_base_32 (base));\n \n+      if (TARGET_GNU2_TLS)\n+\t{\n+\t  rtx x = ix86_tls_module_base ();\n+\n+\t  base = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, base));\n+\n+\t  set_unique_reg_note (get_last_insn (), REG_EQUIV, x);\n+\t}\n+\n       off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPOFF);\n       off = gen_rtx_CONST (Pmode, off);\n \n-      return gen_rtx_PLUS (Pmode, base, off);\n+      dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, base, off));\n+      break;\n \n     case TLS_MODEL_INITIAL_EXEC:\n       if (TARGET_64BIT)\n@@ -6407,9 +6439,9 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \t  if (reload_in_progress)\n \t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \t  pic = pic_offset_table_rtx;\n-\t  type = TARGET_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n+\t  type = TARGET_ANY_GNU_TLS ? UNSPEC_GOTNTPOFF : UNSPEC_GOTTPOFF;\n \t}\n-      else if (!TARGET_GNU_TLS)\n+      else if (!TARGET_ANY_GNU_TLS)\n \t{\n \t  pic = gen_reg_rtx (Pmode);\n \t  emit_insn (gen_set_got (pic));\n@@ -6428,7 +6460,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n       off = gen_const_mem (Pmode, off);\n       set_mem_alias_set (off, ix86_GOT_alias_set ());\n \n-      if (TARGET_64BIT || TARGET_GNU_TLS)\n+      if (TARGET_64BIT || TARGET_ANY_GNU_TLS)\n \t{\n           base = get_thread_pointer (for_mov || !TARGET_TLS_DIRECT_SEG_REFS);\n \t  off = force_reg (Pmode, off);\n@@ -6444,11 +6476,11 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n \n     case TLS_MODEL_LOCAL_EXEC:\n       off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x),\n-\t\t\t    (TARGET_64BIT || TARGET_GNU_TLS)\n+\t\t\t    (TARGET_64BIT || TARGET_ANY_GNU_TLS)\n \t\t\t    ? UNSPEC_NTPOFF : UNSPEC_TPOFF);\n       off = gen_rtx_CONST (Pmode, off);\n \n-      if (TARGET_64BIT || TARGET_GNU_TLS)\n+      if (TARGET_64BIT || TARGET_ANY_GNU_TLS)\n \t{\n \t  base = get_thread_pointer (for_mov || !TARGET_TLS_DIRECT_SEG_REFS);\n \t  return gen_rtx_PLUS (Pmode, base, off);\n@@ -12900,6 +12932,7 @@ ix86_init_machine_status (void)\n \n   f = ggc_alloc_cleared (sizeof (struct machine_function));\n   f->use_fast_prologue_epilogue_nregs = -1;\n+  f->tls_descriptor_call_expanded_p = 0;\n \n   return f;\n }\n@@ -12942,13 +12975,32 @@ ix86_tls_get_addr (void)\n   if (!ix86_tls_symbol)\n     {\n       ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t    (TARGET_GNU_TLS && !TARGET_64BIT)\n+\t\t\t\t\t    (TARGET_ANY_GNU_TLS\n+\t\t\t\t\t     && !TARGET_64BIT)\n \t\t\t\t\t    ? \"___tls_get_addr\"\n \t\t\t\t\t    : \"__tls_get_addr\");\n     }\n \n   return ix86_tls_symbol;\n }\n+\n+/* Construct the SYMBOL_REF for the _TLS_MODULE_BASE_ symbol.  */\n+\n+static GTY(()) rtx ix86_tls_module_base_symbol;\n+rtx\n+ix86_tls_module_base (void)\n+{\n+\n+  if (!ix86_tls_module_base_symbol)\n+    {\n+      ix86_tls_module_base_symbol = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t\t\"_TLS_MODULE_BASE_\");\n+      SYMBOL_REF_FLAGS (ix86_tls_module_base_symbol)\n+\t|= TLS_MODEL_GLOBAL_DYNAMIC << SYMBOL_FLAG_TLS_SHIFT;\n+    }\n+\n+  return ix86_tls_module_base_symbol;\n+}\n \f\n /* Calculate the length of the memory address in the instruction\n    encoding.  Does not include the one-byte modrm, opcode, or prefix.  */"}, {"sha": "b402f3d95db4433eaa2d29571c0e0385ab83c7db", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GCC for IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -225,6 +225,8 @@ extern int x86_prefetch_sse;\n \t\t\t     && (ix86_fpmath & FPMATH_387))\n \n #define TARGET_GNU_TLS (ix86_tls_dialect == TLS_DIALECT_GNU)\n+#define TARGET_GNU2_TLS (ix86_tls_dialect == TLS_DIALECT_GNU2)\n+#define TARGET_ANY_GNU_TLS (TARGET_GNU_TLS || TARGET_GNU2_TLS)\n #define TARGET_SUN_TLS (ix86_tls_dialect == TLS_DIALECT_SUN)\n \n #define TARGET_CMPXCHG (x86_cmpxchg & (1 << ix86_arch))\n@@ -2134,6 +2136,7 @@ extern enum fpmath_unit ix86_fpmath;\n enum tls_dialect\n {\n   TLS_DIALECT_GNU,\n+  TLS_DIALECT_GNU2,\n   TLS_DIALECT_SUN\n };\n \n@@ -2275,11 +2278,30 @@ struct machine_function GTY(())\n   /* Number of saved registers USE_FAST_PROLOGUE_EPILOGUE has been computed\n      for.  */\n   int use_fast_prologue_epilogue_nregs;\n+  /* If true, the current function needs the default PIC register, not\n+     an alternate register (on x86) and must not use the red zone (on\n+     x86_64), even if it's a leaf function.  We don't want the\n+     function to be regarded as non-leaf because TLS calls need not\n+     affect register allocation.  This flag is set when a TLS call\n+     instruction is expanded within a function, and never reset, even\n+     if all such instructions are optimized away.  Use the\n+     ix86_current_function_calls_tls_descriptor macro for a better\n+     approximation.  */\n+  int tls_descriptor_call_expanded_p;\n };\n \n #define ix86_stack_locals (cfun->machine->stack_locals)\n #define ix86_save_varrargs_registers (cfun->machine->save_varrargs_registers)\n #define ix86_optimize_mode_switching (cfun->machine->optimize_mode_switching)\n+#define ix86_tls_descriptor_calls_expanded_in_cfun \\\n+  (cfun->machine->tls_descriptor_call_expanded_p)\n+/* Since tls_descriptor_call_expanded is not cleared, even if all TLS\n+   calls are optimized away, we try to detect cases in which it was\n+   optimized away.  Since such instructions (use (reg REG_SP)), we can\n+   verify whether there's any such instruction live by testing that\n+   REG_SP is live.  */\n+#define ix86_current_function_calls_tls_descriptor \\\n+  (ix86_tls_descriptor_calls_expanded_in_cfun && regs_ever_live[SP_REG])\n \n /* Control behavior of x86_file_start.  */\n #define X86_FILE_START_VERSION_DIRECTIVE false"}, {"sha": "6b3b91cdc4521fa0df8969edbd1e46ff1198cf05", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 166, "deletions": 1, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "patch": "@@ -1,6 +1,6 @@\n ;; GCC machine description for IA-32 and x86-64.\n ;; Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-;; 2001, 2002, 2003, 2004, 2005\n+;; 2001, 2002, 2003, 2004, 2005, 2006\n ;; Free Software Foundation, Inc.\n ;; Mostly by William Schelter.\n ;; x86_64 support added by Jan Hubicka\n@@ -73,6 +73,7 @@\n    (UNSPEC_TP\t\t\t16)\n    (UNSPEC_TLS_GD\t\t17)\n    (UNSPEC_TLS_LD_BASE\t\t18)\n+   (UNSPEC_TLSDESC\t\t19)\n \n    ; Other random patterns\n    (UNSPEC_SCAS\t\t\t20)\n@@ -14161,6 +14162,12 @@\n       operands[2] = gen_reg_rtx (Pmode);\n       emit_insn (gen_set_got (operands[2]));\n     }\n+  if (TARGET_GNU2_TLS)\n+    {\n+       emit_insn (gen_tls_dynamic_gnu2_32\n+\t\t  (operands[0], operands[1], operands[2]));\n+       DONE;\n+    }\n   operands[3] = ix86_tls_get_addr ();\n })\n \n@@ -14182,6 +14189,12 @@\n \t\t\t UNSPEC_TLS_GD)])]\n   \"\"\n {\n+  if (TARGET_GNU2_TLS)\n+    {\n+       emit_insn (gen_tls_dynamic_gnu2_64\n+\t\t  (operands[0], operands[1]));\n+       DONE;\n+    }\n   operands[2] = ix86_tls_get_addr ();\n })\n \n@@ -14228,6 +14241,12 @@\n       operands[1] = gen_reg_rtx (Pmode);\n       emit_insn (gen_set_got (operands[1]));\n     }\n+  if (TARGET_GNU2_TLS)\n+    {\n+       emit_insn (gen_tls_dynamic_gnu2_32\n+\t\t  (operands[0], ix86_tls_module_base (), operands[1]));\n+       DONE;\n+    }\n   operands[2] = ix86_tls_get_addr ();\n })\n \n@@ -14247,6 +14266,12 @@\n \t      (unspec:DI [(const_int 0)] UNSPEC_TLS_LD_BASE)])]\n   \"\"\n {\n+  if (TARGET_GNU2_TLS)\n+    {\n+       emit_insn (gen_tls_dynamic_gnu2_64\n+\t\t  (operands[0], ix86_tls_module_base ()));\n+       DONE;\n+    }\n   operands[1] = ix86_tls_get_addr ();\n })\n \n@@ -14324,6 +14349,146 @@\n    (set_attr \"length\" \"7\")\n    (set_attr \"memory\" \"load\")\n    (set_attr \"imm_disp\" \"false\")])\n+\n+;; GNU2 TLS patterns can be split.\n+\n+(define_expand \"tls_dynamic_gnu2_32\"\n+  [(set (match_dup 3)\n+\t(plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t (const:SI\n+\t\t  (unspec:SI [(match_operand:SI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t\t     UNSPEC_TLSDESC))))\n+   (parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (unspec:SI [(match_dup 1) (match_dup 3)\n+\t\t      (match_dup 2) (reg:SI SP_REG)]\n+\t\t      UNSPEC_TLSDESC))\n+     (clobber (reg:CC FLAGS_REG))])]\n+  \"!TARGET_64BIT && TARGET_GNU2_TLS\"\n+{\n+  operands[3] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  ix86_tls_descriptor_calls_expanded_in_cfun = true;\n+})\n+\n+(define_insn \"*tls_dynamic_lea_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t (const:SI\n+\t\t  (unspec:SI [(match_operand:SI 2 \"tls_symbolic_operand\" \"\")]\n+\t\t\t      UNSPEC_TLSDESC))))]\n+  \"!TARGET_64BIT && TARGET_GNU2_TLS\"\n+  \"lea{l}\\t{%a2@TLSDESC(%1), %0|%0, %a2@TLSDESC[%1]}\"\n+  [(set_attr \"type\" \"lea\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"length_address\" \"4\")])\n+\n+(define_insn \"*tls_dynamic_call_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"tls_symbolic_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"0\")\n+\t\t    ;; we have to make sure %ebx still points to the GOT\n+\t\t    (match_operand:SI 3 \"register_operand\" \"b\")\n+\t\t    (reg:SI SP_REG)]\n+\t\t   UNSPEC_TLSDESC))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && TARGET_GNU2_TLS\"\n+  \"call\\t{*%a1@TLSCALL(%2)|[DWORD PTR [%2+%a1@TLSCALL]]}\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"length_address\" \"0\")])\n+\n+(define_insn_and_split \"*tls_dynamic_gnu2_combine_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&a\")\n+\t(plus:SI\n+\t (plus:SI (match_operand:SI 3 \"tp_or_register_operand\" \"ir\")\n+\t\t  (unspec:SI [(match_operand:SI 4 \"tls_modbase_operand\" \"\")\n+\t\t\t      (match_operand:SI 5 \"\" \"\")\n+\t\t\t      (match_operand:SI 2 \"register_operand\" \"b\")\n+\t\t\t      (reg:SI SP_REG)]\n+\t\t\t     UNSPEC_TLSDESC))\n+\t (const:SI (unspec:SI\n+\t\t    [(match_operand:SI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t    UNSPEC_DTPOFF))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && TARGET_GNU2_TLS\"\n+  \"#\"\n+  \"\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (plus:SI (match_dup 3)\n+\t\t   (match_dup 5)))\n+     (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[5] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  emit_insn (gen_tls_dynamic_gnu2_32 (operands[5], operands[1], operands[2]));\n+})\n+\n+(define_expand \"tls_dynamic_gnu2_64\"\n+  [(set (match_dup 2)\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TLSDESC))\n+   (parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t  (unspec:DI [(match_dup 1) (match_dup 2) (reg:DI SP_REG)]\n+\t\t     UNSPEC_TLSDESC))\n+     (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT && TARGET_GNU2_TLS\"\n+{\n+  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  ix86_tls_descriptor_calls_expanded_in_cfun = true;\n+})\n+\n+(define_insn \"*tls_dynamic_lea_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TLSDESC))]\n+  \"TARGET_64BIT && TARGET_GNU2_TLS\"\n+  \"lea{q}\\t{%a1@TLSDESC(%%rip), %0|%0, %a1@TLSDESC[%%rip]}\"\n+  [(set_attr \"type\" \"lea\")\n+   (set_attr \"mode\" \"DI\")\n+   (set_attr \"length\" \"7\")\n+   (set_attr \"length_address\" \"4\")])\n+\n+(define_insn \"*tls_dynamic_call_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(unspec:DI [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"0\")\n+\t\t    (reg:DI SP_REG)]\n+\t\t   UNSPEC_TLSDESC))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && TARGET_GNU2_TLS\"\n+  \"call\\t{*%a1@TLSCALL(%2)|[QWORD PTR [%2+%a1@TLSCALL]]}\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"length_address\" \"0\")])\n+\n+(define_insn_and_split \"*tls_dynamic_gnu2_combine_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&a\")\n+\t(plus:DI\n+\t (plus:DI (match_operand:DI 2 \"tp_or_register_operand\" \"ir\")\n+\t\t  (unspec:DI [(match_operand:DI 3 \"tls_modbase_operand\" \"\")\n+\t\t\t      (match_operand:DI 4 \"\" \"\")\n+\t\t\t      (reg:DI SP_REG)]\n+\t\t\t      UNSPEC_TLSDESC))\n+\t (const:DI (unspec:DI\n+\t\t    [(match_operand:DI 1 \"tls_symbolic_operand\" \"\")]\n+\t\t    UNSPEC_DTPOFF))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && TARGET_GNU2_TLS\"\n+  \"#\"\n+  \"\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (plus:DI (match_dup 2)\n+\t\t   (match_dup 4)))\n+     (clobber (reg:CC FLAGS_REG))])]\n+{\n+  operands[4] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  emit_insn (gen_tls_dynamic_gnu2_64 (operands[4], operands[1]));\n+})\n+\n+;;\n \f\n ;; These patterns match the binary 387 instructions for addM3, subM3,\n ;; mulM3 and divM3.  There are three patterns for each of DFmode and"}, {"sha": "d87284d9ab9872b9f8fbda1e40747ef71599b80f", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=5bf5a10b1ccacfc5eac5c1941d2198eb89258ce9", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for IA-32 and x86-64.\n-;; Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+;; Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -467,6 +467,15 @@\n   (and (match_code \"symbol_ref\")\n        (match_test \"SYMBOL_REF_TLS_MODEL (op) != 0\")))\n \n+(define_predicate \"tls_modbase_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"op == ix86_tls_module_base ()\")))\n+\n+(define_predicate \"tp_or_register_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"unspec\")\n+\t    (match_test \"XINT (op, 1) == UNSPEC_TP\"))))\n+\n ;; Test for a pc-relative call operand\n (define_predicate \"constant_call_address_operand\"\n   (ior (match_code \"symbol_ref\")"}]}