{"sha": "d3f70b35df36f20ad887de0adc150d0b3dd186cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNmNzBiMzVkZjM2ZjIwYWQ4ODdkZTBhZGMxNTBkMGIzZGQxODZjYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T09:52:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T09:52:57Z"}, "message": "[multiple changes]\n\n2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-fihema.ads, a-fihema.adb: Unit removed.\n\t* a-undesu.ads, a-undesu.adb: New unit implementing\n\tAda.Unchecked_Deallocate_Subpool.\n\t* einfo.adb: Remove Associated_Collection from the node usage.\n\tAdd Finalization_Master to the node usage.\n\t(Associated_Collection): Removed.\n\t(Finalization_Master): New routine.\n\t(Set_Associated_Collection): Removed.\n\t(Set_Finalization_Master): New routine.\n\t(Write_Field23_Name): Remove Associated_Collection from the output. Add\n\tFinalization_Master to the output.\n\t* einfo.ads: Remove attribute Associated_Collection and its uses in\n\tentities.\n\tAdd new attribute Finalization_Master along with its uses in entitites.\n\t(Associated_Collection): Removed along with its pragma import.\n\t(Finalization_Master): New routine along with a pragma import.\n\t(Set_Associated_Collection): Removed along with its pragma import.\n\t(Set_Finalization_Master): New routine along with a pragma import.\n\t* exp_ch3.adb (Expand_Freeze_Array_Type): Replace call to\n\tBuild_Finalization_Collection with Build_Finalization_Master.\n\t(Expand_Freeze_Record_Type): Move the generation of Finalize_Address\n\tbefore the bodies of the predefined routines. Add comment explaining\n\tthis. Replace call to Build_Finalization_Collection with\n\tBuild_Finalization_Master.\n\t(Freeze_Type): Replace call to Build_Finalization_Collection with\n\tBuild_Finalization_Master.\n\t(Make_Finalize_Address_Body): Comment reformatting.\n\t(Make_Predefined_Primitive_Specs): Code reformatting.\n\t(Stream_Operation_OK): Update comment mentioning finalization\n\tcollections. Replace RE_Finalization_Collection with\n\tRE_Finalization_Master.\n\t* exp_ch4.adb (Complete_Controlled_Allocation): Replace call to\n\tAssociated_Collection with Finalization_Master. Replace call to\n\tBuild_Finalization_Collection with Build_Finalization_Master.\n\t(Expand_Allocator_Expression): Replace call to Associated_Collection\n\twith Finalization_Master. Replace call to Set_Associated_Collection with\n\tSet_Finalization_Master. Remove the generation of\n\tSet_Finalize_Address_Ptr.\n\t(Expand_N_Allocator): Replace call to Associated_Collection with\n\tFinalization_Master. Remove the generation of Set_Finalize_Address_Ptr.\n\t* exp_ch6.adb (Add_Collection_Actual_To_Build_In_Place_Call): Renamed to\n\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call. Update the\n\tcomment on usage. Replace call to Needs_BIP_Collection with\n\tNeeds_BIP_Finalization_Master Remplace BIP_Collection with\n\tBIP_Finalization_Master. Update all comments which mention finalization\n\tcollections. Replace Associated_Collection with\n\tFinalization_Master. Replace Build_Finalization_Collection with\n\tBuild_Finalization_Master.\n\t(BIP_Formal_Suffix): Update BIP_Collection's case.\n\t(Build_Heap_Allocator): Update the related comment. Rename local\n\tvariable Collect to Fin_Mas_Id and update its occurrences. Update\n\tcomments which mention finalization collections. Replace\n\tSet_Associated_Collection with Set_Finalization_Master.\n\t(Expand_Call): Update the code which detects a special piece of library\n\tcode for .NET/JVM.\n\t(Make_Build_In_Place_Call_In_Allocator): Replace the call to\n\tAdd_Collection_Actual_To_Build_In_Place_Call with\n\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call. Remove the code\n\twhich generates a call to Make_Set_Finalize_Address_Ptr_Call.\n\t(Make_Build_In_Place_Call_In_Anonymous_Context): Replace call to\n\tAdd_Collection_Actual_To_Build_In_Place_Call with\n\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call.\n\t(Make_Build_In_Place_Call_In_Assignment): Replace call to\n\tAdd_Collection_Actual_To_Build_In_Place_Call with\n\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call.\n\t(Needs_BIP_Collection): Renamed to Needs_BIP_Finalization_Master.\n\t* exp_ch6.ads: Rename BIP_Collection to BIP_Finalization_Master.\n\t(Needs_BIP_Collection): Renamed to Needs_BIP_Finalization_Master.\n\t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Update comment on usage.\n\tRename local variable Collect to Fin_Mas_Id and update its occurrences.\n\tReplace call to Set_Associated_Collection with Set_Finalization_Master.\n\t(Build_Finalization_Collection): Renamed to Build_Finalization_Master.\n\tReplace the call to Associated_Collection with Finalization_Master.\n\tRename local variable Coll_Id to Fin_Mas_Id and update its occurrences.\n\tUpdate the way finalization master names are generated. Update the\n\tretrieval of the correct access type which will carry the pool and\n\tmaster attributes.\n\t(Make_Final_Call): Reimplement the way [Deep_]Finalize is retrieved.\n\t(Make_Finalize_Address_Body): Abstract types do not need\n\tFinalize_Address. Code reformatting.\n\t(Make_Finalize_Address_Stmts): Update comment on usage.\n\t(Make_Set_Finalize_Address_Ptr_Call): Removed.\n\t(Process_Declarations): Update comments.\n\t* exp_ch7.ads (Build_Finalization_Collection): Renamed to\n\tBuild_Finalization_Master. Update associated comment.\n\t(Make_Set_Finalize_Address_Ptr_Call): Removed.\n\t* exp_ch13.adb: Update comments which mention finalization collections.\n\t(Expand_N_Free_Statement): Replace the call to Associated_Collection\n\twith Finalization_Master.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Reimplemented to\n\tcreate calls to routines Allocate_Any_Controlled and\n\tDeallocate_Any_Controlled.\n\t(Find_Finalize_Address): New routine.\n\t(Is_Allocate_Deallocate_Proc): Update the RTE entities used in the\n\tcomparison.\n\t(Requires_Cleanup_Actions): Update the comment on freeze node\n\tinspection.\n\t* exp_util.ads: Remove comment on generated code for\n\tBuild_Allocate_Deallocate_Proc. The code is now quite complex and it\n\tis better to simply look in the body.\n\t* freeze.adb (Freeze_All): Update the comment of finalization\n\tcollections. Replace the call to Associated_Collection with\n\tFinalization_Master. Replace the call to Build_Finalization_Collection\n\twith Build_Finalization_Master.\n\t* impunit.adb: Add a-undesu and s-stposu to the list of units.\n\t* Makefile.rtl: Add files a-undesu, s-finmas and s-stposu. Remove file\n\ta-fihema.\n\t* rtsfind.adb (Get_Unit_Name): Remove the processing for children of\n\tAda.Finalization. Add processing for children of System.Storage_Pools.\n\t* rtsfind.ads: Remove the naming of second level children of\n\tAda.Finalization.\n\tRemove Ada_Finalization_Heap_Management from the list of units.\n\tRemove subtype Ada_Finalization_Child.\n\tRemove the following subprogram entities:\n\t\n\t   RE_Allocate\n\t   RE_Deallocate\n\t   RE_Finalization_Collection\n\t   RE_Finalization_Collection_Ptr\n\t   RE_Set_Finalize_Address_Ptr\n\t\n\tAdd the naming of second level children of System.Storage_Pools.\n\tAdd System_Finalization_Masters and System_Storage_Pools_Subpools to\n\tthe list of units.\n\tAdd subtype System_Storage_Pools_Child.\n\tAdd the following subprogram entities to System.Finalization_Masters:\n\t\n\t   RE_Finalization_Master\n\t   RE_Finalization_Master_Ptr\n\t\n\tAdd the following subprogram entities to System.Storage_Pools.Subpools:\n\t\n\t   RE_Allocate_Any_Controlled\n\t   RE_Deallocate_Any_Controlled\n\t   RE_Root_Storage_Pool_With_Subpools\n\t   RE_Root_Subpool\n\t   RE_Subpool_Handle\n\t\n\tMove the following subprogram entities from\n\tAda.Finalization.Heap_Management to System.Finalization_Masters:\n\t\n\t   RE_Add_Offset_To_Address\n\t   RE_Attach\n\t   RE_Base_Pool\n\t   RE_Detach\n\t\n\t* sem_ch3.adb (Access_Type_Declaration): Replace the call to\n\tSet_Associated_Collection with Set_Finalization_Master.\n\t* sem_ch6.adb (Create_Extra_Formals): Update the way extra formal\n\tBIP_Finalization_Master is created.\n\t* s-finmas.adb: New unit System.Finalization_Masters.\n\t* s-finmas.ads: New unit System.Finalization_Masters.\n\t* s-stopoo.ads, s-stopoo.adb: Minor code reformatting.\n\t* s-stposu.ads, s-stposu.adb: New unit implementing\n\tSystem.Storage_Pools.Subpools.\n\n2011-08-29  Bob Duff  <duff@adacore.com>\n\n\t* tbuild.adb: Add assertion.\n\nFrom-SVN: r178183", "tree": {"sha": "f70a40b65e9047bcf6e86a203d73f616a8c976dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f70a40b65e9047bcf6e86a203d73f616a8c976dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3f70b35df36f20ad887de0adc150d0b3dd186cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f70b35df36f20ad887de0adc150d0b3dd186cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f70b35df36f20ad887de0adc150d0b3dd186cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f70b35df36f20ad887de0adc150d0b3dd186cc/comments", "author": null, "committer": null, "parents": [{"sha": "8c889ae483adccb124c7104e6c0e1ab274bd3677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c889ae483adccb124c7104e6c0e1ab274bd3677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c889ae483adccb124c7104e6c0e1ab274bd3677"}], "stats": {"total": 3308, "additions": 1912, "deletions": 1396}, "files": [{"sha": "90001baf6995f047efff243a2a7aa19dd6457b62", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -1,3 +1,165 @@\n+2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-fihema.ads, a-fihema.adb: Unit removed.\n+\t* a-undesu.ads, a-undesu.adb: New unit implementing\n+\tAda.Unchecked_Deallocate_Subpool.\n+\t* einfo.adb: Remove Associated_Collection from the node usage.\n+\tAdd Finalization_Master to the node usage.\n+\t(Associated_Collection): Removed.\n+\t(Finalization_Master): New routine.\n+\t(Set_Associated_Collection): Removed.\n+\t(Set_Finalization_Master): New routine.\n+\t(Write_Field23_Name): Remove Associated_Collection from the output. Add\n+\tFinalization_Master to the output.\n+\t* einfo.ads: Remove attribute Associated_Collection and its uses in\n+\tentities.\n+\tAdd new attribute Finalization_Master along with its uses in entitites.\n+\t(Associated_Collection): Removed along with its pragma import.\n+\t(Finalization_Master): New routine along with a pragma import.\n+\t(Set_Associated_Collection): Removed along with its pragma import.\n+\t(Set_Finalization_Master): New routine along with a pragma import.\n+\t* exp_ch3.adb (Expand_Freeze_Array_Type): Replace call to\n+\tBuild_Finalization_Collection with Build_Finalization_Master.\n+\t(Expand_Freeze_Record_Type): Move the generation of Finalize_Address\n+\tbefore the bodies of the predefined routines. Add comment explaining\n+\tthis. Replace call to Build_Finalization_Collection with\n+\tBuild_Finalization_Master.\n+\t(Freeze_Type): Replace call to Build_Finalization_Collection with\n+\tBuild_Finalization_Master.\n+\t(Make_Finalize_Address_Body): Comment reformatting.\n+\t(Make_Predefined_Primitive_Specs): Code reformatting.\n+\t(Stream_Operation_OK): Update comment mentioning finalization\n+\tcollections. Replace RE_Finalization_Collection with\n+\tRE_Finalization_Master.\n+\t* exp_ch4.adb (Complete_Controlled_Allocation): Replace call to\n+\tAssociated_Collection with Finalization_Master. Replace call to\n+\tBuild_Finalization_Collection with Build_Finalization_Master.\n+\t(Expand_Allocator_Expression): Replace call to Associated_Collection\n+\twith Finalization_Master. Replace call to Set_Associated_Collection with\n+\tSet_Finalization_Master. Remove the generation of\n+\tSet_Finalize_Address_Ptr.\n+\t(Expand_N_Allocator): Replace call to Associated_Collection with\n+\tFinalization_Master. Remove the generation of Set_Finalize_Address_Ptr.\n+\t* exp_ch6.adb (Add_Collection_Actual_To_Build_In_Place_Call): Renamed to\n+\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call. Update the\n+\tcomment on usage. Replace call to Needs_BIP_Collection with\n+\tNeeds_BIP_Finalization_Master Remplace BIP_Collection with\n+\tBIP_Finalization_Master. Update all comments which mention finalization\n+\tcollections. Replace Associated_Collection with\n+\tFinalization_Master. Replace Build_Finalization_Collection with\n+\tBuild_Finalization_Master.\n+\t(BIP_Formal_Suffix): Update BIP_Collection's case.\n+\t(Build_Heap_Allocator): Update the related comment. Rename local\n+\tvariable Collect to Fin_Mas_Id and update its occurrences. Update\n+\tcomments which mention finalization collections. Replace\n+\tSet_Associated_Collection with Set_Finalization_Master.\n+\t(Expand_Call): Update the code which detects a special piece of library\n+\tcode for .NET/JVM.\n+\t(Make_Build_In_Place_Call_In_Allocator): Replace the call to\n+\tAdd_Collection_Actual_To_Build_In_Place_Call with\n+\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call. Remove the code\n+\twhich generates a call to Make_Set_Finalize_Address_Ptr_Call.\n+\t(Make_Build_In_Place_Call_In_Anonymous_Context): Replace call to\n+\tAdd_Collection_Actual_To_Build_In_Place_Call with\n+\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call.\n+\t(Make_Build_In_Place_Call_In_Assignment): Replace call to\n+\tAdd_Collection_Actual_To_Build_In_Place_Call with\n+\tAdd_Finalization_Master_Actual_To_Build_In_Place_Call.\n+\t(Needs_BIP_Collection): Renamed to Needs_BIP_Finalization_Master.\n+\t* exp_ch6.ads: Rename BIP_Collection to BIP_Finalization_Master.\n+\t(Needs_BIP_Collection): Renamed to Needs_BIP_Finalization_Master.\n+\t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Update comment on usage.\n+\tRename local variable Collect to Fin_Mas_Id and update its occurrences.\n+\tReplace call to Set_Associated_Collection with Set_Finalization_Master.\n+\t(Build_Finalization_Collection): Renamed to Build_Finalization_Master.\n+\tReplace the call to Associated_Collection with Finalization_Master.\n+\tRename local variable Coll_Id to Fin_Mas_Id and update its occurrences.\n+\tUpdate the way finalization master names are generated. Update the\n+\tretrieval of the correct access type which will carry the pool and\n+\tmaster attributes.\n+\t(Make_Final_Call): Reimplement the way [Deep_]Finalize is retrieved.\n+\t(Make_Finalize_Address_Body): Abstract types do not need\n+\tFinalize_Address. Code reformatting.\n+\t(Make_Finalize_Address_Stmts): Update comment on usage.\n+\t(Make_Set_Finalize_Address_Ptr_Call): Removed.\n+\t(Process_Declarations): Update comments.\n+\t* exp_ch7.ads (Build_Finalization_Collection): Renamed to\n+\tBuild_Finalization_Master. Update associated comment.\n+\t(Make_Set_Finalize_Address_Ptr_Call): Removed.\n+\t* exp_ch13.adb: Update comments which mention finalization collections.\n+\t(Expand_N_Free_Statement): Replace the call to Associated_Collection\n+\twith Finalization_Master.\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Reimplemented to\n+\tcreate calls to routines Allocate_Any_Controlled and\n+\tDeallocate_Any_Controlled.\n+\t(Find_Finalize_Address): New routine.\n+\t(Is_Allocate_Deallocate_Proc): Update the RTE entities used in the\n+\tcomparison.\n+\t(Requires_Cleanup_Actions): Update the comment on freeze node\n+\tinspection.\n+\t* exp_util.ads: Remove comment on generated code for\n+\tBuild_Allocate_Deallocate_Proc. The code is now quite complex and it\n+\tis better to simply look in the body.\n+\t* freeze.adb (Freeze_All): Update the comment of finalization\n+\tcollections. Replace the call to Associated_Collection with\n+\tFinalization_Master. Replace the call to Build_Finalization_Collection\n+\twith Build_Finalization_Master.\n+\t* impunit.adb: Add a-undesu and s-stposu to the list of units.\n+\t* Makefile.rtl: Add files a-undesu, s-finmas and s-stposu. Remove file\n+\ta-fihema.\n+\t* rtsfind.adb (Get_Unit_Name): Remove the processing for children of\n+\tAda.Finalization. Add processing for children of System.Storage_Pools.\n+\t* rtsfind.ads: Remove the naming of second level children of\n+\tAda.Finalization.\n+\tRemove Ada_Finalization_Heap_Management from the list of units.\n+\tRemove subtype Ada_Finalization_Child.\n+\tRemove the following subprogram entities:\n+\t\n+\t   RE_Allocate\n+\t   RE_Deallocate\n+\t   RE_Finalization_Collection\n+\t   RE_Finalization_Collection_Ptr\n+\t   RE_Set_Finalize_Address_Ptr\n+\t\n+\tAdd the naming of second level children of System.Storage_Pools.\n+\tAdd System_Finalization_Masters and System_Storage_Pools_Subpools to\n+\tthe list of units.\n+\tAdd subtype System_Storage_Pools_Child.\n+\tAdd the following subprogram entities to System.Finalization_Masters:\n+\t\n+\t   RE_Finalization_Master\n+\t   RE_Finalization_Master_Ptr\n+\t\n+\tAdd the following subprogram entities to System.Storage_Pools.Subpools:\n+\t\n+\t   RE_Allocate_Any_Controlled\n+\t   RE_Deallocate_Any_Controlled\n+\t   RE_Root_Storage_Pool_With_Subpools\n+\t   RE_Root_Subpool\n+\t   RE_Subpool_Handle\n+\t\n+\tMove the following subprogram entities from\n+\tAda.Finalization.Heap_Management to System.Finalization_Masters:\n+\t\n+\t   RE_Add_Offset_To_Address\n+\t   RE_Attach\n+\t   RE_Base_Pool\n+\t   RE_Detach\n+\t\n+\t* sem_ch3.adb (Access_Type_Declaration): Replace the call to\n+\tSet_Associated_Collection with Set_Finalization_Master.\n+\t* sem_ch6.adb (Create_Extra_Formals): Update the way extra formal\n+\tBIP_Finalization_Master is created.\n+\t* s-finmas.adb: New unit System.Finalization_Masters.\n+\t* s-finmas.ads: New unit System.Finalization_Masters.\n+\t* s-stopoo.ads, s-stopoo.adb: Minor code reformatting.\n+\t* s-stposu.ads, s-stposu.adb: New unit implementing\n+\tSystem.Storage_Pools.Subpools.\n+\n+2011-08-29  Bob Duff  <duff@adacore.com>\n+\n+\t* tbuild.adb: Add assertion.\n+\n 2011-08-29  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-pooglo.adb: Minor reformatting."}, {"sha": "16255b862b33f4a8f3883999ffbd10e481d0a1b1", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -154,7 +154,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-envvar$(objext) \\\n   a-except$(objext) \\\n   a-exctra$(objext) \\\n-  a-fihema$(objext) \\\n   a-finali$(objext) \\\n   a-flteio$(objext) \\\n   a-fwteio$(objext) \\\n@@ -290,6 +289,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-tiunio$(objext) \\\n   a-unccon$(objext) \\\n   a-uncdea$(objext) \\\n+  a-undesu$(objext) \\\n   a-wichha$(objext) \\\n   a-wichun$(objext) \\\n   a-widcha$(objext) \\\n@@ -495,6 +495,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-ficobl$(objext) \\\n   s-fileio$(objext) \\\n   s-filofl$(objext) \\\n+  s-finmas$(objext) \\\n   s-finroo$(objext) \\\n   s-fishfl$(objext) \\\n   s-flocon$(objext) \\\n@@ -611,6 +612,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-stchop$(objext) \\\n   s-stoele$(objext) \\\n   s-stopoo$(objext) \\\n+  s-stposu$(objext) \\\n   s-stratt$(objext) \\\n   s-strhas$(objext) \\\n   s-string$(objext) \\"}, {"sha": "2eadd0cdf16475d0617532ad12d2ad02b59b7afa", "filename": "gcc/ada/a-fihema.adb", "status": "removed", "additions": 0, "deletions": 568, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c889ae483adccb124c7104e6c0e1ab274bd3677/gcc%2Fada%2Fa-fihema.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c889ae483adccb124c7104e6c0e1ab274bd3677/gcc%2Fada%2Fa-fihema.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.adb?ref=8c889ae483adccb124c7104e6c0e1ab274bd3677", "patch": "@@ -1,568 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---     A D A . F I N A L I Z A T I O N . H E A P _ M A N A G E M E N T      --\n---                                                                          --\n---                                B o d y                                   --\n---                                                                          --\n---          Copyright (C) 2008-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Exceptions;          use Ada.Exceptions;\n-with Ada.Unchecked_Conversion;\n-\n-with System;                  use System;\n-with System.Address_Image;\n-with System.IO;               use System.IO;\n---  ???with System.OS_Lib;\n---  Breaks ravenscar runtimes\n-with System.Soft_Links;       use System.Soft_Links;\n-with System.Storage_Elements; use System.Storage_Elements;\n-with System.Storage_Pools;    use System.Storage_Pools;\n-\n-package body Ada.Finalization.Heap_Management is\n-\n-   Debug : constant Boolean := False;\n-   --  True for debugging printouts.\n-\n-   Header_Size : constant Storage_Count  := Node'Size / Storage_Unit;\n-   --  Size of the header in bytes. Added to Storage_Size requested by\n-   --  Allocate/Deallocate to determine the Storage_Size passed to the\n-   --  underlying pool.\n-\n-   function Address_To_Node_Ptr is\n-     new Ada.Unchecked_Conversion (Address, Node_Ptr);\n-\n-   procedure Attach (N : Node_Ptr; L : Node_Ptr);\n-   --  Prepend a node to a list\n-\n-   procedure Detach (N : Node_Ptr);\n-   --  Unhook a node from an arbitrary list\n-\n-   procedure Fin_Assert (Condition : Boolean; Message : String);\n-   --  Asserts that the condition is True. Used instead of pragma Assert in\n-   --  delicate places where raising an exception would cause re-invocation of\n-   --  finalization. Instead of raising an exception, aborts the whole process.\n-\n-   function Is_Empty (Objects : Node_Ptr) return Boolean;\n-   --  True if the Objects list is empty\n-\n-   ----------------\n-   -- Fin_Assert --\n-   ----------------\n-\n-   procedure Fin_Assert (Condition : Boolean; Message : String) is\n-\n-      procedure Fail;\n-      --  Use a separate procedure to make it easy to set a breakpoint here.\n-\n-      ----------\n-      -- Fail --\n-      ----------\n-\n-      procedure Fail is\n-      begin\n-         Put_Line (\"Heap_Management: Fin_Assert failed: \" & Message);\n-         --  ???OS_Lib.OS_Abort;\n-         --  Breaks ravenscar runtimes\n-      end Fail;\n-\n-   --  Start of processing for Fin_Assert\n-\n-   begin\n-      if not Condition then\n-         Fail;\n-      end if;\n-   end Fin_Assert;\n-\n-   ---------------------------\n-   -- Add_Offset_To_Address --\n-   ---------------------------\n-\n-   function Add_Offset_To_Address\n-     (Addr   : System.Address;\n-      Offset : System.Storage_Elements.Storage_Offset) return System.Address\n-   is\n-   begin\n-      return System.Storage_Elements.\"+\" (Addr, Offset);\n-   end Add_Offset_To_Address;\n-\n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   procedure Allocate\n-     (Collection   : in out Finalization_Collection;\n-      Addr         : out System.Address;\n-      Storage_Size : System.Storage_Elements.Storage_Count;\n-      Alignment    : System.Storage_Elements.Storage_Count;\n-      Needs_Header : Boolean := True)\n-   is\n-   begin\n-      --  Allocation of an object with controlled parts\n-\n-      if Needs_Header then\n-\n-         --  Do not allow the allocation of controlled objects while the\n-         --  associated collection is being finalized.\n-\n-         if Collection.Finalization_Started then\n-            raise Program_Error with \"allocation after finalization started\";\n-         end if;\n-\n-         declare\n-            Header_Offset : Storage_Offset;\n-            N_Addr        : Address;\n-            N_Ptr         : Node_Ptr;\n-\n-         begin\n-            --  Offset from the header to the actual object. The header is\n-            --  just in front of the object. There may be padding space before\n-            --  the header.\n-\n-            if Alignment > Header_Size then\n-               Header_Offset := Alignment;\n-            else\n-               Header_Offset := Header_Size;\n-            end if;\n-\n-            --  Use the underlying pool to allocate enough space for the object\n-            --  and the list header. The returned address points to the list\n-            --  header. If locking is necessary, it will be done by the\n-            --  underlying pool.\n-\n-            Allocate\n-              (Collection.Base_Pool.all,\n-               N_Addr,\n-               Storage_Size + Header_Offset,\n-               Alignment);\n-\n-            --  Map the allocated memory into a Node record. This converts the\n-            --  top of the allocated bits into a list header.\n-\n-            N_Ptr := Address_To_Node_Ptr\n-              (N_Addr + Header_Offset - Header_Size);\n-            Attach (N_Ptr, Collection.Objects'Unchecked_Access);\n-\n-            --  Move the address from Prev to the start of the object. This\n-            --  operation effectively hides the list header.\n-\n-            Addr := N_Addr + Header_Offset;\n-         end;\n-\n-      --  Allocation of a non-controlled object\n-\n-      else\n-         Allocate\n-           (Collection.Base_Pool.all,\n-            Addr,\n-            Storage_Size,\n-            Alignment);\n-      end if;\n-\n-      pragma Assert (Addr mod Alignment = 0);\n-   end Allocate;\n-\n-   ------------\n-   -- Attach --\n-   ------------\n-\n-   procedure Attach (N : Node_Ptr; L : Node_Ptr) is\n-   begin\n-      Lock_Task.all;\n-\n-      L.Next.Prev := N;\n-      N.Next := L.Next;\n-      L.Next := N;\n-      N.Prev := L;\n-\n-      Unlock_Task.all;\n-\n-      --  Note: no need to unlock in case of exceptions; the above code cannot\n-      --  raise any.\n-\n-   end Attach;\n-\n-   ---------------\n-   -- Base_Pool --\n-   ---------------\n-\n-   function Base_Pool\n-     (Collection : Finalization_Collection) return Any_Storage_Pool_Ptr\n-   is\n-   begin\n-      return Collection.Base_Pool;\n-   end Base_Pool;\n-\n-   ----------------\n-   -- Deallocate --\n-   ----------------\n-\n-   procedure Deallocate\n-     (Collection   : in out Finalization_Collection;\n-      Addr         : System.Address;\n-      Storage_Size : System.Storage_Elements.Storage_Count;\n-      Alignment    : System.Storage_Elements.Storage_Count;\n-      Has_Header   : Boolean := True)\n-   is\n-      pragma Assert (Addr mod Alignment = 0);\n-   begin\n-      --  Deallocation of an object with controlled parts\n-\n-      if Has_Header then\n-         declare\n-            Header_Offset : Storage_Offset;\n-            N_Addr        : Address;\n-            N_Ptr         : Node_Ptr;\n-\n-         begin\n-            --  Offset from the header to the actual object.\n-\n-            if Alignment > Header_Size then\n-               Header_Offset := Alignment;\n-            else\n-               Header_Offset := Header_Size;\n-            end if;\n-\n-            --  Converts from the object to the list header\n-\n-            N_Ptr := Address_To_Node_Ptr (Addr - Header_Size);\n-            Detach (N_Ptr);\n-\n-            --  Converts the bits preceding the object the block address.\n-\n-            N_Addr := Addr - Header_Offset;\n-\n-            --  Use the underlying pool to destroy the object along with the\n-            --  list header.\n-\n-            Deallocate\n-              (Collection.Base_Pool.all,\n-               N_Addr,\n-               Storage_Size + Header_Size,\n-               Alignment);\n-         end;\n-\n-      --  Deallocation of a non-controlled object\n-\n-      else\n-         Deallocate\n-           (Collection.Base_Pool.all,\n-            Addr,\n-            Storage_Size,\n-            Alignment);\n-      end if;\n-   end Deallocate;\n-\n-   ------------\n-   -- Detach --\n-   ------------\n-\n-   procedure Detach (N : Node_Ptr) is\n-   begin\n-      pragma Debug (Fin_Assert (N /= null, \"Detach null\"));\n-\n-      Lock_Task.all;\n-\n-      if N.Next = null then\n-         pragma Assert (N.Prev = null);\n-\n-      else\n-         N.Prev.Next := N.Next;\n-         N.Next.Prev := N.Prev;\n-         N.Next := null;\n-         N.Prev := null;\n-      end if;\n-\n-      Unlock_Task.all;\n-\n-      --  Note: no need to unlock in case of exceptions; the above code cannot\n-      --  raise any.\n-\n-   end Detach;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   overriding procedure Finalize\n-     (Collection : in out Finalization_Collection)\n-   is\n-      Ex_Occur : Exception_Occurrence;\n-      Raised   : Boolean := False;\n-\n-   begin\n-      if Debug then\n-         Put_Line (\"-->Heap_Management: \");\n-         pcol (Collection);\n-      end if;\n-\n-      --  Set Finalization_Started to prevent any allocations of objects with\n-      --  controlled parts during finalization. The associated access type is\n-      --  about to go out of scope; Finalization_Started is never again\n-      --  modified.\n-\n-      if Collection.Finalization_Started then\n-\n-         --  ???Needed for shared libraries\n-\n-         return;\n-      end if;\n-\n-      pragma Debug (Fin_Assert (not Collection.Finalization_Started,\n-                                \"Finalize: already started\"));\n-      Collection.Finalization_Started := True;\n-\n-      --  For each object in the Objects list, detach it, and finalize it. Note\n-      --  that other tasks can be doing Unchecked_Deallocations at the same\n-      --  time, so we need to beware of race conditions.\n-\n-      while not Is_Empty (Collection.Objects'Unchecked_Access) loop\n-\n-         declare\n-            Node : constant Node_Ptr := Collection.Objects.Next;\n-         begin\n-            --  Remove the current node from the list first, in case some other\n-            --  task is simultaneously doing Unchecked_Deallocation on this\n-            --  object. Detach does Lock_Task. Note that we can't Lock_Task\n-            --  during Finalize_Address, because finalization can do pretty\n-            --  much anything.\n-\n-            Detach (Node);\n-\n-            --  ??? Kludge: Don't do anything until the proper place to set\n-            --  primitive Finalize_Address has been determined.\n-\n-            if Collection.Finalize_Address /= null then\n-               declare\n-                  Object_Address : constant Address :=\n-                                     Node.all'Address + Header_Size;\n-                  --  Get address of object from address of header\n-\n-               begin\n-                  Collection.Finalize_Address (Object_Address);\n-               exception\n-                  when Fin_Except : others =>\n-                     if not Raised then\n-                        Raised := True;\n-                        Save_Occurrence (Ex_Occur, Fin_Except);\n-                     end if;\n-               end;\n-            end if;\n-         end;\n-      end loop;\n-\n-      if Debug then\n-         Put_Line (\"<--Heap_Management: \");\n-         pcol (Collection);\n-      end if;\n-\n-      --  If the finalization of a particular node raised an exception, reraise\n-      --  it after the remainder of the list has been finalized.\n-\n-      if Raised then\n-         if Debug then\n-            Put_Line (\"Heap_Management: reraised\");\n-         end if;\n-\n-         Reraise_Occurrence (Ex_Occur);\n-      end if;\n-   end Finalize;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   overriding procedure Initialize\n-     (Collection : in out Finalization_Collection)\n-   is\n-   begin\n-      --  The dummy head must point to itself in both directions\n-\n-      Collection.Objects.Next := Collection.Objects'Unchecked_Access;\n-      Collection.Objects.Prev := Collection.Objects'Unchecked_Access;\n-      pragma Assert (Is_Empty (Collection.Objects'Unchecked_Access));\n-   end Initialize;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Objects : Node_Ptr) return Boolean is\n-   begin\n-      pragma Debug\n-        (Fin_Assert ((Objects.Next = Objects) = (Objects.Prev = Objects),\n-                     \"Is_Empty\"));\n-      return Objects.Next = Objects;\n-   end Is_Empty;\n-\n-   ----------\n-   -- pcol --\n-   ----------\n-\n-   procedure pcol (Collection : Finalization_Collection) is\n-      Head      : constant Node_Ptr := Collection.Objects'Unrestricted_Access;\n-      --  \"Unrestricted\", because we are getting access-to-variable of a\n-      --  constant! Normally worrisome, this is OK for debugging code.\n-\n-      Head_Seen : Boolean := False;\n-      N_Ptr     : Node_Ptr;\n-\n-   begin\n-      --  Output the basic contents of the collection\n-\n-      --    Collection: 0x123456789\n-      --    Base_Pool : null <or> 0x123456789\n-      --    Fin_Addr  : null <or> 0x123456789\n-      --    Fin_Start : TRUE <or> FALSE\n-\n-      Put (\"Collection: \");\n-      Put_Line (Address_Image (Collection'Address));\n-\n-      Put (\"Base_Pool : \");\n-\n-      if Collection.Base_Pool = null then\n-         Put_Line (\" null\");\n-      else\n-         Put_Line (Address_Image (Collection.Base_Pool'Address));\n-      end if;\n-\n-      Put (\"Fin_Addr  : \");\n-\n-      if Collection.Finalize_Address = null then\n-         Put_Line (\"null\");\n-      else\n-         Put_Line (Address_Image (Collection.Finalize_Address'Address));\n-      end if;\n-\n-      Put (\"Fin_Start : \");\n-      Put_Line (Collection.Finalization_Started'Img);\n-\n-      --  Output all chained elements. The format is the following:\n-\n-      --    ^ <or> ? <or> null\n-      --    |Header: 0x123456789 (dummy head)\n-      --    |  Prev: 0x123456789\n-      --    |  Next: 0x123456789\n-      --    V\n-\n-      --  ^ - the current element points back to the correct element\n-      --  ? - the current element points back to an erroneous element\n-      --  n - the current element points back to null\n-\n-      --  Header - the address of the list header\n-      --  Prev   - the address of the list header which the current element\n-      --         - points back to\n-      --  Next   - the address of the list header which the current element\n-      --         - points to\n-      --  (dummy head) - present if dummy head\n-\n-      N_Ptr := Head;\n-      while N_Ptr /= null loop -- Should never be null; we being defensive\n-         Put_Line (\"V\");\n-\n-         --  We see the head initially; we want to exit when we see the head a\n-         --  SECOND time.\n-\n-         if N_Ptr = Head then\n-            exit when Head_Seen;\n-\n-            Head_Seen := True;\n-         end if;\n-\n-         --  The current element is null. This should never happen since the\n-         --  list is circular.\n-\n-         if N_Ptr.Prev = null then\n-            Put_Line (\"null (ERROR)\");\n-\n-         --  The current element points back to the correct element\n-\n-         elsif N_Ptr.Prev.Next = N_Ptr then\n-            Put_Line (\"^\");\n-\n-         --  The current element points to an erroneous element\n-\n-         else\n-            Put_Line (\"? (ERROR)\");\n-         end if;\n-\n-         --  Output the header and fields\n-\n-         Put (\"|Header: \");\n-         Put (Address_Image (N_Ptr.all'Address));\n-\n-         --  Detect the dummy head\n-\n-         if N_Ptr = Head then\n-            Put_Line (\" (dummy head)\");\n-         else\n-            Put_Line (\"\");\n-         end if;\n-\n-         Put (\"|  Prev: \");\n-\n-         if N_Ptr.Prev = null then\n-            Put_Line (\"null\");\n-         else\n-            Put_Line (Address_Image (N_Ptr.Prev.all'Address));\n-         end if;\n-\n-         Put (\"|  Next: \");\n-\n-         if N_Ptr.Next = null then\n-            Put_Line (\"null\");\n-         else\n-            Put_Line (Address_Image (N_Ptr.Next.all'Address));\n-         end if;\n-\n-         N_Ptr := N_Ptr.Next;\n-      end loop;\n-   end pcol;\n-\n-   ------------------------------\n-   -- Set_Finalize_Address_Ptr --\n-   ------------------------------\n-\n-   procedure Set_Finalize_Address_Ptr\n-     (Collection : in out Finalization_Collection;\n-      Proc_Ptr   : Finalize_Address_Ptr)\n-   is\n-   begin\n-      Collection.Finalize_Address := Proc_Ptr;\n-   end Set_Finalize_Address_Ptr;\n-\n-   --------------------------\n-   -- Set_Storage_Pool_Ptr --\n-   --------------------------\n-\n-   procedure Set_Storage_Pool_Ptr\n-     (Collection : in out Finalization_Collection;\n-      Pool_Ptr   : Any_Storage_Pool_Ptr)\n-   is\n-   begin\n-      Collection.Base_Pool := Pool_Ptr;\n-   end Set_Storage_Pool_Ptr;\n-\n-end Ada.Finalization.Heap_Management;"}, {"sha": "6e829d20517229cd7af9a68f6b647831d0726006", "filename": "gcc/ada/a-fihema.ads", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c889ae483adccb124c7104e6c0e1ab274bd3677/gcc%2Fada%2Fa-fihema.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c889ae483adccb124c7104e6c0e1ab274bd3677/gcc%2Fada%2Fa-fihema.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-fihema.ads?ref=8c889ae483adccb124c7104e6c0e1ab274bd3677", "patch": "@@ -1,161 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---     A D A . F I N A L I Z A T I O N . H E A P _ M A N A G E M E N T      --\n---                                                                          --\n---                                S p e c                                   --\n---                                                                          --\n---          Copyright (C) 2008-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System;\n-with System.Storage_Elements;\n-with System.Storage_Pools;\n-\n-package Ada.Finalization.Heap_Management is\n-\n-   --  A reference to any derivation of Root_Storage_Pool. Since this type may\n-   --  not be used to allocate objects, its storage size is zero.\n-\n-   type Any_Storage_Pool_Ptr is\n-     access System.Storage_Pools.Root_Storage_Pool'Class;\n-   for Any_Storage_Pool_Ptr'Storage_Size use 0;\n-\n-   --  ??? Comment needed on overall mechanism\n-\n-   type Finalization_Collection is\n-     new Ada.Finalization.Limited_Controlled with private;\n-\n-   type Finalization_Collection_Ptr is access all Finalization_Collection;\n-   for Finalization_Collection_Ptr'Storage_Size use 0;\n-\n-   --  A reference used to describe primitive Finalize_Address\n-\n-   type Finalize_Address_Ptr is access procedure (Obj : System.Address);\n-\n-   --  Since RTSfind cannot contain names of the form RE_\"+\", the following\n-   --  routine serves as a wrapper around System.Storage_Elements.\"+\".\n-\n-   function Add_Offset_To_Address\n-     (Addr   : System.Address;\n-      Offset : System.Storage_Elements.Storage_Offset) return System.Address;\n-\n-   procedure Allocate\n-     (Collection   : in out Finalization_Collection;\n-      Addr         : out System.Address;\n-      Storage_Size : System.Storage_Elements.Storage_Count;\n-      Alignment    : System.Storage_Elements.Storage_Count;\n-      Needs_Header : Boolean := True);\n-   --  Allocate a chunk of memory described by Storage_Size and Alignment on\n-   --  Collection's underlying storage pool. Return the address of the chunk.\n-   --  The routine creates a list header which precedes the chunk of memory if\n-   --  Needs_Header is True. If allocated, the header is attached to the\n-   --  Collection's objects. The interface to this routine is provided by\n-   --  Build_Allocate_Deallocate_Proc.\n-\n-   function Base_Pool\n-     (Collection : Finalization_Collection) return Any_Storage_Pool_Ptr;\n-   --  Return a reference to the underlying storage pool of Collection\n-\n-   procedure Deallocate\n-     (Collection   : in out Finalization_Collection;\n-      Addr         : System.Address;\n-      Storage_Size : System.Storage_Elements.Storage_Count;\n-      Alignment    : System.Storage_Elements.Storage_Count;\n-      Has_Header   : Boolean := True);\n-   --  Deallocate a chunk of memory described by Storage_Size and Alignment\n-   --  from Collection's underlying storage pool. The beginning of the memory\n-   --  chunk is designated by Addr. The routine detaches and destroys the\n-   --  preceding list header if flag Has_Header is set. The interface to this\n-   --  routine is provided by Build_Allocate_Deallocate_Proc.\n-\n-   overriding procedure Finalize\n-     (Collection : in out Finalization_Collection);\n-   --  Traverse objects of Collection, invoking Finalize_Address on each one\n-\n-   overriding procedure Initialize\n-     (Collection : in out Finalization_Collection);\n-   --  Initialize the finalization list to empty\n-\n-   procedure Set_Finalize_Address_Ptr\n-     (Collection : in out Finalization_Collection;\n-      Proc_Ptr   : Finalize_Address_Ptr);\n-   --  Set the finalization address routine of a finalization collection\n-\n-   procedure Set_Storage_Pool_Ptr\n-     (Collection : in out Finalization_Collection;\n-      Pool_Ptr   : Any_Storage_Pool_Ptr);\n-   --  Set the underlying storage pool of a finalization collection\n-\n-private\n-   --  Homogeneous collection types\n-\n-   type Node;\n-   type Node_Ptr is access all Node;\n-   pragma No_Strict_Aliasing (Node_Ptr);\n-\n-   --  The following record type should really be limited, but we can see the\n-   --  full view of Limited_Controlled, which is NOT limited. Note that default\n-   --  initialization does not happen for this type (the pointers will not be\n-   --  automatically set to null), because of the games we're playing with\n-   --  address arithmetic. Code in the body assumes that the size of\n-   --  this record is a power of 2 to deal with alignment.\n-\n-   type Node is record\n-      Prev : Node_Ptr;\n-      Next : Node_Ptr;\n-   end record;\n-\n-   type Finalization_Collection is\n-     new Ada.Finalization.Limited_Controlled with\n-   record\n-      Base_Pool : Any_Storage_Pool_Ptr;\n-      --  All objects and node headers are allocated on this underlying pool;\n-      --  the collection is simply a wrapper around it.\n-\n-      Objects : aliased Node;\n-      --  The head of a doubly linked list containing all allocated objects\n-      --  with controlled parts that still exist (Unchecked_Deallocation has\n-      --  not been done on them).\n-\n-      Finalize_Address : Finalize_Address_Ptr;\n-      --  A reference to a routine that finalizes an object denoted by its\n-      --  address. The collection must be homogeneous since the same routine\n-      --  will be invoked for every allocated object when the pool is\n-      --  finalized.\n-\n-      Finalization_Started : Boolean := False;\n-      pragma Atomic (Finalization_Started);\n-      --  When the finalization of a collection takes place, any allocations of\n-      --  objects with controlled or protected parts on the same collection are\n-      --  prohibited and the action must raise Program_Error. This needs to be\n-      --  atomic, because it is accessed without Lock_Task/Unlock_Task. See\n-      --  RM-4.8(10.2/2).\n-   end record;\n-\n-   procedure pcol (Collection : Finalization_Collection);\n-   --  Output the contents of a collection in a readable form. Intended for\n-   --  debugging purposes.\n-\n-end Ada.Finalization.Heap_Management;"}, {"sha": "97c79157a8fa2ec61504ceb88d945cde2d598dcf", "filename": "gcc/ada/a-undesu.adb", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fa-undesu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fa-undesu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-undesu.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -0,0 +1,36 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     A D A . U N C H E C K E D _ D E A L L O C A T E _ S U B P O O L      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  ??? What is the header version here, see a-uncdea.adb. No GPL?\n+\n+with System.Storage_Pools.Subpools; use System.Storage_Pools.Subpools;\n+\n+procedure Ada.Unchecked_Deallocate_Subpool\n+  (Subpool : in out System.Storage_Pools.Subpools.Subpool_Handle)\n+is\n+begin\n+   --  Finalize all controlled objects allocated on the input subpool\n+\n+   --  ??? It is awkward to create a child of Storage_Pools.Subpools for the\n+   --  sole purpose of exporting Finalize_Subpool.\n+\n+--   Finalize_Subpool (Subpool);\n+\n+   --  Dispatch to the user-defined implementation of Deallocate_Subpool\n+\n+   Deallocate_Subpool (Pool_Of_Subpool (Subpool).all, Subpool);\n+end Ada.Unchecked_Deallocate_Subpool;"}, {"sha": "b59888247aec3ce0e02825e0c556357b209562b4", "filename": "gcc/ada/a-undesu.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fa-undesu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fa-undesu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-undesu.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -0,0 +1,23 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     A D A . U N C H E C K E D _ D E A L L O C A T E _ S U B P O O L      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  ??? What is the header version here, see a-uncdea.ads. No GPL?\n+\n+with System.Storage_Pools.Subpools;\n+\n+procedure Ada.Unchecked_Deallocate_Subpool\n+  (Subpool : in out System.Storage_Pools.Subpools.Subpool_Handle);"}, {"sha": "753dd4bfc912ec6c9bd123b677ba06505cfd52a9", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -195,11 +195,11 @@ package body Einfo is\n    --    Scope_Depth_Value               Uint22\n    --    Shared_Var_Procs_Instance       Node22\n \n-   --    Associated_Collection           Node23\n    --    CR_Discriminant                 Node23\n    --    Entry_Cancel_Parameter          Node23\n    --    Enum_Pos_To_Rep                 Node23\n    --    Extra_Constrained               Node23\n+   --    Finalization_Master             Node23\n    --    Generic_Renamings               Elist23\n    --    Inner_Instances                 Elist23\n    --    Limited_View                    Node23\n@@ -612,12 +612,6 @@ package body Einfo is\n       return Uint14 (Id);\n    end Alignment;\n \n-   function Associated_Collection (Id : E) return E is\n-   begin\n-      pragma Assert (Is_Access_Type (Id));\n-      return Node23 (Id);\n-   end Associated_Collection;\n-\n    function Associated_Formal_Package (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Package);\n@@ -1075,6 +1069,12 @@ package body Einfo is\n       return Flag229 (Base_Type (Id));\n    end Can_Use_Internal_Rep;\n \n+   function Finalization_Master (Id : E) return E is\n+   begin\n+      pragma Assert (Is_Access_Type (Id));\n+      return Node23 (Root_Type (Id));\n+   end Finalization_Master;\n+\n    function Finalize_Storage_Only (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -3051,12 +3051,6 @@ package body Einfo is\n       Set_Elist16 (Id, V);\n    end Set_Access_Disp_Table;\n \n-   procedure Set_Associated_Collection (Id : E; V : E) is\n-   begin\n-      pragma Assert (Is_Access_Type (Id));\n-      Set_Node23 (Id, V);\n-   end Set_Associated_Collection;\n-\n    procedure Set_Associated_Formal_Package (Id : E; V : E) is\n    begin\n       Set_Node12 (Id, V);\n@@ -3544,6 +3538,12 @@ package body Einfo is\n       Set_Flag229 (Id, V);\n    end Set_Can_Use_Internal_Rep;\n \n+   procedure Set_Finalization_Master (Id : E; V : E) is\n+   begin\n+      pragma Assert (Is_Access_Type (Id) and then Is_Base_Type (Id));\n+      Set_Node23 (Id, V);\n+   end Set_Finalization_Master;\n+\n    procedure Set_Finalize_Storage_Only (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id) and then Is_Base_Type (Id));\n@@ -6941,15 +6941,7 @@ package body Einfo is\n       if Ekind (T) = E_Class_Wide_Type then\n          return Etype (T);\n \n-      elsif Ekind (T) = E_Class_Wide_Subtype then\n-         return Etype (Base_Type (T));\n-\n-         --  ??? T comes from Base_Type, how can it be a subtype?\n-         --  Also Base_Type is supposed to be idempotent, so either way\n-         --  this is equivalent to \"return Etype (T)\" and should be merged\n-         --  with the E_Class_Wide_Type case.\n-\n-      --  All other cases\n+      --  Other cases\n \n       else\n          loop\n@@ -8459,9 +8451,6 @@ package body Einfo is\n    procedure Write_Field23_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n-         when Access_Kind                                  =>\n-            Write_Str (\"Associated_Collection\");\n-\n          when E_Discriminant                               =>\n             Write_Str (\"CR_Discriminant\");\n \n@@ -8475,6 +8464,9 @@ package body Einfo is\n               E_Variable                                   =>\n             Write_Str (\"Extra_Constrained\");\n \n+         when Access_Kind                                  =>\n+            Write_Str (\"Finalization_Master\");\n+\n          when E_Generic_Function                           |\n               E_Generic_Package                            |\n               E_Generic_Procedure                          =>"}, {"sha": "6f061d198b98a3665505eae040098345fa0bf79b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -427,12 +427,6 @@ package Einfo is\n --       definition clause with an (obsolescent) mod clause is converted\n --       into an attribute definition clause for this purpose.\n \n---    Associated_Collection (Node23)\n---       Present in non-subprogram access type entities. Contains the entity of\n---       the finalization collection on which dynamically allocated objects\n---       referenced by the access type are stored. Empty when the access type\n---       cannot reference a controlled object.\n-\n --    Associated_Formal_Package (Node12)\n --       Present in packages that are the actuals of formal_packages. Points\n --       to the entity in the declaration for the formal package.\n@@ -1144,6 +1138,13 @@ package Einfo is\n --       must be retrieved through the entity designed by this field instead of\n --       being computed.\n \n+--    Finalization_Master (Node23) [root type only]\n+--       Present in access-to-controlled or access-to-class-wide types. The\n+--       field contains the entity of the finalization master which handles\n+--       dynamically allocated controlled objects referenced by the access\n+--       type. Empty for access-to-subprogram types. Empty for access types\n+--       whose designated type does not need finalization actions.\n+\n --    Finalize_Storage_Only (Flag158) [base type only]\n --       Present in all types. Set on direct controlled types to which a\n --       valid Finalize_Storage_Only pragma applies. This flag is also set on\n@@ -4943,7 +4944,7 @@ package Einfo is\n    --    Master_Id                           (Node17)\n    --    Directly_Designated_Type            (Node20)\n    --    Associated_Storage_Pool             (Node22)   (base type only)\n-   --    Associated_Collection               (Node23)   (base type only)\n+   --    Finalization_Master                 (Node23)   (base type only)\n    --    Has_Pragma_Controlled               (Flag27)   (base type only)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n    --    Is_Access_Constant                  (Flag69)\n@@ -4971,7 +4972,7 @@ package Einfo is\n    --  E_Anonymous_Access_Type\n    --    Storage_Size_Variable               (Node15)   ??? is this needed ???\n    --    Directly_Designated_Type            (Node20)\n-   --    Associated_Collection               (Node23)\n+   --    Finalization_Master                 (Node23)\n    --    (plus type attributes)\n \n    --  E_Array_Type\n@@ -5278,7 +5279,7 @@ package Einfo is\n    --    Master_Id                           (Node17)\n    --    Directly_Designated_Type            (Node20)\n    --    Associated_Storage_Pool             (Node22)   (root type only)\n-   --    Associated_Collection               (Node23)\n+   --    Finalization_Master                 (Node23)   (root type only)\n    --    (plus type attributes)\n \n    --  E_Generic_In_Parameter\n@@ -5974,7 +5975,6 @@ package Einfo is\n    function Address_Taken                       (Id : E) return B;\n    function Alias                               (Id : E) return E;\n    function Alignment                           (Id : E) return U;\n-   function Associated_Collection               (Id : E) return E;\n    function Associated_Formal_Package           (Id : E) return E;\n    function Associated_Node_For_Itype           (Id : E) return N;\n    function Associated_Storage_Pool             (Id : E) return E;\n@@ -6050,6 +6050,7 @@ package Einfo is\n    function Extra_Formal                        (Id : E) return E;\n    function Extra_Formals                       (Id : E) return E;\n    function Can_Use_Internal_Rep                (Id : E) return B;\n+   function Finalization_Master                 (Id : E) return E;\n    function Finalize_Storage_Only               (Id : E) return B;\n    function Finalizer                           (Id : E) return E;\n    function First_Entity                        (Id : E) return E;\n@@ -6563,7 +6564,6 @@ package Einfo is\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n    procedure Set_Alias                           (Id : E; V : E);\n    procedure Set_Alignment                       (Id : E; V : U);\n-   procedure Set_Associated_Collection           (Id : E; V : E);\n    procedure Set_Associated_Formal_Package       (Id : E; V : E);\n    procedure Set_Associated_Node_For_Itype       (Id : E; V : N);\n    procedure Set_Associated_Storage_Pool         (Id : E; V : E);\n@@ -6637,6 +6637,7 @@ package Einfo is\n    procedure Set_Extra_Formal                    (Id : E; V : E);\n    procedure Set_Extra_Formals                   (Id : E; V : E);\n    procedure Set_Can_Use_Internal_Rep            (Id : E; V : B := True);\n+   procedure Set_Finalization_Master             (Id : E; V : E);\n    procedure Set_Finalize_Storage_Only           (Id : E; V : B := True);\n    procedure Set_Finalizer                       (Id : E; V : E);\n    procedure Set_First_Entity                    (Id : E; V : E);\n@@ -7259,7 +7260,6 @@ package Einfo is\n    pragma Inline (Address_Taken);\n    pragma Inline (Alias);\n    pragma Inline (Alignment);\n-   pragma Inline (Associated_Collection);\n    pragma Inline (Associated_Formal_Package);\n    pragma Inline (Associated_Node_For_Itype);\n    pragma Inline (Associated_Storage_Pool);\n@@ -7335,6 +7335,7 @@ package Einfo is\n    pragma Inline (Extra_Formal);\n    pragma Inline (Extra_Formals);\n    pragma Inline (Can_Use_Internal_Rep);\n+   pragma Inline (Finalization_Master);\n    pragma Inline (Finalizer);\n    pragma Inline (First_Entity);\n    pragma Inline (First_Exit_Statement);\n@@ -7703,7 +7704,6 @@ package Einfo is\n    pragma Inline (Set_Address_Taken);\n    pragma Inline (Set_Alias);\n    pragma Inline (Set_Alignment);\n-   pragma Inline (Set_Associated_Collection);\n    pragma Inline (Set_Associated_Formal_Package);\n    pragma Inline (Set_Associated_Node_For_Itype);\n    pragma Inline (Set_Associated_Storage_Pool);\n@@ -7778,6 +7778,7 @@ package Einfo is\n    pragma Inline (Set_Extra_Formal);\n    pragma Inline (Set_Extra_Formals);\n    pragma Inline (Set_Can_Use_Internal_Rep);\n+   pragma Inline (Set_Finalization_Master);\n    pragma Inline (Set_Finalizer);\n    pragma Inline (Set_First_Entity);\n    pragma Inline (Set_First_Exit_Statement);"}, {"sha": "a6890d72746313516902c340dfc7f1512a41c747", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -230,7 +230,7 @@ package body Exp_Ch13 is\n          return;\n       end if;\n \n-      --  Use the base type to perform the collection check\n+      --  Use the base type to perform the check for finalization master\n \n       Typ := Etype (Expr);\n \n@@ -248,10 +248,10 @@ package body Exp_Ch13 is\n \n       --  Do not create a custom Deallocate when freeing an object with\n       --  suppressed finalization. In such cases the object is never attached\n-      --  to a collection, so it does not need to be detached. Use a regular\n-      --  free statement instead.\n+      --  to a master, so it does not need to be detached. Use a regular free\n+      --  statement instead.\n \n-      if No (Associated_Collection (Typ)) then\n+      if No (Finalization_Master (Typ)) then\n          return;\n       end if;\n "}, {"sha": "2ba20e5565f4b5ddca09ad0e14c2dd00b37dc189", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -5482,12 +5482,13 @@ package body Exp_Ch3 is\n                   Build_Slice_Assignment (Typ);\n                end if;\n \n-            --  ??? This may not be necessary after all\n+            --  ??? Now that masters acts as heterogeneous lists, it might be\n+            --  worthed to revisit the global master approach.\n \n             elsif Ekind (Comp_Typ) = E_Anonymous_Access_Type\n               and then Needs_Finalization (Directly_Designated_Type (Comp_Typ))\n             then\n-               Build_Finalization_Collection (Comp_Typ);\n+               Build_Finalization_Master (Comp_Typ);\n             end if;\n          end if;\n \n@@ -5581,8 +5582,8 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n-      --  Generate the body of Finalize_Address. This routine is accessible\n-      --  through the TSS mechanism.\n+      --  Create the body of TSS primitive Finalize_Address. This automatically\n+      --  sets the TSS entry for the class-wide type.\n \n       Make_Finalize_Address_Body (Typ);\n    end Expand_Freeze_Class_Wide_Type;\n@@ -6310,13 +6311,17 @@ package body Exp_Ch3 is\n          --  compiling a CPP tagged type.\n \n          elsif not Restriction_Active (No_Dispatching_Calls) then\n-            Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n-            Append_Freeze_Actions (Def_Id, Predef_List);\n \n-            --  Create the body of Finalize_Address, a helper routine used in\n-            --  conjunction with controlled objects on the heap.\n+            --  Create the body of TSS primitive Finalize_Address. This must\n+            --  be done before the bodies of all predefined primitives are\n+            --  created. If Def_Id is limited, Stream_Input and Streap_Read\n+            --  may produce build-in-place allocations and for that the\n+            --  expander needs Finalize_Address.\n \n             Make_Finalize_Address_Body (Def_Id);\n+\n+            Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n+            Append_Freeze_Actions (Def_Id, Predef_List);\n          end if;\n \n          --  Ada 2005 (AI-391): If any wrappers were created for nonoverridden\n@@ -6364,7 +6369,7 @@ package body Exp_Ch3 is\n \n            and then Directly_Designated_Type (Comp_Typ) /= Def_Id\n          then\n-            Build_Finalization_Collection\n+            Build_Finalization_Master\n              (Typ        => Comp_Typ,\n               Ins_Node   => Parent (Def_Id),\n               Encl_Scope => Scope (Def_Id));\n@@ -6652,7 +6657,7 @@ package body Exp_Ch3 is\n                   and then not Is_Frozen (Desig_Type)\n                   and then Needs_Finalization (Component_Type (Desig_Type)))\n             then\n-               Build_Finalization_Collection (Def_Id);\n+               Build_Finalization_Master (Def_Id);\n             end if;\n          end;\n \n@@ -8399,7 +8404,7 @@ package body Exp_Ch3 is\n       end if;\n \n       --  All tagged types receive their own Deep_Adjust and Deep_Finalize\n-      --  regardless of whether they are controlled or contain controlled\n+      --  regardless of whether they are controlled or may contain controlled\n       --  components.\n \n       --  Do not generate the routines if finalization is disabled\n@@ -8414,12 +8419,10 @@ package body Exp_Ch3 is\n \n       else\n          if not Is_Limited_Type (Tag_Typ) then\n-            Append_To (Res,\n-              Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Adjust));\n+            Append_To (Res, Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Adjust));\n          end if;\n \n-         Append_To (Res,\n-           Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Finalize));\n+         Append_To (Res, Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Finalize));\n       end if;\n \n       Predef_List := Res;\n@@ -9028,9 +9031,9 @@ package body Exp_Ch3 is\n       --  to be (implicitly) inherited in that case because it can lead to a VM\n       --  exception.\n \n-      --  Do not generate stream routines for type Finalization_Collection\n-      --  because collection may never appear in types and therefore cannot be\n-      --  read or written.\n+      --  Do not generate stream routines for type Finalization_Master because\n+      --  a master may never appear in types and therefore cannot be read or\n+      --  written.\n \n       return\n           (not Is_Limited_Type (Typ)\n@@ -9053,7 +9056,7 @@ package body Exp_Ch3 is\n         and then RTE_Available (RE_Tag)\n         and then No (Type_Without_Stream_Operation (Typ))\n         and then RTE_Available (RE_Root_Stream_Type)\n-        and then not Is_RTE (Typ, RE_Finalization_Collection);\n+        and then not Is_RTE (Typ, RE_Finalization_Master);\n    end Stream_Operation_OK;\n \n end Exp_Ch3;"}, {"sha": "a4ef03ed6ce847e711bc2b8e8648fa20f0f94721", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 30, "deletions": 64, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -444,12 +444,15 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  ??? Now that finalization masters act as heterogeneous lists, it\n+      --  might be worthed to revisit the global master approach.\n+\n       --  Processing for anonymous access-to-controlled types. These access\n-      --  types receive a special collection which appears on the declarations\n-      --  of the enclosing semantic unit.\n+      --  types receive a special finalization master which appears in the\n+      --  declarations of the enclosing semantic unit.\n \n       if Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n-        and then No (Associated_Collection (Ptr_Typ))\n+        and then No (Finalization_Master (Ptr_Typ))\n         and then\n           (not Restriction_Active (No_Nested_Finalization)\n              or else Is_Library_Level_Entity (Ptr_Typ))\n@@ -466,7 +469,7 @@ package body Exp_Ch4 is\n                Scop := Corresponding_Spec (Parent (Parent (Parent (Scop))));\n             end if;\n \n-            Build_Finalization_Collection\n+            Build_Finalization_Master\n               (Typ        => Ptr_Typ,\n                Ins_Node   => First_Declaration_Of_Current_Unit,\n                Encl_Scope => Scop);\n@@ -481,7 +484,7 @@ package body Exp_Ch4 is\n       --  Since the temporary object reuses the original allocator, generate a\n       --  custom Allocate routine for the temporary.\n \n-      if Present (Associated_Collection (Ptr_Typ)) then\n+      if Present (Finalization_Master (Ptr_Typ)) then\n          Build_Allocate_Deallocate_Proc\n            (N           => Temp_Decl,\n             Is_Allocate => True);\n@@ -858,14 +861,14 @@ package body Exp_Ch4 is\n                Complete_Controlled_Allocation (Temp_Decl);\n                Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n-               --  Attach the object to the associated finalization collection.\n+               --  Attach the object to the associated finalization master.\n                --  This is done manually on .NET/JVM since those compilers do\n                --  no support pools and can't benefit from internally generated\n                --  Allocate / Deallocate procedures.\n \n                if VM_Target /= No_VM\n                  and then Is_Controlled (DesigT)\n-                 and then Present (Associated_Collection (PtrT))\n+                 and then Present (Finalization_Master (PtrT))\n                then\n                   Insert_Action (N,\n                     Make_Attach_Call (\n@@ -888,14 +891,14 @@ package body Exp_Ch4 is\n                Insert_Action (N, Temp_Decl);\n                Complete_Controlled_Allocation (Temp_Decl);\n \n-               --  Attach the object to the associated finalization collection.\n+               --  Attach the object to the associated finalization master.\n                --  This is done manually on .NET/JVM since those compilers do\n                --  no support pools and can't benefit from internally generated\n                --  Allocate / Deallocate procedures.\n \n                if VM_Target /= No_VM\n                  and then Is_Controlled (DesigT)\n-                 and then Present (Associated_Collection (PtrT))\n+                 and then Present (Finalization_Master (PtrT))\n                then\n                   Insert_Action (N,\n                     Make_Attach_Call (\n@@ -931,8 +934,7 @@ package body Exp_Ch4 is\n                --  Inherit the allocation-related attributes from the original\n                --  access type.\n \n-               Set_Associated_Collection (Def_Id,\n-                 Associated_Collection (PtrT));\n+               Set_Finalization_Master (Def_Id, Finalization_Master (PtrT));\n \n                Set_Associated_Storage_Pool (Def_Id,\n                  Associated_Storage_Pool (PtrT));\n@@ -1083,25 +1085,6 @@ package body Exp_Ch4 is\n                          Prefix => New_Reference_To (Temp, Loc))),\n                    Typ => T));\n             end if;\n-\n-            --  Generate:\n-            --    Set_Finalize_Address_Ptr\n-            --      (Collection, <Finalize_Address>'Unrestricted_Access)\n-\n-            --  Since .NET/JVM compilers do not support address arithmetic,\n-            --  this call is skipped. The same is done for CodePeer because\n-            --  Finalize_Address is never generated.\n-\n-            if VM_Target = No_VM\n-              and then not CodePeer_Mode\n-              and then Present (Associated_Collection (PtrT))\n-            then\n-               Insert_Action (N,\n-                 Make_Set_Finalize_Address_Ptr_Call\n-                   (Loc     => Loc,\n-                    Typ     => T,\n-                    Ptr_Typ => PtrT));\n-            end if;\n          end if;\n \n          Rewrite (N, New_Reference_To (Temp, Loc));\n@@ -1139,14 +1122,14 @@ package body Exp_Ch4 is\n          Complete_Controlled_Allocation (Temp_Decl);\n          Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n-         --  Attach the object to the associated finalization collection. This\n-         --  is done manually on .NET/JVM since those compilers do no support\n+         --  Attach the object to the associated finalization master. Thisis\n+         --  done manually on .NET/JVM since those compilers do no support\n          --  pools and cannot benefit from internally generated Allocate and\n          --  Deallocate procedures.\n \n          if VM_Target /= No_VM\n            and then Is_Controlled (DesigT)\n-           and then Present (Associated_Collection (PtrT))\n+           and then Present (Finalization_Master (PtrT))\n          then\n             Insert_Action (N,\n               Make_Attach_Call\n@@ -3564,7 +3547,7 @@ package body Exp_Ch4 is\n             --  do not support pools, this step is skipped.\n \n             if VM_Target = No_VM\n-              and then Present (Associated_Collection (PtrT))\n+              and then Present (Finalization_Master (PtrT))\n             then\n                Build_Allocate_Deallocate_Proc\n                  (N           => Parent (N),\n@@ -3858,39 +3841,22 @@ package body Exp_Ch4 is\n                       (Obj_Ref => New_Copy_Tree (Init_Arg1),\n                        Typ     => T));\n \n-                  if Present (Associated_Collection (PtrT)) then\n+                  --  Special processing for .NET/JVM, the allocated object is\n+                  --  attached to the finalization master. Generate:\n \n-                     --  Special processing for .NET/JVM, the allocated object\n-                     --  is attached to the finalization collection. Generate:\n+                  --    Attach (<PtrT>FM, Root_Controlled_Ptr (Init_Arg1));\n \n-                     --    Attach (<PtrT>FC, Root_Controlled_Ptr (Init_Arg1));\n+                  --  Types derived from [Limited_]Controlled are the only\n+                  --  ones considered since they have fields Prev and Next.\n \n-                     --  Types derived from [Limited_]Controlled are the only\n-                     --  ones considered since they have fields Prev and Next.\n-\n-                     if VM_Target /= No_VM then\n-                        if Is_Controlled (T) then\n-                           Insert_Action (N,\n-                             Make_Attach_Call\n-                               (Obj_Ref => New_Copy_Tree (Init_Arg1),\n-                                Ptr_Typ => PtrT));\n-                        end if;\n-\n-                     --  Default case, generate:\n-\n-                     --    Set_Finalize_Address_Ptr\n-                     --      (Pool, <Finalize_Address>'Unrestricted_Access)\n-\n-                     --  Do not generate the above for CodePeer compilations\n-                     --  because Finalize_Address is never built.\n-\n-                     elsif not CodePeer_Mode then\n-                        Insert_Action (N,\n-                          Make_Set_Finalize_Address_Ptr_Call\n-                            (Loc     => Loc,\n-                             Typ     => T,\n-                             Ptr_Typ => PtrT));\n-                     end if;\n+                  if VM_Target /= No_VM\n+                    and then Present (Finalization_Master (PtrT))\n+                    and then Is_Controlled (T)\n+                  then\n+                     Insert_Action (N,\n+                       Make_Attach_Call\n+                         (Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                          Ptr_Typ => PtrT));\n                   end if;\n                end if;\n "}, {"sha": "5f8feb73bf0cd62a255e15f7c80108857ac6058e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 69, "deletions": 92, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -110,14 +110,14 @@ package body Exp_Ch6 is\n    --  Adds Extra_Actual as a named parameter association for the formal\n    --  Extra_Formal in Subprogram_Call.\n \n-   procedure Add_Collection_Actual_To_Build_In_Place_Call\n+   procedure Add_Finalization_Master_Actual_To_Build_In_Place_Call\n      (Func_Call : Node_Id;\n       Func_Id   : Entity_Id;\n       Ptr_Typ   : Entity_Id := Empty);\n    --  Ada 2005 (AI-318-02): If the result type of a build-in-place call needs\n    --  finalization actions, add an actual parameter which is a pointer to the\n-   --  finalization collection of the caller. If Ptr_Typ is left Empty, this\n-   --  will result in an automatic \"null\" value for the actual.\n+   --  finalization master of the caller. If Ptr_Typ is left Empty, this will\n+   --  result in an automatic \"null\" value for the actual.\n \n    procedure Add_Task_Actuals_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n@@ -340,30 +340,30 @@ package body Exp_Ch6 is\n         (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n    end Add_Alloc_Form_Actual_To_Build_In_Place_Call;\n \n-   --------------------------------------------------\n-   -- Add_Collection_Actual_To_Build_In_Place_Call --\n-   --------------------------------------------------\n+   -----------------------------------------------------------\n+   -- Add_Finalization_Master_Actual_To_Build_In_Place_Call --\n+   -----------------------------------------------------------\n \n-   procedure Add_Collection_Actual_To_Build_In_Place_Call\n+   procedure Add_Finalization_Master_Actual_To_Build_In_Place_Call\n      (Func_Call : Node_Id;\n       Func_Id   : Entity_Id;\n       Ptr_Typ   : Entity_Id := Empty)\n    is\n    begin\n-      if not Needs_BIP_Collection (Func_Id) then\n+      if not Needs_BIP_Finalization_Master (Func_Id) then\n          return;\n       end if;\n \n       declare\n          Formal : constant Entity_Id :=\n-                    Build_In_Place_Formal (Func_Id, BIP_Collection);\n+                    Build_In_Place_Formal (Func_Id, BIP_Finalization_Master);\n          Loc    : constant Source_Ptr := Sloc (Func_Call);\n \n          Actual    : Node_Id;\n          Desig_Typ : Entity_Id;\n \n       begin\n-         --  Case where the context does not require an actual collection\n+         --  Case where the context does not require an actual master\n \n          if No (Ptr_Typ) then\n             Actual := Make_Null (Loc);\n@@ -372,9 +372,9 @@ package body Exp_Ch6 is\n             Desig_Typ := Directly_Designated_Type (Ptr_Typ);\n \n             --  Check for a library-level access type whose designated type has\n-            --  supressed finalization. Such an access types lack a collection.\n+            --  supressed finalization. Such an access types lack a master.\n             --  Pass a null actual to the callee in order to signal a missing\n-            --  collection.\n+            --  master.\n \n             if Is_Library_Level_Entity (Ptr_Typ)\n               and then Finalize_Storage_Only (Desig_Typ)\n@@ -385,28 +385,28 @@ package body Exp_Ch6 is\n \n             elsif Needs_Finalization (Desig_Typ) then\n \n-               --  The general mechanism of creating finalization collections\n-               --  for anonymous access types is disabled by default, otherwise\n-               --  collections will pop all over the place. Such types use\n-               --  context-specific collections.\n+               --  The general mechanism of creating finalization masters for\n+               --  anonymous access types is disabled by default, otherwise\n+               --  finalization masters will pop all over the place. Such types\n+               --  use context-specific masters.\n \n                if Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n-                 and then No (Associated_Collection (Ptr_Typ))\n+                 and then No (Finalization_Master (Ptr_Typ))\n                then\n-                  Build_Finalization_Collection\n+                  Build_Finalization_Master\n                     (Typ        => Ptr_Typ,\n                      Ins_Node   => Associated_Node_For_Itype (Ptr_Typ),\n                      Encl_Scope => Scope (Ptr_Typ));\n                end if;\n \n-               --  Access-to-controlled types should always have a collection\n+               --  Access-to-controlled types should always have a master\n \n-               pragma Assert (Present (Associated_Collection (Ptr_Typ)));\n+               pragma Assert (Present (Finalization_Master (Ptr_Typ)));\n \n                Actual :=\n                  Make_Attribute_Reference (Loc,\n                    Prefix =>\n-                     New_Reference_To (Associated_Collection (Ptr_Typ), Loc),\n+                     New_Reference_To (Finalization_Master (Ptr_Typ), Loc),\n                    Attribute_Name => Name_Unrestricted_Access);\n \n             --  Tagged types\n@@ -423,7 +423,7 @@ package body Exp_Ch6 is\n \n          Add_Extra_Actual_To_Call (Func_Call, Formal, Actual);\n       end;\n-   end Add_Collection_Actual_To_Build_In_Place_Call;\n+   end Add_Finalization_Master_Actual_To_Build_In_Place_Call;\n \n    ------------------------------\n    -- Add_Extra_Actual_To_Call --\n@@ -559,15 +559,15 @@ package body Exp_Ch6 is\n    function BIP_Formal_Suffix (Kind : BIP_Formal_Kind) return String is\n    begin\n       case Kind is\n-         when BIP_Alloc_Form       =>\n+         when BIP_Alloc_Form          =>\n             return \"BIPalloc\";\n-         when BIP_Collection       =>\n-            return \"BIPcollection\";\n-         when BIP_Master           =>\n+         when BIP_Finalization_Master =>\n+            return \"BIPfinalizationmaster\";\n+         when BIP_Master              =>\n             return \"BIPmaster\";\n-         when BIP_Activation_Chain =>\n+         when BIP_Activation_Chain    =>\n             return \"BIPactivationchain\";\n-         when BIP_Object_Access    =>\n+         when BIP_Object_Access       =>\n             return \"BIPaccess\";\n       end case;\n    end BIP_Formal_Suffix;\n@@ -2105,10 +2105,10 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  Detect the following code in Ada.Finalization.Heap_Management only\n-      --  on .NET/JVM targets:\n+      --  Detect the following code in System.Finalization_Masters only on\n+      --  .NET/JVM targets:\n       --\n-      --    procedure Finalize (Collection : in out Finalization_Collection) is\n+      --    procedure Finalize (Master : in out Finalization_Master) is\n       --    begin\n       --       . . .\n       --       begin\n@@ -2124,7 +2124,7 @@ package body Exp_Ch6 is\n         and then Ekind (Scope (Curr_S)) = E_Procedure\n         and then Chars (Scope (Curr_S)) = Name_Finalize\n         and then Etype (First_Formal (Scope (Curr_S))) =\n-                   RTE (RE_Finalization_Collection)\n+                   RTE (RE_Finalization_Master)\n       then\n          declare\n             Deep_Fin : constant Entity_Id :=\n@@ -4393,20 +4393,20 @@ package body Exp_Ch6 is\n          Ret_Typ    : Entity_Id;\n          Alloc_Expr : Node_Id) return Node_Id;\n       --  Create the statements necessary to allocate a return object on the\n-      --  caller's collection. The collection is available through implicit\n-      --  parameter BIPcollection.\n+      --  caller's master. The master is available through implicit parameter\n+      --  BIPfinalizationmaster.\n       --\n-      --    if BIPcollection /= null then\n+      --    if BIPfinalizationmaster /= null then\n       --       declare\n       --          type Ptr_Typ is access Ret_Typ;\n       --          for Ptr_Typ'Storage_Pool use\n-      --                Base_Pool (BIPcollection.all).all;\n+      --                Base_Pool (BIPfinalizationmaster.all).all;\n       --          Local : Ptr_Typ;\n       --\n       --       begin\n       --          procedure Allocate (...) is\n       --          begin\n-      --             Ada.Finalization.Heap_Management.Allocate (...);\n+      --             System.Storage_Pools.Subpools.Allocate_Any (...);\n       --          end Allocate;\n       --\n       --          Local := <Alloc_Expr>;\n@@ -4439,25 +4439,26 @@ package body Exp_Ch6 is\n       is\n       begin\n          --  Processing for build-in-place object allocation. This is disabled\n-         --  on .NET/JVM because pools are not supported.\n+         --  on .NET/JVM because the targets do not support pools.\n \n          if VM_Target = No_VM\n            and then Is_Build_In_Place_Function (Func_Id)\n            and then Needs_Finalization (Ret_Typ)\n          then\n             declare\n-               Collect : constant Entity_Id :=\n-                           Build_In_Place_Formal (Func_Id, BIP_Collection);\n-               Decls   : constant List_Id := New_List;\n-               Stmts   : constant List_Id := New_List;\n+               Decls      : constant List_Id := New_List;\n+               Fin_Mas_Id : constant Entity_Id :=\n+                              Build_In_Place_Formal\n+                                (Func_Id, BIP_Finalization_Master);\n+               Stmts      : constant List_Id := New_List;\n \n                Local_Id : Entity_Id;\n                Pool_Id  : Entity_Id;\n                Ptr_Typ  : Entity_Id;\n \n             begin\n                --  Generate:\n-               --    Pool_Id renames Base_Pool (BIPcollection.all).all;\n+               --    Pool_Id renames Base_Pool (BIPfinalizationmaster.all).all;\n \n                Pool_Id := Make_Temporary (Loc, 'P');\n \n@@ -4474,11 +4475,12 @@ package body Exp_Ch6 is\n                              New_Reference_To (RTE (RE_Base_Pool), Loc),\n                            Parameter_Associations => New_List (\n                              Make_Explicit_Dereference (Loc,\n-                               Prefix => New_Reference_To (Collect, Loc)))))));\n+                               Prefix =>\n+                                 New_Reference_To (Fin_Mas_Id, Loc)))))));\n \n                --  Create an access type which uses the storage pool of the\n-               --  caller's collection. This additional type is necessary\n-               --  because the collection cannot be associated with the type\n+               --  caller's master. This additional type is necessary because\n+               --  the finalization master cannot be associated with the type\n                --  of the temporary. Otherwise the secondary stack allocation\n                --  will fail.\n \n@@ -4495,11 +4497,11 @@ package body Exp_Ch6 is\n                        Subtype_Indication =>\n                          New_Reference_To (Ret_Typ, Loc))));\n \n-               --  Perform minor decoration in order to set the collection and\n-               --  the storage pool attributes.\n+               --  Perform minor decoration in order to set the master and the\n+               --  storage pool attributes.\n \n                Set_Ekind (Ptr_Typ, E_Access_Type);\n-               Set_Associated_Collection   (Ptr_Typ, Collect);\n+               Set_Finalization_Master     (Ptr_Typ, Fin_Mas_Id);\n                Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n \n                --  Create the temporary, generate:\n@@ -4534,12 +4536,12 @@ package body Exp_Ch6 is\n                        New_Reference_To (Local_Id, Loc))));\n \n                --  Wrap the allocation in a block. This is further conditioned\n-               --  by checking the caller collection at runtime. A null value\n-               --  indicates a non-existent collection, most likely due to a\n-               --  Finalize_Storage_Only allocation.\n+               --  by checking the caller finalization master at runtime. A\n+               --  null value indicates a non-existent master, most likely due\n+               --  to a Finalize_Storage_Only allocation.\n \n                --  Generate:\n-               --    if BIPcollection /= null then\n+               --    if BIPfinalizationmaster /= null then\n                --       declare\n                --          <Decls>\n                --       begin\n@@ -4551,7 +4553,7 @@ package body Exp_Ch6 is\n                  Make_If_Statement (Loc,\n                    Condition       =>\n                      Make_Op_Ne (Loc,\n-                       Left_Opnd  => New_Reference_To (Collect, Loc),\n+                       Left_Opnd  => New_Reference_To (Fin_Mas_Id, Loc),\n                        Right_Opnd => Make_Null (Loc)),\n \n                    Then_Statements => New_List (\n@@ -7110,7 +7112,7 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-         Add_Collection_Actual_To_Build_In_Place_Call\n+         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Acc_Type);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -7144,7 +7146,7 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n \n-         Add_Collection_Actual_To_Build_In_Place_Call\n+         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Acc_Type);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -7157,33 +7159,6 @@ package body Exp_Ch6 is\n            (Func_Call, Function_Id, Return_Object => Empty);\n       end if;\n \n-      --  If the build-in-place function call returns a controlled object, the\n-      --  finalization collection will require a reference to routine Finalize_\n-      --  Address of the designated type. Setting this attribute is done in the\n-      --  same manner to expansion of allocators.\n-\n-      if Needs_Finalization (Result_Subt) then\n-\n-         --  Controlled types with supressed finalization do not need to\n-         --  associate the address of their Finalize_Address primitives with a\n-         --  collection since they do not need a collection to begin with.\n-\n-         if Is_Library_Level_Entity (Acc_Type)\n-           and then Finalize_Storage_Only (Result_Subt)\n-         then\n-            null;\n-\n-         --  Do not generate the call to Make_Set_Finalize_Address_Ptr for\n-         --  CodePeer compilations because Finalize_Address is never built.\n-\n-         elsif not CodePeer_Mode then\n-            Insert_Action (Allocator,\n-              Make_Set_Finalize_Address_Ptr_Call (Loc,\n-                Typ     => Etype (Function_Id),\n-                Ptr_Typ => Acc_Type));\n-         end if;\n-      end if;\n-\n       --  Finally, replace the allocator node with a reference to the result\n       --  of the function call itself (which will effectively be an access\n       --  to the object created by the allocator).\n@@ -7310,7 +7285,7 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-         Add_Collection_Actual_To_Build_In_Place_Call\n+         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -7334,7 +7309,7 @@ package body Exp_Ch6 is\n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n \n-         Add_Collection_Actual_To_Build_In_Place_Call\n+         Add_Finalization_Master_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id);\n \n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -7412,7 +7387,7 @@ package body Exp_Ch6 is\n       Add_Alloc_Form_Actual_To_Build_In_Place_Call\n         (Func_Call, Func_Id, Alloc_Form => Caller_Allocation);\n \n-      Add_Collection_Actual_To_Build_In_Place_Call\n+      Add_Finalization_Master_Actual_To_Build_In_Place_Call\n         (Func_Call, Func_Id);\n \n       Add_Task_Actuals_To_Build_In_Place_Call\n@@ -7625,7 +7600,7 @@ package body Exp_Ch6 is\n          Establish_Transient_Scope (Object_Decl, Sec_Stack => True);\n       end if;\n \n-      Add_Collection_Actual_To_Build_In_Place_Call\n+      Add_Finalization_Master_Actual_To_Build_In_Place_Call\n         (Func_Call, Function_Id);\n \n       if Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement\n@@ -7773,18 +7748,20 @@ package body Exp_Ch6 is\n       end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n \n-   --------------------------\n-   -- Needs_BIP_Collection --\n-   --------------------------\n+   -----------------------------------\n+   -- Needs_BIP_Finalization_Master --\n+   -----------------------------------\n \n-   function Needs_BIP_Collection (Func_Id : Entity_Id) return Boolean is\n+   function Needs_BIP_Finalization_Master\n+     (Func_Id : Entity_Id) return Boolean\n+   is\n       pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n    begin\n       return\n         not Restriction_Active (No_Finalization)\n           and then Needs_Finalization (Func_Typ);\n-   end Needs_BIP_Collection;\n+   end Needs_BIP_Finalization_Master;\n \n end Exp_Ch6;"}, {"sha": "077ddeb9e1902d8b100fc7731b138e4d7b22ae29", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -68,9 +68,9 @@ package Exp_Ch6 is\n       --  caller or callee, and if the callee, whether to use the secondary\n       --  stack or the heap. See Create_Extra_Formals.\n \n-      BIP_Collection,\n+      BIP_Finalization_Master,\n       --  Present if result type needs finalization. Pointer to caller's\n-      --  finalization collection.\n+      --  finalization master.\n \n       BIP_Master,\n       --  Present if result type contains tasks. Master associated with\n@@ -163,8 +163,8 @@ package Exp_Ch6 is\n    --  for which Is_Build_In_Place_Call is True, or an N_Qualified_Expression\n    --  node applied to such a function call.\n \n-   function Needs_BIP_Collection (Func_Id : Entity_Id) return Boolean;\n+   function Needs_BIP_Finalization_Master (Func_Id : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Return True if the function needs a finalization\n-   --  collection implicit parameter.\n+   --  master implicit parameter.\n \n end Exp_Ch6;"}, {"sha": "acd64ca60ba8a6ce20c6ed0e9c0255499e0f471c", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 139, "deletions": 223, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -431,8 +431,8 @@ package body Exp_Ch7 is\n    --  whether the inner logic should be dictated by state counters.\n \n    function Make_Finalize_Address_Stmts (Typ : Entity_Id) return List_Id;\n-   --  Subsidiary to Make_Finalize_Address_Body and Make_Deep_Array_Body.\n-   --  Generate the following statements:\n+   --  Subsidiary to Make_Finalize_Address_Body, Make_Deep_Array_Body and\n+   --  Make_Deep_Record_Body. Generate the following statements:\n    --\n    --    declare\n    --       type Acc_Typ is access all Typ;\n@@ -797,11 +797,11 @@ package body Exp_Ch7 is\n                   Parameter_Associations => Actuals)))));\n    end Build_Exception_Handler;\n \n-   -----------------------------------\n-   -- Build_Finalization_Collection --\n-   -----------------------------------\n+   -------------------------------\n+   -- Build_Finalization_Master --\n+   -------------------------------\n \n-   procedure Build_Finalization_Collection\n+   procedure Build_Finalization_Master\n      (Typ        : Entity_Id;\n       Ins_Node   : Node_Id := Empty;\n       Encl_Scope : Entity_Id := Empty)\n@@ -837,7 +837,7 @@ package body Exp_Ch7 is\n          return False;\n       end In_Deallocation_Instance;\n \n-   --  Start of processing for Build_Finalization_Collection\n+   --  Start of processing for Build_Finalization_Master\n \n    begin\n       --  Certain run-time configurations and targets do not provide support\n@@ -847,16 +847,13 @@ package body Exp_Ch7 is\n          return;\n \n       --  Various machinery such as freezing may have already created a\n-      --  collection.\n+      --  finalization master.\n \n-      elsif Present (Associated_Collection (Typ)) then\n+      elsif Present (Finalization_Master (Typ)) then\n          return;\n \n       --  Do not process types that return on the secondary stack\n \n-      --  ??? The need for a secondary stack should be revisited and perhaps\n-      --  changed.\n-\n       elsif Present (Associated_Storage_Pool (Typ))\n         and then Is_RTE (Associated_Storage_Pool (Typ), RE_SS_Pool)\n       then\n@@ -875,15 +872,15 @@ package body Exp_Ch7 is\n          return;\n \n       --  Ignore the general use of anonymous access types unless the context\n-      --  requires a collection.\n+      --  requires a finalization master.\n \n       elsif Ekind (Typ) = E_Anonymous_Access_Type\n         and then No (Ins_Node)\n       then\n          return;\n \n       --  Do not process non-library access types when restriction No_Nested_\n-      --  Finalization is in effect since collections are controlled objects.\n+      --  Finalization is in effect since masters are controlled objects.\n \n       elsif Restriction_Active (No_Nested_Finalization)\n         and then not Is_Library_Level_Entity (Typ)\n@@ -901,87 +898,85 @@ package body Exp_Ch7 is\n       end if;\n \n       declare\n-         Loc     : constant Source_Ptr := Sloc (Typ);\n-         Actions : constant List_Id := New_List;\n-         Coll_Id : Entity_Id;\n-         Pool_Id : Entity_Id;\n+         Loc        : constant Source_Ptr := Sloc (Typ);\n+         Actions    : constant List_Id := New_List;\n+         Fin_Mas_Id : Entity_Id;\n+         Pool_Id    : Entity_Id;\n+         Ptr_Typ    : Entity_Id := Typ;\n \n       begin\n+         --  Access subtypes must use the storage pool of their base type\n+\n+         if Ekind (Ptr_Typ) = E_Access_Subtype then\n+            Ptr_Typ := Base_Type (Ptr_Typ);\n+         end if;\n+\n          --  Generate:\n-         --    Fnn : Finalization_Collection;\n+         --    Fnn : aliased Finalization_Master;\n \n-         --  Source access types use fixed names for their collections since\n-         --  the collection is inserted only once in the same source unit and\n-         --  there is no possible name overlap. Internally-generated access\n-         --  types on the other hand use temporaries as collection names due\n-         --  to possible name collisions.\n+         --  Source access types use fixed master names since the master is\n+         --  inserted in the same source unit only once. The only exception to\n+         --  this are instances using the same access type as generic actual.\n \n-         if Comes_From_Source (Typ) then\n-            Coll_Id :=\n+         if Comes_From_Source (Ptr_Typ)\n+           and then not Inside_A_Generic\n+         then\n+            Fin_Mas_Id :=\n               Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Chars (Typ), \"FC\"));\n+                Chars => New_External_Name (Chars (Ptr_Typ), \"FM\"));\n+\n+         --  Internally generated access types use temporaries as their names\n+         --  due to possible collision with identical names coming from other\n+         --  packages.\n+\n          else\n-            Coll_Id := Make_Temporary (Loc, 'F');\n+            Fin_Mas_Id := Make_Temporary (Loc, 'F');\n          end if;\n \n          Append_To (Actions,\n            Make_Object_Declaration (Loc,\n-             Defining_Identifier => Coll_Id,\n+             Defining_Identifier => Fin_Mas_Id,\n+             Aliased_Present     => True,\n              Object_Definition   =>\n-               New_Reference_To (RTE (RE_Finalization_Collection), Loc)));\n+               New_Reference_To (RTE (RE_Finalization_Master), Loc)));\n \n          --  Storage pool selection and attribute decoration of the generated\n-         --  collection. Since .NET/JVM compilers do not support pools, this\n-         --  step is skipped.\n+         --  master. Since .NET/JVM compilers do not support pools, this step\n+         --  is skipped.\n \n          if VM_Target = No_VM then\n \n             --  If the access type has a user-defined pool, use it as the base\n             --  storage medium for the finalization pool.\n \n-            if Present (Associated_Storage_Pool (Typ)) then\n-               Pool_Id := Associated_Storage_Pool (Typ);\n-\n-            --  Access subtypes must use the storage pool of their base type\n-\n-            elsif Ekind (Typ) = E_Access_Subtype then\n-               declare\n-                  Base_Typ : constant Entity_Id := Base_Type (Typ);\n-\n-               begin\n-                  if No (Associated_Storage_Pool (Base_Typ)) then\n-                     Pool_Id := Get_Global_Pool_For_Access_Type (Base_Typ);\n-                     Set_Associated_Storage_Pool (Base_Typ, Pool_Id);\n-                  else\n-                     Pool_Id := Associated_Storage_Pool (Base_Typ);\n-                  end if;\n-               end;\n+            if Present (Associated_Storage_Pool (Ptr_Typ)) then\n+               Pool_Id := Associated_Storage_Pool (Ptr_Typ);\n \n             --  The default choice is the global pool\n \n             else\n-               Pool_Id := Get_Global_Pool_For_Access_Type (Typ);\n-               Set_Associated_Storage_Pool (Typ, Pool_Id);\n+               Pool_Id := Get_Global_Pool_For_Access_Type (Ptr_Typ);\n+               Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n             end if;\n \n             --  Generate:\n-            --    Set_Storage_Pool_Ptr (Fnn, Pool_Id'Unchecked_Access);\n+            --    Set_Base_Pool (Fnn, Pool_Id'Unchecked_Access);\n \n             Append_To (Actions,\n               Make_Procedure_Call_Statement (Loc,\n                 Name                   =>\n-                  New_Reference_To (RTE (RE_Set_Storage_Pool_Ptr), Loc),\n+                  New_Reference_To (RTE (RE_Set_Base_Pool), Loc),\n                 Parameter_Associations => New_List (\n-                  New_Reference_To (Coll_Id, Loc),\n+                  New_Reference_To (Fin_Mas_Id, Loc),\n                   Make_Attribute_Reference (Loc,\n                     Prefix         => New_Reference_To (Pool_Id, Loc),\n                     Attribute_Name => Name_Unrestricted_Access))));\n          end if;\n \n-         Set_Associated_Collection (Typ, Coll_Id);\n+         Set_Finalization_Master (Ptr_Typ, Fin_Mas_Id);\n \n-         --  A finalization collection created for an anonymous access type\n-         --  must be inserted before a context-dependent node.\n+         --  A finalization master created for an anonymous access type must be\n+         --  inserted before a context-dependent node.\n \n          if Present (Ins_Node) then\n             Push_Scope (Encl_Scope);\n@@ -1024,12 +1019,12 @@ package body Exp_Ch7 is\n             Append_Freeze_Actions (Typ, Actions);\n \n          --  If there's a pool created locally for the access type, then we\n-         --  need to ensure that the collection gets created after the pool\n-         --  object, because otherwise we can have a forward reference, so\n-         --  we force the collection actions to be inserted and analyzed after\n-         --  the pool entity. Note that both the access type and its designated\n-         --  type may have already been frozen and had their freezing actions\n-         --  analyzed at this point. (This seems a little unclean.???)\n+         --  need to ensure that the master gets created after the pool object,\n+         --  because otherwise we can have a forward reference, so we force the\n+         --  master actions to be inserted and analyzed after the pool entity.\n+         --  Note that both the access type and its designated type may have\n+         --  already been frozen and had their freezing actions analyzed at\n+         --  this point. (This seems a little unclean.???)\n \n          elsif VM_Target = No_VM\n            and then Scope (Pool_Id) = Scope (Typ)\n@@ -1040,7 +1035,7 @@ package body Exp_Ch7 is\n             Insert_Actions (Parent (Typ), Actions);\n          end if;\n       end;\n-   end Build_Finalization_Collection;\n+   end Build_Finalization_Master;\n \n    ---------------------\n    -- Build_Finalizer --\n@@ -1933,15 +1928,15 @@ package body Exp_Ch7 is\n                end if;\n \n             --  Inspect the freeze node of an access-to-controlled type and\n-            --  look for a delayed finalization collection. This case arises\n-            --  when the freeze actions are inserted at a later time than the\n+            --  look for a delayed finalization master. This case arises when\n+            --  the freeze actions are inserted at a later time than the\n             --  expansion of the context. Since Build_Finalizer is never called\n-            --  on a single construct twice, the collection will be ultimately\n+            --  on a single construct twice, the master will be ultimately\n             --  left out and never finalized. This is also needed for freeze\n             --  actions of designated types themselves, since in some cases the\n-            --  finalization collection is associated with a designated type's\n+            --  finalization master is associated with a designated type's\n             --  freeze node rather than that of the access type (see handling\n-            --  for freeze actions in Build_Finalization_Collection).\n+            --  for freeze actions in Build_Finalization_Master).\n \n             elsif Nkind (Decl) = N_Freeze_Entity\n               and then Present (Actions (Decl))\n@@ -1958,12 +1953,12 @@ package body Exp_Ch7 is\n \n                   --  Freeze nodes are considered to be identical to packages\n                   --  and blocks in terms of nesting. The difference is that\n-                  --  a finalization collection created inside the freeze node\n-                  --  is at the same nesting level as the node itself.\n+                  --  a finalization master created inside the freeze node is\n+                  --  at the same nesting level as the node itself.\n \n                   Process_Declarations (Actions (Decl), Preprocess);\n \n-                  --  The freeze node contains a finalization collection\n+                  --  The freeze node contains a finalization master\n \n                   if Preprocess\n                     and then Top_Level\n@@ -2086,11 +2081,12 @@ package body Exp_Ch7 is\n          --  following cleanup code:\n          --\n          --    if BIPallocfrom > Secondary_Stack'Pos\n-         --      and then BIPcollection /= null\n+         --      and then BIPfinalizationmaster /= null\n          --    then\n          --       declare\n          --          type Ptr_Typ is access Obj_Typ;\n-         --          for Ptr_Typ'Storage_Pool use Base_Pool (BIPcollection);\n+         --          for Ptr_Typ'Storage_Pool\n+         --            use Base_Pool (BIPfinalizationmaster);\n          --\n          --       begin\n          --          Free (Ptr_Typ (Temp));\n@@ -2118,12 +2114,13 @@ package body Exp_Ch7 is\n          function Build_BIP_Cleanup_Stmts\n            (Func_Id : Entity_Id) return Node_Id\n          is\n-            Collect : constant Entity_Id :=\n-                        Build_In_Place_Formal (Func_Id, BIP_Collection);\n-            Decls   : constant List_Id := New_List;\n-            Obj_Typ : constant Entity_Id := Etype (Func_Id);\n-            Temp_Id : constant Entity_Id :=\n-                        Entity (Prefix (Name (Parent (Obj_Id))));\n+            Decls      : constant List_Id := New_List;\n+            Fin_Mas_Id : constant Entity_Id :=\n+                           Build_In_Place_Formal\n+                             (Func_Id, BIP_Finalization_Master);\n+            Obj_Typ    : constant Entity_Id := Etype (Func_Id);\n+            Temp_Id    : constant Entity_Id :=\n+                           Entity (Prefix (Name (Parent (Obj_Id))));\n \n             Cond      : Node_Id;\n             Free_Blk  : Node_Id;\n@@ -2133,7 +2130,7 @@ package body Exp_Ch7 is\n \n          begin\n             --  Generate:\n-            --    Pool_Id renames Base_Pool (BIPcollection.all).all;\n+            --    Pool_Id renames Base_Pool (BIPfinalizationmaster.all).all;\n \n             Pool_Id := Make_Temporary (Loc, 'P');\n \n@@ -2150,10 +2147,10 @@ package body Exp_Ch7 is\n                           New_Reference_To (RTE (RE_Base_Pool), Loc),\n                         Parameter_Associations => New_List (\n                           Make_Explicit_Dereference (Loc,\n-                            Prefix => New_Reference_To (Collect, Loc)))))));\n+                            Prefix => New_Reference_To (Fin_Mas_Id, Loc)))))));\n \n             --  Create an access type which uses the storage pool of the\n-            --  caller's collection.\n+            --  caller's finalization master.\n \n             --  Generate:\n             --    type Ptr_Typ is access Obj_Typ;\n@@ -2167,11 +2164,11 @@ package body Exp_Ch7 is\n                   Make_Access_To_Object_Definition (Loc,\n                     Subtype_Indication => New_Reference_To (Obj_Typ, Loc))));\n \n-            --  Perform minor decoration in order to set the collection and the\n+            --  Perform minor decoration in order to set the master and the\n             --  storage pool attributes.\n \n             Set_Ekind (Ptr_Typ, E_Access_Type);\n-            Set_Associated_Collection   (Ptr_Typ, Collect);\n+            Set_Finalization_Master     (Ptr_Typ, Fin_Mas_Id);\n             Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n \n             --  Create an explicit free statement. Note that the free uses the\n@@ -2203,18 +2200,18 @@ package body Exp_Ch7 is\n                     Statements => New_List (Free_Stmt)));\n \n             --  Generate:\n-            --    if BIPcollection /= null then\n+            --    if BIPfinalizationmaster /= null then\n \n             Cond :=\n               Make_Op_Ne (Loc,\n-                Left_Opnd  => New_Reference_To (Collect, Loc),\n+                Left_Opnd  => New_Reference_To (Fin_Mas_Id, Loc),\n                 Right_Opnd => Make_Null (Loc));\n \n             --  For constrained or tagged results escalate the condition to\n             --  include the allocation format. Generate:\n             --\n             --    if BIPallocform > Secondary_Stack'Pos\n-            --      and then BIPcollection /= null\n+            --      and then BIPfinalizationmaster /= null\n             --    then\n \n             if not Is_Constrained (Obj_Typ)\n@@ -2590,29 +2587,29 @@ package body Exp_Ch7 is\n             --  If we are dealing with a return object of a build-in-place\n             --  function, generate the following cleanup statements:\n             --\n-            --    if BIPallocfrom > Secondary_Stack'Pos then\n+            --    if BIPallocfrom > Secondary_Stack'Pos\n+            --      and then BIPfinalizationmaster /= null\n+            --    then\n             --       declare\n             --          type Ptr_Typ is access Obj_Typ;\n             --          for Ptr_Typ'Storage_Pool use\n-            --                Base_Pool (BIPcollection.all).all;\n+            --                Base_Pool (BIPfinalizationmaster.all).all;\n             --\n             --       begin\n             --          Free (Ptr_Typ (Temp));\n             --       end;\n             --    end if;\n             --\n             --  The generated code effectively detaches the temporary from the\n-            --  caller finalization chain and deallocates the object. This is\n+            --  caller finalization master and deallocates the object. This is\n             --  disabled on .NET/JVM because pools are not supported.\n \n-            --  H505-021 This needs to be revisited on .NET/JVM\n-\n             if VM_Target = No_VM and then Is_Return_Object (Obj_Id) then\n                declare\n                   Func_Id : constant Entity_Id := Enclosing_Function (Obj_Id);\n                begin\n                   if Is_Build_In_Place_Function (Func_Id)\n-                    and then Needs_BIP_Collection (Func_Id)\n+                    and then Needs_BIP_Finalization_Master (Func_Id)\n                   then\n                      Append_To (Fin_Stmts, Build_BIP_Cleanup_Stmts (Func_Id));\n                   end if;\n@@ -4632,7 +4629,7 @@ package body Exp_Ch7 is\n           Name                   =>\n             New_Reference_To (RTE (RE_Attach), Loc),\n           Parameter_Associations => New_List (\n-            New_Reference_To (Associated_Collection (Ptr_Typ), Loc),\n+            New_Reference_To (Finalization_Master (Ptr_Typ), Loc),\n             Unchecked_Convert_To (RTE (RE_Root_Controlled_Ptr), Obj_Ref)));\n    end Make_Attach_Call;\n \n@@ -6849,17 +6846,16 @@ package body Exp_Ch7 is\n             Fin_Id := Find_Prim_Op (Utyp, TSS_Deep_Finalize);\n          end if;\n \n-      --  For types that are both controlled and have controlled components,\n-      --  generate a call to Deep_Finalize.\n+      --  Derivations from [Limited_]Controlled\n \n-      elsif Is_Controlled (Utyp)\n-        and then Has_Controlled_Component (Utyp)\n-      then\n-         Fin_Id := Find_Prim_Op (Utyp, TSS_Deep_Finalize);\n+      elsif Is_Controlled (Utyp) then\n+         if Has_Controlled_Component (Utyp) then\n+            Fin_Id := Find_Prim_Op (Utyp, TSS_Deep_Finalize);\n+         else\n+            Fin_Id := Find_Prim_Op (Utyp, Name_Of (Finalize_Case));\n+         end if;\n \n-      --  For types that are not controlled themselves, but contain controlled\n-      --  components or can be extended by types with controlled components,\n-      --  create a call to Deep_Finalize.\n+      --  Class-wide types, interfaces and types with controlled components\n \n       elsif Is_Class_Wide_Type (Typ)\n         or else Is_Interface (Typ)\n@@ -6871,11 +6867,13 @@ package body Exp_Ch7 is\n             Fin_Id := TSS (Utyp, TSS_Deep_Finalize);\n          end if;\n \n-      --  For types that are derived from Controlled and do not have controlled\n-      --  components, build a call to Finalize.\n+      --  Tagged types\n+\n+      elsif Is_Tagged_Type (Utyp) then\n+         Fin_Id := Find_Prim_Op (Utyp, TSS_Deep_Finalize);\n \n       else\n-         Fin_Id := Find_Prim_Op (Utyp, Name_Of (Finalize_Case));\n+         raise Program_Error;\n       end if;\n \n       if Present (Fin_Id) then\n@@ -6927,13 +6925,17 @@ package body Exp_Ch7 is\n    --------------------------------\n \n    procedure Make_Finalize_Address_Body (Typ : Entity_Id) is\n+      Loc     : constant Source_Ptr := Sloc (Typ);\n+      Proc_Id : Entity_Id;\n+\n    begin\n       --  Nothing to do if the type is not controlled or it already has a\n       --  TSS entry for Finalize_Address. Skip class-wide subtypes which do not\n       --  come from source. These are usually generated for completeness and\n       --  do not need the Finalize_Address primitive.\n \n       if not Needs_Finalization (Typ)\n+        or else Is_Abstract_Type (Typ)\n         or else Present (TSS (Typ, TSS_Finalize_Address))\n         or else\n           (Is_Class_Wide_Type (Typ)\n@@ -6943,48 +6945,42 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n-      declare\n-         Loc     : constant Source_Ptr := Sloc (Typ);\n-         Proc_Id : Entity_Id;\n-\n-      begin\n-         Proc_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Make_TSS_Name (Typ, TSS_Finalize_Address));\n+      Proc_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Make_TSS_Name (Typ, TSS_Finalize_Address));\n \n-         --  Generate:\n-         --    procedure TypFD (V : System.Address) is\n-         --    begin\n-         --       declare\n-         --          type Pnn is access all Typ;\n-         --          for Pnn'Storage_Size use 0;\n-         --       begin\n-         --          [Deep_]Finalize (Pnn (V).all);\n-         --       end;\n-         --    end TypFD;\n+      --  Generate:\n+      --    procedure <Typ>FD (V : System.Address) is\n+      --    begin\n+      --       declare\n+      --          type Pnn is access all Typ;\n+      --          for Pnn'Storage_Size use 0;\n+      --       begin\n+      --          [Deep_]Finalize (Pnn (V).all);\n+      --       end;\n+      --    end TypFD;\n \n-         Discard_Node (\n-           Make_Subprogram_Body (Loc,\n-             Specification =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name => Proc_Id,\n+      Discard_Node (\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name => Proc_Id,\n \n-                 Parameter_Specifications => New_List (\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier =>\n-                       Make_Defining_Identifier (Loc, Name_V),\n-                     Parameter_Type =>\n-                       New_Reference_To (RTE (RE_Address), Loc)))),\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier =>\n+                    Make_Defining_Identifier (Loc, Name_V),\n+                  Parameter_Type =>\n+                    New_Reference_To (RTE (RE_Address), Loc)))),\n \n-             Declarations => No_List,\n+          Declarations => No_List,\n \n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements =>\n-                   Make_Finalize_Address_Stmts (Typ))));\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements =>\n+                Make_Finalize_Address_Stmts (Typ))));\n \n-         Set_TSS (Typ, Proc_Id);\n-      end;\n+      Set_TSS (Typ, Proc_Id);\n    end Make_Finalize_Address_Body;\n \n    ---------------------------------\n@@ -7415,86 +7411,6 @@ package body Exp_Ch7 is\n               Statements => Make_Deep_Record_Body (Finalize_Case, Typ, True)));\n    end Make_Local_Deep_Finalize;\n \n-   ----------------------------------------\n-   -- Make_Set_Finalize_Address_Ptr_Call --\n-   ----------------------------------------\n-\n-   function Make_Set_Finalize_Address_Ptr_Call\n-     (Loc     : Source_Ptr;\n-      Typ     : Entity_Id;\n-      Ptr_Typ : Entity_Id) return Node_Id\n-   is\n-      Desig_Typ : constant Entity_Id :=\n-                    Available_View (Designated_Type (Ptr_Typ));\n-      Utyp      : Entity_Id;\n-\n-   begin\n-      --  If the context is a class-wide allocator, we use the class-wide type\n-      --  to obtain the proper Finalize_Address routine.\n-\n-      if Is_Class_Wide_Type (Desig_Typ) then\n-         Utyp := Desig_Typ;\n-\n-      else\n-         Utyp := Typ;\n-\n-         if Is_Private_Type (Utyp) and then Present (Full_View (Utyp)) then\n-            Utyp := Full_View (Utyp);\n-         end if;\n-\n-         if Is_Concurrent_Type (Utyp) then\n-            Utyp := Corresponding_Record_Type (Utyp);\n-         end if;\n-      end if;\n-\n-      Utyp := Underlying_Type (Base_Type (Utyp));\n-\n-      --  Deal with non-tagged derivation of private views. If the parent is\n-      --  now known to be protected, the finalization routine is the one\n-      --  defined on the corresponding record of the ancestor (corresponding\n-      --  records do not automatically inherit operations, but maybe they\n-      --  should???)\n-\n-      if Is_Untagged_Derivation (Typ) then\n-         if Is_Protected_Type (Typ) then\n-            Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n-         else\n-            Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n-\n-            if Is_Protected_Type (Utyp) then\n-               Utyp := Corresponding_Record_Type (Utyp);\n-            end if;\n-         end if;\n-      end if;\n-\n-      --  If the underlying_type is a subtype, we are dealing with the\n-      --  completion of a private type. We need to access the base type and\n-      --  generate a conversion to it.\n-\n-      if Utyp /= Base_Type (Utyp) then\n-         pragma Assert (Is_Private_Type (Typ));\n-\n-         Utyp := Base_Type (Utyp);\n-      end if;\n-\n-      --  Generate:\n-      --    Set_Finalize_Address_Ptr\n-      --      (<Ptr_Typ>FC, <Utyp>FD'Unrestricted_Access);\n-\n-      return\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   =>\n-            New_Reference_To (RTE (RE_Set_Finalize_Address_Ptr), Loc),\n-\n-          Parameter_Associations => New_List (\n-            New_Reference_To (Associated_Collection (Ptr_Typ), Loc),\n-\n-            Make_Attribute_Reference (Loc,\n-              Prefix         =>\n-                New_Reference_To (TSS (Utyp, TSS_Finalize_Address), Loc),\n-              Attribute_Name => Name_Unrestricted_Access)));\n-   end Make_Set_Finalize_Address_Ptr_Call;\n-\n    --------------------------\n    -- Make_Transient_Block --\n    --------------------------"}, {"sha": "25b339559f9d530cbb83f794c7f0f883db4907a4", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -40,15 +40,15 @@ package Exp_Ch7 is\n    --  Create the procedures Deep_Initialize, Deep_Adjust and Deep_Finalize\n    --  that take care of finalization management at run-time.\n \n-   procedure Build_Finalization_Collection\n+   procedure Build_Finalization_Master\n      (Typ        : Entity_Id;\n       Ins_Node   : Node_Id := Empty;\n       Encl_Scope : Entity_Id := Empty);\n-   --  Build a finalization collection for an access type. The designated type\n-   --  may not necessarely be controlled or need finalization actions. The\n-   --  routine creates a wrapper around a user-defined storage pool or the\n-   --  general storage pool for access types. Ins_Nod and Encl_Scope are used\n-   --  in conjunction with anonymous access types. Ins_Node designates the\n+   --  Build a finalization master for an access type. The designated type may\n+   --  not necessarely be controlled or need finalization actions. The routine\n+   --  creates a wrapper around a user-defined storage pool or the general\n+   --  storage pool for access types. Ins_Nod and Encl_Scope are used in\n+   --  conjunction with anonymous access types. Ins_Node designates the\n    --  insertion point before which the collection should be added. Encl_Scope\n    --  is the scope of the context, either the enclosing record or the scope\n    --  of the related function.\n@@ -173,18 +173,6 @@ package Exp_Ch7 is\n    --  Create a special version of Deep_Finalize with identifier Nam. The\n    --  routine has state information and can parform partial finalization.\n \n-   function Make_Set_Finalize_Address_Ptr_Call\n-     (Loc     : Source_Ptr;\n-      Typ     : Entity_Id;\n-      Ptr_Typ : Entity_Id) return Node_Id;\n-   --  Generate the following call:\n-   --\n-   --    Set_Finalize_Address_Ptr (<Ptr_Typ>FC, <Typ>FD'Unrestricted_Access);\n-   --\n-   --  where Finalize_Address is the corresponding TSS primitive of type Typ\n-   --  and Ptr_Typ is the access type of the related allocation. Loc is the\n-   --  source location of the related allocator.\n-\n    --------------------------------------------\n    -- Task and Protected Object finalization --\n    --------------------------------------------"}, {"sha": "a23a923f4187d0e8bb022ec8e744abb43ba161f7", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 216, "deletions": 113, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -332,6 +332,9 @@ package body Exp_Util is\n       Desig_Typ : constant Entity_Id :=\n                     Available_View (Designated_Type (Ptr_Typ));\n \n+      function Find_Finalize_Address (Typ : Entity_Id) return Entity_Id;\n+      --  Locate TSS primitive Finalize_Address in type Typ\n+\n       function Find_Object (E : Node_Id) return Node_Id;\n       --  Given an arbitrary expression of an allocator, try to find an object\n       --  reference in it, otherwise return the original expression.\n@@ -340,6 +343,57 @@ package body Exp_Util is\n       --  Determine whether subprogram Subp denotes a custom allocate or\n       --  deallocate.\n \n+      ---------------------------\n+      -- Find_Finalize_Address --\n+      ---------------------------\n+\n+      function Find_Finalize_Address (Typ : Entity_Id) return Entity_Id is\n+         Utyp : Entity_Id := Typ;\n+\n+      begin\n+         if Is_Private_Type (Utyp)\n+           and then Present (Full_View (Utyp))\n+         then\n+            Utyp := Full_View (Utyp);\n+         end if;\n+\n+         if Is_Concurrent_Type (Utyp) then\n+            Utyp := Corresponding_Record_Type (Utyp);\n+         end if;\n+\n+         Utyp := Underlying_Type (Base_Type (Utyp));\n+\n+         --  Deal with non-tagged derivation of private views. If the parent is\n+         --  now known to be protected, the finalization routine is the one\n+         --  defined on the corresponding record of the ancestor (corresponding\n+         --  records do not automatically inherit operations, but maybe they\n+         --  should???)\n+\n+         if Is_Untagged_Derivation (Typ) then\n+            if Is_Protected_Type (Typ) then\n+               Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n+            else\n+               Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n+\n+               if Is_Protected_Type (Utyp) then\n+                  Utyp := Corresponding_Record_Type (Utyp);\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  If the underlying_type is a subtype, we are dealing with the\n+         --  completion of a private type. We need to access the base type and\n+         --  generate a conversion to it.\n+\n+         if Utyp /= Base_Type (Utyp) then\n+            pragma Assert (Is_Private_Type (Typ));\n+\n+            Utyp := Base_Type (Utyp);\n+         end if;\n+\n+         return TSS (Utyp, TSS_Finalize_Address);\n+      end Find_Finalize_Address;\n+\n       -----------------\n       -- Find_Object --\n       -----------------\n@@ -375,8 +429,7 @@ package body Exp_Util is\n       function Is_Allocate_Deallocate_Proc (Subp : Entity_Id) return Boolean is\n       begin\n          --  Look for a subprogram body with only one statement which is a\n-         --  call to one of the Allocate / Deallocate routines in package\n-         --  Ada.Finalization.Heap_Management.\n+         --  call to Allocate_Any_Controlled / Deallocate_Any_Controlled.\n \n          if Ekind (Subp) = E_Procedure\n            and then Nkind (Parent (Parent (Subp))) = N_Subprogram_Body\n@@ -394,8 +447,8 @@ package body Exp_Util is\n                   Proc := Entity (Name (First (Statements (HSS))));\n \n                   return\n-                    Is_RTE (Proc, RE_Allocate)\n-                      or else Is_RTE (Proc, RE_Deallocate);\n+                    Is_RTE (Proc, RE_Allocate_Any_Controlled)\n+                      or else Is_RTE (Proc, RE_Deallocate_Any_Controlled);\n                end if;\n             end;\n          end if;\n@@ -430,137 +483,191 @@ package body Exp_Util is\n          Size_Id : constant Entity_Id := Make_Temporary (Loc, 'S');\n \n          Actuals      : List_Id;\n-         Collect_Act  : Node_Id;\n-         Collect_Id   : Entity_Id;\n-         Collect_Typ  : Entity_Id;\n+         Fin_Addr_Id  : Entity_Id;\n+         Fin_Mas_Act  : Node_Id;\n+         Fin_Mas_Id   : Entity_Id;\n+         Fin_Mas_Typ  : Entity_Id;\n          Proc_To_Call : Entity_Id;\n \n       begin\n-         --  When dealing with an access subtype, use the collection of the\n-         --  base type.\n+         --  When dealing with an access subtype, always use the base type\n+         --  since it carries all the attributes.\n \n          if Ekind (Ptr_Typ) = E_Access_Subtype then\n-            Collect_Typ := Base_Type (Ptr_Typ);\n+            Fin_Mas_Typ := Base_Type (Ptr_Typ);\n          else\n-            Collect_Typ := Ptr_Typ;\n+            Fin_Mas_Typ := Ptr_Typ;\n          end if;\n \n-         Collect_Id  := Associated_Collection (Collect_Typ);\n-         Collect_Act := New_Reference_To (Collect_Id, Loc);\n+         Actuals := New_List;\n \n-         --  Handle the case where the collection is actually a pointer to a\n-         --  collection. This case arises in build-in-place functions.\n+         --  Step 1: Construct all the actuals for the call to library routine\n+         --  Allocate_Any_Controlled / Deallocate_Any_Controlled.\n \n-         if Is_Access_Type (Etype (Collect_Id)) then\n-            Collect_Act :=\n-              Make_Explicit_Dereference (Loc,\n-                Prefix => Collect_Act);\n-         end if;\n+         --  a) Storage pool\n \n-         --  Create the actuals for the call to Allocate / Deallocate\n+         Append_To (Actuals,\n+           New_Reference_To (Associated_Storage_Pool (Fin_Mas_Typ), Loc));\n \n-         Actuals := New_List (\n-           Collect_Act,\n-           New_Reference_To (Addr_Id, Loc),\n-           New_Reference_To (Size_Id, Loc),\n-           New_Reference_To (Alig_Id, Loc));\n+         if Is_Allocate then\n \n-         --  Generate a run-time check to determine whether a class-wide object\n-         --  is truly controlled.\n+            --  b) Subpool\n \n-         if Is_Class_Wide_Type (Desig_Typ)\n-           or else Is_Generic_Actual_Type (Desig_Typ)\n-         then\n-            declare\n-               Flag_Id   : constant Entity_Id := Make_Temporary (Loc, 'F');\n-               Flag_Expr : Node_Id;\n-               Param     : Node_Id;\n-               Temp      : Node_Id;\n+            if Present (Subpool_Handle_Name (Expr)) then\n+               Append_To (Actuals,\n+                 New_Reference_To (Entity (Subpool_Handle_Name (Expr)), Loc));\n+            else\n+               Append_To (Actuals, Make_Null (Loc));\n+            end if;\n \n-            begin\n-               if Is_Allocate then\n-                  Temp := Find_Object (Expression (Expr));\n+            --  c) Finalization master\n+\n+            if Needs_Finalization (Desig_Typ) then\n+               Fin_Mas_Id  := Finalization_Master (Fin_Mas_Typ);\n+               Fin_Mas_Act := New_Reference_To (Fin_Mas_Id, Loc);\n+\n+               --  Handle the case where the master is actually a pointer to a\n+               --  master. This case arises in build-in-place functions.\n+\n+               if Is_Access_Type (Etype (Fin_Mas_Id)) then\n+                  Append_To (Actuals, Fin_Mas_Act);\n                else\n-                  Temp := Expr;\n+                  Append_To (Actuals,\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => Fin_Mas_Act,\n+                      Attribute_Name => Name_Unrestricted_Access));\n                end if;\n+            else\n+               Append_To (Actuals, Make_Null (Loc));\n+            end if;\n \n-               --  Processing for generic actuals\n+            --  d) Finalize_Address\n \n-               if Is_Generic_Actual_Type (Desig_Typ) then\n-                  Flag_Expr :=\n-                    New_Reference_To (Boolean_Literals\n-                      (Needs_Finalization (Base_Type (Desig_Typ))), Loc);\n+            Fin_Addr_Id := Find_Finalize_Address (Desig_Typ);\n \n-               --  Processing for subtype indications\n+            if Present (Fin_Addr_Id) then\n+               Append_To (Actuals,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Reference_To (Fin_Addr_Id, Loc),\n+                   Attribute_Name => Name_Unrestricted_Access));\n+            else\n+               Append_To (Actuals, Make_Null (Loc));\n+            end if;\n+         end if;\n \n-               elsif Nkind (Temp) in N_Has_Entity\n-                 and then Is_Type (Entity (Temp))\n-               then\n-                  Flag_Expr :=\n-                    New_Reference_To (Boolean_Literals\n-                      (Needs_Finalization (Entity (Temp))), Loc);\n+         --  e) Address\n+         --  f) Storage_Size\n+         --  g) Alignment\n \n-               --  Generate a runtime check to test the controlled state of an\n-               --  object for the purposes of allocation / deallocation.\n+         Append_To (Actuals, New_Reference_To (Addr_Id, Loc));\n+         Append_To (Actuals, New_Reference_To (Size_Id, Loc));\n+         Append_To (Actuals, New_Reference_To (Alig_Id, Loc));\n \n-               else\n-                  --  The following case arises when allocating through an\n-                  --  interface class-wide type, generate:\n-                  --\n-                  --    Temp.all\n+         --  h) Is_Controlled\n \n-                  if Is_RTE (Etype (Temp), RE_Tag_Ptr) then\n-                     Param :=\n-                       Make_Explicit_Dereference (Loc,\n-                         Prefix =>\n-                           Relocate_Node (Temp));\n+         --  Generate a run-time check to determine whether a class-wide object\n+         --  is truly controlled.\n \n-                  --  Generate:\n-                  --    Temp'Tag\n+         if Needs_Finalization (Desig_Typ) then\n+            if Is_Class_Wide_Type (Desig_Typ)\n+              or else Is_Generic_Actual_Type (Desig_Typ)\n+            then\n+               declare\n+                  Flag_Id   : constant Entity_Id := Make_Temporary (Loc, 'F');\n+                  Flag_Expr : Node_Id;\n+                  Param     : Node_Id;\n+                  Temp      : Node_Id;\n \n+               begin\n+                  if Is_Allocate then\n+                     Temp := Find_Object (Expression (Expr));\n                   else\n-                     Param :=\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix =>\n-                           Relocate_Node (Temp),\n-                         Attribute_Name => Name_Tag);\n+                     Temp := Expr;\n                   end if;\n \n-                  --  Generate:\n-                  --    Needs_Finalization (Param)\n+                  --  Processing for generic actuals\n \n-                  Flag_Expr :=\n-                    Make_Function_Call (Loc,\n-                      Name =>\n-                        New_Reference_To (RTE (RE_Needs_Finalization), Loc),\n-                      Parameter_Associations => New_List (Param));\n-               end if;\n+                  if Is_Generic_Actual_Type (Desig_Typ) then\n+                     Flag_Expr :=\n+                       New_Reference_To (Boolean_Literals\n+                         (Needs_Finalization (Base_Type (Desig_Typ))), Loc);\n \n-               --  Create the temporary which represents the finalization state\n-               --  of the expression. Generate:\n-               --\n-               --    F : constant Boolean := <Flag_Expr>;\n+                  --  Processing for subtype indications\n \n-               Insert_Action (N,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Flag_Id,\n-                   Constant_Present => True,\n-                   Object_Definition =>\n-                     New_Reference_To (Standard_Boolean, Loc),\n-                   Expression => Flag_Expr));\n+                  elsif Nkind (Temp) in N_Has_Entity\n+                    and then Is_Type (Entity (Temp))\n+                  then\n+                     Flag_Expr :=\n+                       New_Reference_To (Boolean_Literals\n+                         (Needs_Finalization (Entity (Temp))), Loc);\n \n-               --  The flag acts as the fifth actual\n+                  --  Generate a runtime check to test the controlled state of\n+                  --  an object for the purposes of allocation / deallocation.\n \n-               Append_To (Actuals, New_Reference_To (Flag_Id, Loc));\n-            end;\n+                  else\n+                     --  The following case arises when allocating through an\n+                     --  interface class-wide type, generate:\n+                     --\n+                     --    Temp.all\n+\n+                     if Is_RTE (Etype (Temp), RE_Tag_Ptr) then\n+                        Param :=\n+                          Make_Explicit_Dereference (Loc,\n+                            Prefix =>\n+                              Relocate_Node (Temp));\n+\n+                     --  Generate:\n+                     --    Temp'Tag\n+\n+                     else\n+                        Param :=\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix =>\n+                              Relocate_Node (Temp),\n+                            Attribute_Name => Name_Tag);\n+                     end if;\n+\n+                     --  Generate:\n+                     --    Needs_Finalization (<Param>)\n+\n+                     Flag_Expr :=\n+                       Make_Function_Call (Loc,\n+                         Name =>\n+                           New_Reference_To (RTE (RE_Needs_Finalization), Loc),\n+                         Parameter_Associations => New_List (Param));\n+                  end if;\n+\n+                  --  Create the temporary which represents the finalization\n+                  --  state of the expression. Generate:\n+                  --\n+                  --    F : constant Boolean := <Flag_Expr>;\n+\n+                  Insert_Action (N,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Flag_Id,\n+                      Constant_Present => True,\n+                      Object_Definition =>\n+                        New_Reference_To (Standard_Boolean, Loc),\n+                      Expression => Flag_Expr));\n+\n+                  --  The flag acts as the last actual\n+\n+                  Append_To (Actuals, New_Reference_To (Flag_Id, Loc));\n+               end;\n+            end if;\n+         else\n+            Append_To (Actuals, New_Reference_To (Standard_False, Loc));\n          end if;\n \n+         --  Step 2: Build a wrapper Allocate / Deallocate which internally\n+         --  calls Allocate_Any_Controlled / Deallocate_Any_Controlled.\n+\n          --  Select the proper routine to call\n \n          if Is_Allocate then\n-            Proc_To_Call := RTE (RE_Allocate);\n+            Proc_To_Call := RTE (RE_Allocate_Any_Controlled);\n          else\n-            Proc_To_Call := RTE (RE_Deallocate);\n+            Proc_To_Call := RTE (RE_Deallocate_Any_Controlled);\n          end if;\n \n          --  Create a custom Allocate / Deallocate routine which has identical\n@@ -611,10 +718,6 @@ package body Exp_Util is\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => New_List (\n-\n-                  --  Allocate / Deallocate\n-                  --    (<Ptr_Typ collection>, A, S, L[, F]);\n-\n                    Make_Procedure_Call_Statement (Loc,\n                      Name =>\n                        New_Reference_To (Proc_To_Call, Loc),\n@@ -3752,7 +3855,7 @@ package body Exp_Util is\n           and then Nkind (Rel_Node) /= N_Simple_Return_Statement\n \n          --  Do not consider transient objects allocated on the heap since they\n-         --  are attached to a finalization collection.\n+         --  are attached to a finalization master.\n \n           and then not Is_Allocated (Obj_Id)\n \n@@ -6431,16 +6534,16 @@ package body Exp_Util is\n                return True;\n             end if;\n \n-         --  Inspect the freeze node of an access-to-controlled type and\n-         --  look for a delayed finalization collection. This case arises\n-         --  when the freeze actions are inserted at a later time than the\n-         --  expansion of the context. Since Build_Finalizer is never called\n-         --  on a single construct twice, the collection will be ultimately\n-         --  left out and never finalized. This is also needed for freeze\n-         --  actions of designated types themselves, since in some cases the\n-         --  finalization collection is associated with a designated type's\n-         --  freeze node rather than that of the access type (see handling\n-         --  for freeze actions in Build_Finalization_Collection).\n+         --  Inspect the freeze node of an access-to-controlled type and look\n+         --  for a delayed finalization master. This case arises when the\n+         --  freeze actions are inserted at a later time than the expansion of\n+         --  the context. Since Build_Finalizer is never called on a single\n+         --  construct twice, the master will be ultimately left out and never\n+         --  finalized. This is also needed for freeze actions of designated\n+         --  types themselves, since in some cases the finalization master is\n+         --  associated with a designated type's freeze node rather than that\n+         --  of the access type (see handling for freeze actions in\n+         --  Build_Finalization_Master).\n \n          elsif Nkind (Decl) = N_Freeze_Entity\n            and then Present (Actions (Decl))\n@@ -6451,9 +6554,9 @@ package body Exp_Util is\n                   and then not Is_Access_Subprogram_Type (Typ)\n                   and then Needs_Finalization\n                              (Available_View (Designated_Type (Typ))))\n-                 or else\n-                   (Is_Type (Typ)\n-                     and then Needs_Finalization (Typ)))\n+               or else\n+                (Is_Type (Typ)\n+                   and then Needs_Finalization (Typ)))\n               and then Requires_Cleanup_Actions\n                          (Actions (Decl), For_Package, Nested_Constructs)\n             then"}, {"sha": "7058ceb887d9305436a62ee0bbffe36b0caac08b", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -202,21 +202,7 @@ package Exp_Util is\n    --  allocation, N is the declaration of the temporary variable which\n    --  represents the expression of the original allocator node, otherwise N\n    --  must be a free statement. If flag Is_Allocate is set, the generated\n-   --  routine is allocate, deallocate otherwise. The generated routine is:\n-   --\n-   --     F : constant Boolean :=                          --  CW case\n-   --           Ada.Tags.Needs_Finalization (<Expr>'Tag);  --  CW case\n-   --\n-   --     procedure Allocate / Deallocate\n-   --       (P : Storage_Pool;\n-   --        A : [out] Address;  --  out is present for Allocate\n-   --        S : Storage_Count;\n-   --        L : Storage_Count)\n-   --     is\n-   --     begin\n-   --        Allocate / Deallocate\n-   --          (<Ptr_Typ collection>, A, S, L, [Needs_Header => F]);\n-   --     end Allocate;\n+   --  routine is allocate, deallocate otherwise.\n \n    function Build_Runtime_Call (Loc : Source_Ptr; RE : RE_Id) return Node_Id;\n    --  Build an N_Procedure_Call_Statement calling the given runtime entity."}, {"sha": "3532f096c98a1dd9cb14603d8369e4432c3d3eff", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -1432,27 +1432,27 @@ package body Freeze is\n                end loop;\n             end;\n \n-         --  We add finalization collections to access types whose designated\n-         --  types require finalization. This is normally done when freezing\n-         --  the type, but this misses recursive type definitions where the\n-         --  later members of the recursion introduce controlled components\n-         --  (such as can happen when incomplete types are involved), as well\n-         --  cases where a component type is private and the controlled full\n-         --  type occurs after the access type is frozen. Cases that don't\n-         --  need a finalization collection are generic formal types (the\n-         --  actual type will have it) and types with Java and CIL conventions,\n-         --  since those are used for API bindings. (Are there any other cases\n-         --  that should be excluded here???)\n+         --  We add finalization masters to access types whose designated types\n+         --  require finalization. This is normally done when freezing the\n+         --  type, but this misses recursive type definitions where the later\n+         --  members of the recursion introduce controlled components (such as\n+         --  can happen when incomplete types are involved), as well cases\n+         --  where a component type is private and the controlled full type\n+         --  occurs after the access type is frozen. Cases that don't need a\n+         --  finalization master are generic formal types (the actual type will\n+         --  have it) and types with Java and CIL conventions, since those are\n+         --  used for API bindings. (Are there any other cases that should be\n+         --  excluded here???)\n \n          elsif Is_Access_Type (E)\n            and then Comes_From_Source (E)\n            and then not Is_Generic_Type (E)\n            and then Needs_Finalization (Designated_Type (E))\n-           and then No (Associated_Collection (E))\n+           and then No (Finalization_Master (E))\n            and then Convention (Designated_Type (E)) /= Convention_Java\n            and then Convention (Designated_Type (E)) /= Convention_CIL\n          then\n-            Build_Finalization_Collection (E);\n+            Build_Finalization_Master (E);\n          end if;\n \n          Next_Entity (E);\n@@ -2029,7 +2029,7 @@ package body Freeze is\n             Next_Entity (Comp);\n          end loop;\n \n-         --  Deal with Bit_Order aspect specifying a non-default bit order\n+         --  Deal with pragma Bit_Order setting non-standard bit order\n \n          if Reverse_Bit_Order (Rec) and then Base_Type (Rec) = Rec then\n             if not Placed_Component then"}, {"sha": "3b96918f92829332324bd15e2f65167fac405f37", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -111,6 +111,7 @@ package body Impunit is\n      \"a-titest\",    -- Ada.Text_IO.Text_Streams\n      \"a-unccon\",    -- Ada.Unchecked_Conversion\n      \"a-uncdea\",    -- Ada.Unchecked_Deallocation\n+     \"a-undesu\",    -- Ada.Unchecked_Deallocate_Subpool\n      \"a-witeio\",    -- Ada.Wide_Text_IO\n      \"a-wtcoio\",    -- Ada.Wide_Text_IO.Complex_IO\n      \"a-wtedit\",    -- Ada.Wide_Text_IO.Editing\n@@ -339,6 +340,7 @@ package body Impunit is\n      \"s-rpc   \",    -- System.Rpc\n      \"s-stoele\",    -- System.Storage_Elements\n      \"s-stopoo\",    -- System.Storage_Pools\n+     \"s-stposu\",    -- System.Storage_Pools.Subpools\n \n    --------------------------------------\n    -- GNAT Defined Additions to System --"}, {"sha": "d4b07a97db129e90bd4bc421b742996db351e533", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -293,9 +293,6 @@ package body Rtsfind is\n          elsif U_Id in Ada_Dispatching_Child then\n             Name_Buffer (16) := '.';\n \n-         elsif U_Id in Ada_Finalization_Child then\n-            Name_Buffer (17) := '.';\n-\n          elsif U_Id in Ada_Interrupts_Child then\n             Name_Buffer (15) := '.';\n \n@@ -324,6 +321,10 @@ package body Rtsfind is\n       elsif U_Id in System_Child then\n          Name_Buffer (7) := '.';\n \n+         if U_Id in System_Storage_Pools_Child then\n+            Name_Buffer (21) := '.';\n+         end if;\n+\n          if U_Id in System_Strings_Child then\n             Name_Buffer (15) := '.';\n          end if;"}, {"sha": "48f4a33ab074519eb6a20cdbf34f6a79dd544f54", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -48,9 +48,6 @@ package Rtsfind is\n    --    eventually, packages implementing delays will be found relative to\n    --    the package that declares the time type.\n \n-   --    Names of the form Ada_Finalization_xxx are second level children of\n-   --    Ada.Finalization.\n-\n    --    Names of the form Ada_Interrupts_xxx are second level children of\n    --    Ada.Interrupts. This is needed for Ada.Interrupts.Names which is used\n    --    by pragma Interrupt_State.\n@@ -80,6 +77,9 @@ package Rtsfind is\n    --    name is System.xxx. For example, the name System_Str_Concat refers to\n    --    package System.Str_Concat.\n \n+   --    Names of the form System_Storage_Pools_xxx are second level children\n+   --    of the package System.Storage_Pools.\n+\n    --    Names of the form System_Strings_xxx are second level children of the\n    --    package System.Strings.\n \n@@ -140,10 +140,6 @@ package Rtsfind is\n \n       Ada_Dispatching_EDF,\n \n-      --  Children of Ada.Finalization\n-\n-      Ada_Finalization_Heap_Management,\n-\n       --  Children of Ada.Interrupts\n \n       Ada_Interrupts_Names,\n@@ -249,6 +245,7 @@ package Rtsfind is\n       System_Fat_VAX_D_Float,\n       System_Fat_VAX_F_Float,\n       System_Fat_VAX_G_Float,\n+      System_Finalization_Masters,\n       System_Finalization_Root,\n       System_Fore,\n       System_Img_Bool,\n@@ -374,6 +371,10 @@ package Rtsfind is\n       System_WWd_Enum,\n       System_WWd_Wchar,\n \n+      --  Children of System.Storage_Pools\n+\n+      System_Storage_Pools_Subpools,\n+\n       --  Children of System.Strings\n \n       System_Strings_Stream_Ops,\n@@ -403,10 +404,6 @@ package Rtsfind is\n      range Ada_Dispatching_EDF .. Ada_Dispatching_EDF;\n    --  Range of values for children of Ada.Dispatching\n \n-   subtype Ada_Finalization_Child is Ada_Child range\n-     Ada_Finalization_Heap_Management .. Ada_Finalization_Heap_Management;\n-   --  Range of values for children of Ada.Finalization\n-\n    subtype Ada_Interrupts_Child is Ada_Child range\n      Ada_Interrupts_Names .. Ada_Interrupts_Names;\n    --  Range of values for children of Ada.Interrupts\n@@ -443,6 +440,9 @@ package Rtsfind is\n      range System_Address_Image .. System_Tasking_Stages;\n    --  Range of values for children or grandchildren of System\n \n+   subtype System_Storage_Pools_Child is RTU_Id\n+     range System_Storage_Pools_Subpools .. System_Storage_Pools_Subpools;\n+\n    subtype System_Strings_Child is RTU_Id\n      range System_Strings_Stream_Ops .. System_Strings_Stream_Ops;\n \n@@ -521,17 +521,6 @@ package Rtsfind is\n      RE_Reraise_Occurrence_No_Defer,     -- Ada.Exceptions\n      RE_Save_Occurrence,                 -- Ada.Exceptions\n \n-     RE_Add_Offset_To_Address,           -- Ada.Finalization.Heap_Management\n-     RE_Allocate,                        -- Ada.Finalization.Heap_Management\n-     RE_Attach,                          -- Ada.Finalization.Heap_Management\n-     RE_Base_Pool,                       -- Ada.Finalization.Heap_Management\n-     RE_Deallocate,                      -- Ada.Finalization.Heap_Management\n-     RE_Detach,                          -- Ada.Finalization.Heap_Management\n-     RE_Finalization_Collection,         -- Ada.Finalization.Heap_Management\n-     RE_Finalization_Collection_Ptr,     -- Ada.Finalization.Heap_Management\n-     RE_Set_Finalize_Address_Ptr,        -- Ada.Finalization.Heap_Management\n-     RE_Set_Storage_Pool_Ptr,            -- Ada.Finalization.Heap_Management\n-\n      RE_Interrupt_ID,                    -- Ada.Interrupts\n      RE_Is_Reserved,                     -- Ada.Interrupts\n      RE_Is_Attached,                     -- Ada.Interrupts\n@@ -805,6 +794,14 @@ package Rtsfind is\n      RE_Attr_VAX_G_Float,                -- System.Fat_VAX_G_Float\n      RE_Fat_VAX_G,                       -- System.Fat_VAX_G_Float\n \n+     RE_Add_Offset_To_Address,           -- System.Finalization_Masters\n+     RE_Attach,                          -- System.Finalization_Masters\n+     RE_Base_Pool,                       -- System.Finalization_Masters\n+     RE_Detach,                          -- System.Finalization_Masters\n+     RE_Finalization_Master,             -- System.Finalization_Masters\n+     RE_Finalization_Master_Ptr,         -- System.Finalization_Masters\n+     RE_Set_Base_Pool,                   -- System.Finalization_Masters\n+\n      RE_Root_Controlled,                 -- System.Finalization_Root\n      RE_Root_Controlled_Ptr,             -- System.Finalization_Root\n \n@@ -1327,9 +1324,15 @@ package Rtsfind is\n      RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n \n+     RE_Allocate_Any,                    -- System.Storage_Pools\n+     RE_Deallocate_Any,                  -- System.Storage_Pools\n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n-     RE_Allocate_Any,                    -- System.Storage_Pools,\n-     RE_Deallocate_Any,                  -- System.Storage_Pools,\n+\n+     RE_Allocate_Any_Controlled,         -- System.Storage_Pools.Subpools\n+     RE_Deallocate_Any_Controlled,       -- System.Storage_Pools.Subpools\n+     RE_Root_Storage_Pool_With_Subpools, -- System.Storage_Pools.Subpools\n+     RE_Root_Subpool,                    -- System.Storage_Pools.Subpools\n+     RE_Subpool_Handle,                  -- System.Storage_Pools.Subpools\n \n      RE_I_AD,                            -- System.Stream_Attributes\n      RE_I_AS,                            -- System.Stream_Attributes\n@@ -1704,17 +1707,6 @@ package Rtsfind is\n      RE_Reraise_Occurrence_No_Defer      => Ada_Exceptions,\n      RE_Save_Occurrence                  => Ada_Exceptions,\n \n-     RE_Add_Offset_To_Address            => Ada_Finalization_Heap_Management,\n-     RE_Allocate                         => Ada_Finalization_Heap_Management,\n-     RE_Attach                           => Ada_Finalization_Heap_Management,\n-     RE_Base_Pool                        => Ada_Finalization_Heap_Management,\n-     RE_Deallocate                       => Ada_Finalization_Heap_Management,\n-     RE_Detach                           => Ada_Finalization_Heap_Management,\n-     RE_Finalization_Collection          => Ada_Finalization_Heap_Management,\n-     RE_Finalization_Collection_Ptr      => Ada_Finalization_Heap_Management,\n-     RE_Set_Finalize_Address_Ptr         => Ada_Finalization_Heap_Management,\n-     RE_Set_Storage_Pool_Ptr             => Ada_Finalization_Heap_Management,\n-\n      RE_Interrupt_ID                     => Ada_Interrupts,\n      RE_Is_Reserved                      => Ada_Interrupts,\n      RE_Is_Attached                      => Ada_Interrupts,\n@@ -1988,6 +1980,14 @@ package Rtsfind is\n      RE_Attr_VAX_G_Float                 => System_Fat_VAX_G_Float,\n      RE_Fat_VAX_G                        => System_Fat_VAX_G_Float,\n \n+     RE_Add_Offset_To_Address            => System_Finalization_Masters,\n+     RE_Attach                           => System_Finalization_Masters,\n+     RE_Base_Pool                        => System_Finalization_Masters,\n+     RE_Detach                           => System_Finalization_Masters,\n+     RE_Finalization_Master              => System_Finalization_Masters,\n+     RE_Finalization_Master_Ptr          => System_Finalization_Masters,\n+     RE_Set_Base_Pool                    => System_Finalization_Masters,\n+\n      RE_Root_Controlled                  => System_Finalization_Root,\n      RE_Root_Controlled_Ptr              => System_Finalization_Root,\n \n@@ -2510,9 +2510,15 @@ package Rtsfind is\n      RE_Storage_Offset                   => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n \n-     RE_Root_Storage_Pool                => System_Storage_Pools,\n      RE_Allocate_Any                     => System_Storage_Pools,\n      RE_Deallocate_Any                   => System_Storage_Pools,\n+     RE_Root_Storage_Pool                => System_Storage_Pools,\n+\n+     RE_Allocate_Any_Controlled          => System_Storage_Pools_Subpools,\n+     RE_Deallocate_Any_Controlled        => System_Storage_Pools_Subpools,\n+     RE_Root_Storage_Pool_With_Subpools  => System_Storage_Pools_Subpools,\n+     RE_Root_Subpool                     => System_Storage_Pools_Subpools,\n+     RE_Subpool_Handle                   => System_Storage_Pools_Subpools,\n \n      RE_I_AD                             => System_Stream_Attributes,\n      RE_I_AS                             => System_Stream_Attributes,"}, {"sha": "7a5be2cd3c1b4946b4bf864bf529881d08bf5803", "filename": "gcc/ada/s-finmas.adb", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -0,0 +1,214 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . F I N A L I Z A T I O N _ M A S T E R S          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Exceptions;          use Ada.Exceptions;\n+\n+with System.Soft_Links;       use System.Soft_Links;\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+package body System.Finalization_Masters is\n+\n+   ---------------------------\n+   -- Add_Offset_To_Address --\n+   ---------------------------\n+\n+   function Add_Offset_To_Address\n+     (Addr   : System.Address;\n+      Offset : System.Storage_Elements.Storage_Offset) return System.Address\n+   is\n+   begin\n+      return System.Storage_Elements.\"+\" (Addr, Offset);\n+   end Add_Offset_To_Address;\n+\n+   ------------\n+   -- Attach --\n+   ------------\n+\n+   procedure Attach (N : not null FM_Node_Ptr; L : not null FM_Node_Ptr) is\n+   begin\n+      Lock_Task.all;\n+\n+      L.Next.Prev := N;\n+      N.Next := L.Next;\n+      L.Next := N;\n+      N.Prev := L;\n+\n+      Unlock_Task.all;\n+\n+      --  Note: No need to unlock in case of an exception because the above\n+      --  code can never raise one.\n+   end Attach;\n+\n+   ---------------\n+   -- Base_Pool --\n+   ---------------\n+\n+   function Base_Pool\n+     (Master : Finalization_Master) return Any_Storage_Pool_Ptr\n+   is\n+   begin\n+      return Master.Base_Pool;\n+   end Base_Pool;\n+\n+   ------------\n+   -- Detach --\n+   ------------\n+\n+   procedure Detach (N : not null FM_Node_Ptr) is\n+   begin\n+      --  N must be attached to some list\n+\n+      pragma Assert (N.Next /= null and then N.Prev /= null);\n+\n+      Lock_Task.all;\n+\n+      N.Prev.Next := N.Next;\n+      N.Next.Prev := N.Prev;\n+\n+      Unlock_Task.all;\n+\n+      --  Note: No need to unlock in case of an exception because the above\n+      --  code can never raise one.\n+   end Detach;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   overriding procedure Finalize (Master : in out Finalization_Master) is\n+      Curr_Ptr : FM_Node_Ptr;\n+      Ex_Occur : Exception_Occurrence;\n+      Obj_Addr : Address;\n+      Raised   : Boolean := False;\n+\n+   begin\n+      --  It is possible for multiple tasks to cause the finalization of the\n+      --  same master. Let only one task finalize the objects.\n+\n+      if Master.Finalization_Started then\n+         return;\n+      end if;\n+\n+      --  Lock the master to prevent any allocations while the objects are\n+      --  being finalized. The master remains locked because either the master\n+      --  is explicitly deallocated or the associated access type is about to\n+      --  go out of scope.\n+\n+      Master.Finalization_Started := True;\n+\n+      --  Skip the dummy head\n+\n+      Curr_Ptr := Master.Objects.Next;\n+      while Curr_Ptr /= Master.Objects'Unchecked_Access loop\n+         begin\n+            --  If primitive Finalize_Address is not set, then the expansion of\n+            --  the designated type or that of the allocator failed. This is a\n+            --  serious error.\n+\n+            --  Note: The Program_Error must be raised from the same block as\n+            --  the finalization call. If Finalize_Address is not present for\n+            --  a particular object, this should not stop the finalization of\n+            --  the remaining objects.\n+\n+            if Curr_Ptr.Finalize_Address = null then\n+               raise Program_Error\n+                 with \"primitive Finalize_Address not available\";\n+\n+            --  Skip the list header in order to offer proper object layout for\n+            --  finalization and call Finalize_Address.\n+\n+            else\n+               Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n+               Curr_Ptr.Finalize_Address (Obj_Addr);\n+            end if;\n+\n+         exception\n+            when Fin_Occur : others =>\n+               if not Raised then\n+                  Raised := True;\n+                  Save_Occurrence (Ex_Occur, Fin_Occur);\n+               end if;\n+         end;\n+\n+         Curr_Ptr := Curr_Ptr.Next;\n+      end loop;\n+\n+      --  If the finalization of a particular object failed or Finalize_Address\n+      --  was not set, reraise the exception now.\n+\n+      if Raised then\n+         Reraise_Occurrence (Ex_Occur);\n+      end if;\n+   end Finalize;\n+\n+   -----------------\n+   -- Header_Size --\n+   -----------------\n+\n+   function Header_Size return System.Storage_Elements.Storage_Count is\n+   begin\n+      return FM_Node'Size / Storage_Unit;\n+   end Header_Size;\n+\n+   -------------------\n+   -- Header_Offset --\n+   -------------------\n+\n+   function Header_Offset return System.Storage_Elements.Storage_Offset is\n+   begin\n+      return FM_Node'Size / Storage_Unit;\n+   end Header_Offset;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   overriding procedure Initialize (Master : in out Finalization_Master) is\n+   begin\n+      --  The dummy head must point to itself in both directions\n+\n+      Master.Objects.Next := Master.Objects'Unchecked_Access;\n+      Master.Objects.Prev := Master.Objects'Unchecked_Access;\n+   end Initialize;\n+\n+   -------------------\n+   -- Set_Base_Pool --\n+   -------------------\n+\n+   procedure Set_Base_Pool\n+     (Master   : in out Finalization_Master;\n+      Pool_Ptr : Any_Storage_Pool_Ptr)\n+   is\n+   begin\n+      Master.Base_Pool := Pool_Ptr;\n+   end Set_Base_Pool;\n+\n+end System.Finalization_Masters;"}, {"sha": "26783d331729a4a3fc68ed8a71bec4e1ca6bd709", "filename": "gcc/ada/s-finmas.ads", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -0,0 +1,135 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . F I N A L I Z A T I O N _ M A S T E R S          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Finalization;\n+with Ada.Unchecked_Conversion;\n+\n+with System.Storage_Elements;\n+with System.Storage_Pools;\n+\n+package System.Finalization_Masters is\n+   pragma Preelaborate (System.Finalization_Masters);\n+\n+   --  A reference to primitive Finalize_Address. The expander generates an\n+   --  implementation of this procedure for each controlled and class-wide\n+   --  type. Since controlled objects are simply viewed as addresses once\n+   --  allocated through a master, Finalize_Address provides a backward\n+   --  indirection from an address to a type-specific context.\n+\n+   type Finalize_Address_Ptr is access procedure (Obj : System.Address);\n+\n+   --  Heterogeneous collection type structure. The implementation allows for\n+   --  finalizable objects of different base types to be serviced by the same\n+   --  master.\n+\n+   type FM_Node;\n+   type FM_Node_Ptr is access all FM_Node;\n+\n+   type FM_Node is record\n+      Prev             : FM_Node_Ptr := null;\n+      Next             : FM_Node_Ptr := null;\n+      Finalize_Address : Finalize_Address_Ptr := null;\n+   end record;\n+\n+   --  A reference to any derivation from Root_Storage_Pool. Since this type\n+   --  may not be used to allocate objects, its storage size is zero.\n+\n+   type Any_Storage_Pool_Ptr is\n+     access System.Storage_Pools.Root_Storage_Pool'Class;\n+   for Any_Storage_Pool_Ptr'Storage_Size use 0;\n+\n+   --  Finalization master type structure. A unique master is associated with\n+   --  each access-to-controlled or access-to-class-wide type. Masters also act\n+   --  as components of subpools.\n+\n+   type Finalization_Master is\n+     new Ada.Finalization.Limited_Controlled with\n+   record\n+      Base_Pool : Any_Storage_Pool_Ptr := null;\n+      --  A reference to the pool which this finalization master services. This\n+      --  field is used in conjunction with the build-in-place machinery.\n+\n+      Objects : aliased FM_Node;\n+      --  A doubly linked list which contains the headers of all controlled\n+      --  objects allocated in a [sub]pool.\n+\n+      Finalization_Started : Boolean := False;\n+      pragma Atomic (Finalization_Started);\n+      --  A flag used to detect allocations which occur during the finalization\n+      --  of a master. The allocations must raise Program_Error. This scenario\n+      --  may arise in a multitask environment. The flag is atomic because it\n+      --  is accessed without Lock_Task / Unlock_Task.\n+   end record;\n+\n+   type Finalization_Master_Ptr is access all Finalization_Master;\n+   for Finalization_Master_Ptr'Storage_Size use 0;\n+\n+   --  Since RTSfind cannot contain names of the form RE_\"+\", the following\n+   --  routine serves as a wrapper around System.Storage_Elements.\"+\".\n+\n+   function Add_Offset_To_Address\n+     (Addr   : System.Address;\n+      Offset : System.Storage_Elements.Storage_Offset) return System.Address;\n+\n+   function Address_To_FM_Node_Ptr is\n+     new Ada.Unchecked_Conversion (Address, FM_Node_Ptr);\n+\n+   procedure Attach (N : not null FM_Node_Ptr; L : not null FM_Node_Ptr);\n+   --  Prepend a node to a specific finalization master\n+\n+   function Base_Pool\n+     (Master : Finalization_Master) return Any_Storage_Pool_Ptr;\n+   --  Return a reference to the underlying storage pool on which the master\n+   --  operates.\n+\n+   procedure Detach (N : not null FM_Node_Ptr);\n+   --  Remove a node from an arbitrary finalization master\n+\n+   overriding procedure Finalize (Master : in out Finalization_Master);\n+   --  Lock the master to prevent allocations during finalization. Iterate over\n+   --  the list of allocated controlled objects, finalizing each one by calling\n+   --  its specific Finalize_Address. In the end, deallocate the dummy head.\n+\n+   function Header_Size return System.Storage_Elements.Storage_Count;\n+   --  Return the size of type FM_Node as Storage_Count\n+\n+   function Header_Offset return System.Storage_Elements.Storage_Offset;\n+   --  Return the size of type FM_Node as Storage_Offset\n+\n+   overriding procedure Initialize (Master : in out Finalization_Master);\n+   --  Initialize the dummy head of a finalization master\n+\n+   procedure Set_Base_Pool\n+     (Master   : in out Finalization_Master;\n+      Pool_Ptr : Any_Storage_Pool_Ptr);\n+   --  Set the underlying pool of a finalization master\n+\n+end System.Finalization_Masters;"}, {"sha": "3ac5beb176c833d576f3231c6b6c6d127d1ec9ae", "filename": "gcc/ada/s-stopoo.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stopoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stopoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stopoo.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2009 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,13 +37,12 @@ package body System.Storage_Pools is\n \n    procedure Allocate_Any\n     (Pool                     : in out Root_Storage_Pool'Class;\n-     Storage_Address          : out Address;\n+     Storage_Address          : out System.Address;\n      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n      Alignment                : System.Storage_Elements.Storage_Count)\n    is\n    begin\n-      Allocate\n-        (Pool, Storage_Address, Size_In_Storage_Elements, Alignment);\n+      Allocate (Pool, Storage_Address, Size_In_Storage_Elements, Alignment);\n    end Allocate_Any;\n \n    --------------------\n@@ -52,12 +51,12 @@ package body System.Storage_Pools is\n \n    procedure Deallocate_Any\n     (Pool                     : in out Root_Storage_Pool'Class;\n-     Storage_Address          : Address;\n+     Storage_Address          : System.Address;\n      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n      Alignment                : System.Storage_Elements.Storage_Count)\n    is\n    begin\n-      Deallocate\n-        (Pool, Storage_Address, Size_In_Storage_Elements, Alignment);\n+      Deallocate (Pool, Storage_Address, Size_In_Storage_Elements, Alignment);\n    end Deallocate_Any;\n+\n end System.Storage_Pools;"}, {"sha": "1c4d12754a0f41304d155a8096fea08ce237609a", "filename": "gcc/ada/s-stopoo.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stopoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stopoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stopoo.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,14 +44,14 @@ package System.Storage_Pools is\n \n    procedure Allocate\n      (Pool                     : in out Root_Storage_Pool;\n-      Storage_Address          : out Address;\n+      Storage_Address          : out System.Address;\n       Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n       Alignment                : System.Storage_Elements.Storage_Count)\n    is abstract;\n \n    procedure Deallocate\n      (Pool                     : in out Root_Storage_Pool;\n-      Storage_Address          : Address;\n+      Storage_Address          : System.Address;\n       Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n       Alignment                : System.Storage_Elements.Storage_Count)\n    is abstract;\n@@ -62,6 +62,13 @@ package System.Storage_Pools is\n    is abstract;\n \n private\n+   type Root_Storage_Pool is abstract\n+     new Ada.Finalization.Limited_Controlled with null record;\n+\n+   --  ??? Are these two still needed? It might be possible to use Subpools.\n+   --  Allocate_Any_Controlled / Deallocate_Any_Controlled for non-controlled\n+   --  objects.\n+\n    --  The following two procedures support the use of class-wide pool\n    --  objects in storage pools. When a local type is given a class-wide\n    --  storage pool, allocation and deallocation for the type must dispatch\n@@ -71,16 +78,14 @@ private\n \n    procedure Allocate_Any\n     (Pool                     : in out Root_Storage_Pool'Class;\n-     Storage_Address          : out Address;\n+     Storage_Address          : out System.Address;\n      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n      Alignment                : System.Storage_Elements.Storage_Count);\n \n    procedure Deallocate_Any\n     (Pool                     : in out Root_Storage_Pool'Class;\n-     Storage_Address          : Address;\n+     Storage_Address          : System.Address;\n      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n      Alignment                : System.Storage_Elements.Storage_Count);\n \n-   type Root_Storage_Pool is abstract\n-     new Ada.Finalization.Limited_Controlled with null record;\n end System.Storage_Pools;"}, {"sha": "a4c0bb6c8ea361581494b8826b42e5db0c7679b0", "filename": "gcc/ada/s-stposu.adb", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -0,0 +1,473 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--        S Y S T E M . S T O R A G E _ P O O L S . S U B P O O L S         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Exceptions;              use Ada.Exceptions;\n+with Ada.Unchecked_Deallocation;\n+\n+with System.Finalization_Masters; use System.Finalization_Masters;\n+with System.Soft_Links;           use System.Soft_Links;\n+with System.Storage_Elements;     use System.Storage_Elements;\n+\n+package body System.Storage_Pools.Subpools is\n+\n+   procedure Attach (N : not null SP_Node_Ptr; L : not null SP_Node_Ptr);\n+   --  Attach a subpool node to a pool\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (SP_Node, SP_Node_Ptr);\n+\n+   procedure Detach (N : not null SP_Node_Ptr);\n+   --  Unhook a subpool node from an arbitrary subpool list\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   overriding procedure Allocate\n+     (Pool                     : in out Root_Storage_Pool_With_Subpools;\n+      Storage_Address          : out System.Address;\n+      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n+      Alignment                : System.Storage_Elements.Storage_Count)\n+   is\n+   begin\n+      --  ??? The use of Allocate is very dangerous as it does not handle\n+      --  controlled objects properly. Perhaps we should provide an\n+      --  implementation which raises Program_Error instead.\n+\n+      --  Dispatch to the user-defined implementations of Allocate_From_Subpool\n+      --  and Default_Subpool_For_Pool.\n+\n+      Allocate_From_Subpool\n+        (Root_Storage_Pool_With_Subpools'Class (Pool),\n+         Storage_Address,\n+         Size_In_Storage_Elements,\n+         Alignment,\n+         Default_Subpool_For_Pool\n+           (Root_Storage_Pool_With_Subpools'Class (Pool)));\n+   end Allocate;\n+\n+   -----------------------------\n+   -- Allocate_Any_Controlled --\n+   -----------------------------\n+\n+   procedure Allocate_Any_Controlled\n+     (Pool            : in out Root_Storage_Pool'Class;\n+      Context_Subpool : Subpool_Handle := null;\n+      Context_Master  : Finalization_Masters.Finalization_Master_Ptr := null;\n+      Fin_Address     : Finalization_Masters.Finalize_Address_Ptr := null;\n+      Addr            : out System.Address;\n+      Storage_Size    : System.Storage_Elements.Storage_Count;\n+      Alignment       : System.Storage_Elements.Storage_Count;\n+      Is_Controlled   : Boolean := True)\n+   is\n+      --  ??? This membership test gives the wrong result when Pool has\n+      --  subpools.\n+\n+      Is_Subpool_Allocation : constant Boolean :=\n+                                Pool in Root_Storage_Pool_With_Subpools;\n+\n+      Master  : Finalization_Master_Ptr := null;\n+      N_Addr  : Address;\n+      N_Ptr   : FM_Node_Ptr;\n+      N_Size  : Storage_Count;\n+      Subpool : Subpool_Handle := null;\n+\n+   begin\n+      --  Step 1: Pool-related runtime checks\n+\n+      --  Allocation on a pool_with_subpools. In this scenario there is a\n+      --  master for each subpool.\n+\n+      if Is_Subpool_Allocation then\n+\n+         --  Case of an allocation without a Subpool_Handle. Dispatch to the\n+         --  implementation of Default_Subpool_For_Pool.\n+\n+         if Context_Subpool = null then\n+            Subpool :=\n+              Default_Subpool_For_Pool\n+                (Root_Storage_Pool_With_Subpools'Class (Pool));\n+\n+            --  Ensure proper ownership\n+\n+            if Subpool.Owner /=\n+                 Root_Storage_Pool_With_Subpools'Class (Pool)'Unchecked_Access\n+            then\n+               raise Program_Error with \"incorrect owner of default subpool\";\n+            end if;\n+\n+         --  Allocation with a Subpool_Handle\n+\n+         else\n+            Subpool := Context_Subpool;\n+\n+            --  Ensure proper ownership\n+\n+            if Subpool.Owner /=\n+                 Root_Storage_Pool_With_Subpools'Class (Pool)'Unchecked_Access\n+            then\n+               raise Program_Error with \"incorrect owner of subpool\";\n+            end if;\n+         end if;\n+\n+         Master := Subpool.Master'Unchecked_Access;\n+\n+      --  Allocation on a simple pool. In this scenario there is a master for\n+      --  each access-to-controlled type. No context subpool should be present.\n+\n+      else\n+\n+         --  If the master is missing, then the expansion of the access type\n+         --  failed to create one. This is a serious error.\n+\n+         if Context_Master = null then\n+            raise Program_Error with \"missing master in pool allocation\";\n+\n+         --  If a subpool is present, then this is the result of erroneous\n+         --  allocator expansion. This is not a serious error, but it should\n+         --  still be detected.\n+\n+         elsif Context_Subpool /= null then\n+            raise Program_Error with \"subpool not required in pool allocation\";\n+         end if;\n+\n+         Master := Context_Master;\n+      end if;\n+\n+      --  Step 2: Master-related runtime checks\n+\n+      --  Allocation of a descendant from [Limited_]Controlled, a class-wide\n+      --  object or a record with controlled components.\n+\n+      if Is_Controlled then\n+\n+         --  Do not allow the allocation of controlled objects while the\n+         --  associated master is being finalized.\n+\n+         if Master.Finalization_Started then\n+            raise Program_Error with \"allocation after finalization started\";\n+         end if;\n+\n+         --  The size must acount for the hidden header preceding the object\n+\n+         N_Size := Storage_Size + Header_Size;\n+\n+      --  Non-controlled allocation\n+\n+      else\n+         N_Size := Storage_Size;\n+      end if;\n+\n+      --  Step 3: Allocation of object\n+\n+      --  For descendants of Root_Storage_Pool_With_Subpools, dispatch to the\n+      --  implementation of Allocate_From_Subpool.\n+\n+      if Is_Subpool_Allocation then\n+         Allocate_From_Subpool\n+           (Root_Storage_Pool_With_Subpools'Class (Pool),\n+            N_Addr, N_Size, Alignment, Subpool);\n+\n+      --  For descendants of Root_Storage_Pool, dispatch to the implementation\n+      --  of Allocate.\n+\n+      else\n+         Allocate (Pool, N_Addr, N_Size, Alignment);\n+      end if;\n+\n+      --  Step 4: Attachment\n+\n+      if Is_Controlled then\n+\n+         --  Map the allocated memory into a FM_Node record. This converts the\n+         --  top of the allocated bits into a list header.\n+\n+         N_Ptr := Address_To_FM_Node_Ptr (N_Addr);\n+\n+         --  Check whether primitive Finalize_Address is available. If it is\n+         --  not, then either the expansion of the designated type failed or\n+         --  the expansion of the allocator failed. This is a serious error.\n+\n+         if Fin_Address = null then\n+            raise Program_Error\n+              with \"primitive Finalize_Address not available\";\n+         end if;\n+\n+         N_Ptr.Finalize_Address := Fin_Address;\n+\n+         --  Prepend the allocated object to the finalization master\n+\n+         Attach (N_Ptr, Master.Objects'Unchecked_Access);\n+\n+         --  Move the address from the hidden list header to the start of the\n+         --  object. This operation effectively hides the list header.\n+\n+         Addr := N_Addr + Header_Offset;\n+      else\n+         Addr := N_Addr;\n+      end if;\n+   end Allocate_Any_Controlled;\n+\n+   ------------\n+   -- Attach --\n+   ------------\n+\n+   procedure Attach (N : not null SP_Node_Ptr; L : not null SP_Node_Ptr) is\n+   begin\n+      Lock_Task.all;\n+\n+      L.Next.Prev := N;\n+      N.Next := L.Next;\n+      L.Next := N;\n+      N.Prev := L;\n+\n+      Unlock_Task.all;\n+\n+      --  Note: No need to unlock in case of an exception because the above\n+      --  code can never raise one.\n+   end Attach;\n+\n+   -------------------------------\n+   -- Deallocate_Any_Controlled --\n+   -------------------------------\n+\n+   procedure Deallocate_Any_Controlled\n+     (Pool          : in out Root_Storage_Pool'Class;\n+      Addr          : System.Address;\n+      Storage_Size  : System.Storage_Elements.Storage_Count;\n+      Alignment     : System.Storage_Elements.Storage_Count;\n+      Is_Controlled : Boolean := True)\n+   is\n+      N_Addr : Address;\n+      N_Ptr  : FM_Node_Ptr;\n+      N_Size : Storage_Count;\n+\n+   begin\n+      --  Step 1: Detachment\n+\n+      if Is_Controlled then\n+\n+         --  Move the address from the object to the beginning of the list\n+         --  header.\n+\n+         N_Addr := Addr - Header_Offset;\n+\n+         --  Convert the bits preceding the object into a list header\n+\n+         N_Ptr := Address_To_FM_Node_Ptr (N_Addr);\n+\n+         --  Detach the object from the related finalization master. This\n+         --  action does not need to know the prior context used during\n+         --  allocation.\n+\n+         Detach (N_Ptr);\n+\n+         --  The size of the deallocated object must include the size of the\n+         --  hidden list header.\n+\n+         N_Size := Storage_Size + Header_Size;\n+      else\n+         N_Addr := Addr;\n+         N_Size := Storage_Size;\n+      end if;\n+\n+      --  Step 2: Deallocation\n+\n+      --  Dispatch to the proper implementation of Deallocate. This action\n+      --  covers both Root_Storage_Pool and Root_Storage_Pool_With_Subpools\n+      --  implementations.\n+\n+      Deallocate (Pool, N_Addr, N_Size, Alignment);\n+   end Deallocate_Any_Controlled;\n+\n+   ------------\n+   -- Detach --\n+   ------------\n+\n+   procedure Detach (N : not null SP_Node_Ptr) is\n+   begin\n+      --  N must be attached to some list\n+\n+      pragma Assert (N.Next /= null and then N.Prev /= null);\n+\n+      Lock_Task.all;\n+\n+      N.Prev.Next := N.Next;\n+      N.Next.Prev := N.Prev;\n+\n+      Unlock_Task.all;\n+\n+      --  Note: No need to unlock in case of an exception because the above\n+      --  code can never raise one.\n+   end Detach;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   overriding procedure Finalize\n+     (Pool : in out Root_Storage_Pool_With_Subpools)\n+   is\n+      Curr_Ptr : SP_Node_Ptr;\n+      Ex_Occur : Exception_Occurrence;\n+      Next_Ptr : SP_Node_Ptr;\n+      Raised   : Boolean := False;\n+\n+   begin\n+      --  Uninitialized pools do not have subpools and do not contain objects\n+      --  of any kind.\n+\n+      if not Pool.Initialized then\n+         return;\n+      end if;\n+\n+      --  It is possible for multiple tasks to cause the finalization of a\n+      --  common pool. Allow only one task to finalize the contents.\n+\n+      if Pool.Finalization_Started then\n+         return;\n+      end if;\n+\n+      --  Lock the pool to prevent the creation of additional subpools while\n+      --  the available ones are finalized. The pool remains locked because\n+      --  either it is about to be deallocated or the associated access type\n+      --  is about to go out of scope.\n+\n+      Pool.Finalization_Started := True;\n+\n+      --  Skip the dummy head\n+\n+      Curr_Ptr := Pool.Subpools.Next;\n+      while Curr_Ptr /= Pool.Subpools'Unchecked_Access loop\n+         Next_Ptr := Curr_Ptr.Next;\n+\n+         --  Remove the subpool node from the subpool list\n+\n+         Detach (Curr_Ptr);\n+\n+         --  Finalize the current subpool\n+\n+         begin\n+            Finalize_Subpool (Curr_Ptr.Subpool);\n+\n+         exception\n+            when Fin_Occur : others =>\n+               if not Raised then\n+                  Raised := True;\n+                  Save_Occurrence (Ex_Occur, Fin_Occur);\n+               end if;\n+         end;\n+\n+         --  Since subpool nodes are not allocated on the owner pool, they must\n+         --  be explicitly destroyed.\n+\n+         Free (Curr_Ptr);\n+\n+         Curr_Ptr := Next_Ptr;\n+      end loop;\n+\n+      --  If the finalization of a particular master failed, reraise the\n+      --  exception now.\n+\n+      if Raised then\n+         Reraise_Occurrence (Ex_Occur);\n+      end if;\n+   end Finalize;\n+\n+   ----------------------\n+   -- Finalize_Subpool --\n+   ----------------------\n+\n+   procedure Finalize_Subpool (Subpool : not null Subpool_Handle) is\n+   begin\n+      Finalize (Subpool.Master);\n+   end Finalize_Subpool;\n+\n+   ---------------------\n+   -- Pool_Of_Subpool --\n+   ---------------------\n+\n+   function Pool_Of_Subpool (Subpool : not null Subpool_Handle)\n+     return access Root_Storage_Pool_With_Subpools'Class is\n+   begin\n+      return Subpool.Owner;\n+   end Pool_Of_Subpool;\n+\n+   -------------------------\n+   -- Set_Pool_Of_Subpool --\n+   -------------------------\n+\n+   procedure Set_Pool_Of_Subpool\n+     (Subpool : not null Subpool_Handle;\n+      Pool    : in out Root_Storage_Pool_With_Subpools'Class)\n+   is\n+      N_Ptr : SP_Node_Ptr;\n+\n+   begin\n+      if not Pool.Initialized then\n+\n+         --  The dummy head must point to itself in both directions\n+\n+         Pool.Subpools.Next := Pool.Subpools'Unchecked_Access;\n+         Pool.Subpools.Prev := Pool.Subpools'Unchecked_Access;\n+         Pool.Initialized   := True;\n+      end if;\n+\n+      --  If the subpool is already owned, raise Program_Error. This is a\n+      --  direct violation of the RM rules.\n+\n+      if Subpool.Owner /= null then\n+         raise Program_Error with \"subpool already belongs to a pool\";\n+      end if;\n+\n+      --  Prevent the creation of a new subpool while the owner is being\n+      --  finalized. This is a serious error.\n+\n+      if Pool.Finalization_Started then\n+         raise Program_Error\n+           with \"subpool creation after finalization started\";\n+      end if;\n+\n+      --  Create a subpool node, decorate it and associate it with the subpool\n+      --  list of Pool.\n+\n+      N_Ptr := new SP_Node;\n+\n+      Subpool.Owner := Pool'Unchecked_Access;\n+      N_Ptr.Subpool := Subpool;\n+\n+      Attach (N_Ptr, Pool.Subpools'Unchecked_Access);\n+   end Set_Pool_Of_Subpool;\n+\n+end System.Storage_Pools.Subpools;"}, {"sha": "d8e58fb0797d0239f67af2df25a53766bf84369a", "filename": "gcc/ada/s-stposu.ads", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stposu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fs-stposu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.ads?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -0,0 +1,255 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--        S Y S T E M . S T O R A G E _ P O O L S . S U B P O O L S         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Finalization_Masters;\n+with System.Storage_Elements;\n+\n+package System.Storage_Pools.Subpools is\n+   pragma Preelaborate (System.Storage_Pools.Subpools);\n+\n+   type Root_Storage_Pool_With_Subpools is abstract\n+     new Root_Storage_Pool with private;\n+   --  The base for all implementations of Storage_Pool_With_Subpools. This\n+   --  type is Limited_Controlled by derivation. To use subpools, an access\n+   --  type must be associated with an implementation descending from type\n+   --  Root_Storage_Pool_With_Subpools.\n+\n+   type Root_Subpool is abstract tagged limited private;\n+   --  The base for all implementations of Subpool. Objects of this type are\n+   --  managed by the pool_with_subpools.\n+\n+   type Subpool_Handle is access all Root_Subpool'Class;\n+   for Subpool_Handle'Storage_Size use 0;\n+   --  Since subpools are limited types by definition, a handle is instead used\n+   --  to manage subpool abstractions.\n+\n+   overriding procedure Allocate\n+     (Pool                     : in out Root_Storage_Pool_With_Subpools;\n+      Storage_Address          : out System.Address;\n+      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n+      Alignment                : System.Storage_Elements.Storage_Count);\n+   --  Allocate an object described by Size_In_Storage_Elements and Alignment\n+   --  on the default subpool of Pool.\n+\n+   procedure Allocate_From_Subpool\n+     (Pool                     : in out Root_Storage_Pool_With_Subpools;\n+      Storage_Address          : out System.Address;\n+      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n+      Alignment                : System.Storage_Elements.Storage_Count;\n+      Subpool                  : not null Subpool_Handle)\n+   is abstract;\n+\n+   --  ??? This precondition causes errors in simple tests, disabled for now\n+\n+--     with Pre'Class => Pool_Of_Subpool (Subpool) = Pool'Access;\n+   --  This routine requires implementation. Allocate an object described by\n+   --  Size_In_Storage_Elements and Alignment on a subpool.\n+\n+   function Create_Subpool\n+     (Pool         : in out Root_Storage_Pool_With_Subpools;\n+      Storage_Size : Storage_Elements.Storage_Count :=\n+                     Storage_Elements.Storage_Count'Last)\n+   return not null Subpool_Handle\n+   is abstract;\n+   --  This routine requires implementation. Create a subpool within the given\n+   --  pool_with_subpools.\n+\n+   overriding procedure Deallocate\n+     (Pool                     : in out Root_Storage_Pool_With_Subpools;\n+      Storage_Address          : System.Address;\n+      Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n+      Alignment                : System.Storage_Elements.Storage_Count)\n+   is null;\n+\n+   procedure Deallocate_Subpool\n+     (Pool    : in out Root_Storage_Pool_With_Subpools;\n+      Subpool : in out Subpool_Handle)\n+   is abstract;\n+\n+   --  ??? This precondition causes errors in simple tests, disabled for now\n+\n+--     with Pre'Class => Pool_Of_Subpool (Subpool) = Pool'Access;\n+   --  This routine requires implementation. Reclaim the storage a particular\n+   --  subpool occupies in a pool_with_subpools. This routine is called by\n+   --  Ada.Unchecked_Deallocate_Subpool.\n+\n+   function Default_Subpool_For_Pool\n+     (Pool : Root_Storage_Pool_With_Subpools)\n+   return not null Subpool_Handle\n+   is abstract;\n+   --  This routine requires implementation. Returns a common subpool used for\n+   --  allocations without Subpool_Handle_name in the allocator.\n+\n+   function Pool_Of_Subpool\n+     (Subpool : not null Subpool_Handle)\n+   return access Root_Storage_Pool_With_Subpools'Class;\n+   --  Return the owner of the subpool\n+\n+   procedure Set_Pool_Of_Subpool\n+     (Subpool : not null Subpool_Handle;\n+      Pool    : in out Root_Storage_Pool_With_Subpools'Class);\n+   --  Set the owner of the subpool. This is intended to be called from\n+   --  Create_Subpool or similar subpool constructors. Raises Program_Error\n+   --  if the subpool already belongs to a pool.\n+\n+private\n+   --  Model\n+   --                           Pool_With_Subpools\n+   --                 +----> +---------------------+ <----+\n+   --                 |  +---------- Subpools      |      |\n+   --                 |  |   +---------------------+      |\n+   --                 |  |   :      User data      :      |\n+   --                 |  |   '.....................'      |\n+   --                 |  |                                |\n+   --                 |  |    SP_Node       SP_Node       |\n+   --                 |  +-> +-------+     +-------+      |\n+   --                 |      | Prev  <-----> Prev  |      |\n+   --                 |      +-------+     +-------+      |\n+   --                 |      | Next  <---->| Next  |      |\n+   --                 |      +-------+     +-------+      |\n+   --                 |  +----Subpool|     |Subpool----+  |\n+   --                 |  |   +-------+     +-------+   |  |\n+   --                 |  |                             |  |\n+   --                 |  |    Subpool       Subpool    |  |\n+   --                 |  +-> +-------+     +-------+ <-+  |\n+   --                 +------- Owner |     | Owner -------+\n+   --                        +-------+     +-------+\n+   --     +------------------- Master|     | Master---------------+\n+   --     |                  +-------+     +-------+              |\n+   --     |                  : User  :     : User  :              |\n+   --     |                  : Data  :     : Data  :              |\n+   --     |                  '.......'     '.......'              |\n+   --     |                                                       |\n+   --     |                           Heap                        |\n+   --  .. | ..................................................... | ..\n+   --  :  |                                                       |  :\n+   --  :  |    Object    Object    Object               Object    |  :\n+   --  :  +-> +------+  +------+  +------+             +------+ <-+  :\n+   --  :      | Prev <--> Prev <--> Prev |             | Prev |      :\n+   --  :      +------+  +------+  +------+             +------+      :\n+   --  :      | Next <--> Next <--> Next |             | Next |      :\n+   --  :      +------+  +------+  +------+             +------+      :\n+   --  :      |  FA  |  |  FA  |  |  FA  |             |  FA  |      :\n+   --  :      +------+  +------+  +------+             +------+      :\n+   --  :      :      :  :      :  :      :             :      :      :\n+   --  :      :      :  :      :  :      :             :      :      :\n+   --  :      '......'  '......'  '......'             '......'      :\n+   --  :                                                             :\n+   --  '.............................................................'\n+\n+   --  Subpool list types. Each pool_with_subpools contains a list of subpools.\n+\n+   type SP_Node;\n+   type SP_Node_Ptr is access all SP_Node;\n+\n+   type SP_Node is record\n+      Prev    : SP_Node_Ptr := null;\n+      Next    : SP_Node_Ptr := null;\n+      Subpool : Subpool_Handle := null;\n+   end record;\n+\n+   --  Root_Storage_Pool_With_Subpools internal structure\n+\n+   type Root_Storage_Pool_With_Subpools is abstract\n+     new Root_Storage_Pool with\n+   record\n+      Initialized : Boolean := False;\n+      pragma Atomic (Initialized);\n+      --  Even though this type is derived from Limited_Controlled, overriding\n+      --  Initialize would have no effect since the type is abstract. Routine\n+      --  Set_Pool_Of_Subpool is tasked with the initialization of a pool with\n+      --  subpools because it has to be called at some point. This flag is used\n+      --  to prevent the resetting of the subpool chain.\n+\n+      Subpools : aliased SP_Node;\n+      --  A doubly linked list of subpools\n+\n+      Finalization_Started : Boolean := False;\n+      pragma Atomic (Finalization_Started);\n+      --  A flag which prevents the creation of new subpools while the master\n+      --  pool is being finalized. The flag needs to be atomic because it is\n+      --  accessed without Lock_Task / Unlock_Task.\n+   end record;\n+\n+   type Any_Storage_Pool_With_Subpools_Ptr\n+     is access all Root_Storage_Pool_With_Subpools'Class;\n+   for Any_Storage_Pool_With_Subpools_Ptr'Storage_Size use 0;\n+\n+   --  A subpool is an abstraction layer which sits on top of a pool. It\n+   --  contains links to all controlled objects allocated on a particular\n+   --  subpool.\n+\n+   type Root_Subpool is abstract tagged limited record\n+      Owner : Any_Storage_Pool_With_Subpools_Ptr := null;\n+      --  A reference to the master pool_with_subpools\n+\n+      Master : aliased System.Finalization_Masters.Finalization_Master;\n+      --  A collection of controlled objects\n+   end record;\n+\n+   --  ??? Once Storage_Pools.Allocate_Any is removed, this should be renamed\n+   --  to Allocate_Any.\n+\n+   procedure Allocate_Any_Controlled\n+     (Pool            : in out Root_Storage_Pool'Class;\n+      Context_Subpool : Subpool_Handle := null;\n+      Context_Master  : Finalization_Masters.Finalization_Master_Ptr := null;\n+      Fin_Address     : Finalization_Masters.Finalize_Address_Ptr := null;\n+      Addr            : out System.Address;\n+      Storage_Size    : System.Storage_Elements.Storage_Count;\n+      Alignment       : System.Storage_Elements.Storage_Count;\n+      Is_Controlled   : Boolean := True);\n+   --  Compiler interface. This version of Allocate handles all possible cases,\n+   --  either on a pool or a pool_with_subpools.\n+\n+   procedure Deallocate_Any_Controlled\n+     (Pool          : in out Root_Storage_Pool'Class;\n+      Addr          : System.Address;\n+      Storage_Size  : System.Storage_Elements.Storage_Count;\n+      Alignment     : System.Storage_Elements.Storage_Count;\n+      Is_Controlled : Boolean := True);\n+   --  Compiler interface. This version of Deallocate handles all possible\n+   --  cases, either from a pool or a pool_with_subpools.\n+\n+   overriding procedure Finalize\n+     (Pool : in out Root_Storage_Pool_With_Subpools);\n+   --  Iterate over all subpools of Pool, detach them one by one and finalize\n+   --  their masters. This action first detaches a controlled object from a\n+   --  particular master, then invokes its Finalize_Address primitive.\n+\n+   procedure Finalize_Subpool (Subpool : not null Subpool_Handle);\n+   --  Finalize the master of a subpool\n+\n+end System.Storage_Pools.Subpools;"}, {"sha": "13e0fdbb0c083f2210d0d9edc37046c4f1439754", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -1353,18 +1353,18 @@ package body Sem_Ch3 is\n       Set_Has_Task (T, False);\n       Set_Has_Controlled_Component (T, False);\n \n-      --  Initialize Associated_Collection explicitly to Empty, to avoid\n+      --  Initialize field Finalization_Master explicitly to Empty, to avoid\n       --  problems where an incomplete view of this entity has been previously\n       --  established by a limited with and an overlaid version of this field\n       --  (Stored_Constraint) was initialized for the incomplete view.\n \n       --  This reset is performed in most cases except where the access type\n       --  has been created for the purposes of allocating or deallocating a\n       --  build-in-place object. Such access types have explicitly set pools\n-      --  and collections.\n+      --  and finalization masters.\n \n       if No (Associated_Storage_Pool (T)) then\n-         Set_Associated_Collection (T, Empty);\n+         Set_Finalization_Master (T, Empty);\n       end if;\n \n       --  Ada 2005 (AI-231): Propagate the null-excluding and access-constant"}, {"sha": "cfb5b557a1738a246ff8f2eb82160f9d93e5ce1e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -6080,14 +6080,13 @@ package body Sem_Ch6 is\n             end if;\n \n             --  In the case of functions whose result type needs finalization,\n-            --  add an extra formal of type Ada.Finalization.Heap_Management.\n-            --  Finalization_Collection_Ptr.\n+            --  add an extra formal which represents the finalization master.\n \n-            if Needs_BIP_Collection (E) then\n+            if Needs_BIP_Finalization_Master (E) then\n                Discard :=\n                  Add_Extra_Formal\n-                   (E, RTE (RE_Finalization_Collection_Ptr),\n-                    E, BIP_Formal_Suffix (BIP_Collection));\n+                   (E, RTE (RE_Finalization_Master_Ptr),\n+                    E, BIP_Formal_Suffix (BIP_Finalization_Master));\n             end if;\n \n             --  If the result type contains tasks, we have two extra formals:"}, {"sha": "a9a7757fc639bcc31fd211e7544efd5e7197950a", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f70b35df36f20ad887de0adc150d0b3dd186cc/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=d3f70b35df36f20ad887de0adc150d0b3dd186cc", "patch": "@@ -717,6 +717,7 @@ package body Tbuild is\n      (Def_Id : Entity_Id;\n       Loc    : Source_Ptr) return Node_Id\n    is\n+      pragma Assert (Nkind (Def_Id) in N_Entity);\n       Occurrence : Node_Id;\n    begin\n       Occurrence := New_Node (N_Identifier, Loc);"}]}