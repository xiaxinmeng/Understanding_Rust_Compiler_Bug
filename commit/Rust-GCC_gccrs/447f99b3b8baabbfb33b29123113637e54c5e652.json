{"sha": "447f99b3b8baabbfb33b29123113637e54c5e652", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3Zjk5YjNiOGJhYWJiZmIzM2IyOTEyMzExMzYzN2U1NGM1ZTY1Mg==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2020-12-01T17:54:48Z"}, "committer": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2020-12-08T20:07:02Z"}, "message": "Avoid atomic for guard acquire when that is expensive\n\nWhen the atomic access involves a call to __sync_synchronize\nit is better to call __cxa_guard_acquire unconditionally,\nsince it handles the atomics too, or is a non-threaded\nimplementation when there is no gthread support for this target.\n\nThis fixes also a bug for the ARM EABI big-endian target,\nthat is, previously the wrong bit was checked.\n\n2020-12-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n\t* decl2.c: (is_atomic_expensive_p): New helper function.\n\t(build_atomic_load_byte): Rename to...\n\t(build_atomic_load_type): ... and add new parameter type.\n\t(get_guard_cond): Skip the atomic here if that is expensive.\n\tUse the correct type for the atomic load on certain targets.", "tree": {"sha": "59eb5f7abb8bd21cd8d2eed6f71c55cc657070ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59eb5f7abb8bd21cd8d2eed6f71c55cc657070ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/447f99b3b8baabbfb33b29123113637e54c5e652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447f99b3b8baabbfb33b29123113637e54c5e652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447f99b3b8baabbfb33b29123113637e54c5e652", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447f99b3b8baabbfb33b29123113637e54c5e652/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7251a2c103bc48775cb9726a4bebeaebde96684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7251a2c103bc48775cb9726a4bebeaebde96684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7251a2c103bc48775cb9726a4bebeaebde96684"}], "stats": {"total": 33, "additions": 29, "deletions": 4}, "files": [{"sha": "eec0c9255c29ece074b16c68c68807082fd6a1ff", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447f99b3b8baabbfb33b29123113637e54c5e652/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447f99b3b8baabbfb33b29123113637e54c5e652/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=447f99b3b8baabbfb33b29123113637e54c5e652", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"c-family/c-ada-spec.h\"\n #include \"asan.h\"\n+#include \"optabs-query.h\"\n \n /* Id for dumping the raw trees.  */\n int raw_dump_id;\n@@ -3297,18 +3298,34 @@ get_guard (tree decl)\n   return guard;\n }\n \n+/* Returns true if accessing the GUARD atomic is expensive,\n+   i.e. involves a call to __sync_synchronize or similar.\n+   In this case let __cxa_guard_acquire handle the atomics.  */\n+\n+static bool\n+is_atomic_expensive_p (machine_mode mode)\n+{\n+  if (!flag_inline_atomics)\n+    return true;\n+\n+  if (!can_compare_and_swap_p (mode, false) || !can_atomic_load_p (mode))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return an atomic load of src with the appropriate memory model.  */\n \n static tree\n-build_atomic_load_byte (tree src, HOST_WIDE_INT model)\n+build_atomic_load_type (tree src, HOST_WIDE_INT model, tree type)\n {\n-  tree ptr_type = build_pointer_type (char_type_node);\n+  tree ptr_type = build_pointer_type (type);\n   tree mem_model = build_int_cst (integer_type_node, model);\n   tree t, addr, val;\n   unsigned int size;\n   int fncode;\n \n-  size = tree_to_uhwi (TYPE_SIZE_UNIT (char_type_node));\n+  size = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n \n   fncode = BUILT_IN_ATOMIC_LOAD_N + exact_log2 (size) + 1;\n   t = builtin_decl_implicit ((enum built_in_function) fncode);\n@@ -3351,7 +3368,15 @@ get_guard_cond (tree guard, bool thread_safe)\n   if (!thread_safe)\n     guard = get_guard_bits (guard);\n   else\n-    guard = build_atomic_load_byte (guard, MEMMODEL_ACQUIRE);\n+    {\n+      tree type = targetm.cxx.guard_mask_bit ()\n+\t\t  ? TREE_TYPE (guard) : char_type_node;\n+\n+      if (is_atomic_expensive_p (TYPE_MODE (type)))\n+\tguard = integer_zero_node;\n+      else\n+\tguard = build_atomic_load_type (guard, MEMMODEL_ACQUIRE, type);\n+    }\n \n   /* Mask off all but the low bit.  */\n   if (targetm.cxx.guard_mask_bit ())"}]}