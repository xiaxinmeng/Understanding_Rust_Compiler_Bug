{"sha": "0802d51684ee39dac56ec84821cbcef6de89ac0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgwMmQ1MTY4NGVlMzlkYWM1NmVjODQ4MjFjYmNlZjZkZTg5YWMwZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-27T14:04:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-27T14:04:16Z"}, "message": "(simplify_rtx): Don't do anything with if_then_else_cond result if both one arm and the input are a comparison.\n\n(simplify_rtx): Don't do anything with if_then_else_cond\nresult if both one arm and the input are a comparison.\n(simplify_{rtx,if_then_else,logical,shift_const}): Don't\ntest STORE_FLAG_VALUE with #if; properly test for just sign bit.\n(num_sign_bit_copies, if_then_else_cond): Likewise.\n\nFrom-SVN: r13551", "tree": {"sha": "6d90d03a8095a755a99b15af99815fac0fe836e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d90d03a8095a755a99b15af99815fac0fe836e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0802d51684ee39dac56ec84821cbcef6de89ac0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0802d51684ee39dac56ec84821cbcef6de89ac0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0802d51684ee39dac56ec84821cbcef6de89ac0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0802d51684ee39dac56ec84821cbcef6de89ac0d/comments", "author": null, "committer": null, "parents": [{"sha": "91674c376c5dea02e83f28c44a76f4f555f53e37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91674c376c5dea02e83f28c44a76f4f555f53e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91674c376c5dea02e83f28c44a76f4f555f53e37"}], "stats": {"total": 108, "additions": 56, "deletions": 52}, "files": [{"sha": "be5843b56290196c747851688726222b2af4219a", "filename": "gcc/combine.c", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0802d51684ee39dac56ec84821cbcef6de89ac0d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0802d51684ee39dac56ec84821cbcef6de89ac0d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0802d51684ee39dac56ec84821cbcef6de89ac0d", "patch": "@@ -3138,7 +3138,12 @@ simplify_rtx (x, op0_mode, last, in_dest)\n       rtx cond, true, false;\n \n       cond = if_then_else_cond (x, &true, &false);\n-      if (cond != 0)\n+      if (cond != 0\n+\t  /* If everything is a comparison, what we have is highly unlikely\n+\t     to be simpler, so don't use it.  */\n+\t  && ! (GET_RTX_CLASS (code) == '<'\n+\t\t&& (GET_RTX_CLASS (GET_CODE (true)) == '<'\n+\t\t    || GET_RTX_CLASS (GET_CODE (false)) == '<')))\n \t{\n \t  rtx cop1 = const0_rtx;\n \t  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);\n@@ -3437,25 +3442,25 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t  return gen_lowpart_for_combine (mode, x);\n \t}\n \t\t\t\t\t    \n-#if STORE_FLAG_VALUE == -1\n-      /* (not (comparison foo bar)) can be done by reversing the comparison\n-\t code if valid.  */\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+      /* If STORE_FLAG_VALUE is -1, (not (comparison foo bar)) can be done by\n+\t reversing the comparison code if valid.  */\n+      if (STORE_FLAG_VALUE == -1\n+\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n \t  && reversible_comparison_p (XEXP (x, 0)))\n \treturn gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n \t\t\t\tmode, XEXP (XEXP (x, 0), 0),\n \t\t\t\tXEXP (XEXP (x, 0), 1));\n \n       /* (ashiftrt foo C) where C is the number of bits in FOO minus 1\n-\t is (lt foo (const_int 0)), so we can perform the above\n-\t simplification.  */\n+\t is (lt foo (const_int 0)) if STORE_FLAG_VALUE is -1, so we can\n+\t perform the above simplification.  */\n \n-      if (XEXP (x, 1) == const1_rtx\n+      if (STORE_FLAG_VALUE == -1\n+\t  && XEXP (x, 1) == const1_rtx\n \t  && GET_CODE (XEXP (x, 0)) == ASHIFTRT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn gen_rtx_combine (GE, mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n-#endif\n \n       /* Apply De Morgan's laws to reduce number of patterns for machines\n  \t with negating logical insns (and-not, nand, etc.).  If result has\n@@ -3762,16 +3767,15 @@ simplify_rtx (x, op0_mode, last, in_dest)\n       break;\n \n     case MINUS:\n-#if STORE_FLAG_VALUE == 1\n-      /* (minus 1 (comparison foo bar)) can be done by reversing the comparison\n-\t code if valid.  */\n-      if (XEXP (x, 0) == const1_rtx\n+      /* If STORE_FLAG_VALUE is 1, (minus 1 (comparison foo bar)) can be done\n+\t by reversing the comparison code if valid.  */\n+      if (STORE_FLAG_VALUE == 1\n+\t  && XEXP (x, 0) == const1_rtx\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<'\n \t  && reversible_comparison_p (XEXP (x, 1)))\n \treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 1))),\n \t\t\t   mode, XEXP (XEXP (x, 1), 0),\n \t\t\t\tXEXP (XEXP (x, 1), 1));\n-#endif\n \n       /* (minus <foo> (and <foo> (const_int -pow2))) becomes\n \t (and <foo> (const_int pow2-1))  */\n@@ -3845,7 +3849,6 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t  /* Simplify our comparison, if possible.  */\n \t  new_code = simplify_comparison (code, &op0, &op1);\n \n-#if STORE_FLAG_VALUE == 1\n \t  /* If STORE_FLAG_VALUE is 1, we can convert (ne x 0) to simply X\n \t     if only the low-order bit is possibly nonzero in X (such as when\n \t     X is a ZERO_EXTRACT of one bit).  Similarly, we can convert EQ to\n@@ -3858,13 +3861,14 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t     ZERO_EXTRACT is indeed appropriate, it will be placed back by\n \t     the call to make_compound_operation in the SET case.  */\n \n-\t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n-\t      && op1 == const0_rtx\n-\t      && nonzero_bits (op0, mode) == 1)\n+\t  if (STORE_FLAG_VALUE == 1\n+\t      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t      && op1 == const0_rtx && nonzero_bits (op0, mode) == 1)\n \t    return gen_lowpart_for_combine (mode,\n \t\t\t\t\t    expand_compound_operation (op0));\n \n-\t  else if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t  else if (STORE_FLAG_VALUE == 1\n+\t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && (num_sign_bit_copies (op0, mode)\n \t\t       == GET_MODE_BITSIZE (mode)))\n@@ -3874,7 +3878,8 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t\tgen_lowpart_for_combine (mode, op0));\n \t    }\n \n-\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t  else if (STORE_FLAG_VALUE == 1\n+\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n@@ -3884,27 +3889,28 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t\t const1_rtx);\n \t    }\n \n-\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t  else if (STORE_FLAG_VALUE == 1\n+\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && (num_sign_bit_copies (op0, mode)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      return plus_constant (gen_lowpart_for_combine (mode, op0), 1);\n \t    }\n-#endif\n \n-#if STORE_FLAG_VALUE == -1\n \t  /* If STORE_FLAG_VALUE is -1, we have cases similar to\n \t     those above.  */\n-\t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t  if (STORE_FLAG_VALUE == -1\n+\t      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n \t      && (num_sign_bit_copies (op0, mode)\n \t\t  == GET_MODE_BITSIZE (mode)))\n \t    return gen_lowpart_for_combine (mode,\n \t\t\t\t\t    expand_compound_operation (op0));\n \n-\t  else if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t  else if (STORE_FLAG_VALUE == -1\n+\t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n@@ -3913,7 +3919,8 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t\tgen_lowpart_for_combine (mode, op0));\n \t    }\n \n-\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t  else if (STORE_FLAG_VALUE == -1\n+\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && (num_sign_bit_copies (op0, mode)\n \t\t       == GET_MODE_BITSIZE (mode)))\n@@ -3924,14 +3931,14 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t    }\n \n \t  /* If X is 0/1, (eq X 0) is X-1.  */\n-\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t  else if (STORE_FLAG_VALUE == -1\n+\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      return plus_constant (gen_lowpart_for_combine (mode, op0), -1);\n \t    }\n-#endif\n \n \t  /* If STORE_FLAG_VALUE says to just test the sign bit and X has just\n \t     one bit that might be nonzero, we can convert (ne x 0) to\n@@ -3940,7 +3947,7 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t     going to test the sign bit.  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t      && (STORE_FLAG_VALUE\n+\t      && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n \t\t  == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n@@ -4215,16 +4222,15 @@ simplify_if_then_else (x)\n \treturn gen_binary (UMIN, mode, true, false);\n       }\n   \n-#if STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1\n-\n   /* If we have (if_then_else COND (OP Z C1) Z) and OP is an identity when its\n      second operand is zero, this can be done as (OP Z (mult COND C2)) where\n      C2 = C1 * STORE_FLAG_VALUE. Similarly if OP has an outer ZERO_EXTEND or\n      SIGN_EXTEND as long as Z is already extended (so we don't destroy it).\n      We can do this kind of thing in some cases when STORE_FLAG_VALUE is\n-     neither of the above, but it isn't worth checking for.  */\n+     neither 1 or -1, but it isn't worth checking for.  */\n \n-  if (comparison_p && mode != VOIDmode && ! side_effects_p (x))\n+  if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n+      && comparison_p && mode != VOIDmode && ! side_effects_p (x))\n     {\n       rtx t = make_compound_operation (true, SET);\n       rtx f = make_compound_operation (false, SET);\n@@ -4333,7 +4339,6 @@ simplify_if_then_else (x)\n \t  return temp;\n \t}\n     }\n-#endif\n \n   /* If we have (if_then_else (ne A 0) C1 0) and either A is known to be 0 or\n      1 and C1 is a single bit or A is known to be 0 or -1 and C1 is the\n@@ -4874,30 +4879,30 @@ simplify_logical (x, last)\n \t\t\t   gen_unary (NOT, mode, mode, XEXP (op0, 1)),\n \t\t\t   op1);\n \n-#if STORE_FLAG_VALUE == 1\n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n-\t comparison.  */\n-      if (op1 == const1_rtx\n+\t comparison if STORE_FLAG_VALUE is 1.  */\n+      if (STORE_FLAG_VALUE == 1\n+\t  && op1 == const1_rtx\n \t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n \t  && reversible_comparison_p (op0))\n \treturn gen_rtx_combine (reverse_condition (GET_CODE (op0)),\n \t\t\t\tmode, XEXP (op0, 0), XEXP (op0, 1));\n \n       /* (lshiftrt foo C) where C is the number of bits in FOO minus 1\n \t is (lt foo (const_int 0)), so we can perform the above\n-\t simplification.  */\n+\t simplification if STORE_FLAG_VALUE is 1.  */\n \n-      if (op1 == const1_rtx\n+      if (STORE_FLAG_VALUE == 1\n+\t  && op1 == const1_rtx\n \t  && GET_CODE (op0) == LSHIFTRT\n \t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t  && INTVAL (XEXP (op0, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \treturn gen_rtx_combine (GE, mode, XEXP (op0, 0), const0_rtx);\n-#endif\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n \t when STORE_FLAG_VALUE is the sign bit.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (STORE_FLAG_VALUE\n+\t  && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n \t      == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t  && op1 == const_true_rtx\n \t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n@@ -6483,12 +6488,12 @@ if_then_else_cond (x, ptrue, pfalse)\n \t  return cond0 ? cond0 : cond1;\n \t}\n \n-#if STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1\n-\n       /* See if we have PLUS, IOR, XOR, MINUS or UMAX, where one of the\n-\t operands is zero when the other is non-zero, and vice-versa.  */\n+\t operands is zero when the other is non-zero, and vice-versa,\n+\t and STORE_FLAG_VALUE is 1 or -1.  */\n \n-      if ((code == PLUS || code == IOR || code == XOR || code == MINUS\n+      if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n+\t  && (code == PLUS || code == IOR || code == XOR || code == MINUS\n \t   || code == UMAX)\n \t  && GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == MULT)\n \t{\n@@ -6521,7 +6526,8 @@ if_then_else_cond (x, ptrue, pfalse)\n \n       /* Similarly for MULT, AND and UMIN, execpt that for these the result\n \t is always zero.  */\n-      if ((code == MULT || code == AND || code == UMIN)\n+      if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n+\t  && (code == MULT || code == AND || code == UMIN)\n \t  && GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == MULT)\n \t{\n \t  cond0 = XEXP (XEXP (x, 0), 0);\n@@ -6543,7 +6549,6 @@ if_then_else_cond (x, ptrue, pfalse)\n \t      return cond0;\n \t    }\n \t}\n-#endif\n     }\n \n   else if (code == IF_THEN_ELSE)\n@@ -7773,11 +7778,10 @@ num_sign_bit_copies (x, mode)\n       num1 = num_sign_bit_copies (XEXP (x, 2), mode);\n       return MIN (num0, num1);\n \n-#if STORE_FLAG_VALUE == -1\n     case EQ:  case NE:  case GE:  case GT:  case LE:  case LT:\n     case GEU: case GTU: case LEU: case LTU:\n-      return bitwidth;\n-#endif\n+      if (STORE_FLAG_VALUE == -1)\n+\treturn bitwidth;\n     }\n \n   /* If we haven't been able to figure it out by one of the above rules,\n@@ -8545,9 +8549,9 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t     STORE_FLAG_VALUE of 1 or logical with STORE_FLAG_VALUE == -1,\n \t     we have a (neg (gt X 0)) operation.  */\n \n-\t  if (GET_CODE (XEXP (varop, 0)) == ASHIFTRT\n+\t  if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n+\t      && GET_CODE (XEXP (varop, 0)) == ASHIFTRT\n \t      && count == GET_MODE_BITSIZE (GET_MODE (varop)) - 1\n-\t      && (STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \t      && (code == LSHIFTRT || code == ASHIFTRT)\n \t      && GET_CODE (XEXP (XEXP (varop, 0), 1)) == CONST_INT\n \t      && INTVAL (XEXP (XEXP (varop, 0), 1)) == count"}]}