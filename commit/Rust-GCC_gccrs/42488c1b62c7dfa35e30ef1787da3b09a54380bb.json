{"sha": "42488c1b62c7dfa35e30ef1787da3b09a54380bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI0ODhjMWI2MmM3ZGZhMzVlMzBlZjE3ODdkYTNiMDlhNTQzODBiYg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-06-29T18:57:43Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-06-29T18:57:43Z"}, "message": "re PR fortran/44582 (gfortran generates wrong results due to wrong ABI in function with array return)\n\n2010-06-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/44582\n\t* trans-expr.c (arrayfunc_assign_needs_temporary): New function\n\tto determine if a function assignment can be made without a\n\ttemporary.\n\t(gfc_trans_arrayfunc_assign): Move all the conditions that\n\tsuppress the direct function call to the above new functon and\n\tcall it.\n\n2010-06-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/44582\n\t* gfortran.dg/aliasing_array_result_1.f90 : New test.\n\nFrom-SVN: r161550", "tree": {"sha": "0873d19ee868ffa15535fe1be34270d82e9452dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0873d19ee868ffa15535fe1be34270d82e9452dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42488c1b62c7dfa35e30ef1787da3b09a54380bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42488c1b62c7dfa35e30ef1787da3b09a54380bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42488c1b62c7dfa35e30ef1787da3b09a54380bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42488c1b62c7dfa35e30ef1787da3b09a54380bb/comments", "author": null, "committer": null, "parents": [{"sha": "b313b165a4eac02c7fd079082415ecfac41a0713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b313b165a4eac02c7fd079082415ecfac41a0713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b313b165a4eac02c7fd079082415ecfac41a0713"}], "stats": {"total": 274, "additions": 254, "deletions": 20}, "files": [{"sha": "34c8f6407b53aa44af1b6147469d3162744383e6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=42488c1b62c7dfa35e30ef1787da3b09a54380bb", "patch": "@@ -1,3 +1,13 @@\n+2010-06-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/44582\n+\t* trans-expr.c (arrayfunc_assign_needs_temporary): New function\n+\tto determine if a function assignment can be made without a\n+\ttemporary.\n+\t(gfc_trans_arrayfunc_assign): Move all the conditions that\n+\tsuppress the direct function call to the above new functon and\n+\tcall it.\n+\n 2010-06-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/40158"}, {"sha": "692b3e2f8461a362c055328f7572a442840d45ed", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 75, "deletions": 20, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=42488c1b62c7dfa35e30ef1787da3b09a54380bb", "patch": "@@ -4870,57 +4870,56 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n }\n \n \n-/* Try to translate array(:) = func (...), where func is a transformational\n-   array function, without using a temporary.  Returns NULL is this isn't the\n-   case.  */\n+/* There are quite a lot of restrictions on the optimisation in using an\n+   array function assign without a temporary.  */\n \n-static tree\n-gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n+static bool\n+arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n {\n-  gfc_se se;\n-  gfc_ss *ss;\n   gfc_ref * ref;\n   bool seen_array_ref;\n   bool c = false;\n-  gfc_component *comp = NULL;\n+  gfc_symbol *sym = expr1->symtree->n.sym;\n \n   /* The caller has already checked rank>0 and expr_type == EXPR_FUNCTION.  */\n   if (expr2->value.function.isym && !gfc_is_intrinsic_libcall (expr2))\n-    return NULL;\n+    return true;\n \n-  /* Elemental functions don't need a temporary anyway.  */\n+  /* Elemental functions are scalarized so that they don't need a\n+     temporary in gfc_trans_assignment_1, so return a true.  Otherwise,\n+     they would need special treatment in gfc_trans_arrayfunc_assign.  */\n   if (expr2->value.function.esym != NULL\n       && expr2->value.function.esym->attr.elemental)\n-    return NULL;\n+    return true;\n \n-  /* Fail if rhs is not FULL or a contiguous section.  */\n+  /* Need a temporary if rhs is not FULL or a contiguous section.  */\n   if (expr1->ref && !(gfc_full_array_ref_p (expr1->ref, &c) || c))\n-    return NULL;\n+    return true;\n \n-  /* Fail if EXPR1 can't be expressed as a descriptor.  */\n+  /* Need a temporary if EXPR1 can't be expressed as a descriptor.  */\n   if (gfc_ref_needs_temporary_p (expr1->ref))\n-    return NULL;\n+    return true;\n \n   /* Functions returning pointers need temporaries.  */\n   if (expr2->symtree->n.sym->attr.pointer \n       || expr2->symtree->n.sym->attr.allocatable)\n-    return NULL;\n+    return true;\n \n   /* Character array functions need temporaries unless the\n      character lengths are the same.  */\n   if (expr2->ts.type == BT_CHARACTER && expr2->rank > 0)\n     {\n       if (expr1->ts.u.cl->length == NULL\n \t    || expr1->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n-\treturn NULL;\n+\treturn true;\n \n       if (expr2->ts.u.cl->length == NULL\n \t    || expr2->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n-\treturn NULL;\n+\treturn true;\n \n       if (mpz_cmp (expr1->ts.u.cl->length->value.integer,\n \t\t     expr2->ts.u.cl->length->value.integer) != 0)\n-\treturn NULL;\n+\treturn true;\n     }\n \n   /* Check that no LHS component references appear during an array\n@@ -4934,14 +4933,70 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n       if (ref->type == REF_ARRAY)\n \tseen_array_ref= true;\n       else if (ref->type == REF_COMPONENT && seen_array_ref)\n-\treturn NULL;\n+\treturn true;\n     }\n \n   /* Check for a dependency.  */\n   if (gfc_check_fncall_dependency (expr1, INTENT_OUT,\n \t\t\t\t   expr2->value.function.esym,\n \t\t\t\t   expr2->value.function.actual,\n \t\t\t\t   NOT_ELEMENTAL))\n+    return true;\n+\n+  /* If we have reached here with an intrinsic function, we do not\n+     need a temporary.  */\n+  if (expr2->value.function.isym)\n+    return false;\n+\n+  /* If the LHS is a dummy, we need a temporary if it is not\n+     INTENT(OUT).  */\n+  if (sym->attr.dummy && sym->attr.intent != INTENT_OUT)\n+    return true;\n+\n+  /* A PURE function can unconditionally be called without a temporary.  */\n+  if (expr2->value.function.esym != NULL\n+      && expr2->value.function.esym->attr.pure)\n+    return false;\n+\n+  /* TODO a function that could correctly be declared PURE but is not\n+     could do with returning false as well.  */\n+\n+  if (!sym->attr.use_assoc\n+\t&& !sym->attr.in_common\n+\t&& !sym->attr.pointer\n+\t&& !sym->attr.target\n+\t&& expr2->value.function.esym)\n+    {\n+      /* A temporary is not needed if the function is not contained and\n+\t the variable is local or host associated and not a pointer or\n+\t a target. */\n+      if (!expr2->value.function.esym->attr.contained)\n+\treturn false;\n+\n+      /* A temporary is not needed if the variable is local and not\n+\t a pointer, a target or a result.  */\n+      if (sym->ns->parent\n+\t    && expr2->value.function.esym->ns == sym->ns->parent)\n+\treturn false;\n+    }\n+\n+  /* Default to temporary use.  */\n+  return true;\n+}\n+\n+\n+/* Try to translate array(:) = func (...), where func is a transformational\n+   array function, without using a temporary.  Returns NULL if this isn't the\n+   case.  */\n+\n+static tree\n+gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n+{\n+  gfc_se se;\n+  gfc_ss *ss;\n+  gfc_component *comp = NULL;\n+\n+  if (arrayfunc_assign_needs_temporary (expr1, expr2))\n     return NULL;\n \n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic"}, {"sha": "6bdd576ca7a6ba4cda147136f1d8c44b8a034e25", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42488c1b62c7dfa35e30ef1787da3b09a54380bb", "patch": "@@ -1,3 +1,8 @@\n+2010-06-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/44582\n+\t* gfortran.dg/aliasing_array_result_1.f90 : New test.\n+\n 2010-06-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* lib/lto.exp (lto_prune_warns): Also accept leading single quote."}, {"sha": "d8899d2ecf877b7708e6f5bce42315b69f41b8c8", "filename": "gcc/testsuite/gfortran.dg/aliasing_array_result_1.f90", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_array_result_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42488c1b62c7dfa35e30ef1787da3b09a54380bb/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_array_result_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Faliasing_array_result_1.f90?ref=42488c1b62c7dfa35e30ef1787da3b09a54380bb", "patch": "@@ -0,0 +1,164 @@\n+! { dg-do run }\n+! Tests the fic for PR44582, where gfortran was found to\n+! produce an incorrect result when the result of a function\n+! was aliased by a host or use associated variable, to which\n+! the function is assigned. In these cases a temporary is\n+! required in the function assignments. The check has to be\n+! rather restrictive.  Whilst the cases marked below might\n+! not need temporaries, the TODOs are going to be tough.\n+!\n+! Reported by Yin Ma <yin@absoft.com> and\n+! elaborated by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module foo\n+  INTEGER, PARAMETER :: ONE = 1\n+  INTEGER, PARAMETER :: TEN = 10\n+  INTEGER, PARAMETER :: FIVE = TEN/2\n+  INTEGER, PARAMETER :: TWO = 2\n+  integer :: foo_a(ONE)\n+  integer :: check(ONE) = TEN\n+  LOGICAL :: abort_flag = .false. \n+contains\n+  function foo_f()\n+     integer :: foo_f(ONE)\n+     foo_f = -FIVE\n+     foo_f = foo_a - foo_f\n+  end function foo_f\n+  subroutine bar\n+    foo_a = FIVE\n+! This aliases 'foo_a' by host association.\n+    foo_a = foo_f ()\n+    if (any (foo_a .ne. check)) call myabort (0)\n+  end subroutine bar\n+  subroutine myabort(fl)\n+    integer :: fl\n+    print *, fl\n+    abort_flag = .true.\n+  end subroutine myabort\n+end module foo\n+\n+function h_ext()\n+  use foo\n+  integer :: h_ext(ONE)\n+  h_ext = -FIVE\n+  h_ext = FIVE - h_ext\n+end function h_ext\n+\n+function i_ext() result (h)\n+  use foo\n+  integer :: h(ONE)\n+  h = -FIVE\n+  h = FIVE - h\n+end function i_ext\n+\n+subroutine tobias\n+  use foo\n+  integer :: a(ONE)\n+  a = FIVE\n+  call sub1(a)\n+  if (any (a .ne. check)) call myabort (1)\n+contains\n+  subroutine sub1(x)\n+    integer :: x(ONE)\n+! 'x' is aliased by host association in 'f'.\n+    x = f()\n+  end subroutine sub1\n+  function f()\n+    integer :: f(ONE)\n+    f = ONE\n+    f = a + FIVE\n+  end function f\n+end subroutine tobias\n+\n+program test\n+  use foo\n+  implicit none\n+  common /foo_bar/ c\n+  integer :: a(ONE), b(ONE), c(ONE), d(ONE)\n+  interface\n+    function h_ext()\n+      use foo\n+      integer :: h_ext(ONE)\n+    end function h_ext\n+  end interface\n+  interface\n+    function i_ext() result (h)\n+      use foo\n+      integer :: h(ONE)\n+    end function i_ext\n+  end interface\n+\n+  a = FIVE\n+! This aliases 'a' by host association\n+  a = f()\n+  if (any (a .ne. check)) call myabort (2)\n+  a = FIVE\n+  if (any (f() .ne. check)) call myabort (3)\n+  call bar\n+  foo_a = FIVE\n+! This aliases 'foo_a' by host association.\n+  foo_a = g ()\n+  if (any (foo_a .ne. check)) call myabort (4)\n+  a = FIVE\n+  a = h()           ! TODO: Needs no temporary\n+  if (any (a .ne. check)) call myabort (5)\n+  a = FIVE\n+  a = i()           ! TODO: Needs no temporary\n+  if (any (a .ne. check)) call myabort (6)\n+  a = FIVE\n+  a = h_ext()       ! Needs no temporary - was OK\n+  if (any (a .ne. check)) call myabort (15)\n+  a = FIVE\n+  a = i_ext()       ! Needs no temporary - was OK\n+  if (any (a .ne. check)) call myabort (16)\n+  c = FIVE\n+! This aliases 'c' through the common block.\n+  c = j()\n+  if (any (c .ne. check)) call myabort (7)\n+  call aaa\n+  call tobias\n+  if (abort_flag) call abort\n+contains\n+  function f()\n+     integer :: f(ONE)\n+     f = -FIVE\n+     f = a - f\n+  end function f\n+  function g()\n+     integer :: g(ONE)\n+     g = -FIVE\n+     g = foo_a - g\n+  end function g\n+  function h()\n+     integer :: h(ONE)\n+     h = -FIVE\n+     h = FIVE - h\n+  end function h\n+  function i() result (h)\n+     integer :: h(ONE)\n+     h = -FIVE\n+     h = FIVE - h\n+  end function i\n+  function j()\n+     common /foo_bar/ cc\n+     integer :: j(ONE), cc(ONE)\n+     j = -FIVE\n+     j = cc - j\n+  end function j\n+  subroutine aaa()\n+    d = TEN - TWO\n+! This aliases 'd' through 'get_d'.\n+    d = bbb()\n+    if (any (d .ne. check)) call myabort (8)\n+  end subroutine aaa\n+  function bbb()\n+    integer :: bbb(ONE)\n+    bbb = TWO\n+    bbb = bbb + get_d()\n+  end function bbb\n+  function get_d()\n+    integer :: get_d(ONE)\n+    get_d = d\n+  end function get_d\n+end program test\n+! { dg-final { cleanup-modules \"foo\" } }"}]}