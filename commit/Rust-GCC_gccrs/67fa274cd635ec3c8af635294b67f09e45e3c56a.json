{"sha": "67fa274cd635ec3c8af635294b67f09e45e3c56a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmYTI3NGNkNjM1ZWMzYzhhZjYzNTI5NGI2N2YwOWU0NWUzYzU2YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-02-21T14:28:55Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-02-26T11:57:22Z"}, "message": "analyzer: improvements to logging/dumping\n\nThis patch adds various information to -fdump-analyzer and\n-fdump-analyzer-stderr to make it easier to track down\nproblems with state explosions in the exploded_graph.\n\nIt logs the number of unprocessed nodes in the worklist, for\nthe case where the upper limit on exploded nodes is reached.\n\nIt prints:\n[a] a bar chart showing the number of exploded nodes by function, and\n\n[b] bar charts for each function showing the number of exploded nodes\n    per supernode/BB, and\n\n[c] bar charts for each function showing the number of excess exploded\n    nodes per supernode/BB beyond the limit\n    (--param=analyzer-max-enodes-per-program-point), where that limit\n    was reached\n\nI've found these helpful in finding exactly where we fail to consolidate\nstate, leading to state explosions and false negatives due to the\nthresholds being reached.\n\nThe patch also adds a \"superedge::dump\" member function I found myself\nneeding.\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/bar-chart.o.\n\ngcc/analyzer/ChangeLog:\n\t* bar-chart.cc: New file.\n\t* bar-chart.h: New file.\n\t* engine.cc: Include \"analyzer/bar-chart.h\".\n\t(stats::log): Only log the m_num_nodes kinds that are non-zero.\n\t(stats::dump): Likewise when dumping.\n\t(stats::get_total_enodes): New.\n\t(exploded_graph::get_or_create_node): Increment the per-point-data\n\tm_excess_enodes when hitting the per-program-point limit on\n\tenodes.\n\t(exploded_graph::print_bar_charts): New.\n\t(exploded_graph::log_stats): Log the number of unprocessed enodes\n\tin the worklist.  Call print_bar_charts.\n\t(exploded_graph::dump_stats): Print the number of unprocessed\n\tenodes in the worklist.\n\t* exploded-graph.h (stats::get_total_enodes): New decl.\n\t(struct per_program_point_data): Add field m_excess_enodes.\n\t(exploded_graph::print_bar_charts): New decl.\n\t* supergraph.cc (superedge::dump): New.\n\t(superedge::dump): New.\n\t* supergraph.h (supernode::get_function): New.\n\t(superedge::dump): New decl.\n\t(superedge::dump): New decl.", "tree": {"sha": "5e4a3b45327dc89b6d8791fa236a6c48cb7c0b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e4a3b45327dc89b6d8791fa236a6c48cb7c0b46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67fa274cd635ec3c8af635294b67f09e45e3c56a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67fa274cd635ec3c8af635294b67f09e45e3c56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67fa274cd635ec3c8af635294b67f09e45e3c56a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67fa274cd635ec3c8af635294b67f09e45e3c56a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce25177f505ea75b3c0833c3f3f0072b97ee1b44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce25177f505ea75b3c0833c3f3f0072b97ee1b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce25177f505ea75b3c0833c3f3f0072b97ee1b44"}], "stats": {"total": 353, "additions": 346, "deletions": 7}, "files": [{"sha": "7504b13022263110fc505664626f1a7dad8eba28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -1,3 +1,7 @@\n+2020-02-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (ANALYZER_OBJS): Add analyzer/bar-chart.o.\n+\n 2020-02-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/93820"}, {"sha": "fa9923bb27032fba3ae54ed5cb54b255a6706665", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -1221,6 +1221,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/analyzer-logging.o \\\n \tanalyzer/analyzer-pass.o \\\n \tanalyzer/analyzer-selftests.o \\\n+\tanalyzer/bar-chart.o \\\n \tanalyzer/call-string.o \\\n \tanalyzer/checker-path.o \\\n \tanalyzer/constraint-manager.o \\"}, {"sha": "982cc3ca9fd48643cfe3656acc9c4cb10b2f3f24", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -1,3 +1,28 @@\n+2020-02-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* bar-chart.cc: New file.\n+\t* bar-chart.h: New file.\n+\t* engine.cc: Include \"analyzer/bar-chart.h\".\n+\t(stats::log): Only log the m_num_nodes kinds that are non-zero.\n+\t(stats::dump): Likewise when dumping.\n+\t(stats::get_total_enodes): New.\n+\t(exploded_graph::get_or_create_node): Increment the per-point-data\n+\tm_excess_enodes when hitting the per-program-point limit on\n+\tenodes.\n+\t(exploded_graph::print_bar_charts): New.\n+\t(exploded_graph::log_stats): Log the number of unprocessed enodes\n+\tin the worklist.  Call print_bar_charts.\n+\t(exploded_graph::dump_stats): Print the number of unprocessed\n+\tenodes in the worklist.\n+\t* exploded-graph.h (stats::get_total_enodes): New decl.\n+\t(struct per_program_point_data): Add field m_excess_enodes.\n+\t(exploded_graph::print_bar_charts): New decl.\n+\t* supergraph.cc (superedge::dump): New.\n+\t(superedge::dump): New.\n+\t* supergraph.h (supernode::get_function): New.\n+\t(superedge::dump): New decl.\n+\t(superedge::dump): New decl.\n+\n 2020-02-24  David Malcolm  <dmalcolm@redhat.com>\n \n \t* engine.cc (exploded_graph::get_or_create_node): Dump the"}, {"sha": "d0e30b68d0fc5e570f2d5cbbb9a8e3531c58840d", "filename": "gcc/analyzer/bar-chart.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fbar-chart.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fbar-chart.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fbar-chart.cc?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -0,0 +1,102 @@\n+/* Support for plotting bar charts in dumps.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"pretty-print.h\"\n+#include \"analyzer/bar-chart.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class bar_chart.  */\n+\n+/* Add an item, taking a copy of NAME.  */\n+\n+void\n+bar_chart::add_item (const char *name, value_t value)\n+{\n+  m_items.safe_push (new item (name, value));\n+}\n+\n+/* Print the data to PP.  */\n+\n+void\n+bar_chart::print (pretty_printer *pp) const\n+{\n+  /* Get maximum printing widths and maximum value.  */\n+  size_t max_width_name = 0;\n+  size_t max_width_value = 0;\n+  value_t max_value = 0;\n+  unsigned i;\n+  item *item;\n+  char digit_buffer[128];\n+  FOR_EACH_VEC_ELT (m_items, i, item)\n+    {\n+      max_width_name = MAX (max_width_name, item->m_strlen);\n+      sprintf (digit_buffer, \"%li\", item->m_value);\n+      max_width_value = MAX (max_width_value, strlen (digit_buffer));\n+      max_value = MAX (max_value, item->m_value);\n+    }\n+\n+  /* Print items.  */\n+  FOR_EACH_VEC_ELT (m_items, i, item)\n+    {\n+      /* Print left-aligned name, padding to max_width_name.  */\n+      pp_string (pp, item->m_name);\n+      print_padding (pp, max_width_name - item->m_strlen);\n+\n+      pp_string (pp, \": \");\n+\n+      /* Print right-aligned name, padding to max_width_value.  */\n+      sprintf (digit_buffer, \"%li\", item->m_value);\n+      const size_t value_width = strlen (digit_buffer);\n+      print_padding (pp, max_width_value - value_width);\n+      pp_string (pp, digit_buffer);\n+\n+      pp_character (pp, '|');\n+\n+      /* Print bar, scaled in proportion to max value.  */\n+      const int max_width_bar\n+\t= MIN (max_value, 76 - (max_width_name + max_width_value + 4));\n+      const int bar_width\n+\t= (max_value > 0 ? (max_width_bar * item->m_value) / max_value : 0);\n+      for (int j = 0; j < bar_width; j++)\n+\tpp_character (pp, '#');\n+      print_padding (pp, max_width_bar - bar_width);\n+      pp_character (pp, '|');\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Print COUNT spaces to PP.  */\n+\n+void\n+bar_chart::print_padding (pretty_printer *pp, size_t count)\n+{\n+  for (size_t i = 0; i < count; i++)\n+    pp_character (pp, ' ');\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "07e93c5e394b82929d2d6895771b71807d6c24c3", "filename": "gcc/analyzer/bar-chart.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fbar-chart.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fbar-chart.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fbar-chart.h?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -0,0 +1,60 @@\n+/* Support for plotting bar charts in dumps.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_BAR_CHART_H\n+#define GCC_ANALYZER_BAR_CHART_H\n+\n+namespace ana {\n+\n+/* A class for printing bar charts to a pretty_printer.\n+\n+   TODO(stage1): move to gcc subdir? */\n+\n+class bar_chart\n+{\n+public:\n+  typedef unsigned long value_t;\n+\n+  /* Add an item, taking a copy of NAME.  */\n+  void add_item (const char *name, value_t value);\n+\n+  /* Print the data to PP.  */\n+  void print (pretty_printer *pp) const;\n+\n+private:\n+  struct item\n+  {\n+    item (const char *name, value_t value)\n+    : m_name (xstrdup (name)), m_strlen (strlen (name)) , m_value (value) {}\n+    ~item () { free (m_name); }\n+\n+    char *m_name;\n+    size_t m_strlen;\n+    value_t m_value;\n+  };\n+\n+  static void print_padding (pretty_printer *pp, size_t count);\n+\n+  auto_delete_vec<item> m_items;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_BAR_CHART_H */"}, {"sha": "9c3b5adc09b305049ef32918b9c5c07a7c7795df", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 119, "deletions": 6, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analysis-plan.h\"\n #include \"analyzer/checker-path.h\"\n #include \"analyzer/state-purge.h\"\n+#include \"analyzer/bar-chart.h\"\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -1527,9 +1528,10 @@ stats::log (logger *logger) const\n {\n   gcc_assert (logger);\n   for (int i = 0; i < NUM_POINT_KINDS; i++)\n-    logger->log (\"m_num_nodes[%s]: %i\",\n-\t\t point_kind_to_string (static_cast <enum point_kind> (i)),\n-\t\t m_num_nodes[i]);\n+    if (m_num_nodes[i] > 0)\n+      logger->log (\"m_num_nodes[%s]: %i\",\n+\t\t   point_kind_to_string (static_cast <enum point_kind> (i)),\n+\t\t   m_num_nodes[i]);\n   logger->log (\"m_node_reuse_count: %i\", m_node_reuse_count);\n   logger->log (\"m_node_reuse_after_merge_count: %i\",\n \t       m_node_reuse_after_merge_count);\n@@ -1541,9 +1543,10 @@ void\n stats::dump (FILE *out) const\n {\n   for (int i = 0; i < NUM_POINT_KINDS; i++)\n-    fprintf (out, \"m_num_nodes[%s]: %i\\n\",\n-\t     point_kind_to_string (static_cast <enum point_kind> (i)),\n-\t     m_num_nodes[i]);\n+    if (m_num_nodes[i] > 0)\n+      fprintf (out, \"m_num_nodes[%s]: %i\\n\",\n+\t       point_kind_to_string (static_cast <enum point_kind> (i)),\n+\t       m_num_nodes[i]);\n   fprintf (out, \"m_node_reuse_count: %i\\n\", m_node_reuse_count);\n   fprintf (out, \"m_node_reuse_after_merge_count: %i\\n\",\n \t   m_node_reuse_after_merge_count);\n@@ -1553,6 +1556,17 @@ stats::dump (FILE *out) const\n \t     (float)m_num_nodes[PK_AFTER_SUPERNODE] / (float)m_num_supernodes);\n }\n \n+/* Return the total number of enodes recorded within this object.  */\n+\n+int\n+stats::get_total_enodes () const\n+{\n+  int result = 0;\n+  for (int i = 0; i < NUM_POINT_KINDS; i++)\n+    result += m_num_nodes[i];\n+  return result;\n+}\n+\n /* strongly_connected_components's ctor.  Tarjan's SCC algorithm.  */\n \n strongly_connected_components::\n@@ -1982,6 +1996,7 @@ exploded_graph::get_or_create_node (const program_point &point,\n \tlogger->log (\"not creating enode; too many at program point\");\n       warning_at (point.get_location (), OPT_Wanalyzer_too_complex,\n \t\t  \"terminating analysis for this program point\");\n+      per_point_data->m_excess_enodes++;\n       return NULL;\n     }\n \n@@ -2606,6 +2621,100 @@ exploded_graph::get_or_create_function_stats (function *fn)\n     }\n }\n \n+/* Print bar charts to PP showing:\n+   - the number of enodes per function, and\n+   - for each function:\n+     - the number of enodes per supernode/BB\n+     - the number of excess enodes per supernode/BB beyond the\n+       per-program-point limit, if there were any.  */\n+\n+void\n+exploded_graph::print_bar_charts (pretty_printer *pp) const\n+{\n+  cgraph_node *cgnode;\n+\n+  pp_string (pp, \"enodes per function:\");\n+  pp_newline (pp);\n+  bar_chart enodes_per_function;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (cgnode)\n+    {\n+      function *fn = cgnode->get_fun ();\n+      const stats * const *s_ptr\n+\t= const_cast <function_stat_map_t &> (m_per_function_stats).get (fn);\n+      enodes_per_function.add_item (function_name (fn),\n+\t\t\t\t    s_ptr ? (*s_ptr)->get_total_enodes () : 0);\n+    }\n+  enodes_per_function.print (pp);\n+\n+  /* Accumulate number of enodes per supernode.  */\n+  auto_vec<unsigned> enodes_per_supernode (m_sg.num_nodes ());\n+  for (int i = 0; i < m_sg.num_nodes (); i++)\n+    enodes_per_supernode.quick_push (0);\n+  int i;\n+  exploded_node *enode;\n+  FOR_EACH_VEC_ELT (m_nodes, i, enode)\n+    {\n+      const supernode *iter_snode = enode->get_supernode ();\n+      if (!iter_snode)\n+\tcontinue;\n+      enodes_per_supernode[iter_snode->m_index]++;\n+    }\n+\n+  /* Accumulate excess enodes per supernode.  */\n+  auto_vec<unsigned> excess_enodes_per_supernode (m_sg.num_nodes ());\n+  for (int i = 0; i < m_sg.num_nodes (); i++)\n+    excess_enodes_per_supernode.quick_push (0);\n+  for (point_map_t::iterator iter = m_per_point_data.begin ();\n+       iter != m_per_point_data.end (); ++iter)\n+    {\n+      const program_point *point = (*iter).first;\n+      const supernode *iter_snode = point->get_supernode ();\n+      if (!iter_snode)\n+\tcontinue;\n+      const per_program_point_data *point_data = (*iter).second;\n+      excess_enodes_per_supernode[iter_snode->m_index]\n+\t+= point_data->m_excess_enodes;\n+    }\n+\n+  /* Show per-function bar_charts of enodes per supernode/BB.  */\n+  pp_string (pp, \"per-function enodes per supernode/BB:\");\n+  pp_newline (pp);\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (cgnode)\n+    {\n+      function *fn = cgnode->get_fun ();\n+      pp_printf (pp, \"function: %qs\", function_name (fn));\n+      pp_newline (pp);\n+\n+      bar_chart enodes_per_snode;\n+      bar_chart excess_enodes_per_snode;\n+      bool have_excess_enodes = false;\n+      for (int i = 0; i < m_sg.num_nodes (); i++)\n+\t{\n+\t  const supernode *iter_snode = m_sg.get_node_by_index (i);\n+\t  if (iter_snode->get_function () != fn)\n+\t    continue;\n+\t  pretty_printer tmp_pp;\n+\t  pp_printf (&tmp_pp, \"sn %i (bb %i)\",\n+\t\t     iter_snode->m_index, iter_snode->m_bb->index);\n+\t  enodes_per_snode.add_item (pp_formatted_text (&tmp_pp),\n+\t\t\t\t     enodes_per_supernode[iter_snode->m_index]);\n+\t  const int num_excess\n+\t    = excess_enodes_per_supernode[iter_snode->m_index];\n+\t  excess_enodes_per_snode.add_item (pp_formatted_text (&tmp_pp),\n+\t\t\t\t\t    num_excess);\n+\t  if (num_excess)\n+\t    have_excess_enodes = true;\n+\t}\n+      enodes_per_snode.print (pp);\n+      if (have_excess_enodes)\n+\t{\n+\t  pp_printf (pp, \"EXCESS ENODES:\");\n+\t  pp_newline (pp);\n+\t  excess_enodes_per_snode.print (pp);\n+\t}\n+    }\n+}\n+\n /* Write all stats information to this graph's logger, if any.  */\n \n void\n@@ -2620,6 +2729,7 @@ exploded_graph::log_stats () const\n   logger->log (\"m_sg.num_nodes (): %i\", m_sg.num_nodes ());\n   logger->log (\"m_nodes.length (): %i\", m_nodes.length ());\n   logger->log (\"m_edges.length (): %i\", m_edges.length ());\n+  logger->log (\"remaining enodes in worklist: %i\", m_worklist.length ());\n \n   logger->log (\"global stats:\");\n   m_global_stats.log (logger);\n@@ -2632,6 +2742,8 @@ exploded_graph::log_stats () const\n       log_scope s (logger, function_name (fn));\n       (*iter).second->log (logger);\n     }\n+\n+  print_bar_charts (logger->get_printer ());\n }\n \n /* Dump all stats information to OUT.  */\n@@ -2642,6 +2754,7 @@ exploded_graph::dump_stats (FILE *out) const\n   fprintf (out, \"m_sg.num_nodes (): %i\\n\", m_sg.num_nodes ());\n   fprintf (out, \"m_nodes.length (): %i\\n\", m_nodes.length ());\n   fprintf (out, \"m_edges.length (): %i\\n\", m_edges.length ());\n+  fprintf (out, \"remaining enodes in worklist: %i\", m_worklist.length ());\n \n   fprintf (out, \"global stats:\\n\");\n   m_global_stats.dump (out);"}, {"sha": "c3bd383e924573fb86ac2b439e1492742e9ad92d", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -400,6 +400,8 @@ struct stats\n   void log (logger *logger) const;\n   void dump (FILE *out) const;\n \n+  int get_total_enodes () const;\n+\n   int m_num_nodes[NUM_POINT_KINDS];\n   int m_node_reuse_count;\n   int m_node_reuse_after_merge_count;\n@@ -466,11 +468,14 @@ struct eg_hash_map_traits\n struct per_program_point_data\n {\n   per_program_point_data (const program_point &key)\n-  : m_key (key)\n+  : m_key (key), m_excess_enodes (0)\n   {}\n \n   const program_point m_key;\n   auto_vec<exploded_node *> m_enodes;\n+  /* The number of attempts to create an enode for this point\n+     after exceeding --param=analyzer-max-enodes-per-program-point.  */\n+  int m_excess_enodes;\n };\n \n /* Traits class for storing per-program_point data within\n@@ -791,6 +796,8 @@ class exploded_graph : public digraph<eg_traits>\n   { return &m_per_call_string_data; }\n \n private:\n+  void print_bar_charts (pretty_printer *pp) const;\n+\n   DISABLE_COPY_AND_ASSIGN (exploded_graph);\n \n   const supergraph &m_sg;"}, {"sha": "e4c067606e0c1330f208d8d24fe76c8cdb115541", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -624,6 +624,29 @@ supernode::get_stmt_index (const gimple *stmt) const\n   gcc_unreachable ();\n }\n \n+/* Dump this superedge to PP.  */\n+\n+void\n+superedge::dump (pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"edge: SN: %i -> SN: %i\", m_src->m_index, m_dest->m_index);\n+  dump_label_to_pp (pp, false);\n+  pp_newline (pp);\n+}\n+\n+/* Dump this superedge to stderr.  */\n+\n+DEBUG_FUNCTION void\n+superedge::dump () const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump (&pp);\n+  pp_flush (&pp);\n+}\n+\n /* Implementation of dedge::dump_dot for superedges.\n    Write a .dot edge to GV representing this superedge.  */\n "}, {"sha": "ddb674da3b1934618ca6593f234e6c068e6a7937", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67fa274cd635ec3c8af635294b67f09e45e3c56a/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=67fa274cd635ec3c8af635294b67f09e45e3c56a", "patch": "@@ -216,6 +216,8 @@ class supernode : public dnode<supergraph_traits>\n     m_phi_nodes (phi_nodes), m_index (index)\n   {}\n \n+  function *get_function () const { return m_fun; }\n+\n   bool entry_p () const\n   {\n     return m_bb == ENTRY_BLOCK_PTR_FOR_FN (m_fun);\n@@ -280,6 +282,8 @@ class superedge : public dedge<supergraph_traits>\n  public:\n   virtual ~superedge () {}\n \n+  void dump (pretty_printer *pp) const;\n+  void dump () const;\n   void dump_dot (graphviz_out *gv, const dump_args_t &args) const;\n \n   virtual void dump_label_to_pp (pretty_printer *pp,"}]}