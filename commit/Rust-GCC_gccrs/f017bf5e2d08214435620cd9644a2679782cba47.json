{"sha": "f017bf5e2d08214435620cd9644a2679782cba47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxN2JmNWUyZDA4MjE0NDM1NjIwY2Q5NjQ0YTI2Nzk3ODJjYmE0Nw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2009-03-04T17:50:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2009-03-04T17:50:20Z"}, "message": "tree-scalar-evolution.c (analyze_scalar_evolution_in_loop): Extend comments.\n\n\t* tree-scalar-evolution.c (analyze_scalar_evolution_in_loop):\n\tExtend comments.\n\t(simple_iv):  Take loop as an argument instead of statement.\n\t* tree-scalar-evolution.h (simple_iv): Declaration changed.\n\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Update calls\n\tto simple_iv.\n\t* tree-ssa-loop-ivopts.c (determine_biv_step, find_givs_in_stmt_scev):\n\tDitto.\n\t* tree-parloops.c (loop_parallel_p, canonicalize_loop_ivs): Ditto.\n\t* matrix-reorg.c (analyze_transpose): Ditto.\n\t* tree-data-ref.c (dr_analyze_innermost): Ditto.\n\t* tree-vect-analyze.c (vect_analyze_data_refs): Ditto.\n\t* tree-predcom.c (ref_at_iteration): Ditto.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Ditto.\n\nFrom-SVN: r144615", "tree": {"sha": "1784f170df203484b0353b0a27338ee477b5fc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1784f170df203484b0353b0a27338ee477b5fc6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f017bf5e2d08214435620cd9644a2679782cba47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f017bf5e2d08214435620cd9644a2679782cba47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f017bf5e2d08214435620cd9644a2679782cba47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f017bf5e2d08214435620cd9644a2679782cba47/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79c09787dcece54e89f97c644ea8fd82d12e723a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c09787dcece54e89f97c644ea8fd82d12e723a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c09787dcece54e89f97c644ea8fd82d12e723a"}], "stats": {"total": 168, "additions": 129, "deletions": 39}, "files": [{"sha": "451eafadddacdb0021aa0223deaef3d8d0e7b866", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -1,3 +1,20 @@\n+2009-03-04  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* tree-scalar-evolution.c (analyze_scalar_evolution_in_loop):\n+\tExtend comments.\n+\t(simple_iv):  Take loop as an argument instead of statement.\n+\t* tree-scalar-evolution.h (simple_iv): Declaration changed.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_exit): Update calls\n+\tto simple_iv.\n+\t* tree-ssa-loop-ivopts.c (determine_biv_step, find_givs_in_stmt_scev):\n+\tDitto.\n+\t* tree-parloops.c (loop_parallel_p, canonicalize_loop_ivs): Ditto.\n+\t* matrix-reorg.c (analyze_transpose): Ditto.\n+\t* tree-data-ref.c (dr_analyze_innermost): Ditto.\n+\t* tree-vect-analyze.c (vect_analyze_data_refs): Ditto.\n+\t* tree-predcom.c (ref_at_iteration): Ditto.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Ditto.\n+\n 2009-03-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/39358"}, {"sha": "7ea185ced206d6c1aba082c5e225cef3a09e9ab7", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -930,7 +930,7 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n \t      free (acc_info);\n \t      continue;\n \t    }\n-\t  if (simple_iv (loop, acc_info->stmt, acc_info->offset, &iv, true))\n+\t  if (simple_iv (loop, loop, acc_info->offset, &iv, true))\n \t    {\n \t      if (iv.step != NULL)\n \t\t{"}, {"sha": "7c062602a1a55ad0816d8fcdf29adeb59b65a792", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -698,7 +698,7 @@ dr_analyze_innermost (struct data_reference *dr)\n     }\n \n   base = build_fold_addr_expr (base);\n-  if (!simple_iv (loop, stmt, base, &base_iv, false))\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), base, &base_iv, false))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n@@ -709,7 +709,8 @@ dr_analyze_innermost (struct data_reference *dr)\n       offset_iv.base = ssize_int (0);\n       offset_iv.step = ssize_int (0);\n     }\n-  else if (!simple_iv (loop, stmt, poffset, &offset_iv, false))\n+  else if (!simple_iv (loop, loop_containing_stmt (stmt),\n+\t\t       poffset, &offset_iv, false))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"failed: evolution of offset is not affine.\\n\");"}, {"sha": "4e9b102973a102990831d0a764cffb1917981418", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -385,7 +385,7 @@ loop_parallel_p (struct loop *loop, htab_t reduction_list,\n       tree def = PHI_RESULT (phi);\n       affine_iv iv;\n \n-      if (is_gimple_reg (def) && !simple_iv (loop, phi, def, &iv, true))\n+      if (is_gimple_reg (def) && !simple_iv (loop, loop, def, &iv, true))\n \t{\n \t  struct reduction_info *red;\n \n@@ -1380,7 +1380,7 @@ canonicalize_loop_ivs (struct loop *loop, htab_t reduction_list, tree *nit)\n \t  continue;\n \t}\n \n-      ok = simple_iv (loop, phi, res, &iv, true);\n+      ok = simple_iv (loop, loop, res, &iv, true);\n \n       if (reduction_list)\n \tred = reduction_phi (reduction_list, phi);"}, {"sha": "bd82a8016fb7dfd6cade9f1b0140b52ab7387bb3", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -1374,7 +1374,7 @@ ref_at_iteration (struct loop *loop, tree ref, int iter)\n   else\n     return NULL_TREE;\n \n-  ok = simple_iv (loop, first_stmt (loop->header), idx, &iv, true);\n+  ok = simple_iv (loop, loop, idx, &iv, true);\n   if (!ok)\n     return NULL_TREE;\n   iv.base = expand_simple_operations (iv.base);"}, {"sha": "8e12c2b32abe3437758878213c83c4fe6ee5c27b", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 94, "deletions": 25, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -1915,12 +1915,54 @@ analyze_scalar_evolution (struct loop *loop, tree var)\n }\n \n /* Analyze scalar evolution of use of VERSION in USE_LOOP with respect to\n-   WRTO_LOOP (which should be a superloop of both USE_LOOP and definition\n-   of VERSION).\n+   WRTO_LOOP (which should be a superloop of USE_LOOP)\n \n    FOLDED_CASTS is set to true if resolve_mixers used\n    chrec_convert_aggressive (TODO -- not really, we are way too conservative\n-   at the moment in order to keep things simple).  */\n+   at the moment in order to keep things simple). \n+   \n+   To illustrate the meaning of USE_LOOP and WRTO_LOOP, consider the following\n+   example:\n+\n+   for (i = 0; i < 100; i++)\t\t\t-- loop 1\n+     {\n+       for (j = 0; j < 100; j++)\t\t-- loop 2\n+         {\n+\t   k1 = i;\n+\t   k2 = j;\n+\n+\t   use2 (k1, k2);\n+\n+\t   for (t = 0; t < 100; t++)\t\t-- loop 3\n+\t     use3 (k1, k2);\n+\n+\t }\n+       use1 (k1, k2);\n+     }\n+\n+   Both k1 and k2 are invariants in loop3, thus\n+     analyze_scalar_evolution_in_loop (loop3, loop3, k1) = k1\n+     analyze_scalar_evolution_in_loop (loop3, loop3, k2) = k2\n+\n+   As they are invariant, it does not matter whether we consider their\n+   usage in loop 3 or loop 2, hence\n+     analyze_scalar_evolution_in_loop (loop2, loop3, k1) =\n+       analyze_scalar_evolution_in_loop (loop2, loop2, k1) = i\n+     analyze_scalar_evolution_in_loop (loop2, loop3, k2) =\n+       analyze_scalar_evolution_in_loop (loop2, loop2, k2) = [0,+,1]_2\n+\n+   Similarly for their evolutions with respect to loop 1.  The values of K2\n+   in the use in loop 2 vary independently on loop 1, thus we cannot express\n+   the evolution with respect to loop 1:\n+     analyze_scalar_evolution_in_loop (loop1, loop3, k1) =\n+       analyze_scalar_evolution_in_loop (loop1, loop2, k1) = [0,+,1]_1\n+     analyze_scalar_evolution_in_loop (loop1, loop3, k2) =\n+       analyze_scalar_evolution_in_loop (loop1, loop2, k2) = dont_know\n+\n+   The value of k2 in the use in loop 1 is known, though:\n+     analyze_scalar_evolution_in_loop (loop1, loop1, k1) = [0,+,1]_1\n+     analyze_scalar_evolution_in_loop (loop1, loop1, k2) = 100\n+   */\n \n static tree\n analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n@@ -1929,6 +1971,25 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n   bool val = false;\n   tree ev = version, tmp;\n \n+  /* We cannot just do \n+\n+     tmp = analyze_scalar_evolution (use_loop, version);\n+     ev = resolve_mixers (wrto_loop, tmp);\n+\n+     as resolve_mixers would query the scalar evolution with respect to\n+     wrto_loop.  For example, in the situation described in the function\n+     comment, suppose that wrto_loop = loop1, use_loop = loop3 and\n+     version = k2.  Then\n+\n+     analyze_scalar_evolution (use_loop, version) = k2\n+\n+     and resolve_mixers (loop1, k2) finds that the value of k2 in loop 1\n+     is 100, which is a wrong result, since we are interested in the\n+     value in loop 3.\n+\n+     Instead, we need to proceed from use_loop to wrto_loop loop by loop,\n+     each time checking that there is no evolution in the inner loop.  */\n+\n   if (folded_casts)\n     *folded_casts = false;\n   while (1)\n@@ -2743,17 +2804,31 @@ scev_reset (void)\n     }\n }\n \n-/* Checks whether OP behaves as a simple affine iv of LOOP in STMT and returns\n-   its base and step in IV if possible.  If ALLOW_NONCONSTANT_STEP is true, we\n-   want step to be invariant in LOOP.  Otherwise we require it to be an\n-   integer constant.  IV->no_overflow is set to true if we are sure the iv cannot\n-   overflow (e.g.  because it is computed in signed arithmetics).  */\n+/* Checks whether use of OP in USE_LOOP behaves as a simple affine iv with\n+   respect to WRTO_LOOP and returns its base and step in IV if possible\n+   (see analyze_scalar_evolution_in_loop for more details on USE_LOOP\n+   and WRTO_LOOP).  If ALLOW_NONCONSTANT_STEP is true, we want step to be\n+   invariant in LOOP.  Otherwise we require it to be an integer constant.\n+   \n+   IV->no_overflow is set to true if we are sure the iv cannot overflow (e.g.\n+   because it is computed in signed arithmetics).  Consequently, adding an\n+   induction variable\n+   \n+   for (i = IV->base; ; i += IV->step)\n+\n+   is only safe if IV->no_overflow is false, or TYPE_OVERFLOW_UNDEFINED is\n+   false for the type of the induction variable, or you can prove that i does\n+   not wrap by some other argument.  Otherwise, this might introduce undefined\n+   behavior, and\n+   \n+   for (i = iv->base; ; i = (type) ((unsigned type) i + (unsigned type) iv->step))\n+\n+   must be used instead.  */\n \n bool\n-simple_iv (struct loop *loop, gimple stmt, tree op, affine_iv *iv,\n-\t   bool allow_nonconstant_step)\n+simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n+\t   affine_iv *iv, bool allow_nonconstant_step)\n {\n-  basic_block bb = gimple_bb (stmt);\n   tree type, ev;\n   bool folded_casts;\n \n@@ -2766,13 +2841,13 @@ simple_iv (struct loop *loop, gimple stmt, tree op, affine_iv *iv,\n       && TREE_CODE (type) != POINTER_TYPE)\n     return false;\n \n-  ev = analyze_scalar_evolution_in_loop (loop, bb->loop_father, op,\n+  ev = analyze_scalar_evolution_in_loop (wrto_loop, use_loop, op,\n \t\t\t\t\t &folded_casts);\n-  if (chrec_contains_undetermined (ev))\n+  if (chrec_contains_undetermined (ev)\n+      || chrec_contains_symbols_defined_in_loop (ev, wrto_loop->num))\n     return false;\n \n-  if (tree_does_not_contain_chrecs (ev)\n-      && !chrec_contains_symbols_defined_in_loop (ev, loop->num))\n+  if (tree_does_not_contain_chrecs (ev))\n     {\n       iv->base = ev;\n       iv->step = build_int_cst (TREE_TYPE (ev), 0);\n@@ -2781,22 +2856,16 @@ simple_iv (struct loop *loop, gimple stmt, tree op, affine_iv *iv,\n     }\n \n   if (TREE_CODE (ev) != POLYNOMIAL_CHREC\n-      || CHREC_VARIABLE (ev) != (unsigned) loop->num)\n+      || CHREC_VARIABLE (ev) != (unsigned) wrto_loop->num)\n     return false;\n \n   iv->step = CHREC_RIGHT (ev);\n-  if (allow_nonconstant_step)\n-    {\n-      if (tree_contains_chrecs (iv->step, NULL)\n-\t  || chrec_contains_symbols_defined_in_loop (iv->step, loop->num))\n-\treturn false;\n-    }\n-  else if (TREE_CODE (iv->step) != INTEGER_CST)\n+  if ((!allow_nonconstant_step && TREE_CODE (iv->step) != INTEGER_CST)\n+      || tree_contains_chrecs (iv->step, NULL))\n     return false;\n \n   iv->base = CHREC_LEFT (ev);\n-  if (tree_contains_chrecs (iv->base, NULL)\n-      || chrec_contains_symbols_defined_in_loop (iv->base, loop->num))\n+  if (tree_contains_chrecs (iv->base, NULL))\n     return false;\n \n   iv->no_overflow = !folded_casts && TYPE_OVERFLOW_UNDEFINED (type);"}, {"sha": "06324972ca541412092eb5d508a54bfa990e22b7", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -36,7 +36,7 @@ extern void scev_analysis (void);\n unsigned int scev_const_prop (void);\n \n bool expression_expensive_p (tree);\n-extern bool simple_iv (struct loop *, gimple, tree, affine_iv *, bool);\n+extern bool simple_iv (struct loop *, struct loop *, tree, affine_iv *, bool);\n \n /* Returns the basic block preceding LOOP or ENTRY_BLOCK_PTR when the\n    loop is function's body.  */"}, {"sha": "c7bfa07be8065b09a09a408a8f3a9ed66cc96ab0", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -884,7 +884,7 @@ determine_biv_step (gimple phi)\n   if (!is_gimple_reg (name))\n     return NULL_TREE;\n \n-  if (!simple_iv (loop, phi, name, &iv, true))\n+  if (!simple_iv (loop, loop, name, &iv, true))\n     return NULL_TREE;\n \n   return integer_zerop (iv.step) ? NULL_TREE : iv.step;\n@@ -990,7 +990,7 @@ find_givs_in_stmt_scev (struct ivopts_data *data, gimple stmt, affine_iv *iv)\n   if (TREE_CODE (lhs) != SSA_NAME)\n     return false;\n \n-  if (!simple_iv (loop, stmt, lhs, iv, true))\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), lhs, iv, true))\n     return false;\n   iv->base = expand_simple_operations (iv->base);\n "}, {"sha": "c67e638d58af2c44b550321ca5ae6b7066f5c18d", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -1781,9 +1781,9 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n       && !POINTER_TYPE_P (type))\n     return false;\n      \n-  if (!simple_iv (loop, stmt, op0, &iv0, false))\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), op0, &iv0, false))\n     return false;\n-  if (!simple_iv (loop, stmt, op1, &iv1, false))\n+  if (!simple_iv (loop, loop_containing_stmt (stmt), op1, &iv1, false))\n     return false;\n \n   /* We don't want to see undefined signed overflow warnings while"}, {"sha": "d0e460cf92eab07ac1aae747e65dcf3a3c5c2a6c", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -364,7 +364,8 @@ idx_analyze_ref (tree base, tree *index, void *data)\n       || TREE_CODE (base) == ALIGN_INDIRECT_REF)\n     return false;\n \n-  if (!simple_iv (ar_data->loop, ar_data->stmt, *index, &iv, false))\n+  if (!simple_iv (ar_data->loop, loop_containing_stmt (ar_data->stmt),\n+\t\t  *index, &iv, false))\n     return false;\n   ibase = iv.base;\n   step = iv.step;"}, {"sha": "0b947143c68575690de459d4e15f34cd4e3c78b3", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f017bf5e2d08214435620cd9644a2679782cba47/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=f017bf5e2d08214435620cd9644a2679782cba47", "patch": "@@ -3622,7 +3622,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t    }\n \n \t  outer_base = build_fold_addr_expr (outer_base);\n-\t  if (!simple_iv (loop, stmt, outer_base, &base_iv, false))\n+\t  if (!simple_iv (loop, loop_containing_stmt (stmt), outer_base,\n+\t\t\t  &base_iv, false))\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tfprintf (vect_dump, \"failed: evolution of base is not affine.\\n\");\n@@ -3642,7 +3643,8 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t      offset_iv.base = ssize_int (0);\n \t      offset_iv.step = ssize_int (0);\n \t    }\n-\t  else if (!simple_iv (loop, stmt, poffset, &offset_iv, false))\n+\t  else if (!simple_iv (loop, loop_containing_stmt (stmt), poffset,\n+\t\t\t       &offset_iv, false))\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t        fprintf (vect_dump, \"evolution of offset is not affine.\\n\");"}]}