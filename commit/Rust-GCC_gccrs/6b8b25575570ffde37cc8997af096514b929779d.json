{"sha": "6b8b25575570ffde37cc8997af096514b929779d", "node_id": "C_kwDOANBUbNoAKDZiOGIyNTU3NTU3MGZmZGUzN2NjODk5N2FmMDk2NTE0YjkyOTc3OWQ", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-10-26T07:33:41Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-10-26T07:33:41Z"}, "message": "x86_64: Implement V1TI mode shifts/rotates by a constant\n\nThis patch provides RTL expanders to implement logical shifts and\nrotates of 128-bit values (stored in vector integer registers) by\nconstant bit counts.  Previously, GCC would transfer these values\nto a pair of integer registers (TImode) via memory to perform the\noperation, then transfer the result back via memory.  Instead these\noperations are now expanded using (between 1 and 5) SSE2 vector\ninstructions.\n\nLogical shifts by multiples of 8 can be implemented using x86_64's\npslldq/psrldq instruction:\nashl_8:\tpslldq  $1, %xmm0\n        ret\nlshr_32:\n\tpsrldq  $4, %xmm0\n        ret\n\nLogical shifts by greater than 64 can use pslldq/psrldq $8, followed\nby a psllq/psrlq for the remaining bits:\nashl_111:\n        pslldq  $8, %xmm0\n        psllq   $47, %xmm0\n        ret\nlshr_127:\n        psrldq  $8, %xmm0\n        psrlq   $63, %xmm0\n        ret\n\nThe remaining logical shifts make use of the following idiom:\nashl_1:\n        movdqa  %xmm0, %xmm1\n        psllq   $1, %xmm0\n        pslldq  $8, %xmm1\n        psrlq   $63, %xmm1\n        por     %xmm1, %xmm0\n        ret\nlshr_15:\n        movdqa  %xmm0, %xmm1\n        psrlq   $15, %xmm0\n        psrldq  $8, %xmm1\n        psllq   $49, %xmm1\n        por     %xmm1, %xmm0\n        ret\n\nRotates by multiples of 32 can use x86_64's pshufd:\nrotr_32:\n        pshufd  $57, %xmm0, %xmm0\n        ret\nrotr_64:\n        pshufd  $78, %xmm0, %xmm0\n        ret\nrotr_96:\n        pshufd  $147, %xmm0, %xmm0\n        ret\n\nRotates by multiples of 8 (other than multiples of 32) can make\nuse of both pslldq and psrldq, followed by por:\nrotr_8:\n        movdqa  %xmm0, %xmm1\n        psrldq  $1, %xmm0\n        pslldq  $15, %xmm1\n        por     %xmm1, %xmm0\n        ret\nrotr_112:\n        movdqa  %xmm0, %xmm1\n        psrldq  $14, %xmm0\n        pslldq  $2, %xmm1\n        por     %xmm1, %xmm0\n        ret\n\nAnd the remaining rotates use one or two pshufd, followed by a\npsrld/pslld/por sequence:\nrotr_1:\n        movdqa  %xmm0, %xmm1\n        pshufd  $57, %xmm0, %xmm0\n        psrld   $1, %xmm1\n        pslld   $31, %xmm0\n        por     %xmm1, %xmm0\n        ret\nrotr_63:\n        pshufd  $78, %xmm0, %xmm1\n        pshufd  $57, %xmm0, %xmm0\n        pslld   $1, %xmm1\n        psrld   $31, %xmm0\n        por     %xmm1, %xmm0\n        ret\nrotr_111:\n        pshufd  $147, %xmm0, %xmm1\n        pslld   $17, %xmm0\n        psrld   $15, %xmm1\n        por     %xmm1, %xmm0\n        ret\n\nThe new test case, sse2-v1ti-shift.c, is a run-time check to confirm that\nthe results of V1TImode shifts/rotates by constants, exactly match the\nexpected results of TImode operations, for various input test vectors.\n\n2021-10-26  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* config/i386/i386-expand.c (ix86_expand_v1ti_shift): New helper\n\tfunction to expand V1TI mode logical shifts by integer constants.\n\t(ix86_expand_v1ti_rotate): New helper function to expand V1TI\n\tmode rotations by integer constants.\n\t* config/i386/i386-protos.h (ix86_expand_v1ti_shift,\n\tix86_expand_v1ti_rotate): Prototype new functions here.\n\t* config/i386/sse.md (ashlv1ti3, lshrv1ti3, rotlv1ti3, rotrv1ti3):\n\tNew TARGET_SSE2 expanders to implement V1TI shifts and rotations.\n\ngcc/testsuite/ChangeLog\n\t* gcc.target/i386/sse2-v1ti-shift.c: New test case.", "tree": {"sha": "ee8923431f1ed44c3f58d7cf988326d63b517109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee8923431f1ed44c3f58d7cf988326d63b517109"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8b25575570ffde37cc8997af096514b929779d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8b25575570ffde37cc8997af096514b929779d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8b25575570ffde37cc8997af096514b929779d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8b25575570ffde37cc8997af096514b929779d/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e417eea8f3f14131f7370f9bd5dd568611d11df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e417eea8f3f14131f7370f9bd5dd568611d11df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e417eea8f3f14131f7370f9bd5dd568611d11df"}], "stats": {"total": 421, "additions": 421, "deletions": 0}, "files": [{"sha": "4c3800e32001050d355207137c1f488e8bc20aec", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=6b8b25575570ffde37cc8997af096514b929779d", "patch": "@@ -6157,6 +6157,169 @@ ix86_split_lshr (rtx *operands, rtx scratch, machine_mode mode)\n     }\n }\n \n+/* Expand V1TI mode shift (of rtx_code CODE) by constant.  */\n+void ix86_expand_v1ti_shift (enum rtx_code code, rtx operands[])\n+{\n+  HOST_WIDE_INT bits = INTVAL (operands[2]) & 127;\n+  rtx op1 = force_reg (V1TImode, operands[1]);\n+\n+  if (bits == 0)\n+    {\n+      emit_move_insn (operands[0], op1);\n+      return;\n+    }\n+\n+  if ((bits & 7) == 0)\n+    {\n+      rtx tmp = gen_reg_rtx (V1TImode);\n+      if (code == ASHIFT)\n+        emit_insn (gen_sse2_ashlv1ti3 (tmp, op1, GEN_INT (bits)));\n+      else\n+\temit_insn (gen_sse2_lshrv1ti3 (tmp, op1, GEN_INT (bits)));\n+      emit_move_insn (operands[0], tmp);\n+      return;\n+    }\n+\n+  rtx tmp1 = gen_reg_rtx (V1TImode);\n+  if (code == ASHIFT)\n+    emit_insn (gen_sse2_ashlv1ti3 (tmp1, op1, GEN_INT (64)));\n+  else\n+    emit_insn (gen_sse2_lshrv1ti3 (tmp1, op1, GEN_INT (64)));\n+\n+  /* tmp2 is operands[1] shifted by 64, in V2DImode.  */\n+  rtx tmp2 = gen_reg_rtx (V2DImode);\n+  emit_move_insn (tmp2, gen_lowpart (V2DImode, tmp1));\n+\n+  /* tmp3 will be the V2DImode result.  */\n+  rtx tmp3 = gen_reg_rtx (V2DImode);\n+\n+  if (bits > 64)\n+    {\n+      if (code == ASHIFT)\n+\temit_insn (gen_ashlv2di3 (tmp3, tmp2, GEN_INT (bits - 64)));\n+      else\n+\temit_insn (gen_lshrv2di3 (tmp3, tmp2, GEN_INT (bits - 64)));\n+    }\n+  else\n+    {\n+      /* tmp4 is operands[1], in V2DImode.  */\n+      rtx tmp4 = gen_reg_rtx (V2DImode);\n+      emit_move_insn (tmp4, gen_lowpart (V2DImode, op1));\n+\n+      rtx tmp5 = gen_reg_rtx (V2DImode);\n+      if (code == ASHIFT)\n+\temit_insn (gen_ashlv2di3 (tmp5, tmp4, GEN_INT (bits)));\n+      else\n+\temit_insn (gen_lshrv2di3 (tmp5, tmp4, GEN_INT (bits)));\n+\n+      rtx tmp6 = gen_reg_rtx (V2DImode);\n+      if (code == ASHIFT)\n+\temit_insn (gen_lshrv2di3 (tmp6, tmp2, GEN_INT (64 - bits)));\n+      else\n+\temit_insn (gen_ashlv2di3 (tmp6, tmp2, GEN_INT (64 - bits)));\n+\n+      emit_insn (gen_iorv2di3 (tmp3, tmp5, tmp6));\n+    }\n+\n+  /* Convert the result back to V1TImode and store in operands[0].  */\n+  rtx tmp7 = gen_reg_rtx (V1TImode);\n+  emit_move_insn (tmp7, gen_lowpart (V1TImode, tmp3));\n+  emit_move_insn (operands[0], tmp7);\n+}\n+\n+/* Expand V1TI mode rotate (of rtx_code CODE) by constant.  */\n+void ix86_expand_v1ti_rotate (enum rtx_code code, rtx operands[])\n+{\n+  HOST_WIDE_INT bits = INTVAL (operands[2]) & 127;\n+  rtx op1 = force_reg (V1TImode, operands[1]);\n+\n+  if (bits == 0)\n+    {\n+      emit_move_insn (operands[0], op1);\n+      return;\n+    }\n+\n+  if (code == ROTATERT)\n+    bits = 128 - bits;\n+\n+  if ((bits & 31) == 0)\n+    {\n+      rtx tmp1 = gen_reg_rtx (V4SImode);\n+      rtx tmp2 = gen_reg_rtx (V4SImode);\n+      rtx tmp3 = gen_reg_rtx (V1TImode);\n+\n+      emit_move_insn (tmp1, gen_lowpart (V4SImode, op1));\n+      if (bits == 32)\n+\temit_insn (gen_sse2_pshufd (tmp2, tmp1, GEN_INT (0x93)));\n+      else if (bits == 64)\n+\temit_insn (gen_sse2_pshufd (tmp2, tmp1, GEN_INT (0x4e)));\n+      else\n+\temit_insn (gen_sse2_pshufd (tmp2, tmp1, GEN_INT (0x39)));\n+      emit_move_insn (tmp3, gen_lowpart (V1TImode, tmp2));\n+      emit_move_insn (operands[0], tmp3);\n+      return;\n+    }\n+\n+  if ((bits & 7) == 0)\n+    {\n+      rtx tmp1 = gen_reg_rtx (V1TImode);\n+      rtx tmp2 = gen_reg_rtx (V1TImode);\n+      rtx tmp3 = gen_reg_rtx (V1TImode);\n+\n+      emit_insn (gen_sse2_ashlv1ti3 (tmp1, op1, GEN_INT (bits)));\n+      emit_insn (gen_sse2_lshrv1ti3 (tmp2, op1, GEN_INT (128 - bits)));\n+      emit_insn (gen_iorv1ti3 (tmp3, tmp1, tmp2));\n+      emit_move_insn (operands[0], tmp3);\n+      return;\n+    }\n+\n+  rtx op1_v4si = gen_reg_rtx (V4SImode);\n+  emit_move_insn (op1_v4si, gen_lowpart (V4SImode, op1));\n+\n+  rtx lobits;\n+  rtx hibits;\n+\n+  switch (bits >> 5)\n+    {\n+    case 0:\n+      lobits = op1_v4si;\n+      hibits = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_sse2_pshufd (hibits, op1_v4si, GEN_INT (0x93)));\n+      break;\n+\n+    case 1:\n+      lobits = gen_reg_rtx (V4SImode);\n+      hibits = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_sse2_pshufd (lobits, op1_v4si, GEN_INT (0x93)));\n+      emit_insn (gen_sse2_pshufd (hibits, op1_v4si, GEN_INT (0x4e)));\n+      break;\n+\n+    case 2:\n+      lobits = gen_reg_rtx (V4SImode);\n+      hibits = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_sse2_pshufd (lobits, op1_v4si, GEN_INT (0x4e)));\n+      emit_insn (gen_sse2_pshufd (hibits, op1_v4si, GEN_INT (0x39)));\n+      break;\n+\n+    default:\n+      lobits = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_sse2_pshufd (lobits, op1_v4si, GEN_INT (0x39)));\n+      hibits = op1_v4si;\n+      break;\n+    }\n+\n+  rtx tmp1 = gen_reg_rtx (V4SImode);\n+  rtx tmp2 = gen_reg_rtx (V4SImode);\n+  rtx tmp3 = gen_reg_rtx (V4SImode);\n+  rtx tmp4 = gen_reg_rtx (V1TImode);\n+\n+  emit_insn (gen_ashlv4si3 (tmp1, lobits, GEN_INT (bits & 31)));\n+  emit_insn (gen_lshrv4si3 (tmp2, hibits, GEN_INT (32 - (bits & 31))));\n+  emit_insn (gen_iorv4si3 (tmp3, tmp1, tmp2));\n+  emit_move_insn (tmp4, gen_lowpart (V1TImode, tmp3));\n+  emit_move_insn (operands[0], tmp4);\n+}\n+\n /* Return mode for the memcpy/memset loop counter.  Prefer SImode over\n    DImode for constant loop counts.  */\n "}, {"sha": "9918a28157b9e93e81e0598d78b85b5dd78a05d1", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=6b8b25575570ffde37cc8997af096514b929779d", "patch": "@@ -159,6 +159,8 @@ extern void ix86_split_long_move (rtx[]);\n extern void ix86_split_ashl (rtx *, rtx, machine_mode);\n extern void ix86_split_ashr (rtx *, rtx, machine_mode);\n extern void ix86_split_lshr (rtx *, rtx, machine_mode);\n+extern void ix86_expand_v1ti_shift (enum rtx_code, rtx[]);\n+extern void ix86_expand_v1ti_rotate (enum rtx_code, rtx[]);\n extern rtx ix86_find_base_term (rtx);\n extern bool ix86_check_movabs (rtx, int);\n extern bool ix86_check_no_addr_space (rtx);"}, {"sha": "bdc606747c8e624e8ab86859eb4856c629e9b9cb", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=6b8b25575570ffde37cc8997af096514b929779d", "patch": "@@ -15075,6 +15075,50 @@\n   operands[4] = gen_lowpart (<MODE>mode, operands[3]);\n })\n \n+(define_expand \"ashlv1ti3\"\n+  [(set (match_operand:V1TI 0 \"register_operand\")\n+\t(ashift:V1TI\n+\t (match_operand:V1TI 1 \"register_operand\")\n+\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_v1ti_shift (ASHIFT, operands);\n+  DONE;\n+})\n+\n+(define_expand \"lshrv1ti3\"\n+  [(set (match_operand:V1TI 0 \"register_operand\")\n+\t(lshiftrt:V1TI\n+\t (match_operand:V1TI 1 \"register_operand\")\n+\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_v1ti_shift (LSHIFTRT, operands);\n+  DONE;\n+})\n+\n+(define_expand \"rotlv1ti3\"\n+  [(set (match_operand:V1TI 0 \"register_operand\")\n+\t(rotate:V1TI\n+\t (match_operand:V1TI 1 \"register_operand\")\n+\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_v1ti_rotate (ROTATE, operands);\n+  DONE;\n+})\n+\n+(define_expand \"rotrv1ti3\"\n+  [(set (match_operand:V1TI 0 \"register_operand\")\n+\t(rotatert:V1TI\n+\t (match_operand:V1TI 1 \"register_operand\")\n+\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_v1ti_rotate (ROTATERT, operands);\n+  DONE;\n+})\n+\n (define_insn \"avx512bw_<insn><mode>3\"\n   [(set (match_operand:VIMAX_AVX512VL 0 \"register_operand\" \"=v\")\n \t(any_lshift:VIMAX_AVX512VL"}, {"sha": "dbae4185dceb82f775a6fd9cbcf1a36940032273", "filename": "gcc/testsuite/gcc.target/i386/sse2-v1ti-shift.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-v1ti-shift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8b25575570ffde37cc8997af096514b929779d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-v1ti-shift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-v1ti-shift.c?ref=6b8b25575570ffde37cc8997af096514b929779d", "patch": "@@ -0,0 +1,212 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-options \"-O2 -msse2\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+typedef unsigned __int128 v1ti __attribute__ ((__vector_size__ (16)));\n+typedef unsigned __int128 ti;\n+\n+ti ashl(ti x, unsigned int i) { return x << i; }\n+ti lshr(ti x, unsigned int i) { return x >> i; }\n+ti rotr(ti x, unsigned int i) { return (x >> i) | (x << (128-i)); }\n+\n+v1ti ashl_1(v1ti x) { return x << 1; }\n+v1ti ashl_2(v1ti x) { return x << 2; }\n+v1ti ashl_7(v1ti x) { return x << 7; }\n+v1ti ashl_8(v1ti x) { return x << 8; }\n+v1ti ashl_9(v1ti x) { return x << 9; }\n+v1ti ashl_15(v1ti x) { return x << 15; }\n+v1ti ashl_16(v1ti x) { return x << 16; }\n+v1ti ashl_17(v1ti x) { return x << 17; }\n+v1ti ashl_31(v1ti x) { return x << 31; }\n+v1ti ashl_32(v1ti x) { return x << 32; }\n+v1ti ashl_33(v1ti x) { return x << 33; }\n+v1ti ashl_63(v1ti x) { return x << 63; }\n+v1ti ashl_64(v1ti x) { return x << 64; }\n+v1ti ashl_65(v1ti x) { return x << 65; }\n+v1ti ashl_72(v1ti x) { return x << 72; }\n+v1ti ashl_95(v1ti x) { return x << 95; }\n+v1ti ashl_96(v1ti x) { return x << 96; }\n+v1ti ashl_97(v1ti x) { return x << 97; }\n+v1ti ashl_111(v1ti x) { return x << 111; }\n+v1ti ashl_112(v1ti x) { return x << 112; }\n+v1ti ashl_113(v1ti x) { return x << 113; }\n+v1ti ashl_119(v1ti x) { return x << 119; }\n+v1ti ashl_120(v1ti x) { return x << 120; }\n+v1ti ashl_121(v1ti x) { return x << 121; }\n+v1ti ashl_126(v1ti x) { return x << 126; }\n+v1ti ashl_127(v1ti x) { return x << 127; }\n+\n+v1ti lshr_1(v1ti x) { return x >> 1; }\n+v1ti lshr_2(v1ti x) { return x >> 2; }\n+v1ti lshr_7(v1ti x) { return x >> 7; }\n+v1ti lshr_8(v1ti x) { return x >> 8; }\n+v1ti lshr_9(v1ti x) { return x >> 9; }\n+v1ti lshr_15(v1ti x) { return x >> 15; }\n+v1ti lshr_16(v1ti x) { return x >> 16; }\n+v1ti lshr_17(v1ti x) { return x >> 17; }\n+v1ti lshr_31(v1ti x) { return x >> 31; }\n+v1ti lshr_32(v1ti x) { return x >> 32; }\n+v1ti lshr_33(v1ti x) { return x >> 33; }\n+v1ti lshr_63(v1ti x) { return x >> 63; }\n+v1ti lshr_64(v1ti x) { return x >> 64; }\n+v1ti lshr_65(v1ti x) { return x >> 65; }\n+v1ti lshr_72(v1ti x) { return x >> 72; }\n+v1ti lshr_95(v1ti x) { return x >> 95; }\n+v1ti lshr_96(v1ti x) { return x >> 96; }\n+v1ti lshr_97(v1ti x) { return x >> 97; }\n+v1ti lshr_111(v1ti x) { return x >> 111; }\n+v1ti lshr_112(v1ti x) { return x >> 112; }\n+v1ti lshr_113(v1ti x) { return x >> 113; }\n+v1ti lshr_119(v1ti x) { return x >> 119; }\n+v1ti lshr_120(v1ti x) { return x >> 120; }\n+v1ti lshr_121(v1ti x) { return x >> 121; }\n+v1ti lshr_126(v1ti x) { return x >> 126; }\n+v1ti lshr_127(v1ti x) { return x >> 127; }\n+\n+v1ti rotr_1(v1ti x) { return (x >> 1) | (x << 127); }\n+v1ti rotr_2(v1ti x) { return (x >> 2) | (x << 126); }\n+v1ti rotr_7(v1ti x) { return (x >> 7) | (x << 121); }\n+v1ti rotr_8(v1ti x) { return (x >> 8) | (x << 120); }\n+v1ti rotr_9(v1ti x) { return (x >> 9) | (x << 119); }\n+v1ti rotr_15(v1ti x) { return (x >> 15) | (x << 113); }\n+v1ti rotr_16(v1ti x) { return (x >> 16) | (x << 112); }\n+v1ti rotr_17(v1ti x) { return (x >> 17) | (x << 111); }\n+v1ti rotr_31(v1ti x) { return (x >> 31) | (x << 97); }\n+v1ti rotr_32(v1ti x) { return (x >> 32) | (x << 96); }\n+v1ti rotr_33(v1ti x) { return (x >> 33) | (x << 95); }\n+v1ti rotr_63(v1ti x) { return (x >> 63) | (x << 65); }\n+v1ti rotr_64(v1ti x) { return (x >> 64) | (x << 64); }\n+v1ti rotr_65(v1ti x) { return (x >> 65) | (x << 63); }\n+v1ti rotr_72(v1ti x) { return (x >> 72) | (x << 56); }\n+v1ti rotr_95(v1ti x) { return (x >> 95) | (x << 33); }\n+v1ti rotr_96(v1ti x) { return (x >> 96) | (x << 32); }\n+v1ti rotr_97(v1ti x) { return (x >> 97) | (x << 31); }\n+v1ti rotr_111(v1ti x) { return (x >> 111) | (x << 17); }\n+v1ti rotr_112(v1ti x) { return (x >> 112) | (x << 16); }\n+v1ti rotr_113(v1ti x) { return (x >> 113) | (x << 15); }\n+v1ti rotr_119(v1ti x) { return (x >> 119) | (x << 9); }\n+v1ti rotr_120(v1ti x) { return (x >> 120) | (x << 8); }\n+v1ti rotr_121(v1ti x) { return (x >> 121) | (x << 7); }\n+v1ti rotr_126(v1ti x) { return (x >> 126) | (x << 2); }\n+v1ti rotr_127(v1ti x) { return (x >> 127) | (x << 1); }\n+\n+\n+typedef v1ti (*fun)(v1ti);\n+\n+struct {\n+  unsigned int i;\n+  fun ashl;\n+  fun lshr;\n+  fun rotr;\n+} table[26] = {\n+  {   1, ashl_1,   lshr_1,   rotr_1   },\n+  {   2, ashl_2,   lshr_2,   rotr_2   },\n+  {   7, ashl_7,   lshr_7,   rotr_7   },\n+  {   8, ashl_8,   lshr_8,   rotr_8   },\n+  {   9, ashl_9,   lshr_9,   rotr_9   },\n+  {  15, ashl_15,  lshr_15,  rotr_15  },\n+  {  16, ashl_16,  lshr_16,  rotr_16  },\n+  {  17, ashl_17,  lshr_17,  rotr_17  },\n+  {  31, ashl_31,  lshr_31,  rotr_31  },\n+  {  32, ashl_32,  lshr_32,  rotr_32  },\n+  {  33, ashl_33,  lshr_33,  rotr_33  },\n+  {  63, ashl_63,  lshr_63,  rotr_63  },\n+  {  64, ashl_64,  lshr_64,  rotr_64  },\n+  {  65, ashl_65,  lshr_65,  rotr_65  },\n+  {  72, ashl_72,  lshr_72,  rotr_72  },\n+  {  95, ashl_95,  lshr_95,  rotr_95  },\n+  {  96, ashl_96,  lshr_96,  rotr_96  },\n+  {  97, ashl_97,  lshr_97,  rotr_97  },\n+  { 111, ashl_111, lshr_111, rotr_111 },\n+  { 112, ashl_112, lshr_112, rotr_112 },\n+  { 113, ashl_113, lshr_113, rotr_113 },\n+  { 119, ashl_119, lshr_119, rotr_119 },\n+  { 120, ashl_120, lshr_120, rotr_120 },\n+  { 121, ashl_121, lshr_121, rotr_121 },\n+  { 126, ashl_126, lshr_126, rotr_126 },\n+  { 127, ashl_127, lshr_127, rotr_127 }\n+};\n+\n+void test(ti x)\n+{\n+  unsigned int i;\n+  v1ti t = (v1ti)x;\n+\n+  for (i=0; i<(sizeof(table)/sizeof(table[0])); i++) {\n+    if ((ti)(*table[i].ashl)(t) != ashl(x,table[i].i))\n+      __builtin_abort();\n+    if ((ti)(*table[i].lshr)(t) != lshr(x,table[i].i))\n+      __builtin_abort();\n+    if ((ti)(*table[i].rotr)(t) != rotr(x,table[i].i))\n+      __builtin_abort();\n+  }\n+}\n+\n+int main()\n+{\n+  ti x;\n+\n+  x = ((ti)0x0011223344556677ull)<<64 | 0x8899aabbccddeeffull;\n+  test(x);\n+  x = ((ti)0xffeeddccbbaa9988ull)<<64 | 0x7766554433221100ull;\n+  test(x);\n+  x = ((ti)0x0123456789abcdefull)<<64 | 0x0123456789abcdefull;\n+  test(x);\n+  x = ((ti)0xfedcba9876543210ull)<<64 | 0xfedcba9876543210ull;\n+  test(x);\n+  x = ((ti)0x0123456789abcdefull)<<64 | 0xfedcba9876543210ull;\n+  test(x);\n+  x = ((ti)0xfedcba9876543210ull)<<64 | 0x0123456789abcdefull;\n+  test(x);\n+  x = 0;\n+  test(x);\n+  x = 0xffffffffffffffffull;\n+  test(x);\n+  x = ((ti)0xffffffffffffffffull)<<64;\n+  test(x);\n+  x = ((ti)0xffffffffffffffffull)<<64 | 0xffffffffffffffffull;\n+  test(x);\n+  x = ((ti)0x5a5a5a5a5a5a5a5aull)<<64 | 0x5a5a5a5a5a5a5a5aull;\n+  test(x);\n+  x = ((ti)0xa5a5a5a5a5a5a5a5ull)<<64 | 0xa5a5a5a5a5a5a5a5ull;\n+  test(x);\n+  x = 0xffull;\n+  test(x);\n+  x = 0xff00ull;\n+  test(x);\n+  x = 0xff0000ull;\n+  test(x);\n+  x = 0xff000000ull;\n+  test(x);\n+  x = 0xff00000000ull;\n+  test(x);\n+  x = 0xff0000000000ull;\n+  test(x);\n+  x = 0xff000000000000ull;\n+  test(x);\n+  x = 0xff00000000000000ull;\n+  test(x);\n+  x = ((ti)0xffull)<<64;\n+  test(x);\n+  x = ((ti)0xff00ull)<<64;\n+  test(x);\n+  x = ((ti)0xff0000ull)<<64;\n+  test(x);\n+  x = ((ti)0xff000000ull)<<64;\n+  test(x);\n+  x = ((ti)0xff00000000ull)<<64;\n+  test(x);\n+  x = ((ti)0xff0000000000ull)<<64;\n+  test(x);\n+  x = ((ti)0xff000000000000ull)<<64;\n+  test(x);\n+  x = ((ti)0xff00000000000000ull)<<64;\n+  test(x);\n+  x = 0xdeadbeefcafebabeull;\n+  test(x);\n+  x = ((ti)0xdeadbeefcafebabeull)<<64;\n+  test(x);\n+\n+  return 0;\n+}\n+"}]}