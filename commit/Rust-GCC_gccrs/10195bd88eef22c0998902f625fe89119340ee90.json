{"sha": "10195bd88eef22c0998902f625fe89119340ee90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxOTViZDg4ZWVmMjJjMDk5ODkwMmY2MjVmZTg5MTE5MzQwZWU5MA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-04-25T11:43:49Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "1999-04-25T11:43:49Z"}, "message": "stupid.c (stupid_mark_refs): Generate a REG_UNUSED note for a register which is clobbered even if...\n\n\t* stupid.c (stupid_mark_refs): Generate a REG_UNUSED note\n\tfor a register which is clobbered even if the register\n\twas used by an earlier instruction.\n\t* i386.md (fix_truncsfdi2, fix_truncdfdi2,\n\tfix_truncxfdi2): Don't bother with the gen_reg_RTX.\n\t(fix_truncsfsi2, fix_truncsfdi2, fix_truncdfsi2,\n\tfix_truncdfdi2, fix_truncxfsi2, fix_truncxfdi2): Update\n\toperand constraints and modes.\n\t* i386.c (output_fix_trunc): Use HImode register to avoid\n\tmemory stalls.  Call output_move_double instead of output_to_reg.\n\t(output_to_reg): Remove.\n\t* i386.h: Likewise.\n\t* i386.md (negsf2, negdf2, negxf2): Set the type\n\tattribute to fpop.\n\nFrom-SVN: r26621", "tree": {"sha": "7ca441f8bb80a8971078183607b030c4dd82e538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ca441f8bb80a8971078183607b030c4dd82e538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10195bd88eef22c0998902f625fe89119340ee90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10195bd88eef22c0998902f625fe89119340ee90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10195bd88eef22c0998902f625fe89119340ee90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10195bd88eef22c0998902f625fe89119340ee90/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f41eba1d05d43c2b01d9be1a02124d5849a0c87e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41eba1d05d43c2b01d9be1a02124d5849a0c87e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f41eba1d05d43c2b01d9be1a02124d5849a0c87e"}], "stats": {"total": 421, "additions": 178, "deletions": 243}, "files": [{"sha": "e153d1d8243bdf35e10899940a3acfcadee5ae43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10195bd88eef22c0998902f625fe89119340ee90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10195bd88eef22c0998902f625fe89119340ee90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10195bd88eef22c0998902f625fe89119340ee90", "patch": "@@ -1,3 +1,22 @@\n+Sun Apr 25 14:38:10 EDT 1999  John Wehle  (john@feith.com)\n+\n+\t* stupid.c (stupid_mark_refs): Generate a REG_UNUSED note\n+\tfor a register which is clobbered even if the register\n+\twas used by an earlier instruction.\n+\n+\t* i386.md (fix_truncsfdi2, fix_truncdfdi2,\n+\tfix_truncxfdi2): Don't bother with the gen_reg_RTX.\n+\t(fix_truncsfsi2, fix_truncsfdi2, fix_truncdfsi2,\n+\tfix_truncdfdi2, fix_truncxfsi2, fix_truncxfdi2): Update\n+\toperand constraints and modes.\n+\t* i386.c (output_fix_trunc): Use HImode register to avoid\n+\tmemory stalls.  Call output_move_double instead of output_to_reg.\n+\t(output_to_reg): Remove.\n+\t* i386.h: Likewise.\n+\n+\t* i386.md (negsf2, negdf2, negxf2): Set the type\n+\tattribute to fpop.\n+\n Sat Apr 24 23:15:57 1999  Donn Terry (donn@interix.com)\n \n \t* alpha.md (call_value_nt): Correct subscripts."}, {"sha": "e3c2f02d3f21396112766ecb60f836e558af772d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 25, "deletions": 123, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=10195bd88eef22c0998902f625fe89119340ee90", "patch": "@@ -871,102 +871,6 @@ function_arg_partial_nregs (cum, mode, type, named)\n   return 0;\n }\n \f\n-/* Output an insn to pop an value from the 387 top-of-stack to 386\n-   register DEST. The 387 register stack is popped if DIES is true.  If\n-   the mode of DEST is an integer mode, a `fist' integer store is done,\n-   otherwise a `fst' float store is done. */\n-\n-void\n-output_to_reg (dest, dies, scratch_mem)\n-     rtx dest;\n-     int dies;\n-     rtx scratch_mem;\n-{\n-  rtx xops[4];\n-  int size = GET_MODE_SIZE (GET_MODE (dest));\n-\n-  if (! scratch_mem)\n-    xops[0] = AT_SP (Pmode);\n-  else\n-    xops[0] = scratch_mem;\n-\n-  xops[1] = stack_pointer_rtx;\n-  xops[2] = GEN_INT (size);\n-  xops[3] = dest;\n-\n-  if (! scratch_mem)\n-    output_asm_insn (AS2 (sub%L1,%2,%1), xops);\n-\n-  if (GET_MODE_CLASS (GET_MODE (dest)) == MODE_INT)\n-    {\n-      if (dies)\n-\toutput_asm_insn (AS1 (fistp%z3,%y0), xops);\n-      else if (GET_MODE (xops[3]) == DImode && ! dies)\n-\t{\n-\t  /* There is no DImode version of this without a stack pop, so\n-\t     we must emulate it.  It doesn't matter much what the second\n-\t     instruction is, because the value being pushed on the FP stack\n-\t     is not used except for the following stack popping store.\n-\t     This case can only happen without optimization, so it doesn't\n-\t     matter that it is inefficient.  */\n-\t  output_asm_insn (AS1 (fistp%z3,%0), xops);\n-\t  output_asm_insn (AS1 (fild%z3,%0), xops);\n-\t}\n-      else\n-\toutput_asm_insn (AS1 (fist%z3,%y0), xops);\n-    }\n-\n-  else if (GET_MODE_CLASS (GET_MODE (dest)) == MODE_FLOAT)\n-    {\n-      if (dies)\n-\toutput_asm_insn (AS1 (fstp%z3,%y0), xops);\n-      else\n-\t{\n-\t  if (GET_MODE (dest) == XFmode)\n-\t    {\n-\t      output_asm_insn (AS1 (fstp%z3,%y0), xops);\n-\t      output_asm_insn (AS1 (fld%z3,%y0), xops);\n-\t    }\n-\t  else\n-\t    output_asm_insn (AS1 (fst%z3,%y0), xops);\n-\t}\n-    }\n-\n-  else\n-    abort ();\n-\n-  if (! scratch_mem)\n-    output_asm_insn (AS1 (pop%L0,%0), &dest);\n-  else\n-    output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n-\n-\n-  if (size > UNITS_PER_WORD)\n-    {\n-      dest = gen_rtx_REG (SImode, REGNO (dest) + 1);\n-      if (! scratch_mem)\n-\toutput_asm_insn (AS1 (pop%L0,%0), &dest);\n-      else\n-\t{\n-\t  xops[0] = adj_offsettable_operand (xops[0], 4);\n-\t  xops[3] = dest;\n-\t  output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n-\t}\n-\n-      if (size > 2 * UNITS_PER_WORD)\n-\t{\n-\t  dest = gen_rtx_REG (SImode, REGNO (dest) + 1);\n-\t  if (! scratch_mem)\n-\t    output_asm_insn (AS1 (pop%L0,%0), &dest);\n-\t  else\n-\t    {\n-\t      xops[0] = adj_offsettable_operand (xops[0], 4);\n-\t      output_asm_insn (AS2 (mov%L0,%0,%3), xops);\n-\t    }\n-\t}\n-    }\n-}\n-\f\n char *\n singlemove_string (operands)\n      rtx *operands;\n@@ -4087,10 +3991,10 @@ output_387_binary_op (insn, operands)\n }\n \f\n /* Output code for INSN to convert a float to a signed int.  OPERANDS\n-   are the insn operands.  The output may be SFmode or DFmode and the\n-   input operand may be SImode or DImode.  As a special case, make sure\n-   that the 387 stack top dies if the output mode is DImode, because the\n-   hardware requires this.  */\n+   are the insn operands.  The input may be SFmode, DFmode, or XFmode\n+   and the output operand may be SImode or DImode.  As a special case,\n+   make sure that the 387 stack top dies if the output mode is DImode,\n+   because the hardware requires this.  */\n \n char *\n output_fix_trunc (insn, operands)\n@@ -4103,38 +4007,36 @@ output_fix_trunc (insn, operands)\n   if (! STACK_TOP_P (operands[1]))\n     abort ();\n \n-  xops[0] = GEN_INT (12);\n-  xops[1] = operands[4];\n+  if (GET_MODE (operands[0]) == DImode && ! stack_top_dies)\n+    abort ();\n+\n+  xops[0] = GEN_INT (0x0c00);\n+  xops[1] = operands[5];\n \n   output_asm_insn (AS1 (fnstc%W2,%2), operands);\n-  output_asm_insn (AS2 (mov%L2,%2,%4), operands);\n-  output_asm_insn (AS2 (mov%B1,%0,%h1), xops);\n-  output_asm_insn (AS2 (mov%L4,%4,%3), operands);\n+  output_asm_insn (AS2 (mov%W5,%2,%w5), operands);\n+  output_asm_insn (AS2 (or%W1,%0,%w1), xops);\n+  output_asm_insn (AS2 (mov%W3,%w5,%3), operands);\n   output_asm_insn (AS1 (fldc%W3,%3), operands);\n \n-  if (NON_STACK_REG_P (operands[0]))\n-    output_to_reg (operands[0], stack_top_dies, operands[3]);\n+  xops[0] = NON_STACK_REG_P (operands[0]) ? operands[4] : operands[0];\n \n-  else if (GET_CODE (operands[0]) == MEM)\n+  if (stack_top_dies)\n+    output_asm_insn (AS1 (fistp%z0,%y0), xops);\n+  else\n+    output_asm_insn (AS1 (fist%z0,%y0), xops);\n+\n+  if (NON_STACK_REG_P (operands[0]))\n     {\n-      if (stack_top_dies)\n-\toutput_asm_insn (AS1 (fistp%z0,%0), operands);\n-      else if (GET_MODE (operands[0]) == DImode && ! stack_top_dies)\n+      if (GET_MODE (operands[0]) == SImode)\n+\toutput_asm_insn (AS2 (mov%L0,%4,%0), operands);\n+      else\n \t{\n-\t  /* There is no DImode version of this without a stack pop, so\n-\t     we must emulate it.  It doesn't matter much what the second\n-\t     instruction is, because the value being pushed on the FP stack\n-\t     is not used except for the following stack popping store.\n-\t     This case can only happen without optimization, so it doesn't\n-\t     matter that it is inefficient.  */\n-\t  output_asm_insn (AS1 (fistp%z0,%0), operands);\n-\t  output_asm_insn (AS1 (fild%z0,%0), operands);\n+\t  xops[0] = operands[0];\n+\t  xops[1] = operands[4];\n+\t  output_asm_insn (output_move_double (xops), xops);\n \t}\n-      else\n-\toutput_asm_insn (AS1 (fist%z0,%0), operands);\n     }\n-  else\n-    abort ();\n \n   return AS1 (fldc%W2,%2);\n }"}, {"sha": "5e27fd800349053d44c37031b6871e2c386684a7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=10195bd88eef22c0998902f625fe89119340ee90", "patch": "@@ -2713,7 +2713,6 @@ extern void function_arg_advance ();\n extern struct rtx_def *function_arg ();\n extern int function_arg_partial_nregs ();\n extern char *output_strlen_unroll ();\n-extern void output_to_reg ();\n extern char *singlemove_string ();\n extern char *output_move_double ();\n extern char *output_move_pushmem ();"}, {"sha": "fb3e1b2ad0b03cd852610f846aea42cf43d85a3b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 123, "deletions": 110, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=10195bd88eef22c0998902f625fe89119340ee90", "patch": "@@ -2693,164 +2693,172 @@\n }\"\n   [(set_attr \"type\" \"fpop\")])\n \f\n-;; Signed conversion to DImode.\n+;; Conversions between floating point and fix point.\n \n-(define_expand \"fix_truncxfdi2\"\n-  [(set (match_dup 2)\n-\t(match_operand:XF 1 \"register_operand\" \"\"))\n-   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:XF (match_dup 2))))\n+(define_expand \"fix_truncsfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"\"))))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n+\t      (clobber (match_scratch:HI 5 \"\"))])]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n-  operands[2] = gen_reg_rtx (XFmode);\n-  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[4] = (rtx) assign_386_stack_local (DImode, 1);\n+  operands[2] = (rtx) assign_386_stack_local (HImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (HImode, 1);\n+  operands[4] = (rtx) assign_386_stack_local (SImode, 0);\n }\")\n \n-(define_expand \"fix_truncdfdi2\"\n-  [(set (match_dup 2)\n-\t(match_operand:DF 1 \"register_operand\" \"\"))\n-   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:DF (match_dup 2))))\n-\t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,!r\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"f,f\"))))\n+   (clobber (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:SI 4 \"memory_operand\" \"m,m\"))\n+   (clobber (match_scratch:HI 5 \"=&r,&r\"))]\n   \"TARGET_80387\"\n-  \"\n-{\n-  operands[1] = copy_to_mode_reg (DFmode, operands[1]);\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[4] = (rtx) assign_386_stack_local (DImode, 1);\n-}\")\n+  \"* return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fpop\")])\n \n (define_expand \"fix_truncsfdi2\"\n-  [(set (match_dup 2)\n-\t(match_operand:SF 1 \"register_operand\" \"\"))\n-   (parallel [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t\t   (fix:DI (fix:SF (match_dup 2))))\n+  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"\"))))\n+\t      (clobber (match_dup 1))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n \t      (clobber (match_dup 4))\n-\t      (clobber (match_scratch:SI 5 \"\"))])]\n+\t      (clobber (match_scratch:HI 5 \"\"))])]\n   \"TARGET_80387\"\n   \"\n {\n   operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n-  operands[2] = gen_reg_rtx (SFmode);\n-  operands[3] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[4] = (rtx) assign_386_stack_local (DImode, 1);\n+  operands[2] = (rtx) assign_386_stack_local (HImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (HImode, 1);\n+  operands[4] = (rtx) assign_386_stack_local (DImode, 0);\n }\")\n \n-;; These match a signed conversion of either DFmode or SFmode to DImode.\n-\n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(fix:DI (fix:XF (match_operand:XF 1 \"register_operand\" \"+f\"))))\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,!r\")\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f,f\"))))\n    (clobber (match_dup 1))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 4 \"=&q\"))]\n+   (clobber (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:DI 4 \"memory_operand\" \"m,o\"))\n+   (clobber (match_scratch:HI 5 \"=&r,&r\"))]\n   \"TARGET_80387\"\n-  \"* return output_fix_trunc (insn, operands);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"+f\"))))\n-   (clobber (match_dup 1))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 4 \"=&q\"))]\n-  \"TARGET_80387\"\n-  \"* return output_fix_trunc (insn, operands);\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"+f\"))))\n-   (clobber (match_dup 1))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 4 \"=&q\"))]\n-  \"TARGET_80387\"\n-  \"* return output_fix_trunc (insn, operands);\")\n-\n-;; Signed MODE_FLOAT conversion to SImode.\n+  \"* return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fpop\")])\n \n-(define_expand \"fix_truncxfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t   (fix:SI\n-\t\t    (fix:XF (match_operand:XF 1 \"register_operand\" \"\"))))\n+(define_expand \"fix_truncdfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"\"))))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n-\t      (clobber (match_scratch:SI 4 \"\"))])]\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_scratch:HI 5 \"\"))])]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[2] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[3] = (rtx) assign_386_stack_local (DImode, 1);\n+  operands[2] = (rtx) assign_386_stack_local (HImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (HImode, 1);\n+  operands[4] = (rtx) assign_386_stack_local (SImode, 0);\n }\")\n \n-(define_expand \"fix_truncdfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t   (fix:SI\n-\t\t    (fix:DF (match_operand:DF 1 \"register_operand\" \"\"))))\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,!r\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f,f\"))))\n+   (clobber (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:SI 4 \"memory_operand\" \"m,m\"))\n+   (clobber (match_scratch:HI 5 \"=&r,&r\"))]\n+  \"TARGET_80387\"\n+  \"* return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_expand \"fix_truncdfdi2\"\n+  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"\"))))\n+\t      (clobber (match_dup 1))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n-\t      (clobber (match_scratch:SI 4 \"\"))])]\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_scratch:HI 5 \"\"))])]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[2] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[3] = (rtx) assign_386_stack_local (DImode, 1);\n+  operands[1] = copy_to_mode_reg (DFmode, operands[1]);\n+  operands[2] = (rtx) assign_386_stack_local (HImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (HImode, 1);\n+  operands[4] = (rtx) assign_386_stack_local (DImode, 0);\n }\")\n \n-(define_expand \"fix_truncsfsi2\"\n-  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t   (fix:SI\n-\t\t    (fix:SF (match_operand:SF 1 \"register_operand\" \"\"))))\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,!r\")\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f,f\"))))\n+   (clobber (match_dup 1))\n+   (clobber (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:DI 4 \"memory_operand\" \"m,o\"))\n+   (clobber (match_scratch:HI 5 \"=&r,&r\"))]\n+  \"TARGET_80387\"\n+  \"* return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fpop\")])\n+\n+(define_expand \"fix_truncxfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:SI (fix:XF (match_operand:XF 1 \"register_operand\" \"\"))))\n \t      (clobber (match_dup 2))\n \t      (clobber (match_dup 3))\n-\t      (clobber (match_scratch:SI 4 \"\"))])]\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_scratch:HI 5 \"\"))])]\n   \"TARGET_80387\"\n   \"\n {\n-  operands[2] = (rtx) assign_386_stack_local (SImode, 0);\n-  operands[3] = (rtx) assign_386_stack_local (DImode, 1);\n+  operands[2] = (rtx) assign_386_stack_local (HImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (HImode, 1);\n+  operands[4] = (rtx) assign_386_stack_local (SImode, 0);\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(fix:SI (fix:XF (match_operand:XF 1 \"register_operand\" \"f\"))))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 4 \"=&q\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,!r\")\n+\t(fix:SI (fix:XF (match_operand:XF 1 \"register_operand\" \"f,f\"))))\n+   (clobber (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:SI 4 \"memory_operand\" \"m,m\"))\n+   (clobber (match_scratch:HI 5 \"=&r,&r\"))]\n   \"TARGET_80387\"\n-  \"* return output_fix_trunc (insn, operands);\")\n+  \"* return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fpop\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 4 \"=&q\"))]\n+(define_expand \"fix_truncxfdi2\"\n+  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (fix:DI (fix:XF (match_operand:XF 1 \"register_operand\" \"\"))))\n+\t      (clobber (match_dup 1))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_scratch:HI 5 \"\"))])]\n   \"TARGET_80387\"\n-  \"* return output_fix_trunc (insn, operands);\")\n+  \"\n+{\n+  operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n+  operands[2] = (rtx) assign_386_stack_local (HImode, 0);\n+  operands[3] = (rtx) assign_386_stack_local (HImode, 1);\n+  operands[4] = (rtx) assign_386_stack_local (DImode, 0);\n+}\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:DI 3 \"memory_operand\" \"m\"))\n-   (clobber (match_scratch:SI 4 \"=&q\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,!r\")\n+\t(fix:DI (fix:XF (match_operand:XF 1 \"register_operand\" \"f,f\"))))\n+   (clobber (match_dup 1))\n+   (clobber (match_operand:HI 2 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:HI 3 \"memory_operand\" \"m,m\"))\n+   (clobber (match_operand:DI 4 \"memory_operand\" \"m,o\"))\n+   (clobber (match_scratch:HI 5 \"=&r,&r\"))]\n   \"TARGET_80387\"\n-  \"* return output_fix_trunc (insn, operands);\")\n+  \"* return output_fix_trunc (insn, operands);\"\n+  [(set_attr \"type\" \"fpop\")])\n \f\n ;; Conversion between fixed point and floating point.\n \n@@ -4880,31 +4888,36 @@ byte_xor_operation:\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n   \"TARGET_80387\"\n-  \"fchs\")\n+  \"fchs\"\n+  [(set_attr \"type\" \"fpop\")])\n \n (define_insn \"negdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n   \"TARGET_80387\"\n-  \"fchs\")\n+  \"fchs\"\n+  [(set_attr \"type\" \"fpop\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(neg:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"0\"))))]\n   \"TARGET_80387\"\n-  \"fchs\")\n+  \"fchs\"\n+  [(set_attr \"type\" \"fpop\")])\n \n (define_insn \"negxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(neg:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n   \"TARGET_80387\"\n-  \"fchs\")\n+  \"fchs\"\n+  [(set_attr \"type\" \"fpop\")])\n \n (define_insn \"\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(neg:XF (float_extend:XF (match_operand:DF 1 \"register_operand\" \"0\"))))]\n   \"TARGET_80387\"\n-  \"fchs\")\n+  \"fchs\"\n+  [(set_attr \"type\" \"fpop\")])\n \f\n ;; Absolute value instructions\n "}, {"sha": "b2cd170c8c348705998ed4ba11036783f553f16d", "filename": "gcc/stupid.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10195bd88eef22c0998902f625fe89119340ee90/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=10195bd88eef22c0998902f625fe89119340ee90", "patch": "@@ -682,16 +682,18 @@ stupid_mark_refs (x, chain)\n \t      if (last_setjmp_suid < reg_where_dead[regno])\n \t\tregs_crosses_setjmp[regno] = 1;\n \n-\t      /* If this register is only used in this insn and is only\n-\t\t set, mark it unused.  We have to do this even when not \n-\t\t optimizing so that MD patterns which count on this\n-\t\t behavior (e.g., it not causing an output reload on\n-\t\t an insn setting CC) will operate correctly.  */\n+\t      /* If this register is clobbered or it is only used in\n+\t\t this insn and is only set, mark it unused.  We have\n+\t\t to do this even when not optimizing so that MD patterns\n+\t\t which count on this behavior (e.g., it not causing an\n+\t\t output reload on an insn setting CC) will operate\n+\t\t correctly.  */\n \t      if (GET_CODE (SET_DEST (x)) == REG\n-\t\t  && REGNO_FIRST_UID (regno) == INSN_UID (insn)\n-\t\t  && REGNO_LAST_UID (regno) == INSN_UID (insn)\n-\t\t  && (code == CLOBBER || ! reg_mentioned_p (SET_DEST (x),\n-\t\t\t\t\t\t\t    SET_SRC (x))))\n+\t\t  && (code == CLOBBER\n+\t\t      || (REGNO_FIRST_UID (regno) == INSN_UID (insn)\n+\t\t\t  && REGNO_LAST_UID (regno) == INSN_UID (insn)\n+\t\t\t  && ! reg_mentioned_p (SET_DEST (x),\n+\t\t\t\t\t\tSET_SRC (x)))))\n \t\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n \t\t\t\t\t\t      SET_DEST (x),\n \t\t\t\t\t\t      REG_NOTES (insn));"}]}