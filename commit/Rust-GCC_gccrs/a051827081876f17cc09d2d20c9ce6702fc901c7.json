{"sha": "a051827081876f17cc09d2d20c9ce6702fc901c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1MTgyNzA4MTg3NmYxN2NjMDlkMmQyMGM5Y2U2NzAyZmM5MDFjNw==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gnu.org", "date": "1998-03-28T00:28:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-28T00:28:21Z"}, "message": "u77-test.f: Don't bother declaring etime.\n\n        * libU77/u77-test.f: Don't bother declaring etime.\n        Use `implicit none' and declare mask and lenstr.\n        Do ETIME/DTIME consistency check before loop, then\n        use loop to verify that dtime \"ticks\" at some point.\n        Check ETIME array-sum using single-precision add, to\n        avoid spurious complaint on systems (like x86) that\n        use more precision for intermediate results.\n        Fix `Results of ETIME and DTIME...' message to print\n        pertinent values (r1 and r2 instead of i and j).\n        Change loop from 10M to 1K repeated up to 1000 times\n        or until dtime \"ticks\".\n        Print the number of 1K loops needed to see this tick.\n        Answer a commented question.\n        Split up a long line of output and do other prettying.\n        Preset lognam in case GETLOG fails to overwrite it.\nPatch from Craig.\n\nFrom-SVN: r18861", "tree": {"sha": "b09838b2ea570d743dc4165680e7063ba1bf10e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09838b2ea570d743dc4165680e7063ba1bf10e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a051827081876f17cc09d2d20c9ce6702fc901c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a051827081876f17cc09d2d20c9ce6702fc901c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a051827081876f17cc09d2d20c9ce6702fc901c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a051827081876f17cc09d2d20c9ce6702fc901c7/comments", "author": null, "committer": null, "parents": [{"sha": "4d1d804584e7b0795a7c355d3a9cafaa947f1071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1d804584e7b0795a7c355d3a9cafaa947f1071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1d804584e7b0795a7c355d3a9cafaa947f1071"}], "stats": {"total": 91, "additions": 76, "deletions": 15}, "files": [{"sha": "80d1f88fc5d3bfe70c6064318b2006fa7eb8a980", "filename": "libf2c/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a051827081876f17cc09d2d20c9ce6702fc901c7/libf2c%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a051827081876f17cc09d2d20c9ce6702fc901c7/libf2c%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FChangeLog?ref=a051827081876f17cc09d2d20c9ce6702fc901c7", "patch": "@@ -1,3 +1,21 @@\n+Wed Mar  4 16:32:46 1998  Craig Burley  <burley@gnu.org>\n+\n+\t* libU77/u77-test.f: Don't bother declaring etime.\n+\tUse `implicit none' and declare mask and lenstr.\n+\tDo ETIME/DTIME consistency check before loop, then\n+\tuse loop to verify that dtime \"ticks\" at some point.\n+\tCheck ETIME array-sum using single-precision add, to\n+\tavoid spurious complaint on systems (like x86) that\n+\tuse more precision for intermediate results.\n+\tFix `Results of ETIME and DTIME...' message to print\n+\tpertinent values (r1 and r2 instead of i and j).\n+\tChange loop from 10M to 1K repeated up to 1000 times\n+\tor until dtime \"ticks\".\n+\tPrint the number of 1K loops needed to see this tick.\n+\tAnswer a commented question.\n+\tSplit up a long line of output and do other prettying.\n+\tPreset lognam in case GETLOG fails to overwrite it.\n+\n Sat Feb 28 15:32:15 1998  Craig Burley  <burley@gnu.org>\n \n \t* libI77/open.c (f_open): Use sizeof(buf) instead of"}, {"sha": "9060469a8795a19b1bf41327517b458a553b016d", "filename": "libf2c/libU77/u77-test.f", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a051827081876f17cc09d2d20c9ce6702fc901c7/libf2c%2FlibU77%2Fu77-test.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a051827081876f17cc09d2d20c9ce6702fc901c7/libf2c%2FlibU77%2Fu77-test.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibU77%2Fu77-test.f?ref=a051827081876f17cc09d2d20c9ce6702fc901c7", "patch": "@@ -3,15 +3,17 @@\n *     good squint at what it prints, though detected errors will cause \n *     starred messages.\n \n+      implicit none\n       integer i, j, k, ltarray (9), idat (3), count, rate, count_max,\n-     +     pid\n-      real tarray1(2), tarray2(2), r1, r2, etime\n+     +     pid, mask\n+      real tarray1(2), tarray2(2), r1, r2, sum\n       intrinsic getpid, getuid, getgid, ierrno, gerror,\n      +     fnum, isatty, getarg, access, unlink, fstat,\n      +     stat, lstat, getcwd, gmtime, hostnm, etime, chmod,\n      +     chdir, fgetc, fputc, system_clock, second, idate, secnds,\n      +     time, ctime, fdate, ttynam\n       external lenstr\n+      integer lenstr\n       logical l\n       character gerr*80, c*1\n       character ctim*25, line*80, lognam*20, wd*100, line2*80\n@@ -35,20 +37,23 @@\n         line = 'and 6 isn''t a tty device (ISATTY)'\n       end if\n       write (6,'(1X,A)') line(:lenstr(line))\n+\n       pid = getpid()\n       WRITE (6,'(A,I10)') ' Process id (GETPID): ', pid\n       WRITE (6,'(A,I10)') ' User id (GETUID): ', GETUID ()\n       WRITE (6,'(A,I10)') ' Group id (GETGID): ', GETGID ()\n-      WRITE (6,*) 'If you have the `id'' program, the following call of'\n-     +     // ' SYSTEM should agree with the above'\n+      WRITE (6, *) 'If you have the `id'' program, the following call'\n+      write (6, *) 'of SYSTEM should agree with the above:'\n       call flush(6)\n       CALL SYSTEM ('echo \" \" `id`')\n       call flush\n+      lognam = 'blahblahblah'\n       call getlog (lognam)\n       write (6,*) 'Login name (GETLOG): ', lognam\n       call umask(0, mask)\n       write(6,*) 'UMASK returns', mask\n       call umask(mask)\n+\n       ctim = fdate()\n       write (6,*) 'FDATE returns: ', ctim\n       j=time()\n@@ -58,23 +63,54 @@\n       write (6,'(1x,a,9i4)') 'GMTIME returns:', ltarray\n       call system_clock(count, rate, count_max)\n       write(6,*) 'SYSTEM_CLOCK returns: ', count, rate, count_max\n+\n       write (6,*) 'Sleeping for 1 second (SLEEP) ...'\n       call sleep (1)\n-      write (6,*) 'Looping 10,000,000 times ...'\n-      do i=1,10*1000*1000\n+\n+c consistency-check etime vs. dtime for first call\n+      r1 = etime (tarray1)\n+      r2 = dtime (tarray2)\n+      if (abs (r1-r2).gt.1.0) write (6,*)\n+     +     'Results of ETIME and DTIME differ by more than a second:',\n+     +     r1, r2\n+      call sgladd (sum, tarray1(1), tarray1(2))\n+      if (r1 .ne. sum)\n+     +     write (6,*) '*** ETIME didn''t return sum of the array: ',\n+     +     r1, ' /= ', tarray1(1), '+', tarray1(2)\n+      call sgladd (sum, tarray2(1), tarray2(2))\n+      if (r2 .ne. sum)\n+     +     write (6,*) '*** DTIME didn''t return sum of the array: ',\n+     +     r2, ' /= ', tarray2(1), '+', tarray2(2)\n+      write (6, '(A,3F10.3)')\n+     +     ' Elapsed total, user, system time (ETIME): ',\n+     +     r1, tarray1\n+\n+c now try to get times to change enough to see in etime/dtime\n+      write (6,*) 'Looping until clock ticks at least once...'\n+      do i = 1,1000\n+      do j = 1,1000\n+      end do\n+      r2 = dtime (tarray2)\n+      if (tarray2(1) .ne. 0. .or. tarray2(2) .ne. 0.) exit\n       end do\n-      r1= etime (tarray1)\n-      if (r1.ne.tarray1(1)+tarray1(2))\n+      r1 = etime (tarray1)\n+      call sgladd (sum, tarray1(1), tarray1(2))\n+      if (r1 .ne. sum)\n      +     write (6,*) '*** ETIME didn''t return sum of the array: ',\n      +     r1, ' /= ', tarray1(1), '+', tarray1(2)\n-      r2= dtime (tarray2)\n-      if (abs (r1-r2).gt.1.0) write (6,*)\n-     +     'Results of ETIME and DTIME differ by more than a second:',\n-     +     i, j\n-      write (6,'(A,3F10.3)')\n+      call sgladd (sum, tarray2(1), tarray2(2))\n+      if (r2 .ne. sum)\n+     +     write (6,*) '*** DTIME didn''t return sum of the array: ',\n+     +     r2, ' /= ', tarray2(1), '+', tarray2(2)\n+      write (6, '(A,3F10.3)')\n+     +     ' Differences in total, user, system time (DTIME): ',\n+     +     r2, tarray2\n+      write (6, '(A,3F10.3)')\n      +     ' Elapsed total, user, system time (ETIME): ',\n      +     r1, tarray1\n-      call idate(i,j,k)\n+      write (6, *) '(Clock-tick detected after ', i, ' 1K loops.)'\n+\n+      call idate (i,j,k)\n       call idate (idat)\n       write (6,*) 'IDATE d,m,y: ',idat\n       print *,  '... and the VXT version: ', i,j,k\n@@ -107,7 +143,8 @@\n       call fputc(3, 'c',i)\n       call fputc(3, 'd',j)      \n       if (i+j.ne.0) write(6,*) '***FPUTC: ', i\n-C     why is it necessary to reopen?\n+C     why is it necessary to reopen?  (who wrote this?)\n+C     the better to test with, my dear!  (-- burley)\n       close(3)\n       open(3,file='foo',status='old')\n       call fseek(3,0,0,*10)\n@@ -176,3 +213,9 @@ integer function lenstr (str)\n       subroutine dumdum(r)\n       r = 3.14159\n       end\n+* do an add that is most likely to be done in single precision.\n+      subroutine sgladd(sum,left,right)\n+      implicit none\n+      real sum,left,right\n+      sum = left+right\n+      end"}]}