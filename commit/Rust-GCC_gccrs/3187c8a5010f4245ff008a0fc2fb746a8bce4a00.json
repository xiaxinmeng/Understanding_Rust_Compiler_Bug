{"sha": "3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE4N2M4YTUwMTBmNDI0NWZmMDA4YTBmYzJmYjc0NmE4YmNlNGEwMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-10-02T12:44:35Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-10-02T12:44:35Z"}, "message": "[PATCH] Do not check call type compatibility when cloning cgraph-edges\n\n2019-10-02  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.c (symbol_table::create_edge): New parameter cloning_p,\n\tdo not compute some stuff when set.\n\t(cgraph_node::create_edge): Likewise.\n\t(cgraph_node::create_indirect_edge): Renamed last parameter to\n\tconing_p and flipped its meaning, don't even calculate\n\tinline_failed when set.\n\t* cgraph.h (cgraph_node::create_edge): Add new parameter.\n\t(symbol_table::::create_edge): Likewise.\n\t(cgraph_node::create_indirect_edge): Rename last parameter, flip\n\tthe default value.\n\t* cgraphclones.c (cgraph_edge::clone): Pass true cloning_p to all\n\tcall graph edge creating functions.\n\nFrom-SVN: r276455", "tree": {"sha": "57403e651339babab9bbb759ade26ac1ce118719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57403e651339babab9bbb759ade26ac1ce118719"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "569651fd6fdb6455da58f7811e6296c22ce34df7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/569651fd6fdb6455da58f7811e6296c22ce34df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/569651fd6fdb6455da58f7811e6296c22ce34df7"}], "stats": {"total": 81, "additions": 54, "deletions": 27}, "files": [{"sha": "7b5777e37d0dfb670663e1e9a2bafa00c2306d97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "patch": "@@ -1,3 +1,18 @@\n+2019-10-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.c (symbol_table::create_edge): New parameter cloning_p,\n+\tdo not compute some stuff when set.\n+\t(cgraph_node::create_edge): Likewise.\n+\t(cgraph_node::create_indirect_edge): Renamed last parameter to\n+\tconing_p and flipped its meaning, don't even calculate\n+\tinline_failed when set.\n+\t* cgraph.h (cgraph_node::create_edge): Add new parameter.\n+\t(symbol_table::::create_edge): Likewise.\n+\t(cgraph_node::create_indirect_edge): Rename last parameter, flip\n+\tthe default value.\n+\t* cgraphclones.c (cgraph_edge::clone): Pass true cloning_p to all\n+\tcall graph edge creating functions.\n+\n 2019-10-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR c++/91222"}, {"sha": "7748cef76d0b2eadffea1617d78c5e31d1560459", "filename": "gcc/cgraph.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "patch": "@@ -824,12 +824,13 @@ cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)\n \n /* Allocate a cgraph_edge structure and fill it with data according to the\n    parameters of which only CALLEE can be NULL (when creating an indirect call\n-   edge).  */\n+   edge).  CLONING_P should be set if properties that are copied from an\n+   original edge should not be calculated.  */\n \n cgraph_edge *\n symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n \t\t\t   gcall *call_stmt, profile_count count,\n-\t\t\t   bool indir_unknown_callee)\n+\t\t\t   bool indir_unknown_callee, bool cloning_p)\n {\n   cgraph_edge *edge;\n \n@@ -862,8 +863,17 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->lto_stmt_uid = 0;\n \n   edge->count = count;\n-\n   edge->call_stmt = call_stmt;\n+  edge->indirect_info = NULL;\n+  edge->indirect_inlining_edge = 0;\n+  edge->speculative = false;\n+  edge->indirect_unknown_callee = indir_unknown_callee;\n+  if (call_stmt && caller->call_site_hash)\n+    cgraph_add_edge_to_call_site_hash (edge);\n+\n+  if (cloning_p)\n+    return edge;\n+\n   edge->can_throw_external\n     = call_stmt ? stmt_can_throw_external (DECL_STRUCT_FUNCTION (caller->decl),\n \t\t\t\t\t   call_stmt) : false;\n@@ -881,33 +891,30 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n       edge->call_stmt_cannot_inline_p = false;\n     }\n \n-  edge->indirect_info = NULL;\n-  edge->indirect_inlining_edge = 0;\n-  edge->speculative = false;\n-  edge->indirect_unknown_callee = indir_unknown_callee;\n   if (opt_for_fn (edge->caller->decl, flag_devirtualize)\n       && call_stmt && DECL_STRUCT_FUNCTION (caller->decl))\n     edge->in_polymorphic_cdtor\n       = decl_maybe_in_construction_p (NULL, NULL, call_stmt,\n \t\t\t\t      caller->decl);\n   else\n     edge->in_polymorphic_cdtor = caller->thunk.thunk_p;\n-  if (call_stmt && caller->call_site_hash)\n-    cgraph_add_edge_to_call_site_hash (edge);\n \n   return edge;\n }\n \n-/* Create edge from a given function to CALLEE in the cgraph.  */\n+/* Create edge from a given function to CALLEE in the cgraph.  CLONING_P should\n+   be set if properties that are copied from an original edge should not be\n+   calculated.  */\n \n cgraph_edge *\n cgraph_node::create_edge (cgraph_node *callee,\n-\t\t\t  gcall *call_stmt, profile_count count)\n+\t\t\t  gcall *call_stmt, profile_count count, bool cloning_p)\n {\n   cgraph_edge *edge = symtab->create_edge (this, callee, call_stmt, count,\n-\t\t\t\t\t   false);\n+\t\t\t\t\t   false, cloning_p);\n \n-  initialize_inline_failed (edge);\n+  if (!cloning_p)\n+    initialize_inline_failed (edge);\n \n   edge->next_caller = callee->callers;\n   if (callee->callers)\n@@ -935,25 +942,28 @@ cgraph_allocate_init_indirect_info (void)\n \n /* Create an indirect edge with a yet-undetermined callee where the call\n    statement destination is a formal parameter of the caller with index\n-   PARAM_INDEX. */\n+   PARAM_INDEX. CLONING_P should be set if properties that are copied from an\n+   original edge should not be calculated and indirect_info structure should\n+   not be calculated.  */\n \n cgraph_edge *\n cgraph_node::create_indirect_edge (gcall *call_stmt, int ecf_flags,\n \t\t\t\t   profile_count count,\n-\t\t\t\t   bool compute_indirect_info)\n+\t\t\t\t   bool cloning_p)\n {\n-  cgraph_edge *edge = symtab->create_edge (this, NULL, call_stmt,\n-\t\t\t\t\t\t\t    count, true);\n+  cgraph_edge *edge = symtab->create_edge (this, NULL, call_stmt, count, true,\n+\t\t\t\t\t   cloning_p);\n   tree target;\n \n-  initialize_inline_failed (edge);\n+  if (!cloning_p)\n+    initialize_inline_failed (edge);\n \n   edge->indirect_info = cgraph_allocate_init_indirect_info ();\n   edge->indirect_info->ecf_flags = ecf_flags;\n   edge->indirect_info->vptr_changed = true;\n \n   /* Record polymorphic call info.  */\n-  if (compute_indirect_info\n+  if (!cloning_p\n       && call_stmt\n       && (target = gimple_call_fn (call_stmt))\n       && virtual_method_call_p (target))"}, {"sha": "66a4dae76184433d749c9ebd7d5e75bed2fc31e1", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "patch": "@@ -1161,14 +1161,15 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n \n   /* Create edge from a given function to CALLEE in the cgraph.  */\n   cgraph_edge *create_edge (cgraph_node *callee,\n-\t\t\t    gcall *call_stmt, profile_count count);\n+\t\t\t    gcall *call_stmt, profile_count count,\n+\t\t\t    bool cloning_p = false);\n \n   /* Create an indirect edge with a yet-undetermined callee where the call\n      statement destination is a formal parameter of the caller with index\n      PARAM_INDEX. */\n   cgraph_edge *create_indirect_edge (gcall *call_stmt, int ecf_flags,\n \t\t\t\t     profile_count count,\n-\t\t\t\t     bool compute_indirect_info = true);\n+\t\t\t\t     bool cloning_p = false);\n \n   /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n    same function body.  If clones already have edge for OLD_STMT; only\n@@ -2381,11 +2382,12 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   inline cgraph_node * allocate_cgraph_symbol (void);\n \n   /* Allocate a cgraph_edge structure and fill it with data according to the\n-     parameters of which only CALLEE can be NULL (when creating an indirect call\n-     edge).  */\n+     parameters of which only CALLEE can be NULL (when creating an indirect\n+     call edge).  CLONING_P should be set if properties that are copied from an\n+     original edge should not be calculated.  */\n   cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee,\n \t\t\t    gcall *call_stmt, profile_count count,\n-\t\t\t    bool indir_unknown_callee);\n+\t\t\t    bool indir_unknown_callee, bool cloning_p);\n \n   /* Put the edge onto the free list.  */\n   void free_edge (cgraph_edge *e);"}, {"sha": "087b5a26280c0e283c72153abd0d33b0999b73c0", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3187c8a5010f4245ff008a0fc2fb746a8bce4a00/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=3187c8a5010f4245ff008a0fc2fb746a8bce4a00", "patch": "@@ -104,19 +104,19 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t{\n \t  cgraph_node *callee = cgraph_node::get (decl);\n \t  gcc_checking_assert (callee);\n-\t  new_edge = n->create_edge (callee, call_stmt, prof_count);\n+\t  new_edge = n->create_edge (callee, call_stmt, prof_count, true);\n \t}\n       else\n \t{\n \t  new_edge = n->create_indirect_edge (call_stmt,\n \t\t\t\t\t      indirect_info->ecf_flags,\n-\t\t\t\t\t      prof_count, false);\n+\t\t\t\t\t      prof_count, true);\n \t  *new_edge->indirect_info = *indirect_info;\n \t}\n     }\n   else\n     {\n-      new_edge = n->create_edge (callee, call_stmt, prof_count);\n+      new_edge = n->create_edge (callee, call_stmt, prof_count, true);\n       if (indirect_info)\n \t{\n \t  new_edge->indirect_info"}]}