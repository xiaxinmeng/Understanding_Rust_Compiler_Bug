{"sha": "cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyYjcwMjBlZThlOTc0NWVkZTUyN2IwYTNiMmUwZmZiYWZkNDkyYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-28T21:05:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-06-01T15:38:21Z"}, "message": "c++: no clobber for C++20 destroying delete [PR91859]\n\nBefore C++20 added destroying operator delete, by the time we called\noperator delete for a pointer, the object would already be gone.  But that\nisn't true for destroying delete.  Since the optimizers' assumptions about\noperator delete are based on either DECL_IS_REPLACEABLE_OPERATOR (which\nalready is not set) or CALL_FROM_NEW_OR_DELETE_P, let's avoid setting the\nlatter flag in this case.\n\n\tPR c++/91859\n\ngcc/ChangeLog:\n\n\t* tree.h (CALL_FROM_NEW_OR_DELETE_P): Adjust comment.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (build_op_delete_call): Don't set CALL_FROM_NEW_OR_DELETE_P\n\tfor destroying delete.\n\t* init.c (build_delete): Don't clobber before destroying delete.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/destroying-delete5.C: New test.", "tree": {"sha": "2cba3de452cbeda1c79403c5f1d50c957dd43118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cba3de452cbeda1c79403c5f1d50c957dd43118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "620cd7861e1266991c9c2a82e1e2d5f4d723ec88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/620cd7861e1266991c9c2a82e1e2d5f4d723ec88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/620cd7861e1266991c9c2a82e1e2d5f4d723ec88"}], "stats": {"total": 47, "additions": 44, "deletions": 3}, "files": [{"sha": "90192b1b8aa9b6838cb1c12b9fd88635b4cbc817", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "patch": "@@ -7206,8 +7206,10 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t treat that as an implicit delete-expression.  This is also called for\n \t the delete if the constructor throws in a new-expression, and for a\n \t deleting destructor (which implements a delete-expression).  */\n+      /* But leave this flag off for destroying delete to avoid wrong\n+\t assumptions in the optimizers.  */\n       tree call = extract_call_expr (ret);\n-      if (TREE_CODE (call) == CALL_EXPR)\n+      if (TREE_CODE (call) == CALL_EXPR && !destroying_delete_p (fn))\n \tCALL_FROM_NEW_OR_DELETE_P (call) = 1;\n \n       return ret;"}, {"sha": "04d495807efd3ff9445974f5bf6fd51dd8feef2a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "patch": "@@ -4881,7 +4881,10 @@ build_delete (location_t loc, tree otype, tree addr,\n \t\t\t    complain);\n     }\n \n-  if (!destroying_delete && type_build_dtor_call (type))\n+  if (destroying_delete)\n+    /* The operator delete will call the destructor.  */\n+    expr = addr;\n+  else if (type_build_dtor_call (type))\n     expr = build_dtor_call (cp_build_fold_indirect_ref (addr),\n \t\t\t    auto_delete, flags, complain);\n   else"}, {"sha": "553c964b9e956c157b71cda16e69d41190131a27", "filename": "gcc/testsuite/g++.dg/cpp2a/destroying-delete5.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdestroying-delete5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdestroying-delete5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdestroying-delete5.C?ref=cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/91859\n+// { dg-do run { target c++20 } }\n+// { dg-additional-options -O2 }\n+\n+#include <cstdlib>\n+#include <new>\n+\n+struct Expression {\n+  int i = 0;\n+  void *operator new(std::size_t);\n+  void operator delete(Expression *, std::destroying_delete_t);\n+};\n+\n+void * Expression::operator new(std::size_t sz)\n+{\n+  return std::malloc(sz);\n+}\n+\n+int i;\n+\n+void Expression::operator delete(Expression *p, std::destroying_delete_t)\n+{\n+  Expression * e = p;\n+  ::i = e->i;\n+  p->~Expression();\n+  std::free(p);\n+}\n+\n+int main()\n+{\n+  auto p = new Expression();\n+  p->i = 1;\n+  delete p;\n+  if (i != 1)\n+    __builtin_abort();\n+}"}, {"sha": "62b2de464797c273c5dd71404db5d4489c3e921b", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=cf2b7020ee8e9745ede527b0a3b2e0ffbafd492b", "patch": "@@ -937,7 +937,7 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n /* In a CALL_EXPR, if the function being called is DECL_IS_OPERATOR_NEW_P or\n    DECL_IS_OPERATOR_DELETE_P, true for allocator calls from C++ new or delete\n-   expressions.  */\n+   expressions.  Not set for C++20 destroying delete operators.  */\n #define CALL_FROM_NEW_OR_DELETE_P(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n "}]}