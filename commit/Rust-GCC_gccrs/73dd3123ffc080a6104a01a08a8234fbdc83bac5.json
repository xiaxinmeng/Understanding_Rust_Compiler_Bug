{"sha": "73dd3123ffc080a6104a01a08a8234fbdc83bac5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNkZDMxMjNmZmMwODBhNjEwNGEwMWEwOGE4MjM0ZmJkYzgzYmFjNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-02-07T08:07:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-02-07T08:07:04Z"}, "message": "re PR rtl-optimization/56178 (Miscompilation of Ada front-end with profiled bootstrap)\n\n\tPR rtl-optimization/56178\n\t* cse.c (cse_insn): Do not create a REG_EQUAL note if the source is a\n\tSUBREG of a register.  Tidy up related block of code.\n\t* fwprop.c (forward_propagate_and_simplify): Do not create a REG_EQUAL\n\tnote if the source is a register or a SUBREG of a register.\n\nFrom-SVN: r195841", "tree": {"sha": "33510bb58a15436c9c5742765116481061bd5673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33510bb58a15436c9c5742765116481061bd5673"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73dd3123ffc080a6104a01a08a8234fbdc83bac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73dd3123ffc080a6104a01a08a8234fbdc83bac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73dd3123ffc080a6104a01a08a8234fbdc83bac5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73dd3123ffc080a6104a01a08a8234fbdc83bac5/comments", "author": null, "committer": null, "parents": [{"sha": "e3936f47f63c128d6a667596111865f35869392f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3936f47f63c128d6a667596111865f35869392f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3936f47f63c128d6a667596111865f35869392f"}], "stats": {"total": 62, "additions": 38, "deletions": 24}, "files": [{"sha": "b7914b5dfe1807416855c57763590beae5e56de3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dd3123ffc080a6104a01a08a8234fbdc83bac5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dd3123ffc080a6104a01a08a8234fbdc83bac5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73dd3123ffc080a6104a01a08a8234fbdc83bac5", "patch": "@@ -1,3 +1,11 @@\n+2013-02-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/56178\n+\t* cse.c (cse_insn): Do not create a REG_EQUAL note if the source is a\n+\tSUBREG of a register.  Tidy up related block of code.\n+\t* fwprop.c (forward_propagate_and_simplify): Do not create a REG_EQUAL\n+\tnote if the source is a register or a SUBREG of a register.\n+\n 2013-02-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/56228"}, {"sha": "b200fef4dfbac1dc9fd0ec0a2f46c736b3f85052", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dd3123ffc080a6104a01a08a8234fbdc83bac5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dd3123ffc080a6104a01a08a8234fbdc83bac5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=73dd3123ffc080a6104a01a08a8234fbdc83bac5", "patch": "@@ -5311,33 +5311,33 @@ cse_insn (rtx insn)\n \t}\n \n       /* If this is a single SET, we are setting a register, and we have an\n-\t equivalent constant, we want to add a REG_NOTE.   We don't want\n-\t to write a REG_EQUAL note for a constant pseudo since verifying that\n-\t that pseudo hasn't been eliminated is a pain.  Such a note also\n-\t won't help anything.\n+\t equivalent constant, we want to add a REG_EQUAL note if the constant\n+\t is different from the source.  We don't want to do it for a constant\n+\t pseudo since verifying that this pseudo hasn't been eliminated is a\n+\t pain; moreover such a note won't help anything.\n \n \t Avoid a REG_EQUAL note for (CONST (MINUS (LABEL_REF) (LABEL_REF)))\n \t which can be created for a reference to a compile time computable\n \t entry in a jump table.  */\n-\n-      if (n_sets == 1 && src_const && REG_P (dest)\n+      if (n_sets == 1\n+\t  && REG_P (dest)\n+\t  && src_const\n \t  && !REG_P (src_const)\n-\t  && ! (GET_CODE (src_const) == CONST\n-\t\t&& GET_CODE (XEXP (src_const, 0)) == MINUS\n-\t\t&& GET_CODE (XEXP (XEXP (src_const, 0), 0)) == LABEL_REF\n-\t\t&& GET_CODE (XEXP (XEXP (src_const, 0), 1)) == LABEL_REF))\n+\t  && !(GET_CODE (src_const) == SUBREG\n+\t       && REG_P (SUBREG_REG (src_const)))\n+\t  && !(GET_CODE (src_const) == CONST\n+\t       && GET_CODE (XEXP (src_const, 0)) == MINUS\n+\t       && GET_CODE (XEXP (XEXP (src_const, 0), 0)) == LABEL_REF\n+\t       && GET_CODE (XEXP (XEXP (src_const, 0), 1)) == LABEL_REF)\n+\t  && !rtx_equal_p (src, src_const))\n \t{\n-\t  /* We only want a REG_EQUAL note if src_const != src.  */\n-\t  if (! rtx_equal_p (src, src_const))\n-\t    {\n-\t      /* Make sure that the rtx is not shared.  */\n-\t      src_const = copy_rtx (src_const);\n+\t  /* Make sure that the rtx is not shared.  */\n+\t  src_const = copy_rtx (src_const);\n \n-\t      /* Record the actual constant value in a REG_EQUAL note,\n-\t\t making a new one if one does not already exist.  */\n-\t      set_unique_reg_note (insn, REG_EQUAL, src_const);\n-\t      df_notes_rescan (insn);\n-\t    }\n+\t  /* Record the actual constant value in a REG_EQUAL note,\n+\t     making a new one if one does not already exist.  */\n+\t  set_unique_reg_note (insn, REG_EQUAL, src_const);\n+\t  df_notes_rescan (insn);\n \t}\n \n       /* Now deal with the destination.  */"}, {"sha": "17cc62aa2e4e2cfcfd1dc0135ef20722301b12dd", "filename": "gcc/fwprop.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73dd3123ffc080a6104a01a08a8234fbdc83bac5/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73dd3123ffc080a6104a01a08a8234fbdc83bac5/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=73dd3123ffc080a6104a01a08a8234fbdc83bac5", "patch": "@@ -1316,10 +1316,16 @@ forward_propagate_and_simplify (df_ref use, rtx def_insn, rtx def_set)\n \t separately try plugging the definition in the note and simplifying.\n \t And only install a REQ_EQUAL note when the destination is a REG\n \t that isn't mentioned in USE_SET, as the note would be invalid\n-\t otherwise.  */\n-      set_reg_equal = (note == NULL_RTX && REG_P (SET_DEST (use_set))\n-\t\t       && ! reg_mentioned_p (SET_DEST (use_set),\n-\t\t\t\t\t     SET_SRC (use_set)));\n+\t otherwise.  We also don't want to install a note if we are merely\n+\t propagating a pseudo since verifying that this pseudo isn't dead\n+\t is a pain; moreover such a note won't help anything.  */\n+      set_reg_equal = (note == NULL_RTX\n+\t\t       && REG_P (SET_DEST (use_set))\n+\t\t       && !REG_P (src)\n+\t\t       && !(GET_CODE (src) == SUBREG\n+\t\t\t    && REG_P (SUBREG_REG (src)))\n+\t\t       && !reg_mentioned_p (SET_DEST (use_set),\n+\t\t\t\t\t    SET_SRC (use_set)));\n     }\n \n   if (GET_MODE (*loc) == VOIDmode)"}]}