{"sha": "edfaf675109ca666d7ddbd901c82c18383385255", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRmYWY2NzUxMDljYTY2NmQ3ZGRiZDkwMWM4MmMxODM4MzM4NTI1NQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2004-11-02T00:23:04Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2004-11-02T00:23:04Z"}, "message": "re PR tree-optimization/16447 (out of ssa generates bloated code)\n\n\n2004-11-01  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR tree-optimization/16447\n\t* tree-cfg.c (bsi_commit_one_edge_insert): Rename from\n\tbsi_commit_edge_inserts_1, and make funtion external.  Return new block.\n\t(bsi_commit_edge_inserts): Use renamed bsi_commit_one_edge_insert.\n\t* tree-optimize.c (pass_cleanup_cfg_post_optimizing): Enable listing.\n\t* tree-flow.h (bsi_commit_one_edge_insert): Extern decl.\n\t* tree-outof-ssa.c (rewrite_trees): Don't commit edges here.\n\t(same_stmt_list_p): New.  Return TRUE if edge is to be forwarded.\n\t(identical_copies_p): New.  Return true is two copies are the same.\n\t(identical_stmt_lists_p): New.  Return true if stmt lists are the same.\n\t(analyze_edges_for_bb): New.  Determine how best to insert edge stmts\n\tfor a basic block.\n\t(perform_edge_inserts): New.  Determine what to do with all stmts that\n\thave been inserted on edges.\n\t(remove_ssa_form):  Analyze and commit edges from here.\n\nFrom-SVN: r89970", "tree": {"sha": "b53d70edc3071cf94765fb9657ab1326ec36c283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b53d70edc3071cf94765fb9657ab1326ec36c283"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edfaf675109ca666d7ddbd901c82c18383385255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edfaf675109ca666d7ddbd901c82c18383385255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edfaf675109ca666d7ddbd901c82c18383385255", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edfaf675109ca666d7ddbd901c82c18383385255/comments", "author": null, "committer": null, "parents": [{"sha": "8bf639fa5e1887d9313c9a251cfe550033708bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf639fa5e1887d9313c9a251cfe550033708bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf639fa5e1887d9313c9a251cfe550033708bef"}], "stats": {"total": 368, "additions": 357, "deletions": 11}, "files": [{"sha": "2610259112f52d2c39f82858bd800b10e6c9ac34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edfaf675109ca666d7ddbd901c82c18383385255", "patch": "@@ -1,3 +1,21 @@\n+2004-11-01  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR tree-optimization/16447\n+\t* tree-cfg.c (bsi_commit_one_edge_insert): Rename from \n+\tbsi_commit_edge_inserts_1, and make funtion external.  Return new block.\n+\t(bsi_commit_edge_inserts): Use renamed bsi_commit_one_edge_insert.\n+\t* tree-optimize.c (pass_cleanup_cfg_post_optimizing): Enable listing.\n+\t* tree-flow.h (bsi_commit_one_edge_insert): Extern decl.\n+\t* tree-outof-ssa.c (rewrite_trees): Don't commit edges here.\n+\t(same_stmt_list_p): New.  Return TRUE if edge is to be forwarded.\n+\t(identical_copies_p): New.  Return true is two copies are the same.\n+\t(identical_stmt_lists_p): New.  Return true if stmt lists are the same.\n+\t(analyze_edges_for_bb): New.  Determine how best to insert edge stmts \n+\tfor a basic block.\n+\t(perform_edge_inserts): New.  Determine what to do with all stmts that\n+\thave been inserted on edges.\n+\t(remove_ssa_form):  Analyze and commit edges from here.\n+\n 2004-11-01  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR bootstrap/18232"}, {"sha": "c886f6a56168f79263fc0afcba8fa526118546dc", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=edfaf675109ca666d7ddbd901c82c18383385255", "patch": "@@ -93,7 +93,6 @@ static int tree_verify_flow_info (void);\n static void tree_make_forwarder_block (edge);\n static bool thread_jumps (void);\n static bool tree_forwarder_block_p (basic_block);\n-static void bsi_commit_edge_inserts_1 (edge e);\n static void tree_cfg2vcg (FILE *);\n \n /* Flowgraph optimization and cleanup.  */\n@@ -2871,30 +2870,33 @@ bsi_commit_edge_inserts (int *new_blocks)\n \n   blocks = n_basic_blocks;\n \n-  bsi_commit_edge_inserts_1 (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+  bsi_commit_one_edge_insert (EDGE_SUCC (ENTRY_BLOCK_PTR, 0), NULL);\n \n   FOR_EACH_BB (bb)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n-      bsi_commit_edge_inserts_1 (e);\n+      bsi_commit_one_edge_insert (e, NULL);\n \n   if (new_blocks)\n     *new_blocks = n_basic_blocks - blocks;\n }\n \n \n-/* Commit insertions pending at edge E.  */\n+/* Commit insertions pending at edge E. If a new block is created, set NEW_BB\n+   to this block, otherwise set it to NULL.  */\n \n-static void\n-bsi_commit_edge_inserts_1 (edge e)\n+void\n+bsi_commit_one_edge_insert (edge e, basic_block *new_bb)\n {\n+  if (new_bb)\n+    *new_bb = NULL;\n   if (PENDING_STMT (e))\n     {\n       block_stmt_iterator bsi;\n       tree stmt = PENDING_STMT (e);\n \n       PENDING_STMT (e) = NULL_TREE;\n \n-      if (tree_find_edge_insert_loc (e, &bsi, NULL))\n+      if (tree_find_edge_insert_loc (e, &bsi, new_bb))\n \tbsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n       else\n \tbsi_insert_before (&bsi, stmt, BSI_NEW_STMT);"}, {"sha": "9e77fe250632c8226ded56c5242b93dfa1bb726e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=edfaf675109ca666d7ddbd901c82c18383385255", "patch": "@@ -479,6 +479,7 @@ extern basic_block label_to_block (tree);\n extern void tree_optimize_tail_calls (bool, enum tree_dump_index);\n extern void bsi_insert_on_edge (edge, tree);\n extern basic_block bsi_insert_on_edge_immediate (edge, tree);\n+extern void bsi_commit_one_edge_insert (edge e, basic_block *);\n extern void bsi_commit_edge_inserts (int *);\n extern void notice_special_calls (tree);\n extern void clear_special_calls (void);"}, {"sha": "da7a2e7e6e3fb4f5f48e663e498f8777905cd131", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=edfaf675109ca666d7ddbd901c82c18383385255", "patch": "@@ -118,7 +118,7 @@ execute_cleanup_cfg_post_optimizing (void)\n \n static struct tree_opt_pass pass_cleanup_cfg_post_optimizing =\n {\n-  NULL,\t\t\t\t\t/* name */\n+  \"final_cleanup\",\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n   execute_cleanup_cfg_post_optimizing,\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n@@ -129,7 +129,7 @@ static struct tree_opt_pass pass_cleanup_cfg_post_optimizing =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n+  TODO_dump_func,\t\t\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "6d33c4731cf65f30d1a09d61c7db3ce5a57962e2", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 327, "deletions": 2, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edfaf675109ca666d7ddbd901c82c18383385255/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=edfaf675109ca666d7ddbd901c82c18383385255", "patch": "@@ -1933,9 +1933,331 @@ rewrite_trees (var_map map, tree *values)\n     }\n \n   delete_elim_graph (g);\n+}\n+\n+\n+/* These are the local work structures used to determine the best place to \n+   insert the copies that were placed on edges by the SSA->normal pass..  */\n+static varray_type edge_leader = NULL;\n+static varray_type GTY(()) stmt_list = NULL;\n+static bitmap leader_has_match = NULL;\n+static edge leader_match = NULL;\n+\n+\n+/* Pass this function to make_forwarder_block so that all the edges with\n+   matching PENDING_STMT lists to 'curr_stmt_list' get redirected.  */\n+static bool \n+same_stmt_list_p (edge e)\n+{\n+  return (e->aux == (PTR) leader_match) ? true : false;\n+}\n+\n+\n+/* Return TRUE if S1 and S2 are equivalent copies.  */\n+static inline bool\n+identical_copies_p (tree s1, tree s2)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (TREE_CODE (s1) == MODIFY_EXPR);\n+  gcc_assert (TREE_CODE (s2) == MODIFY_EXPR);\n+  gcc_assert (DECL_P (TREE_OPERAND (s1, 0)));\n+  gcc_assert (DECL_P (TREE_OPERAND (s2, 0)));\n+#endif\n+\n+  if (TREE_OPERAND (s1, 0) != TREE_OPERAND (s2, 0))\n+    return false;\n+\n+  s1 = TREE_OPERAND (s1, 1);\n+  s2 = TREE_OPERAND (s2, 1);\n+\n+  if (s1 != s2)\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Compare the PENDING_STMT list for two edges, and return true if the lists\n+   contain the same sequence of copies.  */\n+\n+static inline bool \n+identical_stmt_lists_p (edge e1, edge e2)\n+{\n+  tree t1 = PENDING_STMT (e1);\n+  tree t2 = PENDING_STMT (e2);\n+  tree_stmt_iterator tsi1, tsi2;\n+\n+  gcc_assert (TREE_CODE (t1) == STATEMENT_LIST);\n+  gcc_assert (TREE_CODE (t2) == STATEMENT_LIST);\n+\n+  for (tsi1 = tsi_start (t1), tsi2 = tsi_start (t2);\n+       !tsi_end_p (tsi1) && !tsi_end_p (tsi2); \n+       tsi_next (&tsi1), tsi_next (&tsi2))\n+    {\n+      if (!identical_copies_p (tsi_stmt (tsi1), tsi_stmt (tsi2)))\n+        break;\n+    }\n+\n+  if (!tsi_end_p (tsi1) || ! tsi_end_p (tsi2))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Look at all the incoming edges to block BB, and decide where the best place\n+   to insert the stmts on each edge are, and perform those insertions.   Output\n+   any debug information to DEBUG_FILE.  Return true if anything other than a \n+   standard edge insertion is done.  */\n+\n+static bool \n+analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  int count;\n+  unsigned int x;\n+  bool have_opportunity;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n+  edge single_edge = NULL;\n+  bool is_label;\n+\n+  count = 0;\n+  /* Find out how many edges there are with interesting pending stmts on them.  \n+     Commit the stmts on edges we are not interested in.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (PENDING_STMT (e))\n+        {\n+\t  gcc_assert (!(e->flags & EDGE_ABNORMAL));\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    {\n+\t      bsi = bsi_start (e->src);\n+\t      if (!bsi_end_p (bsi))\n+\t        {\n+\t\t  stmt = bsi_stmt (bsi);\n+\t\t  bsi_next (&bsi);\n+\t\t  gcc_assert (stmt != NULL_TREE);\n+\t\t  is_label = (TREE_CODE (stmt) == LABEL_EXPR);\n+\t\t  /* Punt if it has non-label stmts, or isn't local.  */\n+\t\t  if (!is_label || DECL_NONLOCAL (TREE_OPERAND (stmt, 0)) \n+\t\t      || !bsi_end_p (bsi))\n+\t\t    {\n+\t\t      bsi_commit_one_edge_insert (e, NULL);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  single_edge = e;\n+\t  count++;\n+\t}\n+    }\n+\n+  /* If there aren't at least 2 edges, no sharing will happen.  */\n+  if (count < 2)\n+    {\n+      if (single_edge)\n+        bsi_commit_one_edge_insert (single_edge, NULL);\n+      return false;\n+    }\n+\n+  /* Ensure that we have empty worklists.  */\n+  if (edge_leader == NULL)\n+    {\n+      VARRAY_EDGE_INIT (edge_leader, 25, \"edge_leader\");\n+      VARRAY_TREE_INIT (stmt_list, 25, \"stmt_list\");\n+      leader_has_match = BITMAP_XMALLOC ();\n+    }\n+  else\n+    {\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (VARRAY_ACTIVE_SIZE (edge_leader) == 0);\n+      gcc_assert (VARRAY_ACTIVE_SIZE (stmt_list) == 0);\n+      gcc_assert (bitmap_first_set_bit (leader_has_match) == -1);\n+#endif\n+    }\n+\n+  /* Find the \"leader\" block for each set of unique stmt lists.  Preference is\n+     given to FALLTHRU blocks since they would need a GOTO to arrive at another\n+     block.  The leader edge destination is the block which all the other edges\n+     with the same stmt list will be redirected to.  */\n+  have_opportunity = false;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (PENDING_STMT (e))\n+\t{\n+\t  bool found = false;\n+\n+\t  /* Look for the same stmt list in edge leaders list.  */\n+\t  for (x = 0; x < VARRAY_ACTIVE_SIZE (edge_leader); x++)\n+\t    {\n+\t      edge leader = VARRAY_EDGE (edge_leader, x);\n+\t      if (identical_stmt_lists_p (leader, e))\n+\t\t{\n+\t\t  /* Give this edge the same stmt list pointer.  */\n+\t\t  PENDING_STMT (e) = NULL;\n+\t\t  e->aux = leader;\n+\t\t  bitmap_set_bit (leader_has_match, x);\n+\t\t  have_opportunity = found = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* If no similar stmt list, add this edge to the leader list.  */\n+\t  if (!found)\n+\t    {\n+\t      VARRAY_PUSH_EDGE (edge_leader, e);\n+\t      VARRAY_PUSH_TREE (stmt_list, PENDING_STMT (e));\n+\t    }\n+\t}\n+     }\n+\n+  /* If there are no similar lists, just issue the stmts.  */\n+  if (!have_opportunity)\n+    {\n+      for (x = 0; x < VARRAY_ACTIVE_SIZE (edge_leader); x++)\n+\tbsi_commit_one_edge_insert (VARRAY_EDGE (edge_leader, x), NULL);\n+      VARRAY_POP_ALL (edge_leader);\n+      VARRAY_POP_ALL (stmt_list);\n+      bitmap_clear (leader_has_match);\n+      return false;\n+    }\n+\n+\n+  if (debug_file)\n+    fprintf (debug_file, \"\\nOpportunities in BB %d for stmt/block reduction:\\n\",\n+\t     bb->index);\n+\n+  \n+  /* For each common list, create a forwarding block and issue the stmt's\n+     in that block.  */\n+  for (x = 0 ; x < VARRAY_ACTIVE_SIZE (edge_leader); x++)\n+    if (bitmap_bit_p (leader_has_match, x))\n+      {\n+\tedge new_edge, leader_edge;\n+\tblock_stmt_iterator bsi;\n+\ttree curr_stmt_list;\n+\n+\tleader_match = leader_edge = VARRAY_EDGE (edge_leader, x);\n+\n+\t/* The tree_* cfg manipulation routines use the PENDING_EDGE field\n+\t   for various PHI manipulations, so it gets cleared whhen calls are \n+\t   made to make_forwarder_block(). So make sure the edge is clear, \n+\t   and use the saved stmt list.  */\n+\tPENDING_STMT (leader_edge) = NULL;\n+\tleader_edge->aux = leader_edge;\n+\tcurr_stmt_list = VARRAY_TREE (stmt_list, x);\n+\n+        new_edge = make_forwarder_block (leader_edge->dest, same_stmt_list_p, \n+\t\t\t\t\t NULL);\n+\tbb = new_edge->dest;\n+\tif (debug_file)\n+\t  {\n+\t    fprintf (debug_file, \"Splitting BB %d for Common stmt list.  \", \n+\t\t     leader_edge->dest->index);\n+\t    fprintf (debug_file, \"Original block is now BB%d.\\n\", bb->index);\n+\t    print_generic_stmt (debug_file, curr_stmt_list, TDF_VOPS);\n+\t  }\n+\n+\tFOR_EACH_EDGE (e, ei, new_edge->src->preds)\n+\t  {\n+\t    e->aux = NULL;\n+\t    if (debug_file)\n+\t      fprintf (debug_file, \"  Edge (%d->%d) lands here.\\n\", \n+\t\t       e->src->index, e->dest->index);\n+\t  }\n+\n+\tbsi = bsi_last (leader_edge->dest);\n+\tbsi_insert_after (&bsi, curr_stmt_list, BSI_NEW_STMT);\n+\n+\tleader_match = NULL;\n+\t/* We should never get a new block now.  */\n+      }\n+    else\n+      {\n+        e = VARRAY_EDGE (edge_leader, x);\n+\tPENDING_STMT (e) = VARRAY_TREE (stmt_list, x);\n+\tbsi_commit_one_edge_insert (e, NULL);\n+      }\n+\n+   \n+  /* Clear the working data structures.  */\n+  VARRAY_POP_ALL (edge_leader);\n+  VARRAY_POP_ALL (stmt_list);\n+  bitmap_clear (leader_has_match);\n+\n+  return true;\n+}\n+\n+\n+/* This function will analyze the insertions which were performed on edges,\n+   and decide whether they should be left on that edge, or whether it is more\n+   efficient to emit some subset of them in a single block.  All stmts are\n+   inserted somewhere, and if non-NULL, debug information is printed via \n+   DUMP_FILE.  */\n+\n+static void\n+perform_edge_inserts (FILE *dump_file)\n+{\n+  basic_block bb;\n+  bool changed = false;\n+\n+  if (dump_file)\n+    fprintf(dump_file, \"Analyzing Edge Insertions.\\n\");\n+\n+  FOR_EACH_BB (bb)\n+    changed |= analyze_edges_for_bb (bb, dump_file);\n+\n+  changed |= analyze_edges_for_bb (EXIT_BLOCK_PTR, dump_file);\n+\n+  /* Clear out any tables which were created.  */\n+  edge_leader = NULL;\n+  if (leader_has_match != NULL)\n+    {\n+      free (leader_has_match);\n+      leader_has_match = NULL;\n+    }\n \n-  /* If any copies were inserted on edges, actually insert them now.  */\n-  bsi_commit_edge_inserts (NULL);\n+  if (changed)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  {\n+    edge_iterator ei;\n+    edge e;\n+    FOR_EACH_BB (bb)\n+      {\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  {\n+\t    if (PENDING_STMT (e))\n+\t      error (\" Pending stmts not issued on PRED edge (%d, %d)\\n\", \n+\t\t     e->src->index, e->dest->index);\n+\t  }\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  {\n+\t    if (PENDING_STMT (e))\n+\t      error (\" Pending stmts not issued on SUCC edge (%d, %d)\\n\", \n+\t\t     e->src->index, e->dest->index);\n+\t  }\n+      }\n+    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+      {\n+\tif (PENDING_STMT (e))\n+\t  error (\" Pending stmts not issued on ENTRY edge (%d, %d)\\n\", \n+\t\t e->src->index, e->dest->index);\n+      }\n+    FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      {\n+\tif (PENDING_STMT (e))\n+\t  error (\" Pending stmts not issued on EXIT edge (%d, %d)\\n\", \n+\t\t e->src->index, e->dest->index);\n+      }\n+  }\n+#endif\n }\n \n \n@@ -2022,6 +2344,9 @@ remove_ssa_form (FILE *dump, var_map map, int flags)\n \t}\n     }\n \n+  /* If any copies were inserted on edges, analyze and insert them now.  */\n+  perform_edge_inserts (dump_file);\n+\n   dump_file = save;\n }\n "}]}