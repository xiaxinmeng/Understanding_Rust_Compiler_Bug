{"sha": "10c5d1a0a8cf531acc940ca357894e807f1b90d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjNWQxYTBhOGNmNTMxYWNjOTQwY2EzNTc4OTRlODA3ZjFiOTBkOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-03-21T13:05:14Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-03-21T13:05:14Z"}, "message": "trans.c (addressable_p): Add notes on addressability issues.\n\n\t* trans.c (addressable_p): Add notes on addressability issues.\n\nFrom-SVN: r133421", "tree": {"sha": "c697ce43e2471d08f1f097b69d41aa87ee766363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c697ce43e2471d08f1f097b69d41aa87ee766363"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c5d1a0a8cf531acc940ca357894e807f1b90d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c5d1a0a8cf531acc940ca357894e807f1b90d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c5d1a0a8cf531acc940ca357894e807f1b90d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c5d1a0a8cf531acc940ca357894e807f1b90d8/comments", "author": null, "committer": null, "parents": [{"sha": "457b629a354c9be68bc92eafb870b89a520799d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457b629a354c9be68bc92eafb870b89a520799d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457b629a354c9be68bc92eafb870b89a520799d3"}], "stats": {"total": 61, "additions": 59, "deletions": 2}, "files": [{"sha": "a108d89ebfb6f6bb751c6ba0058d386f63118627", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c5d1a0a8cf531acc940ca357894e807f1b90d8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c5d1a0a8cf531acc940ca357894e807f1b90d8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=10c5d1a0a8cf531acc940ca357894e807f1b90d8", "patch": "@@ -1,3 +1,7 @@\n+2008-03-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* trans.c (addressable_p): Add notes on addressability issues.\n+\n 2008-03-21  Olivier Hainque  <hainque@adacore.com>\n             Ed Schonberg  <schonberg@adacore.com>\n "}, {"sha": "9e59373b375c634cd3d2ec6da04c0d1afabc5f0d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c5d1a0a8cf531acc940ca357894e807f1b90d8/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c5d1a0a8cf531acc940ca357894e807f1b90d8/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=10c5d1a0a8cf531acc940ca357894e807f1b90d8", "patch": "@@ -6089,8 +6089,61 @@ larger_record_type_p (tree record_type, tree type)\n /* Return true if GNU_EXPR can be directly addressed.  This is the case\n    unless it is an expression involving computation or if it involves a\n    reference to a bitfield or to an object not sufficiently aligned for\n-   its type.  If GNU_TYPE is non null, return true only if GNU_EXPR can\n-   be directly addressed as an object of this type.  */\n+   its type.  If GNU_TYPE is non-null, return true only if GNU_EXPR can\n+   be directly addressed as an object of this type.\n+\n+   *** Notes on addressability issues in the Ada compiler ***\n+\n+   This predicate is necessary in order to bridge the gap between Gigi\n+   and the middle-end about addressability of GENERIC trees.  A tree\n+   is said to be addressable if it can be directly addressed, i.e. if\n+   its address can be taken, is a multiple of the type's alignment on\n+   strict-alignment architectures and returns the first storage unit\n+   assigned to the object represented by the tree.\n+\n+   In the C family of languages, everything is in practice addressable\n+   at the language level, except for bit-fields.  This means that these\n+   compilers will take the address of any tree that doesn't represent\n+   a bit-field reference and expect the result to be the first storage\n+   unit assigned to the object.  Even in cases where this will result\n+   in unaligned accesses at run time, nothing is supposed to be done\n+   and the program is considered as erroneous instead (see PR c/18287).\n+\n+   The implicit assumptions made in the middle-end are in keeping with\n+   the C viewpoint described above:\n+     - the address of a bit-field reference is supposed to be never\n+       taken; the compiler (generally) will stop on such a construct,\n+     - any other tree is addressable if it is formally addressable,\n+       i.e. if it is formally allowed to be the operand of ADDR_EXPR.\n+\n+   In Ada, the viewpoint is the opposite one: nothing is addressable\n+   at the language level unless explicitly declared so.  This means\n+   that the compiler will both make sure that the trees representing\n+   references to addressable (\"aliased\" in Ada parlance) objects are\n+   addressable and make no real attempts at ensuring that the trees\n+   representing references to non-addressable objects are addressable.\n+\n+   In the first case, Ada is effectively equivalent to C and handing\n+   down the direct result of applying ADDR_EXPR to these trees to the\n+   middle-end works flawlessly.  In the second case, Ada cannot afford\n+   to consider the program as erroneous if the address of trees that\n+   are not addressable is requested for technical reasons, unlike C;\n+   as a consequence, the Ada compiler must arrange for either making\n+   sure that this address is not requested in the middle-end or for\n+   compensating by inserting temporaries if it is requested in Gigi.\n+\n+   The first goal can be achieved because the middle-end should not\n+   request the address of non-addressable trees on its own; the only\n+   exception is for the invocation of low-level block operations like\n+   memcpy, for which the addressability requirements are lower since\n+   the type's alignment can be disregarded.  In practice, this means\n+   that Gigi must make sure that such operations cannot be applied to\n+   non-BLKmode bit-fields.\n+\n+   The second goal is achieved by means of the addressable_p predicate\n+   and by inserting SAVE_EXPRs around trees deemed non-addressable.\n+   They will be turned during gimplification into proper temporaries\n+   whose address will be used in lieu of that of the original tree.  */\n \n static bool\n addressable_p (tree gnu_expr, tree gnu_type)"}]}