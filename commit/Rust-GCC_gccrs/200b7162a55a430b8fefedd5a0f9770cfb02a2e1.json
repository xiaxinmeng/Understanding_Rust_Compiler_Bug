{"sha": "200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwYjcxNjJhNTVhNDMwYjhmZWZlZGQ1YTBmOTc3MGNmYjAyYTJlMQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2011-10-13T10:37:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:37:33Z"}, "message": "exp_ch6.ads (BIP_Storage_Pool): New \"extra implicit parameter\" that gets passed in the same cases where...\n\n2011-10-13  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.ads (BIP_Storage_Pool): New \"extra implicit parameter\"\n\tthat gets passed in the same cases where BIP_Alloc_Form is passed\n\t(caller-unknown-size results). BIP_Storage_Pool is used when\n\tBIP_Alloc_Form = User_Storage_Pool.  In that case, a pointer\n\tto the user-defined storage pool is passed at the call site,\n\tand this pool is used in callee to allocate the result.\n\t* exp_ch6.adb (Add_Unconstrained_Actuals_To_Build_In_Place_Call): New\n\tversion of Add_Alloc_Form_Actual_To_Build_In_Place_Call. Passes\n\tthe additional BIP_Storage_Pool actual.\n\t(Expand_N_Extended_Return_Statement): Allocate the function\n\tresult using the user-defined storage pool, if BIP_Alloc_Form =\n\tUser_Storage_Pool.\n\t* sem_ch6.adb: Add the \"extra formal\" for BIP_Storage_Pool.\n\t* exp_ch4.adb: Don't overwrite storage pool set by\n\tExpand_N_Extended_Return_Statement.\n\t* s-stopoo.ads, rtsfind.ads (Root_Storage_Pool_Ptr): New type,\n\tfor use in build-in-place function calls within allocators\n\twhere the access type has a user-defined storage pool.\n\nFrom-SVN: r179903", "tree": {"sha": "f5ced87e3f9f879a7bb3f9307840a47ec4111780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5ced87e3f9f879a7bb3f9307840a47ec4111780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f8d1e5ca55ca37137adf9d89dda0080238b1baf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f8d1e5ca55ca37137adf9d89dda0080238b1baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f8d1e5ca55ca37137adf9d89dda0080238b1baf"}], "stats": {"total": 252, "additions": 193, "deletions": 59}, "files": [{"sha": "61da1c3f507662a64ef88d2690fff009af5f72bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -1,3 +1,24 @@\n+2011-10-13  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.ads (BIP_Storage_Pool): New \"extra implicit parameter\"\n+\tthat gets passed in the same cases where BIP_Alloc_Form is passed\n+\t(caller-unknown-size results). BIP_Storage_Pool is used when\n+\tBIP_Alloc_Form = User_Storage_Pool.  In that case, a pointer\n+\tto the user-defined storage pool is passed at the call site,\n+\tand this pool is used in callee to allocate the result.\n+\t* exp_ch6.adb (Add_Unconstrained_Actuals_To_Build_In_Place_Call): New\n+\tversion of Add_Alloc_Form_Actual_To_Build_In_Place_Call. Passes\n+\tthe additional BIP_Storage_Pool actual.\n+\t(Expand_N_Extended_Return_Statement): Allocate the function\n+\tresult using the user-defined storage pool, if BIP_Alloc_Form =\n+\tUser_Storage_Pool.\n+\t* sem_ch6.adb: Add the \"extra formal\" for BIP_Storage_Pool.\n+\t* exp_ch4.adb: Don't overwrite storage pool set by\n+\tExpand_N_Extended_Return_Statement.\n+\t* s-stopoo.ads, rtsfind.ads (Root_Storage_Pool_Ptr): New type,\n+\tfor use in build-in-place function calls within allocators\n+\twhere the access type has a user-defined storage pool.\n+\n 2011-10-13  Sergey Rybin  <rybin@adacore.com>\n \n \t* gnat_ugn.texi, vms_data.ads: Add an option to control enumeration"}, {"sha": "638c79028436b2694388a3644749c1ce876afe46", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -3526,23 +3526,28 @@ package body Exp_Ch4 is\n       end if;\n \n       --  Set the storage pool and find the appropriate version of Allocate to\n-      --  call.\n+      --  call. But don't overwrite the storage pool if it is already set,\n+      --  which can happen for build-in-place function returns (see\n+      --  Exp_Ch4.Expand_N_Extended_Return_Statement).\n \n-      Pool := Associated_Storage_Pool (Root_Type (PtrT));\n-      Set_Storage_Pool (N, Pool);\n+      if No (Storage_Pool (N)) then\n+         Pool := Associated_Storage_Pool (Root_Type (PtrT));\n \n-      if Present (Pool) then\n-         if Is_RTE (Pool, RE_SS_Pool) then\n-            if VM_Target = No_VM then\n-               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n-            end if;\n+         if Present (Pool) then\n+            Set_Storage_Pool (N, Pool);\n \n-         elsif Is_Class_Wide_Type (Etype (Pool)) then\n-            Set_Procedure_To_Call (N, RTE (RE_Allocate_Any));\n+            if Is_RTE (Pool, RE_SS_Pool) then\n+               if VM_Target = No_VM then\n+                  Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n+               end if;\n \n-         else\n-            Set_Procedure_To_Call (N,\n-              Find_Prim_Op (Etype (Pool), Name_Allocate));\n+            elsif Is_Class_Wide_Type (Etype (Pool)) then\n+               Set_Procedure_To_Call (N, RTE (RE_Allocate_Any));\n+\n+            else\n+               Set_Procedure_To_Call (N,\n+                 Find_Prim_Op (Etype (Pool), Name_Allocate));\n+            end if;\n          end if;\n       end if;\n "}, {"sha": "e7b04a3beb3172a5783dc366f375877e67a1566b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 124, "deletions": 39, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -94,15 +94,18 @@ package body Exp_Ch6 is\n    --  along directly to the build-in-place function. Finally, if Return_Object\n    --  is empty, then pass a null literal as the actual.\n \n-   procedure Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+   procedure Add_Unconstrained_Actuals_To_Build_In_Place_Call\n      (Function_Call  : Node_Id;\n       Function_Id    : Entity_Id;\n       Alloc_Form     : BIP_Allocation_Form := Unspecified;\n-      Alloc_Form_Exp : Node_Id             := Empty);\n-   --  Ada 2005 (AI-318-02): Add an actual indicating the form of allocation,\n-   --  if any, to be done by a build-in-place function. If Alloc_Form_Exp is\n-   --  present, then use it, otherwise pass a literal corresponding to the\n-   --  Alloc_Form parameter (which must not be Unspecified in that case).\n+      Alloc_Form_Exp : Node_Id             := Empty;\n+      Pool_Actual    : Node_Id             := Make_Null (No_Location));\n+   --  Ada 2005 (AI-318-02): Add the actuals needed for a build-in-place\n+   --  function call that returns a caller-unknown-size result (BIP_Alloc_Form\n+   --  and BIP_Storage_Pool). If Alloc_Form_Exp is present, then use it,\n+   --  otherwise pass a literal corresponding to the Alloc_Form parameter\n+   --  (which must not be Unspecified in that case). Pool_Actual is the\n+   --  parameter to pass to BIP_Storage_Pool.\n \n    procedure Add_Finalization_Master_Actual_To_Build_In_Place_Call\n      (Func_Call  : Node_Id;\n@@ -252,18 +255,20 @@ package body Exp_Ch6 is\n    end Add_Access_Actual_To_Build_In_Place_Call;\n \n    --------------------------------------------------\n-   -- Add_Alloc_Form_Actual_To_Build_In_Place_Call --\n+   -- Add_Unconstrained_Actuals_To_Build_In_Place_Call --\n    --------------------------------------------------\n \n-   procedure Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+   procedure Add_Unconstrained_Actuals_To_Build_In_Place_Call\n      (Function_Call  : Node_Id;\n       Function_Id    : Entity_Id;\n       Alloc_Form     : BIP_Allocation_Form := Unspecified;\n-      Alloc_Form_Exp : Node_Id             := Empty)\n+      Alloc_Form_Exp : Node_Id             := Empty;\n+      Pool_Actual    : Node_Id             := Make_Null (No_Location))\n    is\n       Loc               : constant Source_Ptr := Sloc (Function_Call);\n       Alloc_Form_Actual : Node_Id;\n       Alloc_Form_Formal : Node_Id;\n+      Pool_Formal       : Node_Id;\n \n    begin\n       --  The allocation form generally doesn't need to be passed in the case\n@@ -305,7 +310,15 @@ package body Exp_Ch6 is\n \n       Add_Extra_Actual_To_Call\n         (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n-   end Add_Alloc_Form_Actual_To_Build_In_Place_Call;\n+\n+      --  Pass the Storage_Pool parameter\n+\n+      Pool_Formal := Build_In_Place_Formal (Function_Id, BIP_Storage_Pool);\n+      Analyze_And_Resolve (Pool_Actual, Etype (Pool_Formal));\n+      Add_Extra_Actual_To_Call\n+        (Function_Call, Pool_Formal, Pool_Actual);\n+\n+   end Add_Unconstrained_Actuals_To_Build_In_Place_Call;\n \n    -----------------------------------------------------------\n    -- Add_Finalization_Master_Actual_To_Build_In_Place_Call --\n@@ -541,6 +554,8 @@ package body Exp_Ch6 is\n       case Kind is\n          when BIP_Alloc_Form          =>\n             return \"BIPalloc\";\n+         when BIP_Storage_Pool          =>\n+            return \"BIPstoragepool\";\n          when BIP_Finalization_Master =>\n             return \"BIPfinalizationmaster\";\n          when BIP_Master              =>\n@@ -4638,11 +4653,12 @@ package body Exp_Ch6 is\n          Alloc_Expr : Node_Id) return Node_Id\n       is\n       begin\n+         pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+\n          --  Processing for build-in-place object allocation. This is disabled\n          --  on .NET/JVM because the targets do not support pools.\n \n          if VM_Target = No_VM\n-           and then Is_Build_In_Place_Function (Func_Id)\n            and then Needs_Finalization (Ret_Typ)\n          then\n             declare\n@@ -5121,8 +5137,12 @@ package body Exp_Ch6 is\n                      Alloc_Obj_Id   : Entity_Id;\n                      Alloc_Obj_Decl : Node_Id;\n                      Alloc_If_Stmt  : Node_Id;\n-                     Heap_Allocator : Node_Id;\n                      SS_Allocator   : Node_Id;\n+                     Heap_Allocator : Node_Id;\n+\n+                     Pool_Decl      : Node_Id;\n+                     Pool_Allocator : Node_Id;\n+                     Pool_Id : constant Entity_Id := Make_Temporary (Loc, 'P');\n \n                   begin\n                      --  Reuse the itype created for the function's implicit\n@@ -5216,6 +5236,25 @@ package body Exp_Ch6 is\n                         Set_No_Initialization (Heap_Allocator);\n                      end if;\n \n+                     --  The Pool_Allocator is just like the Heap_Allocator,\n+                     --  except we set Storage_Pool and Procedure_To_Call so it\n+                     --  will use the user-defined storage pool.\n+\n+                     Pool_Allocator := New_Copy_Tree (Heap_Allocator);\n+                     Pool_Decl :=\n+                       Make_Object_Renaming_Declaration (Loc,\n+                         Defining_Identifier => Pool_Id,\n+                         Subtype_Mark        =>\n+                           New_Reference_To (RTE (RE_Root_Storage_Pool), Loc),\n+                         Name                =>\n+                           Make_Explicit_Dereference (Loc,\n+                             New_Reference_To\n+                               (Build_In_Place_Formal\n+                                  (Par_Func, BIP_Storage_Pool), Loc)));\n+                     Set_Storage_Pool (Pool_Allocator, Pool_Id);\n+                     Set_Procedure_To_Call\n+                       (Pool_Allocator, RTE (RE_Allocate_Any));\n+\n                      --  If the No_Allocators restriction is active, then only\n                      --  an allocator for secondary stack allocation is needed.\n                      --  It's OK for such allocators to have Comes_From_Source\n@@ -5225,22 +5264,25 @@ package body Exp_Ch6 is\n                      if Restriction_Active (No_Allocators) then\n                         SS_Allocator   := Heap_Allocator;\n                         Heap_Allocator := Make_Null (Loc);\n+                        Pool_Allocator := Make_Null (Loc);\n \n-                     --  Otherwise the heap allocator may be needed, so we make\n-                     --  another allocator for secondary stack allocation.\n+                     --  Otherwise the heap and pool allocators may be needed,\n+                     --  so we make another allocator for secondary stack\n+                     --  allocation.\n \n                      else\n                         SS_Allocator := New_Copy_Tree (Heap_Allocator);\n \n-                        --  The heap allocator is marked Comes_From_Source\n-                        --  since it corresponds to an explicit user-written\n-                        --  allocator (that is, it will only be executed on\n-                        --  behalf of callers that call the function as\n-                        --  initialization for such an allocator). This\n-                        --  prevents errors when No_Implicit_Heap_Allocations\n-                        --  is in force.\n+                        --  The heap and pool allocators are marked\n+                        --  Comes_From_Source since they correspond to an\n+                        --  explicit user-written allocator (that is, it will\n+                        --  only be executed on behalf of callers that call the\n+                        --  function as initialization for such an\n+                        --  allocator). This prevents errors when\n+                        --  No_Implicit_Heap_Allocations is in force.\n \n                         Set_Comes_From_Source (Heap_Allocator, True);\n+                        Set_Comes_From_Source (Pool_Allocator, True);\n                      end if;\n \n                      --  The allocator is returned on the secondary stack. We\n@@ -5269,10 +5311,12 @@ package body Exp_Ch6 is\n \n                      --  Create an if statement to test the BIP_Alloc_Form\n                      --  formal and initialize the access object to either the\n-                     --  BIP_Object_Access formal (BIP_Alloc_Form = 0), the\n-                     --  result of allocating the object in the secondary stack\n-                     --  (BIP_Alloc_Form = 1), or else an allocator to create\n-                     --  the return object in the heap (BIP_Alloc_Form = 2).\n+                     --  BIP_Object_Access formal (BIP_Alloc_Form =\n+                     --  Caller_Allocation), the result of allocating the\n+                     --  object in the secondary stack (BIP_Alloc_Form =\n+                     --  Secondary_Stack), or else an allocator to create the\n+                     --  return object in the heap or user-defined pool\n+                     --  (BIP_Alloc_Form = Global_Heap or User_Storage_Pool).\n \n                      --  ??? An unchecked type conversion must be made in the\n                      --  case of assigning the access object formal to the\n@@ -5320,15 +5364,34 @@ package body Exp_Ch6 is\n                                Make_Assignment_Statement (Loc,\n                                  Name       =>\n                                    New_Reference_To (Alloc_Obj_Id, Loc),\n-                                 Expression => SS_Allocator)))),\n+                                 Expression => SS_Allocator))),\n+\n+                           Make_Elsif_Part (Loc,\n+                             Condition =>\n+                               Make_Op_Eq (Loc,\n+                                 Left_Opnd  =>\n+                                   New_Reference_To (Obj_Alloc_Formal, Loc),\n+                                 Right_Opnd =>\n+                                   Make_Integer_Literal (Loc,\n+                                     UI_From_Int (BIP_Allocation_Form'Pos\n+                                                    (Global_Heap)))),\n+\n+                             Then_Statements => New_List (\n+                               Build_Heap_Allocator\n+                                 (Temp_Id    => Alloc_Obj_Id,\n+                                  Temp_Typ   => Ref_Type,\n+                                  Func_Id    => Par_Func,\n+                                  Ret_Typ    => Return_Obj_Typ,\n+                                  Alloc_Expr => Heap_Allocator)))),\n \n                          Else_Statements => New_List (\n+                           Pool_Decl,\n                            Build_Heap_Allocator\n                              (Temp_Id    => Alloc_Obj_Id,\n                               Temp_Typ   => Ref_Type,\n                               Func_Id    => Par_Func,\n                               Ret_Typ    => Return_Obj_Typ,\n-                              Alloc_Expr => Heap_Allocator)));\n+                              Alloc_Expr => Pool_Allocator)));\n \n                      --  If a separate initialization assignment was created\n                      --  earlier, append that following the assignment of the\n@@ -7592,7 +7655,7 @@ package body Exp_Ch6 is\n          --  called as a dispatching operation and must be treated similarly\n          --  to functions with unconstrained result subtypes.\n \n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n          Add_Finalization_Master_Actual_To_Build_In_Place_Call\n@@ -7623,11 +7686,29 @@ package body Exp_Ch6 is\n       --  operations. ???\n \n       else\n-         --  Pass an allocation parameter indicating that the function should\n-         --  allocate its result on the heap.\n+         --  No user-defined pool; pass an allocation parameter indicating that\n+         --  the function should allocate its result on the heap.\n+\n+         if No (Associated_Storage_Pool (Acc_Type)) then\n \n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+\n+         --  User-defined pool; pass an allocation parameter indicating that\n+         --  the function should allocate its result in the pool, and pass the\n+         --  pool.  We need 'Unrestricted_Access here, because 'Access is\n+         --  illegal, because the storage pool is not aliased.\n+\n+         else\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => User_Storage_Pool,\n+               Pool_Actual =>\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     New_Reference_To\n+                       (Associated_Storage_Pool (Acc_Type), Loc),\n+                   Attribute_Name => Name_Unrestricted_Access));\n+         end if;\n \n          Add_Finalization_Master_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Acc_Type);\n@@ -7796,7 +7877,7 @@ package body Exp_Ch6 is\n          --  called as a dispatching operation and must be treated similarly\n          --  to functions with unconstrained result subtypes.\n \n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n          Add_Finalization_Master_Actual_To_Build_In_Place_Call\n@@ -7820,7 +7901,7 @@ package body Exp_Ch6 is\n          --  Pass an allocation parameter indicating that the function should\n          --  allocate its result on the secondary stack.\n \n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n \n          Add_Finalization_Master_Actual_To_Build_In_Place_Call\n@@ -7898,7 +7979,7 @@ package body Exp_Ch6 is\n       --  controlling result, because dispatching calls to the function needs\n       --  to be treated effectively the same as calls to class-wide functions.\n \n-      Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+      Add_Unconstrained_Actuals_To_Build_In_Place_Call\n         (Func_Call, Func_Id, Alloc_Form => Caller_Allocation);\n \n       Add_Finalization_Master_Actual_To_Build_In_Place_Call\n@@ -8047,19 +8128,23 @@ package body Exp_Ch6 is\n          --  has an unconstrained or tagged result type).\n \n          if Needs_BIP_Alloc_Form (Enclosing_Func) then\n-            Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n               (Func_Call,\n                Function_Id,\n                Alloc_Form_Exp =>\n                  New_Reference_To\n                    (Build_In_Place_Formal (Enclosing_Func, BIP_Alloc_Form),\n+                    Loc),\n+               Pool_Actual =>\n+                 New_Reference_To\n+                   (Build_In_Place_Formal (Enclosing_Func, BIP_Storage_Pool),\n                     Loc));\n \n          --  Otherwise, if enclosing function has a constrained result subtype,\n          --  then caller allocation will be used.\n \n          else\n-            Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+            Add_Unconstrained_Actuals_To_Build_In_Place_Call\n               (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n          end if;\n \n@@ -8102,7 +8187,7 @@ package body Exp_Ch6 is\n          --  called as a dispatching operation and must be treated similarly\n          --  to functions with unconstrained result subtypes.\n \n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n       --  In other unconstrained cases, pass an indication to do the allocation\n@@ -8111,7 +8196,7 @@ package body Exp_Ch6 is\n       --  scope is established to ensure eventual cleanup of the result.\n \n       else\n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+         Add_Unconstrained_Actuals_To_Build_In_Place_Call\n            (Func_Call,\n             Function_Id,\n             Alloc_Form => Secondary_Stack);"}, {"sha": "8c278680a403b83bea97d6b6d25e038f24d8d07e", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -88,15 +88,20 @@ package Exp_Ch6 is\n \n    type BIP_Formal_Kind is\n    --  Ada 2005 (AI-318-02): This type defines the kinds of implicit extra\n-   --  formals created for build-in-place functions. The order of the above\n+   --  formals created for build-in-place functions. The order of these\n    --  enumeration literals matches the order in which the formals are\n    --  declared. See Sem_Ch6.Create_Extra_Formals.\n \n      (BIP_Alloc_Form,\n-      --  Present if result subtype is unconstrained, or if the result type\n-      --  is tagged. Indicates whether the return object is allocated by the\n-      --  caller or callee, and if the callee, whether to use the secondary\n-      --  stack or the heap. See Create_Extra_Formals.\n+      --  Present if result subtype is unconstrained or tagged. Indicates\n+      --  whether the return object is allocated by the caller or callee, and\n+      --  if the callee, whether to use the secondary stack or the heap. See\n+      --  Create_Extra_Formals.\n+\n+      BIP_Storage_Pool,\n+      --  Present if result subtype is unconstrained or tagged. If\n+      --  BIP_Alloc_Form = User_Storage_Pool, this is a pointer to the pool\n+      --  (of type access to Root_Storage_Pool'Class). Otherwise null.\n \n       BIP_Finalization_Master,\n       --  Present if result type needs finalization. Pointer to caller's\n@@ -114,8 +119,7 @@ package Exp_Ch6 is\n       --  the return object, or null if BIP_Alloc_Form indicates allocated by\n       --  callee.\n       --\n-      --  ??? We also need to be able to pass in some way to access a user-\n-      --  defined storage pool at some point. And perhaps a constrained flag.\n+      --  ??? We might also need to be able to pass in a constrained flag.\n \n    function BIP_Formal_Suffix (Kind : BIP_Formal_Kind) return String;\n    --  Ada 2005 (AI-318-02): Returns a string to be used as the suffix of names"}, {"sha": "05247e036dbc0c5ba82390d4b6cf84a6552dede8", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -1346,6 +1346,7 @@ package Rtsfind is\n      RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n \n+     RE_Root_Storage_Pool_Ptr,           -- System.Storage_Pools\n      RE_Allocate_Any,                    -- System.Storage_Pools\n      RE_Deallocate_Any,                  -- System.Storage_Pools\n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n@@ -2542,6 +2543,7 @@ package Rtsfind is\n      RE_Storage_Offset                   => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n \n+     RE_Root_Storage_Pool_Ptr            => System_Storage_Pools,\n      RE_Allocate_Any                     => System_Storage_Pools,\n      RE_Deallocate_Any                   => System_Storage_Pools,\n      RE_Root_Storage_Pool                => System_Storage_Pools,"}, {"sha": "e2d66ff747d78726a2045c0a75d0359cbb2cb1b6", "filename": "gcc/ada/s-stopoo.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fs-stopoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fs-stopoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stopoo.ads?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -65,6 +65,14 @@ private\n    type Root_Storage_Pool is abstract\n      new Ada.Finalization.Limited_Controlled with null record;\n \n+   type Root_Storage_Pool_Ptr is access all Root_Storage_Pool'Class;\n+   for Root_Storage_Pool_Ptr'Storage_Size use 0;\n+   --  Type of the BIP_Storage_Pool extra parameter (see Exp_Ch6). The\n+   --  Storage_Size clause is necessary, because otherwise we have a\n+   --  chicken&egg problem; we can't be creating collection finalization code\n+   --  in this low-level package, because that involves Pool_Global, which\n+   --  imports this package.\n+\n    --  ??? Are these two still needed? It might be possible to use Subpools.\n    --  Allocate_Any_Controlled / Deallocate_Any_Controlled for non-controlled\n    --  objects."}, {"sha": "26dac7789d5bfc79bde7745c88cd4e87c4f70069", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b7162a55a430b8fefedd5a0f9770cfb02a2e1/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=200b7162a55a430b8fefedd5a0f9770cfb02a2e1", "patch": "@@ -6482,6 +6482,15 @@ package body Sem_Ch6 is\n                  Add_Extra_Formal\n                    (E, Standard_Natural,\n                     E, BIP_Formal_Suffix (BIP_Alloc_Form));\n+\n+               --  Whenever we need BIP_Alloc_Form, we also need\n+               --  BIP_Storage_Pool, in case BIP_Alloc_Form indicates to use a\n+               --  user-defined pool.\n+\n+               Discard :=\n+                 Add_Extra_Formal\n+                   (E, RTE (RE_Root_Storage_Pool_Ptr),\n+                    E, BIP_Formal_Suffix (BIP_Storage_Pool));\n             end if;\n \n             --  In the case of functions whose result type needs finalization,"}]}