{"sha": "44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRhNjAyNDQ1OTJkYTAxOTZmN2MxZDhjZmU1NmJjOTVkN2NkYWUwZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-06-24T12:40:17Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-06-24T12:40:17Z"}, "message": "re PR tree-optimization/57539 (ice in ipa_edge_duplication_hook)\n\n2013-06-24  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/57539\n\t* cgraphclones.c (cgraph_clone_node): Add parameter new_inlined_to, set\n\tglobal.inlined_to of the new node to it.  All callers changed.\n\t* ipa-inline-transform.c (clone_inlined_nodes): New variable\n\tinlining_into, pass it to cgraph_clone_node.\n\t* ipa-prop.c (ipa_propagate_indirect_call_infos): Do not call\n\tipa_free_edge_args_substructures.\n\t(ipa_edge_duplication_hook): Only add edges from inlined nodes to\n\trdesc linked list.  Do not assert rdesc edges have inlined caller.\n\tAssert we have found an rdesc in the rdesc list.\n\nFrom-SVN: r200368", "tree": {"sha": "f89f7096e73c7e3897bc706a86a08d49270d459d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f89f7096e73c7e3897bc706a86a08d49270d459d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c5848b89955c3ec45a78630f23d610f13e3e47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5848b89955c3ec45a78630f23d610f13e3e47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c5848b89955c3ec45a78630f23d610f13e3e47b"}], "stats": {"total": 69, "additions": 45, "deletions": 24}, "files": [{"sha": "8e5515236443c2ca5fd6516974247b4d94a63110", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -1,3 +1,16 @@\n+2013-06-24  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/57539\n+\t* cgraphclones.c (cgraph_clone_node): Add parameter new_inlined_to, set\n+\tglobal.inlined_to of the new node to it.  All callers changed.\n+\t* ipa-inline-transform.c (clone_inlined_nodes): New variable\n+\tinlining_into, pass it to cgraph_clone_node.\n+\t* ipa-prop.c (ipa_propagate_indirect_call_infos): Do not call\n+\tipa_free_edge_args_substructures.\n+\t(ipa_edge_duplication_hook): Only add edges from inlined nodes to\n+\trdesc linked list.  Do not assert rdesc edges have inlined caller.\n+\tAssert we have found an rdesc in the rdesc list.\n+\n 2013-06-24  Richard Biener  <rguenther@suse.de>\n \n \t* pointer-set.h (struct pointer_set_t): Move here from"}, {"sha": "1e17cb70e8dbe5a99fc1b6edc259e2d56a80faee", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -715,7 +715,7 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tunsigned, gcov_type, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n \t\t\t\t\tint, bool, vec<cgraph_edge_p>,\n-\t\t\t\t\tbool);\n+\t\t\t\t\tbool, struct cgraph_node *);\n tree clone_function_name (tree decl, const char *);\n struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \t\t\t                          vec<cgraph_edge_p>,"}, {"sha": "f2a57fc1d08ead83fa191cd3c0a40cb2facbb80a", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -167,13 +167,19 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n    function's profile to reflect the fact that part of execution is handled\n    by node.  \n    When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n-   the new clone. Otherwise the caller is responsible for doing so later.  */\n+   the new clone. Otherwise the caller is responsible for doing so later.\n+\n+   If the new node is being inlined into another one, NEW_INLINED_TO should be\n+   the outline function the new one is (even indirectly) inlined to.  All hooks\n+   will see this in node's global.inlined_to, when invoked.  Can be NULL if the\n+   node is not inlined.  */\n \n struct cgraph_node *\n cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t\t   bool update_original,\n \t\t   vec<cgraph_edge_p> redirect_callers,\n-\t\t   bool call_duplication_hook)\n+\t\t   bool call_duplication_hook,\n+\t\t   struct cgraph_node *new_inlined_to)\n {\n   struct cgraph_node *new_node = cgraph_create_empty_node ();\n   struct cgraph_edge *e;\n@@ -195,6 +201,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   new_node->symbol.externally_visible = false;\n   new_node->local.local = true;\n   new_node->global = n->global;\n+  new_node->global.inlined_to = new_inlined_to;\n   new_node->rtl = n->rtl;\n   new_node->count = count;\n   new_node->frequency = n->frequency;\n@@ -307,7 +314,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \n   new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n \t\t\t\tCGRAPH_FREQ_BASE, false,\n-\t\t\t\tredirect_callers, false);\n+\t\t\t\tredirect_callers, false, NULL);\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n      that is not weak also."}, {"sha": "d421c87c2228a39489c51134f57fd4190c9a9adc", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -132,6 +132,13 @@ void\n clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t\t     bool update_original, int *overall_size)\n {\n+  struct cgraph_node *inlining_into;\n+\n+  if (e->caller->global.inlined_to)\n+    inlining_into = e->caller->global.inlined_to;\n+  else\n+    inlining_into = e->caller;\n+\n   if (duplicate)\n     {\n       /* We may eliminate the need for out-of-line copy to be output.\n@@ -167,18 +174,15 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t{\n \t  struct cgraph_node *n;\n \t  n = cgraph_clone_node (e->callee, e->callee->symbol.decl,\n-\t\t\t\t e->count, e->frequency,\n-\t\t\t\t update_original, vNULL, true);\n+\t\t\t\t e->count, e->frequency, update_original,\n+\t\t\t\t vNULL, true, inlining_into);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }\n   else\n     symtab_dissolve_same_comdat_group_list ((symtab_node) e->callee);\n \n-  if (e->caller->global.inlined_to)\n-    e->callee->global.inlined_to = e->caller->global.inlined_to;\n-  else\n-    e->callee->global.inlined_to = e->caller;\n+  e->callee->global.inlined_to = inlining_into;\n \n   /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = e->next_callee)"}, {"sha": "6eede0d35fc150a37b0d3c95298fcf8848e251b6", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -1314,7 +1314,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t  /* We need original clone to copy around.  */\n \t  master_clone = cgraph_clone_node (node, node->symbol.decl,\n \t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t    false, vNULL, true);\n+\t\t\t\t\t    false, vNULL, true, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL);"}, {"sha": "e5e7dd00eeecfab5782bf89ed9000ced6fb50261", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -2684,9 +2684,6 @@ ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n   propagate_controlled_uses (cs);\n   changed = propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n \n-  /* We do not keep jump functions of inlined edges up to date. Better to free\n-     them so we do not access them accidentally.  */\n-  ipa_free_edge_args_substructures (IPA_EDGE_REF (cs));\n   return changed;\n }\n \n@@ -2816,9 +2813,12 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t      dst_rdesc\n \t\t= (struct ipa_cst_ref_desc *) pool_alloc (ipa_refdesc_pool);\n \t      dst_rdesc->cs = dst;\n-\t      dst_rdesc->next_duplicate = src_rdesc->next_duplicate;\n-\t      src_rdesc->next_duplicate = dst_rdesc;\n \t      dst_rdesc->refcount = src_rdesc->refcount;\n+\t      if (dst->caller->global.inlined_to)\n+\t\t{\n+\t\t  dst_rdesc->next_duplicate = src_rdesc->next_duplicate;\n+\t\t  src_rdesc->next_duplicate = dst_rdesc;\n+\t\t}\n \t      dst_jf->value.constant.rdesc = dst_rdesc;\n \t    }\n \t  else\n@@ -2833,13 +2833,10 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t      for (dst_rdesc = src_rdesc->next_duplicate;\n \t\t   dst_rdesc;\n \t\t   dst_rdesc = dst_rdesc->next_duplicate)\n-\t\t{\n-\t\t  gcc_assert (dst_rdesc->cs->caller->global.inlined_to);\n-\t\t  if (dst_rdesc->cs->caller->global.inlined_to\n-\t\t      == dst->caller->global.inlined_to)\n-\t\t    break;\n-\t\t}\n-\n+\t\tif (dst_rdesc->cs->caller->global.inlined_to\n+\t\t    == dst->caller->global.inlined_to)\n+\t\t  break;\n+\t      gcc_assert (dst_rdesc);\n \t      dst_jf->value.constant.rdesc = dst_rdesc;\n \t    }\n \t}"}, {"sha": "4a287f65463f9f7888c591ce04257411403a18e6", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a60244592da0196f7c1d8cfe56bc95d7cdae0e/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=44a60244592da0196f7c1d8cfe56bc95d7cdae0e", "patch": "@@ -955,7 +955,7 @@ input_node (struct lto_file_decl_data *file_data,\n     {\n       node = cgraph_clone_node (cgraph (nodes[clone_ref]), fn_decl,\n \t\t\t\t0, CGRAPH_FREQ_BASE, false,\n-\t\t\t\tvNULL, false);\n+\t\t\t\tvNULL, false, NULL);\n     }\n   else\n     {"}]}