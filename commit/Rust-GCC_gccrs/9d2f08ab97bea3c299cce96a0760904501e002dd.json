{"sha": "9d2f08ab97bea3c299cce96a0760904501e002dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQyZjA4YWI5N2JlYTNjMjk5Y2NlOTZhMDc2MDkwNDUwMWUwMDJkZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:14:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:14:31Z"}, "message": "poly_int: omp_max_vf\n\nThis patch makes omp_max_vf return a polynomial vectorization factor.\nWe then need to be able to stash a polynomial value in\nOMP_CLAUSE_SAFELEN_EXPR too:\n\n   /* If max_vf is non-zero, then we can use only a vectorization factor\n      up to the max_vf we chose.  So stick it into the safelen clause.  */\n\nFor now the cfgloop safelen is still constant though.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* omp-general.h (omp_max_vf): Return a poly_uint64 instead of an int.\n\t* omp-general.c (omp_max_vf): Likewise.\n\t* omp-expand.c (omp_adjust_chunk_size): Update call to omp_max_vf.\n\t(expand_omp_simd): Handle polynomial safelen.\n\t* omp-low.c (omplow_simd_context): Add a default constructor.\n\t(omplow_simd_context::max_vf): Change from int to poly_uint64.\n\t(lower_rec_simd_input_clauses): Update accordingly.\n\t(lower_rec_input_clauses): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256129", "tree": {"sha": "e47f22b11c033a18b86e50ce91d45d804751f54e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e47f22b11c033a18b86e50ce91d45d804751f54e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d2f08ab97bea3c299cce96a0760904501e002dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2f08ab97bea3c299cce96a0760904501e002dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2f08ab97bea3c299cce96a0760904501e002dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2f08ab97bea3c299cce96a0760904501e002dd/comments", "author": null, "committer": null, "parents": [{"sha": "c5126ce8cae4f14194414e266be91fdc4b756807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5126ce8cae4f14194414e266be91fdc4b756807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5126ce8cae4f14194414e266be91fdc4b756807"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "e373f88d5e6384fe16b6b70a44e7a129a992f629", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d2f08ab97bea3c299cce96a0760904501e002dd", "patch": "@@ -1,3 +1,16 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* omp-general.h (omp_max_vf): Return a poly_uint64 instead of an int.\n+\t* omp-general.c (omp_max_vf): Likewise.\n+\t* omp-expand.c (omp_adjust_chunk_size): Update call to omp_max_vf.\n+\t(expand_omp_simd): Handle polynomial safelen.\n+\t* omp-low.c (omplow_simd_context): Add a default constructor.\n+\t(omplow_simd_context::max_vf): Change from int to poly_uint64.\n+\t(lower_rec_simd_input_clauses): Update accordingly.\n+\t(lower_rec_input_clauses): Likewise.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "aa580e2051fbb2f6c8334936794d1bbcc0230f52", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=9d2f08ab97bea3c299cce96a0760904501e002dd", "patch": "@@ -205,8 +205,8 @@ omp_adjust_chunk_size (tree chunk_size, bool simd_schedule)\n   if (!simd_schedule)\n     return chunk_size;\n \n-  int vf = omp_max_vf ();\n-  if (vf == 1)\n+  poly_uint64 vf = omp_max_vf ();\n+  if (known_eq (vf, 1U))\n     return chunk_size;\n \n   tree type = TREE_TYPE (chunk_size);\n@@ -4368,11 +4368,12 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \n   if (safelen)\n     {\n+      poly_uint64 val;\n       safelen = OMP_CLAUSE_SAFELEN_EXPR (safelen);\n-      if (TREE_CODE (safelen) != INTEGER_CST)\n+      if (!poly_int_tree_p (safelen, &val))\n \tsafelen_int = 0;\n-      else if (tree_fits_uhwi_p (safelen) && tree_to_uhwi (safelen) < INT_MAX)\n-\tsafelen_int = tree_to_uhwi (safelen);\n+      else\n+\tsafelen_int = MIN (constant_lower_bound (val), INT_MAX);\n       if (safelen_int == 1)\n \tsafelen_int = 0;\n     }"}, {"sha": "826e1bea642db9a559ac99b18159f3812203c34c", "filename": "gcc/omp-general.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=9d2f08ab97bea3c299cce96a0760904501e002dd", "patch": "@@ -419,7 +419,7 @@ omp_build_barrier (tree lhs)\n \n /* Return maximum possible vectorization factor for the target.  */\n \n-int\n+poly_uint64\n omp_max_vf (void)\n {\n   if (!optimize"}, {"sha": "99a5e1dbd85b42950c1cbdbe04cc83b539e87562", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=9d2f08ab97bea3c299cce96a0760904501e002dd", "patch": "@@ -78,7 +78,7 @@ extern tree omp_get_for_step_from_incr (location_t loc, tree incr);\n extern void omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\t\t\t  struct omp_for_data_loop *loops);\n extern gimple *omp_build_barrier (tree lhs);\n-extern int omp_max_vf (void);\n+extern poly_uint64 omp_max_vf (void);\n extern int omp_max_simt_vf (void);\n extern tree oacc_launch_pack (unsigned code, tree device, unsigned op);\n extern void oacc_replace_fn_attrib (tree fn, tree dims);"}, {"sha": "f6267ece858fe7f85c52bc708c01b42935b006e6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2f08ab97bea3c299cce96a0760904501e002dd/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=9d2f08ab97bea3c299cce96a0760904501e002dd", "patch": "@@ -3417,11 +3417,12 @@ omp_clause_aligned_alignment (tree clause)\n    and lower_rec_input_clauses.  */\n \n struct omplow_simd_context {\n+  omplow_simd_context () { memset (this, 0, sizeof (*this)); }\n   tree idx;\n   tree lane;\n   vec<tree, va_heap> simt_eargs;\n   gimple_seq simt_dlist;\n-  int max_vf;\n+  poly_uint64_pod max_vf;\n   bool is_simt;\n };\n \n@@ -3432,28 +3433,30 @@ static bool\n lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t\t\t      omplow_simd_context *sctx, tree &ivar, tree &lvar)\n {\n-  if (sctx->max_vf == 0)\n+  if (known_eq (sctx->max_vf, 0U))\n     {\n       sctx->max_vf = sctx->is_simt ? omp_max_simt_vf () : omp_max_vf ();\n-      if (sctx->max_vf > 1)\n+      if (maybe_gt (sctx->max_vf, 1U))\n \t{\n \t  tree c = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\t    OMP_CLAUSE_SAFELEN);\n-\t  if (c\n-\t      && (TREE_CODE (OMP_CLAUSE_SAFELEN_EXPR (c)) != INTEGER_CST\n-\t\t  || tree_int_cst_sgn (OMP_CLAUSE_SAFELEN_EXPR (c)) != 1))\n-\t    sctx->max_vf = 1;\n-\t  else if (c && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n-\t\t\t\t\t  sctx->max_vf) == -1)\n-\t    sctx->max_vf = tree_to_shwi (OMP_CLAUSE_SAFELEN_EXPR (c));\n+\t  if (c)\n+\t    {\n+\t      poly_uint64 safe_len;\n+\t      if (!poly_int_tree_p (OMP_CLAUSE_SAFELEN_EXPR (c), &safe_len)\n+\t\t  || maybe_lt (safe_len, 1U))\n+\t\tsctx->max_vf = 1;\n+\t      else\n+\t\tsctx->max_vf = lower_bound (sctx->max_vf, safe_len);\n+\t    }\n \t}\n-      if (sctx->max_vf > 1)\n+      if (maybe_gt (sctx->max_vf, 1U))\n \t{\n \t  sctx->idx = create_tmp_var (unsigned_type_node);\n \t  sctx->lane = create_tmp_var (unsigned_type_node);\n \t}\n     }\n-  if (sctx->max_vf == 1)\n+  if (known_eq (sctx->max_vf, 1U))\n     return false;\n \n   if (sctx->is_simt)\n@@ -3567,7 +3570,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t}\n \n   /* Add a placeholder for simduid.  */\n-  if (sctx.is_simt && sctx.max_vf != 1)\n+  if (sctx.is_simt && maybe_ne (sctx.max_vf, 1U))\n     sctx.simt_eargs.safe_push (NULL_TREE);\n \n   /* Do all the fixed sized types in the first pass, and the variable sized\n@@ -4457,7 +4460,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t}\n     }\n \n-  if (sctx.max_vf == 1)\n+  if (known_eq (sctx.max_vf, 1U))\n     sctx.is_simt = false;\n \n   if (sctx.lane || sctx.is_simt)\n@@ -4594,14 +4597,14 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n   /* If max_vf is non-zero, then we can use only a vectorization factor\n      up to the max_vf we chose.  So stick it into the safelen clause.  */\n-  if (sctx.max_vf)\n+  if (maybe_ne (sctx.max_vf, 0U))\n     {\n       tree c = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\tOMP_CLAUSE_SAFELEN);\n+      poly_uint64 safe_len;\n       if (c == NULL_TREE\n-\t  || (TREE_CODE (OMP_CLAUSE_SAFELEN_EXPR (c)) == INTEGER_CST\n-\t      && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n-\t\t\t\t   sctx.max_vf) == 1))\n+\t  || (poly_int_tree_p (OMP_CLAUSE_SAFELEN_EXPR (c), &safe_len)\n+\t      && maybe_gt (safe_len, sctx.max_vf)))\n \t{\n \t  c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);\n \t  OMP_CLAUSE_SAFELEN_EXPR (c) = build_int_cst (integer_type_node,"}]}