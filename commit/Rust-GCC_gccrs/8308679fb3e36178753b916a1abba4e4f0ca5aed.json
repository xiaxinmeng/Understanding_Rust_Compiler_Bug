{"sha": "8308679fb3e36178753b916a1abba4e4f0ca5aed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMwODY3OWZiM2UzNjE3ODc1M2I5MTZhMWFiYmE0ZTRmMGNhNWFlZA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-09-11T23:22:10Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-09-11T23:22:10Z"}, "message": "re PR rtl-optimization/23098 (store of 0.0 to float)\n\n        PR rtl-optimization/23098\n        * config/rs6000/predicates.md (easy_fp_constant): SFmode constant\n        0.0f is easy.\n        * config/rs6000/rs6000.md (movdf splitter): Use\n        const_double_operand predicate for TARGET_POWERPC64.\n        * config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Expand\n        SYMBOL_REF method to ABI_V4.\n\n        * config/rs6000/altivec.md (build_vector_mask_for_load): Use\n        replace_equiv_address.\n        * config/rs6000/rs6000.c (rs6000_emit_eh_reg_restore): Mark MEM as\n        rs6000_sr_alias_set and MEM_NOTRAP.\n        (rs6000_aix_emit_builtin_unwind_init): Use gen_frame_mem().\n\nFrom-SVN: r104145", "tree": {"sha": "07e99fc71bf4cca4090bb07e1af6a81736580174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07e99fc71bf4cca4090bb07e1af6a81736580174"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8308679fb3e36178753b916a1abba4e4f0ca5aed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8308679fb3e36178753b916a1abba4e4f0ca5aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8308679fb3e36178753b916a1abba4e4f0ca5aed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8308679fb3e36178753b916a1abba4e4f0ca5aed/comments", "author": null, "committer": null, "parents": [{"sha": "4c223d6a3891ddb95111b9a1c430b1875f9ee8fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c223d6a3891ddb95111b9a1c430b1875f9ee8fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c223d6a3891ddb95111b9a1c430b1875f9ee8fd"}], "stats": {"total": 56, "additions": 43, "deletions": 13}, "files": [{"sha": "2501c1a7aeccc2582f230fd475037b670ff46045", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8308679fb3e36178753b916a1abba4e4f0ca5aed", "patch": "@@ -1,3 +1,19 @@\n+2005-09-11  David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR rtl-optimization/23098\n+\t* config/rs6000/predicates.md (easy_fp_constant): SFmode constant\n+\t0.0f is easy.\n+\t* config/rs6000/rs6000.md (movdf splitter): Use\n+\tconst_double_operand predicate for TARGET_POWERPC64.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Expand\n+\tSYMBOL_REF method to ABI_V4.\n+\n+\t* config/rs6000/altivec.md (build_vector_mask_for_load): Use\n+\treplace_equiv_address.\n+\t* config/rs6000/rs6000.c (rs6000_emit_eh_reg_restore): Mark MEM as\n+\trs6000_sr_alias_set and MEM_NOTRAP.\n+\t(rs6000_aix_emit_builtin_unwind_init): Use gen_frame_mem().\n+\n 2005-09-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree.c (contains_placeholder_p) <tcc_expression>: Properly"}, {"sha": "056a8160150449ed428aebc76452d32d45f98404", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=8308679fb3e36178753b916a1abba4e4f0ca5aed", "patch": "@@ -1838,7 +1838,7 @@\n   emit_insn (gen_rtx_SET (VOIDmode, temp, \n \t\t\t  gen_rtx_NEG (GET_MODE (addr), addr)));\n   emit_insn (gen_altivec_lvsr (operands[0], \n-\t\t\t       gen_rtx_MEM (GET_MODE (operands[1]), temp)));\n+\t\t\t       replace_equiv_address (operands[1], temp)));\n   DONE;\n }\")\n "}, {"sha": "ff475053cad9db274d0259552d98436173491263", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8308679fb3e36178753b916a1abba4e4f0ca5aed", "patch": "@@ -235,6 +235,10 @@\n \t      && num_insns_constant_wide ((HOST_WIDE_INT) k[1]) == 1);\n \n     case SFmode:\n+      /* The constant 0.f is easy.  */\n+      if (op == CONST0_RTX (SFmode))\n+\treturn 1;\n+\n       /* Force constants to memory before reload to utilize\n \t compress_float_constant.\n \t Avoid this when flag_unsafe_math_optimizations is enabled"}, {"sha": "44548133e91ff88c8410df74005b02c0c5d2a7bb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8308679fb3e36178753b916a1abba4e4f0ca5aed", "patch": "@@ -3245,16 +3245,21 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       return x;\n     }\n \n-#if TARGET_MACHO\n   if (GET_CODE (x) == SYMBOL_REF\n-      && DEFAULT_ABI == ABI_DARWIN\n       && !ALTIVEC_VECTOR_MODE (mode)\n+#if TARGET_MACHO\n+      && DEFAULT_ABI == ABI_DARWIN\n       && (flag_pic || MACHO_DYNAMIC_NO_PIC_P)\n+#else\n+      && DEFAULT_ABI == ABI_V4\n+      && !flag_pic\n+#endif\n       /* Don't do this for TFmode, since the result isn't offsettable.\n \t The same goes for DImode without 64-bit gprs.  */\n       && mode != TFmode\n       && (mode != DImode || TARGET_POWERPC64))\n     {\n+#if TARGET_MACHO\n       if (flag_pic)\n \t{\n \t  rtx offset = gen_rtx_CONST (Pmode,\n@@ -3265,6 +3270,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \t\t  gen_rtx_HIGH (Pmode, offset)), offset);\n \t}\n       else\n+#endif\n \tx = gen_rtx_LO_SUM (GET_MODE (x),\n \t      gen_rtx_HIGH (Pmode, x), x);\n \n@@ -3274,7 +3280,6 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       *win = 1;\n       return x;\n     }\n-#endif\n \n   /* Reload an offset address wrapped by an AND that represents the\n      masking of the lower bits.  Strip the outer AND and let reload\n@@ -13368,14 +13373,19 @@ rs6000_emit_eh_reg_restore (rtx source, rtx scratch)\n \t  || current_function_calls_alloca\n \t  || info->total_size > 32767)\n \t{\n-\t  emit_move_insn (operands[1], gen_rtx_MEM (Pmode, frame_rtx));\n+\t  tmp = gen_rtx_MEM (Pmode, frame_rtx);\n+\t  MEM_NOTRAP_P (tmp) = 1;\n+\t  set_mem_alias_set (tmp, rs6000_sr_alias_set);\n+\t  emit_move_insn (operands[1], tmp);\n \t  frame_rtx = operands[1];\n \t}\n       else if (info->push_p)\n \tsp_offset = info->total_size;\n \n       tmp = plus_constant (frame_rtx, info->lr_save_offset + sp_offset);\n       tmp = gen_rtx_MEM (Pmode, tmp);\n+      MEM_NOTRAP_P (tmp) = 1;\n+      set_mem_alias_set (tmp, rs6000_sr_alias_set);\n       emit_move_insn (tmp, operands[0]);\n     }\n   else\n@@ -13448,12 +13458,12 @@ rs6000_aix_emit_builtin_unwind_init (void)\n   rtx tocompare = gen_reg_rtx (SImode);\n   rtx no_toc_save_needed = gen_label_rtx ();\n \n-  mem = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n+  mem = gen_frame_mem (Pmode, hard_frame_pointer_rtx);\n   emit_move_insn (stack_top, mem);\n \n-  mem = gen_rtx_MEM (Pmode,\n-\t\t     gen_rtx_PLUS (Pmode, stack_top,\n-\t\t\t\t   GEN_INT (2 * GET_MODE_SIZE (Pmode))));\n+  mem = gen_frame_mem (Pmode,\n+\t\t       gen_rtx_PLUS (Pmode, stack_top,\n+\t\t\t\t     GEN_INT (2 * GET_MODE_SIZE (Pmode))));\n   emit_move_insn (opcode_addr, mem);\n   emit_move_insn (opcode, gen_rtx_MEM (SImode, opcode_addr));\n   emit_move_insn (tocompare, gen_int_mode (TARGET_32BIT ? 0x80410014\n@@ -13463,9 +13473,9 @@ rs6000_aix_emit_builtin_unwind_init (void)\n \t\t\t   SImode, NULL_RTX, NULL_RTX,\n \t\t\t   no_toc_save_needed);\n \n-  mem = gen_rtx_MEM (Pmode,\n-\t\t     gen_rtx_PLUS (Pmode, stack_top,\n-\t\t\t\t   GEN_INT (5 * GET_MODE_SIZE (Pmode))));\n+  mem = gen_frame_mem (Pmode,\n+\t\t       gen_rtx_PLUS (Pmode, stack_top,\n+\t\t\t\t     GEN_INT (5 * GET_MODE_SIZE (Pmode))));\n   emit_move_insn (mem, gen_rtx_REG (Pmode, 2));\n   emit_label (no_toc_save_needed);\n }"}, {"sha": "46381dc59dd06958efad04494b6b006eb6444e9c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8308679fb3e36178753b916a1abba4e4f0ca5aed/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8308679fb3e36178753b916a1abba4e4f0ca5aed", "patch": "@@ -7495,7 +7495,7 @@\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DF 1 \"easy_fp_constant\" \"\"))]\n+\t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\n    && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n        || (GET_CODE (operands[0]) == SUBREG"}]}