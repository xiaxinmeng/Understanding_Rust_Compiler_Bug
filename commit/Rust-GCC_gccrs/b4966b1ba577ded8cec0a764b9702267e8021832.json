{"sha": "b4966b1ba577ded8cec0a764b9702267e8021832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5NjZiMWJhNTc3ZGVkOGNlYzBhNzY0Yjk3MDIyNjdlODAyMTgzMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-08-12T20:50:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-08-12T20:50:29Z"}, "message": "iris6.h: Convert to C90 prototypes.\n\n\t* config/mips/iris6.h: Convert to C90 prototypes.\n\t* config/mips/irix6-libc-compat.c: Likewise.\n\t* config/mips/mips-protos.h: Likewise.\n\t* config/mips/mips.c: Likewise.\n\nFrom-SVN: r70389", "tree": {"sha": "ad175e3897960f1e5efcd1c20aaaa1fa09f1b9e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad175e3897960f1e5efcd1c20aaaa1fa09f1b9e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4966b1ba577ded8cec0a764b9702267e8021832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4966b1ba577ded8cec0a764b9702267e8021832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4966b1ba577ded8cec0a764b9702267e8021832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4966b1ba577ded8cec0a764b9702267e8021832/comments", "author": null, "committer": null, "parents": [{"sha": "aecf41099bac0258050c052bdc1892e8b4a5d145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aecf41099bac0258050c052bdc1892e8b4a5d145", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aecf41099bac0258050c052bdc1892e8b4a5d145"}], "stats": {"total": 1541, "additions": 596, "deletions": 945}, "files": [{"sha": "b87fe4bbe05d79a7fb35d0ba355a6b5789b92266", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4966b1ba577ded8cec0a764b9702267e8021832", "patch": "@@ -1,3 +1,10 @@\n+2003-08-12  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/iris6.h: Convert to C90 prototypes.\n+\t* config/mips/irix6-libc-compat.c: Likewise.\n+\t* config/mips/mips-protos.h: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\n 2003-08-12  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \tfixinc/inclhack.def (svr4_krnl): Rename from svr4_kernel.  Enable"}, {"sha": "cf68b418c3d24ac85d95e78f6a3f8d022920ba39", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=b4966b1ba577ded8cec0a764b9702267e8021832", "patch": "@@ -287,7 +287,7 @@ Boston, MA 02111-1307, USA.  */\n #undef EXTRA_SECTION_FUNCTIONS\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n const char *\t\t\t\t\t\t\t\t\\\n-current_section_name ()\t\t\t\t\t\t\t\\\n+current_section_name (void)\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   switch (in_section)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -307,7 +307,7 @@ current_section_name ()\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n unsigned int\t\t\t\t\t\t\t\t\\\n-current_section_flags ()\t\t\t\t\t\t\\\n+current_section_flags (void)\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   switch (in_section)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "ce3b63a260cd3dbd78b5aaacb448be79491c7a0f", "filename": "gcc/config/mips/irix6-libc-compat.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firix6-libc-compat.c?ref=b4966b1ba577ded8cec0a764b9702267e8021832", "patch": "@@ -69,15 +69,15 @@ Boston, MA 02111-1307, USA.  */\n    always 32.  */\n #define SHIFT_BITS\t32\n \n-extern machreg_t inet_ntoa\tPARAMS ((machreg_t));\n-extern machreg_t inet_lnaof\tPARAMS ((machreg_t));\n-extern machreg_t inet_netof\tPARAMS ((machreg_t));\n-extern machreg_t inet_makeaddr\tPARAMS ((machreg_t, machreg_t));\n+extern machreg_t inet_ntoa (machreg_t);\n+extern machreg_t inet_lnaof (machreg_t);\n+extern machreg_t inet_netof (machreg_t);\n+extern machreg_t inet_makeaddr (machreg_t, machreg_t);\n \n-extern machreg_t _inet_ntoa\tPARAMS ((machreg_t));\n-extern machreg_t _inet_lnaof\tPARAMS ((machreg_t));\n-extern machreg_t _inet_netof\tPARAMS ((machreg_t));\n-extern machreg_t _inet_makeaddr\tPARAMS ((machreg_t, machreg_t));\n+extern machreg_t _inet_ntoa (machreg_t);\n+extern machreg_t _inet_lnaof (machreg_t);\n+extern machreg_t _inet_netof (machreg_t);\n+extern machreg_t _inet_makeaddr (machreg_t, machreg_t);\n \n /* <arpa/inet.h> has\n \n@@ -127,8 +127,8 @@ inet_makeaddr (machreg_t net, machreg_t lna)\n }\n \n #if _MIPS_SIM == _ABIN32\n-extern machreg_t semctl\t\tPARAMS ((machreg_t, machreg_t, machreg_t, machreg_t));\n-extern machreg_t _semctl\tPARAMS ((machreg_t, machreg_t, machreg_t, machreg_t));\n+extern machreg_t semctl (machreg_t, machreg_t, machreg_t, machreg_t);\n+extern machreg_t _semctl (machreg_t, machreg_t, machreg_t, machreg_t);\n \n /* <sys/sem.h> has\n "}, {"sha": "9e053a66105dc38b1740f4e69eebd736fcb962e7", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 114, "deletions": 141, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=b4966b1ba577ded8cec0a764b9702267e8021832", "patch": "@@ -26,149 +26,122 @@ Boston, MA 02111-1307, USA.  */\n #ifndef GCC_MIPS_PROTOS_H\n #define GCC_MIPS_PROTOS_H\n \n-extern HOST_WIDE_INT\tcompute_frame_size PARAMS ((HOST_WIDE_INT));\n-extern int\t\tmips_initial_elimination_offset PARAMS ((int, int));\n-extern void\t\tiris6_asm_output_align PARAMS ((FILE *, unsigned));\n-extern const char *\tcurrent_section_name PARAMS ((void));\n-extern unsigned int\tcurrent_section_flags PARAMS ((void));\n-extern int\t\tmips_can_use_return_insn PARAMS ((void));\n-extern void\t\tmips_declare_object PARAMS ((FILE *, const char *,\n-\t\t\t\t\t\t     const char *,\n-\t\t\t\t\t\t     const char *, int));\n-extern void\t\tmips_declare_object_name PARAMS ((FILE *, const char *,\n-\t\t\t\t\t\t\t  tree));\n-extern void\t\tmips_finish_declare_object PARAMS ((FILE *, tree,\n-\t\t\t\t\t\t\t    int, int));\n-extern void\t\tmips_output_aligned_bss\n-\t\t\t\tPARAMS ((FILE *, tree, const char *,\n-\t\t\t\t\t unsigned HOST_WIDE_INT, int));\n-extern void\t\tmips_expand_epilogue PARAMS ((int));\n-extern void\t\tmips_expand_prologue PARAMS ((void));\n-extern void\t\tmips_output_filename PARAMS ((FILE *, const char *));\n-extern void\t\tmips_output_lineno PARAMS ((FILE *, int));\n-extern void\t\tmips_output_ascii PARAMS ((FILE *, const char *,\n-\t\t\t\t\t\t   size_t));\n-extern void\t\tmips_order_regs_for_local_alloc PARAMS ((void));\n-extern struct rtx_def * embedded_pic_fnaddr_reg PARAMS ((void));\n-extern struct rtx_def *\tmips16_gp_pseudo_reg PARAMS ((void));\n-#ifdef ASM_OUTPUT_UNDEF_FUNCTION\n-extern int\t\tmips_output_external_libcall PARAMS ((FILE *, const char *));\n-#endif /* ASM_OUTPUT_UNDEF_FUNCTION */\n-extern struct rtx_def  *mips_function_value PARAMS ((tree, tree,\n-\t\t\t\t\t\t     enum machine_mode));\n-\n-extern unsigned int\tmips_hard_regno_nregs PARAMS ((int,\n-\t\t\t\t\t\t       enum machine_mode));\n-extern int              mips_return_in_memory PARAMS ((tree));\n-\n-extern struct rtx_def  *function_arg PARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t      enum machine_mode, tree, int));\n-extern void\t\tfunction_arg_advance PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t      enum machine_mode,\n-\t\t\t\t\t\t      tree, int));\n-extern int\t\tfunction_arg_partial_nregs\n-\t\t\t\tPARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t tree, int));\n-extern int\t\tmips_setup_incoming_varargs\n-\t\t\t\tPARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t tree, int));\n-extern int\t\tfunction_arg_pass_by_reference\n-\t\t\t\tPARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t enum machine_mode, tree, int));\n-extern int\t\tmips_output_external PARAMS ((FILE *, tree,\n-\t\t\t\t\t\t      const char *));\n-extern tree\t\tmips_build_va_list PARAMS ((void));\n-extern void\t\tmips_va_start PARAMS ((tree, rtx));\n-extern struct rtx_def  *mips_va_arg PARAMS ((tree, tree));\n-\n-extern bool\t\tmips_expand_block_move PARAMS ((rtx, rtx, rtx));\n-extern bool\t\tmips_expand_unaligned_load PARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t    unsigned int,\n-\t\t\t\t\t\t\t    int));\n-extern bool\t\tmips_expand_unaligned_store PARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t     unsigned int,\n-\t\t\t\t\t\t\t     int));\n-extern void\t\tinit_cumulative_args PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t      tree, rtx));\n-extern void\t\tgen_conditional_move PARAMS ((rtx *));\n-extern void\t\tmips_gen_conditional_trap PARAMS ((rtx *));\n-extern void\t\tmips_emit_fcc_reload PARAMS ((rtx, rtx, rtx));\n-extern void\t\tmips_set_return_address PARAMS ((rtx, rtx));\n-extern HOST_WIDE_INT\tmips_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n-extern rtx\t\tmips_subword PARAMS ((rtx, int));\n-extern bool\t\tmips_split_64bit_move_p PARAMS ((rtx, rtx));\n-extern void\t\tmips_split_64bit_move PARAMS ((rtx, rtx));\n-extern const char      *mips_output_move PARAMS ((rtx, rtx));\n-extern const char      *mips_emit_prefetch PARAMS ((rtx *));\n-extern const char      *mips_restore_gp PARAMS ((rtx *));\n-extern void\t\toverride_options PARAMS ((void));\n-extern void\t\tmips_conditional_register_usage PARAMS ((void));\n-extern void\t\tprint_operand_address PARAMS ((FILE *, rtx));\n-extern void\t\tprint_operand PARAMS ((FILE *, rtx, int));\n-extern struct rtx_def *\tembedded_pic_offset PARAMS ((rtx));\n-extern int\t\tbuild_mips16_call_stub PARAMS ((rtx, rtx, rtx, int));\n-extern const char\t*mips_output_load_label PARAMS ((void));\n-extern const char       *mips_output_conditional_branch PARAMS ((rtx, rtx *,\n-\t\t\t\t\t\t\t\t int, int, int,\n-\t\t\t\t\t\t\t\t int));\n-extern const char\t*mips_output_division PARAMS ((const char *, rtx *));\n-extern int              mips_adjust_insn_length PARAMS ((rtx, int));\n-extern enum reg_class\tmips_secondary_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t\t\t     rtx, int));\n-extern bool     \tmips_cannot_change_mode_class\n-\t\t\t  PARAMS ((enum machine_mode, enum machine_mode,\n-\t\t\t\t   enum reg_class));\n-extern int              mips_class_max_nregs PARAMS ((enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode));\n-extern int              mips_register_move_cost PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t enum reg_class,\n-\t\t\t\t\t\t\t enum reg_class));\n-\n-extern int\t\tse_arith_operand PARAMS ((rtx, enum machine_mode));\n-extern int\t\tmips_address_insns PARAMS ((rtx, enum machine_mode));\n-extern int\t\tmips_fetch_insns PARAMS ((rtx));\n-extern int\t\tmips_const_insns PARAMS ((rtx));\n-extern bool\t\tmips_global_pic_constant_p PARAMS ((rtx));\n-extern bool\t\tmips_legitimate_address_p PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t   rtx, int));\n-extern bool\t\tmips_legitimize_address PARAMS ((rtx *,\n-\t\t\t\t\t\t\t enum machine_mode));\n-extern bool\t\tmips_legitimize_move PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t      rtx, rtx));\n-extern rtx\t\tmips_delegitimize_address PARAMS ((rtx));\n-extern void\t\tmips_expand_call PARAMS ((rtx, rtx, rtx, rtx, int));\n-extern int              mips_reg_mode_ok_for_base_p PARAMS ((rtx,\n-\t\t\t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t\t\t     int));\n-extern bool             mips_valid_pointer_mode PARAMS ((enum machine_mode));\n-\n-extern int\t\tm16_uimm3_b PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_simm4_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nsimm4_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_simm5_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nsimm5_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_uimm5_4 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nuimm5_4 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_simm8_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nsimm8_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_uimm8_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nuimm8_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_uimm8_m1_1 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_uimm8_4 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nuimm8_4 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_simm8_8 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_nsimm8_8 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_usym8_4 PARAMS ((rtx, enum machine_mode));\n-extern int\t\tm16_usym5_4 PARAMS ((rtx, enum machine_mode));\n+extern int mips_reg_mode_ok_for_base_p (rtx, enum machine_mode, int);\n+extern int mips_address_insns (rtx, enum machine_mode);\n+extern int mips_const_insns (rtx);\n+extern int mips_fetch_insns (rtx);\n+extern bool mips_global_pic_constant_p (rtx);\n+extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n+extern bool mips_legitimize_address (rtx *, enum machine_mode);\n+extern bool mips_legitimize_move (enum machine_mode, rtx, rtx);\n+extern rtx mips_delegitimize_address (rtx);\n+\n+extern int m16_uimm3_b (rtx, enum machine_mode);\n+extern int m16_simm4_1 (rtx, enum machine_mode);\n+extern int m16_nsimm4_1 (rtx, enum machine_mode);\n+extern int m16_simm5_1 (rtx, enum machine_mode);\n+extern int m16_nsimm5_1 (rtx, enum machine_mode);\n+extern int m16_uimm5_4 (rtx, enum machine_mode);\n+extern int m16_nuimm5_4 (rtx, enum machine_mode);\n+extern int m16_simm8_1 (rtx, enum machine_mode);\n+extern int m16_nsimm8_1 (rtx, enum machine_mode);\n+extern int m16_uimm8_1 (rtx, enum machine_mode);\n+extern int m16_nuimm8_1 (rtx, enum machine_mode);\n+extern int m16_uimm8_m1_1 (rtx, enum machine_mode);\n+extern int m16_uimm8_4 (rtx, enum machine_mode);\n+extern int m16_nuimm8_4 (rtx, enum machine_mode);\n+extern int m16_simm8_8 (rtx, enum machine_mode);\n+extern int m16_nsimm8_8 (rtx, enum machine_mode);\n+extern int m16_usym8_4 (rtx, enum machine_mode);\n+extern int m16_usym5_4 (rtx, enum machine_mode);\n \n+extern struct rtx_def *embedded_pic_fnaddr_reg (void);\n+extern struct rtx_def *embedded_pic_offset (rtx);\n+extern rtx mips_subword (rtx, int);\n+extern bool mips_split_64bit_move_p (rtx, rtx);\n+extern void mips_split_64bit_move (rtx, rtx);\n+extern const char *mips_output_move (rtx, rtx);\n+extern const char *mips_restore_gp (rtx *);\n #ifdef RTX_CODE\n-extern rtx\t\tgen_int_relational PARAMS ((enum rtx_code, rtx, rtx,\n-\t\t\t\t\t\t    rtx,int *));\n-extern void\t\tgen_conditional_branch PARAMS ((rtx *, enum rtx_code));\n+extern rtx gen_int_relational (enum rtx_code, rtx, rtx, rtx, int *);\n+extern void gen_conditional_branch (rtx *, enum rtx_code);\n #endif\n-extern rtx              mips_return_addr PARAMS ((int, rtx));\n+extern void gen_conditional_move (rtx *);\n+extern void mips_gen_conditional_trap (rtx *);\n+extern void mips_expand_call (rtx, rtx, rtx, rtx, int);\n+extern void mips_emit_fcc_reload (rtx, rtx, rtx);\n+extern void mips_set_return_address (rtx, rtx);\n+extern bool mips_expand_block_move (rtx, rtx, rtx);\n+\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n+extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t  tree, int);\n+extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n+\t\t\t\t     enum machine_mode, tree, int);\n+extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n+\t\t\t\t       enum machine_mode, tree, int);\n+extern int mips_setup_incoming_varargs (const CUMULATIVE_ARGS *,\n+\t\t\t\t\tenum machine_mode, tree, int);\n+extern tree mips_build_va_list (void);\n+extern void mips_va_start (tree, rtx);\n+extern struct rtx_def *mips_va_arg (tree, tree);\n+\n+extern bool mips_expand_unaligned_load (rtx, rtx, unsigned int, int);\n+extern bool mips_expand_unaligned_store (rtx, rtx, unsigned int, int);\n+extern void override_options (void);\n+extern void mips_conditional_register_usage (void);\n+extern void mips_order_regs_for_local_alloc (void);\n+extern HOST_WIDE_INT mips_debugger_offset (rtx, HOST_WIDE_INT);\n+\n+extern void print_operand (FILE *, rtx, int);\n+extern void print_operand_address (FILE *, rtx);\n+extern int mips_output_external (FILE *, tree, const char *);\n+#ifdef ASM_OUTPUT_UNDEF_FUNCTION\n+extern int mips_output_external_libcall (FILE *, const char *);\n+#endif\n+extern void mips_output_filename (FILE *, const char *);\n+extern void mips_output_lineno (FILE *, int);\n+extern void mips_output_ascii (FILE *, const char *, size_t);\n+extern void mips_output_aligned_bss (FILE *, tree, const char *,\n+\t\t\t\t     unsigned HOST_WIDE_INT, int);\n+extern void mips_declare_object (FILE *, const char *, const char *,\n+\t\t\t\t const char *, int);\n+extern void mips_declare_object_name (FILE *, const char *, tree);\n+extern void mips_finish_declare_object (FILE *, tree, int, int);\n+\n+extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT);\n+extern int mips_initial_elimination_offset (int, int);\n+extern rtx mips_return_addr (int, rtx);\n+extern void mips_expand_prologue (void);\n+extern void mips_expand_epilogue (int);\n+extern int mips_can_use_return_insn (void);\n+extern struct rtx_def *mips_function_value (tree, tree, enum machine_mode);\n+extern int function_arg_pass_by_reference (const CUMULATIVE_ARGS *,\n+\t\t\t\t\t   enum machine_mode, tree, int);\n+\n+extern bool mips_cannot_change_mode_class (enum machine_mode,\n+\t\t\t\t\t   enum machine_mode, enum reg_class);\n+extern enum reg_class mips_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t   rtx, int);\n+extern int mips_class_max_nregs (enum reg_class, enum machine_mode);\n+extern bool mips_valid_pointer_mode (enum machine_mode);\n+extern struct rtx_def *mips16_gp_pseudo_reg (void);\n+extern int build_mips16_call_stub (rtx, rtx, rtx, int);\n+extern int mips_register_move_cost (enum machine_mode, enum reg_class,\n+\t\t\t\t    enum reg_class);\n+\n+extern int mips_adjust_insn_length (rtx, int);\n+extern const char *mips_output_load_label (void);\n+extern const char *mips_output_conditional_branch (rtx, rtx *, int, int,\n+\t\t\t\t\t\t   int, int);\n+extern const char *mips_output_division (const char *, rtx *);\n+extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n+extern int mips_return_in_memory (tree);\n+extern const char *mips_emit_prefetch (rtx *);\n+\n+extern void iris6_asm_output_align (FILE *, unsigned);\n+extern const char *current_section_name (void);\n+extern unsigned int current_section_flags (void);\n \n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "7e7bcc3f9a30177f82a7064813f22e0c565946d0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 463, "deletions": 792, "changes": 1255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4966b1ba577ded8cec0a764b9702267e8021832/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b4966b1ba577ded8cec0a764b9702267e8021832", "patch": "@@ -167,125 +167,101 @@ struct mips_arg_info;\n struct mips_constant_info;\n struct mips_address_info;\n struct mips_integer_op;\n-static enum mips_constant_type mips_classify_constant\n-\t\t\t\tPARAMS ((struct mips_constant_info *, rtx));\n-static enum mips_symbol_type mips_classify_symbol\n-\t\t\t\tPARAMS ((rtx));\n-static bool mips_valid_base_register_p\n-\t\t\t\tPARAMS ((rtx, enum machine_mode, int));\n-static bool mips_symbolic_address_p\n-\t\t\t\tPARAMS ((rtx, HOST_WIDE_INT,\n-\t\t\t\t\t enum machine_mode, int));\n-static enum mips_address_type mips_classify_address\n-\t\t\t\tPARAMS ((struct mips_address_info *,\n-\t\t\t\t\t rtx, enum machine_mode, int, int));\n-static enum internal_test map_test_to_internal_test\tPARAMS ((enum rtx_code));\n-static void get_float_compare_codes PARAMS ((enum rtx_code, enum rtx_code *,\n-\t\t\t\t\t     enum rtx_code *));\n-static const char *mips_reloc_string\tPARAMS ((int));\n-static bool mips_splittable_symbol_p\tPARAMS ((enum mips_symbol_type));\n-static int mips_symbol_insns\t\tPARAMS ((enum mips_symbol_type));\n-static bool mips16_unextended_reference_p\n-\t\t\t\t\tPARAMS ((enum machine_mode mode,\n-\t\t\t\t\t\t rtx, rtx));\n-static rtx mips_force_temporary\t\t\tPARAMS ((rtx, rtx));\n-static rtx mips_add_offset\t\t\tPARAMS ((rtx, HOST_WIDE_INT));\n-static rtx mips_load_got\t\t\tPARAMS ((rtx, rtx, int));\n-static rtx mips_load_got16\t\t\tPARAMS ((rtx, int));\n-static rtx mips_load_got32\t\t\tPARAMS ((rtx, rtx, int, int));\n-static rtx mips_emit_high\t\t\tPARAMS ((rtx, rtx));\n-static bool mips_legitimize_symbol\t\tPARAMS ((rtx, rtx *, int));\n-static rtx mips_reloc\t\t\t\tPARAMS ((rtx, int));\n-static rtx mips_lui_reloc\t\t\tPARAMS ((rtx, int));\n-static unsigned int mips_build_shift\tPARAMS ((struct mips_integer_op *,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n-static unsigned int mips_build_lower\tPARAMS ((struct mips_integer_op *,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static unsigned int mips_build_integer\tPARAMS ((struct mips_integer_op *,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static void mips_move_integer\t\tPARAMS ((rtx, unsigned HOST_WIDE_INT));\n-static void mips_legitimize_const_move\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t rtx, rtx));\n-static int m16_check_op\t\t\t\tPARAMS ((rtx, int, int, int));\n-static bool mips_function_ok_for_sibcall\tPARAMS ((tree, tree));\n-static void mips_block_move_straight\t\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n-static void mips_adjust_block_mem\t\tPARAMS ((rtx, HOST_WIDE_INT,\n-\t\t\t\t\t\t\t rtx *, rtx *));\n-static void mips_block_move_loop\t\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n-static void mips_arg_info\t\tPARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t tree, int,\n-\t\t\t\t\t\t struct mips_arg_info *));\n-static bool mips_get_unaligned_mem\t\tPARAMS ((rtx *, unsigned int,\n-\t\t\t\t\t\t\t int, rtx *, rtx *));\n-static unsigned int mips_global_pointer\t\tPARAMS ((void));\n-static bool mips_save_reg_p\t\t\tPARAMS ((unsigned int));\n-static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT));\n-static void mips_set_frame_expr\t\t\tPARAMS ((rtx));\n-static rtx mips_frame_set\t\t\tPARAMS ((rtx, int));\n-static void mips_emit_frame_related_store\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t HOST_WIDE_INT));\n-static void save_restore_insns\t\t\tPARAMS ((int, rtx, long));\n-static void mips_gp_insn\t\t\tPARAMS ((rtx, rtx));\n-static void mips16_fp_args\t\t\tPARAMS ((FILE *, int, int));\n-static void build_mips16_function_stub\t\tPARAMS ((FILE *));\n-static void mips16_optimize_gp\t\t\tPARAMS ((void));\n-static rtx add_constant\t\t\t\tPARAMS ((struct constant **,\n-\t\t\t\t\t\t\trtx,\n-\t\t\t\t\t\t\tenum machine_mode));\n-static void dump_constants\t\t\tPARAMS ((struct constant *,\n-\t\t\t\t\t\t\trtx));\n-static rtx mips_find_symbol\t\t\tPARAMS ((rtx));\n-static void mips16_lay_out_constants\t\tPARAMS ((void));\n-static void mips_avoid_hazard\t\t\tPARAMS ((rtx, rtx, int *,\n-\t\t\t\t\t\t\t rtx *, rtx));\n-static void mips_avoid_hazards\t\t\tPARAMS ((void));\n-static void mips_reorg\t\t\t\tPARAMS ((void));\n-static int symbolic_expression_p                PARAMS ((rtx));\n-static bool mips_assemble_integer\t  PARAMS ((rtx, unsigned int, int));\n-static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void mips_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void mips_set_architecture    PARAMS ((const struct mips_cpu_info *));\n-static void mips_set_tune\t     PARAMS ((const struct mips_cpu_info *));\n-static bool mips_strict_matching_cpu_name_p\tPARAMS ((const char *,\n-\t\t\t\t\t\t\t const char *));\n-static bool mips_matching_cpu_name_p\t\tPARAMS ((const char *,\n-\t\t\t\t\t\t\t const char *));\n-static const struct mips_cpu_info *mips_parse_cpu   PARAMS ((const char *,\n-\t\t\t\t\t\t\t      const char *));\n-static const struct mips_cpu_info *mips_cpu_info_from_isa PARAMS ((int));\n+static enum mips_constant_type\n+  mips_classify_constant (struct mips_constant_info *, rtx);\n+static enum mips_symbol_type mips_classify_symbol (rtx);\n+static bool mips_valid_base_register_p (rtx, enum machine_mode, int);\n+static bool mips_symbolic_address_p (rtx, HOST_WIDE_INT,\n+\t\t\t\t     enum machine_mode, int);\n+static enum mips_address_type\n+  mips_classify_address (struct mips_address_info *, rtx,\n+\t\t\t enum machine_mode, int, int);\n+static bool mips_splittable_symbol_p (enum mips_symbol_type);\n+static int mips_symbol_insns (enum mips_symbol_type);\n+static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n+static rtx mips_reloc (rtx, int);\n+static rtx mips_lui_reloc (rtx, int);\n+static rtx mips_force_temporary (rtx, rtx);\n+static rtx mips_add_offset (rtx, HOST_WIDE_INT);\n+static rtx mips_load_got (rtx, rtx, int);\n+static rtx mips_load_got16 (rtx, int);\n+static rtx mips_load_got32 (rtx, rtx, int, int);\n+static rtx mips_emit_high (rtx, rtx);\n+static bool mips_legitimize_symbol (rtx, rtx *, int);\n+static unsigned int mips_build_shift (struct mips_integer_op *, HOST_WIDE_INT);\n+static unsigned int mips_build_lower (struct mips_integer_op *,\n+\t\t\t\t      unsigned HOST_WIDE_INT);\n+static unsigned int mips_build_integer (struct mips_integer_op *,\n+\t\t\t\t\tunsigned HOST_WIDE_INT);\n+static void mips_move_integer (rtx, unsigned HOST_WIDE_INT);\n+static void mips_legitimize_const_move (enum machine_mode, rtx, rtx);\n+static int m16_check_op (rtx, int, int, int);\n+static bool mips_rtx_costs (rtx, int, int, int *);\n+static int mips_address_cost (rtx);\n+static enum internal_test map_test_to_internal_test (enum rtx_code);\n+static void get_float_compare_codes (enum rtx_code, enum rtx_code *,\n+\t\t\t\t     enum rtx_code *);\n+static bool mips_function_ok_for_sibcall (tree, tree);\n+static void mips_block_move_straight (rtx, rtx, HOST_WIDE_INT);\n+static void mips_adjust_block_mem (rtx, HOST_WIDE_INT, rtx *, rtx *);\n+static void mips_block_move_loop (rtx, rtx, HOST_WIDE_INT);\n+static void mips_arg_info (const CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t   tree, int, struct mips_arg_info *);\n+static bool mips_get_unaligned_mem (rtx *, unsigned int, int, rtx *, rtx *);\n+static void mips_set_architecture (const struct mips_cpu_info *);\n+static void mips_set_tune (const struct mips_cpu_info *);\n+static struct machine_function *mips_init_machine_status (void);\n+static const char *mips_reloc_string (int);\n+static bool mips_assemble_integer (rtx, unsigned int, int);\n+static void mips_file_start (void);\n+static void mips_file_end (void);\n+static unsigned int mips_global_pointer\t(void);\n+static bool mips_save_reg_p (unsigned int);\n+static rtx mips_add_large_offset_to_sp (HOST_WIDE_INT);\n+static void mips_set_frame_expr (rtx);\n+static rtx mips_frame_set (rtx, int);\n+static void mips_emit_frame_related_store (rtx, rtx, HOST_WIDE_INT);\n+static void save_restore_insns (int, rtx, long);\n+static void mips_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void mips_gp_insn (rtx, rtx);\n+static void mips_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static int symbolic_expression_p (rtx);\n+static void mips_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t     unsigned HOST_WIDE_INT);\n+static void mips_select_section (tree, int, unsigned HOST_WIDE_INT)\n+\t\t\t\t  ATTRIBUTE_UNUSED;\n+static bool mips_in_small_data_p (tree);\n+static void mips_encode_section_info (tree, rtx, int);\n+static void mips16_fp_args (FILE *, int, int);\n+static void build_mips16_function_stub (FILE *);\n+static void mips16_optimize_gp (void);\n+static rtx add_constant\t(struct constant **, rtx, enum machine_mode);\n+static void dump_constants (struct constant *, rtx);\n+static rtx mips_find_symbol (rtx);\n+static void mips16_lay_out_constants (void);\n+static void mips_avoid_hazard (rtx, rtx, int *, rtx *, rtx);\n+static void mips_avoid_hazards (void);\n+static void mips_reorg (void);\n+static bool mips_strict_matching_cpu_name_p (const char *, const char *);\n+static bool mips_matching_cpu_name_p (const char *, const char *);\n+static const struct mips_cpu_info *mips_parse_cpu (const char *, const char *);\n+static const struct mips_cpu_info *mips_cpu_info_from_isa (int);\n+static int mips_adjust_cost (rtx, rtx, rtx, int);\n+static int mips_issue_rate (void);\n+static int mips_use_dfa_pipeline_interface (void);\n+\n #ifdef TARGET_IRIX6\n-static void copy_file_data\t\t\tPARAMS ((FILE *, FILE *));\n-static void iris6_asm_named_section_1\t\tPARAMS ((const char *,\n-\t\t\t\t\t\t\t unsigned int,\n-\t\t\t\t\t\t\t unsigned int));\n-static void iris6_asm_named_section\t\tPARAMS ((const char *,\n-\t\t\t\t\t\t\t unsigned int));\n-static int iris_section_align_entry_eq\t\tPARAMS ((const void *, const void *));\n-static hashval_t iris_section_align_entry_hash\tPARAMS ((const void *));\n-static int iris6_section_align_1\t\tPARAMS ((void **, void *));\n-static void iris6_file_start\t\t\tPARAMS ((void));\n-static void iris6_file_end\t\t\tPARAMS ((void));\n-static unsigned int iris6_section_type_flags\tPARAMS ((tree, const char *,\n-\t\t\t\t\t\t\t int));\n+static void iris6_asm_named_section_1 (const char *, unsigned int,\n+\t\t\t\t       unsigned int);\n+static void iris6_asm_named_section (const char *, unsigned int);\n+static int iris_section_align_entry_eq (const void *, const void *);\n+static hashval_t iris_section_align_entry_hash (const void *);\n+static void iris6_file_start (void);\n+static int iris6_section_align_1 (void **, void *);\n+static void copy_file_data (FILE *, FILE *);\n+static void iris6_file_end (void);\n+static unsigned int iris6_section_type_flags (tree, const char *, int);\n #endif\n-static int mips_adjust_cost\t\t\tPARAMS ((rtx, rtx, rtx, int));\n-static int mips_issue_rate\t\t\tPARAMS ((void));\n-\n-static struct machine_function * mips_init_machine_status PARAMS ((void));\n-static void mips_select_section PARAMS ((tree, int, unsigned HOST_WIDE_INT))\n-\tATTRIBUTE_UNUSED;\n-static void mips_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t     unsigned HOST_WIDE_INT));\n-static int mips_use_dfa_pipeline_interface      PARAMS ((void));\n-static bool mips_rtx_costs\t\t\tPARAMS ((rtx, int, int, int *));\n-static int mips_address_cost                    PARAMS ((rtx));\n-static bool mips_in_small_data_p\t\tPARAMS ((tree));\n-static void mips_encode_section_info            PARAMS ((tree, rtx, int));\n-static void mips_file_start\t\t\tPARAMS ((void));\n-static void mips_file_end\t\t\tPARAMS ((void));\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -813,9 +789,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n    store its components in INFO and return its type.  */\n \n static enum mips_constant_type\n-mips_classify_constant (info, x)\n-     struct mips_constant_info *info;\n-     rtx x;\n+mips_classify_constant (struct mips_constant_info *info, rtx x)\n {\n   info->offset = 0;\n   info->symbol = x;\n@@ -861,8 +835,7 @@ mips_classify_constant (info, x)\n /* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n \n static enum mips_symbol_type\n-mips_classify_symbol (x)\n-     rtx x;\n+mips_classify_symbol (rtx x)\n {\n   if (GET_CODE (x) == LABEL_REF)\n     return (TARGET_ABICALLS ? SYMBOL_GOT_LOCAL : SYMBOL_GENERAL);\n@@ -911,10 +884,7 @@ mips_classify_symbol (x)\n /* This function is used to implement REG_MODE_OK_FOR_BASE_P.  */\n \n int\n-mips_reg_mode_ok_for_base_p (reg, mode, strict)\n-     rtx reg;\n-     enum machine_mode mode;\n-     int strict;\n+mips_reg_mode_ok_for_base_p (rtx reg, enum machine_mode mode, int strict)\n {\n   return (strict\n \t  ? REGNO_MODE_OK_FOR_BASE_P (REGNO (reg), mode)\n@@ -926,10 +896,7 @@ mips_reg_mode_ok_for_base_p (reg, mode, strict)\n    Allow only hard registers if STRICT.  */\n \n static bool\n-mips_valid_base_register_p (x, mode, strict)\n-     rtx x;\n-     enum machine_mode mode;\n-     int strict;\n+mips_valid_base_register_p (rtx x, enum machine_mode mode, int strict)\n {\n   if (!strict && GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n@@ -954,11 +921,8 @@ mips_valid_base_register_p (x, mode, strict)\n      it is better to move the address into a register first.  */\n \n static bool\n-mips_symbolic_address_p (symbol, offset, mode, lea_p)\n-     rtx symbol;\n-     HOST_WIDE_INT offset;\n-     enum machine_mode mode;\n-     int lea_p;\n+mips_symbolic_address_p (rtx symbol, HOST_WIDE_INT offset,\n+\t\t\t enum machine_mode mode, int lea_p)\n {\n   if (TARGET_EXPLICIT_RELOCS)\n     return false;\n@@ -1005,11 +969,8 @@ mips_symbolic_address_p (symbol, offset, mode, lea_p)\n    the same as for mips_symbolic_address_p.  */\n \n static enum mips_address_type\n-mips_classify_address (info, x, mode, strict, lea_p)\n-     struct mips_address_info *info;\n-     rtx x;\n-     enum machine_mode mode;\n-     int strict, lea_p;\n+mips_classify_address (struct mips_address_info *info, rtx x,\n+\t\t       enum machine_mode mode, int strict, int lea_p)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1071,8 +1032,7 @@ mips_classify_address (info, x, mode, strict, lea_p)\n    HIGH/LO_SUM pair.  */\n \n static bool\n-mips_splittable_symbol_p (type)\n-     enum mips_symbol_type type;\n+mips_splittable_symbol_p (enum mips_symbol_type type)\n {\n   if (TARGET_EXPLICIT_RELOCS)\n     return (type == SYMBOL_GENERAL || type == SYMBOL_GOT_LOCAL);\n@@ -1088,8 +1048,7 @@ mips_splittable_symbol_p (type)\n    mips16 instructions as two instructions.  */\n \n static int\n-mips_symbol_insns (type)\n-     enum mips_symbol_type type;\n+mips_symbol_insns (enum mips_symbol_type type)\n {\n   switch (type)\n     {\n@@ -1152,9 +1111,7 @@ mips_symbol_insns (type)\n    stack pointer, which have an 8-bit immediate field.  */\n \n static bool\n-mips16_unextended_reference_p (mode, base, offset)\n-     enum machine_mode mode;\n-     rtx base, offset;\n+mips16_unextended_reference_p (enum machine_mode mode, rtx base, rtx offset)\n {\n   if (TARGET_MIPS16\n       && GET_CODE (offset) == CONST_INT\n@@ -1175,9 +1132,7 @@ mips16_unextended_reference_p (mode, base, offset)\n    For mips16 code, count extended instructions as two instructions.  */\n \n int\n-mips_address_insns (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+mips_address_insns (rtx x, enum machine_mode mode)\n {\n   struct mips_address_info addr;\n   int factor;\n@@ -1209,8 +1164,7 @@ mips_address_insns (x, mode)\n /* Likewise for constant X.  */\n \n int\n-mips_const_insns (x)\n-     rtx x;\n+mips_const_insns (rtx x)\n {\n   struct mips_constant_info c;\n   struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n@@ -1264,8 +1218,7 @@ mips_const_insns (x)\n    Count extended mips16 instructions as two instructions.  */\n \n int\n-mips_fetch_insns (x)\n-     rtx x;\n+mips_fetch_insns (rtx x)\n {\n   if (GET_CODE (x) != MEM)\n     abort ();\n@@ -1278,8 +1231,7 @@ mips_fetch_insns (x)\n    global PIC symbol.  */\n \n bool\n-mips_global_pic_constant_p (op)\n-     rtx op;\n+mips_global_pic_constant_p (rtx op)\n {\n   struct mips_constant_info c;\n \n@@ -1292,9 +1244,7 @@ mips_global_pic_constant_p (op)\n    where a register or 16 bit unsigned integer is needed.  */\n \n int\n-uns_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+uns_arith_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT && SMALL_INT_UNSIGNED (op))\n     return 1;\n@@ -1306,9 +1256,7 @@ uns_arith_operand (op, mode)\n /* True if OP can be treated as a signed 16-bit constant.  */\n \n int\n-const_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const_arith_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   struct mips_constant_info c;\n \n@@ -1320,19 +1268,15 @@ const_arith_operand (op, mode)\n /* Return true if OP is a register operand or a signed 16-bit constant.  */\n \n int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_operand (rtx op, enum machine_mode mode)\n {\n   return const_arith_operand (op, mode) || register_operand (op, mode);\n }\n \n /* Return truth value of whether OP is an integer which fits in 16 bits.  */\n \n int\n-small_int (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n }\n@@ -1342,9 +1286,7 @@ small_int (op, mode)\n    registers.  */\n \n int\n-reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -1366,9 +1308,7 @@ reg_or_0_operand (op, mode)\n /* Accept the floating point constant 1 in the appropriate mode.  */\n \n int\n-const_float_1_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_float_1_operand (rtx op, enum machine_mode mode)\n {\n   REAL_VALUE_TYPE d;\n \n@@ -1385,9 +1325,7 @@ const_float_1_operand (op, mode)\n /* Return true if OP is either the HI or LO register.  */\n \n int\n-hilo_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+hilo_operand (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || mode == GET_MODE (op))\n \t  && REG_P (op) && MD_REG_P (REGNO (op)));\n@@ -1396,9 +1334,7 @@ hilo_operand (op, mode)\n /* Return true if OP is an extension operator.  */\n \n int\n-extend_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+extend_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || mode == GET_MODE (op))\n \t  && (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND));\n@@ -1407,9 +1343,7 @@ extend_operator (op, mode)\n /* Return nonzero if the code of this rtx pattern is EQ or NE.  */\n \n int\n-equality_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+equality_op (rtx op, enum machine_mode mode)\n {\n   if (mode != GET_MODE (op))\n     return 0;\n@@ -1420,9 +1354,7 @@ equality_op (op, mode)\n /* Return nonzero if the code is a relational operations (EQ, LE, etc.) */\n \n int\n-cmp_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cmp_op (rtx op, enum machine_mode mode)\n {\n   if (mode != GET_MODE (op))\n     return 0;\n@@ -1436,9 +1368,7 @@ cmp_op (op, mode)\n    combine from erroneously altering the condition.  */\n \n int\n-trap_cmp_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+trap_cmp_op (rtx op, enum machine_mode mode)\n {\n   if (mode != GET_MODE (op))\n     return 0;\n@@ -1461,9 +1391,7 @@ trap_cmp_op (op, mode)\n /* Return nonzero if the operand is either the PC or a label_ref.  */\n \n int\n-pc_or_label_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (op == pc_rtx)\n     return 1;\n@@ -1477,9 +1405,7 @@ pc_or_label_operand (op, mode)\n /* Test for a valid call address.  */\n \n int\n-call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_insn_operand (rtx op, enum machine_mode mode)\n {\n   struct mips_constant_info c;\n \n@@ -1509,9 +1435,7 @@ call_insn_operand (op, mode)\n    instruction.  */\n \n int\n-move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_operand (rtx op, enum machine_mode mode)\n {\n   struct mips_constant_info c;\n \n@@ -1531,9 +1455,7 @@ move_operand (op, mode)\n    accepted by LEGITIMATE_CONSTANT, such as arbitrary SYMBOL_REFs.  */\n \n int\n-consttable_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+consttable_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return CONSTANT_P (op);\n }\n@@ -1542,9 +1464,7 @@ consttable_operand (op, mode)\n    possibly with an offset.  */\n \n int\n-symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   struct mips_constant_info c;\n \n@@ -1558,10 +1478,7 @@ symbolic_operand (op, mode)\n    is called during reload.  */\n \n bool\n-mips_legitimate_address_p (mode, x, strict)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict;\n+mips_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   struct mips_address_info addr;\n \n@@ -1573,9 +1490,7 @@ mips_legitimate_address_p (mode, x, strict)\n    RELOC to symbolic address ADDR.  */\n \n static rtx\n-mips_reloc (addr, reloc)\n-     rtx addr;\n-     int reloc;\n+mips_reloc (rtx addr, int reloc)\n {\n   struct mips_constant_info c;\n   rtx x;\n@@ -1592,9 +1507,7 @@ mips_reloc (addr, reloc)\n    used as the right hand side of an LUISI or LUIDI pattern.  */\n \n static rtx\n-mips_lui_reloc (addr, reloc)\n-     rtx addr;\n-     int reloc;\n+mips_lui_reloc (rtx addr, int reloc)\n {\n   return gen_rtx_UNSPEC (Pmode,\n \t\t\t gen_rtvec (1, mips_reloc (addr, reloc)),\n@@ -1608,8 +1521,7 @@ mips_lui_reloc (addr, reloc)\n    The operation happens in Pmode.  */\n \n static rtx\n-mips_force_temporary (dest, value)\n-     rtx dest, value;\n+mips_force_temporary (rtx dest, rtx value)\n {\n   if (dest == 0)\n     return force_reg (Pmode, value);\n@@ -1626,9 +1538,7 @@ mips_force_temporary (dest, value)\n    create a temporary register if OFFSET is not a SMALL_OPERAND.  */\n \n static rtx\n-mips_add_offset (reg, offset)\n-     rtx reg;\n-     HOST_WIDE_INT offset;\n+mips_add_offset (rtx reg, HOST_WIDE_INT offset)\n {\n   if (!SMALL_OPERAND (offset))\n     reg = expand_simple_binop (GET_MODE (reg), PLUS,\n@@ -1644,9 +1554,7 @@ mips_add_offset (reg, offset)\n    sought and RELOC is the relocation that should be used.  */\n \n static rtx\n-mips_load_got (base, addr, reloc)\n-     rtx base, addr;\n-     int reloc;\n+mips_load_got (rtx base, rtx addr, int reloc)\n {\n   rtx mem;\n \n@@ -1670,9 +1578,7 @@ mips_load_got (base, addr, reloc)\n    The returned address may be used on the right hand side of a SET.  */\n \n static rtx\n-mips_load_got16 (addr, reloc)\n-     rtx addr;\n-     int reloc;\n+mips_load_got16 (rtx addr, int reloc)\n {\n   return mips_load_got (pic_offset_table_rtx, addr, reloc);\n }\n@@ -1684,9 +1590,7 @@ mips_load_got16 (addr, reloc)\n    to use a temporary, or null if new registers can be created at will.  */\n \n static rtx\n-mips_load_got32 (temp, addr, high_reloc, low_reloc)\n-     rtx temp, addr;\n-     int high_reloc, low_reloc;\n+mips_load_got32 (rtx temp, rtx addr, int high_reloc, int low_reloc)\n {\n   rtx x;\n \n@@ -1701,8 +1605,7 @@ mips_load_got32 (temp, addr, high_reloc, low_reloc)\n    Use DEST as the register if non-null.  */\n \n static rtx\n-mips_emit_high (dest, addr)\n-     rtx dest, addr;\n+mips_emit_high (rtx dest, rtx addr)\n {\n   rtx high, x;\n \n@@ -1729,9 +1632,7 @@ mips_emit_high (dest, addr)\n    can be created at will.  */\n \n static bool\n-mips_legitimize_symbol (dest, xloc, offsetable_p)\n-     rtx dest, *xloc;\n-     int offsetable_p;\n+mips_legitimize_symbol (rtx dest, rtx *xloc, int offsetable_p)\n {\n   struct mips_constant_info c;\n   enum mips_symbol_type symbol_type;\n@@ -1801,9 +1702,7 @@ mips_legitimize_symbol (dest, xloc, offsetable_p)\n    the memory being accessed.  */\n \n bool\n-mips_legitimize_address (xloc, mode)\n-     rtx *xloc;\n-     enum machine_mode mode;\n+mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n {\n   if (mips_legitimize_symbol (0, xloc, !SINGLE_WORD_MODE_P (mode)))\n     return true;\n@@ -1828,9 +1727,7 @@ mips_legitimize_address (xloc, mode)\n    Assume that the final action in the sequence should be a left shift.  */\n \n static unsigned int\n-mips_build_shift (codes, value)\n-     struct mips_integer_op *codes;\n-     HOST_WIDE_INT value;\n+mips_build_shift (struct mips_integer_op *codes, HOST_WIDE_INT value)\n {\n   unsigned int i, shift;\n \n@@ -1851,9 +1748,7 @@ mips_build_shift (codes, value)\n    an IOR or PLUS operation.  */\n \n static unsigned int\n-mips_build_lower (codes, value)\n-     struct mips_integer_op *codes;\n-     unsigned HOST_WIDE_INT value;\n+mips_build_lower (struct mips_integer_op *codes, unsigned HOST_WIDE_INT value)\n {\n   unsigned HOST_WIDE_INT high;\n   unsigned int i;\n@@ -1884,9 +1779,8 @@ mips_build_lower (codes, value)\n    Return the number of operations needed.  */\n \n static unsigned int\n-mips_build_integer (codes, value)\n-     struct mips_integer_op *codes;\n-     unsigned HOST_WIDE_INT value;\n+mips_build_integer (struct mips_integer_op *codes,\n+\t\t    unsigned HOST_WIDE_INT value)\n {\n   if (SMALL_OPERAND (value)\n       || SMALL_OPERAND_UNSIGNED (value)\n@@ -1934,9 +1828,7 @@ mips_build_integer (codes, value)\n /* Move VALUE into register DEST.  */\n \n static void\n-mips_move_integer (dest, value)\n-     rtx dest;\n-     unsigned HOST_WIDE_INT value;\n+mips_move_integer (rtx dest, unsigned HOST_WIDE_INT value)\n {\n   struct mips_integer_op codes[MIPS_MAX_INTEGER_OPS];\n   enum machine_mode mode;\n@@ -1967,9 +1859,7 @@ mips_move_integer (dest, value)\n    move_operand.  */\n \n static void\n-mips_legitimize_const_move (mode, dest, src)\n-     enum machine_mode mode;\n-     rtx dest, src;\n+mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n {\n   rtx temp;\n \n@@ -2027,9 +1917,7 @@ mips_legitimize_const_move (mode, dest, src)\n    sequence that is valid.  */\n \n bool\n-mips_legitimize_move (mode, dest, src)\n-     enum machine_mode mode;\n-     rtx dest, src;\n+mips_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n {\n   if (!register_operand (dest, mode) && !reg_or_0_operand (src, mode))\n     {\n@@ -2057,8 +1945,7 @@ mips_legitimize_move (mode, dest, src)\n    Used by both TARGET_DELEGITIMIZE_ADDRESS and FIND_BASE_TERM.  */\n \n rtx\n-mips_delegitimize_address (x)\n-     rtx x;\n+mips_delegitimize_address (rtx x)\n {\n   struct mips_constant_info c;\n \n@@ -2084,11 +1971,7 @@ mips_delegitimize_address (x)\n    there aren't nearly enough letters available.  */\n \n static int\n-m16_check_op (op, low, high, mask)\n-     rtx op;\n-     int low;\n-     int high;\n-     int mask;\n+m16_check_op (rtx op, int low, int high, int mask)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && INTVAL (op) >= low\n@@ -2097,129 +1980,97 @@ m16_check_op (op, low, high, mask)\n }\n \n int\n-m16_uimm3_b (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_uimm3_b (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, 0x1, 0x8, 0);\n }\n \n int\n-m16_simm4_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_simm4_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0x8, 0x7, 0);\n }\n \n int\n-m16_nsimm4_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nsimm4_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0x7, 0x8, 0);\n }\n \n int\n-m16_simm5_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_simm5_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0x10, 0xf, 0);\n }\n \n int\n-m16_nsimm5_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nsimm5_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0xf, 0x10, 0);\n }\n \n int\n-m16_uimm5_4 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_uimm5_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, (- 0x10) << 2, 0xf << 2, 3);\n }\n \n int\n-m16_nuimm5_4 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nuimm5_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, (- 0xf) << 2, 0x10 << 2, 3);\n }\n \n int\n-m16_simm8_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_simm8_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0x80, 0x7f, 0);\n }\n \n int\n-m16_nsimm8_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nsimm8_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0x7f, 0x80, 0);\n }\n \n int\n-m16_uimm8_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_uimm8_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, 0x0, 0xff, 0);\n }\n \n int\n-m16_nuimm8_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nuimm8_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0xff, 0x0, 0);\n }\n \n int\n-m16_uimm8_m1_1 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_uimm8_m1_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, - 0x1, 0xfe, 0);\n }\n \n int\n-m16_uimm8_4 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_uimm8_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, 0x0, 0xff << 2, 3);\n }\n \n int\n-m16_nuimm8_4 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nuimm8_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, (- 0xff) << 2, 0x0, 3);\n }\n \n int\n-m16_simm8_8 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_simm8_8 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, (- 0x80) << 3, 0x7f << 3, 7);\n }\n \n int\n-m16_nsimm8_8 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_nsimm8_8 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return m16_check_op (op, (- 0x7f) << 3, 0x80 << 3, 7);\n }\n@@ -2230,9 +2081,7 @@ m16_nsimm8_8 (op, mode)\n    referencing instruction.  */\n \n int\n-m16_usym8_4 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_usym8_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (op)\n@@ -2257,9 +2106,7 @@ m16_usym8_4 (op, mode)\n }\n \n int\n-m16_usym5_4 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m16_usym5_4 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (op)\n@@ -2284,10 +2131,7 @@ m16_usym5_4 (op, mode)\n }\n \f\n static bool\n-mips_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n@@ -2565,8 +2409,7 @@ mips_rtx_costs (x, code, outer_code, total)\n    If ADDR is not a valid address, its cost is irrelevant.  */\n \n static int\n-mips_address_cost (addr)\n-     rtx addr;\n+mips_address_cost (rtx addr)\n {\n   return mips_address_insns (addr, SImode);\n }\n@@ -2576,7 +2419,7 @@ mips_address_cost (addr)\n    pseudo is emitted in the beginning of the function.  */\n \n rtx\n-embedded_pic_fnaddr_reg ()\n+embedded_pic_fnaddr_reg (void)\n {\n   if (cfun->machine->embedded_pic_fnaddr_rtx == NULL)\n     {\n@@ -2609,8 +2452,7 @@ embedded_pic_fnaddr_reg ()\n    X is the symbol whose offset from the current function we want.  */\n \n rtx\n-embedded_pic_offset (x)\n-     rtx x;\n+embedded_pic_offset (rtx x)\n {\n   /* Make sure it is emitted.  */\n   embedded_pic_fnaddr_reg ();\n@@ -2626,9 +2468,7 @@ embedded_pic_offset (x)\n    false to select the low part.  */\n \n rtx\n-mips_subword (op, high_p)\n-     rtx op;\n-     int high_p;\n+mips_subword (rtx op, int high_p)\n {\n   unsigned int byte;\n   enum machine_mode mode;\n@@ -2660,8 +2500,7 @@ mips_subword (op, high_p)\n /* Return true if a 64-bit move from SRC to DEST should be split into two.  */\n \n bool\n-mips_split_64bit_move_p (dest, src)\n-     rtx dest, src;\n+mips_split_64bit_move_p (rtx dest, rtx src)\n {\n   if (TARGET_64BIT)\n     return false;\n@@ -2699,8 +2538,7 @@ mips_split_64bit_move_p (dest, src)\n    load_df_high and store_df_high instead.  */\n \n void\n-mips_split_64bit_move (dest, src)\n-     rtx dest, src;\n+mips_split_64bit_move (rtx dest, rtx src)\n {\n   if (FP_REG_RTX_P (dest))\n     {\n@@ -2740,8 +2578,7 @@ mips_split_64bit_move (dest, src)\n    that SRC is operand 1 and DEST is operand 0.  */\n \n const char *\n-mips_output_move (dest, src)\n-     rtx dest, src;\n+mips_output_move (rtx dest, rtx src)\n {\n   enum rtx_code dest_code, src_code;\n   struct mips_constant_info c;\n@@ -2876,8 +2713,7 @@ mips_output_move (dest, src)\n    on entry.  */\n \n const char *\n-mips_restore_gp (operands)\n-     rtx *operands;\n+mips_restore_gp (rtx *operands)\n {\n   rtx loc;\n \n@@ -2896,8 +2732,7 @@ mips_restore_gp (operands)\n /* Make normal rtx_code into something we can index from an array */\n \n static enum internal_test\n-map_test_to_internal_test (test_code)\n-     enum rtx_code test_code;\n+map_test_to_internal_test (enum rtx_code test_code)\n {\n   enum internal_test test = ITEST_MAX;\n \n@@ -2939,16 +2774,16 @@ map_test_to_internal_test (test_code)\n      return i < 5;\n    }\n \n-   */\n+   TEST_CODE is the rtx code for the comparison.\n+   CMP0 and CMP1 are the two operands to compare.\n+   RESULT is the register in which the result should be stored (null for\n+     branches).\n+   For branches, P_INVERT points to an integer that is nonzero on return\n+     if the branch should be inverted.  */\n \n rtx\n-gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n-     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n-     rtx result;\t\t/* result to store comp. or 0 if branch */\n-     rtx cmp0;\t\t\t/* first operand to compare */\n-     rtx cmp1;\t\t\t/* second operand to compare */\n-     int *p_invert;\t\t/* NULL or ptr to hold whether branch needs */\n-\t\t\t\t/* to reverse its test */\n+gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0,\n+\t\t    rtx cmp1, int *p_invert)\n {\n   struct cmp_info\n   {\n@@ -3144,8 +2979,8 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n    and *action_code to the branch or move code.  */\n \n static void\n-get_float_compare_codes (in_code, cmp_code, action_code)\n-     enum rtx_code in_code, *cmp_code, *action_code;\n+get_float_compare_codes (enum rtx_code in_code, enum rtx_code *cmp_code,\n+\t\t\t enum rtx_code *action_code)\n {\n   switch (in_code)\n     {\n@@ -3170,9 +3005,7 @@ get_float_compare_codes (in_code, cmp_code, action_code)\n    The comparison operands are saved away by cmp{si,di,sf,df}.  */\n \n void\n-gen_conditional_branch (operands, test_code)\n-     rtx operands[];\n-     enum rtx_code test_code;\n+gen_conditional_branch (rtx *operands, enum rtx_code test_code)\n {\n   enum cmp_type type = branch_type;\n   rtx cmp0 = branch_cmp[0];\n@@ -3247,8 +3080,7 @@ gen_conditional_branch (operands, test_code)\n    of operands passed to the conditional move define_expand.  */\n \n void\n-gen_conditional_move (operands)\n-     rtx *operands;\n+gen_conditional_move (rtx *operands)\n {\n   rtx op0 = branch_cmp[0];\n   rtx op1 = branch_cmp[1];\n@@ -3334,8 +3166,7 @@ gen_conditional_move (operands)\n    the conditional_trap expander.  */\n \n void\n-mips_gen_conditional_trap (operands)\n-     rtx operands[];\n+mips_gen_conditional_trap (rtx *operands)\n {\n   rtx op0, op1;\n   enum rtx_code cmp_code = GET_CODE (operands[0]);\n@@ -3378,9 +3209,7 @@ mips_gen_conditional_trap (operands)\n    a normal call.  */\n \n void\n-mips_expand_call (result, addr, args_size, aux, sibcall_p)\n-     rtx result, addr, args_size, aux;\n-     int sibcall_p;\n+mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n {\n   int i;\n \n@@ -3440,9 +3269,8 @@ mips_expand_call (result, addr, args_size, aux, sibcall_p)\n /* We can handle any sibcall when TARGET_SIBCALLS is true.  */\n \n static bool\n-mips_function_ok_for_sibcall (decl, exp)\n-     tree decl ATTRIBUTE_UNUSED;\n-     tree exp ATTRIBUTE_UNUSED;\n+mips_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n+\t\t\t      tree exp ATTRIBUTE_UNUSED)\n {\n   return TARGET_SIBCALLS;\n }\n@@ -3451,9 +3279,7 @@ mips_function_ok_for_sibcall (decl, exp)\n    Only for use during or after reload.  */\n \n int\n-fcc_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fcc_register_operand (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || mode == GET_MODE (op))\n \t  && (reload_in_progress || reload_completed)\n@@ -3473,8 +3299,7 @@ fcc_register_operand (op, mode)\n    taken from SCRATCH.  */\n \n void\n-mips_emit_fcc_reload (dest, src, scratch)\n-     rtx dest, src, scratch;\n+mips_emit_fcc_reload (rtx dest, rtx src, rtx scratch)\n {\n   rtx fp1, fp2;\n \n@@ -3497,8 +3322,7 @@ mips_emit_fcc_reload (dest, src, scratch)\n    ADDRESS and SCRATCH are both word-mode GPRs.  */\n \n void\n-mips_set_return_address (address, scratch)\n-     rtx address, scratch;\n+mips_set_return_address (rtx address, rtx scratch)\n {\n   HOST_WIDE_INT gp_offset;\n \n@@ -3526,9 +3350,7 @@ mips_set_return_address (address, scratch)\n    Assume that the areas do not overlap.  */\n \n static void\n-mips_block_move_straight (dest, src, length)\n-     rtx dest, src;\n-     HOST_WIDE_INT length;\n+mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n {\n   HOST_WIDE_INT offset, delta;\n   unsigned HOST_WIDE_INT bits;\n@@ -3602,9 +3424,8 @@ mips_block_move_straight (dest, src, length)\n    register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */\n \n static void\n-mips_adjust_block_mem (mem, length, loop_reg, loop_mem)\n-     rtx mem, *loop_reg, *loop_mem;\n-     HOST_WIDE_INT length;\n+mips_adjust_block_mem (rtx mem, HOST_WIDE_INT length,\n+\t\t       rtx *loop_reg, rtx *loop_mem)\n {\n   *loop_reg = copy_addr_to_reg (XEXP (mem, 0));\n \n@@ -3620,9 +3441,7 @@ mips_adjust_block_mem (mem, length, loop_reg, loop_mem)\n    memory regions do not overlap.  */\n \n static void\n-mips_block_move_loop (dest, src, length)\n-     rtx dest, src;\n-     HOST_WIDE_INT length;\n+mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length)\n {\n   rtx label, src_reg, dest_reg, final_src;\n   HOST_WIDE_INT leftover;\n@@ -3665,8 +3484,7 @@ mips_block_move_loop (dest, src, length)\n /* Expand a movstrsi instruction.  */\n \n bool\n-mips_expand_block_move (dest, src, length)\n-     rtx dest, src, length;\n+mips_expand_block_move (rtx dest, rtx src, rtx length)\n {\n   if (GET_CODE (length) == CONST_INT)\n     {\n@@ -3689,10 +3507,8 @@ mips_expand_block_move (dest, src, length)\n /* Initialize CUMULATIVE_ARGS for a function.  */\n \n void\n-init_cumulative_args (cum, fntype, libname)\n-     CUMULATIVE_ARGS *cum;\t\t/* argument info to initialize */\n-     tree fntype;\t\t\t/* tree ptr for function decl */\n-     rtx libname ATTRIBUTE_UNUSED;\t/* SYMBOL_REF of library name or 0 */\n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n+\t\t      rtx libname ATTRIBUTE_UNUSED)\n {\n   static CUMULATIVE_ARGS zero_cum;\n   tree param, next_param;\n@@ -3731,13 +3547,15 @@ init_cumulative_args (cum, fntype, libname)\n     }\n }\n \n+\n+/* Fill INFO with information about a single argument.  CUM is the\n+   cumulative state for earlier arguments.  MODE is the mode of this\n+   argument and TYPE is its type (if known).  NAMED is true if this\n+   is a named (fixed) argument rather than a variable one.  */\n+\n static void\n-mips_arg_info (cum, mode, type, named, info)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-     struct mips_arg_info *info;\n+mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t       tree type, int named, struct mips_arg_info *info)\n {\n   bool even_reg_p;\n   unsigned int num_words, max_regs;\n@@ -3823,14 +3641,11 @@ mips_arg_info (cum, mode, type, named, info)\n }\n \n \n-/* Advance the argument to the next argument position.  */\n+/* Implement FUNCTION_ARG_ADVANCE.  */\n \n void\n-function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* whether or not the argument was named */\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t      tree type, int named)\n {\n   struct mips_arg_info info;\n \n@@ -3886,15 +3701,11 @@ function_arg_advance (cum, mode, type, named)\n   cum->arg_number++;\n }\n \n-/* Return an RTL expression containing the register for the given mode,\n-   or 0 if the argument is to be passed on the stack.  */\n+/* Implement FUNCTION_ARG.  */\n \n struct rtx_def *\n-function_arg (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum; /* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t      tree type, int named)\n {\n   struct mips_arg_info info;\n \n@@ -3995,12 +3806,12 @@ function_arg (cum, mode, type, named)\n     return gen_rtx_REG (mode, GP_ARG_FIRST + info.reg_offset);\n }\n \n+\n+/* Implement FUNCTION_ARG_PARTIAL_NREGS.  */\n+\n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum; /* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+function_arg_partial_nregs (const CUMULATIVE_ARGS *cum,\n+\t\t\t    enum machine_mode mode, tree type, int named)\n {\n   struct mips_arg_info info;\n \n@@ -4009,11 +3820,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n }\n \f\n int\n-mips_setup_incoming_varargs (cum, mode, type, no_rtl)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int no_rtl;\n+mips_setup_incoming_varargs (const CUMULATIVE_ARGS *cum,\n+\t\t\t     enum machine_mode mode, tree type, int no_rtl)\n {\n   CUMULATIVE_ARGS local_cum;\n   int gp_saved, fp_saved;\n@@ -4105,7 +3913,7 @@ mips_setup_incoming_varargs (cum, mode, type, no_rtl)\n \n \n tree\n-mips_build_va_list ()\n+mips_build_va_list (void)\n {\n   if (EABI_FLOAT_VARARGS_P)\n     {\n@@ -4152,12 +3960,10 @@ mips_build_va_list ()\n     return ptr_type_node;\n }\n \n-/* Implement va_start.   stdarg_p is always 1.  */\n+/* Implement va_start.  */\n \n void\n-mips_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+mips_va_start (tree valist, rtx nextarg)\n {\n   const CUMULATIVE_ARGS *cum = &current_function_args_info;\n \n@@ -4250,148 +4056,10 @@ mips_va_start (valist, nextarg)\n     std_expand_builtin_va_start (valist, nextarg);\n }\n \f\n-/* Return true if it is possible to use left/right accesses for a\n-   bitfield of WIDTH bits starting BITPOS bits into *OP.  When\n-   returning true, update *OP, *LEFT and *RIGHT as follows:\n-\n-   *OP is a BLKmode reference to the whole field.\n-\n-   *LEFT is a QImode reference to the first byte if big endian or\n-   the last byte if little endian.  This address can be used in the\n-   left-side instructions (lwl, swl, ldl, sdl).\n-\n-   *RIGHT is a QImode reference to the opposite end of the field and\n-   can be used in the parterning right-side instruction.  */\n-\n-static bool\n-mips_get_unaligned_mem (op, width, bitpos, left, right)\n-     rtx *op, *left, *right;\n-     unsigned int width;\n-     int bitpos;\n-{\n-  rtx first, last;\n-\n-  /* Check that the operand really is a MEM.  Not all the extv and\n-     extzv predicates are checked.  */\n-  if (GET_CODE (*op) != MEM)\n-    return false;\n-\n-  /* Check that the size is valid.  */\n-  if (width != 32 && (!TARGET_64BIT || width != 64))\n-    return false;\n-\n-  /* We can only access byte-aligned values.  Since we are always passed\n-     a reference to the first byte of the field, it is not necessary to\n-     do anything with BITPOS after this check.  */\n-  if (bitpos % BITS_PER_UNIT != 0)\n-    return false;\n-\n-  /* Reject aligned bitfields: we want to use a normal load or store\n-     instead of a left/right pair.  */\n-  if (MEM_ALIGN (*op) >= width)\n-    return false;\n-\n-  /* Adjust *OP to refer to the whole field.  This also has the effect\n-     of legitimizing *OP's address for BLKmode, possibly simplifying it.  */\n-  *op = adjust_address (*op, BLKmode, 0);\n-  set_mem_size (*op, GEN_INT (width / BITS_PER_UNIT));\n-\n-  /* Get references to both ends of the field.  We deliberately don't\n-     use the original QImode *OP for FIRST since the new BLKmode one\n-     might have a simpler address.  */\n-  first = adjust_address (*op, QImode, 0);\n-  last = adjust_address (*op, QImode, width / BITS_PER_UNIT - 1);\n-\n-  /* Allocate to LEFT and RIGHT according to endiannes.  LEFT should\n-     be the upper word and RIGHT the lower word.  */\n-  if (TARGET_BIG_ENDIAN)\n-    *left = first, *right = last;\n-  else\n-    *left = last, *right = first;\n-\n-  return true;\n-}\n-\n-\n-/* Try to emit the equivalent of (set DEST (zero_extract SRC WIDTH BITPOS)).\n-   Return true on success.  We only handle cases where zero_extract is\n-   equivalent to sign_extract.  */\n-\n-bool\n-mips_expand_unaligned_load (dest, src, width, bitpos)\n-     rtx dest, src;\n-     unsigned int width;\n-     int bitpos;\n-{\n-  rtx left, right;\n-\n-  /* If TARGET_64BIT, the destination of a 32-bit load will be a\n-     paradoxical word_mode subreg.  This is the only case in which\n-     we allow the destination to be larger than the source.  */\n-  if (GET_CODE (dest) == SUBREG\n-      && GET_MODE (dest) == DImode\n-      && SUBREG_BYTE (dest) == 0\n-      && GET_MODE (SUBREG_REG (dest)) == SImode)\n-    dest = SUBREG_REG (dest);\n-\n-  /* After the above adjustment, the destination must be the same\n-     width as the source.  */\n-  if (GET_MODE_BITSIZE (GET_MODE (dest)) != width)\n-    return false;\n-\n-  if (!mips_get_unaligned_mem (&src, width, bitpos, &left, &right))\n-    return false;\n-\n-  if (GET_MODE (dest) == DImode)\n-    {\n-      emit_insn (gen_mov_ldl (dest, src, left));\n-      emit_insn (gen_mov_ldr (copy_rtx (dest), copy_rtx (src),\n-\t\t\t      right, copy_rtx (dest)));\n-    }\n-  else\n-    {\n-      emit_insn (gen_mov_lwl (dest, src, left));\n-      emit_insn (gen_mov_lwr (copy_rtx (dest), copy_rtx (src),\n-\t\t\t      right, copy_rtx (dest)));\n-    }\n-  return true;\n-}\n-\n-\n-/* Try to expand (set (zero_extract DEST WIDTH BITPOS) SRC).  Return\n-   true on success.  */\n-\n-bool\n-mips_expand_unaligned_store (dest, src, width, bitpos)\n-     rtx dest, src;\n-     unsigned int width;\n-     int bitpos;\n-{\n-  rtx left, right;\n-\n-  if (!mips_get_unaligned_mem (&dest, width, bitpos, &left, &right))\n-    return false;\n-\n-  src = gen_lowpart (mode_for_size (width, MODE_INT, 0), src);\n-\n-  if (GET_MODE (src) == DImode)\n-    {\n-      emit_insn (gen_mov_sdl (dest, src, left));\n-      emit_insn (gen_mov_sdr (copy_rtx (dest), copy_rtx (src), right));\n-    }\n-  else\n-    {\n-      emit_insn (gen_mov_swl (dest, src, left));\n-      emit_insn (gen_mov_swr (copy_rtx (dest), copy_rtx (src), right));\n-    }\n-  return true;\n-}\n-\f\n /* Implement va_arg.  */\n \n rtx\n-mips_va_arg (valist, type)\n-     tree valist, type;\n+mips_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size, rsize;\n   rtx addr_rtx;\n@@ -4620,12 +4288,140 @@ mips_va_arg (valist, type)\n     }\n }\n \f\n+/* Return true if it is possible to use left/right accesses for a\n+   bitfield of WIDTH bits starting BITPOS bits into *OP.  When\n+   returning true, update *OP, *LEFT and *RIGHT as follows:\n+\n+   *OP is a BLKmode reference to the whole field.\n+\n+   *LEFT is a QImode reference to the first byte if big endian or\n+   the last byte if little endian.  This address can be used in the\n+   left-side instructions (lwl, swl, ldl, sdl).\n+\n+   *RIGHT is a QImode reference to the opposite end of the field and\n+   can be used in the parterning right-side instruction.  */\n+\n+static bool\n+mips_get_unaligned_mem (rtx *op, unsigned int width, int bitpos,\n+\t\t\trtx *left, rtx *right)\n+{\n+  rtx first, last;\n+\n+  /* Check that the operand really is a MEM.  Not all the extv and\n+     extzv predicates are checked.  */\n+  if (GET_CODE (*op) != MEM)\n+    return false;\n+\n+  /* Check that the size is valid.  */\n+  if (width != 32 && (!TARGET_64BIT || width != 64))\n+    return false;\n+\n+  /* We can only access byte-aligned values.  Since we are always passed\n+     a reference to the first byte of the field, it is not necessary to\n+     do anything with BITPOS after this check.  */\n+  if (bitpos % BITS_PER_UNIT != 0)\n+    return false;\n+\n+  /* Reject aligned bitfields: we want to use a normal load or store\n+     instead of a left/right pair.  */\n+  if (MEM_ALIGN (*op) >= width)\n+    return false;\n+\n+  /* Adjust *OP to refer to the whole field.  This also has the effect\n+     of legitimizing *OP's address for BLKmode, possibly simplifying it.  */\n+  *op = adjust_address (*op, BLKmode, 0);\n+  set_mem_size (*op, GEN_INT (width / BITS_PER_UNIT));\n+\n+  /* Get references to both ends of the field.  We deliberately don't\n+     use the original QImode *OP for FIRST since the new BLKmode one\n+     might have a simpler address.  */\n+  first = adjust_address (*op, QImode, 0);\n+  last = adjust_address (*op, QImode, width / BITS_PER_UNIT - 1);\n+\n+  /* Allocate to LEFT and RIGHT according to endiannes.  LEFT should\n+     be the upper word and RIGHT the lower word.  */\n+  if (TARGET_BIG_ENDIAN)\n+    *left = first, *right = last;\n+  else\n+    *left = last, *right = first;\n+\n+  return true;\n+}\n+\n+\n+/* Try to emit the equivalent of (set DEST (zero_extract SRC WIDTH BITPOS)).\n+   Return true on success.  We only handle cases where zero_extract is\n+   equivalent to sign_extract.  */\n+\n+bool\n+mips_expand_unaligned_load (rtx dest, rtx src, unsigned int width, int bitpos)\n+{\n+  rtx left, right;\n+\n+  /* If TARGET_64BIT, the destination of a 32-bit load will be a\n+     paradoxical word_mode subreg.  This is the only case in which\n+     we allow the destination to be larger than the source.  */\n+  if (GET_CODE (dest) == SUBREG\n+      && GET_MODE (dest) == DImode\n+      && SUBREG_BYTE (dest) == 0\n+      && GET_MODE (SUBREG_REG (dest)) == SImode)\n+    dest = SUBREG_REG (dest);\n+\n+  /* After the above adjustment, the destination must be the same\n+     width as the source.  */\n+  if (GET_MODE_BITSIZE (GET_MODE (dest)) != width)\n+    return false;\n+\n+  if (!mips_get_unaligned_mem (&src, width, bitpos, &left, &right))\n+    return false;\n+\n+  if (GET_MODE (dest) == DImode)\n+    {\n+      emit_insn (gen_mov_ldl (dest, src, left));\n+      emit_insn (gen_mov_ldr (copy_rtx (dest), copy_rtx (src),\n+\t\t\t      right, copy_rtx (dest)));\n+    }\n+  else\n+    {\n+      emit_insn (gen_mov_lwl (dest, src, left));\n+      emit_insn (gen_mov_lwr (copy_rtx (dest), copy_rtx (src),\n+\t\t\t      right, copy_rtx (dest)));\n+    }\n+  return true;\n+}\n+\n+\n+/* Try to expand (set (zero_extract DEST WIDTH BITPOS) SRC).  Return\n+   true on success.  */\n+\n+bool\n+mips_expand_unaligned_store (rtx dest, rtx src, unsigned int width, int bitpos)\n+{\n+  rtx left, right;\n+\n+  if (!mips_get_unaligned_mem (&dest, width, bitpos, &left, &right))\n+    return false;\n+\n+  src = gen_lowpart (mode_for_size (width, MODE_INT, 0), src);\n+\n+  if (GET_MODE (src) == DImode)\n+    {\n+      emit_insn (gen_mov_sdl (dest, src, left));\n+      emit_insn (gen_mov_sdr (copy_rtx (dest), copy_rtx (src), right));\n+    }\n+  else\n+    {\n+      emit_insn (gen_mov_swl (dest, src, left));\n+      emit_insn (gen_mov_swr (copy_rtx (dest), copy_rtx (src), right));\n+    }\n+  return true;\n+}\n+\f\n /* Set up globals to generate code for the ISA or processor\n    described by INFO.  */\n \n static void\n-mips_set_architecture (info)\n-     const struct mips_cpu_info *info;\n+mips_set_architecture (const struct mips_cpu_info *info)\n {\n   if (info != 0)\n     {\n@@ -4639,8 +4435,7 @@ mips_set_architecture (info)\n /* Likewise for tuning.  */\n \n static void\n-mips_set_tune (info)\n-     const struct mips_cpu_info *info;\n+mips_set_tune (const struct mips_cpu_info *info)\n {\n   if (info != 0)\n     {\n@@ -4654,7 +4449,7 @@ mips_set_tune (info)\n    of the normal data area, and detect any conflicts in the switches.  */\n \n void\n-override_options ()\n+override_options (void)\n {\n   int i, start, regno;\n   enum machine_mode mode;\n@@ -5112,7 +4907,7 @@ override_options ()\n /* Implement CONDITIONAL_REGISTER_USAGE.  */\n \n void\n-mips_conditional_register_usage ()\n+mips_conditional_register_usage (void)\n {\n   if (!TARGET_HARD_FLOAT)\n     {\n@@ -5167,7 +4962,7 @@ mips_conditional_register_usage ()\n \n /* Allocate a chunk of memory for per-function machine-dependent data.  */\n static struct machine_function *\n-mips_init_machine_status ()\n+mips_init_machine_status (void)\n {\n   return ((struct machine_function *)\n \t  ggc_alloc_cleared (sizeof (struct machine_function)));\n@@ -5179,7 +4974,7 @@ mips_init_machine_status ()\n    encouraging the compiler to use a cmp instead.  */\n \n void\n-mips_order_regs_for_local_alloc ()\n+mips_order_regs_for_local_alloc (void)\n {\n   register int i;\n \n@@ -5206,9 +5001,7 @@ mips_order_regs_for_local_alloc ()\n    the initial adjustments.  */\n \n HOST_WIDE_INT\n-mips_debugger_offset (addr, offset)\n-     rtx addr;\n-     HOST_WIDE_INT offset;\n+mips_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n {\n   rtx offset2 = const0_rtx;\n   rtx reg = eliminate_constant_term (addr, &offset2);\n@@ -5286,10 +5079,7 @@ mips_debugger_offset (addr, offset)\n    '~'\tOutput a branch alignment to LABEL_ALIGN(NULL).  */\n \n void\n-print_operand (file, op, letter)\n-     FILE *file;\t\t/* file to write to */\n-     rtx op;\t\t\t/* operand to print */\n-     int letter;\t\t/* %<letter> or 0 */\n+print_operand (FILE *file, rtx op, int letter)\n {\n   register enum rtx_code code;\n   struct mips_constant_info c;\n@@ -5603,8 +5393,7 @@ print_operand (file, op, letter)\n /* Return the assembly operator used for the given type of relocation.  */\n \n static const char *\n-mips_reloc_string (reloc)\n-     int reloc;\n+mips_reloc_string (int reloc)\n {\n   switch (reloc)\n     {\n@@ -5625,9 +5414,7 @@ mips_reloc_string (reloc)\n /* Output address operand X to FILE.   */\n \n void\n-print_operand_address (file, x)\n-     FILE *file;\n-     rtx x;\n+print_operand_address (FILE *file, rtx x)\n {\n   struct mips_address_info addr;\n \n@@ -5659,10 +5446,7 @@ print_operand_address (file, x)\n    such an integer here.  */\n \n static bool\n-mips_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+mips_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if ((TARGET_64BIT || TARGET_GAS) && size == 8 && aligned_p)\n     {\n@@ -5686,10 +5470,7 @@ mips_assemble_integer (x, size, aligned_p)\n    than .sbss or .sdata.  */\n \n int\n-mips_output_external (file, decl, name)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     tree decl;\n-     const char *name;\n+mips_output_external (FILE *file ATTRIBUTE_UNUSED, tree decl, const char *name)\n {\n   register struct extern_list *p;\n \n@@ -5724,9 +5505,7 @@ mips_output_external (file, decl, name)\n \n #ifdef ASM_OUTPUT_UNDEF_FUNCTION\n int\n-mips_output_external_libcall (file, name)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     const char *name;\n+mips_output_external_libcall (FILE *file ATTRIBUTE_UNUSED, const char *name)\n {\n   register struct extern_list *p;\n \n@@ -5744,9 +5523,7 @@ mips_output_external_libcall (file, name)\n    put out a MIPS ECOFF file and a stab.  */\n \n void\n-mips_output_filename (stream, name)\n-     FILE *stream;\n-     const char *name;\n+mips_output_filename (FILE *stream, const char *name)\n {\n   char ltext_label_name[100];\n \n@@ -5788,9 +5565,7 @@ mips_output_filename (stream, name)\n    file.  */\n \n void\n-mips_output_lineno (stream, line)\n-     FILE *stream;\n-     int line;\n+mips_output_lineno (FILE *stream, int line)\n {\n   if (write_symbols == DBX_DEBUG)\n     {\n@@ -5809,10 +5584,7 @@ mips_output_lineno (stream, line)\n /* Output an ASCII string, in a space-saving way.  */\n \n void\n-mips_output_ascii (stream, string_param, len)\n-     FILE *stream;\n-     const char *string_param;\n-     size_t len;\n+mips_output_ascii (FILE *stream, const char *string_param, size_t len)\n {\n   size_t i;\n   int cur_pos = 17;\n@@ -5888,7 +5660,7 @@ mips_output_ascii (stream, string_param, len)\n /* Implement TARGET_ASM_FILE_START.  */\n \n static void\n-mips_file_start ()\n+mips_file_start (void)\n {\n   default_file_start ();\n \n@@ -5955,12 +5727,8 @@ mips_file_start ()\n    in the use of sbss.  */\n \n void\n-mips_output_aligned_bss (stream, decl, name, size, align)\n-     FILE *stream;\n-     tree decl;\n-     const char *name;\n-     unsigned HOST_WIDE_INT size;\n-     int align;\n+mips_output_aligned_bss (FILE *stream, tree decl, const char *name,\n+\t\t\t unsigned HOST_WIDE_INT size, int align)\n {\n   extern tree last_assemble_variable_decl;\n \n@@ -5979,7 +5747,7 @@ mips_output_aligned_bss (stream, decl, name, size, align)\n    .externs for any small-data variables that turned out to be external.  */\n \n static void\n-mips_file_end ()\n+mips_file_end (void)\n {\n   tree name_tree;\n   struct extern_list *p;\n@@ -6016,12 +5784,8 @@ mips_file_end ()\n    .extern for it.  */\n \n void\n-mips_declare_object (stream, name, init_string, final_string, size)\n-     FILE *stream;\n-     const char *name;\n-     const char *init_string;\n-     const char *final_string;\n-     int size;\n+mips_declare_object (FILE *stream, const char *name, const char *init_string,\n+\t\t     const char *final_string, int size)\n {\n   fputs (init_string, stream);\t\t/* \"\", \"\\t.comm\\t\", or \"\\t.lcomm\\t\" */\n   assemble_name (stream, name);\n@@ -6041,10 +5805,8 @@ extern int size_directive_output;\n    definitions except that it uses mips_declare_object() to emit the label.  */\n \n void\n-mips_declare_object_name (stream, name, decl)\n-     FILE *stream;\n-     const char *name;\n-     tree decl ATTRIBUTE_UNUSED;\n+mips_declare_object_name (FILE *stream, const char *name,\n+\t\t\t  tree decl ATTRIBUTE_UNUSED)\n {\n #ifdef ASM_OUTPUT_TYPE_DIRECTIVE\n   ASM_OUTPUT_TYPE_DIRECTIVE (stream, name, \"object\");\n@@ -6066,10 +5828,7 @@ mips_declare_object_name (stream, name, decl)\n /* Implement ASM_FINISH_DECLARE_OBJECT.  This is generic ELF stuff.  */\n \n void\n-mips_finish_declare_object (stream, decl, top_level, at_end)\n-     FILE *stream;\n-     tree decl;\n-     int top_level, at_end;\n+mips_finish_declare_object (FILE *stream, tree decl, int top_level, int at_end)\n {\n   const char *name;\n \n@@ -6094,7 +5853,7 @@ mips_finish_declare_object (stream, decl, top_level, at_end)\n    a global pointer.  */\n \n static unsigned int\n-mips_global_pointer ()\n+mips_global_pointer (void)\n {\n   unsigned int regno;\n \n@@ -6144,8 +5903,7 @@ mips_global_pointer ()\n /* Return true if the current function must save REGNO.  */\n \n static bool\n-mips_save_reg_p (regno)\n-     unsigned int regno;\n+mips_save_reg_p (unsigned int regno)\n {\n   /* We only need to save $gp for NewABI PIC.  */\n   if (regno == GLOBAL_POINTER_REGNUM)\n@@ -6201,7 +5959,7 @@ mips_save_reg_p (regno)\n \n \n /* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.\n+   stack pointer.  SIZE is the size (in bytes) of the local variables.\n \n    Mips stack frames look like:\n \n@@ -6254,8 +6012,7 @@ mips_save_reg_p (regno)\n */\n \n HOST_WIDE_INT\n-compute_frame_size (size)\n-     HOST_WIDE_INT size;\t/* # of var. bytes allocated */\n+compute_frame_size (HOST_WIDE_INT size)\n {\n   unsigned int regno;\n   HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up */\n@@ -6394,8 +6151,7 @@ compute_frame_size (size)\n    hard frame pointer.  */\n \n int\n-mips_initial_elimination_offset (from, to)\n-     int from, to;\n+mips_initial_elimination_offset (int from, int to)\n {\n   int offset;\n \n@@ -6434,9 +6190,7 @@ mips_initial_elimination_offset (from, to)\n /* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n    back to a previous frame.  */\n rtx\n-mips_return_addr (count, frame)\n-     int count;\n-     rtx frame ATTRIBUTE_UNUSED;\n+mips_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n   if (count != 0)\n     return const0_rtx;\n@@ -6452,8 +6206,7 @@ mips_return_addr (count, frame)\n    OFFSET is too large to add in a single instruction.  */\n \n static rtx\n-mips_add_large_offset_to_sp (offset)\n-     HOST_WIDE_INT offset;\n+mips_add_large_offset_to_sp (HOST_WIDE_INT offset)\n {\n   rtx reg = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n   rtx offset_rtx = GEN_INT (offset);\n@@ -6470,8 +6223,7 @@ mips_add_large_offset_to_sp (offset)\n    the operation described by FRAME_PATTERN.  */\n \n static void\n-mips_set_frame_expr (frame_pattern)\n-     rtx frame_pattern;\n+mips_set_frame_expr (rtx frame_pattern)\n {\n   rtx insn;\n \n@@ -6486,9 +6238,7 @@ mips_set_frame_expr (frame_pattern)\n    REG must be a single register.  */\n \n static rtx\n-mips_frame_set (reg, offset)\n-     rtx reg;\n-     int offset;\n+mips_frame_set (rtx reg, int offset)\n {\n   rtx address = plus_constant (stack_pointer_rtx, offset);\n   rtx set = gen_rtx_SET (VOIDmode, gen_rtx_MEM (GET_MODE (reg), address), reg);\n@@ -6502,10 +6252,7 @@ mips_frame_set (reg, offset)\n    function may be asked to store an FPR pair.  */\n \n static void\n-mips_emit_frame_related_store (mem, reg, offset)\n-     rtx mem;\n-     rtx reg;\n-     HOST_WIDE_INT offset;\n+mips_emit_frame_related_store (rtx mem, rtx reg, HOST_WIDE_INT offset)\n {\n   if (GET_MODE (reg) == DFmode && mips_split_64bit_move_p (mem, reg))\n     mips_split_64bit_move (mem, reg);\n@@ -6527,11 +6274,15 @@ mips_emit_frame_related_store (mem, reg, offset)\n     mips_set_frame_expr (mips_frame_set (reg, offset));\n }\n \n+\n+/* Emit instructions to save or restore the registers in\n+   cfun->machine->frame.mask and cfun->machine->frame.fmask.\n+   STORE_P is true to save registers (meaning we are expanding\n+   the prologue).  If nonnull, LARGE_REG stores the value LARGE_OFFSET,\n+   which the caller thinks might be useful to us.  */\n+\n static void\n-save_restore_insns (store_p, large_reg, large_offset)\n-     int store_p;\t/* true if this is prologue */\n-     rtx large_reg;\t/* register holding large offset constant or NULL */\n-     long large_offset;\t/* large constant offset value */\n+save_restore_insns (int store_p, rtx large_reg, long large_offset)\n {\n   long mask = cfun->machine->frame.mask;\n   long fmask = cfun->machine->frame.fmask;\n@@ -6731,9 +6482,7 @@ save_restore_insns (store_p, large_reg, large_offset)\n /* Set up the stack and frame (if desired) for the function.  */\n \n static void\n-mips_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n #ifndef FUNCTION_NAME_ALREADY_DECLARED\n   const char *fnname;\n@@ -6937,8 +6686,7 @@ mips_output_function_prologue (file, size)\n    explicit reloc code, mark the instruction as potentially dead.  */\n \n static void\n-mips_gp_insn (dest, src)\n-     rtx dest, src;\n+mips_gp_insn (rtx dest, rtx src)\n {\n   rtx insn;\n \n@@ -6957,7 +6705,7 @@ mips_gp_insn (dest, src)\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n-mips_expand_prologue ()\n+mips_expand_prologue (void)\n {\n   int regno;\n   HOST_WIDE_INT tsize;\n@@ -7327,9 +7075,8 @@ mips_expand_prologue ()\n #define PIC_OFFSET_TABLE_MASK (1 << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \n static void\n-mips_output_function_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   rtx string;\n \n@@ -7385,8 +7132,7 @@ mips_output_function_epilogue (file, size)\n    \"epilogue\" pattern.  */\n \n void\n-mips_expand_epilogue (sibcall_p)\n-     int sibcall_p;\n+mips_expand_epilogue (int sibcall_p)\n {\n   HOST_WIDE_INT tsize = cfun->machine->frame.total_size;\n   rtx tsize_rtx = GEN_INT (tsize);\n@@ -7534,7 +7280,7 @@ mips_expand_epilogue (sibcall_p)\n    was created.  */\n \n int\n-mips_can_use_return_insn ()\n+mips_can_use_return_insn (void)\n {\n   tree return_type;\n \n@@ -7565,8 +7311,7 @@ mips_can_use_return_insn ()\n /* Returns nonzero if X contains a SYMBOL_REF.  */\n \n static int\n-symbolic_expression_p (x)\n-     rtx x;\n+symbolic_expression_p (rtx x)\n {\n   if (GET_CODE (x) == SYMBOL_REF)\n     return 1;\n@@ -7589,10 +7334,8 @@ symbolic_expression_p (x)\n    mode MODE.  */\n \n static void\n-mips_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+mips_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t unsigned HOST_WIDE_INT align)\n {\n   if (TARGET_MIPS16)\n     {\n@@ -7632,10 +7375,8 @@ mips_select_rtx_section (mode, x, align)\n    any relocatable expression.  */\n \n static void\n-mips_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+mips_select_section (tree decl, int reloc,\n+\t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if ((TARGET_EMBEDDED_PIC || TARGET_MIPS16)\n       && TREE_CODE (decl) == STRING_CST\n@@ -7657,8 +7398,7 @@ mips_select_section (decl, reloc, align)\n    access DECL using %gp_rel(...)($gp).  */\n \n static bool\n-mips_in_small_data_p (decl)\n-     tree decl;\n+mips_in_small_data_p (tree decl)\n {\n   HOST_WIDE_INT size;\n \n@@ -7710,10 +7450,7 @@ mips_in_small_data_p (decl)\n    should treat the symbol as SYMBOL_GOT_LOCAL.  */\n \n static void\n-mips_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+mips_encode_section_info (tree decl, rtx rtl, int first)\n {\n   rtx symbol;\n \n@@ -7799,10 +7536,8 @@ mips_encode_section_info (decl, rtl, first)\n    VALTYPE is null and MODE is the mode of the return value.  */\n \n rtx\n-mips_function_value (valtype, func, mode)\n-     tree valtype;\n-     tree func ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+mips_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n+\t\t     enum machine_mode mode)\n {\n   int reg = GP_RETURN;\n   enum mode_class mclass;\n@@ -7925,11 +7660,9 @@ mips_function_value (valtype, func, mode)\n    nonzero when an argument must be passed by reference.  */\n \n int\n-function_arg_pass_by_reference (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_pass_by_reference (const CUMULATIVE_ARGS *cum,\n+\t\t\t\tenum machine_mode mode, tree type,\n+\t\t\t\tint named ATTRIBUTE_UNUSED)\n {\n   int size;\n \n@@ -7979,9 +7712,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n    mode to a 64-bit mode.  */\n \n bool\n-mips_cannot_change_mode_class (from, to, class)\n-     enum machine_mode from, to;\n-     enum reg_class class;\n+mips_cannot_change_mode_class (enum machine_mode from,\n+\t\t\t       enum machine_mode to, enum reg_class class)\n {\n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n@@ -8001,11 +7733,8 @@ mips_cannot_change_mode_class (from, to, class)\n    NO_REGS means that no secondary register is required.  */\n \n enum reg_class\n-mips_secondary_reload_class (class, mode, x, in_p)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx x;\n-     int in_p;\n+mips_secondary_reload_class (enum reg_class class,\n+\t\t\t     enum machine_mode mode, rtx x, int in_p)\n {\n   enum reg_class gr_regs = TARGET_MIPS16 ? M16_REGS : GR_REGS;\n   int regno = -1;\n@@ -8118,16 +7847,14 @@ mips_secondary_reload_class (class, mode, x, in_p)\n    since -msingle-float disallows multi-FPR values.  */\n \n int\n-mips_class_max_nregs (class, mode)\n-     enum reg_class class ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+mips_class_max_nregs (enum reg_class class ATTRIBUTE_UNUSED,\n+\t\t      enum machine_mode mode)\n {\n   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n bool\n-mips_valid_pointer_mode (mode)\n-     enum machine_mode mode;\n+mips_valid_pointer_mode (enum machine_mode mode)\n {\n   return (mode == SImode || (TARGET_64BIT && mode == DImode));\n }\n@@ -8138,7 +7865,7 @@ mips_valid_pointer_mode (mode)\n    hold the $gp value.  */\n \n rtx\n-mips16_gp_pseudo_reg ()\n+mips16_gp_pseudo_reg (void)\n {\n   if (cfun->machine->mips16_gp_pseudo_rtx == NULL_RTX)\n     {\n@@ -8180,10 +7907,7 @@ mips16_gp_pseudo_reg ()\n    we are copying from the floating point registers.  */\n \n static void\n-mips16_fp_args (file, fp_code, from_fp_p)\n-     FILE *file;\n-     int fp_code;\n-     int from_fp_p;\n+mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n {\n   const char *s;\n   int gparg, fparg;\n@@ -8243,8 +7967,7 @@ mips16_fp_args (file, fp_code, from_fp_p)\n    then jumps to the 16 bit code.  */\n \n static void\n-build_mips16_function_stub (file)\n-     FILE *file;\n+build_mips16_function_stub (FILE *file)\n {\n   const char *fnname;\n   char *secname, *stubname;\n@@ -8351,11 +8074,7 @@ static struct mips16_stub *mips16_stubs;\n    value if it builds the call instruction itself.  */\n \n int\n-build_mips16_call_stub (retval, fn, arg_size, fp_code)\n-     rtx retval;\n-     rtx fn;\n-     rtx arg_size;\n-     int fp_code;\n+build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n {\n   int fpret;\n   const char *fnname;\n@@ -8659,7 +8378,7 @@ build_mips16_call_stub (retval, fn, arg_size, fp_code)\n    generated is correct, so we do not need to catch all cases.  */\n \n static void\n-mips16_optimize_gp ()\n+mips16_optimize_gp (void)\n {\n   rtx gpcopy, slot, insn;\n \n@@ -8876,10 +8595,7 @@ struct constant\n /* Add a constant to the list in *PCONSTANTS.  */\n \n static rtx\n-add_constant (pconstants, val, mode)\n-     struct constant **pconstants;\n-     rtx val;\n-     enum machine_mode mode;\n+add_constant (struct constant **pconstants, rtx val, enum machine_mode mode)\n {\n   struct constant *c;\n \n@@ -8899,9 +8615,7 @@ add_constant (pconstants, val, mode)\n /* Dump out the constants in CONSTANTS after INSN.  */\n \n static void\n-dump_constants (constants, insn)\n-     struct constant *constants;\n-     rtx insn;\n+dump_constants (struct constant *constants, rtx insn)\n {\n   struct constant *c;\n   int align;\n@@ -8974,8 +8688,7 @@ dump_constants (constants, insn)\n /* Find the symbol in an address expression.  */\n \n static rtx\n-mips_find_symbol (addr)\n-     rtx addr;\n+mips_find_symbol (rtx addr)\n {\n   if (GET_CODE (addr) == MEM)\n     addr = XEXP (addr, 0);\n@@ -9001,7 +8714,7 @@ mips_find_symbol (addr)\n    PC relative loads that are out of range.  */\n \n static void\n-mips16_lay_out_constants ()\n+mips16_lay_out_constants (void)\n {\n   int insns_len, max_internal_pool_size, pool_size, addr, first_constant_ref;\n   rtx first, insn;\n@@ -9210,9 +8923,8 @@ mips16_lay_out_constants ()\n    LO_REG is an rtx for the LO register, used in dependence checking.  */\n \n static void\n-mips_avoid_hazard (after, insn, hilo_delay, delayed_reg, lo_reg)\n-     rtx after, insn, *delayed_reg, lo_reg;\n-     int *hilo_delay;\n+mips_avoid_hazard (rtx after, rtx insn, int *hilo_delay,\n+\t\t   rtx *delayed_reg, rtx lo_reg)\n {\n   rtx pattern, set;\n   int nops, ninsns;\n@@ -9278,7 +8990,7 @@ mips_avoid_hazard (after, insn, hilo_delay, delayed_reg, lo_reg)\n    .set nomacro.  */\n \n static void\n-mips_avoid_hazards ()\n+mips_avoid_hazards (void)\n {\n   rtx insn, last_insn, lo_reg, delayed_reg;\n   int hilo_delay, i;\n@@ -9314,7 +9026,7 @@ mips_avoid_hazards ()\n /* Implement TARGET_MACHINE_DEPENDENT_REORG.  */\n \n static void\n-mips_reorg ()\n+mips_reorg (void)\n {\n   if (TARGET_MIPS16)\n     {\n@@ -9363,9 +9075,8 @@ mips_reorg ()\n    we need to use.  This gets pretty messy, but it is feasible.  */\n \n int\n-mips_register_move_cost (mode, to, from)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     enum reg_class to, from;\n+mips_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t enum reg_class to, enum reg_class from)\n {\n   if (from == M16_REGS && GR_REG_CLASS_P (to))\n     return 2;\n@@ -9433,9 +9144,7 @@ mips_register_move_cost (mode, to, from)\n    attributes in the machine-description file.  */\n \n int\n-mips_adjust_insn_length (insn, length)\n-     rtx insn;\n-     int length;\n+mips_adjust_insn_length (rtx insn, int length)\n {\n   /* A unconditional jump has an unfilled delay slot if it is not part\n      of a sequence.  A conditional jump normally has a delay slot, but\n@@ -9473,7 +9182,7 @@ mips_adjust_insn_length (insn, length)\n    of a label into $1.  */\n \n const char *\n-mips_output_load_label ()\n+mips_output_load_label (void)\n {\n   if (TARGET_EXPLICIT_RELOCS)\n     switch (mips_abi)\n@@ -9514,18 +9223,8 @@ mips_output_load_label ()\n    That tells us whether to generate a simple conditional branch, or a\n    reversed conditional branch around a `jr' instruction.  */\n const char *\n-mips_output_conditional_branch (insn,\n-\t\t\t\toperands,\n-\t\t\t\ttwo_operands_p,\n-\t\t\t\tfloat_p,\n-\t\t\t\tinverted_p,\n-\t\t\t\tlength)\n-     rtx insn;\n-     rtx *operands;\n-     int two_operands_p;\n-     int float_p;\n-     int inverted_p;\n-     int length;\n+mips_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n+\t\t\t\tint float_p, int inverted_p, int length)\n {\n   static char buffer[200];\n   /* The kind of comparison we are doing.  */\n@@ -9727,9 +9426,7 @@ mips_output_conditional_branch (insn,\n    operand 2 is zero.  Otherwise just return DIVISION itself.  */\n \n const char *\n-mips_output_division (division, operands)\n-     const char *division;\n-     rtx *operands;\n+mips_output_division (const char *division, rtx *operands)\n {\n   if (TARGET_CHECK_ZERO_DIV)\n     {\n@@ -9749,8 +9446,7 @@ mips_output_division (division, operands)\n    Note: this function is shared between GCC and GAS.  */\n \n static bool\n-mips_strict_matching_cpu_name_p (canonical, given)\n-     const char *canonical, *given;\n+mips_strict_matching_cpu_name_p (const char *canonical, const char *given)\n {\n   while (*given != 0 && TOLOWER (*given) == TOLOWER (*canonical))\n     given++, canonical++;\n@@ -9766,8 +9462,7 @@ mips_strict_matching_cpu_name_p (canonical, given)\n    Note: this function is shared between GCC and GAS.  */\n \n static bool\n-mips_matching_cpu_name_p (canonical, given)\n-     const char *canonical, *given;\n+mips_matching_cpu_name_p (const char *canonical, const char *given)\n {\n   /* First see if the name matches exactly, or with a final \"000\"\n      turned into \"k\".  */\n@@ -9802,8 +9497,7 @@ mips_matching_cpu_name_p (canonical, given)\n    A similar function exists in GAS.  */\n \n static const struct mips_cpu_info *\n-mips_parse_cpu (option, cpu_string)\n-     const char *option, *cpu_string;\n+mips_parse_cpu (const char *option, const char *cpu_string)\n {\n   const struct mips_cpu_info *p;\n   const char *s;\n@@ -9844,8 +9538,7 @@ mips_parse_cpu (option, cpu_string)\n    if the ISA isn't valid.  */\n \n static const struct mips_cpu_info *\n-mips_cpu_info_from_isa (isa)\n-     int isa;\n+mips_cpu_info_from_isa (int isa)\n {\n   const struct mips_cpu_info *p;\n \n@@ -9862,11 +9555,8 @@ mips_cpu_info_from_isa (isa)\n \n    On the MIPS, ignore the cost of anti- and output-dependencies.  */\n static int\n-mips_adjust_cost (insn, link, dep, cost)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx link;\n-     rtx dep ATTRIBUTE_UNUSED;\n-     int cost;\n+mips_adjust_cost (rtx insn ATTRIBUTE_UNUSED, rtx link,\n+\t\t  rtx dep ATTRIBUTE_UNUSED, int cost)\n {\n   if (REG_NOTE_KIND (link) != 0)\n     return 0;\t/* Anti or output dependence.  */\n@@ -9877,9 +9567,7 @@ mips_adjust_cost (insn, link, dep, cost)\n    by UNITS_PER_FPREG.  All other registers are word sized.  */\n \n unsigned int\n-mips_hard_regno_nregs (regno, mode)\n-    int regno;\n-    enum machine_mode mode;\n+mips_hard_regno_nregs (int regno, enum machine_mode mode)\n {\n   if (! FP_REG_P (regno))\n     return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n@@ -9894,8 +9582,7 @@ mips_hard_regno_nregs (regno, mode)\n    course.  */\n \n int\n-mips_return_in_memory (type)\n-     tree type;\n+mips_return_in_memory (tree type)\n {\n   if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n     return (TYPE_MODE (type) == BLKmode);\n@@ -9905,7 +9592,7 @@ mips_return_in_memory (type)\n }\n \n static int\n-mips_issue_rate ()\n+mips_issue_rate (void)\n {\n   switch (mips_tune)\n     {\n@@ -9927,7 +9614,7 @@ mips_issue_rate ()\n    processors that have a DFA pipeline description.  */\n \n static int\n-mips_use_dfa_pipeline_interface ()\n+mips_use_dfa_pipeline_interface (void)\n {\n   switch (mips_tune)\n     {\n@@ -9945,8 +9632,7 @@ mips_use_dfa_pipeline_interface ()\n \n \n const char *\n-mips_emit_prefetch (operands)\n-     rtx operands[];\n+mips_emit_prefetch (rtx *operands)\n {\n   /* For the mips32/64 architectures the hint fields are arranged\n      by operation (load/store) and locality (normal/streamed/retained).\n@@ -9980,10 +9666,8 @@ mips_emit_prefetch (operands)\n /* Output assembly to switch to section NAME with attribute FLAGS.  */\n \n static void\n-iris6_asm_named_section_1 (name, flags, align)\n-     const char *name;\n-     unsigned int flags;\n-     unsigned int align;\n+iris6_asm_named_section_1 (const char *name, unsigned int flags,\n+\t\t\t   unsigned int align)\n {\n   unsigned int sh_type, sh_flags, sh_entsize;\n \n@@ -10015,9 +9699,7 @@ iris6_asm_named_section_1 (name, flags, align)\n }\n \n static void\n-iris6_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+iris6_asm_named_section (const char *name, unsigned int flags)\n {\n   iris6_asm_named_section_1 (name, flags, 0);\n }\n@@ -10036,9 +9718,7 @@ static htab_t iris_section_align_htab;\n static FILE *iris_orig_asm_out_file;\n \n static int\n-iris_section_align_entry_eq (p1, p2)\n-     const void *p1;\n-     const void *p2;\n+iris_section_align_entry_eq (const void *p1, const void *p2)\n {\n   const struct iris_section_align_entry *old = p1;\n   const char *new = p2;\n@@ -10047,17 +9727,14 @@ iris_section_align_entry_eq (p1, p2)\n }\n \n static hashval_t\n-iris_section_align_entry_hash (p)\n-     const void *p;\n+iris_section_align_entry_hash (const void *p)\n {\n   const struct iris_section_align_entry *old = p;\n   return htab_hash_string (old->name);\n }\n \n void\n-iris6_asm_output_align (file, log)\n-     FILE *file;\n-     unsigned int log;\n+iris6_asm_output_align (FILE *file, unsigned int log)\n {\n   const char *section = current_section_name ();\n   struct iris_section_align_entry **slot, *entry;\n@@ -10090,7 +9767,7 @@ iris6_asm_output_align (file, log)\n    beginning of the file with the proper alignment attached.  */\n \n static void\n-iris6_file_start ()\n+iris6_file_start (void)\n {\n   mips_file_start ();\n \n@@ -10102,9 +9779,7 @@ iris6_file_start ()\n }\n \n static int\n-iris6_section_align_1 (slot, data)\n-     void **slot;\n-     void *data ATTRIBUTE_UNUSED;\n+iris6_section_align_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   const struct iris_section_align_entry *entry\n     = *(const struct iris_section_align_entry **) slot;\n@@ -10114,8 +9789,7 @@ iris6_section_align_1 (slot, data)\n }\n \n static void\n-copy_file_data (to, from)\n-     FILE *to, *from;\n+copy_file_data (FILE *to, FILE *from)\n {\n   char buffer[8192];\n   size_t len;\n@@ -10135,7 +9809,7 @@ copy_file_data (to, from)\n }\n \n static void\n-iris6_file_end ()\n+iris6_file_end (void)\n {\n   /* Emit section directives with the proper alignment at the top of the\n      real output file.  */\n@@ -10155,10 +9829,7 @@ iris6_file_end ()\n    default code.  */\n \n static unsigned int\n-iris6_section_type_flags (decl, section, relocs_p)\n-     tree decl;\n-     const char *section;\n-     int relocs_p;\n+iris6_section_type_flags (tree decl, const char *section, int relocs_p)\n {\n   unsigned int flags;\n "}]}