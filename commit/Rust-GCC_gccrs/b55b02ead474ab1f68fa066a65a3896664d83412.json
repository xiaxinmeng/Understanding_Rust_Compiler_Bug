{"sha": "b55b02ead474ab1f68fa066a65a3896664d83412", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU1YjAyZWFkNDc0YWIxZjY4ZmEwNjZhNjVhMzg5NjY2NGQ4MzQxMg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2015-06-27T10:40:21Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2015-06-27T10:40:21Z"}, "message": "call.c: Use VECTOR_TYPE_P.\n\n\t* call.c: Use VECTOR_TYPE_P.\n\t* constexpr.c: Likewise.\n\t* cvt.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* init.c: Likewise.\n\t* semantics.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\nFrom-SVN: r225099", "tree": {"sha": "e2fdea317833c9400e7b7b897d2c41b2b4785409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2fdea317833c9400e7b7b897d2c41b2b4785409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b55b02ead474ab1f68fa066a65a3896664d83412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55b02ead474ab1f68fa066a65a3896664d83412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55b02ead474ab1f68fa066a65a3896664d83412", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55b02ead474ab1f68fa066a65a3896664d83412/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56a6f1d33f7259fde0efc9c37a1308c306590e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56a6f1d33f7259fde0efc9c37a1308c306590e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56a6f1d33f7259fde0efc9c37a1308c306590e8b"}], "stats": {"total": 73, "additions": 42, "deletions": 31}, "files": [{"sha": "4a3b2d8a071495bdc79297e3784ce117e3753cec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -1,3 +1,16 @@\n+2015-06-27  Marek Polacek  <polacek@redhat.com>\n+\n+\t* call.c: Use VECTOR_TYPE_P.\n+\t* constexpr.c: Likewise.\n+\t* cvt.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* init.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2015-06-27  Marek Polacek  <polacek@redhat.com>\n \n \t* call.c (set_up_extended_ref_temp): Use VAR_P."}, {"sha": "b8469194f7013b6ab62ddbc3677044e4c87dc68d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -4559,8 +4559,8 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n       arg2_type = TREE_TYPE (arg2);\n       arg3_type = TREE_TYPE (arg3);\n \n-      if (TREE_CODE (arg2_type) != VECTOR_TYPE\n-\t  && TREE_CODE (arg3_type) != VECTOR_TYPE)\n+      if (!VECTOR_TYPE_P (arg2_type)\n+\t  && !VECTOR_TYPE_P (arg3_type))\n \t{\n \t  /* Rely on the error messages of the scalar version.  */\n \t  tree scal = build_conditional_expr_1 (loc, integer_one_node,\n@@ -4612,8 +4612,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t  arg3_type = vtype;\n \t}\n \n-      if ((TREE_CODE (arg2_type) == VECTOR_TYPE)\n-\t  != (TREE_CODE (arg3_type) == VECTOR_TYPE))\n+      if (VECTOR_TYPE_P (arg2_type) != VECTOR_TYPE_P (arg3_type))\n \t{\n \t  enum stv_conv convert_flag =\n \t    scalar_to_vector (loc, VEC_COND_EXPR, arg2, arg3,"}, {"sha": "a122ded0a265f7321ba87fbd9f39dbccfbfd7ea3", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -61,7 +61,7 @@ bool\n literal_type_p (tree t)\n {\n   if (SCALAR_TYPE_P (t)\n-      || TREE_CODE (t) == VECTOR_TYPE\n+      || VECTOR_TYPE_P (t)\n       || TREE_CODE (t) == REFERENCE_TYPE\n       || (VOID_TYPE_P (t) && cxx_dialect >= cxx14))\n     return true;\n@@ -2101,7 +2101,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n   /* We're done building this CONSTRUCTOR, so now we can interpret an\n      element without an explicit initializer as value-initialized.  */\n   CONSTRUCTOR_NO_IMPLICIT_ZERO (t) = false;\n-  if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+  if (VECTOR_TYPE_P (TREE_TYPE (t)))\n     t = fold (t);\n   return t;\n }\n@@ -2289,7 +2289,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t\t   (type, TREE_TYPE (optype))))\n \treturn fold_build1_loc (loc, REALPART_EXPR, type, op);\n       /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n-      else if (TREE_CODE (optype) == VECTOR_TYPE\n+      else if (VECTOR_TYPE_P (optype)\n \t       && (same_type_ignoring_top_level_qualifiers_p\n \t\t   (type, TREE_TYPE (optype))))\n \t{\n@@ -2335,7 +2335,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t  op00type = TREE_TYPE (op00);\n \n \t  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n-\t  if (TREE_CODE (op00type) == VECTOR_TYPE\n+\t  if (VECTOR_TYPE_P (op00type)\n \t      && (same_type_ignoring_top_level_qualifiers_p\n \t\t  (type, TREE_TYPE (op00type))))\n \t    {"}, {"sha": "a2776781d989e6380124147d667dd734363f8764", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -708,7 +708,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t conversion.  */\n       else if (TREE_CODE (type) == COMPLEX_TYPE)\n \treturn fold_if_not_in_template (convert_to_complex (type, e));\n-      else if (TREE_CODE (type) == VECTOR_TYPE)\n+      else if (VECTOR_TYPE_P (type))\n \treturn fold_if_not_in_template (convert_to_vector (type, e));\n       else if (TREE_CODE (e) == TARGET_EXPR)\n \t{"}, {"sha": "0683f26b7a042216486d0df99ea8b5383f5cf43d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -5392,7 +5392,7 @@ reshape_init_vector (tree type, reshape_iter *d, tsubst_flags_t complain)\n {\n   tree max_index = NULL_TREE;\n \n-  gcc_assert (TREE_CODE (type) == VECTOR_TYPE);\n+  gcc_assert (VECTOR_TYPE_P (type));\n \n   if (COMPOUND_LITERAL_P (d->cur->value))\n     {\n@@ -5409,7 +5409,7 @@ reshape_init_vector (tree type, reshape_iter *d, tsubst_flags_t complain)\n     }\n \n   /* For a vector, we initialize it as an array of the appropriate size.  */\n-  if (TREE_CODE (type) == VECTOR_TYPE)\n+  if (VECTOR_TYPE_P (type))\n     max_index = size_int (TYPE_VECTOR_SUBPARTS (type) - 1);\n \n   return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);\n@@ -5717,7 +5717,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n     return reshape_init_class (type, d, first_initializer_p, complain);\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     return reshape_init_array (type, d, complain);\n-  else if (TREE_CODE (type) == VECTOR_TYPE)\n+  else if (VECTOR_TYPE_P (type))\n     return reshape_init_vector (type, d, complain);\n   else\n     gcc_unreachable();\n@@ -5919,7 +5919,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t\t       \"not by %<{...}%>\",\n \t\t       decl);\n \t    }\n-\t  else if (TREE_CODE (type) == VECTOR_TYPE && TYPE_VECTOR_OPAQUE (type))\n+\t  else if (VECTOR_TYPE_P (type) && TYPE_VECTOR_OPAQUE (type))\n \t    {\n \t      error (\"opaque vector types cannot be initialized\");\n \t      init = error_mark_node;"}, {"sha": "a7a6efb25f2dc0741e3ece1cf536fc3441b7686f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -395,7 +395,7 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n \t It is a little-known fact that, if `a' is an array and `i' is\n \t an int, you can write `i[a]', which means the same thing as\n \t `a[i]'.  */\n-      if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+      if (TREE_CODE (type) == ARRAY_TYPE || VECTOR_TYPE_P (type))\n \tp1 = array_expr;\n       else\n \tp1 = build_expr_type_conversion (WANT_POINTER, array_expr, false);"}, {"sha": "871ddb5e68673c08e1502879068394b694713be7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -280,7 +280,7 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n       /* Build a constructor to contain the initializations.  */\n       init = build_constructor (type, v);\n     }\n-  else if (TREE_CODE (type) == VECTOR_TYPE)\n+  else if (VECTOR_TYPE_P (type))\n     init = build_zero_cst (type);\n   else\n     gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);"}, {"sha": "4b8ce3b35ce08eee5706f02f21d46e5101220a58", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -7357,7 +7357,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n \t  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);\n \n \t  /* For vector types, pick a non-opaque variant.  */\n-\t  if (TREE_CODE (type) == VECTOR_TYPE)\n+\t  if (VECTOR_TYPE_P (type))\n \t    type = strip_typedefs (type);\n \n \t  if (clk != clk_none && !(clk & clk_class))"}, {"sha": "f1f5e533c7afb2ecf40a442f80cce748ceeee1b6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -3239,8 +3239,7 @@ scalarish_type_p (const_tree t)\n   if (t == error_mark_node)\n     return 1;\n \n-  return (SCALAR_TYPE_P (t)\n-\t  || TREE_CODE (t) == VECTOR_TYPE);\n+  return (SCALAR_TYPE_P (t) || VECTOR_TYPE_P (t));\n }\n \n /* Returns true iff T requires non-trivial default initialization.  */"}, {"sha": "2d03d758448a83ee15a8efd6c429a9bb4f8ea85c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -293,10 +293,10 @@ cp_common_type (tree t1, tree t2)\n \n   /* FIXME: Attributes.  */\n   gcc_assert (ARITHMETIC_TYPE_P (t1)\n-\t      || TREE_CODE (t1) == VECTOR_TYPE\n+\t      || VECTOR_TYPE_P (t1)\n \t      || UNSCOPED_ENUM_P (t1));\n   gcc_assert (ARITHMETIC_TYPE_P (t2)\n-\t      || TREE_CODE (t2) == VECTOR_TYPE\n+\t      || VECTOR_TYPE_P (t2)\n \t      || UNSCOPED_ENUM_P (t2));\n \n   /* If one type is complex, form the common type of the non-complex\n@@ -441,10 +441,10 @@ tree\n type_after_usual_arithmetic_conversions (tree t1, tree t2)\n {\n   gcc_assert (ARITHMETIC_TYPE_P (t1)\n-\t      || TREE_CODE (t1) == VECTOR_TYPE\n+\t      || VECTOR_TYPE_P (t1)\n \t      || UNSCOPED_ENUM_P (t1));\n   gcc_assert (ARITHMETIC_TYPE_P (t2)\n-\t      || TREE_CODE (t2) == VECTOR_TYPE\n+\t      || VECTOR_TYPE_P (t2)\n \t      || UNSCOPED_ENUM_P (t2));\n \n   /* Perform the integral promotions.  We do not promote real types here.  */\n@@ -6979,9 +6979,9 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \t\t \"is conditionally-supported\");\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n-  else if (TREE_CODE (type) == VECTOR_TYPE)\n+  else if (VECTOR_TYPE_P (type))\n     return fold_if_not_in_template (convert_to_vector (type, expr));\n-  else if (TREE_CODE (intype) == VECTOR_TYPE\n+  else if (VECTOR_TYPE_P (intype)\n \t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     return fold_if_not_in_template (convert_to_integer (type, expr));\n   else\n@@ -8115,7 +8115,7 @@ convert_for_assignment (tree type, tree rhs,\n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n \n-  if (TREE_CODE (type) == VECTOR_TYPE && coder == VECTOR_TYPE\n+  if (VECTOR_TYPE_P (type) && coder == VECTOR_TYPE\n       && vector_types_convertible_p (type, rhstype, true))\n     {\n       rhs = mark_rvalue_use (rhs);\n@@ -8819,7 +8819,7 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n \t    constp &= TYPE_READONLY (to);\n \t}\n \n-      if (TREE_CODE (to) == VECTOR_TYPE)\n+      if (VECTOR_TYPE_P (to))\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n       if (!TYPE_PTR_P (to) && !TYPE_PTRDATAMEM_P (to))\n@@ -8900,7 +8900,7 @@ ptr_reasonably_similar (const_tree to, const_tree from)\n \t\t\tCOMPARE_BASE | COMPARE_DERIVED))\n \tcontinue;\n \n-      if (TREE_CODE (to) == VECTOR_TYPE\n+      if (VECTOR_TYPE_P (to)\n \t  && vector_types_convertible_p (to, from, false))\n \treturn true;\n \n@@ -8942,7 +8942,7 @@ comp_ptr_ttypes_const (tree to, tree from)\n \t\t\t  TYPE_OFFSET_BASETYPE (to)))\n \t  continue;\n \n-      if (TREE_CODE (to) == VECTOR_TYPE)\n+      if (VECTOR_TYPE_P (to))\n \tis_opaque_pointer = vector_targets_convertible_p (to, from);\n \n       if (!TYPE_PTR_P (to))"}, {"sha": "ea0ae64b4e83766591d021800f45bc5d76b91fee", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b55b02ead474ab1f68fa066a65a3896664d83412/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=b55b02ead474ab1f68fa066a65a3896664d83412", "patch": "@@ -1083,7 +1083,7 @@ digest_init_r (tree type, tree init, bool nested, int flags,\n   /* Come here only for aggregates: records, arrays, unions, complex numbers\n      and vectors.  */\n   gcc_assert (TREE_CODE (type) == ARRAY_TYPE\n-\t      || TREE_CODE (type) == VECTOR_TYPE\n+\t      || VECTOR_TYPE_P (type)\n \t      || TREE_CODE (type) == RECORD_TYPE\n \t      || TREE_CODE (type) == UNION_TYPE\n \t      || TREE_CODE (type) == COMPLEX_TYPE);\n@@ -1236,7 +1236,7 @@ process_init_constructor_array (tree type, tree init,\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init);\n \n   gcc_assert (TREE_CODE (type) == ARRAY_TYPE\n-\t      || TREE_CODE (type) == VECTOR_TYPE);\n+\t      || VECTOR_TYPE_P (type));\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -1572,7 +1572,7 @@ process_init_constructor (tree type, tree init, tsubst_flags_t complain)\n \n   gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n \n-  if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+  if (TREE_CODE (type) == ARRAY_TYPE || VECTOR_TYPE_P (type))\n     flags = process_init_constructor_array (type, init, complain);\n   else if (TREE_CODE (type) == RECORD_TYPE)\n     flags = process_init_constructor_record (type, init, complain);"}]}