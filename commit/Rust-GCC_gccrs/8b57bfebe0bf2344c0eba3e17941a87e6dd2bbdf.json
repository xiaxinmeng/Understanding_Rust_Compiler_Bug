{"sha": "8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI1N2JmZWJlMGJmMjM0NGMwZWJhM2UxNzk0MWE4N2U2ZGQyYmJkZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-09-27T16:15:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-09-27T16:15:46Z"}, "message": "common.opt: Add -foptimize-strlen option.\n\n\t* common.opt: Add -foptimize-strlen option.\n\t* Makefile.in (OBJS): Add tree-ssa-strlen.o.\n\t(tree-sssa-strlen.o): Add dependencies.\n\t* opts.c (default_options_table): Enable -foptimize-strlen\n\tby default at -O2 if not -Os.\n\t* passes.c (init_optimization_passes): Add pass_strlen\n\tafter pass_object_sizes.\n\t* timevar.def (TV_TREE_STRLEN): New timevar.\n\t* params.def (PARAM_MAX_TRACKED_STRLENS): New parameter.\n\t* tree-pass.h (pass_strlen): Declare.\n\t* tree-ssa-strlen.c: New file.\n\t* c-decl.c (merge_decls): If compatible stpcpy prototype\n\tis seen, set implicit_built_in_decls[BUILT_IN_STPCPY].\ncp/\n\t* decl.c (duplicate_decls): If compatible stpcpy prototype\n\tis seen, set implicit_built_in_decls[BUILT_IN_STPCPY].\ntestsuite/\n\t* gcc.dg/strlenopt-1.c: New test.\n\t* gcc.dg/strlenopt-1f.c: New test.\n\t* gcc.dg/strlenopt-2.c: New test.\n\t* gcc.dg/strlenopt-2f.c: New test.\n\t* gcc.dg/strlenopt-3.c: New test.\n\t* gcc.dg/strlenopt-4.c: New test.\n\t* gcc.dg/strlenopt-4g.c: New test.\n\t* gcc.dg/strlenopt-4gf.c: New test.\n\t* gcc.dg/strlenopt-5.c: New test.\n\t* gcc.dg/strlenopt-6.c: New test.\n\t* gcc.dg/strlenopt-7.c: New test.\n\t* gcc.dg/strlenopt-8.c: New test.\n\t* gcc.dg/strlenopt-9.c: New test.\n\t* gcc.dg/strlenopt-10.c: New test.\n\t* gcc.dg/strlenopt-11.c: New test.\n\t* gcc.dg/strlenopt-12.c: New test.\n\t* gcc.dg/strlenopt-12g.c: New test.\n\t* gcc.dg/strlenopt-13.c: New test.\n\t* gcc.dg/strlenopt-14g.c: New test.\n\t* gcc.dg/strlenopt-14gf.c: New test.\n\t* gcc.dg/strlenopt-15.c: New test.\n\t* gcc.dg/strlenopt-16g.c: New test.\n\t* gcc.dg/strlenopt-17g.c: New test.\n\t* gcc.dg/strlenopt-18g.c: New test.\n\t* gcc.dg/strlenopt.h: New file.\n\nFrom-SVN: r179277", "tree": {"sha": "c8200cc6b87f6842f33b4c4ff883b03d7a81bc54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8200cc6b87f6842f33b4c4ff883b03d7a81bc54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "baaa40aeca4a95a6e250e14e8f1e8b2e1239c864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baaa40aeca4a95a6e250e14e8f1e8b2e1239c864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baaa40aeca4a95a6e250e14e8f1e8b2e1239c864"}], "stats": {"total": 3675, "additions": 3671, "deletions": 4}, "files": [{"sha": "8cbbe02cff0d75beedfa30e4d5214d842468d37b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1,3 +1,19 @@\n+2011-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* common.opt: Add -foptimize-strlen option.\n+\t* Makefile.in (OBJS): Add tree-ssa-strlen.o.\n+\t(tree-sssa-strlen.o): Add dependencies.\n+\t* opts.c (default_options_table): Enable -foptimize-strlen\n+\tby default at -O2 if not -Os.\n+\t* passes.c (init_optimization_passes): Add pass_strlen\n+\tafter pass_object_sizes.\n+\t* timevar.def (TV_TREE_STRLEN): New timevar.\n+\t* params.def (PARAM_MAX_TRACKED_STRLENS): New parameter.\n+\t* tree-pass.h (pass_strlen): Declare.\n+\t* tree-ssa-strlen.c: New file.\n+\t* c-decl.c (merge_decls): If compatible stpcpy prototype\n+\tis seen, set implicit_built_in_decls[BUILT_IN_STPCPY].\n+\n 2011-09-27  Tom de Vries  <tom@codesourcery.com>\n \n \tPR middle-end/43864"}, {"sha": "2f320a9029ee0ea950b04381b4c53579a2205e7d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1475,6 +1475,7 @@ OBJS = \\\n \ttree-ssa-reassoc.o \\\n \ttree-ssa-sccvn.o \\\n \ttree-ssa-sink.o \\\n+\ttree-ssa-strlen.o \\\n \ttree-ssa-structalias.o \\\n \ttree-ssa-tail-merge.o \\\n \ttree-ssa-ter.o \\\n@@ -3168,6 +3169,9 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) langhooks.h  $(PARAMS_H) \\\n    tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(DIAGNOSTIC_CORE_H) \\\n    $(DBGCNT_H) tree-pretty-print.h gimple-pretty-print.h gimple-fold.h\n+tree-ssa-strlen.o : tree-ssa-strlen.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TREE_FLOW_H) $(TREE_PASS_H) domwalk.h alloc-pool.h tree-ssa-propagate.h \\\n+   gimple-pretty-print.h $(PARAMS_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \\\n    $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) \\\n    $(IPA_PROP_H) $(DIAGNOSTIC_H) statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) \\"}, {"sha": "cb58d324dca35d258e5a8bc3c5b3794b804a3fd9", "filename": "gcc/c-decl.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -2369,7 +2369,21 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);\n \t  C_DECL_DECLARED_BUILTIN (newdecl) = 1;\n \t  if (new_is_prototype)\n-\t    C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n+\t    {\n+\t      C_DECL_BUILTIN_PROTOTYPE (newdecl) = 0;\n+\t      if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)\n+\t\tswitch (DECL_FUNCTION_CODE (newdecl))\n+\t\t  {\n+\t\t  /* If a compatible prototype of these builtin functions\n+\t\t     is seen, assume the runtime implements it with the\n+\t\t     expected semantics.  */\n+\t\t  case BUILT_IN_STPCPY:\n+\t\t    implicit_built_in_decls[DECL_FUNCTION_CODE (newdecl)]\n+\t\t      = built_in_decls[DECL_FUNCTION_CODE (newdecl)];\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t    }\n \t  else\n \t    C_DECL_BUILTIN_PROTOTYPE (newdecl)\n \t      = C_DECL_BUILTIN_PROTOTYPE (olddecl);"}, {"sha": "c7c523c960bded8ce09751ddfea8368a6314009f", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1961,6 +1961,10 @@ ftree-fre\n Common Report Var(flag_tree_fre) Optimization\n Enable Full Redundancy Elimination (FRE) on trees\n \n+foptimize-strlen\n+Common Report Var(flag_optimize_strlen) Optimization\n+Enable string length optimizations on trees\n+\n ftree-loop-distribution\n Common Report Var(flag_tree_loop_distribution) Optimization\n Enable loop distribution on trees"}, {"sha": "24068c8168b86575c562242c6bac9e92b82d483c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1,3 +1,8 @@\n+2011-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* decl.c (duplicate_decls): If compatible stpcpy prototype\n+\tis seen, set implicit_built_in_decls[BUILT_IN_STPCPY].\n+\n 2011-09-26  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/45012"}, {"sha": "30f92dae24396c1405f674b52f0d0eee7d935733", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -2135,6 +2135,18 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t      /* If we're keeping the built-in definition, keep the rtl,\n \t\t regardless of declaration matches.  */\n \t      COPY_DECL_RTL (olddecl, newdecl);\n+\t      if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)\n+\t\tswitch (DECL_FUNCTION_CODE (newdecl))\n+\t\t  {\n+\t\t    /* If a compatible prototype of these builtin functions\n+\t\t       is seen, assume the runtime implements it with the\n+\t\t       expected semantics.  */\n+\t\t  case BUILT_IN_STPCPY:\n+\t\t    implicit_built_in_decls[DECL_FUNCTION_CODE (newdecl)]\n+\t\t      = built_in_decls[DECL_FUNCTION_CODE (newdecl)];\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n \t    }\n \n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);"}, {"sha": "4d8ca6e42f21824374d64c967af82b48d3fe90f3", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1,7 +1,7 @@\n /* Top level of GCC compilers (cc1, cc1plus, etc.)\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1321,6 +1321,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_forwprop);\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_object_sizes);\n+      NEXT_PASS (pass_strlen);\n       NEXT_PASS (pass_ccp);\n       NEXT_PASS (pass_copy_prop);\n       NEXT_PASS (pass_cse_sincos);"}, {"sha": "68c5d28a3765a08024da125f9740bd0cd71b0eb9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1,3 +1,31 @@\n+2011-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/strlenopt-1.c: New test.\n+\t* gcc.dg/strlenopt-1f.c: New test.\n+\t* gcc.dg/strlenopt-2.c: New test.\n+\t* gcc.dg/strlenopt-2f.c: New test.\n+\t* gcc.dg/strlenopt-3.c: New test.\n+\t* gcc.dg/strlenopt-4.c: New test.\n+\t* gcc.dg/strlenopt-4g.c: New test.\n+\t* gcc.dg/strlenopt-4gf.c: New test.\n+\t* gcc.dg/strlenopt-5.c: New test.\n+\t* gcc.dg/strlenopt-6.c: New test.\n+\t* gcc.dg/strlenopt-7.c: New test.\n+\t* gcc.dg/strlenopt-8.c: New test.\n+\t* gcc.dg/strlenopt-9.c: New test.\n+\t* gcc.dg/strlenopt-10.c: New test.\n+\t* gcc.dg/strlenopt-11.c: New test.\n+\t* gcc.dg/strlenopt-12.c: New test.\n+\t* gcc.dg/strlenopt-12g.c: New test.\n+\t* gcc.dg/strlenopt-13.c: New test.\n+\t* gcc.dg/strlenopt-14g.c: New test.\n+\t* gcc.dg/strlenopt-14gf.c: New test.\n+\t* gcc.dg/strlenopt-15.c: New test.\n+\t* gcc.dg/strlenopt-16g.c: New test.\n+\t* gcc.dg/strlenopt-17g.c: New test.\n+\t* gcc.dg/strlenopt-18g.c: New test.\n+\t* gcc.dg/strlenopt.h: New file.\n+\n 2011-09-27  Tom de Vries  <tom@codesourcery.com>\n \n \tPR middle-end/43864"}, {"sha": "5bc4f0cd176fe15973083e53522e8eab33d98c51", "filename": "gcc/testsuite/gcc.dg/strlenopt-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+foo (char *p, char *r)\n+{\n+  char *q = malloc (strlen (p) + strlen (r) + 64);\n+  if (q == NULL) return NULL;\n+  /* This strcpy can be optimized into memcpy, using the remembered\n+     strlen (p).  */\n+  strcpy (q, p);\n+  /* These two strcat can be optimized into memcpy.  The first one\n+     could be even optimized into a *ptr = '/'; store as the '\\0'\n+     is immediately overwritten.  */\n+  strcat (q, \"/\");\n+  strcat (q, \"abcde\");\n+  /* Due to inefficient PTA (PR50262) the above calls invalidate\n+     string length of r, so it is optimized just into strcpy instead\n+     of memcpy.  */\n+  strcat (q, r);\n+  return q;\n+}\n+\n+int\n+main ()\n+{\n+  char *volatile p = \"string1\";\n+  char *volatile r = \"string2\";\n+  char *q = foo (p, r);\n+  if (q != NULL)\n+    {\n+      if (strcmp (q, \"string1/abcdestring2\"))\n+\tabort ();\n+      free (q);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "a18c06ae0694b641d195a1044694c8a3c5fa9a1e", "filename": "gcc/testsuite/gcc.dg/strlenopt-10.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) size_t\n+fn1 (char *p)\n+{\n+  char *q;\n+  /* This can be optimized into memcpy and the size can be decreased to one,\n+     as it is immediately overwritten.  */\n+  strcpy (p, \"z\");\n+  q = strchr (p, '\\0');\n+  *q = 32;\n+  /* This strlen can't be optimized away, string length is unknown here.  */\n+  return strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+fn2 (char *p, const char *z, size_t *lp)\n+{\n+  char *q, *r;\n+  char buf[64];\n+  size_t l[10];\n+  /* The first strlen stays, all the strcpy calls can be optimized\n+     into memcpy and all other strlen calls and all strchr calls\n+     optimized away.  */\n+  l[0] = strlen (z);\n+  strcpy (buf, z);\n+  strcpy (p, \"abcde\");\n+  q = strchr (p, '\\0');\n+  strcpy (q, \"efghi\");\n+  r = strchr (q, '\\0');\n+  strcpy (r, \"jkl\");\n+  l[1] = strlen (p);\n+  l[2] = strlen (q);\n+  l[3] = strlen (r);\n+  strcpy (r, buf);\n+  l[4] = strlen (p);\n+  l[5] = strlen (q);\n+  l[6] = strlen (r);\n+  strcpy (r, \"mnopqr\");\n+  l[7] = strlen (p);\n+  l[8] = strlen (q);\n+  l[9] = strlen (r);\n+  memcpy (lp, l, sizeof l);\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  size_t l[10];\n+  const char *volatile z = \"ABCDEFG\";\n+  memset (buf, '\\0', sizeof buf);\n+  if (fn1 (buf) != 2 || buf[0] != 'z' || buf[1] != 32 || buf[2] != '\\0')\n+    abort ();\n+  fn2 (buf, z, l);\n+  if (memcmp (buf, \"abcdeefghimnopqr\", 17) != 0)\n+    abort ();\n+  if (l[0] != 7)\n+    abort ();\n+  if (l[1] != 13 || l[2] != 8 || l[3] != 3)\n+    abort ();\n+  if (l[4] != 17 || l[5] != 12 || l[6] != 7)\n+    abort ();\n+  if (l[7] != 16 || l[8] != 11 || l[9] != 6)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 8 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\*q_\\[0-9\\]* = 32;\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\\[^\\n\\r\\]*, 1\\\\)\" 1 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "03f8790d0c6cf611791fc2ca5adf02895714ae38", "filename": "gcc/testsuite/gcc.dg/strlenopt-11.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) void\n+fn1 (char *p, const char *z, size_t *lp)\n+{\n+  char *q, *r, *s;\n+  char buf[64];\n+  size_t l[11];\n+  /* The first strlen stays, all the strcpy calls can be optimized\n+     into memcpy and most other strlen calls and all strchr calls\n+     optimized away.  l[6] = strlen (r); and l[9] = strlen (r); need\n+     to stay, because we need to invalidate the knowledge about\n+     r strlen after strcpy (q, \"jklmnopqrst\").  */\n+  l[0] = strlen (z);\n+  strcpy (buf, z);\n+  strcpy (p, \"abcde\");\n+  q = strchr (p, '\\0');\n+  strcpy (q, \"efghi\");\n+  r = strchr (q, '\\0');\n+  strcpy (r, buf);\n+  l[1] = strlen (p);\n+  l[2] = strlen (q);\n+  l[3] = strlen (r);\n+  strcpy (q, \"jklmnopqrst\");\n+  l[4] = strlen (p);\n+  l[5] = strlen (q);\n+  l[6] = strlen (r);\n+  s = strchr (q, '\\0');\n+  strcpy (s, buf);\n+  l[7] = strlen (p);\n+  l[8] = strlen (q);\n+  l[9] = strlen (r);\n+  l[10] = strlen (s);\n+  memcpy (lp, l, sizeof l);\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  size_t l[11];\n+  const char *volatile z = \"ABCDEFG\";\n+  memset (buf, '\\0', sizeof buf);\n+  fn1 (buf, z, l);\n+  if (memcmp (buf, \"abcdejklmnopqrstABCDEFG\", 24) != 0)\n+    abort ();\n+  if (l[0] != 7)\n+    abort ();\n+  if (l[1] != 17 || l[2] != 12 || l[3] != 7)\n+    abort ();\n+  if (l[4] != 16 || l[5] != 11 || l[6] != 6)\n+    abort ();\n+  if (l[7] != 23 || l[8] != 18 || l[9] != 13 || l[10] != 7)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "1005fc6709e53265f4804384ebfbea7ac6124662", "filename": "gcc/testsuite/gcc.dg/strlenopt-12.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-12.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+fn1 (char *p, size_t *l)\n+{\n+  char *q = strcat (p, \"abcde\");\n+  *l = strlen (p);\n+  return q;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn2 (char *p, const char *q, size_t *l1, size_t *l2)\n+{\n+  size_t l = strlen (q);\n+  char *r = strcat (p, q);\n+  *l1 = l;\n+  *l2 = strlen (p);\n+  return r;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn3 (char *p, const char *q, size_t *l)\n+{\n+  char *r = strcpy (p, q);\n+  *l = strlen (p);\n+  return r;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn4 (char *p, const char *q, size_t *l)\n+{\n+  char *r = strcat (p, q);\n+  *l = strlen (p);\n+  return r;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn5 (char *p, const char *q, size_t *l1, size_t *l2, size_t *l3)\n+{\n+  size_t l = strlen (q);\n+  size_t ll = strlen (p);\n+  char *r = strcat (p, q);\n+  *l1 = l;\n+  *l2 = strlen (p);\n+  *l3 = ll;\n+  return r;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn6 (char *p, const char *q, size_t *l1, size_t *l2)\n+{\n+  size_t l = strlen (p);\n+  char *r = strcat (p, q);\n+  *l1 = strlen (p);\n+  *l2 = l;\n+  return r;\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  const char *volatile q = \"fgh\";\n+  size_t l, l1, l2, l3;\n+  memset (buf, '\\0', sizeof buf);\n+  memset (buf, 'a', 3);\n+  if (fn1 (buf, &l) != buf || l != 8 || memcmp (buf, \"aaaabcde\", 9) != 0)\n+    abort ();\n+  if (fn2 (buf, q, &l1, &l2) != buf || l1 != 3 || l2 != 11\n+      || memcmp (buf, \"aaaabcdefgh\", 12) != 0)\n+    abort ();\n+  if (fn3 (buf, q, &l) != buf || l != 3\n+      || memcmp (buf, \"fgh\\0bcdefgh\", 12) != 0)\n+    abort ();\n+  if (fn4 (buf, q, &l) != buf || l != 6\n+      || memcmp (buf, \"fghfgh\\0efgh\", 12) != 0)\n+    abort ();\n+  l1 = 0;\n+  l2 = 0;\n+  if (fn5 (buf, q, &l1, &l2, &l3) != buf || l1 != 3 || l2 != 9 || l3 != 6\n+      || memcmp (buf, \"fghfghfgh\\0h\", 12) != 0)\n+    abort ();\n+  if (fn6 (buf, q, &l1, &l2) != buf || l1 != 12 || l2 != 9\n+      || memcmp (buf, \"fghfghfghfgh\", 13) != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "2b6508f01d9d344456f3f56ae1d5e0b7aae6bd00", "filename": "gcc/testsuite/gcc.dg/strlenopt-12g.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-12g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-12g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-12g.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,6 @@\n+/* This test needs runtime that provides stpcpy function.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt-12.c\""}, {"sha": "62effcd64d04bee24c2bdefd1046033184bb03dc", "filename": "gcc/testsuite/gcc.dg/strlenopt-13.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) void\n+fn1 (char *p, const char *y, const char *z, size_t *lp)\n+{\n+  char *q, *r, *s;\n+  char buf1[64], buf2[64];\n+  size_t l[8];\n+  /* These two strlen calls stay, all strcpy calls are optimized into\n+     memcpy, all strchr calls optimized away, and most other strlen\n+     calls too.  */\n+  l[0] = strlen (y);\n+  l[1] = strlen (z);\n+  strcpy (buf1, y);\n+  strcpy (buf2, z);\n+  strcpy (p, \"abcde\");\n+  q = strchr (p, '\\0');\n+  strcpy (q, \"efghi\");\n+  r = strchr (q, '\\0');\n+  strcpy (r, buf1);\n+  l[2] = strlen (p);\n+  l[3] = strlen (q);\n+  l[4] = strlen (r);\n+  strcpy (r, buf2);\n+  /* Except for these two calls, strlen (r) before and after the above\n+     is non-constant, so adding l[4] - l[1] to all previous strlens\n+     might make the expressions already too complex.  */\n+  l[5] = strlen (p);\n+  l[6] = strlen (q);\n+  /* This one is of course optimized, it is l[1].  */\n+  l[7] = strlen (r);\n+  memcpy (lp, l, sizeof l);\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  size_t l[8];\n+  const char *volatile y = \"ABCDEFG\";\n+  const char *volatile z = \"HIJK\";\n+  memset (buf, '\\0', sizeof buf);\n+  fn1 (buf, y, z, l);\n+  if (memcmp (buf, \"abcdeefghiHIJK\", 15) != 0)\n+    abort ();\n+  if (l[0] != 7 || l[1] != 4)\n+    abort ();\n+  if (l[2] != 17 || l[3] != 12 || l[4] != 7)\n+    abort ();\n+  if (l[5] != 14 || l[6] != 9 || l[7] != 4)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "62a120de07becf01cc7885cccf882f917c7bdd7a", "filename": "gcc/testsuite/gcc.dg/strlenopt-14g.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14g.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,115 @@\n+/* This test needs runtime that provides stpcpy and mempcpy functions.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+fn1 (char *p, size_t *l1, size_t *l2)\n+{\n+  char *a = mempcpy (p, \"abcde\", 6);\n+  /* This strlen needs to stay.  */\n+  size_t la = strlen (a);\n+  /* This strlen can be optimized into 5.  */\n+  size_t lp = strlen (p);\n+  *l1 = la;\n+  *l2 = lp;\n+  return a;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn2 (char *p, const char *q, size_t *l1, size_t *l2, size_t *l3)\n+{\n+  /* This strlen needs to stay.  */\n+  size_t lq = strlen (q);\n+  char *a = mempcpy (p, q, lq + 1);\n+  /* This strlen needs to stay.  */\n+  size_t la = strlen (a);\n+  /* This strlen can be optimized into lq.  */\n+  size_t lp = strlen (p);\n+  *l1 = lq;\n+  *l2 = la;\n+  *l3 = lp;\n+  return a;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn3 (char *p, size_t *l1, size_t *l2)\n+{\n+  char *a = stpcpy (p, \"abcde\");\n+  /* This strlen can be optimized into 0.  */\n+  size_t la = strlen (a);\n+  /* This strlen can be optimized into 5.  */\n+  size_t lp = strlen (p);\n+  *l1 = la;\n+  *l2 = lp;\n+  return a;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn4 (char *p, const char *q, size_t *l1, size_t *l2, size_t *l3)\n+{\n+  /* This strlen needs to stay.  */\n+  size_t lq = strlen (q);\n+  char *a = stpcpy (p, q);\n+  /* This strlen can be optimized into 0.  */\n+  size_t la = strlen (a);\n+  /* This strlen can be optimized into lq.  */\n+  size_t lp = strlen (p);\n+  *l1 = lq;\n+  *l2 = la;\n+  *l3 = lp;\n+  return a;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn5 (char *p, const char *q, size_t *l1, size_t *l2)\n+{\n+  char *a = stpcpy (p, q);\n+  /* This strlen can be optimized into 0.  */\n+  size_t la = strlen (a);\n+  /* This strlen can be optimized into a - p.  */\n+  size_t lp = strlen (p);\n+  *l1 = la;\n+  *l2 = lp;\n+  return a;\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  const char *volatile q = \"ABCDEFGH\";\n+  size_t l1, l2, l3;\n+  memset (buf, '\\0', sizeof buf);\n+  memset (buf + 6, 'z', 7);\n+  if (fn1 (buf, &l1, &l2) != buf + 6 || l1 != 7 || l2 != 5\n+      || memcmp (buf, \"abcde\\0zzzzzzz\", 14) != 0)\n+    abort ();\n+  if (fn2 (buf, q, &l1, &l2, &l3) != buf + 9 || l1 != 8 || l2 != 4 || l3 != 8\n+      || memcmp (buf, \"ABCDEFGH\\0zzzz\", 14) != 0)\n+    abort ();\n+  if (fn3 (buf, &l1, &l2) != buf + 5 || l1 != 0 || l2 != 5\n+      || memcmp (buf, \"abcde\\0GH\\0zzzz\", 14) != 0)\n+    abort ();\n+  l3 = 0;\n+  memset (buf, 'n', 9);\n+  if (fn4 (buf, q, &l1, &l2, &l3) != buf + 8 || l1 != 8 || l2 != 0 || l3 != 8\n+      || memcmp (buf, \"ABCDEFGH\\0zzzz\", 14) != 0)\n+    abort ();\n+  memset (buf, 'm', 9);\n+  if (fn5 (buf, q, &l1, &l2) != buf + 8 || l1 != 0 || l2 != 8\n+      || memcmp (buf, \"ABCDEFGH\\0zzzz\", 14) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "999759e86f6b816c120e2280d589a337fc2a59d2", "filename": "gcc/testsuite/gcc.dg/strlenopt-14gf.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14gf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14gf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-14gf.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,24 @@\n+/* This test needs runtime that provides stpcpy, mempcpy and __*_chk\n+   functions.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define FORTIFY_SOURCE 2\n+#include \"strlenopt-14g.c\"\n+\n+/* Compared to strlenopt-14gf.c, strcpy_chk with string literal as\n+   second argument isn't being optimized by builtins.c into\n+   memcpy.  */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__mempcpy_chk \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "495166ddb9bc431ad0d8aed06d8db5daaf831be7", "filename": "gcc/testsuite/gcc.dg/strlenopt-15.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-15.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) size_t\n+fn1 (char *p, size_t l)\n+{\n+  memcpy (p, \"abcdef\", l);\n+  /* This strlen can't be optimized, as l is unknown.  */\n+  return strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn2 (char *p, const char *q, size_t *lp)\n+{\n+  size_t l = strlen (q), l2;\n+  memcpy (p, q, 7);\n+  /* This strlen can't be optimized, as l might be bigger than 7.  */\n+  l2 = strlen (p);\n+  *lp = l;\n+  return l2;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn3 (char *p)\n+{\n+  *p = 0;\n+  return p + 1;\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  const char *volatile q = \"ABCDEFGH\";\n+  const char *volatile q2 = \"IJ\\0KLMNOPQRS\";\n+  size_t l;\n+  memset (buf, '\\0', sizeof buf);\n+  memset (buf + 2, 'a', 7);\n+  if (fn1 (buf, 3) != 9 || memcmp (buf, \"abcaaaaaa\", 10) != 0)\n+    abort ();\n+  if (fn1 (buf, 7) != 6 || memcmp (buf, \"abcdef\\0aa\", 10) != 0)\n+    abort ();\n+  if (fn2 (buf, q, &l) != 9 || l != 8 || memcmp (buf, \"ABCDEFGaa\", 10) != 0)\n+    abort ();\n+  if (fn2 (buf, q2, &l) != 2 || l != 2 || memcmp (buf, \"IJ\\0KLMNaa\", 10) != 0)\n+    abort ();\n+  if (fn3 (buf) != buf + 1 || memcmp (buf, \"\\0J\\0KLMNaa\", 10) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "11e4d319adb2357dc1fe634dba7b2e1d7cc6e452", "filename": "gcc/testsuite/gcc.dg/strlenopt-16g.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-16g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-16g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-16g.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,34 @@\n+/* This test needs runtime that provides stpcpy function.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+fn1 (char *p, const char *q)\n+{\n+  /* This strcpy can be optimized into stpcpy.  */\n+  strcpy (p, q);\n+  /* And this strchr into the return value from it.  */\n+  return strchr (p, '\\0');\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  const char *volatile q = \"ABCDEFGH\";\n+  if (fn1 (buf, q) != buf + 8 || memcmp (buf, \"ABCDEFGH\", 9) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "b61bf74b8b20c85e287263c7b22657f5a1ec231d", "filename": "gcc/testsuite/gcc.dg/strlenopt-17g.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-17g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-17g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-17g.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,57 @@\n+/* This test needs runtime that provides stpcpy function.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) int\n+foo (const char *p)\n+{\n+  static int c;\n+  const char *q[] = { \"123498765abcde\", \"123498765..\", \"129abcde\", \"129abcde\" };\n+  if (strcmp (p, q[c]) != 0)\n+    abort ();\n+  return c++;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (const char *p, const char *q)\n+{\n+  size_t l;\n+  /* This strlen stays.  */\n+  char *a = __builtin_alloca (strlen (p) + 50);\n+  /* strcpy can be optimized into memcpy.  */\n+  strcpy (a, p);\n+  /* strcat into stpcpy.  */\n+  strcat (a, q);\n+  /* This strlen can be optimized away.  */\n+  l = strlen (a);\n+  /* This becomes memcpy.  */\n+  strcat (a, \"abcde\");\n+  if (!foo (a))\n+    /* And this one too.  */\n+    strcpy (a + l, \"..\");\n+  foo (a);\n+}\n+\n+int\n+main ()\n+{\n+  const char *volatile s1 = \"1234\";\n+  const char *volatile s2 = \"98765\";\n+  const char *volatile s3 = \"12\";\n+  const char *volatile s4 = \"9\";\n+  bar (s1, s2);\n+  bar (s3, s4);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"mempcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "c70daea4b2843ed390e8f9d585f9e6c9c9d6b179", "filename": "gcc/testsuite/gcc.dg/strlenopt-18g.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-18g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-18g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-18g.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,82 @@\n+/* This test needs runtime that provides stpcpy function.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+fn1 (int x, int y, int z)\n+{\n+  static char buf[40];\n+  const char *p;\n+  switch (x)\n+    {\n+    case 0:\n+      p = \"abcd\";\n+      break;\n+    case 1:\n+      p = \"efgh\";\n+      break;\n+    case 2:\n+      p = \"ijkl\";\n+      break;\n+    default:\n+      p = \"mnopq\";\n+      break;\n+    }\n+  if (y)\n+    {\n+      strcpy (buf, p);\n+      if (z)\n+\tstrcat (buf, \"ABCDEFG\");\n+      else\n+\tstrcat (buf, \"HIJKLMN\");\n+    }\n+  else\n+    {\n+      strcpy (buf, p + 1);\n+      if (z)\n+\tstrcat (buf, \"OPQ\");\n+      else\n+\tstrcat (buf, \"RST\");\n+    }\n+  return buf;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 5; i++)\n+    {\n+      const char *p = \"abcdefghijklmnopq\" + (i < 3 ? i : 3) * 4;\n+      const char *q;\n+      int j = i >= 3;\n+      fn1 (i ? 0 : 1, 1, 1);\n+      q = fn1 (i, 0, 0);\n+      if (memcmp (q, p + 1, 3 + j) != 0 || memcmp (q + 3 + j, \"RST\", 4) != 0)\n+\tabort ();\n+      fn1 (i ? 0 : 1, 0, 1);\n+      q = fn1 (i, 1, 0);\n+      if (memcmp (q, p, 4 + j) != 0 || memcmp (q + 4 + j, \"HIJKLMN\", 8) != 0)\n+\tabort ();\n+      fn1 (i ? 0 : 1, 1, 0);\n+      q = fn1 (i, 0, 1);\n+      if (memcmp (q, p + 1, 3 + j) != 0 || memcmp (q + 3 + j, \"OPQ\", 4) != 0)\n+\tabort ();\n+      fn1 (i ? 0 : 1, 0, 0);\n+      q = fn1 (i, 1, 1);\n+      if (memcmp (q, p, 4 + j) != 0 || memcmp (q + 4 + j, \"ABCDEFG\", 8) != 0)\n+\tabort ();\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "042fd77b002b12e9f38574fdcfd7399c4c5e9e29", "filename": "gcc/testsuite/gcc.dg/strlenopt-19.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-19.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+fn1 (int x, int y, int z)\n+{\n+  static char buf[40];\n+  const char *p;\n+  switch (x)\n+    {\n+    case 0:\n+      p = \"abcd\";\n+      /* Prevent cswitch optimization.  */\n+      asm volatile (\"\" : : : \"memory\");\n+      break;\n+    case 1:\n+      p = \"efgh\";\n+      break;\n+    case 2:\n+      p = \"ijkl\";\n+      break;\n+    default:\n+      p = \"mnop\";\n+      break;\n+    }\n+  if (y)\n+    {\n+      strcpy (buf, p);\n+      if (z)\n+\tstrcat (buf, \"ABCDEFG\");\n+      else\n+\tstrcat (buf, \"HIJKLMN\");\n+    }\n+  else\n+    {\n+      strcpy (buf, p + 1);\n+      if (z)\n+\tstrcat (buf, \"OPQ\");\n+      else\n+\tstrcat (buf, \"RST\");\n+    }\n+  return buf;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 5; i++)\n+    {\n+      const char *p = \"abcdefghijklmnop\" + (i < 3 ? i : 3) * 4;\n+      const char *q;\n+      fn1 (i ? 0 : 1, 1, 1);\n+      q = fn1 (i, 0, 0);\n+      if (memcmp (q, p + 1, 3) != 0 || memcmp (q + 3, \"RST\", 4) != 0)\n+\tabort ();\n+      fn1 (i ? 0 : 1, 0, 1);\n+      q = fn1 (i, 1, 0);\n+      if (memcmp (q, p, 4) != 0 || memcmp (q + 4, \"HIJKLMN\", 8) != 0)\n+\tabort ();\n+      fn1 (i ? 0 : 1, 1, 0);\n+      q = fn1 (i, 0, 1);\n+      if (memcmp (q, p + 1, 3) != 0 || memcmp (q + 3, \"OPQ\", 4) != 0)\n+\tabort ();\n+      fn1 (i ? 0 : 1, 0, 0);\n+      q = fn1 (i, 1, 1);\n+      if (memcmp (q, p, 4) != 0 || memcmp (q + 4, \"ABCDEFG\", 8) != 0)\n+\tabort ();\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "4b0207fd4f7f87c71c0693a4236581fa68d55c06", "filename": "gcc/testsuite/gcc.dg/strlenopt-1f.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-1f.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,18 @@\n+/* This test needs runtime that provides __*_chk functions.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define FORTIFY_SOURCE 2\n+#include \"strlenopt-1.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "5e6557b568708a42c4be31f1a5a44c7c86e6cb7f", "filename": "gcc/testsuite/gcc.dg/strlenopt-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+foo (char *p, char *r)\n+{\n+  char buf[26];\n+  if (strlen (p) + strlen (r) + 9 > 26)\n+    return NULL;\n+  /* This strcpy can be optimized into memcpy, using the remembered\n+     strlen (p).  */\n+  strcpy (buf, p);\n+  /* These two strcat can be optimized into memcpy.  The first one\n+     could be even optimized into a *ptr = '/'; store as the '\\0'\n+     is immediately overwritten.  */\n+  strcat (buf, \"/\");\n+  strcat (buf, \"abcde\");\n+  /* This strcpy can be optimized into memcpy, using the remembered\n+     strlen (r).  */\n+  strcat (buf, r);\n+  /* And this can be optimized into memcpy too.  */\n+  strcat (buf, \"fg\");\n+  return strdup (buf);\n+}\n+\n+int\n+main ()\n+{\n+  char *volatile p = \"string1\";\n+  char *volatile r = \"string2\";\n+  char *q = foo (p, r);\n+  if (q != NULL)\n+    {\n+      if (strcmp (q, \"string1/abcdestring2fg\"))\n+\tabort ();\n+      free (q);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 5 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "6fe99a422e9e411de37156b562615bc18c164800", "filename": "gcc/testsuite/gcc.dg/strlenopt-20.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-20.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) const char *\n+fn1 (int x, int y)\n+{\n+  const char *p;\n+  switch (x)\n+    {\n+    case 0:\n+      p = \"abcd\";\n+      /* Prevent cswitch optimization.  */\n+      asm volatile (\"\" : : : \"memory\");\n+      break;\n+    case 1:\n+      p = \"efgh\";\n+      break;\n+    case 2:\n+      p = \"ijkl\";\n+      break;\n+    default:\n+      p = \"mnop\";\n+      break;\n+    }\n+  if (y)\n+    /* strchr should be optimized into p + 4 here.  */\n+    return strchr (p, '\\0');\n+  else\n+    /* and strlen into 3.  */\n+    return p + strlen (p + 1);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn2 (char *p, char *q)\n+{\n+  size_t l;\n+  /* Both strcpy calls can be optimized into memcpy, strlen needs to stay.  */\n+  strcpy (p, \"abc\");\n+  p[3] = 'd';\n+  l = strlen (p);\n+  strcpy (q, p);\n+  return l;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+fn3 (char *p)\n+{\n+  char *c;\n+  /* The strcpy call can be optimized into memcpy, strchr needs to stay,\n+     strcat is optimized into memcpy.  */\n+  strcpy (p, \"abc\");\n+  p[3] = 'd';\n+  c = strchr (p, '\\0');\n+  strcat (p, \"efgh\");\n+  return c;\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  char buf[64], buf2[64];\n+  for (i = 0; i < 5; i++)\n+    {\n+      const char *p = \"abcdefghijklmnop\" + (i < 3 ? i : 3) * 4;\n+      const char *q;\n+      q = fn1 (i, 1);\n+      if (memcmp (q - 4, p, 4) != 0 || q[0] != '\\0')\n+\tabort ();\n+      q = fn1 (i, 0);\n+      if (memcmp (q - 3, p, 4) != 0 || q[1] != '\\0')\n+\tabort ();\n+    }\n+  memset (buf, '\\0', sizeof buf);\n+  memset (buf + 4, 'z', 2);\n+  if (fn2 (buf, buf2) != 6\n+      || memcmp (buf, \"abcdzz\", 7) != 0\n+      || memcmp (buf2, \"abcdzz\", 7) != 0)\n+    abort ();\n+  memset (buf, '\\0', sizeof buf);\n+  memset (buf + 4, 'z', 2);\n+  if (fn3 (buf) != buf + 6 || memcmp (buf, \"abcdzzefgh\", 11) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "7996e67618ca02a31d9c35c190efc96abf8c7a6f", "filename": "gcc/testsuite/gcc.dg/strlenopt-2f.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-2f.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,18 @@\n+/* This test needs runtime that provides __*_chk functions.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define FORTIFY_SOURCE 2\n+#include \"strlenopt-2.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 5 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "1bab8f37e996a4e33eb11194910566ae1d6c09c3", "filename": "gcc/testsuite/gcc.dg/strlenopt-3.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-3.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) size_t\n+fn1 (char *p, char *q)\n+{\n+  size_t s = strlen (q);\n+  strcpy (p, q);\n+  return s - strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn2 (char *p, char *q)\n+{\n+  size_t s = strlen (q);\n+  memcpy (p, q, s + 1);\n+  return s - strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn3 (char *p)\n+{\n+  memcpy (p, \"abcd\", 5);\n+  return strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn4 (char *p)\n+{\n+  memcpy (p, \"efg\\0hij\", 6);\n+  return strlen (p);\n+}\n+\n+int\n+main ()\n+{\n+  char buf[64];\n+  char *volatile p = buf;\n+  char *volatile q = \"ABCDEF\";\n+  buf[7] = 'G';\n+  if (fn1 (p, q) != 0 || memcmp (buf, \"ABCDEF\\0G\", 8))\n+    abort ();\n+  q = \"HIJ\";\n+  if (fn2 (p + 1, q) != 0 || memcmp (buf, \"AHIJ\\0F\\0G\", 8))\n+    abort ();\n+  buf[6] = 'K';\n+  if (fn3 (p + 1) != 4 || memcmp (buf, \"Aabcd\\0KG\", 8))\n+    abort ();\n+  if (fn4 (p) != 3 || memcmp (buf, \"efg\\0hiKG\", 8))\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 4\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 3\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "beea4959245f17d5e7036229f02bf6544437fb9e", "filename": "gcc/testsuite/gcc.dg/strlenopt-4.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+/* If stpcpy can't be used, this is optimized into\n+   strcpy (p, q); strcat (p, r); memcpy (p + strlen (p), \"abcd\", 5);\n+   If stpcpy can be used (see strlenopt-4g.c test),\n+   this is optimized into\n+   memcpy (stpcpy (stpcpy (p, q), r), \"abcd\", 5);  */\n+__attribute__((noinline, noclone)) void\n+foo (char *p, const char *q, const char *r)\n+{\n+  strcpy (p, q);\n+  strcat (p, r);\n+  strcat (p, \"abcd\");\n+}\n+\n+/* If stpcpy can't be used, this is optimized into\n+   memcpy (p, \"abcd\", 4); strcpy (p + 4, q); strcat (p, r);\n+   If stpcpy can be used, this is optimized into\n+   memcpy (p, \"abcd\", 4); strcpy (stpcpy (p + 4, q), r);  */\n+__attribute__((noinline, noclone)) void\n+bar (char *p, const char *q, const char *r)\n+{\n+  strcpy (p, \"abcd\");\n+  strcat (p, q);\n+  strcat (p, r);\n+}\n+\n+/* If stpcpy can't be used, this is optimized into\n+   strcat (p, q); memcpy (t1 = p + strlen (p), \"abcd\", 4);\n+   strcpy (t1 + 4, r); memcpy (p + strlen (p), \"efgh\", 5);\n+   If stpcpy can be used, this is optimized into\n+   t1 = stpcpy (p + strlen (p), q); memcpy (t1, \"abcd\", 4);\n+   memcpy (stpcpy (t1 + 4, r), \"efgh\", 5);  */\n+__attribute__((noinline, noclone)) void\n+baz (char *p, const char *q, const char *r)\n+{\n+  strcat (p, q);\n+  strcat (p, \"abcd\");\n+  strcat (p, r);\n+  strcat (p, \"efgh\");\n+}\n+\n+char buf[64];\n+\n+int\n+main ()\n+{\n+  char *volatile p = buf;\n+  const char *volatile q = \"ij\";\n+  const char *volatile r = \"klmno\";\n+  foo (p, q, r);\n+  if (memcmp (buf, \"ijklmnoabcd\\0\\0\\0\\0\\0\\0\\0\\0\", 20) != 0)\n+    abort ();\n+  memset (buf, '\\0', sizeof buf);\n+  bar (p, q, r);\n+  if (memcmp (buf, \"abcdijklmno\\0\\0\\0\\0\\0\\0\\0\\0\", 20) != 0)\n+    abort ();\n+  memset (buf, 'v', 3);\n+  memset (buf + 3, '\\0', -3 + sizeof buf);\n+  baz (p, q, r);\n+  if (memcmp (buf, \"vvvijabcdklmnoefgh\\0\", 20) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "7b397366e9ca8d3f8bc473f51040f7cbbf4ad198", "filename": "gcc/testsuite/gcc.dg/strlenopt-4g.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4g.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,14 @@\n+/* This test needs runtime that provides stpcpy function.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt-4.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 5 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "cf99212a15282346952d58a811a321b416afd450", "filename": "gcc/testsuite/gcc.dg/strlenopt-4gf.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4gf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4gf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-4gf.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,19 @@\n+/* This test needs runtime that provides stpcpy and __*_chk functions.  */\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#define FORTIFY_SOURCE 2\n+#include \"strlenopt-4.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__memcpy_chk \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcpy_chk \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__strcat_chk \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"__stpcpy_chk \\\\(\" 5 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "131494ac8e48507a0f903e50ab9641d7caebc5b0", "filename": "gcc/testsuite/gcc.dg/strlenopt-5.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-5.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+foo (char *p, const char *q)\n+{\n+  char *e = strchr (p, '\\0');\n+  strcat (p, q);\n+  return e;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+bar (char *p)\n+{\n+  memcpy (p, \"abcd\", 5);\n+  return strchr (p, '\\0');\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz (char *p)\n+{\n+  char *e = strchr (p, '\\0');\n+  strcat (e, \"abcd\");\n+}\n+\n+char buf[64];\n+\n+int\n+main ()\n+{\n+  char *volatile p = buf;\n+  const char *volatile q = \"ij\";\n+  memset (buf, 'v', 3);\n+  if (foo (p, q) != buf + 3\n+      || memcmp (buf, \"vvvij\\0\\0\\0\\0\", 10) != 0)\n+    abort ();\n+  memset (buf, '\\0', sizeof buf);\n+  if (bar (p) != buf + 4\n+      || memcmp (buf, \"abcd\\0\\0\\0\\0\\0\", 10) != 0)\n+    abort ();\n+  memset (buf, 'v', 2);\n+  memset (buf + 2, '\\0', -2 + sizeof buf);\n+  baz (p);\n+  if (memcmp (buf, \"vvabcd\\0\\0\\0\", 10) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "d9b718758a5ee80aec993d63e1f35cc05bf20ab6", "filename": "gcc/testsuite/gcc.dg/strlenopt-6.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-6.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+foo (char *x)\n+{\n+#ifdef PR50262_FIXED\n+  /* Once PTA is fixed, we'll need just one strlen here,\n+     without the memcpy.  */\n+  char *p = x;\n+  char *q = malloc (strlen (p) + 64);\n+#else\n+  /* This is here just because PTA can't figure that\n+     *q = '\\0' store below can't change p's length.\n+     In this case we have one strlen and one memcpy here.  */\n+  char b[64];\n+  char *q = malloc (strlen (x) + 64);\n+  char *p = strcpy (b, x);\n+#endif\n+  char *r;\n+  if (q == NULL) return NULL;\n+  /* This store can be optimized away once strcat is\n+     replaced with memcpy.  */\n+  *q = '\\0';\n+  /* These two strcat calls can be optimized into memcpy calls.  */\n+  strcat (q, p);\n+  strcat (q, \"/\");\n+  /* The strchr can be optimized away, as we know the current\n+     string length as well as end pointer.  */\n+  r = strchr (q, '\\0');\n+  /* This store can go, as it is overwriting '\\0' with the same\n+     character.  */\n+  *r = '\\0';\n+  /* And this strcat can be again optimized into memcpy call.  */\n+  strcat (q, \"abcde\");\n+  return q;\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+bar (char *p)\n+{\n+  char buf[26];\n+  char *r;\n+  if (strlen (p) + 9 > 26)\n+    return NULL;\n+  *buf = '\\0';\n+  strcat (buf, p);\n+  strcat (buf, \"/\");\n+  r = strchr (buf, '\\0');\n+  *r = '\\0';\n+  strcat (buf, \"abcde\");\n+  return strdup (buf);\n+}\n+\n+int\n+main ()\n+{\n+  char *volatile p = \"string1\";\n+  char *volatile r = \"string2\";\n+  char *q = foo (p);\n+  if (q != NULL)\n+    {\n+      if (strcmp (q, \"string1/abcde\"))\n+\tabort ();\n+      memset (q, '\\0', 14);\n+      free (q);\n+    }\n+  q = bar (p);\n+  if (q != NULL)\n+    {\n+      if (strcmp (q, \"string1/abcde\"))\n+\tabort ();\n+      free (q);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "6fd940d748b2b1c0866c068b777ac9c8cdfa0bf3", "filename": "gcc/testsuite/gcc.dg/strlenopt-7.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-7.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+char buf[64];\n+\n+__attribute__((noinline, noclone)) size_t\n+foo (void)\n+{\n+  char *p = memcpy (buf, \"abcdefgh\", 9);\n+  /* This store can be optimized away as... */\n+  *p = '\\0';\n+  /* ... the following strcat can be optimized into memcpy,\n+     which overwrites that '\\0'.  */\n+  strcat (p, \"ijk\");\n+  /* This should be optimized into return 3.  */\n+  return strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+bar (char *p)\n+{\n+  char *r = strchr (p, '\\0');\n+  /* This store shouldn't be optimized away, because we\n+     want to crash if p is e.g. a string literal.  */\n+  *r = '\\0';\n+  /* This strlen can be optimized into 0.  */\n+  return strlen (r);\n+}\n+\n+int\n+main ()\n+{\n+  char *volatile p = buf;\n+  if (foo () != 3 || memcmp (buf, \"ijk\\0efgh\\0\", 10) != 0)\n+    abort ();\n+  if (bar (p) != 0 || memcmp (buf, \"ijk\\0efgh\\0\", 10) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\*r_\\[0-9\\]* = 0;\" 1 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 3;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0;\" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "3aaf660a12ccd940396527c6568325b7da694292", "filename": "gcc/testsuite/gcc.dg/strlenopt-8.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#include \"strlenopt.h\"\n+\n+/* Yes, there are people who write code like this.  */\n+\n+__attribute__((noinline, noclone)) char *\n+foo (int r)\n+{\n+  char buf[10] = \"\";\n+  strcat (buf, r ? \"r\" : \"w\");\n+  strcat (buf, \"b\");\n+  return strdup (buf);\n+}\n+\n+__attribute__((noinline, noclone)) char *\n+bar (int r)\n+{\n+  char buf[10] = {};\n+  strcat (buf, r ? \"r\" : \"w\");\n+  strcat (buf, \"b\");\n+  return strdup (buf);\n+}\n+\n+int\n+main ()\n+{\n+  char *q = foo (1);\n+  if (q != NULL)\n+    {\n+      if (strcmp (q, \"rb\"))\n+\tabort ();\n+      free (q);\n+    }\n+  q = bar (0);\n+  if (q != NULL)\n+    {\n+      if (strcmp (q, \"wb\"))\n+\tabort ();\n+      free (q);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "6590d708ec7aa11d38fadb586359f94448334279", "filename": "gcc/testsuite/gcc.dg/strlenopt-9.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) char *\n+fn1 (int r)\n+{\n+  char *p = r ? \"a\" : \"bc\";\n+  /* String length for p varies, therefore strchr below isn't\n+     optimized away.  */\n+  return strchr (p, '\\0');\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn2 (int r)\n+{\n+  char *p, q[10];\n+  strcpy (q, \"abc\");\n+  p = r ? \"a\" : q;\n+  /* String length for p varies, therefore strlen below isn't\n+     optimized away.  */\n+  return strlen (p);\n+}\n+\n+__attribute__((noinline, noclone)) size_t\n+fn3 (char *p, int n)\n+{\n+  int i;\n+  p = strchr (p, '\\0');\n+  /* strcat here can be optimized into memcpy.  */\n+  strcat (p, \"abcd\");\n+  for (i = 0; i < n; i++)\n+    if ((i % 123) == 53)\n+      /* strcat here is optimized into strlen and memcpy.  */\n+      strcat (p, \"efg\");\n+  /* The strlen here can't be optimized away, as in the loop string\n+     length of p might change.  */\n+  return strlen (p);\n+}\n+\n+char buf[64];\n+\n+__attribute__((noinline, noclone)) size_t\n+fn4 (char *x, int n)\n+{\n+  int i;\n+  size_t l;\n+  char a[64];\n+  char *p = strchr (x, '\\0');\n+  /* strcpy here is optimized into memcpy, length computed as p - x + 1.  */\n+  strcpy (a, x);\n+  /* strcat here is optimized into memcpy.  */\n+  strcat (p, \"abcd\");\n+  for (i = 0; i < n; i++)\n+    if ((i % 123) == 53)\n+      /* strcat here is optimized into strlen and memcpy.  */\n+      strcat (a, \"efg\");\n+  /* The strlen should be optimized here into 4.  */\n+  l = strlen (p);\n+  /* This stays strcpy.  */\n+  strcpy (buf, a);\n+  return l;\n+}\n+\n+int\n+main ()\n+{\n+  volatile int l = 1;\n+  char b[64];\n+\n+  if (memcmp (fn1 (l) - 1, \"a\", 2) != 0)\n+    abort ();\n+  if (memcmp (fn1 (!l) - 2, \"bc\", 3) != 0)\n+    abort ();\n+  if (fn2 (l) != 1 || fn2 (!l) != 3)\n+    abort ();\n+  memset (b, '\\0', sizeof b);\n+  memset (b, 'a', 3);\n+  if (fn3 (b, 10) != 4 || memcmp (b, \"aaaabcd\", 8) != 0)\n+    abort ();\n+  if (fn3 (b, 128) != 7 || memcmp (b, \"aaaabcdabcdefg\", 15) != 0)\n+    abort ();\n+  if (fn3 (b, 256) != 10 || memcmp (b, \"aaaabcdabcdefgabcdefgefg\", 25) != 0)\n+    abort ();\n+  if (fn4 (b, 10) != 4\n+      || memcmp (b, \"aaaabcdabcdefgabcdefgefgabcd\", 29) != 0\n+      || memcmp (buf, \"aaaabcdabcdefgabcdefgefg\", 25) != 0)\n+    abort ();\n+  if (fn4 (b, 128) != 4\n+      || memcmp (b, \"aaaabcdabcdefgabcdefgefgabcdabcd\", 33) != 0\n+      || memcmp (buf, \"aaaabcdabcdefgabcdefgefgabcdefg\", 32) != 0)\n+    abort ();\n+  if (fn4 (b, 256) != 4\n+      || memcmp (b, \"aaaabcdabcdefgabcdefgefgabcdabcdabcd\", 37) != 0\n+      || memcmp (buf, \"aaaabcdabcdefgabcdefgefgabcdabcdefgefg\", 39) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 3 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { cleanup-tree-dump \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 4;\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ef47e5ac9ad16e70e4dd6b84d1ae59532cdbfd5d", "filename": "gcc/testsuite/gcc.dg/strlenopt.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt.h?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,59 @@\n+/* This is a replacement of needed parts from stdlib.h and string.h\n+   for -foptimize-strlen testing, to ensure we are testing the builtins\n+   rather than whatever the OS has in its headers.  */\n+\n+#define NULL ((void *) 0)\n+typedef __SIZE_TYPE__ size_t;\n+extern void abort (void);\n+void *malloc (size_t);\n+void free (void *);\n+char *strdup (const char *);\n+size_t strlen (const char *);\n+void *memcpy (void *__restrict, const void *__restrict, size_t);\n+char *strcpy (char *__restrict, const char *__restrict);\n+char *strcat (char *__restrict, const char *__restrict);\n+char *strchr (const char *, int);\n+void *memset (void *, int, size_t);\n+int memcmp (const void *, const void *, size_t);\n+int strcmp (const char *, const char *);\n+#ifdef USE_GNU\n+void *mempcpy (void *__restrict, const void *__restrict, size_t);\n+char *stpcpy (char *__restrict, const char *__restrict);\n+#endif\n+\n+#if defined(FORTIFY_SOURCE) && FORTIFY_SOURCE > 0 && __OPTIMIZE__\n+# define bos(ptr) __builtin_object_size (ptr, FORTIFY_SOURCE > 0)\n+# define bos0(ptr) __builtin_object_size (ptr, 0)\n+\n+extern inline __attribute__((gnu_inline, always_inline, artificial)) void *\n+memcpy (void *__restrict dest, const void *__restrict src, size_t len)\n+{\n+  return __builtin___memcpy_chk (dest, src, len, bos0 (dest));\n+}\n+\n+extern inline __attribute__((gnu_inline, always_inline, artificial)) char *\n+strcpy (char *__restrict dest, const char *__restrict src)\n+{\n+  return __builtin___strcpy_chk (dest, src, bos (dest));\n+}\n+\n+extern inline __attribute__((gnu_inline, always_inline, artificial)) char *\n+strcat (char *__restrict dest, const char *__restrict src)\n+{\n+  return __builtin___strcat_chk (dest, src, bos (dest));\n+}\n+\n+# ifdef USE_GNU\n+extern inline __attribute__((gnu_inline, always_inline, artificial)) void *\n+mempcpy (void *__restrict dest, const void *__restrict src, size_t len)\n+{\n+  return __builtin___mempcpy_chk (dest, src, len, bos0 (dest));\n+}\n+\n+extern inline __attribute__((gnu_inline, always_inline, artificial)) char *\n+stpcpy (char *__restrict dest, const char *__restrict src)\n+{\n+  return __builtin___stpcpy_chk (dest, src, bos (dest));\n+}\n+# endif\n+#endif"}, {"sha": "5ad0f9dd08c9153bdb6fa28df6a9939894868473", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions for timing variables used to\n    measure run-time performance of the compiler.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010\n+   2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Alex Samuel <samuel@codesourcery.com>\n \n@@ -184,6 +184,7 @@ DEFTIMEVAR (TV_TREE_COPY_RENAME\t     , \"tree rename SSA copies\")\n DEFTIMEVAR (TV_TREE_SSA_VERIFY       , \"tree SSA verifier\")\n DEFTIMEVAR (TV_TREE_STMT_VERIFY      , \"tree STMT verifier\")\n DEFTIMEVAR (TV_TREE_SWITCH_CONVERSION, \"tree switch initialization conversion\")\n+DEFTIMEVAR (TV_TREE_STRLEN           , \"tree strlen optimization\")\n DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")\n DEFTIMEVAR (TV_DOM_FRONTIERS         , \"dominance frontiers\")\n DEFTIMEVAR (TV_DOMINANCE             , \"dominance computation\")"}, {"sha": "df1e24c79066bb7d644a868a88a66ff627201507", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -413,6 +413,7 @@ extern struct gimple_opt_pass pass_diagnose_omp_blocks;\n extern struct gimple_opt_pass pass_expand_omp;\n extern struct gimple_opt_pass pass_expand_omp_ssa;\n extern struct gimple_opt_pass pass_object_sizes;\n+extern struct gimple_opt_pass pass_strlen;\n extern struct gimple_opt_pass pass_fold_builtins;\n extern struct gimple_opt_pass pass_stdarg;\n extern struct gimple_opt_pass pass_early_warn_uninitialized;"}, {"sha": "71cefaaabc875a9988d23e3069d3a3c19fff848a", "filename": "gcc/tree-ssa-strlen.c", "status": "added", "additions": 1997, "deletions": 0, "changes": 1997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=8b57bfebe0bf2344c0eba3e17941a87e6dd2bbdf", "patch": "@@ -0,0 +1,1997 @@\n+/* String length optimization\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"params.h\"\n+\n+/* A vector indexed by SSA_NAME_VERSION.  0 means unknown, positive value\n+   is an index into strinfo vector, negative value stands for\n+   string length of a string literal (~strlen).  */\n+static VEC (int, heap) *ssa_ver_to_stridx;\n+\n+/* Number of currently active string indexes plus one.  */\n+static int max_stridx;\n+\n+/* String information record.  */\n+typedef struct strinfo_struct\n+{\n+  /* String length of this string.  */\n+  tree length;\n+  /* Any of the corresponding pointers for querying alias oracle.  */\n+  tree ptr;\n+  /* Statement for delayed length computation.  */\n+  gimple stmt;\n+  /* Pointer to '\\0' if known, if NULL, it can be computed as\n+     ptr + length.  */\n+  tree endptr;\n+  /* Reference count.  Any changes to strinfo entry possibly shared\n+     with dominating basic blocks need unshare_strinfo first, except\n+     for dont_invalidate which affects only the immediately next\n+     maybe_invalidate.  */\n+  int refcount;\n+  /* Copy of index.  get_strinfo (si->idx) should return si;  */\n+  int idx;\n+  /* These 3 fields are for chaining related string pointers together.\n+     E.g. for\n+     bl = strlen (b); dl = strlen (d); strcpy (a, b); c = a + bl;\n+     strcpy (c, d); e = c + dl;\n+     strinfo(a) -> strinfo(c) -> strinfo(e)\n+     All have ->first field equal to strinfo(a)->idx and are doubly\n+     chained through prev/next fields.  The later strinfos are required\n+     to point into the same string with zero or more bytes after\n+     the previous pointer and all bytes in between the two pointers\n+     must be non-zero.  Functions like strcpy or memcpy are supposed\n+     to adjust all previous strinfo lengths, but not following strinfo\n+     lengths (those are uncertain, usually invalidated during\n+     maybe_invalidate, except when the alias oracle knows better).\n+     Functions like strcat on the other side adjust the whole\n+     related strinfo chain.\n+     They are updated lazily, so to use the chain the same first fields\n+     and si->prev->next == si->idx needs to be verified.  */\n+  int first;\n+  int next;\n+  int prev;\n+  /* A flag whether the string is known to be written in the current\n+     function.  */\n+  bool writable;\n+  /* A flag for the next maybe_invalidate that this strinfo shouldn't\n+     be invalidated.  Always cleared by maybe_invalidate.  */\n+  bool dont_invalidate;\n+} *strinfo;\n+DEF_VEC_P(strinfo);\n+DEF_VEC_ALLOC_P(strinfo,heap);\n+\n+/* Pool for allocating strinfo_struct entries.  */\n+static alloc_pool strinfo_pool;\n+\n+/* Vector mapping positive string indexes to strinfo, for the\n+   current basic block.  The first pointer in the vector is special,\n+   it is either NULL, meaning the vector isn't shared, or it is\n+   a basic block pointer to the owner basic_block if shared.\n+   If some other bb wants to modify the vector, the vector needs\n+   to be unshared first, and only the owner bb is supposed to free it.  */\n+static VEC(strinfo, heap) *stridx_to_strinfo;\n+\n+/* One OFFSET->IDX mapping.  */\n+struct stridxlist\n+{\n+  struct stridxlist *next;\n+  HOST_WIDE_INT offset;\n+  int idx;\n+};\n+\n+/* Hash table entry, mapping a DECL to a chain of OFFSET->IDX mappings.  */\n+struct decl_stridxlist_map\n+{\n+  struct tree_map_base base;\n+  struct stridxlist list;\n+};\n+\n+/* Hash table for mapping decls to a chained list of offset -> idx\n+   mappings.  */\n+static htab_t decl_to_stridxlist_htab;\n+\n+/* Obstack for struct stridxlist and struct decl_stridxlist_map.  */\n+static struct obstack stridx_obstack;\n+\n+/* Last memcpy statement if it could be adjusted if the trailing\n+   '\\0' written is immediately overwritten, or\n+   *x = '\\0' store that could be removed if it is immediately overwritten.  */\n+struct laststmt_struct\n+{\n+  gimple stmt;\n+  tree len;\n+  int stridx;\n+} laststmt;\n+\n+/* Hash a from tree in a decl_stridxlist_map.  */\n+\n+static unsigned int\n+decl_to_stridxlist_hash (const void *item)\n+{\n+  return DECL_UID (((const struct decl_stridxlist_map *) item)->base.from);\n+}\n+\n+/* Helper function for get_stridx.  */\n+\n+static int\n+get_addr_stridx (tree exp)\n+{\n+  HOST_WIDE_INT off;\n+  struct decl_stridxlist_map ent, *e;\n+  struct stridxlist *list;\n+  tree base;\n+\n+  if (decl_to_stridxlist_htab == NULL)\n+    return 0;\n+\n+  base = get_addr_base_and_unit_offset (exp, &off);\n+  if (base == NULL || !DECL_P (base))\n+    return 0;\n+\n+  ent.base.from = base;\n+  e = (struct decl_stridxlist_map *)\n+      htab_find_with_hash (decl_to_stridxlist_htab, &ent, DECL_UID (base));\n+  if (e == NULL)\n+    return 0;\n+\n+  list = &e->list;\n+  do\n+    {\n+      if (list->offset == off)\n+\treturn list->idx;\n+      list = list->next;\n+    }\n+  while (list);\n+  return 0;\n+}\n+\n+/* Return string index for EXP.  */\n+\n+static int\n+get_stridx (tree exp)\n+{\n+  tree l;\n+\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    return VEC_index (int, ssa_ver_to_stridx, SSA_NAME_VERSION (exp));\n+\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    {\n+      int idx = get_addr_stridx (TREE_OPERAND (exp, 0));\n+      if (idx != 0)\n+\treturn idx;\n+    }\n+\n+  l = c_strlen (exp, 0);\n+  if (l != NULL_TREE\n+      && host_integerp (l, 1))\n+    {\n+      unsigned HOST_WIDE_INT len = tree_low_cst (l, 1);\n+      if (len == (unsigned int) len\n+\t  && (int) len >= 0)\n+\treturn ~(int) len;\n+    }\n+  return 0;\n+}\n+\n+/* Return true if strinfo vector is shared with the immediate dominator.  */\n+\n+static inline bool\n+strinfo_shared (void)\n+{\n+  return VEC_length (strinfo, stridx_to_strinfo)\n+\t && VEC_index (strinfo, stridx_to_strinfo, 0) != NULL;\n+}\n+\n+/* Unshare strinfo vector that is shared with the immediate dominator.  */\n+\n+static void\n+unshare_strinfo_vec (void)\n+{\n+  strinfo si;\n+  unsigned int i = 0;\n+\n+  gcc_assert (strinfo_shared ());\n+  stridx_to_strinfo = VEC_copy (strinfo, heap, stridx_to_strinfo);\n+  for (i = 1; VEC_iterate (strinfo, stridx_to_strinfo, i, si); ++i)\n+    if (si != NULL)\n+      si->refcount++;\n+  VEC_replace (strinfo, stridx_to_strinfo, 0, NULL);\n+}\n+\n+/* Attempt to create a string index for exp, ADDR_EXPR's operand.\n+   Return a pointer to the location where the string index can\n+   be stored (if 0) or is stored, or NULL if this can't be tracked.  */\n+\n+static int *\n+addr_stridxptr (tree exp)\n+{\n+  void **slot;\n+  struct decl_stridxlist_map ent;\n+  struct stridxlist *list;\n+  HOST_WIDE_INT off;\n+\n+  tree base = get_addr_base_and_unit_offset (exp, &off);\n+  if (base == NULL_TREE || !DECL_P (base))\n+    return NULL;\n+\n+  if (decl_to_stridxlist_htab == NULL)\n+    {\n+      decl_to_stridxlist_htab\n+\t= htab_create (64, decl_to_stridxlist_hash, tree_map_base_eq, NULL);\n+      gcc_obstack_init (&stridx_obstack);\n+    }\n+  ent.base.from = base;\n+  slot = htab_find_slot_with_hash (decl_to_stridxlist_htab, &ent,\n+\t\t\t\t   DECL_UID (base), INSERT);\n+  if (*slot)\n+    {\n+      int i;\n+      list = &((struct decl_stridxlist_map *)*slot)->list;\n+      for (i = 0; i < 16; i++)\n+\t{\n+\t  if (list->offset == off)\n+\t    return &list->idx;\n+\t  if (list->next == NULL)\n+\t    break;\n+\t}\n+      if (i == 16)\n+\treturn NULL;\n+      list->next = XOBNEW (&stridx_obstack, struct stridxlist);\n+      list = list->next;\n+    }\n+  else\n+    {\n+      struct decl_stridxlist_map *e\n+\t= XOBNEW (&stridx_obstack, struct decl_stridxlist_map);\n+      e->base.from = base;\n+      *slot = (void *) e;\n+      list = &e->list;\n+    }\n+  list->next = NULL;\n+  list->offset = off;\n+  list->idx = 0;\n+  return &list->idx;\n+}\n+\n+/* Create a new string index, or return 0 if reached limit.  */\n+\n+static int\n+new_stridx (tree exp)\n+{\n+  int idx;\n+  if (max_stridx >= PARAM_VALUE (PARAM_MAX_TRACKED_STRLENS))\n+    return 0;\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    {\n+      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp))\n+\treturn 0;\n+      idx = max_stridx++;\n+      VEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (exp), idx);\n+      return idx;\n+    }\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    {\n+      int *pidx = addr_stridxptr (TREE_OPERAND (exp, 0));\n+      if (pidx != NULL)\n+\t{\n+\t  gcc_assert (*pidx == 0);\n+\t  *pidx = max_stridx++;\n+\t  return *pidx;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Like new_stridx, but for ADDR_EXPR's operand instead.  */\n+\n+static int\n+new_addr_stridx (tree exp)\n+{\n+  int *pidx;\n+  if (max_stridx >= PARAM_VALUE (PARAM_MAX_TRACKED_STRLENS))\n+    return 0;\n+  pidx = addr_stridxptr (exp);\n+  if (pidx != NULL)\n+    {\n+      gcc_assert (*pidx == 0);\n+      *pidx = max_stridx++;\n+      return *pidx;\n+    }\n+  return 0;\n+}\n+\n+/* Create a new strinfo.  */\n+\n+static strinfo\n+new_strinfo (tree ptr, int idx, tree length)\n+{\n+  strinfo si = (strinfo) pool_alloc (strinfo_pool);\n+  si->length = length;\n+  si->ptr = ptr;\n+  si->stmt = NULL;\n+  si->endptr = NULL_TREE;\n+  si->refcount = 1;\n+  si->idx = idx;\n+  si->first = 0;\n+  si->prev = 0;\n+  si->next = 0;\n+  si->writable = false;\n+  si->dont_invalidate = false;\n+  return si;\n+}\n+\n+/* Decrease strinfo refcount and free it if not referenced anymore.  */\n+\n+static inline void\n+free_strinfo (strinfo si)\n+{\n+  if (si && --si->refcount == 0)\n+    pool_free (strinfo_pool, si);\n+}\n+\n+/* Return strinfo vector entry IDX.  */\n+\n+static inline strinfo\n+get_strinfo (int idx)\n+{\n+  if (VEC_length (strinfo, stridx_to_strinfo) <= (unsigned int) idx)\n+    return NULL;\n+  return VEC_index (strinfo, stridx_to_strinfo, idx);\n+}\n+\n+/* Set strinfo in the vector entry IDX to SI.  */\n+\n+static inline void\n+set_strinfo (int idx, strinfo si)\n+{\n+  if (VEC_length (strinfo, stridx_to_strinfo) && VEC_index (strinfo, stridx_to_strinfo, 0))\n+    unshare_strinfo_vec ();\n+  if (VEC_length (strinfo, stridx_to_strinfo) <= (unsigned int) idx)\n+    VEC_safe_grow_cleared (strinfo, heap, stridx_to_strinfo, idx + 1);\n+  VEC_replace (strinfo, stridx_to_strinfo, idx, si);\n+}\n+\n+/* Return string length, or NULL if it can't be computed.  */\n+\n+static tree\n+get_string_length (strinfo si)\n+{\n+  if (si->length)\n+    return si->length;\n+\n+  if (si->stmt)\n+    {\n+      gimple stmt = si->stmt, lenstmt;\n+      tree callee, lhs, lhs_var, fn, tem;\n+      location_t loc;\n+      gimple_stmt_iterator gsi;\n+\n+      gcc_assert (is_gimple_call (stmt));\n+      callee = gimple_call_fndecl (stmt);\n+      gcc_assert (callee && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL);\n+      lhs = gimple_call_lhs (stmt);\n+      gcc_assert (implicit_built_in_decls[BUILT_IN_STRCPY] != NULL_TREE);\n+      /* unshare_strinfo is intentionally not called here.  The (delayed)\n+\t transformation of strcpy or strcat into stpcpy is done at the place\n+\t of the former strcpy/strcat call and so can affect all the strinfos\n+\t with the same stmt.  If they were unshared before and transformation\n+\t has been already done, the handling of BUILT_IN_STPCPY{,_CHK} should\n+\t just compute the right length.  */\n+      switch (DECL_FUNCTION_CODE (callee))\n+\t{\n+\tcase BUILT_IN_STRCAT:\n+\tcase BUILT_IN_STRCAT_CHK:\n+\t  gsi = gsi_for_stmt (stmt);\n+\t  fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n+\t  gcc_assert (lhs == NULL_TREE);\n+\t  lhs_var = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n+\t  add_referenced_var (lhs_var);\n+\t  tem = unshare_expr (gimple_call_arg (stmt, 0));\n+\t  lenstmt = gimple_build_call (fn, 1, tem);\n+\t  lhs = make_ssa_name (lhs_var, lenstmt);\n+\t  gimple_call_set_lhs (lenstmt, lhs);\n+\t  gimple_set_vuse (lenstmt, gimple_vuse (stmt));\n+\t  gsi_insert_before (&gsi, lenstmt, GSI_SAME_STMT);\n+\t  lhs_var = create_tmp_var (TREE_TYPE (gimple_call_arg (stmt, 0)),\n+\t\t\t\t    NULL);\n+\t  add_referenced_var (lhs_var);\n+\t  tem = gimple_call_arg (stmt, 0);\n+\t  lenstmt\n+\t    = gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n+\t\t\t\t\t    make_ssa_name (lhs_var, NULL),\n+\t\t\t\t\t    tem, lhs);\n+\t  gsi_insert_before (&gsi, lenstmt, GSI_SAME_STMT);\n+\t  gimple_call_set_arg (stmt, 0, gimple_assign_lhs (lenstmt));\n+\t  lhs = NULL_TREE;\n+\t  /* FALLTHRU */\n+\tcase BUILT_IN_STRCPY:\n+\tcase BUILT_IN_STRCPY_CHK:\n+\t  if (gimple_call_num_args (stmt) == 2)\n+\t    fn = implicit_built_in_decls[BUILT_IN_STPCPY];\n+\t  else\n+\t    fn = built_in_decls[BUILT_IN_STPCPY_CHK];\n+\t  gcc_assert (lhs == NULL_TREE);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t    {\n+\t      fprintf (dump_file, \"Optimizing: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t  gimple_call_set_fndecl (stmt, fn);\n+\t  lhs_var = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)), NULL);\n+\t  add_referenced_var (lhs_var);\n+\t  lhs = make_ssa_name (lhs_var, stmt);\n+\t  gimple_call_set_lhs (stmt, lhs);\n+\t  update_stmt (stmt);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t    {\n+\t      fprintf (dump_file, \"into: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t  /* FALLTHRU */\n+\tcase BUILT_IN_STPCPY:\n+\tcase BUILT_IN_STPCPY_CHK:\n+\t  gcc_assert (lhs != NULL_TREE);\n+\t  loc = gimple_location (stmt);\n+\t  si->endptr = lhs;\n+\t  si->stmt = NULL;\n+\t  lhs = fold_convert_loc (loc, size_type_node, lhs);\n+\t  si->length = fold_convert_loc (loc, size_type_node, si->ptr);\n+\t  si->length = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n+\t\t\t\t\tlhs, si->length);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+    }\n+\n+  return si->length;\n+}\n+\n+/* Invalidate string length information for strings whose length\n+   might change due to stores in stmt.  */\n+\n+static bool\n+maybe_invalidate (gimple stmt)\n+{\n+  strinfo si;\n+  unsigned int i;\n+  bool nonempty = false;\n+\n+  for (i = 1; VEC_iterate (strinfo, stridx_to_strinfo, i, si); ++i)\n+    if (si != NULL)\n+      {\n+\tif (!si->dont_invalidate)\n+\t  {\n+\t    ao_ref r;\n+\t    ao_ref_init_from_ptr_and_size (&r, si->ptr, NULL_TREE);\n+\t    if (stmt_may_clobber_ref_p_1 (stmt, &r))\n+\t      {\n+\t\tset_strinfo (i, NULL);\n+\t\tfree_strinfo (si);\n+\t\tcontinue;\n+\t      }\n+\t  }\n+\tsi->dont_invalidate = false;\n+\tnonempty = true;\n+      }\n+  return nonempty;\n+}\n+\n+/* Unshare strinfo record SI, if it has recount > 1 or\n+   if stridx_to_strinfo vector is shared with some other\n+   bbs.  */\n+\n+static strinfo\n+unshare_strinfo (strinfo si)\n+{\n+  strinfo nsi;\n+\n+  if (si->refcount == 1 && !strinfo_shared ())\n+    return si;\n+\n+  nsi = new_strinfo (si->ptr, si->idx, si->length);\n+  nsi->stmt = si->stmt;\n+  nsi->endptr = si->endptr;\n+  nsi->first = si->first;\n+  nsi->prev = si->prev;\n+  nsi->next = si->next;\n+  nsi->writable = si->writable;\n+  set_strinfo (si->idx, nsi);\n+  free_strinfo (si);\n+  return nsi;\n+}\n+\n+/* Return first strinfo in the related strinfo chain\n+   if all strinfos in between belong to the chain, otherwise\n+   NULL.  */\n+\n+static strinfo\n+verify_related_strinfos (strinfo origsi)\n+{\n+  strinfo si = origsi, psi;\n+\n+  if (origsi->first == 0)\n+    return NULL;\n+  for (; si->prev; si = psi)\n+    {\n+      if (si->first != origsi->first)\n+\treturn NULL;\n+      psi = get_strinfo (si->prev);\n+      if (psi == NULL)\n+\treturn NULL;\n+      if (psi->next != si->idx)\n+\treturn NULL;\n+    }\n+  if (si->idx != si->first)\n+    return NULL;\n+  return si;\n+}\n+\n+/* Note that PTR, a pointer SSA_NAME initialized in the current stmt, points\n+   to a zero-length string and if possible chain it to a related strinfo\n+   chain whose part is or might be CHAINSI.  */\n+\n+static strinfo\n+zero_length_string (tree ptr, strinfo chainsi)\n+{\n+  strinfo si;\n+  int idx;\n+  gcc_checking_assert (TREE_CODE (ptr) == SSA_NAME\n+\t\t       && get_stridx (ptr) == 0);\n+\n+  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr))\n+    return NULL;\n+  if (chainsi != NULL)\n+    {\n+      si = verify_related_strinfos (chainsi);\n+      if (si)\n+\t{\n+\t  chainsi = si;\n+\t  for (; chainsi->next; chainsi = si)\n+\t    {\n+\t      if (chainsi->endptr == NULL_TREE)\n+\t\t{\n+\t\t  chainsi = unshare_strinfo (chainsi);\n+\t\t  chainsi->endptr = ptr;\n+\t\t}\n+\t      si = get_strinfo (chainsi->next);\n+\t      if (si == NULL\n+\t\t  || si->first != chainsi->first\n+\t\t  || si->prev != chainsi->idx)\n+\t\tbreak;\n+\t    }\n+\t  gcc_assert (chainsi->length);\n+\t  if (chainsi->endptr == NULL_TREE)\n+\t    {\n+\t      chainsi = unshare_strinfo (chainsi);\n+\t      chainsi->endptr = ptr;\n+\t    }\n+\t  if (integer_zerop (chainsi->length))\n+\t    {\n+\t      if (chainsi->next)\n+\t\t{\n+\t\t  chainsi = unshare_strinfo (chainsi);\n+\t\t  chainsi->next = 0;\n+\t\t}\n+\t      VEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (ptr),\n+\t\t\t   chainsi->idx);\n+\t      return chainsi;\n+\t    }\n+\t}\n+      else if (chainsi->first || chainsi->prev || chainsi->next)\n+\t{\n+\t  chainsi = unshare_strinfo (chainsi);\n+\t  chainsi->first = 0;\n+\t  chainsi->prev = 0;\n+\t  chainsi->next = 0;\n+\t}\n+    }\n+  idx = new_stridx (ptr);\n+  if (idx == 0)\n+    return NULL;\n+  si = new_strinfo (ptr, idx, build_int_cst (size_type_node, 0));\n+  set_strinfo (idx, si);\n+  si->endptr = ptr;\n+  if (chainsi != NULL)\n+    {\n+      chainsi = unshare_strinfo (chainsi);\n+      if (chainsi->first == 0)\n+\tchainsi->first = chainsi->idx;\n+      chainsi->next = idx;\n+      si->prev = chainsi->idx;\n+      si->first = chainsi->first;\n+      si->writable = chainsi->writable;\n+    }\n+  return si;\n+}\n+\n+/* For strinfo ORIGSI whose length has been just updated\n+   update also related strinfo lengths (add ADJ to each,\n+   but don't adjust ORIGSI).  */\n+\n+static void\n+adjust_related_strinfos (location_t loc, strinfo origsi, tree adj)\n+{\n+  strinfo si = verify_related_strinfos (origsi);\n+\n+  if (si == NULL)\n+    return;\n+\n+  while (1)\n+    {\n+      strinfo nsi;\n+\n+      if (si != origsi)\n+\t{\n+\t  tree tem;\n+\n+\t  si = unshare_strinfo (si);\n+\t  gcc_assert (si->length);\n+\t  tem = fold_convert_loc (loc, TREE_TYPE (si->length), adj);\n+\t  si->length = fold_build2_loc (loc, PLUS_EXPR,\n+\t\t\t\t\tTREE_TYPE (si->length), si->length,\n+\t\t\t\t\ttem);\n+\t  si->endptr = NULL_TREE;\n+\t  si->dont_invalidate = true;\n+\t}\n+      if (si->next == 0)\n+\treturn;\n+      nsi = get_strinfo (si->next);\n+      if (nsi == NULL\n+\t  || nsi->first != si->first\n+\t  || nsi->prev != si->idx)\n+\treturn;\n+      si = nsi;\n+    }\n+}\n+\n+/* Find if there are other SSA_NAME pointers equal to PTR\n+   for which we don't track their string lengths yet.  If so, use\n+   IDX for them.  */\n+\n+static void\n+find_equal_ptrs (tree ptr, int idx)\n+{\n+  if (TREE_CODE (ptr) != SSA_NAME)\n+    return;\n+  while (1)\n+    {\n+      gimple stmt = SSA_NAME_DEF_STMT (ptr);\n+      if (!is_gimple_assign (stmt))\n+\treturn;\n+      ptr = gimple_assign_rhs1 (stmt);\n+      switch (gimple_assign_rhs_code (stmt))\n+\t{\n+\tcase SSA_NAME:\n+\t  break;\n+\tcase ADDR_EXPR:\n+\t  {\n+\t    int *pidx = addr_stridxptr (TREE_OPERAND (ptr, 0));\n+\t    if (pidx != NULL && *pidx == 0)\n+\t      *pidx = idx;\n+\t    return;\n+\t  }\n+\tCASE_CONVERT:\n+\t  if (POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\t    break;\n+\t  return;\n+\tdefault:\n+\t  return;\n+\t}\n+\n+      /* We might find an endptr created in this pass.  Grow the\n+\t vector in that case.  */\n+      if (VEC_length (int, ssa_ver_to_stridx) <= SSA_NAME_VERSION (ptr))\n+\tVEC_safe_grow_cleared (int, heap, ssa_ver_to_stridx, num_ssa_names);\n+\n+      if (VEC_index (int, ssa_ver_to_stridx, SSA_NAME_VERSION (ptr)) != 0)\n+\treturn;\n+      VEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (ptr), idx);\n+    }\n+}\n+\n+/* If the last .MEM setter statement before STMT is\n+   memcpy (x, y, strlen (y) + 1), the only .MEM use of it is STMT\n+   and STMT is known to overwrite x[strlen (x)], adjust the last memcpy to\n+   just memcpy (x, y, strlen (y)).  SI must be the zero length\n+   strinfo.  */\n+\n+static void\n+adjust_last_stmt (strinfo si, gimple stmt, bool is_strcat)\n+{\n+  tree vuse, callee, len;\n+  struct laststmt_struct last = laststmt;\n+  strinfo lastsi, firstsi;\n+\n+  laststmt.stmt = NULL;\n+  laststmt.len = NULL_TREE;\n+  laststmt.stridx = 0;\n+\n+  if (last.stmt == NULL)\n+    return;\n+\n+  vuse = gimple_vuse (stmt);\n+  if (vuse == NULL_TREE\n+      || SSA_NAME_DEF_STMT (vuse) != last.stmt\n+      || !has_single_use (vuse))\n+    return;\n+\n+  gcc_assert (last.stridx > 0);\n+  lastsi = get_strinfo (last.stridx);\n+  if (lastsi == NULL)\n+    return;\n+\n+  if (lastsi != si)\n+    {\n+      if (lastsi->first == 0 || lastsi->first != si->first)\n+\treturn;\n+\n+      firstsi = verify_related_strinfos (si);\n+      if (firstsi == NULL)\n+\treturn;\n+      while (firstsi != lastsi)\n+\t{\n+\t  strinfo nextsi;\n+\t  if (firstsi->next == 0)\n+\t    return;\n+\t  nextsi = get_strinfo (firstsi->next);\n+\t  if (nextsi == NULL\n+\t      || nextsi->prev != firstsi->idx\n+\t      || nextsi->first != si->first)\n+\t    return;\n+\t  firstsi = nextsi;\n+\t}\n+    }\n+\n+  if (!is_strcat)\n+    {\n+      if (si->length == NULL_TREE || !integer_zerop (si->length))\n+\treturn;\n+    }\n+\n+  if (is_gimple_assign (last.stmt))\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      if (!integer_zerop (gimple_assign_rhs1 (last.stmt)))\n+\treturn;\n+      if (stmt_could_throw_p (last.stmt))\n+\treturn;\n+      gsi = gsi_for_stmt (last.stmt);\n+      unlink_stmt_vdef (last.stmt);\n+      release_defs (last.stmt);\n+      gsi_remove (&gsi, true);\n+      return;\n+    }\n+\n+  if (!is_gimple_call (last.stmt))\n+    return;\n+  callee = gimple_call_fndecl (last.stmt);\n+  if (callee == NULL_TREE || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL)\n+    return;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+      break;\n+    default:\n+      return;\n+    }\n+\n+  len = gimple_call_arg (last.stmt, 2);\n+  if (host_integerp (len, 1))\n+    {\n+      if (!host_integerp (last.len, 1)\n+\t  || integer_zerop (len)\n+\t  || (unsigned HOST_WIDE_INT) tree_low_cst (len, 1)\n+\t     != (unsigned HOST_WIDE_INT) tree_low_cst (last.len, 1) + 1)\n+\treturn;\n+      /* Don't adjust the length if it is divisible by 4, it is more efficient\n+\t to store the extra '\\0' in that case.  */\n+      if ((((unsigned HOST_WIDE_INT) tree_low_cst (len, 1)) & 3) == 0)\n+\treturn;\n+    }\n+  else if (TREE_CODE (len) == SSA_NAME)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (len);\n+      if (!is_gimple_assign (def_stmt)\n+\t  || gimple_assign_rhs_code (def_stmt) != PLUS_EXPR\n+\t  || gimple_assign_rhs1 (def_stmt) != last.len\n+\t  || !integer_onep (gimple_assign_rhs2 (def_stmt)))\n+\treturn;\n+    }\n+  else\n+    return;\n+\n+  gimple_call_set_arg (last.stmt, 2, last.len);\n+  update_stmt (last.stmt);\n+}\n+\n+/* Handle a strlen call.  If strlen of the argument is known, replace\n+   the strlen call with the known value, otherwise remember that strlen\n+   of the argument is stored in the lhs SSA_NAME.  */\n+\n+static void\n+handle_builtin_strlen (gimple_stmt_iterator *gsi)\n+{\n+  int idx;\n+  tree src;\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_call_lhs (stmt);\n+\n+  if (lhs == NULL_TREE)\n+    return;\n+\n+  src = gimple_call_arg (stmt, 0);\n+  idx = get_stridx (src);\n+  if (idx)\n+    {\n+      strinfo si = NULL;\n+      tree rhs;\n+\n+      if (idx < 0)\n+\trhs = build_int_cst (TREE_TYPE (lhs), ~idx);\n+      else\n+\t{\n+\t  rhs = NULL_TREE;\n+\t  si = get_strinfo (idx);\n+\t  if (si != NULL)\n+\t    rhs = get_string_length (si);\n+\t}\n+      if (rhs != NULL_TREE)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t    {\n+\t      fprintf (dump_file, \"Optimizing: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t  rhs = unshare_expr (rhs);\n+\t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+\t    rhs = fold_convert_loc (gimple_location (stmt),\n+\t\t\t\t    TREE_TYPE (lhs), rhs);\n+\t  if (!update_call_from_tree (gsi, rhs))\n+\t    gimplify_and_update_call_from_tree (gsi, rhs);\n+\t  stmt = gsi_stmt (*gsi);\n+\t  update_stmt (stmt);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t    {\n+\t      fprintf (dump_file, \"into: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t  if (si != NULL\n+\t      && TREE_CODE (si->length) != SSA_NAME\n+\t      && TREE_CODE (si->length) != INTEGER_CST\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+\t    {\n+\t      si = unshare_strinfo (si);\n+\t      si->length = lhs;\n+\t    }\n+\t  return;\n+\t}\n+    }\n+  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+    return;\n+  if (idx == 0)\n+    idx = new_stridx (src);\n+  else if (get_strinfo (idx) != NULL)\n+    return;\n+  if (idx)\n+    {\n+      strinfo si = new_strinfo (src, idx, lhs);\n+      set_strinfo (idx, si);\n+      find_equal_ptrs (src, idx);\n+    }\n+}\n+\n+/* Handle a strchr call.  If strlen of the first argument is known, replace\n+   the strchr (x, 0) call with the endptr or x + strlen, otherwise remember\n+   that lhs of the call is endptr and strlen of the argument is endptr - x.  */\n+\n+static void\n+handle_builtin_strchr (gimple_stmt_iterator *gsi)\n+{\n+  int idx;\n+  tree src;\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_call_lhs (stmt);\n+\n+  if (lhs == NULL_TREE)\n+    return;\n+\n+  if (!integer_zerop (gimple_call_arg (stmt, 1)))\n+    return;\n+\n+  src = gimple_call_arg (stmt, 0);\n+  idx = get_stridx (src);\n+  if (idx)\n+    {\n+      strinfo si = NULL;\n+      tree rhs;\n+\n+      if (idx < 0)\n+\trhs = build_int_cst (size_type_node, ~idx);\n+      else\n+\t{\n+\t  rhs = NULL_TREE;\n+\t  si = get_strinfo (idx);\n+\t  if (si != NULL)\n+\t    rhs = get_string_length (si);\n+\t}\n+      if (rhs != NULL_TREE)\n+\t{\n+\t  location_t loc = gimple_location (stmt);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t    {\n+\t      fprintf (dump_file, \"Optimizing: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t  if (si != NULL && si->endptr != NULL_TREE)\n+\t    {\n+\t      rhs = unshare_expr (si->endptr);\n+\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t      TREE_TYPE (rhs)))\n+\t\trhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n+\t    }\n+\t  else\n+\t    {\n+\t      rhs = fold_convert_loc (loc, sizetype, unshare_expr (rhs));\n+\t      rhs = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n+\t\t\t\t     TREE_TYPE (src), src, rhs);\n+\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t      TREE_TYPE (rhs)))\n+\t\trhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n+\t    }\n+\t  if (!update_call_from_tree (gsi, rhs))\n+\t    gimplify_and_update_call_from_tree (gsi, rhs);\n+\t  stmt = gsi_stmt (*gsi);\n+\t  update_stmt (stmt);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t    {\n+\t      fprintf (dump_file, \"into: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    }\n+\t  if (si != NULL\n+\t      && si->endptr == NULL_TREE\n+\t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+\t    {\n+\t      si = unshare_strinfo (si);\n+\t      si->endptr = lhs;\n+\t    }\n+\t  zero_length_string (lhs, si);\n+\t  return;\n+\t}\n+    }\n+  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+    return;\n+  if (TREE_CODE (src) != SSA_NAME || !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (src))\n+    {\n+      if (idx == 0)\n+\tidx = new_stridx (src);\n+      else if (get_strinfo (idx) != NULL)\n+\t{\n+\t  zero_length_string (lhs, NULL);\n+\t  return;\n+\t}\n+      if (idx)\n+\t{\n+\t  location_t loc = gimple_location (stmt);\n+\t  tree lhsu = fold_convert_loc (loc, size_type_node, lhs);\n+\t  tree srcu = fold_convert_loc (loc, size_type_node, src);\n+\t  tree length = fold_build2_loc (loc, MINUS_EXPR,\n+\t\t\t\t\t size_type_node, lhsu, srcu);\n+\t  strinfo si = new_strinfo (src, idx, length);\n+\t  si->endptr = lhs;\n+\t  set_strinfo (idx, si);\n+\t  find_equal_ptrs (src, idx);\n+\t  zero_length_string (lhs, si);\n+\t}\n+    }\n+  else\n+    zero_length_string (lhs, NULL);\n+}\n+\n+/* Handle a strcpy-like ({st{r,p}cpy,__st{r,p}cpy_chk}) call.\n+   If strlen of the second argument is known, strlen of the first argument\n+   is the same after this call.  Furthermore, attempt to convert it to\n+   memcpy.  */\n+\n+static void\n+handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+{\n+  int idx, didx;\n+  tree src, dst, srclen, len, lhs, args, type, fn, oldlen;\n+  bool success;\n+  gimple stmt = gsi_stmt (*gsi);\n+  strinfo si, dsi, olddsi, zsi;\n+  location_t loc;\n+\n+  src = gimple_call_arg (stmt, 1);\n+  dst = gimple_call_arg (stmt, 0);\n+  lhs = gimple_call_lhs (stmt);\n+  idx = get_stridx (src);\n+  si = NULL;\n+  if (idx > 0)\n+    si = get_strinfo (idx);\n+\n+  didx = get_stridx (dst);\n+  olddsi = NULL;\n+  oldlen = NULL_TREE;\n+  if (didx > 0)\n+    olddsi = get_strinfo (didx);\n+  else if (didx < 0)\n+    return;\n+\n+  if (olddsi != NULL)\n+    adjust_last_stmt (olddsi, stmt, false);\n+\n+  srclen = NULL_TREE;\n+  if (si != NULL)\n+    srclen = get_string_length (si);\n+  else if (idx < 0)\n+    srclen = build_int_cst (size_type_node, ~idx);\n+\n+  loc = gimple_location (stmt);\n+  if (srclen == NULL_TREE)\n+    switch (bcode)\n+      {\n+      case BUILT_IN_STRCPY:\n+      case BUILT_IN_STRCPY_CHK:\n+\tif (implicit_built_in_decls[BUILT_IN_STPCPY] == NULL_TREE\n+\t    || lhs != NULL_TREE)\n+\t  return;\n+\tbreak;\n+      case BUILT_IN_STPCPY:\n+      case BUILT_IN_STPCPY_CHK:\n+\tif (lhs == NULL_TREE)\n+\t  return;\n+\telse\n+\t  {\n+\t    tree lhsuint = fold_convert_loc (loc, size_type_node, lhs);\n+\t    srclen = fold_convert_loc (loc, size_type_node, dst);\n+\t    srclen = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n+\t\t\t\t      lhsuint, srclen);\n+\t  }\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  if (didx == 0)\n+    {\n+      didx = new_stridx (dst);\n+      if (didx == 0)\n+\treturn;\n+    }\n+  if (olddsi != NULL)\n+    {\n+      oldlen = olddsi->length;\n+      dsi = unshare_strinfo (olddsi);\n+      dsi->length = srclen;\n+      /* Break the chain, so adjust_related_strinfo on later pointers in\n+\t the chain won't adjust this one anymore.  */\n+      dsi->next = 0;\n+      dsi->stmt = NULL;\n+      dsi->endptr = NULL_TREE;\n+    }\n+  else\n+    {\n+      dsi = new_strinfo (dst, didx, srclen);\n+      set_strinfo (didx, dsi);\n+      find_equal_ptrs (dst, didx);\n+    }\n+  dsi->writable = true;\n+  dsi->dont_invalidate = true;\n+\n+  if (dsi->length == NULL_TREE)\n+    {\n+      /* If string length of src is unknown, use delayed length\n+\t computation.  If string lenth of dst will be needed, it\n+\t can be computed by transforming this strcpy call into\n+\t stpcpy and subtracting dst from the return value.  */\n+      dsi->stmt = stmt;\n+      return;\n+    }\n+\n+  if (olddsi != NULL)\n+    {\n+      tree adj = NULL_TREE;\n+      if (oldlen == NULL_TREE)\n+\t;\n+      else if (integer_zerop (oldlen))\n+\tadj = srclen;\n+      else if (TREE_CODE (oldlen) == INTEGER_CST\n+\t       || TREE_CODE (srclen) == INTEGER_CST)\n+\tadj = fold_build2_loc (loc, MINUS_EXPR,\n+\t\t\t       TREE_TYPE (srclen), srclen,\n+\t\t\t       fold_convert_loc (loc, TREE_TYPE (srclen),\n+\t\t\t\t\t\t oldlen));\n+      if (adj != NULL_TREE)\n+\tadjust_related_strinfos (loc, dsi, adj);\n+      else\n+\tdsi->prev = 0;\n+    }\n+  /* strcpy src may not overlap dst, so src doesn't need to be\n+     invalidated either.  */\n+  if (si != NULL)\n+    si->dont_invalidate = true;\n+\n+  fn = NULL_TREE;\n+  zsi = NULL;\n+  switch (bcode)\n+    {\n+    case BUILT_IN_STRCPY:\n+      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+      if (lhs)\n+\tVEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs), didx);\n+      break;\n+    case BUILT_IN_STRCPY_CHK:\n+      fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+      if (lhs)\n+\tVEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs), didx);\n+      break;\n+    case BUILT_IN_STPCPY:\n+      /* This would need adjustment of the lhs (subtract one),\n+\t or detection that the trailing '\\0' doesn't need to be\n+\t written, if it will be immediately overwritten.\n+      fn = built_in_decls[BUILT_IN_MEMPCPY];  */\n+      if (lhs)\n+\t{\n+\t  dsi->endptr = lhs;\n+\t  zsi = zero_length_string (lhs, dsi);\n+\t}\n+      break;\n+    case BUILT_IN_STPCPY_CHK:\n+      /* This would need adjustment of the lhs (subtract one),\n+\t or detection that the trailing '\\0' doesn't need to be\n+\t written, if it will be immediately overwritten.\n+      fn = built_in_decls[BUILT_IN_MEMPCPY_CHK];  */\n+      if (lhs)\n+\t{\n+\t  dsi->endptr = lhs;\n+\t  zsi = zero_length_string (lhs, dsi);\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (zsi != NULL)\n+    zsi->dont_invalidate = true;\n+\n+  if (fn == NULL_TREE)\n+    return;\n+\n+  args = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  type = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+\n+  len = fold_convert_loc (loc, type, unshare_expr (srclen));\n+  len = fold_build2_loc (loc, PLUS_EXPR, type, len, build_int_cst (type, 1));\n+  len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE, true,\n+\t\t\t\t  GSI_SAME_STMT);\n+  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+    {\n+      fprintf (dump_file, \"Optimizing: \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+    }\n+  if (gimple_call_num_args (stmt) == 2)\n+    success = update_gimple_call (gsi, fn, 3, dst, src, len);\n+  else\n+    success = update_gimple_call (gsi, fn, 4, dst, src, len,\n+\t\t\t\t  gimple_call_arg (stmt, 2));\n+  if (success)\n+    {\n+      stmt = gsi_stmt (*gsi);\n+      update_stmt (stmt);\n+      if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t{\n+\t  fprintf (dump_file, \"into: \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      /* Allow adjust_last_stmt to decrease this memcpy's size.  */\n+      laststmt.stmt = stmt;\n+      laststmt.len = srclen;\n+      laststmt.stridx = dsi->idx;\n+    }\n+  else if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+    fprintf (dump_file, \"not possible.\\n\");\n+}\n+\n+/* Handle a memcpy-like ({mem{,p}cpy,__mem{,p}cpy_chk}) call.\n+   If strlen of the second argument is known and length of the third argument\n+   is that plus one, strlen of the first argument is the same after this\n+   call.  */\n+\n+static void\n+handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+{\n+  int idx, didx;\n+  tree src, dst, len, lhs, oldlen, newlen;\n+  gimple stmt = gsi_stmt (*gsi);\n+  strinfo si, dsi, olddsi;\n+\n+  len = gimple_call_arg (stmt, 2);\n+  src = gimple_call_arg (stmt, 1);\n+  dst = gimple_call_arg (stmt, 0);\n+  idx = get_stridx (src);\n+  if (idx == 0)\n+    return;\n+\n+  didx = get_stridx (dst);\n+  olddsi = NULL;\n+  if (didx > 0)\n+    olddsi = get_strinfo (didx);\n+  else if (didx < 0)\n+    return;\n+\n+  if (olddsi != NULL\n+      && host_integerp (len, 1)\n+      && !integer_zerop (len))\n+    adjust_last_stmt (olddsi, stmt, false);\n+\n+  if (idx > 0)\n+    {\n+      gimple def_stmt;\n+\n+      /* Handle memcpy (x, y, l) where l is strlen (y) + 1.  */\n+      si = get_strinfo (idx);\n+      if (si == NULL || si->length == NULL_TREE)\n+\treturn;\n+      if (TREE_CODE (len) != SSA_NAME)\n+\treturn;\n+      def_stmt = SSA_NAME_DEF_STMT (len);\n+      if (!is_gimple_assign (def_stmt)\n+\t  || gimple_assign_rhs_code (def_stmt) != PLUS_EXPR\n+\t  || gimple_assign_rhs1 (def_stmt) != si->length\n+\t  || !integer_onep (gimple_assign_rhs2 (def_stmt)))\n+\treturn;\n+    }\n+  else\n+    {\n+      si = NULL;\n+      /* Handle memcpy (x, \"abcd\", 5) or\n+\t memcpy (x, \"abc\\0uvw\", 7).  */\n+      if (!host_integerp (len, 1)\n+\t  || (unsigned HOST_WIDE_INT) tree_low_cst (len, 1)\n+\t     <= (unsigned HOST_WIDE_INT) ~idx)\n+\treturn;\n+    }\n+\n+  if (olddsi != NULL && TREE_CODE (len) == SSA_NAME)\n+    adjust_last_stmt (olddsi, stmt, false);\n+\n+  if (didx == 0)\n+    {\n+      didx = new_stridx (dst);\n+      if (didx == 0)\n+\treturn;\n+    }\n+  if (si != NULL)\n+    newlen = si->length;\n+  else\n+    newlen = build_int_cst (TREE_TYPE (len), ~idx);\n+  oldlen = NULL_TREE;\n+  if (olddsi != NULL)\n+    {\n+      dsi = unshare_strinfo (olddsi);\n+      oldlen = olddsi->length;\n+      dsi->length = newlen;\n+      /* Break the chain, so adjust_related_strinfo on later pointers in\n+\t the chain won't adjust this one anymore.  */\n+      dsi->next = 0;\n+      dsi->stmt = NULL;\n+      dsi->endptr = NULL_TREE;\n+    }\n+  else\n+    {\n+      dsi = new_strinfo (dst, didx, newlen);\n+      set_strinfo (didx, dsi);\n+      find_equal_ptrs (dst, didx);\n+    }\n+  dsi->writable = true;\n+  dsi->dont_invalidate = true;\n+  if (olddsi != NULL)\n+    {\n+      tree adj = NULL_TREE;\n+      location_t loc = gimple_location (stmt);\n+      if (oldlen == NULL_TREE)\n+\t;\n+      else if (integer_zerop (oldlen))\n+\tadj = dsi->length;\n+      else if (TREE_CODE (oldlen) == INTEGER_CST\n+\t       || TREE_CODE (dsi->length) == INTEGER_CST)\n+\tadj = fold_build2_loc (loc, MINUS_EXPR,\n+\t\t\t       TREE_TYPE (dsi->length), dsi->length,\n+\t\t\t       fold_convert_loc (loc, TREE_TYPE (dsi->length),\n+\t\t\t\t\t\t oldlen));\n+      if (adj != NULL_TREE)\n+\tadjust_related_strinfos (loc, dsi, adj);\n+      else\n+\tdsi->prev = 0;\n+    }\n+  /* memcpy src may not overlap dst, so src doesn't need to be\n+     invalidated either.  */\n+  if (si != NULL)\n+    si->dont_invalidate = true;\n+\n+  lhs = gimple_call_lhs (stmt);\n+  switch (bcode)\n+    {\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+      /* Allow adjust_last_stmt to decrease this memcpy's size.  */\n+      laststmt.stmt = stmt;\n+      laststmt.len = dsi->length;\n+      laststmt.stridx = dsi->idx;\n+      if (lhs)\n+\tVEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs), didx);\n+      break;\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Handle a strcat-like ({strcat,__strcat_chk}) call.\n+   If strlen of the second argument is known, strlen of the first argument\n+   is increased by the length of the second argument.  Furthermore, attempt\n+   to convert it to memcpy/strcpy if the length of the first argument\n+   is known.  */\n+\n+static void\n+handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+{\n+  int idx, didx;\n+  tree src, dst, srclen, dstlen, len, lhs, args, type, fn, objsz, endptr;\n+  bool success;\n+  gimple stmt = gsi_stmt (*gsi);\n+  strinfo si, dsi;\n+  location_t loc;\n+\n+  src = gimple_call_arg (stmt, 1);\n+  dst = gimple_call_arg (stmt, 0);\n+  lhs = gimple_call_lhs (stmt);\n+\n+  didx = get_stridx (dst);\n+  if (didx < 0)\n+    return;\n+\n+  dsi = NULL;\n+  if (didx > 0)\n+    dsi = get_strinfo (didx);\n+  if (dsi == NULL || get_string_length (dsi) == NULL_TREE)\n+    {\n+      /* strcat (p, q) can be transformed into\n+\t tmp = p + strlen (p); endptr = strpcpy (tmp, q);\n+\t with length endptr - p if we need to compute the length\n+\t later on.  Don't do this transformation if we don't need\n+\t it.  */\n+      if (implicit_built_in_decls[BUILT_IN_STPCPY] != NULL_TREE\n+\t  && lhs == NULL_TREE)\n+\t{\n+\t  if (didx == 0)\n+\t    {\n+\t      didx = new_stridx (dst);\n+\t      if (didx == 0)\n+\t\treturn;\n+\t    }\n+\t  if (dsi == NULL)\n+\t    {\n+\t      dsi = new_strinfo (dst, didx, NULL_TREE);\n+\t      set_strinfo (didx, dsi);\n+\t      find_equal_ptrs (dst, didx);\n+\t    }\n+\t  else\n+\t    {\n+\t      dsi = unshare_strinfo (dsi);\n+\t      dsi->length = NULL_TREE;\n+\t      dsi->next = 0;\n+\t      dsi->endptr = NULL_TREE;\n+\t    }\n+\t  dsi->writable = true;\n+\t  dsi->stmt = stmt;\n+\t  dsi->dont_invalidate = true;\n+\t}\n+      return;\n+    }\n+\n+  srclen = NULL_TREE;\n+  si = NULL;\n+  idx = get_stridx (src);\n+  if (idx < 0)\n+    srclen = build_int_cst (size_type_node, ~idx);\n+  else if (idx > 0)\n+    {\n+      si = get_strinfo (idx);\n+      if (si != NULL)\n+\tsrclen = get_string_length (si);\n+    }\n+\n+  loc = gimple_location (stmt);\n+  dstlen = dsi->length;\n+  endptr = dsi->endptr;\n+\n+  dsi = unshare_strinfo (dsi);\n+  dsi->endptr = NULL_TREE;\n+  dsi->stmt = NULL;\n+  dsi->writable = true;\n+\n+  if (srclen != NULL_TREE)\n+    {\n+      dsi->length = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (dsi->length),\n+\t\t\t\t     dsi->length, srclen);\n+      adjust_related_strinfos (loc, dsi, srclen);\n+      dsi->dont_invalidate = true;\n+    }\n+  else\n+    {\n+      dsi->length = NULL;\n+      if (implicit_built_in_decls[BUILT_IN_STPCPY] != NULL_TREE\n+\t  && lhs == NULL_TREE)\n+\tdsi->dont_invalidate = true;\n+    }\n+\n+  if (si != NULL)\n+    /* strcat src may not overlap dst, so src doesn't need to be\n+       invalidated either.  */\n+    si->dont_invalidate = true;\n+\n+  /* For now.  Could remove the lhs from the call and add\n+     lhs = dst; afterwards.  */\n+  if (lhs)\n+    return;\n+\n+  fn = NULL_TREE;\n+  objsz = NULL_TREE;\n+  switch (bcode)\n+    {\n+    case BUILT_IN_STRCAT:\n+      if (srclen != NULL_TREE)\n+\tfn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+      else\n+\tfn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+      break;\n+    case BUILT_IN_STRCAT_CHK:\n+      if (srclen != NULL_TREE)\n+\tfn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+      else\n+\tfn = built_in_decls[BUILT_IN_STRCPY_CHK];\n+      objsz = gimple_call_arg (stmt, 2);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (fn == NULL_TREE)\n+    return;\n+\n+  len = NULL_TREE;\n+  if (srclen != NULL_TREE)\n+    {\n+      args = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      type = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+\n+      len = fold_convert_loc (loc, type, unshare_expr (srclen));\n+      len = fold_build2_loc (loc, PLUS_EXPR, type, len,\n+\t\t\t     build_int_cst (type, 1));\n+      len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE, true,\n+\t\t\t\t      GSI_SAME_STMT);\n+    }\n+  if (endptr)\n+    dst = fold_convert_loc (loc, TREE_TYPE (dst), unshare_expr (endptr));\n+  else\n+    dst = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n+\t\t\t   TREE_TYPE (dst), unshare_expr (dst),\n+\t\t\t   fold_convert_loc (loc, sizetype,\n+\t\t\t\t\t     unshare_expr (dstlen)));\n+  dst = force_gimple_operand_gsi (gsi, dst, true, NULL_TREE, true,\n+\t\t\t\t  GSI_SAME_STMT);\n+  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+    {\n+      fprintf (dump_file, \"Optimizing: \");\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+    }\n+  if (srclen != NULL_TREE)\n+    success = update_gimple_call (gsi, fn, 3 + (objsz != NULL_TREE),\n+\t\t\t\t  dst, src, len, objsz);\n+  else\n+    success = update_gimple_call (gsi, fn, 2 + (objsz != NULL_TREE),\n+\t\t\t\t  dst, src, objsz);\n+  if (success)\n+    {\n+      stmt = gsi_stmt (*gsi);\n+      update_stmt (stmt);\n+      if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+\t{\n+\t  fprintf (dump_file, \"into: \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      /* If srclen == NULL, note that current string length can be\n+\t computed by transforming this strcpy into stpcpy.  */\n+      if (srclen == NULL_TREE && dsi->dont_invalidate)\n+\tdsi->stmt = stmt;\n+      adjust_last_stmt (dsi, stmt, true);\n+      if (srclen != NULL_TREE)\n+\t{\n+\t  laststmt.stmt = stmt;\n+\t  laststmt.len = srclen;\n+\t  laststmt.stridx = dsi->idx;\n+\t}\n+    }\n+  else if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n+    fprintf (dump_file, \"not possible.\\n\");\n+}\n+\n+/* Handle a POINTER_PLUS_EXPR statement.\n+   For p = \"abcd\" + 2; compute associated length, or if\n+   p = q + off is pointing to a '\\0' character of a string, call\n+   zero_length_string on it.  */\n+\n+static void\n+handle_pointer_plus (gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_assign_lhs (stmt), off;\n+  int idx = get_stridx (gimple_assign_rhs1 (stmt));\n+  strinfo si, zsi;\n+\n+  if (idx == 0)\n+    return;\n+\n+  if (idx < 0)\n+    {\n+      tree off = gimple_assign_rhs2 (stmt);\n+      if (host_integerp (off, 1)\n+\t  && (unsigned HOST_WIDE_INT) tree_low_cst (off, 1)\n+\t     <= (unsigned HOST_WIDE_INT) ~idx)\n+\tVEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs),\n+\t\t     ~(~idx - (int) tree_low_cst (off, 1)));\n+      return;\n+    }\n+\n+  si = get_strinfo (idx);\n+  if (si == NULL || si->length == NULL_TREE)\n+    return;\n+\n+  off = gimple_assign_rhs2 (stmt);\n+  zsi = NULL;\n+  if (operand_equal_p (si->length, off, 0))\n+    zsi = zero_length_string (lhs, si);\n+  else if (TREE_CODE (off) == SSA_NAME)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (off);\n+      if (gimple_assign_single_p (def_stmt)\n+\t  && operand_equal_p (si->length, gimple_assign_rhs1 (def_stmt), 0))\n+\tzsi = zero_length_string (lhs, si);\n+    }\n+  if (zsi != NULL\n+      && si->endptr != NULL_TREE\n+      && si->endptr != lhs\n+      && TREE_CODE (si->endptr) == SSA_NAME)\n+    {\n+      enum tree_code rhs_code\n+\t= useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (si->endptr))\n+\t  ? SSA_NAME : NOP_EXPR;\n+      gimple_assign_set_rhs_with_ops (gsi, rhs_code, si->endptr, NULL_TREE);\n+      gcc_assert (gsi_stmt (*gsi) == stmt);\n+      update_stmt (stmt);\n+    }\n+}\n+\n+/* Handle a single character store.  */\n+\n+static bool\n+handle_char_store (gimple_stmt_iterator *gsi)\n+{\n+  int idx = -1;\n+  strinfo si = NULL;\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree ssaname = NULL_TREE, lhs = gimple_assign_lhs (stmt);\n+\n+  if (TREE_CODE (lhs) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME)\n+    {\n+      if (integer_zerop (TREE_OPERAND (lhs, 1)))\n+\t{\n+\t  ssaname = TREE_OPERAND (lhs, 0);\n+\t  idx = get_stridx (ssaname);\n+\t}\n+    }\n+  else\n+    idx = get_addr_stridx (lhs);\n+\n+  if (idx > 0)\n+    {\n+      si = get_strinfo (idx);\n+      if (si != NULL && si->length != NULL_TREE && integer_zerop (si->length))\n+\t{\n+\t  if (initializer_zerop (gimple_assign_rhs1 (stmt)))\n+\t    {\n+\t      /* When storing '\\0', the store can be removed\n+\t\t if we know it has been stored in the current function.  */\n+\t      if (!stmt_could_throw_p (stmt) && si->writable)\n+\t\t{\n+\t\t  unlink_stmt_vdef (stmt);\n+\t\t  release_defs (stmt);\n+\t\t  gsi_remove (gsi, true);\n+\t\t  return false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  si->writable = true;\n+\t\t  si->dont_invalidate = true;\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* Otherwise this statement overwrites the '\\0' with\n+\t       something, if the previous stmt was a memcpy,\n+\t       its length may be decreased.  */\n+\t    adjust_last_stmt (si, stmt, false);\n+\t}\n+      else if (si != NULL)\n+\t{\n+\t  si = unshare_strinfo (si);\n+\t  si->length = build_int_cst (size_type_node, 0);\n+\t  si->endptr = NULL;\n+\t  si->prev = 0;\n+\t  si->next = 0;\n+\t  si->stmt = NULL;\n+\t  si->first = 0;\n+\t  si->writable = true;\n+\t  if (ssaname && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n+\t    si->endptr = ssaname;\n+\t  si->dont_invalidate = true;\n+\t}\n+    }\n+  else if (idx == 0 && initializer_zerop (gimple_assign_rhs1 (stmt)))\n+    {\n+      if (ssaname)\n+\t{\n+\t  si = zero_length_string (ssaname, NULL);\n+\t  if (si != NULL)\n+\t    si->dont_invalidate = true;\n+\t}\n+      else\n+\t{\n+\t  int idx = new_addr_stridx (lhs);\n+\t  if (idx != 0)\n+\t    {\n+\t      si = new_strinfo (build_fold_addr_expr (lhs), idx,\n+\t\t\t\tbuild_int_cst (size_type_node, 0));\n+\t      set_strinfo (idx, si);\n+\t      si->dont_invalidate = true;\n+\t    }\n+\t}\n+      if (si != NULL)\n+\tsi->writable = true;\n+    }\n+\n+  if (si != NULL && initializer_zerop (gimple_assign_rhs1 (stmt)))\n+    {\n+      /* Allow adjust_last_stmt to remove it if the stored '\\0'\n+\t is immediately overwritten.  */\n+      laststmt.stmt = stmt;\n+      laststmt.len = build_int_cst (size_type_node, 1);\n+      laststmt.stridx = si->idx;\n+    }\n+  return true;\n+}\n+\n+/* Attempt to optimize a single statement at *GSI using string length\n+   knowledge.  */\n+\n+static bool\n+strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+\n+  if (is_gimple_call (stmt))\n+    {\n+      tree callee = gimple_call_fndecl (stmt);\n+      if (callee && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+\tswitch (DECL_FUNCTION_CODE (callee))\n+\t  {\n+\t  case BUILT_IN_STRLEN:\n+\t    handle_builtin_strlen (gsi);\n+\t    break;\n+\t  case BUILT_IN_STRCHR:\n+\t    handle_builtin_strchr (gsi);\n+\t    break;\n+\t  case BUILT_IN_STRCPY:\n+\t  case BUILT_IN_STRCPY_CHK:\n+\t  case BUILT_IN_STPCPY:\n+\t  case BUILT_IN_STPCPY_CHK:\n+\t    handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi);\n+\t    break;\n+\t  case BUILT_IN_MEMCPY:\n+\t  case BUILT_IN_MEMCPY_CHK:\n+\t  case BUILT_IN_MEMPCPY:\n+\t  case BUILT_IN_MEMPCPY_CHK:\n+\t    handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi);\n+\t    break;\n+\t  case BUILT_IN_STRCAT:\n+\t  case BUILT_IN_STRCAT_CHK:\n+\t    handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi);\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+    }\n+  else if (is_gimple_assign (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (stmt);\n+\n+      if (TREE_CODE (lhs) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t{\n+\t  if (gimple_assign_single_p (stmt)\n+\t      || (gimple_assign_cast_p (stmt)\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt)))))\n+\t    {\n+\t      int idx = get_stridx (gimple_assign_rhs1 (stmt));\n+\t      VEC_replace (int, ssa_ver_to_stridx, SSA_NAME_VERSION (lhs),\n+\t\t\t   idx);\n+\t    }\n+\t  else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+\t    handle_pointer_plus (gsi);\n+\t}\n+      else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n+\t{\n+\t  tree type = TREE_TYPE (lhs);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    type = TREE_TYPE (type);\n+\t  if (TREE_CODE (type) == INTEGER_TYPE\n+\t      && TYPE_MODE (type) == TYPE_MODE (char_type_node)\n+\t      && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node))\n+\t    {\n+\t      if (! handle_char_store (gsi))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  if (gimple_vdef (stmt))\n+    maybe_invalidate (stmt);\n+  return true;\n+}\n+\n+/* Recursively call maybe_invalidate on stmts that might be executed\n+   in between dombb and current bb and that contain a vdef.  Stop when\n+   *count stmts are inspected, or if the whole strinfo vector has\n+   been invalidated.  */\n+\n+static void\n+do_invalidate (basic_block dombb, gimple phi, bitmap visited, int *count)\n+{\n+  unsigned int i, n = gimple_phi_num_args (phi);\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      tree vuse = gimple_phi_arg_def (phi, i);\n+      gimple stmt = SSA_NAME_DEF_STMT (vuse);\n+      basic_block bb = gimple_bb (stmt);\n+      if (bb == NULL\n+\t  || bb == dombb\n+\t  || !bitmap_set_bit (visited, bb->index)\n+\t  || !dominated_by_p (CDI_DOMINATORS, bb, dombb))\n+\tcontinue;\n+      while (1)\n+\t{\n+\t  if (gimple_code (stmt) == GIMPLE_PHI)\n+\t    {\n+\t      do_invalidate (dombb, stmt, visited, count);\n+\t      if (*count == 0)\n+\t\treturn;\n+\t      break;\n+\t    }\n+\t  if (--*count == 0)\n+\t    return;\n+\t  if (!maybe_invalidate (stmt))\n+\t    {\n+\t      *count = 0;\n+\t      return;\n+\t    }\n+\t  vuse = gimple_vuse (stmt);\n+\t  stmt = SSA_NAME_DEF_STMT (vuse);\n+\t  if (gimple_bb (stmt) != bb)\n+\t    {\n+\t      bb = gimple_bb (stmt);\n+\t      if (bb == NULL\n+\t\t  || bb == dombb\n+\t\t  || !bitmap_set_bit (visited, bb->index)\n+\t\t  || !dominated_by_p (CDI_DOMINATORS, bb, dombb))\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Callback for walk_dominator_tree.  Attempt to optimize various\n+   string ops by remembering string lenths pointed by pointer SSA_NAMEs.  */\n+\n+static void\n+strlen_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t    basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\n+  if (dombb == NULL)\n+    stridx_to_strinfo = NULL;\n+  else\n+    {\n+      stridx_to_strinfo = (VEC(strinfo, heap) *) dombb->aux;\n+      if (stridx_to_strinfo)\n+\t{\n+\t  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple phi = gsi_stmt (gsi);\n+\t      if (!is_gimple_reg (gimple_phi_result (phi)))\n+\t\t{\n+\t\t  bitmap visited = BITMAP_ALLOC (NULL);\n+\t\t  int count_vdef = 100;\n+\t\t  do_invalidate (dombb, phi, visited, &count_vdef);\n+\t\t  BITMAP_FREE (visited);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* If all PHI arguments have the same string index, the PHI result\n+     has it as well.  */\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      tree result = gimple_phi_result (phi);\n+      if (is_gimple_reg (result) && POINTER_TYPE_P (TREE_TYPE (result)))\n+\t{\n+\t  int idx = get_stridx (gimple_phi_arg_def (phi, 0));\n+\t  if (idx != 0)\n+\t    {\n+\t      unsigned int i, n = gimple_phi_num_args (phi);\n+\t      for (i = 1; i < n; i++)\n+\t\tif (idx != get_stridx (gimple_phi_arg_def (phi, i)))\n+\t\t  break;\n+\t      if (i == n)\n+\t\tVEC_replace (int, ssa_ver_to_stridx,\n+\t\t\t     SSA_NAME_VERSION (result), idx);\n+\t    }\n+\t}\n+    }\n+\n+  /* Attempt to optimize individual statements.  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+    if (strlen_optimize_stmt (&gsi))\n+      gsi_next (&gsi);\n+\n+  bb->aux = stridx_to_strinfo;\n+  if (VEC_length (strinfo, stridx_to_strinfo) && !strinfo_shared ())\n+    VEC_replace (strinfo, stridx_to_strinfo, 0, (strinfo) bb);\n+}\n+\n+/* Callback for walk_dominator_tree.  Free strinfo vector if it is\n+   owned by the current bb, clear bb->aux.  */\n+\n+static void\n+strlen_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t    basic_block bb)\n+{\n+  if (bb->aux)\n+    {\n+      stridx_to_strinfo = (VEC(strinfo, heap) *) bb->aux;\n+      if (VEC_length (strinfo, stridx_to_strinfo)\n+\t  && VEC_index (strinfo, stridx_to_strinfo, 0) == (strinfo) bb)\n+\t{\n+\t  unsigned int i;\n+\t  strinfo si;\n+\n+\t  for (i = 1; VEC_iterate (strinfo, stridx_to_strinfo, i, si); ++i)\n+\t    free_strinfo (si);\n+\t  VEC_free (strinfo, heap, stridx_to_strinfo);\n+\t}\n+      bb->aux = NULL;\n+    }\n+}\n+\n+/* Main entry point.  */\n+\n+static unsigned int\n+tree_ssa_strlen (void)\n+{\n+  struct dom_walk_data walk_data;\n+\n+  VEC_safe_grow_cleared (int, heap, ssa_ver_to_stridx, num_ssa_names);\n+  max_stridx = 1;\n+  strinfo_pool = create_alloc_pool (\"strinfo_struct pool\",\n+\t\t\t\t    sizeof (struct strinfo_struct), 64);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* String length optimization is implemented as a walk of the dominator\n+     tree and a forward walk of statements within each block.  */\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children = strlen_enter_block;\n+  walk_data.after_dom_children = strlen_leave_block;\n+  walk_data.block_local_data_size = 0;\n+  walk_data.global_data = NULL;\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  VEC_free (int, heap, ssa_ver_to_stridx);\n+  free_alloc_pool (strinfo_pool);\n+  if (decl_to_stridxlist_htab)\n+    {\n+      obstack_free (&stridx_obstack, NULL);\n+      htab_delete (decl_to_stridxlist_htab);\n+      decl_to_stridxlist_htab = NULL;\n+    }\n+  laststmt.stmt = NULL;\n+  laststmt.len = NULL_TREE;\n+  laststmt.stridx = 0;\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_strlen (void)\n+{\n+  return flag_optimize_strlen != 0;\n+}\n+\n+struct gimple_opt_pass pass_strlen =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"strlen\",\t\t\t/* name */\n+  gate_strlen,\t\t\t/* gate */\n+  tree_ssa_strlen,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_STRLEN,\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_ggc_collect\n+    | TODO_verify_ssa\t\t/* todo_flags_finish */\n+ }\n+};"}]}