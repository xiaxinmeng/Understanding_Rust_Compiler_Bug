{"sha": "5640461d2f585cd08286f1ffb1ce41e9e88435d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY0MDQ2MWQyZjU4NWNkMDgyODZmMWZmYjFjZTQxZTllODg0MzVkNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-01-13T11:46:50Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-01-13T11:46:50Z"}, "message": "rope (_Rope_rep_alloc_base): Eliminate.\n\n2004-01-13  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/rope (_Rope_rep_alloc_base): Eliminate.\n\t(_Rope_rep_base): Inherit directly from the rope allocator;\n\tuse rebinding instead of _Alloc_traits; pick up data member\n\tfrom _Rope_rep_alloc_base.\n\t(_Rope_alloc_base): Eliminate.\n\t(_Rope_base): Inherit directly from the rope allocator; use\n\trebinding instead of _Alloc_traits; pick up data member from\n\t_Rope_alloc_base.\n\t(rope::_S_new_RopeLeaf, rope::_S_new_RopeConcatenation,\n\trope::_S_new_RopeFunction, rope::_S_new_RopeSubstring): Tweak.\n\nFrom-SVN: r75800", "tree": {"sha": "5eb756132f09e547f86710725c497edfb0a81d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eb756132f09e547f86710725c497edfb0a81d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5640461d2f585cd08286f1ffb1ce41e9e88435d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5640461d2f585cd08286f1ffb1ce41e9e88435d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5640461d2f585cd08286f1ffb1ce41e9e88435d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5640461d2f585cd08286f1ffb1ce41e9e88435d4/comments", "author": null, "committer": null, "parents": [{"sha": "95c9624ff55c571983f7278edeceff8a90042d84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c9624ff55c571983f7278edeceff8a90042d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c9624ff55c571983f7278edeceff8a90042d84"}], "stats": {"total": 196, "additions": 54, "deletions": 142}, "files": [{"sha": "59702aad470454ea6464590eb9c01bbe65b76463", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5640461d2f585cd08286f1ffb1ce41e9e88435d4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5640461d2f585cd08286f1ffb1ce41e9e88435d4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5640461d2f585cd08286f1ffb1ce41e9e88435d4", "patch": "@@ -1,3 +1,16 @@\n+2004-01-13  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/rope (_Rope_rep_alloc_base): Eliminate.\n+\t(_Rope_rep_base): Inherit directly from the rope allocator;\n+\tuse rebinding instead of _Alloc_traits; pick up data member\n+\tfrom _Rope_rep_alloc_base.\n+\t(_Rope_alloc_base): Eliminate.\n+\t(_Rope_base): Inherit directly from the rope allocator; use\n+\trebinding instead of _Alloc_traits; pick up data member from\n+\t_Rope_alloc_base.\n+\t(rope::_S_new_RopeLeaf, rope::_S_new_RopeConcatenation,\n+\trope::_S_new_RopeFunction, rope::_S_new_RopeSubstring): Tweak.\n+\n 2004-01-13  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/13650"}, {"sha": "597f82c8c3853d1d1df47354f687b4dc662a1513", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 41, "deletions": 142, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5640461d2f585cd08286f1ffb1ce41e9e88435d4/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5640461d2f585cd08286f1ffb1ce41e9e88435d4/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=5640461d2f585cd08286f1ffb1ce41e9e88435d4", "patch": "@@ -1,6 +1,6 @@\n // SGI's rope class -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -74,7 +74,6 @@ using std::ptrdiff_t;\n using std::allocator;\n using std::iterator;\n using std::reverse_iterator;\n-using std::_Alloc_traits;\n using std::_Destroy;\n \n // The _S_eos function is used for those functions that\n@@ -414,16 +413,6 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n //\n // Some of the static member functions of _RopeRep have identically\n // named functions in rope that simply invoke the _RopeRep versions.\n-//\n-// A macro to introduce various allocation and deallocation functions\n-// These need to be defined differently depending on whether or not\n-// we are using standard conforming allocators, and whether the allocator\n-// instances have real state.  Thus this macro is invoked repeatedly\n-// with different definitions of __ROPE_DEFINE_ALLOC.\n-// __ROPE_DEFINE_ALLOC(type,name) defines\n-//   type * name_allocate(size_t) and\n-//   void name_deallocate(tipe *, size_t)\n-// Both functions may or may not be static.\n \n #define __ROPE_DEFINE_ALLOCS(__a) \\\n         __ROPE_DEFINE_ALLOC(_CharT,_Data) /* character data */ \\\n@@ -442,79 +431,34 @@ identity_element(_Rope_Concat_fn<_CharT, _Alloc>)\n //  in some form to nearly all internal functions, since any pointer\n //  assignment may result in a zero reference count and thus require\n //  deallocation.\n-//  The _Rope_rep_base class encapsulates\n-//  the differences between SGI-style allocators and standard-conforming\n-//  allocators.\n \n #define __STATIC_IF_SGI_ALLOC  /* not static */\n \n-// Base class for ordinary allocators.\n-template <class _CharT, class _Allocator, bool _IsStatic>\n-class _Rope_rep_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-  _Rope_rep_alloc_base(size_t __size, const allocator_type& __a)\n-        : _M_size(__size), _M_data_allocator(__a) {}\n-  size_t _M_size;       // This is here only to avoid wasting space\n-                // for an otherwise empty base class.\n-\n+template <class _CharT, class _Alloc>\n+struct _Rope_rep_base\n+: public _Alloc\n+{\n+  typedef _Alloc allocator_type;\n \n-protected:\n-    allocator_type _M_data_allocator;\n+  allocator_type\n+  get_allocator() const { return *static_cast<const _Alloc*>(this); }\n \n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n-        /*static*/ _Tp * __name##_allocate(size_t __n) \\\n-          { return __name##Allocator(_M_data_allocator).allocate(__n); } \\\n-        void __name##_deallocate(_Tp* __p, size_t __n) \\\n-          { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator);\n-# undef __ROPE_DEFINE_ALLOC\n-};\n+  _Rope_rep_base(size_t __size, const allocator_type&)\n+  : _M_size(__size) {}\n \n-// Specialization for allocators that have the property that we don't\n-//  actually have to store an allocator object.\n-template <class _CharT, class _Allocator>\n-class _Rope_rep_alloc_base<_CharT,_Allocator,true> {\n-public:\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-  _Rope_rep_alloc_base(size_t __size, const allocator_type&)\n-                : _M_size(__size) {}\n   size_t _M_size;\n \n-protected:\n-\n # define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n         typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n+          _Alloc::template rebind<_Tp>::other __name##Alloc; \\\n         static _Tp* __name##_allocate(size_t __n) \\\n-                { return __name##Alloc::allocate(__n); } \\\n-        void __name##_deallocate(_Tp *__p, size_t __n) \\\n-                { __name##Alloc::deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator);\n+          { return __name##Alloc().allocate(__n); } \\\n+        static void __name##_deallocate(_Tp *__p, size_t __n) \\\n+          { __name##Alloc().deallocate(__p, __n); }\n+  __ROPE_DEFINE_ALLOCS(_Alloc)\n # undef __ROPE_DEFINE_ALLOC\n };\n \n-template <class _CharT, class _Alloc>\n-struct _Rope_rep_base\n-  : public _Rope_rep_alloc_base<_CharT,_Alloc,\n-                                _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-{\n-  typedef _Rope_rep_alloc_base<_CharT,_Alloc,\n-                               _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-  _Rope_rep_base(size_t __size, const allocator_type& __a)\n-    : _Base(__size, __a) {}\n-};\n-\n \n template<class _CharT, class _Alloc>\n struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n@@ -538,6 +482,7 @@ struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n                         /* the same memory as the data field.       */\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n                         allocator_type;\n+    using _Rope_rep_base<_CharT,_Alloc>::get_allocator;\n     _Rope_RopeRep(_Tag __t, int __d, bool __b, size_t __size,\n                   allocator_type __a)\n         : _Rope_rep_base<_CharT,_Alloc>(__size, __a),\n@@ -1219,84 +1164,37 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n          const _Rope_iterator<_CharT2,_Alloc2>& __x);\n };\n \n-//  The rope base class encapsulates\n-//  the differences between SGI-style allocators and standard-conforming\n-//  allocators.\n-\n-// Base class for ordinary allocators.\n-template <class _CharT, class _Allocator, bool _IsStatic>\n-class _Rope_alloc_base {\n-public:\n-  typedef _Rope_RopeRep<_CharT,_Allocator> _RopeRep;\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _M_data_allocator; }\n-  _Rope_alloc_base(_RopeRep *__t, const allocator_type& __a)\n-        : _M_tree_ptr(__t), _M_data_allocator(__a) {}\n-  _Rope_alloc_base(const allocator_type& __a)\n-        : _M_data_allocator(__a) {}\n-\n-protected:\n-  // The only data members of a rope:\n-    allocator_type _M_data_allocator;\n-    _RopeRep* _M_tree_ptr;\n \n-# define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n-        _Tp* __name##_allocate(size_t __n) const \\\n-          { return __name##Allocator(_M_data_allocator).allocate(__n); } \\\n-        void __name##_deallocate(_Tp *__p, size_t __n) const \\\n-                { __name##Allocator(_M_data_allocator).deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator)\n-# undef __ROPE_DEFINE_ALLOC\n-};\n+template <class _CharT, class _Alloc>\n+struct _Rope_base\n+: public _Alloc\n+{\n+  typedef _Alloc allocator_type;\n+\n+  allocator_type\n+  get_allocator() const { return *static_cast<const _Alloc*>(this); }\n+\n+  typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n+  // The one in _Base may not be visible due to template rules.\n+\n+  _Rope_base(_RopeRep* __t, const allocator_type&)\n+  : _M_tree_ptr(__t) {}\n+  _Rope_base(const allocator_type&) {}\n \n-// Specialization for allocators that have the property that we don't\n-//  actually have to store an allocator object.\n-template <class _CharT, class _Allocator>\n-class _Rope_alloc_base<_CharT,_Allocator,true> {\n-public:\n-  typedef _Rope_RopeRep<_CharT,_Allocator> _RopeRep;\n-  typedef typename _Alloc_traits<_CharT,_Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-  _Rope_alloc_base(_RopeRep *__t, const allocator_type&)\n-                : _M_tree_ptr(__t) {}\n-  _Rope_alloc_base(const allocator_type&) {}\n-\n-protected:\n   // The only data member of a rope:\n-    _RopeRep *_M_tree_ptr;\n+  _RopeRep *_M_tree_ptr;\n \n # define __ROPE_DEFINE_ALLOC(_Tp, __name) \\\n         typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::_Alloc_type __name##Alloc; \\\n-        typedef typename \\\n-          _Alloc_traits<_Tp,_Allocator>::allocator_type __name##Allocator; \\\n+          _Alloc::template rebind<_Tp>::other __name##Alloc; \\\n         static _Tp* __name##_allocate(size_t __n) \\\n-          { return __name##Alloc::allocate(__n); } \\\n+          { return __name##Alloc().allocate(__n); } \\\n         static void __name##_deallocate(_Tp *__p, size_t __n) \\\n-          { __name##Alloc::deallocate(__p, __n); }\n-  __ROPE_DEFINE_ALLOCS(_Allocator)\n+          { __name##Alloc().deallocate(__p, __n); }\n+  __ROPE_DEFINE_ALLOCS(_Alloc)\n # undef __ROPE_DEFINE_ALLOC\n };\n \n-template <class _CharT, class _Alloc>\n-struct _Rope_base\n-  : public _Rope_alloc_base<_CharT,_Alloc,\n-                            _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-{\n-  typedef _Rope_alloc_base<_CharT,_Alloc,\n-                            _Alloc_traits<_CharT,_Alloc>::_S_instanceless>\n-          _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n-  typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-        // The one in _Base may not be visible due to template rules.\n-  _Rope_base(_RopeRep* __t, const allocator_type& __a) : _Base(__t, __a) {}\n-  _Rope_base(const allocator_type& __a) : _Base(__a) {}\n-};\n-\n \n /**\n  *  This is an SGI extension.\n@@ -1328,6 +1226,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         typedef _Rope_base<_CharT,_Alloc> _Base;\n         typedef typename _Base::allocator_type allocator_type;\n         using _Base::_M_tree_ptr;\n+        using _Base::get_allocator;\n         typedef __GC_CONST _CharT* _Cstrptr;\n \n         static _CharT _S_empty_c_str[1];\n@@ -1435,30 +1334,30 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         static _RopeLeaf* _S_new_RopeLeaf(__GC_CONST _CharT *__s,\n                                           size_t __size, allocator_type __a)\n         {\n-            _RopeLeaf* __space = typename _Base::_LAllocator(__a).allocate(1);\n+            _RopeLeaf* __space = typename _Base::_LAlloc(__a).allocate(1);\n             return new(__space) _RopeLeaf(__s, __size, __a);\n         }\n \n         static _RopeConcatenation* _S_new_RopeConcatenation(\n                         _RopeRep* __left, _RopeRep* __right,\n                         allocator_type __a)\n         {\n-            _RopeConcatenation* __space = typename _Base::_CAllocator(__a).allocate(1);\n+            _RopeConcatenation* __space = typename _Base::_CAlloc(__a).allocate(1);\n             return new(__space) _RopeConcatenation(__left, __right, __a);\n         }\n \n         static _RopeFunction* _S_new_RopeFunction(char_producer<_CharT>* __f,\n                 size_t __size, bool __d, allocator_type __a)\n         {\n-            _RopeFunction* __space = typename _Base::_FAllocator(__a).allocate(1);\n+            _RopeFunction* __space = typename _Base::_FAlloc(__a).allocate(1);\n             return new(__space) _RopeFunction(__f, __size, __d, __a);\n         }\n \n         static _RopeSubstring* _S_new_RopeSubstring(\n                 _Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n                 size_t __l, allocator_type __a)\n         {\n-            _RopeSubstring* __space = typename _Base::_SAllocator(__a).allocate(1);\n+            _RopeSubstring* __space = typename _Base::_SAlloc(__a).allocate(1);\n             return new(__space) _RopeSubstring(__b, __s, __l, __a);\n         }\n "}]}