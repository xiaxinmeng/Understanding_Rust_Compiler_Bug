{"sha": "5ce97055e0f4077280146d62394370882f1b13e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNlOTcwNTVlMGY0MDc3MjgwMTQ2ZDYyMzk0MzcwODgyZjFiMTNlMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-10-02T07:03:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-10-02T07:03:15Z"}, "message": "ipa-prop.h (ipa_get_controlled_uses): Add hack to avoid ICE when speculation is added.\n\n\n\t* ipa-prop.h (ipa_get_controlled_uses): Add hack to avoid ICE\n\twhen speculation is added.\n\t(ipa_edge_args): Add polymorphic_call_contexts.\n\t(ipa_get_ith_polymorhic_call_context): New accesor.\n\t(ipa_make_edge_direct_to_target): Add SPECULATIVE parameter.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Print contexts.\n\t(ipa_compute_jump_functions_for_edge): Compute contexts.\n\t(update_jump_functions_after_inlining): Update contexts.\n\t(ipa_make_edge_direct_to_target): Add SPECULATIVE argument;\n\tupdate dumping; add speculative edge creation.\n\t(try_make_edge_direct_virtual_call): Add CTX_PTR parameter; handle\n\tcontext updating.\n\t(update_indirect_edges_after_inlining): Pass down context.\n\t(ipa_edge_duplication_hook): Duplicate contexts.\n\t(ipa_write_node_info): Stream out contexts.\n\t(ipa_read_node_info): Stream in contexts.\n\t* ipa-devirt.c (type_all_derivations_known_p): Avoid ICE on non-ODR\n\ttypes.\n\t(try_speculative_devirtualization): New function.\n\t* ipa-utils.h (try_speculative_devirtualization): Declare.\n\nFrom-SVN: r215794", "tree": {"sha": "b3e82e3cba97dcee5b7ae4802423eec91c41f503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3e82e3cba97dcee5b7ae4802423eec91c41f503"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ce97055e0f4077280146d62394370882f1b13e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce97055e0f4077280146d62394370882f1b13e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ce97055e0f4077280146d62394370882f1b13e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce97055e0f4077280146d62394370882f1b13e0/comments", "author": null, "committer": null, "parents": [{"sha": "9fbbb20da58853217f84a9c4b82c84274c27144f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbbb20da58853217f84a9c4b82c84274c27144f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbbb20da58853217f84a9c4b82c84274c27144f"}], "stats": {"total": 312, "additions": 272, "deletions": 40}, "files": [{"sha": "e07c960ade66583d112817cc67a89ce5b737ebdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ce97055e0f4077280146d62394370882f1b13e0", "patch": "@@ -1,3 +1,26 @@\n+2014-10-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-prop.h (ipa_get_controlled_uses): Add hack to avoid ICE\n+\twhen speculation is added.\n+\t(ipa_edge_args): Add polymorphic_call_contexts.\n+\t(ipa_get_ith_polymorhic_call_context): New accesor.\n+\t(ipa_make_edge_direct_to_target): Add SPECULATIVE parameter.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Print contexts.\n+\t(ipa_compute_jump_functions_for_edge): Compute contexts.\n+\t(update_jump_functions_after_inlining): Update contexts.\n+\t(ipa_make_edge_direct_to_target): Add SPECULATIVE argument;\n+\tupdate dumping; add speculative edge creation.\n+\t(try_make_edge_direct_virtual_call): Add CTX_PTR parameter; handle\n+\tcontext updating.\n+\t(update_indirect_edges_after_inlining): Pass down context.\n+\t(ipa_edge_duplication_hook): Duplicate contexts.\n+\t(ipa_write_node_info): Stream out contexts.\n+\t(ipa_read_node_info): Stream in contexts.\n+\t* ipa-devirt.c (type_all_derivations_known_p): Avoid ICE on non-ODR\n+\ttypes.\n+\t(try_speculative_devirtualization): New function.\n+\t* ipa-utils.h (try_speculative_devirtualization): Declare.\n+\n 2014-10-01  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa.c (walk_polymorphic_call_targets): Avoid ICE when"}, {"sha": "00fc6bb8285a293ebc9505afa46d4574b7761e92", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=5ce97055e0f4077280146d62394370882f1b13e0", "patch": "@@ -224,6 +224,9 @@ type_all_derivations_known_p (const_tree t)\n     return true;\n   if (flag_ltrans)\n     return false;\n+  /* Non-C++ types may have IDENTIFIER_NODE here, do not crash.  */\n+  if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL)\n+    return true;\n   if (type_in_anonymous_namespace_p (t))\n     return true;\n   return (decl_function_context (TYPE_NAME (t)) != NULL);\n@@ -2734,6 +2737,43 @@ decl_warning_cmp (const void *p1, const void *p2)\n   return t2->count - t1->count;\n }\n \n+\n+/* Try speculatively devirtualize call to OTR_TYPE with OTR_TOKEN with\n+   context CTX.  */\n+\n+struct cgraph_node *\n+try_speculative_devirtualization (tree otr_type, HOST_WIDE_INT otr_token,\n+\t\t\t\t  ipa_polymorphic_call_context ctx)\n+{\n+  vec <cgraph_node *>targets\n+     = possible_polymorphic_call_targets\n+\t  (otr_type, otr_token, ctx, NULL, NULL, true);\n+  unsigned int i;\n+  struct cgraph_node *likely_target = NULL;\n+\n+  for (i = 0; i < targets.length (); i++)\n+    if (likely_target_p (targets[i]))\n+      {\n+\tif (likely_target)\n+\t  return NULL;\n+\tlikely_target = targets[i];\n+      }\n+  if (!likely_target\n+      ||!likely_target->definition\n+      || DECL_EXTERNAL (likely_target->decl))\n+    return NULL;\n+\n+  /* Don't use an implicitly-declared destructor (c++/58678).  */\n+  struct cgraph_node *non_thunk_target\n+    = likely_target->function_symbol ();\n+  if (DECL_ARTIFICIAL (non_thunk_target->decl))\n+    return NULL;\n+  if (likely_target->get_availability () <= AVAIL_INTERPOSABLE\n+      && likely_target->can_be_discarded_p ())\n+    return NULL;\n+  return likely_target;\n+}\n+\n /* The ipa-devirt pass.\n    When polymorphic call has only one likely target in the unit,\n    turn it into speculative call.  */"}, {"sha": "b2430b8dff5ab7983691d6217523878f7f31def3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 190, "deletions": 38, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5ce97055e0f4077280146d62394370882f1b13e0", "patch": "@@ -364,6 +364,8 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t      fprintf (f, \"\\n\");\n \t    }\n \t}\n+      if (IPA_EDGE_REF (cs)->polymorphic_call_contexts)\n+\tipa_get_ith_polymorhic_call_context (IPA_EDGE_REF (cs), i)->dump (f);\n     }\n }\n \n@@ -1876,10 +1878,13 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n   struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n   gimple call = cs->call_stmt;\n   int n, arg_num = gimple_call_num_args (call);\n+  bool useful_context = false;\n \n   if (arg_num == 0 || args->jump_functions)\n     return;\n   vec_safe_grow_cleared (args->jump_functions, arg_num);\n+  if (flag_devirtualize)\n+    vec_safe_grow_cleared (args->polymorphic_call_contexts, arg_num);\n \n   if (gimple_call_internal_p (call))\n     return;\n@@ -1891,6 +1896,16 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n       struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, n);\n       tree arg = gimple_call_arg (call, n);\n       tree param_type = ipa_get_callee_param_type (cs, n);\n+      if (flag_devirtualize && POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t{\n+\t  struct ipa_polymorphic_call_context context (cs->caller->decl,\n+\t\t\t\t\t\t       arg, cs->call_stmt,\n+\t\t\t\t\t\t       NULL);\n+\t  /* TODO: We should also handle dynamic types.  */\n+\t  *ipa_get_ith_polymorhic_call_context (args, n) = context;\n+\t  if (!context.useless_p ())\n+\t    useful_context = true;\n+\t}\n \n       if (is_gimple_ip_invariant (arg))\n \tipa_set_jf_constant (jfunc, arg, cs);\n@@ -1963,6 +1978,8 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t      || POINTER_TYPE_P (param_type)))\n \tdetermine_locally_known_aggregate_parts (call, arg, param_type, jfunc);\n     }\n+  if (!useful_context)\n+    vec_free (args->polymorphic_call_contexts);\n }\n \n /* Compute jump functions for all edges - both direct and indirect - outgoing\n@@ -2608,11 +2625,15 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n   for (i = 0; i < count; i++)\n     {\n       struct ipa_jump_func *dst = ipa_get_ith_jump_func (args, i);\n+      struct ipa_polymorphic_call_context *dst_ctx\n+\t= ipa_get_ith_polymorhic_call_context (args, i);\n \n       if (dst->type == IPA_JF_ANCESTOR)\n \t{\n \t  struct ipa_jump_func *src;\n \t  int dst_fid = dst->value.ancestor.formal_id;\n+\t  struct ipa_polymorphic_call_context *src_ctx\n+\t    = ipa_get_ith_polymorhic_call_context (top, dst_fid);\n \n \t  /* Variable number of arguments can cause havoc if we try to access\n \t     one that does not exist in the inlined edge.  So make sure we\n@@ -2625,6 +2646,22 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \n \t  src = ipa_get_ith_jump_func (top, dst_fid);\n \n+\t  if (src_ctx && !src_ctx->useless_p ())\n+\t    {\n+\t      struct ipa_polymorphic_call_context ctx = *src_ctx;\n+\n+\t      /* TODO: Make type preserved safe WRT contexts.  */\n+\t      if (!dst->value.ancestor.agg_preserved)\n+\t\tctx.make_speculative ();\n+\t      ctx.offset_by (dst->value.ancestor.offset);\n+\t      if (!ctx.useless_p ())\n+\t\t{\n+\t\t  vec_safe_grow_cleared (args->polymorphic_call_contexts,\n+\t\t\t\t\t count);\n+\t\t  dst_ctx = ipa_get_ith_polymorhic_call_context (args, i);\n+\t\t}\n+\t    }\n+\n \t  if (src->agg.items\n \t      && (dst->value.ancestor.agg_preserved || !src->agg.by_ref))\n \t    {\n@@ -2676,7 +2713,27 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      int dst_fid = dst->value.pass_through.formal_id;\n \t      src = ipa_get_ith_jump_func (top, dst_fid);\n \t      bool dst_agg_p = ipa_get_jf_pass_through_agg_preserved (dst);\n+\t      struct ipa_polymorphic_call_context *src_ctx\n+\t\t= ipa_get_ith_polymorhic_call_context (top, dst_fid);\n \n+\t      if (src_ctx && !src_ctx->useless_p ())\n+\t\t{\n+\t\t  struct ipa_polymorphic_call_context ctx = *src_ctx;\n+\n+\t\t  /* TODO: Make type preserved safe WRT contexts.  */\n+\t\t  if (!dst->value.ancestor.agg_preserved)\n+\t\t    ctx.make_speculative ();\n+\t\t  if (!ctx.useless_p ())\n+\t\t    {\n+\t\t      if (!dst_ctx)\n+\t\t\t{\n+\t\t\t  vec_safe_grow_cleared (args->polymorphic_call_contexts,\n+\t\t\t\t\t         count);\n+\t\t\t  dst_ctx = ipa_get_ith_polymorhic_call_context (args, i);\n+\t\t\t}\n+\t\t      dst_ctx->combine_with (ctx);\n+\t\t    }\n+\t\t}\n \t      switch (src->type)\n \t\t{\n \t\tcase IPA_JF_UNKNOWN:\n@@ -2754,11 +2811,13 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n     }\n }\n \n-/* If TARGET is an addr_expr of a function declaration, make it the destination\n-   of an indirect edge IE and return the edge.  Otherwise, return NULL.  */\n+/* If TARGET is an addr_expr of a function declaration, make it the \n+   (SPECULATIVE)destination of an indirect edge IE and return the edge.\n+   Otherwise, return NULL.  */\n \n struct cgraph_edge *\n-ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n+ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n+\t\t\t\tbool speculative)\n {\n   struct cgraph_node *callee;\n   struct inline_edge_summary *es = inline_edge_summary (ie);\n@@ -2829,9 +2888,10 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \n   if (dump_file && !unreachable)\n     {\n-      fprintf (dump_file, \"ipa-prop: Discovered %s call to a known target \"\n+      fprintf (dump_file, \"ipa-prop: Discovered %s call to a %s target \"\n \t       \"(%s/%i -> %s/%i), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n+\t       speculative ? \"speculative\" : \"known\",\n \t       xstrdup (ie->caller->name ()),\n \t       ie->caller->order,\n \t       xstrdup (callee->name ()),\n@@ -2849,7 +2909,20 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t\t       \"converting indirect call in %s to direct call to %s\\n\",\n \t\t       ie->caller->name (), callee->name ());\n     }\n-  ie = ie->make_direct (callee);\n+  if (!speculative)\n+    ie = ie->make_direct (callee);\n+  else\n+    {\n+      if (!callee->can_be_discarded_p ())\n+\t{\n+\t  cgraph_node *alias;\n+\t  alias = dyn_cast<cgraph_node *> (callee->noninterposable_alias ());\n+\t  if (alias)\n+\t    callee = alias;\n+\t}\n+      ie = ie->make_speculative\n+\t     (callee, ie->count * 8 / 10, ie->frequency * 8 / 10);\n+    }\n   es = inline_edge_summary (ie);\n   es->call_stmt_size -= (eni_size_weights.indirect_call_cost\n \t\t\t - eni_size_weights.call_cost);\n@@ -3035,14 +3108,33 @@ ipa_impossible_devirt_target (struct cgraph_edge *ie, tree target)\n static struct cgraph_edge *\n try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc,\n-\t\t\t\t   struct ipa_node_params *new_root_info)\n+\t\t\t\t   struct ipa_node_params *new_root_info,\n+\t\t\t\t   struct ipa_polymorphic_call_context *ctx_ptr)\n {\n-  tree binfo, target;\n+  tree binfo, target = NULL;\n+  bool speculative = false;\n+  bool updated = false;\n \n   if (!flag_devirtualize)\n     return NULL;\n \n-  /* First try to do lookup via known virtual table pointer value.  */\n+  /* If this is call of a function parameter, restrict its type\n+     based on knowlede of the context.  */\n+  if (ctx_ptr && !ie->indirect_info->by_ref)\n+    {\n+      struct ipa_polymorphic_call_context ctx = *ctx_ptr;\n+\n+      ctx.offset_by (ie->indirect_info->offset);\n+\n+      /* TODO: We want to record if type change happens.  \n+\t Old code did not do that that seems like a bug.  */\n+      ctx.make_speculative (ie->indirect_info->otr_type);\n+\n+      updated = ie->indirect_info->context.combine_with\n+\t\t  (ctx, ie->indirect_info->otr_type);\n+    }\n+\n+  /* Try to do lookup via known virtual table pointer value.  */\n   if (!ie->indirect_info->by_ref)\n     {\n       tree vtable;\n@@ -3068,44 +3160,68 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n   binfo = ipa_value_from_jfunc (new_root_info, jfunc);\n \n-  if (!binfo)\n-    return NULL;\n+  if (binfo && TREE_CODE (binfo) != TREE_BINFO)\n+    {\n+      struct ipa_polymorphic_call_context ctx (binfo,\n+\t\t\t\t\t       ie->indirect_info->otr_type,\n+\t\t\t\t\t       ie->indirect_info->offset);\n+      updated |= ie->indirect_info->context.combine_with\n+\t\t  (ctx, ie->indirect_info->otr_type);\n+    }\n \n-  if (TREE_CODE (binfo) != TREE_BINFO)\n+  if (updated)\n     {\n-      ipa_polymorphic_call_context context (binfo,\n-\t\t\t\t\t    ie->indirect_info->otr_type,\n-\t\t\t\t\t    ie->indirect_info->offset);\n+      ipa_polymorphic_call_context context (ie);\n       vec <cgraph_node *>targets;\n       bool final;\n \n       targets = possible_polymorphic_call_targets\n \t\t (ie->indirect_info->otr_type,\n \t\t  ie->indirect_info->otr_token,\n \t\t  context, &final);\n-      if (!final || targets.length () > 1)\n-\treturn NULL;\n-      if (targets.length () == 1)\n-\ttarget = targets[0]->decl;\n-      else\n-\ttarget = ipa_impossible_devirt_target (ie, NULL_TREE);\n-    }\n-  else\n+      if (final && targets.length () <= 1)\n+\t{\n+\t  if (targets.length () == 1)\n+\t    target = targets[0]->decl;\n+\t  else\n+\t    target = ipa_impossible_devirt_target (ie, NULL_TREE);\n+\t}\n+      else if (flag_devirtualize_speculatively\n+\t       && !ie->speculative && ie->maybe_hot_p ())\n+\t{\n+\t  cgraph_node *n = try_speculative_devirtualization (ie->indirect_info->otr_type,\n+\t\t\t\t\t\t\t     ie->indirect_info->otr_token,\n+\t\t\t\t\t\t\t     ie->indirect_info->context);\n+\t  if (n)\n+\t    {\n+\t      target = n->decl;\n+\t      speculative = true;\n+\t    }\n+\t}\n+     }\n+\n+  if (binfo && TREE_CODE (binfo) == TREE_BINFO)\n     {\n       binfo = get_binfo_at_offset (binfo, ie->indirect_info->offset,\n \t\t\t\t   ie->indirect_info->otr_type);\n       if (binfo)\n-\ttarget = gimple_get_virt_method_for_binfo (ie->indirect_info->otr_token,\n-\t\t\t\t\t\t   binfo);\n-      else\n-\treturn NULL;\n+\t{\n+\t  tree t = gimple_get_virt_method_for_binfo (ie->indirect_info->otr_token,\n+\t\t\t\t\t\t     binfo);\n+\t  if (t)\n+\t    {\n+\t      gcc_assert (!target || speculative || target == t);\n+\t      target = t;\n+\t      speculative = false;\n+\t    }\n+\t}\n     }\n \n   if (target)\n     {\n-      if (!possible_polymorphic_call_target_p (ie, cgraph_node::get (target)))\n+      if (!possible_polymorphic_call_target_p (ie, cgraph_node::get_create (target)))\n \ttarget = ipa_impossible_devirt_target (ie, target);\n-      return ipa_make_edge_direct_to_target (ie, target);\n+      return ipa_make_edge_direct_to_target (ie, target, speculative);\n     }\n   else\n     return NULL;\n@@ -3157,8 +3273,13 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       if (!flag_indirect_inlining)\n \tnew_direct_edge = NULL;\n       else if (ici->polymorphic)\n-\tnew_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc,\n-\t\t\t\t\t\t\t     new_root_info);\n+\t{\n+          ipa_polymorphic_call_context *ctx;\n+          ctx = ipa_get_ith_polymorhic_call_context (top, param_index);\n+\t  new_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc,\n+\t\t\t\t\t\t\t       new_root_info,\n+\t\t\t\t\t\t\t       ctx);\n+\t}\n       else\n \tnew_direct_edge = try_make_edge_direct_simple_call (ie, jfunc,\n \t\t\t\t\t\t\t    new_root_info);\n@@ -3523,6 +3644,9 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n   new_args = IPA_EDGE_REF (dst);\n \n   new_args->jump_functions = vec_safe_copy (old_args->jump_functions);\n+  if (old_args->polymorphic_call_contexts)\n+    new_args->polymorphic_call_contexts\n+      = vec_safe_copy (old_args->polymorphic_call_contexts);\n \n   for (i = 0; i < vec_safe_length (old_args->jump_functions); i++)\n     {\n@@ -4751,17 +4875,29 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n \n-      streamer_write_uhwi (ob, ipa_get_cs_argument_count (args));\n+      streamer_write_uhwi (ob,\n+\t\t\t   ipa_get_cs_argument_count (args) * 2\n+\t\t\t   + (args->polymorphic_call_contexts != NULL));\n       for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n-\tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n+\t{\n+\t  ipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n+\t  if (args->polymorphic_call_contexts != NULL)\n+\t    ipa_get_ith_polymorhic_call_context (args, j)->stream_out (ob);\n+\t}\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n \n-      streamer_write_uhwi (ob, ipa_get_cs_argument_count (args));\n+      streamer_write_uhwi (ob,\n+\t\t\t   ipa_get_cs_argument_count (args) * 2\n+  \t\t\t   + (args->polymorphic_call_contexts != NULL));\n       for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n-\tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n+\t{\n+\t  ipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n+\t  if (args->polymorphic_call_contexts != NULL)\n+\t    ipa_get_ith_polymorhic_call_context (args, j)->stream_out (ob);\n+\t}\n       ipa_write_indirect_edge_info (ob, e);\n     }\n }\n@@ -4794,26 +4930,42 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       int count = streamer_read_uhwi (ib);\n+      bool contexts_computed = count & 1;\n+      count /= 2;\n \n       if (!count)\n \tcontinue;\n       vec_safe_grow_cleared (args->jump_functions, count);\n+      if (contexts_computed)\n+\tvec_safe_grow_cleared (args->polymorphic_call_contexts, count);\n \n       for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n-\tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n-\t\t\t\tdata_in);\n+\t{\n+\t  ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n+\t\t\t\t  data_in);\n+\t  if (contexts_computed)\n+\t    ipa_get_ith_polymorhic_call_context (args, k)->stream_in (ib, data_in);\n+\t}\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       int count = streamer_read_uhwi (ib);\n+      bool contexts_computed = count & 1;\n+      count /= 2;\n \n       if (count)\n \t{\n \t  vec_safe_grow_cleared (args->jump_functions, count);\n+\t  if (contexts_computed)\n+\t    vec_safe_grow_cleared (args->polymorphic_call_contexts, count);\n           for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n-\t    ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n-\t\t\t\t    data_in);\n+\t    {\n+\t      ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n+\t\t\t\t      data_in);\n+\t      if (contexts_computed)\n+\t\tipa_get_ith_polymorhic_call_context (args, k)->stream_in (ib, data_in);\n+\t    }\n \t}\n       ipa_read_indirect_edge_info (ib, data_in, e);\n     }"}, {"sha": "7a06af9958bceb1746572b828db07114535c37f7", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=5ce97055e0f4077280146d62394370882f1b13e0", "patch": "@@ -432,7 +432,10 @@ ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n static inline int\n ipa_get_controlled_uses (struct ipa_node_params *info, int i)\n {\n-  return info->descriptors[i].controlled_uses;\n+  /* FIXME: introducing speuclation causes out of bounds access here.  */\n+  if (info->descriptors.length () > (unsigned)i)\n+    return info->descriptors[i].controlled_uses;\n+  return IPA_UNDESCRIBED_USE;\n }\n \n /* Set the controlled counter of a given parameter.  */\n@@ -479,6 +482,7 @@ struct GTY(()) ipa_edge_args\n {\n   /* Vector of the callsite's jump function of each parameter.  */\n   vec<ipa_jump_func, va_gc> *jump_functions;\n+  vec<ipa_polymorphic_call_context, va_gc> *polymorphic_call_contexts;\n };\n \n /* ipa_edge_args access functions.  Please use these to access fields that\n@@ -502,6 +506,16 @@ ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n   return &(*args->jump_functions)[i];\n }\n \n+/* Returns a pointer to the polymorphic call context for the ith argument.\n+   NULL if contexts are not computed.  */\n+static inline struct ipa_polymorphic_call_context *\n+ipa_get_ith_polymorhic_call_context (struct ipa_edge_args *args, int i)\n+{\n+  if (!args->polymorphic_call_contexts)\n+    return NULL;\n+  return &(*args->polymorphic_call_contexts)[i];\n+}\n+\n /* Types of vectors holding the infos.  */\n \n /* Vector where the parameter infos are actually stored. */\n@@ -585,7 +599,8 @@ tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \t\t\t\t   vec<tree> ,\n \t\t\t\t   vec<tree> ,\n \t\t\t\t   vec<ipa_agg_jump_function_p> );\n-struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree);\n+struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n+\t\t\t\t\t\t    bool speculative = false);\n tree ipa_binfo_from_known_type_jfunc (struct ipa_jump_func *);\n tree ipa_impossible_devirt_target (struct cgraph_edge *, tree);\n "}, {"sha": "e1b2d548121fa8d082a394a6b554f0247ccee213", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ce97055e0f4077280146d62394370882f1b13e0/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=5ce97055e0f4077280146d62394370882f1b13e0", "patch": "@@ -82,6 +82,8 @@ bool contains_polymorphic_type_p (const_tree);\n void register_odr_type (tree);\n bool types_must_be_same_for_odr (tree, tree);\n bool types_odr_comparable (tree, tree);\n+cgraph_node *try_speculative_devirtualization (tree, HOST_WIDE_INT,\n+\t\t\t\t\t       ipa_polymorphic_call_context);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If COMPLETEP is non-NULL, store true if the list is complette. "}]}