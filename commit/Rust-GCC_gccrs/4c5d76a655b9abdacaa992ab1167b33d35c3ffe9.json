{"sha": "4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM1ZDc2YTY1NWI5YWJkYWNhYTk5MmFiMTE2N2IzM2QzNWMzZmZlOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-08-25T23:25:12Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-08-25T23:25:12Z"}, "message": "Fix tests that require IBM 128-bit long double\n\nThis patch adds 3 more selections to target-supports.exp to see if we can\nspecify to use a particular long double format (IEEE 128-bit, IBM extended\ndouble, 64-bit), and the library support will track the changes for the long\ndouble.  This is needed because two of the tests in the test suite use long\ndouble, and they are actually testing IBM extended double.\n\nThis patch also forces the two tests that explicitly require long double\nto use the IBM double-double encoding to explicitly run the test.  This\nrequires GLIBC 2.32 or greater in order to do the switch.\n\nI have run tests on a little endian power9 system with 3 compilers.  There were\nno regressions with these patches, and the two tests in the following patches\nnow work if the default long double is not IBM 128-bit:\n\n * One compiler used the default IBM 128-bit format;\n * One compiler used the IEEE 128-bit format; (and)\n * One compiler used 64-bit long doubles.\n\nI have also tested compilers on a big endian power8 system with a compiler\ndefaulting to power8 code generation and another with the default cpu\nset.  There were no regressions.\n\n2021-08-25  Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/testsuite/\n\tPR target/94630\n\t* gcc.target/powerpc/pr70117.c: Specify that we need the long double\n\ttype to be IBM 128-bit.  Remove the code to use __ibm128.\n\t* c-c++-common/dfp/convert-bfp-11.c: Specify that we need the long\n\tdouble type to be IBM 128-bit.  Run the test at -O2 optimization.\n\t* lib/target-supports.exp (add_options_for_long_double_ibm128): New\n\tfunction.\n\t(check_effective_target_long_double_ibm128): New function.\n\t(add_options_for_long_double_ieee128): New function.\n\t(check_effective_target_long_double_ieee128): New function.\n\t(add_options_for_long_double_64bit): New function.\n\t(check_effective_target_long_double_64bit): New function.", "tree": {"sha": "05ac5f73fe56d0bff59097489c04ed7a500cc9d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05ac5f73fe56d0bff59097489c04ed7a500cc9d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/comments", "author": null, "committer": null, "parents": [{"sha": "ea5674687ac45fe7242c57220b699337899881f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea5674687ac45fe7242c57220b699337899881f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea5674687ac45fe7242c57220b699337899881f0"}], "stats": {"total": 172, "additions": 148, "deletions": 24}, "files": [{"sha": "c09c8342bbbd868a777fe1f64f8b51fed2d0913a", "filename": "gcc/testsuite/c-c++-common/dfp/convert-bfp-11.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fconvert-bfp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fconvert-bfp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdfp%2Fconvert-bfp-11.c?ref=4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "patch": "@@ -1,9 +1,16 @@\n-/* { dg-skip-if \"\" { ! \"powerpc*-*-linux*\" } } */\n+/* { dg-require-effective-target dfp } */\n \n-/* Test decimal float conversions to and from IBM 128-bit long double. \n-   Checks are skipped at runtime if long double is not 128 bits.\n-   Don't force 128-bit long doubles because runtime support depends\n-   on glibc.  */\n+/* We need the long double type to be IBM 128-bit because the CONVERT_TO_PINF\n+   tests will fail if we use IEEE 128-bit floating point.  This is due to IEEE\n+   128-bit having a larger exponent range than IBM 128-bit extended double.  So\n+   tests that would generate an infinity with IBM 128-bit will generate a\n+   normal number with IEEE 128-bit.  */\n+\n+/* { dg-require-effective-target long_double_ibm128 } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options long_double_ibm128 } */\n+\n+/* Test decimal float conversions to and from IBM 128-bit long double.   */\n \n #include \"convert.h\"\n \n@@ -36,9 +43,6 @@ CONVERT_TO_PINF (312, tf, sd, 1.6e+308L, d32)\n int\n main ()\n {\n-  if (sizeof (long double) != 16)\n-    return 0;\n-\n   convert_101 ();\n   convert_102 ();\n "}, {"sha": "4a51f5831575ae029d57af2869a265d147b2768a", "filename": "gcc/testsuite/gcc.target/powerpc/pr70117.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c?ref=4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "patch": "@@ -1,26 +1,18 @@\n-/* { dg-do run { target { powerpc*-*-linux* powerpc*-*-darwin* powerpc*-*-aix* rs6000-*-* } } } */\n-/* { dg-options \"-std=c99 -mlong-double-128 -O2\" } */\n+/* { dg-do run } */\n+/* { dg-require-effective-target long_double_ibm128 } */\n+/* { dg-options \"-std=c99 -O2\" } */\n+/* { dg-add-options long_double_ibm128 } */\n \n #include <float.h>\n \n-#if defined(__LONG_DOUBLE_IEEE128__)\n-/* If long double is IEEE 128-bit, we need to use the __ibm128 type instead of\n-   long double.  We can't use __ibm128 on systems that don't support IEEE\n-   128-bit floating point, because the type is not enabled on those\n-   systems.  */\n-#define LDOUBLE __ibm128\n-\n-#elif defined(__LONG_DOUBLE_IBM128__)\n-#define LDOUBLE long double\n-\n-#else\n-#error \"long double must be either IBM 128-bit or IEEE 128-bit\"\n+#ifndef __LONG_DOUBLE_IBM128__\n+#error \"long double must be IBM 128-bit\"\n #endif\n \n union gl_long_double_union\n {\n   struct { double hi; double lo; } dd;\n-  LDOUBLE ld;\n+  long double ld;\n };\n \n /* This is gnulib's LDBL_MAX which, being 107 bits in precision, is\n@@ -36,7 +28,7 @@ volatile double dnan = 0.0/0.0;\n int\n main (void)\n {\n-  LDOUBLE ld;\n+  long double ld;\n \n   ld = gl_LDBL_MAX.ld;\n   if (__builtin_isinf (ld))"}, {"sha": "350dbdb24f1408c02b6f0dbc9e16d1a22392748d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5d76a655b9abdacaa992ab1167b33d35c3ffe9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=4c5d76a655b9abdacaa992ab1167b33d35c3ffe9", "patch": "@@ -2360,6 +2360,134 @@ proc check_effective_target_ppc_ieee128_ok { } {\n     }]\n }\n \n+# Check if GCC and GLIBC supports explicitly specifying that the long double\n+# format uses the IBM 128-bit extended double format.  Under little endian\n+# PowerPC Linux, you need GLIBC 2.32 or later to be able to use a different\n+# long double format for running a program than the system default.\n+\n+proc check_effective_target_long_double_ibm128 { } {\n+    return [check_runtime_nocache long_double_ibm128 {\n+\t#include <string.h>\n+\t#include <stdio.h>\n+\t/* use volatile to prevent optimization.  */\n+\tvolatile __ibm128 a = (__ibm128) 3.0;\n+\tvolatile long double one = 1.0L;\n+\tvolatile long double two = 2.0L;\n+\tvolatile long double b;\n+\tchar buffer[20];\n+\tint main()\n+\t{\n+\t  __ibm128 a2;\n+\t  long double b2;\n+\t  if (sizeof (long double) != 16)\n+\t    return 1;\n+\t  b = one + two;\n+\t  /* eliminate removing volatile cast warning.  */\n+\t  a2 = a;\n+\t  b2 = b;\n+\t  if (memcmp (&a2, &b2, 16) != 0)\n+\t    return 1;\n+\t  sprintf (buffer, \"%lg\", b);\n+\t  return strcmp (buffer, \"3\") != 0;\n+\t}\n+    } [add_options_for_long_double_ibm128 \"\"]]\n+}\n+\n+# Return the appropriate options to specify that long double uses the IBM\n+# 128-bit format on PowerPC.\n+\n+proc add_options_for_long_double_ibm128 { flags } {\n+    if { [istarget powerpc*-*-*] } {\n+\treturn \"$flags -mlong-double-128 -Wno-psabi -mabi=ibmlongdouble\"\n+    }\n+    return \"$flags\"\n+}\n+\n+# Check if GCC and GLIBC supports explicitly specifying that the long double\n+# format uses the IEEE 128-bit format.  Under little endian PowerPC Linux, you\n+# need GLIBC 2.32 or later to be able to use a different long double format for\n+# running a program than the system default.\n+\n+proc check_effective_target_long_double_ieee128 { } {\n+    return [check_runtime_nocache long_double_ieee128 {\n+\t#include <string.h>\n+\t#include <stdio.h>\n+\t/* use volatile to prevent optimization.  */\n+\tvolatile _Float128 a = 3.0f128;\n+\tvolatile long double one = 1.0L;\n+\tvolatile long double two = 2.0L;\n+\tvolatile long double b;\n+\tchar buffer[20];\n+\tint main()\n+\t{\n+\t  _Float128 a2;\n+\t  long double b2;  \n+\t  if (sizeof (long double) != 16)\n+\t    return 1;\n+\t  b = one + two;\n+\t  /* eliminate removing volatile cast warning.  */\n+\t  a2 = a;\n+\t  b2 = b;\n+\t  if (memcmp (&a2, &b2, 16) != 0)\n+\t    return 1;\n+\t  sprintf (buffer, \"%lg\", b);\n+\t  return strcmp (buffer, \"3\") != 0;\n+\t}\n+    }  [add_options_for_long_double_ieee128 \"\"]]\n+}\n+\n+# Return the appropriate options to specify that long double uses the IBM\n+# 128-bit format on PowerPC.\n+proc add_options_for_long_double_ieee128 { flags } {\n+    if { [istarget powerpc*-*-*] } {\n+\treturn \"$flags -mlong-double-128 -Wno-psabi -mabi=ieeelongdouble\"\n+    }\n+    return \"$flags\"\n+}\n+\n+# Check if GCC and GLIBC supports explicitly specifying that the long double\n+# format uses the IEEE 64-bit.  Under little endian PowerPC Linux, you need\n+# GLIBC 2.32 or later to be able to use a different long double format for\n+# running a program than the system default.\n+\n+proc check_effective_target_long_double_64bit { } {\n+    return [check_runtime_nocache long_double_64bit {\n+\t#include <string.h>\n+\t#include <stdio.h>\n+\t/* use volatile to prevent optimization.  */\n+\tvolatile double a = 3.0;\n+\tvolatile long double one = 1.0L;\n+\tvolatile long double two = 2.0L;\n+\tvolatile long double b;\n+\tchar buffer[20];\n+\tint main()\n+\t{\n+\t  double a2;\n+\t  long double b2;\n+\t  if (sizeof (long double) != 8)\n+\t    return 1;\n+\t  b = one + two;\n+\t  /* eliminate removing volatile cast warning.  */\n+\t  a2 = a;\n+\t  b2 = b;\n+\t  if (memcmp (&a2, &b2, 16) != 0)\n+\t    return 1;\n+\t  sprintf (buffer, \"%lg\", b);\n+\t  return strcmp (buffer, \"3\") != 0;\n+\t}\n+    }  [add_options_for_ppc_long_double_override_64bit \"\"]]\n+}\n+\n+# Return the appropriate options to specify that long double uses the IEEE\n+# 64-bit format on PowerPC.\n+\n+proc add_options_for_long_double_64bit { flags } {\n+    if { [istarget powerpc*-*-*] } {\n+\treturn \"$flags -mlong-double-64\"\n+    }\n+    return \"$flags\"\n+}\n+\n # Return 1 if the target supports executing VSX instructions, 0\n # otherwise.  Cache the result.\n "}]}