{"sha": "0435b978f95971e139882549f5a1765c50682216", "node_id": "C_kwDOANBUbNoAKDA0MzViOTc4Zjk1OTcxZTEzOTg4MjU0OWY1YTE3NjVjNTA2ODIyMTY", "commit": {"author": {"name": "Hongyu Wang", "email": "hongyu.wang@intel.com", "date": "2022-02-11T06:44:15Z"}, "committer": {"name": "Hongyu Wang", "email": "hongyu.wang@intel.com", "date": "2022-02-22T01:30:19Z"}, "message": "i386: Relax cmpxchg instruction under -mrelax-cmpxchg-loop [PR103069]\n\nFor cmpxchg, it is commonly used in spin loop, and several user code\nsuch as pthread directly takes cmpxchg as loop condition, which cause\nhuge cache bouncing.\n\nThis patch extends previous implementation to relax all cmpxchg\ninstruction under -mrelax-cmpxchg-loop with an extra atomic load,\ncompare and emulate the failed cmpxchg behavior.\n\nFor original spin loop which looks like\n\nloop: mov    %eax,%r8d\n      or     $1,%r8d\n      lock cmpxchg %r8d,(%rdi)\n      jne    loop\n\nIt will now truns to\n\nloop: mov    %eax,%r8d\n      or     $1,%r8d\n      mov    (%r8),%rsi <--- load lock first\n      cmp    %rsi,%rax <--- compare with expected input\n      jne    .L2 <--- lock ne expected\n      lock cmpxchg %r8d,(%rdi)\n      jne    loop\n  L2: mov    %rsi,%rax <--- perform the behavior of failed cmpxchg\n      jne    loop\n\nunder -mrelax-cmpxchg-loop.\n\ngcc/ChangeLog:\n\n\tPR target/103069\n\t* config/i386/i386-expand.cc (ix86_expand_atomic_fetch_op_loop):\n\tSplit atomic fetch and loop part.\n\t(ix86_expand_cmpxchg_loop): New expander for cmpxchg loop.\n\t* config/i386/i386-protos.h (ix86_expand_cmpxchg_loop): New\n\tprototype.\n\t* config/i386/sync.md (atomic_compare_and_swap<mode>): Call new\n\texpander under TARGET_RELAX_CMPXCHG_LOOP.\n\t(atomic_compare_and_swap<mode>): Likewise for doubleword modes.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/103069\n\t* gcc.target/i386/pr103069-2.c: Adjust result check.\n\t* gcc.target/i386/pr103069-3.c: New test.\n\t* gcc.target/i386/pr103069-4.c: Likewise.", "tree": {"sha": "09592c5a8432cbab97c1a18ad227007c5931e3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09592c5a8432cbab97c1a18ad227007c5931e3c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0435b978f95971e139882549f5a1765c50682216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435b978f95971e139882549f5a1765c50682216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0435b978f95971e139882549f5a1765c50682216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0435b978f95971e139882549f5a1765c50682216/comments", "author": {"login": "wwwhhhyyy", "id": 5366075, "node_id": "MDQ6VXNlcjUzNjYwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5366075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wwwhhhyyy", "html_url": "https://github.com/wwwhhhyyy", "followers_url": "https://api.github.com/users/wwwhhhyyy/followers", "following_url": "https://api.github.com/users/wwwhhhyyy/following{/other_user}", "gists_url": "https://api.github.com/users/wwwhhhyyy/gists{/gist_id}", "starred_url": "https://api.github.com/users/wwwhhhyyy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wwwhhhyyy/subscriptions", "organizations_url": "https://api.github.com/users/wwwhhhyyy/orgs", "repos_url": "https://api.github.com/users/wwwhhhyyy/repos", "events_url": "https://api.github.com/users/wwwhhhyyy/events{/privacy}", "received_events_url": "https://api.github.com/users/wwwhhhyyy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wwwhhhyyy", "id": 5366075, "node_id": "MDQ6VXNlcjUzNjYwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5366075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wwwhhhyyy", "html_url": "https://github.com/wwwhhhyyy", "followers_url": "https://api.github.com/users/wwwhhhyyy/followers", "following_url": "https://api.github.com/users/wwwhhhyyy/following{/other_user}", "gists_url": "https://api.github.com/users/wwwhhhyyy/gists{/gist_id}", "starred_url": "https://api.github.com/users/wwwhhhyyy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wwwhhhyyy/subscriptions", "organizations_url": "https://api.github.com/users/wwwhhhyyy/orgs", "repos_url": "https://api.github.com/users/wwwhhhyyy/repos", "events_url": "https://api.github.com/users/wwwhhhyyy/events{/privacy}", "received_events_url": "https://api.github.com/users/wwwhhhyyy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c105adbf22f5dfa11de08fc88ee06573b3c4305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c105adbf22f5dfa11de08fc88ee06573b3c4305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c105adbf22f5dfa11de08fc88ee06573b3c4305"}], "stats": {"total": 291, "additions": 226, "deletions": 65}, "files": [{"sha": "6cf1a0b9cb66e2a4c635de8c4a6c6d8bb2e43175", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 113, "deletions": 40, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435b978f95971e139882549f5a1765c50682216/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435b978f95971e139882549f5a1765c50682216/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=0435b978f95971e139882549f5a1765c50682216", "patch": "@@ -23203,16 +23203,14 @@ void ix86_expand_atomic_fetch_op_loop (rtx target, rtx mem, rtx val,\n \t\t\t\t       enum rtx_code code, bool after,\n \t\t\t\t       bool doubleword)\n {\n-  rtx old_reg, new_reg, old_mem, success, oldval, new_mem;\n-  rtx_code_label *loop_label, *pause_label, *done_label;\n+  rtx old_reg, new_reg, old_mem, success;\n   machine_mode mode = GET_MODE (target);\n+  rtx_code_label *loop_label = NULL;\n \n   old_reg = gen_reg_rtx (mode);\n   new_reg = old_reg;\n-  loop_label = gen_label_rtx ();\n-  pause_label = gen_label_rtx ();\n-  done_label = gen_label_rtx ();\n   old_mem = copy_to_reg (mem);\n+  loop_label = gen_label_rtx ();\n   emit_label (loop_label);\n   emit_move_insn (old_reg, old_mem);\n \n@@ -23234,50 +23232,125 @@ void ix86_expand_atomic_fetch_op_loop (rtx target, rtx mem, rtx val,\n   if (after)\n     emit_move_insn (target, new_reg);\n \n-  /* Load memory again inside loop.  */\n-  new_mem = copy_to_reg (mem);\n-  /* Compare mem value with expected value.  */\n+  success = NULL_RTX;\n+\n+  ix86_expand_cmpxchg_loop (&success, old_mem, mem, old_reg, new_reg,\n+\t\t\t    gen_int_mode (MEMMODEL_SYNC_SEQ_CST,\n+\t\t\t\t\t  SImode),\n+\t\t\t    doubleword, loop_label);\n+}\n+\n+/* Relax cmpxchg instruction, param loop_label indicates whether\n+   the instruction should be relaxed with a pause loop.  If not,\n+   it will be relaxed to an atomic load + compare, and skip\n+   cmpxchg instruction if mem != exp_input.  */\n+\n+void ix86_expand_cmpxchg_loop (rtx *ptarget_bool, rtx target_val,\n+\t\t\t       rtx mem, rtx exp_input, rtx new_input,\n+\t\t\t       rtx mem_model, bool doubleword,\n+\t\t\t       rtx_code_label *loop_label)\n+{\n+  rtx_code_label *cmp_label = NULL;\n+  rtx_code_label *done_label = NULL;\n+  rtx target_bool = NULL_RTX, new_mem = NULL_RTX;\n+  rtx (*gen) (rtx, rtx, rtx, rtx, rtx) = NULL;\n+  rtx (*gendw) (rtx, rtx, rtx, rtx, rtx, rtx) = NULL;\n+  machine_mode mode = GET_MODE (target_val), hmode = mode;\n+\n+  if (*ptarget_bool == NULL)\n+    target_bool = gen_reg_rtx (QImode);\n+  else\n+    target_bool = *ptarget_bool;\n+\n+  cmp_label = gen_label_rtx ();\n+  done_label = gen_label_rtx ();\n+\n+  new_mem = gen_reg_rtx (mode);\n+  /* Load memory first.  */\n+  expand_atomic_load (new_mem, mem, MEMMODEL_SEQ_CST);\n+\n+  switch (mode)\n+    {\n+    case TImode:\n+      gendw = gen_atomic_compare_and_swapti_doubleword;\n+      hmode = DImode;\n+      break;\n+    case DImode:\n+      if (doubleword)\n+\t{\n+\t  gendw = gen_atomic_compare_and_swapdi_doubleword;\n+\t  hmode = SImode;\n+\t}\n+      else\n+\tgen = gen_atomic_compare_and_swapdi_1;\n+      break;\n+    case SImode:\n+      gen = gen_atomic_compare_and_swapsi_1; break;\n+    case HImode:\n+      gen = gen_atomic_compare_and_swaphi_1; break;\n+    case QImode:\n+      gen = gen_atomic_compare_and_swapqi_1; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n+  /* Compare mem value with expected value.  */\n   if (doubleword)\n     {\n-      machine_mode half_mode = (mode == DImode)? SImode : DImode;\n-      rtx low_new_mem = gen_lowpart (half_mode, new_mem);\n-      rtx low_old_mem = gen_lowpart (half_mode, old_mem);\n-      rtx high_new_mem = gen_highpart (half_mode, new_mem);\n-      rtx high_old_mem = gen_highpart (half_mode, old_mem);\n-      emit_cmp_and_jump_insns (low_new_mem, low_old_mem, NE, NULL_RTX,\n-\t\t\t       half_mode, 1, pause_label,\n+      rtx low_new_mem = gen_lowpart (hmode, new_mem);\n+      rtx low_exp_input = gen_lowpart (hmode, exp_input);\n+      rtx high_new_mem = gen_highpart (hmode, new_mem);\n+      rtx high_exp_input = gen_highpart (hmode, exp_input);\n+      emit_cmp_and_jump_insns (low_new_mem, low_exp_input, NE, NULL_RTX,\n+\t\t\t       hmode, 1, cmp_label,\n \t\t\t       profile_probability::guessed_never ());\n-      emit_cmp_and_jump_insns (high_new_mem, high_old_mem, NE, NULL_RTX,\n-\t\t\t       half_mode, 1, pause_label,\n+      emit_cmp_and_jump_insns (high_new_mem, high_exp_input, NE, NULL_RTX,\n+\t\t\t       hmode, 1, cmp_label,\n \t\t\t       profile_probability::guessed_never ());\n     }\n   else\n-    emit_cmp_and_jump_insns (new_mem, old_mem, NE, NULL_RTX,\n-\t\t\t     GET_MODE (old_mem), 1, pause_label,\n+    emit_cmp_and_jump_insns (new_mem, exp_input, NE, NULL_RTX,\n+\t\t\t     GET_MODE (exp_input), 1, cmp_label,\n \t\t\t     profile_probability::guessed_never ());\n \n-  success = NULL_RTX;\n-  oldval = old_mem;\n-  expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,\n-\t\t\t\t  new_reg, false, MEMMODEL_SYNC_SEQ_CST,\n-\t\t\t\t  MEMMODEL_RELAXED);\n-  if (oldval != old_mem)\n-    emit_move_insn (old_mem, oldval);\n-\n-  emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n-\t\t\t   GET_MODE (success), 1, loop_label,\n-\t\t\t   profile_probability::guessed_never ());\n-\n-  emit_jump_insn (gen_jump (done_label));\n-  emit_barrier ();\n-\n-  /* If mem is not expected, pause and loop back.  */\n-  emit_label (pause_label);\n-  emit_insn (gen_pause ());\n-  emit_jump_insn (gen_jump (loop_label));\n-  emit_barrier ();\n-  emit_label (done_label);\n+  /* Directly emits cmpxchg here.  */\n+  if (doubleword)\n+    emit_insn (gendw (target_val, mem, exp_input,\n+\t\t      gen_lowpart (hmode, new_input),\n+\t\t      gen_highpart (hmode, new_input),\n+\t\t      mem_model));\n+  else\n+    emit_insn (gen (target_val, mem, exp_input, new_input, mem_model));\n+\n+  if (!loop_label)\n+  {\n+    emit_jump_insn (gen_jump (done_label));\n+    emit_barrier ();\n+    emit_label (cmp_label);\n+    emit_move_insn (target_val, new_mem);\n+    emit_label (done_label);\n+    ix86_expand_setcc (target_bool, EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n+\t\t       const0_rtx);\n+  }\n+  else\n+  {\n+    ix86_expand_setcc (target_bool, EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n+\t\t       const0_rtx);\n+    emit_cmp_and_jump_insns (target_bool, const0_rtx, EQ, const0_rtx,\n+\t\t\t     GET_MODE (target_bool), 1, loop_label,\n+\t\t\t     profile_probability::guessed_never ());\n+    emit_jump_insn (gen_jump (done_label));\n+    emit_barrier ();\n+\n+    /* If mem is not expected, pause and loop back.  */\n+    emit_label (cmp_label);\n+    emit_insn (gen_pause ());\n+    emit_jump_insn (gen_jump (loop_label));\n+    emit_barrier ();\n+    emit_label (done_label);\n+  }\n+\n+  *ptarget_bool = target_bool;\n }\n \n #include \"gt-i386-expand.h\""}, {"sha": "d5e11259a5a5a14f4a2366c8aaa5b5fc53914782", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435b978f95971e139882549f5a1765c50682216/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435b978f95971e139882549f5a1765c50682216/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=0435b978f95971e139882549f5a1765c50682216", "patch": "@@ -221,6 +221,8 @@ extern void ix86_split_mmx_punpck (rtx[], bool);\n extern void ix86_expand_avx_vzeroupper (void);\n extern void ix86_expand_atomic_fetch_op_loop (rtx, rtx, rtx, enum rtx_code,\n \t\t\t\t\t      bool, bool);\n+extern void ix86_expand_cmpxchg_loop (rtx *, rtx, rtx, rtx, rtx, rtx,\n+\t\t\t\t      bool, rtx_code_label *);\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);"}, {"sha": "820e9ca911ab29c0fff246b96711a6444f452d83", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435b978f95971e139882549f5a1765c50682216/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435b978f95971e139882549f5a1765c50682216/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=0435b978f95971e139882549f5a1765c50682216", "patch": "@@ -373,11 +373,20 @@\n    (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n   \"TARGET_CMPXCHG\"\n {\n-  emit_insn\n-   (gen_atomic_compare_and_swap<mode>_1\n-    (operands[1], operands[2], operands[3], operands[4], operands[6]));\n-  ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n-\t\t     const0_rtx);\n+  if (TARGET_RELAX_CMPXCHG_LOOP)\n+  {\n+    ix86_expand_cmpxchg_loop (&operands[0], operands[1], operands[2],\n+\t\t\t      operands[3], operands[4], operands[6],\n+\t\t\t      false, NULL);\n+  }\n+  else\n+  {\n+    emit_insn\n+      (gen_atomic_compare_and_swap<mode>_1\n+\t(operands[1], operands[2], operands[3], operands[4], operands[6]));\n+      ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n+\t\t\tconst0_rtx);\n+  }\n   DONE;\n })\n \n@@ -397,25 +406,35 @@\n    (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n   \"TARGET_CMPXCHG\"\n {\n-  if (<MODE>mode == DImode && TARGET_64BIT)\n-    {\n-      emit_insn\n-       (gen_atomic_compare_and_swapdi_1\n-\t(operands[1], operands[2], operands[3], operands[4], operands[6]));\n-    }\n+  int doubleword = !(<MODE>mode == DImode && TARGET_64BIT);\n+  if (TARGET_RELAX_CMPXCHG_LOOP)\n+  {\n+    ix86_expand_cmpxchg_loop (&operands[0], operands[1], operands[2],\n+\t\t\t      operands[3], operands[4], operands[6],\n+\t\t\t      doubleword, NULL);\n+  }\n   else\n-    {\n-      machine_mode hmode = <CASHMODE>mode;\n-\n-      emit_insn\n-       (gen_atomic_compare_and_swap<mode>_doubleword\n-        (operands[1], operands[2], operands[3],\n-\t gen_lowpart (hmode, operands[4]), gen_highpart (hmode, operands[4]),\n-\t operands[6]));\n-    }\n-\n-  ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n-\t\t     const0_rtx);\n+  {\n+    if (!doubleword)\n+      {\n+\temit_insn\n+\t  (gen_atomic_compare_and_swapdi_1\n+\t   (operands[1], operands[2], operands[3], operands[4], operands[6]));\n+      }\n+    else\n+      {\n+\tmachine_mode hmode = <CASHMODE>mode;\n+\n+\temit_insn\n+\t  (gen_atomic_compare_and_swap<mode>_doubleword\n+\t   (operands[1], operands[2], operands[3],\n+\t    gen_lowpart (hmode, operands[4]), gen_highpart (hmode, operands[4]),\n+\t    operands[6]));\n+      }\n+\n+    ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n+\t\t       const0_rtx);\n+  }\n   DONE;\n })\n "}, {"sha": "2ceb54e013ac485809f6f1784beed017ae6403f9", "filename": "gcc/testsuite/gcc.target/i386/pr103069-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435b978f95971e139882549f5a1765c50682216/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435b978f95971e139882549f5a1765c50682216/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-2.c?ref=0435b978f95971e139882549f5a1765c50682216", "patch": "@@ -40,12 +40,12 @@ FUNC_ATOMIC_RELAX (char, xor)\n   TYPE c = 11, d = 101;\t\\\n   res = relax_##TYPE##_##OP##_fetch (&a, b); \\\n   exp = f_##TYPE##_##OP##_fetch (&c, d);  \\\n-  if (res != exp) \\\n+  if (res != exp || a != c) \\\n     abort (); \\\n   a = c = 21, b = d = 92; \\\n   res = relax_##TYPE##_fetch_##OP (&a, b); \\\n   exp = f_##TYPE##_fetch_##OP (&c, d);  \\\n-  if (res != exp) \\\n+  if (res != exp || a != c) \\\n     abort (); \\\n }\n "}, {"sha": "fee708905ec706393a042fe984ac8d45b2d493d4", "filename": "gcc/testsuite/gcc.target/i386/pr103069-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435b978f95971e139882549f5a1765c50682216/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435b978f95971e139882549f5a1765c50682216/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-3.c?ref=0435b978f95971e139882549f5a1765c50682216", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/103068 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O2 -march=x86-64 -mtune=generic -mrelax-cmpxchg-loop\" } */ \n+\n+#include <stdint.h>\n+\n+#define FUNC_CMPXCHG(TYPE) \\\n+__attribute__ ((noinline, noclone))\t\\\n+TYPE f_##TYPE##_cmpxchg (TYPE *lock, TYPE newval, TYPE oldval)  \\\n+{ \\\n+  do  \\\n+  { \\\n+    newval = oldval | 1;  \\\n+  } while (! __atomic_compare_exchange_n (lock, &oldval, newval,  \\\n+\t\t\t\t\t  0, __ATOMIC_RELEASE,  \\\n+\t\t\t\t\t  __ATOMIC_RELAXED));  \\\n+  return *lock;\t\\\n+}\n+\n+\n+FUNC_CMPXCHG (int64_t)\n+FUNC_CMPXCHG (int)\n+FUNC_CMPXCHG (short)\n+FUNC_CMPXCHG (char)"}, {"sha": "5abcbca2a98b01adbe41da9b87559a0941d43d29", "filename": "gcc/testsuite/gcc.target/i386/pr103069-4.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0435b978f95971e139882549f5a1765c50682216/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0435b978f95971e139882549f5a1765c50682216/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103069-4.c?ref=0435b978f95971e139882549f5a1765c50682216", "patch": "@@ -0,0 +1,43 @@\n+/* PR target/103069 */\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2 -march=x86-64 -mtune=generic\" } */ \n+\n+#include <stdlib.h>\n+#include \"pr103069-3.c\"\n+\n+#define FUNC_CMPXCHG_RELAX(TYPE) \\\n+__attribute__ ((noinline, noclone, target (\"relax-cmpxchg-loop\")))\t\\\n+TYPE relax_##TYPE##_cmpxchg (TYPE *lock, TYPE newval, TYPE oldval)  \\\n+{ \\\n+  do  \\\n+  { \\\n+    newval = oldval | 1;  \\\n+  } while (! __atomic_compare_exchange_n (lock, &oldval, newval,  \\\n+\t\t\t\t\t  0, __ATOMIC_RELEASE,  \\\n+\t\t\t\t\t  __ATOMIC_RELAXED));  \\\n+  return *lock;\t\\\n+}\n+\n+FUNC_CMPXCHG_RELAX (int64_t)\n+FUNC_CMPXCHG_RELAX (int)\n+FUNC_CMPXCHG_RELAX (short)\n+FUNC_CMPXCHG_RELAX (char)\n+\n+#define TEST_CMPXCHG_LOOP(TYPE)\t\\\n+{ \\\n+  TYPE a = 11, b = 20, c = 11, res, exp; \\\n+  TYPE d = 11, e = 20, f = 11;\t\\\n+  res = relax_##TYPE##_cmpxchg (&a, b, c); \\\n+  exp = f_##TYPE##_cmpxchg (&d, e, f); \\\n+  if (res != exp || a != d) \\\n+    abort (); \\\n+}\n+\n+int main (void)\n+{\n+  TEST_CMPXCHG_LOOP (int64_t)\n+  TEST_CMPXCHG_LOOP (int)\n+  TEST_CMPXCHG_LOOP (short)\n+  TEST_CMPXCHG_LOOP (char)\n+  return 0;\n+}"}]}