{"sha": "211bea6b40bfa457a9e8619cf653227206736e76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjExYmVhNmI0MGJmYTQ1N2E5ZTg2MTljZjY1MzIyNzIwNjczNmU3Ng==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-11-13T09:05:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-11-13T09:05:20Z"}, "message": "GCOV: introduce global vector of functions\n\n2017-11-13  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (read_graph_file): Store to global vector of functions.\n\t(read_count_file): Iterate the vector.\n\t(process_file): Likewise.\n\t(generate_results): Likewise.\n\t(release_structures): Likewise.\n\nFrom-SVN: r254672", "tree": {"sha": "a0f4cfcab205fc31c28cf7a2b8142ba15430131a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0f4cfcab205fc31c28cf7a2b8142ba15430131a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/211bea6b40bfa457a9e8619cf653227206736e76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211bea6b40bfa457a9e8619cf653227206736e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/211bea6b40bfa457a9e8619cf653227206736e76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211bea6b40bfa457a9e8619cf653227206736e76/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bfd2f9bc61af31a8ada151a6e841b10e37b302c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bfd2f9bc61af31a8ada151a6e841b10e37b302c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bfd2f9bc61af31a8ada151a6e841b10e37b302c"}], "stats": {"total": 118, "additions": 52, "deletions": 66}, "files": [{"sha": "0261faffc6765010932699a88c6054843eba47ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211bea6b40bfa457a9e8619cf653227206736e76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211bea6b40bfa457a9e8619cf653227206736e76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=211bea6b40bfa457a9e8619cf653227206736e76", "patch": "@@ -1,3 +1,11 @@\n+2017-11-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (read_graph_file): Store to global vector of functions.\n+\t(read_count_file): Iterate the vector.\n+\t(process_file): Likewise.\n+\t(generate_results): Likewise.\n+\t(release_structures): Likewise.\n+\n 2017-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/82954"}, {"sha": "71239cf0cbd1bced40122361457a008d64ddd913", "filename": "gcc/gcov.c", "status": "modified", "additions": 44, "deletions": 66, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211bea6b40bfa457a9e8619cf653227206736e76/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211bea6b40bfa457a9e8619cf653227206736e76/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=211bea6b40bfa457a9e8619cf653227206736e76", "patch": "@@ -392,10 +392,8 @@ class name_map\n   unsigned src;  /* Source file */\n };\n \n-/* Holds a list of function basic block graphs.  */\n-\n-static function_t *functions;\n-static function_t **fn_end = &functions;\n+/* Vector of all functions.  */\n+static vector<function_t *> functions;\n \n /* Vector of source files.  */\n static vector<source_info> sources;\n@@ -535,8 +533,8 @@ static void generate_results (const char *);\n static void create_file_names (const char *);\n static char *canonicalize_name (const char *);\n static unsigned find_source (const char *);\n-static function_t *read_graph_file (void);\n-static int read_count_file (function_t *);\n+static void read_graph_file (void);\n+static int read_count_file (void);\n static void solve_flow_graph (function_t *);\n static void find_exception_blocks (function_t *);\n static void add_branch_counts (coverage_t *, const arc_t *);\n@@ -1125,42 +1123,40 @@ struct function_start_pair_hash : typed_noop_remove <function_start>\n static void\n process_file (const char *file_name)\n {\n-  function_t *fns;\n-\n   create_file_names (file_name);\n-  fns = read_graph_file ();\n-  if (!fns)\n+  read_graph_file ();\n+  if (functions.empty ())\n     return;\n \n-  read_count_file (fns);\n+  read_count_file ();\n \n   hash_map<function_start_pair_hash, function_t *> fn_map;\n \n   /* Identify group functions.  */\n-  for (function_t *f = fns; f; f = f->next)\n-    if (!f->artificial)\n+  for (vector<function_t *>::iterator it = functions.begin ();\n+       it != functions.end (); it++)\n+    if (!(*it)->artificial)\n       {\n \tfunction_start needle;\n-\tneedle.source_file_idx = f->src;\n-\tneedle.start_line = f->start_line;\n+\tneedle.source_file_idx = (*it)->src;\n+\tneedle.start_line = (*it)->start_line;\n \n \tfunction_t **slot = fn_map.get (needle);\n \tif (slot)\n \t  {\n-\t    gcc_assert ((*slot)->end_line == f->end_line);\n+\t    gcc_assert ((*slot)->end_line == (*it)->end_line);\n \t    (*slot)->is_group = 1;\n-\t    f->is_group = 1;\n+\t    (*it)->is_group = 1;\n \t  }\n \telse\n-\t  fn_map.put (needle, f);\n+\t  fn_map.put (needle, *it);\n       }\n \n-  while (fns)\n+  for (vector<function_t *>::iterator it = functions.begin ();\n+       it != functions.end (); it++)\n     {\n-      function_t *fn = fns;\n+      function_t *fn = *it;\n \n-      fns = fn->next;\n-      fn->next = NULL;\n       if (fn->counts || no_data_file)\n \t{\n \t  unsigned src = fn->src;\n@@ -1207,14 +1203,12 @@ process_file (const char *file_name)\n \t      if (fn->has_catch)\n \t\tfind_exception_blocks (fn);\n \t    }\n-\n-\t  *fn_end = fn;\n-\t  fn_end = &fn->next;\n \t}\n       else\n-\t/* The function was not in the executable -- some other\n-\t   instance must have been selected.  */\n-\tdelete fn;\n+\t{\n+\t  /* The function was not in the executable -- some other\n+\t     instance must have been selected.  */\n+\t}\n     }\n }\n \n@@ -1249,12 +1243,13 @@ output_gcov_file (const char *file_name, source_info *src)\n static void\n generate_results (const char *file_name)\n {\n-  function_t *fn;\n   FILE *gcov_intermediate_file = NULL;\n   char *gcov_intermediate_filename = NULL;\n \n-  for (fn = functions; fn; fn = fn->next)\n+  for (vector<function_t *>::iterator it = functions.begin ();\n+       it != functions.end (); it++)\n     {\n+      function_t *fn = *it;\n       coverage_t coverage;\n       if (fn->artificial)\n \tcontinue;\n@@ -1345,18 +1340,13 @@ generate_results (const char *file_name)\n static void\n release_structures (void)\n {\n-  function_t *fn;\n+  for (vector<function_t *>::iterator it = functions.begin ();\n+       it != functions.end (); it++)\n+    delete (*it);\n \n   sources.resize (0);\n   names.resize (0);\n-\n-  while ((fn = functions))\n-    {\n-      functions = fn->next;\n-      delete fn;\n-    }\n-\n-  fn_end = &functions;\n+  functions.resize (0);\n }\n \n /* Generate the names of the graph and data files.  If OBJECT_DIRECTORY\n@@ -1514,29 +1504,26 @@ find_source (const char *file_name)\n   return idx;\n }\n \n-/* Read the notes file.  Return list of functions read -- in reverse order.  */\n+/* Read the notes file.  Save functions to FUNCTIONS global vector.  */\n \n-static function_t *\n+static void\n read_graph_file (void)\n {\n   unsigned version;\n   unsigned current_tag = 0;\n-  function_t *fn = NULL;\n-  function_t *fns = NULL;\n-  function_t **fns_end = &fns;\n   unsigned tag;\n \n   if (!gcov_open (bbg_file_name, 1))\n     {\n       fnotice (stderr, \"%s:cannot open notes file\\n\", bbg_file_name);\n-      return fns;\n+      return;\n     }\n   bbg_file_time = gcov_time ();\n   if (!gcov_magic (gcov_read_unsigned (), GCOV_NOTE_MAGIC))\n     {\n       fnotice (stderr, \"%s:not a gcov notes file\\n\", bbg_file_name);\n       gcov_close ();\n-      return fns;\n+      return;\n     }\n \n   version = gcov_read_unsigned ();\n@@ -1553,6 +1540,7 @@ read_graph_file (void)\n   bbg_stamp = gcov_read_unsigned ();\n   bbg_supports_has_unexecuted_blocks = gcov_read_unsigned ();\n \n+  function_t *fn = NULL;\n   while ((tag = gcov_read_unsigned ()))\n     {\n       unsigned length = gcov_read_unsigned ();\n@@ -1574,7 +1562,8 @@ read_graph_file (void)\n \t  unsigned start_column = gcov_read_unsigned ();\n \t  unsigned end_line = gcov_read_unsigned ();\n \n-\t  fn = new function_t;\n+\t  fn = new function_t ();\n+\t  functions.push_back (fn);\n \t  fn->name = function_name;\n \t  if (flag_demangled_names)\n \t    {\n@@ -1591,9 +1580,6 @@ read_graph_file (void)\n \t  fn->end_line = end_line;\n \t  fn->artificial = artificial;\n \n-\t  fn->next = NULL;\n-\t  *fns_end = fn;\n-\t  fns_end = &fn->next;\n \t  current_tag = tag;\n \t}\n       else if (fn && tag == GCOV_TAG_BLOCKS)\n@@ -1719,17 +1705,15 @@ read_graph_file (void)\n     }\n   gcov_close ();\n \n-  if (!fns)\n+  if (functions.empty ())\n     fnotice (stderr, \"%s:no functions found\\n\", bbg_file_name);\n-\n-  return fns;\n }\n \n /* Reads profiles from the count file and attach to each\n    function. Return nonzero if fatal error.  */\n \n static int\n-read_count_file (function_t *fns)\n+read_count_file (void)\n {\n   unsigned ix;\n   unsigned version;\n@@ -1786,26 +1770,20 @@ read_count_file (function_t *fns)\n       else if (tag == GCOV_TAG_FUNCTION && length == GCOV_TAG_FUNCTION_LENGTH)\n \t{\n \t  unsigned ident;\n-\t  struct function_info *fn_n;\n \n \t  /* Try to find the function in the list.  To speed up the\n \t     search, first start from the last function found.  */\n \t  ident = gcov_read_unsigned ();\n-\t  fn_n = fns;\n-\t  for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n+\n+\t  fn = NULL;\n+\t  for (vector<function_t *>::reverse_iterator it = functions.rbegin ();\n+\t       it != functions.rend (); it++)\n \t    {\n-\t      if (fn)\n-\t\t;\n-\t      else if ((fn = fn_n))\n-\t\tfn_n = NULL;\n-\t      else\n+\t      if ((*it)->ident == ident)\n \t\t{\n-\t\t  fnotice (stderr, \"%s:unknown function '%u'\\n\",\n-\t\t\t   da_file_name, ident);\n+\t\t  fn = *it;\n \t\t  break;\n \t\t}\n-\t      if (fn->ident == ident)\n-\t\tbreak;\n \t    }\n \n \t  if (!fn)"}]}