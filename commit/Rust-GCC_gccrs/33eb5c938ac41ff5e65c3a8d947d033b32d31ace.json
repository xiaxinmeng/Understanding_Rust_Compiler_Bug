{"sha": "33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "node_id": "C_kwDOANBUbNoAKDMzZWI1YzkzOGFjNDFmZjVlNjVjM2E4ZDk0N2QwMzNiMzJkMzFhY2U", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-08T09:29:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-08T09:29:00Z"}, "message": "Merge #1371\n\n1371: typecheck: Refactor TypeCheckTopLevel class r=CohenArthur a=CohenArthur\n\nThis commit moves the TypeCheckTopLevel implementation into its own\r\nsource file, and factors generic parameter resolving into a single\r\nfunction\r\n\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "f6f13a20af938cad3702bb195f2a482de01b953e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6f13a20af938cad3702bb195f2a482de01b953e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJix/jcCRBK7hj4Ov3rIwAALxIIAH7NDGpVqHUZgQ2ZmVArIEss\n0GudtxxLV5pq3L0AKfl8LTq7NuY4oQNeIgFbwIBnwOgJqd8qWs9a2UwLda9jAgMz\nQZyXWPBUnGQVeybFvmctfCvYwtbvpWsoOj7lCxkxqpWN4QwV0GfOIypM0tMFFFbm\nqIDtBlCXs7TU54d2N7A60xk4r1BnMfyRbZByqhYelyG+8qRpB5CO6me0URRsjhBH\nP7BTvQN/jn7EwHu9D77bgJ2Xhp62dglZzBzqSxNRQxf8Q+OLe9uv+bT8R6X0QM3T\nB1GKxSTXobGM8Xey3LGBS0bc6RXckD+ACWMutWuUkKTewgY/5+jNsOQ57KMFpZ8=\n=60aY\n-----END PGP SIGNATURE-----\n", "payload": "tree f6f13a20af938cad3702bb195f2a482de01b953e\nparent b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e\nparent b941670e38d0150da2eb7372427d8550c8a4b6aa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657272540 +0000\ncommitter GitHub <noreply@github.com> 1657272540 +0000\n\nMerge #1371\n\n1371: typecheck: Refactor TypeCheckTopLevel class r=CohenArthur a=CohenArthur\n\nThis commit moves the TypeCheckTopLevel implementation into its own\r\nsource file, and factors generic parameter resolving into a single\r\nfunction\r\n\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c9ac14a06a2c0dd4acb8758f3c88c2c610a31e"}, {"sha": "b941670e38d0150da2eb7372427d8550c8a4b6aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b941670e38d0150da2eb7372427d8550c8a4b6aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b941670e38d0150da2eb7372427d8550c8a4b6aa"}], "stats": {"total": 875, "additions": 402, "deletions": 473}, "files": [{"sha": "c2782e9e3983bfe1b38fa961e5a9579dd280c6e1", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "patch": "@@ -110,6 +110,7 @@ GRS_OBJS = \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n+    rust/rust-hir-type-check-toplevel.o \\\n     rust/rust-hir-type-check-item.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\"}, {"sha": "e46d312fa326723071c327c6b6794e876f9329e4", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.cc", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc?ref=33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "patch": "@@ -0,0 +1,384 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-toplevel.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckTopLevel::Resolve (HIR::Item *item)\n+{\n+  TypeCheckTopLevel resolver;\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+TypeCheckTopLevel::resolve_generic_params (\n+  const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n+  std::vector<TyTy::SubstitutionParamMapping> &substitutions)\n+{\n+  for (auto &generic_param : generic_params)\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\tcase HIR::GenericParam::GenericKind::CONST:\n+\t  // FIXME: Skipping Lifetime and Const completely until better\n+\t  // handling.\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t      static_cast<HIR::TypeParam &> (*generic_param), param_type));\n+\t  }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::TypeAlias &alias)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+  context->insert_type (alias.get_mappings (), actual_type);\n+\n+  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::TupleStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_crate_num (),\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // its a single variant ADT\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+\n+  // Process #[repr(X)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    TypeCheckTopLevel::Resolve (item.get ());\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::StructStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type);\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_crate_num (),\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // its a single variant ADT\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  // Process #[repr(X)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Enum &enum_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (enum_decl.has_generics ())\n+    resolve_generic_params (enum_decl.get_generic_params (), substitutions);\n+\n+  std::vector<TyTy::VariantDef *> variants;\n+  int64_t discriminant_value = 0;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      TyTy::VariantDef *field_type\n+\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+      discriminant_value++;\n+      variants.push_back (field_type);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    enum_decl.get_mappings ().get_crate_num (),\n+    enum_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n+  // multi variant ADT\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t enum_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (enum_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Union &union_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (union_decl.has_generics ())\n+    resolve_generic_params (union_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &variant : union_decl.get_variants ())\n+    {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type);\n+      fields.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    union_decl.get_mappings ().get_crate_num (),\n+    union_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t union_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (union_decl.get_mappings (), type);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::StaticItem &var)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n+\n+  context->insert_type (var.get_mappings (), type->unify (expr_type));\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::Function &function)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (function.has_generics ())\n+    resolve_generic_params (function.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n+    {\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n+\t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *>> params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    function.get_mappings ().get_crate_num (),\n+    function.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n+\t\t\t\t  std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::ImplBlock &impl_block)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (impl_block.has_generics ())\n+    resolve_generic_params (impl_block.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n+  if (self->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self, substitutions);\n+}\n+\n+void\n+TypeCheckTopLevel::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      TypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "fdc13f7684d1f22f095d2ce36ff3f3ebb6d8be12", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 17, "deletions": 473, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33eb5c938ac41ff5e65c3a8d947d033b32d31ace/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=33eb5c938ac41ff5e65c3a8d947d033b32d31ace", "patch": "@@ -35,482 +35,26 @@ class TypeCheckTopLevel : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static void Resolve (HIR::Item *item)\n-  {\n-    TypeCheckTopLevel resolver;\n-    item->accept_vis (resolver);\n-  }\n-\n-  void visit (HIR::TypeAlias &alias) override\n-  {\n-    TyTy::BaseType *actual_type\n-      = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n-\n-    context->insert_type (alias.get_mappings (), actual_type);\n-\n-    for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-  }\n-\n-  void visit (HIR::TupleStruct &struct_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : struct_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    size_t idx = 0;\n-    for (auto &field : struct_decl.get_fields ())\n-      {\n-\tTyTy::BaseType *field_type\n-\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_field\n-\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t       std::to_string (idx), field_type);\n-\tfields.push_back (ty_field);\n-\tcontext->insert_type (field.get_mappings (),\n-\t\t\t      ty_field->get_field_type ());\n-\tidx++;\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      struct_decl.get_mappings ().get_crate_num (),\n-      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-    // its a single variant ADT\n-    std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (\n-      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t    struct_decl.get_identifier (), ident,\n-\t\t\t    TyTy::VariantDef::VariantType::TUPLE, nullptr,\n-\t\t\t    std::move (fields)));\n-\n-    // Process #[repr(X)] attribute, if any\n-    const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-    TyTy::ADTType::ReprOptions repr\n-      = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t   std::move (variants), std::move (substitutions),\n-\t\t\t   repr);\n-\n-    context->insert_type (struct_decl.get_mappings (), type);\n-  }\n-\n-  void visit (HIR::Module &module) override\n-  {\n-    for (auto &item : module.get_items ())\n-      TypeCheckTopLevel::Resolve (item.get ());\n-  }\n-\n-  void visit (HIR::StructStruct &struct_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : struct_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    for (auto &field : struct_decl.get_fields ())\n-      {\n-\tTyTy::BaseType *field_type\n-\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_field\n-\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t       field.get_field_name (), field_type);\n-\tfields.push_back (ty_field);\n-\tcontext->insert_type (field.get_mappings (),\n-\t\t\t      ty_field->get_field_type ());\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      struct_decl.get_mappings ().get_crate_num (),\n-      struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-    // its a single variant ADT\n-    std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (\n-      new TyTy::VariantDef (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t    struct_decl.get_identifier (), ident,\n-\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n-\t\t\t    std::move (fields)));\n-\n-    // Process #[repr(X)] attribute, if any\n-    const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-    TyTy::ADTType::ReprOptions repr\n-      = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   struct_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t   std::move (variants), std::move (substitutions),\n-\t\t\t   repr);\n-\n-    context->insert_type (struct_decl.get_mappings (), type);\n-  }\n-\n-  void visit (HIR::Enum &enum_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (enum_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : enum_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    std::vector<TyTy::VariantDef *> variants;\n-    int64_t discriminant_value = 0;\n-    for (auto &variant : enum_decl.get_variants ())\n-      {\n-\tTyTy::VariantDef *field_type\n-\t  = TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n-\n-\tdiscriminant_value++;\n-\tvariants.push_back (field_type);\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      enum_decl.get_mappings ().get_crate_num (),\n-      enum_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n-\n-    // multi variant ADT\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   enum_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n-\t\t\t   std::move (substitutions));\n-\n-    context->insert_type (enum_decl.get_mappings (), type);\n-  }\n-\n-  void visit (HIR::Union &union_decl) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (union_decl.has_generics ())\n-      {\n-\tfor (auto &generic_param : union_decl.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-\n-    std::vector<TyTy::StructFieldType *> fields;\n-    for (auto &variant : union_decl.get_variants ())\n-      {\n-\tTyTy::BaseType *variant_type\n-\t  = TypeCheckType::Resolve (variant.get_field_type ().get ());\n-\tTyTy::StructFieldType *ty_variant\n-\t  = new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t       variant.get_field_name (), variant_type);\n-\tfields.push_back (ty_variant);\n-\tcontext->insert_type (variant.get_mappings (),\n-\t\t\t      ty_variant->get_field_type ());\n-      }\n-\n-    // get the path\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      union_decl.get_mappings ().get_crate_num (),\n-      union_decl.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    RustIdent ident{*canonical_path, union_decl.get_locus ()};\n-\n-    // there is only a single variant\n-    std::vector<TyTy::VariantDef *> variants;\n-    variants.push_back (\n-      new TyTy::VariantDef (union_decl.get_mappings ().get_hirid (),\n-\t\t\t    union_decl.get_identifier (), ident,\n-\t\t\t    TyTy::VariantDef::VariantType::STRUCT, nullptr,\n-\t\t\t    std::move (fields)));\n-\n-    TyTy::BaseType *type\n-      = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n-\t\t\t   mappings->get_next_hir_id (),\n-\t\t\t   union_decl.get_identifier (), ident,\n-\t\t\t   TyTy::ADTType::ADTKind::UNION, std::move (variants),\n-\t\t\t   std::move (substitutions));\n-\n-    context->insert_type (union_decl.get_mappings (), type);\n-  }\n-\n-  void visit (HIR::StaticItem &var) override\n-  {\n-    TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());\n-    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n-\n-    context->insert_type (var.get_mappings (), type->unify (expr_type));\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n-\n-    context->insert_type (constant.get_mappings (), type->unify (expr_type));\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic_param : function.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    for (auto &where_clause_item : function.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-\n-    TyTy::BaseType *ret_type = nullptr;\n-    if (!function.has_function_return_type ())\n-      ret_type = TyTy::TupleType::get_unit_type (\n-\tfunction.get_mappings ().get_hirid ());\n-    else\n-      {\n-\tauto resolved\n-\t  = TypeCheckType::Resolve (function.get_return_type ().get ());\n-\tif (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (function.get_locus (),\n-\t\t\t   \"failed to resolve return type\");\n-\t    return;\n-\t  }\n-\n-\tret_type = resolved->clone ();\n-\tret_type->set_ref (\n-\t  function.get_return_type ()->get_mappings ().get_hirid ());\n-      }\n-\n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-    for (auto &param : function.get_function_params ())\n-      {\n-\t// get the name as well required for later on\n-\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-\tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t       param_tyty));\n-\n-\tcontext->insert_type (param.get_mappings (), param_tyty);\n-\tTypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n-      }\n-\n-    const CanonicalPath *canonical_path = nullptr;\n-    bool ok = mappings->lookup_canonical_path (\n-      function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    RustIdent ident{*canonical_path, function.get_locus ()};\n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (), ident,\n-\t\t\t\t    TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n-\t\t\t\t    ABI::RUST, std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n-\n-    context->insert_type (function.get_mappings (), fnType);\n-  }\n-\n-  void visit (HIR::ImplBlock &impl_block) override\n-  {\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic_param : impl_block.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      case HIR::GenericParam::GenericKind::CONST:\n-\t\t// FIXME: Skipping Lifetime and Const completely until better\n-\t\t// handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n-\n-    for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n-      {\n-\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-      }\n-\n-    auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n-    if (self->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self,\n-\t\t\t\t\t  substitutions);\n-  }\n-\n-  void visit (HIR::ExternBlock &extern_block) override\n-  {\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tTypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n-      }\n-  }\n+  static void Resolve (HIR::Item *item);\n+\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::TupleStruct &struct_decl) override;\n+  void visit (HIR::Module &module) override;\n+  void visit (HIR::StructStruct &struct_decl) override;\n+  void visit (HIR::Enum &enum_decl) override;\n+  void visit (HIR::Union &union_decl) override;\n+  void visit (HIR::StaticItem &var) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::ImplBlock &impl_block) override;\n+  void visit (HIR::ExternBlock &extern_block) override;\n \n private:\n   TypeCheckTopLevel () : TypeCheckBase () {}\n+\n+  void resolve_generic_params (\n+    const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n+    std::vector<TyTy::SubstitutionParamMapping> &substitutions);\n };\n \n } // namespace Resolver"}]}