{"sha": "9b81593bbcb4151c135af547647cb9b65ecbd6bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI4MTU5M2JiY2I0MTUxYzEzNWFmNTQ3NjQ3Y2I5YjY1ZWNiZDZiZA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-12-09T20:01:04Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-12-09T20:01:04Z"}, "message": "hashtable.h (_Hashtable<>::emplace, [...]): Add.\n\n2011-12-09  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable.h (_Hashtable<>::emplace,\n\t_Hashtable<>::emplace_hint): Add.\n\t* include/debug/unordered_set (unordered_set<>::emplace,\n\tunordered_set<>::emplace_hint, unordered_multiset<>::emplace,\n\tunordered_multiset<>::emplace_hint): Add.\n\t* include/profile/unordered_set: Likewise.\n\t* include/debug/unordered_map (unordered_map<>::emplace,\n\tunordered_map<>::emplace_hint, unordered_multimap<>::emplace,\n\tunordered_multimap<>::emplace_hint): Add.\n\t* include/profile/unordered_map: Likewise.\n\t* testsuite/23_containers/unordered_map/modifiers/emplace.cc: New.\n\t* testsuite/23_containers/unordered_multimap/modifiers/emplace.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_set/modifiers/emplace.cc: New.\n\t* testsuite/23_containers/unordered_multiset/modifiers/emplace.cc:\n\tNew.\n\t* testsuite/util/testsuite_container_traits.h\n\t(traits_base::has_emplace): Add and defined as std::true_type for\n\tunordered containers.\n\t* testsuite/util/exception/safety.h (emplace, emplace_hint): Add and\n\tuse them in basic_safety exception test case.\n\t* doc/xml/manual/status_cxx2011.xml: Update unordered containers\n\tstatus.\n\nFrom-SVN: r182174", "tree": {"sha": "dba467050250a28c9ead1c5187c57648cec07cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dba467050250a28c9ead1c5187c57648cec07cd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b81593bbcb4151c135af547647cb9b65ecbd6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b81593bbcb4151c135af547647cb9b65ecbd6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b81593bbcb4151c135af547647cb9b65ecbd6bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b81593bbcb4151c135af547647cb9b65ecbd6bd/comments", "author": null, "committer": null, "parents": [{"sha": "60ef5d4e7fcf2789986bcf24e2db82dc0ef79bab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60ef5d4e7fcf2789986bcf24e2db82dc0ef79bab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60ef5d4e7fcf2789986bcf24e2db82dc0ef79bab"}], "stats": {"total": 785, "additions": 780, "deletions": 5}, "files": [{"sha": "5ade2a00bd1dc747b403b2fcc85389ab62be8a92", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -1,3 +1,29 @@\n+2011-12-09  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable.h (_Hashtable<>::emplace,\n+\t_Hashtable<>::emplace_hint): Add.\n+\t* include/debug/unordered_set (unordered_set<>::emplace,\n+\tunordered_set<>::emplace_hint, unordered_multiset<>::emplace,\n+\tunordered_multiset<>::emplace_hint): Add.\n+\t* include/profile/unordered_set: Likewise.\n+\t* include/debug/unordered_map (unordered_map<>::emplace,\n+\tunordered_map<>::emplace_hint, unordered_multimap<>::emplace,\n+\tunordered_multimap<>::emplace_hint): Add.\n+\t* include/profile/unordered_map: Likewise.\n+\t* testsuite/23_containers/unordered_map/modifiers/emplace.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/modifiers/emplace.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_set/modifiers/emplace.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/modifiers/emplace.cc:\n+\tNew.\n+\t* testsuite/util/testsuite_container_traits.h\n+\t(traits_base::has_emplace): Add and defined as std::true_type for\n+\tunordered containers.\n+\t* testsuite/util/exception/safety.h (emplace, emplace_hint): Add and\n+\tuse them in basic_safety exception test case.\n+\t* doc/xml/manual/status_cxx2011.xml: Update unordered containers\n+\tstatus.\n+\n 2011-12-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/atomic_base.h (__calculate_memory_order): Rename to..."}, {"sha": "1f39ce5e5b83e10fc253a16da0153769b131e518", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2011.xml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2011.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2011.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2011.xml?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -1403,11 +1403,10 @@ particular release.\n       <entry>Missing emplace members</entry>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#B0B0B0\" ?>\n       <entry>23.2.5</entry>\n       <entry>Unordered associative containers</entry>\n-      <entry>Partial</entry>\n-      <entry>Missing emplace members</entry>\n+      <entry>Y</entry>\n+      <entry/>\n     </row>\n     <row>\n       <entry>23.3</entry>"}, {"sha": "3874cbc5a6451175587c29b8fc3864b7bf887204", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 142, "deletions": 2, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -467,6 +467,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Insert_Conv_Type;\n \n     protected:\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\t_M_emplace(std::true_type, _Args&&... __args);\n+\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace(std::false_type, _Args&&... __args);\n+\n       template<typename _Arg>\n \tstd::pair<iterator, bool>\n \t_M_insert(_Arg&&, std::true_type);\n@@ -476,7 +484,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_insert(_Arg&&, std::false_type);\n \n     public:\n-      // Insert and erase\n+      // Emplace, insert and erase\n+      template<typename... _Args>\n+\t_Insert_Return_Type\n+\templace(_Args&&... __args)\n+\t{ return _M_emplace(integral_constant<bool, __unique_keys>(),\n+\t\t\t    std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator, _Args&&... __args)\n+\t{ return _Insert_Conv_Type()(emplace(std::forward<_Args>(__args)...)); }\n+\n       _Insert_Return_Type\n       insert(const value_type& __v)\n       { return _M_insert(__v, integral_constant<bool, __unique_keys>()); }\n@@ -1160,6 +1179,128 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __prev_n;\n     }\n \n+  template<typename _Key, typename _Value,\n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename... _Args>\n+      std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t    _ExtractKey, _Equal, _H1,\n+\t\t\t\t    _H2, _Hash, _RehashPolicy,\n+\t\t\t\t    __chc, __cit, __uk>::iterator, bool>\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _M_emplace(std::true_type, _Args&&... __args)\n+      {\n+\t// First build the node to get access to the hash code\n+\t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n+\t__try\n+\t  {\n+\t    const key_type& __k = this->_M_extract(__new_node->_M_v);\n+\t    typename _Hashtable::_Hash_code_type __code\n+\t      = this->_M_hash_code(__k);\n+\t    size_type __bkt\n+\t      = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+\t    if (_Node* __p = _M_find_node(__bkt, __k, __code))\n+\t      {\n+\t\t// There is already an equivalent node, no insertion\n+\t\t_M_deallocate_node(__new_node);\n+\t\treturn std::make_pair(iterator(__p), false);\n+\t      }\n+\n+\t    // We are going to insert this node\n+\t    this->_M_store_code(__new_node, __code);\n+\t    const _RehashPolicyState& __saved_state\n+\t      = _M_rehash_policy._M_state();\n+\t    std::pair<bool, std::size_t> __do_rehash\n+\t      = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t\t_M_element_count, 1);\n+\n+\t    if (__do_rehash.first)\n+\t      {\n+\t\t_M_rehash(__do_rehash.second, __saved_state);\n+\t\t__bkt = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t      }\n+\n+\t    if (_M_buckets[__bkt])\n+\t      _M_insert_after(__bkt, _M_buckets[__bkt], __new_node);\n+\t    else \n+\t      _M_insert_bucket_begin(__bkt, __new_node);\n+\t    ++_M_element_count;\n+\t    return std::make_pair(iterator(__new_node), true);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_deallocate_node(__new_node);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Value,\n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename... _Args>\n+      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t  __chc, __cit, __uk>::iterator\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _M_emplace(std::false_type, _Args&&... __args)\n+      {\n+\tconst _RehashPolicyState& __saved_state = _M_rehash_policy._M_state();\n+\tstd::pair<bool, std::size_t> __do_rehash\n+\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t    _M_element_count, 1);\n+\n+\t// First build the node to get its hash code\n+\t_Node* __new_node = _M_allocate_node(std::forward<_Args>(__args)...);\n+\t__try\n+\t  {\n+\t    const key_type& __k = this->_M_extract(__new_node->_M_v);\n+\t    typename _Hashtable::_Hash_code_type __code\n+\t      = this->_M_hash_code(__k);\n+\t    this->_M_store_code(__new_node, __code);\n+\t    size_type __bkt\n+\t      = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+\t    // Second find the node, avoid rehash if compare throws.\n+\t    _Node* __prev = _M_find_node(__bkt, __k, __code);\n+\t    \n+\t    if (__do_rehash.first)\n+\t      {\n+\t\t_M_rehash(__do_rehash.second, __saved_state);\n+\t\t__bkt = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\t\t// __prev is still valid because rehash do not invalidate nodes\n+\t      }\n+\n+\t    if (__prev)\n+\t      // Insert after the previous equivalent node\n+\t      _M_insert_after(__bkt, __prev, __new_node);\n+\t    else if (_M_buckets[__bkt])\n+\t      // Bucket is not empty and the inserted node has no equivalent in\n+\t      // the hashtable. We must insert the new node at the beginning or\n+\t      // end of the bucket to preserve equivalent elements relative\n+\t      // positions.\n+\t      if (__bkt != _M_begin_bucket_index)\n+\t\t// We insert the new node at the beginning\n+\t\t_M_insert_after(__bkt, _M_buckets[__bkt], __new_node);\n+\t      else\n+\t\t// We insert the new node at the end\n+\t\t_M_insert_after(__bkt, _M_bucket_end(__bkt), __new_node);\n+\t    else\n+\t      _M_insert_bucket_begin(__bkt, __new_node);\n+\t    ++_M_element_count;\n+\t    return iterator(__new_node);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_deallocate_node(__new_node);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n   // Insert v in bucket n (assumes no element with its key already present).\n   template<typename _Key, typename _Value,\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n@@ -1300,7 +1441,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      _M_deallocate_node(__new_node);\n \t    __throw_exception_again;\n \t  }\n-\n       }\n \n   template<typename _Key, typename _Value,"}, {"sha": "cf84948f049b6e76c0ed51783b467c05c785f75e", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -204,6 +204,29 @@ namespace __debug\n       cend(size_type __b) const\n       { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  std::pair<_Base_iterator, bool> __res\n+\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return std::make_pair(iterator(__res.first, this), __res.second);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __hint, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__hint);\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n+\n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n@@ -587,6 +610,29 @@ namespace __debug\n       cend(size_type __b) const\n       { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it\n+\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __hint, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__hint);\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n+\n       iterator\n       insert(const value_type& __obj)\n       {"}, {"sha": "ba4404028e3dccba2c641fc4ef1c7383a87aa806", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -204,6 +204,29 @@ namespace __debug\n       cend(size_type __b) const\n       { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  std::pair<_Base_iterator, bool> __res\n+\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return std::make_pair(iterator(__res.first, this), __res.second);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __hint, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__hint);\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n+\n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n@@ -582,6 +605,29 @@ namespace __debug\n       cend(size_type __b) const\n       { return const_local_iterator(_Base::cend(__b), __b, this); }\n \n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it\n+\t    = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __hint, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__hint);\n+\t  size_type __bucket_count = this->bucket_count();\n+\t  _Base_iterator __it = _Base::emplace_hint(__hint.base(),\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  _M_check_rehashed(__bucket_count);\n+\t  return iterator(__it, this);\n+\t}\n+\n       iterator\n       insert(const value_type& __obj)\n       {"}, {"sha": "0a0dff8c2b70545d90931e91ca095fde10b7cb57", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/emplace.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Femplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Femplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Femplace.cc?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -0,0 +1,116 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <utility>\n+#include <tuple>\n+#include <vector>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+    : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+    : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::unordered_map<char, std::vector<double>> Map;\n+  Map m;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto ret = m.emplace('a', coord1);\n+  VERIFY( ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  ret = m.emplace('a', coord1);\n+  VERIFY( !ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+  VERIFY( ret.first->second[0] == 0.0 );\n+\n+  auto it = m.emplace_hint(m.begin(), 'b', coord1);\n+  VERIFY( it != m.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  ret = m.emplace('c', std::move(coord1));\n+  VERIFY( ret.second );\n+  VERIFY( ret.first->first == 'c' );\n+  VERIFY( &(ret.first->second[0]) == px );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+  typedef unordered_map<char, PathPoint> Map;\n+  Map m;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto ret = m.emplace(piecewise_construct,\n+\t\t       make_tuple('a'), make_tuple('a', coord1));\n+  VERIFY( ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  ret = m.emplace(piecewise_construct,\n+\t\t  make_tuple('a'), make_tuple( 'b', coord1));\n+  VERIFY( !ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+  VERIFY( ret.first->second.getCoords()[0] == 0.0 );\n+\n+  auto it = m.emplace_hint(m.begin(), piecewise_construct,\n+\t\t\t   make_tuple('b'), make_tuple('c', coord1));\n+  VERIFY( it != m.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second.getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  ret = m.emplace(piecewise_construct,\n+\t\t  make_tuple('c'), make_tuple('d', move(coord1)));\n+  VERIFY( ret.second );\n+  VERIFY( ret.first->first == 'c' );\n+  VERIFY( &(ret.first->second.getCoords()[0]) == px );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "40aef98ad41eb791998e0227249352c8580b78f2", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/emplace.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Femplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Femplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fmodifiers%2Femplace.cc?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -0,0 +1,110 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <tuple>\n+#include <vector>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+  : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+  : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::unordered_multimap<char, std::vector<double>> MMap;\n+  MMap mm;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto it = mm.emplace('a', coord1);\n+  VERIFY( mm.size() == 1 );\n+  VERIFY( it->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  it = mm.emplace('a', coord1);\n+  VERIFY( mm.size() == 2 );\n+  VERIFY( it->first == 'a' );\n+  VERIFY( it->second[0] == 3.0 );\n+\n+  it = mm.emplace_hint(mm.begin(), 'b', coord1);\n+  VERIFY( it != mm.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  it = mm.emplace('c', std::move(coord1));\n+  VERIFY( it->first == 'c' );\n+  VERIFY( &(it->second[0]) == px );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+  typedef unordered_multimap<char, PathPoint> Map;\n+  Map m;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto it = m.emplace(piecewise_construct,\n+\t\t       make_tuple('a'), make_tuple('a', coord1));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( it->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  it = m.emplace(piecewise_construct,\n+\t\t  make_tuple('a'), make_tuple( 'b', coord1));\n+  VERIFY( m.size() == 2 );\n+  VERIFY( it->first == 'a' );\n+  VERIFY( it->second.getCoords()[0] == 3.0 );\n+\n+  it = m.emplace_hint(m.begin(), piecewise_construct,\n+\t\t      make_tuple('b'), make_tuple('c', coord1));\n+  VERIFY( it != m.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second.getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  it = m.emplace(piecewise_construct,\n+\t\t  make_tuple('c'), make_tuple('d', move(coord1)));\n+  VERIFY( it->first == 'c' );\n+  VERIFY( &(it->second.getCoords()[0]) == px );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "057e326fbf8d69f71311dd4178612f599dff0bcd", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/modifiers/emplace.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Femplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Femplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Femplace.cc?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -0,0 +1,88 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <vector>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+  : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+  : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+struct PathPointHasher\n+{\n+  std::size_t operator() (const PathPoint& __pp) const\n+  { return __pp.getType(); }\n+};\n+\n+struct PathPointEqual\n+{\n+  bool operator() (const PathPoint& __lhs, const PathPoint& __rhs) const\n+  { return __lhs.getType() == __rhs.getType(); }\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::unordered_multiset<PathPoint, PathPointHasher,\n+\t\t\t\t  PathPointEqual> Mset;\n+  Mset ms;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto it = ms.emplace('a', coord1);\n+  VERIFY( ms.size() == 1 );\n+  VERIFY( it->getType() == 'a' );\n+\n+  coord1[0] = 3.0;\n+  it = ms.emplace('a', coord1);\n+  VERIFY( ms.size() == 2 );\n+  VERIFY( it->getType() == 'a' );\n+  VERIFY( it->getCoords()[0] == 3.0 );\n+\n+  it = ms.emplace_hint(ms.begin(), 'b', coord1);\n+  VERIFY( it != ms.end() );\n+  VERIFY( it->getType() == 'b' );\n+  VERIFY( it->getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  it = ms.emplace('c', std::move(coord1));\n+  VERIFY( ms.size() == 4 );\n+  VERIFY( it->getType() == 'c' );\n+  VERIFY( &(it->getCoords()[0]) == px );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2ae4e763d6096071a0f6a7396064120dc106d61c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/modifiers/emplace.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Femplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Femplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Femplace.cc?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// range insert\n+\n+#include <vector>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+  : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+  : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+struct PathPointHasher\n+{\n+  std::size_t operator() (const PathPoint& __pp) const\n+  { return __pp.getType(); }\n+};\n+\n+struct PathPointEqual\n+{\n+  bool operator() (const PathPoint& __lhs, const PathPoint& __rhs) const\n+  { return __lhs.getType() == __rhs.getType(); }\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::unordered_set<PathPoint, PathPointHasher, PathPointEqual> Set;\n+  Set s;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto ret = s.emplace('a', coord1);\n+  VERIFY( ret.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( ret.first->getType() == 'a' );\n+\n+  coord1[0] = 3.0;\n+  ret = s.emplace('a', coord1);\n+  VERIFY( !ret.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( ret.first->getType() == 'a' );\n+  VERIFY( ret.first->getCoords()[0] == 0.0 );\n+\n+  auto it = s.emplace_hint(s.begin(), 'b', coord1);\n+  VERIFY( it != s.end() );\n+  VERIFY( it->getType() == 'b' );\n+  VERIFY( it->getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  ret = s.emplace('c', std::move(coord1));\n+  VERIFY( ret.second );\n+  VERIFY( ret.first->getType() == 'c' );\n+  VERIFY( &(ret.first->getCoords()[0]) == px );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "50418983ca60472fcac86a5f2e5f575cb7cffc04", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -826,6 +826,110 @@ namespace __gnu_test\n \toperator()(_Tp&, _Tp&) { }\n       };\n \n+    template<typename _Tp,\n+\t     bool = traits<_Tp>::has_emplace::value>\n+      struct emplace;\n+\n+    // Specialization for most containers.\n+    template<typename _Tp>\n+      struct emplace<_Tp, true>\n+      {\n+\ttypedef _Tp\t\t\t\t\tcontainer_type;\n+\ttypedef typename container_type::value_type\tvalue_type;\n+\ttypedef typename container_type::size_type\tsize_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.emplace(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      __test.emplace(cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+ \t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct emplace<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n+\n+    template<typename _Tp,\n+\t     bool = traits<_Tp>::has_emplace::value>\n+      struct emplace_hint;\n+\n+    // Specialization for most containers.\n+    template<typename _Tp>\n+      struct emplace_hint<_Tp, true>\n+      {\n+\ttypedef _Tp \t\t\t\t       \tcontainer_type;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.begin();\n+\t      std::advance(i, s);\n+\t      __test.emplace_hint(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.begin();\n+\t      std::advance(i, s);\n+\t      __test.emplace_hint(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+ \t}\n+      };\n+\n+    // Specialization, empty.\n+    template<typename _Tp>\n+      struct emplace_hint<_Tp, false>\n+      {\n+\tvoid\n+\toperator()(_Tp&) { }\n+\n+\tvoid\n+\toperator()(_Tp&, _Tp&) { }\n+      };\n \n     template<typename _Tp, bool = traits<_Tp>::is_associative::value\n \t\t\t\t  || traits<_Tp>::is_unordered::value>\n@@ -1023,6 +1127,8 @@ namespace __gnu_test\n       typedef erase_point<container_type> \t       \terase_point;\n       typedef erase_range<container_type> \t       \terase_range;\n       typedef insert_point<container_type> \t       \tinsert_point;\n+      typedef emplace<container_type>\t\t\templace;\n+      typedef emplace_hint<container_type>\t\templace_hint;\n       typedef pop_front<container_type> \t       \tpop_front;\n       typedef pop_back<container_type> \t\t\tpop_back;\n       typedef push_front<container_type> \t       \tpush_front;\n@@ -1039,6 +1145,8 @@ namespace __gnu_test\n       erase_point\t\t_M_erasep;\n       erase_range\t\t_M_eraser;\n       insert_point\t\t_M_insertp;\n+      emplace\t\t\t_M_emplace;\n+      emplace_hint\t\t_M_emplaceh;\n       pop_front\t\t\t_M_popf;\n       pop_back\t\t\t_M_popb;\n       push_front\t       \t_M_pushf;\n@@ -1098,6 +1206,8 @@ namespace __gnu_test\n \t_M_functions.push_back(function_type(base_type::_M_erasep));\n \t_M_functions.push_back(function_type(base_type::_M_eraser));\n \t_M_functions.push_back(function_type(base_type::_M_insertp));\n+\t_M_functions.push_back(function_type(base_type::_M_emplace));\n+\t_M_functions.push_back(function_type(base_type::_M_emplaceh));\n \t_M_functions.push_back(function_type(base_type::_M_popf));\n \t_M_functions.push_back(function_type(base_type::_M_popb));\n \t_M_functions.push_back(function_type(base_type::_M_pushf));"}, {"sha": "cce91b739bfe318c57a0cc18a43574ded7c961ac", "filename": "libstdc++-v3/testsuite/util/testsuite_container_traits.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b81593bbcb4151c135af547647cb9b65ecbd6bd/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h?ref=9b81593bbcb4151c135af547647cb9b65ecbd6bd", "patch": "@@ -43,6 +43,7 @@ namespace __gnu_test\n     typedef std::false_type\thas_throwing_erase;\n     typedef std::false_type\thas_insert;\n     typedef std::false_type\thas_insert_after;\n+    typedef std::false_type\thas_emplace;\n     typedef std::false_type\thas_push_pop;\n     typedef std::false_type\thas_size_type_constructor;\n   };\n@@ -216,6 +217,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3,\n@@ -230,6 +232,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n@@ -242,6 +245,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_emplace;\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n@@ -254,6 +258,7 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_emplace;\n     };\n } // namespace __gnu_test\n "}]}