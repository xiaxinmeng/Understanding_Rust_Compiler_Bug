{"sha": "5991e1568cd0d505ae3646c3178b1676cc70bc13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5MWUxNTY4Y2QwZDUwNWFlMzY0NmMzMTc4YjE2NzZjYzcwYmMxMw==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-04-30T13:40:14Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2012-04-30T13:40:14Z"}, "message": "2012-04-30 Ian Bolton\t<ian.bolton at arm.com> Sameera Deshpande...\n\n2012-04-30  Ian Bolton\t<ian.bolton at arm.com>\n\t    Sameera Deshpande  <sameera.deshpande at arm.com>\n\t    Greta Yorsh\t <greta.yorsh at arm.com>\n\n\t* config/arm/arm-protos.h (ldm_stm_operation_p): New declaration.\n\t* config/arm/arm.c (ldm_stm_operation_p): New function.\n\t* config/arm/predicates.md (load_multiple_operation): Update predicate.\n\t(store_multiple_operation): Likewise.\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r186980", "tree": {"sha": "c09b78879773404236f826ecfe7361af931d230e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09b78879773404236f826ecfe7361af931d230e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5991e1568cd0d505ae3646c3178b1676cc70bc13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5991e1568cd0d505ae3646c3178b1676cc70bc13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5991e1568cd0d505ae3646c3178b1676cc70bc13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5991e1568cd0d505ae3646c3178b1676cc70bc13/comments", "author": null, "committer": null, "parents": [{"sha": "d55d2c8490cf7c44a2c48a41cf253888b3a5c552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d55d2c8490cf7c44a2c48a41cf253888b3a5c552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d55d2c8490cf7c44a2c48a41cf253888b3a5c552"}], "stats": {"total": 299, "additions": 156, "deletions": 143}, "files": [{"sha": "0ee7588955af6b01ea921fe7baae37534dcbc4d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5991e1568cd0d505ae3646c3178b1676cc70bc13", "patch": "@@ -1,3 +1,12 @@\n+2012-04-30  Ian Bolton\t<ian.bolton at arm.com>\n+\t    Sameera Deshpande  <sameera.deshpande at arm.com>\n+\t    Greta Yorsh\t <greta.yorsh at arm.com>\n+\n+\t* config/arm/arm-protos.h (ldm_stm_operation_p): New declaration.\n+\t* config/arm/arm.c (ldm_stm_operation_p): New function.\n+\t* config/arm/predicates.md (load_multiple_operation): Update predicate.\n+\t(store_multiple_operation): Likewise.\n+\n 2012-04-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (and<mode>3): Expand masking operations with"}, {"sha": "753e109273cd637740d2ac3b2ae1e0697cd84704", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=5991e1568cd0d505ae3646c3178b1676cc70bc13", "patch": "@@ -62,6 +62,7 @@ extern bool arm_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n \t\t\t\t\t    int);\n extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);\n+extern bool ldm_stm_operation_p (rtx, bool);\n extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n extern int vfp3_const_double_rtx (rtx);"}, {"sha": "c856af8e09fe819e37cc74de631380fc15037525", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5991e1568cd0d505ae3646c3178b1676cc70bc13", "patch": "@@ -10166,6 +10166,150 @@ adjacent_mem_locations (rtx a, rtx b)\n   return 0;\n }\n \n+/* Return true if OP is a valid load or store multiple operation.  LOAD is true\n+   for load operations, false for store operations.\n+   The pattern we are trying to match for load is:\n+     [(SET (R_d0) (MEM (PLUS (addr) (offset))))\n+      (SET (R_d1) (MEM (PLUS (addr) (offset + <reg_increment>))))\n+       :\n+       :\n+      (SET (R_dn) (MEM (PLUS (addr) (offset + n * <reg_increment>))))\n+     ]\n+     where\n+     1.  If offset is 0, first insn should be (SET (R_d0) (MEM (src_addr))).\n+     2.  REGNO (R_d0) < REGNO (R_d1) < ... < REGNO (R_dn).\n+     3.  If consecutive is TRUE, then for kth register being loaded,\n+         REGNO (R_dk) = REGNO (R_d0) + k.\n+   The pattern for store is similar.  */\n+bool\n+ldm_stm_operation_p (rtx op, bool load)\n+{\n+  HOST_WIDE_INT count = XVECLEN (op, 0);\n+  rtx reg, mem, addr;\n+  unsigned regno;\n+  HOST_WIDE_INT i = 1, base = 0, offset = 0;\n+  rtx elt;\n+  bool addr_reg_in_reglist = false;\n+  bool update = false;\n+  int reg_increment;\n+  int offset_adj;\n+\n+  reg_increment = 4;\n+  offset_adj = 0;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, offset_adj)) != SET\n+      || (load && !REG_P (SET_DEST (XVECEXP (op, 0, offset_adj)))))\n+    return false;\n+\n+  /* Check if this is a write-back.  */\n+  elt = XVECEXP (op, 0, offset_adj);\n+  if (GET_CODE (SET_SRC (elt)) == PLUS)\n+    {\n+      i++;\n+      base = 1;\n+      update = true;\n+\n+      /* The offset adjustment must be the number of registers being\n+         popped times the size of a single register.  */\n+      if (!REG_P (SET_DEST (elt))\n+          || !REG_P (XEXP (SET_SRC (elt), 0))\n+          || (REGNO (SET_DEST (elt)) != REGNO (XEXP (SET_SRC (elt), 0)))\n+          || !CONST_INT_P (XEXP (SET_SRC (elt), 1))\n+          || INTVAL (XEXP (SET_SRC (elt), 1)) !=\n+             ((count - 1 - offset_adj) * reg_increment))\n+        return false;\n+    }\n+\n+  i = i + offset_adj;\n+  base = base + offset_adj;\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= i)\n+    return false;\n+\n+  elt = XVECEXP (op, 0, i - 1);\n+  if (GET_CODE (elt) != SET)\n+    return false;\n+\n+  if (load)\n+    {\n+      reg = SET_DEST (elt);\n+      mem = SET_SRC (elt);\n+    }\n+  else\n+    {\n+      reg = SET_SRC (elt);\n+      mem = SET_DEST (elt);\n+    }\n+\n+  if (!REG_P (reg) || !MEM_P (mem))\n+    return false;\n+\n+  regno = REGNO (reg);\n+  addr = XEXP (mem, 0);\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (!CONST_INT_P (XEXP (addr, 1)))\n+\treturn false;\n+\n+      offset = INTVAL (XEXP (addr, 1));\n+      addr = XEXP (addr, 0);\n+    }\n+\n+  if (!REG_P (addr))\n+    return false;\n+\n+  for (; i < count; i++)\n+    {\n+      elt = XVECEXP (op, 0, i);\n+      if (GET_CODE (elt) != SET)\n+        return false;\n+\n+      if (load)\n+        {\n+          reg = SET_DEST (elt);\n+          mem = SET_SRC (elt);\n+        }\n+      else\n+        {\n+          reg = SET_SRC (elt);\n+          mem = SET_DEST (elt);\n+        }\n+\n+      if (!REG_P (reg)\n+          || GET_MODE (reg) != SImode\n+          || REGNO (reg) <= regno\n+          || !MEM_P (mem)\n+          || GET_MODE (mem) != SImode\n+          || ((GET_CODE (XEXP (mem, 0)) != PLUS\n+\t       || !rtx_equal_p (XEXP (XEXP (mem, 0), 0), addr)\n+\t       || !CONST_INT_P (XEXP (XEXP (mem, 0), 1))\n+\t       || (INTVAL (XEXP (XEXP (mem, 0), 1)) !=\n+                   offset + (i - base) * reg_increment))\n+\t      && (!REG_P (XEXP (mem, 0))\n+\t\t  || offset + (i - base) * reg_increment != 0)))\n+        return false;\n+\n+      regno = REGNO (reg);\n+      if (regno == REGNO (addr))\n+        addr_reg_in_reglist = true;\n+    }\n+\n+  if (load)\n+    {\n+      if (update && addr_reg_in_reglist)\n+        return false;\n+\n+      /* For Thumb-1, address register is always modified - either by write-back\n+         or by explicit load.  If the pattern does not describe an update,\n+         then the address register must be in the list of loaded registers.  */\n+      if (TARGET_THUMB1)\n+        return update || addr_reg_in_reglist;\n+    }\n+\n+  return true;\n+}\n+\n /* Return true iff it would be profitable to turn a sequence of NOPS loads\n    or stores (depending on IS_STORE) into a load-multiple or store-multiple\n    instruction.  ADD_OFFSET is nonzero if the base address register needs"}, {"sha": "20a64ec37010aa4c879a536cd486f95f72d5e9cd", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 2, "deletions": 143, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5991e1568cd0d505ae3646c3178b1676cc70bc13/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=5991e1568cd0d505ae3646c3178b1676cc70bc13", "patch": "@@ -380,154 +380,13 @@\n (define_special_predicate \"load_multiple_operation\"\n   (match_code \"parallel\")\n {\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  unsigned dest_regno;\n-  rtx src_addr;\n-  HOST_WIDE_INT i = 1, base = 0;\n-  HOST_WIDE_INT offset = 0;\n-  rtx elt;\n-  bool addr_reg_loaded = false;\n-  bool update = false;\n-\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n-      || !REG_P (SET_DEST (XVECEXP (op, 0, 0))))\n-    return false;\n-\n-  /* Check to see if this might be a write-back.  */\n-  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n-    {\n-      i++;\n-      base = 1;\n-      update = true;\n-\n-      /* Now check it more carefully.  */\n-      if (GET_CODE (SET_DEST (elt)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n-          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)\n-        return false;\n-    }\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= i\n-      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != MEM)\n-    return false;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, i - 1)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, i - 1)), 0);\n-  if (GET_CODE (src_addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (src_addr, 1)) != CONST_INT)\n-\treturn false;\n-      offset = INTVAL (XEXP (src_addr, 1));\n-      src_addr = XEXP (src_addr, 0);\n-    }\n-  if (!REG_P (src_addr))\n-    return false;\n-\n-  for (; i < count; i++)\n-    {\n-      elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-          || GET_CODE (SET_DEST (elt)) != REG\n-          || GET_MODE (SET_DEST (elt)) != SImode\n-          || REGNO (SET_DEST (elt)) <= dest_regno\n-          || GET_CODE (SET_SRC (elt)) != MEM\n-          || GET_MODE (SET_SRC (elt)) != SImode\n-          || ((GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-\t       || !rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-\t       || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-\t       || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != offset + (i - base) * 4)\n-\t      && (!REG_P (XEXP (SET_SRC (elt), 0))\n-\t\t  || offset + (i - base) * 4 != 0)))\n-        return false;\n-      dest_regno = REGNO (SET_DEST (elt));\n-      if (dest_regno == REGNO (src_addr))\n-        addr_reg_loaded = true;\n-    }\n-  /* For Thumb, we only have updating instructions.  If the pattern does\n-     not describe an update, it must be because the address register is\n-     in the list of loaded registers - on the hardware, this has the effect\n-     of overriding the update.  */\n-  if (update && addr_reg_loaded)\n-    return false;\n-  if (TARGET_THUMB1)\n-    return update || addr_reg_loaded;\n-  return true;\n+ return ldm_stm_operation_p (op, /*load=*/true);\n })\n \n (define_special_predicate \"store_multiple_operation\"\n   (match_code \"parallel\")\n {\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  unsigned src_regno;\n-  rtx dest_addr;\n-  HOST_WIDE_INT i = 1, base = 0, offset = 0;\n-  rtx elt;\n-\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n-    return false;\n-\n-  /* Check to see if this might be a write-back.  */\n-  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n-    {\n-      i++;\n-      base = 1;\n-\n-      /* Now check it more carefully.  */\n-      if (GET_CODE (SET_DEST (elt)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n-          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)\n-        return false;\n-    }\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= i\n-      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != REG)\n-    return false;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, i - 1)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, i - 1)), 0);\n-\n-  if (GET_CODE (dest_addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (dest_addr, 1)) != CONST_INT)\n-\treturn false;\n-      offset = INTVAL (XEXP (dest_addr, 1));\n-      dest_addr = XEXP (dest_addr, 0);\n-    }\n-  if (!REG_P (dest_addr))\n-    return false;\n-\n-  for (; i < count; i++)\n-    {\n-      elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-          || GET_CODE (SET_SRC (elt)) != REG\n-          || GET_MODE (SET_SRC (elt)) != SImode\n-          || REGNO (SET_SRC (elt)) <= src_regno\n-          || GET_CODE (SET_DEST (elt)) != MEM\n-          || GET_MODE (SET_DEST (elt)) != SImode\n-          || ((GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-\t       || !rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-\t       || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-               || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != offset + (i - base) * 4)\n-\t      && (!REG_P (XEXP (SET_DEST (elt), 0))\n-\t\t  || offset + (i - base) * 4 != 0)))\n-        return false;\n-      src_regno = REGNO (SET_SRC (elt));\n-    }\n-\n-  return true;\n+ return ldm_stm_operation_p (op, /*load=*/false);\n })\n \n (define_special_predicate \"multi_register_push\""}]}