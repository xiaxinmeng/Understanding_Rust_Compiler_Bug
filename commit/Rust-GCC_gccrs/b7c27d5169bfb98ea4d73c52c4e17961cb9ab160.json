{"sha": "b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdjMjdkNTE2OWJmYjk4ZWE0ZDczYzUyYzRlMTc5NjFjYjlhYjE2MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-24T22:45:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-24T22:45:00Z"}, "message": "ipa-inline.c (initial_insns, max_insns): Delete.\n\n\t* ipa-inline.c (initial_insns, max_insns): Delete.\n\t(compute_max_insns): New function.\n\t(cgraph_decide_inlining_of_small_function): Use it; take minimal amount\n\tof insns as base for code growth.\n\t(cgraph_decide_inlining): Make initial_insns local; do not compute\n\tmax_insns.\n\t* params.def (PARAM_INLINE_UNIT_GROWTH): Set to 60.\n\t* doc/invoke.texi (inline-unit-growth): Update docs.\n\nFrom-SVN: r121144", "tree": {"sha": "97625f5e54c9473e50dcef3cfe1a4f3808aee7d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97625f5e54c9473e50dcef3cfe1a4f3808aee7d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/comments", "author": null, "committer": null, "parents": [{"sha": "078b307321410f5a8e580df2a4c7dd8e980354b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078b307321410f5a8e580df2a4c7dd8e980354b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078b307321410f5a8e580df2a4c7dd8e980354b1"}], "stats": {"total": 53, "additions": 40, "deletions": 13}, "files": [{"sha": "6a8e41e36d09ea4134fc087b54a9043b34ecdb72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "patch": "@@ -1,3 +1,14 @@\n+2007-01-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (initial_insns, max_insns): Delete.\n+\t(compute_max_insns): New function.\n+\t(cgraph_decide_inlining_of_small_function): Use it; take minimal amount\n+\tof insns as base for code growth.\n+\t(cgraph_decide_inlining): Make initial_insns local; do not compute\n+\tmax_insns.\n+\t* params.def (PARAM_INLINE_UNIT_GROWTH): Set to 60.\n+\t* doc/invoke.texi (inline-unit-growth): Update docs.\n+\n 2007-01-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.h (x86_cmpxchg16b): Remove const."}, {"sha": "4cd0a43ce48b4a92b92509f3d58a61f4b2b08b11", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "patch": "@@ -6096,7 +6096,7 @@ before applying @option{--param inline-unit-growth}.  The default is 10000\n @item inline-unit-growth\n Specifies maximal overall growth of the compilation unit caused by inlining.\n This parameter is ignored when @option{-funit-at-a-time} is not used.\n-The default value is 50 which limits unit growth to 1.5 times the original\n+The default value is 60 which limits unit growth to 1.6 times the original\n size.\n \n @item large-stack-frame"}, {"sha": "803bc9d70d074b51a31322743df0bd88407fd78d", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "patch": "@@ -169,9 +169,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *, enum inlining_mode,\n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n static int nfunctions_inlined;\n-static int initial_insns;\n static int overall_insns;\n-static int max_insns;\n static gcov_type max_count;\n \n /* Estimate size of the function after inlining WHAT into TO.  */\n@@ -753,6 +751,19 @@ cgraph_set_inline_failed (struct cgraph_node *node, const char *reason)\n       e->inline_failed = reason;\n }\n \n+/* Given whole compilation unit esitmate of INSNS, compute how large we can\n+   allow the unit to grow.  */\n+static int\n+compute_max_insns (int insns)\n+{\n+  int max_insns = insns;\n+  if (max_insns < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n+    max_insns = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n+\n+  return max_insns = ((HOST_WIDEST_INT) max_insns\n+\t              * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n+}\n+\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap based on estimated\n    growth of the overall number of instructions and then update the estimates.\n@@ -768,6 +779,7 @@ cgraph_decide_inlining_of_small_functions (void)\n   const char *failed_reason;\n   fibheap_t heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n+  int min_insns, max_insns;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nDeciding on smaller functions:\\n\");\n@@ -796,6 +808,10 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge), edge);\n \t  }\n     }\n+\n+  max_insns = compute_max_insns (overall_insns);\n+  min_insns = overall_insns;\n+\n   while (overall_insns <= max_insns && (edge = fibheap_extract_min (heap)))\n     {\n       int old_insns = overall_insns;\n@@ -923,6 +939,14 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t   edge->caller->global.insns,\n \t\t   overall_insns - old_insns);\n \t}\n+      if (min_insns > overall_insns)\n+\t{\n+\t  min_insns = overall_insns;\n+\t  max_insns = compute_max_insns (min_insns);\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"New minimal insns reached: %i\\n\", min_insns);\n+\t}\n     }\n   while ((edge = fibheap_extract_min (heap)) != NULL)\n     {\n@@ -949,6 +973,7 @@ cgraph_decide_inlining (void)\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int old_insns = 0;\n   int i;\n+  int initial_insns;\n \n   max_count = 0;\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -965,13 +990,6 @@ cgraph_decide_inlining (void)\n   overall_insns = initial_insns;\n   gcc_assert (!max_count || (profile_info && flag_branch_probabilities));\n \n-  max_insns = overall_insns;\n-  if (max_insns < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n-    max_insns = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n-\n-  max_insns = ((HOST_WIDEST_INT) max_insns\n-\t       * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n-\n   nnodes = cgraph_postorder (order);\n \n   if (dump_file)\n@@ -996,12 +1014,10 @@ cgraph_decide_inlining (void)\n       /* Handle nodes to be flattened, but don't update overall unit size.  */\n       if (lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n         {\n-\t  int old_overall_insns = overall_insns;\n   \t  if (dump_file)\n     \t    fprintf (dump_file,\n \t     \t     \"Flattening %s\\n\", cgraph_node_name (node));\n \t  cgraph_decide_inlining_incrementally (node, INLINE_ALL, 0);\n-\t  overall_insns = old_overall_insns;\n         }\n \n       if (!node->local.disregard_inline_limits)"}, {"sha": "c4f7229afdfa4e8cb51d854403692e1a3cde180b", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c27d5169bfb98ea4d73c52c4e17961cb9ab160/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b7c27d5169bfb98ea4d73c52c4e17961cb9ab160", "patch": "@@ -199,7 +199,7 @@ DEFPARAM(PARAM_LARGE_UNIT_INSNS,\n DEFPARAM(PARAM_INLINE_UNIT_GROWTH,\n \t \"inline-unit-growth\",\n \t \"how much can given compilation unit grow because of the inlining (in percent)\",\n-\t 50, 0, 0)\n+\t 60, 0, 0)\n DEFPARAM(PARAM_INLINE_CALL_COST,\n \t \"inline-call-cost\",\n \t \"expense of call operation relative to ordinary arithmetic operations\","}]}