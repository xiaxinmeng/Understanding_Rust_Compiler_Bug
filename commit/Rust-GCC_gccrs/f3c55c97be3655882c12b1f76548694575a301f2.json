{"sha": "f3c55c97be3655882c12b1f76548694575a301f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNjNTVjOTdiZTM2NTU4ODJjMTJiMWY3NjU0ODY5NDU3NWEzMDFmMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-05-12T10:41:21Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-05-12T10:41:21Z"}, "message": "defaults.h (TARGET_PTRMEMFUNC_VBIT_LOCATION): Define.\n\n* defaults.h (TARGET_PTRMEMFUNC_VBIT_LOCATION): Define.\n* tm.texi (TARGET_PRTMEMFUNC_VBIT_LOCATION): Document.\n\nFrom-SVN: r41989", "tree": {"sha": "85d31d3c38b3d8227bcdae0fdb074c5fbcdf205a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85d31d3c38b3d8227bcdae0fdb074c5fbcdf205a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3c55c97be3655882c12b1f76548694575a301f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c55c97be3655882c12b1f76548694575a301f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3c55c97be3655882c12b1f76548694575a301f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c55c97be3655882c12b1f76548694575a301f2/comments", "author": null, "committer": null, "parents": [{"sha": "18ae7f63994e175638eacd0c626a017f648c7436", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ae7f63994e175638eacd0c626a017f648c7436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18ae7f63994e175638eacd0c626a017f648c7436"}], "stats": {"total": 55, "additions": 55, "deletions": 0}, "files": [{"sha": "748847f68bc1550325a8e02ddfb5427aef2b3d6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c55c97be3655882c12b1f76548694575a301f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c55c97be3655882c12b1f76548694575a301f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3c55c97be3655882c12b1f76548694575a301f2", "patch": "@@ -1,3 +1,8 @@\n+2001-05-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* defaults.h (TARGET_PTRMEMFUNC_VBIT_LOCATION): Define.\n+\t* tm.texi (TARGET_PRTMEMFUNC_VBIT_LOCATION): Document.\n+\n 2001-05-11  Richard Henderson  <rth@redhat.com>\n \n \t* defaults.h (ASM_PREFERRED_EH_DATA_FORMAT): New."}, {"sha": "45fb088785fcda6273921cb944d7ad87a6b0030f", "filename": "gcc/defaults.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c55c97be3655882c12b1f76548694575a301f2/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c55c97be3655882c12b1f76548694575a301f2/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=f3c55c97be3655882c12b1f76548694575a301f2", "patch": "@@ -325,5 +325,16 @@ do {\t\t\t\t\t\t\t\t\\\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  DW_EH_PE_absptr\n #endif\n \n+/* By default, the C++ compiler will use the lowest bit of the pointer\n+   to function to indicate a pointer-to-member-function points to a\n+   virtual member function.  However, if FUNCTION_BOUNDARY indicates\n+   function addresses aren't always even, the lowest bit of the delta\n+   field will be used.  */\n+#ifndef TARGET_PTRMEMFUNC_VBIT_LOCATION\n+#define TARGET_PTRMEMFUNC_VBIT_LOCATION \\\n+  (FUNCTION_BOUNDARY >= 2 * BITS_PER_UNIT \\\n+   ? ptrmemfunc_vbit_in_pfn : ptrmemfunc_vbit_in_delta)\n+#endif\n+\n #endif  /* GCC_DEFAULTS_H */\n "}, {"sha": "8f1c314d79056b53ec9a1568f2506d425259ed14", "filename": "gcc/tm.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c55c97be3655882c12b1f76548694575a301f2/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c55c97be3655882c12b1f76548694575a301f2/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=f3c55c97be3655882c12b1f76548694575a301f2", "patch": "@@ -1451,6 +1451,45 @@ label.\n On certain machines, it is important to have a separate label for each\n selector because this enables the linker to eliminate duplicate selectors.\n \n+@findex TARGET_PTRMEMFUNC_VBIT_LOCATION\n+@item TARGET_PTRMEMFUNC_VBIT_LOCATION\n+The C++ compiler represents a pointer-to-member-function with a struct\n+that looks like:\n+\n+@example\n+  struct @{\n+    union @{\n+      void (*fn)();\n+      ptrdiff_t vtable_index;\n+    @};\n+    ptrdiff_t delta;\n+  @};\n+@end example\n+\n+@noindent\n+The C++ compiler must use one bit to indicate whether the function that\n+will be called through a pointer-to-member-function is virtual.\n+Normally, we assume that the low-order bit of a function pointer must\n+always be zero.  Then, by ensuring that the vtable_index is odd, we can\n+distinguish which variant of the union is in use.  But, on some\n+platforms function pointers can be odd, and so this doesn't work.  In\n+that case, we use the low-order bit of the @code{delta} field, and shift\n+the remainder of the @code{delta} field to the left.\n+\n+GCC will automatically make the right selection about where to store\n+this bit using the @code{FUNCTION_BOUNDARY} setting for your platform.\n+However, some platforms such as ARM/Thumb have @code{FUNCTION_BOUNDARY}\n+set such that functions always start at even addresses, but the lowest\n+bit of pointers to functions indicate whether the function at that\n+address is in ARM or Thumb mode.  If this is the case of your\n+architecture, you should define this macro to\n+@code{ptrmemfunc_vbit_in_delta}.\n+\n+In general, you should not have to define this macro.  On architectures\n+in which function addresses are always even, according to\n+@code{FUNCTION_BOUNDARY}, GCC will automatically define this macro to\n+@code{ptrmemfunc_vbit_in_pfn}.\n+\n @findex TARGET_BELL\n @item TARGET_BELL\n A C constant expression for the integer value for escape sequence"}]}