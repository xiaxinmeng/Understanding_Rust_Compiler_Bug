{"sha": "ad59ba209d800635e12601658e043bee5d07bc23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ1OWJhMjA5ZDgwMDYzNWUxMjYwMTY1OGUwNDNiZWU1ZDA3YmMyMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-03-27T22:42:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-03-27T22:42:02Z"}, "message": "real.h (struct real_value): Add signalling.\n\n        * real.h (struct real_value): Add signalling.\n        (EXP_BITS): Decrement.\n        * real.c (get_canonical_qnan): Don't set MSB-1.\n        (get_canonical_snan): Likewise.  Set signalling.\n        (real_identical): Compare signalling.\n        (round_for_format): Remove force-one-bit on code.\n        (real_nan): Likewise.  Set signalling.\n        (encode_ieee_single): Add force-one-bit code; honor signalling.\n        (encode_ieee_double, encode_ieee_extended, encode_ieee_quad): Likewise.\n        (decode_ieee_single): Set signalling.\n        (decode_ieee_double, decode_ieee_extended, decode_ieee_quad): Likewise.\n\nFrom-SVN: r64935", "tree": {"sha": "641d713f41a7b420324d735240da435cb9e3a799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/641d713f41a7b420324d735240da435cb9e3a799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad59ba209d800635e12601658e043bee5d07bc23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad59ba209d800635e12601658e043bee5d07bc23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad59ba209d800635e12601658e043bee5d07bc23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad59ba209d800635e12601658e043bee5d07bc23/comments", "author": null, "committer": null, "parents": [{"sha": "940bbb7441d87498d92168d816f94fb9ca6194b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/940bbb7441d87498d92168d816f94fb9ca6194b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/940bbb7441d87498d92168d816f94fb9ca6194b1"}], "stats": {"total": 98, "additions": 50, "deletions": 48}, "files": [{"sha": "a706e78f8c301b487c2d24f6570f3fc888422e07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad59ba209d800635e12601658e043bee5d07bc23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad59ba209d800635e12601658e043bee5d07bc23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad59ba209d800635e12601658e043bee5d07bc23", "patch": "@@ -1,3 +1,17 @@\n+2003-03-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* real.h (struct real_value): Add signalling.\n+\t(EXP_BITS): Decrement.\n+\t* real.c (get_canonical_qnan): Don't set MSB-1.\n+\t(get_canonical_snan): Likewise.  Set signalling.\n+\t(real_identical): Compare signalling.\n+\t(round_for_format): Remove force-one-bit on code.\n+\t(real_nan): Likewise.  Set signalling.\n+\t(encode_ieee_single): Add force-one-bit code; honor signalling.\n+\t(encode_ieee_double, encode_ieee_extended, encode_ieee_quad): Likewise.\n+\t(decode_ieee_single): Set signalling.\n+\t(decode_ieee_double, decode_ieee_extended, decode_ieee_quad): Likewise.\n+\n 2003-03-27  Olivier Hainque  <hainque@act-europe.fr>\n \n \tPR ada/9953"}, {"sha": "f6074f99639242b9abf6ef49fb2fa2b71d4d8b40", "filename": "gcc/real.c", "status": "modified", "additions": 34, "deletions": 47, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad59ba209d800635e12601658e043bee5d07bc23/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad59ba209d800635e12601658e043bee5d07bc23/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=ad59ba209d800635e12601658e043bee5d07bc23", "patch": "@@ -158,7 +158,6 @@ get_canonical_qnan (r, sign)\n   memset (r, 0, sizeof (*r));\n   r->class = rvc_nan;\n   r->sign = sign;\n-  r->sig[SIGSZ-1] = SIG_MSB >> 1;\n }\n \n static inline void\n@@ -169,7 +168,7 @@ get_canonical_snan (r, sign)\n   memset (r, 0, sizeof (*r));\n   r->class = rvc_nan;\n   r->sign = sign;\n-  r->sig[SIGSZ-1] = SIG_MSB >> 2;\n+  r->signalling = 1;\n }\n \n static inline void\n@@ -1235,6 +1234,8 @@ real_identical (a, b)\n  \treturn false;\n       /* FALLTHRU */\n     case rvc_nan:\n+      if (a->signalling != b->signalling)\n+\treturn false;\n       for (i = 0; i < SIGSZ; ++i)\n \tif (a->sig[i] != b->sig[i])\n \t  return false;\n@@ -2249,23 +2250,7 @@ real_nan (r, str, quiet, mode)\n       r->sig[SIGSZ-1] &= ~SIG_MSB;\n \n       /* Force quiet or signalling NaN.  */\n-      if (quiet)\n-\tr->sig[SIGSZ-1] |= SIG_MSB >> 1;\n-      else\n-\tr->sig[SIGSZ-1] &= ~(SIG_MSB >> 1);\n-\n-      /* Force at least one bit of the significand set.  */\n-      for (d = 0; d < SIGSZ; ++d)\n-\tif (r->sig[d])\n-\t  break;\n-      if (d == SIGSZ)\n-\tr->sig[SIGSZ-1] |= SIG_MSB >> 2;\n-\n-      /* Our intermediate format forces QNaNs to have MSB-1 set.\n-\t If the target format has QNaNs with the top bit unset,\n-\t mirror the output routines and invert the top two bits.  */\n-      if (!fmt->qnan_msb_set)\n-\tr->sig[SIGSZ-1] ^= (SIG_MSB >> 1) | (SIG_MSB >> 2);\n+      r->signalling = !quiet;\n     }\n \n   return true;\n@@ -2325,14 +2310,6 @@ round_for_format (fmt, r)\n \n     case rvc_nan:\n       clear_significand_below (r, np2);\n-\n-      /* If we've cleared the entire significand, we need one bit\n-\t set for this to continue to be a NaN.  */\n-      for (i = 0; i < SIGSZ; ++i)\n-\tif (r->sig[i])\n-\t  break;\n-      if (i == SIGSZ)\n-\tr->sig[SIGSZ-1] = SIG_MSB >> 2;\n       return;\n \n     case rvc_normal:\n@@ -2642,10 +2619,15 @@ encode_ieee_single (fmt, buf, r)\n     case rvc_nan:\n       if (fmt->has_nans)\n \t{\n+\t  if (r->signalling == fmt->qnan_msb_set)\n+\t    sig &= ~(1 << 22);\n+\t  else\n+\t    sig |= 1 << 22;\n+\t  if (sig == 0)\n+\t    sig = 1 << 21;\n+\n \t  image |= 255 << 23;\n \t  image |= sig;\n-\t  if (!fmt->qnan_msb_set)\n-\t    image ^= 1 << 23 | 1 << 22;\n \t}\n       else\n \timage |= 0x7fffffff;\n@@ -2703,8 +2685,7 @@ decode_ieee_single (fmt, r, buf)\n \t{\n \t  r->class = rvc_nan;\n \t  r->sign = sign;\n-\t  if (!fmt->qnan_msb_set)\n-\t    image ^= (SIG_MSB >> 1 | SIG_MSB >> 2);\n+\t  r->signalling = ((image >> 22) & 1) ^ fmt->qnan_msb_set;\n \t  r->sig[SIGSZ-1] = image;\n \t}\n       else\n@@ -2791,10 +2772,15 @@ encode_ieee_double (fmt, buf, r)\n     case rvc_nan:\n       if (fmt->has_nans)\n \t{\n+\t  if (r->signalling == fmt->qnan_msb_set)\n+\t    sig_hi &= ~(1 << 19);\n+\t  else\n+\t    sig_hi |= 1 << 19;\n+\t  if (sig_hi == 0 && sig_lo == 0)\n+\t    sig_hi = 1 << 18;\n+\n \t  image_hi |= 2047 << 20;\n \t  image_hi |= sig_hi;\n-\t  if (!fmt->qnan_msb_set)\n-\t    image_hi ^= 1 << 19 | 1 << 18;\n \t  image_lo = sig_lo;\n \t}\n       else\n@@ -2884,16 +2870,14 @@ decode_ieee_double (fmt, r, buf)\n \t{\n \t  r->class = rvc_nan;\n \t  r->sign = sign;\n+\t  r->signalling = ((image_hi >> 30) & 1) ^ fmt->qnan_msb_set;\n \t  if (HOST_BITS_PER_LONG == 32)\n \t    {\n \t      r->sig[SIGSZ-1] = image_hi;\n \t      r->sig[SIGSZ-2] = image_lo;\n \t    }\n \t  else\n \t    r->sig[SIGSZ-1] = (image_hi << 31 << 1) | image_lo;\n-\n-\t  if (!fmt->qnan_msb_set)\n-\t    r->sig[SIGSZ-1] ^= (SIG_MSB >> 1 | SIG_MSB >> 2);\n \t}\n       else\n \t{\n@@ -2999,8 +2983,12 @@ encode_ieee_extended (fmt, buf, r)\n \t      sig_hi = sig_lo >> 31 >> 1;\n \t      sig_lo &= 0xffffffff;\n \t    }\n-\t  if (!fmt->qnan_msb_set)\n-\t    sig_hi ^= 1 << 30 | 1 << 29;\n+\t  if (r->signalling == fmt->qnan_msb_set)\n+\t    sig_hi &= ~(1 << 30);\n+\t  else\n+\t    sig_hi |= 1 << 30;\n+\t  if ((sig_hi & 0x7fffffff) == 0 && sig_lo == 0)\n+\t    sig_hi = 1 << 29;\n \n \t  /* Intel requires the explicit integer bit to be set, otherwise\n \t     it considers the value a \"pseudo-nan\".  Motorola docs say it\n@@ -3131,16 +3119,14 @@ decode_ieee_extended (fmt, r, buf)\n \t{\n \t  r->class = rvc_nan;\n \t  r->sign = sign;\n+\t  r->signalling = ((sig_hi >> 30) & 1) ^ fmt->qnan_msb_set;\n \t  if (HOST_BITS_PER_LONG == 32)\n \t    {\n \t      r->sig[SIGSZ-1] = sig_hi;\n \t      r->sig[SIGSZ-2] = sig_lo;\n \t    }\n \t  else\n \t    r->sig[SIGSZ-1] = (sig_hi << 31 << 1) | sig_lo;\n-\n-\t  if (!fmt->qnan_msb_set)\n-\t    r->sig[SIGSZ-1] ^= (SIG_MSB >> 1 | SIG_MSB >> 2);\n \t}\n       else\n \t{\n@@ -3395,9 +3381,12 @@ encode_ieee_quad (fmt, buf, r)\n \t      image0 &= 0xffffffff;\n \t      image2 &= 0xffffffff;\n \t    }\n-\n-\t  if (!fmt->qnan_msb_set)\n-\t    image3 ^= 1 << 15 | 1 << 14;\n+\t  if (r->signalling == fmt->qnan_msb_set)\n+\t    image3 &= ~0x8000;\n+\t  else\n+\t    image3 |= 0x8000;\n+\t  if (((image3 & 0xffff) | image2 | image1 | image0) == 0)\n+\t    image3 |= 0x4000;\n \t}\n       else\n \t{\n@@ -3522,6 +3511,7 @@ decode_ieee_quad (fmt, r, buf)\n \t{\n \t  r->class = rvc_nan;\n \t  r->sign = sign;\n+\t  r->signalling = ((image3 >> 15) & 1) ^ fmt->qnan_msb_set;\n \n \t  if (HOST_BITS_PER_LONG == 32)\n \t    {\n@@ -3536,9 +3526,6 @@ decode_ieee_quad (fmt, r, buf)\n \t      r->sig[1] = (image3 << 31 << 1) | image2;\n \t    }\n \t  lshift_significand (r, r, SIGNIFICAND_BITS - 113);\n-\n-\t  if (!fmt->qnan_msb_set)\n-\t    r->sig[SIGSZ-1] ^= (SIG_MSB >> 1 | SIG_MSB >> 2);\n \t}\n       else\n \t{"}, {"sha": "d16231acae88ac35b81536ed0af389811d4cfff9", "filename": "gcc/real.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad59ba209d800635e12601658e043bee5d07bc23/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad59ba209d800635e12601658e043bee5d07bc23/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=ad59ba209d800635e12601658e043bee5d07bc23", "patch": "@@ -35,7 +35,7 @@ enum real_value_class {\n };\n \n #define SIGNIFICAND_BITS\t(128 + HOST_BITS_PER_LONG)\n-#define EXP_BITS\t\t(32 - 3)\n+#define EXP_BITS\t\t(32 - 4)\n #define MAX_EXP\t\t\t((1 << (EXP_BITS - 1)) - 1)\n #define SIGSZ\t\t\t(SIGNIFICAND_BITS / HOST_BITS_PER_LONG)\n #define SIG_MSB\t\t\t((unsigned long)1 << (HOST_BITS_PER_LONG - 1))\n@@ -44,6 +44,7 @@ struct real_value GTY(())\n {\n   ENUM_BITFIELD (real_value_class) class : 2;\n   unsigned int sign : 1;\n+  unsigned int signalling : 1;\n   signed int exp : EXP_BITS;\n   unsigned long sig[SIGSZ];\n };"}]}