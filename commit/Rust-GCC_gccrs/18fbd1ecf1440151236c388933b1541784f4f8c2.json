{"sha": "18fbd1ecf1440151236c388933b1541784f4f8c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThmYmQxZWNmMTQ0MDE1MTIzNmMzODg5MzNiMTU0MTc4NGY0ZjhjMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2015-02-03T03:33:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-02-03T03:33:21Z"}, "message": "re PR go/64836 (go.test/test/fixedbugs/issue4348.go FAILs)\n\n\tPR go/64836\n\tPR go/64838\n\ncompiler: Use int64_t for backend type size and alignment.\n\nFixes 32-bit host 64-bit target cross-compilation.\n\n\t* go-gcc.cc (Gcc_backend::type_size): Change return type to\n\tint64_t.\n\t(Gcc_backend::type_alignment): Likewise.\n\t(Gcc_backend::type_field_alignment): Likewise.\n\t(Gcc_backend::type_field_offset): Likewise.\n\t(Gcc_backend::implicit_variable): Change alignment parameter type\n\tto int64_t.\n\nFrom-SVN: r220364", "tree": {"sha": "78fb832e42f96e31bd518c22227ffe0aaa2eb0eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78fb832e42f96e31bd518c22227ffe0aaa2eb0eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18fbd1ecf1440151236c388933b1541784f4f8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fbd1ecf1440151236c388933b1541784f4f8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fbd1ecf1440151236c388933b1541784f4f8c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fbd1ecf1440151236c388933b1541784f4f8c2/comments", "author": null, "committer": null, "parents": [{"sha": "879887f1d250f677eb22d9aec6714ce131fd995b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/879887f1d250f677eb22d9aec6714ce131fd995b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/879887f1d250f677eb22d9aec6714ce131fd995b"}], "stats": {"total": 259, "additions": 158, "deletions": 101}, "files": [{"sha": "1cee68cb76ffade9cc64c18dbaca727ce1600233", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -1,3 +1,15 @@\n+2015-02-02  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR go/64836\n+\tPR go/64838\n+\t* go-gcc.cc (Gcc_backend::type_size): Change return type to\n+\tint64_t.\n+\t(Gcc_backend::type_alignment): Likewise.\n+\t(Gcc_backend::type_field_alignment): Likewise.\n+\t(Gcc_backend::type_field_offset): Likewise.\n+\t(Gcc_backend::implicit_variable): Change alignment parameter type\n+\tto int64_t.\n+\n 2015-01-23  Ian Lance Taylor  <iant@google.com>\n \n \tPR go/63565"}, {"sha": "08f014fa02e0693e14f8f3e337e6e7b7ec456d56", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -223,16 +223,16 @@ class Gcc_backend : public Backend\n   bool\n   is_circular_pointer_type(Btype*);\n \n-  size_t\n+  int64_t\n   type_size(Btype*);\n \n-  size_t\n+  int64_t\n   type_alignment(Btype*);\n \n-  size_t\n+  int64_t\n   type_field_alignment(Btype*);\n \n-  size_t\n+  int64_t\n   type_field_offset(Btype*, size_t index);\n \n   // Expressions.\n@@ -411,7 +411,7 @@ class Gcc_backend : public Backend\n \n   Bvariable*\n   implicit_variable(const std::string&, Btype*, bool, bool, bool,\n-\t\t    size_t);\n+\t\t    int64_t);\n \n   void\n   implicit_variable_set_init(Bvariable*, const std::string&, Btype*,\n@@ -1097,7 +1097,7 @@ Gcc_backend::is_circular_pointer_type(Btype* btype)\n \n // Return the size of a type.\n \n-size_t\n+int64_t\n Gcc_backend::type_size(Btype* btype)\n {\n   tree t = btype->get_tree();\n@@ -1106,14 +1106,14 @@ Gcc_backend::type_size(Btype* btype)\n   t = TYPE_SIZE_UNIT(t);\n   gcc_assert(tree_fits_uhwi_p (t));\n   unsigned HOST_WIDE_INT val_wide = TREE_INT_CST_LOW(t);\n-  size_t ret = static_cast<size_t>(val_wide);\n-  gcc_assert(ret == val_wide);\n+  int64_t ret = static_cast<int64_t>(val_wide);\n+  gcc_assert(ret >= 0 && static_cast<unsigned HOST_WIDE_INT>(ret) == val_wide);\n   return ret;\n }\n \n // Return the alignment of a type.\n \n-size_t\n+int64_t\n Gcc_backend::type_alignment(Btype* btype)\n {\n   tree t = btype->get_tree();\n@@ -1124,7 +1124,7 @@ Gcc_backend::type_alignment(Btype* btype)\n \n // Return the alignment of a struct field of type BTYPE.\n \n-size_t\n+int64_t\n Gcc_backend::type_field_alignment(Btype* btype)\n {\n   tree t = btype->get_tree();\n@@ -1135,7 +1135,7 @@ Gcc_backend::type_field_alignment(Btype* btype)\n \n // Return the offset of a field in a struct.\n \n-size_t\n+int64_t\n Gcc_backend::type_field_offset(Btype* btype, size_t index)\n {\n   tree struct_tree = btype->get_tree();\n@@ -1149,9 +1149,8 @@ Gcc_backend::type_field_offset(Btype* btype, size_t index)\n       gcc_assert(field != NULL_TREE);\n     }\n   HOST_WIDE_INT offset_wide = int_byte_position(field);\n-  gcc_assert(offset_wide >= 0);\n-  size_t ret = static_cast<size_t>(offset_wide);\n-  gcc_assert(ret == static_cast<unsigned HOST_WIDE_INT>(offset_wide));\n+  int64_t ret = static_cast<int64_t>(offset_wide);\n+  gcc_assert(ret == offset_wide);\n   return ret;\n }\n \n@@ -2609,7 +2608,7 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n Bvariable*\n Gcc_backend::implicit_variable(const std::string& name, Btype* type,\n \t\t\t       bool is_hidden, bool is_constant,\n-\t\t\t       bool is_common, size_t alignment)\n+\t\t\t       bool is_common, int64_t alignment)\n {\n   tree type_tree = type->get_tree();\n   if (type_tree == error_mark_node)"}, {"sha": "b5071ae67c56493ff2bf3d4222a7c9549a61d7a7", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -216,22 +216,22 @@ class Backend\n   is_circular_pointer_type(Btype*) = 0;\n \n   // Return the size of a type.\n-  virtual size_t\n+  virtual int64_t\n   type_size(Btype*) = 0;\n \n   // Return the alignment of a type.\n-  virtual size_t\n+  virtual int64_t\n   type_alignment(Btype*) = 0;\n \n   // Return the alignment of a struct field of this type.  This is\n   // normally the same as type_alignment, but not always.\n-  virtual size_t\n+  virtual int64_t\n   type_field_alignment(Btype*) = 0;\n \n   // Return the offset of field INDEX in a struct type.  INDEX is the\n   // entry in the FIELDS std::vector parameter of struct_type or\n   // set_placeholder_struct_type.\n-  virtual size_t\n+  virtual int64_t\n   type_field_offset(Btype*, size_t index) = 0;\n \n   // Expressions.\n@@ -575,7 +575,7 @@ class Backend\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n   virtual Bvariable*\n   implicit_variable(const std::string& name, Btype* type, bool is_hidden,\n-\t\t    bool is_constant, bool is_common, size_t alignment) = 0;\n+\t\t    bool is_constant, bool is_common, int64_t alignment) = 0;\n \n \n   // Set the initial value of a variable created by implicit_variable."}, {"sha": "0cb0938fda1e8005b3f143f1ad8df14226b91c6b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 72, "deletions": 27, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -181,8 +181,10 @@ Expression::convert_for_assignment(Gogo* gogo, Type* lhs_type,\n       // represented as non-zero-sized.\n       // TODO(cmang): This check is for a GCC-specific issue, and should be\n       // removed from the frontend.  FIXME.\n-      size_t lhs_size = gogo->backend()->type_size(lhs_type->get_backend(gogo));\n-      size_t rhs_size = gogo->backend()->type_size(rhs_type->get_backend(gogo));\n+      int64_t lhs_size =\n+\tgogo->backend()->type_size(lhs_type->get_backend(gogo));\n+      int64_t rhs_size =\n+\tgogo->backend()->type_size(rhs_type->get_backend(gogo));\n       if (rhs_size == 0 || lhs_size == 0)\n \treturn rhs;\n \n@@ -2112,6 +2114,48 @@ Expression::make_integer_sl(long val, Type *type, Location location)\n   return ret;\n }\n \n+// Store an int64_t in an uninitialized mpz_t.\n+\n+static void\n+set_mpz_from_int64(mpz_t* zval, int64_t val)\n+{\n+  if (val >= 0)\n+    {\n+      unsigned long ul = static_cast<unsigned long>(val);\n+      if (static_cast<int64_t>(ul) == val)\n+\t{\n+\t  mpz_init_set_ui(*zval, ul);\n+\t  return;\n+\t}\n+    }\n+  uint64_t uv;\n+  if (val >= 0)\n+    uv = static_cast<uint64_t>(val);\n+  else\n+    uv = static_cast<uint64_t>(- val);\n+  unsigned long ul = uv & 0xffffffffUL;\n+  mpz_init_set_ui(*zval, ul);\n+  mpz_t hval;\n+  mpz_init_set_ui(hval, static_cast<unsigned long>(uv >> 32));\n+  mpz_mul_2exp(hval, hval, 32);\n+  mpz_add(*zval, *zval, hval);\n+  mpz_clear(hval);\n+  if (val < 0)\n+    mpz_neg(*zval, *zval);\n+}\n+\n+// Build a new integer value from an int64_t.\n+\n+Expression*\n+Expression::make_integer_int64(int64_t val, Type* type, Location location)\n+{\n+  mpz_t zval;\n+  set_mpz_from_int64(&zval, val);\n+  Expression* ret = Expression::make_integer_z(&zval, type, location);\n+  mpz_clear(zval);\n+  return ret;\n+}\n+\n // Build a new character constant value.\n \n Expression*\n@@ -3694,7 +3738,7 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n       if (!ptype->is_void_type())\n         {\n           Btype* pbtype = ptype->get_backend(gogo);\n-          size_t s = gogo->backend()->type_size(pbtype);\n+          int64_t s = gogo->backend()->type_size(pbtype);\n           if (s >= 4096 || this->issue_nil_check_)\n             {\n               Temporary_statement* temp =\n@@ -4182,7 +4226,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n         Btype* pbtype = ptype->get_backend(gogo);\n         if (!ptype->is_void_type())\n \t  {\n-            size_t s = gogo->backend()->type_size(pbtype);\n+            int64_t s = gogo->backend()->type_size(pbtype);\n \t    if (s >= 4096 || this->issue_nil_check_)\n \t      {\n                 go_assert(this->expr_->is_variable());\n@@ -7361,7 +7405,7 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n       if (this->seen_)\n         return false;\n \n-      unsigned long ret;\n+      int64_t ret;\n       if (this->code_ == BUILTIN_SIZEOF)\n \t{\n           this->seen_ = true;\n@@ -7389,7 +7433,10 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n       else\n \tgo_unreachable();\n \n-      nc->set_unsigned_long(Type::lookup_integer_type(\"uintptr\"), ret);\n+      mpz_t zval;\n+      set_mpz_from_int64(&zval, ret);\n+      nc->set_int(Type::lookup_integer_type(\"uintptr\"), zval);\n+      mpz_clear(zval);\n       return true;\n     }\n   else if (this->code_ == BUILTIN_OFFSETOF)\n@@ -7403,7 +7450,7 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n       if (this->seen_)\n         return false;\n \n-      unsigned int total_offset = 0;\n+      int64_t total_offset = 0;\n       while (true)\n         {\n           Expression* struct_expr = farg->expr();\n@@ -7412,7 +7459,7 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n             return false;\n           if (st->named_type() != NULL)\n             st->named_type()->convert(this->gogo_);\n-          unsigned int offset;\n+          int64_t offset;\n           this->seen_ = true;\n           bool ok = st->struct_type()->backend_field_offset(this->gogo_,\n \t\t\t\t\t\t\t    farg->field_index(),\n@@ -7429,8 +7476,10 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n             }\n           break;\n         }\n-      nc->set_unsigned_long(Type::lookup_integer_type(\"uintptr\"),\n-\t\t\t    static_cast<unsigned long>(total_offset));\n+      mpz_t zval;\n+      set_mpz_from_int64(&zval, total_offset);\n+      nc->set_int(Type::lookup_integer_type(\"uintptr\"), zval);\n+      mpz_clear(zval);\n       return true;\n     }\n   else if (this->code_ == BUILTIN_REAL || this->code_ == BUILTIN_IMAG)\n@@ -8329,10 +8378,10 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \n \tType* element_type = at->element_type();\n \tBtype* element_btype = element_type->get_backend(gogo);\n-\tsize_t element_size = gogo->backend()->type_size(element_btype);\n-\tExpression* size_expr = Expression::make_integer_ul(element_size,\n-\t\t\t\t\t\t\t    length->type(),\n-\t\t\t\t\t\t\t    location);\n+\tint64_t element_size = gogo->backend()->type_size(element_btype);\n+\tExpression* size_expr = Expression::make_integer_int64(element_size,\n+\t\t\t\t\t\t\t       length->type(),\n+\t\t\t\t\t\t\t       location);\n         Expression* bytecount =\n             Expression::make_binary(OPERATOR_MULT, size_expr, length, location);\n         Expression* copy = Runtime::make_call(Runtime::COPY, location, 3,\n@@ -8355,7 +8404,7 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n         go_assert(arg2->is_variable());\n \tExpression* arg2_val;\n \tExpression* arg2_len;\n-\tunsigned long size;\n+\tint64_t size;\n \tif (arg2->type()->is_string_type()\n \t    && element_type->integer_type() != NULL\n \t    && element_type->integer_type()->is_byte())\n@@ -8374,7 +8423,7 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t    size = gogo->backend()->type_size(element_btype);\n \t  }\n         Expression* element_size =\n-\t  Expression::make_integer_ul(size, NULL, location);\n+\t  Expression::make_integer_int64(size, NULL, location);\n \n         Expression* append = Runtime::make_call(Runtime::APPEND, location, 4,\n                                                 arg1, arg2_val, arg2_len,\n@@ -14028,7 +14077,7 @@ Type_info_expression::do_get_backend(Translate_context* context)\n {\n   Btype* btype = this->type_->get_backend(context->gogo());\n   Gogo* gogo = context->gogo();\n-  size_t val;\n+  int64_t val;\n   switch (this->type_info_)\n     {\n     case TYPE_INFO_SIZE:\n@@ -14043,13 +14092,9 @@ Type_info_expression::do_get_backend(Translate_context* context)\n     default:\n       go_unreachable();\n     }\n-  mpz_t cst;\n-  mpz_init_set_ui(cst, val);\n-  Btype* int_btype = this->type()->get_backend(gogo);\n-  Bexpression* ret =\n-    gogo->backend()->integer_constant_expression(int_btype, cst);\n-  mpz_clear(cst);\n-  return ret;\n+  Expression* e = Expression::make_integer_int64(val, this->type(),\n+\t\t\t\t\t\t this->location());\n+  return e->get_backend(context);\n }\n \n // Dump ast representation for a type info expression.\n@@ -14780,11 +14825,11 @@ Struct_field_offset_expression::do_get_backend(Translate_context* context)\n   Gogo* gogo = context->gogo();\n   Btype* btype = this->type_->get_backend(gogo);\n \n-  size_t offset = gogo->backend()->type_field_offset(btype, i);\n+  int64_t offset = gogo->backend()->type_field_offset(btype, i);\n   Type* uptr_type = Type::lookup_integer_type(\"uintptr\");\n   Expression* ret =\n-    Expression::make_integer_ul(offset, uptr_type,\n-\t\t\t\tLinemap::predeclared_location());\n+    Expression::make_integer_int64(offset, uptr_type,\n+\t\t\t\t   Linemap::predeclared_location());\n   return ret->get_backend(context);\n }\n "}, {"sha": "fbccdf04c1c614ba0113831bf45a5545fcf8d0b5", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -233,6 +233,11 @@ class Expression\n   static Expression*\n   make_integer_sl(long, Type*, Location);\n \n+  // Make a constant integer expression from an int64_t.  TYPE should\n+  // be NULL for an abstract type.\n+  static Expression*\n+  make_integer_int64(int64_t, Type*, Location);\n+\n   // Make a constant float expression.  TYPE should be NULL for an\n   // abstract type.\n   static Expression*"}, {"sha": "ab305cf27413138d70934f3ee40c337ef73398e9", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -602,7 +602,7 @@ Gogo::zero_value(Type *type)\n     }\n \n   // The zero value will be the maximum required size.\n-  unsigned long size;\n+  int64_t size;\n   bool ok = type->backend_type_size(this, &size);\n   if (!ok) {\n     go_assert(saw_errors());\n@@ -611,7 +611,7 @@ Gogo::zero_value(Type *type)\n   if (size > this->zero_value_size_)\n     this->zero_value_size_ = size;\n \n-  unsigned long align;\n+  int64_t align;\n   ok = type->backend_type_align(this, &align);\n   if (!ok) {\n     go_assert(saw_errors());\n@@ -644,13 +644,12 @@ Gogo::backend_zero_value()\n   Btype* bbtype_type = byte_type->get_backend(this);\n \n   Type* int_type = this->lookup_global(\"int\")->type_value();\n-  Btype* bint_type = int_type->get_backend(this);\n \n-  mpz_t val;\n-  mpz_init_set_ui(val, this->zero_value_size_);\n-  Bexpression* blength =\n-    this->backend()->integer_constant_expression(bint_type, val);\n-  mpz_clear(val);\n+  Expression* e = Expression::make_integer_int64(this->zero_value_size_,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t Linemap::unknown_location());\n+  Translate_context context(this, NULL, NULL, NULL);\n+  Bexpression* blength = e->get_backend(&context);\n \n   Btype* barray_type = this->backend()->array_type(bbtype_type, blength);\n "}, {"sha": "6d0823679285dfcd5809bcef85f9f75e222cf10c", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -746,9 +746,9 @@ class Gogo\n   // The special zero value variable.\n   Named_object* zero_value_;\n   // The size of the zero value variable.\n-  unsigned long zero_value_size_;\n+  int64_t zero_value_size_;\n   // The alignment of the zero value variable, in bytes.\n-  unsigned long zero_value_align_;\n+  int64_t zero_value_align_;\n   // Whether pkgpath_ has been set.\n   bool pkgpath_set_;\n   // Whether an explicit package path was set by -fgo-pkgpath."}, {"sha": "785889fb5c82af4e5f273ff89343e575999bded7", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -2533,47 +2533,38 @@ Type::is_backend_type_size_known(Gogo* gogo)\n // the backend.\n \n bool\n-Type::backend_type_size(Gogo* gogo, unsigned long *psize)\n+Type::backend_type_size(Gogo* gogo, int64_t *psize)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n   Btype* bt = this->get_backend_placeholder(gogo);\n-  size_t size = gogo->backend()->type_size(bt);\n-  *psize = static_cast<unsigned long>(size);\n-  if (*psize != size)\n-    return false;\n+  *psize = gogo->backend()->type_size(bt);\n   return true;\n }\n \n // If the alignment of the type can be determined, set *PALIGN to\n // the alignment in bytes and return true.  Otherwise, return false.\n \n bool\n-Type::backend_type_align(Gogo* gogo, unsigned long *palign)\n+Type::backend_type_align(Gogo* gogo, int64_t *palign)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n   Btype* bt = this->get_backend_placeholder(gogo);\n-  size_t align = gogo->backend()->type_alignment(bt);\n-  *palign = static_cast<unsigned long>(align);\n-  if (*palign != align)\n-    return false;\n+  *palign = gogo->backend()->type_alignment(bt);\n   return true;\n }\n \n // Like backend_type_align, but return the alignment when used as a\n // field.\n \n bool\n-Type::backend_type_field_align(Gogo* gogo, unsigned long *palign)\n+Type::backend_type_field_align(Gogo* gogo, int64_t *palign)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n   Btype* bt = this->get_backend_placeholder(gogo);\n-  size_t a = gogo->backend()->type_field_alignment(bt);\n-  *palign = static_cast<unsigned long>(a);\n-  if (*palign != a)\n-    return false;\n+  *palign = gogo->backend()->type_field_alignment(bt);\n   return true;\n }\n \n@@ -4780,7 +4771,7 @@ Struct_type::do_compare_is_identity(Gogo* gogo)\n   const Struct_field_list* fields = this->fields_;\n   if (fields == NULL)\n     return true;\n-  unsigned long offset = 0;\n+  int64_t offset = 0;\n   for (Struct_field_list::const_iterator pf = fields->begin();\n        pf != fields->end();\n        ++pf)\n@@ -4791,7 +4782,7 @@ Struct_type::do_compare_is_identity(Gogo* gogo)\n       if (!pf->type()->compare_is_identity(gogo))\n \treturn false;\n \n-      unsigned long field_align;\n+      int64_t field_align;\n       if (!pf->type()->backend_type_align(gogo, &field_align))\n \treturn false;\n       if ((offset & (field_align - 1)) != 0)\n@@ -4802,13 +4793,13 @@ Struct_type::do_compare_is_identity(Gogo* gogo)\n \t  return false;\n \t}\n \n-      unsigned long field_size;\n+      int64_t field_size;\n       if (!pf->type()->backend_type_size(gogo, &field_size))\n \treturn false;\n       offset += field_size;\n     }\n \n-  unsigned long struct_size;\n+  int64_t struct_size;\n   if (!this->backend_type_size(gogo, &struct_size))\n     return false;\n   if (offset != struct_size)\n@@ -5571,15 +5562,12 @@ Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \n bool\n Struct_type::backend_field_offset(Gogo* gogo, unsigned int index,\n-\t\t\t\t  unsigned int* poffset)\n+\t\t\t\t  int64_t* poffset)\n {\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n   Btype* bt = this->get_backend_placeholder(gogo);\n-  size_t offset = gogo->backend()->type_field_offset(bt, index);\n-  *poffset = static_cast<unsigned int>(offset);\n-  if (*poffset != offset)\n-    return false;\n+  *poffset = gogo->backend()->type_field_offset(bt, index);\n   return true;\n }\n \n@@ -5764,10 +5752,17 @@ Array_type::verify_length()\n       return false;\n     }\n \n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  unsigned int tbits = int_type->integer_type()->bits();\n   unsigned long val;\n   switch (nc.to_unsigned_long(&val))\n     {\n     case Numeric_constant::NC_UL_VALID:\n+      if (sizeof(val) >= tbits / 8 && val >> (tbits - 1) != 0)\n+\t{\n+\t  error_at(this->length_->location(), \"array bound overflows\");\n+\t  return false;\n+\t}\n       break;\n     case Numeric_constant::NC_UL_NOTINT:\n       error_at(this->length_->location(), \"array bound truncated to integer\");\n@@ -5776,21 +5771,23 @@ Array_type::verify_length()\n       error_at(this->length_->location(), \"negative array bound\");\n       return false;\n     case Numeric_constant::NC_UL_BIG:\n-      error_at(this->length_->location(), \"array bound overflows\");\n-      return false;\n+      {\n+\tmpz_t val;\n+\tif (!nc.to_int(&val))\n+\t  go_unreachable();\n+\tunsigned int bits = mpz_sizeinbase(val, 2);\n+\tmpz_clear(val);\n+\tif (bits >= tbits)\n+\t  {\n+\t    error_at(this->length_->location(), \"array bound overflows\");\n+\t    return false;\n+\t  }\n+      }\n+      break;\n     default:\n       go_unreachable();\n     }\n \n-  Type* int_type = Type::lookup_integer_type(\"int\");\n-  unsigned int tbits = int_type->integer_type()->bits();\n-  if (sizeof(val) <= tbits * 8\n-      && val >> (tbits - 1) != 0)\n-    {\n-      error_at(this->length_->location(), \"array bound overflows\");\n-      return false;\n-    }\n-\n   return true;\n }\n \n@@ -5820,8 +5817,8 @@ Array_type::do_compare_is_identity(Gogo* gogo)\n     return false;\n \n   // If there is any padding, then we can't use memcmp.\n-  unsigned long size;\n-  unsigned long align;\n+  int64_t size;\n+  int64_t align;\n   if (!this->element_type_->backend_type_size(gogo, &size)\n       || !this->element_type_->backend_type_align(gogo, &align))\n     return false;\n@@ -6417,7 +6414,7 @@ Array_type::slice_gc_symbol(Gogo* gogo, Expression_list** vals,\n   // Differentiate between slices with zero-length and non-zero-length values.\n   Type* element_type = this->element_type();\n   Btype* ebtype = element_type->get_backend(gogo);\n-  size_t element_size = gogo->backend()->type_size(ebtype);\n+  int64_t element_size = gogo->backend()->type_size(ebtype);\n \n   Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n   unsigned long opval = element_size == 0 ? GC_APTR : GC_SLICE;\n@@ -6444,8 +6441,8 @@ Array_type::array_gc_symbol(Gogo* gogo, Expression_list** vals,\n     go_assert(saw_errors());\n \n   Btype* pbtype = gogo->backend()->pointer_type(gogo->backend()->void_type());\n-  size_t pwidth = gogo->backend()->type_size(pbtype);\n-  size_t iwidth = gogo->backend()->type_size(this->get_backend(gogo));\n+  int64_t pwidth = gogo->backend()->type_size(pbtype);\n+  int64_t iwidth = gogo->backend()->type_size(this->get_backend(gogo));\n \n   Type* element_type = this->element_type();\n   if (bound < 1 || !element_type->has_pointer())"}, {"sha": "82d5081222835702c9ac469f33310b6359af60e6", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fbd1ecf1440151236c388933b1541784f4f8c2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=18fbd1ecf1440151236c388933b1541784f4f8c2", "patch": "@@ -942,18 +942,18 @@ class Type\n   // in bytes and return true.  Otherwise, return false.  This queries\n   // the backend.\n   bool\n-  backend_type_size(Gogo*, unsigned long* psize);\n+  backend_type_size(Gogo*, int64_t* psize);\n \n   // If the alignment of the type can be determined, set *PALIGN to\n   // the alignment in bytes and return true.  Otherwise, return false.\n   bool\n-  backend_type_align(Gogo*, unsigned long* palign);\n+  backend_type_align(Gogo*, int64_t* palign);\n \n   // If the alignment of a struct field of this type can be\n   // determined, set *PALIGN to the alignment in bytes and return\n   // true.  Otherwise, return false.\n   bool\n-  backend_type_field_align(Gogo*, unsigned long* palign);\n+  backend_type_field_align(Gogo*, int64_t* palign);\n \n   // Whether the backend size is known.\n   bool\n@@ -2263,7 +2263,7 @@ class Struct_type : public Type\n   // determined, set *POFFSET to the offset in bytes and return true.\n   // Otherwise, return false.\n   bool\n-  backend_field_offset(Gogo*, unsigned int index, unsigned int* poffset);\n+  backend_field_offset(Gogo*, unsigned int index, int64_t* poffset);\n \n   // Finish the backend representation of all the fields.\n   void"}]}