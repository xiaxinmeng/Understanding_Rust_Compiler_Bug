{"sha": "f72f4169133572cf62f1e872c5657cdbc4d5de2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyZjQxNjkxMzM1NzJjZjYyZjFlODcyYzU2NTdjZGJjNGQ1ZGUyYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-30T15:33:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-30T15:33:16Z"}, "message": "Update to current Go library.\n\nFrom-SVN: r171732", "tree": {"sha": "9382d76e5dc68294cdf3c4f2c03a9f61b44fb014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9382d76e5dc68294cdf3c4f2c03a9f61b44fb014"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f72f4169133572cf62f1e872c5657cdbc4d5de2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72f4169133572cf62f1e872c5657cdbc4d5de2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f72f4169133572cf62f1e872c5657cdbc4d5de2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72f4169133572cf62f1e872c5657cdbc4d5de2c/comments", "author": null, "committer": null, "parents": [{"sha": "f2034d064c29d9620c5562b2b5b517bdc6c7a672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2034d064c29d9620c5562b2b5b517bdc6c7a672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2034d064c29d9620c5562b2b5b517bdc6c7a672"}], "stats": {"total": 2600, "additions": 1924, "deletions": 676}, "files": [{"sha": "0c531968e669a01afd885cedb825853e54165d06", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug243.go", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug243.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -6,12 +6,14 @@\n \n package main\n \n-import (\n-\t\"net\"\n-)\n+import \"os\"\n+\n+// Issue 481: closures and var declarations\n+// with multiple variables assigned from one\n+// function call.\n \n func main() {\n-\tvar listen, _ = net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\tvar listen, _ = Listen(\"tcp\", \"127.0.0.1:0\")\n \n \tgo func() {\n \t\tfor {\n@@ -20,6 +22,31 @@ func main() {\n \t\t}\n \t}()\n \n-\tvar conn, _ = net.Dial(\"tcp\", \"\", listen.Addr().String())\n+\tvar conn, _ = Dial(\"tcp\", \"\", listen.Addr().String())\n \t_ = conn\n }\n+\n+// Simulated net interface to exercise bug\n+// without involving a real network.\n+type T chan int\n+\n+var global T\n+\n+func Listen(x, y string) (T, string) {\n+\tglobal = make(chan int)\n+\treturn global, y\n+}\n+\n+func (t T) Addr() os.Error {\n+\treturn os.ErrorString(\"stringer\")\n+}\n+\n+func (t T) Accept() (int, string) {\n+\treturn <-t, \"\"\n+}\n+\n+func Dial(x, y, z string) (int, string) {\n+\tglobal <- 1\n+\treturn 0, \"\"\n+}\n+"}, {"sha": "b78ba690a547d433e8022494053362139b9c5059", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -1,4 +1,4 @@\n-31d7feb9281b\n+342e3b11f21a\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "0545d7d8396e631e3cf82b7a15dfdb6de83dbf0e", "filename": "libgo/Makefile.am", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -657,17 +657,20 @@ endif # !LIBGO_IS_LINUX\n endif # !LIBGO_IS_RTEMS\n \n go_net_files = \\\n+\tgo/net/cgo_stub.go \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsconfig.go \\\n \tgo/net/dnsmsg.go \\\n \t$(go_net_newpollserver_file) \\\n \tgo/net/fd.go \\\n \t$(go_net_fd_os_file) \\\n+\tgo/net/file.go \\\n \tgo/net/hosts.go \\\n \tgo/net/ip.go \\\n \tgo/net/iprawsock.go \\\n \tgo/net/ipsock.go \\\n+\tgo/net/lookup.go \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n@@ -1095,6 +1098,7 @@ go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n \tgo/go/ast/filter.go \\\n \tgo/go/ast/print.go \\\n+\tgo/go/ast/resolve.go \\\n \tgo/go/ast/scope.go \\\n \tgo/go/ast/walk.go\n go_go_doc_files = \\\n@@ -2327,8 +2331,8 @@ exp/eval/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: exp/eval/check\n \n-go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/token.gox io.gox os.gox \\\n-\t\treflect.gox unicode.gox utf8.gox\n+go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/scanner.gox go/token.gox \\\n+\t\tio.gox os.gox reflect.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/ast/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/ast"}, {"sha": "b7500666197433ca7ea70ad16f003a8e91c1685a", "filename": "libgo/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -1039,17 +1039,20 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_RTEMS_TRUE@go_net_newpollserver_file = go/net/newpollserver_rtems.go\n go_net_files = \\\n+\tgo/net/cgo_stub.go \\\n \tgo/net/dial.go \\\n \tgo/net/dnsclient.go \\\n \tgo/net/dnsconfig.go \\\n \tgo/net/dnsmsg.go \\\n \t$(go_net_newpollserver_file) \\\n \tgo/net/fd.go \\\n \t$(go_net_fd_os_file) \\\n+\tgo/net/file.go \\\n \tgo/net/hosts.go \\\n \tgo/net/ip.go \\\n \tgo/net/iprawsock.go \\\n \tgo/net/ipsock.go \\\n+\tgo/net/lookup.go \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n@@ -1483,6 +1486,7 @@ go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n \tgo/go/ast/filter.go \\\n \tgo/go/ast/print.go \\\n+\tgo/go/ast/resolve.go \\\n \tgo/go/ast/scope.go \\\n \tgo/go/ast/walk.go\n \n@@ -4747,8 +4751,8 @@ exp/eval/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: exp/eval/check\n \n-go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/token.gox io.gox os.gox \\\n-\t\treflect.gox unicode.gox utf8.gox\n+go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/scanner.gox go/token.gox \\\n+\t\tio.gox os.gox reflect.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/ast/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/ast"}, {"sha": "838cb7e1fefc719ac1cc5ac3e21c80e945417d6e", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -150,5 +150,8 @@ testLoop:\n \t\t\tt.Errorf(\"test %d: Incorrect result: (-=expected, +=actual)\\n%v\",\n \t\t\t\ti, bytediff(expected, actual))\n \t\t}\n+\t\tif testing.Short() { // The second test is expensive.\n+\t\t\tbreak\n+\t\t}\n \t}\n }"}, {"sha": "c5314517b34f428841d4b8304990ae406261c1e3", "filename": "libgo/go/asn1/asn1.go", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -389,6 +389,11 @@ func parseSequenceOf(bytes []byte, sliceType *reflect.SliceType, elemType reflec\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n+\t\t// We pretend that GENERAL STRINGs are PRINTABLE STRINGs so\n+\t\t// that a sequence of them can be parsed into a []string.\n+\t\tif t.tag == tagGeneralString {\n+\t\t\tt.tag = tagPrintableString\n+\t\t}\n \t\tif t.class != classUniversal || t.isCompound != compoundType || t.tag != expectedTag {\n \t\t\terr = StructuralError{\"sequence tag mismatch\"}\n \t\t\treturn\n@@ -516,7 +521,11 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\treturn\n \t}\n \tif params.explicit {\n-\t\tif t.class == classContextSpecific && t.tag == *params.tag && (t.length == 0 || t.isCompound) {\n+\t\texpectedClass := classContextSpecific\n+\t\tif params.application {\n+\t\t\texpectedClass = classApplication\n+\t\t}\n+\t\tif t.class == expectedClass && t.tag == *params.tag && (t.length == 0 || t.isCompound) {\n \t\t\tif t.length > 0 {\n \t\t\t\tt, offset, err = parseTagAndLength(bytes, offset)\n \t\t\t\tif err != nil {\n@@ -551,6 +560,10 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \tif universalTag == tagPrintableString && t.tag == tagIA5String {\n \t\tuniversalTag = tagIA5String\n \t}\n+\t// Likewise for GeneralString\n+\tif universalTag == tagPrintableString && t.tag == tagGeneralString {\n+\t\tuniversalTag = tagGeneralString\n+\t}\n \n \t// Special case for time: UTCTime and GeneralizedTime both map to the\n \t// Go type time.Time.\n@@ -566,6 +579,11 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\texpectedTag = *params.tag\n \t}\n \n+\tif !params.explicit && params.application && params.tag != nil {\n+\t\texpectedClass = classApplication\n+\t\texpectedTag = *params.tag\n+\t}\n+\n \t// We have unwrapped any explicit tagging at this point.\n \tif t.class != expectedClass || t.tag != expectedTag || t.isCompound != compoundType {\n \t\t// Tags don't match. Again, it could be an optional element.\n@@ -701,6 +719,12 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\tv, err = parseIA5String(innerBytes)\n \t\tcase tagT61String:\n \t\t\tv, err = parseT61String(innerBytes)\n+\t\tcase tagGeneralString:\n+\t\t\t// GeneralString is specified in ISO-2022/ECMA-35,\n+\t\t\t// A brief review suggests that it includes structures\n+\t\t\t// that allow the encoding to change midstring and\n+\t\t\t// such. We give up and pass it as an 8-bit string.\n+\t\t\tv, err = parseT61String(innerBytes)\n \t\tdefault:\n \t\t\terr = SyntaxError{fmt.Sprintf(\"internal error: unknown string type %d\", universalTag)}\n \t\t}\n@@ -776,8 +800,14 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n // Other ASN.1 types are not supported; if it encounters them,\n // Unmarshal returns a parse error.\n func Unmarshal(b []byte, val interface{}) (rest []byte, err os.Error) {\n+\treturn UnmarshalWithParams(b, val, \"\")\n+}\n+\n+// UnmarshalWithParams allows field parameters to be specified for the\n+// top-level element. The form of the params is the same as the field tags.\n+func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err os.Error) {\n \tv := reflect.NewValue(val).(*reflect.PtrValue).Elem()\n-\toffset, err := parseField(v, b, 0, fieldParameters{})\n+\toffset, err := parseField(v, b, 0, parseFieldParameters(params))\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "b7767656a428dfa51294aaaa7e537aa886b0baea", "filename": "libgo/go/asn1/asn1_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -249,11 +249,12 @@ var parseFieldParametersTestData []parseFieldParametersTest = []parseFieldParame\n \t{\"printable\", fieldParameters{stringType: tagPrintableString}},\n \t{\"optional\", fieldParameters{optional: true}},\n \t{\"explicit\", fieldParameters{explicit: true, tag: new(int)}},\n+\t{\"application\", fieldParameters{application: true, tag: new(int)}},\n \t{\"optional,explicit\", fieldParameters{optional: true, explicit: true, tag: new(int)}},\n \t{\"default:42\", fieldParameters{defaultValue: newInt64(42)}},\n \t{\"tag:17\", fieldParameters{tag: newInt(17)}},\n \t{\"optional,explicit,default:42,tag:17\", fieldParameters{optional: true, explicit: true, defaultValue: newInt64(42), tag: newInt(17)}},\n-\t{\"optional,explicit,default:42,tag:17,rubbish1\", fieldParameters{true, true, newInt64(42), newInt(17), 0, false}},\n+\t{\"optional,explicit,default:42,tag:17,rubbish1\", fieldParameters{true, true, false, newInt64(42), newInt(17), 0, false}},\n \t{\"set\", fieldParameters{set: true}},\n }\n "}, {"sha": "f2254a41bba850dc4e978fcd46e219f95d8f606f", "filename": "libgo/go/asn1/common.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fcommon.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -32,6 +32,7 @@ const (\n \ttagIA5String       = 22\n \ttagUTCTime         = 23\n \ttagGeneralizedTime = 24\n+\ttagGeneralString   = 27\n )\n \n const (\n@@ -67,7 +68,8 @@ type tagAndLength struct {\n // fieldParameters is the parsed representation of tag string from a structure field.\n type fieldParameters struct {\n \toptional     bool   // true iff the field is OPTIONAL\n-\texplicit     bool   // true iff and EXPLICIT tag is in use.\n+\texplicit     bool   // true iff an EXPLICIT tag is in use.\n+\tapplication  bool   // true iff an APPLICATION tag is in use.\n \tdefaultValue *int64 // a default value for INTEGER typed fields (maybe nil).\n \ttag          *int   // the EXPLICIT or IMPLICIT tag (maybe nil).\n \tstringType   int    // the string tag to use when marshaling.\n@@ -89,7 +91,6 @@ func parseFieldParameters(str string) (ret fieldParameters) {\n \t\t\tret.explicit = true\n \t\t\tif ret.tag == nil {\n \t\t\t\tret.tag = new(int)\n-\t\t\t\t*ret.tag = 0\n \t\t\t}\n \t\tcase part == \"ia5\":\n \t\t\tret.stringType = tagIA5String\n@@ -109,6 +110,11 @@ func parseFieldParameters(str string) (ret fieldParameters) {\n \t\t\t}\n \t\tcase part == \"set\":\n \t\t\tret.set = true\n+\t\tcase part == \"application\":\n+\t\t\tret.application = true\n+\t\t\tif ret.tag == nil {\n+\t\t\t\tret.tag = new(int)\n+\t\t\t}\n \t\t}\n \t}\n \treturn"}, {"sha": "9c19dd5da6ded695207392ff9d64830f092cd678", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -716,18 +716,25 @@ var composites = []string{\n \n \n func TestProbablyPrime(t *testing.T) {\n+\tnreps := 20\n+\tif testing.Short() {\n+\t\tnreps = 1\n+\t}\n \tfor i, s := range primes {\n \t\tp, _ := new(Int).SetString(s, 10)\n-\t\tif !ProbablyPrime(p, 20) {\n+\t\tif !ProbablyPrime(p, nreps) {\n \t\t\tt.Errorf(\"#%d prime found to be non-prime (%s)\", i, s)\n \t\t}\n \t}\n \n \tfor i, s := range composites {\n \t\tc, _ := new(Int).SetString(s, 10)\n-\t\tif ProbablyPrime(c, 20) {\n+\t\tif ProbablyPrime(c, nreps) {\n \t\t\tt.Errorf(\"#%d composite found to be prime (%s)\", i, s)\n \t\t}\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n "}, {"sha": "14f9501416e1b51f6a77089862ae47cc173c49c0", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -178,7 +178,11 @@ func TestBasicOperations(t *testing.T) {\n \n func TestLargeStringWrites(t *testing.T) {\n \tvar buf Buffer\n-\tfor i := 3; i < 30; i += 3 {\n+\tlimit := 30\n+\tif testing.Short() {\n+\t\tlimit = 9\n+\t}\n+\tfor i := 3; i < limit; i += 3 {\n \t\ts := fillString(t, \"TestLargeWrites (1)\", &buf, \"\", 5, data)\n \t\tempty(t, \"TestLargeStringWrites (2)\", &buf, s, make([]byte, len(data)/i))\n \t}\n@@ -188,7 +192,11 @@ func TestLargeStringWrites(t *testing.T) {\n \n func TestLargeByteWrites(t *testing.T) {\n \tvar buf Buffer\n-\tfor i := 3; i < 30; i += 3 {\n+\tlimit := 30\n+\tif testing.Short() {\n+\t\tlimit = 9\n+\t}\n+\tfor i := 3; i < limit; i += 3 {\n \t\ts := fillBytes(t, \"TestLargeWrites (1)\", &buf, \"\", 5, bytes)\n \t\tempty(t, \"TestLargeByteWrites (2)\", &buf, s, make([]byte, len(data)/i))\n \t}"}, {"sha": "c12a135738328e7853197caec22b5dd75a8e3ec3", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -293,20 +293,10 @@ func Join(a [][]byte, sep []byte) []byte {\n \t}\n \n \tb := make([]byte, n)\n-\tbp := 0\n-\tfor i := 0; i < len(a); i++ {\n-\t\ts := a[i]\n-\t\tfor j := 0; j < len(s); j++ {\n-\t\t\tb[bp] = s[j]\n-\t\t\tbp++\n-\t\t}\n-\t\tif i+1 < len(a) {\n-\t\t\ts = sep\n-\t\t\tfor j := 0; j < len(s); j++ {\n-\t\t\t\tb[bp] = s[j]\n-\t\t\t\tbp++\n-\t\t\t}\n-\t\t}\n+\tbp := copy(b, a[0])\n+\tfor _, s := range a[1:] {\n+\t\tbp += copy(b[bp:], sep)\n+\t\tbp += copy(b[bp:], s)\n \t}\n \treturn b\n }"}, {"sha": "4ce291a4f67b2fc05935f1df6405fa406e75d563", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -201,7 +201,10 @@ func TestIndexByte(t *testing.T) {\n \n // test a larger buffer with different sizes and alignments\n func TestIndexByteBig(t *testing.T) {\n-\tconst n = 1024\n+\tvar n = 1024\n+\tif testing.Short() {\n+\t\tn = 128\n+\t}\n \tb := make([]byte, n)\n \tfor i := 0; i < n; i++ {\n \t\t// different start alignments"}, {"sha": "b83b0bfeeff319cd1e4f2b6248fde4482ed8d1bd", "filename": "libgo/go/container/vector/numbers_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -33,6 +33,9 @@ func s(n uint64) string {\n \n \n func TestVectorNums(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n \tvar v Vector\n \tc := int(0)\n \truntime.GC()\n@@ -51,6 +54,9 @@ func TestVectorNums(t *testing.T) {\n \n \n func TestIntVectorNums(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n \tvar v IntVector\n \tc := int(0)\n \truntime.GC()\n@@ -69,6 +75,9 @@ func TestIntVectorNums(t *testing.T) {\n \n \n func TestStringVectorNums(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n \tvar v StringVector\n \tc := \"\"\n \truntime.GC()"}, {"sha": "147b74fc2fd4d7a24c7592410e6aa4b235854a95", "filename": "libgo/go/crypto/cipher/ctr.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fctr.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -22,6 +22,10 @@ type ctr struct {\n // NewCTR returns a Stream which encrypts/decrypts using the given Block in\n // counter mode. The length of iv must be the same as the Block's block size.\n func NewCTR(block Block, iv []byte) Stream {\n+\tif len(iv) != block.BlockSize() {\n+\t\tpanic(\"cipher.NewCTR: iv length must equal block size\")\n+\t}\n+\n \treturn &ctr{\n \t\tb:       block,\n \t\tctr:     dup(iv),"}, {"sha": "d6b40391421c474d5233fd48bf0b21ca033ad27f", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -20,12 +20,15 @@ func testKeyGeneration(t *testing.T, c *elliptic.Curve, tag string) {\n \t\treturn\n \t}\n \tif !c.IsOnCurve(priv.PublicKey.X, priv.PublicKey.Y) {\n-\t\tt.Errorf(\"%s: public key invalid\", tag, err)\n+\t\tt.Errorf(\"%s: public key invalid: %s\", tag, err)\n \t}\n }\n \n func TestKeyGeneration(t *testing.T) {\n \ttestKeyGeneration(t, elliptic.P224(), \"p224\")\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n \ttestKeyGeneration(t, elliptic.P256(), \"p256\")\n \ttestKeyGeneration(t, elliptic.P384(), \"p384\")\n \ttestKeyGeneration(t, elliptic.P521(), \"p521\")\n@@ -53,6 +56,9 @@ func testSignAndVerify(t *testing.T, c *elliptic.Curve, tag string) {\n \n func TestSignAndVerify(t *testing.T) {\n \ttestSignAndVerify(t, elliptic.P224(), \"p224\")\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n \ttestSignAndVerify(t, elliptic.P256(), \"p256\")\n \ttestSignAndVerify(t, elliptic.P384(), \"p384\")\n \ttestSignAndVerify(t, elliptic.P521(), \"p521\")\n@@ -214,5 +220,8 @@ func TestVectors(t *testing.T) {\n \t\tif Verify(&pub, hashed, r, s) != test.ok {\n \t\t\tt.Errorf(\"%d: bad result\", i)\n \t\t}\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }"}, {"sha": "02083a986668cb58952d9183fe7677d26146f8e1", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -297,6 +297,9 @@ func TestBaseMult(t *testing.T) {\n \t\tif fmt.Sprintf(\"%x\", x) != e.x || fmt.Sprintf(\"%x\", y) != e.y {\n \t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %s), want (%s, %s)\", i, e.k, x, y, e.x, e.y)\n \t\t}\n+\t\tif testing.Short() && i > 5 {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n "}, {"sha": "75bc47ec10b6f25f3bd04f19acaf5fa6594a25a6", "filename": "libgo/go/crypto/openpgp/s2k/s2k_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -90,5 +90,8 @@ func TestParse(t *testing.T) {\n \t\tif !bytes.Equal(out, expected) {\n \t\t\tt.Errorf(\"%d: output got: %x want: %x\", i, out, expected)\n \t\t}\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }"}, {"sha": "bfae7ce4f9bf075c82fcede3a2237a22a0e98b21", "filename": "libgo/go/crypto/rand/rand_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -11,7 +11,11 @@ import (\n )\n \n func TestRead(t *testing.T) {\n-\tb := make([]byte, 4e6)\n+\tvar n int = 4e6\n+\tif testing.Short() {\n+\t\tn = 1e5\n+\t}\n+\tb := make([]byte, n)\n \tn, err := Read(b)\n \tif n != len(b) || err != nil {\n \t\tt.Fatalf(\"Read(buf) = %d, %s\", n, err)"}, {"sha": "30a4824a6b0566471ec4c92870298299aff0cc47", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -97,7 +97,11 @@ func TestEncryptPKCS1v15(t *testing.T) {\n \t\treturn true\n \t}\n \n-\tquick.Check(tryEncryptDecrypt, nil)\n+\tconfig := new(quick.Config)\n+\tif testing.Short() {\n+\t\tconfig.MaxCount = 10\n+\t}\n+\tquick.Check(tryEncryptDecrypt, config)\n }\n \n // These test vectors were generated with `openssl rsautl -pkcs -encrypt`"}, {"sha": "bf7c05137a38a4e75b6d7c60bd39407326fb0e27", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -15,7 +15,11 @@ import (\n func TestKeyGeneration(t *testing.T) {\n \trandom := rand.Reader\n \n-\tpriv, err := GenerateKey(random, 1024)\n+\tsize := 1024\n+\tif testing.Short() {\n+\t\tsize = 128\n+\t}\n+\tpriv, err := GenerateKey(random, size)\n \tif err != nil {\n \t\tt.Errorf(\"failed to generate key\")\n \t}\n@@ -99,6 +103,9 @@ func TestDecryptOAEP(t *testing.T) {\n \t\t\t\tt.Errorf(\"#%d,%d (blind) bad result: %#v (want %#v)\", i, j, out, message.in)\n \t\t\t}\n \t\t}\n+\t\tif testing.Short() {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n "}, {"sha": "c7792343942243b2614286521d41218e046897fe", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -93,9 +93,10 @@ const (\n \n // ConnectionState records basic TLS details about the connection.\n type ConnectionState struct {\n-\tHandshakeComplete  bool\n-\tCipherSuite        uint16\n-\tNegotiatedProtocol string\n+\tHandshakeComplete          bool\n+\tCipherSuite                uint16\n+\tNegotiatedProtocol         string\n+\tNegotiatedProtocolIsMutual bool\n \n \t// the certificate chain that was presented by the other side\n \tPeerCertificates []*x509.Certificate\n@@ -124,7 +125,6 @@ type Config struct {\n \tRootCAs *CASet\n \n \t// NextProtos is a list of supported, application level protocols.\n-\t// Currently only server-side handling is supported.\n \tNextProtos []string\n \n \t// ServerName is included in the client's handshake to support virtual"}, {"sha": "b94e235c814fc7aea41c2131f2bb61a4cbd1066a", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -35,7 +35,8 @@ type Conn struct {\n \tocspResponse      []byte // stapled OCSP response\n \tpeerCertificates  []*x509.Certificate\n \n-\tclientProtocol string\n+\tclientProtocol         string\n+\tclientProtocolFallback bool\n \n \t// first permanent error\n \terrMutex sync.Mutex\n@@ -761,6 +762,7 @@ func (c *Conn) ConnectionState() ConnectionState {\n \tstate.HandshakeComplete = c.handshakeComplete\n \tif c.handshakeComplete {\n \t\tstate.NegotiatedProtocol = c.clientProtocol\n+\t\tstate.NegotiatedProtocolIsMutual = !c.clientProtocolFallback\n \t\tstate.CipherSuite = c.cipherSuite\n \t\tstate.PeerCertificates = c.peerCertificates\n \t}"}, {"sha": "540b25c8753a7408df7adfa9fc35bee35b9dc088", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -29,6 +29,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tserverName:         c.config.ServerName,\n \t\tsupportedCurves:    []uint16{curveP256, curveP384, curveP521},\n \t\tsupportedPoints:    []uint8{pointFormatUncompressed},\n+\t\tnextProtoNeg:       len(c.config.NextProtos) > 0,\n \t}\n \n \tt := uint32(c.config.time())\n@@ -66,6 +67,11 @@ func (c *Conn) clientHandshake() os.Error {\n \t\treturn c.sendAlert(alertUnexpectedMessage)\n \t}\n \n+\tif !hello.nextProtoNeg && serverHello.nextProtoNeg {\n+\t\tc.sendAlert(alertHandshakeFailure)\n+\t\treturn os.ErrorString(\"server advertised unrequested NPN\")\n+\t}\n+\n \tsuite, suiteId := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)\n \tif suite == nil {\n \t\treturn c.sendAlert(alertHandshakeFailure)\n@@ -267,6 +273,17 @@ func (c *Conn) clientHandshake() os.Error {\n \tc.out.prepareCipherSpec(clientCipher, clientHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n+\tif serverHello.nextProtoNeg {\n+\t\tnextProto := new(nextProtoMsg)\n+\t\tproto, fallback := mutualProtocol(c.config.NextProtos, serverHello.nextProtos)\n+\t\tnextProto.proto = proto\n+\t\tc.clientProtocol = proto\n+\t\tc.clientProtocolFallback = fallback\n+\n+\t\tfinishedHash.Write(nextProto.marshal())\n+\t\tc.writeRecord(recordTypeHandshake, nextProto.marshal())\n+\t}\n+\n \tfinished := new(finishedMsg)\n \tfinished.verifyData = finishedHash.clientSum(masterSecret)\n \tfinishedHash.Write(finished.marshal())\n@@ -299,3 +316,19 @@ func (c *Conn) clientHandshake() os.Error {\n \tc.cipherSuite = suiteId\n \treturn nil\n }\n+\n+// mutualProtocol finds the mutual Next Protocol Negotiation protocol given the\n+// set of client and server supported protocols. The set of client supported\n+// protocols must not be empty. It returns the resulting protocol and flag\n+// indicating if the fallback case was reached.\n+func mutualProtocol(clientProtos, serverProtos []string) (string, bool) {\n+\tfor _, s := range serverProtos {\n+\t\tfor _, c := range clientProtos {\n+\t\t\tif s == c {\n+\t\t\t\treturn s, false\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn clientProtos[0], true\n+}"}, {"sha": "3f91c7acf1f7a19c1cbb6dc4cd3f5122db4fd76c", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -50,7 +50,7 @@ func TestRunClient(t *testing.T) {\n \n \ttestConfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_RC4_128_SHA}\n \n-\tconn, err := Dial(\"tcp\", \"\", \"127.0.0.1:10443\", testConfig)\n+\tconn, err := Dial(\"tcp\", \"127.0.0.1:10443\", testConfig)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "0b93b89f1ad4ad152259043050a319629f6790d4", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -34,7 +34,11 @@ func TestMarshalUnmarshal(t *testing.T) {\n \tfor i, iface := range tests {\n \t\tty := reflect.NewValue(iface).Type()\n \n-\t\tfor j := 0; j < 100; j++ {\n+\t\tn := 100\n+\t\tif testing.Short() {\n+\t\t\tn = 5\n+\t\t}\n+\t\tfor j := 0; j < n; j++ {\n \t\t\tv, ok := quick.Value(ty, rand)\n \t\t\tif !ok {\n \t\t\t\tt.Errorf(\"#%d: failed to create value\", i)"}, {"sha": "f66449c822535f15839a2c376f4256552615a752", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -87,8 +87,9 @@ func Listen(network, laddr string, config *Config) (*Listener, os.Error) {\n // Dial interprets a nil configuration as equivalent to\n // the zero configuration; see the documentation of Config\n // for the defaults.\n-func Dial(network, laddr, raddr string, config *Config) (*Conn, os.Error) {\n-\tc, err := net.Dial(network, laddr, raddr)\n+func Dial(network, addr string, config *Config) (*Conn, os.Error) {\n+\traddr := addr\n+\tc, err := net.Dial(network, raddr)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "853bcde9ad8053bbdd8eaab05b886968928f38c9", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -304,6 +304,42 @@ const (\n \tKeyUsageDecipherOnly\n )\n \n+// RFC 5280, 4.2.1.12  Extended Key Usage\n+//\n+// anyExtendedKeyUsage OBJECT IDENTIFIER ::= { id-ce-extKeyUsage 0 }\n+//\n+// id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }\n+//\n+// id-kp-serverAuth             OBJECT IDENTIFIER ::= { id-kp 1 }\n+// id-kp-clientAuth             OBJECT IDENTIFIER ::= { id-kp 2 }\n+// id-kp-codeSigning            OBJECT IDENTIFIER ::= { id-kp 3 }\n+// id-kp-emailProtection        OBJECT IDENTIFIER ::= { id-kp 4 }\n+// id-kp-timeStamping           OBJECT IDENTIFIER ::= { id-kp 8 }\n+// id-kp-OCSPSigning            OBJECT IDENTIFIER ::= { id-kp 9 }\n+var (\n+\toidExtKeyUsageAny             = asn1.ObjectIdentifier{2, 5, 29, 37, 0}\n+\toidExtKeyUsageServerAuth      = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 1}\n+\toidExtKeyUsageClientAuth      = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 2}\n+\toidExtKeyUsageCodeSigning     = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 3}\n+\toidExtKeyUsageEmailProtection = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 4}\n+\toidExtKeyUsageTimeStamping    = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 8}\n+\toidExtKeyUsageOCSPSigning     = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 9}\n+)\n+\n+// ExtKeyUsage represents an extended set of actions that are valid for a given key.\n+// Each of the ExtKeyUsage* constants define a unique action.\n+type ExtKeyUsage int\n+\n+const (\n+\tExtKeyUsageAny ExtKeyUsage = iota\n+\tExtKeyUsageServerAuth\n+\tExtKeyUsageClientAuth\n+\tExtKeyUsageCodeSigning\n+\tExtKeyUsageEmailProtection\n+\tExtKeyUsageTimeStamping\n+\tExtKeyUsageOCSPSigning\n+)\n+\n // A Certificate represents an X.509 certificate.\n type Certificate struct {\n \tRaw                []byte // Raw ASN.1 DER contents.\n@@ -320,6 +356,9 @@ type Certificate struct {\n \tNotBefore, NotAfter *time.Time // Validity bounds.\n \tKeyUsage            KeyUsage\n \n+\tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n+\tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n+\n \tBasicConstraintsValid bool // if true then the next two fields are valid.\n \tIsCA                  bool\n \tMaxPathLen            int\n@@ -666,6 +705,44 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \t\t\t\tout.AuthorityKeyId = a.Id\n \t\t\t\tcontinue\n \n+\t\t\tcase 37:\n+\t\t\t\t// RFC 5280, 4.2.1.12.  Extended Key Usage\n+\n+\t\t\t\t// id-ce-extKeyUsage OBJECT IDENTIFIER ::= { id-ce 37 }\n+\t\t\t\t//\n+\t\t\t\t// ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId\n+\t\t\t\t//\n+\t\t\t\t// KeyPurposeId ::= OBJECT IDENTIFIER\n+\n+\t\t\t\tvar keyUsage []asn1.ObjectIdentifier\n+\t\t\t\t_, err = asn1.Unmarshal(e.Value, &keyUsage)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\n+\t\t\t\tfor _, u := range keyUsage {\n+\t\t\t\t\tswitch {\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageAny):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageAny)\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageServerAuth):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageServerAuth)\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageClientAuth):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageClientAuth)\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageCodeSigning):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageCodeSigning)\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageEmailProtection):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageEmailProtection)\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageTimeStamping):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageTimeStamping)\n+\t\t\t\t\tcase u.Equal(oidExtKeyUsageOCSPSigning):\n+\t\t\t\t\t\tout.ExtKeyUsage = append(out.ExtKeyUsage, ExtKeyUsageOCSPSigning)\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tout.UnknownExtKeyUsage = append(out.UnknownExtKeyUsage, u)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tcontinue\n+\n \t\t\tcase 14:\n \t\t\t\t// RFC 5280, 4.2.1.2\n \t\t\t\tvar keyid []byte"}, {"sha": "c83e64eabd76e11604ecf1f1b99ccd92037be770", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -143,9 +143,6 @@ func TestLineAline(t *testing.T) {\n \t}\n }\n \n-// gotest: if [ \"$(uname)-$(uname -m)\" = Linux-x86_64 -a \"$GOARCH\" = amd64 ]; then\n-// gotest:    mkdir -p _test && $AS pclinetest.s && $LD -E main -o _test/pclinetest pclinetest.$O\n-// gotest: fi\n func TestPCLine(t *testing.T) {\n \tif !dotest() {\n \t\treturn"}, {"sha": "e77cf64adfaa380e96a8c58c2ec88e790d923ad4", "filename": "libgo/go/ebnf/ebnf_test.go", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Febnf%2Febnf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Febnf%2Febnf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -15,31 +15,26 @@ var fset = token.NewFileSet()\n \n \n var grammars = []string{\n-`Program = .\n-`,\n-\n-`Program = foo .\n-foo = \"foo\" .\n-`,\n-\n-`Program = \"a\" | \"b\" \"c\" .\n-`,\n-\n-`Program = \"a\" ... \"z\" .\n-`,\n-\n-`Program = Song .\n- Song = { Note } .\n- Note = Do | (Re | Mi | Fa | So | La) | Ti .\n- Do = \"c\" .\n- Re = \"d\" .\n- Mi = \"e\" .\n- Fa = \"f\" .\n- So = \"g\" .\n- La = \"a\" .\n- Ti = ti .\n- ti = \"b\" .\n-`,\n+\t`Program = .`,\n+\n+\t`Program = foo .\n+\t foo = \"foo\" .`,\n+\n+\t`Program = \"a\" | \"b\" \"c\" .`,\n+\n+\t`Program = \"a\" ... \"z\" .`,\n+\n+\t`Program = Song .\n+\t Song = { Note } .\n+\t Note = Do | (Re | Mi | Fa | So | La) | Ti .\n+\t Do = \"c\" .\n+\t Re = \"d\" .\n+\t Mi = \"e\" .\n+\t Fa = \"f\" .\n+\t So = \"g\" .\n+\t La = \"a\" .\n+\t Ti = ti .\n+\t ti = \"b\" .`,\n }\n \n "}, {"sha": "818168e111dcce992c3a4d80952c007696721621", "filename": "libgo/go/ebnf/parser.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Febnf%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Febnf%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Fparser.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -18,7 +18,7 @@ type parser struct {\n \tscanner scanner.Scanner\n \tpos     token.Pos   // token position\n \ttok     token.Token // one token look-ahead\n-\tlit     []byte      // token literal\n+\tlit     string      // token literal\n }\n \n \n@@ -44,7 +44,7 @@ func (p *parser) errorExpected(pos token.Pos, msg string) {\n \t\t// make the error message more specific\n \t\tmsg += \", found '\" + p.tok.String() + \"'\"\n \t\tif p.tok.IsLiteral() {\n-\t\t\tmsg += \" \" + string(p.lit)\n+\t\t\tmsg += \" \" + p.lit\n \t\t}\n \t}\n \tp.error(pos, msg)\n@@ -63,7 +63,7 @@ func (p *parser) expect(tok token.Token) token.Pos {\n \n func (p *parser) parseIdentifier() *Name {\n \tpos := p.pos\n-\tname := string(p.lit)\n+\tname := p.lit\n \tp.expect(token.IDENT)\n \treturn &Name{pos, name}\n }\n@@ -73,7 +73,7 @@ func (p *parser) parseToken() *Token {\n \tpos := p.pos\n \tvalue := \"\"\n \tif p.tok == token.STRING {\n-\t\tvalue, _ = strconv.Unquote(string(p.lit))\n+\t\tvalue, _ = strconv.Unquote(p.lit)\n \t\t// Unquote may fail with an error, but only if the scanner found\n \t\t// an illegal string in the first place. In this case the error\n \t\t// has already been reported."}, {"sha": "7dedb531a51a770f1c7fd5ba76668df92696f10a", "filename": "libgo/go/exp/datafmt/parser.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdatafmt%2Fparser.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -22,7 +22,7 @@ type parser struct {\n \tfile    *token.File\n \tpos     token.Pos   // token position\n \ttok     token.Token // one token look-ahead\n-\tlit     []byte      // token literal\n+\tlit     string      // token literal\n \n \tpacks map[string]string // PackageName -> ImportPath\n \trules map[string]expr   // RuleName -> Expression\n@@ -62,7 +62,7 @@ func (p *parser) errorExpected(pos token.Pos, msg string) {\n \t\t// make the error message more specific\n \t\tmsg += \", found '\" + p.tok.String() + \"'\"\n \t\tif p.tok.IsLiteral() {\n-\t\t\tmsg += \" \" + string(p.lit)\n+\t\t\tmsg += \" \" + p.lit\n \t\t}\n \t}\n \tp.error(pos, msg)\n@@ -80,7 +80,7 @@ func (p *parser) expect(tok token.Token) token.Pos {\n \n \n func (p *parser) parseIdentifier() string {\n-\tname := string(p.lit)\n+\tname := p.lit\n \tp.expect(token.IDENT)\n \treturn name\n }\n@@ -130,7 +130,7 @@ func (p *parser) parseRuleName() (string, bool) {\n func (p *parser) parseString() string {\n \ts := \"\"\n \tif p.tok == token.STRING {\n-\t\ts, _ = strconv.Unquote(string(p.lit))\n+\t\ts, _ = strconv.Unquote(p.lit)\n \t\t// Unquote may fail with an error, but only if the scanner found\n \t\t// an illegal string in the first place. In this case the error\n \t\t// has already been reported.\n@@ -181,7 +181,7 @@ func (p *parser) parseField() expr {\n \tvar fname string\n \tswitch p.tok {\n \tcase token.ILLEGAL:\n-\t\tif string(p.lit) != \"@\" {\n+\t\tif p.lit != \"@\" {\n \t\t\treturn nil\n \t\t}\n \t\tfname = \"@\""}, {"sha": "53294af15c0d95b3bf7cf367d6e1db4868d2b42d", "filename": "libgo/go/exp/draw/x11/conn.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -286,11 +286,11 @@ func connect(display string) (conn net.Conn, displayStr string, err os.Error) {\n \t}\n \t// Make the connection.\n \tif socket != \"\" {\n-\t\tconn, err = net.Dial(\"unix\", \"\", socket+\":\"+displayStr)\n+\t\tconn, err = net.Dial(\"unix\", socket+\":\"+displayStr)\n \t} else if host != \"\" {\n-\t\tconn, err = net.Dial(protocol, \"\", host+\":\"+strconv.Itoa(6000+displayInt))\n+\t\tconn, err = net.Dial(protocol, host+\":\"+strconv.Itoa(6000+displayInt))\n \t} else {\n-\t\tconn, err = net.Dial(\"unix\", \"\", \"/tmp/.X11-unix/X\"+displayStr)\n+\t\tconn, err = net.Dial(\"unix\", \"/tmp/.X11-unix/X\"+displayStr)\n \t}\n \tif err != nil {\n \t\treturn nil, \"\", os.NewError(\"cannot connect to \" + display + \": \" + err.String())"}, {"sha": "541d3feb71dc70d5febb81b8d967cdd5bdac9dcf", "filename": "libgo/go/exp/eval/eval_test.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Feval_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -39,9 +39,13 @@ type job struct {\n }\n \n func runTests(t *testing.T, baseName string, tests []test) {\n-\tfor i, test := range tests {\n+\tdelta := 1\n+\tif testing.Short() {\n+\t\tdelta = 16\n+\t}\n+\tfor i := 0; i < len(tests); i += delta {\n \t\tname := fmt.Sprintf(\"%s[%d]\", baseName, i)\n-\t\ttest.run(t, name)\n+\t\ttests[i].run(t, name)\n \t}\n }\n "}, {"sha": "ba056e88bafc021bb4d5a8363dceeaee0d3abbf5", "filename": "libgo/go/exp/ogle/cmd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -205,7 +205,7 @@ func parseLoad(args []byte) (ident string, path string, err os.Error) {\n \tsc, ev := newScanner(args)\n \n \tvar toks [4]token.Token\n-\tvar lits [4][]byte\n+\tvar lits [4]string\n \tfor i := range toks {\n \t\t_, toks[i], lits[i] = sc.Scan()\n \t}"}, {"sha": "19a3104553f379e5b1b244dac12514d557886142", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -56,7 +56,7 @@\n \n \t\tflag.Bool(...)  // global options\n \t\tflag.Parse()  // parse leading command\n-\t\tsubcmd := flag.Arg[0]\n+\t\tsubcmd := flag.Arg(0)\n \t\tswitch subcmd {\n \t\t\t// add per-subcommand options\n \t\t}"}, {"sha": "4d308ac342dea8371f877f1d4363244b837bc3d2", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -442,6 +442,9 @@ func BenchmarkSprintfPrefixedInt(b *testing.B) {\n }\n \n func TestCountMallocs(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n \tmallocs := 0 - runtime.MemStats.Mallocs\n \tfor i := 0; i < 100; i++ {\n \t\tSprintf(\"\")"}, {"sha": "ed3e2cdd9be51400fbd84b00fc676f1ca936987a", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -66,7 +66,7 @@ type Decl interface {\n // A Comment node represents a single //-style or /*-style comment.\n type Comment struct {\n \tSlash token.Pos // position of \"/\" starting the comment\n-\tText  []byte    // comment text (excluding '\\n' for //-style comments)\n+\tText  string    // comment text (excluding '\\n' for //-style comments)\n }\n \n \n@@ -199,7 +199,7 @@ type (\n \tBasicLit struct {\n \t\tValuePos token.Pos   // literal position\n \t\tKind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n-\t\tValue    []byte      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n+\t\tValue    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n \t}\n \n \t// A FuncLit node represents a function literal.\n@@ -781,7 +781,7 @@ type (\n \tImportSpec struct {\n \t\tDoc     *CommentGroup // associated documentation; or nil\n \t\tName    *Ident        // local package name (including \".\"); or nil\n-\t\tPath    *BasicLit     // package path\n+\t\tPath    *BasicLit     // import path\n \t\tComment *CommentGroup // line comments; or nil\n \t}\n \n@@ -925,8 +925,9 @@ type File struct {\n \tPackage    token.Pos       // position of \"package\" keyword\n \tName       *Ident          // package name\n \tDecls      []Decl          // top-level declarations; or nil\n-\tScope      *Scope          // package scope\n-\tUnresolved []*Ident        // unresolved global identifiers\n+\tScope      *Scope          // package scope (this file only)\n+\tImports    []*ImportSpec   // imports in this file\n+\tUnresolved []*Ident        // unresolved identifiers in this file\n \tComments   []*CommentGroup // list of all comments in the source file\n }\n \n@@ -944,9 +945,10 @@ func (f *File) End() token.Pos {\n // collectively building a Go package.\n //\n type Package struct {\n-\tName  string           // package name\n-\tScope *Scope           // package scope\n-\tFiles map[string]*File // Go source files by filename\n+\tName    string            // package name\n+\tScope   *Scope            // package scope\n+\tImports map[string]*Scope // map of import path -> package scope across all files\n+\tFiles   map[string]*File  // Go source files by filename\n }\n \n "}, {"sha": "090d08d34c78325936bcef8c11e95aa12b95c0c6", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -304,7 +304,7 @@ const (\n // separator is an empty //-style comment that is interspersed between\n // different comment groups when they are concatenated into a single group\n //\n-var separator = &Comment{noPos, []byte(\"//\")}\n+var separator = &Comment{noPos, \"//\"}\n \n \n // MergePackageFiles creates a file AST by merging the ASTs of the\n@@ -426,5 +426,6 @@ func MergePackageFiles(pkg *Package, mode MergeMode) *File {\n \t}\n \n \t// TODO(gri) need to compute pkgScope and unresolved identifiers!\n-\treturn &File{doc, pos, NewIdent(pkg.Name), decls, nil, nil, comments}\n+\t// TODO(gri) need to compute imports!\n+\treturn &File{doc, pos, NewIdent(pkg.Name), decls, nil, nil, nil, comments}\n }"}, {"sha": "fddc3baab86c61b91d33c08f67225da2eac90920", "filename": "libgo/go/go/ast/resolve.go", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -0,0 +1,188 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements NewPackage.\n+\n+package ast\n+\n+import (\n+\t\"fmt\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"os\"\n+)\n+\n+\n+type pkgBuilder struct {\n+\tscanner.ErrorVector\n+\tfset *token.FileSet\n+}\n+\n+\n+func (p *pkgBuilder) error(pos token.Pos, msg string) {\n+\tp.Error(p.fset.Position(pos), msg)\n+}\n+\n+\n+func (p *pkgBuilder) errorf(pos token.Pos, format string, args ...interface{}) {\n+\tp.error(pos, fmt.Sprintf(format, args...))\n+}\n+\n+\n+func (p *pkgBuilder) declare(scope, altScope *Scope, obj *Object) {\n+\talt := scope.Insert(obj)\n+\tif alt == nil && altScope != nil {\n+\t\t// see if there is a conflicting declaration in altScope\n+\t\talt = altScope.Lookup(obj.Name)\n+\t}\n+\tif alt != nil {\n+\t\tprevDecl := \"\"\n+\t\tif pos := alt.Pos(); pos.IsValid() {\n+\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", p.fset.Position(pos))\n+\t\t}\n+\t\tp.error(obj.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", obj.Name, prevDecl))\n+\t}\n+}\n+\n+\n+func resolve(scope *Scope, ident *Ident) bool {\n+\tfor ; scope != nil; scope = scope.Outer {\n+\t\tif obj := scope.Lookup(ident.Name); obj != nil {\n+\t\t\tident.Obj = obj\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+\n+// NewPackage uses an Importer to resolve imports. Given an importPath,\n+// an importer returns the imported package's name, its scope of exported\n+// objects, and an error, if any.\n+//\n+type Importer func(path string) (name string, scope *Scope, err os.Error)\n+\n+\n+// NewPackage creates a new Package node from a set of File nodes. It resolves\n+// unresolved identifiers across files and updates each file's Unresolved list\n+// accordingly. If a non-nil importer and universe scope are provided, they are\n+// used to resolve identifiers not declared in any of the package files. Any\n+// remaining unresolved identifiers are reported as undeclared. If the files\n+// belong to different packages, one package name is selected and files with\n+// different package name are reported and then ignored.\n+// The result is a package node and a scanner.ErrorList if there were errors.\n+//\n+func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, os.Error) {\n+\tvar p pkgBuilder\n+\tp.fset = fset\n+\n+\t// complete package scope\n+\tpkgName := \"\"\n+\tpkgScope := NewScope(universe)\n+\tfor _, file := range files {\n+\t\t// package names must match\n+\t\tswitch name := file.Name.Name; {\n+\t\tcase pkgName == \"\":\n+\t\t\tpkgName = name\n+\t\tcase name != pkgName:\n+\t\t\tp.errorf(file.Package, \"package %s; expected %s\", name, pkgName)\n+\t\t\tcontinue // ignore this file\n+\t\t}\n+\n+\t\t// collect top-level file objects in package scope\n+\t\tfor _, obj := range file.Scope.Objects {\n+\t\t\tp.declare(pkgScope, nil, obj)\n+\t\t}\n+\t}\n+\n+\t// imports maps import paths to package names and scopes\n+\t// TODO(gri): Eventually we like to get to the import scope from\n+\t//            a package object. Then we can have a map path -> Obj.\n+\ttype importedPkg struct {\n+\t\tname  string\n+\t\tscope *Scope\n+\t}\n+\timports := make(map[string]*importedPkg)\n+\n+\t// complete file scopes with imports and resolve identifiers\n+\tfor _, file := range files {\n+\t\t// ignore file if it belongs to a different package\n+\t\t// (error has already been reported)\n+\t\tif file.Name.Name != pkgName {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// build file scope by processing all imports\n+\t\timportErrors := false\n+\t\tfileScope := NewScope(pkgScope)\n+\t\tfor _, spec := range file.Imports {\n+\t\t\t// add import to global map of imports\n+\t\t\tpath := string(spec.Path.Value)\n+\t\t\tpath = path[1 : len(path)-1] // strip \"\"'s\n+\t\t\tpkg := imports[path]\n+\t\t\tif pkg == nil {\n+\t\t\t\tif importer == nil {\n+\t\t\t\t\timportErrors = true\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tname, scope, err := importer(path)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tp.errorf(spec.Path.Pos(), \"could not import %s (%s)\", path, err)\n+\t\t\t\t\timportErrors = true\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tpkg = &importedPkg{name, scope}\n+\t\t\t\timports[path] = pkg\n+\t\t\t\t// TODO(gri) If a local package name != \".\" is provided,\n+\t\t\t\t// global identifier resolution could proceed even if the\n+\t\t\t\t// import failed. Consider adjusting the logic here a bit.\n+\t\t\t}\n+\t\t\t// local name overrides imported package name\n+\t\t\tname := pkg.name\n+\t\t\tif spec.Name != nil {\n+\t\t\t\tname = spec.Name.Name\n+\t\t\t}\n+\t\t\t// add import to file scope\n+\t\t\tif name == \".\" {\n+\t\t\t\t// merge imported scope with file scope\n+\t\t\t\tfor _, obj := range pkg.scope.Objects {\n+\t\t\t\t\tp.declare(fileScope, pkgScope, obj)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// declare imported package object in file scope\n+\t\t\t\tobj := NewObj(Pkg, name)\n+\t\t\t\tobj.Decl = spec\n+\t\t\t\tp.declare(fileScope, pkgScope, obj)\n+\t\t\t}\n+\t\t}\n+\n+\t\t// resolve identifiers\n+\t\tif importErrors {\n+\t\t\t// don't use the universe scope without correct imports\n+\t\t\t// (objects in the universe may be shadowed by imports;\n+\t\t\t// with missing imports identifiers might get resolved\n+\t\t\t// wrongly)\n+\t\t\tpkgScope.Outer = nil\n+\t\t}\n+\t\ti := 0\n+\t\tfor _, ident := range file.Unresolved {\n+\t\t\tif !resolve(fileScope, ident) {\n+\t\t\t\tp.errorf(ident.Pos(), \"undeclared name: %s\", ident.Name)\n+\t\t\t\tfile.Unresolved[i] = ident\n+\t\t\t\ti++\n+\t\t\t}\n+\n+\t\t}\n+\t\tfile.Unresolved = file.Unresolved[0:i]\n+\t\tpkgScope.Outer = universe // reset universe scope\n+\t}\n+\n+\t// collect all import paths and respective package scopes\n+\timportedScopes := make(map[string]*Scope)\n+\tfor path, pkg := range imports {\n+\t\timportedScopes[path] = pkg.scope\n+\t}\n+\n+\treturn &Package{pkgName, pkgScope, importedScopes, files}, p.GetError(scanner.Sorted)\n+}"}, {"sha": "830d88aef4a3175cedcfe44f25a63bc88c390ccc", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -39,16 +39,14 @@ func (s *Scope) Lookup(name string) *Object {\n }\n \n \n-// Insert attempts to insert a named object into the scope s.\n-// If the scope does not contain an object with that name yet,\n-// Insert inserts the object and returns it. Otherwise, Insert\n-// leaves the scope unchanged and returns the object found in\n-// the scope instead.\n+// Insert attempts to insert a named object obj into the scope s.\n+// If the scope already contains an object alt with the same name,\n+// Insert leaves the scope unchanged and returns alt. Otherwise\n+// it inserts obj and returns nil.\"\n //\n func (s *Scope) Insert(obj *Object) (alt *Object) {\n \tif alt = s.Objects[obj.Name]; alt == nil {\n \t\ts.Objects[obj.Name] = obj\n-\t\talt = obj\n \t}\n \treturn\n }\n@@ -101,6 +99,11 @@ func (obj *Object) Pos() token.Pos {\n \t\t\t\treturn n.Pos()\n \t\t\t}\n \t\t}\n+\tcase *ImportSpec:\n+\t\tif d.Name != nil && d.Name.Name == name {\n+\t\t\treturn d.Name.Pos()\n+\t\t}\n+\t\treturn d.Path.Pos()\n \tcase *ValueSpec:\n \t\tfor _, n := range d.Names {\n \t\t\tif n.Name == name {"}, {"sha": "f1ebfa97b9f7dc7d4794fafaa7c5b923b875ec6c", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -286,7 +286,7 @@ func unindent(block [][]byte) {\n // nor to have trailing spaces at the end of lines.\n // The comment markers have already been removed.\n //\n-// Turn each run of multiple \\n into </p><p>\n+// Turn each run of multiple \\n into </p><p>.\n // Turn each run of indented lines into a <pre> block without indent.\n //\n // URLs in the comment text are converted into links; if the URL also appears"}, {"sha": "e7a8d3f63bbda80b1827f3bcf7c73c299bf8c614", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -66,7 +66,7 @@ func (doc *docReader) addDoc(comments *ast.CommentGroup) {\n \tn2 := len(comments.List)\n \tlist := make([]*ast.Comment, n1+1+n2) // + 1 for separator line\n \tcopy(list, doc.doc.List)\n-\tlist[n1] = &ast.Comment{token.NoPos, []byte(\"//\")} // separator line\n+\tlist[n1] = &ast.Comment{token.NoPos, \"//\"} // separator line\n \tcopy(list[n1+1:], comments.List)\n \tdoc.doc = &ast.CommentGroup{list}\n }\n@@ -105,7 +105,7 @@ func baseTypeName(typ ast.Expr) string {\n \t\t// if the type is not exported, the effect to\n \t\t// a client is as if there were no type name\n \t\tif t.IsExported() {\n-\t\t\treturn string(t.Name)\n+\t\t\treturn t.Name\n \t\t}\n \tcase *ast.StarExpr:\n \t\treturn baseTypeName(t.X)\n@@ -300,9 +300,9 @@ func (doc *docReader) addFile(src *ast.File) {\n \t// collect BUG(...) comments\n \tfor _, c := range src.Comments {\n \t\ttext := c.List[0].Text\n-\t\tif m := bug_markers.FindIndex(text); m != nil {\n+\t\tif m := bug_markers.FindStringIndex(text); m != nil {\n \t\t\t// found a BUG comment; maybe empty\n-\t\t\tif btxt := text[m[1]:]; bug_content.Match(btxt) {\n+\t\t\tif btxt := text[m[1]:]; bug_content.MatchString(btxt) {\n \t\t\t\t// non-empty BUG comment; collect comment without BUG prefix\n \t\t\t\tlist := copyCommentList(c.List)\n \t\t\t\tlist[0].Text = text[m[1]:]"}, {"sha": "fc4ae094394b4b850875087a2293601e8cd84efb", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -69,7 +69,7 @@ func ParseExpr(fset *token.FileSet, filename string, src interface{}) (ast.Expr,\n \n \tvar p parser\n \tp.init(fset, filename, data, 0)\n-\tx := p.parseExpr()\n+\tx := p.parseRhs()\n \tif p.tok == token.SEMICOLON {\n \t\tp.next() // consume automatically inserted semicolon, if any\n \t}\n@@ -159,7 +159,8 @@ func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[st\n \t\t\tname := src.Name.Name\n \t\t\tpkg, found := pkgs[name]\n \t\t\tif !found {\n-\t\t\t\tpkg = &ast.Package{name, nil, make(map[string]*ast.File)}\n+\t\t\t\t// TODO(gri) Use NewPackage here; reconsider ParseFiles API.\n+\t\t\t\tpkg = &ast.Package{name, nil, nil, make(map[string]*ast.File)}\n \t\t\t\tpkgs[name] = pkg\n \t\t\t}\n \t\t\tpkg.Files[filename] = src"}, {"sha": "ad7e4cdcf2e2856ef798df8e01c75517350b86a8", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 236, "deletions": 128, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -47,17 +47,18 @@ type parser struct {\n \tlineComment *ast.CommentGroup // last line comment\n \n \t// Next token\n-\tpos  token.Pos   // token position\n-\ttok  token.Token // one token look-ahead\n-\tlit_ []byte      // token literal (slice into original source, don't hold on to it)\n+\tpos token.Pos   // token position\n+\ttok token.Token // one token look-ahead\n+\tlit string      // token literal\n \n \t// Non-syntactic parser control\n \texprLev int // < 0: in control clause, >= 0: in expression\n \n \t// Ordinary identifer scopes\n-\tpkgScope   *ast.Scope   // pkgScope.Outer == nil\n-\ttopScope   *ast.Scope   // top-most scope; may be pkgScope\n-\tunresolved []*ast.Ident // unresolved global identifiers\n+\tpkgScope   *ast.Scope        // pkgScope.Outer == nil\n+\ttopScope   *ast.Scope        // top-most scope; may be pkgScope\n+\tunresolved []*ast.Ident      // unresolved identifiers\n+\timports    []*ast.ImportSpec // list of imports\n \n \t// Label scope\n \t// (maintained by open/close LabelScope)\n@@ -95,15 +96,6 @@ func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode uin\n }\n \n \n-func (p *parser) lit() []byte {\n-\t// make a copy of p.lit_ so that we don't hold on to\n-\t// a copy of the entire source indirectly in the AST\n-\tt := make([]byte, len(p.lit_))\n-\tcopy(t, p.lit_)\n-\treturn t\n-}\n-\n-\n // ----------------------------------------------------------------------------\n // Scoping support\n \n@@ -141,13 +133,13 @@ func (p *parser) closeLabelScope() {\n \n func (p *parser) declare(decl interface{}, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident) {\n \tfor _, ident := range idents {\n+\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n \t\tif ident.Name != \"_\" {\n \t\t\tobj := ast.NewObj(kind, ident.Name)\n \t\t\t// remember the corresponding declaration for redeclaration\n \t\t\t// errors and global variable resolution/typechecking phase\n \t\t\tobj.Decl = decl\n-\t\t\talt := scope.Insert(obj)\n-\t\t\tif alt != obj && p.mode&DeclarationErrors != 0 {\n+\t\t\tif alt := scope.Insert(obj); alt != nil && p.mode&DeclarationErrors != 0 {\n \t\t\t\tprevDecl := \"\"\n \t\t\t\tif pos := alt.Pos(); pos.IsValid() {\n \t\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", p.file.Position(pos))\n@@ -166,14 +158,16 @@ func (p *parser) shortVarDecl(idents []*ast.Ident) {\n \t// the same type, and at least one of the non-blank variables is new.\n \tn := 0 // number of new variables\n \tfor _, ident := range idents {\n+\t\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n \t\tif ident.Name != \"_\" {\n \t\t\tobj := ast.NewObj(ast.Var, ident.Name)\n \t\t\t// short var declarations cannot have redeclaration errors\n \t\t\t// and are not global => no need to remember the respective\n \t\t\t// declaration\n \t\t\talt := p.topScope.Insert(obj)\n-\t\t\tif alt == obj {\n+\t\t\tif alt == nil {\n \t\t\t\tn++ // new declaration\n+\t\t\t\talt = obj\n \t\t\t}\n \t\t\tident.Obj = alt\n \t\t}\n@@ -184,7 +178,19 @@ func (p *parser) shortVarDecl(idents []*ast.Ident) {\n }\n \n \n-func (p *parser) resolve(ident *ast.Ident) {\n+// The unresolved object is a sentinel to mark identifiers that have been added\n+// to the list of unresolved identifiers. The sentinel is only used for verifying\n+// internal consistency.\n+var unresolved = new(ast.Object)\n+\n+\n+func (p *parser) resolve(x ast.Expr) {\n+\t// nothing to do if x is not an identifier or the blank identifier\n+\tident, _ := x.(*ast.Ident)\n+\tif ident == nil {\n+\t\treturn\n+\t}\n+\tassert(ident.Obj == nil, \"identifier already declared or resolved\")\n \tif ident.Name == \"_\" {\n \t\treturn\n \t}\n@@ -195,10 +201,12 @@ func (p *parser) resolve(ident *ast.Ident) {\n \t\t\treturn\n \t\t}\n \t}\n-\t// collect unresolved global identifiers; ignore the others\n-\tif p.topScope == p.pkgScope {\n-\t\tp.unresolved = append(p.unresolved, ident)\n-\t}\n+\t// all local scopes are known, so any unresolved identifier\n+\t// must be found either in the file scope, package scope\n+\t// (perhaps in another file), or universe scope --- collect\n+\t// them so that they can be resolved later\n+\tident.Obj = unresolved\n+\tp.unresolved = append(p.unresolved, ident)\n }\n \n \n@@ -244,31 +252,32 @@ func (p *parser) next0() {\n \t\ts := p.tok.String()\n \t\tswitch {\n \t\tcase p.tok.IsLiteral():\n-\t\t\tp.printTrace(s, string(p.lit_))\n+\t\t\tp.printTrace(s, p.lit)\n \t\tcase p.tok.IsOperator(), p.tok.IsKeyword():\n \t\t\tp.printTrace(\"\\\"\" + s + \"\\\"\")\n \t\tdefault:\n \t\t\tp.printTrace(s)\n \t\t}\n \t}\n \n-\tp.pos, p.tok, p.lit_ = p.scanner.Scan()\n+\tp.pos, p.tok, p.lit = p.scanner.Scan()\n }\n \n // Consume a comment and return it and the line on which it ends.\n func (p *parser) consumeComment() (comment *ast.Comment, endline int) {\n \t// /*-style comments may end on a different line than where they start.\n \t// Scan the comment for '\\n' chars and adjust endline accordingly.\n \tendline = p.file.Line(p.pos)\n-\tif p.lit_[1] == '*' {\n-\t\tfor _, b := range p.lit_ {\n-\t\t\tif b == '\\n' {\n+\tif p.lit[1] == '*' {\n+\t\t// don't use range here - no need to decode Unicode code points\n+\t\tfor i := 0; i < len(p.lit); i++ {\n+\t\t\tif p.lit[i] == '\\n' {\n \t\t\t\tendline++\n \t\t\t}\n \t\t}\n \t}\n \n-\tcomment = &ast.Comment{p.pos, p.lit()}\n+\tcomment = &ast.Comment{p.pos, p.lit}\n \tp.next0()\n \n \treturn\n@@ -358,12 +367,12 @@ func (p *parser) errorExpected(pos token.Pos, msg string) {\n \tif pos == p.pos {\n \t\t// the error happened at the current position;\n \t\t// make the error message more specific\n-\t\tif p.tok == token.SEMICOLON && p.lit_[0] == '\\n' {\n+\t\tif p.tok == token.SEMICOLON && p.lit[0] == '\\n' {\n \t\t\tmsg += \", found newline\"\n \t\t} else {\n \t\t\tmsg += \", found '\" + p.tok.String() + \"'\"\n \t\t\tif p.tok.IsLiteral() {\n-\t\t\t\tmsg += \" \" + string(p.lit_)\n+\t\t\t\tmsg += \" \" + p.lit\n \t\t\t}\n \t\t}\n \t}\n@@ -388,14 +397,21 @@ func (p *parser) expectSemi() {\n }\n \n \n+func assert(cond bool, msg string) {\n+\tif !cond {\n+\t\tpanic(\"go/parser internal error: \" + msg)\n+\t}\n+}\n+\n+\n // ----------------------------------------------------------------------------\n // Identifiers\n \n func (p *parser) parseIdent() *ast.Ident {\n \tpos := p.pos\n \tname := \"_\"\n \tif p.tok == token.IDENT {\n-\t\tname = string(p.lit_)\n+\t\tname = p.lit\n \t\tp.next()\n \t} else {\n \t\tp.expect(token.IDENT) // use expect() error handling\n@@ -422,21 +438,51 @@ func (p *parser) parseIdentList() (list []*ast.Ident) {\n // ----------------------------------------------------------------------------\n // Common productions\n \n-func (p *parser) parseExprList() (list []ast.Expr) {\n+// If lhs is set, result list elements which are identifiers are not resolved.\n+func (p *parser) parseExprList(lhs bool) (list []ast.Expr) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ExpressionList\"))\n \t}\n \n-\tlist = append(list, p.parseExpr())\n+\tlist = append(list, p.parseExpr(lhs))\n \tfor p.tok == token.COMMA {\n \t\tp.next()\n-\t\tlist = append(list, p.parseExpr())\n+\t\tlist = append(list, p.parseExpr(lhs))\n \t}\n \n \treturn\n }\n \n \n+func (p *parser) parseLhsList() []ast.Expr {\n+\tlist := p.parseExprList(true)\n+\tswitch p.tok {\n+\tcase token.DEFINE:\n+\t\t// lhs of a short variable declaration\n+\t\tp.shortVarDecl(p.makeIdentList(list))\n+\tcase token.COLON:\n+\t\t// lhs of a label declaration or a communication clause of a select\n+\t\t// statement (parseLhsList is not called when parsing the case clause\n+\t\t// of a switch statement):\n+\t\t// - labels are declared by the caller of parseLhsList\n+\t\t// - for communication clauses, if there is a stand-alone identifier\n+\t\t//   followed by a colon, we have a syntax error; there is no need\n+\t\t//   to resolve the identifier in that case\n+\tdefault:\n+\t\t// identifiers must be declared elsewhere\n+\t\tfor _, x := range list {\n+\t\t\tp.resolve(x)\n+\t\t}\n+\t}\n+\treturn list\n+}\n+\n+\n+func (p *parser) parseRhsList() []ast.Expr {\n+\treturn p.parseExprList(false)\n+}\n+\n+\n // ----------------------------------------------------------------------------\n // Types\n \n@@ -458,31 +504,24 @@ func (p *parser) parseType() ast.Expr {\n }\n \n \n-func (p *parser) parseQualifiedIdent() ast.Expr {\n+// If the result is an identifier, it is not resolved.\n+func (p *parser) parseTypeName() ast.Expr {\n \tif p.trace {\n-\t\tdefer un(trace(p, \"QualifiedIdent\"))\n+\t\tdefer un(trace(p, \"TypeName\"))\n \t}\n \n \tident := p.parseIdent()\n-\tp.resolve(ident)\n-\tvar x ast.Expr = ident\n+\t// don't resolve ident yet - it may be a parameter or field name\n+\n \tif p.tok == token.PERIOD {\n-\t\t// first identifier is a package identifier\n+\t\t// ident is a package name\n \t\tp.next()\n+\t\tp.resolve(ident)\n \t\tsel := p.parseIdent()\n-\t\tx = &ast.SelectorExpr{x, sel}\n+\t\treturn &ast.SelectorExpr{ident, sel}\n \t}\n \n-\treturn x\n-}\n-\n-\n-func (p *parser) parseTypeName() ast.Expr {\n-\tif p.trace {\n-\t\tdefer un(trace(p, \"TypeName\"))\n-\t}\n-\n-\treturn p.parseQualifiedIdent()\n+\treturn ident\n }\n \n \n@@ -497,7 +536,7 @@ func (p *parser) parseArrayType(ellipsisOk bool) ast.Expr {\n \t\tlen = &ast.Ellipsis{p.pos, nil}\n \t\tp.next()\n \t} else if p.tok != token.RBRACK {\n-\t\tlen = p.parseExpr()\n+\t\tlen = p.parseRhs()\n \t}\n \tp.expect(token.RBRACK)\n \telt := p.parseType()\n@@ -521,7 +560,7 @@ func (p *parser) makeIdentList(list []ast.Expr) []*ast.Ident {\n }\n \n \n-func (p *parser) parseFieldDecl() *ast.Field {\n+func (p *parser) parseFieldDecl(scope *ast.Scope) *ast.Field {\n \tif p.trace {\n \t\tdefer un(trace(p, \"FieldDecl\"))\n \t}\n@@ -534,7 +573,7 @@ func (p *parser) parseFieldDecl() *ast.Field {\n \t// optional tag\n \tvar tag *ast.BasicLit\n \tif p.tok == token.STRING {\n-\t\ttag = &ast.BasicLit{p.pos, p.tok, p.lit()}\n+\t\ttag = &ast.BasicLit{p.pos, p.tok, p.lit}\n \t\tp.next()\n \t}\n \n@@ -546,6 +585,7 @@ func (p *parser) parseFieldDecl() *ast.Field {\n \t} else {\n \t\t// [\"*\"] TypeName (AnonymousField)\n \t\ttyp = list[0] // we always have at least one element\n+\t\tp.resolve(typ)\n \t\tif n := len(list); n > 1 || !isTypeName(deref(typ)) {\n \t\t\tpos := typ.Pos()\n \t\t\tp.errorExpected(pos, \"anonymous field\")\n@@ -555,7 +595,10 @@ func (p *parser) parseFieldDecl() *ast.Field {\n \n \tp.expectSemi() // call before accessing p.linecomment\n \n-\treturn &ast.Field{doc, idents, typ, tag, p.lineComment}\n+\tfield := &ast.Field{doc, idents, typ, tag, p.lineComment}\n+\tp.declare(field, scope, ast.Var, idents...)\n+\n+\treturn field\n }\n \n \n@@ -566,15 +609,17 @@ func (p *parser) parseStructType() *ast.StructType {\n \n \tpos := p.expect(token.STRUCT)\n \tlbrace := p.expect(token.LBRACE)\n+\tscope := ast.NewScope(nil) // struct scope\n \tvar list []*ast.Field\n \tfor p.tok == token.IDENT || p.tok == token.MUL || p.tok == token.LPAREN {\n \t\t// a field declaration cannot start with a '(' but we accept\n \t\t// it here for more robust parsing and better error messages\n \t\t// (parseFieldDecl will check and complain if necessary)\n-\t\tlist = append(list, p.parseFieldDecl())\n+\t\tlist = append(list, p.parseFieldDecl(scope))\n \t}\n \trbrace := p.expect(token.RBRACE)\n \n+\t// TODO(gri): store struct scope in AST\n \treturn &ast.StructType{pos, &ast.FieldList{lbrace, list, rbrace}, false}\n }\n \n@@ -595,7 +640,7 @@ func (p *parser) tryVarType(isParam bool) ast.Expr {\n \tif isParam && p.tok == token.ELLIPSIS {\n \t\tpos := p.pos\n \t\tp.next()\n-\t\ttyp := p.tryType() // don't use parseType so we can provide better error message\n+\t\ttyp := p.tryIdentOrType(isParam) // don't use parseType so we can provide better error message\n \t\tif typ == nil {\n \t\t\tp.error(pos, \"'...' parameter is missing type\")\n \t\t\ttyp = &ast.BadExpr{pos, p.pos}\n@@ -605,7 +650,7 @@ func (p *parser) tryVarType(isParam bool) ast.Expr {\n \t\t}\n \t\treturn &ast.Ellipsis{pos, typ}\n \t}\n-\treturn p.tryType()\n+\treturn p.tryIdentOrType(false)\n }\n \n \n@@ -641,6 +686,9 @@ func (p *parser) parseVarList(isParam bool) (list []ast.Expr, typ ast.Expr) {\n \n \t// if we had a list of identifiers, it must be followed by a type\n \ttyp = p.tryVarType(isParam)\n+\tif typ != nil {\n+\t\tp.resolve(typ)\n+\t}\n \n \treturn\n }\n@@ -682,6 +730,7 @@ func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params [\n \t\t// Type { \",\" Type } (anonymous parameters)\n \t\tparams = make([]*ast.Field, len(list))\n \t\tfor i, x := range list {\n+\t\t\tp.resolve(x)\n \t\t\tparams[i] = &ast.Field{Type: x}\n \t\t}\n \t}\n@@ -751,15 +800,15 @@ func (p *parser) parseFuncType() (*ast.FuncType, *ast.Scope) {\n }\n \n \n-func (p *parser) parseMethodSpec() *ast.Field {\n+func (p *parser) parseMethodSpec(scope *ast.Scope) *ast.Field {\n \tif p.trace {\n \t\tdefer un(trace(p, \"MethodSpec\"))\n \t}\n \n \tdoc := p.leadComment\n \tvar idents []*ast.Ident\n \tvar typ ast.Expr\n-\tx := p.parseQualifiedIdent()\n+\tx := p.parseTypeName()\n \tif ident, isIdent := x.(*ast.Ident); isIdent && p.tok == token.LPAREN {\n \t\t// method\n \t\tidents = []*ast.Ident{ident}\n@@ -772,7 +821,10 @@ func (p *parser) parseMethodSpec() *ast.Field {\n \t}\n \tp.expectSemi() // call before accessing p.linecomment\n \n-\treturn &ast.Field{doc, idents, typ, nil, p.lineComment}\n+\tspec := &ast.Field{doc, idents, typ, nil, p.lineComment}\n+\tp.declare(spec, scope, ast.Fun, idents...)\n+\n+\treturn spec\n }\n \n \n@@ -783,12 +835,14 @@ func (p *parser) parseInterfaceType() *ast.InterfaceType {\n \n \tpos := p.expect(token.INTERFACE)\n \tlbrace := p.expect(token.LBRACE)\n+\tscope := ast.NewScope(nil) // interface scope\n \tvar list []*ast.Field\n \tfor p.tok == token.IDENT {\n-\t\tlist = append(list, p.parseMethodSpec())\n+\t\tlist = append(list, p.parseMethodSpec(scope))\n \t}\n \trbrace := p.expect(token.RBRACE)\n \n+\t// TODO(gri): store interface scope in AST\n \treturn &ast.InterfaceType{pos, &ast.FieldList{lbrace, list, rbrace}, false}\n }\n \n@@ -832,7 +886,8 @@ func (p *parser) parseChanType() *ast.ChanType {\n }\n \n \n-func (p *parser) tryRawType(ellipsisOk bool) ast.Expr {\n+// If the result is an identifier, it is not resolved.\n+func (p *parser) tryIdentOrType(ellipsisOk bool) ast.Expr {\n \tswitch p.tok {\n \tcase token.IDENT:\n \t\treturn p.parseTypeName()\n@@ -864,7 +919,13 @@ func (p *parser) tryRawType(ellipsisOk bool) ast.Expr {\n }\n \n \n-func (p *parser) tryType() ast.Expr { return p.tryRawType(false) }\n+func (p *parser) tryType() ast.Expr {\n+\ttyp := p.tryIdentOrType(false)\n+\tif typ != nil {\n+\t\tp.resolve(typ)\n+\t}\n+\treturn typ\n+}\n \n \n // ----------------------------------------------------------------------------\n@@ -939,28 +1000,31 @@ func (p *parser) parseFuncTypeOrLit() ast.Expr {\n \n // parseOperand may return an expression or a raw type (incl. array\n // types of the form [...]T. Callers must verify the result.\n+// If lhs is set and the result is an identifier, it is not resolved.\n //\n-func (p *parser) parseOperand() ast.Expr {\n+func (p *parser) parseOperand(lhs bool) ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Operand\"))\n \t}\n \n \tswitch p.tok {\n \tcase token.IDENT:\n-\t\tident := p.parseIdent()\n-\t\tp.resolve(ident)\n-\t\treturn ident\n+\t\tx := p.parseIdent()\n+\t\tif !lhs {\n+\t\t\tp.resolve(x)\n+\t\t}\n+\t\treturn x\n \n \tcase token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:\n-\t\tx := &ast.BasicLit{p.pos, p.tok, p.lit()}\n+\t\tx := &ast.BasicLit{p.pos, p.tok, p.lit}\n \t\tp.next()\n \t\treturn x\n \n \tcase token.LPAREN:\n \t\tlparen := p.pos\n \t\tp.next()\n \t\tp.exprLev++\n-\t\tx := p.parseExpr()\n+\t\tx := p.parseRhs()\n \t\tp.exprLev--\n \t\trparen := p.expect(token.RPAREN)\n \t\treturn &ast.ParenExpr{lparen, x, rparen}\n@@ -969,9 +1033,11 @@ func (p *parser) parseOperand() ast.Expr {\n \t\treturn p.parseFuncTypeOrLit()\n \n \tdefault:\n-\t\tt := p.tryRawType(true) // could be type for composite literal or conversion\n-\t\tif t != nil {\n-\t\t\treturn t\n+\t\tif typ := p.tryIdentOrType(true); typ != nil {\n+\t\t\t// could be type for composite literal or conversion\n+\t\t\t_, isIdent := typ.(*ast.Ident)\n+\t\t\tassert(!isIdent, \"type cannot be identifier\")\n+\t\t\treturn typ\n \t\t}\n \t}\n \n@@ -982,19 +1048,22 @@ func (p *parser) parseOperand() ast.Expr {\n }\n \n \n-func (p *parser) parseSelectorOrTypeAssertion(x ast.Expr) ast.Expr {\n+func (p *parser) parseSelector(x ast.Expr) ast.Expr {\n \tif p.trace {\n-\t\tdefer un(trace(p, \"SelectorOrTypeAssertion\"))\n+\t\tdefer un(trace(p, \"Selector\"))\n \t}\n \n-\tp.expect(token.PERIOD)\n-\tif p.tok == token.IDENT {\n-\t\t// selector\n-\t\tsel := p.parseIdent()\n-\t\treturn &ast.SelectorExpr{x, sel}\n+\tsel := p.parseIdent()\n+\n+\treturn &ast.SelectorExpr{x, sel}\n+}\n+\n+\n+func (p *parser) parseTypeAssertion(x ast.Expr) ast.Expr {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"TypeAssertion\"))\n \t}\n \n-\t// type assertion\n \tp.expect(token.LPAREN)\n \tvar typ ast.Expr\n \tif p.tok == token.TYPE {\n@@ -1019,13 +1088,13 @@ func (p *parser) parseIndexOrSlice(x ast.Expr) ast.Expr {\n \tvar low, high ast.Expr\n \tisSlice := false\n \tif p.tok != token.COLON {\n-\t\tlow = p.parseExpr()\n+\t\tlow = p.parseRhs()\n \t}\n \tif p.tok == token.COLON {\n \t\tisSlice = true\n \t\tp.next()\n \t\tif p.tok != token.RBRACK {\n-\t\t\thigh = p.parseExpr()\n+\t\t\thigh = p.parseRhs()\n \t\t}\n \t}\n \tp.exprLev--\n@@ -1048,7 +1117,7 @@ func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {\n \tvar list []ast.Expr\n \tvar ellipsis token.Pos\n \tfor p.tok != token.RPAREN && p.tok != token.EOF && !ellipsis.IsValid() {\n-\t\tlist = append(list, p.parseExpr())\n+\t\tlist = append(list, p.parseRhs())\n \t\tif p.tok == token.ELLIPSIS {\n \t\t\tellipsis = p.pos\n \t\t\tp.next()\n@@ -1074,12 +1143,16 @@ func (p *parser) parseElement(keyOk bool) ast.Expr {\n \t\treturn p.parseLiteralValue(nil)\n \t}\n \n-\tx := p.parseExpr()\n-\tif keyOk && p.tok == token.COLON {\n-\t\tcolon := p.pos\n-\t\tp.next()\n-\t\tx = &ast.KeyValueExpr{x, colon, p.parseElement(false)}\n+\tx := p.parseExpr(keyOk) // don't resolve if map key\n+\tif keyOk {\n+\t\tif p.tok == token.COLON {\n+\t\t\tcolon := p.pos\n+\t\t\tp.next()\n+\t\t\treturn &ast.KeyValueExpr{x, colon, p.parseElement(false)}\n+\t\t}\n+\t\tp.resolve(x) // not a map key\n \t}\n+\n \treturn x\n }\n \n@@ -1231,37 +1304,63 @@ func (p *parser) checkExprOrType(x ast.Expr) ast.Expr {\n }\n \n \n-func (p *parser) parsePrimaryExpr() ast.Expr {\n+// If lhs is set and the result is an identifier, it is not resolved.\n+func (p *parser) parsePrimaryExpr(lhs bool) ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"PrimaryExpr\"))\n \t}\n \n-\tx := p.parseOperand()\n+\tx := p.parseOperand(lhs)\n L:\n \tfor {\n \t\tswitch p.tok {\n \t\tcase token.PERIOD:\n-\t\t\tx = p.parseSelectorOrTypeAssertion(p.checkExpr(x))\n+\t\t\tp.next()\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t}\n+\t\t\tswitch p.tok {\n+\t\t\tcase token.IDENT:\n+\t\t\t\tx = p.parseSelector(p.checkExpr(x))\n+\t\t\tcase token.LPAREN:\n+\t\t\t\tx = p.parseTypeAssertion(p.checkExpr(x))\n+\t\t\tdefault:\n+\t\t\t\tpos := p.pos\n+\t\t\t\tp.next() // make progress\n+\t\t\t\tp.errorExpected(pos, \"selector or type assertion\")\n+\t\t\t\tx = &ast.BadExpr{pos, p.pos}\n+\t\t\t}\n \t\tcase token.LBRACK:\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t}\n \t\t\tx = p.parseIndexOrSlice(p.checkExpr(x))\n \t\tcase token.LPAREN:\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t}\n \t\t\tx = p.parseCallOrConversion(p.checkExprOrType(x))\n \t\tcase token.LBRACE:\n \t\t\tif isLiteralType(x) && (p.exprLev >= 0 || !isTypeName(x)) {\n+\t\t\t\tif lhs {\n+\t\t\t\t\tp.resolve(x)\n+\t\t\t\t}\n \t\t\t\tx = p.parseLiteralValue(x)\n \t\t\t} else {\n \t\t\t\tbreak L\n \t\t\t}\n \t\tdefault:\n \t\t\tbreak L\n \t\t}\n+\t\tlhs = false // no need to try to resolve again\n \t}\n \n \treturn x\n }\n \n \n-func (p *parser) parseUnaryExpr() ast.Expr {\n+// If lhs is set and the result is an identifier, it is not resolved.\n+func (p *parser) parseUnaryExpr(lhs bool) ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"UnaryExpr\"))\n \t}\n@@ -1270,7 +1369,7 @@ func (p *parser) parseUnaryExpr() ast.Expr {\n \tcase token.ADD, token.SUB, token.NOT, token.XOR, token.AND, token.RANGE:\n \t\tpos, op := p.pos, p.tok\n \t\tp.next()\n-\t\tx := p.parseUnaryExpr()\n+\t\tx := p.parseUnaryExpr(false)\n \t\treturn &ast.UnaryExpr{pos, op, p.checkExpr(x)}\n \n \tcase token.ARROW:\n@@ -1283,32 +1382,37 @@ func (p *parser) parseUnaryExpr() ast.Expr {\n \t\t\treturn &ast.ChanType{pos, ast.RECV, value}\n \t\t}\n \n-\t\tx := p.parseUnaryExpr()\n+\t\tx := p.parseUnaryExpr(false)\n \t\treturn &ast.UnaryExpr{pos, token.ARROW, p.checkExpr(x)}\n \n \tcase token.MUL:\n \t\t// pointer type or unary \"*\" expression\n \t\tpos := p.pos\n \t\tp.next()\n-\t\tx := p.parseUnaryExpr()\n+\t\tx := p.parseUnaryExpr(false)\n \t\treturn &ast.StarExpr{pos, p.checkExprOrType(x)}\n \t}\n \n-\treturn p.parsePrimaryExpr()\n+\treturn p.parsePrimaryExpr(lhs)\n }\n \n \n-func (p *parser) parseBinaryExpr(prec1 int) ast.Expr {\n+// If lhs is set and the result is an identifier, it is not resolved.\n+func (p *parser) parseBinaryExpr(lhs bool, prec1 int) ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"BinaryExpr\"))\n \t}\n \n-\tx := p.parseUnaryExpr()\n+\tx := p.parseUnaryExpr(lhs)\n \tfor prec := p.tok.Precedence(); prec >= prec1; prec-- {\n \t\tfor p.tok.Precedence() == prec {\n \t\t\tpos, op := p.pos, p.tok\n \t\t\tp.next()\n-\t\t\ty := p.parseBinaryExpr(prec + 1)\n+\t\t\tif lhs {\n+\t\t\t\tp.resolve(x)\n+\t\t\t\tlhs = false\n+\t\t\t}\n+\t\t\ty := p.parseBinaryExpr(false, prec+1)\n \t\t\tx = &ast.BinaryExpr{p.checkExpr(x), pos, op, p.checkExpr(y)}\n \t\t}\n \t}\n@@ -1317,14 +1421,20 @@ func (p *parser) parseBinaryExpr(prec1 int) ast.Expr {\n }\n \n \n+// If lhs is set and the result is an identifier, it is not resolved.\n // TODO(gri): parseExpr may return a type or even a raw type ([..]int) -\n //            should reject when a type/raw type is obviously not allowed\n-func (p *parser) parseExpr() ast.Expr {\n+func (p *parser) parseExpr(lhs bool) ast.Expr {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Expression\"))\n \t}\n \n-\treturn p.parseBinaryExpr(token.LowestPrec + 1)\n+\treturn p.parseBinaryExpr(lhs, token.LowestPrec+1)\n+}\n+\n+\n+func (p *parser) parseRhs() ast.Expr {\n+\treturn p.parseExpr(false)\n }\n \n \n@@ -1336,7 +1446,7 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \t\tdefer un(trace(p, \"SimpleStmt\"))\n \t}\n \n-\tx := p.parseExprList()\n+\tx := p.parseLhsList()\n \n \tswitch p.tok {\n \tcase\n@@ -1347,10 +1457,7 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \t\t// assignment statement\n \t\tpos, tok := p.pos, p.tok\n \t\tp.next()\n-\t\ty := p.parseExprList()\n-\t\tif tok == token.DEFINE {\n-\t\t\tp.shortVarDecl(p.makeIdentList(x))\n-\t\t}\n+\t\ty := p.parseRhsList()\n \t\treturn &ast.AssignStmt{x, pos, tok, y}\n \t}\n \n@@ -1379,7 +1486,7 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \t\t// send statement\n \t\tarrow := p.pos\n \t\tp.next() // consume \"<-\"\n-\t\ty := p.parseExpr()\n+\t\ty := p.parseRhs()\n \t\treturn &ast.SendStmt{x[0], arrow, y}\n \n \tcase token.INC, token.DEC:\n@@ -1395,7 +1502,7 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \n \n func (p *parser) parseCallExpr() *ast.CallExpr {\n-\tx := p.parseExpr()\n+\tx := p.parseRhs()\n \tif call, isCall := x.(*ast.CallExpr); isCall {\n \t\treturn call\n \t}\n@@ -1445,7 +1552,7 @@ func (p *parser) parseReturnStmt() *ast.ReturnStmt {\n \tp.expect(token.RETURN)\n \tvar x []ast.Expr\n \tif p.tok != token.SEMICOLON && p.tok != token.RBRACE {\n-\t\tx = p.parseExprList()\n+\t\tx = p.parseRhsList()\n \t}\n \tp.expectSemi()\n \n@@ -1500,12 +1607,12 @@ func (p *parser) parseIfStmt() *ast.IfStmt {\n \t\tp.exprLev = -1\n \t\tif p.tok == token.SEMICOLON {\n \t\t\tp.next()\n-\t\t\tx = p.parseExpr()\n+\t\t\tx = p.parseRhs()\n \t\t} else {\n \t\t\ts = p.parseSimpleStmt(false)\n \t\t\tif p.tok == token.SEMICOLON {\n \t\t\t\tp.next()\n-\t\t\t\tx = p.parseExpr()\n+\t\t\t\tx = p.parseRhs()\n \t\t\t} else {\n \t\t\t\tx = p.makeExpr(s)\n \t\t\t\ts = nil\n@@ -1552,7 +1659,7 @@ func (p *parser) parseCaseClause(exprSwitch bool) *ast.CaseClause {\n \tif p.tok == token.CASE {\n \t\tp.next()\n \t\tif exprSwitch {\n-\t\t\tlist = p.parseExprList()\n+\t\t\tlist = p.parseRhsList()\n \t\t} else {\n \t\t\tlist = p.parseTypeList()\n \t\t}\n@@ -1639,7 +1746,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \tvar comm ast.Stmt\n \tif p.tok == token.CASE {\n \t\tp.next()\n-\t\tlhs := p.parseExprList()\n+\t\tlhs := p.parseLhsList()\n \t\tif p.tok == token.ARROW {\n \t\t\t// SendStmt\n \t\t\tif len(lhs) > 1 {\n@@ -1648,7 +1755,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t}\n \t\t\tarrow := p.pos\n \t\t\tp.next()\n-\t\t\trhs := p.parseExpr()\n+\t\t\trhs := p.parseRhs()\n \t\t\tcomm = &ast.SendStmt{lhs[0], arrow, rhs}\n \t\t} else {\n \t\t\t// RecvStmt\n@@ -1663,10 +1770,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t\t\tlhs = lhs[0:2]\n \t\t\t\t}\n \t\t\t\tp.next()\n-\t\t\t\trhs = p.parseExpr()\n-\t\t\t\tif tok == token.DEFINE {\n-\t\t\t\t\tp.shortVarDecl(p.makeIdentList(lhs))\n-\t\t\t\t}\n+\t\t\t\trhs = p.parseRhs()\n \t\t\t} else {\n \t\t\t\t// rhs must be single receive operation\n \t\t\t\tif len(lhs) > 1 {\n@@ -1866,14 +1970,18 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \n \tvar path *ast.BasicLit\n \tif p.tok == token.STRING {\n-\t\tpath = &ast.BasicLit{p.pos, p.tok, p.lit()}\n+\t\tpath = &ast.BasicLit{p.pos, p.tok, p.lit}\n \t\tp.next()\n \t} else {\n \t\tp.expect(token.STRING) // use expect() error handling\n \t}\n \tp.expectSemi() // call before accessing p.linecomment\n \n-\treturn &ast.ImportSpec{doc, ident, path, p.lineComment}\n+\t// collect imports\n+\tspec := &ast.ImportSpec{doc, ident, path, p.lineComment}\n+\tp.imports = append(p.imports, spec)\n+\n+\treturn spec\n }\n \n \n@@ -1887,7 +1995,7 @@ func parseConstSpec(p *parser, doc *ast.CommentGroup, iota int) ast.Spec {\n \tvar values []ast.Expr\n \tif typ != nil || p.tok == token.ASSIGN || iota == 0 {\n \t\tp.expect(token.ASSIGN)\n-\t\tvalues = p.parseExprList()\n+\t\tvalues = p.parseRhsList()\n \t}\n \tp.expectSemi() // call before accessing p.linecomment\n \n@@ -1932,7 +2040,7 @@ func parseVarSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tvar values []ast.Expr\n \tif typ == nil || p.tok == token.ASSIGN {\n \t\tp.expect(token.ASSIGN)\n-\t\tvalues = p.parseExprList()\n+\t\tvalues = p.parseRhsList()\n \t}\n \tp.expectSemi() // call before accessing p.linecomment\n \n@@ -2120,20 +2228,20 @@ func (p *parser) parseFile() *ast.File {\n \t\t}\n \t}\n \n-\tif p.topScope != p.pkgScope {\n-\t\tpanic(\"internal error: imbalanced scopes\")\n-\t}\n+\tassert(p.topScope == p.pkgScope, \"imbalanced scopes\")\n \n \t// resolve global identifiers within the same file\n \ti := 0\n \tfor _, ident := range p.unresolved {\n \t\t// i <= index for current ident\n-\t\tident.Obj = p.pkgScope.Lookup(ident.Name)\n+\t\tassert(ident.Obj == unresolved, \"object already resolved\")\n+\t\tident.Obj = p.pkgScope.Lookup(ident.Name) // also removes unresolved sentinel\n \t\tif ident.Obj == nil {\n \t\t\tp.unresolved[i] = ident\n \t\t\ti++\n \t\t}\n \t}\n \n-\treturn &ast.File{doc, pos, ident, decls, p.pkgScope, p.unresolved[0:i], p.comments}\n+\t// TODO(gri): store p.imports in AST\n+\treturn &ast.File{doc, pos, ident, decls, p.pkgScope, p.imports, p.unresolved[0:i], p.comments}\n }"}, {"sha": "0b3b6621e6c1513506163e31499b46d570176bc2", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -160,19 +160,7 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t// the first linebreak is always a formfeed since this section must not\n \t// depend on any previous formatting\n \tprevBreak := -1 // index of last expression that was followed by a linebreak\n-\tlinebreakMin := 1\n-\tif mode&periodSep != 0 {\n-\t\t// Make fragments like\n-\t\t//\n-\t\t// a.Bar(1,\n-\t\t//   2).Foo\n-\t\t//\n-\t\t// format correctly (a linebreak shouldn't be added before Foo) when\n-\t\t// doing period-separated expr lists by setting minimum linebreak to 0\n-\t\t// lines for them.\n-\t\tlinebreakMin = 0\n-\t}\n-\tif prev.IsValid() && prev.Line < line && p.linebreak(line, linebreakMin, ws, true) {\n+\tif prev.IsValid() && prev.Line < line && p.linebreak(line, 0, ws, true) {\n \t\tws = ignore\n \t\t*multiLine = true\n \t\tprevBreak = 0\n@@ -237,7 +225,7 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t\t\t// lines are broken using newlines so comments remain aligned\n \t\t\t\t// unless forceFF is set or there are multiple expressions on\n \t\t\t\t// the same line in which case formfeed is used\n-\t\t\t\tif p.linebreak(line, linebreakMin, ws, useFF || prevBreak+1 < i) {\n+\t\t\t\tif p.linebreak(line, 0, ws, useFF || prevBreak+1 < i) {\n \t\t\t\t\tws = ignore\n \t\t\t\t\t*multiLine = true\n \t\t\t\t\tprevBreak = i\n@@ -363,7 +351,7 @@ func (p *printer) isOneLineFieldList(list []*ast.Field) bool {\n \n \n func (p *printer) setLineComment(text string) {\n-\tp.setComment(&ast.CommentGroup{[]*ast.Comment{&ast.Comment{token.NoPos, []byte(text)}}})\n+\tp.setComment(&ast.CommentGroup{[]*ast.Comment{&ast.Comment{token.NoPos, text}}})\n }\n \n \n@@ -527,7 +515,7 @@ func walkBinary(e *ast.BinaryExpr) (has4, has5 bool, maxProblem int) {\n \t\t}\n \n \tcase *ast.StarExpr:\n-\t\tif e.Op.String() == \"/\" {\n+\t\tif e.Op == token.QUO { // `*/`\n \t\t\tmaxProblem = 5\n \t\t}\n "}, {"sha": "697a83fa8665cf0dc24a386f9e798f9d4fd89cb3", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 65, "deletions": 100, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -34,12 +34,6 @@ const (\n )\n \n \n-const (\n-\tesc2 = '\\xfe'                        // an escape byte that cannot occur in regular UTF-8\n-\t_    = 1 / (esc2 - tabwriter.Escape) // cause compiler error if esc2 == tabwriter.Escape\n-)\n-\n-\n var (\n \tesc       = []byte{tabwriter.Escape}\n \thtab      = []byte{'\\t'}\n@@ -81,8 +75,9 @@ type printer struct {\n \tmode    pmode       // current printer mode\n \tlastTok token.Token // the last token printed (token.ILLEGAL if it's whitespace)\n \n-\t// Buffered whitespace\n-\tbuffer []whiteSpace\n+\t// Reused buffers\n+\twsbuf  []whiteSpace // delayed white space\n+\tlitbuf bytes.Buffer // for creation of escaped literals and comments\n \n \t// The (possibly estimated) position in the generated output;\n \t// in AST space (i.e., pos is set whenever a token position is\n@@ -109,7 +104,7 @@ func (p *printer) init(output io.Writer, cfg *Config, fset *token.FileSet, nodeS\n \tp.Config = *cfg\n \tp.fset = fset\n \tp.errors = make(chan os.Error)\n-\tp.buffer = make([]whiteSpace, 0, 16) // whitespace sequences are short\n+\tp.wsbuf = make([]whiteSpace, 0, 16) // whitespace sequences are short\n \tp.nodeSizes = nodeSizes\n }\n \n@@ -123,6 +118,20 @@ func (p *printer) internalError(msg ...interface{}) {\n }\n \n \n+// escape escapes string s by bracketing it with tabwriter.Escape.\n+// Escaped strings pass through tabwriter unchanged. (Note that\n+// valid Go programs cannot contain tabwriter.Escape bytes since\n+// they do not appear in legal UTF-8 sequences).\n+//\n+func (p *printer) escape(s string) string {\n+\tp.litbuf.Reset()\n+\tp.litbuf.WriteByte(tabwriter.Escape)\n+\tp.litbuf.WriteString(s)\n+\tp.litbuf.WriteByte(tabwriter.Escape)\n+\treturn p.litbuf.String()\n+}\n+\n+\n // nlines returns the adjusted number of linebreaks given the desired number\n // of breaks n such that min <= result <= max where max depends on the current\n // nesting level.\n@@ -230,7 +239,7 @@ func (p *printer) writeNewlines(n int, useFF bool) {\n // source text. writeItem updates p.last to the position immediately following\n // the data.\n //\n-func (p *printer) writeItem(pos token.Position, data []byte) {\n+func (p *printer) writeItem(pos token.Position, data string) {\n \tif pos.IsValid() {\n \t\t// continue with previous position if we don't have a valid pos\n \t\tif p.last.IsValid() && p.last.Filename != pos.Filename {\n@@ -239,7 +248,7 @@ func (p *printer) writeItem(pos token.Position, data []byte) {\n \t\t\t// e.g., the result of ast.MergePackageFiles)\n \t\t\tp.indent = 0\n \t\t\tp.mode = 0\n-\t\t\tp.buffer = p.buffer[0:0]\n+\t\t\tp.wsbuf = p.wsbuf[0:0]\n \t\t}\n \t\tp.pos = pos\n \t}\n@@ -248,7 +257,7 @@ func (p *printer) writeItem(pos token.Position, data []byte) {\n \t\t_, filename := filepath.Split(pos.Filename)\n \t\tp.write0([]byte(fmt.Sprintf(\"[%s:%d:%d]\", filename, pos.Line, pos.Column)))\n \t}\n-\tp.write(data)\n+\tp.write([]byte(data))\n \tp.last = p.pos\n }\n \n@@ -280,11 +289,11 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment\n \t\tif prev == nil {\n \t\t\t// first comment of a comment group\n \t\t\tj := 0\n-\t\t\tfor i, ch := range p.buffer {\n+\t\t\tfor i, ch := range p.wsbuf {\n \t\t\t\tswitch ch {\n \t\t\t\tcase blank:\n \t\t\t\t\t// ignore any blanks before a comment\n-\t\t\t\t\tp.buffer[i] = ignore\n+\t\t\t\t\tp.wsbuf[i] = ignore\n \t\t\t\t\tcontinue\n \t\t\t\tcase vtab:\n \t\t\t\t\t// respect existing tabs - important\n@@ -318,11 +327,11 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment\n \t\tif prev == nil {\n \t\t\t// first comment of a comment group\n \t\t\tj := 0\n-\t\t\tfor i, ch := range p.buffer {\n+\t\t\tfor i, ch := range p.wsbuf {\n \t\t\t\tswitch ch {\n \t\t\t\tcase blank, vtab:\n \t\t\t\t\t// ignore any horizontal whitespace before line breaks\n-\t\t\t\t\tp.buffer[i] = ignore\n+\t\t\t\t\tp.wsbuf[i] = ignore\n \t\t\t\t\tcontinue\n \t\t\t\tcase indent:\n \t\t\t\t\t// apply pending indentation\n@@ -339,7 +348,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment\n \t\t\t\t\t}\n \t\t\t\tcase newline, formfeed:\n \t\t\t\t\t// TODO(gri): may want to keep formfeed info in some cases\n-\t\t\t\t\tp.buffer[i] = ignore\n+\t\t\t\t\tp.wsbuf[i] = ignore\n \t\t\t\t}\n \t\t\t\tj = i\n \t\t\t\tbreak\n@@ -360,12 +369,8 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment\n }\n \n \n-func (p *printer) writeCommentLine(comment *ast.Comment, pos token.Position, line []byte) {\n-\t// line must pass through unchanged, bracket it with tabwriter.Escape\n-\tline = bytes.Join([][]byte{esc, line, esc}, nil)\n-\tp.writeItem(pos, line)\n-}\n-\n+// TODO(gri): It should be possible to convert the code below from using\n+//            []byte to string and in the process eliminate some conversions.\n \n // Split comment text into lines\n func split(text []byte) [][]byte {\n@@ -546,13 +551,13 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \n \t// shortcut common case of //-style comments\n \tif text[1] == '/' {\n-\t\tp.writeCommentLine(comment, p.fset.Position(comment.Pos()), text)\n+\t\tp.writeItem(p.fset.Position(comment.Pos()), p.escape(text))\n \t\treturn\n \t}\n \n \t// for /*-style comments, print line by line and let the\n \t// write function take care of the proper indentation\n-\tlines := split(text)\n+\tlines := split([]byte(text))\n \tstripCommonPrefix(lines)\n \n \t// write comment lines, separated by formfeed,\n@@ -565,7 +570,7 @@ func (p *printer) writeComment(comment *ast.Comment) {\n \t\t\tpos = p.pos\n \t\t}\n \t\tif len(line) > 0 {\n-\t\t\tp.writeCommentLine(comment, pos, line)\n+\t\t\tp.writeItem(pos, p.escape(string(line)))\n \t\t}\n \t}\n }\n@@ -578,11 +583,11 @@ func (p *printer) writeComment(comment *ast.Comment) {\n // formfeed was dropped from the whitespace buffer.\n //\n func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n-\tfor i, ch := range p.buffer {\n+\tfor i, ch := range p.wsbuf {\n \t\tswitch ch {\n \t\tcase blank, vtab:\n \t\t\t// ignore trailing whitespace\n-\t\t\tp.buffer[i] = ignore\n+\t\t\tp.wsbuf[i] = ignore\n \t\tcase indent, unindent:\n \t\t\t// don't loose indentation information\n \t\tcase newline, formfeed:\n@@ -594,11 +599,11 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (droppedFF bool) {\n \t\t\t\tif ch == formfeed {\n \t\t\t\t\tdroppedFF = true\n \t\t\t\t}\n-\t\t\t\tp.buffer[i] = ignore\n+\t\t\t\tp.wsbuf[i] = ignore\n \t\t\t}\n \t\t}\n \t}\n-\tp.writeWhitespace(len(p.buffer))\n+\tp.writeWhitespace(len(p.wsbuf))\n \n \t// make sure we have a line break\n \tif needsLinebreak {\n@@ -652,7 +657,7 @@ func (p *printer) writeWhitespace(n int) {\n \t// write entries\n \tvar data [1]byte\n \tfor i := 0; i < n; i++ {\n-\t\tswitch ch := p.buffer[i]; ch {\n+\t\tswitch ch := p.wsbuf[i]; ch {\n \t\tcase ignore:\n \t\t\t// ignore!\n \t\tcase indent:\n@@ -670,13 +675,13 @@ func (p *printer) writeWhitespace(n int) {\n \t\t\t// the line break and the label, the unindent is not\n \t\t\t// part of the comment whitespace prefix and the comment\n \t\t\t// will be positioned correctly indented.\n-\t\t\tif i+1 < n && p.buffer[i+1] == unindent {\n+\t\t\tif i+1 < n && p.wsbuf[i+1] == unindent {\n \t\t\t\t// Use a formfeed to terminate the current section.\n \t\t\t\t// Otherwise, a long label name on the next line leading\n \t\t\t\t// to a wide column may increase the indentation column\n \t\t\t\t// of lines before the label; effectively leading to wrong\n \t\t\t\t// indentation.\n-\t\t\t\tp.buffer[i], p.buffer[i+1] = unindent, formfeed\n+\t\t\t\tp.wsbuf[i], p.wsbuf[i+1] = unindent, formfeed\n \t\t\t\ti-- // do it again\n \t\t\t\tcontinue\n \t\t\t}\n@@ -689,11 +694,11 @@ func (p *printer) writeWhitespace(n int) {\n \n \t// shift remaining entries down\n \ti := 0\n-\tfor ; n < len(p.buffer); n++ {\n-\t\tp.buffer[i] = p.buffer[n]\n+\tfor ; n < len(p.wsbuf); n++ {\n+\t\tp.wsbuf[i] = p.wsbuf[n]\n \t\ti++\n \t}\n-\tp.buffer = p.buffer[0:i]\n+\tp.wsbuf = p.wsbuf[0:i]\n }\n \n \n@@ -734,7 +739,7 @@ func mayCombine(prev token.Token, next byte) (b bool) {\n func (p *printer) print(args ...interface{}) {\n \tfor _, f := range args {\n \t\tnext := p.pos // estimated position of next item\n-\t\tvar data []byte\n+\t\tvar data string\n \t\tvar tok token.Token\n \n \t\tswitch x := f.(type) {\n@@ -748,42 +753,22 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\t// LabeledStmt)\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\ti := len(p.buffer)\n-\t\t\tif i == cap(p.buffer) {\n+\t\t\ti := len(p.wsbuf)\n+\t\t\tif i == cap(p.wsbuf) {\n \t\t\t\t// Whitespace sequences are very short so this should\n \t\t\t\t// never happen. Handle gracefully (but possibly with\n \t\t\t\t// bad comment placement) if it does happen.\n \t\t\t\tp.writeWhitespace(i)\n \t\t\t\ti = 0\n \t\t\t}\n-\t\t\tp.buffer = p.buffer[0 : i+1]\n-\t\t\tp.buffer[i] = x\n+\t\t\tp.wsbuf = p.wsbuf[0 : i+1]\n+\t\t\tp.wsbuf[i] = x\n \t\tcase *ast.Ident:\n-\t\t\tdata = []byte(x.Name)\n+\t\t\tdata = x.Name\n \t\t\ttok = token.IDENT\n \t\tcase *ast.BasicLit:\n-\t\t\t// escape all literals so they pass through unchanged\n-\t\t\t// (note that valid Go programs cannot contain\n-\t\t\t// tabwriter.Escape bytes since they do not appear in\n-\t\t\t// legal UTF-8 sequences)\n-\t\t\tdata = make([]byte, 0, len(x.Value)+2)\n-\t\t\tdata = append(data, tabwriter.Escape)\n-\t\t\tdata = append(data, x.Value...)\n-\t\t\tdata = append(data, tabwriter.Escape)\n+\t\t\tdata = p.escape(x.Value)\n \t\t\ttok = x.Kind\n-\t\t\t// If we have a raw string that spans multiple lines and\n-\t\t\t// the opening quote (`) is on a line preceded only by\n-\t\t\t// indentation, we don't want to write that indentation\n-\t\t\t// because the following lines of the raw string are not\n-\t\t\t// indented. It's easiest to correct the output at the end\n-\t\t\t// via the trimmer (because of the complex handling of\n-\t\t\t// white space).\n-\t\t\t// Mark multi-line raw strings by replacing the opening\n-\t\t\t// quote with esc2 and have the trimmer take care of fixing\n-\t\t\t// it up. (Do this _after_ making a copy of data!)\n-\t\t\tif data[1] == '`' && bytes.IndexByte(data, '\\n') > 0 {\n-\t\t\t\tdata[1] = esc2\n-\t\t\t}\n \t\tcase token.Token:\n \t\t\ts := x.String()\n \t\t\tif mayCombine(p.lastTok, s[0]) {\n@@ -793,13 +778,13 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\t// (except for token.INT followed by a '.' this\n \t\t\t\t// should never happen because it is taken care\n \t\t\t\t// of via binary expression formatting)\n-\t\t\t\tif len(p.buffer) != 0 {\n+\t\t\t\tif len(p.wsbuf) != 0 {\n \t\t\t\t\tp.internalError(\"whitespace buffer not empty\")\n \t\t\t\t}\n-\t\t\t\tp.buffer = p.buffer[0:1]\n-\t\t\t\tp.buffer[0] = ' '\n+\t\t\t\tp.wsbuf = p.wsbuf[0:1]\n+\t\t\t\tp.wsbuf[0] = ' '\n \t\t\t}\n-\t\t\tdata = []byte(s)\n+\t\t\tdata = s\n \t\t\ttok = x\n \t\tcase token.Pos:\n \t\t\tif x.IsValid() {\n@@ -813,7 +798,7 @@ func (p *printer) print(args ...interface{}) {\n \t\tp.lastTok = tok\n \t\tp.pos = next\n \n-\t\tif data != nil {\n+\t\tif data != \"\" {\n \t\t\tdroppedFF := p.flush(next, tok)\n \n \t\t\t// intersperse extra newlines if present in the source\n@@ -848,7 +833,7 @@ func (p *printer) flush(next token.Position, tok token.Token) (droppedFF bool) {\n \t\tdroppedFF = p.intersperseComments(next, tok)\n \t} else {\n \t\t// otherwise, write any leftover whitespace\n-\t\tp.writeWhitespace(len(p.buffer))\n+\t\tp.writeWhitespace(len(p.wsbuf))\n \t}\n \treturn\n }\n@@ -864,26 +849,21 @@ func (p *printer) flush(next token.Position, tok token.Token) (droppedFF bool) {\n // through unchanged.\n //\n type trimmer struct {\n-\toutput  io.Writer\n-\tstate   int\n-\tspace   bytes.Buffer\n-\thasText bool\n+\toutput io.Writer\n+\tstate  int\n+\tspace  bytes.Buffer\n }\n \n \n // trimmer is implemented as a state machine.\n // It can be in one of the following states:\n const (\n \tinSpace  = iota // inside space\n-\tatEscape        // inside space and the last char was an opening tabwriter.Escape\n \tinEscape        // inside text bracketed by tabwriter.Escapes\n \tinText          // inside text\n )\n \n \n-var backquote = []byte{'`'}\n-\n-\n // Design note: It is tempting to eliminate extra blanks occurring in\n //              whitespace in this function as it could simplify some\n //              of the blanks logic in the node printing functions.\n@@ -892,9 +872,8 @@ var backquote = []byte{'`'}\n \n func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \t// invariants:\n-\t// p.state == inSpace, atEscape:\n+\t// p.state == inSpace:\n \t//\tp.space is unwritten\n-\t//\tp.hasText indicates if there is any text on this line\n \t// p.state == inEscape, inText:\n \t//\tdata[m:n] is unwritten\n \tm := 0\n@@ -911,32 +890,20 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \t\t\tcase '\\n', '\\f':\n \t\t\t\tp.space.Reset()                        // discard trailing space\n \t\t\t\t_, err = p.output.Write(newlines[0:1]) // write newline\n-\t\t\t\tp.hasText = false\n \t\t\tcase tabwriter.Escape:\n-\t\t\t\tp.state = atEscape\n+\t\t\t\t_, err = p.output.Write(p.space.Bytes())\n+\t\t\t\tp.state = inEscape\n+\t\t\t\tm = n + 1 // +1: skip tabwriter.Escape\n \t\t\tdefault:\n \t\t\t\t_, err = p.output.Write(p.space.Bytes())\n \t\t\t\tp.state = inText\n \t\t\t\tm = n\n \t\t\t}\n-\t\tcase atEscape:\n-\t\t\t// discard indentation if we have a multi-line raw string\n-\t\t\t// (see printer.print for details)\n-\t\t\tif b != esc2 || p.hasText {\n-\t\t\t\t_, err = p.output.Write(p.space.Bytes())\n-\t\t\t}\n-\t\t\tp.state = inEscape\n-\t\t\tm = n\n-\t\t\tif b == esc2 {\n-\t\t\t\t_, err = p.output.Write(backquote) // convert back\n-\t\t\t\tm++\n-\t\t\t}\n \t\tcase inEscape:\n \t\t\tif b == tabwriter.Escape {\n \t\t\t\t_, err = p.output.Write(data[m:n])\n \t\t\t\tp.state = inSpace\n \t\t\t\tp.space.Reset()\n-\t\t\t\tp.hasText = true\n \t\t\t}\n \t\tcase inText:\n \t\t\tswitch b {\n@@ -945,19 +912,18 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \t\t\t\tp.state = inSpace\n \t\t\t\tp.space.Reset()\n \t\t\t\tp.space.WriteByte(b) // WriteByte returns no errors\n-\t\t\t\tp.hasText = true\n \t\t\tcase '\\n', '\\f':\n \t\t\t\t_, err = p.output.Write(data[m:n])\n \t\t\t\tp.state = inSpace\n \t\t\t\tp.space.Reset()\n \t\t\t\t_, err = p.output.Write(newlines[0:1]) // write newline\n-\t\t\t\tp.hasText = false\n \t\t\tcase tabwriter.Escape:\n \t\t\t\t_, err = p.output.Write(data[m:n])\n-\t\t\t\tp.state = atEscape\n-\t\t\t\tp.space.Reset()\n-\t\t\t\tp.hasText = true\n+\t\t\t\tp.state = inEscape\n+\t\t\t\tm = n + 1 // +1: skip tabwriter.Escape\n \t\t\t}\n+\t\tdefault:\n+\t\t\tpanic(\"unreachable\")\n \t\t}\n \t\tif err != nil {\n \t\t\treturn\n@@ -970,7 +936,6 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \t\t_, err = p.output.Write(data[m:n])\n \t\tp.state = inSpace\n \t\tp.space.Reset()\n-\t\tp.hasText = true\n \t}\n \n \treturn"}, {"sha": "090f92af181cc99f70d8692065a797edc25623af", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -114,7 +114,7 @@ func check(t *testing.T, source, golden string, mode checkMode) {\n \t// start a timer to produce a time-out signal\n \ttc := make(chan int)\n \tgo func() {\n-\t\ttime.Sleep(20e9) // plenty of a safety margin, even for very slow machines\n+\t\ttime.Sleep(10e9) // plenty of a safety margin, even for very slow machines\n \t\ttc <- 0\n \t}()\n \n@@ -156,12 +156,15 @@ var data = []entry{\n \n \n func TestFiles(t *testing.T) {\n-\tfor _, e := range data {\n+\tfor i, e := range data {\n \t\tsource := filepath.Join(dataDir, e.source)\n \t\tgolden := filepath.Join(dataDir, e.golden)\n \t\tcheck(t, source, golden, e.mode)\n \t\t// TODO(gri) check that golden is idempotent\n-\t\t//check(t, golden, golden, e.mode);\n+\t\t//check(t, golden, golden, e.mode)\n+\t\tif testing.Short() && i >= 3 {\n+\t\t\tbreak\n+\t\t}\n \t}\n }\n "}, {"sha": "c1a7e970b45e426b80dd98146215377f9181c5e5", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -253,17 +253,17 @@ bar`\n \tvar _ = ``\n \tvar _ = `foo`\n \tvar _ =\n-\t// the next line should not be indented\n-`foo\n+\t// the next line should remain indented\n+\t`foo\n bar`\n \n \tvar _ =\t// comment\n \t``\n \tvar _ =\t// comment\n \t`foo`\n \tvar _ =\t// comment\n-\t// the next line should not be indented\n-`foo\n+\t// the next line should remain indented\n+\t`foo\n bar`\n \n \tvar _ = /* comment */ ``\n@@ -276,12 +276,12 @@ bar`\n \tvar _ =\t/* comment */\n \t`foo`\n \tvar _ =\t/* comment */\n-\t// the next line should not be indented\n-`foo\n+\t// the next line should remain indented\n+\t`foo\n bar`\n \n \tvar board = []int(\n-`...........\n+\t\t`...........\n ...........\n ....\u25cf\u25cf\u25cf....\n ....\u25cf\u25cf\u25cf....\n@@ -296,8 +296,8 @@ bar`\n \n \tvar state = S{\n \t\t\"foo\",\n-\t\t// the next line should not be indented\n-`...........\n+\t\t// the next line should remain indented\n+\t\t`...........\n ...........\n ....\u25cf\u25cf\u25cf....\n ....\u25cf\u25cf\u25cf....\n@@ -619,3 +619,13 @@ func _() {\n \t\tb.(T).\n \t\tc\n }\n+\n+\n+// Don't introduce extra newlines in strangely formatted expression lists.\n+func f() {\n+\t// os.Open parameters should remain on two lines\n+\tif writer, err = os.Open(outfile, s.O_WRONLY|os.O_CREATE|\n+\t\tos.O_TRUNC,0666); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "b87381198e470c58bfbae4a19a7c981be8573b7d", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -256,7 +256,7 @@ var _ =\n var _ =\n \t`foo`\n var _ =\n-\t// the next line should not be indented\n+\t// the next line should remain indented\n \t`foo\n bar`\n \n@@ -266,7 +266,7 @@ bar`\n \tvar _ = // comment\n \t\t`foo`\n \tvar _ = // comment\n-\t\t// the next line should not be indented\n+\t\t// the next line should remain indented\n \t\t`foo\n bar`\n \n@@ -282,7 +282,7 @@ bar`\n \tvar _ = /* comment */\n \t\t`foo`\n \tvar _ = /* comment */\n-\t\t// the next line should not be indented\n+\t\t// the next line should remain indented\n \t\t`foo\n bar`\n \n@@ -304,7 +304,7 @@ var board = []int(\n \n \tvar state = S{\n \t\t\"foo\",\n-\t\t// the next line should not be indented\n+\t\t// the next line should remain indented\n \t\t`...........\n ...........\n ....\u25cf\u25cf\u25cf....\n@@ -625,3 +625,13 @@ baz()\n \t(T).\n \tc\n }\n+\n+\n+// Don't introduce extra newlines in strangely formatted expression lists.\n+func f() {\n+\t// os.Open parameters should remain on two lines\n+\tif writer, err = os.Open(outfile, s.O_WRONLY|os.O_CREATE|\n+\t\tos.O_TRUNC, 0666); err != nil {\n+\t    log.Fatal(err)\n+\t}\n+}"}, {"sha": "735cd943e69d729fc2eb5f3908b94d4b3f1c7cfa", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -239,7 +239,8 @@ func _() {\n \t_ = `foo\n \t\tbar`\n \t_ = `three spaces before the end of the line starting here:   \n-they must not be removed`\f}\n+they must not be removed`\n+}\n \n \n func _() {\n@@ -252,17 +253,17 @@ bar`\n \tvar _ = ``\n \tvar _ = `foo`\n \tvar _ =\n-\t// the next line should not be indented\n-`foo\n+\t// the next line should remain indented\n+\t`foo\n bar`\n \n \tvar _ =\t// comment\n \t``\n \tvar _ =\t// comment\n \t`foo`\n \tvar _ =\t// comment\n-\t// the next line should not be indented\n-`foo\n+\t// the next line should remain indented\n+\t`foo\n bar`\n \n \tvar _ = /* comment */ ``\n@@ -275,12 +276,12 @@ bar`\n \tvar _ =\t/* comment */\n \t`foo`\n \tvar _ =\t/* comment */\n-\t// the next line should not be indented\n-`foo\n+\t// the next line should remain indented\n+\t`foo\n bar`\n \n \tvar board = []int(\n-`...........\n+\t\t`...........\n ...........\n ....\u25cf\u25cf\u25cf....\n ....\u25cf\u25cf\u25cf....\n@@ -295,8 +296,8 @@ bar`\n \n \tvar state = S{\n \t\t\"foo\",\n-\t\t// the next line should not be indented\n-`...........\n+\t\t// the next line should remain indented\n+\t\t`...........\n ...........\n ....\u25cf\u25cf\u25cf....\n ....\u25cf\u25cf\u25cf....\n@@ -618,3 +619,13 @@ func _() {\n \t\tb.(T).\n \t\tc\n }\n+\n+\n+// Don't introduce extra newlines in strangely formatted expression lists.\n+func f() {\n+\t// os.Open parameters should remain on two lines\n+\tif writer, err = os.Open(outfile, s.O_WRONLY|os.O_CREATE|\n+\t\tos.O_TRUNC,0666); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "2f949ad25689660b7369a3d6e252809286f9340e", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -538,14 +538,12 @@ func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 int, tok2, tok3 token.Toke\n }\n \n \n-var newline = []byte{'\\n'}\n-\n-// Scan scans the next token and returns the token position pos,\n-// the token tok, and the literal text lit corresponding to the\n+// Scan scans the next token and returns the token position,\n+// the token, and the literal string corresponding to the\n // token. The source end is indicated by token.EOF.\n //\n // If the returned token is token.SEMICOLON, the corresponding\n-// literal value is \";\" if the semicolon was present in the source,\n+// literal string is \";\" if the semicolon was present in the source,\n // and \"\\n\" if the semicolon was inserted because of a newline or\n // at EOF.\n //\n@@ -560,7 +558,7 @@ var newline = []byte{'\\n'}\n // set with Init. Token positions are relative to that file\n // and thus relative to the file set.\n //\n-func (S *Scanner) Scan() (token.Pos, token.Token, []byte) {\n+func (S *Scanner) Scan() (token.Pos, token.Token, string) {\n scanAgain:\n \tS.skipWhitespace()\n \n@@ -586,15 +584,15 @@ scanAgain:\n \t\tcase -1:\n \t\t\tif S.insertSemi {\n \t\t\t\tS.insertSemi = false // EOF consumed\n-\t\t\t\treturn S.file.Pos(offs), token.SEMICOLON, newline\n+\t\t\t\treturn S.file.Pos(offs), token.SEMICOLON, \"\\n\"\n \t\t\t}\n \t\t\ttok = token.EOF\n \t\tcase '\\n':\n \t\t\t// we only reach here if S.insertSemi was\n \t\t\t// set in the first place and exited early\n \t\t\t// from S.skipWhitespace()\n \t\t\tS.insertSemi = false // newline consumed\n-\t\t\treturn S.file.Pos(offs), token.SEMICOLON, newline\n+\t\t\treturn S.file.Pos(offs), token.SEMICOLON, \"\\n\"\n \t\tcase '\"':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.STRING\n@@ -662,7 +660,7 @@ scanAgain:\n \t\t\t\t\tS.offset = offs\n \t\t\t\t\tS.rdOffset = offs + 1\n \t\t\t\t\tS.insertSemi = false // newline consumed\n-\t\t\t\t\treturn S.file.Pos(offs), token.SEMICOLON, newline\n+\t\t\t\t\treturn S.file.Pos(offs), token.SEMICOLON, \"\\n\"\n \t\t\t\t}\n \t\t\t\tS.scanComment()\n \t\t\t\tif S.mode&ScanComments == 0 {\n@@ -711,5 +709,9 @@ scanAgain:\n \tif S.mode&InsertSemis != 0 {\n \t\tS.insertSemi = insertSemi\n \t}\n-\treturn S.file.Pos(offs), tok, S.src[offs:S.offset]\n+\n+\t// TODO(gri): The scanner API should change such that the literal string\n+\t//            is only valid if an actual literal was scanned. This will\n+\t//            permit a more efficient implementation.\n+\treturn S.file.Pos(offs), tok, string(S.src[offs:S.offset])\n }"}, {"sha": "8afb00ee5bc6dc57f9e7393919a809845619ddc4", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -234,12 +234,11 @@ func TestScan(t *testing.T) {\n \tindex := 0\n \tepos := token.Position{\"\", 0, 1, 1} // expected position\n \tfor {\n-\t\tpos, tok, litb := s.Scan()\n+\t\tpos, tok, lit := s.Scan()\n \t\te := elt{token.EOF, \"\", special}\n \t\tif index < len(tokens) {\n \t\t\te = tokens[index]\n \t\t}\n-\t\tlit := string(litb)\n \t\tif tok == token.EOF {\n \t\t\tlit = \"<EOF>\"\n \t\t\tepos.Line = src_linecount\n@@ -257,7 +256,7 @@ func TestScan(t *testing.T) {\n \t\t}\n \t\tepos.Offset += len(lit) + len(whitespace)\n \t\tepos.Line += newlineCount(lit) + whitespace_linecount\n-\t\tif tok == token.COMMENT && litb[1] == '/' {\n+\t\tif tok == token.COMMENT && lit[1] == '/' {\n \t\t\t// correct for unaccounted '/n' in //-style comment\n \t\t\tepos.Offset++\n \t\t\tepos.Line++\n@@ -292,7 +291,7 @@ func checkSemi(t *testing.T, line string, mode uint) {\n \t\t\tsemiPos.Column++\n \t\t\tpos, tok, lit = S.Scan()\n \t\t\tif tok == token.SEMICOLON {\n-\t\t\t\tif string(lit) != semiLit {\n+\t\t\t\tif lit != semiLit {\n \t\t\t\t\tt.Errorf(`bad literal for %q: got %q, expected %q`, line, lit, semiLit)\n \t\t\t\t}\n \t\t\t\tcheckPos(t, line, pos, semiPos)\n@@ -493,7 +492,7 @@ func TestLineComments(t *testing.T) {\n \tfor _, s := range segments {\n \t\tp, _, lit := S.Scan()\n \t\tpos := file.Position(p)\n-\t\tcheckPos(t, string(lit), p, token.Position{s.filename, pos.Offset, s.line, pos.Column})\n+\t\tcheckPos(t, lit, p, token.Position{s.filename, pos.Offset, s.line, pos.Column})\n \t}\n \n \tif S.ErrorCount != 0 {\n@@ -547,10 +546,10 @@ func TestIllegalChars(t *testing.T) {\n \tfor offs, ch := range src {\n \t\tpos, tok, lit := s.Scan()\n \t\tif poffs := file.Offset(pos); poffs != offs {\n-\t\t\tt.Errorf(\"bad position for %s: got %d, expected %d\", string(lit), poffs, offs)\n+\t\t\tt.Errorf(\"bad position for %s: got %d, expected %d\", lit, poffs, offs)\n \t\t}\n-\t\tif tok == token.ILLEGAL && string(lit) != string(ch) {\n-\t\t\tt.Errorf(\"bad token: got %s, expected %s\", string(lit), string(ch))\n+\t\tif tok == token.ILLEGAL && lit != string(ch) {\n+\t\t\tt.Errorf(\"bad token: got %s, expected %s\", lit, string(ch))\n \t\t}\n \t}\n "}, {"sha": "a5f21df168e7db04d324e1649517ca4388bee4b8", "filename": "libgo/go/go/token/token.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -126,10 +126,7 @@ const (\n )\n \n \n-// At the moment we have no array literal syntax that lets us describe\n-// the index for each element - use a map for now to make sure they are\n-// in sync.\n-var tokens = map[Token]string{\n+var tokens = [...]string{\n \tILLEGAL: \"ILLEGAL\",\n \n \tEOF:     \"EOF\",\n@@ -237,10 +234,14 @@ var tokens = map[Token]string{\n // constant name (e.g. for the token IDENT, the string is \"IDENT\").\n //\n func (tok Token) String() string {\n-\tif str, exists := tokens[tok]; exists {\n-\t\treturn str\n+\ts := \"\"\n+\tif 0 <= tok && tok < Token(len(tokens)) {\n+\t\ts = tokens[tok]\n \t}\n-\treturn \"token(\" + strconv.Itoa(int(tok)) + \")\"\n+\tif s == \"\" {\n+\t\ts = \"token(\" + strconv.Itoa(int(tok)) + \")\"\n+\t}\n+\treturn s\n }\n \n "}, {"sha": "a4bee6e6962c9cad49624ee46cfab68f6da183be", "filename": "libgo/go/go/typechecker/scope.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -33,7 +33,7 @@ func (tc *typechecker) declInScope(scope *ast.Scope, kind ast.ObjKind, name *ast\n \t//obj.N = n\n \tname.Obj = obj\n \tif name.Name != \"_\" {\n-\t\tif alt := scope.Insert(obj); alt != obj {\n+\t\tif alt := scope.Insert(obj); alt != nil {\n \t\t\ttc.Errorf(name.Pos(), \"%s already declared at %s\", name.Name, tc.fset.Position(alt.Pos()).String())\n \t\t}\n \t}"}, {"sha": "b5e695d973ad4e0fef4d26e6816f919c37a63242", "filename": "libgo/go/go/typechecker/typechecker.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -53,7 +53,7 @@ func CheckPackage(fset *token.FileSet, pkg *ast.Package, importer Importer) os.E\n //\n func CheckFile(fset *token.FileSet, file *ast.File, importer Importer) os.Error {\n \t// create a single-file dummy package\n-\tpkg := &ast.Package{file.Name.Name, nil, map[string]*ast.File{fset.Position(file.Name.NamePos).Filename: file}}\n+\tpkg := &ast.Package{file.Name.Name, nil, nil, map[string]*ast.File{fset.Position(file.Name.NamePos).Filename: file}}\n \treturn CheckPackage(fset, pkg, importer)\n }\n \n@@ -327,8 +327,8 @@ func (tc *typechecker) checkBlock(body []ast.Stmt, ftype *Type) {\n \tif ftype != nil {\n \t\tfor _, par := range ftype.Params.Objects {\n \t\t\tif par.Name != \"_\" {\n-\t\t\t\tobj := tc.topScope.Insert(par)\n-\t\t\t\tassert(obj == par) // ftype has no double declarations\n+\t\t\t\talt := tc.topScope.Insert(par)\n+\t\t\t\tassert(alt == nil) // ftype has no double declarations\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "d16e06921801246768bc75f238d9ca03fa478319", "filename": "libgo/go/go/typechecker/typechecker_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -78,7 +78,7 @@ func expectedErrors(t *testing.T, pkg *ast.Package) (list scanner.ErrorList) {\n \t\t\tcase token.EOF:\n \t\t\t\tbreak loop\n \t\t\tcase token.COMMENT:\n-\t\t\t\ts := errRx.FindSubmatch(lit)\n+\t\t\t\ts := errRx.FindStringSubmatch(lit)\n \t\t\t\tif len(s) == 2 {\n \t\t\t\t\tlist = append(list, &scanner.Error{fset.Position(prev), string(s[1])})\n \t\t\t\t}"}, {"sha": "abc8bbbd49cc21ad2f77790b64eec1f6505f6985", "filename": "libgo/go/go/typechecker/universe.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -14,7 +14,7 @@ var Universe *ast.Scope\n \n func def(obj *ast.Object) {\n \talt := Universe.Insert(obj)\n-\tif alt != obj {\n+\tif alt != nil {\n \t\tpanic(\"object declared twice\")\n \t}\n }"}, {"sha": "305d41980a54ceb46d0c84912ade040aefe691e2", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -407,7 +407,7 @@ func (s *structType) string() string { return s.safeString(make(map[typeId]bool)\n func newStructType(name string) *structType {\n \ts := &structType{CommonType{Name: name}, nil}\n \t// For historical reasons we set the id here rather than init.\n-\t// Se the comment in newTypeObject for details.\n+\t// See the comment in newTypeObject for details.\n \tsetTypeId(s)\n \treturn s\n }\n@@ -545,7 +545,7 @@ func getBaseType(name string, rt reflect.Type) (gobType, os.Error) {\n // getType returns the Gob type describing the given reflect.Type.\n // Should be called only when handling GobEncoders/Decoders,\n // which may be pointers.  All other types are handled through the\n-//  base type, never a pointer.\n+// base type, never a pointer.\n // typeLock must be held.\n func getType(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.Error) {\n \ttyp, present := types[rt]\n@@ -561,7 +561,7 @@ func getType(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.Error)\n \n func checkId(want, got typeId) {\n \tif want != got {\n-\t\tfmt.Fprintf(os.Stderr, \"checkId: %d should be %d\\n\", int(want), int(got))\n+\t\tfmt.Fprintf(os.Stderr, \"checkId: %d should be %d\\n\", int(got), int(want))\n \t\tpanic(\"bootstrap type wrong id: \" + got.name() + \" \" + got.string() + \" not \" + want.string())\n \t}\n }"}, {"sha": "8b5c4770c49b2fab5927eea67ed79b0f283640d8", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -154,7 +154,10 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t// handle Content-Range header.\n \t// TODO(adg): handle multiple ranges\n \tranges, err := parseRange(r.Header.Get(\"Range\"), size)\n-\tif err != nil || len(ranges) > 1 {\n+\tif err == nil && len(ranges) > 1 {\n+\t\terr = os.ErrorString(\"multiple ranges not supported\")\n+\t}\n+\tif err != nil {\n \t\tError(w, err.String(), StatusRequestedRangeNotSatisfiable)\n \t\treturn\n \t}"}, {"sha": "bc79e218320cb9b0c4941866cc9fa01b85fe8ecb", "filename": "libgo/go/http/pprof/pprof.go", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -18,6 +18,10 @@\n //\n //\tpprof http://localhost:6060/debug/pprof/heap\n //\n+// Or to look at a 30-second CPU profile:\n+//\n+//\tpprof http://localhost:6060/debug/pprof/profile\n+//\n package pprof\n \n import (\n@@ -29,10 +33,12 @@ import (\n \t\"runtime/pprof\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"time\"\n )\n \n func init() {\n \thttp.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(Cmdline))\n+\thttp.Handle(\"/debug/pprof/profile\", http.HandlerFunc(Profile))\n \thttp.Handle(\"/debug/pprof/heap\", http.HandlerFunc(Heap))\n \thttp.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(Symbol))\n }\n@@ -41,22 +47,46 @@ func init() {\n // command line, with arguments separated by NUL bytes.\n // The package initialization registers it as /debug/pprof/cmdline.\n func Cmdline(w http.ResponseWriter, r *http.Request) {\n-\tw.Header().Set(\"content-type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \tfmt.Fprintf(w, strings.Join(os.Args, \"\\x00\"))\n }\n \n // Heap responds with the pprof-formatted heap profile.\n // The package initialization registers it as /debug/pprof/heap.\n func Heap(w http.ResponseWriter, r *http.Request) {\n-\tw.Header().Set(\"content-type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \tpprof.WriteHeapProfile(w)\n }\n \n+// Profile responds with the pprof-formatted cpu profile.\n+// The package initialization registers it as /debug/pprof/profile.\n+func Profile(w http.ResponseWriter, r *http.Request) {\n+\tsec, _ := strconv.Atoi64(r.FormValue(\"seconds\"))\n+\tif sec == 0 {\n+\t\tsec = 30\n+\t}\n+\n+\t// Set Content Type assuming StartCPUProfile will work,\n+\t// because if it does it starts writing.\n+\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n+\tif err := pprof.StartCPUProfile(w); err != nil {\n+\t\t// StartCPUProfile failed, so no writes yet.\n+\t\t// Can change header back to text content\n+\t\t// and send error code.\n+\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\t\tw.WriteHeader(http.StatusInternalServerError)\n+\t\tfmt.Fprintf(w, \"Could not enable CPU profiling: %s\\n\", err)\n+\t\treturn\n+\t}\n+\ttime.Sleep(sec * 1e9)\n+\tpprof.StopCPUProfile()\n+}\n+\n // Symbol looks up the program counters listed in the request,\n // responding with a table mapping program counters to function names.\n // The package initialization registers it as /debug/pprof/symbol.\n func Symbol(w http.ResponseWriter, r *http.Request) {\n-\tw.Header().Set(\"content-type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \n \t// We don't know how many symbols we have, but we\n \t// do have symbol information.  Pprof only cares whether"}, {"sha": "b0e26e533596b423d0f7ffb61fa2ef6970c62967", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -175,7 +175,7 @@ func TestHostHandlers(t *testing.T) {\n \tts := httptest.NewServer(nil)\n \tdefer ts.Close()\n \n-\tconn, err := net.Dial(\"tcp\", \"\", ts.Listener.Addr().String())\n+\tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -265,7 +265,7 @@ func TestServerTimeouts(t *testing.T) {\n \n \t// Slow client that should timeout.\n \tt1 := time.Nanoseconds()\n-\tconn, err := net.Dial(\"tcp\", \"\", fmt.Sprintf(\"localhost:%d\", addr.Port))\n+\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"localhost:%d\", addr.Port))\n \tif err != nil {\n \t\tt.Fatalf(\"Dial: %v\", err)\n \t}\n@@ -348,7 +348,7 @@ func TestIdentityResponse(t *testing.T) {\n \t}\n \t// Verify that the connection is closed when the declared Content-Length\n \t// is larger than what the handler wrote.\n-\tconn, err := net.Dial(\"tcp\", \"\", ts.Listener.Addr().String())\n+\tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n \tif err != nil {\n \t\tt.Fatalf(\"error dialing: %v\", err)\n \t}\n@@ -377,7 +377,7 @@ func TestServeHTTP10Close(t *testing.T) {\n \t}))\n \tdefer s.Close()\n \n-\tconn, err := net.Dial(\"tcp\", \"\", s.Listener.Addr().String())\n+\tconn, err := net.Dial(\"tcp\", s.Listener.Addr().String())\n \tif err != nil {\n \t\tt.Fatal(\"dial error:\", err)\n \t}"}, {"sha": "ed7843bc713c0f6d0ca4fb35af614e0185283bca", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -195,7 +195,7 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n \t\treturn pc, nil\n \t}\n \n-\tconn, err := net.Dial(\"tcp\", \"\", cm.addr())\n+\tconn, err := net.Dial(\"tcp\", cm.addr())\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "0b2058d51a2b378a79e8a1f7d36e633b66a1f0e9", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -34,6 +34,12 @@ var filenames = []string{\n \t\"basn6a16\",\n }\n \n+var filenamesShort = []string{\n+\t\"basn0g01\",\n+\t\"basn0g04-31\",\n+\t\"basn6a16\",\n+}\n+\n func readPng(filename string) (image.Image, os.Error) {\n \tf, err := os.Open(filename, os.O_RDONLY, 0444)\n \tif err != nil {\n@@ -157,7 +163,11 @@ func sng(w io.WriteCloser, filename string, png image.Image) {\n }\n \n func TestReader(t *testing.T) {\n-\tfor _, fn := range filenames {\n+\tnames := filenames\n+\tif testing.Short() {\n+\t\tnames = filenamesShort\n+\t}\n+\tfor _, fn := range names {\n \t\t// Read the .png file.\n \t\timg, err := readPng(\"testdata/pngsuite/\" + fn + \".png\")\n \t\tif err != nil {"}, {"sha": "4d9929f314fb966ef8516878b1387ee51bc24899", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -32,7 +32,11 @@ func diff(m0, m1 image.Image) os.Error {\n \n func TestWriter(t *testing.T) {\n \t// The filenames variable is declared in reader_test.go.\n-\tfor _, fn := range filenames {\n+\tnames := filenames\n+\tif testing.Short() {\n+\t\tnames = filenamesShort\n+\t}\n+\tfor _, fn := range names {\n \t\tqfn := \"testdata/pngsuite/\" + fn + \".png\"\n \t\t// Read the image.\n \t\tm0, err := readPng(qfn)"}, {"sha": "aad8b635f2bbdb471d1ef5fda35c6a031c130efb", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -157,6 +157,7 @@ func TestUnmarshal(t *testing.T) {\n }\n \n func TestUnmarshalMarshal(t *testing.T) {\n+\tinitBig()\n \tvar v interface{}\n \tif err := Unmarshal(jsonBig, &v); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %v\", err)"}, {"sha": "0d4de3246dd0fa4000df0b67acff73c4c42db420", "filename": "libgo/go/json/scanner_test.go", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -85,6 +85,7 @@ func TestIndent(t *testing.T) {\n // Tests of a large random structure.\n \n func TestCompactBig(t *testing.T) {\n+\tinitBig()\n \tvar buf bytes.Buffer\n \tif err := Compact(&buf, jsonBig); err != nil {\n \t\tt.Fatalf(\"Compact: %v\", err)\n@@ -98,6 +99,7 @@ func TestCompactBig(t *testing.T) {\n }\n \n func TestIndentBig(t *testing.T) {\n+\tinitBig()\n \tvar buf bytes.Buffer\n \tif err := Indent(&buf, jsonBig, \"\", \"\\t\"); err != nil {\n \t\tt.Fatalf(\"Indent1: %v\", err)\n@@ -135,6 +137,7 @@ func TestIndentBig(t *testing.T) {\n }\n \n func TestNextValueBig(t *testing.T) {\n+\tinitBig()\n \tvar scan scanner\n \titem, rest, err := nextValue(jsonBig, &scan)\n \tif err != nil {\n@@ -160,6 +163,7 @@ func TestNextValueBig(t *testing.T) {\n }\n \n func BenchmarkSkipValue(b *testing.B) {\n+\tinitBig()\n \tvar scan scanner\n \tfor i := 0; i < b.N; i++ {\n \t\tnextValue(jsonBig, &scan)\n@@ -191,12 +195,23 @@ func trim(b []byte) []byte {\n \n var jsonBig []byte\n \n-func init() {\n-\tb, err := Marshal(genValue(10000))\n-\tif err != nil {\n-\t\tpanic(err)\n+const (\n+\tbig   = 10000\n+\tsmall = 100\n+)\n+\n+func initBig() {\n+\tn := big\n+\tif testing.Short() {\n+\t\tn = small\n+\t}\n+\tif len(jsonBig) != n {\n+\t\tb, err := Marshal(genValue(n))\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\tjsonBig = b\n \t}\n-\tjsonBig = b\n }\n \n func genValue(n int) interface{} {"}, {"sha": "e28f6622e93f61fbcc48b99d6841a2349c33c469", "filename": "libgo/go/net/cgo_stub.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fcgo_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_stub.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Stub cgo routines for systems that do not use cgo to do network lookups.\n+\n+package net\n+\n+import \"os\"\n+\n+func cgoLookupHost(name string) (addrs []string, err os.Error, completed bool) {\n+\treturn nil, nil, false\n+}\n+\n+func cgoLookupPort(network, service string) (port int, err os.Error, completed bool) {\n+\treturn 0, nil, false\n+}\n+\n+func cgoLookupIP(name string) (addrs []IP, err os.Error, completed bool) {\n+\treturn nil, nil, false\n+}"}, {"sha": "66cb09b19bbb6b0266df22a9683d28aa13d39348", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -6,89 +6,64 @@ package net\n \n import \"os\"\n \n-// Dial connects to the remote address raddr on the network net.\n-// If the string laddr is not empty, it is used as the local address\n-// for the connection.\n+// Dial connects to the address addr on the network net.\n //\n // Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n // \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n // (IPv4-only), \"ip6\" (IPv6-only), \"unix\" and \"unixgram\".\n //\n // For IP networks, addresses have the form host:port.  If host is\n // a literal IPv6 address, it must be enclosed in square brackets.\n+// The functions JoinHostPort and SplitHostPort manipulate \n+// addresses in this form.\n //\n // Examples:\n-//\tDial(\"tcp\", \"\", \"12.34.56.78:80\")\n-//\tDial(\"tcp\", \"\", \"google.com:80\")\n-//\tDial(\"tcp\", \"\", \"[de:ad:be:ef::ca:fe]:80\")\n-//\tDial(\"tcp\", \"127.0.0.1:123\", \"127.0.0.1:88\")\n+//\tDial(\"tcp\", \"12.34.56.78:80\")\n+//\tDial(\"tcp\", \"google.com:80\")\n+//\tDial(\"tcp\", \"[de:ad:be:ef::ca:fe]:80\")\n //\n-func Dial(net, laddr, raddr string) (c Conn, err os.Error) {\n+func Dial(net, addr string) (c Conn, err os.Error) {\n+\traddr := addr\n+\tif raddr == \"\" {\n+\t\treturn nil, &OpError{\"dial\", net, nil, errMissingAddress}\n+\t}\n \tswitch net {\n \tcase \"tcp\", \"tcp4\", \"tcp6\":\n-\t\tvar la, ra *TCPAddr\n-\t\tif laddr != \"\" {\n-\t\t\tif la, err = ResolveTCPAddr(laddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n-\t\t}\n-\t\tif raddr != \"\" {\n-\t\t\tif ra, err = ResolveTCPAddr(raddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n+\t\tvar ra *TCPAddr\n+\t\tif ra, err = ResolveTCPAddr(raddr); err != nil {\n+\t\t\tgoto Error\n \t\t}\n-\t\tc, err := DialTCP(net, la, ra)\n+\t\tc, err := DialTCP(net, nil, ra)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn c, nil\n \tcase \"udp\", \"udp4\", \"udp6\":\n-\t\tvar la, ra *UDPAddr\n-\t\tif laddr != \"\" {\n-\t\t\tif la, err = ResolveUDPAddr(laddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n-\t\t}\n-\t\tif raddr != \"\" {\n-\t\t\tif ra, err = ResolveUDPAddr(raddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n+\t\tvar ra *UDPAddr\n+\t\tif ra, err = ResolveUDPAddr(raddr); err != nil {\n+\t\t\tgoto Error\n \t\t}\n-\t\tc, err := DialUDP(net, la, ra)\n+\t\tc, err := DialUDP(net, nil, ra)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn c, nil\n \tcase \"unix\", \"unixgram\", \"unixpacket\":\n-\t\tvar la, ra *UnixAddr\n-\t\tif raddr != \"\" {\n-\t\t\tif ra, err = ResolveUnixAddr(net, raddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n-\t\t}\n-\t\tif laddr != \"\" {\n-\t\t\tif la, err = ResolveUnixAddr(net, laddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n+\t\tvar ra *UnixAddr\n+\t\tif ra, err = ResolveUnixAddr(net, raddr); err != nil {\n+\t\t\tgoto Error\n \t\t}\n-\t\tc, err = DialUnix(net, la, ra)\n+\t\tc, err = DialUnix(net, nil, ra)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn c, nil\n \tcase \"ip\", \"ip4\", \"ip6\":\n-\t\tvar la, ra *IPAddr\n-\t\tif laddr != \"\" {\n-\t\t\tif la, err = ResolveIPAddr(laddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n-\t\t}\n-\t\tif raddr != \"\" {\n-\t\t\tif ra, err = ResolveIPAddr(raddr); err != nil {\n-\t\t\t\tgoto Error\n-\t\t\t}\n+\t\tvar ra *IPAddr\n+\t\tif ra, err = ResolveIPAddr(raddr); err != nil {\n+\t\t\tgoto Error\n \t\t}\n-\t\tc, err := DialIP(net, la, ra)\n+\t\tc, err := DialIP(net, nil, ra)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}"}, {"sha": "9a9c02ebd717f874151c98dad145fe81832458af", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -32,7 +32,7 @@ func fetchGoogle(t *testing.T, fd Conn, network, addr string) {\n }\n \n func doDial(t *testing.T, network, addr string) {\n-\tfd, err := Dial(network, \"\", addr)\n+\tfd, err := Dial(network, addr)\n \tif err != nil {\n \t\tt.Errorf(\"Dial(%q, %q, %q) = _, %v\", network, \"\", addr, err)\n \t\treturn\n@@ -55,6 +55,13 @@ var googleaddrs = []string{\n \t\"[2001:4860:0:2001::68]:80\", // ipv6.google.com; removed if ipv6 flag not set\n }\n \n+func TestLookupCNAME(t *testing.T) {\n+\tcname, err := LookupCNAME(\"www.google.com\")\n+\tif cname != \"www.l.google.com.\" || err != nil {\n+\t\tt.Errorf(`LookupCNAME(\"www.google.com.\") = %q, %v, want \"www.l.google.com.\", nil`, cname, err)\n+\t}\n+}\n+\n func TestDialGoogle(t *testing.T) {\n \t// If no ipv6 tunnel, don't try the last address.\n \tif !*ipv6 {\n@@ -64,14 +71,14 @@ func TestDialGoogle(t *testing.T) {\n \t// Insert an actual IP address for google.com\n \t// into the table.\n \n-\t_, addrs, err := LookupHost(\"www.google.com\")\n+\taddrs, err := LookupIP(\"www.google.com\")\n \tif err != nil {\n \t\tt.Fatalf(\"lookup www.google.com: %v\", err)\n \t}\n \tif len(addrs) == 0 {\n \t\tt.Fatalf(\"no addresses for www.google.com\")\n \t}\n-\tip := ParseIP(addrs[0]).To4()\n+\tip := addrs[0].To4()\n \n \tfor i, s := range googleaddrs {\n \t\tif strings.Contains(s, \"%\") {"}, {"sha": "32cea6125eb05276a366f74ed6959a4bc03aa6e5", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 71, "deletions": 9, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -159,7 +159,7 @@ func tryOneName(cfg *dnsConfig, name string, qtype uint16) (cname string, addrs\n \t\t// all the cfg.servers[i] are IP addresses, which\n \t\t// Dial will use without a DNS lookup.\n \t\tserver := cfg.servers[i] + \":53\"\n-\t\tc, cerr := Dial(\"udp\", \"\", server)\n+\t\tc, cerr := Dial(\"udp\", server)\n \t\tif cerr != nil {\n \t\t\terr = cerr\n \t\t\tcontinue\n@@ -178,12 +178,23 @@ func tryOneName(cfg *dnsConfig, name string, qtype uint16) (cname string, addrs\n \treturn\n }\n \n-func convertRR_A(records []dnsRR) []string {\n-\taddrs := make([]string, len(records))\n+func convertRR_A(records []dnsRR) []IP {\n+\taddrs := make([]IP, len(records))\n \tfor i := 0; i < len(records); i++ {\n \t\trr := records[i]\n \t\ta := rr.(*dnsRR_A).A\n-\t\taddrs[i] = IPv4(byte(a>>24), byte(a>>16), byte(a>>8), byte(a)).String()\n+\t\taddrs[i] = IPv4(byte(a>>24), byte(a>>16), byte(a>>8), byte(a))\n+\t}\n+\treturn addrs\n+}\n+\n+func convertRR_AAAA(records []dnsRR) []IP {\n+\taddrs := make([]IP, len(records))\n+\tfor i := 0; i < len(records); i++ {\n+\t\trr := records[i]\n+\t\ta := make(IP, 16)\n+\t\tcopy(a, rr.(*dnsRR_AAAA).AAAA[:])\n+\t\taddrs[i] = a\n \t}\n \treturn addrs\n }\n@@ -294,10 +305,8 @@ func lookup(name string, qtype uint16) (cname string, addrs []dnsRR, err os.Erro\n \treturn\n }\n \n-// LookupHost looks for name using the local hosts file and DNS resolver.\n-// It returns the canonical name for the host and an array of that\n-// host's addresses.\n-func LookupHost(name string) (cname string, addrs []string, err os.Error) {\n+// goLookupHost is the native Go implementation of LookupHost.\n+func goLookupHost(name string) (addrs []string, err os.Error) {\n \tonceLoadConfig.Do(loadConfig)\n \tif dnserr != nil || cfg == nil {\n \t\terr = dnserr\n@@ -306,18 +315,69 @@ func LookupHost(name string) (cname string, addrs []string, err os.Error) {\n \t// Use entries from /etc/hosts if they match.\n \taddrs = lookupStaticHost(name)\n \tif len(addrs) > 0 {\n-\t\tcname = name\n+\t\treturn\n+\t}\n+\tips, err := goLookupIP(name)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\taddrs = make([]string, 0, len(ips))\n+\tfor _, ip := range ips {\n+\t\taddrs = append(addrs, ip.String())\n+\t}\n+\treturn\n+}\n+\n+// goLookupIP is the native Go implementation of LookupIP.\n+func goLookupIP(name string) (addrs []IP, err os.Error) {\n+\tonceLoadConfig.Do(loadConfig)\n+\tif dnserr != nil || cfg == nil {\n+\t\terr = dnserr\n \t\treturn\n \t}\n \tvar records []dnsRR\n+\tvar cname string\n \tcname, records, err = lookup(name, dnsTypeA)\n \tif err != nil {\n \t\treturn\n \t}\n \taddrs = convertRR_A(records)\n+\tif cname != \"\" {\n+\t\tname = cname\n+\t}\n+\t_, records, err = lookup(name, dnsTypeAAAA)\n+\tif err != nil && len(addrs) > 0 {\n+\t\t// Ignore error because A lookup succeeded.\n+\t\terr = nil\n+\t}\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\taddrs = append(addrs, convertRR_AAAA(records)...)\n+\treturn\n+}\n+\n+// LookupCNAME returns the canonical DNS host for the given name.\n+// Callers that do not care about the canonical name can call\n+// LookupHost or LookupIP directly; both take care of resolving\n+// the canonical name as part of the lookup.\n+func LookupCNAME(name string) (cname string, err os.Error) {\n+\tonceLoadConfig.Do(loadConfig)\n+\tif dnserr != nil || cfg == nil {\n+\t\terr = dnserr\n+\t\treturn\n+\t}\n+\t_, rr, err := lookup(name, dnsTypeCNAME)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif len(rr) >= 0 {\n+\t\tcname = rr[0].(*dnsRR_CNAME).Cname\n+\t}\n \treturn\n }\n \n+// An SRV represents a single DNS SRV record.\n type SRV struct {\n \tTarget   string\n \tPort     uint16\n@@ -344,11 +404,13 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err os.\n \treturn\n }\n \n+// An MX represents a single DNS MX record.\n type MX struct {\n \tHost string\n \tPref uint16\n }\n \n+// LookupMX returns the DNS MX records associated with name.\n func LookupMX(name string) (entries []*MX, err os.Error) {\n \tvar records []dnsRR\n \t_, records, err = lookup(name, dnsTypeMX)"}, {"sha": "5209c1a06a542a9ecb95caf0e0efd697a89cfd0c", "filename": "libgo/go/net/dnsmsg.go", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -50,6 +50,7 @@ const (\n \tdnsTypeMINFO = 14\n \tdnsTypeMX    = 15\n \tdnsTypeTXT   = 16\n+\tdnsTypeAAAA  = 28\n \tdnsTypeSRV   = 33\n \n \t// valid dnsQuestion.qtype only\n@@ -244,8 +245,18 @@ type dnsRR_A struct {\n \tA   uint32 \"ipv4\"\n }\n \n-func (rr *dnsRR_A) Header() *dnsRR_Header { return &rr.Hdr }\n+func (rr *dnsRR_A) Header() *dnsRR_Header {\n+\treturn &rr.Hdr\n+}\n+\n+type dnsRR_AAAA struct {\n+\tHdr  dnsRR_Header\n+\tAAAA [16]byte \"ipv6\"\n+}\n \n+func (rr *dnsRR_AAAA) Header() *dnsRR_Header {\n+\treturn &rr.Hdr\n+}\n \n // Packing and unpacking.\n //\n@@ -270,6 +281,7 @@ var rr_mk = map[int]func() dnsRR{\n \tdnsTypeTXT:   func() dnsRR { return new(dnsRR_TXT) },\n \tdnsTypeSRV:   func() dnsRR { return new(dnsRR_SRV) },\n \tdnsTypeA:     func() dnsRR { return new(dnsRR_A) },\n+\tdnsTypeAAAA:  func() dnsRR { return new(dnsRR_AAAA) },\n }\n \n // Pack a domain name s into msg[off:].\n@@ -377,7 +389,7 @@ Loop:\n \n // TODO(rsc): Move into generic library?\n // Pack a reflect.StructValue into msg.  Struct members can only be uint16, uint32, string,\n-// and other (often anonymous) structs.\n+// [n]byte, and other (often anonymous) structs.\n func packStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int, ok bool) {\n \tfor i := 0; i < val.NumField(); i++ {\n \t\tf := val.Type().(*reflect.StructType).Field(i)\n@@ -410,6 +422,16 @@ func packStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int, o\n \t\t\t\tmsg[off+3] = byte(i)\n \t\t\t\toff += 4\n \t\t\t}\n+\t\tcase *reflect.ArrayValue:\n+\t\t\tif fv.Type().(*reflect.ArrayType).Elem().Kind() != reflect.Uint8 {\n+\t\t\t\tgoto BadType\n+\t\t\t}\n+\t\t\tn := fv.Len()\n+\t\t\tif off+n > len(msg) {\n+\t\t\t\treturn len(msg), false\n+\t\t\t}\n+\t\t\treflect.Copy(reflect.NewValue(msg[off:off+n]).(*reflect.SliceValue), fv)\n+\t\t\toff += n\n \t\tcase *reflect.StringValue:\n \t\t\t// There are multiple string encodings.\n \t\t\t// The tag distinguishes ordinary strings from domain names.\n@@ -478,6 +500,16 @@ func unpackStructValue(val *reflect.StructValue, msg []byte, off int) (off1 int,\n \t\t\t\tfv.Set(uint64(i))\n \t\t\t\toff += 4\n \t\t\t}\n+\t\tcase *reflect.ArrayValue:\n+\t\t\tif fv.Type().(*reflect.ArrayType).Elem().Kind() != reflect.Uint8 {\n+\t\t\t\tgoto BadType\n+\t\t\t}\n+\t\t\tn := fv.Len()\n+\t\t\tif off+n > len(msg) {\n+\t\t\t\treturn len(msg), false\n+\t\t\t}\n+\t\t\treflect.Copy(fv, reflect.NewValue(msg[off:off+n]).(*reflect.SliceValue))\n+\t\t\toff += n\n \t\tcase *reflect.StringValue:\n \t\t\tvar s string\n \t\t\tswitch f.Tag {\n@@ -515,7 +547,8 @@ func unpackStruct(any interface{}, msg []byte, off int) (off1 int, ok bool) {\n \n // Generic struct printer.\n // Doesn't care about the string tag \"domain-name\",\n-// but does look for an \"ipv4\" tag on uint32 variables,\n+// but does look for an \"ipv4\" tag on uint32 variables\n+// and the \"ipv6\" tag on array variables,\n // printing them as IP addresses.\n func printStructValue(val *reflect.StructValue) string {\n \ts := \"{\"\n@@ -533,6 +566,9 @@ func printStructValue(val *reflect.StructValue) string {\n \t\t} else if fv, ok := fval.(*reflect.UintValue); ok && f.Tag == \"ipv4\" {\n \t\t\ti := fv.Get()\n \t\t\ts += IPv4(byte(i>>24), byte(i>>16), byte(i>>8), byte(i)).String()\n+\t\t} else if fv, ok := fval.(*reflect.ArrayValue); ok && f.Tag == \"ipv6\" {\n+\t\t\ti := fv.Interface().([]byte)\n+\t\t\ts += IP(i).String()\n \t\t} else {\n \t\t\ts += fmt.Sprint(fval.Interface())\n \t\t}"}, {"sha": "7e4b83a9f997de6e2b89fb19769b35aa7c984291", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -274,30 +274,49 @@ func startServer() {\n \tpollserver = p\n }\n \n-func newFD(fd, family, proto int, net string, laddr, raddr Addr) (f *netFD, err os.Error) {\n+func newFD(fd, family, proto int, net string) (f *netFD, err os.Error) {\n \tonceStartServer.Do(startServer)\n \tif e := syscall.SetNonblock(fd, true); e != 0 {\n-\t\treturn nil, &OpError{\"setnonblock\", net, laddr, os.Errno(e)}\n+\t\treturn nil, os.Errno(e)\n \t}\n \tf = &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n \t\tproto:  proto,\n \t\tnet:    net,\n-\t\tladdr:  laddr,\n-\t\traddr:  raddr,\n \t}\n+\tf.cr = make(chan bool, 1)\n+\tf.cw = make(chan bool, 1)\n+\treturn f, nil\n+}\n+\n+func (fd *netFD) setAddr(laddr, raddr Addr) {\n+\tfd.laddr = laddr\n+\tfd.raddr = raddr\n \tvar ls, rs string\n \tif laddr != nil {\n \t\tls = laddr.String()\n \t}\n \tif raddr != nil {\n \t\trs = raddr.String()\n \t}\n-\tf.sysfile = os.NewFile(fd, net+\":\"+ls+\"->\"+rs)\n-\tf.cr = make(chan bool, 1)\n-\tf.cw = make(chan bool, 1)\n-\treturn f, nil\n+\tfd.sysfile = os.NewFile(fd.sysfd, fd.net+\":\"+ls+\"->\"+rs)\n+}\n+\n+func (fd *netFD) connect(ra syscall.Sockaddr) (err os.Error) {\n+\te := syscall.Connect(fd.sysfd, ra)\n+\tif e == syscall.EINPROGRESS {\n+\t\tvar errno int\n+\t\tpollserver.WaitWrite(fd)\n+\t\te, errno = syscall.GetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)\n+\t\tif errno != 0 {\n+\t\t\treturn os.NewSyscallError(\"getsockopt\", errno)\n+\t\t}\n+\t}\n+\tif e != 0 {\n+\t\treturn os.Errno(e)\n+\t}\n+\treturn nil\n }\n \n // Add a reference to this fd.\n@@ -593,10 +612,11 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err os.\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\tif nfd, err = newFD(s, fd.family, fd.proto, fd.net, fd.laddr, toAddr(sa)); err != nil {\n+\tif nfd, err = newFD(s, fd.family, fd.proto, fd.net); err != nil {\n \t\tsyscall.Close(s)\n \t\treturn nil, err\n \t}\n+\tnfd.setAddr(fd.laddr, toAddr(sa))\n \treturn nfd, nil\n }\n "}, {"sha": "c2f736cc1267da65a0c8f06a0b05e2e59de0dbb4", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -225,29 +225,40 @@ type netFD struct {\n \twio             sync.Mutex\n }\n \n-func allocFD(fd, family, proto int, net string, laddr, raddr Addr) (f *netFD) {\n+func allocFD(fd, family, proto int, net string) (f *netFD) {\n \tf = &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n \t\tproto:  proto,\n \t\tnet:    net,\n-\t\tladdr:  laddr,\n-\t\traddr:  raddr,\n \t}\n \truntime.SetFinalizer(f, (*netFD).Close)\n \treturn f\n }\n \n-func newFD(fd, family, proto int, net string, laddr, raddr Addr) (f *netFD, err os.Error) {\n+func newFD(fd, family, proto int, net string) (f *netFD, err os.Error) {\n \tif initErr != nil {\n \t\treturn nil, initErr\n \t}\n \tonceStartServer.Do(startServer)\n \t// Associate our socket with resultsrv.iocp.\n \tif _, e := syscall.CreateIoCompletionPort(int32(fd), resultsrv.iocp, 0, 0); e != 0 {\n-\t\treturn nil, &OpError{\"CreateIoCompletionPort\", net, laddr, os.Errno(e)}\n+\t\treturn nil, os.Errno(e)\n+\t}\n+\treturn allocFD(fd, family, proto, net), nil\n+}\n+\n+func (fd *netFD) setAddr(laddr, raddr Addr) {\n+\tfd.laddr = laddr\n+\tfd.raddr = raddr\n+}\n+\n+func (fd *netFD) connect(ra syscall.Sockaddr) (err os.Error) {\n+\te := syscall.Connect(fd.sysfd, ra)\n+\tif e != 0 {\n+\t\treturn os.Errno(e)\n \t}\n-\treturn allocFD(fd, family, proto, net, laddr, raddr), nil\n+\treturn nil\n }\n \n // Add a reference to this fd.\n@@ -497,7 +508,9 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err os.\n \tlsa, _ := lrsa.Sockaddr()\n \trsa, _ := rrsa.Sockaddr()\n \n-\treturn allocFD(s, fd.family, fd.proto, fd.net, toAddr(lsa), toAddr(rsa)), nil\n+\tnfd = allocFD(s, fd.family, fd.proto, fd.net)\n+\tnfd.setAddr(toAddr(lsa), toAddr(rsa))\n+\treturn nfd, nil\n }\n \n // Not implemeted functions."}, {"sha": "0e411a192f2393715e6b03e9ccc7a4c12a68446c", "filename": "libgo/go/net/file.go", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func newFileFD(f *os.File) (nfd *netFD, err os.Error) {\n+\tfd, errno := syscall.Dup(f.Fd())\n+\tif errno != 0 {\n+\t\treturn nil, os.NewSyscallError(\"dup\", errno)\n+\t}\n+\n+\tproto, errno := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n+\tif errno != 0 {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", errno)\n+\t}\n+\n+\ttoAddr := sockaddrToTCP\n+\tsa, _ := syscall.Getsockname(fd)\n+\tswitch sa.(type) {\n+\tdefault:\n+\t\tclosesocket(fd)\n+\t\treturn nil, os.EINVAL\n+\tcase *syscall.SockaddrInet4:\n+\t\tif proto == syscall.SOCK_DGRAM {\n+\t\t\ttoAddr = sockaddrToUDP\n+\t\t} else if proto == syscall.SOCK_RAW {\n+\t\t\ttoAddr = sockaddrToIP\n+\t\t}\n+\tcase *syscall.SockaddrInet6:\n+\t\tif proto == syscall.SOCK_DGRAM {\n+\t\t\ttoAddr = sockaddrToUDP\n+\t\t} else if proto == syscall.SOCK_RAW {\n+\t\t\ttoAddr = sockaddrToIP\n+\t\t}\n+\tcase *syscall.SockaddrUnix:\n+\t\ttoAddr = sockaddrToUnix\n+\t\tif proto == syscall.SOCK_DGRAM {\n+\t\t\ttoAddr = sockaddrToUnixgram\n+\t\t} else if proto == syscall.SOCK_SEQPACKET {\n+\t\t\ttoAddr = sockaddrToUnixpacket\n+\t\t}\n+\t}\n+\tladdr := toAddr(sa)\n+\tsa, _ = syscall.Getpeername(fd)\n+\traddr := toAddr(sa)\n+\n+\tif nfd, err = newFD(fd, 0, proto, laddr.Network()); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tnfd.setAddr(laddr, raddr)\n+\treturn nfd, nil\n+}\n+\n+// FileConn returns a copy of the network connection corresponding to\n+// the open file f.  It is the caller's responsibility to close f when\n+// finished.  Closing c does not affect f, and closing f does not\n+// affect c.\n+func FileConn(f *os.File) (c Conn, err os.Error) {\n+\tfd, err := newFileFD(f)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch fd.laddr.(type) {\n+\tcase *TCPAddr:\n+\t\treturn newTCPConn(fd), nil\n+\tcase *UDPAddr:\n+\t\treturn newUDPConn(fd), nil\n+\tcase *UnixAddr:\n+\t\treturn newUnixConn(fd), nil\n+\tcase *IPAddr:\n+\t\treturn newIPConn(fd), nil\n+\t}\n+\tfd.Close()\n+\treturn nil, os.EINVAL\n+}\n+\n+// FileListener returns a copy of the network listener corresponding\n+// to the open file f.  It is the caller's responsibility to close l\n+// when finished.  Closing c does not affect l, and closing l does not\n+// affect c.\n+func FileListener(f *os.File) (l Listener, err os.Error) {\n+\tfd, err := newFileFD(f)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch laddr := fd.laddr.(type) {\n+\tcase *TCPAddr:\n+\t\treturn &TCPListener{fd}, nil\n+\tcase *UnixAddr:\n+\t\treturn &UnixListener{fd, laddr.Name}, nil\n+\t}\n+\tfd.Close()\n+\treturn nil, os.EINVAL\n+}\n+\n+// FilePacketConn returns a copy of the packet network connection\n+// corresponding to the open file f.  It is the caller's\n+// responsibility to close f when finished.  Closing c does not affect\n+// f, and closing f does not affect c.\n+func FilePacketConn(f *os.File) (c PacketConn, err os.Error) {\n+\tfd, err := newFileFD(f)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch fd.laddr.(type) {\n+\tcase *UDPAddr:\n+\t\treturn newUDPConn(fd), nil\n+\tcase *UnixAddr:\n+\t\treturn newUnixConn(fd), nil\n+\t}\n+\tfd.Close()\n+\treturn nil, os.EINVAL\n+}"}, {"sha": "1ec05fdeea55dd11862756546f437e8cc32e2d3a", "filename": "libgo/go/net/file_test.go", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+type listenerFile interface {\n+\tListener\n+\tFile() (f *os.File, err os.Error)\n+}\n+\n+type packetConnFile interface {\n+\tPacketConn\n+\tFile() (f *os.File, err os.Error)\n+}\n+\n+type connFile interface {\n+\tConn\n+\tFile() (f *os.File, err os.Error)\n+}\n+\n+func testFileListener(t *testing.T, net, laddr string) {\n+\tif net == \"tcp\" {\n+\t\tladdr += \":0\" // any available port\n+\t}\n+\tl, err := Listen(net, laddr)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t}\n+\tdefer l.Close()\n+\tlf := l.(listenerFile)\n+\tf, err := lf.File()\n+\tif err != nil {\n+\t\tt.Fatalf(\"File failed: %v\", err)\n+\t}\n+\tc, err := FileListener(f)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileListener failed: %v\", err)\n+\t}\n+\tif !reflect.DeepEqual(l.Addr(), c.Addr()) {\n+\t\tt.Fatalf(\"Addrs not equal: %#v != %#v\", l.Addr(), c.Addr())\n+\t}\n+\tif err := c.Close(); err != nil {\n+\t\tt.Fatalf(\"Close failed: %v\", err)\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tt.Fatalf(\"Close failed: %v\", err)\n+\t}\n+}\n+\n+func TestFileListener(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n+\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n+\tif kernelSupportsIPv6() {\n+\t\ttestFileListener(t, \"tcp\", \"[::ffff:127.0.0.1]\")\n+\t\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n+\t\ttestFileListener(t, \"tcp\", \"[::ffff:127.0.0.1]\")\n+\t}\n+\tif syscall.OS == \"linux\" {\n+\t\ttestFileListener(t, \"unix\", \"@gotest/net\")\n+\t\ttestFileListener(t, \"unixpacket\", \"@gotest/net\")\n+\t}\n+}\n+\n+func testFilePacketConn(t *testing.T, pcf packetConnFile) {\n+\tf, err := pcf.File()\n+\tif err != nil {\n+\t\tt.Fatalf(\"File failed: %v\", err)\n+\t}\n+\tc, err := FilePacketConn(f)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FilePacketConn failed: %v\", err)\n+\t}\n+\tif !reflect.DeepEqual(pcf.LocalAddr(), c.LocalAddr()) {\n+\t\tt.Fatalf(\"LocalAddrs not equal: %#v != %#v\", pcf.LocalAddr(), c.LocalAddr())\n+\t}\n+\tif err := c.Close(); err != nil {\n+\t\tt.Fatalf(\"Close failed: %v\", err)\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tt.Fatalf(\"Close failed: %v\", err)\n+\t}\n+}\n+\n+func testFilePacketConnListen(t *testing.T, net, laddr string) {\n+\tl, err := ListenPacket(net, laddr)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t}\n+\ttestFilePacketConn(t, l.(packetConnFile))\n+\tif err := l.Close(); err != nil {\n+\t\tt.Fatalf(\"Close failed: %v\", err)\n+\t}\n+}\n+\n+func testFilePacketConnDial(t *testing.T, net, raddr string) {\n+\tc, err := Dial(net, raddr)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Dial failed: %v\", err)\n+\t}\n+\ttestFilePacketConn(t, c.(packetConnFile))\n+\tif err := c.Close(); err != nil {\n+\t\tt.Fatalf(\"Close failed: %v\", err)\n+\t}\n+}\n+\n+func TestFilePacketConn(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\ttestFilePacketConnListen(t, \"udp\", \"127.0.0.1:0\")\n+\ttestFilePacketConnDial(t, \"udp\", \"127.0.0.1:12345\")\n+\tif kernelSupportsIPv6() {\n+\t\ttestFilePacketConnListen(t, \"udp\", \"[::1]:0\")\n+\t\ttestFilePacketConnDial(t, \"udp\", \"[::ffff:127.0.0.1]:12345\")\n+\t}\n+\tif syscall.OS == \"linux\" {\n+\t\ttestFilePacketConnListen(t, \"unixgram\", \"@gotest1/net\")\n+\t}\n+}"}, {"sha": "94aa583755b1f081911c8d0c26944e8789595baf", "filename": "libgo/go/net/file_windows.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffile_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ffile_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_windows.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func FileConn(f *os.File) (c Conn, err os.Error) {\n+\t// TODO: Implement this\n+\treturn nil, os.NewSyscallError(\"FileConn\", syscall.EWINDOWS)\n+}\n+\n+func FileListener(f *os.File) (l Listener, err os.Error) {\n+\t// TODO: Implement this\n+\treturn nil, os.NewSyscallError(\"FileListener\", syscall.EWINDOWS)\n+}\n+\n+func FilePacketConn(f *os.File) (c PacketConn, err os.Error) {\n+\t// TODO: Implement this\n+\treturn nil, os.NewSyscallError(\"FilePacketConn\", syscall.EWINDOWS)\n+}"}, {"sha": "470e35f7863801ca6b415164e237f36caf14afbe", "filename": "libgo/go/net/hosts_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fhosts_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fhosts_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -13,7 +13,6 @@ type hostTest struct {\n \tips  []IP\n }\n \n-\n var hosttests = []hostTest{\n \t{\"odin\", []IP{\n \t\tIPv4(127, 0, 0, 2),"}, {"sha": "12bb6f351a1e914a4f76faecf37cc98c9afdf307", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -474,13 +474,13 @@ func parseIPv6(s string) IP {\n \treturn p\n }\n \n-// A SyntaxError represents a malformed text string and the type of string that was expected.\n-type SyntaxError struct {\n+// A ParseError represents a malformed text string and the type of string that was expected.\n+type ParseError struct {\n \tType string\n \tText string\n }\n \n-func (e *SyntaxError) String() string {\n+func (e *ParseError) String() string {\n \treturn \"invalid \" + e.Type + \": \" + e.Text\n }\n \n@@ -507,33 +507,46 @@ func ParseIP(s string) IP {\n }\n \n // ParseCIDR parses s as a CIDR notation IP address and mask,\n-// like \"192.168.100.1/24\" or \"2001:DB8::/48\".\n+// like \"192.168.100.1/24\", \"2001:DB8::/48\", as defined in\n+// RFC 4632 and RFC 4291.\n func ParseCIDR(s string) (ip IP, mask IPMask, err os.Error) {\n \ti := byteIndex(s, '/')\n \tif i < 0 {\n-\t\treturn nil, nil, &SyntaxError{\"CIDR address\", s}\n+\t\treturn nil, nil, &ParseError{\"CIDR address\", s}\n \t}\n \tipstr, maskstr := s[:i], s[i+1:]\n-\tip = ParseIP(ipstr)\n+\tiplen := 4\n+\tip = parseIPv4(ipstr)\n+\tif ip == nil {\n+\t\tiplen = 16\n+\t\tip = parseIPv6(ipstr)\n+\t}\n \tnn, i, ok := dtoi(maskstr, 0)\n-\tif ip == nil || !ok || i != len(maskstr) || nn < 0 || nn > 8*len(ip) {\n-\t\treturn nil, nil, &SyntaxError{\"CIDR address\", s}\n+\tif ip == nil || !ok || i != len(maskstr) || nn < 0 || nn > 8*iplen {\n+\t\treturn nil, nil, &ParseError{\"CIDR address\", s}\n \t}\n \tn := uint(nn)\n-\tif len(ip) == 4 {\n+\tif iplen == 4 {\n \t\tv4mask := ^uint32(0xffffffff >> n)\n-\t\tmask = IPMask(IPv4(byte(v4mask>>24), byte(v4mask>>16), byte(v4mask>>8), byte(v4mask)))\n-\t\treturn ip, mask, nil\n-\t}\n-\tmask = make(IPMask, 16)\n-\tfor i := 0; i < 16; i++ {\n-\t\tif n >= 8 {\n-\t\t\tmask[i] = 0xff\n-\t\t\tn -= 8\n-\t\t\tcontinue\n+\t\tmask = IPv4Mask(byte(v4mask>>24), byte(v4mask>>16), byte(v4mask>>8), byte(v4mask))\n+\t} else {\n+\t\tmask = make(IPMask, 16)\n+\t\tfor i := 0; i < 16; i++ {\n+\t\t\tif n >= 8 {\n+\t\t\t\tmask[i] = 0xff\n+\t\t\t\tn -= 8\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tmask[i] = ^byte(0xff >> n)\n+\t\t\tn = 0\n+\n+\t\t}\n+\t}\n+\t// address must not have any bits not in mask\n+\tfor i := range ip {\n+\t\tif ip[i]&^mask[i] != 0 {\n+\t\t\treturn nil, nil, &ParseError{\"CIDR address\", s}\n \t\t}\n-\t\tmask[i] = ^byte(0xff >> n)\n-\t\tn = 0\n \t}\n \treturn ip, mask, nil\n }"}, {"sha": "f1a4716d227b4bc200af719f0fa8a0c77833c806", "filename": "libgo/go/net/ip_test.go", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -5,30 +5,26 @@\n package net\n \n import (\n+\t\"bytes\"\n+\t\"reflect\"\n \t\"testing\"\n+\t\"os\"\n )\n \n-func isEqual(a, b IP) bool {\n+func isEqual(a, b []byte) bool {\n \tif a == nil && b == nil {\n \t\treturn true\n \t}\n-\tif a == nil || b == nil || len(a) != len(b) {\n+\tif a == nil || b == nil {\n \t\treturn false\n \t}\n-\tfor i := 0; i < len(a); i++ {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n+\treturn bytes.Equal(a, b)\n }\n \n-type parseIPTest struct {\n+var parseiptests = []struct {\n \tin  string\n \tout IP\n-}\n-\n-var parseiptests = []parseIPTest{\n+}{\n \t{\"127.0.1.2\", IPv4(127, 0, 1, 2)},\n \t{\"127.0.0.1\", IPv4(127, 0, 0, 1)},\n \t{\"127.0.0.256\", nil},\n@@ -43,20 +39,17 @@ var parseiptests = []parseIPTest{\n }\n \n func TestParseIP(t *testing.T) {\n-\tfor i := 0; i < len(parseiptests); i++ {\n-\t\ttt := parseiptests[i]\n+\tfor _, tt := range parseiptests {\n \t\tif out := ParseIP(tt.in); !isEqual(out, tt.out) {\n \t\t\tt.Errorf(\"ParseIP(%#q) = %v, want %v\", tt.in, out, tt.out)\n \t\t}\n \t}\n }\n \n-type ipStringTest struct {\n+var ipstringtests = []struct {\n \tin  IP\n \tout string\n-}\n-\n-var ipstringtests = []ipStringTest{\n+}{\n \t// cf. RFC 5952 (A Recommendation for IPv6 Address Text Representation)\n \t{IP{0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0,\n \t\t0, 0, 0x1, 0x23, 0, 0x12, 0, 0x1},\n@@ -85,10 +78,67 @@ var ipstringtests = []ipStringTest{\n }\n \n func TestIPString(t *testing.T) {\n-\tfor i := 0; i < len(ipstringtests); i++ {\n-\t\ttt := ipstringtests[i]\n+\tfor _, tt := range ipstringtests {\n \t\tif out := tt.in.String(); out != tt.out {\n \t\t\tt.Errorf(\"IP.String(%v) = %#q, want %#q\", tt.in, out, tt.out)\n \t\t}\n \t}\n }\n+\n+var parsecidrtests = []struct {\n+\tin   string\n+\tip   IP\n+\tmask IPMask\n+\terr  os.Error\n+}{\n+\t{\"135.104.0.0/32\", IPv4(135, 104, 0, 0), IPv4Mask(255, 255, 255, 255), nil},\n+\t{\"0.0.0.0/24\", IPv4(0, 0, 0, 0), IPv4Mask(255, 255, 255, 0), nil},\n+\t{\"135.104.0.0/24\", IPv4(135, 104, 0, 0), IPv4Mask(255, 255, 255, 0), nil},\n+\t{\"135.104.0.1/32\", IPv4(135, 104, 0, 1), IPv4Mask(255, 255, 255, 255), nil},\n+\t{\"135.104.0.1/24\", nil, nil, &ParseError{\"CIDR address\", \"135.104.0.1/24\"}},\n+\t{\"::1/128\", ParseIP(\"::1\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\")), nil},\n+\t{\"abcd:2345::/127\", ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe\")), nil},\n+\t{\"abcd:2345::/65\", ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff:8000::\")), nil},\n+\t{\"abcd:2345::/64\", ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:ffff::\")), nil},\n+\t{\"abcd:2345::/63\", ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:ffff:fffe::\")), nil},\n+\t{\"abcd:2345::/33\", ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff:8000::\")), nil},\n+\t{\"abcd:2345::/32\", ParseIP(\"abcd:2345::\"), IPMask(ParseIP(\"ffff:ffff::\")), nil},\n+\t{\"abcd:2344::/31\", ParseIP(\"abcd:2344::\"), IPMask(ParseIP(\"ffff:fffe::\")), nil},\n+\t{\"abcd:2300::/24\", ParseIP(\"abcd:2300::\"), IPMask(ParseIP(\"ffff:ff00::\")), nil},\n+\t{\"abcd:2345::/24\", nil, nil, &ParseError{\"CIDR address\", \"abcd:2345::/24\"}},\n+\t{\"2001:DB8::/48\", ParseIP(\"2001:DB8::\"), IPMask(ParseIP(\"ffff:ffff:ffff::\")), nil},\n+}\n+\n+func TestParseCIDR(t *testing.T) {\n+\tfor _, tt := range parsecidrtests {\n+\t\tif ip, mask, err := ParseCIDR(tt.in); !isEqual(ip, tt.ip) || !isEqual(mask, tt.mask) || !reflect.DeepEqual(err, tt.err) {\n+\t\t\tt.Errorf(\"ParseCIDR(%q) = %v, %v, %v; want %v, %v, %v\", tt.in, ip, mask, err, tt.ip, tt.mask, tt.err)\n+\t\t}\n+\t}\n+}\n+\n+var splitjointests = []struct {\n+\tHost string\n+\tPort string\n+\tJoin string\n+}{\n+\t{\"www.google.com\", \"80\", \"www.google.com:80\"},\n+\t{\"127.0.0.1\", \"1234\", \"127.0.0.1:1234\"},\n+\t{\"::1\", \"80\", \"[::1]:80\"},\n+}\n+\n+func TestSplitHostPort(t *testing.T) {\n+\tfor _, tt := range splitjointests {\n+\t\tif host, port, err := SplitHostPort(tt.Join); host != tt.Host || port != tt.Port || err != nil {\n+\t\t\tt.Errorf(\"SplitHostPort(%q) = %q, %q, %v; want %q, %q, nil\", tt.Join, host, port, err, tt.Host, tt.Port)\n+\t\t}\n+\t}\n+}\n+\n+func TestJoinHostPort(t *testing.T) {\n+\tfor _, tt := range splitjointests {\n+\t\tif join := JoinHostPort(tt.Host, tt.Port); join != tt.Join {\n+\t\t\tt.Errorf(\"JoinHostPort(%q, %q) = %q; want %q\", tt.Host, tt.Port, join, tt.Join)\n+\t\t}\n+\t}\n+}"}, {"sha": "60433303ae1b09fe62698bd2f7e163b7548b04a3", "filename": "libgo/go/net/iprawsock.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fiprawsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fiprawsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -240,7 +240,7 @@ func hostToIP(host string) (ip IP, err os.Error) {\n \taddr = ParseIP(host)\n \tif addr == nil {\n \t\t// Not an IP address.  Try as a DNS name.\n-\t\t_, addrs, err1 := LookupHost(host)\n+\t\taddrs, err1 := LookupHost(host)\n \t\tif err1 != nil {\n \t\t\terr = err1\n \t\t\tgoto Error"}, {"sha": "80bc3eea5da138cb421fbe6c3542cd58c1c3072f", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -170,9 +170,10 @@ func ipToSockaddr(family int, ip IP, port int) (syscall.Sockaddr, os.Error) {\n \treturn nil, InvalidAddrError(\"unexpected socket family\")\n }\n \n-// Split \"host:port\" into \"host\" and \"port\".\n-// Host cannot contain colons unless it is bracketed.\n-func splitHostPort(hostport string) (host, port string, err os.Error) {\n+// SplitHostPort splits a network address of the form\n+// \"host:port\" or \"[host]:port\" into host and port.\n+// The latter form must be used when host contains a colon.\n+func SplitHostPort(hostport string) (host, port string, err os.Error) {\n \t// The port starts after the last colon.\n \ti := last(hostport, ':')\n \tif i < 0 {\n@@ -195,9 +196,9 @@ func splitHostPort(hostport string) (host, port string, err os.Error) {\n \treturn\n }\n \n-// Join \"host\" and \"port\" into \"host:port\".\n-// If host contains colons, will join into \"[host]:port\".\n-func joinHostPort(host, port string) string {\n+// JoinHostPort combines host and port into a network address\n+// of the form \"host:port\" or, if host contains a colon, \"[host]:port\".\n+func JoinHostPort(host, port string) string {\n \t// If host has colons, have to bracket it.\n \tif byteIndex(host, ':') >= 0 {\n \t\treturn \"[\" + host + \"]:\" + port\n@@ -207,7 +208,7 @@ func joinHostPort(host, port string) string {\n \n // Convert \"host:port\" into IP address and port.\n func hostPortToIP(net, hostport string) (ip IP, iport int, err os.Error) {\n-\thost, port, err := splitHostPort(hostport)\n+\thost, port, err := SplitHostPort(hostport)\n \tif err != nil {\n \t\tgoto Error\n \t}\n@@ -218,7 +219,7 @@ func hostPortToIP(net, hostport string) (ip IP, iport int, err os.Error) {\n \t\taddr = ParseIP(host)\n \t\tif addr == nil {\n \t\t\t// Not an IP address.  Try as a DNS name.\n-\t\t\t_, addrs, err1 := LookupHost(host)\n+\t\t\taddrs, err1 := LookupHost(host)\n \t\t\tif err1 != nil {\n \t\t\t\terr = err1\n \t\t\t\tgoto Error"}, {"sha": "7b2185ed4198924501867c39307b99fa517b8c92", "filename": "libgo/go/net/lookup.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"os\"\n+)\n+\n+// LookupHost looks up the given host using the local resolver.\n+// It returns an array of that host's addresses.\n+func LookupHost(host string) (addrs []string, err os.Error) {\n+\taddrs, err, ok := cgoLookupHost(host)\n+\tif !ok {\n+\t\taddrs, err = goLookupHost(host)\n+\t}\n+\treturn\n+}\n+\n+// LookupIP looks up host using the local resolver.\n+// It returns an array of that host's IPv4 and IPv6 addresses.\n+func LookupIP(host string) (addrs []IP, err os.Error) {\n+\taddrs, err, ok := cgoLookupIP(host)\n+\tif !ok {\n+\t\taddrs, err = goLookupIP(host)\n+\t}\n+\treturn\n+}\n+\n+// LookupPort looks up the port for the given network and service.\n+func LookupPort(network, service string) (port int, err os.Error) {\n+\tport, err, ok := cgoLookupPort(network, service)\n+\tif !ok {\n+\t\tport, err = goLookupPort(network, service)\n+\t}\n+\treturn\n+}"}, {"sha": "da7928351ce08ac4ef202af9579ddcbf42cb9084", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -15,50 +15,49 @@ var runErrorTest = flag.Bool(\"run_error_test\", false, \"let TestDialError check f\n \n type DialErrorTest struct {\n \tNet     string\n-\tLaddr   string\n \tRaddr   string\n \tPattern string\n }\n \n var dialErrorTests = []DialErrorTest{\n \t{\n-\t\t\"datakit\", \"\", \"mh/astro/r70\",\n+\t\t\"datakit\", \"mh/astro/r70\",\n \t\t\"dial datakit mh/astro/r70: unknown network datakit\",\n \t},\n \t{\n-\t\t\"tcp\", \"\", \"127.0.0.1:\u263a\",\n+\t\t\"tcp\", \"127.0.0.1:\u263a\",\n \t\t\"dial tcp 127.0.0.1:\u263a: unknown port tcp/\u263a\",\n \t},\n \t{\n-\t\t\"tcp\", \"\", \"no-such-name.google.com.:80\",\n+\t\t\"tcp\", \"no-such-name.google.com.:80\",\n \t\t\"dial tcp no-such-name.google.com.:80: lookup no-such-name.google.com.( on .*)?: no (.*)\",\n \t},\n \t{\n-\t\t\"tcp\", \"\", \"no-such-name.no-such-top-level-domain.:80\",\n+\t\t\"tcp\", \"no-such-name.no-such-top-level-domain.:80\",\n \t\t\"dial tcp no-such-name.no-such-top-level-domain.:80: lookup no-such-name.no-such-top-level-domain.( on .*)?: no (.*)\",\n \t},\n \t{\n-\t\t\"tcp\", \"\", \"no-such-name:80\",\n+\t\t\"tcp\", \"no-such-name:80\",\n \t\t`dial tcp no-such-name:80: lookup no-such-name\\.(.*\\.)?( on .*)?: no (.*)`,\n \t},\n \t{\n-\t\t\"tcp\", \"\", \"mh/astro/r70:http\",\n+\t\t\"tcp\", \"mh/astro/r70:http\",\n \t\t\"dial tcp mh/astro/r70:http: lookup mh/astro/r70: invalid domain name\",\n \t},\n \t{\n-\t\t\"unix\", \"\", \"/etc/file-not-found\",\n+\t\t\"unix\", \"/etc/file-not-found\",\n \t\t\"dial unix /etc/file-not-found: [nN]o such file or directory\",\n \t},\n \t{\n-\t\t\"unix\", \"\", \"/etc/\",\n-\t\t\"dial unix /etc/: ([pP]ermission denied|[sS]ocket operation on non-socket|[cC]onnection refused)\",\n+\t\t\"unix\", \"/etc/\",\n+\t\t\"dial unix /etc/: ([pP]ermission denied|socket operation on non-socket|connection refused)\",\n \t},\n \t{\n-\t\t\"unixpacket\", \"\", \"/etc/file-not-found\",\n+\t\t\"unixpacket\", \"/etc/file-not-found\",\n \t\t\"dial unixpacket /etc/file-not-found: no such file or directory\",\n \t},\n \t{\n-\t\t\"unixpacket\", \"\", \"/etc/\",\n+\t\t\"unixpacket\", \"/etc/\",\n \t\t\"dial unixpacket /etc/: (permission denied|socket operation on non-socket|connection refused)\",\n \t},\n }\n@@ -69,7 +68,7 @@ func TestDialError(t *testing.T) {\n \t\treturn\n \t}\n \tfor i, tt := range dialErrorTests {\n-\t\tc, e := Dial(tt.Net, tt.Laddr, tt.Raddr)\n+\t\tc, e := Dial(tt.Net, tt.Raddr)\n \t\tif c != nil {\n \t\t\tc.Close()\n \t\t}"}, {"sha": "8f8327a3733d573994a0e53d760e36aacadbb17d", "filename": "libgo/go/net/port.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fport.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -50,8 +50,8 @@ func readServices() {\n \tfile.close()\n }\n \n-// LookupPort looks up the port for the given network and service.\n-func LookupPort(network, service string) (port int, err os.Error) {\n+// goLookupPort is the native Go implementation of LookupPort.\n+func goLookupPort(network, service string) (port int, err os.Error) {\n \tonceReadServices.Do(readServices)\n \n \tswitch network {"}, {"sha": "37695a068d15297b9e8646902a50fc7559627408", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -54,13 +54,15 @@ func runServe(t *testing.T, network, addr string, listening chan<- string, done\n }\n \n func connect(t *testing.T, network, addr string, isEmpty bool) {\n-\tvar laddr string\n+\tvar fd Conn\n+\tvar err os.Error\n \tif network == \"unixgram\" {\n-\t\tladdr = addr + \".local\"\n+\t\tfd, err = DialUnix(network, &UnixAddr{addr + \".local\", network}, &UnixAddr{addr, network})\n+\t} else {\n+\t\tfd, err = Dial(network, addr)\n \t}\n-\tfd, err := Dial(network, laddr, addr)\n \tif err != nil {\n-\t\tt.Fatalf(\"net.Dial(%q, %q, %q) = _, %v\", network, laddr, addr, err)\n+\t\tt.Fatalf(\"net.Dial(%q, %q) = _, %v\", network, addr, err)\n \t}\n \tfd.SetReadTimeout(1e9) // 1s\n "}, {"sha": "933700af160ec2248daf6207a5cffaf76b65e72d", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -52,14 +52,16 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal\n \t\t}\n \t}\n \n+\tif fd, err = newFD(s, f, p, net); err != nil {\n+\t\tclosesocket(s)\n+\t\treturn nil, err\n+\t}\n+\n \tif ra != nil {\n-\t\te = syscall.Connect(s, ra)\n-\t\tfor e == syscall.EINTR {\n-\t\t\te = syscall.Connect(s, ra)\n-\t\t}\n-\t\tif e != 0 {\n+\t\tif err = fd.connect(ra); err != nil {\n+\t\t\tfd.sysfd = -1\n \t\t\tclosesocket(s)\n-\t\t\treturn nil, os.Errno(e)\n+\t\t\treturn nil, err\n \t\t}\n \t}\n \n@@ -68,12 +70,7 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal\n \tsa, _ = syscall.Getpeername(s)\n \traddr := toAddr(sa)\n \n-\tfd, err = newFD(s, f, p, net, laddr, raddr)\n-\tif err != nil {\n-\t\tclosesocket(s)\n-\t\treturn nil, err\n-\t}\n-\n+\tfd.setAddr(laddr, raddr)\n \treturn fd, nil\n }\n \n@@ -170,9 +167,9 @@ func (e *UnknownSocketError) String() string {\n func sockaddrToString(sa syscall.Sockaddr) (name string, err os.Error) {\n \tswitch a := sa.(type) {\n \tcase *syscall.SockaddrInet4:\n-\t\treturn joinHostPort(IP(a.Addr[0:]).String(), itoa(a.Port)), nil\n+\t\treturn JoinHostPort(IP(a.Addr[0:]).String(), itoa(a.Port)), nil\n \tcase *syscall.SockaddrInet6:\n-\t\treturn joinHostPort(IP(a.Addr[0:]).String(), itoa(a.Port)), nil\n+\t\treturn JoinHostPort(IP(a.Addr[0:]).String(), itoa(a.Port)), nil\n \tcase *syscall.SockaddrUnix:\n \t\treturn a.Name, nil\n \t}"}, {"sha": "b484be20b463dd7af28617f40e2d5d2479588c72", "filename": "libgo/go/net/tcpsock.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ftcpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ftcpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -34,7 +34,7 @@ func (a *TCPAddr) String() string {\n \tif a == nil {\n \t\treturn \"<nil>\"\n \t}\n-\treturn joinHostPort(a.IP.String(), itoa(a.Port))\n+\treturn JoinHostPort(a.IP.String(), itoa(a.Port))\n }\n \n func (a *TCPAddr) family() int {\n@@ -213,8 +213,9 @@ func (c *TCPConn) SetNoDelay(noDelay bool) os.Error {\n // Closing c does not affect f, and closing f does not affect c.\n func (c *TCPConn) File() (f *os.File, err os.Error) { return c.fd.dup() }\n \n-// DialTCP is like Dial but can only connect to TCP networks\n-// and returns a TCPConn structure.\n+// DialTCP connects to the remote address raddr on the network net,\n+// which must be \"tcp\", \"tcp4\", or \"tcp6\".  If laddr is not nil, it is used\n+// as the local address for the connection.\n func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error) {\n \tif raddr == nil {\n \t\treturn nil, &OpError{\"dial\", \"tcp\", nil, errMissingAddress}"}, {"sha": "fbfad9d61ce4519ef28e66c1045f0c946c792bbe", "filename": "libgo/go/net/textproto/textproto.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Ftextproto.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -78,7 +78,7 @@ func (c *Conn) Close() os.Error {\n // Dial connects to the given address on the given network using net.Dial\n // and then returns a new Conn for the connection.\n func Dial(network, addr string) (*Conn, os.Error) {\n-\tc, err := net.Dial(network, \"\", addr)\n+\tc, err := net.Dial(network, addr)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "0dbab5846a6885ec13a130b6c5c5402e7a42b13f", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -11,7 +11,7 @@ import (\n )\n \n func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n-\tfd, err := Dial(network, \"\", addr)\n+\tfd, err := Dial(network, addr)\n \tif err != nil {\n \t\tt.Errorf(\"dial %s %s failed: %v\", network, addr, err)\n \t\treturn"}, {"sha": "44d618dab08c91daa08504813f5c8a48fe4b4749", "filename": "libgo/go/net/udpsock.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fudpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnet%2Fudpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -34,7 +34,7 @@ func (a *UDPAddr) String() string {\n \tif a == nil {\n \t\treturn \"<nil>\"\n \t}\n-\treturn joinHostPort(a.IP.String(), itoa(a.Port))\n+\treturn JoinHostPort(a.IP.String(), itoa(a.Port))\n }\n \n func (a *UDPAddr) family() int {"}, {"sha": "8ba5df9a5154c957e45b41b3f45cca8dc91ec674", "filename": "libgo/go/netchan/import.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnetchan%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnetchan%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fimport.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -48,7 +48,7 @@ func NewImporter(conn io.ReadWriter) *Importer {\n \n // Import imports a set of channels from the given network and address.\n func Import(network, remoteaddr string) (*Importer, os.Error) {\n-\tconn, err := net.Dial(network, \"\", remoteaddr)\n+\tconn, err := net.Dial(network, remoteaddr)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "fd4d8f780d9328953f42302f8ee676c18bb61c28", "filename": "libgo/go/netchan/netchan_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -399,7 +399,7 @@ func TestImportFlowControl(t *testing.T) {\n \n func testFlow(sendDone chan bool, ch <-chan int, N int, t *testing.T) {\n \tgo func() {\n-\t\ttime.Sleep(1e9)\n+\t\ttime.Sleep(0.5e9)\n \t\tsendDone <- false\n \t}()\n "}, {"sha": "01268e53a78b7033e07881853ceb2cae83144dd5", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -108,3 +108,21 @@ func Truncate(name string, size int64) Error {\n \t}\n \treturn nil\n }\n+\n+// basename removes trailing slashes and the leading directory name from path name\n+func basename(name string) string {\n+\ti := len(name) - 1\n+\t// Remove trailing slashes\n+\tfor ; i > 0 && name[i] == '/'; i-- {\n+\t\tname = name[:i]\n+\t}\n+\t// Remove leading directory name\n+\tfor i--; i >= 0; i-- {\n+\t\tif name[i] == '/' {\n+\t\t\tname = name[i+1:]\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn name\n+}"}, {"sha": "8af4afcf697ab3befd713f36825c5045bb3a1896", "filename": "libgo/go/rpc/client.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fclient.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -208,7 +208,7 @@ func DialHTTP(network, address string) (*Client, os.Error) {\n // at the specified network address and path.\n func DialHTTPPath(network, address, path string) (*Client, os.Error) {\n \tvar err os.Error\n-\tconn, err := net.Dial(network, \"\", address)\n+\tconn, err := net.Dial(network, address)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -229,7 +229,7 @@ func DialHTTPPath(network, address, path string) (*Client, os.Error) {\n \n // Dial connects to an RPC server at the specified network address.\n func Dial(network, address string) (*Client, os.Error) {\n-\tconn, err := net.Dial(network, \"\", address)\n+\tconn, err := net.Dial(network, address)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "57e977d3253194c801c5252da58f86cd2d25db7e", "filename": "libgo/go/rpc/jsonrpc/client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fclient.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -116,7 +116,7 @@ func NewClient(conn io.ReadWriteCloser) *rpc.Client {\n \n // Dial connects to a JSON-RPC server at the specified network address.\n func Dial(network, address string) (*rpc.Client, os.Error) {\n-\tconn, err := net.Dial(network, \"\", address)\n+\tconn, err := net.Dial(network, address)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "a060917a280871e3040de554f238ece6ec3f5fb1", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -15,7 +15,15 @@ import (\n )\n \n func TestCPUProfile(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+\tswitch runtime.GOOS {\n+\tcase \"darwin\":\n+\t\t// see Apple Bug Report #9177434 (copied into change description)\n+\t\treturn\n+\tcase \"plan9\":\n+\t\t// unimplemented\n+\t\treturn\n+\tcase \"windows\":\n+\t\t// unimplemented\n \t\treturn\n \t}\n "}, {"sha": "3f89af147202e8f0bf3b8952afd4e5cda05c0354", "filename": "libgo/go/smtp/smtp.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsmtp%2Fsmtp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsmtp%2Fsmtp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsmtp%2Fsmtp.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -39,7 +39,7 @@ type Client struct {\n \n // Dial returns a new Client connected to an SMTP server at addr.\n func Dial(addr string) (*Client, os.Error) {\n-\tconn, err := net.Dial(\"tcp\", \"\", addr)\n+\tconn, err := net.Dial(\"tcp\", addr)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "3d7337fd01007ce6916f98f655d2e8268c05d19d", "filename": "libgo/go/sort/sort_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsort%2Fsort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsort%2Fsort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fsort_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -74,7 +74,11 @@ func TestSortStrings(t *testing.T) {\n }\n \n func TestSortLarge_Random(t *testing.T) {\n-\tdata := make([]int, 1000000)\n+\tn := 1000000\n+\tif testing.Short() {\n+\t\tn /= 100\n+\t}\n+\tdata := make([]int, n)\n \tfor i := 0; i < len(data); i++ {\n \t\tdata[i] = rand.Intn(100)\n \t}\n@@ -174,6 +178,9 @@ func lg(n int) int {\n \n func TestBentleyMcIlroy(t *testing.T) {\n \tsizes := []int{100, 1023, 1024, 1025}\n+\tif testing.Short() {\n+\t\tsizes = []int{100, 127, 128, 129}\n+\t}\n \tdists := []string{\"sawtooth\", \"rand\", \"stagger\", \"plateau\", \"shuffle\"}\n \tmodes := []string{\"copy\", \"reverse\", \"reverse1\", \"reverse2\", \"sort\", \"dither\"}\n \tvar tmp1, tmp2 [1025]int"}, {"sha": "93c7c46473882c6cf115d9d6c41a5488d7da2a83", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -275,20 +275,10 @@ func Join(a []string, sep string) string {\n \t}\n \n \tb := make([]byte, n)\n-\tbp := 0\n-\tfor i := 0; i < len(a); i++ {\n-\t\ts := a[i]\n-\t\tfor j := 0; j < len(s); j++ {\n-\t\t\tb[bp] = s[j]\n-\t\t\tbp++\n-\t\t}\n-\t\tif i+1 < len(a) {\n-\t\t\ts = sep\n-\t\t\tfor j := 0; j < len(s); j++ {\n-\t\t\t\tb[bp] = s[j]\n-\t\t\t\tbp++\n-\t\t\t}\n-\t\t}\n+\tbp := copy(b, a[0])\n+\tfor _, s := range a[1:] {\n+\t\tbp += copy(b[bp:], sep)\n+\t\tbp += copy(b[bp:], s)\n \t}\n \treturn string(b)\n }\n@@ -312,9 +302,19 @@ func Map(mapping func(rune int) int, s string) string {\n \t// fine.  It could also shrink but that falls out naturally.\n \tmaxbytes := len(s) // length of b\n \tnbytes := 0        // number of bytes encoded in b\n-\tb := make([]byte, maxbytes)\n-\tfor _, c := range s {\n+\t// The output buffer b is initialized on demand, the first\n+\t// time a character differs.\n+\tvar b []byte\n+\n+\tfor i, c := range s {\n \t\trune := mapping(c)\n+\t\tif b == nil {\n+\t\t\tif rune == c {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tb = make([]byte, maxbytes)\n+\t\t\tnbytes = copy(b, s[:i])\n+\t\t}\n \t\tif rune >= 0 {\n \t\t\twid := 1\n \t\t\tif rune >= utf8.RuneSelf {\n@@ -330,6 +330,9 @@ func Map(mapping func(rune int) int, s string) string {\n \t\t\tnbytes += utf8.EncodeRune(b[nbytes:maxbytes], rune)\n \t\t}\n \t}\n+\tif b == nil {\n+\t\treturn s\n+\t}\n \treturn string(b[0:nbytes])\n }\n "}, {"sha": "c45b1485d8fffdb65e30e59740f557a6d5b85f98", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -6,10 +6,12 @@ package strings_test\n \n import (\n \t\"os\"\n+\t\"reflect\"\n \t\"strconv\"\n \t. \"strings\"\n \t\"testing\"\n \t\"unicode\"\n+\t\"unsafe\"\n \t\"utf8\"\n )\n \n@@ -429,12 +431,32 @@ func TestMap(t *testing.T) {\n \tif m != expect {\n \t\tt.Errorf(\"drop: expected %q got %q\", expect, m)\n \t}\n+\n+\t// 6. Identity\n+\tidentity := func(rune int) int {\n+\t\treturn rune\n+\t}\n+\torig := \"Input string that we expect not to be copied.\"\n+\tm = Map(identity, orig)\n+\tif (*reflect.StringHeader)(unsafe.Pointer(&orig)).Data !=\n+\t\t(*reflect.StringHeader)(unsafe.Pointer(&m)).Data {\n+\t\tt.Error(\"unexpected copy during identity map\")\n+\t}\n }\n \n func TestToUpper(t *testing.T) { runStringTests(t, ToUpper, \"ToUpper\", upperTests) }\n \n func TestToLower(t *testing.T) { runStringTests(t, ToLower, \"ToLower\", lowerTests) }\n \n+func BenchmarkMapNoChanges(b *testing.B) {\n+\tidentity := func(rune int) int {\n+\t\treturn rune\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tMap(identity, \"Some string that won't be modified.\")\n+\t}\n+}\n+\n func TestSpecialCase(t *testing.T) {\n \tlower := \"abc\u00e7defg\u011fh\u0131ijklmno\u00f6prs\u015ftu\u00fcvyz\"\n \tupper := \"ABC\u00c7DEFG\u011eHI\u0130JKLMNO\u00d6PRS\u015eTU\u00dcVYZ\"\n@@ -617,7 +639,11 @@ func equal(m string, s1, s2 string, t *testing.T) bool {\n \n func TestCaseConsistency(t *testing.T) {\n \t// Make a string of all the runes.\n-\ta := make([]int, unicode.MaxRune+1)\n+\tnumRunes := unicode.MaxRune + 1\n+\tif testing.Short() {\n+\t\tnumRunes = 1000\n+\t}\n+\ta := make([]int, numRunes)\n \tfor i := range a {\n \t\ta[i] = i\n \t}\n@@ -627,10 +653,10 @@ func TestCaseConsistency(t *testing.T) {\n \tlower := ToLower(s)\n \n \t// Consistency checks\n-\tif n := utf8.RuneCountInString(upper); n != unicode.MaxRune+1 {\n+\tif n := utf8.RuneCountInString(upper); n != numRunes {\n \t\tt.Error(\"rune count wrong in upper:\", n)\n \t}\n-\tif n := utf8.RuneCountInString(lower); n != unicode.MaxRune+1 {\n+\tif n := utf8.RuneCountInString(lower); n != numRunes {\n \t\tt.Error(\"rune count wrong in lower:\", n)\n \t}\n \tif !equal(\"ToUpper(upper)\", ToUpper(upper), upper, t) {"}, {"sha": "119ad0036fdb5eea8efd079ee38fbeedd0f86df6", "filename": "libgo/go/sync/atomic/atomic_test.go", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -2,10 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package atomic\n+package atomic_test\n \n import (\n \t\"runtime\"\n+\t. \"sync/atomic\"\n \t\"testing\"\n \t\"unsafe\"\n )\n@@ -27,6 +28,16 @@ const (\n \tmagic64 = 0xdeddeadbeefbeef\n )\n \n+// Do the 64-bit functions panic?  If so, don't bother testing.\n+var test64err = func() (err interface{}) {\n+\tdefer func() {\n+\t\terr = recover()\n+\t}()\n+\tvar x int64\n+\tAddInt64(&x, 1)\n+\treturn nil\n+}()\n+\n func TestAddInt32(t *testing.T) {\n \tvar x struct {\n \t\tbefore int32\n@@ -70,6 +81,10 @@ func TestAddUint32(t *testing.T) {\n }\n \n func TestAddInt64(t *testing.T) {\n+\tif test64err != nil {\n+\t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n+\t\treturn\n+\t}\n \tvar x struct {\n \t\tbefore int64\n \t\ti      int64\n@@ -91,6 +106,10 @@ func TestAddInt64(t *testing.T) {\n }\n \n func TestAddUint64(t *testing.T) {\n+\tif test64err != nil {\n+\t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n+\t\treturn\n+\t}\n \tvar x struct {\n \t\tbefore uint64\n \t\ti      uint64\n@@ -193,6 +212,10 @@ func TestCompareAndSwapUint32(t *testing.T) {\n }\n \n func TestCompareAndSwapInt64(t *testing.T) {\n+\tif test64err != nil {\n+\t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n+\t\treturn\n+\t}\n \tvar x struct {\n \t\tbefore int64\n \t\ti      int64\n@@ -222,6 +245,10 @@ func TestCompareAndSwapInt64(t *testing.T) {\n }\n \n func TestCompareAndSwapUint64(t *testing.T) {\n+\tif test64err != nil {\n+\t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n+\t\treturn\n+\t}\n \tvar x struct {\n \t\tbefore uint64\n \t\ti      uint64\n@@ -370,10 +397,11 @@ func hammerCompareAndSwapUintptr32(uval *uint32, count int) {\n }\n \n func TestHammer32(t *testing.T) {\n-\tconst (\n-\t\tn = 100000\n-\t\tp = 4\n-\t)\n+\tconst p = 4\n+\tn := 100000\n+\tif testing.Short() {\n+\t\tn = 1000\n+\t}\n \tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(p))\n \n \tfor _, tt := range hammer32 {\n@@ -391,7 +419,7 @@ func TestHammer32(t *testing.T) {\n \t\tfor i := 0; i < p; i++ {\n \t\t\t<-c\n \t\t}\n-\t\tif val != n*p {\n+\t\tif val != uint32(n)*p {\n \t\t\tt.Errorf(\"%s: val=%d want %d\", tt.name, val, n*p)\n \t\t}\n \t}\n@@ -478,10 +506,15 @@ func hammerCompareAndSwapUintptr64(uval *uint64, count int) {\n }\n \n func TestHammer64(t *testing.T) {\n-\tconst (\n-\t\tn = 100000\n-\t\tp = 4\n-\t)\n+\tif test64err != nil {\n+\t\tt.Logf(\"Skipping 64-bit tests: %v\", test64err)\n+\t\treturn\n+\t}\n+\tconst p = 4\n+\tn := 100000\n+\tif testing.Short() {\n+\t\tn = 1000\n+\t}\n \tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(p))\n \n \tfor _, tt := range hammer64 {\n@@ -499,7 +532,7 @@ func TestHammer64(t *testing.T) {\n \t\tfor i := 0; i < p; i++ {\n \t\t\t<-c\n \t\t}\n-\t\tif val != n*p {\n+\t\tif val != uint64(n)*p {\n \t\t\tt.Errorf(\"%s: val=%d want %d\", tt.name, val, n*p)\n \t\t}\n \t}"}, {"sha": "ec5a0d33af123c2a8920384a0fb964cb923ac570", "filename": "libgo/go/sync/atomic/doc.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -55,3 +55,8 @@ func AddUint64(val *uint64, delta uint64) (new uint64)\n \n // AddUintptr atomically adds delta to *val and returns the new value.\n func AddUintptr(val *uintptr, delta uintptr) (new uintptr)\n+\n+// Helper for ARM.  Linker will discard on other systems\n+func panic64() {\n+\tpanic(\"sync/atomic: broken 64-bit atomic operations (buggy QEMU)\")\n+}"}, {"sha": "9fb89f8e8a32a3c5c63d36099b3e63eb00011c07", "filename": "libgo/go/sync/rwmutex_test.go", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsync%2Frwmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsync%2Frwmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Frwmutex_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -102,16 +102,20 @@ func HammerRWMutex(gomaxprocs, numReaders, num_iterations int) {\n }\n \n func TestRWMutex(t *testing.T) {\n-\tHammerRWMutex(1, 1, 1000)\n-\tHammerRWMutex(1, 3, 1000)\n-\tHammerRWMutex(1, 10, 1000)\n-\tHammerRWMutex(4, 1, 1000)\n-\tHammerRWMutex(4, 3, 1000)\n-\tHammerRWMutex(4, 10, 1000)\n-\tHammerRWMutex(10, 1, 1000)\n-\tHammerRWMutex(10, 3, 1000)\n-\tHammerRWMutex(10, 10, 1000)\n-\tHammerRWMutex(10, 5, 10000)\n+\tn := 1000\n+\tif testing.Short() {\n+\t\tn = 5\n+\t}\n+\tHammerRWMutex(1, 1, n)\n+\tHammerRWMutex(1, 3, n)\n+\tHammerRWMutex(1, 10, n)\n+\tHammerRWMutex(4, 1, n)\n+\tHammerRWMutex(4, 3, n)\n+\tHammerRWMutex(4, 10, n)\n+\tHammerRWMutex(10, 1, n)\n+\tHammerRWMutex(10, 3, n)\n+\tHammerRWMutex(10, 10, n)\n+\tHammerRWMutex(10, 5, n)\n }\n \n func TestRLocker(t *testing.T) {"}, {"sha": "4ada113f1d7692260769749d9783ad3a636e6d24", "filename": "libgo/go/syslog/syslog.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyslog%2Fsyslog.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -67,7 +67,7 @@ func Dial(network, raddr string, priority Priority, prefix string) (w *Writer, e\n \t\tconn, err = unixSyslog()\n \t} else {\n \t\tvar c net.Conn\n-\t\tc, err = net.Dial(network, \"\", raddr)\n+\t\tc, err = net.Dial(network, raddr)\n \t\tconn = netConn{c}\n \t}\n \treturn &Writer{priority, prefix, conn}, err"}, {"sha": "fa15e882d079772701bb6d5d0492420913615a17", "filename": "libgo/go/syslog/syslog_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsyslog%2Fsyslog_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fsyslog%2Fsyslog_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyslog%2Fsyslog_unix.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -19,7 +19,7 @@ func unixSyslog() (conn serverConn, err os.Error) {\n \tfor _, network := range logTypes {\n \t\tfor _, path := range logPaths {\n \t\t\traddr = path\n-\t\t\tconn, err := net.Dial(network, \"\", raddr)\n+\t\t\tconn, err := net.Dial(network, raddr)\n \t\t\tif err != nil {\n \t\t\t\tcontinue\n \t\t\t} else {"}, {"sha": "d1893907a565131fa43af76e8315793cc383570c", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -48,6 +48,13 @@ import (\n )\n \n var (\n+\t// The short flag requests that tests run more quickly, but its functionality\n+\t// is provided by test writers themselves.  The testing package is just its\n+\t// home.  The all.bash installation script sets it to make installation more\n+\t// efficient, but by default the flag is off so a plain \"gotest\" will do a\n+\t// full test of the package.\n+\tshort = flag.Bool(\"test.short\", false, \"run smaller test suite to save time\")\n+\n \t// Report as tests are run; default is silent for success.\n \tchatty         = flag.Bool(\"test.v\", false, \"verbose: print additional output\")\n \tmatch          = flag.String(\"test.run\", \"\", \"regular expression to select tests to run\")\n@@ -56,6 +63,11 @@ var (\n \tcpuProfile     = flag.String(\"test.cpuprofile\", \"\", \"write a cpu profile to the named file during execution\")\n )\n \n+// Short reports whether the -test.short flag is set.\n+func Short() bool {\n+\treturn *short\n+}\n+\n \n // Insert final newline if needed and tabs after internal newlines.\n func tabify(s string) string {\n@@ -174,7 +186,7 @@ func RunTests(matchString func(pat, str string) (bool, os.Error), tests []Intern\n \t\tgo tRunner(t, &tests[i])\n \t\t<-t.ch\n \t\tns += time.Nanoseconds()\n-\t\ttstr := fmt.Sprintf(\"(%.1f seconds)\", float64(ns)/1e9)\n+\t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", float64(ns)/1e9)\n \t\tif t.failed {\n \t\t\tprintln(\"--- FAIL:\", tests[i].Name, tstr)\n \t\t\tprint(t.errors)"}, {"sha": "eb6bb25fd4d14fcb20e649b424edfee3fb67b96c", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -5,6 +5,7 @@\n package time_test\n \n import (\n+\t\"fmt\"\n \t\"os\"\n \t\"syscall\"\n \t\"testing\"\n@@ -132,8 +133,22 @@ func TestAfterStop(t *testing.T) {\n \t}\n }\n \n+func TestAfterQueuing(t *testing.T) {\n+\t// This test flakes out on some systems,\n+\t// so we'll try it a few times before declaring it a failure.\n+\tconst attempts = 3\n+\terr := os.NewError(\"!=nil\")\n+\tfor i := 0; i < attempts && err != nil; i++ {\n+\t\tif err = testAfterQueuing(t); err != nil {\n+\t\t\tt.Logf(\"attempt %v failed: %v\", i, err)\n+\t\t}\n+\t}\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n // For gccgo omit 0 for now because it can take too long to start the\n-// thread.\n var slots = []int{5, 3, 6, 6, 6, 1, 1, 2, 7, 9, 4, 8, /*0*/}\n \n type afterResult struct {\n@@ -145,7 +160,7 @@ func await(slot int, result chan<- afterResult, ac <-chan int64) {\n \tresult <- afterResult{slot, <-ac}\n }\n \n-func TestAfterQueuing(t *testing.T) {\n+func testAfterQueuing(t *testing.T) os.Error {\n \tconst (\n \t\tDelta = 100 * 1e6\n \t)\n@@ -162,13 +177,14 @@ func TestAfterQueuing(t *testing.T) {\n \tfor _, slot := range slots {\n \t\tr := <-result\n \t\tif r.slot != slot {\n-\t\t\tt.Fatalf(\"after queue got slot %d, expected %d\", r.slot, slot)\n+\t\t\treturn fmt.Errorf(\"after queue got slot %d, expected %d\", r.slot, slot)\n \t\t}\n \t\tns := r.t - t0\n \t\ttarget := int64(slot * Delta)\n \t\tslop := int64(Delta) / 4\n \t\tif ns < target-slop || ns > target+slop {\n-\t\t\tt.Fatalf(\"after queue slot %d arrived at %g, expected [%g,%g]\", slot, float64(ns), float64(target-slop), float64(target+slop))\n+\t\t\treturn fmt.Errorf(\"after queue slot %d arrived at %g, expected [%g,%g]\", slot, float64(ns), float64(target-slop), float64(target+slop))\n \t\t}\n \t}\n+\treturn nil\n }"}, {"sha": "f376b628c73e11b114006931d813d2ca13969071", "filename": "libgo/go/utf8/string_test.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Futf8%2Fstring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Futf8%2Fstring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf8%2Fstring_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -45,7 +45,12 @@ func TestScanBackwards(t *testing.T) {\n \t}\n }\n \n-const randCount = 100000\n+func randCount() int {\n+\tif testing.Short() {\n+\t\treturn 100\n+\t}\n+\treturn 100000\n+}\n \n func TestRandomAccess(t *testing.T) {\n \tfor _, s := range testStrings {\n@@ -58,7 +63,7 @@ func TestRandomAccess(t *testing.T) {\n \t\t\tt.Errorf(\"%s: expected %d runes; got %d\", s, len(runes), str.RuneCount())\n \t\t\tbreak\n \t\t}\n-\t\tfor j := 0; j < randCount; j++ {\n+\t\tfor j := 0; j < randCount(); j++ {\n \t\t\ti := rand.Intn(len(runes))\n \t\t\texpect := runes[i]\n \t\t\tgot := str.At(i)\n@@ -80,7 +85,7 @@ func TestRandomSliceAccess(t *testing.T) {\n \t\t\tt.Errorf(\"%s: expected %d runes; got %d\", s, len(runes), str.RuneCount())\n \t\t\tbreak\n \t\t}\n-\t\tfor k := 0; k < randCount; k++ {\n+\t\tfor k := 0; k < randCount(); k++ {\n \t\t\ti := rand.Intn(len(runes))\n \t\t\tj := rand.Intn(len(runes) + 1)\n \t\t\tif i > j { // include empty strings"}, {"sha": "78c8b7f57bfeede97a79874b4178e369ca568f21", "filename": "libgo/go/websocket/client.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fwebsocket%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fwebsocket%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fclient.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -108,10 +108,10 @@ func Dial(url, protocol, origin string) (ws *Conn, err os.Error) {\n \n \tswitch parsedUrl.Scheme {\n \tcase \"ws\":\n-\t\tclient, err = net.Dial(\"tcp\", \"\", parsedUrl.Host)\n+\t\tclient, err = net.Dial(\"tcp\", parsedUrl.Host)\n \n \tcase \"wss\":\n-\t\tclient, err = tls.Dial(\"tcp\", \"\", parsedUrl.Host, nil)\n+\t\tclient, err = tls.Dial(\"tcp\", parsedUrl.Host, nil)\n \n \tdefault:\n \t\terr = ErrBadScheme"}, {"sha": "8b3cf8925a99dfa86ca165caab7ceb03769deacf", "filename": "libgo/go/websocket/websocket_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -53,7 +53,7 @@ func TestEcho(t *testing.T) {\n \tonce.Do(startServer)\n \n \t// websocket.Dial()\n-\tclient, err := net.Dial(\"tcp\", \"\", serverAddr)\n+\tclient, err := net.Dial(\"tcp\", serverAddr)\n \tif err != nil {\n \t\tt.Fatal(\"dialing\", err)\n \t}\n@@ -84,7 +84,7 @@ func TestEchoDraft75(t *testing.T) {\n \tonce.Do(startServer)\n \n \t// websocket.Dial()\n-\tclient, err := net.Dial(\"tcp\", \"\", serverAddr)\n+\tclient, err := net.Dial(\"tcp\", serverAddr)\n \tif err != nil {\n \t\tt.Fatal(\"dialing\", err)\n \t}\n@@ -114,7 +114,7 @@ func TestEchoDraft75(t *testing.T) {\n func TestWithQuery(t *testing.T) {\n \tonce.Do(startServer)\n \n-\tclient, err := net.Dial(\"tcp\", \"\", serverAddr)\n+\tclient, err := net.Dial(\"tcp\", serverAddr)\n \tif err != nil {\n \t\tt.Fatal(\"dialing\", err)\n \t}\n@@ -131,7 +131,7 @@ func TestWithQuery(t *testing.T) {\n func TestWithProtocol(t *testing.T) {\n \tonce.Do(startServer)\n \n-\tclient, err := net.Dial(\"tcp\", \"\", serverAddr)\n+\tclient, err := net.Dial(\"tcp\", serverAddr)\n \tif err != nil {\n \t\tt.Fatal(\"dialing\", err)\n \t}\n@@ -200,7 +200,7 @@ func TestSmallBuffer(t *testing.T) {\n \tonce.Do(startServer)\n \n \t// websocket.Dial()\n-\tclient, err := net.Dial(\"tcp\", \"\", serverAddr)\n+\tclient, err := net.Dial(\"tcp\", serverAddr)\n \tif err != nil {\n \t\tt.Fatal(\"dialing\", err)\n \t}"}, {"sha": "28581a523e06c7c422f673ff5ec41d547f6f8eca", "filename": "libgo/syscalls/socket.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fsyscalls%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fsyscalls%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -208,6 +208,13 @@ func Listen(fd int, n int) (errno int) {\n   return;\n }\n \n+func GetsockoptInt(fd, level, opt int) (value, errno int) {\n+\tvar n int32\n+\tvallen := Socklen_t(4)\n+\terrno = libc_getsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&n)), &vallen)\n+\treturn int(n), errno\n+}\n+\n func setsockopt(fd, level, opt int, valueptr uintptr, length Socklen_t) (errno int) {\n   r := libc_setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(valueptr)),\n \t\t       length);\n@@ -383,5 +390,3 @@ func Shutdown(fd int, how int) (errno int) {\n \tif r < 0 { errno = GetErrno() }\n \treturn;\n }\n-\n-// FIXME: No getsockopt."}, {"sha": "46ac0e07e1d47ad93bd31096219fb029c188e067", "filename": "libgo/syscalls/sysfile_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fsyscalls%2Fsysfile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Fsyscalls%2Fsysfile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_posix.go?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -209,7 +209,7 @@ func FDZero(set *FdSet_t) {\n \n func Select(nfds int, r *FdSet_t, w *FdSet_t, e *FdSet_t, timeout *Timeval) (n int, errno int) {\n   n = libc_select(nfds, (*byte)(unsafe.Pointer(r)),\n-\t\t  (*byte)(unsafe.Pointer(e)),\n+\t\t  (*byte)(unsafe.Pointer(w)),\n \t\t  (*byte)(unsafe.Pointer(e)), timeout);\n   if n < 0 { errno = GetErrno() }\n   return;"}, {"sha": "bcd725136b9c38a0fabe516eeaa7dc65f202f036", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -357,7 +357,7 @@ case \"x$dejagnu\" in\n xno)\n \t${GC} -g -c _testmain.go\n \t${GL} *.o ${GOLIBS}\n-\t./a.out \"$@\"\n+\t./a.out -test.short \"$@\"\n \t;;\n xyes)\n \trm -rf ../testsuite/*.o"}, {"sha": "f201de7f76abbf990f3d28717e6f992a3a5126b6", "filename": "libgo/testsuite/libgo.testmain/testmain.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Ftestsuite%2Flibgo.testmain%2Ftestmain.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72f4169133572cf62f1e872c5657cdbc4d5de2c/libgo%2Ftestsuite%2Flibgo.testmain%2Ftestmain.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Flibgo.testmain%2Ftestmain.exp?ref=f72f4169133572cf62f1e872c5657cdbc4d5de2c", "patch": "@@ -54,7 +54,7 @@ if ![ string match \"\" $comp_output ] {\n     exit 1\n }\n \n-set result [libgo_load \"./a.exe\" \"\" \"\"]\n+set result [libgo_load \"./a.exe\" \"-test.short\" \"\"]\n \n set status [lindex $result 0]\n $status go"}]}