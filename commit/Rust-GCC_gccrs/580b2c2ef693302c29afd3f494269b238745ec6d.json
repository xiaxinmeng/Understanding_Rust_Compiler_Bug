{"sha": "580b2c2ef693302c29afd3f494269b238745ec6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgwYjJjMmVmNjkzMzAyYzI5YWZkM2Y0OTQyNjliMjM4NzQ1ZWM2ZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-10T09:27:31Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-10T09:27:31Z"}, "message": "tree-ssa-pre.c (alloc_expression_id): Fix use of VEC_reserve.\n\n\t* tree-ssa-pre.c (alloc_expression_id): Fix use of VEC_reserve.\n\t* tree-into-ssa.c (get_ssa_name_ann): Likewise.\n\t(mark_phi_for_rewrite): Likewise.\n\t(compute_global_livein): Use VEC_reserve outside the innermost\n\tloop and VEC_quick_push instead of VEC_safe_push in that loop.\n\t(update_ssa): Re-organize to avoid unnecessary sbitmap_zero'ing\n\tof new_ssa_names and old_ssa_names.  Allocate phis_to_rewrite to\n\tthe correct initial size.\n\nFrom-SVN: r190289", "tree": {"sha": "36d238929fded9774c6d13509cfb2761c743b8bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d238929fded9774c6d13509cfb2761c743b8bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/580b2c2ef693302c29afd3f494269b238745ec6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/580b2c2ef693302c29afd3f494269b238745ec6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/580b2c2ef693302c29afd3f494269b238745ec6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/580b2c2ef693302c29afd3f494269b238745ec6d/comments", "author": null, "committer": null, "parents": [{"sha": "83d5977e2f4747bbd33cc00a807e239d0b740895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d5977e2f4747bbd33cc00a807e239d0b740895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d5977e2f4747bbd33cc00a807e239d0b740895"}], "stats": {"total": 68, "additions": 45, "deletions": 23}, "files": [{"sha": "0ecb3c96692df18ecf228abfe472987a46458e2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/580b2c2ef693302c29afd3f494269b238745ec6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/580b2c2ef693302c29afd3f494269b238745ec6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=580b2c2ef693302c29afd3f494269b238745ec6d", "patch": "@@ -1,3 +1,14 @@\n+2012-08-10  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree-ssa-pre.c (alloc_expression_id): Fix use of VEC_reserve.\n+\t* tree-into-ssa.c (get_ssa_name_ann): Likewise.\n+\t(mark_phi_for_rewrite): Likewise.\n+\t(compute_global_livein): Use VEC_reserve outside the innermost\n+\tloop and VEC_quick_push instead of VEC_safe_push in that loop.\n+\t(update_ssa): Re-organize to avoid unnecessary sbitmap_zero'ing\n+\tof new_ssa_names and old_ssa_names.  Allocate phis_to_rewrite to\n+\tthe correct initial size.\n+\n 2012-08-10  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (pretemp, storetemp, prephitemp): Remove."}, {"sha": "e62e3fe35cca4a90b2b9f70b3222ef7811089143", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/580b2c2ef693302c29afd3f494269b238745ec6d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/580b2c2ef693302c29afd3f494269b238745ec6d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=580b2c2ef693302c29afd3f494269b238745ec6d", "patch": "@@ -101,6 +101,9 @@ sbitmap interesting_blocks;\n    released after we finish updating the SSA web.  */\n static bitmap names_to_release;\n \n+/* VEC of VECs of PHIs to rewrite in a basic block.  Element I corresponds\n+   the to basic block with index I.  Allocated once per compilation, *not*\n+   released between different functions.  */\n static VEC(gimple_vec, heap) *phis_to_rewrite;\n \n /* The bitmap of non-NULL elements of PHIS_TO_REWRITE.  */\n@@ -310,9 +313,11 @@ get_ssa_name_ann (tree name)\n \n   if (ver >= len)\n     {\n+      unsigned old_len = VEC_length (ssa_name_info_p, info_for_ssa_name);\n       unsigned new_len = num_ssa_names;\n \n-      VEC_reserve (ssa_name_info_p, heap, info_for_ssa_name, new_len);\n+      VEC_reserve (ssa_name_info_p, heap, info_for_ssa_name,\n+\t\t   new_len - old_len);\n       while (len++ < new_len)\n \t{\n \t  struct ssa_name_info *info = XCNEW (struct ssa_name_info);\n@@ -431,6 +436,10 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n       /* Pull a block off the worklist.  */\n       basic_block bb = VEC_pop (basic_block, worklist);\n \n+      /* Make sure we have at least enough room in the work list\n+\t for all predecessors of this block.  */\n+      VEC_reserve (basic_block, heap, worklist, EDGE_COUNT (bb->preds));\n+\n       /* For each predecessor block.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n@@ -442,7 +451,7 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n \t      && ! bitmap_bit_p (def_blocks, pred_index)\n \t      && bitmap_set_bit (livein, pred_index))\n \t    {\n-\t      VEC_safe_push (basic_block, heap, worklist, pred);\n+\t      VEC_quick_push (basic_block, worklist, pred);\n \t    }\n \t}\n     }\n@@ -970,7 +979,7 @@ static void\n mark_phi_for_rewrite (basic_block bb, gimple phi)\n {\n   gimple_vec phis;\n-  unsigned i, idx = bb->index;\n+  unsigned n, idx = bb->index;\n \n   if (rewrite_uses_p (phi))\n     return;\n@@ -981,9 +990,10 @@ mark_phi_for_rewrite (basic_block bb, gimple phi)\n     return;\n \n   bitmap_set_bit (blocks_with_phis_to_rewrite, idx);\n-  VEC_reserve (gimple_vec, heap, phis_to_rewrite, last_basic_block + 1);\n-  for (i = VEC_length (gimple_vec, phis_to_rewrite); i <= idx; i++)\n-    VEC_quick_push (gimple_vec, phis_to_rewrite, NULL);\n+\n+  n = (unsigned) last_basic_block + 1;\n+  if (VEC_length (gimple_vec, phis_to_rewrite) < n)\n+    VEC_safe_grow_cleared (gimple_vec, heap, phis_to_rewrite, n);\n \n   phis = VEC_index (gimple_vec, phis_to_rewrite, idx);\n   if (!phis)\n@@ -3166,6 +3176,12 @@ update_ssa (unsigned update_flags)\n   sbitmap_iterator sbi;\n   tree sym;\n \n+  /* Only one update flag should be set.  */\n+  gcc_assert (update_flags == TODO_update_ssa\n+              || update_flags == TODO_update_ssa_no_phi\n+\t      || update_flags == TODO_update_ssa_full_phi\n+\t      || update_flags == TODO_update_ssa_only_virtuals);\n+\n   if (!need_ssa_update_p (cfun))\n     return;\n \n@@ -3176,31 +3192,25 @@ update_ssa (unsigned update_flags)\n \n   if (!update_ssa_initialized_fn)\n     init_update_ssa (cfun);\n+  else if (update_flags == TODO_update_ssa_only_virtuals)\n+    {\n+      /* If we only need to update virtuals, remove all the mappings for\n+\t real names before proceeding.  The caller is responsible for\n+\t having dealt with the name mappings before calling update_ssa.  */\n+      sbitmap_zero (old_ssa_names);\n+      sbitmap_zero (new_ssa_names);\n+    }\n+\n   gcc_assert (update_ssa_initialized_fn == cfun);\n \n   blocks_with_phis_to_rewrite = BITMAP_ALLOC (NULL);\n   if (!phis_to_rewrite)\n-    phis_to_rewrite = VEC_alloc (gimple_vec, heap, last_basic_block);\n+    phis_to_rewrite = VEC_alloc (gimple_vec, heap, last_basic_block + 1);\n   blocks_to_update = BITMAP_ALLOC (NULL);\n \n   /* Ensure that the dominance information is up-to-date.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Only one update flag should be set.  */\n-  gcc_assert (update_flags == TODO_update_ssa\n-              || update_flags == TODO_update_ssa_no_phi\n-\t      || update_flags == TODO_update_ssa_full_phi\n-\t      || update_flags == TODO_update_ssa_only_virtuals);\n-\n-  /* If we only need to update virtuals, remove all the mappings for\n-     real names before proceeding.  The caller is responsible for\n-     having dealt with the name mappings before calling update_ssa.  */\n-  if (update_flags == TODO_update_ssa_only_virtuals)\n-    {\n-      sbitmap_zero (old_ssa_names);\n-      sbitmap_zero (new_ssa_names);\n-    }\n-\n   insert_phi_p = (update_flags != TODO_update_ssa_no_phi);\n \n   /* If there are names defined in the replacement table, prepare"}, {"sha": "9b186ddc577479f3dbb12782e9ec0c6308ec50f4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/580b2c2ef693302c29afd3f494269b238745ec6d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/580b2c2ef693302c29afd3f494269b238745ec6d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=580b2c2ef693302c29afd3f494269b238745ec6d", "patch": "@@ -249,7 +249,8 @@ alloc_expression_id (pre_expr expr)\n       /* VEC_safe_grow_cleared allocates no headroom.  Avoid frequent\n \t re-allocations by using VEC_reserve upfront.  There is no\n \t VEC_quick_grow_cleared unfortunately.  */\n-      VEC_reserve (unsigned, heap, name_to_id, num_ssa_names);\n+      unsigned old_len = VEC_length (unsigned, name_to_id);\n+      VEC_reserve (unsigned, heap, name_to_id, num_ssa_names - old_len);\n       VEC_safe_grow_cleared (unsigned, heap, name_to_id, num_ssa_names);\n       gcc_assert (VEC_index (unsigned, name_to_id, version) == 0);\n       VEC_replace (unsigned, name_to_id, version, expr->id);"}]}