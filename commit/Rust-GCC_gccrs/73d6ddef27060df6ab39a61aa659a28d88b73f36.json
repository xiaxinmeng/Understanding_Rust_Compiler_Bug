{"sha": "73d6ddef27060df6ab39a61aa659a28d88b73f36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNkNmRkZWYyNzA2MGRmNmFiMzlhNjFhYTY1OWEyOGQ4OGI3M2YzNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-07-03T13:51:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-07-03T13:51:51Z"}, "message": "gimplify.c (gimplify_conversion): Remove stripping useless conversions from here.\n\n\t* gimplify.c (gimplify_conversion): Remove stripping useless\n\tconversions from here.\n\t(gimplify_expr): Put it here, in place of call to STRIP_MAIN_TYPE_NOPS.\n\t(gimplify_modify_expr_to_memcpy, gimplify_variable_sized_compare):\n\tUnshare before substituting PLACEHOLDER_EXPR.\n\t(gimplify_modify_expr_to_memset): Likewise.\n\tPass address of TO to memset, not TO itself.\n\t(gimplify_init_constructor): Make copy of OBJECT so we have it each\n\ttime we make an expression (to match a PLACEHOLDER_EXPR).\n\nFrom-SVN: r84056", "tree": {"sha": "13502e09753764f145c7cb2614cac2d59631abee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13502e09753764f145c7cb2614cac2d59631abee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73d6ddef27060df6ab39a61aa659a28d88b73f36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d6ddef27060df6ab39a61aa659a28d88b73f36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73d6ddef27060df6ab39a61aa659a28d88b73f36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d6ddef27060df6ab39a61aa659a28d88b73f36/comments", "author": null, "committer": null, "parents": [{"sha": "580d124fe0265e81154d5fe07a40279418f048f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/580d124fe0265e81154d5fe07a40279418f048f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/580d124fe0265e81154d5fe07a40279418f048f8"}], "stats": {"total": 38, "additions": 24, "deletions": 14}, "files": [{"sha": "b9a289db11ae747ab93888b1af542b917d3710e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d6ddef27060df6ab39a61aa659a28d88b73f36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d6ddef27060df6ab39a61aa659a28d88b73f36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73d6ddef27060df6ab39a61aa659a28d88b73f36", "patch": "@@ -1,5 +1,15 @@\n 2004-07-03  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t\n+\t* gimplify.c (gimplify_conversion): Remove stripping useless\n+\tconversions from here.\n+\t(gimplify_expr): Put it here, in place of call to STRIP_MAIN_TYPE_NOPS.\n+\t(gimplify_modify_expr_to_memcpy, gimplify_variable_sized_compare):\n+\tUnshare before substituting PLACEHOLDER_EXPR.\n+\t(gimplify_modify_expr_to_memset): Likewise.\n+\tPass address of TO to memset, not TO itself.\n+\t(gimplify_init_constructor): Make copy of OBJECT so we have it each\n+\ttime we make an expression (to match a PLACEHOLDER_EXPR).\n+\n \t* tree-ssa.c (tree_ssa_useless_type_conversion): Also look at\n \tVIEW_CONVERT_EXPR and NON_LVALUE_EXPR.\n \t* tree-ssa-ccp.c (fold_stmt): Call just STRIP_USELESS_TYPE_CONVERSION."}, {"sha": "f6a35bdff00b142b53bee137e8e9d2af3df9dd5e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73d6ddef27060df6ab39a61aa659a28d88b73f36/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73d6ddef27060df6ab39a61aa659a28d88b73f36/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=73d6ddef27060df6ab39a61aa659a28d88b73f36", "patch": "@@ -1422,10 +1422,6 @@ canonicalize_addr_expr (tree *expr_p)\n static enum gimplify_status\n gimplify_conversion (tree *expr_p)\n {  \n-  /* Strip away as many useless type conversions as possible\n-     at the toplevel.  */\n-  STRIP_USELESS_TYPE_CONVERSION (*expr_p);\n-\n   /* If we still have a conversion at the toplevel, then strip\n      away all but the outermost conversion.  */\n   if (TREE_CODE (*expr_p) == NOP_EXPR || TREE_CODE (*expr_p) == CONVERT_EXPR)\n@@ -2326,9 +2322,9 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, bool want_value)\n   from = TREE_OPERAND (*expr_p, 1);\n \n   t = TYPE_SIZE_UNIT (TREE_TYPE (to));\n+  t = unshare_expr (t);\n   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, from);\n-  t = unshare_expr (t);\n   args = tree_cons (NULL, t, NULL);\n \n   t = build_fold_addr_expr (from);\n@@ -2361,14 +2357,14 @@ gimplify_modify_expr_to_memset (tree *expr_p, bool want_value)\n   to = TREE_OPERAND (*expr_p, 0);\n \n   t = TYPE_SIZE_UNIT (TREE_TYPE (to));\n-  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n   t = unshare_expr (t);\n+  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n   args = tree_cons (NULL, t, NULL);\n \n   args = tree_cons (NULL, integer_zero_node, args);\n \n   to_ptr = build_fold_addr_expr (to);\n-  args = tree_cons (NULL, to, args);\n+  args = tree_cons (NULL, to_ptr, args);\n   t = implicit_built_in_decls[BUILT_IN_MEMSET];\n   t = build_function_call_expr (t, args);\n \n@@ -2539,8 +2535,11 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t  {\n \t    /* Zap the CONSTRUCTOR element list, which simplifies this case.\n \t       Note that we still have to gimplify, in order to handle the\n-\t       case of variable sized types.  */\n+\t       case of variable sized types.  Make an unshared copy of\n+\t       OBJECT before that so we can match a PLACEHOLDER_EXPR to it\n+\t       later, if needed.  */\n \t    CONSTRUCTOR_ELTS (ctor) = NULL_TREE;\n+\t    object = unshare_expr (TREE_OPERAND (*expr_p, 0));\n \t    gimplify_stmt (expr_p);\n \t    append_to_statement_list (*expr_p, pre_p);\n \t  }\n@@ -2568,12 +2567,12 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\tif (TREE_CODE (purpose) == RANGE_EXPR)\n \t\t  abort ();\n \n-\t\tcref = build (ARRAY_REF, t, object, purpose,\n+\t\tcref = build (ARRAY_REF, t, unshare_expr (object), purpose,\n \t\t\t      NULL_TREE, NULL_TREE);\n \t      }\n \t    else\n-\t      cref = build (COMPONENT_REF, TREE_TYPE (purpose), object,\n-\t\t\t    purpose, NULL_TREE);\n+\t      cref = build (COMPONENT_REF, TREE_TYPE (purpose),\n+\t\t\t    unshare_expr (object), purpose, NULL_TREE);\n \n \t    init = build (MODIFY_EXPR, TREE_TYPE (purpose), cref, value);\n \n@@ -2845,8 +2844,8 @@ gimplify_variable_sized_compare (tree *expr_p)\n   tree args, t, dest;\n \n   t = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n-  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, op0);\n   t = unshare_expr (t);\n+  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, op0);\n   args = tree_cons (NULL, t, NULL);\n   t = build_fold_addr_expr (op1);\n   args = tree_cons (NULL, t, args);\n@@ -3463,8 +3462,9 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n      remains the same.  */\n   do\n     {\n-      /* Strip any uselessness.  */\n-      STRIP_MAIN_TYPE_NOPS (*expr_p);\n+      /* Strip away as many useless type conversions as possible\n+\t at the toplevel.  */\n+      STRIP_USELESS_TYPE_CONVERSION (*expr_p);\n \n       /* Remember the expr.  */\n       save_expr = *expr_p;"}]}