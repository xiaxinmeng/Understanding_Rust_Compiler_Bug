{"sha": "a28e3c7f21098041386f8c52962ac75781849d95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4ZTNjN2YyMTA5ODA0MTM4NmY4YzUyOTYyYWM3NTc4MTg0OWQ5NQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-15T01:44:15Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-15T01:44:15Z"}, "message": "32nd Cygnus<->FSF merge\n\nFrom-SVN: r7047", "tree": {"sha": "28f66434ed97386036e735c594470694d75a02c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28f66434ed97386036e735c594470694d75a02c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a28e3c7f21098041386f8c52962ac75781849d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28e3c7f21098041386f8c52962ac75781849d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28e3c7f21098041386f8c52962ac75781849d95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28e3c7f21098041386f8c52962ac75781849d95/comments", "author": null, "committer": null, "parents": [{"sha": "7062b881467ee80ba7ddfe5fa46540c425d47ad8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7062b881467ee80ba7ddfe5fa46540c425d47ad8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7062b881467ee80ba7ddfe5fa46540c425d47ad8"}], "stats": {"total": 2603, "additions": 921, "deletions": 1682}, "files": [{"sha": "9b5b508570b9918ba3e7f8ab7f8c58d4681f718f", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -200,7 +200,7 @@ parse.o : $(srcdir)/parse.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h lex.h\n   `echo $(srcdir)/parse.c | sed 's,^\\./,,'`\n \n $(srcdir)/parse.c $(srcdir)/parse.h : $(srcdir)/parse.y\n-\t@echo expect 24 reduce/reduce conflicts.\n+\t@echo expect 33 reduce/reduce conflicts.\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n "}, {"sha": "261b16b24eabab91e3276076a8a57b45cfc24cac", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -2673,10 +2673,7 @@ build_scoped_method_call (exp, scopes, name, parms)\n \t{\n \t  /* Explicit call to destructor.  */\n \t  name = TREE_OPERAND (name, 0);\n-\t  if (TREE_TYPE (decl) !=\n-\t      (IDENTIFIER_CLASS_VALUE (name)\n-\t       ? IDENTIFIER_CLASS_TYPE_VALUE (name)\n-\t       : IDENTIFIER_TYPE_VALUE (name)))\n+\t  if (name != constructor_name (TREE_TYPE (decl)))\n \t    {\n \t      cp_error\n \t\t(\"qualified type `%T' does not match destructor type `%T'\",\n@@ -2808,6 +2805,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       /* If it doesn't work, two argument delete must work */\n       TREE_CHAIN (parms) = save_last;\n     }\n+  /* We already know whether it's needed or not for vec delete.  */\n+  else if (name == ansi_opname[(int) VEC_DELETE_EXPR]\n+\t   && ! TYPE_VEC_DELETE_TAKES_SIZE (TREE_TYPE (instance)))\n+    TREE_CHAIN (parms) = NULL_TREE;\n \n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {"}, {"sha": "b60cdec641f00fe3a05bece5be4efbb91cf652a5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -2494,7 +2494,9 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \n \t      for (x = *testp; x; x = DECL_CHAIN (x))\n \t\t{\n-\t\t  if (DECL_NAME (fn_fields) == ansi_opname[(int) DELETE_EXPR])\n+\t\t  if (DECL_NAME (fn_fields) == ansi_opname[(int) DELETE_EXPR]\n+\t\t      || DECL_NAME (fn_fields)\n+\t\t         == ansi_opname[(int) VEC_DELETE_EXPR])\n \t\t    {\n \t\t      /* ANSI C++ June 5 1992 WP 12.5.5.1 */\n \t\t      cp_error_at (\"`%D' overloaded\", fn_fields);\n@@ -4149,8 +4151,10 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   else if (flag_dossier && ! CLASSTYPE_DOSSIER (t))\n     build_t_desc (t, 1);\n \n+#if 0\n   if (TYPE_NAME (t) && TYPE_IDENTIFIER (t))\n     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);\n+#endif\n   if (current_class_type)\n     popclass (0);\n   else\n@@ -4426,10 +4430,7 @@ pushclass (type, modify)\n \tcurrent_function_decl = NULL_TREE;\n \n       if (TREE_CODE (type) == UNINSTANTIATED_P_TYPE)\n-        {\n-          declare_uninstantiated_type_level ();\n-\t  overload_template_name (current_class_name, 0);\n-        }\n+\tdeclare_uninstantiated_type_level ();\n       else if (type != previous_class_type || current_class_depth > 1)\n \t{\n \t  build_mi_matrix (type);\n@@ -4457,6 +4458,9 @@ pushclass (type, modify)\n \t  unuse_fields (type);\n \t}\n \n+      if (IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (type)))\n+\toverload_template_name (current_class_name, 0);\n+\n       for (tags = CLASSTYPE_TAGS (type); tags; tags = TREE_CHAIN (tags))\n \t{\n \t  TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 1;\n@@ -4513,9 +4517,9 @@ popclass (modify)\n \t  TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n \t  tags = TREE_CHAIN (tags);\n \t}\n+      if (IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (current_class_type)))\n+\tundo_template_name_overload (current_class_name, 0);\n     }\n-  if (TREE_CODE (current_class_type) == UNINSTANTIATED_P_TYPE)\n-    undo_template_name_overload (current_class_name, 0);\n \n   poplevel_class ();\n \n@@ -4583,7 +4587,12 @@ push_nested_class (type, modify)\n      tree type;\n      int modify;\n {\n-  tree context = DECL_CONTEXT (TYPE_NAME (type));\n+  tree context;\n+\n+  if (type == error_mark_node || ! IS_AGGR_TYPE (type))\n+    return;\n+  \n+  context = DECL_CONTEXT (TYPE_NAME (type));\n \n   if (context && TREE_CODE (context) == RECORD_TYPE)\n     push_nested_class (context, 2);"}, {"sha": "4f73664f24a7bcd1807825ace4fc1402374d3470", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -32,6 +32,7 @@ DEFTREECODE (CP_OFFSET_REF, \"cp_offset_ref\", \"r\", 2)\n    Operand 1 is the value to pass to the destroying function\n    saying whether the store should be deallocated as well.  */\n DEFTREECODE (DELETE_EXPR, \"dl_expr\", \"e\", 2)\n+DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", \"e\", 2)\n \n /* Value is reference to particular overloaded class method.\n    Operand 0 is the class name (an IDENTIFIER_NODE);\n@@ -52,6 +53,7 @@ DEFTREECODE (TYPE_EXPR, \"type_expr\", \"e\", 1)\n    operand 1 is argument list to initialization function,\n    and operand 2 is the slot which was allocated for this expression.  */\n DEFTREECODE (NEW_EXPR, \"nw_expr\", \"e\", 3)\n+DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", \"e\", 3)\n \n /* Distinguish variables that are only used to identify exceptions\n    that were caught.  Only the DECL_NAME (and TREE_CHAIN)"}, {"sha": "1fb1bb17da07562af3051cd02b5c7563b5984e77", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -68,10 +68,6 @@ struct lang_id2\n #define IDENTIFIER_TYPE_VALUE(NODE) (TREE_TYPE (NODE))\n #define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = TYPE)\n #define IDENTIFIER_HAS_TYPE_VALUE(NODE) (TREE_TYPE (NODE) ? 1 : 0)\n-#define IDENTIFIER_HAS_CLASS_TYPE_VALUE(NODE) \\\n-  (IDENTIFIER_CLASS_VALUE (NODE) && TREE_TYPE (IDENTIFIER_CLASS_VALUE (NODE)))\n-#define IDENTIFIER_CLASS_TYPE_VALUE(NODE) \\\n-  TREE_TYPE (IDENTIFIER_CLASS_VALUE (NODE))\n \n #define LANG_ID_FIELD(NAME,NODE) \\\n   (((struct lang_identifier *)(NODE))->x \\\n@@ -325,7 +321,7 @@ enum languages { lang_c, lang_cplusplus };\n #define TYPE_ASSEMBLER_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (TYPE_NAME (NODE))))\n \n #define IS_AGGR_TYPE(t)\t\t(TYPE_LANG_FLAG_5 (t))\n-#define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE)\n+#define IS_AGGR_TYPE_CODE(t)\t(t == RECORD_TYPE || t == UNION_TYPE || t == UNINSTANTIATED_P_TYPE)\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n   (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n    && IS_AGGR_TYPE (TYPE1)&IS_AGGR_TYPE (TYPE2))\n@@ -395,56 +391,56 @@ struct lang_type\n       unsigned vtable_needs_writing : 1;\n \n       unsigned has_assign_ref : 1;\n-      unsigned gets_new : 1;\n-      unsigned gets_placed_new : 1;\n-      unsigned gets_delete : 1;\n+      unsigned gets_new : 2;\n+      unsigned gets_delete : 2;\n       unsigned has_call_overloaded : 1;\n       unsigned has_array_ref_overloaded : 1;\n       unsigned has_arrow_overloaded : 1;\n-      unsigned local_typedecls : 1;\n \n+      unsigned local_typedecls : 1;\n       unsigned interface_only : 1;\n       unsigned interface_unknown : 1;\n       unsigned needs_virtual_reinit : 1;\n       unsigned declared_exception : 1;\n       unsigned declared_class : 1;\n       unsigned being_defined : 1;\n       unsigned redefined : 1;\n-      unsigned no_globalize : 1;\n \n+      unsigned no_globalize : 1;\n       unsigned marked : 1;\n       unsigned marked2 : 1;\n       unsigned marked3 : 1;\n       unsigned marked4 : 1;\n       unsigned marked5 : 1;\n       unsigned marked6 : 1;\n-      unsigned use_template : 2;\n \n+      unsigned use_template : 2;\n       unsigned debug_requested : 1;\n       unsigned has_method_call_overloaded : 1;\n       unsigned private_attr : 1;\n       unsigned got_semicolon : 1;\n       unsigned ptrmemfunc_flag : 1;\n       unsigned is_signature : 1;\n       unsigned is_signature_pointer : 1;\n-      unsigned is_signature_reference : 1;\n \n+      unsigned is_signature_reference : 1;\n       unsigned has_default_implementation : 1;\n       unsigned grokking_typedef : 1;\n       unsigned has_opaque_typedecls : 1;\n       unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n       unsigned has_real_assignment : 1;\n       unsigned has_real_assign_ref : 1;\n+\n       unsigned has_const_init_ref : 1;\n-      \n       unsigned has_complex_init_ref : 1;\n       unsigned has_complex_assign_ref : 1;\n+      unsigned vec_delete_takes_size : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 22;\n+      unsigned dummy : 20;\n \n       unsigned n_vancestors : 16;\n     } type_flags;\n@@ -519,9 +515,17 @@ struct lang_type\n \n /* Nonzero for _CLASSTYPE means that operator new and delete are defined,\n    respectively.  */\n-#define TREE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_new)\n-#define TREE_GETS_PLACED_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_placed_new)\n-#define TREE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_delete)\n+#define TYPE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_new)\n+#define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_delete)\n+#define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n+\n+/* Nonzero for _CLASSTYPE means that operator vec delete is defined and\n+   takes the optional size_t argument.  */\n+#define TYPE_VEC_DELETE_TAKES_SIZE(NODE) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->type_flags.vec_delete_takes_size)\n+#define TYPE_VEC_NEW_USES_COOKIE(NODE) \\\n+  (TYPE_NEEDS_DESTRUCTOR (NODE) \\\n+   || (TYPE_LANG_SPECIFIC (NODE) && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n \n /* Nonzero for TREE_LIST or _TYPE node means that this node is class-local.  */\n #define TREE_NONLOCAL_FLAG(NODE) (TREE_LANG_FLAG_0 (NODE))\n@@ -1972,7 +1976,7 @@ extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPROTO((tree, tree, int, tree));\n extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));\n extern tree build_vbase_delete\t\t\tPROTO((tree, tree));\n-extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n+extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, tree, int));\n \n /* in input.c */\n \n@@ -2081,6 +2085,7 @@ extern int do_pending_expansions\t\tPROTO((void));\n extern void do_pending_templates\t\tPROTO((void));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void do_function_instantiation\t\tPROTO((tree, tree));\n+extern tree create_nested_upt\t\t\tPROTO((tree, tree));\n \n /* in search.c */\n extern tree make_memoized_table_entry\t\tPROTO((tree, tree, int));\n@@ -2092,6 +2097,7 @@ extern enum access_type compute_access\t\tPROTO((tree, tree));\n extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n+extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));\n extern HOST_WIDE_INT breadth_first_search\tPROTO((tree, int (*)(), int (*)()));\n extern int tree_needs_constructor_p\t\tPROTO((tree, int));\n extern int tree_has_any_destructor_p\t\tPROTO((tree, int));\n@@ -2193,6 +2199,7 @@ extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n extern tree common_base_types\t\t\tPROTO((tree, tree));\n extern int compparms\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n+extern int self_promoting_args_p\t\tPROTO((tree));\n extern tree unsigned_type\t\t\tPROTO((tree));\n extern tree signed_type\t\t\t\tPROTO((tree));\n extern tree signed_or_unsigned_type\t\tPROTO((int, tree));"}, {"sha": "d19354d33ae0c6c065e57e81f7cebcc59f57faa8", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -720,8 +720,16 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n     {\n       /* When casting an lvalue to a reference type, just convert into\n \t a pointer to the new type and deference it.  This is allowed\n-\t by San Diego WP section 5.2.8 paragraph 9, though perhaps it\n+\t by San Diego WP section 5.2.9 paragraph 12, though perhaps it\n \t should be done directly (jason).  (int &)ri ---> *(int*)&ri */\n+\n+      /* B* bp; A& ar = (A&)bp; is legal, but it's probably not what they\n+         meant.  */\n+      if (form == POINTER_TYPE\n+\t  && (comptypes (TREE_TYPE (intype), type, strict)))\n+\tcp_warning (\"casting `%T' to `%T' does not dereference pointer\",\n+\t\t    intype, reftype);\n+\t  \n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n       if (rval != error_mark_node)\n \trval = convert_force (build_pointer_type (TREE_TYPE (reftype)), rval);\n@@ -744,6 +752,7 @@ convert_to_reference (decl, reftype, expr, fndecl, parmnum,\n       \n       /* Definitely need to go through a constructor here.  */\n       if (TYPE_HAS_CONSTRUCTOR (type)\n+\t  && ! CLASSTYPE_ABSTRACT_VIRTUALS (type)\n \t  && (rval = build_method_call\n \t      (NULL_TREE, constructor_name_full (type),\n \t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (type),"}, {"sha": "3dce83c650eb8e81f30acd09d50283e19f8c83ac", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 264, "deletions": 157, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -1964,7 +1964,8 @@ decls_match (newdecl, olddecl)\n {\n   int types_match;\n \n-  if (TREE_CODE (newdecl) == FUNCTION_DECL && TREE_CODE (olddecl) == FUNCTION_DECL)\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL\n+      && TREE_CODE (olddecl) == FUNCTION_DECL)\n     {\n       tree f1 = TREE_TYPE (newdecl);\n       tree f2 = TREE_TYPE (olddecl);\n@@ -1997,10 +1998,19 @@ decls_match (newdecl, olddecl)\n       if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (f1)),\n \t\t     TYPE_MAIN_VARIANT (TREE_TYPE (f2)), 2))\n \t{\n-\t  if (DECL_LANGUAGE (olddecl) == lang_c\n-\t      && ! strict_prototypes_lang_c\n+\t  if (! strict_prototypes_lang_c && DECL_LANGUAGE (olddecl) == lang_c\n \t      && p2 == NULL_TREE)\n-\t    types_match = self_promoting_args_p (p1);\n+\t    {\n+\t      types_match = self_promoting_args_p (p1);\n+\t      if (p1 == void_list_node)\n+\t\tTREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n+\t    }\n+\t  else if (!strict_prototypes_lang_c && DECL_LANGUAGE (olddecl)==lang_c\n+\t\t   && DECL_LANGUAGE (newdecl) == lang_c && p1 == NULL_TREE)\n+\t    {\n+\t      types_match = self_promoting_args_p (p2);\n+\t      TREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n+\t    }\n \t  else\n \t    types_match = compparms (p1, p2, 1);\n \t}\n@@ -2249,12 +2259,7 @@ duplicate_decls (newdecl, olddecl)\n \t     int foo () { bar (); }\n \t     is OK.  */\n \t  if (current_lang_stack == current_lang_base)\n-\t    {\n-\t      DECL_LANGUAGE (newdecl) = DECL_LANGUAGE (olddecl);\n-\t      if (TYPE_ARG_TYPES (TREE_TYPE (olddecl)) == NULL_TREE\n-\t\t  && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) == void_list_node)\n-\t\tTREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n-\t    }\n+\t    DECL_LANGUAGE (newdecl) = DECL_LANGUAGE (olddecl);\n \t  else\n \t    {\n \t      cp_error_at (\"previous declaration of `%#D' with %L linkage\",\n@@ -2268,7 +2273,8 @@ duplicate_decls (newdecl, olddecl)\n       if (pedantic\n \t  && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n \t      || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))\n-\tcp_error_at (\"type qualifiers for `%D' conflict with previous decl\", newdecl);\n+\tcp_error_at (\"type qualifiers for `%D' conflict with previous decl\",\n+\t\t     newdecl);\n     }\n \n   /* If new decl is `static' and an `extern' was seen previously,\n@@ -2318,7 +2324,8 @@ duplicate_decls (newdecl, olddecl)\n \t\t} Thing;\n       */\n #if 0\n-      my_friendly_assert (DECL_IGNORED_P (olddecl) == DECL_IGNORED_P (newdecl), 139);\n+      my_friendly_assert (DECL_IGNORED_P (olddecl) == DECL_IGNORED_P (newdecl),\n+\t\t\t  139);\n #endif\n     }\n \n@@ -2363,9 +2370,10 @@ duplicate_decls (newdecl, olddecl)\n \t  TREE_TYPE (olddecl) = build_exception_variant (ctype, newtype,\n \t\t\t\t\t\t\t TYPE_RAISES_EXCEPTIONS (oldtype));\n \n-\t  if (! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE(olddecl), 0))\n+\t  if (! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 0))\n \t    {\n-\t      cp_error (\"declaration of `%D' raises different exceptions...\", newdecl);\n+\t      cp_error (\"declaration of `%D' raises different exceptions...\",\n+\t\t\tnewdecl);\n \t      cp_error_at (\"...from previous declaration here\", olddecl);\n \t    }\n \t}\n@@ -2683,7 +2691,8 @@ pushdecl (x)\n \n \t\t  if (extra_warnings)\n \t\t    {\n-\t\t      cp_warning (\"`static' missing from declaration of `%D'\", t);\n+\t\t      cp_warning (\"`static' missing from declaration of `%D'\",\n+\t\t\t\t  t);\n \t\t      warning_with_file_and_line (file, line,\n \t\t\t\t\t\t  \"previous declaration of `%s'\",\n \t\t\t\t\t\t  decl_as_string (t, 0));\n@@ -3176,8 +3185,11 @@ push_overloaded_decl (decl, forgettable)\n \t    {\n \t      if (decl == tmp || duplicate_decls (decl, tmp))\n \t\treturn tmp;\n-\t      if (compparms (TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t     TYPE_ARG_TYPES (TREE_TYPE (tmp)), 2))\n+\t      /* Avoid doing things about built-ins, since duplicate_decls\n+\t\t will have given warnings/errors for them.  */\n+\t      if (!DECL_BUILT_IN (tmp) && !DECL_BUILT_IN_NONANSI (tmp)\n+\t\t  && compparms (TYPE_ARG_TYPES (TREE_TYPE (decl)),\n+\t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmp)), 2))\n \t\t{\n \t\t  cp_error (\"new declaration `%#D'\", decl);\n \t\t  cp_error_at (\"ambiguates old declaration `%#D'\", tmp);\n@@ -3762,7 +3774,8 @@ lookup_nested_type (type, context)\n \t  }\n \t  break;\n \tcase FUNCTION_DECL:\n-\t  return TYPE_IDENTIFIER (type) ? lookup_name (TYPE_IDENTIFIER (type), 1) : NULL_TREE;\n+\t  return TYPE_IDENTIFIER (type) ?\n+\t    lookup_name (TYPE_IDENTIFIER (type), 1) : NULL_TREE;\n \t  break;\n \tdefault:\n \t  my_friendly_abort (12);\n@@ -3778,6 +3791,7 @@ lookup_nested_type (type, context)\n    definitions if there are many, or return 0 if it is undefined.\n \n    If PREFER_TYPE is > 0, we prefer TYPE_DECLs.\n+   If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n    Otherwise we prefer non-TYPE_DECLs.  */\n \n tree\n@@ -3786,7 +3800,43 @@ lookup_name (name, prefer_type)\n      int prefer_type;\n {\n   register tree val;\n+  int yylex = 0;\n \n+  if (prefer_type == -2)\n+    {\n+      extern int looking_for_typename;\n+\n+      yylex = 1;\n+      prefer_type = looking_for_typename;\n+      \n+      if (got_scope != NULL_TREE)\n+\t{\n+\t  if (got_scope == void_type_node)\n+\t    val = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  else if (TREE_CODE (got_scope) == TEMPLATE_TYPE_PARM\n+\t\t   /* TFIXME -- don't do this for UPTs in new model.  */\n+\t\t   || TREE_CODE (got_scope) == UNINSTANTIATED_P_TYPE)\n+\t    {\n+\t      if (prefer_type > 0)\n+\t\tval = create_nested_upt (got_scope, name);\n+\t      else\n+\t\tval = NULL_TREE;\n+\t    }\n+\t  else if (! IS_AGGR_TYPE (got_scope))\n+\t    /* Someone else will give an error about this if needed. */\n+\t    val = NULL_TREE;\n+\t  else if (got_scope == current_class_type)\n+\t    val = IDENTIFIER_CLASS_VALUE (name);\n+\t  else if (TYPE_BEING_DEFINED (got_scope))\n+\t    val = lookup_nested_tag (got_scope, name);\n+\t  else\n+\t    val = lookup_field (got_scope, name, 0, 0);\n+\n+\t  got_scope = NULL_TREE;\n+\t  goto done;\n+\t}\n+    }\n+    \n   if (current_binding_level != global_binding_level\n       && IDENTIFIER_LOCAL_VALUE (name))\n     val = IDENTIFIER_LOCAL_VALUE (name);\n@@ -3802,7 +3852,7 @@ lookup_name (name, prefer_type)\n \t  /* Try to find values from base classes\n \t     if we are presently defining a type.\n \t     We are presently only interested in TYPE_DECLs.  */\n-\t  val = lookup_field (current_class_type, name, 0, prefer_type < 0);\n+\t  val = lookup_field (current_class_type, name, 0, 1);\n \t  if (val == error_mark_node)\n \t    return val;\n \t  if (val && TREE_CODE (val) != TYPE_DECL)\n@@ -3813,29 +3863,27 @@ lookup_name (name, prefer_type)\n \t the nested name at the point where we haven't even, for example,\n \t created the COMPONENT_REF or anything like that.  */\n       if (val == NULL_TREE)\n-\tval = lookup_nested_field (name, prefer_type != -2);\n+\tval = lookup_nested_field (name, ! yylex);\n \n       if (val == NULL_TREE)\n \tval = IDENTIFIER_GLOBAL_VALUE (name);\n     }\n   else\n     val = IDENTIFIER_GLOBAL_VALUE (name);\n \n+ done:\n   if (val)\n     {\n-      extern int looking_for_typename;\n-\n       /* Arbitrate between finding a TYPE_DECL and finding\n \t other kinds of _DECLs.  */\n-      if (TREE_CODE (val) == TYPE_DECL || looking_for_typename < 0)\n+      if (TREE_CODE (val) == TYPE_DECL || prefer_type < 0)\n \treturn val;\n \n       if (IDENTIFIER_HAS_TYPE_VALUE (name))\n \t{\n \t  register tree val_as_type = TYPE_NAME (IDENTIFIER_TYPE_VALUE (name));\n \n-\t  if (val == val_as_type || prefer_type > 0\n-\t      || looking_for_typename > 0)\n+\t  if (val == val_as_type || prefer_type > 0)\n \t    return val_as_type;\n \n \t  return val;\n@@ -4088,7 +4136,8 @@ init_decl_processing ()\n   error_mark_list = build_tree_list (error_mark_node, error_mark_node);\n   TREE_TYPE (error_mark_list) = error_mark_node;\n \n-  pushlevel (0);\t/* make the binding_level structure for global names.  */\n+  /* Make the binding_level structure for global names.  */\n+  pushlevel (0);\n   global_binding_level = current_binding_level;\n \n   this_identifier = get_identifier (THIS_NAME);\n@@ -4229,7 +4278,8 @@ init_decl_processing ()\n   TREE_TYPE (void_zero_node) = void_type_node;\n \n   string_type_node = build_pointer_type (char_type_node);\n-  const_string_type_node = build_pointer_type (build_type_variant (char_type_node, 1, 0));\n+  const_string_type_node =\n+    build_pointer_type (build_type_variant (char_type_node, 1, 0));\n   record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n \n   /* Make a type to be the domain of a few array types\n@@ -4257,7 +4307,8 @@ init_decl_processing ()\n   build_pointer_type (default_function_type);\n \n   ptr_type_node = build_pointer_type (void_type_node);\n-  const_ptr_type_node = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n+  const_ptr_type_node =\n+    build_pointer_type (build_type_variant (void_type_node, 1, 0));\n   record_builtin_type (RID_MAX, NULL_PTR, ptr_type_node);\n   endlink = void_list_node;\n   int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);\n@@ -4269,14 +4320,16 @@ init_decl_processing ()\n \n   double_ftype_double_double\n     = build_function_type (double_type_node,\n-\t\t\t   tree_cons (NULL_TREE, double_type_node, double_endlink));\n+\t\t\t   tree_cons (NULL_TREE, double_type_node,\n+\t\t\t\t      double_endlink));\n \n   int_ftype_int\n     = build_function_type (integer_type_node, int_endlink);\n \n   long_ftype_long\n     = build_function_type (long_integer_type_node,\n-\t\t\t   tree_cons (NULL_TREE, long_integer_type_node, endlink));\n+\t\t\t   tree_cons (NULL_TREE, long_integer_type_node,\n+\t\t\t\t      endlink));\n \n   void_ftype_ptr_ptr_int\n     = build_function_type (void_type_node,\n@@ -4466,7 +4519,8 @@ init_decl_processing ()\n       builtin_function (\"memcmp\", int_ftype_cptr_cptr_sizet, BUILT_IN_MEMCMP,\n \t\t\tNULL_PTR);\n       builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP, NULL_PTR);\n-      builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY, NULL_PTR);\n+      builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY,\n+\t\t\tNULL_PTR);\n #if 0\n       /* Not yet.  */\n       builtin_function (\"strncpy\", strncpy_ftype, BUILT_IN_STRNCPY, NULL_PTR);\n@@ -4481,13 +4535,19 @@ init_decl_processing ()\n      or build_function_call.  */\n   builtin_function (\"__builtin_div\", default_ftype, BUILT_IN_DIV, 0);\n   builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV, 0);\n-  builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR, 0);\n+  builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR,\n+\t\t    0);\n   builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL, 0);\n-  builtin_function (\"__builtin_fmod\", double_ftype_double_double, BUILT_IN_FMOD, 0);\n-  builtin_function (\"__builtin_frem\", double_ftype_double_double, BUILT_IN_FREM, 0);\n-  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET, 0);\n-  builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP, 0);\n-  builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN, 0);\n+  builtin_function (\"__builtin_fmod\", double_ftype_double_double,\n+\t\t    BUILT_IN_FMOD, 0);\n+  builtin_function (\"__builtin_frem\", double_ftype_double_double,\n+\t\t    BUILT_IN_FREM, 0);\n+  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET,\n+\t\t    0);\n+  builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP,\n+\t\t    0);\n+  builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN,\n+\t\t    0);\n #endif\n \n   /* C++ extensions */\n@@ -4507,7 +4567,7 @@ init_decl_processing ()\n   TYPE_MODE (unknown_type_node) = TYPE_MODE (void_type_node);\n   /* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */\n   TREE_TYPE (unknown_type_node) = unknown_type_node;\n-  /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result.  */\n+  /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result. */\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n@@ -4544,9 +4604,12 @@ init_decl_processing ()\n      fields names so that the debugger can use them.  */\n \n   memptr_type = make_lang_type (RECORD_TYPE);\n-  fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier, delta_type_node);\n-  fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier, delta_type_node);\n-  fields[2] = build_lang_field_decl (FIELD_DECL, pfn_identifier, ptr_type_node);\n+  fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t     delta_type_node);\n+  fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier,\n+\t\t\t\t     delta_type_node);\n+  fields[2] = build_lang_field_decl (FIELD_DECL, pfn_identifier,\n+\t\t\t\t     ptr_type_node);\n   finish_builtin_type (memptr_type, VTBL_PTR_TYPE, fields, 2,\n \t\t       double_type_node);\n \n@@ -4588,9 +4651,15 @@ init_decl_processing ()\n   if (flag_handle_signatures)\n     {\n       sigtable_entry_type = make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (SIGTABLE_CODE_NAME), short_integer_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (SIGTABLE_OFFSET_NAME), short_integer_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (SIGTABLE_PFN_NAME), ptr_type_node);\n+      fields[0] = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t\t get_identifier (SIGTABLE_CODE_NAME),\n+\t\t\t\t\t short_integer_type_node);\n+      fields[1] = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t\t get_identifier (SIGTABLE_OFFSET_NAME),\n+\t\t\t\t\t short_integer_type_node);\n+      fields[2] = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t\t get_identifier (SIGTABLE_PFN_NAME),\n+\t\t\t\t\t ptr_type_node);\n       finish_builtin_type (sigtable_entry_type, SIGTABLE_PTR_TYPE, fields, 2,\n \t\t\t   double_type_node);\n       sigtable_entry_type = build_type_variant (sigtable_entry_type, 1, 0);\n@@ -4620,17 +4689,21 @@ init_decl_processing ()\n       __t_desc_type_node = make_lang_type (RECORD_TYPE);\n       __i_desc_type_node = make_lang_type (RECORD_TYPE);\n       __m_desc_type_node = make_lang_type (RECORD_TYPE);\n-      __t_desc_array_type = build_array_type (TYPE_POINTER_TO (__t_desc_type_node), NULL_TREE);\n-      __i_desc_array_type = build_array_type (TYPE_POINTER_TO (__i_desc_type_node), NULL_TREE);\n-      __m_desc_array_type = build_array_type (TYPE_POINTER_TO (__m_desc_type_node), NULL_TREE);\n+      __t_desc_array_type =\n+\tbuild_array_type (TYPE_POINTER_TO (__t_desc_type_node), NULL_TREE);\n+      __i_desc_array_type =\n+\tbuild_array_type (TYPE_POINTER_TO (__i_desc_type_node), NULL_TREE);\n+      __m_desc_array_type =\n+\tbuild_array_type (TYPE_POINTER_TO (__m_desc_type_node), NULL_TREE);\n \n       fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n \t\t\t\t\t string_type_node);\n       fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"size\"),\n \t\t\t\t\t unsigned_type_node);\n       fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"bits\"),\n \t\t\t\t\t unsigned_type_node);\n-      fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier (\"points_to\"),\n+      fields[3] = build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t\t get_identifier (\"points_to\"),\n \t\t\t\t\t TYPE_POINTER_TO (__t_desc_type_node));\n       fields[4] = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t\t get_identifier (\"ivars_count\"),\n@@ -4666,7 +4739,8 @@ init_decl_processing ()\n \t\t\t\t\t integer_type_node);\n       fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n \t\t\t\t\t TYPE_POINTER_TO (__t_desc_type_node));\n-      finish_builtin_type (__i_desc_type_node, \"__i_desc\", fields, 2, integer_type_node);\n+      finish_builtin_type (__i_desc_type_node, \"__i_desc\", fields, 2,\n+\t\t\t   integer_type_node);\n \n       /* method descriptors look like this:\n \n@@ -4699,7 +4773,8 @@ init_decl_processing ()\n \t\t\t\t\t short_integer_type_node);\n       fields[7] = build_lang_field_decl (FIELD_DECL, get_identifier (\"parm_types\"),\n \t\t\t\t\t build_pointer_type (build_array_type (TYPE_POINTER_TO (__t_desc_type_node), NULL_TREE)));\n-      finish_builtin_type (__m_desc_type_node, \"__m_desc\", fields, 7, integer_type_node);\n+      finish_builtin_type (__m_desc_type_node, \"__m_desc\", fields, 7,\n+\t\t\t   integer_type_node);\n     }\n \n   /* Now, C++.  */\n@@ -4720,11 +4795,21 @@ init_decl_processing ()\n \t\t\t\t      tree_cons (NULL_TREE, sizetype,\n \t\t\t\t\t\t void_list_node)),\n \t\t NOT_BUILT_IN);\n+  auto_function (ansi_opname[(int) VEC_NEW_EXPR],\n+\t\t build_function_type (ptr_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, sizetype,\n+\t\t\t\t\t\t void_list_node)),\n+\t\t NOT_BUILT_IN);\n   auto_function (ansi_opname[(int) DELETE_EXPR],\n \t\t build_function_type (void_type_node,\n \t\t\t\t      tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t\t\t void_list_node)),\n \t\t NOT_BUILT_IN);\n+  auto_function (ansi_opname[(int) VEC_DELETE_EXPR],\n+\t\t build_function_type (void_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t void_list_node)),\n+\t\t NOT_BUILT_IN);\n \n   abort_fndecl\n     = define_function (\"abort\",\n@@ -4889,7 +4974,8 @@ shadow_tag (declspecs)\n \t function members.  */\n       if (TYPE_FIELDS (t))\n \t{\n-\t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0, NULL_TREE);\n+\t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n+\t\t\t\t      NULL_TREE);\n \t  finish_anon_union (decl);\n \t}\n       else\n@@ -4982,7 +5068,8 @@ start_decl (declarator, declspecs, initialized, raises)\n   /* This should only be done once on the top most decl. */\n   if (have_extern_spec && !used_extern_spec)\n     {\n-      declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"), declspecs);\n+      declspecs = decl_tree_cons (NULL_TREE, get_identifier (\"extern\"),\n+\t\t\t\t  declspecs);\n       used_extern_spec = 1;\n     }\n \n@@ -5057,9 +5144,11 @@ start_decl (declarator, declspecs, initialized, raises)\n           DECL_ARGUMENTS (decl) = args;\n         }\n       d = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n-      if (interface_unknown && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))\n+      if (interface_unknown && flag_external_templates\n+\t  && ! DECL_IN_SYSTEM_HEADER (decl))\n \twarn_if_unknown_interface ();\n-      TREE_PUBLIC (d) = TREE_PUBLIC (decl) = flag_external_templates && !interface_unknown;\n+      TREE_PUBLIC (d) = TREE_PUBLIC (decl) =\n+\tflag_external_templates && !interface_unknown;\n       TREE_STATIC (d) = TREE_STATIC (decl);\n       DECL_EXTERNAL (d) = (DECL_EXTERNAL (decl)\n \t\t\t   && !(context && !DECL_THIS_EXTERN (decl)));\n@@ -5251,7 +5340,8 @@ start_decl (declarator, declspecs, initialized, raises)\n \t use temporary storage.  Do this even if we will ignore the value.  */\n       if (current_binding_level == global_binding_level && debug_temp_inits)\n \t{\n-\t  if (TYPE_NEEDS_CONSTRUCTING (type) || TREE_CODE (type) == REFERENCE_TYPE)\n+\t  if (TYPE_NEEDS_CONSTRUCTING (type)\n+\t      || TREE_CODE (type) == REFERENCE_TYPE)\n \t    /* In this case, the initializer must lay down in permanent\n \t       storage, since it will be saved until `finish_file' is run.   */\n \t    ;\n@@ -5463,7 +5553,8 @@ grok_reference_init (decl, type, init, cleanupp)\n \t  TREE_OPERAND (TREE_OPERAND (tmp, 0), 2) = error_mark_node;\n \t}\n       if (IS_AGGR_TYPE (TREE_TYPE (this_ptr_type)))\n-\tDECL_INITIAL (decl) = convert_pointer_to (TREE_TYPE (this_ptr_type), tmp);\n+\tDECL_INITIAL (decl) = convert_pointer_to (TREE_TYPE (this_ptr_type),\n+\t\t\t\t\t\t  tmp);\n       else\n \tDECL_INITIAL (decl) = convert (this_ptr_type, tmp);\n \n@@ -5481,7 +5572,8 @@ grok_reference_init (decl, type, init, cleanupp)\n       if (TREE_CODE (actual_init) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (actual_init, 0)) == TARGET_EXPR)\n \tactual_init = save_expr (actual_init);\n-      DECL_INITIAL (decl) = convert_pointer_to (TREE_TYPE (this_ptr_type), actual_init);\n+      DECL_INITIAL (decl) = convert_pointer_to (TREE_TYPE (this_ptr_type),\n+\t\t\t\t\t\tactual_init);\n       DECL_INITIAL (decl) = save_expr (DECL_INITIAL (decl));\n       TREE_TYPE (DECL_INITIAL (decl)) = type;\n     }\n@@ -5689,7 +5781,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t    {\n \t      if (TYPE_NEEDS_CONSTRUCTING (type))\n \t\t{\n-\t\t  cp_error (\"`%D' must be initialized by constructor, not by `{...}'\", decl);\n+\t\t  cp_error (\"`%D' must be initialized by constructor, not by `{...}'\",\n+\t\t\t    decl);\n \t\t  init = error_mark_node;\n \t\t}\n \t      else\n@@ -5780,7 +5873,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (ctype))\n \t    cp_error (\"structure `%D' with uninitialized const members\", decl);\n \t  if (CLASSTYPE_REF_FIELDS_NEED_INIT (ctype))\n-\t    cp_error (\"structure `%D' with uninitialized reference members\", decl);\n+\t    cp_error (\"structure `%D' with uninitialized reference members\",\n+\t\t      decl);\n \t}\n \n       if (TREE_CODE (decl) == VAR_DECL\n@@ -6002,9 +6096,6 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t    }\n \t  else if (toplev)\n \t    {\n-\t      /* Keep GCC from complaining that this variable\n-\t\t is defined but never used.  */\n-\t      TREE_USED (decl) = 1;\n \t      /* If this is a static const, change its apparent linkage\n \t\t if it belongs to a #pragma interface.  */\n \t      if (TREE_STATIC (decl) && !interface_unknown)\n@@ -6092,7 +6183,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\t\t: & TYPE_ARG_TYPES (type);\n \n \t\t      *argp = NULL_TREE;\n-\t\t      fnname = build_decl_overload (original_name, TYPE_ARG_TYPES (type), 0);\n+\t\t      fnname = build_decl_overload (original_name,\n+\t\t\t\t\t\t    TYPE_ARG_TYPES (type), 0);\n \t\t      *argp = parmtypes;\n \t\t      fndecl = build_decl (FUNCTION_DECL, fnname, type);\n \t\t      DECL_EXTERNAL (fndecl) = DECL_EXTERNAL (decl);\n@@ -6169,7 +6261,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \n \t      if (init || TYPE_NEEDS_CONSTRUCTING (type))\n \t\t{\n-\t\t  emit_line_note (DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n+\t\t  emit_line_note (DECL_SOURCE_FILE (decl),\n+\t\t\t\t  DECL_SOURCE_LINE (decl));\n \t\t  expand_aggr_init (decl, init, 0);\n \t\t}\n \n@@ -6182,7 +6275,8 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t      if (cleanup)\n \t\t{\n \t\t  if (! expand_decl_cleanup (decl, cleanup))\n-\t\t    cp_error (\"parser lost in parsing declaration of `%D'\", decl);\n+\t\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t\t      decl);\n \t\t}\n \t    }\n \t}\n@@ -6380,7 +6474,8 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n   if (inlinep)\n     cp_error (\"`%D' declared as an `inline' %s\", object, type);\n   if (quals)\n-    cp_error (\"`const' and `volatile' function specifiers on `%D' invalid in %s declaration\", object, type);\n+    cp_error (\"`const' and `volatile' function specifiers on `%D' invalid in %s declaration\",\n+\t      object, type);\n   if (friendp)\n     cp_error_at (\"invalid friend declaration\", object);\n   if (raises)\n@@ -6399,7 +6494,8 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    CHECK is 1 if we must find this method in CTYPE, 0 if we should\n    not look, and -1 if we should not call `grokclassfn' at all.  */\n static tree\n-grokfndecl (ctype, type, declarator, virtualp, flags, quals, raises, check, publicp)\n+grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n+\t    raises, check, publicp)\n      tree ctype, type;\n      tree declarator;\n      int virtualp;\n@@ -6530,7 +6626,8 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals, raises, check, publ\n \tfor (i = 0; i < n_baselinks; i++)\n \t  {\n \t    tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t    if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo)) || flag_all_virtual == 1)\n+\t    if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo))\n+\t\t|| flag_all_virtual == 1)\n \t      {\n \t\ttmp = get_first_matching_virtual (base_binfo, decl,\n \t\t\t\t\t\t  flags == DTOR_FLAG);\n@@ -6547,8 +6644,10 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals, raises, check, publ\n \t\t       path to its virtual baseclass.  */\n \t\t    if (staticp)\n \t\t      {\n-\t\t\tcp_error (\"method `%D' may not be declared static\", decl);\n-\t\t\tcp_error_at (\"(since `%D' declared virtual in base class.)\", tmp);\n+\t\t\tcp_error (\"method `%D' may not be declared static\",\n+\t\t\t\t  decl);\n+\t\t\tcp_error_at (\"(since `%D' declared virtual in base class.)\",\n+\t\t\t\t     tmp);\n \t\t\tbreak;\n \t\t      }\n \t\t    virtualp = 1;\n@@ -6716,7 +6815,8 @@ build_ptrmemfunc_type (type)\n \n   u = make_lang_type (UNION_TYPE);\n   fields[0] = build_lang_field_decl (FIELD_DECL, pfn_identifier, type);\n-  fields[1] = build_lang_field_decl (FIELD_DECL, delta2_identifier, delta_type_node);\n+  fields[1] = build_lang_field_decl (FIELD_DECL, delta2_identifier,\n+\t\t\t\t     delta_type_node);\n   finish_builtin_type (u, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n   TYPE_NAME (u) = NULL_TREE;\n \n@@ -6725,8 +6825,10 @@ build_ptrmemfunc_type (type)\n   /* Let the front-end know this is a pointer to member function. */\n   TYPE_PTRMEMFUNC_FLAG(t) = 1;\n \n-  fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier, delta_type_node);\n-  fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier, delta_type_node);\n+  fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t     delta_type_node);\n+  fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier,\n+\t\t\t\t     delta_type_node);\n   fields[2] = build_lang_field_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n   finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n \n@@ -6839,7 +6941,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   tree ctype = current_class_type;\n   tree ctor_return_type = NULL_TREE;\n   enum overload_flags flags = NO_SPECIAL;\n-  int seen_scope_ref = 0;\n   tree quals = NULL_TREE;\n \n   RIDBIT_RESET_ALL (specbits);\n@@ -6957,7 +7058,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  dname = decl;\n \t  decl = NULL_TREE;\n \n-\t  if (IDENTIFIER_TYPENAME_P (dname))\n+\t  /* This may just be a variable starting with __op.  */\n+\t  if (IDENTIFIER_TYPENAME_P (dname) && TREE_TYPE (dname))\n \t    {\n \t      my_friendly_assert (flags == NO_SPECIAL, 154);\n \t      flags = TYPENAME_FLAG;\n@@ -6987,11 +7089,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t  /* C++ extension */\n \tcase SCOPE_REF:\n-/*\n-\t  if (seen_scope_ref == 1)\n-\t    error (\"multiple `::' terms in declarator invalid\");\n-*/\n-\t  seen_scope_ref += 1;\n \t  {\n \t    /* Perform error checking, and convert class names to types.\n \t       We may call grokdeclarator multiple times for the same\n@@ -7239,14 +7336,24 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t}\n       else\n \t{\n-\t  if (funcdef_flag && warn_return_type\n-\t      && return_type == return_normal\n-\t      && ! (RIDBIT_SETP (RID_SIGNED, specbits)\n-\t\t    || RIDBIT_SETP (RID_UNSIGNED, specbits)\n-\t\t    || RIDBIT_SETP (RID_LONG, specbits)\n-\t\t    || RIDBIT_SETP (RID_SHORT, specbits)))\n-\t    warn_about_return_type = 1;\n-\t  /* Save warning until we know what is really going on.  */\n+\t  if (funcdef_flag)\n+\t    {\n+\t      if (warn_return_type\n+\t\t  && return_type == return_normal\n+\t\t  && ! (RIDBIT_SETP (RID_SIGNED, specbits)\n+\t\t\t|| RIDBIT_SETP (RID_UNSIGNED, specbits)\n+\t\t\t|| RIDBIT_SETP (RID_LONG, specbits)\n+\t\t\t|| RIDBIT_SETP (RID_SHORT, specbits)))\n+\t\t/* Save warning until we know what is really going on.  */\n+\t\twarn_about_return_type = 1;\n+\t    }\n+\t  else if (class_binding_level && declarator\n+\t\t   && TREE_CODE (declarator) == SCOPE_REF)\n+\t    /* OK -- access declaration */;\n+\t  else if (declspecs == NULL_TREE &&\n+\t\t   (innermost_code != CALL_EXPR || pedantic))\n+\t    cp_pedwarn (\"ANSI C++ forbids declaration `%D' with no type or storage class\",\n+\t\t\tdname);\n \t  type = integer_type_node;\n \t}\n     }\n@@ -7486,7 +7593,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t}\n       if (volatilep)\n \t{\n-\t  error (\"`volatile' specified for signature member function `%s'\", name);\n+\t  error (\"`volatile' specified for signature member function `%s'\",\n+\t\t name);\n \t  volatilep = 0;\n \t}\n       if (inlinep)\n@@ -7502,7 +7610,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t}\n       if (virtualp)\n \t{\n-\t  error (\"`virtual' specified for signature member function `%s'\", name);\n+\t  error (\"`virtual' specified for signature member function `%s'\",\n+\t\t name);\n \t  /* Later, we'll make signature member functions virtual.  */\n \t  virtualp = 0;\n \t}\n@@ -7816,7 +7925,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\telse\n \t\t  {\n \t\t    if (pedantic)\n-\t\t      cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\", dname);\n+\t\t      cp_pedwarn (\"ANSI C++ forbids variable-size array `%D'\",\n+\t\t\t\t  dname);\n \t\t  dont_grok_size:\n \t\t    itype =\n \t\t      build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n@@ -8177,11 +8287,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      /* don't fall out into global scope. Hides real bug? --eichin */ ;\n \t    else if (TREE_COMPLEXITY (declarator) == current_class_depth)\n \t      {\n-\t\t/* I'm not really sure what pushclass calls this popclass\n-\t\t   corresponds to.  One is in build_push_scope and that has\n-\t\t   been changed to a push_nested_class call, that's why I\n-\t\t   try to use pop_nested_class here instead.\n-\t\t   -niklas@appli.se */\n+\t\t/* This pop_nested_class corresponds to the\n+                   push_nested_class used to push into class scope for\n+                   parsing the argument list of a function decl, in\n+                   qualified_id.  */\n \t\tpop_nested_class (1);\n \t\tTREE_COMPLEXITY (declarator) = current_class_depth;\n \t      }\n@@ -8631,7 +8740,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \n \t\tif (declarator == ansi_opname[(int) NEW_EXPR]\n-\t\t    || declarator == ansi_opname[(int) DELETE_EXPR])\n+\t\t    || declarator == ansi_opname[(int) VEC_NEW_EXPR]\n+\t\t    || declarator == ansi_opname[(int) DELETE_EXPR]\n+\t\t    || declarator == ansi_opname[(int) VEC_DELETE_EXPR])\n \t\t  {\n \t\t    if (virtualp)\n \t\t      {\n@@ -9328,7 +9439,8 @@ grok_ctor_properties (ctype, decl)\n }\n \n /* An operator with this name can be either unary or binary.  */\n-int ambi_op_p (name)\n+static int\n+ambi_op_p (name)\n      tree name;\n {\n   return (name == ansi_opname [(int) INDIRECT_REF]\n@@ -9340,7 +9452,8 @@ int ambi_op_p (name)\n }\n \n /* An operator with this name can only be unary.  */\n-int unary_op_p (name)\n+static int\n+unary_op_p (name)\n      tree name;\n {\n   return (name == ansi_opname [(int) TRUTH_NOT_EXPR]\n@@ -9358,44 +9471,39 @@ grok_op_properties (decl, virtualp, friendp)\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   int methodp = (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n   tree name = DECL_NAME (decl);\n-  tree t;\n \n-  if (! friendp)\n-    for (t = current_class_type; t; t = TYPE_NEXT_VARIANT (t))\n-      {\n-\tif (name == ansi_opname[(int) MODIFY_EXPR])\n-\t  TYPE_HAS_ASSIGNMENT (t) = 1;\n-\telse if (name == ansi_opname[(int) CALL_EXPR])\n-\t  TYPE_OVERLOADS_CALL_EXPR (t) = 1;\n-\telse if (name == ansi_opname[(int) ARRAY_REF])\n-\t  TYPE_OVERLOADS_ARRAY_REF (t) = 1;\n-\telse if (name == ansi_opname[(int) COMPONENT_REF]\n-\t\t || name == ansi_opname[(int) MEMBER_REF])\n-\t  TYPE_OVERLOADS_ARROW (t) = 1;\n-\telse if (name == ansi_opname[(int) NEW_EXPR])\n-\t  {\n-\t    if (TREE_CHAIN (argtypes) == void_list_node)\n-\t      TREE_GETS_NEW (t) = 1;\n-\t    else\n-\t      TREE_GETS_PLACED_NEW (t) = 1;\n-\t  }\n-\telse if (name == ansi_opname[(int) DELETE_EXPR])\n-\t  TREE_GETS_DELETE (t) = 1;\n-#if 0\n-\telse if (name == ansi_opname[(int) VEC_NEW_EXPR])\n-\t  TREE_GETS_NEW (t) = 1;\n-\telse if (name == ansi_opname[(int) VEC_DELETE_EXPR])\n-\t  TREE_GETS_DELETE (t) = 1;\n-#endif\n-      }\n+  if (current_class_type == NULL_TREE)\n+    friendp = 1;\n \n-  if (name == ansi_opname[(int) NEW_EXPR])\n+  if (! friendp)\n+    {\n+      if (name == ansi_opname[(int) MODIFY_EXPR])\n+\tTYPE_HAS_ASSIGNMENT (current_class_type) = 1;\n+      else if (name == ansi_opname[(int) CALL_EXPR])\n+\tTYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n+      else if (name == ansi_opname[(int) ARRAY_REF])\n+\tTYPE_OVERLOADS_ARRAY_REF (current_class_type) = 1;\n+      else if (name == ansi_opname[(int) COMPONENT_REF]\n+\t       || name == ansi_opname[(int) MEMBER_REF])\n+\tTYPE_OVERLOADS_ARROW (current_class_type) = 1;\n+      else if (name == ansi_opname[(int) NEW_EXPR])\n+\tTYPE_GETS_NEW (current_class_type) |= 1;\n+      else if (name == ansi_opname[(int) DELETE_EXPR])\n+\tTYPE_GETS_DELETE (current_class_type) |= 1;\n+      else if (name == ansi_opname[(int) VEC_NEW_EXPR])\n+\tTYPE_GETS_NEW (current_class_type) |= 2;\n+      else if (name == ansi_opname[(int) VEC_DELETE_EXPR])\n+\tTYPE_GETS_DELETE (current_class_type) |= 2;\n+    }\n+\n+  if (name == ansi_opname[(int) NEW_EXPR]\n+      || name == ansi_opname[(int) VEC_NEW_EXPR])\n     {\n-#if 0\n       /* When the compiler encounters the definition of A::operator new, it\n \t doesn't look at the class declaration to find out if it's static.  */\n-      my_friendly_assert (!methodp, 355);\n-#endif\n+      if (methodp)\n+\trevert_static_member_fn (&TREE_TYPE (decl), &decl,\n+\t\t\t\t &TYPE_ARG_TYPES (TREE_TYPE (decl)));\n      \n       /* Take care of function decl if we had syntax errors.  */\n       if (argtypes == NULL_TREE)\n@@ -9404,32 +9512,30 @@ grok_op_properties (decl, virtualp, friendp)\n \t\t\t       hash_tree_chain (integer_type_node,\n \t\t\t\t\t\tvoid_list_node));\n       else\n-\tdecl = coerce_new_type (TREE_TYPE (decl));\n+\tTREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl));\n     }\n-#if 0\n-  else if (name == ansi_opname[(int) VEC_NEW_EXPR])\n-    {\n-    }\n-#endif\n-  else if (name == ansi_opname[(int) DELETE_EXPR])\n+  else if (name == ansi_opname[(int) DELETE_EXPR]\n+\t   || name == ansi_opname[(int) VEC_DELETE_EXPR])\n     {\n-#if 0\n-      my_friendly_assert (!methodp, 355);\n-#endif\n+      if (methodp)\n+\trevert_static_member_fn (&TREE_TYPE (decl), &decl,\n+\t\t\t\t &TYPE_ARG_TYPES (TREE_TYPE (decl)));\n      \n       if (argtypes == NULL_TREE)\n \tTREE_TYPE (decl) =\n \t  build_function_type (void_type_node,\n \t\t\t       hash_tree_chain (ptr_type_node,\n \t\t\t\t\t\tvoid_list_node));\n       else\n-\tdecl = coerce_delete_type (TREE_TYPE (decl));\n-    }\n-#if 0\n-  else if (name == ansi_opname[(int) VEC_DELETE_EXPR])\n-    {\n+\t{\n+\t  TREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl));\n+\n+\t  if (! friendp && name == ansi_opname[(int) VEC_DELETE_EXPR]\n+\t      && (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n+\t\t  != void_list_node))\n+\t    TYPE_VEC_DELETE_TAKES_SIZE (current_class_type) = 1;\n+\t}\n     }\n-#endif\n   else\n     {\n       /* An operator function must either be a non-static member function\n@@ -9484,8 +9590,9 @@ grok_op_properties (decl, virtualp, friendp)\n \t  parmtype = TREE_VALUE (TREE_CHAIN (argtypes));\n \n \t  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-\t      && TYPE_MAIN_VARIANT (TREE_TYPE (parmtype))\n-\t      == current_class_type)\n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (parmtype))\n+\t\t  == current_class_type)\n+\t      && ! friendp)\n \t    {\n \t      TYPE_HAS_ASSIGN_REF (current_class_type) = 1;\n \t      if (TYPE_READONLY (TREE_TYPE (parmtype)))\n@@ -9957,9 +10064,8 @@ if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE\n \t\t}\n \n \t      TYPE_OVERLOADS_METHOD_CALL_EXPR (ref) |= TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype);\n-\t      TREE_GETS_NEW (ref) |= TREE_GETS_NEW (basetype);\n-\t      TREE_GETS_PLACED_NEW (ref) |= TREE_GETS_PLACED_NEW (basetype);\n-\t      TREE_GETS_DELETE (ref) |= TREE_GETS_DELETE (basetype);\n+\t      TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n+\t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n \t      CLASSTYPE_LOCAL_TYPEDECLS (ref) |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);\n \t      i += 1;\n \t    }\n@@ -10439,7 +10545,8 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t  /* If this doesn't return integer_type, complain.  */\n \t  if (TREE_TYPE (TREE_TYPE (decl1)) != integer_type_node)\n \t    {\n-\t      warning (\"return type for `main' changed to integer type\");\n+\t      if (pedantic || warn_return_type)\n+\t\twarning (\"return type for `main' changed to integer type\");\n \t      TREE_TYPE (decl1) = fntype = default_function_type;\n \t    }\n \t  warn_about_return_type = 0;\n@@ -11040,7 +11147,7 @@ finish_function (lineno, call_poplevel)\n \n       /* These are two cases where we cannot delegate deletion.  */\n       if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)\n-\t  || TREE_GETS_DELETE (current_class_type))\n+\t  || TYPE_GETS_REG_DELETE (current_class_type))\n \texprstmt = build_delete (current_class_type, C_C_D, integer_zero_node,\n \t\t\t\t LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n       else\n@@ -11096,7 +11203,7 @@ finish_function (lineno, call_poplevel)\n       virtual_size = c_sizeof (current_class_type);\n \n       /* At the end, call delete if that's what's requested.  */\n-      if (TREE_GETS_DELETE (current_class_type))\n+      if (TYPE_GETS_REG_DELETE (current_class_type))\n \t/* This NOP_EXPR means we are in a static call context.  */\n \texprstmt =\n \t  build_method_call\n@@ -11216,7 +11323,7 @@ finish_function (lineno, call_poplevel)\n \t      expand_decl_init (allocated_this);\n \t      /* How we cleanup `this' if an exception was raised before\n \t\t we are ready to bail out.  */\n-\t      cleanup = TREE_GETS_DELETE (current_class_type)\n+\t      cleanup = TYPE_GETS_REG_DELETE (current_class_type)\n \t\t? build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, allocated_this, virtual_size, NULL_TREE)\n \t\t  /* The size of allocated_this is wrong, and hence the\n \t\t     second argument to operator delete will be wrong. */"}, {"sha": "aad0c15fe9f3d4c63c3b5332019c7d3ed1081874", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -1071,6 +1071,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n       return error_mark_node;\n     }\n \n+#if 0\n   /* If the type has no destructor, then we should build a regular\n      delete, instead of a vector delete.  Otherwise, we would end\n      up passing a bogus offset into __builtin_delete, which is\n@@ -1082,15 +1083,15 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n       doing_vec = 0;\n       use_global_delete = 1;\n     }\n+#endif\n \n   if (doing_vec)\n-    return build_vec_delete (t, maxindex, elt_size, NULL_TREE,\n-\t\t\t     integer_one_node, integer_two_node);\n+    return build_vec_delete (t, maxindex, elt_size, integer_one_node,\n+\t\t\t     integer_two_node, use_global_delete);\n   else\n     return build_delete (type, t, integer_three_node,\n \t\t\t LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE,\n-\t\t\t use_global_delete\n-\t\t\t || TYPE_HAS_DESTRUCTOR (TREE_TYPE (type)));\n+\t\t\t use_global_delete);\n }\n \n /* Sanity check: report error if this function FUNCTION is not\n@@ -1456,6 +1457,7 @@ grokbitfield (declarator, declspecs, width)\n   return value;\n }\n \n+#if 0\n /* Like GROKFIELD, except that the declarator has been\n    buried in DECLSPECS.  Find the declarator, and\n    return something that looks like it came from\n@@ -1634,6 +1636,7 @@ groktypefield (declspecs, parmlist)\n   DECL_IN_AGGR_P (decl) = 1;\n   return decl;\n }\n+#endif\n \n tree\n grokoptypename (declspecs, declarator)\n@@ -2278,7 +2281,7 @@ coerce_delete_type (type)\n   else if (e3 |= e2)\n     {\n       if (arg_types == NULL_TREE)\n-\targ_types = void_list_node;\n+\targ_types = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n       else\n \targ_types = tree_cons (NULL_TREE, ptr_type_node, TREE_CHAIN (arg_types));\n     }\n@@ -2853,7 +2856,11 @@ reparse_decl_as_expr1 (decl)\n     case BIT_NOT_EXPR:\n       return build_x_unary_op (BIT_NOT_EXPR,\n \t\t\t       reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)));\n-\n+    case SCOPE_REF:\n+      return build_offset_ref (TREE_OPERAND (decl, 0), TREE_OPERAND (decl, 1));\n+    case ARRAY_REF:\n+      return grok_array_decl (reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)),\n+\t\t\t      TREE_OPERAND (decl, 1));\n     default:\n       my_friendly_abort (5);\n       return NULL_TREE;\n@@ -2901,6 +2908,9 @@ finish_decl_parsing (decl)\n       push_nested_class (TREE_OPERAND (decl, 0), 3);\n       TREE_COMPLEXITY (decl) = current_class_depth;\n       return decl;\n+    case ARRAY_REF:\n+      TREE_OPERAND (decl, 0) = finish_decl_parsing (TREE_OPERAND (decl, 0));\n+      return decl;\n     default:\n       my_friendly_abort (5);\n       return NULL_TREE;"}, {"sha": "d27fe70c791715e44ad748635b65e6f5e433265c", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -1059,17 +1059,18 @@ It is ambiguous whether @code{class T} should be parsed as the\n declaration of a template type parameter named @code{T} or an unnamed\n constant parameter of type @code{class T}.  Section 14.6, paragraph 3 of\n the January '94 working paper states that the first interpretation is\n-the correct one.  This ambiguity results in four reduce/reduce conflicts.\n+the correct one.  This ambiguity results in two reduce/reduce conflicts.\n \n-2) Between @code{primary} and @code{typename} for code like @samp{int()}\n+2) Between @code{primary} and @code{type_id} for code like @samp{int()}\n in places where both can be accepted, such as the argument to\n @code{sizeof}.  Section 8.1 of the pre-San Diego working paper specifies\n that these ambiguous constructs will be interpreted as @code{typename}s.\n-This ambiguity results in six reduce/reduce conflicts.\n+This ambiguity results in six reduce/reduce conflicts between\n+@samp{absdcl} and @samp{functional_cast}.\n \n-3) Between @code{primary}/@code{functional_cast} and\n-@code{expr_or_declarator}/@code{complex_direct_notype_declarator}, for\n-various token strings.  This situation occurs in code looking like\n+3) Between @code{functional_cast} and\n+@code{complex_direct_notype_declarator}, for various token strings.\n+This situation occurs in code looking like\n \n @example\n int (*a);\n@@ -1078,11 +1079,23 @@ int (*a);\n This code is ambiguous; it could be a declaration of the variable\n @samp{a} as a pointer to @samp{int}, or it could be a functional cast of\n @samp{*a} to @samp{int}.  Section 6.8 specifies that the former\n-interpretation is correct.  This ambiguity results in 12 reduce/reduce\n-conflicts.  Ack.\n-\n-4) Between @code{after_type_declarator} and @code{parm}, for the token\n-@code{TYPENAME}.  This occurs in (as one example) code like\n+interpretation is correct.  This ambiguity results in 7 reduce/reduce\n+conflicts.  Another aspect of this ambiguity is code like 'int (x[2]);',\n+which is resolved at the '[' and accounts for 6 reduce/reduce conflicts\n+between @samp{direct_notype_declarator} and\n+@samp{primary}/@samp{overqualified_id}.  Finally, there are 4 r/r\n+conflicts between @samp{expr_or_declarator} and @samp{primary} over code\n+like 'int (a);', which could probably be resolved but would also\n+probably be more trouble than it's worth.  In all, this situation\n+accounts for 17 conflicts.  Ack!\n+\n+The second case above is responsible for the failure to parse 'LinppFile\n+ppfile (String (argv[1]), &outs, argc, argv);' (from Rogue Wave\n+Math.h++) as an object declaration, and must be fixed so that it does\n+not resolve until later.\n+\n+4) Indirectly between @code{after_type_declarator} and @code{parm}, for\n+type names.  This occurs in (as one example) code like\n \n @example\n typedef int foo, bar;\n@@ -1093,11 +1106,12 @@ class A @{\n \n What is @code{bar} inside the class definition?  We currently interpret\n it as a @code{parm}, as does Cfront, but IBM xlC interprets it as an\n-@code{after_type_declarator}.  I suspect that xlC is correct, in light\n+@code{after_type_declarator}.  I believe that xlC is correct, in light\n of 7.1p2, which says \"The longest sequence of @i{decl-specifiers} that\n could possibly be a type name is taken as the @i{decl-specifier-seq} of\n a @i{declaration}.\"  However, it seems clear that this rule must be\n-violated in the case of constructors, so...\n+violated in the case of constructors.  This ambiguity accounts for 8\n+conflicts.\n \n Unlike the others, this ambiguity is not recognized by the Working Paper.\n "}, {"sha": "4d2cbf7332cc57b1bb995e8f3a0edd7d30a7b5bf", "filename": "gcc/cp/init.c", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -52,12 +52,11 @@ static void expand_recursive_init_1 ();\n static void expand_recursive_init ();\n static void expand_virtual_init PROTO((tree, tree, tree));\n tree expand_vec_init ();\n-tree build_vec_delete ();\n \n static void add_friend (), add_friends ();\n \n /* Cache _builtin_new and _builtin_delete exprs.  */\n-static tree BIN, BID;\n+static tree BIN, BID, BIVN, BIVD;\n \n /* Cache the identifier nodes for the two magic field of a new cookie.  */\n static tree nc_nelts_field_id;\n@@ -81,6 +80,10 @@ void init_init_processing ()\n   TREE_USED (TREE_OPERAND (BIN, 0)) = 0;\n   BID = default_conversion (get_first_fn (IDENTIFIER_GLOBAL_VALUE (ansi_opname[(int) DELETE_EXPR])));\n   TREE_USED (TREE_OPERAND (BID, 0)) = 0;\n+  BIVN = default_conversion (get_first_fn (IDENTIFIER_GLOBAL_VALUE (ansi_opname[(int) VEC_NEW_EXPR])));\n+  TREE_USED (TREE_OPERAND (BIVN, 0)) = 0;\n+  BIVD = default_conversion (get_first_fn (IDENTIFIER_GLOBAL_VALUE (ansi_opname[(int) VEC_DELETE_EXPR])));\n+  TREE_USED (TREE_OPERAND (BIVD, 0)) = 0;\n   minus_one = build_int_2 (-1, -1);\n \n   /* Define the structure that holds header information for\n@@ -1801,20 +1804,18 @@ is_aggr_typedef (name, or_else)\n \n   if (IDENTIFIER_HAS_TYPE_VALUE (name))\n     type = IDENTIFIER_TYPE_VALUE (name);\n-  else if (IDENTIFIER_HAS_CLASS_TYPE_VALUE (name))\n-    type = IDENTIFIER_CLASS_TYPE_VALUE (name);\n   else\n     {\n       if (or_else)\n-\tcp_error (\"`%T' fails to be an aggregate typedef\", name);\n+\tcp_error (\"`%T' is not an aggregate typedef\", name);\n       return 0;\n     }\n \n   if (! IS_AGGR_TYPE (type)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM)\n     {\n       if (or_else)\n-\tcp_error (\"type `%T' is of non-aggregate type\", type);\n+\tcp_error (\"`%T' is not an aggregate type\", type);\n       return 0;\n     }\n   return 1;\n@@ -1833,8 +1834,6 @@ get_aggr_from_typedef (name, or_else)\n \n   if (IDENTIFIER_HAS_TYPE_VALUE (name))\n     type = IDENTIFIER_TYPE_VALUE (name);\n-  else if (IDENTIFIER_HAS_CLASS_TYPE_VALUE (name))\n-    type = IDENTIFIER_CLASS_TYPE_VALUE (name);\n   else\n     {\n       if (or_else)\n@@ -1861,8 +1860,6 @@ get_type_value (name)\n \n   if (IDENTIFIER_HAS_TYPE_VALUE (name))\n     return IDENTIFIER_TYPE_VALUE (name);\n-  else if (IDENTIFIER_CLASS_VALUE (name))\n-    return IDENTIFIER_CLASS_TYPE_VALUE (name);\n   else\n     return NULL_TREE;\n }\n@@ -2808,13 +2805,6 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n       TREE_PUBLIC (decl) = 1;\n       add_friend (current_class_type, decl);\n       DECL_FRIEND_P (decl) = 1;\n-      if (IDENTIFIER_POINTER (declarator)[0] == '_')\n-\t{\n-\t  if (! strcmp (IDENTIFIER_POINTER (declarator)+10, \"new\"))\n-\t    TREE_GETS_NEW (current_class_type) = 0;\n-\t  else if (! strcmp (IDENTIFIER_POINTER (declarator)+10, \"delete\"))\n-\t    TREE_GETS_DELETE (current_class_type) = 0;\n-\t}\n       decl = void_type_node;\n     }\n   /* A global friend.\n@@ -2980,6 +2970,7 @@ build_new (placement, decl, init, use_global_new)\n   tree type, true_type, size, rval;\n   tree nelts;\n   int has_array = 0;\n+  enum tree_code code = NEW_EXPR;\n \n   tree pending_sizes = NULL_TREE;\n \n@@ -3155,27 +3146,28 @@ build_new (placement, decl, init, use_global_new)\n \n   /* Get a little extra space to store a couple of things before the new'ed\n      array. */\n-  if (has_array && TYPE_NEEDS_DESTRUCTOR (true_type))\n+  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n     {\n       tree extra = BI_header_size;\n \n       size = size_binop (PLUS_EXPR, size, extra);\n     }\n \n+  if (has_array)\n+    code = VEC_NEW_EXPR;\n+\n   /* Allocate the object. */\n-  if (TYPE_LANG_SPECIFIC (true_type)\n-      && (TREE_GETS_NEW (true_type) || TREE_GETS_PLACED_NEW (true_type))\n-      && !use_global_new\n-      && !has_array)\n-    rval = build_opfncall (NEW_EXPR, LOOKUP_NORMAL,\n+  if (! use_global_new && TYPE_LANG_SPECIFIC (true_type)\n+      && (TYPE_GETS_NEW (true_type) & (1 << has_array)))\n+    rval = build_opfncall (code, LOOKUP_NORMAL,\n \t\t\t   TYPE_POINTER_TO (true_type), size, placement);\n   else if (placement)\n     {\n-      rval = build_opfncall (NEW_EXPR, LOOKUP_GLOBAL|LOOKUP_COMPLAIN,\n+      rval = build_opfncall (code, LOOKUP_GLOBAL|LOOKUP_COMPLAIN,\n \t\t\t     ptr_type_node, size, placement);\n       rval = convert (TYPE_POINTER_TO (true_type), rval);\n     }\n-  else if (flag_this_is_variable > 0\n+  else if (! has_array && flag_this_is_variable > 0\n \t   && TYPE_HAS_CONSTRUCTOR (true_type) && init != void_type_node)\n     {\n       if (init == NULL_TREE || TREE_CODE (init) == TREE_LIST)\n@@ -3189,7 +3181,8 @@ build_new (placement, decl, init, use_global_new)\n   else\n     {\n       rval = build_builtin_call (build_pointer_type (true_type),\n-\t\t\t\t BIN, build_tree_list (NULL_TREE, size));\n+\t\t\t\t has_array ? BIVN : BIN,\n+\t\t\t\t build_tree_list (NULL_TREE, size));\n #if 0\n       /* See comment above as to why this is disabled.  */\n       if (alignment)\n@@ -3202,14 +3195,13 @@ build_new (placement, decl, init, use_global_new)\n \t}\n #endif\n       TREE_CALLS_NEW (rval) = 1;\n-      TREE_SIDE_EFFECTS (rval) = 1;\n     }\n \n   /* if rval is NULL_TREE I don't have to allocate it, but are we totally\n      sure we have some extra bytes in that case for the BI_header_size\n      cookies? And how does that interact with the code below? (mrs) */\n   /* Finish up some magic for new'ed arrays */\n-  if (has_array && TYPE_NEEDS_DESTRUCTOR (true_type) && rval != NULL_TREE)\n+  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type) && rval != NULL_TREE)\n     {\n       tree extra = BI_header_size;\n       tree cookie, exp1;\n@@ -3594,20 +3586,21 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \n    This does not call any destructors.  */\n tree\n-build_x_delete (type, addr, use_global_delete, virtual_size)\n+build_x_delete (type, addr, which_delete, virtual_size)\n      tree type, addr;\n-     int use_global_delete;\n+     int which_delete;\n      tree virtual_size;\n {\n+  int use_global_delete = which_delete & 1;\n+  int use_vec_delete = !!(which_delete & 2);\n   tree rval;\n+  enum tree_code code = use_vec_delete ? VEC_DELETE_EXPR : DELETE_EXPR;\n \n-  if (!use_global_delete\n-      && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n-      && TREE_GETS_DELETE (TREE_TYPE (type)))\n-    rval = build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, addr,\n-\t\t\t   virtual_size, NULL_TREE);\n+  if (! use_global_delete && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n+      && (TYPE_GETS_DELETE (TREE_TYPE (type)) & (1 << use_vec_delete)))\n+    rval = build_opfncall (code, LOOKUP_NORMAL, addr, virtual_size, NULL_TREE);\n   else\n-    rval = build_builtin_call (void_type_node, BID,\n+    rval = build_builtin_call (void_type_node, use_vec_delete ? BIVD : BID,\n \t\t\t       build_tree_list (NULL_TREE, addr));\n   return rval;\n }\n@@ -3674,7 +3667,8 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \taddr = save_expr (addr);\n       return build_vec_delete (addr, array_type_nelts (type),\n \t\t\t       c_sizeof_nowarn (TREE_TYPE (type)),\n-\t\t\t       NULL_TREE, auto_delete, integer_two_node);\n+\t\t\t       auto_delete, integer_two_node,\n+\t\t\t       use_global_delete);\n     }\n   else\n     {\n@@ -3707,10 +3701,8 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       /* Pass the size of the object down to the operator delete() in\n \t addition to the ADDR.  */\n-      if (TREE_GETS_DELETE (type) && !use_global_delete)\n+      if (TYPE_GETS_REG_DELETE (type) && !use_global_delete)\n \t{\n-\t  /* This is probably wrong. It should be the size of the virtual\n-\t     object being deleted.  */\n \t  tree virtual_size = c_sizeof_nowarn (type);\n \t  return build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, addr,\n \t\t\t\t virtual_size, NULL_TREE);\n@@ -3837,7 +3829,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t operator delete, call the parent parent destructor (if any),\n \t but let this node do the deleting.  Otherwise, it is ok\n \t to let the parent destructor do the deleting.  */\n-      if (TREE_GETS_DELETE (type) && !use_global_delete)\n+      if (TYPE_GETS_REG_DELETE (type) && !use_global_delete)\n \t{\n \t  parent_auto_delete = integer_zero_node;\n \t  if (auto_delete == integer_zero_node)\n@@ -3970,8 +3962,6 @@ build_vbase_delete (type, decl)\n    MAXINDEX is the number of elements to be deleted.\n    ELT_SIZE is the nominal size of each element in the vector.\n    BASE is the expression that should yield the store to be deleted.\n-   DTOR_DUMMY is a placeholder for a destructor.  The library function\n-   __builtin_vec_delete has a pointer to function in this position.\n    This function expands (or synthesizes) these calls itself.\n    AUTO_DELETE_VEC says whether the container (vector) should be deallocated.\n    AUTO_DELETE say whether each item in the container should be deallocated.\n@@ -3985,10 +3975,11 @@ build_vbase_delete (type, decl)\n    confirm the size, and trap if the numbers differ; not clear that it'd\n    be worth bothering.)  */\n tree\n-build_vec_delete (base, maxindex, elt_size, dtor_dummy, auto_delete_vec, auto_delete)\n+build_vec_delete (base, maxindex, elt_size, auto_delete_vec, auto_delete,\n+\t\t  use_global_delete)\n      tree base, maxindex, elt_size;\n-     tree dtor_dummy;\n      tree auto_delete_vec, auto_delete;\n+     int use_global_delete;\n {\n   tree ptype = TREE_TYPE (base);\n   tree type;\n@@ -4081,7 +4072,8 @@ build_vec_delete (base, maxindex, elt_size, dtor_dummy, auto_delete_vec, auto_de\n       /* This is the real size */\n       virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n       body = build_tree_list (NULL_TREE,\n-\t\t\t      build_x_delete (ptr_type_node, base_tbd, 1,\n+\t\t\t      build_x_delete (ptype, base_tbd,\n+\t\t\t\t\t      2 | use_global_delete,\n \t\t\t\t\t      virtual_size));\n       body = build (COND_EXPR, void_type_node,\n \t\t    build (BIT_AND_EXPR, integer_type_node,\n@@ -4124,7 +4116,7 @@ build_vec_delete (base, maxindex, elt_size, dtor_dummy, auto_delete_vec, auto_de\n       /* The below is short by BI_header_size */\n       virtual_size = fold (size_binop (MULT_EXPR, size_exp, maxindex));\n \n-      if (loop == integer_zero_node)\n+      if (! TYPE_VEC_NEW_USES_COOKIE (type))\n \t/* no header */\n \tbase_tbd = base;\n       else\n@@ -4137,7 +4129,8 @@ build_vec_delete (base, maxindex, elt_size, dtor_dummy, auto_delete_vec, auto_de\n \t  /* True size with header. */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, BI_header_size);\n \t}\n-      deallocate_expr = build_x_delete (ptr_type_node, base_tbd, 1,\n+      deallocate_expr = build_x_delete (ptype, base_tbd,\n+\t\t\t\t\t2 | use_global_delete,\n \t\t\t\t\tvirtual_size);\n       if (auto_delete_vec != integer_one_node)\n \tdeallocate_expr = build (COND_EXPR, void_type_node,"}, {"sha": "478cd106a12085acfbc4d1fe1b358bbfaab9afd8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -542,6 +542,10 @@ init_lex ()\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) NEW_EXPR]) = 1;\n   ansi_opname[(int) DELETE_EXPR] = get_identifier (\"__dl\");\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) DELETE_EXPR]) = 1;\n+  ansi_opname[(int) VEC_NEW_EXPR] = get_identifier (\"__vn\");\n+  IDENTIFIER_OPNAME_P (ansi_opname[(int) VEC_NEW_EXPR]) = 1;\n+  ansi_opname[(int) VEC_DELETE_EXPR] = get_identifier (\"__vd\");\n+  IDENTIFIER_OPNAME_P (ansi_opname[(int) VEC_DELETE_EXPR]) = 1;\n   ansi_opname[(int) TYPE_EXPR] = get_identifier (\"__op\");\n   IDENTIFIER_OPNAME_P (ansi_opname[(int) TYPE_EXPR]) = 1;\n \n@@ -681,6 +685,8 @@ init_lex ()\n   opname_tab[(int) MODIFY_EXPR] = \"=\";\n   opname_tab[(int) NEW_EXPR] = \"new\";\n   opname_tab[(int) DELETE_EXPR] = \"delete\";\n+  opname_tab[(int) VEC_NEW_EXPR] = \"new []\";\n+  opname_tab[(int) VEC_DELETE_EXPR] = \"delete []\";\n   opname_tab[(int) COND_EXPR] = \"... ? ... : ...\";\n   opname_tab[(int) CALL_EXPR] = \"()\";\n   opname_tab[(int) PLUS_EXPR] = \"+\";\n@@ -841,10 +847,7 @@ yyprint (file, yychar, yylval)\n     case IDENTIFIER_DEFN:\n     case TYPENAME_DEFN:\n     case PTYPENAME_DEFN:\n-    case TYPENAME_COLON:\n     case TYPENAME_ELLIPSIS:\n-    case SCOPED_TYPENAME:\n-    case SCOPED_NAME:\n     case SCSPEC:\n     case PRE_PARSED_CLASS_DECL:\n       t = yylval.ttype;\n@@ -2324,14 +2327,15 @@ check_newline ()\n   register int c;\n   register int token;\n \n-  lineno++;\n-\n-  /* Read first nonwhite char on the line.  */\n+  /* Read first nonwhite char on the line.  Do this before incrementing the\n+     line number, in case we're at the end of saved text.  */\n \n   do\n     c = getch ();\n   while (c == ' ' || c == '\\t');\n \n+  lineno++;\n+\n   if (c != '#')\n     {\n       /* If not #, return it so caller will use it.  */\n@@ -3080,12 +3084,13 @@ readescape (ignore_ptr)\n   return c;\n }\n \n-/* Value is 1 if we should try to make the next identifier look like a\n-   typename (when it may be a local variable or a class variable).\n-   Value is 0 if we treat this name in a default fashion.\n-   Value is -1 if we must not see a type name.  */\n+/* Value is 1 (or 2) if we should try to make the next identifier look like\n+   a typename (when it may be a local variable or a class variable).\n+   Value is 0 if we treat this name in a default fashion.  */\n int looking_for_typename = 0;\n \n+#if 0\n+/* NO LONGER USED: Value is -1 if we must not see a type name.  */\n void\n dont_see_typename ()\n {\n@@ -3096,6 +3101,7 @@ dont_see_typename ()\n       lastiddecl = 0;\n     }\n }\n+#endif\n \n #ifdef __GNUC__\n extern __inline int identifier_type ();\n@@ -3119,7 +3125,7 @@ see_typename ()\n   looking_for_typename = 0;\n   if (yychar == IDENTIFIER)\n     {\n-      lastiddecl = lookup_name (yylval.ttype, -1);\n+      lastiddecl = lookup_name (yylval.ttype, -2);\n       if (lastiddecl == 0)\n \t{\n \t  if (flag_labels_ok)\n@@ -3540,7 +3546,6 @@ real_yylex ()\n \t  }\n \tif (value == NEW && ! global_bindings_p ())\n \t  {\n-\t    looking_for_typename = 1;\n \t    value = NEW;\n \t    goto done;\n \t  }"}, {"sha": "5288a02435911e695f4a6bf2ba13e6df6ca1d354", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -114,6 +114,9 @@ extern char *token_buffer;\t/* Pointer to token buffer.  */\n /* Back-door communication channel to the lexer.  */\n extern int looking_for_typename;\n \n+/* Tell the lexer where to look for names.  */\n+extern tree got_scope;\n+\n /* Pending language change.\n    Positive is push count, negative is pop count.  */\n extern int pending_lang_change;"}, {"sha": "a39f9a57ae32a78e216b5a23cbc48d0b4651950e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -840,27 +840,22 @@ build_decl_overload (dname, parms, for_method)\n {\n   char *name = IDENTIFIER_POINTER (dname);\n \n-  if (dname == ansi_opname[(int) NEW_EXPR]\n-      && parms != NULL_TREE\n-      && TREE_CODE (parms) == TREE_LIST\n-      && TREE_VALUE (parms) == sizetype\n-      && TREE_CHAIN (parms) == void_list_node)\n-    return get_identifier (\"__builtin_new\");\n-  else if (dname == ansi_opname[(int) DELETE_EXPR]\n-\t   && parms != NULL_TREE\n-\t   && TREE_CODE (parms) == TREE_LIST\n-\t   && TREE_VALUE (parms) == ptr_type_node\n-\t   && TREE_CHAIN (parms) == void_list_node)\n-    return get_identifier (\"__builtin_delete\");\n-  else if (dname == ansi_opname[(int) DELETE_EXPR]\n-\t   && parms != NULL_TREE\n-\t   && TREE_CODE (parms) == TREE_LIST\n-\t   && TREE_VALUE (parms) == ptr_type_node\n-\t   && TREE_CHAIN (parms) != NULL_TREE\n-\t   && TREE_CODE (TREE_CHAIN (parms)) == TREE_LIST\n-\t   && TREE_VALUE (TREE_CHAIN (parms)) == sizetype\n-\t   && TREE_CHAIN (TREE_CHAIN (parms)) == void_list_node)\n-    return get_identifier (\"__builtin_delete\");\n+  /* member operators new and delete look like methods at this point.  */\n+  if (! for_method && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST)\n+    {\n+      if (TREE_VALUE (parms) == sizetype\n+\t  && TREE_CHAIN (parms) == void_list_node)\n+\t{\n+\t  if (dname == ansi_opname[(int) NEW_EXPR])\n+\t    return get_identifier (\"__builtin_new\");\n+\t  else if (dname == ansi_opname[(int) VEC_NEW_EXPR])\n+\t    return get_identifier (\"__builtin_vec_new\");\n+\t}\n+      else if (dname == ansi_opname[(int) DELETE_EXPR])\n+\treturn get_identifier (\"__builtin_delete\");\n+      else if (dname == ansi_opname[(int) VEC_DELETE_EXPR])\n+\treturn get_identifier (\"__builtin_vec_delete\");\n+    }\n \n   OB_INIT ();\n   if (for_method != 2)\n@@ -1112,19 +1107,19 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n       try_second = 0;\n       break;\n \n+    case VEC_NEW_EXPR:\n     case NEW_EXPR:\n       {\n-\tfnname = ansi_opname[(int) NEW_EXPR];\n+\ttree args = tree_cons (NULL_TREE, xarg2, arg3);\n+\tfnname = ansi_opname[(int) code];\n \tif (flags & LOOKUP_GLOBAL)\n-\t  return build_overload_call (fnname, tree_cons (NULL_TREE, xarg2, arg3),\n-\t\t\t\t      flags & LOOKUP_COMPLAIN,\n+\t  return build_overload_call (fnname, args, flags & LOOKUP_COMPLAIN,\n \t\t\t\t      (struct candidate *)0);\n \n \trval = build_method_call\n \t  (build_indirect_ref (build1 (NOP_EXPR, xarg1, error_mark_node),\n \t\t\t       \"new\"),\n-\t   fnname, tree_cons (NULL_TREE, xarg2, arg3),\n-\t   NULL_TREE, flags);\n+\t   fnname, args, NULL_TREE, flags);\n \tif (rval == error_mark_node)\n \t  /* User might declare fancy operator new, but invoke it\n \t     like standard one.  */\n@@ -1136,13 +1131,13 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n       }\n       break;\n \n+    case VEC_DELETE_EXPR:\n     case DELETE_EXPR:\n       {\n-\tfnname = ansi_opname[(int) DELETE_EXPR];\n+\tfnname = ansi_opname[(int) code];\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_overload_call (fnname,\n-\t\t\t\t      tree_cons (NULL_TREE, xarg1,\n-\t\t\t\t\t\t build_tree_list (NULL_TREE, xarg2)),\n+\t\t\t\t      build_tree_list (NULL_TREE, xarg1),\n \t\t\t\t      flags & LOOKUP_COMPLAIN,\n \t\t\t\t      (struct candidate *)0);\n \n@@ -1151,7 +1146,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t\t\t\t       error_mark_node),\n \t\t\t       NULL_PTR),\n \t   fnname, tree_cons (NULL_TREE, xarg1,\n-\t\t\t      build_tree_list (NULL_TREE, xarg2)),\n+\t\t\t       build_tree_list (NULL_TREE, xarg2)),\n \t   NULL_TREE, flags);\n \t/* This happens when the user mis-declares `operator delete'.\n \t   Should now be impossible.  */"}, {"sha": "e199708966a4d8f6d4d2481f72b47dfaf1927e19", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 361, "deletions": 598, "changes": 959, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -66,12 +66,16 @@ extern int errno;\n #endif\n \n extern int end_of_file;\n+extern int current_class_depth;\n \n void yyerror ();\n \n /* Like YYERROR but do call yyerror.  */\n #define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n \n+#define OP0(NODE) (TREE_OPERAND (NODE, 0))\n+#define OP1(NODE) (TREE_OPERAND (NODE, 1))\n+\n /* Contains the statement keyword (if/while/do) to include in an\n    error message if the user supplies an empty conditional expression.  */\n static char *cond_stmt_keyword;\n@@ -112,12 +116,6 @@ empty_parms ()\n    but they can also serve as typespecs in declarations.  */\n %token TYPENAME\n \n-/* Qualified identifiers that end in a TYPENAME.  */\n-%token SCOPED_TYPENAME\n-\n-/* Qualified identifiers that end in a IDENTIFIER.  */\n-%token SCOPED_NAME\n-\n /* Reserved words that specify storage class.\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n %token SCSPEC\n@@ -156,11 +154,6 @@ empty_parms ()\n %token TYPEID DYNAMIC_CAST\n %token <itype> SCOPE\n \n-/* Special token created by the lexer to separate TYPENAME\n-   from an ABSDCL.  This allows us to parse `foo (*pf)()'.  */\n-\n-%token START_DECLARATOR\n-\n /* Define the operator tokens and their precedences.\n    The value is an integer because, if used, it is the tree code\n    to use in the expression made from the operator.  */\n@@ -173,7 +166,7 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME PTYPENAME TYPENAME_COLON SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS SCOPED_TYPENAME TYPEOF SIGOF START_DECLARATOR OPERATOR\n+%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR\n \n %left '{' ',' ';'\n \n@@ -217,30 +210,28 @@ empty_parms ()\n %type <ttype> compstmt except_stmts ansi_except_stmts implicitly_scoped_stmt\n \n %type <ttype> declarator notype_declarator after_type_declarator\n-%type <ttype> notype_declarator1 after_type_declarator1\n %type <ttype> direct_notype_declarator direct_after_type_declarator\n \n %type <ttype> structsp opt.component_decl_list component_decl_list\n %type <ttype> component_decl components component_declarator\n %type <ttype> notype_components notype_component_declarator\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n-%type <ttype> notype_component_declarator0\n+%type <ttype> notype_component_declarator0 component_decl_1\n %type <ttype> enumlist enumerator\n-%type <ttype> type_id absdcl absdcl1 type_quals\n+%type <ttype> type_id absdcl type_quals\n %type <ttype> direct_abstract_declarator conversion_declarator\n %type <ttype> new_type_id new_declarator direct_new_declarator\n %type <ttype> xexpr parmlist parms parm bad_parm\n %type <ttype> identifiers_or_typenames\n %type <ttype> fcast_or_absdcl regcast_or_absdcl sub_cast_expr\n-%type <ttype> expr_or_declarator complex_notype_declarator1\n-%type <ttype> notype_unqualified_id\n+%type <ttype> expr_or_declarator complex_notype_declarator\n+%type <ttype> notype_unqualified_id unqualified_id qualified_id\n+%type <ttype> overqualified_id notype_qualified_id\n %type <ttype> complex_direct_notype_declarator functional_cast\n %type <ttype> named_parm complex_parmlist typed_declspecs1 parms_comma\n \n /* C++ extensions */\n-%type <ttype> typename_scope\n-%token <ttype> TYPENAME_COLON TYPENAME_ELLIPSIS\n-%token <ttype> PTYPENAME SCOPED_TYPENAME SCOPED_NAME\n+%token <ttype> TYPENAME_ELLIPSIS PTYPENAME\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL\n %type <ttype> fn.def1 /* Not really! */\n@@ -251,21 +242,26 @@ empty_parms ()\n %type <itype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n %type <ttype> maybe_raises raise_identifier raise_identifiers ansi_raise_identifier ansi_raise_identifiers\n-%type <ttype> component_declarator0 id_scope scoped_typename scoped_base_class\n-%type <ttype> forhead.1 identifier_or_opname operator_name\n-%type <ttype> new delete object aggr\n+%type <ttype> component_declarator0\n+%type <ttype> forhead.1 operator_name\n+%type <ttype> new object aggr\n+%type <itype> delete\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr\n %type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n %type <itype> .scope try ansi_try\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type template_arg_list template_arg\n-%type <ttype> template_instantiation template_type_name tmpl.1 tmpl.2\n+%type <ttype> template_instantiation template_type_name tmpl.2\n %type <ttype> template_instantiate_once template_instantiate_some\n %type <itype> fn_tmpl_end\n /* %type <itype> try_for_typename */\n %type <ttype> condition partially_scoped_stmt xcond paren_cond_or_null\n %type <strtype> .kindof_pushlevel\n+%type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n+%type <ttype> qualified_type_name complete_type_name notype_identifier\n+%type <ttype> complex_type_name nested_name_specifier_1\n+%type <itype> nomods_initdecls nomods_initdcl0\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n@@ -405,15 +401,6 @@ template_parm:\n \t\t  warning (\"restricted template type parameters not yet implemented\");\n \t\t  $$ = build_tree_list ($2, $4);\n \t\t}\n-\t| aggr TYPENAME_COLON base_class.1\n-\t\t{\n-\t\t  if ($1 == signature_type_node)\n-\t\t    sorry (\"signature as template type parameter\");\n-\t\t  else if ($1 != class_type_node)\n-\t\t    error (\"template type parameter must use keyword `class'\");\n-\t\t  warning (\"restricted template type parameters not yet implemented\");\n-\t\t  $$ = build_tree_list ($2, $3);\n-\t\t}\n \t| parm\n \t;\n \n@@ -528,11 +515,8 @@ fn_tmpl_end: '{'\t\t{ $$ = '{'; }\n \t;\n \n datadef:\n-\t  notype_initdecls ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids data definition with no type or storage class\");\n-  \t\t  else if (! flag_traditional && ! have_extern_spec)\n-  \t\t    warning (\"data definition has no type or storage class\"); }\n+\t  nomods_initdecls ';'\n+\t\t{}\n \t| declmods notype_initdecls ';'\n \t\t{}\n \t/* Normal case to make fast: \"const i;\".  */\n@@ -649,26 +633,6 @@ fn.def1:\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| TYPENAME '(' parmlist ')' type_quals maybe_raises\n-\t\t{ if (! start_function (NULL_TREE, build_parse_node (CALL_EXPR, $$, $3, $5), $6, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n-\t| scoped_typename '(' parmlist ')' type_quals maybe_raises\n-\t\t{ if (! start_function (NULL_TREE, build_parse_node (CALL_EXPR, $$, $3, $5), $6, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n-\t| TYPENAME LEFT_RIGHT type_quals maybe_raises\n-\t\t{ if (! start_function (NULL_TREE, build_parse_node (CALL_EXPR, $$, empty_parms (), $3), $4, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n-\t| scoped_typename LEFT_RIGHT type_quals maybe_raises\n-\t\t{ if (! start_function (NULL_TREE, build_parse_node (CALL_EXPR, $$, empty_parms (), $3), $4, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n \t| PRE_PARSED_FUNCTION_DECL\n \t\t{ start_function (NULL_TREE, TREE_VALUE ($$), NULL_TREE, 1);\n \t\t  reinit_parse_for_function (); }\n@@ -679,61 +643,27 @@ fn.def1:\n fn.def2:\n \t  typed_declspecs '(' parmlist ')' type_quals maybe_raises\n \t\t{\n-\t\t  tree decl = build_parse_node (CALL_EXPR, TREE_VALUE ($$), $3, $5);\n-\t\t  $$ = start_method (TREE_CHAIN ($$), decl, $6);\n+\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1), $3, $5);\n+\t\t  $$ = start_method (TREE_CHAIN ($1), $$, $6);\n+\t\t rest_of_mdef:\n \t\t  if (! $$)\n \t\t    YYERROR1;\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n \t| typed_declspecs LEFT_RIGHT type_quals maybe_raises\n \t\t{\n-\t\t  tree decl = build_parse_node (CALL_EXPR, TREE_VALUE ($$), empty_parms (), $3);\n-\t\t  $$ = start_method (TREE_CHAIN ($$), decl, $4);\n-\t\t  if (! $$)\n-\t\t    YYERROR1;\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n+\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n+\t\t\t\t\t empty_parms (), $3);\n+\t\t  $$ = start_method (TREE_CHAIN ($1), $$, $4);\n+\t\t  goto rest_of_mdef;\n+\t\t}\n \t| typed_declspecs declarator maybe_raises\n-\t\t{ $$ = start_method ($$, $2, $3);\n-\t\t  if (! $$)\n-\t\t    YYERROR1;\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n-\t| declmods '(' parmlist ')' type_quals maybe_raises\n-\t\t{\n-\t\t  tree decl = build_parse_node (CALL_EXPR, TREE_VALUE ($$), $3, $5);\n-\t\t  $$ = start_method (TREE_CHAIN ($$), decl, $6);\n-\t\t  if (! $$)\n-\t\t    YYERROR1;\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n-\t| declmods LEFT_RIGHT type_quals maybe_raises\n-\t\t{\n-\t\t  tree decl = build_parse_node (CALL_EXPR, TREE_VALUE ($$), empty_parms (), $3);\n-\t\t  $$ = start_method (TREE_CHAIN ($$), decl, $4);\n-\t\t  if (! $$)\n-\t\t    YYERROR1;\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n+\t\t{ $$ = start_method ($$, $2, $3); goto rest_of_mdef; }\n \t| declmods notype_declarator maybe_raises\n-\t\t{ $$ = start_method ($$, $2, $3);\n-\t\t  if (! $$)\n-\t\t    YYERROR1;\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n+\t\t{ $$ = start_method ($$, $2, $3); goto rest_of_mdef; }\n \t| notype_declarator maybe_raises\n-\t\t{ $$ = start_method (NULL_TREE, $$, $2);\n-\t\t  if (! $$)\n-\t\t    YYERROR1;\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n+\t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n \t;\n \n return_id: RETURN IDENTIFIER\n@@ -811,27 +741,22 @@ member_init: '(' nonnull_exprlist ')'\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n \t\t  expand_member_init (C_C_D, NULL_TREE, void_type_node);\n \t\t}\n-\t| identifier '(' nonnull_exprlist ')'\n-\t\t{\n-\t\t  expand_member_init (C_C_D, $<ttype>$, $3);\n-\t\t}\n-\t| identifier LEFT_RIGHT\n-\t\t{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }\n-\t| template_type_name '(' nonnull_exprlist ')'\n+\t| notype_identifier '(' nonnull_exprlist ')'\n \t\t{ expand_member_init (C_C_D, $<ttype>$, $3); }\n-\t| template_type_name LEFT_RIGHT\n+\t| notype_identifier LEFT_RIGHT\n \t\t{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }\n-\t| scoped_typename '(' nonnull_exprlist ')'\n+\t| complete_type_name '(' nonnull_exprlist ')'\n \t\t{ expand_member_init (C_C_D, $<ttype>$, $3); }\n-\t| scoped_typename LEFT_RIGHT\n+\t| complete_type_name LEFT_RIGHT\n \t\t{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }\n-\t| id_scope identifier '(' nonnull_exprlist ')'\n+\t/* GNU extension */\n+\t| notype_qualified_id '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  do_member_init ($<ttype>$, $2, $4);\n+\t\t  do_member_init (OP0 ($1), OP1 ($1), $3);\n \t\t}\n-\t| id_scope identifier LEFT_RIGHT\n+\t| notype_qualified_id LEFT_RIGHT\n \t\t{\n-\t\t  do_member_init ($<ttype>$, $2, void_type_node);\n+\t\t  do_member_init (OP0 ($1), OP1 ($1), void_type_node);\n \t\t}\n \t;\n \n@@ -841,56 +766,26 @@ identifier:\n \t| PTYPENAME\n \t;\n \n+notype_identifier:\n+\t  IDENTIFIER\n+\t| PTYPENAME %prec EMPTY\n+\t;\n+\n identifier_defn:\n \t  IDENTIFIER_DEFN\n \t| TYPENAME_DEFN\n \t| PTYPENAME_DEFN\n \t;\n \n-identifier_or_opname:\n-\t  IDENTIFIER\n-\t| TYPENAME\n-\t| PTYPENAME\n-/*\t| '~' TYPENAME\n-\t\t{ $$ = build_parse_node (BIT_NOT_EXPR, $2); }*/\n-\t/* get rid of the next line, replace it with the above */\n-\t| '~' identifier { $$ = build_parse_node (BIT_NOT_EXPR,$2);}\n-\t| operator_name\n-\t;\n-\n explicit_instantiation:\n \t  TEMPLATE aggr template_type\n \t| TEMPLATE typed_declspecs declarator\n \t  { do_function_instantiation ($2, $3); }\n \t;\n \n template_type:\n-\t  template_type_name tmpl.1 template_instantiation\n-\t\t{\n-  \t\t  extern tree template_type_seen_before_scope;\n-\n-\t\t  if ($3) \n-\t\t    $$ = $3;\n-\t\t  else if ($$ != error_mark_node)\n-\t\t    $$ = IDENTIFIER_TYPE_VALUE ($$);\n-\t\t  /* This is a kludge: In order to detect nested types inside\n-\t\t   * template classes, we have to tell the lexer that it should\n-\t\t   * try to replace a following SCOPE token with the correct\n-\t\t   * SCOPED_TYPENAME for the nested type.  This SCOPED_TYPENAME\n-\t\t   * token will be handled in the rule \"scoped_typename\".\n-\t\t   * - niklas@appli.se */\n-\t\t  if (yychar == SCOPE)\n-\t\t    {\n-\t\t      /* We set template_type_seen_before_scope to be\n-\t\t\t an error_mark_node so we can avoid meaningless\n-\t\t\t and unhelpful syntax errors later.  */\n-\t\t      if ($$ != error_mark_node)\n-\t\t\ttemplate_type_seen_before_scope = TYPE_IDENTIFIER ($$);\n-\t\t      else\n-\t\t\ttemplate_type_seen_before_scope = error_mark_node;\n-\t\t      yychar = YYLEX;\n-\t\t    }\n-\t\t}\n+\t  template_type_name tmpl.2 template_instantiation\n+\t\t{ if ($3) $$ = $3; }\n \t;\n \n template_type_name:\n@@ -900,16 +795,7 @@ template_type_name:\n \t\t{ $$ = lookup_template_class ($$, $3, NULL_TREE); }\n \t;\n \n-tmpl.1:\n-\t/* Expansion of template may be required, unless we're followed by\n-\t   a class definition.  */\n-\t  '{'\t{ yyungetc ('{', 1); $$ = 0; }\n-\t| ':'\t{ yyungetc (':', 1); $$ = 0; }\n-\t| /* empty */ %prec EMPTY\n-                { $$ = instantiate_class_template ($<ttype>0, 1); }\n-\t;\n-\n-tmpl.2:\n+tmpl.2: %prec EMPTY\n \t/* Always do expansion if it hasn't been done already. */\n \t\t{ $$ = instantiate_class_template ($<ttype>0, 1); }\n \t;\n@@ -961,7 +847,7 @@ template_instantiate_once:\n \t\t}\n \t  left_curly opt.component_decl_list '}'\n \t\t{\n-\t\t  $$ = finish_struct ($<ttype>3, $5, 0);\n+\t\t  tree t = finish_struct ($<ttype>3, $5, 0);\n \n \t\t  pop_obstacks ();\n \t\t  end_template_instantiation ($1);\n@@ -971,7 +857,7 @@ template_instantiate_once:\n \n \t\t  pop_tinst_level();\n \n-\t\t  CLASSTYPE_GOT_SEMICOLON ($$) = 1;\n+\t\t  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n \t\t}\n \t;\n \n@@ -1229,20 +1115,15 @@ unary_expr:\n \t| .scope new '(' nonnull_exprlist ')' '(' type_id ')'\n \t\t{ $$ = build_new ($4, groktypename ($7), NULL_TREE,\n \t\t\t\t  $$ != NULL_TREE); }\n-\t/* Unswallow a ':' which is probably meant for ?: expression.  */\n-\t| .scope new TYPENAME_COLON\n-\t\t{ yyungetc (':', 1); $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' TYPENAME_COLON\n-\t\t{ yyungetc (':', 1); $$ = build_new ($4, $6, NULL_TREE, $$ != NULL_TREE); }\n \n \t| delete cast_expr  %prec UNARY\n-\t\t{ $$ = delete_sanity ($2, NULL_TREE, 0, $$ != NULL_TREE); }\n+\t\t{ $$ = delete_sanity ($2, NULL_TREE, 0, $1); }\n \t| delete '[' ']' cast_expr  %prec UNARY\n-\t\t{ $$ = delete_sanity ($4, NULL_TREE, 1, $$ != NULL_TREE);\n+\t\t{ $$ = delete_sanity ($4, NULL_TREE, 1, $1);\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX; }\n \t| delete '[' expr ']' cast_expr %prec UNARY\n-\t\t{ $$ = delete_sanity ($5, $3, 2, $$ != NULL_TREE);\n+\t\t{ $$ = delete_sanity ($5, $3, 2, $1);\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX; }\n \t;\n@@ -1368,33 +1249,33 @@ expr_no_commas:\n \t;\n \n notype_unqualified_id:\n-\t  '~' see_typename TYPENAME\n-\t\t{\n-\t\tdestructor_name:\n-\t\t  $$ = build_parse_node (BIT_NOT_EXPR, $3);\n-\t\t}\n-\t| '~' see_typename IDENTIFIER\n-                { goto destructor_name; }\n-\t| '~' see_typename PTYPENAME\n-                { goto destructor_name; }\n+\t  '~' see_typename identifier\n+\t\t{ $$ = build_parse_node (BIT_NOT_EXPR, $3); }\n \t| operator_name\n \t| IDENTIFIER\n \t| PTYPENAME %prec EMPTY\n \t;\n \n+unqualified_id:\n+\t  notype_unqualified_id\n+\t| TYPENAME\n+\t;\n+\n expr_or_declarator:\n-\t  '*' expr_or_declarator %prec UNARY\n+\t  notype_unqualified_id\n+\t| notype_qualified_id\n+\t| '*' expr_or_declarator %prec UNARY\n \t\t{ $$ = build_parse_node (INDIRECT_REF, $2); }\n \t| '&' expr_or_declarator %prec UNARY\n \t\t{ $$ = build_parse_node (ADDR_EXPR, $2); }\n-\t| notype_unqualified_id\n-\t\t{ see_typename (); }\n \t;\n \n direct_notype_declarator:\n \t  complex_direct_notype_declarator\n \t| notype_unqualified_id\n-\t\t{ see_typename (); }\n+\t| notype_qualified_id\n+\t\t{ push_nested_class (TREE_TYPE (OP0 ($$)), 3);\n+\t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n \t;\n \n primary:\n@@ -1474,10 +1355,6 @@ primary:\n                 }\n \t| primary '[' expr ']'\n \t\t{ $$ = grok_array_decl ($$, $3); }\n-\t| object identifier_or_opname  %prec UNARY\n-\t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n-\t| object id_scope identifier_or_opname %prec UNARY\n-\t\t{ $$ = build_object_ref ($$, $2, $3); }\n \t| primary PLUSPLUS\n \t\t{ /* If we get an OFFSET_REF, turn it into what it really\n \t\t     means (e.g., a COMPONENT_REF).  This way if we've got,\n@@ -1569,7 +1446,7 @@ primary:\n \t| TYPEID '(' type_id ')'\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = get_typeid (type); }\n-\t| SCOPE IDENTIFIER\n+\t| global_scope IDENTIFIER\n \t\t{\n \t\tdo_scoped_id:\n \t\t  $$ = IDENTIFIER_GLOBAL_VALUE ($2);\n@@ -1608,19 +1485,24 @@ primary:\n \t\t    }\n \n \t\t}\n-\t| SCOPE operator_name\n+\t| global_scope operator_name\n \t\t{\n+\t\t  got_scope = NULL_TREE;\n \t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    goto do_scoped_id;\n \t\t  $$ = $2;\n \t\t}\n-\t| id_scope identifier_or_opname  %prec HYPERUNARY\n-\t\t{ $$ = build_offset_ref ($$, $2); }\n-\t| id_scope identifier_or_opname '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_member_call ($$, $2, $4); }\n-\t| id_scope identifier_or_opname LEFT_RIGHT\n-\t\t{ $$ = build_member_call ($$, $2, NULL_TREE); }\n-\t| object identifier_or_opname '(' nonnull_exprlist ')'\n+\t| overqualified_id %prec HYPERUNARY\n+\t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n+\t| overqualified_id '(' nonnull_exprlist ')'\n+\t\t{ $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }\n+\t| overqualified_id LEFT_RIGHT\n+\t\t{ $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n+\t| object unqualified_id  %prec UNARY\n+\t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n+\t| object qualified_id %prec UNARY\n+\t\t{ $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n+\t| object unqualified_id '(' nonnull_exprlist ')'\n \t\t{\n #if 0\n \t\t  /* This is a future direction of this code, but because\n@@ -1635,7 +1517,7 @@ primary:\n \t\t\t\t\t  (LOOKUP_NORMAL|LOOKUP_AGGR));\n #endif\n \t\t}\n-\t| object identifier_or_opname LEFT_RIGHT\n+\t| object unqualified_id LEFT_RIGHT\n \t\t{\n #if 0\n \t\t  /* This is a future direction of this code, but because\n@@ -1650,27 +1532,27 @@ primary:\n \t\t\t\t\t  (LOOKUP_NORMAL|LOOKUP_AGGR));\n #endif\n \t\t}\n-\t| object id_scope identifier_or_opname '(' nonnull_exprlist ')'\n+\t| object qualified_id '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE ($2)))\n+\t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n-\t\t      $$ = build_method_call ($$, $3, $5, NULL_TREE,\n+\t\t      $$ = build_method_call ($$, OP1 ($2), $4, NULL_TREE,\n \t\t\t\t\t      (LOOKUP_NORMAL|LOOKUP_AGGR));\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_scoped_method_call ($$, $2, $3, $5);\n+\t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), $4);\n \t\t}\n-\t| object id_scope identifier_or_opname LEFT_RIGHT\n+\t| object qualified_id LEFT_RIGHT\n \t\t{\n-\t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE ($2)))\n+\t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n-\t\t      $$ = build_method_call ($$, $3, NULL_TREE, NULL_TREE,\n+\t\t      $$ = build_method_call ($$, OP1 ($2), NULL_TREE, NULL_TREE,\n \t\t\t\t\t      (LOOKUP_NORMAL|LOOKUP_AGGR));\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_scoped_method_call ($$, $2, $3, NULL_TREE);\n+\t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), NULL_TREE);\n \t\t}\n \t/* p->int::~int() is valid -- 12.4 */\n \t| object '~' TYPESPEC LEFT_RIGHT\n@@ -1741,17 +1623,14 @@ new:\t  NEW\n .scope:\n \t/* empty  */\n \t\t{ $$ = 0; }\n-\t| SCOPE\n-\t\t{ $$ = 1; }\n+\t| global_scope\n+\t\t{ got_scope = NULL_TREE; $$ = 1; }\n \t;\n \n delete:\t  DELETE\n-\t\t{ $$ = NULL_TREE; }\n-\t| SCOPE delete\n-\t\t{ if ($2)\n-\t\t    error (\"extra `::' before `delete' ignored\");\n-\t\t  $$ = error_mark_node;\n-\t\t}\n+\t\t{ $$ = 0; }\n+\t| global_scope delete\n+\t\t{ got_scope = NULL_TREE; $$ = 1; }\n \t;\n \n /* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n@@ -1782,18 +1661,16 @@ object:\t  primary '.'\n \t;\n \n decl:\n-\t  typed_declspecs initdecls ';'\n-\t\t{\n-\t\t  resume_momentary ($2);\n-\t\t  note_list_got_semicolon ($1);\n-\t\t}\n-\t| typespec initdecls ';'\n-\t\t{\n-\t\t  resume_momentary ($2);\n+\t/* Normal case: make this fast.  */\n+\t  typespec declarator ';'\n+\t\t{ tree d = get_decl_list ($1);\n+\t\t  int yes = suspend_momentary ();\n+\t\t  d = start_decl ($2, d, 0, NULL_TREE);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  resume_momentary (yes);\n \t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n \t\t    note_got_semicolon ($1);\n \t\t}\n-\t/* Normal case: make this fast.  */\n \t| typed_declspecs declarator ';'\n \t\t{ tree d = $1;\n \t\t  int yes = suspend_momentary ();\n@@ -1802,29 +1679,23 @@ decl:\n \t\t  resume_momentary (yes);\n \t\t  note_list_got_semicolon ($1);\n \t\t}\n-\t| typespec declarator ';'\n-\t\t{ tree d = get_decl_list ($1);\n-\t\t  int yes = suspend_momentary ();\n-\t\t  d = start_decl ($2, d, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n-\t\t  resume_momentary (yes);\n+\t| typespec initdecls ';'\n+\t\t{\n+\t\t  resume_momentary ($2);\n \t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n \t\t    note_got_semicolon ($1);\n \t\t}\n-\t| declmods notype_initdecls ';'\n-\t\t{ resume_momentary ((int) $<itype>2); }\n-\t/* Normal case: make this fast.  */\n-\t| declmods notype_declarator ';'\n-\t\t{ tree d;\n-\t\t  int yes = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n-\t\t  resume_momentary (yes);\n+\t| typed_declspecs initdecls ';'\n+\t\t{\n+\t\t  resume_momentary ($2);\n+\t\t  note_list_got_semicolon ($1);\n \t\t}\n+\t| declmods notype_initdecls ';'\n+\t\t{ resume_momentary ($2); }\n \t| typed_declspecs ';'\n \t\t{\n-\t\t  shadow_tag ($<ttype>$);\n-\t\t  note_list_got_semicolon ($<ttype>$);\n+\t\t  shadow_tag ($1);\n+\t\t  note_list_got_semicolon ($1);\n \t\t}\n \t| declmods ';'\n \t\t{ warning (\"empty declaration\"); }\n@@ -1950,22 +1821,7 @@ reserved_typespecquals:\n \n typespec: structsp\n \t| TYPESPEC  %prec EMPTY\n-\t| TYPENAME  %prec EMPTY\n-\t| scoped_typename %prec EMPTY\n-\t| SCOPE TYPENAME %prec EMPTY\n-\t\t{ $$ = IDENTIFIER_GLOBAL_VALUE ($2);\n-                  if (!$$)\n-\t\t    {\n-                      error (\"undeclared variable `%s' (first use here)\",\n-                      IDENTIFIER_POINTER ($2));\n-                      $$ = error_mark_node;\n-                      IDENTIFIER_GLOBAL_VALUE ($2) = error_mark_node;\n-\t\t    }\n-\t\t  else \n-\t\t    {\n-\t\t      $$ = TREE_TYPE($$);\n-\t\t    }\n-\t\t}\n+\t| complete_type_name\n \t| TYPEOF '(' expr ')'\n \t\t{ $$ = TREE_TYPE ($3);\n \t\t  if (pedantic)\n@@ -2002,7 +1858,6 @@ typespec: structsp\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n-\t| template_type %prec EMPTY\n \t;\n \n /* A typespec that is a reserved word, or a type qualifier.  */\n@@ -2022,6 +1877,11 @@ notype_initdecls:\n \t| notype_initdecls ',' initdcl\n \t;\n \n+nomods_initdecls:\n+\t  nomods_initdcl0\n+\t| nomods_initdecls ',' initdcl\n+\t;\n+\n maybeasm:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n@@ -2098,6 +1958,25 @@ notype_initdcl0:\n \t\t  finish_decl (d, NULL_TREE, $3, 0); }\n \t;\n \n+nomods_initdcl0:\n+\t  notype_declarator maybe_raises maybeasm maybe_attribute '='\n+\t\t{ current_declspecs = NULL_TREE;\n+\t\t  $<itype>5 = suspend_momentary ();\n+\t\t  $<ttype>$ = start_decl ($1, current_declspecs, 1, $2);\n+\t\t  cplus_decl_attributes ($<ttype>$, $4); }\n+\t  init\n+/* Note how the declaration of the variable is in effect while its init is parsed! */\n+\t\t{ finish_decl ($<ttype>6, $7, $3, 0);\n+\t\t  $$ = $<itype>5; }\n+\t| notype_declarator maybe_raises maybeasm maybe_attribute\n+\t\t{ tree d;\n+\t\t  current_declspecs = NULL_TREE;\n+\t\t  $$ = suspend_momentary ();\n+\t\t  d = start_decl ($1, current_declspecs, 0, $2);\n+\t\t  cplus_decl_attributes (d, $4);\n+\t\t  finish_decl (d, NULL_TREE, $3, 0); }\n+\t;\n+\n /* the * rules are dummies to accept the Apollo extended syntax\n    so that the header files compile. */\n maybe_attribute:\n@@ -2223,6 +2102,8 @@ structsp:\n \t\t  check_for_missing_semicolon ($$); }\n \t| ENUM identifier\n \t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 0); }\n+\t| ENUM complex_type_name\n+\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 0); }\n \n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly opt.component_decl_list '}'\n@@ -2319,11 +2200,11 @@ aggr:\t  AGGR\n \n named_class_head_sans_basetype:\n \t  aggr identifier\n-\t\t{ aggr1: current_aggr = $$; $$ = $2; }\n-\t| aggr template_type_name  %prec EMPTY\n \t\t{ current_aggr = $$; $$ = $2; }\n-\t| aggr TYPENAME_COLON\n-\t\t{ yyungetc (':', 1); goto aggr1; }\n+\t| aggr complex_type_name\n+\t\t{ current_aggr = $$; $$ = $2; }\n+\t| aggr template_type %prec EMPTY\n+\t\t{ current_aggr = $$; $$ = $2; }\n \t| aggr template_type_name '{'\n \t\t{ yyungetc ('{', 1);\n \t\taggr2:\n@@ -2415,10 +2296,6 @@ base_class:\n \t\t  else\n \t\t    $$ = build_tree_list ((tree)access_default, $$);\n \t\t}\n-\t| scoped_base_class\n-\t\t{\n-\t\t  goto do_base_class1;\n-\t\t}\n \t| base_class_access_list base_class.1\n \t\t{\n \t\t  tree type;\n@@ -2448,36 +2325,10 @@ base_class:\n \t\t  else\n \t\t    $$ = build_tree_list ((tree) $$, $2);\n \t\t}\n-\t| base_class_access_list scoped_base_class\n-\t\t{\n-\t\t  goto do_base_class2;\n-\t\t}\n \t;\n \n-scoped_base_class:\n-\t  base_class.1 SCOPED_TYPENAME\n-\t\t{\n-  \t\t  /* Kludge!!! See rule \"template_type\" and the code\n-\t\t   * dealing with \"template_type_seen_before_scope\" in\n-\t\t   * yylex(). */\n-  \t\t  $$ = $2;\n-\t\t}\n-\t;\n base_class.1:\n-\t  template_type_name tmpl.2 template_instantiation\n-\t\t{\n-  \t\t  extern tree template_type_seen_before_scope;\n-\t\t  tree id = $3 ? TYPE_IDENTIFIER ($3) : $1;\n-\n-  \t\t  /* Check the rule template_type to get this... */\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  if (yychar == SCOPE) {\n-\t\t    template_type_seen_before_scope = id;\n-\t\t    yychar = YYLEX;\n-\t\t  }\n-\t\t}\n-\t| identifier\n+\t  complete_type_name\n \t| SIGOF '(' expr ')'\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n@@ -2585,9 +2436,11 @@ left_curly: '{'\n                     }\n \t\t  pushclass ($<ttype>0, 0);\n \t\t  TYPE_BEING_DEFINED ($<ttype>0) = 1;\n+#if 0\n \t\t  t = TYPE_IDENTIFIER ($<ttype>0);\n \t\t  if (t && IDENTIFIER_TEMPLATE (t))\n \t\t    overload_template_name (t, 1);\n+#endif\n \t\t}\n \t;\n \n@@ -2642,81 +2495,58 @@ component_decl_list:\n \t;\n \n component_decl:\n-\t/* Do not add a \"typed_declspecs declarator ';'\" rule here for\n+\t  component_decl_1 ';'\n+\t| component_decl_1 '}'\n+\t\t{ error (\"missing ';' before right brace\");\n+\t\t  yyungetc ('}', 0); }\n+\t/* C++: handle constructors, destructors and inline functions */\n+\t/* note that INLINE is like a TYPESPEC */\n+\t| fn.def2 ':' /* base_init compstmt */\n+\t\t{ $$ = finish_method ($$); }\n+\t| fn.def2 '{' /* nodecls compstmt */\n+\t\t{ $$ = finish_method ($$); }\n+\t;\n+\n+component_decl_1:\n+\t/* Do not add a \"typed_declspecs declarator\" rule here for\n \t   speed; we need to call grok_x_components for enums, so the\n \t   speedup would be insignificant.  */\n-\t  typed_declspecs components ';'\n+\t  typed_declspecs components\n \t\t{\n \t\t  $$ = grok_x_components ($$, $2);\n \t\t  end_exception_decls ();\n \t\t}\n-\t/* These rules introduce a reduce/reduce conflict; in\n-\t\ttypedef int foo, bar;\n-\t\tclass A {\n-\t\t  foo (bar);\n-\t\t};\n-\t   should \"A::foo\" be declared as a function or data member?  \n-\t   In other words, is \"bar\" an after_type_declarator or a parmlist? */\n-\t| typed_declspecs '(' parmlist ')' ';'\n-\t\t{ $$ = groktypefield ($$, $3); }\n-\t| typed_declspecs '(' parmlist ')' '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = groktypefield ($$, $3); }\n-\t| typed_declspecs LEFT_RIGHT ';'\n-\t\t{ $$ = groktypefield ($$, empty_parms ()); }\n-\t| typed_declspecs LEFT_RIGHT '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = groktypefield ($$, empty_parms ()); }\n-\t| declmods notype_components ';'\n+\t| declmods notype_components\n \t\t{ \n \t\t  $$ = grok_x_components ($$, $2);\n \t\t  end_exception_decls ();\n \t\t}\n-\t/* Normal case: make this fast.  */\n-\t| declmods notype_declarator ';'\n-\t\t{ $$ = grokfield ($<ttype>2, $<ttype>$,\n-\t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE); }\n-\t| declmods notype_components '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = grok_x_components ($$, $2);\n-\t\t  end_exception_decls ();\n-\t\t}\n-\t| declmods '(' parmlist ')' ';'\n-\t\t{ $$ = groktypefield ($$, $3); }\n-\t| declmods '(' parmlist ')' '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = groktypefield ($$, $3); }\n-\t| declmods LEFT_RIGHT ';'\n-\t\t{ $$ = groktypefield ($$, empty_parms ()); }\n-\t| declmods LEFT_RIGHT '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = groktypefield ($$, empty_parms ()); }\n-\t| ':' expr_no_commas ';'\n+\t| notype_declarator maybe_raises maybeasm maybe_attribute\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $2, NULL_TREE, $3);\n+\t\t  cplus_decl_attributes ($$, $4); }\n+\t| ':' expr_no_commas\n \t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n-\t| ':' expr_no_commas '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n \t| error\n \t\t{ $$ = NULL_TREE; }\n \n-\t/* C++: handle constructors, destructors and inline functions */\n-\t/* note that INLINE is like a TYPESPEC */\n-\t| fn.def2 ':' /* base_init compstmt */\n-\t\t{ $$ = finish_method ($$); }\n-\t| fn.def2 '{' /* nodecls compstmt */\n-\t\t{ $$ = finish_method ($$); }\n-\t| notype_declarator maybe_raises ';'\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $2, NULL_TREE, NULL_TREE); }\n-\t| notype_declarator maybe_raises '}'\n-\t\t{ error (\"missing ';' before right brace\");\n-\t\t  yyungetc ('}', 0);\n-\t\t  $$ = grokfield ($$, NULL_TREE, $2, NULL_TREE, NULL_TREE); }\n+\t/* These rules introduce a reduce/reduce conflict; in\n+\t\ttypedef int foo, bar;\n+\t\tclass A {\n+\t\t  foo (bar);\n+\t\t};\n+\t   should \"A::foo\" be declared as a function or \"A::bar\" as a data\n+\t   member? In other words, is \"bar\" an after_type_declarator or a\n+\t   parmlist? */\n+\t| typed_declspecs '(' parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n+\t\t\t\t\t $3, $5);\n+\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), NULL_TREE, NULL_TREE,\n+\t\t\t\t  NULL_TREE); }\n+\t| typed_declspecs LEFT_RIGHT type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, TREE_VALUE ($1),\n+\t\t\t\t\t empty_parms (), $3);\n+\t\t  $$ = grokfield ($$, TREE_CHAIN ($1), NULL_TREE, NULL_TREE,\n+\t\t\t\t  NULL_TREE); }\n \t;\n \n /* The case of exactly one component is handled directly by component_decl. */\n@@ -2850,13 +2680,6 @@ new_type_id:\n \t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n \t;\n \n-/* ANSI abstract-declarator (8.1) */\n-absdcl:\n-\t  absdcl1  %prec EMPTY\n-\t| START_DECLARATOR absdcl1  %prec EMPTY\n-\t\t{ $$ = $2; }\n-\t;\n-\n type_quals:\n \t  /* empty */ %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n@@ -2883,32 +2706,31 @@ nonmomentary_expr:\n /* A declarator that is allowed only after an explicit typespec.  */\n /* may all be followed by prec '.' */\n after_type_declarator:\n-\t  after_type_declarator1\n-\t| START_DECLARATOR after_type_declarator1\n-\t\t{ $$ = $2; }\n-\t;\n-\n-after_type_declarator1:\n-\t  '*' nonempty_type_quals after_type_declarator1  %prec UNARY\n+\t  '*' nonempty_type_quals after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' nonempty_type_quals after_type_declarator1  %prec UNARY\n+\t| '&' nonempty_type_quals after_type_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| '*' after_type_declarator1  %prec UNARY\n+\t| '*' after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n-\t| '&' after_type_declarator1  %prec UNARY\n+\t| '&' after_type_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| id_scope '*' type_quals after_type_declarator1\n-\t\t{ tree arg = make_pointer_declarator ($3, $4);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals after_type_declarator\n+\t\t{ tree arg = make_pointer_declarator ($2, $3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| direct_after_type_declarator\n \t;\n \n+qualified_type_name:\n+\t  type_name %prec EMPTY\n+\t| nested_type\n+\t;\n+\n+nested_type:\n+\tnested_name_specifier type_name %prec EMPTY\n+\t\t{ $$ = $2; }\n+\t;\n+\n direct_after_type_declarator:\n \t  direct_after_type_declarator '(' nonnull_exprlist ')' type_quals %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n@@ -2922,58 +2744,46 @@ direct_after_type_declarator:\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_after_type_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n-\t| '(' after_type_declarator1 ')'\n+\t| '(' after_type_declarator ')'\n \t\t{ $$ = $2; }\n-\t| TYPENAME %prec EMPTY\n+\t| nested_name_specifier type_name %prec EMPTY\n+\t\t{ push_nested_class (TREE_TYPE ($$), 3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $$, $2);\n+\t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n+\t| type_name %prec EMPTY\n \t;\n \n /* A declarator allowed whether or not there has been\n    an explicit typespec.  These cannot redeclare a typedef-name.  */\n \n notype_declarator:\n-          notype_declarator1\n-        | START_DECLARATOR notype_declarator1\n-\t\t{ $$ = $2; }\n-\t;\n-\n-notype_declarator1:\n-\t  '*' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t  '*' nonempty_type_quals notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t| '&' nonempty_type_quals notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| '*' notype_declarator1  %prec UNARY\n+\t| '*' notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n-\t| '&' notype_declarator1  %prec UNARY\n+\t| '&' notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| id_scope '*' type_quals notype_declarator1\n-\t\t{ tree arg = make_pointer_declarator ($3, $4);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals notype_declarator\n+\t\t{ tree arg = make_pointer_declarator ($2, $3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| direct_notype_declarator\n \t;\n \n-complex_notype_declarator1:\n-\t  '*' nonempty_type_quals notype_declarator1  %prec UNARY\n+complex_notype_declarator:\n+\t  '*' nonempty_type_quals notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t| '&' nonempty_type_quals notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| '*' complex_notype_declarator1  %prec UNARY\n+\t| '*' complex_notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n-\t| '&' complex_notype_declarator1  %prec UNARY\n+\t| '&' complex_notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| id_scope '*' type_quals notype_declarator1\n-\t\t{ tree arg = make_pointer_declarator ($3, $4);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals notype_declarator\n+\t\t{ tree arg = make_pointer_declarator ($2, $3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| complex_direct_notype_declarator\n \t;\n@@ -2989,40 +2799,30 @@ complex_direct_notype_declarator:\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, NULL_TREE, NULL_TREE); }\n \t| '(' expr_or_declarator ')'\n \t\t{ $$ = finish_decl_parsing ($2); }\n-\t| '(' complex_notype_declarator1 ')'\n+\t| '(' complex_notype_declarator ')'\n \t\t{ $$ = $2; }\n \t| direct_notype_declarator '[' nonmomentary_expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_notype_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n+\t;\n \n-\t/* C++ extensions.  */\n-\t| id_scope see_typename notype_unqualified_id\n-\t\t{ see_typename ();\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, $3);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = $3;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, $3);\n-\t\t}\n-\t| id_scope see_typename TYPENAME\n-\t\t{ $$ = build_push_scope ($$, $3); }\n-\t| SCOPE see_typename direct_notype_declarator\n-\t\t{ $$ = build_parse_node (SCOPE_REF, NULL_TREE, $3); }\n-\t| template_type SCOPED_NAME \n-\t\t{ tree t;\n-\t\t  extern int current_class_depth;\n+qualified_id:\n+\tnested_name_specifier unqualified_id\n+\t\t{ got_scope = NULL_TREE;\n+\t\t  $$ = build_parse_node (SCOPE_REF, $$, $2); }\n+\t;\n \n-\t\t  t = TREE_TYPE(TREE_OPERAND($2, 0));\n-\t\t  if (t != current_class_type &&\n-\t\t      TREE_CODE(t) != TEMPLATE_TYPE_PARM)\n-\t\t    {\n-\t\t      push_nested_class(t, 3);\n-\t\t      TREE_COMPLEXITY ($2) = current_class_depth;\n-\t\t    }\n-\t\t  $$ = $2; \n-\t\t}\n+notype_qualified_id:\n+\tnested_name_specifier notype_unqualified_id\n+\t\t{ got_scope = NULL_TREE;\n+\t\t  $$ = build_parse_node (SCOPE_REF, $$, $2); }\n+\t;\n+\n+overqualified_id:\n+\t  notype_qualified_id\n+\t| global_scope notype_qualified_id\n+\t\t{ $$ = $2; }\n \t;\n \n functional_cast:\n@@ -3034,61 +2834,60 @@ functional_cast:\n \t\t{ $$ = reparse_absdcl_as_expr ($$, $2); }\n \t;\n \n-id_scope: typename_scope\n-\t\t{ tree t;\n-                  do_id_scope:\n+type_name:\n+\t  TYPENAME\n+\t| template_type %prec EMPTY\n+\t;\n \n-\t\t  t = resolve_scope_to_name (NULL_TREE, $$);\n-\t\t  if (t == NULL_TREE)\n-\t\t    {\n-\t\t      cp_error (\"`%T' is not a valid scope\", $$);\n-\t\t      $$ = error_mark_node; \n-\t\t    }\n-\t\t  else\n-\t\t    $$ = t;\n-\t\t}\n+nested_name_specifier:\n+\t  nested_name_specifier_1\n+\t| nested_name_specifier nested_name_specifier_1\n+\t\t{ $$ = $2; }\n+\t;\n+\n+/* Why the @#$%^& do type_name and notype_identifier need to be expanded\n+   inline here?!?  (jason) */\n+nested_name_specifier_1:\n+\t  TYPENAME SCOPE\n+\t\t{ got_scope = TREE_TYPE ($$); }\n+\t| template_type SCOPE\n+\t\t{ got_scope = TREE_TYPE ($$); }\n+/* \tThese break 'const i;'\n \t| IDENTIFIER SCOPE\n-\t\t{ goto do_id_scope; }\n-\t| template_type SCOPE /* try_for_typename %prec EMPTY */\n \t\t{\n-                  if ($$ == error_mark_node)\n-                    /* leave it alone */;\n-                  else\n-\t\t    {\n-\t\t      $$ = resolve_scope_to_name (NULL_TREE, TYPE_IDENTIFIER ($$));\n-\t\t      if ($$ == NULL_TREE)\n-\t\t\t{\n-\t\t\t  error (\"undefined explicitly scoped type\");\n-\t\t\t  $$ = error_mark_node; \n-\t\t\t}\n-\t\t    }\n-/*                  if ($3) popclass (1); */\n+\t\t failed_scope:\n+\t\t  cp_error (\"`%D' is not an aggregate typedef\", \n+\t\t\t    lastiddecl ? lastiddecl : $$);\n+\t\t  $$ = error_mark_node;\n \t\t}\n+\t| PTYPENAME SCOPE\n+\t\t{ goto failed_scope; } */\n \t;\n \n-typename_scope:\n-\tTYPENAME SCOPE;\n+complete_type_name:\n+\t  qualified_type_name\n+\t| global_scope qualified_type_name\n+\t\t{ $$ = $2; }\n+\t;\n \n-scoped_typename: SCOPED_TYPENAME\n-\t| template_type SCOPED_TYPENAME\n-\t\t{\n-  \t\t  /* Kludge!!! See rule \"template_type\" and the code\n-\t\t   * dealing with \"template_type_seen_before_scope\" in\n-\t\t   * yylex(). */\n-\t\t  $$ = $2;\n-\t\t}\n-/*\t| template_type SCOPE try_for_typename TYPENAME\n-\t\t{\n-                  if ($$ == error_mark_node)\n-                    ;\n-\t\t  else\n-\t\t    {\n-                      $$ = build_parse_node (SCOPE_REF,\n-                                             TYPE_IDENTIFIER ($$),\n-                                             $4);\n-                    }\n-\t\t  if ($3) popclass (1);\n-\t\t} */\n+complex_type_name:\n+\t  nested_type\n+\t| global_scope qualified_type_name\n+\t\t{ $$ = $2; }\n+\t;\n+\n+ptr_to_mem:\n+\t  nested_name_specifier '*'\n+\t\t{ got_scope = NULL_TREE; }\n+\t| global_scope nested_name_specifier '*'\n+\t\t{ $$ = $2; got_scope = NULL_TREE; }\n+\t;\n+\n+/* All uses of explicit global scope must go through this nonterminal so\n+   that got_scope will be set before yylex is called to get the next token. */\n+global_scope:\n+\t  SCOPE\n+\t\t{ got_scope = void_type_node; }\n \t;\n \n /* ANSI new-declarator (5.3.4) */\n@@ -3101,23 +2900,13 @@ new_declarator:\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n \t| '&' type_quals %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n-\t| id_scope '*' type_quals %prec EMPTY\n-\t\t{ tree arg = make_pointer_declarator ($3, NULL_TREE);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals %prec EMPTY\n+\t\t{ tree arg = make_pointer_declarator ($2, NULL_TREE);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n-\t| id_scope '*' type_quals new_declarator\n-\t\t{ tree arg = make_pointer_declarator ($3, $4);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals new_declarator\n+\t\t{ tree arg = make_pointer_declarator ($2, $3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| direct_new_declarator %prec EMPTY\n \t;\n@@ -3131,48 +2920,36 @@ direct_new_declarator:\n \t;\n \n /* ANSI abstract-declarator (8.1) */\n-absdcl1:\n-\t  '*' nonempty_type_quals absdcl1\n+absdcl:\n+\t  '*' nonempty_type_quals absdcl\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '*' absdcl1\n+\t| '*' absdcl\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '*' type_quals  %prec EMPTY\n \t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-\t| '&' nonempty_type_quals absdcl1\n+\t| '&' nonempty_type_quals absdcl\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| '&' absdcl1\n+\t| '&' absdcl\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n \t| '&' type_quals %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n-\t| id_scope '*' type_quals %prec EMPTY\n-\t\t{ tree arg = make_pointer_declarator ($3, NULL_TREE);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals %prec EMPTY\n+\t\t{ tree arg = make_pointer_declarator ($2, NULL_TREE);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n-\t| id_scope '*' type_quals absdcl1\n-\t\t{ tree arg = make_pointer_declarator ($3, $4);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals absdcl\n+\t\t{ tree arg = make_pointer_declarator ($2, $3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| direct_abstract_declarator %prec EMPTY\n \t;\n \n /* ANSI direct-abstract-declarator (8.1) */\n direct_abstract_declarator:\n-\t  '(' absdcl1 ')'\n-\t\t{ see_typename ();\n-\t\t  $$ = $2; }\n+\t  '(' absdcl ')'\n+\t\t{ $$ = $2; }\n \t  /* `(typedef)1' is `int'.  */\n \t| PAREN_STAR_PAREN\n-\t\t{ see_typename (); }\n \t| direct_abstract_declarator '(' parmlist ')' type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n \t| direct_abstract_declarator LEFT_RIGHT type_quals  %prec '.'\n@@ -3813,11 +3590,6 @@ label_colon:\n \t\t}\n \t| PTYPENAME ':'\n \t\t{ goto do_label; }\n-\t| TYPENAME_COLON\n-\t\t{ tree label = define_label (input_filename, lineno, $1);\n-\t\t  if (label)\n-\t\t    expand_label (label);\n-\t\t}\n \t;\n \n try_head: TRY '{' { cplus_expand_start_try (0); } .pushlevel\n@@ -4160,23 +3932,17 @@ named_parm:\n \t/* Here we expand typed_declspecs inline to avoid mis-parsing of\n \t   TYPESPEC IDENTIFIER.  */\n \t  typed_declspecs1 declarator\n-\t\t{ $$ = build_tree_list ($$, $2);\n-\t\t  see_typename (); }\n+\t\t{ $$ = build_tree_list ($$, $2); }\n \t| typed_typespecs declarator\n-\t\t{ $$ = build_tree_list ($$, $2);\n-\t\t  see_typename (); }\n+\t\t{ $$ = build_tree_list ($$, $2); }\n \t| typespec declarator\n-\t\t{ $$ = build_tree_list (get_decl_list ($$), $2);\n-\t\t  see_typename (); }\n+\t\t{ $$ = build_tree_list (get_decl_list ($$), $2); }\n \t| typed_declspecs1 absdcl\n-\t\t{ $$ = build_tree_list ($$, $2);\n-\t\t  see_typename (); }\n+\t\t{ $$ = build_tree_list ($$, $2); }\n \t| typed_declspecs1 %prec EMPTY\n-\t\t{ $$ = build_tree_list ($$, NULL_TREE);\n-\t\t  see_typename (); }\n+\t\t{ $$ = build_tree_list ($$, NULL_TREE); }\n \t| declmods notype_declarator\n-\t\t{ $$ = build_tree_list ($$, $2);\n-\t\t  see_typename (); }\n+\t\t{ $$ = build_tree_list ($$, $2); }\n \t;\n \n parm:\n@@ -4235,13 +4001,10 @@ raise_identifier:\n \t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n \t| TYPENAME\n \t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n-\t| SCOPE IDENTIFIER\n-\t\t{ $$ = build_decl_list (void_type_node, $2); }\n-\t| SCOPE TYPENAME\n-\t\t{ $$ = build_decl_list (void_type_node, $2); }\n-\t| id_scope IDENTIFIER\n-\t\t{ $$ = build_decl_list ($$, $2); }\n-\t| scoped_typename\n+\t| global_scope IDENTIFIER\n+\t\t{ $$ = build_decl_list (NULL_TREE, $2); }\n+\t| global_scope TYPENAME\n+\t\t{ $$ = build_decl_list (NULL_TREE, $2); }\n \t;\n \n ansi_raise_identifier:\n@@ -4274,87 +4037,87 @@ conversion_declarator:\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| '&' type_quals conversion_declarator\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| id_scope '*' type_quals conversion_declarator\n-\t\t{ tree arg = make_pointer_declarator ($3, $4);\n-\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n-\t\t    $$ = build_push_scope ($$, arg);\n-\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n-\t\t    TREE_OPERAND ($$, 1) = arg;\n-\t\t  else\n-\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t| ptr_to_mem type_quals conversion_declarator\n+\t\t{ tree arg = make_pointer_declarator ($2, $3);\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t;\n \n+operator: OPERATOR\n+\t\t{ got_scope = NULL_TREE; }\n+\t;\n+\n operator_name:\n-\t  OPERATOR '*'\n+\t  operator '*'\n \t\t{ $$ = ansi_opname[MULT_EXPR]; }\n-\t| OPERATOR '/'\n+\t| operator '/'\n \t\t{ $$ = ansi_opname[TRUNC_DIV_EXPR]; }\n-\t| OPERATOR '%'\n+\t| operator '%'\n \t\t{ $$ = ansi_opname[TRUNC_MOD_EXPR]; }\n-\t| OPERATOR '+'\n+\t| operator '+'\n \t\t{ $$ = ansi_opname[PLUS_EXPR]; }\n-\t| OPERATOR '-'\n+\t| operator '-'\n \t\t{ $$ = ansi_opname[MINUS_EXPR]; }\n-\t| OPERATOR '&'\n+\t| operator '&'\n \t\t{ $$ = ansi_opname[BIT_AND_EXPR]; }\n-\t| OPERATOR '|'\n+\t| operator '|'\n \t\t{ $$ = ansi_opname[BIT_IOR_EXPR]; }\n-\t| OPERATOR '^'\n+\t| operator '^'\n \t\t{ $$ = ansi_opname[BIT_XOR_EXPR]; }\n-\t| OPERATOR '~'\n+\t| operator '~'\n \t\t{ $$ = ansi_opname[BIT_NOT_EXPR]; }\n-\t| OPERATOR ','\n+\t| operator ','\n \t\t{ $$ = ansi_opname[COMPOUND_EXPR]; }\n-\t| OPERATOR ARITHCOMPARE\n+\t| operator ARITHCOMPARE\n \t\t{ $$ = ansi_opname[$2]; }\n-\t| OPERATOR '<'\n+\t| operator '<'\n \t\t{ $$ = ansi_opname[LT_EXPR]; }\n-\t| OPERATOR '>'\n+\t| operator '>'\n \t\t{ $$ = ansi_opname[GT_EXPR]; }\n-\t| OPERATOR EQCOMPARE\n+\t| operator EQCOMPARE\n \t\t{ $$ = ansi_opname[$2]; }\n-\t| OPERATOR ASSIGN\n+\t| operator ASSIGN\n \t\t{ $$ = ansi_assopname[$2]; }\n-\t| OPERATOR '='\n+\t| operator '='\n \t\t{ $$ = ansi_opname [MODIFY_EXPR]; }\n-\t| OPERATOR LSHIFT\n+\t| operator LSHIFT\n \t\t{ $$ = ansi_opname[$2]; }\n-\t| OPERATOR RSHIFT\n+\t| operator RSHIFT\n \t\t{ $$ = ansi_opname[$2]; }\n-\t| OPERATOR PLUSPLUS\n+\t| operator PLUSPLUS\n \t\t{ $$ = ansi_opname[POSTINCREMENT_EXPR]; }\n-\t| OPERATOR MINUSMINUS\n+\t| operator MINUSMINUS\n \t\t{ $$ = ansi_opname[PREDECREMENT_EXPR]; }\n-\t| OPERATOR ANDAND\n+\t| operator ANDAND\n \t\t{ $$ = ansi_opname[TRUTH_ANDIF_EXPR]; }\n-\t| OPERATOR OROR\n+\t| operator OROR\n \t\t{ $$ = ansi_opname[TRUTH_ORIF_EXPR]; }\n-\t| OPERATOR '!'\n+\t| operator '!'\n \t\t{ $$ = ansi_opname[TRUTH_NOT_EXPR]; }\n-\t| OPERATOR '?' ':'\n+\t| operator '?' ':'\n \t\t{ $$ = ansi_opname[COND_EXPR]; }\n-\t| OPERATOR MIN_MAX\n+\t| operator MIN_MAX\n \t\t{ $$ = ansi_opname[$2]; }\n-\t| OPERATOR POINTSAT  %prec EMPTY\n+\t| operator POINTSAT  %prec EMPTY\n \t\t{ $$ = ansi_opname[COMPONENT_REF]; }\n-\t| OPERATOR POINTSAT_STAR  %prec EMPTY\n+\t| operator POINTSAT_STAR  %prec EMPTY\n \t\t{ $$ = ansi_opname[MEMBER_REF]; }\n-\t| OPERATOR LEFT_RIGHT\n+\t| operator LEFT_RIGHT\n \t\t{ $$ = ansi_opname[CALL_EXPR]; }\n-\t| OPERATOR '[' ']'\n+\t| operator '[' ']'\n \t\t{ $$ = ansi_opname[ARRAY_REF]; }\n-\t| OPERATOR NEW\n+\t| operator NEW %prec EMPTY\n \t\t{ $$ = ansi_opname[NEW_EXPR]; }\n-\t| OPERATOR DELETE\n+\t| operator DELETE %prec EMPTY\n \t\t{ $$ = ansi_opname[DELETE_EXPR]; }\n-/*\t| OPERATOR NEW '[' ']'\n+\t| operator NEW '[' ']'\n \t\t{ $$ = ansi_opname[VEC_NEW_EXPR]; }\n-\t| OPERATOR DELETE '[' ']'\n-\t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }  */\n-\t| OPERATOR typed_typespecs conversion_declarator\n+\t| operator DELETE '[' ']'\n+\t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }\n+\t/* Should we be pushing into class scope to parse this?  */\n+\t| operator typed_typespecs conversion_declarator\n \t\t{ $$ = grokoptypename ($2, $3); }\n-\t| OPERATOR error\n+\t| operator error\n \t\t{ $$ = ansi_opname[ERROR_MARK]; }\n \t;\n "}, {"sha": "ef2fbb28f1ac56dce8c0129a84b4b2dff6219cdd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -1690,6 +1690,7 @@ instantiate_template (tmpl, targ_ptr)\n   return fndecl;\n }\n \n+/* classlevel should now never be true.  jason 4/12/94 */\n void\n undo_template_name_overload (id, classlevel)\n      tree id;\n@@ -1711,6 +1712,7 @@ undo_template_name_overload (id, classlevel)\n #endif\n }\n \n+/* classlevel should now never be true.  jason 4/12/94 */\n void\n overload_template_name (id, classlevel)\n      tree id;\n@@ -1731,12 +1733,9 @@ overload_template_name (id, classlevel)\n \n #if 1 /* XXX */\n   /* This was a botch... names of templates do not get their own private\n-     scopes.  Rather, the names of generated template instances should\n-     just get pushed into whatever scope we happen to be in at the moment.\n-     This will typically (but not always) be the global scope.  (Maybe\n-     what we really want to do here is a `push_to_toplevel' and then stay\n-     there while we are generating the instance; popping back out to the\n-     current scope when we are done generating the instance.)  */\n+     scopes.  Rather, they should go into the binding level already created\n+     by push_template_decls.  Except that there isn't one of those for\n+     specializations.  */\n   if (!classlevel)\n     {\n       pushlevel (1);\n@@ -1765,20 +1764,13 @@ overload_template_name (id, classlevel)\n   if (classlevel)\n     pushdecl_class_level (decl);\n   else\n-#if 0 /* not yet, should get fixed properly later */\n     pushdecl (decl);\n-  pushlevel (1);\n-#else\n-    {\n-      pushdecl (decl);\n-      /* @@ Is this necessary now?  */\n-      IDENTIFIER_LOCAL_VALUE (template) = decl;\n-    }\n-#endif\n \n+#if 0 /* This seems bogus to me; if it isn't, explain why.  (jason) */\n   /* Fake this for now, just to make dwarfout.c happy.  It will have to\n      be done in a proper way later on.  */\n   DECL_CONTEXT (decl) = t;\n+#endif\n }\n \n /* NAME is the IDENTIFIER value of a PRE_PARSED_CLASS_DECL. */\n@@ -2028,6 +2020,22 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \treturn 0;\n       else if (targs[idx])\n \t{\n+\t  tree t = targs[idx];\n+\t  if (TREE_CODE (t) == TREE_CODE (arg))\n+\t    switch (TREE_CODE (arg))\n+\t      {\n+\t      case INTEGER_CST:\n+\t\tif (tree_int_cst_equal (t, arg))\n+\t\t  return 0;\n+\t\tbreak;\n+\t      case REAL_CST:\n+\t\tif (REAL_VALUES_EQUAL (TREE_REAL_CST (t), TREE_REAL_CST (arg)))\n+\t\t  return 0;\n+\t\tbreak;\n+\t      /* STRING_CST values are not valid template const parms.  */\n+\t      default:\n+\t\t;\n+\t      }\n \t  my_friendly_abort (87);\n \t  return 1;\n \t}\n@@ -2306,3 +2314,18 @@ do_function_instantiation (declspecs, declarator)\n   if (!result)\n     cp_error (\"no matching template for `%D' found\", decl);\n }\n+\n+tree\n+create_nested_upt (scope, name)\n+     tree scope, name;\n+{\n+  tree t = make_lang_type (UNINSTANTIATED_P_TYPE);\n+  tree d = build_lang_decl (TYPE_DECL, name, t);\n+\n+  TYPE_NAME (t) = d;\n+  TYPE_VALUES (t) = TYPE_VALUES (scope);\n+  TYPE_CONTEXT (t) = scope;\n+\n+  pushdecl (d);\n+  return d;\n+}"}, {"sha": "38e3c77aad795fe502be5f426f0e20ecc757ac73", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -108,10 +108,14 @@ print_lang_type (file, node, indent)\n       else\n \tfputs (\" X(X&)\", file);\n     }\n-  if (TREE_GETS_NEW (node))\n-    fputs (\" gets-new\", file);\n-  if (TREE_GETS_DELETE (node))\n-    fputs (\" gets-delete\", file);\n+  if (TYPE_GETS_NEW (node) & 1)\n+    fputs (\" new\", file);\n+  if (TYPE_GETS_NEW (node) & 2)\n+    fputs (\" new[]\", file);\n+  if (TYPE_GETS_DELETE (node) & 1)\n+    fputs (\" delete\", file);\n+  if (TYPE_GETS_DELETE (node) & 2)\n+    fputs (\" delete[]\", file);\n   if (TYPE_HAS_ASSIGNMENT (node))\n     fputs (\" has=\", file);\n   if (TYPE_HAS_ASSIGN_REF (node))"}, {"sha": "576eaecda9033a9fa839ac84f4c625b5cd404872", "filename": "gcc/cp/search.c", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -1079,16 +1079,16 @@ lookup_field (xbasetype, name, protect, want_type)\n \t  if (TREE_CODE (rval) == CONST_DECL)\n \t    {\n \t      if (this_v == access_private)\n-\t\terrstr = \"enum `%s' is a private value of class `%s'\";\n+\t\terrstr = \"enum `%D' is a private value of class `%T'\";\n \t      else if (this_v == access_protected)\n-\t\terrstr = \"enum `%s' is a protected value of class `%s'\";\n+\t\terrstr = \"enum `%D' is a protected value of class `%T'\";\n \t    }\n \t  else\n \t    {\n \t      if (this_v == access_private)\n-\t\terrstr = \"member `%s' is a private member of class `%s'\";\n+\t\terrstr = \"member `%D' is a private member of class `%T'\";\n \t      else if (this_v == access_protected)\n-\t\terrstr = \"member `%s' is a protected member of class `%s'\";\n+\t\terrstr = \"member `%D' is a protected member of class `%T'\";\n \t    }\n \t}\n \n@@ -1214,7 +1214,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t  else\n \t    {\n \t      /* This is ambiguous. */\n-\t      errstr = \"request for member `%s' is ambiguous\";\n+\t      errstr = \"request for member `%D' is ambiguous\";\n \t      protect = 2;\n \t      break;\n \t    }\n@@ -1250,7 +1250,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      new_v = compute_access (TREE_VALUE (TREE_CHAIN (*tp)), rval);\n \t    if (this_v != access_default && new_v != this_v)\n \t      {\n-\t\terrstr = \"conflicting access to member `%s'\";\n+\t\terrstr = \"conflicting access to member `%D'\";\n \t\tthis_v = access_default;\n \t      }\n \t    own_access = new_v;\n@@ -1272,17 +1272,17 @@ lookup_field (xbasetype, name, protect, want_type)\n   if (errstr == 0)\n     {\n       if (own_access == access_private)\n-\terrstr = \"member `%s' declared private\";\n+\terrstr = \"member `%D' declared private\";\n       else if (own_access == access_protected)\n-\terrstr = \"member `%s' declared protected\";\n+\terrstr = \"member `%D' declared protected\";\n       else if (this_v == access_private)\n \terrstr = TREE_PRIVATE (rval)\n-\t  ? \"member `%s' is private\"\n-\t    : \"member `%s' is from private base class\";\n+\t  ? \"member `%D' is private\"\n+\t    : \"member `%D' is from private base class\";\n       else if (this_v == access_protected)\n \terrstr = TREE_PROTECTED (rval)\n-\t  ? \"member `%s' is protected\"\n-\t    : \"member `%s' is from protected base class\";\n+\t  ? \"member `%D' is protected\"\n+\t    : \"member `%D' is from protected base class\";\n     }\n \n   if (entry)\n@@ -1302,17 +1302,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   if (errstr && protect)\n     {\n-      char *p = IDENTIFIER_POINTER (name), *q = NULL;\n-      if (IDENTIFIER_OPNAME_P (name))\n-\t{\n-\t  q = operator_name_string (name);\n-\t  p = (char *) xmalloc (9 + strlen (q) + 1);\n-\t  sprintf (p, \"operator %s\", q);\n-\t}\n-\n-      error (errstr, p, TYPE_NAME_STRING (type));\n-      if (q)\n-\tfree (p);\n+      cp_error (errstr, name, type);\n       rval = error_mark_node;\n     }\n   return rval;\n@@ -3031,15 +3021,15 @@ push_class_decls (type)\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n   id = TYPE_IDENTIFIER (type);\n+#if 0\n   if (IDENTIFIER_TEMPLATE (id) != 0)\n     {\n-#if 0\n       tree tmpl = IDENTIFIER_TEMPLATE (id);\n       push_template_decls (DECL_ARGUMENTS (TREE_PURPOSE (tmpl)),\n \t\t\t   TREE_VALUE (tmpl), 1);\n-#endif\n       overload_template_name (id, 1);\n     }\n+#endif\n \n   /* Push class fields into CLASS_VALUE scope, and mark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarkedp);\n@@ -3227,3 +3217,27 @@ reinit_search_statistics ()\n   n_outer_fields_searched = 0;\n   n_contexts_saved = 0;\n }\n+\n+tree\n+lookup_nested_tag (type, name)\n+     tree type, name;\n+{\n+  tree tags = CLASSTYPE_TAGS (type);\n+\n+  for (; tags; tags = TREE_CHAIN (tags))\n+    {\n+      /* The TREE_PURPOSE of an enum tag (which becomes a member of the\n+\t enclosing class) is set to the name for the enum type.  So, if\n+\t name is `bar', and we strike `baz' for `enum bar { baz }', then\n+\t this test will be true.  */\n+      if (TREE_PURPOSE (tags) == name)\n+\tbreak;\n+    }\n+  if (tags)\n+    return TYPE_NAME (TREE_VALUE (tags));\n+\n+  if (TYPE_CONTEXT (type))\n+    return lookup_nested_tag (TYPE_CONTEXT (type), name);\n+\n+  return NULL_TREE;\n+}"}, {"sha": "b7fc7d5732341252a506f7a7d6354a3491a9c4c6", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 22, "deletions": 742, "changes": 764, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28e3c7f21098041386f8c52962ac75781849d95/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a28e3c7f21098041386f8c52962ac75781849d95", "patch": "@@ -45,12 +45,6 @@ struct token  {\n };\n \n static int do_aggr ();\n-static struct token frob_identifier ();\n-static tree hack_more_ids ();\n-#if 0\n-static struct token hack_scope ();\n-static tree hack_ptype ();\n-#endif\n \n /* From lex.c: */\n /* the declaration found for the last IDENTIFIER token read in.\n@@ -72,51 +66,10 @@ static unsigned int yylex_ctr = 0;\n static int debug_yychar ();\n #endif\n \n-#if 0\t\t\t\t/* Used by arbitrate_lookup */\n-static char follows_typename[END_OF_SAVED_INPUT+1];\n-static char follows_identifier[END_OF_SAVED_INPUT+1];\n-#endif\n-\n-/* This is a hack!!! TEMPLATE_TYPE_SEEN_BEFORE_SCOPE consists of the name\n- * of the last template_type parsed in parse.y if it is followed by a\n- * scope operator.  It will be reset inside the next invocation of yylex().\n- * This is used for recognizing nested types inside templates.\n- * - niklas@appli.se */\n-tree template_type_seen_before_scope;\n-\n /* Initialize token_obstack. Called once, from init_lex.  */\n void\n init_spew ()\n {\n-#if 0\t\t\t\t/* Used by arbitrate_lookup */\n-  static char *chars_following_identifier = \".+-|/%^!?:\";\n-  short *ps;\n-  static short toks_follow_ids[] =\n-    { ASSIGN, RANGE, OROR, ANDAND, MIN_MAX, EQCOMPARE,\n-      ARITHCOMPARE, LSHIFT, RSHIFT, UNARY, PLUSPLUS, MINUSMINUS, POINTSAT,\n-      POINTSAT_STAR, DOT_STAR, CONSTANT, STRING, SIZEOF, ENUM, IF,\n-      ELSE, WHILE, DO, FOR, SWITCH, CASE, DEFAULT, BREAK, CONTINUE,\n-      RETURN, GOTO, ASM_KEYWORD, GCC_ASM_KEYWORD, TYPEOF, ALIGNOF, HEADOF,\n-      CLASSOF, SIGOF, ATTRIBUTE, AGGR, VISSPEC, DELETE, RAISE, RERAISE, TRY,\n-      EXCEPT, CATCH, THROW, ANSI_TRY, ANSI_THROW, DYNAMIC_CAST, TYPEID,\n-      EXTERN_LANG_STRING, ALL, END_OF_SAVED_INPUT, -1 };\n-  static short toks_follow_types[] =\n-    { IDENTIFIER, TYPENAME, SCOPED_TYPENAME, SCOPED_NAME, SCSPEC, \n-      TYPESPEC, TYPE_QUAL,\n-      ELLIPSIS, THIS, OPERATOR, TEMPLATE, SCOPE, START_DECLARATOR,\n-      TYPENAME_COLON, PAREN_STAR_PAREN, TYPENAME_ELLIPSIS, PTYPENAME,\n-      PRE_PARSED_FUNCTION_DECL, PRE_PARSED_CLASS_DECL, -1 };\n-\n-  /* Initialize the arrays saying what tokens are definitely\n-     (or possibly) valid following typenames and identifiers.  */\n-  while (*chars_following_identifier)\n-    follows_identifier[*chars_following_identifier++] = 1;\n-  for (ps = toks_follow_ids; *ps != -1; ps++)\n-    follows_identifier[*ps] = 1;\n-  for (ps = toks_follow_types; *ps != -1; ps++)\n-    follows_typename[*ps] = 1;\n-#endif\n-\n   gcc_obstack_init(&token_obstack);\n }\n \n@@ -181,7 +134,8 @@ consume_token()\n    : first_token++)\n #endif\n \n-/* Pull in enough tokens from real_yylex that the queue is N long.  */\n+/* Pull in enough tokens from real_yylex that the queue is N long beyond\n+   the current token.  */\n \n static void\n scan_tokens (n)\n@@ -278,13 +232,13 @@ probe_obstack (h, obj, nlevels)\n }\n \n /* from lex.c: */\n-/* Value is 1 if we should try to make the next identifier look like a\n-   typename (when it may be a local variable or a class variable).\n-   Value is 0 if we treat this name in a default fashion.\n-   Value is -1 if we must not see a type name.  */\n+/* Value is 1 (or 2) if we should try to make the next identifier look like\n+   a typename (when it may be a local variable or a class variable).\n+   Value is 0 if we treat this name in a default fashion. */\n extern int looking_for_typename;\n \n extern struct obstack *current_obstack, *saveable_obstack;\n+tree got_scope;\n \n int\n yylex()\n@@ -300,36 +254,6 @@ yylex()\n     fprintf(stderr, \"\\t\\t## %d ##\",yylex_ctr);\n   }\n #endif\n-  \n-  /* This is a kludge for recognizing nested types in templates */\n-  if (template_type_seen_before_scope)\n-    {\n-      shift_tokens (2);\t\t/* Sync in hack_more_ids (yes, it's ugly) */\n-      nth_token (1)->yychar = SCOPE;\n-      yylval.ttype = hack_more_ids (0, template_type_seen_before_scope);\n-      template_type_seen_before_scope = 0;\n-      if (!yylval.ttype)\n-\t{\n-\t  /* Sync back again, leaving SCOPE on the token stream, because we\n-\t   * failed to substitute the original SCOPE token with a\n-\t   * SCOPED_TYPENAME.  See rule \"template_type\" in parse.y */\n-\t  consume_token ();\n-\t}\n-      else\n-\t{\n-\t  tree t = TREE_TYPE(yylval.ttype);\n-\t  if (TREE_CODE(yylval.ttype) == SCOPE_REF && \n-\t\tt && TREE_CODE(t) == UNINSTANTIATED_P_TYPE)\n-\t    yychar = SCOPED_NAME;\n-\t  else\n-\t    yychar = SCOPED_TYPENAME;\n-#ifdef SPEW_DEBUG    \n-\t  if (spew_debug)\n-\t    debug_yychar(yychar);\n-#endif\n-\t  return yychar;\n-\t}\n-    }\n \n   /* if we've got tokens, send them */\n   if (num_tokens())\n@@ -370,36 +294,31 @@ yylex()\n       goto retry;\n \n     case IDENTIFIER:\n+      scan_tokens (1);\n+      if (nth_token (1)->yychar == SCOPE)\n+\t/* Don't interfere with the setting from an 'aggr' prefix.  */\n+\tlooking_for_typename++;\n+\n       trrr = lookup_name (tmp_token.yylval.ttype, -2);\n+\n       if (trrr)\n \t{\n \t  tmp_token.yychar = identifier_type (trrr);\n \t  switch (tmp_token.yychar)\n \t    {\n \t    case TYPENAME:\n \t      lastiddecl = identifier_typedecl_value (tmp_token.yylval.ttype);\n-\t      if (lastiddecl == NULL_TREE)\n-\t\tlastiddecl = trrr;\n+\t      if (lastiddecl != trrr)\n+\t\t{\n+\t\t  lastiddecl = trrr;\n+\t\t  tmp_token.yylval.ttype = DECL_NESTED_TYPENAME (trrr);\n+\t\t}\n \t      break;\n \t    case IDENTIFIER:\n \t      lastiddecl = trrr;\n \t      break;\n \t    case PTYPENAME:\n-\t      /* This is for cases like\n-\t\t    template<class A> X<A>::operator[] ...\n-\t\t since \"X\" is (presumably) a PTYPENAME; we might want to\n-\t\t avoid seeing the entire thing as a type name, but X<A>\n-\t\t must be one.\n-\n-\t\t It might not work right if the thing after the ::\n-\t\t can be a typename nested in X<A>, but I don't think the\n-\t\t PT code would be up to dealing with that anyways.  --KR  */\n-\t      if (looking_for_typename == -1)\n-\t\t{\n-\t\t  scan_tokens (2);\n-\t\t  if (nth_token(1)->yychar == '<')\n-\t\t    looking_for_typename = 0;\n-\t\t}\n+\t      lastiddecl = NULL_TREE;\n \t      break;\n \t    default:\n \t      my_friendly_abort (101);\n@@ -410,120 +329,20 @@ yylex()\n       /* and fall through to... */\n     case TYPENAME:\n     case PTYPENAME:\n-      /* if (new_token) add_token (&tmp_token); */\n-      *nth_token(0) = tmp_token;\n-      tmp_token = frob_identifier ();\n-      if (looking_for_typename < 0)\n-\t{\n-\t  tmp_token.yychar = IDENTIFIER;\n-\t  lastiddecl = 0;\n-\t  looking_for_typename = 0;\n-\t}\n-      else if (lastiddecl && TREE_CODE (lastiddecl) == TYPE_DECL)\n-\t{\n-\t  scan_tokens (2);\n-\t  if (nth_token(0)->yychar == IDENTIFIER\n-\t      && nth_token (1)->yychar != SCOPE)\n-\t    looking_for_typename = -1;\n-\t  else\n-\t    looking_for_typename = 0;\n-\t  goto finish_typename_processing;\n-\t}\n-      else\n-\tlooking_for_typename = 0;\n+      consume_token ();\n+      if (looking_for_typename > 0)\n+\tlooking_for_typename--;\n       break;\n \n     case SCSPEC:\n       /* do_aggr needs to check if the previous token was RID_FRIEND,\n \t so just increment first_token instead of calling consume_token. */\n       first_token++;\n-      goto finish_typename_processing;\n+      break;\n     case TYPESPEC:\n       consume_token ();\n-    finish_typename_processing:\n-#if 0\n-      /* Now see if we should insert a START_DECLARATOR token.\n-         Here are the cases caught:\n-\n-\t typespec ( * ID ) (\t// ptr to function\n-\t typespec ( & ID ) (\t// ref to function\n-\t typespec ( * ID ) [\t// array of pointers\n-\t typespec ( & ID ) [\t// array of references\n-\n-\t This is a terrible kludge.  */\n-\n-      scan_tokens (2);\n-      if (nth_token (0)->yychar == '('\n-\t  && (nth_token (1)->yychar == '*'\n-\t      || nth_token (1)->yychar == '&'))\n-\t{\n-\t  scan_tokens (5);\n-\t  if (nth_token (3)->yychar == ')'\n-\t      && (nth_token (4)->yychar == '('\n-\t\t  || nth_token (4)->yychar == '['\n-\t\t  || nth_token (4)->yychar == LEFT_RIGHT)\n-\t      && (nth_token (2)->yychar == IDENTIFIER\n-\t\t  || nth_token (2)->yychar == TYPENAME))\n-\t    {\n-\t      shift_tokens (1);\n-\t      nth_token (0)->yychar = START_DECLARATOR;\n-\t    }\n-\t}\n-      /* Extend to handle:\n-\n-\t typespec (ID::* qf)(   // ptr to member function\n-\t typespec (ID::* qf)[   // array of ptr to member functions\n-\n-\t */\n-      if (nth_token (0)->yychar == '('\n-\t  && (nth_token (1)->yychar == IDENTIFIER\n-\t      || nth_token (1)->yychar == TYPENAME))\n-\t{\n-\t  scan_tokens (7);\n-\t  if (nth_token (2)->yychar == SCOPE\n-\t      && nth_token (3)->yychar == '*'\n-\t      && (nth_token (4)->yychar == IDENTIFIER\n-\t\t  || nth_token (4)->yychar == TYPENAME)\n-\t      && nth_token (5)->yychar == ')'\n-\t      && (nth_token (6)->yychar == '('\n-\t\t  || nth_token (6)->yychar == '['\n-\t\t  || nth_token (6)->yychar == LEFT_RIGHT))\n-\t    {\n-\t      shift_tokens (1);\n-\t      nth_token (0)->yychar = START_DECLARATOR;\n-\t    }\n-\t}\n-#endif\n       break;\n \n-#if 0\n-    case '(':\n-      /* Handle casts.  We are looking for one of:\n-         `( TYPENAME' followed by `)', or\n-\t `( TYPENAME *' followed by one of `[,*,&,)', or\n-\t `( TYPENAME &' followed by one of `[,*,&,)', or\n-\t `( TYPENAME [' followed by `]'.  We are punting\n-\t generality on scanning casts to array types.  */\n-      scan_tokens (4);\n-      if (nth_token (1)->yychar == IDENTIFIER)\n-\t{\n-\t  tree type = identifier_typedecl_value (nth_token (1)->yylval.ttype);\n-\t  if (type)\n-\t    switch (nth_token (2)->yychar)\n-\t      {\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t}\n-      break;\n-\n-    case SCOPE:\n-      /* if (new_token) add_token (&tmp_token); */\n-      *nth_token(0) = tmp_token;\n-      tmp_token = hack_scope ();\n-      break;\n-#endif\n-\n     case AGGR:\n       *nth_token(0) = tmp_token;\n       do_aggr ();\n@@ -533,36 +352,7 @@ yylex()\n       looking_for_typename = 1;\n       /* fall through... */\n     default:\n-#ifdef SPEW_DEBUG    \n-      if (spew_debug)\n-\tdebug_yychar(tmp_token.yychar);\n-#endif\n       consume_token();\n-      yylval = tmp_token.yylval;\n-      yychar = tmp_token.yychar;\n-      end_of_file = tmp_token.end_of_file;\n-      return tmp_token.yychar;\n-    }\n-\n-  if (tmp_token.yychar == SCOPED_TYPENAME)\n-    {\n-#if 0\n-      tree t2 = resolve_scope_to_name (NULL_TREE, tmp_token.yylval.ttype);\n-      if (t2 != NULL_TREE)\n-\t{\n-\t  tmp_token.yylval.ttype = t2;\n-\t  tmp_token.yychar = TYPENAME;\n-\t}\n-      else\n-\t{\n-\t  /* unwind? */\n-\t}\n-    }\n-  else\n-    {\n-      /* couldn't get here, as is... */\n-#endif\n-      tmp_token.yychar = TYPENAME;\n     }\n \n   yylval = tmp_token.yylval;\n@@ -572,7 +362,6 @@ yylex()\n   if (spew_debug)\n     debug_yychar(yychar);\n #endif\n-/*  consume_token(); */ /* already eaten by frob_identifier?... */\n   return yychar;\n }\n \n@@ -618,515 +407,6 @@ do_aggr ()\n     }\n   return 0;\n }  \n-\n-static struct token\n-frob_identifier ()\n-{\n-  /* we could have a type, if it is followed by :: (if so, suck it all up); */\n-  /* we could have a ptypename; */\n-  /* we could have a normal identifier. */\n-  tree t1;\n-  struct token rt;\n-  \n-  scan_tokens(1);\n-  rt = *nth_token(0);\n-\n-#if 0\n-  if (nth_token(1)->yychar == '<')\n-    {\n-      t1 = hack_ptype();\t/* suck up the whole thing */\n-      if (t1)\n-\t{\n-\t  rt.yylval.ttype = t1;\n-\t  rt.yychar = TYPENAME;\n-\t  *nth_token(0) = rt;\n-\t}\n-      /* else fall out bottom */\n-    }\t\n-#endif\n-\n-  if (nth_token(1)->yychar == SCOPE)\n-    {\n-#if 0\n-      t1 = hack_more_ids(0);\n-      if (t1 && TREE_CODE(t1) == SCOPE_REF)\n-#else\n-      t1 = hack_more_ids(0, nth_token (0)->yylval.ttype);\n-      if (t1)\n-#endif\n-\t{\n-\t  rt.yylval.ttype = t1;\n-\t  rt.yychar = SCOPED_TYPENAME ;\n-\t  return rt;\n-\t}\n-      else\n-\t{\n-\t  /* deal with types (enums?) in classes... */\n-\t  struct token *tok;\n-\t  tree ta, tb;\n-\t  scan_tokens(3);\n-\n-\t  /* Have to check for a type conversion operator\n-\t     to a nested type.  */\n-\t  if (nth_token (2)->yychar == OPERATOR)\n-\t    tok = nth_token (3);\n-\t  else\n-\t    tok = nth_token(2);\n-\n-\t  if (tok->yychar == IDENTIFIER || tok->yychar == TYPENAME)\n-\t    {\n-\t      ta = build_parse_node (SCOPE_REF,\n-\t\t\t\t     nth_token(0)->yylval.ttype,\n-\t\t\t\t     tok->yylval.ttype);\n-\t      tb = resolve_scope_to_name (NULL_TREE, ta);\n-\n-\t      if (tb != NULL_TREE)\n-\t\t{\n-\t\t  if (nth_token (2)->yychar == OPERATOR)\n-\t\t    {\n-\t\t      /* Have to keep these tokens around\n-\t\t\t so we can finish parsing the declaration.\n-\t\t\t What do we do for\n-\n-\t\t\t int foo::operator bar::baz (); \n-\n-\t\t\t where bar is a nested class in foo?  */\n-\t\t      nth_token (3)->yychar = TYPENAME;\n-\t\t      nth_token (3)->yylval.ttype = tb;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      consume_token (); /* base type */\n-\t\t      consume_token (); /* SCOPE */\n-\t\t      consume_token (); /* member type */\n-\t\t      rt.yychar = TYPENAME;\n-\t\t      rt.yylval.ttype = tb;\n-\t\t      rt.end_of_file = tok->end_of_file;\n-\t\t      return rt;\n-\t\t    }\n-\t\t  \n-\t\t}\n-\t    }      \n-\t  /* else fall out bottom */\n-\t}\n-    }\n-\t     \n-  consume_token();\n-  return rt;\n-}\n-\n-#if 0\n-/* When this function is called, nth_token(0) is the current\n-   token we are scanning.  This means that the next token we'll\n-   scan is nth_token (1).  Usually the next token we'll scan\n-   is nth_token (0) (and the current token is in [yylval,yychar]).  */\n-tree\n-arbitrate_lookup (name, exp_decl, type_decl)\n-     tree name, exp_decl, type_decl;\n-{\n-  int ch;\n-  tree t;\n-  char *assume;\n-\n-  scan_tokens (3);\n-  ch = nth_token (1)->yychar;\n-\n-  switch (ch)\n-    {\n-    case '(':\n-    case LEFT_RIGHT:\n-      /* If we guessed wrong here, `build_functional_cast' can fix it.  */\n-      return type_decl;\n-\n-    case '=':\n-      if (global_bindings_p ())\n-\t/* Probably a default parameter.  */\n-\treturn type_decl;\n-      /* Probably not an initialization.  */\n-      return exp_decl;\n-\n-    case '[':\n-      /* This needs special help because an expression inside the\n-\t brackets means nothing.  */\n-      {\n-\tint i;\n-\n-\tfor (i = 0; i < 42; i++)\n-\t  {\n-\t    int ith_yychar;\n-\n-\t    scan_tokens (3+i);\n-\t    ith_yychar = nth_token (2+i)->yychar;\n-\n-\t    /* If we hit an undefined identifier, assume\n-\t       the decl in arbitration is its type specifier.  */\n-\t    if (ith_yychar == IDENTIFIER\n-\t\t&& lookup_name (nth_token (2+i)->yylval.ttype, 0) == 0)\n-\t      return type_decl;\n-\t    else if (ith_yychar == ']')\n-\t      {\n-\t\t/* There are only a few things we expect after a ']'\n-\t\t   in a declarator.  */\n-\t\ti += 1;\n-\t\tscan_tokens (4+i);\n-\t\tith_yychar = nth_token (2+i)->yychar;\n-\n-\t\t/* These are inconclusive.  */\n-\t\tif (ith_yychar == LEFT_RIGHT\n-\t\t    || ith_yychar == '('\n-\t\t    || ith_yychar == '['\n-\t\t    || ith_yychar == ',')\n-\t\t  continue;\n-\t\t/* stmt or decl?  We'll probably never know.  */\n-\t\telse if (ith_yychar == ';')\n-\t\t  goto warn_ambiguous;\n-\n-\t\tif (ith_yychar == '=')\n-\t\t  {\n-\t\t    if (nth_token (3+i)->yychar == '{')\n-\t\t      return type_decl;\n-\t\t    continue;\n-\t\t  }\n-\n-\t\t/* Whatever it is, it looks like we're processing an expr.  */\n-\t\treturn exp_decl;\n-\t      }\n-\t  }\n-\tgoto warn_ambiguous;\n-      }\n-\n-    case ',':\n-    case ';':\n-    case '&':\n-    case '<':\n-    case '*':\n-    case ']':\n-    case ')':\n-    case '>':\n-      /* see if the next token looks like it wants to be part\n-\t of a declaration list or an expression list.  */\n-      {\n-\tint i;\n-\n-\t/* Some heuristics: if we are inside a function definition,\n-\t   prefer the local declaration.  */\n-\tif (! global_bindings_p ())\n-\t  {\n-\t    if (IDENTIFIER_LOCAL_VALUE (name) == exp_decl)\n-\t      return exp_decl;\n-\t    if (IDENTIFIER_LOCAL_VALUE (name) != type_decl\n-\t\t&& IDENTIFIER_CLASS_VALUE (name) == exp_decl)\n-\t      return exp_decl;\n-\t  }\n-\t/* If these symbols follow in a list, we know it's a list of\n-\t   expressions.  */\n-\tif (follows_identifier[nth_token (2)->yychar])\n-\t  return exp_decl;\n-\n-\t/* If we see a id&, or id&) the we are probably in an argument list. */\n-\tif (ch=='&'\n-\t    && (nth_token (2)->yychar == ',' || nth_token (2)->yychar == ')'))\n-\t  return type_decl;\n-\n-\t/* Look for the first identifier or other distinguishing token\n-\t   we find in the next several tokens.  */\n-\tfor (i = 0; i < 42; i++)\n-\t  {\n-\t    int ith_yychar;\n-\n-\t    scan_tokens (3+i);\n-\t    ith_yychar = nth_token (2+i)->yychar;\n-\n-\t    if (ith_yychar == IDENTIFIER)\n-\t      {\n-\t\ttree as_type = lookup_name (nth_token (2+i)->yylval.ttype, 1);\n-\t\tif (as_type && TREE_CODE (as_type) != TYPE_DECL)\n-\t\t  return exp_decl;\n-\t\t/* An undeclared identifier or a typename means we're\n-\t\t   probably looking at a typename.  */\n-\t\treturn type_decl;\n-\t      }\n-\t    else if (ith_yychar == EMPTY\n-\t\t     || follows_identifier[ith_yychar])\n-\t      return exp_decl;\n-\t    else if (follows_typename[ith_yychar])\n-\t      return type_decl;\n-\t    /* stmt or decl?  We'll probably never know.  */\n-\t    else if (ith_yychar == ';')\n-\t      goto warn_ambiguous;\n-\t  }\n-\tgoto warn_ambiguous;\n-      }\n-\n-    default:\n-      if (follows_identifier[ch])\n-\treturn exp_decl;\n-      if (follows_typename[ch])\n-\treturn type_decl;\n-\n-      /* Fall through...  */\n-    warn_ambiguous:\n-      if (ch == '[')\n-\t{\n-\t  assume = \"expression\";\n-\t  t = exp_decl;\n-\t}\n-      else\n-\t{\n-\t  assume = \"type\";\n-\t  t = type_decl;\n-\t}\n-\n-      warning (\"name `%s' could be type or expression; compiler assuming %s\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (t)), assume);\n-      return t;\n-    }\n-}\n-#endif\n-\n-/* now returns decl_node */\n-\n-#if 0\n-static tree\n-hack_ptype()\n-{\n-  /* when we get here, we know that [0] is a ptype and [1] is '<'.\n-   * now we loop over simple parameters. */\n-  struct token this_param;\n-  int n = 2;\n-  tree tplist = 0;\n-  tree tc;\n-  scan_tokens(n+1);\n-  \n-  while((this_param = *nth_token(n)).yychar != '>')\n-    {\n-      /* if it is a type, add it to the list */\n-      tree thistype;\n-    \n-      switch(this_param.yychar)\n-\t{\n-\tcase IDENTIFIER:\n-\tcase TYPENAME:\n-\tcase TYPESPEC:\n-\t  break;\n-\tdefault:\n-\t  return 0;\n-\t}\n-\n-      thistype = this_param.yylval.ttype;\n-      thistype = lookup_name(thistype, 1);\n-      thistype = TREE_TYPE (thistype);\n-        \n-      if (tplist)\n-\ttplist = chainon (tplist, build_tree_list (NULL_TREE, thistype));\n-      else\n-\ttplist = build_tree_list(NULL_TREE, thistype);\n-    \n-    \n-      /* then suck up the comma */\n-      n++;\n-      scan_tokens(n+1);\n-      this_param = *nth_token(n);\n-      if (this_param.yychar == ',')\n-\t{\n-\t  n++;\n-\t  scan_tokens(n+1);\n-\t  continue;\n-\t}\n-      if (this_param.yychar == '>')\n-\tbreak;\n-      return 0;\n-    }\n-\n-  /* once we're done, lookup_template_class -> identifier */\n-  tc = lookup_template_class (nth_token(0)->yylval.ttype,tplist);\n-  /* then lookup_name on that to get a type, if there is one */\n-  tc = lookup_name (tc, 1);\n-  if (tc)\n-    {\n-      int i;\n-      /* don't actually eat the trailing '>'... we can replace it! */\n-      for (i=0; i<n; i++)\n-\tconsume_token();\n-      /*    IDENTIFIER_TYPE_VALUE (DECL_NAME (tc)) = */\n-      return DECL_NAME (tc);\n-    }\n-  return NULL_TREE;\n-}\n-#endif\n-\n-#if 0\n-static tree\n-hack_more_ids (n)\n-     int n;\n-{\n-  /*\n-   * The recursion should probably do consume_tokens(), since once we've started\n-   * down an IDENTIFIER SCOPE ... chain, we don't need to back-track - we just\n-   * get as much as we can, make SCOPE_REF's out of it, and return it.\n-   */\n-  struct token this_iter, this2_iter;\n-  int tmp_y;\n-  \n-  scan_tokens(n+1);\n-  this_iter = *nth_token(n);\n-\n-  tmp_y = nth_token(n)->yychar;\n-  if (tmp_y == IDENTIFIER || tmp_y == TYPENAME)\n-    {\n-      scan_tokens(n+2+2);\n-      if (nth_token(n+1)->yychar == SCOPE)\n-\t{\n-\t  if (nth_token(n+1+2)->yychar == SCOPE)\n-\t    {\n-\t      tree hmi;\n-\t\n-\t      consume_token();\t/* last IDENTIFIER (this_iter) */\n-\t      consume_token();\t/* last SCOPE */\n-\t      this2_iter = *nth_token(n);\n-\t\n-\t      hmi = hack_more_ids (n);\n-\t\n-\t      if (hmi)\n-\t\treturn build_parse_node (SCOPE_REF, this_iter.yylval.ttype, hmi);\n-\t      consume_token(); /* last IDENTIFIER (this2_iter) */\n-\t      return build_parse_node (SCOPE_REF, this_iter.yylval.ttype,\n-\t\t\t\t       this2_iter.yylval.ttype);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* consume_token();\t*/\t/* last IDENTIFIER */\n-\t      /* leave whatever else we got */\n-\t      /* return this_iter.yylval.ttype; */\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n-    }\n-  return NULL_TREE;\t\t/* @@ may need to backtrack */\n-}\n-#else\n-/* niklas@appli.se says:  I didn't understand how the code above was intended\n- * to work, so I rewrote it (also changed the interface a bit).  This code\n- * dives down an IDENTIFIER/TYPENAME SCOPE ... chain as long as the parsed\n- * type prefix constitutes recognizable (by resolve_scope_to_name) types.\n- * Interface changed like this:\n- * 1. Takes an extra argument containing the name of the the type recognized\n- *    so far.\n- * 2. Now returns the name of the type instead of a SCOPE_REF. */\n-static tree\n-hack_more_ids(n, outer)\n-  int n;\n-  tree outer;\n-{\n-  int ch;\n-  tree type, val, inner, outer_t;\n-\n-  scan_tokens (n + 2);\n-  if (nth_token (n + 1)->yychar != SCOPE\n-      || ((ch = nth_token (n + 2)->yychar) != IDENTIFIER && ch != TYPENAME))\n-    return NULL_TREE;\n-\n-  inner = nth_token(n+2)->yylval.ttype;\n-  val = build_parse_node (SCOPE_REF, outer, inner);\n-  outer_t = TREE_TYPE(outer);\n-  if (outer_t && TREE_CODE(outer_t) == UNINSTANTIATED_P_TYPE)\n-    {\n-      tree t = make_lang_type (UNINSTANTIATED_P_TYPE);\n-      tree id = inner;\n-      tree d = build_lang_decl (TYPE_DECL, id, t);\n-\n-      TYPE_NAME (t) = d;\n-      TYPE_VALUES (t) = TYPE_VALUES(outer_t);\n-      TYPE_CONTEXT(t) = outer_t;\n-/*\n-      pushdecl_top_level (d);\n-*/\n-      pushdecl(d);\n-\n-      type = val;\n-      TREE_TYPE(type) = t;\n-    }\n-  else\n-    {\n-      type = resolve_scope_to_name (NULL_TREE, val);\n-      if (type == NULL_TREE)\n-        return NULL_TREE;\n-    }\n-  consume_token ();\n-  consume_token ();\n-  val = hack_more_ids (n, type);\n-  if (! val)\n-    consume_token ();\n-  return val ? val : type;\n-}\n-#endif\n-\n-#if 0\n-static struct token\n-hack_scope ()\n-{\n-  /* we've got a :: - what follows is either a global var or a type. */\n-  /* hmm, template names can be in the global scope too... */\n-  tree t1;\n-  struct token rt;\n-  \n-  scan_tokens(1);\n-  if (nth_token(1)->yychar == IDENTIFIER)\n-    {\n-      /* @@ this is probably not right, but doesn't get hit yet */\n-      t1 = build_parse_node (SCOPE_REF,\n-\t\t\t     NULL_TREE, /* to get \"global\" scope */\n-\t\t\t     hack_more_ids(0)); /* do some prefetching */\n-      rt.yylval.ttype = t1;\n-      rt.yychar =\t\t/*SCOPED_*/TYPENAME;\n-      return rt;\n-    }\n-  else\n-    {\n-      rt = *nth_token(0);\n-      consume_token();\n-      return rt;\n-    }\n-}\n-#endif\n-  \n-/*\n- * Generations:\n- * \t\n- * PINST: PTYPE { saved_arg_count = arg_count($1) }\n- *        '<' { arg_c = 0; } PARGS '>'\n- *        ;\n- * PARG: TYPE\n- *       | VALUE\n- *       ;\n- * (of course the arg counting doesn't work for recursion... Do it right.)\n- * PARGS: PARG { assert(arg_c == saved_arg_count); }\n- *        | PARG ',' PARGS\t{ arg_c++; }\n- *        ;\n- * ATYPE: PINST\n- *        | TYPEID\n- *        ;\n- * TYPE: ATYPE\n- *       | ATYPE { basetype = $1; } '::' TYPEKIDS\n- *       ;\n- * TYPEKIDS: TYPE { assert ($1 is a member of basetype); }\n- * \t  | TYPEKIDS { basetype += $1} TYPE { assert( $3 is in basetype ); }\n- * \t  ;\n- *\n- *\n- * state0: ; ATYPE\n- * \tTYPE '<': ac = args($0), base = CALL state1, state3\t\n- * \tTYPE '::': base=$0, state3\n- * \telse return TYPE\n- * state1: ; begin PARGS\n- * \tif(ac < list length) punt\n- * \tPARG \",\": add to list, state1\n- * \tPARG \">\": add to list, return\n- * \telse unravel\n- * state3: ; begin TYPEKIDS\n- * \tTYPE: \n- */\n-  \n   \n #ifdef SPEW_DEBUG    \n /* debug_yychar takes a yychar (token number) value and prints its name. */"}]}