{"sha": "c9b26f89d1a1c39680c1594698df41204691f550", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzliMjZmODlkMWExYzM5NjgwYzE1OTQ2OThkZjQxMjA0NjkxZjU1MA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-19T21:00:14Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-10-19T21:00:14Z"}, "message": "(SECONDARY_INPUT_RELOAD_CLASS): Require a temporary for a\n\tpic address with a large constant term.\n\n(FUNCTION_PROFILER_LENGTH, FUNCTION_BLOCK_PROFILER_LENGTH,\n\tBLOCK_PROFILER_LENGTH, REG_PUSH_LENGTH, REG_POP_LENGTH): Added.\n\t(ADJUST_INSN_LENGTH): Account for profiling code.\n\nFrom-SVN: r2518", "tree": {"sha": "30372bcb38b185cf0c98abe465f339e17e20c2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30372bcb38b185cf0c98abe465f339e17e20c2f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9b26f89d1a1c39680c1594698df41204691f550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9b26f89d1a1c39680c1594698df41204691f550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9b26f89d1a1c39680c1594698df41204691f550", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9b26f89d1a1c39680c1594698df41204691f550/comments", "author": null, "committer": null, "parents": [{"sha": "5785e34c37bc9f15b77e66ee802b41443bd063ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5785e34c37bc9f15b77e66ee802b41443bd063ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5785e34c37bc9f15b77e66ee802b41443bd063ef"}], "stats": {"total": 60, "additions": 51, "deletions": 9}, "files": [{"sha": "02ff492cf3859dfc93435364adb42c7b7355fb27", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b26f89d1a1c39680c1594698df41204691f550/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b26f89d1a1c39680c1594698df41204691f550/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=c9b26f89d1a1c39680c1594698df41204691f550", "patch": "@@ -215,9 +215,9 @@ extern char * reg_names[];\n /* Print subsidiary information on the compiler version in use.\n    Redefined in m88kv4.h, and m88kluna.h.  */\n #define VERSION_INFO1\t\"88open OCS/BCS, \"\n-#define VERSION_INFO2\t\"10/15/92\"\n+#define VERSION_INFO2\t\"10/19/92\"\n #define VERSION_STRING\tversion_string\n-#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.2.13.2 10/15/92 08:00:51\"\n+#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.2.13.4 10/19/92 10:34:58\"\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -840,6 +840,16 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n    (CONSTANT_P(X) && (CLASS == XRF_REGS) ? NO_REGS : (CLASS))\n \n+/* Return the register class of a scratch register needed to load IN\n+   into a register of class CLASS in MODE.  On the m88k, when PIC, we\n+   need a temporary when loading some addresses into a register.  */\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n+  ((flag_pic\t\t\t\t\t\t\t\\\n+    && GET_CODE (IN) == CONST\t\t\t\t\t\\\n+    && GET_CODE (XEXP (IN, 0)) == PLUS\t\t\t\t\\\n+    && GET_CODE (XEXP (XEXP (IN, 0), 0)) == CONST_INT\t\t\\\n+    && ! SMALL_INT (XEXP (XEXP (IN, 0), 1))) ? GENERAL_REGS : NO_REGS)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n@@ -1090,15 +1100,25 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define FUNCTION_PROFILER(FILE, LABELNO) \\\n   output_function_profiler (FILE, LABELNO, \"mcount\", 1)\n \n+/* Maximum length in instructions of the code output by FUNCTION_PROFILER.  */\n+#define FUNCTION_PROFILER_LENGTH (5+3+1+5)\n+\n /* Output assembler code to FILE to initialize basic-block profiling for\n    the current module.  LABELNO is unique to each instance.  */\n #define FUNCTION_BLOCK_PROFILER(FILE, LABELNO) \\\n   output_function_block_profiler (FILE, LABELNO)\n \n+/* Maximum length in instructions of the code output by\n+   FUNCTION_BLOCK_PROFILER.  */\n+#define FUNCTION_BLOCK_PROFILER_LENGTH (3+5+2+5)\n+\n /* Output assembler code to FILE to increment the count associated with\n    the basic block number BLOCKNO.  */\n #define BLOCK_PROFILER(FILE, BLOCKNO) output_block_profiler (FILE, BLOCKNO)\n \n+/* Maximum length in instructions of the code output by BLOCK_PROFILER.  */\n+#define BLOCK_PROFILER_LENGTH 4\n+\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n@@ -1372,7 +1392,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n   if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n \t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n-    (X) = legitimize_address (flag_pic, X, gen_reg_rtx (Pmode)); \\\n+    (X) = legitimize_address (flag_pic, X, 0, 0);\t\t\\\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN; }\n \n@@ -1516,18 +1536,34 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    so give the MEM rtx word mode.  */\n #define FUNCTION_MODE SImode\n \n-/* A barrier will be aligned so account for the possible expansion.  A\n-   volatile memory reference may be preceeded by a serializing instruction.  */\n+/* A barrier will be aligned so account for the possible expansion.\n+   A volatile load may be preceeded by a serializing instruction.\n+   Account for profiling code output at NOTE_INSN_PROLOGUE_END.\n+   Account for block profiling code at basic block boundaries.  */\n #define ADJUST_INSN_LENGTH(RTX, LENGTH)\t\t\t\t\t\\\n   if (GET_CODE (RTX) == BARRIER\t\t\t\t\t\t\\\n       || (TARGET_SERIALIZE_VOLATILE\t\t\t\t\t\\\n \t  && GET_CODE (RTX) == INSN\t\t\t\t\t\\\n \t  && GET_CODE (PATTERN (RTX)) == SET\t\t\t\t\\\n \t  && ((GET_CODE (SET_SRC (PATTERN (RTX))) == MEM\t\t\\\n-\t       && MEM_VOLATILE_P (SET_SRC (PATTERN (RTX))))\t\t\\\n-\t      || (GET_CODE (SET_DEST (PATTERN (RTX))) == MEM\t\t\\\n-\t\t  && MEM_VOLATILE_P (SET_DEST (PATTERN (RTX)))))))\t\\\n-    LENGTH += 1;\n+\t       && MEM_VOLATILE_P (SET_SRC (PATTERN (RTX)))))))\t\t\\\n+    LENGTH += 1;\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (RTX) == NOTE\t\t\t\t\t\\\n+\t   && NOTE_LINE_NUMBER (RTX) == NOTE_INSN_PROLOGUE_END)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (profile_block_flag)\t\t\t\t\t\t\\\n+\tLENGTH += FUNCTION_BLOCK_PROFILER_LENGTH;\t\t\t\\\n+      if (profile_flag)\t\t\t\t\t\t\t\\\n+\tLENGTH += (FUNCTION_PROFILER_LENGTH + REG_PUSH_LENGTH\t\t\\\n+\t\t   + REG_POP_LENGTH);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (profile_block_flag\t\t\t\t\t\t\\\n+\t   && (GET_CODE (RTX) == CODE_LABEL\t\t\t\t\\\n+\t       || GET_CODE (RTX) == JUMP_INSN\t\t\t\t\\\n+\t       || (GET_CODE (RTX) == INSN\t\t\t\t\\\n+\t\t   && GET_CODE (PATTERN (RTX)) == SEQUENCE\t\t\\\n+\t\t   && GET_CODE (XVECEXP (PATTERN (RTX), 0, 0)) == JUMP_INSN)))\\\n+    LENGTH += BLOCK_PROFILER_LENGTH;\n \n /* Track the state of the last volatile memory reference.  Clear the\n    state with CC_STATUS_INIT for now.  */\n@@ -2122,6 +2158,9 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \t   reg_names[REGNO],\t\t\t\t\\\n \t   reg_names[STACK_POINTER_REGNUM])\n \n+/* Length in instructions of the code output by ASM_OUTPUT_REG_PUSH.  */\n+#define REG_PUSH_LENGTH 2\n+\n /* This is how to output an insn to pop a register from the stack.  */\n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tld\\t %s,%s,0\\n\\taddu\\t %s,%s,%d\\n\",\t\\\n@@ -2131,6 +2170,9 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n \t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n \t   (STACK_BOUNDARY / BITS_PER_UNIT))\n \n+/* Length in instructions of the code output by ASM_OUTPUT_REG_POP.  */\n+#define REG_POP_LENGTH 2\n+\n /* Define the parentheses used to group arithmetic operations\n    in assembler code.  */\n #define ASM_OPEN_PAREN \"(\""}]}