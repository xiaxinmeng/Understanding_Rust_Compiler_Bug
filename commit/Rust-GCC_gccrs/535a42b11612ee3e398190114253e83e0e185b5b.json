{"sha": "535a42b11612ee3e398190114253e83e0e185b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1YTQyYjExNjEyZWUzZTM5ODE5MDExNDI1M2U4M2UwZTE4NWI1Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-22T16:14:55Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-22T16:14:55Z"}, "message": "builtins.c (gimplify_va_arg_expr): Reword comments to avoid 'abort'.\n\n\t* builtins.c (gimplify_va_arg_expr): Reword comments to avoid\n\t'abort'. Use gcc_assert and gcc_unreachable as appropriate.\n\t* c-format.c (get_constant, decode_format_attr, get_flag_spec,\n\tfind_char_info_specifier_index,\n\tfind_length_info_modifier_index): Likewise.\n\t* c-typeck.c (composite_type, pop_init_level): Likewise.\n\t* combine.c (cant_combine_insn_p, try_combine): Likewise.\n\t* cse.c (cse_insn): Likewise\n\t* dominance.c (calc_dfs_tree): Likewise\n\tdwarf2out.c (loc_descriptor_from_tree_1,\n\tadd_abstract_origin_attribute, force_decl_die,\n\tforce_type_die): Likewise\n\temit-rtl.c (operand_subword_force): Likewise\n\texplow.c (hard_function_value): Likewise\n\texpmed.c (store_bit_field, expand_divmod,\n\temit_store_flag_force): Likewise\n\texpr.c (emit_move_multi_word, store_expr,\n\texpand_expr_real_1): Likewise\n\tfinal.c (this_is_asm_operands, shorten_branches, final_scan_insn,\n\toutput_operand): Likewise\n\tflow.c (recompute_reg_usage): Likewise\n\t* function.c (assign_stack_temp_for_type, assign_temp,\n\thandle_epilogue_set): Likewise\n\t* genextract.c (main): Likewise\n\t* gimplify.c (mostly_copy_tree_r, gimplify_return_expr,\n\tgimplify_modify_expr_rhs, gimplify_expr): Likewise\n\t* haifa-sched.c (ready_lastpos, ready_remove_first, ready_element,\n\tready_remove, rm_line_notes, rm_other_notes,\n\tschedule_block): Likewise\n\tmips-tfile.c (copy_object, out_of_bounds): Likewise\n\nFrom-SVN: r98567", "tree": {"sha": "13c3694fe0b9c65ce670df40813f4df53f79e80d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13c3694fe0b9c65ce670df40813f4df53f79e80d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/535a42b11612ee3e398190114253e83e0e185b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535a42b11612ee3e398190114253e83e0e185b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535a42b11612ee3e398190114253e83e0e185b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535a42b11612ee3e398190114253e83e0e185b5b/comments", "author": null, "committer": null, "parents": [{"sha": "98c41d988c9db08ecdfb4d00b672b9e1a96031e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c41d988c9db08ecdfb4d00b672b9e1a96031e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c41d988c9db08ecdfb4d00b672b9e1a96031e8"}], "stats": {"total": 302, "additions": 160, "deletions": 142}, "files": [{"sha": "f29d6a2fa1c68dcacfb9902f72dd56a0ecaeabc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -1,3 +1,36 @@\n+2005-04-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* builtins.c (gimplify_va_arg_expr): Reword comments to avoid\n+\t'abort'. Use gcc_assert and gcc_unreachable as appropriate.\n+\t* c-format.c (get_constant, decode_format_attr, get_flag_spec, \n+\tfind_char_info_specifier_index,\n+\tfind_length_info_modifier_index): Likewise.\n+\t* c-typeck.c (composite_type, pop_init_level): Likewise.\n+\t* combine.c (cant_combine_insn_p, try_combine): Likewise.\n+\t* cse.c (cse_insn): Likewise\n+\t* dominance.c (calc_dfs_tree): Likewise\n+\tdwarf2out.c (loc_descriptor_from_tree_1,\n+\tadd_abstract_origin_attribute, force_decl_die,\n+\tforce_type_die): Likewise\n+\temit-rtl.c (operand_subword_force): Likewise\n+\texplow.c (hard_function_value): Likewise\n+\texpmed.c (store_bit_field, expand_divmod,\n+\temit_store_flag_force): Likewise\n+\texpr.c (emit_move_multi_word, store_expr,\n+\texpand_expr_real_1): Likewise\n+\tfinal.c (this_is_asm_operands, shorten_branches, final_scan_insn,\n+\toutput_operand): Likewise\n+\tflow.c (recompute_reg_usage): Likewise\n+\t* function.c (assign_stack_temp_for_type, assign_temp, \n+\thandle_epilogue_set): Likewise\n+\t* genextract.c (main): Likewise\n+\t* gimplify.c (mostly_copy_tree_r, gimplify_return_expr,\n+\tgimplify_modify_expr_rhs, gimplify_expr): Likewise\n+\t* haifa-sched.c (ready_lastpos, ready_remove_first, ready_element,\n+\tready_remove, rm_line_notes, rm_other_notes,\n+\tschedule_block): Likewise\n+\tmips-tfile.c (copy_object, out_of_bounds): Likewise\n+\n 2005-04-22 David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/20813"}, {"sha": "af7721e3ad1bd240550d6bc11892ef8afff519d6", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -4262,7 +4262,8 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \tgimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n \n       if (!targetm.gimplify_va_arg_expr)\n-\t/* Once most targets are converted this should abort.  */\n+\t/* FIXME:Once most targets are converted we should merely\n+\t   assert this is non-null.  */\n \treturn GS_ALL_DONE;\n \n       *expr_p = targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);"}, {"sha": "1fdc858f6e7f98b751b68389c09afa798fa8bdbe", "filename": "gcc/c-format.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -148,7 +148,7 @@ check_format_string (tree argument, unsigned HOST_WIDE_INT format_num,\n }\n \n /* Verify EXPR is a constant, and store its value.\n-   If validated_p is true, abort on errors.\n+   If validated_p is true there should be no errors.\n    Returns true on success, false otherwise.  */\n static bool\n get_constant (tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n@@ -164,12 +164,12 @@ get_constant (tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n   return true;\n }\n \n-/* Decode the arguments to a \"format\" attribute into a function_format_info\n-   structure.  It is already known that the list is of the right length.\n-   If VALIDATED_P is true, then these attributes have already been validated\n-   and this function will abort if they are erroneous; if false, it\n-   will give an error message.  Returns true if the attributes are\n-   successfully decoded, false otherwise.  */\n+/* Decode the arguments to a \"format\" attribute into a\n+   function_format_info structure.  It is already known that the list\n+   is of the right length.  If VALIDATED_P is true, then these\n+   attributes have already been validated and must not be erroneous;\n+   if false, it will give an error message.  Returns true if the\n+   attributes are successfully decoded, false otherwise.  */\n \n static bool\n decode_format_attr (tree args, function_format_info *info, int validated_p)\n@@ -1063,10 +1063,10 @@ finish_dollar_format_checking (format_check_results *res, int pointer_gap_ok)\n /* Retrieve the specification for a format flag.  SPEC contains the\n    specifications for format flags for the applicable kind of format.\n    FLAG is the flag in question.  If PREDICATES is NULL, the basic\n-   spec for that flag must be retrieved and this function aborts if\n-   it cannot be found.  If PREDICATES is not NULL, it is a string listing\n-   possible predicates for the spec entry; if an entry predicated on any\n-   of these is found, it is returned, otherwise NULL is returned.  */\n+   spec for that flag must be retrieved and must exist.  If\n+   PREDICATES is not NULL, it is a string listing possible predicates\n+   for the spec entry; if an entry predicated on any of these is\n+   found, it is returned, otherwise NULL is returned.  */\n \n static const format_flag_spec *\n get_flag_spec (const format_flag_spec *spec, int flag, const char *predicates)\n@@ -2236,7 +2236,7 @@ format_type_warning (const char *descr, const char *format_start,\n \n /* Given a format_char_info array FCI, and a character C, this function\n    returns the index into the conversion_specs where that specifier's\n-   data is located.  If the character isn't found it aborts.  */\n+   data is located.  The character must exist.  */\n static unsigned int\n find_char_info_specifier_index (const format_char_info *fci, int c)\n {\n@@ -2252,8 +2252,7 @@ find_char_info_specifier_index (const format_char_info *fci, int c)\n \n /* Given a format_length_info array FLI, and a character C, this\n    function returns the index into the conversion_specs where that\n-   modifier's data is located.  If the character isn't found it\n-   aborts.  */\n+   modifier's data is located.  The character must exist.  */\n static unsigned int\n find_length_info_modifier_index (const format_length_info *fli, int c)\n {"}, {"sha": "60ce6b61ccfa52e4b35d370d3463dfc43bf43ad2", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -344,7 +344,7 @@ composite_type (tree t1, tree t2)\n \t/* If both args specify argument types, we must merge the two\n \t   lists, argument by argument.  */\n \t/* Tell global_bindings_p to return false so that variable_size\n-\t   doesn't abort on VLAs in parameter types.  */\n+\t   doesn't die on VLAs in parameter types.  */\n \tc_override_global_bindings_to_false = true;\n \n \tlen = list_length (p1);\n@@ -5018,7 +5018,7 @@ pop_init_level (int implicit)\n \n \t  /* We have already issued an error message for the existence\n \t     of a flexible array member not at the end of the structure.\n-\t     Discard the initializer so that we do not abort later.  */\n+\t     Discard the initializer so that we do not die later.  */\n \t  if (TREE_CHAIN (constructor_fields) != NULL_TREE)\n \t    constructor_type = NULL_TREE;\n \t}"}, {"sha": "d9e0b4fcda5398b6f17b83a2f96b8c6ca66375e8", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -1527,7 +1527,7 @@ cant_combine_insn_p (rtx insn)\n   /* Never combine loads and stores involving hard regs that are likely\n      to be spilled.  The register allocator can usually handle such\n      reg-reg moves by tying.  If we allow the combiner to make\n-     substitutions of likely-spilled regs, we may abort in reload.\n+     substitutions of likely-spilled regs, reload might die.\n      As an exception, we allow combinations involving fixed regs; these are\n      not available to the register allocator so there's no risk involved.  */\n \n@@ -2096,8 +2096,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       || (i1 != 0 && FIND_REG_INC_NOTE (i1, NULL_RTX) != 0\n \t  && (n_occurrences + added_sets_1 + (added_sets_2 && ! i1_feeds_i3)\n \t      > 1))\n-      /* Fail if we tried to make a new register (we used to abort, but there's\n-\t really no reason to).  */\n+      /* Fail if we tried to make a new register.  */\n       || max_reg_num () != maxreg\n       /* Fail if we couldn't do something and have a CLOBBER.  */\n       || GET_CODE (newpat) == CLOBBER"}, {"sha": "4eb4c3528e0013220c1d98296dcba1dc85f83302", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -5534,9 +5534,10 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t  else if (constant_pool_entries_cost\n \t\t   && CONSTANT_P (trial)\n-\t\t   /* Reject cases that will abort in decode_rtx_const.\n-\t\t      On the alpha when simplifying a switch, we get\n-\t\t      (const (truncate (minus (label_ref) (label_ref)))).  */\n+\t\t   /* Reject cases that will cause decode_rtx_const to\n+\t\t      die.  On the alpha when simplifying a switch, we\n+\t\t      get (const (truncate (minus (label_ref)\n+\t\t      (label_ref)))).  */\n \t\t   && ! (GET_CODE (trial) == CONST\n \t\t\t && GET_CODE (XEXP (trial, 0)) == TRUNCATE)\n \t\t   /* Likewise on IA-64, except without the truncate.  */"}, {"sha": "ce977e292fe0ddf9724dc6b1878ff5a8a152813f", "filename": "gcc/dominance.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -372,7 +372,7 @@ calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n \n   di->nodes = di->dfsnum - 1;\n \n-  /* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */\n+  /* Make sure there is a path from ENTRY to EXIT at all.  */\n   gcc_assert (di->nodes == (unsigned int) n_basic_blocks + 1);\n }\n "}, {"sha": "a1ff63f6ee0b354614475728e004fa09535dbfea", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -9283,7 +9283,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n #ifdef ENABLE_CHECKING\n       /* Otherwise this is a generic code; we should just lists all of\n-\t these explicitly.  Aborting means we forgot one.  */\n+\t these explicitly.  We forgot one.  */\n       gcc_unreachable ();\n #else\n       /* In a release build, we want to degrade gracefully: better to\n@@ -10583,7 +10583,7 @@ add_abstract_origin_attribute (dw_die_ref die, tree origin)\n      trees (in the case of java, they simply have no block tree, in some other\n      languages).  For these functions, there is nothing we can really do to\n      output correct debug info for inlined functions in all cases.  Rather\n-     than abort, we'll just produce deficient debug info now, in that we will\n+     than die, we'll just produce deficient debug info now, in that we will\n      have variables without a proper abstract origin.  In the future, when all\n      functions are lowered, we should re-add a gcc_assert (origin_die)\n      here.  */\n@@ -12540,7 +12540,7 @@ is_redundant_typedef (tree decl)\n   return 0;\n }\n \n-/* Returns the DIE for decl or aborts.  */\n+/* Returns the DIE for decl.  A DIE will always be returned.  */\n \n static dw_die_ref\n force_decl_die (tree decl)\n@@ -12593,8 +12593,7 @@ force_decl_die (tree decl)\n \t  gcc_unreachable ();\n \t}\n \n-      /* See if we can find the die for this deci now.\n-\t If not then abort.  */\n+      /* We should be able to find the DIE now.  */\n       if (!decl_die)\n \tdecl_die = lookup_decl_die (decl);\n       gcc_assert (decl_die);\n@@ -12603,7 +12602,7 @@ force_decl_die (tree decl)\n   return decl_die;\n }\n \n-/* Returns the DIE for decl or aborts.  */\n+/* Returns the DIE for TYPE.  A DIE is always returned.  */\n \n static dw_die_ref\n force_type_die (tree type)"}, {"sha": "b67d3b22c2065273e6bf33f78ca46593735f04e8", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -1330,9 +1330,10 @@ operand_subword (rtx op, unsigned int offset, int validate_address, enum machine\n   return simplify_gen_subreg (word_mode, op, mode, (offset * UNITS_PER_WORD));\n }\n \n-/* Similar to `operand_subword', but never return 0.  If we can't extract\n-   the required subword, put OP into a register and try again.  If that fails,\n-   abort.  We always validate the address in this case.\n+/* Similar to `operand_subword', but never return 0.  If we can't\n+   extract the required subword, put OP into a register and try again.\n+   The second attempt must succeed.  We always validate the address in\n+   this case.\n \n    MODE is the mode of OP, in case it is CONST_INT.  */\n "}, {"sha": "95a2931430b5231191d5902a9dff02559453f27a", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -1525,8 +1525,8 @@ hard_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n       enum machine_mode tmpmode;\n \n       /* int_size_in_bytes can return -1.  We don't need a check here\n-\t since the value of bytes will be large enough that no mode\n-\t will match and we will abort later in this function.  */\n+\t since the value of bytes will then be large enough that no\n+\t mode will match anyway.  */\n \n       for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmpmode != VOIDmode;"}, {"sha": "e0ad4cffb5e5b5369bbdd90d503533f9f9d87765", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -544,8 +544,8 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       /* This is the mode we must force value to, so that there will be enough\n \t subwords to extract.  Note that fieldmode will often (always?) be\n \t VOIDmode, because that is what store_field uses to indicate that this\n-\t is a bit field, but passing VOIDmode to operand_subword_force will\n-\t result in an abort.  */\n+\t is a bit field, but passing VOIDmode to operand_subword_force\n+\t is not allowed.  */\n       fieldmode = GET_MODE (value);\n       if (fieldmode == VOIDmode)\n \tfieldmode = smallest_mode_for_size (nwords * BITS_PER_WORD, MODE_INT);\n@@ -582,10 +582,10 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  if (!REG_P (op0))\n \t    {\n-\t      /* Since this is a destination (lvalue), we can't copy it to a\n-\t\t pseudo.  We can trivially remove a SUBREG that does not\n-\t\t change the size of the operand.  Such a SUBREG may have been\n-\t\t added above.  Otherwise, abort.  */\n+\t      /* Since this is a destination (lvalue), we can't copy\n+\t\t it to a pseudo.  We can remove a SUBREG that does not\n+\t\t change the size of the operand.  Such a SUBREG may\n+\t\t have been added above.  */\n \t      gcc_assert (GET_CODE (op0) == SUBREG\n \t\t\t  && (GET_MODE_SIZE (GET_MODE (op0))\n \t\t\t      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))));\n@@ -3835,8 +3835,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t  || optab2->handlers[compute_mode].libfunc)\n \tbreak;\n \n-  /* If we still couldn't find a mode, use MODE, but we'll probably abort\n-     in expand_binop.  */\n+  /* If we still couldn't find a mode, use MODE, but expand_binop will\n+     probably die.  */\n   if (compute_mode == VOIDmode)\n     compute_mode = mode;\n \n@@ -5538,9 +5538,9 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n    The algorithm is based on the code in expr.c:do_jump.\n \n-   Note that this does not perform a general comparison.  Only variants\n-   generated within expmed.c are correctly handled, others abort (but could\n-   be handled if needed).  */\n+   Note that this does not perform a general comparison.  Only\n+   variants generated within expmed.c are correctly handled, others\n+   could be handled if needed.  */\n \n static void\n do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, enum machine_mode mode,"}, {"sha": "07e57a4fbfa58ea61bcea20faf7d007af9a512bc", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -3020,8 +3020,8 @@ emit_move_multi_word (enum machine_mode mode, rtx x, rtx y)\n       rtx ypart = operand_subword (y, i, 1, mode);\n \n       /* If we can't get a part of Y, put Y into memory if it is a\n-\t constant.  Otherwise, force it into a register.  If we still\n-\t can't get a part of Y, abort.  */\n+\t constant.  Otherwise, force it into a register.  Then we must\n+\t be able to get a part of Y.  */\n       if (ypart == 0 && CONSTANT_P (y))\n \t{\n \t  y = force_const_mem (mode, y);\n@@ -4222,10 +4222,10 @@ store_expr (tree exp, rtx target, int call_param_p)\n \t but TARGET is not valid memory reference, TEMP will differ\n \t from TARGET although it is really the same location.  */\n       && !(alt_rtl && rtx_equal_p (alt_rtl, target))\n-      /* If there's nothing to copy, don't bother.  Don't call expr_size\n-\t unless necessary, because some front-ends (C++) expr_size-hook\n-\t aborts on objects that are not supposed to be bit-copied or\n-\t bit-initialized.  */\n+      /* If there's nothing to copy, don't bother.  Don't call\n+\t expr_size unless necessary, because some front-ends (C++)\n+\t expr_size-hook must not be given objects that are not\n+\t supposed to be bit-copied or bit-initialized.  */\n       && expr_size (exp) != const0_rtx)\n     {\n       if (GET_MODE (temp) != GET_MODE (target)\n@@ -8341,8 +8341,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         op2 = expand_expr (oprnd2, NULL_RTX, VOIDmode, 0);\n         temp = expand_ternary_op (mode, this_optab, op0, op1, op2, \n \t\t\t\t  target, unsignedp);\n-        if (temp == 0)\n-          abort ();\n+        gcc_assert (temp);\n         return temp;\n       }\n "}, {"sha": "598992ce6e8fb502d5e53e3ed876d12c9aff7558", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -136,7 +136,7 @@ static const char *last_filename;\n extern int length_unit_log; /* This is defined in insn-attrtab.c.  */\n \n /* Nonzero while outputting an `asm' with operands.\n-   This means that inconsistencies are the user's fault, so don't abort.\n+   This means that inconsistencies are the user's fault, so don't die.\n    The precise value is the insn being output, to pass to error_for_asm.  */\n rtx this_is_asm_operands;\n \n@@ -788,7 +788,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n       label_align = xrealloc (label_align,\n \t\t\t      n_labels * sizeof (struct label_alignment));\n \n-      /* Range of labels grows monotonically in the function.  Abort here\n+      /* Range of labels grows monotonically in the function.  Failing here\n          means that the initialization of array got lost.  */\n       gcc_assert (n_old_labels <= n_labels);\n \n@@ -2060,7 +2060,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \n \t    /* Get out the operand values.  */\n \t    string = decode_asm_operands (body, ops, NULL, NULL, NULL);\n-\t    /* Inhibit aborts on what would otherwise be compiler bugs.  */\n+\t    /* Inhibit dieing on what would otherwise be compiler bugs.  */\n \t    insn_noperands = noperands;\n \t    this_is_asm_operands = insn;\n \n@@ -3135,8 +3135,7 @@ output_operand (rtx x, int code ATTRIBUTE_UNUSED)\n   if (x && GET_CODE (x) == SUBREG)\n     x = alter_subreg (&x);\n \n-  /* If X is a pseudo-register, abort now rather than writing trash to the\n-     assembler file.  */\n+  /* X must not be a psuedo reg.  */\n   gcc_assert (!x || !REG_P (x) || REGNO (x) < FIRST_PSEUDO_REGISTER);\n \n   PRINT_OPERAND (asm_out_file, x, code);"}, {"sha": "ff1d861dbe525c967adb9026a0611d29cfac6df0", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -4334,9 +4334,10 @@ void\n recompute_reg_usage (void)\n {\n   allocate_reg_life_data ();\n-  /* distribute_notes in combiner fails to convert some of the REG_UNUSED notes\n-   to REG_DEAD notes.  This causes CHECK_DEAD_NOTES in sched1 to abort.  To \n-   solve this update the DEATH_NOTES here.  */\n+  /* distribute_notes in combiner fails to convert some of the\n+     REG_UNUSED notes to REG_DEAD notes.  This causes CHECK_DEAD_NOTES\n+     in sched1 to die.  To solve this update the DEATH_NOTES\n+     here.  */\n   update_life_info (NULL, UPDATE_LIFE_LOCAL, PROP_REG_INFO | PROP_DEATH_NOTES);\n }\n "}, {"sha": "7ed6092754644f47d5d9e29a2dc6c3ba4aa6e791", "filename": "gcc/function.c", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -578,13 +578,13 @@ make_slot_available (struct temp_slot *temp)\n    free_temp_slots.  Automatic variables for a block are allocated\n    with this flag.  KEEP values of 2 or 3 were needed respectively\n    for variables whose lifetime is controlled by CLEANUP_POINT_EXPRs\n-   or for SAVE_EXPRs, but they are now unused and will abort.\n+   or for SAVE_EXPRs, but they are now unused.\n \n    TYPE is the type that will be used for the stack slot.  */\n \n rtx\n-assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep,\n-\t\t\t    tree type)\n+assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n+\t\t\t    int keep, tree type)\n {\n   unsigned int align;\n   struct temp_slot *p, *best_p = 0, *selected = NULL, **pp;\n@@ -815,7 +815,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n       /* The size of the temporary may be too large to fit into an integer.  */\n       /* ??? Not sure this should happen except for user silliness, so limit\n \t this to things that aren't compiler-generated temporaries.  The\n-\t rest of the time we'll abort in assign_stack_temp_for_type.  */\n+\t rest of the time we'll die in assign_stack_temp_for_type.  */\n       if (decl && size == -1\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n \t{\n@@ -4715,34 +4715,35 @@ emit_return_into_block (basic_block bb, rtx line_note)\n \n #if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n \n-/* These functions convert the epilogue into a variant that does not modify the\n-   stack pointer.  This is used in cases where a function returns an object\n-   whose size is not known until it is computed.  The called function leaves the\n-   object on the stack, leaves the stack depressed, and returns a pointer to\n-   the object.\n-\n-   What we need to do is track all modifications and references to the stack\n-   pointer, deleting the modifications and changing the references to point to\n-   the location the stack pointer would have pointed to had the modifications\n-   taken place.\n-\n-   These functions need to be portable so we need to make as few assumptions\n-   about the epilogue as we can.  However, the epilogue basically contains\n-   three things: instructions to reset the stack pointer, instructions to\n-   reload registers, possibly including the frame pointer, and an\n-   instruction to return to the caller.\n-\n-   If we can't be sure of what a relevant epilogue insn is doing, we abort.\n-   We also make no attempt to validate the insns we make since if they are\n-   invalid, we probably can't do anything valid.  The intent is that these\n-   routines get \"smarter\" as more and more machines start to use them and\n-   they try operating on different epilogues.\n-\n-   We use the following structure to track what the part of the epilogue that\n-   we've already processed has done.  We keep two copies of the SP equivalence,\n-   one for use during the insn we are processing and one for use in the next\n-   insn.  The difference is because one part of a PARALLEL may adjust SP\n-   and the other may use it.  */\n+/* These functions convert the epilogue into a variant that does not\n+   modify the stack pointer.  This is used in cases where a function\n+   returns an object whose size is not known until it is computed.\n+   The called function leaves the object on the stack, leaves the\n+   stack depressed, and returns a pointer to the object.\n+\n+   What we need to do is track all modifications and references to the\n+   stack pointer, deleting the modifications and changing the\n+   references to point to the location the stack pointer would have\n+   pointed to had the modifications taken place.\n+\n+   These functions need to be portable so we need to make as few\n+   assumptions about the epilogue as we can.  However, the epilogue\n+   basically contains three things: instructions to reset the stack\n+   pointer, instructions to reload registers, possibly including the\n+   frame pointer, and an instruction to return to the caller.\n+\n+   We must be sure of what a relevant epilogue insn is doing.  We also\n+   make no attempt to validate the insns we make since if they are\n+   invalid, we probably can't do anything valid.  The intent is that\n+   these routines get \"smarter\" as more and more machines start to use\n+   them and they try operating on different epilogues.\n+\n+   We use the following structure to track what the part of the\n+   epilogue that we've already processed has done.  We keep two copies\n+   of the SP equivalence, one for use during the insn we are\n+   processing and one for use in the next insn.  The difference is\n+   because one part of a PARALLEL may adjust SP and the other may use\n+   it.  */\n \n struct epi_info\n {\n@@ -4960,7 +4961,7 @@ static void\n handle_epilogue_set (rtx set, struct epi_info *p)\n {\n   /* First handle the case where we are setting SP.  Record what it is being\n-     set from.  If unknown, abort.  */\n+     set from, which we must be able to determine  */\n   if (reg_set_p (stack_pointer_rtx, set))\n     {\n       gcc_assert (SET_DEST (set) == stack_pointer_rtx);\n@@ -4995,14 +4996,14 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n       return;\n     }\n \n-  /* Next handle the case where we are setting SP's equivalent register.\n-     If we already have a value to set it to, abort.  We could update, but\n-     there seems little point in handling that case.  Note that we have\n-     to allow for the case where we are setting the register set in\n-     the previous part of a PARALLEL inside a single insn.  But use the\n-     old offset for any updates within this insn.  We must allow for the case\n-     where the register is being set in a different (usually wider) mode than\n-     Pmode).  */\n+  /* Next handle the case where we are setting SP's equivalent\n+     register.  We must not already have a value to set it to.  We\n+     could update, but there seems little point in handling that case.\n+     Note that we have to allow for the case where we are setting the\n+     register set in the previous part of a PARALLEL inside a single\n+     insn.  But use the old offset for any updates within this insn.\n+     We must allow for the case where the register is being set in a\n+     different (usually wider) mode than Pmode).  */\n   else if (p->new_sp_equiv_reg != 0 && reg_set_p (p->new_sp_equiv_reg, set))\n     {\n       gcc_assert (!p->equiv_reg_src"}, {"sha": "ae63c1af99292d0acc78490bd6680cd3486ea3e2", "filename": "gcc/genextract.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -475,9 +475,9 @@ from the machine description file `md'.  */\\n\\n\");\n       printf (\"      break;\\n\\n\");\n     }\n \n-  /* This should never be reached.  Note that we would also reach this abort\n-   if we tried to extract something whose INSN_CODE was a DEFINE_EXPAND or\n-   DEFINE_SPLIT, but that is correct.  */\n+  /* This should never be reached.  Note that we would also reach here\n+     if we tried to extract something whose INSN_CODE was a\n+     DEFINE_EXPAND or DEFINE_SPLIT, but that is correct.  */\n   printf (\"    default:\\n      gcc_unreachable ();\\n\");\n \n   printf (\"    }\\n}\\n\");"}, {"sha": "1162910e666ce3f19e6ec3a77a6d2a225c45e899", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -606,7 +606,7 @@ mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n       || TREE_CODE_CLASS (code) == tcc_constant\n       || code == SAVE_EXPR || code == TARGET_EXPR\n       /* We can't do anything sensible with a BLOCK used as an expression,\n-\t but we also can't abort when we see it because of non-expression\n+\t but we also can't just die when we see it because of non-expression\n \t uses.  So just avert our eyes and cross our fingers.  Silly Java.  */\n       || code == BLOCK)\n     *walk_subtrees = 0;\n@@ -930,7 +930,7 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n      returned in registers.  If we're returning values in registers, then\n      we don't want to extend the lifetime of the RESULT_DECL, particularly\n      across another call.  In addition, for those aggregates for which\n-     hard_function_value generates a PARALLEL, we'll abort during normal\n+     hard_function_value generates a PARALLEL, we'll die during normal\n      expansion of structure assignments; there's special code in expand_return\n      to handle this case that does not exist in expand_expr.  */\n   if (!result_decl\n@@ -2893,7 +2893,7 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \n \t     ??? What about code that pulls out the temp and uses it\n \t     elsewhere? I think that such code never uses the TARGET_EXPR as\n-\t     an initializer.  If I'm wrong, we'll abort because the temp won't\n+\t     an initializer.  If I'm wrong, we'll die because the temp won't\n \t     have any RTL.  In that case, I guess we'll need to replace\n \t     references somehow.  */\n \t  tree init = TARGET_EXPR_INITIAL (*from_p);\n@@ -4329,7 +4329,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n #endif\n       gcc_assert (fallback & fb_mayfail);\n       /* If this is an asm statement, and the user asked for the\n-\t impossible, don't abort.  Fail and let gimplify_asm_expr\n+\t impossible, don't die.  Fail and let gimplify_asm_expr\n \t issue an error.  */\n       ret = GS_ERROR;\n       goto out;"}, {"sha": "bb8a91716147f1c3e745f15413db2a700febdb20", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -753,8 +753,7 @@ queue_insn (rtx insn, int n_cycles)\n HAIFA_INLINE static rtx *\n ready_lastpos (struct ready_list *ready)\n {\n-  if (ready->n_ready == 0)\n-    abort ();\n+  gcc_assert (ready->n_ready);\n   return ready->vec + ready->first - ready->n_ready + 1;\n }\n \n@@ -782,8 +781,8 @@ HAIFA_INLINE static rtx\n ready_remove_first (struct ready_list *ready)\n {\n   rtx t;\n-  if (ready->n_ready == 0)\n-    abort ();\n+  \n+  gcc_assert (ready->n_ready);\n   t = ready->vec[ready->first--];\n   ready->n_ready--;\n   /* If the queue becomes empty, reset it.  */\n@@ -803,10 +802,8 @@ ready_remove_first (struct ready_list *ready)\n HAIFA_INLINE static rtx\n ready_element (struct ready_list *ready, int index)\n {\n-#ifdef ENABLE_CHECKING\n-  if (ready->n_ready == 0 || index >= ready->n_ready)\n-    abort ();\n-#endif\n+  gcc_assert (ready->n_ready && index < ready->n_ready);\n+  \n   return ready->vec[ready->first - index];\n }\n \n@@ -822,8 +819,7 @@ ready_remove (struct ready_list *ready, int index)\n \n   if (index == 0)\n     return ready_remove_first (ready);\n-  if (ready->n_ready == 0 || index >= ready->n_ready)\n-    abort ();\n+  gcc_assert (ready->n_ready && index < ready->n_ready);\n   t = ready->vec[ready->first - index];\n   ready->n_ready--;\n   for (i = index; i < ready->n_ready; i++)\n@@ -1105,12 +1101,7 @@ rm_line_notes (rtx head, rtx tail)\n \t  prev = insn;\n \t  insn = unlink_line_notes (insn, next_tail);\n \n-\t  if (prev == tail)\n-\t    abort ();\n-\t  if (prev == head)\n-\t    abort ();\n-\t  if (insn == next_tail)\n-\t    abort ();\n+\t  gcc_assert (prev != tail && prev != head && insn != next_tail);\n \t}\n     }\n }\n@@ -1289,12 +1280,7 @@ rm_other_notes (rtx head, rtx tail)\n \n \t  insn = unlink_other_notes (insn, next_tail);\n \n-\t  if (prev == tail)\n-\t    abort ();\n-\t  if (prev == head)\n-\t    abort ();\n-\t  if (insn == next_tail)\n-\t    abort ();\n+\t  gcc_assert (prev != tail && prev != head && insn != next_tail);\n \t}\n     }\n }\n@@ -1868,18 +1854,19 @@ schedule_block (int b, int rgn_n_insns)\n      and caused problems because schedule_block and compute_forward_dependences\n      had different notions of what the \"head\" insn was.  */\n \n-  if (head == tail && (! INSN_P (head)))\n-    abort ();\n+  gcc_assert (head != tail || INSN_P (head));\n \n   /* Debug info.  */\n   if (sched_verbose)\n     {\n-      fprintf (sched_dump, \";;   ======================================================\\n\");\n+      fprintf (sched_dump,\n+\t       \";;   ======================================================\\n\");\n       fprintf (sched_dump,\n \t       \";;   -- basic block %d from %d to %d -- %s reload\\n\",\n \t       b, INSN_UID (head), INSN_UID (tail),\n \t       (reload_completed ? \"after\" : \"before\"));\n-      fprintf (sched_dump, \";;   ======================================================\\n\");\n+      fprintf (sched_dump,\n+\t       \";;   ======================================================\\n\");\n       fprintf (sched_dump, \"\\n\");\n     }\n \n@@ -1938,8 +1925,7 @@ schedule_block (int b, int rgn_n_insns)\n \t     list.  */\n \t  queue_to_ready (&ready);\n \n-\t  if (ready.n_ready == 0)\n-\t    abort ();\n+\t  gcc_assert (ready.n_ready);\n \n \t  if (sched_verbose >= 2)\n \t    {\n@@ -2122,8 +2108,7 @@ schedule_block (int b, int rgn_n_insns)\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n      multiple bbs.  */\n-  if (current_sched_info->queue_must_finish_empty && q_size != 0)\n-      abort ();\n+  gcc_assert (!current_sched_info->queue_must_finish_empty || q_size);\n \n   /* Update head/tail boundaries.  */\n   head = NEXT_INSN (prev_head);"}, {"sha": "69f27908b26c2d50d58d2ac88cc4b4247ae87092", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535a42b11612ee3e398190114253e83e0e185b5b/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=535a42b11612ee3e398190114253e83e0e185b5b", "patch": "@@ -4438,7 +4438,7 @@ copy_object (void)\n \n \n \n-  /* Abort if the symbol table is not last.  */\n+  /* The symbol table should be last.  */\n   if (max_file_offset != (unsigned long) stat_buf.st_size)\n     fatal (\"symbol table is not last (symbol table ends at %ld, .o ends at %ld\",\n \t   max_file_offset,\n@@ -4940,7 +4940,7 @@ pfatal_with_name (const char *msg)\n }\n \n \f\n-/* Procedure to abort with an out of bounds error message.  It has\n+/* Procedure to die with an out of bounds error message.  It has\n    type int, so it can be used with an ?: expression within the\n    ORIG_xxx macros, but the function never returns.  */\n "}]}