{"sha": "26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZiY2Y4ZmMxNmEwNmQ0ZmUxNmFjMjVjZTc5NzM5ZTJlNmNiNzQ0NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-03-19T07:27:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-03-19T07:27:30Z"}, "message": "semantics.c (finish_pseudo_destructor_expr): Allow differing cv-qualification between the type named by the...\n\n\n\t* semantics.c (finish_pseudo_destructor_expr): Allow differing\n\tcv-qualification between the type named by the\n\tpseudo-destructor-name and the object-type.\n\n\t* search.c (accessible_base_p): Handle non-proper bases.\n\n\t* name-lookup.c (do_nonmember_using_decl): If a using declaration\n\trefers to a single overloaded function, set the type of the\n\tfunction.\n\t* tree.c (lvalue_type): Simplify.\n\t* typeck.c (type_unknown_p): Do not assume all OVERLOADs have an\n\tunknown type.\n\t(build_unary_op): Handle OVERLOADs with known types.\n\n\t* decl.c (duplicate_decls): Do not destroy DECL_ARGUMENTS for\n\tfunction templates.\n\n\t* parser.c (cp_parser_postfix_expression): Handle the use of\n\t\"typename\" in non-dependent contexts.  Convert appropriately when\n\twhen using a qualified name after \"->\" or \".\".\n\n\t* call.c (conditional_conversion): Honor the requirement that some\n\tconversions refer to the original object.\n\n\t* g++.dg/expr/dtor2.C: New test.\n\n\t* g++.dg/lookup/anon4.C: New test.\n\n\t* g++.dg/overload/using1.C: New test.\n\n\t* g++.dg/template/lookup7.C: New test.\n\n\t* g++.dg/template/typename6.C: New test.\n\n\t* g++.dg/expr/cond6.C: New test.\n\nFrom-SVN: r79671", "tree": {"sha": "78c8fee7aeff0e01a8b8cc9aef49a891bccb39a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78c8fee7aeff0e01a8b8cc9aef49a891bccb39a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/comments", "author": null, "committer": null, "parents": [{"sha": "ff3fcb8a50f89eff597c9d5e8f8d1cf6e31b809b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3fcb8a50f89eff597c9d5e8f8d1cf6e31b809b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff3fcb8a50f89eff597c9d5e8f8d1cf6e31b809b"}], "stats": {"total": 186, "additions": 167, "deletions": 19}, "files": [{"sha": "3822563923612062f2af6ff809f86c9e7cafde54", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -1,3 +1,29 @@\n+2004-03-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* semantics.c (finish_pseudo_destructor_expr): Allow differing\n+\tcv-qualification between the type named by the\n+\tpseudo-destructor-name and the object-type.\n+\n+\t* search.c (accessible_base_p): Handle non-proper bases.\n+\n+\t* name-lookup.c (do_nonmember_using_decl): If a using declaration\n+\trefers to a single overloaded function, set the type of the\n+\tfunction.\n+\t* tree.c (lvalue_type): Simplify.\n+\t* typeck.c (type_unknown_p): Do not assume all OVERLOADs have an\n+\tunknown type.\n+\t(build_unary_op): Handle OVERLOADs with known types.\n+\n+\t* decl.c (duplicate_decls): Do not destroy DECL_ARGUMENTS for\n+\tfunction templates.\n+\n+\t* parser.c (cp_parser_postfix_expression): Handle the use of\n+\t\"typename\" in non-dependent contexts.  Convert appropriately when\n+\twhen using a qualified name after \"->\" or \".\".\n+\n+\t* call.c (conditional_conversion): Honor the requirement that some\n+\tconversions refer to the original object.\n+\n 2004-03-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (build_conditional_expr): Do not call force_rvalue for"}, {"sha": "7270ed6742d71e65f9fbe200a2d9072d7d48900b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -3072,10 +3072,7 @@ conditional_conversion (tree e1, tree e2)\n      same cv-qualification as, or a greater cv-qualification than, the\n      cv-qualification of T1.  If the conversion is applied, E1 is\n      changed to an rvalue of type T2 that still refers to the original\n-     source class object (or the appropriate subobject thereof).\n-\n-     FIXME we can't express an rvalue that refers to the original object;\n-     we have to create a new one.  */\n+     source class object (or the appropriate subobject thereof).  */\n   if (CLASS_TYPE_P (t1) && CLASS_TYPE_P (t2)\n       && ((good_base = DERIVED_FROM_P (t2, t1)) || DERIVED_FROM_P (t1, t2)))\n     {\n@@ -3084,10 +3081,7 @@ conditional_conversion (tree e1, tree e2)\n \t  conv = build_identity_conv (t1, e1);\n \t  if (!same_type_p (TYPE_MAIN_VARIANT (t1), \n \t\t\t    TYPE_MAIN_VARIANT (t2)))\n-\t    {\n-\t      conv = build_conv (ck_base, t2, conv);\n-\t      conv->need_temporary_p = true;\n-\t    }\n+\t    conv = build_conv (ck_base, t2, conv);\n \t  else\n \t    conv = build_conv (ck_rvalue, t2, conv);\n \t  return conv;"}, {"sha": "29d658859e6bb1c7aa65e406835c568694ccfc56", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -1581,6 +1581,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  DECL_SOURCE_LOCATION (olddecl) \n \t    = DECL_SOURCE_LOCATION (DECL_TEMPLATE_RESULT (olddecl))\n \t    = DECL_SOURCE_LOCATION (newdecl);\n+\t  if (DECL_FUNCTION_TEMPLATE_P (newdecl))\n+\t    DECL_ARGUMENTS (DECL_TEMPLATE_RESULT (olddecl))\n+\t      = DECL_ARGUMENTS (DECL_TEMPLATE_RESULT (newdecl));\n \t}\n \n       if (DECL_FUNCTION_TEMPLATE_P (newdecl))"}, {"sha": "e0a919d5b557c4d6a38e23b59c54adc2a82d8daa", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -2194,9 +2194,21 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t  if (tmp1)\n \t    continue;\n \t    \n+\t  /* If we are adding to an existing OVERLOAD, then we no\n+\t     longer know the type of the set of functions.  */\n+\t  if (*newval && TREE_CODE (*newval) == OVERLOAD)\n+\t    TREE_TYPE (*newval) = unknown_type_node;\n+\t  /* Add this new function to the set.  */\n \t  *newval = build_overload (OVL_CURRENT (tmp), *newval);\n+\t  /* If there is only one function, then we use its type.  (A\n+\t     using-declaration naming a single function can be used in\n+\t     contexts where overload resolution cannot be\n+\t     performed.)  */\n \t  if (TREE_CODE (*newval) != OVERLOAD)\n-\t    *newval = ovl_cons (*newval, NULL_TREE);\n+\t    {\n+\t      *newval = ovl_cons (*newval, NULL_TREE);\n+\t      TREE_TYPE (*newval) = TREE_TYPE (OVL_CURRENT (tmp));\n+\t    }\n \t  OVL_USED (*newval) = 1;\n \t}\n     }"}, {"sha": "c05e37542188fa013ca42285d4fe19265bb8b1cb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -3629,10 +3629,16 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t/* If that didn't work, try an identifier.  */\n \tif (!cp_parser_parse_definitely (parser))\n \t  id = cp_parser_identifier (parser);\n+\t/* If we look up a template-id in a non-dependent qualifying\n+\t   scope, there's no need to create a dependent type.  */\n+\tif (TREE_CODE (id) == TYPE_DECL\n+\t    && !dependent_type_p (parser->scope))\n+\t  type = TREE_TYPE (id);\n \t/* Create a TYPENAME_TYPE to represent the type to which the\n \t   functional cast is being performed.  */\n-\ttype = make_typename_type (parser->scope, id,\n-\t\t\t\t   /*complain=*/1);\n+\telse\n+\t  type = make_typename_type (parser->scope, id, \n+\t\t\t\t     /*complain=*/1);\n \n \tpostfix_expression = cp_parser_functional_cast (parser, type);\n       }\n@@ -3971,6 +3977,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t    parser->qualifying_scope = NULL_TREE;\n \t\t    parser->object_scope = NULL_TREE;\n \t\t  }\n+\t\tif (scope && name && BASELINK_P (name))\n+\t\t  adjust_result_of_qualified_name_lookup \n+\t\t    (name, BINFO_TYPE (BASELINK_BINFO (name)), scope);\n \t\tpostfix_expression\n \t\t  = finish_class_member_access_expr (postfix_expression, name);\n \t      }"}, {"sha": "11c7dedf57d1524ed8f481a473123049719e7ea2", "filename": "gcc/cp/search.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -232,7 +232,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n }\n \n /* Returns true if type BASE is accessible in T.  (BASE is known to be\n-   a base class of T.)  */\n+   a (possibly non-proper) base class of T.)  */\n \n bool\n accessible_base_p (tree t, tree base)\n@@ -242,7 +242,12 @@ accessible_base_p (tree t, tree base)\n   /* [class.access.base]\n \n      A base class is said to be accessible if an invented public\n-     member of the base class is accessible.  */\n+     member of the base class is accessible.  \n+\n+     If BASE is a non-proper base, this condition is trivially\n+     true.  */\n+  if (same_type_p (t, base))\n+    return true;\n   /* Rather than inventing a public member, we use the implicit\n      public typedef created in the scope of every class.  */\n   decl = TYPE_FIELDS (base);"}, {"sha": "50cb153ec10ed84f0402be11856cbcd906b4a077", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -1803,7 +1803,21 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n \t  return error_mark_node;\n \t}\n       \n-      if (!same_type_p (TREE_TYPE (object), destructor))\n+      /* [expr.pseudo] says both:\n+\n+           The type designated by the pseudo-destructor-name shall be\n+\t   the same as the object type.\n+\n+         and:\n+\n+           The cv-unqualified versions of the object type and of the\n+\t   type designated by the pseudo-destructor-name shall be the\n+\t   same type.\n+\n+         We implement the more generous second sentence, since that is\n+         what most other compilers do.  */\n+      if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (object), \n+\t\t\t\t\t\t      destructor))\n \t{\n \t  error (\"`%E' is not of type `%T'\", object, destructor);\n \t  return error_mark_node;"}, {"sha": "85855ac6d6e98f1e55f6324502dbf91ddb4f4283", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -1646,8 +1646,6 @@ tree\n lvalue_type (tree arg)\n {\n   tree type = TREE_TYPE (arg);\n-  if (TREE_CODE (arg) == OVERLOAD)\n-    type = unknown_type_node;\n   return type;\n }\n "}, {"sha": "32d8177b6013f65e20ec7a025becbdbf567152ef", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -163,8 +163,7 @@ complete_type_or_diagnostic (tree type, tree value, int diag_type)\n int\n type_unknown_p (tree exp)\n {\n-  return (TREE_CODE (exp) == OVERLOAD\n-          || TREE_CODE (exp) == TREE_LIST\n+  return (TREE_CODE (exp) == TREE_LIST\n \t  || TREE_TYPE (exp) == unknown_type_node);\n }\n \n@@ -4022,7 +4021,11 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  if (! lvalue_p (arg) && pedantic)\n \t    pedwarn (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n \t  break;\n-\t  \n+\n+\tcase OVERLOAD:\n+\t  arg = OVL_CURRENT (arg);\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}"}, {"sha": "391bfa3844cbbd0d35faf7640a462f89d00a2baf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -1,3 +1,17 @@\n+2004-03-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/expr/dtor2.C: New test.\n+\n+\t* g++.dg/lookup/anon4.C: New test.\n+\n+\t* g++.dg/overload/using1.C: New test.\n+\n+\t* g++.dg/template/lookup7.C: New test.\n+\n+\t* g++.dg/template/typename6.C: New test.\n+\n+\t* g++.dg/expr/cond6.C: New test.\n+\n 2004-03-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-convert-1.c: Test more math builtins."}, {"sha": "9308c17954121e9ee9241690983cad4099edaca9", "filename": "gcc/testsuite/g++.dg/expr/cond6.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcond6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcond6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcond6.C?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do \"run\" }\n+\n+extern \"C\" void abort ();\n+\n+struct B {\n+  B() {}\n+  B(const B& b) { abort (); }\n+};\n+\n+struct D : public B {\n+  D() {}\n+  D(const D& d) : B() {}\n+};\n+\n+D d;\n+B b;\n+\n+D f() {\n+  return d;\n+}\n+\n+int main () {\n+  b = (true ? f() : b);\n+}"}, {"sha": "5f372424e66d21d2206eb1d37b0969760a9f1afd", "filename": "gcc/testsuite/g++.dg/expr/dtor2.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fdtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fdtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fdtor2.C?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -0,0 +1,6 @@\n+typedef const int I;\n+int i;\n+\n+void f() {\n+  i.I::~I();\n+}"}, {"sha": "40c4ab40a586cd9bf201aceb988299350ae125d2", "filename": "gcc/testsuite/g++.dg/lookup/anon4.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fanon4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fanon4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fanon4.C?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -0,0 +1,9 @@\n+static union {\n+  int i;\n+};\n+\n+int *ip;\n+\n+void g() {\n+  ip = &i;\n+}"}, {"sha": "bc46c6049777e2e775cc40558c3870670fbccaec", "filename": "gcc/testsuite/g++.dg/overload/using1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fusing1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fusing1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fusing1.C?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -0,0 +1,11 @@\n+void f();\n+\n+namespace N { \n+  using ::f;\n+}\n+\n+bool b;\n+\n+void g() {\n+  b = N::f == ::f;\n+}"}, {"sha": "0e05c5f752cae6c0c7de52e1e27958b88b4f2be2", "filename": "gcc/testsuite/g++.dg/template/lookup7.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup7.C?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -0,0 +1,9 @@\n+class S;\n+\n+template<class T>\n+int f(T, S);\n+\n+class S {\n+  template<class T>\n+  friend int f(T t, S) { t; return 0; }\n+};"}, {"sha": "937ea96aa80a41edc5c4019be1438b62b8e75e14", "filename": "gcc/testsuite/g++.dg/template/typename6.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename6.C?ref=26bcf8fc16a06d4fe16ac25ce79739e2e6cb7445", "patch": "@@ -0,0 +1,11 @@\n+struct O {\n+  template <typename T>\n+  struct I {\n+    I (int);\n+  };\n+};\n+\n+template <typename T>\n+void f() {\n+  typename ::O::I<int>(3);\n+}"}]}