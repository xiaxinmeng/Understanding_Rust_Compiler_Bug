{"sha": "c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJhNDdlNDhkNWY3NjIwZTg3YWZmM2ZjMjE0ZGExYjY5OGVkMWNkYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-22T10:33:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-22T10:33:37Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1045", "tree": {"sha": "c337b5b6dd0794247e04ab0c390bae4e947b18f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c337b5b6dd0794247e04ab0c390bae4e947b18f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/comments", "author": null, "committer": null, "parents": [{"sha": "3ad69266be869b0a6f6a8f9701728185e62cf9b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad69266be869b0a6f6a8f9701728185e62cf9b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad69266be869b0a6f6a8f9701728185e62cf9b3"}], "stats": {"total": 73, "additions": 51, "deletions": 22}, "files": [{"sha": "b9d0598bfa3c14c4f47235907b71f7429f60a5dc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "patch": "@@ -1406,7 +1406,7 @@ output_epilog (file, size)\n        from the function start.  */\n     if (*fname == '*')\n       ++fname;\n-    fprintf (file, \"L..tbtab_\");\n+    fprintf (file, \"LT..\");\n     ASM_OUTPUT_LABEL (file, fname);\n \n     /* The .tbtab psuedo-op can only be used for the first eight\n@@ -1534,7 +1534,7 @@ output_epilog (file, size)\n       fprintf (file, \"\\t.long %d\\n\", parm_info);\n \n     /* Offset from start of code to tb table.  */\n-    fprintf (file, \"\\t.long L..tbtab_\");\n+    fprintf (file, \"\\t.long LT..\");\n     RS6000_OUTPUT_BASENAME (file, fname);\n     fprintf (file, \"-.\");\n     RS6000_OUTPUT_BASENAME (file, fname);\n@@ -1621,9 +1621,9 @@ output_toc (file, x, labelno)\n   RS6000_OUTPUT_BASENAME (file, name);\n \n   if (offset < 0)\n-    fprintf (file, \"P.N.%d\", - offset);\n+    fprintf (file, \".N%d\", - offset);\n   else if (offset)\n-    fprintf (file, \".P.%d\", offset);\n+    fprintf (file, \".P%d\", offset);\n \n   fprintf (file, \"[TC],\");\n   output_addr_const (file, x);\n@@ -1766,7 +1766,7 @@ output_function_profiler (file, labelno)\n \n   /* Set up a TOC entry for the profiler label.  */\n   toc_section ();\n-  fprintf (file, \"LPTOC..%d:\\n\\t.tc\\tLP..%d[TC], LP..%d\\n\",\n+  fprintf (file, \"LPC..%d:\\n\\t.tc\\tLP..%d[TC],LP..%d\\n\",\n \t   labelno, labelno, labelno);\n   text_section ();\n \n@@ -1787,7 +1787,7 @@ output_function_profiler (file, labelno)\n \n   /* Load location address into r3, and call mcount.  */\n \n-  fprintf (file, \"\\tl 3,LPTOC..%d(2)\\n\\tbl .mcount\\n\", labelno);\n+  fprintf (file, \"\\tl 3,LPC..%d(2)\\n\\tbl .mcount\\n\", labelno);\n \n   /* Restore parameter registers.  */\n "}, {"sha": "7cda5d2fb712146fbb6257e5cd2dabe428d8ece2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "patch": "@@ -1437,18 +1437,7 @@ toc_section ()\t\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n   if (write_symbols == XCOFF_DEBUG)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      dbxout_symbol (DECL, 0);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.function .\");\t\t\t\t\\\n-      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      fprintf (FILE, \",.\");\t\t\t\t\t\\\n-      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      fprintf (FILE, \",16,044,L..end_\");\t\t\t\\\n-      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      fprintf (FILE, \"-.\");\t\t\t\t\t\\\n-      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n+    xcoffout_declare_function (FILE, DECL, NAME);\t\t\\\n }\n \n /* Return non-zero if this entry is to be written into the constant pool"}, {"sha": "940a0bedb59cbf04f9cfa4cd258a36833658e7db", "filename": "gcc/cse.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "patch": "@@ -6112,11 +6112,16 @@ cse_insn (insn, in_libcall_block)\n \t  sets[i].rtl = 0;\n \t}\n \n-      /* No further processing for this assignment if destination\n-\t is volatile.  */\n+      /* If destination is volatile, invalidate it and then do no further\n+\t processing for this assignment.  */\n \n       else if (do_not_record)\n-\tsets[i].rtl = 0;\n+\t{\n+\t  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n+\t      || GET_CODE (dest) == MEM)\n+\t    invalidate (dest);\n+\t  sets[i].rtl = 0;\n+\t}\n \n       if (sets[i].rtl != 0 && dest != SET_DEST (sets[i].rtl))\n \tsets[i].dest_hash_code = HASH (SET_DEST (sets[i].rtl), mode);"}, {"sha": "07a6c272d7b5f4155aed0ba5c7c9c76654453f00", "filename": "gcc/expmed.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "patch": "@@ -2254,6 +2254,14 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n       op1 = convert_to_mode (compute_mode, op1, unsignedp);\n     }\n \n+  /* If we are computing the remainder and one of the operands is a volatile\n+     MEM, copy it into a register.  */\n+\n+  if (rem_flag && GET_CODE (op0) == MEM && MEM_VOLATILE_P (op0))\n+    adjusted_op0 = op0 = force_reg (compute_mode, op0), can_clobber_op0 = 1;\n+  if (rem_flag && GET_CODE (op1) == MEM && MEM_VOLATILE_P (op1))\n+    op1 = force_reg (compute_mode, op1);\n+\n   if (target == 0 || GET_MODE (target) != compute_mode)\n     target = gen_reg_rtx (compute_mode);\n "}, {"sha": "6e7c50f26e2d639f56d8e3587b9918c4b95b29dd", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a47e48d5f7620e87aff3fc214da1b698ed1cdb/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=c2a47e48d5f7620e87aff3fc214da1b698ed1cdb", "patch": "@@ -399,6 +399,33 @@ xcoffout_end_block (file, line, n)\n   ASM_OUTPUT_LBE (file, line, n);\n }\n \n+/* Called at beginning of function (before prologue).\n+   Declare function as needed for debugging.  */\n+\n+void\n+xcoffout_declare_function (file, decl, name)\n+     FILE *file;\n+     tree decl;\n+     char *name;\n+{\n+  char *n = name;\n+  int i;\n+\n+  for (i = 0; name[i]; ++i)\n+    {\n+      if (name[i] == '[')\n+\t{\n+\t  n = alloca (i + 1);\n+\t  strncpy (n, name, i);\n+\t  n[i] = '\\0';\n+\t  break;\n+\t}\n+    }\n+\n+  dbxout_symbol (decl, 0);\n+  fprintf (file, \"\\t.function .%s,.%s,16,044,FE..%s-.%s\\n\", n, n, n, n);\n+}\n+\n /* Called at beginning of function body (after prologue).\n    Record the function's starting line number, so we can output\n    relative line numbers for the other lines.\n@@ -438,7 +465,7 @@ xcoffout_end_epilogue (file)\n   char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n   if (*fname == '*')\n     ++fname;\n-  fprintf (file, \"L..end_\");\n+  fprintf (file, \"FE..\");\n   ASM_OUTPUT_LABEL (file, fname);\n }\n #endif /* XCOFF_DEBUGGING_INFO */"}]}