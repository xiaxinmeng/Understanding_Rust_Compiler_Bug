{"sha": "e7a740068ed3cc5961101f07012314d940a97ae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdhNzQwMDY4ZWQzY2M1OTYxMTAxZjA3MDEyMzE0ZDk0MGE5N2FlNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-03T15:42:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-03T15:42:30Z"}, "message": "asan.c (create_cond_insert_point): Maintain profile.\n\n\n\t* asan.c (create_cond_insert_point): Maintain profile.\n\t* ipa-utils.c (ipa_merge_profiles): Be sure only IPA profiles are\n\tmerged.\n\t* basic-block.h (struct basic_block_def): Remove frequency.\n\t(EDGE_FREQUENCY): Use to_frequency\n\t* bb-reorder.c (push_to_next_round_p): Use only IPA counts for global\n\theuristics.\n\t(find_traces): Update to use to_frequency.\n\t(find_traces_1_round): Likewise; use only IPA counts.\n\t(bb_to_key): Likewise.\n\t(connect_traces): Use IPA counts only.\n\t(copy_bb_p): Update to use to_frequency.\n\t(fix_up_crossing_landing_pad): Likewise.\n\t(sanitize_hot_paths): Likewise.\n\t* bt-load.c (basic_block_freq): Likewise.\n\t* cfg.c (init_flow): Set count_max to uninitialized.\n\t(check_bb_profile): Remove frequencies; check counts.\n\t(dump_bb_info): Do not dump frequencies.\n\t(update_bb_profile_for_threading): Update counts only.\n\t(scale_bbs_frequencies_int): Likewise.\n\t(MAX_SAFE_MULTIPLIER): Remove.\n\t(scale_bbs_frequencies_gcov_type): Update counts only.\n\t(scale_bbs_frequencies_profile_count): Update counts only.\n\t(scale_bbs_frequencies): Update counts only.\n\t* cfg.h (struct control_flow_graph): Add count-max.\n\t(update_bb_profile_for_threading): Update prototype.\n\t* cfgbuild.c (find_bb_boundaries): Do not update frequencies.\n\t(find_many_sub_basic_blocks): Likewise.\n\t* cfgcleanup.c (try_forward_edges): Likewise.\n\t(try_crossjump_to_edge): Likewise.\n\t* cfgexpand.c (expand_gimple_cond): Likewise.\n\t(expand_gimple_tailcall): Likewise.\n\t(construct_init_block): Likewise.\n\t(construct_exit_block): Likewise.\n\t* cfghooks.c (verify_flow_info): Check consistency of counts.\n\t(dump_bb_for_graph): Do not dump frequencies.\n\t(split_block_1): Do not update frequencies.\n\t(split_edge): Do not update frequencies.\n\t(make_forwarder_block): Do not update frequencies.\n\t(duplicate_block): Do not update frequencies.\n\t(account_profile_record): Do not update frequencies.\n\t* cfgloop.c (find_subloop_latch_edge_by_profile): Use IPA counts\n\tfor global heuristics.\n\t* cfgloopanal.c (average_num_loop_insns): Update to use to_frequency.\n\t(expected_loop_iterations_unbounded): Use counts only.\n\t* cfgloopmanip.c (scale_loop_profile): Simplify.\n\t(create_empty_loop_on_edge): Simplify\n\t(loopify): Simplify\n\t(duplicate_loop_to_header_edge): Simplify\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Update profile.\n\t(update_br_prob_note): Take care of removing note when profile\n\tbecomes undefined.\n\t(relink_block_chain): Do not dump frequency.\n\t(rtl_account_profile_record): Use to_frequency.\n\t* cgraph.c (symbol_table::create_edge): Convert count to ipa count.\n\t(cgraph_edge::redirect_call_stmt_to_calle): Conver tcount to ipa count.\n\t(cgraph_update_edges_for_call_stmt_node): Likewise.\n\t(cgraph_edge::verify_count_and_frequency): Update.\n\t(cgraph_node::verify_node): Temporarily disable frequency verification.\n\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Use\n\tto_cgraph_frequency.\n\t(cgraph_edge::rebuild_edges): Convert to ipa counts.\n\t* cgraphunit.c (init_lowered_empty_function): Do not initialize\n\tfrequencies.\n\t(cgraph_node::expand_thunk): Update profile.\n\t* except.c (dw2_build_landing_pads): Do not update frequency.\n\t* final.c (compute_alignments): Use to_frequency.\n\t(dump_basic_block_info): Do not dump frequency.\n\t* gimple-pretty-print.c (dump_profile): Do not dump frequency.\n\t(dump_gimple_bb_header): Do not dump frequency.\n\t* gimple-ssa-isolate-paths.c (isolate_path): Do not update frequency;\n\tdo update count.\n\t* gimple-streamer-in.c (input_bb): Do not stream frequency.\n\t* gimple-streamer-out.c (output_bb): Do not stream frequency.\n\t* haifa-sched.c (sched_pressure_start_bb): Use to_freuqency.\n\t(init_before_recovery): Do not update frequency.\n\t(sched_create_recovery_edges): Do not update frequency.\n\t* hsa-gen.c (convert_switch_statements): Do not update frequency.\n\t* ipa-cp.c (ipcp_propagate_stage): Update search for max_count.\n\t(ipa_cp_c_finalize): Set max_count to uninitialized.\n\t* ipa-fnsummary.c (get_minimal_bb): Use counts.\n\t(param_change_prob): Use counts.\n\t* ipa-profile.c (ipa_profile_generate_summary): Do not summarize\n\tlocal profiles.\n\t* ipa-split.c (consider_split): Use to_frequency.\n\t(split_function): Use to_frequency.\n\t* ira-build.c (loop_compare_func): Likewise.\n\t(mark_loops_for_removal): Likewise.\n\t(mark_all_loops_for_removal): Likewise.\n\t* loop-doloop.c (doloop_modify): Do not update frequency.\n\t* loop-unroll.c (unroll_loop_runtime_iterations): Do not update\n\tfrequency.\n\t* lto-streamer-in.c (input_function): Update count_max.\n\t* omp-expand.c (expand_omp_taskreg): Update count_max.\n\t* omp-simd-clone.c (simd_clone_adjust): Update profile.\n\t* predict.c (maybe_hot_frequency_p): Use to_frequency.\n\t(maybe_hot_count_p): Use ipa counts only.\n\t(maybe_hot_bb_p): Simplify.\n\t(maybe_hot_edge_p): Simplify.\n\t(probably_never_executed): Do not take frequency argument.\n\t(probably_never_executed_bb_p): Do not pass frequency.\n\t(probably_never_executed_edge_p): Likewise.\n\t(combine_predictions_for_bb): Check that profile is nonzero.\n\t(propagate_freq): Do not set frequency.\n\t(drop_profile): Simplify.\n\t(counts_to_freqs): Simplify.\n\t(expensive_function_p): Use to_frequency.\n\t(propagate_unlikely_bbs_forward): Simplify.\n\t(determine_unlikely_bbs): Simplify.\n\t(estimate_bb_frequencies): Add hack to silence graphite issues.\n\t(compute_function_frequency): Use ipa counts.\n\t(pass_profile::execute): Update.\n\t(rebuild_frequencies): Use counts only.\n\t(force_edge_cold): Use counts only.\n\t* profile-count.c (profile_count::dump): Dump new count types.\n\t(profile_count::differs_from_p): Check compatiblity.\n\t(profile_count::to_frequency): New function.\n\t(profile_count::to_cgraph_frequency): New function.\n\t* profile-count.h (struct function): Declare.\n\t(enum profile_quality): Add profile_guessed_local and\n\tprofile_guessed_global0.\n\t(class profile_proability): Decrease number of bits to 29;\n\tupdate from_reg_br_prob_note and to_reg_br_prob_note.\n\t(class profile_count: Update comment; decrease number of bits\n\tto 61. Check compatibility.\n\t(profile_count::compatible_p): New private member function.\n\t(profile_count::ipa_p): New member function.\n\t(profile_count::operator<): Handle global zero correctly.\n\t(profile_count::operator>): Handle global zero correctly.\n\t(profile_count::operator<=): Handle global zero correctly.\n\t(profile_count::operator>=): Handle global zero correctly.\n\t(profile_count::nonzero_p): New member function.\n\t(profile_count::force_nonzero): New member function.\n\t(profile_count::max): New member function.\n\t(profile_count::apply_scale): Handle IPA scalling.\n\t(profile_count::guessed_local): New member function.\n\t(profile_count::global0): New member function.\n\t(profile_count::ipa): New member function.\n\t(profile_count::to_frequency): Declare.\n\t(profile_count::to_cgraph_frequency): Declare.\n\t* profile.c (OVERLAP_BASE): Delete.\n\t(compute_frequency_overlap): Delete.\n\t(compute_branch_probabilities): Do not use compute_frequency_overlap.\n\t* regs.h (REG_FREQ_FROM_BB): Use to_frequency.\n\t* sched-ebb.c (rank): Use counts only.\n\t* shrink-wrap.c (handle_simple_exit): Use counts only.\n\t(try_shrink_wrapping): Use counts only.\n\t(place_prologue_for_one_component): Use counts only.\n\t* tracer.c (find_best_predecessor): Use to_frequency.\n\t(find_trace): Use to_frequency.\n\t(tail_duplicate): Use to_frequency.\n\t* trans-mem.c (expand_transaction): Do not update frequency.\n\t* tree-call-cdce.c: Do not update frequency. \n\t* tree-cfg.c (gimple_find_sub_bbs): Likewise.\n\t(gimple_merge_blocks): Likewise.\n\t(gimple_split_edge): Likewise.\n\t(gimple_duplicate_sese_region): Likewise.\n\t(gimple_duplicate_sese_tail): Likewise.\n\t(move_sese_region_to_fn): Likewise.\n\t(gimple_account_profile_record): Likewise.\n\t(insert_cond_bb): Likewise.\n\t* tree-complex.c (expand_complex_div_wide): Likewise.\n\t* tree-eh.c (lower_resx): Update profile.\n\t* tree-inline.c (copy_bb): Simplify count scaling; do not scale\n\tfrequencies.\n\t(initialize_cfun): Do not initialize frequencies\n\t(freqs_to_counts): Delete.\n\t(copy_cfg_body): Ignore count parameter.\n\t(copy_body): Update.\n\t(expand_call_inline): Update count_max.\n\t(optimize_inline_calls): Update count_max.\n\t(tree_function_versioning): Update count_max.\n\t* tree-ssa-coalesce.c (coalesce_cost_bb): Use to_frequency.\n\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Do not update\n\tfrequency.\n\t* tree-ssa-loop-im.c (execute_sm_if_changed): Use counts only.\n\t* tree-ssa-loop-ivcanon.c (unloop_loops): Do not update freuqency.\n\t(try_peel_loop): Likewise.\n\t* tree-ssa-loop-ivopts.c (get_scaled_computation_cost_at): Use\n\tto_frequency.\n\t* tree-ssa-loop-manip.c (niter_for_unrolled_loop): Pass -1.\n\t(tree_transform_and_unroll_loop): Do not use frequencies\n\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations):\n\tUse reliable prediction only.\n\t* tree-ssa-loop-unswitch.c (hoist_guard): Do not use frequencies.\n\t* tree-ssa-sink.c (select_best_block): Use to_frequency.\n\t* tree-ssa-tail-merge.c (replace_block_by): Temporarily disable\n\tprobability scaling.\n\t* tree-ssa-threadupdate.c (create_block_for_threading): Do\n\tnot update frequency\n\t(any_remaining_duplicated_blocks): Likewise.\n\t(update_profile): Likewise.\n\t(estimated_freqs_path): Delete.\n\t(freqs_to_counts_path): Delete.\n\t(clear_counts_path): Delete.\n\t(ssa_fix_duplicate_block_edges): Likewise.\n\t(duplicate_thread_path): Likewise.\n\t* tree-switch-conversion.c (gen_inbound_check): Use counts.\n\t* tree-tailcall.c (decrease_profile): Do not update frequency.\n\t(eliminate_tail_call): Likewise.\n\t* tree-vect-loop-manip.c (vect_do_peeling): Likewise.\n\t* tree-vect-loop.c (scale_profile_for_vect_loop): Likewise.\n\t(optimize_mask_stores): Likewise.\n\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Likewise.\n\t* ubsan.c (ubsan_expand_null_ifn): Update profile.\n\t(ubsan_expand_ptr_ifn): Update profile.\n\t* value-prof.c (gimple_ic): Simplify.\n\t* value-prof.h (gimple_ic): Update prototype.\n\t* ipa-inline-transform.c (inline_transform): Fix scaling conditoins.\n\t* ipa-inline.c (compute_uninlined_call_time): Be sure that\n\tcounts are nonzero.\n\t(want_inline_self_recursive_call_p): Likewise.\n\t(resolve_noninline_speculation): Only cummulate defined counts.\n\t(inline_small_functions): Use nonzero_p.\n\t(ipa_inline): Do not access freed node.\n\nUnknown ChangeLog:\n\n2017-11-02  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* testsuite/gcc.dg/no-strict-overflow-3.c (foo): Update magic\n\tvalue to not clash with frequency.\n\t* testsuite/gcc.dg/strict-overflow-3.c (foo): Likewise.\n\t* testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/dump-2.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-10.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-11.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-12.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-20040816-1.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-20040816-2.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-5.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-8.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-9.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-cd.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-pr56541.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-pr68583.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-pr69489-1.c: Update template.\n\t* testsuite/gcc.dg/tree-ssa/ifc-pr69489-2.c: Update template.\n\t* testsuite/gcc.target/i386/pr61403.c: Update template.\n\nFrom-SVN: r254379", "tree": {"sha": "60ff28d76be31e01dc2ff68a6aba99743046eba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60ff28d76be31e01dc2ff68a6aba99743046eba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7a740068ed3cc5961101f07012314d940a97ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a740068ed3cc5961101f07012314d940a97ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a740068ed3cc5961101f07012314d940a97ae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a740068ed3cc5961101f07012314d940a97ae5/comments", "author": null, "committer": null, "parents": [{"sha": "13494fcb363e8a901db7768a851a9eed1dea62e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13494fcb363e8a901db7768a851a9eed1dea62e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13494fcb363e8a901db7768a851a9eed1dea62e3"}], "stats": {"total": 2085, "additions": 1049, "deletions": 1036}, "files": [{"sha": "0a27e36d6b8d4ed65379d0bbf76d5785375448f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1,3 +1,221 @@\n+2017-11-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* asan.c (create_cond_insert_point): Maintain profile.\n+\t* ipa-utils.c (ipa_merge_profiles): Be sure only IPA profiles are\n+\tmerged.\n+\t* basic-block.h (struct basic_block_def): Remove frequency.\n+\t(EDGE_FREQUENCY): Use to_frequency\n+\t* bb-reorder.c (push_to_next_round_p): Use only IPA counts for global\n+\theuristics.\n+\t(find_traces): Update to use to_frequency.\n+\t(find_traces_1_round): Likewise; use only IPA counts.\n+\t(bb_to_key): Likewise.\n+\t(connect_traces): Use IPA counts only.\n+\t(copy_bb_p): Update to use to_frequency.\n+\t(fix_up_crossing_landing_pad): Likewise.\n+\t(sanitize_hot_paths): Likewise.\n+\t* bt-load.c (basic_block_freq): Likewise.\n+\t* cfg.c (init_flow): Set count_max to uninitialized.\n+\t(check_bb_profile): Remove frequencies; check counts.\n+\t(dump_bb_info): Do not dump frequencies.\n+\t(update_bb_profile_for_threading): Update counts only.\n+\t(scale_bbs_frequencies_int): Likewise.\n+\t(MAX_SAFE_MULTIPLIER): Remove.\n+\t(scale_bbs_frequencies_gcov_type): Update counts only.\n+\t(scale_bbs_frequencies_profile_count): Update counts only.\n+\t(scale_bbs_frequencies): Update counts only.\n+\t* cfg.h (struct control_flow_graph): Add count-max.\n+\t(update_bb_profile_for_threading): Update prototype.\n+\t* cfgbuild.c (find_bb_boundaries): Do not update frequencies.\n+\t(find_many_sub_basic_blocks): Likewise.\n+\t* cfgcleanup.c (try_forward_edges): Likewise.\n+\t(try_crossjump_to_edge): Likewise.\n+\t* cfgexpand.c (expand_gimple_cond): Likewise.\n+\t(expand_gimple_tailcall): Likewise.\n+\t(construct_init_block): Likewise.\n+\t(construct_exit_block): Likewise.\n+\t* cfghooks.c (verify_flow_info): Check consistency of counts.\n+\t(dump_bb_for_graph): Do not dump frequencies.\n+\t(split_block_1): Do not update frequencies.\n+\t(split_edge): Do not update frequencies.\n+\t(make_forwarder_block): Do not update frequencies.\n+\t(duplicate_block): Do not update frequencies.\n+\t(account_profile_record): Do not update frequencies.\n+\t* cfgloop.c (find_subloop_latch_edge_by_profile): Use IPA counts\n+\tfor global heuristics.\n+\t* cfgloopanal.c (average_num_loop_insns): Update to use to_frequency.\n+\t(expected_loop_iterations_unbounded): Use counts only.\n+\t* cfgloopmanip.c (scale_loop_profile): Simplify.\n+\t(create_empty_loop_on_edge): Simplify\n+\t(loopify): Simplify\n+\t(duplicate_loop_to_header_edge): Simplify\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Update profile.\n+\t(update_br_prob_note): Take care of removing note when profile\n+\tbecomes undefined.\n+\t(relink_block_chain): Do not dump frequency.\n+\t(rtl_account_profile_record): Use to_frequency.\n+\t* cgraph.c (symbol_table::create_edge): Convert count to ipa count.\n+\t(cgraph_edge::redirect_call_stmt_to_calle): Conver tcount to ipa count.\n+\t(cgraph_update_edges_for_call_stmt_node): Likewise.\n+\t(cgraph_edge::verify_count_and_frequency): Update.\n+\t(cgraph_node::verify_node): Temporarily disable frequency verification.\n+\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Use\n+\tto_cgraph_frequency.\n+\t(cgraph_edge::rebuild_edges): Convert to ipa counts.\n+\t* cgraphunit.c (init_lowered_empty_function): Do not initialize\n+\tfrequencies.\n+\t(cgraph_node::expand_thunk): Update profile.\n+\t* except.c (dw2_build_landing_pads): Do not update frequency.\n+\t* final.c (compute_alignments): Use to_frequency.\n+\t(dump_basic_block_info): Do not dump frequency.\n+\t* gimple-pretty-print.c (dump_profile): Do not dump frequency.\n+\t(dump_gimple_bb_header): Do not dump frequency.\n+\t* gimple-ssa-isolate-paths.c (isolate_path): Do not update frequency;\n+\tdo update count.\n+\t* gimple-streamer-in.c (input_bb): Do not stream frequency.\n+\t* gimple-streamer-out.c (output_bb): Do not stream frequency.\n+\t* haifa-sched.c (sched_pressure_start_bb): Use to_freuqency.\n+\t(init_before_recovery): Do not update frequency.\n+\t(sched_create_recovery_edges): Do not update frequency.\n+\t* hsa-gen.c (convert_switch_statements): Do not update frequency.\n+\t* ipa-cp.c (ipcp_propagate_stage): Update search for max_count.\n+\t(ipa_cp_c_finalize): Set max_count to uninitialized.\n+\t* ipa-fnsummary.c (get_minimal_bb): Use counts.\n+\t(param_change_prob): Use counts.\n+\t* ipa-profile.c (ipa_profile_generate_summary): Do not summarize\n+\tlocal profiles.\n+\t* ipa-split.c (consider_split): Use to_frequency.\n+\t(split_function): Use to_frequency.\n+\t* ira-build.c (loop_compare_func): Likewise.\n+\t(mark_loops_for_removal): Likewise.\n+\t(mark_all_loops_for_removal): Likewise.\n+\t* loop-doloop.c (doloop_modify): Do not update frequency.\n+\t* loop-unroll.c (unroll_loop_runtime_iterations): Do not update\n+\tfrequency.\n+\t* lto-streamer-in.c (input_function): Update count_max.\n+\t* omp-expand.c (expand_omp_taskreg): Update count_max.\n+\t* omp-simd-clone.c (simd_clone_adjust): Update profile.\n+\t* predict.c (maybe_hot_frequency_p): Use to_frequency.\n+\t(maybe_hot_count_p): Use ipa counts only.\n+\t(maybe_hot_bb_p): Simplify.\n+\t(maybe_hot_edge_p): Simplify.\n+\t(probably_never_executed): Do not take frequency argument.\n+\t(probably_never_executed_bb_p): Do not pass frequency.\n+\t(probably_never_executed_edge_p): Likewise.\n+\t(combine_predictions_for_bb): Check that profile is nonzero.\n+\t(propagate_freq): Do not set frequency.\n+\t(drop_profile): Simplify.\n+\t(counts_to_freqs): Simplify.\n+\t(expensive_function_p): Use to_frequency.\n+\t(propagate_unlikely_bbs_forward): Simplify.\n+\t(determine_unlikely_bbs): Simplify.\n+\t(estimate_bb_frequencies): Add hack to silence graphite issues.\n+\t(compute_function_frequency): Use ipa counts.\n+\t(pass_profile::execute): Update.\n+\t(rebuild_frequencies): Use counts only.\n+\t(force_edge_cold): Use counts only.\n+\t* profile-count.c (profile_count::dump): Dump new count types.\n+\t(profile_count::differs_from_p): Check compatiblity.\n+\t(profile_count::to_frequency): New function.\n+\t(profile_count::to_cgraph_frequency): New function.\n+\t* profile-count.h (struct function): Declare.\n+\t(enum profile_quality): Add profile_guessed_local and\n+\tprofile_guessed_global0.\n+\t(class profile_proability): Decrease number of bits to 29;\n+\tupdate from_reg_br_prob_note and to_reg_br_prob_note.\n+\t(class profile_count: Update comment; decrease number of bits\n+\tto 61. Check compatibility.\n+\t(profile_count::compatible_p): New private member function.\n+\t(profile_count::ipa_p): New member function.\n+\t(profile_count::operator<): Handle global zero correctly.\n+\t(profile_count::operator>): Handle global zero correctly.\n+\t(profile_count::operator<=): Handle global zero correctly.\n+\t(profile_count::operator>=): Handle global zero correctly.\n+\t(profile_count::nonzero_p): New member function.\n+\t(profile_count::force_nonzero): New member function.\n+\t(profile_count::max): New member function.\n+\t(profile_count::apply_scale): Handle IPA scalling.\n+\t(profile_count::guessed_local): New member function.\n+\t(profile_count::global0): New member function.\n+\t(profile_count::ipa): New member function.\n+\t(profile_count::to_frequency): Declare.\n+\t(profile_count::to_cgraph_frequency): Declare.\n+\t* profile.c (OVERLAP_BASE): Delete.\n+\t(compute_frequency_overlap): Delete.\n+\t(compute_branch_probabilities): Do not use compute_frequency_overlap.\n+\t* regs.h (REG_FREQ_FROM_BB): Use to_frequency.\n+\t* sched-ebb.c (rank): Use counts only.\n+\t* shrink-wrap.c (handle_simple_exit): Use counts only.\n+\t(try_shrink_wrapping): Use counts only.\n+\t(place_prologue_for_one_component): Use counts only.\n+\t* tracer.c (find_best_predecessor): Use to_frequency.\n+\t(find_trace): Use to_frequency.\n+\t(tail_duplicate): Use to_frequency.\n+\t* trans-mem.c (expand_transaction): Do not update frequency.\n+\t* tree-call-cdce.c: Do not update frequency. \n+\t* tree-cfg.c (gimple_find_sub_bbs): Likewise.\n+\t(gimple_merge_blocks): Likewise.\n+\t(gimple_split_edge): Likewise.\n+\t(gimple_duplicate_sese_region): Likewise.\n+\t(gimple_duplicate_sese_tail): Likewise.\n+\t(move_sese_region_to_fn): Likewise.\n+\t(gimple_account_profile_record): Likewise.\n+\t(insert_cond_bb): Likewise.\n+\t* tree-complex.c (expand_complex_div_wide): Likewise.\n+\t* tree-eh.c (lower_resx): Update profile.\n+\t* tree-inline.c (copy_bb): Simplify count scaling; do not scale\n+\tfrequencies.\n+\t(initialize_cfun): Do not initialize frequencies\n+\t(freqs_to_counts): Delete.\n+\t(copy_cfg_body): Ignore count parameter.\n+\t(copy_body): Update.\n+\t(expand_call_inline): Update count_max.\n+\t(optimize_inline_calls): Update count_max.\n+\t(tree_function_versioning): Update count_max.\n+\t* tree-ssa-coalesce.c (coalesce_cost_bb): Use to_frequency.\n+\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Do not update\n+\tfrequency.\n+\t* tree-ssa-loop-im.c (execute_sm_if_changed): Use counts only.\n+\t* tree-ssa-loop-ivcanon.c (unloop_loops): Do not update freuqency.\n+\t(try_peel_loop): Likewise.\n+\t* tree-ssa-loop-ivopts.c (get_scaled_computation_cost_at): Use\n+\tto_frequency.\n+\t* tree-ssa-loop-manip.c (niter_for_unrolled_loop): Pass -1.\n+\t(tree_transform_and_unroll_loop): Do not use frequencies\n+\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations):\n+\tUse reliable prediction only.\n+\t* tree-ssa-loop-unswitch.c (hoist_guard): Do not use frequencies.\n+\t* tree-ssa-sink.c (select_best_block): Use to_frequency.\n+\t* tree-ssa-tail-merge.c (replace_block_by): Temporarily disable\n+\tprobability scaling.\n+\t* tree-ssa-threadupdate.c (create_block_for_threading): Do\n+\tnot update frequency\n+\t(any_remaining_duplicated_blocks): Likewise.\n+\t(update_profile): Likewise.\n+\t(estimated_freqs_path): Delete.\n+\t(freqs_to_counts_path): Delete.\n+\t(clear_counts_path): Delete.\n+\t(ssa_fix_duplicate_block_edges): Likewise.\n+\t(duplicate_thread_path): Likewise.\n+\t* tree-switch-conversion.c (gen_inbound_check): Use counts.\n+\t* tree-tailcall.c (decrease_profile): Do not update frequency.\n+\t(eliminate_tail_call): Likewise.\n+\t* tree-vect-loop-manip.c (vect_do_peeling): Likewise.\n+\t* tree-vect-loop.c (scale_profile_for_vect_loop): Likewise.\n+\t(optimize_mask_stores): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Likewise.\n+\t* ubsan.c (ubsan_expand_null_ifn): Update profile.\n+\t(ubsan_expand_ptr_ifn): Update profile.\n+\t* value-prof.c (gimple_ic): Simplify.\n+\t* value-prof.h (gimple_ic): Update prototype.\n+\t* ipa-inline-transform.c (inline_transform): Fix scaling conditoins.\n+\t* ipa-inline.c (compute_uninlined_call_time): Be sure that\n+\tcounts are nonzero.\n+\t(want_inline_self_recursive_call_p): Likewise.\n+\t(resolve_noninline_speculation): Only cummulate defined counts.\n+\t(inline_small_functions): Use nonzero_p.\n+\t(ipa_inline): Do not access freed node.\n+\n 2017-11-03  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_override_options_internal):"}, {"sha": "cd1a5617a9859b11ced1099229ea442783fb26b5", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1801,6 +1801,7 @@ create_cond_insert_point (gimple_stmt_iterator *iter,\n     ? profile_probability::very_unlikely ()\n     : profile_probability::very_likely ();\n   e->probability = fallthrough_probability.invert ();\n+  then_bb->count = e->count ();\n   if (create_then_fallthru_edge)\n     make_single_succ_edge (then_bb, fallthru_bb, EDGE_FALLTHRU);\n "}, {"sha": "5a5ddbfcb6ddcaf0fd3b05a615326e817871ccd4", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -148,9 +148,6 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n \n-  /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n-  int frequency;\n-\n   /* The discriminator for this block.  The discriminator distinguishes\n      among several basic blocks that share a common locus, allowing for\n      more accurate sample-based profiling.  */\n@@ -301,7 +298,7 @@ enum cfg_bb_flags\n \t\t\t\t\t ? EDGE_SUCC ((bb), 1) : EDGE_SUCC ((bb), 0))\n \n /* Return expected execution frequency of the edge E.  */\n-#define EDGE_FREQUENCY(e)\t\te->probability.apply (e->src->frequency)\n+#define EDGE_FREQUENCY(e)\t\te->count ().to_frequency (cfun)\n \n /* Compute a scale factor (or probability) suitable for scaling of\n    gcov_type values via apply_probability() and apply_scale().  */"}, {"sha": "f7c1f4c971e0478dbdd00a9ec6dbfd0a977ef8d9", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -256,8 +256,8 @@ push_to_next_round_p (const_basic_block bb, int round, int number_of_rounds,\n \n   there_exists_another_round = round < number_of_rounds - 1;\n \n-  block_not_hot_enough = (bb->frequency < exec_th\n-\t\t\t  || bb->count < count_th\n+  block_not_hot_enough = (bb->count.to_frequency (cfun) < exec_th\n+\t\t\t  || bb->count.ipa () < count_th\n \t\t\t  || probably_never_executed_bb_p (cfun, bb));\n \n   if (there_exists_another_round\n@@ -293,9 +293,9 @@ find_traces (int *n_traces, struct trace *traces)\n     {\n       bbd[e->dest->index].heap = heap;\n       bbd[e->dest->index].node = heap->insert (bb_to_key (e->dest), e->dest);\n-      if (e->dest->frequency > max_entry_frequency)\n-\tmax_entry_frequency = e->dest->frequency;\n-      if (e->dest->count.initialized_p () && e->dest->count > max_entry_count)\n+      if (e->dest->count.to_frequency (cfun) > max_entry_frequency)\n+\tmax_entry_frequency = e->dest->count.to_frequency (cfun);\n+      if (e->dest->count.ipa_p () && e->dest->count > max_entry_count)\n \tmax_entry_count = e->dest->count;\n     }\n \n@@ -329,8 +329,10 @@ find_traces (int *n_traces, struct trace *traces)\n \t  for (bb = traces[i].first;\n \t       bb != traces[i].last;\n \t       bb = (basic_block) bb->aux)\n-\t    fprintf (dump_file, \"%d [%d] \", bb->index, bb->frequency);\n-\t  fprintf (dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n+\t    fprintf (dump_file, \"%d [%d] \", bb->index,\n+\t\t     bb->count.to_frequency (cfun));\n+\t  fprintf (dump_file, \"%d [%d]\\n\", bb->index,\n+\t\t   bb->count.to_frequency (cfun));\n \t}\n       fflush (dump_file);\n     }\n@@ -551,7 +553,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\tcontinue;\n \n \t      prob = e->probability;\n-\t      freq = e->dest->frequency;\n+\t      freq = e->dest->count.to_frequency (cfun);\n \n \t      /* The only sensible preference for a call instruction is the\n \t\t fallthru edge.  Don't bother selecting anything else.  */\n@@ -573,7 +575,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  || !prob.initialized_p ()\n \t\t  || ((prob.to_reg_br_prob_base () < branch_th\n \t\t       || EDGE_FREQUENCY (e) < exec_th\n-\t\t      || e->count () < count_th) && (!for_size)))\n+\t\t      || e->count ().ipa () < count_th) && (!for_size)))\n \t\tcontinue;\n \n \t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq,\n@@ -671,7 +673,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t      || !prob.initialized_p ()\n \t\t      || prob.to_reg_br_prob_base () < branch_th\n \t\t      || freq < exec_th\n-\t\t      || e->count () < count_th)\n+\t\t      || e->count ().ipa () < count_th)\n \t\t    {\n \t\t      /* When partitioning hot/cold basic blocks, make sure\n \t\t\t the cold blocks (and only the cold blocks) all get\n@@ -706,7 +708,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  if (best_edge->dest != bb)\n \t\t    {\n \t\t      if (EDGE_FREQUENCY (best_edge)\n-\t\t\t  > 4 * best_edge->dest->frequency / 5)\n+\t\t\t  > 4 * best_edge->dest->count.to_frequency (cfun) / 5)\n \t\t\t{\n \t\t\t  /* The loop has at least 4 iterations.  If the loop\n \t\t\t     header is not the first block of the function\n@@ -783,8 +785,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t    & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(single_succ_edge (e->dest)->flags & EDGE_COMPLEX)\n \t\t\t&& single_succ (e->dest) == best_edge->dest\n-\t\t\t&& (2 * e->dest->frequency >= EDGE_FREQUENCY (best_edge)\n-\t\t\t    || for_size))\n+\t\t\t&& (2 * e->dest->count.to_frequency (cfun)\n+\t\t\t    >= EDGE_FREQUENCY (best_edge) || for_size))\n \t\t      {\n \t\t\tbest_edge = e;\n \t\t\tif (dump_file)\n@@ -945,9 +947,9 @@ bb_to_key (basic_block bb)\n \n   if (priority)\n     /* The block with priority should have significantly lower key.  */\n-    return -(100 * BB_FREQ_MAX + 100 * priority + bb->frequency);\n+    return -(100 * BB_FREQ_MAX + 100 * priority + bb->count.to_frequency (cfun));\n \n-  return -bb->frequency;\n+  return -bb->count.to_frequency (cfun);\n }\n \n /* Return true when the edge E from basic block BB is better than the temporary\n@@ -1290,7 +1292,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t\t&& !connected[bbd[di].start_of_trace]\n \t\t\t\t&& BB_PARTITION (e2->dest) == current_partition\n \t\t\t\t&& EDGE_FREQUENCY (e2) >= freq_threshold\n-\t\t\t\t&& e2->count () >= count_threshold\n+\t\t\t\t&& e2->count ().ipa () >= count_threshold\n \t\t\t\t&& (!best2\n \t\t\t\t    || e2->probability > best2->probability\n \t\t\t\t    || (e2->probability == best2->probability\n@@ -1317,7 +1319,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t\toptimize_edge_for_speed_p (best)\n \t\t\t\t&& EDGE_FREQUENCY (best) >= freq_threshold\n \t\t\t\t&& (!best->count ().initialized_p ()\n-\t\t\t\t    || best->count () >= count_threshold)))\n+\t\t\t\t    || best->count ().ipa () >= count_threshold)))\n \t\t{\n \t\t  basic_block new_bb;\n \n@@ -1375,7 +1377,7 @@ copy_bb_p (const_basic_block bb, int code_may_grow)\n   int max_size = uncond_jump_length;\n   rtx_insn *insn;\n \n-  if (!bb->frequency)\n+  if (!bb->count.to_frequency (cfun))\n     return false;\n   if (EDGE_COUNT (bb->preds) < 2)\n     return false;\n@@ -1459,7 +1461,6 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n   last_bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n   new_bb = create_basic_block (new_label, jump, last_bb);\n   new_bb->aux = last_bb->aux;\n-  new_bb->frequency = post_bb->frequency;\n   new_bb->count = post_bb->count;\n   last_bb->aux = new_bb;\n \n@@ -1517,7 +1518,6 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n       edge_iterator ei;\n       profile_probability highest_probability\n \t\t\t\t = profile_probability::uninitialized ();\n-      int highest_freq = 0;\n       profile_count highest_count = profile_count::uninitialized ();\n       bool found = false;\n \n@@ -1544,11 +1544,8 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n           /* The following loop will look for the hottest edge via\n              the edge count, if it is non-zero, then fallback to the edge\n              frequency and finally the edge probability.  */\n-          if (!highest_count.initialized_p () || e->count () > highest_count)\n+          if (!(e->count () > highest_count))\n             highest_count = e->count ();\n-          int edge_freq = EDGE_FREQUENCY (e);\n-          if (edge_freq > highest_freq)\n-            highest_freq = edge_freq;\n           if (!highest_probability.initialized_p ()\n \t      || e->probability > highest_probability)\n             highest_probability = e->probability;\n@@ -1573,17 +1570,12 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n           /* Select the hottest edge using the edge count, if it is non-zero,\n              then fallback to the edge frequency and finally the edge\n              probability.  */\n-          if (highest_count > 0)\n+          if (highest_count.initialized_p ())\n             {\n-              if (e->count () < highest_count)\n+              if (!(e->count () >= highest_count))\n                 continue;\n             }\n-          else if (highest_freq)\n-            {\n-              if (EDGE_FREQUENCY (e) < highest_freq)\n-                continue;\n-            }\n-          else if (e->probability < highest_probability)\n+          else if (!(e->probability >= highest_probability))\n             continue;\n \n           basic_block reach_bb = walk_up ? e->src : e->dest;"}, {"sha": "90922082e7b4963067f929d18afbfb44220869c7", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -185,7 +185,7 @@ static int first_btr, last_btr;\n static int\n basic_block_freq (const_basic_block bb)\n {\n-  return bb->frequency;\n+  return bb->count.to_frequency (cfun);\n }\n \n /* If the rtx at *XP references (sets or reads) any branch target"}, {"sha": "062788afdc0378a49a326baa0972cd32f7c5dce1", "filename": "gcc/cfg.c", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -68,6 +68,7 @@ init_flow (struct function *the_fun)\n   if (!the_fun->cfg)\n     the_fun->cfg = ggc_cleared_alloc<control_flow_graph> ();\n   n_edges_for_fn (the_fun) = 0;\n+  the_fun->cfg->count_max = profile_count::uninitialized ();\n   ENTRY_BLOCK_PTR_FOR_FN (the_fun)\n     = alloc_block ();\n   ENTRY_BLOCK_PTR_FOR_FN (the_fun)->index = ENTRY_BLOCK;\n@@ -447,13 +448,18 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n     }\n   if (bb != ENTRY_BLOCK_PTR_FOR_FN (fun))\n     {\n-      int sum = 0;\n+      profile_count sum = profile_count::zero ();\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tsum += EDGE_FREQUENCY (e);\n-      if (abs (sum - bb->frequency) > 100)\n-\tfprintf (file,\n-\t\t \";; %sInvalid sum of incoming frequencies %i, should be %i\\n\",\n-\t\t s_indent, sum, bb->frequency);\n+\tsum += e->count ();\n+      if (sum.differs_from_p (bb->count))\n+\t{\n+\t  fprintf (file, \";; %sInvalid sum of incoming counts \",\n+\t\t   s_indent);\n+\t  sum.dump (file);\n+\t  fprintf (file, \", should be \");\n+\t  bb->count.dump (file);\n+\t  fprintf (file, \"\\n\");\n+\t}\n     }\n   if (BB_PARTITION (bb) == BB_COLD_PARTITION)\n     {\n@@ -751,7 +757,6 @@ dump_bb_info (FILE *outf, basic_block bb, int indent, dump_flags_t flags,\n \t      fputs (\", count \", outf);\n \t      bb->count.dump (outf);\n \t    }\n-\t  fprintf (outf, \", freq %i\", bb->frequency);\n \t  if (maybe_hot_bb_p (fun, bb))\n \t    fputs (\", maybe hot\", outf);\n \t  if (probably_never_executed_bb_p (fun, bb))\n@@ -843,15 +848,15 @@ brief_dump_cfg (FILE *file, dump_flags_t flags)\n     }\n }\n \n-/* An edge originally destinating BB of FREQUENCY and COUNT has been proved to\n+/* An edge originally destinating BB of COUNT has been proved to\n    leave the block by TAKEN_EDGE.  Update profile of BB such that edge E can be\n    redirected to destination of TAKEN_EDGE.\n \n    This function may leave the profile inconsistent in the case TAKEN_EDGE\n-   frequency or count is believed to be lower than FREQUENCY or COUNT\n+   frequency or count is believed to be lower than COUNT\n    respectively.  */\n void\n-update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n+update_bb_profile_for_threading (basic_block bb, \n \t\t\t\t profile_count count, edge taken_edge)\n {\n   edge c;\n@@ -866,16 +871,10 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n     }\n   bb->count -= count;\n \n-  bb->frequency -= edge_frequency;\n-  if (bb->frequency < 0)\n-    bb->frequency = 0;\n-\n   /* Compute the probability of TAKEN_EDGE being reached via threaded edge.\n      Watch for overflows.  */\n-  if (bb->frequency)\n-    /* FIXME: We should get edge frequency as count.  */\n-    prob = profile_probability::probability_in_gcov_type\n-\t\t (edge_frequency, bb->frequency);\n+  if (bb->count.nonzero_p ())\n+    prob = count.probability_in (bb->count);\n   else\n     prob = profile_probability::never ();\n   if (prob > taken_edge->probability)\n@@ -899,9 +898,9 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n   if (prob == profile_probability::never ())\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Edge frequencies of bb %i has been reset, \"\n-\t\t \"frequency of block should end up being 0, it is %i\\n\",\n-\t\t bb->index, bb->frequency);\n+\tfprintf (dump_file, \"Edge probabilities of bb %i has been reset, \"\n+\t\t \"count of block should end up being 0, it is non-zero\\n\",\n+\t\t bb->index);\n       EDGE_SUCC (bb, 0)->probability = profile_probability::guessed_always ();\n       ei = ei_start (bb->succs);\n       ei_next (&ei);\n@@ -942,18 +941,10 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n \n   for (i = 0; i < nbbs; i++)\n     {\n-      bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n-      /* Make sure the frequencies do not grow over BB_FREQ_MAX.  */\n-      if (bbs[i]->frequency > BB_FREQ_MAX)\n-\tbbs[i]->frequency = BB_FREQ_MAX;\n       bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n     }\n }\n \n-/* numbers smaller than this value are safe to multiply without getting\n-   64bit overflow.  */\n-#define MAX_SAFE_MULTIPLIER (1 << (sizeof (int64_t) * 4 - 1))\n-\n /* Multiply all frequencies of basic blocks in array BBS of length NBBS\n    by NUM/DEN, in gcov_type arithmetic.  More accurate than previous\n    function but considerably slower.  */\n@@ -962,28 +953,9 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n \t\t\t\t gcov_type den)\n {\n   int i;\n-  gcov_type fraction = RDIV (num * 65536, den);\n-\n-  gcc_assert (fraction >= 0);\n \n-  if (num < MAX_SAFE_MULTIPLIER)\n-    for (i = 0; i < nbbs; i++)\n-      {\n-\tbbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n-\tif (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n-\t  bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n-\telse\n-\t  bbs[i]->count = bbs[i]->count.apply_scale (fraction, 65536);\n-      }\n-   else\n-    for (i = 0; i < nbbs; i++)\n-      {\n-\tif (sizeof (gcov_type) > sizeof (int))\n-\t  bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n-\telse\n-\t  bbs[i]->frequency = RDIV (bbs[i]->frequency * fraction, 65536);\n-\tbbs[i]->count = bbs[i]->count.apply_scale (fraction, 65536);\n-      }\n+  for (i = 0; i < nbbs; i++)\n+    bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n }\n \n /* Multiply all frequencies of basic blocks in array BBS of length NBBS\n@@ -994,13 +966,9 @@ scale_bbs_frequencies_profile_count (basic_block *bbs, int nbbs,\n \t\t\t\t     profile_count num, profile_count den)\n {\n   int i;\n-\n-  for (i = 0; i < nbbs; i++)\n-    {\n-      bbs[i]->frequency = RDIV (bbs[i]->frequency * num.to_gcov_type (),\n-\t\t\t\tden.to_gcov_type ());\n+  if (num == profile_count::zero () || den.nonzero_p ())\n+    for (i = 0; i < nbbs; i++)\n       bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n-    }\n }\n \n /* Multiply all frequencies of basic blocks in array BBS of length NBBS\n@@ -1013,10 +981,7 @@ scale_bbs_frequencies (basic_block *bbs, int nbbs,\n   int i;\n \n   for (i = 0; i < nbbs; i++)\n-    {\n-      bbs[i]->frequency = p.apply (bbs[i]->frequency);\n-      bbs[i]->count = bbs[i]->count.apply_probability (p);\n-    }\n+    bbs[i]->count = bbs[i]->count.apply_probability (p);\n }\n \n /* Helper types for hash tables.  */"}, {"sha": "e8129ddb1901c0d27ba79124157bb84fc4dbfc5c", "filename": "gcc/cfg.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.h?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -71,6 +71,9 @@ struct GTY(()) control_flow_graph {\n   /* Maximal number of entities in the single jumptable.  Used to estimate\n      final flowgraph size.  */\n   int max_jumptable_ents;\n+\n+  /* Maximal count of BB in function.  */\n+  profile_count count_max;\n };\n \n \n@@ -103,7 +106,7 @@ extern void debug_bb (basic_block);\n extern basic_block debug_bb_n (int);\n extern void dump_bb_info (FILE *, basic_block, int, dump_flags_t, bool, bool);\n extern void brief_dump_cfg (FILE *, dump_flags_t);\n-extern void update_bb_profile_for_threading (basic_block, int, profile_count, edge);\n+extern void update_bb_profile_for_threading (basic_block, profile_count, edge);\n extern void scale_bbs_frequencies_int (basic_block *, int, int, int);\n extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n \t\t\t\t\t     gcov_type);"}, {"sha": "a0926752143d5f939546b4b222e6ba54068a1ff2", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -499,7 +499,6 @@ find_bb_boundaries (basic_block bb)\n \t  remove_edge (fallthru);\n \t  /* BB is unreachable at this point - we need to determine its profile\n \t     once edges are built.  */\n-\t  bb->frequency = 0;\n \t  bb->count = profile_count::uninitialized ();\n \t  flow_transfer_insn = NULL;\n \t  debug_insn = NULL;\n@@ -669,7 +668,6 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t  {\n \t    bool initialized_src = false, uninitialized_src = false;\n \t    bb->count = profile_count::zero ();\n-\t    bb->frequency = 0;\n \t    FOR_EACH_EDGE (e, ei, bb->preds)\n \t      {\n \t\tif (e->count ().initialized_p ())\n@@ -679,8 +677,6 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t\t  }\n \t\telse\n \t\t  uninitialized_src = true;\n-\t\tif (e->probability.initialized_p ())\n-\t\t  bb->frequency += EDGE_FREQUENCY (e);\n \t      }\n \t    /* When some edges are missing with read profile, this is\n \t       most likely because RTL expansion introduced loop.\n@@ -692,7 +688,7 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t       precisely once.  */\n \t    if (!initialized_src\n \t\t|| (uninitialized_src\n-\t\t     && profile_status_for_fn (cfun) != PROFILE_READ))\n+\t\t     && profile_status_for_fn (cfun) < PROFILE_GUESSED))\n \t      bb->count = profile_count::uninitialized ();\n \t  }\n  \t/* If nothing changed, there is no need to create new BBs.  */"}, {"sha": "4734d3eae17e63f5f24fb9d6b930e5aaaa3b15bc", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -559,8 +559,6 @@ try_forward_edges (int mode, basic_block b)\n \t{\n \t  /* Save the values now, as the edge may get removed.  */\n \t  profile_count edge_count = e->count ();\n-\t  profile_probability edge_probability = e->probability;\n-\t  int edge_frequency;\n \t  int n = 0;\n \n \t  e->goto_locus = goto_locus;\n@@ -585,8 +583,6 @@ try_forward_edges (int mode, basic_block b)\n \t  /* We successfully forwarded the edge.  Now update profile\n \t     data: for each edge we traversed in the chain, remove\n \t     the original edge's execution count.  */\n-\t  edge_frequency = edge_probability.apply (b->frequency);\n-\n \t  do\n \t    {\n \t      edge t;\n@@ -596,16 +592,12 @@ try_forward_edges (int mode, basic_block b)\n \t\t  gcc_assert (n < nthreaded_edges);\n \t\t  t = threaded_edges [n++];\n \t\t  gcc_assert (t->src == first);\n-\t\t  update_bb_profile_for_threading (first, edge_frequency,\n-\t\t\t\t\t\t   edge_count, t);\n+\t\t  update_bb_profile_for_threading (first, edge_count, t);\n \t\t  update_br_prob_note (first);\n \t\t}\n \t      else\n \t\t{\n \t\t  first->count -= edge_count;\n-\t\t  first->frequency -= edge_frequency;\n-\t\t  if (first->frequency < 0)\n-\t\t    first->frequency = 0;\n \t\t  /* It is possible that as the result of\n \t\t     threading we've removed edge as it is\n \t\t     threaded to the fallthru edge.  Avoid\n@@ -2109,7 +2101,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n   else\n     redirect_edges_to = osrc2;\n \n-  /* Recompute the frequencies and counts of outgoing edges.  */\n+  /* Recompute the counts of destinations of outgoing edges.  */\n   FOR_EACH_EDGE (s, ei, redirect_edges_to->succs)\n     {\n       edge s2;\n@@ -2132,34 +2124,26 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \t that there is no more than one in the chain, so we can't run\n \t into infinite loop.  */\n       if (FORWARDER_BLOCK_P (s->dest))\n-\t{\n-\t  s->dest->frequency += EDGE_FREQUENCY (s);\n-\t}\n+\ts->dest->count += s->count ();\n \n       if (FORWARDER_BLOCK_P (s2->dest))\n-\t{\n-\t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n-\t  if (s2->dest->frequency < 0)\n-\t    s2->dest->frequency = 0;\n-\t}\n+\ts2->dest->count -= s->count ();\n \n-      if (!redirect_edges_to->frequency && !src1->frequency)\n+      /* FIXME: Is this correct? Should be rewritten to count API.  */\n+      if (redirect_edges_to->count.nonzero_p () && src1->count.nonzero_p ())\n \ts->probability = s->probability.combine_with_freq\n-\t\t\t   (redirect_edges_to->frequency,\n-\t\t\t    s2->probability, src1->frequency);\n+\t\t\t   (redirect_edges_to->count.to_frequency (cfun),\n+\t\t\t    s2->probability, src1->count.to_frequency (cfun));\n     }\n \n-  /* Adjust count and frequency for the block.  An earlier jump\n+  /* Adjust count for the block.  An earlier jump\n      threading pass may have left the profile in an inconsistent\n      state (see update_bb_profile_for_threading) so we must be\n      prepared for overflows.  */\n   tmp = redirect_to;\n   do\n     {\n       tmp->count += src1->count;\n-      tmp->frequency += src1->frequency;\n-      if (tmp->frequency > BB_FREQ_MAX)\n-        tmp->frequency = BB_FREQ_MAX;\n       if (tmp == redirect_edges_to)\n         break;\n       tmp = find_fallthru_edge (tmp->succs)->dest;"}, {"sha": "ca5d8dbdfd68619d997f4eecaa026173361a5975", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -2516,7 +2516,6 @@ expand_gimple_cond (basic_block bb, gcond *stmt)\n   redirect_edge_succ (false_edge, new_bb);\n   false_edge->flags |= EDGE_FALLTHRU;\n   new_bb->count = false_edge->count ();\n-  new_bb->frequency = EDGE_FREQUENCY (false_edge);\n   loop_p loop = find_common_loop (bb->loop_father, dest->loop_father);\n   add_bb_to_loop (new_bb, loop);\n   if (loop->latch == bb\n@@ -3847,11 +3846,7 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n       if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n \t{\n \t  if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t    {\n-\t      e->dest->frequency -= EDGE_FREQUENCY (e);\n-\t      if (e->dest->frequency < 0)\n-\t\te->dest->frequency = 0;\n-\t    }\n+\t    e->dest->count -= e->count ();\n \t  probability += e->probability;\n \t  remove_edge (e);\n \t}\n@@ -5860,7 +5855,6 @@ construct_init_block (void)\n   init_block = create_basic_block (NEXT_INSN (get_insns ()),\n \t\t\t\t   get_last_insn (),\n \t\t\t\t   ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  init_block->frequency = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n   init_block->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n   add_bb_to_loop (init_block, ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n   if (e)\n@@ -5924,7 +5918,7 @@ construct_exit_block (void)\n   while (NEXT_INSN (head) && NOTE_P (NEXT_INSN (head)))\n     head = NEXT_INSN (head);\n   /* But make sure exit_block starts with RETURN_LABEL, otherwise the\n-     bb frequency counting will be confused.  Any instructions before that\n+     bb count counting will be confused.  Any instructions before that\n      label are emitted for the case where PREV_BB falls through into the\n      exit block, so append those instructions to prev_bb in that case.  */\n   if (NEXT_INSN (head) != return_label)\n@@ -5937,7 +5931,6 @@ construct_exit_block (void)\n \t}\n     }\n   exit_block = create_basic_block (NEXT_INSN (head), end, prev_bb);\n-  exit_block->frequency = EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency;\n   exit_block->count = EXIT_BLOCK_PTR_FOR_FN (cfun)->count;\n   add_bb_to_loop (exit_block, EXIT_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n \n@@ -5957,10 +5950,7 @@ construct_exit_block (void)\n     if (e2 != e)\n       {\n \texit_block->count -= e2->count ();\n-\texit_block->frequency -= EDGE_FREQUENCY (e2);\n       }\n-  if (exit_block->frequency < 0)\n-    exit_block->frequency = 0;\n   update_bb_for_insn (exit_block);\n }\n "}, {"sha": "4a224243e3200324549313c1513bbe27639ab942", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -146,10 +146,12 @@ verify_flow_info (void)\n \t  error (\"verify_flow_info: Wrong count of block %i\", bb->index);\n \t  err = 1;\n \t}\n-      if (bb->frequency < 0)\n+      /* FIXME: Graphite and SLJL and target code still tends to produce\n+\t edges with no probablity.  */\n+      if (profile_status_for_fn (cfun) >= PROFILE_GUESSED\n+          && !bb->count.initialized_p () && !flag_graphite && 0)\n \t{\n-\t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n-\t\t bb->index, bb->frequency);\n+\t  error (\"verify_flow_info: Missing count of block %i\", bb->index);\n \t  err = 1;\n \t}\n \n@@ -164,7 +166,7 @@ verify_flow_info (void)\n \t  /* FIXME: Graphite and SLJL and target code still tends to produce\n \t     edges with no probablity.  */\n \t  if (profile_status_for_fn (cfun) >= PROFILE_GUESSED\n-\t      && !e->probability.initialized_p () && 0)\n+\t      && !e->probability.initialized_p () && !flag_graphite && 0)\n \t    {\n \t      error (\"Uninitialized probability of edge %i->%i\", e->src->index,\n \t\t     e->dest->index);\n@@ -315,7 +317,6 @@ dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n   /* TODO: Add pretty printer for counter.  */\n   if (bb->count.initialized_p ())\n     pp_printf (pp, \"COUNT:\" \"%\" PRId64, bb->count.to_gcov_type ());\n-  pp_printf (pp, \" FREQ:%i |\", bb->frequency);\n   pp_write_text_to_stream (pp);\n   if (!(dump_flags & TDF_SLIM))\n     cfg_hooks->dump_bb_for_graph (pp, bb);\n@@ -513,7 +514,6 @@ split_block_1 (basic_block bb, void *i)\n     return NULL;\n \n   new_bb->count = bb->count;\n-  new_bb->frequency = bb->frequency;\n   new_bb->discriminator = bb->discriminator;\n \n   if (dom_info_available_p (CDI_DOMINATORS))\n@@ -626,7 +626,6 @@ split_edge (edge e)\n {\n   basic_block ret;\n   profile_count count = e->count ();\n-  int freq = EDGE_FREQUENCY (e);\n   edge f;\n   bool irr = (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n   struct loop *loop;\n@@ -640,7 +639,6 @@ split_edge (edge e)\n \n   ret = cfg_hooks->split_edge (e);\n   ret->count = count;\n-  ret->frequency = freq;\n   single_succ_edge (ret)->probability = profile_probability::always ();\n \n   if (irr)\n@@ -869,7 +867,6 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   fallthru = split_block_after_labels (bb);\n   dummy = fallthru->src;\n   dummy->count = profile_count::zero ();\n-  dummy->frequency = 0;\n   bb = fallthru->dest;\n \n   /* Redirect back edges we want to keep.  */\n@@ -879,10 +876,6 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \n       if (redirect_edge_p (e))\n \t{\n-\t  dummy->frequency += EDGE_FREQUENCY (e);\n-\t  if (dummy->frequency > BB_FREQ_MAX)\n-\t    dummy->frequency = BB_FREQ_MAX;\n-\n \t  dummy->count += e->count ();\n \t  ei_next (&ei);\n \t  continue;\n@@ -1101,19 +1094,10 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n       new_bb->count = new_count;\n       bb->count -= new_count;\n \n-      new_bb->frequency = EDGE_FREQUENCY (e);\n-      bb->frequency -= EDGE_FREQUENCY (e);\n-\n       redirect_edge_and_branch_force (e, new_bb);\n-\n-      if (bb->frequency < 0)\n-\tbb->frequency = 0;\n     }\n   else\n-    {\n-      new_bb->count = bb->count;\n-      new_bb->frequency = bb->frequency;\n-    }\n+    new_bb->count = bb->count;\n \n   set_bb_original (new_bb, bb);\n   set_bb_copy (bb, new_bb);\n@@ -1463,13 +1447,6 @@ account_profile_record (struct profile_record *record, int after_pass)\n       if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status_for_fn (cfun) != PROFILE_ABSENT)\n \t{\n-\t  int sum = 0;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    sum += EDGE_FREQUENCY (e);\n-\t  if (abs (sum - bb->frequency) > 100\n-\t      || (MAX (sum, bb->frequency) > 10\n-\t\t  && abs ((sum - bb->frequency) * 100 / (MAX (sum, bb->frequency) + 1)) > 10))\n-\t    record->num_mismatched_freq_in[after_pass]++;\n \t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    lsum += e->count ();"}, {"sha": "d82da97d7afa0cfe7149e20d08a808b22124e706", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -607,7 +607,7 @@ find_subloop_latch_edge_by_profile (vec<edge> latches)\n       tcount += e->count();\n     }\n \n-  if (!tcount.initialized_p () || tcount < HEAVY_EDGE_MIN_SAMPLES\n+  if (!tcount.initialized_p () || !(tcount.ipa () > HEAVY_EDGE_MIN_SAMPLES)\n       || (tcount - mcount).apply_scale (HEAVY_EDGE_RATIO, 1) > tcount)\n     return NULL;\n "}, {"sha": "78a3c9387aafdca121fd585f825271075e99de31", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -213,9 +213,10 @@ average_num_loop_insns (const struct loop *loop)\n \tif (NONDEBUG_INSN_P (insn))\n \t  binsns++;\n \n-      ratio = loop->header->frequency == 0\n+      ratio = loop->header->count.to_frequency (cfun) == 0\n \t      ? BB_FREQ_MAX\n-\t      : (bb->frequency * BB_FREQ_MAX) / loop->header->frequency;\n+\t      : (bb->count.to_frequency (cfun) * BB_FREQ_MAX)\n+\t\t / loop->header->count.to_frequency (cfun);\n       ninsns += binsns * ratio;\n     }\n   free (bbs);\n@@ -245,8 +246,8 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n   /* If we have no profile at all, use AVG_LOOP_NITER.  */\n   if (profile_status_for_fn (cfun) == PROFILE_ABSENT)\n     expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n-  else if (loop->latch && (loop->latch->count.reliable_p ()\n-\t\t\t   || loop->header->count.reliable_p ()))\n+  else if (loop->latch && (loop->latch->count.initialized_p ()\n+\t\t\t   || loop->header->count.initialized_p ()))\n     {\n       profile_count count_in = profile_count::zero (),\n \t\t    count_latch = profile_count::zero ();\n@@ -258,45 +259,25 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n \t  count_in += e->count ();\n \n       if (!count_latch.initialized_p ())\n-\t;\n-      else if (!(count_in > profile_count::zero ()))\n+\texpected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+      else if (!count_in.nonzero_p ())\n \texpected = count_latch.to_gcov_type () * 2;\n       else\n \t{\n \t  expected = (count_latch.to_gcov_type () + count_in.to_gcov_type ()\n \t\t      - 1) / count_in.to_gcov_type ();\n-\t  if (read_profile_p)\n+\t  if (read_profile_p\n+\t      && count_latch.reliable_p () && count_in.reliable_p ())\n \t    *read_profile_p = true;\n \t}\n     }\n-  if (expected == -1)\n-    {\n-      int freq_in, freq_latch;\n-\n-      freq_in = 0;\n-      freq_latch = 0;\n-\n-      FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\tif (flow_bb_inside_loop_p (loop, e->src))\n-\t  freq_latch += EDGE_FREQUENCY (e);\n-\telse\n-\t  freq_in += EDGE_FREQUENCY (e);\n-\n-      if (freq_in == 0)\n-\t{\n-\t  /* If we have no profile at all, use AVG_LOOP_NITER iterations.  */\n-\t  if (!freq_latch)\n-\t    expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n-\t  else\n-\t    expected = freq_latch * 2;\n-\t}\n-      else\n-        expected = (freq_latch + freq_in - 1) / freq_in;\n-    }\n+  else\n+    expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n \n   HOST_WIDE_INT max = get_max_loop_iterations_int (loop);\n   if (max != -1 && max < expected)\n     return max;\n+ \n   return expected;\n }\n "}, {"sha": "1f55137ed975d7bcaa865e8f530b78e24ad17e09", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -536,7 +536,6 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n       if (e)\n \t{\n \t  edge other_e;\n-\t  int freq_delta;\n \t  profile_count count_delta;\n \n           FOR_EACH_EDGE (other_e, ei, e->src->succs)\n@@ -545,23 +544,18 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n \t      break;\n \n \t  /* Probability of exit must be 1/iterations.  */\n-\t  freq_delta = EDGE_FREQUENCY (e);\n \t  count_delta = e->count ();\n \t  e->probability = profile_probability::always ()\n \t\t\t\t.apply_scale (1, iteration_bound);\n \t  other_e->probability = e->probability.invert ();\n-\t  freq_delta -= EDGE_FREQUENCY (e);\n \t  count_delta -= e->count ();\n \n-\t  /* If latch exists, change its frequency and count, since we changed\n+\t  /* If latch exists, change its count, since we changed\n \t     probability of exit.  Theoretically we should update everything from\n \t     source of exit edge to latch, but for vectorizer this is enough.  */\n \t  if (loop->latch\n \t      && loop->latch != e->src)\n \t    {\n-\t      loop->latch->frequency += freq_delta;\n-\t      if (loop->latch->frequency < 0)\n-\t\tloop->latch->frequency = 0;\n \t      loop->latch->count += count_delta;\n \t    }\n \t}\n@@ -571,7 +565,6 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n \t we look at the actual profile, if it is available.  */\n       p = p.apply_scale (iteration_bound, iterations);\n \n-      bool determined = false;\n       if (loop->header->count.initialized_p ())\n \t{\n \t  profile_count count_in = profile_count::zero ();\n@@ -584,21 +577,8 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n \t    {\n \t      p = count_in.probability_in (loop->header->count.apply_scale\n \t\t\t\t\t\t (iteration_bound, 1));\n-\t      determined = true;\n \t    }\n \t}\n-      if (!determined && loop->header->frequency)\n-\t{\n-\t  int freq_in = 0;\n-\n-\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\t    if (e->src != loop->latch)\n-\t      freq_in += EDGE_FREQUENCY (e);\n-\n-\t  if (freq_in != 0)\n-\t    p = profile_probability::probability_in_gcov_type\n-\t\t\t (freq_in * iteration_bound, loop->header->frequency);\n-\t}\n       if (!(p > profile_probability::never ()))\n \tp = profile_probability::very_unlikely ();\n     }\n@@ -800,7 +780,7 @@ create_empty_loop_on_edge (edge entry_edge,\n   loop->latch = loop_latch;\n   add_loop (loop, outer);\n \n-  /* TODO: Fix frequencies and counts.  */\n+  /* TODO: Fix counts.  */\n   scale_loop_frequencies (loop, profile_probability::even ());\n \n   /* Update dominators.  */\n@@ -866,13 +846,11 @@ loopify (edge latch_edge, edge header_edge,\n   basic_block pred_bb = header_edge->src;\n   struct loop *loop = alloc_loop ();\n   struct loop *outer = loop_outer (succ_bb->loop_father);\n-  int freq;\n   profile_count cnt;\n \n   loop->header = header_edge->dest;\n   loop->latch = latch_edge->src;\n \n-  freq = EDGE_FREQUENCY (header_edge);\n   cnt = header_edge->count ();\n \n   /* Redirect edges.  */\n@@ -901,10 +879,9 @@ loopify (edge latch_edge, edge header_edge,\n     remove_bb_from_loops (switch_bb);\n   add_bb_to_loop (switch_bb, outer);\n \n-  /* Fix frequencies.  */\n+  /* Fix counts.  */\n   if (redirect_all_edges)\n     {\n-      switch_bb->frequency = freq;\n       switch_bb->count = cnt;\n     }\n   scale_loop_frequencies (loop, false_scale);\n@@ -1167,7 +1144,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n     {\n       /* Calculate coefficients by that we have to scale frequencies\n \t of duplicated loop bodies.  */\n-      freq_in = header->frequency;\n+      freq_in = header->count.to_frequency (cfun);\n       freq_le = EDGE_FREQUENCY (latch_edge);\n       if (freq_in == 0)\n \tfreq_in = 1;"}, {"sha": "ae469088eecbcc46dcdd08055da10e5094a945ea", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1533,6 +1533,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \n \t  basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL,\n \t\t\t\t\t       ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\t  bb->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n \t  /* Change the existing edge's source to be the new block, and add\n \t     a new edge from the entry block to the new block.  */\n@@ -1628,7 +1629,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \n       jump_block = create_basic_block (new_head, NULL, e->src);\n       jump_block->count = count;\n-      jump_block->frequency = EDGE_FREQUENCY (e);\n \n       /* Make sure new block ends up in correct hot/cold section.  */\n \n@@ -1652,7 +1652,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t{\n \t  new_edge->probability = new_edge->probability.apply_scale (1, 2);\n \t  jump_block->count = jump_block->count.apply_scale (1, 2);\n-\t  jump_block->frequency /= 2;\n \t  edge new_edge2 = make_edge (new_edge->src, target,\n \t\t\t\t      e->flags & ~EDGE_FALLTHRU);\n \t  new_edge2->probability = probability - new_edge->probability;\n@@ -2245,9 +2244,23 @@ void\n update_br_prob_note (basic_block bb)\n {\n   rtx note;\n-  if (!JUMP_P (BB_END (bb)) || !BRANCH_EDGE (bb)->probability.initialized_p ())\n-    return;\n   note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n+  if (!JUMP_P (BB_END (bb)) || !BRANCH_EDGE (bb)->probability.initialized_p ())\n+    {\n+      if (note)\n+\t{\n+\t  rtx *note_link, this_rtx;\n+\n+\t  note_link = &REG_NOTES (BB_END (bb));\n+\t  for (this_rtx = *note_link; this_rtx; this_rtx = XEXP (this_rtx, 1))\n+\t    if (this_rtx == note)\n+\t      {\n+\t\t*note_link = XEXP (this_rtx, 1);\n+\t\tbreak;\n+\t      }\n+\t}\n+      return;\n+    }\n   if (!note\n       || XINT (note, 0) == BRANCH_EDGE (bb)->probability.to_reg_br_prob_note ())\n     return;\n@@ -3623,7 +3636,6 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n \t    fprintf (dump_file, \"compensation \");\n \t  else\n \t    fprintf (dump_file, \"bb %i \", bb->index);\n-\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n \t}\n     }\n \n@@ -5034,7 +5046,7 @@ rtl_account_profile_record (basic_block bb, int after_pass,\n \t    += insn_cost (insn, true) * bb->count.to_gcov_type ();\n \telse if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n \t  record->time[after_pass]\n-\t    += insn_cost (insn, true) * bb->frequency;\n+\t    += insn_cost (insn, true) * bb->count.to_frequency (cfun);\n       }\n }\n "}, {"sha": "7c3507c6eceee9bfbb49485a96c1b7b531b9494b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -862,7 +862,7 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->next_callee = NULL;\n   edge->lto_stmt_uid = 0;\n \n-  edge->count = count;\n+  edge->count = count.ipa ();\n   edge->frequency = freq;\n   gcc_checking_assert (freq >= 0);\n   gcc_checking_assert (freq <= CGRAPH_FREQ_MAX);\n@@ -1308,7 +1308,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t  /* We are producing the final function body and will throw away the\n \t     callgraph edges really soon.  Reset the counts/frequencies to\n \t     keep verifier happy in the case of roundoff errors.  */\n-\t  e->count = gimple_bb (e->call_stmt)->count;\n+\t  e->count = gimple_bb (e->call_stmt)->count.ipa ();\n \t  e->frequency = compute_call_stmt_bb_frequency\n \t\t\t  (e->caller->decl, gimple_bb (e->call_stmt));\n \t}\n@@ -1338,7 +1338,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t    prob = profile_probability::even ();\n \t  new_stmt = gimple_ic (e->call_stmt,\n \t\t\t\tdyn_cast<cgraph_node *> (ref->referred),\n-\t\t\t\tprob, e->count, e->count + e2->count);\n+\t\t\t\tprob);\n \t  e->speculative = false;\n \t  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt,\n \t\t\t\t\t\t     false);\n@@ -1644,7 +1644,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t  /* Otherwise remove edge and create new one; we can't simply redirect\n \t     since function has changed, so inline plan and other information\n \t     attached to edge is invalid.  */\n-\t  count = e->count;\n+\t  count = e->count.ipa ();\n \t  frequency = e->frequency;\n  \t  if (e->indirect_unknown_callee || e->inline_failed)\n \t    e->remove ();\n@@ -1655,7 +1655,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t{\n \t  /* We are seeing new direct call; compute profile info based on BB.  */\n \t  basic_block bb = gimple_bb (new_stmt);\n-\t  count = bb->count;\n+\t  count = bb->count.ipa ();\n \t  frequency = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t      bb);\n \t}\n@@ -3082,9 +3082,14 @@ bool\n cgraph_edge::verify_count_and_frequency ()\n {\n   bool error_found = false;\n-  if (count < 0)\n+  if (!count.verify ())\n     {\n-      error (\"caller edge count is negative\");\n+      error (\"caller edge count invalid\");\n+      error_found = true;\n+    }\n+  if (count.initialized_p () && !(count.ipa () == count))\n+    {\n+      error (\"caller edge count is local\");\n       error_found = true;\n     }\n   if (frequency < 0)\n@@ -3183,9 +3188,14 @@ cgraph_node::verify_node (void)\n \t       identifier_to_locale (e->callee->name ()));\n \terror_found = true;\n       }\n-  if (count < 0)\n+  if (!count.verify ())\n+    {\n+      error (\"cgraph count invalid\");\n+      error_found = true;\n+    }\n+  if (count.initialized_p () && !(count.ipa () == count))\n     {\n-      error (\"execution count is negative\");\n+      error (\"cgraph count is local\");\n       error_found = true;\n     }\n   if (global.inlined_to && same_comdat_group)\n@@ -3269,7 +3279,9 @@ cgraph_node::verify_node (void)\n     {\n       if (e->verify_count_and_frequency ())\n \terror_found = true;\n+      /* FIXME: re-enable once cgraph is converted to counts.  */\n       if (gimple_has_body_p (e->caller->decl)\n+\t  && 0\n \t  && !e->caller->global.inlined_to\n \t  && !e->speculative\n \t  /* Optimized out calls are redirected to __builtin_unreachable.  */\n@@ -3292,9 +3304,11 @@ cgraph_node::verify_node (void)\n     {\n       if (e->verify_count_and_frequency ())\n \terror_found = true;\n+      /* FIXME: re-enable once cgraph is converted to counts.  */\n       if (gimple_has_body_p (e->caller->decl)\n \t  && !e->caller->global.inlined_to\n \t  && !e->speculative\n+\t  && 0\n \t  && (e->frequency\n \t      != compute_call_stmt_bb_frequency (e->caller->decl,\n \t\t\t\t\t\t gimple_bb (e->call_stmt))))"}, {"sha": "dd4bf9a7fa3bd35126fef36bc74b3f8b81970e4f", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -190,21 +190,8 @@ record_eh_tables (cgraph_node *node, function *fun)\n int\n compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n {\n-  int entry_freq = ENTRY_BLOCK_PTR_FOR_FN\n-  \t\t     (DECL_STRUCT_FUNCTION (decl))->frequency;\n-  int freq = bb->frequency;\n-\n-  if (profile_status_for_fn (DECL_STRUCT_FUNCTION (decl)) == PROFILE_ABSENT)\n-    return CGRAPH_FREQ_BASE;\n-\n-  if (!entry_freq)\n-    entry_freq = 1, freq++;\n-\n-  freq = freq * CGRAPH_FREQ_BASE / entry_freq;\n-  if (freq > CGRAPH_FREQ_MAX)\n-    freq = CGRAPH_FREQ_MAX;\n-\n-  return freq;\n+  return bb->count.to_cgraph_frequency\n+      (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (decl))->count);\n }\n \n /* Mark address taken in STMT.  */\n@@ -415,7 +402,7 @@ cgraph_edge::rebuild_edges (void)\n   node->remove_callees ();\n   node->remove_all_references ();\n \n-  node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+  node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ();\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {"}, {"sha": "c5183a02058a1807357c267a390842bd836bf025", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1601,12 +1601,9 @@ init_lowered_empty_function (tree decl, bool in_ssa, profile_count count)\n \n   /* Create BB for body of the function and connect it properly.  */\n   ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = count;\n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency = BB_FREQ_MAX;\n   EXIT_BLOCK_PTR_FOR_FN (cfun)->count = count;\n-  EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency = BB_FREQ_MAX;\n   bb = create_basic_block (NULL, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   bb->count = count;\n-  bb->frequency = BB_FREQ_MAX;\n   e = make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FALLTHRU);\n   e->probability = profile_probability::always ();\n   e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n@@ -1852,8 +1849,12 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       else\n \tresdecl = DECL_RESULT (thunk_fndecl);\n \n+      profile_count cfg_count = count;\n+      if (!cfg_count.initialized_p ())\n+\tcfg_count = profile_count::from_gcov_type (BB_FREQ_MAX).guessed_local ();\n+\n       bb = then_bb = else_bb = return_bb\n-\t= init_lowered_empty_function (thunk_fndecl, true, count);\n+\t= init_lowered_empty_function (thunk_fndecl, true, cfg_count);\n \n       bsi = gsi_start_bb (bb);\n \n@@ -1966,14 +1967,11 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t     adjustment, because that's why we're emitting a\n \t\t     thunk.  */\n \t\t  then_bb = create_basic_block (NULL, bb);\n-\t\t  then_bb->count = count - count.apply_scale (1, 16);\n-\t\t  then_bb->frequency = BB_FREQ_MAX - BB_FREQ_MAX / 16;\n+\t\t  then_bb->count = cfg_count - cfg_count.apply_scale (1, 16);\n \t\t  return_bb = create_basic_block (NULL, then_bb);\n-\t\t  return_bb->count = count;\n-\t\t  return_bb->frequency = BB_FREQ_MAX;\n+\t\t  return_bb->count = cfg_count;\n \t\t  else_bb = create_basic_block (NULL, else_bb);\n-\t\t  then_bb->count = count.apply_scale (1, 16);\n-\t\t  then_bb->frequency = BB_FREQ_MAX / 16;\n+\t\t  else_bb->count = cfg_count.apply_scale (1, 16);\n \t\t  add_bb_to_loop (then_bb, bb->loop_father);\n \t\t  add_bb_to_loop (return_bb, bb->loop_father);\n \t\t  add_bb_to_loop (else_bb, bb->loop_father);\n@@ -2028,8 +2026,10 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t}\n \n       cfun->gimple_df->in_ssa_p = true;\n+      counts_to_freqs ();\n       profile_status_for_fn (cfun)\n-        = count.initialized_p () ? PROFILE_READ : PROFILE_GUESSED;\n+        = cfg_count.initialized_p () && cfg_count.ipa_p ()\n+\t  ? PROFILE_READ : PROFILE_GUESSED;\n       /* FIXME: C++ FE should stop setting TREE_ASM_WRITTEN on thunks.  */\n       TREE_ASM_WRITTEN (thunk_fndecl) = false;\n       delete_unreachable_blocks ();"}, {"sha": "30f303a7bf86045898a02cd1f8388bc16ae7640d", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1003,7 +1003,6 @@ dw2_build_landing_pads (void)\n \n       bb = emit_to_new_bb_before (seq, label_rtx (lp->post_landing_pad));\n       bb->count = bb->next_bb->count;\n-      bb->frequency = bb->next_bb->frequency;\n       make_single_succ_edge (bb, bb->next_bb, e_flags);\n       if (current_loops)\n \t{"}, {"sha": "039c37a3135264d1f912e1a7018b3abcff9ee343", "filename": "gcc/final.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -694,8 +694,8 @@ compute_alignments (void)\n     }\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   FOR_EACH_BB_FN (bb, cfun)\n-    if (bb->frequency > freq_max)\n-      freq_max = bb->frequency;\n+    if (bb->count.to_frequency (cfun) > freq_max)\n+      freq_max = bb->count.to_frequency (cfun);\n   freq_threshold = freq_max / PARAM_VALUE (PARAM_ALIGN_THRESHOLD);\n \n   if (dump_file)\n@@ -713,7 +713,8 @@ compute_alignments (void)\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"BB %4i freq %4i loop %2i loop_depth %2i skipped.\\n\",\n-\t\t     bb->index, bb->frequency, bb->loop_father->num,\n+\t\t     bb->index, bb->count.to_frequency (cfun),\n+\t\t     bb->loop_father->num,\n \t\t     bb_loop_depth (bb));\n \t  continue;\n \t}\n@@ -731,7 +732,7 @@ compute_alignments (void)\n \t{\n \t  fprintf (dump_file, \"BB %4i freq %4i loop %2i loop_depth\"\n \t\t   \" %2i fall %4i branch %4i\",\n-\t\t   bb->index, bb->frequency, bb->loop_father->num,\n+\t\t   bb->index, bb->count.to_frequency (cfun), bb->loop_father->num,\n \t\t   bb_loop_depth (bb),\n \t\t   fallthru_frequency, branch_frequency);\n \t  if (!bb->loop_father->inner && bb->loop_father->num)\n@@ -753,9 +754,10 @@ compute_alignments (void)\n \n       if (!has_fallthru\n \t  && (branch_frequency > freq_threshold\n-\t      || (bb->frequency > bb->prev_bb->frequency * 10\n-\t\t  && (bb->prev_bb->frequency\n-\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency / 2))))\n+\t      || (bb->count.to_frequency (cfun) \n+\t\t\t> bb->prev_bb->count.to_frequency (cfun) * 10\n+\t\t  && (bb->prev_bb->count.to_frequency (cfun)\n+\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun) / 2))))\n \t{\n \t  log = JUMP_ALIGN (label);\n \t  if (dump_file)\n@@ -1942,8 +1944,6 @@ dump_basic_block_info (FILE *file, rtx_insn *insn, basic_block *start_to_bb,\n       edge_iterator ei;\n \n       fprintf (file, \"%s BLOCK %d\", ASM_COMMENT_START, bb->index);\n-      if (bb->frequency)\n-        fprintf (file, \" freq:%d\", bb->frequency);\n       if (bb->count.initialized_p ())\n \t{\n           fprintf (file, \", count:\");"}, {"sha": "ba3d6d6898c5aa25fd8acc72a300c05e3e28e1c6", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -82,21 +82,17 @@ debug_gimple_stmt (gimple *gs)\n    by xstrdup_for_dump.  */\n \n static const char *\n-dump_profile (int frequency, profile_count &count)\n+dump_profile (profile_count &count)\n {\n-  float minimum = 0.01f;\n-\n-  gcc_assert (0 <= frequency && frequency <= REG_BR_PROB_BASE);\n-  float fvalue = frequency * 100.0f / REG_BR_PROB_BASE;\n-  if (fvalue < minimum && frequency > 0)\n-    return \"[0.01%]\";\n-\n   char *buf;\n-  if (count.initialized_p ())\n-    buf = xasprintf (\"[%.2f%%] [count: %\" PRId64 \"]\", fvalue,\n+  if (!count.initialized_p ())\n+    return NULL;\n+  if (count.ipa_p ())\n+    buf = xasprintf (\"[count: %\" PRId64 \"]\",\n+\t\t     count.to_gcov_type ());\n+  else if (count.initialized_p ())\n+    buf = xasprintf (\"[local count: %\" PRId64 \"]\",\n \t\t     count.to_gcov_type ());\n-  else\n-    buf = xasprintf (\"[%.2f%%] [count: INV]\", fvalue);\n \n   const char *ret = xstrdup_for_dump (buf);\n   free (buf);\n@@ -2695,8 +2691,7 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent,\n \tfprintf (outf, \"%*sbb_%d:\\n\", indent, \"\", bb->index);\n       else\n \tfprintf (outf, \"%*s<bb %d> %s:\\n\",\n-\t\t indent, \"\", bb->index, dump_profile (bb->frequency,\n-\t\t\t\t\t\t      bb->count));\n+\t\t indent, \"\", bb->index, dump_profile (bb->count));\n     }\n }\n "}, {"sha": "9a010a6b3954ac7181d1424ff56b3263f087188a", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -154,7 +154,6 @@ isolate_path (basic_block bb, basic_block duplicate,\n   if (!duplicate)\n     {\n       duplicate = duplicate_block (bb, NULL, NULL);\n-      bb->frequency = 0;\n       bb->count = profile_count::zero ();\n       if (!ret_zero)\n \tfor (ei = ei_start (duplicate->succs); (e2 = ei_safe_edge (ei)); )\n@@ -168,7 +167,7 @@ isolate_path (basic_block bb, basic_block duplicate,\n       flush_pending_stmts (e2);\n \n       /* Update profile only when redirection is really processed.  */\n-      bb->frequency += EDGE_FREQUENCY (e);\n+      bb->count += e->count ();\n     }\n \n   /* There may be more than one statement in DUPLICATE which exhibits"}, {"sha": "0dabe1adcf6308abbf679fe0607358821e49a2af", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -266,7 +266,6 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n \n   bb->count = profile_count::stream_in (ib).apply_scale\n \t\t (count_materialization_scale, REG_BR_PROB_BASE);\n-  bb->frequency = streamer_read_hwi (ib);\n   bb->flags = streamer_read_hwi (ib);\n \n   /* LTO_bb1 has statements.  LTO_bb0 does not.  */"}, {"sha": "c19e5f1b55f23c5f780dd84db6e8045bd367e8ba", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -210,7 +210,6 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n \n   streamer_write_uhwi (ob, bb->index);\n   bb->count.stream_out (ob);\n-  streamer_write_hwi (ob, bb->frequency);\n   streamer_write_hwi (ob, bb->flags);\n \n   if (!gsi_end_p (bsi) || phi_nodes (bb))"}, {"sha": "f5c06a95bb6742475bf7d1f2c5ea16456fa21efe", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -3917,8 +3917,8 @@ sched_pressure_start_bb (basic_block bb)\n       - call_saved_regs_num[cl]).  */\n   {\n     int i;\n-    int entry_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n-    int bb_freq = bb->frequency;\n+    int entry_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun);\n+    int bb_freq = bb->count.to_frequency (cfun);\n \n     if (bb_freq == 0)\n       {\n@@ -8141,8 +8141,6 @@ init_before_recovery (basic_block *before_recovery_ptr)\n \n       single->count = last->count;\n       empty->count = last->count;\n-      single->frequency = last->frequency;\n-      empty->frequency = last->frequency;\n       BB_COPY_PARTITION (single, last);\n       BB_COPY_PARTITION (empty, last);\n \n@@ -8236,7 +8234,6 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n      in sel-sched.c `check_ds' in create_speculation_check.  */\n   e->probability = profile_probability::very_unlikely ();\n   rec->count = e->count ();\n-  rec->frequency = EDGE_FREQUENCY (e);\n   e2->probability = e->probability.invert ();\n \n   rtx_code_label *label = block_label (second_bb);"}, {"sha": "f0efd9dd6d924159974a4a10dbbd06ce459ee41a", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -6374,7 +6374,7 @@ convert_switch_statements (void)\n \n \t\tedge next_edge = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n \t\tnext_edge->probability = new_edge->probability.invert ();\n-\t\tnext_bb->frequency = EDGE_FREQUENCY (next_edge);\n+\t\tnext_bb->count = next_edge->count ();\n \t\tcur_bb = next_bb;\n \t      }\n \t    else /* Link last IF statement and default label"}, {"sha": "24d2be791038f608539c1bdb4945cc0d7e4e3e18", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -3257,6 +3257,8 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n   if (dump_file)\n     fprintf (dump_file, \"\\n Propagating constants:\\n\\n\");\n \n+  max_count = profile_count::uninitialized ();\n+\n   FOR_EACH_DEFINED_FUNCTION (node)\n   {\n     struct ipa_node_params *info = IPA_NODE_REF (node);\n@@ -3270,8 +3272,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n       }\n     if (node->definition && !node->alias)\n       overall_size += ipa_fn_summaries->get (node)->self_size;\n-    if (node->count > max_count)\n-      max_count = node->count;\n+    max_count = max_count.max (node->count);\n   }\n \n   max_new_size = overall_size;\n@@ -5125,7 +5126,7 @@ make_pass_ipa_cp (gcc::context *ctxt)\n void\n ipa_cp_c_finalize (void)\n {\n-  max_count = profile_count::zero ();\n+  max_count = profile_count::uninitialized ();\n   overall_size = 0;\n   max_new_size = 0;\n }"}, {"sha": "f6841104a32a5f87e507dca460e09a278edbe874", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1608,7 +1608,7 @@ static basic_block\n get_minimal_bb (basic_block init_bb, basic_block use_bb)\n {\n   struct loop *l = find_common_loop (init_bb->loop_father, use_bb->loop_father);\n-  if (l && l->header->frequency < init_bb->frequency)\n+  if (l && l->header->count < init_bb->count)\n     return l->header;\n   return init_bb;\n }\n@@ -1664,20 +1664,21 @@ param_change_prob (gimple *stmt, int i)\n     {\n       int init_freq;\n \n-      if (!bb->frequency)\n+      if (!bb->count.to_frequency (cfun))\n \treturn REG_BR_PROB_BASE;\n \n       if (SSA_NAME_IS_DEFAULT_DEF (base))\n-\tinit_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n+\tinit_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun);\n       else\n \tinit_freq = get_minimal_bb\n \t\t      (gimple_bb (SSA_NAME_DEF_STMT (base)),\n-\t\t       gimple_bb (stmt))->frequency;\n+\t\t       gimple_bb (stmt))->count.to_frequency (cfun);\n \n       if (!init_freq)\n \tinit_freq = 1;\n-      if (init_freq < bb->frequency)\n-\treturn MAX (GCOV_COMPUTE_SCALE (init_freq, bb->frequency), 1);\n+      if (init_freq < bb->count.to_frequency (cfun))\n+\treturn MAX (GCOV_COMPUTE_SCALE (init_freq,\n+\t\t\t\t\tbb->count.to_frequency (cfun)), 1);\n       else\n \treturn REG_BR_PROB_BASE;\n     }\n@@ -1692,7 +1693,7 @@ param_change_prob (gimple *stmt, int i)\n \n       if (init != error_mark_node)\n \treturn 0;\n-      if (!bb->frequency)\n+      if (!bb->count.to_frequency (cfun))\n \treturn REG_BR_PROB_BASE;\n       ao_ref_init (&refd, op);\n       info.stmt = stmt;\n@@ -1708,17 +1709,17 @@ param_change_prob (gimple *stmt, int i)\n       /* Assume that every memory is initialized at entry.\n          TODO: Can we easilly determine if value is always defined\n          and thus we may skip entry block?  */\n-      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency)\n-\tmax = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n+      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun))\n+\tmax = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun);\n       else\n \tmax = 1;\n \n       EXECUTE_IF_SET_IN_BITMAP (info.bb_set, 0, index, bi)\n-\tmax = MIN (max, BASIC_BLOCK_FOR_FN (cfun, index)->frequency);\n+\tmax = MIN (max, BASIC_BLOCK_FOR_FN (cfun, index)->count.to_frequency (cfun));\n \n       BITMAP_FREE (info.bb_set);\n-      if (max < bb->frequency)\n-\treturn MAX (GCOV_COMPUTE_SCALE (max, bb->frequency), 1);\n+      if (max < bb->count.to_frequency (cfun))\n+\treturn MAX (GCOV_COMPUTE_SCALE (max, bb->count.to_frequency (cfun)), 1);\n       else\n \treturn REG_BR_PROB_BASE;\n     }"}, {"sha": "886e8edd473b40229cd162550313637ac5ceb7cf", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -676,9 +676,9 @@ inline_transform (struct cgraph_node *node)\n     {\n       profile_count num = node->count;\n       profile_count den = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n-      bool scale = num.initialized_p ()\n-\t\t   && (den > 0 || num == profile_count::zero ())\n-\t\t   && !(num == den);\n+      bool scale = num.initialized_p () && den.ipa_p ()\n+\t\t   && (den.nonzero_p () || num == profile_count::zero ())\n+\t\t   && !(num == den.ipa ());\n       if (scale)\n \t{\n \t  if (dump_file)"}, {"sha": "687996876ce717a68ecf39bb042086a54eefeca0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -640,8 +640,8 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n \n-  if (edge->count > profile_count::zero ()\n-      && caller->count > profile_count::zero ())\n+  if (edge->count.nonzero_p ()\n+      && caller->count.nonzero_p ())\n     uninlined_call_time *= (sreal)edge->count.to_gcov_type ()\n \t\t\t   / caller->count.to_gcov_type ();\n   if (edge->frequency)\n@@ -665,8 +665,8 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t : edge->caller);\n   sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n-  if (edge->count > profile_count::zero ()\n-      && caller->count > profile_count::zero ())\n+  if (edge->count.nonzero_p ()\n+      && caller->count.nonzero_p ())\n     time *= (sreal)edge->count.to_gcov_type () / caller->count.to_gcov_type ();\n   if (edge->frequency)\n     time *= cgraph_freq_base_rec * edge->frequency;\n@@ -733,7 +733,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl)\n-\t    || e->count > profile_count::zero ())\n+\t    || e->count.nonzero_p ())\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n@@ -843,7 +843,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       reason = \"recursive call is cold\";\n       want_inline = false;\n     }\n-  else if (outer_node->count == profile_count::zero ())\n+  else if (!outer_node->count.nonzero_p ())\n     {\n       reason = \"not executed in profile\";\n       want_inline = false;\n@@ -881,15 +881,15 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       int i;\n       for (i = 1; i < depth; i++)\n \tmax_prob = max_prob * max_prob / CGRAPH_FREQ_BASE;\n-      if (max_count > profile_count::zero () && edge->count > profile_count::zero ()\n+      if (max_count.nonzero_p () && edge->count.nonzero_p () \n \t  && (edge->count.to_gcov_type () * CGRAPH_FREQ_BASE\n \t      / outer_node->count.to_gcov_type ()\n \t      >= max_prob))\n \t{\n \t  reason = \"profile of recursive call is too large\";\n \t  want_inline = false;\n \t}\n-      if (max_count == profile_count::zero ()\n+      if (!max_count.nonzero_p ()\n \t  && (edge->frequency * CGRAPH_FREQ_BASE / caller_freq\n \t      >= max_prob))\n \t{\n@@ -915,15 +915,15 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n      methods.  */\n   else\n     {\n-      if (max_count > profile_count::zero () && edge->count.initialized_p ()\n+      if (max_count.nonzero_p () && edge->count.initialized_p ()\n \t  && (edge->count.to_gcov_type () * 100\n \t      / outer_node->count.to_gcov_type ()\n \t      <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{\n \t  reason = \"profile of recursive call is too small\";\n \t  want_inline = false;\n \t}\n-      else if ((max_count == profile_count::zero ()\n+      else if ((!max_count.nonzero_p ()\n \t        || !edge->count.initialized_p ())\n \t       && (edge->frequency * 100 / caller_freq\n \t           <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n@@ -1070,7 +1070,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      then calls without.\n   */\n   else if (opt_for_fn (caller->decl, flag_guess_branch_prob)\n-\t   || caller->count > profile_count::zero ())\n+\t   || caller->count.nonzero_p ())\n     {\n       sreal numerator, denominator;\n       int overall_growth;\n@@ -1080,7 +1080,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   - inlined_time);\n       if (numerator == 0)\n \tnumerator = ((sreal) 1 >> 8);\n-      if (caller->count > profile_count::zero ())\n+      if (caller->count.nonzero_p ())\n \tnumerator *= caller->count.to_gcov_type ();\n       else if (caller->count.initialized_p ())\n \tnumerator = numerator >> 11;\n@@ -1521,7 +1521,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t{\n \t  fprintf (dump_file,\n \t\t   \"   Inlining call of depth %i\", depth);\n-\t  if (node->count > profile_count::zero ())\n+\t  if (node->count.nonzero_p ())\n \t    {\n \t      fprintf (dump_file, \" called approx. %.2f times per call\",\n \t\t       (double)curr->count.to_gcov_type ()\n@@ -1684,7 +1684,8 @@ resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n \t\t\t\t  ? node->global.inlined_to : node;\n       auto_bitmap updated_nodes;\n \n-      spec_rem += edge->count;\n+      if (edge->count.initialized_p ())\n+        spec_rem += edge->count;\n       edge->resolve_speculation ();\n       reset_edge_caches (where);\n       ipa_update_overall_fn_summary (where);\n@@ -1789,8 +1790,7 @@ inline_small_functions (void)\n \t  }\n \n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n-\t  if (!(max_count >= edge->count))\n-\t    max_count = edge->count;\n+\t  max_count = max_count.max (edge->count);\n       }\n   ipa_free_postorder_info ();\n   initialize_growth_caches ();\n@@ -2049,7 +2049,7 @@ inline_small_functions (void)\n       update_caller_keys (&edge_heap, where, updated_nodes, NULL);\n       /* Offline copy count has possibly changed, recompute if profile is\n \t available.  */\n-      if (max_count > profile_count::zero ())\n+      if (max_count.nonzero_p ())\n         {\n \t  struct cgraph_node *n = cgraph_node::get (edge->callee->decl);\n \t  if (n != edge->callee && n->analyzed)\n@@ -2392,6 +2392,7 @@ ipa_inline (void)\n     ipa_dump_fn_summaries (dump_file);\n \n   nnodes = ipa_reverse_postorder (order);\n+  spec_rem = profile_count::zero ();\n \n   FOR_EACH_FUNCTION (node)\n     {\n@@ -2487,8 +2488,9 @@ ipa_inline (void)\n \t      next = edge->next_callee;\n \t      if (edge->speculative && !speculation_useful_p (edge, false))\n \t\t{\n+\t\t  if (edge->count.initialized_p ())\n+\t\t    spec_rem += edge->count;\n \t\t  edge->resolve_speculation ();\n-\t\t  spec_rem += edge->count;\n \t\t  update = true;\n \t\t  remove_functions = true;\n \t\t}"}, {"sha": "8eb03dd7c24d739cc2fed950657d7e9c676e7417", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -179,53 +179,54 @@ ipa_profile_generate_summary (void)\n   hash_table<histogram_hash> hashtable (10);\n   \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n-    FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n-      {\n-\tint time = 0;\n-\tint size = 0;\n-        for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  {\n-\t    gimple *stmt = gsi_stmt (gsi);\n-\t    if (gimple_code (stmt) == GIMPLE_CALL\n-\t\t&& !gimple_call_fndecl (stmt))\n-\t      {\n-\t\thistogram_value h;\n-\t\th = gimple_histogram_value_of_type\n-\t\t      (DECL_STRUCT_FUNCTION (node->decl),\n-\t\t       stmt, HIST_TYPE_INDIR_CALL);\n-\t\t/* No need to do sanity check: gimple_ic_transform already\n-\t\t   takes away bad histograms.  */\n-\t\tif (h)\n-\t\t  {\n-\t\t    /* counter 0 is target, counter 1 is number of execution we called target,\n-\t\t       counter 2 is total number of executions.  */\n-\t\t    if (h->hvalue.counters[2])\n-\t\t      {\n-\t\t\tstruct cgraph_edge * e = node->get_edge (stmt);\n-\t\t\tif (e && !e->indirect_unknown_callee)\n-\t\t\t  continue;\n-\t\t\te->indirect_info->common_target_id\n-\t\t\t  = h->hvalue.counters [0];\n-\t\t\te->indirect_info->common_target_probability\n-\t\t\t  = GCOV_COMPUTE_SCALE (h->hvalue.counters [1], h->hvalue.counters [2]);\n-\t\t\tif (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n-\t\t\t  {\n-\t\t\t    if (dump_file)\n-\t\t\t      fprintf (dump_file, \"Probability capped to 1\\n\");\n-\t\t\t    e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n-\t\t\t  }\n-\t\t      }\n-\t\t    gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->decl),\n-\t\t\t\t\t\t    stmt, h);\n-\t\t  }\n-\t      }\n-\t    time += estimate_num_insns (stmt, &eni_time_weights);\n-\t    size += estimate_num_insns (stmt, &eni_size_weights);\n-\t  }\n-\tif (bb->count.initialized_p ())\n-\t  account_time_size (&hashtable, histogram, bb->count.to_gcov_type (),\n-\t\t\t     time, size);\n-      }\n+    if (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (node->decl))->count.ipa_p ())\n+      FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+\t{\n+\t  int time = 0;\n+\t  int size = 0;\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (gimple_code (stmt) == GIMPLE_CALL\n+\t\t  && !gimple_call_fndecl (stmt))\n+\t\t{\n+\t\t  histogram_value h;\n+\t\t  h = gimple_histogram_value_of_type\n+\t\t\t(DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t stmt, HIST_TYPE_INDIR_CALL);\n+\t\t  /* No need to do sanity check: gimple_ic_transform already\n+\t\t     takes away bad histograms.  */\n+\t\t  if (h)\n+\t\t    {\n+\t\t      /* counter 0 is target, counter 1 is number of execution we called target,\n+\t\t\t counter 2 is total number of executions.  */\n+\t\t      if (h->hvalue.counters[2])\n+\t\t\t{\n+\t\t\t  struct cgraph_edge * e = node->get_edge (stmt);\n+\t\t\t  if (e && !e->indirect_unknown_callee)\n+\t\t\t    continue;\n+\t\t\t  e->indirect_info->common_target_id\n+\t\t\t    = h->hvalue.counters [0];\n+\t\t\t  e->indirect_info->common_target_probability\n+\t\t\t    = GCOV_COMPUTE_SCALE (h->hvalue.counters [1], h->hvalue.counters [2]);\n+\t\t\t  if (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n+\t\t\t    {\n+\t\t\t      if (dump_file)\n+\t\t\t\tfprintf (dump_file, \"Probability capped to 1\\n\");\n+\t\t\t      e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t\t\t      stmt, h);\n+\t\t    }\n+\t\t}\n+\t      time += estimate_num_insns (stmt, &eni_time_weights);\n+\t      size += estimate_num_insns (stmt, &eni_size_weights);\n+\t    }\n+\t  if (bb->count.ipa_p () && bb->count.initialized_p ())\n+\t    account_time_size (&hashtable, histogram, bb->count.ipa ().to_gcov_type (),\n+\t\t\t       time, size);\n+\t}\n   histogram.qsort (cmp_counts);\n }\n "}, {"sha": "252ea053e2aa357224c390ff7efe64a1ebf5f4c6", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -444,7 +444,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \n   /* Do not split when we would end up calling function anyway.  */\n   if (incoming_freq\n-      >= (ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency\n+      >= (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun)\n \t  * PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100))\n     {\n       /* When profile is guessed, we can not expect it to give us\n@@ -454,13 +454,14 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \t is likely noticeable win.  */\n       if (back_edge\n \t  && profile_status_for_fn (cfun) != PROFILE_READ\n-\t  && incoming_freq < ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency)\n+\t  && incoming_freq\n+\t\t < ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n \t\t     \"  Split before loop, accepting despite low frequencies %i %i.\\n\",\n \t\t     incoming_freq,\n-\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency);\n+\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun));\n \t}\n       else\n \t{\n@@ -714,8 +715,10 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n      out smallest size of header.\n      In future we might re-consider this heuristics.  */\n   if (!best_split_point.split_bbs\n-      || best_split_point.entry_bb->frequency > current->entry_bb->frequency\n-      || (best_split_point.entry_bb->frequency == current->entry_bb->frequency\n+      || best_split_point.entry_bb->count.to_frequency (cfun)\n+\t > current->entry_bb->count.to_frequency (cfun)\n+      || (best_split_point.entry_bb->count.to_frequency (cfun)\n+\t  == current->entry_bb->count.to_frequency (cfun)\n \t  && best_split_point.split_size < current->split_size))\n \t\n     {\n@@ -1285,7 +1288,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n \t  FOR_EACH_EDGE (e, ei, return_bb->preds)\n \t    if (bitmap_bit_p (split_point->split_bbs, e->src->index))\n \t      {\n-\t\tnew_return_bb->frequency += EDGE_FREQUENCY (e);\n+\t\tnew_return_bb->count += e->count ();\n \t\tredirect_edge_and_branch (e, new_return_bb);\n \t\tredirected = true;\n \t\tbreak;"}, {"sha": "e9ab78cdabb0e696c925bb9dba54cedcfd01ab19", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -524,7 +524,14 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t  unsigned int i;\n \n \t  dstbb = BASIC_BLOCK_FOR_FN (dstcfun, srcbb->index);\n-\t  if (!dstbb->count.initialized_p ())\n+\n+\t  /* Either sum the profiles if both are IPA and not global0, or\n+\t     pick more informative one (that is nonzero IPA if other is\n+\t     uninitialized, guessed or global0).   */\n+\t  if (!dstbb->count.ipa ().initialized_p ()\n+\t      || (dstbb->count.ipa () == profile_count::zero ()\n+\t\t  && (srcbb->count.ipa ().initialized_p ()\n+\t\t      && !(srcbb->count.ipa () == profile_count::zero ()))))\n \t    {\n \t      dstbb->count = srcbb->count;\n \t      for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n@@ -535,7 +542,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t    dste->probability = srce->probability;\n \t\t}\n \t    }\t\n-\t  else if (srcbb->count.initialized_p ())\n+\t  else if (srcbb->count.ipa ().initialized_p ()\n+\t\t   && !(srcbb->count.ipa () == profile_count::zero ()))\n \t    {\n \t      for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n \t\t{\n@@ -556,7 +564,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t{\n \t  if (e->speculative)\n \t    continue;\n-\t  e->count = gimple_bb (e->call_stmt)->count;\n+\t  e->count = gimple_bb (e->call_stmt)->count.ipa ();\n \t  e->frequency = compute_call_stmt_bb_frequency\n \t\t\t     (dst->decl,\n \t\t\t      gimple_bb (e->call_stmt));\n@@ -634,7 +642,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t      ipa_ref *ref;\n \n \t      e2->speculative_call_info (direct, indirect, ref);\n-\t      e->count = count;\n+\t      e->count = count.ipa ();\n \t      e->frequency = freq;\n \t      int prob = direct->count.probability_in (e->count)\n \t\t\t .to_reg_br_prob_base ();\n@@ -643,7 +651,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t    }\n \t  else\n \t    {\n-\t      e->count = count;\n+\t      e->count = count.ipa ();\n \t      e->frequency = freq;\n \t    }\n \t}"}, {"sha": "e30e39eb3d4441c0faca2261ab60484ce60e89e7", "filename": "gcc/ira-build.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -2202,7 +2202,8 @@ loop_compare_func (const void *v1p, const void *v2p)\n     return -1;\n   if (! l1->to_remove_p && l2->to_remove_p)\n     return 1;\n-  if ((diff = l1->loop->header->frequency - l2->loop->header->frequency) != 0)\n+  if ((diff = l1->loop->header->count.to_frequency (cfun)\n+\t      - l2->loop->header->count.to_frequency (cfun)) != 0)\n     return diff;\n   if ((diff = (int) loop_depth (l1->loop) - (int) loop_depth (l2->loop)) != 0)\n     return diff;\n@@ -2260,7 +2261,7 @@ mark_loops_for_removal (void)\n \t  (ira_dump_file,\n \t   \"  Mark loop %d (header %d, freq %d, depth %d) for removal (%s)\\n\",\n \t   sorted_loops[i]->loop_num, sorted_loops[i]->loop->header->index,\n-\t   sorted_loops[i]->loop->header->frequency,\n+\t   sorted_loops[i]->loop->header->count.to_frequency (cfun),\n \t   loop_depth (sorted_loops[i]->loop),\n \t   low_pressure_loop_node_p (sorted_loops[i]->parent)\n \t   && low_pressure_loop_node_p (sorted_loops[i])\n@@ -2293,7 +2294,7 @@ mark_all_loops_for_removal (void)\n \t     \"  Mark loop %d (header %d, freq %d, depth %d) for removal\\n\",\n \t     ira_loop_nodes[i].loop_num,\n \t     ira_loop_nodes[i].loop->header->index,\n-\t     ira_loop_nodes[i].loop->header->frequency,\n+\t     ira_loop_nodes[i].loop->header->count.to_frequency (cfun),\n \t     loop_depth (ira_loop_nodes[i].loop));\n       }\n }"}, {"sha": "3a1d838affdf506c78d9c072c3521ed13246e6ea", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -506,7 +506,6 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       set_immediate_dominator (CDI_DOMINATORS, new_preheader, preheader);\n \n       set_zero->count = profile_count::uninitialized ();\n-      set_zero->frequency = 0;\n \n       te = single_succ_edge (preheader);\n       for (; ass; ass = XEXP (ass, 1))\n@@ -522,7 +521,6 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \t     also be very hard to show that it is impossible, so we must\n \t     handle this case.  */\n \t  set_zero->count = preheader->count;\n-\t  set_zero->frequency = preheader->frequency;\n \t}\n \n       if (EDGE_COUNT (set_zero->preds) == 0)"}, {"sha": "91bf5dddeeda8d8649a4e154ee1d6a1ffa3a25fd", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -863,7 +863,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   unsigned i, j;\n   profile_probability p;\n   basic_block preheader, *body, swtch, ezc_swtch = NULL;\n-  int may_exit_copy, iter_freq, new_freq;\n+  int may_exit_copy;\n   profile_count iter_count, new_count;\n   unsigned n_peel;\n   edge e;\n@@ -970,12 +970,10 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   /* Record the place where switch will be built for preconditioning.  */\n   swtch = split_edge (loop_preheader_edge (loop));\n \n-  /* Compute frequency/count increments for each switch block and initialize\n+  /* Compute count increments for each switch block and initialize\n      innermost switch block.  Switch blocks and peeled loop copies are built\n      from innermost outward.  */\n-  iter_freq = new_freq = swtch->frequency / (max_unroll + 1);\n   iter_count = new_count = swtch->count.apply_scale (1, max_unroll + 1);\n-  swtch->frequency = new_freq;\n   swtch->count = new_count;\n \n   for (i = 0; i < n_peel; i++)\n@@ -995,8 +993,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       p = profile_probability::always ().apply_scale (1, i + 2);\n \n       preheader = split_edge (loop_preheader_edge (loop));\n-      /* Add in frequency/count of edge from switch block.  */\n-      preheader->frequency += iter_freq;\n+      /* Add in count of edge from switch block.  */\n       preheader->count += iter_count;\n       branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,\n \t\t\t\t\t  block_label (preheader), p,\n@@ -1009,9 +1006,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       swtch = split_edge_and_insert (single_pred_edge (swtch), branch_code);\n       set_immediate_dominator (CDI_DOMINATORS, preheader, swtch);\n       single_succ_edge (swtch)->probability = p.invert ();\n-      new_freq += iter_freq;\n       new_count += iter_count;\n-      swtch->frequency = new_freq;\n       swtch->count = new_count;\n       e = make_edge (swtch, preheader,\n \t\t     single_succ_edge (swtch)->flags & EDGE_IRREDUCIBLE_LOOP);\n@@ -1024,12 +1019,10 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       p = profile_probability::always ().apply_scale (1, max_unroll + 1);\n       swtch = ezc_swtch;\n       preheader = split_edge (loop_preheader_edge (loop));\n-      /* Recompute frequency/count adjustments since initial peel copy may\n+      /* Recompute count adjustments since initial peel copy may\n \t have exited and reduced those values that were computed above.  */\n-      iter_freq = swtch->frequency / (max_unroll + 1);\n       iter_count = swtch->count.apply_scale (1, max_unroll + 1);\n-      /* Add in frequency/count of edge from switch block.  */\n-      preheader->frequency += iter_freq;\n+      /* Add in count of edge from switch block.  */\n       preheader->count += iter_count;\n       branch_code = compare_and_jump_seq (copy_rtx (niter), const0_rtx, EQ,\n \t\t\t\t\t  block_label (preheader), p,"}, {"sha": "acbbc9d68235d26411d3cffc3ec012e92e600c50", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1192,6 +1192,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n     gimple_set_body (fn_decl, bb_seq (ei_edge (ei)->dest));\n   }\n \n+  counts_to_freqs ();\n   fixup_call_stmt_edges (node, stmts);\n   execute_all_ipa_stmt_fixups (node, stmts);\n "}, {"sha": "07856424f65adc4f26c2c6e716fab6cb343e74ca", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1399,6 +1399,7 @@ expand_omp_taskreg (struct omp_region *region)\n \n       if (optimize)\n \toptimize_omp_library_calls (entry_stmt);\n+      counts_to_freqs ();\n       cgraph_edge::rebuild_edges ();\n \n       /* Some EH regions might become dead, see PR34608.  If"}, {"sha": "37a5f64a549fb736a3373d2ba65243e096e42c05", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1132,6 +1132,7 @@ simd_clone_adjust (struct cgraph_node *node)\n     {\n       basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;\n       incr_bb = create_empty_bb (orig_exit);\n+      incr_bb->count = profile_count::zero ();\n       add_bb_to_loop (incr_bb, body_bb->loop_father);\n       /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty\n \t flag.  Set it now to be a FALLTHRU_EDGE.  */\n@@ -1142,11 +1143,13 @@ simd_clone_adjust (struct cgraph_node *node)\n \t{\n \t  edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);\n \t  redirect_edge_succ (e, incr_bb);\n+\t  incr_bb->count += e->count ();\n \t}\n     }\n   else if (node->simdclone->inbranch)\n     {\n       incr_bb = create_empty_bb (entry_bb);\n+      incr_bb->count = profile_count::zero ();\n       add_bb_to_loop (incr_bb, body_bb->loop_father);\n     }\n \n@@ -1243,6 +1246,7 @@ simd_clone_adjust (struct cgraph_node *node)\n       gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n       edge e = make_edge (loop->header, incr_bb, EDGE_TRUE_VALUE);\n       e->probability = profile_probability::unlikely ().guessed ();\n+      incr_bb->count += e->count ();\n       edge fallthru = FALLTHRU_EDGE (loop->header);\n       fallthru->flags = EDGE_FALSE_VALUE;\n       fallthru->probability = profile_probability::likely ().guessed ();"}, {"sha": "cf42ccbd903b9c5063de30702c514897d28a2e9c", "filename": "gcc/predict.c", "status": "modified", "additions": 81, "deletions": 66, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -137,12 +137,12 @@ maybe_hot_frequency_p (struct function *fun, int freq)\n   if (profile_status_for_fn (fun) == PROFILE_ABSENT)\n     return true;\n   if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n-      && freq < (ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency * 2 / 3))\n+      && freq < (ENTRY_BLOCK_PTR_FOR_FN (fun)->count.to_frequency (cfun) * 2 / 3))\n     return false;\n   if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0)\n     return false;\n   if (freq * PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)\n-      < ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency)\n+      < ENTRY_BLOCK_PTR_FOR_FN (fun)->count.to_frequency (cfun))\n     return false;\n   return true;\n }\n@@ -175,10 +175,14 @@ set_hot_bb_threshold (gcov_type min)\n /* Return TRUE if frequency FREQ is considered to be hot.  */\n \n bool\n-maybe_hot_count_p (struct function *, profile_count count)\n+maybe_hot_count_p (struct function *fun, profile_count count)\n {\n   if (!count.initialized_p ())\n     return true;\n+  if (!count.ipa_p ())\n+    return maybe_hot_frequency_p (fun, count.to_frequency (fun));\n+  if (count.ipa () == profile_count::zero ())\n+    return false;\n   /* Code executed at most once is not hot.  */\n   if (count <= MAX (profile_info ? profile_info->runs : 1, 1))\n     return false;\n@@ -192,9 +196,7 @@ bool\n maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n {\n   gcc_checking_assert (fun);\n-  if (!maybe_hot_count_p (fun, bb->count))\n-    return false;\n-  return maybe_hot_frequency_p (fun, bb->frequency);\n+  return maybe_hot_count_p (fun, bb->count);\n }\n \n /* Return true in case BB can be CPU intensive and should be optimized\n@@ -203,17 +205,15 @@ maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n bool\n maybe_hot_edge_p (edge e)\n {\n-  if (!maybe_hot_count_p (cfun, e->count ()))\n-    return false;\n-  return maybe_hot_frequency_p (cfun, EDGE_FREQUENCY (e));\n+  return maybe_hot_count_p (cfun, e->count ());\n }\n \n /* Return true if profile COUNT and FREQUENCY, or function FUN static\n    node frequency reflects never being executed.  */\n    \n static bool\n probably_never_executed (struct function *fun,\n-                         profile_count count, int)\n+                         profile_count count)\n {\n   gcc_checking_assert (fun);\n   if (count == profile_count::zero ())\n@@ -238,7 +238,7 @@ probably_never_executed (struct function *fun,\n bool\n probably_never_executed_bb_p (struct function *fun, const_basic_block bb)\n {\n-  return probably_never_executed (fun, bb->count, bb->frequency);\n+  return probably_never_executed (fun, bb->count);\n }\n \n \n@@ -259,7 +259,7 @@ probably_never_executed_edge_p (struct function *fun, edge e)\n {\n   if (unlikely_executed_edge_p (e))\n     return true;\n-  return probably_never_executed (fun, e->count (), EDGE_FREQUENCY (e));\n+  return probably_never_executed (fun, e->count ());\n }\n \n /* Return true when current function should always be optimized for size.  */\n@@ -1289,7 +1289,8 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n     }\n   clear_bb_predictions (bb);\n \n-  if (!bb->count.initialized_p () && !dry_run)\n+  if ((!bb->count.nonzero_p () || !first->probability.initialized_p ())\n+      && !dry_run)\n     {\n       first->probability\n \t = profile_probability::from_reg_br_prob_base (combined_probability);\n@@ -3014,10 +3015,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n       BLOCK_INFO (bb)->npredecessors = count;\n       /* When function never returns, we will never process exit block.  */\n       if (!count && bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t{\n-\t  bb->count = profile_count::zero ();\n-\t  bb->frequency = 0;\n-\t}\n+\tbb->count = profile_count::zero ();\n     }\n \n   BLOCK_INFO (head)->frequency = 1;\n@@ -3050,7 +3048,10 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n \t\t\t\t  REG_BR_PROB_BASE);  */\n \n-\t\tsreal tmp = e->probability.to_reg_br_prob_base ();\n+\t\t/* FIXME: Graphite is producing edges with no profile. Once\n+\t\t   this is fixed, drop this.  */\n+\t\tsreal tmp = e->probability.initialized_p () ?\n+\t\t\t    e->probability.to_reg_br_prob_base () : 0;\n \t\ttmp *= BLOCK_INFO (e->src)->frequency;\n \t\ttmp *= real_inv_br_prob_base;\n \t\tfrequency += tmp;\n@@ -3082,7 +3083,10 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t     = ((e->probability * BLOCK_INFO (bb)->frequency)\n \t     / REG_BR_PROB_BASE); */\n \n-\t  sreal tmp = e->probability.to_reg_br_prob_base ();\n+\t  /* FIXME: Graphite is producing edges with no profile. Once\n+\t     this is fixed, drop this.  */\n+\t  sreal tmp = e->probability.initialized_p () ?\n+\t\t      e->probability.to_reg_br_prob_base () : 0;\n \t  tmp *= BLOCK_INFO (bb)->frequency;\n \t  EDGE_INFO (e)->back_edge_prob = tmp * real_inv_br_prob_base;\n \t}\n@@ -3196,10 +3200,26 @@ drop_profile (struct cgraph_node *node, profile_count call_count)\n     }\n \n   basic_block bb;\n-  FOR_ALL_BB_FN (bb, fn)\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  if (flag_guess_branch_prob)\n     {\n-      bb->count = profile_count::uninitialized ();\n+      bool clear_zeros\n+\t = ENTRY_BLOCK_PTR_FOR_FN\n+\t\t (DECL_STRUCT_FUNCTION (node->decl))->count.nonzero_p ();\n+      FOR_ALL_BB_FN (bb, fn)\n+\tif (clear_zeros || !(bb->count == profile_count::zero ()))\n+\t  bb->count = bb->count.guessed_local ();\n+      DECL_STRUCT_FUNCTION (node->decl)->cfg->count_max =\n+        DECL_STRUCT_FUNCTION (node->decl)->cfg->count_max.guessed_local ();\n     }\n+  else\n+    {\n+      FOR_ALL_BB_FN (bb, fn)\n+\tbb->count = profile_count::uninitialized ();\n+      DECL_STRUCT_FUNCTION (node->decl)->cfg->count_max\n+\t = profile_count::uninitialized ();\n+    }\n+  pop_cfun ();\n \n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_caller)\n@@ -3300,33 +3320,16 @@ handle_missing_profiles (void)\n bool\n counts_to_freqs (void)\n {\n-  gcov_type count_max;\n-  profile_count true_count_max = profile_count::zero ();\n+  profile_count true_count_max = profile_count::uninitialized ();\n   basic_block bb;\n \n-  /* Don't overwrite the estimated frequencies when the profile for\n-     the function is missing.  We may drop this function PROFILE_GUESSED\n-     later in drop_profile ().  */\n-  if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ()\n-      || ENTRY_BLOCK_PTR_FOR_FN (cfun)->count == profile_count::zero ())\n-    return false;\n-\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    if (bb->count > true_count_max)\n-      true_count_max = bb->count;\n-\n-  /* If we have no counts to base frequencies on, keep those that are\n-     already there.  */\n-  if (!(true_count_max > 0))\n-    return false;\n+    if (!(bb->count < true_count_max))\n+      true_count_max = true_count_max.max (bb->count);\n \n-  count_max = true_count_max.to_gcov_type ();\n-\n-  FOR_ALL_BB_FN (bb, cfun)\n-    if (bb->count.initialized_p ())\n-      bb->frequency = RDIV (bb->count.to_gcov_type () * BB_FREQ_MAX, count_max);\n+  cfun->cfg->count_max = true_count_max;\n \n-  return true;\n+  return true_count_max.nonzero_p ();\n }\n \n /* Return true if function is likely to be expensive, so there is no point to\n@@ -3348,19 +3351,19 @@ expensive_function_p (int threshold)\n   /* Frequencies are out of range.  This either means that function contains\n      internal loop executing more than BB_FREQ_MAX times or profile feedback\n      is available and function has not been executed at all.  */\n-  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency == 0)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun) == 0)\n     return true;\n \n   /* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */\n-  limit = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency * threshold;\n+  limit = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun) * threshold;\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       rtx_insn *insn;\n \n       FOR_BB_INSNS (bb, insn)\n \tif (active_insn_p (insn))\n \t  {\n-\t    sum += bb->frequency;\n+\t    sum += bb->count.to_frequency (cfun);\n \t    if (sum > limit)\n \t      return true;\n \t}\n@@ -3409,7 +3412,6 @@ propagate_unlikely_bbs_forward (void)\n \t\t     \"Basic block %i is marked unlikely by forward prop\\n\",\n \t\t     bb->index);\n \t  bb->count = profile_count::zero ();\n-\t  bb->frequency = 0;\n \t}\n       else\n         bb->aux = NULL;\n@@ -3440,9 +3442,6 @@ determine_unlikely_bbs ()\n \t  bb->count = profile_count::zero ();\n \t}\n \n-      if (bb->count == profile_count::zero ())\n-        bb->frequency = 0;\n-\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (!(e->probability == profile_probability::never ())\n \t    && unlikely_executed_edge_p (e))\n@@ -3497,7 +3496,6 @@ determine_unlikely_bbs ()\n \t\t \"Basic block %i is marked unlikely by backward prop\\n\",\n \t\t bb->index);\n       bb->count = profile_count::zero ();\n-      bb->frequency = 0;\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (!(e->probability == profile_probability::never ()))\n \t  {\n@@ -3554,8 +3552,13 @@ estimate_bb_frequencies (bool force)\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      EDGE_INFO (e)->back_edge_prob\n-\t\t = e->probability.to_reg_br_prob_base ();\n+\t      /* FIXME: Graphite is producing edges with no profile. Once\n+\t\t this is fixed, drop this.  */\n+\t      if (e->probability.initialized_p ())\n+\t        EDGE_INFO (e)->back_edge_prob\n+\t\t   = e->probability.to_reg_br_prob_base ();\n+\t      else\n+\t\tEDGE_INFO (e)->back_edge_prob = REG_BR_PROB_BASE / 2;\n \t      EDGE_INFO (e)->back_edge_prob *= real_inv_br_prob_base;\n \t    }\n \t}\n@@ -3564,16 +3567,28 @@ estimate_bb_frequencies (bool force)\n          to outermost to examine frequencies for back edges.  */\n       estimate_loops ();\n \n+      bool global0 = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ()\n+\t\t     && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa_p ();\n+\n       freq_max = 0;\n       FOR_EACH_BB_FN (bb, cfun)\n \tif (freq_max < BLOCK_INFO (bb)->frequency)\n \t  freq_max = BLOCK_INFO (bb)->frequency;\n \n       freq_max = real_bb_freq_max / freq_max;\n+      cfun->cfg->count_max = profile_count::uninitialized ();\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n \t  sreal tmp = BLOCK_INFO (bb)->frequency * freq_max + real_one_half;\n-\t  bb->frequency = tmp.to_int ();\n+\t  profile_count count = profile_count::from_gcov_type (tmp.to_int ());\t\n+\n+\t  /* If we have profile feedback in which this function was never\n+\t     executed, then preserve this info.  */\n+\t  if (global0)\n+\t    bb->count = count.global0 ();\n+\t  else if (!(bb->count == profile_count::zero ()))\n+\t    bb->count = count.guessed_local ();\n+          cfun->cfg->count_max = cfun->cfg->count_max.max (bb->count);\n \t}\n \n       free_aux_for_blocks ();\n@@ -3598,7 +3613,8 @@ compute_function_frequency (void)\n   if (profile_status_for_fn (cfun) != PROFILE_READ)\n     {\n       int flags = flags_from_decl_or_type (current_function_decl);\n-      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count == profile_count::zero ()\n+      if ((ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa_p ()\n+\t   && ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa() == profile_count::zero ())\n \t  || lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl))\n \t     != NULL)\n \t{\n@@ -3717,7 +3733,7 @@ pass_profile::execute (function *fun)\n    {\n      struct loop *loop;\n      FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n-       if (loop->header->frequency)\n+       if (loop->header->count.initialized_p ())\n          fprintf (dump_file, \"Loop got predicted %d to iterate %i times.\\n\",\n        \t   loop->num,\n        \t   (int)expected_loop_iterations_unbounded (loop));\n@@ -3843,15 +3859,12 @@ rebuild_frequencies (void)\n      which may also lead to frequencies incorrectly reduced to 0. There\n      is less precision in the probabilities, so we only do this for small\n      max counts.  */\n-  profile_count count_max = profile_count::zero ();\n+  cfun->cfg->count_max = profile_count::uninitialized ();\n   basic_block bb;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    if (bb->count > count_max)\n-      count_max = bb->count;\n+    cfun->cfg->count_max = cfun->cfg->count_max.max (bb->count);\n \n-  if (profile_status_for_fn (cfun) == PROFILE_GUESSED\n-      || (!flag_auto_profile && profile_status_for_fn (cfun) == PROFILE_READ\n-\t  && count_max < REG_BR_PROB_BASE / 10))\n+  if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n     {\n       loop_optimizer_init (0);\n       add_noreturn_fake_exit_edges ();\n@@ -4017,17 +4030,19 @@ force_edge_cold (edge e, bool impossible)\n \t after loop transforms.  */\n       if (!(prob_sum > profile_probability::never ())\n \t  && count_sum == profile_count::zero ()\n-\t  && single_pred_p (e->src) && e->src->frequency > (impossible ? 0 : 1))\n+\t  && single_pred_p (e->src) && e->src->count.to_frequency (cfun)\n+\t     > (impossible ? 0 : 1))\n \t{\n-\t  int old_frequency = e->src->frequency;\n+\t  int old_frequency = e->src->count.to_frequency (cfun);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Making bb %i %s.\\n\", e->src->index,\n \t\t     impossible ? \"impossible\" : \"cold\");\n-\t  e->src->frequency = MIN (e->src->frequency, impossible ? 0 : 1);\n+\t  int new_frequency = MIN (e->src->count.to_frequency (cfun),\n+\t\t\t\t   impossible ? 0 : 1);\n \t  if (impossible)\n \t    e->src->count = profile_count::zero ();\n \t  else\n-\t    e->src->count = e->count ().apply_scale (e->src->frequency,\n+\t    e->src->count = e->count ().apply_scale (new_frequency,\n \t\t\t\t\t\t     old_frequency);\n \t  force_edge_cold (single_pred_edge (e->src), impossible);\n \t}"}, {"sha": "d70314046452db2e15345de25d7d5ae58746ad12", "filename": "gcc/profile-count.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -42,7 +42,11 @@ profile_count::dump (FILE *f) const\n   else\n     {\n       fprintf (f, \"%\" PRId64, m_val);\n-      if (m_quality == profile_adjusted)\n+      if (m_quality == profile_guessed_local)\n+\tfprintf (f, \" (estimated locally)\");\n+      else if (m_quality == profile_guessed_global0)\n+\tfprintf (f, \" (estimated locally, globally 0)\");\n+      else if (m_quality == profile_adjusted)\n \tfprintf (f, \" (adjusted)\");\n       else if (m_quality == profile_afdo)\n \tfprintf (f, \" (auto FDO)\");\n@@ -65,6 +69,7 @@ profile_count::debug () const\n bool\n profile_count::differs_from_p (profile_count other) const\n {\n+  gcc_checking_assert (compatible_p (other));\n   if (!initialized_p () || !other.initialized_p ())\n     return false;\n   if ((uint64_t)m_val - (uint64_t)other.m_val < 100\n@@ -213,3 +218,40 @@ slow_safe_scale_64bit (uint64_t a, uint64_t b, uint64_t c, uint64_t *res)\n   *res = (uint64_t) -1;\n   return false;\n }\n+\n+/* Return count as frequency within FUN scaled in range 0 to REG_FREQ_MAX\n+   Used for legacy code and should not be used anymore.  */\n+\n+int\n+profile_count::to_frequency (struct function *fun) const\n+{\n+  if (!initialized_p ())\n+    return BB_FREQ_MAX;\n+  if (*this == profile_count::zero ())\n+    return 0;\n+  gcc_assert (REG_BR_PROB_BASE == BB_FREQ_MAX\n+\t      && fun->cfg->count_max.initialized_p ());\n+  profile_probability prob = probability_in (fun->cfg->count_max);\n+  if (!prob.initialized_p ())\n+    return REG_BR_PROB_BASE;\n+  return prob.to_reg_br_prob_base ();\n+}\n+\n+/* Return count as frequency within FUN scaled in range 0 to CGRAPH_FREQ_MAX\n+   where CGRAPH_FREQ_BASE means that count equals to entry block count.\n+   Used for legacy code and should not be used anymore.  */\n+\n+int\n+profile_count::to_cgraph_frequency (profile_count entry_bb_count) const\n+{\n+  if (!initialized_p ())\n+    return CGRAPH_FREQ_BASE;\n+  if (*this == profile_count::zero ())\n+    return 0;\n+  gcc_checking_assert (entry_bb_count.initialized_p ());\n+  uint64_t scale;\n+  if (!safe_scale_64bit (!entry_bb_count.m_val ? m_val + 1 : m_val,\n+\t\t\t CGRAPH_FREQ_BASE, MAX (1, entry_bb_count.m_val), &scale))\n+    return CGRAPH_FREQ_MAX;\n+  return MIN (scale, CGRAPH_FREQ_MAX);\n+}"}, {"sha": "d793d11c830db216db5f0152570c5058b8060ab0", "filename": "gcc/profile-count.h", "status": "modified", "additions": 199, "deletions": 31, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -21,21 +21,37 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_PROFILE_COUNT_H\n #define GCC_PROFILE_COUNT_H\n \n+struct function;\n+\n /* Quality of the profile count.  Because gengtype does not support enums\n    inside of classes, this is in global namespace.  */\n enum profile_quality {\n+  /* Profile is based on static branch prediction heuristics and may\n+     or may not match reality.  It is local to function and can not be compared\n+     inter-procedurally.  Never used by probabilities (they are always local).\n+   */\n+  profile_guessed_local = 0,\n+  /* Profile was read by feedback and was 0, we used local heuristics to guess\n+     better.  This is the case of functions not run in profile fedback.\n+     Never used by probabilities.  */\n+  profile_guessed_global0 = 1,\n+\n+\n   /* Profile is based on static branch prediction heuristics.  It may or may\n-     not reflect the reality.  */\n-  profile_guessed = 0,\n+     not reflect the reality but it can be compared interprocedurally\n+     (for example, we inlined function w/o profile feedback into function\n+      with feedback and propagated from that).\n+     Never used by probablities.  */\n+  profile_guessed = 2,\n   /* Profile was determined by autofdo.  */\n-  profile_afdo = 1,\n+  profile_afdo = 3,\n   /* Profile was originally based on feedback but it was adjusted\n      by code duplicating optimization.  It may not precisely reflect the\n      particular code path.  */\n-  profile_adjusted = 2,\n+  profile_adjusted = 4,\n   /* Profile was read from profile feedback or determined by accurate static\n      method.  */\n-  profile_precise = 3\n+  profile_precise = 5\n };\n \n /* The base value for branch probability notes and edge probabilities.  */\n@@ -114,15 +130,15 @@ safe_scale_64bit (uint64_t a, uint64_t b, uint64_t c, uint64_t *res)\n \n class GTY((user)) profile_probability\n {\n-  static const int n_bits = 30;\n+  static const int n_bits = 29;\n   /* We can technically use ((uint32_t) 1 << (n_bits - 1)) - 2 but that\n      will lead to harder multiplication sequences.  */\n   static const uint32_t max_probability = (uint32_t) 1 << (n_bits - 2);\n   static const uint32_t uninitialized_probability\n \t\t = ((uint32_t) 1 << (n_bits - 1)) - 1;\n \n-  uint32_t m_val : 30;\n-  enum profile_quality m_quality : 2;\n+  uint32_t m_val : 29;\n+  enum profile_quality m_quality : 3;\n \n   friend class profile_count;\n public:\n@@ -226,14 +242,14 @@ class GTY((user)) profile_probability\n   static profile_probability from_reg_br_prob_note (int v)\n     {\n       profile_probability ret;\n-      ret.m_val = ((unsigned int)v) / 4;\n-      ret.m_quality = (enum profile_quality)(v & 3);\n+      ret.m_val = ((unsigned int)v) / 8;\n+      ret.m_quality = (enum profile_quality)(v & 7);\n       return ret;\n     }\n   int to_reg_br_prob_note () const\n     {\n       gcc_checking_assert (initialized_p ());\n-      int ret = m_val * 4 + m_quality;\n+      int ret = m_val * 8 + m_quality;\n       gcc_checking_assert (profile_probability::from_reg_br_prob_note (ret)\n \t\t\t   == *this);\n       return ret;\n@@ -489,8 +505,9 @@ class GTY((user)) profile_probability\n     {\n       if (m_val == uninitialized_probability)\n \treturn m_quality == profile_guessed;\n-      else\n-\treturn m_val <= max_probability;\n+      else if (m_quality < profile_guessed)\n+\treturn false;\n+      return m_val <= max_probability;\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n@@ -530,9 +547,32 @@ class GTY((user)) profile_probability\n   void stream_out (struct lto_output_stream *);\n };\n \n-/* Main data type to hold profile counters in GCC.  In most cases profile\n-   counts originate from profile feedback. They are 64bit integers\n-   representing number of executions during the train run.\n+/* Main data type to hold profile counters in GCC. Profile counts originate\n+   either from profile feedback, static profile estimation or both.  We do not\n+   perform whole program profile propagation and thus profile estimation\n+   counters are often local to function, while counters from profile feedback\n+   (or special cases of profile estimation) can be used inter-procedurally.\n+\n+   There are 3 basic types\n+     1) local counters which are result of intra-procedural static profile\n+        estimation.\n+     2) ipa counters which are result of profile feedback or special case\n+        of static profile estimation (such as in function main).\n+     3) counters which counts as 0 inter-procedurally (beause given function\n+        was never run in train feedback) but they hold local static profile\n+        estimate.\n+\n+   Counters of type 1 and 3 can not be mixed with counters of different type\n+   within operation (because whole function should use one type of counter)\n+   with exception that global zero mix in most operations where outcome is\n+   well defined.\n+\n+   To take local counter and use it inter-procedurally use ipa member function\n+   which strips information irelevant at the inter-procedural level.\n+\n+   Counters are 61bit integers representing number of executions during the\n+   train run or normalized frequency within the function.\n+\n    As the profile is maintained during the compilation, many adjustments are\n    made.  Not all transformations can be made precisely, most importantly\n    when code is being duplicated.  It also may happen that part of CFG has\n@@ -567,12 +607,25 @@ class GTY(()) profile_count\n      64bit.  Although a counter cannot be negative, we use a signed\n      type to hold various extra stages.  */\n \n-  static const int n_bits = 62;\n+  static const int n_bits = 61;\n   static const uint64_t max_count = ((uint64_t) 1 << n_bits) - 2;\n   static const uint64_t uninitialized_count = ((uint64_t) 1 << n_bits) - 1;\n \n   uint64_t m_val : n_bits;\n-  enum profile_quality m_quality : 2;\n+  enum profile_quality m_quality : 3;\n+\n+  /* Return true if both values can meaningfully appear in single function\n+     body.  We have either all counters in function local or global, otherwise\n+     operations between them are not really defined well.  */\n+  bool compatible_p (const profile_count other) const\n+    {\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn true;\n+      if (*this == profile_count::zero ()\n+\t  || other == profile_count::zero ())\n+\treturn true;\n+      return ipa_p () == other.ipa_p ();\n+    }\n public:\n \n   /* Used for counters which are expected to be never executed.  */\n@@ -597,7 +650,7 @@ class GTY(()) profile_count\n     {\n       profile_count c;\n       c.m_val = uninitialized_count;\n-      c.m_quality = profile_guessed;\n+      c.m_quality = profile_guessed_local;\n       return c;\n     }\n \n@@ -630,6 +683,11 @@ class GTY(()) profile_count\n     {\n       return m_quality >= profile_adjusted;\n     }\n+  /* Return true if vlaue can be operated inter-procedurally.  */\n+  bool ipa_p () const\n+    {\n+      return !initialized_p () || m_quality >= profile_guessed_global0;\n+    }\n \n   /* When merging basic blocks, the two different profile counts are unified.\n      Return true if this can be done without losing info about profile.\n@@ -671,6 +729,7 @@ class GTY(()) profile_count\n \treturn profile_count::uninitialized ();\n \n       profile_count ret;\n+      gcc_checking_assert (compatible_p (other));\n       ret.m_val = m_val + other.m_val;\n       ret.m_quality = MIN (m_quality, other.m_quality);\n       return ret;\n@@ -688,6 +747,7 @@ class GTY(()) profile_count\n \treturn *this = profile_count::uninitialized ();\n       else\n \t{\n+          gcc_checking_assert (compatible_p (other));\n \t  m_val += other.m_val;\n \t  m_quality = MIN (m_quality, other.m_quality);\n \t}\n@@ -699,6 +759,7 @@ class GTY(()) profile_count\n \treturn *this;\n       if (!initialized_p () || !other.initialized_p ())\n \treturn profile_count::uninitialized ();\n+      gcc_checking_assert (compatible_p (other));\n       profile_count ret;\n       ret.m_val = m_val >= other.m_val ? m_val - other.m_val : 0;\n       ret.m_quality = MIN (m_quality, other.m_quality);\n@@ -712,6 +773,7 @@ class GTY(()) profile_count\n \treturn *this = profile_count::uninitialized ();\n       else\n \t{\n+          gcc_checking_assert (compatible_p (other));\n \t  m_val = m_val >= other.m_val ? m_val - other.m_val: 0;\n \t  m_quality = MIN (m_quality, other.m_quality);\n \t}\n@@ -721,48 +783,115 @@ class GTY(()) profile_count\n   /* Return false if profile_count is bogus.  */\n   bool verify () const\n     {\n-      return m_val != uninitialized_count || m_quality == profile_guessed;\n+      return m_val != uninitialized_count || m_quality == profile_guessed_local;\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n      the inequality can not be decided.  */\n   bool operator< (const profile_count &other) const\n     {\n-      return initialized_p () && other.initialized_p () && m_val < other.m_val;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn false;\n+      if (*this == profile_count::zero ())\n+\treturn !(other == profile_count::zero ());\n+      if (other == profile_count::zero ())\n+\treturn false;\n+      gcc_checking_assert (compatible_p (other));\n+      return m_val < other.m_val;\n     }\n   bool operator> (const profile_count &other) const\n     {\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn false;\n+      if (*this  == profile_count::zero ())\n+\treturn false;\n+      if (other == profile_count::zero ())\n+\treturn !(*this == profile_count::zero ());\n+      gcc_checking_assert (compatible_p (other));\n       return initialized_p () && other.initialized_p () && m_val > other.m_val;\n     }\n   bool operator< (const gcov_type other) const\n     {\n+      gcc_checking_assert (ipa_p ());\n       gcc_checking_assert (other >= 0);\n       return initialized_p () && m_val < (uint64_t) other;\n     }\n   bool operator> (const gcov_type other) const\n     {\n+      gcc_checking_assert (ipa_p ());\n       gcc_checking_assert (other >= 0);\n       return initialized_p () && m_val > (uint64_t) other;\n     }\n \n   bool operator<= (const profile_count &other) const\n     {\n-      return initialized_p () && other.initialized_p () && m_val <= other.m_val;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn false;\n+      if (*this == profile_count::zero ())\n+\treturn true;\n+      if (other == profile_count::zero ())\n+\treturn (*this == profile_count::zero ());\n+      gcc_checking_assert (compatible_p (other));\n+      return m_val <= other.m_val;\n     }\n   bool operator>= (const profile_count &other) const\n     {\n-      return initialized_p () && other.initialized_p () && m_val >= other.m_val;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn false;\n+      if (other == profile_count::zero ())\n+\treturn true;\n+      if (*this == profile_count::zero ())\n+\treturn !(other == profile_count::zero ());\n+      gcc_checking_assert (compatible_p (other));\n+      return m_val >= other.m_val;\n     }\n   bool operator<= (const gcov_type other) const\n     {\n+      gcc_checking_assert (ipa_p ());\n       gcc_checking_assert (other >= 0);\n       return initialized_p () && m_val <= (uint64_t) other;\n     }\n   bool operator>= (const gcov_type other) const\n     {\n+      gcc_checking_assert (ipa_p ());\n       gcc_checking_assert (other >= 0);\n       return initialized_p () && m_val >= (uint64_t) other;\n     }\n+  /* Return true when value is not zero and can be used for scaling. \n+     This is different from *this > 0 because that requires counter to\n+     be IPA.  */\n+  bool nonzero_p () const\n+    {\n+      return initialized_p () && m_val != 0;\n+    }\n+\n+  /* Make counter forcingly nonzero.  */\n+  profile_count force_nonzero () const\n+    {\n+      if (!initialized_p ())\n+\treturn *this;\n+      profile_count ret = *this;\n+      if (ret.m_val == 0)\n+\tret.m_val = 1;\n+      return ret;\n+    }\n+\n+  profile_count max (profile_count other) const\n+    {\n+      if (!initialized_p ())\n+\treturn other;\n+      if (!other.initialized_p ())\n+\treturn *this;\n+      if (*this == profile_count::zero ())\n+\treturn other;\n+      if (other == profile_count::zero ())\n+\treturn *this;\n+      gcc_checking_assert (compatible_p (other));\n+      if (m_val < other.m_val || (m_val == other.m_val\n+\t\t\t\t  && m_quality < other.m_quality))\n+\treturn other;\n+      return *this;\n+    }\n \n   /* PROB is a probability in scale 0...REG_BR_PROB_BASE.  Scale counter\n      accordingly.  */\n@@ -814,32 +943,66 @@ class GTY(()) profile_count\n     }\n   profile_count apply_scale (profile_count num, profile_count den) const\n     {\n-      if (m_val == 0)\n+      if (*this == profile_count::zero ())\n \treturn *this;\n-      if (num.m_val == 0)\n+      if (num == profile_count::zero ())\n \treturn num;\n       if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n \treturn profile_count::uninitialized ();\n-      gcc_checking_assert (den > 0);\n+      gcc_checking_assert (den.m_val);\n       if (num == den)\n \treturn *this;\n \n       profile_count ret;\n       uint64_t val;\n       safe_scale_64bit (m_val, num.m_val, den.m_val, &val);\n       ret.m_val = MIN (val, max_count);\n-      ret.m_quality = MIN (m_quality, profile_adjusted);\n+      ret.m_quality = MIN (MIN (MIN (m_quality, profile_adjusted),\n+\t\t\t        num.m_quality), den.m_quality);\n+      if (num.ipa_p () && !ret.ipa_p ())\n+\tret.m_quality = MIN (num.m_quality, profile_guessed);\n+      return ret;\n+    }\n+\n+  /* Return THIS with quality dropped to GUESSED_LOCAL.  */\n+  profile_count guessed_local () const\n+    {\n+      profile_count ret = *this;\n+      if (!initialized_p ())\n+\treturn *this;\n+      ret.m_quality = profile_guessed_local;\n+      return ret;\n+    }\n+\n+  /* We know that profile is globally0 but keep local profile if present.  */\n+  profile_count global0 () const\n+    {\n+      profile_count ret = *this;\n+      if (!initialized_p ())\n+\treturn *this;\n+      ret.m_quality = profile_guessed_global0;\n       return ret;\n     }\n \n   /* Return THIS with quality dropped to GUESSED.  */\n   profile_count guessed () const\n     {\n       profile_count ret = *this;\n-      ret.m_quality = profile_guessed;\n+      ret.m_quality = MIN (ret.m_quality, profile_guessed);\n       return ret;\n     }\n \n+  /* Return variant of profile counte which is always safe to compare\n+     acorss functions.  */\n+  profile_count ipa () const\n+    {\n+      if (m_quality > profile_guessed_global0)\n+\treturn *this;\n+      if (m_quality == profile_guessed_global0)\n+\treturn profile_count::zero ();\n+      return profile_count::uninitialized ();\n+    }\n+\n   /* Return THIS with quality dropped to AFDO.  */\n   profile_count afdo () const\n     {\n@@ -852,21 +1015,26 @@ class GTY(()) profile_count\n      OVERALL.  */\n   profile_probability probability_in (const profile_count overall) const\n     {\n-      if (!m_val)\n+      if (*this == profile_count::zero ())\n \treturn profile_probability::never ();\n       if (!initialized_p () || !overall.initialized_p ()\n \t  || !overall.m_val)\n \treturn profile_probability::uninitialized ();\n       profile_probability ret;\n-      if (overall < m_val)\n+      gcc_checking_assert (compatible_p (overall));\n+\n+      if (overall.m_val < m_val)\n \tret.m_val = profile_probability::max_probability;\n       else\n \tret.m_val = RDIV (m_val * profile_probability::max_probability,\n \t\t\t  overall.m_val);\n-      ret.m_quality = MIN (m_quality, overall.m_quality);\n+      ret.m_quality = MAX (MIN (m_quality, overall.m_quality), profile_guessed);\n       return ret;\n     }\n \n+  int to_frequency (struct function *fun) const;\n+  int to_cgraph_frequency (profile_count entry_bb_count) const;\n+\n   /* Output THIS to F.  */\n   void dump (FILE *f) const;\n "}, {"sha": "2b30a9e67543e82b1b151e0045938933495130d3", "filename": "gcc/profile.c", "status": "modified", "additions": 11, "deletions": 43, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -476,38 +476,6 @@ read_profile_edge_counts (gcov_type *exec_counts)\n     return num_edges;\n }\n \n-#define OVERLAP_BASE 10000\n-\n-/* Compare the static estimated profile to the actual profile, and\n-   return the \"degree of overlap\" measure between them.\n-\n-   Degree of overlap is a number between 0 and OVERLAP_BASE. It is\n-   the sum of each basic block's minimum relative weights between\n-   two profiles. And overlap of OVERLAP_BASE means two profiles are\n-   identical.  */\n-\n-static int\n-compute_frequency_overlap (void)\n-{\n-  gcov_type count_total = 0, freq_total = 0;\n-  int overlap = 0;\n-  basic_block bb;\n-\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    {\n-      count_total += bb_gcov_count (bb);\n-      freq_total += bb->frequency;\n-    }\n-\n-  if (count_total == 0 || freq_total == 0)\n-    return 0;\n-\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    overlap += MIN (bb_gcov_count (bb) * OVERLAP_BASE / count_total,\n-\t\t    bb->frequency * OVERLAP_BASE / freq_total);\n-\n-  return overlap;\n-}\n \n /* Compute the branch probabilities for the various branches.\n    Annotate them accordingly.  \n@@ -676,14 +644,6 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t    }\n \t}\n     }\n-  if (dump_file)\n-    {\n-      int overlap = compute_frequency_overlap ();\n-      gimple_dump_cfg (dump_file, dump_flags);\n-      fprintf (dump_file, \"Static profile overlap: %d.%d%%\\n\",\n-\t       overlap / (OVERLAP_BASE / 100),\n-\t       overlap % (OVERLAP_BASE / 100));\n-    }\n \n   total_num_passes += passes;\n   if (dump_file)\n@@ -829,10 +789,18 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t}\n     }\n \n-  FOR_ALL_BB_FN (bb, cfun)\n-    {\n+  /* If we have real data, use them!  */\n+  if (bb_gcov_count (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+      || !flag_guess_branch_prob)\n+    FOR_ALL_BB_FN (bb, cfun)\n       bb->count = profile_count::from_gcov_type (bb_gcov_count (bb));\n-    }\n+  /* If function was not trained, preserve local estimates including statically\n+     determined zero counts.  */\n+  else\n+    FOR_ALL_BB_FN (bb, cfun)\n+      if (!(bb->count == profile_count::zero ()))\n+        bb->count = bb->count.global0 ();\n+\n   bb_gcov_counts.release ();\n   delete edge_gcov_counts;\n   edge_gcov_counts = NULL;"}, {"sha": "2dc94a929d36f37a8e5be7a0c0d93059257654fb", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -130,8 +130,10 @@ extern size_t reg_info_p_size;\n    frequency.  */\n #define REG_FREQ_FROM_BB(bb) (optimize_function_for_size_p (cfun)\t      \\\n \t\t\t      ? REG_FREQ_MAX\t\t\t\t      \\\n-\t\t\t      : ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n-\t\t\t      ? ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n+\t\t\t      : ((bb)->count.to_frequency (cfun)\t      \\\n+\t\t\t\t* REG_FREQ_MAX / BB_FREQ_MAX)\t\t      \\\n+\t\t\t      ? ((bb)->count.to_frequency (cfun)\t      \\\n+\t\t\t\t * REG_FREQ_MAX / BB_FREQ_MAX)\t\t      \\\n \t\t\t      : 1)\n \n /* Indexed by N, gives number of insns in which register N dies."}, {"sha": "e51749c60cc0443e2dfc8b73d735832c3d568076", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -231,11 +231,9 @@ rank (rtx_insn *insn1, rtx_insn *insn2)\n   basic_block bb1 = BLOCK_FOR_INSN (insn1);\n   basic_block bb2 = BLOCK_FOR_INSN (insn2);\n \n-  if (bb1->count > bb2->count\n-      || bb1->frequency > bb2->frequency)\n+  if (bb1->count > bb2->count)\n     return -1;\n-  if (bb1->count < bb2->count\n-      || bb1->frequency < bb2->frequency)\n+  if (bb1->count < bb2->count)\n     return 1;\n   return 0;\n }"}, {"sha": "0e4ff6cd46a028166a7eb07e90f491487e80b1ab", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -561,7 +561,7 @@ handle_simple_exit (edge e)\n       BB_END (old_bb) = end;\n \n       redirect_edge_succ (e, new_bb);\n-      new_bb->frequency = EDGE_FREQUENCY (e);\n+      new_bb->count = e->count ();\n       e->flags |= EDGE_FALLTHRU;\n \n       e = make_single_succ_edge (new_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n@@ -887,7 +887,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n     if (!dominated_by_p (CDI_DOMINATORS, e->src, pro))\n       {\n \tnum += EDGE_FREQUENCY (e);\n-\tden += e->src->frequency;\n+\tden += e->src->count.to_frequency (cfun);\n       }\n \n   if (den == 0)\n@@ -920,8 +920,6 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \tif (dump_file)\n \t  fprintf (dump_file, \"Duplicated %d to %d\\n\", bb->index, dup->index);\n \n-\tbb->frequency = RDIV (num * bb->frequency, den);\n-\tdup->frequency -= bb->frequency;\n \tbb->count = bb->count.apply_scale (num, den);\n \tdup->count -= bb->count;\n       }\n@@ -995,8 +993,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \t  continue;\n \t}\n \n-      new_bb->count += e->src->count.apply_probability (e->probability);\n-      new_bb->frequency += EDGE_FREQUENCY (e);\n+      new_bb->count += e->count ();\n \n       redirect_edge_and_branch_force (e, new_bb);\n       if (dump_file)\n@@ -1181,7 +1178,7 @@ place_prologue_for_one_component (unsigned int which, basic_block head)\n \t     work: this does not always add up to the block frequency at\n \t     all, and even if it does, rounding error makes for bad\n \t     decisions.  */\n-\t  SW (bb)->own_cost = bb->frequency;\n+\t  SW (bb)->own_cost = bb->count.to_frequency (cfun);\n \n \t  edge e;\n \t  edge_iterator ei;"}, {"sha": "ef5b1071384b4255bddc61244b6365e5dd167e5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1,3 +1,25 @@\n+2017-11-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/no-strict-overflow-3.c (foo): Update magic\n+\tvalue to not clash with frequency.\n+\t* gcc.dg/strict-overflow-3.c (foo): Likewise.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Update template.\n+\t* gcc.dg/tree-ssa/dump-2.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-10.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-11.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-12.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-20040816-1.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-20040816-2.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-5.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-8.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-9.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-cd.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-pr56541.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-pr68583.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-pr69489-1.c: Update template.\n+\t* gcc.dg/tree-ssa/ifc-pr69489-2.c: Update template.\n+\t* gcc.target/i386/pr61403.c: Update template.\n+\n 2017-11-03  Nathan Sidwell  <nathan@acm.org>\n \n \t* lib/scanlang.exp: Fix error message to refer to scan-lang-dump."}, {"sha": "d68008a3ddeea031b0328e5758090e6672889c38", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -9,7 +9,7 @@\n int\n foo (int i, int j)\n {\n-  return i + 100 < j + 1000;\n+  return i + 100 < j + 1234;\n }\n \n-/* { dg-final { scan-tree-dump \"1000\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"1234\" \"optimized\" } } */"}, {"sha": "8ef914762007f8d834bdca001f5a412b003b55d0", "filename": "gcc/testsuite/gcc.dg/strict-overflow-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -9,7 +9,7 @@\n int\n foo (int i, int j)\n {\n-  return i + 100 < j + 1000;\n+  return i + 100 < j + 1234;\n }\n \n-/* { dg-final { scan-tree-dump-not \"1000\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"1234\" \"optimized\" } } */"}, {"sha": "75d3db37ade4ac7cbfc23ec55a89e39b332ead29", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -290,7 +290,7 @@ RNG (0,  6,   8, \"%s%ls\", \"1\", L\"2\");\n \n /*  Only conditional calls to must_not_eliminate must be made (with\n     any probability):\n-    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\] \\\\\\[count: \\[0-9INV\\]*\\\\\\]:\\n *must_not_eliminate\" 127 \"optimized\" { target { ilp32 || lp64 } } } }\n-    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\] \\\\\\[count: \\[0-9INV\\]*\\\\\\]:\\n *must_not_eliminate\" 96 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } }\n+    { dg-final { scan-tree-dump-times \"> \\\\\\[local count: \\[0-9INV\\]*\\\\\\]:\\n *must_not_eliminate\" 127 \"optimized\" { target { ilp32 || lp64 } } } }\n+    { dg-final { scan-tree-dump-times \"> \\\\\\[local count: \\[0-9INV\\]*\\\\\\]:\\n *must_not_eliminate\" 96 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } }\n     No unconditional calls to abort should be made:\n     { dg-final { scan-tree-dump-not \";\\n *must_not_eliminate\" \"optimized\" } } */"}, {"sha": "20f99c2df12282bdd9ea6bd92c0d8d4934d5ad26", "filename": "gcc/testsuite/gcc.dg/tree-ssa/dump-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdump-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdump-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdump-2.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -6,4 +6,4 @@ int f(void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"<bb \\[0-9\\]> \\\\\\[100\\\\\\.00%\\\\\\] \\\\\\[count: INV\\\\\\]:\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"<bb \\[0-9\\]> \\\\\\[local count: 10000\\\\\\]:\" \"optimized\" } } */"}, {"sha": "75a8ab9b1d5b1c74cf478708e102858e012ae95e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -26,5 +26,5 @@ int foo (int x, int n)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 1 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */\n "}, {"sha": "10f3d534adcadefbf2c2dbd8e101532e357ed819", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-11.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-11.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -24,5 +24,4 @@ int foo (float *x)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "9468c070489bd29016eaeab5a895ad782bb33267", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-12.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-12.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -29,6 +29,5 @@ int foo (int x)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */\n "}, {"sha": "b55a533e374fba04cae76b1b56c3ed6a56111760", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-1.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -39,4 +39,4 @@ int main1 ()\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 1 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "9249f3020b731e028b8bbac1b09415f788066092", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-20040816-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-20040816-2.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -43,5 +43,4 @@ void foo(const int * __restrict__ zr_in,\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "35595aa98e381aaa92a986d13f3413cafd361a10", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-5.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -27,4 +27,4 @@ dct_unquantize_h263_inter_c (short *block, int n, int qscale, int nCoeffs)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 1 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "c200748650086ab315e1ff4914efe05b2944fac2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-8.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-8.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -22,5 +22,4 @@ void test ()\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "fce181e2feebfd02a26b68eceeca83429a0e738f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -26,4 +26,4 @@ int foo (int x, int n)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 1 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "4932cd75a13167a8d94752b5a91bd3919d5bb139", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-cd.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-cd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-cd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-cd.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -32,5 +32,4 @@ void foo (int *x1, int *x2, int *x3, int *x4, int *y)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "71d6398897adbd97e39b2c2961d927b47b52288f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-pr56541.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr56541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr56541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr56541.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -29,5 +29,4 @@ void foo()\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "6739fad9f6ca1fb314f77788bc0b504d0cf01e94", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-pr68583.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr68583.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr68583.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr68583.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -26,5 +26,5 @@ void foo (long *a)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 1 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */\n "}, {"sha": "a9f4ff669f8dfc22d3f6d27852ba6d654f42b107", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-pr69489-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-1.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -20,5 +20,4 @@ void foo (int a[], int b[])\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* Sum is wrong here, but not enough for error to be reported.  */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 0 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "c9e7c1b96ea1022d70fc8a304fbfb4ebf8f13c1d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-pr69489-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-2.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -21,4 +21,4 @@ foo (const char *u, const char *v, long n)\n    which is folded by vectorizer.  Both outgoing edges must have probability\n    100% so the resulting profile match after folding.  */\n /* { dg-final { scan-tree-dump-times \"Invalid sum of outgoing probabilities 200.0\" 1 \"ifcvt\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming frequencies\" 1 \"ifcvt\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum of incoming counts\" 1 \"ifcvt\" } } */"}, {"sha": "38ba4a1b1ecbba722f9a5dc8d1d2b06142a734c9", "filename": "gcc/testsuite/gcc.target/i386/pr61403.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr61403.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr61403.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr61403.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -23,4 +23,4 @@ norm (struct XYZ *in, struct XYZ *out, int size)\n     }\n }\n \n-/* { dg-final { scan-assembler \"blend\" } } */\n+/* { dg-final { scan-assembler \"rsqrtps\" } } */"}, {"sha": "58caf13b0de6be4036a07653fd28069ac68ea6d1", "filename": "gcc/tracer.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -179,7 +179,7 @@ find_best_predecessor (basic_block bb)\n   if (!best || ignore_bb_p (best->src))\n     return NULL;\n   if (EDGE_FREQUENCY (best) * REG_BR_PROB_BASE\n-      < bb->frequency * branch_ratio_cutoff)\n+      < bb->count.to_frequency (cfun) * branch_ratio_cutoff)\n     return NULL;\n   return best;\n }\n@@ -194,7 +194,7 @@ find_trace (basic_block bb, basic_block *trace)\n   edge e;\n \n   if (dump_file)\n-    fprintf (dump_file, \"Trace seed %i [%i]\", bb->index, bb->frequency);\n+    fprintf (dump_file, \"Trace seed %i [%i]\", bb->index, bb->count.to_frequency (cfun));\n \n   while ((e = find_best_predecessor (bb)) != NULL)\n     {\n@@ -203,11 +203,11 @@ find_trace (basic_block bb, basic_block *trace)\n \t  || find_best_successor (bb2) != e)\n \tbreak;\n       if (dump_file)\n-\tfprintf (dump_file, \",%i [%i]\", bb->index, bb->frequency);\n+\tfprintf (dump_file, \",%i [%i]\", bb->index, bb->count.to_frequency (cfun));\n       bb = bb2;\n     }\n   if (dump_file)\n-    fprintf (dump_file, \" forward %i [%i]\", bb->index, bb->frequency);\n+    fprintf (dump_file, \" forward %i [%i]\", bb->index, bb->count.to_frequency (cfun));\n   trace[i++] = bb;\n \n   /* Follow the trace in forward direction.  */\n@@ -218,7 +218,7 @@ find_trace (basic_block bb, basic_block *trace)\n \t  || find_best_predecessor (bb) != e)\n \tbreak;\n       if (dump_file)\n-\tfprintf (dump_file, \",%i [%i]\", bb->index, bb->frequency);\n+\tfprintf (dump_file, \",%i [%i]\", bb->index, bb->count.to_frequency (cfun));\n       trace[i++] = bb;\n     }\n   if (dump_file)\n@@ -282,11 +282,11 @@ tail_duplicate (void)\n     {\n       int n = count_insns (bb);\n       if (!ignore_bb_p (bb))\n-\tblocks[bb->index] = heap.insert (-bb->frequency, bb);\n+\tblocks[bb->index] = heap.insert (-bb->count.to_frequency (cfun), bb);\n \n       counts [bb->index] = n;\n       ninsns += n;\n-      weighted_insns += n * bb->frequency;\n+      weighted_insns += n * bb->count.to_frequency (cfun);\n     }\n \n   if (profile_info && profile_status_for_fn (cfun) == PROFILE_READ)\n@@ -314,7 +314,7 @@ tail_duplicate (void)\n       n = find_trace (bb, trace);\n \n       bb = trace[0];\n-      traced_insns += bb->frequency * counts [bb->index];\n+      traced_insns += bb->count.to_frequency (cfun) * counts [bb->index];\n       if (blocks[bb->index])\n \t{\n \t  heap.delete_node (blocks[bb->index]);\n@@ -330,7 +330,7 @@ tail_duplicate (void)\n \t      heap.delete_node (blocks[bb2->index]);\n \t      blocks[bb2->index] = NULL;\n \t    }\n-\t  traced_insns += bb2->frequency * counts [bb2->index];\n+\t  traced_insns += bb2->count.to_frequency (cfun) * counts [bb2->index];\n \t  if (EDGE_COUNT (bb2->preds) > 1\n \t      && can_duplicate_block_p (bb2)\n \t      /* We have the tendency to duplicate the loop header\n@@ -345,11 +345,11 @@ tail_duplicate (void)\n \t      /* Reconsider the original copy of block we've duplicated.\n \t         Removing the most common predecessor may make it to be\n \t         head.  */\n-\t      blocks[bb2->index] = heap.insert (-bb2->frequency, bb2);\n+\t      blocks[bb2->index] = heap.insert (-bb2->count.to_frequency (cfun), bb2);\n \n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Duplicated %i as %i [%i]\\n\",\n-\t\t\t bb2->index, copy->index, copy->frequency);\n+\t\t\t bb2->index, copy->index, copy->count.to_frequency (cfun));\n \n \t      bb2 = copy;\n \t      changed = true;"}, {"sha": "ef5655aa61accd6f57add491afea97dac92663a7", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -2932,15 +2932,13 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       edge ef = make_edge (test_bb, join_bb, EDGE_FALSE_VALUE);\n       redirect_edge_pred (fallthru_edge, join_bb);\n \n-      join_bb->frequency = test_bb->frequency = transaction_bb->frequency;\n       join_bb->count = test_bb->count = transaction_bb->count;\n \n       ei->probability = profile_probability::always ();\n       et->probability = profile_probability::likely ();\n       ef->probability = profile_probability::unlikely ();\n \n       code_bb->count = et->count ();\n-      code_bb->frequency = EDGE_FREQUENCY (et);\n \n       transaction_bb = join_bb;\n     }\n@@ -2964,7 +2962,6 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n       edge ei = make_edge (transaction_bb, test_bb, EDGE_FALLTHRU);\n-      test_bb->frequency = transaction_bb->frequency;\n       test_bb->count = transaction_bb->count;\n       ei->probability = profile_probability::always ();\n \n@@ -3006,7 +3003,6 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       edge e = make_edge (transaction_bb, test_bb, fallthru_edge->flags);\n       e->probability = fallthru_edge->probability;\n       test_bb->count = fallthru_edge->count ();\n-      test_bb->frequency = EDGE_FREQUENCY (e);\n \n       // Now update the edges to the inst/uninist implementations.\n       // For now assume that the paths are equally likely.  When using HTM,"}, {"sha": "02c89cce62ffd09890e218cd42277285e2a8d79b", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -906,7 +906,6 @@ shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n      Here we take the second approach because it's slightly simpler\n      and because it's easy to see that it doesn't lose profile counts.  */\n   bi_call_bb->count = profile_count::zero ();\n-  bi_call_bb->frequency = 0;\n   while (!edges.is_empty ())\n     {\n       edge_pair e = edges.pop ();\n@@ -919,16 +918,10 @@ shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n       nocall_edge->probability = profile_probability::always ()\n \t\t\t\t - call_edge->probability;\n \n-      unsigned int call_frequency\n-\t = call_edge->probability.apply (src_bb->frequency);\n-\n       bi_call_bb->count += call_edge->count ();\n-      bi_call_bb->frequency += call_frequency;\n \n       if (nocall_edge->dest != join_tgt_bb)\n-\t{\n-\t  nocall_edge->dest->frequency = src_bb->frequency - call_frequency;\n-\t}\n+\tnocall_edge->dest->count = src_bb->count - bi_call_bb->count;\n     }\n \n   if (dom_info_available_p (CDI_DOMINATORS))"}, {"sha": "def3f0b8d9bc49359af52fe69d9716dc5e746f8d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 21, "deletions": 58, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1071,7 +1071,6 @@ gimple_find_sub_bbs (gimple_seq seq, gimple_stmt_iterator *gsi)\n       tree_guess_outgoing_edge_probabilities (bb);\n       if (all || profile_status_for_fn (cfun) == PROFILE_READ)\n         bb->count = cnt;\n-      bb->frequency = freq;\n \n       bb = bb->next_bb;\n     }\n@@ -2081,7 +2080,6 @@ gimple_merge_blocks (basic_block a, basic_block b)\n   if (a->loop_father == b->loop_father)\n     {\n       a->count = a->count.merge (b->count);\n-      a->frequency = MAX (a->frequency, b->frequency);\n     }\n \n   /* Merge the sequences.  */\n@@ -2840,7 +2838,6 @@ gimple_split_edge (edge edge_in)\n   after_bb = split_edge_bb_loc (edge_in);\n \n   new_bb = create_empty_bb (after_bb);\n-  new_bb->frequency = EDGE_FREQUENCY (edge_in);\n   new_bb->count = edge_in->count ();\n \n   e = redirect_edge_and_branch (edge_in, new_bb);\n@@ -6306,9 +6303,8 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n   bool free_region_copy = false, copying_header = false;\n   struct loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n-  vec<basic_block> doms;\n+  vec<basic_block> doms = vNULL;\n   edge redirected;\n-  int total_freq = 0, entry_freq = 0;\n   profile_count total_count = profile_count::uninitialized ();\n   profile_count entry_count = profile_count::uninitialized ();\n \n@@ -6376,34 +6372,17 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n       if (entry_count > total_count)\n \tentry_count = total_count;\n     }\n-  if (!(total_count > 0) || !(entry_count > 0))\n-    {\n-      total_freq = entry->dest->frequency;\n-      entry_freq = EDGE_FREQUENCY (entry);\n-      /* Fix up corner cases, to avoid division by zero or creation of negative\n-\t frequencies.  */\n-      if (total_freq == 0)\n-\ttotal_freq = 1;\n-      else if (entry_freq > total_freq)\n-\tentry_freq = total_freq;\n-    }\n \n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n \t    split_edge_bb_loc (entry), update_dominance);\n-  if (total_count > 0 && entry_count > 0)\n+  if (total_count.initialized_p () && entry_count.initialized_p ())\n     {\n       scale_bbs_frequencies_profile_count (region, n_region,\n \t\t\t\t           total_count - entry_count,\n \t\t\t\t           total_count);\n       scale_bbs_frequencies_profile_count (region_copy, n_region, entry_count,\n \t\t\t\t           total_count);\n     }\n-  else\n-    {\n-      scale_bbs_frequencies_int (region, n_region, total_freq - entry_freq,\n-\t\t\t\t total_freq);\n-      scale_bbs_frequencies_int (region_copy, n_region, entry_freq, total_freq);\n-    }\n \n   if (copying_header)\n     {\n@@ -6492,7 +6471,6 @@ gimple_duplicate_sese_tail (edge entry, edge exit,\n   struct loop *orig_loop = entry->dest->loop_father;\n   basic_block switch_bb, entry_bb, nentry_bb;\n   vec<basic_block> doms;\n-  int total_freq = 0, exit_freq = 0;\n   profile_count total_count = profile_count::uninitialized (),\n \t\texit_count = profile_count::uninitialized ();\n   edge exits[2], nexits[2], e;\n@@ -6537,43 +6515,23 @@ gimple_duplicate_sese_tail (edge entry, edge exit,\n      inside.  */\n   doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n \n-  if (exit->src->count > 0)\n-    {\n-      total_count = exit->src->count;\n-      exit_count = exit->count ();\n-      /* Fix up corner cases, to avoid division by zero or creation of negative\n-\t frequencies.  */\n-      if (exit_count > total_count)\n-\texit_count = total_count;\n-    }\n-  else\n-    {\n-      total_freq = exit->src->frequency;\n-      exit_freq = EDGE_FREQUENCY (exit);\n-      /* Fix up corner cases, to avoid division by zero or creation of negative\n-\t frequencies.  */\n-      if (total_freq == 0)\n-\ttotal_freq = 1;\n-      if (exit_freq > total_freq)\n-\texit_freq = total_freq;\n-    }\n+  total_count = exit->src->count;\n+  exit_count = exit->count ();\n+  /* Fix up corner cases, to avoid division by zero or creation of negative\n+     frequencies.  */\n+  if (exit_count > total_count)\n+    exit_count = total_count;\n \n   copy_bbs (region, n_region, region_copy, exits, 2, nexits, orig_loop,\n \t    split_edge_bb_loc (exit), true);\n-  if (total_count.initialized_p ())\n+  if (total_count.initialized_p () && exit_count.initialized_p ())\n     {\n       scale_bbs_frequencies_profile_count (region, n_region,\n \t\t\t\t           total_count - exit_count,\n \t\t\t\t           total_count);\n       scale_bbs_frequencies_profile_count (region_copy, n_region, exit_count,\n \t\t\t\t           total_count);\n     }\n-  else\n-    {\n-      scale_bbs_frequencies_int (region, n_region, total_freq - exit_freq,\n-\t\t\t\t total_freq);\n-      scale_bbs_frequencies_int (region_copy, n_region, exit_freq, total_freq);\n-    }\n \n   /* Create the switch block, and put the exit condition to it.  */\n   entry_bb = entry->dest;\n@@ -7614,9 +7572,15 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n      FIXME, this is silly.  The CFG ought to become a parameter to\n      these helpers.  */\n   push_cfun (dest_cfun);\n-  make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), entry_bb, EDGE_FALLTHRU);\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = entry_bb->count;\n+  make_single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), entry_bb, EDGE_FALLTHRU);\n   if (exit_bb)\n-    make_edge (exit_bb,  EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+    {\n+      make_single_succ_edge (exit_bb,  EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+      EXIT_BLOCK_PTR_FOR_FN (cfun)->count = exit_bb->count;\n+    }\n+  else\n+    EXIT_BLOCK_PTR_FOR_FN (cfun)->count = profile_count::zero ();\n   pop_cfun ();\n \n   /* Back in the original function, the SESE region has disappeared,\n@@ -8691,7 +8655,7 @@ gimple_account_profile_record (basic_block bb, int after_pass,\n       else if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n \trecord->time[after_pass]\n \t  += estimate_num_insns (gsi_stmt (i),\n-\t\t\t\t &eni_time_weights) * bb->frequency;\n+\t\t\t\t &eni_time_weights) * bb->count.to_frequency (cfun);\n     }\n }\n \n@@ -8843,7 +8807,6 @@ insert_cond_bb (basic_block bb, gimple *stmt, gimple *cond,\n   edge e = make_edge (bb, new_bb, EDGE_TRUE_VALUE);\n   e->probability = prob;\n   new_bb->count = e->count ();\n-  new_bb->frequency = prob.apply (bb->frequency);\n   make_single_succ_edge (new_bb, fall->dest, EDGE_FALLTHRU);\n \n   /* Fix edge for split bb.  */\n@@ -9264,9 +9227,9 @@ execute_fixup_cfg (void)\n   cgraph_node *node = cgraph_node::get (current_function_decl);\n   profile_count num = node->count;\n   profile_count den = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n-  bool scale = num.initialized_p ()\n-\t       && (den > 0 || num == profile_count::zero ())\n-\t       && !(num == den);\n+  bool scale = num.initialized_p () && den.ipa_p ()\n+\t       && (den.nonzero_p () || num == profile_count::zero ())\n+\t       && !(num == den.ipa ());\n \n   if (scale)\n     {"}, {"sha": "146b52bbd5276acd4bba1cd8d39d6dee23a24899", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1191,7 +1191,6 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n       bb_join = e->dest;\n       bb_true = create_empty_bb (bb_cond);\n       bb_false = create_empty_bb (bb_true);\n-      bb_true->frequency = bb_false->frequency = bb_cond->frequency / 2;\n       bb_true->count = bb_false->count\n \t = bb_cond->count.apply_probability (profile_probability::even ());\n "}, {"sha": "65e850d36ad254758ee05989c3d52e3e95c17359", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -3224,6 +3224,7 @@ lower_resx (basic_block bb, gresx *stmt,\n \t      gimple_stmt_iterator gsi2;\n \n \t      new_bb = create_empty_bb (bb);\n+\t      new_bb->count = bb->count;\n \t      add_bb_to_loop (new_bb, bb->loop_father);\n \t      lab = gimple_block_label (new_bb);\n \t      gsi2 = gsi_start_bb (new_bb);"}, {"sha": "040799c778c25866e78d77de505ce657155c95a6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 31, "deletions": 82, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1763,16 +1763,15 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n    later  */\n \n static basic_block\n-copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n+copy_bb (copy_body_data *id, basic_block bb,\n          profile_count num, profile_count den)\n {\n   gimple_stmt_iterator gsi, copy_gsi, seq_gsi;\n   basic_block copy_basic_block;\n   tree decl;\n-  gcov_type freq;\n   basic_block prev;\n-  bool scale = num.initialized_p ()\n-\t       && (den > 0 || num == profile_count::zero ());\n+  bool scale = !num.initialized_p ()\n+\t       || (den.nonzero_p () || num == profile_count::zero ());\n \n   /* Search for previous copied basic block.  */\n   prev = bb->prev_bb;\n@@ -1784,15 +1783,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n   copy_basic_block = create_basic_block (NULL, (basic_block) prev->aux);\n   if (scale)\n     copy_basic_block->count = bb->count.apply_scale (num, den);\n-\n-  /* We are going to rebuild frequencies from scratch.  These values\n-     have just small importance to drive canonicalize_loop_headers.  */\n-  freq = apply_scale ((gcov_type)bb->frequency, frequency_scale);\n-\n-  /* We recompute frequencies after inlining, so this is quite safe.  */\n-  if (freq > BB_FREQ_MAX)\n-    freq = BB_FREQ_MAX;\n-  copy_basic_block->frequency = freq;\n+  else if (num.initialized_p ())\n+    copy_basic_block->count = bb->count;\n \n   copy_gsi = gsi_start_bb (copy_basic_block);\n \n@@ -2068,8 +2060,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t\t      fprintf (dump_file,\n \t\t\t\t       \"Orig bb: %i, orig bb freq %i, new bb freq %i\\n\",\n \t\t\t\t       bb->index,\n-\t\t\t\t       bb->frequency,\n-\t\t\t\t       copy_basic_block->frequency);\n+\t\t\t\t       bb->count.to_frequency (cfun),\n+\t\t\t\t       copy_basic_block->count.to_frequency (cfun));\n \t\t\t    }\n \t\t\t}\n \t\t    }\n@@ -2507,11 +2499,8 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, profile_count count)\n \n   profile_status_for_fn (cfun) = profile_status_for_fn (src_cfun);\n \n-  /* FIXME: When all counts are known to be zero, scaling is also meaningful.\n-   */\n   if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.initialized_p ()\n-      && count.initialized_p ()\n-      && ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.initialized_p ())\n+      && count.ipa ().initialized_p ())\n     {\n       ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n \tENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n@@ -2520,10 +2509,13 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, profile_count count)\n \tEXIT_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n \t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n     }\n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency\n-    = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->frequency;\n-  EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency =\n-    EXIT_BLOCK_PTR_FOR_FN (src_cfun)->frequency;\n+  else\n+    {\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count\n+\t   = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n+      EXIT_BLOCK_PTR_FOR_FN (cfun)->count\n+\t   = EXIT_BLOCK_PTR_FOR_FN (src_cfun)->count;\n+    }\n   if (src_cfun->eh)\n     init_eh_for_function ();\n \n@@ -2680,27 +2672,11 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n     }\n }\n \n-/* Convert estimated frequencies into counts for NODE, scaling COUNT\n-   with each bb's frequency. Used when NODE has a 0-weight entry\n-   but we are about to inline it into a non-zero count call bb.\n-   See the comments for handle_missing_profiles() in predict.c for\n-   when this can happen for COMDATs.  */\n-\n-void\n-freqs_to_counts (struct cgraph_node *node, profile_count count)\n-{\n-  basic_block bb;\n-  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n-\n-  FOR_ALL_BB_FN(bb, fn)\n-    bb->count = count.apply_scale (bb->frequency, BB_FREQ_MAX);\n-}\n-\n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n static tree\n-copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n+copy_cfg_body (copy_body_data * id, profile_count,\n \t       basic_block entry_block_map, basic_block exit_block_map,\n \t       basic_block new_entry)\n {\n@@ -2712,31 +2688,10 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n   tree new_fndecl = NULL;\n   bool need_debug_cleanup = false;\n   int last;\n-  int incoming_frequency = 0;\n-  profile_count incoming_count = profile_count::zero ();\n-  profile_count num = count;\n   profile_count den = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n-  bool scale = num.initialized_p ()\n-\t       && (den > 0 || num == profile_count::zero ());\n-\n-  /* This can happen for COMDAT routines that end up with 0 counts\n-     despite being called (see the comments for handle_missing_profiles()\n-     in predict.c as to why). Apply counts to the blocks in the callee\n-     before inlining, using the guessed edge frequencies, so that we don't\n-     end up with a 0-count inline body which can confuse downstream\n-     optimizations such as function splitting.  */\n-  if (!(ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count > 0) && count > 0)\n-    {\n-      /* Apply the larger of the call bb count and the total incoming\n-         call edge count to the callee.  */\n-      profile_count in_count = profile_count::zero ();\n-      struct cgraph_edge *in_edge;\n-      for (in_edge = id->src_node->callers; in_edge;\n-           in_edge = in_edge->next_caller)\n-\tif (in_edge->count.initialized_p ())\n-          in_count += in_edge->count;\n-      freqs_to_counts (id->src_node, count > in_count ? count : in_count);\n-    }\n+  profile_count num = entry_block_map->count;\n+\n+  cfun_to_copy = id->src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n \n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n@@ -2750,25 +2705,18 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n     {\n       edge e;\n       edge_iterator ei;\n+      den = profile_count::zero ();\n \n       FOR_EACH_EDGE (e, ei, new_entry->preds)\n \tif (!e->src->aux)\n-\t  incoming_frequency += EDGE_FREQUENCY (e);\n-      if (scale)\n-        incoming_count = incoming_count.apply_scale (num, den);\n-      else\n-\tincoming_count = profile_count::uninitialized ();\n-      incoming_frequency\n-\t= apply_scale ((gcov_type)incoming_frequency, frequency_scale);\n-      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = incoming_count;\n-      ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency = incoming_frequency;\n+\t  den += e->count ();\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = den;\n     }\n \n   /* Must have a CFG here at this point.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FN\n \t      (DECL_STRUCT_FUNCTION (callee_fndecl)));\n \n-  cfun_to_copy = id->src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n \n   ENTRY_BLOCK_PTR_FOR_FN (cfun_to_copy)->aux = entry_block_map;\n   EXIT_BLOCK_PTR_FOR_FN (cfun_to_copy)->aux = exit_block_map;\n@@ -2784,7 +2732,7 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n     if (!id->blocks_to_copy || bitmap_bit_p (id->blocks_to_copy, bb->index))\n       {\n-\tbasic_block new_bb = copy_bb (id, bb, frequency_scale, num, den);\n+\tbasic_block new_bb = copy_bb (id, bb, num, den);\n \tbb->aux = new_bb;\n \tnew_bb->aux = bb;\n \tnew_bb->loop_father = entry_block_map->loop_father;\n@@ -3011,7 +2959,7 @@ copy_tree_body (copy_body_data *id)\n    another function.  */\n \n static tree\n-copy_body (copy_body_data *id, profile_count count, int frequency_scale,\n+copy_body (copy_body_data *id, profile_count count,\n \t   basic_block entry_block_map, basic_block exit_block_map,\n \t   basic_block new_entry)\n {\n@@ -3020,7 +2968,7 @@ copy_body (copy_body_data *id, profile_count count, int frequency_scale,\n \n   /* If this body has a CFG, walk CFG and copy.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (fndecl)));\n-  body = copy_cfg_body (id, count, frequency_scale, entry_block_map, exit_block_map,\n+  body = copy_cfg_body (id, count, entry_block_map, exit_block_map,\n \t\t\tnew_entry);\n   copy_debug_stmts (id);\n \n@@ -4771,7 +4719,6 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n      a self-referential call; if we're calling ourselves, we need to\n      duplicate our body before altering anything.  */\n   copy_body (id, cg_edge->callee->count,\n-  \t     GCOV_COMPUTE_SCALE (cg_edge->frequency, CGRAPH_FREQ_BASE),\n \t     bb, return_block, NULL);\n \n   reset_debug_bindings (id, stmt_gsi);\n@@ -5146,6 +5093,7 @@ optimize_inline_calls (tree fn)\n     }\n \n   /* Fold queued statements.  */\n+  counts_to_freqs ();\n   fold_marked_statements (last, id.statements_to_fold);\n   delete id.statements_to_fold;\n \n@@ -6090,7 +6038,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n     }\n \n   /* Copy the Function's body.  */\n-  copy_body (&id, old_entry_block->count, REG_BR_PROB_BASE,\n+  copy_body (&id, old_entry_block->count,\n \t     ENTRY_BLOCK_PTR_FOR_FN (cfun), EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t     new_entry);\n \n@@ -6122,6 +6070,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n+  counts_to_freqs ();\n   fold_marked_statements (0, id.statements_to_fold);\n   delete id.statements_to_fold;\n   delete_unreachable_blocks_update_callgraph (&id);\n@@ -6141,20 +6090,20 @@ tree_function_versioning (tree old_decl, tree new_decl,\n       struct cgraph_edge *e;\n       rebuild_frequencies ();\n \n-      new_version_node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+      new_version_node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa ();\n       for (e = new_version_node->callees; e; e = e->next_callee)\n \t{\n \t  basic_block bb = gimple_bb (e->call_stmt);\n \t  e->frequency = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t\t bb);\n-\t  e->count = bb->count;\n+\t  e->count = bb->count.ipa ();\n \t}\n       for (e = new_version_node->indirect_calls; e; e = e->next_callee)\n \t{\n \t  basic_block bb = gimple_bb (e->call_stmt);\n \t  e->frequency = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t\t bb);\n-\t  e->count = bb->count;\n+\t  e->count = bb->count.ipa ();\n \t}\n     }\n "}, {"sha": "057d51dcf37a1417ddba31ed46612297e7c9c397", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -164,7 +164,7 @@ coalesce_cost (int frequency, bool optimize_for_size)\n static inline int\n coalesce_cost_bb (basic_block bb)\n {\n-  return coalesce_cost (bb->frequency, optimize_bb_for_size_p (bb));\n+  return coalesce_cost (bb->count.to_frequency (cfun), optimize_bb_for_size_p (bb));\n }\n \n "}, {"sha": "ff26dd1f731daa6a4b99ca0c51261b5439ce77ef", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -366,7 +366,6 @@ update_profile_after_ifcombine (basic_block inner_cond_bb,\n \t\t\t\t - inner_taken->probability;\n \n   outer_to_inner->probability = profile_probability::always ();\n-  inner_cond_bb->frequency = outer_cond_bb->frequency;\n   outer2->probability = profile_probability::never ();\n }\n "}, {"sha": "46be9440a816462b2ecd5d4ea3bf3617d95170aa", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1803,7 +1803,7 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   for (hash_set<basic_block>::iterator it = flag_bbs->begin ();\n        it != flag_bbs->end (); ++it)\n     {\n-       freq_sum += (*it)->frequency;\n+       freq_sum += (*it)->count.to_frequency (cfun);\n        if ((*it)->count.initialized_p ())\n          count_sum += (*it)->count, ncount ++;\n        if (dominated_by_p (CDI_DOMINATORS, ex->src, *it))\n@@ -1815,20 +1815,15 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \n   if (flag_probability.initialized_p ())\n     ;\n-  else if (ncount == nbbs && count_sum > 0 && preheader->count () >= count_sum)\n+  else if (ncount == nbbs\n+\t   && preheader->count () >= count_sum && preheader->count ().nonzero_p ())\n     {\n       flag_probability = count_sum.probability_in (preheader->count ());\n       if (flag_probability > cap)\n \tflag_probability = cap;\n     }\n-  else if (freq_sum > 0 && EDGE_FREQUENCY (preheader) >= freq_sum)\n-    {\n-      flag_probability = profile_probability::from_reg_br_prob_base\n-\t\t(GCOV_COMPUTE_SCALE (freq_sum, EDGE_FREQUENCY (preheader)));\n-      if (flag_probability > cap)\n-\tflag_probability = cap;\n-    }\n-  else\n+\n+  if (!flag_probability.initialized_p ())\n     flag_probability = cap;\n \n   /* ?? Insert store after previous store if applicable.  See note\n@@ -1861,7 +1856,6 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   old_dest = ex->dest;\n   new_bb = split_edge (ex);\n   then_bb = create_empty_bb (new_bb);\n-  then_bb->frequency = flag_probability.apply (new_bb->frequency);\n   then_bb->count = new_bb->count.apply_probability (flag_probability);\n   if (irr)\n     then_bb->flags = BB_IRREDUCIBLE_LOOP;"}, {"sha": "8b1daa66b3e0be166e11785b5c810bcc2f7c0af6", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -647,7 +647,6 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n \n       add_bb_to_loop (latch_edge->dest, current_loops->tree_root);\n       latch_edge->dest->count = profile_count::zero ();\n-      latch_edge->dest->frequency = 0;\n       set_immediate_dominator (CDI_DOMINATORS, latch_edge->dest, latch_edge->src);\n \n       gsi = gsi_start_bb (latch_edge->dest);\n@@ -1090,7 +1089,6 @@ try_peel_loop (struct loop *loop,\n \t}\n     }\n   profile_count entry_count = profile_count::zero ();\n-  int entry_freq = 0;\n \n   edge e;\n   edge_iterator ei;\n@@ -1099,15 +1097,10 @@ try_peel_loop (struct loop *loop,\n       {\n \tif (e->src->count.initialized_p ())\n \t  entry_count = e->src->count + e->src->count;\n-\tentry_freq += e->src->frequency;\n \tgcc_assert (!flow_bb_inside_loop_p (loop, e->src));\n       }\n   profile_probability p = profile_probability::very_unlikely ();\n-  if (loop->header->count > 0)\n-    p = entry_count.probability_in (loop->header->count);\n-  else if (loop->header->frequency)\n-    p = profile_probability::probability_in_gcov_type\n-\t\t (entry_freq, loop->header->frequency);\n+  p = entry_count.probability_in (loop->header->count);\n   scale_loop_profile (loop, p, 0);\n   bitmap_set_bit (peeled_loops, loop->num);\n   return true;"}, {"sha": "e16a4820784ed97a10fe1f9a63a7a68a6ddf28a3", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -4457,8 +4457,8 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n static comp_cost\n get_scaled_computation_cost_at (ivopts_data *data, gimple *at, comp_cost cost)\n {\n-   int loop_freq = data->current_loop->header->frequency;\n-   int bb_freq = gimple_bb (at)->frequency;\n+   int loop_freq = data->current_loop->header->count.to_frequency (cfun);\n+   int bb_freq = gimple_bb (at)->count.to_frequency (cfun);\n    if (loop_freq != 0)\n      {\n        gcc_assert (cost.scratch <= cost.cost);"}, {"sha": "1efcd272241486e5c6128c28ac7eed30e5b67605", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1122,6 +1122,9 @@ niter_for_unrolled_loop (struct loop *loop, unsigned factor)\n      converts back.  */\n   gcov_type new_est_niter = est_niter / factor;\n \n+  if (est_niter == -1)\n+    return -1;\n+\n   /* Without profile feedback, loops for which we do not know a better estimate\n      are assumed to roll 10 times.  When we unroll such loop, it appears to\n      roll too little, and it may even seem to be cold.  To avoid this, we\n@@ -1370,14 +1373,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \n   freq_h = loop->header->count;\n   freq_e = (loop_preheader_edge (loop))->count ();\n-  /* Use frequency only if counts are zero.  */\n-  if (!(freq_h > 0) && !(freq_e > 0))\n-    {\n-      freq_h = profile_count::from_gcov_type (loop->header->frequency);\n-      freq_e = profile_count::from_gcov_type\n-\t\t (EDGE_FREQUENCY (loop_preheader_edge (loop)));\n-    }\n-  if (freq_h > 0)\n+  if (freq_h.nonzero_p ())\n     {\n       /* Avoid dropping loop body profile counter to 0 because of zero count\n \t in loop's preheader.  */\n@@ -1392,7 +1388,6 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \t\t\t\t.apply_scale (1, new_est_niter + 1);\n \n   rest->count += new_exit->count ();\n-  rest->frequency += EDGE_FREQUENCY (new_exit);\n \n   new_nonexit = single_pred_edge (loop->latch);\n   prob = new_nonexit->probability;"}, {"sha": "b97f1dba0f6631b237606e44c43b64c31c00c7ed", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -3901,7 +3901,7 @@ estimate_numbers_of_iterations (struct loop *loop)\n      recomputing iteration bounds later in the compilation process will just\n      introduce random roundoff errors.  */\n   if (!loop->any_estimate\n-      && loop->header->count > 0)\n+      && loop->header->count.reliable_p ())\n     {\n       gcov_type nit = expected_loop_iterations_unbounded (loop);\n       bound = gcov_type_to_wide_int (nit);"}, {"sha": "ecc72cbaf5c440f8c3fde52d059847fa0a97613a", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -852,7 +852,7 @@ hoist_guard (struct loop *loop, edge guard)\n   /* Determine the probability that we skip the loop.  Assume that loop has\n      same average number of iterations regardless outcome of guard.  */\n   new_edge->probability = guard->probability;\n-  profile_count skip_count = guard->src->count > 0\n+  profile_count skip_count = guard->src->count.nonzero_p ()\n \t\t   ? guard->count ().apply_scale (pre_header->count,\n \t\t\t\t\t       guard->src->count)\n \t\t   : guard->count ().apply_probability (new_edge->probability);\n@@ -875,7 +875,6 @@ hoist_guard (struct loop *loop, edge guard)\n      to loop header...  */\n   e->probability = new_edge->probability.invert ();\n   e->dest->count = e->count ();\n-  e->dest->frequency = EDGE_FREQUENCY (e);\n \n   /* ... now update profile to represent that original guard will be optimized\n      away ...  */"}, {"sha": "1c5d7dd7556172e8913581bf4c8bf5fb9d1e01d4", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -226,7 +226,8 @@ select_best_block (basic_block early_bb,\n   /* If BEST_BB is at the same nesting level, then require it to have\n      significantly lower execution frequency to avoid gratutious movement.  */\n   if (bb_loop_depth (best_bb) == bb_loop_depth (early_bb)\n-      && best_bb->frequency < (early_bb->frequency * threshold / 100.0))\n+      && best_bb->count.to_frequency (cfun)\n+\t < (early_bb->count.to_frequency (cfun) * threshold / 100.0))\n     return best_bb;\n \n   /* No better block found, so return EARLY_BB, which happens to be the"}, {"sha": "97e90233d580c321e6f42610ec923ce735d59a63", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1530,8 +1530,6 @@ static void\n replace_block_by (basic_block bb1, basic_block bb2)\n {\n   edge pred_edge;\n-  edge e1, e2;\n-  edge_iterator ei;\n   unsigned int i;\n   gphi *bb2_phi;\n \n@@ -1560,9 +1558,13 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \n   bb2->count += bb1->count;\n \n+  /* FIXME: Fix merging of probabilities.  They need to be redistributed\n+     according to the relative counts of merged BBs.  */\n+#if 0\n   /* Merge the outgoing edge counts from bb1 onto bb2.  */\n   profile_count out_sum = profile_count::zero ();\n   int out_freq_sum = 0;\n+  edge e1, e2;\n \n   /* Recompute the edge probabilities from the new merged edge count.\n      Use the sum of the new merged edge counts computed above instead\n@@ -1580,7 +1582,6 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \tout_sum += e1->count ();\n       out_freq_sum += EDGE_FREQUENCY (e1);\n     }\n-\n   FOR_EACH_EDGE (e1, ei, bb1->succs)\n     {\n       e2 = find_edge (bb2, e1->dest);\n@@ -1589,9 +1590,9 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \t{\n \t  e2->probability = e2->count ().probability_in (bb2->count);\n \t}\n-      else if (bb1->frequency && bb2->frequency)\n+      else if (bb1->count.to_frequency (cfun) && bb2->count.to_frequency (cfun))\n \te2->probability = e1->probability;\n-      else if (bb2->frequency && !bb1->frequency)\n+      else if (bb2->count.to_frequency (cfun) && !bb1->count.to_frequency (cfun))\n \t;\n       else if (out_freq_sum)\n \te2->probability = profile_probability::from_reg_br_prob_base\n@@ -1600,9 +1601,7 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \t\t\t\t     out_freq_sum));\n       out_sum += e2->count ();\n     }\n-  bb2->frequency += bb1->frequency;\n-  if (bb2->frequency > BB_FREQ_MAX)\n-    bb2->frequency = BB_FREQ_MAX;\n+#endif\n \n   /* Move over any user labels from bb1 after the bb2 labels.  */\n   gimple_stmt_iterator gsi1 = gsi_start_bb (bb1);"}, {"sha": "1dab0f1fab498e0d59d7514d746080e850c7cbd3", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 38, "deletions": 199, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -339,7 +339,6 @@ create_block_for_threading (basic_block bb,\n     e->aux = NULL;\n \n   /* Zero out the profile, since the block is unreachable for now.  */\n-  rd->dup_blocks[count]->frequency = 0;\n   rd->dup_blocks[count]->count = profile_count::uninitialized ();\n   if (duplicate_blocks)\n     bitmap_set_bit (*duplicate_blocks, rd->dup_blocks[count]->index);\n@@ -590,15 +589,15 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n }\n \n \n-/* Compute the amount of profile count/frequency coming into the jump threading\n+/* Compute the amount of profile count coming into the jump threading\n    path stored in RD that we are duplicating, returned in PATH_IN_COUNT_PTR and\n    PATH_IN_FREQ_PTR, as well as the amount of counts flowing out of the\n    duplicated path, returned in PATH_OUT_COUNT_PTR.  LOCAL_INFO is used to\n    identify blocks duplicated for jump threading, which have duplicated\n    edges that need to be ignored in the analysis.  Return true if path contains\n    a joiner, false otherwise.\n \n-   In the non-joiner case, this is straightforward - all the counts/frequency\n+   In the non-joiner case, this is straightforward - all the counts\n    flowing into the jump threading path should flow through the duplicated\n    block and out of the duplicated path.\n \n@@ -851,16 +850,14 @@ compute_path_counts (struct redirection_data *rd,\n \n /* Update the counts and frequencies for both an original path\n    edge EPATH and its duplicate EDUP.  The duplicate source block\n-   will get a count/frequency of PATH_IN_COUNT and PATH_IN_FREQ,\n+   will get a count of PATH_IN_COUNT and PATH_IN_FREQ,\n    and the duplicate edge EDUP will have a count of PATH_OUT_COUNT.  */\n static void\n update_profile (edge epath, edge edup, profile_count path_in_count,\n-\t\tprofile_count path_out_count, int path_in_freq)\n+\t\tprofile_count path_out_count)\n {\n-  if (!(path_in_count > 0))\n-    return;\n \n-  /* First update the duplicated block's count / frequency.  */\n+  /* First update the duplicated block's count.  */\n   if (edup)\n     {\n       basic_block dup_block = edup->src;\n@@ -894,167 +891,54 @@ update_profile (edge epath, edge edup, profile_count path_in_count,\n \t    if (esucc != edup)\n \t      esucc->probability *= scale;\n \t}\n-      edup->probability = edup_prob;\n+      if (edup_prob.initialized_p ())\n+        edup->probability = edup_prob;\n \n-      /* FIXME once freqs_to_counts is dropped re-enable this check.  */\n-      gcc_assert (!dup_block->count.initialized_p () || 1);\n-      gcc_assert (dup_block->frequency == 0);\n+      gcc_assert (!dup_block->count.initialized_p ());\n       dup_block->count = path_in_count;\n-      dup_block->frequency = path_in_freq;\n     }\n \n+  if (path_in_count == profile_count::zero ())\n+    return;\n+\n   profile_count final_count = epath->count () - path_out_count;\n \n-  /* Now update the original block's count and frequency in the\n+  /* Now update the original block's count in the\n      opposite manner - remove the counts/freq that will flow\n      into the duplicated block.  Handle underflow due to precision/\n      rounding issues.  */\n   epath->src->count -= path_in_count;\n-  epath->src->frequency -= path_in_freq;\n-  if (epath->src->frequency < 0)\n-    epath->src->frequency = 0;\n \n   /* Next update this path edge's original and duplicated counts.  We know\n      that the duplicated path will have path_out_count flowing\n      out of it (in the joiner case this is the count along the duplicated path\n      out of the duplicated joiner).  This count can then be removed from the\n      original path edge.  */\n-  if (epath->src->count > 0)\n-    {\n-      edge esucc;\n-      edge_iterator ei;\n-      profile_probability epath_prob = final_count.probability_in (epath->src->count);\n-\n-      if (epath->probability > epath_prob)\n-\t{\n-\t   profile_probability rev_scale\n-\t     = (profile_probability::always () - epath->probability)\n-\t       / (profile_probability::always () - epath_prob);\n-\t   FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\t     if (esucc != epath)\n-\t       esucc->probability /= rev_scale;\n-\t}\n-      else if (epath->probability < epath_prob)\n-\t{\n-\t   profile_probability scale\n-\t     = (profile_probability::always () - epath_prob)\n-\t       / (profile_probability::always () - epath->probability);\n-\t  FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\t    if (esucc != epath)\n-\t      esucc->probability *= scale;\n-\t}\n-      epath->probability = epath_prob;\n-    }\n-}\n-\n-\n-/* Check if the paths through RD all have estimated frequencies but zero\n-   profile counts.  This is more accurate than checking the entry block\n-   for a zero profile count, since profile insanities sometimes creep in.  */\n-\n-static bool\n-estimated_freqs_path (struct redirection_data *rd)\n-{\n-  edge e = rd->incoming_edges->e;\n-  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-  edge ein;\n-  edge_iterator ei;\n-  bool non_zero_freq = false;\n-  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    {\n-      if (ein->count () > 0)\n-\treturn false;\n-      non_zero_freq |= ein->src->frequency != 0;\n-    }\n-\n-  for (unsigned int i = 1; i < path->length (); i++)\n-    {\n-      edge epath = (*path)[i]->e;\n-      if (epath->src->count > 0)\n-\treturn false;\n-      non_zero_freq |= epath->src->frequency != 0;\n-      edge esucc;\n-      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\t{\n-\t  if (esucc->count () > 0)\n-\t    return false;\n-\t  non_zero_freq |= esucc->src->frequency != 0;\n-\t}\n-    }\n-  return non_zero_freq;\n-}\n-\n-\n-/* Invoked for routines that have guessed frequencies and no profile\n-   counts to record the block and edge frequencies for paths through RD\n-   in the profile count fields of those blocks and edges.  This is because\n-   ssa_fix_duplicate_block_edges incrementally updates the block and\n-   edge counts as edges are redirected, and it is difficult to do that\n-   for edge frequencies which are computed on the fly from the source\n-   block frequency and probability.  When a block frequency is updated\n-   its outgoing edge frequencies are affected and become difficult to\n-   adjust.  */\n-\n-static void\n-freqs_to_counts_path (struct redirection_data *rd)\n-{\n-  edge e = rd->incoming_edges->e;\n-  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-  edge ein;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    ein->src->count = profile_count::from_gcov_type\n-\t  (ein->src->frequency * REG_BR_PROB_BASE);\n-  for (unsigned int i = 1; i < path->length (); i++)\n-    {\n-      edge epath = (*path)[i]->e;\n-      /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n-\t errors applying the edge probability when the frequencies are very\n-\t small.  */\n-      epath->src->count = \n-\tprofile_count::from_gcov_type\n-\t  (epath->src->frequency * REG_BR_PROB_BASE);\n-    }\n-}\n-\n-\n-/* For routines that have guessed frequencies and no profile counts, where we\n-   used freqs_to_counts_path to record block and edge frequencies for paths\n-   through RD, we clear the counts after completing all updates for RD.\n-   The updates in ssa_fix_duplicate_block_edges are based off the count fields,\n-   but the block frequencies and edge probabilities were updated as well,\n-   so we can simply clear the count fields.  */\n-\n-static void\n-clear_counts_path (struct redirection_data *rd)\n-{\n-  edge e = rd->incoming_edges->e;\n-  vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-  profile_count val = profile_count::uninitialized ();\n-  if (profile_status_for_fn (cfun) == PROFILE_READ)\n-    val = profile_count::zero ();\n \n-  edge ein;\n+  edge esucc;\n   edge_iterator ei;\n+  profile_probability epath_prob = final_count.probability_in (epath->src->count);\n \n-  FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    ein->src->count = val;\n-\n-  /* First clear counts along original path.  */\n-  for (unsigned int i = 1; i < path->length (); i++)\n+  if (epath->probability > epath_prob)\n     {\n-      edge epath = (*path)[i]->e;\n-      epath->src->count = val;\n+       profile_probability rev_scale\n+\t = (profile_probability::always () - epath->probability)\n+\t   / (profile_probability::always () - epath_prob);\n+       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+\t if (esucc != epath)\n+\t   esucc->probability /= rev_scale;\n     }\n-  /* Also need to clear the counts along duplicated path.  */\n-  for (unsigned int i = 0; i < 2; i++)\n+  else if (epath->probability < epath_prob)\n     {\n-      basic_block dup = rd->dup_blocks[i];\n-      if (!dup)\n-\tcontinue;\n-      dup->count = val;\n+       profile_probability scale\n+\t = (profile_probability::always () - epath_prob)\n+\t   / (profile_probability::always () - epath->probability);\n+      FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n+\tif (esucc != epath)\n+\t  esucc->probability *= scale;\n     }\n+  if (epath_prob.initialized_p ())\n+    epath->probability = epath_prob;\n }\n \n /* Wire up the outgoing edges from the duplicate blocks and\n@@ -1072,20 +956,6 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n   profile_count path_out_count = profile_count::zero ();\n   int path_in_freq = 0;\n \n-  /* This routine updates profile counts, frequencies, and probabilities\n-     incrementally. Since it is difficult to do the incremental updates\n-     using frequencies/probabilities alone, for routines without profile\n-     data we first take a snapshot of the existing block and edge frequencies\n-     by copying them into the empty profile count fields.  These counts are\n-     then used to do the incremental updates, and cleared at the end of this\n-     routine.  If the function is marked as having a profile, we still check\n-     to see if the paths through RD are using estimated frequencies because\n-     the routine had zero profile counts.  */\n-  bool do_freqs_to_counts = (profile_status_for_fn (cfun) != PROFILE_READ\n-\t\t\t     || estimated_freqs_path (rd));\n-  if (do_freqs_to_counts)\n-    freqs_to_counts_path (rd);\n-\n   /* First determine how much profile count to move from original\n      path to the duplicate path.  This is tricky in the presence of\n      a joiner (see comments for compute_path_counts), where some portion\n@@ -1096,7 +966,6 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t\t\t\t &path_in_count, &path_out_count,\n \t\t\t\t\t &path_in_freq);\n \n-  int cur_path_freq = path_in_freq;\n   for (unsigned int count = 0, i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n@@ -1162,19 +1031,14 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t}\n \t    }\n \n-\t  /* Update the counts and frequency of both the original block\n+\t  /* Update the counts of both the original block\n \t     and path edge, and the duplicates.  The path duplicate's\n-\t     incoming count and frequency are the totals for all edges\n+\t     incoming count are the totals for all edges\n \t     incoming to this jump threading path computed earlier.\n \t     And we know that the duplicated path will have path_out_count\n \t     flowing out of it (i.e. along the duplicated path out of the\n \t     duplicated joiner).  */\n-\t  update_profile (epath, e2, path_in_count, path_out_count,\n-\t\t\t  path_in_freq);\n-\n-\t  /* Record the frequency flowing to the downstream duplicated\n-\t     path blocks.  */\n-\t  cur_path_freq = EDGE_FREQUENCY (e2);\n+\t  update_profile (epath, e2, path_in_count, path_out_count);\n \t}\n       else if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n \t{\n@@ -1184,7 +1048,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  if (count == 1)\n \t    single_succ_edge (rd->dup_blocks[1])->aux = NULL;\n \n-\t  /* Update the counts and frequency of both the original block\n+\t  /* Update the counts of both the original block\n \t     and path edge, and the duplicates.  Since we are now after\n \t     any joiner that may have existed on the path, the count\n \t     flowing along the duplicated threaded path is path_out_count.\n@@ -1194,7 +1058,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t     been updated at the end of that handling to the edge frequency\n \t     along the duplicated joiner path edge.  */\n \t  update_profile (epath, EDGE_SUCC (rd->dup_blocks[count], 0),\n-\t\t\t  path_out_count, path_out_count, cur_path_freq);\n+\t\t\t  path_out_count, path_out_count);\n \t}\n       else\n \t{\n@@ -1211,8 +1075,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t     thread path (path_in_freq).  If we had a joiner, it would have\n \t     been updated at the end of that handling to the edge frequency\n \t     along the duplicated joiner path edge.  */\n-\t   update_profile (epath, NULL, path_out_count, path_out_count,\n-\t\t\t   cur_path_freq);\n+\t   update_profile (epath, NULL, path_out_count, path_out_count);\n \t}\n \n       /* Increment the index into the duplicated path when we processed\n@@ -1223,11 +1086,6 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  count++;\n \t}\n     }\n-\n-  /* Done with all profile and frequency updates, clear counts if they\n-     were copied.  */\n-  if (do_freqs_to_counts)\n-    clear_counts_path (rd);\n }\n \n /* Hash table traversal callback routine to create duplicate blocks.  */\n@@ -2137,7 +1995,6 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n   struct loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n   edge redirected;\n-  int curr_freq;\n   profile_count curr_count;\n \n   if (!can_copy_bbs_p (region, n_region))\n@@ -2170,7 +2027,6 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n      the jump-thread path in order.  */\n \n   curr_count = entry->count ();\n-  curr_freq = EDGE_FREQUENCY (entry);\n \n   for (i = 0; i < n_region; i++)\n     {\n@@ -2181,10 +2037,8 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n       /* Watch inconsistent profile.  */\n       if (curr_count > region[i]->count)\n \tcurr_count = region[i]->count;\n-      if (curr_freq > region[i]->frequency)\n-\tcurr_freq = region[i]->frequency;\n       /* Scale current BB.  */\n-      if (region[i]->count > 0 && curr_count.initialized_p ())\n+      if (region[i]->count.nonzero_p () && curr_count.initialized_p ())\n \t{\n \t  /* In the middle of the path we only scale the frequencies.\n \t     In last BB we need to update probabilities of outgoing edges\n@@ -2195,24 +2049,11 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \t\t\t\t\t         region[i]->count);\n \t  else\n \t    update_bb_profile_for_threading (region[i],\n-\t\t\t\t\t     curr_freq, curr_count,\n+\t\t\t\t\t     curr_count,\n \t\t\t\t\t     exit);\n \t  scale_bbs_frequencies_profile_count (region_copy + i, 1, curr_count,\n \t\t\t\t\t       region_copy[i]->count);\n \t}\n-      else if (region[i]->frequency)\n-\t{\n-\t  if (i + 1 != n_region)\n-\t    scale_bbs_frequencies_int (region + i, 1,\n-\t\t\t\t       region[i]->frequency - curr_freq,\n-\t\t\t\t       region[i]->frequency);\n-\t  else\n-\t    update_bb_profile_for_threading (region[i],\n-\t\t\t\t\t     curr_freq, curr_count,\n-\t\t\t\t\t     exit);\n-\t  scale_bbs_frequencies_int (region_copy + i, 1, curr_freq,\n-\t\t\t\t     region_copy[i]->frequency);\n-\t}\n \n       if (single_succ_p (bb))\n \t{\n@@ -2221,7 +2062,6 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \t\t      || region_copy[i + 1] == single_succ_edge (bb)->dest);\n \t  if (i + 1 != n_region)\n \t    {\n-\t      curr_freq = EDGE_FREQUENCY (single_succ_edge (bb));\n \t      curr_count = single_succ_edge (bb)->count ();\n \t    }\n \t  continue;\n@@ -2252,7 +2092,6 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \t  }\n \telse\n \t  {\n-\t    curr_freq = EDGE_FREQUENCY (e);\n \t    curr_count = e->count ();\n \t  }\n     }"}, {"sha": "f0d158391df3967ae38dea04bfc75804cae51022", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1443,10 +1443,10 @@ gen_inbound_check (gswitch *swtch, struct switch_conv_info *info)\n     }\n \n   /* frequencies of the new BBs */\n-  bb1->frequency = EDGE_FREQUENCY (e01);\n-  bb2->frequency = EDGE_FREQUENCY (e02);\n+  bb1->count = e01->count ();\n+  bb2->count = e02->count ();\n   if (!info->default_case_nonstandard)\n-    bbf->frequency = EDGE_FREQUENCY (e1f) + EDGE_FREQUENCY (e2f);\n+    bbf->count = e1f->count () + e2f->count ();\n \n   /* Tidy blocks that have become unreachable.  */\n   prune_bbs (bbd, info->final_bb,"}, {"sha": "0e637147e8c57f7ee95f5769fe2c65e0d9162c74", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -805,12 +805,9 @@ adjust_return_value (basic_block bb, tree m, tree a)\n /* Subtract COUNT and FREQUENCY from the basic block and it's\n    outgoing edge.  */\n static void\n-decrease_profile (basic_block bb, profile_count count, int frequency)\n+decrease_profile (basic_block bb, profile_count count)\n {\n   bb->count = bb->count - count;\n-  bb->frequency -= frequency;\n-  if (bb->frequency < 0)\n-    bb->frequency = 0;\n   if (!single_succ_p (bb))\n     {\n       gcc_assert (!EDGE_COUNT (bb->succs));\n@@ -892,11 +889,10 @@ eliminate_tail_call (struct tailcall *t)\n \n   /* Number of executions of function has reduced by the tailcall.  */\n   e = single_succ_edge (gsi_bb (t->call_gsi));\n-  decrease_profile (EXIT_BLOCK_PTR_FOR_FN (cfun), e->count (), EDGE_FREQUENCY (e));\n-  decrease_profile (ENTRY_BLOCK_PTR_FOR_FN (cfun), e->count (),\n-\t\t    EDGE_FREQUENCY (e));\n+  decrease_profile (EXIT_BLOCK_PTR_FOR_FN (cfun), e->count ());\n+  decrease_profile (ENTRY_BLOCK_PTR_FOR_FN (cfun), e->count ());\n   if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-    decrease_profile (e->dest, e->count (), EDGE_FREQUENCY (e));\n+    decrease_profile (e->dest, e->count ());\n \n   /* Replace the call by a jump to the start of function.  */\n   e = redirect_edge_and_branch (single_succ_edge (gsi_bb (t->call_gsi)),"}, {"sha": "be34310fd03fdd1213a9d191df596ec55fbdb69f", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -1843,7 +1843,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \n \t  /* Simply propagate profile info from guard_bb to guard_to which is\n \t     a merge point of control flow.  */\n-\t  guard_to->frequency = guard_bb->frequency;\n \t  guard_to->count = guard_bb->count;\n \t  /* Scale probability of epilog loop back.\n \t     FIXME: We should avoid scaling down and back up.  Profile may"}, {"sha": "afb36eab1f7e94aacf976a03fc33fd4840ac68f3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -7229,20 +7229,14 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n   gcov_type new_est_niter = niter_for_unrolled_loop (loop, vf);\n   profile_count freq_h = loop->header->count, freq_e = preheader->count ();\n \n-  /* Use frequency only if counts are zero.  */\n-  if (!(freq_h > 0) && !(freq_e > 0))\n-    {\n-      freq_h = profile_count::from_gcov_type (loop->header->frequency);\n-      freq_e = profile_count::from_gcov_type (EDGE_FREQUENCY (preheader));\n-    }\n-  if (freq_h > 0)\n+  if (freq_h.nonzero_p ())\n     {\n       profile_probability p;\n \n       /* Avoid dropping loop body profile counter to 0 because of zero count\n \t in loop's preheader.  */\n-      if (!(freq_e > profile_count::from_gcov_type (1)))\n-       freq_e = profile_count::from_gcov_type (1);\n+      if (!(freq_e == profile_count::zero ()))\n+        freq_e = freq_e.force_nonzero ();\n       p = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h);\n       scale_loop_frequencies (loop, p);\n     }\n@@ -7781,7 +7775,7 @@ optimize_mask_stores (struct loop *loop)\n       efalse = make_edge (bb, store_bb, EDGE_FALSE_VALUE);\n       /* Put STORE_BB to likely part.  */\n       efalse->probability = profile_probability::unlikely ();\n-      store_bb->frequency = PROB_ALWAYS - EDGE_FREQUENCY (efalse);\n+      store_bb->count = efalse->count ();\n       make_single_succ_edge (store_bb, join_bb, EDGE_FALLTHRU);\n       if (dom_info_available_p (CDI_DOMINATORS))\n \tset_immediate_dominator (CDI_DOMINATORS, store_bb, bb);"}, {"sha": "61a4cbd6df6f6e985a0e807539c06b782e7a812e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -3221,7 +3221,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<tree> vargs = vNULL;\n   size_t i, nargs;\n   tree lhs, rtype, ratype;\n-  vec<constructor_elt, va_gc> *ret_ctor_elts;\n+  vec<constructor_elt, va_gc> *ret_ctor_elts = NULL;\n \n   /* Is STMT a vectorizable call?   */\n   if (!is_gimple_call (stmt))"}, {"sha": "52dacd001f8db0cd81806ea1c808a5e8b694fe56", "filename": "gcc/ubsan.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -804,6 +804,7 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n      this edge is unlikely taken, so set up the probability accordingly.  */\n   e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n   e->probability = profile_probability::very_unlikely ();\n+  then_bb->count = e->count ();\n \n   /* Connect 'then block' with the 'else block'.  This is needed\n      as the ubsan routines we call in the 'then block' are not noreturn.\n@@ -1085,6 +1086,7 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n \t accordingly.  */\n       e = make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n       e->probability = profile_probability::very_unlikely ();\n+      then_bb->count = e->count ();\n     }\n   else\n     {\n@@ -1098,12 +1100,14 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n \n       e = make_edge (cond_neg_bb, then_bb, EDGE_TRUE_VALUE);\n       e->probability = profile_probability::very_unlikely ();\n+      then_bb->count = e->count ();\n \n       cond_pos_bb = create_empty_bb (cond_bb);\n       add_bb_to_loop (cond_pos_bb, cond_bb->loop_father);\n \n       e = make_edge (cond_bb, cond_pos_bb, EDGE_TRUE_VALUE);\n       e->probability = profile_probability::even ();\n+      cond_pos_bb->count = e->count ();\n \n       e = make_edge (cond_pos_bb, then_bb, EDGE_TRUE_VALUE);\n       e->probability = profile_probability::very_unlikely ();"}, {"sha": "85de3189f83a257e8d494b99b608797edfa75f7c", "filename": "gcc/value-prof.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -583,7 +583,7 @@ static bool\n check_counter (gimple *stmt, const char * name,\n \t       gcov_type *count, gcov_type *all, profile_count bb_count_d)\n {\n-  gcov_type bb_count = bb_count_d.to_gcov_type ();\n+  gcov_type bb_count = bb_count_d.ipa ().to_gcov_type ();\n   if (*all != bb_count || *count > *all)\n     {\n       location_t locus;\n@@ -1299,7 +1299,7 @@ check_ic_target (gcall *call_stmt, struct cgraph_node *target)\n \n gcall *\n gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n-\t   profile_probability prob, profile_count count, profile_count all)\n+\t   profile_probability prob)\n {\n   gcall *dcall_stmt;\n   gassign *load_stmt;\n@@ -1354,11 +1354,11 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n   /* Edge e_cd connects cond_bb to dcall_bb, etc; note the first letters. */\n   e_cd = split_block (cond_bb, cond_stmt);\n   dcall_bb = e_cd->dest;\n-  dcall_bb->count = count;\n+  dcall_bb->count = cond_bb->count.apply_probability (prob);\n \n   e_di = split_block (dcall_bb, dcall_stmt);\n   icall_bb = e_di->dest;\n-  icall_bb->count = all - count;\n+  icall_bb->count = cond_bb->count - dcall_bb->count;\n \n   /* Do not disturb existing EH edges from the indirect call.  */\n   if (!stmt_ends_bb_p (icall_stmt))\n@@ -1376,7 +1376,7 @@ gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n   if (e_ij != NULL)\n     {\n       join_bb = e_ij->dest;\n-      join_bb->count = all;\n+      join_bb->count = cond_bb->count;\n     }\n \n   e_cd->flags = (e_cd->flags & ~EDGE_FALLTHRU) | EDGE_TRUE_VALUE;\n@@ -1518,7 +1518,7 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n   count = histogram->hvalue.counters [1];\n   all = histogram->hvalue.counters [2];\n \n-  bb_all = gimple_bb (stmt)->count.to_gcov_type ();\n+  bb_all = gimple_bb (stmt)->count.ipa ().to_gcov_type ();\n   /* The order of CHECK_COUNTER calls is important -\n      since check_counter can correct the third parameter\n      and we want to make count <= all <= bb_all. */"}, {"sha": "8190bfd074fe8e4704529ba46bf50eda5437bde5", "filename": "gcc/value-prof.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7a740068ed3cc5961101f07012314d940a97ae5/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=e7a740068ed3cc5961101f07012314d940a97ae5", "patch": "@@ -90,8 +90,7 @@ void gimple_move_stmt_histograms (struct function *, gimple *, gimple *);\n void verify_histograms (void);\n void free_histograms (function *);\n void stringop_block_profile (gimple *, unsigned int *, HOST_WIDE_INT *);\n-gcall *gimple_ic (gcall *, struct cgraph_node *, profile_probability,\n-\t\t  profile_count, profile_count);\n+gcall *gimple_ic (gcall *, struct cgraph_node *, profile_probability);\n bool check_ic_target (gcall *, struct cgraph_node *);\n \n "}]}