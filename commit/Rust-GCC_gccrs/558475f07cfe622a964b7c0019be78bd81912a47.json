{"sha": "558475f07cfe622a964b7c0019be78bd81912a47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU4NDc1ZjA3Y2ZlNjIyYTk2NGI3YzAwMTliZTc4YmQ4MTkxMmE0Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-16T19:01:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-16T19:01:36Z"}, "message": "cp-tree.def (STMT_EXPR): New tree node.\n\n\t* cp-tree.def (STMT_EXPR): New tree node.\n\t* cp-tree.h (STMT_EXPR_STMT): New macro.\n\t(store_return_init): Change prototype.\n\t(finish_named_return_value): New function.\n\t(expand_stmt): Likewise.\n\t(expand_body): Likewise.\n\t(begin_stmt_tree): Likewise.\n\t(finish_stmt_tree): Likewise.\n\t(expanding_p): New variable.\n\t(last_expr_type): Likewise.\n\t(building_stmt_tree): New macro.\n\t* decl.c (start_function): Use building_stmt_tree, not\n\tprocessing_template_decl, where appropriate.\n\t(store_parm_decls): Likewise.\n\t(store_return_init): Move most of the body to semantics.c.\n\t(finish_function): Use building_stmt_tree.\n\t(finish_stmt): Clear last_expr_type here.\n\t(cp_function): Add expanding_p, last_tree, last_expr_type.\n\t(push_cp_function_context): Save them.\n\t(pop_cp_function_context): Restore them.\n\t* decl2.c (setup_vtbl_ptr): Move to semantics.c.\n\t* error.c (dump_expr): Handle STMT_EXPR.\n\t* except.c (expand_start_catch_block): Use building_stmt_tree.\n\tUse add_decl_stmt.\n\t* expr.c (cplus_expand_expr): Handle STMT_EXPR.\n\t(do_case): Move add_tree call to semantics.c.\n\t* parse.y (return_init): Use finish_named_return_value.\n\t(for.init.statement): Use finish_expr_stmt.\n\t* parse.c: Regenerated.\n\t* pt.c (do_pushlevel): Move to semantics.c.\n\t(do_poplevel): Likewise.\n\t(tsubst_copy): Handle STMT_EXPR instead of BIND_EXPR.\n\t(tsubst_expr): Don't expand all the way to RTL here.  Handle\n\tRETURN_INIT and CTOR_INITIALIZER.\n\t(instantiate_decl): Call expand_body after tsubst'ing into\n\tDECL_SAVED_TREE.\n\t* semantics.c (expand_stmts): New function.\n\t(expanding_p): New variable.\n\t(last_expr_type): Likewise.\n\t(finish_expr_stmt): Use building_stmt_tree.\n\t(begin_if_stmt): Likewise.\n\t(finish_if_stmt_cond): Likewise.\n\t(finish_then_clause): Likewise.\n\t(begin_else_clause): Likewise.\n\t(finish_else_clause): Likewise.\n\t(begin_while_stmt): Likewise.\n\t(finish_while_stmt_cond): Likewise.\n\t(finish_while_stmt): Likewise.\n\t(finish_do_body): Likewise.\n\t(finish_do_stmt): Likewise.\n\t(finish_return_stmt): Likewise.\n\t(begin_for_stmt): Likewise.\n\t(fnish_for_init_stmt): Likewise.\n\t(finish_for_cond): Likewise.\n\t(finish_for_expr): Likewise.\n\t(finish_for_stmt): Likewise.\n\t(finish_break_stmt): Likewise.\n\t(finish_continue_stmt): Likewise.\n\t(finish_switch_cond): Likewise.\n\t(finish_switch_stmt): Likewise.\n\t(finish_case_label): Call add_tree here if necessary.\n\t(finish_goto_statement): Use building_stmt_tree.\n\t(begin_try_block): Likewise.\n\t(begin_function_try_block): Likewise.\n\t(finish_try_block): Likewise.\n\t(finish_function_try_block): Likewise.\n\t(finish_handler_sequence): Likewise.\n\t(finish_function_handler_sequence): Likewise.\n\t(begin_handler): Likewise.\n\t(finish_handler_parms): Likewise.\n\t(finish_handler): Likewise.\n\t(begin_compound_stmt): Likewise.\n\t(finish_compound_stmt): Likewise.\n\t(finish_asm_stmt): Likewise.\n\t(finish_label_stmt): Likewise.\n\t(finish_named_return_value): New function.\n\t(setup_vtbl_ptr): Moved here from decl2.c.\n\t(do_pushlevel): Moved here from pt.c.\n\t(do_poplevel): Likewise.\n\t(begin_stmt_expr): Use building_stmt_tree.\n\t(finish_stmt_expr): Likewise.  Build a STMT_EXPR, not a BIND_EXPR,\n\twhen building_stmt_tree.\n\t(begin_stmt_tree): New function.\n\t(finish_stmt_tree): Likewise.\n\t(expand_stmt): Likewise.\n\t(expand_body): Likewise.\n\t* tree.c (build_cplus_method_type): Make sure the argument types\n\tend up on the same obstack as the METHOD_TYPE.\n\t(search_tree): Handle COMPOUND_EXPR, MODIFY_EXPR,\n\tTHROW_EXPR, STMT_EXPR.\n\t(mapcar): Break out common cases.  Handle COMPOUND_EXPR,\n\tMODIFY_EXPR, THROW_EXPR, STMT_EXPR, RTL_EXPR.  Abort, rather than\n\tsorry, if an unsupported node is encountered.\n\t* typeck.c (require_complete_type_in_void): Handle BIND_EXPR.\n\t(c_expand_return): Don't call add_tree here.\n\nFrom-SVN: r28729", "tree": {"sha": "941793477b95a8310030bd04dc3b51507e7b23d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/941793477b95a8310030bd04dc3b51507e7b23d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/558475f07cfe622a964b7c0019be78bd81912a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558475f07cfe622a964b7c0019be78bd81912a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/558475f07cfe622a964b7c0019be78bd81912a47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558475f07cfe622a964b7c0019be78bd81912a47/comments", "author": null, "committer": null, "parents": [{"sha": "63ebc2756028198247166b6f46554b62b028dce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ebc2756028198247166b6f46554b62b028dce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ebc2756028198247166b6f46554b62b028dce9"}], "stats": {"total": 1229, "additions": 846, "deletions": 383}, "files": [{"sha": "bf6c0ac1f384cda355758ad188294bd130cf8054", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -1,3 +1,101 @@\n+1999-08-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (STMT_EXPR): New tree node.\n+\t* cp-tree.h (STMT_EXPR_STMT): New macro.\n+\t(store_return_init): Change prototype.\n+\t(finish_named_return_value): New function.\n+\t(expand_stmt): Likewise.\n+\t(expand_body): Likewise.\n+\t(begin_stmt_tree): Likewise.\n+\t(finish_stmt_tree): Likewise.\n+\t(expanding_p): New variable.\n+\t(last_expr_type): Likewise.\n+\t(building_stmt_tree): New macro.\n+\t* decl.c (start_function): Use building_stmt_tree, not\n+\tprocessing_template_decl, where appropriate.\n+\t(store_parm_decls): Likewise.\n+\t(store_return_init): Move most of the body to semantics.c.\n+\t(finish_function): Use building_stmt_tree.\n+\t(finish_stmt): Clear last_expr_type here.\n+\t(cp_function): Add expanding_p, last_tree, last_expr_type.\n+\t(push_cp_function_context): Save them.\n+\t(pop_cp_function_context): Restore them.\n+\t* decl2.c (setup_vtbl_ptr): Move to semantics.c.\n+\t* error.c (dump_expr): Handle STMT_EXPR.\n+\t* except.c (expand_start_catch_block): Use building_stmt_tree.\n+\tUse add_decl_stmt.\n+\t* expr.c (cplus_expand_expr): Handle STMT_EXPR.\n+\t(do_case): Move add_tree call to semantics.c.\n+\t* parse.y (return_init): Use finish_named_return_value.\n+\t(for.init.statement): Use finish_expr_stmt.\n+\t* parse.c: Regenerated.\n+\t* pt.c (do_pushlevel): Move to semantics.c.\n+\t(do_poplevel): Likewise.\n+\t(tsubst_copy): Handle STMT_EXPR instead of BIND_EXPR.\n+\t(tsubst_expr): Don't expand all the way to RTL here.  Handle\n+\tRETURN_INIT and CTOR_INITIALIZER.\n+\t(instantiate_decl): Call expand_body after tsubst'ing into\n+\tDECL_SAVED_TREE.\n+\t* semantics.c (expand_stmts): New function.\n+\t(expanding_p): New variable.\n+\t(last_expr_type): Likewise.\n+\t(finish_expr_stmt): Use building_stmt_tree.\n+\t(begin_if_stmt): Likewise.\n+\t(finish_if_stmt_cond): Likewise.\n+\t(finish_then_clause): Likewise.\n+\t(begin_else_clause): Likewise.\n+\t(finish_else_clause): Likewise.\n+\t(begin_while_stmt): Likewise.\n+\t(finish_while_stmt_cond): Likewise.\n+\t(finish_while_stmt): Likewise.\n+\t(finish_do_body): Likewise.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_return_stmt): Likewise.\n+\t(begin_for_stmt): Likewise.\n+\t(fnish_for_init_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\t(finish_for_expr): Likewise.\n+\t(finish_for_stmt): Likewise.\n+\t(finish_break_stmt): Likewise.\n+\t(finish_continue_stmt): Likewise.\n+\t(finish_switch_cond): Likewise.\n+\t(finish_switch_stmt): Likewise.\n+\t(finish_case_label): Call add_tree here if necessary.\n+\t(finish_goto_statement): Use building_stmt_tree.\n+\t(begin_try_block): Likewise.\n+\t(begin_function_try_block): Likewise.\n+\t(finish_try_block): Likewise.\n+\t(finish_function_try_block): Likewise.\n+\t(finish_handler_sequence): Likewise.\n+\t(finish_function_handler_sequence): Likewise.\n+\t(begin_handler): Likewise.\n+\t(finish_handler_parms): Likewise.\n+\t(finish_handler): Likewise.\n+\t(begin_compound_stmt): Likewise.\n+\t(finish_compound_stmt): Likewise.\n+\t(finish_asm_stmt): Likewise.\n+\t(finish_label_stmt): Likewise.\n+\t(finish_named_return_value): New function.\n+\t(setup_vtbl_ptr): Moved here from decl2.c.\n+\t(do_pushlevel): Moved here from pt.c.\n+\t(do_poplevel): Likewise.\n+\t(begin_stmt_expr): Use building_stmt_tree.\n+\t(finish_stmt_expr): Likewise.  Build a STMT_EXPR, not a BIND_EXPR,\n+\twhen building_stmt_tree.\n+\t(begin_stmt_tree): New function.\n+\t(finish_stmt_tree): Likewise.\n+\t(expand_stmt): Likewise.\n+\t(expand_body): Likewise.\n+\t* tree.c (build_cplus_method_type): Make sure the argument types\n+\tend up on the same obstack as the METHOD_TYPE.\n+\t(search_tree): Handle COMPOUND_EXPR, MODIFY_EXPR,\n+\tTHROW_EXPR, STMT_EXPR.\n+\t(mapcar): Break out common cases.  Handle COMPOUND_EXPR,\n+\tMODIFY_EXPR, THROW_EXPR, STMT_EXPR, RTL_EXPR.  Abort, rather than\n+\tsorry, if an unsupported node is encountered.\n+\t* typeck.c (require_complete_type_in_void): Handle BIND_EXPR.\n+\t(c_expand_return): Don't call add_tree here.\n+\t\n 1999-08-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* pt.c (check_default_tmpl_args): Don't check in local scopes."}, {"sha": "19709222e469b620f9735e6749cad56974c2a399", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -235,6 +235,10 @@ DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n DEFTREECODE (TRY_BLOCK, \"try_stmt\", 'e', 2)\n DEFTREECODE (HANDLER, \"catch_stmt\", 'e', 2)\n \n+/* A STMT_EXPR represents a statement-expression.  The\n+   STMT_EXPR_STMT is the statement given by the expression.  */\n+DEFTREECODE (STMT_EXPR, \"cp_stmt_expr\", 'e', 1)\n+\n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n /* And some codes for expressing conversions for overload resolution.  */"}, {"sha": "486701324edd49f7406fb3a499cec6c3614c5562", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -2138,6 +2138,7 @@ extern int flag_new_for_scope;\n #define ASM_INPUTS(NODE)        TREE_OPERAND (NODE, 3)\n #define ASM_CLOBBERS(NODE)      TREE_OPERAND (NODE, 4)\n #define DECL_STMT_DECL(NODE)    TREE_OPERAND (NODE, 0)\n+#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (NODE, 0)\n \n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n #define ASM_VOLATILE_P(NODE)\t\t\t\\\n@@ -2919,7 +2920,7 @@ extern tree build_enumerator\t\t\tPROTO((tree, tree, tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void expand_start_early_try_stmts\tPROTO((void));\n extern void store_parm_decls\t\t\tPROTO((void));\n-extern void store_return_init\t\t\tPROTO((tree, tree));\n+extern void store_return_init\t\t\tPROTO((tree));\n extern void finish_function\t\t\tPROTO((int, int, int));\n extern tree start_method\t\t\tPROTO((tree, tree, tree));\n extern tree finish_method\t\t\tPROTO((tree));\n@@ -3365,6 +3366,17 @@ extern void finish_member_declaration           PROTO((tree));\n extern void check_multiple_declarators          PROTO((void));\n extern tree finish_typeof\t\t\tPROTO((tree));\n extern void add_decl_stmt                       PROTO((tree));\n+extern void finish_named_return_value           PROTO((tree, tree));\n+extern tree expand_stmt                         PROTO((tree));\n+extern void expand_body                         PROTO((tree));\n+extern void begin_stmt_tree                     PROTO((tree));\n+extern void finish_stmt_tree                    PROTO((tree));\n+extern int expanding_p;\n+extern tree last_expr_type;\n+/* Non-zero if we are presently building a statement tree, rather\n+   than expanding each statement as we encounter it.  */\n+#define building_stmt_tree() \\\n+  (processing_template_decl || !expanding_p)\n \n /* in spew.c */\n extern void init_spew\t\t\t\tPROTO((void));"}, {"sha": "374717cc1a6d5beaa13b2979e823350b46c82c50", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 66, "deletions": 99, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -4341,7 +4341,7 @@ maybe_push_decl (decl)\n        && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n       || (TREE_CODE (decl) == TEMPLATE_DECL && !namespace_bindings_p ())\n       || TREE_CODE (type) == UNKNOWN_TYPE\n-      /* The declaration of template specializations does not affect\n+      /* The declaration of a template specialization does not affect\n \t the functions available for overload resolution, so we do not\n \t call pushdecl.  */\n       || (TREE_CODE (decl) == FUNCTION_DECL\n@@ -12882,7 +12882,8 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n       && IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)) != NULL_TREE)\n     cp_warning_at (\"`%D' implicitly declared before its definition\", IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)));\n \n-  announce_function (decl1);\n+  if (!building_stmt_tree ())\n+    announce_function (decl1);\n \n   /* Set up current_class_type, and enter the scope of the class, if\n      appropriate.  */\n@@ -13110,12 +13111,14 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   pushlevel (0);\n   current_binding_level->parm_flag = 1;\n \n-  GNU_xref_function (decl1, current_function_parms);\n-\n   if (attrs)\n     cplus_decl_attributes (decl1, NULL_TREE, attrs);\n   \n-  make_function_rtl (decl1);\n+  if (!building_stmt_tree ())\n+    {\n+      GNU_xref_function (decl1, current_function_parms);\n+      make_function_rtl (decl1);\n+    }\n \n   /* Promote the value to int before returning it.  */\n   if (C_PROMOTING_INTEGER_TYPE_P (restype))\n@@ -13141,9 +13144,8 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   if (! hack_decl_function_context (decl1))\n     temporary_allocation ();\n \n-  if (processing_template_decl)\n-    last_tree = DECL_SAVED_TREE (decl1)\n-      = build_nt (EXPR_STMT, void_zero_node);\n+  if (building_stmt_tree ())\n+    begin_stmt_tree (decl1);\n \n   ++function_depth;\n \n@@ -13254,7 +13256,7 @@ store_parm_decls ()\n \n \t\t  pushdecl (parm);\n \t\t}\n-\t      if (! processing_template_decl\n+\t      if (! building_stmt_tree ()\n \t\t  && (cleanup = maybe_build_cleanup (parm), cleanup))\n \t\t{\n \t\t  expand_decl (parm);\n@@ -13295,21 +13297,20 @@ store_parm_decls ()\n \n   /* Initialize the RTL code for the function.  */\n   DECL_SAVED_INSNS (fndecl) = 0;\n-  if (! processing_template_decl)\n+  if (! building_stmt_tree ())\n     expand_function_start (fndecl, parms_have_cleanups);\n \n   current_function_parms_stored = 1;\n \n   /* If this function is `main', emit a call to `__main'\n      to run global initializers, etc.  */\n-  if (DECL_MAIN_P (fndecl))\n+  if (DECL_MAIN_P (fndecl) && !building_stmt_tree ())\n     expand_main_function ();\n \n   /* Now that we have initialized the parms, we can start their\n      cleanups.  We cannot do this before, since expand_decl_cleanup\n      should not be called before the parm can be used.  */\n-  if (cleanups\n-      && ! processing_template_decl)      \n+  if (cleanups && !building_stmt_tree ())\n     {\n       for (cleanups = nreverse (cleanups); cleanups; cleanups = TREE_CHAIN (cleanups))\n \t{\n@@ -13325,10 +13326,11 @@ store_parm_decls ()\n   if (parms_have_cleanups)\n     {\n       pushlevel (0);\n-      expand_start_bindings (0);\n+      if (!building_stmt_tree ())\n+\texpand_start_bindings (0);\n     }\n \n-  if (! processing_template_decl && flag_exceptions)\n+  if (! building_stmt_tree () && flag_exceptions)\n     {\n       /* Do the starting of the exception specifications, if we have any.  */\n       if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n@@ -13343,55 +13345,15 @@ store_parm_decls ()\n    the current function.  */\n \n void\n-store_return_init (return_id, init)\n-     tree return_id, init;\n+store_return_init (decl)\n+     tree decl;\n {\n-  tree decl = DECL_RESULT (current_function_decl);\n-\n-  if (pedantic)\n-    /* Give this error as many times as there are occurrences,\n-       so that users can use Emacs compilation buffers to find\n-       and fix all such places.  */\n-    pedwarn (\"ANSI C++ does not permit named return values\");\n-\n-  if (return_id != NULL_TREE)\n-    {\n-      if (DECL_NAME (decl) == NULL_TREE)\n-\t{\n-\t  DECL_NAME (decl) = return_id;\n-\t  DECL_ASSEMBLER_NAME (decl) = return_id;\n-\t}\n-      else\n-\tcp_error (\"return identifier `%D' already in place\", decl);\n-    }\n-\n-  /* Can't let this happen for constructors.  */\n-  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+  /* If this named return value comes in a register, put it in a\n+     pseudo-register.  */\n+  if (DECL_REGISTER (decl))\n     {\n-      error (\"can't redefine default return value for constructors\");\n-      return;\n-    }\n-\n-  /* If we have a named return value, put that in our scope as well.  */\n-  if (DECL_NAME (decl) != NULL_TREE)\n-    {\n-      /* If this named return value comes in a register,\n-\t put it in a pseudo-register.  */\n-      if (DECL_REGISTER (decl))\n-\t{\n-\t  original_result_rtx = DECL_RTL (decl);\n-\t  DECL_RTL (decl) = gen_reg_rtx (DECL_MODE (decl));\n-\t}\n-\n-      /* Let `cp_finish_decl' know that this initializer is ok.  */\n-      DECL_INITIAL (decl) = init;\n-      pushdecl (decl);\n-\n-      if (processing_template_decl && current_function_decl)\n-\tadd_tree (build_min_nt (RETURN_INIT, return_id,\n-\t\t\t\tcopy_to_permanent (init)));\n-      else\n-\tcp_finish_decl (decl, init, NULL_TREE, 0, 0);\n+      original_result_rtx = DECL_RTL (decl);\n+      DECL_RTL (decl) = gen_reg_rtx (DECL_MODE (decl));\n     }\n }\n \n@@ -13430,7 +13392,7 @@ finish_function (lineno, flags, nested)\n   tree decls = NULL_TREE;\n   int call_poplevel = (flags & 1) != 0;\n   int inclass_inline = (flags & 2) != 0;\n-  int in_template;\n+  int expand_p;\n \n   /* When we get some parse errors, we can end up without a\n      current_function_decl, so cope.  */\n@@ -13453,7 +13415,7 @@ finish_function (lineno, flags, nested)\n       store_parm_decls ();\n     }\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       if (DECL_CONSTRUCTOR_P (fndecl) && call_poplevel)\n \t{\n@@ -13834,19 +13796,15 @@ finish_function (lineno, flags, nested)\n       /* Generate rtl for function exit.  */\n       expand_function_end (input_filename, lineno, 1);\n     }\n+\n+  /* We have to save this value here in case\n+     maybe_end_member_template_processing decides to pop all the\n+     template parameters.  */\n+  expand_p = !building_stmt_tree ();\n   \n-  /* If we're processing a template, squirrel away the definition\n-     until we do an instantiation.  */\n-  if (processing_template_decl)\n-    {\n-      DECL_SAVED_TREE (fndecl) = TREE_CHAIN (DECL_SAVED_TREE (fndecl));\n-      /* We have to save this value here in case\n-\t maybe_end_member_template_processing decides to pop all the\n-\t template parameters.  */\n-      in_template = 1;\n-    }\n-  else\n-    in_template = 0;\n+  /* If we're saving up tree structure, tie off the function now.  */\n+  if (!expand_p)\n+    finish_stmt_tree (fndecl);\n \n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n@@ -13880,7 +13838,7 @@ finish_function (lineno, flags, nested)\n      to the FUNCTION_DECL node itself.  */\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n-  if (!in_template)\n+  if (expand_p)\n     {\n       int saved_flag_keep_inline_functions =\n \tflag_keep_inline_functions;\n@@ -14285,12 +14243,6 @@ void\n cplus_expand_expr_stmt (exp)\n      tree exp;\n {\n-  if (processing_template_decl)\n-    {\n-      add_tree (build_min_nt (EXPR_STMT, exp));\n-      return;\n-    }\n-\n   /* Arrange for all temps to disappear.  */\n   expand_start_target_temps ();\n \n@@ -14324,28 +14276,30 @@ cplus_expand_expr_stmt (exp)\n   expand_end_target_temps ();\n }\n \n-/* When a stmt has been parsed, this function is called.\n-\n-   Currently, this function only does something within a\n-   constructor's scope: if a stmt has just assigned to this,\n-   and we are in a derived class, we call `emit_base_init'.  */\n+/* When a stmt has been parsed, this function is called.  */\n \n void\n finish_stmt ()\n {\n-  if (current_function_assigns_this\n-      || ! current_function_just_assigned_this)\n-    return;\n-  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+  if (!current_function_assigns_this\n+      && current_function_just_assigned_this)\n     {\n-      /* Constructors must wait until we are out of control\n-\t zones before calling base constructors.  */\n-      if (in_control_zone_p ())\n-\treturn;\n-      expand_expr_stmt (base_init_expr);\n-      check_base_init (current_class_type);\n+      if (DECL_CONSTRUCTOR_P (current_function_decl))\n+\t{\n+\t  /* Constructors must wait until we are out of control\n+\t     zones before calling base constructors.  */\n+\t  if (in_control_zone_p ())\n+\t    return;\n+\t  expand_expr_stmt (base_init_expr);\n+\t  check_base_init (current_class_type);\n+\t}\n+      current_function_assigns_this = 1;\n     }\n-  current_function_assigns_this = 1;\n+\n+  /* Always assume this statement was not an expression statement.  If\n+     it actually was an expression statement, its our callers\n+     responsibility to fix this up.  */\n+  last_expr_type = NULL_TREE;\n }\n \n /* Change a static member function definition into a FUNCTION_TYPE, instead\n@@ -14408,6 +14362,9 @@ struct cp_function\n   struct binding_level *binding_level;\n   int static_labelno;\n   int in_function_try_handler;\n+  int expanding_p;\n+  tree last_tree;\n+  tree last_expr_type;\n };\n \n static struct cp_function *cp_function_chain;\n@@ -14451,6 +14408,13 @@ push_cp_function_context (context)\n   p->current_class_ref = current_class_ref;\n   p->static_labelno = static_labelno;\n   p->in_function_try_handler = in_function_try_handler;\n+  p->last_tree = last_tree;\n+  p->last_expr_type = last_expr_type;\n+  p->expanding_p = expanding_p;\n+  \n+  /* For now, we always assume we're expanding all the way to RTL\n+     unless we're explicitly doing otherwise.  */\n+  expanding_p = 1;\n }\n \n /* Restore the variables used during compilation of a C++ function.  */\n@@ -14494,6 +14458,9 @@ pop_cp_function_context (context)\n   current_class_ref = p->current_class_ref;\n   static_labelno = p->static_labelno;\n   in_function_try_handler = p->in_function_try_handler;\n+  last_tree = p->last_tree;\n+  last_expr_type = p->last_expr_type;\n+  expanding_p = p->expanding_p;\n \n   free (p);\n }"}, {"sha": "e4d2d0e1120f643824d57faf6bba1557d3a71c28", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -2001,27 +2001,6 @@ constructor_name (thing)\n   return t;\n }\n \f\n-/* Cache the value of this class's main virtual function table pointer\n-   in a register variable.  This will save one indirection if a\n-   more than one virtual function call is made this function.  */\n-\n-void\n-setup_vtbl_ptr ()\n-{\n-  extern tree base_init_expr;\n-\n-  if (base_init_expr == 0\n-      && DECL_CONSTRUCTOR_P (current_function_decl))\n-    {\n-      if (processing_template_decl)\n-\tadd_tree (build_min_nt\n-\t\t  (CTOR_INITIALIZER,\n-\t\t   current_member_init_list, current_base_init_list));\n-      else\n-\temit_base_init (current_class_type, 0);\n-    }\n-}\n-\n /* Record the existence of an addressable inline function.  */\n \n void"}, {"sha": "ce0ffbf11b66e1f4eee57ea71d3480277b19f1b9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -1780,6 +1780,12 @@ dump_expr (t, nop)\n       dump_decl (t, 0);\n       break;\n \n+    case STMT_EXPR:\n+      /* We don't yet have a way of dumping statements in a\n+\t human-readable format.  */\n+      OB_PUTS (\"{ ... }\");\n+      break;\n+\n     case BIND_EXPR:\n       OB_PUTS (\"{ \");\n       dump_expr (TREE_OPERAND (t, 1), nop);"}, {"sha": "2dbdbd3b91f6df418ad218b61744a13d206fae26", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -558,17 +558,14 @@ expand_start_catch_block (declspecs, declarator)\n {\n   tree decl;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       if (declspecs)\n \t{\n \t  decl = grokdeclarator (declarator, declspecs, CATCHPARM,\n \t\t\t\t 1, NULL_TREE);\n \t  pushdecl (decl);\n-\t  decl = build_min_nt (DECL_STMT, copy_to_permanent (declarator),\n-\t\t\t       copy_to_permanent (declspecs),\n-\t\t\t       NULL_TREE);\n-\t  add_tree (decl);\n+\t  add_decl_stmt (decl);\n \t}\n       return;\n     }\n@@ -579,7 +576,6 @@ expand_start_catch_block (declspecs, declarator)\n   process_start_catch_block (declspecs, declarator);\n }\n \n-\n /* This function performs the expand_start_catch_block functionality for \n    exceptions implemented in the new style. __throw determines whether\n    a handler needs to be called or not, so the handler itself has to do"}, {"sha": "42fb75798611306c1b0081b067695311bfee5e7f", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -246,6 +246,15 @@ cplus_expand_expr (exp, target, tmode, modifier)\n     case NEW_EXPR:\n       return expand_expr (build_new_1 (exp), target, tmode, modifier);\n \n+    case STMT_EXPR:\n+      {\n+\ttree rtl_expr = begin_stmt_expr ();\n+\ttree block = expand_stmt (STMT_EXPR_STMT (exp));\n+\tfinish_stmt_expr (rtl_expr, block);\n+\treturn expand_expr (rtl_expr, target, tmode, modifier);\n+      }\n+      break;\n+\n     default:\n       break;\n     }\n@@ -388,12 +397,6 @@ do_case (start, end)\n   if (end && pedantic)\n     pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n \n-  if (processing_template_decl)\n-    {\n-      add_tree (build_min_nt (CASE_LABEL, start, end));\n-      return;\n-    }\n-\n   if (start)\n     value1 = check_cp_case_value (start);\n   if (end)"}, {"sha": "c5d435c02930783c36e8268393a2cb3619578138", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -4912,15 +4912,15 @@ case 122:\n     break;}\n case 123:\n #line 770 \"parse.y\"\n-{ store_return_init (yyval.ttype, yyvsp[0].ttype); ;\n+{ finish_named_return_value (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 124:\n #line 772 \"parse.y\"\n-{ store_return_init (yyval.ttype, yyvsp[-1].ttype); ;\n+{ finish_named_return_value (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 125:\n #line 774 \"parse.y\"\n-{ store_return_init (yyval.ttype, NULL_TREE); ;\n+{ finish_named_return_value (yyval.ttype, NULL_TREE); ;\n     break;}\n case 126:\n #line 779 \"parse.y\"\n@@ -7732,7 +7732,7 @@ case 783:\n     break;}\n case 784:\n #line 3411 \"parse.y\"\n-{ if (yyvsp[-1].ttype) cplus_expand_expr_stmt (yyvsp[-1].ttype); ;\n+{ finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 786:\n #line 3414 \"parse.y\""}, {"sha": "d735aa785c6a402535e58ee1c4a9e15b4bda159b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -767,11 +767,11 @@ return_id:\n \n return_init:\n \t  return_id maybe_init\n-\t\t{ store_return_init ($<ttype>$, $2); }\n+\t\t{ finish_named_return_value ($<ttype>$, $2); }\n \t| return_id '(' nonnull_exprlist ')'\n-\t\t{ store_return_init ($<ttype>$, $3); }\n+\t\t{ finish_named_return_value ($<ttype>$, $3); }\n \t| return_id LEFT_RIGHT\n-\t\t{ store_return_init ($<ttype>$, NULL_TREE); }\n+\t\t{ finish_named_return_value ($<ttype>$, NULL_TREE); }\n \t;\n \n base_init:\n@@ -3408,7 +3408,7 @@ label_colon:\n \n for.init.statement:\n \t  xexpr ';'\n-\t\t{ if ($1) cplus_expand_expr_stmt ($1); }\n+                { finish_expr_stmt ($1); }\n \t| decl\n \t| '{' compstmtend\n \t\t{ if (pedantic)"}, {"sha": "674834b9ae0be8e107c16f78fd65e793c38c33e2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 95, "deletions": 128, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -6839,35 +6839,6 @@ tsubst (t, args, complain, in_decl)\n     }\n }\n \n-void\n-do_pushlevel ()\n-{\n-  emit_line_note (input_filename, lineno);\n-  pushlevel (0);\n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n-}  \n-\n-tree\n-do_poplevel ()\n-{\n-  tree t;\n-  int saved_warn_unused = 0;\n-\n-  if (processing_template_decl)\n-    {\n-      saved_warn_unused = warn_unused;\n-      warn_unused = 0;\n-    }\n-  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  if (processing_template_decl)\n-    warn_unused = saved_warn_unused;\n-  t = poplevel (kept_level_p (), 1, 0);\n-  pop_momentary ();\n-  return t;\n-}\n-\n /* Like tsubst, but deals with expressions.  This function just replaces\n    template parms; to finish processing the resultant expression, use\n    tsubst_expr.  */\n@@ -7083,29 +7054,28 @@ tsubst_copy (t, args, complain, in_decl)\n \t   NULL_TREE);\n       }\n \n-    case BIND_EXPR:\n+    case STMT_EXPR:\n+      /* This processing should really occur in tsubst_expr, However,\n+\t tsubst_expr does not recurse into expressions, since it\n+\t assumes that there aren't any statements inside them.\n+\t Instead, it simply calls build_expr_from_tree.  So, we need\n+\t to expand the STMT_EXPR here.  */\n+      if (!processing_template_decl)\n+\t{\n+\t  tree rtl_expr = begin_stmt_expr ();\n+\t  tree block = tsubst_expr (STMT_EXPR_STMT (t), args,\n+\t\t\t\t    complain, in_decl);\n+\t  r = finish_stmt_expr (rtl_expr, block);\n+\t}\n+      return r;\n+\n     case COND_EXPR:\n     case MODOP_EXPR:\n       {\n \tr = build_nt\n \t  (code, tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl),\n \t   tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl),\n \t   tsubst_copy (TREE_OPERAND (t, 2), args, complain, in_decl));\n-\n-\tif (code == BIND_EXPR && !processing_template_decl)\n-\t  {\n-\t    /* This processing should really occur in tsubst_expr,\n-\t       However, tsubst_expr does not recurse into expressions,\n-\t       since it assumes that there aren't any statements\n-\t       inside them.  Instead, it simply calls\n-\t       build_expr_from_tree.  So, we need to expand the\n-\t       BIND_EXPR here.  */ \n-\t    tree rtl_expr = begin_stmt_expr ();\n-\t    tree block = tsubst_expr (TREE_OPERAND (r, 1), args,\n-\t\t\t\t      complain, in_decl);\n-\t    r = finish_stmt_expr (rtl_expr, block);\n-\t  }\n-\n \treturn r;\n       }\n \n@@ -7218,14 +7188,16 @@ tsubst_copy (t, args, complain, in_decl)\n     }\n }\n \n-/* Like tsubst_copy, but also does semantic processing and RTL expansion.  */\n+/* Like tsubst_copy, but also does semantic processing.  */\n \n tree\n tsubst_expr (t, args, complain, in_decl)\n      tree t, args;\n      int complain;\n      tree in_decl;\n {\n+  tree stmt;\n+\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n@@ -7234,6 +7206,22 @@ tsubst_expr (t, args, complain, in_decl)\n \n   switch (TREE_CODE (t))\n     {\n+    case RETURN_INIT:\n+      finish_named_return_value\n+\t(TREE_OPERAND (t, 0),\n+\t tsubst_expr (TREE_OPERAND (t, 1), args, /*complain=*/1, in_decl));\n+      tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n+      break;\n+\n+    case CTOR_INITIALIZER:\n+      current_member_init_list\n+\t= tsubst_expr_values (TREE_OPERAND (t, 0), args);\n+      current_base_init_list\n+\t= tsubst_expr_values (TREE_OPERAND (t, 1), args);\n+      setup_vtbl_ptr ();\n+      tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n+      break;\n+\n     case RETURN_STMT:\n       lineno = STMT_LINENO (t);\n       finish_return_stmt (tsubst_expr (RETURN_EXPR (t),\n@@ -7253,18 +7241,19 @@ tsubst_expr (t, args, complain, in_decl)\n \ttree init;\n \n \tlineno = STMT_LINENO (t);\n-\temit_line_note (input_filename, lineno);\n \tdecl = DECL_STMT_DECL (t);\n \tinit = DECL_INITIAL (decl);\n \tdecl = tsubst (decl, args, complain, in_decl);\n \tinit = tsubst_expr (init, args, complain, in_decl);\n \tDECL_INITIAL (decl) = init;\n-\tmaybe_push_decl (decl);\n+\t/* By marking the declaration as instantiated, we avoid trying\n+\t   to instantiate it.  Since instantiate_decl can't handle\n+\t   local variables, and since we've already done all that\n+\t   needs to be done, that's the right thing to do.  */\n \tif (TREE_CODE (decl) == VAR_DECL)\n \t  DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n-\tstart_decl_1 (decl);\n-\tcp_finish_decl\n-\t  (decl, init, NULL_TREE, 0, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n+\tmaybe_push_decl (decl);\n+\tadd_decl_stmt (decl);\n \tresume_momentary (i);\n \treturn decl;\n       }\n@@ -7274,41 +7263,41 @@ tsubst_expr (t, args, complain, in_decl)\n \ttree tmp;\n \tlineno = STMT_LINENO (t);\n \n-\tbegin_for_stmt ();\n+\tstmt = begin_for_stmt ();\n \tfor (tmp = FOR_INIT_STMT (t); tmp; tmp = TREE_CHAIN (tmp))\n \t  tsubst_expr (tmp, args, complain, in_decl);\n-\tfinish_for_init_stmt (NULL_TREE);\n+\tfinish_for_init_stmt (stmt);\n \tfinish_for_cond (tsubst_expr (FOR_COND (t), args,\n \t\t\t\t      complain, in_decl),\n-\t\t\t NULL_TREE);\n+\t\t\t stmt);\n \ttmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n-\tfinish_for_expr (tmp, NULL_TREE);\n+\tfinish_for_expr (tmp, stmt);\n \ttsubst_expr (FOR_BODY (t), args, complain, in_decl);\n-\tfinish_for_stmt (tmp, NULL_TREE);\n+\tfinish_for_stmt (tmp, stmt);\n       }\n       break;\n \n     case WHILE_STMT:\n       {\n \tlineno = STMT_LINENO (t);\n-\tbegin_while_stmt ();\n+\tstmt = begin_while_stmt ();\n \tfinish_while_stmt_cond (tsubst_expr (WHILE_COND (t),\n \t\t\t\t\t     args, complain, in_decl),\n-\t\t\t\tNULL_TREE);\n+\t\t\t\tstmt);\n \ttsubst_expr (WHILE_BODY (t), args, complain, in_decl);\n-\tfinish_while_stmt (NULL_TREE);\n+\tfinish_while_stmt (stmt);\n       }\n       break;\n \n     case DO_STMT:\n       {\n \tlineno = STMT_LINENO (t);\n-\tbegin_do_stmt ();\n+\tstmt = begin_do_stmt ();\n \ttsubst_expr (DO_BODY (t), args, complain, in_decl);\n-\tfinish_do_body (NULL_TREE);\n+\tfinish_do_body (stmt);\n \tfinish_do_stmt (tsubst_expr (DO_COND (t), args,\n \t\t\t\t     complain, in_decl),\n-\t\t\tNULL_TREE);\n+\t\t\tstmt);\n       }\n       break;\n \n@@ -7317,22 +7306,22 @@ tsubst_expr (t, args, complain, in_decl)\n \ttree tmp;\n \n \tlineno = STMT_LINENO (t);\n-\tbegin_if_stmt ();\n+\tstmt = begin_if_stmt ();\n \tfinish_if_stmt_cond (tsubst_expr (IF_COND (t),\n \t\t\t\t\t  args, complain, in_decl),\n-\t\t\t     NULL_TREE);\n+\t\t\t     stmt);\n \n \tif (tmp = THEN_CLAUSE (t), tmp)\n \t  {\n \t    tsubst_expr (tmp, args, complain, in_decl);\n-\t    finish_then_clause (NULL_TREE);\n+\t    finish_then_clause (stmt);\n \t  }\n \n \tif (tmp = ELSE_CLAUSE (t), tmp)\n \t  {\n \t    begin_else_clause ();\n \t    tsubst_expr (tmp, args, complain, in_decl);\n-\t    finish_else_clause (NULL_TREE);\n+\t    finish_else_clause (stmt);\n \t  }\n \n \tfinish_if_stmt ();\n@@ -7344,13 +7333,12 @@ tsubst_expr (t, args, complain, in_decl)\n \ttree substmt;\n \n \tlineno = STMT_LINENO (t);\n-\tbegin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+\tstmt = begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n \tfor (substmt = COMPOUND_BODY (t); \n \t     substmt != NULL_TREE;\n \t     substmt = TREE_CHAIN (substmt))\n \t  tsubst_expr (substmt, args, complain, in_decl);\n-\treturn finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n-\t\t\t\t     NULL_TREE);\n+\treturn finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), stmt);\n       }\n       break;\n \n@@ -7366,17 +7354,14 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case SWITCH_STMT:\n       {\n-\ttree val, tmp;\n+\ttree val;\n \n \tlineno = STMT_LINENO (t);\n \tbegin_switch_stmt ();\n \tval = tsubst_expr (SWITCH_COND (t), args, complain, in_decl);\n-\tfinish_switch_cond (val);\n-\t\n-\tif (tmp = TREE_OPERAND (t, 1), tmp)\n-\t  tsubst_expr (tmp, args, complain, in_decl);\n-\n-\tfinish_switch_stmt (val, NULL_TREE);\n+\tstmt = finish_switch_cond (val);\n+\ttsubst_expr (SWITCH_BODY (t), args, complain, in_decl);\n+\tfinish_switch_stmt (val, stmt);\n       }\n       break;\n \n@@ -7414,20 +7399,20 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case TRY_BLOCK:\n       lineno = STMT_LINENO (t);\n-      begin_try_block ();\n+      stmt = begin_try_block ();\n       tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n-      finish_try_block (NULL_TREE);\n+      finish_try_block (stmt);\n       {\n \ttree handler = TRY_HANDLERS (t);\n \tfor (; handler; handler = TREE_CHAIN (handler))\n \t  tsubst_expr (handler, args, complain, in_decl);\n       }\n-      finish_handler_sequence (NULL_TREE);\n+      finish_handler_sequence (stmt);\n       break;\n \n     case HANDLER:\n       lineno = STMT_LINENO (t);\n-      begin_handler ();\n+      stmt = begin_handler ();\n       if (HANDLER_PARMS (t))\n \t{\n \t  tree d = HANDLER_PARMS (t);\n@@ -7437,9 +7422,9 @@ tsubst_expr (t, args, complain, in_decl)\n \t}\n       else\n \texpand_start_catch_block (NULL_TREE, NULL_TREE);\n-      finish_handler_parms (NULL_TREE);\n+      finish_handler_parms (stmt);\n       tsubst_expr (HANDLER_BODY (t), args, complain, in_decl);\n-      finish_handler (NULL_TREE);\n+      finish_handler (stmt);\n       break;\n \n     case TAG_DEFN:\n@@ -9654,57 +9639,39 @@ instantiate_decl (d)\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n-      tree t = DECL_SAVED_TREE (code_pattern);\n-      tree try_block = NULL_TREE;\n+      extern struct obstack *saveable_obstack;\n+      extern struct obstack *rtl_obstack;\n+      int saved_expanding_p = expanding_p;\n+\n+      /* We're not expanding all the way to RTL here.  */\n+      expanding_p = 0;\n \n+      /* Set up context.  */\n       start_function (NULL_TREE, d, NULL_TREE, 1);\n       store_parm_decls ();\n \n-      if (t && TREE_CODE (t) == TRY_BLOCK)\n-\t{\n-\t  try_block = t;\n-\t  begin_function_try_block ();\n-\t  t = TRY_STMTS (try_block);\n-\t}\n-\n-      if (t && TREE_CODE (t) == RETURN_INIT)\n-\t{\n-\t  store_return_init\n-\t    (TREE_OPERAND (t, 0),\n-\t     tsubst_expr (TREE_OPERAND (t, 1), args, /*complain=*/1, tmpl));\n-\t  t = TREE_CHAIN (t);\n-\t}\n-\n-      if (t && TREE_CODE (t) == CTOR_INITIALIZER)\n-\t{\n-\t  current_member_init_list\n-\t    = tsubst_expr_values (TREE_OPERAND (t, 0), args);\n-\t  current_base_init_list\n-\t    = tsubst_expr_values (TREE_OPERAND (t, 1), args);\n-\t  t = TREE_CHAIN (t);\n-\t}\n-\n-      setup_vtbl_ptr ();\n-      /* Always keep the BLOCK node associated with the outermost\n-\t pair of curly braces of a function.  These are needed\n-\t for correct operation of dwarfout.c.  */\n-      keep_next_level ();\n-\n-      my_friendly_assert (TREE_CODE (t) == COMPOUND_STMT, 42);\n-      tsubst_expr (t, args, /*complain=*/1, tmpl);\n-\n-      if (try_block)\n-\t{\n-\t  finish_function_try_block (NULL_TREE);\n-\t  {\n-\t    tree handler = TRY_HANDLERS (try_block);\n-\t    for (; handler; handler = TREE_CHAIN (handler))\n-\t      tsubst_expr (handler, args, /*complain=*/1, tmpl);\n-\t  }\n-\t  finish_function_handler_sequence (NULL_TREE);\n-\t}\n-\n+      /* Anything we might\n+\t want to save is going to have to be saved forever.  Note that\n+\t we don't want to save all kinds of temporary clutter that\n+\t might end up on the temporary obstack so we don't want to\n+\t call push_permanent_obstack.  */\n+      push_obstacks_nochange ();\n+      saveable_obstack = &permanent_obstack;\n+      /* We only need this because of the cases where we generate\n+\t RTL_EXPRs.  We should really be generating RTL_EXPRs until\n+\t final expansion time; when that is fixed, this can go.  */\n+      rtl_obstack = &permanent_obstack;\n+      /* Substitute into the body of the function.  */\n+      tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n+\t\t   /*complain=*/1, tmpl);\n+\n+      /* Clean up.  */\n+      pop_obstacks ();\n       finish_function (lineno, 0, nested);\n+      expanding_p = saved_expanding_p;\n+\n+      /* Now, generate RTL for the function.  */\n+      expand_body (d);\n     }\n \n out:"}, {"sha": "dc6b54144b0c255d1139499067db8472631560bf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 501, "deletions": 61, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -41,6 +41,18 @@\n    parsing into this file; that will make implementing the new parser\n    much easier since it will be able to make use of these routines.  */\n \n+static void expand_stmts PROTO((tree));\n+\n+/* Non-zero if we should generate RTL for functions that we process.\n+   When this is zero, we just accumulate tree structure, without\n+   interacting with the back end.  */\n+int expanding_p = 1;\n+\n+/* The type of the last expression-statement we have seen.  This is\n+   required because the type of a statement-expression is the type of\n+   the last expression statement.  */\n+tree last_expr_type;\n+\n /* When parsing a template, LAST_TREE contains the last statement\n    parsed.  These are chained together through the TREE_CHAIN field,\n    but often need to be re-organized since the parse is performed\n@@ -68,7 +80,9 @@ finish_expr_stmt (expr)\n {\n   if (expr != NULL_TREE)\n     {\n-      if (!processing_template_decl)\n+      if (building_stmt_tree ())\n+\tadd_tree (build_min_nt (EXPR_STMT, expr));\n+      else\n \t{\n \t  emit_line_note (input_filename, lineno);\n \t  /* Do default conversion if safe and possibly important,\n@@ -77,13 +91,17 @@ finish_expr_stmt (expr)\n \t       && lvalue_p (expr))\n \t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n \t    expr = default_conversion (expr);\n+\t  cplus_expand_expr_stmt (expr);\n \t}\n-      \n-      cplus_expand_expr_stmt (expr);\n+\n       clear_momentary ();\n     }\n \n   finish_stmt ();\n+\n+  /* This was an expression-statement, so we save the type of the\n+     expression.  */\n+  last_expr_type = expr ? TREE_TYPE (expr) : NULL_TREE;\n }\n \n /* Begin an if-statement.  Returns a newly created IF_STMT if\n@@ -94,7 +112,7 @@ begin_if_stmt ()\n {\n   tree r;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       r = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n       add_tree (r);\n@@ -115,7 +133,7 @@ finish_if_stmt_cond (cond, if_stmt)\n      tree cond;\n      tree if_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       if (last_tree != if_stmt)\n \tRECHAIN_STMTS_FROM_LAST (if_stmt, IF_COND (if_stmt));\n@@ -136,7 +154,7 @@ tree\n finish_then_clause (if_stmt)\n      tree if_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       RECHAIN_STMTS_FROM_CHAIN (if_stmt, \n \t\t\t\tTHEN_CLAUSE (if_stmt));\n@@ -152,7 +170,7 @@ finish_then_clause (if_stmt)\n void \n begin_else_clause ()\n {\n-  if (!processing_template_decl)\n+  if (!building_stmt_tree ())\n     expand_start_else ();\n }\n \n@@ -163,7 +181,7 @@ void\n finish_else_clause (if_stmt)\n      tree if_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (if_stmt, ELSE_CLAUSE (if_stmt));\n }\n \n@@ -172,7 +190,7 @@ finish_else_clause (if_stmt)\n void \n finish_if_stmt ()\n {\n-  if (!processing_template_decl)\n+  if (!building_stmt_tree ())\n     expand_end_cond ();\n \n   do_poplevel ();\n@@ -187,7 +205,7 @@ begin_while_stmt ()\n {\n   tree r;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       r = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);\n       add_tree (r);\n@@ -213,11 +231,10 @@ finish_while_stmt_cond (cond, while_stmt)\n      tree cond;\n      tree while_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       if (last_tree != while_stmt)\n-\tRECHAIN_STMTS_FROM_LAST (while_stmt, \n-\t\t\t\t      WHILE_COND (while_stmt)); \n+\tRECHAIN_STMTS_FROM_LAST (while_stmt, WHILE_COND (while_stmt)); \n       else\n \tTREE_OPERAND (while_stmt, 0) = copy_to_permanent (cond);\n     }\n@@ -245,7 +262,7 @@ finish_while_stmt (while_stmt)\n {\n   do_poplevel ();\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (while_stmt, WHILE_BODY (while_stmt));\n   else\n     expand_end_loop ();\n@@ -258,7 +275,7 @@ finish_while_stmt (while_stmt)\n tree\n begin_do_stmt ()\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       tree r = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);\n       add_tree (r);\n@@ -279,7 +296,7 @@ void\n finish_do_body (do_stmt)\n      tree do_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (do_stmt, DO_BODY (do_stmt));\n   else\n     expand_loop_continue_here ();\n@@ -293,7 +310,7 @@ finish_do_stmt (cond, do_stmt)\n      tree cond;\n      tree do_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     DO_COND (do_stmt) = copy_to_permanent (cond);\n   else\n     {\n@@ -313,8 +330,14 @@ void\n finish_return_stmt (expr)\n      tree expr;\n {\n-  emit_line_note (input_filename, lineno);\n-  c_expand_return (expr);\n+  if (building_stmt_tree ())\n+    add_tree (build_min_nt (RETURN_STMT, expr));\n+  else\n+    {\n+      emit_line_note (input_filename, lineno);\n+      c_expand_return (expr);\n+    }\n+\n   finish_stmt ();\n }\n \n@@ -325,7 +348,7 @@ begin_for_stmt ()\n {\n   tree r;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       r = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, \n \t\t\tNULL_TREE, NULL_TREE);\n@@ -350,7 +373,7 @@ void\n finish_for_init_stmt (for_stmt)\n      tree for_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       if (last_tree != for_stmt)\n \tRECHAIN_STMTS_FROM_CHAIN (for_stmt, FOR_INIT_STMT (for_stmt));\n@@ -373,7 +396,7 @@ finish_for_cond (cond, for_stmt)\n      tree cond;\n      tree for_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       if (last_tree != for_stmt)\n \tRECHAIN_STMTS_FROM_LAST (for_stmt, FOR_COND (for_stmt));\n@@ -405,8 +428,8 @@ finish_for_expr (expr, for_stmt)\n      tree expr;\n      tree for_stmt;\n {\n-  if (processing_template_decl)\n-    FOR_EXPR (for_stmt) = expr;\n+  if (building_stmt_tree ())\n+    FOR_EXPR (for_stmt) = copy_to_permanent (expr);\n \n   /* Don't let the tree nodes for EXPR be discarded\n      by clear_momentary during the parsing of the next stmt.  */\n@@ -425,7 +448,7 @@ finish_for_stmt (expr, for_stmt)\n   /* Pop the scope for the body of the loop.  */\n   do_poplevel ();\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (for_stmt, FOR_BODY (for_stmt));\n   else\n     {\n@@ -450,7 +473,7 @@ void\n finish_break_stmt ()\n {\n   emit_line_note (input_filename, lineno);\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     add_tree (build_min_nt (BREAK_STMT));\n   else if ( ! expand_exit_something ())\n     cp_error (\"break statement not within loop or switch\");\n@@ -462,7 +485,7 @@ void\n finish_continue_stmt ()\n {\n   emit_line_note (input_filename, lineno);\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     add_tree (build_min_nt (CONTINUE_STMT));\n   else if (! expand_continue_loop (0))\n     cp_error (\"continue statement not within a loop\");   \n@@ -485,7 +508,7 @@ finish_switch_cond (cond)\n {\n   tree r;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       r = build_min_nt (SWITCH_STMT, cond, NULL_TREE);\n       add_tree (r);\n@@ -521,7 +544,7 @@ finish_switch_stmt (cond, switch_stmt)\n      tree cond;\n      tree switch_stmt;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (switch_stmt, SWITCH_BODY (switch_stmt));\n   else\n     expand_end_case (cond);\n@@ -538,17 +561,22 @@ finish_case_label (low_value, high_value)\n      tree low_value;\n      tree high_value;\n {\n+  if (building_stmt_tree ())\n+    {\n+      add_tree (build_min_nt (CASE_LABEL, low_value, high_value));\n+      return;\n+    }\n+\n   do_case (low_value, high_value);\n }\n \n-\n /* Finish a goto-statement.  */\n \n void\n finish_goto_stmt (destination)\n      tree destination;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     add_tree (build_min_nt (GOTO_STMT, destination));\n   else\n     {\n@@ -571,7 +599,7 @@ finish_goto_stmt (destination)\n tree\n begin_try_block ()\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       tree r = build_min_nt (TRY_BLOCK, NULL_TREE,\n \t\t\t     NULL_TREE);\n@@ -591,7 +619,7 @@ begin_try_block ()\n tree\n begin_function_try_block ()\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       tree r = build_min_nt (TRY_BLOCK, NULL_TREE,\n \t\t\t     NULL_TREE);\n@@ -613,12 +641,10 @@ void\n finish_try_block (try_block)\n      tree try_block;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_LAST (try_block, TRY_STMTS (try_block));\n   else\n-    {\n-      expand_start_all_catch ();  \n-    }\n+    expand_start_all_catch ();  \n }\n \n /* Likewise, for a function-try-block.  */\n@@ -627,7 +653,7 @@ void\n finish_function_try_block (try_block)\n      tree try_block;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_LAST (try_block, TRY_STMTS (try_block));\n   else\n     {\n@@ -644,7 +670,7 @@ void\n finish_handler_sequence (try_block)\n      tree try_block;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (try_block, TRY_HANDLERS (try_block));\n   else\n     {\n@@ -658,7 +684,7 @@ void\n finish_function_handler_sequence (try_block)\n      tree try_block;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (try_block, TRY_HANDLERS (try_block));\n   else\n     {\n@@ -674,7 +700,7 @@ begin_handler ()\n {\n   tree r;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       r = build_min_nt (HANDLER, NULL_TREE, NULL_TREE);\n       add_tree (r);\n@@ -694,7 +720,7 @@ void\n finish_handler_parms (handler)\n      tree handler;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (handler, HANDLER_PARMS (handler));\n }\n \n@@ -704,7 +730,7 @@ void\n finish_handler (handler)\n      tree handler;\n {\n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (handler, HANDLER_BODY (handler));\n   else\n     expand_end_catch_block ();\n@@ -722,7 +748,7 @@ begin_compound_stmt (has_no_scope)\n {\n   tree r; \n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       r = build_min_nt (COMPOUND_STMT, NULL_TREE);\n       add_tree (r);\n@@ -732,6 +758,8 @@ begin_compound_stmt (has_no_scope)\n   else\n     r = NULL_TREE;\n \n+  last_expr_type = NULL_TREE;\n+\n   if (!has_no_scope)\n     do_pushlevel ();\n \n@@ -749,17 +777,24 @@ finish_compound_stmt (has_no_scope, compound_stmt)\n      tree compound_stmt;\n {\n   tree r;\n+  tree t;\n \n   if (!has_no_scope)\n     r = do_poplevel ();\n   else\n     r = NULL_TREE;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (compound_stmt, \n \t\t\t      COMPOUND_BODY (compound_stmt));\n \n+  /* When we call finish_stmt we will lost LAST_EXPR_TYPE.  But, since\n+     the precise purpose of that variable is store the type of the\n+     last expression statement within the last compound statement, we\n+     preserve the value.  */\n+  t = last_expr_type;\n   finish_stmt ();\n+  last_expr_type = t;\n \n   return r;\n }\n@@ -779,14 +814,14 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n {\n   if (TREE_CHAIN (string))\n     {\n-      if (processing_template_decl)\n+      if (building_stmt_tree ())\n \t/* We need to build the combined string on the permanent\n \t   obstack so that we can use it during instantiations.  */\n \tpush_permanent_obstack ();\n \n       string = combine_strings (string);\n \n-      if (processing_template_decl)\n+      if (building_stmt_tree ())\n \tpop_obstacks ();\n     }\n \n@@ -798,7 +833,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n       cv_qualifier = NULL_TREE;\n     }\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       tree r = build_min_nt (ASM_STMT, cv_qualifier, string,\n \t\t\t     output_operands, input_operands,\n@@ -837,7 +872,7 @@ finish_label_stmt (name)\n {\n   tree decl;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       push_permanent_obstack ();\n       decl = build_decl (LABEL_DECL, name, void_type_node);\n@@ -869,6 +904,111 @@ add_decl_stmt (decl)\n   add_tree (decl_stmt);\n }\n \n+/* Bind a name and initialization to the return value of\n+   the current function.  */\n+\n+void\n+finish_named_return_value (return_id, init)\n+     tree return_id, init;\n+{\n+  tree decl = DECL_RESULT (current_function_decl);\n+\n+  if (pedantic)\n+    /* Give this error as many times as there are occurrences,\n+       so that users can use Emacs compilation buffers to find\n+       and fix all such places.  */\n+    pedwarn (\"ANSI C++ does not permit named return values\");\n+\n+  if (return_id != NULL_TREE)\n+    {\n+      if (DECL_NAME (decl) == NULL_TREE)\n+\t{\n+\t  DECL_NAME (decl) = return_id;\n+\t  DECL_ASSEMBLER_NAME (decl) = return_id;\n+\t}\n+      else\n+\t{\n+\t  cp_error (\"return identifier `%D' already in place\", return_id);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Can't let this happen for constructors.  */\n+  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+    {\n+      error (\"can't redefine default return value for constructors\");\n+      return;\n+    }\n+\n+  /* If we have a named return value, put that in our scope as well.  */\n+  if (DECL_NAME (decl) != NULL_TREE)\n+    {\n+      /* Let `cp_finish_decl' know that this initializer is ok.  */\n+      DECL_INITIAL (decl) = init;\n+      pushdecl (decl);\n+\n+      if (building_stmt_tree ())\n+\tadd_tree (build_min_nt (RETURN_INIT, return_id,\n+\t\t\t\tcopy_to_permanent (init)));\n+      else\n+\t{\n+\t  cp_finish_decl (decl, init, NULL_TREE, 0, 0);\n+\t  store_return_init (decl);\n+\t}\n+    }\n+}\n+\n+/* Cache the value of this class's main virtual function table pointer\n+   in a register variable.  This will save one indirection if a\n+   more than one virtual function call is made this function.  */\n+\n+void\n+setup_vtbl_ptr ()\n+{\n+  extern tree base_init_expr;\n+\n+  if (base_init_expr == 0\n+      && DECL_CONSTRUCTOR_P (current_function_decl))\n+    {\n+      if (building_stmt_tree ())\n+\tadd_tree (build_min_nt\n+\t\t  (CTOR_INITIALIZER,\n+\t\t   current_member_init_list, current_base_init_list));\n+      else\n+\temit_base_init (current_class_type, 0);\n+    }\n+}\n+\n+/* Begin a new scope.  */\n+\n+void\n+do_pushlevel ()\n+{\n+  if (!building_stmt_tree ())\n+    {\n+      emit_line_note (input_filename, lineno);\n+      clear_last_expr ();\n+    }\n+  pushlevel (0);\n+  push_momentary ();\n+  if (!building_stmt_tree ())\n+    expand_start_bindings (0);\n+}  \n+\n+/* Finish a scope.  */\n+\n+tree\n+do_poplevel ()\n+{\n+  tree t;\n+\n+  if (!building_stmt_tree ())\n+    expand_end_bindings (getdecls (), kept_level_p (), 0);\n+  t = poplevel (kept_level_p (), 1, 0);\n+  pop_momentary ();\n+  return t;\n+}\n+\n /* Finish a parenthesized expression EXPR.  */\n \n tree\n@@ -889,11 +1029,11 @@ tree\n begin_stmt_expr ()\n {\n   keep_next_level ();\n-  /* If we're processing_template_decl, then the upcoming compound\n+  /* If we're building a statement tree, then the upcoming compound\n      statement will be chained onto the tree structure, starting at\n      last_tree.  We return last_tree so that we can later unhook the\n      compound statement.  */\n-  return processing_template_decl ? last_tree : expand_start_stmt_expr(); \n+  return building_stmt_tree () ? last_tree : expand_start_stmt_expr(); \n }\n \n /* Finish a statement-expression.  RTL_EXPR should be the value\n@@ -908,7 +1048,7 @@ finish_stmt_expr (rtl_expr, expr)\n {\n   tree result;\n \n-  if (!processing_template_decl)\n+  if (!building_stmt_tree ())\n     {\n       rtl_expr = expand_end_stmt_expr (rtl_expr);\n       /* The statements have side effects, so the group does.  */\n@@ -917,26 +1057,29 @@ finish_stmt_expr (rtl_expr, expr)\n \n   if (TREE_CODE (expr) == BLOCK)\n     {\n-      /* Make a BIND_EXPR for the BLOCK already made.  */\n-      if (processing_template_decl)\n-\tresult = build_min_nt (BIND_EXPR, NULL_TREE, last_tree,\n-\t\t\t       NULL_TREE);\n+      /* Make a CP_BIND_EXPR for the BLOCK already made.  */\n+      if (building_stmt_tree ())\n+\t{\n+\t  result = build_min (STMT_EXPR, last_expr_type, last_tree);\n+\t  /* FIXME: Do we need this?  */\n+\t  TREE_SIDE_EFFECTS (result) = 1;\n+\t}\n       else\n \tresult = build (BIND_EXPR, TREE_TYPE (rtl_expr),\n \t\t\tNULL_TREE, rtl_expr, expr);\n       \n-      /* Remove the block from the tree at this point.\n-\t It gets put back at the proper place\n-\t when the BIND_EXPR is expanded.  */\n+      /* Remove the block from the tree at this point.  It gets put\n+\t back at the proper place when the STMT_EXPR or BIND_EXPR is\n+\t expanded.  */\n       delete_block (expr);\n     }\n   else\n     result = expr;\n \n-  if (processing_template_decl)\n+  if (building_stmt_tree ())\n     {\n       /* Remove the compound statement from the tree structure; it is\n-\t now saved in the BIND_EXPR.  */\n+\t now saved in the STMT_EXPR.  */\n       last_tree = rtl_expr;\n       TREE_CHAIN (last_tree) = NULL_TREE;\n     }\n@@ -1746,3 +1889,300 @@ finish_typeof (expr)\n \n   return TREE_TYPE (expr);\n }\n+\n+/* Create an empty statement tree for FN.  */\n+\n+void\n+begin_stmt_tree (fn)\n+     tree fn;\n+{\n+  /* We create a trivial EXPR_STMT so that last_tree is never NULL in\n+     what follows.  We remove the extraneous statement in\n+     finish_stmt_tree.  */\n+  DECL_SAVED_TREE (fn) = build_nt (EXPR_STMT, void_zero_node);\n+  last_tree = DECL_SAVED_TREE (fn);\n+  last_expr_type = NULL_TREE;\n+}\n+\n+/* Finish the statement tree for FN.  */\n+\n+void\n+finish_stmt_tree (fn)\n+     tree fn;\n+{\n+  DECL_SAVED_TREE (fn) = TREE_CHAIN (DECL_SAVED_TREE (fn));\n+}\n+\n+/* Generate RTL for the chain of statements T.  */\n+\n+static void \n+expand_stmts (t)\n+     tree t;\n+{\n+  while (t)\n+    {\n+      expand_stmt (t);\n+      t = TREE_CHAIN (t);\n+    }\n+}\n+\n+/* Generate RTL for the statement T, and its substatements.  */\n+\n+tree\n+expand_stmt (t)\n+     tree t;\n+{\n+  if (t == NULL_TREE || t == error_mark_node)\n+    return NULL_TREE;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case RETURN_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_return_stmt (RETURN_EXPR (t));\n+      break;\n+\n+    case EXPR_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_expr_stmt (EXPR_STMT_EXPR (t));\n+      break;\n+\n+    case DECL_STMT:\n+      {\n+\ttree decl;\n+\tint i = suspend_momentary ();\n+\n+\tlineno = STMT_LINENO (t);\n+\temit_line_note (input_filename, lineno);\n+\tdecl = DECL_STMT_DECL (t);\n+\t/* We need to clear DECL_CONTEXT so that maybe_push_decl\n+\t   will push it into the current scope.  */\n+\tif (DECL_CONTEXT (decl) == current_function_decl)\n+\t  DECL_CONTEXT (decl) = NULL_TREE;\n+\t/* If we marked this variable as dead when we processed it\n+\t   before, we must undo that now.  The variable has been\n+\t   resuscitated.  */\n+\tif (TREE_CODE (decl) == VAR_DECL)\n+\t  DECL_DEAD_FOR_LOCAL (decl) = 0;\n+\tmaybe_push_decl (decl);\n+\tcp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n+\tresume_momentary (i);\n+      }\n+      break;\n+\n+    case FOR_STMT:\n+      {\n+\ttree tmp;\n+\n+\tlineno = STMT_LINENO (t);\n+\tbegin_for_stmt ();\n+\tfor (tmp = FOR_INIT_STMT (t); tmp; tmp = TREE_CHAIN (tmp))\n+\t  expand_stmt (tmp);\n+\tfinish_for_init_stmt (NULL_TREE);\n+\tfinish_for_cond (FOR_COND (t), NULL_TREE);\n+\ttmp = FOR_EXPR (t);\n+\tfinish_for_expr (tmp, NULL_TREE);\n+\texpand_stmt (FOR_BODY (t));\n+\tfinish_for_stmt (tmp, NULL_TREE);\n+      }\n+      break;\n+\n+    case WHILE_STMT:\n+      {\n+\tlineno = STMT_LINENO (t);\n+\tbegin_while_stmt ();\n+\tfinish_while_stmt_cond (WHILE_COND (t), NULL_TREE);\n+\texpand_stmt (WHILE_BODY (t));\n+\tfinish_while_stmt (NULL_TREE);\n+      }\n+      break;\n+\n+    case DO_STMT:\n+      {\n+\tlineno = STMT_LINENO (t);\n+\tbegin_do_stmt ();\n+\texpand_stmt (DO_BODY (t));\n+\tfinish_do_body (NULL_TREE);\n+\tfinish_do_stmt (DO_COND (t), NULL_TREE);\n+      }\n+      break;\n+\n+    case IF_STMT:\n+      lineno = STMT_LINENO (t);\n+      begin_if_stmt ();\n+      finish_if_stmt_cond (IF_COND (t), NULL_TREE);\n+      if (THEN_CLAUSE (t))\n+\t{\n+\t  expand_stmt (THEN_CLAUSE (t));\n+\t  finish_then_clause (NULL_TREE);\n+\t}\n+      if (ELSE_CLAUSE (t))\n+\t{\n+\t  begin_else_clause ();\n+\t  expand_stmt (ELSE_CLAUSE (t));\n+\t  finish_else_clause (NULL_TREE);\n+\t}\n+      finish_if_stmt ();\n+      break;\n+\n+    case COMPOUND_STMT:\n+      lineno = STMT_LINENO (t);\n+      begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+      expand_stmts (COMPOUND_BODY (t));\n+      return finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n+\t\t\t\t   NULL_TREE);\n+\n+    case BREAK_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_break_stmt ();\n+      break;\n+\n+    case CONTINUE_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_continue_stmt ();\n+      break;\n+\n+    case SWITCH_STMT:\n+      lineno = STMT_LINENO (t);\n+      begin_switch_stmt ();\n+      finish_switch_cond (SWITCH_COND (t));\n+      if (TREE_OPERAND (t, 1))\n+\texpand_stmt (SWITCH_BODY (t));\n+      finish_switch_stmt (SWITCH_COND (t), NULL_TREE);\n+      break;\n+\n+    case CASE_LABEL:\n+      finish_case_label (CASE_LOW (t), CASE_HIGH (t));\n+      break;\n+\n+    case LABEL_DECL:\n+      t = define_label (DECL_SOURCE_FILE (t), DECL_SOURCE_LINE (t),\n+\t\t\tDECL_NAME (t));\n+      if (t)\n+\texpand_label (t);\n+      break;\n+\n+    case GOTO_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_goto_stmt (GOTO_DESTINATION (t));\n+      break;\n+\n+    case ASM_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_asm_stmt (ASM_CV_QUAL (t), ASM_STRING (t), ASM_OUTPUTS\n+\t\t       (t), ASM_INPUTS (t), ASM_CLOBBERS (t));\n+      break;\n+\n+    case TRY_BLOCK:\n+      lineno = STMT_LINENO (t);\n+      begin_try_block ();\n+      expand_stmt (TRY_STMTS (t));\n+      finish_try_block (NULL_TREE);\n+      expand_stmts (TRY_HANDLERS (t));\n+      finish_handler_sequence (NULL_TREE);\n+      break;\n+\n+    case HANDLER:\n+      lineno = STMT_LINENO (t);\n+      begin_handler ();\n+      if (HANDLER_PARMS (t))\n+\t{\n+\t  tree d = HANDLER_PARMS (t);\n+\t  expand_start_catch_block (TREE_OPERAND (d, 1),\n+\t\t\t\t    TREE_OPERAND (d, 0));\n+\t}\n+      else\n+\texpand_start_catch_block (NULL_TREE, NULL_TREE);\n+      finish_handler_parms (NULL_TREE);\n+      expand_stmt (HANDLER_BODY (t));\n+      finish_handler (NULL_TREE);\n+      break;\n+\n+    default:\n+      my_friendly_abort (19990810);\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Generate RTL for FN.  */\n+\n+void\n+expand_body (fn)\n+     tree fn;\n+{\n+  int saved_expanding_p;\n+  int nested; \n+  tree t;\n+  tree try_block;\n+\n+  /* Remember whether we're already processing a function definition\n+     so that we can tell finish_function.  */\n+  nested = in_function_p ();\n+\n+  /* Let the compiler know that now is the time to really generate\n+     actualy RTL.  */\n+  saved_expanding_p = expanding_p;\n+  expanding_p = 1;\n+\n+  start_function (NULL_TREE, fn, NULL_TREE, 1);\n+  store_parm_decls ();\n+\n+  /* There are a few things that we do not handle recursively.  For\n+     example, a function try-block is handled differently from an\n+     ordinary try-block, so we must handle it here.  */\n+  t = DECL_SAVED_TREE (fn);\n+  try_block = NULL_TREE;\n+  if (t && TREE_CODE (t) == TRY_BLOCK)\n+    {\n+      try_block = t;\n+      begin_function_try_block ();\n+      t = TRY_STMTS (try_block);\n+    }\n+\n+  if (t && TREE_CODE (t) == RETURN_INIT)\n+    {\n+      /* Clear this out so that finish_named_return_value can set it\n+\t again.  */\n+      DECL_NAME (DECL_RESULT (fn)) = NULL_TREE;\n+      finish_named_return_value (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1));\n+      t = TREE_CHAIN (t);\n+    }\n+\n+  if (t && TREE_CODE (t) == CTOR_INITIALIZER)\n+    {\n+      current_member_init_list = TREE_OPERAND (t, 0);\n+      current_base_init_list = TREE_OPERAND (t, 1);\n+      t = TREE_CHAIN (t);\n+    }\n+\n+  /* If this is a constructor, we need to initialize our members and\n+     base-classes.  */\n+  setup_vtbl_ptr ();\n+\n+  /* Always keep the BLOCK node associated with the outermost pair of\n+     curly braces of a function.  These are needed for correct\n+     operation of dwarfout.c.  */\n+  keep_next_level ();\n+\n+  /* Expand the body.  */\n+  expand_stmt (t);\n+\n+  /* If there was a function try-block, expand the handlers.  */\n+  if (try_block)\n+    {\n+      finish_function_try_block (NULL_TREE);\n+      {\n+\ttree handler = TRY_HANDLERS (try_block);\n+\tfor (; handler; handler = TREE_CHAIN (handler))\n+\t  expand_stmt (handler);\n+      }\n+      finish_function_handler_sequence (NULL_TREE);\n+    }\n+\n+  finish_function (lineno, 0, nested);\n+\n+  /* Restore EXPANDING_P.  */\n+  expanding_p = saved_expanding_p;\n+}"}, {"sha": "b9732b3a738a2dc58a260aad8a0efe6459fde0af", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -412,15 +412,20 @@ build_cplus_method_type (basetype, rettype, argtypes)\n   ptype = build_pointer_type (basetype);\n \n   /* The actual arglist for this function includes a \"hidden\" argument\n-     which is \"this\".  Put it into the list of argument types.  */\n-\n+     which is \"this\".  Put it into the list of argument types.  Make\n+     sure that the new argument list is allocated on the same obstack\n+     as the type.  */\n+  push_obstacks (TYPE_OBSTACK (t), TYPE_OBSTACK (t));\n   argtypes = tree_cons (NULL_TREE, ptype, argtypes);\n   TYPE_ARG_TYPES (t) = argtypes;\n   TREE_SIDE_EFFECTS (argtypes) = 1;  /* Mark first argtype as \"artificial\".  */\n+  pop_obstacks ();\n \n   /* If we already have such a type, use the old one and free this one.\n      Note that it also frees up the above cons cell if found.  */\n-  hashcode = TYPE_HASH (basetype) + TYPE_HASH (rettype) + type_hash_list (argtypes);\n+  hashcode = TYPE_HASH (basetype) + TYPE_HASH (rettype) +\n+    type_hash_list (argtypes);\n+\n   t = type_hash_canon (hashcode, t);\n \n   if (TYPE_SIZE (t) == 0)\n@@ -1646,6 +1651,8 @@ search_tree (t, func)\n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n     case CALL_EXPR:\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       TRY (TREE_OPERAND (t, 1));\n       break;\n@@ -1657,6 +1664,7 @@ search_tree (t, func)\n     case COMPONENT_REF:\n     case CLEANUP_POINT_EXPR:\n     case LOOKUP_EXPR:\n+    case THROW_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       break;\n \n@@ -1681,6 +1689,7 @@ search_tree (t, func)\n       break;\n \n     case BIND_EXPR:\n+    case STMT_EXPR:\n       break;\n \n     case REAL_TYPE:\n@@ -1774,6 +1783,7 @@ mapcar (t, func)\n      tree (*func) PROTO((tree));\n {\n   tree tmp;\n+  enum tree_code code; \n \n   if (t == NULL_TREE)\n     return t;\n@@ -1785,6 +1795,24 @@ mapcar (t, func)\n \treturn tmp;\n     }\n \n+  /* Handle some common cases up front.  */\n+  code = TREE_CODE (t);\n+  if (TREE_CODE_CLASS (code) == '1')\n+    {\n+      t = copy_node (t);\n+      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n+      return t;\n+    }\n+  else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n+    {\n+      t = copy_node (t);\n+      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n+      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n+      TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n+      return t;\n+    }\n+\n   switch (TREE_CODE (t))\n     {\n     case ERROR_MARK:\n@@ -1871,40 +1899,8 @@ mapcar (t, func)\n       TREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n       return t;\n \n-    case SAVE_EXPR:\n-      t = copy_node (t);\n-      TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n-      return t;\n-\n-    case MODIFY_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case MIN_EXPR:\n-    case MAX_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case BIT_AND_EXPR:\n-    case BIT_ANDTC_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-    case COMPOUND_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n@@ -1913,6 +1909,8 @@ mapcar (t, func)\n     case SCOPE_REF:\n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n@@ -1933,16 +1931,14 @@ mapcar (t, func)\n \tTREE_OPERAND (t, 2) = NULL_TREE;\n       return t;\n \n-    case CONVERT_EXPR:\n+    case SAVE_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n-    case NOP_EXPR:\n     case COMPONENT_REF:\n     case CLEANUP_POINT_EXPR:\n-    case NON_LVALUE_EXPR:\n+    case THROW_EXPR:\n+    case STMT_EXPR:\n       t = copy_node (t);\n       TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n@@ -2009,19 +2005,19 @@ mapcar (t, func)\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       return t;\n \n+    case RTL_EXPR:\n+      t = copy_node (t);\n+      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n+      return t;\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn build_ptrmemfunc_type\n \t  (mapcar (TYPE_PTRMEMFUNC_FN_TYPE (t), func));\n       /* else fall through */\n-      \n-      /*  This list is incomplete, but should suffice for now.\n-\t  It is very important that `sorry' not call\n-\t  `report_error_function'.  That could cause an infinite loop.  */\n-    default:\n-      sorry (\"initializer contains unrecognized tree code\");\n-      return error_mark_node;\n \n+    default:\n+      my_friendly_abort (19990815);\n     }\n   my_friendly_abort (107);\n   /* NOTREACHED */"}, {"sha": "5d12bee3ada6601a7ae5fc1ad245489f57cc2162", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558475f07cfe622a964b7c0019be78bd81912a47/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=558475f07cfe622a964b7c0019be78bd81912a47", "patch": "@@ -197,6 +197,7 @@ require_complete_type_in_void (expr)\n     case EXIT_EXPR:   /* have no return */\n     case LOOP_EXPR:   /* have no return */\n     case BIND_EXPR:   /* have no return */\n+    case STMT_EXPR: /* have no return */\n     case THROW_EXPR:  /* have no return */\n     case MODIFY_EXPR: /* sometimes this has a void type, but that's ok */\n     case CONVERT_EXPR:  /* sometimes has a void type */\n@@ -6801,12 +6802,6 @@ c_expand_return (retval)\n       return;\n     }\n \n-  if (processing_template_decl)\n-    {\n-      add_tree (build_min_nt (RETURN_STMT, retval));\n-      return;\n-    }\n-\n   if (dtor_label)\n     {\n       if (retval)"}]}