{"sha": "81b3411cdf96d7160aad803388a8e522501646f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFiMzQxMWNkZjk2ZDcxNjBhYWQ4MDMzODhhOGU1MjI1MDE2NDZmNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-09-10T10:36:02Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-09-10T10:36:02Z"}, "message": "Move declarations and building code for common tree nodes to tree.[ch]\n\nFrom-SVN: r29266", "tree": {"sha": "e509e10c1be6e5513d27d5310b0f2d791b23761d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e509e10c1be6e5513d27d5310b0f2d791b23761d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81b3411cdf96d7160aad803388a8e522501646f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b3411cdf96d7160aad803388a8e522501646f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81b3411cdf96d7160aad803388a8e522501646f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b3411cdf96d7160aad803388a8e522501646f6/comments", "author": null, "committer": null, "parents": [{"sha": "ed5511d94eaa6e0ac388aad1999bf11d647d3906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5511d94eaa6e0ac388aad1999bf11d647d3906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed5511d94eaa6e0ac388aad1999bf11d647d3906"}], "stats": {"total": 1259, "additions": 430, "deletions": 829}, "files": [{"sha": "994ce27b677bbe0eb437122a24636d66a142225d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -1,3 +1,33 @@\n+Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* c-common.c (c_common_nodes_and_builtins): Don't build\n+\tva_list_type_node.\n+\t* c-common.h (enum c_tree_index and related accesor macros): Remove\n+\teverything now declared in tree.h.\n+\t* c-decl.c (CHAR_TYPE_SIZE, SHORT_TYPE_SIZE, INT_TYPE_SIZE,\n+\tLONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE, WCHAR_UNSIGNED, FLOAT_TYPE_SIZE,\n+\tDOUBLE_TYPE_SIZE, LONG_DOUBLE_TYPE_SIZE): Don't provide defaults.\n+\t(error_mark_node, void_type_node, char_type_node, integer_type_node,\n+\tunsigned_type_node, ptr_type_node, va_list_type_node,\n+\tinteger_zero_node, null_pointer_node, integer_one_node): Delete.\n+\t(init_decl_processing): Call build_common_tree_nodes and\n+\tbuild_common_tree_nodes_2 instead of building their nodes here.\n+\tDon't add roots for these nodes.\n+\t* stor-layout.c (size_zero_node, size_one_node): Delete.\n+\t(set_sizetype): Make a new node for bitsizetype each time.\n+\t* tree.c (global_trees): New variable.\n+\t(init_obstacks): Add a gc root for it.\n+\t(CHAR_TYPE_SIZE, SHORT_TYPE_SIZE, INT_TYPE_SIZE,\n+\tLONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE, FLOAT_TYPE_SIZE,\n+\tDOUBLE_TYPE_SIZE, LONG_DOUBLE_TYPE_SIZE): Provide defaults.\n+\t(build_common_tree_nodes): New function.\n+\t(fix_sizetype): New function.\n+\t(build_common_tree_nodes_2): New function.\n+\t* tree.h (enum tree_index): New.\n+\t(global_trees): Declare.\n+\tAdd accessor macros for all nodes now moved to global_trees.\n+\tDelete their declarations.\n+\n Thu Sep  9 20:15:46 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* c-decl.c (finish_function): When processing a nested function,"}, {"sha": "cd2baab58ced8a3d08e49bdf56a6cde4d6398798", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -3482,11 +3482,6 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n   tree va_list_ptr_type_node;\n   tree va_list_arg_type_node;\n \n-#ifdef BUILD_VA_LIST_TYPE\n-  BUILD_VA_LIST_TYPE(va_list_type_node);\n-#else\n-  va_list_type_node = ptr_type_node;\n-#endif\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n \t\t\tva_list_type_node));\n "}, {"sha": "d41677008b0cb532bd77e6132ad4751f204bf8ad", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -22,50 +22,18 @@ Boston, MA 02111-1307, USA.  */\n \n enum c_tree_index\n {\n-    CTI_INTQI_TYPE,\n-    CTI_INTHI_TYPE,\n-    CTI_INTSI_TYPE,\n-    CTI_INTDI_TYPE,\n-    CTI_INTTI_TYPE,\n-\n-    CTI_UINTQI_TYPE,\n-    CTI_UINTHI_TYPE,\n-    CTI_UINTSI_TYPE,\n-    CTI_UINTDI_TYPE,\n-    CTI_UINTTI_TYPE,\n-    \n-    CTI_SIGNED_CHAR_TYPE,\n-    CTI_UNSIGNED_CHAR_TYPE,\n     CTI_WCHAR_TYPE,\n     CTI_SIGNED_WCHAR_TYPE,\n     CTI_UNSIGNED_WCHAR_TYPE,\n-    CTI_SHORT_INTEGER_TYPE,\n-    CTI_SHORT_UNSIGNED_TYPE,\n-    CTI_LONG_INTEGER_TYPE,\n-    CTI_LONG_UNSIGNED_TYPE,\n-    CTI_LONG_LONG_INTEGER_TYPE,\n-    CTI_LONG_LONG_UNSIGNED_TYPE,\n     CTI_WIDEST_INT_LIT_TYPE,\n     CTI_WIDEST_UINT_LIT_TYPE,\n \n-    CTI_COMPLEX_INTEGER_TYPE,\n-    CTI_COMPLEX_FLOAT_TYPE,\n-    CTI_COMPLEX_DOUBLE_TYPE,\n-    CTI_COMPLEX_LONG_DOUBLE_TYPE,\n-\n-    CTI_FLOAT_TYPE,\n-    CTI_DOUBLE_TYPE,\n-    CTI_LONG_DOUBLE_TYPE,\n-\n     CTI_CHAR_ARRAY_TYPE,\n     CTI_WCHAR_ARRAY_TYPE,\n     CTI_INT_ARRAY_TYPE,\n     CTI_STRING_TYPE,\n     CTI_CONST_STRING_TYPE,\n \n-    CTI_CONST_PTR_TYPE,\n-    CTI_PTRDIFF_TYPE,\n-\n     CTI_BOOLEAN_TYPE,\n     CTI_BOOLEAN_TRUE,\n     CTI_BOOLEAN_FALSE,\n@@ -82,52 +50,16 @@ enum c_tree_index\n \n extern tree c_global_trees[CTI_MAX];\n \n-#define intQI_type_node\t\t\tc_global_trees[CTI_INTQI_TYPE]\n-#define intHI_type_node\t\t\tc_global_trees[CTI_INTHI_TYPE]\n-#define intSI_type_node\t\t\tc_global_trees[CTI_INTSI_TYPE]\n-#define intDI_type_node\t\t\tc_global_trees[CTI_INTDI_TYPE]\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-#define intTI_type_node\t\t\tc_global_trees[CTI_INTTI_TYPE]\n-#endif\n-\n-#define unsigned_intQI_type_node\tc_global_trees[CTI_UINTQI_TYPE]\n-#define unsigned_intHI_type_node\tc_global_trees[CTI_UINTHI_TYPE]\n-#define unsigned_intSI_type_node\tc_global_trees[CTI_UINTSI_TYPE]\n-#define unsigned_intDI_type_node\tc_global_trees[CTI_UINTDI_TYPE]\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-#define unsigned_intTI_type_node\tc_global_trees[CTI_UINTTI_TYPE]\n-#endif\n-\n-#define signed_char_type_node\t\tc_global_trees[CTI_SIGNED_CHAR_TYPE]\n-#define unsigned_char_type_node\t\tc_global_trees[CTI_UNSIGNED_CHAR_TYPE]\n #define wchar_type_node\t\t\tc_global_trees[CTI_WCHAR_TYPE]\n #define signed_wchar_type_node\t\tc_global_trees[CTI_SIGNED_WCHAR_TYPE]\n #define unsigned_wchar_type_node\tc_global_trees[CTI_UNSIGNED_WCHAR_TYPE]\n-#define short_integer_type_node\t\tc_global_trees[CTI_SHORT_INTEGER_TYPE]\n-#define short_unsigned_type_node\tc_global_trees[CTI_SHORT_UNSIGNED_TYPE]\n-#define long_integer_type_node\t\tc_global_trees[CTI_LONG_INTEGER_TYPE]\n-#define long_unsigned_type_node\t\tc_global_trees[CTI_LONG_UNSIGNED_TYPE]\n-#define long_long_integer_type_node\tc_global_trees[CTI_LONG_LONG_INTEGER_TYPE]\n-#define long_long_unsigned_type_node\tc_global_trees[CTI_LONG_LONG_UNSIGNED_TYPE]\n #define widest_integer_literal_type_node c_global_trees[CTI_WIDEST_INT_LIT_TYPE]\n #define widest_unsigned_literal_type_node c_global_trees[CTI_WIDEST_UINT_LIT_TYPE]\n \n-#define float_type_node\t\t\tc_global_trees[CTI_FLOAT_TYPE]\n-#define double_type_node\t\tc_global_trees[CTI_DOUBLE_TYPE]\n-#define long_double_type_node\t\tc_global_trees[CTI_LONG_DOUBLE_TYPE]\n-\n-#define complex_integer_type_node\tc_global_trees[CTI_COMPLEX_INTEGER_TYPE]\n-#define complex_float_type_node\t\tc_global_trees[CTI_COMPLEX_FLOAT_TYPE]\n-#define complex_double_type_node\tc_global_trees[CTI_COMPLEX_DOUBLE_TYPE]\n-#define complex_long_double_type_node\tc_global_trees[CTI_COMPLEX_LONG_DOUBLE_TYPE]\n-\n #define boolean_type_node\t\tc_global_trees[CTI_BOOLEAN_TYPE]\n #define boolean_true_node\t\tc_global_trees[CTI_BOOLEAN_TRUE]\n #define boolean_false_node\t\tc_global_trees[CTI_BOOLEAN_FALSE]\n \n-#define const_ptr_type_node\t\tc_global_trees[CTI_CONST_PTR_TYPE]\n-#define ptrdiff_type_node\t\tc_global_trees[CTI_PTRDIFF_TYPE]\n-\n #define char_array_type_node\t\tc_global_trees[CTI_CHAR_ARRAY_TYPE]\n #define wchar_array_type_node\t\tc_global_trees[CTI_WCHAR_ARRAY_TYPE]\n #define int_array_type_node\t\tc_global_trees[CTI_INT_ARRAY_TYPE]"}, {"sha": "f018d85b68146ffa1a14f65eec4bf22134f7bd25", "filename": "gcc/c-decl.c", "status": "modified", "additions": 25, "deletions": 210, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -52,42 +52,6 @@ enum decl_context\n   BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME};\t\t\t/* Typename (inside cast or sizeof)  */\n \n-#ifndef CHAR_TYPE_SIZE\n-#define CHAR_TYPE_SIZE BITS_PER_UNIT\n-#endif\n-\n-#ifndef SHORT_TYPE_SIZE\n-#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n-#endif\n-\n-#ifndef INT_TYPE_SIZE\n-#define INT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef LONG_TYPE_SIZE\n-#define LONG_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef LONG_LONG_TYPE_SIZE\n-#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n-#ifndef WCHAR_UNSIGNED\n-#define WCHAR_UNSIGNED 0\n-#endif\n-\n-#ifndef FLOAT_TYPE_SIZE\n-#define FLOAT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef DOUBLE_TYPE_SIZE\n-#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n-#ifndef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n /* We let tm.h override the types used here, to handle trivial differences\n    such as the choice of unsigned int or long unsigned int for size_t.\n    When machines start needing nontrivial differences in the size type,\n@@ -109,38 +73,6 @@ enum decl_context\n /* Don't do GC.  */\n int ggc_p = 0;\n \n-/* a node which has tree code ERROR_MARK, and whose type is itself.\n-   All erroneous expressions are replaced with this node.  All functions\n-   that accept nodes as arguments should avoid generating error messages\n-   if this node is one of the arguments, since it is undesirable to get\n-   multiple error messages from one error in the input.  */\n-\n-tree error_mark_node;\n-\n-/* These can't be part of the above array, since they are declared\n-   individually in tree.h, and used by the debug output routines.  */\n-\n-tree void_type_node;\n-tree char_type_node;\n-tree integer_type_node;\n-tree unsigned_type_node;\n-\n-/* These can't be part of the above array, since they are declared\n-   individially in tree.h and used by the target routines.  */\n-\n-tree ptr_type_node;\n-tree va_list_type_node;\n-\n-/* Two expressions that are constants with value zero.\n-   The first is of type `int', the second of type `void *'.  */\n-\n-tree integer_zero_node;\n-tree null_pointer_node;\n-\n-/* A node for the integer constant 1.  */\n-\n-tree integer_one_node;\n-\n /* Nonzero if we have seen an invalid cross reference\n    to a struct, union, or enum, but not yet printed the message.  */\n \n@@ -2975,195 +2907,92 @@ init_decl_processing ()\n   pushlevel (0);\t/* make the binding_level structure for global names */\n   global_binding_level = current_binding_level;\n \n-  /* Define `int' and `char' first so that dbx will output them first.  */\n+  build_common_tree_nodes (flag_signed_char);\n \n-  integer_type_node = make_signed_type (INT_TYPE_SIZE);\n+  /* Define `int' and `char' first so that dbx will output them first.  */\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_INT],\n \t\t\tinteger_type_node));\n-\n-  /* Define `char', which is like either `signed char' or `unsigned char'\n-     but not the same as either.  */\n-\n-  char_type_node\n-    = (flag_signed_char\n-       ? make_signed_type (CHAR_TYPE_SIZE)\n-       : make_unsigned_type (CHAR_TYPE_SIZE));\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"char\"),\n \t\t\tchar_type_node));\n-\n-  long_integer_type_node = make_signed_type (LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long int\"),\n \t\t\tlong_integer_type_node));\n-\n-  unsigned_type_node = make_unsigned_type (INT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned int\"),\n \t\t\tunsigned_type_node));\n-\n-  long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long unsigned int\"),\n \t\t\tlong_unsigned_type_node));\n-\n-  long_long_integer_type_node = make_signed_type (LONG_LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long int\"),\n \t\t\tlong_long_integer_type_node));\n-\n-  long_long_unsigned_type_node = make_unsigned_type (LONG_LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long unsigned int\"),\n \t\t\tlong_long_unsigned_type_node));\n-\n-  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"short int\"),\n \t\t\tshort_integer_type_node));\n-\n-  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"short unsigned int\"),\n \t\t\tshort_unsigned_type_node));\n-\n-  /* `unsigned long' is the standard type for sizeof.\n-     Traditionally, use a signed type.\n-     Note that stddef.h uses `unsigned long',\n-     and this must agree, even if long and int are the same size.  */\n-  set_sizetype\n-    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n-  if (flag_traditional && TREE_UNSIGNED (sizetype))\n-    set_sizetype (signed_type (sizetype));\n-\n-  ptrdiff_type_node\n-    = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n-\n-  error_mark_node = make_node (ERROR_MARK);\n-  TREE_TYPE (error_mark_node) = error_mark_node;\n-\n-  /* Define both `signed char' and `unsigned char'.  */\n-  signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"signed char\"),\n \t\t\tsigned_char_type_node));\n-\n-  unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned char\"),\n \t\t\tunsigned_char_type_node));\n-\n-  /* Create the widest literal types. */\n-  widest_integer_literal_type_node = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n-\t\t\twidest_integer_literal_type_node));\n-\n-  widest_unsigned_literal_type_node = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n-\t\t\twidest_unsigned_literal_type_node));\n-\n-  /* Now all the integer mode types. */\n-  intQI_type_node = make_signed_type (GET_MODE_BITSIZE (QImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intQI_type_node));\n-\n-  intHI_type_node = make_signed_type (GET_MODE_BITSIZE (HImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intHI_type_node));\n-\n-  intSI_type_node = make_signed_type (GET_MODE_BITSIZE (SImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intSI_type_node));\n-\n-  intDI_type_node = make_signed_type (GET_MODE_BITSIZE (DImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intDI_type_node));\n-\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  intTI_type_node = make_signed_type (GET_MODE_BITSIZE (TImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intTI_type_node));\n #endif\n-\n-  unsigned_intQI_type_node = make_unsigned_type (GET_MODE_BITSIZE (QImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intQI_type_node));\n-\n-  unsigned_intHI_type_node = make_unsigned_type (GET_MODE_BITSIZE (HImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intHI_type_node));\n-\n-  unsigned_intSI_type_node = make_unsigned_type (GET_MODE_BITSIZE (SImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intSI_type_node));\n-\n-  unsigned_intDI_type_node = make_unsigned_type (GET_MODE_BITSIZE (DImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intDI_type_node));\n-\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  unsigned_intTI_type_node = make_unsigned_type (GET_MODE_BITSIZE (TImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intTI_type_node));\n #endif\n \n-  float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float_type_node) = FLOAT_TYPE_SIZE;\n+  /* `unsigned long' is the standard type for sizeof.\n+     Traditionally, use a signed type.\n+     Note that stddef.h uses `unsigned long',\n+     and this must agree, even if long and int are the same size.  */\n+  set_sizetype\n+    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n+  if (flag_traditional && TREE_UNSIGNED (sizetype))\n+    set_sizetype (signed_type (sizetype));\n+\n+  /* Create the widest literal types. */\n+  widest_integer_literal_type_node = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n+  widest_unsigned_literal_type_node = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n+\t\t\twidest_integer_literal_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n+\t\t\twidest_unsigned_literal_type_node));\n+\n+  build_common_tree_nodes_2 (flag_short_double);\n+\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_FLOAT],\n \t\t\tfloat_type_node));\n-  layout_type (float_type_node);\n-\n-  double_type_node = make_node (REAL_TYPE);\n-  if (flag_short_double)\n-    TYPE_PRECISION (double_type_node) = FLOAT_TYPE_SIZE;\n-  else\n-    TYPE_PRECISION (double_type_node) = DOUBLE_TYPE_SIZE;\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_DOUBLE],\n \t\t\tdouble_type_node));\n-  layout_type (double_type_node);\n-\n-  long_double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (long_double_type_node) = LONG_DOUBLE_TYPE_SIZE;\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long double\"),\n \t\t\tlong_double_type_node));\n-  layout_type (long_double_type_node);\n-\n-  complex_integer_type_node = make_node (COMPLEX_TYPE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n \t\t\tcomplex_integer_type_node));\n-  TREE_TYPE (complex_integer_type_node) = integer_type_node;\n-  layout_type (complex_integer_type_node);\n-\n-  complex_float_type_node = make_node (COMPLEX_TYPE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n \t\t\tcomplex_float_type_node));\n-  TREE_TYPE (complex_float_type_node) = float_type_node;\n-  layout_type (complex_float_type_node);\n-\n-  complex_double_type_node = make_node (COMPLEX_TYPE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n \t\t\tcomplex_double_type_node));\n-  TREE_TYPE (complex_double_type_node) = double_type_node;\n-  layout_type (complex_double_type_node);\n-\n-  complex_long_double_type_node = make_node (COMPLEX_TYPE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t\tcomplex_long_double_type_node));\n-  TREE_TYPE (complex_long_double_type_node) = long_double_type_node;\n-  layout_type (complex_long_double_type_node);\n+  pushdecl (build_decl (TYPE_DECL,\n+\t\t\tridpointers[(int) RID_VOID], void_type_node));\n \n   wchar_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (WCHAR_TYPE)));\n   wchar_type_size = TYPE_PRECISION (wchar_type_node);\n   signed_wchar_type_node = signed_type (wchar_type_node);\n   unsigned_wchar_type_node = unsigned_type (wchar_type_node);\n \n-  integer_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (integer_zero_node) = integer_type_node;\n-  integer_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (integer_one_node) = integer_type_node;\n-\n   boolean_type_node = integer_type_node;\n   boolean_true_node = integer_one_node;\n   boolean_false_node = integer_zero_node;\n \n-  size_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (size_zero_node) = sizetype;\n-  size_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (size_one_node) = sizetype;\n-\n-  void_type_node = make_node (VOID_TYPE);\n-  pushdecl (build_decl (TYPE_DECL,\n-\t\t\tridpointers[(int) RID_VOID], void_type_node));\n-  layout_type (void_type_node);\t/* Uses integer_zero_node */\n-  /* We are not going to have real types in C with less than byte alignment,\n-     so we might as well not have any types that claim to have it.  */\n-  TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;\n-\n-  null_pointer_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n-  layout_type (TREE_TYPE (null_pointer_node));\n-\n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node\n     = build_pointer_type (build_type_variant (char_type_node, 1, 0));\n@@ -3191,10 +3020,8 @@ init_decl_processing ()\n \n   default_function_type\n     = build_function_type (integer_type_node, NULL_TREE);\n-\n-  ptr_type_node = build_pointer_type (void_type_node);\n-  const_ptr_type_node\n-    = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n+  ptrdiff_type_node\n+    = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n \n   c_common_nodes_and_builtins (0, flag_no_builtin, flag_no_nonansi_builtin);\n \n@@ -3254,19 +3081,7 @@ init_decl_processing ()\n \n   ggc_add_tree_root (c_global_trees, CTI_MAX);\n   ggc_add_tree_root (&current_function_decl, 1);\n-  ggc_add_tree_root (&error_mark_node, 1);\n-  ggc_add_tree_root (&ptr_type_node, 1);\n-  ggc_add_tree_root (&va_list_type_node, 1);\n-  ggc_add_tree_root (&void_type_node, 1);\n-  ggc_add_tree_root (&char_type_node, 1);\n-  ggc_add_tree_root (&integer_type_node, 1);\n-  ggc_add_tree_root (&unsigned_type_node, 1);\n-  ggc_add_tree_root (&integer_one_node, 1);\n-  ggc_add_tree_root (&integer_zero_node, 1);\n   ggc_add_tree_root (&named_labels, 1);\n-  ggc_add_tree_root (&null_pointer_node, 1);\n-  ggc_add_tree_root (&size_one_node, 1);\n-  ggc_add_tree_root (&size_zero_node, 1);\n   ggc_add_tree_root (&shadowed_labels, 1);\n   ggc_add_root (&current_binding_level, 1, sizeof current_binding_level,\n \t\tmark_binding_level);"}, {"sha": "2790e5e78a1f32c5b5457dd32cc97598bdd8ca61", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -1,3 +1,14 @@\n+Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* ch-tree.h: Delete declarations for all tree nodes now moved to\n+\tglobal_trees.\n+\t* expr.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* decl.c: Delete their definitions.\n+\t(init_decl_processing): Call build_common_tree_nodes and\n+\tbuild_common_tree_nodes_2 instead of building their nodes here.\n+\tUse set_sizetype instead of assigning sizetype.\n+\n Tue Sep  7 15:59:56 1999  Dave Brolley  <brolley@cygnus.com>\n \n \t* parse.h: Undefine DELAY if it's defined."}, {"sha": "7cc378747109eff843b3020b9970e03eb7b2bbfe", "filename": "gcc/ch/ch-tree.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Fch-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Fch-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.h?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -474,9 +474,6 @@ extern tree signed_boolean_type_node;\n extern tree string_one_type_node;\n extern tree bitstring_one_type_node, bit_zero_node, bit_one_node;\n \n-extern tree float_type_node, double_type_node;\n-extern tree void_type_node, ptr_type_node, const_ptr_type_node;\n-\n /* a VOID_TYPE node, packaged in a TREE_LIST.  */\n \n extern tree void_list_node;\n@@ -636,15 +633,7 @@ extern char *get_directive_line                 PROTO((FILE *));\n extern tree shorten_compare                     PROTO((tree *, tree *, tree *, enum tree_code *));\n \n /* in c-decl.c */\n-extern tree short_integer_type_node, integer_type_node;\n-extern tree long_integer_type_node, long_long_integer_type_node;\n-extern tree short_unsigned_type_node, unsigned_type_node;\n-extern tree long_unsigned_type_node, long_long_unsigned_type_node;\n-extern tree ptrdiff_type_node;\n-extern tree unsigned_char_type_node, signed_char_type_node, char_type_node;\n extern tree wchar_type_node, signed_wchar_type_node, unsigned_wchar_type_node;\n-extern tree float_type_node, double_type_node, long_double_type_node;\n-extern tree void_type_node, ptr_type_node, const_ptr_type_node;\n extern tree default_function_type;\n extern tree double_ftype_double, double_ftype_double_double;\n extern tree int_ftype_int, long_ftype_long;"}, {"sha": "ec7086f7525e5cefa38c575d8806e7b15d1c89cf", "filename": "gcc/ch/decl.c", "status": "modified", "additions": 7, "deletions": 173, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fdecl.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -324,71 +324,12 @@ enum decl_context\n #define WCHAR_TYPE \"int\"\n #endif\n \f\n-/* a node which has tree code ERROR_MARK, and whose type is itself.\n-   All erroneous expressions are replaced with this node.  All functions\n-   that accept nodes as arguments should avoid generating error messages\n-   if this node is one of the arguments, since it is undesirable to get\n-   multiple error messages from one error in the input.  */\n-\n-tree error_mark_node;\n-\n-/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */\n-\n-tree short_integer_type_node;\n-tree integer_type_node;\n-tree long_integer_type_node;\n-tree long_long_integer_type_node;\n-\n-tree short_unsigned_type_node;\n-tree unsigned_type_node;\n-tree long_unsigned_type_node;\n-tree long_long_unsigned_type_node;\n-\n-tree ptrdiff_type_node;\n-\n-tree unsigned_char_type_node;\n-tree signed_char_type_node;\n-tree char_type_node;\n tree wchar_type_node;\n tree signed_wchar_type_node;\n tree unsigned_wchar_type_node;\n \n-tree float_type_node;\n-tree double_type_node;\n-tree long_double_type_node;\n-\n-tree complex_integer_type_node;\n-tree complex_float_type_node;\n-tree complex_double_type_node;\n-tree complex_long_double_type_node;\n-\n-tree intQI_type_node;\n-tree intHI_type_node;\n-tree intSI_type_node;\n-tree intDI_type_node;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-tree intTI_type_node;\n-#endif\n-\n-tree unsigned_intQI_type_node;\n-tree unsigned_intHI_type_node;\n-tree unsigned_intSI_type_node;\n-tree unsigned_intDI_type_node;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-tree unsigned_intTI_type_node;\n-#endif\n-\n-/* a VOID_TYPE node.  */\n-\n-tree void_type_node;\n tree void_list_node;\n \n-/* Nodes for types `void *' and `const void *'.  */\n-tree ptr_type_node, const_ptr_type_node;\n-\n-/* __builtin_va_list; not used by chill, but referenced in target files.  */\n-tree va_list_type_node;\n-\n /* type of initializer structure, which points to\n    a module's module-level code, and to the next\n    such structure. */\n@@ -401,34 +342,8 @@ tree chill_predefined_function_type;\n \n tree default_function_type;\n \n-#if 0\n-/* function types `double (double)' and `double (double, double)', etc.  */\n-\n-tree double_ftype_double, double_ftype_double_double;\n-tree int_ftype_int, long_ftype_long;\n-\n-/* Function type `void (void *, void *, int)' and similar ones */\n-\n-tree void_ftype_ptr_ptr_int, int_ftype_ptr_ptr_int, void_ftype_ptr_int_int;\n-\n-/* Function type `char *(char *, char *)' and similar ones */\n-tree string_ftype_ptr_ptr, int_ftype_string_string;\n-\n-/* Function type `int (const void *, const void *, size_t)' */\n-tree int_ftype_cptr_cptr_sizet;\n-#endif\n-\n const char **boolean_code_name;\n \n-/* Two expressions that are constants with value zero.\n-   The first is of type `int', the second of type `void *'.  */\n-\n-tree integer_zero_node;\n-tree null_pointer_node;\n-\n-/* A node for the integer constant 1.  */\n-tree integer_one_node;\n-\n /* A node for the integer constant -1.  */\n tree integer_minus_one_node;\n \n@@ -3501,124 +3416,46 @@ init_decl_processing ()\n   var_length_id = get_identifier (VAR_LENGTH);\n   var_data_id = get_identifier (VAR_DATA);\n \n-  /* This is the *C* int type. */\n-  integer_type_node = make_signed_type (INT_TYPE_SIZE);\n+  build_common_tree_nodes (1);\n \n   if (CHILL_INT_IS_SHORT)\n     long_integer_type_node = integer_type_node;\n   else\n     long_integer_type_node = make_signed_type (LONG_TYPE_SIZE);\n \n-  unsigned_type_node = make_unsigned_type (INT_TYPE_SIZE);\n-  long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n-  long_long_integer_type_node = make_signed_type (LONG_LONG_TYPE_SIZE);\n-  long_long_unsigned_type_node = make_unsigned_type (LONG_LONG_TYPE_SIZE);\n-\n   /* `unsigned long' is the standard type for sizeof.\n      Note that stddef.h uses `unsigned long',\n      and this must agree, even of long and int are the same size.  */\n #ifndef SIZE_TYPE\n-    sizetype = long_unsigned_type_node;\n+  set_sizetype (long_unsigned_type_node);\n #else\n   {\n     const char *size_type_c_name = SIZE_TYPE;\n     if (strncmp (size_type_c_name, \"long long \", 10) == 0)\n-      sizetype = long_long_unsigned_type_node;\n+      set_sizetype (long_long_unsigned_type_node);\n     else if (strncmp (size_type_c_name, \"long \", 5) == 0)\n-      sizetype = long_unsigned_type_node;\n+      set_sizetype (long_unsigned_type_node);\n     else\n-      sizetype = unsigned_type_node;\n+      set_sizetype (unsigned_type_node);\n   }\n #endif\n \n-  TREE_TYPE (TYPE_SIZE (integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (unsigned_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_unsigned_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_long_integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_long_unsigned_type_node)) = sizetype;\n-\n-  error_mark_node = make_node (ERROR_MARK);\n-  TREE_TYPE (error_mark_node) = error_mark_node;\n-\n-  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n-  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n-  signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n-  unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n-  intQI_type_node = make_signed_type (GET_MODE_BITSIZE (QImode));\n-  intHI_type_node = make_signed_type (GET_MODE_BITSIZE (HImode));\n-  intSI_type_node = make_signed_type (GET_MODE_BITSIZE (SImode));\n-  intDI_type_node = make_signed_type (GET_MODE_BITSIZE (DImode));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  intTI_type_node = make_signed_type (GET_MODE_BITSIZE (TImode));\n-#endif\n-  unsigned_intQI_type_node = make_unsigned_type (GET_MODE_BITSIZE (QImode));\n-  unsigned_intHI_type_node = make_unsigned_type (GET_MODE_BITSIZE (HImode));\n-  unsigned_intSI_type_node = make_unsigned_type (GET_MODE_BITSIZE (SImode));\n-  unsigned_intDI_type_node = make_unsigned_type (GET_MODE_BITSIZE (DImode));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  unsigned_intTI_type_node = make_unsigned_type (GET_MODE_BITSIZE (TImode));\n-#endif\n-\n-  float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float_type_node) = FLOAT_TYPE_SIZE;\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_FLOAT],\n \t\t\tfloat_type_node));\n-  layout_type (float_type_node);\n-\n-  double_type_node = make_node (REAL_TYPE);\n-  if (flag_short_double)\n-    TYPE_PRECISION (double_type_node) = FLOAT_TYPE_SIZE;\n-  else\n-    TYPE_PRECISION (double_type_node) = DOUBLE_TYPE_SIZE;\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_DOUBLE],\n \t\t\tdouble_type_node));\n-  layout_type (double_type_node);\n-\n-  long_double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (long_double_type_node) = LONG_DOUBLE_TYPE_SIZE;\n-  layout_type (long_double_type_node);\n-\n-  complex_integer_type_node = make_node (COMPLEX_TYPE);\n-  TREE_TYPE (complex_integer_type_node) = integer_type_node;\n-  layout_type (complex_integer_type_node);\n \n-  complex_float_type_node = make_node (COMPLEX_TYPE);\n-  TREE_TYPE (complex_float_type_node) = float_type_node;\n-  layout_type (complex_float_type_node);\n-\n-  complex_double_type_node = make_node (COMPLEX_TYPE);\n-  TREE_TYPE (complex_double_type_node) = double_type_node;\n-  layout_type (complex_double_type_node);\n-\n-  complex_long_double_type_node = make_node (COMPLEX_TYPE);\n-  TREE_TYPE (complex_long_double_type_node) = long_double_type_node;\n-  layout_type (complex_long_double_type_node);\n-\n-  integer_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (integer_zero_node) = integer_type_node;\n-  integer_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (integer_one_node) = integer_type_node;\n   integer_minus_one_node = build_int_2 (-1, -1);\n   TREE_TYPE (integer_minus_one_node) = integer_type_node;\n \n-  size_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (size_zero_node) = sizetype;\n-  size_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (size_one_node) = sizetype;\n+  build_common_tree_nodes_2 (flag_short_double);\n \n-  void_type_node = make_node (VOID_TYPE);\n   pushdecl (build_decl (TYPE_DECL,\n \t\t\tridpointers[(int) RID_VOID], void_type_node));\n-  layout_type (void_type_node);\t/* Uses integer_zero_node */\n   /* We are not going to have real types in C with less than byte alignment,\n      so we might as well not have any types that claim to have it.  */\n   TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;\n \n-  null_pointer_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n-  layout_type (TREE_TYPE (null_pointer_node));\n-\n   /* This is for wide string constants.  */\n   wchar_type_node = short_unsigned_type_node;\n   wchar_type_size = TYPE_PRECISION (wchar_type_node);\n@@ -3662,9 +3499,6 @@ init_decl_processing ()\n   bit_one_node = build (CONSTRUCTOR, bitstring_one_type_node, NULL_TREE,\n \t\t\tbuild_tree_list (NULL_TREE, integer_zero_node));\n \n-  char_type_node = make_node (CHAR_TYPE);\n-  TYPE_PRECISION (char_type_node) = CHAR_TYPE_SIZE;\n-  fixup_unsigned_type (char_type_node);\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int)RID_CHAR],\n \t\t\tchar_type_node));\n \n@@ -3695,7 +3529,7 @@ init_decl_processing ()\n   pushdecl (build_decl (TYPE_DECL, ridpointers[(int)RID_LONG],\n                         long_integer_type_node));\n \n-  sizetype = long_integer_type_node;\n+  set_sizetype (long_integer_type_node);\n #if 0\n   ptrdiff_type_node\n     = TREE_TYPE (IDENTIFIER_LOCAL_VALUE (get_identifier (PTRDIFF_TYPE)));"}, {"sha": "b919fde8ddb9be2a9867551309c4b5ae65d5829e", "filename": "gcc/ch/expr.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexpr.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern char **boolean_code_name;\n extern int  flag_old_strings;\n-extern tree long_unsigned_type_node;\n extern int  ignore_case;\n extern int  special_UC;\n "}, {"sha": "a1bc17b5cd448fa98efb57247c21a8487dc02ea9", "filename": "gcc/ch/typeck.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -38,22 +38,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"lex.h\"\n #include \"toplev.h\"\n \n-extern tree intQI_type_node;\n-extern tree intHI_type_node;\n-extern tree intSI_type_node;\n-extern tree intDI_type_node;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-extern tree intTI_type_node;\n-#endif\n-\n-extern tree unsigned_intQI_type_node;\n-extern tree unsigned_intHI_type_node;\n-extern tree unsigned_intSI_type_node;\n-extern tree unsigned_intDI_type_node;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-extern tree unsigned_intTI_type_node;\n-#endif\n-\n /* forward declarations */\n static int chill_l_equivalent PROTO((tree, tree, struct mode_chain*));\n static tree extract_constant_from_buffer PROTO((tree, const unsigned char *, int));"}, {"sha": "8f7aaf65405d13d4f640b361e6a6ffd321eb2432", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -1,3 +1,15 @@\n+Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* cp-tree.h: Delete declarations for all tree nodes now moved to\n+\tglobal_trees.\n+\t* decl.c: Delete their definitions.\n+\t(SHORT_TYPE_SIZE, INT_TYPE_SIZE, LONG_TYPE_SIZE, LONG_LONG_TYPE_SIZE,\n+\tFLOAT_TYPE_SIZE, DOUBLE_TYPE_SIZE, LONG_DOUBLE_TYPE_SIZE): Don't\n+\tprovide defaults.\n+\t(init_decl_processing): Call build_common_tree_nodes and\n+\tbuild_common_tree_nodes_2 instead of building their nodes here.\n+\tDon't add gc roots for them.\n+\n 1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (language_function): Rename expanding_p to"}, {"sha": "d40fe7533eaf885cd3eead49500f7191e159e681", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -743,7 +743,6 @@ extern tree global_namespace;\n extern tree ridpointers[];\n extern tree ansi_opname[];\n extern tree ansi_assopname[];\n-extern tree null_pointer_node;\n \n /* Nonzero means `$' can be in an identifier.  */\n "}, {"sha": "ee680230b1e44188e9974e62d2e8cb07faab7cfd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 25, "deletions": 168, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -69,40 +69,12 @@ int ggc_p = 1;\n struct obstack decl_obstack;\n static struct stack_level *decl_stack;\n \n-#ifndef CHAR_TYPE_SIZE\n-#define CHAR_TYPE_SIZE BITS_PER_UNIT\n-#endif\n-\n-#ifndef SHORT_TYPE_SIZE\n-#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n-#endif\n-\n-#ifndef INT_TYPE_SIZE\n-#define INT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef LONG_TYPE_SIZE\n-#define LONG_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef LONG_LONG_TYPE_SIZE\n-#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n #ifndef WCHAR_UNSIGNED\n #define WCHAR_UNSIGNED 0\n #endif\n \n-#ifndef FLOAT_TYPE_SIZE\n-#define FLOAT_TYPE_SIZE BITS_PER_WORD\n-#endif\n-\n-#ifndef DOUBLE_TYPE_SIZE\n-#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n-#endif\n-\n-#ifndef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n \n #ifndef BOOL_TYPE_SIZE\n@@ -212,14 +184,6 @@ static void destroy_local_static PROTO((tree));\n static void indent PROTO((void));\n #endif\n \n-/* A node which has tree code ERROR_MARK, and whose type is itself.\n-   All erroneous expressions are replaced with this node.  All functions\n-   that accept nodes as arguments should avoid generating error messages\n-   if this node is one of the arguments, since it is undesirable to get\n-   multiple error messages from one error in the input.  */\n-\n-tree error_mark_node;\n-\n /* Erroneous argument lists can use this *IFF* they do not modify it.  */\n tree error_mark_list;\n \n@@ -283,21 +247,6 @@ tree error_mark_list;\n \n tree cp_global_trees[CPTI_MAX];\n \n-/* These can't be part of the above array, since they are declared\n-   individually in tree.h, and used by the debug output routines.  */\n-\n-tree void_type_node;\n-tree char_type_node;\n-tree integer_type_node;\n-tree unsigned_type_node;\n-\n-/* These can't be part of the above array, since they are declared\n-   individially in tree.h and used by the target routines.  */\n-\n-tree ptr_type_node;\n-tree va_list_type_node;\n-tree null_pointer_node;\n-\n /* Indicates that there is a type value in some namespace, although\n    that is not necessarily in scope at the moment.  */\n \n@@ -351,13 +300,9 @@ tree static_aggregates;\n \n /* -- end of C++ */\n \n-/* An expression of type `int' for the constant zero.  */\n-\n-tree integer_zero_node;\n+/* A node for the integer constants 2, and 3.  */\n \n-/* A node for the integer constants 1, 2, and 3.  */\n-\n-tree integer_one_node, integer_two_node, integer_three_node;\n+tree integer_two_node, integer_three_node;\n \n /* While defining an enum type, this is 1 plus the last enumerator\n    constant value.  */\n@@ -6091,10 +6036,9 @@ init_decl_processing ()\n \n   gcc_obstack_init (&decl_obstack);\n \n-  /* Must lay these out before anything else gets laid out.  */\n-  error_mark_node = make_node (ERROR_MARK);\n+  build_common_tree_nodes (flag_signed_char);\n+\n   TREE_PERMANENT (error_mark_node) = 1;\n-  TREE_TYPE (error_mark_node) = error_mark_node;\n   error_mark_list = build_tree_list (error_mark_node, error_mark_node);\n   TREE_TYPE (error_mark_list) = error_mark_node;\n \n@@ -6116,62 +6060,37 @@ init_decl_processing ()\n   pfn_or_delta2_identifier = get_identifier (\"__pfn_or_delta2\");\n \n   /* Define `int' and `char' first so that dbx will output them first.  */\n-\n-  integer_type_node = make_signed_type (INT_TYPE_SIZE);\n   record_builtin_type (RID_INT, NULL_PTR, integer_type_node);\n-\n-  /* Define `char', which is like either `signed char' or `unsigned char'\n-     but not the same as either.  */\n-\n-  char_type_node\n-    = (flag_signed_char\n-       ? make_signed_type (CHAR_TYPE_SIZE)\n-       : make_unsigned_type (CHAR_TYPE_SIZE));\n   record_builtin_type (RID_CHAR, \"char\", char_type_node);\n \n   /* `signed' is the same as `int' */\n   record_builtin_type (RID_SIGNED, NULL_PTR, integer_type_node);\n-  \n-  long_integer_type_node = make_signed_type (LONG_TYPE_SIZE);\n   record_builtin_type (RID_LONG, \"long int\", long_integer_type_node);\n-\n-  unsigned_type_node = make_unsigned_type (INT_TYPE_SIZE);\n   record_builtin_type (RID_UNSIGNED, \"unsigned int\", unsigned_type_node);\n-\n-  long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n   record_builtin_type (RID_MAX, \"long unsigned int\", long_unsigned_type_node);\n   record_builtin_type (RID_MAX, \"unsigned long\", long_unsigned_type_node);\n-\n-  long_long_integer_type_node = make_signed_type (LONG_LONG_TYPE_SIZE);\n   record_builtin_type (RID_MAX, \"long long int\", long_long_integer_type_node);\n-\n-  long_long_unsigned_type_node = make_unsigned_type (LONG_LONG_TYPE_SIZE);\n   record_builtin_type (RID_MAX, \"long long unsigned int\",\n \t\t       long_long_unsigned_type_node);\n   record_builtin_type (RID_MAX, \"long long unsigned\",\n \t\t       long_long_unsigned_type_node);\n-\n-  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n   record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n-  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n   record_builtin_type (RID_MAX, \"short unsigned int\", short_unsigned_type_node);\n   record_builtin_type (RID_MAX, \"unsigned short\", short_unsigned_type_node);\n \n-  /* `unsigned long' is the standard type for sizeof.\n-     Note that stddef.h uses `unsigned long',\n-     and this must agree, even if long and int are the same size.  */\n-  set_sizetype\n-    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n-\n   ptrdiff_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n \n   /* Define both `signed char' and `unsigned char'.  */\n-  signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n   record_builtin_type (RID_MAX, \"signed char\", signed_char_type_node);\n-  unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n   record_builtin_type (RID_MAX, \"unsigned char\", unsigned_char_type_node);\n \n+  /* `unsigned long' is the standard type for sizeof.\n+     Note that stddef.h uses `unsigned long',\n+     and this must agree, even if long and int are the same size.  */\n+  set_sizetype\n+    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n+\n   /* Create the widest literal types. */\n   widest_integer_literal_type_node = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n@@ -6182,72 +6101,22 @@ init_decl_processing ()\n \t\t\twidest_unsigned_literal_type_node));\n \n   /* These are types that type_for_size and type_for_mode use.  */\n-  intQI_type_node = make_signed_type (GET_MODE_BITSIZE (QImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intQI_type_node));\n-  intHI_type_node = make_signed_type (GET_MODE_BITSIZE (HImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intHI_type_node));\n-  intSI_type_node = make_signed_type (GET_MODE_BITSIZE (SImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intSI_type_node));\n-  intDI_type_node = make_signed_type (GET_MODE_BITSIZE (DImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  intTI_type_node = make_signed_type (GET_MODE_BITSIZE (TImode));\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"__int128_t\"), intTI_type_node));\n #endif\n-  unsigned_intQI_type_node = make_unsigned_type (GET_MODE_BITSIZE (QImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intQI_type_node));\n-  unsigned_intHI_type_node = make_unsigned_type (GET_MODE_BITSIZE (HImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intHI_type_node));\n-  unsigned_intSI_type_node = make_unsigned_type (GET_MODE_BITSIZE (SImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intSI_type_node));\n-  unsigned_intDI_type_node = make_unsigned_type (GET_MODE_BITSIZE (DImode));\n   pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  unsigned_intTI_type_node = make_unsigned_type (GET_MODE_BITSIZE (TImode));\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"__uint128_t\"), unsigned_intTI_type_node));\n #endif\n \n-  float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float_type_node) = FLOAT_TYPE_SIZE;\n-  record_builtin_type (RID_FLOAT, NULL_PTR, float_type_node);\n-  layout_type (float_type_node);\n-\n-  double_type_node = make_node (REAL_TYPE);\n-  if (flag_short_double)\n-    TYPE_PRECISION (double_type_node) = FLOAT_TYPE_SIZE;\n-  else\n-    TYPE_PRECISION (double_type_node) = DOUBLE_TYPE_SIZE;\n-  record_builtin_type (RID_DOUBLE, NULL_PTR, double_type_node);\n-  layout_type (double_type_node);\n-\n-  long_double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (long_double_type_node) = LONG_DOUBLE_TYPE_SIZE;\n-  record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n-  layout_type (long_double_type_node);\n-\n-  complex_integer_type_node = make_node (COMPLEX_TYPE);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n-\t\t\tcomplex_integer_type_node));\n-  TREE_TYPE (complex_integer_type_node) = integer_type_node;\n-  layout_type (complex_integer_type_node);\n-\n-  complex_float_type_node = make_node (COMPLEX_TYPE);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n-\t\t\tcomplex_float_type_node));\n-  TREE_TYPE (complex_float_type_node) = float_type_node;\n-  layout_type (complex_float_type_node);\n-\n-  complex_double_type_node = make_node (COMPLEX_TYPE);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n-\t\t\tcomplex_double_type_node));\n-  TREE_TYPE (complex_double_type_node) = double_type_node;\n-  layout_type (complex_double_type_node);\n-\n-  complex_long_double_type_node = make_node (COMPLEX_TYPE);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n-\t\t\tcomplex_long_double_type_node));\n-  TREE_TYPE (complex_long_double_type_node) = long_double_type_node;\n-  layout_type (complex_long_double_type_node);\n+  build_common_tree_nodes_2 (flag_short_double);\n \n   java_byte_type_node = record_builtin_java_type (\"__java_byte\", 8);\n   java_short_type_node = record_builtin_java_type (\"__java_short\", 16);\n@@ -6258,10 +6127,6 @@ init_decl_processing ()\n   java_char_type_node = record_builtin_java_type (\"__java_char\", -16);\n   java_boolean_type_node = record_builtin_java_type (\"__java_boolean\", -1);\n \n-  integer_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (integer_zero_node) = integer_type_node;\n-  integer_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (integer_one_node) = integer_type_node;\n   integer_two_node = build_int_2 (2, 0);\n   TREE_TYPE (integer_two_node) = integer_type_node;\n   integer_three_node = build_int_2 (3, 0);\n@@ -6278,23 +6143,25 @@ init_decl_processing ()\n   boolean_true_node = build_int_2 (1, 0);\n   TREE_TYPE (boolean_true_node) = boolean_type_node;\n \n-  /* These are needed by stor-layout.c.  */\n-  size_zero_node = size_int (0);\n-  size_one_node = size_int (1);\n+  signed_size_zero_node = build_int_2 (0, 0);  record_builtin_type (RID_FLOAT, NULL_PTR, float_type_node);\n+  record_builtin_type (RID_DOUBLE, NULL_PTR, double_type_node);\n+  record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n+\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n+\t\t\tcomplex_integer_type_node));\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n+\t\t\tcomplex_float_type_node));\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n+\t\t\tcomplex_double_type_node));\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n+\t\t\tcomplex_long_double_type_node));\n \n-  signed_size_zero_node = build_int_2 (0, 0);\n   TREE_TYPE (signed_size_zero_node) = make_signed_type (TYPE_PRECISION (sizetype));\n \n-  void_type_node = make_node (VOID_TYPE);\n   record_builtin_type (RID_VOID, NULL_PTR, void_type_node);\n-  layout_type (void_type_node); /* Uses integer_zero_node.  */\n   void_list_node = build_tree_list (NULL_TREE, void_type_node);\n   TREE_PARMLIST (void_list_node) = 1;\n \n-  null_pointer_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n-  layout_type (TREE_TYPE (null_pointer_node));\n-     \n   /* Used for expressions that do nothing, but are not errors.  */\n   void_zero_node = build_int_2 (0, 0);\n   TREE_TYPE (void_zero_node) = void_type_node;\n@@ -6497,21 +6364,11 @@ init_decl_processing ()\n   /* Add GC roots for all of our global variables.  */\n   ggc_add_tree_root (c_global_trees, sizeof c_global_trees / sizeof(tree));\n   ggc_add_tree_root (cp_global_trees, sizeof cp_global_trees / sizeof(tree));\n-  ggc_add_tree_root (&char_type_node, 1);\n-  ggc_add_tree_root (&error_mark_node, 1);\n-  ggc_add_tree_root (&integer_type_node, 1);\n   ggc_add_tree_root (&integer_three_node, 1);\n   ggc_add_tree_root (&integer_two_node, 1);\n-  ggc_add_tree_root (&integer_one_node, 1);\n-  ggc_add_tree_root (&integer_zero_node, 1);\n   ggc_add_tree_root (&signed_size_zero_node, 1);\n   ggc_add_tree_root (&size_one_node, 1);\n   ggc_add_tree_root (&size_zero_node, 1);\n-  ggc_add_tree_root (&unsigned_type_node, 1);\n-  ggc_add_tree_root (&ptr_type_node, 1);\n-  ggc_add_tree_root (&null_pointer_node, 1);\n-  ggc_add_tree_root (&va_list_type_node, 1);\n-  ggc_add_tree_root (&void_type_node, 1);\n   ggc_add_root (&global_binding_level, 1, sizeof global_binding_level,\n \t\tmark_binding_level);\n   ggc_add_root (&scope_chain, 1, sizeof scope_chain, &mark_saved_scope);"}, {"sha": "5382d9a4b44790d6e0012431731e1b8dc9555ba3", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -1,3 +1,12 @@\n+Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* com.h: Delete declarations for all tree nodes now moved to\n+\tglobal_trees.\n+\t* com.c: Delete their definitions.\n+\t(ffecom_init_0): Call build_common_tree_nodes and\n+\tbuild_common_tree_nodes_2 instead of building their nodes here.\n+\tOverride their decisions for complex nodes.\n+\n Sat Sep  4 13:46:27 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Make-lang.in (f771): Depend on ggc-callbacks.o."}, {"sha": "316288e925761b6a72f2141c3e45a5ef0b38e3dd", "filename": "gcc/f/com.c", "status": "modified", "additions": 9, "deletions": 86, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -219,17 +219,7 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n    define.  Here are the definitions, which in the C front end are\n    found in the file c-decl.c.  */\n \n-tree integer_zero_node;\n-tree integer_one_node;\n-tree null_pointer_node;\n-tree error_mark_node;\n-tree void_type_node;\n-tree integer_type_node;\n-tree unsigned_type_node;\n-tree char_type_node;\n tree current_function_decl;\n-tree ptr_type_node;\n-tree va_list_type_node;\n \n /* ~~gcc/tree.h *should* declare this, because toplev.c and dwarfout.c\n    reference it.  */\n@@ -246,25 +236,6 @@ FILE *finput;\n    \"static\") are those that ste.c and such might use (directly\n    or by using com macros that reference them in their definitions).  */\n \n-static tree short_integer_type_node;\n-tree long_integer_type_node;\n-static tree long_long_integer_type_node;\n-\n-static tree short_unsigned_type_node;\n-static tree long_unsigned_type_node;\n-static tree long_long_unsigned_type_node;\n-\n-static tree unsigned_char_type_node;\n-static tree signed_char_type_node;\n-\n-static tree float_type_node;\n-static tree double_type_node;\n-static tree complex_float_type_node;\n-tree complex_double_type_node;\n-static tree long_double_type_node;\n-static tree complex_integer_type_node;\n-static tree complex_long_double_type_node;\n-\n tree string_type_node;\n \n static tree double_ftype_double;\n@@ -11699,41 +11670,25 @@ ffecom_init_0 ()\n   global_binding_level = current_binding_level;\n   current_binding_level->prep_state = 2;\n \n-  /* Define `int' and `char' first so that dbx will output them first.  */\n+  build_common_tree_nodes (1);\n \n-  integer_type_node = make_signed_type (INT_TYPE_SIZE);\n+  /* Define `int' and `char' first so that dbx will output them first.  */\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"int\"),\n \t\t\tinteger_type_node));\n-\n-  char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"char\"),\n \t\t\tchar_type_node));\n-\n-  long_integer_type_node = make_signed_type (LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long int\"),\n \t\t\tlong_integer_type_node));\n-\n-  unsigned_type_node = make_unsigned_type (INT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned int\"),\n \t\t\tunsigned_type_node));\n-\n-  long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long unsigned int\"),\n \t\t\tlong_unsigned_type_node));\n-\n-  long_long_integer_type_node = make_signed_type (LONG_LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long int\"),\n \t\t\tlong_long_integer_type_node));\n-\n-  long_long_unsigned_type_node = make_unsigned_type (LONG_LONG_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long unsigned int\"),\n \t\t\tlong_long_unsigned_type_node));\n-\n-  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"short int\"),\n \t\t\tshort_integer_type_node));\n-\n-  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"short unsigned int\"),\n \t\t\tshort_unsigned_type_node));\n \n@@ -11745,76 +11700,44 @@ ffecom_init_0 ()\n   ffecom_typesize_pointer_\n     = TREE_INT_CST_LOW (TYPE_SIZE (sizetype)) / BITS_PER_UNIT;\n \n-  error_mark_node = make_node (ERROR_MARK);\n-  TREE_TYPE (error_mark_node) = error_mark_node;\n+  build_common_tree_nodes_2 (0);\n \n   /* Define both `signed char' and `unsigned char'.  */\n-  signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"signed char\"),\n \t\t\tsigned_char_type_node));\n \n-  unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned char\"),\n \t\t\tunsigned_char_type_node));\n \n-  float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float_type_node) = FLOAT_TYPE_SIZE;\n-  layout_type (float_type_node);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"float\"),\n \t\t\tfloat_type_node));\n-\n-  double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (double_type_node) = DOUBLE_TYPE_SIZE;\n-  layout_type (double_type_node);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"double\"),\n \t\t\tdouble_type_node));\n-\n-  long_double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (long_double_type_node) = LONG_DOUBLE_TYPE_SIZE;\n-  layout_type (long_double_type_node);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"long double\"),\n \t\t\tlong_double_type_node));\n \n+  /* For now, override what build_common_tree_nodes has done.  */\n   complex_integer_type_node = ffecom_make_complex_type_ (integer_type_node);\n+  complex_float_type_node = ffecom_make_complex_type_ (float_type_node);\n+  complex_double_type_node = ffecom_make_complex_type_ (double_type_node);\n+  complex_long_double_type_node\n+    = ffecom_make_complex_type_ (long_double_type_node);\n+\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n \t\t\tcomplex_integer_type_node));\n-\n-  complex_float_type_node = ffecom_make_complex_type_ (float_type_node);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n \t\t\tcomplex_float_type_node));\n-\n-  complex_double_type_node = ffecom_make_complex_type_ (double_type_node);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n \t\t\tcomplex_double_type_node));\n-\n-  complex_long_double_type_node = ffecom_make_complex_type_ (long_double_type_node);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t\tcomplex_long_double_type_node));\n \n-  integer_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (integer_zero_node) = integer_type_node;\n-  integer_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (integer_one_node) = integer_type_node;\n-\n-  size_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (size_zero_node) = sizetype;\n-  size_one_node = build_int_2 (1, 0);\n-  TREE_TYPE (size_one_node) = sizetype;\n-\n-  void_type_node = make_node (VOID_TYPE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"),\n \t\t\tvoid_type_node));\n-  layout_type (void_type_node);\t/* Uses integer_zero_node */\n   /* We are not going to have real types in C with less than byte alignment,\n      so we might as well not have any types that claim to have it.  */\n   TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;\n \n-  ptr_type_node = build_pointer_type (void_type_node);\n-\n-  null_pointer_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_pointer_node) = ptr_type_node;\n-  layout_type (TREE_TYPE (null_pointer_node));\n-\n   string_type_node = build_pointer_type (char_type_node);\n \n   ffecom_tree_fun_type_void"}, {"sha": "b5e77149c0d50605dbbcf79e7b3254dfc04dcc54", "filename": "gcc/f/com.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ff%2Fcom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ff%2Fcom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.h?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -238,8 +238,6 @@ struct _ffecom_symbol_\n /* Global objects accessed by users of this module. */\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n-extern tree long_integer_type_node;\n-extern tree complex_double_type_node;\n extern tree string_type_node;\n extern tree ffecom_integer_type_node;\n extern tree ffecom_integer_zero_node;"}, {"sha": "981a3df10f19da7479c1c1e4d06836c609abad0c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -1,3 +1,9 @@\n+Fri Sep 10 10:32:32 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* java-tree.h: Delete declarations for all tree nodes now moved to\n+\tglobal_trees.\n+\t* decl.c: Delete their definitions.\n+\n 1999-09-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Make-lang.in (jc1): Depend on ggc-callbacks.o."}, {"sha": "443fa9dd19e9ef03795039903480ac703033e1aa", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -252,9 +252,6 @@ static int keep_next_if_subblocks;\n    or 0 if between functions.  */\n tree current_function_decl;\n \n-/* The type node for the ordinary character type.  */\n-tree char_type_node;\n-\n tree object_type_node;\n tree unqualified_object_id_node;\n tree object_ptr_type_node;\n@@ -268,17 +265,8 @@ int  predef_filenames_size;\n \n tree boolean_type_node;\n \n-tree float_type_node;\n-tree double_type_node;\n-\n-/* a VOID_TYPE node.  */\n-\n-tree void_type_node;\n-tree ptr_type_node;\n tree return_address_type_node;\n \n-tree integer_type_node;\n-\n tree byte_type_node;\n tree short_type_node;\n tree int_type_node;\n@@ -319,19 +307,8 @@ tree one_elt_array_domain_type;\n tree access_flags_type_node;\n tree class_dtable_decl;\n \n-/* a node which has tree code ERROR_MARK, and whose type is itself.\n-   All erroneous expressions are replaced with this node.  All functions\n-   that accept nodes as arguments should avoid generating error messages\n-   if this node is one of the arguments, since it is undesirable to get\n-   multiple error messages from one error in the input.  */\n-\n-tree error_mark_node;\n-\n-/* Two expressions that are constants with value zero.\n-   The first is of type `int', the second of type `void *'.\n-   Other of type `long', `float' and `double' follow.  */\n-tree integer_zero_node;\n-tree null_pointer_node;\n+/* Expressions that are constants with value zero, of types\n+   `long', `float' and `double'.  */\n tree long_zero_node;\n tree float_zero_node;\n tree double_zero_node;\n@@ -374,9 +351,6 @@ tree soft_irem_node;\n tree soft_ldiv_node;\n tree soft_lrem_node;\n \n-/* __builtin_va_list; unused by java, but referenced by target files.  */\n-tree va_list_type_node;\n-\n /* Build (and pushdecl) a \"promoted type\" for all standard\n    types shorter than int.  */\n \n@@ -406,7 +380,7 @@ push_promoted_type (name, actual_type)\n }\n \n /* Nodes for integer constants.  */\n-tree integer_one_node, integer_two_node, integer_four_node;\n+tree integer_two_node, integer_four_node;\n tree integer_negative_one_node;\n \n /* Return a definition for a builtin function named NAME and whose data type"}, {"sha": "c13f0955fc536076480e25a532e78d251084b4b2", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -196,9 +196,6 @@ extern tree unsigned_int_type_node;\n extern tree unsigned_long_type_node;\n \n extern tree boolean_type_node;\n-extern tree char_type_node;\n-extern tree float_type_node;\n-extern tree double_type_node;\n \n extern tree object_type_node;\n extern tree unqualified_object_id_node;\n@@ -233,8 +230,6 @@ extern tree this_identifier_node;  /* \"this\" */\n extern tree super_identifier_node;  /* \"super\" */\n extern tree continue_identifier_node;  /* \"continue\" */\n extern tree one_elt_array_domain_type;\n-extern tree void_type_node;\n-extern tree ptr_type_node;\n /* The type of the return address of a subroutine. */\n extern tree return_address_type_node;\n "}, {"sha": "9f32de43ef8d0d274852eab9723b9349daed85c8", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -37,14 +37,6 @@ Boston, MA 02111-1307, USA.  */\n \n struct sizetype_tab sizetype_tab;\n \n-/* An integer constant with value 0 whose type is sizetype.  */\n-\n-tree size_zero_node;\n-\n-/* An integer constant with value 1 whose type is sizetype.  */\n-\n-tree size_one_node;\n-\n /* If nonzero, this is an upper limit on alignment of structure fields.\n    The value is measured in bits.  */\n int maximum_field_alignment;\n@@ -1220,22 +1212,15 @@ set_sizetype (type)\n   sizetype = type;\n \n   /* The *bitsizetype types use a precision that avoids overflows when\n-     calculating signed sizes / offsets in bits.\n-\n-     We are allocating bitsizetype once and change it in place when\n-     we decide later that we want to change it.  This way, we avoid the\n-     hassle of changing all the TYPE_SIZE (TREE_TYPE (sometype))\n-     individually in each front end.  */\n-  if (! bitsizetype)\n-    bitsizetype = make_node (INTEGER_TYPE);\n-  if (TYPE_NAME (sizetype) && ! TYPE_NAME (bitsizetype))\n-    TYPE_NAME (bitsizetype) = TYPE_NAME (sizetype);\n-\n+     calculating signed sizes / offsets in bits.  */\n   precision = oprecision + BITS_PER_UNIT_LOG + 1;\n   /* However, when cross-compiling from a 32 bit to a 64 bit host,\n      we are limited to 64 bit precision.  */\n   if (precision > 2 * HOST_BITS_PER_WIDE_INT)\n     precision = 2 * HOST_BITS_PER_WIDE_INT;\n+\n+  bitsizetype = make_node (INTEGER_TYPE);\n+  TYPE_NAME (bitsizetype) = TYPE_NAME (type);\n   TYPE_PRECISION (bitsizetype) = precision;\n   if (TREE_UNSIGNED (type))\n     fixup_unsigned_type (bitsizetype);\n@@ -1257,6 +1242,7 @@ set_sizetype (type)\n       usizetype = make_unsigned_type (oprecision);\n       ubitsizetype = make_unsigned_type (precision);\n     }\n+  TYPE_NAME (bitsizetype) = TYPE_NAME (sizetype);\n \n   ggc_add_tree_root ((tree*) &sizetype_tab, sizeof(sizetype_tab)/sizeof(tree));\n }"}, {"sha": "16d3f4df43f7d73071eb38eb25a435cf2f1b6e74", "filename": "gcc/tree.c", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -279,6 +279,8 @@ void gcc_obstack_init ();\n \n void (*lang_unsave_expr_now) PROTO((tree));\n \f\n+tree global_trees[TI_MAX];\n+\f\n /* Init the principal obstacks.  */\n \n void\n@@ -311,6 +313,7 @@ init_obstacks ()\n   ggc_add_root (type_hash_table, TYPE_HASH_SIZE, \n \t\tsizeof(struct type_hash *),\n \t\tmark_type_hash);\n+  ggc_add_tree_root (global_trees, TI_MAX);\n }\n \n void\n@@ -5069,3 +5072,185 @@ new_alias_set ()\n   else\n     return 0;\n }\n+\f\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef SHORT_TYPE_SIZE\n+#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_LONG_TYPE_SIZE\n+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef FLOAT_TYPE_SIZE\n+#define FLOAT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef DOUBLE_TYPE_SIZE\n+#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+/* Create nodes for all integer types (and error_mark_node) using the sizes\n+   of C datatypes.  The caller should call set_sizetype soon after calling\n+   this function to select one of the types as sizetype.  */\n+   \n+void\n+build_common_tree_nodes (signed_char)\n+     int signed_char;\n+{\n+  error_mark_node = make_node (ERROR_MARK);\n+  TREE_TYPE (error_mark_node) = error_mark_node;\n+\n+  /* Define both `signed char' and `unsigned char'.  */\n+  signed_char_type_node = make_signed_type (CHAR_TYPE_SIZE);\n+  unsigned_char_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n+\n+  /* Define `char', which is like either `signed char' or `unsigned char'\n+     but not the same as either.  */\n+  char_type_node\n+    = (signed_char\n+       ? make_signed_type (CHAR_TYPE_SIZE)\n+       : make_unsigned_type (CHAR_TYPE_SIZE));\n+\n+  short_integer_type_node = make_signed_type (SHORT_TYPE_SIZE);\n+  short_unsigned_type_node = make_unsigned_type (SHORT_TYPE_SIZE);\n+  integer_type_node = make_signed_type (INT_TYPE_SIZE);\n+  /* Define an unsigned integer first.  make_unsigned_type and make_signed_type\n+     both call set_sizetype for the first type that we create, and we want this\n+     to be large enough to hold the sizes of various types until we switch to\n+     the real sizetype.  */\n+  unsigned_type_node = make_unsigned_type (INT_TYPE_SIZE);\n+  long_integer_type_node = make_signed_type (LONG_TYPE_SIZE);\n+  long_unsigned_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n+  long_long_integer_type_node = make_signed_type (LONG_LONG_TYPE_SIZE);\n+  long_long_unsigned_type_node = make_unsigned_type (LONG_LONG_TYPE_SIZE);\n+\n+  intQI_type_node = make_signed_type (GET_MODE_BITSIZE (QImode));\n+  intHI_type_node = make_signed_type (GET_MODE_BITSIZE (HImode));\n+  intSI_type_node = make_signed_type (GET_MODE_BITSIZE (SImode));\n+  intDI_type_node = make_signed_type (GET_MODE_BITSIZE (DImode));\n+  intTI_type_node = make_signed_type (GET_MODE_BITSIZE (TImode));\n+\n+  unsigned_intQI_type_node = make_unsigned_type (GET_MODE_BITSIZE (QImode));\n+  unsigned_intHI_type_node = make_unsigned_type (GET_MODE_BITSIZE (HImode));\n+  unsigned_intSI_type_node = make_unsigned_type (GET_MODE_BITSIZE (SImode));\n+  unsigned_intDI_type_node = make_unsigned_type (GET_MODE_BITSIZE (DImode));\n+  unsigned_intTI_type_node = make_unsigned_type (GET_MODE_BITSIZE (TImode));\n+}\n+\n+/* For type TYPE, fill in the proper type for TYPE_SIZE and\n+   TYPE_SIZE_UNIT.  */\n+static void\n+fix_sizetype (type)\n+     tree type;\n+{\n+  TREE_TYPE (TYPE_SIZE (type)) = sizetype;\n+  TREE_TYPE (TYPE_SIZE_UNIT (type)) = bitsizetype;\n+}\n+\n+/* Call this function after calling build_common_tree_nodes and set_sizetype.\n+   It will fix the previously made nodes to have proper references to\n+   sizetype, and it will create several other common tree nodes.  */\n+void\n+build_common_tree_nodes_2 (short_double)\n+     int short_double;\n+{\n+  fix_sizetype (signed_char_type_node);\n+  fix_sizetype (unsigned_char_type_node);\n+  fix_sizetype (char_type_node);\n+  fix_sizetype (short_integer_type_node);\n+  fix_sizetype (short_unsigned_type_node);\n+  fix_sizetype (integer_type_node);\n+  fix_sizetype (unsigned_type_node);\n+  fix_sizetype (long_unsigned_type_node);\n+  fix_sizetype (long_integer_type_node);\n+  fix_sizetype (long_long_integer_type_node);\n+  fix_sizetype (long_long_unsigned_type_node);\n+\n+  fix_sizetype (intQI_type_node);\n+  fix_sizetype (intHI_type_node);\n+  fix_sizetype (intSI_type_node);\n+  fix_sizetype (intDI_type_node);\n+  fix_sizetype (intTI_type_node);\n+  fix_sizetype (unsigned_intQI_type_node);\n+  fix_sizetype (unsigned_intHI_type_node);\n+  fix_sizetype (unsigned_intSI_type_node);\n+  fix_sizetype (unsigned_intDI_type_node);\n+  fix_sizetype (unsigned_intTI_type_node);\n+\n+  integer_zero_node = build_int_2 (0, 0);\n+  TREE_TYPE (integer_zero_node) = integer_type_node;\n+  integer_one_node = build_int_2 (1, 0);\n+  TREE_TYPE (integer_one_node) = integer_type_node;\n+\n+  size_zero_node = build_int_2 (0, 0);\n+  TREE_TYPE (size_zero_node) = sizetype;\n+  size_one_node = build_int_2 (1, 0);\n+  TREE_TYPE (size_one_node) = sizetype;\n+\n+  void_type_node = make_node (VOID_TYPE);\n+  layout_type (void_type_node);\t/* Uses size_zero_node */\n+  /* We are not going to have real types in C with less than byte alignment,\n+     so we might as well not have any types that claim to have it.  */\n+  TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;\n+\n+  null_pointer_node = build_int_2 (0, 0);\n+  TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n+  layout_type (TREE_TYPE (null_pointer_node));\n+\n+  ptr_type_node = build_pointer_type (void_type_node);\n+  const_ptr_type_node\n+    = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n+\n+  float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (float_type_node) = FLOAT_TYPE_SIZE;\n+  layout_type (float_type_node);\n+\n+  double_type_node = make_node (REAL_TYPE);\n+  if (short_double)\n+    TYPE_PRECISION (double_type_node) = FLOAT_TYPE_SIZE;\n+  else\n+    TYPE_PRECISION (double_type_node) = DOUBLE_TYPE_SIZE;\n+  layout_type (double_type_node);\n+\n+  long_double_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (long_double_type_node) = LONG_DOUBLE_TYPE_SIZE;\n+  layout_type (long_double_type_node);\n+\n+  complex_integer_type_node = make_node (COMPLEX_TYPE);\n+  TREE_TYPE (complex_integer_type_node) = integer_type_node;\n+  layout_type (complex_integer_type_node);\n+\n+  complex_float_type_node = make_node (COMPLEX_TYPE);\n+  TREE_TYPE (complex_float_type_node) = float_type_node;\n+  layout_type (complex_float_type_node);\n+\n+  complex_double_type_node = make_node (COMPLEX_TYPE);\n+  TREE_TYPE (complex_double_type_node) = double_type_node;\n+  layout_type (complex_double_type_node);\n+\n+  complex_long_double_type_node = make_node (COMPLEX_TYPE);\n+  TREE_TYPE (complex_long_double_type_node) = long_double_type_node;\n+  layout_type (complex_long_double_type_node);\n+\n+#ifdef BUILD_VA_LIST_TYPE\n+  BUILD_VA_LIST_TYPE(va_list_type_node);\n+#else\n+  va_list_type_node = ptr_type_node;\n+#endif\n+}"}, {"sha": "6df6e63cc093aa0e9b553c4cd8c4387cdc8edc83", "filename": "gcc/tree.h", "status": "modified", "additions": 103, "deletions": 35, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b3411cdf96d7160aad803388a8e522501646f6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=81b3411cdf96d7160aad803388a8e522501646f6", "patch": "@@ -1418,6 +1418,109 @@ union tree_node\n   struct tree_block block;\n  };\n \f\n+/* Standard named or nameless data types of the C compiler.  */\n+\n+enum tree_index\n+{\n+  TI_ERROR_MARK,\n+  TI_INTQI_TYPE,\n+  TI_INTHI_TYPE,\n+  TI_INTSI_TYPE,\n+  TI_INTDI_TYPE,\n+  TI_INTTI_TYPE,\n+\n+  TI_UINTQI_TYPE,\n+  TI_UINTHI_TYPE,\n+  TI_UINTSI_TYPE,\n+  TI_UINTDI_TYPE,\n+  TI_UINTTI_TYPE,\n+    \n+  TI_CHAR_TYPE,\n+  TI_SIGNED_CHAR_TYPE,\n+  TI_UNSIGNED_CHAR_TYPE,\n+  TI_INTEGER_TYPE,\n+  TI_UNSIGNED_TYPE,\n+  TI_SHORT_INTEGER_TYPE,\n+  TI_SHORT_UNSIGNED_TYPE,\n+  TI_LONG_INTEGER_TYPE,\n+  TI_LONG_UNSIGNED_TYPE,\n+  TI_LONG_LONG_INTEGER_TYPE,\n+  TI_LONG_LONG_UNSIGNED_TYPE,\n+\n+  TI_INTEGER_ZERO,\n+  TI_INTEGER_ONE,\n+  TI_NULL_POINTER,\n+\n+  TI_SIZE_ZERO,\n+  TI_SIZE_ONE,\n+    \n+  TI_COMPLEX_INTEGER_TYPE,\n+  TI_COMPLEX_FLOAT_TYPE,\n+  TI_COMPLEX_DOUBLE_TYPE,\n+  TI_COMPLEX_LONG_DOUBLE_TYPE,\n+\n+  TI_FLOAT_TYPE,\n+  TI_DOUBLE_TYPE,\n+  TI_LONG_DOUBLE_TYPE,\n+\n+  TI_VOID_TYPE,\n+  TI_PTR_TYPE,\n+  TI_CONST_PTR_TYPE,\n+  TI_PTRDIFF_TYPE,\n+  TI_VA_LIST_TYPE,\n+\n+  TI_MAX\n+};\n+\n+extern tree global_trees[TI_MAX];\n+\n+#define error_mark_node\t\t\tglobal_trees[TI_ERROR_MARK]\n+ \n+#define intQI_type_node\t\t\tglobal_trees[TI_INTQI_TYPE]\n+#define intHI_type_node\t\t\tglobal_trees[TI_INTHI_TYPE]\n+#define intSI_type_node\t\t\tglobal_trees[TI_INTSI_TYPE]\n+#define intDI_type_node\t\t\tglobal_trees[TI_INTDI_TYPE]\n+#define intTI_type_node\t\t\tglobal_trees[TI_INTTI_TYPE]\n+\n+#define unsigned_intQI_type_node\tglobal_trees[TI_UINTQI_TYPE]\n+#define unsigned_intHI_type_node\tglobal_trees[TI_UINTHI_TYPE]\n+#define unsigned_intSI_type_node\tglobal_trees[TI_UINTSI_TYPE]\n+#define unsigned_intDI_type_node\tglobal_trees[TI_UINTDI_TYPE]\n+#define unsigned_intTI_type_node\tglobal_trees[TI_UINTTI_TYPE]\n+\n+#define char_type_node\t\t\tglobal_trees[TI_CHAR_TYPE]\n+#define signed_char_type_node\t\tglobal_trees[TI_SIGNED_CHAR_TYPE]\n+#define unsigned_char_type_node\t\tglobal_trees[TI_UNSIGNED_CHAR_TYPE]\n+#define short_integer_type_node\t\tglobal_trees[TI_SHORT_INTEGER_TYPE]\n+#define short_unsigned_type_node\tglobal_trees[TI_SHORT_UNSIGNED_TYPE]\n+#define integer_type_node\t\tglobal_trees[TI_INTEGER_TYPE]\n+#define unsigned_type_node\t\tglobal_trees[TI_UNSIGNED_TYPE]\n+#define long_integer_type_node\t\tglobal_trees[TI_LONG_INTEGER_TYPE]\n+#define long_unsigned_type_node\t\tglobal_trees[TI_LONG_UNSIGNED_TYPE]\n+#define long_long_integer_type_node\tglobal_trees[TI_LONG_LONG_INTEGER_TYPE]\n+#define long_long_unsigned_type_node\tglobal_trees[TI_LONG_LONG_UNSIGNED_TYPE]\n+\n+#define integer_zero_node\t\tglobal_trees[TI_INTEGER_ZERO]\n+#define integer_one_node\t\tglobal_trees[TI_INTEGER_ONE]\n+#define size_zero_node\t\t\tglobal_trees[TI_SIZE_ZERO]\n+#define size_one_node\t\t\tglobal_trees[TI_SIZE_ONE]\n+#define null_pointer_node\t\tglobal_trees[TI_NULL_POINTER]\n+\n+#define float_type_node\t\t\tglobal_trees[TI_FLOAT_TYPE]\n+#define double_type_node\t\tglobal_trees[TI_DOUBLE_TYPE]\n+#define long_double_type_node\t\tglobal_trees[TI_LONG_DOUBLE_TYPE]\n+\n+#define complex_integer_type_node\tglobal_trees[TI_COMPLEX_INTEGER_TYPE]\n+#define complex_float_type_node\t\tglobal_trees[TI_COMPLEX_FLOAT_TYPE]\n+#define complex_double_type_node\tglobal_trees[TI_COMPLEX_DOUBLE_TYPE]\n+#define complex_long_double_type_node\tglobal_trees[TI_COMPLEX_LONG_DOUBLE_TYPE]\n+\n+#define void_type_node\t\t\tglobal_trees[TI_VOID_TYPE]\n+#define ptr_type_node\t\t\tglobal_trees[TI_PTR_TYPE]\n+#define const_ptr_type_node\t\tglobal_trees[TI_CONST_PTR_TYPE]\n+#define ptrdiff_type_node\t\tglobal_trees[TI_PTRDIFF_TYPE]\n+#define va_list_type_node\t\tglobal_trees[TI_VA_LIST_TYPE]\n+\f\n #define NULL_TREE (tree) NULL\n \n /* The following functions accept a wide integer argument.  Rather than\n@@ -1859,41 +1962,6 @@ extern int real_zerop PROTO((tree));\n \f\n /* Declare commonly used variables for tree structure.  */\n \n-/* An integer constant with value 0 */\n-extern tree integer_zero_node;\n-\n-/* An integer constant with value 1 */\n-extern tree integer_one_node;\n-\n-/* An integer constant with value 0 whose type is sizetype.  */\n-extern tree size_zero_node;\n-\n-/* An integer constant with value 1 whose type is sizetype.  */\n-extern tree size_one_node;\n-\n-/* A constant of type pointer-to-int and value 0 */\n-extern tree null_pointer_node;\n-\n-/* A node of type ERROR_MARK.  */\n-extern tree error_mark_node;\n-\n-/* The type node for the void type.  */\n-extern tree void_type_node;\n-\n-/* The type node for the ordinary (signed) integer type.  */\n-extern tree integer_type_node;\n-\n-/* The type node for the unsigned integer type.  */\n-extern tree unsigned_type_node;\n-\n-/* The type node for the ordinary character type.  */\n-extern tree char_type_node;\n-\n-extern tree ptr_type_node;\n-\n-/* Type `va_list'.  Used by va_start, va_arg, etc.  */\n-extern tree va_list_type_node;\n-\n /* Points to the name of the input file from which the current input\n    being parsed originally came (before it went into cpp).  */\n extern char *input_filename;"}]}