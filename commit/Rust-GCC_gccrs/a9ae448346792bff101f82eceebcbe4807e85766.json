{"sha": "a9ae448346792bff101f82eceebcbe4807e85766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhZTQ0ODM0Njc5MmJmZjEwMWY4MmVjZWViY2JlNDgwN2U4NTc2Ng==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@bitmover.com", "date": "1999-10-29T04:31:14Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-10-29T04:31:14Z"}, "message": "cpplib.h (struct cpp_buffer: fname, [...]): Mark const.\n\n1999-10-28 21:27 -0700  Zack Weinberg  <zack@bitmover.com>\n\n\t* cpplib.h (struct cpp_buffer: fname, nominal_fname,\n\tlast_nominal_fname): Mark const.\n\t(struct include_hash: name, nshort, control_macro): Mark\n\tconst.\n\t(struct macrodef: symnam): Mark const.\n\t(struct if_stack: fname): Mark const.\n\t(is_idchar, is_idstart, is_hor_space, trigraph_table): Delete.\n\t(IStable): New character-syntax array which encompasses all\n\tthe old is_foo arrays.\n\t(is_idchar, is_numchar, is_idstart, is_numstart, is_hspace,\n\tis_space): New macros for interrogating IStable.\n\t(check_macro_name): Kill last argument.  All callers changed.\n\n\t* cppinit.c (initialize_char_syntax): Delete.\n\t(is_idchar, is_idstart, is_hor_space, is_space,\n\ttrigraph_table): Delete.\n\t(IStable): New.  Initialize with clever macros to avoid\n\tinformation duplication.\n\t(builtin_array): Table of builtins to get rid of explicit list\n\tin initialize_builtins.\n\t(initialize_builtins): Use builtins_array.\n\t(cpp_start_read): Call init_IStable, and set IStable['$'] if\n\topts->dollars_in_ident.\n\n\t* cppexp.c: Change all refs to is_xyz[] arrays to use new\n\tis_xyz() macros.\n\t(cpp_parse_expr): Avoid 'format string is not constant'\n\twarning. Use ISGRAPH to identify printable chars.\n\t* cppfiles.c: Change all refs to is_xyz[] arrays to use new\n\tis_xyz() macros.\n\t(read_and_prescan): Map trigraphs to chars with open-coded\n\tif-else-if-... sequence, not a lookup table.\n\t* cpphash.c: Change all refs to is_xyz[] arrays to use new\n\tis_xyz() macros.\n\t* cpplib.c: Change all refs to is_xyz[] arrays to use new\n\tis_xyz() macros.  Kill SKIP_ALL_WHITE_SPACE (unused).\n\t(check_macro_name): Remove ability to report an invalid\n\tassertion name, which is never used.\n\t(do_line): Constify a couple of char *'s.\n\t* cppmain.c (main): Call cpp_cleanup before returning.\n\nFrom-SVN: r30252", "tree": {"sha": "b2a0aa8d86d67e1213ffbe961148d1038e5ba877", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2a0aa8d86d67e1213ffbe961148d1038e5ba877"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9ae448346792bff101f82eceebcbe4807e85766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ae448346792bff101f82eceebcbe4807e85766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ae448346792bff101f82eceebcbe4807e85766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ae448346792bff101f82eceebcbe4807e85766/comments", "author": null, "committer": null, "parents": [{"sha": "3277221c451318748ffe73c4205ca474fd0b806c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3277221c451318748ffe73c4205ca474fd0b806c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3277221c451318748ffe73c4205ca474fd0b806c"}], "stats": {"total": 580, "additions": 281, "deletions": 299}, "files": [{"sha": "4435b727460602891203b261475a2ae9ef359390", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -1,3 +1,46 @@\n+1999-10-28 21:27 -0700  Zack Weinberg  <zack@bitmover.com>\n+\n+\t* cpplib.h (struct cpp_buffer: fname, nominal_fname,\n+\tlast_nominal_fname): Mark const.\n+\t(struct include_hash: name, nshort, control_macro): Mark\n+\tconst.\n+\t(struct macrodef: symnam): Mark const.\n+\t(struct if_stack: fname): Mark const.\n+\t(is_idchar, is_idstart, is_hor_space, trigraph_table): Delete.\n+\t(IStable): New character-syntax array which encompasses all\n+\tthe old is_foo arrays.\n+\t(is_idchar, is_numchar, is_idstart, is_numstart, is_hspace,\n+\tis_space): New macros for interrogating IStable.\n+\t(check_macro_name): Kill last argument.  All callers changed.\n+\n+\t* cppinit.c (initialize_char_syntax): Delete.\n+\t(is_idchar, is_idstart, is_hor_space, is_space,\n+\ttrigraph_table): Delete.\n+\t(IStable): New.  Initialize with clever macros to avoid\n+\tinformation duplication.\n+\t(builtin_array): Table of builtins to get rid of explicit list\n+\tin initialize_builtins.\n+\t(initialize_builtins): Use builtins_array.\n+\t(cpp_start_read): Call init_IStable, and set IStable['$'] if\n+\topts->dollars_in_ident.\n+\n+\t* cppexp.c: Change all refs to is_xyz[] arrays to use new\n+\tis_xyz() macros.\n+\t(cpp_parse_expr): Avoid 'format string is not constant'\n+\twarning. Use ISGRAPH to identify printable chars.\n+\t* cppfiles.c: Change all refs to is_xyz[] arrays to use new\n+\tis_xyz() macros.\n+\t(read_and_prescan): Map trigraphs to chars with open-coded\n+\tif-else-if-... sequence, not a lookup table.\n+\t* cpphash.c: Change all refs to is_xyz[] arrays to use new\n+\tis_xyz() macros.\n+\t* cpplib.c: Change all refs to is_xyz[] arrays to use new\n+\tis_xyz() macros.  Kill SKIP_ALL_WHITE_SPACE (unused).\n+\t(check_macro_name): Remove ability to report an invalid\n+\tassertion name, which is never used.\n+\t(do_line): Constify a couple of char *'s.\n+\t* cppmain.c (main): Call cpp_cleanup before returning.\n+\n Thu Oct 28 21:16:35 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ggc.h (struct ggc_statistics): New type."}, {"sha": "dafbe92e74e1b840f0b6cb4f7c73d0aabbb12183", "filename": "gcc/cppexp.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -457,12 +457,12 @@ cpp_lex (pfile, skip_evaluation)\n \t      cpp_skip_hspace (pfile);\n \t    }\n \n-\t  if (!is_idstart[*ip->cur])\n+\t  if (!is_idstart(*ip->cur))\n \t    goto oops;\n \t  if (ip->cur[0] == 'L' && (ip->cur[1] == '\\'' || ip->cur[1] == '\"'))\n \t    goto oops;\n \t  tok = ip->cur;\n-\t  while (is_idchar[*ip->cur])\n+\t  while (is_idchar(*ip->cur))\n \t    ++ip->cur;\n \t  len = ip->cur - tok;\n \t  cpp_skip_hspace (pfile);\n@@ -1010,11 +1010,11 @@ cpp_parse_expr (pfile)\n \t\t}\n \t      break;\n \t    default:\n-\t      cpp_error (pfile,\n-\t\t\t (top[1].op >= ' ' && top[1].op <= '~'\n-\t\t\t  ? \"unimplemented operator '%c'\\n\"\n-\t\t\t  : \"unimplemented operator '\\\\%03o'\\n\"),\n-\t\t\t top[1].op);\n+\t      if (ISGRAPH (top[1].op))\n+\t\tcpp_error (pfile, \"unimplemented operator '%c'\\n\", top[1].op);\n+\t      else\n+\t\tcpp_error (pfile, \"unimplemented operator '\\\\%03o'\\n\",\n+\t\t\t   top[1].op);\n \t    }\n \t}\n       if (op.op == 0)"}, {"sha": "dfeddcc8ca278d8e06b3892648dd33d87fd364ce", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -437,10 +437,10 @@ read_filename_string (ch, f)\n \n   len = 20;\n   set = alloc = xmalloc (len + 1);\n-  if (! is_space[ch])\n+  if (! is_space(ch))\n     {\n       *set++ = ch;\n-      while ((ch = getc (f)) != EOF && ! is_space[ch])\n+      while ((ch = getc (f)) != EOF && ! is_space(ch))\n \t{\n \t  if (set - alloc == len)\n \t    {\n@@ -503,10 +503,10 @@ read_name_map (pfile, dirname)\n \t  char *from, *to;\n \t  struct file_name_map *ptr;\n \n-\t  if (is_space[ch])\n+\t  if (is_space(ch))\n \t    continue;\n \t  from = read_filename_string (ch, f);\n-\t  while ((ch = getc (f)) != EOF && is_hor_space[ch])\n+\t  while ((ch = getc (f)) != EOF && is_hspace(ch))\n \t    ;\n \t  to = read_filename_string (ch, f);\n \n@@ -976,7 +976,7 @@ read_and_prescan (pfile, fp, desc, len)\n \n \t    case SPECCASE_QUESTION: /* ? */\n \t      {\n-\t\tunsigned int d;\n+\t\tunsigned int d, t;\n \t\t/* If we're at the end of the intermediate buffer,\n \t\t   we have to shift the ?'s down to the start and\n \t\t   come back next pass. */\n@@ -998,12 +998,27 @@ read_and_prescan (pfile, fp, desc, len)\n \t\t    *--ibase = '?';\n \t\t    goto read_next;\n \t\t  }\n-\t\tif (!trigraph_table[d])\n+\n+\t\t/* Trigraph map:\n+\t\t *\tfrom\tto\tfrom\tto\tfrom\tto\n+\t\t *\t?? =\t#\t?? )\t]\t?? !\t|\n+\t\t *\t?? (\t[\t?? '\t^\t?? >\t}\n+\t\t *\t?? /\t\\\t?? <\t{\t?? -\t~\n+\t\t */\n+\t\tif (d == '=') t = '#';\n+\t\telse if (d == ')') t = ']';\n+\t\telse if (d == '!') t = '|';\n+\t\telse if (d == '(') t = '[';\n+\t\telse if (d == '\\'') t = '^';\n+\t\telse if (d == '>') t = '}';\n+\t\telse if (d == '/') t = '\\\\';\n+\t\telse if (d == '<') t = '{';\n+\t\telse if (d == '-') t = '~';\n+\t\telse\n \t\t  {\n \t\t    *op++ = '?';\n \t\t    break;\n \t\t  }\n-\n \t\tif (CPP_OPTIONS (pfile)->warn_trigraphs)\n \t\t  {\n \t\t    unsigned long col;\n@@ -1014,10 +1029,10 @@ read_and_prescan (pfile, fp, desc, len)\n \t\t  }\n \t\tif (CPP_OPTIONS (pfile)->trigraphs)\n \t\t  {\n-\t\t    if (trigraph_table[d] == '\\\\')\n+\t\t    if (t == '\\\\')\n \t\t      goto backslash;\n \t\t    else\n-\t\t      *op++ = trigraph_table[d];\n+\t\t      *op++ = t;\n \t\t  }\n \t\telse\n \t\t  {"}, {"sha": "8c268f455a3a42e86bf7ab5f55ef66d5c58a284d", "filename": "gcc/cpphash.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -40,7 +40,7 @@ static struct tm *timestamp\t PARAMS ((cpp_reader *));\n static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n \n \n-#define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n+#define SKIP_WHITE_SPACE(p) do { while (is_hspace(*p)) p++; } while (0)\n #define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n #define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n \n@@ -131,7 +131,7 @@ cpp_lookup (pfile, name, len, hash)\n \n   if (len < 0)\n     {\n-      for (bp = name; is_idchar[*bp]; bp++);\n+      for (bp = name; is_idchar(*bp); bp++);\n       len = bp - name;\n     }\n \n@@ -224,7 +224,7 @@ cpp_install (pfile, name, len, type, value, hash)\n   if (len < 0)\n     {\n       p = name;\n-      while (is_idchar[*p])\n+      while (is_idchar(*p))\n \tp++;\n       len = p - name;\n     }\n@@ -306,7 +306,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \n   /* Find the beginning of the trailing whitespace.  */\n   p = buf;\n-  while (p < limit && is_space[limit[-1]])\n+  while (p < limit && is_space(limit[-1]))\n     limit--;\n \n   /* Allocate space for the text in the macro definition.\n@@ -376,7 +376,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \t\t  /* ##: concatenate preceding and following tokens.  */\n \t\t  /* Take out the first #, discard preceding whitespace.  */\n \t\t  exp_p--;\n-\t\t  while (exp_p > lastp && is_hor_space[exp_p[-1]])\n+\t\t  while (exp_p > lastp && is_hspace(exp_p[-1]))\n \t\t    --exp_p;\n \t\t  /* Skip the second #.  */\n \t\t  p++;\n@@ -392,7 +392,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \t\t     Don't leave the # in the expansion.  */\n \t\t  exp_p--;\n \t\t  SKIP_WHITE_SPACE (p);\n-\t\t  if (p == limit || !is_idstart[*p]\n+\t\t  if (p == limit || !is_idstart(*p)\n \t\t      || (*p == 'L' && p + 1 < limit && (p[1] == '\\'' ||\n \t\t\t\t\t\t\t p[1] == '\"')))\n \t\t    cpp_error (pfile,\n@@ -457,17 +457,17 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \t}\n \n       /* Handle the start of a symbol.  */\n-      if (is_idchar[c] && nargs > 0)\n+      if (is_idchar(c) && nargs > 0)\n \t{\n \t  U_CHAR *id_beg = p - 1;\n \t  int id_len;\n \n \t  --exp_p;\n-\t  while (p != limit && is_idchar[*p])\n+\t  while (p != limit && is_idchar(*p))\n \t    p++;\n \t  id_len = p - id_beg;\n \n-\t  if (is_idstart[c]\n+\t  if (is_idstart(c)\n \t      && !(id_len == 1 && c == 'L' && (*p == '\\'' || *p == '\"')))\n \t    {\n \t      register struct arglist *arg;\n@@ -612,12 +612,12 @@ create_definition (buf, limit, pfile, predefinition)\n \n   bp = buf;\n \n-  while (is_hor_space[*bp])\n+  while (is_hspace(*bp))\n     bp++;\n \n   symname = bp;\t\t\t/* remember where it starts */\n \n-  sym_length = check_macro_name (pfile, bp, 0);\n+  sym_length = check_macro_name (pfile, bp);\n   bp += sym_length;\n \n   /* Lossage will occur if identifiers or control keywords are broken\n@@ -648,11 +648,11 @@ create_definition (buf, limit, pfile, predefinition)\n \t    cpp_pedwarn (pfile, \"another parameter follows `%s'\",\n \t\t\t rest_extension);\n \n-\t  if (!is_idstart[*bp])\n+\t  if (!is_idstart(*bp))\n \t    cpp_pedwarn (pfile, \"invalid character in macro parameter name\");\n \n \t  /* Find the end of the arg name.  */\n-\t  while (is_idchar[*bp])\n+\t  while (is_idchar(*bp))\n \t    {\n \t      bp++;\n \t      /* do we have a \"special\" rest-args extension here? */\n@@ -737,7 +737,7 @@ create_definition (buf, limit, pfile, predefinition)\n \n       if (bp < limit)\n \t{\n-\t  if (is_hor_space[*bp])\n+\t  if (is_hspace(*bp))\n \t    {\n \t      bp++;\n \t      SKIP_WHITE_SPACE (bp);\n@@ -1141,7 +1141,7 @@ macroexpand (pfile, hp)\n \t  /* cpp.texi says for foo ( ) we provide one argument.\n \t     However, if foo wants just 0 arguments, treat this as 0.  */\n \t  if (nargs == 0)\n-\t    while (bp != lim && is_space[*bp])\n+\t    while (bp != lim && is_space(*bp))\n \t      bp++;\n \t  if (bp == lim)\n \t    i = 0;\n@@ -1227,7 +1227,7 @@ macroexpand (pfile, hp)\n \t\t\t  /* Internal sequences of whitespace are\n \t\t\t     replaced by one space except within\n \t\t\t     a string or char token. */\n-\t\t\t  if (is_space[c])\n+\t\t\t  if (is_space(c))\n \t\t\t    {\n \t\t\t      if (CPP_WRITTEN (pfile) > (unsigned) arg->stringified\n \t\t\t\t  && (CPP_PWRITTEN (pfile))[-1] == '\\r')\n@@ -1333,11 +1333,11 @@ macroexpand (pfile, hp)\n \t\t      && last_ap->raw_after)))\n \t    {\n \t      /* Delete final whitespace.  */\n-\t      while (totlen > count_before && is_space[xbuf[totlen - 1]])\n+\t      while (totlen > count_before && is_space(xbuf[totlen - 1]))\n \t\ttotlen--;\n \n \t      /* Delete the nonwhites before them.  */\n-\t      while (totlen > count_before && !is_space[xbuf[totlen - 1]])\n+\t      while (totlen > count_before && !is_space(xbuf[totlen - 1]))\n \t\ttotlen--;\n \t    }\n \n@@ -1357,7 +1357,7 @@ macroexpand (pfile, hp)\n \t\t     whitespace markers, and no-reexpansion markers.  */\n \t\t  while (p1 != l1)\n \t\t    {\n-\t\t      if (is_space[p1[0]])\n+\t\t      if (is_space(p1[0]))\n \t\t\tp1++;\n \t\t      else if (p1[0] == '\\r')\n \t\t\tp1 += 2;\n@@ -1371,7 +1371,7 @@ macroexpand (pfile, hp)\n \t\t     whitespace markers, and no-reexpansion markers.  */\n \t\t  while (p1 != l1)\n \t\t    {\n-\t\t      if (is_space[l1[-1]])\n+\t\t      if (is_space(l1[-1]))\n \t\t\tl1--;\n \t\t      else if (l1[-1] == '\\r')\n \t\t\tl1--;\n@@ -1510,7 +1510,7 @@ unsafe_chars (c1, c2)\n     case 'U':  case 'V':  case 'W':  case 'X':  case 'Y':  case 'Z':\n     letter:\n     /* We're in the middle of either a name or a pre-processing number.  */\n-      return (is_idchar[c2] || c2 == '.');\n+      return (is_idchar(c2) || c2 == '.');\n \n     case '<':  case '>':  case '!':  case '%':  case '#':  case ':':\n     case '^':  case '&':  case '|':  case '*':  case '/':  case '=':\n@@ -1551,7 +1551,7 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n      or some other (less common) characters.  */\n \n   if (xbuf[0] == '\\r' && xbuf[1] == ' '\n-      && (is_idchar[xbuf[2]] || xbuf[2] == '(' || xbuf[2] == '\\''\n+      && (is_idchar(xbuf[2]) || xbuf[2] == '(' || xbuf[2] == '\\''\n \t  || xbuf[2] == '\\\"'))\n     mbuf->cur += 2;\n \n@@ -1627,25 +1627,25 @@ comp_def_part (first, beg1, len1, beg2, len2, last)\n   register U_CHAR *end2 = beg2 + len2;\n   if (first)\n     {\n-      while (beg1 != end1 && is_space[*beg1])\n+      while (beg1 != end1 && is_space(*beg1))\n \tbeg1++;\n-      while (beg2 != end2 && is_space[*beg2])\n+      while (beg2 != end2 && is_space(*beg2))\n \tbeg2++;\n     }\n   if (last)\n     {\n-      while (beg1 != end1 && is_space[end1[-1]])\n+      while (beg1 != end1 && is_space(end1[-1]))\n \tend1--;\n-      while (beg2 != end2 && is_space[end2[-1]])\n+      while (beg2 != end2 && is_space(end2[-1]))\n \tend2--;\n     }\n   while (beg1 != end1 && beg2 != end2)\n     {\n-      if (is_space[*beg1] && is_space[*beg2])\n+      if (is_space(*beg1) && is_space(*beg2))\n \t{\n-\t  while (beg1 != end1 && is_space[*beg1])\n+\t  while (beg1 != end1 && is_space(*beg1))\n \t    beg1++;\n-\t  while (beg2 != end2 && is_space[*beg2])\n+\t  while (beg2 != end2 && is_space(*beg2))\n \t    beg2++;\n \t}\n       else if (*beg1 == *beg2)"}, {"sha": "fa41c3ca74bee004deeb6ef89a3abefaa41094f8", "filename": "gcc/cppinit.c", "status": "modified", "additions": 122, "deletions": 205, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -194,7 +194,6 @@ struct pending_option\n   } while (0)\n #endif\n \n-static void initialize_char_syntax\tPARAMS ((int));\n static void print_help                  PARAMS ((void));\n static void path_include\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct cpp_pending *,\n@@ -210,174 +209,57 @@ static void initialize_dependency_output PARAMS ((cpp_reader *));\n /* Last argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n \n-/* If gcc is in use (stage2/stage3) we can make these tables initialized\n-   data. */\n+/* If gcc is in use (stage2/stage3) we can make this table initialized data. */\n+#ifdef __STDC__\n+#define CAT(a, b) a##b\n+#else\n+#define CAT(a, b) a/**/b\n+#endif\n+\n #if HAVE_GCC_VERSION(2,7)\n-/* Table to tell if a character is legal as the second or later character\n-   of a C identifier. */\n-U_CHAR is_idchar[256] =\n-{\n-  ['a'] = 1, ['b'] = 1, ['c'] = 1,  ['d'] = 1, ['e'] = 1, ['f'] = 1,\n-  ['g'] = 1, ['h'] = 1, ['i'] = 1,  ['j'] = 1, ['k'] = 1, ['l'] = 1,\n-  ['m'] = 1, ['n'] = 1, ['o'] = 1,  ['p'] = 1, ['q'] = 1, ['r'] = 1,\n-  ['s'] = 1, ['t'] = 1, ['u'] = 1,  ['v'] = 1, ['w'] = 1, ['x'] = 1,\n-  ['y'] = 1, ['z'] = 1,\n-\n-  ['A'] = 1, ['B'] = 1, ['C'] = 1,  ['D'] = 1, ['E'] = 1, ['F'] = 1,\n-  ['G'] = 1, ['H'] = 1, ['I'] = 1,  ['J'] = 1, ['K'] = 1, ['L'] = 1,\n-  ['M'] = 1, ['N'] = 1, ['O'] = 1,  ['P'] = 1, ['Q'] = 1, ['R'] = 1,\n-  ['S'] = 1, ['T'] = 1, ['U'] = 1,  ['V'] = 1, ['W'] = 1, ['X'] = 1,\n-  ['Y'] = 1, ['Z'] = 1,\n-\n-  ['1'] = 1, ['2'] = 1, ['3'] = 1,  ['4'] = 1, ['5'] = 1, ['6'] = 1,\n-  ['7'] = 1, ['8'] = 1, ['9'] = 1,  ['0'] = 1,\n-\n-  ['_']  = 1,\n-};\n+#define TABLE(id) static inline void CAT(init_, id) PARAMS ((void)) {} \\\n+unsigned char id[256] = {\n+#define s(p, v) [p] = v,\n+#define END };\n+#else\n+#define TABLE(id) unsigned char id[256] = { 0 }; \\\n+static void CAT(init_, id) PARAMS ((void)) { \\\n+unsigned char *x = id;\n+#define s(p, v) x[p] = v;\n+#define END } \n+#endif\n \n-/* Table to tell if a character is legal as the first character of\n-   a C identifier. */\n-U_CHAR is_idstart[256] =\n-{\n-  ['a'] = 1, ['b'] = 1, ['c'] = 1,  ['d'] = 1, ['e'] = 1, ['f'] = 1,\n-  ['g'] = 1, ['h'] = 1, ['i'] = 1,  ['j'] = 1, ['k'] = 1, ['l'] = 1,\n-  ['m'] = 1, ['n'] = 1, ['o'] = 1,  ['p'] = 1, ['q'] = 1, ['r'] = 1,\n-  ['s'] = 1, ['t'] = 1, ['u'] = 1,  ['v'] = 1, ['w'] = 1, ['x'] = 1,\n-  ['y'] = 1, ['z'] = 1,\n-\n-  ['A'] = 1, ['B'] = 1, ['C'] = 1,  ['D'] = 1, ['E'] = 1, ['F'] = 1,\n-  ['G'] = 1, ['H'] = 1, ['I'] = 1,  ['J'] = 1, ['K'] = 1, ['L'] = 1,\n-  ['M'] = 1, ['N'] = 1, ['O'] = 1,  ['P'] = 1, ['Q'] = 1, ['R'] = 1,\n-  ['S'] = 1, ['T'] = 1, ['U'] = 1,  ['V'] = 1, ['W'] = 1, ['X'] = 1,\n-  ['Y'] = 1, ['Z'] = 1,\n-\n-  ['_']  = 1,\n-};\n+#define A(x) s(x, ISidnum|ISidstart)\n+#define N(x) s(x, ISidnum|ISnumstart)\n+#define H(x) s(x, IShspace|ISspace)\n+#define S(x) s(x, ISspace)\n \n-/* Table to tell if a character is horizontal space.\n-   \\r is magical, so it is not in here.  */\n-U_CHAR is_hor_space[256] =\n-{\n-  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1,\n-};\n-/* table to tell if a character is horizontal or vertical space.  */\n-U_CHAR is_space[256] =\n-{\n-  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1, ['\\n'] = 1,\n-};\n-/* Table to handle trigraph conversion, which occurs before all other\n-   processing, everywhere in the file.  (This is necessary since one\n-   of the trigraphs encodes backslash.)  Note it's off by default.\n-\n-\tfrom\tto\tfrom\tto\tfrom\tto\n-\t?? =\t#\t?? )\t]\t?? !\t|\n-\t?? (\t[\t?? '\t^\t?? >\t}\n-\t?? /\t\\\t?? <\t{\t?? -\t~\n-\n-   There is not a space between the ?? and the third char.  I put spaces\n-   there to avoid warnings when compiling this file. */\n-U_CHAR trigraph_table[256] =\n-{\n-  ['='] = '#',  [')'] = ']',  ['!'] = '|',\n-  ['('] = '[',  ['\\''] = '^', ['>'] = '}',\n-  ['/'] = '\\\\', ['<'] = '{',  ['-'] = '~',\n-};\n+TABLE (IStable)\n+  A('_')\n \n-/* This function will be entirely removed soon. */\n-static inline void\n-initialize_char_syntax (dollar_in_ident)\n-     int dollar_in_ident;\n-{\n-  is_idchar['$'] = dollar_in_ident;\n-  is_idstart['$'] = dollar_in_ident;\n-}\n+  A('a') A('b') A('c') A('d') A('e') A('f') A('g') A('h') A('i')\n+  A('j') A('k') A('l') A('m') A('n') A('o') A('p') A('q') A('r')\n+  A('s') A('t') A('u') A('v') A('w') A('x') A('y') A('z')\n \n-#else /* Not GCC. */\n+  A('A') A('B') A('C') A('D') A('E') A('F') A('G') A('H') A('I')\n+  A('J') A('K') A('L') A('M') A('N') A('O') A('P') A('Q') A('R')\n+  A('S') A('T') A('U') A('V') A('W') A('X') A('Y') A('Z')\n \n-U_CHAR is_idchar[256] = { 0 };\n-U_CHAR is_idstart[256] = { 0 };\n-U_CHAR is_hor_space[256] = { 0 };\n-U_CHAR is_space[256] = { 0 };\n-U_CHAR trigraph_table[256] = { 0 };\n+  N('1') N('2') N('3') N('4') N('5') N('6') N('7') N('8') N('9') N('0')\n \n-/* Initialize syntactic classifications of characters. */\n-static void\n-initialize_char_syntax (dollar_in_ident)\n-     int dollar_in_ident;\n-{\n-  is_idstart['a'] = 1; is_idstart['b'] = 1; is_idstart['c'] = 1;\n-  is_idstart['d'] = 1; is_idstart['e'] = 1; is_idstart['f'] = 1;\n-  is_idstart['g'] = 1; is_idstart['h'] = 1; is_idstart['i'] = 1;\n-  is_idstart['j'] = 1; is_idstart['k'] = 1; is_idstart['l'] = 1;\n-  is_idstart['m'] = 1; is_idstart['n'] = 1; is_idstart['o'] = 1;\n-  is_idstart['p'] = 1; is_idstart['q'] = 1; is_idstart['r'] = 1;\n-  is_idstart['s'] = 1; is_idstart['t'] = 1; is_idstart['u'] = 1;\n-  is_idstart['v'] = 1; is_idstart['w'] = 1; is_idstart['x'] = 1;\n-  is_idstart['y'] = 1; is_idstart['z'] = 1;\n-\n-  is_idstart['A'] = 1; is_idstart['B'] = 1; is_idstart['C'] = 1;\n-  is_idstart['D'] = 1; is_idstart['E'] = 1; is_idstart['F'] = 1;\n-  is_idstart['G'] = 1; is_idstart['H'] = 1; is_idstart['I'] = 1;\n-  is_idstart['J'] = 1; is_idstart['K'] = 1; is_idstart['L'] = 1;\n-  is_idstart['M'] = 1; is_idstart['N'] = 1; is_idstart['O'] = 1;\n-  is_idstart['P'] = 1; is_idstart['Q'] = 1; is_idstart['R'] = 1;\n-  is_idstart['S'] = 1; is_idstart['T'] = 1; is_idstart['U'] = 1;\n-  is_idstart['V'] = 1; is_idstart['W'] = 1; is_idstart['X'] = 1;\n-  is_idstart['Y'] = 1; is_idstart['Z'] = 1;\n-\n-  is_idstart['_'] = 1;\n-\n-  is_idchar['a'] = 1; is_idchar['b'] = 1; is_idchar['c'] = 1;\n-  is_idchar['d'] = 1; is_idchar['e'] = 1; is_idchar['f'] = 1;\n-  is_idchar['g'] = 1; is_idchar['h'] = 1; is_idchar['i'] = 1;\n-  is_idchar['j'] = 1; is_idchar['k'] = 1; is_idchar['l'] = 1;\n-  is_idchar['m'] = 1; is_idchar['n'] = 1; is_idchar['o'] = 1;\n-  is_idchar['p'] = 1;  is_idchar['q'] = 1; is_idchar['r'] = 1;\n-  is_idchar['s'] = 1; is_idchar['t'] = 1;  is_idchar['u'] = 1;\n-  is_idchar['v'] = 1; is_idchar['w'] = 1; is_idchar['x'] = 1;\n-  is_idchar['y'] = 1; is_idchar['z'] = 1;\n-\n-  is_idchar['A'] = 1; is_idchar['B'] = 1; is_idchar['C'] = 1;\n-  is_idchar['D'] = 1; is_idchar['E'] = 1; is_idchar['F'] = 1;\n-  is_idchar['G'] = 1; is_idchar['H'] = 1; is_idchar['I'] = 1;\n-  is_idchar['J'] = 1; is_idchar['K'] = 1; is_idchar['L'] = 1;\n-  is_idchar['M'] = 1; is_idchar['N'] = 1; is_idchar['O'] = 1;\n-  is_idchar['P'] = 1; is_idchar['Q'] = 1; is_idchar['R'] = 1;\n-  is_idchar['S'] = 1; is_idchar['T'] = 1;  is_idchar['U'] = 1;\n-  is_idchar['V'] = 1; is_idchar['W'] = 1; is_idchar['X'] = 1;\n-  is_idchar['Y'] = 1; is_idchar['Z'] = 1;\n-\n-  is_idchar['1'] = 1; is_idchar['2'] = 1; is_idchar['3'] = 1;\n-  is_idchar['4'] = 1; is_idchar['5'] = 1; is_idchar['6'] = 1;\n-  is_idchar['7'] = 1; is_idchar['8'] = 1; is_idchar['9'] = 1;\n-  is_idchar['0'] = 1;\n-\n-  is_idchar['_']  = 1;\n-\n-  is_idchar['$']  = dollar_in_ident;\n-  is_idstart['$'] = dollar_in_ident;\n-\n-  /* white space tables */\n-  is_hor_space[' '] = 1;\n-  is_hor_space['\\t'] = 1;\n-  is_hor_space['\\v'] = 1;\n-  is_hor_space['\\f'] = 1;\n-\n-  is_space[' '] = 1;\n-  is_space['\\t'] = 1;\n-  is_space['\\v'] = 1;\n-  is_space['\\f'] = 1;\n-  is_space['\\n'] = 1;\n-\n-  /* trigraph conversion */\n-  trigraph_table['='] = '#';  trigraph_table[')'] = ']';\n-  trigraph_table['!'] = '|';  trigraph_table['('] = '[';\n-  trigraph_table['\\''] = '^'; trigraph_table['>'] = '}';\n-  trigraph_table['/'] = '\\\\'; trigraph_table['<'] = '{';\n-  trigraph_table['-'] = '~';\n-}\n+  H(' ') H('\\t') H('\\v') H('\\f')\n \n-#endif /* Not GCC. */\n+  S('\\n')\n+END\n+\n+#undef A\n+#undef N\n+#undef H\n+#undef S\n+#undef TABLE\n+#undef END\n+#undef s\n+#undef CAT\n \n /* Given a colon-separated list of file names PATH,\n    add all the names to the search path for include files.  */\n@@ -614,58 +496,89 @@ cpp_cleanup (pfile)\n }\n \n \n-/* Initialize the built-in macros.  */\n-static void\n-initialize_builtins (pfile)\n-     cpp_reader *pfile;\n+/* This structure defines one built-in macro.  A node of type TYPE will\n+   be entered in the macro hash table under the name NAME, with value\n+   VALUE (if any).  FLAGS tweaks the behavior a little:\n+   DUMP\t\twrite debug info for this macro\n+   STDC\t\tdefine only if not -traditional\n+   C89\t\tdefine only if -lang-c89\n+   C9X\t\tdefine only if -lang-c9x\n+   ULP\t\tvalue is the global user_label_prefix (which can't be\n+\t\tput directly into the table).\n+ */\n+\n+struct builtin\n+{\n+  const char *name;\n+  const char *value;\n+  unsigned short type;\n+  unsigned short flags;\n+};\n+#define DUMP 0x01\n+#define STDC 0x02\n+#define C89  0x04\n+#define C9X  0x08\n+#define ULP  0x10\n+\n+static const struct builtin builtin_array[] =\n {\n-#define NAME(str) (const U_CHAR *)str, sizeof str - 1\n-  cpp_install (pfile, NAME(\"__TIME__\"),\t\t  T_TIME,\t0, -1);\n-  cpp_install (pfile, NAME(\"__DATE__\"),\t\t  T_DATE,\t0, -1);\n-  cpp_install (pfile, NAME(\"__FILE__\"),\t\t  T_FILE,\t0, -1);\n-  cpp_install (pfile, NAME(\"__BASE_FILE__\"),\t  T_BASE_FILE,\t0, -1);\n-  cpp_install (pfile, NAME(\"__LINE__\"),\t\t  T_SPECLINE,\t0, -1);\n-  cpp_install (pfile, NAME(\"__INCLUDE_LEVEL__\"),  T_INCLUDE_LEVEL, 0, -1);\n-  cpp_install (pfile, NAME(\"__VERSION__\"),\t  T_VERSION,\t0, -1);\n+  { \"__TIME__\",\t\t\t0, T_TIME,\t\tDUMP },\n+  { \"__DATE__\",\t\t\t0, T_DATE,\t\tDUMP },\n+  { \"__FILE__\",\t\t\t0, T_FILE,\t\t0    },\n+  { \"__BASE_FILE__\",\t\t0, T_BASE_FILE,\t\tDUMP },\n+  { \"__LINE__\",\t\t\t0, T_SPECLINE,\t\t0    },\n+  { \"__INCLUDE_LEVEL__\",\t0, T_INCLUDE_LEVEL,\t0    },\n+  { \"__VERSION__\",\t\t0, T_VERSION,\t\tDUMP },\n+  { \"__STDC__\",\t\t\t0, T_STDC,\t\tDUMP|STDC },\n+\n+  { \"__USER_LABEL_PREFIX__\",\t0,\t\t T_CONST, ULP  },\n+  { \"__REGISTER_PREFIX__\",\tREGISTER_PREFIX, T_CONST, 0    },\n+  { \"__HAVE_BUILTIN_SETJMP__\",\t\"1\",\t\t T_CONST, 0    },\n #ifndef NO_BUILTIN_SIZE_TYPE\n-  cpp_install (pfile, NAME(\"__SIZE_TYPE__\"),\t  T_CONST, SIZE_TYPE, -1);\n+  { \"__SIZE_TYPE__\",\t\tSIZE_TYPE,\t T_CONST, DUMP },\n #endif\n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n-  cpp_install (pfile, NAME(\"__PTRDIFF_TYPE__ \"),  T_CONST, PTRDIFF_TYPE, -1);\n-#endif\n-  cpp_install (pfile, NAME(\"__WCHAR_TYPE__\"),\t  T_CONST, WCHAR_TYPE, -1);\n-  cpp_install (pfile, NAME(\"__USER_LABEL_PREFIX__\"), T_CONST, user_label_prefix, -1);\n-  cpp_install (pfile, NAME(\"__REGISTER_PREFIX__\"),  T_CONST, REGISTER_PREFIX, -1);\n-  cpp_install (pfile, NAME(\"__HAVE_BUILTIN_SETJMP__\"), T_CONST, \"1\", -1);\n-  if (!CPP_TRADITIONAL (pfile))\n-    {\n-      cpp_install (pfile, NAME(\"__STDC__\"),\t  T_STDC,  0, -1);\n-#if 0\n-      if (CPP_OPTIONS (pfile)->c9x)\n-\tcpp_install (pfile, NAME(\"__STDC_VERSION__\"),T_CONST, \"199909L\", -1);\n-      else\n+  { \"__PTRDIFF_TYPE__\",\t\tPTRDIFF_TYPE,\t T_CONST, DUMP },\n #endif\n-\tcpp_install (pfile, NAME(\"__STDC_VERSION__\"),T_CONST, \"199409L\", -1);\n-    }\n-#undef NAME\n+  { \"__WCHAR_TYPE__\",\t\tWCHAR_TYPE,\t T_CONST, DUMP },\n+  { \"__STDC_VERSION__\",\t\t\"199409L\",\t T_CONST, DUMP|STDC|C89 },\n+  { \"__STDC_VERSION__\",\t\t\"199909L\",\t T_CONST, DUMP|STDC|C9X },\n+  { 0, 0, 0, 0 }\n+};\n+\n+/* Subroutine of cpp_start_read; reads the builtins table above and\n+   enters the macros into the hash table.  */\n \n-  if (CPP_OPTIONS (pfile)->debug_output)\n+static void\n+initialize_builtins (pfile)\n+     cpp_reader *pfile;\n+{\n+  int len;\n+  const struct builtin *b;\n+  const char *val;\n+  for(b = builtin_array; b->name; b++)\n     {\n-      dump_special_to_buffer (pfile, \"__BASE_FILE__\");\n-      dump_special_to_buffer (pfile, \"__VERSION__\");\n-#ifndef NO_BUILTIN_SIZE_TYPE\n-      dump_special_to_buffer (pfile, \"__SIZE_TYPE__\");\n-#endif\n-#ifndef NO_BUILTIN_PTRDIFF_TYPE\n-      dump_special_to_buffer (pfile, \"__PTRDIFF_TYPE__\");\n-#endif\n-      dump_special_to_buffer (pfile, \"__WCHAR_TYPE__\");\n-      dump_special_to_buffer (pfile, \"__DATE__\");\n-      dump_special_to_buffer (pfile, \"__TIME__\");\n-      if (!CPP_TRADITIONAL (pfile))\n-\tdump_special_to_buffer (pfile, \"__STDC__\");\n+      if ((b->flags & STDC) && CPP_TRADITIONAL (pfile))\n+\tcontinue;\n+      if ((b->flags & C89) && CPP_OPTIONS (pfile)->c9x)\n+\tcontinue;\n+      if ((b->flags & C9X) && !CPP_OPTIONS (pfile)->c9x)\n+\tcontinue;\n+\n+      val = (b->flags & ULP) ? user_label_prefix : b->value;\n+      len = strlen (b->name);\n+\n+      cpp_install (pfile, b->name, len, b->type, val, -1);\n+      if ((b->flags & DUMP) && CPP_OPTIONS (pfile)->debug_output)\n+\tdump_special_to_buffer (pfile, b->name);\n     }\n+\n }\n+#undef DUMP\n+#undef STDC\n+#undef C89\n+#undef C9X\n+#undef ULP\n \n /* Another subroutine of cpp_start_read.  This one sets up to do\n    dependency-file output. */\n@@ -802,7 +715,11 @@ cpp_start_read (pfile, fname)\n   \n   /* Now that we know dollars_in_ident, we can initialize the syntax\n      tables. */\n-  initialize_char_syntax (opts->dollars_in_ident);\n+  init_IStable ();\n+  /* XXX Get rid of code that depends on this, then IStable can\n+     be truly const.  */\n+  if (opts->dollars_in_ident)\n+    IStable['$'] = ISidstart|ISidnum;\n \n   /* Do partial setup of input buffer for the sake of generating\n      early #line directives (when -g is in effect).  */"}, {"sha": "c3e3960c66f0d8525b62c7696874977c4a7f2564", "filename": "gcc/cpplib.c", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -25,8 +25,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-#define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n-#define SKIP_ALL_WHITE_SPACE(p) do { while (is_space[*p]) p++; } while (0)\n+#define SKIP_WHITE_SPACE(p) do { while (is_hspace(*p)) p++; } while (0)\n \n #define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) ? CPP_BUFFER (pfile)->cur[N] : EOF)\n #define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n@@ -411,7 +410,7 @@ cpp_skip_hspace (pfile)\n       c = GETC();\n       if (c == EOF)\n \treturn;\n-      else if (is_hor_space[c])\n+      else if (is_hspace(c))\n \t{\n \t  if ((c == '\\f' || c == '\\v') && CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n@@ -596,36 +595,29 @@ pass_thru_directive (buf, len, pfile, keyword)\n   CPP_PUTS_Q (pfile, buf, len);\n }\n \n-/* Check a purported macro name SYMNAME, and yield its length.\n-   ASSERTION is nonzero if this is really for an assertion name.  */\n+/* Check a purported macro name SYMNAME, and yield its length.  */\n \n int\n-check_macro_name (pfile, symname, assertion)\n+check_macro_name (pfile, symname)\n      cpp_reader *pfile;\n      const U_CHAR *symname;\n-     int assertion;\n {\n   const U_CHAR *p;\n   int sym_length;\n \n-  for (p = symname; is_idchar[*p]; p++)\n+  for (p = symname; is_idchar(*p); p++)\n     ;\n   sym_length = p - symname;\n   if (sym_length == 0\n       || (sym_length == 1 && *symname == 'L' && (*p == '\\'' || *p == '\"')))\n-    cpp_error (pfile,\n-\t       assertion ? \"invalid assertion name\" : \"invalid macro name\");\n-  else if (!is_idstart[*symname]\n+    cpp_error (pfile, \"invalid macro name\");\n+  else if (!is_idstart(*symname)\n \t   || (! strncmp (symname, \"defined\", 7) && sym_length == 7)) {\n     U_CHAR *msg;\t\t\t/* what pain...  */\n     msg = (U_CHAR *) alloca (sym_length + 1);\n     bcopy (symname, msg, sym_length);\n     msg[sym_length] = 0;\n-    cpp_error (pfile,\n-\t       (assertion\n-\t\t? \"invalid assertion name `%s'\"\n-\t\t: \"invalid macro name `%s'\"),\n-\t       msg);\n+    cpp_error (pfile, \"invalid macro name `%s'\", msg);\n   }\n   return sym_length;\n }\n@@ -1354,7 +1346,7 @@ do_line (pfile, keyword)\n       \n       if (strcmp (fname, ip->nominal_fname))\n \t{\n-\t  char *newname, *oldname;\n+\t  const char *newname, *oldname;\n \t  if (!strcmp (fname, ip->fname))\n \t    newname = ip->fname;\n \t  else if (ip->last_nominal_fname\n@@ -1370,7 +1362,7 @@ do_line (pfile, keyword)\n \t      && ip->last_nominal_fname != oldname\n \t      && ip->last_nominal_fname != newname\n \t      && ip->last_nominal_fname != ip->fname)\n-\t    free (ip->last_nominal_fname);\n+\t    free ((void *) ip->last_nominal_fname);\n \n \t  if (newname == ip->fname)\n \t    ip->last_nominal_fname = NULL;\n@@ -1415,7 +1407,7 @@ do_undef (pfile, keyword)\n \n   cpp_skip_hspace (pfile);\n   c = GETC();\n-  if (! is_idstart[c])\n+  if (! is_idstart(c))\n   {\n       cpp_error (pfile, \"token after #undef is not an identifier\");\n       skip_rest_of_line (pfile);\n@@ -1440,7 +1432,7 @@ do_undef (pfile, keyword)\n \n   CPP_SET_WRITTEN (pfile, here);\n \n-  sym_length = check_macro_name (pfile, buf, 0);\n+  sym_length = check_macro_name (pfile, buf);\n \n   while ((hp = cpp_lookup (pfile, name, sym_length, -1)) != NULL)\n     {\n@@ -1643,10 +1635,10 @@ do_pragma (pfile, keyword)\n \t{\n \t  U_CHAR *end = syms;\n \t  \n-\t  while (is_idchar[*end])\n+\t  while (is_idchar(*end))\n \t    end++;\n \n-\t  if (!is_hor_space[*end] && *end != '\\0')\n+\t  if (!is_hspace(*end) && *end != '\\0')\n \t    {\n \t      cpp_error (pfile, \"invalid #pragma poison directive\");\n \t      return 1;\n@@ -1924,7 +1916,7 @@ do_xifdef (pfile, keyword)\n       else {\n \tU_CHAR *cp = buf;\n \tfprintf (pcp_outfile, \"#undef \");\n-\twhile (is_idchar[*cp]) /* Ick! */\n+\twhile (is_idchar(*cp)) /* Ick! */\n \t  fputc (*cp++, pcp_outfile);\n \tputc ('\\n', pcp_outfile);\n       }\n@@ -2573,7 +2565,7 @@ cpp_get_token (pfile)\n \t      c = PEEKC ();\n \t      if (c == EOF)\n \t\tbreak;\n-\t      if (!is_idchar[c] && c != '.'\n+\t      if (!is_idchar(c) && c != '.'\n \t\t  && ((c2 != 'e' && c2 != 'E'\n \t\t       && ((c2 != 'p' && c2 != 'P') || CPP_C89 (pfile)))\n \t\t      || (c != '+' && c != '-')))\n@@ -2598,7 +2590,7 @@ cpp_get_token (pfile)\n \t\t  c = GETC();\n \t\t  if (c == EOF)\n \t\t    goto chill_number_eof;\n-\t\t  if (!is_idchar[c])\n+\t\t  if (!is_idchar(c))\n \t\t    break;\n \t\t  CPP_PUTC (pfile, c);\n \t\t}\n@@ -2720,7 +2712,7 @@ cpp_get_token (pfile)\n \t    {\n \t      CPP_PUTC (pfile, c);\n \t      c = PEEKC ();\n-\t      if (c == EOF || !is_hor_space[c])\n+\t      if (c == EOF || !is_hspace(c))\n \t\tbreak;\n \t      FORWARD(1);\n \t    }\n@@ -2816,7 +2808,7 @@ parse_name (pfile, c)\n {\n   for (;;)\n   {\n-      if (! is_idchar[c])\n+      if (! is_idchar(c))\n       {\n \t  FORWARD (-1);\n \t  break;\n@@ -2939,7 +2931,7 @@ parse_assertion (pfile)\n   int c, dropwhite;\n   cpp_skip_hspace (pfile);\n   c = PEEKC();\n-  if (! is_idstart[c])\n+  if (! is_idstart(c))\n     {\n       cpp_error (pfile, \"assertion predicate is not an identifier\");\n       return 0;\n@@ -2951,7 +2943,7 @@ parse_assertion (pfile)\n   c = PEEKC();\n   if (c != '(')\n     {\n-      if (is_hor_space[c] || c == '\\r')\n+      if (is_hspace(c) || c == '\\r')\n \tcpp_skip_hspace (pfile);\n       c = PEEKC();\n     }\n@@ -2963,7 +2955,7 @@ parse_assertion (pfile)\n   dropwhite = 1;\n   while ((c = GETC()) != ')')\n     {\n-      if (is_hor_space[c])\n+      if (is_space(c))\n \t{\n \t  if (! dropwhite)\n \t    {"}, {"sha": "f18a61d8ca444fe9e87fcf5161a56eb7355d9c01", "filename": "gcc/cpplib.h", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -96,11 +96,11 @@ struct cpp_buffer\n   struct cpp_buffer *prev;\n \n   /* Real filename.  (Alias to ->ihash->fname, obsolete). */\n-  char *fname;\n+  const char *fname;\n   /* Filename specified with #line command.  */\n-  char *nominal_fname;\n+  const char *nominal_fname;\n   /* Last filename specified with #line command.  */\n-  char *last_nominal_fname;\n+  const char *last_nominal_fname;\n   /* Actual directory of this file, used only for \"\" includes */\n   struct file_name_list *actual_dir;\n \n@@ -550,11 +550,12 @@ struct include_hash\n   /* Location of the file in the include search path.\n      Used for include_next */\n   struct file_name_list *foundhere;\n-  char *name;\t\t/* (partial) pathname of file */\n-  char *nshort;\t\t/* name of file as referenced in #include */\n-  const char *control_macro; /* macro, if any, preventing reinclusion - see\n-\t\t\t\tredundant_include_p */\n-  char *buf, *limit;\t/* for file content cache, not yet implemented */\n+  const char *name;\t\t/* (partial) pathname of file */\n+  const char *nshort;\t\t/* name of file as referenced in #include */\n+  const char *control_macro;\t/* macro, if any, preventing reinclusion -\n+\t\t\t\t   see redundant_include_p */\n+  char *buf, *limit;\t\t/* for file content cache,\n+\t\t\t\t   not yet implemented */\n };\n \n /* Name under which this program was invoked.  */\n@@ -610,7 +611,7 @@ typedef struct macrodef MACRODEF;\n struct macrodef\n {\n   struct definition *defn;\n-  unsigned char *symnam;\n+  const U_CHAR *symnam;\n   int symlen;\n };\n \n@@ -665,26 +666,38 @@ struct definition {\n   } args;\n };\n \n-/* These tables are not really `const', but they are only modified at\n+/* Character classes.\n+   If the definition of `numchar' looks odd to you, please look up the\n+   definition of a pp-number in the C standard [section 6.4.8 of C99] */\n+#define ISidnum\t\t0x01\t/* a-zA-Z0-9_ */\n+#define ISidstart\t0x02\t/* _a-zA-Z */\n+#define ISnumstart\t0x04\t/* 0-9 */\n+#define IShspace\t0x08\t/* ' ' \\t \\f \\v */\n+#define ISspace\t\t0x10\t/* ' ' \\t \\f \\v \\n */\n+\n+#define is_idchar(x)\t(IStable[x] & ISidnum)\n+#define is_numchar(x)\t(IStable[x] & ISidnum)\n+#define is_idstart(x)\t(IStable[x] & ISidstart)\n+#define is_numstart(x)\t(IStable[x] & ISnumstart)\n+#define is_hspace(x)\t(IStable[x] & IShspace)\n+#define is_space(x)\t(IStable[x] & ISspace)\n+\n+/* This table is not really `const', but it is only modified at\n    initialization time, in a separate translation unit from the rest\n-   of the library.  We let the rest of the library think they are `const'\n-   to get better code and some additional sanity checks.  */\n+   of the library.  We let the rest of the library think it is `const'\n+   to get better code and some additional compile-time checks.  */\n #ifndef FAKE_CONST\n #define FAKE_CONST const\n #endif\n-extern FAKE_CONST unsigned char is_idstart[256];\n-extern FAKE_CONST unsigned char is_idchar[256];\n-extern FAKE_CONST unsigned char is_hor_space[256];\n-extern FAKE_CONST unsigned char is_space[256];\n-extern FAKE_CONST unsigned char trigraph_table[256];\n+extern FAKE_CONST unsigned char IStable[256];\n #undef FAKE_CONST\n \n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n \n struct if_stack {\n   struct if_stack *next;\t/* for chaining to the next stack frame */\n-  char *fname;\t\t/* copied from input when frame is made */\n+  const char *fname;\t\t/* copied from input when frame is made */\n   int lineno;\t\t\t/* similarly */\n   int if_succeeded;\t\t/* true if a leg of this if-group\n \t\t\t\t    has been passed through rescan */\n@@ -739,7 +752,7 @@ extern void quote_string\t\tPARAMS ((cpp_reader *, const char *));\n extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t\t int));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *));\n-extern int check_macro_name\t\tPARAMS ((cpp_reader *, const U_CHAR *, int));\n+extern int check_macro_name\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n \n /* Last arg to output_line_command.  */\n enum file_change_code {same_file, enter_file, leave_file};"}, {"sha": "2e31faebfa5ad56f4d5c69d45efa06d4f600b1e6", "filename": "gcc/cppmain.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ae448346792bff101f82eceebcbe4807e85766/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=a9ae448346792bff101f82eceebcbe4807e85766", "patch": "@@ -117,6 +117,8 @@ main (argc, argv)\n       < CPP_WRITTEN (&parse_in))\n     cpp_pfatal_with_name (&parse_in, opts->out_fname);\n \n+  cpp_cleanup (&parse_in);\n+\n   if (parse_in.errors)\n     return (FATAL_EXIT_CODE);\n   return (SUCCESS_EXIT_CODE);"}]}