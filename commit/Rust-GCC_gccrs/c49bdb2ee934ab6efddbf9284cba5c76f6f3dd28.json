{"sha": "c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5YmRiMmVlOTM0YWI2ZWZkZGJmOTI4NGNiYTVjNzZmNmYzZGQyOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-16T12:38:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-16T12:38:04Z"}, "message": "gimple-fold.c (gimple_extract_devirt_binfo_from_cst): Add new arugment expected_type.\n\n\n\t* gimple-fold.c (gimple_extract_devirt_binfo_from_cst): Add new\n\tarugment expected_type.\n\t(gimple_fold_call): Use it.\n\t* gimple.h (gimple_extract_devirt_binfo_from_cst): Update prototype.\n\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Update.\n\t* ipa-prop.c (ipa_analyze_virtual_call_uses): Use\n\tobj_type_ref_class.\n\t(try_make_edge_direct_virtual_call): Likewise.\n\t* tree.c (obj_type_ref_class): New.\n\t* tree.h (obj_type_ref_class): Use it.\n\nFrom-SVN: r201789", "tree": {"sha": "71b7f3809446131bd9d0c013ed500b7b38f3350e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71b7f3809446131bd9d0c013ed500b7b38f3350e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/comments", "author": null, "committer": null, "parents": [{"sha": "4042dca916ad7f5a99438e37416d4fed2209cc6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4042dca916ad7f5a99438e37416d4fed2209cc6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4042dca916ad7f5a99438e37416d4fed2209cc6d"}], "stats": {"total": 50, "additions": 41, "deletions": 9}, "files": [{"sha": "0a77efc8a2aaf0f1ec34ccbaa47aa6c4f6c391f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -1,3 +1,16 @@\n+2013-08-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimple-fold.c (gimple_extract_devirt_binfo_from_cst): Add new\n+\tarugment expected_type.\n+\t(gimple_fold_call): Use it.\n+\t* gimple.h (gimple_extract_devirt_binfo_from_cst): Update prototype.\n+\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Update.\n+\t* ipa-prop.c (ipa_analyze_virtual_call_uses): Use\n+\tobj_type_ref_class.\n+\t(try_make_edge_direct_virtual_call): Likewise.\n+\t* tree.c (obj_type_ref_class): New.\n+\t* tree.h (obj_type_ref_class): Use it.\n+\n 2013-08-16  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* sched-vis.c (rtl_slim_pp_initialized): Remove."}, {"sha": "e9cd9aa2292d9002b8dc2f3dff2c497ba462621e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -1007,13 +1007,14 @@ gimple_fold_builtin (gimple stmt)\n    represented by a declaration (i.e. a global or automatically allocated one)\n    or NULL if it cannot be found or is not safe.  CST is expected to be an\n    ADDR_EXPR of such object or the function will return NULL.  Currently it is\n-   safe to use such binfo only if it has no base binfo (i.e. no ancestors).  */\n+   safe to use such binfo only if it has no base binfo (i.e. no ancestors)\n+   EXPECTED_TYPE is type of the class virtual belongs to.  */\n \n tree\n-gimple_extract_devirt_binfo_from_cst (tree cst)\n+gimple_extract_devirt_binfo_from_cst (tree cst, tree expected_type)\n {\n   HOST_WIDE_INT offset, size, max_size;\n-  tree base, type, expected_type, binfo;\n+  tree base, type, binfo;\n   bool last_artificial = false;\n \n   if (!flag_devirtualize\n@@ -1022,7 +1023,6 @@ gimple_extract_devirt_binfo_from_cst (tree cst)\n     return NULL_TREE;\n \n   cst = TREE_OPERAND (cst, 0);\n-  expected_type = TREE_TYPE (cst);\n   base = get_ref_base_and_extent (cst, &offset, &size, &max_size);\n   type = TREE_TYPE (base);\n   if (!DECL_P (base)\n@@ -1108,7 +1108,8 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n       else\n \t{\n \t  tree obj = OBJ_TYPE_REF_OBJECT (callee);\n-\t  tree binfo = gimple_extract_devirt_binfo_from_cst (obj);\n+\t  tree binfo = gimple_extract_devirt_binfo_from_cst\n+\t\t (obj, obj_type_ref_class (callee));\n \t  if (binfo)\n \t    {\n \t      HOST_WIDE_INT token"}, {"sha": "b039937035869dcd66fc4fb2b69508fa17917b9c", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -854,7 +854,7 @@ unsigned get_gimple_rhs_num_ops (enum tree_code);\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n-tree gimple_extract_devirt_binfo_from_cst (tree);\n+tree gimple_extract_devirt_binfo_from_cst (tree, tree);\n \n /* Returns true iff T is a scalar register variable.  */\n extern bool is_gimple_reg (tree);"}, {"sha": "312672cc49f0425d998639eeb745cd36fa1a4e22", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -1541,7 +1541,8 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   if (TREE_CODE (t) != TREE_BINFO)\n     {\n       tree binfo;\n-      binfo = gimple_extract_devirt_binfo_from_cst (t);\n+      binfo = gimple_extract_devirt_binfo_from_cst\n+\t\t (t, ie->indirect_info->otr_type);\n       if (!binfo)\n \treturn NULL_TREE;\n       binfo = get_binfo_at_offset (binfo, anc_offset, otr_type);"}, {"sha": "7cda34637b23ba59ed975c04b398db8224d9ef2d", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -1903,7 +1903,7 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n   ii = cs->indirect_info;\n   ii->offset = anc_offset;\n   ii->otr_token = tree_low_cst (OBJ_TYPE_REF_TOKEN (target), 1);\n-  ii->otr_type = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (target)));\n+  ii->otr_type = obj_type_ref_class (target);\n   ii->polymorphic = 1;\n }\n \n@@ -2453,7 +2453,8 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n   if (TREE_CODE (binfo) != TREE_BINFO)\n     {\n-      binfo = gimple_extract_devirt_binfo_from_cst (binfo);\n+      binfo = gimple_extract_devirt_binfo_from_cst\n+\t\t (binfo, ie->indirect_info->otr_type);\n       if (!binfo)\n         return NULL;\n     }"}, {"sha": "9480c7308dac3223ccb9ea8cf985b4dbb86e413f", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -11864,6 +11864,21 @@ types_same_for_odr (tree type1, tree type2)\n   return true;\n }\n \n+/* REF is OBJ_TYPE_REF, return the class the ref corresponds to.  */\n+\n+tree\n+obj_type_ref_class (tree ref)\n+{\n+  gcc_checking_assert (TREE_CODE (ref) == OBJ_TYPE_REF);\n+  ref = TREE_TYPE (ref);\n+  gcc_checking_assert (TREE_CODE (ref) == POINTER_TYPE);\n+  ref = TREE_TYPE (ref);\n+  gcc_checking_assert (TREE_CODE (ref) == METHOD_TYPE);\n+  ref = TREE_VALUE (TYPE_ARG_TYPES (ref));\n+  gcc_checking_assert (TREE_CODE (ref) == POINTER_TYPE);\n+  return TREE_TYPE (ref);\n+}\n+\n /* Try to find a base info of BINFO that would have its field decl at offset\n    OFFSET within the BINFO type and which is of EXPECTED_TYPE.  If it can be\n    found, return, otherwise return NULL_TREE.  */"}, {"sha": "c1d8d57e8d543dd721fee9be265395420aec0050", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c49bdb2ee934ab6efddbf9284cba5c76f6f3dd28", "patch": "@@ -5974,6 +5974,7 @@ extern location_t tree_nonartificial_location (tree);\n extern tree block_ultimate_origin (const_tree);\n \n extern tree get_binfo_at_offset (tree, HOST_WIDE_INT, tree);\n+extern tree obj_type_ref_class (tree ref);\n extern bool types_same_for_odr (tree type1, tree type2);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);"}]}