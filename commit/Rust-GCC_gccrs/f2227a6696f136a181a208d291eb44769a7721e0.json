{"sha": "f2227a6696f136a181a208d291eb44769a7721e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyMjdhNjY5NmYxMzZhMTgxYTIwOGQyOTFlYjQ0NzY5YTc3MjFlMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-06-25T11:02:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-06-25T11:02:10Z"}, "message": "tree-vect-data-refs.c (vect_find_stmt_data_reference): Modify DR for SIMD lane accesses here and mark DR with (void *)-1 aux.\n\n2018-06-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Modify\n\tDR for SIMD lane accesses here and mark DR with (void *)-1 aux.\n\t(vect_analyze_data_refs): Remove similar code from here and\n\tsimplify accordingly.\n\nFrom-SVN: r262008", "tree": {"sha": "3809125d886f3d5045718e6f630611a142b77b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3809125d886f3d5045718e6f630611a142b77b8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2227a6696f136a181a208d291eb44769a7721e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2227a6696f136a181a208d291eb44769a7721e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2227a6696f136a181a208d291eb44769a7721e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2227a6696f136a181a208d291eb44769a7721e0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c9632905d39afc3c431d0ff4d318d15c9250344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c9632905d39afc3c431d0ff4d318d15c9250344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c9632905d39afc3c431d0ff4d318d15c9250344"}], "stats": {"total": 172, "additions": 92, "deletions": 80}, "files": [{"sha": "e01728cda35f5c7f8e3a31eb07539359516becc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2227a6696f136a181a208d291eb44769a7721e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2227a6696f136a181a208d291eb44769a7721e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2227a6696f136a181a208d291eb44769a7721e0", "patch": "@@ -1,3 +1,10 @@\n+2018-06-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Modify\n+\tDR for SIMD lane accesses here and mark DR with (void *)-1 aux.\n+\t(vect_analyze_data_refs): Remove similar code from here and\n+\tsimplify accordingly.\n+\n 2018-06-25  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_check_gather_scatter): Fail"}, {"sha": "db5232e7c5af000eeb00ba75ee809066d98deb7a", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 85, "deletions": 80, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2227a6696f136a181a208d291eb44769a7721e0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2227a6696f136a181a208d291eb44769a7721e0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f2227a6696f136a181a208d291eb44769a7721e0", "patch": "@@ -4032,6 +4032,70 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n       return false;\n     }\n \n+  /* Check whether this may be a SIMD lane access and adjust the\n+     DR to make it easier for us to handle it.  */\n+  if (loop\n+      && loop->simduid\n+      && (!DR_BASE_ADDRESS (dr)\n+\t  || !DR_OFFSET (dr)\n+\t  || !DR_INIT (dr)\n+\t  || !DR_STEP (dr)))\n+    {\n+      struct data_reference *newdr\n+\t= create_data_ref (NULL, loop_containing_stmt (stmt), DR_REF (dr), stmt,\n+\t\t\t   DR_IS_READ (dr), DR_IS_CONDITIONAL_IN_STMT (dr));\n+      if (DR_BASE_ADDRESS (newdr)\n+\t  && DR_OFFSET (newdr)\n+\t  && DR_INIT (newdr)\n+\t  && DR_STEP (newdr)\n+\t  && integer_zerop (DR_STEP (newdr)))\n+\t{\n+\t  tree off = DR_OFFSET (newdr);\n+\t  STRIP_NOPS (off);\n+\t  if (TREE_CODE (DR_INIT (newdr)) == INTEGER_CST\n+\t      && TREE_CODE (off) == MULT_EXPR\n+\t      && tree_fits_uhwi_p (TREE_OPERAND (off, 1)))\n+\t    {\n+\t      tree step = TREE_OPERAND (off, 1);\n+\t      off = TREE_OPERAND (off, 0);\n+\t      STRIP_NOPS (off);\n+\t      if (CONVERT_EXPR_P (off)\n+\t\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (off, 0)))\n+\t\t      < TYPE_PRECISION (TREE_TYPE (off))))\n+\t\toff = TREE_OPERAND (off, 0);\n+\t      if (TREE_CODE (off) == SSA_NAME)\n+\t\t{\n+\t\t  gimple *def = SSA_NAME_DEF_STMT (off);\n+\t\t  tree reft = TREE_TYPE (DR_REF (newdr));\n+\t\t  if (is_gimple_call (def)\n+\t\t      && gimple_call_internal_p (def)\n+\t\t      && (gimple_call_internal_fn (def) == IFN_GOMP_SIMD_LANE))\n+\t\t    {\n+\t\t      tree arg = gimple_call_arg (def, 0);\n+\t\t      gcc_assert (TREE_CODE (arg) == SSA_NAME);\n+\t\t      arg = SSA_NAME_VAR (arg);\n+\t\t      if (arg == loop->simduid\n+\t\t\t  /* For now.  */\n+\t\t\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (reft), step))\n+\t\t\t{\n+\t\t\t  DR_OFFSET (newdr) = ssize_int (0);\n+\t\t\t  DR_STEP (newdr) = step;\n+\t\t\t  DR_OFFSET_ALIGNMENT (newdr) = BIGGEST_ALIGNMENT;\n+\t\t\t  DR_STEP_ALIGNMENT (newdr)\n+\t\t\t    = highest_pow2_factor (step);\n+\t\t\t  /* Mark as simd-lane access.  */\n+\t\t\t  newdr->aux = (void *)-1;\n+\t\t\t  free_data_ref (dr);\n+\t\t\t  datarefs->safe_push (newdr);\n+\t\t\t  return true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free_data_ref (newdr);\n+    }\n+\n   datarefs->safe_push (dr);\n   return true;\n }\n@@ -4073,7 +4137,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n       gimple *stmt;\n       stmt_vec_info stmt_info;\n       enum { SG_NONE, GATHER, SCATTER } gatherscatter = SG_NONE;\n-      bool simd_lane_access = false;\n       poly_uint64 vf;\n \n       gcc_assert (DR_REF (dr));\n@@ -4094,76 +4157,13 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n \t      && (targetm.vectorize.builtin_scatter != NULL\n \t\t  || supports_vec_scatter_store_p ());\n-\t  bool maybe_simd_lane_access\n-\t    = is_a <loop_vec_info> (vinfo) && loop->simduid;\n \n-\t  /* If target supports vector gather loads or scatter stores, or if\n-\t     this might be a SIMD lane access, see if they can't be used.  */\n+\t  /* If target supports vector gather loads or scatter stores,\n+\t     see if they can't be used.  */\n \t  if (is_a <loop_vec_info> (vinfo)\n \t      && !nested_in_vect_loop_p (loop, stmt))\n \t    {\n-\t      if (maybe_simd_lane_access)\n-\t\t{\n-\t\t  struct data_reference *newdr\n-\t\t    = create_data_ref (NULL, loop_containing_stmt (stmt),\n-\t\t\t\t       DR_REF (dr), stmt, !maybe_scatter,\n-\t\t\t\t       DR_IS_CONDITIONAL_IN_STMT (dr));\n-\t\t  gcc_assert (newdr != NULL && DR_REF (newdr));\n-\t\t  if (DR_BASE_ADDRESS (newdr)\n-\t\t      && DR_OFFSET (newdr)\n-\t\t      && DR_INIT (newdr)\n-\t\t      && DR_STEP (newdr)\n-\t\t      && integer_zerop (DR_STEP (newdr)))\n-\t\t    {\n-\t\t      tree off = DR_OFFSET (newdr);\n-\t\t      STRIP_NOPS (off);\n-\t\t      if (TREE_CODE (DR_INIT (newdr)) == INTEGER_CST\n-\t\t\t  && TREE_CODE (off) == MULT_EXPR\n-\t\t\t  && tree_fits_uhwi_p (TREE_OPERAND (off, 1)))\n-\t\t\t{\n-\t\t\t  tree step = TREE_OPERAND (off, 1);\n-\t\t\t  off = TREE_OPERAND (off, 0);\n-\t\t\t  STRIP_NOPS (off);\n-\t\t\t  if (CONVERT_EXPR_P (off)\n-\t\t\t      && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (off,\n-\t\t\t\t\t\t\t\t\t  0)))\n-\t\t\t      < TYPE_PRECISION (TREE_TYPE (off)))\n-\t\t\t    off = TREE_OPERAND (off, 0);\n-\t\t\t  if (TREE_CODE (off) == SSA_NAME)\n-\t\t\t    {\n-\t\t\t      gimple *def = SSA_NAME_DEF_STMT (off);\n-\t\t\t      tree reft = TREE_TYPE (DR_REF (newdr));\n-\t\t\t      if (is_gimple_call (def)\n-\t\t\t\t  && gimple_call_internal_p (def)\n-\t\t\t\t  && (gimple_call_internal_fn (def)\n-\t\t\t\t      == IFN_GOMP_SIMD_LANE))\n-\t\t\t\t{\n-\t\t\t\t  tree arg = gimple_call_arg (def, 0);\n-\t\t\t\t  gcc_assert (TREE_CODE (arg) == SSA_NAME);\n-\t\t\t\t  arg = SSA_NAME_VAR (arg);\n-\t\t\t\t  if (arg == loop->simduid\n-\t\t\t\t      /* For now.  */\n-\t\t\t\t      && tree_int_cst_equal\n-\t\t\t\t      (TYPE_SIZE_UNIT (reft),\n-\t\t\t\t       step))\n-\t\t\t\t    {\n-\t\t\t\t      DR_OFFSET (newdr) = ssize_int (0);\n-\t\t\t\t      DR_STEP (newdr) = step;\n-\t\t\t\t      DR_OFFSET_ALIGNMENT (newdr)\n-\t\t\t\t\t  = BIGGEST_ALIGNMENT;\n-\t\t\t\t      DR_STEP_ALIGNMENT (newdr)\n-\t\t\t\t\t  = highest_pow2_factor (step);\n-\t\t\t\t      dr = newdr;\n-\t\t\t\t      simd_lane_access = true;\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  if (!simd_lane_access)\n-\t\t    free_data_ref (newdr);\n-\t\t}\n-\t      if (!simd_lane_access && (maybe_gather || maybe_scatter))\n+\t      if (maybe_gather || maybe_scatter)\n \t\t{\n \t\t  if (maybe_gather)\n \t\t    gatherscatter = GATHER;\n@@ -4172,7 +4172,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t\t}\n \t    }\n \n-\t  if (gatherscatter == SG_NONE && !simd_lane_access)\n+\t  if (gatherscatter == SG_NONE)\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -4192,6 +4192,23 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t    }\n         }\n \n+      /* See if this was detected as SIMD lane access.  */\n+      if (dr->aux == (void *)-1)\n+\t{\n+\t  if (nested_in_vect_loop_p (loop, stmt))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"not vectorized: data ref analysis \"\n+\t\t\t\t   \"failed \");\n+\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) = true;\n+\t}\n+\n       tree base = get_base_address (DR_REF (dr));\n       if (base && VAR_P (base) && DECL_NONALIASED (base))\n \t{\n@@ -4294,12 +4311,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \n       gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n       STMT_VINFO_DATA_REF (stmt_info) = dr;\n-      if (simd_lane_access)\n-\t{\n-\t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) = true;\n-\t  free_data_ref (datarefs[i]);\n-\t  datarefs[i] = dr;\n-\t}\n \n       /* Set vectype for STMT.  */\n       scalar_type = TREE_TYPE (DR_REF (dr));\n@@ -4325,12 +4336,6 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n \t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n \t      continue;\n \t    }\n-\n-\t  if (simd_lane_access)\n-\t    {\n-\t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n-\t      free_data_ref (dr);\n-\t    }\n \t  return false;\n         }\n       else"}]}