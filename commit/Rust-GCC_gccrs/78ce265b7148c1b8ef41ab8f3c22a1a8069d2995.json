{"sha": "78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjZTI2NWI3MTQ4YzFiOGVmNDFhYjhmM2MyMmExYTgwNjlkMjk5NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-08-07T17:32:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-08-07T17:32:19Z"}, "message": "s390: Convert from sync to atomic optabs\n\n        * config/s390/s390.c (s390_emit_compare_and_swap): Update for\n        atomic_compare_and_swapsi_internal name change.\n        (s390_expand_insv): Try RISBG last, not requiring operands in\n        registers but forcing them there.  Try a limited form of ICM.\n        (s390_two_part_insv): New.\n        (s390_expand_cs_hqi): Use it.  Update for atomic optabs.\n        * config/s390/s390.md (UNSPEC_MOVA): New.\n        (TDSI): Remove mode iterator.\n        (DGPR, DINT, TDI): New mode iterators.\n        (td): New mode attribute.\n        (mem_signal_fence): New.\n        (mem_thread_fence): Rename from memory_barrier; update for model arg.\n        (mem_thread_fence_1): Rename from *memory_barrier.\n        (atomic_load<DINT>, atomic_store<DINT>): New expanders.\n        (atomic_loaddi_1, atomic_loadti_1): New.\n        (atomic_storedi_1, atomic_storeti_1): New.\n        (sync_compare_and_swap<TDSI>, sync_compare_and_swap<HQI>): Remove.\n        (atomic_compare_and_swap<DGPR>, atomic_compare_and_swap<HQI>): New.\n        (atomic_compare_and_swap<DGPR>_internal): New.\n        (*sync_compare_and_swap<DW>, *sync_compare_and_swap<GPR>): Remove.\n        (*atomic_compare_and_swap<TDI>_1): New.\n        (*atomic_compare_and_swapdi_2, *atomic_compare_and_swapsi_3): New.\n        (sync_<ATOMIC_Z196><GPR>, sync_old_<ATOMIC_Z196><GPR>): Remove.\n        (atomic_fetch_<ATOMIC_Z196><GPR>): New.\n        (atomic_fetch_<ATOMC_Z196><GPR>_iaf): New.\n        (sync_<ATOMIC><HQI>, sync_old_<ATOMIC><HQI>): Remove.\n        (sync_new_<ATOMIC><HQI>): Remove.\n        (atomic_<ATOMIC><HQI>, atomic_fetch_<ATOMIC><HQI>): New.\n        (atomic_<ATOMIC>_fetch<HQI>): New.\n        (sync_lock_test_and_set<HQI>): Remove.\n        (atomic_exchange<HQI>): New.\n\nFrom-SVN: r190209", "tree": {"sha": "636e0b6367be34ec676ef92427e342d845c8bd67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/636e0b6367be34ec676ef92427e342d845c8bd67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/comments", "author": null, "committer": null, "parents": [{"sha": "3e6011cfebedfb66b92c87e6d2add9237188819e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6011cfebedfb66b92c87e6d2add9237188819e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e6011cfebedfb66b92c87e6d2add9237188819e"}], "stats": {"total": 728, "additions": 505, "deletions": 223}, "files": [{"sha": "bdf47c73ad70ea5056230d75b07f219f16e01b79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "patch": "@@ -1,3 +1,37 @@\n+2012-08-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/s390/s390.c (s390_emit_compare_and_swap): Update for\n+\tatomic_compare_and_swapsi_internal name change.\n+\t(s390_expand_insv): Try RISBG last, not requiring operands in\n+\tregisters but forcing them there.  Try a limited form of ICM.\n+\t(s390_two_part_insv): New.\n+\t(s390_expand_cs_hqi): Use it.  Update for atomic optabs.\n+\t* config/s390/s390.md (UNSPEC_MOVA): New.\n+\t(TDSI): Remove mode iterator.\n+\t(DGPR, DINT, TDI): New mode iterators.\n+\t(td): New mode attribute.\n+\t(mem_signal_fence): New.\n+\t(mem_thread_fence): Rename from memory_barrier; update for model arg.\n+\t(mem_thread_fence_1): Rename from *memory_barrier.\n+\t(atomic_load<DINT>, atomic_store<DINT>): New expanders.\n+\t(atomic_loaddi_1, atomic_loadti_1): New.\n+\t(atomic_storedi_1, atomic_storeti_1): New.\n+\t(sync_compare_and_swap<TDSI>, sync_compare_and_swap<HQI>): Remove.\n+\t(atomic_compare_and_swap<DGPR>, atomic_compare_and_swap<HQI>): New.\n+\t(atomic_compare_and_swap<DGPR>_internal): New.\n+\t(*sync_compare_and_swap<DW>, *sync_compare_and_swap<GPR>): Remove.\n+\t(*atomic_compare_and_swap<TDI>_1): New.\n+\t(*atomic_compare_and_swapdi_2, *atomic_compare_and_swapsi_3): New.\n+\t(sync_<ATOMIC_Z196><GPR>, sync_old_<ATOMIC_Z196><GPR>): Remove.\n+\t(atomic_fetch_<ATOMIC_Z196><GPR>): New.\n+\t(atomic_fetch_<ATOMC_Z196><GPR>_iaf): New.\n+\t(sync_<ATOMIC><HQI>, sync_old_<ATOMIC><HQI>): Remove.\n+\t(sync_new_<ATOMIC><HQI>): Remove.\n+\t(atomic_<ATOMIC><HQI>, atomic_fetch_<ATOMIC><HQI>): New.\n+\t(atomic_<ATOMIC>_fetch<HQI>): New.\n+\t(sync_lock_test_and_set<HQI>): Remove.\n+\t(atomic_exchange<HQI>): New.\n+\n 2012-08-07  Paul Brook  <paul@codesourcery.com>\n \t    Sandra Loosemore  <sandra@codesourcery.com>\n "}, {"sha": "79673d6d835e855d4fe253f83233f5b302e504cf", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "patch": "@@ -85,7 +85,8 @@ extern void s390_expand_setmem (rtx, rtx, rtx);\n extern bool s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n-extern void s390_expand_cs_hqi (enum machine_mode, rtx, rtx, rtx, rtx);\n+extern void s390_expand_cs_hqi (enum machine_mode, rtx, rtx, rtx,\n+\t\t\t\trtx, rtx, bool);\n extern void s390_expand_atomic (enum machine_mode, enum rtx_code,\n \t\t\t\trtx, rtx, rtx, bool);\n extern rtx s390_return_addr_rtx (int, rtx);"}, {"sha": "20a2db66042b13830fe8ee3993ec5aec58d3cf11", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 193, "deletions": 109, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "patch": "@@ -896,10 +896,12 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n    conditional branch testing the result.  */\n \n static rtx\n-s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem, rtx cmp, rtx new_rtx)\n+s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem,\n+\t\t\t    rtx cmp, rtx new_rtx)\n {\n-  emit_insn (gen_sync_compare_and_swapsi (old, mem, cmp, new_rtx));\n-  return s390_emit_compare (code, gen_rtx_REG (CCZ1mode, CC_REGNUM), const0_rtx);\n+  emit_insn (gen_atomic_compare_and_swapsi_internal (old, mem, cmp, new_rtx));\n+  return s390_emit_compare (code, gen_rtx_REG (CCZ1mode, CC_REGNUM),\n+\t\t\t    const0_rtx);\n }\n \n /* Emit a jump instruction to TARGET.  If COND is NULL_RTX, emit an\n@@ -4548,106 +4550,146 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n {\n   int bitsize = INTVAL (op1);\n   int bitpos = INTVAL (op2);\n+  enum machine_mode mode = GET_MODE (dest);\n+  enum machine_mode smode;\n+  int smode_bsize, mode_bsize;\n+  rtx op, clobber;\n \n-  /* On z10 we can use the risbg instruction to implement insv.  */\n-  if (TARGET_Z10\n-      && ((GET_MODE (dest) == DImode && GET_MODE (src) == DImode)\n-\t  || (GET_MODE (dest) == SImode && GET_MODE (src) == SImode)))\n+  /* Generate INSERT IMMEDIATE (IILL et al).  */\n+  /* (set (ze (reg)) (const_int)).  */\n+  if (TARGET_ZARCH\n+      && register_operand (dest, word_mode)\n+      && (bitpos % 16) == 0\n+      && (bitsize % 16) == 0\n+      && const_int_operand (src, VOIDmode))\n     {\n-      rtx op;\n-      rtx clobber;\n+      HOST_WIDE_INT val = INTVAL (src);\n+      int regpos = bitpos + bitsize;\n \n-      op = gen_rtx_SET (GET_MODE(src),\n-\t\t\tgen_rtx_ZERO_EXTRACT (GET_MODE (dest), dest, op1, op2),\n-\t\t\tsrc);\n-      clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n-      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clobber)));\n+      while (regpos > bitpos)\n+\t{\n+\t  enum machine_mode putmode;\n+\t  int putsize;\n \n+\t  if (TARGET_EXTIMM && (regpos % 32 == 0) && (regpos >= bitpos + 32))\n+\t    putmode = SImode;\n+\t  else\n+\t    putmode = HImode;\n+\n+\t  putsize = GET_MODE_BITSIZE (putmode);\n+\t  regpos -= putsize;\n+\t  emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest,\n+\t\t\t\t\t\tGEN_INT (putsize),\n+\t\t\t\t\t\tGEN_INT (regpos)),\n+\t\t\t  gen_int_mode (val, putmode));\n+\t  val >>= putsize;\n+\t}\n+      gcc_assert (regpos == bitpos);\n       return true;\n     }\n \n-  /* We need byte alignment.  */\n-  if (bitsize % BITS_PER_UNIT)\n-    return false;\n+  smode = smallest_mode_for_size (bitsize, MODE_INT);\n+  smode_bsize = GET_MODE_BITSIZE (smode);\n+  mode_bsize = GET_MODE_BITSIZE (mode);\n \n+  /* Generate STORE CHARACTERS UNDER MASK (STCM et al).  */\n   if (bitpos == 0\n-      && memory_operand (dest, VOIDmode)\n+      && (bitsize % BITS_PER_UNIT) == 0\n+      && MEM_P (dest)\n       && (register_operand (src, word_mode)\n \t  || const_int_operand (src, VOIDmode)))\n     {\n       /* Emit standard pattern if possible.  */\n-      enum machine_mode mode = smallest_mode_for_size (bitsize, MODE_INT);\n-      if (GET_MODE_BITSIZE (mode) == bitsize)\n-\temit_move_insn (adjust_address (dest, mode, 0), gen_lowpart (mode, src));\n+      if (smode_bsize == bitsize)\n+\t{\n+\t  emit_move_insn (adjust_address (dest, smode, 0),\n+\t\t\t  gen_lowpart (smode, src));\n+\t  return true;\n+\t}\n \n       /* (set (ze (mem)) (const_int)).  */\n       else if (const_int_operand (src, VOIDmode))\n \t{\n \t  int size = bitsize / BITS_PER_UNIT;\n-\t  rtx src_mem = adjust_address (force_const_mem (word_mode, src), BLKmode,\n-\t\t\t\t\tGET_MODE_SIZE (word_mode) - size);\n+\t  rtx src_mem = adjust_address (force_const_mem (word_mode, src),\n+\t\t\t\t\tBLKmode,\n+\t\t\t\t\tUNITS_PER_WORD - size);\n \n \t  dest = adjust_address (dest, BLKmode, 0);\n \t  set_mem_size (dest, size);\n \t  s390_expand_movmem (dest, src_mem, GEN_INT (size));\n+\t  return true;\n \t}\n \n       /* (set (ze (mem)) (reg)).  */\n       else if (register_operand (src, word_mode))\n \t{\n-\t  if (bitsize <= GET_MODE_BITSIZE (SImode))\n+\t  if (bitsize <= 32)\n \t    emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, op1,\n \t\t\t\t\t\t  const0_rtx), src);\n \t  else\n \t    {\n \t      /* Emit st,stcmh sequence.  */\n-\t      int stcmh_width = bitsize - GET_MODE_BITSIZE (SImode);\n+\t      int stcmh_width = bitsize - 32;\n \t      int size = stcmh_width / BITS_PER_UNIT;\n \n \t      emit_move_insn (adjust_address (dest, SImode, size),\n \t\t\t      gen_lowpart (SImode, src));\n \t      set_mem_size (dest, size);\n-\t      emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, GEN_INT\n-\t\t\t\t\t\t    (stcmh_width), const0_rtx),\n-\t\t\t      gen_rtx_LSHIFTRT (word_mode, src, GEN_INT\n-\t\t\t\t\t\t(GET_MODE_BITSIZE (SImode))));\n+\t      emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest,\n+\t\t\t\t\t\t    GEN_INT (stcmh_width),\n+\t\t\t\t\t\t    const0_rtx),\n+\t\t\t      gen_rtx_LSHIFTRT (word_mode, src, GEN_INT (32)));\n \t    }\n+\t  return true;\n \t}\n-      else\n-\treturn false;\n+    }\n \n-      return true;\n+  /* Generate INSERT CHARACTERS UNDER MASK (IC, ICM et al).  */\n+  if ((bitpos % BITS_PER_UNIT) == 0\n+      && (bitsize % BITS_PER_UNIT) == 0\n+      && (bitpos & 32) == ((bitpos + bitsize - 1) & 32)\n+      && MEM_P (src)\n+      && (mode == DImode || mode == SImode)\n+      && register_operand (dest, mode))\n+    {\n+      /* Emit a strict_low_part pattern if possible.  */\n+      if (smode_bsize == bitsize && bitpos == mode_bsize - smode_bsize)\n+\t{\n+\t  op = gen_rtx_STRICT_LOW_PART (VOIDmode, gen_lowpart (smode, dest));\n+\t  op = gen_rtx_SET (VOIDmode, op, gen_lowpart (smode, src));\n+\t  clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n+\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clobber)));\n+\t  return true;\n+\t}\n+\n+      /* ??? There are more powerful versions of ICM that are not\n+\t completely represented in the md file.  */\n     }\n \n-  /* (set (ze (reg)) (const_int)).  */\n-  if (TARGET_ZARCH\n-      && register_operand (dest, word_mode)\n-      && (bitpos % 16) == 0\n-      && (bitsize % 16) == 0\n-      && const_int_operand (src, VOIDmode))\n+  /* For z10, generate ROTATE THEN INSERT SELECTED BITS (RISBG et al).  */\n+  if (TARGET_Z10 && (mode == DImode || mode == SImode))\n     {\n-      HOST_WIDE_INT val = INTVAL (src);\n-      int regpos = bitpos + bitsize;\n+      enum machine_mode mode_s = GET_MODE (src);\n \n-      while (regpos > bitpos)\n+      if (mode_s == VOIDmode)\n \t{\n-\t  enum machine_mode putmode;\n-\t  int putsize;\n+\t  /* Assume const_int etc already in the proper mode.  */\n+\t  src = force_reg (mode, src);\n+\t}\n+      else if (mode_s != mode)\n+\t{\n+\t  gcc_assert (GET_MODE_BITSIZE (mode_s) >= bitsize);\n+\t  src = force_reg (mode_s, src);\n+\t  src = gen_lowpart (mode, src);\n+\t}\n \n-\t  if (TARGET_EXTIMM && (regpos % 32 == 0) && (regpos >= bitpos + 32))\n-\t    putmode = SImode;\n-\t  else\n-\t    putmode = HImode;\n+      op = gen_rtx_SET (mode,\n+\t\t\tgen_rtx_ZERO_EXTRACT (mode, dest, op1, op2),\n+\t\t\tsrc);\n+      clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clobber)));\n \n-\t  putsize = GET_MODE_BITSIZE (putmode);\n-\t  regpos -= putsize;\n-\t  emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest,\n-\t\t\t\t\t\tGEN_INT (putsize),\n-\t\t\t\t\t\tGEN_INT (regpos)),\n-\t\t\t  gen_int_mode (val, putmode));\n-\t  val >>= putsize;\n-\t}\n-      gcc_assert (regpos == bitpos);\n       return true;\n     }\n \n@@ -4717,92 +4759,134 @@ init_alignment_context (struct alignment_context *ac, rtx mem,\n       /* As we already have some offset, evaluate the remaining distance.  */\n       ac->shift = expand_simple_binop (SImode, MINUS, ac->shift, byteoffset,\n \t\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n-\n     }\n+\n   /* Shift is the byte count, but we need the bitcount.  */\n-  ac->shift = expand_simple_binop (SImode, MULT, ac->shift, GEN_INT (BITS_PER_UNIT),\n-\t\t\t\t  NULL_RTX, 1, OPTAB_DIRECT);\n+  ac->shift = expand_simple_binop (SImode, ASHIFT, ac->shift, GEN_INT (3),\n+\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n+\n   /* Calculate masks.  */\n   ac->modemask = expand_simple_binop (SImode, ASHIFT,\n-\t\t\t\t     GEN_INT (GET_MODE_MASK (mode)), ac->shift,\n-\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n-  ac->modemaski = expand_simple_unop (SImode, NOT, ac->modemask, NULL_RTX, 1);\n+\t\t\t\t      GEN_INT (GET_MODE_MASK (mode)),\n+\t\t\t\t      ac->shift, NULL_RTX, 1, OPTAB_DIRECT);\n+  ac->modemaski = expand_simple_unop (SImode, NOT, ac->modemask,\n+\t\t\t\t      NULL_RTX, 1);\n+}\n+\n+/* A subroutine of s390_expand_cs_hqi.  Insert INS into VAL.  If possible,\n+   use a single insv insn into SEQ2.  Otherwise, put prep insns in SEQ1 and\n+   perform the merge in SEQ2.  */\n+\n+static rtx\n+s390_two_part_insv (struct alignment_context *ac, rtx *seq1, rtx *seq2,\n+\t\t    enum machine_mode mode, rtx val, rtx ins)\n+{\n+  rtx tmp;\n+\n+  if (ac->aligned)\n+    {\n+      start_sequence ();\n+      tmp = copy_to_mode_reg (SImode, val);\n+      if (s390_expand_insv (tmp, GEN_INT (GET_MODE_BITSIZE (mode)),\n+\t\t\t    const0_rtx, ins))\n+\t{\n+\t  *seq1 = NULL;\n+\t  *seq2 = get_insns ();\n+\t  end_sequence ();\n+\t  return tmp;\n+\t}\n+      end_sequence ();\n+    }\n+\n+  /* Failed to use insv.  Generate a two part shift and mask.  */\n+  start_sequence ();\n+  tmp = s390_expand_mask_and_shift (ins, mode, ac->shift);\n+  *seq1 = get_insns ();\n+  end_sequence ();\n+\n+  start_sequence ();\n+  tmp = expand_simple_binop (SImode, IOR, tmp, val, NULL_RTX, 1, OPTAB_DIRECT);\n+  *seq2 = get_insns ();\n+  end_sequence ();\n+\n+  return tmp;\n }\n \n /* Expand an atomic compare and swap operation for HImode and QImode.  MEM is\n-   the memory location, CMP the old value to compare MEM with and NEW_RTX the value\n-   to set if CMP == MEM.\n-   CMP is never in memory for compare_and_swap_cc because\n-   expand_bool_compare_and_swap puts it into a register for later compare.  */\n+   the memory location, CMP the old value to compare MEM with and NEW_RTX the\n+   value to set if CMP == MEM.  */\n \n void\n-s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx new_rtx)\n+s390_expand_cs_hqi (enum machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n+\t\t    rtx cmp, rtx new_rtx, bool is_weak)\n {\n   struct alignment_context ac;\n-  rtx cmpv, newv, val, resv, cc;\n+  rtx cmpv, newv, val, resv, cc, seq0, seq1, seq2, seq3;\n   rtx res = gen_reg_rtx (SImode);\n-  rtx csloop = gen_label_rtx ();\n-  rtx csend = gen_label_rtx ();\n+  rtx csloop = NULL, csend = NULL;\n \n-  gcc_assert (register_operand (target, VOIDmode));\n+  gcc_assert (register_operand (vtarget, VOIDmode));\n   gcc_assert (MEM_P (mem));\n \n   init_alignment_context (&ac, mem, mode);\n \n-  /* Shift the values to the correct bit positions.  */\n-  if (!(ac.aligned && MEM_P (cmp)))\n-    cmp = s390_expand_mask_and_shift (cmp, mode, ac.shift);\n-  if (!(ac.aligned && MEM_P (new_rtx)))\n-    new_rtx = s390_expand_mask_and_shift (new_rtx, mode, ac.shift);\n-\n   /* Load full word.  Subsequent loads are performed by CS.  */\n   val = expand_simple_binop (SImode, AND, ac.memsi, ac.modemaski,\n \t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n \n+  /* Prepare insertions of cmp and new_rtx into the loaded value.  When\n+     possible, we try to use insv to make this happen efficiently.  If\n+     that fails we'll generate code both inside and outside the loop.  */\n+  cmpv = s390_two_part_insv (&ac, &seq0, &seq2, mode, val, cmp);\n+  newv = s390_two_part_insv (&ac, &seq1, &seq3, mode, val, new_rtx);\n+\n+  if (seq0)\n+    emit_insn (seq0);\n+  if (seq1)\n+    emit_insn (seq1);\n+\n   /* Start CS loop.  */\n-  emit_label (csloop);\n+  if (!is_weak)\n+    {\n+      /* Begin assuming success.  */\n+      emit_move_insn (btarget, const1_rtx);\n+\n+      csloop = gen_label_rtx ();\n+      csend = gen_label_rtx ();\n+      emit_label (csloop);\n+    }\n+\n   /* val = \"<mem>00..0<mem>\"\n    * cmp = \"00..0<cmp>00..0\"\n    * new = \"00..0<new>00..0\"\n    */\n \n-  /* Patch cmp and new with val at correct position.  */\n-  if (ac.aligned && MEM_P (cmp))\n-    {\n-      cmpv = force_reg (SImode, val);\n-      store_bit_field (cmpv, GET_MODE_BITSIZE (mode), 0,\n-\t\t       0, 0, SImode, cmp);\n-    }\n+  emit_insn (seq2);\n+  emit_insn (seq3);\n+\n+  cc = s390_emit_compare_and_swap (EQ, res, ac.memsi, cmpv, newv);\n+  if (is_weak)\n+    emit_insn (gen_cstorecc4 (btarget, cc, XEXP (cc, 0), XEXP (cc, 1)));\n   else\n-    cmpv = force_reg (SImode, expand_simple_binop (SImode, IOR, cmp, val,\n-\t\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n-  if (ac.aligned && MEM_P (new_rtx))\n     {\n-      newv = force_reg (SImode, val);\n-      store_bit_field (newv, GET_MODE_BITSIZE (mode), 0,\n-\t\t       0, 0, SImode, new_rtx);\n-    }\n-  else\n-    newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new_rtx, val,\n-\t\t\t\t\t\t   NULL_RTX, 1, OPTAB_DIRECT));\n+      /* Jump to end if we're done (likely?).  */\n+      s390_emit_jump (csend, cc);\n \n-  /* Jump to end if we're done (likely?).  */\n-  s390_emit_jump (csend, s390_emit_compare_and_swap (EQ, res, ac.memsi,\n-\t\t\t\t\t\t     cmpv, newv));\n+      /* Check for changes outside mode, and loop internal if so.  */\n+      resv = expand_simple_binop (SImode, AND, res, ac.modemaski,\n+\t\t\t          NULL_RTX, 1, OPTAB_DIRECT);\n+      cc = s390_emit_compare (NE, resv, val);\n+      emit_move_insn (val, resv);\n+      s390_emit_jump (csloop, cc);\n \n-  /* Check for changes outside mode.  */\n-  resv = expand_simple_binop (SImode, AND, res, ac.modemaski,\n-\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n-  cc = s390_emit_compare (NE, resv, val);\n-  emit_move_insn (val, resv);\n-  /* Loop internal if so.  */\n-  s390_emit_jump (csloop, cc);\n-\n-  emit_label (csend);\n+      /* Failed.  */\n+      emit_move_insn (btarget, const0_rtx);\n+      emit_label (csend);\n+    }\n \n   /* Return the correct part of the bitfield.  */\n-  convert_move (target, expand_simple_binop (SImode, LSHIFTRT, res, ac.shift,\n-\t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT), 1);\n+  convert_move (vtarget, expand_simple_binop (SImode, LSHIFTRT, res, ac.shift,\n+\t\t\t\t\t      NULL_RTX, 1, OPTAB_DIRECT), 1);\n }\n \n /* Expand an atomic operation CODE of mode MODE.  MEM is the memory location"}, {"sha": "0e43e51a486f8357b8514c951953e034ff31507d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 276, "deletions": 113, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ce265b7148c1b8ef41ab8f3c22a1a8069d2995/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=78ce265b7148c1b8ef41ab8f3c22a1a8069d2995", "patch": "@@ -84,6 +84,7 @@\n \n    ; Atomic Support\n    UNSPEC_MB\n+   UNSPEC_MOVA\n \n    ; TLS relocation specifiers\n    UNSPEC_TLSGD\n@@ -349,21 +350,19 @@\n (define_mode_iterator DD_DF [DF DD])\n (define_mode_iterator TD_TF [TF TD])\n \n-;; This mode iterator allows 31-bit and 64-bit TDSI patterns to be generated\n-;; from the same template.\n-(define_mode_iterator TDSI [(TI \"TARGET_64BIT\") DI SI])\n-\n ;; These mode iterators allow 31-bit and 64-bit GPR patterns to be generated\n ;; from the same template.\n (define_mode_iterator GPR [(DI \"TARGET_ZARCH\") SI])\n+(define_mode_iterator DGPR [(TI \"TARGET_ZARCH\") DI SI])\n (define_mode_iterator DSI [DI SI])\n+(define_mode_iterator TDI [TI DI])\n \n ;; These mode iterators allow :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_iterator P [(DI \"TARGET_64BIT\") (SI \"!TARGET_64BIT\")])\n \n-;; These macros refer to the actual word_mode of the configuration. This is equal\n-;; to Pmode except on 31-bit machines in zarch mode.\n+;; These macros refer to the actual word_mode of the configuration.\n+;; This is equal to Pmode except on 31-bit machines in zarch mode.\n (define_mode_iterator DW [(TI \"TARGET_ZARCH\") (DI \"!TARGET_ZARCH\")])\n (define_mode_iterator W  [(DI \"TARGET_ZARCH\") (SI \"!TARGET_ZARCH\")])\n \n@@ -379,6 +378,7 @@\n ;; same template.\n (define_mode_iterator INT [(DI \"TARGET_ZARCH\") SI HI QI])\n (define_mode_iterator INTALL [TI DI SI HI QI])\n+(define_mode_iterator DINT [(TI \"TARGET_ZARCH\") DI SI HI QI])\n \n ;; This iterator allows some 'ashift' and 'lshiftrt' pattern to be defined from\n ;; the same template.\n@@ -487,6 +487,9 @@\n ;; and \"cds\" in DImode.\n (define_mode_attr tg [(TI \"g\") (DI \"\")])\n \n+;; In TDI templates, a string like \"c<d>sg\".\n+(define_mode_attr td [(TI \"d\") (DI \"\")])\n+\n ;; In GPR templates, a string like \"c<gf>dbr\" will expand to \"cgdbr\" in DImode\n ;; and \"cfdbr\" in SImode.\n (define_mode_attr gf [(DI \"g\") (SI \"f\")])\n@@ -8739,164 +8742,324 @@\n ;;\n \n ;\n-; memory barrier pattern.\n+; memory barrier patterns.\n ;\n \n-(define_expand \"memory_barrier\"\n-  [(set (match_dup 0)\n-\t(unspec:BLK [(match_dup 0)] UNSPEC_MB))]\n+(define_expand \"mem_signal_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\")]\t\t;; model\n   \"\"\n {\n-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n-  MEM_VOLATILE_P (operands[0]) = 1;\n+  /* The s390 memory model is strong enough not to require any\n+     barrier in order to synchronize a thread with itself.  */\n+  DONE;\n+})\n+\n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\")]\t\t;; model\n+  \"\"\n+{\n+  /* Unless this is a SEQ_CST fence, the s390 memory model is strong\n+     enough not to require barriers of any kind.  */\n+  if (INTVAL (operands[0]) == MEMMODEL_SEQ_CST)\n+    {\n+      rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+      MEM_VOLATILE_P (mem) = 1;\n+      emit_insn (gen_mem_thread_fence_1 (mem));\n+    }\n+  DONE;\n })\n \n-(define_insn \"*memory_barrier\"\n+; Although bcr is superscalar on Z10, this variant will never\n+; become part of an execution group.\n+(define_insn \"mem_thread_fence_1\"\n   [(set (match_operand:BLK 0 \"\" \"\")\n \t(unspec:BLK [(match_dup 0)] UNSPEC_MB))]\n   \"\"\n   \"bcr\\t15,0\"\n   [(set_attr \"op_type\" \"RR\")])\n \n-; Although bcr is superscalar on Z10, this variant will never become part of\n-; an execution group.\n+;\n+; atomic load/store operations\n+;\n+\n+; Atomic loads need not examine the memory model at all.\n+(define_expand \"atomic_load<mode>\"\n+  [(match_operand:DINT 0 \"register_operand\")\t;; output\n+   (match_operand:DINT 1 \"memory_operand\")\t;; memory\n+   (match_operand:SI 2 \"const_int_operand\")]\t;; model\n+  \"\"\n+{\n+  if (<MODE>mode == TImode)\n+    emit_insn (gen_atomic_loadti_1 (operands[0], operands[1]));\n+  else if (<MODE>mode == DImode && !TARGET_ZARCH)\n+    emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));\n+  else\n+    emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+; Different from movdi_31 in that we want no splitters.\n+(define_insn \"atomic_loaddi_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,!*f,!*f\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"Q,S,R,T\")]\n+\t\t   UNSPEC_MOVA))]\n+  \"!TARGET_ZARCH\"\n+  \"@\n+   lm\\t%0,%M0,%S1\n+   lmy\\t%0,%M0,%S1\n+   ld\\t%0,%1\n+   ldy\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RS,RSY,RS,RSY\")\n+   (set_attr \"type\" \"lm,lm,floaddf,floaddf\")])\n+\n+(define_insn \"atomic_loadti_1\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(unspec:TI [(match_operand:TI 1 \"memory_operand\" \"RT\")]\n+\t\t   UNSPEC_MOVA))]\n+  \"TARGET_ZARCH\"\n+  \"lpq\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RXY\")\n+   (set_attr \"type\" \"other\")])\n+\n+; Atomic stores must(?) enforce sequential consistency.\n+(define_expand \"atomic_store<mode>\"\n+  [(match_operand:DINT 0 \"memory_operand\")\t;; memory\n+   (match_operand:DINT 1 \"register_operand\")\t;; input\n+   (match_operand:SI 2 \"const_int_operand\")]\t;; model\n+  \"\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+\n+  if (<MODE>mode == TImode)\n+    emit_insn (gen_atomic_storeti_1 (operands[0], operands[1]));\n+  else if (<MODE>mode == DImode && !TARGET_ZARCH)\n+    emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));\n+  else\n+    emit_move_insn (operands[0], operands[1]);\n+  if (model == MEMMODEL_SEQ_CST)\n+    emit_insn (gen_mem_thread_fence (operands[2]));\n+  DONE;\n+})\n+\n+; Different from movdi_31 in that we want no splitters.\n+(define_insn \"atomic_storedi_1\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=Q,S,R,T\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"d,d,!*f,!*f\")]\n+\t\t   UNSPEC_MOVA))]\n+  \"!TARGET_ZARCH\"\n+  \"@\n+   stm\\t%1,%N1,%S0\n+   stmy\\t%1,%N1,%S0\n+   std %1,%0\n+   stdy %1,%0\"\n+  [(set_attr \"op_type\" \"RS,RSY,RS,RSY\")\n+   (set_attr \"type\" \"stm,stm,fstoredf,fstoredf\")])\n+\n+(define_insn \"atomic_storeti_1\"\n+  [(set (match_operand:TI 0 \"memory_operand\" \"=RT\")\n+\t(unspec:TI [(match_operand:TI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_MOVA))]\n+  \"TARGET_ZARCH\"\n+  \"stpq\\t%1,%0\"\n+  [(set_attr \"op_type\" \"RXY\")\n+   (set_attr \"type\" \"other\")])\n \n ;\n ; compare and swap patterns.\n ;\n \n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(parallel\n-    [(set (match_operand:TDSI 0 \"register_operand\" \"\")\n-\t  (match_operand:TDSI 1 \"memory_operand\" \"\"))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:TDSI\n-\t    [(match_dup 1)\n-\t     (match_operand:TDSI 2 \"register_operand\" \"\")\n-\t     (match_operand:TDSI 3 \"register_operand\" \"\")]\n-\t    UNSPECV_CAS))\n-     (set (reg:CCZ1 CC_REGNUM)\n-\t  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n-  \"\")\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\")\t;; bool success output\n+   (match_operand:DGPR 1 \"register_operand\")\t;; oldval output\n+   (match_operand:DGPR 2 \"memory_operand\")\t;; memory\n+   (match_operand:DGPR 3 \"register_operand\")\t;; expected intput\n+   (match_operand:DGPR 4 \"register_operand\")\t;; newval intput\n+   (match_operand:SI 5 \"const_int_operand\")\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n+  \"\"\n+{\n+  rtx cc, cmp;\n+  emit_insn (gen_atomic_compare_and_swap<mode>_internal\n+\t     (operands[1], operands[2], operands[3], operands[4]));\n+  cc = gen_rtx_REG (CCZ1mode, CC_REGNUM);\n+  cmp = gen_rtx_EQ (SImode, cc, const0_rtx);\n+  emit_insn (gen_cstorecc4 (operands[0], cmp, cc, const0_rtx));\n+  DONE;\n+})\n \n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(parallel\n-    [(set (match_operand:HQI 0 \"register_operand\" \"\")\n-\t  (match_operand:HQI 1 \"memory_operand\" \"\"))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:HQI\n-\t    [(match_dup 1)\n-\t     (match_operand:HQI 2 \"general_operand\" \"\")\n-\t     (match_operand:HQI 3 \"general_operand\" \"\")]\n-\t    UNSPECV_CAS))\n-     (clobber (reg:CC CC_REGNUM))])]\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\")\t;; bool success output\n+   (match_operand:HQI 1 \"register_operand\")\t;; oldval output\n+   (match_operand:HQI 2 \"memory_operand\")\t;; memory\n+   (match_operand:HQI 3 \"general_operand\")\t;; expected intput\n+   (match_operand:HQI 4 \"general_operand\")\t;; newval intput\n+   (match_operand:SI 5 \"const_int_operand\")\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n   \"\"\n-  \"s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1],\n-\t\t       operands[2], operands[3]); DONE;\")\n+{\n+  s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1], operands[2],\n+\t\t      operands[3], operands[4], INTVAL (operands[5]));\n+  DONE;\n+})\n \n-; cds, cdsg\n-(define_insn \"*sync_compare_and_swap<mode>\"\n-  [(set (match_operand:DW 0 \"register_operand\" \"=r\")\n-\t(match_operand:DW 1 \"memory_operand\" \"+Q\"))\n+(define_expand \"atomic_compare_and_swap<mode>_internal\"\n+  [(parallel\n+     [(set (match_operand:DGPR 0 \"register_operand\")\n+\t   (match_operand:DGPR 1 \"memory_operand\"))\n+      (set (match_dup 1)\n+\t   (unspec_volatile:DGPR\n+\t     [(match_dup 1)\n+\t      (match_operand:DGPR 2 \"register_operand\")\n+\t      (match_operand:DGPR 3 \"register_operand\")]\n+\t     UNSPECV_CAS))\n+      (set (reg:CCZ1 CC_REGNUM)\n+\t   (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n+  \"\")\n+\n+; cdsg, csg\n+(define_insn \"*atomic_compare_and_swap<mode>_1\"\n+  [(set (match_operand:TDI 0 \"register_operand\" \"=r\")\n+\t(match_operand:TDI 1 \"memory_operand\" \"+QS\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:DW\n+\t(unspec_volatile:TDI\n \t  [(match_dup 1)\n-\t   (match_operand:DW 2 \"register_operand\" \"0\")\n-\t   (match_operand:DW 3 \"register_operand\" \"r\")]\n+\t   (match_operand:TDI 2 \"register_operand\" \"0\")\n+\t   (match_operand:TDI 3 \"register_operand\" \"r\")]\n \t  UNSPECV_CAS))\n    (set (reg:CCZ1 CC_REGNUM)\n \t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"cds<tg>\\t%0,%3,%S1\"\n-  [(set_attr \"op_type\" \"RS<TE>\")\n+  \"TARGET_ZARCH\"\n+  \"c<td>sg\\t%0,%3,%S1\"\n+  [(set_attr \"op_type\" \"RSY\")\n    (set_attr \"type\"   \"sem\")])\n \n-; cs, csg\n-(define_insn \"*sync_compare_and_swap<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=r\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+Q\"))\n+; cds, cdsy\n+(define_insn \"*atomic_compare_and_swapdi_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(match_operand:DI 1 \"memory_operand\" \"+Q,S\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:GPR\n+\t(unspec_volatile:DI\n+\t  [(match_dup 1)\n+\t   (match_operand:DI 2 \"register_operand\" \"0,0\")\n+\t   (match_operand:DI 3 \"register_operand\" \"r,r\")]\n+\t  UNSPECV_CAS))\n+   (set (reg:CCZ1 CC_REGNUM)\n+\t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n+  \"!TARGET_ZARCH\"\n+  \"@\n+   cds\\t%0,%3,%S1\n+   cdsy\\t%0,%3,%S1\"\n+  [(set_attr \"op_type\" \"RS,RSY\")\n+   (set_attr \"type\" \"sem\")])\n+\n+; cs, csy\n+(define_insn \"*atomic_compare_and_swapsi_3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operand:SI 1 \"memory_operand\" \"+Q,S\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SI\n \t  [(match_dup 1)\n-\t   (match_operand:GPR 2 \"register_operand\" \"0\")\n-\t   (match_operand:GPR 3 \"register_operand\" \"r\")]\n+\t   (match_operand:SI 2 \"register_operand\" \"0,0\")\n+\t   (match_operand:SI 3 \"register_operand\" \"r,r\")]\n \t  UNSPECV_CAS))\n    (set (reg:CCZ1 CC_REGNUM)\n \t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"cs<g>\\t%0,%3,%S1\"\n-  [(set_attr \"op_type\" \"RS<E>\")\n+  \"@\n+   cs\\t%0,%3,%S1\n+   csy\\t%0,%3,%S1\"\n+  [(set_attr \"op_type\" \"RS,RSY\")\n    (set_attr \"type\"   \"sem\")])\n \n-\n ;\n ; Other atomic instruction patterns.\n ;\n \n-(define_expand \"sync_lock_test_and_set<mode>\"\n-  [(match_operand:HQI 0 \"register_operand\")\n-   (match_operand:HQI 1 \"memory_operand\")\n-   (match_operand:HQI 2 \"general_operand\")]\n-  \"\"\n-  \"s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1],\n-\t\t       operands[2], false); DONE;\")\n-\n ; z196 load and add, xor, or and and instructions\n \n-; lan, lang, lao, laog, lax, laxg, laa, laag\n-(define_insn \"sync_<atomic><mode>\"\n-  [(parallel\n-    [(set (match_operand:GPR 0 \"memory_operand\" \"+QS\")\n-\t  (unspec_volatile:GPR\n-\t   [(ATOMIC_Z196:GPR (match_dup 0)\n-\t\t\t     (match_operand:GPR 1 \"general_operand\" \"d\"))]\n-\t   UNSPECV_ATOMIC_OP))\n-     (clobber (match_scratch:GPR 2 \"=d\"))\n-     (clobber (reg:CC CC_REGNUM))])]\n+(define_expand \"atomic_fetch_<atomic><mode>\"\n+  [(match_operand:GPR 0 \"register_operand\")\t\t;; val out\n+   (ATOMIC_Z196:GPR\n+     (match_operand:GPR 1 \"memory_operand\")\t\t;; memory\n+     (match_operand:GPR 2 \"register_operand\"))\t\t;; val in\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n   \"TARGET_Z196\"\n-  \"la<noxa><g>\\t%2,%1,%0\")\n+{\n+  emit_insn (gen_atomic_fetch_<atomic><mode>_iaf\n+\t     (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n \n ; lan, lang, lao, laog, lax, laxg, laa, laag\n-(define_insn \"sync_old_<atomic><mode>\"\n-  [(parallel\n-    [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t  (match_operand:GPR 1 \"memory_operand\"   \"+QS\"))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:GPR\n-\t   [(ATOMIC_Z196:GPR (match_dup 1)\n-\t\t\t     (match_operand:GPR 2 \"general_operand\" \"d\"))]\n-\t   UNSPECV_ATOMIC_OP))\n-     (clobber (reg:CC CC_REGNUM))])]\n+(define_insn \"atomic_fetch_<atomic><mode>_iaf\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+QS\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR\n+\t [(ATOMIC_Z196:GPR (match_dup 1)\n+\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d\"))]\n+\t UNSPECV_ATOMIC_OP))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_Z196\"\n-  \"la<noxa><g>\\t%0,%2,%1\")\n+  \"la<noxa><g>\\t%0,%2,%1\"\n+  [(set_attr \"op_type\" \"RSY\")\n+   (set_attr \"type\" \"sem\")])\n \n+;; For SImode and larger, the optabs.c code will do just fine in\n+;; expanding a compare-and-swap loop.  For QI/HImode, we can do\n+;; better by expanding our own loop.\n \n-(define_expand \"sync_<atomic><mode>\"\n-  [(set (match_operand:HQI 0 \"memory_operand\")\n-\t(ATOMIC:HQI (match_dup 0)\n-\t\t    (match_operand:HQI 1 \"general_operand\")))]\n+(define_expand \"atomic_<atomic><mode>\"\n+  [(ATOMIC:HQI\n+     (match_operand:HQI 0 \"memory_operand\")\t\t;; memory\n+     (match_operand:HQI 1 \"general_operand\"))\t\t;; val in\n+   (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n   \"\"\n-  \"s390_expand_atomic (<MODE>mode, <CODE>, NULL_RTX, operands[0],\n-\t\t       operands[1], false); DONE;\")\n+{\n+  s390_expand_atomic (<MODE>mode, <CODE>, NULL_RTX, operands[0],\n+\t\t       operands[1], false);\n+  DONE;\n+})\n \n-(define_expand \"sync_old_<atomic><mode>\"\n-  [(set (match_operand:HQI 0 \"register_operand\")\n-\t(match_operand:HQI 1 \"memory_operand\"))\n-   (set (match_dup 1)\n-\t(ATOMIC:HQI (match_dup 1)\n-\t\t    (match_operand:HQI 2 \"general_operand\")))]\n+(define_expand \"atomic_fetch_<atomic><mode>\"\n+  [(match_operand:HQI 0 \"register_operand\")\t\t;; val out\n+   (ATOMIC:HQI\n+     (match_operand:HQI 1 \"memory_operand\")\t\t;; memory\n+     (match_operand:HQI 2 \"general_operand\"))\t\t;; val in\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n   \"\"\n-  \"s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1],\n-\t\t       operands[2], false); DONE;\")\n-\n-(define_expand \"sync_new_<atomic><mode>\"\n-  [(set (match_operand:HQI 0 \"register_operand\")\n-\t(ATOMIC:HQI (match_operand:HQI 1 \"memory_operand\")\n-\t\t    (match_operand:HQI 2 \"general_operand\")))\n-   (set (match_dup 1) (ATOMIC:HQI (match_dup 1) (match_dup 2)))]\n+{\n+  s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1],\n+\t\t      operands[2], false);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_<atomic>_fetch<mode>\"\n+  [(match_operand:HQI 0 \"register_operand\")\t\t;; val out\n+   (ATOMIC:HQI\n+     (match_operand:HQI 1 \"memory_operand\")\t\t;; memory\n+     (match_operand:HQI 2 \"general_operand\"))\t\t;; val in\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n+  \"\"\n+{\n+  s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1],\n+\t\t      operands[2], true);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:HQI 0 \"register_operand\")\t\t;; val out\n+   (match_operand:HQI 1 \"memory_operand\")\t\t;; memory\n+   (match_operand:HQI 2 \"general_operand\")\t\t;; val in\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n   \"\"\n-  \"s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1],\n-\t\t       operands[2], true); DONE;\")\n+{\n+  s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1],\n+\t\t      operands[2], false);\n+  DONE;\n+})\n \n ;;\n ;;- Miscellaneous instructions."}]}