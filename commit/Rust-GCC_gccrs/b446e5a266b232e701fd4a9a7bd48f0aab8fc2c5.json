{"sha": "b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ0NmU1YTI2NmIyMzJlNzAxZmQ0YTlhN2JkNDhmMGFhYjhmYzJjNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-01-10T20:37:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-01-10T20:37:43Z"}, "message": "basic-block.h (update_br_prob_note): Declare.\n\n\n\t* basic-block.h (update_br_prob_note): Declare.\n\t* cfgcleanup.c (try_simplify_condjump): Call update_br_prob_note.\n\t(try_forward_edges): Care negative frequencies and update note.\n\t(outgoing_edges_match): Tweek conditional merging heuristics.\n\t(try_crossjump_to_edge): use update_br_prob_note.\n\t* cfglayout.c (fixup_reorder_chain): Likewise.\n\t* cfrtl.c (update_br_prob_note): New.\n\t* ifcvt.c (dead_or_predicable): Call update_br_prob_note.\n\n\t* i386.c (ix86_decompose_address): Return -1 if address contains\n\tshift.\n\t(legitimate_address_p): Require ix86_decompose_address to return 1.\n\n\t* gcse.c (hash_scan_set): Use CONSTANT_INSN_P.\n\t(cprop_insn): Likewise.\n\nFrom-SVN: r48750", "tree": {"sha": "19471938dee687744538e8ca3cc2eb35fdb507c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19471938dee687744538e8ca3cc2eb35fdb507c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/comments", "author": null, "committer": null, "parents": [{"sha": "a01da83b2291abdccd8abe66eff604c50e3c71f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01da83b2291abdccd8abe66eff604c50e3c71f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01da83b2291abdccd8abe66eff604c50e3c71f0"}], "stats": {"total": 130, "additions": 89, "deletions": 41}, "files": [{"sha": "ee9b1d2f6b9c4cc4619b38b9619df1fe7de320aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -1,3 +1,21 @@\n+Thu Jan 10 22:35:54 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (update_br_prob_note): Declare.\n+\t* cfgcleanup.c (try_simplify_condjump): Call update_br_prob_note.\n+\t(try_forward_edges): Care negative frequencies and update note.\n+\t(outgoing_edges_match): Tweek conditional merging heuristics.\n+\t(try_crossjump_to_edge): use update_br_prob_note.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t* cfrtl.c (update_br_prob_note): New.\n+\t* ifcvt.c (dead_or_predicable): Call update_br_prob_note.\n+\n+\t* i386.c (ix86_decompose_address): Return -1 if address contains\n+\tshift.\n+\t(legitimate_address_p): Require ix86_decompose_address to return 1.\n+\n+\t* gcse.c (hash_scan_set): Use CONSTANT_INSN_P.\n+\t(cprop_insn): Likewise.\n+\n 2002-01-10  Kazu Hirata  <kazu@hxi.com>\n \n \t* toplev.c: Fix formatting."}, {"sha": "29df84af3350496c5dd93c983dc511907c5b9aac", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -687,6 +687,7 @@ extern conflict_graph conflict_graph_compute\n                                         PARAMS ((regset,\n \t\t\t\t\t\t partition));\n extern bool mark_dfs_back_edges\t\tPARAMS ((void));\n+extern void update_br_prob_note\t\tPARAMS ((basic_block));\n \n /* In dominance.c */\n "}, {"sha": "5015c81494129bf133bd64bd2b8278bada628cdb", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -177,6 +177,7 @@ try_simplify_condjump (cbranch_block)\n \t\t\t\t\t\t    jump_dest_block);\n   cbranch_jump_edge->flags |= EDGE_FALLTHRU;\n   cbranch_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n+  update_br_prob_note (cbranch_block);\n \n   /* Delete the block with the unconditional jump, and clean up the mess.  */\n   flow_delete_block (jump_block);\n@@ -521,7 +522,11 @@ try_forward_edges (mode, b)\n \t      edge t;\n \n \t      first->count -= edge_count;\n+\t      if (first->count < 0)\n+\t\tfirst->count = 0;\n \t      first->frequency -= edge_frequency;\n+\t      if (first->frequency < 0)\n+\t\tfirst->frequency = 0;\n \t      if (first->succ->succ_next)\n \t\t{\n \t\t  edge e;\n@@ -535,9 +540,11 @@ try_forward_edges (mode, b)\n \t\t    prob = edge_frequency * REG_BR_PROB_BASE / first->frequency;\n \t\t  else\n \t\t    prob = 0;\n+\t\t  if (prob > t->probability)\n+\t\t    prob = t->probability;\n \t\t  t->probability -= prob;\n \t\t  prob = REG_BR_PROB_BASE - prob;\n-\t\t  if (prob == 0)\n+\t\t  if (prob <= 0)\n \t\t    {\n \t\t      first->succ->probability = REG_BR_PROB_BASE;\n \t\t      first->succ->succ_next->probability = 0;\n@@ -546,6 +553,7 @@ try_forward_edges (mode, b)\n \t\t    for (e = first->succ; e; e = e->succ_next)\n \t\t      e->probability = ((e->probability * REG_BR_PROB_BASE)\n \t\t\t\t\t/ (double) prob);\n+\t\t  update_br_prob_note (first);\n \t\t}\n \t      else\n \t\t{\n@@ -558,8 +566,10 @@ try_forward_edges (mode, b)\n \t\t    n++;\n \t\t  t = first->succ;\n \t\t }\n-\t      t->count -= edge_count;\n \n+\t      t->count -= edge_count;\n+\t      if (t->count < 0)\n+\t\tt->count = 0;\n \t      first = t->dest;\n \t    }\n \t  while (first != target);\n@@ -745,6 +755,7 @@ merge_blocks (e, b, c, mode)\n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (e->flags & EDGE_FALLTHRU)\n     {\n+      int b_index = b->index, c_index = c->index;\n       /* We need to update liveness in case C already has broken liveness\n \t or B ends by conditional jump to next instructions that will be\n \t removed.  */\n@@ -756,7 +767,7 @@ merge_blocks (e, b, c, mode)\n \n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n-\t\t b->index, c->index);\n+                 b_index, c_index);\n \n       return true;\n     }\n@@ -1147,32 +1158,30 @@ outgoing_edges_match (mode, bb1, bb2)\n \t we will only have one branch prediction bit to work with.  Thus\n \t we require the existing branches to have probabilities that are\n \t roughly similar.  */\n-      /* ??? We should use bb->frequency to allow merging in infrequently\n-\t executed blocks, but at the moment it is not available when\n-\t cleanup_cfg is run.  */\n-      if (match && !optimize_size)\n+      if (match\n+\t  && !optimize_size\n+\t  && bb1->frequency > BB_FREQ_MAX / 1000\n+\t  && bb2->frequency > BB_FREQ_MAX / 1000)\n \t{\n-\t  rtx note1, note2;\n-\t  int prob1, prob2;\n+\t  int prob2;\n \n-\t  note1 = find_reg_note (bb1->end, REG_BR_PROB, 0);\n-\t  note2 = find_reg_note (bb2->end, REG_BR_PROB, 0);\n+\t  if (b1->dest == b2->dest)\n+\t    prob2 = b2->probability;\n+\t  else\n+\t    /* Do not use f2 probability as f2 may be forwarded.  */\n+\t    prob2 = REG_BR_PROB_BASE - b2->probability;\n \n-\t  if (note1 && note2)\n+\t  /* Fail if the difference in probabilities is\n+\t     greater than 5%.  */\n+\t  if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 20)\n \t    {\n-\t      prob1 = INTVAL (XEXP (note1, 0));\n-\t      prob2 = INTVAL (XEXP (note2, 0));\n-\t      if (reverse)\n-\t\tprob2 = REG_BR_PROB_BASE - prob2;\n-\n-\t      /* Fail if the difference in probabilities is\n-\t\t greater than 5%.  */\n-\t      if (abs (prob1 - prob2) > REG_BR_PROB_BASE / 20)\n-\t\treturn false;\n-\t    }\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file,\n+\t\t\t \"Outcomes of branch in bb %i and %i differs to much (%i %i)\\n\",\n+\t\t\t bb1->index, bb2->index, b1->probability, prob2);\n \n-\t  else if (note1 || note2)\n-\t    return false;\n+\t      return false;\n+\t    }\n \t}\n \n       if (rtl_dump_file && match)\n@@ -1259,7 +1268,6 @@ try_crossjump_to_edge (mode, e1, e2)\n   edge s;\n   rtx last;\n   rtx label;\n-  rtx note;\n \n   /* Search backward through forwarder blocks.  We don't need to worry\n      about multiple entry or chained forwarders, as they will be optimized\n@@ -1356,8 +1364,14 @@ try_crossjump_to_edge (mode, e1, e2)\n       if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n \t  s2->dest->succ->count -= s2->count;\n+\t  if (s2->dest->succ->count < 0)\n+\t    s2->dest->succ->count = 0;\n \t  s2->dest->count -= s2->count;\n \t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n+\t  if (s2->dest->frequency < 0)\n+\t    s2->dest->frequency = 0;\n+\t  if (s2->dest->count < 0)\n+\t    s2->dest->count = 0;\n \t}\n \n       if (!redirect_to->frequency && !src1->frequency)\n@@ -1369,9 +1383,7 @@ try_crossjump_to_edge (mode, e1, e2)\n \t     / (redirect_to->frequency + src1->frequency));\n     }\n \n-  note = find_reg_note (redirect_to->end, REG_BR_PROB, 0);\n-  if (note)\n-    XEXP (note, 0) = GEN_INT (BRANCH_EDGE (redirect_to)->probability);\n+  update_br_prob_note (redirect_to);\n \n   /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n "}, {"sha": "329e9f80b18cc738bcd6efc44c723b9da93ca218", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -412,6 +412,7 @@ fixup_reorder_chain ()\n \t\t    {\n \t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n \t\t      e_taken->flags |= EDGE_FALLTHRU;\n+\t\t      update_br_prob_note (bb);\n \t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n \t\t    }\n \t\t}\n@@ -423,6 +424,7 @@ fixup_reorder_chain ()\n \t\t{\n \t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n \t\t  e_taken->flags |= EDGE_FALLTHRU;\n+\t\t  update_br_prob_note (bb);\n \t\t  continue;\n \t\t}\n \t    }"}, {"sha": "a4f25f8964cb584ec9e62027c3e9f7221a8d3e6d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -1510,6 +1510,19 @@ print_rtl_with_bb (outf, rtx_first)\n     }\n }\n \f\n+void\n+update_br_prob_note (bb)\n+     basic_block bb;\n+{\n+  rtx note;\n+  if (GET_CODE (bb->end) != JUMP_INSN)\n+    return;\n+  note = find_reg_note (bb->end, REG_BR_PROB, NULL_RTX);\n+  if (!note || INTVAL (XEXP (note, 0)) == BRANCH_EDGE (bb)->probability)\n+    return;\n+  XEXP (note, 0) = GEN_INT (BRANCH_EDGE (bb)->probability);\n+}\n+\f\n /* Verify the CFG consistency.  This function check some CFG invariants and\n    aborts when something is wrong.  Hope that this function will help to\n    convert many optimization passes to preserve CFG consistent."}, {"sha": "4d047809f79f8a5038a93612303d3b5e66357e37", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -4349,8 +4349,10 @@ ix86_expand_epilogue (style)\n }\n \f\n /* Extract the parts of an RTL expression that is a valid memory address\n-   for an instruction.  Return false if the structure of the address is\n-   grossly off.  */\n+   for an instruction.  Return 0 if the structure of the address is\n+   grossly off.  Return -1 if the address contains ASHIFT, so it is not\n+   strictly valid, but still used for computing length of lea instruction.\n+   */\n \n static int\n ix86_decompose_address (addr, out)\n@@ -4362,6 +4364,7 @@ ix86_decompose_address (addr, out)\n   rtx disp = NULL_RTX;\n   HOST_WIDE_INT scale = 1;\n   rtx scale_rtx = NULL_RTX;\n+  int retval = 1;\n \n   if (GET_CODE (addr) == REG || GET_CODE (addr) == SUBREG)\n     base = addr;\n@@ -4402,7 +4405,7 @@ ix86_decompose_address (addr, out)\n \t  disp = op1;\n \t}\n       else\n-\treturn FALSE;\n+\treturn 0;\n     }\n   else if (GET_CODE (addr) == MULT)\n     {\n@@ -4417,11 +4420,12 @@ ix86_decompose_address (addr, out)\n       index = XEXP (addr, 0);\n       tmp = XEXP (addr, 1);\n       if (GET_CODE (tmp) != CONST_INT)\n-\treturn FALSE;\n+\treturn 0;\n       scale = INTVAL (tmp);\n       if ((unsigned HOST_WIDE_INT) scale > 3)\n-\treturn FALSE;\n+\treturn 0;\n       scale = 1 << scale;\n+      retval = -1;\n     }\n   else\n     disp = addr;\t\t\t/* displacement */\n@@ -4430,7 +4434,7 @@ ix86_decompose_address (addr, out)\n   if (scale_rtx)\n     {\n       if (GET_CODE (scale_rtx) != CONST_INT)\n-\treturn FALSE;\n+\treturn 0;\n       scale = INTVAL (scale_rtx);\n     }\n \n@@ -4471,7 +4475,7 @@ ix86_decompose_address (addr, out)\n   out->disp = disp;\n   out->scale = scale;\n \n-  return TRUE;\n+  return retval;\n }\n \f\n /* Return cost of the memory address x.\n@@ -4684,7 +4688,7 @@ legitimate_address_p (mode, addr, strict)\n       debug_rtx (addr);\n     }\n \n-  if (! ix86_decompose_address (addr, &parts))\n+  if (ix86_decompose_address (addr, &parts) <= 0)\n     {\n       reason = \"decomposition failed\";\n       goto report_error;"}, {"sha": "af3b29e4ca68ea89c89a98fc822ff55cc21d8105", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -2204,9 +2204,7 @@ hash_scan_set (pat, insn, set_p)\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t\t    && can_copy_p [GET_MODE (dest)]\n \t\t    && REGNO (src) != regno)\n-\t\t   || GET_CODE (src) == CONST_INT\n-\t\t   || GET_CODE (src) == SYMBOL_REF\n-\t\t   || GET_CODE (src) == CONST_DOUBLE)\n+\t\t   || CONSTANT_P (src))\n \t       /* A copy is not available if its src or dest is subsequently\n \t\t  modified.  Here we want to search from INSN+1 on, but\n \t\t  oprs_available_p searches from INSN on.  */\n@@ -4155,8 +4153,7 @@ cprop_insn (bb, insn, alter_jumps)\n       src = SET_SRC (pat);\n \n       /* Constant propagation.  */\n-      if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE\n-\t  || GET_CODE (src) == SYMBOL_REF)\n+      if (CONSTANT_P (src))\n \t{\n \t  /* Handle normal insns first.  */\n \t  if (GET_CODE (insn) == INSN"}, {"sha": "2939de4483e677f05a3719917712702f22f323ed", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=b446e5a266b232e701fd4a9a7bd48f0aab8fc2c5", "patch": "@@ -2657,6 +2657,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n       probability = BRANCH_EDGE (test_bb)->probability;\n       BRANCH_EDGE (test_bb)->probability = FALLTHRU_EDGE (test_bb)->probability;\n       FALLTHRU_EDGE (test_bb)->probability = probability;\n+      update_br_prob_note (test_bb);\n     }\n \n   /* Move the insns out of MERGE_BB to before the branch.  */"}]}