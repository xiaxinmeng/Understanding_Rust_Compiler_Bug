{"sha": "2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE0YjVmM2JmMGNlYTViNWIzNmRiNzI0YTA1Zjg1MGEyODEzYjZhNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-02-08T03:28:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-02-08T03:28:19Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r291", "tree": {"sha": "6b5d659cfea73d2944f991313366c392b465d311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5d659cfea73d2944f991313366c392b465d311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4/comments", "author": null, "committer": null, "parents": [{"sha": "67f2de4154173a8f544d55b60048b8cb4b88a1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f2de4154173a8f544d55b60048b8cb4b88a1df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f2de4154173a8f544d55b60048b8cb4b88a1df"}], "stats": {"total": 26, "additions": 20, "deletions": 6}, "files": [{"sha": "3121b8b021078fc647357b7db0ccd5051ee1f542", "filename": "gcc/reload1.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2a4b5f3bf0cea5b5b36db724a05f850a2813b6a4", "patch": "@@ -2163,9 +2163,16 @@ set_label_offsets (x, insn, initial_p)\n       else if (x == insn\n \t       && (tem = prev_nonnote_insn (insn)) != 0\n \t       && GET_CODE (tem) == BARRIER)\n-\tfor (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n-\t  reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n-\t    = offsets_at[CODE_LABEL_NUMBER (x)][i];\n+\t{\n+\t  num_not_at_initial_offset = 0;\n+\t  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n+\t    {\n+\t      reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n+\t\t= offsets_at[CODE_LABEL_NUMBER (x)][i];\n+\t      if (reg_eliminate[i].offset != reg_eliminate[i].initial_offset)\n+\t\tnum_not_at_initial_offset++;\n+\t    }\n+\t}\n \n       else\n \t/* If neither of the above cases is true, compare each offset\n@@ -3215,9 +3222,16 @@ reload_as_needed (first, live_known)\n       /* If we pass a label, copy the offsets from the label information\n \t into the current offsets of each elimination.  */\n       if (GET_CODE (insn) == CODE_LABEL)\n-\tfor (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n-\t  reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n-\t    = offsets_at[CODE_LABEL_NUMBER (insn)][i];\n+\t{\n+\t  num_not_at_initial_offset = 0;\n+\t  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n+\t    {\n+\t      reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n+\t\t= offsets_at[CODE_LABEL_NUMBER (insn)][i];\n+\t      if (reg_eliminate[i].offset != reg_eliminate[i].initial_offset)\n+\t\tnum_not_at_initial_offset++;\n+\t    }\n+\t}\n \n       else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{"}]}