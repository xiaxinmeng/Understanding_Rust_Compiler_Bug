{"sha": "38109dab82b39697d2a062dda597e01446a72c15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxMDlkYWI4MmIzOTY5N2QyYTA2MmRkYTU5N2UwMTQ0NmE3MmMxNQ==", "commit": {"author": {"name": "Gabor Loki", "email": "loki@gcc.gnu.org", "date": "2006-01-16T15:56:47Z"}, "committer": {"name": "Gabor Loki", "email": "loki@gcc.gnu.org", "date": "2006-01-16T15:56:47Z"}, "message": "rtl-factoring.c: Add sequence abstraction algorithm.\n\n2006-01-16  Gabor Loki <loki@gcc.gnu.org>\n\n\t* rtl-factoring.c : Add sequence abstraction algorithm.\n\t* cfgcleanup.c (outgoing_edges_match): Extra checks.\n\t(try_crossjump_to_edge): Avoid deleting preserve label when redirecting\n\tABNORMAL edges.\n\t(block_has_preserve_label): New function.\n\t* common.opt: Register new pass.\n\t* Makefile.in: Ditto.\n\t* passes.c: Ditto.\n\t* timevar.def: Ditto.\n\t* tree-pass.h: Ditto.\n\t* emit-rtl.c (make_jump_insn_raw): Remove forward decl.\n\t* rtl.h (make_jump_insn_raw): Add forward decl.\n\t* doc/invoke.texi: Add documentation for\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                  -frtl-abstract-sequences.\n\nFrom-SVN: r109750", "tree": {"sha": "af252562b35a549f3d69775cbe66df0b0efcfb90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af252562b35a549f3d69775cbe66df0b0efcfb90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38109dab82b39697d2a062dda597e01446a72c15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38109dab82b39697d2a062dda597e01446a72c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38109dab82b39697d2a062dda597e01446a72c15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38109dab82b39697d2a062dda597e01446a72c15/comments", "author": null, "committer": null, "parents": [{"sha": "292f30c5d777603851ec3dd576a7038c8b64c632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292f30c5d777603851ec3dd576a7038c8b64c632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/292f30c5d777603851ec3dd576a7038c8b64c632"}], "stats": {"total": 1517, "additions": 1511, "deletions": 6}, "files": [{"sha": "7a6495e27f27173af1dd7e05902040cdbb859228", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -995,7 +995,8 @@ OBJS-common = \\\n  tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o    \t\t\t   \\\n  lambda-trans.o\tlambda-code.o tree-loop-linear.o tree-ssa-sink.o \t   \\\n  tree-vrp.o tree-stdarg.o tree-cfgcleanup.o tree-ssa-reassoc.o\t\t   \\\n- tree-ssa-structalias.o tree-object-size.o\n+ tree-ssa-structalias.o tree-object-size.o \t\t\t\t   \\\n+ rtl-factoring.o\n \n \n OBJS-md = $(out_object_file)\n@@ -1891,6 +1892,9 @@ tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \\\n    $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \\\n    tree-ssa-propagate.h\n+rtl-factoring.o : rtl-factoring.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n+   coretypes.h $(TM_H) $(BASIC_BLOCK_H) $(GGC_H) $(REGS_H) $(PARAMS_H) $(EXPR_H) \\\n+   $(TM_P_H) tree-pass.h tree-flow.h timevar.h output.h\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) function.h $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H) except.h tree-pass.h $(FLAGS_H) langhooks.h \\"}, {"sha": "4f0c9d4de8aac27e5740663903487fdfacf21370", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -1589,11 +1589,43 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       return false;\n   }\n \n-  /* We don't need to match the rest of edges as above checks should be enough\n-     to ensure that they are equivalent.  */\n+  /* The same checks as in try_crossjump_to_edge. It is required for RTL\n+     version of sequence abstraction.  */\n+  FOR_EACH_EDGE (e1, ei, bb2->succs)\n+    {\n+      edge e2;\n+      edge_iterator ei;\n+      basic_block d1 = e1->dest;\n+\n+      if (FORWARDER_BLOCK_P (d1))\n+        d1 = EDGE_SUCC (d1, 0)->dest;\n+\n+      FOR_EACH_EDGE (e2, ei, bb1->succs)\n+        {\n+          basic_block d2 = e2->dest;\n+          if (FORWARDER_BLOCK_P (d2))\n+            d2 = EDGE_SUCC (d2, 0)->dest;\n+          if (d1 == d2)\n+            break;\n+        }\n+\n+      if (!e2)\n+        return false;\n+    }\n+\n   return true;\n }\n \n+/* Returns true if BB basic block has a preserve label.  */\n+\n+static bool\n+block_has_preserve_label (basic_block bb)\n+{\n+  return (bb\n+          && block_label (bb)\n+          && LABEL_PRESERVE_P (block_label (bb)));\n+}\n+\n /* E1 and E2 are edges with the same destination block.  Search their\n    predecessors for common code.  If found, redirect control flow from\n    (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC.  */\n@@ -1669,6 +1701,11 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n       && (newpos1 != BB_HEAD (src1)))\n     return false;\n \n+  /* Avoid deleting preseve label when redirecting ABNORMAL edeges.  */\n+  if (block_has_preserve_label (e1->dest)\n+      && (e1->flags & EDGE_ABNORMAL))\n+    return false;\n+\n   /* Here we know that the insns in the end of SRC1 which are common with SRC2\n      will be deleted.\n      If we have tablejumps in the end of SRC1 and SRC2"}, {"sha": "123996022aa6cd6fc9e7af5314bea113ba440bd3", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -783,6 +783,10 @@ fsched-stalled-insns-dep=\n Common RejectNegative Joined UInteger\n -fsched-stalled-insns-dep=<number>\tSet dependence distance checking in premature scheduling of queued insns\n \n+frtl-abstract-sequences\n+Common Report Var(flag_rtl_seqabstr)\n+Perform sequence abstraction optimization on RTL\n+\n fshared-data\n Common Report Var(flag_shared_data)\n Mark data as shared rather than private"}, {"sha": "9791453776aa70c352031c324d303560a8528e67", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -326,7 +326,8 @@ Objective-C and Objective-C++ Dialects}.\n -fregmove  -frename-registers @gol\n -freorder-blocks  -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n--frounding-math -fschedule-insns  -fschedule-insns2 @gol\n+-frounding-math -frtl-abstract-sequences @gol\n+-fschedule-insns  -fschedule-insns2 @gol\n -fno-sched-interblock  -fno-sched-spec  -fsched-spec-load @gol\n -fsched-spec-load-dangerous  @gol\n -fsched-stalled-insns=@var{n} -fsched-stalled-insns-dep=@var{n} @gol\n@@ -5530,6 +5531,14 @@ Future versions of GCC may provide finer control of this setting\n using C99's @code{FENV_ACCESS} pragma.  This command line option\n will be used to specify the default state for @code{FENV_ACCESS}.\n \n+@item -frtl-abstract-sequences\n+@opindex frtl-abstract-sequences\n+It is a size optimization method. This option is to find identical\n+sequences of code, which can be turned into pseudo-procedures  and\n+then  replace  all  occurrences with  calls to  the  newly created\n+subroutine. It is kind of an opposite of @option{-finline-functions}.\n+This optimization runs at RTL level.\n+\n @item -fsignaling-nans\n @opindex fsignaling-nans\n Compile code assuming that IEEE signaling NaNs may generate user-visible"}, {"sha": "e1446fc349af89cbe1178965e320ab86114e5af6", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -164,7 +164,6 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n #define last_location (cfun->emit->x_last_location)\n #define first_label_num (cfun->emit->x_first_label_num)\n \n-static rtx make_jump_insn_raw (rtx);\n static rtx make_call_insn_raw (rtx);\n static rtx find_line_note (rtx);\n static rtx change_address_1 (rtx, enum machine_mode, rtx, int);\n@@ -3344,7 +3343,7 @@ make_insn_raw (rtx pattern)\n \n /* Like `make_insn_raw' but make a JUMP_INSN instead of an insn.  */\n \n-static rtx\n+rtx\n make_jump_insn_raw (rtx pattern)\n {\n   rtx insn;"}, {"sha": "b79a03811ef4089449b724f22f460e6322963175", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -667,6 +667,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_postreload_cse);\n   NEXT_PASS (pass_gcse2);\n   NEXT_PASS (pass_flow2);\n+  NEXT_PASS (pass_rtl_seqabstr);\n   NEXT_PASS (pass_stack_adjustments);\n   NEXT_PASS (pass_peephole2);\n   NEXT_PASS (pass_if_after_reload);"}, {"sha": "e06eac3d09cca6a2c498105bc75f5309b9465448", "filename": "gcc/rtl-factoring.c", "status": "added", "additions": 1448, "deletions": 0, "changes": 1448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -0,0 +1,1448 @@\n+/* RTL factoring (sequence abstraction).\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+#include \"basic-block.h\"\n+#include \"resource.h\"\n+#include \"flags.h\"\n+#include \"ggc.h\"\n+#include \"regs.h\"\n+#include \"params.h\"\n+#include \"expr.h\"\n+#include \"tm_p.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n+#include \"timevar.h\"\n+#include \"output.h\"\n+\n+/* Sequence abstraction:\n+\n+   It is a size optimization method. The main idea of this technique is to\n+   find identical sequences of code, which can be turned into procedures and\n+   then replace all occurrences with calls to the newly created subroutine.\n+   It is kind of an opposite of function inlining.\n+\n+   There are four major parts of this file:\n+\n+   sequence fingerprint\n+     In order to avoid the comparison of every insn with every other, hash\n+     value will be designed for every insn by COMPUTE_HASH.\n+     These hash values are used for grouping the sequence candidates. So\n+     we only need to compare every insn with every other in same hash group.\n+\n+     FILL_HASH_BUCKET creates all hash values and stores into HASH_BUCKETS.\n+     The result is used by COLLECT_PATTERN_SEQS.\n+\n+   code matching\n+     In code matching the algorithm compares every two possible sequence\n+     candidates which last insns are in the same hash group. If these\n+     sequences are identical they will be stored and do further searches for\n+     finding more sequences which are identical with the first one.\n+\n+     COLLECT_PATTERN_SEQS does the code matching and stores the results into\n+     PATTERN_SEQS.\n+\n+   gain computation\n+     This part computes the gain of abstraction which could be archived when\n+     turning the pattern sequence into a pseudo-function and its matching\n+     sequences into pseudo-calls. After it the most effective sequences will\n+     be marked for abstraction.\n+\n+     RECOMPUTE_GAIN does the gain computation. The sequences with the maximum\n+     gain is on the top of PATTERN_SEQS.\n+\n+   abstract code\n+     This part turns the pattern sequence into a pseudo-function and its\n+     matching sequences into pseudo-calls.\n+\n+     ABSTRACT_BEST_SEQ does the code merging.\n+\n+\n+   C code example:\n+\n+   // Original source            // After sequence abstraction\n+   {                             {\n+                                   void *jump_label;\n+     ...                           ...\n+                                   jump_label = &&exit_0;\n+                                 entry_0:\n+     I0;                           I0;\n+     I1;                           I1;\n+     I2;                           I2;\n+     I3;                           I3;\n+                                   goto *jump_label;\n+                                 exit_0:\n+     ...                           ...\n+                                   jump_label = &&exit_1;\n+                                 goto entry_0;\n+     I0;\n+     I1;\n+     I2;\n+     I3;\n+                                 exit_1:\n+     ...                           ...\n+                                   jump_label = &&exit_2;\n+                                   goto entry_0;\n+     I0;\n+     I1;\n+     I2;\n+     I3;\n+                                 exit_2:\n+     ...                           ...\n+                                   jump_label = &&exit_3;\n+                                   goto entry_0;\n+     I0;\n+     I1;\n+     I2;\n+     I3;\n+                                exit_3:\n+     ...                           ...\n+   }                             }\n+\n+\n+   TODO:\n+   - Use REG_ALLOC_ORDER when choosing link register.\n+   - Handle JUMP_INSNs. Also handle volatile function calls (handle them\n+     simmilar to unconditional jumps.)\n+   - Test command line option -fpic.\n+*/\n+\n+/* Predicate yielding nonzero iff X is an abstractable insn.  Non-jump insns are\n+   abstractable.  */\n+#define ABSTRACTABLE_INSN_P(X) (INSN_P (X) && !JUMP_P (X))\n+\n+/* First parameter of the htab_create function call.  */\n+#define HASH_INIT 1023\n+\n+/* Multiplier for cost of sequence call to avoid abstracting short\n+   sequences.  */\n+#ifndef SEQ_CALL_COST_MULTIPLIER\n+#define SEQ_CALL_COST_MULTIPLIER 2\n+#endif\n+\n+/* Recomputes the cost of MSEQ pattern/matching sequence.  */\n+#define RECOMPUTE_COST(SEQ)                                 \\\n+{                                                           \\\n+  int l;                                                    \\\n+  rtx x = SEQ->insn;                                        \\\n+  SEQ->cost = 0;                                            \\\n+  for (l = 0; l < SEQ->abstracted_length; l++)              \\\n+    {                                                       \\\n+      SEQ->cost += compute_rtx_cost (x);                    \\\n+      x = prev_insn_in_block (x);                           \\\n+    }                                                       \\\n+}\n+\n+/* A sequence matching a pattern sequence.  */\n+typedef struct matching_seq_def\n+{\n+  /* The last insn in the matching sequence.  */\n+  rtx insn;\n+\n+  /* Index of INSN instruction.  */\n+  unsigned long idx;\n+\n+  /* The number of insns matching in this sequence and the pattern sequence.\n+   */\n+  int matching_length;\n+\n+  /* The number of insns selected to abstract from this sequence. Less than\n+     or equal to MATCHING_LENGTH.  */\n+  int abstracted_length;\n+\n+  /* The cost of the sequence.  */\n+  int cost;\n+\n+  /* The next sequence in the chain matching the same pattern.  */\n+  struct matching_seq_def *next_matching_seq;\n+} *matching_seq;\n+\n+\n+/* A pattern instruction sequence.  */\n+typedef struct pattern_seq_def\n+{\n+  /* The last insn in the pattern sequence.  */\n+  rtx insn;\n+\n+  /* Index of INSN instruction.  */\n+  unsigned long idx;\n+\n+  /* The gain of transforming the pattern sequence into a pseudo-function and\n+     the matching sequences into pseudo-calls.  */\n+  int gain;\n+\n+  /* The maximum of the ABSTRACTED_LENGTH of the matching sequences.  */\n+  int abstracted_length;\n+\n+  /* The cost of the sequence.  */\n+  int cost;\n+\n+  /* The register used to hold the return address during the pseudo-call.  */\n+  rtx link_reg;\n+\n+  /* The sequences matching this pattern.  */\n+  matching_seq matching_seqs;\n+\n+  /* The next pattern sequence in the chain.  */\n+  struct pattern_seq_def *next_pattern_seq;\n+} *pattern_seq;\n+\n+\n+/* A block of a pattern sequence.  */\n+typedef struct seq_block_def\n+{\n+  /* The number of insns in the block.  */\n+  int length;\n+\n+  /* The code_label of the block.  */\n+  rtx label;\n+\n+  /* The sequences entering the pattern sequence at LABEL.  */\n+  matching_seq matching_seqs;\n+\n+  /* The next block in the chain. The blocks are sorted by LENGTH in\n+     ascending order.  */\n+  struct seq_block_def *next_seq_block;\n+} *seq_block;\n+\n+/* Contains same sequence candidates for futher searching.  */\n+typedef struct hash_bucket_def\n+{\n+  /* The hash value of the group.  */\n+  unsigned int hash;\n+\n+  /* List of sequence candidates.  */\n+  htab_t seq_candidates;\n+} *p_hash_bucket;\n+\n+/* Contains the last insn of the sequence, and its index value.  */\n+typedef struct hash_elem_def\n+{\n+  /* Unique index; ordered by FILL_HASH_BUCKET.  */\n+  unsigned long idx;\n+\n+  /* The last insn in the sequence.  */\n+  rtx insn;\n+\n+  /* The cached length of the insn.  */\n+  int length;\n+} *p_hash_elem;\n+\n+/* The list of same sequence candidates.  */\n+static htab_t hash_buckets;\n+\n+/* The pattern sequences collected from the current functions.  */\n+static pattern_seq pattern_seqs;\n+\n+/* The blocks of the current pattern sequence.  */\n+static seq_block seq_blocks;\n+\n+/* Cost of calling sequence.  */\n+static int seq_call_cost;\n+\n+/* Cost of jump.  */\n+static int seq_jump_cost;\n+\n+/* Cost of returning.  */\n+static int seq_return_cost;\n+\n+/* Returns the first insn preceding INSN for which INSN_P is true and belongs to\n+   the same basic block. Returns NULL_RTX if no such insn can be found.  */\n+\n+static rtx\n+prev_insn_in_block (rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+\n+  if (!bb)\n+    return NULL_RTX;\n+\n+  while (insn != BB_HEAD (bb))\n+    {\n+      insn = PREV_INSN (insn);\n+      if (INSN_P (insn))\n+        return insn;\n+    }\n+  return NULL_RTX;\n+}\n+\n+/* Returns the hash value of INSN.  */\n+\n+static unsigned int\n+compute_hash (rtx insn)\n+{\n+  unsigned int hash = 0;\n+  rtx prev;\n+\n+  hash = INSN_CODE (insn) * 100;\n+\n+  prev = prev_insn_in_block (insn);\n+  if (prev)\n+    hash += INSN_CODE (prev);\n+\n+  return hash;\n+}\n+\n+/* Compute the cost of INSN rtx for abstraction.  */\n+\n+static int\n+compute_rtx_cost (rtx insn)\n+{\n+  struct hash_bucket_def tmp_bucket;\n+  p_hash_bucket bucket;\n+  struct hash_elem_def tmp_elem;\n+  p_hash_elem elem = NULL;\n+  int cost = -1;\n+\n+  /* Compute hash value for INSN.  */\n+  tmp_bucket.hash = compute_hash (insn);\n+\n+  /* Select the hash group.  */\n+  bucket = htab_find (hash_buckets, &tmp_bucket);\n+\n+  if (bucket)\n+  {\n+    tmp_elem.insn = insn;\n+\n+    /* Select the insn.  */\n+    elem = htab_find (bucket->seq_candidates, &tmp_elem);\n+\n+    /* If INSN is parsed the cost will be the cached length.  */\n+    if (elem)\n+      cost = elem->length;\n+  }\n+\n+  /* If we can't parse the INSN cost will be the instruction length.  */\n+  if (cost == -1)\n+  {\n+    cost = get_attr_length (insn);\n+\n+    /* Cache the length.  */\n+    if (elem)\n+      elem->length = cost;\n+  }\n+\n+  /* If we can't get an accurate estimate for a complex instruction,\n+     assume that it has the same cost as a single fast instruction.  */\n+  return cost != 0 ? cost : COSTS_N_INSNS (1);\n+}\n+\n+/* Determines the number of common insns in the sequences ending in INSN1 and\n+   INSN2. Returns with LEN number of common insns and COST cost of sequence.\n+*/\n+\n+static void\n+matching_length (rtx insn1, rtx insn2, int* len, int* cost)\n+{\n+  rtx x1;\n+  rtx x2;\n+\n+  x1 = insn1;\n+  x2 = insn2;\n+  *len = 0;\n+  *cost = 0;\n+  while (x1 && x2 && (x1 != insn2) && (x2 != insn1)\n+         && rtx_equal_p (PATTERN (x1), PATTERN (x2)))\n+    {\n+      (*len)++;\n+      (*cost) += compute_rtx_cost (x1);\n+      x1 = prev_insn_in_block (x1);\n+      x2 = prev_insn_in_block (x2);\n+    }\n+}\n+\n+/* Adds E0 as a pattern sequence to PATTERN_SEQS with E1 as a matching\n+   sequence.  */\n+\n+static void\n+match_seqs (p_hash_elem e0, p_hash_elem e1)\n+{\n+  int len;\n+  int cost;\n+  matching_seq mseq, p_prev, p_next;\n+\n+  /* Determines the cost of the sequence and return without doing anything\n+     if it is too small to produce any gain.  */\n+  matching_length (e0->insn, e1->insn, &len, &cost);\n+  if (cost <= seq_call_cost)\n+    return;\n+\n+  /* Prepend a new PATTERN_SEQ to PATTERN_SEQS if the last pattern sequence\n+     does not end in E0->INSN. This assumes that once the E0->INSN changes\n+     the old value will never appear again.  */\n+  if (!pattern_seqs || pattern_seqs->insn != e0->insn)\n+    {\n+      pattern_seq pseq =\n+        (pattern_seq) xmalloc (sizeof (struct pattern_seq_def));\n+      pseq->insn = e0->insn;\n+      pseq->idx = e0->idx;\n+      pseq->gain = 0;                 /* Set to zero to force recomputing.  */\n+      pseq->abstracted_length = 0;\n+      pseq->cost = 0;\n+      pseq->link_reg = NULL_RTX;\n+      pseq->matching_seqs = NULL;\n+      pseq->next_pattern_seq = pattern_seqs;\n+      pattern_seqs = pseq;\n+    }\n+\n+  /* Find the position of E1 in the matching sequences list.  */\n+  p_prev = NULL;\n+  p_next = pattern_seqs->matching_seqs;\n+  while (p_next && p_next->idx < e1->idx)\n+    {\n+      p_prev = p_next;\n+      p_next = p_next->next_matching_seq;\n+    }\n+\n+  /* Add a new E1 matching sequence to the pattern sequence. We know that\n+     it ends in E0->INSN.  */\n+  mseq = (matching_seq) xmalloc (sizeof (struct matching_seq_def));\n+  mseq->insn = e1->insn;\n+  mseq->idx = e1->idx;\n+  mseq->matching_length = len;\n+  mseq->abstracted_length = 0;\n+  mseq->cost = cost;\n+\n+  if (p_prev == NULL)\n+    pattern_seqs->matching_seqs = mseq;\n+  else\n+    p_prev->next_matching_seq = mseq;\n+  mseq->next_matching_seq = p_next;\n+}\n+\n+/* Collects all pattern sequences and their matching sequences and puts them\n+   into PATTERN_SEQS.  */\n+\n+static void\n+collect_pattern_seqs (void)\n+{\n+  htab_iterator hti0, hti1, hti2;\n+  p_hash_bucket hash_bucket;\n+  p_hash_elem e0, e1;\n+#ifdef STACK_REGS\n+  basic_block bb;\n+  bitmap_head stack_reg_live;\n+\n+  /* Extra initialization step to ensure that no stack registers (if present)\n+     are live across abnormal edges. Set a flag in STACK_REG_LIVE for an insn\n+     if a stack register is live after the insn.  */\n+  bitmap_initialize (&stack_reg_live, NULL);\n+\n+  FOR_EACH_BB (bb)\n+  {\n+    regset_head live;\n+    struct propagate_block_info *pbi;\n+    rtx insn;\n+\n+    /* Initialize liveness propagation.  */\n+    INIT_REG_SET (&live);\n+    COPY_REG_SET (&live, bb->il.rtl->global_live_at_end);\n+    pbi = init_propagate_block_info (bb, &live, NULL, NULL, 0);\n+\n+    /* Propagate liveness info and mark insns where a stack reg is live.  */\n+    insn = BB_END (bb);\n+    while (1)\n+      {\n+        int reg;\n+        for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n+          {\n+            if (REGNO_REG_SET_P (&live, reg))\n+              {\n+                bitmap_set_bit (&stack_reg_live, INSN_UID (insn));\n+                break;\n+              }\n+          }\n+\n+        if (insn == BB_HEAD (bb))\n+          break;\n+        insn = propagate_one_insn (pbi, insn);\n+      }\n+\n+    /* Free unused data.  */\n+    CLEAR_REG_SET (&live);\n+    free_propagate_block_info (pbi);\n+  }\n+#endif\n+\n+  /* Initialize PATTERN_SEQS to empty.  */\n+  pattern_seqs = 0;\n+\n+  /* Try to match every abstractable insn with every other insn in the same\n+     HASH_BUCKET.  */\n+\n+  FOR_EACH_HTAB_ELEMENT (hash_buckets, hash_bucket, p_hash_bucket, hti0)\n+    if (htab_elements (hash_bucket->seq_candidates) > 1)\n+      FOR_EACH_HTAB_ELEMENT (hash_bucket->seq_candidates, e0, p_hash_elem, hti1)\n+        FOR_EACH_HTAB_ELEMENT (hash_bucket->seq_candidates, e1, p_hash_elem,\n+                               hti2)\n+          if (e0 != e1\n+#ifdef STACK_REGS\n+              && !bitmap_bit_p (&stack_reg_live, INSN_UID (e0->insn))\n+              && !bitmap_bit_p (&stack_reg_live, INSN_UID (e1->insn))\n+#endif\n+             )\n+            match_seqs (e0, e1);\n+#ifdef STACK_REGS\n+  /* Free unused data.  */\n+  bitmap_clear (&stack_reg_live);\n+#endif\n+}\n+\n+/* Transforms a regset to a HARD_REG_SET. Every hard register in REGS is added\n+   to hregs. Additionally, the hard counterpart of every renumbered pseudo\n+   register is also added.  */\n+\n+static void\n+renumbered_reg_set_to_hard_reg_set (HARD_REG_SET * hregs, regset regs)\n+{\n+  int r;\n+\n+  REG_SET_TO_HARD_REG_SET (*hregs, regs);\n+  for (r = FIRST_PSEUDO_REGISTER; r < max_regno; r++)\n+    if (REGNO_REG_SET_P (regs, r) && reg_renumber[r] >= 0)\n+      SET_HARD_REG_BIT (*hregs, reg_renumber[r]);\n+}\n+\n+/* Clears the bits in REGS for all registers, which are live in the sequence\n+   give by its last INSN and its LENGTH.  */\n+\n+static void\n+clear_regs_live_in_seq (HARD_REG_SET * regs, rtx insn, int length)\n+{\n+  basic_block bb;\n+  regset_head live;\n+  HARD_REG_SET hlive;\n+  struct propagate_block_info *pbi;\n+  rtx x;\n+  int i;\n+\n+  /* Initialize liveness propagation.  */\n+  bb = BLOCK_FOR_INSN (insn);\n+  INIT_REG_SET (&live);\n+  COPY_REG_SET (&live, bb->il.rtl->global_live_at_end);\n+  pbi = init_propagate_block_info (bb, &live, NULL, NULL, 0);\n+\n+  /* Propagate until INSN if found.  */\n+  for (x = BB_END (bb); x != insn;)\n+    x = propagate_one_insn (pbi, x);\n+\n+  /* Clear registers live after INSN.  */\n+  renumbered_reg_set_to_hard_reg_set (&hlive, &live);\n+  AND_COMPL_HARD_REG_SET (*regs, hlive);\n+\n+  /* Clear registers live in and before the sequence.  */\n+  for (i = 0; i < length;)\n+    {\n+      rtx prev = propagate_one_insn (pbi, x);\n+\n+      if (INSN_P (x))\n+        {\n+          renumbered_reg_set_to_hard_reg_set (&hlive, &live);\n+          AND_COMPL_HARD_REG_SET (*regs, hlive);\n+          i++;\n+        }\n+\n+      x = prev;\n+    }\n+\n+  /* Free unused data.  */\n+  free_propagate_block_info (pbi);\n+  CLEAR_REG_SET (&live);\n+}\n+\n+/* Computes the gain of turning PSEQ into a pseudo-function and its matching\n+   sequences into pseudo-calls. Also computes and caches the number of insns to\n+   abstract from  the matching sequences.  */\n+\n+static void\n+recompute_gain_for_pattern_seq (pattern_seq pseq)\n+{\n+  matching_seq mseq;\n+  rtx x;\n+  int i;\n+  int hascall;\n+  HARD_REG_SET linkregs;\n+\n+  /* Initialize data.  */\n+  SET_HARD_REG_SET (linkregs);\n+  pseq->link_reg = NULL_RTX;\n+  pseq->abstracted_length = 0;\n+\n+  pseq->gain = -(seq_call_cost - seq_jump_cost + seq_return_cost);\n+\n+  /* Determine ABSTRACTED_LENGTH and COST for matching sequences of PSEQ.\n+     ABSTRACTED_LENGTH may be less than MATCHING_LENGTH if sequences in the\n+     same block overlap. */\n+\n+  for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+    {\n+      /* Determine ABSTRACTED_LENGTH.  */\n+      if (mseq->next_matching_seq)\n+        mseq->abstracted_length = (int)(mseq->next_matching_seq->idx -\n+                                        mseq->idx);\n+      else\n+        mseq->abstracted_length = mseq->matching_length;\n+\n+      if (mseq->abstracted_length > mseq->matching_length)\n+        mseq->abstracted_length = mseq->matching_length;\n+\n+      /* Compute the cost of sequence.  */\n+      RECOMPUTE_COST (mseq);\n+\n+      /* If COST is big enough registers live in this matching sequence\n+         should not be used as a link register. Also set ABSTRACTED_LENGTH\n+         of PSEQ.  */\n+      if (mseq->cost > seq_call_cost)\n+        {\n+          clear_regs_live_in_seq (&linkregs, mseq->insn,\n+                                  mseq->abstracted_length);\n+          if (mseq->abstracted_length > pseq->abstracted_length)\n+            pseq->abstracted_length = mseq->abstracted_length;\n+        }\n+    }\n+\n+  /* Modify ABSTRACTED_LENGTH of PSEQ if pattern sequence overlaps with one\n+     of the matching sequences.  */\n+  for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+    {\n+      x = pseq->insn;\n+      for (i = 0; (i < pseq->abstracted_length) && (x != mseq->insn); i++)\n+        x = prev_insn_in_block (x);\n+      pseq->abstracted_length = i;\n+    }\n+\n+  /* Compute the cost of pattern sequence.  */\n+  RECOMPUTE_COST (pseq);\n+\n+  /* No gain if COST is too small.  */\n+  if (pseq->cost <= seq_call_cost)\n+  {\n+    pseq->gain = -1;\n+    return;\n+  }\n+\n+  /* Ensure that no matching sequence is longer than the pattern sequence.  */\n+  for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+    {\n+      if (mseq->abstracted_length > pseq->abstracted_length)\n+        {\n+          mseq->abstracted_length = pseq->abstracted_length;\n+          RECOMPUTE_COST (mseq);\n+        }\n+      /* Once the length is stabilizing the gain can be calculated.  */\n+      if (mseq->cost > seq_call_cost)\n+        pseq->gain += mseq->cost - seq_call_cost;\n+    }\n+\n+  /* No need to do further work if there is no gain.  */\n+  if (pseq->gain <= 0)\n+    return;\n+\n+  /* Should not use registers live in the pattern sequence as link register.\n+   */\n+  clear_regs_live_in_seq (&linkregs, pseq->insn, pseq->abstracted_length);\n+\n+  /* Determine whether pattern sequence contains a call_insn.  */\n+  hascall = 0;\n+  x = pseq->insn;\n+  for (i = 0; i < pseq->abstracted_length; i++)\n+    {\n+      if (CALL_P (x))\n+        {\n+          hascall = 1;\n+          break;\n+        }\n+      x = prev_insn_in_block (x);\n+    }\n+\n+  /* Should not use a register as a link register if - it is a fixed\n+     register, or - the sequence contains a call insn and the register is a\n+     call used register, or - the register needs to be saved if used in a\n+     function but was not used before (since saving it can invalidate already\n+     computed frame pointer offsets), or - the register cannot be used as a\n+     base register.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (fixed_regs[i]\n+#ifdef REGNO_OK_FOR_INDIRECT_JUMP_P\n+        || (!REGNO_OK_FOR_INDIRECT_JUMP_P (i, Pmode))\n+#else\n+        || (!REGNO_MODE_OK_FOR_BASE_P (i, Pmode))\n+        || (!reg_class_subset_p (REGNO_REG_CLASS (i), BASE_REG_CLASS))\n+#endif\n+        || (hascall && call_used_regs[i])\n+        || (!call_used_regs[i] && !regs_ever_live[i]))\n+      CLEAR_HARD_REG_BIT (linkregs, i);\n+\n+  /* Find an appropriate register to be used as the link register.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (linkregs, i))\n+      {\n+        pseq->link_reg = gen_rtx_REG (Pmode, i);\n+        break;\n+      }\n+\n+  /* Abstraction is not possible if no link register is available, so set\n+     gain to 0.  */\n+  if (!pseq->link_reg)\n+    pseq->gain = 0;\n+}\n+\n+/* Deallocates memory occupied by PSEQ and its matching seqs.  */\n+\n+static void\n+free_pattern_seq (pattern_seq pseq)\n+{\n+  while (pseq->matching_seqs)\n+    {\n+      matching_seq mseq = pseq->matching_seqs;\n+      pseq->matching_seqs = mseq->next_matching_seq;\n+      free (mseq);\n+    }\n+  free (pseq);\n+}\n+\n+\n+/* Computes the gain for pattern sequences. Pattern sequences producing no gain\n+   are deleted. The pattern sequence with the biggest gain is moved to the first\n+   place of PATTERN_SEQS.  */\n+\n+static void\n+recompute_gain (void)\n+{\n+  pattern_seq *pseq;\n+  int maxgain;\n+\n+  maxgain = 0;\n+  for (pseq = &pattern_seqs; *pseq;)\n+    {\n+      if ((*pseq)->gain <= 0)\n+        recompute_gain_for_pattern_seq (*pseq);\n+\n+      if ((*pseq)->gain > 0)\n+        {\n+          if ((*pseq)->gain > maxgain)\n+            {\n+              pattern_seq temp = *pseq;\n+              (*pseq) = temp->next_pattern_seq;\n+              temp->next_pattern_seq = pattern_seqs;\n+              pattern_seqs = temp;\n+              maxgain = pattern_seqs->gain;\n+            }\n+          else\n+            {\n+              pseq = &(*pseq)->next_pattern_seq;\n+            }\n+        }\n+      else\n+        {\n+          pattern_seq temp = *pseq;\n+          *pseq = temp->next_pattern_seq;\n+          free_pattern_seq (temp);\n+        }\n+    }\n+}\n+\n+/* Updated those pattern sequences and matching sequences, which overlap with\n+   the sequence given by INSN and LEN. Deletes sequences shrinking below a\n+   limit.  */\n+\n+static void\n+erase_from_pattern_seqs (rtx insn, int len)\n+{\n+  pattern_seq *pseq;\n+  matching_seq *mseq;\n+  rtx x;\n+  int plen, mlen;\n+  int pcost, mcost;\n+\n+  while (len > 0)\n+    {\n+      for (pseq = &pattern_seqs; *pseq;)\n+        {\n+          plen = 0;\n+          pcost = 0;\n+          for (x = (*pseq)->insn; x && (x != insn);\n+               x = prev_insn_in_block (x))\n+            {\n+              plen++;\n+              pcost += compute_rtx_cost (x);\n+            }\n+\n+          if (pcost <= seq_call_cost)\n+            {\n+              pattern_seq temp = *pseq;\n+              *pseq = temp->next_pattern_seq;\n+              free_pattern_seq (temp);\n+            }\n+          else\n+            {\n+              for (mseq = &(*pseq)->matching_seqs; *mseq;)\n+                {\n+                  mlen = 0;\n+                  mcost = 0;\n+                  for (x = (*mseq)->insn;\n+                       x && (x != insn) && (mlen < plen)\n+                       && (mlen < (*mseq)->matching_length);\n+                       x = prev_insn_in_block (x))\n+                    {\n+                      mlen++;\n+                      mcost += compute_rtx_cost (x);\n+                    }\n+\n+                  if (mcost <= seq_call_cost)\n+                    {\n+                      matching_seq temp = *mseq;\n+                      *mseq = temp->next_matching_seq;\n+                      free (temp);\n+                      /* Set to 0 to force gain recomputation.  */\n+                      (*pseq)->gain = 0;\n+                    }\n+                  else\n+                    {\n+                      if (mlen < (*mseq)->matching_length)\n+                        {\n+                          (*mseq)->cost = mcost;\n+                          (*mseq)->matching_length = mlen;\n+                          /* Set to 0 to force gain recomputation.  */\n+                          (*pseq)->gain = 0;\n+                        }\n+                      mseq = &(*mseq)->next_matching_seq;\n+                    }\n+                }\n+\n+              pseq = &(*pseq)->next_pattern_seq;\n+            }\n+        }\n+\n+      len--;\n+      insn = prev_insn_in_block (insn);\n+    }\n+}\n+\n+/* Updates those pattern sequences and matching sequences, which overlap with\n+   the pattern sequence with the biggest gain and its matching sequences.  */\n+\n+static void\n+update_pattern_seqs (void)\n+{\n+  pattern_seq bestpseq;\n+  matching_seq mseq;\n+\n+  bestpseq = pattern_seqs;\n+  pattern_seqs = bestpseq->next_pattern_seq;\n+\n+  for (mseq = bestpseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+    if (mseq->cost > seq_call_cost)\n+      erase_from_pattern_seqs (mseq->insn, mseq->abstracted_length);\n+  erase_from_pattern_seqs (bestpseq->insn, bestpseq->abstracted_length);\n+\n+  bestpseq->next_pattern_seq = pattern_seqs;\n+  pattern_seqs = bestpseq;\n+}\n+\n+/* Groups together those matching sequences of the best pattern sequence, which\n+   have the same ABSTRACTED_LENGTH and puts these groups in ascending order.\n+   SEQ_BLOCKS contains the result.  */\n+\n+static void\n+determine_seq_blocks (void)\n+{\n+  seq_block sb;\n+  matching_seq *mseq;\n+  matching_seq m;\n+\n+  /* Initialize SEQ_BLOCKS to empty.  */\n+  seq_blocks = 0;\n+\n+  /* Process all matching sequences.  */\n+  for (mseq = &pattern_seqs->matching_seqs; *mseq;)\n+    {\n+      /* Deal only with matching sequences being long enough. */\n+      if ((*mseq)->cost <= seq_call_cost)\n+        {\n+          mseq = &(*mseq)->next_matching_seq;\n+          continue;\n+        }\n+\n+      /* Ensure that SB contains a seq_block with the appropriate length.\n+         Insert a new seq_block if neccessary.  */\n+      if (!seq_blocks || ((*mseq)->abstracted_length < seq_blocks->length))\n+        {\n+          sb = (seq_block) xmalloc (sizeof (struct seq_block_def));\n+          sb->length = (*mseq)->abstracted_length;\n+          sb->label = NULL_RTX;\n+          sb->matching_seqs = 0;\n+          sb->next_seq_block = seq_blocks;\n+          seq_blocks = sb;\n+        }\n+      else\n+        {\n+          for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n+            {\n+              if ((*mseq)->abstracted_length == sb->length)\n+                break;\n+              if (!sb->next_seq_block\n+                  || ((*mseq)->abstracted_length <\n+                      sb->next_seq_block->length))\n+                {\n+                  seq_block temp =\n+                    (seq_block) xmalloc (sizeof (struct seq_block_def));\n+                  temp->length = (*mseq)->abstracted_length;\n+                  temp->label = NULL_RTX;\n+                  temp->matching_seqs = 0;\n+                  temp->next_seq_block = sb->next_seq_block;\n+                  sb->next_seq_block = temp;\n+                }\n+            }\n+        }\n+\n+      /* Remove the matching sequence from the linked list of the pattern\n+         sequence and link it to SB.  */\n+      m = *mseq;\n+      *mseq = m->next_matching_seq;\n+      m->next_matching_seq = sb->matching_seqs;\n+      sb->matching_seqs = m;\n+    }\n+}\n+\n+/* Builds a symbol_ref for LABEL.  */\n+\n+static rtx\n+gen_symbol_ref_rtx_for_label (rtx label)\n+{\n+  char name[20];\n+  rtx sym;\n+\n+  ASM_GENERATE_INTERNAL_LABEL (name, \"L\", CODE_LABEL_NUMBER (label));\n+  sym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+  SYMBOL_REF_FLAGS (sym) = SYMBOL_FLAG_LOCAL;\n+  return sym;\n+}\n+\n+/* Ensures that INSN is the last insn in its block and returns the block label\n+   of the next block.  */\n+\n+static rtx\n+block_label_after (rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  if ((insn == BB_END (bb)) && (bb->next_bb != EXIT_BLOCK_PTR))\n+    return block_label (bb->next_bb);\n+  else\n+    return block_label (split_block (bb, insn)->dest);\n+}\n+\n+/* Ensures that the last insns of the best pattern and its matching sequences\n+   are the last insns in their block. Additionally, extends the live set at the\n+   end of the pattern sequence with the live sets at the end of the matching\n+   sequences.  */\n+\n+static void\n+split_blocks_after_seqs (void)\n+{\n+  seq_block sb;\n+  matching_seq mseq;\n+\n+  block_label_after (pattern_seqs->insn);\n+  for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n+    {\n+      for (mseq = sb->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+        {\n+          block_label_after (mseq->insn);\n+          IOR_REG_SET (BLOCK_FOR_INSN (pattern_seqs->insn)->\n+                       il.rtl->global_live_at_end,\n+                       BLOCK_FOR_INSN (mseq->insn)->il.rtl->global_live_at_end);\n+        }\n+    }\n+}\n+\n+/* Splits the best pattern sequence accoring to SEQ_BLOCKS. Emits pseudo-call\n+   and -return insns before and after the sequence.  */\n+\n+static void\n+split_pattern_seq (void)\n+{\n+  rtx insn;\n+  basic_block bb;\n+  rtx retlabel, retjmp, saveinsn;\n+  int i;\n+  seq_block sb;\n+\n+  insn = pattern_seqs->insn;\n+  bb = BLOCK_FOR_INSN (insn);\n+\n+  /* Get the label after the sequence. This will be the return address. The\n+     label will be referenced using a symbol_ref so protect it from\n+     deleting.  */\n+  retlabel = block_label_after (insn);\n+  LABEL_PRESERVE_P (retlabel) = 1;\n+\n+  /* Emit an indirect jump via the link register after the sequence acting\n+     as the return insn.  Also emit a barrier and update the basic block.  */\n+  retjmp = emit_jump_insn_after (gen_indirect_jump (pattern_seqs->link_reg),\n+                                 BB_END (bb));\n+  emit_barrier_after (BB_END (bb));\n+\n+  /* Replace all outgoing edges with a new one to the block of RETLABEL.  */\n+  while (EDGE_COUNT (bb->succs) != 0)\n+    remove_edge (EDGE_SUCC (bb, 0));\n+  make_edge (bb, BLOCK_FOR_INSN (retlabel), EDGE_ABNORMAL);\n+\n+  /* Split the sequence according to SEQ_BLOCKS and cache the label of the\n+     resulting basic blocks.  */\n+  i = 0;\n+  for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n+    {\n+      for (; i < sb->length; i++)\n+        insn = prev_insn_in_block (insn);\n+\n+      sb->label = block_label (split_block (bb, insn)->dest);\n+    }\n+\n+  /* Emit an insn saving the return address to the link register before the\n+     sequence.  */\n+  saveinsn = emit_insn_after (gen_move_insn (pattern_seqs->link_reg,\n+                              gen_symbol_ref_rtx_for_label\n+                              (retlabel)), BB_END (bb));\n+  /* Update liveness info.  */\n+  SET_REGNO_REG_SET (bb->il.rtl->global_live_at_end,\n+                     REGNO (pattern_seqs->link_reg));\n+}\n+\n+/* Deletes the insns of the matching sequences of the best pattern sequence and\n+   replaces them with pseudo-calls to the pattern sequence.  */\n+\n+static void\n+erase_matching_seqs (void)\n+{\n+  seq_block sb;\n+  matching_seq mseq;\n+  rtx insn;\n+  basic_block bb;\n+  rtx retlabel, saveinsn, callinsn;\n+  int i;\n+\n+  for (sb = seq_blocks; sb; sb = sb->next_seq_block)\n+    {\n+      for (mseq = sb->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+        {\n+          insn = mseq->insn;\n+          bb = BLOCK_FOR_INSN (insn);\n+\n+          /* Get the label after the sequence. This will be the return\n+             address. The label will be referenced using a symbol_ref so\n+             protect it from deleting.  */\n+          retlabel = block_label_after (insn);\n+          LABEL_PRESERVE_P (retlabel) = 1;\n+\n+          /* Delete the insns of the sequence.  */\n+          for (i = 0; i < sb->length; i++)\n+            insn = prev_insn_in_block (insn);\n+          delete_basic_block (split_block (bb, insn)->dest);\n+\n+          /* Emit an insn saving the return address to the link register\n+             before the deleted sequence.  */\n+          saveinsn = emit_insn_after (gen_move_insn (pattern_seqs->link_reg,\n+                                      gen_symbol_ref_rtx_for_label\n+                                      (retlabel)),\n+                                      BB_END (bb));\n+          BLOCK_FOR_INSN (saveinsn) = bb;\n+\n+          /* Emit a jump to the appropriate part of the pattern sequence\n+             after the save insn. Also update the basic block.  */\n+          callinsn = emit_jump_insn_after (gen_jump (sb->label), saveinsn);\n+          JUMP_LABEL (callinsn) = sb->label;\n+          LABEL_NUSES (sb->label)++;\n+          BLOCK_FOR_INSN (callinsn) = bb;\n+          BB_END (bb) = callinsn;\n+\n+          /* Maintain control flow and liveness information.  */\n+          SET_REGNO_REG_SET (bb->il.rtl->global_live_at_end,\n+                             REGNO (pattern_seqs->link_reg));\n+          emit_barrier_after (BB_END (bb));\n+          make_single_succ_edge (bb, BLOCK_FOR_INSN (sb->label), 0);\n+          IOR_REG_SET (bb->il.rtl->global_live_at_end,\n+            BLOCK_FOR_INSN (sb->label)->il.rtl->global_live_at_start);\n+\n+          make_edge (BLOCK_FOR_INSN (seq_blocks->label),\n+                     BLOCK_FOR_INSN (retlabel), EDGE_ABNORMAL);\n+        }\n+    }\n+}\n+\n+/* Deallocates SEQ_BLOCKS and all the matching sequences.  */\n+\n+static void\n+free_seq_blocks (void)\n+{\n+  while (seq_blocks)\n+    {\n+      seq_block sb = seq_blocks;\n+      while (sb->matching_seqs)\n+        {\n+          matching_seq mseq = sb->matching_seqs;\n+          sb->matching_seqs = mseq->next_matching_seq;\n+          free (mseq);\n+        }\n+      seq_blocks = sb->next_seq_block;\n+      free (sb);\n+    }\n+}\n+\n+/* Transforms the best pattern sequence into a pseudo-function and its matching\n+   sequences to pseudo-calls. Afterwards the best pattern sequence is removed\n+   from PATTERN_SEQS.  */\n+\n+static void\n+abstract_best_seq (void)\n+{\n+  pattern_seq bestpseq;\n+\n+  /* Do the abstraction.  */\n+  determine_seq_blocks ();\n+  split_blocks_after_seqs ();\n+  split_pattern_seq ();\n+  erase_matching_seqs ();\n+  free_seq_blocks ();\n+\n+  /* Record the usage of the link register.  */\n+  regs_ever_live[REGNO (pattern_seqs->link_reg)] = 1;\n+\n+  /* Remove the best pattern sequence.  */\n+  bestpseq = pattern_seqs;\n+  pattern_seqs = bestpseq->next_pattern_seq;\n+  free_pattern_seq (bestpseq);\n+}\n+\n+/* Prints info on the pattern sequences to the dump file.  */\n+\n+static void\n+dump_pattern_seqs (void)\n+{\n+  pattern_seq pseq;\n+  matching_seq mseq;\n+\n+  if (!dump_file)\n+    return;\n+\n+  fprintf (dump_file, \";; Pattern sequences\\n\");\n+  for (pseq = pattern_seqs; pseq; pseq = pseq->next_pattern_seq)\n+    {\n+      fprintf (dump_file, \"Pattern sequence at insn %d matches sequences at\",\n+               INSN_UID (pseq->insn));\n+      for (mseq = pseq->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n+        {\n+          fprintf (dump_file, \" insn %d (length %d)\", INSN_UID (mseq->insn),\n+                   mseq->matching_length);\n+          if (mseq->next_matching_seq)\n+            fprintf (dump_file, \",\");\n+        }\n+      fprintf (dump_file, \".\\n\");\n+    }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Prints info on the best pattern sequence transformed in the ITER-th\n+   iteration to the dump file.  */\n+\n+static void\n+dump_best_pattern_seq (int iter)\n+{\n+  matching_seq mseq;\n+\n+  if (!dump_file)\n+    return;\n+\n+  fprintf (dump_file, \";; Iteration %d\\n\", iter);\n+  fprintf (dump_file,\n+           \"Best pattern sequence with %d gain is at insn %d (length %d).\\n\",\n+           pattern_seqs->gain, INSN_UID (pattern_seqs->insn),\n+           pattern_seqs->abstracted_length);\n+  fprintf (dump_file, \"Matching sequences are at\");\n+  for (mseq = pattern_seqs->matching_seqs; mseq;\n+       mseq = mseq->next_matching_seq)\n+    {\n+      fprintf (dump_file, \" insn %d (length %d)\", INSN_UID (mseq->insn),\n+               mseq->abstracted_length);\n+      if (mseq->next_matching_seq)\n+        fprintf (dump_file, \",\");\n+    }\n+  fprintf (dump_file, \".\\n\");\n+  fprintf (dump_file, \"Using reg %d as link register.\\n\\n\",\n+           REGNO (pattern_seqs->link_reg));\n+}\n+\n+/* Htab hash function for hash_bucket_def structure.  */\n+\n+static unsigned int\n+htab_hash_bucket (const void *p)\n+{\n+  p_hash_bucket bucket = (p_hash_bucket) p;\n+  return bucket->hash;\n+}\n+\n+/* Htab equal function for hash_bucket_def structure.  */\n+\n+static int\n+htab_eq_bucket (const void *p0, const void *p1)\n+{\n+  return htab_hash_bucket (p0) == htab_hash_bucket (p1);\n+}\n+\n+/* Htab delete function for hash_bucket_def structure.  */\n+\n+static void\n+htab_del_bucket (void *p)\n+{\n+  p_hash_bucket bucket = (p_hash_bucket) p;\n+\n+  if (bucket->seq_candidates)\n+    htab_delete (bucket->seq_candidates);\n+\n+  free (bucket);\n+}\n+\n+/* Htab hash function for hash_bucket_def structure.  */\n+\n+static unsigned int\n+htab_hash_elem (const void *p)\n+{\n+  p_hash_elem elem = (p_hash_elem) p;\n+  return htab_hash_pointer (elem->insn);\n+}\n+\n+/* Htab equal function for hash_bucket_def structure.  */\n+\n+static int\n+htab_eq_elem (const void *p0, const void *p1)\n+{\n+  return htab_hash_elem (p0) == htab_hash_elem (p1);\n+}\n+\n+/* Htab delete function for hash_bucket_def structure.  */\n+\n+static void\n+htab_del_elem (void *p)\n+{\n+  p_hash_elem elem = (p_hash_elem) p;\n+  free (elem);\n+}\n+\n+/* Creates a hash value for each sequence candidate and saves them\n+   in HASH_BUCKET.  */\n+\n+static void\n+fill_hash_bucket (void)\n+{\n+  basic_block bb;\n+  rtx insn;\n+  void **slot;\n+  p_hash_bucket bucket;\n+  struct hash_bucket_def tmp_bucket;\n+  p_hash_elem elem;\n+  unsigned long insn_idx;\n+\n+  insn_idx = 0;\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+        {\n+          if (!ABSTRACTABLE_INSN_P (insn))\n+            continue;\n+\n+          /* Compute hash value for INSN.  */\n+          tmp_bucket.hash = compute_hash (insn);\n+\n+          /* Select the hash group.  */\n+          bucket = htab_find (hash_buckets, &tmp_bucket);\n+\n+          if (!bucket)\n+            {\n+              /* Create a new hash group.  */\n+              bucket = (p_hash_bucket) xcalloc (1,\n+                                        sizeof (struct hash_bucket_def));\n+              bucket->hash = tmp_bucket.hash;\n+              bucket->seq_candidates = NULL;\n+\n+              slot = htab_find_slot (hash_buckets, &tmp_bucket, INSERT);\n+              *slot = bucket;\n+            }\n+\n+          /* Create new list for storing sequence candidates.  */\n+          if (!bucket->seq_candidates)\n+              bucket->seq_candidates = htab_create (HASH_INIT,\n+                                                    htab_hash_elem,\n+                                                    htab_eq_elem,\n+                                                    htab_del_elem);\n+\n+          elem = (p_hash_elem) xcalloc (1, sizeof (struct hash_elem_def));\n+          elem->insn = insn;\n+          elem->idx = insn_idx;\n+          elem->length = get_attr_length (insn);\n+\n+          /* Insert INSN into BUCKET hash bucket.  */\n+          slot = htab_find_slot (bucket->seq_candidates, elem, INSERT);\n+          *slot = elem;\n+\n+          insn_idx++;\n+        }\n+    }\n+}\n+\n+/* Computes the cost of calling sequence and the cost of return.  */\n+\n+static void\n+compute_init_costs (void)\n+{\n+  rtx rtx_jump, rtx_store, rtx_return, reg, label;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    if (BB_HEAD (bb))\n+      break;\n+\n+  label = block_label (bb);\n+  reg = gen_rtx_REG (Pmode, 0);\n+\n+  /* Pattern for indirect jump.  */\n+  rtx_jump = gen_indirect_jump (reg);\n+\n+  /* Pattern for storing address.  */\n+  rtx_store = gen_rtx_SET (VOIDmode, reg, gen_symbol_ref_rtx_for_label (label));\n+\n+  /* Pattern for return insn.  */\n+  rtx_return = gen_jump (label);\n+\n+  /* The cost of jump.  */\n+  seq_jump_cost = compute_rtx_cost (make_jump_insn_raw (rtx_jump));\n+\n+  /* The cost of calling sequence.  */\n+  seq_call_cost = seq_jump_cost + compute_rtx_cost (make_insn_raw (rtx_store));\n+\n+  /* The cost of return.  */\n+  seq_return_cost = compute_rtx_cost (make_jump_insn_raw (rtx_return));\n+\n+  /* Simple heuristic for minimal sequence cost.  */\n+  seq_call_cost   = (int)(seq_call_cost * (double)SEQ_CALL_COST_MULTIPLIER);\n+}\n+\n+/* Finds equivalent insn sequences in the current function and retains only one\n+   instance of them which is turned into a pseudo-function. The additional\n+   copies are erased and replaced by pseudo-calls to the retained sequence.  */\n+\n+static void\n+rtl_seqabstr (void)\n+{\n+  int iter;\n+\n+  /* Create a hash list for COLLECT_PATTERN_SEQS.  */\n+  hash_buckets = htab_create (HASH_INIT, htab_hash_bucket , htab_eq_bucket ,\n+                              htab_del_bucket);\n+  fill_hash_bucket ();\n+\n+  /* Compute the common cost of abstraction.  */\n+  compute_init_costs ();\n+\n+  /* Build an initial set of pattern sequences from the current function.  */\n+  collect_pattern_seqs ();\n+  dump_pattern_seqs ();\n+\n+  /* Iterate until there are no sequences to abstract.  */\n+  for (iter = 1;; iter++)\n+    {\n+      /* Recompute gain for sequences if neccessary and select sequence with\n+         biggest gain.  */\n+      recompute_gain ();\n+      if (!pattern_seqs)\n+        break;\n+      dump_best_pattern_seq (iter);\n+      /* Update the cached info of the other sequences and force gain\n+         recomputation where needed.  */\n+      update_pattern_seqs ();\n+      /* Turn best sequences into pseudo-functions and -calls.  */\n+      abstract_best_seq ();\n+    }\n+\n+  /* Cleanup hash tables.  */\n+  htab_delete (hash_buckets);\n+\n+  if (iter > 1)\n+    {\n+      /* Update notes.  */\n+      count_or_remove_death_notes (NULL, 1);\n+\n+      life_analysis (dump_file, PROP_DEATH_NOTES |\n+                                PROP_SCAN_DEAD_CODE |\n+                                PROP_KILL_DEAD_CODE);\n+\n+      /* Extra cleanup.  */\n+      cleanup_cfg (CLEANUP_EXPENSIVE |\n+                   CLEANUP_UPDATE_LIFE |\n+                   (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+    }\n+}\n+\n+/* The gate function for TREE_OPT_PASS.  */\n+\n+static bool\n+gate_rtl_seqabstr (void)\n+{\n+  return flag_rtl_seqabstr;\n+}\n+\n+/* The entry point of the sequence abstraction algorithm.  */\n+\n+static void\n+rest_of_rtl_seqabstr (void)\n+{\n+  life_analysis (dump_file, PROP_DEATH_NOTES |\n+                            PROP_SCAN_DEAD_CODE |\n+                            PROP_KILL_DEAD_CODE);\n+\n+  cleanup_cfg (CLEANUP_EXPENSIVE |\n+               CLEANUP_UPDATE_LIFE |\n+               (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+\n+  /* Abstract out common insn sequences. */\n+  rtl_seqabstr ();\n+}\n+\n+struct tree_opt_pass pass_rtl_seqabstr = {\n+  \"seqabstr\",                           /* name */\n+  gate_rtl_seqabstr,                    /* gate */\n+  rest_of_rtl_seqabstr,                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_SEQABSTR,                          /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func |\n+  TODO_ggc_collect,                     /* todo_flags_finish */\n+  'Q'                                   /* letter */\n+};"}, {"sha": "d076b1de4b44ed4140334f1c4cd308676c5c6e1e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -1462,6 +1462,7 @@ extern rtx emit_note (int);\n extern rtx emit_note_copy (rtx);\n extern rtx emit_line_note (location_t);\n extern rtx make_insn_raw (rtx);\n+extern rtx make_jump_insn_raw (rtx);\n extern void add_function_usage_to (rtx, rtx);\n extern rtx last_call_insn (void);\n extern rtx previous_insn (rtx);"}, {"sha": "e769cba2fe45ba033988c8e087034ad48131c9ec", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -149,6 +149,7 @@ DEFTIMEVAR (TV_SCHED                 , \"scheduling\")\n DEFTIMEVAR (TV_LOCAL_ALLOC           , \"local alloc\")\n DEFTIMEVAR (TV_GLOBAL_ALLOC          , \"global alloc\")\n DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n+DEFTIMEVAR (TV_SEQABSTR              , \"sequence abstraction\")\n DEFTIMEVAR (TV_GCSE_AFTER_RELOAD      , \"load CSE after reload\")\n DEFTIMEVAR (TV_FLOW2                 , \"flow 2\")\n DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")"}, {"sha": "3c846274449a8790a1ea66d24ffb1b63455546ab", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38109dab82b39697d2a062dda597e01446a72c15/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=38109dab82b39697d2a062dda597e01446a72c15", "patch": "@@ -379,6 +379,7 @@ extern struct tree_opt_pass pass_convert_to_eh_region_ranges;\n extern struct tree_opt_pass pass_shorten_branches;\n extern struct tree_opt_pass pass_set_nothrow_function_flags;\n extern struct tree_opt_pass pass_final;\n+extern struct tree_opt_pass pass_rtl_seqabstr;\n \n /* The root of the compilation pass tree, once constructed.  */\n extern struct tree_opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;"}]}