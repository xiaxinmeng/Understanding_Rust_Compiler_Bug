{"sha": "491527afb8bcf02fc91fbddc66b27a0dc25c2bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkxNTI3YWZiOGJjZjAyZmM5MWZiZGRjNjZiMjdhMGRjMjVjMmJkMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-02-24T10:48:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-02-24T10:48:38Z"}, "message": "utils.c (fold_bit_position): New function.\n\n\t* gcc-interface/utils.c (fold_bit_position): New function.\n\t(rest_of_record_type_compilation): Call it instead of bit_position to\n\tcompute the field position and remove the call to remove_conversions.\n\t(compute_related_constant): Factor out the multiplication in both\n\toperands, if any, and streamline the final test.\n\nFrom-SVN: r245704", "tree": {"sha": "5b0c493558a4f1c75429d65375cd897b7b2660f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b0c493558a4f1c75429d65375cd897b7b2660f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1/comments", "author": null, "committer": null, "parents": [{"sha": "0b9cdb9a4011886f0166a648f874f880ac9e026a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b9cdb9a4011886f0166a648f874f880ac9e026a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b9cdb9a4011886f0166a648f874f880ac9e026a"}], "stats": {"total": 63, "additions": 48, "deletions": 15}, "files": [{"sha": "ffa4666d4e9796e096a297d49f01b4e47001b1f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=491527afb8bcf02fc91fbddc66b27a0dc25c2bd1", "patch": "@@ -1,3 +1,11 @@\n+2017-02-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (fold_bit_position): New function.\n+\t(rest_of_record_type_compilation): Call it instead of bit_position to\n+\tcompute the field position and remove the call to remove_conversions.\n+\t(compute_related_constant): Factor out the multiplication in both\n+\toperands, if any, and streamline the final test.\n+\n 2017-02-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (return_value_ok_for_nrv_p): Add sanity check."}, {"sha": "0a6d6af5b52f7e8c8c5650de4f3a383269c158b9", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/491527afb8bcf02fc91fbddc66b27a0dc25c2bd1/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=491527afb8bcf02fc91fbddc66b27a0dc25c2bd1", "patch": "@@ -238,6 +238,7 @@ static GTY ((cache))\n   hash_table<pad_type_hasher> *pad_type_hash_table;\n \n static tree merge_sizes (tree, tree, tree, bool, bool);\n+static tree fold_bit_position (const_tree);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n static tree float_type_for_precision (int, machine_mode);\n@@ -2041,15 +2042,11 @@ rest_of_record_type_compilation (tree record_type)\n \t{\n \t  tree field_type = TREE_TYPE (old_field);\n \t  tree field_name = DECL_NAME (old_field);\n-\t  tree curpos = bit_position (old_field);\n+\t  tree curpos = fold_bit_position (old_field);\n \t  tree pos, new_field;\n \t  bool var = false;\n \t  unsigned int align = 0;\n \n-\t  /* We're going to do some pattern matching below so remove as many\n-\t     conversions as possible.  */\n-\t  curpos = remove_conversions (curpos, true);\n-\n \t  /* See how the position was modified from the last position.\n \n \t     There are two basic cases we support: a value was added\n@@ -2146,7 +2143,7 @@ rest_of_record_type_compilation (tree record_type)\n \t     is when there are other components at fixed positions after\n \t     it (meaning there was a rep clause for every field) and we\n \t     want to be able to encode them.  */\n-\t  last_pos = size_binop (PLUS_EXPR, bit_position (old_field),\n+\t  last_pos = size_binop (PLUS_EXPR, curpos,\n \t\t\t\t (TREE_CODE (TREE_TYPE (old_field))\n \t\t\t\t  == QUAL_UNION_TYPE)\n \t\t\t\t ? bitsize_zero_node\n@@ -2201,23 +2198,51 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n   return new_size;\n }\n \n+/* Return the bit position of FIELD, in bits from the start of the record,\n+   and fold it as much as possible.  This is a tree of type bitsizetype.  */\n+\n+static tree\n+fold_bit_position (const_tree field)\n+{\n+  tree offset = DECL_FIELD_OFFSET (field);\n+  if (TREE_CODE (offset) == MULT_EXPR || TREE_CODE (offset) == PLUS_EXPR)\n+    offset = size_binop (TREE_CODE (offset),\n+\t\t\t fold_convert (bitsizetype, TREE_OPERAND (offset, 0)),\n+\t\t\t fold_convert (bitsizetype, TREE_OPERAND (offset, 1)));\n+  else\n+    offset = fold_convert (bitsizetype, offset);\n+  return size_binop (PLUS_EXPR, DECL_FIELD_BIT_OFFSET (field),\n+ \t\t     size_binop (MULT_EXPR, offset, bitsize_unit_node));\n+}\n+\n /* Utility function of above to see if OP0 and OP1, both of SIZETYPE, are\n    related by the addition of a constant.  Return that constant if so.  */\n \n static tree\n compute_related_constant (tree op0, tree op1)\n {\n-  tree op0_var, op1_var;\n-  tree op0_con = split_plus (op0, &op0_var);\n-  tree op1_con = split_plus (op1, &op1_var);\n-  tree result = size_binop (MINUS_EXPR, op0_con, op1_con);\n+  tree factor, op0_var, op1_var, op0_cst, op1_cst, result;\n \n-  if (operand_equal_p (op0_var, op1_var, 0))\n-    return result;\n-  else if (operand_equal_p (op0, size_binop (PLUS_EXPR, op1_var, result), 0))\n-    return result;\n+  if (TREE_CODE (op0) == MULT_EXPR\n+      && TREE_CODE (op1) == MULT_EXPR\n+      && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST\n+      && TREE_OPERAND (op1, 1) == TREE_OPERAND (op0, 1))\n+    {\n+      factor = TREE_OPERAND (op0, 1);\n+      op0 = TREE_OPERAND (op0, 0);\n+      op1 = TREE_OPERAND (op1, 0);\n+    }\n   else\n-    return 0;\n+    factor = NULL_TREE;\n+\n+  op0_cst = split_plus (op0, &op0_var);\n+  op1_cst = split_plus (op1, &op1_var);\n+  result = size_binop (MINUS_EXPR, op0_cst, op1_cst);\n+\n+  if (operand_equal_p (op0_var, op1_var, 0))\n+    return factor ? size_binop (MULT_EXPR, factor, result) : result;\n+\n+  return NULL_TREE;\n }\n \n /* Utility function of above to split a tree OP which may be a sum, into a"}]}