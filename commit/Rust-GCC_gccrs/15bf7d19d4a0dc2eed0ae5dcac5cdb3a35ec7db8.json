{"sha": "15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViZjdkMTlkNGEwZGMyZWVkMGFlNWRjYWM1Y2RiM2EzNWVjN2RiOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-12T22:00:14Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-12T22:00:14Z"}, "message": "ada-tree.h (DECL_LOOP_PARM_P): New flag.\n\n\t* gcc-interface/ada-tree.h (DECL_LOOP_PARM_P): New flag.\n\t(DECL_INDUCTION_VAR): New macro.\n\t(SET_DECL_INDUCTION_VAR): Likewise.\n\t* gcc-interface/gigi.h (convert_to_index_type): Declare.\n\t(gnat_invariant_expr): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: If this is a loop\n\tparameter, set DECL_LOOP_PARM_P on it.\n\t* gcc-interface/misc.c (gnat_print_decl) <VAR_DECL>: If DECL_LOOP_PARM_P\n\tis set, print DECL_INDUCTION_VAR instead of DECL_RENAMED_OBJECT.\n\t* gcc-interface/trans.c (gnu_loop_label_stack): Delete.\n\t(struct range_check_info_d): New type.\n\t(struct loop_info_d): Likewise.\n\t(gnu_loop_stack): New stack.\n\t(Identifier_to_gnu): Set TREE_READONLY flag on the first dereference\n\tbuilt for a by-double-ref read-only parameter.  If DECL_LOOP_PARM_P\n\tis set, do not test DECL_RENAMED_OBJECT.\n\t(push_range_check_info): New function.\n\t(Loop_Statement_to_gnu): Push a new struct loop_info_d instead of just\n\tthe label.  Reference the label and the iteration variable from it.\n\tBuild the special induction variable in the unsigned version of the\n\tsize type, if it is larger than the base type.  And attach it to the\n\titeration variable if the latter isn't by-ref.  In the iteration scheme\n\tcase, initialize the invariant conditions in front of the loop if\n\tdeemed profitable.  Use gnu_loop_stack.\n\t(gnat_to_gnu) <N_Exit_Statement>: Use gnu_loop_stack.\n\t<N_Raise_Constraint_Error>: Always process the reason.  In the range\n\tcheck and related cases, and if loop unswitching is enabled, compute\n\tinvariant conditions and push this information onto the stack.\n\tDo not translate again the condition if it has been already translated.\n\t* gcc-interface/utils.c (record_global_renaming_pointer): Assert that\n\tDECL_LOOP_PARM_P isn't set.\n\t(convert_to_index_type): New function.\n\t* gcc-interface/utils2.c (build_binary_op) <ARRAY_REF>: Use it in order\n\tto convert the index from the base index type to sizetype.\n\t(gnat_invariant_expr): New function.\n\nFrom-SVN: r179868", "tree": {"sha": "41c1d92f48d823ae6099ab833bb5304343a3034e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41c1d92f48d823ae6099ab833bb5304343a3034e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/comments", "author": null, "committer": null, "parents": [{"sha": "578f023490bab56ea603aa4374ecbf31b38c24b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/578f023490bab56ea603aa4374ecbf31b38c24b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/578f023490bab56ea603aa4374ecbf31b38c24b5"}], "stats": {"total": 1394, "additions": 1325, "deletions": 69}, "files": [{"sha": "07a734e772964e2c7ab79767db6f8ee39e1a244c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -1,11 +1,47 @@\n+2011-10-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_LOOP_PARM_P): New flag.\n+\t(DECL_INDUCTION_VAR): New macro.\n+\t(SET_DECL_INDUCTION_VAR): Likewise.\n+\t* gcc-interface/gigi.h (convert_to_index_type): Declare.\n+\t(gnat_invariant_expr): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: If this is a loop\n+\tparameter, set DECL_LOOP_PARM_P on it.\n+\t* gcc-interface/misc.c (gnat_print_decl) <VAR_DECL>: If DECL_LOOP_PARM_P\n+\tis set, print DECL_INDUCTION_VAR instead of DECL_RENAMED_OBJECT.\n+\t* gcc-interface/trans.c (gnu_loop_label_stack): Delete.\n+\t(struct range_check_info_d): New type.\n+\t(struct loop_info_d): Likewise.\n+\t(gnu_loop_stack): New stack.\n+\t(Identifier_to_gnu): Set TREE_READONLY flag on the first dereference\n+\tbuilt for a by-double-ref read-only parameter.  If DECL_LOOP_PARM_P\n+\tis set, do not test DECL_RENAMED_OBJECT.\n+\t(push_range_check_info): New function.\n+\t(Loop_Statement_to_gnu): Push a new struct loop_info_d instead of just\n+\tthe label.  Reference the label and the iteration variable from it.\n+\tBuild the special induction variable in the unsigned version of the\n+\tsize type, if it is larger than the base type.  And attach it to the\n+\titeration variable if the latter isn't by-ref.  In the iteration scheme\n+\tcase, initialize the invariant conditions in front of the loop if\n+\tdeemed profitable.  Use gnu_loop_stack.\n+\t(gnat_to_gnu) <N_Exit_Statement>: Use gnu_loop_stack.\n+\t<N_Raise_Constraint_Error>: Always process the reason.  In the range\n+\tcheck and related cases, and if loop unswitching is enabled, compute\n+\tinvariant conditions and push this information onto the stack.\n+\tDo not translate again the condition if it has been already translated.\n+\t* gcc-interface/utils.c (record_global_renaming_pointer): Assert that\n+\tDECL_LOOP_PARM_P isn't set.\n+\t(convert_to_index_type): New function.\n+\t* gcc-interface/utils2.c (build_binary_op) <ARRAY_REF>: Use it in order\n+\tto convert the index from the base index type to sizetype.\n+\t(gnat_invariant_expr): New function.\n+\n 2011-10-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc-interface/utils.c (def_builtin_1): Delete old interface with\n \ttwo parallel arrays to hold standard builtin declarations, and\n \treplace it with a function based interface that can support\n-\tcreating builtins on the fly in the future.  Change all uses, and\n-\tpoison the old names.  Make sure 0 is not a legitimate builtin\n-\tindex.\n+\tcreating builtins on the fly in the future.\n \t* gcc-interface/trans.c (Exception_Handler_to_gnu_zcx): Ditto.\n \t(gnat_to_gnu): Ditto.\n "}, {"sha": "c408de30296d581697cd717373e3995d40a11993", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -355,6 +355,9 @@ do {\t\t\t\t\t\t   \\\n /* Nonzero in a DECL if it is made for a pointer that can never be null.  */\n #define DECL_CAN_NEVER_BE_NULL_P(NODE) DECL_LANG_FLAG_2 (NODE)\n \n+/* Nonzero in a VAR_DECL if it is made for a loop parameter.  */\n+#define DECL_LOOP_PARM_P(NODE) DECL_LANG_FLAG_3 (VAR_DECL_CHECK (NODE))\n+\n /* Nonzero in a FIELD_DECL that is a dummy built for some internal reason.  */\n #define DECL_INTERNAL_P(NODE) DECL_LANG_FLAG_3 (FIELD_DECL_CHECK (NODE))\n \n@@ -409,9 +412,16 @@ do {\t\t\t\t\t\t   \\\n    || (DECL_ORIGINAL_FIELD (FIELD1)\t\t\t\t\t\\\n        && (DECL_ORIGINAL_FIELD (FIELD1) == DECL_ORIGINAL_FIELD (FIELD2))))\n \n-/* In a VAR_DECL, points to the object being renamed if the VAR_DECL is a\n-   renaming pointer, otherwise 0.  Note that this object is guaranteed to\n-   be protected against multiple evaluations.  */\n+/* In a VAR_DECL with the DECL_LOOP_PARM_P flag set, points to the special\n+   induction variable that is built under certain circumstances, if any.  */\n+#define DECL_INDUCTION_VAR(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n+#define SET_DECL_INDUCTION_VAR(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n+\n+/* In a VAR_DECL without the DECL_LOOP_PARM_P flag set and that is a renaming\n+   pointer, points to the object being renamed, if any.  Note that this object\n+   is guaranteed to be protected against multiple evaluations.  */\n #define DECL_RENAMED_OBJECT(NODE) \\\n   GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n #define SET_DECL_RENAMED_OBJECT(NODE, X) \\"}, {"sha": "81f891fee63933d29f22947580696a2e0aa2a0bf", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -1431,10 +1431,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TREE_ADDRESSABLE (gnu_decl) = 1;\n \t  }\n \n+\t/* If this is a loop parameter, set the corresponding flag.  */\n+\telse if (kind == E_Loop_Parameter)\n+\t  DECL_LOOP_PARM_P (gnu_decl) = 1;\n+\n \t/* If this is a renaming pointer, attach the renamed object to it and\n \t   register it if we are at the global level.  Note that an external\n \t   constant is at the global level.  */\n-\tif (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n+\telse if (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n \t  {\n \t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n \t    if ((!definition && kind == E_Constant) || global_bindings_p ())"}, {"sha": "143926160ac2043d320384b15ab3d814ec65c3da", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -492,6 +492,10 @@ extern bool fntype_same_flags_p (const_tree, tree, bool, bool, bool);\n    not permitted by the language being compiled.  */\n extern tree convert (tree type, tree expr);\n \n+/* Create an expression whose value is that of EXPR converted to the common\n+   index type, which is sizetype.  */\n+extern tree convert_to_index_type (tree expr);\n+\n /* Routines created solely for the tree translator's sake. Their prototypes\n    can be changed as desired.  */\n \n@@ -916,6 +920,11 @@ extern tree gnat_protect_expr (tree exp);\n    through something we don't know how to stabilize.  */\n extern tree gnat_stabilize_reference (tree ref, bool force, bool *success);\n \n+/* If EXPR is an expression that is invariant in the current function, in the\n+   sense that it can be evaluated anywhere in the function and any number of\n+   times, return EXPR or an equivalent expression.  Otherwise return NULL.  */\n+extern tree gnat_invariant_expr (tree expr);\n+\n /* Implementation of the builtin_function langhook.  */\n extern tree gnat_builtin_function (tree decl);\n "}, {"sha": "9b667125225854e994447ce9ffc1d3d2c6ba4ff6", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -394,8 +394,12 @@ gnat_print_decl (FILE *file, tree node, int indent)\n       break;\n \n     case VAR_DECL:\n-      print_node (file, \"renamed object\", DECL_RENAMED_OBJECT (node),\n-\t\t  indent + 4);\n+      if (DECL_LOOP_PARM_P (node))\n+\tprint_node (file, \"induction var\", DECL_INDUCTION_VAR (node),\n+\t\t    indent + 4);\n+      else\n+\tprint_node (file, \"renamed object\", DECL_RENAMED_OBJECT (node),\n+\t\t    indent + 4);\n       break;\n \n     default:"}, {"sha": "cd84dc7eaf25aa6316c14251be0e184c37df3b3d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 209, "deletions": 58, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -189,8 +189,33 @@ static GTY(()) VEC(tree,gc) *gnu_return_label_stack;\n    parameters.  See processing for N_Subprogram_Body.  */\n static GTY(()) VEC(tree,gc) *gnu_return_var_stack;\n \n-/* Stack of LOOP_STMT nodes.  */\n-static GTY(()) VEC(tree,gc) *gnu_loop_label_stack;\n+/* Structure used to record information for a range check.  */\n+struct GTY(()) range_check_info_d {\n+  tree low_bound;\n+  tree high_bound;\n+  tree type;\n+  tree invariant_cond;\n+};\n+\n+typedef struct range_check_info_d *range_check_info;\n+\n+DEF_VEC_P(range_check_info);\n+DEF_VEC_ALLOC_P(range_check_info,gc);\n+\n+/* Structure used to record information for a loop.  */\n+struct GTY(()) loop_info_d {\n+  tree label;\n+  tree loop_var;\n+  VEC(range_check_info,gc) *checks;\n+};\n+\n+typedef struct loop_info_d *loop_info;\n+\n+DEF_VEC_P(loop_info);\n+DEF_VEC_ALLOC_P(loop_info,gc);\n+\n+/* Stack of loop_info structures associated with LOOP_STMT nodes.  */\n+static GTY(()) VEC(loop_info,gc) *gnu_loop_stack;\n \n /* The stacks for N_{Push,Pop}_*_Label.  */\n static GTY(()) VEC(tree,gc) *gnu_constraint_error_label_stack;\n@@ -1008,6 +1033,9 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \t  if (TREE_CODE (gnu_result) == INDIRECT_REF)\n \t    TREE_THIS_NOTRAP (gnu_result) = 1;\n+\n+\t  if (read_only)\n+\t    TREE_READONLY (gnu_result) = 1;\n \t}\n \n       /* If it's a PARM_DECL to foreign convention subprogram, convert it.  */\n@@ -1024,6 +1052,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t we can reference the renamed object directly, since the renamed\n \t expression has been protected against multiple evaluations.  */\n       if (TREE_CODE (gnu_result) == VAR_DECL\n+          && !DECL_LOOP_PARM_P (gnu_result)\n \t  && DECL_RENAMED_OBJECT (gnu_result)\n \t  && (!DECL_RENAMING_GLOBAL_P (gnu_result) || global_bindings_p ()))\n \tgnu_result = DECL_RENAMED_OBJECT (gnu_result);\n@@ -2114,6 +2143,44 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n+/* Find out whether VAR is an iteration variable of an enclosing loop in the\n+   current function.  If so, push a range_check_info structure onto the stack\n+   of this enclosing loop and return it.  Otherwise, return NULL.  */\n+\n+static struct range_check_info_d *\n+push_range_check_info (tree var)\n+{\n+  struct loop_info_d *iter = NULL;\n+  unsigned int i;\n+\n+  if (VEC_empty (loop_info, gnu_loop_stack))\n+    return NULL;\n+\n+  while (CONVERT_EXPR_P (var) || TREE_CODE (var) == VIEW_CONVERT_EXPR)\n+    var = TREE_OPERAND (var, 0);\n+\n+  if (TREE_CODE (var) != VAR_DECL)\n+    return NULL;\n+\n+  if (decl_function_context (var) != current_function_decl)\n+    return NULL;\n+\n+  for (i = VEC_length (loop_info, gnu_loop_stack) - 1;\n+       VEC_iterate (loop_info, gnu_loop_stack, i, iter);\n+       i--)\n+    if (var == iter->loop_var)\n+      break;\n+\n+  if (iter)\n+    {\n+      struct range_check_info_d *rci = ggc_alloc_range_check_info_d ();\n+      VEC_safe_push (range_check_info, gc, iter->checks, rci);\n+      return rci;\n+    }\n+\n+  return NULL;\n+}\n+\n /* Return true if VAL (of type TYPE) can equal the minimum value if MAX is\n    false, or the maximum value if MAX is true, of TYPE.  */\n \n@@ -2181,20 +2248,24 @@ static tree\n Loop_Statement_to_gnu (Node_Id gnat_node)\n {\n   const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n+  struct loop_info_d *gnu_loop_info = ggc_alloc_cleared_loop_info_d ();\n   tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n \t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n   tree gnu_loop_label = create_artificial_label (input_location);\n-  tree gnu_cond_expr = NULL_TREE, gnu_result;\n+  tree gnu_cond_expr = NULL_TREE, gnu_low = NULL_TREE, gnu_high = NULL_TREE;\n+  tree gnu_result;\n+\n+  /* Push the loop_info structure associated with the LOOP_STMT.  */\n+  VEC_safe_push (loop_info, gc, gnu_loop_stack, gnu_loop_info);\n \n   /* Set location information for statement and end label.  */\n   set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n   Sloc_to_locus (Sloc (End_Label (gnat_node)),\n \t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n   LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n \n-  /* Save the end label of this LOOP_STMT in a stack so that a corresponding\n-     N_Exit_Statement can find it.  */\n-  VEC_safe_push (tree, gc, gnu_loop_label_stack, gnu_loop_label);\n+  /* Save the label so that a corresponding N_Exit_Statement can find it.  */\n+  gnu_loop_info->label = gnu_loop_label;\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2214,14 +2285,15 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       Entity_Id gnat_loop_var = Defining_Entity (gnat_loop_spec);\n       Entity_Id gnat_type = Etype (gnat_loop_var);\n       tree gnu_type = get_unpadded_type (gnat_type);\n-      tree gnu_low = TYPE_MIN_VALUE (gnu_type);\n-      tree gnu_high = TYPE_MAX_VALUE (gnu_type);\n       tree gnu_base_type = get_base_type (gnu_type);\n       tree gnu_one_node = convert (gnu_base_type, integer_one_node);\n       tree gnu_loop_var, gnu_loop_iv, gnu_first, gnu_last, gnu_stmt;\n       enum tree_code update_code, test_code, shift_code;\n       bool reverse = Reverse_Present (gnat_loop_spec), use_iv = false;\n \n+      gnu_low = TYPE_MIN_VALUE (gnu_type);\n+      gnu_high = TYPE_MAX_VALUE (gnu_type);\n+\n       /* We must disable modulo reduction for the iteration variable, if any,\n \t in order for the loop comparison to be effective.  */\n       if (reverse)\n@@ -2296,17 +2368,20 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t    ;\n \n \t  /* Otherwise, use the do-while form with the help of a special\n-\t     induction variable in the (unsigned version of) the base\n-\t     type, in order to have wrap-around arithmetics for it.  */\n+\t     induction variable in the unsigned version of the base type\n+\t     or the unsigned version of the size type, whichever is the\n+\t     largest, in order to have wrap-around arithmetics for it.  */\n \t  else\n \t    {\n-\t      if (!TYPE_UNSIGNED (gnu_base_type))\n-\t\t{\n-\t\t  gnu_base_type = gnat_unsigned_type (gnu_base_type);\n-\t\t  gnu_first = convert (gnu_base_type, gnu_first);\n-\t\t  gnu_last = convert (gnu_base_type, gnu_last);\n-\t\t  gnu_one_node = convert (gnu_base_type, integer_one_node);\n-\t\t}\n+\t      if (TYPE_PRECISION (gnu_base_type)\n+\t\t  > TYPE_PRECISION (size_type_node))\n+\t\tgnu_base_type = gnat_unsigned_type (gnu_base_type);\n+\t      else\n+\t\tgnu_base_type = size_type_node;\n+\n+\t      gnu_first = convert (gnu_base_type, gnu_first);\n+\t      gnu_last = convert (gnu_base_type, gnu_last);\n+\t      gnu_one_node = convert (gnu_base_type, integer_one_node);\n \t      use_iv = true;\n \t    }\n \n@@ -2379,6 +2454,12 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       gnu_loop_var = gnat_to_gnu_entity (gnat_loop_var, gnu_first, 1);\n       if (DECL_BY_REF_P (gnu_loop_var))\n \tgnu_loop_var = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_loop_var);\n+      else if (use_iv)\n+\t{\n+\t  gcc_assert (DECL_LOOP_PARM_P (gnu_loop_var));\n+\t  SET_DECL_INDUCTION_VAR (gnu_loop_var, gnu_loop_iv);\n+\t}\n+      gnu_loop_info->loop_var = gnu_loop_var;\n \n       /* Do all the arithmetics in the base type.  */\n       gnu_loop_var = convert (gnu_base_type, gnu_loop_var);\n@@ -2437,6 +2518,45 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n      the LOOP_STMT to it, finish it and make it the \"loop\".  */\n   if (Present (gnat_iter_scheme) && No (Condition (gnat_iter_scheme)))\n     {\n+      struct range_check_info_d *rci;\n+      unsigned n_checks = VEC_length (range_check_info, gnu_loop_info->checks);\n+      unsigned int i;\n+\n+      /* First, if we have computed a small number of invariant conditions for\n+\t range checks applied to the iteration variable, then initialize these\n+\t conditions in front of the loop.  Otherwise, leave them set to True.\n+\n+\t ??? The heuristics need to be improved, by taking into account the\n+\t     following datapoints:\n+\t       - loop unswitching is disabled for big loops.  The cap is the\n+\t\t parameter PARAM_MAX_UNSWITCH_INSNS (50).\n+\t       - loop unswitching can only be applied a small number of times\n+\t\t to a given loop.  The cap is PARAM_MAX_UNSWITCH_LEVEL (3).\n+\t       - the front-end quickly generates useless or redundant checks\n+\t\t that can be entirely optimized away in the end.  */\n+      if (1 <= n_checks && n_checks <= 4)\n+\tfor (i = 0;\n+\t     VEC_iterate (range_check_info, gnu_loop_info->checks, i, rci);\n+\t     i++)\n+\t  {\n+\t    tree low_ok\n+\t      = build_binary_op (GE_EXPR, boolean_type_node,\n+\t\t\t\t convert (rci->type, gnu_low),\n+\t\t\t\t rci->low_bound);\n+\t    tree high_ok\n+\t      = build_binary_op (LE_EXPR, boolean_type_node,\n+\t\t\t\t convert (rci->type, gnu_high),\n+\t\t\t\t rci->high_bound);\n+\t    tree range_ok\n+\t      = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t\t low_ok, high_ok);\n+\n+\t    TREE_OPERAND (rci->invariant_cond, 0)\n+\t      = build_unary_op (TRUTH_NOT_EXPR, boolean_type_node, range_ok);\n+\n+\t    add_stmt_with_node_force (rci->invariant_cond, gnat_node);\n+\t  }\n+\n       add_stmt (gnu_loop_stmt);\n       gnat_poplevel ();\n       gnu_loop_stmt = end_stmt_group ();\n@@ -2453,7 +2573,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   else\n     gnu_result = gnu_loop_stmt;\n \n-  VEC_pop (tree, gnu_loop_label_stack);\n+  VEC_pop (loop_info, gnu_loop_stack);\n \n   return gnu_result;\n }\n@@ -5588,7 +5708,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   ? gnat_to_gnu (Condition (gnat_node)) : NULL_TREE),\n \t\t  (Present (Name (gnat_node))\n \t\t   ? get_gnu_tree (Entity (Name (gnat_node)))\n-\t\t   : VEC_last (tree, gnu_loop_label_stack)));\n+\t\t   : VEC_last (loop_info, gnu_loop_stack)->label));\n       break;\n \n     case N_Return_Statement:\n@@ -6174,7 +6294,11 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Raise_Storage_Error:\n       {\n \tconst int reason = UI_To_Int (Reason (gnat_node));\n-\tconst Node_Id cond = Condition (gnat_node);\n+\tconst Node_Id gnat_cond = Condition (gnat_node);\n+\tconst bool with_extra_info = Exception_Extra_Info\n+\t\t\t\t     && !No_Exception_Handlers_Set ()\n+\t\t\t\t     && !get_exception_label (kind);\n+\ttree gnu_cond = NULL_TREE;\n \n \tif (type_annotate_only)\n \t  {\n@@ -6184,43 +6308,66 @@ gnat_to_gnu (Node_Id gnat_node)\n \n         gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\tif (Exception_Extra_Info\n-\t    && !No_Exception_Handlers_Set ()\n-\t    && !get_exception_label (kind)\n-\t    && VOID_TYPE_P (gnu_result_type)\n-\t    && Present (cond))\n-\t  switch (reason)\n-\t    {\n-\t    case CE_Access_Check_Failed:\n+\tswitch (reason)\n+\t  {\n+\t  case CE_Access_Check_Failed:\n+\t    if (with_extra_info)\n \t      gnu_result = build_call_raise_column (reason, gnat_node);\n-\t      break;\n+\t    break;\n \n-\t    case CE_Index_Check_Failed:\n-\t    case CE_Range_Check_Failed:\n-\t    case CE_Invalid_Data:\n-\t      if (Nkind (cond) == N_Op_Not\n-\t\t  && Nkind (Right_Opnd (cond)) == N_In\n-\t\t  && Nkind (Right_Opnd (Right_Opnd (cond))) == N_Range)\n-\t\t{\n-\t\t  Node_Id op = Right_Opnd (cond);  /* N_In node */\n-\t\t  Node_Id index = Left_Opnd (op);\n-\t\t  Node_Id range = Right_Opnd (op);\n-\t\t  Node_Id type = Etype (index);\n-\t\t  if (Is_Type (type)\n-\t\t      && Known_Esize (type)\n-\t\t      && UI_To_Int (Esize (type)) <= 32)\n-\t\t    gnu_result\n-\t\t      = build_call_raise_range (reason, gnat_node,\n-\t\t\t\t\t\tgnat_to_gnu (index),\n-\t\t\t\t\t\tgnat_to_gnu\n-\t\t\t\t\t\t(Low_Bound (range)),\n-\t\t\t\t\t\tgnat_to_gnu\n-\t\t\t\t\t\t(High_Bound (range)));\n-\t        }\n-\t      break;\n+\t  case CE_Index_Check_Failed:\n+\t  case CE_Range_Check_Failed:\n+\t  case CE_Invalid_Data:\n+\t    if (Present (gnat_cond)\n+\t\t&& Nkind (gnat_cond) == N_Op_Not\n+\t\t&& Nkind (Right_Opnd (gnat_cond)) == N_In\n+\t\t&& Nkind (Right_Opnd (Right_Opnd (gnat_cond))) == N_Range)\n+\t      {\n+\t\tNode_Id gnat_index = Left_Opnd (Right_Opnd (gnat_cond));\n+\t\tNode_Id gnat_type = Etype (gnat_index);\n+\t\tNode_Id gnat_range = Right_Opnd (Right_Opnd (gnat_cond));\n+\t\ttree gnu_index = gnat_to_gnu (gnat_index);\n+\t\ttree gnu_low_bound = gnat_to_gnu (Low_Bound (gnat_range));\n+\t\ttree gnu_high_bound = gnat_to_gnu (High_Bound (gnat_range));\n+\t\tstruct range_check_info_d *rci;\n+\n+\t\tif (with_extra_info\n+\t\t    && Known_Esize (gnat_type)\n+\t\t    && UI_To_Int (Esize (gnat_type)) <= 32)\n+\t\t  gnu_result\n+\t\t    = build_call_raise_range (reason, gnat_node, gnu_index,\n+\t\t\t\t\t      gnu_low_bound, gnu_high_bound);\n+\n+\t\t/* If loop unswitching is enabled, we try to compute invariant\n+\t\t   conditions for checks applied to iteration variables, i.e.\n+\t\t   conditions that are both independent of the variable and\n+\t\t   necessary in order for the check to fail in the course of\n+\t\t   some iteration, and prepend them to the original condition\n+\t\t   of the checks.  This will make it possible later for the\n+\t\t   loop unswitching pass to replace the loop with two loops,\n+\t\t   one of which has the checks eliminated and the other has\n+\t\t   the original checks reinstated, and a run time selection.\n+\t\t   The former loop will be suitable for vectorization.  */\n+\t\tif (flag_unswitch_loops\n+\t\t    && (gnu_low_bound = gnat_invariant_expr (gnu_low_bound))\n+\t\t    && (gnu_high_bound = gnat_invariant_expr (gnu_high_bound))\n+\t\t    && (rci = push_range_check_info (gnu_index)))\n+\t\t  {\n+\t\t    rci->low_bound = gnu_low_bound;\n+\t\t    rci->high_bound = gnu_high_bound;\n+\t\t    rci->type = gnat_to_gnu_type (gnat_type);\n+\t\t    rci->invariant_cond = build1 (SAVE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  boolean_true_node);\n+\t\t    gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t\tboolean_type_node,\n+\t\t\t\t\t\trci->invariant_cond,\n+\t\t\t\t\t\tgnat_to_gnu (gnat_cond));\n+\t\t  }\n+\t      }\n+\t    break;\n \n-\t    default:\n-\t      break;\n+\t  default:\n+\t    break;\n \t  }\n \n \tif (gnu_result == error_mark_node)\n@@ -6232,10 +6379,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   the code for the call.  Handle a condition, if there is one.  */\n \tif (VOID_TYPE_P (gnu_result_type))\n \t  {\n-\t    if (Present (cond))\n-\t      gnu_result\n-\t\t= build3 (COND_EXPR, void_type_node, gnat_to_gnu (cond),\n-\t\t\t  gnu_result, alloc_stmt_list ());\n+\t    if (Present (gnat_cond))\n+\t      {\n+\t\tif (!gnu_cond)\n+\t\t  gnu_cond = gnat_to_gnu (gnat_cond);\n+\t\tgnu_result\n+\t\t  = build3 (COND_EXPR, void_type_node, gnu_cond, gnu_result,\n+\t\t\t    alloc_stmt_list ());\n+\t      }\n \t  }\n \telse\n \t  gnu_result = build1 (NULL_EXPR, gnu_result_type, gnu_result);"}, {"sha": "c4cfde7e4215965cc63c7ed3a4afbe407eca3731", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -1771,7 +1771,7 @@ process_attributes (tree decl, struct attrib *attr_list)\n void\n record_global_renaming_pointer (tree decl)\n {\n-  gcc_assert (DECL_RENAMED_OBJECT (decl));\n+  gcc_assert (!DECL_LOOP_PARM_P (decl) && DECL_RENAMED_OBJECT (decl));\n   VEC_safe_push (tree, gc, global_renaming_pointers, decl);\n }\n \n@@ -4247,6 +4247,92 @@ convert (tree type, tree expr)\n       gcc_unreachable ();\n     }\n }\n+\n+/* Create an expression whose value is that of EXPR converted to the common\n+   index type, which is sizetype.  EXPR is supposed to be in the base type\n+   of the GNAT index type.  Calling it is equivalent to doing\n+\n+     convert (sizetype, expr)\n+\n+   but we try to distribute the type conversion with the knowledge that EXPR\n+   cannot overflow in its type.  This is a best-effort approach and we fall\n+   back to the above expression as soon as difficulties are encountered.\n+\n+   This is necessary to overcome issues that arise when the GNAT base index\n+   type and the GCC common index type (sizetype) don't have the same size,\n+   which is quite frequent on 64-bit architectures.  In this case, and if\n+   the GNAT base index type is signed but the iteration type of the loop has\n+   been forced to unsigned, the loop scalar evolution engine cannot compute\n+   a simple evolution for the general induction variables associated with the\n+   array indices, because it will preserve the wrap-around semantics in the\n+   unsigned type of their \"inner\" part.  As a result, many loop optimizations\n+   are blocked.\n+\n+   The solution is to use a special (basic) induction variable that is at\n+   least as large as sizetype, and to express the aforementioned general\n+   induction variables in terms of this induction variable, eliminating\n+   the problematic intermediate truncation to the GNAT base index type.\n+   This is possible as long as the original expression doesn't overflow\n+   and if the middle-end hasn't introduced artificial overflows in the\n+   course of the various simplification it can make to the expression.  */\n+\n+tree\n+convert_to_index_type (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  tree type = TREE_TYPE (expr);\n+\n+  /* If the type is unsigned, overflow is allowed so we cannot be sure that\n+     EXPR doesn't overflow.  Keep it simple if optimization is disabled.  */\n+  if (TYPE_UNSIGNED (type) || !optimize)\n+    return convert (sizetype, expr);\n+\n+  switch (code)\n+    {\n+    case VAR_DECL:\n+      /* The main effect of the function: replace a loop parameter with its\n+\t associated special induction variable.  */\n+      if (DECL_LOOP_PARM_P (expr) && DECL_INDUCTION_VAR (expr))\n+\texpr = DECL_INDUCTION_VAR (expr);\n+      break;\n+\n+    CASE_CONVERT:\n+      {\n+\ttree otype = TREE_TYPE (TREE_OPERAND (expr, 0));\n+\t/* Bail out as soon as we suspect some sort of type frobbing.  */\n+\tif (TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n+\t    || TYPE_UNSIGNED (type) != TYPE_UNSIGNED (otype))\n+\t  break;\n+      }\n+\n+      /* ... fall through ... */\n+\n+    case NON_LVALUE_EXPR:\n+      return fold_build1 (code, sizetype,\n+\t\t\t  convert_to_index_type (TREE_OPERAND (expr, 0)));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      return fold_build2 (code, sizetype,\n+\t\t\t  convert_to_index_type (TREE_OPERAND (expr, 0)),\n+\t\t\t  convert_to_index_type (TREE_OPERAND (expr, 1)));\n+\n+    case COMPOUND_EXPR:\n+      return fold_build2 (code, sizetype, TREE_OPERAND (expr, 0),\n+\t\t\t  convert_to_index_type (TREE_OPERAND (expr, 1)));\n+\n+    case COND_EXPR:\n+      return fold_build3 (code, sizetype, TREE_OPERAND (expr, 0),\n+\t\t\t  convert_to_index_type (TREE_OPERAND (expr, 1)),\n+\t\t\t  convert_to_index_type (TREE_OPERAND (expr, 2)));\n+\n+    default:\n+      break;\n+    }\n+\n+  return convert (sizetype, expr);\n+}\n \f\n /* Remove all conversions that are done in EXP.  This includes converting\n    from a padded type or to a justified modular type.  If TRUE_ADDRESS"}, {"sha": "4679ea85f309823c2ec62ab294e815e617ce32cc", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -798,7 +798,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       /* Then convert the right operand to its base type.  This will prevent\n \t unneeded sign conversions when sizetype is wider than integer.  */\n       right_operand = convert (right_base_type, right_operand);\n-      right_operand = convert (sizetype, right_operand);\n+      right_operand = convert_to_index_type (right_operand);\n       modulus = NULL_TREE;\n       break;\n \n@@ -2598,3 +2598,88 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n \n   return result;\n }\n+\n+/* If EXPR is an expression that is invariant in the current function, in the\n+   sense that it can be evaluated anywhere in the function and any number of\n+   times, return EXPR or an equivalent expression.  Otherwise return NULL.  */\n+\n+tree\n+gnat_invariant_expr (tree expr)\n+{\n+  tree type = TREE_TYPE (expr), t;\n+\n+  STRIP_NOPS (expr);\n+\n+  while ((TREE_CODE (expr) == CONST_DECL\n+\t  || (TREE_CODE (expr) == VAR_DECL && TREE_READONLY (expr)))\n+\t && decl_function_context (expr) == current_function_decl\n+\t && DECL_INITIAL (expr))\n+    {\n+      expr = DECL_INITIAL (expr);\n+      STRIP_NOPS (expr);\n+    }\n+\n+  if (TREE_CONSTANT (expr))\n+    return fold_convert (type, expr);\n+\n+  t = expr;\n+\n+  while (true)\n+    {\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase COMPONENT_REF:\n+\t  if (TREE_OPERAND (t, 2) != NULL_TREE)\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  if (!TREE_CONSTANT (TREE_OPERAND (t, 1))\n+\t      || TREE_OPERAND (t, 2) != NULL_TREE\n+\t      || TREE_OPERAND (t, 3) != NULL_TREE)\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tcase BIT_FIELD_REF:\n+\tcase VIEW_CONVERT_EXPR:\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n+\t  break;\n+\n+\tcase INDIRECT_REF:\n+\t  if (!TREE_READONLY (t)\n+\t      || TREE_SIDE_EFFECTS (t)\n+\t      || !TREE_THIS_NOTRAP (t))\n+\t    return NULL_TREE;\n+\t  break;\n+\n+\tdefault:\n+\t  goto object;\n+\t}\n+\n+      t = TREE_OPERAND (t, 0);\n+    }\n+\n+object:\n+  if (TREE_SIDE_EFFECTS (t))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (t) == CONST_DECL\n+      && (DECL_EXTERNAL (t)\n+\t  || decl_function_context (t) != current_function_decl))\n+    return fold_convert (type, expr);\n+\n+  if (!TREE_READONLY (t))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (t) == PARM_DECL)\n+    return fold_convert (type, expr);\n+\n+  if (TREE_CODE (t) == VAR_DECL\n+      && (DECL_EXTERNAL (t)\n+\t  || decl_function_context (t) != current_function_decl))\n+    return fold_convert (type, expr);\n+\n+  return NULL_TREE;\n+}"}, {"sha": "9e8f1f9b952a4900a960bd834ca537f838cc1d2f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -1,3 +1,18 @@\n+2011-10-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/vect1.ad[sb]: New test.\n+\t* gnat.dg/vect1_pkg.ads: New helper.\n+\t* gnat.dg/vect2.ad[sb]: New test.\n+\t* gnat.dg/vect2_pkg.ads: New helper.\n+\t* gnat.dg/vect3.ad[sb]: New test.\n+\t* gnat.dg/vect3_pkg.ads: New helper.\n+\t* gnat.dg/vect4.ad[sb]: New test.\n+\t* gnat.dg/vect4_pkg.ads: New helper.\n+\t* gnat.dg/vect5.ad[sb]: New test.\n+\t* gnat.dg/vect5_pkg.ads: New helper.\n+\t* gnat.dg/vect6.ad[sb]: New test.\n+\t* gnat.dg/vect6_pkg.ads: New helper.\n+\n 2011-10-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/fma_run_double_1.c: Add -mfpmath=sse."}, {"sha": "0bbd9ee86a7bee2c9bf0c47291b07eef7ac9fc2a", "filename": "gcc/testsuite/gnat.dg/vect1.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1.adb?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,93 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-O3 -msse2 -fdump-tree-vect-details\" }\n+\n+package body Vect1 is\n+\n+   function \"+\" (X, Y : Varray) return Varray is\n+      R : Varray (X'Range);\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Varray; R : not null access Varray) is\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Sarray) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Sarray; R : not null access Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray1) return Darray1 is\n+      R : Darray1;\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray1; R : not null access Darray1) is\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray2) return Darray2 is\n+      R : Darray2;\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray2; R : not null access Darray2) is\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray3) return Darray3 is\n+      R : Darray3;\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray3; R : not null access Darray3) is\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+end Vect1;\n+\n+-- { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 10 \"vect\"  } }\n+-- { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "48343fc0553a08d70dffa61be54f3c9bf2383fce", "filename": "gcc/testsuite/gnat.dg/vect1.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,42 @@\n+with Vect1_Pkg;\n+\n+package Vect1 is\n+\n+   -- Unconstrained array types are vectorizable, possibly with special\n+   -- help for the programmer\n+   type Varray is array (Integer range <>) of Long_Float;\n+   for Varray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Varray) return Varray;\n+   procedure Add (X, Y : not null access Varray; R : not null access Varray);\n+\n+\n+   -- Constrained array types are vectorizable\n+   type Sarray is array (1 .. 4) of Long_Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Sarray) return Sarray;\n+   procedure Add (X, Y : not null access Sarray; R : not null access Sarray);\n+\n+\n+   type Darray1 is array (1 .. Vect1_Pkg.N) of Long_Float;\n+   for Darray1'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray1) return Darray1;\n+   procedure Add (X, Y : not null access Darray1; R : not null access Darray1);\n+\n+\n+   type Darray2 is array (Vect1_Pkg.K .. 4) of Long_Float;\n+   for Darray2'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray2) return Darray2;\n+   procedure Add (X, Y : not null access Darray2; R : not null access Darray2);\n+\n+\n+   type Darray3 is array (Vect1_Pkg.K .. Vect1_Pkg.N) of Long_Float;\n+   for Darray3'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray3) return Darray3;\n+   procedure Add (X, Y : not null access Darray3; R : not null access Darray3);\n+\n+end Vect1;"}, {"sha": "b9fab52b1e2deb042604232ffbf615786f5eb28b", "filename": "gcc/testsuite/gnat.dg/vect1_pkg.ads", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect1_pkg.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,6 @@\n+package Vect1_Pkg is\n+\n+   function K return Integer;\n+   function N return Integer;\n+\n+end Vect1_Pkg;"}, {"sha": "54e0403f135a2ae7381dcb3093fc1847bb453849", "filename": "gcc/testsuite/gnat.dg/vect2.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2.adb?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,93 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-O3 -msse2 -fdump-tree-vect-details\" }\n+\n+package body Vect2 is\n+\n+   function \"+\" (X, Y : Varray) return Varray is\n+      R : Varray (X'Range);\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Varray; R : not null access Varray) is\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Sarray) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Sarray; R : not null access Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray1) return Darray1 is\n+      R : Darray1;\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray1; R : not null access Darray1) is\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray2) return Darray2 is\n+      R : Darray2;\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray2; R : not null access Darray2) is\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray3) return Darray3 is\n+      R : Darray3;\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray3; R : not null access Darray3) is\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+end Vect2;\n+\n+-- { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 10 \"vect\"  } }\n+-- { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "b5111875924781c01f53b2b03b110e7813d85290", "filename": "gcc/testsuite/gnat.dg/vect2.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,42 @@\n+with Vect2_Pkg;\n+\n+package Vect2 is\n+\n+   -- Unconstrained array types are vectorizable, possibly with special\n+   -- help for the programmer\n+   type Varray is array (Positive range <>) of Long_Float;\n+   for Varray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Varray) return Varray;\n+   procedure Add (X, Y : not null access Varray; R : not null access Varray);\n+\n+\n+   -- Constrained array types are vectorizable\n+   type Sarray is array (Positive(1) .. Positive(4)) of Long_Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Sarray) return Sarray;\n+   procedure Add (X, Y : not null access Sarray; R : not null access Sarray);\n+\n+\n+   type Darray1 is array (Positive(1) .. Vect2_Pkg.N) of Long_Float;\n+   for Darray1'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray1) return Darray1;\n+   procedure Add (X, Y : not null access Darray1; R : not null access Darray1);\n+\n+\n+   type Darray2 is array (Vect2_Pkg.K .. Positive(4)) of Long_Float;\n+   for Darray2'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray2) return Darray2;\n+   procedure Add (X, Y : not null access Darray2; R : not null access Darray2);\n+\n+\n+   type Darray3 is array (Vect2_Pkg.K .. Vect2_Pkg.N) of Long_Float;\n+   for Darray3'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray3) return Darray3;\n+   procedure Add (X, Y : not null access Darray3; R : not null access Darray3);\n+\n+end Vect2;"}, {"sha": "804e10caebc14391288f0655b424bb99dc5284ef", "filename": "gcc/testsuite/gnat.dg/vect2_pkg.ads", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect2_pkg.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,6 @@\n+package Vect2_Pkg is\n+\n+   function K return Positive;\n+   function N return Positive;\n+\n+end Vect2_Pkg;"}, {"sha": "3baa6388e17a4f0548155f8b910fc671acf29ef1", "filename": "gcc/testsuite/gnat.dg/vect3.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3.adb?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,93 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-O3 -msse2 -fdump-tree-vect-details\" }\n+\n+package body Vect3 is\n+\n+   function \"+\" (X, Y : Varray) return Varray is\n+      R : Varray (X'Range);\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Varray; R : not null access Varray) is\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Sarray) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Sarray; R : not null access Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray1) return Darray1 is\n+      R : Darray1;\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray1; R : not null access Darray1) is\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray2) return Darray2 is\n+      R : Darray2;\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray2; R : not null access Darray2) is\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X, Y : Darray3) return Darray3 is\n+      R : Darray3;\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X, Y : not null access Darray3; R : not null access Darray3) is\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y(I);\n+      end loop;\n+   end;\n+\n+end Vect3;\n+\n+-- { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 10 \"vect\"  } }\n+-- { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "d78e3c44cfff09fbac33c19426e58f3a79dae6a6", "filename": "gcc/testsuite/gnat.dg/vect3.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,43 @@\n+with Vect3_Pkg;\n+\n+package Vect3 is\n+\n+   -- Unconstrained array types are vectorizable, possibly with special\n+   -- help for the programmer\n+   type Varray is array (Vect3_Pkg.Index_Type range <>) of Long_Float;\n+   for Varray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Varray) return Varray;\n+   procedure Add (X, Y : not null access Varray; R : not null access Varray);\n+\n+\n+   -- Constrained array types are vectorizable\n+   type Sarray is array (Vect3_Pkg.Index_Type(1) .. Vect3_Pkg.Index_Type(4))\n+     of Long_Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X, Y : Sarray) return Sarray;\n+   procedure Add (X, Y : not null access Sarray; R : not null access Sarray);\n+\n+\n+   type Darray1 is array (Vect3_Pkg.Index_Type(1) .. Vect3_Pkg.N) of Long_Float;\n+   for Darray1'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray1) return Darray1;\n+   procedure Add (X, Y : not null access Darray1; R : not null access Darray1);\n+\n+\n+   type Darray2 is array (Vect3_Pkg.K .. Vect3_Pkg.Index_Type(4)) of Long_Float;\n+   for Darray2'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray2) return Darray2;\n+   procedure Add (X, Y : not null access Darray2; R : not null access Darray2);\n+\n+\n+   type Darray3 is array (Vect3_Pkg.K .. Vect3_Pkg.N) of Long_Float;\n+   for Darray3'Alignment use 16;\n+\n+   function \"+\" (X, Y : Darray3) return Darray3;\n+   procedure Add (X, Y : not null access Darray3; R : not null access Darray3);\n+\n+end Vect3;"}, {"sha": "8c926bbcd6aa0496151fe7831f74f96f9797cf10", "filename": "gcc/testsuite/gnat.dg/vect3_pkg.ads", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect3_pkg.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,10 @@\n+with System;\n+\n+package Vect3_Pkg is\n+\n+   type Index_Type is mod System.Memory_Size;\n+\n+   function K return Index_Type;\n+   function N return Index_Type;\n+\n+end Vect3_Pkg;"}, {"sha": "032a72893944947bb472ff43823116603571d5f3", "filename": "gcc/testsuite/gnat.dg/vect4.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4.adb?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,93 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-O3 -msse2 -fdump-tree-vect-details\" }\n+\n+package body Vect4 is\n+\n+   function \"+\" (X : Varray; Y : Long_Float) return Varray is\n+      R : Varray (X'Range);\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Varray; Y : Long_Float; R : not null access Varray) is\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Sarray; Y : Long_Float) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Sarray; Y : Long_Float; R : not null access Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray1; Y : Long_Float) return Darray1 is\n+      R : Darray1;\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray1; Y : Long_Float; R : not null access Darray1) is\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray2; Y : Long_Float) return Darray2 is\n+      R : Darray2;\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray2; Y : Long_Float; R : not null access Darray2) is\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray3; Y : Long_Float) return Darray3 is\n+      R : Darray3;\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray3; Y : Long_Float; R : not null access Darray3) is\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+end Vect4;\n+\n+-- { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 10 \"vect\"  } }\n+-- { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "98df7efeebc12978274456f4e11467d49a829ed1", "filename": "gcc/testsuite/gnat.dg/vect4.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,42 @@\n+with Vect4_Pkg;\n+\n+package Vect4 is\n+\n+   -- Unconstrained array types are vectorizable, possibly with special\n+   -- help for the programmer\n+   type Varray is array (Integer range <>) of Long_Float;\n+   for Varray'Alignment use 16;\n+\n+   function \"+\" (X : Varray; Y : Long_Float) return Varray;\n+   procedure Add (X : not null access Varray; Y : Long_Float; R : not null access Varray);\n+\n+\n+   -- Constrained array types are vectorizable\n+   type Sarray is array (1 .. 4) of Long_Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X : Sarray; Y : Long_Float) return Sarray;\n+   procedure Add (X : not null access Sarray; Y : Long_Float; R : not null access Sarray);\n+\n+\n+   type Darray1 is array (1 .. Vect4_Pkg.N) of Long_Float;\n+   for Darray1'Alignment use 16;\n+\n+   function \"+\" (X : Darray1; Y : Long_Float) return Darray1;\n+   procedure Add (X : not null access Darray1; Y : Long_Float; R : not null access Darray1);\n+\n+\n+   type Darray2 is array (Vect4_Pkg.K .. 4) of Long_Float;\n+   for Darray2'Alignment use 16;\n+\n+   function \"+\" (X : Darray2; Y : Long_Float) return Darray2;\n+   procedure Add (X : not null access Darray2; Y : Long_Float; R : not null access Darray2);\n+\n+\n+   type Darray3 is array (Vect4_Pkg.K .. Vect4_Pkg.N) of Long_Float;\n+   for Darray3'Alignment use 16;\n+\n+   function \"+\" (X : Darray3; Y : Long_Float) return Darray3;\n+   procedure Add (X : not null access Darray3; Y : Long_Float; R : not null access Darray3);\n+\n+end Vect4;"}, {"sha": "2e0008d0a714f9f8717339de763a4119a225ee8e", "filename": "gcc/testsuite/gnat.dg/vect4_pkg.ads", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect4_pkg.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,6 @@\n+package Vect4_Pkg is\n+\n+   function K return Integer;\n+   function N return Integer;\n+\n+end Vect4_Pkg;"}, {"sha": "98af2c01d54193ab8ae7d4a59b920df8b86592d8", "filename": "gcc/testsuite/gnat.dg/vect5.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5.adb?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,93 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-O3 -msse2 -fdump-tree-vect-details\" }\n+\n+package body Vect5 is\n+\n+   function \"+\" (X : Varray; Y : Long_Float) return Varray is\n+      R : Varray (X'Range);\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Varray; Y : Long_Float; R : not null access Varray) is\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Sarray; Y : Long_Float) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Sarray; Y : Long_Float; R : not null access Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray1; Y : Long_Float) return Darray1 is\n+      R : Darray1;\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray1; Y : Long_Float; R : not null access Darray1) is\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray2; Y : Long_Float) return Darray2 is\n+      R : Darray2;\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray2; Y : Long_Float; R : not null access Darray2) is\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray3; Y : Long_Float) return Darray3 is\n+      R : Darray3;\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray3; Y : Long_Float; R : not null access Darray3) is\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+end Vect5;\n+\n+-- { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 10 \"vect\"  } }\n+-- { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "09e798aecb210aa9c4b4bf098ae3dca814d7413c", "filename": "gcc/testsuite/gnat.dg/vect5.ads", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,42 @@\n+with Vect5_Pkg;\n+\n+package Vect5 is\n+\n+   -- Unconstrained array types are vectorizable, possibly with special\n+   -- help for the programmer\n+   type Varray is array (Positive range <>) of Long_Float;\n+   for Varray'Alignment use 16;\n+\n+   function \"+\" (X : Varray; Y : Long_Float) return Varray;\n+   procedure Add (X : not null access Varray; Y : Long_Float; R : not null access Varray);\n+\n+\n+   -- Constrained array types are vectorizable\n+   type Sarray is array (Positive (1) .. Positive (4)) of Long_Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X : Sarray; Y : Long_Float) return Sarray;\n+   procedure Add (X : not null access Sarray; Y : Long_Float; R : not null access Sarray);\n+\n+\n+   type Darray1 is array (Positive(1) .. Vect5_Pkg.N) of Long_Float;\n+   for Darray1'Alignment use 16;\n+\n+   function \"+\" (X : Darray1; Y : Long_Float) return Darray1;\n+   procedure Add (X : not null access Darray1; Y : Long_Float; R : not null access Darray1);\n+\n+\n+   type Darray2 is array (Vect5_Pkg.K .. Positive(4)) of Long_Float;\n+   for Darray2'Alignment use 16;\n+\n+   function \"+\" (X : Darray2; Y : Long_Float) return Darray2;\n+   procedure Add (X : not null access Darray2; Y : Long_Float; R : not null access Darray2);\n+\n+\n+   type Darray3 is array (Vect5_Pkg.K .. Vect5_Pkg.N) of Long_Float;\n+   for Darray3'Alignment use 16;\n+\n+   function \"+\" (X : Darray3; Y : Long_Float) return Darray3;\n+   procedure Add (X : not null access Darray3; Y : Long_Float; R : not null access Darray3);\n+\n+end Vect5;"}, {"sha": "9eb752eedb218db84e3252e5e0adc0d45f78ad31", "filename": "gcc/testsuite/gnat.dg/vect5_pkg.ads", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect5_pkg.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,6 @@\n+package Vect5_Pkg is\n+\n+   function K return Positive;\n+   function N return Positive;\n+\n+end Vect5_Pkg;"}, {"sha": "425f2a703623f9d855e70491fb43e6339dce9b9d", "filename": "gcc/testsuite/gnat.dg/vect6.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6.adb?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,93 @@\n+-- { dg-do compile { target i?86-*-* x86_64-*-* } }\n+-- { dg-options \"-O3 -msse2 -fdump-tree-vect-details\" }\n+\n+package body Vect6 is\n+\n+   function \"+\" (X : Varray; Y : Long_Float) return Varray is\n+      R : Varray (X'Range);\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Varray; Y : Long_Float; R : not null access Varray) is\n+   begin\n+      for I in X'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Sarray; Y : Long_Float) return Sarray is\n+      R : Sarray;\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Sarray; Y : Long_Float; R : not null access Sarray) is\n+   begin\n+      for I in Sarray'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray1; Y : Long_Float) return Darray1 is\n+      R : Darray1;\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray1; Y : Long_Float; R : not null access Darray1) is\n+   begin\n+      for I in Darray1'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray2; Y : Long_Float) return Darray2 is\n+      R : Darray2;\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray2; Y : Long_Float; R : not null access Darray2) is\n+   begin\n+      for I in Darray2'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+\n+   function \"+\" (X : Darray3; Y : Long_Float) return Darray3 is\n+      R : Darray3;\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+      return R;\n+   end;\n+\n+   procedure Add (X : not null access Darray3; Y : Long_Float; R : not null access Darray3) is\n+   begin\n+      for I in Darray3'Range loop\n+         R(I) := X(I) + Y;\n+      end loop;\n+   end;\n+\n+end Vect6;\n+\n+-- { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 10 \"vect\"  } }\n+-- { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "013fe13652ebc2e38e788f1289e98fb89fed96e6", "filename": "gcc/testsuite/gnat.dg/vect6.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,43 @@\n+with Vect6_Pkg;\n+\n+package Vect6 is\n+\n+   -- Unconstrained array types are vectorizable, possibly with special\n+   -- help for the programmer\n+   type Varray is array (Vect6_Pkg.Index_Type range <>) of Long_Float;\n+   for Varray'Alignment use 16;\n+\n+   function \"+\" (X : Varray; Y : Long_Float) return Varray;\n+   procedure Add (X : not null access Varray; Y : Long_Float; R : not null access Varray);\n+\n+\n+   -- Constrained array types are vectorizable\n+   type Sarray is array (Vect6_Pkg.Index_Type(1) .. Vect6_Pkg.Index_Type(4))\n+     of Long_Float;\n+   for Sarray'Alignment use 16;\n+\n+   function \"+\" (X : Sarray; Y : Long_Float) return Sarray;\n+   procedure Add (X : not null access Sarray; Y : Long_Float; R : not null access Sarray);\n+\n+\n+   type Darray1 is array (Vect6_Pkg.Index_Type(1) .. Vect6_Pkg.N) of Long_Float;\n+   for Darray1'Alignment use 16;\n+\n+   function \"+\" (X : Darray1; Y : Long_Float) return Darray1;\n+   procedure Add (X : not null access Darray1; Y : Long_Float; R : not null access Darray1);\n+\n+\n+   type Darray2 is array (Vect6_Pkg.K .. Vect6_Pkg.Index_Type(4)) of Long_Float;\n+   for Darray2'Alignment use 16;\n+\n+   function \"+\" (X : Darray2; Y : Long_Float) return Darray2;\n+   procedure Add (X : not null access Darray2; Y : Long_Float; R : not null access Darray2);\n+\n+\n+   type Darray3 is array (Vect6_Pkg.K .. Vect6_Pkg.N) of Long_Float;\n+   for Darray3'Alignment use 16;\n+\n+   function \"+\" (X : Darray3; Y : Long_Float) return Darray3;\n+   procedure Add (X : not null access Darray3; Y : Long_Float; R : not null access Darray3);\n+\n+end Vect6;"}, {"sha": "7db734a359f81f9f8f714df9e473aee526e9916e", "filename": "gcc/testsuite/gnat.dg/vect6_pkg.ads", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvect6_pkg.ads?ref=15bf7d19d4a0dc2eed0ae5dcac5cdb3a35ec7db8", "patch": "@@ -0,0 +1,10 @@\n+with System;\n+\n+package Vect6_Pkg is\n+\n+   type Index_Type is mod System.Memory_Size;\n+\n+   function K return Index_Type;\n+   function N return Index_Type;\n+\n+end Vect6_Pkg;"}]}