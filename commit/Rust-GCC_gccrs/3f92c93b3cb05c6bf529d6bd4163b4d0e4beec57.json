{"sha": "3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y5MmM5M2IzY2IwNWM2YmY1MjlkNmJkNDE2M2I0ZDBlNGJlZWM1Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-09T10:29:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-09T10:29:09Z"}, "message": "[multiple changes]\n\n2009-07-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Precondition): Do not analyze the\n\tcondition, to prevent generation of visible code during expansion,\n\twhen Check is not enabled.\n\n2009-07-09  Gary Dismukes  <dismukes@adacore.com>\n\n\t* checks.adb (Install_Static_Check): Call Possible_Local_Raise so that\n\tthe check gets registered for any available local handler\n\t(Set_Local_Raise).\n\n\t* sem_util.adb: Add with and use of Exp_Ch11.\n\t(Apply_Compile_Time_Constraint_Error): Call Possible_Local_Raise so\n\tthat the check gets registered for any available local handler.\n\n\t* exp_ch4.adb (Expand_N_Slice): Remove call to Enable_Range_Check\n\ton slice ranges.\n\n2009-07-09  Steve Baird  <baird@adacore.com>\n\n\t* exp_ch11.adb (Force_Static_Allocation_Of_Referenced_Objects): New\n\tfunction.\n\t(Expand_N_Exception_Declaration): Fix handling of exceptions\n\tdeclared in a subprogram.\n\nFrom-SVN: r149413", "tree": {"sha": "9ef2c3b88ec0004f8860549feec8bccde0e38af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef2c3b88ec0004f8860549feec8bccde0e38af0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/comments", "author": null, "committer": null, "parents": [{"sha": "f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cf5b85eaeb6eecadf7010c1b99e809023a4d6d"}], "stats": {"total": 147, "additions": 116, "deletions": 31}, "files": [{"sha": "e63554a17485137bf71e4b6fec5d14abc9768726", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "patch": "@@ -1,3 +1,29 @@\n+2009-07-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Precondition): Do not analyze the\n+\tcondition, to prevent generation of visible code during expansion,\n+\twhen Check is not enabled.\n+\n+2009-07-09  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* checks.adb (Install_Static_Check): Call Possible_Local_Raise so that\n+\tthe check gets registered for any available local handler\n+\t(Set_Local_Raise).\n+\n+\t* sem_util.adb: Add with and use of Exp_Ch11.\n+\t(Apply_Compile_Time_Constraint_Error): Call Possible_Local_Raise so\n+\tthat the check gets registered for any available local handler.\n+\n+\t* exp_ch4.adb (Expand_N_Slice): Remove call to Enable_Range_Check\n+\ton slice ranges.\n+\n+2009-07-09  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_ch11.adb (Force_Static_Allocation_Of_Referenced_Objects): New\n+\tfunction.\n+\t(Expand_N_Exception_Declaration): Fix handling of exceptions\n+\tdeclared in a subprogram.\n+\n 2009-07-09  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-nmsc.adb (Find_Sources): Avoid error messages from gprbuild from"}, {"sha": "bf689b4254809d123a7d7e014344a832798849d9", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "patch": "@@ -5458,6 +5458,10 @@ package body Checks is\n       Set_Etype (R_Cno, Typ);\n       Set_Raises_Constraint_Error (R_Cno);\n       Set_Is_Static_Expression (R_Cno, Stat);\n+\n+      --  Now deal with possible local raise handling\n+\n+      Possible_Local_Raise (R_Cno, Standard_Constraint_Error);\n    end Install_Static_Check;\n \n    ---------------------"}, {"sha": "21f878b579a929c6bc25a412b1fc7e37a633bc98", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1178,6 +1178,79 @@ package body Exp_Ch11 is\n       Exname      : constant Node_Id :=\n                       Make_Defining_Identifier (Loc, Name_Exname);\n \n+      procedure Force_Static_Allocation_Of_Referenced_Objects\n+        (Aggregate : Node_Id);\n+      --  A specialized solution to one particular case of an ugly problem\n+      --\n+      --  The given aggregate includes an Unchecked_Conversion as one of the\n+      --  component values. The call to Analyze_And_Resolve below ends up\n+      --  calling Exp_Ch4.Expand_N_Unchecked_Type_Conversion, which may decide\n+      --  to introduce a (constant) temporary and then obtain the component\n+      --  value by evaluating the temporary.\n+      --\n+      --  In the case of an exception declared within a subprogram (or any\n+      --  other dynamic scope), this is a bad transformation. The exception\n+      --  object is marked as being Statically_Allocated but the temporary is\n+      --  not. If the initial value of a Statically_Allocated declaration\n+      --  references a dynamically allocated object, this prevents static\n+      --  initialization of the object.\n+      --\n+      --  We cope with this here by marking the temporary Statically_Allocated.\n+      --  It might seem cleaner to generalize this utility and then use it to\n+      --  enforce a rule that the entities referenced in the declaration of any\n+      --  \"hoisted\" (i.e., Is_Statically_Allocated and not Is_Library_Level)\n+      --  entity must also be either Library_Level or hoisted. It turns out\n+      --  that this would be incompatible with the current treatment of an\n+      --  object which is local to a subprogram, subject to an Export pragma,\n+      --  not subject to an address clause, and whose declaration contains\n+      --  references to other local (non-hoisted) objects (e.g., in the initial\n+      --  value expression).\n+\n+      ---------------------------------------------------\n+      -- Force_Static_Allocation_Of_Referenced_Objects --\n+      ---------------------------------------------------\n+\n+      procedure Force_Static_Allocation_Of_Referenced_Objects\n+        (Aggregate : Node_Id)\n+      is\n+         function Fixup_Node (N : Node_Id) return Traverse_Result;\n+         --  If the given node references a dynamically allocated object, then\n+         --  correct the declaration of the object.\n+\n+         ----------------\n+         -- Fixup_Node --\n+         ----------------\n+\n+         function Fixup_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) in N_Has_Entity\n+              and then Present (Entity (N))\n+              and then not Is_Library_Level_Entity (Entity (N))\n+\n+              --  Note: the following test is not needed but it seems cleaner\n+              --  to do this test (this would be more important if procedure\n+              --  Force_Static_Allocation_Of_Referenced_Objects recursively\n+              --  traversed the declaration of an entity after marking it as\n+              --  statically allocated).\n+\n+              and then not Is_Statically_Allocated (Entity (N))\n+            then\n+               Set_Is_Statically_Allocated (Entity (N));\n+            end if;\n+\n+            return OK;\n+         end Fixup_Node;\n+\n+         procedure Fixup_Tree is new Traverse_Proc (Fixup_Node);\n+\n+      --  Start of processing for Force_Static_Allocation_Of_Referenced_Objects\n+\n+      begin\n+         Fixup_Tree (Aggregate);\n+      end Force_Static_Allocation_Of_Referenced_Objects;\n+\n+   --  Start of processing for Expand_N_Exception_Declaration\n+\n    begin\n       --  There is no expansion needed when compiling for the JVM since the\n       --  JVM has a built-in exception mechanism. See 4jexcept.ads for details.\n@@ -1193,7 +1266,9 @@ package body Exp_Ch11 is\n           Defining_Identifier => Exname,\n           Constant_Present    => True,\n           Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n-          Expression => Make_String_Literal (Loc, Full_Qualified_Name (Id))));\n+          Expression          =>\n+            Make_String_Literal (Loc,\n+              Strval => Full_Qualified_Name (Id))));\n \n       Set_Is_Statically_Allocated (Exname);\n \n@@ -1238,6 +1313,8 @@ package body Exp_Ch11 is\n       Set_Expression (N, Make_Aggregate (Loc, Expressions => L));\n       Analyze_And_Resolve (Expression (N), Etype (Id));\n \n+      Force_Static_Allocation_Of_Referenced_Objects (Expression (N));\n+\n       --  Register_Exception (except'Unchecked_Access);\n \n       if not No_Exception_Handlers_Set"}, {"sha": "22179e0b58899ffab4050591e2fee006409784df", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "patch": "@@ -7448,32 +7448,6 @@ package body Exp_Ch4 is\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pfx);\n       end if;\n \n-      --  Range checks are potentially also needed for cases involving a slice\n-      --  indexed by a subtype indication, but Do_Range_Check can currently\n-      --  only be set for expressions ???\n-\n-      if not Index_Checks_Suppressed (Ptp)\n-        and then (not Is_Entity_Name (Pfx)\n-                   or else not Index_Checks_Suppressed (Entity (Pfx)))\n-        and then Nkind (Discrete_Range (N)) /= N_Subtype_Indication\n-\n-         --  Do not enable range check to nodes associated with the frontend\n-         --  expansion of the dispatch table. We first check if Ada.Tags is\n-         --  already loaded to avoid the addition of an undesired dependence\n-         --  on such run-time unit.\n-\n-        and then\n-          (not Tagged_Type_Expansion\n-            or else not\n-             (RTU_Loaded (Ada_Tags)\n-               and then Nkind (Prefix (N)) = N_Selected_Component\n-               and then Present (Entity (Selector_Name (Prefix (N))))\n-               and then Entity (Selector_Name (Prefix (N))) =\n-                                  RTE_Record_Component (RE_Prims_Ptr)))\n-      then\n-         Enable_Range_Check (Discrete_Range (N));\n-      end if;\n-\n       --  The remaining case to be handled is packed slices. We can leave\n       --  packed slices as they are in the following situations:\n "}, {"sha": "885d1b885db06b00d6d682bb2a4c626443c898dc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "patch": "@@ -9697,16 +9697,15 @@ package body Sem_Prag is\n             --  If in spec, nothing more to do. If in body, then we convert the\n             --  pragma to pragma Check (Precondition, cond [, msg]). Note we do\n             --  this whether or not precondition checks are enabled. That works\n-            --  fine since pragma Check will do this check.\n+            --  fine since pragma Check will do this check, and will also\n+            --  analyze the condition itself in the proper context.\n \n             if In_Body then\n                if Arg_Count = 2 then\n                   Check_Optional_Identifier (Arg3, Name_Message);\n                   Analyze_And_Resolve (Get_Pragma_Arg (Arg2), Standard_String);\n                end if;\n \n-               Analyze_And_Resolve (Get_Pragma_Arg (Arg1), Standard_Boolean);\n-\n                Rewrite (N,\n                  Make_Pragma (Loc,\n                    Chars => Name_Check,"}, {"sha": "c2706007a7081bf4e4d9f5f6c46c6487c8bf534c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3f92c93b3cb05c6bf529d6bd4163b4d0e4beec57", "patch": "@@ -29,6 +29,7 @@ with Checks;   use Checks;\n with Debug;    use Debug;\n with Errout;   use Errout;\n with Elists;   use Elists;\n+with Exp_Ch11; use Exp_Ch11;\n with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -268,6 +269,10 @@ package body Sem_Util is\n       Set_Etype (N, Rtyp);\n       Set_Raises_Constraint_Error (N);\n \n+      --  Now deal with possible local raise handling\n+\n+      Possible_Local_Raise (N, Standard_Constraint_Error);\n+\n       --  If the original expression was marked as static, the result is\n       --  still marked as static, but the Raises_Constraint_Error flag is\n       --  always set so that further static evaluation is not attempted."}]}