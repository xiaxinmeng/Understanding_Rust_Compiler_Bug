{"sha": "1dd3915be108e6dcd7adfa01de6096419092a5de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRkMzkxNWJlMTA4ZTZkY2Q3YWRmYTAxZGU2MDk2NDE5MDkyYTVkZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-09-19T08:13:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-19T08:13:29Z"}, "message": "[Ada] Streamline comparison for equality of 2-element arrays\n\nIn the general case, the comparison for equality of array objects is\nimplemented by a local function that contains, among other things, a\nloop running over the elements, comparing them one by one and exiting\nas soon as an element is not the same in the two array objects.\n\nFor the specific case of constrained 2-element arrays, this is rather\nheavy and unnecessarily obfuscates the control flow of the program,\nso this change implements a simple conjunction of comparisons for it.\n\nRunning these commands:\n\n  gcc -c p.ads -O -gnatD\n  grep loop p.ads.dg\n\nOn the following sources:\n\npackage P is\n\n  type Rec is record\n    Re : Float;\n    Im : Float;\n  end record;\n\n  type Arr is array (1 .. 2) of Rec;\n\n  function Equal (A, B : Arr) return Boolean is (A = B);\n\nend P;\n\nShould execute silently.\n\n2019-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_Array_Equality): If optimization is\n\tenabled, generate a simple conjunction of comparisons for the\n\tspecific case of constrained 1-dimensional 2-element arrays.\n\tFix formatting.\n\nFrom-SVN: r275941", "tree": {"sha": "42ffcfdfd44bf6e5926e9edee4bc052bc0357912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42ffcfdfd44bf6e5926e9edee4bc052bc0357912"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dd3915be108e6dcd7adfa01de6096419092a5de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dd3915be108e6dcd7adfa01de6096419092a5de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dd3915be108e6dcd7adfa01de6096419092a5de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dd3915be108e6dcd7adfa01de6096419092a5de/comments", "author": null, "committer": null, "parents": [{"sha": "c4f372c54f24fd24f1092fb6a09c31c7733ce8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4f372c54f24fd24f1092fb6a09c31c7733ce8cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4f372c54f24fd24f1092fb6a09c31c7733ce8cc"}], "stats": {"total": 131, "additions": 96, "deletions": 35}, "files": [{"sha": "37576aaee5c08861796e65e098b2e3df4c4f42cd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dd3915be108e6dcd7adfa01de6096419092a5de/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dd3915be108e6dcd7adfa01de6096419092a5de/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1dd3915be108e6dcd7adfa01de6096419092a5de", "patch": "@@ -1,3 +1,10 @@\n+2019-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Array_Equality): If optimization is\n+\tenabled, generate a simple conjunction of comparisons for the\n+\tspecific case of constrained 1-dimensional 2-element arrays.\n+\tFix formatting.\n+\n 2019-09-19  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* exp_dbug.ads, exp_dbug.adb (Get_Homonym_Number): Remove."}, {"sha": "82145b42a197392aed2ca129e6417c8a69506cc8", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 89, "deletions": 35, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dd3915be108e6dcd7adfa01de6096419092a5de/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dd3915be108e6dcd7adfa01de6096419092a5de/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=1dd3915be108e6dcd7adfa01de6096419092a5de", "patch": "@@ -1582,7 +1582,7 @@ package body Exp_Ch4 is\n       Index_List1 : constant List_Id    := New_List;\n       Index_List2 : constant List_Id    := New_List;\n \n-      Actuals   : List_Id;\n+      First_Idx : Node_Id;\n       Formals   : List_Id;\n       Func_Name : Entity_Id;\n       Func_Body : Node_Id;\n@@ -1594,6 +1594,10 @@ package body Exp_Ch4 is\n       Rtyp : Entity_Id;\n       --  The parameter types to be used for the formals\n \n+      New_Lhs : Node_Id;\n+      New_Rhs : Node_Id;\n+      --  The LHS and RHS converted to the parameter types\n+\n       function Arr_Attr\n         (Arr : Entity_Id;\n          Nam : Name_Id;\n@@ -1962,6 +1966,82 @@ package body Exp_Ch4 is\n          pragma Assert (Ltyp = Rtyp);\n       end if;\n \n+      --  If the array type is distinct from the type of the arguments, it\n+      --  is the full view of a private type. Apply an unchecked conversion\n+      --  to ensure that analysis of the code below succeeds.\n+\n+      if No (Etype (Lhs))\n+        or else Base_Type (Etype (Lhs)) /= Base_Type (Ltyp)\n+      then\n+         New_Lhs := OK_Convert_To (Ltyp, Lhs);\n+      else\n+         New_Lhs := Lhs;\n+      end if;\n+\n+      if No (Etype (Rhs))\n+        or else Base_Type (Etype (Rhs)) /= Base_Type (Rtyp)\n+      then\n+         New_Rhs := OK_Convert_To (Rtyp, Rhs);\n+      else\n+         New_Rhs := Rhs;\n+      end if;\n+\n+      First_Idx := First_Index (Ltyp);\n+\n+      --  If optimization is enabled and the array boils down to a couple of\n+      --  consecutive elements, generate a simple conjunction of comparisons\n+      --  which should be easier to optimize by the code generator.\n+\n+      if Optimization_Level > 0\n+        and then Ltyp = Rtyp\n+        and then Is_Constrained (Ltyp)\n+        and then Number_Dimensions (Ltyp) = 1\n+        and then Nkind (First_Idx) = N_Range\n+        and then Compile_Time_Known_Value (Low_Bound (First_Idx))\n+        and then Compile_Time_Known_Value (High_Bound (First_Idx))\n+        and then Expr_Value (High_Bound (First_Idx)) =\n+                                         Expr_Value (Low_Bound (First_Idx)) + 1\n+      then\n+         declare\n+            Ctyp         : constant Entity_Id := Component_Type (Ltyp);\n+            L, R         : Node_Id;\n+            TestL, TestH : Node_Id;\n+            Index_List   : List_Id;\n+\n+         begin\n+            Index_List := New_List (New_Copy_Tree (Low_Bound (First_Idx)));\n+\n+            L :=\n+              Make_Indexed_Component (Loc,\n+                Prefix      => New_Copy_Tree (New_Lhs),\n+                Expressions => Index_List);\n+\n+            R :=\n+              Make_Indexed_Component (Loc,\n+                Prefix      => New_Copy_Tree (New_Rhs),\n+                Expressions => Index_List);\n+\n+            TestL := Expand_Composite_Equality (Nod, Ctyp, L, R, Bodies);\n+\n+            Index_List := New_List (New_Copy_Tree (High_Bound (First_Idx)));\n+\n+            L :=\n+              Make_Indexed_Component (Loc,\n+                Prefix      => New_Lhs,\n+                Expressions => Index_List);\n+\n+            R :=\n+              Make_Indexed_Component (Loc,\n+                Prefix      => New_Rhs,\n+                Expressions => Index_List);\n+\n+            TestH := Expand_Composite_Equality (Nod, Ctyp, L, R, Bodies);\n+\n+            return\n+              Make_And_Then (Loc, Left_Opnd => TestL, Right_Opnd => TestH);\n+         end;\n+      end if;\n+\n       --  Build list of formals for function\n \n       Formals := New_List (\n@@ -2004,46 +2084,20 @@ package body Exp_Ch4 is\n                     Make_Simple_Return_Statement (Loc,\n                       Expression => New_Occurrence_Of (Standard_False, Loc)))),\n \n-                Handle_One_Dimension (1, First_Index (Ltyp)),\n+                Handle_One_Dimension (1, First_Idx),\n \n                 Make_Simple_Return_Statement (Loc,\n                   Expression => New_Occurrence_Of (Standard_True, Loc)))));\n \n-         Set_Has_Completion (Func_Name, True);\n-         Set_Is_Inlined (Func_Name);\n-\n-         --  If the array type is distinct from the type of the arguments, it\n-         --  is the full view of a private type. Apply an unchecked conversion\n-         --  to ensure that analysis of the call succeeds.\n-\n-         declare\n-            L, R : Node_Id;\n-\n-         begin\n-            L := Lhs;\n-            R := Rhs;\n-\n-            if No (Etype (Lhs))\n-              or else Base_Type (Etype (Lhs)) /= Base_Type (Ltyp)\n-            then\n-               L := OK_Convert_To (Ltyp, Lhs);\n-            end if;\n-\n-            if No (Etype (Rhs))\n-              or else Base_Type (Etype (Rhs)) /= Base_Type (Rtyp)\n-            then\n-               R := OK_Convert_To (Rtyp, Rhs);\n-            end if;\n-\n-            Actuals := New_List (L, R);\n-         end;\n+      Set_Has_Completion (Func_Name, True);\n+      Set_Is_Inlined (Func_Name);\n \n-         Append_To (Bodies, Func_Body);\n+      Append_To (Bodies, Func_Body);\n \n-         return\n-           Make_Function_Call (Loc,\n-             Name                   => New_Occurrence_Of (Func_Name, Loc),\n-             Parameter_Associations => Actuals);\n+      return\n+        Make_Function_Call (Loc,\n+          Name                   => New_Occurrence_Of (Func_Name, Loc),\n+          Parameter_Associations => New_List (New_Lhs, New_Rhs));\n    end Expand_Array_Equality;\n \n    -----------------------------"}]}