{"sha": "7cc273ade8609756edc2d4f9f58975fc90beb9e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjMjczYWRlODYwOTc1NmVkYzJkNGY5ZjU4OTc1ZmM5MGJlYjllOA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gnu.ai.mit.edu", "date": "1997-12-12T06:20:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-12T06:20:41Z"}, "message": "objc-act.c (lang_report_error_function): Disable.\n\n        * objc/objc-act.c (lang_report_error_function): Disable.\n        * objc/objc-parse.y: Include \"output.h\".\n        (yyerror): Remove redundant decl.\n        (yyprint): Fix prototype.\n        (apply_args_register_offset): Remove redundant decl.\n        (get_file_function_name): Likewise.\n\nFrom-SVN: r17057", "tree": {"sha": "bc84c24a77d228cd3e1edbf24e58c4ba2acdd88e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc84c24a77d228cd3e1edbf24e58c4ba2acdd88e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc273ade8609756edc2d4f9f58975fc90beb9e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc273ade8609756edc2d4f9f58975fc90beb9e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc273ade8609756edc2d4f9f58975fc90beb9e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc273ade8609756edc2d4f9f58975fc90beb9e8/comments", "author": null, "committer": null, "parents": [{"sha": "ab23f7879dbd2a9e5f102d001791335f1cf2e938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab23f7879dbd2a9e5f102d001791335f1cf2e938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab23f7879dbd2a9e5f102d001791335f1cf2e938"}], "stats": {"total": 180, "additions": 170, "deletions": 10}, "files": [{"sha": "f5cad23bb3be307744be1c9e5770e1effe12bdeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc273ade8609756edc2d4f9f58975fc90beb9e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc273ade8609756edc2d4f9f58975fc90beb9e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cc273ade8609756edc2d4f9f58975fc90beb9e8", "patch": "@@ -1,3 +1,12 @@\n+Thu Dec 11 23:06:48 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)\n+\n+\t* objc/objc-act.c (lang_report_error_function): Disable.\n+\t* objc/objc-parse.y: Include \"output.h\".\n+\t(yyerror): Remove redundant decl.\n+\t(yyprint): Fix prototype.\n+\t(apply_args_register_offset): Remove redundant decl.\n+\t(get_file_function_name): Likewise.\n+\n Thu Dec 11 22:02:10 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* flow.c (find_basic_blocks): A CALL_INSN that can throw starts"}, {"sha": "44d859e35b30bef9fdcd2410f8507feff7b135f3", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 159, "deletions": 7, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc273ade8609756edc2d4f9f58975fc90beb9e8/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc273ade8609756edc2d4f9f58975fc90beb9e8/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=7cc273ade8609756edc2d4f9f58975fc90beb9e8", "patch": "@@ -38,8 +38,8 @@ Boston, MA 02111-1307, USA.  */\n \n    - OBJC_INT_SELECTORS  */\n \n-#include <stdio.h>\n #include \"config.h\"\n+#include <stdio.h>\n #include \"tree.h\"\n #include \"c-tree.h\"\n #include \"c-lex.h\"\n@@ -48,7 +48,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"input.h\"\n #include \"except.h\"\n #include \"function.h\"\n-\n+#include <string.h>\n+#include \"output.h\"\n \n /* This is the default way of generating a method name.  */\n /* I am not sure it is really correct.\n@@ -188,8 +189,14 @@ static tree init_selector\t\t\tPROTO((int));\n static tree build_keyword_selector\t\tPROTO((tree));\n static tree synth_id_with_class_suffix\t\tPROTO((char *, tree));\n \n-/* From expr.c */\n-extern int apply_args_register_offset           PROTO((int));\n+static void generate_static_references\t\tPROTO((void));\n+static int check_methods_accessible\t\tPROTO((tree, tree,\n+\t\t\t\t\t\t       int));\n+static void encode_aggregate_within\t\tPROTO((tree, int, int,\n+\t\t\t\t\t               char, char));\n+\n+/* We handle printing method names ourselves for ObjC */\n+extern char *(*decl_printable_name) ();\n \n /* Misc. bookkeeping */\n \n@@ -227,6 +234,8 @@ enum string_section\n \n static tree add_objc_string\t\t\tPROTO((tree,\n \t\t\t\t\t\t       enum string_section));\n+static tree get_objc_string_decl\t\tPROTO((tree,\n+\t\t\t\t\t\t       enum string_section));\n static tree build_objc_string_decl\t\tPROTO((tree,\n \t\t\t\t\t\t       enum string_section));\n static tree build_selector_reference_decl\tPROTO((tree));\n@@ -502,6 +511,75 @@ int flag_warn_protocol = 1;\n \n static int generating_instance_variables = 0;\n \n+/* Tells the compiler that this is a special run.  Do not perform\n+   any compiling, instead we are to test some platform dependent\n+   features and output a C header file with appropriate definitions. */\n+\n+static int print_struct_values = 0;\n+\n+/* Some platforms pass small structures through registers versus through\n+   an invisible pointer.  Determine at what size structure is the \n+   transition point between the two possibilities. */\n+\n+void\n+generate_struct_by_value_array ()\n+{\n+  tree type;\n+  tree field_decl, field_decl_chain;\n+  int i, j;\n+  int aggregate_in_mem[32];\n+  int found = 0;\n+\n+  /* Presumbaly no platform passes 32 byte structures in a register. */\n+  for (i = 1; i < 32; i++)\n+    {\n+      char buffer[5];\n+\n+      /* Create an unnamed struct that has `i' character components */\n+      type = start_struct (RECORD_TYPE, NULL_TREE);\n+\n+      strcpy (buffer, \"c1\");\n+      field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t\tchar_type_node,\n+\t\t\t\t\tbuffer);\n+      field_decl_chain = field_decl;\n+\n+      for (j = 1; j < i; j++)\n+\t{\n+\t  sprintf (buffer, \"c%d\", j + 1);\n+\t  field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t\t    char_type_node,\n+\t\t\t\t\t    buffer);\n+\t  chainon (field_decl_chain, field_decl);\n+\t}\n+      finish_struct (type, field_decl_chain, NULL_TREE);\n+ \n+      aggregate_in_mem[i] = aggregate_value_p (type);\n+      if (!aggregate_in_mem[i])\n+\tfound = 1;\n+    }\n+ \n+  /* We found some structures that are returned in registers instead of memory\n+     so output the necessary data. */\n+  if (found)\n+    {\n+      for (i = 31; i >= 0;  i--)\n+\tif (!aggregate_in_mem[i])\n+\t  break;\n+      printf (\"#define OBJC_MAX_STRUCT_BY_VALUE %d\\n\\n\", i);\n+ \n+      /* The first member of the structure is always 0 because we don't handle\n+\t structures with 0 members */\n+      printf (\"static int struct_forward_array[] = {\\n  0\");\n+ \n+      for (j = 1; j <= i; j++)\n+\tprintf (\", %d\", aggregate_in_mem[j]);\n+      printf (\"\\n};\\n\");\n+    }\n+ \n+  exit (0);\n+}\n+\n void\n lang_init ()\n {\n@@ -550,6 +628,9 @@ lang_init ()\n \n   if (doing_objc_thang)\n     init_objc ();\n+\n+  if (print_struct_values)\n+    generate_struct_by_value_array ();\n }\n \n static void\n@@ -603,6 +684,8 @@ lang_decode_option (p)\n     flag_next_runtime = 1;\n   else if (!strcmp (p, \"-fnext-runtime\"))\n     flag_next_runtime = 1;\n+  else if (!strcmp (p, \"-print-objc-runtime-info\"))\n+    print_struct_values = 1;\n   else\n     return c_decode_option (p);\n \n@@ -1643,7 +1726,6 @@ build_module_descriptor ()\n   {\n     tree parms, function_decl, decelerator, void_list_node;\n     tree function_type;\n-    extern tree get_file_function_name ();\n     tree init_function_name = get_file_function_name ('I');\n \n     /* Declare void __objc_execClass (void *); */\n@@ -1743,7 +1825,7 @@ get_objc_string_decl (ident, section)\n /* Output references to all statically allocated objects.  Return the DECL\n    for the array built.  */\n \n-static tree\n+static void\n generate_static_references ()\n {\n   tree decls = NULL_TREE, ident, decl_spec, expr_decl, expr = NULL_TREE;\n@@ -7193,6 +7275,7 @@ finish_method_def ()\n   method_context = NULL_TREE;\n }\n \n+#if 0\n int\n lang_report_error_function (decl)\n       tree decl;\n@@ -7207,6 +7290,7 @@ lang_report_error_function (decl)\n   else\n     return 0;\n }\n+#endif\n \n static int\n is_complex_decl (type)\n@@ -7863,6 +7947,71 @@ dump_interface (fp, chain)\n   fprintf (fp, \"\\n@end\");\n }\n \n+/* Demangle function for Objective-C */\n+static const char *\n+objc_demangle (mangled)\n+     const char *mangled;\n+{\n+  char *demangled, *cp;\n+\n+  if (mangled[0] == '_' &&\n+      (mangled[1] == 'i' || mangled[1] == 'c') &&\n+      mangled[2] == '_')\n+    {\n+      cp = demangled = xmalloc(strlen(mangled) + 2);\n+      if (mangled[1] == 'i')\n+\t*cp++ = '-';            /* for instance method */\n+      else\n+\t*cp++ = '+';            /* for class method */\n+      *cp++ = '[';              /* opening left brace */\n+      strcpy(cp, mangled+3);    /* tack on the rest of the mangled name */\n+      while (*cp && *cp == '_')\n+\tcp++;                   /* skip any initial underbars in class name */\n+      cp = strchr(cp, '_');     /* find first non-initial underbar */\n+      if (cp == NULL)\n+\t{\n+\t  free(demangled);      /* not mangled name */\n+\t  return mangled;\n+\t}\n+      if (cp[1] == '_')  /* easy case: no category name */\n+\t{\n+\t  *cp++ = ' ';            /* replace two '_' with one ' ' */\n+\t  strcpy(cp, mangled + (cp - demangled) + 2);\n+\t}\n+      else\n+\t{\n+\t  *cp++ = '(';            /* less easy case: category name */\n+\t  cp = strchr(cp, '_');\n+\t  if (cp == 0)\n+\t    {\n+\t      free(demangled);    /* not mangled name */\n+\t      return mangled;\n+\t    }\n+\t  *cp++ = ')';\n+\t  *cp++ = ' ';            /* overwriting 1st char of method name... */\n+\t  strcpy(cp, mangled + (cp - demangled)); /* get it back */\n+\t}\n+      while (*cp && *cp == '_')\n+\tcp++;                   /* skip any initial underbars in method name */\n+      for (; *cp; cp++)\n+\tif (*cp == '_')\n+\t  *cp = ':';            /* replace remaining '_' with ':' */\n+      *cp++ = ']';              /* closing right brace */\n+      *cp++ = 0;                /* string terminator */\n+      return demangled;\n+    }\n+  else\n+    return mangled;             /* not an objc mangled name */\n+}\n+\n+static const char *\n+objc_printable_name (decl, kind)\n+     tree decl;\n+     char **kind;\n+{\n+  return objc_demangle (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+}\n+\n static void\n init_objc ()\n {\n@@ -7898,6 +8047,9 @@ init_objc ()\n   errbuf = (char *)xmalloc (BUFSIZE);\n   hash_init ();\n   synth_module_prologue ();\n+\n+  /* Change the default error function */\n+  decl_printable_name = (char* (*)()) objc_printable_name;\n }\n \f\n static void\n@@ -7917,7 +8069,7 @@ finish_objc ()\n #endif\n \n   /* Process the static instances here because initialization of objc_symtab\n-     dependens on them. */\n+     depends on them. */\n   if (objc_static_instances)\n     generate_static_references ();\n "}, {"sha": "2b4cca9d9ca8e7e5910fada102bfb571bfde8e4f", "filename": "gcc/objc/objc-parse.y", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc273ade8609756edc2d4f9f58975fc90beb9e8/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc273ade8609756edc2d4f9f58975fc90beb9e8/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=7cc273ade8609756edc2d4f9f58975fc90beb9e8", "patch": "@@ -42,6 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-lex.h\"\n #include \"c-tree.h\"\n #include \"flags.h\"\n+#include \"output.h\"\n \n #ifdef MULTIBYTE_CHARS\n #include <stdlib.h>\n@@ -58,8 +59,6 @@ char *language_string = \"GNU Obj-C\";\n extern int errno;\n #endif\n \n-void yyerror ();\n-\n /* Like YYERROR but do call yyerror.  */\n #define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n \n@@ -232,7 +231,7 @@ int objc_public_flag;\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint ();\n+extern void yyprint \t\t\tPROTO ((FILE *, int, YYSTYPE));\n %}\n \f\n %%"}]}