{"sha": "740b77b675fc26c64e5e305992a199585e703a2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQwYjc3YjY3NWZjMjZjNjRlNWUzMDU5OTJhMTk5NTg1ZTcwM2EyZA==", "commit": {"author": {"name": "Andrew Cagney", "email": "ac131313@redhat.com", "date": "2002-03-24T19:53:49Z"}, "committer": {"name": "Andrew Cagney", "email": "cagney@gcc.gnu.org", "date": "2002-03-24T19:53:49Z"}, "message": "stmt.c (check_for_full_enumeration_handling): Remove tests of warn_switch.\n\n* stmt.c (check_for_full_enumeration_handling): Remove tests of\nwarn_switch.  Update description.\n(expand_end_case_type): Call check_for_full_enumeration_handling\nwhen warn_switch.\n\nFrom-SVN: r51270", "tree": {"sha": "d4f78a94e6d6591fb03bf3519c587f44bb3f1f0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f78a94e6d6591fb03bf3519c587f44bb3f1f0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/740b77b675fc26c64e5e305992a199585e703a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740b77b675fc26c64e5e305992a199585e703a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740b77b675fc26c64e5e305992a199585e703a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740b77b675fc26c64e5e305992a199585e703a2d/comments", "author": null, "committer": null, "parents": [{"sha": "c61f581f322d0a30d4f1f37a9fb13cbdf1c48fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c61f581f322d0a30d4f1f37a9fb13cbdf1c48fbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c61f581f322d0a30d4f1f37a9fb13cbdf1c48fbf"}], "stats": {"total": 127, "additions": 69, "deletions": 58}, "files": [{"sha": "c8c100dffc7f12dc3a845fa882d0f9572b38bfa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740b77b675fc26c64e5e305992a199585e703a2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740b77b675fc26c64e5e305992a199585e703a2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=740b77b675fc26c64e5e305992a199585e703a2d", "patch": "@@ -1,3 +1,10 @@\n+2002-03-24  Andrew Cagney  <ac131313@redhat.com>\n+\n+\t* stmt.c (check_for_full_enumeration_handling): Remove tests of\n+\twarn_switch.  Update description.\n+\t(expand_end_case_type): Call check_for_full_enumeration_handling\n+\twhen warn_switch.\n+\n 2002-03-24  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.c (m68hc11_autoinc_compatible_p): New function."}, {"sha": "5823f8b0497a7c65266f6f0dac80b5f2c05a7100", "filename": "gcc/stmt.c", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740b77b675fc26c64e5e305992a199585e703a2d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740b77b675fc26c64e5e305992a199585e703a2d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=740b77b675fc26c64e5e305992a199585e703a2d", "patch": "@@ -5094,16 +5094,23 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n     }\n }\n \n-/* Called when the index of a switch statement is an enumerated type\n-   and there is no default label.\n+/* Given a switch statement with an expression that is an enumeration\n+   type, warn if any of the enumeration type's literals are not\n+   covered by the case expressions of the switch.  Also, warn if there\n+   are any extra switch cases that are *not* elements of the\n+   enumerated type.\n \n-   Checks that all enumeration literals are covered by the case\n-   expressions of a switch.  Also, warn if there are any extra\n-   switch cases that are *not* elements of the enumerated type.\n+   Historical note:\n \n-   If all enumeration literals were covered by the case expressions,\n-   turn one of the expressions into the default expression since it should\n-   not be possible to fall through such a switch.  */\n+   At one stage this function would: ``If all enumeration literals\n+   were covered by the case expressions, turn one of the expressions\n+   into the default expression since it should not be possible to fall\n+   through such a switch.''\n+\n+   That code has since been removed as: ``This optimization is\n+   disabled because it causes valid programs to fail.  ANSI C does not\n+   guarantee that an expression with enum type will have a value that\n+   is the same as one of the enumeration literals.''  */\n \n void\n check_for_full_enumeration_handling (type)\n@@ -5125,9 +5132,6 @@ check_for_full_enumeration_handling (type)\n   /* The allocated size of cases_seen, in chars.  */\n   HOST_WIDE_INT bytes_needed;\n \n-  if (! warn_switch)\n-    return;\n-\n   size = all_cases_count (type, &sparseness);\n   bytes_needed = (size + HOST_BITS_PER_CHAR) / HOST_BITS_PER_CHAR;\n \n@@ -5165,49 +5169,48 @@ check_for_full_enumeration_handling (type)\n       && case_stack->data.case_stmt.case_list->left)\n     case_stack->data.case_stmt.case_list\n       = case_tree2list (case_stack->data.case_stmt.case_list, 0);\n-  if (warn_switch)\n-    for (n = case_stack->data.case_stmt.case_list; n; n = n->right)\n-      {\n-\tfor (chain = TYPE_VALUES (type);\n-\t     chain && !tree_int_cst_equal (n->low, TREE_VALUE (chain));\n-\t     chain = TREE_CHAIN (chain))\n-\t  ;\n-\n-\tif (!chain)\n-\t  {\n-\t    if (TYPE_NAME (type) == 0)\n-\t      warning (\"case value `%ld' not in enumerated type\",\n-\t\t       (long) TREE_INT_CST_LOW (n->low));\n-\t    else\n-\t      warning (\"case value `%ld' not in enumerated type `%s'\",\n-\t\t       (long) TREE_INT_CST_LOW (n->low),\n-\t\t       IDENTIFIER_POINTER ((TREE_CODE (TYPE_NAME (type))\n-\t\t\t\t\t    == IDENTIFIER_NODE)\n-\t\t\t\t\t   ? TYPE_NAME (type)\n-\t\t\t\t\t   : DECL_NAME (TYPE_NAME (type))));\n-\t  }\n-\tif (!tree_int_cst_equal (n->low, n->high))\n-\t  {\n-\t    for (chain = TYPE_VALUES (type);\n-\t\t chain && !tree_int_cst_equal (n->high, TREE_VALUE (chain));\n-\t\t chain = TREE_CHAIN (chain))\n-\t      ;\n-\n-\t    if (!chain)\n-\t      {\n-\t\tif (TYPE_NAME (type) == 0)\n-\t\t  warning (\"case value `%ld' not in enumerated type\",\n-\t\t\t   (long) TREE_INT_CST_LOW (n->high));\n-\t\telse\n-\t\t  warning (\"case value `%ld' not in enumerated type `%s'\",\n-\t\t\t   (long) TREE_INT_CST_LOW (n->high),\n-\t\t\t   IDENTIFIER_POINTER ((TREE_CODE (TYPE_NAME (type))\n-\t\t\t\t\t\t== IDENTIFIER_NODE)\n-\t\t\t\t\t       ? TYPE_NAME (type)\n-\t\t\t\t\t       : DECL_NAME (TYPE_NAME (type))));\n-\t      }\n-\t  }\n-      }\n+  for (n = case_stack->data.case_stmt.case_list; n; n = n->right)\n+    {\n+      for (chain = TYPE_VALUES (type);\n+\t   chain && !tree_int_cst_equal (n->low, TREE_VALUE (chain));\n+\t   chain = TREE_CHAIN (chain))\n+\t;\n+      \n+      if (!chain)\n+\t{\n+\t  if (TYPE_NAME (type) == 0)\n+\t    warning (\"case value `%ld' not in enumerated type\",\n+\t\t     (long) TREE_INT_CST_LOW (n->low));\n+\t  else\n+\t    warning (\"case value `%ld' not in enumerated type `%s'\",\n+\t\t     (long) TREE_INT_CST_LOW (n->low),\n+\t\t     IDENTIFIER_POINTER ((TREE_CODE (TYPE_NAME (type))\n+\t\t\t\t\t  == IDENTIFIER_NODE)\n+\t\t\t\t\t ? TYPE_NAME (type)\n+\t\t\t\t\t : DECL_NAME (TYPE_NAME (type))));\n+\t}\n+      if (!tree_int_cst_equal (n->low, n->high))\n+\t{\n+\t  for (chain = TYPE_VALUES (type);\n+\t       chain && !tree_int_cst_equal (n->high, TREE_VALUE (chain));\n+\t       chain = TREE_CHAIN (chain))\n+\t    ;\n+\t  \n+\t  if (!chain)\n+\t    {\n+\t      if (TYPE_NAME (type) == 0)\n+\t\twarning (\"case value `%ld' not in enumerated type\",\n+\t\t\t (long) TREE_INT_CST_LOW (n->high));\n+\t      else\n+\t\twarning (\"case value `%ld' not in enumerated type `%s'\",\n+\t\t\t (long) TREE_INT_CST_LOW (n->high),\n+\t\t\t IDENTIFIER_POINTER ((TREE_CODE (TYPE_NAME (type))\n+\t\t\t\t\t      == IDENTIFIER_NODE)\n+\t\t\t\t\t     ? TYPE_NAME (type)\n+\t\t\t\t\t     : DECL_NAME (TYPE_NAME (type))));\n+\t    }\n+\t}\n+    }\n }\n \n /* Free CN, and its children.  */\n@@ -5275,11 +5278,12 @@ expand_end_case_type (orig_index, orig_type)\n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n   if (index_type != error_mark_node)\n     {\n-      /* If switch expression was an enumerated type, check that all\n-\t enumeration literals are covered by the cases.\n-\t No sense trying this if there's a default case, however.  */\n+      /* If the switch expression was an enumerated type, check that\n+\t exactly all enumeration literals are covered by the cases.\n+\t The check is made -Wswitch was specified and there is no\n+\t default case.  */\n \n-      if (!thiscase->data.case_stmt.default_label\n+      if ((warn_switch && !thiscase->data.case_stmt.default_label)\n \t  && TREE_CODE (orig_type) == ENUMERAL_TYPE\n \t  && TREE_CODE (index_expr) != INTEGER_CST)\n \tcheck_for_full_enumeration_handling (orig_type);"}]}