{"sha": "a70ad3bb3e56ff95a717b80842d4b56a2b680856", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcwYWQzYmIzZTU2ZmY5NWE3MTdiODA4NDJkNGI1NmEyYjY4MDg1Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-09-26T18:10:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-09-26T18:10:58Z"}, "message": "re PR middle-end/25261 ([gomp] Nested function calls in #pragma omp parallel blocks)\n\n\tPR middle-end/25261\n\tPR middle-end/28790\n\t* tree-nested.c (struct nesting_info): Added static_chain_added.\n\t(convert_call_expr): Set static_chain_added when adding static\n\tchain.  Handle OMP_PARALLEL and OMP_SECTION.\n\n\t* gcc.dg/gomp/nestedfn-1.c: New test.\n\n\t* testsuite/libgomp.c/nestedfn-4.c: New test.\n\t* testsuite/libgomp.c/nestedfn-5.c: New test.\n\t* testsuite/libgomp.fortran/nestedfn3.f90: New test.\n\nFrom-SVN: r117235", "tree": {"sha": "363a6e44b0cedce330dc22f91e904959a53d14b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/363a6e44b0cedce330dc22f91e904959a53d14b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a70ad3bb3e56ff95a717b80842d4b56a2b680856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70ad3bb3e56ff95a717b80842d4b56a2b680856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70ad3bb3e56ff95a717b80842d4b56a2b680856", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70ad3bb3e56ff95a717b80842d4b56a2b680856/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b9e4cd6a909fd68c16d27c7f011300933db2f10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b9e4cd6a909fd68c16d27c7f011300933db2f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b9e4cd6a909fd68c16d27c7f011300933db2f10"}], "stats": {"total": 241, "additions": 238, "deletions": 3}, "files": [{"sha": "4a167ddb47abbcf5bbfd2adb7b4b2522528ad8e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -1,3 +1,11 @@\n+2006-09-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/25261\n+\tPR middle-end/28790\n+\t* tree-nested.c (struct nesting_info): Added static_chain_added.\n+\t(convert_call_expr): Set static_chain_added when adding static\n+\tchain.  Handle OMP_PARALLEL and OMP_SECTION.\n+\n 2006-09-25  Matthias Klose  <doko@debian.org>\n \n \t* doc/invoke.texi: Add missing full stop."}, {"sha": "836f23615cd547a788b8cfe239836720b7d806a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -1,3 +1,9 @@\n+2006-09-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/25261\n+\tPR middle-end/28790\n+\t* gcc.dg/gomp/nestedfn-1.c: New test.\n+\n 2006-09-26  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR objc/29195"}, {"sha": "8532d8af1aff548bc6df1dc92bbf4641ab754a38", "filename": "gcc/testsuite/gcc.dg/gomp/nestedfn-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnestedfn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnestedfn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnestedfn-1.c?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -0,0 +1,53 @@\n+/* This testcase violates the OpenMP requirements, as nested functions\n+   access the original variables.\n+   We test it just to make sure we don't ICE on it.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+extern void abort (void);\n+extern int omp_get_thread_num ();\n+extern void omp_set_dynamic (int);\n+\n+int\n+main (void)\n+{\n+  int j = 0, k = 6, l = 7, m = 8;\n+  void foo (void)\n+  {\n+    int i = 5;\n+    int bar (void)\n+    {\n+      return i + 1 + (j > 100 ? 10000 : 0);\n+    }\n+#pragma omp sections private (i)\n+    {\n+#pragma omp section\n+      {\n+\ti = 6;\n+\tif (bar () != 6)\n+#pragma omp atomic\n+\t  ++j;\n+      }\n+#pragma omp section\n+      {\n+\tif (bar () != 6)\n+#pragma omp atomic\n+\t  ++j;\n+      }\n+    }\n+    if (k != 6 || l != 7 || m != 8)\n+#pragma omp atomic\n+      ++j;\n+  }\n+  omp_set_dynamic (0);\n+#pragma omp parallel num_threads (2) firstprivate (k) shared (l) private (m)\n+  {\n+    if (omp_get_thread_num () != 0)\n+      k += omp_get_thread_num ();\n+    m = 9;\n+    foo ();\n+  }\n+  if (j)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "7467dca84e6a2611849d9317ead2849291fa6d87", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -1,5 +1,5 @@\n /* Nested function decomposition for trees.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -104,6 +104,7 @@ struct nesting_info GTY ((chain_next (\"%h.next\")))\n \n   bool any_parm_remapped;\n   bool any_tramp_created;\n+  char static_chain_added;\n };\n \n \n@@ -1626,6 +1627,8 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp, decl, target_context;\n+  char save_static_chain_added;\n+  int i;\n \n   *walk_subtrees = 0;\n   switch (TREE_CODE (t))\n@@ -1636,8 +1639,12 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n \tbreak;\n       target_context = decl_function_context (decl);\n       if (target_context && !DECL_NO_STATIC_CHAIN (decl))\n-\tTREE_OPERAND (t, 2)\n-\t  = get_static_chain (info, target_context, &wi->tsi);\n+\t{\n+\t  TREE_OPERAND (t, 2)\n+\t    = get_static_chain (info, target_context, &wi->tsi);\n+\t  info->static_chain_added\n+\t    |= (1 << (info->context != target_context));\n+\t}\n       break;\n \n     case RETURN_EXPR:\n@@ -1647,8 +1654,36 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n       *walk_subtrees = 1;\n       break;\n \n+    case OMP_PARALLEL:\n+      save_static_chain_added = info->static_chain_added;\n+      info->static_chain_added = 0;\n+      walk_body (convert_call_expr, info, &OMP_PARALLEL_BODY (t));\n+      for (i = 0; i < 2; i++)\n+\t{\n+\t  tree c, decl;\n+\t  if ((info->static_chain_added & (1 << i)) == 0)\n+\t    continue;\n+\t  decl = i ? get_chain_decl (info) : info->frame_decl;\n+\t  /* Don't add CHAIN.* or FRAME.* twice.  */\n+\t  for (c = OMP_PARALLEL_CLAUSES (t); c; c = OMP_CLAUSE_CHAIN (c))\n+\t    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED)\n+\t\t&& OMP_CLAUSE_DECL (c) == decl)\n+\t      break;\n+\t  if (c == NULL)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_FIRSTPRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = decl;\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);\n+\t      OMP_PARALLEL_CLAUSES (t) = c;\n+\t    }\n+\t}\n+      info->static_chain_added |= save_static_chain_added;\n+      break;\n+\n     case OMP_FOR:\n     case OMP_SECTIONS:\n+    case OMP_SECTION:\n     case OMP_SINGLE:\n     case OMP_MASTER:\n     case OMP_ORDERED:"}, {"sha": "a4c470cc70317df776ec6606b8f65f4464e74720", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -1,5 +1,11 @@\n 2006-09-26  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/25261\n+\tPR middle-end/28790\n+\t* testsuite/libgomp.c/nestedfn-4.c: New test.\n+\t* testsuite/libgomp.c/nestedfn-5.c: New test.\n+\t* testsuite/libgomp.fortran/nestedfn3.f90: New test.\n+\n \tPR fortran/29097\n \t* testsuite/libgomp.fortran/condinc1.f: New test.\n \t* testsuite/libgomp.fortran/condinc2.f: New test."}, {"sha": "dbe1062bddc274bcb19b861306e213af61360668", "filename": "libgomp/testsuite/libgomp.c/nestedfn-4.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-4.c?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -0,0 +1,65 @@\n+/* PR middle-end/25261 */\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  int i = 5, j, l = 0;\n+  int foo (void)\n+  {\n+    return i == 6;\n+  }\n+  int bar (void)\n+  {\n+    return i - 3;\n+  }\n+\n+  omp_set_dynamic (0);\n+\n+#pragma omp parallel if (foo ()) num_threads (2)\n+  if (omp_get_num_threads () != 1)\n+#pragma omp atomic\n+    l++;\n+\n+#pragma omp parallel for schedule (static, bar ()) num_threads (2) \\\n+\t\t     reduction (|:l)\n+  for (j = 0; j < 4; j++)\n+    if (omp_get_thread_num () != (j >= 2))\n+#pragma omp atomic\n+      l++;\n+\n+  i++;\n+\n+#pragma omp parallel if (foo ()) num_threads (2)\n+  if (omp_get_num_threads () != 2)\n+#pragma omp atomic\n+    l++;\n+\n+#pragma omp parallel for schedule (static, bar ()) num_threads (2) \\\n+\t\t     reduction (|:l)\n+  for (j = 0; j < 6; j++)\n+    if (omp_get_thread_num () != (j >= 3))\n+#pragma omp atomic\n+      l++;\n+\n+#pragma omp parallel num_threads (4) reduction (|:l)\n+  if (!foo () || bar () != 3)\n+#pragma omp atomic\n+      l++;\n+\n+  i++;\n+\n+#pragma omp parallel num_threads (4) reduction (|:l)\n+  if (foo () || bar () != 4)\n+#pragma omp atomic\n+      l++;\n+\n+  if (l)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "6072b1fe369022e3467087a5ddb1d44ebc7b9694", "filename": "libgomp/testsuite/libgomp.c/nestedfn-5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-5.c?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+\n+void\n+foo (int *j)\n+{\n+  int i = 5;\n+  int bar (void) { return i + 1; }\n+#pragma omp sections\n+  {\n+    #pragma omp section\n+      {\n+\tif (bar () != 6)\n+\t#pragma omp atomic\n+\t  ++*j;\n+      }\n+    #pragma omp section\n+      {\n+\tif (bar () != 6)\n+\t#pragma omp atomic\n+\t  ++*j;\n+      }\n+  }\n+}\n+\n+int\n+main (void)\n+{\n+  int j = 0;\n+#pragma omp parallel num_threads (2)\n+  foo (&j);\n+  if (j)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "454749c54851c0f3a8da94f68ee6e69bca1517e8", "filename": "libgomp/testsuite/libgomp.fortran/nestedfn3.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70ad3bb3e56ff95a717b80842d4b56a2b680856/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn3.f90?ref=a70ad3bb3e56ff95a717b80842d4b56a2b680856", "patch": "@@ -0,0 +1,24 @@\n+! PR middle-end/28790\n+! { dg-do run }\n+\n+program nestomp\n+  integer :: j\n+  j = 8\n+  call bar\n+  if (j.ne.10) call abort\n+contains\n+  subroutine foo (i)\n+    integer :: i\n+  !$omp atomic\n+    j = j + i - 5\n+  end subroutine\n+  subroutine bar\n+  use omp_lib\n+  integer :: i\n+  i = 6\n+  call omp_set_dynamic (.false.)\n+  !$omp parallel num_threads (2)\n+    call foo(i)\n+  !$omp end parallel\n+  end subroutine\n+end"}]}