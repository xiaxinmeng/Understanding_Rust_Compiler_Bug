{"sha": "d8e178a02b6adccbbbef668c0374a95b466d11b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlMTc4YTAyYjZhZGNjYmJiZWY2NjhjMDM3NGE5NWI0NjZkMTFiMA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-03-26T07:45:00Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-03-26T07:45:00Z"}, "message": "Warning fixes:\n\n        * call.c (op_error): Const-ify a char*.\n        (add_candidate, source_type, add_warning): Add static prototype.\n        (print_z_candidates): Const-ify a char*.\n        * class.c (resolve_address_of_overloaded_function,\n        fixed_type_or_null, build_vtable_entry_ref): Add static prototype.\n        (get_vtable_name, finish_struct_1): Const-ify a char*.\n        * cvt.c (convert_to_reference): Likewise.\n        * decl.c (redeclaration_error_message, record_builtin_type,\n        record_unknown_type, member_function_or_else, bad_specifiers):\n        Likewise.\n        (find_binding, select_decl, unqualified_namespace_lookup,\n        lookup_flags, qualify_lookup, record_builtin_java_type, tag_name):\n        Add static prototype.\n        (warn_extern_redeclared_static, duplicate_decls, pushdecl,\n        implicitly_declare, record_builtin_java_type, define_function,\n        grok_op_properties, tag_name): Const-ify a char*.\n        * cp-tree.h (FORMAT_VBASE_NAME): Allow parameter `BUF' to be const.\n        (define_function, finish_builtin_type): Const-ify a char*.\n        (cp_error, cp_error_at, cp_warning, cp_warning_at, cp_pedwarn,\n        cp_pedwarn_at, cp_compiler_error, cp_sprintf): Add prototype args.\n        (file_name_nondirectory): Const-ify a char*.\n        (init_filename_times): Don't prototype.\n        (compiler_error): Prototype.\n        (yyerror, init_repo): Const-ify a char*.\n        (build_srcloc): Don't prototype.\n        (build_x_indirect_ref, build_indirect_ref, build_component_addr):\n        Const-ify a char*.\n        (warn_for_assignment): Don't prototype.\n        (convert_for_initialization, readonly_error, check_for_new_type,\n        GNU_xref_begin, GNU_xref_file, GNU_xref_ref, GNU_xref_call):\n        Const-ify a char*.\n        * decl2.c (acceptable_java_type, output_vtable_inherit,\n        setup_initp, start_objects, finish_objects, do_dtors, do_ctors,\n        merge_functions, decl_namespace, validate_nonmember_using_decl,\n        do_nonmember_using_decl): Add static prototype.\n        (lang_f_options): Const-ify a char*.\n        (finish_builtin_type): Likewise.\n        (add_function, arg_assoc_namespace, arg_assoc_class): Add static\n        prototype.\n        * errfn.c: Include cp-tree.h.\n        (cp_thing): Add static prototype.\n        (compiler_error): Don't protoptype.\n        (cp_compiler_error): Cast `compiler_error' to `errorfn' before\n        passing it to `cp_thing'.\n        * error.c (interesting_scope_p): Add static prototype.\n        * except.c (build_eh_type_type, build_eh_type_type_ref): Const-ify\n        a char*.\n        * init.c (compiler_error): Don't prototype.\n        (member_init_ok_or_else): Const-ify a char*.\n        (build_java_class_ref): Add static prototype.\n        * lex.c (compiler_error): Don't prototype.\n        (get_time_identifier, interface_strcmp, extend_token_buffer,\n        handle_cp_pragma): Const-ify a char*.\n        (is_global, init_filename_times): Add static prototype.\n        (file_name_nondirectory, cplus_tree_code_name): Const-ify a char*.\n        (compiler_error): Change from fixed args to variable args.\n        (yyerror): Const-ify a char*.\n        * parse.y (cond_stmt_keyword): Const-ify a char*.\n        (parse_decl): Add static prototype.\n        * pt.c (template_args_equal, print_template_context): Likewise.\n        (print_candidates, check_default_tmpl_args): Const-ify a char*.\n        (instantiate_class_template): Likewise.\n        * repo.c (get_base_filename, open_repo_file, init_repo): Likewise.\n        * rtti.c (call_void_fn, expand_generic_desc, expand_si_desc,\n        expand_class_desc, expand_ptr_desc, expand_attr_desc): Likewise.\n        * search.c (lookup_field_info, lookup_member): Likewise.\n        (lookup_member): Cast the first argument of `bzero' to a PTR.\n        * sig.c (compiler_error): Don't prototype.\n        (build_signature_pointer_or_reference_nam): Const-ify a char*.\n        (get_sigtable_name, build_member_function_pointer): Likewise.\n        * tree.c (compiler_error): Don't prototype.\n        (no_linkage_helper, build_srcloc): Add static prototype.\n        (build_vbase_pointer_fields): Const-ify a char*.\n        (__eprintf): Don't unnecessarily handle `const' when !__STDC__.\n        * typeck.c (compiler_error): Don't prototype.\n        (convert_for_assignment): Const-ify a char*.\n        (comp_cv_target_types): Add static prototype.\n        (build_x_indirect_ref, build_indirect_ref, convert_arguments,\n        build_component_addr, build_unary_op, convert_for_initialization):\n        Const-ify a char*.\n        * typeck2.c (ack): Add static prototype and change from fixed args\n        to variable args.\n        (readonly_error, check_for_new_type): Const-ify a char*.\n        * xref.c (_XREF_FILE, find_file, filename, fctname, declname,\n        fixname, open_xref_file, classname, GNU_xref_begin): Likewise.\n        (GNU_xref_file): Likewise.  Also use `xmalloc' instead of `malloc'.\n        (GNU_xref_end_scope, GNU_xref_ref, GNU_xref_decl, GNU_xref_call,\n        gen_assign, GNU_xref_member): Const-ify a char*.\n\nFrom-SVN: r25994", "tree": {"sha": "075d74c3c5bdfacc3f051fa291e0d746c4bb5b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/075d74c3c5bdfacc3f051fa291e0d746c4bb5b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8e178a02b6adccbbbef668c0374a95b466d11b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e178a02b6adccbbbef668c0374a95b466d11b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e178a02b6adccbbbef668c0374a95b466d11b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e178a02b6adccbbbef668c0374a95b466d11b0/comments", "author": null, "committer": null, "parents": [{"sha": "142413745029dfc6147595a843ed06b4b2d2c4ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142413745029dfc6147595a843ed06b4b2d2c4ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142413745029dfc6147595a843ed06b4b2d2c4ce"}], "stats": {"total": 2163, "additions": 1160, "deletions": 1003}, "files": [{"sha": "14254ece8f3a886cd92122b4fbb963142b2c7ece", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -1,3 +1,114 @@\n+Fri Mar 26 10:20:34 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* call.c (op_error): Const-ify a char*.\n+\t(add_candidate, source_type, add_warning): Add static prototype.\n+\t(print_z_candidates): Const-ify a char*.\n+\n+\t* class.c (resolve_address_of_overloaded_function,\n+\tfixed_type_or_null, build_vtable_entry_ref): Add static prototype.\n+\t(get_vtable_name, finish_struct_1): Const-ify a char*.\n+\n+\t* cvt.c (convert_to_reference): Likewise.\n+\n+\t* decl.c (redeclaration_error_message, record_builtin_type,\n+ \trecord_unknown_type, member_function_or_else, bad_specifiers):\n+ \tLikewise.\n+\t(find_binding, select_decl, unqualified_namespace_lookup,\n+\tlookup_flags, qualify_lookup, record_builtin_java_type, tag_name):\n+\tAdd static prototype.\n+\t(warn_extern_redeclared_static, duplicate_decls, pushdecl,\n+\timplicitly_declare, record_builtin_java_type, define_function,\n+\tgrok_op_properties, tag_name): Const-ify a char*.\n+\n+\t* cp-tree.h (FORMAT_VBASE_NAME): Allow parameter `BUF' to be const.\n+\t(define_function, finish_builtin_type): Const-ify a char*.\n+\t(cp_error, cp_error_at, cp_warning, cp_warning_at, cp_pedwarn,\n+\tcp_pedwarn_at, cp_compiler_error, cp_sprintf): Add prototype args.\n+\t(file_name_nondirectory): Const-ify a char*.\n+\t(init_filename_times): Don't prototype.\n+\t(compiler_error): Prototype.\n+\t(yyerror, init_repo): Const-ify a char*.\n+\t(build_srcloc): Don't prototype.\n+\t(build_x_indirect_ref, build_indirect_ref, build_component_addr):\n+ \tConst-ify a char*.\n+\t(warn_for_assignment): Don't prototype.\n+\t(convert_for_initialization, readonly_error, check_for_new_type,\n+\tGNU_xref_begin, GNU_xref_file, GNU_xref_ref, GNU_xref_call):\n+\tConst-ify a char*.\n+\n+\t* decl2.c (acceptable_java_type, output_vtable_inherit,\n+\tsetup_initp, start_objects, finish_objects, do_dtors, do_ctors,\n+\tmerge_functions, decl_namespace, validate_nonmember_using_decl,\n+\tdo_nonmember_using_decl): Add static prototype.\n+\t(lang_f_options): Const-ify a char*.\n+\t(finish_builtin_type): Likewise.\n+\t(add_function, arg_assoc_namespace, arg_assoc_class): Add static\n+\tprototype.\n+\n+\t* errfn.c: Include cp-tree.h.\n+\t(cp_thing): Add static prototype.\n+\t(compiler_error): Don't protoptype.\n+\t(cp_compiler_error): Cast `compiler_error' to `errorfn' before\n+\tpassing it to `cp_thing'.\n+\n+\t* error.c (interesting_scope_p): Add static prototype.\n+\n+\t* except.c (build_eh_type_type, build_eh_type_type_ref): Const-ify\n+\ta char*.\n+\n+\t* init.c (compiler_error): Don't prototype.\n+\t(member_init_ok_or_else): Const-ify a char*.\n+\t(build_java_class_ref): Add static prototype.\n+\n+\t* lex.c (compiler_error): Don't prototype.\n+\t(get_time_identifier, interface_strcmp, extend_token_buffer,\n+\thandle_cp_pragma): Const-ify a char*.\n+\t(is_global, init_filename_times): Add static prototype.\n+\t(file_name_nondirectory, cplus_tree_code_name): Const-ify a char*.\n+\t(compiler_error): Change from fixed args to variable args.\n+\t(yyerror): Const-ify a char*.\n+\n+\t* parse.y (cond_stmt_keyword): Const-ify a char*.\n+\t(parse_decl): Add static prototype.\n+\n+\t* pt.c (template_args_equal, print_template_context): Likewise.\n+\t(print_candidates, check_default_tmpl_args): Const-ify a char*.\n+\t(instantiate_class_template): Likewise.\n+\n+\t* repo.c (get_base_filename, open_repo_file, init_repo): Likewise.\n+\n+\t* rtti.c (call_void_fn, expand_generic_desc, expand_si_desc,\n+\texpand_class_desc, expand_ptr_desc, expand_attr_desc): Likewise.\n+\n+\t* search.c (lookup_field_info, lookup_member): Likewise.\n+\t(lookup_member): Cast the first argument of `bzero' to a PTR.\n+\n+\t* sig.c (compiler_error): Don't prototype.\n+\t(build_signature_pointer_or_reference_nam): Const-ify a char*.\n+\t(get_sigtable_name, build_member_function_pointer): Likewise.\n+\n+\t* tree.c (compiler_error): Don't prototype.\n+\t(no_linkage_helper, build_srcloc): Add static prototype.\n+\t(build_vbase_pointer_fields): Const-ify a char*.\n+\t(__eprintf): Don't unnecessarily handle `const' when !__STDC__.\n+\n+\t* typeck.c (compiler_error): Don't prototype.\n+\t(convert_for_assignment): Const-ify a char*.\n+\t(comp_cv_target_types): Add static prototype.\n+\t(build_x_indirect_ref, build_indirect_ref, convert_arguments,\n+\tbuild_component_addr, build_unary_op, convert_for_initialization):\n+\tConst-ify a char*.\n+\n+\t* typeck2.c (ack): Add static prototype and change from fixed args\n+\tto variable args.\n+\t(readonly_error, check_for_new_type): Const-ify a char*.\n+\n+\t* xref.c (_XREF_FILE, find_file, filename, fctname, declname,\n+\tfixname, open_xref_file, classname, GNU_xref_begin): Likewise.\n+\t(GNU_xref_file): Likewise.  Also use `xmalloc' instead of `malloc'.\n+\t(GNU_xref_end_scope, GNU_xref_ref, GNU_xref_decl, GNU_xref_call,\n+\tgen_assign, GNU_xref_member): Const-ify a char*.\n+\n 1999-03-25  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* gxxint.texi: Remove old discussion on copying virtual bases."}, {"sha": "3a1af797657a680bf78b41f85fdb46facaf6c501", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -49,7 +49,7 @@ static int compare_ics PROTO((tree, tree));\n static tree build_over_call PROTO((struct z_candidate *, tree, int));\n static tree convert_like PROTO((tree, tree));\n static void op_error PROTO((enum tree_code, enum tree_code, tree, tree,\n-\t\t\t    tree, char *));\n+\t\t\t    tree, const char *));\n static tree build_object_call PROTO((tree, tree));\n static tree resolve_args PROTO((tree));\n static struct z_candidate * build_user_type_conversion_1\n@@ -90,6 +90,10 @@ static int is_subseq PROTO((tree, tree));\n static int is_properly_derived_from PROTO((tree, tree));\n static int maybe_handle_ref_bind PROTO((tree*, tree*));\n static void maybe_handle_implicit_object PROTO((tree*));\n+static struct z_candidate * add_candidate PROTO((struct z_candidate *,\n+\t\t\t\t\t\t tree, tree, int));\n+static tree source_type PROTO((tree));\n+static void add_warning PROTO((struct z_candidate *, struct z_candidate *));\n \n tree\n build_vfield_ref (datum, type)\n@@ -2085,7 +2089,7 @@ static void\n print_z_candidates (candidates)\n      struct z_candidate *candidates;\n {\n-  char *str = \"candidates are:\";\n+  const char *str = \"candidates are:\";\n   for (; candidates; candidates = candidates->next)\n     {\n       if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n@@ -2518,9 +2522,9 @@ static void\n op_error (code, code2, arg1, arg2, arg3, problem)\n      enum tree_code code, code2;\n      tree arg1, arg2, arg3;\n-     char *problem;\n+     const char *problem;\n {\n-  char * opname\n+  const char * opname\n     = (code == MODIFY_EXPR ? assignop_tab [code2] : opname_tab [code]);\n \n   switch (code)"}, {"sha": "a4daed214bede7f3b10c12c4d0c9f48378374876", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -134,6 +134,10 @@ static void check_member_decl_is_same_in_complete_scope PROTO((tree, tree));\n static tree make_method_vec PROTO((int));\n static void free_method_vec PROTO((tree));\n static tree add_implicitly_declared_members PROTO((tree, int, int, int));\n+static tree fixed_type_or_null PROTO((tree, int *));\n+static tree resolve_address_of_overloaded_function PROTO((tree, tree, int,\n+\t\t\t\t\t\t\t  int, tree));\n+static void build_vtable_entry_ref PROTO((tree, tree, tree));\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -604,7 +608,7 @@ get_vtable_name (type)\n   tree type_id = build_typename_overload (type);\n   char *buf = (char *) alloca (strlen (VTABLE_NAME_FORMAT)\n \t\t\t       + IDENTIFIER_LENGTH (type_id) + 2);\n-  char *ptr = IDENTIFIER_POINTER (type_id);\n+  const char *ptr = IDENTIFIER_POINTER (type_id);\n   int i;\n   for (i = 0; ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++) ;\n #if 0\n@@ -3718,7 +3722,7 @@ finish_struct_1 (t, warn_anon)\n \t\t      \n \t      if (code == UNION_TYPE)\n \t\t{\n-\t\t  char *fie = NULL;\n+\t\t  const char *fie = NULL;\n \t\t  if (TYPE_NEEDS_CONSTRUCTING (type))\n \t\t    fie = \"constructor\";\n \t\t  else if (TYPE_NEEDS_DESTRUCTOR (type))\n@@ -4496,7 +4500,7 @@ finish_struct (t, attributes, warn_anon)\n    *NONNULL is set iff INSTANCE can be known to be nonnull, regardless\n    of our knowledge of its type.  */\n \n-tree\n+static tree\n fixed_type_or_null (instance, nonnull)\n      tree instance;\n      int *nonnull;"}, {"sha": "4e6c024cc41b6e220caae7e4122c76780db9de87", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -2451,10 +2451,11 @@ extern int current_function_parms_stored;\n #endif /* !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL) */\n \n /* Store the vbase pointer field name for type TYPE into pointer BUF.  */\n-#define FORMAT_VBASE_NAME(BUF,TYPE) do {\t\t\t\t\\\n-  BUF = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (TYPE)\t\t\\\n+#define FORMAT_VBASE_NAME(BUF,TYPE) do { \t\t\t\t\\\n+  char *wbuf = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (TYPE)\t\\\n \t\t\t + sizeof (VBASE_NAME) + 1);\t\t\t\\\n-  sprintf (BUF, VBASE_NAME_FORMAT, TYPE_ASSEMBLER_NAME_STRING (TYPE));\t\\\n+  sprintf (wbuf, VBASE_NAME_FORMAT, TYPE_ASSEMBLER_NAME_STRING (TYPE));\t\\\n+  (BUF) = wbuf;\t\t\t\t\t\t\t\t\\\n } while (0)\n \n /* Returns non-zero iff ID_NODE is an IDENTIFIER_NODE whose name is\n@@ -2861,8 +2862,8 @@ extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));\n extern void init_decl_processing\t\tPROTO((void));\n extern int init_type_desc\t\t\tPROTO((void));\n extern tree define_function\n-\tPROTO((char *, tree, enum built_in_function,\n-\t       void (*) (tree), char *));\n+\tPROTO((const char *, tree, enum built_in_function,\n+\t       void (*) (tree), const char *));\n extern tree check_tag_decl\t\t\tPROTO((tree));\n extern void shadow_tag\t\t\t\tPROTO((tree));\n extern tree groktypename\t\t\tPROTO((tree));\n@@ -2940,7 +2941,8 @@ extern tree get_temp_name\t\t\tPROTO((tree, int));\n extern tree get_temp_regvar\t\t\tPROTO((tree, tree));\n extern void finish_anon_union\t\t\tPROTO((tree));\n extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));\n-extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n+extern void finish_builtin_type\t\t\tPROTO((tree, const char *,\n+\t\t\t\t\t\t       tree *, int, tree));\n extern tree coerce_new_type\t\t\tPROTO((tree));\n extern tree coerce_delete_type\t\t\tPROTO((tree));\n extern void comdat_linkage\t\t\tPROTO((tree));\n@@ -2976,14 +2978,15 @@ extern tree handle_class_head\t\t\tPROTO((tree, tree, tree));\n extern tree lookup_arg_dependent                PROTO((tree, tree, tree));\n \n /* in errfn.c */\n-extern void cp_error\t\t\t\t();\n-extern void cp_error_at\t\t\t\t();\n-extern void cp_warning\t\t\t\t();\n-extern void cp_warning_at\t\t\t();\n-extern void cp_pedwarn\t\t\t\t();\n-extern void cp_pedwarn_at\t\t\t();\n-extern void cp_compiler_error\t\t\t();\n-extern void cp_sprintf\t\t\t\t();\n+/* The cp_* functions aren't suitable for ATTRIBUTE_PRINTF. */\n+extern void cp_error\t\t\t\tPVPROTO((const char *, ...));\n+extern void cp_error_at\t\t\t\tPVPROTO((const char *, ...));\n+extern void cp_warning\t\t\t\tPVPROTO((const char *, ...));\n+extern void cp_warning_at\t\t\tPVPROTO((const char *, ...));\n+extern void cp_pedwarn\t\t\t\tPVPROTO((const char *, ...));\n+extern void cp_pedwarn_at\t\t\tPVPROTO((const char *, ...));\n+extern void cp_compiler_error\t\t\tPVPROTO((const char *, ...));\n+extern void cp_sprintf\t\t\t\tPVPROTO((const char *, ...));\n \n /* in error.c */\n extern void init_error\t\t\t\tPROTO((void));\n@@ -3053,15 +3056,14 @@ extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, int));\n /* in input.c */\n \n /* in lex.c */\n-extern char *file_name_nondirectory\t\tPROTO((char *));\n+extern char *file_name_nondirectory\t\tPROTO((const char *));\n extern tree make_pointer_declarator\t\tPROTO((tree, tree));\n extern tree make_reference_declarator\t\tPROTO((tree, tree));\n extern tree make_call_declarator\t\tPROTO((tree, tree, tree, tree));\n extern void set_quals_and_spec\t\t\tPROTO((tree, tree, tree));\n extern char *operator_name_string\t\tPROTO((tree));\n extern void lang_init\t\t\t\tPROTO((void));\n extern void lang_finish\t\t\t\tPROTO((void));\n-extern void init_filename_times\t\t\tPROTO((void));\n #if 0\n extern void reinit_lang_specific\t\tPROTO((void));\n #endif\n@@ -3093,8 +3095,9 @@ extern tree build_lang_field_decl\t\tPROTO((enum tree_code, tree, tree));\n extern void copy_lang_decl\t\t\tPROTO((tree));\n extern tree make_lang_type\t\t\tPROTO((enum tree_code));\n extern void dump_time_statistics\t\tPROTO((void));\n-/* extern void compiler_error\t\t\tPROTO((char *, HOST_WIDE_INT, HOST_WIDE_INT)); */\n-extern void yyerror\t\t\t\tPROTO((char *));\n+extern void compiler_error\t\t\tPVPROTO((const char *, ...))\n+  ATTRIBUTE_PRINTF_1;\n+extern void yyerror\t\t\t\tPROTO((const char *));\n extern void clear_inline_text_obstack\t\tPROTO((void));\n extern void maybe_snarf_defarg\t\t\tPROTO((void));\n extern tree snarf_defarg\t\t\tPROTO((void));\n@@ -3188,7 +3191,7 @@ extern int processing_template_parmlist;\n /* in repo.c */\n extern void repo_template_used\t\t\tPROTO((tree));\n extern void repo_template_instantiated\t\tPROTO((tree, int));\n-extern void init_repo\t\t\t\tPROTO((char*));\n+extern void init_repo\t\t\t\tPROTO((const char *));\n extern void finish_repo\t\t\t\tPROTO((void));\n \n /* in rtti.c */\n@@ -3384,7 +3387,6 @@ extern tree make_temp_vec\t\t\tPROTO((int));\n extern tree build_ptr_wrapper\t\t\tPROTO((void *));\n extern tree build_expr_ptr_wrapper\t\tPROTO((void *));\n extern tree build_int_wrapper\t\t\tPROTO((int));\n-extern tree build_srcloc\t\t\tPROTO((char *, int));\n extern tree build_srcloc_here\t\t\tPROTO((void));\n extern int varargs_function_p\t\t\tPROTO((tree));\n extern int really_overloaded_fn\t\t\tPROTO((tree));\n@@ -3441,8 +3443,8 @@ extern tree build_object_ref\t\t\tPROTO((tree, tree, tree));\n extern tree build_component_ref_1\t\tPROTO((tree, tree, int));\n extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_x_component_ref\t\tPROTO((tree, tree, tree, int));\n-extern tree build_x_indirect_ref\t\tPROTO((tree, char *));\n-extern tree build_indirect_ref\t\t\tPROTO((tree, char *));\n+extern tree build_x_indirect_ref\t\tPROTO((tree, const char *));\n+extern tree build_indirect_ref\t\t\tPROTO((tree, const char *));\n extern tree build_array_ref\t\t\tPROTO((tree, tree));\n extern tree build_x_function_call\t\tPROTO((tree, tree, tree));\n extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n@@ -3453,7 +3455,7 @@ extern tree convert_arguments\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_x_binary_op\t\t\tPROTO((enum tree_code, tree, tree));\n extern tree build_binary_op\t\t\tPROTO((enum tree_code, tree, tree, int));\n extern tree build_binary_op_nodefault\t\tPROTO((enum tree_code, tree, tree, enum tree_code));\n-extern tree build_component_addr\t\tPROTO((tree, tree, char *));\n+extern tree build_component_addr\t\tPROTO((tree, tree, const char *));\n extern tree build_x_unary_op\t\t\tPROTO((enum tree_code, tree));\n extern tree build_unary_op\t\t\tPROTO((enum tree_code, tree, int));\n extern tree unary_complex_lvalue\t\tPROTO((enum tree_code, tree));\n@@ -3468,8 +3470,7 @@ extern tree build_const_cast\t\t\tPROTO((tree, tree));\n extern tree build_c_cast\t\t\tPROTO((tree, tree));\n extern tree build_x_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n-extern void warn_for_assignment\t\t\tPROTO((char *, char *, char *, tree, int, int));\n-extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, char *, tree, int));\n+extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, const char *, tree, int));\n extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, int));\n extern void c_expand_return\t\t\tPROTO((tree));\n extern tree c_expand_start_case\t\t\tPROTO((tree));\n@@ -3488,7 +3489,7 @@ extern tree pfn_from_ptrmemfunc                 PROTO((tree));\n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n-extern void readonly_error\t\t\tPROTO((tree, char *, int));\n+extern void readonly_error\t\t\tPROTO((tree, const char *, int));\n extern void abstract_virtuals_error\t\tPROTO((tree, tree));\n extern void signature_error\t\t\tPROTO((tree, tree));\n extern void incomplete_type_error\t\tPROTO((tree, tree));\n@@ -3503,18 +3504,18 @@ extern tree build_m_component_ref\t\tPROTO((tree, tree));\n extern tree build_functional_cast\t\tPROTO((tree, tree));\n extern char *enum_name_string\t\t\tPROTO((tree, tree));\n extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n-extern void check_for_new_type\t\t\tPROTO((char *,flagged_type_tree));\n+extern void check_for_new_type\t\t\tPROTO((const char *, flagged_type_tree));\n extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n \n /* in xref.c */\n-extern void GNU_xref_begin\t\t\tPROTO((char *));\n+extern void GNU_xref_begin\t\t\tPROTO((const char *));\n extern void GNU_xref_end\t\t\tPROTO((int));\n-extern void GNU_xref_file\t\t\tPROTO((char *));\n+extern void GNU_xref_file\t\t\tPROTO((const char *));\n extern void GNU_xref_start_scope\t\tPROTO((HOST_WIDE_INT));\n extern void GNU_xref_end_scope\t\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, int, int));\n-extern void GNU_xref_ref\t\t\tPROTO((tree, char *));\n+extern void GNU_xref_ref\t\t\tPROTO((tree, const char *));\n extern void GNU_xref_decl\t\t\tPROTO((tree, tree));\n-extern void GNU_xref_call\t\t\tPROTO((tree, char *));\n+extern void GNU_xref_call\t\t\tPROTO((tree, const char *));\n extern void GNU_xref_function\t\t\tPROTO((tree, tree));\n extern void GNU_xref_assign\t\t\tPROTO((tree));\n extern void GNU_xref_hier\t\t\tPROTO((tree, tree, int, int, int));"}, {"sha": "d03cff5df65eea3413a9d23afd0bef603e19f6af", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -456,7 +456,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  if (! real_lvalue_p (expr)\n \t      && !CP_TYPE_CONST_NON_VOLATILE_P (ttl))\n \t    {\n-\t      char* msg;\n+\t      const char *msg;\n \n \t      if (CP_TYPE_VOLATILE_P (ttl) && decl)\n \t\tmsg = \"initialization of volatile reference type `%#T'\";"}, {"sha": "74ba56b74aab809b9b298225583c99502fd6cd39", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -134,7 +134,7 @@ static struct stack_level *decl_stack;\n \n static tree grokparms\t\t\t\tPROTO((tree, int));\n static tree lookup_nested_type\t\t\tPROTO((tree, tree));\n-static char *redeclaration_error_message\tPROTO((tree, tree));\n+static const char *redeclaration_error_message\tPROTO((tree, tree));\n \n static struct stack_level *push_decl_level PROTO((struct stack_level *,\n \t\t\t\t\t\t  struct obstack *));\n@@ -167,10 +167,10 @@ static tree lookup_tag PROTO((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n static void set_identifier_type_value_with_scope\n \tPROTO((tree, tree, struct binding_level *));\n-static void record_builtin_type PROTO((enum rid, char *, tree));\n-static void record_unknown_type PROTO((tree, char *));\n-static int member_function_or_else PROTO((tree, tree, char *));\n-static void bad_specifiers PROTO((tree, char *, int, int, int, int,\n+static void record_builtin_type PROTO((enum rid, const char *, tree));\n+static void record_unknown_type PROTO((tree, const char *));\n+static int member_function_or_else PROTO((tree, tree, const char *));\n+static void bad_specifiers PROTO((tree, const char *, int, int, int, int,\n \t\t\t\t  int));\n static void lang_print_error_function PROTO((char *));\n static tree maybe_process_template_type_declaration PROTO((tree, int, struct binding_level*));\n@@ -181,6 +181,13 @@ static void push_binding PROTO((tree, tree, struct binding_level*));\n static void add_binding PROTO((tree, tree));\n static void pop_binding PROTO((tree, tree));\n static tree local_variable_p PROTO((tree));\n+static tree find_binding PROTO((tree, tree));\n+static tree select_decl PROTO((tree, int));\n+static tree unqualified_namespace_lookup PROTO((tree, int));\n+static int lookup_flags PROTO((int, int));\n+static tree qualify_lookup PROTO((tree, int));\n+static tree record_builtin_java_type PROTO((const char *, int));\n+static const char *tag_name PROTO((enum tag_types code));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -2815,9 +2822,9 @@ warn_extern_redeclared_static (newdecl, olddecl)\n {\n   tree name;\n \n-  static char *explicit_extern_static_warning\n+  static const char *explicit_extern_static_warning\n     = \"`%D' was declared `extern' and later `static'\";\n-  static char *implicit_extern_static_warning\n+  static const char *implicit_extern_static_warning\n     = \"`%D' was declared implicitly `extern' and later `static'\";\n \n   if (TREE_CODE (newdecl) == TYPE_DECL)\n@@ -3042,7 +3049,7 @@ duplicate_decls (newdecl, olddecl)\n     return 1;\n   else\n     {\n-      char *errmsg = redeclaration_error_message (newdecl, olddecl);\n+      const char *errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n \t  cp_error (errmsg, newdecl);\n@@ -3895,7 +3902,7 @@ pushdecl (x)\n \t\t   /* No shadow warnings for vars made for inlining.  */\n \t\t   && ! DECL_FROM_INLINE (x))\n \t    {\n-\t      char *warnstring = NULL;\n+\t      const char *warnstring = NULL;\n \n \t      if (oldlocal != NULL_TREE && TREE_CODE (oldlocal) == PARM_DECL)\n \t\twarnstring = \"declaration of `%s' shadows a parameter\";\n@@ -4372,7 +4379,7 @@ implicitly_declare (functionid)\n    Otherwise return an error message format string with a %s\n    where the identifier should go.  */\n \n-static char *\n+static const char *\n redeclaration_error_message (newdecl, olddecl)\n      tree newdecl, olddecl;\n {\n@@ -5737,7 +5744,7 @@ static int builtin_type_tdescs_len, builtin_type_tdescs_max;\n static void\n record_builtin_type (rid_index, name, type)\n      enum rid rid_index;\n-     char *name;\n+     const char *name;\n      tree type;\n {\n   tree rname = NULL_TREE, tname = NULL_TREE;\n@@ -5780,7 +5787,7 @@ record_builtin_type (rid_index, name, type)\n \n static tree\n record_builtin_java_type (name, size)\n-     char *name;\n+     const char *name;\n      int size;\n {\n   tree type, decl;\n@@ -5809,7 +5816,7 @@ record_builtin_java_type (name, size)\n static void\n record_unknown_type (type, name)\n      tree type;\n-     char *name;\n+     const char *name;\n {\n   tree decl = pushdecl (build_decl (TYPE_DECL, get_identifier (name), type));\n   /* Make sure the \"unknown type\" typedecl gets ignored for debug info.  */\n@@ -6628,11 +6635,11 @@ lang_print_error_function (file)\n \n tree\n define_function (name, type, function_code, pfn, library_name)\n-     char *name;\n+     const char *name;\n      tree type;\n      enum built_in_function function_code;\n      void (*pfn) PROTO((tree));\n-     char *library_name;\n+     const char *library_name;\n {\n   tree decl = build_lang_decl (FUNCTION_DECL, get_identifier (name), type);\n   DECL_EXTERNAL (decl) = 1;\n@@ -8303,7 +8310,7 @@ complete_array_type (type, initial_value, do_default)\n static int\n member_function_or_else (ctype, cur_type, string)\n      tree ctype, cur_type;\n-     char *string;\n+     const char *string;\n {\n   if (ctype && ctype != cur_type)\n     {\n@@ -8321,7 +8328,7 @@ member_function_or_else (ctype, cur_type, string)\n static void\n bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n      tree object;\n-     char *type;\n+     const char *type;\n      int virtualp, quals, friendp, raises, inlinep;\n {\n   if (virtualp)\n@@ -11923,7 +11930,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t  else if (! friendp)\n \t    {\n \t      int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n-\t      char *what = 0;\n+\t      const char *what = 0;\n \t      if (ref)\n \t\tt = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n \n@@ -12078,7 +12085,7 @@ grok_op_properties (decl, virtualp, friendp)\n     }\n }\n \f\n-static char *\n+static const char *\n tag_name (code)\n      enum tag_types code;\n {"}, {"sha": "9b577ba58e22cbdf2663c28c85644d4813896a1a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -58,6 +58,18 @@ static int is_namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n static tree ambiguous_decl PROTO((tree, tree, tree,int));\n static tree build_anon_union_vars PROTO((tree, tree*, int, int));\n+static int acceptable_java_type PROTO((tree));\n+static void output_vtable_inherit PROTO((tree));\n+static void setup_initp PROTO((void));\n+static void start_objects PROTO((int, int));\n+static void finish_objects PROTO((int, int));\n+static void do_dtors PROTO((tree));\n+static void do_ctors PROTO((tree));\n+static tree merge_functions PROTO((tree, tree));\n+static tree decl_namespace PROTO((tree));\n+static tree validate_nonmember_using_decl PROTO((tree, tree *, tree *));\n+static void do_nonmember_using_decl PROTO((tree, tree, tree, tree,\n+\t\t\t\t\t   tree *, tree *));\n \n extern int current_class_depth;\n \n@@ -441,7 +453,8 @@ int flag_permissive;\n     if `-fSTRING' is seen as an option.\n    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */\n \n-static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n+static struct { const char *string; int *variable; int on_value;}\n+lang_f_options[] =\n {\n   /* C/C++ options.  */\n   {\"signed-char\", &flag_signed_char, 1},\n@@ -1234,7 +1247,7 @@ check_member_template (tmpl)\n \n /* Return true iff TYPE is a valid Java parameter or return type. */\n \n-int\n+static int\n acceptable_java_type (type)\n      tree type;\n {\n@@ -2202,7 +2215,7 @@ finish_anon_union (anon_union_decl)\n void\n finish_builtin_type (type, name, fields, len, align_type)\n      tree type;\n-     char *name;\n+     const char *name;\n      tree fields[];\n      int len;\n      tree align_type;\n@@ -4272,7 +4285,7 @@ set_decl_namespace (decl, scope, friendp)\n \n /* Compute the namespace where a declaration is defined. */\n \n-tree\n+static tree\n decl_namespace (decl)\n      tree decl;\n {\n@@ -4364,6 +4377,9 @@ struct arg_lookup\n static int arg_assoc         PROTO((struct arg_lookup*, tree));\n static int arg_assoc_args    PROTO((struct arg_lookup*, tree));\n static int arg_assoc_type    PROTO((struct arg_lookup*, tree));\n+static int add_function      PROTO((struct arg_lookup *, tree));\n+static int arg_assoc_namespace PROTO((struct arg_lookup *, tree));\n+static int arg_assoc_class   PROTO((struct arg_lookup *, tree));\n \n /* Add a function to the lookup structure.\n    Returns 1 on error.  */"}, {"sha": "7d6e66dffac84a490c5aa17e18ace8e7ffd277c8", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"cp-tree.h\"\n #include \"toplev.h\"\n \n /* cp_printer is the type of a function which converts an argument into\n@@ -39,6 +40,7 @@ int cp_silent = 0;\n \n typedef void errorfn ();\t/* deliberately vague */\n \n+static void cp_thing PROTO ((errorfn *, int, const char *, va_list));\n extern char* cp_file_of PROTO((tree));\n extern int   cp_line_of PROTO((tree));\n \n@@ -246,8 +248,6 @@ cp_pedwarn VPROTO((const char *format, ...))\n   va_end (ap);\n }\n \n-extern errorfn compiler_error;\n-\n void\n cp_compiler_error VPROTO((const char *format, ...))\n {\n@@ -263,7 +263,7 @@ cp_compiler_error VPROTO((const char *format, ...))\n #endif\n \n   if (! cp_silent)\n-    cp_thing (compiler_error, 0, format, ap);\n+    cp_thing ((errorfn *) compiler_error, 0, format, ap);\n   va_end (ap);\n }\n "}, {"sha": "b230e1f1efc24afffb6ce46fbe59726e14aa083d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -110,6 +110,7 @@ static void dump_parameters PROTO((tree, int, int));\n static void dump_exception_spec PROTO((tree, int));\n static char *aggr_variety PROTO((tree));\n static tree ident_fndecl PROTO((tree));\n+static int interesting_scope_p PROTO((tree));\n \n void\n init_error ()"}, {"sha": "9e2d6af592aabece0bbd6ed794a9f9df60a77dec", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -399,7 +399,7 @@ static tree\n build_eh_type_type (type)\n      tree type;\n {\n-  char *typestring;\n+  const char *typestring;\n   tree exp;\n \n   if (type == error_mark_node)\n@@ -427,7 +427,7 @@ static tree\n build_eh_type_type_ref (type)\n      tree type;\n {\n-  char *typestring;\n+  const char *typestring;\n   tree exp;\n \n   if (type == error_mark_node)"}, {"sha": "71fd08b1d4c34078a463617b9cccfbaf22a6d59b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -32,8 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n \n-extern void compiler_error ();\n-\n /* In C++, structures with well-defined constructors are initialized by\n    those constructors, unasked.  CURRENT_BASE_INIT_LIST\n    holds a list of stmts for a BASE_INIT term in the grammar.\n@@ -54,13 +52,14 @@ static tree build_vec_delete_1 PROTO((tree, tree, tree, tree, tree,\n static void perform_member_init PROTO((tree, tree, tree, int));\n static void sort_base_init PROTO((tree, tree *, tree *));\n static tree build_builtin_delete_call PROTO((tree));\n-static int member_init_ok_or_else PROTO((tree, tree, char *));\n+static int member_init_ok_or_else PROTO((tree, tree, const char *));\n static void expand_virtual_init PROTO((tree, tree));\n static tree sort_member_init PROTO((tree));\n static tree build_partial_cleanup_for PROTO((tree));\n static tree initializing_context PROTO((tree));\n static void expand_vec_init_try_block PROTO((tree));\n static void expand_vec_init_catch_clause PROTO((tree, tree, tree, tree));\n+static tree build_java_class_ref PROTO((tree));\n \n /* Cache the identifier nodes for the magic field of a new cookie.  */\n static tree nc_nelts_field_id;\n@@ -848,7 +847,7 @@ static int\n member_init_ok_or_else (field, type, member_name)\n      tree field;\n      tree type;\n-     char *member_name;\n+     const char *member_name;\n {\n   if (field == error_mark_node)\n     return 0;\n@@ -2061,7 +2060,7 @@ static tree jclass_node = NULL_TREE;\n \n /* Given a Java class, return a decl for the corresponding java.lang.Class. */\n \n-tree\n+static tree\n build_java_class_ref (type)\n      tree type;\n {"}, {"sha": "447e41fb0ac1a2aec2ea1725fe3e226bec373a41", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -54,26 +54,24 @@ extern struct obstack permanent_obstack;\n extern struct obstack *current_obstack, *saveable_obstack;\n \n extern void yyprint PROTO((FILE *, int, YYSTYPE));\n-extern void compiler_error PROTO((char *, HOST_WIDE_INT,\n-\t\t\t\t  HOST_WIDE_INT));\n \n-static tree get_time_identifier PROTO((char *));\n+static tree get_time_identifier PROTO((const char *));\n static int check_newline PROTO((void));\n static int skip_white_space PROTO((int));\n static void finish_defarg PROTO((void));\n static int my_get_run_time PROTO((void));\n static int get_last_nonwhite_on_line PROTO((void));\n-static int interface_strcmp PROTO((char *));\n+static int interface_strcmp PROTO((const char *));\n static int readescape PROTO((int *));\n-static char *extend_token_buffer PROTO((char *));\n+static char *extend_token_buffer PROTO((const char *));\n static void consume_string PROTO((struct obstack *, int));\n static void set_typedecl_interface_info PROTO((tree, tree));\n static void feed_defarg PROTO((tree, tree));\n static int set_vardecl_interface_info PROTO((tree, tree));\n static void store_pending_inline PROTO((tree, struct pending_inline *));\n static void reinit_parse_for_expr PROTO((struct obstack *));\n static int *init_cpp_parse PROTO((void));\n-static int handle_cp_pragma PROTO((char *));\n+static int handle_cp_pragma PROTO((const char *));\n #ifdef HANDLE_GENERIC_PRAGMAS\n static int handle_generic_pragma PROTO((int));\n #endif\n@@ -85,20 +83,22 @@ static int token_cmp PROTO((int *, int *));\n #endif\n static void begin_definition_of_inclass_inline PROTO((struct pending_inline*));\n static void parse_float PROTO((PTR));\n+static int is_global PROTO((tree));\n+static void init_filename_times PROTO((void));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n char *\n file_name_nondirectory (x)\n-     char *x;\n+     const char *x;\n {\n   char *tmp = (char *) rindex (x, '/');\n   if (DIR_SEPARATOR != '/' && ! tmp)\n     tmp = (char *) rindex (x, DIR_SEPARATOR);\n   if (tmp)\n     return (char *) (tmp + 1);\n   else\n-    return x;\n+    return (char *) x;\n }\n \n /* This obstack is needed to hold text.  It is not safe to use\n@@ -314,7 +314,7 @@ static int ignore_escape_flag = 0;\n \n static tree\n get_time_identifier (name)\n-     char *name;\n+     const char *name;\n {\n   tree time_identifier;\n   int len = strlen (name);\n@@ -379,7 +379,7 @@ int cplus_tree_code_length[] = {\n    Used for printing out the tree and error messages.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LEN) NAME,\n \n-char *cplus_tree_code_name[] = {\n+const char *cplus_tree_code_name[] = {\n   \"@@dummy\",\n #include \"cp-tree.def\"\n };\n@@ -429,7 +429,7 @@ lang_identify ()\n   return \"cplusplus\";\n }\n \n-void\n+static void\n init_filename_times ()\n {\n   this_filename_time = get_time_identifier (\"<top level>\");\n@@ -1158,15 +1158,15 @@ extract_interface_info ()\n \n static int\n interface_strcmp (s)\n-     char *s;\n+     const char *s;\n {\n   /* Set the interface/implementation bits for this scope.  */\n   struct impl_files *ifiles;\n-  char *s1;\n+  const char *s1;\n \n   for (ifiles = impl_file_chain; ifiles; ifiles = ifiles->next)\n     {\n-      char *t1 = ifiles->filename;\n+      const char *t1 = ifiles->filename;\n       s1 = s;\n \n       if (*s1 != *t1 || *s1 == 0)\n@@ -2197,7 +2197,7 @@ skip_white_space (c)\n \n static char *\n extend_token_buffer (p)\n-     char *p;\n+     const char *p;\n {\n   int offset = p - token_buffer;\n \n@@ -2256,8 +2256,6 @@ pragma_ungetc (arg)\n \n int linemode;\n \n-static int handle_cp_pragma PROTO((char *));\n-\n static int\n check_newline ()\n {\n@@ -4780,18 +4778,27 @@ dump_time_statistics ()\n }\n \n void\n-compiler_error (s, v, v2)\n-     char *s;\n-     HOST_WIDE_INT v, v2;\t\t\t/* @@also used as pointer */\n+compiler_error VPROTO ((const char *msg, ...))\n {\n+#ifndef ANSI_PROTOTYPES\n+  const char *msg;\n+#endif\n   char buf[1024];\n-  sprintf (buf, s, v, v2);\n+  va_list ap;\n+  \n+  VA_START (ap, msg);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  msg = va_arg (ap, const char *);\n+#endif\n+\n+  vsprintf (buf, msg, ap);\n   error_with_file_and_line (input_filename, lineno, \"%s (compiler error)\", buf);\n }\n \f\n void\n yyerror (string)\n-     char *string;\n+     const char *string;\n {\n   extern int end_of_file;\n   char buf[200];\n@@ -4821,7 +4828,7 @@ yyerror (string)\n \f\n static int\n handle_cp_pragma (pname)\n-     char *pname;\n+     const char *pname;\n {\n   register int token;\n "}, {"sha": "4ae0f0f4ad8730f025df6b59bbb3ad10b3caccd7", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 813, "deletions": 812, "changes": 1625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0"}, {"sha": "9e10c106682aac227fed1edd12370efca48f8202", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -60,9 +60,10 @@ extern int end_of_file;\n \n /* Contains the statement keyword (if/while/do) to include in an\n    error message if the user supplies an empty conditional expression.  */\n-static char *cond_stmt_keyword;\n+static const char *cond_stmt_keyword;\n \n static tree empty_parms PROTO((void));\n+static int parse_decl PROTO((tree, tree, tree, int, tree *));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;"}, {"sha": "8d83ffafcb50a0266fc0df538b88ed93a2bad882", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -149,6 +149,8 @@ static tree try_class_unification PROTO((tree, tree, tree, tree));\n static int coerce_template_template_parms PROTO((tree, tree, int,\n \t\t\t\t\t\t tree, tree));\n static tree determine_specialization PROTO((tree, tree, tree *, int));\n+static int template_args_equal PROTO((tree, tree));\n+static void print_template_context PROTO((int));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -896,7 +898,7 @@ print_candidates (fns)\n {\n   tree fn;\n \n-  char* str = \"candidates are:\";\n+  const char *str = \"candidates are:\";\n \n   for (fn = fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n     {\n@@ -2136,7 +2138,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n      int is_primary;\n      int is_partial;\n {\n-  char* msg;\n+  const char *msg;\n   int   last_level_to_check;\n \n   /* [temp.param] \n@@ -3284,7 +3286,7 @@ coerce_template_parms (parms, args, in_decl,\n \n /* Returns 1 if template args OT and NT are equivalent.  */\n \n-int\n+static int\n template_args_equal (ot, nt)\n      tree ot, nt;\n {\n@@ -4671,7 +4673,7 @@ instantiate_class_template (type)\n \n       if (t == error_mark_node)\n \t{\n-\t  char *str = \"candidates are:\";\n+\t  const char *str = \"candidates are:\";\n \t  cp_error (\"ambiguous class template instantiation for `%#T'\", type);\n \t  for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; \n \t       t = TREE_CHAIN (t))"}, {"sha": "9fa8e5c4ece69712412de1a0b93dbd22bf7f9889", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -37,8 +37,8 @@ extern char *getpwd PROTO((void));\n \n static tree repo_get_id PROTO((tree));\n static char *extract_string PROTO((char **));\n-static char *get_base_filename PROTO((char *));\n-static void open_repo_file PROTO((char *));\n+static char *get_base_filename PROTO((const char *));\n+static void open_repo_file PROTO((const char *));\n static char *afgets PROTO((FILE *));\n static void reopen_repo_file_for_write PROTO((void));\n \n@@ -239,7 +239,7 @@ extract_string (pp)\n \n static char *\n get_base_filename (filename)\n-     char *filename;\n+     const char *filename;\n {\n   char *p = getenv (\"COLLECT_GCC_OPTIONS\");\n   char *output = NULL;\n@@ -270,10 +270,10 @@ get_base_filename (filename)\n \n static void\n open_repo_file (filename)\n-     char *filename;\n+     const char *filename;\n {\n-  register char *p;\n-  char *s = get_base_filename (filename);\n+  register const char *p;\n+  const char *s = get_base_filename (filename);\n \n   if (s == NULL)\n     return;\n@@ -304,7 +304,7 @@ afgets (stream)\n \n void\n init_repo (filename)\n-     char *filename;\n+     const char *filename;\n {\n   char *buf;\n "}, {"sha": "d98435e54f367986ad0f8bc534f5d170c0bc31b6", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack permanent_obstack;\n \n-static tree call_void_fn PROTO((char *));\n+static tree call_void_fn PROTO((const char *));\n static tree build_headof_sub PROTO((tree));\n static tree build_headof PROTO((tree));\n static tree get_tinfo_var PROTO((tree));\n@@ -45,7 +45,7 @@ static void expand_si_desc PROTO((tree, tree));\n static void expand_class_desc PROTO((tree, tree));\n static void expand_attr_desc PROTO((tree, tree));\n static void expand_ptr_desc PROTO((tree, tree));\n-static void expand_generic_desc PROTO((tree, tree, char *));\n+static void expand_generic_desc PROTO((tree, tree, const char *));\n static tree throw_bad_cast PROTO((void));\n static tree throw_bad_typeid PROTO((void));\n \n@@ -133,7 +133,7 @@ build_headof (exp)\n \n static tree\n call_void_fn (name)\n-     char *name;\n+     const char *name;\n {\n   tree d = get_identifier (name);\n   tree type;\n@@ -719,7 +719,7 @@ expand_si_desc (tdecl, type)\n      tree type;\n {\n   tree t, elems, fn;\n-  char *name = build_overload_name (type, 1, 1);\n+  const char *name = build_overload_name (type, 1, 1);\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n \n   type = BINFO_TYPE (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0));\n@@ -767,7 +767,7 @@ expand_class_desc (tdecl, type)\n {\n   tree name_string;\n   tree fn, tmp;\n-  char *name;\n+  const char *name;\n \n   int i = CLASSTYPE_N_BASECLASSES (type);\n   int base_cnt = 0;\n@@ -827,7 +827,7 @@ expand_class_desc (tdecl, type)\n       if (TREE_VIA_VIRTUAL (binfo))\n \t{\n \t  tree t = BINFO_TYPE (binfo);\n-\t  char *name;\n+\t  const char *name;\n \t  tree field;\n \n \t  FORMAT_VBASE_NAME (name, t);\n@@ -947,7 +947,7 @@ expand_ptr_desc (tdecl, type)\n      tree type;\n {\n   tree t, elems, fn;\n-  char *name = build_overload_name (type, 1, 1);\n+  const char *name = build_overload_name (type, 1, 1);\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n \n   type = TREE_TYPE (type);\n@@ -994,7 +994,7 @@ expand_attr_desc (tdecl, type)\n      tree type;\n {\n   tree elems, t, fn;\n-  char *name = build_overload_name (type, 1, 1);\n+  const char *name = build_overload_name (type, 1, 1);\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n   tree attrval = build_int_2 (TYPE_QUALS (type), 0);\n \n@@ -1040,9 +1040,9 @@ static void\n expand_generic_desc (tdecl, type, fnname)\n      tree tdecl;\n      tree type;\n-     char *fnname;\n+     const char *fnname;\n {\n-  char *name = build_overload_name (type, 1, 1);\n+  const char *name = build_overload_name (type, 1, 1);\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n   tree elems = tree_cons\n     (NULL_TREE, decay_conversion (tdecl), tree_cons"}, {"sha": "a5caba87b617370767616d046ae701bf34f475ea", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -1142,7 +1142,7 @@ struct lookup_field_info {\n   /* If non-zero, RVAL was found by looking through a dependent base.  */\n   int from_dep_base_p;\n   /* If something went wrong, a message indicating what.  */\n-  char *errstr;\n+  const char *errstr;\n };\n \n /* Returns non-zero if BINFO is not hidden by the value found by the\n@@ -1330,7 +1330,7 @@ lookup_member (xbasetype, name, protect, want_type)\n      we know that binfo of a virtual base class will always == itself when\n      found along any line.  (mrs)  */\n \n-  char *errstr = 0;\n+  const char *errstr = 0;\n \n   if (xbasetype == current_class_type && TYPE_BEING_DEFINED (xbasetype)\n       && IDENTIFIER_CLASS_VALUE (name))\n@@ -1362,7 +1362,7 @@ lookup_member (xbasetype, name, protect, want_type)\n   n_calls_lookup_field++;\n #endif /* GATHER_STATISTICS */\n \n-  bzero (&lfi, sizeof (lfi));\n+  bzero ((PTR) &lfi, sizeof (lfi));\n   lfi.type = type;\n   lfi.name = name;\n   lfi.want_type = want_type;"}, {"sha": "f170df52a606850b1b73c939f0bd8612ca62c3b4", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -33,8 +33,6 @@ extern struct obstack *current_obstack;\n extern struct obstack permanent_obstack;\n extern struct obstack *saveable_obstack;\n \n-extern void compiler_error ();\n-\n static tree save_this PROTO((tree));\n static tree build_sptr_ref PROTO((tree));\n static tree build_member_function_pointer PROTO((tree));\n@@ -63,14 +61,14 @@ build_signature_pointer_or_reference_name (to_type, type_quals, refp)\n      int type_quals;\n      int refp;\n {\n-  char * sig_name = TYPE_NAME_STRING (to_type);\n+  const char * sig_name = TYPE_NAME_STRING (to_type);\n   int name_len = TYPE_NAME_LENGTH (to_type) + 3 /* Enough room for\n \t\t\t\t\t\t   C,V,R.  */;\n   char * name;\n \n-  char *const_rep = (type_quals & TYPE_QUAL_CONST) ? \"C\" : \"\";\n-  char *restrict_rep = (type_quals & TYPE_QUAL_RESTRICT) ? \"R\" : \"\"; \n-  char *volatile_rep = (type_quals & TYPE_QUAL_VOLATILE) ? \"C\" : \"\";\n+  const char *const_rep = (type_quals & TYPE_QUAL_CONST) ? \"C\" : \"\";\n+  const char *restrict_rep = (type_quals & TYPE_QUAL_RESTRICT) ? \"R\" : \"\"; \n+  const char *volatile_rep = (type_quals & TYPE_QUAL_VOLATILE) ? \"C\" : \"\";\n \n   if (refp)\n     {\n@@ -288,8 +286,8 @@ get_sigtable_name (sig_type, rhs_type)\n   char *buf = (char *) alloca (sizeof (SIGTABLE_NAME_FORMAT_LONG)\n \t\t\t       + IDENTIFIER_LENGTH (sig_type_id)\n \t\t\t       + IDENTIFIER_LENGTH (rhs_type_id) + 20);\n-  char *sig_ptr = IDENTIFIER_POINTER (sig_type_id);\n-  char *rhs_ptr = IDENTIFIER_POINTER (rhs_type_id);\n+  const char *sig_ptr = IDENTIFIER_POINTER (sig_type_id);\n+  const char *rhs_ptr = IDENTIFIER_POINTER (rhs_type_id);\n   int i, j;\n \n   for (i = 0; sig_ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++)\n@@ -316,7 +314,7 @@ static tree\n build_member_function_pointer (member)\n      tree member;\n {\n-  char *namstr = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (member));\n+  const char *namstr = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (member));\n   int namlen = IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (member));\n   char *name;\n   tree entry;"}, {"sha": "fc8d5844582343cbb690c6348bdedc4e79e9eb9b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -28,8 +28,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"toplev.h\"\n \n-extern void compiler_error ();\n-\n static tree get_identifier_list PROTO((tree));\n static tree bot_manip PROTO((tree));\n static tree perm_manip PROTO((tree));\n@@ -42,6 +40,8 @@ static void propagate_binfo_offsets PROTO((tree, tree));\n static int avoid_overlap PROTO((tree, tree));\n static int lvalue_p_1 PROTO((tree, int));\n static int equal_functions PROTO((tree, tree));\n+static tree no_linkage_helper PROTO((tree));\n+static tree build_srcloc PROTO((char *, int));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -881,7 +881,7 @@ build_vbase_pointer_fields (rec)\n       if (TREE_VIA_VIRTUAL (base_binfo))\n \t{\n \t  int j;\n-\t  char *name;\n+\t  const char *name;\n \n \t  /* The offset for a virtual base class is only used in computing\n \t     virtual function tables and for initializing virtual base\n@@ -2132,17 +2132,10 @@ print_lang_statistics ()\n \n void\n __eprintf (string, expression, line, filename)\n-#ifdef __STDC__\n      const char *string;\n      const char *expression;\n      unsigned line;\n      const char *filename;\n-#else\n-     char *string;\n-     char *expression;\n-     unsigned line;\n-     char *filename;\n-#endif\n {\n   fprintf (stderr, string, expression, line, filename);\n   fflush (stderr);\n@@ -2604,7 +2597,7 @@ build_int_wrapper (i)\n   return t;\n }\n \n-tree\n+static tree\n build_srcloc (file, line)\n      char *file;\n      int line;"}, {"sha": "f1fa51f4528c9b0ae5e9ec9c3653f5e699784ee0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -39,9 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n \n-extern void compiler_error ();\n-\n-static tree convert_for_assignment PROTO((tree, tree, char*, tree,\n+static tree convert_for_assignment PROTO((tree, tree, const char *, tree,\n \t\t\t\t\t  int));\n static tree pointer_int_sum PROTO((enum tree_code, tree, tree));\n static tree rationalize_conditional_expr PROTO((enum tree_code, tree));\n@@ -59,6 +57,7 @@ static tree lookup_anon_field PROTO((tree, tree));\n static tree pointer_diff PROTO((tree, tree, tree));\n static tree qualify_type PROTO((tree, tree));\n static tree get_delta_difference PROTO((tree, tree, int));\n+static int comp_cv_target_types PROTO((tree, tree, int));\n \n /* Return the target type of TYPE, which meas return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n@@ -2322,7 +2321,7 @@ build_x_component_ref (datum, component, basetype_path, protect)\n tree\n build_x_indirect_ref (ptr, errorstring)\n      tree ptr;\n-     char *errorstring;\n+     const char *errorstring;\n {\n   tree rval;\n \n@@ -2339,7 +2338,7 @@ build_x_indirect_ref (ptr, errorstring)\n tree\n build_indirect_ref (ptr, errorstring)\n      tree ptr;\n-     char *errorstring;\n+     const char *errorstring;\n {\n   register tree pointer, type;\n \n@@ -3084,7 +3083,7 @@ convert_arguments (typelist, values, fndecl, flags)\n {\n   register tree typetail, valtail;\n   register tree result = NULL_TREE;\n-  char *called_thing = 0;\n+  const char *called_thing = 0;\n   int i = 0;\n \n   /* Argument passing is always copy-initialization.  */\n@@ -4247,7 +4246,7 @@ pointer_diff (op0, op1, ptrtype)\n tree\n build_component_addr (arg, argtype, msg)\n      tree arg, argtype;\n-     char *msg;\n+     const char *msg;\n {\n   tree field = TREE_OPERAND (arg, 1);\n   tree basetype = decl_type_context (field);\n@@ -4359,7 +4358,7 @@ build_unary_op (code, xarg, noconvert)\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   register tree arg = xarg;\n   register tree argtype = 0;\n-  char *errstring = NULL;\n+  const char *errstring = NULL;\n   tree val;\n \n   if (arg == error_mark_node)\n@@ -6643,7 +6642,7 @@ pfn_from_ptrmemfunc (t)\n static tree\n convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n      tree type, rhs;\n-     char *errtype;\n+     const char *errtype;\n      tree fndecl;\n      int parmnum;\n {\n@@ -7078,7 +7077,7 @@ tree\n convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n      tree exp, type, rhs;\n      int flags;\n-     char *errtype;\n+     const char *errtype;\n      tree fndecl;\n      int parmnum;\n {"}, {"sha": "76a30b202d6e43c032cc6c9081b53b00f7202c06", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n \n static tree process_init_constructor PROTO((tree, tree, tree *));\n+static void ack PVPROTO ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n extern int errorcount;\n extern int sorrycount;\n@@ -80,11 +81,11 @@ binfo_or_else (parent_or_type, type)\n void\n readonly_error (arg, string, soft)\n      tree arg;\n-     char *string;\n+     const char *string;\n      int soft;\n {\n-  char *fmt;\n-  void (*fn)();\n+  const char *fmt;\n+  void (*fn) PVPROTO ((const char *, ...));\n \n   if (soft)\n     fn = cp_pedwarn;\n@@ -274,19 +275,28 @@ incomplete_type_error (value, type)\n /* Like error(), but don't call report_error_function().  */\n \n static void\n-ack (s, v, v2)\n-     char *s;\n-     HOST_WIDE_INT v;\n-     HOST_WIDE_INT v2;\n+ack VPROTO ((const char *msg, ...))\n {\n+#ifndef ANSI_PROTOTYPES\n+  const char *msg;\n+#endif\n+  va_list ap;\n   extern char * progname;\n   \n+  VA_START (ap, msg);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msg = va_arg (ap, const char *);\n+#endif\n+  \n   if (input_filename)\n     fprintf (stderr, \"%s:%d: \", input_filename, lineno);\n   else\n     fprintf (stderr, \"%s: \", progname);\n \n-  fprintf (stderr, s, v, v2);\n+  vfprintf (stderr, msg, ap);\n+  va_end (ap);\n+  \n   fprintf (stderr, \"\\n\");\n }\n   \n@@ -1640,7 +1650,7 @@ report_case_error (code, type, new_value, old_value)\n \n void\n check_for_new_type (string, inptree)\n-     char *string;\n+     const char *string;\n      flagged_type_tree inptree;\n {\n   if (inptree.new_type_flag"}, {"sha": "6e06eda92fb93c5047eba273c2157a4d6402354c", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e178a02b6adccbbbef668c0374a95b466d11b0/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=d8e178a02b6adccbbbef668c0374a95b466d11b0", "patch": "@@ -86,8 +86,8 @@ typedef struct _XREF_SCOPE *\tXREF_SCOPE;\n \n typedef struct _XREF_FILE\n {\n-  char *name;\n-  char *outname;\n+  const char *name;\n+  const char *outname;\n   XREF_FILE next;\n } XREF_FILE_INFO;\n \n@@ -122,19 +122,20 @@ static\ttree\t\tlast_fndecl = NULL;\n /*\t\t\t\t\t\t\t\t\t*/\n /************************************************************************/\n static\tvoid\t\tgen_assign PROTO((XREF_FILE, tree));\n-static\tXREF_FILE\tfind_file PROTO((char *));\n-static\tchar *\t\tfilename PROTO((XREF_FILE));\n-static\tchar *\t\tfctname PROTO((tree));\n-static\tchar *\t\tdeclname PROTO((tree));\n+static\tXREF_FILE\tfind_file PROTO((const char *));\n+static\tconst char *\tfilename PROTO((XREF_FILE));\n+static\tconst char *\tfctname PROTO((tree));\n+static\tconst char *\tdeclname PROTO((tree));\n static\tvoid\t\tsimplify_type PROTO((char *));\n-static\tchar *\t\tfixname PROTO((char *, char *));\n-static\tvoid\t\topen_xref_file PROTO((char *));\n+static\tconst char *\tfixname PROTO((const char *, char *));\n+static\tvoid\t\topen_xref_file PROTO((const char *));\n+static  const char *\tclassname PROTO((tree));\n \n /* Start cross referencing.  FILE is the name of the file we xref.  */\n \n void\n GNU_xref_begin (file)\n-   char *file;\n+   const char *file;\n {\n   doing_xref = 1;\n \n@@ -178,7 +179,7 @@ GNU_xref_end (ect)\n \n void\n GNU_xref_file (name)\n-   char *name;\n+   const char *name;\n {\n   XREF_FILE xf;\n \n@@ -209,8 +210,8 @@ GNU_xref_file (name)\n   else\n     {\n       char *nmbuf\n-\t= (char *) malloc (strlen (wd_name) + strlen (FILE_NAME_JOINER)\n-\t\t\t   + strlen (name) + 1);\n+\t= (char *) xmalloc (strlen (wd_name) + strlen (FILE_NAME_JOINER)\n+\t\t\t    + strlen (name) + 1);\n       sprintf (nmbuf, \"%s%s%s\", wd_name, FILE_NAME_JOINER, name);\n       name = nmbuf;\n       xf->outname = nmbuf;\n@@ -259,7 +260,7 @@ GNU_xref_end_scope (id,inid,prm,keep)\n {\n   XREF_FILE xf;\n   XREF_SCOPE xs,lxs,oxs;\n-  char *stype;\n+  const char *stype;\n \n   if (!doing_xref) return;\n   xf = find_file (input_filename);\n@@ -302,7 +303,7 @@ GNU_xref_end_scope (id,inid,prm,keep)\n void\n GNU_xref_ref (fndecl,name)\n    tree fndecl;\n-   char *name;\n+   const char *name;\n {\n   XREF_FILE xf;\n \n@@ -322,8 +323,8 @@ GNU_xref_decl (fndecl,decl)\n    tree decl;\n {\n   XREF_FILE xf,xf1;\n-  char *cls = 0;\n-  char *name;\n+  const char *cls = 0;\n+  const char *name;\n   char buf[10240];\n   int uselin;\n \n@@ -432,11 +433,11 @@ GNU_xref_decl (fndecl,decl)\n void\n GNU_xref_call (fndecl, name)\n    tree fndecl;\n-   char *name;\n+   const char *name;\n {\n   XREF_FILE xf;\n   char buf[1024];\n-  char *s;\n+  const char *s;\n \n   if (!doing_xref) return;\n   xf = find_file (input_filename);\n@@ -508,7 +509,7 @@ gen_assign(xf, name)\n    XREF_FILE xf;\n    tree name;\n {\n-  char *s;\n+  const char *s;\n \n   s = NULL;\n \n@@ -541,7 +542,7 @@ gen_assign(xf, name)\n     fprintf(xref_file, \"ASG %s %d %s\\n\", filename(xf), lineno, s);\n }\n \n-static char*\n+static const char *\n classname (cls)\n      tree cls;\n {\n@@ -590,9 +591,9 @@ GNU_xref_member(cls, fld)\n    tree fld;\n {\n   XREF_FILE xf;\n-  char *prot;\n+  const char *prot;\n   int confg, pure;\n-  char *d;\n+  const char *d;\n #ifdef XREF_SHORT_MEMBER_NAMES\n   int i;\n #endif\n@@ -651,7 +652,7 @@ GNU_xref_member(cls, fld)\n \n static XREF_FILE\n find_file(name)\n-   char *name;\n+   const char *name;\n {\n   XREF_FILE xf;\n \n@@ -664,7 +665,7 @@ find_file(name)\n \n /* Return filename for output purposes.  */\n \n-static char *\n+static const char *\n filename(xf)\n    XREF_FILE xf;\n {\n@@ -682,12 +683,12 @@ filename(xf)\n \n /* Return function name for output purposes.  */\n \n-static char *\n+static const char *\n fctname(fndecl)\n    tree fndecl;\n {\n   static char fctbuf[1024];\n-  char *s;\n+  const char *s;\n \n   if (fndecl == NULL && last_fndecl == NULL) return \"*\";\n \n@@ -709,7 +710,7 @@ fctname(fndecl)\n \n /* Return decl name for output purposes.  */\n \n-static char *\n+static const char *\n declname(dcl)\n    tree dcl;\n {\n@@ -773,12 +774,13 @@ simplify_type(typ)\n \n /* Fixup a function name (take care of embedded spaces).  */\n \n-static char *\n+static const char *\n fixname(nam, buf)\n-   char *nam;\n+   const char *nam;\n    char *buf;\n {\n-  char *s, *t;\n+  const char *s;\n+  char *t;\n   int fg;\n \n   s = nam;\n@@ -806,9 +808,10 @@ fixname(nam, buf)\n \n static void\n open_xref_file(file)\n-   char *file;\n+   const char *file;\n {\n-  char *s, *t;\n+  const char *s;\n+  char *t;\n \n #ifdef XREF_FILE_NAME\n   XREF_FILE_NAME (xref_name, file);"}]}