{"sha": "69dc042f91c70458ffb6e7b147f093799cee2100", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkYzA0MmY5MWM3MDQ1OGZmYjZlN2IxNDdmMDkzNzk5Y2VlMjEwMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-10T20:38:34Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-13T17:50:12Z"}, "message": "PR c++/80265 - constexpr __builtin_mem*.\n\nThe library has already worked around this issue, but I was curious about\nwhy it wasn't working.  The answer: because we were passing &var to fold,\nwhich doesn't know about the constexpr values hash table.  Fixed by passing\n&\"str\" instead.\n\n\t* constexpr.c (cxx_eval_builtin_function_call): Expose STRING_CST\n\tto str/mem builtins.", "tree": {"sha": "35aa87883d243598c9f505525aff4f27c13d43b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35aa87883d243598c9f505525aff4f27c13d43b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69dc042f91c70458ffb6e7b147f093799cee2100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dc042f91c70458ffb6e7b147f093799cee2100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69dc042f91c70458ffb6e7b147f093799cee2100", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69dc042f91c70458ffb6e7b147f093799cee2100/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c82dd6c02d44d9d2cd84dda137c00b1a3cd6c90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82dd6c02d44d9d2cd84dda137c00b1a3cd6c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c82dd6c02d44d9d2cd84dda137c00b1a3cd6c90"}], "stats": {"total": 107, "additions": 102, "deletions": 5}, "files": [{"sha": "3a9fb566a5282d8e275f669839c95a94364e7211", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dc042f91c70458ffb6e7b147f093799cee2100/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dc042f91c70458ffb6e7b147f093799cee2100/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=69dc042f91c70458ffb6e7b147f093799cee2100", "patch": "@@ -1260,28 +1260,76 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   if (fndecl_built_in_p (fun, CP_BUILT_IN_SOURCE_LOCATION, BUILT_IN_FRONTEND))\n     return fold_builtin_source_location (EXPR_LOCATION (t));\n \n+  int strops = 0;\n+  int strret = 0;\n+  if (fndecl_built_in_p (fun, BUILT_IN_NORMAL))\n+    switch (DECL_FUNCTION_CODE (fun))\n+      {\n+      case BUILT_IN_STRLEN:\n+      case BUILT_IN_STRNLEN:\n+\tstrops = 1;\n+\tbreak;\n+      case BUILT_IN_MEMCHR:\n+      case BUILT_IN_STRCHR:\n+      case BUILT_IN_STRRCHR:\n+\tstrops = 1;\n+\tstrret = 1;\n+\tbreak;\n+      case BUILT_IN_MEMCMP:\n+      case BUILT_IN_STRCMP:\n+\tstrops = 2;\n+\tbreak;\n+      case BUILT_IN_STRSTR:\n+\tstrops = 2;\n+\tstrret = 1;\n+      default:\n+\tbreak;\n+      }\n+\n   /* Be permissive for arguments to built-ins; __builtin_constant_p should\n      return constant false for a non-constant argument.  */\n   constexpr_ctx new_ctx = *ctx;\n   new_ctx.quiet = true;\n   for (i = 0; i < nargs; ++i)\n     {\n-      args[i] = CALL_EXPR_ARG (t, i);\n+      tree arg = CALL_EXPR_ARG (t, i);\n+\n+      /* To handle string built-ins we need to pass ADDR_EXPR<STRING_CST> since\n+\t expand_builtin doesn't know how to look in the values table.  */\n+      bool strop = i < strops;\n+      if (strop)\n+\t{\n+\t  STRIP_NOPS (arg);\n+\t  if (TREE_CODE (arg) == ADDR_EXPR)\n+\t    arg = TREE_OPERAND (arg, 0);\n+\t  else\n+\t    strop = false;\n+\t}\n+\n       /* If builtin_valid_in_constant_expr_p is true,\n \t potential_constant_expression_1 has not recursed into the arguments\n \t of the builtin, verify it here.  */\n       if (!builtin_valid_in_constant_expr_p (fun)\n-\t  || potential_constant_expression (args[i]))\n+\t  || potential_constant_expression (arg))\n \t{\n \t  bool dummy1 = false, dummy2 = false;\n-\t  args[i] = cxx_eval_constant_expression (&new_ctx, args[i], false,\n-\t\t\t\t\t\t  &dummy1, &dummy2);\n+\t  arg = cxx_eval_constant_expression (&new_ctx, arg, false,\n+\t\t\t\t\t      &dummy1, &dummy2);\n \t}\n \n       if (bi_const_p)\n \t/* For __builtin_constant_p, fold all expressions with constant values\n \t   even if they aren't C++ constant-expressions.  */\n-\targs[i] = cp_fold_rvalue (args[i]);\n+\targ = cp_fold_rvalue (arg);\n+      else if (strop)\n+\t{\n+\t  if (TREE_CODE (arg) == CONSTRUCTOR)\n+\t    arg = braced_lists_to_strings (TREE_TYPE (arg), arg);\n+\t  if (TREE_CODE (arg) == STRING_CST)\n+\t    arg = build_address (arg);\n+\t}\n+\n+      args[i] = arg;\n     }\n \n   bool save_ffbcp = force_folding_builtin_constant_p;\n@@ -1325,6 +1373,18 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n       return t;\n     }\n \n+  if (strret)\n+    {\n+      /* memchr returns a pointer into the first argument, but we replaced the\n+\t argument above with a STRING_CST; put it back it now.  */\n+      tree op = CALL_EXPR_ARG (t, strret-1);\n+      STRIP_NOPS (new_call);\n+      if (TREE_CODE (new_call) == POINTER_PLUS_EXPR)\n+\tTREE_OPERAND (new_call, 0) = op;\n+      else if (TREE_CODE (new_call) == ADDR_EXPR)\n+\tnew_call = op;\n+    }\n+\n   return cxx_eval_constant_expression (&new_ctx, new_call, lval,\n \t\t\t\t       non_constant_p, overflow_p);\n }"}, {"sha": "2d0904b6e085ebdc1695b01c70bd4a56ae57d81b", "filename": "gcc/testsuite/g++.dg/ext/constexpr-builtin1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69dc042f91c70458ffb6e7b147f093799cee2100/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-builtin1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69dc042f91c70458ffb6e7b147f093799cee2100/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-builtin1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-builtin1.C?ref=69dc042f91c70458ffb6e7b147f093799cee2100", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/80265\n+// { dg-do compile { target c++14 } }\n+\n+constexpr bool compare() {\n+  char s1[] = \"foo\";\n+  char s2[] = \"fxo\";\n+  if (!__builtin_memcmp(s1, s2, 3))\n+    return false;\n+  s2[1] = 'o';\n+  if (__builtin_memcmp(s1, s2, 3))\n+    return false;\n+  if (__builtin_strcmp(s1, s2))\n+    return false;\n+  return true;\n+}\n+\n+constexpr bool length() {\n+  char s[] = \"foo\";\n+  if (__builtin_strlen(s) != 3)\n+    return false;\n+  return true;\n+}\n+\n+constexpr bool find() {\n+  char s[] = \"foo\";\n+  if (__builtin_memchr(s, 'f', 3) != s)\n+    return false;\n+  if (__builtin_strchr(s, 'o') != s+1)\n+    return false;\n+  if (__builtin_strstr(s, \"oo\") != s+1)\n+    return false;\n+  return true;\n+}\n+\n+static_assert( compare(), \"\" );\n+static_assert( length(), \"\" );\n+static_assert( find(), \"\" );"}]}