{"sha": "932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyZmJjODY4YWQ0MjkxNjdhM2Q0ZDU2MjVhYTlkNmRjMGI0NTA2Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-07-20T22:49:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-07-20T22:49:27Z"}, "message": "libstdc++: Add std::from_chars for floating-point types\n\nThis adds the missing std::from_chars overloads for floating-point\ntypes, as required for C++17 conformance.\n\nThe implementation is a hack and not intended to be used in the long\nterm. Rather than parsing the string directly, this determines the\ninitial portion of the string that matches the pattern determined by the\nchars_format parameter, then creates a NTBS to be parsed by strtod (or\nstrtold or strtof).\n\nBecause creating a NTBS requires allocating memory, but std::from_chars\nis noexcept, we need to be careful to minimise allocation. Even after\nbeing careful, allocation failure is still possible, and so a\nnon-conforming std::no_more_memory error code might be returned.\n\nBecause strtod et al depend on the current locale, but std::from_chars\ndoes not, we change the current thread's locale to \"C\" using newlocale\nand uselocale before calling strtod, and restore it afterwards.\n\nBecause strtod doesn't have the equivalent of a std::chars_format\nparameter, it has to examine the input to determine the format in use,\neven though the std::from_chars code has already parsed it once (or\ntwice for large input strings!)\n\nBy replacing the use of strtod we could avoid allocation, avoid changing\nlocale, and use optimised code paths specific to each std::chars_format\ncase. We would also get more portable behaviour, rather than depending\non the presence of uselocale, and on any bugs or quirks of the target\nlibc's strtod. Replacing strtod is a project for a later date.\n\nlibstdc++-v3/ChangeLog:\n\n\t* acinclude.m4 (libtool_VERSION): Bump version.\n\t* config.h.in: Regenerate.\n\t* config/abi/pre/gnu.ver: Add GLIBCXX_3.4.29 version and new\n\texports.\n\t* config/os/gnu-linux/ldbl-extra.ver: Add _GLIBCXX_LDBL_3.4.29\n\tversion and new export.\n\t* configure: Regenerate.\n\t* configure.ac: Check for <xlocale.h> and uselocale.\n\t* crossconfig.m4: Add macro or checks for uselocale.\n\t* include/std/charconv (from_chars): Declare overloads for\n\tfloat, double, and long double.\n\t* src/c++17/Makefile.am: Add new file.\n\t* src/c++17/Makefile.in: Regenerate.\n\t* src/c++17/floating_from_chars.cc: New file.\n\t(from_chars): Define for float, double, and long double.\n\t* testsuite/20_util/from_chars/1_c++20_neg.cc: Prune extra\n\tdiagnostics caused by new overloads.\n\t* testsuite/20_util/from_chars/1_neg.cc: Likewise.\n\t* testsuite/20_util/from_chars/2.cc: Check leading '+'.\n\t* testsuite/20_util/from_chars/4.cc: New test.\n\t* testsuite/20_util/from_chars/5.cc: New test.\n\t* testsuite/util/testsuite_abi.cc: Add new symbol versions.", "tree": {"sha": "20d9a830d6cdb638248b986e5fdaafda86b7eeac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20d9a830d6cdb638248b986e5fdaafda86b7eeac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e443d8213864ac337c29092d4767224f280d2062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e443d8213864ac337c29092d4767224f280d2062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e443d8213864ac337c29092d4767224f280d2062"}], "stats": {"total": 1088, "additions": 1083, "deletions": 5}, "files": [{"sha": "e3926e1c9c270efab732ea5dec549877b316d600", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -3846,7 +3846,7 @@ changequote([,])dnl\n fi\n \n # For libtool versioning info, format is CURRENT:REVISION:AGE\n-libtool_VERSION=6:28:0\n+libtool_VERSION=6:29:0\n \n # Everything parsed; figure out what files and settings to use.\n case $enable_symvers in"}, {"sha": "8ae3e0fc4bf89143bedcd538ac973104019e540c", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -526,6 +526,9 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define to 1 if you have the `uselocale' function. */\n+#undef HAVE_USELOCALE\n+\n /* Defined if usleep exists. */\n #undef HAVE_USLEEP\n \n@@ -556,6 +559,9 @@\n /* Define if writev is available in <sys/uio.h>. */\n #undef HAVE_WRITEV\n \n+/* Define to 1 if you have the <xlocale.h> header file. */\n+#undef HAVE_XLOCALE_H\n+\n /* Define to 1 if you have the `_acosf' function. */\n #undef HAVE__ACOSF\n "}, {"sha": "17aff5d907b2d1dd41b36602ba6e70472310ac70", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -2299,6 +2299,13 @@ GLIBCXX_3.4.28 {\n \n } GLIBCXX_3.4.27;\n \n+GLIBCXX_3.4.29 {\n+\n+    # std::from_chars\n+    _ZSt10from_charsPKcS0_R[def]St12chars_format;\n+\n+} GLIBCXX_3.4.28;\n+\n # Symbols in the support library (libsupc++) have their own tag.\n CXXABI_1.3 {\n "}, {"sha": "b4f3af0f9d9ba7869144830a0e46659c34f9c989", "filename": "libstdc++-v3/config/os/gnu-linux/ldbl-extra.ver", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fldbl-extra.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fldbl-extra.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fldbl-extra.ver?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -40,6 +40,10 @@ GLIBCXX_LDBL_3.4.21 {\n   __gnu_cxx_ldbl1287num_getI[cw]*16_M_extract_floatB5cxx11*;\n } GLIBCXX_LDBL_3.4.10;\n \n+GLIBCXX_LDBL_3.4.29 {\n+  _ZSt10from_charsPKcS0_RgSt12chars_format;\n+} GLIBCXX_LDBL_3.4.21;\n+\n CXXABI_LDBL_1.3 {\n   _ZT[IS]g;\n   _ZT[IS]Pg;"}, {"sha": "8d16bf3ffd6b17ef61e1f13d038f3292b36d1189", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -22661,6 +22661,19 @@ fi\n done\n \n \n+for ac_header in xlocale.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"xlocale.h\" \"ac_cv_header_xlocale_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_xlocale_h\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_XLOCALE_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+\n # Only do link tests if native. Else, hardcode.\n if $GLIBCXX_IS_NATIVE; then\n \n@@ -28986,6 +28999,19 @@ if test \"x$ac_cv_func_sockatmark\" = xyes; then :\n #define HAVE_SOCKATMARK 1\n _ACEOF\n \n+fi\n+done\n+\n+\n+  # Non-standard functions used by C++17 std::from_chars\n+  for ac_func in uselocale\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"uselocale\" \"ac_cv_func_uselocale\"\n+if test \"x$ac_cv_func_uselocale\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_USELOCALE 1\n+_ACEOF\n+\n fi\n done\n \n@@ -41997,6 +42023,9 @@ _ACEOF\n \n   fi\n \n+\n+    $as_echo \"#define HAVE_USELOCALE 1\" >>confdefs.h\n+\n     ;;\n \n   *-darwin*)\n@@ -47770,6 +47799,18 @@ done\n \n   CXXFLAGS=\"$ac_save_CXXFLAGS\"\n \n+\n+    for ac_func in uselocale\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"uselocale\" \"ac_cv_func_uselocale\"\n+if test \"x$ac_cv_func_uselocale\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_USELOCALE 1\n+_ACEOF\n+\n+fi\n+done\n+\n     ;;\n \n   *djgpp)\n@@ -48041,6 +48082,17 @@ if test \"x$ac_cv_func_sockatmark\" = xyes; then :\n #define HAVE_SOCKATMARK 1\n _ACEOF\n \n+fi\n+done\n+\n+    for ac_func in uselocale\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"uselocale\" \"ac_cv_func_uselocale\"\n+if test \"x$ac_cv_func_uselocale\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_USELOCALE 1\n+_ACEOF\n+\n fi\n done\n \n@@ -54682,6 +54734,17 @@ _ACEOF\n fi\n done\n \n+    for ac_func in uselocale\n+do :\n+  ac_fn_c_check_func \"$LINENO\" \"uselocale\" \"ac_cv_func_uselocale\"\n+if test \"x$ac_cv_func_uselocale\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_USELOCALE 1\n+_ACEOF\n+\n+fi\n+done\n+\n \n \n \n@@ -75231,7 +75294,7 @@ $as_echo \"$as_me: WARNING: === Symbol versioning will be disabled.\" >&2;}\n fi\n \n # For libtool versioning info, format is CURRENT:REVISION:AGE\n-libtool_VERSION=6:28:0\n+libtool_VERSION=6:29:0\n \n # Everything parsed; figure out what files and settings to use.\n case $enable_symvers in"}, {"sha": "cbfdf4c6bad12a4eaaebdf3a70e6e174cc71a9bf", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -256,6 +256,8 @@ AC_CHECK_HEADERS([linux/random.h], [], [],\n #endif\n ]])\n \n+AC_CHECK_HEADERS([xlocale.h])\n+\n # Only do link tests if native. Else, hardcode.\n if $GLIBCXX_IS_NATIVE; then\n \n@@ -282,6 +284,9 @@ if $GLIBCXX_IS_NATIVE; then\n   # For Networking TS.\n   AC_CHECK_FUNCS(sockatmark)\n \n+  # Non-standard functions used by C++17 std::from_chars\n+  AC_CHECK_FUNCS(uselocale)\n+\n   # For iconv support.\n   AM_ICONV\n "}, {"sha": "9f2589b739ebffc9835de1f6b67ccf6a9570b47c", "filename": "libstdc++-v3/crossconfig.m4", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fcrossconfig.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fcrossconfig.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fcrossconfig.m4?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -63,6 +63,8 @@ case \"${host}\" in\n     # We don't yet support AIX's TLS ABI.\n     #GCC_CHECK_TLS\n     AM_ICONV\n+\n+    AC_DEFINE(HAVE_USELOCALE)\n     ;;\n \n   *-darwin*)\n@@ -73,6 +75,8 @@ case \"${host}\" in\n     # Don't call GLIBCXX_CHECK_LINKER_FEATURES, Darwin doesn't have a GNU ld\n     GLIBCXX_CHECK_MATH_SUPPORT\n     GLIBCXX_CHECK_STDLIB_SUPPORT\n+\n+    AC_CHECK_FUNCS(uselocale)\n     ;;\n \n   *djgpp)\n@@ -129,6 +133,7 @@ case \"${host}\" in\n     AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)\n     AC_CHECK_FUNCS(timespec_get)\n     AC_CHECK_FUNCS(sockatmark)\n+    AC_CHECK_FUNCS(uselocale)\n     ;;\n \n   *-fuchsia*)\n@@ -190,6 +195,7 @@ case \"${host}\" in\n     AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)\n     AC_CHECK_FUNCS(timespec_get)\n     AC_CHECK_FUNCS(sockatmark)\n+    AC_CHECK_FUNCS(uselocale)\n     AM_ICONV\n     ;;\n   *-mingw32*)"}, {"sha": "be668c1939e3d54d80e352ede69e99379ce7b40a", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -688,6 +688,20 @@ namespace __detail\n   operator^=(chars_format& __lhs, chars_format __rhs) noexcept\n   { return __lhs = __lhs ^ __rhs; }\n \n+#if _GLIBCXX_HAVE_USELOCALE\n+  from_chars_result\n+  from_chars(const char* __first, const char* __last, float& __value,\n+\t     chars_format __fmt = chars_format::general);\n+\n+  from_chars_result\n+  from_chars(const char* __first, const char* __last, double& __value,\n+\t     chars_format __fmt = chars_format::general);\n+\n+  from_chars_result\n+  from_chars(const char* __first, const char* __last, long double& __value,\n+\t     chars_format __fmt = chars_format::general);\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n #endif // C++14"}, {"sha": "642efb976acc1ac7f2b908f93a205320077f715b", "filename": "libstdc++-v3/src/c++17/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -50,6 +50,7 @@ inst_sources =\n endif\n \n sources = \\\n+\tfloating_from_chars.cc \\\n \tfs_dir.cc \\\n \tfs_ops.cc \\\n \tfs_path.cc \\"}, {"sha": "ce08eb3ff111f9753b5a9a8001a6c0402d59f380", "filename": "libstdc++-v3/src/c++17/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -124,8 +124,8 @@ LTLIBRARIES = $(noinst_LTLIBRARIES)\n libc__17convenience_la_LIBADD =\n @ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-fs_dir.lo cow-fs_ops.lo \\\n @ENABLE_DUAL_ABI_TRUE@\tcow-fs_path.lo\n-am__objects_2 = fs_dir.lo fs_ops.lo fs_path.lo memory_resource.lo \\\n-\t$(am__objects_1)\n+am__objects_2 = floating_from_chars.lo fs_dir.lo fs_ops.lo fs_path.lo \\\n+\tmemory_resource.lo $(am__objects_1)\n @ENABLE_DUAL_ABI_TRUE@am__objects_3 = cow-string-inst.lo\n @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = ostream-inst.lo \\\n @ENABLE_EXTERN_TEMPLATE_TRUE@\tstring-inst.lo $(am__objects_3)\n@@ -435,6 +435,7 @@ headers =\n @ENABLE_EXTERN_TEMPLATE_TRUE@\t$(extra_string_inst_sources)\n \n sources = \\\n+\tfloating_from_chars.cc \\\n \tfs_dir.cc \\\n \tfs_ops.cc \\\n \tfs_path.cc \\"}, {"sha": "45de2be283d47641429416c61bd1c1862870a968", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -0,0 +1,422 @@\n+// std::from_chars implementation for floating-point types -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+//\n+// ISO C++ 14882:2017\n+// 23.2.9  Primitive numeric input conversion [utility.from.chars]\n+//\n+\n+#include <charconv>\n+#include <string>\n+#include <memory_resource>\n+#include <cmath>\n+#include <cstdlib>\n+#include <cstring>\n+#include <cctype>\n+#include <locale.h>\n+#include <bits/functexcept.h>\n+#if _GLIBCXX_HAVE_XLOCALE_H\n+# include <xlocale.h>\n+#endif\n+\n+#if _GLIBCXX_HAVE_USELOCALE\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+namespace\n+{\n+  // A memory resource with a static buffer that can be used for small\n+  // allocations. At most one allocation using the freestore can be done\n+  // if the static buffer is insufficient. The callers below only require\n+  // a single allocation, so there's no need for anything more complex.\n+  struct buffer_resource : pmr::memory_resource\n+  {\n+    ~buffer_resource() { if (m_ptr) operator delete(m_ptr, m_bytes); }\n+\n+    void*\n+    do_allocate(size_t bytes, size_t alignment [[maybe_unused]]) override\n+    {\n+      // Allocate from the buffer if it will fit.\n+      if (m_bytes < sizeof(m_buf) && (m_bytes + bytes) <= sizeof(m_buf))\n+\treturn m_buf + std::__exchange(m_bytes, m_bytes + bytes);\n+\n+      __glibcxx_assert(m_ptr == nullptr);\n+      __glibcxx_assert(alignment != 1);\n+\n+      m_ptr = operator new(bytes);\n+      m_bytes = bytes;\n+      return m_ptr;\n+    }\n+\n+    void\n+    do_deallocate(void*, size_t, size_t) noexcept override\n+    { /* like pmr::monotonic_buffer_resource, do nothing here */ }\n+\n+    bool\n+    do_is_equal(const pmr::memory_resource& other) const noexcept override\n+    { return &other == this; }\n+\n+    static constexpr int guaranteed_capacity() { return sizeof(m_buf); }\n+\n+  private:\n+    char m_buf[512];\n+    size_t m_bytes = 0;\n+    void* m_ptr = nullptr;\n+  };\n+\n+  inline bool valid_fmt(chars_format fmt)\n+  {\n+    return fmt != chars_format{}\n+      && ((fmt & chars_format::general) == fmt\n+\t  || (fmt & chars_format::hex) == fmt);\n+  }\n+\n+  constexpr char hex_digits[] = \"abcdefABCDEF0123456789\";\n+  constexpr auto dec_digits = hex_digits + 12;\n+\n+  // Find initial portion of [first, last) containing a floating-point number.\n+  // The string `digits` is either `dec_digits` or `hex_digits`\n+  // and `exp` is 'e' or 'p' or '\\0'.\n+  const char*\n+  find_end_of_float(const char* first, const char* last, const char* digits,\n+\t\t    char exp)\n+  {\n+    while (first < last && strchr(digits, *first) != nullptr)\n+      ++first;\n+    if (first < last && *first == '.')\n+      {\n+\t++first;\n+\twhile (first < last && strchr(digits, *first))\n+\t  ++first;\n+      }\n+    if (first < last && exp != 0 && std::tolower((unsigned char)*first) == exp)\n+      {\n+\t++first;\n+\tif (first < last && (*first == '-' || *first == '+'))\n+\t  ++first;\n+\twhile (first < last && strchr(dec_digits, *first) != nullptr)\n+\t  ++first;\n+      }\n+    return first;\n+  }\n+\n+  // Determine the prefix of [first, last) that matches the pattern\n+  // corresponding to `fmt`.\n+  // Returns a NTBS containing the pattern, using `buf` to allocate\n+  // additional storage if needed.\n+  // Returns a nullptr if a valid pattern is not present.\n+  const char*\n+  pattern(const char* const first, const char* last,\n+\t  chars_format& fmt, pmr::string& buf)\n+  {\n+    // fmt has the value of one of the enumerators of chars_format.\n+    __glibcxx_assert(valid_fmt(fmt));\n+\n+    string_view res;\n+\n+    if (first == last || *first == '+') [[unlikely]]\n+\treturn nullptr;\n+\n+    const int neg = (*first == '-');\n+\n+    if (std::memchr(\"iInN\", (unsigned char)first[neg], 4))\n+      {\n+\tptrdiff_t len = last - first;\n+\tif (len < (3 + neg))\n+\t  return nullptr;\n+\n+\t// possible infinity or NaN, let strtod decide\n+\tif (first[neg] == 'i' || first[neg] == 'I')\n+\t  {\n+\t    // Need at most 9 chars for \"-INFINITY\", ignore anything after it.\n+\t    len = std::min(len, ptrdiff_t(neg + 8));\n+\t  }\n+\telse if (len > (neg + 3) && first[neg + 3] == '(')\n+\t  {\n+\t    // Look for end of \"NAN(n-char-sequence)\"\n+\t    if (void* p = std::memchr(const_cast<char*>(first)+4, ')', len-4))\n+\t      len = static_cast<char*>(p) + 1 - first;\n+#ifndef __cpp_exceptions\n+\t    if (len > buffer_resource::guaranteed_capacity())\n+\t      {\n+\t\t// The character sequence is too large for the buffer.\n+\t\t// Allocation failure could terminate the process,\n+\t\t// so just return an error via the fmt parameter.\n+\t\tfmt = chars_format{};\n+\t\treturn nullptr;\n+\t      }\n+#endif\n+\t  }\n+\telse // Only need 4 chars for \"-NAN\"\n+\t  len = neg + 3;\n+\n+\tbuf.assign(first, 0, len);\n+\t// prevent make_result correcting for \"0x\"\n+\tfmt = chars_format::general;\n+\treturn buf.c_str();\n+      }\n+\n+    const char* digits;\n+    char* ptr;\n+\n+    // Assign [first,last) to a std::string to get a NTBS that can be used\n+    // with strspn, strtod etc.\n+    // If the string would be longer than the fixed buffer inside the\n+    // buffer_resource type use find_end_of_float to try to reduce how\n+    // much memory is needed, to reduce the chance of std::bad_alloc.\n+\n+    if (fmt == chars_format::hex)\n+      {\n+\tdigits = hex_digits;\n+\n+\tif ((last - first + 2) > buffer_resource::guaranteed_capacity())\n+\t  {\n+\t    last = find_end_of_float(first + neg, last, digits, 'p');\n+#ifndef __cpp_exceptions\n+\t    if ((last - first + 2) > buffer_resource::guaranteed_capacity())\n+\t      {\n+\t\t// The character sequence is still too large for the buffer.\n+\t\t// Allocation failure could terminate the process,\n+\t\t// so just return an error via the fmt parameter.\n+\t\tfmt = chars_format{};\n+\t\treturn nullptr;\n+\t      }\n+#endif\n+\t  }\n+\n+\tbuf = \"-0x\" + !neg;\n+\tbuf.append(first + neg, last);\n+\tptr = buf.data() + neg + 2;\n+      }\n+    else\n+      {\n+\tdigits = dec_digits;\n+\n+\tif ((last - first) > buffer_resource::guaranteed_capacity())\n+\t  {\n+\t    last = find_end_of_float(first + neg, last, digits,\n+\t\t\t\t     \"e\"[fmt == chars_format::fixed]);\n+#ifndef __cpp_exceptions\n+\t    if ((last - first) > buffer_resource::guaranteed_capacity())\n+\t      {\n+\t\t// The character sequence is still too large for the buffer.\n+\t\t// Allocation failure could terminate the process,\n+\t\t// so just return an error via the fmt parameter.\n+\t\tfmt = chars_format{};\n+\t\treturn nullptr;\n+\t      }\n+#endif\n+\t  }\n+\tbuf.assign(first, last);\n+\tptr = buf.data() + neg;\n+      }\n+\n+    // \"A non-empty sequence of decimal digits\" or\n+    // \"A non-empty sequence of hexadecimal digits\"\n+    size_t len = std::strspn(ptr, digits);\n+    // \"possibly containing a radix character,\"\n+    if (ptr[len] == '.')\n+      {\n+\tconst size_t len2 = std::strspn(ptr + len + 1, digits);\n+\tif (len + len2)\n+\t  ptr += len + 1 + len2;\n+\telse\n+\t  return nullptr;\n+      }\n+    else if (len == 0) [[unlikely]]\n+      return nullptr;\n+    else\n+      ptr += len;\n+\n+    if (fmt == chars_format::fixed)\n+      {\n+\t// Truncate the string to stop strtod parsing past this point.\n+\t*ptr = '\\0';\n+      }\n+    else if (fmt == chars_format::scientific)\n+      {\n+\t// Check for required exponent part which starts with 'e' or 'E'\n+\tif (*ptr != 'e' && *ptr != 'E')\n+\t  return nullptr;\n+\t// then an optional plus or minus sign\n+\tconst int sign = (ptr[1] == '-' || ptr[1] == '+');\n+\t// then a nonempty sequence of decimal digits\n+\tif (!std::memchr(dec_digits, (unsigned char)ptr[1+sign], 10))\n+\t  return nullptr;\n+      }\n+    else if (fmt == chars_format::general)\n+      {\n+\tif (*ptr == 'x' || *ptr == 'X')\n+\t  *ptr = '\\0';\n+      }\n+\n+    return buf.c_str();\n+  }\n+\n+  // Convert the NTBS `str` to a floating-point value of type `T`.\n+  // If `str` cannot be converted, `value` is unchanged and `0` is returned.\n+  // Otherwise, let N be the number of characters consumed from `str`.\n+  // On success `value` is set to the converted value and N is returned.\n+  // If the converted value is out of range, `value` is unchanged and\n+  // -N is returned.\n+  template<typename T>\n+  ptrdiff_t\n+  from_chars_impl(const char* str, T& value, errc& ec) noexcept\n+  {\n+    if (locale_t loc = ::newlocale(LC_ALL, \"C\", (locale_t)0)) [[likely]]\n+      {\n+\tlocale_t orig = ::uselocale(loc);\n+\n+\tconst int save_errno = errno;\n+\terrno = 0;\n+\tchar* endptr;\n+\tT tmpval;\n+\tif constexpr (is_same_v<T, float>)\n+\t  tmpval = std::strtof(str, &endptr);\n+\tif constexpr (is_same_v<T, double>)\n+\t  tmpval = std::strtod(str, &endptr);\n+\telse if constexpr (is_same_v<T, long double>)\n+\t  tmpval = std::strtold(str, &endptr);\n+\tconst int conv_errno = std::__exchange(errno, save_errno);\n+\n+\t::uselocale(orig);\n+\t::freelocale(loc);\n+\n+\tconst ptrdiff_t n = endptr - str;\n+\tif (conv_errno == ERANGE) [[unlikely]]\n+\t  {\n+\t    if (std::isinf(tmpval)) // overflow\n+\t      ec = errc::result_out_of_range;\n+\t    else // underflow (LWG 3081 wants to set value = tmpval here)\n+\t      ec = errc::result_out_of_range;\n+\t  }\n+\telse if (n)\n+\t  {\n+\t    value = tmpval;\n+\t    ec = errc();\n+\t  }\n+\treturn n;\n+      }\n+    else if (errno == ENOMEM)\n+      ec = errc::not_enough_memory;\n+\n+    return 0;\n+  }\n+\n+  inline from_chars_result\n+  make_result(const char* str, ptrdiff_t n, chars_format fmt, errc ec) noexcept\n+  {\n+    from_chars_result result = { str, ec };\n+    if (n != 0)\n+      {\n+\tif (fmt == chars_format::hex)\n+\t  n -= 2; // correct for the \"0x\" inserted into the pattern\n+\tresult.ptr += n;\n+      }\n+    else if (fmt == chars_format{}) [[unlikely]]\n+      {\n+\t// FIXME: the standard does not allow this result.\n+\tec = errc::not_enough_memory;\n+      }\n+    return result;\n+  }\n+\n+} // namespace\n+\n+// FIXME: This should be reimplemented so it doesn't use strtod and newlocale.\n+// That will avoid the need for any memory allocation, meaning that the\n+// non-conforming errc::not_enough_memory result cannot happen.\n+\n+from_chars_result\n+from_chars(const char* first, const char* last, float& value,\n+\t   chars_format fmt) noexcept\n+{\n+  buffer_resource mr;\n+  pmr::string buf(&mr);\n+  size_t len = 0;\n+  errc ec = errc::invalid_argument;\n+  __try\n+    {\n+      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n+\tlen = from_chars_impl(pat, value, ec);\n+    }\n+  __catch (const std::bad_alloc&)\n+    {\n+      fmt = chars_format{};\n+    }\n+  return make_result(first, len, fmt, ec);\n+}\n+\n+from_chars_result\n+from_chars(const char* first, const char* last, double& value,\n+\t   chars_format fmt) noexcept\n+{\n+  buffer_resource mr;\n+  pmr::string buf(&mr);\n+  size_t len = 0;\n+  errc ec = errc::invalid_argument;\n+  __try\n+    {\n+      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n+\tlen = from_chars_impl(pat, value, ec);\n+    }\n+  __catch (const std::bad_alloc&)\n+    {\n+      fmt = chars_format{};\n+    }\n+  return make_result(first, len, fmt, ec);\n+}\n+\n+from_chars_result\n+from_chars(const char* first, const char* last, long double& value,\n+\t   chars_format fmt) noexcept\n+{\n+  buffer_resource mr;\n+  pmr::string buf(&mr);\n+  size_t len = 0;\n+  errc ec = errc::invalid_argument;\n+  __try\n+    {\n+      if (const char* pat = pattern(first, last, fmt, buf)) [[likely]]\n+\tlen = from_chars_impl(pat, value, ec);\n+    }\n+  __catch (const std::bad_alloc&)\n+    {\n+      fmt = chars_format{};\n+    }\n+  return make_result(first, len, fmt, ec);\n+}\n+\n+#ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n+extern \"C\" from_chars_result\n+_ZSt10from_charsPKcS0_ReSt12chars_format(const char* first, const char* last,\n+\t\t\t\t\t long double& value,\n+\t\t\t\t\t chars_format fmt) noexcept\n+__attribute__((alias (\"_ZSt10from_charsPKcS0_RdSt12chars_format\")));\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // _GLIBCXX_HAVE_USELOCALE"}, {"sha": "b3ca6525681282770d2e13b7c5570bdf41858f2e", "filename": "libstdc++-v3/testsuite/20_util/from_chars/1_c++20_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_c%2B%2B20_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_c%2B%2B20_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_c%2B%2B20_neg.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -41,3 +41,4 @@ test01(const char* first, const char* last)\n }\n \n // { dg-prune-output \"enable_if\" }\n+// { dg-prune-output \"cannot bind non-const lvalue reference\" }"}, {"sha": "0d2fe2b3e659482e1dc491bfb4019c897b00aa3c", "filename": "libstdc++-v3/testsuite/20_util/from_chars/1_neg.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_neg.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -44,3 +44,4 @@ test01(const char* first, const char* last)\n }\n \n // { dg-prune-output \"enable_if\" }\n+// { dg-prune-output \"cannot bind non-const lvalue reference\" }"}, {"sha": "e5e2db82c3fd4abe6f30196b4e3eca4cf66215ad", "filename": "libstdc++-v3/testsuite/20_util/from_chars/2.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F2.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -55,6 +55,12 @@ test01()\n   VERIFY( r.ptr == s.data() );\n   VERIFY( i == 999 );\n \n+  s = \"+1\";\n+  r = std::from_chars(s.data(), s.data() + s.length(), i);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.data() );\n+  VERIFY( i == 999 );\n+\n   unsigned u = 888;\n   s = \"-1\";\n   r = std::from_chars(s.data(), s.data() + s.length(), u);\n@@ -69,6 +75,11 @@ test01()\n   VERIFY( r.ec == std::errc::invalid_argument );\n   VERIFY( r.ptr == s.data() );\n   VERIFY( u == 888 );\n+  s = \"+1\";\n+  r = std::from_chars(s.data(), s.data() + s.length(), u);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.data() );\n+  VERIFY( u == 888 );\n \n   for (int base = 2; base <= 36; ++base)\n   {"}, {"sha": "6d692592e953921a0c5aa005a7bfd894bfed43cd", "filename": "libstdc++-v3/testsuite/20_util/from_chars/4.cc", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F4.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -0,0 +1,368 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// <charconv> is supported in C++14 as a GNU extension\n+// { dg-do run { target c++14 } }\n+\n+#include <charconv>\n+#include <string>\n+#include <limits>\n+#include <cmath>\n+#include <cstdlib>\n+#include <testsuite_hooks.h>\n+\n+// Test std::from_chars floating-point conversions.\n+\n+void\n+test01()\n+{\n+  std::string s;\n+  double d;\n+  std::from_chars_result res;\n+\n+  for (auto fmt : { std::chars_format::fixed, std::chars_format::scientific,\n+\t\t    std::chars_format::general, std::chars_format::hex })\n+  {\n+    s = \"Info\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+    VERIFY( std::isinf(d) );\n+    VERIFY( res.ptr == s.data() + 3 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"-INFIN\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+    VERIFY( std::isinf(d) );\n+    VERIFY( d < 0 );\n+    VERIFY( res.ptr == s.data() + 4 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"InFiNiTy aNd BeYoNd\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+    VERIFY( std::isinf(d) );\n+    VERIFY( res.ptr == s.data() + 8 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"nAn\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+    VERIFY( std::isnan(d) );\n+    VERIFY( res.ptr == s.data() + 3 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"-NAN()\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+    VERIFY( std::isnan(d) );\n+    VERIFY( res.ptr == s.data() + s.length() );\n+    VERIFY( res.ec == std::errc{} );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  std::string s;\n+  double d = 1.0;\n+  std::from_chars_result res;\n+\n+  s = \"0x123\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), d);\n+  VERIFY( d == 0.0 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::fixed);\n+  VERIFY( d == 0.0 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::scientific);\n+  VERIFY( d == 1.0 );\n+  VERIFY( res.ptr == s.data() );\n+  VERIFY( res.ec == std::errc::invalid_argument );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::general);\n+  VERIFY( d == 0.0 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::hex);\n+  VERIFY( d == 0.0 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+}\n+\n+void\n+test03()\n+{\n+  std::string s;\n+  double d = 1.0;\n+  std::from_chars_result res;\n+\n+  s = \"0.5e+2azzz\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), d);\n+  VERIFY( d == 0.5e+2 );\n+  VERIFY( res.ptr == s.data() + s.length() - 1 - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::fixed);\n+  VERIFY( d == 0.5 );\n+  VERIFY( res.ptr == s.data() + 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::scientific);\n+  VERIFY( d == 0.5e+2 );\n+  VERIFY( res.ptr == s.data() + s.length() - 1 - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::general);\n+  VERIFY( d == 0.5e+2 );\n+  VERIFY( res.ptr == s.data() + s.length() - 1 - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  d = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::hex);\n+  VERIFY( d == 0x0.5Ep0 );\n+  VERIFY( res.ptr == s.data() + 4 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  s = \"1.Ap-2zzz\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::hex);\n+  VERIFY( d == 0.40625 );\n+  VERIFY( res.ptr == s.data() + s.length() - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+}\n+\n+void\n+test04()\n+{\n+  // Huge input strings\n+  std::string s(1000, '0');\n+  double d = 1.0;\n+  std::from_chars_result res;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d);\n+  VERIFY( res.ptr == s.data() + s.length() );\n+  VERIFY( res.ec == std::errc{} );\n+  VERIFY( d == 0.0 );\n+\n+  s += \".5\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), d);\n+  VERIFY( res.ptr == s.data() + s.length() );\n+  VERIFY( res.ec == std::errc{} );\n+  VERIFY( d == 0.5 );\n+\n+  s += \"e2\";\n+  auto len = s.length();\n+  s += std::string(1000, 'a');\n+  res = std::from_chars(s.data(), s.data() + s.length(), d);\n+  VERIFY( res.ptr == s.data() + len );\n+  VERIFY( res.ec == std::errc{} );\n+  VERIFY( d == 50 );\n+}\n+\n+using std::to_string;\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+std::string\n+to_string(unsigned __GLIBCXX_TYPE_INT_N_0 val)\n+{\n+  using Limits = std::numeric_limits<unsigned __GLIBCXX_TYPE_INT_N_0>;\n+  std::string s(Limits::digits10+2, '0');\n+  for (auto iter = s.end(); val != 0; val /= 10)\n+    *--iter = '0' + (val % 10);\n+  return s;\n+}\n+#endif\n+\n+void\n+test05()\n+{\n+  std::from_chars_result res;\n+  float flt;\n+  double dbl;\n+  long double ldbl;\n+\n+  // Small integer values that are exactly representable\n+\n+  for (int i = 0; i < 100; ++i)\n+  {\n+    std::string s = to_string(i);\n+    int len = s.length();\n+    s += \"123\";\n+    const char* s1 = s.c_str();\n+    const char* s1_end = s1 + len;\n+\n+    for (auto fmt : { std::chars_format::fixed,\n+\t\t      std::chars_format::general,\n+\t\t      std::chars_format::hex })\n+    {\n+      if (fmt == std::chars_format::hex && i > 9)\n+\tcontinue;\n+\n+      res = std::from_chars(s1, s1_end, flt, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s1_end );\n+      VERIFY( flt == i );\n+\n+      res = std::from_chars(s1, s1_end, dbl, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s1_end );\n+      VERIFY( dbl == i );\n+\n+      res = std::from_chars(s1, s1_end, ldbl, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s1_end );\n+      VERIFY( ldbl == i );\n+    }\n+\n+    if (i > 9)\n+      continue;\n+\n+    // Test single-digit integers with small exponents.\n+\n+    const char s2[] = { '.', *s1, 'e', '0', '0', '0', '1' };\n+    const char* s2_end = s2 + sizeof(s2);\n+\n+    const char s3[] = { *s1, '0', 'e', '-', '0', '0', '1' };\n+    const char* s3_end = s3 + sizeof(s3);\n+\n+    for (auto fmt : { std::chars_format::scientific,\n+\t\t      std::chars_format::general })\n+    {\n+      res = std::from_chars(s2, s2_end, flt, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s2_end );\n+      VERIFY( flt == i );\n+\n+      res = std::from_chars(s3, s3_end, flt, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s3_end );\n+      VERIFY( flt == i );\n+\n+      res = std::from_chars(s2, s2_end, dbl, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s2_end );\n+      VERIFY( dbl == i );\n+\n+      res = std::from_chars(s3, s3_end, dbl, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s3_end );\n+      VERIFY( dbl == i );\n+\n+      res = std::from_chars(s2, s2_end, ldbl, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s2_end );\n+      VERIFY( ldbl == i );\n+\n+      res = std::from_chars(s3, s3_end, ldbl, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s3_end );\n+      VERIFY( ldbl == i );\n+    }\n+  }\n+}\n+\n+template<typename FloatT, typename UIntT>\n+void\n+test_max_mantissa()\n+{\n+  using Float_limits = std::numeric_limits<FloatT>;\n+  using UInt_limits = std::numeric_limits<UIntT>;\n+\n+  if constexpr (Float_limits::is_iec559\n+\t\t&& Float_limits::digits < UInt_limits::digits)\n+  {\n+    std::printf(\"Testing %d-bit float, using %zu-bit integer\\n\",\n+\tFloat_limits::digits + (int)std::log2(Float_limits::max_exponent) + 1,\n+\tsizeof(UIntT) * __CHAR_BIT__);\n+\n+    std::from_chars_result res;\n+    FloatT flt;\n+\n+    for (int i = 0; i < 10; ++i)\n+    {\n+      // (1 << digits) - 1 is the maximum value of the mantissa\n+      const auto val = ((UIntT)1 << Float_limits::digits) - 1 - i;\n+      std::string s = to_string(val);\n+      auto len = s.length();\n+      s += \"000\"; // these should be ignored\n+      for (auto fmt : { std::chars_format::fixed,\n+\t\t\tstd::chars_format::general })\n+      {\n+\tres = std::from_chars(s.data(), s.data() + len, flt, fmt);\n+\tVERIFY( res.ec == std::errc{} );\n+\tVERIFY( res.ptr == s.data() + len );\n+\tVERIFY( flt == val );\n+      }\n+      s.resize(len);\n+      const auto orig_len = len;\n+      s += \"e+000\";\n+      len = s.length();\n+      s += \"111\";\n+      for (auto fmt : { std::chars_format::scientific,\n+\t\t\tstd::chars_format::general })\n+      {\n+\tres = std::from_chars(s.data(), s.data() + len, flt, fmt);\n+\tVERIFY( res.ec == std::errc{} );\n+\tVERIFY( res.ptr == s.data() + len );\n+\tVERIFY( flt == val );\n+\n+\tstd::string s2 = s.substr(0, len - 5);\n+\ts2.insert(s2.cbegin() + orig_len - 1, '.');\n+\ts2 += \"e000000000001\";\n+\tres = std::from_chars(s.data(), s.data() + len, flt, fmt);\n+\tVERIFY( res.ec == std::errc{} );\n+\tVERIFY( res.ptr == s.data() + len );\n+\tVERIFY( flt == val );\n+      }\n+    }\n+  }\n+}\n+\n+void\n+test06()\n+{\n+  test_max_mantissa<float, unsigned long>();\n+  test_max_mantissa<double, unsigned long long>();\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+  test_max_mantissa<long double, unsigned __GLIBCXX_TYPE_INT_N_0>();\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+}"}, {"sha": "f8fc7f6cd1240da567f93ba3b2887c658810a041", "filename": "libstdc++-v3/testsuite/20_util/from_chars/5.cc", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F5.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -0,0 +1,163 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// <charconv> is supported in C++14 as a GNU extension\n+// { dg-do run { target c++14 } }\n+\n+#include <charconv>\n+#include <string>\n+#include <cmath>\n+#include <testsuite_hooks.h>\n+\n+// Test std::from_chars error handling.\n+\n+void\n+test01()\n+{\n+  std::from_chars_result r;\n+  double d = 3.2;\n+  std::string s;\n+\n+  for (auto p : { \"\", \"*\", \".\", \"-\", \"-*\", \"-.\", \"+\", \"+.\", \"+-\", \"-+\", \"+1\",\n+\t\t  \".p1\", \"-.p1\",\n+\t\t  \"in\", \"inch\", \"+inf\", \"na\", \"nam\", \"+nan\" })\n+  {\n+    s = p;\n+    for (auto fmt : { std::chars_format::fixed, std::chars_format::scientific,\n+\t\t      std::chars_format::general, std::chars_format::hex })\n+    {\n+      r = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+      VERIFY( r.ec == std::errc::invalid_argument );\n+      VERIFY( r.ptr == s.data() );\n+      VERIFY( d == 3.2 );\n+    }\n+  }\n+\n+  for (auto p : { \".e1\", \"-.e1\" }) // These are valid patterns for hex format\n+  {\n+    s = p;\n+    for (auto fmt : { std::chars_format::fixed, std::chars_format::scientific,\n+\t\t      std::chars_format::general })\n+    {\n+      r = std::from_chars(s.data(), s.data() + s.length(), d, fmt);\n+      VERIFY( r.ec == std::errc::invalid_argument );\n+      VERIFY( r.ptr == s.data() );\n+      VERIFY( d == 3.2 );\n+    }\n+  }\n+\n+  // scientific format requires an exponent\n+  for (auto p : { \"1.2\", \"-1.2\", \"1.2e\", \"-1.2e\", \"1.2e-\", \"-1.2e+\" })\n+  {\n+    s = p;\n+    r = std::from_chars(s.data(), s.data() + s.length(), d,\n+\t\t\tstd::chars_format::scientific);\n+    VERIFY( r.ec == std::errc::invalid_argument );\n+    VERIFY( r.ptr == s.data() );\n+    VERIFY( d == 3.2 );\n+  }\n+\n+  // patterns that are invalid without the final character\n+  for (auto p : { \"1\", \".1\", \"-1\", \"-.1\",\n+\t\t  \"inf\", \"-inf\", \"nan\", \"-nan\" })\n+  {\n+    s = p;\n+    for (auto fmt : { std::chars_format::fixed, std::chars_format::scientific,\n+\t\t      std::chars_format::general, std::chars_format::hex })\n+    {\n+      r = std::from_chars(s.data(), s.data() + s.length() - 1, d, fmt);\n+      VERIFY( r.ec == std::errc::invalid_argument );\n+      VERIFY( r.ptr == s.data() );\n+      VERIFY( d == 3.2 );\n+    }\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  std::from_chars_result r;\n+  std::string s;\n+\n+  float f = 0.5;\n+  // Overflow\n+  s = \"99999999999999999e999999999999999999\";\n+  r = std::from_chars(s.data(), s.data() + s.length(), f);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.data() + s.length() );\n+  VERIFY( f == 0.5 );\n+\n+  s += '*';\n+  r = std::from_chars(s.data(), s.data() + s.length(), f);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.data() + s.length() - 1 );\n+  VERIFY( f == 0.5 );\n+\n+  s.insert(s.begin(), '-');\n+  r = std::from_chars(s.data(), s.data() + s.length(), f);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.data() + s.length() - 1 );\n+  VERIFY( f == 0.5 );\n+}\n+\n+void\n+test03()\n+{\n+  double d = 0.5;\n+  // Underflow\n+  std::string s(\"-1.2345e-9999zzz\");\n+  std::from_chars_result res;\n+  res = std::from_chars(s.data(), s.data() + s.length(), d);\n+  VERIFY( res.ptr == s.data() + s.length() - 3 );\n+  VERIFY( res.ec == std::errc::result_out_of_range );\n+  VERIFY( d == 0.5 );\n+\n+  res = std::from_chars(s.data() + 1, s.data() + s.length(), d);\n+  VERIFY( res.ptr == s.data() + s.length() - 3 );\n+  VERIFY( res.ec == std::errc::result_out_of_range );\n+  VERIFY( d == 0.5 );\n+}\n+\n+void\n+test04()\n+{\n+  std::from_chars_result res;\n+  std::string z(2000, '0');\n+  // Invalid inputs for scientific format\n+  for (const char* s : { \"\", \"1\", \".\", \".0\", \".5\", \"1e+\", \"1e+-1\" })\n+  {\n+    for (auto len : { 0, 10, 100, 1000, 2000 })\n+    {\n+      auto str = z.substr(len) + s;\n+      double d = 99.0;\n+      res = std::from_chars(str.data(), str.data() + str.length(), d,\n+\t\t\t    std::chars_format::scientific);\n+      VERIFY( res.ec == std::errc::invalid_argument );\n+      VERIFY( res.ptr == str.data() );\n+      VERIFY( d == 99.0 );\n+    }\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "fd8224b6789d23ad428ebd80a9fff16527bd5ade", "filename": "libstdc++-v3/testsuite/util/testsuite_abi.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932fbc868ad429167a3d4d5625aa9d6dc0b4506b/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_abi.cc?ref=932fbc868ad429167a3d4d5625aa9d6dc0b4506b", "patch": "@@ -209,6 +209,8 @@ check_version(symbol& test, bool added)\n       known_versions.push_back(\"GLIBCXX_3.4.26\");\n       known_versions.push_back(\"GLIBCXX_3.4.27\");\n       known_versions.push_back(\"GLIBCXX_3.4.28\");\n+      known_versions.push_back(\"GLIBCXX_3.4.29\");\n+      known_versions.push_back(\"GLIBCXX_LDBL_3.4.29\");\n       known_versions.push_back(\"CXXABI_1.3\");\n       known_versions.push_back(\"CXXABI_LDBL_1.3\");\n       known_versions.push_back(\"CXXABI_1.3.1\");\n@@ -240,7 +242,10 @@ check_version(symbol& test, bool added)\n \ttest.version_status = symbol::incompatible;\n \n       // Check that added symbols are added in the latest pre-release version.\n-      bool latestp = (test.version_name == \"GLIBCXX_3.4.28\"\n+      bool latestp = (test.version_name == \"GLIBCXX_3.4.29\"\n+\t  // XXX remove next line when GLIBCXX_3.4.30 is added and baselines\n+\t  // have been regenerated to include GLIBCXX_LDBL_3.4.29 symbols:\n+\t\t     || test.version_name == \"GLIBCXX_LDBL_3.4.29\"\n \t\t     || test.version_name == \"CXXABI_1.3.12\"\n \t\t     || test.version_name == \"CXXABI_FLOAT128\"\n \t\t     || test.version_name == \"CXXABI_TM_1\");"}]}