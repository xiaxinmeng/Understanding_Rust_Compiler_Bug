{"sha": "942632ac1b55d893c57fe62d4e96c12f2c47f105", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQyNjMyYWMxYjU1ZDg5M2M1N2ZlNjJkNGU5NmMxMmYyYzQ3ZjEwNQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-03-29T12:33:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-29T12:33:51Z"}, "message": "except.c (do_unwind): Delete dead function.\n\n        * except.c (do_unwind): Delete dead function.\n        (easy_expand_asm): Likewise.\n\nFrom-SVN: r18898", "tree": {"sha": "fd5675e9e0b8bbc67531ac02628f95a6d755e3c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd5675e9e0b8bbc67531ac02628f95a6d755e3c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/942632ac1b55d893c57fe62d4e96c12f2c47f105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942632ac1b55d893c57fe62d4e96c12f2c47f105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/942632ac1b55d893c57fe62d4e96c12f2c47f105", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/942632ac1b55d893c57fe62d4e96c12f2c47f105/comments", "author": null, "committer": null, "parents": [{"sha": "228fab4ab6fb94957fa4ae6755db1c5e0bf9a462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/228fab4ab6fb94957fa4ae6755db1c5e0bf9a462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/228fab4ab6fb94957fa4ae6755db1c5e0bf9a462"}], "stats": {"total": 99, "additions": 3, "deletions": 96}, "files": [{"sha": "cd3de91a93f6fb0652d097d91232d6e9887415e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942632ac1b55d893c57fe62d4e96c12f2c47f105/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942632ac1b55d893c57fe62d4e96c12f2c47f105/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=942632ac1b55d893c57fe62d4e96c12f2c47f105", "patch": "@@ -1,5 +1,8 @@\n Sun Mar 29 00:47:32 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* except.c (do_unwind): Delete dead function.\n+\t(easy_expand_asm): Likewise.\n+\n \t* cvt.c (build_conversion_type_1): Delete dead function.\n \n \t* cp-tree.h (push_expression_obstack): Declare."}, {"sha": "7eb3c51d0b0faa65993806979f4f9b58f8c0ab86", "filename": "gcc/cp/except.c", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/942632ac1b55d893c57fe62d4e96c12f2c47f105/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/942632ac1b55d893c57fe62d4e96c12f2c47f105/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=942632ac1b55d893c57fe62d4e96c12f2c47f105", "patch": "@@ -42,22 +42,12 @@ tree builtin_return_address_fndecl;\n \n /* A couple of backend routines from m88k.c */\n \n-static void easy_expand_asm PROTO((char *));\n static void push_eh_cleanup PROTO((void));\n-static void do_unwind PROTO((rtx));\n static rtx do_function_call PROTO((tree, tree, tree));\n static tree build_eh_type_type PROTO((tree));\n static tree build_eh_type PROTO((tree));\n static void expand_end_eh_spec PROTO((tree));\n \n-static void\n-easy_expand_asm (str)\n-     char *str;\n-{\n-  expand_asm (build_string (strlen (str)+1, str));\n-}\n-\n-\n #if 0\n /* This is the startup, and finish stuff per exception table.  */\n \n@@ -653,92 +643,6 @@ expand_end_catch_block ()\n   emit_label (pop_label_entry (&false_label_stack));\n }\n \n-/* unwind the stack.  */\n-\n-static void\n-do_unwind (inner_throw_label)\n-     rtx inner_throw_label;\n-{\n-#if defined (SPARC_STACK_ALIGN) /* was sparc */\n-  /* This doesn't work for the flat model sparc, nor does it need to\n-     as the default unwinder is only used to unwind non-flat frames.  */\n-  tree fcall;\n-  tree params;\n-  rtx next_pc;\n-  rtx temp;\n-\n-  /* Call to  __builtin_return_address. */\n-  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n-  fcall = build_function_call (builtin_return_address_fndecl, params);\n-  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n-  /* In the return, the new pc is pc+8, as the value coming in is\n-     really the address of the call insn, not the next insn.  */\n-  temp = gen_reg_rtx (Pmode);\n-  emit_move_insn (temp, inner_throw_label);\n-  emit_move_insn (next_pc, plus_constant (temp, -8));\n-  emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, 31)));\n-  easy_expand_asm (\"ret\");\n-  easy_expand_asm (\"restore\");\n-  emit_barrier ();\n-#endif\n-#if defined (ARM_FRAME_RTX)  /* was __arm */\n-  if (flag_omit_frame_pointer)\n-    sorry (\"this implementation of exception handling requires a frame pointer\");\n-\n-  emit_move_insn (stack_pointer_rtx,\n-\t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -8)));\n-  emit_move_insn (hard_frame_pointer_rtx,\n-\t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -12)));\n-#endif\n-#if defined (TARGET_88000) /* was m88k */\n-  rtx temp_frame = frame_pointer_rtx;\n-\n-  temp_frame = memory_address (Pmode, temp_frame);\n-  temp_frame = copy_to_reg (gen_rtx (MEM, Pmode, temp_frame));\n-\n-  /* hopefully this will successfully pop the frame! */\n-  emit_move_insn (frame_pointer_rtx, temp_frame);\n-  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-  emit_move_insn (arg_pointer_rtx, frame_pointer_rtx);\n-  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (stack_pointer_rtx, 0))));\n-\n-#if 0\n-  emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n-\n-  emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);\n-\n-  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n-#endif\n-#endif\n-#if ! defined (TARGET_88000) && ! defined (ARM_FRAME_RTX) && ! defined (SPARC_STACK_ALIGN)\n-#if 0\n-  tree fcall;\n-  rtx next_pc;\n-#endif\n-  tree params;\n-\n-#if 0\n-  /* I would like to do this here, but the move below doesn't seem to work.  */\n-  /* Call to  __builtin_return_address.  */\n-  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n-  fcall = build_function_call (builtin_return_address_fndecl, params);\n-  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n-\n-  emit_move_insn (next_pc, inner_throw_label);\n-  /* So, for now, just pass throw label to stack unwinder.  */\n-#endif\n-  params = expr_tree_cons (NULL_TREE, make_tree (ptr_type_node,\n-\t\t\t\t\t    inner_throw_label), NULL_TREE);\n-  \n-  do_function_call (Unwind, params, NULL_TREE);\n-  emit_barrier ();\n-#endif\n-}\n-\n-\n /* An exception spec is implemented more or less like:\n \n    try {"}]}