{"sha": "edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRkNzFmMGY2Y2Q5YTMwMzg3NGQ0YTNlNjA0YTVmNWZlNzYwYTk3NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-11T01:43:47Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-11T01:43:47Z"}, "message": "h8300.c (expand_a_rotate): New.\n\n        * h8300.c (expand_a_rotate): New.\n        (emit_a_rotate): Likewise.\n        (h8300_adjust_insn_length): Add support for the rotate insns.\n        * h8300.md (rotlqi3): New.\n        (*rotlqi3_1): Likewise.\n        (rotlhi3): Likewise.\n        (*rotlhi3_1): Likewise.\n        (rotlhi3): Likewise.\n        (*rotlhi3_1): Likewise.\n        * h8300-proto.h: Add prototypes for expand_a_rotate and\n        emit_a_rotate.\n\nFrom-SVN: r35616", "tree": {"sha": "faabefbb5aa1ec913af93e5ae0128448ac55d82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faabefbb5aa1ec913af93e5ae0128448ac55d82f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/comments", "author": null, "committer": null, "parents": [{"sha": "dff55dbc71b08ecca61d1069f386d080ab9dbd0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff55dbc71b08ecca61d1069f386d080ab9dbd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff55dbc71b08ecca61d1069f386d080ab9dbd0d"}], "stats": {"total": 288, "additions": 288, "deletions": 0}, "files": [{"sha": "570ba13601d0f7cd903f55d0cfa7e310111c8223", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "patch": "@@ -13,6 +13,18 @@\n \n 2000-08-10  Kazu Hirata  <kazu@hxi.com>\n \n+        * h8300.c (expand_a_rotate): New.\n+        (emit_a_rotate): Likewise.\n+        (h8300_adjust_insn_length): Add support for the rotate insns.\n+        * h8300.md (rotlqi3): New.\n+        (*rotlqi3_1): Likewise.\n+        (rotlhi3): Likewise.\n+        (*rotlhi3_1): Likewise.\n+        (rotlhi3): Likewise.\n+        (*rotlhi3_1): Likewise.\n+        * h8300-proto.h: Add prototypes for expand_a_rotate and\n+        emit_a_rotate.\n+\n \t* h8300.c: Fix comment typos.\n \t(dosize): Declare the variable amount as unsigned.\n \t(get_shift_alg): Fix a comparison between signed and unsigned."}, {"sha": "d8e4e69ffbbb9ab006a0e7c30abe8dbd3fd3f3fe", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n /* Declarations for functions used in insn-output.c.  */\n #ifdef RTX_CODE\n extern const char *emit_a_shift PARAMS ((rtx, rtx *));\n+extern const char *emit_a_rotate PARAMS ((int, rtx *));\n extern const char *output_adds_subs PARAMS ((rtx *));\n extern const char *output_simode_bld PARAMS ((int, int, rtx[]));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n@@ -34,6 +35,7 @@ extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n extern int do_movsi PARAMS ((rtx[]));\n extern void notice_update_cc PARAMS ((rtx, rtx));\n extern int expand_a_shift PARAMS ((enum machine_mode, int, rtx[]));\n+extern int expand_a_rotate PARAMS ((int, rtx[]));\n extern int fix_bit_operand PARAMS ((rtx *, int, enum rtx_code));\n extern int h8300_adjust_insn_length PARAMS ((rtx, int));\n extern void split_adds_subs PARAMS ((enum machine_mode, rtx[]));"}, {"sha": "3e8208830822e68d6974228b7ee34b9040fe4a20", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "patch": "@@ -2662,6 +2662,177 @@ emit_a_shift (insn, operands)\n     }\n }\n \f\n+/* A rotation by a non-constant will cause a loop to be generated, in\n+   which a rotation by one bit is used.  A rotation by a constant,\n+   including the one in the loop, will be taken care of by\n+   emit_a_rotate () at the insn emit time.  */\n+\n+int\n+expand_a_rotate (code, operands)\n+     int code;\n+     rtx operands[];\n+{\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+  rtx rotate_amount = operands[2];\n+  enum machine_mode mode = GET_MODE (dst);\n+  rtx tmp;\n+\n+  /* We rotate in place.  */\n+  emit_move_insn (dst, src);\n+\n+  if (GET_CODE (rotate_amount) != CONST_INT)\n+    {\n+      rtx counter = gen_reg_rtx (QImode);\n+      rtx start_label = gen_label_rtx ();\n+      rtx end_label = gen_label_rtx ();\n+\n+      /* If the rotate amount is less than or equal to 0,\n+\t we go out of the loop.  */\n+      emit_cmp_and_jump_insns (rotate_amount, GEN_INT (0),\n+\t\t\t       LE, NULL_RTX, QImode, 0, 0, end_label);\n+\n+      /* Initialize the loop counter.  */\n+      emit_move_insn (counter, rotate_amount);\n+\n+      emit_label (start_label);\n+\n+      /* Rotate by one bit.  */\n+      tmp = gen_rtx (code, mode, dst, GEN_INT (1));\n+      emit_insn (gen_rtx_SET (mode, dst, tmp));\n+\n+      /* Decrement the counter by 1.  */\n+      tmp = gen_rtx_PLUS (QImode, counter, GEN_INT (-1));\n+      emit_insn (gen_rtx_SET (VOIDmode, counter, tmp));\n+\n+      /* If the loop counter is non-zero, we go back to the beginning\n+\t of the loop.  */\n+      emit_cmp_and_jump_insns (counter, GEN_INT (0),\n+\t\t\t       NE, NULL_RTX, QImode, 1, 0, start_label);\n+\n+      emit_label (end_label);\n+    }\n+  else\n+    {\n+      /* Rotate by AMOUNT bits.  */\n+      tmp = gen_rtx (code, mode, dst, rotate_amount);\n+      emit_insn (gen_rtx_SET (mode, dst, tmp));\n+    }\n+\n+  return 1;\n+}\n+\n+/* Emit rotate insns.  */\n+\n+const char *\n+emit_a_rotate (code, operands)\n+     int code;\n+     rtx *operands;\n+{\n+  rtx dst = operands[0];\n+  rtx rotate_amount = operands[2];\n+  enum shift_mode rotate_mode;\n+  enum shift_type rotate_type;\n+  const char *insn_buf;\n+  int bits;\n+  int amount;\n+  enum machine_mode mode = GET_MODE (dst);\n+\n+  if (GET_CODE (rotate_amount) != CONST_INT)\n+    abort ();\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      rotate_mode = QIshift;\n+      break;\n+    case HImode:\n+      rotate_mode = HIshift;\n+      break;\n+    case SImode:\n+      rotate_mode = SIshift;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  switch (code)\n+    {\n+    case ROTATERT:\n+      rotate_type = SHIFT_ASHIFT;\n+      break;\n+    case ROTATE:\n+      rotate_type = SHIFT_LSHIFTRT;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  amount = INTVAL (rotate_amount);\n+\n+  /* Clean up AMOUNT.  */\n+  if (amount < 0)\n+    amount = 0;\n+  if ((unsigned int) amount > GET_MODE_BITSIZE (mode))\n+    amount = GET_MODE_BITSIZE (mode);\n+\n+  /* Determine the faster direction.  After this phase, amount will be\n+     at most a half of GET_MODE_BITSIZE (mode).  */\n+  if ((unsigned int) amount > GET_MODE_BITSIZE (mode) / 2)\n+    {\n+      /* Flip the direction.  */\n+      amount = GET_MODE_BITSIZE (mode) - amount;\n+      rotate_type =\n+\t(rotate_type == SHIFT_ASHIFT) ? SHIFT_LSHIFTRT : SHIFT_ASHIFT;\n+    }\n+\n+  /* See if a byte swap (in HImode) or a word swap (in SImode) can\n+     boost up the rotation.  */\n+  if ((mode == HImode && TARGET_H8300 && amount >= 5)\n+      || (mode == HImode && TARGET_H8300H && amount >= 6)\n+      || (mode == HImode && TARGET_H8300S && amount == 8)\n+      || (mode == SImode && TARGET_H8300H && amount >= 10)\n+      || (mode == SImode && TARGET_H8300S && amount >= 13))\n+    {\n+      switch (mode)\n+\t{\n+\tcase HImode:\n+\t  /* This code works on any family.  */\n+\t  insn_buf = \"xor.b\\t%s0,%t0\\n\\txor.b\\t%t0,%s0\\n\\txor.b\\t%s0,%t0\";\n+\t  output_asm_insn (insn_buf, operands);\n+\t  break;\n+\n+\tcase SImode:\n+\t  /* This code works on the H8/300H and H8/S.  */\n+\t  insn_buf = \"xor.w\\t%e0,%f0\\n\\txor.w\\t%f0,%e0\\n\\txor.w\\t%e0,%f0\";\n+\t  output_asm_insn (insn_buf, operands);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      /* Adjust AMOUNT and flip the direction.  */\n+      amount = GET_MODE_BITSIZE (mode) / 2 - amount;\n+      rotate_type =\n+\t(rotate_type == SHIFT_ASHIFT) ? SHIFT_LSHIFTRT : SHIFT_ASHIFT;\n+    }\n+\n+  /* Emit rotate insns.  */\n+  for (bits = TARGET_H8300S ? 2 : 1; bits > 0; bits /= 2)\n+    {\n+      if (bits == 2)\n+\tinsn_buf = rotate_two[rotate_type][rotate_mode];\n+      else\n+\tinsn_buf = rotate_one[cpu_type][rotate_type][rotate_mode];\n+      \n+      for (; amount >= bits; amount -= bits)\n+\toutput_asm_insn (insn_buf, operands);\n+    }\n+\n+  return \"\";\n+}\n+\f\n /* Fix the operands of a gen_xxx so that it could become a bit\n   operating insn.  */\n \n@@ -3052,5 +3223,56 @@ h8300_adjust_insn_length (insn, length)\n       /* XXX ??? Could check for more shift/rotate cases here.  */\n     }\n \n+  /* Rotations need various adjustments.  */\n+  if (GET_CODE (pat) == SET\n+      && (GET_CODE (SET_SRC (pat)) == ROTATE\n+\t  || GET_CODE (SET_SRC (pat)) == ROTATERT))\n+    {\n+      rtx src = SET_SRC (pat);\n+      enum machine_mode mode = GET_MODE (src);\n+      int amount;\n+      int states = 0;\n+\n+      if (GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\treturn 0;\n+\n+      amount = INTVAL (XEXP (src, 1));\n+\n+      /* Clean up AMOUNT.  */\n+      if (amount < 0)\n+\tamount = 0;\n+      if ((unsigned int) amount > GET_MODE_BITSIZE (mode))\n+\tamount = GET_MODE_BITSIZE (mode);\n+\n+      /* Determine the faster direction.  After this phase, amount\n+\t will be at most a half of GET_MODE_BITSIZE (mode).  */\n+      if ((unsigned int) amount > GET_MODE_BITSIZE (mode) / 2)\n+\t/* Flip the direction.  */\n+\tamount = GET_MODE_BITSIZE (mode) - amount;\n+\n+      /* See if a byte swap (in HImode) or a word swap (in SImode) can\n+\t boost up the rotation.  */\n+      if ((mode == HImode && TARGET_H8300 && amount >= 5)\n+\t  || (mode == HImode && TARGET_H8300H && amount >= 6)\n+\t  || (mode == HImode && TARGET_H8300S && amount == 8)\n+\t  || (mode == SImode && TARGET_H8300H && amount >= 10)\n+\t  || (mode == SImode && TARGET_H8300S && amount >= 13))\n+\t{\n+\t  /* Adjust AMOUNT and flip the direction.  */\n+\t  amount = GET_MODE_BITSIZE (mode) / 2 - amount;\n+\t  states += 6;\n+\t}\n+\n+      /* We use 2-bit rotatations on the H8/S.  */\n+      if (TARGET_H8300S)\n+\tamount = amount / 2 + amount % 2;\n+\n+      /* The H8/300 uses three insns to rotate one bit, taking 6\n+         states.  */\n+      states += amount * ((TARGET_H8300 && mode == HImode) ? 6 : 2);\n+\n+      return -(20 - states);\n+    }\n+\n   return 0;\n }"}, {"sha": "8b9c95e21c8af4e8938590f2bb1e84068d52c444", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd71f0f6cd9a303874d4a3e604a5f5fe760a975/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=edd71f0f6cd9a303874d4a3e604a5f5fe760a975", "patch": "@@ -1882,6 +1882,58 @@\n   [(set_attr \"length\" \"20\")\n    (set_attr \"cc\" \"clobber\")])\n \f\n+;; ----------------------------------------------------------------------\n+;; ROTATIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"rotlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(rotate:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"if (expand_a_rotate (ROTATE, operands)) DONE;else FAIL;\")\n+\n+(define_insn \"*rotlqi3_1\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(rotate:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"* return emit_a_rotate (ROTATE, operands);\"\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"if (expand_a_rotate (ROTATE, operands)) DONE;else FAIL;\")\n+\n+(define_insn \"*rotlhi3_1\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"* return emit_a_rotate (ROTATE, operands);\"\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"if (expand_a_rotate (ROTATE, operands)) DONE;else FAIL;\")\n+\n+(define_insn \"*rotlsi3_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  \"* return emit_a_rotate (ROTATE, operands);\"\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"cc\" \"clobber\")])\n+\f\n ;; -----------------------------------------------------------------\n ;; BIT FIELDS\n ;; -----------------------------------------------------------------"}]}