{"sha": "95b3eff34ea98fcd67460f208004f5baddc29f0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTViM2VmZjM0ZWE5OGZjZDY3NDYwZjIwODAwNGY1YmFkZGMyOWYwYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-12-06T09:23:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-12-06T09:23:07Z"}, "message": "re PR tree-optimization/59058 (wrong code at -O3 on x86_64-linux-gnu (affecting gcc 4.6 to trunk))\n\n2013-12-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/59058\n\t* tree-vectorizer.h (struct _loop_vec_info): Add num_itersm1\n\tmember.\n\t(LOOP_VINFO_NITERSM1): New macro.\n\t* tree-vect-loop-manip.c (slpeel_tree_peel_loop_to_edge): Express\n\tthe vector loop entry test in terms of scalar latch executions.\n\t(vect_do_peeling_for_alignment): Update LOOP_VINFO_NITERSM1.\n\t* tree-vect-loop.c (vect_get_loop_niters): Also return the\n\tnumber of latch executions.\n\t(new_loop_vec_info): Initialize LOOP_VINFO_NITERSM1.\n\t(vect_analyze_loop_form): Likewise.\n\t(vect_generate_tmps_on_preheader): Compute the number of\n\tvectorized iterations differently.\n\n\t* gcc.dg/torture/pr59058.c: New testcase.\n\nFrom-SVN: r205730", "tree": {"sha": "d490ce409763d3445fb2ba74ac78008e8d55f526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d490ce409763d3445fb2ba74ac78008e8d55f526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95b3eff34ea98fcd67460f208004f5baddc29f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b3eff34ea98fcd67460f208004f5baddc29f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95b3eff34ea98fcd67460f208004f5baddc29f0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b3eff34ea98fcd67460f208004f5baddc29f0b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3fc92e702e2a3a109cacb81416557d550e26ce44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fc92e702e2a3a109cacb81416557d550e26ce44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fc92e702e2a3a109cacb81416557d550e26ce44"}], "stats": {"total": 119, "additions": 89, "deletions": 30}, "files": [{"sha": "b763531126be0c20bb5cb569eb80e43eb73371aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95b3eff34ea98fcd67460f208004f5baddc29f0b", "patch": "@@ -1,3 +1,19 @@\n+2013-12-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59058\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add num_itersm1\n+\tmember.\n+\t(LOOP_VINFO_NITERSM1): New macro.\n+\t* tree-vect-loop-manip.c (slpeel_tree_peel_loop_to_edge): Express\n+\tthe vector loop entry test in terms of scalar latch executions.\n+\t(vect_do_peeling_for_alignment): Update LOOP_VINFO_NITERSM1.\n+\t* tree-vect-loop.c (vect_get_loop_niters): Also return the\n+\tnumber of latch executions.\n+\t(new_loop_vec_info): Initialize LOOP_VINFO_NITERSM1.\n+\t(vect_analyze_loop_form): Likewise.\n+\t(vect_generate_tmps_on_preheader): Compute the number of\n+\tvectorized iterations differently.\n+\n 2013-12-05  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n \n \t* config/score/score.c (score_force_temporary): Delete function."}, {"sha": "b3be3e0436d29627810833eff508c3db35786be6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=95b3eff34ea98fcd67460f208004f5baddc29f0b", "patch": "@@ -1,3 +1,8 @@\n+2013-12-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59058\n+\t* gcc.dg/torture/pr59058.c: New testcase.\n+\n 2013-12-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/warn/pr15774-1.C: Adjust expected message."}, {"sha": "b3a5a3960c3bf367df2abff3377f983d8f326737", "filename": "gcc/testsuite/gcc.dg/torture/pr59058.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59058.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59058.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr59058.c?ref=95b3eff34ea98fcd67460f208004f5baddc29f0b", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+short b = 0;\n+\n+int\n+main ()\n+{\n+  int c = 0;\n+l1:\n+  b++;\n+  c |= b;\n+  if (b)\n+    goto l1;\n+  if (c != -1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "380fd2258b494d5a464d381bcabb2a51ee14c458", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=95b3eff34ea98fcd67460f208004f5baddc29f0b", "patch": "@@ -1061,7 +1061,6 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   gimple_stmt_iterator gsi;\n   edge exit_e = single_exit (loop);\n   source_location loop_loc;\n-  tree cost_pre_condition = NULL_TREE;\n   /* There are many aspects to how likely the first loop is going to be executed.\n      Without histogram we can't really do good job.  Simply set it to\n      2/3, so the first loop is not reordered to the end of function and\n@@ -1263,21 +1262,17 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   /* Epilogue peeling.  */\n   if (!update_first_loop_count)\n     {\n+      loop_vec_info loop_vinfo = loop_vec_info_for_loop (loop);\n+      tree scalar_loop_iters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n+      unsigned limit = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1;\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+\tlimit = limit + 1;\n+      if (check_profitability\n+\t  && th > limit)\n+\tlimit = th;\n       pre_condition =\n-\tfold_build2 (LE_EXPR, boolean_type_node, *first_niters,\n-\t\t     build_int_cst (TREE_TYPE (*first_niters), 0));\n-      if (check_profitability)\n-\t{\n-\t  tree scalar_loop_iters\n-\t    = unshare_expr (LOOP_VINFO_NITERS_UNCHANGED\n-\t\t\t\t\t(loop_vec_info_for_loop (loop)));\n-\t  cost_pre_condition =\n-\t    fold_build2 (LE_EXPR, boolean_type_node, scalar_loop_iters,\n-\t\t         build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n-\n-\t  pre_condition = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t       cost_pre_condition, pre_condition);\n-\t}\n+\tfold_build2 (LT_EXPR, boolean_type_node, scalar_loop_iters,\n+\t\t     build_int_cst (TREE_TYPE (scalar_loop_iters), limit));\n       if (cond_expr)\n \t{\n \t  pre_condition =\n@@ -1922,6 +1917,9 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n   /* Update number of times loop executes.  */\n   LOOP_VINFO_NITERS (loop_vinfo) = fold_build2 (MINUS_EXPR,\n \t\tTREE_TYPE (ni_name), ni_name, niters_of_prolog_loop);\n+  LOOP_VINFO_NITERSM1 (loop_vinfo) = fold_build2 (MINUS_EXPR,\n+\t\tTREE_TYPE (ni_name),\n+\t\tLOOP_VINFO_NITERSM1 (loop_vinfo), niters_of_prolog_loop);\n \n   if (types_compatible_p (sizetype, TREE_TYPE (niters_of_prolog_loop)))\n     wide_prolog_niters = niters_of_prolog_loop;"}, {"sha": "ca8d3a6cde089574cf431201dac9bea6fa60e226", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=95b3eff34ea98fcd67460f208004f5baddc29f0b", "patch": "@@ -791,12 +791,14 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n /* Function vect_get_loop_niters.\n \n    Determine how many iterations the loop is executed and place it\n-   in NUMBER_OF_ITERATIONS.\n+   in NUMBER_OF_ITERATIONS.  Place the number of latch iterations\n+   in NUMBER_OF_ITERATIONSM1.\n \n    Return the loop exit condition.  */\n \n static gimple\n-vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n+vect_get_loop_niters (struct loop *loop, tree *number_of_iterations,\n+\t\t      tree *number_of_iterationsm1)\n {\n   tree niters;\n \n@@ -805,12 +807,14 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n \t\t     \"=== get_loop_niters ===\\n\");\n \n   niters = number_of_latch_executions (loop);\n+  *number_of_iterationsm1 = niters;\n+\n   /* We want the number of loop header executions which is the number\n      of latch executions plus one.\n      ???  For UINT_MAX latch executions this number overflows to zero\n      for loops like do { n++; } while (n != 0);  */\n   if (niters && !chrec_contains_undetermined (niters))\n-    niters = fold_build2 (PLUS_EXPR, TREE_TYPE (niters), niters,\n+    niters = fold_build2 (PLUS_EXPR, TREE_TYPE (niters), unshare_expr (niters),\n \t\t\t  build_int_cst (TREE_TYPE (niters), 1));\n   *number_of_iterations = niters;\n \n@@ -916,6 +920,7 @@ new_loop_vec_info (struct loop *loop)\n    gcc_assert (nbbs == loop->num_nodes);\n \n   LOOP_VINFO_BBS (res) = bbs;\n+  LOOP_VINFO_NITERSM1 (res) = NULL;\n   LOOP_VINFO_NITERS (res) = NULL;\n   LOOP_VINFO_NITERS_UNCHANGED (res) = NULL;\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (res) = 0;\n@@ -1071,7 +1076,7 @@ vect_analyze_loop_form (struct loop *loop)\n {\n   loop_vec_info loop_vinfo;\n   gimple loop_cond;\n-  tree number_of_iterations = NULL;\n+  tree number_of_iterations = NULL, number_of_iterationsm1 = NULL;\n   loop_vec_info inner_loop_vinfo = NULL;\n \n   if (dump_enabled_p ())\n@@ -1246,7 +1251,8 @@ vect_analyze_loop_form (struct loop *loop)\n \t}\n     }\n \n-  loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n+  loop_cond = vect_get_loop_niters (loop, &number_of_iterations,\n+\t\t\t\t    &number_of_iterationsm1);\n   if (!loop_cond)\n     {\n       if (dump_enabled_p ())\n@@ -1280,6 +1286,7 @@ vect_analyze_loop_form (struct loop *loop)\n     }\n \n   loop_vinfo = new_loop_vec_info (loop);\n+  LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n \n@@ -5637,12 +5644,11 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n   tree var;\n   tree ratio_name;\n   tree ratio_mult_vf_name;\n-  tree ni = LOOP_VINFO_NITERS (loop_vinfo);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n   tree log_vf;\n \n-  log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n+  log_vf = build_int_cst (TREE_TYPE (ni_name), exact_log2 (vf));\n \n   /* If epilogue loop is required because of data accesses with gaps, we\n      subtract one iteration from the total number of iterations here for\n@@ -5654,7 +5660,7 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n \t\t\t               build_one_cst (TREE_TYPE (ni_name)));\n       if (!is_gimple_val (ni_minus_gap_name))\n \t{\n-\t  var = create_tmp_var (TREE_TYPE (ni), \"ni_gap\");\n+\t  var = create_tmp_var (TREE_TYPE (ni_name), \"ni_gap\");\n           gimple stmts = NULL;\n           ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,\n \t\t\t\t\t\t    true, var);\n@@ -5665,12 +5671,22 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n     ni_minus_gap_name = ni_name;\n \n   /* Create: ratio = ni >> log2(vf) */\n-\n-  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_minus_gap_name),\n-\t\t\t    ni_minus_gap_name, log_vf);\n+  /* ???  As we have ni == number of latch executions + 1, ni could\n+     have overflown to zero.  So avoid computing ratio based on ni\n+     but compute it using the fact that we know ratio will be at least\n+     one, thus via (ni - vf) >> log2(vf) + 1.  */\n+  ratio_name\n+    = fold_build2 (PLUS_EXPR, TREE_TYPE (ni_name),\n+\t\t   fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_name),\n+\t\t\t\tfold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),\n+\t\t\t\t\t     ni_minus_gap_name,\n+\t\t\t\t\t     build_int_cst\n+\t\t\t\t\t       (TREE_TYPE (ni_name), vf)),\n+\t\t\t\tlog_vf),\n+\t\t   build_int_cst (TREE_TYPE (ni_name), 1));\n   if (!is_gimple_val (ratio_name))\n     {\n-      var = create_tmp_var (TREE_TYPE (ni), \"bnd\");\n+      var = create_tmp_var (TREE_TYPE (ni_name), \"bnd\");\n       gimple stmts = NULL;\n       ratio_name = force_gimple_operand (ratio_name, &stmts, true, var);\n       gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -5685,7 +5701,7 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n \t\t\t\t\tratio_name, log_vf);\n       if (!is_gimple_val (ratio_mult_vf_name))\n \t{\n-\t  var = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n+\t  var = create_tmp_var (TREE_TYPE (ni_name), \"ratio_mult_vf\");\n \t  gimple stmts = NULL;\n \t  ratio_mult_vf_name = force_gimple_operand (ratio_mult_vf_name, &stmts,\n \t\t\t\t\t\t     true, var);"}, {"sha": "b4daf0aba179c74d31c8c6df437c6bb9ea22a160", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95b3eff34ea98fcd67460f208004f5baddc29f0b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=95b3eff34ea98fcd67460f208004f5baddc29f0b", "patch": "@@ -250,8 +250,11 @@ typedef struct _loop_vec_info {\n   /* The loop basic blocks.  */\n   basic_block *bbs;\n \n+  /* Number of latch executions.  */\n+  tree num_itersm1;\n   /* Number of iterations.  */\n   tree num_iters;\n+  /* Number of iterations of the original loop.  */\n   tree num_iters_unchanged;\n \n   /* Minimum number of iterations below which vectorization is expected to\n@@ -349,9 +352,11 @@ typedef struct _loop_vec_info {\n /* Access Functions.  */\n #define LOOP_VINFO_LOOP(L)                 (L)->loop\n #define LOOP_VINFO_BBS(L)                  (L)->bbs\n+#define LOOP_VINFO_NITERSM1(L)             (L)->num_itersm1\n #define LOOP_VINFO_NITERS(L)               (L)->num_iters\n-/* Since LOOP_VINFO_NITERS can change after prologue peeling\n-   retain total unchanged scalar loop iterations for cost model.  */\n+/* Since LOOP_VINFO_NITERS and LOOP_VINFO_NITERSM1 can change after\n+   prologue peeling retain total unchanged scalar loop iterations for\n+   cost model.  */\n #define LOOP_VINFO_NITERS_UNCHANGED(L)     (L)->num_iters_unchanged\n #define LOOP_VINFO_COST_MODEL_MIN_ITERS(L) (L)->min_profitable_iters\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable"}]}