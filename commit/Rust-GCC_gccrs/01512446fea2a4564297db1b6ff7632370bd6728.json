{"sha": "01512446fea2a4564297db1b6ff7632370bd6728", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE1MTI0NDZmZWEyYTQ1NjQyOTdkYjFiNmZmNzYzMjM3MGJkNjcyOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-12-19T17:11:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-12-19T17:11:57Z"}, "message": "read-rtl.c (parse_reg_note_name): Replace Yoda conditions with typical order conditions.\n\n\t* read-rtl.c (parse_reg_note_name): Replace Yoda conditions with\n\ttypical order conditions.\n\t* sel-sched.c (extract_new_fences_from): Likewise.\n\t* config/visium/constraints.md (J, K, L): Likewise.\n\t* config/visium/predicates.md (const_shift_operand): Likewise.\n\t* config/visium/visium.c (visium_legitimize_address,\n\tvisium_legitimize_reload_address): Likewise.\n\t* config/m68k/m68k.c (output_reg_adjust, emit_reg_adjust): Likewise.\n\t* config/arm/arm.c (arm_block_move_unaligned_straight): Likewise.\n\t* config/avr/constraints.md (Y01, Ym1, Y02, Ym2): Likewise.\n\t* config/avr/avr-log.c (avr_vdump, avr_log_set_avr_log,\n\tSET_DUMP_DETAIL): Likewise.\n\t* config/avr/predicates.md (const_8_16_24_operand): Likewise.\n\t* config/avr/avr.c (STR_PREFIX_P, avr_popcount_each_byte,\n\tavr_is_casesi_sequence, avr_casei_sequence_check_operands,\n\tavr_set_core_architecture, avr_set_current_function,\n\tavr_legitimize_reload_address, avr_asm_len, avr_print_operand,\n\toutput_movqi, output_movsisf, avr_out_plus, avr_out_bitop,\n\tavr_out_fract, avr_adjust_insn_length, avr_encode_section_info,\n\tavr_2word_insn_p, output_reload_in_const, avr_has_nibble_0xf,\n\tavr_map_decompose, avr_fold_builtin): Likewise.\n\t* config/avr/driver-avr.c (avr_devicespecs_file): Likewise.\n\t* config/avr/gen-avr-mmcu-specs.c (str_prefix_p, print_mcu): Likewise.\n\t* config/i386/i386.c (ix86_parse_stringop_strategy_string): Likewise.\n\t* config/m32c/m32c-pragma.c (m32c_pragma_memregs): Likewise.\n\t* config/m32c/m32c.c (m32c_conditional_register_usage,\n\tm32c_address_cost): Likewise.\n\t* config/m32c/predicates.md (shiftcount_operand,\n\tlongshiftcount_operand): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_expand_prologue): Likewise.\n\t* config/nios2/nios2.c (nios2_handle_custom_fpu_insn_option,\n\tcan_use_cdx_ldstw): Likewise.\n\t* config/nios2/nios2.h (CDX_REG_P): Likewise.\n\t* config/cr16/cr16.h (RETURN_ADDR_RTX, REGNO_MODE_OK_FOR_BASE_P):\n\tLikewise.\n\t* config/cr16/cr16.md (*mov<mode>_double): Likewise.\n\t* config/cr16/cr16.c (cr16_create_dwarf_for_multi_push): Likewise.\n\t* config/h8300/h8300.c (h8300_rtx_costs, get_shift_alg): Likewise.\n\t* config/vax/constraints.md (U06, U08, U16, CN6, S08, S16): Likewise.\n\t* config/vax/vax.c (adjacent_operands_p): Likewise.\n\t* config/ft32/constraints.md (L, b, KA): Likewise.\n\t* config/ft32/ft32.c (ft32_load_immediate, ft32_expand_prologue):\n\tLikewise.\n\t* cfgexpand.c (expand_stack_alignment): Likewise.\n\t* gcse.c (insert_expr_in_table): Likewise.\n\t* print-rtl.c (rtx_writer::print_rtx_operand_codes_E_and_V): Likewise.\n\t* cgraphunit.c (cgraph_node::expand): Likewise.\n\t* ira-build.c (setup_min_max_allocno_live_range_point): Likewise.\n\t* emit-rtl.c (add_insn): Likewise.\n\t* input.c (dump_location_info): Likewise.\n\t* passes.c (NEXT_PASS): Likewise.\n\t* read-rtl-function.c (parse_note_insn_name,\n\tfunction_reader::read_rtx_operand_r, function_reader::parse_mem_expr):\n\tLikewise.\n\t* sched-rgn.c (sched_rgn_init): Likewise.\n\t* diagnostic-show-locus.c (layout::show_ruler): Likewise.\n\t* combine.c (find_split_point, simplify_if_then_else, force_to_mode,\n\tif_then_else_cond, simplify_shift_const_1, simplify_comparison): Likewise.\n\t* explow.c (eliminate_constant_term): Likewise.\n\t* final.c (leaf_renumber_regs_insn): Likewise.\n\t* cfgrtl.c (print_rtl_with_bb): Likewise.\n\t* genhooks.c (emit_init_macros): Likewise.\n\t* poly-int.h (maybe_ne, maybe_le, maybe_lt): Likewise.\n\t* tree-data-ref.c (conflict_fn): Likewise.\n\t* selftest.c (assert_streq): Likewise.\n\t* expr.c (store_constructor_field, expand_expr_real_1): Likewise.\n\t* fold-const.c (fold_range_test, extract_muldiv_1, fold_truth_andor,\n\tfold_binary_loc, multiple_of_p): Likewise.\n\t* reload.c (push_reload, find_equiv_reg): Likewise.\n\t* et-forest.c (et_nca, et_below): Likewise.\n\t* dbxout.c (dbxout_symbol_location): Likewise.\n\t* reorg.c (relax_delay_slots): Likewise.\n\t* dojump.c (do_compare_rtx_and_jump): Likewise.\n\t* gengtype-parse.c (type): Likewise.\n\t* simplify-rtx.c (simplify_gen_ternary, simplify_gen_relational,\n\tsimplify_const_relational_operation): Likewise.\n\t* reload1.c (do_output_reload): Likewise.\n\t* dumpfile.c (get_dump_file_info_by_switch): Likewise.\n\t* gengtype.c (type_for_name): Likewise.\n\t* gimple-ssa-sprintf.c (format_directive): Likewise.\nada/\n\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Replace Yoda\n\tconditions with typical order conditions.\n\t* gcc-interface/misc.c (gnat_get_array_descr_info,\n\tdefault_pass_by_ref): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Likewise.\n\t* adaint.c (__gnat_tmp_name): Likewise.\nc-family/\n\t* known-headers.cc (get_stdlib_header_for_name): Replace Yoda\n\tconditions with typical order conditions.\nc/\n\t* c-typeck.c (comptypes_internal, function_types_compatible_p,\n\tperform_integral_promotions, digest_init): Replace Yoda conditions\n\twith typical order conditions.\n\t* c-decl.c (check_bitfield_type_and_width): Likewise.\ncp/\n\t* name-lookup.c (get_std_name_hint): Replace Yoda conditions with\n\ttypical order conditions.\n\t* class.c (check_bitfield_decl): Likewise.\n\t* pt.c (convert_template_argument): Likewise.\n\t* decl.c (duplicate_decls): Likewise.\n\t* typeck.c (commonparms): Likewise.\nfortran/\n\t* scanner.c (preprocessor_line): Replace Yoda conditions with typical\n\torder conditions.\n\t* dependency.c (check_section_vs_section): Likewise.\n\t* trans-array.c (gfc_conv_expr_descriptor): Likewise.\njit/\n\t* jit-playback.c (get_type, playback::compile_to_file::copy_file,\n\tplayback::context::acquire_mutex): Replace Yoda conditions with\n\ttypical order conditions.\n\t* libgccjit.c (gcc_jit_context_new_struct_type,\n\tgcc_jit_struct_set_fields, gcc_jit_context_new_union_type,\n\tgcc_jit_context_new_function, gcc_jit_timer_pop): Likewise.\n\t* jit-builtins.c (matches_builtin): Likewise.\n\t* jit-recording.c (recording::compound_type::set_fields,\n\trecording::fields::write_reproducer, recording::rvalue::set_scope,\n\trecording::function::validate): Likewise.\n\t* jit-logging.c (logger::decref): Likewise.\n\nFrom-SVN: r255831", "tree": {"sha": "96a404bd26176e24281ab6e7f8e47df5a4bb34d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96a404bd26176e24281ab6e7f8e47df5a4bb34d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01512446fea2a4564297db1b6ff7632370bd6728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01512446fea2a4564297db1b6ff7632370bd6728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01512446fea2a4564297db1b6ff7632370bd6728", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01512446fea2a4564297db1b6ff7632370bd6728/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a3a8086bed05ffc8d24bb6908e4437bd9e982f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3a8086bed05ffc8d24bb6908e4437bd9e982f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3a8086bed05ffc8d24bb6908e4437bd9e982f7"}], "stats": {"total": 828, "additions": 469, "deletions": 359}, "files": [{"sha": "c5146d7518b6e6b770ccf81a78fb58d5d119020c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,86 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* read-rtl.c (parse_reg_note_name): Replace Yoda conditions with\n+\ttypical order conditions.\n+\t* sel-sched.c (extract_new_fences_from): Likewise.\n+\t* config/visium/constraints.md (J, K, L): Likewise.\n+\t* config/visium/predicates.md (const_shift_operand): Likewise.\n+\t* config/visium/visium.c (visium_legitimize_address,\n+\tvisium_legitimize_reload_address): Likewise.\n+\t* config/m68k/m68k.c (output_reg_adjust, emit_reg_adjust): Likewise.\n+\t* config/arm/arm.c (arm_block_move_unaligned_straight): Likewise.\n+\t* config/avr/constraints.md (Y01, Ym1, Y02, Ym2): Likewise.\n+\t* config/avr/avr-log.c (avr_vdump, avr_log_set_avr_log,\n+\tSET_DUMP_DETAIL): Likewise.\n+\t* config/avr/predicates.md (const_8_16_24_operand): Likewise.\n+\t* config/avr/avr.c (STR_PREFIX_P, avr_popcount_each_byte,\n+\tavr_is_casesi_sequence, avr_casei_sequence_check_operands,\n+\tavr_set_core_architecture, avr_set_current_function,\n+\tavr_legitimize_reload_address, avr_asm_len, avr_print_operand,\n+\toutput_movqi, output_movsisf, avr_out_plus, avr_out_bitop,\n+\tavr_out_fract, avr_adjust_insn_length, avr_encode_section_info,\n+\tavr_2word_insn_p, output_reload_in_const, avr_has_nibble_0xf,\n+\tavr_map_decompose, avr_fold_builtin): Likewise.\n+\t* config/avr/driver-avr.c (avr_devicespecs_file): Likewise.\n+\t* config/avr/gen-avr-mmcu-specs.c (str_prefix_p, print_mcu): Likewise.\n+\t* config/i386/i386.c (ix86_parse_stringop_strategy_string): Likewise.\n+\t* config/m32c/m32c-pragma.c (m32c_pragma_memregs): Likewise.\n+\t* config/m32c/m32c.c (m32c_conditional_register_usage,\n+\tm32c_address_cost): Likewise.\n+\t* config/m32c/predicates.md (shiftcount_operand,\n+\tlongshiftcount_operand): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_expand_prologue): Likewise.\n+\t* config/nios2/nios2.c (nios2_handle_custom_fpu_insn_option,\n+\tcan_use_cdx_ldstw): Likewise.\n+\t* config/nios2/nios2.h (CDX_REG_P): Likewise.\n+\t* config/cr16/cr16.h (RETURN_ADDR_RTX, REGNO_MODE_OK_FOR_BASE_P):\n+\tLikewise.\n+\t* config/cr16/cr16.md (*mov<mode>_double): Likewise.\n+\t* config/cr16/cr16.c (cr16_create_dwarf_for_multi_push): Likewise.\n+\t* config/h8300/h8300.c (h8300_rtx_costs, get_shift_alg): Likewise.\n+\t* config/vax/constraints.md (U06, U08, U16, CN6, S08, S16): Likewise.\n+\t* config/vax/vax.c (adjacent_operands_p): Likewise.\n+\t* config/ft32/constraints.md (L, b, KA): Likewise.\n+\t* config/ft32/ft32.c (ft32_load_immediate, ft32_expand_prologue):\n+\tLikewise.\n+\t* cfgexpand.c (expand_stack_alignment): Likewise.\n+\t* gcse.c (insert_expr_in_table): Likewise.\n+\t* print-rtl.c (rtx_writer::print_rtx_operand_codes_E_and_V): Likewise.\n+\t* cgraphunit.c (cgraph_node::expand): Likewise.\n+\t* ira-build.c (setup_min_max_allocno_live_range_point): Likewise.\n+\t* emit-rtl.c (add_insn): Likewise.\n+\t* input.c (dump_location_info): Likewise.\n+\t* passes.c (NEXT_PASS): Likewise.\n+\t* read-rtl-function.c (parse_note_insn_name,\n+\tfunction_reader::read_rtx_operand_r, function_reader::parse_mem_expr):\n+\tLikewise.\n+\t* sched-rgn.c (sched_rgn_init): Likewise.\n+\t* diagnostic-show-locus.c (layout::show_ruler): Likewise.\n+\t* combine.c (find_split_point, simplify_if_then_else, force_to_mode,\n+\tif_then_else_cond, simplify_shift_const_1, simplify_comparison): Likewise.\n+\t* explow.c (eliminate_constant_term): Likewise.\n+\t* final.c (leaf_renumber_regs_insn): Likewise.\n+\t* cfgrtl.c (print_rtl_with_bb): Likewise.\n+\t* genhooks.c (emit_init_macros): Likewise.\n+\t* poly-int.h (maybe_ne, maybe_le, maybe_lt): Likewise.\n+\t* tree-data-ref.c (conflict_fn): Likewise.\n+\t* selftest.c (assert_streq): Likewise.\n+\t* expr.c (store_constructor_field, expand_expr_real_1): Likewise.\n+\t* fold-const.c (fold_range_test, extract_muldiv_1, fold_truth_andor,\n+\tfold_binary_loc, multiple_of_p): Likewise.\n+\t* reload.c (push_reload, find_equiv_reg): Likewise.\n+\t* et-forest.c (et_nca, et_below): Likewise.\n+\t* dbxout.c (dbxout_symbol_location): Likewise.\n+\t* reorg.c (relax_delay_slots): Likewise.\n+\t* dojump.c (do_compare_rtx_and_jump): Likewise.\n+\t* gengtype-parse.c (type): Likewise.\n+\t* simplify-rtx.c (simplify_gen_ternary, simplify_gen_relational,\n+\tsimplify_const_relational_operation): Likewise.\n+\t* reload1.c (do_output_reload): Likewise.\n+\t* dumpfile.c (get_dump_file_info_by_switch): Likewise.\n+\t* gengtype.c (type_for_name): Likewise.\n+\t* gimple-ssa-sprintf.c (format_directive): Likewise.\n+\n 2017-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/82975"}, {"sha": "e9f217346ad669a9de0ac63e8c8a4cf25375a0e3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,12 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Replace Yoda\n+\tconditions with typical order conditions.\n+\t* gcc-interface/misc.c (gnat_get_array_descr_info,\n+\tdefault_pass_by_ref): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Likewise.\n+\t* adaint.c (__gnat_tmp_name): Likewise.\n+\n 2017-12-19  Arnaud Charlet  <charlet@adacore.com>\n \n \tPR ada/66205"}, {"sha": "19fe957c40815e375852767bd917e1c45661e1a9", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1221,7 +1221,7 @@ __gnat_tmp_name (char *tmp_filename)\n \n       /* Fill up the name buffer from the last position.  */\n       seed++;\n-      for (t = seed; 0 <= --index; t >>= 3)\n+      for (t = seed; --index >= 0; t >>= 3)\n         *--pos = '0' + (t & 07);\n \n       /* Check to see if its unique, if not bump the seed and try again.  */"}, {"sha": "84fd588d2387e345f03932d227cfc79de2201f44", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2111,7 +2111,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   index to the template.  */\n \tfor (index = (convention_fortran_p ? ndim - 1 : 0),\n \t     gnat_index = First_Index (gnat_entity);\n-\t     0 <= index && index < ndim;\n+\t     index >= 0 && index < ndim;\n \t     index += (convention_fortran_p ? - 1 : 1),\n \t     gnat_index = Next_Index (gnat_index))\n \t  {\n@@ -2362,7 +2362,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t       gnat_index = First_Index (gnat_entity),\n \t       gnat_base_index\n \t\t = First_Index (Implementation_Base_Type (gnat_entity));\n-\t       0 <= index && index < ndim;\n+\t       index >= 0 && index < ndim;\n \t       index += (convention_fortran_p ? - 1 : 1),\n \t       gnat_index = Next_Index (gnat_index),\n \t       gnat_base_index = Next_Index (gnat_base_index))"}, {"sha": "3eda489a36d7b7d31603a75712f44745e3c0cce5", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -953,7 +953,7 @@ gnat_get_array_descr_info (const_tree const_type,\n      structure.  */\n   for (i = (convention_fortran_p ? info->ndimensions - 1 : 0),\n        dimen = first_dimen;\n-       0 <= i && i < info->ndimensions;\n+       i >= 0 && i < info->ndimensions;\n        i += (convention_fortran_p ? -1 : 1),\n        dimen = TREE_TYPE (dimen))\n     {\n@@ -1146,8 +1146,8 @@ default_pass_by_ref (tree gnu_type)\n \n   if (AGGREGATE_TYPE_P (gnu_type)\n       && (!valid_constant_size_p (TYPE_SIZE_UNIT (gnu_type))\n-\t  || 0 < compare_tree_int (TYPE_SIZE_UNIT (gnu_type),\n-\t\t\t\t   TYPE_ALIGN (gnu_type))))\n+\t  || compare_tree_int (TYPE_SIZE_UNIT (gnu_type),\n+\t\t\t       TYPE_ALIGN (gnu_type)) > 0))\n     return true;\n \n   if (pass_by_reference (NULL, TYPE_MODE (gnu_type), gnu_type, true))"}, {"sha": "7e7bac9aa4a3e5957e42e7b239a7474ecbc478fd", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3190,7 +3190,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n \t  /* Note that loop unswitching can only be applied a small number of\n \t     times to a given loop (PARAM_MAX_UNSWITCH_LEVEL default to 3).  */\n-\t  if (0 < n_remaining_checks && n_remaining_checks <= 3\n+\t  if (n_remaining_checks > 0 && n_remaining_checks <= 3\n \t      && optimize > 1 && !optimize_size)\n \t    FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)\n \t      if (rci->invariant_cond != boolean_false_node)"}, {"sha": "996e7b8eaf5dc2ddf33e81c5dff7556091c74525", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,8 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* known-headers.cc (get_stdlib_header_for_name): Replace Yoda\n+\tconditions with typical order conditions.\n+\n 2017-12-18  Marek Polacek  <polacek@redhat.com>\n \n \t* c-warn.c (warn_logical_operator): Return early if -Wlogical-op is"}, {"sha": "0dc9a92f1a21439f44ac80d1752b2462d34f3e35", "filename": "gcc/c-family/known-headers.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc-family%2Fknown-headers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc-family%2Fknown-headers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fknown-headers.cc?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -117,7 +117,7 @@ get_stdlib_header_for_name (const char *name, enum stdlib lib)\n   };\n   const size_t num_hints = sizeof (hints) / sizeof (hints[0]);\n   for (size_t i = 0; i < num_hints; i++)\n-    if (0 == strcmp (name, hints[i].name))\n+    if (strcmp (name, hints[i].name) == 0)\n       return hints[i].header[lib];\n   return NULL;\n }"}, {"sha": "bfa62268166df891d32fe9f1e11b0fe382f5ecfe", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,10 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-typeck.c (comptypes_internal, function_types_compatible_p,\n+\tperform_integral_promotions, digest_init): Replace Yoda conditions\n+\twith typical order conditions.\n+\t* c-decl.c (check_bitfield_type_and_width): Likewise.\n+\n 2017-12-14  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* c-typeck.c (c_safe_arg_type_equiv_p,"}, {"sha": "e37ae17b9e1abae578416e99e3f73e5629d7b5f6", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -5473,7 +5473,7 @@ check_bitfield_type_and_width (location_t loc, tree *type, tree *width,\n \n   max_width = TYPE_PRECISION (*type);\n \n-  if (0 < compare_tree_int (*width, max_width))\n+  if (compare_tree_int (*width, max_width) > 0)\n     {\n       error_at (loc, \"width of %qs exceeds its type\", name);\n       w = max_width;"}, {"sha": "5ae12d9c8a987690f748742a025ea9396fd6dd3b", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1177,9 +1177,9 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n \n \t/* Target types must match incl. qualifiers.  */\n \tif (TREE_TYPE (t1) != TREE_TYPE (t2)\n-\t    && 0 == (val = comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t       enum_and_int_p,\n-\t\t\t\t\t       different_types_p)))\n+\t    && (val = comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t  enum_and_int_p,\n+\t\t\t\t\t  different_types_p)) == 0)\n \t  return 0;\n \n \tif (different_types_p != NULL\n@@ -1662,8 +1662,8 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n \t compare that with the other type's arglist.\n \t If they don't match, ask for a warning (but no error).  */\n       if (TYPE_ACTUAL_ARG_TYPES (f1)\n-\t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1),\n-\t\t\t\t\t   enum_and_int_p, different_types_p))\n+\t  && type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1),\n+\t\t\t\t      enum_and_int_p, different_types_p) != 1)\n \tval = 2;\n       return val;\n     }\n@@ -1672,8 +1672,8 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n       if (!self_promoting_args_p (args1))\n \treturn 0;\n       if (TYPE_ACTUAL_ARG_TYPES (f2)\n-\t  && 1 != type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2),\n-\t\t\t\t\t   enum_and_int_p, different_types_p))\n+\t  && type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2),\n+\t\t\t\t      enum_and_int_p, different_types_p) != 1)\n \tval = 2;\n       return val;\n     }\n@@ -2121,8 +2121,8 @@ perform_integral_promotions (tree exp)\n       && DECL_C_BIT_FIELD (TREE_OPERAND (exp, 1))\n       /* If it's thinner than an int, promote it like a\n \t c_promoting_integer_type_p, otherwise leave it alone.  */\n-      && 0 > compare_tree_int (DECL_SIZE (TREE_OPERAND (exp, 1)),\n-\t\t\t       TYPE_PRECISION (integer_type_node)))\n+      && compare_tree_int (DECL_SIZE (TREE_OPERAND (exp, 1)),\n+\t\t\t   TYPE_PRECISION (integer_type_node)) < 0)\n     return convert (integer_type_node, exp);\n \n   if (c_promoting_integer_type_p (type))\n@@ -7426,15 +7426,14 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \t      /* Subtract the size of a single (possibly wide) character\n \t\t because it's ok to ignore the terminating null char\n \t\t that is counted in the length of the constant.  */\n-\t      if (0 > compare_tree_int (TYPE_SIZE_UNIT (type),\n-\t\t\t\t\t(len\n-\t\t\t\t\t - (TYPE_PRECISION (typ1)\n-\t\t\t\t\t    / BITS_PER_UNIT))))\n+\t      if (compare_tree_int (TYPE_SIZE_UNIT (type),\n+\t\t\t\t    (len - (TYPE_PRECISION (typ1)\n+\t\t\t\t\t    / BITS_PER_UNIT))) < 0)\n \t\tpedwarn_init (init_loc, 0,\n \t\t\t      (\"initializer-string for array of chars \"\n \t\t\t       \"is too long\"));\n \t      else if (warn_cxx_compat\n-\t\t       && 0 > compare_tree_int (TYPE_SIZE_UNIT (type), len))\n+\t\t       && compare_tree_int (TYPE_SIZE_UNIT (type), len) < 0)\n \t\twarning_at (init_loc, OPT_Wc___compat,\n \t\t\t    (\"initializer-string for array chars \"\n \t\t\t     \"is too long for C++\"));"}, {"sha": "85374d32c76a81fda9a838efa704ddd0d069ad38", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -6102,7 +6102,7 @@ expand_stack_alignment (void)\n   gcc_assert ((stack_realign_drap != 0) == (drap_rtx != NULL));\n \n   /* Do nothing if NULL is returned, which means DRAP is not needed.  */\n-  if (NULL != drap_rtx)\n+  if (drap_rtx != NULL)\n     {\n       crtl->args.internal_arg_pointer = drap_rtx;\n "}, {"sha": "fda9f5d3e131092ab90262b0ab663e28bdcd4ee5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2194,7 +2194,7 @@ print_rtl_with_bb (FILE *outf, const rtx_insn *rtx_first, dump_flags_t flags)\n \t    }\n \t}\n \n-      for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n+      for (tmp_rtx = rtx_first; tmp_rtx != NULL; tmp_rtx = NEXT_INSN (tmp_rtx))\n \t{\n \t  if (flags & TDF_BLOCKS)\n \t    {"}, {"sha": "901182454c5b77ca5d78abd73a3e328765939a7d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2155,8 +2155,8 @@ cgraph_node::expand (void)\n \n       if (ret_type && TYPE_SIZE_UNIT (ret_type)\n \t  && TREE_CODE (TYPE_SIZE_UNIT (ret_type)) == INTEGER_CST\n-\t  && 0 < compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n-\t\t\t\t   larger_than_size))\n+\t  && compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n+\t\t\t       larger_than_size) > 0)\n \t{\n \t  unsigned int size_as_int\n \t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));"}, {"sha": "36bd21ae5ca5d35b89c3df33cf444c5e24fe1a24", "filename": "gcc/combine.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -5083,9 +5083,9 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t     is known to be on, this can be converted into a NEG of a shift.  */\n \t  if (STORE_FLAG_VALUE == -1 && XEXP (SET_SRC (x), 1) == const0_rtx\n \t      && GET_MODE (SET_SRC (x)) == GET_MODE (XEXP (SET_SRC (x), 0))\n-\t      && 1 <= (pos = exact_log2\n-\t\t       (nonzero_bits (XEXP (SET_SRC (x), 0),\n-\t\t\t\t      GET_MODE (XEXP (SET_SRC (x), 0))))))\n+\t      && ((pos = exact_log2 (nonzero_bits (XEXP (SET_SRC (x), 0),\n+\t\t\t\t\t\t   GET_MODE (XEXP (SET_SRC (x),\n+\t\t\t\t\t\t\t     0))))) >= 1))\n \t    {\n \t      machine_mode mode = GET_MODE (XEXP (SET_SRC (x), 0));\n \n@@ -6680,7 +6680,7 @@ simplify_if_then_else (rtx x)\n       && XEXP (cond, 1) == const0_rtx\n       && false_rtx == const0_rtx\n       && CONST_INT_P (true_rtx)\n-      && ((1 == nonzero_bits (XEXP (cond, 0), int_mode)\n+      && ((nonzero_bits (XEXP (cond, 0), int_mode) == 1\n \t   && (i = exact_log2 (UINTVAL (true_rtx))) >= 0)\n \t  || ((num_sign_bit_copies (XEXP (cond, 0), int_mode)\n \t       == GET_MODE_PRECISION (int_mode))\n@@ -8637,9 +8637,9 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n   if (GET_CODE (x) == SUBREG\n       && subreg_lowpart_p (x)\n       && (partial_subreg_p (x)\n-\t  || (0 == (mask\n-\t\t    & GET_MODE_MASK (GET_MODE (x))\n-\t\t    & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))))\n+\t  || (mask\n+\t      & GET_MODE_MASK (GET_MODE (x))\n+\t      & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))) == 0))\n     return force_to_mode (SUBREG_REG (x), mode, mask, next_select);\n \n   scalar_int_mode int_mode, xmode;\n@@ -9328,8 +9328,8 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n   /* If X is a SUBREG, we can narrow both the true and false values\n      if the inner expression, if there is a condition.  */\n   else if (code == SUBREG\n-\t   && 0 != (cond0 = if_then_else_cond (SUBREG_REG (x),\n-\t\t\t\t\t       &true0, &false0)))\n+\t   && (cond0 = if_then_else_cond (SUBREG_REG (x), &true0,\n+\t\t\t\t\t  &false0)) != 0)\n     {\n       true0 = simplify_gen_subreg (mode, true0,\n \t\t\t\t   GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n@@ -10928,8 +10928,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t\t shift_unit_mode wider than result_mode.  */\n \t      && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n \t\t   && int_result_mode != shift_unit_mode\n-\t\t   && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n-\t\t\t\t\t      shift_unit_mode))\n+\t\t   && trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n+\t\t\t\t\t  shift_unit_mode) < 0)\n \t      && (new_rtx = simplify_const_binary_operation\n \t\t  (code, int_result_mode,\n \t\t   gen_int_mode (INTVAL (XEXP (varop, 1)), int_result_mode),\n@@ -10949,10 +10949,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t     (ashiftrt (xor)) where we've widened the shift and the constant\n \t     changes the sign bit.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n-\t     && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n-\t\t  && int_result_mode != shift_unit_mode\n-\t\t  && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n-\t\t\t\t\t     shift_unit_mode)))\n+\t      && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n+\t\t   && int_result_mode != shift_unit_mode\n+\t\t   && trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n+\t\t\t\t\t  shift_unit_mode) < 0))\n \t    {\n \t      rtx lhs = simplify_shift_const (NULL_RTX, code, shift_unit_mode,\n \t\t\t\t\t      XEXP (varop, 0), count);\n@@ -11061,10 +11061,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  else if ((code == ASHIFTRT || code == LSHIFTRT)\n \t\t   && count < HOST_BITS_PER_WIDE_INT\n \t\t   && HWI_COMPUTABLE_MODE_P (int_result_mode)\n-\t\t   && 0 == (nonzero_bits (XEXP (varop, 0), int_result_mode)\n-\t\t\t    >> count)\n-\t\t   && 0 == (nonzero_bits (XEXP (varop, 0), int_result_mode)\n-\t\t\t    & nonzero_bits (XEXP (varop, 1), int_result_mode)))\n+\t\t   && (nonzero_bits (XEXP (varop, 0), int_result_mode)\n+\t\t       >> count) == 0\n+\t\t   && (nonzero_bits (XEXP (varop, 0), int_result_mode)\n+\t\t       & nonzero_bits (XEXP (varop, 1), int_result_mode)) == 0)\n \t    {\n \t      varop = XEXP (varop, 1);\n \t      continue;\n@@ -12000,10 +12000,10 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && HWI_COMPUTABLE_MODE_P (GET_MODE (SUBREG_REG (inner_op0)))\n \t      && (GET_MODE (SUBREG_REG (inner_op0))\n \t\t  == GET_MODE (SUBREG_REG (inner_op1)))\n-\t      && (0 == ((~c0) & nonzero_bits (SUBREG_REG (inner_op0),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (inner_op0)))))\n-\t      && (0 == ((~c1) & nonzero_bits (SUBREG_REG (inner_op1),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (inner_op1))))))\n+\t      && ((~c0) & nonzero_bits (SUBREG_REG (inner_op0),\n+\t\t\t\t\tGET_MODE (SUBREG_REG (inner_op0)))) == 0\n+\t      && ((~c1) & nonzero_bits (SUBREG_REG (inner_op1),\n+\t\t\t\t\tGET_MODE (SUBREG_REG (inner_op1)))) == 0)\n \t    {\n \t      op0 = SUBREG_REG (inner_op0);\n \t      op1 = SUBREG_REG (inner_op1);\n@@ -12339,8 +12339,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t   && (equality_comparison_p || unsigned_comparison_p)\n \t\t   /* (A - C1) zero-extends if it is positive and sign-extends\n \t\t      if it is negative, C2 both zero- and sign-extends.  */\n-\t\t   && ((0 == (nonzero_bits (a, inner_mode)\n-\t\t\t      & ~GET_MODE_MASK (mode))\n+\t\t   && (((nonzero_bits (a, inner_mode)\n+\t\t\t & ~GET_MODE_MASK (mode)) == 0\n \t\t\t&& const_op >= 0)\n \t\t       /* (A - C1) sign-extends if it is positive and 1-extends\n \t\t\t  if it is negative, C2 both sign- and 1-extends.  */\n@@ -12408,8 +12408,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     this for equality comparisons due to pathological cases involving\n \t     overflows.  */\n \t  if (equality_comparison_p\n-\t      && 0 != (tem = simplify_binary_operation (MINUS, mode,\n-\t\t\t\t\t\t\top1, XEXP (op0, 1))))\n+\t      && (tem = simplify_binary_operation (MINUS, mode,\n+\t\t\t\t\t\t   op1, XEXP (op0, 1))) != 0)\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      op1 = tem;\n@@ -12437,17 +12437,17 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     this for equality comparisons due to pathological cases involving\n \t     overflows.  */\n \t  if (equality_comparison_p\n-\t      && 0 != (tem = simplify_binary_operation (PLUS, mode,\n-\t\t\t\t\t\t\tXEXP (op0, 1), op1)))\n+\t      && (tem = simplify_binary_operation (PLUS, mode,\n+\t\t\t\t\t\t   XEXP (op0, 1), op1)) != 0)\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      op1 = tem;\n \t      continue;\n \t    }\n \n \t  if (equality_comparison_p\n-\t      && 0 != (tem = simplify_binary_operation (MINUS, mode,\n-\t\t\t\t\t\t\tXEXP (op0, 0), op1)))\n+\t      && (tem = simplify_binary_operation (MINUS, mode,\n+\t\t\t\t\t\t   XEXP (op0, 0), op1)) != 0)\n \t    {\n \t      op0 = XEXP (op0, 1);\n \t      op1 = tem;\n@@ -12471,8 +12471,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* (eq (xor A B) C) -> (eq A (xor B C)).  This is a simplification\n \t     if C is zero or B is a constant.  */\n \t  if (equality_comparison_p\n-\t      && 0 != (tem = simplify_binary_operation (XOR, mode,\n-\t\t\t\t\t\t\tXEXP (op0, 1), op1)))\n+\t      && (tem = simplify_binary_operation (XOR, mode,\n+\t\t\t\t\t\t   XEXP (op0, 1), op1)) != 0)\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      op1 = tem;"}, {"sha": "f914285e16e7213a9d473dfe2c0a05cd556e6773", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -13987,7 +13987,7 @@ arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n   HOST_WIDE_INT src_autoinc, dst_autoinc;\n   rtx mem, addr;\n   \n-  gcc_assert (1 <= interleave_factor && interleave_factor <= 4);\n+  gcc_assert (interleave_factor >= 1 && interleave_factor <= 4);\n   \n   /* Use hard registers if we have aligned source or destination so we can use\n      load/store multiple with contiguous registers.  */"}, {"sha": "d1cf3dd003cc8c550c09f199fa895f84a336a762", "filename": "gcc/config/avr/avr-log.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Favr-log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Favr-log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-log.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -86,7 +86,7 @@ avr_vdump (FILE *stream, const char *caller, ...)\n {\n   va_list ap;\n         \n-  if (NULL == stream && dump_file)\n+  if (stream == NULL && dump_file)\n     stream = dump_file;\n \n   va_start (ap, caller);\n@@ -294,15 +294,15 @@ avr_log_set_avr_log (void)\n       str[0] = ',';\n       strcat (stpcpy (str+1, avr_log_details), \",\");\n \n-      all |= NULL != strstr (str, \",all,\");\n-      info = NULL != strstr (str, \",?,\");\n+      all |= strstr (str, \",all,\") != NULL;\n+      info = strstr (str, \",?,\") != NULL;\n \n       if (info)\n         fprintf (stderr, \"\\n-mlog=\");\n \n #define SET_DUMP_DETAIL(S)                                       \\\n       do {                                                       \\\n-        avr_log.S = (all || NULL != strstr (str, \",\" #S \",\"));   \\\n+\tavr_log.S = (all || strstr (str, \",\" #S \",\") != NULL);   \\\n         if (info)                                                \\\n           fprintf (stderr, #S \",\");                              \\\n       } while (0)"}, {"sha": "ff6672fed469db3f05a761f0d4094a8aa3d1026c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -65,7 +65,7 @@\n #define MAX_LD_OFFSET(MODE) (64 - (signed)GET_MODE_SIZE (MODE))\n \n /* Return true if STR starts with PREFIX and false, otherwise.  */\n-#define STR_PREFIX_P(STR,PREFIX) (0 == strncmp (STR, PREFIX, strlen (PREFIX)))\n+#define STR_PREFIX_P(STR,PREFIX) (strncmp (STR, PREFIX, strlen (PREFIX)) == 0)\n \n /* The 4 bits starting at SECTION_MACH_DEP are reserved to store the\n    address space where data is to be located.\n@@ -269,7 +269,7 @@ avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n       rtx xval8 = simplify_gen_subreg (QImode, xval, mode, i);\n       unsigned int val8 = UINTVAL (xval8) & GET_MODE_MASK (QImode);\n \n-      if (0 == (pop_mask & (1 << popcount_hwi (val8))))\n+      if ((pop_mask & (1 << popcount_hwi (val8))) == 0)\n         return false;\n     }\n \n@@ -461,8 +461,8 @@ avr_is_casesi_sequence (basic_block bb, rtx_insn *insn, rtx_insn *insns[6])\n \n   // Assert on the anatomy of xinsn's operands we are going to work with.\n \n-  gcc_assert (11 == recog_data.n_operands);\n-  gcc_assert (4 == recog_data.n_dups);\n+  gcc_assert (recog_data.n_operands == 11);\n+  gcc_assert (recog_data.n_dups == 4);\n \n   if (dump_file)\n     {\n@@ -509,7 +509,7 @@ avr_casei_sequence_check_operands (rtx *xop)\n \n   if (sub_5\n       && SUBREG_P (sub_5)\n-      && 0 == SUBREG_BYTE (sub_5)\n+      && SUBREG_BYTE (sub_5) == 0\n       && rtx_equal_p (xop[5], SUBREG_REG (sub_5)))\n     return true;\n \n@@ -697,7 +697,7 @@ avr_set_core_architecture (void)\n \n   for (const avr_mcu_t *mcu = avr_mcu_types; ; mcu++)\n     {\n-      if (NULL == mcu->name)\n+      if (mcu->name == NULL)\n         {\n           /* Reached the end of `avr_mcu_types'.  This should actually never\n              happen as options are provided by device-specs.  It could be a\n@@ -709,9 +709,9 @@ avr_set_core_architecture (void)\n           avr_inform_core_architectures ();\n           break;\n         }\n-      else if (0 == strcmp (mcu->name, avr_mmcu)\n+      else if (strcmp (mcu->name, avr_mmcu) == 0\n                // Is this a proper architecture ?\n-               && NULL == mcu->macro)\n+\t       && mcu->macro == NULL)\n         {\n           avr_arch = &avr_arch_types[mcu->arch_id];\n           if (avr_n_flash < 0)\n@@ -1109,9 +1109,9 @@ avr_set_current_function (tree decl)\n   // Common problem is using \"ISR\" without first including avr/interrupt.h.\n   const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n   name = default_strip_name_encoding (name);\n-  if (0 == strcmp (\"ISR\", name)\n-      || 0 == strcmp (\"INTERRUPT\", name)\n-      || 0 == strcmp (\"SIGNAL\", name))\n+  if (strcmp (\"ISR\", name) == 0\n+      || strcmp (\"INTERRUPT\", name) == 0\n+      || strcmp (\"SIGNAL\", name) == 0)\n     {\n       warning_at (loc, OPT_Wmisspelled_isr, \"%qs is a reserved identifier\"\n                   \" in AVR-LibC.  Consider %<#include <avr/interrupt.h>%>\"\n@@ -2572,7 +2572,7 @@ avr_legitimize_reload_address (rtx *px, machine_mode mode,\n \n   if (GET_CODE (x) == PLUS\n       && REG_P (XEXP (x, 0))\n-      && 0 == reg_equiv_constant (REGNO (XEXP (x, 0)))\n+      && reg_equiv_constant (REGNO (XEXP (x, 0))) == 0\n       && CONST_INT_P (XEXP (x, 1))\n       && INTVAL (XEXP (x, 1)) >= 1)\n     {\n@@ -2639,10 +2639,8 @@ avr_legitimize_reload_address (rtx *px, machine_mode mode,\n static const char*\n avr_asm_len (const char* tpl, rtx* operands, int* plen, int n_words)\n {\n-  if (NULL == plen)\n-    {\n-      output_asm_insn (tpl, operands);\n-    }\n+  if (plen == NULL)\n+    output_asm_insn (tpl, operands);\n   else\n     {\n       if (n_words < 0)\n@@ -2969,7 +2967,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n   else if (code == 'x')\n     {\n       /* Constant progmem address - like used in jmp or call */\n-      if (0 == text_segment_operand (x, VOIDmode))\n+      if (text_segment_operand (x, VOIDmode) == 0)\n         if (warning (0, \"accessing program memory\"\n                      \" with data memory address\"))\n           {\n@@ -3930,7 +3928,7 @@ output_movqi (rtx_insn *insn, rtx operands[], int *plen)\n       return avr_out_lpm (insn, operands, plen);\n     }\n \n-  gcc_assert (1 == GET_MODE_SIZE (GET_MODE (dest)));\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (dest)) == 1);\n \n   if (REG_P (dest))\n     {\n@@ -4925,7 +4923,7 @@ output_movsisf (rtx_insn *insn, rtx operands[], int *l)\n   if (!l)\n     l = &dummy;\n \n-  gcc_assert (4 == GET_MODE_SIZE (GET_MODE (dest)));\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (dest)) == 4);\n \n   if (REG_P (dest))\n     {\n@@ -8265,7 +8263,7 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)\n       return \"\";\n     }\n \n-  if (8 == n_bytes)\n+  if (n_bytes == 8)\n     {\n       op[0] = gen_rtx_REG (DImode, ACC_A);\n       op[1] = gen_rtx_REG (DImode, ACC_A);\n@@ -8383,11 +8381,11 @@ avr_out_bitop (rtx insn, rtx *xop, int *plen)\n         {\n         case IOR:\n \n-          if (0 == pop8)\n+\t  if (pop8 == 0)\n             continue;\n           else if (ld_reg_p)\n             avr_asm_len (\"ori %0,%1\", op, plen, 1);\n-          else if (1 == pop8)\n+\t  else if (pop8 == 1)\n             {\n               if (set_t != 1)\n                 avr_asm_len (\"set\", op, plen, 1);\n@@ -8396,7 +8394,7 @@ avr_out_bitop (rtx insn, rtx *xop, int *plen)\n               op[1] = GEN_INT (exact_log2 (val8));\n               avr_asm_len (\"bld %0,%1\", op, plen, 1);\n             }\n-          else if (8 == pop8)\n+\t  else if (pop8 == 8)\n             {\n               if (op[3] != NULL_RTX)\n                 avr_asm_len (\"mov %0,%3\", op, plen, 1);\n@@ -8419,13 +8417,13 @@ avr_out_bitop (rtx insn, rtx *xop, int *plen)\n \n         case AND:\n \n-          if (8 == pop8)\n+\t  if (pop8 == 8)\n             continue;\n-          else if (0 == pop8)\n+\t  else if (pop8 == 0)\n             avr_asm_len (\"clr %0\", op, plen, 1);\n           else if (ld_reg_p)\n             avr_asm_len (\"andi %0,%1\", op, plen, 1);\n-          else if (7 == pop8)\n+\t  else if (pop8 == 7)\n             {\n               if (set_t != 0)\n                 avr_asm_len (\"clt\", op, plen, 1);\n@@ -8447,9 +8445,9 @@ avr_out_bitop (rtx insn, rtx *xop, int *plen)\n \n         case XOR:\n \n-          if (0 == pop8)\n+\t  if (pop8 == 0)\n             continue;\n-          else if (8 == pop8)\n+\t  else if (pop8 == 8)\n             avr_asm_len (\"com %0\", op, plen, 1);\n           else if (ld_reg_p && val8 == (1 << 7))\n             avr_asm_len (\"subi %0,%1\", op, plen, 1);\n@@ -8727,9 +8725,9 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n \n   bool sign_extend = src.sbit && sign_bytes;\n \n-  if (0 == dest.fbit % 8 && 7 == src.fbit % 8)\n+  if (dest.fbit % 8 == 0 && src.fbit % 8 == 7)\n     shift = ASHIFT;\n-  else if (7 == dest.fbit % 8 && 0 == src.fbit % 8)\n+  else if (dest.fbit % 8 == 7 && src.fbit % 8 == 0)\n     shift = ASHIFTRT;\n   else if (dest.fbit % 8 == src.fbit % 8)\n     shift = UNKNOWN;\n@@ -9401,8 +9399,7 @@ avr_adjust_insn_length (rtx_insn *insn, int len)\n      It is easier to state this in an insn attribute \"adjust_len\" than\n      to clutter up code here...  */\n \n-  if (!NONDEBUG_INSN_P (insn)\n-      || -1 == recog_memoized (insn))\n+  if (!NONDEBUG_INSN_P (insn) || recog_memoized (insn) == -1)\n     {\n       return len;\n     }\n@@ -10265,7 +10262,7 @@ avr_asm_init_sections (void)\n      we have also to track .rodata because it is located in RAM then.  */\n \n #if defined HAVE_LD_AVR_AVRXMEGA3_RODATA_IN_FLASH\n-  if (0 == avr_arch->flash_pm_offset)\n+  if (avr_arch->flash_pm_offset == 0)\n #endif\n     readonly_data_section->unnamed.callback = avr_output_data_section_asm_op;\n   data_section->unnamed.callback = avr_output_data_section_asm_op;\n@@ -10303,7 +10300,7 @@ avr_asm_named_section (const char *name, unsigned int flags, tree decl)\n \n   if (!avr_need_copy_data_p\n #if defined HAVE_LD_AVR_AVRXMEGA3_RODATA_IN_FLASH\n-      && 0 == avr_arch->flash_pm_offset\n+      && avr_arch->flash_pm_offset == 0\n #endif\n       )\n     avr_need_copy_data_p = (STR_PREFIX_P (name, \".rodata\")\n@@ -10439,8 +10436,7 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n       /* PSTR strings are in generic space but located in flash:\n          patch address space.  */\n \n-      if (!AVR_TINY\n-          && -1 == avr_progmem_p (decl, attr))\n+      if (!AVR_TINY && avr_progmem_p (decl, attr) == -1)\n         as = ADDR_SPACE_FLASH;\n \n       AVR_SYMBOL_SET_ADDR_SPACE (sym, as);\n@@ -10479,7 +10475,7 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n       && SYMBOL_REF_P (XEXP (rtl, 0)))\n     {\n       rtx sym = XEXP (rtl, 0);\n-      bool progmem_p = -1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl));\n+      bool progmem_p = avr_progmem_p (decl, DECL_ATTRIBUTES (decl)) == -1;\n \n       if (progmem_p)\n         {\n@@ -12091,9 +12087,7 @@ test_hard_reg_class (enum reg_class rclass, rtx x)\n static bool\n avr_2word_insn_p (rtx_insn *insn)\n {\n-  if (TARGET_SKIP_BUG\n-      || !insn\n-      || 2 != get_attr_length (insn))\n+  if (TARGET_SKIP_BUG || !insn || get_attr_length (insn) != 2)\n     {\n       return false;\n     }\n@@ -12402,11 +12396,8 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n \n           if (INTVAL (lo16) == INTVAL (hi16))\n             {\n-              if (0 != INTVAL (lo16)\n-                  || !clear_p)\n-                {\n-                  avr_asm_len (\"movw %C0,%A0\", &op[0], len, 1);\n-                }\n+\t      if (INTVAL (lo16) != 0 || !clear_p)\n+\t\tavr_asm_len (\"movw %C0,%A0\", &op[0], len, 1);\n \n               break;\n             }\n@@ -12458,15 +12449,15 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n \n       /* Need no clobber reg for -1: Use CLR/DEC */\n \n-      if (-1 == ival[n])\n+      if (ival[n] == -1)\n         {\n           if (!clear_p)\n             avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n \n           avr_asm_len (\"dec %0\", &xdest[n], len, 1);\n           continue;\n         }\n-      else if (1 == ival[n])\n+      else if (ival[n] == 1)\n         {\n           if (!clear_p)\n             avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n@@ -13690,7 +13681,7 @@ bool\n avr_has_nibble_0xf (rtx ival)\n {\n   unsigned int map = UINTVAL (ival) & GET_MODE_MASK (SImode);\n-  return 0 != avr_map_metric (map, MAP_MASK_PREIMAGE_F);\n+  return avr_map_metric (map, MAP_MASK_PREIMAGE_F) != 0;\n }\n \n \n@@ -13757,7 +13748,7 @@ static const avr_map_op_t avr_map_op[] =\n static avr_map_op_t\n avr_map_decompose (unsigned int f, const avr_map_op_t *g, bool val_const_p)\n {\n-  bool val_used_p = 0 != avr_map_metric (f, MAP_MASK_PREIMAGE_F);\n+  bool val_used_p = avr_map_metric (f, MAP_MASK_PREIMAGE_F) != 0;\n   avr_map_op_t f_ginv = *g;\n   unsigned int ginv = g->ginv;\n \n@@ -13788,13 +13779,10 @@ avr_map_decompose (unsigned int f, const avr_map_op_t *g, bool val_const_p)\n \n   /* Step 2a:  Compute cost of F o G^-1  */\n \n-  if (0 == avr_map_metric (f_ginv.map, MAP_NONFIXED_0_7))\n-    {\n-      /* The mapping consists only of fixed points and can be folded\n-         to AND/OR logic in the remainder.  Reasonable cost is 3. */\n-\n-      f_ginv.cost = 2 + (val_used_p && !val_const_p);\n-    }\n+  if (avr_map_metric (f_ginv.map, MAP_NONFIXED_0_7) == 0)\n+    /* The mapping consists only of fixed points and can be folded\n+       to AND/OR logic in the remainder.  Reasonable cost is 3. */\n+    f_ginv.cost = 2 + (val_used_p && !val_const_p);\n   else\n     {\n       rtx xop[4];\n@@ -14500,7 +14488,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n         map = TREE_INT_CST_LOW (tmap);\n \n         if (TREE_CODE (tval) != INTEGER_CST\n-            && 0 == avr_map_metric (map, MAP_MASK_PREIMAGE_F))\n+\t    && avr_map_metric (map, MAP_MASK_PREIMAGE_F) == 0)\n           {\n             /* There are no F in the map, i.e. 3rd operand is unused.\n                Replace that argument with some constant to render\n@@ -14511,7 +14499,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n           }\n \n         if (TREE_CODE (tbits) != INTEGER_CST\n-            && 0 == avr_map_metric (map, MAP_PREIMAGE_0_7))\n+\t    && avr_map_metric (map, MAP_PREIMAGE_0_7) == 0)\n           {\n             /* Similar for the bits to be inserted. If they are unused,\n                we can just as well pass 0.  */\n@@ -14550,7 +14538,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n         /* If bits don't change their position we can use vanilla logic\n            to merge the two arguments.  */\n \n-        if (0 == avr_map_metric (map, MAP_NONFIXED_0_7))\n+\tif (avr_map_metric (map, MAP_NONFIXED_0_7) == 0)\n           {\n             int mask_f = avr_map_metric (map, MAP_MASK_PREIMAGE_F);\n             tree tres, tmask = build_int_cst (val_type, mask_f ^ 0xff);"}, {"sha": "226c47cefb09fb80b2763e22953929e25bae8524", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -224,25 +224,25 @@\n (define_constraint \"Y01\"\n   \"Fixed-point or integer constant with bit representation 0x1\"\n   (ior (and (match_code \"const_fixed\")\n-            (match_test \"1 == INTVAL (avr_to_int_mode (op))\"))\n+\t    (match_test \"INTVAL (avr_to_int_mode (op)) == 1\"))\n        (match_test \"satisfies_constraint_P (op)\")))\n \n (define_constraint \"Ym1\"\n   \"Fixed-point or integer constant with bit representation -0x1\"\n   (ior (and (match_code \"const_fixed\")\n-            (match_test \"-1 == INTVAL (avr_to_int_mode (op))\"))\n+\t    (match_test \"INTVAL (avr_to_int_mode (op)) == -1\"))\n        (match_test \"satisfies_constraint_N (op)\")))\n \n (define_constraint \"Y02\"\n   \"Fixed-point or integer constant with bit representation 0x2\"\n   (ior (and (match_code \"const_fixed\")\n-            (match_test \"2 == INTVAL (avr_to_int_mode (op))\"))\n+\t    (match_test \"INTVAL (avr_to_int_mode (op)) == 2\"))\n        (match_test \"satisfies_constraint_K (op)\")))\n \n (define_constraint \"Ym2\"\n   \"Fixed-point or integer constant with bit representation -0x2\"\n   (ior (and (match_code \"const_fixed\")\n-            (match_test \"-2 == INTVAL (avr_to_int_mode (op))\"))\n+\t    (match_test \"INTVAL (avr_to_int_mode (op)) == -2\"))\n        (match_test \"satisfies_constraint_Cm2 (op)\")))\n \n (define_constraint \"Yx2\""}, {"sha": "2d3e0d5593bebbcf59cf5f1752c9cc57a7ecde5f", "filename": "gcc/config/avr/driver-avr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fdriver-avr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fdriver-avr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fdriver-avr.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -59,7 +59,7 @@ avr_devicespecs_file (int argc, const char **argv)\n       return X_NODEVLIB;\n \n     case 1:\n-      if (0 == strcmp (\"device-specs\", argv[0]))\n+      if (strcmp (\"device-specs\", argv[0]) == 0)\n         {\n           /* FIXME:  This means \"device-specs%s\" from avr.h:DRIVER_SELF_SPECS\n              has not been resolved to a path.  That case can occur when the\n@@ -81,7 +81,7 @@ avr_devicespecs_file (int argc, const char **argv)\n       // Allow specifying the same MCU more than once.\n \n       for (int i = 2; i < argc; i++)\n-        if (0 != strcmp (mmcu, argv[i]))\n+\tif (strcmp (mmcu, argv[i]) != 0)\n           {\n             error (\"specified option %qs more than once\", \"-mmcu\");\n             return X_NODEVLIB;"}, {"sha": "08ef1664716fafa411deb23feb6ed6c0ed405f31", "filename": "gcc/config/avr/gen-avr-mmcu-specs.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -55,7 +55,7 @@\n static bool\n str_prefix_p (const char *str, const char *prefix)\n {\n-  return 0 == strncmp (str, prefix, strlen (prefix));\n+  return strncmp (str, prefix, strlen (prefix)) == 0;\n }\n \n \n@@ -133,12 +133,12 @@ print_mcu (const avr_mcu_t *mcu)\n \n   FILE *f = fopen (name ,\"w\");\n \n-  bool absdata = 0 != (mcu->dev_attribute & AVR_ISA_LDS);\n-  bool errata_skip = 0 != (mcu->dev_attribute & AVR_ERRATA_SKIP);\n-  bool rmw = 0 != (mcu->dev_attribute & AVR_ISA_RMW);\n-  bool sp8 = 0 != (mcu->dev_attribute & AVR_SHORT_SP);\n+  bool absdata = (mcu->dev_attribute & AVR_ISA_LDS) != 0;\n+  bool errata_skip = (mcu->dev_attribute & AVR_ERRATA_SKIP) != 0;\n+  bool rmw = (mcu->dev_attribute & AVR_ISA_RMW) != 0;\n+  bool sp8 = (mcu->dev_attribute & AVR_SHORT_SP) != 0;\n   bool rcall = (mcu->dev_attribute & AVR_ISA_RCALL);\n-  bool is_arch = NULL == mcu->macro;\n+  bool is_arch = mcu->macro == NULL;\n   bool is_device = ! is_arch;\n \n   if (is_arch"}, {"sha": "1147005d5120bac1408ee2c07f8b2d87f1246f32", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -221,7 +221,7 @@\n ;; 8 or 16 or 24.\n (define_predicate \"const_8_16_24_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"8 == INTVAL(op) || 16 == INTVAL(op) || 24 == INTVAL(op)\")))\n+       (match_test \"INTVAL(op) == 8 || INTVAL(op) == 16 || INTVAL(op) == 24\")))\n \n ;; Unsigned CONST_INT that fits in 8 bits, i.e. 0..255.\n (define_predicate \"u8_operand\""}, {"sha": "364fdf49e7efa05bc987cb37906dfc3f164ecbb3", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1859,10 +1859,10 @@ cr16_create_dwarf_for_multi_push (rtx insn)\n \n   for (i = current_frame_info.last_reg_to_save; i >= 0;)\n     {\n-      if (!current_frame_info.save_regs[i] || 0 == i || split_here)\n+      if (!current_frame_info.save_regs[i] || i == 0 || split_here)\n \t{\n \t  /* This block of regs is pushed in one instruction.  */\n-\t  if (0 == i && current_frame_info.save_regs[i])\n+\t  if (i == 0 && current_frame_info.save_regs[i])\n \t    from = 0;\n \n \t  for (j = to; j >= from; --j)"}, {"sha": "5c4702c28ef35b19f43c9748ed0ff51306c1ea97", "filename": "gcc/config/cr16/cr16.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -233,7 +233,7 @@ while (0)\n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME) \t\t\t  \t\t\\\n-  (0 == COUNT)\t?  gen_rtx_PLUS (Pmode, gen_rtx_RA, gen_rtx_RA)\t\t\\\n+  (COUNT == 0)\t?  gen_rtx_PLUS (Pmode, gen_rtx_RA, gen_rtx_RA)\t\t\\\n \t\t:  const0_rtx\n \n enum reg_class\n@@ -293,7 +293,7 @@ enum reg_class\n \t(CR16_REGNO_OK_FOR_BASE_P(REGNO)  &&\t  \\\n \t  ((GET_MODE_SIZE (MODE) > 4  &&  \t  \\\n \t     (REGNO) < CR16_FIRST_DWORD_REGISTER) \\\n-\t     ? (0 == ((REGNO) & 1)) \t\t  \\\n+\t     ? (((REGNO) & 1) == 0) \t\t  \\\n \t     : 1))\n \n /* TODO: For now lets not support index addressing mode.  */"}, {"sha": "25e1041506f994f3035da6163c0808e23da01b76", "filename": "gcc/config/cr16/cr16.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fcr16%2Fcr16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fcr16%2Fcr16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -655,8 +655,8 @@\n    || register_operand (operands[1], DImode)\n    || register_operand (operands[1], DFmode)\"\n   {\n-    if (0 == which_alternative) {\n-      rtx xoperands[2] ;\n+    if (which_alternative == 0) {\n+      rtx xoperands[2];\n       int reg0 = REGNO (operands[0]);\n       int reg1 = REGNO (operands[1]);\n \n@@ -673,9 +673,9 @@\n \t  output_asm_insn (\"movd\\t%1, %0\", operands);\n \t}}\n \n-    else if (1 == which_alternative) {\n-      rtx lo_operands[2] ;\n-      rtx hi_operands[2] ;\n+    else if (which_alternative == 1) {\n+      rtx lo_operands[2];\n+      rtx hi_operands[2];\n \n       lo_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n       hi_operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 2);\n@@ -688,40 +688,40 @@\n       output_asm_insn (\"movd\\t%1, %0\", lo_operands);\n       output_asm_insn (\"movd\\t%1, %0\", hi_operands);}\n \n-    else if (2 == which_alternative) {\n-      rtx xoperands[2] ;\n-      int reg0 = REGNO (operands[0]), reg1 = -2 ;\n-      rtx addr ;\n+    else if (which_alternative == 2) {\n+      rtx xoperands[2];\n+      int reg0 = REGNO (operands[0]), reg1 = -2;\n+      rtx addr;\n \n \tif (MEM_P (operands[1]))\n \t  addr = XEXP (operands[1], 0);\n \telse\n-\t  addr = NULL_RTX ;\n+\t  addr = NULL_RTX;\n \tswitch (GET_CODE (addr))\n \t  {\n \t    case REG:\n \t    case SUBREG:\n \t      reg1 = REGNO (addr);\n-\t      break ;\n+\t      break;\n \t    case PLUS:\n \t      switch (GET_CODE (XEXP (addr, 0))) {\n \t\tcase REG:\n \t\tcase SUBREG:\n \t\t  reg1 = REGNO (XEXP (addr, 0));\n-\t\t  break ;\n+\t\t  break;\n \t\tcase PLUS:\n \t\t  reg1 = REGNO (XEXP (XEXP (addr, 0), 0));\n-\t\t  break ;\n+\t\t  break;\n \t\tdefault:\n \t\t  inform (DECL_SOURCE_LOCATION (cfun->decl), \"unexpected expression; addr:\");\n \t\t  debug_rtx (addr);\n \t\t  inform (DECL_SOURCE_LOCATION (cfun->decl), \"operands[1]:\");\n \t\t  debug_rtx (operands[1]);\n \t\t  inform (DECL_SOURCE_LOCATION (cfun->decl), \"generated code might now work\\n\");\n-\t\t  break ;}\n-\t      break ;\n+\t\t  break;}\n+\t      break;\n \t    default:\n-\t      break ;\n+\t      break;\n \t  }\n \n \txoperands[0] = gen_rtx_REG (SImode, reg0 + 2);\n@@ -739,13 +739,13 @@\n \t  }}\n     else\n       {\n-\trtx xoperands[2] ;\n+\trtx xoperands[2];\n \txoperands[0] = offset_address (operands[0], GEN_INT (4), 2);\n \txoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 2);\n \toutput_asm_insn (\"stord\\t%1, %0\", operands);\n    \toutput_asm_insn (\"stord\\t%1, %0\", xoperands);\n       }\n-    return \"\" ;\n+    return \"\";\n   }\n   [(set_attr \"length\" \"4, <lImmArithD>, <lImmArithD>, <lImmArithD>\")]\n )"}, {"sha": "6d2c2b445e60db10f496bd247bf6c83c1f9b01ae", "filename": "gcc/config/ft32/constraints.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fft32%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fft32%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fconstraints.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -91,7 +91,7 @@\n (define_constraint \"L\"\n   \"A 16-bit unsigned constant, multiple of 4 (-65532..0)\"\n   (and (match_code \"const_int\")\n-       (match_test \"-65532 <= ival && ival <= 0 && (ival & 3) == 0\")))\n+       (match_test \"ival >= -65532 && ival <= 0 && (ival & 3) == 0\")))\n \n (define_constraint \"S\"\n   \"A 20-bit signed constant (-524288..524287)\"\n@@ -105,9 +105,9 @@\n (define_constraint \"b\"\n   \"A constant for a bitfield width (1..16)\"\n   (and (match_code \"const_int\")\n-       (match_test \"1 <= ival && ival <= 16\")))\n+       (match_test \"ival >= 1 && ival <= 16\")))\n \n (define_constraint \"KA\"\n   \"A 10-bit signed constant (-512..511)\"\n   (and (match_code \"const_int\")\n-       (match_test \"-512 <= ival && ival <= 511\")))\n+       (match_test \"ival >= -512 && ival <= 511\")))"}, {"sha": "bc49963ed54c6d5bb304e915e87933111920a58f", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -265,12 +265,12 @@ ft32_load_immediate (rtx dst, int32_t i)\n {\n   char pattern[100];\n \n-  if ((-524288 <= i) && (i <= 524287))\n+  if (i >= -524288 && i <= 524287)\n     {\n       sprintf (pattern, \"ldk.l  %%0,%d\", i);\n       output_asm_insn (pattern, &dst);\n     }\n-  else if ((-536870912 <= i) && (i <= 536870911))\n+  else if (i >= -536870912 && i <= 536870911)\n     {\n       ft32_load_immediate (dst, i >> 10);\n       sprintf (pattern, \"ldl.l  %%0,%%0,%d\", i & 1023);\n@@ -283,7 +283,7 @@ ft32_load_immediate (rtx dst, int32_t i)\n       for (rd = 1; rd < 32; rd++)\n         {\n           u = ((u >> 31) & 1) | (u << 1);\n-          if ((-524288 <= (int32_t) u) && ((int32_t) u <= 524287))\n+\t  if ((int32_t) u >= -524288 && (int32_t) u <= 524287)\n             {\n               ft32_load_immediate (dst, (int32_t) u);\n               sprintf (pattern, \"ror.l  %%0,%%0,%d\", rd);\n@@ -496,7 +496,7 @@ ft32_expand_prologue (void)\n \t}\n     }\n \n-  if (65536 <= cfun->machine->size_for_adjusting_sp)\n+  if (cfun->machine->size_for_adjusting_sp >= 65536)\n     {\n       error (\"stack frame must be smaller than 64K\");\n       return;"}, {"sha": "88c21534471c115efe434cf2bb099c0a94c999a2", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1267,7 +1267,7 @@ h8300_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n \t    *total = 0;\n \t    return true;\n \t  }\n-\tif (-4 <= n && n <= 4)\n+\tif (n >= -4 && n <= 4)\n \t  {\n \t    switch ((int) n)\n \t      {\n@@ -4171,7 +4171,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    }\n \t}\n-      else if ((8 <= count && count <= 13)\n+      else if ((count >= 8 && count <= 13)\n \t       || (TARGET_H8300S && count == 14))\n \t{\n \t  info->remainder = count - 8;\n@@ -4251,7 +4251,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n       gcc_unreachable ();\n \n     case SIshift:\n-      if (TARGET_H8300 && 8 <= count && count <= 9)\n+      if (TARGET_H8300 && count >= 8 && count <= 9)\n \t{\n \t  info->remainder = count - 8;\n \n@@ -4314,9 +4314,9 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      gcc_unreachable ();\n \t    }\n \t}\n-      else if ((TARGET_H8300 && 16 <= count && count <= 20)\n-\t       || (TARGET_H8300H && 16 <= count && count <= 19)\n-\t       || (TARGET_H8300S && 16 <= count && count <= 21))\n+      else if ((TARGET_H8300 && count >= 16 && count <= 20)\n+\t       || (TARGET_H8300H && count >= 16 && count <= 19)\n+\t       || (TARGET_H8300S && count >= 16 && count <= 21))\n \t{\n \t  info->remainder = count - 16;\n \n@@ -4353,7 +4353,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t      goto end;\n \t    }\n \t}\n-      else if (TARGET_H8300 && 24 <= count && count <= 28)\n+      else if (TARGET_H8300 && count >= 24 && count <= 28)\n \t{\n \t  info->remainder = count - 24;\n \n@@ -4377,7 +4377,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,\n \t    }\n \t}\n       else if ((TARGET_H8300H && count == 24)\n-\t       || (TARGET_H8300S && 24 <= count && count <= 25))\n+\t       || (TARGET_H8300S && count >= 24 && count <= 25))\n \t{\n \t  info->remainder = count - 24;\n "}, {"sha": "85988cf2de0d7cee9eff370dff25ce60057310da", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3160,8 +3160,8 @@ ix86_parse_stringop_strategy_string (char *strategy_str, bool is_memset)\n       if (next_range_str)\n         *next_range_str++ = '\\0';\n \n-      if (3 != sscanf (curr_range_str, \"%20[^:]:%d:%10s\",\n-                       alg_name, &maxs, align))\n+      if (sscanf (curr_range_str, \"%20[^:]:%d:%10s\", alg_name, &maxs,\n+\t\t  align) != 3)\n         {\n \t  error (\"wrong argument %qs to option %qs\", curr_range_str, opt);\n           return;"}, {"sha": "0759df102d91402ec33ffc60612542efdfb0b319", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1982,10 +1982,10 @@ iq2000_expand_prologue (void)\n \t{\n \t  if (next_arg == 0\n \t      && DECL_NAME (cur_arg)\n-\t      && ((0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (cur_arg)),\n-\t\t\t\t\"__builtin_va_alist\"))\n-\t\t  || (0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (cur_arg)),\n-\t\t\t\t   \"va_alist\"))))\n+\t      && (strcmp (IDENTIFIER_POINTER (DECL_NAME (cur_arg)),\n+\t\t\t  \"__builtin_va_alist\") == 0\n+\t\t  || strcmp (IDENTIFIER_POINTER (DECL_NAME (cur_arg)),\n+\t\t\t     \"va_alist\") == 0))\n \t    {\n \t      last_arg_is_vararg_marker = 1;\n \t      break;"}, {"sha": "f974b06af494a806c15e26cb9451e4b93c957e61", "filename": "gcc/config/m32c/m32c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -53,7 +53,7 @@ m32c_pragma_memregs (cpp_reader * reader ATTRIBUTE_UNUSED)\n \t  if (type != CPP_EOF)\n \t    warning (0, \"junk at end of #pragma GCC memregs [0..16]\");\n \n-\t  if (0 <= i && i <= 16)\n+\t  if (i >= 0 && i <= 16)\n \t    {\n \t      if (!ok_to_change_target_memregs)\n \t\t{"}, {"sha": "f1a465a4b44dd6b995d417781d19e27331a42497", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -517,7 +517,7 @@ m32c_conditional_register_usage (void)\n {\n   int i;\n \n-  if (0 <= target_memregs && target_memregs <= 16)\n+  if (target_memregs >= 0 && target_memregs <= 16)\n     {\n       /* The command line option is bytes, but our \"registers\" are\n \t 16-bit words.  */\n@@ -2308,9 +2308,9 @@ m32c_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED,\n       i = INTVAL (addr);\n       if (i == 0)\n \treturn COSTS_N_INSNS(1);\n-      if (0 < i && i <= 255)\n+      if (i > 0 && i <= 255)\n \treturn COSTS_N_INSNS(2);\n-      if (0 < i && i <= 65535)\n+      if (i > 0 && i <= 65535)\n \treturn COSTS_N_INSNS(3);\n       return COSTS_N_INSNS(4);\n     case SYMBOL_REF:\n@@ -2323,9 +2323,9 @@ m32c_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED,\n \t  i = INTVAL (XEXP (addr, 1));\n \t  if (i == 0)\n \t    return COSTS_N_INSNS(1);\n-\t  if (0 < i && i <= 255)\n+\t  if (i > 0 && i <= 255)\n \t    return COSTS_N_INSNS(2);\n-\t  if (0 < i && i <= 65535)\n+\t  if (i > 0 && i <= 65535)\n \t    return COSTS_N_INSNS(3);\n \t}\n       return COSTS_N_INSNS(4);"}, {"sha": "de7e899ddc706d483266c6e05c9f7946953c9e7f", "filename": "gcc/config/m32c/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fpredicates.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -210,11 +210,11 @@\n (define_predicate \"shiftcount_operand\"\n   (ior (match_operand 0 \"mra_operand\" \"\")\n        (and (match_operand 2 \"const_int_operand\" \"\")\n-\t    (match_test \"-8 <= INTVAL (op) && INTVAL (op) && INTVAL (op) <= 8\"))))\n+\t    (match_test \"INTVAL (op) >= -8 && INTVAL (op) && INTVAL (op) <= 8\"))))\n (define_predicate \"longshiftcount_operand\"\n   (ior (match_operand 0 \"mra_operand\" \"\")\n        (and (match_operand 2 \"const_int_operand\" \"\")\n-\t    (match_test \"-32 <= INTVAL (op) && INTVAL (op) && INTVAL (op) <= 32\"))))\n+\t    (match_test \"INTVAL (op) >= -32 && INTVAL (op) && INTVAL (op) <= 32\"))))\n \n ; TRUE for r0..r3, a0..a1, or sp.\n (define_predicate \"mra_or_sp_operand\""}, {"sha": "a0fab4c0bb41982e0cde3fe7969372f0299d5e32", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3523,8 +3523,7 @@ output_reg_adjust (rtx reg, int n)\n {\n   const char *s;\n \n-  gcc_assert (GET_MODE (reg) == SImode\n-\t      && -12 <= n && n != 0 && n <= 12);\n+  gcc_assert (GET_MODE (reg) == SImode && n >= -12 && n != 0 && n <= 12);\n \n   switch (n)\n     {\n@@ -3566,8 +3565,7 @@ emit_reg_adjust (rtx reg1, int n)\n {\n   rtx reg2;\n \n-  gcc_assert (GET_MODE (reg1) == SImode\n-\t      && -12 <= n && n != 0 && n <= 12);\n+  gcc_assert (GET_MODE (reg1) == SImode && n >= -12 && n != 0 && n <= 12);\n \n   reg1 = copy_rtx (reg1);\n   reg2 = copy_rtx (reg1);"}, {"sha": "1db8dec32bf55b7c27a286f3b54bd1dde20dcb99", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1330,7 +1330,7 @@ nios2_handle_custom_fpu_insn_option (int fpu_insn_index)\n {\n   int param = N2FPU_N (fpu_insn_index);\n \n-  if (0 <= param && param <= 255)\n+  if (param >= 0 && param <= 255)\n     nios2_register_custom_code (param, CCS_FPU, fpu_insn_index);\n \n   /* Valid values are 0-255, but also allow -1 so that the\n@@ -5131,7 +5131,7 @@ static bool\n can_use_cdx_ldstw (int regno, int basereg, int offset)\n {\n   if (CDX_REG_P (regno) && CDX_REG_P (basereg)\n-      && (offset & 0x3) == 0 && 0 <= offset && offset < 0x40)\n+      && (offset & 0x3) == 0 && offset >= 0 && offset < 0x40)\n     return true;\n   else if (basereg == SP_REGNO\n \t   && offset >= 0 && offset < 0x80 && (offset & 0x3) == 0)"}, {"sha": "e18e88e9c13c4bed3bd75fdd191bb4edf2672a22", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -221,7 +221,7 @@ enum reg_class\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n #define CDX_REG_P(REGNO)\t\t\t\t\t\t\\\n-  ((REGNO) == 16 || (REGNO) == 17 || (2 <= (REGNO) && (REGNO) <= 7))\n+  ((REGNO) == 16 || (REGNO) == 17 || ((REGNO) >= 2 && (REGNO) <= 7))\n \n /* Tests for various kinds of constants used in the Nios II port.  */\n "}, {"sha": "3ac8fd605c32eeee2cf7698738dbbb94142242b2", "filename": "gcc/config/vax/constraints.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvax%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvax%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fconstraints.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -25,32 +25,32 @@\n (define_constraint \"U06\"\n    \"unsigned 6 bit value (0..63)\"\n    (and (match_code \"const_int\")\n-\t(match_test \"0 <= ival && ival < 64\")))\n+\t(match_test \"ival >= 0 && ival < 64\")))\n \n (define_constraint \"U08\"\n    \"Unsigned 8 bit value\"\n    (and (match_code \"const_int\")\n-\t(match_test \"0 <= ival && ival < 256\")))\n+\t(match_test \"ival >= 0 && ival < 256\")))\n \n (define_constraint \"U16\"\n    \"Unsigned 16 bit value\"\n    (and (match_code \"const_int\")\n-\t(match_test \"0 <= ival && ival < 65536\")))\n+\t(match_test \"ival >= 0 && ival < 65536\")))\n \n (define_constraint \"CN6\"\n    \"negative 6 bit value (-63..-1)\"\n    (and (match_code \"const_int\")\n-\t(match_test \"-63 <= ival && ival < 0\")))\n+\t(match_test \"ival >= -63 && ival < 0\")))\n \n (define_constraint \"S08\"\n    \"signed 8 bit value [old]\"\n    (and (match_code \"const_int\")\n-\t(match_test \"-128 <= ival && ival < 128\")))\n+\t(match_test \"ival >= -128 && ival < 128\")))\n \n (define_constraint \"S16\"\n    \"signed 16 bit value [old]\"\n    (and (match_code \"const_int\")\n-\t(match_test \"-32768 <= ival && ival < 32768\")))\n+\t(match_test \"ival >= -32768 && ival < 32768\")))\n \n (define_constraint \"I\"\n    \"Match a CONST_INT of 0 [old]\""}, {"sha": "f739c6fe9b94db8045358423d1ebbf59a3c7de99", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2029,7 +2029,7 @@ adjacent_operands_p (rtx lo, rtx hi, machine_mode mode)\n   if (REG_P (lo))\n     return mode == SImode && REGNO (lo) + 1 == REGNO (hi);\n   if (CONST_INT_P (lo))\n-    return INTVAL (hi) == 0 && 0 <= INTVAL (lo) && INTVAL (lo) < 64;\n+    return INTVAL (hi) == 0 && UINTVAL (lo) < 64;\n   if (CONST_INT_P (lo))\n     return mode != SImode;\n "}, {"sha": "15e0bebc08554ae72541724aa8418f9cddcf2645", "filename": "gcc/config/visium/constraints.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvisium%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvisium%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fconstraints.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -48,17 +48,17 @@\n (define_constraint \"J\"\n   \"Integer constant in the range 0 .. 65535 (16-bit immediate)\"\n   (and (match_code \"const_int\")\n-       (match_test \"0 <= ival && ival <= 65535\")))\n+       (match_test \"ival >= 0 && ival <= 65535\")))\n \n (define_constraint \"K\"\n   \"Integer constant in the range 1 .. 31 (5-bit immediate)\"\n   (and (match_code \"const_int\")\n-       (match_test \"1 <= ival && ival <= 31\")))\n+       (match_test \"ival >= 1 && ival <= 31\")))\n \n (define_constraint \"L\"\n   \"Integer constant in the range -65535 .. -1 (16-bit negative immediate)\"\n   (and (match_code \"const_int\")\n-       (match_test \"-65535 <= ival && ival <= -1\")))\n+       (match_test \"ival >= -65535 && ival <= -1\")))\n \n (define_constraint \"M\"\n   \"Integer constant -1\""}, {"sha": "e1dd29cb8fba24f544056a0a05d255a048ebfd6e", "filename": "gcc/config/visium/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fpredicates.md?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -25,7 +25,7 @@\n ;; Return true if OP is a constant in the range 1 .. 31.\n (define_predicate \"const_shift_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"1 <= INTVAL (op) && INTVAL (op) <= 31\")))\n+       (match_test \"INTVAL (op) >= 1 && INTVAL (op) <= 31\")))\n \n ;; Return true if OP is either a register or the constant 0.\n (define_predicate \"reg_or_0_operand\""}, {"sha": "58c4e572623bd1244aee5ee3790d164483f49c44", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1922,7 +1922,7 @@ visium_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       int offset_base = offset & ~mask;\n \n       /* Check that all of the words can be accessed.  */\n-      if (4 < size && 0x80 < size + offset - offset_base)\n+      if (size > 4 && 0x80 < size + offset - offset_base)\n \toffset_base = offset & ~0x3f;\n       if (offset_base != 0 && offset_base != offset && (offset & mask1) == 0)\n \t{\n@@ -1968,7 +1968,7 @@ visium_legitimize_reload_address (rtx x, machine_mode mode, int opnum,\n       int offset_base = offset & ~mask;\n \n       /* Check that all of the words can be accessed.  */\n-      if (4 < size && 0x80 < size + offset - offset_base)\n+      if (size > 4 && 0x80 < size + offset - offset_base)\n \toffset_base = offset & ~0x3f;\n \n       if (offset_base && (offset & mask1) == 0)"}, {"sha": "8a66949be12e545f412b3c93a40f0bafbaf8e959", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,12 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* name-lookup.c (get_std_name_hint): Replace Yoda conditions with\n+\ttypical order conditions.\n+\t* class.c (check_bitfield_decl): Likewise.\n+\t* pt.c (convert_template_argument): Likewise.\n+\t* decl.c (duplicate_decls): Likewise.\n+\t* typeck.c (commonparms): Likewise.\n+\n 2017-12-19  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* cp-tree.h: Fix typo in comment."}, {"sha": "d63a65ee7e2de7a88bda31bcf0c8d5fc7927db16", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3276,12 +3276,14 @@ check_bitfield_decl (tree field)\n \t\t   && tree_int_cst_lt (TYPE_SIZE (type), w)))\n \twarning_at (DECL_SOURCE_LOCATION (field), 0,\n \t\t    \"width of %qD exceeds its type\", field);\n-      else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t       && (0 > (compare_tree_int\n-\t\t\t(w, TYPE_PRECISION (ENUM_UNDERLYING_TYPE (type))))))\n-\twarning_at (DECL_SOURCE_LOCATION (field), 0,\n-\t\t    \"%qD is too small to hold all values of %q#T\",\n-\t\t    field, type);\n+      else if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t{\n+\t  int prec = TYPE_PRECISION (ENUM_UNDERLYING_TYPE (type));\n+\t  if (compare_tree_int (w, prec) < 0)\n+\t    warning_at (DECL_SOURCE_LOCATION (field), 0,\n+\t\t\t\"%qD is too small to hold all values of %q#T\",\n+\t\t\tfield, type);\n+\t}\n     }\n \n   if (w != error_mark_node)"}, {"sha": "453a2bd91970855de8ac1a947995be80ad99d750", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1858,8 +1858,8 @@ next_arg:;\n \t\t   t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2), i++)\n \t\tif (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n \t\t  {\n-\t\t    if (1 == simple_cst_equal (TREE_PURPOSE (t1),\n-\t\t\t\t\t       TREE_PURPOSE (t2)))\n+\t\t    if (simple_cst_equal (TREE_PURPOSE (t1),\n+\t\t\t\t\t  TREE_PURPOSE (t2)) == 1)\n \t\t      {\n \t\t\tif (permerror (input_location,\n \t\t\t\t       \"default argument given for parameter \""}, {"sha": "f898c4e7159f6b0644a1ccd93f3717db5048cb66", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -5485,7 +5485,7 @@ get_std_name_hint (const char *name)\n   const size_t num_hints = sizeof (hints) / sizeof (hints[0]);\n   for (size_t i = 0; i < num_hints; i++)\n     {\n-      if (0 == strcmp (name, hints[i].name))\n+      if (strcmp (name, hints[i].name) == 0)\n \treturn hints[i].header;\n     }\n   return NULL;"}, {"sha": "71f45de1dd95ba169a29c9b2cadb4920c3166a04", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -7838,7 +7838,7 @@ convert_template_argument (tree parm,\n \t  if (innertype\n \t      && TREE_CODE (innertype) == REFERENCE_TYPE\n \t      && TREE_CODE (TREE_TYPE (innertype)) == FUNCTION_TYPE\n-              && 0 < TREE_OPERAND_LENGTH (inner)\n+\t      && TREE_OPERAND_LENGTH (inner) > 0\n               && reject_gcc_builtin (TREE_OPERAND (inner, 0)))\n               return error_mark_node;\n         }"}, {"sha": "d6e235eb2b54cedc0d06ce8f334c162d05cb44cc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -214,7 +214,7 @@ commonparms (tree p1, tree p2)\n \t}\n       else\n \t{\n-\t  if (1 != simple_cst_equal (TREE_PURPOSE (p1), TREE_PURPOSE (p2)))\n+\t  if (simple_cst_equal (TREE_PURPOSE (p1), TREE_PURPOSE (p2)) != 1)\n \t    any_change = 1;\n \t  TREE_PURPOSE (n) = TREE_PURPOSE (p2);\n \t}"}, {"sha": "19827138ced9cad2ba4be4ba0785f98c448cb1a0", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3043,7 +3043,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \t  int offs;\n \t  letter = 'G';\n \t  code = N_GSYM;\n-\t  if (NULL != dbxout_common_check (decl, &offs))\n+\t  if (dbxout_common_check (decl, &offs) != NULL)\n \t    {\n \t      letter = 'V';\n \t      addr = 0;\n@@ -3097,7 +3097,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \t    {\n \t      int offs;\n \t      code = N_LCSYM;\n-\t      if (NULL != dbxout_common_check (decl, &offs))\n+\t      if (dbxout_common_check (decl, &offs) != NULL)\n \t        {\n \t\t  addr = 0;\n \t\t  number = offs;\n@@ -3196,7 +3196,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n       int offs;\n       code = N_LCSYM;\n       letter = 'V';\n-      if (NULL == dbxout_common_check (decl, &offs))\n+      if (dbxout_common_check (decl, &offs) == NULL)\n         addr = XEXP (XEXP (home, 0), 0);\n       else\n         {"}, {"sha": "d3f38a93433a54a97ef6d9da44c1b10d2bde41f7", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1866,7 +1866,7 @@ layout::show_ruler (int max_column) const\n     {\n       pp_space (m_pp);\n       for (int column = 1 + m_x_offset; column <= max_column; column++)\n-\tif (0 == column % 10)\n+\tif (column % 10 == 0)\n \t  pp_character (m_pp, '0' + (column / 100) % 10);\n \telse\n \t  pp_space (m_pp);\n@@ -1876,7 +1876,7 @@ layout::show_ruler (int max_column) const\n   /* Tens.  */\n   pp_space (m_pp);\n   for (int column = 1 + m_x_offset; column <= max_column; column++)\n-    if (0 == column % 10)\n+    if (column % 10 == 0)\n       pp_character (m_pp, '0' + (column / 10) % 10);\n     else\n       pp_space (m_pp);"}, {"sha": "256d02b14dded4415f6be024264f3d9a9273fa3a", "filename": "gcc/dojump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1002,8 +1002,8 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n   do_pending_stack_adjust ();\n \n   code = unsignedp ? unsigned_condition (code) : code;\n-  if (0 != (tem = simplify_relational_operation (code, mode, VOIDmode,\n-\t\t\t\t\t\t op0, op1)))\n+  if ((tem = simplify_relational_operation (code, mode, VOIDmode,\n+\t\t\t\t\t    op0, op1)) != 0)\n     {\n       if (CONSTANT_P (tem))\n \t{"}, {"sha": "4a59d6010442a838a09afe95bd627e3056dbcbe2", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -251,7 +251,7 @@ gcc::dump_manager::\n get_dump_file_info_by_switch (const char *swtch) const\n {\n   for (unsigned i = 0; i < m_extra_dump_files_in_use; i++)\n-    if (0 == strcmp (m_extra_dump_files[i].swtch, swtch))\n+    if (strcmp (m_extra_dump_files[i].swtch, swtch) == 0)\n       return &m_extra_dump_files[i];\n \n   /* Not found.  */"}, {"sha": "9ba2a930b6794abc585523debcafb77f7138ee64", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -4047,7 +4047,7 @@ add_insn (rtx_insn *insn)\n {\n   rtx_insn *prev = get_last_insn ();\n   link_insn_into_chain (insn, prev, NULL);\n-  if (NULL == get_insns ())\n+  if (get_insns () == NULL)\n     set_first_insn (insn);\n   set_last_insn (insn);\n }"}, {"sha": "66511eb258186bf5d2c2d77d90d9f428c359d0db", "filename": "gcc/et-forest.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -671,7 +671,7 @@ et_nca (struct et_node *n1, struct et_node *n2)\n       return NULL;\n     }\n \n-  if (0 < o2->depth)\n+  if (o2->depth > 0)\n     {\n       om = o1;\n       mn = o1->depth;\n@@ -743,7 +743,7 @@ et_below (struct et_node *down, struct et_node *up)\n       return false;\n     }\n \n-  if (0 >= d->depth)\n+  if (d->depth <= 0)\n     return false;\n \n   return !d->next || d->next->min + d->depth >= 0;"}, {"sha": "986002ed103f2163c171cd69026c6e96a848a7d8", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -210,8 +210,8 @@ eliminate_constant_term (rtx x, rtx *constptr)\n \n   /* First handle constants appearing at this level explicitly.  */\n   if (CONST_INT_P (XEXP (x, 1))\n-      && 0 != (tem = simplify_binary_operation (PLUS, GET_MODE (x), *constptr,\n-\t\t\t\t\t\tXEXP (x, 1)))\n+      && (tem = simplify_binary_operation (PLUS, GET_MODE (x), *constptr,\n+\t\t\t\t\t   XEXP (x, 1))) != 0\n       && CONST_INT_P (tem))\n     {\n       *constptr = tem;\n@@ -222,8 +222,8 @@ eliminate_constant_term (rtx x, rtx *constptr)\n   x0 = eliminate_constant_term (XEXP (x, 0), &tem);\n   x1 = eliminate_constant_term (XEXP (x, 1), &tem);\n   if ((x1 != XEXP (x, 1) || x0 != XEXP (x, 0))\n-      && 0 != (tem = simplify_binary_operation (PLUS, GET_MODE (x),\n-\t\t\t\t\t\t*constptr, tem))\n+      && (tem = simplify_binary_operation (PLUS, GET_MODE (x),\n+\t\t\t\t\t   *constptr, tem)) != 0\n       && CONST_INT_P (tem))\n     {\n       *constptr = tem;"}, {"sha": "13dda74a7dbca25bd8ab9ae117f00ed43e8c6cc8", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -6123,8 +6123,8 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n \ttarget\n \t  = adjust_address (target,\n \t\t\t    GET_MODE (target) == BLKmode\n-\t\t\t    || 0 != (bitpos\n-\t\t\t\t     % GET_MODE_ALIGNMENT (GET_MODE (target)))\n+\t\t\t    || (bitpos\n+\t\t\t\t% GET_MODE_ALIGNMENT (GET_MODE (target))) != 0\n \t\t\t    ? BLKmode : VOIDmode, bitpos / BITS_PER_UNIT);\n \n \n@@ -10704,8 +10704,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    || (bitsize >= 0\n \t\t&& TYPE_SIZE (TREE_TYPE (exp))\n \t\t&& TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST\n-\t\t&& 0 != compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)),\n-\t\t\t\t\t  bitsize)))\n+\t\t&& compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)),\n+\t\t\t\t     bitsize) != 0))\n \t  {\n \t    machine_mode ext_mode = mode;\n "}, {"sha": "e8954914e165f7efb003091054fe160f7297667f", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -4513,11 +4513,9 @@ leaf_renumber_regs_insn (rtx in_rtx)\n \tbreak;\n \n       case 'E':\n-\tif (NULL != XVEC (in_rtx, i))\n-\t  {\n-\t    for (j = 0; j < XVECLEN (in_rtx, i); j++)\n-\t      leaf_renumber_regs_insn (XVECEXP (in_rtx, i, j));\n-\t  }\n+\tif (XVEC (in_rtx, i) != NULL)\n+\t  for (j = 0; j < XVECLEN (in_rtx, i); j++)\n+\t    leaf_renumber_regs_insn (XVECEXP (in_rtx, i, j));\n \tbreak;\n \n       case 'S':"}, {"sha": "89a9f4007290b341a6d08573a02b74070e6d4ff0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -5409,10 +5409,10 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n   if ((lhs == 0 || rhs == 0 || operand_equal_p (lhs, rhs, 0))\n       && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n \t\t       in1_p, low1, high1)\n-      && 0 != (tem = (build_range_check (loc, type,\n-\t\t\t\t\t lhs != 0 ? lhs\n-\t\t\t\t\t : rhs != 0 ? rhs : integer_zero_node,\n-\t\t\t\t\t in_p, low, high))))\n+      && (tem = (build_range_check (loc, type,\n+\t\t\t\t    lhs != 0 ? lhs\n+\t\t\t\t    : rhs != 0 ? rhs : integer_zero_node,\n+\t\t\t\t    in_p, low, high))) != 0)\n     {\n       if (strict_overflow_p)\n \tfold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_COMPARISON);\n@@ -5442,12 +5442,12 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n \t{\n \t  tree common = save_expr (lhs);\n \n-\t  if (0 != (lhs = build_range_check (loc, type, common,\n-\t\t\t\t\t     or_op ? ! in0_p : in0_p,\n-\t\t\t\t\t     low0, high0))\n-\t      && (0 != (rhs = build_range_check (loc, type, common,\n-\t\t\t\t\t\t or_op ? ! in1_p : in1_p,\n-\t\t\t\t\t\t low1, high1))))\n+\t  if ((lhs = build_range_check (loc, type, common,\n+\t\t\t\t\tor_op ? ! in0_p : in0_p,\n+\t\t\t\t\tlow0, high0)) != 0\n+\t      && (rhs = build_range_check (loc, type, common,\n+\t\t\t\t\t   or_op ? ! in1_p : in1_p,\n+\t\t\t\t\t   low1, high1)) != 0)\n \t    {\n \t      if (strict_overflow_p)\n \t\tfold_overflow_warning (warnmsg,\n@@ -6146,10 +6146,9 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n       if ((t2 = fold_convert (TREE_TYPE (op0), c)) != 0\n \t  && TREE_CODE (t2) == INTEGER_CST\n \t  && !TREE_OVERFLOW (t2)\n-\t  && (0 != (t1 = extract_muldiv (op0, t2, code,\n-\t\t\t\t\t code == MULT_EXPR\n-\t\t\t\t\t ? ctype : NULL_TREE,\n-\t\t\t\t\t strict_overflow_p))))\n+\t  && (t1 = extract_muldiv (op0, t2, code,\n+\t\t\t\t   code == MULT_EXPR ? ctype : NULL_TREE,\n+\t\t\t\t   strict_overflow_p)) != 0)\n \treturn t1;\n       break;\n \n@@ -6217,10 +6216,9 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t     so check for it explicitly here.  */\n \t  && wi::gtu_p (TYPE_PRECISION (TREE_TYPE (size_one_node)),\n \t\t\twi::to_wide (op1))\n-\t  && 0 != (t1 = fold_convert (ctype,\n-\t\t\t\t      const_binop (LSHIFT_EXPR,\n-\t\t\t\t\t\t   size_one_node,\n-\t\t\t\t\t\t   op1)))\n+\t  && (t1 = fold_convert (ctype,\n+\t\t\t\t const_binop (LSHIFT_EXPR, size_one_node,\n+\t\t\t\t\t      op1))) != 0\n \t  && !TREE_OVERFLOW (t1))\n \treturn extract_muldiv (build2 (tcode == LSHIFT_EXPR\n \t\t\t\t       ? MULT_EXPR : FLOOR_DIV_EXPR,\n@@ -8040,7 +8038,7 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n     }\n \n   /* See if we can build a range comparison.  */\n-  if (0 != (tem = fold_range_test (loc, code, type, op0, op1)))\n+  if ((tem = fold_range_test (loc, code, type, op0, op1)) != 0)\n     return tem;\n \n   if ((code == TRUTH_ANDIF_EXPR && TREE_CODE (arg0) == TRUTH_ORIF_EXPR)\n@@ -8063,8 +8061,8 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n      lhs is another similar operation, try to merge its rhs with our\n      rhs.  Then try to merge our lhs and rhs.  */\n   if (TREE_CODE (arg0) == code\n-      && 0 != (tem = fold_truth_andor_1 (loc, code, type,\n-\t\t\t\t\t TREE_OPERAND (arg0, 1), arg1)))\n+      && (tem = fold_truth_andor_1 (loc, code, type,\n+\t\t\t\t    TREE_OPERAND (arg0, 1), arg1)) != 0)\n     return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), tem);\n \n   if ((tem = fold_truth_andor_1 (loc, code, type, arg0, arg1)) != 0)\n@@ -9526,8 +9524,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t\tSTRIP_NOPS (tree110);\n \t\tSTRIP_NOPS (tree111);\n \t\tif (TREE_CODE (tree110) == INTEGER_CST\n-\t\t    && 0 == compare_tree_int (tree110,\n-\t\t\t\t\t      element_precision (rtype))\n+\t\t    && compare_tree_int (tree110,\n+\t\t\t\t\t element_precision (rtype)) == 0\n \t\t    && operand_equal_p (tree01, tree111, 0))\n \t\t  {\n \t\t    tem = build2_loc (loc, (code0 == LSHIFT_EXPR\n@@ -9548,8 +9546,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t\tSTRIP_NOPS (tree111);\n \t\tif (TREE_CODE (tree110) == NEGATE_EXPR\n \t\t    && TREE_CODE (tree111) == INTEGER_CST\n-\t\t    && 0 == compare_tree_int (tree111,\n-\t\t\t\t\t      element_precision (rtype) - 1)\n+\t\t    && compare_tree_int (tree111,\n+\t\t\t\t\t element_precision (rtype) - 1) == 0\n \t\t    && operand_equal_p (tree01, TREE_OPERAND (tree110, 0), 0))\n \t\t  {\n \t\t    tem = build2_loc (loc, (code0 == LSHIFT_EXPR\n@@ -9657,12 +9655,12 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t  /* Only do something if we found more than two objects.  Otherwise,\n \t     nothing has changed and we risk infinite recursion.  */\n \t  if (ok\n-\t      && (2 < ((var0 != 0) + (var1 != 0)\n-\t\t       + (minus_var0 != 0) + (minus_var1 != 0)\n-\t\t       + (con0 != 0) + (con1 != 0)\n-\t\t       + (minus_con0 != 0) + (minus_con1 != 0)\n-\t\t       + (lit0 != 0) + (lit1 != 0)\n-\t\t       + (minus_lit0 != 0) + (minus_lit1 != 0))))\n+\t      && ((var0 != 0) + (var1 != 0)\n+\t\t  + (minus_var0 != 0) + (minus_var1 != 0)\n+\t\t  + (con0 != 0) + (con1 != 0)\n+\t\t  + (minus_con0 != 0) + (minus_con1 != 0)\n+\t\t  + (lit0 != 0) + (lit1 != 0)\n+\t\t  + (minus_lit0 != 0) + (minus_lit1 != 0)) > 2)\n \t    {\n \t      var0 = associate_trees (loc, var0, var1, code, atype);\n \t      minus_var0 = associate_trees (loc, minus_var0, minus_var1,\n@@ -9876,8 +9874,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \n \t  strict_overflow_p = false;\n \t  if (TREE_CODE (arg1) == INTEGER_CST\n-\t      && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n-\t\t\t\t\t     &strict_overflow_p)))\n+\t      && (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n+\t\t\t\t\t&strict_overflow_p)) != 0)\n \t    {\n \t      if (strict_overflow_p)\n \t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n@@ -10310,8 +10308,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \n       strict_overflow_p = false;\n       if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n-\t\t\t\t\t &strict_overflow_p)))\n+\t  && (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n+\t\t\t\t    &strict_overflow_p)) != 0)\n \t{\n \t  if (strict_overflow_p)\n \t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n@@ -10328,8 +10326,8 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n     case TRUNC_MOD_EXPR:\n       strict_overflow_p = false;\n       if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n-\t\t\t\t\t &strict_overflow_p)))\n+\t  && (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n+\t\t\t\t    &strict_overflow_p)) != 0)\n \t{\n \t  if (strict_overflow_p)\n \t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n@@ -10982,7 +10980,7 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,\n \t  && TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (arg0) == ABS_EXPR\n \t  && ! TREE_SIDE_EFFECTS (arg0)\n-\t  && (0 != (tem = negate_expr (arg1)))\n+\t  && (tem = negate_expr (arg1)) != 0\n \t  && TREE_CODE (tem) == INTEGER_CST\n \t  && !TREE_OVERFLOW (tem))\n \treturn fold_build2_loc (loc, TRUTH_ANDIF_EXPR, type,\n@@ -12491,10 +12489,9 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n \t     so check for it explicitly here.  */\n \t  if (wi::gtu_p (TYPE_PRECISION (TREE_TYPE (size_one_node)),\n \t\t\t wi::to_wide (op1))\n-\t      && 0 != (t1 = fold_convert (type,\n-\t\t\t\t\t  const_binop (LSHIFT_EXPR,\n-\t\t\t\t\t\t       size_one_node,\n-\t\t\t\t\t\t       op1)))\n+\t      && (t1 = fold_convert (type,\n+\t\t\t\t     const_binop (LSHIFT_EXPR, size_one_node,\n+\t\t\t\t\t\t  op1))) != 0\n \t      && !TREE_OVERFLOW (t1))\n \t    return multiple_of_p (type, t1, bottom);\n \t}"}, {"sha": "a601cfaf0cfed4bd1c891b746259887e9e75e4a8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,10 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* scanner.c (preprocessor_line): Replace Yoda conditions with typical\n+\torder conditions.\n+\t* dependency.c (check_section_vs_section): Likewise.\n+\t* trans-array.c (gfc_conv_expr_descriptor): Likewise.\n+\n 2017-12-17  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* decl.c (gfc_match_implicit_none): Use GFC_STD_F2018 instead of"}, {"sha": "29161d12fdfbd998034ed77eaaf6b0756434ee2b", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1431,17 +1431,17 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n   r_stride = r_ar->stride[n];\n \n   /* If l_start is NULL take it from array specifier.  */\n-  if (NULL == l_start && IS_ARRAY_EXPLICIT (l_ar->as))\n+  if (l_start == NULL && IS_ARRAY_EXPLICIT (l_ar->as))\n     l_start = l_ar->as->lower[n];\n   /* If l_end is NULL take it from array specifier.  */\n-  if (NULL == l_end && IS_ARRAY_EXPLICIT (l_ar->as))\n+  if (l_end == NULL && IS_ARRAY_EXPLICIT (l_ar->as))\n     l_end = l_ar->as->upper[n];\n \n   /* If r_start is NULL take it from array specifier.  */\n-  if (NULL == r_start && IS_ARRAY_EXPLICIT (r_ar->as))\n+  if (r_start == NULL && IS_ARRAY_EXPLICIT (r_ar->as))\n     r_start = r_ar->as->lower[n];\n   /* If r_end is NULL take it from array specifier.  */\n-  if (NULL == r_end && IS_ARRAY_EXPLICIT (r_ar->as))\n+  if (r_end == NULL && IS_ARRAY_EXPLICIT (r_ar->as))\n     r_end = r_ar->as->upper[n];\n \n   /* Determine whether the l_stride is positive or negative.  */"}, {"sha": "4a0792d8cfdbdd24d8527602b09c622e90d9b161", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2057,7 +2057,7 @@ preprocessor_line (gfc_char_t *c)\n       c++;\n       i = wide_atoi (c);\n \n-      if (1 <= i && i <= 4)\n+      if (i >= 1 && i <= 4)\n \tflag[i] = true;\n     }\n "}, {"sha": "1b6e2159ae1c759b2b16f28b619801a5d40b1933", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -7003,7 +7003,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n   /* Special case: TRANSPOSE which needs no temporary.  */\n   while (expr->expr_type == EXPR_FUNCTION && expr->value.function.isym\n-      && NULL != (arg = gfc_get_noncopying_intrinsic_argument (expr)))\n+\t && (arg = gfc_get_noncopying_intrinsic_argument (expr)) != NULL)\n     {\n       /* This is a call to transpose which has already been handled by the\n \t scalarizer, so that we just need to get its argument's descriptor.  */"}, {"sha": "092b2852763ebbdacc4e4828ddd0de87028a4c23", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1136,7 +1136,7 @@ insert_expr_in_table (rtx x, machine_mode mode, rtx_insn *insn,\n   cur_expr = table->table[hash];\n   found = 0;\n \n-  while (cur_expr && 0 == (found = expr_equiv_p (cur_expr->expr, x)))\n+  while (cur_expr && (found = expr_equiv_p (cur_expr->expr, x)) == 0)\n     {\n       /* If the expression isn't found, save a pointer to the end of\n \t the list.  */"}, {"sha": "be5a51d058bb008872e172bb38e9e3cbb8747eca", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -948,9 +948,9 @@ type (options_p *optsp, bool nested)\n \t\tadvance ();\n \t\tconst char *basename = require (ID);\n \t\t/* This may be either an access specifier, or the base name.  */\n-\t\tif (0 == strcmp (basename, \"public\")\n-\t\t    || 0 == strcmp (basename, \"protected\")\n-\t\t    || 0 == strcmp (basename, \"private\"))\n+\t\tif (strcmp (basename, \"public\") == 0\n+\t\t    || strcmp (basename, \"protected\") == 0\n+\t\t    || strcmp (basename, \"private\") == 0)\n \t\t  basename = require (ID);\n \t\tbase_class = find_structure (basename, TYPE_STRUCT);\n \t\tif (!base_class)"}, {"sha": "eca66161c898d59ee9db4c6020a965aa863a81d8", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -671,7 +671,7 @@ type_for_name (const char *s)\n          extern GTY(()) gcc::some_type *some_ptr;\n      where the autogenerated functions will refer to simply \"some_type\",\n      where they can be resolved into their namespace.  */\n-  if (0 == strncmp (s, \"gcc::\", 5))\n+  if (strncmp (s, \"gcc::\", 5) == 0)\n     s += 5;\n \n   for (p = typedefs; p != NULL; p = p->next)"}, {"sha": "7e6859c1358c818fb75733c4b17b1c9108a77de5", "filename": "gcc/genhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgenhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgenhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenhooks.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -323,7 +323,7 @@ emit_init_macros (const char *docname)\n \t\t}\n \t      continue;\n \t    }\n-\t  if (0 == print_nest)\n+\t  if (print_nest == 0)\n \t    {\n \t      /* Output default definitions of target hooks.  */\n \t      printf (\"#ifndef %s\\n#define %s %s\\n#endif\\n\","}, {"sha": "eddc20e2ac4e1006cd910d8b9e3c5fdefd720745", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2854,7 +2854,7 @@ format_directive (const sprintf_dom_walker::call_info &info,\n \n   if (!warned\n       /* Only warn at level 2.  */\n-      && 1 < warn_level\n+      && warn_level > 1\n       && (!minunder4k\n \t  || (!maxunder4k && fmtres.range.max < HOST_WIDE_INT_MAX)))\n     {\n@@ -2902,7 +2902,7 @@ format_directive (const sprintf_dom_walker::call_info &info,\n       /* Warn for the likely output size at level 1.  */\n       && (likelyximax\n \t  /* But only warn for the maximum at level 2.  */\n-\t  || (1 < warn_level\n+\t  || (warn_level > 1\n \t      && maxximax\n \t      && fmtres.range.max < HOST_WIDE_INT_MAX)))\n     {"}, {"sha": "6c7651a409611ef17ddacbb8047950229d606b6e", "filename": "gcc/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1117,7 +1117,7 @@ dump_location_info (FILE *stream)\n \t  expanded_location exploc\n \t    = linemap_expand_location (line_table, map, loc);\n \n-\t  if (0 == exploc.column)\n+\t  if (exploc.column == 0)\n \t    {\n \t      /* Beginning of a new source line: draw the line.  */\n "}, {"sha": "63c00d0aeed01027b1140b18df18c3acf3d0348d", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2756,8 +2756,8 @@ setup_min_max_allocno_live_range_point (void)\n #ifdef ENABLE_IRA_CHECKING\n   FOR_EACH_OBJECT (obj, oi)\n     {\n-      if ((0 <= OBJECT_MIN (obj) && OBJECT_MIN (obj) <= ira_max_point)\n-\t  && (0 <= OBJECT_MAX (obj) && OBJECT_MAX (obj) <= ira_max_point))\n+      if ((OBJECT_MIN (obj) >= 0 && OBJECT_MIN (obj) <= ira_max_point)\n+\t  && (OBJECT_MAX (obj) >= 0 && OBJECT_MAX (obj) <= ira_max_point))\n \tcontinue;\n       gcc_unreachable ();\n     }"}, {"sha": "eb2f793279e0ae8f0446691afd88647afc80e3f9", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1,3 +1,17 @@\n+2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* jit-playback.c (get_type, playback::compile_to_file::copy_file,\n+\tplayback::context::acquire_mutex): Replace Yoda conditions with\n+\ttypical order conditions.\n+\t* libgccjit.c (gcc_jit_context_new_struct_type,\n+\tgcc_jit_struct_set_fields, gcc_jit_context_new_union_type,\n+\tgcc_jit_context_new_function, gcc_jit_timer_pop): Likewise.\n+\t* jit-builtins.c (matches_builtin): Likewise.\n+\t* jit-recording.c (recording::compound_type::set_fields,\n+\trecording::fields::write_reproducer, recording::rvalue::set_scope,\n+\trecording::function::validate): Likewise.\n+\t* jit-logging.c (logger::decref): Likewise.\n+\n 2017-11-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* jit-recording.c"}, {"sha": "ee37495e908f5e8acab0c2082da2e314a31253b4", "filename": "gcc/jit/jit-builtins.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -76,24 +76,20 @@ matches_builtin (const char *in_name,\n   if (debug)\n     fprintf (stderr, \"seen builtin: %s\\n\", bd.name);\n \n-  if (0 == strcmp (bd.name, in_name))\n-    {\n-      return true;\n-    }\n+  if (strcmp (bd.name, in_name) == 0)\n+    return true;\n \n   if (bd.both_p)\n     {\n       /* Then the macros in builtins.def gave a \"__builtin_\"\n \t prefix to bd.name, but we should also recognize the form\n \t without the prefix.  */\n-      gcc_assert (0 == strncmp (bd.name, prefix, prefix_len));\n+      gcc_assert (strncmp (bd.name, prefix, prefix_len) == 0);\n       if (debug)\n \tfprintf (stderr, \"testing without prefix as: %s\\n\",\n \t\t bd.name + prefix_len);\n-      if (0 == strcmp (bd.name + prefix_len, in_name))\n-\t{\n-\t  return true;\n-\t}\n+      if (strcmp (bd.name + prefix_len, in_name) == 0)\n+\treturn true;\n     }\n \n   return false;"}, {"sha": "779b756abcc9e2e61966514a42abfb865868ef89", "filename": "gcc/jit/jit-logging.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-logging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-logging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-logging.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -79,7 +79,7 @@ logger::decref (const char *reason)\n   if (m_log_refcount_changes)\n     log (\"%s: reason: %s refcount now %i\",\n \t __PRETTY_FUNCTION__, reason, m_refcount);\n-  if (0 == m_refcount)\n+  if (m_refcount == 0)\n     delete this;\n }\n "}, {"sha": "43b0ec9c7d5ee3a7730e56c86c94cdb5bb22719d", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -211,10 +211,9 @@ playback::context::\n get_type (enum gcc_jit_types type_)\n {\n   tree type_node = get_tree_node_for_type (type_);\n-  if (NULL == type_node)\n+  if (type_node == NULL)\n     {\n-      add_error (NULL,\n-\t\t \"unrecognized (enum gcc_jit_types) value: %i\", type_);\n+      add_error (NULL, \"unrecognized (enum gcc_jit_types) value: %i\", type_);\n       return NULL;\n     }\n \n@@ -2049,7 +2048,7 @@ playback::compile_to_file::copy_file (const char *src_path,\n   /* Use stat on the filedescriptor to get the mode,\n      so that we can copy it over (in particular, the\n      \"executable\" bits).  */\n-  if (-1 == fstat (fileno (f_in), &stat_buf))\n+  if (fstat (fileno (f_in), &stat_buf) == -1)\n     {\n       add_error (NULL,\n \t\t \"unable to fstat %s: %s\",\n@@ -2113,7 +2112,7 @@ playback::compile_to_file::copy_file (const char *src_path,\n \n   /* Set the permissions of the copy to those of the original file,\n      in particular the \"executable\" bits.  */\n-  if (-1 == fchmod (fileno (f_out), stat_buf.st_mode))\n+  if (fchmod (fileno (f_out), stat_buf.st_mode) == -1)\n     add_error (NULL,\n \t       \"error setting mode of %s: %s\",\n \t       dst_path,\n@@ -2139,7 +2138,7 @@ playback::context::acquire_mutex ()\n   /* Acquire the big GCC mutex. */\n   JIT_LOG_SCOPE (get_logger ());\n   pthread_mutex_lock (&jit_mutex);\n-  gcc_assert (NULL == active_playback_ctxt);\n+  gcc_assert (active_playback_ctxt == NULL);\n   active_playback_ctxt = this;\n }\n "}, {"sha": "f2cfcfd50febdd3c17a24f581acdf007c8f84ea0", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2987,7 +2987,7 @@ recording::compound_type::set_fields (location *loc,\n \t\t\t\t      field **field_array)\n {\n   m_loc = loc;\n-  gcc_assert (NULL == m_fields);\n+  gcc_assert (m_fields == NULL);\n \n   m_fields = new fields (this, num_fields, field_array);\n   m_ctxt->record (m_fields);\n@@ -3182,7 +3182,7 @@ void\n recording::fields::write_reproducer (reproducer &r)\n {\n   if (m_struct_or_union)\n-    if (NULL == m_struct_or_union->dyn_cast_struct ())\n+    if (m_struct_or_union->dyn_cast_struct () == NULL)\n       /* We have a union; the fields have already been written by\n \t union::write_reproducer.  */\n       return;\n@@ -3370,7 +3370,7 @@ void\n recording::rvalue::set_scope (function *scope)\n {\n   gcc_assert (scope);\n-  gcc_assert (NULL == m_scope);\n+  gcc_assert (m_scope == NULL);\n   m_scope = scope;\n }\n \n@@ -3750,7 +3750,7 @@ recording::function::validate ()\n   /* Complain about empty functions with non-void return type.  */\n   if (m_kind != GCC_JIT_FUNCTION_IMPORTED\n       && m_return_type != m_ctxt->get_type (GCC_JIT_TYPE_VOID))\n-    if (0 == m_blocks.length ())\n+    if (m_blocks.length () == 0)\n       m_ctxt->add_error (m_loc,\n \t\t\t \"function %s returns non-void (type: %s)\"\n \t\t\t \" but has no blocks\",\n@@ -3771,7 +3771,7 @@ recording::function::validate ()\n   /* Check that all blocks are reachable.  */\n   if (!m_ctxt->get_inner_bool_option\n         (INNER_BOOL_OPTION_ALLOW_UNREACHABLE_BLOCKS)\n-      && m_blocks.length () > 0 && 0 == num_invalid_blocks)\n+      && m_blocks.length () > 0 && num_invalid_blocks == 0)\n     {\n       /* Iteratively walk the graph of blocks, marking their \"m_is_reachable\"\n \t flag, starting at the initial block.  */"}, {"sha": "fa8ef35b5200e75a0e13f37609c92e8679eee953", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -592,7 +592,7 @@ gcc_jit_context_new_struct_type (gcc_jit_context *ctxt,\n     {\n       RETURN_NULL_IF_FAIL (fields[i], ctxt, loc, \"NULL field ptr\");\n       RETURN_NULL_IF_FAIL_PRINTF2 (\n-\tNULL == fields[i]->get_container (),\n+\tfields[i]->get_container () == NULL,\n \tctxt, loc,\n \t\"%s is already a field of %s\",\n \tfields[i]->get_debug_string (),\n@@ -657,7 +657,7 @@ gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n   JIT_LOG_FUNC (ctxt->get_logger ());\n   /* LOC can be NULL.  */\n   RETURN_IF_FAIL_PRINTF1 (\n-    NULL == struct_type->get_fields (), ctxt, loc,\n+    struct_type->get_fields () == NULL, ctxt, loc,\n     \"%s already has had fields set\",\n     struct_type->get_debug_string ());\n   if (num_fields)\n@@ -671,7 +671,7 @@ gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n \tstruct_type->get_debug_string (),\n \ti);\n       RETURN_IF_FAIL_PRINTF2 (\n-\tNULL == fields[i]->get_container (),\n+\tfields[i]->get_container () == NULL,\n \tctxt, loc,\n \t\"%s is already a field of %s\",\n \tfields[i]->get_debug_string (),\n@@ -706,7 +706,7 @@ gcc_jit_context_new_union_type (gcc_jit_context *ctxt,\n     {\n       RETURN_NULL_IF_FAIL (fields[i], ctxt, loc, \"NULL field ptr\");\n       RETURN_NULL_IF_FAIL_PRINTF2 (\n-\tNULL == fields[i]->get_container (),\n+\tfields[i]->get_container () == NULL,\n \tctxt, loc,\n \t\"%s is already a field of %s\",\n \tfields[i]->get_debug_string (),\n@@ -880,7 +880,7 @@ gcc_jit_context_new_function (gcc_jit_context *ctxt,\n \tctxt, loc,\n \t\"NULL parameter %i creating function %s\", i, name);\n       RETURN_NULL_IF_FAIL_PRINTF5 (\n-\t(NULL == params[i]->get_scope ()),\n+\tparams[i]->get_scope () == NULL,\n \tctxt, loc,\n \t\"parameter %i \\\"%s\\\"\"\n \t\" (type: %s)\"\n@@ -2925,7 +2925,7 @@ gcc_jit_timer_pop (gcc_jit_timer *timer,\n \t item_name);\n \n       RETURN_IF_FAIL_PRINTF2\n-\t(0 == strcmp (item_name, top_item_name), NULL, NULL,\n+\t(strcmp (item_name, top_item_name) == 0, NULL, NULL,\n \t \"mismatching item_name:\"\n \t \" top of timing stack: \\\"%s\\\",\"\n \t \" attempting to pop: \\\"%s\\\"\","}, {"sha": "ad8b0187e3365b6c5f080dc6ff6a52c40041694c", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1584,7 +1584,7 @@ pass_manager::pass_manager (context *ctxt)\n \n #define NEXT_PASS(PASS, NUM) \\\n   do { \\\n-    gcc_assert (NULL == PASS ## _ ## NUM); \\\n+    gcc_assert (PASS ## _ ## NUM == NULL); \\\n     if ((NUM) == 1)                              \\\n       PASS ## _1 = make_##PASS (m_ctxt);          \\\n     else                                         \\"}, {"sha": "68788d7ddf4521e19cd0b83567c8ce7e8ec67ce3", "filename": "gcc/poly-int.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1288,7 +1288,7 @@ maybe_ne (const Ca &a, const poly_int_pod<N, Cb> &b)\n {\n   if (N >= 2)\n     for (unsigned int i = 1; i < N; i++)\n-      if (0 != b.coeffs[i])\n+      if (b.coeffs[i] != 0)\n \treturn true;\n   return a != b.coeffs[0];\n }\n@@ -1337,7 +1337,7 @@ maybe_le (const Ca &a, const poly_int_pod<N, Cb> &b)\n {\n   if (N >= 2)\n     for (unsigned int i = 1; i < N; i++)\n-      if (0 < b.coeffs[i])\n+      if (b.coeffs[i] > 0)\n \treturn true;\n   return a <= b.coeffs[0];\n }\n@@ -1379,7 +1379,7 @@ maybe_lt (const Ca &a, const poly_int_pod<N, Cb> &b)\n {\n   if (N >= 2)\n     for (unsigned int i = 1; i < N; i++)\n-      if (0 < b.coeffs[i])\n+      if (b.coeffs[i] > 0)\n \treturn true;\n   return a < b.coeffs[0];\n }"}, {"sha": "bff9dc578d861570f6b1048bb2b5aab584de1f82", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -346,7 +346,7 @@ rtx_writer::print_rtx_operand_codes_E_and_V (const_rtx in_rtx, int idx)\n       m_sawclose = 0;\n     }\n   fputs (\" [\", m_outfile);\n-  if (NULL != XVEC (in_rtx, idx))\n+  if (XVEC (in_rtx, idx) != NULL)\n     {\n       m_indent += 2;\n       if (XVECLEN (in_rtx, idx))"}, {"sha": "8ddf0ecaabc4befc49bcb9a71b43c6870bc8df7e", "filename": "gcc/read-rtl-function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -321,7 +321,7 @@ static int\n parse_note_insn_name (const char *string)\n {\n   for (int i = 0; i < NOTE_INSN_MAX; i++)\n-    if (0 == strcmp (string, GET_NOTE_INSN_NAME (i)))\n+    if (strcmp (string, GET_NOTE_INSN_NAME (i)) == 0)\n       return i;\n   fatal_with_file_and_line (\"unrecognized NOTE_INSN name: `%s'\", string);\n }\n@@ -1079,7 +1079,7 @@ function_reader::read_rtx_operand_r (rtx x)\n \t \"orig:%i\", ORIGINAL_REGNO (rtx).\n \t Consume it, we don't set ORIGINAL_REGNO, since we can\n \t get that from the 2nd copy later.  */\n-      if (0 == strncmp (desc, \"orig:\", 5))\n+      if (strncmp (desc, \"orig:\", 5) == 0)\n \t{\n \t  expect_original_regno = true;\n \t  desc_start += 5;\n@@ -1312,7 +1312,7 @@ function_reader::parse_mem_expr (const char *desc)\n {\n   tree fndecl = cfun->decl;\n \n-  if (0 == strcmp (desc, \"<retval>\"))\n+  if (strcmp (desc, \"<retval>\") == 0)\n     return DECL_RESULT (fndecl);\n \n   tree param = find_param_by_name (fndecl, desc);"}, {"sha": "b1ef52b9a3d50d5a187eb0a117401e684124c45c", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1229,7 +1229,7 @@ static int\n parse_reg_note_name (const char *string)\n {\n   for (int i = 0; i < REG_NOTE_MAX; i++)\n-    if (0 == strcmp (string, GET_REG_NOTE_NAME (i)))\n+    if (strcmp (string, GET_REG_NOTE_NAME (i)) == 0)\n       return i;\n   fatal_with_file_and_line (\"unrecognized REG_NOTE name: `%s'\", string);\n }"}, {"sha": "c6664955fe9374ab1c8bdbf78dc8f788b5915d0d", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -1532,8 +1532,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t value for the incoming operand (same as outgoing one).  */\n       if (rld[i].reg_rtx == out\n \t  && (REG_P (in) || CONSTANT_P (in))\n-\t  && 0 != find_equiv_reg (in, this_insn, NO_REGS, REGNO (out),\n-\t\t\t\t  static_reload_reg_p, i, inmode))\n+\t  && find_equiv_reg (in, this_insn, NO_REGS, REGNO (out),\n+\t\t\t     static_reload_reg_p, i, inmode) != 0)\n \trld[i].in = out;\n     }\n \n@@ -6750,9 +6750,8 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t\t\t      && CONST_DOUBLE_AS_FLOAT_P (XEXP (tem, 0))\n \t\t\t      && SCALAR_FLOAT_MODE_P (GET_MODE (XEXP (tem, 0)))\n \t\t\t      && CONST_INT_P (goal)\n-\t\t\t      && 0 != (goaltry\n-\t\t\t\t       = operand_subword (XEXP (tem, 0), 0, 0,\n-\t\t\t\t\t\t\t  VOIDmode))\n+\t\t\t      && (goaltry = operand_subword (XEXP (tem, 0), 0,\n+\t\t\t\t\t\t\t     0, VOIDmode)) != 0\n \t\t\t      && rtx_equal_p (goal, goaltry)\n \t\t\t      && (valtry\n \t\t\t\t  = operand_subword (SET_DEST (pat), 0, 0,\n@@ -6764,8 +6763,8 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t\t      && CONST_DOUBLE_AS_FLOAT_P (XEXP (tem, 0))\n \t\t      && SCALAR_FLOAT_MODE_P (GET_MODE (XEXP (tem, 0)))\n \t\t      && CONST_INT_P (goal)\n-\t\t      && 0 != (goaltry = operand_subword (XEXP (tem, 0), 1, 0,\n-\t\t\t\t\t\t\t  VOIDmode))\n+\t\t      && (goaltry = operand_subword (XEXP (tem, 0), 1, 0,\n+\t\t\t\t\t\t     VOIDmode)) != 0\n \t\t      && rtx_equal_p (goal, goaltry)\n \t\t      && (valtry\n \t\t\t  = operand_subword (SET_DEST (pat), 1, 0, VOIDmode))"}, {"sha": "1c94f303d05dbcbc43af1074c5edd89b987ce8a6", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -8006,8 +8006,8 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n   /* Likewise for a SUBREG of an operand that dies.  */\n   else if (GET_CODE (old) == SUBREG\n \t   && REG_P (SUBREG_REG (old))\n-\t   && 0 != (note = find_reg_note (insn, REG_UNUSED,\n-\t\t\t\t\t  SUBREG_REG (old))))\n+\t   && (note = find_reg_note (insn, REG_UNUSED,\n+\t\t\t\t     SUBREG_REG (old))) != 0)\n     {\n       XEXP (note, 0) = gen_lowpart_common (GET_MODE (old), reg_rtx);\n       return;"}, {"sha": "96778addce52e3527fc6892983bb30907bbcbd0c", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3205,7 +3205,7 @@ relax_delay_slots (rtx_insn *first)\n \t  && (other = prev_active_insn (insn)) != 0\n \t  && any_condjump_p (other)\n \t  && no_labels_between_p (other, insn)\n-\t  && 0 > mostly_true_jump (other))\n+\t  && mostly_true_jump (other) < 0)\n \t{\n \t  rtx other_target = JUMP_LABEL (other);\n \t  target_label = JUMP_LABEL (insn);"}, {"sha": "172c6ecfede0328626f29c3cd720a44843dc1b4a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -3258,10 +3258,10 @@ sched_rgn_init (bool single_blocks_p)\n \tfree_dominance_info (CDI_DOMINATORS);\n     }\n \n-  gcc_assert (0 < nr_regions && nr_regions <= n_basic_blocks_for_fn (cfun));\n+  gcc_assert (nr_regions > 0 && nr_regions <= n_basic_blocks_for_fn (cfun));\n \n-  RGN_BLOCKS (nr_regions) = (RGN_BLOCKS (nr_regions - 1) +\n-\t\t\t     RGN_NR_BLOCKS (nr_regions - 1));\n+  RGN_BLOCKS (nr_regions) = (RGN_BLOCKS (nr_regions - 1)\n+\t\t\t     + RGN_NR_BLOCKS (nr_regions - 1));\n   nr_regions_initial = nr_regions;\n }\n "}, {"sha": "c1be013655158b27bf80ca2cb92023913a2a66d9", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -672,7 +672,7 @@ extract_new_fences_from (flist_t old_fences, flist_tail_t new_fences,\n     {\n       int seqno = INSN_SEQNO (succ);\n \n-      if (0 < seqno && seqno <= orig_max_seqno\n+      if (seqno > 0 && seqno <= orig_max_seqno\n           && (pipelining_p || INSN_SCHED_TIMES (succ) <= 0))\n         {\n           bool b = (in_same_ebb_p (insn, succ)"}, {"sha": "06e451ca2687f3344a2025d05c46a7fbd367c3c9", "filename": "gcc/selftest.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -79,7 +79,7 @@ assert_streq (const location &loc,\n   if (val_actual == NULL)\n     fail_formatted (loc, \"ASSERT_STREQ (%s, %s) expected=\\\"%s\\\" actual=NULL\",\n \t\t    desc_expected, desc_actual, val_expected);\n-  if (0 == strcmp (val_expected, val_actual))\n+  if (strcmp (val_expected, val_actual) == 0)\n     pass (loc, \"ASSERT_STREQ\");\n   else\n     fail_formatted (loc, \"ASSERT_STREQ (%s, %s) expected=\\\"%s\\\" actual=\\\"%s\\\"\","}, {"sha": "a6e3cd5507a8f77660765fadd5184c393b0228ae", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -400,8 +400,8 @@ simplify_gen_ternary (enum rtx_code code, machine_mode mode,\n   rtx tem;\n \n   /* If this simplifies, use it.  */\n-  if (0 != (tem = simplify_ternary_operation (code, mode, op0_mode,\n-\t\t\t\t\t      op0, op1, op2)))\n+  if ((tem = simplify_ternary_operation (code, mode, op0_mode,\n+\t\t\t\t\t op0, op1, op2)) != 0)\n     return tem;\n \n   return gen_rtx_fmt_eee (code, mode, op0, op1, op2);\n@@ -416,8 +416,8 @@ simplify_gen_relational (enum rtx_code code, machine_mode mode,\n {\n   rtx tem;\n \n-  if (0 != (tem = simplify_relational_operation (code, mode, cmp_mode,\n-\t\t\t\t\t\t op0, op1)))\n+  if ((tem = simplify_relational_operation (code, mode, cmp_mode,\n+\t\t\t\t\t    op0, op1)) != 0)\n     return tem;\n \n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n@@ -5148,7 +5148,7 @@ simplify_const_relational_operation (enum rtx_code code,\n       && (code == EQ || code == NE)\n       && ! ((REG_P (op0) || CONST_INT_P (trueop0))\n \t    && (REG_P (op1) || CONST_INT_P (trueop1)))\n-      && 0 != (tem = simplify_binary_operation (MINUS, mode, op0, op1))\n+      && (tem = simplify_binary_operation (MINUS, mode, op0, op1)) != 0\n       /* We cannot do this if tem is a nonzero address.  */\n       && ! nonzero_address_p (tem))\n     return simplify_const_relational_operation (signed_condition (code),"}, {"sha": "a8cbea9d634b6aa84681159925387ce97f0366d7", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01512446fea2a4564297db1b6ff7632370bd6728/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=01512446fea2a4564297db1b6ff7632370bd6728", "patch": "@@ -2665,7 +2665,7 @@ conflict_fn (unsigned n, ...)\n   conflict_function *ret = XCNEW (conflict_function);\n   va_list ap;\n \n-  gcc_assert (0 < n && n <= MAX_DIM);\n+  gcc_assert (n > 0 && n <= MAX_DIM);\n   va_start (ap, n);\n \n   ret->n = n;"}]}