{"sha": "de144fb24f1fe7e600e89245b6afe27e76660547", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUxNDRmYjI0ZjFmZTdlNjAwZTg5MjQ1YjZhZmUyN2U3NjY2MDU0Nw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-11-20T15:10:33Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-11-20T15:10:33Z"}, "message": "remove param1_is usage\n\ngcc/\n\n\t* hash-map.h (hash_map::iterator): New class.\n\t(hash_map::begin): New method.\n\t(hash_map::end): Likewise.\n\t* alias.c, config/alpha/alpha.c, dwarf2asm.c, omp-low.c, tree.h:\n\treplace splay_tree with hash_map.\n\nFrom-SVN: r217869", "tree": {"sha": "168d9d23388f6dc2e32b8bfa107fb0d4e5febde3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/168d9d23388f6dc2e32b8bfa107fb0d4e5febde3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de144fb24f1fe7e600e89245b6afe27e76660547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de144fb24f1fe7e600e89245b6afe27e76660547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de144fb24f1fe7e600e89245b6afe27e76660547", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de144fb24f1fe7e600e89245b6afe27e76660547/comments", "author": null, "committer": null, "parents": [{"sha": "1f012f560f6eea9cc07dcf9ee343d7a17692f9bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f012f560f6eea9cc07dcf9ee343d7a17692f9bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f012f560f6eea9cc07dcf9ee343d7a17692f9bc"}], "stats": {"total": 229, "additions": 138, "deletions": 91}, "files": [{"sha": "57dfc167760a803ed2521f5ddfb69e154c2347e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -1,3 +1,11 @@\n+2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-map.h (hash_map::iterator): New class.\n+\t(hash_map::begin): New method.\n+\t(hash_map::end): Likewise.\n+\t* alias.c, config/alpha/alpha.c, dwarf2asm.c, omp-low.c, tree.h:\n+\treplace splay_tree with hash_map.\n+\n 2014-11-20  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* hash-table.h (hash_table::hash_table): Call alloc_entries."}, {"sha": "425eb0be72195fcb7aac647209a588ac971d53c8", "filename": "gcc/alias.c", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -40,7 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"diagnostic-core.h\"\n #include \"cselib.h\"\n-#include \"splay-tree.h\"\n+#include \"hash-map.h\"\n #include \"langhooks.h\"\n #include \"timevar.h\"\n #include \"dumpfile.h\"\n@@ -139,6 +139,32 @@ along with GCC; see the file COPYING3.  If not see\n    However, this is no actual entry for alias set zero.  It is an\n    error to attempt to explicitly construct a subset of zero.  */\n \n+struct alias_set_traits : default_hashmap_traits\n+{\n+  template<typename T>\n+  static bool\n+  is_empty (T &e)\n+  {\n+    return e.m_key == INT_MIN;\n+  }\n+\n+  template<typename  T>\n+  static bool\n+  is_deleted (T &e)\n+  {\n+    return e.m_key == (INT_MIN + 1);\n+  }\n+\n+  template<typename T> static void mark_empty (T &e) { e.m_key = INT_MIN; }\n+\n+  template<typename T>\n+  static void\n+  mark_deleted (T &e)\n+  {\n+    e.m_key = INT_MIN + 1;\n+  }\n+};\n+\n struct GTY(()) alias_set_entry_d {\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n   alias_set_type alias_set;\n@@ -154,7 +180,7 @@ struct GTY(()) alias_set_entry_d {\n \n      continuing our example above, the children here will be all of\n      `int', `double', `float', and `struct S'.  */\n-  splay_tree GTY((param1_is (int), param2_is (int))) children;\n+  hash_map<int, int, alias_set_traits> *children;\n };\n typedef struct alias_set_entry_d *alias_set_entry;\n \n@@ -165,7 +191,6 @@ static int base_alias_check (rtx, rtx, rtx, rtx, machine_mode,\n \t\t\t     machine_mode);\n static rtx find_base_value (rtx);\n static int mems_in_disjoint_alias_sets_p (const_rtx, const_rtx);\n-static int insert_subset_children (splay_tree_node, void*);\n static alias_set_entry get_alias_set_entry (alias_set_type);\n static tree decl_for_component_ref (tree);\n static int write_dependence_p (const_rtx,\n@@ -405,17 +430,6 @@ mems_in_disjoint_alias_sets_p (const_rtx mem1, const_rtx mem2)\n   return ! alias_sets_conflict_p (MEM_ALIAS_SET (mem1), MEM_ALIAS_SET (mem2));\n }\n \n-/* Insert the NODE into the splay tree given by DATA.  Used by\n-   record_alias_subset via splay_tree_foreach.  */\n-\n-static int\n-insert_subset_children (splay_tree_node node, void *data)\n-{\n-  splay_tree_insert ((splay_tree) data, node->key, node->value);\n-\n-  return 0;\n-}\n-\n /* Return true if the first alias set is a subset of the second.  */\n \n bool\n@@ -431,8 +445,7 @@ alias_set_subset_of (alias_set_type set1, alias_set_type set2)\n   ase = get_alias_set_entry (set2);\n   if (ase != 0\n       && (ase->has_zero_child\n-\t  || splay_tree_lookup (ase->children,\n-\t\t\t        (splay_tree_key) set1)))\n+\t  || ase->children->get (set1)))\n     return true;\n   return false;\n }\n@@ -452,16 +465,14 @@ alias_sets_conflict_p (alias_set_type set1, alias_set_type set2)\n   ase = get_alias_set_entry (set1);\n   if (ase != 0\n       && (ase->has_zero_child\n-\t  || splay_tree_lookup (ase->children,\n-\t\t\t\t(splay_tree_key) set2)))\n+\t  || ase->children->get (set2)))\n     return 1;\n \n   /* Now do the same, but with the alias sets reversed.  */\n   ase = get_alias_set_entry (set2);\n   if (ase != 0\n       && (ase->has_zero_child\n-\t  || splay_tree_lookup (ase->children,\n-\t\t\t\t(splay_tree_key) set1)))\n+\t  || ase->children->get (set1)))\n     return 1;\n \n   /* The two alias sets are distinct and neither one is the\n@@ -956,9 +967,7 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n       superset_entry = ggc_cleared_alloc<alias_set_entry_d> ();\n       superset_entry->alias_set = superset;\n       superset_entry->children\n-\t= splay_tree_new_ggc (splay_tree_compare_ints,\n-\t\t\t      ggc_alloc_splay_tree_scalar_scalar_splay_tree_s,\n-\t\t\t      ggc_alloc_splay_tree_scalar_scalar_splay_tree_node_s);\n+\t= hash_map<int, int, alias_set_traits>::create_ggc (64);\n       superset_entry->has_zero_child = 0;\n       (*alias_sets)[superset] = superset_entry;\n     }\n@@ -975,13 +984,14 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n \t  if (subset_entry->has_zero_child)\n \t    superset_entry->has_zero_child = 1;\n \n-\t  splay_tree_foreach (subset_entry->children, insert_subset_children,\n-\t\t\t      superset_entry->children);\n+\t  hash_map<int, int, alias_set_traits>::iterator iter\n+\t    = subset_entry->children->begin ();\n+\t  for (; iter != subset_entry->children->end (); ++iter)\n+\t    superset_entry->children->put ((*iter).first, (*iter).second);\n \t}\n \n       /* Enter the SUBSET itself as a child of the SUPERSET.  */\n-      splay_tree_insert (superset_entry->children,\n-\t\t\t (splay_tree_key) subset, 0);\n+      superset_entry->children->put (subset, 0);\n     }\n }\n "}, {"sha": "c0eb0fc34ee083ad91d80d37f485403090f99ea0", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"common/common-target.h\"\n #include \"debug.h\"\n #include \"langhooks.h\"\n-#include \"splay-tree.h\"\n+#include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"predict.h\"\n #include \"dominance.h\"\n@@ -4860,6 +4860,14 @@ alpha_multipass_dfa_lookahead (void)\n \n struct GTY(()) alpha_links;\n \n+struct string_traits : default_hashmap_traits\n+{\n+  static bool equal_keys (const char *const &a, const char *const &b)\n+  {\n+    return strcmp (a, b) == 0;\n+  }\n+};\n+\n struct GTY(()) machine_function\n {\n   /* For flag_reorder_blocks_and_partition.  */\n@@ -4869,8 +4877,7 @@ struct GTY(()) machine_function\n   bool uses_condition_handler;\n \n   /* Linkage entries.  */\n-  splay_tree GTY ((param1_is (char *), param2_is (struct alpha_links *)))\n-    links;\n+  hash_map<const char *, alpha_links *, string_traits> *links;\n };\n \n /* How to allocate a 'struct machine_function'.  */\n@@ -9642,18 +9649,14 @@ alpha_use_linkage (rtx func, bool lflag, bool rflag)\n \n   if (cfun->machine->links)\n     {\n-      splay_tree_node lnode;\n-\n       /* Is this name already defined?  */\n-      lnode = splay_tree_lookup (cfun->machine->links, (splay_tree_key) name);\n-      if (lnode)\n-\tal = (struct alpha_links *) lnode->value;\n+      alpha_links *slot = cfun->machine->links->get (name);\n+      if (slot)\n+\tal = *slot;\n     }\n   else\n-    cfun->machine->links = splay_tree_new_ggc\n-      ((splay_tree_compare_fn) strcmp,\n-       ggc_alloc_splay_tree_str_alpha_links_splay_tree_s,\n-       ggc_alloc_splay_tree_str_alpha_links_splay_tree_node_s);\n+    cfun->machine->links\n+      = hash_map<const char *, alpha_links *, string_traits>::create_ggc (64);\n \n   if (al == NULL)\n     {\n@@ -9681,9 +9684,7 @@ alpha_use_linkage (rtx func, bool lflag, bool rflag)\n       al->func = func;\n       al->linkage = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (linksym));\n \n-      splay_tree_insert (cfun->machine->links,\n-                         (splay_tree_key) ggc_strdup (name),\n-\t\t\t (splay_tree_value) al);\n+      cfun->machine->links->put (ggc_strdup (name), al);\n     }\n \n   al->rkind = rflag ? KIND_CODEADDR : KIND_LINKAGE;\n@@ -9695,12 +9696,8 @@ alpha_use_linkage (rtx func, bool lflag, bool rflag)\n }\n \n static int\n-alpha_write_one_linkage (splay_tree_node node, void *data)\n+alpha_write_one_linkage (const char *name, alpha_links *link, FILE *steam)\n {\n-  const char *const name = (const char *) node->key;\n-  struct alpha_links *link = (struct alpha_links *) node->value;\n-  FILE *stream = (FILE *) data;\n-\n   ASM_OUTPUT_INTERNAL_LABEL (stream, XSTR (link->linkage, 0));\n   if (link->rkind == KIND_CODEADDR)\n     {\n@@ -9750,8 +9747,10 @@ alpha_write_linkage (FILE *stream, const char *funname)\n \n   if (cfun->machine->links)\n     {\n-      splay_tree_foreach (cfun->machine->links, alpha_write_one_linkage, stream);\n-      /* splay_tree_delete (func->links); */\n+      hash_map<const char *, alpha_links *, string_traits>::iterator iter\n+\t= cfun->machine->links->begin ();\n+      for (; iter != cfun->machine->links->end (); ++iter)\n+\talpha_write_one_linkage ((*iter).first, (*iter).second, stream);\n     }\n }\n "}, {"sha": "611b5126271d8d2da849d28529c3c8ddd634aa1d", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -31,7 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"dwarf2asm.h\"\n #include \"dwarf2.h\"\n-#include \"splay-tree.h\"\n+#include \"hash-map.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n \n@@ -790,9 +790,7 @@ dw2_asm_output_delta_sleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n }\n #endif /* 0 */\n \f\n-static int dw2_output_indirect_constant_1 (splay_tree_node, void *);\n-\n-static GTY((param1_is (char *), param2_is (tree))) splay_tree indirect_pool;\n+static GTY(()) hash_map<const char *, tree> *indirect_pool;\n \n static GTY(()) int dw2_const_labelno;\n \n@@ -802,16 +800,16 @@ static GTY(()) int dw2_const_labelno;\n # define USE_LINKONCE_INDIRECT 0\n #endif\n \n-/* Comparison function for a splay tree in which the keys are strings.\n-   K1 and K2 have the dynamic type \"const char *\".  Returns <0, 0, or\n+/* Compare two std::pair<const char *, tree> by their first element.\n+   Returns <0, 0, or\n    >0 to indicate whether K1 is less than, equal to, or greater than\n    K2, respectively.  */\n \n static int\n-splay_tree_compare_strings (splay_tree_key k1, splay_tree_key k2)\n+compare_strings (const void *a, const void *b)\n {\n-  const char *s1 = (const char *)k1;\n-  const char *s2 = (const char *)k2;\n+  const char *s1 = ((const std::pair<const char *, tree> *) a)->first;\n+  const char *s2 = ((const std::pair<const char *, tree> *) b)->first;\n   int ret;\n \n   if (s1 == s2)\n@@ -836,23 +834,18 @@ splay_tree_compare_strings (splay_tree_key k1, splay_tree_key k2)\n rtx\n dw2_force_const_mem (rtx x, bool is_public)\n {\n-  splay_tree_node node;\n   const char *key;\n   tree decl_id;\n \n   if (! indirect_pool)\n-    /* We use strcmp, rather than just comparing pointers, so that the\n-       sort order will not depend on the host system.  */\n-    indirect_pool = splay_tree_new_ggc (splay_tree_compare_strings,\n-\t\t\t\t\tggc_alloc_splay_tree_str_tree_node_splay_tree_s,\n-\t\t\t\t\tggc_alloc_splay_tree_str_tree_node_splay_tree_node_s);\n+    indirect_pool = hash_map<const char *, tree>::create_ggc (64);\n \n   gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n   key = XSTR (x, 0);\n-  node = splay_tree_lookup (indirect_pool, (splay_tree_key) key);\n-  if (node)\n-    decl_id = (tree) node->value;\n+  tree *slot = indirect_pool->get (key);\n+  if (slot)\n+    decl_id = *slot;\n   else\n     {\n       tree id;\n@@ -881,26 +874,20 @@ dw2_force_const_mem (rtx x, bool is_public)\n       if (id)\n \tTREE_SYMBOL_REFERENCED (id) = 1;\n \n-      splay_tree_insert (indirect_pool, (splay_tree_key) key,\n-\t\t\t (splay_tree_value) decl_id);\n+      indirect_pool->put (key, decl_id);\n     }\n \n   return gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (decl_id));\n }\n \n-/* A helper function for dw2_output_indirect_constants called through\n-   splay_tree_foreach.  Emit one queued constant to memory.  */\n+/* A helper function for dw2_output_indirect_constants.  Emit one queued\n+   constant to memory.  */\n \n static int\n-dw2_output_indirect_constant_1 (splay_tree_node node,\n-\t\t\t\tvoid *data ATTRIBUTE_UNUSED)\n+dw2_output_indirect_constant_1 (const char *sym, tree id)\n {\n-  const char *sym;\n   rtx sym_ref;\n-  tree id, decl;\n-\n-  sym = (const char *) node->key;\n-  id = (tree) node->value;\n+  tree decl;\n \n   decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, id, ptr_type_node);\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n@@ -930,8 +917,18 @@ dw2_output_indirect_constant_1 (splay_tree_node node,\n void\n dw2_output_indirect_constants (void)\n {\n-  if (indirect_pool)\n-    splay_tree_foreach (indirect_pool, dw2_output_indirect_constant_1, NULL);\n+  if (!indirect_pool)\n+    return;\n+\n+  auto_vec<std::pair<const char *, tree> > temp (indirect_pool->elements ());\n+  for (hash_map<const char *, tree>::iterator iter = indirect_pool->begin ();\n+       iter != indirect_pool->end (); ++iter)\n+    temp.quick_push (*iter);\n+\n+    temp.qsort (compare_strings);\n+\n+    for (unsigned int i = 0; i < temp.length (); i++)\n+    dw2_output_indirect_constant_1 (temp[i].first, temp[i].second);\n }\n \n /* Like dw2_asm_output_addr_rtx, but encode the pointer as directed."}, {"sha": "f6fdc1c7ab02a83cb7caeda552edee8414705935", "filename": "gcc/hash-map.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define hash_map_h\n \n #include <new>\n+#include <utility>\n #include \"hash-table.h\"\n \n /* implement default behavior for traits when types allow it.  */\n@@ -266,6 +267,39 @@ class GTY((user)) hash_map\n \n   size_t elements () const { return m_table.elements (); }\n \n+  class iterator\n+  {\n+  public:\n+    explicit iterator (const typename hash_table<hash_entry>::iterator &iter) :\n+      m_iter (iter) {}\n+\n+    iterator &operator++ ()\n+    {\n+      ++m_iter;\n+      return *this;\n+    }\n+\n+    std::pair<Key, Value> operator* ()\n+    {\n+      hash_entry &e = *m_iter;\n+      return std::pair<Key, Value> (e.m_key, e.m_value);\n+    }\n+\n+    bool\n+    operator != (const iterator &other) const\n+    {\n+      return m_iter != other.m_iter;\n+    }\n+\n+  private:\n+    typename hash_table<hash_entry>::iterator m_iter;\n+  };\n+\n+  /* Standard iterator retrieval methods.  */\n+\n+  iterator  begin () const { return iterator (m_table.begin ()); }\n+  iterator end () const { return iterator (m_table.end ()); }\n+\n private:\n \n   template<typename T, typename U, typename V> friend void gt_ggc_mx (hash_map<T, U, V> *);"}, {"sha": "3924282cae248b4490f1f5f284bbf5c004c6dc5e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -9330,8 +9330,7 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n    requires that languages coordinate a symbol name.  It is therefore\n    best put here in common code.  */\n \n-static GTY((param1_is (tree), param2_is (tree)))\n-  splay_tree critical_name_mutexes;\n+static GTY(()) hash_map<tree, tree> *critical_name_mutexes;\n \n static void\n lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n@@ -9347,15 +9346,11 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   if (name)\n     {\n       tree decl;\n-      splay_tree_node n;\n \n       if (!critical_name_mutexes)\n-\tcritical_name_mutexes\n-\t  = splay_tree_new_ggc (splay_tree_compare_pointers,\n-\t\t\t\tggc_alloc_splay_tree_tree_node_tree_node_splay_tree_s,\n-\t\t\t\tggc_alloc_splay_tree_tree_node_tree_node_splay_tree_node_s);\n+\tcritical_name_mutexes = hash_map<tree, tree>::create_ggc (10);\n \n-      n = splay_tree_lookup (critical_name_mutexes, (splay_tree_key) name);\n+      tree *n = critical_name_mutexes->get (name);\n       if (n == NULL)\n \t{\n \t  char *new_str;\n@@ -9383,11 +9378,10 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n \t  varpool_node::finalize_decl (decl);\n \n-\t  splay_tree_insert (critical_name_mutexes, (splay_tree_key) name,\n-\t\t\t     (splay_tree_value) decl);\n+\t  critical_name_mutexes->put (name, decl);\n \t}\n       else\n-\tdecl = (tree) n->value;\n+\tdecl = *n;\n \n       lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_START);\n       lock = build_call_expr_loc (loc, lock, 1, build_fold_addr_expr_loc (loc, decl));"}, {"sha": "fa6d535982fe9639922cc91abb3ea45c5af76964", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de144fb24f1fe7e600e89245b6afe27e76660547/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=de144fb24f1fe7e600e89245b6afe27e76660547", "patch": "@@ -4875,4 +4875,9 @@ int_bit_position (const_tree field)\n   return (wi::lshift (wi::to_offset (DECL_FIELD_OFFSET (field)), BITS_PER_UNIT_LOG)\n \t  + wi::to_offset (DECL_FIELD_BIT_OFFSET (field))).to_shwi ();\n }\n+\n+extern void gt_ggc_mx (tree &);\n+extern void gt_pch_nx (tree &);\n+extern void gt_pch_nx (tree &, gt_pointer_operator, void *);\n+\n #endif  /* GCC_TREE_H  */"}]}