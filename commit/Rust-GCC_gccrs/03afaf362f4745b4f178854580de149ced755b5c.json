{"sha": "03afaf362f4745b4f178854580de149ced755b5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNhZmFmMzYyZjQ3NDViNGYxNzg4NTQ1ODBkZTE0OWNlZDc1NWI1Yw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@redhat.com", "date": "2000-11-02T22:02:21Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-11-02T22:02:21Z"}, "message": "combine.c (distribute_notes): Use rtx_equal_p to check elim_i2 / elim_i1.\n\n\t* combine.c (distribute_notes): Use rtx_equal_p to check elim_i2 /\n\telim_i1.\n\tIn REG_DEAD handling: When handling parts of multi-hard-reg hard\n\tregisters, increment the loop counter by the size of the parts;\n\tuse recursion to handle individual parts.\n\nFrom-SVN: r37211", "tree": {"sha": "7383402ebd93d35de160bfd0be9839064ff76168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7383402ebd93d35de160bfd0be9839064ff76168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03afaf362f4745b4f178854580de149ced755b5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03afaf362f4745b4f178854580de149ced755b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03afaf362f4745b4f178854580de149ced755b5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03afaf362f4745b4f178854580de149ced755b5c/comments", "author": null, "committer": null, "parents": [{"sha": "aca46e2a900e60c25b8f7fc201c8614a8c1fcc72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca46e2a900e60c25b8f7fc201c8614a8c1fcc72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca46e2a900e60c25b8f7fc201c8614a8c1fcc72"}], "stats": {"total": 89, "additions": 30, "deletions": 59}, "files": [{"sha": "1b423a3b352673a5bc94f63cc657ca6943eb99b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03afaf362f4745b4f178854580de149ced755b5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03afaf362f4745b4f178854580de149ced755b5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03afaf362f4745b4f178854580de149ced755b5c", "patch": "@@ -1,3 +1,11 @@\n+Thu Nov  2 21:52:35 2000  J\"orn Rennecke <amylaar@redhat.com>\n+\n+\t* combine.c (distribute_notes): Use rtx_equal_p to check elim_i2 /\n+\telim_i1.\n+\tIn REG_DEAD handling: When handling parts of multi-hard-reg hard\n+\tregisters, increment the loop counter by the size of the parts;\n+\tuse recursion to handle individual parts.\n+\n 2000-11-02  Neil Booth  <neilb@earthling.net>\n \n \t* configure.in: Make integrated CPP the default."}, {"sha": "215644037491c091841e570c849bc99e9c3399e7", "filename": "gcc/combine.c", "status": "modified", "additions": 22, "deletions": 59, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03afaf362f4745b4f178854580de149ced755b5c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03afaf362f4745b4f178854580de149ced755b5c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=03afaf362f4745b4f178854580de149ced755b5c", "patch": "@@ -12288,7 +12288,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t   && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n \t    place = i2;\n \n-\t  if (XEXP (note, 0) == elim_i2 || XEXP (note, 0) == elim_i1)\n+\t  if (rtx_equal_p (XEXP (note, 0), elim_i2)\n+\t      || rtx_equal_p (XEXP (note, 0), elim_i1))\n \t    break;\n \n \t  if (place == 0)\n@@ -12468,13 +12469,11 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t      /* If this is a death note for a hard reg that is occupying\n \t\t multiple registers, ensure that we are still using all\n \t\t parts of the object.  If we find a piece of the object\n-\t\t that is unused, we must add a USE for that piece before\n-\t\t PLACE and put the appropriate REG_DEAD note on it.\n-\n-\t\t An alternative would be to put a REG_UNUSED for the pieces\n-\t\t on the insn that set the register, but that can't be done if\n-\t\t it is not in the same block.  It is simpler, though less\n-\t\t efficient, to add the USE insns.  */\n+\t\t that is unused, we must arrange for an appropriate REG_DEAD\n+\t\t note to be added for it.  However, we can't just emit a USE\n+\t\t and tag the note to it, since the register might actually\n+\t\t be dead; so we recourse, and the recursive call then finds\n+\t\t the previous insn that used this register.  */\n \n \t      if (place && regno < FIRST_PSEUDO_REGISTER\n \t\t  && HARD_REGNO_NREGS (regno, GET_MODE (XEXP (note, 0))) > 1)\n@@ -12486,67 +12485,31 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t  unsigned int i;\n \n \t\t  for (i = regno; i < endregno; i++)\n-\t\t    if (! refers_to_regno_p (i, i + 1, PATTERN (place), 0)\n-\t\t\t&& ! find_regno_fusage (place, USE, i))\n-\t\t      {\n-\t\t\trtx piece = gen_rtx_REG (reg_raw_mode[i], i);\n-\t\t\trtx p;\n-\n-\t\t\t/* See if we already placed a USE note for this\n-\t\t\t   register in front of PLACE.  */\n-\t\t\tfor (p = place;\n-\t\t\t     GET_CODE (PREV_INSN (p)) == INSN\n-\t\t\t     && GET_CODE (PATTERN (PREV_INSN (p))) == USE;\n-\t\t\t     p = PREV_INSN (p))\n-\t\t\t  if (rtx_equal_p (piece,\n-\t\t\t\t\t   XEXP (PATTERN (PREV_INSN (p)), 0)))\n-\t\t\t    {\n-\t\t\t      p = 0;\n-\t\t\t      break;\n-\t\t\t    }\n-\n-\t\t\tif (p)\n-\t\t\t  {\n-\t\t\t    rtx use_insn\n-\t\t\t      = emit_insn_before (gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t\t\t       piece),\n-\t\t\t\t\t\t  p);\n-\t\t\t    REG_NOTES (use_insn)\n-\t\t\t      = gen_rtx_EXPR_LIST (REG_DEAD, piece,\n-\t\t\t\t\t\t   REG_NOTES (use_insn));\n-\t\t\t  }\n-\n-\t\t\tall_used = 0;\n-\t\t      }\n-\n-\t\t  /* Check for the case where the register dying partially\n-\t\t     overlaps the register set by this insn.  */\n-\t\t  if (all_used)\n-\t\t    for (i = regno; i < endregno; i++)\n-\t\t      if (dead_or_set_regno_p (place, i))\n-\t\t\t{\n-\t\t\t  all_used = 0;\n-\t\t\t  break;\n-\t\t\t}\n+\t\t    if ((! refers_to_regno_p (i, i + 1, PATTERN (place), 0)\n+\t\t\t && ! find_regno_fusage (place, USE, i))\n+\t\t\t|| dead_or_set_regno_p (place, i))\n+\t\t      all_used = 0;\n \n \t\t  if (! all_used)\n \t\t    {\n \t\t      /* Put only REG_DEAD notes for pieces that are\n-\t\t\t still used and that are not already dead or set.  */\n+\t\t\t not already dead or set.  */\n \n-\t\t      for (i = regno; i < endregno; i++)\n+\t\t      for (i = regno; i < endregno;\n+\t\t\t   i += HARD_REGNO_NREGS (i, reg_raw_mode[i]))\n \t\t\t{\n \t\t\t  rtx piece = gen_rtx_REG (reg_raw_mode[i], i);\n \n-\t\t\t  if ((reg_referenced_p (piece, PATTERN (place))\n-\t\t\t       || (GET_CODE (place) == CALL_INSN\n-\t\t\t\t   && find_reg_fusage (place, USE, piece)))\n-\t\t\t      && ! dead_or_set_p (place, piece)\n+\t\t\t  if (! dead_or_set_p (place, piece)\n \t\t\t      && ! reg_bitfield_target_p (piece,\n \t\t\t\t\t\t\t  PATTERN (place)))\n-\t\t\t    REG_NOTES (place)\n-\t\t\t      = gen_rtx_EXPR_LIST (REG_DEAD, piece,\n-\t\t\t\t\t\t   REG_NOTES (place));\n+\t\t\t    {\n+\t\t\t      rtx new_note\n+\t\t\t\t= gen_rtx_EXPR_LIST (REG_DEAD, piece, NULL_RTX);\n+\n+\t\t\t      distribute_notes (new_note, place, place,\n+\t\t\t\t\t\tNULL_RTX, NULL_RTX, NULL_RTX);\n+\t\t\t    }\n \t\t\t}\n \n \t\t      place = 0;"}]}