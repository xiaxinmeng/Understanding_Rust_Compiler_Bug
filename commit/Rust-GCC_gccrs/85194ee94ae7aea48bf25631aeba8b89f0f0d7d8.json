{"sha": "85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUxOTRlZTk0YWU3YWVhNDhiZjI1NjMxYWViYThiODlmMGYwZDdkOA==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2004-01-09T17:08:44Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-01-09T17:08:44Z"}, "message": "re PR java/12755 (Binary Compatibility: Resolving static methods and classes is not thread safe)\n\n2004-01-09  Andrew Haley  <aph@redhat.com>\n\n\tPR java/12755:\n\t* parse.y (java_fix_constructors):  Set output_class.\n\t(java_reorder_fields): Likewise.\n\t(java_layout_classes): Likewise.\n\t(java_expand_classes): Generate indirect dispatch tables.\n\t(java_expand_classes): Set output_class.\n\t(java_finish_classes): Likewise.\n\t* lang.c (java_init): Turn on always_initialize_class_p if we're\n\tusing indirect dis[atch.\n\t(java_decl_ok_for_sibcall): Use output_class, not current_class.\n\t(java_get_callee_fndecl): Use class local atable.\n\t* jcf-parse.c\n\t(always_initialize_class_p): Decl moved to java-tree.h.\n\t(HANDLE_CLASS_INFO): Set output_class.\n\t(read_class): Likewise.\n\t(parse_class_file): Call gen_indirect_dispatch_tables.\n\t(parse_zip_file_entries): Set output_class.\n\t(java_parse_file): Set output_class.  Don't emit symbol tables.\n\t* java-tree.h (output_class): New.\n\tRemove global declarations for otable, atable, and ctable.\n\t(always_initialize_class_p): moved here from decl.c.\n\t(DECL_OWNER): New.\n\t(TYPE_ATABLE_METHODS, TYPE_ATABLE_SYMS_DECL, TYPE_ATABLE_DECL,\n\tTYPE_OTABLE_METHODS, TYPE_OTABLE_SYMS_DECL, TYPE_OTABLE_DECL,\n\tTYPE_CTABLE_DECL, TYPE_CATCH_CLASSES): New.\n\t(struct lang_type): Add otable_methods, otable_decl,\n\totable_syms_decl, atable_methods, atable_decl, atable_syms_decl,\n\tctable_decl, catch_classes, type_to_runtime_map.\n\t* expr.c (build_field_ref): Make otable, atable, and ctable class\n\tlocal rather than global.\n\t(build_known_method_ref): Likewise.\n\t(build_invokeinterface): Likewise.\n\t(java_expand_expr): Pass runtime type (rather than actual type) to\n\texpand_start_catch.\n\t* except.c (prepare_eh_table_type): Create TYPE_TO_RUNTIME_MAP for\n\tthis class.  Look up each class in that map to delete duplicates.\n\t(expand_end_java_handler): Pass runtime type (rather than actual\n\ttype) to expand_start_catch.\n\t* decl.c: (always_initialize_class_p): Decl moved to java-tree.h.\n\t(do_nothing): New.\n\t(java_init_decl_processing): Rearrange things.  Remove global\n\tdeclarations of otable, atable, and ctable.\n\t(java_init_decl_processing): Make lang_eh_runtime_type do_nothing.\n\t(java_expand_body): Set output_class.\n\t* constants.c (build_constant_data_ref): Use output_class, not\n\tcurrent_class.\n\t(alloc_name_constant): Likewise.\n\t* class.c (gen_indirect_dispatch_tables): New.\n\t(build_class_ref): Generate hard reference to superclass, even if\n\tusing indirect dispatch.\n\t(build_static_field_ref): Use class local atable.\n\t(make_class_data): Generate hard reference to superclass, even if\n\tusing indirect dispatch.\n\tGenerate symbolic references to interfaces when using indirect\n\tdispatch.\n\t(make_class_data): Emit otable, atable, and ctable.\n\tMake otable, atable, and ctable class local rather than global.\n\t(emit_catch_table): Make otable, atable, and ctable class local\n\trather than global.\n\nFrom-SVN: r75590", "tree": {"sha": "98aa4fb08cdfb195718477b393ddac9e38551240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98aa4fb08cdfb195718477b393ddac9e38551240"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "900a35c82b8dd470433ac7b52e3187b05b7988c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900a35c82b8dd470433ac7b52e3187b05b7988c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900a35c82b8dd470433ac7b52e3187b05b7988c9"}], "stats": {"total": 627, "additions": 412, "deletions": 215}, "files": [{"sha": "a0cee422c3585e2c9c1fdf9ade6672cdceb49374", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,3 +1,65 @@\n+2004-01-09  Andrew Haley  <aph@redhat.com>\n+\n+\tPR java/12755:\n+\t* parse.y (java_fix_constructors):  Set output_class.\n+\t(java_reorder_fields): Likewise.\n+\t(java_layout_classes): Likewise.\n+\t(java_expand_classes): Generate indirect dispatch tables.\n+\t(java_expand_classes): Set output_class.\n+\t(java_finish_classes): Likewise.\n+\t* lang.c (java_init): Turn on always_initialize_class_p if we're\n+\tusing indirect dis[atch.\n+\t(java_decl_ok_for_sibcall): Use output_class, not current_class.\n+\t(java_get_callee_fndecl): Use class local atable.\n+\t* jcf-parse.c \n+\t(always_initialize_class_p): Decl moved to java-tree.h.\n+\t(HANDLE_CLASS_INFO): Set output_class.\n+\t(read_class): Likewise.\n+\t(parse_class_file): Call gen_indirect_dispatch_tables.\n+\t(parse_zip_file_entries): Set output_class.\n+\t(java_parse_file): Set output_class.  Don't emit symbol tables.\n+\t* java-tree.h (output_class): New.\n+\tRemove global declarations for otable, atable, and ctable.\n+\t(always_initialize_class_p): moved here from decl.c.\n+\t(DECL_OWNER): New.\n+\t(TYPE_ATABLE_METHODS, TYPE_ATABLE_SYMS_DECL, TYPE_ATABLE_DECL,\n+\tTYPE_OTABLE_METHODS, TYPE_OTABLE_SYMS_DECL, TYPE_OTABLE_DECL,\n+\tTYPE_CTABLE_DECL, TYPE_CATCH_CLASSES): New.\n+\t(struct lang_type): Add otable_methods, otable_decl,\n+\totable_syms_decl, atable_methods, atable_decl, atable_syms_decl,\n+\tctable_decl, catch_classes, type_to_runtime_map.\n+\t* expr.c (build_field_ref): Make otable, atable, and ctable class\n+\tlocal rather than global.\n+\t(build_known_method_ref): Likewise.\n+\t(build_invokeinterface): Likewise.\n+\t(java_expand_expr): Pass runtime type (rather than actual type) to\n+\texpand_start_catch.\n+\t* except.c (prepare_eh_table_type): Create TYPE_TO_RUNTIME_MAP for\n+\tthis class.  Look up each class in that map to delete duplicates.\n+\t(expand_end_java_handler): Pass runtime type (rather than actual\n+\ttype) to expand_start_catch.\n+\t* decl.c: (always_initialize_class_p): Decl moved to java-tree.h.\n+\t(do_nothing): New.\n+\t(java_init_decl_processing): Rearrange things.  Remove global\n+\tdeclarations of otable, atable, and ctable.\n+\t(java_init_decl_processing): Make lang_eh_runtime_type do_nothing.\n+\t(java_expand_body): Set output_class.\n+\t* constants.c (build_constant_data_ref): Use output_class, not\n+\tcurrent_class.\n+\t(alloc_name_constant): Likewise.\n+\t* class.c (gen_indirect_dispatch_tables): New.\n+\t(build_class_ref): Generate hard reference to superclass, even if\n+\tusing indirect dispatch.\n+\t(build_static_field_ref): Use class local atable.\n+\t(make_class_data): Generate hard reference to superclass, even if\n+\tusing indirect dispatch.\n+\tGenerate symbolic references to interfaces when using indirect\n+\tdispatch.\n+\t(make_class_data): Emit otable, atable, and ctable.\n+\tMake otable, atable, and ctable class local rather than global.\n+\t(emit_catch_table): Make otable, atable, and ctable class local\n+\trather than global.\n+\t\t\n 2003-12-25  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* parse.y (catch_clause_parameter): Fix typo."}, {"sha": "bf9f79ef280ae46c15a67909803e3649d3eb1bc0", "filename": "gcc/java/class.c", "status": "modified", "additions": 152, "deletions": 39, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,5 +1,5 @@\n /* Functions related to building classes and their related objects.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -42,6 +42,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"ggc.h\"\n #include \"stdio.h\"\n #include \"target.h\"\n+#include \"except.h\"\n \n /* DOS brain-damage */\n #ifndef O_BINARY\n@@ -304,6 +305,83 @@ unmangle_classname (const char *name, int name_length)\n   return to_return;\n }\n \n+\n+/* Given a class, create the DECLs for all its associated indirect dispatch tables.  */\n+void\n+gen_indirect_dispatch_tables (tree type)\n+{\n+  const char *typename = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+  {  \n+    tree field = NULL;\n+    char *buf = alloca (strlen (typename) + strlen (\"_catch_classes_\"));\n+    tree catch_class_type = make_node (RECORD_TYPE);\n+\n+    sprintf (buf, \"_catch_classes_%s\", typename);\n+    PUSH_FIELD (catch_class_type, field, \"address\", utf8const_ptr_type);\n+    PUSH_FIELD (catch_class_type, field, \"classname\", ptr_type_node);\n+    FINISH_RECORD (catch_class_type);\n+    \n+    TYPE_CTABLE_DECL (type) \n+      = build_decl (VAR_DECL, get_identifier (buf),\n+\t\t    build_array_type (catch_class_type, 0));\n+    DECL_EXTERNAL (TYPE_CTABLE_DECL (type)) = 1;\n+    TREE_STATIC (TYPE_CTABLE_DECL (type)) = 1;\n+    TREE_READONLY (TYPE_CTABLE_DECL (type)) = 1;\n+    TREE_CONSTANT (TYPE_CTABLE_DECL (type)) = 1;\n+    DECL_IGNORED_P (TYPE_CTABLE_DECL (type)) = 1;\n+    pushdecl (TYPE_CTABLE_DECL (type));  \n+  }\n+\n+  if (flag_indirect_dispatch)\n+    {\n+      {\n+\tchar *buf = alloca (strlen (typename) + strlen (\"_otable_syms_\"));\n+\n+\tsprintf (buf, \"_otable_%s\", typename);\n+\tTYPE_OTABLE_DECL (type) = \n+\t  build_decl (VAR_DECL, get_identifier (buf), otable_type);\n+\tDECL_EXTERNAL (TYPE_OTABLE_DECL (type)) = 1;\n+\tTREE_STATIC (TYPE_OTABLE_DECL (type)) = 1;\n+\tTREE_READONLY (TYPE_OTABLE_DECL (type)) = 1;\n+\tTREE_CONSTANT (TYPE_OTABLE_DECL (type)) = 1;\n+\tDECL_IGNORED_P (TYPE_OTABLE_DECL (type)) = 1;\n+\tpushdecl (TYPE_OTABLE_DECL (type));  \n+\tsprintf (buf, \"_otable_syms_%s\", typename);\n+\tTYPE_OTABLE_SYMS_DECL (type) = \n+\t  build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\n+\tTREE_STATIC (TYPE_OTABLE_SYMS_DECL (type)) = 1;\n+\tTREE_CONSTANT (TYPE_OTABLE_SYMS_DECL (type)) = 1;\n+\tDECL_IGNORED_P(TYPE_OTABLE_SYMS_DECL (type)) = 1;\n+\tpushdecl (TYPE_OTABLE_SYMS_DECL (type));\n+      }\n+\n+      {\n+\tchar *buf = alloca (strlen (typename) + strlen (\"_atable_syms_\"));\n+\ttree decl;\n+\n+\tsprintf (buf, \"_atable_%s\", typename);\n+\tTYPE_ATABLE_DECL (type) = decl =\n+\t  build_decl (VAR_DECL, get_identifier (buf), atable_type);\n+\tDECL_EXTERNAL (decl) = 1;\n+\tTREE_STATIC (decl) = 1;\n+\tTREE_READONLY (decl) = 1;\n+\tTREE_CONSTANT (decl) = 1;\n+\tDECL_IGNORED_P (decl) = 1;\n+\t/* Mark the atable as belonging to this class.  */\n+\tpushdecl (decl);  \n+\tMAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n+\tDECL_OWNER (decl) = type;\n+\tsprintf (buf, \"_atable_syms_%s\", typename);\n+\tTYPE_ATABLE_SYMS_DECL (type) = \n+\t  build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\n+\tTREE_STATIC (TYPE_ATABLE_SYMS_DECL (type)) = 1;\n+\tTREE_CONSTANT (TYPE_ATABLE_SYMS_DECL (type)) = 1;\n+\tDECL_IGNORED_P (TYPE_ATABLE_SYMS_DECL (type)) = 1;\n+\tpushdecl (TYPE_ATABLE_SYMS_DECL (type));\n+      }\n+    }\n+}\n+\n tree\n push_class (tree class_type, tree class_name)\n {\n@@ -835,8 +913,13 @@ build_class_ref (tree type)\n       if (TREE_CODE (type) == POINTER_TYPE)\n \ttype = TREE_TYPE (type);\n \n-      if  (flag_indirect_dispatch \n-\t   && type != current_class\n+      /* FIXME: we really want an indirect reference to our\n+\t superclass.  However, libgcj assumes that a superclass\n+\t pointer always points directly to a class.  As a workaround\n+\t we always emit this hard superclass reference.  */\n+      if  (flag_indirect_dispatch\n+\t   && type != output_class\n+\t   && type != CLASSTYPE_SUPER (output_class)\n \t   && TREE_CODE (type) == RECORD_TYPE)\n \treturn build_indirect_class_ref (type);\n \n@@ -957,10 +1040,11 @@ build_static_field_ref (tree fdecl)\n   if (flag_indirect_dispatch)\n     {\n       tree table_index \n-\t= build_int_2 (get_symbol_table_index (fdecl, &atable_methods), 0);\n+\t= build_int_2 (get_symbol_table_index \n+\t\t       (fdecl, &TYPE_ATABLE_METHODS (output_class)), 0);\n       tree field_address\n \t= build (ARRAY_REF, build_pointer_type (TREE_TYPE (fdecl)), \n-\t\t atable_decl, table_index);\n+\t\t TYPE_ATABLE_DECL (output_class), table_index);\n       return fold (build1 (INDIRECT_REF, TREE_TYPE (fdecl), \n \t\t\t   field_address));\n     }\n@@ -1435,8 +1519,10 @@ make_class_data (tree type)\n   super = CLASSTYPE_SUPER (type);\n   if (super == NULL_TREE)\n     super = null_pointer_node;\n-  else if (! flag_indirect_dispatch\n-\t   && assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n+  else if (/* FIXME: we should also test for (!\n+\t      flag_indirect_dispatch) here, but libgcj can't cope with\n+\t      a symbolic reference a superclass in the class data.  */\n+\t   assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n \t   && assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (super)))))\n     super = build_class_ref (super);\n   else\n@@ -1463,13 +1549,15 @@ make_class_data (tree type)\n \t  tree child = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n \t  tree iclass = BINFO_TYPE (child);\n \t  tree index;\n-\t  if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (iclass)))))\n+\t  if (! flag_indirect_dispatch\n+\t      && (assume_compiled \n+\t\t  (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (iclass))))))\n \t    index = build_class_ref (iclass);\n \t  else\n \t    {\n-\t\tint int_index = alloc_class_constant (iclass);\n-\t\tindex = build_int_2 (int_index, 0);\n-\t\tTREE_TYPE (index) = ptr_type_node;\n+\t      int int_index = alloc_class_constant (iclass);\n+\t      index = build_int_2 (int_index, 0);\n+\t      TREE_TYPE (index) = ptr_type_node;\n \t    }\n \t  init = tree_cons (NULL_TREE, index, init); \n \t}\n@@ -1483,6 +1571,23 @@ make_class_data (tree type)\n \n   constant_pool_constructor = build_constants_constructor ();\n \n+  if (flag_indirect_dispatch)\n+    {\n+      TYPE_OTABLE_DECL (type) \n+\t= emit_symbol_table \n+\t(DECL_NAME (TYPE_OTABLE_DECL (type)), \n+\t TYPE_OTABLE_DECL (type), TYPE_OTABLE_METHODS (type), \n+\t TYPE_OTABLE_SYMS_DECL (type), integer_type_node);\n+       \n+      TYPE_ATABLE_DECL (type) \n+\t= emit_symbol_table \n+\t(DECL_NAME (TYPE_ATABLE_DECL (type)), \n+\t TYPE_ATABLE_DECL (type), TYPE_ATABLE_METHODS (type), \n+\t TYPE_ATABLE_SYMS_DECL (type), ptr_type_node);\n+    }\n+  \n+  TYPE_CTABLE_DECL (type) = emit_catch_table (type);\n+\n   START_RECORD_CONSTRUCTOR (temp, object_type_node);\n   PUSH_FIELD_VALUE (temp, \"vtable\",\n \t\t    build (PLUS_EXPR, dtable_ptr_type,\n@@ -1526,37 +1631,37 @@ make_class_data (tree type)\n \t\t      : build (PLUS_EXPR, dtable_ptr_type,\n \t\t\t       build1 (ADDR_EXPR, dtable_ptr_type, dtable_decl),\n \t\t\t       dtable_start_offset));\n-  if (otable_methods == NULL_TREE)\n+  if (TYPE_OTABLE_METHODS (type) == NULL_TREE)\n     {\n       PUSH_FIELD_VALUE (cons, \"otable\", null_pointer_node);\n       PUSH_FIELD_VALUE (cons, \"otable_syms\", null_pointer_node);\n     }\n   else\n     {\n       PUSH_FIELD_VALUE (cons, \"otable\",\n-\t\t\tbuild1 (ADDR_EXPR, otable_ptr_type, otable_decl));\n+\t\t\tbuild1 (ADDR_EXPR, otable_ptr_type, TYPE_OTABLE_DECL (type)));\n       PUSH_FIELD_VALUE (cons, \"otable_syms\",\n \t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n-\t\t\t\totable_syms_decl));\n-      TREE_CONSTANT (otable_decl) = 1;\n-    }\n-  if (atable_methods == NULL_TREE)\n+\t\t\t\tTYPE_OTABLE_SYMS_DECL (type)));\n+      TREE_CONSTANT (TYPE_OTABLE_DECL (type)) = 1;\n+    } \n+  if (TYPE_ATABLE_METHODS(type) == NULL_TREE)\n     {\n       PUSH_FIELD_VALUE (cons, \"atable\", null_pointer_node);\n       PUSH_FIELD_VALUE (cons, \"atable_syms\", null_pointer_node);\n     }\n   else\n     {\n       PUSH_FIELD_VALUE (cons, \"atable\",\n-\t\t\tbuild1 (ADDR_EXPR, atable_ptr_type, atable_decl));\n+\t\t\tbuild1 (ADDR_EXPR, atable_ptr_type, TYPE_ATABLE_DECL (type)));\n       PUSH_FIELD_VALUE (cons, \"atable_syms\",\n \t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n-\t\t\t\tatable_syms_decl));\n-      TREE_CONSTANT (atable_decl) = 1;\n+\t\t\t\tTYPE_ATABLE_SYMS_DECL (type)));\n+      TREE_CONSTANT (TYPE_ATABLE_DECL (type)) = 1;\n     }\n  \n   PUSH_FIELD_VALUE (cons, \"catch_classes\",\n-\t\t    build1 (ADDR_EXPR, ptr_type_node, ctable_decl)); \n+\t\t    build1 (ADDR_EXPR, ptr_type_node, TYPE_CTABLE_DECL (type))); \n   PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n   PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"interface_count\", build_int_2 (interface_len, 0));\n@@ -1616,6 +1721,8 @@ finish_class (void)\n       method = TREE_CHAIN (method);\n     }\n \n+  java_expand_catch_classes (current_class);\n+\n   current_function_decl = NULL_TREE;\n   make_class_data (current_class);\n   register_class ();\n@@ -2231,7 +2338,7 @@ tree\n make_catch_class_record (tree catch_class, tree classname)\n {\n   tree entry;\n-  tree type = TREE_TYPE (TREE_TYPE (ctable_decl));\n+  tree type = TREE_TYPE (TREE_TYPE (TYPE_CTABLE_DECL (output_class)));\n   START_RECORD_CONSTRUCTOR (entry, type);\n   PUSH_FIELD_VALUE (entry, \"address\", catch_class);\n   PUSH_FIELD_VALUE (entry, \"classname\", classname);\n@@ -2241,29 +2348,35 @@ make_catch_class_record (tree catch_class, tree classname)\n \n \n /* Generate the list of Throwable classes that are caught by exception\n-   handlers in this compilation.  */\n-void \n-emit_catch_table (void)\n+   handlers in this class.  */\n+tree \n+emit_catch_table (tree this_class)\n {\n   tree table, table_size, array_type;\n-  catch_classes \n-    = tree_cons (NULL, \n-\t\t make_catch_class_record (null_pointer_node, null_pointer_node),\n-\t\t catch_classes);\n-  catch_classes = nreverse (catch_classes);\n-  catch_classes \n-    = tree_cons (NULL, \n-\t\t make_catch_class_record (null_pointer_node, null_pointer_node),\n-\t\t catch_classes);\n-  table_size = build_index_type (build_int_2 (list_length (catch_classes), 0));\n+  TYPE_CATCH_CLASSES (this_class) =\n+    tree_cons (NULL,\n+\t       make_catch_class_record (null_pointer_node, null_pointer_node),\n+\t       TYPE_CATCH_CLASSES (this_class));\n+  TYPE_CATCH_CLASSES (this_class) = nreverse (TYPE_CATCH_CLASSES (this_class));\n+  TYPE_CATCH_CLASSES (this_class) = \n+    tree_cons (NULL,\n+\t       make_catch_class_record (null_pointer_node, null_pointer_node),\n+\t       TYPE_CATCH_CLASSES (this_class));\n+  table_size = \n+    build_index_type (build_int_2 \n+\t\t      (list_length (TYPE_CATCH_CLASSES (this_class)), 0));\n   array_type \n-    = build_array_type (TREE_TYPE (TREE_TYPE (ctable_decl)), table_size);\n-  table = build_decl (VAR_DECL, DECL_NAME (ctable_decl), array_type);\n-  DECL_INITIAL (table) = build_constructor (array_type, catch_classes);\n+    = build_array_type (TREE_TYPE (TREE_TYPE (TYPE_CTABLE_DECL (this_class))),\n+\t\t\ttable_size);\n+  table = \n+    build_decl (VAR_DECL, DECL_NAME (TYPE_CTABLE_DECL (this_class)), array_type);\n+  DECL_INITIAL (table) = \n+    build_constructor (array_type, TYPE_CATCH_CLASSES (this_class));\n   TREE_STATIC (table) = 1;\n   TREE_READONLY (table) = 1;  \n+  DECL_IGNORED_P (table) = 1;\n   rest_of_decl_compilation (table, NULL, 1, 0);\n-  ctable_decl = table;\n+  return table;\n }\n  \n "}, {"sha": "d97e8c07e800162daa07bdbad9b911505edad5da", "filename": "gcc/java/constants.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,5 +1,5 @@\n /* Handle the constant pool of the Java(TM) Virtual Machine.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -351,7 +351,7 @@ cpool_for_class (tree class)\n int\n alloc_name_constant (int tag, tree name)\n {\n-  CPool *outgoing_cpool = cpool_for_class (current_class);\n+  CPool *outgoing_cpool = cpool_for_class (output_class);\n   return find_tree_constant (outgoing_cpool, tag, name);\n }\n \n@@ -393,19 +393,19 @@ build_constant_data_ref (void)\n {\n   tree cpool_data_ref = NULL_TREE;\n \n-  if (TYPE_CPOOL_DATA_REF (current_class))\n-    cpool_data_ref = TYPE_CPOOL_DATA_REF (current_class);\n+  if (TYPE_CPOOL_DATA_REF (output_class))\n+    cpool_data_ref = TYPE_CPOOL_DATA_REF (output_class);\n \n   if (cpool_data_ref == NULL_TREE)\n     {\n       tree decl;\n-      tree decl_name = mangled_classname (\"_CD_\", current_class);\n+      tree decl_name = mangled_classname (\"_CD_\", output_class);\n       decl = build_decl (VAR_DECL, decl_name,\n \t\t\t build_array_type (ptr_type_node,\n \t\t\t\t\t   one_elt_array_domain_type));\n       TREE_STATIC (decl) = 1;\n       make_decl_rtl (decl, NULL);\n-      TYPE_CPOOL_DATA_REF (current_class) = cpool_data_ref\n+      TYPE_CPOOL_DATA_REF (output_class) = cpool_data_ref\n \t= build1 (ADDR_EXPR, ptr_type_node, decl);\n     }\n   return cpool_data_ref;"}, {"sha": "1ce2ad324c24a5e041ad797472af35a8d875a9ff", "filename": "gcc/java/decl.c", "status": "modified", "additions": 33, "deletions": 72, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for the GNU compiler for the\n    Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -64,10 +64,6 @@ tree java_lang_cloneable_identifier_node;\n /* Name of the Serializable class.  */\n tree java_io_serializable_identifier_node;\n \n-/* Set to nonzero value in order to emit class initialization code\n-   before static field references.  */\n-extern int always_initialize_class_p;\n-\n /* The DECL_MAP is a mapping from (index, type) to a decl node.\n    If index < max_locals, it is the index of a local variable.\n    if index >= max_locals, then index-max_locals is a stack slot.\n@@ -389,6 +385,13 @@ create_primitive_vtable (const char *name)\n   return r;\n }\n \n+static tree\n+do_nothing (tree t)\n+{\n+  return t;\n+}\n+\n+\n void\n java_init_decl_processing (void)\n {\n@@ -538,6 +541,28 @@ java_init_decl_processing (void)\n   float_array_vtable = create_primitive_vtable (\"float\");\n   double_array_vtable = create_primitive_vtable (\"double\");\n \n+  one_elt_array_domain_type = build_index_type (integer_one_node);\n+  utf8const_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (utf8const_type, field, \"hash\", unsigned_short_type_node);\n+  PUSH_FIELD (utf8const_type, field, \"length\", unsigned_short_type_node);\n+  FINISH_RECORD (utf8const_type);\n+  utf8const_ptr_type = build_pointer_type (utf8const_type);\n+\n+  atable_type = build_array_type (ptr_type_node, \n+\t\t\t\t  one_elt_array_domain_type);\n+  TYPE_NONALIASED_COMPONENT (atable_type) = 1;\n+  atable_ptr_type = build_pointer_type (atable_type);\n+\n+  symbol_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (symbol_type, field, \"clname\", utf8const_ptr_type);\n+  PUSH_FIELD (symbol_type, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (symbol_type, field, \"signature\", utf8const_ptr_type);\n+  FINISH_RECORD (symbol_type);\n+\n+  symbols_array_type = build_array_type (symbol_type, \n+\t\t\t\t\t one_elt_array_domain_type);\n+  symbols_array_ptr_type = build_pointer_type (symbols_array_type);\n+\n   /* As you're adding items here, please update the code right after\n      this section, so that the filename containing the source code of\n      the pre-defined class gets registered correctly. */\n@@ -595,12 +620,6 @@ java_init_decl_processing (void)\n   /* for lack of a better place to put this stub call */\n   init_expr_processing();\n \n-  utf8const_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (utf8const_type, field, \"hash\", unsigned_short_type_node);\n-  PUSH_FIELD (utf8const_type, field, \"length\", unsigned_short_type_node);\n-  FINISH_RECORD (utf8const_type);\n-  utf8const_ptr_type = build_pointer_type (utf8const_type);\n-\n   constants_type_node = make_node (RECORD_TYPE);\n   PUSH_FIELD (constants_type_node, field, \"size\", unsigned_int_type_node);\n   PUSH_FIELD (constants_type_node, field, \"tags\", ptr_type_node);\n@@ -613,69 +632,10 @@ java_init_decl_processing (void)\n   dtable_type = make_node (RECORD_TYPE);\n   dtable_ptr_type = build_pointer_type (dtable_type);\n \n-  one_elt_array_domain_type = build_index_type (integer_one_node);\n   otable_type = build_array_type (integer_type_node, \n \t\t\t\t  one_elt_array_domain_type);\n   TYPE_NONALIASED_COMPONENT (otable_type) = 1;\n   otable_ptr_type = build_pointer_type (otable_type);\n-  atable_type = build_array_type (ptr_type_node, \n-\t\t\t\t  one_elt_array_domain_type);\n-  TYPE_NONALIASED_COMPONENT (atable_type) = 1;\n-  atable_ptr_type = build_pointer_type (atable_type);\n-\n-  symbol_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (symbol_type, field, \"clname\", utf8const_ptr_type);\n-  PUSH_FIELD (symbol_type, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (symbol_type, field, \"signature\", utf8const_ptr_type);\n-  FINISH_RECORD (symbol_type);\n-\n-  symbols_array_type = build_array_type (symbol_type, \n-\t\t\t\t\t one_elt_array_domain_type);\n-  symbols_array_ptr_type = build_pointer_type (symbols_array_type);\n-\n-  if (flag_indirect_dispatch)\n-    {\n-      otable_decl = build_decl (VAR_DECL, get_identifier (\"otable\"), otable_type);\n-      DECL_EXTERNAL (otable_decl) = 1;\n-      TREE_STATIC (otable_decl) = 1;\n-      TREE_READONLY (otable_decl) = 1;\n-      TREE_CONSTANT (otable_decl) = 1;\n-      pushdecl (otable_decl);  \n-      otable_syms_decl = build_decl (VAR_DECL, get_identifier (\"otable_syms\"), \n-\t\t\t\t     symbols_array_type);\n-      TREE_STATIC (otable_syms_decl) = 1;\n-      TREE_CONSTANT (otable_syms_decl) = 1;\n-      pushdecl (otable_syms_decl);\n-\n-      atable_decl = build_decl (VAR_DECL, get_identifier (\"atable\"), atable_type);\n-      DECL_EXTERNAL (atable_decl) = 1;\n-      TREE_STATIC (atable_decl) = 1;\n-      TREE_READONLY (atable_decl) = 1;\n-      TREE_CONSTANT (atable_decl) = 1;\n-      pushdecl (atable_decl);  \n-      atable_syms_decl = build_decl (VAR_DECL, get_identifier (\"atable_syms\"), \n-\t\t\t\t     symbols_array_type);\n-      TREE_STATIC (atable_syms_decl) = 1;\n-      TREE_CONSTANT (atable_syms_decl) = 1;\n-      pushdecl (atable_syms_decl);\n-    }\n-  \n-  {  \n-    tree catch_class_type = make_node (RECORD_TYPE);\n-    PUSH_FIELD (catch_class_type, field, \"address\", utf8const_ptr_type);\n-    PUSH_FIELD (catch_class_type, field, \"classname\", ptr_type_node);\n-    FINISH_RECORD (catch_class_type);\n-    \n-    ctable_decl \n-      = build_decl (VAR_DECL, get_identifier (\"catch_classes\"), \n-\t\t    build_array_type \n-\t\t    (catch_class_type, 0));\n-    DECL_EXTERNAL (ctable_decl) = 1;\n-    TREE_STATIC (ctable_decl) = 1;\n-    TREE_READONLY (ctable_decl) = 1;\n-    TREE_CONSTANT (ctable_decl) = 1;\n-    pushdecl (ctable_decl);  \n-  }\n \n   PUSH_FIELD (object_type_node, field, \"vtable\", dtable_ptr_type);\n   /* This isn't exactly true, but it is what we have in the source.\n@@ -945,12 +905,12 @@ java_init_decl_processing (void)\n   eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n                                              ? \"__gcj_personality_sj0\"\n                                              : \"__gcj_personality_v0\");\n-  lang_eh_runtime_type = prepare_eh_table_type;\n+\n+  lang_eh_runtime_type = do_nothing;\n \n   init_jcf_parse ();\n     \n   initialize_builtins ();\n-\n   soft_fmod_node = built_in_decls[BUILT_IN_FMOD];\n #if 0\n   soft_fmodf_node = built_in_decls[BUILT_IN_FMODF];\n@@ -1860,6 +1820,7 @@ java_expand_body (tree fndecl)\n \n   current_function_decl = fndecl;\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n+  output_class = DECL_CONTEXT (current_function_decl);\n   current_class = DECL_CONTEXT (fndecl);\n \n   timevar_push (TV_EXPAND);"}, {"sha": "c5c7dcf27f4bc3edb379a543b63f74652dddacb3", "filename": "gcc/java/except.c", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,5 +1,5 @@\n /* Handle exceptions for GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003\n+   Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -312,6 +312,7 @@ tree\n prepare_eh_table_type (tree type)\n {\n   tree exp;\n+  tree *slot;\n   const char *name;\n   char *buf;\n   tree decl;\n@@ -324,8 +325,16 @@ prepare_eh_table_type (tree type)\n    * rewritten to point to the appropriate class.  */\n \n   if (type == NULL_TREE)\n-    exp = NULL_TREE;\n-  else if (is_compiled_class (type) && !flag_indirect_dispatch)\n+    return NULL_TREE;\n+\n+  if (TYPE_TO_RUNTIME_MAP (output_class) == NULL)\n+    TYPE_TO_RUNTIME_MAP (output_class) = java_treetreehash_create (10, 1);\n+  \n+  slot = java_treetreehash_new (TYPE_TO_RUNTIME_MAP (output_class), type);\n+  if (*slot != NULL)\n+    return TREE_VALUE (*slot);\n+\n+  if (is_compiled_class (type) && !flag_indirect_dispatch)\n     {\n       name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n       buf = alloca (strlen (name) + 5);\n@@ -339,8 +348,6 @@ prepare_eh_table_type (tree type)\n       DECL_INITIAL (decl) = build_class_ref (type);\n       layout_decl (decl, 0);\n       pushdecl (decl);\n-      rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n-      make_decl_rtl (decl, (char*) 0);\n       exp = build1 (ADDR_EXPR, ptr_type_node, decl);\n     }\n   else\n@@ -357,14 +364,37 @@ prepare_eh_table_type (tree type)\n       TREE_THIS_VOLATILE (decl) = 0;\n       layout_decl (decl, 0);\n       pushdecl (decl);\n-      rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n-      make_decl_rtl (decl, (char*) 0);\n       exp = build1 (ADDR_EXPR, build_pointer_type (utf8const_ptr_type), decl);\n-      catch_classes = tree_cons (NULL, make_catch_class_record (exp, utf8_ref), catch_classes);\n+      TYPE_CATCH_CLASSES (output_class) = \n+\ttree_cons (NULL, make_catch_class_record (exp, utf8_ref), \n+\t\t   TYPE_CATCH_CLASSES (output_class));\n     }\n+\n+  *slot = tree_cons (type, exp, NULL_TREE);\n+\n   return exp;\n }\n \n+static int\n+expand_catch_class (void **entry, void *x ATTRIBUTE_UNUSED)\n+{\n+  struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n+  tree decl = TREE_OPERAND (TREE_VALUE ((tree)ite->value), 0);\n+  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+  return true;\n+}\n+  \n+/* For every class in the TYPE_TO_RUNTIME_MAP, expand the\n+   corresponding object that is used by the runtime type matcher.  */\n+\n+void\n+java_expand_catch_classes (tree this_class)\n+{\n+  if (TYPE_TO_RUNTIME_MAP (this_class))\n+    htab_traverse \n+      (TYPE_TO_RUNTIME_MAP (this_class),\n+       expand_catch_class, NULL);\n+}\n \n /* Build a reference to the jthrowable object being carried in the\n    exception header.  */\n@@ -404,7 +434,7 @@ expand_end_java_handler (struct eh_range *range)\n       if (type == NULL)\n \ttype = throwable_type_node;\n \n-      expand_start_catch (type);\n+      expand_start_catch (prepare_eh_table_type (type));\n       expand_goto (TREE_VALUE (handler));\n       expand_end_catch ();\n     }"}, {"sha": "82c110b50c9869ad7766dc9d70ef6346b0770d0f", "filename": "gcc/java/expr.c", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,5 +1,5 @@\n /* Process expressions for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1511,17 +1511,18 @@ build_field_ref (tree self_value, tree self_class, tree name)\n       if (base_type != TREE_TYPE (self_value))\n \tself_value = fold (build1 (NOP_EXPR, base_type, self_value));\n       if (flag_indirect_dispatch\n-\t  && current_class != self_class)\n-\t/* FIXME: current_class != self_class is not exactly the right\n+\t  && output_class != self_class)\n+\t/* FIXME: output_class != self_class is not exactly the right\n \t   test.  What we really want to know is whether self_class is\n-\t   in the same translation unit as current_class.  If it is,\n+\t   in the same translation unit as output_class.  If it is,\n \t   we can make a direct reference.  */\n \t{\n-\t  tree otable_index \n-\t    = build_int_2 \n-\t    (get_symbol_table_index (field_decl, &otable_methods), 0);\n-\t  tree field_offset = build (ARRAY_REF, integer_type_node, otable_decl, \n-\t\t\t\t     otable_index);\n+\t  tree otable_index =\n+\t    build_int_2 (get_symbol_table_index \n+\t\t\t (field_decl, &TYPE_OTABLE_METHODS (output_class)), 0);\n+\t  tree field_offset = \n+\t    build (ARRAY_REF, integer_type_node, TYPE_OTABLE_DECL (output_class), \n+\t\t   otable_index);\n \t  tree address \n \t    = fold (build (PLUS_EXPR, \n \t\t\t   build_pointer_type (TREE_TYPE (field_decl)),\n@@ -1771,10 +1772,12 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t}\n       else\n \t{\n-\t  tree table_index = build_int_2 (get_symbol_table_index \n-\t\t\t\t\t  (method, &atable_methods), 0);\n-\t  func = build (ARRAY_REF,  method_ptr_type_node, atable_decl, \n-\t\t\ttable_index);\n+\t  tree table_index = \n+\t    build_int_2 (get_symbol_table_index \n+\t\t\t (method, &TYPE_ATABLE_METHODS (output_class)), 0);\n+\t  func = \n+\t    build (ARRAY_REF,  method_ptr_type_node, \n+\t\t   TYPE_ATABLE_DECL (output_class), table_index);\n \t}\n     }\n   else\n@@ -1893,8 +1896,10 @@ build_invokevirtual (tree dtable, tree method)\n   if (flag_indirect_dispatch)\n     {\n       otable_index \n-\t= build_int_2 (get_symbol_table_index (method, &otable_methods), 0);\n-      method_index = build (ARRAY_REF, integer_type_node, otable_decl, \n+\t= build_int_2 (get_symbol_table_index \n+\t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n+      method_index = build (ARRAY_REF, integer_type_node, \n+\t\t\t    TYPE_OTABLE_DECL (output_class), \n \t\t\t    otable_index);\n     }\n   else\n@@ -1957,9 +1962,12 @@ build_invokeinterface (tree dtable, tree method)\n   \n   if (flag_indirect_dispatch)\n     {\n-      otable_index \n-\t= build_int_2 (get_symbol_table_index (method, &otable_methods), 0);\n-      idx = build (ARRAY_REF, integer_type_node, otable_decl, otable_index);\n+      otable_index =\n+\tbuild_int_2 (get_symbol_table_index \n+\t\t     (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n+      idx = \n+\tbuild (ARRAY_REF, integer_type_node, TYPE_OTABLE_DECL (output_class),\n+\t       otable_index);\n     }\n   else\n     {\n@@ -2605,7 +2613,7 @@ java_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n \t  tree decl = BLOCK_EXPR_DECLS (catch);\n \t  tree type = (decl ? TREE_TYPE (TREE_TYPE (decl)) : NULL_TREE);\n \n-\t  expand_start_catch (type);\n+\t  expand_start_catch (prepare_eh_table_type (type));\n \t  expand_expr_stmt (TREE_OPERAND (current, 0));\n \t  expand_end_catch ();\n \t}"}, {"sha": "7da5055ad6cc4940c344d1b21220890e46ac7bfa", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for parsing and type checking for the GNU compiler for\n    the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -134,10 +134,17 @@ extern int compiling_from_source;\n #define main_class \\\n   java_global_trees[JTI_MAIN_CLASS]\n \n-/* The class we are currently processing. */\n+/* The class we use as the base for name resolution.  It's usually the\n+   class we're generating code for but sometimes it points to an inner\n+   class.  If you really want to know the class we're currently\n+   generating code for, use output_class instead.  */\n #define current_class \\\n   java_global_trees[JTI_CURRENT_CLASS]\n \n+/* The class we are currently generating.  Really.  */\n+#define output_class \\\n+  java_global_trees[JTI_OUTPUT_CLASS]\n+\n /* List of all class DECLs seen so far.  */\n #define all_class_list \\\n   java_global_trees[JTI_ALL_CLASS_LIST]\n@@ -147,27 +154,13 @@ extern int compiling_from_source;\n \n /* List of virtual decls referred to by this translation unit, used to\n    generate virtual method offset symbol table.  */\n-#define otable_methods java_global_trees [JTI_OTABLE_METHODS]\n-/* List of static decls referred to by this translation unit, used to\n-   generate virtual method offset symbol table.  */\n-#define atable_methods java_global_trees [JTI_ATABLE_METHODS]\n \n /* The virtual offset table.  This is emitted as uninitialized data of\n    the required length, and filled out at run time during class\n    linking. */\n-#define otable_decl java_global_trees [JTI_OTABLE_DECL]\n-/* The static address table.  */\n-#define atable_decl java_global_trees [JTI_ATABLE_DECL]\n \n /* The virtual offset symbol table. Used by the runtime to fill out\n    the otable. */\n-#define otable_syms_decl java_global_trees [JTI_OTABLE_SYMS_DECL]\n-/* The static symbol table. Used by the runtime to fill out the\n-   otable. */\n-#define atable_syms_decl java_global_trees [JTI_ATABLE_SYMS_DECL]\n-\n-#define ctable_decl java_global_trees [JTI_CTABLE_DECL]\n-#define catch_classes java_global_trees [JTI_CATCH_CLASSES]\n \n extern int flag_emit_class_files;\n \n@@ -244,6 +237,10 @@ extern const char *current_encoding;\n /* The Java .class file that provides main_class;  the main input file. */\n extern GTY(()) struct JCF * current_jcf;\n \n+/* Set to nonzero value in order to emit class initialization code\n+   before static field references.  */\n+extern int always_initialize_class_p;\n+\n typedef struct CPool constant_pool;\n \n #define CONSTANT_ResolvedFlag 16\n@@ -413,20 +410,10 @@ enum java_tree_index\n \n   JTI_MAIN_CLASS,\n   JTI_CURRENT_CLASS,\n+  JTI_OUTPUT_CLASS,\n   JTI_ALL_CLASS_LIST,\n   JTI_ALL_CLASS_FILENAME,\n \n-  JTI_OTABLE_METHODS,\n-  JTI_OTABLE_DECL,\n-  JTI_OTABLE_SYMS_DECL,\n-\n-  JTI_ATABLE_METHODS,\n-  JTI_ATABLE_DECL,\n-  JTI_ATABLE_SYMS_DECL,\n-\n-  JTI_CTABLE_DECL,\n-  JTI_CATCH_CLASSES,\n-\n   JTI_PREDEF_FILENAMES,\n \n   JTI_MAX\n@@ -923,6 +910,9 @@ union lang_tree_node\n /* The original WFL of a final variable. */\n #define DECL_FIELD_FINAL_WFL(NODE) \\\n   (DECL_LANG_SPECIFIC(NODE)->u.v.wfl)\n+/* The class that's the owner of a dynamic binding table.  */\n+#define DECL_OWNER(NODE) \\\n+  (DECL_LANG_SPECIFIC(NODE)->u.v.owner)\n /* True if NODE is a local variable final. */\n #define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))\n /* True if NODE is a final field. */\n@@ -1022,6 +1012,7 @@ struct lang_decl_var GTY(())\n   tree slot_chain;\n   tree am;\t\t\t/* Access method for this field (1.1) */\n   tree wfl;\t\t\t/* Original wfl */\n+  tree owner;\n   unsigned int final_iud : 1;\t/* Final initialized upon declaration */\n   unsigned int cif : 1;\t\t/* True: decl is a class initialization flag */\n   unsigned int freed;\t\t/* Decl is no longer in scope.  */\n@@ -1070,6 +1061,19 @@ struct lang_decl GTY(())\n #define TYPE_STRICTFP(T) (TYPE_LANG_SPECIFIC(T)->strictfp)\n #define TYPE_USES_ASSERTIONS(T) (TYPE_LANG_SPECIFIC(T)->assertions)\n \n+#define TYPE_ATABLE_METHODS(T)   (TYPE_LANG_SPECIFIC(T)->atable_methods)\n+#define TYPE_ATABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC(T)->atable_syms_decl)\n+#define TYPE_ATABLE_DECL(T)      (TYPE_LANG_SPECIFIC(T)->atable_decl)\n+\n+#define TYPE_OTABLE_METHODS(T)   (TYPE_LANG_SPECIFIC(T)->otable_methods)\n+#define TYPE_OTABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC(T)->otable_syms_decl)\n+#define TYPE_OTABLE_DECL(T)      (TYPE_LANG_SPECIFIC(T)->otable_decl)\n+\n+#define TYPE_CTABLE_DECL(T)      (TYPE_LANG_SPECIFIC(T)->ctable_decl)\n+#define TYPE_CATCH_CLASSES(T)    (TYPE_LANG_SPECIFIC(T)->catch_classes)\n+\n+#define TYPE_TO_RUNTIME_MAP(T)   (TYPE_LANG_SPECIFIC(T)->type_to_runtime_map)\n+\n struct lang_type GTY(())\n {\n   tree signature;\n@@ -1086,6 +1090,21 @@ struct lang_type GTY(())\n   tree package_list;\t\t/* List of package names, progressive */\n   tree import_list;\t\t/* Imported types, in the CU of this class */\n   tree import_demand_list;\t/* Imported types, in the CU of this class */\n+\n+  tree otable_methods;          /* List of static decls referred to by this class.  */\n+  tree otable_decl;\t\t/* The static address table.  */\n+  tree otable_syms_decl;\n+\n+  tree atable_methods;          /* List of static decls referred to by this class.  */\n+  tree atable_decl;\t\t/* The static address table.  */\n+  tree atable_syms_decl;\n+\n+  tree ctable_decl;             /* The table of classes for the runtime type matcher.  */\n+  tree catch_classes;\n+\n+  htab_t GTY ((param_is (struct treetreehash_entry))) type_to_runtime_map;   \n+                                /* The mapping of classes to exception region markers.  */\n+\n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n   unsigned strictfp:1;\t\t/* `strictfp' class.  */\n@@ -1200,6 +1219,7 @@ extern tree build_instanceof (tree, tree);\n extern tree create_label_decl (tree);\n extern void push_labeled_block (tree);\n extern tree prepare_eh_table_type (tree);\n+extern void java_expand_catch_classes (tree);\n extern tree build_exception_object_ref (tree);\n extern tree generate_name (void);\n extern void pop_labeled_block (void);\n@@ -1322,7 +1342,9 @@ extern void java_expand_body (tree);\n extern int get_symbol_table_index (tree, tree *);\n \n extern tree make_catch_class_record (tree, tree);\n-extern void emit_catch_table (void);\n+extern tree emit_catch_table (tree);\n+\n+extern void gen_indirect_dispatch_tables (tree type);\n \n #define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n "}, {"sha": "32140920676fc0dacd1ca77644ae43e54e949eda", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,5 +1,5 @@\n /* Parser for Java(TM) .class files.\n-   Copyright (C) 1996, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -72,10 +72,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n extern struct obstack temporary_obstack;\n \n-/* Set to nonzero value in order to emit class initialization code\n-   before static field references.  */\n-extern int always_initialize_class_p;\n-\n static GTY(()) tree parse_roots[3];\n \n /* The FIELD_DECL for the current field.  */\n@@ -153,7 +149,7 @@ set_source_filename (JCF *jcf, int index)\n \n #define HANDLE_CLASS_INFO(ACCESS_FLAGS, THIS, SUPER, INTERFACES_COUNT) \\\n { tree super_class = SUPER==0 ? NULL_TREE : get_class_constant (jcf, SUPER); \\\n-  current_class = give_name_to_class (jcf, THIS); \\\n+  output_class = current_class = give_name_to_class (jcf, THIS); \\\n   set_super_info (ACCESS_FLAGS, current_class, super_class, INTERFACES_COUNT);}\n \n #define HANDLE_CLASS_INTERFACE(INDEX) \\\n@@ -509,7 +505,7 @@ read_class (tree name)\n \twfl_operator = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n       EXPR_WFL_FILENAME_NODE (wfl_operator) = file;\n       input_filename = ggc_strdup (filename);\n-      current_class = NULL_TREE;\n+      output_class = current_class = NULL_TREE;\n       current_function_decl = NULL_TREE;\n       if (!HAS_BEEN_ALREADY_PARSED_P (file))\n \t{\n@@ -531,7 +527,7 @@ read_class (tree name)\n \t{\n \t  java_parser_context_save_global ();\n \t  java_push_parser_context ();\n-\t  current_class = class;\n+\t  output_class = current_class = class;\n \t  input_filename = current_jcf->filename;\n \t  if (JCF_SEEN_IN_ZIP (current_jcf))\n \t    read_zip_member(current_jcf,\n@@ -549,7 +545,7 @@ read_class (tree name)\n       load_inner_classes (class);\n     }\n \n-  current_class = save_current_class;\n+  output_class = current_class = save_current_class;\n   input_location = save_location;\n   current_jcf = save_current_jcf;\n   return 1;\n@@ -709,6 +705,8 @@ parse_class_file (void)\n      compiling from class files.  */\n   always_initialize_class_p = 1;\n \n+  gen_indirect_dispatch_tables (current_class);\n+\n   java_mark_class_local (current_class);\n \n   for (method = TYPE_METHODS (current_class);\n@@ -1099,7 +1097,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       input_filename = IDENTIFIER_POINTER (TREE_VALUE (node));\n       if (CLASS_FILE_P (node))\n \t{\n-\t  current_class = TREE_PURPOSE (node);\n+\t  output_class = current_class = TREE_PURPOSE (node);\n \t  current_jcf = TYPE_JCF (current_class);\n \t  layout_class (current_class);\n \t  load_inner_classes (current_class);\n@@ -1119,18 +1117,6 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \n       /* Emit the .jcf section.  */\n       emit_register_classes ();\n-      if (flag_indirect_dispatch)\n-\t{\n-\t  otable_decl \n-\t    = emit_symbol_table \n-\t    (get_identifier (\"otable\"), \n-\t     otable_decl, otable_methods, otable_syms_decl, integer_type_node);\n-\t  atable_decl \n-\t    = emit_symbol_table \n-\t    (get_identifier (\"atable\"), \n-\t     atable_decl, atable_methods, atable_syms_decl, ptr_type_node);\n-\t}\n-      emit_catch_table ();\n     }\n \n   write_resource_constructor ();\n@@ -1201,7 +1187,7 @@ parse_zip_file_entries (void)\n \t    class = lookup_class (get_identifier (class_name));\n \t    FREE (class_name);\n \t    current_jcf = TYPE_JCF (class);\n-\t    current_class = class;\n+\t    output_class = current_class = class;\n \n \t    if (! CLASS_LOADED_P (class))\n \t      {"}, {"sha": "2f68f7c04532a3da61e5ec34f1b610731c4b719a", "filename": "gcc/java/lang.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,5 +1,5 @@\n /* Java(TM) language-specific utility routines.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -464,6 +464,11 @@ java_init (void)\n   if (flag_inline_functions)\n     flag_inline_trees = 1;\n \n+  /* FIXME: Indirect dispatch isn't yet compatible with static class\n+     init optimization.  */\n+  if (flag_indirect_dispatch)\n+    always_initialize_class_p = true;\n+\n   /* Force minimum function alignment if g++ uses the least significant\n      bit of function pointers to store the virtual bit. This is required\n      to keep vtables compatible.  */\n@@ -967,11 +972,9 @@ inline_init_test_initialization (void **entry, void *x)\n     (DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl), ite->key);\n   if (! h)\n     return true;\n-\n   splay_tree_insert (decl_map,\n \t\t     (splay_tree_key) ite->value,\n \t\t     (splay_tree_value) h);\n-\n   return true;\n }\n \n@@ -1102,7 +1105,7 @@ java_dump_tree (void *dump_info, tree t)\n static bool\n java_decl_ok_for_sibcall (tree decl)\n {\n-  return decl != NULL && DECL_CONTEXT (decl) == current_class;\n+  return decl != NULL && DECL_CONTEXT (decl) == output_class;\n }\n \n /* Used by estimate_num_insns.  Estimate number of instructions seen\n@@ -1228,7 +1231,7 @@ java_start_inlining (tree fn)\n static tree\n java_get_callee_fndecl (tree call_expr)\n {\n-  tree method, table, element;\n+  tree method, table, element, atable_methods;\n \n   HOST_WIDE_INT index;\n \n@@ -1239,10 +1242,14 @@ java_get_callee_fndecl (tree call_expr)\n   if (TREE_CODE (method) != ARRAY_REF)\n     return NULL;\n   table = TREE_OPERAND (method, 0);\n-  if (table != atable_decl)\n+  if (! DECL_LANG_SPECIFIC(table)\n+      || !DECL_OWNER (table) \n+      || TYPE_ATABLE_DECL (DECL_OWNER (table)) != table)\n     return NULL;\n-  index = TREE_INT_CST_LOW (TREE_OPERAND (method, 1));\n \n+  atable_methods = TYPE_ATABLE_METHODS (DECL_OWNER (table));\n+  index = TREE_INT_CST_LOW (TREE_OPERAND (method, 1));\n+  \n   /* FIXME: Replace this for loop with a hash table lookup.  */\n   for (element = atable_methods; element; element = TREE_CHAIN (element))\n     {\n@@ -1257,7 +1264,7 @@ java_get_callee_fndecl (tree call_expr)\n \t}\n       --index;\n     }\n-  \n+\n   return NULL;\n }\n "}, {"sha": "20e6f9add999c3ad3a08982ad94909f3854dbaa6", "filename": "gcc/java/parse.y", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85194ee94ae7aea48bf25631aeba8b89f0f0d7d8/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=85194ee94ae7aea48bf25631aeba8b89f0f0d7d8", "patch": "@@ -1,6 +1,6 @@\n /* Source code parsing and tree node generation for the GNU compiler\n    for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n@@ -5451,7 +5451,7 @@ java_fix_constructors (void)\n       if (CLASS_INTERFACE (TYPE_NAME (class_type)))\n \tcontinue;\n \n-      current_class = class_type;\n+      output_class = current_class = class_type;\n       for (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n \t{\n \t  if (DECL_CONSTRUCTOR_P (decl))\n@@ -7575,7 +7575,7 @@ java_reorder_fields (void)\n \n   for (current = gclass_list; current; current = TREE_CHAIN (current))\n     {\n-      current_class = TREE_TYPE (TREE_VALUE (current));\n+      output_class = current_class = TREE_TYPE (TREE_VALUE (current));\n \n       if (current_class == stop_reordering)\n \tbreak;\n@@ -7632,7 +7632,7 @@ java_layout_classes (void)\n \n   for (current = gclass_list; current; current = TREE_CHAIN (current))\n     {\n-      current_class = TREE_TYPE (TREE_VALUE (current));\n+      output_class = current_class = TREE_TYPE (TREE_VALUE (current));\n       layout_class (current_class);\n \n       /* Error reported by the caller */\n@@ -7696,7 +7696,7 @@ java_complete_expand_methods (tree class_decl)\n {\n   tree clinit, decl, first_decl;\n \n-  current_class = TREE_TYPE (class_decl);\n+  output_class = current_class = TREE_TYPE (class_decl);\n \n   /* Pre-expand <clinit> to figure whether we really need it or\n      not. If we do need it, we pre-expand the static fields so they're\n@@ -9015,6 +9015,15 @@ java_expand_classes (void)\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n \n+  for (cur_ctxp = ctxp_for_generation; cur_ctxp; cur_ctxp = cur_ctxp->next)\n+    {\n+      tree current;\n+      for (current = cur_ctxp->class_list; \n+\t   current; \n+\t   current = TREE_CHAIN (current))\n+\tgen_indirect_dispatch_tables (TREE_TYPE (current));\n+    }\n+  \n   for (cur_ctxp = ctxp_for_generation; cur_ctxp; cur_ctxp = cur_ctxp->next)\n     {\n       ctxp = cur_ctxp;\n@@ -9025,7 +9034,6 @@ java_expand_classes (void)\n     }\n   input_filename = main_input_filename;\n \n-\n   /* Find anonymous classes and expand their constructor. This extra pass is\n      necessary because the constructor itself is only generated when the\n      method in which it is defined is expanded. */\n@@ -9035,7 +9043,7 @@ java_expand_classes (void)\n       ctxp = cur_ctxp;\n       for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n \t{\n-\t  current_class = TREE_TYPE (current);\n+\t  output_class = current_class = TREE_TYPE (current);\n \t  if (ANONYMOUS_CLASS_P (current_class))\n \t    {\n \t      tree d;\n@@ -9063,7 +9071,7 @@ java_expand_classes (void)\n       for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n \t{\n \t  tree d;\n-\t  current_class = TREE_TYPE (current);\n+\t  output_class = current_class = TREE_TYPE (current);\n \t  for (d = TYPE_METHODS (current_class); d; d = TREE_CHAIN (d))\n \t    {\n \t      if (DECL_RESULT (d) == NULL_TREE)\n@@ -9094,7 +9102,7 @@ java_expand_classes (void)\n \t      for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n \t\t{\n \t\t  tree d;\n-\t\t  current_class = TREE_TYPE (current);\n+\t\t  output_class = current_class = TREE_TYPE (current);\n \t\t  for (d = TYPE_METHODS (current_class); d; d = TREE_CHAIN (d))\n \t\t    {\n \t\t      if (DECL_RESULT (d) == NULL_TREE)\n@@ -9159,7 +9167,7 @@ java_expand_classes (void)\n \t   current;\n \t   current = TREE_CHAIN (current))\n \t{\n-\t  current_class = TREE_TYPE (TREE_VALUE (current));\n+\t  output_class = current_class = TREE_TYPE (TREE_VALUE (current));\n \t  if (flag_emit_class_files)\n \t    write_classfile (current_class);\n \t  if (flag_emit_xref)\n@@ -9180,7 +9188,7 @@ java_finish_classes (void)\n       ctxp = cur_ctxp;\n       for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n \t{\n-\t  current_class = TREE_TYPE (current);\n+\t  output_class = current_class = TREE_TYPE (current);\n \t  finish_class ();\n \t}\n     }"}]}