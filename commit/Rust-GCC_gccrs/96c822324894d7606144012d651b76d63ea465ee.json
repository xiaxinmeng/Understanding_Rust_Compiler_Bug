{"sha": "96c822324894d7606144012d651b76d63ea465ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZjODIyMzI0ODk0ZDc2MDYxNDQwMTJkNjUxYjc2ZDYzZWE0NjVlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T11:28:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T11:28:45Z"}, "message": "Add missing declarations for external functions in reload.c, reload1.c,\n\nand caller-save.c.\n(reload_strict_low, reload_needed_for_multiple, reload_needed_for): Deleted.\n(reload_opnum): New array.\n(enum reload_type): Renamed from reload_when_needed and expanded to include\nmore reload types.\n(reload_n_operands): New variable.\n\nFrom-SVN: r3912", "tree": {"sha": "637654b4f279446cfaff95bf3ea8e00ba3ffcf57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/637654b4f279446cfaff95bf3ea8e00ba3ffcf57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96c822324894d7606144012d651b76d63ea465ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c822324894d7606144012d651b76d63ea465ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96c822324894d7606144012d651b76d63ea465ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c822324894d7606144012d651b76d63ea465ee/comments", "author": null, "committer": null, "parents": [{"sha": "a8c9daebabca42a0f8809bb696632e76102fea52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c9daebabca42a0f8809bb696632e76102fea52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c9daebabca42a0f8809bb696632e76102fea52"}], "stats": {"total": 165, "additions": 144, "deletions": 21}, "files": [{"sha": "4369d23db3dd13568863ea32df51fbd19c8aba2d", "filename": "gcc/reload.h", "status": "modified", "additions": 144, "deletions": 21, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c822324894d7606144012d651b76d63ea465ee/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c822324894d7606144012d651b76d63ea465ee/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=96c822324894d7606144012d651b76d63ea465ee", "patch": "@@ -1,5 +1,5 @@\n /* Communication between reload.c and reload1.c.\n-   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -27,6 +27,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #endif\n #endif\n \n+#ifndef STDIO_PROTO\n+#ifdef BUFSIZ\n+#define STDIO_PROTO(ARGS) PROTO(ARGS)\n+#else\n+#define STDIO_PROTO(ARGS) ()\n+#endif\n+#endif\n+\n /* If secondary reloads are the same for inputs and outputs, define those\n    macros here.  */\n \n@@ -53,11 +61,9 @@ extern rtx reload_in_reg[MAX_RELOADS];\n extern enum reg_class reload_reg_class[MAX_RELOADS];\n extern enum machine_mode reload_inmode[MAX_RELOADS];\n extern enum machine_mode reload_outmode[MAX_RELOADS];\n-extern char reload_strict_low[MAX_RELOADS];\n extern char reload_optional[MAX_RELOADS];\n extern int reload_inc[MAX_RELOADS];\n-extern int reload_needed_for_multiple[MAX_RELOADS];\n-extern rtx reload_needed_for[MAX_RELOADS];\n+extern int reload_opnum[MAX_RELOADS];\n extern int reload_secondary_reload[MAX_RELOADS];\n extern int reload_secondary_p[MAX_RELOADS];\n #ifdef MAX_INSN_CODE\n@@ -67,22 +73,34 @@ extern int n_reloads;\n \n extern rtx reload_reg_rtx[MAX_RELOADS];\n \n-enum reload_when_needed\n+/* Encode the usage of a reload.  The following codes are supported:\n+\n+   RELOAD_FOR_INPUT\t\treload of an input operand\n+   RELOAD_FOR_OUTPUT\t\tlikewise, for output\n+   RELOAD_FOR_INSN\t\ta reload that must not conflict with anything\n+\t\t\t\tused in the insn, but may conflict with\n+\t\t\t\tsomething used before or after the insn\n+   RELOAD_FOR_INPUT_ADDRESS\treload for parts of the address of an object\n+\t\t\t\tthat is an input reload\n+   RELOAD_FOR_OUTPUT_ADDRESS\tlikewise, for output reload\n+   RELOAD_FOR_OPERAND_ADDRESS\treload for the address of a non-reloaded\n+\t\t\t\toperand; these don't conflict with\n+\t\t\t\tany other addresses.\n+   RELOAD_OTHER\t\t\tnone of the above, usually multiple uses\n+   RELOAD_FOR_OTHER_ADDRESS     reload for part of the address of an input\n+   \t\t\t\tthat is marked RELOAD_OTHER.\n+\n+   This used to be \"enum reload_when_needed\" but some debuggers have trouble\n+   with an enum tag and variable of the same name.  */\n+\n+enum reload_type\n {\n-  RELOAD_FOR_INPUT_RELOAD_ADDRESS,\n-  RELOAD_FOR_OUTPUT_RELOAD_ADDRESS,\n-  RELOAD_FOR_OPERAND_ADDRESS,\n-  /* The following two are not fully implemented.\n-     They are used in emitting insns, but they aren't distinguished from\n-     RELOAD_OTHER when computing the number of spills.  What they accomplish\n-     is to avoid precluding inheritance of already loaded values\n-     for input reloads when there are also output reloads.  */\n-  RELOAD_FOR_INPUT,\n-  RELOAD_FOR_OUTPUT,\n-  RELOAD_OTHER\n+  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN, \n+  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_OUTPUT_ADDRESS,\n+  RELOAD_FOR_OPERAND_ADDRESS, RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS\n };\n \n-extern enum reload_when_needed reload_when_needed[MAX_RELOADS];\n+extern enum reload_type reload_when_needed[MAX_RELOADS];\n \n extern rtx *reg_equiv_constant;\n extern rtx *reg_equiv_memory_loc;\n@@ -94,6 +112,9 @@ extern rtx *reg_equiv_mem;\n extern int n_earlyclobbers;\n extern rtx reload_earlyclobbers[MAX_RECOG_OPERANDS];\n \n+/* Save the number of operands.  */\n+extern int reload_n_operands;\n+\n /* First uid used by insns created by reload in this function.\n    Used in find_equiv_reg.  */\n extern int reload_first_uid;\n@@ -115,10 +136,112 @@ extern enum insn_code reload_in_optab[];\n extern enum insn_code reload_out_optab[];\n #endif\n \n-extern void init_reload PROTO((void));\n+/* Functions from reload.c:  */\n+\n+/* Return a memory location that will be used to copy X in mode MODE.  \n+   If we haven't already made a location for this mode in this insn,\n+   call find_reloads_address on the location being returned.  */\n+extern rtx get_secondary_mem PROTO((rtx, enum machine_mode,\n+\t\t\t\t    int, enum reload_type));\n+\n+/* Clear any secondary memory locations we've made.  */\n+extern void clear_secondary_mem PROTO((void));\n+\n+/* Transfer all replacements that used to be in reload FROM to be in\n+   reload TO.  */\n+extern void transfer_replacements PROTO((int, int));\n+\n+/* Return 1 if ADDR is a valid memory address for mode MODE,\n+   and check that each pseudo reg has the proper kind of\n+   hard reg.  */\n+extern int strict_memory_address_p PROTO((enum machine_mode, rtx));\n+\n+/* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n+   if they are the same hard reg, and has special hacks for\n+   autoincrement and autodecrement.  */\n+extern int operands_match_p PROTO((rtx, rtx));\n+\n+/* Return the number of times character C occurs in string S.  */\n+extern int n_occurrences PROTO((int, char *));\n+\n+/* Return 1 if altering OP will not modify the value of CLOBBER. */\n+extern int safe_from_earlyclobber PROTO((rtx, rtx));\n+\n+/* Search the body of INSN for values that need reloading and record them\n+   with push_reload.  REPLACE nonzero means record also where the values occur\n+   so that subst_reloads can be used.\n extern void find_reloads PROTO((rtx, int, int, int, short *));\n+\n+/* Compute the sum of X and Y, making canonicalizations assumed in an\n+   address, namely: sum constant integers, surround the sum of two\n+   constants with a CONST, put the constant as the second operand, and\n+   group the constant on the outermost sum.  */\n+extern rtx form_sum PROTO((rtx, rtx));\n+\n+/* Substitute into the current INSN the registers into which we have reloaded\n+   the things that need reloading.  */\n extern void subst_reloads PROTO((void));\n-extern rtx get_secondary_mem PROTO((rtx, enum machine_mode));\n-extern rtx eliminate_regs PROTO((rtx, enum machine_mode, rtx));\n-extern rtx gen_input_reload PROTO((rtx, rtx, rtx));\n+\n+/* Make a copy of any replacements being done into X and move those copies\n+   to locations in Y, a copy of X.  We only look at the highest level of\n+   the RTL.  */\n+extern void copy_replacements PROTO((rtx, rtx));\n+\n+/* If LOC was scheduled to be replaced by something, return the replacement.\n+   Otherwise, return *LOC.  */\n extern rtx find_replacement PROTO((rtx *));\n+\n+/* Return nonzero if register in range [REGNO, ENDREGNO)\n+   appears either explicitly or implicitly in X\n+   other than being stored into.  */\n+extern int refers_to_regno_for_reload_p PROTO((int, int, rtx, rtx *));\n+\n+/* Nonzero if modifying X will affect IN.  */\n+extern int reg_overlap_mentioned_for_reload_p PROTO((rtx, rtx));\n+\n+/* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n+   registers.  */\n+extern int refers_to_mem_for_reload_p PROTO((rtx));\n+\n+/* Check the insns before INSN to see if there is a suitable register\n+   containing the same value as GOAL.  */\n+extern rtx find_equiv_reg PROTO((rtx, rtx, enum reg_class, int, short *,\n+\t\t\t\t int, enum machine_mode));\n+\n+/* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n+extern int regno_clobbered_p PROTO((int, rtx));\n+\n+\n+/* Functions in reload1.c:  */\n+\n+/* Initialize the reload pass once per compilation.  */\n+extern void init_reload PROTO((void));\n+\n+/* The reload pass itself.  */\n+extern int reload STDIO_PROTO((rtx, int, FILE *));\n+\n+/* Mark the slots in regs_ever_live for the hard regs\n+   used by pseudo-reg number REGNO.  */\n+extern void mark_home_live PROTO((int));\n+\n+/* Scan X and replace any eliminable registers (such as fp) with a\n+   replacement (such as sp), plus an offset.  */\n+extern rtx eliminate_regs PROTO((rtx, enum machine_mode, rtx));\n+\n+/* Emit code to perform an input reload of IN to RELOADREG.  IN is from\n+   operand OPNUM with reload type TYPE.   */\n+extern rtx gen_input_reload PROTO((rtx, rtx, int, enum reload_type));\n+\n+/* Functions in caller-save.c:  */\n+\n+/* Initialize for caller-save.  */\n+extern void init_caller_save PROTO((void));\n+\n+/* Initialize save areas by showing that we haven't allocated any yet.  */\n+extern void init_save_areas PROTO((void));\n+\n+/* Allocate save areas for any hard registers that might need saving.  */\n+extern int setup_save_areas PROTO((int *));\n+\n+/* Find the places where hard regs are live across calls and save them.  */\n+extern void save_call_clobbered_regs PROTO((enum machine_mode));"}]}