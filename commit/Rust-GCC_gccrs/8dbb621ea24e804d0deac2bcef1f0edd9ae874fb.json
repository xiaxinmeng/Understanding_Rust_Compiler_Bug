{"sha": "8dbb621ea24e804d0deac2bcef1f0edd9ae874fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRiYjYyMWVhMjRlODA0ZDBkZWFjMmJjZWYxZjBlZGQ5YWU4NzRmYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-10-31T17:46:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:46:26Z"}, "message": "s-taprop-solaris.adb: (Time_Slice_Val): Change type to Integer.\n\n2006-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* s-taprop-solaris.adb: (Time_Slice_Val): Change type to Integer.\n\t(Initialize): Add type conversions required by above change.\n\nFrom-SVN: r118238", "tree": {"sha": "db32f236a83396f1a413520a42773fc5ab6017c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db32f236a83396f1a413520a42773fc5ab6017c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dbb621ea24e804d0deac2bcef1f0edd9ae874fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dbb621ea24e804d0deac2bcef1f0edd9ae874fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dbb621ea24e804d0deac2bcef1f0edd9ae874fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dbb621ea24e804d0deac2bcef1f0edd9ae874fb/comments", "author": null, "committer": null, "parents": [{"sha": "f95969eabcd42f10aa4b4ae3c13015e417031523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95969eabcd42f10aa4b4ae3c13015e417031523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95969eabcd42f10aa4b4ae3c13015e417031523"}], "stats": {"total": 148, "additions": 72, "deletions": 76}, "files": [{"sha": "9da267ec4773407cc4a0e92b062851934a4073fa", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 72, "deletions": 76, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dbb621ea24e804d0deac2bcef1f0edd9ae874fb/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dbb621ea24e804d0deac2bcef1f0edd9ae874fb/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=8dbb621ea24e804d0deac2bcef1f0edd9ae874fb", "patch": "@@ -141,7 +141,7 @@ package body System.Task_Primitives.Operations is\n    -- External Configuration Values --\n    -----------------------------------\n \n-   Time_Slice_Val : Interfaces.C.long;\n+   Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n \n    Locking_Policy : Character;\n@@ -151,7 +151,7 @@ package body System.Task_Primitives.Operations is\n    pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n \n    Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads).\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n \n    -----------------------\n    -- Local Subprograms --\n@@ -216,31 +216,31 @@ package body System.Task_Primitives.Operations is\n \n       procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n-      --  Initialize various data needed by this package.\n+      --  Initialize various data needed by this package\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n       procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n-      --  Set the self id for the current task.\n+      --  Set the self id for the current task\n \n       function Self return Task_Id;\n       pragma Inline (Self);\n-      --  Return a pointer to the Ada Task Control Block of the calling task.\n+      --  Return a pointer to the Ada Task Control Block of the calling task\n \n    end Specific;\n \n    package body Specific is separate;\n-   --  The body of this package is target specific.\n+   --  The body of this package is target specific\n \n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n \n    function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n-   --  Allocate and Initialize a new ATCB for the current Thread.\n+   --  Allocate and Initialize a new ATCB for the current Thread\n \n    function Register_Foreign_Thread\n      (Thread : Thread_Id) return Task_Id is separate;\n@@ -353,6 +353,7 @@ package body System.Task_Primitives.Operations is\n \n       begin\n          if Proc_Acc.all'Length /= 0 then\n+\n             --  Environment variable is defined\n \n             Last_Proc := Num_Procs - 1;\n@@ -438,11 +439,13 @@ package body System.Task_Primitives.Operations is\n             --  If a pragma Time_Slice is specified, takes the value in account\n \n             if Time_Slice_Val > 0 then\n+\n                --  Convert Time_Slice_Val (microseconds) into seconds and\n                --  nanoseconds\n \n-               Secs := Time_Slice_Val / 1_000_000;\n-               Nsecs := (Time_Slice_Val rem 1_000_000) * 1_000;\n+               Secs := Interfaces.C.long (Time_Slice_Val / 1_000_000);\n+               Nsecs :=\n+                 Interfaces.C.long ((Time_Slice_Val rem 1_000_000) * 1_000);\n \n             --  Otherwise, default to no time slicing (i.e run until blocked)\n \n@@ -451,7 +454,7 @@ package body System.Task_Primitives.Operations is\n                Nsecs := RT_TQINF;\n             end if;\n \n-            --  Get the real time class id.\n+            --  Get the real time class id\n \n             Class_Info.pc_clname (1) := 'R';\n             Class_Info.pc_clname (2) := 'T';\n@@ -482,7 +485,7 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Set (Environment_Task);\n \n-      --  Initialize the lock used to synchronize chain of all ATCBs.\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n@@ -699,7 +702,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock or else Global_Lock then\n          pragma Assert (Check_Unlock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n@@ -710,7 +712,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if not Single_Lock then\n          pragma Assert (Check_Unlock (To_Lock_Ptr (T.Common.LL.L'Access)));\n@@ -820,7 +821,6 @@ package body System.Task_Primitives.Operations is\n               thr_setprio (T.Common.LL.Thread, Interfaces.C.int (Prio));\n \n          else\n-\n             --  The task is bound to a LWP, use priocntl\n             --  ??? TBD\n \n@@ -942,7 +942,7 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int := 0;\n \n    begin\n-      --  Give the task a unique serial number.\n+      --  Give the task a unique serial number\n \n       Self_ID.Serial_Number := Next_Serial_Number;\n       Next_Serial_Number := Next_Serial_Number + 1;\n@@ -1132,21 +1132,19 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = EINTR);\n    end Sleep;\n \n-   --  Note that we are relying heaviliy here on the GNAT feature\n-   --  that Calendar.Time, System.Real_Time.Time, Duration, and\n-   --  System.Real_Time.Time_Span are all represented in the same\n+   --  Note that we are relying heaviliy here on GNAT represting Calendar.Time,\n+   --  System.Real_Time.Time, Duration, System.Real_Time.Time_Span in the same\n    --  way, i.e., as a 64-bit count of nanoseconds.\n \n-   --  This allows us to always pass the timeout value as a Duration.\n+   --  This allows us to always pass the timeout value as a Duration\n \n    --  ???\n-   --  We are taking liberties here with the semantics of the delays.\n-   --  That is, we make no distinction between delays on the Calendar clock\n-   --  and delays on the Real_Time clock. That is technically incorrect, if\n-   --  the Calendar clock happens to be reset or adjusted.\n-   --  To solve this defect will require modification to the compiler\n-   --  interface, so that it can pass through more information, to tell\n-   --  us here which clock to use!\n+   --  We are taking liberties here with the semantics of the delays. That is,\n+   --  we make no distinction between delays on the Calendar clock and delays\n+   --  on the Real_Time clock. That is technically incorrect, if the Calendar\n+   --  clock happens to be reset or adjusted. To solve this defect will require\n+   --  modification to the compiler interface, so that it can pass through more\n+   --  information, to tell us here which clock to use!\n \n    --  cond_timedwait will return if any of the following happens:\n    --  1) some other task did cond_signal on this condition variable\n@@ -1161,47 +1159,42 @@ package body System.Task_Primitives.Operations is\n    --     UNIX calls this an \"interrupted\" system call.\n    --     In this case, the return value is EINTR\n \n-   --  If the cond_timedwait returns 0 or EINTR, it is still\n-   --  possible that the time has actually expired, and by chance\n-   --  a signal or cond_signal occurred at around the same time.\n-\n-   --  We have also observed that on some OS's the value ETIME\n-   --  will be returned, but the clock will show that the full delay\n-   --  has not yet expired.\n-\n-   --  For these reasons, we need to check the clock after return\n-   --  from cond_timedwait.  If the time has expired, we will set\n-   --  Timedout = True.\n-\n-   --  This check might be omitted for systems on which the\n-   --  cond_timedwait() never returns early or wakes up spuriously.\n-\n-   --  Annex D requires that completion of a delay cause the task\n-   --  to go to the end of its priority queue, regardless of whether\n-   --  the task actually was suspended by the delay. Since\n-   --  cond_timedwait does not do this on Solaris, we add a call\n-   --  to thr_yield at the end. We might do this at the beginning,\n-   --  instead, but then the round-robin effect would not be the\n-   --  same; the delayed task would be ahead of other tasks of the\n-   --  same priority that awoke while it was sleeping.\n-\n-   --  For Timed_Sleep, we are expecting possible cond_signals\n-   --  to indicate other events (e.g., completion of a RV or\n-   --  completion of the abortable part of an async. select),\n-   --  we want to always return if interrupted. The caller will\n-   --  be responsible for checking the task state to see whether\n-   --  the wakeup was spurious, and to go back to sleep again\n-   --  in that case.  We don't need to check for pending abort\n-   --  or priority change on the way in our out; that is the\n-   --  caller's responsibility.\n-\n-   --  For Timed_Delay, we are not expecting any cond_signals or\n-   --  other interruptions, except for priority changes and aborts.\n-   --  Therefore, we don't want to return unless the delay has\n-   --  actually expired, or the call has been aborted. In this\n-   --  case, since we want to implement the entire delay statement\n-   --  semantics, we do need to check for pending abort and priority\n-   --  changes. We can quietly handle priority changes inside the\n+   --  If the cond_timedwait returns 0 or EINTR, it is still possible that the\n+   --  time has actually expired, and by chance a signal or cond_signal\n+   --  occurred at around the same time.\n+\n+   --  We have also observed that on some OS's the value ETIME will be\n+   --  returned, but the clock will show that the full delay has not yet\n+   --  expired.\n+\n+   --  For these reasons, we need to check the clock after return from\n+   --  cond_timedwait. If the time has expired, we will set Timedout = True.\n+\n+   --  This check might be omitted for systems on which the cond_timedwait()\n+   --  never returns early or wakes up spuriously.\n+\n+   --  Annex D requires that completion of a delay cause the task to go to the\n+   --  end of its priority queue, regardless of whether the task actually was\n+   --  suspended by the delay. Since cond_timedwait does not do this on\n+   --  Solaris, we add a call to thr_yield at the end. We might do this at the\n+   --  beginning, instead, but then the round-robin effect would not be the\n+   --  same; the delayed task would be ahead of other tasks of the same\n+   --  priority that awoke while it was sleeping.\n+\n+   --  For Timed_Sleep, we are expecting possible cond_signals to indicate\n+   --  other events (e.g., completion of a RV or completion of the abortable\n+   --  part of an async. select), we want to always return if interrupted. The\n+   --  caller will be responsible for checking the task state to see whether\n+   --  the wakeup was spurious, and to go back to sleep again in that case. We\n+   --  don't need to check for pending abort or priority change on the way in\n+   --  our out; that is the caller's responsibility.\n+\n+   --  For Timed_Delay, we are not expecting any cond_signals or other\n+   --  interruptions, except for priority changes and aborts. Therefore, we\n+   --  don't want to return unless the delay has actually expired, or the call\n+   --  has been aborted. In this case, since we want to implement the entire\n+   --  delay statement semantics, we do need to check for pending abort and\n+   --  priority changes. We can quietly handle priority changes inside the\n    --  procedure, since there is no entry-queue reordering involved.\n \n    -----------------\n@@ -1273,9 +1266,9 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes)\n+     (Self_ID : Task_Id;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes)\n    is\n       Check_Time : constant Duration := Monotonic_Clock;\n       Abs_Time   : Duration;\n@@ -1313,11 +1306,15 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n             if Single_Lock then\n-               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Single_RTS_Lock.L'Access, Request'Access);\n+               Result := cond_timedwait\n+                           (Self_ID.Common.LL.CV'Access,\n+                            Single_RTS_Lock.L'Access,\n+                            Request'Access);\n             else\n-               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n-                 Self_ID.Common.LL.L.L'Access, Request'Access);\n+               Result := cond_timedwait\n+                           (Self_ID.Common.LL.CV'Access,\n+                            Self_ID.Common.LL.L.L'Access,\n+                            Request'Access);\n             end if;\n \n             Yielded := True;\n@@ -1824,8 +1821,7 @@ package body System.Task_Primitives.Operations is\n \n    function Check_Exit (Self_ID : Task_Id) return Boolean is\n    begin\n-      --  Check that caller is just holding Global_Task_Lock\n-      --  and no other locks\n+      --  Check that caller is just holding Global_Task_Lock and no other locks\n \n       if Self_ID.Common.LL.Locks = null then\n          return False;"}]}