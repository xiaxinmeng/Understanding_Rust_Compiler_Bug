{"sha": "4a907b15b551becd3145061a8906089267db5a04", "node_id": "C_kwDOANBUbNoAKDRhOTA3YjE1YjU1MWJlY2QzMTQ1MDYxYTg5MDYwODkyNjdkYjVhMDQ", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-24T09:45:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-24T09:47:05Z"}, "message": "Move things around in predicate analysis\n\nThis moves a few functions, notably normalization after a big comment\ndocumenting it.  I've left the rest unorganized for now.\n\n\t* gimple-predicate-analysis.cc: Move predicate normalization\n\tafter the comment documenting it.", "tree": {"sha": "9f8de5febbecef6f21b447c11c324f4f6fb585e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f8de5febbecef6f21b447c11c324f4f6fb585e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a907b15b551becd3145061a8906089267db5a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a907b15b551becd3145061a8906089267db5a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a907b15b551becd3145061a8906089267db5a04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a907b15b551becd3145061a8906089267db5a04/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd1216d581b44f14b93a427bf2e95ee37e394b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1216d581b44f14b93a427bf2e95ee37e394b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1216d581b44f14b93a427bf2e95ee37e394b8b"}], "stats": {"total": 996, "additions": 498, "deletions": 498}, "files": [{"sha": "079e06009fdeb0ce8479bf15befb0cfbd39bfa5a", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 498, "deletions": 498, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a907b15b551becd3145061a8906089267db5a04/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a907b15b551becd3145061a8906089267db5a04/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=4a907b15b551becd3145061a8906089267db5a04", "patch": "@@ -1694,570 +1694,284 @@ predicate::simplify (gimple *use_or_def, bool is_use)\n   (_2 RELOP1 _1) AND (_5 RELOP2 _4) AND (_8 RELOP3 _7) AND (_0 != 0)\n   */\n \n-/* Store a PRED in *THIS.  */\n-\n-void\n-predicate::push_pred (const pred_info &pred)\n-{\n-  pred_chain chain = vNULL;\n-  chain.safe_push (pred);\n-  m_preds.safe_push (chain);\n-}\n-\n-/* Dump predicates in *THIS for STMT prepended by MSG.  */\n+/* Normalize predicate PRED:\n+   1) if PRED can no longer be normalized, append it to *THIS.\n+   2) otherwise if PRED is of the form x != 0, follow x's definition\n+      and put normalized predicates into WORK_LIST.  */\n \n void\n-predicate::dump (gimple *stmt, const char *msg) const\n+predicate::normalize (pred_chain *norm_chain,\n+\t\t      pred_info pred,\n+\t\t      tree_code and_or_code,\n+\t\t      pred_chain *work_list,\n+\t\t      hash_set<tree> *mark_set)\n {\n-  fprintf (dump_file, \"%s\", msg);\n-  if (stmt)\n+  if (!is_neq_zero_form_p (pred))\n     {\n-      fputc ('\\t', dump_file);\n-      print_gimple_stmt (dump_file, stmt, 0);\n-      fprintf (dump_file, \"  is conditional on:\\n\");\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (pred);\n+      else\n+\tnorm_chain->safe_push (pred);\n+      return;\n     }\n \n-  unsigned np = m_preds.length ();\n-  if (np == 0)\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+\n+  if (gimple_code (def_stmt) == GIMPLE_PHI\n+      && is_degenerate_phi (def_stmt, &pred))\n+    /* PRED has been modified above.  */\n+    work_list->safe_push (pred);\n+  else if (gimple_code (def_stmt) == GIMPLE_PHI && and_or_code == BIT_IOR_EXPR)\n     {\n-      fprintf (dump_file, \"\\t(empty)\\n\");\n-      return;\n-    }\n+      unsigned n = gimple_phi_num_args (def_stmt);\n \n-  {\n-    tree expr = build_pred_expr (m_preds);\n-    char *str = print_generic_expr_to_str (expr);\n-    fprintf (dump_file, \"\\t%s (expanded)\\n\", str);\n-    free (str);\n-  }\n+      /* Punt for a nonzero constant.  The predicate should be one guarding\n+\t the phi edge.  */\n+      for (unsigned i = 0; i < n; ++i)\n+\t{\n+\t  tree op = gimple_phi_arg_def (def_stmt, i);\n+\t  if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n+\t    {\n+\t      push_pred (pred);\n+\t      return;\n+\t    }\n+\t}\n \n-  if (np > 1)\n-    fprintf (dump_file, \"\\tOR (\");\n+      for (unsigned i = 0; i < n; ++i)\n+\t{\n+\t  tree op = gimple_phi_arg_def (def_stmt, i);\n+\t  if (integer_zerop (op))\n+\t    continue;\n+\n+\t  push_to_worklist (op, work_list, mark_set);\n+\t}\n+    }\n+  else if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+    {\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (pred);\n+      else\n+\tnorm_chain->safe_push (pred);\n+    }\n+  else if (gimple_assign_rhs_code (def_stmt) == and_or_code)\n+    {\n+      /* Avoid splitting up bit manipulations like x & 3 or y | 1.  */\n+      if (is_gimple_min_invariant (gimple_assign_rhs2 (def_stmt)))\n+\t{\n+\t  /* But treat x & 3 as a condition.  */\n+\t  if (and_or_code == BIT_AND_EXPR)\n+\t    {\n+\t      pred_info n_pred;\n+\t      n_pred.pred_lhs = gimple_assign_rhs1 (def_stmt);\n+\t      n_pred.pred_rhs = gimple_assign_rhs2 (def_stmt);\n+\t      n_pred.cond_code = and_or_code;\n+\t      n_pred.invert = false;\n+\t      norm_chain->safe_push (n_pred);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  push_to_worklist (gimple_assign_rhs1 (def_stmt), work_list, mark_set);\n+\t  push_to_worklist (gimple_assign_rhs2 (def_stmt), work_list, mark_set);\n+\t}\n+    }\n+  else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n+\t   == tcc_comparison)\n+    {\n+      pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (n_pred);\n+      else\n+\tnorm_chain->safe_push (n_pred);\n+    }\n   else\n-    fputc ('\\t', dump_file);\n-  for (unsigned i = 0; i < np; i++)\n     {\n-      dump_pred_chain (m_preds[i]);\n-      if (i < np - 1)\n-\tfprintf (dump_file, \", \");\n-      else if (i > 0)\n-\tfputc (')', dump_file);\n+      if (and_or_code == BIT_IOR_EXPR)\n+\tpush_pred (pred);\n+      else\n+\tnorm_chain->safe_push (pred);\n     }\n-  fputc ('\\n', dump_file);\n }\n \n-/* Initialize USE_PREDS with the predicates of the control dependence chains\n-   between the basic block DEF_BB that defines a variable of interst and\n-   USE_BB that uses the variable, respectively.  */\n+/* Normalize PRED and store the normalized predicates in THIS->M_PREDS.  */\n \n-bool\n-uninit_analysis::init_use_preds (predicate &use_preds, basic_block def_bb,\n-\t\t\t\t basic_block use_bb)\n+void\n+predicate::normalize (const pred_info &pred)\n {\n-  gcc_assert (use_preds.is_empty ());\n-\n-  /* Set CD_ROOT to the basic block closest to USE_BB that is the control\n-     equivalent of (is guarded by the same predicate as) DEF_BB that also\n-     dominates USE_BB.  */\n-  basic_block cd_root = def_bb;\n-  while (dominated_by_p (CDI_DOMINATORS, use_bb, cd_root))\n+  if (!is_neq_zero_form_p (pred))\n     {\n-      /* Find CD_ROOT's closest postdominator that's its control\n-\t equivalent.  */\n-      if (basic_block bb = find_control_equiv_block (cd_root))\n-\tif (dominated_by_p (CDI_DOMINATORS, use_bb, bb))\n-\t  {\n-\t    cd_root = bb;\n-\t    continue;\n-\t  }\n-\n-      break;\n+      push_pred (pred);\n+      return;\n     }\n \n-  /* Set DEP_CHAINS to the set of edges between CD_ROOT and USE_BB.\n-     Each DEP_CHAINS element is a series of edges whose conditions\n-     are logical conjunctions.  Together, the DEP_CHAINS vector is\n-     used below to initialize an OR expression of the conjunctions.  */\n-  unsigned num_calls = 0;\n-  unsigned num_chains = 0;\n-  auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n-  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+  tree_code and_or_code = ERROR_MARK;\n \n-  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n-\t\t\t\t  cur_chain, &num_calls))\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+  if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n+    and_or_code = gimple_assign_rhs_code (def_stmt);\n+  if (and_or_code != BIT_IOR_EXPR && and_or_code != BIT_AND_EXPR)\n     {\n-      gcc_assert (num_chains == 0);\n-      simple_control_dep_chain (dep_chains[0], cd_root, use_bb);\n-      num_chains++;\n+      if (TREE_CODE_CLASS (and_or_code) == tcc_comparison)\n+\t{\n+\t  pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n+\t  push_pred (n_pred);\n+\t}\n+      else\n+\tpush_pred (pred);\n+      return;\n     }\n \n-  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\n+  pred_chain norm_chain = vNULL;\n+  pred_chain work_list = vNULL;\n+  work_list.safe_push (pred);\n+  hash_set<tree> mark_set;\n+\n+  while (!work_list.is_empty ())\n     {\n-      fprintf (dump_file, \"predicate::predicate (def_bb = %u, use_bb = %u, func_t) \"\n-\t       \"initialized from %u dep_chains:\\n\\t\",\n-\t       def_bb->index, use_bb->index, num_chains);\n-      dump_dep_chains (dep_chains, num_chains);\n+      pred_info a_pred = work_list.pop ();\n+      normalize (&norm_chain, a_pred, and_or_code, &work_list, &mark_set);\n     }\n \n-  /* From the set of edges computed above initialize *THIS as the OR\n-     condition under which the definition in DEF_BB is used in USE_BB.\n-     Each OR subexpression is represented by one element of DEP_CHAINS,\n-     where each element consists of a series of AND subexpressions.  */\n-  use_preds.init_from_control_deps (dep_chains, num_chains);\n-  return !use_preds.is_empty ();\n-}\n-\n-/* Release resources in *THIS.  */\n+  if (and_or_code == BIT_AND_EXPR)\n+    m_preds.safe_push (norm_chain);\n \n-predicate::~predicate ()\n-{\n-  unsigned n = m_preds.length ();\n-  for (unsigned i = 0; i != n; ++i)\n-    m_preds[i].release ();\n-  m_preds.release ();\n+  work_list.release ();\n }\n \n-/* Copy-assign RHS to *THIS.  */\n+/* Normalize a single predicate PRED_CHAIN and append it to *THIS.  */\n \n-predicate&\n-predicate::operator= (const predicate &rhs)\n+void\n+predicate::normalize (const pred_chain &chain)\n {\n-  if (this == &rhs)\n-    return *this;\n-\n-  unsigned n = m_preds.length ();\n-  for (unsigned i = 0; i != n; ++i)\n-    m_preds[i].release ();\n-  m_preds.release ();\n+  pred_chain work_list = vNULL;\n+  hash_set<tree> mark_set;\n+  for (unsigned i = 0; i < chain.length (); i++)\n+    {\n+      work_list.safe_push (chain[i]);\n+      mark_set.add (chain[i].pred_lhs);\n+    }\n \n-  n = rhs.m_preds.length ();\n-  for (unsigned i = 0; i != n; ++i)\n+  /* Normalized chain of predicates built up below.  */\n+  pred_chain norm_chain = vNULL;\n+  while (!work_list.is_empty ())\n     {\n-      const pred_chain &chain = rhs.m_preds[i];\n-      m_preds.safe_push (chain.copy ());\n+      pred_info pi = work_list.pop ();\n+      predicate pred;\n+      /* The predicate object is not modified here, only NORM_CHAIN and\n+\t WORK_LIST are appended to.  */\n+      pred.normalize (&norm_chain, pi, BIT_AND_EXPR, &work_list, &mark_set);\n     }\n \n-  return *this;\n+  m_preds.safe_push (norm_chain);\n+  work_list.release ();\n }\n \n-/* For each use edge of PHI, compute all control dependence chains\n-   and convert those to the composite predicates in M_PREDS.\n-   Return true if a nonempty predicate has been obtained.  */\n+/* Normalize predicate chains in THIS.  */\n \n-bool\n-uninit_analysis::init_from_phi_def (gphi *phi)\n+void\n+predicate::normalize (gimple *use_or_def, bool is_use)\n {\n-  gcc_assert (m_phi_def_preds.is_empty ());\n-\n-  basic_block phi_bb = gimple_bb (phi);\n-  /* Find the closest dominating bb to be the control dependence root.  */\n-  basic_block cd_root = get_immediate_dominator (CDI_DOMINATORS, phi_bb);\n-  if (!cd_root)\n-    return false;\n-\n-  /* Set DEF_EDGES to the edges to the PHI from the bb's that provide\n-     definitions of each of the PHI operands for which M_EVAL is false.  */\n-  auto_vec<edge> def_edges;\n-  hash_set<gimple *> visited_phis;\n-  collect_phi_def_edges (phi, cd_root, &def_edges, &visited_phis);\n-\n-  unsigned nedges = def_edges.length ();\n-  if (nedges == 0)\n-    return false;\n-\n-  unsigned num_chains = 0;\n-  auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n-  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n-  for (unsigned i = 0; i < nedges; i++)\n+  if (dump_file && dump_flags & TDF_DETAILS)\n     {\n-      edge e = def_edges[i];\n-      unsigned num_calls = 0;\n-      unsigned prev_nc = num_chains;\n-      compute_control_dep_chain (cd_root, e->src, dep_chains,\n-\t\t\t\t &num_chains, cur_chain, &num_calls);\n-\n-      /* Update the newly added chains with the phi operand edge.  */\n-      if (EDGE_COUNT (e->src->succs) > 1)\n-\t{\n-\t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n-\t    dep_chains[num_chains++] = vNULL;\n-\t  for (unsigned j = prev_nc; j < num_chains; j++)\n-\t    dep_chains[j].safe_push (e);\n-\t}\n+      fprintf (dump_file, \"Before normalization \");\n+      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n     }\n \n-  /* Convert control dependence chains to the predicate in *THIS under\n-     which the PHI operands are defined to values for which M_EVAL is\n-     false.  */\n-  m_phi_def_preds.init_from_control_deps (dep_chains, num_chains);\n-  return !m_phi_def_preds.is_empty ();\n-}\n-\n-/* Compute the predicates that guard the use USE_STMT and check if\n-   the incoming paths that have an empty (or possibly empty) definition\n-   can be pruned.  Return true if it can be determined that the use of\n-   PHI's def in USE_STMT is guarded by a predicate set that does not\n-   overlap with the predicate sets of all runtime paths that do not\n-   have a definition.\n-\n-   Return false if the use is not guarded or if it cannot be determined.\n-   USE_BB is the bb of the use (for phi operand use, the bb is not the bb\n-   of the phi stmt, but the source bb of the operand edge).\n-\n-   OPNDS is a bitmap with a bit set for each PHI operand of interest.\n-\n-   THIS->M_PREDS contains the (memoized) defining predicate chains of\n-   a PHI.  If THIS->M_PREDS is empty, the PHI's defining predicate\n-   chains are computed and stored into THIS->M_PREDS as needed.\n-\n-   VISITED_PHIS is a pointer set of phis being visited.  */\n-\n-bool\n-uninit_analysis::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n-\t\t\t\t gphi *phi, unsigned opnds,\n-\t\t\t\t hash_set<gphi *> *visited)\n-{\n-  if (visited->add (phi))\n-    return false;\n-\n-  /* The basic block where the PHI is defined.  */\n-  basic_block def_bb = gimple_bb (phi);\n-\n-  if (dominated_by_p (CDI_POST_DOMINATORS, def_bb, use_bb))\n-    /* The use is not guarded.  */\n-    return false;\n-\n-  /* Try to build the predicate expression under which the PHI flows\n-     into its use.  This will be empty if the PHI is defined and used\n-     in the same bb.  */\n-  predicate use_preds;\n-  if (!init_use_preds (use_preds, def_bb, use_bb))\n-    return false;\n-\n-  /* Try to prune the dead incoming phi edges.  */\n-  if (!overlap (phi, opnds, visited, use_preds))\n+  predicate norm_preds;\n+  for (unsigned i = 0; i < m_preds.length (); i++)\n     {\n-      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n-\tfputs (\"found predicate overlap\\n\", dump_file);\n-\n-      return true;\n+      if (m_preds[i].length () != 1)\n+\tnorm_preds.normalize (m_preds[i]);\n+      else\n+\tnorm_preds.normalize (m_preds[i][0]);\n     }\n \n-  /* We might be able to prove that if the control dependencies for OPNDS\n-     are true, the control dependencies for USE_STMT can never be true.  */\n-  if (use_cannot_happen (phi, opnds, use_preds))\n-    return true;\n+  *this = norm_preds;\n \n-  if (m_phi_def_preds.is_empty ())\n+  if (dump_file)\n     {\n-      /* Lazily initialize *THIS from PHI.  */\n-      if (!init_from_phi_def (phi))\n-\treturn false;\n-\n-      m_phi_def_preds.simplify (phi);\n-      m_phi_def_preds.normalize (phi);\n+      fprintf (dump_file, \"After normalization \");\n+      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n     }\n-\n-  use_preds.simplify (use_stmt, /*is_use=*/true);\n-  use_preds.normalize (use_stmt, /*is_use=*/true);\n-\n-  /* Return true if the predicate guarding the valid definition (i.e.,\n-     *THIS) is a superset of the predicate guarding the use (i.e.,\n-     USE_PREDS).  */\n-  if (m_phi_def_preds.superset_of (use_preds))\n-    return true;\n-\n-  return false;\n }\n \n-/* Public interface to the above. */\n+/* Convert the chains of control dependence edges into a set of predicates.\n+   A control dependence chain is represented by a vector edges.  DEP_CHAINS\n+   points to an array of NUM_CHAINS dependence chains. One edge in\n+   a dependence chain is mapped to predicate expression represented by\n+   pred_info type.  One dependence chain is converted to a composite\n+   predicate that is the result of AND operation of pred_info mapped to\n+   each edge.  A composite predicate is represented by a vector of\n+   pred_info.  Sets M_PREDS to the resulting composite predicates.  */\n \n-bool\n-uninit_analysis::is_use_guarded (gimple *stmt, basic_block use_bb, gphi *phi,\n-\t\t\t\t unsigned opnds)\n+void\n+predicate::init_from_control_deps (const vec<edge> *dep_chains,\n+\t\t\t\t   unsigned num_chains)\n {\n-  hash_set<gphi *> visited;\n-  return is_use_guarded (stmt, use_bb, phi, opnds, &visited);\n-}\n+  gcc_assert (is_empty ());\n \n-/* Normalize predicate PRED:\n-   1) if PRED can no longer be normalized, append it to *THIS.\n-   2) otherwise if PRED is of the form x != 0, follow x's definition\n-      and put normalized predicates into WORK_LIST.  */\n+  bool has_valid_pred = false;\n+  if (num_chains == 0)\n+    return;\n \n-void\n-predicate::normalize (pred_chain *norm_chain,\n-\t\t      pred_info pred,\n-\t\t      tree_code and_or_code,\n-\t\t      pred_chain *work_list,\n-\t\t      hash_set<tree> *mark_set)\n-{\n-  if (!is_neq_zero_form_p (pred))\n+  if (num_chains >= MAX_NUM_CHAINS)\n     {\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (pred);\n-      else\n-\tnorm_chain->safe_push (pred);\n+      if (dump_file)\n+\tfprintf (dump_file, \"MAX_NUM_CHAINS exceeded: %u\\n\", num_chains);\n       return;\n     }\n \n-  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n+  /* Convert the control dependency chain into a set of predicates.  */\n+  m_preds.reserve (num_chains);\n \n-  if (gimple_code (def_stmt) == GIMPLE_PHI\n-      && is_degenerate_phi (def_stmt, &pred))\n-    /* PRED has been modified above.  */\n-    work_list->safe_push (pred);\n-  else if (gimple_code (def_stmt) == GIMPLE_PHI && and_or_code == BIT_IOR_EXPR)\n+  for (unsigned i = 0; i < num_chains; i++)\n     {\n-      unsigned n = gimple_phi_num_args (def_stmt);\n+      /* One path through the CFG represents a logical conjunction\n+\t of the predicates.  */\n+      const vec<edge> &path = dep_chains[i];\n \n-      /* Punt for a nonzero constant.  The predicate should be one guarding\n-\t the phi edge.  */\n-      for (unsigned i = 0; i < n; ++i)\n+      has_valid_pred = false;\n+      /* The chain of predicates guarding the definition along this path.  */\n+      pred_chain t_chain{ };\n+      for (unsigned j = 0; j < path.length (); j++)\n \t{\n-\t  tree op = gimple_phi_arg_def (def_stmt, i);\n-\t  if (TREE_CODE (op) == INTEGER_CST && !integer_zerop (op))\n+\t  edge e = path[j];\n+\t  basic_block guard_bb = e->src;\n+\t  /* Ignore empty forwarder blocks.  */\n+\t  if (empty_block_p (guard_bb) && single_succ_p (guard_bb))\n+\t    continue;\n+\n+\t  /* An empty basic block here is likely a PHI, and is not one\n+\t     of the cases we handle below.  */\n+\t  gimple_stmt_iterator gsi = gsi_last_bb (guard_bb);\n+\t  if (gsi_end_p (gsi))\n \t    {\n-\t      push_pred (pred);\n-\t      return;\n+\t      has_valid_pred = false;\n+\t      break;\n \t    }\n-\t}\n-\n-      for (unsigned i = 0; i < n; ++i)\n-\t{\n-\t  tree op = gimple_phi_arg_def (def_stmt, i);\n-\t  if (integer_zerop (op))\n+\t  /* Get the conditional controlling the bb exit edge.  */\n+\t  gimple *cond_stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_call (cond_stmt) && EDGE_COUNT (e->src->succs) >= 2)\n+\t    /* Ignore EH edge.  Can add assertion on the other edge's flag.  */\n \t    continue;\n-\n-\t  push_to_worklist (op, work_list, mark_set);\n-\t}\n-    }\n-  else if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-    {\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (pred);\n-      else\n-\tnorm_chain->safe_push (pred);\n-    }\n-  else if (gimple_assign_rhs_code (def_stmt) == and_or_code)\n-    {\n-      /* Avoid splitting up bit manipulations like x & 3 or y | 1.  */\n-      if (is_gimple_min_invariant (gimple_assign_rhs2 (def_stmt)))\n-\t{\n-\t  /* But treat x & 3 as a condition.  */\n-\t  if (and_or_code == BIT_AND_EXPR)\n+\t  /* Skip if there is essentially one succesor.  */\n+\t  if (EDGE_COUNT (e->src->succs) == 2)\n \t    {\n-\t      pred_info n_pred;\n-\t      n_pred.pred_lhs = gimple_assign_rhs1 (def_stmt);\n-\t      n_pred.pred_rhs = gimple_assign_rhs2 (def_stmt);\n-\t      n_pred.cond_code = and_or_code;\n-\t      n_pred.invert = false;\n-\t      norm_chain->safe_push (n_pred);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  push_to_worklist (gimple_assign_rhs1 (def_stmt), work_list, mark_set);\n-\t  push_to_worklist (gimple_assign_rhs2 (def_stmt), work_list, mark_set);\n-\t}\n-    }\n-  else if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt))\n-\t   == tcc_comparison)\n-    {\n-      pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (n_pred);\n-      else\n-\tnorm_chain->safe_push (n_pred);\n-    }\n-  else\n-    {\n-      if (and_or_code == BIT_IOR_EXPR)\n-\tpush_pred (pred);\n-      else\n-\tnorm_chain->safe_push (pred);\n-    }\n-}\n-\n-/* Normalize PRED and store the normalized predicates in THIS->M_PREDS.  */\n-\n-void\n-predicate::normalize (const pred_info &pred)\n-{\n-  if (!is_neq_zero_form_p (pred))\n-    {\n-      push_pred (pred);\n-      return;\n-    }\n-\n-  tree_code and_or_code = ERROR_MARK;\n-\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n-  if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    and_or_code = gimple_assign_rhs_code (def_stmt);\n-  if (and_or_code != BIT_IOR_EXPR && and_or_code != BIT_AND_EXPR)\n-    {\n-      if (TREE_CODE_CLASS (and_or_code) == tcc_comparison)\n-\t{\n-\t  pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n-\t  push_pred (n_pred);\n-\t}\n-      else\n-\tpush_pred (pred);\n-      return;\n-    }\n-\n-\n-  pred_chain norm_chain = vNULL;\n-  pred_chain work_list = vNULL;\n-  work_list.safe_push (pred);\n-  hash_set<tree> mark_set;\n-\n-  while (!work_list.is_empty ())\n-    {\n-      pred_info a_pred = work_list.pop ();\n-      normalize (&norm_chain, a_pred, and_or_code, &work_list, &mark_set);\n-    }\n-\n-  if (and_or_code == BIT_AND_EXPR)\n-    m_preds.safe_push (norm_chain);\n-\n-  work_list.release ();\n-}\n-\n-/* Normalize a single predicate PRED_CHAIN and append it to *THIS.  */\n-\n-void\n-predicate::normalize (const pred_chain &chain)\n-{\n-  pred_chain work_list = vNULL;\n-  hash_set<tree> mark_set;\n-  for (unsigned i = 0; i < chain.length (); i++)\n-    {\n-      work_list.safe_push (chain[i]);\n-      mark_set.add (chain[i].pred_lhs);\n-    }\n-\n-  /* Normalized chain of predicates built up below.  */\n-  pred_chain norm_chain = vNULL;\n-  while (!work_list.is_empty ())\n-    {\n-      pred_info pi = work_list.pop ();\n-      predicate pred;\n-      /* The predicate object is not modified here, only NORM_CHAIN and\n-\t WORK_LIST are appended to.  */\n-      pred.normalize (&norm_chain, pi, BIT_AND_EXPR, &work_list, &mark_set);\n-    }\n-\n-  m_preds.safe_push (norm_chain);\n-  work_list.release ();\n-}\n-\n-/* Normalize predicate chains in THIS.  */\n-\n-void\n-predicate::normalize (gimple *use_or_def, bool is_use)\n-{\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    {\n-      fprintf (dump_file, \"Before normalization \");\n-      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n-    }\n-\n-  predicate norm_preds;\n-  for (unsigned i = 0; i < m_preds.length (); i++)\n-    {\n-      if (m_preds[i].length () != 1)\n-\tnorm_preds.normalize (m_preds[i]);\n-      else\n-\tnorm_preds.normalize (m_preds[i][0]);\n-    }\n-\n-  *this = norm_preds;\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"After normalization \");\n-      dump (use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n-    }\n-}\n-\n-/* Convert the chains of control dependence edges into a set of predicates.\n-   A control dependence chain is represented by a vector edges.  DEP_CHAINS\n-   points to an array of NUM_CHAINS dependence chains. One edge in\n-   a dependence chain is mapped to predicate expression represented by\n-   pred_info type.  One dependence chain is converted to a composite\n-   predicate that is the result of AND operation of pred_info mapped to\n-   each edge.  A composite predicate is represented by a vector of\n-   pred_info.  Sets M_PREDS to the resulting composite predicates.  */\n-\n-void\n-predicate::init_from_control_deps (const vec<edge> *dep_chains,\n-\t\t\t\t   unsigned num_chains)\n-{\n-  gcc_assert (is_empty ());\n-\n-  bool has_valid_pred = false;\n-  if (num_chains == 0)\n-    return;\n-\n-  if (num_chains >= MAX_NUM_CHAINS)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"MAX_NUM_CHAINS exceeded: %u\\n\", num_chains);\n-      return;\n-    }\n-\n-  /* Convert the control dependency chain into a set of predicates.  */\n-  m_preds.reserve (num_chains);\n-\n-  for (unsigned i = 0; i < num_chains; i++)\n-    {\n-      /* One path through the CFG represents a logical conjunction\n-\t of the predicates.  */\n-      const vec<edge> &path = dep_chains[i];\n-\n-      has_valid_pred = false;\n-      /* The chain of predicates guarding the definition along this path.  */\n-      pred_chain t_chain{ };\n-      for (unsigned j = 0; j < path.length (); j++)\n-\t{\n-\t  edge e = path[j];\n-\t  basic_block guard_bb = e->src;\n-\t  /* Ignore empty forwarder blocks.  */\n-\t  if (empty_block_p (guard_bb) && single_succ_p (guard_bb))\n-\t    continue;\n-\n-\t  /* An empty basic block here is likely a PHI, and is not one\n-\t     of the cases we handle below.  */\n-\t  gimple_stmt_iterator gsi = gsi_last_bb (guard_bb);\n-\t  if (gsi_end_p (gsi))\n-\t    {\n-\t      has_valid_pred = false;\n-\t      break;\n-\t    }\n-\t  /* Get the conditional controlling the bb exit edge.  */\n-\t  gimple *cond_stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_call (cond_stmt) && EDGE_COUNT (e->src->succs) >= 2)\n-\t    /* Ignore EH edge.  Can add assertion on the other edge's flag.  */\n-\t    continue;\n-\t  /* Skip if there is essentially one succesor.  */\n-\t  if (EDGE_COUNT (e->src->succs) == 2)\n-\t    {\n-\t      edge e1;\n-\t      edge_iterator ei1;\n-\t      bool skip = false;\n-\n-\t      FOR_EACH_EDGE (e1, ei1, e->src->succs)\n-\t\t{\n-\t\t  if (EDGE_COUNT (e1->dest->succs) == 0)\n-\t\t    {\n-\t\t      skip = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (skip)\n-\t\tcontinue;\n+\t      edge e1;\n+\t      edge_iterator ei1;\n+\t      bool skip = false;\n+\n+\t      FOR_EACH_EDGE (e1, ei1, e->src->succs)\n+\t\t{\n+\t\t  if (EDGE_COUNT (e1->dest->succs) == 0)\n+\t\t    {\n+\t\t      skip = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (skip)\n+\t\tcontinue;\n \t    }\n \t  if (gimple_code (cond_stmt) == GIMPLE_COND)\n \t    {\n@@ -2353,3 +2067,289 @@ predicate::init_from_control_deps (const vec<edge> *dep_chains,\n     /* Clear M_PREDS to indicate failure.  */\n     m_preds.release ();\n }\n+/* Store a PRED in *THIS.  */\n+\n+void\n+predicate::push_pred (const pred_info &pred)\n+{\n+  pred_chain chain = vNULL;\n+  chain.safe_push (pred);\n+  m_preds.safe_push (chain);\n+}\n+\n+/* Dump predicates in *THIS for STMT prepended by MSG.  */\n+\n+void\n+predicate::dump (gimple *stmt, const char *msg) const\n+{\n+  fprintf (dump_file, \"%s\", msg);\n+  if (stmt)\n+    {\n+      fputc ('\\t', dump_file);\n+      print_gimple_stmt (dump_file, stmt, 0);\n+      fprintf (dump_file, \"  is conditional on:\\n\");\n+    }\n+\n+  unsigned np = m_preds.length ();\n+  if (np == 0)\n+    {\n+      fprintf (dump_file, \"\\t(empty)\\n\");\n+      return;\n+    }\n+\n+  {\n+    tree expr = build_pred_expr (m_preds);\n+    char *str = print_generic_expr_to_str (expr);\n+    fprintf (dump_file, \"\\t%s (expanded)\\n\", str);\n+    free (str);\n+  }\n+\n+  if (np > 1)\n+    fprintf (dump_file, \"\\tOR (\");\n+  else\n+    fputc ('\\t', dump_file);\n+  for (unsigned i = 0; i < np; i++)\n+    {\n+      dump_pred_chain (m_preds[i]);\n+      if (i < np - 1)\n+\tfprintf (dump_file, \", \");\n+      else if (i > 0)\n+\tfputc (')', dump_file);\n+    }\n+  fputc ('\\n', dump_file);\n+}\n+\n+/* Initialize USE_PREDS with the predicates of the control dependence chains\n+   between the basic block DEF_BB that defines a variable of interst and\n+   USE_BB that uses the variable, respectively.  */\n+\n+bool\n+uninit_analysis::init_use_preds (predicate &use_preds, basic_block def_bb,\n+\t\t\t\t basic_block use_bb)\n+{\n+  gcc_assert (use_preds.is_empty ());\n+\n+  /* Set CD_ROOT to the basic block closest to USE_BB that is the control\n+     equivalent of (is guarded by the same predicate as) DEF_BB that also\n+     dominates USE_BB.  */\n+  basic_block cd_root = def_bb;\n+  while (dominated_by_p (CDI_DOMINATORS, use_bb, cd_root))\n+    {\n+      /* Find CD_ROOT's closest postdominator that's its control\n+\t equivalent.  */\n+      if (basic_block bb = find_control_equiv_block (cd_root))\n+\tif (dominated_by_p (CDI_DOMINATORS, use_bb, bb))\n+\t  {\n+\t    cd_root = bb;\n+\t    continue;\n+\t  }\n+\n+      break;\n+    }\n+\n+  /* Set DEP_CHAINS to the set of edges between CD_ROOT and USE_BB.\n+     Each DEP_CHAINS element is a series of edges whose conditions\n+     are logical conjunctions.  Together, the DEP_CHAINS vector is\n+     used below to initialize an OR expression of the conjunctions.  */\n+  unsigned num_calls = 0;\n+  unsigned num_chains = 0;\n+  auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n+  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+\n+  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n+\t\t\t\t  cur_chain, &num_calls))\n+    {\n+      gcc_assert (num_chains == 0);\n+      simple_control_dep_chain (dep_chains[0], cd_root, use_bb);\n+      num_chains++;\n+    }\n+\n+  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+    {\n+      fprintf (dump_file, \"predicate::predicate (def_bb = %u, use_bb = %u, func_t) \"\n+\t       \"initialized from %u dep_chains:\\n\\t\",\n+\t       def_bb->index, use_bb->index, num_chains);\n+      dump_dep_chains (dep_chains, num_chains);\n+    }\n+\n+  /* From the set of edges computed above initialize *THIS as the OR\n+     condition under which the definition in DEF_BB is used in USE_BB.\n+     Each OR subexpression is represented by one element of DEP_CHAINS,\n+     where each element consists of a series of AND subexpressions.  */\n+  use_preds.init_from_control_deps (dep_chains, num_chains);\n+  return !use_preds.is_empty ();\n+}\n+\n+/* Release resources in *THIS.  */\n+\n+predicate::~predicate ()\n+{\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i != n; ++i)\n+    m_preds[i].release ();\n+  m_preds.release ();\n+}\n+\n+/* Copy-assign RHS to *THIS.  */\n+\n+predicate&\n+predicate::operator= (const predicate &rhs)\n+{\n+  if (this == &rhs)\n+    return *this;\n+\n+  unsigned n = m_preds.length ();\n+  for (unsigned i = 0; i != n; ++i)\n+    m_preds[i].release ();\n+  m_preds.release ();\n+\n+  n = rhs.m_preds.length ();\n+  for (unsigned i = 0; i != n; ++i)\n+    {\n+      const pred_chain &chain = rhs.m_preds[i];\n+      m_preds.safe_push (chain.copy ());\n+    }\n+\n+  return *this;\n+}\n+\n+/* For each use edge of PHI, compute all control dependence chains\n+   and convert those to the composite predicates in M_PREDS.\n+   Return true if a nonempty predicate has been obtained.  */\n+\n+bool\n+uninit_analysis::init_from_phi_def (gphi *phi)\n+{\n+  gcc_assert (m_phi_def_preds.is_empty ());\n+\n+  basic_block phi_bb = gimple_bb (phi);\n+  /* Find the closest dominating bb to be the control dependence root.  */\n+  basic_block cd_root = get_immediate_dominator (CDI_DOMINATORS, phi_bb);\n+  if (!cd_root)\n+    return false;\n+\n+  /* Set DEF_EDGES to the edges to the PHI from the bb's that provide\n+     definitions of each of the PHI operands for which M_EVAL is false.  */\n+  auto_vec<edge> def_edges;\n+  hash_set<gimple *> visited_phis;\n+  collect_phi_def_edges (phi, cd_root, &def_edges, &visited_phis);\n+\n+  unsigned nedges = def_edges.length ();\n+  if (nedges == 0)\n+    return false;\n+\n+  unsigned num_chains = 0;\n+  auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n+  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n+  for (unsigned i = 0; i < nedges; i++)\n+    {\n+      edge e = def_edges[i];\n+      unsigned num_calls = 0;\n+      unsigned prev_nc = num_chains;\n+      compute_control_dep_chain (cd_root, e->src, dep_chains,\n+\t\t\t\t &num_chains, cur_chain, &num_calls);\n+\n+      /* Update the newly added chains with the phi operand edge.  */\n+      if (EDGE_COUNT (e->src->succs) > 1)\n+\t{\n+\t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n+\t    dep_chains[num_chains++] = vNULL;\n+\t  for (unsigned j = prev_nc; j < num_chains; j++)\n+\t    dep_chains[j].safe_push (e);\n+\t}\n+    }\n+\n+  /* Convert control dependence chains to the predicate in *THIS under\n+     which the PHI operands are defined to values for which M_EVAL is\n+     false.  */\n+  m_phi_def_preds.init_from_control_deps (dep_chains, num_chains);\n+  return !m_phi_def_preds.is_empty ();\n+}\n+\n+/* Compute the predicates that guard the use USE_STMT and check if\n+   the incoming paths that have an empty (or possibly empty) definition\n+   can be pruned.  Return true if it can be determined that the use of\n+   PHI's def in USE_STMT is guarded by a predicate set that does not\n+   overlap with the predicate sets of all runtime paths that do not\n+   have a definition.\n+\n+   Return false if the use is not guarded or if it cannot be determined.\n+   USE_BB is the bb of the use (for phi operand use, the bb is not the bb\n+   of the phi stmt, but the source bb of the operand edge).\n+\n+   OPNDS is a bitmap with a bit set for each PHI operand of interest.\n+\n+   THIS->M_PREDS contains the (memoized) defining predicate chains of\n+   a PHI.  If THIS->M_PREDS is empty, the PHI's defining predicate\n+   chains are computed and stored into THIS->M_PREDS as needed.\n+\n+   VISITED_PHIS is a pointer set of phis being visited.  */\n+\n+bool\n+uninit_analysis::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n+\t\t\t\t gphi *phi, unsigned opnds,\n+\t\t\t\t hash_set<gphi *> *visited)\n+{\n+  if (visited->add (phi))\n+    return false;\n+\n+  /* The basic block where the PHI is defined.  */\n+  basic_block def_bb = gimple_bb (phi);\n+\n+  if (dominated_by_p (CDI_POST_DOMINATORS, def_bb, use_bb))\n+    /* The use is not guarded.  */\n+    return false;\n+\n+  /* Try to build the predicate expression under which the PHI flows\n+     into its use.  This will be empty if the PHI is defined and used\n+     in the same bb.  */\n+  predicate use_preds;\n+  if (!init_use_preds (use_preds, def_bb, use_bb))\n+    return false;\n+\n+  /* Try to prune the dead incoming phi edges.  */\n+  if (!overlap (phi, opnds, visited, use_preds))\n+    {\n+      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\tfputs (\"found predicate overlap\\n\", dump_file);\n+\n+      return true;\n+    }\n+\n+  /* We might be able to prove that if the control dependencies for OPNDS\n+     are true, the control dependencies for USE_STMT can never be true.  */\n+  if (use_cannot_happen (phi, opnds, use_preds))\n+    return true;\n+\n+  if (m_phi_def_preds.is_empty ())\n+    {\n+      /* Lazily initialize *THIS from PHI.  */\n+      if (!init_from_phi_def (phi))\n+\treturn false;\n+\n+      m_phi_def_preds.simplify (phi);\n+      m_phi_def_preds.normalize (phi);\n+    }\n+\n+  use_preds.simplify (use_stmt, /*is_use=*/true);\n+  use_preds.normalize (use_stmt, /*is_use=*/true);\n+\n+  /* Return true if the predicate guarding the valid definition (i.e.,\n+     *THIS) is a superset of the predicate guarding the use (i.e.,\n+     USE_PREDS).  */\n+  if (m_phi_def_preds.superset_of (use_preds))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Public interface to the above. */\n+\n+bool\n+uninit_analysis::is_use_guarded (gimple *stmt, basic_block use_bb, gphi *phi,\n+\t\t\t\t unsigned opnds)\n+{\n+  hash_set<gphi *> visited;\n+  return is_use_guarded (stmt, use_bb, phi, opnds, &visited);\n+}\n+"}]}