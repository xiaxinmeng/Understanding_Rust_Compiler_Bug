{"sha": "3e60ddeb8220ed388819bb3f14e8caa9309fd3c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2MGRkZWI4MjIwZWQzODg4MTliYjNmMTRlOGNhYTkzMDlmZDNjMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-11T10:10:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-11T10:10:17Z"}, "message": "expansion: Sign or zero extend on MEM_REF stores into SUBREG with SUBREG_PROMOTED_VAR_P [PR98190]\n\nSome targets decide to promote certain scalar variables to wider mode,\nso their DECL_RTL is a SUBREG with SUBREG_PROMOTED_VAR_P.\nWhen storing to such vars, store_expr takes care of sign or zero extending,\nbut if we store e.g. through MEM_REF into them, no sign or zero extension\nhappens and that leads to wrong-code e.g. on the following testcase on\naarch64-linux.\n\nThe following patch uses store_expr if we overwrite all the bits and it is\nnot reversed storage order, i.e. something that store_expr handles normally,\nand otherwise (if the most significant bit is (or for pdp11 might be, but\npdp11 doesn't promote) being modified), the code extends manually.\n\n2020-12-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/98190\n\t* expr.c (expand_assignment): If to_rtx is a promoted SUBREG,\n\tensure sign or zero extension either through use of store_expr\n\tor by extending manually.\n\n\t* gcc.dg/pr98190.c: New test.", "tree": {"sha": "68ee16eb872a982e6b92cacd5bb660f493f4457a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68ee16eb872a982e6b92cacd5bb660f493f4457a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "499651e43854ea65303eb55324263c25256c9735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499651e43854ea65303eb55324263c25256c9735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/499651e43854ea65303eb55324263c25256c9735"}], "stats": {"total": 57, "additions": 57, "deletions": 0}, "files": [{"sha": "a56594e78d5536f47495258dbecaed82f00b3459", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3e60ddeb8220ed388819bb3f14e8caa9309fd3c2", "patch": "@@ -5451,6 +5451,30 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t\t\t\t       mode1, to_rtx, to, from,\n \t\t\t\t\t       reversep))\n \t    result = NULL;\n+\t  else if (SUBREG_P (to_rtx)\n+\t\t   && SUBREG_PROMOTED_VAR_P (to_rtx))\n+\t    {\n+\t      /* If to_rtx is a promoted subreg, we need to zero or sign\n+\t\t extend the value afterwards.  */\n+\t      if (TREE_CODE (to) == MEM_REF\n+\t\t  && !REF_REVERSE_STORAGE_ORDER (to)\n+\t\t  && known_eq (bitpos, 0)\n+\t\t  && known_eq (bitsize, GET_MODE_BITSIZE (GET_MODE (to_rtx))))\n+\t\tresult = store_expr (from, to_rtx, 0, nontemporal, false);\n+\t      else\n+\t\t{\n+\t\t  rtx to_rtx1\n+\t\t    = lowpart_subreg (subreg_unpromoted_mode (to_rtx),\n+\t\t\t\t      SUBREG_REG (to_rtx),\n+\t\t\t\t      subreg_promoted_mode (to_rtx));\n+\t\t  result = store_field (to_rtx1, bitsize, bitpos,\n+\t\t\t\t\tbitregion_start, bitregion_end,\n+\t\t\t\t\tmode1, from, get_alias_set (to),\n+\t\t\t\t\tnontemporal, reversep);\n+\t\t  convert_move (SUBREG_REG (to_rtx), to_rtx1,\n+\t\t\t\tSUBREG_PROMOTED_SIGN (to_rtx));\n+\t\t}\n+\t    }\n \t  else\n \t    result = store_field (to_rtx, bitsize, bitpos,\n \t\t\t\t  bitregion_start, bitregion_end,"}, {"sha": "bfdd17d927080c381ace87c595606cb4dce4e43f", "filename": "gcc/testsuite/gcc.dg/pr98190.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr98190.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e60ddeb8220ed388819bb3f14e8caa9309fd3c2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr98190.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr98190.c?ref=3e60ddeb8220ed388819bb3f14e8caa9309fd3c2", "patch": "@@ -0,0 +1,33 @@\n+/* PR middle-end/98190 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+static int __attribute__((noipa))\n+foo (const char *p, const char *q, const int len)\n+{\n+  for (int i = 0; i < len; p++, q++, i++)\n+    {\n+      int equal;\n+      _Bool x, y;\n+      __builtin_memcpy ((char *) &x, p, sizeof x);\n+      __builtin_memcpy ((char *) &y, q, sizeof y);\n+      equal = (x == y);\n+      if (equal <= 0)\n+\treturn equal;\n+    }\n+  return 1;\n+}\n+\n+int\n+main ()\n+{\n+  const _Bool buf[4] = { 1, 0, 0, 0 };\n+#ifdef __aarch64__\n+  register long x4 asm (\"x4\") = 0xdeadbeefULL;\n+  register long x5 asm (\"x5\") = 0xcafebabeULL;\n+  asm volatile (\"\"::\"r\" (x4), \"r\" (x5));\n+#endif\n+  if (foo ((char *) &buf[0], (char *) &buf[0], 1) != 1)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}