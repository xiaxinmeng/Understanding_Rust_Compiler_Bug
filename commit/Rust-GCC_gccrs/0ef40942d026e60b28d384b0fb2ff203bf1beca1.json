{"sha": "0ef40942d026e60b28d384b0fb2ff203bf1beca1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVmNDA5NDJkMDI2ZTYwYjI4ZDM4NGIwZmIyZmYyMDNiZjFiZWNhMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:14:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:14:41Z"}, "message": "[38/77] Move SCALAR_INT_MODE_P out of strict_volatile_bitfield_p\n\nstrict_volatile_bitfield_p returns false for any mode that isn't\na scalar integer.  This patch moves the check to the caller and\nmakes strict_volatile_bitfield_p take the mode as a scalar_int_mode.\nThe handling of a true return can then also use the mode as a\nscalar_int_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expmed.c (strict_volatile_bitfield_p): Change the type of fieldmode\n\tto scalar_int_mode.  Remove check for SCALAR_INT_MODE_P.\n\t(store_bit_field): Check is_a <scalar_int_mode> before calling\n\tstrict_volatile_bitfield_p.\n\t(extract_bit_field): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251490", "tree": {"sha": "9fb8bcf51f07e829d312f8c9ab92b89b5bd5a54c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fb8bcf51f07e829d312f8c9ab92b89b5bd5a54c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ef40942d026e60b28d384b0fb2ff203bf1beca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef40942d026e60b28d384b0fb2ff203bf1beca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef40942d026e60b28d384b0fb2ff203bf1beca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef40942d026e60b28d384b0fb2ff203bf1beca1/comments", "author": null, "committer": null, "parents": [{"sha": "7cc237a633b6b488a3950baa23833b6f78e8d26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc237a633b6b488a3950baa23833b6f78e8d26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc237a633b6b488a3950baa23833b6f78e8d26b"}], "stats": {"total": 51, "additions": 30, "deletions": 21}, "files": [{"sha": "6b028e45276081a2c488418087b1aa6298bc813e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef40942d026e60b28d384b0fb2ff203bf1beca1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef40942d026e60b28d384b0fb2ff203bf1beca1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ef40942d026e60b28d384b0fb2ff203bf1beca1", "patch": "@@ -1,3 +1,13 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expmed.c (strict_volatile_bitfield_p): Change the type of fieldmode\n+\tto scalar_int_mode.  Remove check for SCALAR_INT_MODE_P.\n+\t(store_bit_field): Check is_a <scalar_int_mode> before calling\n+\tstrict_volatile_bitfield_p.\n+\t(extract_bit_field): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "051e048e806f25abfc0f8b001ac11bc3b31bc4d7", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ef40942d026e60b28d384b0fb2ff203bf1beca1/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ef40942d026e60b28d384b0fb2ff203bf1beca1/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0ef40942d026e60b28d384b0fb2ff203bf1beca1", "patch": "@@ -516,7 +516,7 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n static bool\n strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    unsigned HOST_WIDE_INT bitnum,\n-\t\t\t    machine_mode fieldmode,\n+\t\t\t    scalar_int_mode fieldmode,\n \t\t\t    unsigned HOST_WIDE_INT bitregion_start,\n \t\t\t    unsigned HOST_WIDE_INT bitregion_end)\n {\n@@ -529,11 +529,6 @@ strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       || flag_strict_volatile_bitfields <= 0)\n     return false;\n \n-  /* Non-integral modes likely only happen with packed structures.\n-     Punt.  */\n-  if (!SCALAR_INT_MODE_P (fieldmode))\n-    return false;\n-\n   /* The bit size must not be larger than the field mode, and\n      the field mode must not be larger than a word.  */\n   if (bitsize > modesize || modesize > BITS_PER_WORD)\n@@ -1059,32 +1054,34 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t rtx value, bool reverse)\n {\n   /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n-  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, fieldmode,\n-\t\t\t\t  bitregion_start, bitregion_end))\n+  scalar_int_mode int_mode;\n+  if (is_a <scalar_int_mode> (fieldmode, &int_mode)\n+      && strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, int_mode,\n+\t\t\t\t     bitregion_start, bitregion_end))\n     {\n       /* Storing of a full word can be done with a simple store.\n \t We know here that the field can be accessed with one single\n \t instruction.  For targets that support unaligned memory,\n \t an unaligned access may be necessary.  */\n-      if (bitsize == GET_MODE_BITSIZE (fieldmode))\n+      if (bitsize == GET_MODE_BITSIZE (int_mode))\n \t{\n-\t  str_rtx = adjust_bitfield_address (str_rtx, fieldmode,\n+\t  str_rtx = adjust_bitfield_address (str_rtx, int_mode,\n \t\t\t\t\t     bitnum / BITS_PER_UNIT);\n \t  if (reverse)\n-\t    value = flip_storage_order (fieldmode, value);\n+\t    value = flip_storage_order (int_mode, value);\n \t  gcc_assert (bitnum % BITS_PER_UNIT == 0);\n \t  emit_move_insn (str_rtx, value);\n \t}\n       else\n \t{\n \t  rtx temp;\n \n-\t  str_rtx = narrow_bit_field_mem (str_rtx, fieldmode, bitsize, bitnum,\n+\t  str_rtx = narrow_bit_field_mem (str_rtx, int_mode, bitsize, bitnum,\n \t\t\t\t\t  &bitnum);\n-\t  gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (fieldmode));\n+\t  gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (int_mode));\n \t  temp = copy_to_reg (str_rtx);\n \t  if (!store_bit_field_1 (temp, bitsize, bitnum, 0, 0,\n-\t\t\t\t  fieldmode, value, reverse, true))\n+\t\t\t\t  int_mode, value, reverse, true))\n \t    gcc_unreachable ();\n \n \t  emit_move_insn (str_rtx, temp);\n@@ -1955,25 +1952,27 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   else\n     mode1 = tmode;\n \n-  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, mode1, 0, 0))\n+  scalar_int_mode int_mode;\n+  if (is_a <scalar_int_mode> (mode1, &int_mode)\n+      && strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, int_mode, 0, 0))\n     {\n-      /* Extraction of a full MODE1 value can be done with a simple load.\n+      /* Extraction of a full INT_MODE value can be done with a simple load.\n \t We know here that the field can be accessed with one single\n \t instruction.  For targets that support unaligned memory,\n \t an unaligned access may be necessary.  */\n-      if (bitsize == GET_MODE_BITSIZE (mode1))\n+      if (bitsize == GET_MODE_BITSIZE (int_mode))\n \t{\n-\t  rtx result = adjust_bitfield_address (str_rtx, mode1,\n+\t  rtx result = adjust_bitfield_address (str_rtx, int_mode,\n \t\t\t\t\t\tbitnum / BITS_PER_UNIT);\n \t  if (reverse)\n-\t    result = flip_storage_order (mode1, result);\n+\t    result = flip_storage_order (int_mode, result);\n \t  gcc_assert (bitnum % BITS_PER_UNIT == 0);\n \t  return convert_extracted_bit_field (result, mode, tmode, unsignedp);\n \t}\n \n-      str_rtx = narrow_bit_field_mem (str_rtx, mode1, bitsize, bitnum,\n+      str_rtx = narrow_bit_field_mem (str_rtx, int_mode, bitsize, bitnum,\n \t\t\t\t      &bitnum);\n-      gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (mode1));\n+      gcc_assert (bitnum + bitsize <= GET_MODE_BITSIZE (int_mode));\n       str_rtx = copy_to_reg (str_rtx);\n     }\n "}]}