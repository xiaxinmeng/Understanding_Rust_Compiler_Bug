{"sha": "1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlNjc2YTA2MWQ5MWI0MzRhNjJkOTBkN2EyZjVkOGZkZjA3ZThhZg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-09T20:04:17Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-09T20:04:17Z"}, "message": "cpphash.h (_cpp_push_text_context): Update.\n\n\t* cpphash.h (_cpp_push_text_context): Update.\n\t(_cpp_arguments_ok): New.\n\t* cppmacro.c (_cpp_arguments_ok): New, split out from...\n\t(collect_args): ...here.\n\t(_cpp_push_text_context): Change inputs.\n\t* cpptrad.c (struct fun_macro, maybe_start_funlike, save_argument,\n\treplace_args_and_push): New.\n\t(lex_identifier, _cpp_lex_identifier_trad, scan_parameters):\n\tDon't use IS macros directly.\n\t(scan_out_logical_line): Handle function-like macro argument\n\tcollection.\n\t(push_replacement_text): Update.\n\t(replacement_length): Remove.\n\t(_cpp_create_trad_definition): Don't skip whitespace before\n\tchecking for '('.\n\nFrom-SVN: r54412", "tree": {"sha": "a2b5349f1ee2ab348cfc3c37c8f4c9a4ca8a6b1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2b5349f1ee2ab348cfc3c37c8f4c9a4ca8a6b1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/comments", "author": null, "committer": null, "parents": [{"sha": "25f2e176414291186a206bb5f7cdc3e98563b38b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f2e176414291186a206bb5f7cdc3e98563b38b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f2e176414291186a206bb5f7cdc3e98563b38b"}], "stats": {"total": 417, "additions": 322, "deletions": 95}, "files": [{"sha": "4888b7988e08c33f0125b910e2d664a00e7d61cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "patch": "@@ -1,3 +1,21 @@\n+2002-06-09  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (_cpp_push_text_context): Update.\n+\t(_cpp_arguments_ok): New.\n+\t* cppmacro.c (_cpp_arguments_ok): New, split out from...\n+\t(collect_args): ...here.\n+\t(_cpp_push_text_context): Change inputs.\n+\t* cpptrad.c (struct fun_macro, maybe_start_funlike, save_argument,\n+\treplace_args_and_push): New.\n+\t(lex_identifier, _cpp_lex_identifier_trad, scan_parameters):\n+\tDon't use IS macros directly.\n+\t(scan_out_logical_line): Handle function-like macro argument\n+\tcollection.\n+\t(push_replacement_text): Update.\n+\t(replacement_length): Remove.\n+\t(_cpp_create_trad_definition): Don't skip whitespace before\n+\tchecking for '('.\n+\n 2002-06-09  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n \n \t* config/avr/avr.c (avr_mcu_types): Update for new devices."}, {"sha": "6baf211958d6a3c16107d0ee7d961676aed54963", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "patch": "@@ -438,9 +438,12 @@ extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n extern bool _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n extern void _cpp_push_text_context\tPARAMS ((cpp_reader *, cpp_hashnode *,\n-\t\t\t\t\t\t const uchar *, const uchar*));\n+\t\t\t\t\t\t const uchar *, size_t));\n extern bool _cpp_save_parameter\t\tPARAMS ((cpp_reader *, cpp_macro *,\n \t\t\t\t\t\t cpp_hashnode *));\n+extern bool _cpp_arguments_ok\t\tPARAMS ((cpp_reader *, cpp_macro *,\n+\t\t\t\t\t\t const cpp_hashnode *,\n+\t\t\t\t\t\t unsigned int));\n \n /* In cpphash.c */\n extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));"}, {"sha": "d5179487637b1bab9b715bd52617966e5e843b16", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 57, "deletions": 41, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "patch": "@@ -451,6 +451,52 @@ paste_all_tokens (pfile, lhs)\n   push_token_context (pfile, NULL, lhs, 1);\n }\n \n+/* Returns TRUE if the number of arguments ARGC supplied in an\n+   invocation of the MACRO referenced by NODE is valid.  An empty\n+   invocation to a macro with no parameters should pass ARGC as zero.\n+\n+   Note that MACRO cannot necessarily be deduced from NODE, in case\n+   NODE was redefined whilst collecting arguments.  */\n+bool\n+_cpp_arguments_ok (pfile, macro, node, argc)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+     const cpp_hashnode *node;\n+     unsigned int argc;\n+{\n+  if (argc == macro->paramc)\n+    return true;\n+\n+  if (argc < macro->paramc)\n+    {\n+      /* As an extension, a rest argument is allowed to not appear in\n+\t the invocation at all.\n+\t e.g. #define debug(format, args...) something\n+\t debug(\"string\");\n+\n+\t This is exactly the same as if there had been an empty rest\n+\t argument - debug(\"string\", ).  */\n+\n+      if (argc + 1 == macro->paramc && macro->variadic)\n+\t{\n+\t  if (CPP_PEDANTIC (pfile) && ! macro->syshdr)\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"ISO C99 requires rest arguments to be used\");\n+\t  return true;\n+\t}\n+\n+      cpp_error (pfile, DL_ERROR,\n+\t\t \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n+\t\t NODE_NAME (node), macro->paramc, argc);\n+    }\n+  else\n+    cpp_error (pfile, DL_ERROR,\n+\t       \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n+\t       NODE_NAME (node), argc, macro->paramc);\n+\n+  return false;\n+}\n+\n /* Reads and returns the arguments to a function-like macro\n    invocation.  Assumes the opening parenthesis has been processed.\n    If there is an error, emits an appropriate diagnostic and returns\n@@ -466,7 +512,6 @@ collect_args (pfile, node)\n   macro_arg *args, *arg;\n   const cpp_token *token;\n   unsigned int argc;\n-  bool error = false;\n \n   macro = node->value.macro;\n   if (macro->paramc)\n@@ -561,47 +606,17 @@ collect_args (pfile, node)\n       cpp_error (pfile, DL_ERROR,\n \t\t \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n-      error = true;\n-    }\n-  else if (argc < macro->paramc)\n-    {\n-      /* As an extension, a rest argument is allowed to not appear in\n-\t the invocation at all.\n-\t e.g. #define debug(format, args...) something\n-\t debug(\"string\");\n-\n-\t This is exactly the same as if there had been an empty rest\n-\t argument - debug(\"string\", ).  */\n-\n-      if (argc + 1 == macro->paramc && macro->variadic)\n-\t{\n-\t  if (CPP_PEDANTIC (pfile) && ! macro->syshdr)\n-\t    cpp_error (pfile, DL_PEDWARN,\n-\t\t       \"ISO C99 requires rest arguments to be used\");\n-\t}\n-      else\n-\t{\n-\t  cpp_error (pfile, DL_ERROR,\n-\t\t     \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n-\t\t     NODE_NAME (node), macro->paramc, argc);\n-\t  error = true;\n-\t}\n     }\n-  else if (argc > macro->paramc)\n+  else\n     {\n-      /* Empty argument to a macro taking no arguments is OK.  */\n-      if (argc != 1 || arg->count)\n-\t{\n-\t  cpp_error (pfile, DL_ERROR,\n-\t\t     \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n-\t\t     NODE_NAME (node), argc, macro->paramc);\n-\t  error = true;\n-\t}\n+      /* A single empty argument is counted as no argument.  */\n+      if (argc == 1 && macro->paramc == 0 && args[0].count == 0)\n+\targc = 0;\n+      if (_cpp_arguments_ok (pfile, macro, node, argc))\n+\treturn base_buff;\n     }\n \n-  if (!error)\n-    return base_buff;\n-\n+  /* An error occurred.  */\n   _cpp_release_buff (pfile, base_buff);\n   return NULL;\n }\n@@ -919,18 +934,19 @@ push_token_context (pfile, macro, first, count)\n \n /* Push a traditional macro's replacement text.  */\n void\n-_cpp_push_text_context (pfile, macro, start, end)\n+_cpp_push_text_context (pfile, macro, start, len)\n      cpp_reader *pfile;\n      cpp_hashnode *macro;\n-     const uchar *start, *end;\n+     const uchar *start;\n+     size_t len;\n {\n   cpp_context *context = next_context (pfile);\n \n   context->direct_p = true;\n   context->macro = macro;\n   context->buff = NULL;\n   CUR (context) = start;\n-  RLIMIT (context) = end;\n+  RLIMIT (context) = start + len;\n }\n \n /* Expand an argument ARG before replacing parameters in a"}, {"sha": "7ba9d924ef03dbfcb10cff4a717eebda96e16315", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 243, "deletions": 53, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce676a061d91b434a62d90d7a2f5d8fdf07e8af/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=1ce676a061d91b434a62d90d7a2f5d8fdf07e8af", "patch": "@@ -44,6 +44,29 @@ struct block\n #define BLOCK_HEADER_LEN offsetof (struct block, text)\n #define BLOCK_LEN(TEXT_LEN) CPP_ALIGN (BLOCK_HEADER_LEN + TEXT_LEN)\n \n+/* Structure holding information about a function-like macro\n+   invocation.  */\n+struct fun_macro\n+{\n+  /* Memory buffer holding the trad_arg array.  */\n+  _cpp_buff *buff;\n+\n+  /* An array of size the number of macro parameters + 1, containing\n+     the offsets of the start of each macro argument in the output\n+     buffer.  The argument continues until the character before the\n+     start of the next one.  */\n+  size_t *args;\n+\n+  /* The hashnode of the macro.  */\n+  cpp_hashnode *node;\n+\n+  /* The offset of the macro name in the output buffer.  */\n+  size_t offset;\n+\n+  /* Zero-based index of argument being currently lexed.  */\n+  unsigned int argc;\n+};\n+\n /* Lexing TODO: Handle -C, maybe -CC, and space in escaped newlines.\n    Stop cpplex.c from recognizing comments and directives during its\n    lexing pass.  Get rid of line_base usage - seems pointless?  Do we\n@@ -62,7 +85,10 @@ static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n static bool scan_parameters PARAMS ((cpp_reader *, cpp_macro *));\n static void save_replacement_text PARAMS ((cpp_reader *, cpp_macro *,\n \t\t\t\t\t   unsigned int));\n-static unsigned int replacement_length PARAMS ((cpp_macro *));\n+static void maybe_start_funlike PARAMS ((cpp_reader *, cpp_hashnode *,\n+\t\t\t\t\t const uchar *, struct fun_macro *));\n+static void save_argument PARAMS ((struct fun_macro *, size_t));\n+static void replace_args_and_push PARAMS ((cpp_reader *, struct fun_macro *));\n \n /* Ensures we have N bytes' space in the output buffer, and\n    reallocates it if not.  */\n@@ -205,10 +231,10 @@ lex_identifier (pfile, cur)\n     {\n       do\n \t*out++ = *cur++;\n-      while (ISIDNUM (*cur));\n+      while (is_numchar (*cur));\n       cur = skip_escaped_newlines (pfile, cur);\n     }\n-  while (ISIDNUM (*cur));\n+  while (is_numchar (*cur));\n \n   CUR (pfile->context) = cur;\n   len = out - pfile->trad_out_cur;\n@@ -226,7 +252,7 @@ _cpp_lex_identifier_trad (pfile)\n {\n   const uchar *cur = skip_whitespace (pfile, CUR (pfile->context));\n \n-  if (!ISIDST (*cur))\n+  if (!is_idstart (*cur))\n     {\n       CUR (pfile->context) = cur;\n       return NULL;\n@@ -309,12 +335,45 @@ _cpp_read_logical_line_trad (pfile)\n   return true;\n }\n \n+/* Set up state for finding the opening '(' of a function-like\n+   macro.  */\n+static void\n+maybe_start_funlike (pfile, node, start, macro)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+     const uchar *start;\n+     struct fun_macro *macro;\n+{\n+  unsigned int n = node->value.macro->paramc + 1;\n+\n+  if (macro->buff)\n+    _cpp_release_buff (pfile, macro->buff);\n+  macro->buff = _cpp_get_buff (pfile, n * sizeof (size_t));\n+  macro->args = (size_t *) BUFF_FRONT (macro->buff);\n+  macro->node = node;\n+  macro->offset = start - pfile->trad_out_base;\n+  macro->argc = 0;\n+\n+  pfile->state.parsing_args = 1;\n+}\n+\n+/* Save the OFFSET of the start of the next argument to MACRO.  */\n+static void\n+save_argument (macro, offset)\n+     struct fun_macro *macro;\n+     size_t offset;\n+{\n+  macro->argc++;\n+  if (macro->argc <= macro->node->value.macro->paramc)\n+    macro->args[macro->argc] = offset;\n+}\n+\n /* Copies the next logical line in the current buffer to the output\n    buffer.  The output is guaranteed to terminate with a NUL\n    character.\n \n    If MACRO is non-NULL, then we are scanning the replacement list of\n-   MACRO, and we call save_replacement_text every time we meet an\n+   MACRO, and we call save_replacement_text() every time we meet an\n    argument.  */\n static void\n scan_out_logical_line (pfile, macro)\n@@ -323,9 +382,11 @@ scan_out_logical_line (pfile, macro)\n {\n   cpp_context *context;\n   const uchar *cur;\n-  unsigned int c, quote = 0;\n+  unsigned int c, paren_depth, quote = 0;\n   uchar *out;\n+  struct fun_macro fmacro;\n \n+  fmacro.buff = NULL;\n  new_context:\n   context = pfile->context;\n   cur = CUR (context);\n@@ -357,16 +418,22 @@ scan_out_logical_line (pfile, macro)\n \t  cur--;\n \t  if (!pfile->buffer->from_stage3)\n \t    cpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n+\t  if (pfile->state.parsing_args == 2)\n+\t    cpp_error (pfile, DL_ERROR,\n+\t\t       \"unterminated argument list invoking macro \\\"%s\\\"\",\n+\t\t       NODE_NAME (fmacro.node));\n \t  pfile->line++;\n-\t  goto finish_output;\n+\t  goto done;\n \n \tcase '\\r': case '\\n':\n \t  cur = handle_newline (pfile, cur - 1);\n-\t  out[-1] = '\\0';\n-\tfinish_output:\n-\t  CUR (context) = cur;\n-\t  pfile->trad_out_cur = out - 1;\n-\t  return;\n+\t  if (pfile->state.parsing_args == 2)\n+\t    {\n+\t      /* Newlines in arguments become a space.  */\n+\t      out[-1] = ' ';\n+\t      continue;\n+\t    }\n+\t  goto done;\n \n \tcase '\"':\n \tcase '\\'':\n@@ -418,16 +485,25 @@ scan_out_logical_line (pfile, macro)\n \t      pfile->trad_out_cur = --out;\n \t      node = lex_identifier (pfile, cur - 1);\n \n-\t      if (node->type == NT_MACRO && !pfile->state.prevent_expansion)\n+\t      if (node->type == NT_MACRO\n+\t\t  && pfile->state.parsing_args != 2\n+\t\t  && !pfile->state.prevent_expansion)\n \t\t{\n-\t\t  /* Remove the macro name from the output.  */\n-\t\t  pfile->trad_out_cur = out;\n-\t\t  push_replacement_text (pfile, node);\n-\t\t  goto new_context;\n+\t\t  if (node->value.macro->fun_like)\n+\t\t    maybe_start_funlike (pfile, node, out, &fmacro);\n+\t\t  else\n+\t\t    {\n+\t\t      /* Remove the object-like macro's name from the\n+\t\t\t output, and push its replacement text.  */\n+\t\t      pfile->trad_out_cur = out;\n+\t\t      push_replacement_text (pfile, node);\n+\t\t      goto new_context;\n+\t\t    }\n \t\t}\n \t      else if (macro && node->arg_index)\n \t\t{\n-\t\t  /* Remove the macro name from the output.  */\n+\t\t  /* Found a parameter in the replacement text of a\n+\t\t     #define.  Remove its name from the output.  */\n \t\t  pfile->trad_out_cur = out;\n \t\t  save_replacement_text (pfile, macro, node->arg_index);\n \t\t}\n@@ -437,25 +513,162 @@ scan_out_logical_line (pfile, macro)\n \t    }\n \t  break;\n \n+\tcase '(':\n+\t  if (quote == 0)\n+\t    {\n+\t      paren_depth++;\n+\t      if (pfile->state.parsing_args == 1)\n+\t\t{\n+\t\t  const uchar *p = pfile->trad_out_base + fmacro.offset;\n+\n+\t\t  /* Invoke a prior function-like macro if there is only\n+\t\t     white space in-between.  */\n+\t\t  while (is_numchar (*p))\n+\t\t    p++;\n+\t\t  while (is_space (*p))\n+\t\t    p++;\n+\n+\t\t  if (p == out - 1)\n+\t\t    {\n+\t\t      pfile->state.parsing_args = 2;\n+\t\t      paren_depth = 1;\n+\t\t      out = pfile->trad_out_base + fmacro.offset;\n+\t\t      fmacro.args[0] = fmacro.offset;\n+\t\t    }\n+\t\t  else\n+\t\t    pfile->state.parsing_args = 0;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase ',':\n+\t  if (quote == 0 && pfile->state.parsing_args == 2 && paren_depth == 1)\n+\t    save_argument (&fmacro, out - pfile->trad_out_base);\n+\t  break;\n+\n+\tcase ')':\n+\t  if (quote == 0)\n+\t    {\n+\t      paren_depth--;\n+\t      if (pfile->state.parsing_args == 2 && paren_depth == 0)\n+\t\t{\n+\t\t  cpp_macro *m = fmacro.node->value.macro;\n+\n+\t\t  pfile->state.parsing_args = 0;\n+\t\t  save_argument (&fmacro, out - pfile->trad_out_base);\n+\n+\t\t  /* A single whitespace argument is no argument.  */\n+\t\t  if (fmacro.argc == 1 && m->paramc == 0)\n+\t\t    {\n+\t\t      const uchar *p = pfile->trad_out_base;\n+\t\t      p += fmacro.args[0];\n+\t\t      while (is_space (*p))\n+\t\t\tp++;\n+\t\t      if (p == pfile->trad_out_base + fmacro.args[1])\n+\t\t\tfmacro.argc = 0;\n+\t\t    }\n+\n+\t\t  if (_cpp_arguments_ok (pfile, m, fmacro.node, fmacro.argc))\n+\t\t    {\n+\t\t      /* Remove the macro's invocation from the\n+\t\t\t output, and push its replacement text.  */\n+\t\t      pfile->trad_out_cur = (pfile->trad_out_base\n+\t\t\t\t\t     + fmacro.offset);\n+\t\t      CUR (context) = cur;\n+\t\t      replace_args_and_push (pfile, &fmacro);\n+\t\t      goto new_context;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}\n     }\n+\n+ done:\n+  out[-1] = '\\0';\n+  CUR (context) = cur;\n+  pfile->trad_out_cur = out - 1;\n+  if (fmacro.buff)\n+    _cpp_release_buff (pfile, fmacro.buff);\n }\n \n /* Push a context holding the replacement text of the macro NODE on\n-   the context stack.  Doesn't yet handle special built-ins or\n-   function-like macros.  */\n+   the context stack.  NODE is either object-like, or a function-like\n+   macro with no arguments.  */\n static void\n push_replacement_text (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n   cpp_macro *macro = node->value.macro;\n \n-  _cpp_push_text_context (pfile, node,\n-\t\t\t  macro->exp.text,\n-\t\t\t  macro->exp.text + macro->count);\n+  _cpp_push_text_context (pfile, node, macro->exp.text, macro->count);\n+}\n+\n+/* Push a context holding the replacement text of the macro NODE on\n+   the context stack.  NODE is either object-like, or a function-like\n+   macro with no arguments.  */\n+static void\n+replace_args_and_push (pfile, fmacro)\n+     cpp_reader *pfile;\n+     struct fun_macro *fmacro;\n+{\n+  cpp_macro *macro = fmacro->node->value.macro;\n+\n+  if (macro->paramc == 0)\n+    push_replacement_text (pfile, fmacro->node);\n+  else\n+    {\n+      const uchar *exp;\n+      uchar *p;\n+      _cpp_buff *buff;\n+      size_t len = 0;\n+\n+      /* Calculate the length of the argument-replaced text.  */\n+      for (exp = macro->exp.text;;)\n+\t{\n+\t  struct block *b = (struct block *) exp;\n+\n+\t  len += b->text_len;\n+\t  if (b->arg_index == 0)\n+\t    break;\n+\t  len += (fmacro->args[b->arg_index]\n+\t\t  - fmacro->args[b->arg_index - 1] - 1);\n+\t  exp += BLOCK_LEN (b->text_len);\n+\t}\n+\n+      /* Allocate room for the expansion plus NUL.  */\n+      buff = _cpp_get_buff (pfile, len + 1);\n+\n+      /* Copy the expansion and replace arguments.  */\n+      p = BUFF_FRONT (buff);\n+      for (exp = macro->exp.text;;)\n+\t{\n+\t  struct block *b = (struct block *) exp;\n+\t  size_t arglen;\n+\n+\t  memcpy (p, b->text, b->text_len);\n+\t  p += b->text_len;\n+\t  if (b->arg_index == 0)\n+\t    break;\n+\t  arglen = (fmacro->args[b->arg_index]\n+\t\t    - fmacro->args[b->arg_index - 1] - 1);\n+\t  memcpy (p, pfile->trad_out_base + fmacro->args[b->arg_index - 1],\n+\t\t  arglen);\n+\t  p += arglen;\n+\t  exp += BLOCK_LEN (b->text_len);\n+\t}\n+\n+      /* NUL-terminate.  */\n+      *p = '\\0';\n+      _cpp_push_text_context (pfile, fmacro->node, BUFF_FRONT (buff), len);\n+\n+      /* So we free buffer allocation when macro is left.  */\n+      pfile->context->buff = buff;\n+    }\n }\n \n /* Read and record the parameters, if any, of a function-like macro\n@@ -476,7 +689,7 @@ scan_parameters (pfile, macro)\n     {\n       cur = skip_whitespace (pfile, cur);\n \n-      if (ISIDST (*cur))\n+      if (is_idstart (*cur))\n \t{\n \t  ok = false;\n \t  if (_cpp_save_parameter (pfile, macro, lex_identifier (pfile, cur)))\n@@ -500,25 +713,6 @@ scan_parameters (pfile, macro)\n   return ok;\n }\n \n-/* Calculate the length of the replacement text of MACRO.  */\n-static unsigned int\n-replacement_length (macro)\n-     cpp_macro *macro;\n-{\n-  unsigned int result = 0;\n-  const uchar *exp = macro->exp.text;\n-\n-  for (;;)\n-    {\n-      struct block *block = (struct block *) exp;\n-\n-      result += block->text_len;\n-      if (block->arg_index == 0)\n-\treturn result;\n-      exp += BLOCK_LEN (block->text_len);\n-    }\n-}\n-\n /* Save the text from pfile->trad_out_base to pfile->trad_out_cur as\n    the replacement text for the current macro, followed by argument\n    ARG_INDEX, with zero indicating the end of the replacement\n@@ -568,10 +762,7 @@ save_replacement_text (pfile, macro, arg_index)\n \t in the replacement list, excluding the parameter names, and\n \t save this in macro->count, else store the total bytes in the\n \t replacement text so far (including block headers).  */\n-      if (arg_index == 0)\n-\tmacro->count = replacement_length (macro);\n-      else\n-\tmacro->count += blen;\n+      macro->count += blen;\n     }\n }\n \n@@ -585,13 +776,11 @@ _cpp_create_trad_definition (pfile, macro)\n   const uchar *cur;\n   uchar *limit;\n \n-  /* Skip leading whitespace now.  */\n-  CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n-\n   /* Is this a function-like macro?  */\n   if (* CUR (pfile->context) == '(')\n     {\n-      /* Setting macro to NULL indicates an error occurred.  */\n+      /* Setting macro to NULL indicates an error occurred, and\n+\t prevents unnecessary work in scan_out_logical_line.  */\n       if (!scan_parameters (pfile, macro))\n \tmacro = NULL;\n       else\n@@ -601,10 +790,11 @@ _cpp_create_trad_definition (pfile, macro)\n \t  BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n \t  macro->fun_like = 1;\n \t}\n-\n-      CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n     }\n \n+  /* Skip leading whitespace in the replacement text.  */\n+  CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n+\n   pfile->trad_out_cur = pfile->trad_out_base;\n   pfile->state.prevent_expansion++;\n   scan_out_logical_line (pfile, macro);"}]}