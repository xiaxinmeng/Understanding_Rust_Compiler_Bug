{"sha": "d1704358924217b920bb60e0197282154fa02a4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE3MDQzNTg5MjQyMTdiOTIwYmI2MGUwMTk3MjgyMTU0ZmEwMmE0Yg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-12-10T14:10:21Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-12-10T14:10:21Z"}, "message": "New sreal implementation which uses int64_t as m_sig.\n\n\t* sreal.c (sreal::shift_right): New implementation\n\tfor int64_t as m_sig.\n\t(sreal::normalize): Likewise.\n\t(sreal::to_int): Likewise.\n\t(sreal::operator+): Likewise.\n\t(sreal::operator-): Likewise.\n\t(sreal::operator*): Likewise.\n\t(sreal::operator/): Likewise.\n\t(sreal::signedless_minus): Removed.\n\t(sreal::signedless_plus): Removed.\n\t(sreal::debug): const keyword is added.\n\t* sreal.h (sreal::operator<): New implementation\n\tfor int64_t as m_sig.\n\t* ipa-inline.c (recursive_inlining): LONG_MIN is replaced\n\twith sreal::min ().\n\nFrom-SVN: r218579", "tree": {"sha": "ffe4ab982c92ed3a2f7657504310fbfd73c09665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffe4ab982c92ed3a2f7657504310fbfd73c09665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1704358924217b920bb60e0197282154fa02a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1704358924217b920bb60e0197282154fa02a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1704358924217b920bb60e0197282154fa02a4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1704358924217b920bb60e0197282154fa02a4b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42c0b54df5517af870ae4f50c32886ac77af2046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c0b54df5517af870ae4f50c32886ac77af2046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c0b54df5517af870ae4f50c32886ac77af2046"}], "stats": {"total": 207, "additions": 81, "deletions": 126}, "files": [{"sha": "c74adfae2bc2eee625ab0f0d638cbeaa661cf282", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1704358924217b920bb60e0197282154fa02a4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1704358924217b920bb60e0197282154fa02a4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1704358924217b920bb60e0197282154fa02a4b", "patch": "@@ -1,3 +1,21 @@\n+2014-12-10  Martin Liska  <mliska@suse.cz>\n+\n+\t* sreal.c (sreal::shift_right): New implementation\n+\tfor int64_t as m_sig.\n+\t(sreal::normalize): Likewise.\n+\t(sreal::to_int): Likewise.\n+\t(sreal::operator+): Likewise.\n+\t(sreal::operator-): Likewise.\n+\t(sreal::operator*): Likewise.\n+\t(sreal::operator/): Likewise.\n+\t(sreal::signedless_minus): Removed.\n+\t(sreal::signedless_plus): Removed.\n+\t(sreal::debug): const keyword is added.\n+\t* sreal.h (sreal::operator<): New implementation\n+\tfor int64_t as m_sig.\n+\t* ipa-inline.c (recursive_inlining): LONG_MIN is replaced\n+\twith sreal::min ().\n+\n 2014-12-10  Martin Liska  <mliska@suse.cz>\n \n \t* gimple-iterator.h (gsi_start_bb_nondebug): New function."}, {"sha": "9f600b092c2ea0c1f0d3c4b8a5dc2c86114dfcdd", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1704358924217b920bb60e0197282154fa02a4b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1704358924217b920bb60e0197282154fa02a4b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d1704358924217b920bb60e0197282154fa02a4b", "patch": "@@ -1311,7 +1311,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t\t    vec<cgraph_edge *> *new_edges)\n {\n   int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n-  edge_heap_t heap (LONG_MIN);\n+  edge_heap_t heap (sreal::min ());\n   struct cgraph_node *node;\n   struct cgraph_edge *e;\n   struct cgraph_node *master_clone = NULL, *next;"}, {"sha": "bc3af2309db4554483c34989c1c7442983ddcbe2", "filename": "gcc/sreal.c", "status": "modified", "additions": 40, "deletions": 91, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1704358924217b920bb60e0197282154fa02a4b/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1704358924217b920bb60e0197282154fa02a4b/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=d1704358924217b920bb60e0197282154fa02a4b", "patch": "@@ -61,13 +61,13 @@ sreal::dump (FILE *file) const\n }\n \n DEBUG_FUNCTION void\n-debug (sreal &ref)\n+debug (const sreal &ref)\n {\n   ref.dump (stderr);\n }\n \n DEBUG_FUNCTION void\n-debug (sreal *ptr)\n+debug (const sreal *ptr)\n {\n   if (ptr)\n     debug (*ptr);\n@@ -91,7 +91,7 @@ sreal::shift_right (int s)\n \n   m_exp += s;\n \n-  m_sig += (uint64_t) 1 << (s - 1);\n+  m_sig += (int64_t) 1 << (s - 1);\n   m_sig >>= s;\n }\n \n@@ -100,108 +100,86 @@ sreal::shift_right (int s)\n void\n sreal::normalize ()\n {\n-  if (m_sig == 0)\n+  int64_t s = m_sig < 0 ? -1 : 1;\n+  unsigned HOST_WIDE_INT sig = absu_hwi (m_sig);\n+\n+  if (sig == 0)\n     {\n-      m_negative = 0;\n       m_exp = -SREAL_MAX_EXP;\n     }\n-  else if (m_sig < SREAL_MIN_SIG)\n+  else if (sig < SREAL_MIN_SIG)\n     {\n       do\n \t{\n-\t  m_sig <<= 1;\n+\t  sig <<= 1;\n \t  m_exp--;\n \t}\n-      while (m_sig < SREAL_MIN_SIG);\n+      while (sig < SREAL_MIN_SIG);\n \n       /* Check underflow.  */\n       if (m_exp < -SREAL_MAX_EXP)\n \t{\n \t  m_exp = -SREAL_MAX_EXP;\n-\t  m_sig = 0;\n+\t  sig = 0;\n \t}\n     }\n-  else if (m_sig > SREAL_MAX_SIG)\n+  else if (sig > SREAL_MAX_SIG)\n     {\n       int last_bit;\n       do\n \t{\n-\t  last_bit = m_sig & 1;\n-\t  m_sig >>= 1;\n+\t  last_bit = sig & 1;\n+\t  sig >>= 1;\n \t  m_exp++;\n \t}\n-      while (m_sig > SREAL_MAX_SIG);\n+      while (sig > SREAL_MAX_SIG);\n \n       /* Round the number.  */\n-      m_sig += last_bit;\n-      if (m_sig > SREAL_MAX_SIG)\n+      sig += last_bit;\n+      if (sig > SREAL_MAX_SIG)\n \t{\n-\t  m_sig >>= 1;\n+\t  sig >>= 1;\n \t  m_exp++;\n \t}\n \n       /* Check overflow.  */\n       if (m_exp > SREAL_MAX_EXP)\n \t{\n \t  m_exp = SREAL_MAX_EXP;\n-\t  m_sig = SREAL_MAX_SIG;\n+\t  sig = SREAL_MAX_SIG;\n \t}\n     }\n+\n+  m_sig = s * sig;\n }\n \n /* Return integer value of *this.  */\n \n int64_t\n sreal::to_int () const\n {\n-  int64_t sign = m_negative ? -1 : 1;\n+  int64_t sign = m_sig < 0 ? -1 : 1;\n \n   if (m_exp <= -SREAL_BITS)\n     return 0;\n   if (m_exp >= SREAL_PART_BITS)\n     return sign * INTTYPE_MAXIMUM (int64_t);\n   if (m_exp > 0)\n-    return sign * (m_sig << m_exp);\n+    return m_sig << m_exp;\n   if (m_exp < 0)\n-    return sign * (m_sig >> -m_exp);\n-  return sign * m_sig;\n+    return m_sig >> -m_exp;\n+  return m_sig;\n }\n \n /* Return *this + other.  */\n \n sreal\n sreal::operator+ (const sreal &other) const\n {\n-  const sreal *a_p = this, *b_p = &other;\n-\n-  if (a_p->m_negative && !b_p->m_negative)\n-    std::swap (a_p, b_p);\n-\n-  /* a + -b => a - b.  */\n-  if (!a_p->m_negative && b_p->m_negative)\n-    {\n-      sreal tmp = -(*b_p);\n-      if (*a_p < tmp)\n-\treturn signedless_minus (tmp, *a_p, true);\n-      else\n-\treturn signedless_minus (*a_p, tmp, false);\n-    }\n-\n-  gcc_checking_assert (a_p->m_negative == b_p->m_negative);\n-\n-  sreal r = signedless_plus (*a_p, *b_p, a_p->m_negative);\n-\n-  return r;\n-}\n-\n-sreal\n-sreal::signedless_plus (const sreal &a, const sreal &b, bool negative)\n-{\n-  const sreal *bb;\n-  sreal r, tmp;\n   int dexp;\n-  const sreal *a_p = &a;\n-  const sreal *b_p = &b;\n+  sreal tmp, r;\n+\n+  const sreal *a_p = this, *b_p = &other, *bb;\n \n   if (a_p->m_exp < b_p->m_exp)\n     std::swap (a_p, b_p);\n@@ -211,7 +189,6 @@ sreal::signedless_plus (const sreal &a, const sreal &b, bool negative)\n   if (dexp > SREAL_BITS)\n     {\n       r.m_sig = a_p->m_sig;\n-      r.m_negative = negative;\n       return r;\n     }\n \n@@ -226,56 +203,32 @@ sreal::signedless_plus (const sreal &a, const sreal &b, bool negative)\n \n   r.m_sig = a_p->m_sig + bb->m_sig;\n   r.normalize ();\n-\n-  r.m_negative = negative;\n   return r;\n }\n \n+\n /* Return *this - other.  */\n \n sreal\n sreal::operator- (const sreal &other) const\n-{\n-  /* -a - b => -a + (-b).  */\n-  if (m_negative && !other.m_negative)\n-    return signedless_plus (*this, -other, true);\n-\n-  /* a - (-b) => a + b.  */\n-  if (!m_negative && other.m_negative)\n-    return signedless_plus (*this, -other, false);\n-\n-  gcc_checking_assert (m_negative == other.m_negative);\n-\n-  /* We want to substract a smaller number from bigger\n-    for nonegative numbers.  */\n-  if (!m_negative && *this < other)\n-    return signedless_minus (other, *this, true);\n-\n-  /* Example: -2 - (-3) => 3 - 2 */\n-  if (m_negative && *this > other)\n-    return signedless_minus (-other, -(*this), false);\n-\n-  sreal r = signedless_minus (*this, other, m_negative);\n-\n-  return r;\n-}\n-\n-sreal\n-sreal::signedless_minus (const sreal &a, const sreal &b, bool negative)\n {\n   int dexp;\n   sreal tmp, r;\n   const sreal *bb;\n-  const sreal *a_p = &a;\n-  const sreal *b_p = &b;\n+  const sreal *a_p = this, *b_p = &other;\n \n-  dexp = a_p->m_exp - b_p->m_exp;\n+  int64_t sign = 1;\n+  if (a_p->m_exp < b_p->m_exp)\n+    {\n+      sign = -1;\n+      std::swap (a_p, b_p);\n+    }\n \n+  dexp = a_p->m_exp - b_p->m_exp;\n   r.m_exp = a_p->m_exp;\n   if (dexp > SREAL_BITS)\n     {\n-      r.m_sig = a_p->m_sig;\n-      r.m_negative = negative;\n+      r.m_sig = sign * a_p->m_sig;\n       return r;\n     }\n   if (dexp == 0)\n@@ -287,10 +240,8 @@ sreal::signedless_minus (const sreal &a, const sreal &b, bool negative)\n       bb = &tmp;\n     }\n \n-  r.m_sig = a_p->m_sig - bb->m_sig;\n+  r.m_sig = sign * (a_p->m_sig - bb->m_sig);\n   r.normalize ();\n-\n-  r.m_negative = negative;\n   return r;\n }\n \n@@ -300,7 +251,7 @@ sreal\n sreal::operator* (const sreal &other) const\n {\n   sreal r;\n-  if (m_sig < SREAL_MIN_SIG || other.m_sig < SREAL_MIN_SIG)\n+  if (std::abs (m_sig) < SREAL_MIN_SIG || std::abs (other.m_sig) < SREAL_MIN_SIG)\n     {\n       r.m_sig = 0;\n       r.m_exp = -SREAL_MAX_EXP;\n@@ -312,7 +263,6 @@ sreal::operator* (const sreal &other) const\n       r.normalize ();\n     }\n \n-  r.m_negative = m_negative ^ other.m_negative;\n   return r;\n }\n \n@@ -325,7 +275,6 @@ sreal::operator/ (const sreal &other) const\n   sreal r;\n   r.m_sig = (m_sig << SREAL_PART_BITS) / other.m_sig;\n   r.m_exp = m_exp - other.m_exp - SREAL_PART_BITS;\n-  r.m_negative = m_negative ^ other.m_negative;\n   r.normalize ();\n   return r;\n }"}, {"sha": "730f49c4d899a97c944e452ee489ae2303e8c1e9", "filename": "gcc/sreal.h", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1704358924217b920bb60e0197282154fa02a4b/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1704358924217b920bb60e0197282154fa02a4b/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=d1704358924217b920bb60e0197282154fa02a4b", "patch": "@@ -25,8 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #define UINT64_BITS\t64\n \n-#define SREAL_MIN_SIG ((uint64_t) 1 << (SREAL_PART_BITS - 1))\n-#define SREAL_MAX_SIG (((uint64_t) 1 << SREAL_PART_BITS) - 1)\n+#define SREAL_MIN_SIG ((int64_t) 1 << (SREAL_PART_BITS - 2))\n+#define SREAL_MAX_SIG (((int64_t) 1 << (SREAL_PART_BITS - 1)) - 1)\n #define SREAL_MAX_EXP (INT_MAX / 4)\n \n #define SREAL_BITS SREAL_PART_BITS\n@@ -36,18 +36,11 @@ class sreal\n {\n public:\n   /* Construct an uninitialized sreal.  */\n-  sreal () : m_sig (-1), m_exp (-1), m_negative (0) {}\n+  sreal () : m_sig (-1), m_exp (-1) {}\n \n   /* Construct a sreal.  */\n-  sreal (int64_t sig, int exp = 0) : m_exp (exp)\n+  sreal (int64_t sig, int exp = 0) : m_sig (sig), m_exp (exp)\n   {\n-    m_negative = sig < 0;\n-\n-    if (sig < 0)\n-      sig = -sig;\n-\n-    m_sig = (uint64_t) sig;\n-\n     normalize ();\n   }\n \n@@ -60,33 +53,30 @@ class sreal\n \n   bool operator< (const sreal &other) const\n   {\n-    /* We negate result in case of negative numbers and\n-       it would return true for equal negative numbers.  */\n-    if (*this == other)\n-      return false;\n-\n-    if (m_negative != other.m_negative)\n-      return m_negative > other.m_negative;\n-\n-    bool r = m_exp < other.m_exp\n-      || (m_exp == other.m_exp && m_sig < other.m_sig);\n-\n-    return m_negative ? !r : r;\n+    if (m_exp == other.m_exp)\n+      return m_sig < other.m_sig;\n+    else\n+    {\n+      bool negative = m_sig < 0;\n+      bool other_negative = other.m_sig < 0;\n+\n+      if (negative != other_negative)\n+        return negative > other_negative;\n+\n+      bool r = m_exp < other.m_exp;\n+      return negative ? !r : r;\n+    }\n   }\n \n   bool operator== (const sreal &other) const\n   {\n-    return m_exp == other.m_exp && m_sig == other.m_sig\n-\t\t    && m_negative == other.m_negative;\n+    return m_exp == other.m_exp && m_sig == other.m_sig;\n   }\n \n   sreal operator- () const\n   {\n-    if (m_sig == 0)\n-      return *this;\n-\n     sreal tmp = *this;\n-    tmp.m_negative = !tmp.m_negative;\n+    tmp.m_sig *= -1;\n \n     return tmp;\n   }\n@@ -125,17 +115,15 @@ class sreal\n private:\n   void normalize ();\n   void shift_right (int amount);\n-\n   static sreal signedless_plus (const sreal &a, const sreal &b, bool negative);\n   static sreal signedless_minus (const sreal &a, const sreal &b, bool negative);\n \n-  uint64_t m_sig;\t\t\t/* Significant.  */\n+  int64_t m_sig;\t\t\t/* Significant.  */\n   signed int m_exp;\t\t\t/* Exponent.  */\n-  bool m_negative;\t\t\t/* Negative sign.  */\n };\n \n-extern void debug (sreal &ref);\n-extern void debug (sreal *ptr);\n+extern void debug (const sreal &ref);\n+extern void debug (const sreal *ptr);\n \n inline sreal &operator+= (sreal &a, const sreal &b)\n {"}]}