{"sha": "3de237276c454889c40459223324de6a8a6dd6af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RlMjM3Mjc2YzQ1NDg4OWM0MDQ1OTIyMzMyNGRlNmE4YTZkZDZhZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-14T06:47:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-14T06:47:56Z"}, "message": "regrename.c (kill_value_regno): Simplify chain removal.\n\n        * regrename.c (kill_value_regno): Simplify chain removal.\n        (kill_value): Kill all of HARD_REGNO_NREGS.\n        (kill_set_value): Use kill_value not kill_value_regno.\n        (kill_autoinc_value): Likewise.\n        (copyprop_hardreg_forward): Don't collect refresh_blocks.\n        Call delete_noop_moves.\n\nFrom-SVN: r47992", "tree": {"sha": "6cfed4f3485237b029b5e6abbc1f7d64a4f5dfdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cfed4f3485237b029b5e6abbc1f7d64a4f5dfdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3de237276c454889c40459223324de6a8a6dd6af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de237276c454889c40459223324de6a8a6dd6af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3de237276c454889c40459223324de6a8a6dd6af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3de237276c454889c40459223324de6a8a6dd6af/comments", "author": null, "committer": null, "parents": [{"sha": "c178fe8964aa4f022ff4b4d8d74344cea7f0c11c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c178fe8964aa4f022ff4b4d8d74344cea7f0c11c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c178fe8964aa4f022ff4b4d8d74344cea7f0c11c"}], "stats": {"total": 62, "additions": 33, "deletions": 29}, "files": [{"sha": "c91c357e5acbeeaa60d0bea1030263269ccb86b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3de237276c454889c40459223324de6a8a6dd6af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3de237276c454889c40459223324de6a8a6dd6af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3de237276c454889c40459223324de6a8a6dd6af", "patch": "@@ -1,3 +1,12 @@\n+2001-12-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* regrename.c (kill_value_regno): Simplify chain removal.\n+\t(kill_value): Kill all of HARD_REGNO_NREGS.\n+\t(kill_set_value): Use kill_value not kill_value_regno.\n+\t(kill_autoinc_value): Likewise.\n+\t(copyprop_hardreg_forward): Don't collect refresh_blocks.\n+\tCall delete_noop_moves.\n+\n 2001-12-13  Aldy Hernandez  <aldyh@redhat.com>\n \n         * attribs.c (c_common_attribute_table): Swap decl_req and type_req"}, {"sha": "e6aa8c8f9b9f019c20c0df298263707bde36fd13", "filename": "gcc/regrename.c", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3de237276c454889c40459223324de6a8a6dd6af/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3de237276c454889c40459223324de6a8a6dd6af/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=3de237276c454889c40459223324de6a8a6dd6af", "patch": "@@ -1025,16 +1025,7 @@ kill_value_regno (regno, vd)\n \t   vd->e[i].next_regno != regno;\n \t   i = vd->e[i].next_regno)\n \tcontinue;\n-\n-      next = vd->e[regno].next_regno;\n-      while (1)\n-\t{\n-\t  vd->e[i].next_regno = next;\n-\t  if (next == INVALID_REGNUM)\n-\t    break;\n-\t  i = next;\n-\t  next = vd->e[next].next_regno;\n-\t}\n+      vd->e[i].next_regno = vd->e[regno].next_regno;\n     }\n   else if ((next = vd->e[regno].next_regno) != INVALID_REGNUM)\n     {\n@@ -1052,15 +1043,22 @@ kill_value_regno (regno, vd)\n }\n \n /* Kill X.  This is a convenience function for kill_value_regno\n-   so that we don't have to check that X is a register first.  */\n+   so that we mind the mode the register is in.  */\n \n static void\n kill_value (x, vd)\n      rtx x;\n      struct value_data *vd;\n {\n   if (REG_P (x))\n-    kill_value_regno (REGNO (x), vd);\n+    {\n+      unsigned int regno = REGNO (x);\n+      unsigned int n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      unsigned int i;\n+\n+      for (i = 0; i < n; ++i)\n+\tkill_value_regno (regno + i, vd);\n+    }\n }\n \n /* Initialize VD such that there are no known relationships between regs.  */\n@@ -1103,9 +1101,8 @@ kill_set_value (x, set, data)\n   struct value_data *vd = data;\n   if (GET_CODE (set) != CLOBBER && REG_P (x))\n     {\n-      unsigned int regno = REGNO (x);\n-      kill_value_regno (regno, vd);\n-      vd->e[regno].mode = GET_MODE (x);\n+      kill_value (x, vd);\n+      vd->e[REGNO (x)].mode = GET_MODE (x);\n     }\n }\n \n@@ -1123,9 +1120,9 @@ kill_autoinc_value (px, data)\n \n   if (GET_RTX_CLASS (GET_CODE (x)) == 'a')\n     {\n-      unsigned int regno = REGNO (XEXP (x, 0));\n-      kill_value_regno (regno, vd);\n-      vd->e[regno].mode = Pmode;\n+      x = XEXP (x, 0);\n+      kill_value (x, vd);\n+      vd->e[REGNO (x)].mode = Pmode;\n       return -1;\n     }\n \n@@ -1547,13 +1544,11 @@ copyprop_hardreg_forward_1 (bb, vd)\n void\n copyprop_hardreg_forward ()\n {\n-  int b, need_refresh;\n-  sbitmap refresh_blocks;\n   struct value_data *all_vd;\n+  bool need_refresh;\n+  int b;\n \n-  refresh_blocks = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_zero (refresh_blocks);\n-  need_refresh = 0;\n+  need_refresh = false;\n \n   all_vd = xmalloc (sizeof (struct value_data) * n_basic_blocks);\n \n@@ -1574,24 +1569,24 @@ copyprop_hardreg_forward ()\n         init_value_data (all_vd + b);\n \n       if (copyprop_hardreg_forward_1 (bb, all_vd + b))\n-\t{\n-\t  SET_BIT (refresh_blocks, b);\n-\t  need_refresh = 1;\n-\t}\n+\tneed_refresh = true;\n     }\n \n   if (need_refresh)\n     {\n       if (rtl_dump_file)\n \tfputs (\"\\n\\n\", rtl_dump_file);\n \n-      update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+      /* ??? Irritatingly, delete_noop_moves does not take a set of blocks\n+\t to scan, so we have to do a life update with no initial set of\n+\t blocks Just In Case.  */\n+      delete_noop_moves (get_insns ());\n+      update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t\tPROP_DEATH_NOTES\n \t\t\t| PROP_SCAN_DEAD_CODE\n \t\t\t| PROP_KILL_DEAD_CODE);\n     }\n \n-  sbitmap_free (refresh_blocks);\n   free (all_vd);\n }\n "}]}