{"sha": "77d16198fc5262198db7ed29609a791104b37fcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdkMTYxOThmYzUyNjIxOThkYjdlZDI5NjA5YTc5MTEwNGIzN2ZjZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2009-11-06T11:39:35Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-06T11:39:35Z"}, "message": "multiway_merge.h: Simple formatting and uglification fixes.\n\n2009-11-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/parallel/multiway_merge.h: Simple formatting and\n\tuglification fixes.\n\t* include/parallel/find_selectors.h: Likewise.\n\t* include/parallel/losertree.h: Likewise.\n\t* include/parallel/list_partition.h: Likewise.\n\t* include/parallel/for_each.h: Likewise.\n\t* include/parallel/multiseq_selection.h: Likewise.\n\t* include/parallel/workstealing.h: Likewise.\n\t* include/parallel/par_loop.h: Likewise.\n\t* include/parallel/numeric: Likewise.\n\t* include/parallel/quicksort.h: Likewise.\n\t* include/parallel/equally_split.h: Likewise.\n\t* include/parallel/omp_loop_static.h: Likewise.\n\t* include/parallel/random_shuffle.h: Likewise.\n\t* include/parallel/balanced_quicksort.h: Likewise.\n\t* include/parallel/tags.h: Likewise.\n\t* include/parallel/set_operations.h: Likewise.\n\t* include/parallel/merge.h: Likewise.\n\t* include/parallel/unique_copy.h: Likewise.\n\t* include/parallel/multiway_mergesort.h: Likewise.\n\t* include/parallel/search.h: Likewise.\n\t* include/parallel/partition.h: Likewise.\n\t* include/parallel/partial_sum.h: Likewise.\n\t* include/parallel/find.h: Likewise.\n\t* include/parallel/queue.h: Likewise.\n\t* include/parallel/omp_loop.h: Likewise.\n\t* include/parallel/checkers.h: Likewise.\n\t* include/parallel/sort.h: Likewise.\n\nFrom-SVN: r153966", "tree": {"sha": "1adc66e5655ae213d189aebc713a5de316b8dbee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1adc66e5655ae213d189aebc713a5de316b8dbee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77d16198fc5262198db7ed29609a791104b37fcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77d16198fc5262198db7ed29609a791104b37fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77d16198fc5262198db7ed29609a791104b37fcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77d16198fc5262198db7ed29609a791104b37fcf/comments", "author": null, "committer": null, "parents": [{"sha": "b169fe9de86d92718829e7dd63141c5c8fa9bb2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b169fe9de86d92718829e7dd63141c5c8fa9bb2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b169fe9de86d92718829e7dd63141c5c8fa9bb2e"}], "stats": {"total": 10969, "additions": 5472, "deletions": 5497}, "files": [{"sha": "ec39612f8f519a7cf380e36c98902120347c20bc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -1,3 +1,34 @@\n+2009-11-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/parallel/multiway_merge.h: Simple formatting and\n+\tuglification fixes.\n+\t* include/parallel/find_selectors.h: Likewise.\n+\t* include/parallel/losertree.h: Likewise.\n+\t* include/parallel/list_partition.h: Likewise.\n+\t* include/parallel/for_each.h: Likewise.\n+\t* include/parallel/multiseq_selection.h: Likewise.\n+\t* include/parallel/workstealing.h: Likewise.\n+\t* include/parallel/par_loop.h: Likewise.\n+\t* include/parallel/numeric: Likewise.\n+\t* include/parallel/quicksort.h: Likewise.\n+\t* include/parallel/equally_split.h: Likewise.\n+\t* include/parallel/omp_loop_static.h: Likewise.\n+\t* include/parallel/random_shuffle.h: Likewise.\n+\t* include/parallel/balanced_quicksort.h: Likewise.\n+\t* include/parallel/tags.h: Likewise.\n+\t* include/parallel/set_operations.h: Likewise.\n+\t* include/parallel/merge.h: Likewise.\n+\t* include/parallel/unique_copy.h: Likewise.\n+\t* include/parallel/multiway_mergesort.h: Likewise.\n+\t* include/parallel/search.h: Likewise.\n+\t* include/parallel/partition.h: Likewise.\n+\t* include/parallel/partial_sum.h: Likewise.\n+\t* include/parallel/find.h: Likewise.\n+\t* include/parallel/queue.h: Likewise.\n+\t* include/parallel/omp_loop.h: Likewise.\n+\t* include/parallel/checkers.h: Likewise.\n+\t* include/parallel/sort.h: Likewise.\n+\n 2009-11-06  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/41949"}, {"sha": "3107d97a45b8613899dce80561d1720ef66daf2c", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 376, "deletions": 377, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -57,436 +57,435 @@\n \n namespace __gnu_parallel\n {\n-/** @brief Information local to one thread in the parallel quicksort run. */\n-template<typename _RAIter>\n-  struct _QSBThreadLocal\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    /** @brief Continuous part of the sequence, described by an\n-    iterator pair. */\n-    typedef std::pair<_RAIter, _RAIter> _Piece;\n-\n-    /** @brief Initial piece to work on. */\n-    _Piece _M_initial;\n-\n-    /** @brief Work-stealing queue. */\n-    _RestrictedBoundedConcurrentQueue<_Piece> _M_leftover_parts;\n-\n-    /** @brief Number of threads involved in this algorithm. */\n-    _ThreadIndex _M_num_threads;\n-\n-    /** @brief Pointer to a counter of elements left over to sort. */\n-    volatile _DifferenceType* _M_elements_leftover;\n-\n-    /** @brief The complete sequence to sort. */\n-    _Piece _M_global;\n-\n-    /** @brief Constructor.\n-     *  @param __queue_size size of the work-stealing queue. */\n-    _QSBThreadLocal(int __queue_size) : _M_leftover_parts(__queue_size) { }\n-  };\n-\n-/** @brief Balanced quicksort divide step.\n-  *  @param __begin Begin iterator of subsequence.\n-  *  @param __end End iterator of subsequence.\n-  *  @param __comp Comparator.\n-  *  @param __num_threads Number of threads that are allowed to work on\n-  *  this part.\n-  *  @pre @__c (__end-__begin)>=1 */\n-template<typename _RAIter, typename _Compare>\n-  typename std::iterator_traits<_RAIter>::difference_type\n-  __qsb_divide(_RAIter __begin, _RAIter __end,\n-             _Compare __comp, _ThreadIndex __num_threads)\n-  {\n-    _GLIBCXX_PARALLEL_ASSERT(__num_threads > 0);\n-\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _RAIter __pivot_pos =\n-      __median_of_three_iterators(__begin, __begin + (__end - __begin) / 2,\n-                                __end  - 1, __comp);\n+  /** @brief Information local to one thread in the parallel quicksort run. */\n+  template<typename _RAIter>\n+    struct _QSBThreadLocal\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      /** @brief Continuous part of the sequence, described by an\n+      iterator pair. */\n+      typedef std::pair<_RAIter, _RAIter> _Piece;\n+\n+      /** @brief Initial piece to work on. */\n+      _Piece _M_initial;\n+\n+      /** @brief Work-stealing queue. */\n+      _RestrictedBoundedConcurrentQueue<_Piece> _M_leftover_parts;\n+\n+      /** @brief Number of threads involved in this algorithm. */\n+      _ThreadIndex _M_num_threads;\n+\n+      /** @brief Pointer to a counter of elements left over to sort. */\n+      volatile _DifferenceType* _M_elements_leftover;\n+\n+      /** @brief The complete sequence to sort. */\n+      _Piece _M_global;\n+\n+      /** @brief Constructor.\n+       *  @param __queue_size size of the work-stealing queue. */\n+      _QSBThreadLocal(int __queue_size) : _M_leftover_parts(__queue_size) { }\n+    };\n+\n+  /** @brief Balanced quicksort divide step.\n+    *  @param __begin Begin iterator of subsequence.\n+    *  @param __end End iterator of subsequence.\n+    *  @param __comp Comparator.\n+    *  @param __num_threads Number of threads that are allowed to work on\n+    *  this part.\n+    *  @pre @__c (__end-__begin)>=1 */\n+  template<typename _RAIter, typename _Compare>\n+    typename std::iterator_traits<_RAIter>::difference_type\n+    __qsb_divide(_RAIter __begin, _RAIter __end,\n+\t\t _Compare __comp, _ThreadIndex __num_threads)\n+    {\n+      _GLIBCXX_PARALLEL_ASSERT(__num_threads > 0);\n+\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      _RAIter __pivot_pos =\n+\t__median_of_three_iterators(__begin, __begin + (__end - __begin) / 2,\n+\t\t\t\t    __end  - 1, __comp);\n \n #if defined(_GLIBCXX_ASSERTIONS)\n-    // Must be in between somewhere.\n-    _DifferenceType __n = __end - __begin;\n-\n-    _GLIBCXX_PARALLEL_ASSERT(\n-           (!__comp(*__pivot_pos, *__begin) &&\n-              !__comp(*(__begin + __n / 2), *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *__begin) &&\n-              !__comp(*(__end - 1), *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) &&\n-              !__comp(*__begin, *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) &&\n-              !__comp(*(__end - 1), *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__end - 1)) &&\n-              !__comp(*__begin, *__pivot_pos))\n-        || (!__comp(*__pivot_pos, *(__end - 1)) &&\n-              !__comp(*(__begin + __n / 2), *__pivot_pos)));\n+      // Must be in between somewhere.\n+      _DifferenceType __n = __end - __begin;\n+\n+      _GLIBCXX_PARALLEL_ASSERT((!__comp(*__pivot_pos, *__begin)\n+\t\t\t\t&& !__comp(*(__begin + __n / 2),\n+\t\t\t\t\t   *__pivot_pos))\n+\t\t\t       || (!__comp(*__pivot_pos, *__begin)\n+\t\t\t\t   && !__comp(*(__end - 1), *__pivot_pos))\n+\t\t\t       || (!__comp(*__pivot_pos, *(__begin + __n / 2))\n+\t\t\t\t   && !__comp(*__begin, *__pivot_pos))\n+\t\t\t       || (!__comp(*__pivot_pos, *(__begin + __n / 2))\n+\t\t\t\t   && !__comp(*(__end - 1), *__pivot_pos))\n+\t\t\t       || (!__comp(*__pivot_pos, *(__end - 1))\n+\t\t\t\t   && !__comp(*__begin, *__pivot_pos))\n+\t\t\t       || (!__comp(*__pivot_pos, *(__end - 1))\n+\t\t\t\t   && !__comp(*(__begin + __n / 2),\n+\t\t\t\t\t      *__pivot_pos)));\n #endif\n \n-    // Swap pivot value to end.\n-    if (__pivot_pos != (__end - 1))\n-      std::swap(*__pivot_pos, *(__end - 1));\n-    __pivot_pos = __end - 1;\n+      // Swap pivot value to end.\n+      if (__pivot_pos != (__end - 1))\n+\tstd::swap(*__pivot_pos, *(__end - 1));\n+      __pivot_pos = __end - 1;\n \n-    __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n-        __pred(__comp, *__pivot_pos);\n+      __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n+\t__pred(__comp, *__pivot_pos);\n \n-    // Divide, returning __end - __begin - 1 in the worst case.\n-    _DifferenceType __split_pos = __parallel_partition(\n-        __begin, __end - 1, __pred, __num_threads);\n+      // Divide, returning __end - __begin - 1 in the worst case.\n+      _DifferenceType __split_pos = __parallel_partition(__begin, __end - 1,\n+\t\t\t\t\t\t\t __pred,\n+\t\t\t\t\t\t\t __num_threads);\n \n-    // Swap back pivot to middle.\n-    std::swap(*(__begin + __split_pos), *__pivot_pos);\n-    __pivot_pos = __begin + __split_pos;\n+      // Swap back pivot to middle.\n+      std::swap(*(__begin + __split_pos), *__pivot_pos);\n+      __pivot_pos = __begin + __split_pos;\n \n #if _GLIBCXX_ASSERTIONS\n-    _RAIter __r;\n-    for (__r = __begin; __r != __pivot_pos; ++__r)\n-      _GLIBCXX_PARALLEL_ASSERT(__comp(*__r, *__pivot_pos));\n-    for (; __r != __end; ++__r)\n-      _GLIBCXX_PARALLEL_ASSERT(!__comp(*__r, *__pivot_pos));\n+      _RAIter __r;\n+      for (__r = __begin; __r != __pivot_pos; ++__r)\n+\t_GLIBCXX_PARALLEL_ASSERT(__comp(*__r, *__pivot_pos));\n+      for (; __r != __end; ++__r)\n+\t_GLIBCXX_PARALLEL_ASSERT(!__comp(*__r, *__pivot_pos));\n #endif\n \n-    return __split_pos;\n-  }\n-\n-/** @brief Quicksort conquer step.\n-  *  @param __tls Array of thread-local storages.\n-  *  @param __begin Begin iterator of subsequence.\n-  *  @param __end End iterator of subsequence.\n-  *  @param __comp Comparator.\n-  *  @param __iam Number of the thread processing this function.\n-  *  @param __num_threads\n-  *          Number of threads that are allowed to work on this part. */\n-template<typename _RAIter, typename _Compare>\n-  void\n-  __qsb_conquer(_QSBThreadLocal<_RAIter>** __tls,\n-              _RAIter __begin, _RAIter __end,\n-              _Compare __comp,\n-              _ThreadIndex __iam, _ThreadIndex __num_threads,\n-              bool __parent_wait)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _DifferenceType __n = __end - __begin;\n-\n-    if (__num_threads <= 1 || __n <= 1)\n-      {\n-        __tls[__iam]->_M_initial.first  = __begin;\n-        __tls[__iam]->_M_initial.second = __end;\n+      return __split_pos;\n+    }\n \n-        __qsb_local_sort_with_helping(__tls, __comp, __iam, __parent_wait);\n+  /** @brief Quicksort conquer step.\n+    *  @param __tls Array of thread-local storages.\n+    *  @param __begin Begin iterator of subsequence.\n+    *  @param __end End iterator of subsequence.\n+    *  @param __comp Comparator.\n+    *  @param __iam Number of the thread processing this function.\n+    *  @param __num_threads\n+    *          Number of threads that are allowed to work on this part. */\n+  template<typename _RAIter, typename _Compare>\n+    void\n+    __qsb_conquer(_QSBThreadLocal<_RAIter>** __tls,\n+\t\t  _RAIter __begin, _RAIter __end,\n+\t\t  _Compare __comp,\n+\t\t  _ThreadIndex __iam, _ThreadIndex __num_threads,\n+\t\t  bool __parent_wait)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-        return;\n-      }\n+      _DifferenceType __n = __end - __begin;\n+\n+      if (__num_threads <= 1 || __n <= 1)\n+\t{\n+          __tls[__iam]->_M_initial.first  = __begin;\n+          __tls[__iam]->_M_initial.second = __end;\n+\n+          __qsb_local_sort_with_helping(__tls, __comp, __iam, __parent_wait);\n+\n+          return;\n+\t}\n \n-    // Divide step.\n-    _DifferenceType __split_pos =\n-            __qsb_divide(__begin, __end, __comp, __num_threads);\n+      // Divide step.\n+      _DifferenceType __split_pos =\n+\t__qsb_divide(__begin, __end, __comp, __num_threads);\n \n #if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(0 <= __split_pos &&\n-                             __split_pos < (__end - __begin));\n+      _GLIBCXX_PARALLEL_ASSERT(0 <= __split_pos &&\n+                               __split_pos < (__end - __begin));\n #endif\n \n-    _ThreadIndex __num_threads_leftside =\n-        std::max<_ThreadIndex>(1, std::min<_ThreadIndex>(\n-            __num_threads - 1, __split_pos * __num_threads / __n));\n+      _ThreadIndex\n+\t__num_threads_leftside = std::max<_ThreadIndex>\n+\t(1, std::min<_ThreadIndex>(__num_threads - 1, __split_pos\n+\t\t\t\t   * __num_threads / __n));\n \n-#   pragma omp atomic\n-    *__tls[__iam]->_M_elements_leftover -= (_DifferenceType)1;\n+#     pragma omp atomic\n+      *__tls[__iam]->_M_elements_leftover -= (_DifferenceType)1;\n \n-    // Conquer step.\n-#   pragma omp parallel num_threads(2)\n-    {\n-      bool __wait;\n-      if(omp_get_num_threads() < 2)\n-        __wait = false;\n-      else\n-        __wait = __parent_wait;\n-\n-#     pragma omp sections\n-        {\n+      // Conquer step.\n+#     pragma omp parallel num_threads(2)\n+      {\n+\tbool __wait;\n+\tif(omp_get_num_threads() < 2)\n+          __wait = false;\n+\telse\n+          __wait = __parent_wait;\n+\n+#       pragma omp sections\n+\t{\n #         pragma omp section\n-            {\n-              __qsb_conquer(__tls, __begin, __begin + __split_pos, __comp,\n-                          __iam,\n-                          __num_threads_leftside,\n-                          __wait);\n-              __wait = __parent_wait;\n-            }\n-          // The pivot_pos is left in place, to ensure termination.\n+\t  {\n+\t    __qsb_conquer(__tls, __begin, __begin + __split_pos, __comp,\n+\t\t\t  __iam, __num_threads_leftside, __wait);\n+\t    __wait = __parent_wait;\n+\t  }\n+\t  // The pivot_pos is left in place, to ensure termination.\n #         pragma omp section\n-            {\n-              __qsb_conquer(__tls, __begin + __split_pos + 1, __end, __comp,\n-                          __iam + __num_threads_leftside,\n-                          __num_threads - __num_threads_leftside,\n-                          __wait);\n-              __wait = __parent_wait;\n-            }\n-        }\n+\t  {\n+\t    __qsb_conquer(__tls, __begin + __split_pos + 1, __end, __comp,\n+\t\t\t  __iam + __num_threads_leftside,\n+\t\t\t  __num_threads - __num_threads_leftside, __wait);\n+\t    __wait = __parent_wait;\n+\t  }\n+\t}\n+      }\n     }\n-  }\n-\n-/**\n-  *  @brief Quicksort step doing load-balanced local sort.\n-  *  @param __tls Array of thread-local storages.\n-  *  @param __comp Comparator.\n-  *  @param __iam Number of the thread processing this function.\n-  */\n-template<typename _RAIter, typename _Compare>\n-  void\n-  __qsb_local_sort_with_helping(_QSBThreadLocal<_RAIter>** __tls,\n-                              _Compare& __comp, int __iam, bool __wait)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef std::pair<_RAIter, _RAIter> _Piece;\n-\n-    _QSBThreadLocal<_RAIter>& __tl = *__tls[__iam];\n-\n-    _DifferenceType __base_case_n =\n-        _Settings::get().sort_qsb_base_case_maximal_n;\n-    if (__base_case_n < 2)\n-      __base_case_n = 2;\n-    _ThreadIndex __num_threads = __tl._M_num_threads;\n-\n-    // Every thread has its own random number generator.\n-    _RandomNumber __rng(__iam + 1);\n-\n-    _Piece __current = __tl._M_initial;\n-\n-    _DifferenceType __elements_done = 0;\n+\n+  /**\n+    *  @brief Quicksort step doing load-balanced local sort.\n+    *  @param __tls Array of thread-local storages.\n+    *  @param __comp Comparator.\n+    *  @param __iam Number of the thread processing this function.\n+    */\n+  template<typename _RAIter, typename _Compare>\n+    void\n+    __qsb_local_sort_with_helping(_QSBThreadLocal<_RAIter>** __tls,\n+\t\t\t\t  _Compare& __comp, int __iam, bool __wait)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef std::pair<_RAIter, _RAIter> _Piece;\n+\n+      _QSBThreadLocal<_RAIter>& __tl = *__tls[__iam];\n+\n+      _DifferenceType\n+\t__base_case_n = _Settings::get().sort_qsb_base_case_maximal_n;\n+      if (__base_case_n < 2)\n+\t__base_case_n = 2;\n+      _ThreadIndex __num_threads = __tl._M_num_threads;\n+\n+      // Every thread has its own random number generator.\n+      _RandomNumber __rng(__iam + 1);\n+\n+      _Piece __current = __tl._M_initial;\n+\n+      _DifferenceType __elements_done = 0;\n #if _GLIBCXX_ASSERTIONS\n-    _DifferenceType __total_elements_done = 0;\n+      _DifferenceType __total_elements_done = 0;\n #endif\n \n-    for (;;)\n-      {\n-        // Invariant: __current must be a valid (maybe empty) range.\n-        _RAIter __begin = __current.first, __end = __current.second;\n-        _DifferenceType __n = __end - __begin;\n-\n-        if (__n > __base_case_n)\n-          {\n-            // Divide.\n-            _RAIter __pivot_pos = __begin +  __rng(__n);\n-\n-            // Swap __pivot_pos value to end.\n-            if (__pivot_pos != (__end - 1))\n-              std::swap(*__pivot_pos, *(__end - 1));\n-            __pivot_pos = __end - 1;\n-\n-            __gnu_parallel::binder2nd\n-                <_Compare, _ValueType, _ValueType, bool>\n-                __pred(__comp, *__pivot_pos);\n-\n-            // Divide, leave pivot unchanged in last place.\n-            _RAIter __split_pos1, __split_pos2;\n-            __split_pos1 =\n-                    __gnu_sequential::partition(__begin, __end - 1, __pred);\n-\n-            // Left side: < __pivot_pos; __right side: >= __pivot_pos.\n+      for (;;)\n+\t{\n+          // Invariant: __current must be a valid (maybe empty) range.\n+          _RAIter __begin = __current.first, __end = __current.second;\n+          _DifferenceType __n = __end - __begin;\n+\n+          if (__n > __base_case_n)\n+            {\n+              // Divide.\n+              _RAIter __pivot_pos = __begin +  __rng(__n);\n+\n+              // Swap __pivot_pos value to end.\n+              if (__pivot_pos != (__end - 1))\n+        \tstd::swap(*__pivot_pos, *(__end - 1));\n+              __pivot_pos = __end - 1;\n+\n+              __gnu_parallel::binder2nd\n+\t\t<_Compare, _ValueType, _ValueType, bool>\n+\t\t__pred(__comp, *__pivot_pos);\n+\n+              // Divide, leave pivot unchanged in last place.\n+              _RAIter __split_pos1, __split_pos2;\n+              __split_pos1 = __gnu_sequential::partition(__begin, __end - 1,\n+\t\t\t\t\t\t\t __pred);\n+\n+              // Left side: < __pivot_pos; __right side: >= __pivot_pos.\n #if _GLIBCXX_ASSERTIONS\n-            _GLIBCXX_PARALLEL_ASSERT(__begin <= __split_pos1\n-                                     && __split_pos1 < __end);\n+              _GLIBCXX_PARALLEL_ASSERT(__begin <= __split_pos1\n+                                       && __split_pos1 < __end);\n #endif\n-            // Swap pivot back to middle.\n-            if (__split_pos1 != __pivot_pos)\n-              std::swap(*__split_pos1, *__pivot_pos);\n-            __pivot_pos = __split_pos1;\n-\n-            // In case all elements are equal, __split_pos1 == 0.\n-            if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n-            || (__end - __split_pos1) < (__n >> 7))\n-              {\n-                // Very unequal split, one part smaller than one 128th\n-                // elements not strictly larger than the pivot.\n-                __gnu_parallel::__unary_negate<__gnu_parallel::__binder1st\n-                  <_Compare, _ValueType, _ValueType, bool>, _ValueType>\n-                  __pred(__gnu_parallel::__binder1st\n-                       <_Compare, _ValueType, _ValueType, bool>(\n-                          __comp, *__pivot_pos));\n-\n-                // Find other end of pivot-equal range.\n-                __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n-                                                         __end, __pred);\n-              }\n-            else\n-              // Only skip the pivot.\n-              __split_pos2 = __split_pos1 + 1;\n-\n-            // Elements equal to pivot are done.\n-            __elements_done += (__split_pos2 - __split_pos1);\n+              // Swap pivot back to middle.\n+              if (__split_pos1 != __pivot_pos)\n+        \tstd::swap(*__split_pos1, *__pivot_pos);\n+              __pivot_pos = __split_pos1;\n+\n+              // In case all elements are equal, __split_pos1 == 0.\n+              if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n+\t\t  || (__end - __split_pos1) < (__n >> 7))\n+        \t{\n+                  // Very unequal split, one part smaller than one 128th\n+                  // elements not strictly larger than the pivot.\n+                  __gnu_parallel::__unary_negate<__gnu_parallel::__binder1st\n+                    <_Compare, _ValueType, _ValueType, bool>, _ValueType>\n+                    __pred(__gnu_parallel::__binder1st\n+                \t <_Compare, _ValueType, _ValueType, bool>\n+\t\t\t   (__comp, *__pivot_pos));\n+\n+                  // Find other end of pivot-equal range.\n+                  __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n+\t\t\t\t\t\t\t     __end, __pred);\n+        \t}\n+              else\n+        \t// Only skip the pivot.\n+        \t__split_pos2 = __split_pos1 + 1;\n+\n+              // Elements equal to pivot are done.\n+              __elements_done += (__split_pos2 - __split_pos1);\n #if _GLIBCXX_ASSERTIONS\n-            __total_elements_done += (__split_pos2 - __split_pos1);\n+              __total_elements_done += (__split_pos2 - __split_pos1);\n #endif\n-            // Always push larger part onto stack.\n-            if (((__split_pos1 + 1) - __begin) < (__end - (__split_pos2)))\n-              {\n-                // Right side larger.\n-                if ((__split_pos2) != __end)\n-                  __tl._M_leftover_parts.push_front(\n-                    std::make_pair(__split_pos2, __end));\n-\n-                //__current.first = __begin;    //already set anyway\n-                __current.second = __split_pos1;\n-                continue;\n-              }\n-            else\n-              {\n-                // Left side larger.\n-                if (__begin != __split_pos1)\n-                  __tl._M_leftover_parts.push_front(std::make_pair(__begin,\n-                                                              __split_pos1));\n-\n-                __current.first = __split_pos2;\n-                //__current.second = __end;     //already set anyway\n-                continue;\n-              }\n-          }\n-        else\n-          {\n-            __gnu_sequential::sort(__begin, __end, __comp);\n-            __elements_done += __n;\n+              // Always push larger part onto stack.\n+              if (((__split_pos1 + 1) - __begin) < (__end - (__split_pos2)))\n+        \t{\n+                  // Right side larger.\n+                  if ((__split_pos2) != __end)\n+                    __tl._M_leftover_parts.push_front\n+\t\t      (std::make_pair(__split_pos2, __end));\n+\n+                  //__current.first = __begin;    //already set anyway\n+                  __current.second = __split_pos1;\n+                  continue;\n+        \t}\n+              else\n+        \t{\n+                  // Left side larger.\n+                  if (__begin != __split_pos1)\n+                    __tl._M_leftover_parts.push_front(std::make_pair\n+\t\t\t\t\t\t      (__begin, __split_pos1));\n+\n+                  __current.first = __split_pos2;\n+                  //__current.second = __end;     //already set anyway\n+                  continue;\n+        \t}\n+            }\n+          else\n+            {\n+              __gnu_sequential::sort(__begin, __end, __comp);\n+              __elements_done += __n;\n #if _GLIBCXX_ASSERTIONS\n-            __total_elements_done += __n;\n+              __total_elements_done += __n;\n #endif\n \n-            // Prefer own stack, small pieces.\n-            if (__tl._M_leftover_parts.pop_front(__current))\n-              continue;\n+              // Prefer own stack, small pieces.\n+              if (__tl._M_leftover_parts.pop_front(__current))\n+        \tcontinue;\n \n-#           pragma omp atomic\n-            *__tl._M_elements_leftover -= __elements_done;\n+#             pragma omp atomic\n+              *__tl._M_elements_leftover -= __elements_done;\n \n-            __elements_done = 0;\n+              __elements_done = 0;\n \n #if _GLIBCXX_ASSERTIONS\n-            double __search_start = omp_get_wtime();\n+              double __search_start = omp_get_wtime();\n #endif\n \n-            // Look for new work.\n-            bool __successfully_stolen = false;\n-            while (__wait && *__tl._M_elements_leftover > 0\n-                   && !__successfully_stolen\n+              // Look for new work.\n+              bool __successfully_stolen = false;\n+              while (__wait && *__tl._M_elements_leftover > 0\n+                     && !__successfully_stolen\n #if _GLIBCXX_ASSERTIONS\n-                    // Possible dead-lock.\n-                   && (omp_get_wtime() < (__search_start + 1.0))\n+                      // Possible dead-lock.\n+                     && (omp_get_wtime() < (__search_start + 1.0))\n #endif\n-              )\n-              {\n-                _ThreadIndex __victim;\n-                __victim = __rng(__num_threads);\n-\n-                // Large pieces.\n-                __successfully_stolen = (__victim != __iam)\n-                    && __tls[__victim]->_M_leftover_parts.pop_back(__current);\n-                if (!__successfully_stolen)\n-                  __yield();\n+\t\t     )\n+        \t{\n+                  _ThreadIndex __victim;\n+                  __victim = __rng(__num_threads);\n+\n+                  // Large pieces.\n+                  __successfully_stolen = (__victim != __iam)\n+\t\t    && __tls[__victim]->_M_leftover_parts.pop_back(__current);\n+                  if (!__successfully_stolen)\n+                    __yield();\n #if !defined(__ICC) && !defined(__ECC)\n-#               pragma omp flush\n+#                 pragma omp flush\n #endif\n-              }\n+        \t}\n \n #if _GLIBCXX_ASSERTIONS\n-            if (omp_get_wtime() >= (__search_start + 1.0))\n-              {\n-                sleep(1);\n-                _GLIBCXX_PARALLEL_ASSERT(omp_get_wtime()\n-                                         < (__search_start + 1.0));\n-              }\n+              if (omp_get_wtime() >= (__search_start + 1.0))\n+        \t{\n+                  sleep(1);\n+                  _GLIBCXX_PARALLEL_ASSERT(omp_get_wtime()\n+                                           < (__search_start + 1.0));\n+        \t}\n #endif\n-            if (!__successfully_stolen)\n-              {\n+              if (!__successfully_stolen)\n+        \t{\n #if _GLIBCXX_ASSERTIONS\n-                _GLIBCXX_PARALLEL_ASSERT(*__tl._M_elements_leftover == 0);\n+                  _GLIBCXX_PARALLEL_ASSERT(*__tl._M_elements_leftover == 0);\n #endif\n-                return;\n-              }\n-          }\n-      }\n-  }\n-\n-/** @brief Top-level quicksort routine.\n-  *  @param __begin Begin iterator of sequence.\n-  *  @param __end End iterator of sequence.\n-  *  @param __comp Comparator.\n-  *  @param __num_threads Number of threads that are allowed to work on\n-  *  this part.\n-  */\n-template<typename _RAIter, typename _Compare>\n-  void\n-  __parallel_sort_qsb(_RAIter __begin, _RAIter __end,\n-                    _Compare __comp,\n-                    _ThreadIndex __num_threads)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n-\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef std::pair<_RAIter, _RAIter> _Piece;\n-\n-    typedef _QSBThreadLocal<_RAIter> _TLSType;\n-\n-    _DifferenceType __n = __end - __begin;\n-\n-    if (__n <= 1)\n-      return;\n-\n-    // At least one element per processor.\n-    if (__num_threads > __n)\n-      __num_threads = static_cast<_ThreadIndex>(__n);\n-\n-    // Initialize thread local storage\n-    _TLSType** __tls = new _TLSType*[__num_threads];\n-    _DifferenceType __queue_size =\n-                           __num_threads * (_ThreadIndex)(log2(__n) + 1);\n-    for (_ThreadIndex __t = 0; __t < __num_threads; ++__t)\n-      __tls[__t] = new _QSBThreadLocal<_RAIter>(__queue_size);\n-\n-    // There can never be more than ceil(log2(__n)) ranges on the stack,\n-    // because\n-    // 1. Only one processor pushes onto the stack\n-    // 2. The largest range has at most length __n\n-    // 3. Each range is larger than half of the range remaining\n-    volatile _DifferenceType _M_elements_leftover = __n;\n-    for (int __i = 0; __i < __num_threads; ++__i)\n-      {\n-        __tls[__i]->_M_elements_leftover = &_M_elements_leftover;\n-        __tls[__i]->_M_num_threads = __num_threads;\n-        __tls[__i]->_M_global = std::make_pair(__begin, __end);\n-\n-        // Just in case nothing is left to assign.\n-        __tls[__i]->_M_initial = std::make_pair(__end, __end);\n-      }\n+                  return;\n+        \t}\n+            }\n+\t}\n+    }\n \n-    // Main recursion call.\n-    __qsb_conquer(\n-      __tls, __begin, __begin + __n, __comp, 0, __num_threads, true);\n+  /** @brief Top-level quicksort routine.\n+    *  @param __begin Begin iterator of sequence.\n+    *  @param __end End iterator of sequence.\n+    *  @param __comp Comparator.\n+    *  @param __num_threads Number of threads that are allowed to work on\n+    *  this part.\n+    */\n+  template<typename _RAIter, typename _Compare>\n+    void\n+    __parallel_sort_qsb(_RAIter __begin, _RAIter __end,\n+\t\t\t_Compare __comp, _ThreadIndex __num_threads)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n+\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef std::pair<_RAIter, _RAIter> _Piece;\n+\n+      typedef _QSBThreadLocal<_RAIter> _TLSType;\n+\n+      _DifferenceType __n = __end - __begin;\n+\n+      if (__n <= 1)\n+\treturn;\n+\n+      // At least one element per processor.\n+      if (__num_threads > __n)\n+\t__num_threads = static_cast<_ThreadIndex>(__n);\n+\n+      // Initialize thread local storage\n+      _TLSType** __tls = new _TLSType*[__num_threads];\n+      _DifferenceType __queue_size = (__num_threads\n+\t\t\t\t      * (_ThreadIndex)(__rd_log2(__n) + 1));\n+      for (_ThreadIndex __t = 0; __t < __num_threads; ++__t)\n+\t__tls[__t] = new _QSBThreadLocal<_RAIter>(__queue_size);\n+\n+      // There can never be more than ceil(__rd_log2(__n)) ranges on the\n+      // stack, because\n+      // 1. Only one processor pushes onto the stack\n+      // 2. The largest range has at most length __n\n+      // 3. Each range is larger than half of the range remaining\n+      volatile _DifferenceType __elements_leftover = __n;\n+      for (int __i = 0; __i < __num_threads; ++__i)\n+\t{\n+          __tls[__i]->_M_elements_leftover = &__elements_leftover;\n+          __tls[__i]->_M_num_threads = __num_threads;\n+          __tls[__i]->_M_global = std::make_pair(__begin, __end);\n+\n+          // Just in case nothing is left to assign.\n+          __tls[__i]->_M_initial = std::make_pair(__end, __end);\n+\t}\n+\n+      // Main recursion call.\n+      __qsb_conquer(__tls, __begin, __begin + __n, __comp, 0,\n+\t\t    __num_threads, true);\n \n #if _GLIBCXX_ASSERTIONS\n-    // All stack must be empty.\n-    _Piece __dummy;\n-    for (int __i = 1; __i < __num_threads; ++__i)\n-      _GLIBCXX_PARALLEL_ASSERT(\n-        !__tls[__i]->_M_leftover_parts.pop_back(__dummy));\n+      // All stack must be empty.\n+      _Piece __dummy;\n+      for (int __i = 1; __i < __num_threads; ++__i)\n+\t_GLIBCXX_PARALLEL_ASSERT(\n+          !__tls[__i]->_M_leftover_parts.pop_back(__dummy));\n #endif\n \n-    for (int __i = 0; __i < __num_threads; ++__i)\n-      delete __tls[__i];\n-    delete[] __tls;\n-  }\n+      for (int __i = 0; __i < __num_threads; ++__i)\n+\tdelete __tls[__i];\n+      delete[] __tls;\n+    }\n } // namespace __gnu_parallel\n \n #endif /* _GLIBCXX_PARALLEL_BALANCED_QUICKSORT_H */"}, {"sha": "8abfc991e678e02448af4e1eaf56ead561762f9b", "filename": "libstdc++-v3/include/parallel/checkers.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -68,5 +68,6 @@ namespace __gnu_parallel\n \n       return true;\n     }\n+}\n \n #endif /* _GLIBCXX_PARALLEL_CHECKERS_H */"}, {"sha": "307be0b52f0ef002c7d243ef1624f6467f6bd27c", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -33,57 +33,56 @@\n \n namespace __gnu_parallel\n {\n-/** @brief function to split a sequence into parts of almost equal size.\n- *\n- *  The resulting sequence __s of length __num_threads+1 contains the splitting\n- *  positions when splitting the range [0,__n) into parts of almost\n- *  equal size (plus minus 1).  The first entry is 0, the last one\n-*  n. There may result empty parts.\n- *  @param __n Number of elements\n- *  @param __num_threads Number of parts\n- *  @param __s Splitters\n- *  @returns End of __splitter sequence, i.e. @__c __s+__num_threads+1 */\n-template<typename _DifferenceType, typename _OutputIterator>\n-  _OutputIterator\n-  equally_split(_DifferenceType __n, _ThreadIndex __num_threads,\n-                _OutputIterator __s)\n-  {\n-    _DifferenceType __chunk_length = __n / __num_threads;\n-    _DifferenceType __num_longer_chunks = __n % __num_threads;\n-    _DifferenceType __pos = 0;\n-    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n-      {\n-        *__s++ = __pos;\n-        __pos += (__i < __num_longer_chunks) ?\n-                                      (__chunk_length + 1) : __chunk_length;\n-      }\n-    *__s++ = __n;\n-    return __s;\n-  }\n+  /** @brief function to split a sequence into parts of almost equal size.\n+   *\n+   *  The resulting sequence __s of length __num_threads+1 contains the\n+   *  splitting positions when splitting the range [0,__n) into parts of\n+   *  almost equal size (plus minus 1).  The first entry is 0, the last\n+   *  one n. There may result empty parts.\n+   *  @param __n Number of elements\n+   *  @param __num_threads Number of parts\n+   *  @param __s Splitters\n+   *  @returns End of __splitter sequence, i.e. @__c __s+__num_threads+1 */\n+  template<typename _DifferenceType, typename _OutputIterator>\n+    _OutputIterator\n+    equally_split(_DifferenceType __n, _ThreadIndex __num_threads,\n+\t\t  _OutputIterator __s)\n+    {\n+      _DifferenceType __chunk_length = __n / __num_threads;\n+      _DifferenceType __num_longer_chunks = __n % __num_threads;\n+      _DifferenceType __pos = 0;\n+      for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+\t{\n+\t  *__s++ = __pos;\n+\t  __pos += ((__i < __num_longer_chunks)\n+\t\t    ? (__chunk_length + 1) : __chunk_length);\n+\t}\n+      *__s++ = __n;\n+      return __s;\n+    }\n \n-\n-/** @brief function to split a sequence into parts of almost equal size.\n- *\n- *  Returns the position of the splitting point between\n- *  thread number __thread_no (included) and\n- *  thread number __thread_no+1 (excluded).\n- *  @param __n Number of elements\n- *  @param __num_threads Number of parts\n- *  @returns splitting point */\n-template<typename _DifferenceType>\n-  _DifferenceType\n-  equally_split_point(_DifferenceType __n,\n-                      _ThreadIndex __num_threads,\n-                      _ThreadIndex __thread_no)\n-  {\n-    _DifferenceType __chunk_length = __n / __num_threads;\n-    _DifferenceType __num_longer_chunks = __n % __num_threads;\n-    if (__thread_no < __num_longer_chunks)\n-      return __thread_no * (__chunk_length + 1);\n-    else\n-      return __num_longer_chunks * (__chunk_length + 1)\n+  /** @brief function to split a sequence into parts of almost equal size.\n+   *\n+   *  Returns the position of the splitting point between\n+   *  thread number __thread_no (included) and\n+   *  thread number __thread_no+1 (excluded).\n+   *  @param __n Number of elements\n+   *  @param __num_threads Number of parts\n+   *  @returns splitting point */\n+  template<typename _DifferenceType>\n+    _DifferenceType\n+    equally_split_point(_DifferenceType __n,\n+\t\t\t_ThreadIndex __num_threads,\n+\t\t\t_ThreadIndex __thread_no)\n+    {\n+      _DifferenceType __chunk_length = __n / __num_threads;\n+      _DifferenceType __num_longer_chunks = __n % __num_threads;\n+      if (__thread_no < __num_longer_chunks)\n+\treturn __thread_no * (__chunk_length + 1);\n+      else\n+\treturn __num_longer_chunks * (__chunk_length + 1)\n           + (__thread_no - __num_longer_chunks) * __chunk_length;\n-  }\n+    }\n }\n \n #endif /* _GLIBCXX_PARALLEL_EQUALLY_SPLIT_H */"}, {"sha": "b4e581488ae36a471ee1af44aee3413436c1dcb9", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 318, "deletions": 315, "changes": 633, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -42,360 +42,363 @@\n \n namespace __gnu_parallel\n {\n-/**\n- *  @brief Parallel std::find, switch for different algorithms.\n- *  @param __begin1 Begin iterator of first sequence.\n- *  @param __end1 End iterator of first sequence.\n- *  @param __begin2 Begin iterator of second sequence. Must have same\n- *  length as first sequence.\n- *  @param __pred Find predicate.\n- *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n- *  @return Place of finding in both sequences.\n- */\n-template<typename _RAIter1,\n-         typename _RAIter2,\n-         typename _Pred,\n-         typename _Selector>\n-  inline std::pair<_RAIter1, _RAIter2>\n-  __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n-                _RAIter2 __begin2, _Pred __pred, _Selector __selector)\n-  {\n-    switch (_Settings::get().find_algorithm)\n-      {\n-      case GROWING_BLOCKS:\n-        return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n-                             growing_blocks_tag());\n-      case CONSTANT_SIZE_BLOCKS:\n-        return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n-                             constant_size_blocks_tag());\n-      case EQUAL_SPLIT:\n-        return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n-                             equal_split_tag());\n-      default:\n-        _GLIBCXX_PARALLEL_ASSERT(false);\n-        return std::make_pair(__begin1, __begin2);\n-      }\n-  }\n+  /**\n+   *  @brief Parallel std::find, switch for different algorithms.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence. Must have same\n+   *  length as first sequence.\n+   *  @param __pred Find predicate.\n+   *  @param __selector _Functionality (e. g. std::find_if(), std::equal(),...)\n+   *  @return Place of finding in both sequences.\n+   */\n+  template<typename _RAIter1,\n+\t   typename _RAIter2,\n+\t   typename _Pred,\n+           typename _Selector>\n+    inline std::pair<_RAIter1, _RAIter2>\n+    __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+\t\t    _RAIter2 __begin2, _Pred __pred, _Selector __selector)\n+    {\n+      switch (_Settings::get().find_algorithm)\n+\t{\n+\tcase GROWING_BLOCKS:\n+          return __find_template(__begin1, __end1, __begin2, __pred,\n+\t\t\t\t __selector, growing_blocks_tag());\n+\tcase CONSTANT_SIZE_BLOCKS:\n+          return __find_template(__begin1, __end1, __begin2, __pred,\n+\t\t\t\t __selector, constant_size_blocks_tag());\n+\tcase EQUAL_SPLIT:\n+          return __find_template(__begin1, __end1, __begin2, __pred,\n+\t\t\t\t __selector, equal_split_tag());\n+\tdefault:\n+          _GLIBCXX_PARALLEL_ASSERT(false);\n+          return std::make_pair(__begin1, __begin2);\n+\t}\n+    }\n \n #if _GLIBCXX_FIND_EQUAL_SPLIT\n \n-/**\n- *  @brief Parallel std::find, equal splitting variant.\n- *  @param __begin1 Begin iterator of first sequence.\n- *  @param __end1 End iterator of first sequence.\n- *  @param __begin2 Begin iterator of second sequence. Second __sequence\n- *  must have same length as first sequence.\n- *  @param __pred Find predicate.\n- *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n- *  @return Place of finding in both sequences.\n- */\n-template<typename _RAIter1,\n-         typename _RAIter2,\n-         typename _Pred,\n-         typename _Selector>\n-  std::pair<_RAIter1, _RAIter2>\n-  __find_template(_RAIter1 __begin1,\n-                _RAIter1 __end1,\n-                _RAIter2 __begin2,\n-                _Pred __pred,\n-                _Selector __selector,\n-                equal_split_tag)\n-  {\n-    _GLIBCXX_CALL(__end1 - __begin1)\n-\n-    typedef std::iterator_traits<_RAIter1> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-\n-    _DifferenceType __length = __end1 - __begin1;\n-    _DifferenceType __result = __length;\n-    _DifferenceType* __borders;\n-\n-    omp_lock_t __result_lock;\n-    omp_init_lock(&__result_lock);\n-\n-    _ThreadIndex __num_threads = __get_max_threads();\n-#   pragma omp parallel num_threads(__num_threads)\n+  /**\n+   *  @brief Parallel std::find, equal splitting variant.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence. Second __sequence\n+   *  must have same length as first sequence.\n+   *  @param __pred Find predicate.\n+   *  @param __selector _Functionality (e. g. std::find_if(), std::equal(),...)\n+   *  @return Place of finding in both sequences.\n+   */\n+  template<typename _RAIter1,\n+           typename _RAIter2,\n+           typename _Pred,\n+           typename _Selector>\n+    std::pair<_RAIter1, _RAIter2>\n+    __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+\t\t    _RAIter2 __begin2, _Pred __pred,\n+\t\t    _Selector __selector, equal_split_tag)\n+    {\n+      _GLIBCXX_CALL(__end1 - __begin1)\n+\n+      typedef std::iterator_traits<_RAIter1> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+\n+      _DifferenceType __length = __end1 - __begin1;\n+      _DifferenceType __result = __length;\n+      _DifferenceType* __borders;\n+\n+      omp_lock_t __result_lock;\n+      omp_init_lock(&__result_lock);\n+\n+      _ThreadIndex __num_threads = __get_max_threads();\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n-#       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-            __borders = new _DifferenceType[__num_threads + 1];\n-            equally_split(__length, __num_threads, __borders);\n-          } //single\n-\n-        _ThreadIndex __iam = omp_get_thread_num();\n-        _DifferenceType __start = __borders[__iam],\n-                        __stop = __borders[__iam + 1];\n-\n-        _RAIter1 __i1 = __begin1 + __start;\n-        _RAIter2 __i2 = __begin2 + __start;\n-        for (_DifferenceType __pos = __start; __pos < __stop; ++__pos)\n-          {\n-            #pragma omp flush(__result)\n-            // Result has been set to something lower.\n-            if (__result < __pos)\n-              break;\n-\n-            if (__selector(__i1, __i2, __pred))\n-              {\n-                omp_set_lock(&__result_lock);\n-                if (__pos < __result)\n-                  __result = __pos;\n-                omp_unset_lock(&__result_lock);\n-                break;\n-              }\n-            ++__i1;\n-            ++__i2;\n-          }\n+#     pragma omp single\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t  __borders = new _DifferenceType[__num_threads + 1];\n+\t  equally_split(__length, __num_threads, __borders);\n+\t} //single\n+\n+\t_ThreadIndex __iam = omp_get_thread_num();\n+\t_DifferenceType __start = __borders[__iam],\n+\t                 __stop = __borders[__iam + 1];\n+\n+\t_RAIter1 __i1 = __begin1 + __start;\n+\t_RAIter2 __i2 = __begin2 + __start;\n+\tfor (_DifferenceType __pos = __start; __pos < __stop; ++__pos)\n+\t  {\n+#           pragma omp flush(__result)\n+\t    // Result has been set to something lower.\n+\t    if (__result < __pos)\n+\t      break;\n+\n+\t    if (__selector(__i1, __i2, __pred))\n+\t      {\n+\t\tomp_set_lock(&__result_lock);\n+\t\tif (__pos < __result)\n+\t\t  __result = __pos;\n+\t\tomp_unset_lock(&__result_lock);\n+\t\tbreak;\n+\t      }\n+\t    ++__i1;\n+\t    ++__i2;\n+\t  }\n       } //parallel\n \n-    omp_destroy_lock(&__result_lock);\n-    delete[] __borders;\n+      omp_destroy_lock(&__result_lock);\n+      delete[] __borders;\n \n-    return\n-      std::pair<_RAIter1, _RAIter2>(__begin1 + __result, __begin2 + __result);\n-  }\n+      return std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n+\t\t\t\t\t   __begin2 + __result);\n+    }\n \n #endif\n \n #if _GLIBCXX_FIND_GROWING_BLOCKS\n \n-/**\n- *  @brief Parallel std::find, growing block size variant.\n- *  @param __begin1 Begin iterator of first sequence.\n- *  @param __end1 End iterator of first sequence.\n- *  @param __begin2 Begin iterator of second sequence. Second __sequence\n- *  must have same length as first sequence.\n- *  @param __pred Find predicate.\n- *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n- *  @return Place of finding in both sequences.\n- *  @see __gnu_parallel::_Settings::find_sequential_search_size\n- *  @see __gnu_parallel::_Settings::find_initial_block_size\n- *  @see __gnu_parallel::_Settings::find_maximum_block_size\n- *  @see __gnu_parallel::_Settings::find_increasing_factor\n- *\n- *  There are two main differences between the growing blocks and\n- *  the constant-size blocks variants.\n- *  1. For GB, the block size grows; for CSB, the block size is fixed.\n- *  2. For GB, the blocks are allocated dynamically;\n- *     for CSB, the blocks are allocated in a predetermined manner,\n- *     namely spacial round-robin.\n- */\n-template<typename _RAIter1,\n-         typename _RAIter2,\n-         typename _Pred,\n-         typename _Selector>\n-  std::pair<_RAIter1, _RAIter2>\n-  __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n-                _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n-                growing_blocks_tag)\n-  {\n-    _GLIBCXX_CALL(__end1 - __begin1)\n-\n-    typedef std::iterator_traits<_RAIter1> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-\n-    const _Settings& __s = _Settings::get();\n-\n-    _DifferenceType __length = __end1 - __begin1;\n-\n-    _DifferenceType __sequential_search_size =\n-      std::min<_DifferenceType>(__length, __s.find_sequential_search_size);\n-\n-    // Try it sequentially first.\n-    std::pair<_RAIter1, _RAIter2> __find_seq_result =\n-      __selector._M_sequential_algorithm(\n-          __begin1, __begin1 + __sequential_search_size, __begin2, __pred);\n-\n-    if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n-      return __find_seq_result;\n-\n-    // Index of beginning of next free block (after sequential find).\n-    _DifferenceType __next_block_start = __sequential_search_size;\n-    _DifferenceType __result = __length;\n-\n-    omp_lock_t __result_lock;\n-    omp_init_lock(&__result_lock);\n-\n-    _ThreadIndex __num_threads = __get_max_threads();\n-#   pragma omp parallel shared(__result) num_threads(__num_threads)\n+  /**\n+   *  @brief Parallel std::find, growing block size variant.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence. Second __sequence\n+   *  must have same length as first sequence.\n+   *  @param __pred Find predicate.\n+   *  @param __selector _Functionality (e. g. std::find_if(), std::equal(),...)\n+   *  @return Place of finding in both sequences.\n+   *  @see __gnu_parallel::_Settings::find_sequential_search_size\n+   *  @see __gnu_parallel::_Settings::find_initial_block_size\n+   *  @see __gnu_parallel::_Settings::find_maximum_block_size\n+   *  @see __gnu_parallel::_Settings::find_increasing_factor\n+   *\n+   *  There are two main differences between the growing blocks and\n+   *  the constant-size blocks variants.\n+   *  1. For GB, the block size grows; for CSB, the block size is fixed.\n+   *  2. For GB, the blocks are allocated dynamically;\n+   *     for CSB, the blocks are allocated in a predetermined manner,\n+   *     namely spacial round-robin.\n+   */\n+  template<typename _RAIter1,\n+           typename _RAIter2,\n+           typename _Pred,\n+           typename _Selector>\n+    std::pair<_RAIter1, _RAIter2>\n+    __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+\t\t    _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n+\t\t    growing_blocks_tag)\n+    {\n+      _GLIBCXX_CALL(__end1 - __begin1)\n+\n+      typedef std::iterator_traits<_RAIter1> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+\n+      const _Settings& __s = _Settings::get();\n+\n+      _DifferenceType __length = __end1 - __begin1;\n+\n+      _DifferenceType\n+\t__sequential_search_size = std::min<_DifferenceType>\n+\t(__length, __s.find_sequential_search_size);\n+\n+      // Try it sequentially first.\n+      std::pair<_RAIter1, _RAIter2>\n+\t__find_seq_result = __selector._M_sequential_algorithm\n+\t(__begin1, __begin1 + __sequential_search_size,\n+\t __begin2, __pred);\n+\n+      if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n+\treturn __find_seq_result;\n+\n+      // Index of beginning of next free block (after sequential find).\n+      _DifferenceType __next_block_start = __sequential_search_size;\n+      _DifferenceType __result = __length;\n+\n+      omp_lock_t __result_lock;\n+      omp_init_lock(&__result_lock);\n+\n+      _ThreadIndex __num_threads = __get_max_threads();\n+#     pragma omp parallel shared(__result) num_threads(__num_threads)\n       {\n #       pragma omp single\n-          __num_threads = omp_get_num_threads();\n+\t__num_threads = omp_get_num_threads();\n \n-        // Not within first __k elements -> start parallel.\n-        _ThreadIndex __iam = omp_get_thread_num();\n+\t// Not within first __k elements -> start parallel.\n+\t_ThreadIndex __iam = omp_get_thread_num();\n \n-        _DifferenceType __block_size = __s.find_initial_block_size;\n-        _DifferenceType __start =\n-          __fetch_and_add<_DifferenceType>(&__next_block_start, __block_size);\n+\t_DifferenceType __block_size = __s.find_initial_block_size;\n+\t_DifferenceType __start = __fetch_and_add<_DifferenceType>\n+\t  (&__next_block_start, __block_size);\n \n-        // Get new block, update pointer to next block.\n-        _DifferenceType __stop =\n-            std::min<_DifferenceType>(__length, __start + __block_size);\n+\t// Get new block, update pointer to next block.\n+\t_DifferenceType __stop =\n+\t  std::min<_DifferenceType>(__length, __start + __block_size);\n \n-        std::pair<_RAIter1, _RAIter2> __local_result;\n+\tstd::pair<_RAIter1, _RAIter2> __local_result;\n \n-        while (__start < __length)\n-          {\n+\twhile (__start < __length)\n+\t  {\n #           pragma omp flush(__result)\n-            // Get new value of result.\n-            if (__result < __start)\n-              {\n-                // No chance to find first element.\n-                break;\n-              }\n-\n-            __local_result = __selector._M_sequential_algorithm(\n-                               __begin1 + __start, __begin1 + __stop,\n-                               __begin2 + __start, __pred);\n-            if (__local_result.first != (__begin1 + __stop))\n-              {\n-                omp_set_lock(&__result_lock);\n-                if ((__local_result.first - __begin1) < __result)\n-                  {\n-                    __result = __local_result.first - __begin1;\n-\n-                    // Result cannot be in future blocks, stop algorithm.\n-                    __fetch_and_add<_DifferenceType>(\n-                      &__next_block_start, __length);\n-                  }\n-                  omp_unset_lock(&__result_lock);\n-              }\n-\n-            __block_size = std::min<_DifferenceType>(\n-              __block_size * __s.find_increasing_factor,\n-              __s.find_maximum_block_size);\n-\n-            // Get new block, update pointer to next block.\n-            __start =\n-              __fetch_and_add<_DifferenceType>(\n-                &__next_block_start, __block_size);\n-            __stop = ((__length < (__start + __block_size))\n-                     ? __length : (__start + __block_size));\n-          }\n+\t    // Get new value of result.\n+\t    if (__result < __start)\n+\t      {\n+\t\t// No chance to find first element.\n+\t\tbreak;\n+\t      }\n+\n+\t    __local_result = __selector._M_sequential_algorithm\n+\t      (__begin1 + __start, __begin1 + __stop,\n+\t       __begin2 + __start, __pred);\n+\n+\t    if (__local_result.first != (__begin1 + __stop))\n+\t      {\n+\t\tomp_set_lock(&__result_lock);\n+\t\tif ((__local_result.first - __begin1) < __result)\n+\t\t  {\n+\t\t    __result = __local_result.first - __begin1;\n+\n+\t\t    // Result cannot be in future blocks, stop algorithm.\n+\t\t    __fetch_and_add<_DifferenceType>(&__next_block_start,\n+\t\t\t\t\t\t     __length);\n+\t\t  }\n+\t\tomp_unset_lock(&__result_lock);\n+\t      }\n+\n+\t    __block_size = std::min<_DifferenceType>\n+\t      (__block_size * __s.find_increasing_factor,\n+\t       __s.find_maximum_block_size);\n+\n+\t    // Get new block, update pointer to next block.\n+\t    __start = __fetch_and_add<_DifferenceType>(&__next_block_start,\n+\t\t\t\t\t\t       __block_size);\n+\t    __stop = (__length < (__start + __block_size)\n+\t\t      ? __length : (__start + __block_size));\n+\t  }\n       } //parallel\n \n-    omp_destroy_lock(&__result_lock);\n+      omp_destroy_lock(&__result_lock);\n \n-    // Return iterator on found element.\n-    return\n-      std::pair<_RAIter1, _RAIter2>(__begin1 + __result, __begin2 + __result);\n-  }\n+      // Return iterator on found element.\n+      return\n+\tstd::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n+\t\t\t\t      __begin2 + __result);\n+    }\n \n #endif\n \n #if _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS\n \n-/**\n- *   @brief Parallel std::find, constant block size variant.\n- *  @param __begin1 Begin iterator of first sequence.\n- *  @param __end1 End iterator of first sequence.\n- *  @param __begin2 Begin iterator of second sequence. Second __sequence\n- *  must have same length as first sequence.\n- *  @param __pred Find predicate.\n- *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n- *  @return Place of finding in both sequences.\n- *  @see __gnu_parallel::_Settings::find_sequential_search_size\n- *  @see __gnu_parallel::_Settings::find_block_size\n- *  There are two main differences between the growing blocks and the\n- *  constant-size blocks variants.\n- *  1. For GB, the block size grows; for CSB, the block size is fixed.\n- *  2. For GB, the blocks are allocated dynamically; for CSB, the\n- *  blocks are allocated in a predetermined manner, namely spacial\n- *  round-robin.\n- */\n-template<typename _RAIter1,\n-         typename _RAIter2,\n-         typename _Pred,\n-         typename _Selector>\n-  std::pair<_RAIter1, _RAIter2>\n-  __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n-                _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n-                constant_size_blocks_tag)\n-  {\n-    _GLIBCXX_CALL(__end1 - __begin1)\n-    typedef std::iterator_traits<_RAIter1> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-\n-    const _Settings& __s = _Settings::get();\n-\n-    _DifferenceType __length = __end1 - __begin1;\n-\n-    _DifferenceType __sequential_search_size = std::min<_DifferenceType>(\n-        __length, __s.find_sequential_search_size);\n-\n-    // Try it sequentially first.\n-    std::pair<_RAIter1, _RAIter2> __find_seq_result =\n-      __selector._M_sequential_algorithm(\n-        __begin1, __begin1 + __sequential_search_size, __begin2, __pred);\n-\n-    if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n-      return __find_seq_result;\n-\n-    _DifferenceType __result = __length;\n-    omp_lock_t __result_lock;\n-    omp_init_lock(&__result_lock);\n-\n-    // Not within first __sequential_search_size elements -> start parallel.\n-\n-    _ThreadIndex __num_threads = __get_max_threads();\n-#   pragma omp parallel shared(__result) num_threads(__num_threads)\n+  /**\n+   *   @brief Parallel std::find, constant block size variant.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence. Second __sequence\n+   *  must have same length as first sequence.\n+   *  @param __pred Find predicate.\n+   *  @param __selector _Functionality (e. g. std::find_if(), std::equal(),...)\n+   *  @return Place of finding in both sequences.\n+   *  @see __gnu_parallel::_Settings::find_sequential_search_size\n+   *  @see __gnu_parallel::_Settings::find_block_size\n+   *  There are two main differences between the growing blocks and the\n+   *  constant-size blocks variants.\n+   *  1. For GB, the block size grows; for CSB, the block size is fixed.\n+   *  2. For GB, the blocks are allocated dynamically; for CSB, the\n+   *  blocks are allocated in a predetermined manner, namely spacial\n+   *  round-robin.\n+   */\n+  template<typename _RAIter1,\n+           typename _RAIter2,\n+           typename _Pred,\n+           typename _Selector>\n+    std::pair<_RAIter1, _RAIter2>\n+    __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+                  _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n+                  constant_size_blocks_tag)\n+    {\n+      _GLIBCXX_CALL(__end1 - __begin1)\n+      typedef std::iterator_traits<_RAIter1> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+\n+      const _Settings& __s = _Settings::get();\n+\n+      _DifferenceType __length = __end1 - __begin1;\n+\n+      _DifferenceType __sequential_search_size = std::min<_DifferenceType>\n+\t(__length, __s.find_sequential_search_size);\n+\n+      // Try it sequentially first.\n+      std::pair<_RAIter1, _RAIter2>\n+\t__find_seq_result = __selector._M_sequential_algorithm\n+\t(__begin1, __begin1 + __sequential_search_size, __begin2, __pred);\n+\n+      if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n+\treturn __find_seq_result;\n+\n+      _DifferenceType __result = __length;\n+      omp_lock_t __result_lock;\n+      omp_init_lock(&__result_lock);\n+\n+      // Not within first __sequential_search_size elements -> start parallel.\n+\n+      _ThreadIndex __num_threads = __get_max_threads();\n+#     pragma omp parallel shared(__result) num_threads(__num_threads)\n       {\n #       pragma omp single\n-          __num_threads = omp_get_num_threads();\n+\t__num_threads = omp_get_num_threads();\n \n-        _ThreadIndex __iam = omp_get_thread_num();\n-        _DifferenceType __block_size = __s.find_initial_block_size;\n+\t_ThreadIndex __iam = omp_get_thread_num();\n+\t_DifferenceType __block_size = __s.find_initial_block_size;\n \n-        // First element of thread's current iteration.\n-        _DifferenceType __iteration_start = __sequential_search_size;\n+\t// First element of thread's current iteration.\n+\t_DifferenceType __iteration_start = __sequential_search_size;\n \n-        // Where to work (initialization).\n-        _DifferenceType __start = __iteration_start + __iam * __block_size;\n-        _DifferenceType __stop =\n-            std::min<_DifferenceType>(__length, __start + __block_size);\n+\t// Where to work (initialization).\n+\t_DifferenceType __start = __iteration_start + __iam * __block_size;\n+\t_DifferenceType __stop = std::min<_DifferenceType>(__length,\n+\t\t\t\t\t\t\t   __start\n+\t\t\t\t\t\t\t   + __block_size);\n \n-        std::pair<_RAIter1, _RAIter2> __local_result;\n+\tstd::pair<_RAIter1, _RAIter2> __local_result;\n \n-        while (__start < __length)\n-          {\n-            // Get new value of result.\n+\twhile (__start < __length)\n+\t  {\n+\t    // Get new value of result.\n #           pragma omp flush(__result)\n-            // No chance to find first element.\n-            if (__result < __start)\n-              break;\n-            __local_result = __selector._M_sequential_algorithm(\n-                __begin1 + __start, __begin1 + __stop,\n-                __begin2 + __start, __pred);\n-            if (__local_result.first != (__begin1 + __stop))\n-              {\n-                omp_set_lock(&__result_lock);\n-                if ((__local_result.first - __begin1) < __result)\n-                  __result = __local_result.first - __begin1;\n-                omp_unset_lock(&__result_lock);\n-                // Will not find better value in its interval.\n-                break;\n-              }\n-\n-            __iteration_start += __num_threads * __block_size;\n-\n-            // Where to work.\n-            __start = __iteration_start + __iam * __block_size;\n-            __stop = std::min<_DifferenceType>(\n-                       __length, __start + __block_size);\n-          }\n+\t    // No chance to find first element.\n+\t    if (__result < __start)\n+\t      break;\n+\n+\t    __local_result = __selector._M_sequential_algorithm\n+\t      (__begin1 + __start, __begin1 + __stop,\n+\t       __begin2 + __start, __pred);\n+\n+\t    if (__local_result.first != (__begin1 + __stop))\n+\t      {\n+\t\tomp_set_lock(&__result_lock);\n+\t\tif ((__local_result.first - __begin1) < __result)\n+\t\t  __result = __local_result.first - __begin1;\n+\t\tomp_unset_lock(&__result_lock);\n+\t\t// Will not find better value in its interval.\n+\t\tbreak;\n+\t      }\n+\n+\t    __iteration_start += __num_threads * __block_size;\n+\n+\t    // Where to work.\n+\t    __start = __iteration_start + __iam * __block_size;\n+\t    __stop = std::min<_DifferenceType>(__length,\n+\t\t\t\t\t       __start + __block_size);\n+\t  }\n       } //parallel\n \n-    omp_destroy_lock(&__result_lock);\n+      omp_destroy_lock(&__result_lock);\n \n-    // Return iterator on found element.\n-    return\n-      std::pair<_RAIter1, _RAIter2>(__begin1 + __result, __begin2 + __result);\n-  }\n+      // Return iterator on found element.\n+      return std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n+\t\t\t\t\t   __begin2 + __result);\n+    }\n #endif\n } // end namespace\n "}, {"sha": "df77978a9dd56932e828dbfa69693c201e317c40", "filename": "libstdc++-v3/include/parallel/find_selectors.h", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -103,12 +103,12 @@ namespace __gnu_parallel\n              typename _Pred>\n       std::pair<_RAIter1, _RAIter2>\n       _M_sequential_algorithm(_RAIter1 __begin1,\n-                           _RAIter1 __end1,\n-                           _RAIter2 __begin2, _Pred __pred)\n+\t\t\t      _RAIter1 __end1,\n+\t\t\t      _RAIter2 __begin2, _Pred __pred)\n       {\n         // Passed end iterator is one short.\n         _RAIter1 __spot = adjacent_find(__begin1, __end1 + 1,\n-                                                   __pred, sequential_tag());\n+\t\t\t\t\t__pred, sequential_tag());\n         if (__spot == (__end1 + 1))\n           __spot = __end1;\n         return std::make_pair(__spot, __begin2);\n@@ -141,56 +141,57 @@ namespace __gnu_parallel\n              typename _Pred>\n       std::pair<_RAIter1, _RAIter2>\n       _M_sequential_algorithm(_RAIter1 __begin1,\n-                           _RAIter1 __end1,\n-                           _RAIter2 __begin2, _Pred __pred)\n-      { return mismatch(__begin1, __end1, __begin2, __pred, sequential_tag());\n-        }\n+\t\t\t      _RAIter1 __end1,\n+\t\t\t      _RAIter2 __begin2, _Pred __pred)\n+      { return mismatch(__begin1, __end1, __begin2,\n+\t\t\t__pred, sequential_tag()); }\n   };\n \n \n   /** @brief Test predicate on several elements. */\n   template<typename _FIterator>\n-  struct __find_first_of_selector : public __generic_find_selector\n-  {\n-    _FIterator _M_begin;\n-    _FIterator _M_end;\n-\n-    explicit __find_first_of_selector(_FIterator __begin, _FIterator __end)\n-    : _M_begin(__begin), _M_end(__end) { }\n-\n-    /** @brief Test on one position.\n-     *  @param __i1 _Iterator on first sequence.\n-     *  @param __i2 _Iterator on second sequence (unused).\n-     *  @param __pred Find predicate. */\n-    template<typename _RAIter1, typename _RAIter2,\n-             typename _Pred>\n-      bool \n-      operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n-      {\n-        for (_FIterator __pos_in_candidates = _M_begin;\n-             __pos_in_candidates != _M_end; ++__pos_in_candidates)\n-          if (__pred(*__i1, *__pos_in_candidates))\n-            return true;\n-        return false;\n-      }\n-\n-    /** @brief Corresponding sequential algorithm on a sequence.\n-     *  @param __begin1 Begin iterator of first sequence.\n-     *  @param __end1 End iterator of first sequence.\n-     *  @param __begin2 Begin iterator of second sequence.\n-     *  @param __pred Find predicate. */\n-    template<typename _RAIter1, typename _RAIter2,\n-             typename _Pred>\n-      std::pair<_RAIter1, _RAIter2>\n-      _M_sequential_algorithm(_RAIter1 __begin1,\n-                           _RAIter1 __end1,\n-                           _RAIter2 __begin2, _Pred __pred)\n-      {\n-        return std::make_pair(\n-                 find_first_of(__begin1, __end1, _M_begin, _M_end, __pred,\n-                               sequential_tag()), __begin2);\n-      }\n-  };\n+    struct __find_first_of_selector : public __generic_find_selector\n+    {\n+      _FIterator _M_begin;\n+      _FIterator _M_end;\n+\n+      explicit __find_first_of_selector(_FIterator __begin,\n+\t\t\t\t\t_FIterator __end)\n+      : _M_begin(__begin), _M_end(__end) { }\n+\n+      /** @brief Test on one position.\n+       *  @param __i1 _Iterator on first sequence.\n+       *  @param __i2 _Iterator on second sequence (unused).\n+       *  @param __pred Find predicate. */\n+      template<typename _RAIter1, typename _RAIter2,\n+\t       typename _Pred>\n+        bool\n+        operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n+        {\n+\t  for (_FIterator __pos_in_candidates = _M_begin;\n+\t       __pos_in_candidates != _M_end; ++__pos_in_candidates)\n+\t    if (__pred(*__i1, *__pos_in_candidates))\n+\t      return true;\n+\t  return false;\n+\t}\n+\n+      /** @brief Corresponding sequential algorithm on a sequence.\n+       *  @param __begin1 Begin iterator of first sequence.\n+       *  @param __end1 End iterator of first sequence.\n+       *  @param __begin2 Begin iterator of second sequence.\n+       *  @param __pred Find predicate. */\n+      template<typename _RAIter1, typename _RAIter2,\n+\t       typename _Pred>\n+        std::pair<_RAIter1, _RAIter2>\n+        _M_sequential_algorithm(_RAIter1 __begin1,\n+\t\t\t\t_RAIter1 __end1,\n+\t\t\t\t_RAIter2 __begin2, _Pred __pred)\n+        {\n+\t  return std::make_pair(find_first_of(__begin1, __end1,\n+\t\t\t\t\t      _M_begin, _M_end, __pred,\n+\t\t\t\t\t      sequential_tag()), __begin2);\n+\t}\n+     };\n }\n \n #endif /* _GLIBCXX_PARALLEL_FIND_SELECTORS_H */"}, {"sha": "f758b7ab78ae9d02180642fe22edb0d09eba99bb", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -69,31 +69,21 @@ namespace __gnu_parallel\n                                       _Parallelism __parallelism_tag)\n     {\n       if (__parallelism_tag == parallel_unbalanced)\n-        return __for_each_template_random_access_ed(__begin, __end, __user_op,\n-                                                  __functionality, __reduction,\n-                                                  __reduction_start,\n-                                                  __output, __bound);\n+        return __for_each_template_random_access_ed\n+\t  (__begin, __end, __user_op, __functionality, __reduction,\n+\t   __reduction_start, __output, __bound);\n       else if (__parallelism_tag == parallel_omp_loop)\n-        return __for_each_template_random_access_omp_loop(\n-                                                  __begin, __end, __user_op,\n-                                                  __functionality,\n-                                                  __reduction,\n-                                                  __reduction_start,\n-                                                  __output, __bound);\n+        return __for_each_template_random_access_omp_loop\n+\t  (__begin, __end, __user_op, __functionality, __reduction,\n+\t   __reduction_start, __output, __bound);\n       else if (__parallelism_tag == parallel_omp_loop_static)\n-        return __for_each_template_random_access_omp_loop(\n-                                                  __begin, __end, __user_op,\n-                                                  __functionality,\n-                                                  __reduction,\n-                                                  __reduction_start,\n-                                                  __output, __bound);\n+        return __for_each_template_random_access_omp_loop\n+\t  (__begin, __end, __user_op, __functionality, __reduction,\n+\t   __reduction_start, __output, __bound);\n       else      //e. g. parallel_balanced\n-        return __for_each_template_random_access_workstealing(__begin, __end,\n-                                                            __user_op,\n-                                                            __functionality,\n-                                                            __reduction,\n-                                                            __reduction_start,\n-                                                            __output, __bound);\n+        return __for_each_template_random_access_workstealing\n+\t  (__begin, __end, __user_op, __functionality, __reduction,\n+\t   __reduction_start, __output, __bound);\n   }\n }\n "}, {"sha": "573085aa87211787f024d0e452629cbb573d1efc", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -48,11 +48,11 @@ namespace __gnu_parallel\n   template<typename _IIter>\n     void\n     __shrink_and_double(std::vector<_IIter>& __os_starts,\n-                      size_t& __count_to_two, size_t& __range_length,\n-                      const bool __make_twice)\n+\t\t\tsize_t& __count_to_two, size_t& __range_length,\n+\t\t\tconst bool __make_twice)\n     {\n       ++__count_to_two;\n-      if (not __make_twice or __count_to_two < 2)\n+      if (!__make_twice || __count_to_two < 2)\n         __shrink(__os_starts, __count_to_two, __range_length);\n       else\n         {\n@@ -68,7 +68,7 @@ namespace __gnu_parallel\n   template<typename _IIter>\n     void\n     __shrink(std::vector<_IIter>& __os_starts, size_t& __count_to_two,\n-           size_t& __range_length)\n+\t     size_t& __range_length)\n     {\n       for (typename std::vector<_IIter>::size_type __i = 0;\n            __i <= (__os_starts.size() / 2); ++__i)\n@@ -112,8 +112,8 @@ namespace __gnu_parallel\n \n       std::vector<_IIter> __os_starts(2 * __oversampling * __num_parts + 1);\n \n-      __os_starts[0]= __begin;\n-      _IIter __prev = __begin, __it = __begin;\n+      __os_starts[0] = __begin;\n+      _IIter __prev  = __begin, __it = __begin;\n       size_t __dist_limit = 0, __dist = 0;\n       size_t __cur = 1, __next = 1;\n       size_t __range_length = 1;"}, {"sha": "425cf6d4b6f253a744d5d5cdebf9bf12071ae854", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 903, "deletions": 896, "changes": 1799, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -40,993 +40,1000 @@\n \n namespace __gnu_parallel\n {\n-/**\n- * @brief Guarded loser/tournament tree.\n- *\n- * The smallest element is at the top.\n- *\n- * Guarding is done explicitly through one flag _M_sup per element,\n- * inf is not needed due to a better initialization routine.  This\n- * is a well-performing variant.\n- *\n- * @param _Tp the element type\n- * @param _Compare the comparator to use, defaults to std::less<_Tp>\n- */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreeBase\n-  {\n-  protected:\n-    /** @brief Internal representation of a _LoserTree element. */\n-    struct _Loser\n+  /**\n+   * @brief Guarded loser/tournament tree.\n+   *\n+   * The smallest element is at the top.\n+   *\n+   * Guarding is done explicitly through one flag _M_sup per element,\n+   * inf is not needed due to a better initialization routine.  This\n+   * is a well-performing variant.\n+   *\n+   * @param _Tp the element type\n+   * @param _Compare the comparator to use, defaults to std::less<_Tp>\n+   */\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreeBase\n     {\n-      /** @brief flag, true iff this is a \"maximum\" __sentinel. */\n-      bool _M_sup;\n-      /** @brief __index of the __source __sequence. */\n-      int _M_source;\n-      /** @brief _M_key of the element in the _LoserTree. */\n-      _Tp _M_key;\n+    protected:\n+      /** @brief Internal representation of a _LoserTree element. */\n+      struct _Loser\n+      {\n+\t/** @brief flag, true iff this is a \"maximum\" __sentinel. */\n+\tbool _M_sup;\n+\t/** @brief __index of the __source __sequence. */\n+\tint _M_source;\n+\t/** @brief _M_key of the element in the _LoserTree. */\n+\t_Tp _M_key;\n+      };\n+\n+      unsigned int _M_ik, _M_k, _M_offset;\n+\n+      /** log_2{_M_k} */\n+      unsigned int _M_log_k;\n+\n+      /** @brief _LoserTree __elements. */\n+      _Loser* _M_losers;\n+\n+      /** @brief _Compare to use. */\n+      _Compare _M_comp;\n+\n+      /**\n+       * @brief State flag that determines whether the _LoserTree is empty.\n+       *\n+       * Only used for building the _LoserTree.\n+       */\n+      bool _M_first_insert;\n+\n+    public:\n+      /**\n+       * @brief The constructor.\n+       *\n+       * @param __k The number of sequences to merge.\n+       * @param __comp The comparator to use.\n+       */\n+      _LoserTreeBase(unsigned int __k, _Compare __comp)\n+      : _M_comp(__comp)\n+      {\n+\t_M_ik = __k;\n+\n+\t// Compute log_2{_M_k} for the _Loser Tree\n+\t_M_log_k = __rd_log2(_M_ik - 1) + 1;\n+\n+\t// Next greater power of 2.\n+\t_M_k = 1 << _M_log_k;\n+\t_M_offset = _M_k;\n+\n+\t// Avoid default-constructing _M_losers[]._M_key\n+\t_M_losers = static_cast<_Loser*>(::operator new(2 * _M_k\n+\t\t\t\t\t\t\t* sizeof(_Loser)));\n+\tfor (unsigned int __i = _M_ik - 1; __i < _M_k; ++__i)\n+\t  _M_losers[__i + _M_k]._M_sup = true;\n+\n+\t_M_first_insert = true;\n+      }\n+\n+      /**\n+       * @brief The destructor.\n+       */\n+      ~_LoserTreeBase()\n+      { ::operator delete(_M_losers); }\n+\n+      /**\n+       * @brief Initializes the sequence \"_M_source\" with the element \"__key\".\n+       *\n+       * @param __key the element to insert\n+       * @param __source __index of the __source __sequence\n+       * @param __sup flag that determines whether the value to insert is an\n+       *   explicit __supremum.\n+       */\n+      void\n+      __insert_start(const _Tp& __key, int __source, bool __sup)\n+      {\n+\tunsigned int __pos = _M_k + __source;\n+\n+\tif(_M_first_insert)\n+\t  {\n+\t    // Construct all keys, so we can easily deconstruct them.\n+\t    for (unsigned int __i = 0; __i < (2 * _M_k); ++__i)\n+\t      new(&(_M_losers[__i]._M_key)) _Tp(__key);\n+\t    _M_first_insert = false;\n+\t  }\n+\telse\n+\t  new(&(_M_losers[__pos]._M_key)) _Tp(__key);\n+\n+\t_M_losers[__pos]._M_sup = __sup;\n+\t_M_losers[__pos]._M_source = __source;\n+      }\n+\n+      /**\n+       * @return the index of the sequence with the smallest element.\n+       */\n+      int __get_min_source()\n+      { return _M_losers[0]._M_source; }\n     };\n \n-    unsigned int _M_ik, _M_k, _M_offset;\n-\n-    /** log_2{_M_k} */\n-    unsigned int _M_log_k;\n-\n-    /** @brief _LoserTree __elements. */\n-    _Loser* _M_losers;\n-\n-    /** @brief _Compare to use. */\n-    _Compare _M_comp;\n-\n     /**\n-     * @brief State flag that determines whether the _LoserTree is empty.\n+     * @brief Stable _LoserTree variant.\n      *\n-     * Only used for building the _LoserTree.\n-     */\n-    bool _M_first_insert;\n-\n-  public:\n-    /**\n-     * @brief The constructor.\n+     * Provides the stable implementations of insert_start, __init_winner,\n+     * __init and __delete_min_insert.\n      *\n-     * @param __k The number of sequences to merge.\n-     * @param __comp The comparator to use.\n+     * Unstable variant is done using partial specialisation below.\n      */\n-    _LoserTreeBase(unsigned int __k, _Compare __comp)\n-    : _M_comp(__comp)\n+  template<bool __stable/* default == true */, typename _Tp,\n+\t   typename _Compare>\n+    class _LoserTree\n+    : public _LoserTreeBase<_Tp, _Compare>\n     {\n-      _M_ik = __k;\n-\n-      // Compute log_2{_M_k} for the _Loser Tree\n-      _M_log_k = __rd_log2(_M_ik - 1) + 1;\n-\n-      // Next greater power of 2.\n-      _M_k = 1 << _M_log_k;\n-      _M_offset = _M_k;\n-\n-      // Avoid default-constructing _M_losers[]._M_key\n-      _M_losers\n-        = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n-      for (unsigned int __i = _M_ik - 1; __i < _M_k; ++__i)\n-\t_M_losers[__i + _M_k]._M_sup = true;\n-\n-      _M_first_insert = true;\n-    }\n+      typedef _LoserTreeBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n+      using _Base::_M_first_insert;\n+\n+    public:\n+      _LoserTree(unsigned int __k, _Compare __comp)\n+      : _Base::_LoserTreeBase(__k, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n+\t    if (_M_losers[__right]._M_sup\n+\t\t|| (!_M_losers[__left]._M_sup\n+\t\t    && !_M_comp(_M_losers[__right]._M_key,\n+\t\t\t\t_M_losers[__left]._M_key)))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void __init()\n+      { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+      /**\n+       * @brief Delete the smallest element and insert a new element from\n+       *   the previously smallest element's sequence.\n+       *\n+       * This implementation is stable.\n+       */\n+      // Do not pass a const reference since __key will be used as\n+      // local variable.\n+      void\n+      __delete_min_insert(_Tp __key, bool __sup)\n+      {\n+#if _GLIBCXX_ASSERTIONS\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+#endif\n \n-    /**\n-     * @brief The destructor.\n-     */\n-    ~_LoserTreeBase()\n-    { ::operator delete(_M_losers); }\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted, ties are broken by _M_source.\n+\t    if ((__sup && (!_M_losers[__pos]._M_sup\n+\t\t\t   || _M_losers[__pos]._M_source < __source))\n+\t\t|| (!__sup && !_M_losers[__pos]._M_sup\n+\t\t    && ((_M_comp(_M_losers[__pos]._M_key, __key))\n+\t\t\t|| (!_M_comp(__key, _M_losers[__pos]._M_key)\n+\t\t\t    && _M_losers[__pos]._M_source < __source))))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_sup, __sup);\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_key, __key);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_sup = __sup;\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_key = __key;\n+      }\n+    };\n \n     /**\n-     * @brief Initializes the sequence \"_M_source\" with the element \"_M_key\".\n+     * @brief Unstable _LoserTree variant.\n      *\n-     * @param _M_key the element to insert\n-     * @param _M_source __index of the __source __sequence\n-     * @param _M_sup flag that determines whether the value to insert is an\n-     *   explicit __supremum.\n+     * Stability (non-stable here) is selected with partial specialization.\n      */\n-    void\n-    __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTree</* __stable == */false, _Tp, _Compare>\n+    : public _LoserTreeBase<_Tp, _Compare>\n     {\n-      unsigned int __pos = _M_k + _M_source;\n-\n-      if(_M_first_insert)\n-\t{\n-\t  // Construct all keys, so we can easily deconstruct them.\n-\t  for (unsigned int __i = 0; __i < (2 * _M_k); ++__i)\n-\t    new(&(_M_losers[__i]._M_key)) _Tp(_M_key);\n-\t  _M_first_insert = false;\n-\t}\n-      else\n-\tnew(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n-\n-      _M_losers[__pos]._M_sup = _M_sup;\n-      _M_losers[__pos]._M_source = _M_source;\n-    }\n+      typedef _LoserTreeBase<_Tp, _Compare> _Base;\n+      using _Base::_M_log_k;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n+      using _Base::_M_first_insert;\n+\n+    public:\n+      _LoserTree(unsigned int __k, _Compare __comp)\n+      : _Base::_LoserTreeBase(__k, __comp)\n+      { }\n+\n+      /**\n+       * Computes the winner of the competition at position \"__root\".\n+       *\n+       * Called recursively (starting at 0) to build the initial tree.\n+       *\n+       * @param __root __index of the \"game\" to start.\n+       */\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n+\t    if (_M_losers[__right]._M_sup\n+\t\t|| (!_M_losers[__left]._M_sup\n+\t\t    && !_M_comp(_M_losers[__right]._M_key,\n+\t\t\t\t_M_losers[__left]._M_key)))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void\n+      __init()\n+      { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+      /**\n+       * Delete the _M_key smallest element and insert the element __key\n+       * instead.\n+       *\n+       * @param __key the _M_key to insert\n+       * @param __sup true iff __key is an explicitly marked supremum\n+       */\n+      // Do not pass a const reference since __key will be used as local\n+      // variable.\n+      void\n+      __delete_min_insert(_Tp __key, bool __sup)\n+      {\n+#if _GLIBCXX_ASSERTIONS\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+#endif\n \n-    /**\n-     * @return the index of the sequence with the smallest element.\n-     */\n-    int __get_min_source()\n-    { return _M_losers[0]._M_source; }\n-  };\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted.\n+\t    if (__sup || (!_M_losers[__pos]._M_sup\n+\t\t\t  && _M_comp(_M_losers[__pos]._M_key, __key)))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_sup, __sup);\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_key, __key);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_sup = __sup;\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_key = __key;\n+      }\n+    };\n \n   /**\n-   * @brief Stable _LoserTree variant.\n-   *\n-   * Provides the stable implementations of insert_start, __init_winner,\n-   * __init and __delete_min_insert.\n-   *\n-   * Unstable variant is done using partial specialisation below.\n+   * @brief Base class of _Loser Tree implementation using pointers.\n    */\n-template<bool __stable/* default == true */, typename _Tp,\n-\t typename _Compare>\n-  class _LoserTree\n-  : public _LoserTreeBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreeBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n-    using _Base::_M_first_insert;\n-\n-  public:\n-    _LoserTree(unsigned int __k, _Compare __comp)\n-    : _Base::_LoserTreeBase(__k, __comp)\n-    { }\n-\n-    unsigned int\n-    __init_winner(unsigned int __root)\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreePointerBase\n     {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n-\t  if (_M_losers[__right]._M_sup\n-\t      || (!_M_losers[__left]._M_sup\n-\t\t  && !_M_comp(_M_losers[__right]._M_key,\n-\t\t\t      _M_losers[__left]._M_key)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void __init()\n-    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+    protected:\n+      /** @brief Internal representation of _LoserTree __elements. */\n+      struct _Loser\n+      {\n+\tbool _M_sup;\n+\tint _M_source;\n+\tconst _Tp* _M_keyp;\n+      };\n+\n+      unsigned int _M_ik, _M_k, _M_offset;\n+      _Loser* _M_losers;\n+      _Compare _M_comp;\n+\n+    public:\n+      _LoserTreePointerBase(unsigned int __k,\n+\t\t\t    _Compare __comp = std::less<_Tp>())\n+      : _M_comp(__comp)\n+      {\n+\t_M_ik = __k;\n+\n+\t// Next greater power of 2.\n+\t_M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n+\t_M_offset = _M_k;\n+\t_M_losers = new _Loser[_M_k * 2];\n+\tfor (unsigned int __i = _M_ik - 1; __i < _M_k; __i++)\n+\t  _M_losers[__i + _M_k]._M_sup = true;\n+      }\n+\n+      ~_LoserTreePointerBase()\n+      { ::operator delete[](_M_losers); }\n+\n+      int __get_min_source()\n+      { return _M_losers[0]._M_source; }\n+\n+      void __insert_start(const _Tp& __key, int __source, bool __sup)\n+      {\n+\tunsigned int __pos = _M_k + __source;\n+\n+\t_M_losers[__pos]._M_sup = __sup;\n+\t_M_losers[__pos]._M_source = __source;\n+\t_M_losers[__pos]._M_keyp = &__key;\n+      }\n+    };\n \n-    /**\n-     * @brief Delete the smallest element and insert a new element from\n-     *   the previously smallest element's sequence.\n-     *\n-     * This implementation is stable.\n-     */\n-    // Do not pass a const reference since _M_key will be used as\n-    // local variable.\n-    void\n-    __delete_min_insert(_Tp _M_key, bool _M_sup)\n+  /**\n+   * @brief Stable _LoserTree implementation.\n+   *\n+   * The unstable variant is implemented using partial instantiation below.\n+   */\n+  template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n+    class _LoserTreePointer\n+    : public _LoserTreePointerBase<_Tp, _Compare>\n     {\n+      typedef _LoserTreePointerBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n+\n+    public:\n+      _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+      : _Base::_LoserTreePointerBase(__k, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n+\t    if (_M_losers[__right]._M_sup\n+\t\t|| (!_M_losers[__left]._M_sup\n+\t\t    && !_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t\t\t*_M_losers[__left]._M_keyp)))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void __init()\n+      { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+      void __delete_min_insert(const _Tp& __key, bool __sup)\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0;\n-\t   __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by _M_source.\n-\t  if ((_M_sup && (!_M_losers[__pos]._M_sup\n-\t\t\t  || _M_losers[__pos]._M_source < _M_source))\n-\t      || (!_M_sup && !_M_losers[__pos]._M_sup\n-\t\t  && ((_M_comp(_M_losers[__pos]._M_key, _M_key))\n-\t\t      || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n-\t\t\t  && _M_losers[__pos]._M_source < _M_source))))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_sup = _M_sup;\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_key = _M_key;\n-    }\n-  };\n+\tconst _Tp* __keyp = &__key;\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted, ties are broken by __source.\n+\t    if ((__sup && (!_M_losers[__pos]._M_sup\n+\t\t\t   || _M_losers[__pos]._M_source < __source))\n+\t\t|| (!__sup && !_M_losers[__pos]._M_sup &&\n+\t\t    ((_M_comp(*_M_losers[__pos]._M_keyp, *__keyp))\n+\t\t     || (!_M_comp(*__keyp, *_M_losers[__pos]._M_keyp)\n+\t\t\t && _M_losers[__pos]._M_source < __source))))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_sup, __sup);\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_keyp, __keyp);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_sup = __sup;\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_keyp = __keyp;\n+      }\n+    };\n \n   /**\n-   * @brief Unstable _LoserTree variant.\n+   * @brief Unstable _LoserTree implementation.\n    *\n-   * Stability (non-stable here) is selected with partial specialization.\n+   * The stable variant is above.\n    */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTree</* __stable == */false, _Tp, _Compare>\n-  : public _LoserTreeBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreeBase<_Tp, _Compare> _Base;\n-    using _Base::_M_log_k;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n-    using _Base::_M_first_insert;\n-\n-  public:\n-    _LoserTree(unsigned int __k, _Compare __comp)\n-    : _Base::_LoserTreeBase(__k, __comp)\n-    { }\n-\n-    /**\n-     * Computes the winner of the competition at position \"__root\".\n-     *\n-     * Called recursively (starting at 0) to build the initial tree.\n-     *\n-     * @param __root __index of the \"game\" to start.\n-     */\n-    unsigned int\n-    __init_winner(unsigned int __root)\n-    {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n-\t  if (_M_losers[__right]._M_sup\n-\t      || (!_M_losers[__left]._M_sup\n-\t\t  && !_M_comp(_M_losers[__right]._M_key,\n-\t\t\t      _M_losers[__left]._M_key)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void\n-    __init()\n-    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n-\n-    /**\n-     * Delete the _M_key smallest element and insert the element _M_key\n-     * instead.\n-     *\n-     * @param _M_key the _M_key to insert\n-     * @param _M_sup true iff _M_key is an explicitly marked supremum\n-     */\n-    // Do not pass a const reference since _M_key will be used as local\n-    // variable.\n-    void\n-    __delete_min_insert(_Tp _M_key, bool _M_sup)\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreePointer</* __stable == */false, _Tp, _Compare>\n+    : public _LoserTreePointerBase<_Tp, _Compare>\n     {\n+      typedef _LoserTreePointerBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n+\n+    public:\n+      _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+      : _Base::_LoserTreePointerBase(__k, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n+\t    if (_M_losers[__right]._M_sup\n+        \t|| (!_M_losers[__left]._M_sup\n+\t\t    && !_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t\t\t*_M_losers[__left]._M_keyp)))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void __init()\n+      { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+      void __delete_min_insert(const _Tp& __key, bool __sup)\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0;\n-\t   __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (_M_sup || (!_M_losers[__pos]._M_sup\n-\t\t\t && _M_comp(_M_losers[__pos]._M_key, _M_key)))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_sup = _M_sup;\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_key = _M_key;\n-    }\n-  };\n-\n-/**\n- * @brief Base class of _Loser Tree implementation using pointers.\n- */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreePointerBase\n-  {\n-  protected:\n-    /** @brief Internal representation of _LoserTree __elements. */\n-    struct _Loser\n-    {\n-      bool _M_sup;\n-      int _M_source;\n-      const _Tp* _M_keyp;\n+\tconst _Tp* __keyp = &__key;\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted.\n+\t    if (__sup || (!_M_losers[__pos]._M_sup\n+\t\t\t  && _M_comp(*_M_losers[__pos]._M_keyp, *__keyp)))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_sup, __sup);\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_keyp, __keyp);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_sup = __sup;\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_keyp = __keyp;\n+      }\n     };\n \n-    unsigned int _M_ik, _M_k, _M_offset;\n-    _Loser* _M_losers;\n-    _Compare _M_comp;\n-\n-  public:\n-    _LoserTreePointerBase(unsigned int __k,\n-\t\t\t  _Compare __comp = std::less<_Tp>())\n-    : _M_comp(__comp)\n+  /** @brief Base class for unguarded _LoserTree implementation.\n+   * \n+   * The whole element is copied into the tree structure.\n+   *\n+   * No guarding is done, therefore not a single input sequence must\n+   * run empty.  Unused __sequence heads are marked with a sentinel which\n+   * is &gt; all elements that are to be merged.\n+   *\n+   * This is a very fast variant.\n+   */\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreeUnguardedBase\n     {\n-      _M_ik = __k;\n-\n-      // Next greater power of 2.\n-      _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n-      _M_offset = _M_k;\n-      _M_losers = new _Loser[_M_k * 2];\n-      for (unsigned int __i = _M_ik - 1; __i < _M_k; __i++)\n-\t_M_losers[__i + _M_k]._M_sup = true;\n-    }\n+    protected:\n+      struct _Loser\n+      {\n+\tint _M_source;\n+\t_Tp _M_key;\n+      };\n+\n+      unsigned int _M_ik, _M_k, _M_offset;\n+      _Loser* _M_losers;\n+      _Compare _M_comp;\n+\n+    public:\n+      _LoserTreeUnguardedBase(unsigned int __k, const _Tp __sentinel,\n+\t\t\t      _Compare __comp = std::less<_Tp>())\n+      : _M_comp(__comp)\n+      {\n+\t_M_ik = __k;\n+\n+\t// Next greater power of 2.\n+\t_M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n+\t_M_offset = _M_k;\n+\t// Avoid default-constructing _M_losers[]._M_key\n+\t_M_losers = static_cast<_Loser*>(::operator new(2 * _M_k\n+\t\t\t\t\t\t\t* sizeof(_Loser)));\n+\n+\tfor (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n+\t  {\n+\t    _M_losers[__i]._M_key = __sentinel;\n+\t    _M_losers[__i]._M_source = -1;\n+\t  }\n+      }\n+\n+      ~_LoserTreeUnguardedBase()\n+      { ::operator delete(_M_losers); }\n+\n+      int\n+      __get_min_source()\n+      {\n+#if _GLIBCXX_ASSERTIONS\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+#endif\n+\treturn _M_losers[0]._M_source;\n+      }\n \n-    ~_LoserTreePointerBase()\n-    { ::operator delete[](_M_losers); }\n+      void\n+      __insert_start(const _Tp& __key, int __source, bool)\n+      {\n+\tunsigned int __pos = _M_k + __source;\n \n-    int __get_min_source()\n-    { return _M_losers[0]._M_source; }\n+\tnew(&(_M_losers[__pos]._M_key)) _Tp(__key);\n+\t_M_losers[__pos]._M_source = __source;\n+      }\n+    };\n \n-    void __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n+  /**\n+   * @brief Stable implementation of unguarded _LoserTree.\n+   *\n+   * Unstable variant is selected below with partial specialization.\n+   */\n+  template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n+    class _LoserTreeUnguarded\n+    : public _LoserTreeUnguardedBase<_Tp, _Compare>\n     {\n-      unsigned int __pos = _M_k + _M_source;\n-\n-      _M_losers[__pos]._M_sup = _M_sup;\n-      _M_losers[__pos]._M_source = _M_source;\n-      _M_losers[__pos]._M_keyp = &_M_key;\n-    }\n-  };\n-\n-/**\n- * @brief Stable _LoserTree implementation.\n- *\n- * The unstable variant is implemented using partial instantiation below.\n- */\n-template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-  class _LoserTreePointer\n-  : public _LoserTreePointerBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreePointerBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n+      typedef _LoserTreeUnguardedBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n \n   public:\n-    _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n-    : _Base::_LoserTreePointerBase(__k, __comp)\n-    { }\n+      _LoserTreeUnguarded(unsigned int __k, const _Tp __sentinel,\n+\t\t\t  _Compare __comp = std::less<_Tp>())\n+      : _Base::_LoserTreeUnguardedBase(__k, __sentinel, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n+\t    if (!_M_comp(_M_losers[__right]._M_key,\n+\t\t\t _M_losers[__left]._M_key))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void\n+      __init()\n+      {\n+\t_M_losers[0] = _M_losers[__init_winner(1)];\n \n-    unsigned int\n-    __init_winner(unsigned int __root)\n-    {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n-\t  if (_M_losers[__right]._M_sup\n-\t      || (!_M_losers[__left]._M_sup\n-\t\t  && !_M_comp(*_M_losers[__right]._M_keyp,\n-\t\t\t      *_M_losers[__left]._M_keyp)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void __init()\n-    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n-\n-    void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-    {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top at the beginning\n+\t// (0 sequences!)\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n+      }\n \n-      const _Tp* _M_keyp = &_M_key;\n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by _M_source.\n-\t  if ((_M_sup && (!_M_losers[__pos]._M_sup ||\n-\t\t\t  _M_losers[__pos]._M_source < _M_source)) ||\n-              (!_M_sup && !_M_losers[__pos]._M_sup &&\n-\t       ((_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)) ||\n-                (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n-\t\t && _M_losers[__pos]._M_source < _M_source))))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_sup = _M_sup;\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_keyp = _M_keyp;\n-    }\n-  };\n-\n-/**\n- * @brief Unstable _LoserTree implementation.\n- *\n- * The stable variant is above.\n- */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreePointer</* __stable == */false, _Tp, _Compare>\n-  : public _LoserTreePointerBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreePointerBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n-\n-  public:\n-    _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n-    : _Base::_LoserTreePointerBase(__k, __comp)\n-    { }\n-\n-    unsigned int\n-    __init_winner(unsigned int __root)\n-    {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n-\t  if (_M_losers[__right]._M_sup\n-              || (!_M_losers[__left]._M_sup\n-\t\t  && !_M_comp(*_M_losers[__right]._M_keyp,\n-\t\t\t      *_M_losers[__left]._M_keyp)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void __init()\n-    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n-\n-    void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-    {\n+      // Do not pass a const reference since __key will be used as\n+      // local variable.\n+      void\n+      __delete_min_insert(_Tp __key, bool)\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-      const _Tp* _M_keyp = &_M_key;\n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0;\n-\t   __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (_M_sup || (!_M_losers[__pos]._M_sup\n-\t\t\t && _M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_sup = _M_sup;\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_keyp = _M_keyp;\n-    }\n-  };\n-\n-/** @brief Base class for unguarded _LoserTree implementation.\n- * \n- * The whole element is copied into the tree structure.\n- *\n- * No guarding is done, therefore not a single input sequence must\n- * run empty.  Unused __sequence heads are marked with a sentinel which\n- * is &gt; all elements that are to be merged.\n- *\n- * This is a very fast variant.\n- */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreeUnguardedBase\n-  {\n-  protected:\n-    struct _Loser\n-    {\n-      int _M_source;\n-      _Tp _M_key;\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted, ties are broken by _M_source.\n+\t    if (_M_comp(_M_losers[__pos]._M_key, __key)\n+        \t|| (!_M_comp(__key, _M_losers[__pos]._M_key)\n+                    && _M_losers[__pos]._M_source < __source))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_key, __key);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_key = __key;\n+      }\n     };\n \n-    unsigned int _M_ik, _M_k, _M_offset;\n-    _Loser* _M_losers;\n-    _Compare _M_comp;\n-\n-  public:\n-    _LoserTreeUnguardedBase(unsigned int __k, const _Tp _sentinel,\n-\t\t\t    _Compare __comp = std::less<_Tp>())\n-    : _M_comp(__comp)\n-    {\n-      _M_ik = __k;\n-\n-      // Next greater power of 2.\n-      _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n-      _M_offset = _M_k;\n-      // Avoid default-constructing _M_losers[]._M_key\n-      _M_losers\n-        = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n-\n-      for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n-\t{\n-\t  _M_losers[__i]._M_key = _sentinel;\n-\t  _M_losers[__i]._M_source = -1;\n-\t}\n-    }\n-\n-    ~_LoserTreeUnguardedBase()\n-    { ::operator delete(_M_losers); }\n-\n-    int\n-    __get_min_source()\n-    {\n-#if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n-#endif\n-      return _M_losers[0]._M_source;\n-    }\n-\n-    void\n-    __insert_start(const _Tp& _M_key, int _M_source, bool)\n-    {\n-      unsigned int __pos = _M_k + _M_source;\n-\n-      new(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n-      _M_losers[__pos]._M_source = _M_source;\n-    }\n-  };\n-\n-/**\n- * @brief Stable implementation of unguarded _LoserTree.\n- *\n- * Unstable variant is selected below with partial specialization.\n- */\n-template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-  class _LoserTreeUnguarded\n-  : public _LoserTreeUnguardedBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreeUnguardedBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n-\n-public:\n-    _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n-\t\t\t_Compare __comp = std::less<_Tp>())\n-    : _Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n-    { }\n-\n-    unsigned int\n-    __init_winner(unsigned int __root)\n-    {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n-\t  if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void\n-    __init()\n+  /**\n+   * @brief Non-Stable implementation of unguarded _LoserTree.\n+   *\n+   * Stable implementation is above.\n+   */\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare>\n+    : public _LoserTreeUnguardedBase<_Tp, _Compare>\n     {\n-      _M_losers[0] = _M_losers[__init_winner(1)];\n-      \n-#if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top at the beginning\n-      // (0 sequences!)\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n-#endif\n-    }\n+      typedef _LoserTreeUnguardedBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n \n-    // Do not pass a const reference since _M_key will be used as\n-    // local variable.\n-    void\n-    __delete_min_insert(_Tp _M_key, bool)\n-    {\n-#if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n-#endif\n-\n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by _M_source.\n-\t  if (_M_comp(_M_losers[__pos]._M_key, _M_key)\n-              || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n-                  && _M_losers[__pos]._M_source < _M_source))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_key = _M_key;\n-    }\n-  };\n-\n-/**\n- * @brief Non-Stable implementation of unguarded _LoserTree.\n- *\n- * Stable implementation is above.\n- */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare>\n-  : public _LoserTreeUnguardedBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreeUnguardedBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n-\n-public:\n-    _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n-\t\t\t_Compare __comp = std::less<_Tp>())\n-    : _Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n-    { }\n-\n-    unsigned int\n-    __init_winner(unsigned int __root)\n-    {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n+    public:\n+      _LoserTreeUnguarded(unsigned int __k, const _Tp __sentinel,\n+\t\t\t  _Compare __comp = std::less<_Tp>())\n+      : _Base::_LoserTreeUnguardedBase(__k, __sentinel, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n \n #if _GLIBCXX_ASSERTIONS\n-\t  // If __left one is sentinel then __right one must be, too.\n-\t  if (_M_losers[__left]._M_source == -1)\n-\t    _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n+\t    // If __left one is sentinel then __right one must be, too.\n+\t    if (_M_losers[__left]._M_source == -1)\n+\t      _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n #endif\n \n-\t  if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void\n-    __init()\n-    {\n-      _M_losers[0] = _M_losers[__init_winner(1)];\n+\t    if (!_M_comp(_M_losers[__right]._M_key,\n+\t\t\t _M_losers[__left]._M_key))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void\n+      __init()\n+      {\n+\t_M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top at the beginning\n-      // (0 sequences!)\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top at the beginning\n+\t// (0 sequences!)\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    }\n+      }\n \n-    // Do not pass a const reference since _M_key will be used as\n-    // local variable.\n-    void\n-    __delete_min_insert(_Tp _M_key, bool)\n-    {\n+      // Do not pass a const reference since __key will be used as\n+      // local variable.\n+      void\n+      __delete_min_insert(_Tp __key, bool)\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (_M_comp(_M_losers[__pos]._M_key, _M_key))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_key = _M_key;\n-    }\n-  };\n-\n-/** @brief Unguarded loser tree, keeping only pointers to the\n-* elements in the tree structure.\n-*\n-*  No guarding is done, therefore not a single input sequence must\n-*  run empty.  This is a very fast variant.\n-*/\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreePointerUnguardedBase\n-  {\n-  protected:\n-    struct _Loser\n-    {\n-      int _M_source;\n-      const _Tp* _M_keyp;\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted.\n+\t    if (_M_comp(_M_losers[__pos]._M_key, __key))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_key, __key);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_key = __key;\n+      }\n     };\n \n-    unsigned int _M_ik, _M_k, _M_offset;\n-    _Loser* _M_losers;\n-    _Compare _M_comp;\n-\n-  public:\n-\n-    _LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& _sentinel,\n-\t\t\t\t   _Compare __comp = std::less<_Tp>())\n-    : _M_comp(__comp)\n-    {\n-      _M_ik = __k;\n-\n-      // Next greater power of 2.\n-      _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n-      _M_offset = _M_k;\n-      // Avoid default-constructing _M_losers[]._M_key\n-      _M_losers = new _Loser[2 * _M_k];\n-\n-      for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n-\t{\n-\t  _M_losers[__i]._M_keyp = &_sentinel;\n-\t  _M_losers[__i]._M_source = -1;\n-\t}\n-    }\n-\n-    ~_LoserTreePointerUnguardedBase()\n-    { delete[] _M_losers; }\n-\n-    int\n-    __get_min_source()\n+  /** @brief Unguarded loser tree, keeping only pointers to the\n+  * elements in the tree structure.\n+  *\n+  *  No guarding is done, therefore not a single input sequence must\n+  *  run empty.  This is a very fast variant.\n+  */\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreePointerUnguardedBase\n     {\n+    protected:\n+      struct _Loser\n+      {\n+\tint _M_source;\n+\tconst _Tp* _M_keyp;\n+      };\n+\n+      unsigned int _M_ik, _M_k, _M_offset;\n+      _Loser* _M_losers;\n+      _Compare _M_comp;\n+\n+    public:\n+\n+      _LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& __sentinel,\n+\t\t\t\t     _Compare __comp = std::less<_Tp>())\n+      : _M_comp(__comp)\n+      {\n+\t_M_ik = __k;\n+\n+\t// Next greater power of 2.\n+\t_M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n+\t_M_offset = _M_k;\n+\t// Avoid default-constructing _M_losers[]._M_key\n+\t_M_losers = new _Loser[2 * _M_k];\n+\n+\tfor (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n+\t  {\n+\t    _M_losers[__i]._M_keyp = &__sentinel;\n+\t    _M_losers[__i]._M_source = -1;\n+\t  }\n+      }\n+\n+      ~_LoserTreePointerUnguardedBase()\n+      { delete[] _M_losers; }\n+\n+      int\n+      __get_min_source()\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-      return _M_losers[0]._M_source;\n-    }\n+\treturn _M_losers[0]._M_source;\n+      }\n \n-    void\n-    __insert_start(const _Tp& _M_key, int _M_source, bool)\n-    {\n-      unsigned int __pos = _M_k + _M_source;\n-\n-      _M_losers[__pos]._M_keyp = &_M_key;\n-      _M_losers[__pos]._M_source = _M_source;\n-    }\n-  };\n-\n-/**\n- * @brief Stable unguarded _LoserTree variant storing pointers.\n- *\n- * Unstable variant is implemented below using partial specialization.\n- */\n-template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-  class _LoserTreePointerUnguarded\n-  : public _LoserTreePointerUnguardedBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n+      void\n+      __insert_start(const _Tp& __key, int __source, bool)\n+      {\n+\tunsigned int __pos = _M_k + __source;\n \n-  public:\n-    _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n-\t\t\t       _Compare __comp = std::less<_Tp>())\n-    : _Base::_LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n-    { }\n+\t_M_losers[__pos]._M_keyp = &__key;\n+\t_M_losers[__pos]._M_source = __source;\n+      }\n+    };\n \n-    unsigned int\n-    __init_winner(unsigned int __root)\n-    {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n-\t  if (!_M_comp(*_M_losers[__right]._M_keyp,\n-\t\t       *_M_losers[__left]._M_keyp))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-    \n-    void\n-    __init()\n+  /**\n+   * @brief Stable unguarded _LoserTree variant storing pointers.\n+   *\n+   * Unstable variant is implemented below using partial specialization.\n+   */\n+  template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n+    class _LoserTreePointerUnguarded\n+    : public _LoserTreePointerUnguardedBase<_Tp, _Compare>\n     {\n-      _M_losers[0] = _M_losers[__init_winner(1)];\n+      typedef _LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n+\n+    public:\n+      _LoserTreePointerUnguarded(unsigned int __k, const _Tp& __sentinel,\n+\t\t\t\t _Compare __comp = std::less<_Tp>())\n+      : _Base::_LoserTreePointerUnguardedBase(__k, __sentinel, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n+\t    if (!_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t\t *_M_losers[__left]._M_keyp))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void\n+      __init()\n+      {\n+\t_M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top at the beginning\n-      // (0 sequences!)\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top at the beginning\n+\t// (0 sequences!)\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    }\n+      }\n \n-    void\n-    __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-    {\n+      void\n+      __delete_min_insert(const _Tp& __key, bool __sup)\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-      const _Tp* _M_keyp = &_M_key;\n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by _M_source.\n-\t  if (_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)\n-\t      || (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n-\t\t  && _M_losers[__pos]._M_source < _M_source))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_keyp = _M_keyp;\n-    }\n-  };\n-\n-/**\n- * @brief Unstable unguarded _LoserTree variant storing pointers.\n- *\n- * Stable variant is above.\n- */\n-template<typename _Tp, typename _Compare>\n-  class _LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare>\n-  : public _LoserTreePointerUnguardedBase<_Tp, _Compare>\n-  {\n-    typedef _LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n-    using _Base::_M_k;\n-    using _Base::_M_losers;\n-\n-public:\n-    _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n-\t\t\t       _Compare __comp = std::less<_Tp>())\n-    : _Base::_LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n-    { }\n-\n-    unsigned int\n-    __init_winner(unsigned int __root)\n+\tconst _Tp* __keyp = &__key;\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted, ties are broken by _M_source.\n+\t    if (_M_comp(*_M_losers[__pos]._M_keyp, *__keyp)\n+\t\t|| (!_M_comp(*__keyp, *_M_losers[__pos]._M_keyp)\n+\t\t    && _M_losers[__pos]._M_source < __source))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_keyp, __keyp);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_keyp = __keyp;\n+      }\n+    };\n+\n+  /**\n+   * @brief Unstable unguarded _LoserTree variant storing pointers.\n+   *\n+   * Stable variant is above.\n+   */\n+  template<typename _Tp, typename _Compare>\n+    class _LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare>\n+    : public _LoserTreePointerUnguardedBase<_Tp, _Compare>\n     {\n-      if (__root >= _M_k)\n-\treturn __root;\n-      else\n-\t{\n-\t  unsigned int __left = __init_winner (2 * __root);\n-\t  unsigned int __right = __init_winner (2 * __root + 1);\n+      typedef _LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n+      using _Base::_M_k;\n+      using _Base::_M_losers;\n+\n+  public:\n+      _LoserTreePointerUnguarded(unsigned int __k, const _Tp& __sentinel,\n+\t\t\t\t _Compare __comp = std::less<_Tp>())\n+      : _Base::_LoserTreePointerUnguardedBase(__k, __sentinel, __comp)\n+      { }\n+\n+      unsigned int\n+      __init_winner(unsigned int __root)\n+      {\n+\tif (__root >= _M_k)\n+\t  return __root;\n+\telse\n+\t  {\n+\t    unsigned int __left = __init_winner(2 * __root);\n+\t    unsigned int __right = __init_winner(2 * __root + 1);\n \n #if _GLIBCXX_ASSERTIONS\n-\t  // If __left one is sentinel then __right one must be, too.\n-\t  if (_M_losers[__left]._M_source == -1)\n-\t    _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n+\t    // If __left one is sentinel then __right one must be, too.\n+\t    if (_M_losers[__left]._M_source == -1)\n+\t      _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n #endif\n \n-\t  if (!_M_comp(*_M_losers[__right]._M_keyp,\n-\t\t       *_M_losers[__left]._M_keyp))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      _M_losers[__root] = _M_losers[__right];\n-\t      return __left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      _M_losers[__root] = _M_losers[__left];\n-\t      return __right;\n-\t    }\n-\t}\n-    }\n-\n-    void\n-    __init()\n-    {\n-      _M_losers[0] = _M_losers[__init_winner(1)];\n+\t    if (!_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t\t *_M_losers[__left]._M_keyp))\n+\t      {\n+\t\t// Left one is less or equal.\n+\t\t_M_losers[__root] = _M_losers[__right];\n+\t\treturn __left;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Right one is less.\n+\t\t_M_losers[__root] = _M_losers[__left];\n+\t\treturn __right;\n+\t      }\n+\t  }\n+      }\n+\n+      void\n+      __init()\n+      {\n+\t_M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top at the beginning\n-      // (0 sequences!)\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top at the beginning\n+\t// (0 sequences!)\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    }\n+      }\n \n-    void\n-    __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-    {\n+      void\n+      __delete_min_insert(const _Tp& __key, bool __sup)\n+      {\n #if _GLIBCXX_ASSERTIONS\n-      // no dummy sequence can ever be at the top!\n-      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+\t// no dummy sequence can ever be at the top!\n+\t_GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-      const _Tp* _M_keyp = &_M_key;\n-      int _M_source = _M_losers[0]._M_source;\n-      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (_M_comp(*(_M_losers[__pos]._M_keyp), *_M_keyp))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n-\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-\t    }\n-\t}\n-\n-      _M_losers[0]._M_source = _M_source;\n-      _M_losers[0]._M_keyp = _M_keyp;\n-    }\n-  };\n+\tconst _Tp* __keyp = &__key;\n+\tint __source = _M_losers[0]._M_source;\n+\tfor (unsigned int __pos = (_M_k + __source) / 2; __pos > 0;\n+\t     __pos /= 2)\n+\t  {\n+\t    // The smaller one gets promoted.\n+\t    if (_M_comp(*(_M_losers[__pos]._M_keyp), *__keyp))\n+\t      {\n+\t\t// The other one is smaller.\n+\t\tstd::swap(_M_losers[__pos]._M_source, __source);\n+\t\tstd::swap(_M_losers[__pos]._M_keyp, __keyp);\n+\t      }\n+\t  }\n+\n+\t_M_losers[0]._M_source = __source;\n+\t_M_losers[0]._M_keyp = __keyp;\n+      }\n+    };\n } // namespace __gnu_parallel\n \n #endif /* _GLIBCXX_PARALLEL_LOSERTREE_H */"}, {"sha": "2343d7326e8cfac06a86b80c004397625b6d7edd", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 34, "deletions": 44, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -54,11 +54,10 @@ namespace __gnu_parallel\n            typename _OutputIterator, typename _DifferenceTp,\n            typename _Compare>\n     _OutputIterator\n-    __merge_advance_usual(_RAIter1& __begin1,\n-                        _RAIter1 __end1,\n-                        _RAIter2& __begin2,\n-                        _RAIter2 __end2, _OutputIterator __target,\n-                        _DifferenceTp __max_length, _Compare __comp)\n+    __merge_advance_usual(_RAIter1& __begin1, _RAIter1 __end1,\n+\t\t\t  _RAIter2& __begin2, _RAIter2 __end2,\n+\t\t\t  _OutputIterator __target,\n+\t\t\t  _DifferenceTp __max_length, _Compare __comp)\n     {\n       typedef _DifferenceTp _DifferenceType;\n       while (__begin1 != __end1 && __begin2 != __end2 && __max_length > 0)\n@@ -103,12 +102,10 @@ namespace __gnu_parallel\n            typename _OutputIterator, typename _DifferenceTp,\n            typename _Compare>\n     _OutputIterator\n-    __merge_advance_movc(_RAIter1& __begin1,\n-                       _RAIter1 __end1,\n-                       _RAIter2& __begin2,\n-                       _RAIter2 __end2,\n-                       _OutputIterator __target,\n-                       _DifferenceTp __max_length, _Compare __comp)\n+    __merge_advance_movc(_RAIter1& __begin1, _RAIter1 __end1,\n+\t\t\t _RAIter2& __begin2, _RAIter2 __end2,\n+\t\t\t _OutputIterator __target,\n+\t\t\t _DifferenceTp __max_length, _Compare __comp)\n     {\n       typedef _DifferenceTp _DifferenceType;\n       typedef typename std::iterator_traits<_RAIter1>::value_type\n@@ -172,14 +169,14 @@ namespace __gnu_parallel\n            typename _Compare>\n     inline _OutputIterator\n     __merge_advance(_RAIter1& __begin1, _RAIter1 __end1,\n-                  _RAIter2& __begin2, _RAIter2 __end2,\n-                  _OutputIterator __target, _DifferenceTp __max_length,\n-                  _Compare __comp)\n+\t\t    _RAIter2& __begin2, _RAIter2 __end2,\n+\t\t    _OutputIterator __target, _DifferenceTp __max_length,\n+\t\t    _Compare __comp)\n     {\n       _GLIBCXX_CALL(__max_length)\n \n-      return __merge_advance_movc(__begin1, __end1, __begin2, __end2, __target,\n-                                __max_length, __comp);\n+      return __merge_advance_movc(__begin1, __end1, __begin2, __end2,\n+\t\t\t\t  __target, __max_length, __comp);\n     }\n \n   /** @brief Merge routine fallback to sequential in case the\n@@ -195,17 +192,15 @@ namespace __gnu_parallel\n   template<typename _RAIter1, typename _RAIter2,\n            typename _RAIter3, typename _Compare>\n     inline _RAIter3\n-    __parallel_merge_advance(_RAIter1& __begin1,\n-                           _RAIter1 __end1,\n-                           _RAIter2& __begin2,\n-                           // different iterators, parallel implementation\n-                           // not available                        \n-                           _RAIter2 __end2,\n-                           _RAIter3 __target, typename\n-                           std::iterator_traits<_RAIter1>::\n-                           difference_type __max_length, _Compare __comp)\n+    __parallel_merge_advance(_RAIter1& __begin1, _RAIter1 __end1,\n+\t\t\t     _RAIter2& __begin2,\n+\t\t\t     // different iterators, parallel implementation\n+\t\t\t     // not available\n+\t\t\t     _RAIter2 __end2, _RAIter3 __target, typename\n+\t\t\t     std::iterator_traits<_RAIter1>::\n+\t\t\t     difference_type __max_length, _Compare __comp)\n     { return __merge_advance(__begin1, __end1, __begin2, __end2, __target,\n-                           __max_length, __comp); }\n+\t\t\t     __max_length, __comp); }\n \n   /** @brief Parallel merge routine being able to merge only the @__c\n    * __max_length smallest elements.\n@@ -225,13 +220,11 @@ namespace __gnu_parallel\n   template<typename _RAIter1, typename _RAIter3,\n            typename _Compare>\n     inline _RAIter3\n-    __parallel_merge_advance(_RAIter1& __begin1,\n-                           _RAIter1 __end1,\n-                           _RAIter1& __begin2,\n-                           _RAIter1 __end2,\n-                           _RAIter3 __target, typename\n-                           std::iterator_traits<_RAIter1>::\n-                           difference_type __max_length, _Compare __comp)\n+    __parallel_merge_advance(_RAIter1& __begin1, _RAIter1 __end1,\n+\t\t\t     _RAIter1& __begin2, _RAIter1 __end2,\n+\t\t\t     _RAIter3 __target, typename\n+\t\t\t     std::iterator_traits<_RAIter1>::\n+\t\t\t     difference_type __max_length, _Compare __comp)\n     {\n       typedef typename\n           std::iterator_traits<_RAIter1>::value_type _ValueType;\n@@ -242,17 +235,14 @@ namespace __gnu_parallel\n       typedef typename std::pair<_RAIter1, _RAIter1>\n         _IteratorPair;\n \n-      _IteratorPair\n-        seqs[2] = { std::make_pair(__begin1, __end1),\n-                    std::make_pair(__begin2, __end2) };\n-      _RAIter3\n-        __target_end = parallel_multiway_merge\n-          < /* __stable = */ true, /* __sentinels = */ false>(\n-            seqs, seqs + 2, __target,\n-            multiway_merge_exact_splitting\n-              < /* __stable = */ true, _IteratorPair*,\n-                _Compare, _DifferenceType1>,\n-            __max_length, __comp, omp_get_max_threads());\n+      _IteratorPair __seqs[2] = { std::make_pair(__begin1, __end1),\n+\t\t\t\t  std::make_pair(__begin2, __end2) };\n+      _RAIter3 __target_end = parallel_multiway_merge\n+\t< /* __stable = */ true, /* __sentinels = */ false>\n+\t(__seqs, __seqs + 2, __target, multiway_merge_exact_splitting\n+\t < /* __stable = */ true, _IteratorPair*,\n+\t _Compare, _DifferenceType1>, __max_length, __comp,\n+\t omp_get_max_threads());\n \n       return __target_end;\n     }"}, {"sha": "e434eee624c85d491eee51c28f3086f976f028ed", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -53,8 +53,8 @@ namespace __gnu_parallel\n   /** @brief Compare __a pair of types lexicographically, ascending. */\n   template<typename _T1, typename _T2, typename _Compare>\n     class _Lexicographic\n-    : public std::binary_function<\n-                                std::pair<_T1, _T2>, std::pair<_T1, _T2>, bool>\n+    : public std::binary_function<std::pair<_T1, _T2>,\n+\t\t\t\t  std::pair<_T1, _T2>, bool>\n     {\n     private:\n       _Compare& _M_comp;\n@@ -142,19 +142,19 @@ namespace __gnu_parallel\n \n       // Number of sequences, number of elements in total (possibly\n       // including padding).\n-      _DifferenceType __m = std::distance(__begin_seqs, __end_seqs), __N = 0,\n+      _DifferenceType __m = std::distance(__begin_seqs, __end_seqs), __nn = 0,\n                       __nmax, __n, __r;\n \n       for (int __i = 0; __i < __m; __i++)\n         {\n-          __N += std::distance(__begin_seqs[__i].first,\n+          __nn += std::distance(__begin_seqs[__i].first,\n                                __begin_seqs[__i].second);\n           _GLIBCXX_PARALLEL_ASSERT(\n             std::distance(__begin_seqs[__i].first,\n                           __begin_seqs[__i].second) > 0);\n         }\n \n-      if (__rank == __N)\n+      if (__rank == __nn)\n         {\n           for (int __i = 0; __i < __m; __i++)\n             __begin_offsets[__i] = __begin_seqs[__i].second; // Very end.\n@@ -163,9 +163,9 @@ namespace __gnu_parallel\n         }\n \n       _GLIBCXX_PARALLEL_ASSERT(__m != 0);\n-      _GLIBCXX_PARALLEL_ASSERT(__N != 0);\n+      _GLIBCXX_PARALLEL_ASSERT(__nn != 0);\n       _GLIBCXX_PARALLEL_ASSERT(__rank >= 0);\n-      _GLIBCXX_PARALLEL_ASSERT(__rank < __N);\n+      _GLIBCXX_PARALLEL_ASSERT(__rank < __nn);\n \n       _DifferenceType* __ns = new _DifferenceType[__m];\n       _DifferenceType* __a = new _DifferenceType[__m];\n@@ -401,14 +401,14 @@ namespace __gnu_parallel\n       // Number of sequences, number of elements in total (possibly\n       // including padding).\n       _DifferenceType __m = std::distance(__begin_seqs, __end_seqs);\n-      _DifferenceType __N = 0;\n+      _DifferenceType __nn = 0;\n       _DifferenceType __nmax, __n, __r;\n \n       for (int __i = 0; __i < __m; __i++)\n-        __N += std::distance(__begin_seqs[__i].first,\n-                             __begin_seqs[__i].second);\n+        __nn += std::distance(__begin_seqs[__i].first,\n+\t\t\t      __begin_seqs[__i].second);\n \n-      if (__m == 0 || __N == 0 || __rank < 0 || __rank >= __N)\n+      if (__m == 0 || __nn == 0 || __rank < 0 || __rank >= __nn)\n         {\n           // result undefined if there is no data or __rank is outside bounds\n           throw std::exception();\n@@ -433,7 +433,7 @@ namespace __gnu_parallel\n \n       // Pad all lists to this length, at least as long as any ns[__i],\n       // equality iff __nmax = 2^__k - 1\n-      __l = pow2(__r) - 1;\n+      __l = __round_up_to_pow2(__r) - 1;\n \n       for (int __i = 0; __i < __m; ++__i)\n         {"}, {"sha": "4238a1c6923f3ddd392ea46a95dd5614e9afaba9", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 1837, "deletions": 1862, "changes": 3699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=77d16198fc5262198db7ed29609a791104b37fcf"}, {"sha": "1f2c43db61f1731688fe71bd42b14c0de0eeb7b1", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 37, "deletions": 47, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -125,8 +125,7 @@ namespace __gnu_parallel\n   /** @brief Split by exact splitting. */\n   template<typename _RAIter, typename _Compare,\n \t   typename _SortingPlacesIterator>\n-    struct _SplitConsistently<true, _RAIter,\n-\t\t\t      _Compare, _SortingPlacesIterator>\n+    struct _SplitConsistently<true, _RAIter, _Compare, _SortingPlacesIterator>\n     {\n       void\n       operator()(const _ThreadIndex __iam,\n@@ -140,27 +139,27 @@ namespace __gnu_parallel\n \n \tstd::vector<std::pair<_SortingPlacesIterator,\n \t                      _SortingPlacesIterator> >\n-\t  seqs(__sd->_M_num_threads);\n+\t  __seqs(__sd->_M_num_threads);\n \tfor (_ThreadIndex __s = 0; __s < __sd->_M_num_threads; __s++)\n-\t  seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n-\t\t\t\t     __sd->_M_temporary[__s]\n-\t\t\t\t     + (__sd->_M_starts[__s + 1]\n-\t\t\t\t\t- __sd->_M_starts[__s]));\n+\t  __seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n+\t\t\t\t       __sd->_M_temporary[__s]\n+\t\t\t\t       + (__sd->_M_starts[__s + 1]\n+\t\t\t\t\t  - __sd->_M_starts[__s]));\n \n-\tstd::vector<_SortingPlacesIterator> _M_offsets(__sd->_M_num_threads);\n+\tstd::vector<_SortingPlacesIterator> __offsets(__sd->_M_num_threads);\n \n \t// if not last thread\n \tif (__iam < __sd->_M_num_threads - 1)\n-\t  multiseq_partition(seqs.begin(), seqs.end(),\n-\t\t\t     __sd->_M_starts[__iam + 1], _M_offsets.begin(),\n+\t  multiseq_partition(__seqs.begin(), __seqs.end(),\n+\t\t\t     __sd->_M_starts[__iam + 1], __offsets.begin(),\n \t\t\t     __comp);\n \n \tfor (int __seq = 0; __seq < __sd->_M_num_threads; __seq++)\n \t  {\n \t    // for each sequence\n \t    if (__iam < (__sd->_M_num_threads - 1))\n \t      __sd->_M_pieces[__iam][__seq]._M_end\n-\t\t= _M_offsets[__seq] - seqs[__seq].first;\n+\t\t= __offsets[__seq] - __seqs[__seq].first;\n \t    else\n \t      // very end of this sequence\n \t      __sd->_M_pieces[__iam][__seq]._M_end =\n@@ -185,8 +184,7 @@ namespace __gnu_parallel\n   /** @brief Split by sampling. */ \n   template<typename _RAIter, typename _Compare,\n \t   typename _SortingPlacesIterator>\n-    struct _SplitConsistently<false, _RAIter, _Compare,\n-\t\t\t      _SortingPlacesIterator>\n+    struct _SplitConsistently<false, _RAIter, _Compare, _SortingPlacesIterator>\n     {\n       void\n       operator()(const _ThreadIndex __iam,\n@@ -282,10 +280,8 @@ namespace __gnu_parallel\n \t\t      const _RAIter& __target,\n \t\t      _Compare& __comp,\n \t\t      _DiffType __length_am) const\n-      {\n-\tstable_multiway_merge(__seqs_begin, __seqs_end, __target, __length_am,\n-\t\t\t      __comp, sequential_tag());\n-      }\n+      { stable_multiway_merge(__seqs_begin, __seqs_end, __target,\n+\t\t\t      __length_am, __comp, sequential_tag()); }\n     };\n \n   template<typename Seq_RAIter, typename _RAIter,\n@@ -298,10 +294,8 @@ namespace __gnu_parallel\n                       const _RAIter& __target,\n                       _Compare& __comp,\n                       _DiffType __length_am) const\n-      {\n-\tmultiway_merge(__seqs_begin, __seqs_end, __target, __length_am, __comp,\n-                       sequential_tag());\n-      }\n+      { multiway_merge(__seqs_begin, __seqs_end, __target, __length_am,\n+\t\t       __comp, sequential_tag()); }\n     };\n \n   /** @brief PMWMS code executed by each thread.\n@@ -321,8 +315,8 @@ namespace __gnu_parallel\n       _ThreadIndex __iam = omp_get_thread_num();\n \n       // Length of this thread's chunk, before merging.\n-      _DifferenceType __length_local\n-\t= __sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n+      _DifferenceType __length_local =\n+\t__sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n \n       // Sort in temporary storage, leave space for sentinel.\n \n@@ -350,8 +344,7 @@ namespace __gnu_parallel\n \n       _DifferenceType __num_samples =\n         _Settings::get().sort_mwms_oversampling * __sd->_M_num_threads - 1;\n-      _SplitConsistently\n-\t<__exact, _RAIter, _Compare, _SortingPlacesIterator>()\n+      _SplitConsistently<__exact, _RAIter, _Compare, _SortingPlacesIterator>()\n         (__iam, __sd, __comp, __num_samples);\n \n       // Offset from __target __begin, __length after merging.\n@@ -364,26 +357,24 @@ namespace __gnu_parallel\n \t}\n \n       typedef std::vector<\n-      std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n+        std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n         _SeqVector;\n-      _SeqVector seqs(__sd->_M_num_threads);\n+      _SeqVector __seqs(__sd->_M_num_threads);\n \n       for (int __s = 0; __s < __sd->_M_num_threads; ++__s)\n \t{\n-\t  seqs[__s] =\n-\t    std::make_pair\n-\t    (__sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_begin,\n-\t     __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s]._M_end);\n+\t  __seqs[__s] =\n+\t    std::make_pair(__sd->_M_temporary[__s]\n+\t\t\t   + __sd->_M_pieces[__iam][__s]._M_begin,\n+\t\t\t   __sd->_M_temporary[__s]\n+\t\t\t   + __sd->_M_pieces[__iam][__s]._M_end);\n \t}\n \n       __possibly_stable_multiway_merge<\n-        __stable,\n-        typename _SeqVector::iterator,\n-        _RAIter,\n-        _Compare, _DifferenceType>()\n-          (seqs.begin(), seqs.end(),\n-\t   __sd->_M_source + __offset, __comp,\n-           __length_am);\n+        __stable, typename _SeqVector::iterator,\n+\t_RAIter, _Compare, _DifferenceType>()(__seqs.begin(), __seqs.end(),\n+\t\t\t\t     __sd->_M_source + __offset, __comp,\n+\t\t\t\t     __length_am);\n \n #     pragma omp barrier\n \n@@ -421,7 +412,7 @@ namespace __gnu_parallel\n \n       // shared variables\n       _PMWMSSortingData<_RAIter> __sd;\n-      _DifferenceType* _M_starts;\n+      _DifferenceType* __starts;\n \n #     pragma omp parallel num_threads(__num_threads)\n       {\n@@ -450,30 +441,29 @@ namespace __gnu_parallel\n \t    = new std::vector<_Piece<_DifferenceType> >[__num_threads];\n \t  for (int __s = 0; __s < __num_threads; ++__s)\n \t    __sd._M_pieces[__s].resize(__num_threads);\n-\t  _M_starts = __sd._M_starts\n-\t    = new _DifferenceType[__num_threads + 1];\n+\t  __starts = __sd._M_starts = new _DifferenceType[__num_threads + 1];\n \n \t  _DifferenceType __chunk_length = __n / __num_threads;\n \t  _DifferenceType __split = __n % __num_threads;\n \t  _DifferenceType __pos = 0;\n \t  for (int __i = 0; __i < __num_threads; ++__i)\n \t    {\n-\t      _M_starts[__i] = __pos;\n-\t      __pos += (__i < __split)\n-\t\t? (__chunk_length + 1) : __chunk_length;\n+\t      __starts[__i] = __pos;\n+\t      __pos += ((__i < __split)\n+\t\t\t? (__chunk_length + 1) : __chunk_length);\n \t    }\n-\t  _M_starts[__num_threads] = __pos;\n+\t  __starts[__num_threads] = __pos;\n \t} //single\n \n         // Now sort in parallel.\n         parallel_sort_mwms_pu<__stable, __exact>(&__sd, __comp);\n       } //parallel\n \n-      delete[] _M_starts;\n+      delete[] __starts;\n       delete[] __sd._M_temporary;\n \n       if (!__exact)\n-      ::operator delete(__sd._M_samples);\n+\t::operator delete(__sd._M_samples);\n \n       delete[] __sd._M_offsets;\n       delete[] __sd._M_pieces;"}, {"sha": "6c5607cedc5fb457c74ff95fa073ddaf21c6e411", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -69,7 +69,7 @@ namespace __parallel\n     __accumulate_switch(_IIter __begin, _IIter __end,\n                       _Tp __init, _IteratorTag) \n     { return accumulate(__begin, __end, __init,\n-__gnu_parallel::sequential_tag()); }\n+\t\t\t__gnu_parallel::sequential_tag()); }\n \n   template<typename _IIter, typename _Tp, typename _BinaryOperation,\n            typename _IteratorTag>"}, {"sha": "d07fd7a9307fd5c9e5a8cdf7231c1e4271cc71cf", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -74,8 +74,8 @@ namespace __gnu_parallel\n         _DifferenceType;\n \n       _DifferenceType __length = __end - __begin;\n-      _ThreadIndex __num_threads =\n-\t__gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n+      _ThreadIndex __num_threads = __gnu_parallel::min<_DifferenceType>\n+\t(__get_max_threads(), __length);\n \n       _Result *__thread_results;\n \n@@ -94,8 +94,8 @@ namespace __gnu_parallel\n \n #pragma omp for schedule(dynamic, _Settings::get().workstealing_chunk_size)\n         for (_DifferenceType __pos = 0; __pos < __length; ++__pos)\n-          __thread_results[__iam] =\n-\t    __r(__thread_results[__iam], __f(__o, __begin+__pos));\n+          __thread_results[__iam] = __r(__thread_results[__iam],\n+\t\t\t\t\t__f(__o, __begin+__pos));\n       } //parallel\n \n       for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)"}, {"sha": "f43726e1973e7b642169e69d461a57aec6bc6c6f", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -74,8 +74,8 @@ namespace __gnu_parallel\n \t_DifferenceType;\n \n       _DifferenceType __length = __end - __begin;\n-      _ThreadIndex __num_threads =\n-\tstd::min<_DifferenceType>(__get_max_threads(), __length);\n+      _ThreadIndex __num_threads = std::min<_DifferenceType>\n+\t(__get_max_threads(), __length);\n \n       _Result *__thread_results;\n "}, {"sha": "1e21d3ad042fc540932659e27e2fbc5e3a8c71f2", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -75,25 +75,24 @@ namespace __gnu_parallel\n       _Result *__thread_results;\n       bool* __constructed;\n \n-      _ThreadIndex __num_threads =\n-\t__gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n+      _ThreadIndex __num_threads = __gnu_parallel::min<_DifferenceType>\n+\t(__get_max_threads(), __length);\n \n #     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n \t{\n \t  __num_threads = omp_get_num_threads();\n-\t  __thread_results =\n-\t    static_cast<_Result*>(::operator new(__num_threads\n-\t\t\t\t\t\t * sizeof(_Result)));\n+\t  __thread_results = static_cast<_Result*>\n+\t    (::operator new(__num_threads * sizeof(_Result)));\n \t  __constructed = new bool[__num_threads];\n \t}\n \n \t_ThreadIndex __iam = omp_get_thread_num();\n \n \t// Neutral element.\n-\t_Result* __reduct =\n-\t  static_cast<_Result*>(::operator new(sizeof(_Result)));\n+\t_Result* __reduct = static_cast<_Result*>\n+\t  (::operator new(sizeof(_Result)));\n \n \t_DifferenceType\n \t  __start = equally_split_point(__length, __num_threads, __iam),"}, {"sha": "02404203f4e7793e7390bc26db22dee4b959e89b", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -149,9 +149,10 @@ namespace __gnu_parallel\n         if (__iam == 0)\n           {\n             *__result = *__begin;\n-            __parallel_partial_sum_basecase(\n-                __begin + 1, __begin + __borders[1], __result + 1,\n-                __bin_op, *__begin);\n+            __parallel_partial_sum_basecase(__begin + 1,\n+\t\t\t\t\t    __begin + __borders[1],\n+\t\t\t\t\t    __result + 1,\n+\t\t\t\t\t    __bin_op, *__begin);\n             ::new(&(__sums[__iam])) _ValueType(*(__result + __borders[1] - 1));\n           }\n         else\n@@ -168,7 +169,7 @@ namespace __gnu_parallel\n \n #       pragma omp single\n \t__parallel_partial_sum_basecase(__sums + 1, __sums + __num_threads,\n-                                          __sums + 1, __bin_op, __sums[0]);\n+\t\t\t\t\t__sums + 1, __bin_op, __sums[0]);\n \n #       pragma omp barrier\n "}, {"sha": "86723c512701643f1c8c6424bac7b21a4e3b2913", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 365, "deletions": 361, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -44,387 +44,391 @@\n \n namespace __gnu_parallel\n {\n-/** @brief Parallel implementation of std::partition.\n-  *  @param __begin Begin iterator of input sequence to split.\n-  *  @param __end End iterator of input sequence to split.\n-  *  @param __pred Partition predicate, possibly including some kind of pivot.\n-  *  @param __num_threads Maximum number of threads to use for this task.\n-  *  @return Number of elements not fulfilling the predicate. */\n-template<typename _RAIter, typename _Predicate>\n-  typename std::iterator_traits<_RAIter>::difference_type\n-  __parallel_partition(_RAIter __begin, _RAIter __end,\n-                     _Predicate __pred, _ThreadIndex __num_threads)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _DifferenceType __n = __end - __begin;\n-\n-    _GLIBCXX_CALL(__n)\n-\n-    const _Settings& __s = _Settings::get();\n-\n-    // Shared.\n-    _GLIBCXX_VOLATILE _DifferenceType __left = 0, __right = __n - 1;\n-    _GLIBCXX_VOLATILE _DifferenceType __leftover_left, __leftover_right;\n-    _GLIBCXX_VOLATILE _DifferenceType __leftnew, __rightnew;\n-\n-    bool* __reserved_left = NULL, * __reserved_right = NULL;\n-\n-    _DifferenceType __chunk_size;\n-\n-    omp_lock_t __result_lock;\n-    omp_init_lock(&__result_lock);\n-\n-    //at least two chunks per thread\n-    if(__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n-#   pragma omp parallel num_threads(__num_threads)\n-      {\n-#       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-            __reserved_left = new bool[__num_threads];\n-            __reserved_right = new bool[__num_threads];\n-\n-            if (__s.partition_chunk_share > 0.0)\n-              __chunk_size = std::max<_DifferenceType>(\n-                __s.partition_chunk_size,\n-                (double)__n * __s.partition_chunk_share /\n-                    (double)__num_threads);\n-            else\n-              __chunk_size = __s.partition_chunk_size;\n-          }\n-\n-        while (__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n-          {\n-#           pragma omp single\n-              {\n-                _DifferenceType __num_chunks\n-                    = (__right - __left + 1) / __chunk_size;\n-\n-                for (int __r = 0; __r < __num_threads; ++__r)\n-                  {\n-                    __reserved_left[__r] = false;\n-                    __reserved_right[__r] = false;\n-                  }\n-                __leftover_left = 0;\n-                __leftover_right = 0;\n-              } //implicit barrier\n-\n-            // Private.\n-            _DifferenceType __thread_left, __thread_left_border,\n-                            __thread_right, __thread_right_border;\n-            __thread_left = __left + 1;\n-\n-            // Just to satisfy the condition below.\n-            __thread_left_border = __thread_left - 1;\n-            __thread_right = __n - 1;\n-            __thread_right_border = __thread_right + 1;\n-\n-            bool __iam_finished = false;\n-            while (!__iam_finished)\n-              {\n-                if (__thread_left > __thread_left_border)\n-                  {\n-                    omp_set_lock(&__result_lock);\n-                    if (__left + (__chunk_size - 1) > __right)\n-                      __iam_finished = true;\n-                    else\n-                      {\n-                        __thread_left = __left;\n-                        __thread_left_border = __left + (__chunk_size - 1);\n-                        __left += __chunk_size;\n-                      }\n-                    omp_unset_lock(&__result_lock);\n-                  }\n-\n-                if (__thread_right < __thread_right_border)\n-                  {\n-                    omp_set_lock(&__result_lock);\n-                    if (__left > __right - (__chunk_size - 1))\n-                      __iam_finished = true;\n-                    else\n-                      {\n-                        __thread_right = __right;\n-                        __thread_right_border = __right - (__chunk_size - 1);\n-                        __right -= __chunk_size;\n-                      }\n-                    omp_unset_lock(&__result_lock);\n-                  }\n-\n-                if (__iam_finished)\n-                  break;\n-\n-                // Swap as usual.\n-                while (__thread_left < __thread_right)\n-                  {\n-                    while (__pred(__begin[__thread_left])\n-                            && __thread_left <= __thread_left_border)\n-                      ++__thread_left;\n-                    while (!__pred(__begin[__thread_right])\n-                            && __thread_right >= __thread_right_border)\n-                      --__thread_right;\n-\n-                    if (__thread_left > __thread_left_border\n-                        || __thread_right < __thread_right_border)\n-                      // Fetch new chunk(__s).\n-                      break;\n-\n-                    std::swap(__begin[__thread_left], __begin[__thread_right]);\n-                    ++__thread_left;\n-                    --__thread_right;\n-                  }\n-              }\n-\n-            // Now swap the leftover chunks to the right places.\n-            if (__thread_left <= __thread_left_border)\n-#             pragma omp atomic\n-              ++__leftover_left;\n-            if (__thread_right >= __thread_right_border)\n-#             pragma omp atomic\n-              ++__leftover_right;\n-\n-#           pragma omp barrier\n-\n-#           pragma omp single\n-              {\n-                __leftnew = __left - __leftover_left * __chunk_size;\n-                __rightnew = __right + __leftover_right * __chunk_size;\n-              }\n-\n-#           pragma omp barrier\n-\n-            // <=> __thread_left_border + (__chunk_size - 1) >= __leftnew\n-            if (__thread_left <= __thread_left_border\n-                && __thread_left_border >= __leftnew)\n-              {\n-                // Chunk already in place, reserve spot.\n-                __reserved_left\n-                  [(__left - (__thread_left_border + 1)) / __chunk_size]\n-                    = true;\n-              }\n-\n-            // <=> __thread_right_border - (__chunk_size - 1) <= __rightnew\n-            if (__thread_right >= __thread_right_border\n-                && __thread_right_border <= __rightnew)\n-              {\n-                // Chunk already in place, reserve spot.\n-                __reserved_right[((__thread_right_border - 1) - __right)\n-                               / __chunk_size] = true;\n-              }\n-\n-#           pragma omp barrier\n-\n-            if (__thread_left <= __thread_left_border\n-                && __thread_left_border < __leftnew)\n-              {\n-                // Find spot and swap.\n-                _DifferenceType __swapstart = -1;\n-                omp_set_lock(&__result_lock);\n-                for (int __r = 0; __r < __leftover_left; ++__r)\n-                  if (!__reserved_left[__r])\n-                    {\n-                      __reserved_left[__r] = true;\n-                      __swapstart = __left - (__r + 1) * __chunk_size;\n-                      break;\n-                    }\n-                omp_unset_lock(&__result_lock);\n+  /** @brief Parallel implementation of std::partition.\n+    *  @param __begin Begin iterator of input sequence to split.\n+    *  @param __end End iterator of input sequence to split.\n+    *  @param __pred Partition predicate, possibly including some kind\n+    *         of pivot.\n+    *  @param __num_threads Maximum number of threads to use for this task.\n+    *  @return Number of elements not fulfilling the predicate. */\n+  template<typename _RAIter, typename _Predicate>\n+    typename std::iterator_traits<_RAIter>::difference_type\n+    __parallel_partition(_RAIter __begin, _RAIter __end,\n+\t\t\t _Predicate __pred, _ThreadIndex __num_threads)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      _DifferenceType __n = __end - __begin;\n+\n+      _GLIBCXX_CALL(__n)\n+\n+      const _Settings& __s = _Settings::get();\n+\n+      // Shared.\n+      _GLIBCXX_VOLATILE _DifferenceType __left = 0, __right = __n - 1;\n+      _GLIBCXX_VOLATILE _DifferenceType __leftover_left, __leftover_right;\n+      _GLIBCXX_VOLATILE _DifferenceType __leftnew, __rightnew;\n+\n+      bool* __reserved_left = NULL, * __reserved_right = NULL;\n+\n+      _DifferenceType __chunk_size;\n+\n+      omp_lock_t __result_lock;\n+      omp_init_lock(&__result_lock);\n+\n+      //at least two chunks per thread\n+      if (__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n+#       pragma omp parallel num_threads(__num_threads)\n+\t{\n+#         pragma omp single\n+\t  {\n+\t    __num_threads = omp_get_num_threads();\n+\t    __reserved_left = new bool[__num_threads];\n+\t    __reserved_right = new bool[__num_threads];\n+\n+\t    if (__s.partition_chunk_share > 0.0)\n+\t      __chunk_size = std::max<_DifferenceType>\n+\t\t(__s.partition_chunk_size, (double)__n \n+\t\t * __s.partition_chunk_share / (double)__num_threads);\n+\t    else\n+\t      __chunk_size = __s.partition_chunk_size;\n+\t  }\n+\n+\t  while (__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n+\t    {\n+#             pragma omp single\n+\t      {\n+\t\t_DifferenceType __num_chunks = ((__right - __left + 1) \n+\t\t\t\t\t\t/ __chunk_size);\n+\n+\t\tfor (int __r = 0; __r < __num_threads; ++__r)\n+\t\t  {\n+\t\t    __reserved_left[__r] = false;\n+\t\t    __reserved_right[__r] = false;\n+\t\t  }\n+\t\t__leftover_left = 0;\n+\t\t__leftover_right = 0;\n+\t      } //implicit barrier\n+\n+\t      // Private.\n+\t      _DifferenceType __thread_left, __thread_left_border,\n+\t\t              __thread_right, __thread_right_border;\n+\t      __thread_left = __left + 1;\n+\n+\t      // Just to satisfy the condition below.\n+\t      __thread_left_border = __thread_left - 1;\n+\t      __thread_right = __n - 1;\n+\t      __thread_right_border = __thread_right + 1;\n+\n+\t      bool __iam_finished = false;\n+\t      while (!__iam_finished)\n+\t\t{\n+\t\t  if (__thread_left > __thread_left_border)\n+\t\t    {\n+\t\t      omp_set_lock(&__result_lock);\n+\t\t      if (__left + (__chunk_size - 1) > __right)\n+\t\t\t__iam_finished = true;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  __thread_left = __left;\n+\t\t\t  __thread_left_border = __left + (__chunk_size - 1);\n+\t\t\t  __left += __chunk_size;\n+\t\t\t}\n+\t\t      omp_unset_lock(&__result_lock);\n+\t\t    }\n+\n+\t\t  if (__thread_right < __thread_right_border)\n+\t\t    {\n+\t\t      omp_set_lock(&__result_lock);\n+\t\t      if (__left > __right - (__chunk_size - 1))\n+\t\t\t__iam_finished = true;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  __thread_right = __right;\n+\t\t\t  __thread_right_border = __right - (__chunk_size - 1);\n+\t\t\t  __right -= __chunk_size;\n+\t\t\t}\n+\t\t      omp_unset_lock(&__result_lock);\n+\t\t    }\n+\n+\t\t  if (__iam_finished)\n+\t\t    break;\n+\n+\t\t  // Swap as usual.\n+\t\t  while (__thread_left < __thread_right)\n+\t\t    {\n+\t\t      while (__pred(__begin[__thread_left])\n+\t\t\t     && __thread_left <= __thread_left_border)\n+\t\t\t++__thread_left;\n+\t\t      while (!__pred(__begin[__thread_right])\n+\t\t\t     && __thread_right >= __thread_right_border)\n+\t\t\t--__thread_right;\n+\n+\t\t      if (__thread_left > __thread_left_border\n+\t\t\t  || __thread_right < __thread_right_border)\n+\t\t\t// Fetch new chunk(__s).\n+\t\t\tbreak;\n+\n+\t\t      std::swap(__begin[__thread_left],\n+\t\t\t\t__begin[__thread_right]);\n+\t\t      ++__thread_left;\n+\t\t      --__thread_right;\n+\t\t    }\n+\t\t}\n+\n+\t      // Now swap the leftover chunks to the right places.\n+\t      if (__thread_left <= __thread_left_border)\n+#               pragma omp atomic\n+\t\t++__leftover_left;\n+\t      if (__thread_right >= __thread_right_border)\n+#               pragma omp atomic\n+\t\t++__leftover_right;\n+\n+#             pragma omp barrier\n+\n+#             pragma omp single\n+\t      {\n+\t\t__leftnew = __left - __leftover_left * __chunk_size;\n+\t\t__rightnew = __right + __leftover_right * __chunk_size;\n+\t      }\n+\n+#             pragma omp barrier\n+\n+\t      // <=> __thread_left_border + (__chunk_size - 1) >= __leftnew\n+\t      if (__thread_left <= __thread_left_border\n+\t\t  && __thread_left_border >= __leftnew)\n+\t\t{\n+\t\t  // Chunk already in place, reserve spot.\n+\t\t__reserved_left[(__left - (__thread_left_border + 1))\n+\t\t\t\t/ __chunk_size] = true;\n+\t\t}\n+\n+\t      // <=> __thread_right_border - (__chunk_size - 1) <= __rightnew\n+\t      if (__thread_right >= __thread_right_border\n+\t\t  && __thread_right_border <= __rightnew)\n+\t\t{\n+\t\t  // Chunk already in place, reserve spot.\n+\t\t  __reserved_right[((__thread_right_border - 1) - __right)\n+\t\t\t\t   / __chunk_size] = true;\n+\t\t}\n+\n+#             pragma omp barrier\n+\n+\t      if (__thread_left <= __thread_left_border\n+\t\t  && __thread_left_border < __leftnew)\n+\t\t{\n+\t\t  // Find spot and swap.\n+\t\t  _DifferenceType __swapstart = -1;\n+\t\t  omp_set_lock(&__result_lock);\n+\t\t  for (int __r = 0; __r < __leftover_left; ++__r)\n+\t\t    if (!__reserved_left[__r])\n+\t\t      {\n+\t\t\t__reserved_left[__r] = true;\n+\t\t\t__swapstart = __left - (__r + 1) * __chunk_size;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  omp_unset_lock(&__result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n-                _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n+\t\t  _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n #endif\n \n-                std::swap_ranges(__begin + __thread_left_border\n-                                 - (__chunk_size - 1),\n-                                 __begin + __thread_left_border + 1,\n-                                 __begin + __swapstart);\n-              }\n-\n-            if (__thread_right >= __thread_right_border\n-                && __thread_right_border > __rightnew)\n-              {\n-                // Find spot and swap\n-                _DifferenceType __swapstart = -1;\n-                omp_set_lock(&__result_lock);\n-                for (int __r = 0; __r < __leftover_right; ++__r)\n-                  if (!__reserved_right[__r])\n-                    {\n-                      __reserved_right[__r] = true;\n-                      __swapstart = __right + __r * __chunk_size + 1;\n-                      break;\n-                    }\n-                omp_unset_lock(&__result_lock);\n+\t\t  std::swap_ranges(__begin + __thread_left_border\n+\t\t\t\t   - (__chunk_size - 1),\n+\t\t\t\t   __begin + __thread_left_border + 1,\n+\t\t\t\t   __begin + __swapstart);\n+\t\t}\n+\n+\t      if (__thread_right >= __thread_right_border\n+\t\t  && __thread_right_border > __rightnew)\n+\t\t{\n+\t\t  // Find spot and swap\n+\t\t  _DifferenceType __swapstart = -1;\n+\t\t  omp_set_lock(&__result_lock);\n+\t\t  for (int __r = 0; __r < __leftover_right; ++__r)\n+\t\t    if (!__reserved_right[__r])\n+\t\t      {\n+\t\t\t__reserved_right[__r] = true;\n+\t\t\t__swapstart = __right + __r * __chunk_size + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  omp_unset_lock(&__result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n-                _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n+\t\t  _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n #endif\n \n-                std::swap_ranges(\n-                    __begin + __thread_right_border,\n-                    __begin + __thread_right_border + __chunk_size,\n-                    __begin + __swapstart);\n-              }\n+\t\t  std::swap_ranges(__begin + __thread_right_border,\n+\t\t\t\t   __begin + __thread_right_border\n+\t\t\t\t   + __chunk_size, __begin + __swapstart);\n+\t      }\n #if _GLIBCXX_ASSERTIONS\n #             pragma omp barrier\n \n #             pragma omp single\n-                {\n-                  for (int __r = 0; __r < __leftover_left; ++__r)\n-                    _GLIBCXX_PARALLEL_ASSERT(__reserved_left[__r]);\n-                  for (int __r = 0; __r < __leftover_right; ++__r)\n-                    _GLIBCXX_PARALLEL_ASSERT(__reserved_right[__r]);\n-                }\n+\t      {\n+\t\tfor (int __r = 0; __r < __leftover_left; ++__r)\n+\t\t  _GLIBCXX_PARALLEL_ASSERT(__reserved_left[__r]);\n+\t\tfor (int __r = 0; __r < __leftover_right; ++__r)\n+\t\t  _GLIBCXX_PARALLEL_ASSERT(__reserved_right[__r]);\n+\t      }\n \n #             pragma omp barrier\n #endif\n \n #             pragma omp barrier\n \n-              __left = __leftnew;\n-              __right = __rightnew;\n-          }\n-#         pragma omp flush(__left, __right)\n-      } // end \"recursion\" //parallel\n-\n-    _DifferenceType __final_left = __left, __final_right = __right;\n-\n-    while (__final_left < __final_right)\n-      {\n-        // Go right until key is geq than pivot.\n-        while (__pred(__begin[__final_left]) && __final_left < __final_right)\n-          ++__final_left;\n-\n-        // Go left until key is less than pivot.\n-        while (!__pred(__begin[__final_right]) && __final_left < __final_right)\n-          --__final_right;\n-\n-        if (__final_left == __final_right)\n-          break;\n-        std::swap(__begin[__final_left], __begin[__final_right]);\n-        ++__final_left;\n-        --__final_right;\n-      }\n-\n-    // All elements on the left side are < piv, all elements on the\n-    // right are >= piv\n-    delete[] __reserved_left;\n-    delete[] __reserved_right;\n-\n-    omp_destroy_lock(&__result_lock);\n-\n-    // Element \"between\" __final_left and __final_right might not have\n-    // been regarded yet\n-    if (__final_left < __n && !__pred(__begin[__final_left]))\n-      // Really swapped.\n-      return __final_left;\n-    else\n-      return __final_left + 1;\n-  }\n-\n-/**\n-  *  @brief Parallel implementation of std::nth_element().\n+\t      __left = __leftnew;\n+\t      __right = __rightnew;\n+\t    }\n+\n+#           pragma omp flush(__left, __right)\n+\t} // end \"recursion\" //parallel\n+\n+        _DifferenceType __final_left = __left, __final_right = __right;\n+\n+\twhile (__final_left < __final_right)\n+\t  {\n+\t    // Go right until key is geq than pivot.\n+\t    while (__pred(__begin[__final_left])\n+\t\t   && __final_left < __final_right)\n+\t      ++__final_left;\n+\n+\t    // Go left until key is less than pivot.\n+\t    while (!__pred(__begin[__final_right])\n+\t\t   && __final_left < __final_right)\n+\t      --__final_right;\n+\n+\t    if (__final_left == __final_right)\n+\t      break;\n+\t    std::swap(__begin[__final_left], __begin[__final_right]);\n+\t    ++__final_left;\n+\t    --__final_right;\n+\t  }\n+\n+\t// All elements on the left side are < piv, all elements on the\n+\t// right are >= piv\n+\tdelete[] __reserved_left;\n+\tdelete[] __reserved_right;\n+\n+\tomp_destroy_lock(&__result_lock);\n+\n+\t// Element \"between\" __final_left and __final_right might not have\n+\t// been regarded yet\n+\tif (__final_left < __n && !__pred(__begin[__final_left]))\n+\t  // Really swapped.\n+\t  return __final_left;\n+\telse\n+\t  return __final_left + 1;\n+    }\n+\n+  /**\n+    *  @brief Parallel implementation of std::nth_element().\n+    *  @param __begin Begin iterator of input sequence.\n+    *  @param __nth _Iterator of element that must be in position afterwards.\n+    *  @param __end End iterator of input sequence.\n+    *  @param __comp Comparator.\n+    */\n+  template<typename _RAIter, typename _Compare>\n+    void \n+    __parallel_nth_element(_RAIter __begin, _RAIter __nth, \n+\t\t\t   _RAIter __end, _Compare __comp)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      _GLIBCXX_CALL(__end - __begin)\n+\n+      _RAIter __split;\n+      _RandomNumber __rng;\n+\n+      _DifferenceType __minimum_length =\n+\tstd::max<_DifferenceType>(2, _Settings::get().partition_minimal_n);\n+\n+      // Break if input range to small.\n+      while (static_cast<_SequenceIndex>(__end - __begin) >= __minimum_length)\n+\t{\n+          _DifferenceType __n = __end - __begin;\n+\n+          _RAIter __pivot_pos = __begin +  __rng(__n);\n+\n+          // Swap __pivot_pos value to end.\n+          if (__pivot_pos != (__end - 1))\n+            std::swap(*__pivot_pos, *(__end - 1));\n+          __pivot_pos = __end - 1;\n+\n+          // _Compare must have first_value_type, second_value_type,\n+          // result_type\n+          // _Compare ==\n+          // __gnu_parallel::_Lexicographic<S, int,\n+\t  //                                __gnu_parallel::_Less<S, S> >\n+          // __pivot_pos == std::pair<S, int>*\n+          __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n+            __pred(__comp, *__pivot_pos);\n+\n+          // Divide, leave pivot unchanged in last place.\n+          _RAIter __split_pos1, __split_pos2;\n+          __split_pos1 = __begin + __parallel_partition(__begin, __end - 1,\n+\t\t\t\t\t\t\t__pred,\n+\t\t\t\t\t\t\t__get_max_threads());\n+\n+          // Left side: < __pivot_pos; __right side: >= __pivot_pos\n+\n+          // Swap pivot back to middle.\n+          if (__split_pos1 != __pivot_pos)\n+            std::swap(*__split_pos1, *__pivot_pos);\n+          __pivot_pos = __split_pos1;\n+\n+          // In case all elements are equal, __split_pos1 == 0\n+          if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n+              || (__end - __split_pos1) < (__n >> 7))\n+            {\n+              // Very unequal split, one part smaller than one 128th\n+              // elements not strictly larger than the pivot.\n+              __gnu_parallel::__unary_negate<__gnu_parallel::\n+        \t__binder1st<_Compare, _ValueType,\n+\t\t            _ValueType, bool>, _ValueType>\n+        \t__pred(__gnu_parallel::__binder1st<_Compare, _ValueType,\n+\t\t       _ValueType, bool>(__comp, *__pivot_pos));\n+\n+              // Find other end of pivot-equal range.\n+              __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n+\t\t\t\t\t\t\t __end, __pred);\n+            }\n+          else\n+            // Only skip the pivot.\n+            __split_pos2 = __split_pos1 + 1;\n+\n+          // Compare iterators.\n+          if (__split_pos2 <= __nth)\n+            __begin = __split_pos2;\n+          else if (__nth < __split_pos1)\n+            __end = __split_pos1;\n+          else\n+            break;\n+\t}\n+\n+      // Only at most _Settings::partition_minimal_n __elements __left.\n+      __gnu_sequential::sort(__begin, __end, __comp);\n+    }\n+\n+  /** @brief Parallel implementation of std::partial_sort().\n   *  @param __begin Begin iterator of input sequence.\n-  *  @param __nth _Iterator of element that must be in position afterwards.\n+  *  @param __middle Sort until this position.\n   *  @param __end End iterator of input sequence.\n-  *  @param __comp Comparator.\n-  */\n-template<typename _RAIter, typename _Compare>\n-  void \n-  __parallel_nth_element(_RAIter __begin, _RAIter __nth, \n-                       _RAIter __end, _Compare __comp)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _GLIBCXX_CALL(__end - __begin)\n-\n-    _RAIter __split;\n-    _RandomNumber __rng;\n-\n-    _DifferenceType __minimum_length =\n-      std::max<_DifferenceType>(2, _Settings::get().partition_minimal_n);\n-\n-    // Break if input range to small.\n-    while (static_cast<_SequenceIndex>(__end - __begin) >= __minimum_length)\n-      {\n-        _DifferenceType __n = __end - __begin;\n-\n-        _RAIter __pivot_pos = __begin +  __rng(__n);\n-\n-        // Swap __pivot_pos value to end.\n-        if (__pivot_pos != (__end - 1))\n-          std::swap(*__pivot_pos, *(__end - 1));\n-        __pivot_pos = __end - 1;\n-\n-        // _Compare must have first_value_type, second_value_type,\n-        // result_type\n-        // _Compare ==\n-        // __gnu_parallel::_Lexicographic<S, int, __gnu_parallel::_Less<S, S> >\n-        // __pivot_pos == std::pair<S, int>*\n-        __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n-          __pred(__comp, *__pivot_pos);\n-\n-        // Divide, leave pivot unchanged in last place.\n-        _RAIter __split_pos1, __split_pos2;\n-        __split_pos1 = __begin\n-                       + __parallel_partition(__begin, __end - 1, __pred,\n-                                              __get_max_threads());\n-\n-        // Left side: < __pivot_pos; __right side: >= __pivot_pos\n-\n-        // Swap pivot back to middle.\n-        if (__split_pos1 != __pivot_pos)\n-          std::swap(*__split_pos1, *__pivot_pos);\n-        __pivot_pos = __split_pos1;\n-\n-        // In case all elements are equal, __split_pos1 == 0\n-        if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n-            || (__end - __split_pos1) < (__n >> 7))\n-          {\n-            // Very unequal split, one part smaller than one 128th\n-            // elements not strictly larger than the pivot.\n-            __gnu_parallel::__unary_negate<__gnu_parallel::\n-              __binder1st<_Compare, _ValueType, _ValueType, bool>, _ValueType>\n-              __pred(__gnu_parallel::__binder1st<_Compare, _ValueType,\n-                   _ValueType, bool>(__comp, *__pivot_pos));\n-\n-            // Find other end of pivot-equal range.\n-            __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n-                                                     __end, __pred);\n-          }\n-        else\n-          // Only skip the pivot.\n-          __split_pos2 = __split_pos1 + 1;\n-\n-        // Compare iterators.\n-        if (__split_pos2 <= __nth)\n-          __begin = __split_pos2;\n-        else if (__nth < __split_pos1)\n-          __end = __split_pos1;\n-        else\n-          break;\n-      }\n-\n-    // Only at most _Settings::partition_minimal_n __elements __left.\n-    __gnu_sequential::sort(__begin, __end, __comp);\n-  }\n-\n-/** @brief Parallel implementation of std::partial_sort().\n-*  @param __begin Begin iterator of input sequence.\n-*  @param __middle Sort until this position.\n-*  @param __end End iterator of input sequence.\n-*  @param __comp Comparator. */\n-template<typename _RAIter, typename _Compare>\n-  void\n-  __parallel_partial_sort(_RAIter __begin,\n-                        _RAIter __middle,\n-                        _RAIter __end, _Compare __comp)\n-  {\n-    __parallel_nth_element(__begin, __middle, __end, __comp);\n-    std::sort(__begin, __middle, __comp);\n-  }\n+  *  @param __comp Comparator. */\n+  template<typename _RAIter, typename _Compare>\n+    void\n+    __parallel_partial_sort(_RAIter __begin,\n+\t\t\t    _RAIter __middle,\n+\t\t\t    _RAIter __end, _Compare __comp)\n+    {\n+      __parallel_nth_element(__begin, __middle, __end, __comp);\n+      std::sort(__begin, __middle, __comp);\n+    }\n \n } //namespace __gnu_parallel\n "}, {"sha": "ff5deb09383ab0a9312757d21b91490c9aeca806", "filename": "libstdc++-v3/include/parallel/queue.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -65,10 +65,10 @@ namespace __gnu_parallel\n     public:\n       /** @brief Constructor. Not to be called concurrent, of course.\n        *  @param _M_max_size Maximal number of elements to be contained. */\n-      _RestrictedBoundedConcurrentQueue(_SequenceIndex _M_max_size)\n+      _RestrictedBoundedConcurrentQueue(_SequenceIndex __max_size)\n       {\n-        this->_M_max_size = _M_max_size;\n-        _M_base = new _Tp[_M_max_size];\n+        _M_max_size = __max_size;\n+        _M_base = new _Tp[__max_size];\n         _M_borders = __encode2(0, 0);\n #pragma omp flush\n       }\n@@ -105,12 +105,12 @@ namespace __gnu_parallel\n         while (__former_front > __former_back)\n           {\n             // Chance.\n-            _CASable\n-                __former_borders = __encode2(__former_front, __former_back);\n-            _CASable\n-                __new_borders = __encode2(__former_front - 1, __former_back);\n-            if (__compare_and_swap(\n-                  &_M_borders, __former_borders, __new_borders))\n+            _CASable __former_borders = __encode2(__former_front,\n+\t\t\t\t\t\t  __former_back);\n+            _CASable __new_borders = __encode2(__former_front - 1,\n+\t\t\t\t\t       __former_back);\n+            if (__compare_and_swap(&_M_borders, __former_borders,\n+\t\t\t\t   __new_borders))\n               {\n                 __t = *(_M_base + (__former_front - 1) % _M_max_size);\n                 return true;\n@@ -132,12 +132,12 @@ namespace __gnu_parallel\n         while (__former_front > __former_back)\n           {\n             // Chance.\n-            _CASable\n-              __former_borders = __encode2(__former_front, __former_back);\n-            _CASable\n-              __new_borders = __encode2(__former_front, __former_back + 1);\n-            if (__compare_and_swap(\n-                  &_M_borders, __former_borders, __new_borders))\n+            _CASable __former_borders = __encode2(__former_front,\n+\t\t\t\t\t\t  __former_back);\n+            _CASable __new_borders = __encode2(__former_front,\n+\t\t\t\t\t       __former_back + 1);\n+            if (__compare_and_swap(&_M_borders, __former_borders,\n+\t\t\t\t   __new_borders))\n               {\n                 __t = *(_M_base + __former_back % _M_max_size);\n                 return true;"}, {"sha": "508c3c1763ceaa99d26f52c89b208867d4132826", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -48,13 +48,12 @@ namespace __gnu_parallel\n    */\n   template<typename _RAIter, typename _Compare>\n     typename std::iterator_traits<_RAIter>::difference_type\n-    __parallel_sort_qs_divide(_RAIter __begin,\n-                            _RAIter __end,\n-                            _Compare __comp, typename std::iterator_traits\n-                            <_RAIter>::difference_type __pivot_rank,\n-                            typename std::iterator_traits\n-                            <_RAIter>::difference_type\n-                            __num_samples, _ThreadIndex __num_threads)\n+    __parallel_sort_qs_divide(_RAIter __begin, _RAIter __end,\n+\t\t\t      _Compare __comp, typename std::iterator_traits\n+\t\t\t      <_RAIter>::difference_type __pivot_rank,\n+\t\t\t      typename std::iterator_traits\n+\t\t\t      <_RAIter>::difference_type\n+\t\t\t      __num_samples, _ThreadIndex __num_threads)\n     {\n       typedef std::iterator_traits<_RAIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n@@ -64,25 +63,24 @@ namespace __gnu_parallel\n       __num_samples = std::min(__num_samples, __n);\n \n       // Allocate uninitialized, to avoid default constructor.\n-      _ValueType* __samples =\n-        static_cast<_ValueType*>(::operator new(__num_samples\n-                                                * sizeof(_ValueType)));\n+      _ValueType* __samples = static_cast<_ValueType*>\n+\t(::operator new(__num_samples * sizeof(_ValueType)));\n \n       for (_DifferenceType __s = 0; __s < __num_samples; ++__s)\n         {\n-          const unsigned long long __index\n-            = static_cast<unsigned long long>(__s) * __n / __num_samples;\n+          const unsigned long long __index = static_cast<unsigned long long>\n+\t    (__s) * __n / __num_samples;\n           ::new(&(__samples[__s])) _ValueType(__begin[__index]);\n         }\n \n       __gnu_sequential::sort(__samples, __samples + __num_samples, __comp);\n \n-      _ValueType& pivot = __samples[__pivot_rank * __num_samples / __n];\n+      _ValueType& __pivot = __samples[__pivot_rank * __num_samples / __n];\n \n       __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n-        __pred(__comp, pivot);\n-      _DifferenceType __split =\n-          __parallel_partition(__begin, __end, __pred, __num_threads);\n+        __pred(__comp, __pivot);\n+      _DifferenceType __split = __parallel_partition(__begin, __end,\n+\t\t\t\t\t\t     __pred, __num_threads);\n \n       ::operator delete(__samples);\n \n@@ -98,10 +96,9 @@ namespace __gnu_parallel\n    */\n   template<typename _RAIter, typename _Compare>\n     void\n-    __parallel_sort_qs_conquer(_RAIter __begin,\n-                             _RAIter __end,\n-                             _Compare __comp,\n-                             _ThreadIndex __num_threads)\n+    __parallel_sort_qs_conquer(_RAIter __begin, _RAIter __end,\n+\t\t\t       _Compare __comp,\n+\t\t\t       _ThreadIndex __num_threads)\n     {\n       typedef std::iterator_traits<_RAIter> _TraitsType;\n       typedef typename _TraitsType::value_type _ValueType;\n@@ -127,24 +124,22 @@ namespace __gnu_parallel\n \n       __pivot_rank = __n * __num_threads_left / __num_threads;\n \n-      _DifferenceType __split =\n-        __parallel_sort_qs_divide(__begin, __end, __comp, __pivot_rank,\n-                                _Settings::get().sort_qs_num_samples_preset,\n-                                __num_threads);\n+      _DifferenceType __split = __parallel_sort_qs_divide\n+\t(__begin, __end, __comp, __pivot_rank,\n+\t _Settings::get().sort_qs_num_samples_preset, __num_threads);\n \n #pragma omp parallel sections num_threads(2)\n       {\n #pragma omp section\n         __parallel_sort_qs_conquer(__begin, __begin + __split,\n-                                 __comp, __num_threads_left);\n+\t\t\t\t   __comp, __num_threads_left);\n #pragma omp section\n         __parallel_sort_qs_conquer(__begin + __split, __end,\n-                                 __comp, __num_threads - __num_threads_left);\n+\t\t\t\t   __comp, __num_threads - __num_threads_left);\n       }\n     }\n \n \n-\n   /** @brief Unbalanced quicksort main call.\n    *  @param __begin Begin iterator of input sequence.\n    *  @param __end End iterator input sequence, ignored.\n@@ -154,10 +149,9 @@ namespace __gnu_parallel\n    */\n   template<typename _RAIter, typename _Compare>\n     void\n-    __parallel_sort_qs(_RAIter __begin,\n-                     _RAIter __end,\n-                     _Compare __comp,\n-                     _ThreadIndex __num_threads)\n+    __parallel_sort_qs(_RAIter __begin, _RAIter __end,\n+\t\t       _Compare __comp,\n+\t\t       _ThreadIndex __num_threads)\n     {\n       _GLIBCXX_CALL(__n)\n "}, {"sha": "137414f20f9fad14f68bafa8158cdbf511c4c603", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 418, "deletions": 426, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -39,492 +39,484 @@\n \n namespace __gnu_parallel\n {\n-/** @brief Type to hold the index of a bin.\n-  *\n-  *  Since many variables of this type are allocated, it should be\n-  *  chosen as small as possible.\n-  */\n-typedef unsigned short _BinIndex;\n-\n-/** @brief Data known to every thread participating in\n-    __gnu_parallel::__parallel_random_shuffle(). */\n-template<typename _RAIter>\n-  struct _DRandomShufflingGlobalData\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    /** @brief Begin iterator of the __source. */\n-    _RAIter& _M_source;\n-\n-    /** @brief Temporary arrays for each thread. */\n-    _ValueType** _M_temporaries;\n-\n-    /** @brief Two-dimensional array to hold the thread-bin distribution.\n-     *\n-     *  Dimensions (_M_num_threads + 1) __x (_M_num_bins + 1). */\n-    _DifferenceType** _M_dist;\n-\n-    /** @brief Start indexes of the threads' __chunks. */\n-    _DifferenceType* _M_starts;\n-\n-    /** @brief Number of the thread that will further process the\n-        corresponding bin. */\n-    _ThreadIndex* _M_bin_proc;\n-\n-    /** @brief Number of bins to distribute to. */\n-    int _M_num_bins;\n-\n-    /** @brief Number of bits needed to address the bins. */\n-    int _M_num_bits;\n-\n-    /** @brief Constructor. */\n-    _DRandomShufflingGlobalData(_RAIter& __source)\n-    : _M_source(__source) { }\n-  };\n-\n-/** @brief Local data for a thread participating in\n-    __gnu_parallel::__parallel_random_shuffle().\n-  */\n-template<typename _RAIter, typename _RandomNumberGenerator>\n-  struct _DRSSorterPU\n-  {\n-    /** @brief Number of threads participating in total. */\n-    int _M_num_threads;\n-\n-    /** @brief Begin index for bins taken care of by this thread. */\n-    _BinIndex _M_bins_begin;\n-\n-    /** @brief End index for bins taken care of by this thread. */\n-    _BinIndex __bins_end;\n-\n-    /** @brief Random _M_seed for this thread. */\n-    uint32_t _M_seed;\n-\n-    /** @brief Pointer to global data. */\n-    _DRandomShufflingGlobalData<_RAIter>* _M_sd;\n-  };\n-\n-/** @brief Generate a random number in @__c [0,2^logp).\n-  *  @param logp Logarithm (basis 2) of the upper range __bound.\n-  *  @param __rng Random number generator to use.\n-  */\n-template<typename _RandomNumberGenerator>\n-  inline int\n-  __random_number_pow2(int logp, _RandomNumberGenerator& __rng)\n-  { return __rng.__genrand_bits(logp); }\n-\n-/** @brief Random shuffle code executed by each thread.\n-  *  @param __pus Array of thread-local data records. */\n-template<typename _RAIter, typename _RandomNumberGenerator>\n-  void \n-  __parallel_random_shuffle_drs_pu(_DRSSorterPU<_RAIter,\n-                                 _RandomNumberGenerator>* __pus)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _ThreadIndex __iam = omp_get_thread_num();\n-    _DRSSorterPU<_RAIter, _RandomNumberGenerator>* d = &__pus[__iam];\n-    _DRandomShufflingGlobalData<_RAIter>* _M_sd = d->_M_sd;\n-\n-    // Indexing: _M_dist[bin][processor]\n-    _DifferenceType __length = _M_sd->_M_starts[__iam + 1] -\n-                               _M_sd->_M_starts[__iam];\n-    _BinIndex* __oracles = new _BinIndex[__length];\n-    _DifferenceType* _M_dist = new _DifferenceType[_M_sd->_M_num_bins + 1];\n-    _BinIndex* _M_bin_proc = new _BinIndex[_M_sd->_M_num_bins];\n-    _ValueType** _M_temporaries = new _ValueType*[d->_M_num_threads];\n-\n-    // Compute oracles and count appearances.\n-    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n-      _M_dist[__b] = 0;\n-    int _M_num_bits = _M_sd->_M_num_bits;\n-\n-    _RandomNumber __rng(d->_M_seed);\n-\n-    // First main loop.\n-    for (_DifferenceType __i = 0; __i < __length; ++__i)\n-      {\n-        _BinIndex __oracle = __random_number_pow2(_M_num_bits, __rng);\n-        __oracles[__i] = __oracle;\n+  /** @brief Type to hold the index of a bin.\n+    *\n+    *  Since many variables of this type are allocated, it should be\n+    *  chosen as small as possible.\n+    */\n+  typedef unsigned short _BinIndex;\n+\n+  /** @brief Data known to every thread participating in\n+      __gnu_parallel::__parallel_random_shuffle(). */\n+  template<typename _RAIter>\n+    struct _DRandomShufflingGlobalData\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-        // To allow prefix (partial) sum.\n-        ++(_M_dist[__oracle + 1]);\n-      }\n+      /** @brief Begin iterator of the __source. */\n+      _RAIter& _M_source;\n \n-    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n-      _M_sd->_M_dist[__b][__iam + 1] = _M_dist[__b];\n+      /** @brief Temporary arrays for each thread. */\n+      _ValueType** _M_temporaries;\n \n-#   pragma omp barrier\n+      /** @brief Two-dimensional array to hold the thread-bin distribution.\n+       *\n+       *  Dimensions (_M_num_threads + 1) __x (_M_num_bins + 1). */\n+      _DifferenceType** _M_dist;\n \n-#   pragma omp single\n-    {\n-      // Sum up bins, _M_sd->_M_dist[__s + 1][d->_M_num_threads] now contains\n-      // the total number of items in bin __s\n-      for (_BinIndex __s = 0; __s < _M_sd->_M_num_bins; ++__s)\n-        __gnu_sequential::partial_sum(\n-          _M_sd->_M_dist[__s + 1],\n-          _M_sd->_M_dist[__s + 1] + d->_M_num_threads + 1,\n-          _M_sd->_M_dist[__s + 1]);\n-    }\n+      /** @brief Start indexes of the threads' __chunks. */\n+      _DifferenceType* _M_starts;\n \n-#   pragma omp barrier\n+      /** @brief Number of the thread that will further process the\n+          corresponding bin. */\n+      _ThreadIndex* _M_bin_proc;\n \n-    _SequenceIndex __offset = 0, __global_offset = 0;\n-    for (_BinIndex __s = 0; __s < d->_M_bins_begin; ++__s)\n-      __global_offset += _M_sd->_M_dist[__s + 1][d->_M_num_threads];\n+      /** @brief Number of bins to distribute to. */\n+      int _M_num_bins;\n \n-#   pragma omp barrier\n+      /** @brief Number of bits needed to address the bins. */\n+      int _M_num_bits;\n \n-    for (_BinIndex __s = d->_M_bins_begin; __s < d->__bins_end; ++__s)\n-      {\n-        for (int __t = 0; __t < d->_M_num_threads + 1; ++__t)\n-          _M_sd->_M_dist[__s + 1][__t] += __offset;\n-        __offset = _M_sd->_M_dist[__s + 1][d->_M_num_threads];\n-      }\n+      /** @brief Constructor. */\n+      _DRandomShufflingGlobalData(_RAIter& __source)\n+      : _M_source(__source) { }\n+    };\n+\n+  /** @brief Local data for a thread participating in\n+      __gnu_parallel::__parallel_random_shuffle().\n+    */\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    struct _DRSSorterPU\n+    {\n+      /** @brief Number of threads participating in total. */\n+      int _M_num_threads;\n+\n+      /** @brief Begin index for bins taken care of by this thread. */\n+      _BinIndex _M_bins_begin;\n+\n+      /** @brief End index for bins taken care of by this thread. */\n+      _BinIndex __bins_end;\n+\n+      /** @brief Random _M_seed for this thread. */\n+      uint32_t _M_seed;\n+\n+      /** @brief Pointer to global data. */\n+      _DRandomShufflingGlobalData<_RAIter>* _M_sd;\n+    };\n+\n+  /** @brief Generate a random number in @__c [0,2^__logp).\n+    *  @param __logp Logarithm (basis 2) of the upper range __bound.\n+    *  @param __rng Random number generator to use.\n+    */\n+  template<typename _RandomNumberGenerator>\n+    inline int\n+    __random_number_pow2(int __logp, _RandomNumberGenerator& __rng)\n+    { return __rng.__genrand_bits(__logp); }\n+\n+  /** @brief Random shuffle code executed by each thread.\n+    *  @param __pus Array of thread-local data records. */\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    void \n+    __parallel_random_shuffle_drs_pu(_DRSSorterPU<_RAIter,\n+\t\t\t\t     _RandomNumberGenerator>* __pus)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _M_sd->_M_temporaries[__iam] = static_cast<_ValueType*>(\n-      ::operator new(sizeof(_ValueType) * __offset));\n+      _ThreadIndex __iam = omp_get_thread_num();\n+      _DRSSorterPU<_RAIter, _RandomNumberGenerator>* __d = &__pus[__iam];\n+      _DRandomShufflingGlobalData<_RAIter>* __sd = __d->_M_sd;\n \n-#   pragma omp barrier\n+      // Indexing: _M_dist[bin][processor]\n+      _DifferenceType __length = (__sd->_M_starts[__iam + 1]\n+\t\t\t\t  - __sd->_M_starts[__iam]);\n+      _BinIndex* __oracles = new _BinIndex[__length];\n+      _DifferenceType* __dist = new _DifferenceType[__sd->_M_num_bins + 1];\n+      _BinIndex* __bin_proc = new _BinIndex[__sd->_M_num_bins];\n+      _ValueType** __temporaries = new _ValueType*[__d->_M_num_threads];\n \n-    // Draw local copies to avoid false sharing.\n-    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n-      _M_dist[__b] = _M_sd->_M_dist[__b][__iam];\n-    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins; ++__b)\n-      _M_bin_proc[__b] = _M_sd->_M_bin_proc[__b];\n-    for (_ThreadIndex __t = 0; __t < d->_M_num_threads; ++__t)\n-      _M_temporaries[__t] = _M_sd->_M_temporaries[__t];\n+      // Compute oracles and count appearances.\n+      for (_BinIndex __b = 0; __b < __sd->_M_num_bins + 1; ++__b)\n+\t__dist[__b] = 0;\n+      int __num_bits = __sd->_M_num_bits;\n \n-    _RAIter _M_source = _M_sd->_M_source;\n-    _DifferenceType __start = _M_sd->_M_starts[__iam];\n+      _RandomNumber __rng(__d->_M_seed);\n \n-    // Distribute according to oracles, second main loop.\n-    for (_DifferenceType __i = 0; __i < __length; ++__i)\n-      {\n-        _BinIndex target_bin = __oracles[__i];\n-        _ThreadIndex target_p = _M_bin_proc[target_bin];\n+      // First main loop.\n+      for (_DifferenceType __i = 0; __i < __length; ++__i)\n+\t{\n+          _BinIndex __oracle = __random_number_pow2(__num_bits, __rng);\n+          __oracles[__i] = __oracle;\n \n-        // Last column [d->_M_num_threads] stays unchanged.\n-        ::new(&(_M_temporaries[target_p][_M_dist[target_bin + 1]++]))\n-            _ValueType(*(_M_source + __i + __start));\n-      }\n+          // To allow prefix (partial) sum.\n+          ++(__dist[__oracle + 1]);\n+\t}\n \n-    delete[] __oracles;\n-    delete[] _M_dist;\n-    delete[] _M_bin_proc;\n-    delete[] _M_temporaries;\n+      for (_BinIndex __b = 0; __b < __sd->_M_num_bins + 1; ++__b)\n+\t__sd->_M_dist[__b][__iam + 1] = __dist[__b];\n \n-#   pragma omp barrier\n+#     pragma omp barrier\n \n-    // Shuffle bins internally.\n-    for (_BinIndex __b = d->_M_bins_begin; __b < d->__bins_end; ++__b)\n+#     pragma omp single\n       {\n-        _ValueType* __begin =\n-                    _M_sd->_M_temporaries[__iam] +\n-                    ((__b == d->_M_bins_begin)\n-                      ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]),\n-                  * __end =\n-                    _M_sd->_M_temporaries[__iam] +\n-                      _M_sd->_M_dist[__b + 1][d->_M_num_threads];\n-        __sequential_random_shuffle(__begin, __end, __rng);\n-        std::copy(__begin, __end, _M_sd->_M_source + __global_offset +\n-                  ((__b == d->_M_bins_begin)\n-                  ? 0 : _M_sd->_M_dist[__b][d->_M_num_threads]));\n+\t// Sum up bins, __sd->_M_dist[__s + 1][__d->_M_num_threads] now\n+\t// contains the total number of items in bin __s\n+\tfor (_BinIndex __s = 0; __s < __sd->_M_num_bins; ++__s)\n+          __gnu_sequential::partial_sum(__sd->_M_dist[__s + 1],\n+\t\t\t\t\t__sd->_M_dist[__s + 1]\n+\t\t\t\t\t+ __d->_M_num_threads + 1,\n+\t\t\t\t\t__sd->_M_dist[__s + 1]);\n       }\n \n-    ::operator delete(_M_sd->_M_temporaries[__iam]);\n-  }\n-\n-/** @brief Round up to the next greater power of 2.\n-  *  @param __x _Integer to round up */\n-template<typename _Tp>\n-  _Tp \n-  __round_up_to_pow2(_Tp __x)\n-  {\n-    if (__x <= 1)\n-      return 1;\n-    else\n-      return (_Tp)1 << (__rd_log2(__x - 1) + 1);\n-  }\n-\n-/** @brief Main parallel random shuffle step.\n-  *  @param __begin Begin iterator of sequence.\n-  *  @param __end End iterator of sequence.\n-  *  @param __n Length of sequence.\n-  *  @param __num_threads Number of threads to use.\n-  *  @param __rng Random number generator to use.\n-  */\n-template<typename _RAIter, typename _RandomNumberGenerator>\n-  void\n-  __parallel_random_shuffle_drs(_RAIter __begin,\n-                              _RAIter __end,\n-                              typename std::iterator_traits\n-                              <_RAIter>::difference_type __n,\n-                              _ThreadIndex __num_threads,\n-                              _RandomNumberGenerator& __rng)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _GLIBCXX_CALL(__n)\n-\n-    const _Settings& __s = _Settings::get();\n-\n-    if (__num_threads > __n)\n-      __num_threads = static_cast<_ThreadIndex>(__n);\n-\n-    _BinIndex _M_num_bins, __num_bins_cache;\n+#     pragma omp barrier\n+\n+      _SequenceIndex __offset = 0, __global_offset = 0;\n+      for (_BinIndex __s = 0; __s < __d->_M_bins_begin; ++__s)\n+\t__global_offset += __sd->_M_dist[__s + 1][__d->_M_num_threads];\n+\n+#     pragma omp barrier\n+\n+      for (_BinIndex __s = __d->_M_bins_begin; __s < __d->__bins_end; ++__s)\n+\t{\n+          for (int __t = 0; __t < __d->_M_num_threads + 1; ++__t)\n+            __sd->_M_dist[__s + 1][__t] += __offset;\n+          __offset = __sd->_M_dist[__s + 1][__d->_M_num_threads];\n+\t}\n+\n+      __sd->_M_temporaries[__iam] = static_cast<_ValueType*>\n+\t(::operator new(sizeof(_ValueType) * __offset));\n+\n+#     pragma omp barrier\n+\n+      // Draw local copies to avoid false sharing.\n+      for (_BinIndex __b = 0; __b < __sd->_M_num_bins + 1; ++__b)\n+\t__dist[__b] = __sd->_M_dist[__b][__iam];\n+      for (_BinIndex __b = 0; __b < __sd->_M_num_bins; ++__b)\n+\t__bin_proc[__b] = __sd->_M_bin_proc[__b];\n+      for (_ThreadIndex __t = 0; __t < __d->_M_num_threads; ++__t)\n+\t__temporaries[__t] = __sd->_M_temporaries[__t];\n+\n+      _RAIter __source = __sd->_M_source;\n+      _DifferenceType __start = __sd->_M_starts[__iam];\n+\n+      // Distribute according to oracles, second main loop.\n+      for (_DifferenceType __i = 0; __i < __length; ++__i)\n+\t{\n+          _BinIndex __target_bin = __oracles[__i];\n+          _ThreadIndex __target_p = __bin_proc[__target_bin];\n+\n+          // Last column [__d->_M_num_threads] stays unchanged.\n+          ::new(&(__temporaries[__target_p][__dist[__target_bin + 1]++]))\n+              _ValueType(*(__source + __i + __start));\n+\t}\n+\n+      delete[] __oracles;\n+      delete[] __dist;\n+      delete[] __bin_proc;\n+      delete[] __temporaries;\n+\n+#     pragma omp barrier\n+\n+      // Shuffle bins internally.\n+      for (_BinIndex __b = __d->_M_bins_begin; __b < __d->__bins_end; ++__b)\n+\t{\n+          _ValueType* __begin =\n+\t    (__sd->_M_temporaries[__iam]\n+\t     + (__b == __d->_M_bins_begin\n+\t\t? 0 : __sd->_M_dist[__b][__d->_M_num_threads])),\n+\t  * __end = (__sd->_M_temporaries[__iam]\n+\t\t     + __sd->_M_dist[__b + 1][__d->_M_num_threads]);\n+\n+          __sequential_random_shuffle(__begin, __end, __rng);\n+          std::copy(__begin, __end, __sd->_M_source + __global_offset\n+\t\t    + (__b == __d->_M_bins_begin\n+\t\t       ? 0 : __sd->_M_dist[__b][__d->_M_num_threads]));\n+\t}\n+\n+      ::operator delete(__sd->_M_temporaries[__iam]);\n+    }\n+\n+  /** @brief Round up to the next greater power of 2.\n+    *  @param __x _Integer to round up */\n+  template<typename _Tp>\n+    _Tp \n+    __round_up_to_pow2(_Tp __x)\n+    {\n+      if (__x <= 1)\n+\treturn 1;\n+      else\n+\treturn (_Tp)1 << (__rd_log2(__x - 1) + 1);\n+    }\n+\n+  /** @brief Main parallel random shuffle step.\n+    *  @param __begin Begin iterator of sequence.\n+    *  @param __end End iterator of sequence.\n+    *  @param __n Length of sequence.\n+    *  @param __num_threads Number of threads to use.\n+    *  @param __rng Random number generator to use.\n+    */\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    void\n+    __parallel_random_shuffle_drs(_RAIter __begin, _RAIter __end,\n+\t\t\t\t  typename std::iterator_traits\n+\t\t\t\t  <_RAIter>::difference_type __n,\n+\t\t\t\t  _ThreadIndex __num_threads,\n+\t\t\t\t  _RandomNumberGenerator& __rng)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      _GLIBCXX_CALL(__n)\n+\n+      const _Settings& __s = _Settings::get();\n+\n+      if (__num_threads > __n)\n+\t__num_threads = static_cast<_ThreadIndex>(__n);\n+\n+      _BinIndex __num_bins, __num_bins_cache;\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n-    // Try the L1 cache first.\n+      // Try the L1 cache first.\n \n-    // Must fit into L1.\n-    __num_bins_cache = std::max<_DifferenceType>(\n-        1, __n / (__s.L1_cache_size_lb / sizeof(_ValueType)));\n-    __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n+      // Must fit into L1.\n+      __num_bins_cache =\n+\tstd::max<_DifferenceType>(1, __n / (__s.L1_cache_size_lb\n+\t\t\t\t\t    / sizeof(_ValueType)));\n+      __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n \n-    // No more buckets than TLB entries, power of 2\n-    // Power of 2 and at least one element per bin, at most the TLB size.\n-    _M_num_bins = std::min<_DifferenceType>(__n, __num_bins_cache);\n+      // No more buckets than TLB entries, power of 2\n+      // Power of 2 and at least one element per bin, at most the TLB size.\n+      __num_bins = std::min<_DifferenceType>(__n, __num_bins_cache);\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n-    // 2 TLB entries needed per bin.\n-    _M_num_bins = std::min<_DifferenceType>(__s.TLB_size / 2, _M_num_bins);\n+      // 2 TLB entries needed per bin.\n+      __num_bins = std::min<_DifferenceType>(__s.TLB_size / 2, __num_bins);\n #endif\n-    _M_num_bins = __round_up_to_pow2(_M_num_bins);\n+      __num_bins = __round_up_to_pow2(__num_bins);\n \n-    if (_M_num_bins < __num_bins_cache)\n-      {\n+      if (__num_bins < __num_bins_cache)\n+\t{\n #endif\n-        // Now try the L2 cache\n-        // Must fit into L2\n-        __num_bins_cache = static_cast<_BinIndex>(std::max<_DifferenceType>(\n-            1, __n / (__s.L2_cache_size / sizeof(_ValueType))));\n-        __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n-\n-        // No more buckets than TLB entries, power of 2.\n-        _M_num_bins = static_cast<_BinIndex>(\n-            std::min(__n, static_cast<_DifferenceType>(__num_bins_cache)));\n-        // Power of 2 and at least one element per bin, at most the TLB size.\n+          // Now try the L2 cache\n+          // Must fit into L2\n+          __num_bins_cache = static_cast<_BinIndex>\n+\t    (std::max<_DifferenceType>(1, __n / (__s.L2_cache_size\n+\t\t\t\t\t\t / sizeof(_ValueType))));\n+          __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n+\n+          // No more buckets than TLB entries, power of 2.\n+          __num_bins = static_cast<_BinIndex>\n+\t    (std::min(__n, static_cast<_DifferenceType>(__num_bins_cache)));\n+          // Power of 2 and at least one element per bin, at most the TLB size.\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n-        // 2 TLB entries needed per bin.\n-        _M_num_bins = std::min(\n-            static_cast<_DifferenceType>(__s.TLB_size / 2), _M_num_bins);\n+          // 2 TLB entries needed per bin.\n+          __num_bins = std::min(static_cast<_DifferenceType>(__s.TLB_size / 2),\n+\t\t\t\t__num_bins);\n #endif\n-          _M_num_bins = __round_up_to_pow2(_M_num_bins);\n+            __num_bins = __round_up_to_pow2(__num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n-      }\n+\t}\n #endif\n \n-    __num_threads = std::min<_BinIndex>(__num_threads, _M_num_bins);\n+      __num_threads = std::min<_BinIndex>(__num_threads, __num_bins);\n \n-    if (__num_threads <= 1)\n-      return __sequential_random_shuffle(__begin, __end, __rng);\n+      if (__num_threads <= 1)\n+\treturn __sequential_random_shuffle(__begin, __end, __rng);\n \n-    _DRandomShufflingGlobalData<_RAIter> _M_sd(__begin);\n-    _DRSSorterPU<_RAIter, _RandomNumber >* __pus;\n-    _DifferenceType* _M_starts;\n+      _DRandomShufflingGlobalData<_RAIter> __sd(__begin);\n+      _DRSSorterPU<_RAIter, _RandomNumber >* __pus;\n+      _DifferenceType* __starts;\n \n-#   pragma omp parallel num_threads(__num_threads)\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n-        _ThreadIndex __num_threads = omp_get_num_threads();\n+\t_ThreadIndex __num_threads = omp_get_num_threads();\n #       pragma omp single\n-          {\n-            __pus = new _DRSSorterPU<_RAIter, _RandomNumber>\n-                [__num_threads];\n-\n-            _M_sd._M_temporaries = new _ValueType*[__num_threads];\n-            _M_sd._M_dist = new _DifferenceType*[_M_num_bins + 1];\n-            _M_sd._M_bin_proc = new _ThreadIndex[_M_num_bins];\n-            for (_BinIndex __b = 0; __b < _M_num_bins + 1; ++__b)\n-              _M_sd._M_dist[__b] = new _DifferenceType[__num_threads + 1];\n-            for (_BinIndex __b = 0; __b < (_M_num_bins + 1); ++__b)\n-              {\n-                _M_sd._M_dist[0][0] = 0;\n-                _M_sd._M_dist[__b][0] = 0;\n-              }\n-            _M_starts = _M_sd._M_starts\n-              = new _DifferenceType[__num_threads + 1];\n-            int bin_cursor = 0;\n-            _M_sd._M_num_bins = _M_num_bins;\n-            _M_sd._M_num_bits = __rd_log2(_M_num_bins);\n-\n-            _DifferenceType __chunk_length = __n / __num_threads,\n-                            __split = __n % __num_threads, __start = 0;\n-            _DifferenceType bin_chunk_length = _M_num_bins / __num_threads,\n-                            bin_split = _M_num_bins % __num_threads;\n-            for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n-              {\n-                _M_starts[__i] = __start;\n-                __start += (__i < __split)\n-                           ? (__chunk_length + 1) : __chunk_length;\n-                int __j = __pus[__i]._M_bins_begin = bin_cursor;\n-\n-                // Range of bins for this processor.\n-                bin_cursor += (__i < bin_split) ?\n-                    (bin_chunk_length + 1) : bin_chunk_length;\n-                __pus[__i].__bins_end = bin_cursor;\n-                for (; __j < bin_cursor; ++__j)\n-                  _M_sd._M_bin_proc[__j] = __i;\n-                __pus[__i]._M_num_threads = __num_threads;\n-                __pus[__i]._M_seed =\n-                        __rng(std::numeric_limits<uint32_t>::max());\n-                __pus[__i]._M_sd = &_M_sd;\n-              }\n-            _M_starts[__num_threads] = __start;\n-          } //single\n-        // Now shuffle in parallel.\n-        __parallel_random_shuffle_drs_pu(__pus);\n+\t{\n+\t  __pus = new _DRSSorterPU<_RAIter, _RandomNumber>[__num_threads];\n+\t  \n+\t  __sd._M_temporaries = new _ValueType*[__num_threads];\n+\t  __sd._M_dist = new _DifferenceType*[__num_bins + 1];\n+\t  __sd._M_bin_proc = new _ThreadIndex[__num_bins];\n+\t  for (_BinIndex __b = 0; __b < __num_bins + 1; ++__b)\n+\t    __sd._M_dist[__b] = new _DifferenceType[__num_threads + 1];\n+\t  for (_BinIndex __b = 0; __b < (__num_bins + 1); ++__b)\n+\t    {\n+\t      __sd._M_dist[0][0] = 0;\n+\t      __sd._M_dist[__b][0] = 0;\n+\t    }\n+\t  __starts = __sd._M_starts = new _DifferenceType[__num_threads + 1];\n+\t  int __bin_cursor = 0;\n+\t  __sd._M_num_bins = __num_bins;\n+\t  __sd._M_num_bits = __rd_log2(__num_bins);\n+\n+\t  _DifferenceType __chunk_length = __n / __num_threads,\n+\t                         __split = __n % __num_threads,\n+\t                         __start = 0;\n+\t  _DifferenceType __bin_chunk_length = __num_bins / __num_threads,\n+\t                         __bin_split = __num_bins % __num_threads;\n+\t  for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+\t    {\n+\t      __starts[__i] = __start;\n+\t      __start += (__i < __split\n+\t\t\t  ? (__chunk_length + 1) : __chunk_length);\n+\t      int __j = __pus[__i]._M_bins_begin = __bin_cursor;\n+\n+\t      // Range of bins for this processor.\n+\t      __bin_cursor += (__i < __bin_split\n+\t\t\t       ? (__bin_chunk_length + 1)\n+\t\t\t       : __bin_chunk_length);\n+\t      __pus[__i].__bins_end = __bin_cursor;\n+\t      for (; __j < __bin_cursor; ++__j)\n+\t\t__sd._M_bin_proc[__j] = __i;\n+\t      __pus[__i]._M_num_threads = __num_threads;\n+\t      __pus[__i]._M_seed = __rng(std::numeric_limits<uint32_t>::max());\n+\t      __pus[__i]._M_sd = &__sd;\n+\t    }\n+\t  __starts[__num_threads] = __start;\n+\t} //single\n+          // Now shuffle in parallel.\n+\t__parallel_random_shuffle_drs_pu(__pus);\n       }  // parallel\n \n-    delete[] _M_starts;\n-    delete[] _M_sd._M_bin_proc;\n-    for (int __s = 0; __s < (_M_num_bins + 1); ++__s)\n-      delete[] _M_sd._M_dist[__s];\n-    delete[] _M_sd._M_dist;\n-    delete[] _M_sd._M_temporaries;\n+      delete[] __starts;\n+      delete[] __sd._M_bin_proc;\n+      for (int __s = 0; __s < (__num_bins + 1); ++__s)\n+\tdelete[] __sd._M_dist[__s];\n+      delete[] __sd._M_dist;\n+      delete[] __sd._M_temporaries;\n \n-    delete[] __pus;\n-  }\n+      delete[] __pus;\n+    }\n \n-/** @brief Sequential cache-efficient random shuffle.\n- *  @param __begin Begin iterator of sequence.\n- *  @param __end End iterator of sequence.\n- *  @param __rng Random number generator to use.\n- */\n-template<typename _RAIter, typename _RandomNumberGenerator>\n-  void\n-  __sequential_random_shuffle(_RAIter __begin, \n-                            _RAIter __end,\n-                            _RandomNumberGenerator& __rng)\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n+  /** @brief Sequential cache-efficient random shuffle.\n+   *  @param __begin Begin iterator of sequence.\n+   *  @param __end End iterator of sequence.\n+   *  @param __rng Random number generator to use.\n+   */\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    void\n+    __sequential_random_shuffle(_RAIter __begin, _RAIter __end,\n+\t\t\t\t_RandomNumberGenerator& __rng)\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _DifferenceType __n = __end - __begin;\n-    const _Settings& __s = _Settings::get();\n+      _DifferenceType __n = __end - __begin;\n+      const _Settings& __s = _Settings::get();\n \n-    _BinIndex _M_num_bins, __num_bins_cache;\n+      _BinIndex __num_bins, __num_bins_cache;\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n-    // Try the L1 cache first, must fit into L1.\n-    __num_bins_cache =\n-        std::max<_DifferenceType>\n-            (1, __n / (__s.L1_cache_size_lb / sizeof(_ValueType)));\n-    __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n-\n-    // No more buckets than TLB entries, power of 2\n-    // Power of 2 and at least one element per bin, at most the TLB size\n-    _M_num_bins = std::min(__n, (_DifferenceType)__num_bins_cache);\n+      // Try the L1 cache first, must fit into L1.\n+      __num_bins_cache = std::max<_DifferenceType>\n+\t(1, __n / (__s.L1_cache_size_lb / sizeof(_ValueType)));\n+      __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n+\n+      // No more buckets than TLB entries, power of 2\n+      // Power of 2 and at least one element per bin, at most the TLB size\n+      __num_bins = std::min(__n, (_DifferenceType)__num_bins_cache);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n-    // 2 TLB entries needed per bin\n-    _M_num_bins = std::min((_DifferenceType)__s.TLB_size / 2, _M_num_bins);\n+      // 2 TLB entries needed per bin\n+      __num_bins = std::min((_DifferenceType)__s.TLB_size / 2, __num_bins);\n #endif\n-    _M_num_bins = __round_up_to_pow2(_M_num_bins);\n+      __num_bins = __round_up_to_pow2(__num_bins);\n \n-    if (_M_num_bins < __num_bins_cache)\n-      {\n+      if (__num_bins < __num_bins_cache)\n+\t{\n #endif\n-        // Now try the L2 cache, must fit into L2.\n-        __num_bins_cache =\n-            static_cast<_BinIndex>(std::max<_DifferenceType>(\n-                1, __n / (__s.L2_cache_size / sizeof(_ValueType))));\n-        __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n+          // Now try the L2 cache, must fit into L2.\n+          __num_bins_cache = static_cast<_BinIndex>\n+\t    (std::max<_DifferenceType>(1, __n / (__s.L2_cache_size\n+\t\t\t\t\t\t / sizeof(_ValueType))));\n+          __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n \n-        // No more buckets than TLB entries, power of 2\n-        // Power of 2 and at least one element per bin, at most the TLB size.\n-        _M_num_bins = static_cast<_BinIndex>\n-            (std::min(__n, static_cast<_DifferenceType>(__num_bins_cache)));\n+          // No more buckets than TLB entries, power of 2\n+          // Power of 2 and at least one element per bin, at most the TLB size.\n+          __num_bins = static_cast<_BinIndex>\n+\t    (std::min(__n, static_cast<_DifferenceType>(__num_bins_cache)));\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n-        // 2 TLB entries needed per bin\n-        _M_num_bins =\n-            std::min<_DifferenceType>(__s.TLB_size / 2, _M_num_bins);\n+          // 2 TLB entries needed per bin\n+          __num_bins = std::min<_DifferenceType>(__s.TLB_size / 2, __num_bins);\n #endif\n-        _M_num_bins = __round_up_to_pow2(_M_num_bins);\n+          __num_bins = __round_up_to_pow2(__num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n-      }\n+\t}\n #endif\n \n-    int _M_num_bits = __rd_log2(_M_num_bins);\n+      int __num_bits = __rd_log2(__num_bins);\n \n-    if (_M_num_bins > 1)\n-      {\n-        _ValueType* __target = static_cast<_ValueType*>(\n-          ::operator new(sizeof(_ValueType) * __n));\n-        _BinIndex* __oracles = new _BinIndex[__n];\n-        _DifferenceType* __dist0 = new _DifferenceType[_M_num_bins + 1],\n-                       * __dist1 = new _DifferenceType[_M_num_bins + 1];\n-\n-        for (int __b = 0; __b < _M_num_bins + 1; ++__b)\n-          __dist0[__b] = 0;\n-\n-        _RandomNumber bitrng(__rng(0xFFFFFFFF));\n-\n-        for (_DifferenceType __i = 0; __i < __n; ++__i)\n-          {\n-            _BinIndex __oracle = __random_number_pow2(_M_num_bits, bitrng);\n-            __oracles[__i] = __oracle;\n-\n-            // To allow prefix (partial) sum.\n-            ++(__dist0[__oracle + 1]);\n-          }\n-\n-        // Sum up bins.\n-        __gnu_sequential::\n-            partial_sum(__dist0, __dist0 + _M_num_bins + 1, __dist0);\n-\n-        for (int __b = 0; __b < _M_num_bins + 1; ++__b)\n-          __dist1[__b] = __dist0[__b];\n-\n-        // Distribute according to oracles.\n-        for (_DifferenceType __i = 0; __i < __n; ++__i)\n-          ::new(&(__target[(__dist0[__oracles[__i]])++]))\n-            _ValueType(*(__begin + __i));\n-\n-        for (int __b = 0; __b < _M_num_bins; ++__b)\n-          {\n-            __sequential_random_shuffle(__target + __dist1[__b],\n-                                      __target + __dist1[__b + 1],\n-                                      __rng);\n-          }\n-\n-        // Copy elements back.\n-        std::copy(__target, __target + __n, __begin);\n-\n-        delete[] __dist0;\n-        delete[] __dist1;\n-        delete[] __oracles;\n-        ::operator delete(__target);\n-      }\n-    else\n-      __gnu_sequential::random_shuffle(__begin, __end, __rng);\n-  }\n-\n-/** @brief Parallel random public call.\n- *  @param __begin Begin iterator of sequence.\n- *  @param __end End iterator of sequence.\n- *  @param __rng Random number generator to use.\n- */\n-template<typename _RAIter, typename _RandomNumberGenerator>\n-  inline void\n-  __parallel_random_shuffle(_RAIter __begin,\n-                          _RAIter __end,\n-                          _RandomNumberGenerator __rng = _RandomNumber())\n-  {\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    _DifferenceType __n = __end - __begin;\n-    __parallel_random_shuffle_drs(\n-      __begin, __end, __n, __get_max_threads(), __rng) ;\n-  }\n+      if (__num_bins > 1)\n+\t{\n+          _ValueType* __target =\n+\t    static_cast<_ValueType*>(::operator new(sizeof(_ValueType) * __n));\n+          _BinIndex* __oracles = new _BinIndex[__n];\n+          _DifferenceType* __dist0 = new _DifferenceType[__num_bins + 1],\n+                \t * __dist1 = new _DifferenceType[__num_bins + 1];\n+\n+          for (int __b = 0; __b < __num_bins + 1; ++__b)\n+            __dist0[__b] = 0;\n+\n+          _RandomNumber __bitrng(__rng(0xFFFFFFFF));\n \n+          for (_DifferenceType __i = 0; __i < __n; ++__i)\n+            {\n+              _BinIndex __oracle = __random_number_pow2(__num_bits, __bitrng);\n+              __oracles[__i] = __oracle;\n+\n+              // To allow prefix (partial) sum.\n+              ++(__dist0[__oracle + 1]);\n+            }\n+\n+          // Sum up bins.\n+          __gnu_sequential::partial_sum(__dist0, __dist0 + __num_bins + 1,\n+\t\t\t\t\t__dist0);\n+\n+          for (int __b = 0; __b < __num_bins + 1; ++__b)\n+            __dist1[__b] = __dist0[__b];\n+\n+          // Distribute according to oracles.\n+          for (_DifferenceType __i = 0; __i < __n; ++__i)\n+            ::new(&(__target[(__dist0[__oracles[__i]])++])) \n+\t\t_ValueType(*(__begin + __i));\n+\n+          for (int __b = 0; __b < __num_bins; ++__b)\n+\t    __sequential_random_shuffle(__target + __dist1[__b],\n+\t\t\t\t\t__target + __dist1[__b + 1], __rng);\n+\n+          // Copy elements back.\n+          std::copy(__target, __target + __n, __begin);\n+\n+          delete[] __dist0;\n+          delete[] __dist1;\n+          delete[] __oracles;\n+          ::operator delete(__target);\n+\t}\n+      else\n+\t__gnu_sequential::random_shuffle(__begin, __end, __rng);\n+    }\n+\n+  /** @brief Parallel random public call.\n+   *  @param __begin Begin iterator of sequence.\n+   *  @param __end End iterator of sequence.\n+   *  @param __rng Random number generator to use.\n+   */\n+  template<typename _RAIter, typename _RandomNumberGenerator>\n+    inline void\n+    __parallel_random_shuffle(_RAIter __begin, _RAIter __end,\n+\t\t\t      _RandomNumberGenerator __rng = _RandomNumber())\n+    {\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      _DifferenceType __n = __end - __begin;\n+      __parallel_random_shuffle_drs(__begin, __end, __n,\n+\t\t\t\t    __get_max_threads(), __rng);\n+    }\n }\n \n #endif /* _GLIBCXX_PARALLEL_RANDOM_SHUFFLE_H */"}, {"sha": "9709925618d90ff707b16ada3effc78483402db2", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 96, "deletions": 98, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -38,7 +38,6 @@\n #include <parallel/parallel.h>\n #include <parallel/equally_split.h>\n \n-\n namespace __gnu_parallel\n {\n   /**\n@@ -47,24 +46,24 @@ namespace __gnu_parallel\n    *  @param __length Length of sequence to search for.\n    *  @param __advances Returned __offsets. \n    */\n-template<typename _RAIter, typename _DifferenceTp>\n-  void\n-  __calc_borders(_RAIter __elements, _DifferenceTp __length, \n-              _DifferenceTp* __off)\n-  {\n-    typedef _DifferenceTp _DifferenceType;\n-\n-    __off[0] = -1;\n-    if (__length > 1)\n-      __off[1] = 0;\n-    _DifferenceType __k = 0;\n-    for (_DifferenceType __j = 2; __j <= __length; __j++)\n-      {\n-        while ((__k >= 0) && !(__elements[__k] == __elements[__j-1]))\n-          __k = __off[__k];\n-        __off[__j] = ++__k;\n-      }\n-  }\n+  template<typename _RAIter, typename _DifferenceTp>\n+    void\n+    __calc_borders(_RAIter __elements, _DifferenceTp __length, \n+\t\t   _DifferenceTp* __off)\n+    {\n+      typedef _DifferenceTp _DifferenceType;\n+\n+      __off[0] = -1;\n+      if (__length > 1)\n+\t__off[1] = 0;\n+      _DifferenceType __k = 0;\n+      for (_DifferenceType __j = 2; __j <= __length; __j++)\n+\t{\n+          while ((__k >= 0) && !(__elements[__k] == __elements[__j-1]))\n+            __k = __off[__k];\n+          __off[__j] = ++__k;\n+\t}\n+    }\n \n   // Generic parallel find algorithm (requires random access iterator).\n \n@@ -75,100 +74,99 @@ template<typename _RAIter, typename _DifferenceTp>\n    *  @param __end2 End iterator of second sequence.\n    *  @param __pred Find predicate.\n    *  @return Place of finding in first sequences. */\n-template<typename __RAIter1,\n-         typename __RAIter2,\n-         typename _Pred>\n-  __RAIter1\n-  __search_template(__RAIter1 __begin1, __RAIter1 __end1,\n-                  __RAIter2 __begin2, __RAIter2 __end2,\n-                  _Pred __pred)\n-  {\n-    typedef std::iterator_traits<__RAIter1> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n+  template<typename __RAIter1,\n+           typename __RAIter2,\n+           typename _Pred>\n+    __RAIter1\n+    __search_template(__RAIter1 __begin1, __RAIter1 __end1,\n+\t\t      __RAIter2 __begin2, __RAIter2 __end2,\n+\t\t      _Pred __pred)\n+    {\n+      typedef std::iterator_traits<__RAIter1> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _GLIBCXX_CALL((__end1 - __begin1) + (__end2 - __begin2));\n+      _GLIBCXX_CALL((__end1 - __begin1) + (__end2 - __begin2));\n \n-    _DifferenceType __pattern_length = __end2 - __begin2;\n+      _DifferenceType __pattern_length = __end2 - __begin2;\n \n-    // Pattern too short.\n-    if(__pattern_length <= 0)\n-      return __end1;\n+      // Pattern too short.\n+      if(__pattern_length <= 0)\n+\treturn __end1;\n \n-    // Last point to start search.\n-    _DifferenceType __input_length = (__end1 - __begin1) - __pattern_length;\n+      // Last point to start search.\n+      _DifferenceType __input_length = (__end1 - __begin1) - __pattern_length;\n \n-    // Where is first occurrence of pattern? defaults to end.\n-    _DifferenceType __result = (__end1 - __begin1);\n-    _DifferenceType *__splitters;\n+      // Where is first occurrence of pattern? defaults to end.\n+      _DifferenceType __result = (__end1 - __begin1);\n+      _DifferenceType *__splitters;\n \n-    // Pattern too long.\n-    if (__input_length < 0)\n-      return __end1;\n+      // Pattern too long.\n+      if (__input_length < 0)\n+\treturn __end1;\n \n-    omp_lock_t __result_lock;\n-    omp_init_lock(&__result_lock);\n+      omp_lock_t __result_lock;\n+      omp_init_lock(&__result_lock);\n \n-    _ThreadIndex __num_threads =\n-        std::max<_DifferenceType>(1,\n-            std::min<_DifferenceType>(__input_length, __get_max_threads()));\n+      _ThreadIndex __num_threads = std::max<_DifferenceType>\n+\t(1, std::min<_DifferenceType>(__input_length,\n+\t\t\t\t      __get_max_threads()));\n \n-    _DifferenceType __advances[__pattern_length];\n-    __calc_borders(__begin2, __pattern_length, __advances);\n+      _DifferenceType __advances[__pattern_length];\n+      __calc_borders(__begin2, __pattern_length, __advances);\n \n-#   pragma omp parallel num_threads(__num_threads)\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-            __splitters = new _DifferenceType[__num_threads + 1];\n-            equally_split(__input_length, __num_threads, __splitters);\n-          }\n-\n-        _ThreadIndex __iam = omp_get_thread_num();\n-\n-        _DifferenceType __start = __splitters[__iam],\n-                        __stop = __splitters[__iam + 1];\n-\n-        _DifferenceType __pos_in_pattern = 0;\n-        bool __found_pattern = false;\n-\n-        while (__start <= __stop && !__found_pattern)\n-          {\n-            // Get new value of result.\n-            #pragma omp flush(__result)\n-            // No chance for this thread to find first occurrence.\n-            if (__result < __start)\n-              break;\n-            while (__pred(__begin1[__start + __pos_in_pattern],\n-                         __begin2[__pos_in_pattern]))\n-              {\n-                ++__pos_in_pattern;\n-                if (__pos_in_pattern == __pattern_length)\n-                  {\n-                    // Found new candidate for result.\n-                            omp_set_lock(&__result_lock);\n-                    __result = std::min(__result, __start);\n-                            omp_unset_lock(&__result_lock);\n-\n-                    __found_pattern = true;\n-                    break;\n-                  }\n-              }\n-            // Make safe jump.\n-            __start += (__pos_in_pattern - __advances[__pos_in_pattern]);\n-            __pos_in_pattern =\n-                (__advances[__pos_in_pattern] < 0) ?\n-                  0 : __advances[__pos_in_pattern];\n-          }\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t  __splitters = new _DifferenceType[__num_threads + 1];\n+\t  equally_split(__input_length, __num_threads, __splitters);\n+\t}\n+\n+\t_ThreadIndex __iam = omp_get_thread_num();\n+\n+\t_DifferenceType __start = __splitters[__iam],\n+\t                 __stop = __splitters[__iam + 1];\n+\n+\t_DifferenceType __pos_in_pattern = 0;\n+\tbool __found_pattern = false;\n+\n+\twhile (__start <= __stop && !__found_pattern)\n+\t  {\n+\t    // Get new value of result.\n+#pragma omp flush(__result)\n+\t    // No chance for this thread to find first occurrence.\n+\t    if (__result < __start)\n+\t      break;\n+\t    while (__pred(__begin1[__start + __pos_in_pattern],\n+\t\t\t  __begin2[__pos_in_pattern]))\n+\t      {\n+\t\t++__pos_in_pattern;\n+\t\tif (__pos_in_pattern == __pattern_length)\n+\t\t  {\n+\t\t    // Found new candidate for result.\n+\t\t    omp_set_lock(&__result_lock);\n+\t\t    __result = std::min(__result, __start);\n+\t\t    omp_unset_lock(&__result_lock);\n+\n+\t\t    __found_pattern = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    // Make safe jump.\n+\t    __start += (__pos_in_pattern - __advances[__pos_in_pattern]);\n+\t    __pos_in_pattern = (__advances[__pos_in_pattern] < 0\n+\t\t\t\t? 0 : __advances[__pos_in_pattern]);\n+\t  }\n       } //parallel\n \n-    omp_destroy_lock(&__result_lock);\n-\n-    delete[] __splitters;\n+      omp_destroy_lock(&__result_lock);\n \n-    // Return iterator on found element.\n-    return (__begin1 + __result);\n-  }\n+      delete[] __splitters;\n+      \n+      // Return iterator on found element.\n+      return (__begin1 + __result);\n+    }\n } // end namespace\n \n #endif /* _GLIBCXX_PARALLEL_SEARCH_H */"}, {"sha": "6dd63c9b12812980673b54942c8b757759bd442a", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 420, "deletions": 421, "changes": 841, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -41,490 +41,489 @@\n \n namespace __gnu_parallel\n {\n-template<typename _IIter, typename _OutputIterator>\n-  _OutputIterator\n-  copy_tail(std::pair<_IIter, _IIter> __b,\n-            std::pair<_IIter, _IIter> __e, _OutputIterator __r)\n-  {\n-    if (__b.first != __e.first)\n+  template<typename _IIter, typename _OutputIterator>\n+    _OutputIterator\n+    __copy_tail(std::pair<_IIter, _IIter> __b,\n+\t\tstd::pair<_IIter, _IIter> __e, _OutputIterator __r)\n+    {\n+      if (__b.first != __e.first)\n+\t{\n+          do\n+            {\n+              *__r++ = *__b.first++;\n+            }\n+          while (__b.first != __e.first);\n+\t}\n+      else\n+\t{\n+          while (__b.second != __e.second)\n+            *__r++ = *__b.second++;\n+\t}\n+      return __r;\n+    }\n+\n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    struct __symmetric_difference_func\n+    {\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n+\n+      __symmetric_difference_func(_Compare __comp) : _M_comp(__comp) {}\n+\n+      _Compare _M_comp;\n+\n+      _OutputIterator\n+      _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter __d,\n+\t\t_OutputIterator __r) const\n       {\n-        do\n+\twhile (__a != __b && __c != __d)\n           {\n-            *__r++ = *__b.first++;\n+            if (_M_comp(*__a, *__c))\n+              {\n+        \t*__r = *__a;\n+        \t++__a;\n+        \t++__r;\n+              }\n+            else if (_M_comp(*__c, *__a))\n+              {\n+        \t*__r = *__c;\n+        \t++__c;\n+        \t++__r;\n+              }\n+            else\n+              {\n+        \t++__a;\n+        \t++__c;\n+              }\n           }\n-        while (__b.first != __e.first);\n+\treturn std::copy(__c, __d, std::copy(__a, __b, __r));\n       }\n-    else\n+\n+      _DifferenceType\n+      __count(_IIter __a, _IIter __b, _IIter __c, _IIter d) const\n       {\n-        while (__b.second != __e.second)\n-          *__r++ = *__b.second++;\n+\t_DifferenceType __counter = 0;\n+\n+\twhile (__a != __b && __c != d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              {\n+        \t++__a;\n+        \t++__counter;\n+              }\n+            else if (_M_comp(*__c, *__a))\n+              {\n+        \t++__c;\n+        \t++__counter;\n+              }\n+            else\n+              {\n+        \t++__a;\n+        \t++__c;\n+              }\n+          }\n+\n+\treturn __counter + (__b - __a) + (d - __c);\n       }\n-    return __r;\n-  }\n \n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  struct symmetric_difference_func\n-  {\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n+      _OutputIterator\n+      __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n+      { return std::copy(__c, d, __out); }\n \n-    symmetric_difference_func(_Compare __comp) : _M_comp(__comp) {}\n+      _OutputIterator\n+      __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+      { return std::copy(__a, __b, __out); }\n+    };\n \n-    _Compare _M_comp;\n \n-    _OutputIterator\n-    _M_invoke(_IIter __a, _IIter __b,\n-           _IIter __c, _IIter d,\n-           _OutputIterator __r) const\n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    struct __difference_func\n     {\n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            {\n-              *__r = *__a;\n-              ++__a;\n-              ++__r;\n-            }\n-          else if (_M_comp(*__c, *__a))\n-            {\n-              *__r = *__c;\n-              ++__c;\n-              ++__r;\n-            }\n-          else\n-            {\n-              ++__a;\n-              ++__c;\n-            }\n-        }\n-      return std::copy(__c, d, std::copy(__a, __b, __r));\n-    }\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    _DifferenceType\n-    __count(_IIter __a, _IIter __b,\n-          _IIter __c, _IIter d) const\n-    {\n-      _DifferenceType __counter = 0;\n+      __difference_func(_Compare __comp) : _M_comp(__comp) {}\n \n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            {\n-              ++__a;\n-              ++__counter;\n-            }\n-          else if (_M_comp(*__c, *__a))\n-            {\n-              ++__c;\n-              ++__counter;\n-            }\n-          else\n-            {\n-              ++__a;\n-              ++__c;\n-            }\n-        }\n+      _Compare _M_comp;\n \n-      return __counter + (__b - __a) + (d - __c);\n-    }\n+      _OutputIterator\n+      _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n+\t\t_OutputIterator __r) const\n+      {\n+\twhile (__a != __b && __c != d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              {\n+        \t*__r = *__a;\n+        \t++__a;\n+        \t++__r;\n+              }\n+            else if (_M_comp(*__c, *__a))\n+              { ++__c; }\n+            else\n+              {\n+        \t++__a;\n+        \t++__c;\n+              }\n+          }\n+\treturn std::copy(__a, __b, __r);\n+      }\n \n-    _OutputIterator\n-    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n-    { return std::copy(__c, d, __out); }\n+      _DifferenceType\n+      __count(_IIter __a, _IIter __b,\n+\t      _IIter __c, _IIter d) const\n+      {\n+\t_DifferenceType __counter = 0;\n \n-    _OutputIterator\n-    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n-    { return std::copy(__a, __b, __out); }\n-  };\n+\twhile (__a != __b && __c != d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              {\n+        \t++__a;\n+        \t++__counter;\n+              }\n+            else if (_M_comp(*__c, *__a))\n+              { ++__c; }\n+            else\n+              { ++__a; ++__c; }\n+          }\n \n+\treturn __counter + (__b - __a);\n+      }\n \n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  struct __difference_func\n-  {\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n+      _OutputIterator\n+      __first_empty(_IIter, _IIter, _OutputIterator __out) const\n+      { return __out; }\n \n-    __difference_func(_Compare __comp) : _M_comp(__comp) {}\n+      _OutputIterator\n+      __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+      { return std::copy(__a, __b, __out); }\n+    };\n \n-    _Compare _M_comp;\n \n-    _OutputIterator\n-    _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n-          _OutputIterator __r) const\n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    struct __intersection_func\n     {\n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            {\n-              *__r = *__a;\n-              ++__a;\n-              ++__r;\n-            }\n-          else if (_M_comp(*__c, *__a))\n-            { ++__c; }\n-          else\n-            {\n-              ++__a;\n-              ++__c;\n-            }\n-        }\n-      return std::copy(__a, __b, __r);\n-    }\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    _DifferenceType\n-    __count(_IIter __a, _IIter __b,\n-          _IIter __c, _IIter d) const\n-    {\n-      _DifferenceType __counter = 0;\n+      __intersection_func(_Compare __comp) : _M_comp(__comp) {}\n \n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            {\n-              ++__a;\n-              ++__counter;\n-            }\n-          else if (_M_comp(*__c, *__a))\n-            { ++__c; }\n-          else\n-            { ++__a; ++__c; }\n-        }\n+      _Compare _M_comp;\n \n-      return __counter + (__b - __a);\n-    }\n+      _OutputIterator\n+      _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter __d,\n+\t\t_OutputIterator __r) const\n+      {\n+\twhile (__a != __b && __c != __d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              { ++__a; }\n+            else if (_M_comp(*__c, *__a))\n+              { ++__c; }\n+            else\n+              {\n+        \t*__r = *__a;\n+        \t++__a;\n+        \t++__c;\n+        \t++__r;\n+              }\n+          }\n \n-    inline _OutputIterator\n-    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n-    { return __out; }\n+\treturn __r;\n+      }\n \n-    inline _OutputIterator\n-    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n-    { return std::copy(__a, __b, __out); }\n-  };\n+      _DifferenceType\n+      __count(_IIter __a, _IIter __b, _IIter __c, _IIter __d) const\n+      {\n+\t_DifferenceType __counter = 0;\n \n+\twhile (__a != __b && __c != __d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              { ++__a; }\n+            else if (_M_comp(*__c, *__a))\n+              { ++__c; }\n+            else\n+              {\n+        \t++__a;\n+        \t++__c;\n+        \t++__counter;\n+              }\n+          }\n \n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  struct __intersection_func\n-  {\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n+\treturn __counter;\n+      }\n \n-    __intersection_func(_Compare __comp) : _M_comp(__comp) {}\n+      _OutputIterator\n+      __first_empty(_IIter, _IIter, _OutputIterator __out) const\n+      { return __out; }\n \n-    _Compare _M_comp;\n+      _OutputIterator\n+      __second_empty(_IIter, _IIter, _OutputIterator __out) const\n+      { return __out; }\n+    };\n \n-    _OutputIterator\n-    _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n-          _OutputIterator __r) const\n+  template<class _IIter, class _OutputIterator, class _Compare>\n+    struct __union_func\n     {\n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            { ++__a; }\n-          else if (_M_comp(*__c, *__a))\n-            { ++__c; }\n-          else\n-            {\n-              *__r = *__a;\n-              ++__a;\n-              ++__c;\n-              ++__r;\n-            }\n-        }\n+      typedef typename std::iterator_traits<_IIter>::difference_type\n+      _DifferenceType;\n \n-      return __r;\n-    }\n+      __union_func(_Compare __comp) : _M_comp(__comp) {}\n \n-    _DifferenceType\n-    __count(_IIter __a, _IIter __b,\n-          _IIter __c, _IIter d) const\n-    {\n-      _DifferenceType __counter = 0;\n-\n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            { ++__a; }\n-          else if (_M_comp(*__c, *__a))\n-            { ++__c; }\n-          else\n-            {\n-              ++__a;\n-              ++__c;\n-              ++__counter;\n-            }\n-        }\n+      _Compare _M_comp;\n \n-      return __counter;\n-    }\n+      _OutputIterator\n+      _M_invoke(_IIter __a, const _IIter __b, _IIter __c,\n+\t\tconst _IIter __d, _OutputIterator __r) const\n+      {\n+\twhile (__a != __b && __c != __d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              {\n+        \t*__r = *__a;\n+        \t++__a;\n+              }\n+            else if (_M_comp(*__c, *__a))\n+              {\n+        \t*__r = *__c;\n+        \t++__c;\n+              }\n+            else\n+              {\n+        \t*__r = *__a;\n+        \t++__a;\n+        \t++__c;\n+              }\n+            ++__r;\n+          }\n+\treturn std::copy(__c, __d, std::copy(__a, __b, __r));\n+      }\n \n-    inline _OutputIterator\n-    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n-    { return __out; }\n+      _DifferenceType\n+      __count(_IIter __a, _IIter __b, _IIter __c, _IIter __d) const\n+      {\n+\t_DifferenceType __counter = 0;\n \n-    inline _OutputIterator\n-    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n-    { return __out; }\n-  };\n+\twhile (__a != __b && __c != __d)\n+          {\n+            if (_M_comp(*__a, *__c))\n+              { ++__a; }\n+            else if (_M_comp(*__c, *__a))\n+              { ++__c; }\n+            else\n+              {\n+        \t++__a;\n+        \t++__c;\n+              }\n+            ++__counter;\n+          }\n \n-template<class _IIter, class _OutputIterator, class _Compare>\n-  struct __union_func\n-  {\n-    typedef typename std::iterator_traits<_IIter>::difference_type\n-    _DifferenceType;\n+\t__counter += (__b - __a);\n+\t__counter += (__d - __c);\n+\treturn __counter;\n+      }\n \n-    __union_func(_Compare __comp) : _M_comp(__comp) {}\n+      _OutputIterator\n+      __first_empty(_IIter __c, _IIter __d, _OutputIterator __out) const\n+      { return std::copy(__c, __d, __out); }\n \n-    _Compare _M_comp;\n+      _OutputIterator\n+      __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+      { return std::copy(__a, __b, __out); }\n+    };\n \n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename Operation>\n     _OutputIterator\n-    _M_invoke(_IIter __a, const _IIter __b, _IIter __c,\n-          const _IIter d, _OutputIterator __r) const\n+    __parallel_set_operation(_IIter __begin1, _IIter __end1,\n+\t\t\t     _IIter __begin2, _IIter __end2,\n+\t\t\t     _OutputIterator __result, Operation __op)\n     {\n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            {\n-              *__r = *__a;\n-              ++__a;\n-            }\n-          else if (_M_comp(*__c, *__a))\n-            {\n-              *__r = *__c;\n-              ++__c;\n-            }\n-          else\n-            {\n-              *__r = *__a;\n-              ++__a;\n-              ++__c;\n-            }\n-          ++__r;\n-        }\n-      return std::copy(__c, d, std::copy(__a, __b, __r));\n-    }\n+      _GLIBCXX_CALL((__end1 - __begin1) + (__end2 - __begin2))\n \n-    _DifferenceType\n-    __count(_IIter __a, _IIter __b,\n-          _IIter __c, _IIter d) const\n-    {\n-      _DifferenceType __counter = 0;\n-\n-      while (__a != __b && __c != d)\n-        {\n-          if (_M_comp(*__a, *__c))\n-            { ++__a; }\n-          else if (_M_comp(*__c, *__a))\n-            { ++__c; }\n-          else\n-            {\n-              ++__a;\n-              ++__c;\n-            }\n-          ++__counter;\n-        }\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+      typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-      __counter += (__b - __a);\n-      __counter += (d - __c);\n-      return __counter;\n-    }\n+      if (__begin1 == __end1)\n+\treturn __op.__first_empty(__begin2, __end2, __result);\n \n-    inline _OutputIterator\n-    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n-    { return std::copy(__c, d, __out); }\n+      if (__begin2 == __end2)\n+\treturn __op.__second_empty(__begin1, __end1, __result);\n \n-    inline _OutputIterator\n-    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n-    { return std::copy(__a, __b, __out); }\n-  };\n-\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename Operation>\n-  _OutputIterator\n-  __parallel_set_operation(_IIter __begin1, _IIter __end1,\n-                         _IIter __begin2, _IIter __end2,\n-                         _OutputIterator __result, Operation __op)\n-  {\n-    _GLIBCXX_CALL((__end1 - __begin1) + (__end2 - __begin2))\n-\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n-\n-    if (__begin1 == __end1)\n-      return __op.__first_empty(__begin2, __end2, __result);\n-\n-    if (__begin2 == __end2)\n-      return __op.__second_empty(__begin1, __end1, __result);\n-\n-    const _DifferenceType size = (__end1 - __begin1) + (__end2 - __begin2);\n-\n-    const _IteratorPair __sequence[ 2 ] =\n-      { std::make_pair(__begin1, __end1), std::make_pair(__begin2, __end2) };\n-    _OutputIterator return_value = __result;\n-    _DifferenceType *__borders;\n-    _IteratorPair *__block_begins;\n-    _DifferenceType* __lengths;\n-\n-    _ThreadIndex __num_threads =\n-        std::min<_DifferenceType>(__get_max_threads(),\n-            std::min(__end1 - __begin1, __end2 - __begin2));\n-\n-#   pragma omp parallel num_threads(__num_threads)\n+      const _DifferenceType __size = (__end1 - __begin1) + (__end2 - __begin2);\n+\n+      const _IteratorPair __sequence[2] = { std::make_pair(__begin1, __end1),\n+\t\t\t\t\t    std::make_pair(__begin2, __end2) };\n+      _OutputIterator __return_value = __result;\n+      _DifferenceType *__borders;\n+      _IteratorPair *__block_begins;\n+      _DifferenceType* __lengths;\n+\n+      _ThreadIndex __num_threads =\n+          std::min<_DifferenceType>(__get_max_threads(),\n+              std::min(__end1 - __begin1, __end2 - __begin2));\n+\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n-\n-            __borders = new _DifferenceType[__num_threads + 2];\n-            equally_split(size, __num_threads + 1, __borders);\n-            __block_begins = new _IteratorPair[__num_threads + 1];\n-            // Very __start.\n-            __block_begins[0] = std::make_pair(__begin1, __begin2);\n-            __lengths = new _DifferenceType[__num_threads];\n-          } //single\n-\n-        _ThreadIndex __iam = omp_get_thread_num();\n-\n-        // _Result from multiseq_partition.\n-        _IIter __offset[2];\n-        const _DifferenceType __rank = __borders[__iam + 1];\n-\n-        multiseq_partition(__sequence, __sequence + 2,\n-                           __rank, __offset, __op._M_comp);\n-\n-        // allowed to read?\n-        // together\n-        // *(__offset[ 0 ] - 1) == *__offset[ 1 ]\n-        if (__offset[ 0 ] != __begin1 && __offset[ 1 ] != __end2\n-            && !__op._M_comp(*(__offset[ 0 ] - 1), *__offset[ 1 ])\n-            && !__op._M_comp(*__offset[ 1 ], *(__offset[ 0 ] - 1)))\n-          {\n-            // Avoid split between globally equal elements: move one to\n-            // front in first sequence.\n-            --__offset[ 0 ];\n-          }\n-\n-        _IteratorPair block_end = __block_begins[ __iam + 1 ] =\n-            _IteratorPair(__offset[ 0 ], __offset[ 1 ]);\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\n+\t  __borders = new _DifferenceType[__num_threads + 2];\n+\t  equally_split(__size, __num_threads + 1, __borders);\n+\t  __block_begins = new _IteratorPair[__num_threads + 1];\n+\t  // Very __start.\n+\t  __block_begins[0] = std::make_pair(__begin1, __begin2);\n+\t  __lengths = new _DifferenceType[__num_threads];\n+\t} //single\n+\n+\t_ThreadIndex __iam = omp_get_thread_num();\n+\n+\t// _Result from multiseq_partition.\n+\t_IIter __offset[2];\n+\tconst _DifferenceType __rank = __borders[__iam + 1];\n+\n+\tmultiseq_partition(__sequence, __sequence + 2,\n+\t\t\t   __rank, __offset, __op._M_comp);\n+\n+\t// allowed to read?\n+\t// together\n+\t// *(__offset[ 0 ] - 1) == *__offset[ 1 ]\n+\tif (__offset[ 0 ] != __begin1 && __offset[1] != __end2\n+\t    && !__op._M_comp(*(__offset[0] - 1), *__offset[1])\n+\t    && !__op._M_comp(*__offset[1], *(__offset[0] - 1)))\n+\t  {\n+\t    // Avoid split between globally equal elements: move one to\n+\t    // front in first sequence.\n+              --__offset[0];\n+\t  }\n+\n+\t_IteratorPair __block_end = __block_begins[__iam + 1] =\n+\t  _IteratorPair(__offset[0], __offset[1]);\n+\n+\t// Make sure all threads have their block_begin result written out.\n+#       pragma omp barrier\n \n-        // Make sure all threads have their block_begin result written out.\n+\t_IteratorPair __block_begin = __block_begins[__iam];\n+\n+\t// Begin working for the first block, while the others except\n+\t// the last start to count.\n+\tif (__iam == 0)\n+\t  {\n+\t    // The first thread can copy already.\n+\t    __lengths[ __iam ] =\n+\t      __op._M_invoke(__block_begin.first, __block_end.first,\n+\t\t\t     __block_begin.second, __block_end.second,\n+\t\t\t     __result) - __result;\n+\t  }\n+\telse\n+\t  {\n+\t    __lengths[ __iam ] =\n+\t      __op.__count(__block_begin.first, __block_end.first,\n+\t\t\t   __block_begin.second, __block_end.second);\n+\t  }\n+\n+\t// Make sure everyone wrote their lengths.\n #       pragma omp barrier\n \n-        _IteratorPair __block_begin = __block_begins[ __iam ];\n+\t_OutputIterator __r = __result;\n \n-        // Begin working for the first block, while the others except\n-        // the last start to count.\n-        if (__iam == 0)\n-          {\n-            // The first thread can copy already.\n-            __lengths[ __iam ] =\n-              __op._M_invoke(__block_begin.first, block_end.first,\n-                             __block_begin.second, block_end.second, __result)\n-                              - __result;\n-          }\n-        else\n-          {\n-            __lengths[ __iam ] =\n-              __op.__count(__block_begin.first, block_end.first,\n-                           __block_begin.second, block_end.second);\n-          }\n+\tif (__iam == 0)\n+\t  {\n+\t    // Do the last block.\n+\t    for (int __i = 0; __i < __num_threads; ++__i)\n+\t      __r += __lengths[__i];\n \n-        // Make sure everyone wrote their lengths.\n-#       pragma omp barrier\n+\t    __block_begin = __block_begins[__num_threads];\n \n-        _OutputIterator __r = __result;\n+\t    // Return the result iterator of the last block.\n+\t    __return_value =\n+\t      __op._M_invoke(__block_begin.first, __end1,\n+\t\t\t     __block_begin.second, __end2, __r);\n \n-        if (__iam == 0)\n-          {\n-            // Do the last block.\n-            for (int __i = 0; __i < __num_threads; ++__i)\n-              __r += __lengths[__i];\n+\t  }\n+          else\n+            {\n+              for (int __i = 0; __i < __iam; ++__i)\n+        \t__r += __lengths[ __i ];\n \n-            __block_begin = __block_begins[__num_threads];\n+              // Reset begins for copy pass.\n+              __op._M_invoke(__block_begin.first, __block_end.first,\n+\t\t\t     __block_begin.second, __block_end.second, __r);\n+            }\n+\t}\n+      return __return_value;\n+    }\n \n-            // Return the result iterator of the last block.\n-            return_value = __op._M_invoke(\n-              __block_begin.first, __end1, __block_begin.second, __end2, __r);\n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    inline _OutputIterator\n+    __parallel_set_union(_IIter __begin1, _IIter __end1,\n+\t\t\t _IIter __begin2, _IIter __end2,\n+\t\t\t _OutputIterator __result, _Compare __comp)\n+    {\n+      return __parallel_set_operation(__begin1, __end1, __begin2, __end2,\n+\t\t\t\t      __result,\n+\t\t\t\t      __union_func< _IIter, _OutputIterator,\n+\t\t\t\t      _Compare>(__comp));\n+    }\n \n-          }\n-        else\n-          {\n-            for (int __i = 0; __i < __iam; ++__i)\n-              __r += __lengths[ __i ];\n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    inline _OutputIterator\n+    __parallel_set_intersection(_IIter __begin1, _IIter __end1,\n+                        \t_IIter __begin2, _IIter __end2,\n+                        \t_OutputIterator __result, _Compare __comp)\n+    {\n+      return __parallel_set_operation(__begin1, __end1, __begin2, __end2,\n+\t\t\t\t      __result,\n+\t\t\t\t      __intersection_func<_IIter,\n+\t\t\t\t      _OutputIterator, _Compare>(__comp));\n+    }\n \n-            // Reset begins for copy pass.\n-            __op._M_invoke(__block_begin.first, block_end.first,\n-                  __block_begin.second, block_end.second, __r);\n-          }\n-      }\n-    return return_value;\n-  }\n-\n-\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  inline _OutputIterator\n-  __parallel_set_union(_IIter __begin1, _IIter __end1,\n-                     _IIter __begin2, _IIter __end2,\n-                     _OutputIterator __result, _Compare _M_comp)\n-  {\n-    return __parallel_set_operation(__begin1, __end1, __begin2, __end2,\n-        __result, __union_func< _IIter, _OutputIterator, _Compare>(_M_comp));\n-  }\n-\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  inline _OutputIterator\n-  __parallel_set_intersection(_IIter __begin1, _IIter __end1,\n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    inline _OutputIterator\n+    __parallel_set_difference(_IIter __begin1, _IIter __end1,\n                               _IIter __begin2, _IIter __end2,\n-                              _OutputIterator __result, _Compare _M_comp)\n-  {\n-    return __parallel_set_operation(\n-             __begin1, __end1, __begin2, __end2, __result,\n-             __intersection_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n-  }\n-\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  inline _OutputIterator\n-  __parallel_set_difference(_IIter __begin1, _IIter __end1,\n-                            _IIter __begin2, _IIter __end2,\n-                            _OutputIterator __result, _Compare _M_comp)\n-  {\n-    return __parallel_set_operation(\n-             __begin1, __end1, __begin2, __end2, __result,\n-             __difference_func<_IIter, _OutputIterator, _Compare>(_M_comp));\n-  }\n-\n-template<typename _IIter,\n-         typename _OutputIterator,\n-         typename _Compare>\n-  inline _OutputIterator\n-  __parallel_set_symmetric_difference(_IIter __begin1, _IIter __end1,\n-                                      _IIter __begin2, _IIter __end2,\n-                                      _OutputIterator __result,\n-                                      _Compare _M_comp)\n-  {\n-    return __parallel_set_operation(\n-             __begin1, __end1, __begin2, __end2, __result,\n-            symmetric_difference_func<_IIter, _OutputIterator, _Compare>\n-              (_M_comp));\n-  }\n+                              _OutputIterator __result, _Compare __comp)\n+    {\n+      return __parallel_set_operation(__begin1, __end1, __begin2, __end2,\n+\t\t\t\t      __result,\n+\t\t\t\t      __difference_func<_IIter,\n+\t\t\t\t      _OutputIterator, _Compare>(__comp));\n+    }\n \n+  template<typename _IIter,\n+           typename _OutputIterator,\n+           typename _Compare>\n+    inline _OutputIterator\n+    __parallel_set_symmetric_difference(_IIter __begin1, _IIter __end1,\n+                                \t_IIter __begin2, _IIter __end2,\n+                                \t_OutputIterator __result,\n+                                \t_Compare __comp)\n+    {\n+      return __parallel_set_operation(__begin1, __end1, __begin2, __end2,\n+\t\t\t\t      __result,\n+\t\t\t\t      __symmetric_difference_func<_IIter,\n+\t\t\t\t      _OutputIterator, _Compare>(__comp));\n+    }\n }\n \n #endif /* _GLIBCXX_PARALLEL_SET_OPERATIONS_H */"}, {"sha": "f1a163c63b69b2ec92c8301b4e740df79d25eeb0", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -54,12 +54,12 @@\n \n namespace __gnu_parallel\n {\n-        //prototype\n+  //prototype\n   template<bool __stable, typename _RAIter,\n            typename _Compare, typename _Parallelism>\n-  void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-  _Compare __comp, _Parallelism __parallelism);\n+    void\n+    __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t    _Compare __comp, _Parallelism __parallelism);\n         \n   /** \n    *  @brief Choose multiway mergesort, splitting variant at run-time,\n@@ -70,19 +70,19 @@ namespace __gnu_parallel\n    *  @callgraph \n    */\n   template<bool __stable, typename _RAIter, typename _Compare>\n-  inline void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-    _Compare __comp, multiway_mergesort_tag __parallelism)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n+    inline void\n+    __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t    _Compare __comp, multiway_mergesort_tag __parallelism)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n \n-    if(_Settings::get().sort_splitting == EXACT)\n-      parallel_sort_mwms<__stable, true>\n-        (__begin, __end, __comp, __parallelism.__get_num_threads());\n-    else\n-      parallel_sort_mwms<__stable, false>\n-        (__begin, __end, __comp, __parallelism.__get_num_threads());\n-  }\n+      if(_Settings::get().sort_splitting == EXACT)\n+\tparallel_sort_mwms<__stable, true>\n+\t  (__begin, __end, __comp, __parallelism.__get_num_threads());\n+      else\n+\tparallel_sort_mwms<__stable, false>\n+\t  (__begin, __end, __comp, __parallelism.__get_num_threads());\n+    }\n \n   /** \n    *  @brief Choose multiway mergesort with exact splitting,\n@@ -93,15 +93,16 @@ namespace __gnu_parallel\n    *  @callgraph \n    */\n   template<bool __stable, typename _RAIter, typename _Compare>\n-  inline void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-    _Compare __comp, multiway_mergesort_exact_tag __parallelism)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n+    inline void\n+    __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t    _Compare __comp,\n+\t\t    multiway_mergesort_exact_tag __parallelism)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n \n       parallel_sort_mwms<__stable, true>\n         (__begin, __end, __comp, __parallelism.__get_num_threads());\n-  }\n+    }\n \n   /** \n    *  @brief Choose multiway mergesort with splitting by sampling,\n@@ -112,15 +113,16 @@ namespace __gnu_parallel\n    *  @callgraph \n    */\n   template<bool __stable, typename _RAIter, typename _Compare>\n-  inline void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-    _Compare __comp, multiway_mergesort_sampling_tag __parallelism)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n+    inline void\n+    __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t    _Compare __comp,\n+\t\t    multiway_mergesort_sampling_tag __parallelism)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n \n-    parallel_sort_mwms<__stable, false>\n+      parallel_sort_mwms<__stable, false>\n       (__begin, __end, __comp, __parallelism.__get_num_threads());\n-  }\n+    }\n \n   /**\n    *  @brief Choose quicksort for parallel sorting.\n@@ -130,17 +132,17 @@ namespace __gnu_parallel\n    *  @callgraph \n    */\n   template<bool __stable, typename _RAIter, typename _Compare>\n-  inline void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-    _Compare __comp, quicksort_tag __parallelism)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n+    inline void\n+    __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t    _Compare __comp, quicksort_tag __parallelism)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n \n-    _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n+      _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n \n-    __parallel_sort_qs(__begin, __end, __comp,\n-                       __parallelism.__get_num_threads());\n-  }\n+      __parallel_sort_qs(__begin, __end, __comp,\n+\t\t\t __parallelism.__get_num_threads());\n+    }\n \n   /**\n    *  @brief Choose balanced quicksort for parallel sorting.\n@@ -150,19 +152,18 @@ namespace __gnu_parallel\n    *  @param __stable Sort __stable.\n    *  @callgraph \n    */\n-  template<bool __stable, typename _RAIter, typename _Compare>\n-  inline void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-    _Compare __comp, balanced_quicksort_tag __parallelism)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n-\n-    _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n+   template<bool __stable, typename _RAIter, typename _Compare>\n+     inline void\n+     __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t     _Compare __comp, balanced_quicksort_tag __parallelism)\n+     {\n+       _GLIBCXX_CALL(__end - __begin)\n \n-    __parallel_sort_qsb(__begin, __end, __comp,\n-                        __parallelism.__get_num_threads());\n-  }\n+       _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n \n+       __parallel_sort_qsb(__begin, __end, __comp,\n+\t\t\t   __parallelism.__get_num_threads());\n+     }\n \n   /** \n    *  @brief Choose multiway mergesort with exact splitting,\n@@ -173,17 +174,16 @@ namespace __gnu_parallel\n    *  @callgraph \n    */\n   template<bool __stable, typename _RAIter, typename _Compare>\n-  inline void\n-  __parallel_sort(_RAIter __begin, _RAIter __end,\n-    _Compare __comp, default_parallel_tag __parallelism)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n-\n-    __parallel_sort<__stable>\n-      (__begin, __end, __comp,\n-        multiway_mergesort_exact_tag(__parallelism.__get_num_threads()));\n-  }\n+    inline void\n+    __parallel_sort(_RAIter __begin, _RAIter __end,\n+\t\t    _Compare __comp, default_parallel_tag __parallelism)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n \n+      __parallel_sort<__stable>\n+\t(__begin, __end, __comp,\n+\t multiway_mergesort_exact_tag(__parallelism.__get_num_threads()));\n+    }\n \n   /**\n    *  @brief Choose a parallel sorting algorithm.\n@@ -196,7 +196,7 @@ namespace __gnu_parallel\n   template<bool __stable, typename _RAIter, typename _Compare>\n     inline void\n     __parallel_sort(_RAIter __begin, _RAIter __end,\n-                  _Compare __comp, parallel_tag __parallelism)\n+\t\t    _Compare __comp, parallel_tag __parallelism)\n     {\n       _GLIBCXX_CALL(__end - __begin)\n       typedef std::iterator_traits<_RAIter> _TraitsType;"}, {"sha": "bc47b2699b4670c0ce3d25a4c45ae2fd2e49946d", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -51,20 +51,16 @@ namespace __gnu_parallel\n     public:\n       /** @brief Default constructor. Use default number of threads. */\n       parallel_tag()\n-      {\n-        this->_M_num_threads = 0;\n-      }\n+      { _M_num_threads = 0; }\n \n       /** @brief Default constructor. Recommend number of threads to use.\n        *  @param __num_threads Desired number of threads. */\n       parallel_tag(_ThreadIndex __num_threads)\n-      {\n-        this->_M_num_threads = __num_threads;\n-      }\n+      { _M_num_threads = __num_threads; }\n \n       /** @brief Find out desired number of threads.\n        *  @return Desired number of threads. */\n-      inline _ThreadIndex __get_num_threads()\n+      _ThreadIndex __get_num_threads()\n       {\n         if(_M_num_threads == 0)\n           return omp_get_max_threads();\n@@ -74,19 +70,17 @@ namespace __gnu_parallel\n \n       /** @brief Set the desired number of threads.\n        *  @param __num_threads Desired number of threads. */\n-      inline void set_num_threads(_ThreadIndex __num_threads)\n-      {\n-        this->_M_num_threads = __num_threads;\n-      }\n+      void set_num_threads(_ThreadIndex __num_threads)\n+      { _M_num_threads = __num_threads; }\n   };\n \n   /** @brief Recommends parallel execution using the\n       default parallel algorithm. */\n   struct default_parallel_tag : public parallel_tag\n   {\n-      default_parallel_tag() { }\n-      default_parallel_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    default_parallel_tag() { }\n+    default_parallel_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Recommends parallel execution using dynamic\n@@ -114,64 +108,64 @@ namespace __gnu_parallel\n    *  with exact splitting, at compile time. */\n   struct exact_tag : public parallel_tag\n   {\n-      exact_tag() { }\n-      exact_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    exact_tag() { }\n+    exact_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel merging\n    *  with exact splitting, at compile time. */\n   struct sampling_tag : public parallel_tag\n   {\n-      sampling_tag() { }\n-      sampling_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    sampling_tag() { }\n+    sampling_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n \n   /** @brief Forces parallel sorting using multiway mergesort\n    *  at compile time. */\n   struct multiway_mergesort_tag : public parallel_tag\n   {\n-      multiway_mergesort_tag() { }\n-      multiway_mergesort_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    multiway_mergesort_tag() { }\n+    multiway_mergesort_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using multiway mergesort\n    *  with exact splitting at compile time. */\n   struct multiway_mergesort_exact_tag : public parallel_tag\n   {\n-      multiway_mergesort_exact_tag() { }\n-      multiway_mergesort_exact_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    multiway_mergesort_exact_tag() { }\n+    multiway_mergesort_exact_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using multiway mergesort\n    *  with splitting by sampling at compile time. */\n   struct multiway_mergesort_sampling_tag : public parallel_tag\n   {\n-      multiway_mergesort_sampling_tag() { }\n-      multiway_mergesort_sampling_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    multiway_mergesort_sampling_tag() { }\n+    multiway_mergesort_sampling_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using unbalanced quicksort\n    *  at compile time. */\n   struct quicksort_tag : public parallel_tag\n   {\n-      quicksort_tag() { }\n-      quicksort_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    quicksort_tag() { }\n+    quicksort_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using balanced quicksort\n    *  at compile time. */\n   struct balanced_quicksort_tag : public parallel_tag\n   {\n-      balanced_quicksort_tag() { }\n-      balanced_quicksort_tag(_ThreadIndex __num_threads)\n-          : parallel_tag(__num_threads) { }\n+    balanced_quicksort_tag() { }\n+    balanced_quicksort_tag(_ThreadIndex __num_threads)\n+    : parallel_tag(__num_threads) { }\n   };\n \n "}, {"sha": "1ae5a12316dfc379c6b39bc477a721d763511bf7", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "modified", "additions": 142, "deletions": 137, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -37,155 +37,160 @@\n \n namespace __gnu_parallel\n {\n-\n-/** @brief Parallel std::unique_copy(), w/__o explicit equality predicate.\n-  *  @param __first Begin iterator of input sequence.\n-  *  @param __last End iterator of input sequence.\n-  *  @param __result Begin iterator of result __sequence.\n-  *  @param __binary_pred Equality predicate.\n-  *  @return End iterator of result __sequence. */\n-template<typename _IIter,\n-         class _OutputIterator,\n-         class _BinaryPredicate>\n-  _OutputIterator\n-  __parallel_unique_copy(_IIter __first, _IIter __last,\n-    _OutputIterator __result, _BinaryPredicate __binary_pred)\n-  {\n-    _GLIBCXX_CALL(__last - __first)\n-\n-    typedef std::iterator_traits<_IIter> _TraitsType;\n-    typedef typename _TraitsType::value_type _ValueType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-\n-    _DifferenceType size = __last - __first;\n-\n-    if (size == 0)\n-      return __result;\n-\n-    // Let the first thread process two parts.\n-    _DifferenceType *__counter;\n-    _DifferenceType *__borders;\n-\n-    _ThreadIndex __num_threads = __get_max_threads();\n-    // First part contains at least one element.\n-#   pragma omp parallel num_threads(__num_threads)\n+  /** @brief Parallel std::unique_copy(), w/__o explicit equality predicate.\n+    *  @param __first Begin iterator of input sequence.\n+    *  @param __last End iterator of input sequence.\n+    *  @param __result Begin iterator of result __sequence.\n+    *  @param __binary_pred Equality predicate.\n+    *  @return End iterator of result __sequence. */\n+  template<typename _IIter,\n+           class _OutputIterator,\n+           class _BinaryPredicate>\n+    _OutputIterator\n+    __parallel_unique_copy(_IIter __first, _IIter __last,\n+\t\t\t   _OutputIterator __result,\n+\t\t\t   _BinaryPredicate __binary_pred)\n+    {\n+      _GLIBCXX_CALL(__last - __first)\n+\n+      typedef std::iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      _DifferenceType __size = __last - __first;\n+\n+      if (__size == 0)\n+\treturn __result;\n+\n+      // Let the first thread process two parts.\n+      _DifferenceType *__counter;\n+      _DifferenceType *__borders;\n+\n+      _ThreadIndex __num_threads = __get_max_threads();\n+      // First part contains at least one element.\n+#     pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n+\t  __borders = new _DifferenceType[__num_threads + 2];\n+\t  equally_split(__size, __num_threads + 1, __borders);\n+\t  __counter = new _DifferenceType[__num_threads + 1];\n+\t}\n+\n+\t_ThreadIndex __iam = omp_get_thread_num();\n+\n+\t_DifferenceType __begin, __end;\n+\n+\t// Check for length without duplicates\n+\t// Needed for position in output\n+\t_DifferenceType __i = 0;\n+\t_OutputIterator __out = __result;\n+\n+\tif (__iam == 0)\n           {\n-            __num_threads = omp_get_num_threads();\n-            __borders = new _DifferenceType[__num_threads + 2];\n-            equally_split(size, __num_threads + 1, __borders);\n-            __counter = new _DifferenceType[__num_threads + 1];\n+            __begin = __borders[0] + 1;   // == 1\n+            __end = __borders[__iam + 1];\n+\n+            ++__i;\n+            *__out++ = *__first;\n+\n+            for (_IIter __iter = __first + __begin; __iter < __first + __end;\n+\t\t ++__iter)\n+              {\n+        \tif (!__binary_pred(*__iter, *(__iter - 1)))\n+                  {\n+                    ++__i;\n+                    *__out++ = *__iter;\n+                  }\n+              }\n           }\n+\telse\n+          {\n+            __begin = __borders[__iam]; //one part\n+            __end = __borders[__iam + 1];\n \n-        _ThreadIndex __iam = omp_get_thread_num();\n+            for (_IIter __iter = __first + __begin; __iter < __first + __end;\n+\t\t ++__iter)\n+              {\n+        \tif (!__binary_pred(*__iter, *(__iter - 1)))\n+                  ++__i;\n+              }\n+          }\n+\t__counter[__iam] = __i;\n \n-        _DifferenceType __begin, __end;\n+\t// Last part still untouched.\n+\t_DifferenceType __begin_output;\n \n-        // Check for length without duplicates\n-        // Needed for position in output\n-        _DifferenceType __i = 0;\n-        _OutputIterator __out = __result;\n+#       pragma omp barrier\n \n-        if (__iam == 0)\n-        {\n-          __begin = __borders[0] + 1;   // == 1\n-          __end = __borders[__iam + 1];\n+\t// Store result in output on calculated positions.\n+\t__begin_output = 0;\n \n-          ++__i;\n-          *__out++ = *__first;\n+\tif (__iam == 0)\n+          {\n+            for (int __t = 0; __t < __num_threads; ++__t)\n+              __begin_output += __counter[__t];\n \n-          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n-            {\n-              if (!__binary_pred(*iter, *(iter-1)))\n-                {\n-                  ++__i;\n-                  *__out++ = *iter;\n-                }\n-            }\n-        }\n-      else\n-        {\n-          __begin = __borders[__iam]; //one part\n-          __end = __borders[__iam + 1];\n-\n-          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n-            {\n-              if (!__binary_pred(*iter, *(iter - 1)))\n-                ++__i;\n-            }\n-        }\n-      __counter[__iam] = __i;\n-\n-      // Last part still untouched.\n-      _DifferenceType __begin_output;\n-\n-#     pragma omp barrier\n-\n-      // Store result in output on calculated positions.\n-      __begin_output = 0;\n-\n-      if (__iam == 0)\n-        {\n-          for (int __t = 0; __t < __num_threads; ++__t)\n-            __begin_output += __counter[__t];\n-\n-          __i = 0;\n-\n-          _OutputIterator __iter_out = __result + __begin_output;\n-\n-          __begin = __borders[__num_threads];\n-          __end = size;\n-\n-          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n-            {\n-              if (iter == __first || !__binary_pred(*iter, *(iter - 1)))\n-                {\n-                  ++__i;\n-                  *__iter_out++ = *iter;\n-                }\n-            }\n-\n-          __counter[__num_threads] = __i;\n-        }\n-      else\n-        {\n-          for (int __t = 0; __t < __iam; __t++)\n-            __begin_output += __counter[__t];\n-\n-          _OutputIterator __iter_out = __result + __begin_output;\n-          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n-            {\n-              if (!__binary_pred(*iter, *(iter-1)))\n-                *__iter_out++ = *iter;\n-            }\n-        }\n+            __i = 0;\n+\n+            _OutputIterator __iter_out = __result + __begin_output;\n+\n+            __begin = __borders[__num_threads];\n+            __end = __size;\n+\n+            for (_IIter __iter = __first + __begin; __iter < __first + __end;\n+\t\t ++__iter)\n+              {\n+        \tif (__iter == __first\n+\t\t    || !__binary_pred(*__iter, *(__iter - 1)))\n+                  {\n+                    ++__i;\n+                    *__iter_out++ = *__iter;\n+                  }\n+              }\n+\n+            __counter[__num_threads] = __i;\n+          }\n+\telse\n+          {\n+            for (int __t = 0; __t < __iam; __t++)\n+              __begin_output += __counter[__t];\n+\n+            _OutputIterator __iter_out = __result + __begin_output;\n+            for (_IIter __iter = __first + __begin; __iter < __first + __end;\n+\t\t ++__iter)\n+              {\n+        \tif (!__binary_pred(*__iter, *(__iter - 1)))\n+                  *__iter_out++ = *__iter;\n+              }\n+          }\n+      }\n+\n+      _DifferenceType __end_output = 0;\n+      for (int __t = 0; __t < __num_threads + 1; __t++)\n+\t__end_output += __counter[__t];\n+\n+      delete[] __borders;\n+\n+      return __result + __end_output;\n     }\n \n-    _DifferenceType __end_output = 0;\n-    for (int __t = 0; __t < __num_threads + 1; __t++)\n-      __end_output += __counter[__t];\n-\n-    delete[] __borders;\n-\n-    return __result + __end_output;\n-  }\n-\n-/** @brief Parallel std::unique_copy(), without explicit equality predicate\n-  *  @param __first Begin iterator of input sequence.\n-  *  @param __last End iterator of input sequence.\n-  *  @param __result Begin iterator of result __sequence.\n-  *  @return End iterator of result __sequence. */\n-template<typename _IIter, class _OutputIterator>\n-  inline _OutputIterator\n-  __parallel_unique_copy(_IIter __first, _IIter __last,\n-                       _OutputIterator __result)\n-  {\n-    typedef typename std::iterator_traits<_IIter>::value_type\n-      _ValueType;\n-    return __parallel_unique_copy(__first, __last, __result,\n-                                std::equal_to<_ValueType>());\n-  }\n+  /** @brief Parallel std::unique_copy(), without explicit equality predicate\n+    *  @param __first Begin iterator of input sequence.\n+    *  @param __last End iterator of input sequence.\n+    *  @param __result Begin iterator of result __sequence.\n+    *  @return End iterator of result __sequence. */\n+  template<typename _IIter, class _OutputIterator>\n+    inline _OutputIterator\n+    __parallel_unique_copy(_IIter __first, _IIter __last,\n+\t\t\t   _OutputIterator __result)\n+    {\n+      typedef typename std::iterator_traits<_IIter>::value_type\n+\t_ValueType;\n+      return __parallel_unique_copy(__first, __last, __result,\n+\t\t\t\t    std::equal_to<_ValueType>());\n+    }\n \n }//namespace __gnu_parallel\n "}, {"sha": "4ac155d923fc14b314c292b44c1cd829d5e53c30", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 219, "deletions": 216, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77d16198fc5262198db7ed29609a791104b37fcf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=77d16198fc5262198db7ed29609a791104b37fcf", "patch": "@@ -49,261 +49,264 @@ namespace __gnu_parallel\n \n #define _GLIBCXX_JOB_VOLATILE volatile\n \n-/** @brief One __job for a certain thread. */\n-template<typename _DifferenceTp>\n-  struct _Job\n-  {\n-    typedef _DifferenceTp _DifferenceType;\n-\n-    /** @brief First element.\n-     *\n-     *  Changed by owning and stealing thread. By stealing thread,\n-     *  always incremented. */\n-    _GLIBCXX_JOB_VOLATILE _DifferenceType _M_first;\n-\n-    /** @brief Last element.\n-     *\n-     *  Changed by owning thread only. */\n-    _GLIBCXX_JOB_VOLATILE _DifferenceType _M_last;\n-\n-    /** @brief Number of elements, i.e. @__c _M_last-_M_first+1.\n-     *\n-     *  Changed by owning thread only. */\n-    _GLIBCXX_JOB_VOLATILE _DifferenceType _M_load;\n-  };\n-\n-/** @brief Work stealing algorithm for random access iterators.\n-  *\n-  *  Uses O(1) additional memory. Synchronization at job lists is\n-  *  done with atomic operations.\n-  *  @param __begin Begin iterator of element sequence.\n-  *  @param __end End iterator of element sequence.\n-  *  @param __op User-supplied functor (comparator, predicate, adding\n-  *  functor, ...).\n-  *  @param __f Functor to \"process\" an element with __op (depends on\n-  *  desired functionality, e. g. for std::for_each(), ...).\n-  *  @param __r Functor to \"add\" a single __result to the already\n-  *  processed elements (depends on functionality).\n-  *  @param __base Base value for reduction.\n-  *  @param __output Pointer to position where final result is written to\n-  *  @param __bound Maximum number of elements processed (e. g. for\n-  *  std::count_n()).\n-  *  @return User-supplied functor (that may contain a part of the result).\n-  */\n-template<typename _RAIter,\n-         typename _Op,\n-         typename _Fu,\n-         typename _Red,\n-         typename _Result>\n-  _Op\n-  __for_each_template_random_access_workstealing(\n-    _RAIter __begin, _RAIter __end, _Op __op, _Fu& __f, _Red __r,\n-    _Result __base, _Result& __output,\n-    typename std::iterator_traits<_RAIter>::difference_type __bound)\n-  {\n-    _GLIBCXX_CALL(__end - __begin)\n-\n-    typedef std::iterator_traits<_RAIter> _TraitsType;\n-    typedef typename _TraitsType::difference_type _DifferenceType;\n-    \n-    const _Settings& __s = _Settings::get();\n-\n-    _DifferenceType __chunk_size =\n-        static_cast<_DifferenceType>(__s.workstealing_chunk_size);\n-\n-    // How many jobs?\n-    _DifferenceType __length = (__bound < 0) ? (__end - __begin) : __bound;\n-\n-    // To avoid false sharing in a cache line.\n-    const int __stride =\n-                __s.cache_line_size * 10 / sizeof(_Job<_DifferenceType>) + 1;\n-\n-    // Total number of threads currently working.\n-    _ThreadIndex __busy = 0;\n-\n-    _Job<_DifferenceType> *__job;\n-\n-    omp_lock_t __output_lock;\n-    omp_init_lock(&__output_lock);\n-\n-    // Write base value to output.\n-    __output = __base;\n-\n-    // No more threads than jobs, at least one thread.\n-    _ThreadIndex __num_threads =\n-      __gnu_parallel::max<_ThreadIndex>(1,\n-        __gnu_parallel::min<_DifferenceType>(__length, __get_max_threads()));\n-\n-#   pragma omp parallel shared(__busy) num_threads(__num_threads)\n+  /** @brief One __job for a certain thread. */\n+  template<typename _DifferenceTp>\n+    struct _Job\n+    {\n+      typedef _DifferenceTp _DifferenceType;\n+\n+      /** @brief First element.\n+       *\n+       *  Changed by owning and stealing thread. By stealing thread,\n+       *  always incremented. */\n+      _GLIBCXX_JOB_VOLATILE _DifferenceType _M_first;\n+\n+      /** @brief Last element.\n+       *\n+       *  Changed by owning thread only. */\n+      _GLIBCXX_JOB_VOLATILE _DifferenceType _M_last;\n+\n+      /** @brief Number of elements, i.e. @__c _M_last-_M_first+1.\n+       *\n+       *  Changed by owning thread only. */\n+      _GLIBCXX_JOB_VOLATILE _DifferenceType _M_load;\n+    };\n+\n+  /** @brief Work stealing algorithm for random access iterators.\n+    *\n+    *  Uses O(1) additional memory. Synchronization at job lists is\n+    *  done with atomic operations.\n+    *  @param __begin Begin iterator of element sequence.\n+    *  @param __end End iterator of element sequence.\n+    *  @param __op User-supplied functor (comparator, predicate, adding\n+    *  functor, ...).\n+    *  @param __f Functor to \"process\" an element with __op (depends on\n+    *  desired functionality, e. g. for std::for_each(), ...).\n+    *  @param __r Functor to \"add\" a single __result to the already\n+    *  processed elements (depends on functionality).\n+    *  @param __base Base value for reduction.\n+    *  @param __output Pointer to position where final result is written to\n+    *  @param __bound Maximum number of elements processed (e. g. for\n+    *  std::count_n()).\n+    *  @return User-supplied functor (that may contain a part of the result).\n+    */\n+  template<typename _RAIter,\n+           typename _Op,\n+           typename _Fu,\n+           typename _Red,\n+           typename _Result>\n+    _Op\n+    __for_each_template_random_access_workstealing(_RAIter __begin,\n+\t\t\t\t\t\t   _RAIter __end, _Op __op,\n+\t\t\t\t\t\t   _Fu& __f, _Red __r,\n+\t\t\t\t\t\t   _Result __base,\n+\t\t\t\t\t\t   _Result& __output,\n+      typename std::iterator_traits<_RAIter>::difference_type __bound)\n+    {\n+      _GLIBCXX_CALL(__end - __begin)\n+\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n+\n+      const _Settings& __s = _Settings::get();\n+\n+      _DifferenceType __chunk_size =\n+          static_cast<_DifferenceType>(__s.workstealing_chunk_size);\n+\n+      // How many jobs?\n+      _DifferenceType __length = (__bound < 0) ? (__end - __begin) : __bound;\n+\n+      // To avoid false sharing in a cache line.\n+      const int __stride = (__s.cache_line_size * 10\n+\t\t\t    / sizeof(_Job<_DifferenceType>) + 1);\n+\n+      // Total number of threads currently working.\n+      _ThreadIndex __busy = 0;\n+\n+      _Job<_DifferenceType> *__job;\n+\n+      omp_lock_t __output_lock;\n+      omp_init_lock(&__output_lock);\n+\n+      // Write base value to output.\n+      __output = __base;\n+\n+      // No more threads than jobs, at least one thread.\n+      _ThreadIndex __num_threads = __gnu_parallel::max<_ThreadIndex>\n+\t(1, __gnu_parallel::min<_DifferenceType>(__length,\n+\t\t\t\t\t\t __get_max_threads()));\n+\n+#     pragma omp parallel shared(__busy) num_threads(__num_threads)\n       {\n-\n #       pragma omp single\n-          {\n-            __num_threads = omp_get_num_threads();\n+\t{\n+\t  __num_threads = omp_get_num_threads();\n \n-            // Create job description array.\n-            __job = new _Job<_DifferenceType>[__num_threads * __stride];\n-          }\n+\t  // Create job description array.\n+\t  __job = new _Job<_DifferenceType>[__num_threads * __stride];\n+\t}\n \n-        // Initialization phase.\n+\t// Initialization phase.\n \n-        // Flags for every thread if it is doing productive work.\n-        bool __iam_working = false;\n+\t// Flags for every thread if it is doing productive work.\n+\tbool __iam_working = false;\n \n-        // Thread id.\n-        _ThreadIndex __iam = omp_get_thread_num();\n+\t// Thread id.\n+\t_ThreadIndex __iam = omp_get_thread_num();\n \n-        // This job.\n-        _Job<_DifferenceType>& __my_job = __job[__iam * __stride];\n+\t// This job.\n+\t_Job<_DifferenceType>& __my_job = __job[__iam * __stride];\n \n-        // Random number (for work stealing).\n-        _ThreadIndex __victim;\n+\t// Random number (for work stealing).\n+\t_ThreadIndex __victim;\n \n-        // Local value for reduction.\n-        _Result __result = _Result();\n+\t// Local value for reduction.\n+\t_Result __result = _Result();\n \n-        // Number of elements to steal in one attempt.\n-        _DifferenceType __steal;\n+\t// Number of elements to steal in one attempt.\n+\t_DifferenceType __steal;\n \n-        // Every thread has its own random number generator\n-        // (modulo __num_threads).\n-        _RandomNumber rand_gen(__iam, __num_threads);\n+\t// Every thread has its own random number generator\n+\t// (modulo __num_threads).\n+\t_RandomNumber __rand_gen(__iam, __num_threads);\n \n-        // This thread is currently working.\n+\t// This thread is currently working.\n #       pragma omp atomic\n-          ++__busy;\n+\t++__busy;\n \n-        __iam_working = true;\n+\t__iam_working = true;\n \n-        // How many jobs per thread? last thread gets the rest.\n-        __my_job._M_first =\n-            static_cast<_DifferenceType>(__iam * (__length / __num_threads));\n+\t// How many jobs per thread? last thread gets the rest.\n+\t__my_job._M_first = static_cast<_DifferenceType>\n+\t  (__iam * (__length / __num_threads));\n \n-        __my_job._M_last = (__iam == (__num_threads - 1)) ?\n-            (__length - 1) : ((__iam + 1) * (__length / __num_threads) - 1);\n-        __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n+\t__my_job._M_last = (__iam == (__num_threads - 1)\n+\t\t\t    ? (__length - 1)\n+\t\t\t    : ((__iam + 1) * (__length / __num_threads) - 1));\n+\t__my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n \n-        // Init result with _M_first value (to have a base value for reduction)\n-        if (__my_job._M_first <= __my_job._M_last)\n-          {\n-            // Cannot use volatile variable directly.\n-            _DifferenceType __my_first = __my_job._M_first;\n-            __result = __f(__op, __begin + __my_first);\n-            ++__my_job._M_first;\n-            --__my_job._M_load;\n-          }\n+\t// Init result with _M_first value (to have a base value for reduction)\n+\tif (__my_job._M_first <= __my_job._M_last)\n+\t  {\n+\t    // Cannot use volatile variable directly.\n+\t    _DifferenceType __my_first = __my_job._M_first;\n+\t    __result = __f(__op, __begin + __my_first);\n+\t    ++__my_job._M_first;\n+\t    --__my_job._M_load;\n+\t  }\n \n-        _RAIter __current;\n+\t_RAIter __current;\n \n #       pragma omp barrier\n \n-        // Actual work phase\n-        // Work on own or stolen current start\n-        while (__busy > 0)\n-          {\n-            // Work until no productive thread left.\n+\t// Actual work phase\n+\t// Work on own or stolen current start\n+\twhile (__busy > 0)\n+\t  {\n+\t    // Work until no productive thread left.\n #           pragma omp flush(__busy)\n \n-            // Thread has own work to do\n-            while (__my_job._M_first <= __my_job._M_last)\n-              {\n-                // fetch-and-add call\n-                // Reserve current job block (size __chunk_size) in my queue.\n-                _DifferenceType __current_job =\n-                  __fetch_and_add<_DifferenceType>(\n-                    &(__my_job._M_first), __chunk_size);\n-\n-                // Update _M_load, to make the three values consistent,\n-                // _M_first might have been changed in the meantime\n-                __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n-                for (_DifferenceType __job_counter = 0;\n-                     __job_counter < __chunk_size\n-                       && __current_job <= __my_job._M_last;\n-                     ++__job_counter)\n-                  {\n-                    // Yes: process it!\n-                    __current = __begin + __current_job;\n-                    ++__current_job;\n-\n-                    // Do actual work.\n-                    __result = __r(__result, __f(__op, __current));\n-                  }\n+\t    // Thread has own work to do\n+\t    while (__my_job._M_first <= __my_job._M_last)\n+\t      {\n+\t\t// fetch-and-add call\n+\t\t// Reserve current job block (size __chunk_size) in my queue.\n+\t\t_DifferenceType __current_job =\n+\t\t  __fetch_and_add<_DifferenceType>(&(__my_job._M_first),\n+\t\t\t\t\t\t   __chunk_size);\n+\n+\t\t// Update _M_load, to make the three values consistent,\n+\t\t// _M_first might have been changed in the meantime\n+\t\t__my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n+\t\tfor (_DifferenceType __job_counter = 0;\n+\t\t     __job_counter < __chunk_size\n+\t\t       && __current_job <= __my_job._M_last;\n+\t\t     ++__job_counter)\n+\t\t  {\n+\t\t    // Yes: process it!\n+\t\t    __current = __begin + __current_job;\n+\t\t    ++__current_job;\n+\n+\t\t    // Do actual work.\n+\t\t    __result = __r(__result, __f(__op, __current));\n+\t\t  }\n \n #               pragma omp flush(__busy)\n-              }\n+\t      }\n \n-            // After reaching this point, a thread's __job list is empty.\n-            if (__iam_working)\n-              {\n-                // This thread no longer has work.\n+\t    // After reaching this point, a thread's __job list is empty.\n+\t    if (__iam_working)\n+\t      {\n+\t\t// This thread no longer has work.\n #               pragma omp atomic\n-                --__busy;\n+\t\t--__busy;\n \n-                __iam_working = false;\n-              }\n+\t\t__iam_working = false;\n+\t      }\n \n-            _DifferenceType __supposed_first, __supposed_last, __supposed_load;\n-            do\n-              {\n-                // Find random nonempty deque (not own), do consistency check.\n-                __yield();\n+\t    _DifferenceType __supposed_first, __supposed_last,\n+\t                    __supposed_load;\n+\t    do\n+\t      {\n+\t\t// Find random nonempty deque (not own), do consistency check.\n+\t\t__yield();\n #               pragma omp flush(__busy)\n-                __victim = rand_gen();\n-                __supposed_first = __job[__victim * __stride]._M_first;\n-                __supposed_last = __job[__victim * __stride]._M_last;\n-                __supposed_load = __job[__victim * __stride]._M_load;\n-              }\n-            while (__busy > 0\n-              && ((__supposed_load <= 0)\n-                || ((__supposed_first + __supposed_load - 1)\n-                                                         != __supposed_last)));\n-\n-            if (__busy == 0)\n-              break;\n-\n-            if (__supposed_load > 0)\n-              {\n-                // Has work and work to do.\n-                // Number of elements to steal (at least one).\n-                __steal = (__supposed_load < 2) ? 1 : __supposed_load / 2;\n-\n-                // Push __victim's current start forward.\n-                _DifferenceType __stolen_first =\n-                    __fetch_and_add<_DifferenceType>(\n-                        &(__job[__victim * __stride]._M_first), __steal);\n-                _DifferenceType __stolen_try =\n-                    __stolen_first + __steal - _DifferenceType(1);\n-\n-                __my_job._M_first = __stolen_first;\n-                __my_job._M_last =\n-                  __gnu_parallel::min(__stolen_try, __supposed_last);\n-                __my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n-\n-                // Has potential work again.\n+\t\t__victim = __rand_gen();\n+\t\t__supposed_first = __job[__victim * __stride]._M_first;\n+\t\t__supposed_last = __job[__victim * __stride]._M_last;\n+\t\t__supposed_load = __job[__victim * __stride]._M_load;\n+\t      }\n+\t    while (__busy > 0\n+\t\t   && ((__supposed_load <= 0)\n+\t\t       || ((__supposed_first + __supposed_load - 1)\n+\t\t\t   != __supposed_last)));\n+\n+\t    if (__busy == 0)\n+\t      break;\n+\n+\t    if (__supposed_load > 0)\n+\t      {\n+\t\t// Has work and work to do.\n+\t\t// Number of elements to steal (at least one).\n+\t\t__steal = (__supposed_load < 2) ? 1 : __supposed_load / 2;\n+\n+\t\t// Push __victim's current start forward.\n+\t\t_DifferenceType __stolen_first =\n+\t\t  __fetch_and_add<_DifferenceType>\n+\t\t  (&(__job[__victim * __stride]._M_first), __steal);\n+\t\t_DifferenceType __stolen_try = (__stolen_first + __steal\n+\t\t\t\t\t\t- _DifferenceType(1));\n+\n+\t\t__my_job._M_first = __stolen_first;\n+\t\t__my_job._M_last = __gnu_parallel::min(__stolen_try,\n+\t\t\t\t\t\t       __supposed_last);\n+\t\t__my_job._M_load = __my_job._M_last - __my_job._M_first + 1;\n+\n+\t\t// Has potential work again.\n #               pragma omp atomic\n-                  ++__busy;\n-                __iam_working = true;\n+\t\t++__busy;\n+\t\t__iam_working = true;\n \n #               pragma omp flush(__busy)\n-              }\n+\t      }\n #           pragma omp flush(__busy)\n-          } // end while __busy > 0\n-            // Add accumulated result to output.\n-        omp_set_lock(&__output_lock);\n-        __output = __r(__output, __result);\n-        omp_unset_lock(&__output_lock);\n+\t  } // end while __busy > 0\n+\t// Add accumulated result to output.\n+\tomp_set_lock(&__output_lock);\n+\t__output = __r(__output, __result);\n+\tomp_unset_lock(&__output_lock);\n       }\n \n-    delete[] __job;\n+      delete[] __job;\n \n-    // Points to last element processed (needed as return value for\n-    // some algorithms like transform)\n-    __f._M_finish_iterator = __begin + __length;\n+      // Points to last element processed (needed as return value for\n+      // some algorithms like transform)\n+      __f._M_finish_iterator = __begin + __length;\n \n-    omp_destroy_lock(&__output_lock);\n+      omp_destroy_lock(&__output_lock);\n \n-    return __op;\n-  }\n+      return __op;\n+    }\n } // end namespace\n \n #endif /* _GLIBCXX_PARALLEL_WORKSTEALING_H */"}]}