{"sha": "fa539f518911a5dbc968cc19ac4efb4d47e92dca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1MzlmNTE4OTExYTVkYmM5NjhjYzE5YWM0ZWZiNGQ0N2U5MmRjYQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-26T16:56:01Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-26T16:56:01Z"}, "message": "In libobjc/: 2010-12-26 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* init.c (create_tree_of_subclasses_inherited_from): Use\n\tclass_superclass_of_class instead of assuming a class is\n\tunresolved when it could be resolved.  Tidied up code.\n\t(__objc_tree_insert_class): Enhanced DEBUG_PRINTF.\n\t(objc_tree_insert_class): Tidied up loop; return immediately upon\n\tinserting a class.\n\t(__objc_exec_class): Do not set __objc_class_tree_list.\n\t\nIn gcc/testsuite/:\n2010-12-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc.dg/special/special.exp: Added load-category-2 and\n\tload-category-3 tests.\n\t* objc.dg/special/load-category-2.h: New.\n\t* objc.dg/special/load-category-2.m: New.\n\t* objc.dg/special/load-category-2a.m: New.\n\t* objc.dg/special/load-category-3.h: New.\n\t* objc.dg/special/load-category-3.m: New.\n\t* objc.dg/special/load-category-3a.m: New.\n\nFrom-SVN: r168251", "tree": {"sha": "9afb8d01c5cabd3c92124fa20618610e8e140b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9afb8d01c5cabd3c92124fa20618610e8e140b0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa539f518911a5dbc968cc19ac4efb4d47e92dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa539f518911a5dbc968cc19ac4efb4d47e92dca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa539f518911a5dbc968cc19ac4efb4d47e92dca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa539f518911a5dbc968cc19ac4efb4d47e92dca/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8a64a9ad396972a6019efe0112fedff691beae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a64a9ad396972a6019efe0112fedff691beae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a64a9ad396972a6019efe0112fedff691beae7"}], "stats": {"total": 494, "additions": 461, "deletions": 33}, "files": [{"sha": "c4a012b9c7c660802a9e5feba163831b563662d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -1,3 +1,14 @@\n+2010-12-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/special/special.exp: Added load-category-2 and\n+\tload-category-3 tests.\n+\t* objc.dg/special/load-category-2.h: New.\n+\t* objc.dg/special/load-category-2.m: New.\n+\t* objc.dg/special/load-category-2a.m: New.\n+\t* objc.dg/special/load-category-3.h: New.\n+\t* objc.dg/special/load-category-3.m: New.\n+\t* objc.dg/special/load-category-3a.m: New.\n+\n 2010-12-25  Ira Rosen  <irar@il.ibm.com>\n \n \tPR testsuite/47057"}, {"sha": "ae7e84278af920cda517ebebd168bc2202e7b798", "filename": "gcc/testsuite/objc.dg/special/load-category-2.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2.h?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -0,0 +1,19 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+\n+/* Test the order of calling +load between classes and categories.  */\n+\n+void complete_load_step (int load_step);\n+void check_that_load_step_was_completed (int load_step);\n+void check_that_load_step_was_not_completed (int load_step);\n+\n+@interface TestClass1\n+{\n+  id isa;\n+}\n+@end\n+\n+@interface TestClass2 : TestClass1\n+@end\n+\n+@interface TestClass3 : TestClass2\n+@end"}, {"sha": "6fd99fd2335b4c088c3c6d9eeac8d77ea6b17d37", "filename": "gcc/testsuite/objc.dg/special/load-category-2.m", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2.m?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -0,0 +1,106 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+#include \"load-category-2.h\"\n+\n+/* This test tests that +load is called in the correct order for\n+   classes and categories.  +load needs to be called in superclasses\n+   before subclasses, and in the main class before categories.  */\n+\n+/* Compile the classes in random order to prevent the runtime from\n+   sending +load in the correct order just because the classes happen\n+   to have been compiled in that order.  */\n+@implementation TestClass2\n++ load\n+{\n+  printf (\"[TestClass2 +load]\\n\");\n+  /* Check superclasses/subclasses +load order.  */\n+  check_that_load_step_was_completed (0);\n+  check_that_load_step_was_not_completed (1);\n+  check_that_load_step_was_not_completed (2);\n+\n+  /* Check that the corresponding category's +load was not done.  */\n+  check_that_load_step_was_not_completed (4);\n+\n+  complete_load_step (1);\n+}\n+@end\n+\n+@implementation TestClass3\n++ load\n+{\n+  printf (\"[TestClass3 +load]\\n\");\n+\n+  /* Check superclasses/subclasses +load order.  */\n+  check_that_load_step_was_completed (0);\n+  check_that_load_step_was_completed (1);\n+  check_that_load_step_was_not_completed (2);\n+\n+  /* Check that the corresponding category's +load was not done.  */\n+  check_that_load_step_was_not_completed (5);\n+\n+  complete_load_step (2);\n+}\n+@end\n+\n+@implementation TestClass1\n++ initialize { return self; }\n++ load\n+{\n+  printf (\"[TestClass1 +load]\\n\");\n+\n+  /* Check superclasses/subclasses +load order.  */\n+  check_that_load_step_was_not_completed (0);\n+  check_that_load_step_was_not_completed (1);\n+  check_that_load_step_was_not_completed (2);\n+\n+  /* Check that the corresponding category's +load was not done.  */\n+  check_that_load_step_was_not_completed (3);\n+\n+  complete_load_step (0);\n+}\n+@end\n+\n+\n+static BOOL load_step_completed[6] = { NO, NO, NO, NO, NO, NO };\n+\n+void complete_load_step (int load_step)\n+{\n+  load_step_completed[load_step] = YES;\n+}\n+\n+void check_that_load_step_was_completed (int load_step)\n+{\n+  if (load_step_completed[load_step] == NO)\n+    {\n+      printf (\"Load step %d was not completed but should have been\\n\", load_step);\n+      abort ();\n+    }\n+}\n+\n+void check_that_load_step_was_not_completed (int load_step)\n+{\n+  if (load_step_completed[load_step] == YES)\n+    {\n+      printf (\"Load step %d was completed but shouldn't have been\\n\", load_step);\n+      abort ();\n+    }\n+}\n+\n+int main (void)\n+{\n+  check_that_load_step_was_completed (0);\n+  check_that_load_step_was_completed (1);\n+  check_that_load_step_was_completed (2);\n+  check_that_load_step_was_completed (3);\n+  check_that_load_step_was_completed (4);\n+  check_that_load_step_was_completed (5);\n+\n+  return 0;\n+}"}, {"sha": "f4e0af11d74cb44f544650860cfc927f28ec1b20", "filename": "gcc/testsuite/objc.dg/special/load-category-2a.m", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2a.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2a.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-2a.m?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -0,0 +1,47 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+#include \"load-category-2.h\"\n+\n+/* Compile the categories in random order to prevent the runtime from\n+   sending +load in the correct order just because the classes happen\n+   to have been compiled in that order.  */\n+@implementation TestClass2 (Category)\n++ load\n+{\n+  printf (\"[TestClass2(Category) +load]\\n\");\n+\n+  /* Check that the corresponding class's +load was done.  */\n+  check_that_load_step_was_completed (1);\n+\n+  complete_load_step (4);\n+}\n+@end\n+\n+@implementation TestClass3 (Category)\n++ load\n+{\n+  printf (\"[TestClass3(Category) +load]\\n\");\n+\n+  /* Check that the corresponding class's +load was done.  */\n+  check_that_load_step_was_completed (2);\n+\n+  complete_load_step (5);\n+}\n+@end\n+\n+@implementation TestClass1 (Category)\n++ load\n+{\n+  printf (\"[TestClass1(Category) +load]\\n\");\n+\n+  /* Check that the corresponding class's +load was done.  */\n+  check_that_load_step_was_completed (0);\n+\n+  complete_load_step (3);\n+}\n+@end"}, {"sha": "9d6d8acc90adebfc163a08a28e11e3c95206b349", "filename": "gcc/testsuite/objc.dg/special/load-category-3.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3.h?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -0,0 +1,17 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+\n+void complete_load_step (int load_step);\n+void check_that_load_step_was_completed (int load_step);\n+void check_that_load_step_was_not_completed (int load_step);\n+\n+@interface TestClass1\n+{\n+  id isa;\n+}\n+@end\n+\n+@interface TestClass2 : TestClass1\n+@end\n+\n+@interface TestClass3 : TestClass2\n+@end"}, {"sha": "c32f3ef23041d79129999c49fc3c60f911c4d599", "filename": "gcc/testsuite/objc.dg/special/load-category-3.m", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3.m?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -0,0 +1,88 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* This test is identical to load-category-2, but the classes and\n+   categories are created in inverted order in the modules, to test\n+   that you can load classes first, or categories first, and it all\n+   still works in both cases.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+#include \"load-category-3.h\"\n+\n+@implementation TestClass2 (Category)\n++ load\n+{\n+  printf (\"[TestClass2(Category) +load]\\n\");\n+\n+  /* Check that the corresponding class's +load was done.  */\n+  check_that_load_step_was_completed (1);\n+\n+  complete_load_step (4);\n+}\n+@end\n+\n+@implementation TestClass3 (Category)\n++ load\n+{\n+  printf (\"[TestClass3(Category) +load]\\n\");\n+\n+  /* Check that the corresponding class's +load was done.  */\n+  check_that_load_step_was_completed (2);\n+\n+  complete_load_step (5);\n+}\n+@end\n+\n+@implementation TestClass1 (Category)\n++ load\n+{\n+  printf (\"[TestClass1(Category) +load]\\n\");\n+\n+  /* Check that the corresponding class's +load was done.  */\n+  check_that_load_step_was_completed (0);\n+\n+  complete_load_step (3);\n+}\n+@end\n+\n+static BOOL load_step_completed[6] = { NO, NO, NO, NO, NO, NO };\n+\n+void complete_load_step (int load_step)\n+{\n+  load_step_completed[load_step] = YES;\n+}\n+\n+void check_that_load_step_was_completed (int load_step)\n+{\n+  if (load_step_completed[load_step] == NO)\n+    {\n+      printf (\"Load step %d was not completed but should have been\\n\", load_step);\n+      abort ();\n+    }\n+}\n+\n+void check_that_load_step_was_not_completed (int load_step)\n+{\n+  if (load_step_completed[load_step] == YES)\n+    {\n+      printf (\"Load step %d was completed but shouldn't have been\\n\", load_step);\n+      abort ();\n+    }\n+}\n+\n+int main (void)\n+{\n+  check_that_load_step_was_completed (0);\n+  check_that_load_step_was_completed (1);\n+  check_that_load_step_was_completed (2);\n+  check_that_load_step_was_completed (3);\n+  check_that_load_step_was_completed (4);\n+  check_that_load_step_was_completed (5);\n+\n+  return 0;\n+}"}, {"sha": "a16fe6f73d246766150a2d27f7e07dfe135017b2", "filename": "gcc/testsuite/objc.dg/special/load-category-3a.m", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3a.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3a.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-3a.m?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -0,0 +1,66 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+\n+/* This test is identical to load-category-2, but the classes and\n+   categories are created in inverted order in the modules, to test\n+   that you can load classes first, or categories first, and it all\n+   still works.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+#include \"load-category-3.h\"\n+\n+@implementation TestClass2\n++ load\n+{\n+  printf (\"[TestClass2 +load]\\n\");\n+  /* Check superclasses/subclasses +load order.  */\n+  check_that_load_step_was_completed (0);\n+  check_that_load_step_was_not_completed (1);\n+  check_that_load_step_was_not_completed (2);\n+\n+  /* Check that the corresponding category's +load was not done.  */\n+  check_that_load_step_was_not_completed (4);\n+\n+  complete_load_step (1);\n+}\n+@end\n+\n+@implementation TestClass3\n++ load\n+{\n+  printf (\"[TestClass3 +load]\\n\");\n+\n+  /* Check superclasses/subclasses +load order.  */\n+  check_that_load_step_was_completed (0);\n+  check_that_load_step_was_completed (1);\n+  check_that_load_step_was_not_completed (2);\n+\n+  /* Check that the corresponding category's +load was not done.  */\n+  check_that_load_step_was_not_completed (5);\n+\n+  complete_load_step (2);\n+}\n+@end\n+\n+@implementation TestClass1\n++ initialize { return self; }\n++ load\n+{\n+  printf (\"[TestClass1 +load]\\n\");\n+\n+  /* Check superclasses/subclasses +load order.  */\n+  check_that_load_step_was_not_completed (0);\n+  check_that_load_step_was_not_completed (1);\n+  check_that_load_step_was_not_completed (2);\n+\n+  /* Check that the corresponding category's +load was not done.  */\n+  check_that_load_step_was_not_completed (3);\n+\n+  complete_load_step (0);\n+}\n+@end\n+\n+"}, {"sha": "bab6798d97a4dea0c95f25b152c3ec110eaa7dce", "filename": "gcc/testsuite/objc.dg/special/special.exp", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fspecial.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fspecial.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fspecial.exp?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -27,6 +27,9 @@ if ![info exists DEFAULT_CFLAGS] then {\n # Initialize `dg'.\n dg-init\n \n+# TODO: All these testcases compile and link two Objective-C modules.\n+# Remove code duplication and factor the common code out.\n+\n #\n # unclaimed-category-1 test\n #\n@@ -83,6 +86,60 @@ if ![string match \"\" $lines] then {\n }\n }\n \n+#\n+# load-category-2 test\n+#\n+# This test is similar to the one above.  We compile load-category-2.m\n+# and load-category-2a.m, link them together, and execute the result.\n+set add_flags \"additional_flags=-I${srcdir}/../../libobjc\"\n+lappend add_flags \"additional_flags=-fgnu-runtime\"\n+set lines [objc_target_compile \"$srcdir/$subdir/load-category-2a.m\" \"load-category-2a.o\" object $add_flags ]\n+if ![string match \"\" $lines] then {\n+    fail \"load-category-2a.o\"\n+} else {\n+    dg-runtest \"$srcdir/$subdir/load-category-2.m\" \"load-category-2a.o\" \"-I${srcdir}/../../libobjc -fgnu-runtime\"\n+    file delete load-category-2a.o\n+}\n+\n+if [istarget \"*-*-darwin*\" ] {\n+set add_flags \"\"\n+lappend add_flags \"additional_flags=-fnext-runtime\"\n+set lines [objc_target_compile \"$srcdir/$subdir/load-category-2a.m\" \"load-category-2a.o\" object $add_flags ]\n+if ![string match \"\" $lines] then {\n+    fail \"load-category-2a.o\"\n+} else {\n+    dg-runtest \"$srcdir/$subdir/load-category-2.m\" \"load-category-2a.o\" \"-fnext-runtime\"\n+    file delete load-category-2a.o\n+}\n+}\n+\n+#\n+# load-category-3 test\n+#\n+# This test is similar to the one above.  We compile load-category-3.m\n+# and load-category-3a.m, link them together, and execute the result.\n+set add_flags \"additional_flags=-I${srcdir}/../../libobjc\"\n+lappend add_flags \"additional_flags=-fgnu-runtime\"\n+set lines [objc_target_compile \"$srcdir/$subdir/load-category-3a.m\" \"load-category-3a.o\" object $add_flags ]\n+if ![string match \"\" $lines] then {\n+    fail \"load-category-3a.o\"\n+} else {\n+    dg-runtest \"$srcdir/$subdir/load-category-3.m\" \"load-category-3a.o\" \"-I${srcdir}/../../libobjc -fgnu-runtime\"\n+    file delete load-category-3a.o\n+}\n+\n+if [istarget \"*-*-darwin*\" ] {\n+set add_flags \"\"\n+lappend add_flags \"additional_flags=-fnext-runtime\"\n+set lines [objc_target_compile \"$srcdir/$subdir/load-category-3a.m\" \"load-category-3a.o\" object $add_flags ]\n+if ![string match \"\" $lines] then {\n+    fail \"load-category-3a.o\"\n+} else {\n+    dg-runtest \"$srcdir/$subdir/load-category-3.m\" \"load-category-3a.o\" \"-fnext-runtime\"\n+    file delete load-category-3a.o\n+}\n+}\n+\n # All done.\n dg-finish\n "}, {"sha": "bb00682b80f47fac6f77b57b90b96ded3107cb62", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -1,3 +1,14 @@\n+2010-12-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* init.c (create_tree_of_subclasses_inherited_from): Use\n+\tclass_superclass_of_class instead of assuming a class is\n+\tunresolved when it could be resolved.  Tidied up assignment and\n+\tcheck.\n+\t(__objc_tree_insert_class): Enhanced DEBUG_PRINTF.\n+\t(objc_tree_insert_class): Tidied up loop; return immediately upon\n+\tinserting a class.\n+\t(__objc_exec_class): Do not set __objc_class_tree_list.\n+\t\n 2010-12-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* selector.c (sel_getTypedSelector): Return NULL if given a NULL"}, {"sha": "d4475b3b787a3742a0952bfc64099a7b591137f9", "filename": "libobjc/init.c", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa539f518911a5dbc968cc19ac4efb4d47e92dca/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa539f518911a5dbc968cc19ac4efb4d47e92dca/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=fa539f518911a5dbc968cc19ac4efb4d47e92dca", "patch": "@@ -109,9 +109,9 @@ BOOL __objc_dangling_categories = NO;           /* !T:UNUSED */\n static void objc_send_load (void);\n \n /* Inserts all the classes defined in module in a tree of classes that\n-   resembles the class hierarchy. This tree is traversed in preorder\n+   resembles the class hierarchy.  This tree is traversed in preorder\n    and the classes in its nodes receive the +load message if these\n-   methods were not executed before. The algorithm ensures that when\n+   methods were not executed before.  The algorithm ensures that when\n    the +load method of a class is executed all the superclasses have\n    been already received the +load message.  */\n static void __objc_create_classes_tree (struct objc_module *module);\n@@ -124,15 +124,22 @@ static void __objc_call_load_callback (struct objc_module *module);\n    installed in the runtime.  */\n static BOOL class_is_subclass_of_class (Class class, Class superclass);\n \n+/* This is a node in the class tree hierarchy used to send +load\n+   messages.  */\n typedef struct objc_class_tree\n {\n+  /* The class corresponding to the node.  */\n   Class class;\n-  struct objc_list *subclasses; /* `head' is a pointer to an\n-\t\t\t\t   objc_class_tree.  */\n+\n+  /* This is a linked list of all the direct subclasses of this class.\n+     'head' points to a subclass node; 'tail' points to the next\n+     objc_list node (whose 'head' points to another subclass node,\n+     etc).  */\n+  struct objc_list *subclasses;\n } objc_class_tree;\n \n-/* This is a linked list of objc_class_tree trees. The head of these\n-   trees are root classes (their super class is Nil). These different\n+/* This is a linked list of objc_class_tree trees.  The head of these\n+   trees are root classes (their super class is Nil).  These different\n    trees represent different class hierarchies.  */\n static struct objc_list *__objc_class_tree_list = NULL;\n \n@@ -145,7 +152,7 @@ static cache_ptr __objc_load_methods = NULL;\n    is really needed so that superclasses will get the message before\n    subclasses.\n \n-   This tree will contain classes which are being loaded (or have just\n+   This tree may contain classes which are being loaded (or have just\n    being loaded), and whose super_class pointers have not yet been\n    resolved.  This implies that their super_class pointers point to a\n    string with the name of the superclass; when the first message is\n@@ -184,29 +191,30 @@ static Class  class_superclass_of_class (Class class)\n \n \n /* Creates a tree of classes whose topmost class is directly inherited\n-   from `upper' and the bottom class in this tree is\n-   `bottom_class'. The classes in this tree are super classes of\n-   `bottom_class'. `subclasses' member of each tree node point to the\n-   next subclass tree node.  */\n+   from `upper' and the bottom class in this tree is `bottom_class'.\n+   If `upper' is Nil, creates a class hierarchy up to a root class.\n+   The classes in this tree are super classes of `bottom_class'.  The\n+   `subclasses' member of each tree node point to the list of\n+   subclasses for the node.  */\n static objc_class_tree *\n create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n {\n   Class superclass;\n   objc_class_tree *tree, *prev;\n \n-  if (bottom_class->super_class)\n-    superclass = objc_getClass ((char *) bottom_class->super_class);\n-  else\n-    superclass = Nil;\n-\n   DEBUG_PRINTF (\"create_tree_of_subclasses_inherited_from:\");\n   DEBUG_PRINTF (\" bottom_class = %s, upper = %s\\n\",\n \t\t(bottom_class ? bottom_class->name : NULL),\n \t\t(upper ? upper->name : NULL));\n \n-  tree = prev = objc_calloc (1, sizeof (objc_class_tree));\n+  superclass = class_superclass_of_class (bottom_class);\n+\n+  prev = objc_calloc (1, sizeof (objc_class_tree));\n   prev->class = bottom_class;\n \n+  if (superclass == upper)\n+    return prev;\n+\n   while (superclass != upper)\n     {\n       tree = objc_calloc (1, sizeof (objc_class_tree));\n@@ -220,16 +228,16 @@ create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n }\n \n /* Insert the `class' into the proper place in the `tree' class\n-   hierarchy. This function returns a new tree if the class has been\n+   hierarchy.  This function returns a new tree if the class has been\n    successfully inserted into the tree or NULL if the class is not\n-   part of the classes hierarchy described by `tree'. This function is\n-   private to objc_tree_insert_class (), you should not call it\n+   part of the classes hierarchy described by `tree'.  This function\n+   is private to objc_tree_insert_class (), you should not call it\n    directly.  */\n static objc_class_tree *\n __objc_tree_insert_class (objc_class_tree *tree, Class class)\n {\n-  DEBUG_PRINTF (\"__objc_tree_insert_class: tree = %p, class = %s\\n\",\n-\t\ttree, class->name);\n+  DEBUG_PRINTF (\"__objc_tree_insert_class: tree = %p (root: %s), class = %s\\n\",\n+\t\ttree, ((tree && tree->class) ? tree->class->name : \"Nil\"), class->name);\n \n   if (tree == NULL)\n     return create_tree_of_subclasses_inherited_from (class, NULL);\n@@ -315,27 +323,26 @@ objc_tree_insert_class (Class class)\n {\n   struct objc_list *list_node;\n   objc_class_tree *tree;\n-\n+  \n   list_node = __objc_class_tree_list;\n   while (list_node)\n     {\n+      /* Try to insert the class in this class hierarchy.  */\n       tree = __objc_tree_insert_class (list_node->head, class);\n       if (tree)\n \t{\n \t  list_node->head = tree;\n-\t  break;\n+\t  return;\n \t}\n       else\n \tlist_node = list_node->tail;\n     }\n-\n-  /* If the list was finished but the class hasn't been inserted,\n-     insert it here.  */\n-  if (! list_node)\n-    {\n-      __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n-      __objc_class_tree_list->head = __objc_tree_insert_class (NULL, class);\n-    }\n+  \n+  /* If the list was finished but the class hasn't been inserted, we\n+     don't have an existing class hierarchy that can accomodate it.\n+     Create a new one.  */\n+  __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n+  __objc_class_tree_list->head = __objc_tree_insert_class (NULL, class);\n }\n \n /* Traverse tree in preorder. Used to send +load.  */\n@@ -603,7 +610,6 @@ __objc_exec_class (struct objc_module *module)\n       duplicate_classes = objc_hash_new (8,\n \t\t\t\t\t (hash_func_type)objc_hash_ptr,\n \t\t\t\t\t objc_compare_ptrs);\n-      __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n       __objc_load_methods = objc_hash_new (128, \n \t\t\t\t\t   (hash_func_type)objc_hash_ptr,\n \t\t\t\t\t   objc_compare_ptrs);"}]}