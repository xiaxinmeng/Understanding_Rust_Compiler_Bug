{"sha": "2d130b315dfc09b83b40d41447d5eb4a617843c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQxMzBiMzE1ZGZjMDliODNiNDBkNDE0NDdkNWViNGE2MTc4NDNjNg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-01-05T21:50:20Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-01-05T21:50:20Z"}, "message": "re PR target/51681 (ICE in gcc.dg/torture/vshuf-v2si.c on ia64)\n\n\tPR target/51681\n\t* config/ia64/ia64.c (expand_vec_perm_shrp): Use correct operands\n\tfor shrp pattern.  Correctly handle and fixup shift variable.\n\tReturn false when shift > nelt for BYTES_BIG_ENDIAN target.\n\nFrom-SVN: r182931", "tree": {"sha": "e356db11649d2042c065b8aa3921faacaffc4730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e356db11649d2042c065b8aa3921faacaffc4730"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d130b315dfc09b83b40d41447d5eb4a617843c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d130b315dfc09b83b40d41447d5eb4a617843c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d130b315dfc09b83b40d41447d5eb4a617843c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d130b315dfc09b83b40d41447d5eb4a617843c6/comments", "author": null, "committer": null, "parents": [{"sha": "a32e5e9357929bae073f5533cdadbbb040c7e76c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32e5e9357929bae073f5533cdadbbb040c7e76c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32e5e9357929bae073f5533cdadbbb040c7e76c"}], "stats": {"total": 40, "additions": 25, "deletions": 15}, "files": [{"sha": "206e9ceb49343397b69c685c6daf975270cd26cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d130b315dfc09b83b40d41447d5eb4a617843c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d130b315dfc09b83b40d41447d5eb4a617843c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d130b315dfc09b83b40d41447d5eb4a617843c6", "patch": "@@ -1,3 +1,10 @@\n+2012-01-05  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/51681\n+\t* config/ia64/ia64.c (expand_vec_perm_shrp): Use correct operands\n+\tfor shrp pattern.  Correctly handle and fixup shift variable.\n+\tReturn false when shift > nelt for BYTES_BIG_ENDIAN target.\n+\n 2012-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/51762\n@@ -42,8 +49,7 @@\n 2012-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/51761\n-\t* gimple.h (struct gimplify_ctx): Add in_cleanup_point_expr\n-\tfield.\n+\t* gimple.h (struct gimplify_ctx): Add in_cleanup_point_expr field.\n \t* gimplify.c (gimplify_cleanup_point_expr): Save and set\n \tin_cleanup_point_expr before gimplify_stmt call and restore it\n \tafterwards.\n@@ -183,17 +189,15 @@\n \tPR tree-optimization/49651\n \t* tree-ssa-structalias.c (type_can_have_subvars): New function.\n \t(var_can_have_subvars): Use it.\n-\t(get_constraint_for_1): Only consider subfields if there\n-\tcan be any.\n+\t(get_constraint_for_1): Only consider subfields if there can be any.\n \n 2012-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/51725\n-\t* cselib.c (new_elt_loc_list): When moving locs from one\n-\tcselib_val to its new canonical_cselib_val and the\n-\tcselib_val was in first_containing_mem chain, but\n-\tthe canonical_cselib_val was not, add the latter into the\n-\tchain.\n+\t* cselib.c (new_elt_loc_list): When moving locs from one cselib_val\n+\tto its new canonical_cselib_val and the cselib_val was in\n+\tfirst_containing_mem chain, but the canonical_cselib_val was not,\n+\tadd the latter into the chain.\n \t(cselib_invalidate_mem): Compare canonical_cselib_val of\n \taddr_list chain elt with v.\n "}, {"sha": "b5fad9fd8e0075eae9e52c6d7c3239199fb4a089", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d130b315dfc09b83b40d41447d5eb4a617843c6/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d130b315dfc09b83b40d41447d5eb4a617843c6/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2d130b315dfc09b83b40d41447d5eb4a617843c6", "patch": "@@ -11085,7 +11085,7 @@ static bool\n expand_vec_perm_shrp (struct expand_vec_perm_d *d)\n {\n   unsigned i, nelt = d->nelt, shift, mask;\n-  rtx tmp, op0, op1;;\n+  rtx tmp, hi, lo;\n \n   /* ??? Don't force V2SFmode into the integer registers.  */\n   if (d->vmode == V2SFmode)\n@@ -11094,13 +11094,21 @@ expand_vec_perm_shrp (struct expand_vec_perm_d *d)\n   mask = (d->one_operand_p ? nelt - 1 : 2 * nelt - 1);\n \n   shift = d->perm[0];\n+  if (BYTES_BIG_ENDIAN && shift > nelt)\n+    return false;\n+\n   for (i = 1; i < nelt; ++i)\n     if (d->perm[i] != ((shift + i) & mask))\n       return false;\n \n   if (d->testing_p)\n     return true;\n \n+  hi = shift < nelt ? d->op1 : d->op0;\n+  lo = shift < nelt ? d->op0 : d->op1;\n+\n+  shift %= nelt;\n+\n   shift *= GET_MODE_UNIT_SIZE (d->vmode) * BITS_PER_UNIT;\n \n   /* We've eliminated the shift 0 case via expand_vec_perm_identity.  */\n@@ -11113,11 +11121,9 @@ expand_vec_perm_shrp (struct expand_vec_perm_d *d)\n     shift = 64 - shift;\n \n   tmp = gen_reg_rtx (DImode);\n-  op0 = (shift < nelt ? d->op0 : d->op1);\n-  op1 = (shift < nelt ? d->op1 : d->op0);\n-  op0 = gen_lowpart (DImode, op0);\n-  op1 = gen_lowpart (DImode, op1);\n-  emit_insn (gen_shrp (tmp, op0, op1, GEN_INT (shift)));\n+  hi = gen_lowpart (DImode, hi);\n+  lo = gen_lowpart (DImode, lo);\n+  emit_insn (gen_shrp (tmp, hi, lo, GEN_INT (shift)));\n \n   emit_move_insn (d->target, gen_lowpart (d->vmode, tmp));\n   return true;"}]}