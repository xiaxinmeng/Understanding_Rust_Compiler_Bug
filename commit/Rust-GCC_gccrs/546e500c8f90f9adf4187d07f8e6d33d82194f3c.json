{"sha": "546e500c8f90f9adf4187d07f8e6d33d82194f3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2ZTUwMGM4ZjkwZjlhZGY0MTg3ZDA3ZjhlNmQzM2Q4MjE5NGYzYw==", "commit": {"author": {"name": "Bilyan Borisov", "email": "bilyan.borisov@arm.com", "date": "2015-11-23T14:23:20Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2015-11-23T14:23:20Z"}, "message": "[AARCH64] Adding constant folding for __builtin_fmulx* with scalar 32 and 64 bit arguments\n\ngcc/\n\n\t* config/aarch64/aarch64-builtins.c (aarch64_gimple_fold_builtin): Added\n\tconstant folding.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/simd/vmulx.x: New.\n\t* gcc.target/aarch64/simd/vmulx_f64_2.c: Likewise.\n\t* gcc.target/aarch64/simd/vmulxd_f64_2.c: Likewise.\n\t* gcc.target/aarch64/simd/vmulxs_f32_2.c: Likewise.\n\nFrom-SVN: r230758", "tree": {"sha": "65a0e816d7075bc6c9784ec790430e07a05f03b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65a0e816d7075bc6c9784ec790430e07a05f03b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546e500c8f90f9adf4187d07f8e6d33d82194f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546e500c8f90f9adf4187d07f8e6d33d82194f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546e500c8f90f9adf4187d07f8e6d33d82194f3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546e500c8f90f9adf4187d07f8e6d33d82194f3c/comments", "author": null, "committer": null, "parents": [{"sha": "cc5c5226961128c8c1c0eadd3d7997a59bf2a8b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc5c5226961128c8c1c0eadd3d7997a59bf2a8b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc5c5226961128c8c1c0eadd3d7997a59bf2a8b0"}], "stats": {"total": 257, "additions": 255, "deletions": 2}, "files": [{"sha": "988f7238ec51fcd82c44f7ab14a2e66c699e1200", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -1,3 +1,8 @@\n+2015-11-23  Bilyan Borisov  <bilyan.borisov@arm.com>\n+\n+\t* config/aarch64/aarch64-builtins.c\n+\t(aarch64_gimple_fold_builtin): Fold FMULX.\n+\n 2015-11-23  Richard Biener  <rguenth@gcc.gnu.org>\n \t    Jiong Wang  <jiong.wang@arm.com>\n "}, {"sha": "45011f61d9be6b33f9f89079b9324fbf3f0b226e", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -1468,7 +1468,7 @@ aarch64_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n       if (fndecl)\n \t{\n \t  int fcode = DECL_FUNCTION_CODE (fndecl);\n-\t  int nargs = gimple_call_num_args (stmt);\n+\t  unsigned nargs = gimple_call_num_args (stmt);\n \t  tree *args = (nargs > 0\n \t\t\t? gimple_call_arg_ptr (stmt, 0)\n \t\t\t: &error_mark_node);\n@@ -1492,7 +1492,54 @@ aarch64_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t\tnew_stmt = gimple_build_assign (gimple_call_lhs (stmt),\n \t\t\t\t\t\tREDUC_MIN_EXPR, args[0]);\n \t\tbreak;\n-\n+\t      BUILTIN_GPF (BINOP, fmulx, 0)\n+\t\t{\n+\t\t  gcc_assert (nargs == 2);\n+\t\t  bool a0_cst_p = TREE_CODE (args[0]) == REAL_CST;\n+\t\t  bool a1_cst_p = TREE_CODE (args[1]) == REAL_CST;\n+\t\t  if (a0_cst_p || a1_cst_p)\n+\t\t    {\n+\t\t      if (a0_cst_p && a1_cst_p)\n+\t\t\t{\n+\t\t\t  tree t0 = TREE_TYPE (args[0]);\n+\t\t\t  real_value a0 = (TREE_REAL_CST (args[0]));\n+\t\t\t  real_value a1 = (TREE_REAL_CST (args[1]));\n+\t\t\t  if (real_equal (&a1, &dconst0))\n+\t\t\t    std::swap (a0, a1);\n+\t\t\t  /* According to real_equal (), +0 equals -0.  */\n+\t\t\t  if (real_equal (&a0, &dconst0) && real_isinf (&a1))\n+\t\t\t    {\n+\t\t\t      real_value res = dconst2;\n+\t\t\t      res.sign = a0.sign ^ a1.sign;\n+\t\t\t      new_stmt =\n+\t\t\t\tgimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t\t\t     REAL_CST,\n+\t\t\t\t\t\t     build_real (t0, res));\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    new_stmt =\n+\t\t\t      gimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t\t\t   MULT_EXPR,\n+\t\t\t\t\t\t   args[0], args[1]);\n+\t\t\t}\n+\t\t      else /* a0_cst_p ^ a1_cst_p.  */\n+\t\t\t{\n+\t\t\t  real_value const_part = a0_cst_p\n+\t\t\t    ? TREE_REAL_CST (args[0]) : TREE_REAL_CST (args[1]);\n+\t\t\t  if (!real_equal (&const_part, &dconst0)\n+\t\t\t      && !real_isinf (&const_part))\n+\t\t\t    new_stmt =\n+\t\t\t      gimple_build_assign (gimple_call_lhs (stmt),\n+\t\t\t\t\t\t   MULT_EXPR, args[0], args[1]);\n+\t\t\t}\n+\t\t    }\n+\t\t  if (new_stmt)\n+\t\t    {\n+\t\t      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t\t      gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+\t\t    }\n+\t\t  break;\n+\t\t}\n \t    default:\n \t      break;\n \t    }"}, {"sha": "2a5d8930aa0e1c7efd747c864627df90bd36e778", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -1,3 +1,10 @@\n+2015-11-23  Bilyan Borisov  <bilyan.borisov@arm.com>\n+\n+\t* gcc.target/aarch64/simd/vmulx.x: New.\n+\t* gcc.target/aarch64/simd/vmulx_f64_2.c: Likewise.\n+\t* gcc.target/aarch64/simd/vmulxd_f64_2.c: Likewise.\n+\t* gcc.target/aarch64/simd/vmulxs_f32_2.c: Likewise.\n+\n 2015-11-23  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \tPR c++/68001"}, {"sha": "8968a64a95cb40a466dd77fea4e9f9f63ad707dc", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulx.x", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx.x?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -0,0 +1,46 @@\n+#define PASS_ARRAY(...) {__VA_ARGS__}\n+\n+#define SETUP_TEST_CASE_VEC(I, INTRINSIC, BASE_TYPE, TYPE1, TYPE2,\t\\\n+\t\t\t    VALS1, VALS2, EXPS, LEN, FM, Q_LD, Q_ST,\t\\\n+\t\t\t    V1, V2)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+  int i##I;\t\t\t\t\t\t\t\t\\\n+  BASE_TYPE vec##I##_1_data[] = VALS1;\t\t\t\t\t\\\n+  BASE_TYPE vec##I##_2_data[] = VALS2;\t\t\t\t\t\\\n+  V1 TYPE1 vec##I##_1 = vld1##Q_LD##_##FM (vec##I##_1_data);\t\t\\\n+  V2 TYPE2 vec##I##_2 = vld1##Q_LD##_##FM (vec##I##_2_data);\t\t\\\n+  TYPE1 actual##I##_v = INTRINSIC (vec##I##_1, vec##I##_2);\t\t\\\n+  volatile BASE_TYPE expected##I[] = EXPS;\t\t\t\t\\\n+  BASE_TYPE actual##I[LEN];\t\t\t\t\t\t\\\n+  vst1##Q_ST##_##FM (actual##I, actual##I##_v);\t\t\t\t\\\n+  for (i##I = 0; i##I < LEN; ++i##I)\t\t\t\t\t\\\n+    if (actual##I[i##I] != expected##I[i##I])\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\t\t\t\t\t\t\t\t\\\n+\n+#define SETUP_TEST_CASE_SCALAR(I, INTRINSIC, TYPE, VAL1, VAL2, EXP)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+  TYPE vec_##I##_1 = VAL1;\t\t\t\t\t\t\\\n+  TYPE vec_##I##_2 = VAL2;\t\t\t\t\t\t\\\n+  TYPE expected_##I = EXP;\t\t\t\t\t\t\\\n+  volatile TYPE actual_##I = INTRINSIC (vec_##I##_1, vec_##I##_2);\t\\\n+  if (actual_##I != expected_##I)\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\t\t\t\t\t\t\t\t\\\n+\n+/* Functions used to return values that won't be optimised away.  */\n+float32_t  __attribute__ ((noinline))\n+foo32 ()\n+{\n+  return 1.0;\n+}\n+\n+float64_t  __attribute__ ((noinline))\n+foo64 ()\n+{\n+  return 1.0;\n+}"}, {"sha": "2d11675ed0baa170c64c03669f2841faa73f7009", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulx_f64_2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_f64_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_f64_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulx_f64_2.c?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -0,0 +1,59 @@\n+/* Test the vmulx_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+#include \"vmulx.x\"\n+\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  float64_t v1 = 3.14159265359;\n+  float64_t v2 = 1.383894;\n+\n+  /* Constant * constant, shouldn't generete fmulx or fmul, only fmov.  */\n+  SETUP_TEST_CASE_VEC (1, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (v1), PASS_ARRAY (v2), PASS_ARRAY (v1 * v2),\n+\t\t       1, f64, , , ,);\n+  SETUP_TEST_CASE_VEC (2, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (0.0), PASS_ARRAY (__builtin_huge_val ()),\n+\t\t       PASS_ARRAY (2.0), 1, f64, , , ,);\n+  SETUP_TEST_CASE_VEC (3, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (0.0), PASS_ARRAY (-__builtin_huge_val ()),\n+\t\t       PASS_ARRAY (-2.0), 1, f64, , , ,);\n+  SETUP_TEST_CASE_VEC (4, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (-0.0), PASS_ARRAY (__builtin_huge_val ()),\n+\t\t       PASS_ARRAY (-2.0), 1, f64, , , ,);\n+  SETUP_TEST_CASE_VEC (5, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (-0.0), PASS_ARRAY (-__builtin_huge_val ()),\n+\t\t       PASS_ARRAY (2.0), 1, f64, , , ,);\n+  /* Constant +/- 0 or +/- inf * non-constant should generate fmulx.  */\n+  SETUP_TEST_CASE_VEC (6, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (/* volatile.  */1.0),\n+\t\t       PASS_ARRAY (-__builtin_huge_val ()),\n+\t\t       PASS_ARRAY (-__builtin_huge_val ()), 1, f64, , , volatile\n+\t\t       ,);\n+  SETUP_TEST_CASE_VEC (7, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (/* volatile.  */1.0),\n+\t\t       PASS_ARRAY (__builtin_huge_val ()),\n+\t\t       PASS_ARRAY (__builtin_huge_val ()), 1, f64, , , volatile\n+\t\t       ,);\n+  SETUP_TEST_CASE_VEC (8, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (/* volatile.  */1.0), PASS_ARRAY (0.0),\n+\t\t       PASS_ARRAY (0.0), 1, f64, , , volatile,);\n+  SETUP_TEST_CASE_VEC (9, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (/* volatile.  */1.0), PASS_ARRAY (-0.0),\n+\t\t       PASS_ARRAY (-0.0), 1, f64, , , volatile,);\n+  /* Constant non +/- 0 or non +/- inf * non-constant should generate fmul.  */\n+  SETUP_TEST_CASE_VEC (10, vmulx_f64, float64_t, float64x1_t, float64x1_t,\n+\t\t       PASS_ARRAY (/* volatile.  */1.0), PASS_ARRAY (v1),\n+\t\t       PASS_ARRAY (v1), 1, f64, , , volatile,);\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fmul\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?2.0e\\\\+0\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?-2.0e\\\\+0\\n\" 1 } } */"}, {"sha": "b1f4bcd33fb66d0fd85468a46b40bedf872bacc7", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxd_f64_2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_f64_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_f64_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxd_f64_2.c?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -0,0 +1,45 @@\n+/* Test the vmulxd_f64 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+#include \"vmulx.x\"\n+\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  float64_t v1 = 3.14159265359;\n+  float64_t v2 = 1.383894;\n+\n+  /* Constant * constant, shouldn't generete fmulx or fmul, only fmov.  */\n+  SETUP_TEST_CASE_SCALAR (1, vmulxd_f64, float64_t, v1, v2, v1 * v2);\n+  SETUP_TEST_CASE_SCALAR (2, vmulxd_f64, float64_t, 0.0,\n+\t\t\t  __builtin_huge_val (), 2.0);\n+  SETUP_TEST_CASE_SCALAR (3, vmulxd_f64, float64_t, 0.0,\n+\t\t\t  -__builtin_huge_val (), -2.0);\n+  SETUP_TEST_CASE_SCALAR (4, vmulxd_f64, float64_t, -0.0,\n+\t\t\t  __builtin_huge_val (), -2.0);\n+  SETUP_TEST_CASE_SCALAR (5, vmulxd_f64, float64_t, -0.0,\n+\t\t\t  -__builtin_huge_val (), 2.0);\n+  /* Constant +/- 0 or +/- inf * non-constant should generate fmulx.  */\n+  SETUP_TEST_CASE_SCALAR (6, vmulxd_f64, float64_t, foo64 (),\n+\t\t\t  -__builtin_huge_val (), -__builtin_huge_val ());\n+  SETUP_TEST_CASE_SCALAR (7, vmulxd_f64, float64_t, foo64 (),\n+\t\t\t  __builtin_huge_val (), __builtin_huge_val ());\n+  SETUP_TEST_CASE_SCALAR (8, vmulxd_f64, float64_t, foo64 (),\n+\t\t\t  0, 0);\n+  SETUP_TEST_CASE_SCALAR (9, vmulxd_f64, float64_t, foo64 (),\n+\t\t\t  -0.0, -0.0);\n+  /* Constant non +/- 0 or non +/- inf * non-constant should generate fmul.  */\n+  SETUP_TEST_CASE_SCALAR (10, vmulxd_f64, float64_t, foo64 (),\n+\t\t\t  v1, v1);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fmul\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?2.0e\\\\+0\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\[ \\t\\]+\\[dD\\]\\[0-9\\]+, ?-2.0e\\\\+0\\n\" 1 } } */"}, {"sha": "3d9139859cea04c0b659ee14d142fc901dc736ba", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vmulxs_f32_2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_f32_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546e500c8f90f9adf4187d07f8e6d33d82194f3c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_f32_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvmulxs_f32_2.c?ref=546e500c8f90f9adf4187d07f8e6d33d82194f3c", "patch": "@@ -0,0 +1,44 @@\n+/* Test the vmulxs_f32 AArch64 SIMD intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-save-temps -O3\" } */\n+\n+#include \"arm_neon.h\"\n+#include \"vmulx.x\"\n+\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  float32_t v1 = 3.14159265359;\n+  float32_t v2 = 1.383894;\n+\n+  /* Constant * constant, shouldn't generete fmulx or fmul, only fmov.  */\n+  SETUP_TEST_CASE_SCALAR (1, vmulxs_f32, float32_t, v1, v2, v1 * v2);\n+  SETUP_TEST_CASE_SCALAR (2, vmulxs_f32, float32_t, 0.0,\n+\t\t\t  __builtin_huge_valf (), 2.0);\n+  SETUP_TEST_CASE_SCALAR (3, vmulxs_f32, float32_t, 0.0,\n+\t\t\t  -__builtin_huge_valf (), -2.0);\n+  SETUP_TEST_CASE_SCALAR (4, vmulxs_f32, float32_t, -0.0,\n+\t\t\t  __builtin_huge_valf (), -2.0);\n+  SETUP_TEST_CASE_SCALAR (5, vmulxs_f32, float32_t, -0.0,\n+\t\t\t  -__builtin_huge_valf (), 2.0);\n+  /* Constant +/- 0 or +/- inf * non-constant should generate fmulx.  */\n+  SETUP_TEST_CASE_SCALAR (6, vmulxs_f32, float32_t, foo32 (),\n+\t\t\t  -__builtin_huge_valf (), -__builtin_huge_valf ());\n+  SETUP_TEST_CASE_SCALAR (7, vmulxs_f32, float32_t, foo32 (),\n+\t\t\t  __builtin_huge_valf (), __builtin_huge_valf ());\n+  SETUP_TEST_CASE_SCALAR (8, vmulxs_f32, float32_t, foo32 (),\n+\t\t\t  0, 0);\n+  SETUP_TEST_CASE_SCALAR (9, vmulxs_f32, float32_t, foo32 (),\n+\t\t\t  -0.0, -0.0);\n+  /* Constant non +/- 0 or non +/- inf * non-constant should generate fmul.  */\n+  SETUP_TEST_CASE_SCALAR (10, vmulxs_f32, float32_t, foo32 (),\n+\t\t\t  v1, v1);\n+  return 0;\n+}\n+/* { dg-final { scan-assembler-times \"fmulx\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+\\n\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fmul\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+, ?\\[sS\\]\\[0-9\\]+\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?2.0e\\\\+0\\n\" 1 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\[ \\t\\]+\\[sS\\]\\[0-9\\]+, ?-2.0e\\\\+0\\n\" 1 } } */"}]}