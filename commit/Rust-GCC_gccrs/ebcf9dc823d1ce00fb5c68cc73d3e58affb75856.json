{"sha": "ebcf9dc823d1ce00fb5c68cc73d3e58affb75856", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjZjlkYzgyM2QxY2UwMGZiNWM2OGNjNzNkM2U1OGFmZmI3NTg1Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-09-17T12:02:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-09-17T12:02:42Z"}, "message": "ipa-reference.c (ipa_obstack): Remove.\n\n\t* ipa-reference.c (ipa_obstack): Remove.\n\t(local_info_obstack, global_info_obstack): New.\n\t(add_static_var): We now handle variables only.\n\t(mark_address_taken, mark_load, mark_store): New functions based on ...\n\t(check_operand): ... remove.\n\t(get_asm_stmt_operands): Rename to ...\n\t(check_asm_memory_clobber): ... this. Look only for memory clobber.\n\t(scan_stmt_for_static_refs): Rewrite.\n\t(scan_op_for_static_refs): Rename to ...\n\t(scan_initializer_for_static_refs): do not look for VAR_DECL\n\tinitializers; stop recursion on types and decls.\n\t(ipa_init): Use proper obstacks.\n\t(analyze_variable): Use scan_initializer_for_static_refs.\n\t(init_function_info): Use local obstack.\n\t(analyze_function): Simplify.\n\t(add_new_function): We don't need visited_nodes obstack.\n\t(generate_summary): Use proper obstacks; cleanup after propagation.\n\nFrom-SVN: r140415", "tree": {"sha": "b9f113af8e1eceba321478f6721829d8e3df6ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9f113af8e1eceba321478f6721829d8e3df6ef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856/comments", "author": null, "committer": null, "parents": [{"sha": "791f17147f98a1bdd8be36d677272c57ce933196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/791f17147f98a1bdd8be36d677272c57ce933196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/791f17147f98a1bdd8be36d677272c57ce933196"}], "stats": {"total": 420, "additions": 140, "deletions": 280}, "files": [{"sha": "1207e7f5e4ad8651c8fe5896a979d57003602938", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebcf9dc823d1ce00fb5c68cc73d3e58affb75856", "patch": "@@ -1,3 +1,23 @@\n+2008-09-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-reference.c (ipa_obstack): Remove.\n+\t(local_info_obstack, global_info_obstack): New.\n+\t(add_static_var): We now handle variables only.\n+\t(mark_address_taken, mark_load, mark_store): New functions based on ...\n+\t(check_operand): ... remove.\n+\t(get_asm_stmt_operands): Rename to ...\n+\t(check_asm_memory_clobber): ... this. Look only for memory clobber.\n+\t(scan_stmt_for_static_refs): Rewrite.\n+\t(scan_op_for_static_refs): Rename to ...\n+\t(scan_initializer_for_static_refs): do not look for VAR_DECL\n+\tinitializers; stop recursion on types and decls.\n+\t(ipa_init): Use proper obstacks.\n+\t(analyze_variable): Use scan_initializer_for_static_refs.\n+\t(init_function_info): Use local obstack.\n+\t(analyze_function): Simplify.\n+\t(add_new_function): We don't need visited_nodes obstack.\n+\t(generate_summary): Use proper obstacks; cleanup after propagation.\n+\n 2008-09-17  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/37385"}, {"sha": "861b1536232ef60bd083f07c8ccd8beb3d3f78c2", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 120, "deletions": 280, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcf9dc823d1ce00fb5c68cc73d3e58affb75856/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=ebcf9dc823d1ce00fb5c68cc73d3e58affb75856", "patch": "@@ -93,7 +93,11 @@ static bitmap all_module_statics;\n \n static struct pointer_set_t *visited_nodes;\n \n-static bitmap_obstack ipa_obstack;\n+/* Obstack holding bitmaps of local analysis (live from analysis to\n+   propagation)  */\n+static bitmap_obstack local_info_obstack;\n+/* Obstack holding global analysis live forever.  */\n+static bitmap_obstack global_info_obstack;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n@@ -238,6 +242,7 @@ static inline void\n add_static_var (tree var) \n {\n   int uid = DECL_UID (var);\n+  gcc_assert (TREE_CODE (var) == VAR_DECL);\n   if (!bitmap_bit_p (all_module_statics, uid))\n     {\n       splay_tree_insert (reference_vars_to_consider,\n@@ -281,147 +286,52 @@ has_proper_scope_for_analysis (tree t)\n   return true;\n }\n \n-/* If T is a VAR_DECL for a static that we are interested in, add the\n-   uid to the bitmap.  */\n+/* Mark tree T as having address taken.  */\n \n static void\n-check_operand (ipa_reference_local_vars_info_t local, \n-\t       tree t, bool checking_write)\n+mark_address_taken (tree x)\n {\n-  if (!t) return;\n-\n-  if ((TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == FUNCTION_DECL)\n-      && (has_proper_scope_for_analysis (t))) \n-    {\n-      if (checking_write)\n-\t{\n-\t  if (local)\n-\t    bitmap_set_bit (local->statics_written, DECL_UID (t));\n-\t  /* Mark the write so we can tell which statics are\n-\t     readonly.  */\n-\t  if (module_statics_written)\n-\t    bitmap_set_bit (module_statics_written, DECL_UID (t));\n-\t}\n-      else if (local)\n-\tbitmap_set_bit (local->statics_read, DECL_UID (t));\n-    }\n+  if (TREE_CODE (x) == VAR_DECL\n+      && module_statics_escape && has_proper_scope_for_analysis (x))\n+    bitmap_set_bit (module_statics_escape, DECL_UID (x));\n }\n \n-/* Examine tree T for references to static variables. All internal\n-   references like array references or indirect references are added\n-   to the READ_BM. Direct references are added to either READ_BM or\n-   WRITE_BM depending on the value of CHECKING_WRITE.   */\n+/* Mark load of T.  */\n \n static void\n-check_tree (ipa_reference_local_vars_info_t local, tree t, bool checking_write)\n+mark_load (ipa_reference_local_vars_info_t local, \n+\t   tree t)\n {\n-  if ((TREE_CODE (t) == EXC_PTR_EXPR) || (TREE_CODE (t) == FILTER_EXPR))\n-    return;\n-\n-  while (TREE_CODE (t) == REALPART_EXPR \n-\t || TREE_CODE (t) == IMAGPART_EXPR\n-\t || handled_component_p (t))\n-    {\n-      if (TREE_CODE (t) == ARRAY_REF)\n-\tcheck_operand (local, TREE_OPERAND (t, 1), false);\n-      t = TREE_OPERAND (t, 0);\n-    }\n-\n-  /* The bottom of an indirect reference can only be read, not\n-     written.  So just recurse and whatever we find, check it against\n-     the read bitmaps.  */\n-\n-  /*  if (INDIRECT_REF_P (t) || TREE_CODE (t) == MEM_REF) */\n-  /* FIXME when we have array_ref's of pointers.  */\n-  if (INDIRECT_REF_P (t))\n-    check_tree (local, TREE_OPERAND (t, 0), false);\n-\n-  if (SSA_VAR_P (t))\n-    check_operand (local, t, checking_write);\n+  if (TREE_CODE (t) == VAR_DECL\n+      && has_proper_scope_for_analysis (t))\n+    bitmap_set_bit (local->statics_read, DECL_UID (t));\n }\n \n-/* Scan tree T to see if there are any addresses taken in within T.  */\n+/* Mark store of T.  */\n \n-static void \n-look_for_address_of (tree t)\n+static void\n+mark_store (ipa_reference_local_vars_info_t local, \n+\t   tree t)\n {\n-  if (TREE_CODE (t) == ADDR_EXPR)\n+  if (TREE_CODE (t) == VAR_DECL\n+      && has_proper_scope_for_analysis (t))\n     {\n-      tree x = get_base_var (t);\n-      if (TREE_CODE (x) == VAR_DECL || TREE_CODE (x) == FUNCTION_DECL) \n-\tif (has_proper_scope_for_analysis (x) && module_statics_escape)\n-\t  bitmap_set_bit (module_statics_escape, DECL_UID (x));\n+      if (local)\n+\tbitmap_set_bit (local->statics_written, DECL_UID (t));\n+      /* Mark the write so we can tell which statics are\n+\t readonly.  */\n+      if (module_statics_written)\n+\tbitmap_set_bit (module_statics_written, DECL_UID (t));\n     }\n }\n \n-/* Check to see if T is a read or address of operation on a static var\n-   we are interested in analyzing.  LOCAL is passed in to get access\n-   to its bit vectors.  Local is NULL if this is called from a static\n-   initializer.  */\n-\n-static void\n-check_rhs_var (ipa_reference_local_vars_info_t local, tree t)\n-{\n-  look_for_address_of (t);\n-\n-  if (local == NULL) \n-    return;\n-\n-  check_tree(local, t, false);\n-}\n-\n-/* Check to see if T is an assignment to a static var we are\n-   interested in analyzing.  LOCAL is passed in to get access to its bit\n-   vectors.  */\n+/* Look for memory clobber and set read_all/write_all if present.  */\n \n static void\n-check_lhs_var (ipa_reference_local_vars_info_t local, tree t)\n+check_asm_memory_clobber (ipa_reference_local_vars_info_t local, gimple stmt)\n {\n-  if (local == NULL) \n-    return;\n-   \n-  check_tree(local, t, true);\n-}\n-\n-/* This is a scaled down version of get_asm_expr_operands from\n-   tree_ssa_operands.c.  The version there runs much later and assumes\n-   that aliasing information is already available. Here we are just\n-   trying to find if the set of inputs and outputs contain references\n-   or address of operations to local static variables.  FN is the\n-   function being analyzed and STMT is the actual asm statement.  */\n-\n-static void\n-get_asm_stmt_operands (ipa_reference_local_vars_info_t local, gimple stmt)\n-{\n-  size_t noutputs = gimple_asm_noutputs (stmt);\n-  const char **oconstraints\n-    = (const char **) alloca ((noutputs) * sizeof (const char *));\n   size_t i;\n   tree op;\n-  const char *constraint;\n-  bool allows_mem, allows_reg, is_inout;\n-  \n-  for (i = 0; i < noutputs; i++)\n-    {\n-      op = gimple_asm_output_op (stmt, i);\n-      oconstraints[i] = constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n-      parse_output_constraint (&constraint, i, 0, 0,\n-\t\t\t       &allows_mem, &allows_reg, &is_inout);\n-      \n-      check_lhs_var (local, TREE_VALUE (op));\n-    }\n-\n-  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-    {\n-      op = gimple_asm_input_op (stmt, i);\n-      constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n-      parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n-\t\t\t      oconstraints, &allows_mem, &allows_reg);\n-      \n-      check_rhs_var (local, TREE_VALUE (op));\n-    }\n   \n   for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n     {\n@@ -435,27 +345,14 @@ get_asm_stmt_operands (ipa_reference_local_vars_info_t local, gimple stmt)\n     }\n }\n \n-/* Check the parameters of a function call from CALLER to CALL_EXPR to\n-   see if any of them are static vars.  Also check to see if this is\n-   either an indirect call, a call outside the compilation unit, or\n-   has special attributes that effect the clobbers.  The caller\n-   parameter is the tree node for the caller and the second operand is\n-   the tree node for the entire call expression.  */\n+/* Look for external calls and set read_all/write_all correspondingly.  */\n \n static void\n check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n {\n   int flags = gimple_call_flags (stmt);\n-  tree operand;\n   tree callee_t = gimple_call_fndecl (stmt);\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n-  size_t i;\n-\n-  if ((operand = gimple_call_lhs (stmt)) != NULL)\n-    check_lhs_var (local, operand);\n-\n-  for (i = 0; i < gimple_call_num_args (stmt); i++)\n-    check_rhs_var (local, gimple_call_arg (stmt, i));\n \n   if (callee_t)\n     {\n@@ -466,138 +363,88 @@ check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n   if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n     if (local) \n       {\n-\tif (flags & ECF_PURE) \n+\tif (flags & ECF_CONST) \n+\t  ;\n+\telse if (flags & ECF_PURE)\n \t  local->calls_read_all = true;\n \telse \n \t  {\n \t    local->calls_read_all = true;\n \t    local->calls_write_all = true;\n \t  }\n       }\n+   /* TODO: To be able to produce sane results, we should also handle\n+      common builtins, in particular throw.\n+      Indirect calls hsould be only counted and as inliner is replacing them\n+      by direct calls, we can conclude if any indirect calls are left in body */\n }\n \n /* TP is the part of the tree currently under the microscope.\n    WALK_SUBTREES is part of the walk_tree api but is unused here.\n    DATA is cgraph_node of the function being walked.  */\n \n-/* FIXME: When this is converted to run over SSA form, this code\n-   should be converted to use the operand scanner.  */\n-\n static tree\n-scan_stmt_for_static_refs (gimple_stmt_iterator *gsip, bool *handled_ops_p,\n-\t\t\t   struct walk_stmt_info *data)\n+scan_stmt_for_static_refs (gimple_stmt_iterator *gsip,\n+\t\t\t   struct cgraph_node *fn)\n {\n-  struct cgraph_node *fn = (struct cgraph_node *) data->info;\n   gimple stmt = gsi_stmt (*gsip);\n   ipa_reference_local_vars_info_t local = NULL;\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n   if (fn)\n     local = get_reference_vars_info_from_cgraph (fn)->local;\n \n+  if (gimple_loaded_syms (stmt))\n+    EXECUTE_IF_SET_IN_BITMAP (gimple_loaded_syms (stmt), 0, i, bi)\n+      mark_load (local, referenced_var_lookup (i));\n+  if (gimple_stored_syms (stmt))\n+    EXECUTE_IF_SET_IN_BITMAP (gimple_stored_syms (stmt), 0, i, bi)\n+      mark_store (local, referenced_var_lookup (i));\n+  if (gimple_addresses_taken (stmt))\n+    EXECUTE_IF_SET_IN_BITMAP (gimple_addresses_taken (stmt), 0, i, bi)\n+      mark_address_taken (referenced_var_lookup (i));\n+\n   switch (gimple_code (stmt))\n     {\n-    case GIMPLE_ASSIGN:\n-      {\n-\t/* First look on the lhs and see what variable is stored to */\n-\ttree lhs = gimple_assign_lhs (stmt);\n-\ttree rhs1 = gimple_assign_rhs1 (stmt);\n-\ttree rhs2 = gimple_assign_rhs2 (stmt);\n-\tenum tree_code code = gimple_assign_rhs_code (stmt);\n-\n-\tcheck_lhs_var (local, lhs);\n-\n-\t/* For the purposes of figuring out what the cast affects */\n-\n-\t/* Next check the operands on the rhs to see if they are ok. */\n-\tswitch (TREE_CODE_CLASS (code))\n-\t  {\n-\t  case tcc_binary:\t    \n-\t  case tcc_comparison:\t    \n- \t    check_rhs_var (local, rhs1);\n- \t    check_rhs_var (local, rhs2);\n-\t    break;\n-\n-\t  case tcc_unary:\n-\t  case tcc_reference:\n-\t  case tcc_declaration:\n-\t    check_rhs_var (local, rhs1);\n-\t    break;\n-\n-\t  case tcc_expression:\n-\t    switch (code)\n-\t      {\n-\t      case ADDR_EXPR:\n-\t\tcheck_rhs_var (local, rhs1);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-\t*handled_ops_p = true;\n-      }\n-      break;\n-\n-    case GIMPLE_LABEL:\n-      if (DECL_NONLOCAL (gimple_label_label (stmt)))\n-\t{\n-\t  /* Target of long jump. */\n-\t  local->calls_read_all = true;\n-\t  local->calls_write_all = true;\n-\t}\n-      break;\n-\n     case GIMPLE_CALL:\n       check_call (local, stmt);\n-      *handled_ops_p = true;\n       break;\n       \n     case GIMPLE_ASM:\n-      get_asm_stmt_operands (local, stmt);\n-      *handled_ops_p = true;\n+      check_asm_memory_clobber (local, stmt);\n       break;\n-      \n+\n+    /* We used to check nonlocal labels here and set them as potentially modifying\n+       everything.  This is not needed, since we can get to nonlocal label only\n+       from callee and thus we will get info propagated.  */\n+\n     default:\n       break;\n     }\n+  \n   return NULL;\n }\n \n-/* Call-back to scan GIMPLE operands for static references.  This is supposed\n-   to work with scan_stmt_for_static_refs so the real call-back data is stored\n-   inside a walk_stmt_info struct.  Callers using the walk_tree interface must\n-   also wrap the call-back data in a walk_stmt_info struct.  */\n+/* Call-back to scan variable initializers for static references.  \n+   Called using walk_tree.  */\n \n static tree\n-scan_op_for_static_refs (tree *tp, int *walk_subtrees, void *data)\n+scan_initializer_for_static_refs (tree *tp, int *walk_subtrees,\n+\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n-  struct walk_stmt_info *wi = (struct walk_stmt_info*) data;\n-  struct cgraph_node *fn = (struct cgraph_node *) wi->info;\n   tree t = *tp;\n-  ipa_reference_local_vars_info_t local = NULL;\n-  if (fn)\n-    local = get_reference_vars_info_from_cgraph (fn)->local;\n \n-  switch (TREE_CODE (t))  \n+  if (TREE_CODE (t) == ADDR_EXPR)\n     {\n-    case VAR_DECL:\n-      if (DECL_INITIAL (t))\n-\twalk_tree (&DECL_INITIAL (t), scan_op_for_static_refs, data,\n-\t\t   wi->pset);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case ADDR_EXPR:\n-      /* This case is here to find addresses on rhs of constructors in\n-\t decl_initial of static variables. */\n-      check_rhs_var (local, t);\n+      mark_address_taken (get_base_var (t));\n       *walk_subtrees = 0;\n-      break;\n-\n-    default:\n-      break;\n     }\n+  /* Save some cycles by not walking types and declaration as we\n+     won't find anything useful there anyway.  */\n+  else if (IS_TYPE_OR_DECL_P (*tp))\n+    *walk_subtrees = 0;\n+ \n   return NULL;\n }\n \n@@ -687,9 +534,7 @@ propagate_bits (struct cgraph_node *x)\n \t\t}\n \t    }\n \t  else \n-\t    {\n-\t      gcc_unreachable ();\n-\t    }\n+\t    gcc_unreachable ();\n \t}\n     }\n }\n@@ -763,20 +608,16 @@ merge_callee_local_info (struct cgraph_node *target,\n static void \n ipa_init (void) \n {\n-  struct cgraph_node *node;\n   memory_identifier_string = build_string(7, \"memory\");\n \n   reference_vars_to_consider =\n     splay_tree_new_ggc (splay_tree_compare_ints);\n \n-  bitmap_obstack_initialize (&ipa_obstack);\n-  module_statics_escape = BITMAP_ALLOC (&ipa_obstack);\n-  module_statics_written = BITMAP_ALLOC (&ipa_obstack);\n-  all_module_statics = BITMAP_ALLOC (&ipa_obstack);\n-\n-  /* This will add NODE->DECL to the splay trees.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    has_proper_scope_for_analysis (node->decl);\n+  bitmap_obstack_initialize (&local_info_obstack);\n+  bitmap_obstack_initialize (&global_info_obstack);\n+  module_statics_escape = BITMAP_ALLOC (&local_info_obstack);\n+  module_statics_written = BITMAP_ALLOC (&local_info_obstack);\n+  all_module_statics = BITMAP_ALLOC (&global_info_obstack);\n \n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n@@ -799,7 +640,7 @@ analyze_variable (struct varpool_node *vnode)\n \n   memset (&wi, 0, sizeof (wi));\n   wi.pset = visited_nodes;\n-  walk_tree (&DECL_INITIAL (global), scan_op_for_static_refs,\n+  walk_tree (&DECL_INITIAL (global), scan_initializer_for_static_refs,\n              &wi, wi.pset);\n }\n \n@@ -818,8 +659,8 @@ init_function_info (struct cgraph_node *fn)\n   get_function_ann (decl)->reference_vars_info = info;\n \n   info->local = l;\n-  l->statics_read = BITMAP_ALLOC (&ipa_obstack);\n-  l->statics_written = BITMAP_ALLOC (&ipa_obstack);\n+  l->statics_read = BITMAP_ALLOC (&local_info_obstack);\n+  l->statics_written = BITMAP_ALLOC (&local_info_obstack);\n \n   return l;\n }\n@@ -830,15 +671,18 @@ init_function_info (struct cgraph_node *fn)\n static void\n analyze_function (struct cgraph_node *fn)\n {\n-  ipa_reference_local_vars_info_t l = init_function_info (fn);\n   tree decl = fn->decl;\n-  struct walk_stmt_info wi;\n   struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n   basic_block this_block;\n+  tree step;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\n local analysis of %s\\n\", cgraph_node_name (fn));\n+\n+  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+  current_function_decl = decl;\n   \n+  init_function_info (fn);\n   FOR_EACH_BB_FN (this_block, this_cfun)\n     {\n       gimple_stmt_iterator gsi;\n@@ -857,39 +701,29 @@ analyze_function (struct cgraph_node *fn)\n \t    {\n \t      op = USE_FROM_PTR (use);\n \t      if (TREE_CODE (op) == ADDR_EXPR)\n-\t\tcheck_rhs_var (l, op);\n+\t\tmark_address_taken (get_base_var (op));\n \t    }\n \t}\n \n-      memset (&wi, 0, sizeof (wi));\n-      wi.info = fn;\n-      wi.pset = visited_nodes;\n       for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n-\twalk_gimple_stmt (&gsi, scan_stmt_for_static_refs,\n-\t\t\t  scan_op_for_static_refs, &wi);\n+\tscan_stmt_for_static_refs (&gsi, fn);\n     }\n \n-  /* There may be const decls with interesting right hand sides.  */\n-  if (DECL_STRUCT_FUNCTION (decl))\n+#ifdef ENABLE_CHECKING\n+  /* Verify that all local initializers was expanded by gimplifier.  */\n+  for (step = DECL_STRUCT_FUNCTION (decl)->local_decls;\n+       step;\n+       step = TREE_CHAIN (step))\n     {\n-      tree step;\n-      for (step = DECL_STRUCT_FUNCTION (decl)->local_decls;\n-\t   step;\n-\t   step = TREE_CHAIN (step))\n-\t{\n-\t  tree var = TREE_VALUE (step);\n-\t  if (TREE_CODE (var) == VAR_DECL \n-\t      && DECL_INITIAL (var)\n-\t      && !TREE_STATIC (var))\n-\t    {\n-\t      memset (&wi, 0, sizeof (wi));\n-\t      wi.info = fn;\n-\t      wi.pset = visited_nodes;\n-\t      walk_tree (&DECL_INITIAL (var), scan_op_for_static_refs,\n-\t\t         &wi, wi.pset);\n-\t    }\n-\t}\n+      tree var = TREE_VALUE (step);\n+      if (TREE_CODE (var) == VAR_DECL \n+\t  && DECL_INITIAL (var)\n+\t  && !TREE_STATIC (var))\n+\tgcc_unreachable ();\n     }\n+#endif\n+  pop_cfun ();\n+  current_function_decl = NULL;\n }\n \n /* If FN is avail == AVAIL_OVERWRITABLE, replace the effects bit\n@@ -947,9 +781,7 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n      operations.  */\n-  visited_nodes = pointer_set_create ();\n   analyze_function (node);\n-  pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n }\n \n@@ -969,8 +801,8 @@ generate_summary (void)\n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n   ipa_init ();\n-  module_statics_readonly = BITMAP_ALLOC (&ipa_obstack);\n-  bm_temp = BITMAP_ALLOC (&ipa_obstack);\n+  module_statics_readonly = BITMAP_ALLOC (&local_info_obstack);\n+  bm_temp = BITMAP_ALLOC (&local_info_obstack);\n \n   /* Process all of the variables first.  */\n   FOR_EACH_STATIC_INITIALIZER (vnode)\n@@ -1031,11 +863,6 @@ generate_summary (void)\n     {\n       tree var = get_static_decl (index);\n       \n-      /* Readonly on a function decl is very different from the\n-\t variable.  */\n-      if (TREE_CODE (var) == FUNCTION_DECL)\n-\tcontinue;\n-      \n       /* Ignore variables in named sections - changing TREE_READONLY\n \t changes the section flags, potentially causing conflicts with\n \t other variables in the same named section.  */\n@@ -1186,7 +1013,7 @@ propagate (void)\n \tnode_g->statics_read = all_module_statics;\n       else \n \t{\n-\t  node_g->statics_read = BITMAP_ALLOC (&ipa_obstack);\n+\t  node_g->statics_read = BITMAP_ALLOC (&global_info_obstack);\n \t  bitmap_copy (node_g->statics_read, \n \t\t       node_l->statics_read);\n \t}\n@@ -1195,7 +1022,7 @@ propagate (void)\n \tnode_g->statics_written = all_module_statics;\n       else\n \t{\n-\t  node_g->statics_written = BITMAP_ALLOC (&ipa_obstack);\n+\t  node_g->statics_written = BITMAP_ALLOC (&global_info_obstack);\n \t  bitmap_copy (node_g->statics_written, \n \t\t       node_l->statics_written);\n \t}\n@@ -1346,8 +1173,8 @@ propagate (void)\n       \n       /* Create the complimentary sets.  These are more useful for\n \t certain apis.  */\n-      node_g->statics_not_read = BITMAP_ALLOC (&ipa_obstack);\n-      node_g->statics_not_written = BITMAP_ALLOC (&ipa_obstack);\n+      node_g->statics_not_read = BITMAP_ALLOC (&global_info_obstack);\n+      node_g->statics_not_written = BITMAP_ALLOC (&global_info_obstack);\n \n       if (node_g->statics_read != all_module_statics) \n \t{\n@@ -1367,6 +1194,8 @@ propagate (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n+      ipa_reference_vars_info_t node_info;\n+      node_info = get_reference_vars_info_from_cgraph (node);\n       /* Get rid of the aux information.  */\n       \n       if (node->aux)\n@@ -1378,7 +1207,18 @@ propagate (void)\n       if (node->analyzed \n \t  && (cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE))\n \tclean_function (node);\n+      else if (node_info)\n+\t{\n+\t  /* Remove local info we no longer need.  */\n+\t  if (node_info->local->statics_read\n+\t      && node_info->local->statics_read != all_module_statics)\n+\t    BITMAP_FREE (node_info->local->statics_read);\n+\t  if (node_info->local->statics_written\n+\t      && node_info->local->statics_written != all_module_statics)\n+\t    BITMAP_FREE (node_info->local->statics_written);\n+\t}\n     }\n+  bitmap_obstack_release (&local_info_obstack);\n   return 0;\n }\n "}]}