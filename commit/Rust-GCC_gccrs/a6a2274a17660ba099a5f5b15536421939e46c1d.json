{"sha": "a6a2274a17660ba099a5f5b15536421939e46c1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhMjI3NGExNzY2MGJhMDk5YTVmNWIxNTUzNjQyMTkzOWU0NmMxZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-09T01:42:28Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-09T01:42:28Z"}, "message": "read-rtl.c: Fix formatting.\n\n\t* read-rtl.c: Fix formatting.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regmove.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* reload1.c: Likewise.\n\t* reload.c: Likewise.\n\t* resource.c: Likewise.\n\t* rtlanal.c: Likewise.\n\t* rtl.c: Likewise.\n\t* rtl-error.c: Likewise.\n\nFrom-SVN: r53313", "tree": {"sha": "a546d2736172ee466c2568e02cd89721a1acfd42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a546d2736172ee466c2568e02cd89721a1acfd42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a2274a17660ba099a5f5b15536421939e46c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a2274a17660ba099a5f5b15536421939e46c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a2274a17660ba099a5f5b15536421939e46c1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a2274a17660ba099a5f5b15536421939e46c1d/comments", "author": null, "committer": null, "parents": [{"sha": "461b48d5448f2594e13e085c9f69b15d328ed032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461b48d5448f2594e13e085c9f69b15d328ed032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/461b48d5448f2594e13e085c9f69b15d328ed032"}], "stats": {"total": 417, "additions": 216, "deletions": 201}, "files": [{"sha": "c0b86cc4a8d5a829f86e82f2fabc2b7c34b2bddd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -1,3 +1,18 @@\n+2002-05-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* read-rtl.c: Fix formatting.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* rtl.c: Likewise.\n+\t* rtl-error.c: Likewise.\n+\n 2002-05-08  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* pa/pa-64.h (MAX_WCHAR_TYPE_SIZE): Delete."}, {"sha": "5db7b99a409b140ac141a8f0353b70d27ea581c6", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -265,7 +265,7 @@ read_escape (ob, infile)\n \n   obstack_1grow (ob, c);\n }\n-      \n+\n \n /* Read a double-quoted string onto the obstack.  Caller has scanned\n    the leading quote.  */\n@@ -325,7 +325,7 @@ read_braced_string (ob, infile)\n \n       obstack_1grow (ob, c);\n     }\n-      \n+\n   obstack_1grow (ob, 0);\n   return obstack_finish (ob);\n }\n@@ -361,7 +361,7 @@ read_string (ob, infile, star_if_braced)\n     }\n   else\n     fatal_with_file_and_line (infile, \"expected `\\\"' or `{', found `%c'\", c);\n-       \n+\n   if (saw_paren)\n     {\n       c = read_skip_spaces (infile);\n@@ -639,7 +639,7 @@ read_rtx (infile)\n \t  {\n \t    XVEC (return_rtx, i) = 0;\n \t    break;\n- \t  }\n+\t  }\n \t/* Now process the vector.  */\n \n       case 'E':\n@@ -694,7 +694,7 @@ read_rtx (infile)\n \t     gets a star inserted as its first character, if it is\n \t     written with a brace block instead of a string constant.  */\n \t  int star_if_braced = (format_ptr[-1] == 'T');\n-\t    \n+\n \t  stringbuf = read_string (&rtl_obstack, infile, star_if_braced);\n \n \t  /* For insn patterns, we want to provide a default name"}, {"sha": "912986260765b65174225f88dc733891c19eec40", "filename": "gcc/real.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -227,7 +227,7 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n # define MINDECEXP -4956\n #endif\n \n-/* Fail compilation if 2*NE is not the appropriate size. \n+/* Fail compilation if 2*NE is not the appropriate size.\n    If HOST_BITS_PER_WIDE_INT is 64, we're going to have padding\n    at the end of the array, because neither 96 nor 160 is\n    evenly divisible by 64.  */\n@@ -1601,7 +1601,7 @@ eisnan (x)\n   for (i = 0; i < NE - 1; i++)\n     {\n       if (*x++ != 0)\n-        return (1);\n+\treturn (1);\n     }\n #endif\n \n@@ -4321,13 +4321,13 @@ eifrac (x, i, frac)\n \t*i = -(*i);\n     }\n   else\n-      {\n-        /* shift not more than 16 bits */\n-          eshift (xi, k);\n-        *i = (HOST_WIDE_INT) xi[M] & 0xffff;\n-        if (xi[0])\n-\t  *i = -(*i);\n-      }\n+    {\n+      /* shift not more than 16 bits */\n+      eshift (xi, k);\n+      *i = (HOST_WIDE_INT) xi[M] & 0xffff;\n+      if (xi[0])\n+\t*i = -(*i);\n+    }\n   xi[0] = 0;\n   xi[E] = EXONE - 1;\n   xi[M] = 0;\n@@ -6021,11 +6021,11 @@ c4xtoe (d, e, mode)\n \n       y[M+1] = dn[1];\n       if (mode != QFmode)\t/* There are only 2 words in QFmode.  */\n-        {\n+\t{\n \t  y[M+2] = dn[2];\t/* Fill in the rest of our mantissa.  */\n \t  y[M+3] = dn[3];\n \t  size = 4;\n-        }\n+\t}\n       else\n \tsize = 2;\n       eshift (y, -8);\n@@ -6034,7 +6034,7 @@ c4xtoe (d, e, mode)\n \n       carry = 1;\t/* Initially add 1 for the two's complement.  */\n       for (i=size + M; i > M; i--)\n-        {\n+\t{\n \t  if (carry && (y[i] == 0x0000))\n \t    /* We overflowed into the next word, carry is the same.  */\n \t    y[i] = carry ? 0x0000 : 0xffff;\n@@ -6044,14 +6044,14 @@ c4xtoe (d, e, mode)\n \t      y[i] = ((~y[i]) + carry) & 0xffff;\n \t      carry = 0;\n \t    }\n-        }\n+\t}\n \n       if (carry)\n-        {\n+\t{\n \t  eshift (y, -1);\n \t  y[M+1] |= 0x8000;\n \t  r++;\n-         }\n+\t}\n        y[1] = r + EXONE;\n     }\n   else\n@@ -6123,10 +6123,10 @@ toc4x (x, y, mode)\n       *y++ = 0x8000;\n       *y++ = 0x0000;\n       if (mode != QFmode)\n-        {\n-          *y++ = 0x0000;\n-          *y++ = 0x0000;\n-        }\n+\t{\n+\t  *y++ = 0x0000;\n+\t  *y++ = 0x0000;\n+\t}\n       return;\n     }\n \n@@ -6644,7 +6644,7 @@ etoudi (x, i)\n     }\n   else\n     {\n-        /* shift not more than 16 bits */\n+      /* shift not more than 16 bits */\n       eshift (xi, k);\n \n noshift:\n@@ -6726,7 +6726,7 @@ etodi (x, i)\n     }\n   else\n     {\n-        /* shift not more than 16 bits */\n+      /* shift not more than 16 bits */\n       eshift (xi, k);\n \n       if (WORDS_BIG_ENDIAN)"}, {"sha": "a0075effebcb64295b3373ec3da874b354085a57", "filename": "gcc/recog.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -161,7 +161,7 @@ check_asm_operands (x)\n \tc = constraints[c[0] - '0'];\n \n       if (! asm_operand_ok (operands[i], c))\n-        return 0;\n+\treturn 0;\n     }\n \n   return 1;\n@@ -227,11 +227,11 @@ validate_change (object, loc, new, in_group)\n       else\n \tchanges_allocated *= 2;\n \n-      changes = \n-\t(change_t*) xrealloc (changes, \n-\t\t\t      sizeof (change_t) * changes_allocated); \n+      changes =\n+\t(change_t*) xrealloc (changes,\n+\t\t\t      sizeof (change_t) * changes_allocated);\n     }\n-  \n+\n   changes[num_changes].object = object;\n   changes[num_changes].loc = loc;\n   changes[num_changes].old = old;\n@@ -272,7 +272,7 @@ insn_invalid_p (insn)\n \t\t     ? &num_clobbers : 0);\n   int is_asm = icode < 0 && asm_noperands (PATTERN (insn)) >= 0;\n \n-  \n+\n   /* If this is an asm and the operand aren't legal, then fail.  Likewise if\n      this is not an asm and the insn wasn't recognized.  */\n   if ((is_asm && ! check_asm_operands (PATTERN (insn)))\n@@ -362,7 +362,7 @@ apply_change_group ()\n \t\t  int j;\n \n \t\t  newpat\n-\t\t    = gen_rtx_PARALLEL (VOIDmode, \n+\t\t    = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t\trtvec_alloc (XVECLEN (pat, 0) - 1));\n \t\t  for (j = 0; j < XVECLEN (newpat, 0); j++)\n \t\t    XVECEXP (newpat, 0, j) = XVECEXP (pat, 0, j);\n@@ -401,7 +401,7 @@ apply_change_group ()\n \t    && ((unsigned int)INSN_UID (changes[i].object)\n \t\t< basic_block_for_insn->num_elements)\n \t    && (bb = BLOCK_FOR_INSN (changes[i].object)))\n-        bb->flags |= BB_DIRTY;\n+\t  bb->flags |= BB_DIRTY;\n \n       num_changes = 0;\n       return 1;\n@@ -789,7 +789,7 @@ find_single_use_1 (dest, loc)\n     case MEM:\n     case SUBREG:\n       return find_single_use_1 (dest, &XEXP (x, 0));\n-      \n+\n     default:\n       break;\n     }\n@@ -971,12 +971,12 @@ general_operand (op, mode)\n       /* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory\n          may result in incorrect reference.  We should simplify all valid\n          subregs of MEM anyway.  But allow this after reload because we\n-\t might be called from cleanup_subreg_operands. \n+\t might be called from cleanup_subreg_operands.\n \n \t ??? This is a kludge.  */\n       if (!reload_completed && SUBREG_BYTE (op) != 0\n \t  && GET_CODE (SUBREG_REG (op)) == MEM)\n-        return 0;\n+\treturn 0;\n \n       op = SUBREG_REG (op);\n       code = GET_CODE (op);\n@@ -1329,7 +1329,7 @@ memory_address_p (mode, addr)\n {\n   if (GET_CODE (addr) == ADDRESSOF)\n     return 1;\n-  \n+\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n \n@@ -1583,7 +1583,7 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n \t{\n \t  if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n \t    break;\t\t/* Past last SET */\n-\t  \n+\n \t  if (operands)\n \t    operands[i] = SET_DEST (XVECEXP (body, 0, i));\n \t  if (operand_locs)\n@@ -1635,7 +1635,7 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n   return template;\n }\n \n-/* Check if an asm_operand matches it's constraints. \n+/* Check if an asm_operand matches it's constraints.\n    Return > 0 if ok, = 0 if bad, < 0 if inconclusive.  */\n \n int\n@@ -1703,15 +1703,15 @@ asm_operand_ok (op, constraint)\n \t  if (GET_CODE (op) == MEM\n \t      && (1\n \t\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC\n-                  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n \t    return 1;\n \t  break;\n \n \tcase '>':\n \t  if (GET_CODE (op) == MEM\n \t      && (1\n \t\t  || GET_CODE (XEXP (op, 0)) == PRE_INC\n-                  || GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n \t    return 1;\n \t  break;\n \n@@ -2215,7 +2215,7 @@ preprocess_constraints ()\n \t\t  break;\n \t\tcase '&':\n \t\t  op_alt[j].earlyclobber = 1;\n-\t\t  break;\t\t  \n+\t\t  break;\n \n \t\tcase '0': case '1': case '2': case '3': case '4':\n \t\tcase '5': case '6': case '7': case '8': case '9':\n@@ -2264,7 +2264,7 @@ preprocess_constraints ()\n \t}\n     }\n }\n- \n+\n /* Check the operands of an insn against the insn's operand constraints\n    and return 1 if they are valid.\n    The information about the insn's operands, constraints, operand modes\n@@ -2700,7 +2700,7 @@ split_insn (insn)\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \n \t  /* ??? Coddle to md files that generate subregs in post-\n-\t     reload splitters instead of computing the proper \n+\t     reload splitters instead of computing the proper\n \t     hard register.  */\n \t  if (reload_completed && first != last)\n \t    {\n@@ -2780,7 +2780,7 @@ split_all_insns (upd_life)\n   sbitmap_free (blocks);\n }\n \n-/* Same as split_all_insns, but do not expect CFG to be available. \n+/* Same as split_all_insns, but do not expect CFG to be available.\n    Used by machine depedent reorg passes.  */\n \n void\n@@ -3131,7 +3131,7 @@ peephole2_optimize (dump_file)\n \t\t  if (i >= MAX_INSNS_PER_PEEP2 + 1)\n \t\t    i -= MAX_INSNS_PER_PEEP2 + 1;\n \n-\t\t  note = find_reg_note (peep2_insn_data[i].insn, \n+\t\t  note = find_reg_note (peep2_insn_data[i].insn,\n \t\t\t\t\tREG_EH_REGION, NULL_RTX);\n \n \t\t  /* Replace the old sequence with the new.  */\n@@ -3357,7 +3357,7 @@ if_test_bypass_p (out_insn, in_insn)\n     {\n       if (reg_mentioned_p (SET_DEST (out_set), XEXP (in_set, 1))\n \t  || reg_mentioned_p (SET_DEST (out_set), XEXP (in_set, 2)))\n-        return false;\n+\treturn false;\n     }\n   else\n     {"}, {"sha": "3e1a756d473b273d026ce37e3bd079b46d3ea861", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -188,7 +188,7 @@ typedef struct stack_def\n   unsigned char reg[REG_STACK_SIZE];/* register - stack mapping */\n } *stack;\n \n-/* This is used to carry information about basic blocks.  It is \n+/* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n \n typedef struct block_info_def\n@@ -211,7 +211,7 @@ enum emit_where\n };\n \n /* We use this array to cache info about insns, because otherwise we\n-   spend too much time in stack_regs_mentioned_p. \n+   spend too much time in stack_regs_mentioned_p.\n \n    Indexed by insn UIDs.  A value of zero is uninitialized, one indicates\n    the insn uses stack registers, two indicates the insn does not use\n@@ -336,15 +336,15 @@ static rtx\n next_flags_user (insn)\n      rtx insn;\n {\n-  /* Search forward looking for the first use of this value. \n+  /* Search forward looking for the first use of this value.\n      Stop at block boundaries.  */\n \n   while (insn != current_block->end)\n     {\n       insn = NEXT_INSN (insn);\n \n       if (INSN_P (insn) && reg_mentioned_p (ix86_flags_rtx, PATTERN (insn)))\n-        return insn;\n+\treturn insn;\n \n       if (GET_CODE (insn) == CALL_INSN)\n \treturn NULL_RTX;\n@@ -374,7 +374,7 @@ straighten_stack (insn, regstack)\n \n   for (top = temp_stack.top = regstack->top; top >= 0; top--)\n     temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;\n-  \n+\n   change_stack (insn, regstack, &temp_stack, EMIT_AFTER);\n }\n \n@@ -439,7 +439,7 @@ reg_to_stack (first, file)\n   if (i > LAST_STACK_REG)\n     return;\n \n-  /* Ok, floating point instructions exist.  If not optimizing, \n+  /* Ok, floating point instructions exist.  If not optimizing,\n      build the CFG and run life analysis.  */\n   if (!optimize)\n     {\n@@ -477,7 +477,7 @@ reg_to_stack (first, file)\n \n   ix86_flags_rtx = gen_rtx_REG (CCmode, FLAGS_REG);\n \n-  /* A QNaN for initializing uninitialized variables.  \n+  /* A QNaN for initializing uninitialized variables.\n \n      ??? We can't load from constant memory in PIC mode, because\n      we're insertting these instructions before the prologue and\n@@ -677,7 +677,7 @@ check_asm_stack_operands (insn)\n \t    error_for_asm (insn, \"output constraint %d must specify a single register\", i);\n \t    malformed_asm = 1;\n \t  }\n-        else\n+\telse\n \t  {\n \t    int j;\n \n@@ -823,7 +823,7 @@ stack_result (decl)\n     {\n #ifdef FUNCTION_OUTGOING_VALUE\n       result\n-        = FUNCTION_OUTGOING_VALUE (TREE_TYPE (DECL_RESULT (decl)), decl);\n+\t= FUNCTION_OUTGOING_VALUE (TREE_TYPE (DECL_RESULT (decl)), decl);\n #else\n       result = FUNCTION_VALUE (TREE_TYPE (DECL_RESULT (decl)), decl);\n #endif\n@@ -932,9 +932,9 @@ emit_pop_insn (insn, regstack, reg, where)\n \n       pop_insn = NULL_RTX;\n       if (get_hard_regnum (regstack, reg1) >= 0)\n-         pop_insn = emit_pop_insn (insn, regstack, reg1, where);\n+\tpop_insn = emit_pop_insn (insn, regstack, reg1, where);\n       if (get_hard_regnum (regstack, reg2) >= 0)\n-         pop_insn = emit_pop_insn (insn, regstack, reg2, where);\n+\tpop_insn = emit_pop_insn (insn, regstack, reg2, where);\n       if (!pop_insn)\n \tabort ();\n       return pop_insn;\n@@ -1264,7 +1264,7 @@ swap_rtx_condition (insn)\n     {\n       rtx dest = SET_DEST (pat);\n \n-      /* Search forward looking for the first use of this value. \n+      /* Search forward looking for the first use of this value.\n \t Stop at block boundaries.  */\n       while (insn != current_block->end)\n \t{\n@@ -1430,12 +1430,12 @@ subst_stack_regs_pat (insn, regstack, pat)\n       /* Deaths in USE insns can happen in non optimizing compilation.\n \t Handle them by popping the dying register.  */\n       src = get_true_reg (&XEXP (pat, 0));\n-      if (STACK_REG_P (*src) \n-          && find_regno_note (insn, REG_DEAD, REGNO (*src)))\n-        {\n-\t   emit_pop_insn (insn, regstack, *src, EMIT_AFTER);\n-\t   return;\n-        }\n+      if (STACK_REG_P (*src)\n+\t  && find_regno_note (insn, REG_DEAD, REGNO (*src)))\n+\t{\n+\t  emit_pop_insn (insn, regstack, *src, EMIT_AFTER);\n+\t  return;\n+\t}\n       /* ??? Uninitialized USE should not happen.  */\n       else if (get_hard_regnum (regstack, *src) == -1)\n \tabort ();\n@@ -1455,7 +1455,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\t/* The fix_truncdi_1 pattern wants to be able to allocate\n \t\t   it's own scratch register.  It does this by clobbering\n \t\t   an fp reg so that it is assured of an empty reg-stack\n-\t\t   register.  If the register is live, kill it now. \n+\t\t   register.  If the register is live, kill it now.\n \t\t   Remove the DEAD/UNUSED note so we don't try to kill it\n \t\t   later too.  */\n \n@@ -1474,7 +1474,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t      {\n \t\t/* A top-level clobber with no REG_DEAD, and no hard-regnum\n \t\t   indicates an uninitialized value.  Because reload removed\n-\t\t   all other clobbers, this must be due to a function \n+\t\t   all other clobbers, this must be due to a function\n \t\t   returning without a value.  Load up a NaN.  */\n \n \t\tif (! note\n@@ -1798,7 +1798,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\t\t      reversed_comparison_code (XEXP (pat_src, 0), insn));\n \t\t  }\n \t\telse\n-\t          emit_swap_insn (insn, regstack, *dest);\t\n+\t          emit_swap_insn (insn, regstack, *dest);\n \t      }\n \n \t    {\n@@ -1837,7 +1837,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t    /* Make dest the top of stack.  Add dest to regstack if\n \t       not present.  */\n \t    if (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n-\t      regstack->reg[++regstack->top] = REGNO (*dest);\t\n+\t      regstack->reg[++regstack->top] = REGNO (*dest);\n \t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n \t    replace_reg (dest, FIRST_STACK_REG);\n \t    break;\n@@ -1899,7 +1899,7 @@ subst_asm_stack_regs (insn, regstack)\n \n   n_inputs = get_asm_operand_n_inputs (body);\n   n_outputs = recog_data.n_operands - n_inputs;\n-  \n+\n   if (alt < 0)\n     abort ();\n \n@@ -2296,7 +2296,7 @@ change_stack (insn, old, new, where)\n \tabort ();\n \n       /* If the stack is not empty (new->top != -1), loop here emitting\n-\t swaps until the stack is correct. \n+\t swaps until the stack is correct.\n \n \t The worst case number of swaps emitted is N + 2, where N is the\n \t depth of the stack.  In some cases, the reg at the top of\n@@ -2372,7 +2372,7 @@ print_stack (file, s)\n }\n \f\n /* This function was doing life analysis.  We now let the regular live\n-   code do it's job, so we only need to check some extra invariants \n+   code do it's job, so we only need to check some extra invariants\n    that reg-stack expects.  Primary among these being that all registers\n    are initialized before use.\n \n@@ -2390,10 +2390,10 @@ convert_regs_entry ()\n       basic_block block = BASIC_BLOCK (i);\n       block_info bi = BLOCK_INFO (block);\n       int reg;\n-      \n+\n       /* Set current register status at last instruction `uninitialized'.  */\n       bi->stack_in.top = -2;\n-  \n+\n       /* Copy live_at_end and live_at_start into temporaries.  */\n       for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n \t{\n@@ -2404,11 +2404,11 @@ convert_regs_entry ()\n \t}\n     }\n \n-  /* Load something into each stack register live at function entry. \n+  /* Load something into each stack register live at function entry.\n      Such live registers can be caused by uninitialized variables or\n-     functions not returning values on all paths.  In order to keep \n+     functions not returning values on all paths.  In order to keep\n      the push/pop code happy, and to not scrog the register stack, we\n-     must put something in these registers.  Use a QNaN.  \n+     must put something in these registers.  Use a QNaN.\n \n      Note that we are insertting converted code here.  This code is\n      never seen by the convert_regs pass.  */\n@@ -2510,7 +2510,7 @@ compensate_edge (e, file)\n \t  tmpstack = regstack;\n \n \t  change_stack (block->end, &tmpstack, target_stack, EMIT_AFTER);\n-          return false;\n+\t  return false;\n \t}\n \n       if (file)\n@@ -2593,8 +2593,8 @@ compensate_edge (e, file)\n       current_block = NULL;\n       start_sequence ();\n \n-      /* ??? change_stack needs some point to emit insns after. \n-         Also needed to keep gen_sequence from returning a \n+      /* ??? change_stack needs some point to emit insns after.\n+         Also needed to keep gen_sequence from returning a\n          pattern as opposed to a sequence, which would lose\n          REG_DEAD notes.  */\n       after = emit_note (NULL, NOTE_INSN_DELETED);\n@@ -2660,7 +2660,7 @@ convert_regs_1 (file, block)\n     inserted |= compensate_edge (beste, file);\n   else\n     beste = NULL;\n-  \n+\n   current_block = block;\n \n   if (file)\n@@ -2753,7 +2753,7 @@ convert_regs_1 (file, block)\n \t  if (!BLOCK_INFO (e->dest)->done\n \t      && e->dest != block)\n \t    abort ();\n-          inserted |= compensate_edge (e, file);\n+\t  inserted |= compensate_edge (e, file);\n \t}\n     }\n   for (e = block->pred; e ; e = e->pred_next)\n@@ -2763,7 +2763,7 @@ convert_regs_1 (file, block)\n \t{\n \t  if (!BLOCK_INFO (e->src)->done)\n \t    abort ();\n-          inserted |= compensate_edge (e, file);\n+\t  inserted |= compensate_edge (e, file);\n \t}\n     }\n \n@@ -2832,8 +2832,8 @@ convert_regs (file)\n   /* Process all blocks reachable from all entry points.  */\n   for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n     inserted |= convert_regs_2 (file, e->dest);\n-  \n-  /* ??? Process all unreachable blocks.  Though there's no excuse \n+\n+  /* ??? Process all unreachable blocks.  Though there's no excuse\n      for keeping these even when not optimizing.  */\n   for (i = 0; i < n_basic_blocks; ++i)\n     {"}, {"sha": "decab26b4af9148dc9a75f172d7aaf78184b68e5", "filename": "gcc/regclass.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -97,13 +97,13 @@ static const char initial_call_used_regs[] = CALL_USED_REGISTERS;\n \n /* This is much like call_used_regs, except it doesn't have to\n    be a superset of FIXED_REGISTERS. This vector indicates\n-   what is really call clobbered, and is used when defining \n+   what is really call clobbered, and is used when defining\n    regs_invalidated_by_call.  */\n \n #ifdef CALL_REALLY_USED_REGISTERS\n char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n #endif\n-  \n+\n /* Indexed by hard register number, contains 1 for registers that are\n    fixed use or call used registers that cannot hold quantities across\n    calls even if we are willing to save and restore them.  call fixed\n@@ -155,7 +155,7 @@ HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n #define N_REG_INTS  \\\n   ((FIRST_PSEUDO_REGISTER + (32 - 1)) / 32)\n \n-static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS] \n+static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]\n   = REG_CLASS_CONTENTS;\n \n /* For each reg class, number of regs it contains.  */\n@@ -458,7 +458,7 @@ init_reg_sets_1 ()\n \t RETURN_POPS_ARGS, in which case an explicit CLOBBER will be present.\n \t If we are generating PIC code, the PIC offset table register is\n \t preserved across calls, though the target can override that.  */\n-\t \n+\n       if (i == STACK_POINTER_REGNUM || i == FRAME_POINTER_REGNUM)\n \t;\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n@@ -558,7 +558,7 @@ init_reg_sets_1 ()\n   {\n     HARD_REG_SET c;\n     COMPL_HARD_REG_SET (c, reg_class_contents[CLASS_CANNOT_CHANGE_MODE]);\n-      \n+\n     for (i = 0; i < N_REG_CLASSES; i++)\n       {\n \tGO_IF_HARD_REG_SUBSET (reg_class_contents[i], c, ok_class);\n@@ -774,8 +774,8 @@ fix_register (name, fixed, call_used)\n \t  static const char * const what_option[2][2] = {\n \t    { \"call-saved\", \"call-used\" },\n \t    { \"no-such-option\", \"fixed\" }};\n-\t  \n-\t  error (\"can't use '%s' as a %s register\", name, \n+\n+\t  error (\"can't use '%s' as a %s register\", name,\n \t\t what_option[fixed][call_used]);\n \t}\n       else\n@@ -882,7 +882,7 @@ static void dump_regclass\tPARAMS ((FILE *));\n static void record_reg_classes\tPARAMS ((int, int, rtx *, enum machine_mode *,\n \t\t\t\t       const char **, rtx,\n \t\t\t\t       struct costs *, struct reg_pref *));\n-static int copy_cost\t\tPARAMS ((rtx, enum machine_mode, \n+static int copy_cost\t\tPARAMS ((rtx, enum machine_mode,\n \t\t\t\t       enum reg_class, int));\n static void record_address_regs\tPARAMS ((rtx, enum reg_class, int));\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n@@ -987,7 +987,7 @@ record_operand_costs (insn, op_costs, reg_pref)\n      Then handle any address registers.  Finally record the desired\n      classes for any pseudos, doing it twice if some pair of\n      operands are commutative.  */\n-\t     \n+\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       op_costs[i] = init_cost;\n@@ -1030,12 +1030,12 @@ record_operand_costs (insn, op_costs, reg_pref)\n \txconstraints[i] = constraints[i+1];\n \txconstraints[i+1] = constraints[i];\n \trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t\t    recog_data.operand, modes, \n+\t\t\t    recog_data.operand, modes,\n \t\t\t    xconstraints, insn, op_costs, reg_pref);\n       }\n \n   record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t      recog_data.operand, modes, \n+\t\t      recog_data.operand, modes,\n \t\t      constraints, insn, op_costs, reg_pref);\n }\n \f\n@@ -1193,7 +1193,7 @@ regclass (f, nregs, dump)\n \n #ifdef CLASS_CANNOT_CHANGE_MODE\n   reg_changes_mode = BITMAP_XMALLOC ();\n-#endif  \n+#endif\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n@@ -1258,7 +1258,7 @@ regclass (f, nregs, dump)\n       int index;\n \n       if (dump)\n-        fprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n+\tfprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n       memset ((char *) costs, 0, nregs * sizeof (struct costs));\n@@ -1277,7 +1277,7 @@ regclass (f, nregs, dump)\n \t    insn = scan_one_insn (insn, pass);\n \t}\n       else\n-\tfor (index = 0; index < n_basic_blocks; index++)\t\n+\tfor (index = 0; index < n_basic_blocks; index++)\n \t  {\n \t    basic_block bb = BASIC_BLOCK (index);\n \n@@ -1293,17 +1293,17 @@ regclass (f, nregs, dump)\n \t\t  break;\n \t      }\n \t  }\n-      \n+\n       /* Now for each register look at how desirable each class is\n \t and find which class is preferred.  Store that in\n \t `prefclass'.  Record in `altclass' the largest register\n \t class any of whose registers is better than memory.  */\n-    \n+\n       if (pass == 0)\n \treg_pref = reg_pref_buffer;\n \n       if (dump)\n-        {\n+\t{\n \t  dump_regclass (dump);\n \t  fprintf (dump,\"\\n\");\n \t}\n@@ -1365,12 +1365,12 @@ regclass (f, nregs, dump)\n #endif\n \t\t  )\n \t\talt = reg_class_subunion[(int) alt][class];\n-\t  \n+\n \t  /* If we don't add any classes, nothing to try.  */\n \t  if (alt == best)\n \t    alt = NO_REGS;\n \n-\t  if (dump \n+\t  if (dump\n \t      && (reg_pref[i].prefclass != (int) best\n \t\t  || reg_pref[i].altclass != (int) alt))\n \t    {\n@@ -1418,7 +1418,7 @@ regclass (f, nregs, dump)\n    This procedure works alternative by alternative.  For each alternative\n    we assume that we will be able to allocate all pseudos to their ideal\n    register class and calculate the cost of using that alternative.  Then\n-   we compute for each operand that is a pseudo-register, the cost of \n+   we compute for each operand that is a pseudo-register, the cost of\n    having the pseudo allocated to each register class and using it in that\n    alternative.  To this cost is added the cost of the alternative.\n \n@@ -1466,7 +1466,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t  classes[i] = NO_REGS;\n \t  allows_mem[i] = 0;\n \n-\t  /* If this operand has no constraints at all, we can conclude \n+\t  /* If this operand has no constraints at all, we can conclude\n \t     nothing about it since anything is valid.  */\n \n \t  if (*p == 0)\n@@ -1512,7 +1512,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t       || REGNO (ops[j]) < FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  /* This op is a pseudo but the one it matches is not.  */\n-\t\t  \n+\n \t\t  /* If we can't put the other operand into a register, this\n \t\t     alternative can't be used.  */\n \n@@ -1543,7 +1543,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t\t + (recog_data.operand_type[i] != OP_IN\n \t\t\t    ? may_move_out_cost[mode][(int) classes[i]][class]\n \t\t\t    : 0));\n-\t\t  \n+\n \t\t  /* If the alternative actually allows memory, make things\n \t\t     a bit cheaper since we won't need an extra insn to\n \t\t     load it.  */\n@@ -1726,7 +1726,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t{\n \t\t  /* We must always fail if the operand is a REG, but\n \t\t     we did not find a suitable class.\n-\t\t     \n+\n \t\t     Otherwise we may perform an uninitialized read\n \t\t     from this_op_costs after the `continue' statement\n \t\t     below.  */\n@@ -1826,7 +1826,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n      and one operand is a pseudo with the other a hard reg or a pseudo\n      that prefers a register that is in its own register class then\n      we may want to adjust the cost of that register class to -1.\n- \n+\n      Avoid the adjustment if the source does not die to avoid stressing of\n      register allocator by preferrencing two coliding registers into single\n      class.\n@@ -1906,7 +1906,7 @@ copy_cost (x, mode, class, to_p)\n   class = PREFERRED_RELOAD_CLASS (x, class);\n \n #ifdef HAVE_SECONDARY_RELOADS\n-  /* If we need a secondary reload (we assume here that we are using \n+  /* If we need a secondary reload (we assume here that we are using\n      the secondary reload as an intermediate, not a scratch register), the\n      cost is that to load the input into the intermediate register, then\n      to copy them.  We use a special value of TO_P to avoid recursion.  */\n@@ -2001,7 +2001,7 @@ record_address_regs (x, class, scale)\n \n \t/* If index and base registers are the same on this machine, just\n \t   record registers in any non-constant operands.  We assume here,\n-\t   as well as in the tests below, that all addresses are in \n+\t   as well as in the tests below, that all addresses are in\n \t   canonical form.  */\n \n \telse if (INDEX_REG_CLASS == MODE_BASE_REG_CLASS (VOIDmode))\n@@ -2192,7 +2192,7 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \t{\n \t  VARRAY_REG_INIT (reg_n_info, regno_allocated, \"reg_n_info\");\n \t  renumber = (short *) xmalloc (size_renumber);\n-\t  reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated \n+\t  reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated\n \t\t\t\t\t      * sizeof (struct reg_pref));\n \t}\n \n@@ -2205,15 +2205,15 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \t      free ((char *) renumber);\n \t      free ((char *) reg_pref);\n \t      renumber = (short *) xmalloc (size_renumber);\n-\t      reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated \n+\t      reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated\n \t\t\t\t\t\t  * sizeof (struct reg_pref));\n \t    }\n \n \t  else\n \t    {\n \t      renumber = (short *) xrealloc ((char *) renumber, size_renumber);\n \t      reg_pref_buffer = (struct reg_pref *) xrealloc ((char *) reg_pref_buffer,\n-\t\t\t\t\t\t   regno_allocated \n+\t\t\t\t\t\t   regno_allocated\n \t\t\t\t\t\t   * sizeof (struct reg_pref));\n \t    }\n \t}\n@@ -2232,7 +2232,7 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n     {\n       /* Loop through each of the segments allocated for the actual\n \t reg_info pages, and set up the pointers, zero the pages, etc.  */\n-      for (reg_data = reg_info_head; \n+      for (reg_data = reg_info_head;\n \t   reg_data && reg_data->max_index >= min;\n \t   reg_data = reg_data->next)\n \t{\n@@ -2318,7 +2318,7 @@ free_reg_info ()\n \n int max_parallel;\n \n-/* Used as a temporary to record the largest number of registers in \n+/* Used as a temporary to record the largest number of registers in\n    PARALLEL in a SET_DEST.  This is added to max_parallel.  */\n \n static int max_set_parallel;\n@@ -2467,7 +2467,7 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t Likewise if it is setting the destination from an address or from a\n \t value equivalent to an address or to the sum of an address and\n \t something else.\n-\t\t     \n+\n \t But don't do any of this if the pseudo corresponds to a user\n \t variable since it should have already been set as a pointer based\n \t on the type.  */"}, {"sha": "7b073f29e7330b8a4abc869997bbe86cd8b645f6", "filename": "gcc/regmove.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -269,7 +269,7 @@ mark_flags_life_zones (flags)\n       {\n \tint i;\n \tfor (i = 0; i < flags_nregs; ++i)\n-          live |= REGNO_REG_SET_P (BASIC_BLOCK (block)->global_live_at_start,\n+\t  live |= REGNO_REG_SET_P (BASIC_BLOCK (block)->global_live_at_start,\n \t\t\t\t   flags_regno + i);\n       }\n #endif\n@@ -950,7 +950,7 @@ fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n       if (perhaps_ends_bb_p (p))\n \tbreak;\n       else if (! INSN_P (p))\n-        continue;\n+\tcontinue;\n \n       if (find_regno_note (p, REG_DEAD, REGNO (dst)))\n \tdst_death = p;\n@@ -962,7 +962,7 @@ fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n \t  && GET_CODE (SET_SRC (pset)) == PLUS\n \t  && XEXP (SET_SRC (pset), 0) == src\n \t  && GET_CODE (XEXP (SET_SRC (pset), 1)) == CONST_INT)\n-        {\n+\t{\n \t  HOST_WIDE_INT newconst\n \t    = INTVAL (offset) - INTVAL (XEXP (SET_SRC (pset), 1));\n \t  rtx add = gen_add3_insn (dst, dst, GEN_INT (newconst));\n@@ -1013,10 +1013,10 @@ fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n #endif\n \t      return 1;\n \t    }\n-        }\n+\t}\n \n       if (reg_set_p (dst, PATTERN (p)))\n-        break;\n+\tbreak;\n \n       /* If we have passed a call instruction, and the\n          pseudo-reg SRC is not already live across a call,\n@@ -1025,19 +1025,19 @@ fixup_match_2 (insn, dst, src, offset, regmove_dump_file)\n \t hard regs are clobbered.  Thus, we only use it for src for\n \t non-call insns.  */\n       if (GET_CODE (p) == CALL_INSN)\n-        {\n+\t{\n \t  if (! dst_death)\n \t    num_calls++;\n \n-          if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n-            break;\n+\t  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n+\t    break;\n \n \t  if (call_used_regs [REGNO (dst)]\n \t      || find_reg_fusage (p, CLOBBER, dst))\n \t    break;\n-        }\n+\t}\n       else if (reg_set_p (src, PATTERN (p)))\n-        break;\n+\tbreak;\n     }\n \n   return 0;\n@@ -1131,8 +1131,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t    }\n \t\t}\n \t    }\n-          if (! flag_regmove)\n-            continue;\n+\t  if (! flag_regmove)\n+\t    continue;\n \n \t  if (! find_matches (insn, &match))\n \t    continue;\n@@ -1370,7 +1370,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t it for this optimization, as this would make it\n \t\t no longer equivalent to a constant.  */\n \n-              if (reg_is_remote_constant_p (src, insn, f))\n+\t      if (reg_is_remote_constant_p (src, insn, f))\n \t\t{\n \t\t  if (!copy_src)\n \t\t    {"}, {"sha": "9061bc3663b62a0adfa75d565e354af19e9c4561", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -3563,7 +3563,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   for (i = 0; i < noperands; i++)\n     goal_alternative_matched[i] = -1;\n- \n+\n   for (i = 0; i < noperands; i++)\n     if (! goal_alternative_win[i]\n \t&& goal_alternative_matches[i] >= 0)\n@@ -6824,7 +6824,7 @@ regno_clobbered_p (regno, insn, mode, sets)\n \t      && GET_CODE (XEXP (elt, 0)) == REG)\n \t    {\n \t      unsigned int test = REGNO (XEXP (elt, 0));\n-\t      \n+\n \t      if (test >= regno && test < endregno)\n \t\treturn 1;\n \t    }"}, {"sha": "1bcd29b3ee446663aa0e332907c0449d865f096c", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -5746,8 +5746,8 @@ choose_reload_regs (chain)\n \n \t      /* If we found an equivalent reg, say no code need be generated\n \t\t to load it, and use it as our reload reg.  */\n-\t      if (equiv != 0 \n-\t\t  && (regno != HARD_FRAME_POINTER_REGNUM \n+\t      if (equiv != 0\n+\t\t  && (regno != HARD_FRAME_POINTER_REGNUM\n \t\t      || !frame_pointer_needed))\n \t\t{\n \t\t  int nr = HARD_REGNO_NREGS (regno, rld[r].mode);\n@@ -6611,7 +6611,7 @@ emit_input_reload_insns (chain, rl, old, j)\n   /* End this sequence.  */\n   *where = get_insns ();\n   end_sequence ();\n-\t\t\t\t \n+\n   /* Update reload_override_in so that delete_address_reloads_1\n      can see the actual register usage.  */\n   if (oldequiv_reg)\n@@ -8223,7 +8223,7 @@ reload_cse_simplify_set (set, insn)\n #ifdef LOAD_EXTEND_OP\n   /* When replacing a memory with a register, we need to honor assumptions\n      that combine made wrt the contents of sign bits.  We'll do this by\n-     generating an extend instruction instead of a reg->reg copy.  Thus \n+     generating an extend instruction instead of a reg->reg copy.  Thus\n      the destination must be a register that we can widen.  */\n   if (GET_CODE (src) == MEM\n       && GET_MODE_BITSIZE (GET_MODE (src)) < BITS_PER_WORD\n@@ -9388,7 +9388,7 @@ move2add_note_store (dst, set, data)\n \t  reg_set_luid[regno] = move2add_last_label_luid + 1;\n \t  reg_mode[regno] = mode;\n \t  return;\n-\t  \n+\n \tdefault:\n \tinvalidate:\n \t  /* Invalidate the contents of the register.  */\n@@ -9474,7 +9474,7 @@ copy_eh_notes (insn, x)\n       for (; x != 0; x = NEXT_INSN (x))\n \t{\n \t  if (may_trap_p (PATTERN (x)))\n-\t    REG_NOTES (x) \n+\t    REG_NOTES (x)\n \t      = gen_rtx_EXPR_LIST (REG_EH_REGION, XEXP (eh_note, 0),\n \t\t\t\t   REG_NOTES (x));\n \t}\n@@ -9485,7 +9485,7 @@ copy_eh_notes (insn, x)\n    abnormal calls moving basic block end, but in fact it wants to emit\n    them on the edge.  Looks for abnormal call edges, find backward the\n    proper call and fix the damage.\n- \n+\n    Similar handle instructions throwing exceptions internally.  */\n void\n fixup_abnormal_edges ()"}, {"sha": "e890f8799e6ca9d96e6f6f92f9ad8cd62da5cbce", "filename": "gcc/resource.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for computing resource usage of specific insns.\n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -281,7 +281,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \t We can not just fall through here since then we would be confused\n \t by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t traditional asms unlike their normal usage.  */\n-      \n+\n       for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \tmark_referenced_resources (ASM_OPERANDS_INPUT (x, i), res, 0);\n       return;\n@@ -423,7 +423,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n }\n \f\n /* A subroutine of mark_target_live_regs.  Search forward from TARGET\n-   looking for registers that are set before they are used.  These are dead. \n+   looking for registers that are set before they are used.  These are dead.\n    Stop after passing a few conditional jumps, and/or a small\n    number of unconditional branches.  */\n \n@@ -721,7 +721,7 @@ mark_set_resources (x, res, in_dest, mark_type)\n     case CLOBBER:\n       mark_set_resources (XEXP (x, 0), res, 1, MARK_SRC_DEST);\n       return;\n-      \n+\n     case SEQUENCE:\n       for (i = 0; i < XVECLEN (x, 0); i++)\n \tif (! (INSN_ANNULLED_BRANCH_P (XVECEXP (x, 0, 0))\n@@ -821,7 +821,7 @@ mark_set_resources (x, res, in_dest, mark_type)\n \t We can not just fall through here since then we would be confused\n \t by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t traditional asms unlike their normal usage.  */\n-      \n+\n       for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \tmark_set_resources (ASM_OPERANDS_INPUT (x, i), res, in_dest,\n \t\t\t    MARK_SRC_DEST);\n@@ -946,7 +946,7 @@ mark_target_live_regs (insns, target, res)\n \t}\n       else\n \t{\n-\t  /* Allocate a place to put our results and chain it into the \n+\t  /* Allocate a place to put our results and chain it into the\n \t     hash table.  */\n \t  tinfo = (struct target_info *) xmalloc (sizeof (struct target_info));\n \t  tinfo->uid = INSN_UID (target);\n@@ -1056,7 +1056,7 @@ mark_target_live_regs (insns, target, res)\n \t\t      = (first_regno\n \t\t\t + HARD_REGNO_NREGS (first_regno,\n \t\t\t\t\t     GET_MODE (XEXP (link, 0))));\n-\t\t\t \n+\n \t\t    for (i = first_regno; i < last_regno; i++)\n \t\t      SET_HARD_REG_BIT (pending_dead_regs, i);\n \t\t  }\n@@ -1075,7 +1075,7 @@ mark_target_live_regs (insns, target, res)\n \t\t      = (first_regno\n \t\t\t + HARD_REGNO_NREGS (first_regno,\n \t\t\t\t\t     GET_MODE (XEXP (link, 0))));\n-\t\t\t \n+\n \t\t    for (i = first_regno; i < last_regno; i++)\n \t\t      CLEAR_HARD_REG_BIT (current_live_regs, i);\n \t\t  }\n@@ -1093,7 +1093,7 @@ mark_target_live_regs (insns, target, res)\n \t     RTL chain when there are no epilogue insns.  Certain resources\n \t     are implicitly required at that point.  */\n \t  else if (GET_CODE (real_insn) == NOTE\n- \t\t   && NOTE_LINE_NUMBER (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t   && NOTE_LINE_NUMBER (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n \t    IOR_HARD_REG_SET (current_live_regs, start_of_epilogue_needs.regs);\n \t}\n \n@@ -1237,12 +1237,12 @@ free_resource_info ()\n   if (target_hash_table != NULL)\n     {\n       int i;\n-      \n-      for (i = 0; i < TARGET_HASH_PRIME; ++i) \n+\n+      for (i = 0; i < TARGET_HASH_PRIME; ++i)\n \t{\n \t  struct target_info *ti = target_hash_table[i];\n \n-\t  while (ti) \n+\t  while (ti)\n \t    {\n \t      struct target_info *next = ti->next;\n \t      free (ti);\n@@ -1268,7 +1268,7 @@ clear_hashed_info_for_insn (insn)\n      rtx insn;\n {\n   struct target_info *tinfo;\n-      \n+\n   if (target_hash_table != NULL)\n     {\n       for (tinfo = target_hash_table[INSN_UID (insn) % TARGET_HASH_PRIME];"}, {"sha": "560d54e89c9de8af080a11202be6b2e64995c463", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -1,5 +1,5 @@\n /* RTL specific diagnostic subroutines for the GNU C compiler\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n This file is part of GCC.\n@@ -84,7 +84,7 @@ diagnostic_for_asm (insn, msg, args_ptr, warn)\n \n   set_diagnostic_context (&dc, msg, args_ptr, NULL, 0, warn);\n   file_and_line_for_asm (insn, &diagnostic_file_location (&dc),\n-                         &diagnostic_line_location (&dc));\n+\t\t\t &diagnostic_line_location (&dc));\n   report_diagnostic (&dc);\n }\n "}, {"sha": "13e7380369bc06dfd7a41df2aa7d151acd48466d", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -417,7 +417,7 @@ get_mode_alignment (mode)\n     alignment = GET_MODE_UNIT_SIZE (mode);\n   else\n     alignment = GET_MODE_SIZE (mode);\n-  \n+\n   /* Extract the LSB of the size.  */\n   alignment = alignment & -alignment;\n   alignment *= BITS_PER_UNIT;"}, {"sha": "7db1f01b1e88a280dff2532e8ec67d3dcd61ac04", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a2274a17660ba099a5f5b15536421939e46c1d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=a6a2274a17660ba099a5f5b15536421939e46c1d", "patch": "@@ -176,7 +176,7 @@ rtx_varies_p (x, for_alias)\n \t during alias analysis.  */\n       return (! for_alias && rtx_varies_p (XEXP (x, 0), for_alias))\n \t     || rtx_varies_p (XEXP (x, 1), for_alias);\n-      \n+\n     case ASM_OPERANDS:\n       if (MEM_VOLATILE_P (x))\n \treturn 1;\n@@ -265,9 +265,9 @@ rtx_addr_can_trap_p (x)\n   return 1;\n }\n \n-/* Return 1 if X refers to a memory location whose address \n+/* Return 1 if X refers to a memory location whose address\n    cannot be compared reliably with constant addresses,\n-   or if X refers to a BLKmode memory object. \n+   or if X refers to a BLKmode memory object.\n    FOR_ALIAS is nonzero if we are called from alias analysis; if it is\n    zero, we are slightly more conservative.  */\n \n@@ -553,9 +553,9 @@ global_reg_mentioned_p (x)\n \t  x = CALL_INSN_FUNCTION_USAGE (x);\n \t  if (x == 0)\n \t    return 0;\n-        }\n+\t}\n       else\n-        x = PATTERN (x);\n+\tx = PATTERN (x);\n     }\n \n   return for_each_rtx (&x, global_reg_mentioned_p_1, NULL);\n@@ -668,7 +668,7 @@ reg_mentioned_p (reg, in)\n     case CONST_DOUBLE:\n       /* These are kept unique for a given value.  */\n       return 0;\n-      \n+\n     default:\n       break;\n     }\n@@ -808,7 +808,7 @@ reg_referenced_p (x, body)\n \tif (reg_referenced_p (x, XVECEXP (body, 0, i)))\n \t  return 1;\n       return 0;\n-      \n+\n     case CLOBBER:\n       if (GET_CODE (XEXP (body, 0)) == MEM)\n \tif (reg_overlap_mentioned_p (x, XEXP (XEXP (body, 0), 0)))\n@@ -923,7 +923,7 @@ regs_set_between_p (x, start, end)\n \n     case REG:\n       return reg_set_between_p (x, start, end);\n-      \n+\n     default:\n       break;\n     }\n@@ -979,7 +979,7 @@ modified_between_p (x, start, end)\n \n     case REG:\n       return reg_set_between_p (x, start, end);\n-      \n+\n     default:\n       break;\n     }\n@@ -1190,7 +1190,7 @@ multiple_sets (insn)\n {\n   int found;\n   int i;\n-  \n+\n   /* INSN must be an insn.  */\n   if (! INSN_P (insn))\n     return 0;\n@@ -1208,7 +1208,7 @@ multiple_sets (insn)\n \t      found = 1;\n \t  }\n     }\n-  \n+\n   /* Either zero or one SET.  */\n   return 0;\n }\n@@ -1340,14 +1340,14 @@ find_last_value (x, pinsn, valid_to, allow_hwreg)\n \t\treturn src;\n \t      }\n \t  }\n-\t  \n+\n \t/* If set in non-simple way, we don't have a value.  */\n \tif (reg_set_p (x, p))\n \t  break;\n       }\n \n   return x;\n-}     \n+}\n \f\n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X\n@@ -1392,7 +1392,7 @@ refers_to_regno_p (regno, endregno, x, loc)\n \treturn 1;\n \n       return (endregno > x_regno\n-\t      && regno < x_regno + (x_regno < FIRST_PSEUDO_REGISTER \n+\t      && regno < x_regno + (x_regno < FIRST_PSEUDO_REGISTER\n \t\t\t\t    ? HARD_REGNO_NREGS (x_regno, GET_MODE (x))\n \t\t\t      : 1));\n \n@@ -1597,7 +1597,7 @@ reg_set_last (x, insn)\n \n   If the item being stored in or clobbered is a SUBREG of a hard register,\n   the SUBREG will be passed.  */\n-     \n+\n void\n note_stores (x, fun, data)\n      rtx x;\n@@ -1795,7 +1795,7 @@ dead_or_set_regno_p (insn, test_regno)\n   if (GET_CODE (pattern) == SET)\n     {\n       rtx dest = SET_DEST (PATTERN (insn));\n- \n+\n       /* A value is totally replaced if it is the destination or the\n \t destination is a SUBREG of REGNO that does not change the number of\n \t words in it.  */\n@@ -1946,11 +1946,11 @@ find_reg_fusage (insn, code, datum)\n       rtx link;\n \n       for (link = CALL_INSN_FUNCTION_USAGE (insn);\n-           link;\n+\t   link;\n \t   link = XEXP (link, 1))\n-        if (GET_CODE (XEXP (link, 0)) == code\n+\tif (GET_CODE (XEXP (link, 0)) == code\n \t    && rtx_equal_p (datum, XEXP (XEXP (link, 0), 0)))\n-          return 1;\n+\t  return 1;\n     }\n   else\n     {\n@@ -1960,15 +1960,15 @@ find_reg_fusage (insn, code, datum)\n \t to pseudo registers, so don't bother checking.  */\n \n       if (regno < FIRST_PSEUDO_REGISTER)\n-        {\n+\t{\n \t  unsigned int end_regno\n \t    = regno + HARD_REGNO_NREGS (regno, GET_MODE (datum));\n \t  unsigned int i;\n \n \t  for (i = regno; i < end_regno; i++)\n \t    if (find_regno_fusage (insn, code, i))\n \t      return 1;\n-        }\n+\t}\n     }\n \n   return 0;\n@@ -2158,7 +2158,7 @@ volatile_insn_p (x)\n   {\n     const char *fmt = GET_RTX_FORMAT (code);\n     int i;\n-    \n+\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n@@ -2225,7 +2225,7 @@ volatile_refs_p (x)\n   {\n     const char *fmt = GET_RTX_FORMAT (code);\n     int i;\n-    \n+\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n@@ -2303,7 +2303,7 @@ side_effects_p (x)\n   {\n     const char *fmt = GET_RTX_FORMAT (code);\n     int i;\n-    \n+\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n@@ -2469,7 +2469,7 @@ inequality_comparisons_p (x)\n     case GE:\n     case GEU:\n       return 1;\n-      \n+\n     default:\n       break;\n     }\n@@ -2492,7 +2492,7 @@ inequality_comparisons_p (x)\n \t      return 1;\n \t}\n     }\n-\t    \n+\n   return 0;\n }\n \f\n@@ -2566,12 +2566,12 @@ replace_rtx (x, from, to)\n     }\n \n   return x;\n-}  \n+}\n \f\n /* Throughout the rtx X, replace many registers according to REG_MAP.\n    Return the replacement for X (which may be X with altered contents).\n    REG_MAP[R] is the replacement for register R, or 0 for don't replace.\n-   NREGS is the length of REG_MAP; regs >= NREGS are not mapped.  \n+   NREGS is the length of REG_MAP; regs >= NREGS are not mapped.\n \n    We only support REG_MAP entries of REG or SUBREG.  Also, hard registers\n    should not be mapped to pseudos or vice versa since validate_change\n@@ -2629,7 +2629,7 @@ replace_regs (x, reg_map, nregs, replace_dest)\n \t{\n \t  rtx map_val = reg_map[REGNO (SUBREG_REG (x))];\n \t  return simplify_gen_subreg (GET_MODE (x), map_val,\n-\t\t\t\t      GET_MODE (SUBREG_REG (x)), \n+\t\t\t\t      GET_MODE (SUBREG_REG (x)),\n \t\t\t\t      SUBREG_BYTE (x));\n \t}\n       break;\n@@ -2651,7 +2651,7 @@ replace_regs (x, reg_map, nregs, replace_dest)\n \n       SET_SRC (x) = replace_regs (SET_SRC (x), reg_map, nregs, 0);\n       return x;\n-      \n+\n     default:\n       break;\n     }\n@@ -2808,9 +2808,9 @@ for_each_rtx (x, f, data)\n   length = GET_RTX_LENGTH (GET_CODE (*x));\n   format = GET_RTX_FORMAT (GET_CODE (*x));\n \n-  for (i = 0; i < length; ++i) \n+  for (i = 0; i < length; ++i)\n     {\n-      switch (format[i]) \n+      switch (format[i])\n \t{\n \tcase 'e':\n \t  result = for_each_rtx (&XEXP (*x, i), f, data);\n@@ -2820,7 +2820,7 @@ for_each_rtx (x, f, data)\n \n \tcase 'V':\n \tcase 'E':\n-\t  if (XVEC (*x, i) != 0) \n+\t  if (XVEC (*x, i) != 0)\n \t    {\n \t      int j;\n \t      for (j = 0; j < XVECLEN (*x, i); ++j)\n@@ -2830,7 +2830,7 @@ for_each_rtx (x, f, data)\n \t\t    return result;\n \t\t}\n \t    }\n-\t  break; \n+\t  break;\n \n \tdefault:\n \t  /* Nothing to do.  */\n@@ -2950,8 +2950,8 @@ auto_inc_p (x)\n    to and including TO is safe to move.  If NEW_TO is non-NULL, and\n    the sequence is not already safe to move, but can be easily\n    extended to a sequence which is safe, then NEW_TO will point to the\n-   end of the extended sequence.  \n- \n+   end of the extended sequence.\n+\n    For now, this function only checks that the region contains whole\n    exception regions, but it could be extended to check additional\n    conditions as well.  */\n@@ -3006,7 +3006,7 @@ insns_safe_to_move_p (from, to, new_to)\n \t    /* It's OK to move the sequence if there were matched sets of\n \t       exception region notes.  */\n \t    return eh_region_count == 0;\n-\t  \n+\n \t  past_to_p = 1;\n \t}\n \n@@ -3021,7 +3021,7 @@ insns_safe_to_move_p (from, to, new_to)\n       /* Go to the next instruction.  */\n       r = NEXT_INSN (r);\n     }\n-  \n+\n   return 0;\n }\n \n@@ -3118,7 +3118,7 @@ subreg_regno_offset (xregno, xmode, offset, ymode)\n   nregs_ymode = HARD_REGNO_NREGS (xregno, ymode);\n   if (offset == 0 || nregs_xmode == nregs_ymode)\n     return 0;\n-  \n+\n   /* size of ymode must not be greater than the size of xmode.  */\n   mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n   if (mode_multiple == 0)\n@@ -3130,16 +3130,16 @@ subreg_regno_offset (xregno, xmode, offset, ymode)\n }\n \n /* Return the final regno that a subreg expression refers to.  */\n-unsigned int \n+unsigned int\n subreg_regno (x)\n      rtx x;\n {\n   unsigned int ret;\n   rtx subreg = SUBREG_REG (x);\n   int regno = REGNO (subreg);\n \n-  ret = regno + subreg_regno_offset (regno, \n-\t\t\t\t     GET_MODE (subreg), \n+  ret = regno + subreg_regno_offset (regno,\n+\t\t\t\t     GET_MODE (subreg),\n \t\t\t\t     SUBREG_BYTE (x),\n \t\t\t\t     GET_MODE (x));\n   return ret;\n@@ -3166,7 +3166,7 @@ parms_set (x, pat, data)\n     }\n }\n \n-/* Look backward for first parameter to be loaded.  \n+/* Look backward for first parameter to be loaded.\n    Do not skip BOUNDARY.  */\n rtx\n find_first_parameter_load (call_insn, boundary)\n@@ -3219,7 +3219,7 @@ find_first_parameter_load (call_insn, boundary)\n \t}\n \n       if (INSN_P (before))\n-        note_stores (PATTERN (before), parms_set, &parm);\n+\tnote_stores (PATTERN (before), parms_set, &parm);\n     }\n   return before;\n }"}]}