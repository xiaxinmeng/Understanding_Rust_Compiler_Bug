{"sha": "56e2583099eaf3ed6645b89317a2f59027a9b301", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlMjU4MzA5OWVhZjNlZDY2NDViODkzMTdhMmY1OTAyN2E5YjMwMQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-07-20T21:37:27Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-07-20T21:37:27Z"}, "message": "sh.md: Group and sort shift related patterns.\n\n\t* config/sh/sh.md: Group and sort shift related patterns.\n\t(ashlsi3_n, *ashlhi3_n, lshrsi3_n): Remove length attributes.\n\nFrom-SVN: r189730", "tree": {"sha": "02b2165f9770fbd5f3f9efd9eb3ff8729984a41c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02b2165f9770fbd5f3f9efd9eb3ff8729984a41c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56e2583099eaf3ed6645b89317a2f59027a9b301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e2583099eaf3ed6645b89317a2f59027a9b301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e2583099eaf3ed6645b89317a2f59027a9b301", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e2583099eaf3ed6645b89317a2f59027a9b301/comments", "author": null, "committer": null, "parents": [{"sha": "c21a1dbbf339afb429b1e35394d1bdf1741cff45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c21a1dbbf339afb429b1e35394d1bdf1741cff45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c21a1dbbf339afb429b1e35394d1bdf1741cff45"}], "stats": {"total": 584, "additions": 283, "deletions": 301}, "files": [{"sha": "c6fd330136863937b04f3015b38988f531596e6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2583099eaf3ed6645b89317a2f59027a9b301/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2583099eaf3ed6645b89317a2f59027a9b301/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56e2583099eaf3ed6645b89317a2f59027a9b301", "patch": "@@ -1,3 +1,8 @@\n+2012-07-20  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh.md: Group and sort shift related patterns.\n+\t(ashlsi3_n, *ashlhi3_n, lshrsi3_n): Remove length attributes.\n+\n 2012-07-20  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.c (cris_asm_output_ident): Remove unused"}, {"sha": "14463473caa8dd1d88cc153ddb39ba4055261ad6", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 278, "deletions": 301, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2583099eaf3ed6645b89317a2f59027a9b301/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2583099eaf3ed6645b89317a2f59027a9b301/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=56e2583099eaf3ed6645b89317a2f59027a9b301", "patch": "@@ -3496,12 +3496,35 @@ label:\n     FAIL;\n })\n \n-;;\n-;; shift left\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; SImode shift left\n+\n+(define_expand \"ashlsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"\"\n+{\n+  if (TARGET_SHMEDIA)\n+    {\n+      emit_insn (gen_ashlsi3_media (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  if (CONST_INT_P (operands[2])\n+      && sh_dynamicalize_shift_p (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  if (TARGET_SH3 || TARGET_SH2A)\n+    {\n+      emit_insn (gen_ashlsi3_std (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  if (! immediate_operand (operands[2], GET_MODE (operands[2])))\n+    FAIL;\n+})\n \n ;; This pattern is used by init_expmed for computing the costs of shift\n ;; insns.\n-\n (define_insn_and_split \"ashlsi3_std\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r,r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0,0,0\")\n@@ -3528,16 +3551,6 @@ label:\n   [(set_attr \"length\" \"*,*,*,4\")\n    (set_attr \"type\" \"dyn_shift,arith,arith,arith\")])\n \n-(define_insn \"ashlhi3_k\"\n-  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(ashift:HI (match_operand:HI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t   (match_operand:HI 2 \"const_int_operand\" \"M,P27\")))]\n-  \"TARGET_SH1 && satisfies_constraint_P27 (operands[2])\"\n-  \"@\n-\tadd\t%0,%0\n-\tshll%O2\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\n (define_insn_and_split \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3550,16 +3563,37 @@ label:\n {\n   gen_shifty_op (ASHIFT, operands);\n   DONE;\n-}\n-  [(set (attr \"length\")\n-\t(cond [(match_test \"shift_insns_rtx (insn)\")\n-\t       (const_string \"2\")\n-\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 2))\n-\t       (const_string \"4\")\n-\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 3))\n-\t       (const_string \"6\")]\n-\t      (const_string \"8\")))\n-   (set_attr \"type\" \"arith\")])\n+})\n+\n+(define_insn \"ashlsi_c\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\") (const_int 1)))\n+   (set (reg:SI T_REG)\n+\t(lt:SI (match_dup 1) (const_int 0)))]\n+  \"TARGET_SH1\"\n+  \"shll\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*ashlsi_c_void\"\n+  [(set (reg:SI T_REG)\n+\t(lt:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\") (const_int 0)))\n+   (clobber (match_scratch:SI 1 \"=0\"))]\n+  \"TARGET_SH1 && cse_not_expected\"\n+  \"shll\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\") (const_int 0))\n+   (set (reg:SI T_REG)\n+\t(gt:SI (match_dup 0) (match_operand:SI 1 \"arith_reg_operand\" \"\")))]\n+  \"TARGET_SH1\n+   && peep2_reg_dead_p (2, operands[0])\n+   && peep2_reg_dead_p (2, operands[1])\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_ashlsi_c (operands[1], operands[1]));\n+  DONE;\n+})\n \n (define_insn \"ashlsi3_media\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n@@ -3572,29 +3606,8 @@ label:\n   [(set_attr \"type\" \"arith_media\")\n    (set_attr \"highpart\" \"ignore\")])\n \n-(define_expand \"ashlsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t   (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:SI T_REG))])]\n-  \"\"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      emit_insn (gen_ashlsi3_media (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  if (CONST_INT_P (operands[2])\n-      && sh_dynamicalize_shift_p (operands[2]))\n-    operands[2] = force_reg (SImode, operands[2]);\n-  if (TARGET_SH3 || TARGET_SH2A)\n-    {\n-      emit_insn (gen_ashlsi3_std (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  if (! immediate_operand (operands[2], GET_MODE (operands[2])))\n-    FAIL;\n-})\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; HImode shift left\n \n (define_expand \"ashlhi3\"\n   [(parallel [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n@@ -3611,6 +3624,16 @@ label:\n     operands[1] = copy_to_mode_reg (HImode, operands[1]);\n })\n \n+(define_insn \"ashlhi3_k\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r,r\")\n+\t(ashift:HI (match_operand:HI 1 \"arith_reg_operand\" \"0,0\")\n+\t\t   (match_operand:HI 2 \"const_int_operand\" \"M,P27\")))]\n+  \"TARGET_SH1 && satisfies_constraint_P27 (operands[2])\"\n+  \"@\n+\tadd\t%0,%0\n+\tshll%O2\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn_and_split \"*ashlhi3_n\"\n   [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r\")\n \t(ashift:HI (match_operand:HI 1 \"arith_reg_operand\" \"0\")\n@@ -3623,18 +3646,115 @@ label:\n {\n   gen_shifty_hi_op (ASHIFT, operands);\n   DONE;\n-}\n-  [(set (attr \"length\")\n-\t(cond [(match_test \"shift_insns_rtx (insn)\")\n-\t       (const_string \"2\")\n-\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 2))\n-\t       (const_string \"4\")]\n-\t      (const_string \"6\")))\n+})\n+\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; DImode shift left\n+\n+(define_expand \"ashldi3\"\n+  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+\t\t\t      (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"\"\n+{\n+  if (TARGET_SHMEDIA)\n+    {\n+      emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n+    {\n+      emit_insn (gen_ashldi3_k (operands[0], operands[1]));\n+      DONE;\n+    }\n+  else if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 32)\n+    {\n+      emit_insn (gen_ashldi3_std (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+})\n+\n+;; Expander for DImode shift left with SImode operations.\n+(define_expand \"ashldi3_std\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+                   (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n+  \"TARGET_SH1 && INTVAL (operands[2]) < 32\"\n+{\n+  rtx low_src = gen_lowpart (SImode, operands[1]);\n+  rtx high_src = gen_highpart (SImode, operands[1]);\n+  rtx dst = gen_reg_rtx (DImode);\n+  rtx low_dst = gen_lowpart (SImode, dst);\n+  rtx high_dst = gen_highpart (SImode, dst);\n+  rtx tmp0 = gen_reg_rtx (SImode);\n+  rtx tmp1 = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_lshrsi3 (tmp0, low_src, GEN_INT (32 - INTVAL (operands[2]))));\n+  emit_insn (gen_ashlsi3 (low_dst, low_src, operands[2]));  \n+  emit_insn (gen_ashlsi3 (tmp1, high_src, operands[2]));  \n+  emit_insn (gen_iorsi3 (high_dst, tmp0, tmp1));\n+  emit_move_insn (operands[0], dst);\n+  DONE;\n+})\n+\n+;; This should be an define_insn_and_split.\n+(define_insn \"ashldi3_k\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n+\t\t   (const_int 1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"shll\t%R0\\;rotcl\t%S0\"\n+  [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"arith\")])\n \n+(define_insn \"ashldi3_media\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,r\")\n+\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r,r\")\n+\t\t   (match_operand:DI 2 \"shift_count_operand\" \"r,n\")))]\n+  \"TARGET_SHMEDIA\"\n+  \"@\n+\tshlld\t%1, %2, %0\n+\tshlli\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*ashldisi3_media\"\n+  [(set (subreg:DI (match_operand:SI 0 \"arith_reg_operand\" \"=r\") 0)\n+\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n+  \"TARGET_SHMEDIA && INTVAL (operands[2]) < 32\"\n+  \"shlli.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")\n+   (set_attr \"highpart\" \"ignore\")])\n+\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; SImode arithmetic shift right\n ;;\n-;; arithmetic shift right\n-;;\n+;; We can't do HImode right shifts correctly unless we start out with an\n+;; explicit zero / sign extension; doing that would result in worse overall\n+;; code, so just let the machine independent code widen the mode.\n+;; That's why we don't have ashrhi3_k / lshrhi3_k / lshrhi3_m / lshrhi3 .\n+\n+(define_expand \"ashrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t\t   (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"\"\n+{\n+  if (TARGET_SHMEDIA)\n+    {\n+      emit_insn (gen_ashrsi3_media (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  if (expand_ashiftrt (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n \n (define_insn \"ashrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n@@ -3645,14 +3765,6 @@ label:\n   \"shar\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-;; We can't do HImode right shifts correctly unless we start out with an\n-;; explicit zero / sign extension; doing that would result in worse overall\n-;; code, so just let the machine independent code widen the mode.\n-;; That's why we don't have ashrhi3_k / lshrhi3_k / lshrhi3_m / lshrhi3 .\n-\n-\n-;; ??? This should be a define expand.\n-\n (define_insn_and_split \"ashrsi2_16\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n         (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n@@ -3666,8 +3778,6 @@ label:\n   operands[2] = gen_lowpart (HImode, operands[0]);\n })\n \n-;; ??? This should be a define expand.\n-\n (define_insn_and_split \"ashrsi2_31\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3683,36 +3793,6 @@ label:\n   DONE;\n })\n \n-(define_peephole2\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\") (const_int 0))\n-   (set (reg:SI T_REG)\n-\t(gt:SI (match_dup 0) (match_operand:SI 1 \"arith_reg_operand\" \"\")))]\n-  \"TARGET_SH1\n-   && peep2_reg_dead_p (2, operands[0])\n-   && peep2_reg_dead_p (2, operands[1])\"\n-  [(const_int 0)]\n-{\n-  emit_insn (gen_ashlsi_c (operands[1], operands[1]));\n-  DONE;\n-})\n-\n-(define_insn \"ashlsi_c\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\") (const_int 1)))\n-   (set (reg:SI T_REG)\n-\t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_SH1\"\n-  \"shll\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"*ashlsi_c_void\"\n-  [(set (reg:SI T_REG)\n-\t(lt:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\") (const_int 0)))\n-   (clobber (match_scratch:SI 1 \"=0\"))]\n-  \"TARGET_SH1 && cse_not_expected\"\n-  \"shll\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\n (define_insn \"ashrsi3_d\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3744,25 +3824,105 @@ label:\n   [(set_attr \"type\" \"arith_media\")\n    (set_attr \"highpart\" \"ignore\")])\n \n-(define_expand \"ashrsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t\t   (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:SI T_REG))])]\n-  \"\"\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; DImode arithmetic shift right\n+\n+(define_expand \"ashrdi3\"\n+  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n+\t\t   (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"\"\n {\n   if (TARGET_SHMEDIA)\n     {\n-      emit_insn (gen_ashrsi3_media (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_ashrdi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (expand_ashiftrt (operands))\n-    DONE;\n-  else\n+  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 1)\n     FAIL;\n })\n \n-;; logical shift right\n+;; This should be a define_insn_and_split\n+(define_insn \"ashrdi3_k\"\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"shar\t%S0\\;rotcr\t%R0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"arith\")])\n+\n+(define_insn \"ashrdi3_media\"\n+  [(set (match_operand:DI 0 \"ext_dest_operand\" \"=r,r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r,r\")\n+\t\t     (match_operand:DI 2 \"shift_count_operand\" \"r,n\")))]\n+  \"TARGET_SHMEDIA\n+   && (arith_reg_dest (operands[0], DImode)\n+       || (CONST_INT_P (operands[2]) && INTVAL (operands[2]) >= 32))\"\n+  \"@\n+\tshard\t%1, %2, %0\n+\tshari\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"*ashrdisi3_media\"\n+  [(set (subreg:DI (match_operand:SI 0 \"arith_reg_operand\" \"=r\") 0)\n+\t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n+  \"TARGET_SHMEDIA && INTVAL (operands[2]) < 32\"\n+  \"shari.l\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")\n+   (set_attr \"highpart\" \"ignore\")])\n+\n+(define_insn \"ashrdisi3_media_high\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(truncate:SI\n+\t   (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+\t\t\t(match_operand:DI 2 \"const_int_operand\" \"n\"))))]\n+  \"TARGET_SHMEDIA && INTVAL (operands[2]) >= 32\"\n+  \"shari\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+(define_insn \"ashrdisi3_media_opaque\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(unspec:SI [(match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"const_int_operand\" \"n\")]\n+\t UNSPEC_ASHIFTRT))]\n+  \"TARGET_SHMEDIA\"\n+  \"shari\t%1, %2, %0\"\n+  [(set_attr \"type\" \"arith_media\")])\n+\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; SImode logical shift right\n+\n+;; Only the single bit shift clobbers the T bit.\n+(define_expand \"lshrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t\t   (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"\"\n+{\n+  if (TARGET_SHMEDIA)\n+    {\n+      emit_insn (gen_lshrsi3_media (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  if (CONST_INT_P (operands[2])\n+      && sh_dynamicalize_shift_p (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  if ((TARGET_SH3 || TARGET_SH2A)\n+      && arith_reg_operand (operands[2], GET_MODE (operands[2])))\n+    {\n+      rtx count = copy_to_mode_reg (SImode, operands[2]);\n+      emit_insn (gen_negsi2 (count, count));\n+      emit_insn (gen_lshrsi3_d (operands[0], operands[1], count));\n+      DONE;\n+    }\n+  if (! immediate_operand (operands[2], GET_MODE (operands[2])))\n+    FAIL;\n+})\n \n (define_insn \"lshrsi3_d\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n@@ -3772,8 +3932,6 @@ label:\n   \"shld\t%2,%0\"\n   [(set_attr \"type\" \"dyn_shift\")])\n \n-;;  Only the single bit shift clobbers the T bit.\n-\n (define_insn \"lshrsi3_m\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3804,16 +3962,7 @@ label:\n {\n   gen_shifty_op (LSHIFTRT, operands);\n   DONE;\n-}\n-  [(set (attr \"length\")\n-\t(cond [(match_test \"shift_insns_rtx (insn)\")\n-\t       (const_string \"2\")\n-\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 2))\n-\t       (const_string \"4\")\n-\t       (eq (symbol_ref \"shift_insns_rtx (insn)\") (const_int 3))\n-\t       (const_string \"6\")]\n-\t      (const_string \"8\")))\n-   (set_attr \"type\" \"arith\")])\n+})\n \n (define_insn \"lshrsi3_media\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n@@ -3826,116 +3975,26 @@ label:\n   [(set_attr \"type\" \"arith_media\")\n    (set_attr \"highpart\" \"ignore\")])\n \n-(define_expand \"lshrsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t\t   (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:SI T_REG))])]\n-  \"\"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      emit_insn (gen_lshrsi3_media (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  if (CONST_INT_P (operands[2])\n-      && sh_dynamicalize_shift_p (operands[2]))\n-    operands[2] = force_reg (SImode, operands[2]);\n-  if ((TARGET_SH3 || TARGET_SH2A)\n-      && arith_reg_operand (operands[2], GET_MODE (operands[2])))\n-    {\n-      rtx count = copy_to_mode_reg (SImode, operands[2]);\n-      emit_insn (gen_negsi2 (count, count));\n-      emit_insn (gen_lshrsi3_d (operands[0], operands[1], count));\n-      DONE;\n-    }\n-  if (! immediate_operand (operands[2], GET_MODE (operands[2])))\n-    FAIL;\n-})\n-\n-;; ??? This should be a define expand.\n-\n-(define_insn \"ashldi3_k\"\n-  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n-\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t   (const_int 1)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"shll\t%R0\\;rotcl\t%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-;; Expander for DImode shift left with SImode operations.\n-\n-(define_expand \"ashldi3_std\"\n-  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n-\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n-                   (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n-  \"TARGET_SH1 && INTVAL (operands[2]) < 32\"\n-{\n-  rtx low_src = gen_lowpart (SImode, operands[1]);\n-  rtx high_src = gen_highpart (SImode, operands[1]);\n-  rtx dst = gen_reg_rtx (DImode);\n-  rtx low_dst = gen_lowpart (SImode, dst);\n-  rtx high_dst = gen_highpart (SImode, dst);\n-  rtx tmp0 = gen_reg_rtx (SImode);\n-  rtx tmp1 = gen_reg_rtx (SImode);\n-\n-  emit_insn (gen_lshrsi3 (tmp0, low_src, GEN_INT (32 - INTVAL (operands[2]))));\n-  emit_insn (gen_ashlsi3 (low_dst, low_src, operands[2]));  \n-  emit_insn (gen_ashlsi3 (tmp1, high_src, operands[2]));  \n-  emit_insn (gen_iorsi3 (high_dst, tmp0, tmp1));\n-  emit_move_insn (operands[0], dst);\n-  DONE;\n-})\n-\n-(define_insn \"ashldi3_media\"\n-  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r,r\")\n-\t\t   (match_operand:DI 2 \"shift_count_operand\" \"r,n\")))]\n-  \"TARGET_SHMEDIA\"\n-  \"@\n-\tshlld\t%1, %2, %0\n-\tshlli\t%1, %2, %0\"\n-  [(set_attr \"type\" \"arith_media\")])\n-\n-(define_insn \"*ashldisi3_media\"\n-  [(set (subreg:DI (match_operand:SI 0 \"arith_reg_operand\" \"=r\") 0)\n-\t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n-\t\t   (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n-  \"TARGET_SHMEDIA && INTVAL (operands[2]) < 32\"\n-  \"shlli.l\t%1, %2, %0\"\n-  [(set_attr \"type\" \"arith_media\")\n-   (set_attr \"highpart\" \"ignore\")])\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; DImode logical shift right\n \n-(define_expand \"ashldi3\"\n+(define_expand \"lshrdi3\"\n   [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t\t   (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n-\t\t\t      (match_operand:DI 2 \"immediate_operand\" \"\")))\n-\t      (clobber (reg:SI T_REG))])]\n+\t\t   (lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+\t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n+\t     (clobber (reg:SI T_REG))])]\n   \"\"\n {\n   if (TARGET_SHMEDIA)\n     {\n-      emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 1)\n-    {\n-      emit_insn (gen_ashldi3_k (operands[0], operands[1]));\n-      DONE;\n-    }\n-  else if (CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 32)\n-    {\n-      emit_insn (gen_ashldi3_std (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_lshrdi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  else\n+  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 1)\n     FAIL;\n })\n \n-;; ??? This should be a define expand.\n-\n+;; This should be a define_insn_and_split\n (define_insn \"lshrdi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n@@ -3967,90 +4026,8 @@ label:\n   [(set_attr \"type\" \"arith_media\")\n    (set_attr \"highpart\" \"ignore\")])\n \n-(define_expand \"lshrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t\t   (lshiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n-\t\t\t       (match_operand:DI 2 \"immediate_operand\" \"\")))\n-\t     (clobber (reg:SI T_REG))])]\n-  \"\"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      emit_insn (gen_lshrdi3_media (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 1)\n-    FAIL;\n-})\n-\n-;; ??? This should be a define expand.\n-\n-(define_insn \"ashrdi3_k\"\n-  [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (const_int 1)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"shar\t%S0\\;rotcr\t%R0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n-\n-(define_insn \"ashrdi3_media\"\n-  [(set (match_operand:DI 0 \"ext_dest_operand\" \"=r,r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r,r\")\n-\t\t     (match_operand:DI 2 \"shift_count_operand\" \"r,n\")))]\n-  \"TARGET_SHMEDIA\n-   && (arith_reg_dest (operands[0], DImode)\n-       || (CONST_INT_P (operands[2]) && INTVAL (operands[2]) >= 32))\"\n-  \"@\n-\tshard\t%1, %2, %0\n-\tshari\t%1, %2, %0\"\n-  [(set_attr \"type\" \"arith_media\")])\n-\n-(define_insn \"*ashrdisi3_media\"\n-  [(set (subreg:DI (match_operand:SI 0 \"arith_reg_operand\" \"=r\") 0)\n-\t(ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n-\t\t     (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n-  \"TARGET_SHMEDIA && INTVAL (operands[2]) < 32\"\n-  \"shari.l\t%1, %2, %0\"\n-  [(set_attr \"type\" \"arith_media\")\n-   (set_attr \"highpart\" \"ignore\")])\n-\n-(define_insn \"ashrdisi3_media_high\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(truncate:SI\n-\t   (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t(match_operand:DI 2 \"const_int_operand\" \"n\"))))]\n-  \"TARGET_SHMEDIA && INTVAL (operands[2]) >= 32\"\n-  \"shari\t%1, %2, %0\"\n-  [(set_attr \"type\" \"arith_media\")])\n-\n-(define_insn \"ashrdisi3_media_opaque\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(unspec:SI [(match_operand:DI 1 \"arith_reg_operand\" \"r\")\n-\t\t    (match_operand:DI 2 \"const_int_operand\" \"n\")]\n-\t UNSPEC_ASHIFTRT))]\n-  \"TARGET_SHMEDIA\"\n-  \"shari\t%1, %2, %0\"\n-  [(set_attr \"type\" \"arith_media\")])\n-\n-(define_expand \"ashrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t\t   (ashiftrt:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n-\t\t\t\t(match_operand:DI 2 \"immediate_operand\" \"\")))\n-\t      (clobber (reg:SI T_REG))])]\n-  \"\"\n-{\n-  if (TARGET_SHMEDIA)\n-    {\n-      emit_insn (gen_ashrdi3_media (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n-  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 1)\n-    FAIL;\n-})\n-\n-;; combined left/right shift\n+;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n+;; Combined left/right shifts\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")"}]}