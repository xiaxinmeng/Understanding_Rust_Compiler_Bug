{"sha": "d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxZTdlYWIzYTJjMzk1N2MyMjIwYWQ3MWU2MmQ5ZmM3OGNjY2I5Yg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-28T03:21:19Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-28T03:21:19Z"}, "message": "libstdc++: Fix various bugs in ranges_algo.h [PR100187, ...]\n\nThis fixes some bugs with our ranges algorithms in uncommon situations,\nsuch as when the return type of a predicate is a non-copyable class type\nthat's implicitly convertible to bool (PR100187), when a comparison\npredicate isn't invocable as an rvalue (PR100237), and when the return\ntype of a projection function is non-copyable (PR100249).\n\nThis also fixes PR100287, which reports that we're moving __first twice\nwhen constructing with it an empty subrange in ranges::partition.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/100187\n\tPR libstdc++/100237\n\tPR libstdc++/100249\n\tPR libstdc++/100287\n\t* include/bits/ranges_algo.h (__search_n_fn::operator()): Give\n\tthe __value_comp lambda an explicit bool return type.\n\t(__is_permutation_fn::operator()): Give the __proj_scan local\n\tvariable auto&& return type.  Give the __comp_scan lambda an\n\texplicit bool return type.\n\t(__remove_fn::operator()): Give the __pred lambda an explicit\n\tbool return type.\n\t(__partition_fn::operator()): Don't std::move __first twice\n\twhen returning an empty subrange.\n\t(__min_fn::operator()): Don't std::move __comp.\n\t(__max_fn::operator()): Likewise.\n\t(__minmax_fn::operator()): Likewise.", "tree": {"sha": "357e278d650907024a969ccd8da67cd82fbe4185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/357e278d650907024a969ccd8da67cd82fbe4185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b/comments", "author": null, "committer": null, "parents": [{"sha": "8f54dd61e79842eebf678571b9987bda7502f3aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f54dd61e79842eebf678571b9987bda7502f3aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f54dd61e79842eebf678571b9987bda7502f3aa"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "cda3042c11f15313f064b21fbaab191b05b89a2f", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=d91e7eab3a2c3957c2220ad71e62d9fc78cccb9b", "patch": "@@ -562,7 +562,7 @@ namespace ranges\n \tif (__count <= 0)\n \t  return {__first, __first};\n \n-\tauto __value_comp = [&] <typename _Rp> (_Rp&& __arg) {\n+\tauto __value_comp = [&] <typename _Rp> (_Rp&& __arg) -> bool {\n \t    return std::__invoke(__pred, std::forward<_Rp>(__arg), __value);\n \t};\n \tif (__count == 1)\n@@ -805,8 +805,8 @@ namespace ranges\n \n \tfor (auto __scan = __first1; __scan != __last1; ++__scan)\n \t  {\n-\t    auto __proj_scan = std::__invoke(__proj1, *__scan);\n-\t    auto __comp_scan = [&] <typename _Tp> (_Tp&& __arg) {\n+\t    auto&& __proj_scan = std::__invoke(__proj1, *__scan);\n+\t    auto __comp_scan = [&] <typename _Tp> (_Tp&& __arg) -> bool {\n \t      return std::__invoke(__pred, __proj_scan,\n \t\t\t\t   std::forward<_Tp>(__arg));\n \t    };\n@@ -1256,7 +1256,7 @@ namespace ranges\n       operator()(_Iter __first, _Sent __last,\n \t\t const _Tp& __value, _Proj __proj = {}) const\n       {\n-\tauto __pred = [&] (auto&& __arg) {\n+\tauto __pred = [&] (auto&& __arg) -> bool {\n \t  return std::forward<decltype(__arg)>(__arg) == __value;\n \t};\n \treturn ranges::remove_if(__first, __last,\n@@ -2537,11 +2537,11 @@ namespace ranges\n \telse\n \t  {\n \t    if (__first == __last)\n-\t      return {std::move(__first), std::move(__first)};\n+\t      return {__first, __first};\n \n \t    while (std::__invoke(__pred, std::__invoke(__proj, *__first)))\n \t      if (++__first == __last)\n-\t\treturn {std::move(__first), std::move(__first)};\n+\t\treturn {__first, __first};\n \n \t    auto __next = __first;\n \t    while (++__next != __last)\n@@ -3118,7 +3118,7 @@ namespace ranges\n       operator()(const _Tp& __a, const _Tp& __b,\n \t\t _Comp __comp = {}, _Proj __proj = {}) const\n       {\n-\tif (std::__invoke(std::move(__comp),\n+\tif (std::__invoke(__comp,\n \t\t\t  std::__invoke(__proj, __b),\n \t\t\t  std::__invoke(__proj, __a)))\n \t  return __b;\n@@ -3172,7 +3172,7 @@ namespace ranges\n       operator()(const _Tp& __a, const _Tp& __b,\n \t\t _Comp __comp = {}, _Proj __proj = {}) const\n       {\n-\tif (std::__invoke(std::move(__comp),\n+\tif (std::__invoke(__comp,\n \t\t\t  std::__invoke(__proj, __a),\n \t\t\t  std::__invoke(__proj, __b)))\n \t  return __b;\n@@ -3272,7 +3272,7 @@ namespace ranges\n       operator()(const _Tp& __a, const _Tp& __b,\n \t\t _Comp __comp = {}, _Proj __proj = {}) const\n       {\n-\tif (std::__invoke(std::move(__comp),\n+\tif (std::__invoke(__comp,\n \t\t\t  std::__invoke(__proj, __b),\n \t\t\t  std::__invoke(__proj, __a)))\n \t  return {__b, __a};"}]}