{"sha": "0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM3NTE2N2I2YzE1YTYwZGMyYjk3NGIyNjU0YThmZjFkYmU3MTYwYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-02-08T11:00:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-02-08T11:00:26Z"}, "message": "re PR rtl-optimization/56181 (ICE in verify_loop_structure, at cfgloop.c:1581 with -ftracer)\n\n2013-02-08  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/56181\n\t* cfgloop.h (flow_loops_find): Adjust.\n\t(bb_loop_header_p): Declare.\n\t* cfgloop.c (bb_loop_header_p): New function split out from ...\n\t(flow_loops_find): ... here.  Adjust function signature,\n\tsupport incremental loop structure update.\n\t(verify_loop_structure): Cleanup.  Verify a loop is a loop.\n\t* cfgloopmanip.c (fix_loop_structure): Move ...\n\t* loop-init.c (fix_loop_structure): ... here.\n\t(apply_loop_flags): Split out from ...\n\t(loop_optimizer_init): ... here.\n\t(fix_loop_structure): Use apply_loop_flags.  Use flow_loops_find\n\tin incremental mode, only remove dead loops here.\n\n\t* gcc.dg/torture/pr56181.c: New testcase.\n\nFrom-SVN: r195879", "tree": {"sha": "81c148d9e2f62306dffd098afe34e256d86ec31e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81c148d9e2f62306dffd098afe34e256d86ec31e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85d768f349087f3766ff84054ec7b3403c52ac7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d768f349087f3766ff84054ec7b3403c52ac7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d768f349087f3766ff84054ec7b3403c52ac7a"}], "stats": {"total": 600, "additions": 303, "deletions": 297}, "files": [{"sha": "5175c841a22e4b00e5fdb2350e407fd1f15e6a77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -1,3 +1,19 @@\n+2013-02-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/56181\n+\t* cfgloop.h (flow_loops_find): Adjust.\n+\t(bb_loop_header_p): Declare.\n+\t* cfgloop.c (bb_loop_header_p): New function split out from ...\n+\t(flow_loops_find): ... here.  Adjust function signature,\n+\tsupport incremental loop structure update.\n+\t(verify_loop_structure): Cleanup.  Verify a loop is a loop.\n+\t* cfgloopmanip.c (fix_loop_structure): Move ...\n+\t* loop-init.c (fix_loop_structure): ... here.\n+\t(apply_loop_flags): Split out from ...\n+\t(loop_optimizer_init): ... here.\n+\t(fix_loop_structure): Use apply_loop_flags.  Use flow_loops_find\n+\tin incremental mode, only remove dead loops here.\n+\n 2013-02-08  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/54222"}, {"sha": "60fc6e8c31fd2c0c100a2567f5ea74f691f69177", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 129, "deletions": 111, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -359,139 +359,156 @@ init_loops_structure (struct loops *loops, unsigned num_loops)\n   loops->tree_root = root;\n }\n \n+/* Returns whether HEADER is a loop header.  */\n+\n+bool\n+bb_loop_header_p (basic_block header)\n+{\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* If we have an abnormal predecessor, do not consider the\n+     loop (not worth the problems).  */\n+  if (bb_has_abnormal_pred (header))\n+    return false;\n+\n+  /* Look for back edges where a predecessor is dominated\n+     by this block.  A natural loop has a single entry\n+     node (header) that dominates all the nodes in the\n+     loop.  It also has single back edge to the header\n+     from a latch node.  */\n+  FOR_EACH_EDGE (e, ei, header->preds)\n+    {\n+      basic_block latch = e->src;\n+      if (latch != ENTRY_BLOCK_PTR\n+\t  && dominated_by_p (CDI_DOMINATORS, latch, header))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Find all the natural loops in the function and save in LOOPS structure and\n    recalculate loop_father information in basic block structures.\n-   Return the number of natural loops found.  */\n+   If LOOPS is non-NULL then the loop structures for already recorded loops\n+   will be re-used and their number will not change.  We assume that no\n+   stale loops exist in LOOPS.\n+   When LOOPS is NULL it is allocated and re-built from scratch.\n+   Return the built LOOPS structure.  */\n \n-int\n+struct loops *\n flow_loops_find (struct loops *loops)\n {\n-  int b;\n-  int num_loops;\n-  edge e;\n-  sbitmap headers;\n-  int *dfs_order;\n+  bool from_scratch = (loops == NULL);\n   int *rc_order;\n-  basic_block header;\n-  basic_block bb;\n+  int b;\n+  unsigned i;\n+  vec<loop_p> larray;\n \n   /* Ensure that the dominators are computed.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Taking care of this degenerate case makes the rest of\n-     this code simpler.  */\n-  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+  if (!loops)\n     {\n+      loops = ggc_alloc_cleared_loops ();\n       init_loops_structure (loops, 1);\n-      return 1;\n     }\n \n-  dfs_order = NULL;\n-  rc_order = NULL;\n+  /* Ensure that loop exits were released.  */\n+  gcc_assert (loops->exits == NULL);\n \n-  /* Count the number of loop headers.  This should be the\n-     same as the number of natural loops.  */\n-  headers = sbitmap_alloc (last_basic_block);\n-  bitmap_clear (headers);\n+  /* Taking care of this degenerate case makes the rest of\n+     this code simpler.  */\n+  if (n_basic_blocks == NUM_FIXED_BLOCKS)\n+    return loops;\n \n-  num_loops = 0;\n-  FOR_EACH_BB (header)\n-    {\n-      edge_iterator ei;\n+  /* The root loop node contains all basic-blocks.  */\n+  loops->tree_root->num_nodes = n_basic_blocks;\n \n-      /* If we have an abnormal predecessor, do not consider the\n-\t loop (not worth the problems).  */\n-      if (bb_has_abnormal_pred (header))\n-\tcontinue;\n+  /* Compute depth first search order of the CFG so that outer\n+     natural loops will be found before inner natural loops.  */\n+  rc_order = XNEWVEC (int, n_basic_blocks);\n+  pre_and_rev_post_order_compute (NULL, rc_order, false);\n \n-      FOR_EACH_EDGE (e, ei, header->preds)\n+  /* Gather all loop headers in reverse completion order and allocate\n+     loop structures for loops that are not already present.  */\n+  larray.create (loops->larray->length());\n+  for (b = 0; b < n_basic_blocks - NUM_FIXED_BLOCKS; b++)\n+    {\n+      basic_block header = BASIC_BLOCK (rc_order[b]);\n+      if (bb_loop_header_p (header))\n \t{\n-\t  basic_block latch = e->src;\n-\n-\t  gcc_assert (!(e->flags & EDGE_ABNORMAL));\n+\t  struct loop *loop;\n \n-\t  /* Look for back edges where a predecessor is dominated\n-\t     by this block.  A natural loop has a single entry\n-\t     node (header) that dominates all the nodes in the\n-\t     loop.  It also has single back edge to the header\n-\t     from a latch node.  */\n-\t  if (latch != ENTRY_BLOCK_PTR\n-\t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n+\t  /* The current active loop tree has valid loop-fathers for\n+\t     header blocks.  */\n+\t  if (!from_scratch\n+\t      && header->loop_father->header == header)\n \t    {\n-\t      /* Shared headers should be eliminated by now.  */\n-\t      bitmap_set_bit (headers, header->index);\n-\t      num_loops++;\n+\t      loop = header->loop_father;\n+\t      /* If we found an existing loop remove it from the\n+\t\t loop tree.  It is going to be inserted again\n+\t\t below.  */\n+\t      flow_loop_tree_node_remove (loop);\n \t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise allocate a new loop structure for the loop.  */\n+\t      loop = alloc_loop ();\n+\t      /* ???  We could re-use unused loop slots here.  */\n+\t      loop->num = loops->larray->length ();\n+\t      vec_safe_push (loops->larray, loop);\n+\t      loop->header = header;\n+\n+\t      if (!from_scratch\n+\t\t  && dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"flow_loops_find: discovered new \"\n+\t\t\t \"loop %d with header %d\\n\",\n+\t\t\t loop->num, header->index);\n+\t    }\n+\t  larray.safe_push (loop);\n \t}\n-    }\n \n-  /* Allocate loop structures.  */\n-  init_loops_structure (loops, num_loops + 1);\n+      /* Make blocks part of the loop root node at start.  */\n+      header->loop_father = loops->tree_root;\n+    }\n \n-  /* Find and record information about all the natural loops\n-     in the CFG.  */\n-  FOR_EACH_BB (bb)\n-    bb->loop_father = loops->tree_root;\n+  free (rc_order);\n \n-  if (num_loops)\n+  /* Now iterate over the loops found, insert them into the loop tree\n+     and assign basic-block ownership.  */\n+  for (i = 0; i < larray.length (); ++i)\n     {\n-      /* Compute depth first search order of the CFG so that outer\n-\t natural loops will be found before inner natural loops.  */\n-      dfs_order = XNEWVEC (int, n_basic_blocks);\n-      rc_order = XNEWVEC (int, n_basic_blocks);\n-      pre_and_rev_post_order_compute (dfs_order, rc_order, false);\n+      struct loop *loop = larray[i];\n+      basic_block header = loop->header;\n+      edge_iterator ei;\n+      edge e;\n \n-      num_loops = 1;\n+      flow_loop_tree_node_add (header->loop_father, loop);\n+      loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n \n-      for (b = 0; b < n_basic_blocks - NUM_FIXED_BLOCKS; b++)\n+      /* Look for the latch for this header block, if it has just a\n+\t single one.  */\n+      FOR_EACH_EDGE (e, ei, header->preds)\n \t{\n-\t  struct loop *loop;\n-\t  edge_iterator ei;\n-\n-\t  /* Search the nodes of the CFG in reverse completion order\n-\t     so that we can find outer loops first.  */\n-\t  if (!bitmap_bit_p (headers, rc_order[b]))\n-\t    continue;\n-\n-\t  header = BASIC_BLOCK (rc_order[b]);\n-\n-\t  loop = alloc_loop ();\n-\t  loops->larray->quick_push (loop);\n-\n-\t  loop->header = header;\n-\t  loop->num = num_loops;\n-\t  num_loops++;\n-\n-\t  flow_loop_tree_node_add (header->loop_father, loop);\n-\t  loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n+\t  basic_block latch = e->src;\n \n-\t  /* Look for the latch for this header block, if it has just a\n-\t     single one.  */\n-\t  FOR_EACH_EDGE (e, ei, header->preds)\n+\t  if (flow_bb_inside_loop_p (loop, latch))\n \t    {\n-\t      basic_block latch = e->src;\n-\n-\t      if (flow_bb_inside_loop_p (loop, latch))\n+\t      if (loop->latch != NULL)\n \t\t{\n-\t\t  if (loop->latch != NULL)\n-\t\t    {\n-\t\t      /* More than one latch edge.  */\n-\t\t      loop->latch = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  loop->latch = latch;\n+\t\t  /* More than one latch edge.  */\n+\t\t  loop->latch = NULL;\n+\t\t  break;\n \t\t}\n+\t      loop->latch = latch;\n \t    }\n \t}\n-\n-      free (dfs_order);\n-      free (rc_order);\n     }\n \n-  sbitmap_free (headers);\n+  larray.release();\n \n-  loops->exits = NULL;\n-  return loops->larray->length ();\n+  return loops;\n }\n \n /* Ratio of frequencies of edges so that one of more latch edges is\n@@ -1300,15 +1317,15 @@ verify_loop_structure (void)\n {\n   unsigned *sizes, i, j;\n   sbitmap irreds;\n-  basic_block *bbs, bb;\n+  basic_block bb;\n   struct loop *loop;\n   int err = 0;\n   edge e;\n   unsigned num = number_of_loops ();\n   loop_iterator li;\n   struct loop_exit *exit, *mexit;\n   bool dom_available = dom_info_available_p (CDI_DOMINATORS);\n-  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sbitmap visited;\n \n   /* We need up-to-date dominators, compute or verify them.  */\n   if (!dom_available)\n@@ -1337,28 +1354,23 @@ verify_loop_structure (void)\n     }\n \n   /* Check get_loop_body.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      bbs = get_loop_body (loop);\n-\n-      for (j = 0; j < loop->num_nodes; j++)\n-\tif (!flow_bb_inside_loop_p (loop, bbs[j]))\n-\t  {\n-\t    error (\"bb %d does not belong to loop %d\",\n-\t\t   bbs[j]->index, loop->num);\n-\t    err = 1;\n-\t  }\n-      free (bbs);\n-    }\n+  visited = sbitmap_alloc (last_basic_block);\n   bitmap_clear (visited);\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n-      bbs = get_loop_body (loop);\n+      basic_block *bbs = get_loop_body (loop);\n \n       for (j = 0; j < loop->num_nodes; j++)\n \t{\n \t  bb = bbs[j];\n \n+\t  if (!flow_bb_inside_loop_p (loop, bb))\n+\t    {\n+\t      error (\"bb %d does not belong to loop %d\",\n+\t\t     bb->index, loop->num);\n+\t      err = 1;\n+\t    }\n+\n \t  /* Ignore this block if it is in an inner loop.  */\n \t  if (bitmap_bit_p (visited, bb->index))\n \t    continue;\n@@ -1371,14 +1383,21 @@ verify_loop_structure (void)\n \t      err = 1;\n \t    }\n \t}\n+\n       free (bbs);\n     }\n+  sbitmap_free (visited);\n \n   /* Check headers and latches.  */\n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       i = loop->num;\n \n+      if (!bb_loop_header_p (loop->header))\n+\t{\n+\t  error (\"loop %d%'s header is not a loop header\", i);\n+\t  err = 1;\n+\t}\n       if (loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS)\n \t  && EDGE_COUNT (loop->header->preds) != 2)\n \t{\n@@ -1585,7 +1604,6 @@ verify_loop_structure (void)\n \n   gcc_assert (!err);\n \n-  sbitmap_free (visited);\n   free (sizes);\n   if (!dom_available)\n     free_dominance_info (CDI_DOMINATORS);"}, {"sha": "7506ac5758b4d1f9d71cafaf592d101f2517f148", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -205,7 +205,8 @@ struct GTY (()) loops {\n };\n \n /* Loop recognition.  */\n-extern int flow_loops_find (struct loops *);\n+bool bb_loop_header_p (basic_block);\n+extern struct loops *flow_loops_find (struct loops *);\n extern void disambiguate_loops_with_multiple_latches (void);\n extern void flow_loops_free (struct loops *);\n extern void flow_loops_dump (FILE *,"}, {"sha": "3e53aa0dddf8705f9545ca6553e1da6cfc96dbc8", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -1760,159 +1760,3 @@ loop_version (struct loop *loop,\n \n   return nloop;\n }\n-\n-/* The structure of loops might have changed.  Some loops might get removed\n-   (and their headers and latches were set to NULL), loop exists might get\n-   removed (thus the loop nesting may be wrong), and some blocks and edges\n-   were changed (so the information about bb --> loop mapping does not have\n-   to be correct).  But still for the remaining loops the header dominates\n-   the latch, and loops did not get new subloops (new loops might possibly\n-   get created, but we are not interested in them).  Fix up the mess.\n-\n-   If CHANGED_BBS is not NULL, basic blocks whose loop has changed are\n-   marked in it.  */\n-\n-void\n-fix_loop_structure (bitmap changed_bbs)\n-{\n-  basic_block bb;\n-  struct loop *loop, *ploop;\n-  loop_iterator li;\n-  bool record_exits = false;\n-  struct loop **superloop = XNEWVEC (struct loop *, number_of_loops ());\n-\n-  /* We need exact and fast dominance info to be available.  */\n-  gcc_assert (dom_info_state (CDI_DOMINATORS) == DOM_OK);\n-\n-  /* Remove the old bb -> loop mapping.  Remember the depth of the blocks in\n-     the loop hierarchy, so that we can recognize blocks whose loop nesting\n-     relationship has changed.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      if (changed_bbs)\n-\tbb->aux = (void *) (size_t) loop_depth (bb->loop_father);\n-      bb->loop_father = current_loops->tree_root;\n-    }\n-\n-  if (loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS))\n-    {\n-      release_recorded_exits ();\n-      record_exits = true;\n-    }\n-\n-  /* First re-compute loop latches.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      edge_iterator ei;\n-      edge e, first_latch = NULL, latch = NULL;\n-\n-      if (!loop->header)\n-\tcontinue;\n-\n-      FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\tif (dominated_by_p (CDI_DOMINATORS, e->src, loop->header))\n-\t  {\n-\t    if (!first_latch)\n-\t      first_latch = latch = e;\n-\t    else\n-\t      {\n-\t\tlatch = NULL;\n-\t\tbreak;\n-\t      }\n-\t  }\n-      /* If there was no latch, schedule the loop for removal.  */\n-      if (!first_latch)\n-\tloop->header = NULL;\n-      /* If there was a single latch, record it.  */\n-      else if (latch)\n-\tloop->latch = latch->src;\n-      /* Otherwise there are multiple latches which are eventually\n-         disambiguated below.  */\n-      else\n-\tloop->latch = NULL;\n-    }\n-\n-  /* Remove the dead loops from structures.  We start from the innermost\n-     loops, so that when we remove the loops, we know that the loops inside\n-     are preserved, and do not waste time relinking loops that will be\n-     removed later.  */\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n-    {\n-      if (loop->header)\n-\tcontinue;\n-\n-      while (loop->inner)\n-\t{\n-\t  ploop = loop->inner;\n-\t  flow_loop_tree_node_remove (ploop);\n-\t  flow_loop_tree_node_add (loop_outer (loop), ploop);\n-\t}\n-\n-      /* Remove the loop and free its data.  */\n-      delete_loop (loop);\n-    }\n-\n-  /* Rescan the bodies of loops, starting from the outermost ones.  We assume\n-     that no optimization interchanges the order of the loops, i.e., it cannot\n-     happen that L1 was superloop of L2 before and it is subloop of L2 now\n-     (without explicitly updating loop information).  At the same time, we also\n-     determine the new loop structure.  */\n-  current_loops->tree_root->num_nodes = n_basic_blocks;\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      superloop[loop->num] = loop->header->loop_father;\n-      loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n-    }\n-\n-  /* Now fix the loop nesting.  */\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      ploop = superloop[loop->num];\n-      if (ploop != loop_outer (loop))\n-\t{\n-\t  flow_loop_tree_node_remove (loop);\n-\t  flow_loop_tree_node_add (ploop, loop);\n-\t}\n-    }\n-  free (superloop);\n-\n-  /* Mark the blocks whose loop has changed.  */\n-  if (changed_bbs)\n-    {\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  if ((void *) (size_t) loop_depth (bb->loop_father) != bb->aux)\n-\t    bitmap_set_bit (changed_bbs, bb->index);\n-\n-    \t  bb->aux = NULL;\n-\t}\n-    }\n-\n-  if (!loops_state_satisfies_p (LOOPS_MAY_HAVE_MULTIPLE_LATCHES))\n-    disambiguate_loops_with_multiple_latches ();\n-\n-  if (loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))\n-    {\n-      int cp_flags = CP_SIMPLE_PREHEADERS;\n-\n-      if (loops_state_satisfies_p (LOOPS_HAVE_FALLTHRU_PREHEADERS))\n-\tcp_flags |= CP_FALLTHRU_PREHEADERS;\n-\n-      create_preheaders (cp_flags);\n-    }\n-\n-  if (loops_state_satisfies_p (LOOPS_HAVE_SIMPLE_LATCHES))\n-    force_single_succ_latches ();\n-\n-  if (loops_state_satisfies_p (LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS))\n-    mark_irreducible_loops ();\n-\n-  if (record_exits)\n-    record_loop_exits ();\n-\n-  loops_state_clear (LOOPS_NEED_FIXUP);\n-\n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n-}"}, {"sha": "d64c110c1b5dc1d6ae35b756df871cbbda58b668", "filename": "gcc/loop-init.c", "status": "modified", "additions": 126, "deletions": 29, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -32,37 +32,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n \n \f\n-/* Initialize loop structures.  This is used by the tree and RTL loop\n-   optimizers.  FLAGS specify what properties to compute and/or ensure for\n-   loops.  */\n+/* Apply FLAGS to the loop state.  */\n \n-void\n-loop_optimizer_init (unsigned flags)\n+static void\n+apply_loop_flags (unsigned flags)\n {\n-  timevar_push (TV_LOOP_INIT);\n-  if (!current_loops)\n-    {\n-      struct loops *loops = ggc_alloc_cleared_loops ();\n-\n-      gcc_assert (!(cfun->curr_properties & PROP_loops));\n-\n-      /* Find the loops.  */\n-\n-      flow_loops_find (loops);\n-      current_loops = loops;\n-    }\n-  else\n-    {\n-      gcc_assert (cfun->curr_properties & PROP_loops);\n-\n-      /* Ensure that the dominators are computed, like flow_loops_find does.  */\n-      calculate_dominance_info (CDI_DOMINATORS);\n-\n-#ifdef ENABLE_CHECKING\n-      verify_loop_structure ();\n-#endif\n-    }\n-\n   if (flags & LOOPS_MAY_HAVE_MULTIPLE_LATCHES)\n     {\n       /* If the loops may have multiple latches, we cannot canonicalize\n@@ -97,6 +71,38 @@ loop_optimizer_init (unsigned flags)\n \n   if (flags & LOOPS_HAVE_RECORDED_EXITS)\n     record_loop_exits ();\n+}\n+\n+/* Initialize loop structures.  This is used by the tree and RTL loop\n+   optimizers.  FLAGS specify what properties to compute and/or ensure for\n+   loops.  */\n+\n+void\n+loop_optimizer_init (unsigned flags)\n+{\n+  timevar_push (TV_LOOP_INIT);\n+\n+  if (!current_loops)\n+    {\n+      gcc_assert (!(cfun->curr_properties & PROP_loops));\n+\n+      /* Find the loops.  */\n+      current_loops = flow_loops_find (NULL);\n+    }\n+  else\n+    {\n+      gcc_assert (cfun->curr_properties & PROP_loops);\n+\n+      /* Ensure that the dominators are computed, like flow_loops_find does.  */\n+      calculate_dominance_info (CDI_DOMINATORS);\n+\n+#ifdef ENABLE_CHECKING\n+      verify_loop_structure ();\n+#endif\n+    }\n+\n+  /* Apply flags to loops.  */\n+  apply_loop_flags (flags);\n \n   /* Dump loops.  */\n   flow_loops_dump (dump_file, NULL, 1);\n@@ -157,6 +163,97 @@ loop_optimizer_finalize (void)\n   timevar_pop (TV_LOOP_FINI);\n }\n \n+/* The structure of loops might have changed.  Some loops might get removed\n+   (and their headers and latches were set to NULL), loop exists might get\n+   removed (thus the loop nesting may be wrong), and some blocks and edges\n+   were changed (so the information about bb --> loop mapping does not have\n+   to be correct).  But still for the remaining loops the header dominates\n+   the latch, and loops did not get new subloops (new loops might possibly\n+   get created, but we are not interested in them).  Fix up the mess.\n+\n+   If CHANGED_BBS is not NULL, basic blocks whose loop has changed are\n+   marked in it.  */\n+\n+void\n+fix_loop_structure (bitmap changed_bbs)\n+{\n+  basic_block bb;\n+  int record_exits = 0;\n+  loop_iterator li;\n+  struct loop *loop;\n+\n+  timevar_push (TV_LOOP_INIT);\n+\n+  /* We need exact and fast dominance info to be available.  */\n+  gcc_assert (dom_info_state (CDI_DOMINATORS) == DOM_OK);\n+\n+  if (loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS))\n+    {\n+      release_recorded_exits ();\n+      record_exits = LOOPS_HAVE_RECORDED_EXITS;\n+    }\n+\n+  /* Remember the depth of the blocks in the loop hierarchy, so that we can\n+     recognize blocks whose loop nesting relationship has changed.  */\n+  if (changed_bbs)\n+    FOR_EACH_BB (bb)\n+      bb->aux = (void *) (size_t) loop_depth (bb->loop_father);\n+\n+  /* Remove the dead loops from structures.  We start from the innermost\n+     loops, so that when we remove the loops, we know that the loops inside\n+     are preserved, and do not waste time relinking loops that will be\n+     removed later.  */\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+    {\n+      /* Detect the case that the loop is no longer present even though\n+         it wasn't marked for removal.\n+\t ???  If we do that we can get away with not marking loops for\n+\t removal at all.  And possibly avoid some spurious removals.  */\n+      if (loop->header\n+\t  && bb_loop_header_p (loop->header))\n+\tcontinue;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"fix_loop_structure: removing loop %d\\n\",\n+\t\t loop->num);\n+\n+      while (loop->inner)\n+\t{\n+\t  struct loop *ploop = loop->inner;\n+\t  flow_loop_tree_node_remove (ploop);\n+\t  flow_loop_tree_node_add (loop_outer (loop), ploop);\n+\t}\n+\n+      /* Remove the loop and free its data.  */\n+      delete_loop (loop);\n+    }\n+\n+  /* Re-compute loop structure in-place.  */\n+  flow_loops_find (current_loops);\n+\n+  /* Mark the blocks whose loop has changed.  */\n+  if (changed_bbs)\n+    {\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  if ((void *) (size_t) loop_depth (bb->loop_father) != bb->aux)\n+\t    bitmap_set_bit (changed_bbs, bb->index);\n+\n+    \t  bb->aux = NULL;\n+\t}\n+    }\n+\n+  loops_state_clear (LOOPS_NEED_FIXUP);\n+\n+  /* Apply flags to loops.  */\n+  apply_loop_flags (current_loops->state | record_exits);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+#endif\n+\n+  timevar_pop (TV_LOOP_INIT);\n+}\n \f\n /* Gate for the RTL loop superpass.  The actual passes are subpasses.\n    See passes.c for more on that.  */"}, {"sha": "2dcd876f9367c02440e3de8d7edb8bb2cae76765", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -1,3 +1,8 @@\n+2013-02-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/56181\n+\t* gcc.dg/torture/pr56181.c: New testcase.\n+\n 2013-02-08  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/54222"}, {"sha": "c382b29c43bd713ffabc7d60805b26ea70264a79", "filename": "gcc/testsuite/gcc.dg/torture/pr56181.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56181.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0375167b6c15a60dc2b974b2654a8ff1dbe7160a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56181.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56181.c?ref=0375167b6c15a60dc2b974b2654a8ff1dbe7160a", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\r\n+/* { dg-options \"-ftracer\" } */\r\n+\r\n+int a, b;\r\n+\r\n+void f(void)\r\n+{\r\n+  if(a++)\r\n+    {\r\n+      for(a = 0; a < 1;)\r\n+\t{\r\n+\t  for(b = 0; b < 1; b++)\r\n+\t    {\r\n+\t      while(a++ < 0);\r\n+lbl:\r\n+\t      ;\r\n+\t    }\r\n+\r\n+\t  if(a)\r\n+\t    goto lbl;\r\n+\t}\r\n+\r\n+      goto lbl;\r\n+    }\r\n+}\r"}]}