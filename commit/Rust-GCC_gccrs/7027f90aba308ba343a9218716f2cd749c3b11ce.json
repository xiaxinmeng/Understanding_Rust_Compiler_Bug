{"sha": "7027f90aba308ba343a9218716f2cd749c3b11ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAyN2Y5MGFiYTMwOGJhMzQzYTkyMTg3MTZmMmNkNzQ5YzNiMTFjZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-04T20:01:59Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-04T20:01:59Z"}, "message": "(combine_givs): Use new macro GIV_SORT_CRITERION.\n\nNew variable giv_array.  Loop over giv_array instead of following\nnext_iv links.\n(giv_sort): New function.\nK\n\nFrom-SVN: r11668", "tree": {"sha": "c125ffe2bd3e74215bfd845d127b5b55c82adce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c125ffe2bd3e74215bfd845d127b5b55c82adce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7027f90aba308ba343a9218716f2cd749c3b11ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7027f90aba308ba343a9218716f2cd749c3b11ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7027f90aba308ba343a9218716f2cd749c3b11ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7027f90aba308ba343a9218716f2cd749c3b11ce/comments", "author": null, "committer": null, "parents": [{"sha": "bdc49177fdcd9df5063329dcfb5a617c2233ecab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdc49177fdcd9df5063329dcfb5a617c2233ecab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdc49177fdcd9df5063329dcfb5a617c2233ecab"}], "stats": {"total": 100, "additions": 71, "deletions": 29}, "files": [{"sha": "efde04034b8715ce500132ff661c017870726aba", "filename": "gcc/loop.c", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7027f90aba308ba343a9218716f2cd749c3b11ce/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7027f90aba308ba343a9218716f2cd749c3b11ce/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=7027f90aba308ba343a9218716f2cd749c3b11ce", "patch": "@@ -5580,6 +5580,20 @@ combine_givs_p (g1, g2)\n   return 0;\n }\n \f\n+#ifdef GIV_SORT_CRITERION\n+/* Compare two givs and sort the most desirable one for combinations first.\n+   This is used only in one qsort call below.  */\n+\n+static int\n+giv_sort (x, y)\n+     struct induction **x, **y;\n+{\n+  GIV_SORT_CRITERION (*x, *y);\n+\n+  return 0;\n+}\n+#endif\n+\n /* Check all pairs of givs for iv_class BL and see if any can be combined with\n    any other.  If so, point SAME to the giv combined with and set NEW_REG to\n    be an expression (in terms of the other giv's DEST_REG) equivalent to the\n@@ -5589,39 +5603,67 @@ static void\n combine_givs (bl)\n      struct iv_class *bl;\n {\n-  struct induction *g1, *g2;\n-  int pass;\n+  struct induction *g1, *g2, **giv_array, *temp_iv;\n+  int i, j, giv_count, pass;\n \n+  /* Count givs, because bl->giv_count is incorrect here.  */\n+  giv_count = 0;\n   for (g1 = bl->giv; g1; g1 = g1->next_iv)\n-    for (pass = 0; pass <= 1; pass++)\n-      for (g2 = bl->giv; g2; g2 = g2->next_iv)\n-\tif (g1 != g2\n-\t    /* First try to combine with replaceable givs, then all givs. */\n-\t    && (g1->replaceable || pass == 1)\n-\t    /* If either has already been combined or is to be ignored, can't\n-\t       combine.  */\n-\t    && ! g1->ignore && ! g2->ignore && ! g1->same && ! g2->same\n-\t    /* If something has been based on G2, G2 cannot itself be based\n-\t       on something else.  */\n-\t    && ! g2->combined_with\n-\t    && combine_givs_p (g1, g2))\n+    giv_count++;\n+\n+  giv_array\n+    = (struct induction **) alloca (giv_count * sizeof (struct induction *));\n+  i = 0;\n+  for (g1 = bl->giv; g1; g1 = g1->next_iv)\n+    giv_array[i++] = g1;\n+\n+#ifdef GIV_SORT_CRITERION\n+  /* Sort the givs if GIV_SORT_CRITERION is defined.\n+     This is usually defined for processors which lack\n+     negative register offsets so more givs may be combined.  */\n+\n+  if (loop_dump_stream)\n+    fprintf (loop_dump_stream, \"%d givs counted, sorting...\\n\", giv_count);\n+\n+  qsort (giv_array, giv_count, sizeof (struct induction *), giv_sort);\n+#endif\n+\n+  for (i = 0; i < giv_count; i++)\n+    {\n+      g1 = giv_array[i];\n+      for (pass = 0; pass <= 1; pass++)\n+\tfor (j = 0; j < giv_count; j++)\n \t  {\n-\t    /* g2->new_reg set by `combine_givs_p'  */\n-\t    g2->same = g1;\n-\t    g1->combined_with = 1;\n-\t    g1->benefit += g2->benefit;\n-\t    /* ??? The new final_[bg]iv_value code does a much better job\n-\t       of finding replaceable giv's, and hence this code may no\n-\t       longer be necessary.  */\n-\t    if (! g2->replaceable && REG_USERVAR_P (g2->dest_reg))\n-\t      g1->benefit -= copy_cost;\n-\t    g1->lifetime += g2->lifetime;\n-\t    g1->times_used += g2->times_used;\n-\n-\t    if (loop_dump_stream)\n-\t      fprintf (loop_dump_stream, \"giv at %d combined with giv at %d\\n\",\n-\t\t       INSN_UID (g2->insn), INSN_UID (g1->insn));\n+\t    g2 = giv_array[j];\n+\t    if (g1 != g2\n+\t\t/* First try to combine with replaceable givs, then all givs. */\n+\t\t&& (g1->replaceable || pass == 1)\n+\t\t/* If either has already been combined or is to be ignored, can't\n+\t\t   combine.  */\n+\t\t&& ! g1->ignore && ! g2->ignore && ! g1->same && ! g2->same\n+\t\t/* If something has been based on G2, G2 cannot itself be based\n+\t\t   on something else.  */\n+\t\t&& ! g2->combined_with\n+\t\t&& combine_givs_p (g1, g2))\n+\t      {\n+\t\t/* g2->new_reg set by `combine_givs_p'  */\n+\t\tg2->same = g1;\n+\t\tg1->combined_with = 1;\n+\t\tg1->benefit += g2->benefit;\n+\t\t/* ??? The new final_[bg]iv_value code does a much better job\n+\t\t   of finding replaceable giv's, and hence this code may no\n+\t\t   longer be necessary.  */\n+\t\tif (! g2->replaceable && REG_USERVAR_P (g2->dest_reg))\n+\t\t  g1->benefit -= copy_cost;\n+\t\tg1->lifetime += g2->lifetime;\n+\t\tg1->times_used += g2->times_used;\n+\t\t\n+\t\tif (loop_dump_stream)\n+\t\t  fprintf (loop_dump_stream, \"giv at %d combined with giv at %d\\n\",\n+\t\t\t   INSN_UID (g2->insn), INSN_UID (g1->insn));\n+\t      }\n \t  }\n+    }\n }\n \f\n /* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */"}]}