{"sha": "fa10beec52789c84fe0c22a16fe73c895b275b1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmExMGJlZWM1Mjc4OWM4NGZlMGMyMmExNmZlNzNjODk1YjI3NWIxZQ==", "commit": {"author": {"name": "Ralf Wildenhues", "email": "Ralf.Wildenhues@gmx.de", "date": "2008-06-06T05:42:00Z"}, "committer": {"name": "Ralf Wildenhues", "email": "rwild@gcc.gnu.org", "date": "2008-06-06T05:42:00Z"}, "message": "cgraph.c: Fix typos in comments.\n\ngcc/\n\t* cgraph.c: Fix typos in comments.\n\t(cgraph_availability_names): Fix string typo.\n\t* fold-const.c: Fix typos in comments.\n\t(fold_binary): Fix typo in warning.\n\t* genautomata.c: Fix typos in comments.\n\t(check_presence_pattern_sets): Fix typo in local variable.\n\t(output_description): Fix typo in output.\n\t* ggc-zone.c (ggc_pch_finish): Fix typo in error message.\n\t* hwint.h: Likewise.\n\t* matrix-reorg.c (check_allocation_function): Likewise.\n\t* omega.c (smooth_weird_equations): Likewise.\n\t* auto-inc-dec.c: Fix typos in comments.\n\t* bb-reorder.c: Likewise.\n\t* builtins.c: Likewise.\n\t* c-common.c: Likewise.\n\t* c-cppbuiltin.c: Likewise.\n\t* c-parser.c: Likewise.\n\t* c-pretty-print.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* cfghooks.c: Likewise.\n\t* cfglayout.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* coverage.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* df-byte-scan.c: Likewise.\n\t* df-core.c: Likewise.\n\t* df-problems.c: Likewise.\n\t* df-scan.c: Likewise.\n\t* dfp.c: Likewise.\n\t* dominance.c: Likewise.\n\t* domwalk.c: Likewise.\n\t* dse.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* et-forest.c: Likewise.\n\t* function.c: Likewise.\n\t* function.h: Likewise.\n\t* gcc.c: Likewise.\n\t* gcov-io.c: Likewise.\n\t* gcov.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattrtab.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* gimplify.c: Likewise.\n\t* gthr-lynx.h: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* ipa-prop.h: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* ipa-struct-reorg.c: Likewise.\n\t* ipa-struct-reorg.h: Likewise.\n\t* ipa-type-escape.c: Likewise.\n\t* ipa.c: Likewise.\n\t* loop-doloop.c: Likewise.\n\t* mips-tfile.c: Likewise.\n\t* mkmap-flat.awk: Likewise.\n\t* mkmap-symver.awk: Likewise.\n\t* modulo-sched.c: Likewise.\n\t* omp-low.c: Likewise.\n\t* optabs.c: Likewise.\n\t* optabs.h: Likewise.\n\t* opts.c: Likewise.\n\t* passes.c: Likewise.\n\t* postreload-gcse.c: Likewise.\n\t* postreload.c: Likewise.\n\t* predict.c: Likewise.\n\t* pretty-print.h: Likewise.\n\t* profile.c: Likewise.\n\t* protoize.c: Likewise.\n\t* ra-conflict.c: Likewise.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regs.h: Likewise.\n\t* reload.c: Likewise.\n\t* rtl-error.c: Likewise.\n\t* rtlanal.c: Likewise.\n\t* scan.h: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* see.c: Likewise.\n\t* stmt.c: Likewise.\n\t* target.h: Likewise.\n\t* tree-dfa.c: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-flow-inline.h: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-nested.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-pass.h: Likewise.\n\t* tree-pretty-print.c: Likewise.\n\t* tree-profile.c: Likewise.\n\t* tree-scalar-evolution.c: Likewise.\n\t* tree-sra.c: Likewise.\n\t* tree-ssa-alias-warnings.c: Likewise.\n\t* tree-ssa-ccp.c: Likewise.\n\t* tree-ssa-coalesce.c: Likewise.\n\t* tree-ssa-dom.c: Likewise.\n\t* tree-ssa-dse.c: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-ssa-live.h: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-ter.c: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-vect-analyze.c: Likewise.\n\t* tree-vect-transform.c: Likewise.\n\t* tree-vectorizer.c: Likewise.\n\t* tree-vn.c: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* tree.c: Likewise.\n\t* tree.def: Likewise.\n\t* tree.h: Likewise.\n\t* unwind-dw2-fde.c: Likewise.\n\t* unwind.inc: Likewise.\n\t* value-prof.c: Likewise.\n\t* vmsdbgout.c: Likewise.\n\nFrom-SVN: r136425", "tree": {"sha": "51c1eeb863a9849991eb66b073c4b3c570d21d13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51c1eeb863a9849991eb66b073c4b3c570d21d13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa10beec52789c84fe0c22a16fe73c895b275b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa10beec52789c84fe0c22a16fe73c895b275b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa10beec52789c84fe0c22a16fe73c895b275b1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa10beec52789c84fe0c22a16fe73c895b275b1e/comments", "author": null, "committer": null, "parents": [{"sha": "6bf2f78acceebc97378cd1a7106c1ae3f41c75de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf2f78acceebc97378cd1a7106c1ae3f41c75de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bf2f78acceebc97378cd1a7106c1ae3f41c75de"}], "stats": {"total": 845, "additions": 503, "deletions": 342}, "files": [{"sha": "2771b9f862efedcbb001302fb31d4f839096e7f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,3 +1,134 @@\n+2008-06-06  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n+\n+\t* cgraph.c: Fix typos in comments.\n+\t(cgraph_availability_names): Fix string typo.\n+\t* fold-const.c: Fix typos in comments.\n+\t(fold_binary): Fix typo in warning.\n+\t* genautomata.c: Fix typos in comments.\n+\t(check_presence_pattern_sets): Fix typo in local variable.\n+\t(output_description): Fix typo in output.\n+\t* ggc-zone.c (ggc_pch_finish): Fix typo in error message.\n+\t* hwint.h: Likewise.\n+\t* matrix-reorg.c (check_allocation_function): Likewise.\n+\t* omega.c (smooth_weird_equations): Likewise.\n+\t* auto-inc-dec.c: Fix typos in comments.\n+\t* bb-reorder.c: Likewise.\n+\t* builtins.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-cppbuiltin.c: Likewise.\n+\t* c-parser.c: Likewise.\n+\t* c-pretty-print.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* cfghooks.c: Likewise.\n+\t* cfglayout.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* coverage.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* df-byte-scan.c: Likewise.\n+\t* df-core.c: Likewise.\n+\t* df-problems.c: Likewise.\n+\t* df-scan.c: Likewise.\n+\t* dfp.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* domwalk.c: Likewise.\n+\t* dse.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* et-forest.c: Likewise.\n+\t* function.c: Likewise.\n+\t* function.h: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcov-io.c: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattrtab.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* gthr-lynx.h: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* ipa-prop.h: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* ipa-struct-reorg.c: Likewise.\n+\t* ipa-struct-reorg.h: Likewise.\n+\t* ipa-type-escape.c: Likewise.\n+\t* ipa.c: Likewise.\n+\t* loop-doloop.c: Likewise.\n+\t* mips-tfile.c: Likewise.\n+\t* mkmap-flat.awk: Likewise.\n+\t* mkmap-symver.awk: Likewise.\n+\t* modulo-sched.c: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* optabs.h: Likewise.\n+\t* opts.c: Likewise.\n+\t* passes.c: Likewise.\n+\t* postreload-gcse.c: Likewise.\n+\t* postreload.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* pretty-print.h: Likewise.\n+\t* profile.c: Likewise.\n+\t* protoize.c: Likewise.\n+\t* ra-conflict.c: Likewise.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regs.h: Likewise.\n+\t* reload.c: Likewise.\n+\t* rtl-error.c: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* scan.h: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* see.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* target.h: Likewise.\n+\t* tree-dfa.c: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-flow-inline.h: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-nested.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-pass.h: Likewise.\n+\t* tree-pretty-print.c: Likewise.\n+\t* tree-profile.c: Likewise.\n+\t* tree-scalar-evolution.c: Likewise.\n+\t* tree-sra.c: Likewise.\n+\t* tree-ssa-alias-warnings.c: Likewise.\n+\t* tree-ssa-ccp.c: Likewise.\n+\t* tree-ssa-coalesce.c: Likewise.\n+\t* tree-ssa-dom.c: Likewise.\n+\t* tree-ssa-dse.c: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-ssa-live.h: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-ter.c: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-vect-analyze.c: Likewise.\n+\t* tree-vect-transform.c: Likewise.\n+\t* tree-vectorizer.c: Likewise.\n+\t* tree-vn.c: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.def: Likewise.\n+\t* tree.h: Likewise.\n+\t* unwind-dw2-fde.c: Likewise.\n+\t* unwind.inc: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\n 2008-06-05  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/xcoff.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Do not"}, {"sha": "18c1b7107daf4b136a046afd27e2a499bf22eba8", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Discovery of auto-inc and auto-dec instructions.\n-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n    \n This file is part of GCC.\n@@ -636,7 +636,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n \n /* Try to combine the instruction in INC_INSN with the instruction in\n    MEM_INSN.  First the form is determined using the DECISION_TABLE\n-   and and the results of parsing the INC_INSN and the MEM_INSN.\n+   and the results of parsing the INC_INSN and the MEM_INSN.\n    Assuming the form is ok, a prototype new address is built which is\n    passed to ATTEMPT_CHANGE for final processing.  */\n "}, {"sha": "a3fd3feb6c73fb96e466b8fc25290981a6367aaf", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -1490,7 +1490,7 @@ fix_up_fall_thru_edges (void)\n     }\n }\n \n-/* This function checks the destination blockof a \"crossing jump\" to\n+/* This function checks the destination block of a \"crossing jump\" to\n    see if it has any crossing predecessors that begin with a code label\n    and end with an unconditional jump.  If so, it returns that predecessor\n    block.  (This is to avoid creating lots of new basic blocks that all"}, {"sha": "8abcc114647fbba1d126bf7aed5ab007c10dfc69", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Expand builtin functions.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -4783,7 +4783,7 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \n   /* If the actual alignment is less than the alignment of the type,\n      adjust the type accordingly so that we don't assume strict alignment\n-     when deferencing the pointer.  */\n+     when dereferencing the pointer.  */\n   boundary *= BITS_PER_UNIT;\n   if (boundary < TYPE_ALIGN (type))\n     {\n@@ -8768,9 +8768,9 @@ fold_builtin_memory_op (tree dest, tree src, tree len, tree type, bool ignore, i\n       if (!tree_int_cst_equal (lang_hooks.expr_size (srcvar), len))\n \treturn NULL_TREE;\n       /* With memcpy, it is possible to bypass aliasing rules, so without\n-         this check i. e. execute/20060930-2.c would be misoptimized, because\n+         this check i.e. execute/20060930-2.c would be misoptimized, because\n \t it use conflicting alias set to hold argument for the memcpy call.\n-\t This check is probably unnecesary with -fno-strict-aliasing. \n+\t This check is probably unnecessary with -fno-strict-aliasing.\n \t Similarly for destvar.  See also PR29286.  */\n       if (!var_decl_component_p (srcvar)\n \t  /* Accept: memcpy (*char_var, \"test\", 1); that simplify"}, {"sha": "377db5708d06f9559fae80f399e4d4f134a41fd4", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -221,7 +221,7 @@ tree c_global_trees[CTI_MAX];\n \f\n /* Switches common to the C front ends.  */\n \n-/* Nonzero if prepreprocessing only.  */\n+/* Nonzero if preprocessing only.  */\n \n int flag_preprocess_only;\n \n@@ -360,7 +360,7 @@ int flag_gen_declaration;\n \n int print_struct_values;\n \n-/* Tells the compiler what is the constant string class for Objc.  */\n+/* Tells the compiler what is the constant string class for ObjC.  */\n \n const char *constant_string_class_name;\n \n@@ -4496,7 +4496,7 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n \t}\n \n       /* Even though there wasn't an exact match, there might be a\n-\t case range which includes the enumator's value.  */\n+\t case range which includes the enumerator's value.  */\n       node = splay_tree_predecessor (cases, (splay_tree_key) value);\n       if (node && CASE_HIGH ((tree) node->value))\n \t{"}, {"sha": "5948fbd64f6f6d4014e5f949e01441dc9ebae14f", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Define builtin-in macros for the C family front ends.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -301,7 +301,7 @@ builtin_define_decimal_float_constants (const char *name_prefix,\n   sprintf (buf, \"1E-%d%s\", fmt->p - 1, suffix);\n   builtin_define_with_value (name, buf, 0);\n \n-  /* Minimum denormalized postive decimal value.  */\n+  /* Minimum denormalized positive decimal value.  */\n   sprintf (name, \"__%s_DEN__\", name_prefix);\n   p = buf;\n   for (digits = fmt->p; digits > 1; digits--)"}, {"sha": "d28ec9c91a9fa82bc16626f2ed0bcb9989df853c", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -7522,7 +7522,7 @@ c_parser_omp_flush (c_parser *parser)\n   c_finish_omp_flush ();\n }\n \n-/* Parse the restricted form of the for statment allowed by OpenMP.\n+/* Parse the restricted form of the for statement allowed by OpenMP.\n    The real trick here is to determine the loop control variable early\n    so that we can push a new decl if necessary to make it private.  */\n "}, {"sha": "4386c392c9fdb54a20a5260c60afb63fbc6b822e", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1019,7 +1019,7 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n     case COMPLEX_CST:\n       /* Sometimes, we are confused and we think a complex literal\n          is a constant.  Such thing is a compound literal which\n-         grammatically belongs to postifx-expr production.  */\n+         grammatically belongs to postfix-expr production.  */\n       pp_c_compound_literal (pp, e);\n       break;\n \n@@ -1096,7 +1096,7 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     default:\n-      /* FIXME:  Make sure we won't get into an infinie loop.  */\n+      /* FIXME:  Make sure we won't get into an infinite loop.  */\n       pp_c_left_paren (pp);\n       pp_expression (pp, e);\n       pp_c_right_paren (pp);"}, {"sha": "c5c7950f8359fe9907aced1b54ce770ab720ee3d", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Control flow optimization code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -418,8 +418,8 @@ try_forward_edges (int mode, basic_block b)\n      and cold sections.\n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really m\n-     ust be left untouched (they are required to make it safely across\n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n      partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n "}, {"sha": "afa3e1231069b1c7876eea12f9d7775bcded3bdf", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -125,7 +125,7 @@ static struct stack_var *stack_vars;\n static size_t stack_vars_alloc;\n static size_t stack_vars_num;\n \n-/* An array of indicies such that stack_vars[stack_vars_sorted[i]].size\n+/* An array of indices such that stack_vars[stack_vars_sorted[i]].size\n    is non-decreasing.  */\n static size_t *stack_vars_sorted;\n \n@@ -341,7 +341,7 @@ add_alias_set_conflicts (void)\n }\n \n /* A subroutine of partition_stack_vars.  A comparison function for qsort,\n-   sorting an array of indicies by the size of the object.  */\n+   sorting an array of indices by the size of the object.  */\n \n static int\n stack_var_size_cmp (const void *a, const void *b)"}, {"sha": "5815a7edd37aea714a3c30f0fabd8914aa7d0722", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Hooks for cfg representation specific functions.\n-   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Sebastian Pop <s.pop@laposte.net>\n \n This file is part of GCC.\n@@ -1029,7 +1030,7 @@ cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \n /* Conditional jumps are represented differently in trees and RTL,\n    this hook takes a basic block that is known to have a cond jump\n-   at its end and extracts the taken and not taken eges out of it\n+   at its end and extracts the taken and not taken edges out of it\n    and store it in E1 and E2 respectively.  */\n void\n extract_cond_bb_edges (basic_block b, edge *e1, edge *e2)"}, {"sha": "623e5bdd91143785d2b917c21753e2b9ba837a0d", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -378,7 +378,7 @@ struct rtl_opt_pass pass_outof_cfg_layout_mode =\n  }\n };\n \f\n-/* Return sope resulting from combination of S1 and S2.  */\n+/* Return scope resulting from combination of S1 and S2.  */\n static tree\n choose_inner_scope (tree s1, tree s2)\n {"}, {"sha": "d5bd216e08c5d5478f162d89c4e4782431b9dd3d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Loop manipulation code for GNU compiler.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1361,8 +1362,8 @@ loop_version (struct loop *loop,\n       free (bbs);\n     }\n \n-  /* At this point condition_bb is loop predheader with two successors,\n-     first_head and second_head.   Make sure that loop predheader has only\n+  /* At this point condition_bb is loop preheader with two successors,\n+     first_head and second_head.   Make sure that loop preheader has only\n      one successor.  */\n   split_edge (loop_preheader_edge (loop));\n   split_edge (loop_preheader_edge (nloop));\n@@ -1375,7 +1376,7 @@ loop_version (struct loop *loop,\n    removed (thus the loop nesting may be wrong), and some blocks and edges\n    were changed (so the information about bb --> loop mapping does not have\n    to be correct).  But still for the remaining loops the header dominates\n-   the latch, and loops did not get new subloobs (new loops might possibly\n+   the latch, and loops did not get new subloops (new loops might possibly\n    get created, but we are not interested in them).  Fix up the mess.\n \n    If CHANGED_BBS is not NULL, basic blocks whose loop has changed are"}, {"sha": "66189d8ffdef9f2f0f0f9e51e32387232fc3f318", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -296,7 +296,7 @@ cgraph_edge (struct cgraph_node *node, tree call_stmt)\n   return e;\n }\n \n-/* Change call_smtt of edge E to NEW_STMT.  */\n+/* Change call_stmt of edge E to NEW_STMT.  */\n \n void\n cgraph_set_call_stmt (struct cgraph_edge *e, tree new_stmt)\n@@ -701,7 +701,7 @@ cgraph_node_name (struct cgraph_node *node)\n \n /* Names used to print out the availability enum.  */\n const char * const cgraph_availability_names[] =\n-  {\"unset\", \"not_available\", \"overwrittable\", \"available\", \"local\"};\n+  {\"unset\", \"not_available\", \"overwritable\", \"available\", \"local\"};\n \n \n /* Dump call graph node NODE to file F.  */\n@@ -1038,7 +1038,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n   switch (cgraph_state)\n     {\n       case CGRAPH_STATE_CONSTRUCTION:\n-\t/* Just enqueue function to be processed at nearest occurence.  */\n+\t/* Just enqueue function to be processed at nearest occurrence.  */\n \tnode = cgraph_node (fndecl);\n \tnode->next_needed = cgraph_new_nodes;\n \tif (lowered)"}, {"sha": "7c0db40ce7c428a61a8e078d189c3715e2f36b11", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -119,9 +119,9 @@ along with GCC; see the file COPYING3.  If not see\n \tFunctions are output early using call of\n \tcgraph_assemble_pending_function from cgraph_finalize_function.  The\n \tdecision on whether function is needed is made more conservative so\n-\tuninlininable static functions are needed too.  During the call-graph\n+\tuninlinable static functions are needed too.  During the call-graph\n \tconstruction the edge destinations are not marked as reachable and it\n-\tis completely relied upn assemble_variable to mark them.  */\n+\tis completely relied upon assemble_variable to mark them.  */\n \n \n #include \"config.h\"\n@@ -326,7 +326,7 @@ cgraph_build_cdtor_fns (void)\n \n /* Determine if function DECL is needed.  That is, visible to something\n    either outside this translation unit, something magic in the system\n-   configury, or (if not doing unit-at-a-time) to something we havn't\n+   configury, or (if not doing unit-at-a-time) to something we haven't\n    seen yet.  */\n \n static bool\n@@ -1455,7 +1455,7 @@ cgraph_optimize (void)\n /* Generate and emit a static constructor or destructor.  WHICH must\n    be one of 'I' (for a constructor) or 'D' (for a destructor).  BODY\n    is a STATEMENT_LIST containing GENERIC statements.  PRIORITY is the\n-   initialization priority fot this constructor or destructor.  */\n+   initialization priority for this constructor or destructor.  */\n \n void\n cgraph_build_static_cdtor (char which, tree body, int priority)"}, {"sha": "f2d26a29f4ee67b1a8c136772d560cb1e58472be", "filename": "gcc/coverage.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,7 @@\n /* Read and write coverage files, and associated functionality.\n    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   2000, 2001, 2003, 2004, 2005, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n    based on some ideas from Dain Samples of UC Berkeley.\n    Further mangling by Bob Manson, Cygnus Support.\n@@ -489,7 +490,7 @@ coverage_checksum_string (unsigned chksum, const char *string)\n          _GLOBAL__N_<filename>_<wrongmagicnumber>_<magicnumber>functionname\n        since filename might contain extra underscores there seems\n        to be no better chance then walk all possible offsets looking\n-       for magicnuber.  */\n+       for magicnumber.  */\n       if (offset)\n \t{\n \t  for (i = i + offset; string[i]; i++)"}, {"sha": "28f7bfa14a5f89239e411d7e41649c552ce97e79", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -2334,7 +2334,7 @@ dbxout_class_name_qualifiers (tree decl)\n \f\n /* This is a specialized subset of expand_expr for use by dbxout_symbol in\n    evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that\n-   havn't been expanded, or if the expression is getting so complex we won't\n+   haven't been expanded, or if the expression is getting so complex we won't\n    be able to represent it in stabs anyway.  Returns NULL on failure.  */\n \n static rtx\n@@ -2500,7 +2500,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \n   /* If we are to generate only the symbols actually used then such\n      symbol nodes are flagged with TREE_USED.  Ignore any that\n-     aren't flaged as TREE_USED.  */\n+     aren't flagged as TREE_USED.  */\n \n   if (flag_debug_only_used_symbols\n       && (!TREE_USED (decl)"}, {"sha": "11252cd4474a55df43fe72c1230c8ac8c608dcec", "filename": "gcc/df-byte-scan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-byte-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-byte-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-byte-scan.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -161,7 +161,7 @@ df_compute_accessed_bytes_strict_low_part (struct df_ref *ref,\n   int m2_size;\n   int offset;\n \n-  /* In order to accomodate multiword subregs of a hardreg, df_scan\n+  /* In order to accommodate multiword subregs of a hardreg, df_scan\n      eats the subreg and it can only be found from the loc.  */\n   if (REG_P (reg))\n     reg = *(DF_REF_LOC (ref));\n@@ -214,7 +214,7 @@ df_compute_accessed_bytes_subreg (struct df_ref *ref, unsigned int *start_byte,\n   enum machine_mode m2;\n   int m2_size;\n \n-  /* In order to accomodate multiword subregs of a hardreg, df_scan\n+  /* In order to accommodate multiword subregs of a hardreg, df_scan\n      eats the subreg and it can only be found from the loc.  */\n   if (REG_P (reg))\n     reg = *(DF_REF_LOC (ref));"}, {"sha": "95932909ebbab88274090841645e2639890871e8", "filename": "gcc/df-core.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Allocation for dataflow support routines.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+   2008 Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n@@ -42,7 +42,7 @@ requirement is that there be a correct control flow graph.\n There are three variations of the live variable problem that are\n available whenever dataflow is available.  The LR problem finds the\n areas that can reach a use of a variable, the UR problems finds the\n-areas tha can be reached from a definition of a variable.  The LIVE\n+areas that can be reached from a definition of a variable.  The LIVE\n problem finds the intersection of these two areas.  \n \n There are several optional problems.  These can be enabled when they\n@@ -57,7 +57,7 @@ making this happen and are described in the INCREMENTAL SCANNING\n section.\n \n In the middle layer, basic blocks are scanned to produce transfer\n-functions which describe the effects of that block on the a global\n+functions which describe the effects of that block on the global\n dataflow solution.  The transfer functions are only rebuilt if the\n some instruction within the block has changed.  \n \n@@ -343,7 +343,6 @@ There are 4 ways to obtain access to refs:\n    chains.\n \n 4) An array of all of the uses (and an array of all of the defs) can\n-\n    be built.  These arrays are indexed by the value in the id\n    structure.  These arrays are only lazily kept up to date, and that\n    process can be expensive.  To have these arrays built, call\n@@ -370,7 +369,7 @@ address in this second example.\n \n A set to a REG inside a ZERO_EXTRACT, or a set to a non-paradoxical SUBREG\n for which the number of word_mode units covered by the outer mode is\n-smaller than that covered by the inner mode, invokes a read-modify-write.\n+smaller than that covered by the inner mode, invokes a read-modify-write\n operation.  We generate both a use and a def and again mark them\n read/write.\n "}, {"sha": "043cf38398ff4147f7017187e404025e649b4785", "filename": "gcc/df-problems.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,7 +1,6 @@\n /* Standard problems for dataflow support routines.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n-\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+   2008 Free Software Foundation, Inc.\n    Originally contributed by Michael P. Hayes \n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n@@ -2335,7 +2334,7 @@ df_chain_add_problem (enum df_chain_flags chain_flags)\n    reach in the backwards direction.  In and out bitvectors are built\n    for each basic block.  There are two mapping functions,\n    df_byte_lr_get_regno_start and df_byte_lr_get_regno_len that are\n-   used to map regnos into bit vector postions.  \n+   used to map regnos into bit vector positions.\n \n    This problem differs from the regular df_lr function in the way\n    that subregs, *_extracts and strict_low_parts are handled. In lr"}, {"sha": "962c17a816d9a7ea802dbf407fc13524798004ab", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -462,7 +462,7 @@ df_scan_add_problem (void)\n \n \n /* First, grow the reg_info information.  If the current size is less than\n-   the number of psuedos, grow to 25% more than the number of\n+   the number of pseudos, grow to 25% more than the number of\n    pseudos.  \n \n    Second, assure that all of the slots up to max_reg_num have been\n@@ -3434,7 +3434,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \t bottom of the sender block.\n \n          The bottom of the sender block is problematic because not all\n-         out-edges of the a block are eh-edges.  However, it is true\n+         out-edges of a block are eh-edges.  However, it is true\n          that all edges into a block are either eh-edges or none of\n          them are eh-edges.  Thus, we can model this at the top of the\n          eh-receiver for all of the edges at once. */"}, {"sha": "fde3b84bda51180b739af04cac313d33728aa48f", "filename": "gcc/dfp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Decimal floating point support.\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -528,7 +528,7 @@ decimal_real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n   decNumberZero (&dn3);\n   decNumberRescale (&dn, &dn2, &dn3, &set);\n \n-  /* Conver to REAL_VALUE_TYPE and call appropriate conversion\n+  /* Convert to REAL_VALUE_TYPE and call appropriate conversion\n      function.  */\n   decNumberToString (&dn, string);\n   real_from_string (&to, string);"}, {"sha": "811d2b913005ccd89a0e9a498060bd3f16263a61", "filename": "gcc/dominance.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Calculate (post)dominators in slightly super-linear time.\n-   Copyright (C) 2000, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003, 2004, 2005, 2006, 2007, 2008 Free\n+   Software Foundation, Inc.\n    Contributed by Michael Matz (matz@ifh.de).\n \n    This file is part of GCC.\n@@ -82,7 +83,7 @@ struct dom_info\n \n   /* The following few fields implement the structures needed for disjoint\n      sets.  */\n-  /* set_chain[x] is the next node on the path from x to the representant\n+  /* set_chain[x] is the next node on the path from x to the representative\n      of the set containing x.  If set_chain[x]==0 then x is a root.  */\n   TBB *set_chain;\n   /* set_size[x] is the number of elements in the set named by x.  */\n@@ -421,7 +422,7 @@ compress (struct dom_info *di, TBB v)\n static inline TBB\n eval (struct dom_info *di, TBB v)\n {\n-  /* The representant of the set V is in, also called root (as the set\n+  /* The representative of the set V is in, also called root (as the set\n      representation is a tree).  */\n   TBB rep = di->set_chain[v];\n "}, {"sha": "cec95a5f93242532b07c15c3ceaf1f95ee05e11c", "filename": "gcc/domwalk.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Generic dominator tree walker\n-   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -213,7 +214,7 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t    (*walk_data->before_dom_children_after_stmts) (walk_data, bb);\n \n \t  /* Mark the current BB to be popped out of the recursion stack\n-\t     once childs are processed.  */\n+\t     once children are processed.  */\n \t  worklist[sp++] = bb;\n \t  worklist[sp++] = NULL;\n "}, {"sha": "841e4668b274180da0332e562fdffe35b97eb4e4", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* RTL dead store elimination.\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n    Contributed by Richard Sandiford <rsandifor@codesourcery.com>\n    and Kenneth Zadeck <zadeck@naturalbridge.com>\n@@ -345,7 +345,7 @@ struct insn_info\n   /* The linked list of insns that are in consideration for removal in\n      the forwards pass thru the basic block.  This pointer may be\n      trash as it is not cleared when a wild read occurs.  The only\n-     time it is guaranteed to be correct is when the traveral starts\n+     time it is guaranteed to be correct is when the traversal starts\n      at active_local_stores.  */\n   struct insn_info * next_local_store;\n };"}, {"sha": "ba17c3f5c2d10722023c5cce41c4ed907046f86d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -12558,7 +12558,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t}\n       else\n \t{  /* Do nothing for now; maybe need to duplicate die, one for\n-\t      hot section and ond for cold section, then use the hot/cold\n+\t      hot section and one for cold section, then use the hot/cold\n \t      section begin/end labels to generate the aranges...  */\n \t  /*\n \t    add_AT_lbl_id (subr_die, DW_AT_low_pc, hot_section_label);"}, {"sha": "0bacebcf9f81b21f24c61b811e79bce3f020ae07", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1141,7 +1141,7 @@ get_first_label_num (void)\n \n /* If the rtx for label was created during the expansion of a nested\n    function, then first_label_num won't include this label number.\n-   Fix this now so that array indicies work later.  */\n+   Fix this now so that array indices work later.  */\n \n void\n maybe_set_first_label_num (rtx x)\n@@ -1623,7 +1623,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t}\n \n       /* If this is a field reference and not a bit-field, record it.  */\n-      /* ??? There is some information that can be gleened from bit-fields,\n+      /* ??? There is some information that can be gleaned from bit-fields,\n \t such as the word offset in the structure that might be modified.\n \t But skip it for now.  */\n       else if (TREE_CODE (t) == COMPONENT_REF\n@@ -1726,7 +1726,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n   if (TREE_CODE (t) == ALIGN_INDIRECT_REF)\n     {\n-      /* Force EXPR and OFFSE to NULL, since we don't know exactly what\n+      /* Force EXPR and OFFSET to NULL, since we don't know exactly what\n \t we're overlapping.  */\n       offset = NULL;\n       expr = NULL;\n@@ -1960,7 +1960,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR, which is assumed to be\n-   MEMREF offseted by OFFSET bytes.  If VALIDATE is\n+   MEMREF offset by OFFSET bytes.  If VALIDATE is\n    nonzero, the memory address is forced to be valid.  */\n \n rtx"}, {"sha": "02cbcc16402745daec5705e4366cf80b6df37e8d", "filename": "gcc/et-forest.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,7 @@\n /* ET-trees data structure implementation.\n    Contributed by Pavel Nejedly\n-   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of the libiberty library.\n Libiberty is free software; you can redistribute it and/or\n@@ -754,7 +755,7 @@ et_root (struct et_node *node)\n {\n   struct et_occ *occ = node->rightmost_occ, *r;\n \n-  /* The root of the tree corresponds to the rightmost occurence in the\n+  /* The root of the tree corresponds to the rightmost occurrence in the\n      represented path.  */\n   et_splay (occ);\n   for (r = occ; r->next; r = r->next)"}, {"sha": "aaae9d66c51e177ef537303a7864e316db198a95", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -11389,7 +11389,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t{\n \t  if (strict_overflow_p)\n \t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n-\t\t\t\t    \"when simplifying modulos\"),\n+\t\t\t\t    \"when simplifying modulus\"),\n \t\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n \t  return fold_convert (type, tem);\n \t}\n@@ -14758,7 +14758,7 @@ fold_read_from_constant_string (tree exp)\n \t     with constant folding.  (E.g. suppose the lower bound is 1,\n \t     and its mode is QI.  Without the conversion,l (ARRAY\n \t     +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n-\t     +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */\n+\t     +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  */\n \t  if (! integer_zerop (low_bound))\n \t    index = size_diffop (index, fold_convert (sizetype, low_bound));\n "}, {"sha": "928107e35c2fac17b17eeb7734785bd41d23d046", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -2009,15 +2009,15 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n \n   memset (data, 0, sizeof (*data));\n \n-  /* NAMED_ARG is a mis-nomer.  We really mean 'non-varadic'. */\n+  /* NAMED_ARG is a misnomer.  We really mean 'non-variadic'. */\n   if (!cfun->stdarg)\n-    data->named_arg = 1;  /* No varadic parms.  */\n+    data->named_arg = 1;  /* No variadic parms.  */\n   else if (TREE_CHAIN (parm))\n-    data->named_arg = 1;  /* Not the last non-varadic parm. */\n+    data->named_arg = 1;  /* Not the last non-variadic parm. */\n   else if (targetm.calls.strict_argument_naming (&all->args_so_far))\n-    data->named_arg = 1;  /* Only varadic ones are unnamed.  */\n+    data->named_arg = 1;  /* Only variadic ones are unnamed.  */\n   else\n-    data->named_arg = 0;  /* Treat as varadic.  */\n+    data->named_arg = 0;  /* Treat as variadic.  */\n \n   nominal_type = TREE_TYPE (parm);\n   passed_type = DECL_ARG_TYPE (parm);\n@@ -5304,7 +5304,7 @@ match_asm_constraints_1 (rtx insn, rtx *p_sets, int noutputs)\n       emit_insn_before (insns, insn);\n \n       /* Now replace all mentions of the input with output.  We can't\n-\t just replace the occurence in inputs[i], as the register might\n+\t just replace the occurrence in inputs[i], as the register might\n \t also be used in some other input (or even in an address of an\n \t output), which would mean possibly increasing the number of\n \t inputs by one (namely 'output' in addition), which might pose\n@@ -5314,7 +5314,7 @@ match_asm_constraints_1 (rtx insn, rtx *p_sets, int noutputs)\n \n \t Here 'input' is used in two occurrences as input (once for the\n \t input operand, once for the address in the second output operand).\n-\t If we would replace only the occurence of the input operand (to\n+\t If we would replace only the occurrence of the input operand (to\n \t make the matching) we would be left with this:\n \n \t   output = input"}, {"sha": "ece44fdc7ac7ef2dcdd511db43e76e6f4fc86516", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -414,9 +414,9 @@ struct rtl_data GTY(())\n \n extern GTY(()) struct rtl_data x_rtl;\n \n-/* Accestor to RTL datastructures.  We keep them statically allocated now since\n+/* Accessor to RTL datastructures.  We keep them statically allocated now since\n    we never keep multiple functions.  For threaded compiler we might however\n-   want to do differntly.  */\n+   want to do differently.  */\n #define crtl (&x_rtl)\n \n /* This structure can save all the important global and static variables"}, {"sha": "37c3f5f2f02543b4cb621236b3fbab8a20f28b76", "filename": "gcc/gcc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1203,7 +1203,7 @@ static const struct {\n \n /* Translate the options described by *ARGCP and *ARGVP.\n    Make a new vector and store it back in *ARGVP,\n-   and store its length in *ARGVC.  */\n+   and store its length in *ARGCP.  */\n \n static void\n translate_options (int *argcp, const char *const **argvp)\n@@ -7823,8 +7823,8 @@ getenv_spec_function (int argc, const char **argv)\n     fatal (\"environment variable \\\"%s\\\" not defined\", argv[0]);\n \n   /* We have to escape every character of the environment variable so\n-     they are not interpretted as active spec characters.  A\n-     particulaly painful case is when we are reading a variable\n+     they are not interpreted as active spec characters.  A\n+     particularly painful case is when we are reading a variable\n      holding a windows path complete with \\ separators.  */\n   len = strlen (value) * 2 + strlen (argv[1]) + 1;\n   result = xmalloc (len);"}, {"sha": "665b98681c2d05bdce7bbf866f8b16e2016b1173", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* File format for coverage information\n-   Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2005, 2007,\n+   2008  Free Software Foundation, Inc.\n    Contributed by Bob Manson <manson@cygnus.com>.\n    Completely remangled by Nathan Sidwell <nathan@codesourcery.com>.\n \n@@ -507,7 +507,7 @@ gcov_sync (gcov_position_t base, gcov_unsigned_t length)\n #endif\n \n #if IN_LIBGCOV\n-/* Move to the a set position in a gcov file.  */\n+/* Move to a given position in a gcov file.  */\n \n GCOV_LINKAGE void\n gcov_seek (gcov_position_t base)"}, {"sha": "a6cabe84d033344384899b4e5688d21beb63593a", "filename": "gcc/gcov.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -83,7 +83,7 @@ typedef struct arc_info\n   /* Arc is for a function that abnormally returns.  */\n   unsigned int is_call_non_return : 1;\n \n-  /* Arc is for catch/setjump.  */\n+  /* Arc is for catch/setjmp.  */\n   unsigned int is_nonlocal_return : 1;\n \n   /* Is an unconditional branch.  */"}, {"sha": "c86f2af1e79ab31ad7051639532a65d3257abeef", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1705,7 +1705,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \t same PRE GCSE operation repeatedly on the same REG_EQUAL value if we\n \t do more than one PRE GCSE pass.\n \n-\t Note that this does not impede profitale constant propagations.  We\n+\t Note that this does not impede profitable constant propagations.  We\n \t \"look through\" reg-reg sets in lookup_avail_set.  */\n       note = find_reg_equal_equiv_note (insn);\n       if (note != 0\n@@ -4680,7 +4680,7 @@ compute_transpout (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      /* Note that flow inserted a nop a the end of basic blocks that\n+      /* Note that flow inserted a nop at the end of basic blocks that\n \t end in call instructions for reasons other than abnormal\n \t control flow.  */\n       if (! CALL_P (BB_END (bb)))"}, {"sha": "47b6ec13c9f50cb554cb84023c8d35855e9bab98", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to compute values of attributes.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2002, 2003, 2004, 2005, 2006, 2007  Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GCC.\n@@ -135,7 +135,7 @@ struct insn_def\n   struct insn_def *next;\t/* Next insn in chain.  */\n   rtx def;\t\t\t/* The DEFINE_...  */\n   int insn_code;\t\t/* Instruction number.  */\n-  int insn_index;\t\t/* Expression numer in file, for errors.  */\n+  int insn_index;\t\t/* Expression number in file, for errors.  */\n   int lineno;\t\t\t/* Line number.  */\n   int num_alternatives;\t\t/* Number of alternatives.  */\n   int vec_idx;\t\t\t/* Index of attribute vector in `def'.  */"}, {"sha": "59c1af0654499e0f40cf5082613284e30aa58b97", "filename": "gcc/genautomata.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Pipeline hazard description translator.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n    Written by Vladimir Makarov <vmakarov@redhat.com>\n@@ -471,7 +471,7 @@ struct insn_reserv_decl\n   /* The following field is the insn regexp transformed that\n      the regexp has not optional regexp, repetition regexp, and an\n      reservation name (i.e. reservation identifiers are changed by the\n-     corresponding regexp) and all alternations are the topest level\n+     corresponding regexp) and all alternations are the top level\n      of the regexp.  The value can be NULL only if it is special\n      insn `cycle advancing'.  */\n   regexp_t transformed_regexp;\n@@ -4247,11 +4247,11 @@ initiate_presence_absence_pattern_sets (void)\n }\n \n /* The function checks that CHECKED_SET satisfies all presence pattern\n-   sets for units in ORIGIONAL_SET.  The function returns TRUE if it\n+   sets for units in ORIGINAL_SET.  The function returns TRUE if it\n    is ok.  */\n static int\n check_presence_pattern_sets (reserv_sets_t checked_set,\n-\t\t\t     reserv_sets_t origional_set,\n+\t\t\t     reserv_sets_t original_set,\n \t\t\t     int final_p)\n {\n   int char_num;\n@@ -4264,9 +4264,9 @@ check_presence_pattern_sets (reserv_sets_t checked_set,\n \n   chars_num = els_in_cycle_reserv * sizeof (set_el_t);\n   for (char_num = 0; char_num < chars_num; char_num++)\n-    if (((unsigned char *) origional_set) [char_num])\n+    if (((unsigned char *) original_set) [char_num])\n       for (i = CHAR_BIT - 1; i >= 0; i--)\n-\tif ((((unsigned char *) origional_set) [char_num] >> i) & 1)\n+\tif ((((unsigned char *) original_set) [char_num] >> i) & 1)\n \t  {\n \t    start_unit_num = char_num * CHAR_BIT + i;\n \t    if (start_unit_num >= description->units_num)\n@@ -4296,11 +4296,11 @@ check_presence_pattern_sets (reserv_sets_t checked_set,\n }\n \n /* The function checks that CHECKED_SET satisfies all absence pattern\n-   sets for units in ORIGIONAL_SET.  The function returns TRUE if it\n+   sets for units in ORIGINAL_SET.  The function returns TRUE if it\n    is ok.  */\n static int\n check_absence_pattern_sets (reserv_sets_t checked_set,\n-\t\t\t    reserv_sets_t origional_set,\n+\t\t\t    reserv_sets_t original_set,\n \t\t\t    int final_p)\n {\n   int char_num;\n@@ -4312,9 +4312,9 @@ check_absence_pattern_sets (reserv_sets_t checked_set,\n \n   chars_num = els_in_cycle_reserv * sizeof (set_el_t);\n   for (char_num = 0; char_num < chars_num; char_num++)\n-    if (((unsigned char *) origional_set) [char_num])\n+    if (((unsigned char *) original_set) [char_num])\n       for (i = CHAR_BIT - 1; i >= 0; i--)\n-\tif ((((unsigned char *) origional_set) [char_num] >> i) & 1)\n+\tif ((((unsigned char *) original_set) [char_num] >> i) & 1)\n \t  {\n \t    start_unit_num = char_num * CHAR_BIT + i;\n \t    if (start_unit_num >= description->units_num)\n@@ -5393,7 +5393,7 @@ make_automaton (automaton_t automaton)\n   VEC_free (state_t,heap, state_stack);\n }\n \n-/* Foms lists of all arcs of STATE marked by the same ainsn.  */\n+/* Form lists of all arcs of STATE marked by the same ainsn.  */\n static void\n form_arcs_marked_by_insn (state_t state)\n {\n@@ -8488,7 +8488,7 @@ output_description (void)\n \t{\n \t  if (DECL_UNIT (decl)->excl_list != NULL)\n \t    {\n-\t      fprintf (output_description_file, \"unit %s exlusion_set: \",\n+\t      fprintf (output_description_file, \"unit %s exclusion_set: \",\n \t\t       DECL_UNIT (decl)->name);\n \t      output_unit_set_el_list (DECL_UNIT (decl)->excl_list);\n \t      fprintf (output_description_file, \"\\n\");"}, {"sha": "416f9114122df4cdeb2ad869d77cdf4a9fec862c", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -386,7 +386,7 @@ static struct globals\n   /* Maximum number of elements that can be used before resizing.  */\n   unsigned int depth_max;\n \n-  /* Each element of this arry is an index in by_depth where the given\n+  /* Each element of this array is an index in by_depth where the given\n      depth starts.  This structure is indexed by that given depth we\n      are interested in.  */\n   unsigned int *depth;"}, {"sha": "a80a6a0e979da24933e42d62d54fe98b1e80dbb3", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -2445,7 +2445,7 @@ ggc_pch_finish (struct ggc_pch_data *d, FILE *f)\n     fatal_error (\"can't seek PCH file: %m\");\n \n   if (fwrite (d->alloc_bits, d->alloc_size, 1, f) != 1)\n-    fatal_error (\"can't write PCH fle: %m\");\n+    fatal_error (\"can't write PCH file: %m\");\n \n   /* Done with the PCH, so write out our footer.  */\n   if (fwrite (&d->d, sizeof (d->d), 1, f) != 1)"}, {"sha": "462e4a2cb85f3b543becd0185ae91a2423a186fa", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -6494,7 +6494,7 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   unshare_body (body_p, fndecl);\n   unvisit_body (body_p, fndecl);\n \n-  /* Make sure input_location isn't set to something wierd.  */\n+  /* Make sure input_location isn't set to something weird.  */\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n \n   /* Resolve callee-copies.  This has to be done before processing"}, {"sha": "5a8147df680a713086e988e4f0a681d1a57db7e8", "filename": "gcc/gthr-lynx.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgthr-lynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fgthr-lynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-lynx.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,7 +1,7 @@\n /* Threads compatibility routines for libgcc2 and libobjc for\n    LynxOS.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 2004, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -44,7 +44,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* When using static libc on LynxOS, we cannot define pthread_create\n    weak.  If the multi-threaded application includes iostream.h,\n    gthr-posix.h is included and pthread_create will be defined weak.\n-   If pthead_create is weak its defining module in libc is not\n+   If pthread_create is weak its defining module in libc is not\n    necessarily included in the link and the symbol is resolved to zero.\n    Therefore the first call to it will crash.\n "}, {"sha": "bb799f96c3c2c870f529197e41af2d056f627a01", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1110,7 +1110,7 @@ ready_sort (struct ready_list *ready)\n \n /* PREV is an insn that is ready to execute.  Adjust its priority if that\n    will help shorten or lengthen register lifetimes as appropriate.  Also\n-   provide a hook for the target to tweek itself.  */\n+   provide a hook for the target to tweak itself.  */\n \n HAIFA_INLINE static void\n adjust_priority (rtx prev)\n@@ -2373,7 +2373,7 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n \t      asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT\n \t\t       || asm_noperands (PATTERN (insn)) >= 0);\n \t      if (!first_cycle_insn_p && asm_p)\n-\t\t/* This is asm insn which is tryed to be issued on the\n+\t\t/* This is asm insn which is tried to be issued on the\n \t\t   cycle not first.  Issue it on the next cycle.  */\n \t\tcost = 1;\n \t      else\n@@ -2548,7 +2548,7 @@ schedule_block (basic_block *target_bb, int rgn_n_insns1)\n     {\n       targetm.sched.md_finish (sched_dump, sched_verbose);\n \n-      /* Target might have added some instructions to the scheduled block.\n+      /* Target might have added some instructions to the scheduled block\n \t in its md_finish () hook.  These new insns don't have any data\n \t initialized and to identify them we extend h_i_d so that they'll\n \t get zero luids.*/"}, {"sha": "4e0679c77b6e166f17e17f42453e6d80513daff8", "filename": "gcc/hwint.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* HOST_WIDE_INT definitions for the GNU compiler.\n-   Copyright (C) 1998, 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2002, 2004, 2008 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -139,7 +139,7 @@ extern char sizeof_long_long_must_be_8[sizeof(long long) == 8 ? 1 : -1];\n #    define HOST_WIDEST_FAST_INT __int64\n #    define HOST_BITS_PER_WIDEST_FAST_INT HOST_BITS_PER___INT64\n #  else\n-#    error \"Your host said it wantted to use long long or __int64 but neither\"\n+#    error \"Your host said it wanted to use long long or __int64 but neither\"\n #    error \"exist\"\n #  endif\n #else"}, {"sha": "9e2153141d3e6cbf5a59aff3cce07a0789434f12", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -99,7 +99,7 @@ along with GCC; see the file COPYING3.  If not see\n    2. For read-only parameters that do not live in memory, we replace all their\n       uses with the constant.\n \n-   We also need to modify some callsites to call the cloned functiosns instead\n+   We also need to modify some callsites to call the cloned functions instead\n    of the original ones.  For a callsite passing an argument found to be a\n    constant by IPCP, there are two different cases to handle:\n    1. A constant is passed as an argument.  In this case the callsite in the\n@@ -109,7 +109,7 @@ along with GCC; see the file COPYING3.  If not see\n       only the callsite in the cloned caller is redirected to call to the\n       cloned callee.\n \n-   This update is done in two steps: First all cloned functionss are created\n+   This update is done in two steps: First all cloned functions are created\n    during a traversal of the call graph, during which all callsites are\n    redirected to call the cloned function.  Then the callsites are traversed\n    and many calls redirected back to fit the description above."}, {"sha": "6d74c1f71b7e684e2fa60d36189b0659cfa2bcc0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Inlining decision heuristics.\n-   Copyright (C) 2003, 2004, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -520,7 +520,7 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n      within function, the function itself is infrequent.\n \n      Other objective to optimize for is number of different calls inlined.\n-     We add the estimated growth after inlining all functions to biass the\n+     We add the estimated growth after inlining all functions to bias the\n      priorities slightly in this direction (so fewer times called functions\n      of the same size gets priority).  */\n   else if (flag_guess_branch_prob)"}, {"sha": "a81418d7f47fc3108a488794c6abe4b4efa7f7f3", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Interprocedural analyses.\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -115,7 +115,7 @@ struct ipa_replace_map\n struct ipa_node_params\n {\n   /* Number of formal parameters of this function.  When set to 0,\n-     this functions's parameters would not be analyzed by the different\n+     this function's parameters would not be analyzed by the different\n      stages of IPA CP.  */\n   int param_count;\n   /* Array of lattices.  */\n@@ -134,7 +134,7 @@ struct ipa_node_params\n      one.  */\n   gcov_type count_scale;\n \n-  /* Whether this fynction is called with variable number of actual\n+  /* Whether this function is called with variable number of actual\n      arguments.  */\n   unsigned called_with_var_arguments : 1;\n };\n@@ -165,7 +165,7 @@ ipa_get_ith_param (struct ipa_node_params *info, int i)\n   return info->param_decls[i];\n }\n \n-/* Returns the modification flag corresponding o the ith paramterer.  Note\n+/* Returns the modification flag corresponding to the ith parameter.  Note\n    there is no setter method as the goal is to set all flags when building the\n    array in ipa_detect_param_modifications.  */\n static inline bool"}, {"sha": "3b2cdaee2a1b143d5212d37a2d8e517e518b78a8", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Callgraph based analysis of static variables.\n-   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n \n This file is part of GCC.\n@@ -18,9 +18,9 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* This file mark functions as being either const (TREE_READONLY) or\n-   pure (DECL_PURE_P).  It can also set the a variant of these that\n-   are allowed to infinite loop (DECL_LOOPING_CONST_PURE_P).\n+/* This file marks functions as being either const (TREE_READONLY) or\n+   pure (DECL_PURE_P).  It can also set a variant of these that\n+   are allowed to loop indefinitely (DECL_LOOPING_CONST_PURE_P).\n \n    This must be run after inlining decisions have been made since\n    otherwise, the local sets will not contain information that is\n@@ -85,7 +85,7 @@ get_function_state (struct cgraph_node *node)\n   return (funct_state) info->aux;\n }\n \n-/* Check to see if the use (or definition when CHECHING_WRITE is true) \n+/* Check to see if the use (or definition when CHECKING_WRITE is true)\n    variable T is legal in a function that is either pure or const.  */\n \n static inline void \n@@ -174,7 +174,7 @@ check_tree (funct_state local, tree t, bool checking_write)\n       || TREE_CODE (t) == SSA_NAME)\n     return;\n \n-  /* Any tree which is volatile disqualifies thie function from being\n+  /* Any tree which is volatile disqualifies this function from being\n      const or pure. */\n   if (TREE_THIS_VOLATILE (t))\n     {\n@@ -641,7 +641,7 @@ static_execute (void)\n      is a master clone.  However, we do NOT process any\n      AVAIL_OVERWRITABLE functions (these are never clones) we cannot\n      guarantee that what we learn about the one we see will be true\n-     for the one that overriders it.\n+     for the one that overrides it.\n   */\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed && cgraph_is_master_clone (node))"}, {"sha": "908681dc12f454c239506fb575389cddd97566d0", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Struct-reorg optimization.\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Olga Golovanevsky <olga@il.ibm.com>\n    (Initial version of this code was developed\n    by Caroline Tice and Mostafa Hagog.)\n@@ -309,7 +309,7 @@ is_result_of_mult (tree arg, tree *num, tree struct_size)\n {\n   tree size_def_stmt = SSA_NAME_DEF_STMT (arg);\n \n-  /* If allocation  statementt was of the form \n+  /* If the allocation statement was of the form\n      D.2229_10 = <alloc_func> (D.2228_9);\n      then size_def_stmt can be D.2228_9 = num.3_8 * 8;  */\n \n@@ -406,7 +406,7 @@ decompose_indirect_ref_acc (tree str_decl, struct field_access_site *acc)\n \n \n /* This function checks whether the access ACC of structure type STR \n-   is of the form suitable for tranformation. If yes, it returns true. \n+   is of the form suitable for transformation. If yes, it returns true.\n    False otherwise.  */\n \n static bool\n@@ -435,7 +435,7 @@ make_field_acc_node (void)\n }\n \n /* This function returns the structure field access, defined by STMT,\n-   if it is aready in hashtable of function accesses F_ACCS.  */\n+   if it is already in hashtable of function accesses F_ACCS.  */\n \n static struct field_access_site *\n is_in_field_accs (tree stmt, htab_t f_accs)\n@@ -538,7 +538,7 @@ finalize_new_vars_creation (void **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-/* This funciton updates statements in STMT_LIST with BB info.  */\n+/* This function updates statements in STMT_LIST with BB info.  */\n \n static void\n add_bb_info (basic_block bb, tree stmt_list)\n@@ -587,7 +587,7 @@ is_in_new_vars_htab (tree decl, htab_t new_vars_htab)\n \t\t\t\t\thtab_hash_pointer (decl));\n }\n \n-/* Given original varaiable ORIG_VAR, this function returns\n+/* Given original variable ORIG_VAR, this function returns\n    new variable corresponding to it of NEW_TYPE type. */\n \n static tree\n@@ -1616,7 +1616,7 @@ is_equal_types (tree type1, tree type2)\n     case ENUMERAL_TYPE:\n       {\n \ttree field1;\n-\t/* Compare fields of struture.  */\n+\t/* Compare fields of structure.  */\n \tfor (field1 = TYPE_FIELDS (type1); field1; \n \t     field1 = TREE_CHAIN (field1))\n \t  {\n@@ -1760,7 +1760,7 @@ create_new_malloc (tree malloc_stmt, tree new_type, tree *new_stmts, tree num)\n \n /* This function returns a tree representing \n    the number of instances of structure STR_DECL allocated \n-   by allocation STMT. If new statments are generated, \n+   by allocation STMT. If new statements are generated,\n    they are filled into NEW_STMTS_P.  */\n \n static tree \n@@ -2074,7 +2074,7 @@ dump_acc (void **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-/* This function frees memory allocated for strcuture clusters, \n+/* This function frees memory allocated for structure clusters,\n    starting from CLUSTER.  */\n \n static void\n@@ -2402,7 +2402,7 @@ remove_structure (unsigned i)\n }\n \n /* Currently we support only EQ_EXPR or NE_EXPR conditions.\n-   COND_STNT is a condition statement to check.  */\n+   COND_STMT is a condition statement to check.  */\n \n static bool\n is_safe_cond_expr (tree cond_stmt)\n@@ -2861,7 +2861,7 @@ check_bitfields (d_str str, VEC (tree, heap) **unsuitable_types)\n }\n \n /* This function adds to UNSUITABLE_TYPES those types that escape \n-   due to results of ipa-type-escpae analysis. See ipa-type-escpae.[c,h].  */\n+   due to results of ipa-type-escape analysis. See ipa-type-escape.[c,h].  */\n \n static void\n exclude_escaping_types_1 (VEC (tree, heap) **unsuitable_types)\n@@ -3158,7 +3158,7 @@ exclude_alloc_and_field_accs_1 (d_str str, struct cgraph_node *node)\n     htab_traverse (dt.str->accs, exclude_from_accs, &dt);  \n }\n \n-/* Collect accesses to the structure types that apear in basic bloack BB.  */\n+/* Collect accesses to the structure types that appear in basic block BB.  */\n \n static void\n collect_accesses_in_bb (basic_block bb)\n@@ -3181,8 +3181,8 @@ collect_accesses_in_bb (basic_block bb)\n     }\n }\n \n-/* This function generates cluster substructure that cointains FIELDS.\n-   The cluster added to the set of clusters of the structure SRT.  */\n+/* This function generates cluster substructure that contains FIELDS.\n+   The cluster added to the set of clusters of the structure STR.  */\n \n static void\n gen_cluster (sbitmap fields, d_str str)"}, {"sha": "54cdbc9982f13d4260c709e984c2e87f420570b9", "filename": "gcc/ipa-struct-reorg.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-struct-reorg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-struct-reorg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Struct-reorg optimization.\n-   Copyright (C) 2002, 2003-2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003-2007, 2008 Free Software Foundation, Inc.\n    Contributed by Olga Golovanevsky <olga@il.ibm.com>\n \n This file is part of GCC.\n@@ -104,7 +104,7 @@ struct data_structure\n   /* A data structure representing a reorganization decision.  */\n   struct field_cluster *struct_clustering;\n \n-  /* New types to replace an the original structure type.  */\n+  /* New types to replace the original structure type.  */\n   VEC(tree, heap) *new_types;\n };\n "}, {"sha": "229d8b2e9a56495d899c929bf2934afd6f39a1d8", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Type based alias analysis.\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n \n This file is part of GCC.\n@@ -1781,7 +1782,7 @@ type_for_uid (int uid)\n   else return NULL;\n }\n \n-/* Return the a bitmap with the subtypes of the type for UID.  If it\n+/* Return a bitmap with the subtypes of the type for UID.  If it\n    does not exist, return either NULL or a new bitmap depending on the\n    value of CREATE.  */ \n \n@@ -2054,7 +2055,7 @@ type_escape_execute (void)\n   FOR_EACH_STATIC_VARIABLE (vnode)\n     analyze_variable (vnode);\n \n-  /* Process all of the functions. next\n+  /* Process all of the functions next.\n \n      We do not want to process any of the clones so we check that this\n      is a master clone.  However, we do need to process any"}, {"sha": "0e2cb2db9eb8596a276fe49fa4a27d2b176753dc", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Basic IPA optimizations and utilities.\n-   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.  \n+   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation,\n+   Inc.\n \n This file is part of GCC.\n \n@@ -42,7 +43,7 @@ cgraph_postorder (struct cgraph_node **order)\n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need\n      to be output and put them into order as well, so we get dependencies\n-     right through intline functions.  */\n+     right through inline functions.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n   for (node = cgraph_nodes; node; node = node->next)"}, {"sha": "c6e0540d15fb2697251874b83d70403062879168", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Perform doloop optimizations\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Based on code by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n \n This file is part of GCC.\n@@ -362,7 +363,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       fputs (\" iterations).\\n\", dump_file);\n     }\n \n-  /* Get the probabilty of the original branch. If it exists we would\n+  /* Get the probability of the original branch. If it exists we would\n      need to update REG_BR_PROB of the new jump_insn.  */\n   true_prob_val = find_reg_note (jump_insn, REG_BR_PROB, NULL_RTX);\n "}, {"sha": "eee4ddf322fecf297e02e5846abd4635e526ea4b", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Matrix layout transformations.\n-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Razya Ladelsky <razya@il.ibm.com>\n    Originally written by Revital Eres and Mustafa Hagog.\n    \n@@ -1543,7 +1543,7 @@ check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n \t  mark_min_matrix_escape_level (mi, level, call_stmt);\n \t  if (dump_file)\n \t    fprintf (dump_file,\n-\t\t     \"Matrix %s: Cannot calculate the size of allocation. escaping at level %d\\n\",\n+\t\t     \"Matrix %s: Cannot calculate the size of allocation, escaping at level %d\\n\",\n \t\t     get_name (mi->decl), level);\n \t  break;\n \t}"}, {"sha": "56a953747e42d84d8bf1b63656126d3d4fad1353", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    The auxiliary table is a series of 32 bit integers, that are\n    referenced as needed from the local symbol table.  Unlike standard\n-   COFF, the aux.  information does not follow the symbol that uses\n+   COFF, the aux. information does not follow the symbol that uses\n    it, but rather is a separate table.  In theory, this would allow\n    the MIPS compilers to collapse duplicate aux. entries, but I've not\n    noticed this happening with the 1.31 compiler suite.  The different"}, {"sha": "377731a4e7d7772ba4372e4a7af5122d46ff00af", "filename": "gcc/mkmap-flat.awk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmkmap-flat.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmkmap-flat.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkmap-flat.awk?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n # Generate a flat list of symbols to export.\n-#\tCopyright (C) 2007  Free Software Foundation, Inc.\n+#\tCopyright (C) 2007, 2008  Free Software Foundation, Inc.\n #\tContributed by Richard Henderson <rth@cygnus.com>\n #\n # This file is part of GCC.\n@@ -56,7 +56,7 @@ state == \"nm\" {\n # Now we process a simplified variant of the Solaris symbol version\n # script.  We have one symbol per line, no semicolons, simple markers\n # for beginning and ending each section, and %inherit markers for\n-# describing version inheritence.  A symbol may appear in more than\n+# describing version inheritance.  A symbol may appear in more than\n # one symbol version, and the last seen takes effect.\n # The magic version name '%exclude' causes all the symbols given that\n # version to be dropped from the output (unless a later version overrides)."}, {"sha": "855043f7e6c9a01c7ac64b4d040326a4ba01f854", "filename": "gcc/mkmap-symver.awk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmkmap-symver.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmkmap-symver.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkmap-symver.awk?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n # Generate an ELF symbol version map a-la Solaris and GNU ld.\n-#\tCopyright (C) 2007  Free Software Foundation, Inc.\n+#\tCopyright (C) 2007, 2008  Free Software Foundation, Inc.\n #\tContributed by Richard Henderson <rth@cygnus.com>\n #\n # This file is part of GCC.\n@@ -58,7 +58,7 @@ state == \"nm\" {\n # Now we process a simplified variant of the Solaris symbol version\n # script.  We have one symbol per line, no semicolons, simple markers\n # for beginning and ending each section, and %inherit markers for\n-# describing version inheritence.  A symbol may appear in more than\n+# describing version inheritance.  A symbol may appear in more than\n # one symbol version, and the last seen takes effect.\n # The magic version name '%exclude' causes all the symbols given that\n # version to be dropped from the output (unless a later version overrides)."}, {"sha": "f11bc1c35cffb0afbcc338ccb4a78ac60a1c7202", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Swing Modulo Scheduling implementation.\n-   Copyright (C) 2004, 2005, 2006, 2007\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -965,7 +965,7 @@ sms_schedule (void)\n       if (single_exit (loop)->count)\n \ttrip_count = latch_edge->count / single_exit (loop)->count;\n \n-      /* Perfrom SMS only on loops that their average count is above threshold.  */\n+      /* Perform SMS only on loops that their average count is above threshold.  */\n \n       if ( latch_edge->count\n           && (latch_edge->count < single_exit (loop)->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD))\n@@ -1680,7 +1680,7 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n    parameters to decide if that's possible:\n    PS - The partial schedule.\n    U - The serial number of U_NODE.\n-   NUM_SPLITS - The number of row spilts made so far.\n+   NUM_SPLITS - The number of row splits made so far.\n    MUST_PRECEDE - The nodes that must precede U_NODE. (only valid at\n    the first row of the scheduling window)\n    MUST_FOLLOW - The nodes that must follow U_NODE. (only valid at the\n@@ -2125,7 +2125,7 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n   sbitmap_zero (prev_sccs);\n   sbitmap_ones (ones);\n \n-  /* Perfrom the node ordering starting from the SCC with the highest recMII.\n+  /* Perform the node ordering starting from the SCC with the highest recMII.\n      For each SCC order the nodes according to their ASAP/ALAP/HEIGHT etc.  */\n   for (i = 0; i < all_sccs->num_sccs; i++)\n     {\n@@ -2740,7 +2740,7 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n \t    return true;\n \n \t  /* Update the DFA state and return with failure if the DFA found\n-\t     recource conflicts.  */\n+\t     resource conflicts.  */\n \t  if (state_transition (curr_state, insn) >= 0)\n \t    return true;\n "}, {"sha": "8f0470f6dfd64d65c722a82e827ddd9eef4f2688", "filename": "gcc/omega.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -5,7 +5,8 @@\n    This code has no license restrictions, and is considered public\n    domain.\n \n-   Changes copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Changes copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n \n This file is part of GCC.\n@@ -2433,7 +2434,7 @@ smooth_weird_equations (omega_pb pb)\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  {\n \t\t    fprintf (dump_file,\n-\t\t\t     \"Smoothing wierd equations; adding:\\n\");\n+\t\t\t     \"Smoothing weird equations; adding:\\n\");\n \t\t    omega_print_geq (dump_file, pb, &pb->geqs[e3]);\n \t\t    fprintf (dump_file, \"\\nto:\\n\");\n \t\t    omega_print_problem (dump_file, pb);"}, {"sha": "c608ae4521eae87eb313d1c68087c7bfdd2d4d86", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -4110,7 +4110,7 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t}\n       else if (code == OMP_ATOMIC_STORE)\n \t{\n-\t  /* OMP_ATOMIC_STORE is analoguous to OMP_RETURN, but matches with\n+\t  /* OMP_ATOMIC_STORE is analogous to OMP_RETURN, but matches with\n \t     OMP_ATOMIC_LOAD.  */\n \t  gcc_assert (parent);\n \t  gcc_assert (parent->type == OMP_ATOMIC_LOAD);\n@@ -5124,7 +5124,7 @@ diagnose_sb_0 (tree *stmt_p, tree branch_ctx, tree label_ctx)\n     return false;\n \n   /* Try to avoid confusing the user by producing and error message\n-     with correct \"exit\" or \"enter\" verbage.  We prefer \"exit\"\n+     with correct \"exit\" or \"enter\" verbiage.  We prefer \"exit\"\n      unless we can show that LABEL_CTX is nested within BRANCH_CTX.  */\n   if (branch_ctx == NULL)\n     exit_p = false;"}, {"sha": "558a708c5f91fc951fab58f703079fd4f4954d0e", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -5785,7 +5785,7 @@ gen_fp_to_int_conv_libfunc (convert_optab tab,\n   gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n }\n \n-/* Initialize the libfunc fiels of an of an intra-mode-class conversion optab.\n+/* Initialize the libfunc fields of an of an intra-mode-class conversion optab.\n    The string formation rules are\n    similar to the ones for init_libfunc, above.  */\n "}, {"sha": "30a28d4816da4f89e65c61a165605aa6dd09771d", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -115,7 +115,7 @@ enum optab_index\n      wider than the multiplicand and multiplier.\n      All involved operations are saturating.  */\n   OTI_ssmadd_widen,\n-  /* Unigned multiply and add with the result and addend one machine mode\n+  /* Unsigned multiply and add with the result and addend one machine mode\n      wider than the multiplicand and multiplier.\n      All involved operations are saturating.  */\n   OTI_usmadd_widen,\n@@ -129,7 +129,7 @@ enum optab_index\n      wider than the multiplicand and multiplier.\n      All involved operations are saturating.  */\n   OTI_ssmsub_widen,\n-  /* Unigned multiply and subtract the result and minuend one machine mode\n+  /* Unsigned multiply and subtract the result and minuend one machine mode\n      wider than the multiplicand and multiplier.\n      All involved operations are saturating.  */\n   OTI_usmsub_widen,"}, {"sha": "4a6d440bc1bdcbd0f6d5336c958ca5709e03dbd6", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Command line option handling.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n@@ -950,7 +950,7 @@ decode_options (unsigned int argc, const char **argv)\n      modify it.  */\n   target_flags = targetm.default_target_flags;\n \n-  /* Some tagets have ABI-specified unwind tables.  */\n+  /* Some targets have ABI-specified unwind tables.  */\n   flag_unwind_tables = targetm.unwind_tables_default;\n \n #ifdef OPTIMIZATION_OPTIONS\n@@ -1405,7 +1405,7 @@ common_handle_option (size_t scode, const char *arg, int value,\n \tunsigned int include_flags = 0;\n \t/* Note - by default we include undocumented options when listing\n \t   specific classes.  If you only want to see documented options\n-\t   then add \",^undocumented\" to the --help= option.  e.g.:\n+\t   then add \",^undocumented\" to the --help= option.  E.g.:\n \n \t   --help=target,^undocumented  */\n \tunsigned int exclude_flags = 0;\n@@ -1465,7 +1465,7 @@ common_handle_option (size_t scode, const char *arg, int value,\n \t    /* Check to see if the string matches a language name.\n \t       Note - we rely upon the alpha-sorted nature of the entries in\n \t       the lang_names array, specifically that shorter names appear\n-\t       before their longer variants.  (ie C before C++).  That way\n+\t       before their longer variants.  (i.e. C before C++).  That way\n \t       when we are attempting to match --help=c for example we will\n \t       match with C first and not C++.  */\n \t    for (i = 0, lang_flag = 0; i < cl_lang_count; i++)"}, {"sha": "488808b6d390e5678bc35b1774331af0c3adf16a", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Top level of GCC compilers (cc1, cc1plus, etc.)\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1236,7 +1236,7 @@ execute_one_pass (struct opt_pass *pass)\n   unsigned int todo_after = 0;\n \n   /* IPA passes are executed on whole program, so cfun should be NULL.\n-     Ohter passes needs function context set.  */\n+     Other passes need function context set.  */\n   if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)\n     gcc_assert (!cfun && !current_function_decl);\n   else"}, {"sha": "27889d01f2ee7f7bba340680f37be316956e723b", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Post reload partially redundant load elimination\n-   Copyright (C) 2004, 2005, 2006, 2007\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1269,7 +1269,7 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n \n   memset (&stats, 0, sizeof (stats));\n \n-  /* Allocate ememory for this pass.\n+  /* Allocate memory for this pass.\n      Also computes and initializes the insns' CUIDs.  */\n   alloc_mem ();\n "}, {"sha": "527bd8b0beff1374fdb21891e5fe93fb7bc083ec", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Perform simple optimizations to clean up the result of reload.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -661,7 +661,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n    replace them with reg+reg addressing.  */\n #define RELOAD_COMBINE_MAX_USES 6\n \n-/* INSN is the insn where a register has ben used, and USEP points to the\n+/* INSN is the insn where a register has been used, and USEP points to the\n    location of the register within the rtl.  */\n struct reg_use { rtx insn, *usep; };\n "}, {"sha": "2d6faf35679641071b340e0bd6c74c265ea6039e", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Branch prediction routines for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1493,7 +1493,7 @@ tree_estimate_probability (void)\n   return 0;\n }\n \f\n-/* Predict edges to succestors of CUR whose sources are not postdominated by\n+/* Predict edges to successors of CUR whose sources are not postdominated by\n    BB by PRED and recurse to all postdominators.  */\n \n static void"}, {"sha": "dd3f0c0ad3909f8cd2196c1aadcdf59da45bd84c", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Various declarations for language-independent pretty-print subroutines.\n-   Copyright (C) 2002, 2003, 2004, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -142,7 +142,7 @@ typedef bool (*printer_fn) (pretty_printer *, text_info *, const char *,\n    formatting.  */\n #define pp_needs_newline(PP)  pp_base (PP)->need_newline \n \n-/* True if PRETTY-PTINTER is in line-wrapping mode.  */\n+/* True if PRETTY-PRINTER is in line-wrapping mode.  */\n #define pp_is_wrapping_line(PP) (pp_line_cutoff (PP) > 0)\n \n /* The amount of whitespace to be emitted when starting a new line.  */"}, {"sha": "78568228e1f7ac9ddd8474b876dc07379e8f43ff", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -441,7 +441,7 @@ compute_branch_probabilities (void)\n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    total += e->count;\n \n-\t\t  /* Seedgeh for the invalid edge, and set its count.  */\n+\t\t  /* Search for the invalid edge, and set its count.  */\n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    if (! EDGE_INFO (e)->count_valid && ! EDGE_INFO (e)->ignore)\n \t\t      break;"}, {"sha": "aab1291dbb2633a9152342adbcd080e31b89a25c", "filename": "gcc/protoize.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,7 @@\n /* Protoize program - Original version by Ron Guilmette (rfg@segfault.us.com).\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1723,7 +1724,7 @@ save_def_or_dec (const char *l, int is_syscalls)\n     }\n \n   /* Since we are unprotoizing, if this item is already in old (K&R) style,\n-     we can just ignore it.  If that is true, throw away the itme now.  */\n+     we can just ignore it.  If that is true, throw away the item now.  */\n \n   if (!def_dec_p->prototyped)\n     {"}, {"sha": "c693bc4d8b344d28495b85b78bbde60203ff543e", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Allocate registers for pseudo-registers that span basic blocks.\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n \n This file is part of GCC.\n@@ -405,7 +405,7 @@ set_conflicts_for_earlyclobber (rtx insn)\n \n \n /* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] using\n-   REG to the the number of nregs, and INIT_VALUE to get the\n+   REG to the number of nregs, and INIT_VALUE to get the\n    initialization.  ALLOCNUM need not be the regno of REG.  */\n \n void"}, {"sha": "5da2cb3b2cedf3f8958c6229116aa091690d431f", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -3526,7 +3526,7 @@ encode_ibm_extended (const struct real_format *fmt, long *buf,\n \n   base_fmt = fmt->qnan_msb_set ? &ieee_double_format : &mips_double_format;\n \n-  /* Renormlize R before doing any arithmetic on it.  */\n+  /* Renormalize R before doing any arithmetic on it.  */\n   normr = *r;\n   if (normr.cl == rvc_normal)\n     normalize (&normr);"}, {"sha": "bf4c2b4a64ff3f4ed89b5ebc66e1ff491f38272f", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -451,7 +451,7 @@ confirm_change_group (void)\n       if (changes[i].unshare)\n \t*changes[i].loc = copy_rtx (*changes[i].loc);\n \n-      /* Avoid unnecesary rescanning when multiple changes to same instruction\n+      /* Avoid unnecessary rescanning when multiple changes to same instruction\n          are made.  */\n       if (object)\n \t{"}, {"sha": "f72a80258b3230113b18efbc935fbb292a3fbc0e", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1961,7 +1961,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n      we may want to adjust the cost of that register class to -1.\n \n      Avoid the adjustment if the source does not die to avoid stressing of\n-     register allocator by preferrencing two colliding registers into single\n+     register allocator by preferencing two colliding registers into single\n      class.\n \n      Also avoid the adjustment if a copy between registers of the class"}, {"sha": "20587ac27b2da3d36fb2984561f21a289f23f6d0", "filename": "gcc/regs.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,7 @@\n /* Define per-register tables for data flow info and register allocation.\n    Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   1999, 2000, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -129,7 +130,7 @@ extern size_t reg_info_p_size;\n \n #define REG_FREQ(N) (reg_info_p[N].freq)\n \n-/* The weights for each insn varries from 0 to REG_FREQ_BASE.\n+/* The weights for each insn varies from 0 to REG_FREQ_BASE.\n    This constant does not need to be high, as in infrequently executed\n    regions we want to count instructions equivalently to optimize for\n    size instead of speed.  */"}, {"sha": "9ab01375a9109060b8c9349fd36d30f3fb99388c", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Search an insn for pseudo regs that must be in hard regs and are not.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -988,7 +988,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      we can't handle it here because CONST_INT does not indicate a mode.\n \n      Similarly, we must reload the inside expression if we have a\n-     STRICT_LOW_PART (presumably, in == out in the cas).\n+     STRICT_LOW_PART (presumably, in == out in this case).\n \n      Also reload the inner expression if it does not require a secondary\n      reload but the SUBREG does."}, {"sha": "f5558005c9acf9527e74aac52dc1dd6d6b07bfdb", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -64,7 +64,7 @@ location_for_asm (const_rtx insn)\n   return loc;\n }\n \n-/* Report a diagnostic MESSAGE (an errror or a WARNING) at the line number\n+/* Report a diagnostic MESSAGE (an error or a WARNING) at the line number\n    of the insn INSN.  This is used only when INSN is an `asm' with operands,\n    and each ASM_OPERANDS records its own source file and line.  */\n static void"}, {"sha": "cf58c348489f679c6315b3f752e739d526e644cd", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -841,7 +841,7 @@ reg_set_p (const_rtx reg, const_rtx insn)\n \n /* Similar to reg_set_between_p, but check all registers in X.  Return 0\n    only if none of them are modified between START and END.  Return 1 if\n-   X contains a MEM; this routine does usememory aliasing.  */\n+   X contains a MEM; this routine does use memory aliasing.  */\n \n int\n modified_between_p (const_rtx x, const_rtx start, const_rtx end)\n@@ -1124,7 +1124,7 @@ noop_move_p (const_rtx insn)\n     return 0;\n \n   /* For now treat an insn with a REG_RETVAL note as a\n-     a special insn which should not be considered a no-op.  */\n+     special insn which should not be considered a no-op.  */\n   if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n     return 0;\n "}, {"sha": "0a1b1af9647fa7b43d591eee3ac264776fc5f47c", "filename": "gcc/scan.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* scan.h - Utility declarations for scan-decls and fix-header programs.\n-   Copyright (C) 1993, 1998, 1999, 2003, 2004, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1998, 1999, 2003, 2004, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by the\n@@ -65,7 +66,7 @@ extern int scan_decls (struct cpp_reader *, int, char **);\n #define INT_TOKEN 303\n extern int get_token (FILE *, sstring *);\n \n-/* Current file and line numer, taking #-directives into account */\n+/* Current file and line number, taking #-directives into account */\n extern int source_lineno;\n extern sstring source_filename;\n /* Current physical line number */"}, {"sha": "ca090dea4dada5de74511bf711d09e66202de512", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n@@ -1566,7 +1566,7 @@ check_live_1 (int src, rtx x)\n \t\t  int t = bitmap_bit_p (&not_in_df, b->index);\n \n \t\t  /* We can have split blocks, that were recently generated.\n-\t\t     such blocks are always outside current region.  */\n+\t\t     Such blocks are always outside current region.  */\n \t\t  gcc_assert (!t || (CONTAINING_RGN (b->index)\n \t\t\t\t     != CONTAINING_RGN (BB_TO_BLOCK (src))));\n \n@@ -1753,11 +1753,11 @@ find_conditional_protection (rtx insn, int load_insn_bb)\n \n /* Returns 1 if the same insn1 that participates in the computation\n    of load_insn's address is feeding a conditional branch that is\n-   guarding on load_insn. This is true if we find a the two DEF-USE\n+   guarding on load_insn. This is true if we find two DEF-USE\n    chains:\n    insn1 -> ... -> conditional-branch\n    insn1 -> ... -> load_insn,\n-   and if a flow path exist:\n+   and if a flow path exists:\n    insn1 -> ... -> conditional-branch -> ... -> load_insn,\n    and if insn1 is on the path\n    region-entry -> ... -> bb_trg -> ... load_insn."}, {"sha": "6ea9f3ed25ae69a920d7b78c1f47776c9b1d89c6", "filename": "gcc/see.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Sign extension elimination optimization for GNU compiler.\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Leehod Baruch <leehod@il.ibm.com>\n \n This file is part of GCC.\n@@ -1253,7 +1253,7 @@ see_update_leader_extra_info (struct web_entry *first, struct web_entry *second)\n \t}\n       break;\n     default:\n-      /* Unknown patern type.  */\n+      /* Unknown pattern type.  */\n       gcc_unreachable ();\n     }\n \n@@ -1945,7 +1945,7 @@ see_analyze_unmerged_def_local_prop (void **slot, void *b)\n }\n \n \n-/* Analyze the properties of a use extension for the LCM and record anic and\n+/* Analyze the properties of a use extension for the LCM and record any and\n    avail occurrences.\n \n    This is a subroutine of see_analyze_ref_local_prop called"}, {"sha": "2908f082ea3d92540aa311c6a88379716c5ab88a", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Expands front end tree to back end RTL for GCC\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -622,7 +622,7 @@ tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n    STRING is the instruction template.\n    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n    Each output or input has an expression in the TREE_VALUE and\n-   and a tree list in TREE_PURPOSE which in turn contains a constraint\n+   a tree list in TREE_PURPOSE which in turn contains a constraint\n    name in TREE_VALUE (or NULL_TREE) and a constraint string\n    in TREE_PURPOSE.\n    CLOBBERS is a list of STRING_CST nodes each naming a hard register"}, {"sha": "9b87dc5c3096d47c6e15e0cb3f55dd9d5ac97883", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Data structure definitions for a generic GCC target.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify it\n@@ -351,7 +351,7 @@ struct gcc_target\n        second argument is the cost of the dependence as estimated by\n        the scheduler.  The last argument is the distance in cycles\n        between the already scheduled insn (first parameter) and the\n-       the second insn (second parameter).  */\n+       second insn (second parameter).  */\n     bool (* is_costly_dependence) (struct _dep *_dep, int, int);\n \n     /* The following member value is a pointer to a function called"}, {"sha": "1406339a0fb676450876bba31faed0fa842d21c4", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Data flow functions for trees.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -724,7 +725,7 @@ add_referenced_var (tree var)\n       /* Scan DECL_INITIAL for pointer variables as they may contain\n \t address arithmetic referencing the address of other\n \t variables.  \n-\t Even non-constant intializers need to be walked, because\n+\t Even non-constant initializers need to be walked, because\n \t IPA passes might prove that their are invariant later on.  */\n       if (DECL_INITIAL (var)\n \t  /* Initializers of external variables are not useful to the\n@@ -911,7 +912,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t      {\n \t\ttree csize = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \t\t/* We need to adjust maxsize to the whole structure bitsize.\n-\t\t   But we can subtract any constant offset seen sofar,\n+\t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us out of the structure otherwise.  */\n \t\tif (maxsize != -1 && csize && host_integerp (csize, 1))\n \t\t  maxsize = TREE_INT_CST_LOW (csize) - bit_offset;\n@@ -949,7 +950,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t      {\n \t\ttree asize = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \t\t/* We need to adjust maxsize to the whole array bitsize.\n-\t\t   But we can subtract any constant offset seen sofar,\n+\t\t   But we can subtract any constant offset seen so far,\n \t\t   because that would get us outside of the array otherwise.  */\n \t\tif (maxsize != -1 && asize && host_integerp (asize, 1))\n \t\t  maxsize = TREE_INT_CST_LOW (asize) - bit_offset;\n@@ -1060,7 +1061,7 @@ refs_may_alias_p (tree ref1, tree ref2)\n \n   /* If both references are based on different variables, they cannot alias.\n      If both references are based on the same variable, they cannot alias if\n-     if the accesses do not overlap.  */\n+     the accesses do not overlap.  */\n   if (SSA_VAR_P (base1)\n       && SSA_VAR_P (base2))\n     {"}, {"sha": "965acce74906dc15f758927bcf5e194d95132bb8", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Exception handling semantics and decomposition for trees.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -314,7 +315,7 @@ struct leh_tf_state\n   size_t goto_queue_size;\n   size_t goto_queue_active;\n \n-  /* Pointer map to help in searching qoto_queue when it is large.  */\n+  /* Pointer map to help in searching goto_queue when it is large.  */\n   struct pointer_map_t *goto_queue_map;\n \n   /* The set of unique labels seen as entries in the goto queue.  */"}, {"sha": "c84964c1cdd205f9942d8226181ef0425fd2ed9f", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Inline functions for tree-flow.h\n-   Copyright (C) 2001, 2003, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -1463,7 +1464,7 @@ link_use_stmts_after (use_operand_p head, imm_use_iterator *imm)\n \tif (USE_FROM_PTR (use_p) == use)\n \t  last_p = move_use_after_head (use_p, head, last_p);\n     }\n-  /* LInk iter node in after last_p.  */\n+  /* Link iter node in after last_p.  */\n   if (imm->iter_node.prev != NULL)\n     delink_imm_use (&imm->iter_node);\n   link_imm_use_to_list (&(imm->iter_node), last_p);"}, {"sha": "48a6a2366ee5b1b652ff7eb2bcc4c4556c8724da", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -192,7 +192,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  /* By inlining function having uninitialized variable, we might\n \t     extend the lifetime (variable might get reused).  This cause\n \t     ICE in the case we end up extending lifetime of SSA name across\n-\t     abnormal edge, but also increase register presure.\n+\t     abnormal edge, but also increase register pressure.\n \n \t     We simply initialize all uninitialized vars by 0 except for case\n \t     we are inlining to very first BB.  We can avoid this for all\n@@ -1603,7 +1603,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t}\n \n       /* If VAR represents a zero-sized variable, it's possible that the\n-\t assignment statment may result in no gimple statements.  */\n+\t assignment statement may result in no gimple statements.  */\n       if (init_stmt)\n         bsi_insert_after (&bsi, init_stmt, BSI_NEW_STMT);\n       if (gimple_in_ssa_p (cfun))"}, {"sha": "2d0ddb6a5bf71c7c73e9fce3d94f5213d85d2fba", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Rewrite a program in Normal form into SSA.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n@@ -207,7 +207,7 @@ struct ssa_name_info\n   ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n \n   /* Age of this record (so that info_for_ssa_name table can be cleared\n-     quicky); if AGE < CURRENT_INFO_FOR_SSA_NAME_AGE, then the fields\n+     quickly); if AGE < CURRENT_INFO_FOR_SSA_NAME_AGE, then the fields\n      are assumed to be null.  */\n   unsigned age;\n };\n@@ -362,7 +362,7 @@ set_current_def (tree var, tree def)\n }\n \n \n-/* Compute global livein information given the set of blockx where\n+/* Compute global livein information given the set of blocks where\n    an object is locally live at the start of the block (LIVEIN)\n    and the set of blocks where the object is defined (DEF_BLOCKS).\n "}, {"sha": "d15ab80377f43a7c9e0f79f0112aa625277605f7", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Loop distribution.\n-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Georges-Andre Silber <Georges-Andre.Silber@ensmp.fr>\n    and Sebastian Pop <sebastian.pop@amd.com>.\n \n@@ -639,7 +639,7 @@ rdg_flag_vertex (struct graph *rdg, int v, bitmap partition, bitmap loops,\n }\n \n /* Flag in the bitmap PARTITION the vertex V and all its predecessors.\n-   Alse flag their loop number in LOOPS.  */\n+   Also flag their loop number in LOOPS.  */\n \n static void\n rdg_flag_vertex_and_dependent (struct graph *rdg, int v, bitmap partition,"}, {"sha": "562e39a173a476c16a1ac0a48c647998f547d281", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -156,7 +156,7 @@ build_addr (tree exp, tree context)\n \n   /* Building the ADDR_EXPR will compute a set of properties for\n      that ADDR_EXPR.  Those properties are unfortunately context\n-     specific.  ie, they are dependent on CURRENT_FUNCTION_DECL.\n+     specific, i.e., they are dependent on CURRENT_FUNCTION_DECL.\n \n      Temporarily set CURRENT_FUNCTION_DECL to the desired context,\n      build the ADDR_EXPR, then restore CURRENT_FUNCTION_DECL.  That"}, {"sha": "8754432eb301b0c9a83e9c90863f1882111794ef", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -106,7 +106,7 @@ parloop\n ....\n \n \n-  # Storing the the initial value given by the user.  #\n+  # Storing the initial value given by the user.  #\n \n   .paral_data_store.32.sum.27 = 1;\n  \n@@ -885,7 +885,7 @@ add_field_for_name (void **slot, void *data)\n \n /* Callback for htab_traverse.  A local result is the intermediate result \n    computed by a single \n-   thread, or the intial value in case no iteration was executed.\n+   thread, or the initial value in case no iteration was executed.\n    This function creates a phi node reflecting these values.  \n    The phi's result will be stored in NEW_PHI field of the \n    reduction's data structure.  */ \n@@ -1043,7 +1043,7 @@ create_loads_for_reductions (void **slot, void *data)\n \n /* Load the reduction result that was stored in LD_ST_DATA.  \n    REDUCTION_LIST describes the list of reductions that the\n-   loades should be generated for.  */\n+   loads should be generated for.  */\n static void\n create_final_loads_for_reduction (htab_t reduction_list, \n \t\t\t\t  struct clsn_data *ld_st_data)\n@@ -1416,7 +1416,7 @@ canonicalize_loop_ivs (struct loop *loop, htab_t reduction_list, tree nit)\n    exit of the loop.  NIT is the number of iterations of the loop\n    (used to initialize the variables in the duplicated part).\n  \n-   TODO: the common case is that latch of the loop is empty and immediatelly\n+   TODO: the common case is that latch of the loop is empty and immediately\n    follows the loop exit.  In this case, it would be better not to copy the\n    body of the loop, but only move the entry of the loop directly before the\n    exit check and increase the number of iterations of the loop by one.\n@@ -1648,7 +1648,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n \n /* Generates code to execute the iterations of LOOP in N_THREADS threads in\n    parallel.  NITER describes number of iterations of LOOP.  \n-   REDUCTION_LIST describes the reductions existant in the LOOP.  */\n+   REDUCTION_LIST describes the reductions existent in the LOOP.  */\n \n static void\n gen_parallel_loop (struct loop *loop, htab_t reduction_list, \n@@ -1757,7 +1757,7 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n   /* Ensure that the exit condition is the first statement in the loop.  */\n   transform_to_exit_first_loop (loop, reduction_list, nit);\n \n-  /* Generate intializations for reductions.  */\n+  /* Generate initializations for reductions.  */\n   if (htab_elements (reduction_list) > 0)  \n     htab_traverse (reduction_list, initialize_reductions, loop);\n "}, {"sha": "d1f615ad4950084826584bfc1753ac1ea841878f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Definitions for describing one tree-ssa optimization pass.\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Richard Henderson <rth@redhat.com>\n \n This file is part of GCC.\n@@ -142,7 +143,7 @@ struct gimple_opt_pass\n   struct opt_pass pass;\n };\n \n-/* Decription of RTL pass.  */\n+/* Description of RTL pass.  */\n struct rtl_opt_pass\n {\n   struct opt_pass pass;"}, {"sha": "a15e49b575974a305df2d85f0af224e905a4daa6", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -2253,7 +2253,7 @@ print_declaration (pretty_printer *buffer, tree t, int spc, int flags)\n       pp_character (buffer, ')');\n     }\n \n-  /* The initial value of a function serves to determine wether the function\n+  /* The initial value of a function serves to determine whether the function\n      is declared or defined.  So the following does not apply to function\n      nodes.  */\n   if (TREE_CODE (t) != FUNCTION_DECL)"}, {"sha": "9aac154b436ab7210ff6fa884e4fd26ef1870e81", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -65,7 +65,7 @@ static GTY(()) tree ptr_void;\n \n /* Add code:\n    static gcov*\t__gcov_indirect_call_counters; // pointer to actual counter\n-   static void*\t__gcov_indirect_call_callee; // actual callee addres\n+   static void*\t__gcov_indirect_call_callee; // actual callee address\n */\n static void\n tree_init_ic_make_global_vars (void)"}, {"sha": "57fe59b186e5416b2d562be4081d601afb00409f", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Scalar evolution detector.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n    Contributed by Sebastian Pop <s.pop@laposte.net>\n \n This file is part of GCC.\n@@ -2357,7 +2358,7 @@ number_of_latch_executions (struct loop *loop)\n \n /* Returns the number of executions of the exit condition of LOOP,\n    i.e., the number by one higher than number_of_latch_executions.\n-   Note that unline number_of_latch_executions, this number does\n+   Note that unlike number_of_latch_executions, this number does\n    not necessarily fit in the unsigned variant of the type of\n    the control variable -- if the number of iterations is a constant,\n    we return chrec_dont_know if adding one to number_of_latch_executions\n@@ -2843,7 +2844,7 @@ scev_const_prop (void)\n \t and avoided final value elimination if that is the case.  The problem\n \t is that it is hard to evaluate whether the expression is too\n \t expensive, as we do not know what optimization opportunities the\n-\t the elimination of the final value may reveal.  Therefore, we now\n+\t elimination of the final value may reveal.  Therefore, we now\n \t eliminate the final values of induction variables unconditionally.  */\n       if (niter == chrec_dont_know)\n \tcontinue;"}, {"sha": "aea18d5a8264fbb042887b4f6bdd2b99dc319f51", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -357,7 +357,7 @@ decl_can_be_decomposed_p (tree var)\n   /* HACK: if we decompose a va_list_type_node before inlining, then we'll\n      confuse tree-stdarg.c, and we won't be able to figure out which and\n      how many arguments are accessed.  This really should be improved in\n-     tree-stdarg.c, as the decomposition is truely a win.  This could also\n+     tree-stdarg.c, as the decomposition is truly a win.  This could also\n      be fixed if the stdarg pass ran early, but this can't be done until\n      we've aliasing information early too.  See PR 30791.  */\n   if (early_sra\n@@ -2076,7 +2076,7 @@ generate_one_element_ref (struct sra_elt *elt, tree base)\n       {\n \ttree field = elt->element;\n \n-\t/* We can't test elt->in_bitfld_blk here because, when this is\n+\t/* We can't test elt->in_bitfld_block here because, when this is\n \t   called from instantiate_element, we haven't set this field\n \t   yet.  */\n \tif (TREE_CODE (field) == BIT_FIELD_REF)\n@@ -2162,7 +2162,7 @@ sra_build_assignment (tree dst, tree src)\n       var = TREE_OPERAND (src, 0);\n       width = TREE_OPERAND (src, 1);\n       /* The offset needs to be adjusted to a right shift quantity\n-\t depending on the endianess.  */\n+\t depending on the endianness.  */\n       if (BYTES_BIG_ENDIAN)\n \t{\n \t  tree tmp = size_binop (PLUS_EXPR, width, TREE_OPERAND (src, 2));"}, {"sha": "bf95258ed288f8fe83e22bb62a166d22ac6e3464", "filename": "gcc/tree-ssa-alias-warnings.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-alias-warnings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-alias-warnings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-warnings.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Strict aliasing checks.\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Silvius Rus <rus@google.com>.\n \n    This file is part of GCC.\n@@ -93,7 +93,7 @@\n    -Wstrict-aliasing=3 (default)\n    ===================\n    Should have very few false positives and few false negatives.\n-   Takes care of the common punn+dereference pattern in the front end:\n+   Takes care of the common pun+dereference pattern in the front end:\n    *(int*)&some_float.\n    Takes care of multiple statement cases in the back end,\n    using flow-sensitive points-to information (-O required)."}, {"sha": "d4dfadbced041342836a5c48ca7f0e540a408d42", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Conditional constant propagation pass for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Adapted from original RTL SSA-CCP by Daniel Berlin <dberlin@dberlin.org>\n    Adapted to GIMPLE trees by Diego Novillo <dnovillo@redhat.com>\n@@ -286,7 +286,7 @@ get_symbol_constant_value (tree sym)\n \t    return val;\n \t}\n       /* Variables declared 'const' without an initializer\n-\t have zero as the intializer if they may not be\n+\t have zero as the initializer if they may not be\n \t overridden at link or run time.  */\n       if (!val\n \t  && targetm.binds_local_p (sym)"}, {"sha": "ef28c8eff389907cf20fa529f1fea6d861d12a5b", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Coalesce SSA_NAMES together for the out-of-ssa pass.\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -582,7 +583,7 @@ ssa_conflicts_merge (ssa_conflicts_p ptr, unsigned x, unsigned y)\n     return;\n \n   /* Add a conflict between X and every one Y has.  If the bitmap doesn't\n-     exist, then it has already been coalesced, and we dont need to add a \n+     exist, then it has already been coalesced, and we don't need to add a\n      conflict.  */\n   EXECUTE_IF_SET_IN_BITMAP (ptr->conflicts[y], 0, z, bi)\n     if (ptr->conflicts[z])"}, {"sha": "ea99a021fb14daaba9602f71f2bfe74bee7256bc", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* SSA Dominator optimizations for trees\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n@@ -283,7 +283,7 @@ tree_ssa_dominator_optimize (void)\n   loop_optimizer_init (LOOPS_HAVE_SIMPLE_LATCHES);\n \n   /* We need accurate information regarding back edges in the CFG\n-     for jump threading; this may include back edes that are not part of\n+     for jump threading; this may include back edges that are not part of\n      a single loop.  */\n   mark_dfs_back_edges ();\n       \n@@ -610,7 +610,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n \n   /* If we have an outgoing edge to a block with multiple incoming and\n-     outgoing edges, then we may be able to thread the edge.  ie, we\n+     outgoing edges, then we may be able to thread the edge, i.e., we\n      may be able to statically determine which of the outgoing edges\n      will be traversed when the incoming edge from BB is traversed.  */\n   if (single_succ_p (bb)\n@@ -1360,7 +1360,7 @@ record_edge_info (basic_block bb)\n \t      tree op1 = TREE_OPERAND (cond, 1);\n \n \t      /* Special case comparing booleans against a constant as we\n-\t\t know the value of OP0 on both arms of the branch.  i.e., we\n+\t\t know the value of OP0 on both arms of the branch, i.e., we\n \t\t can record an equivalence for OP0 rather than COND.  */\n \t      if ((TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n \t\t  && TREE_CODE (op0) == SSA_NAME"}, {"sha": "2f7e9238ab15929daacdb6008db0b54ba9e3ef52", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Dead store elimination\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n \n This file is part of GCC.\n \n@@ -207,7 +208,7 @@ memory_address_same (tree store1, tree store2)\n }\n \n /* Return true if there is a stmt that kills the lhs of STMT and is in the\n-   virtual def-use chain of STMT without a use inbetween the kill and STMT.\n+   virtual def-use chain of STMT without a use in between the kill and STMT.\n    Returns false if no such stmt is found.\n    *FIRST_USE_P is set to the first use of the single virtual def of\n    STMT.  *USE_P is set to the vop killed by *USE_STMT.  */\n@@ -691,7 +692,7 @@ execute_simple_dse (void)\n \t\tif (TREE_THIS_VOLATILE (op))\n \t\t  dead = false;\n \n-\t    /* Look for possible occurence var = indirect_ref (...) where\n+\t    /* Look for possible occurrence var = indirect_ref (...) where\n \t       indirect_ref itself is volatile.  */\n \n \t    if (dead && TREE_THIS_VOLATILE (GIMPLE_STMT_OPERAND (stmt, 1)))"}, {"sha": "ac9d8514784045251a34f22d6fdbbf5cbcc182d1", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -845,7 +845,7 @@ forward_propagate_comparison (tree cond, tree stmt)\n \t\t\tTREE_OPERAND (cond, 0), TREE_OPERAND (cond, 1));\n \t}\n       /* We can propagate the condition into X op CST where op\n-\t is EQ_EXRP or NE_EXPR and CST is either one or zero.  */\n+\t is EQ_EXPR or NE_EXPR and CST is either one or zero.  */\n       else if (COMPARISON_CLASS_P (rhs)\n \t       && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n \t       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)"}, {"sha": "c277980ed86968d6e93ec7e20fd519451118f101", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Liveness for SSA trees.\n-   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -46,7 +47,7 @@ static void  verify_live_on_entry (tree_live_info_p);\n    At the end of out-of-ssa, each partition becomes a \"real\" variable and is\n    rewritten as a compiler variable.\n \n-   The var_map datat structure is used to manage these partitions.  It allows\n+   The var_map data structure is used to manage these partitions.  It allows\n    partitions to be combined, and determines which partition belongs to what\n    ssa_name or variable, and vice versa.  */\n "}, {"sha": "4f021609b2f7759e580b17b1413ac4a64f69dc0f", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Routines for liveness in SSA trees.\n-   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod  <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -82,7 +82,7 @@ typedef struct _var_map\n \n /* Partition number of a  non ssa-name variable.  */\n #define VAR_ANN_PARTITION(ann) (ann->partition)\n-/* Index iot the basevar table of a non ssa-name variable.  */\n+/* Index to the basevar table of a non ssa-name variable.  */\n #define VAR_ANN_BASE_INDEX(ann) (ann->base_index)\n \n "}, {"sha": "8a2dd9de3040dabc1b6d1565e8a9a6f7647c140e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Loop invariant motion.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -131,7 +132,7 @@ typedef struct mem_ref\n   unsigned id;\t\t\t/* ID assigned to the memory reference\n \t\t\t\t   (its index in memory_accesses.refs_list)  */\n   hashval_t hash;\t\t/* Its hash value.  */\n-  bitmap stored;\t\t/* The set of loops in that this memory locatio\n+  bitmap stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n   VEC (mem_ref_locs_p, heap) *accesses_in_loop;\n \t\t\t\t/* The locations of the accesses.  Vector\n@@ -570,7 +571,7 @@ outermost_indep_loop (struct loop *outer, struct loop *loop, mem_ref_p ref)\n }\n \n /* If there is a simple load or store to a memory reference in STMT, returns\n-   the location of the memory reference, and sets IS_STORE accoring to whether\n+   the location of the memory reference, and sets IS_STORE according to whether\n    it is a store or load.  Otherwise, returns NULL.  */\n \n static tree *"}, {"sha": "41c3794365690f7b393082970340ece467cb1435", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Induction variable optimizations.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -3047,7 +3048,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t    {\n \t      base = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (\"\"));\n \t      /* ??? We can run into trouble with some backends by presenting\n-\t\t it with symbols which havn't been properly passed through\n+\t\t it with symbols which haven't been properly passed through\n \t\t targetm.encode_section_info.  By setting the local bit, we\n \t\t enhance the probability of things working.  */\n \t      SYMBOL_REF_FLAGS (base) = SYMBOL_FLAG_LOCAL;\n@@ -3978,7 +3979,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n   cost = cost_step + cost_base.cost / AVG_LOOP_NITER (current_loop);\n \n   /* Prefer the original ivs unless we may gain something by replacing it.\n-     The reason is to makee debugging simpler; so this is not relevant for\n+     The reason is to make debugging simpler; so this is not relevant for\n      artificial ivs created by other optimization passes.  */\n   if (cand->pos != IP_ORIGINAL\n       || DECL_ARTIFICIAL (SSA_NAME_VAR (cand->var_before)))"}, {"sha": "74153fd294d1206dc3bd41688b1e8ca40fa0c979", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Functions to determine/estimate number of iterations of a loop.\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    \n This file is part of GCC.\n    \n@@ -2313,7 +2314,7 @@ derive_constant_upper_bound (const_tree val)\n }\n \n /* Records that every statement in LOOP is executed I_BOUND times.\n-   REALISTIC is true if I_BOUND is expected to be close the the real number\n+   REALISTIC is true if I_BOUND is expected to be close to the real number\n    of iterations.  UPPER is true if we are sure the loop iterates at most\n    I_BOUND times.  */\n \n@@ -2342,7 +2343,7 @@ record_niter_bound (struct loop *loop, double_int i_bound, bool realistic,\n /* Records that AT_STMT is executed at most BOUND + 1 times in LOOP.  IS_EXIT\n    is true if the loop is exited immediately after STMT, and this exit\n    is taken at last when the STMT is executed BOUND + 1 times.\n-   REALISTIC is true if BOUND is expected to be close the the real number\n+   REALISTIC is true if BOUND is expected to be close to the real number\n    of iterations.  UPPER is true if we are sure the loop iterates at most\n    BOUND times.  I_BOUND is an unsigned double_int upper estimate on BOUND.  */\n "}, {"sha": "48fafb1a97a70e842e63230b4eecba85ae96fe54", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Array prefetching.\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -156,7 +156,7 @@ along with GCC; see the file COPYING3.  If not see\n /* In some cases we are only able to determine that there is a certain\n    probability that the two accesses hit the same cache line.  In this\n    case, we issue the prefetches for both of them if this probability\n-   is less then (1000 - ACCEPTABLE_MISS_RATE) promile.  */\n+   is less then (1000 - ACCEPTABLE_MISS_RATE) per thousand.  */\n \n #ifndef ACCEPTABLE_MISS_RATE\n #define ACCEPTABLE_MISS_RATE 50"}, {"sha": "93b82d93ab1a44f85e6461bc50fd9482145d9bf3", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Optimization of PHI nodes by converting them into straightline code.\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n \n This file is part of GCC.\n \n@@ -1129,7 +1130,7 @@ name_to_bb_eq (const void *p1, const void *p2)\n   return n1->ssa_name == n2->ssa_name && n1->store == n2->store;\n }\n \n-/* We see a the expression EXP in basic block BB.  If it's an interesting\n+/* We see the expression EXP in basic block BB.  If it's an interesting\n    expression (an INDIRECT_REF through an SSA_NAME) possibly insert the\n    expression into the set NONTRAP or the hash table of seen expressions.\n    STORE is true if this expression is on the LHS, otherwise it's on"}, {"sha": "f408939b07d914be1654e1f4bf27551c40628232", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n \n /* This pass propagates indirect loads through the PHI node for its\n-   address to make the load source possiby non-addressable and to\n+   address to make the load source possibly non-addressable and to\n    allow for PHI optimization to trigger.\n \n    For example the pass changes\n@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n \n      # tmp_1 = PHI <a, b>\n \n-   but also handles more complex cenarios like\n+   but also handles more complex scenarios like\n \n      D.2077_2 = &this_1(D)->a1;\n      ..."}, {"sha": "8e3de703866eb158cfd6c0232fbd2b7948776e08", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* SCC value numbering for trees\n-   Copyright (C) 2006, 2007\n+   Copyright (C) 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@dberlin.org>\n \n@@ -2009,7 +2009,7 @@ extract_and_process_scc_for_name (tree name)\n    Execution of this algorithm relies on the fact that the SCC's are\n    popped off the stack in topological order.\n    Returns true if successful, false if we stopped processing SCC's due\n-   to ressource constraints.  */\n+   to resource constraints.  */\n \n static bool\n DFS (tree name)\n@@ -2238,7 +2238,7 @@ free_scc_vn (void)\n }\n \n /* Do SCCVN.  Returns true if it finished, false if we bailed out\n-   due to ressource constraints.  */\n+   due to resource constraints.  */\n \n bool\n run_scc_vn (bool may_insert_arg)"}, {"sha": "a93001a985b6ce3308bb95596a8cc2f25bd372fa", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Routines for performing Temporary Expression Replacement (TER) in SSA trees.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n    Contributed by Andrew MacLeod  <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -58,7 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n    v_9 = (b_5 + 6) * (C * 10)\n \n    which will then have the ssa_name assigned to regular variables, and the\n-   resulting code which will be passed ot the expander looks something like:\n+   resulting code which will be passed to the expander looks something like:\n \n    v = (b + 6) * (C * 10)\n \n@@ -70,7 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n    Although SSA_NAMES themselves don't change, this pass is performed after \n    coalescing has coalesced different SSA_NAMES together, so there could be a \n    definition of an SSA_NAME which is coalesced with a use that causes a\n-   problem.  ie\n+   problem, i.e.,\n    \n    PHI b_5 = <b_8(2), b_14(1)>\n    <...>\n@@ -95,8 +96,8 @@ along with GCC; see the file COPYING3.  If not see\n    EXPR_DECL_UID bitmap is allocated and set to the base variable UID of the \n    def and any uses in the expression.  non-NULL means the expression is being \n    tracked.  The UID's themselves are used to prevent TER substitution into\n-   accumulating sequences.\n-   ie\n+   accumulating sequences, i.e.,\n+\n    x = x + y\n    x = x + z\n    x = x + w\n@@ -124,7 +125,7 @@ along with GCC; see the file COPYING3.  If not see\n    a block to clear out the KILL_LIST bitmaps at the end of each block.\n \n    NEW_REPLACEABLE_DEPENDENCIES is used as a temporary place to store \n-   dependencies which will be reused by the current definition. ALl the uses\n+   dependencies which will be reused by the current definition. All the uses\n    on an expression are processed before anything else is done. If a use is\n    determined to be a replaceable expression AND the current stmt is also going\n    to be replaceable, all the dependencies of this replaceable use will be\n@@ -137,8 +138,8 @@ along with GCC; see the file COPYING3.  If not see\n \n    a_2's expression 'b_5 + 6' is determined to be replaceable at the use \n    location. It is dependent on the partition 'b_5' is in. This is cached into\n-   the NEW_REPLACEABLE_DEPENDENCIES bitmap. and when v_8 is examined for\n-   replaceablility, it is a candidate, and it is dependent on the partition \n+   the NEW_REPLACEABLE_DEPENDENCIES bitmap, and when v_8 is examined for\n+   replaceability, it is a candidate, and it is dependent on the partition\n    b_5 is in *NOT* a_2, as well as c_4's partition.\n \n    if v_8 is also replaceable:\n@@ -520,7 +521,7 @@ kill_virtual_exprs (temp_expr_table_p tab)\n \n \n /* Mark the expression associated with VAR as replaceable, and enter\n-   the defining stmt into the partition_dependencies table TAB.  if\n+   the defining stmt into the partition_dependencies table TAB.  If\n    MORE_REPLACING is true, accumulate the pending partition dependencies.  */\n \n static void"}, {"sha": "54f87afaf687ca4d2da53a487c526025b43bb6b6", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Thread edges through blocks and update the control flow and SSA graphs.\n-   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n+   Inc.\n \n This file is part of GCC.\n \n@@ -71,7 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n      7. Put the duplicated resources in B and all the B' blocks into SSA form.\n \n    Note that block duplication can be minimized by first collecting the\n-   the set of unique destination blocks that the incoming edges should\n+   set of unique destination blocks that the incoming edges should\n    be threaded to.  Block duplication can be further minimized by using\n    B instead of creating B' for one destination if all edges into B are\n    going to be threaded to a successor of B.\n@@ -1089,7 +1090,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n    threading opportunities discovered by a pass and update the CFG\n    and SSA form all at once.\n \n-   E is the edge we can thread, E2 is the new target edge.  ie, we\n+   E is the edge we can thread, E2 is the new target edge, i.e., we\n    are effectively recording that E->dest can be changed to E2->dest\n    after fixing the SSA graph.  */\n "}, {"sha": "8e6ea4cff7a960ff61bf6cc7778b50a29e0429e4", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Miscellaneous SSA utility functions.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -129,7 +130,7 @@ redirect_edge_var_map_dup (edge newe, edge olde)\n }\n \n \n-/* Return the varable mappings for a given edge.  If there is none, return\n+/* Return the variable mappings for a given edge.  If there is none, return\n    NULL.  */\n \n edge_var_map_vector"}, {"sha": "9f2640d09d6f5f733308dc91bf37db9592df7342", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Analysis Utilities for Loop Vectorization.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -509,7 +510,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t      /* Groups of strided accesses whose size is not a power of 2 are \n \t\t not vectorizable yet using loop-vectorization. Therefore, if \n \t\t this stmt feeds non-SLP-able stmts (i.e., this stmt has to be \n-\t\t both SLPed and loop-based vectorzed), the loop cannot be \n+\t\t both SLPed and loop-based vectorized), the loop cannot be\n \t\t vectorized.  */\n \t      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n \t\t  && exact_log2 (DR_GROUP_SIZE (vinfo_for_stmt (\n@@ -690,7 +691,7 @@ exist_non_indexing_operands_for_use_p (tree use, tree stmt)\n /* Function vect_analyze_scalar_cycles_1.\n \n    Examine the cross iteration def-use cycles of scalar variables\n-   in LOOP. LOOP_VINFO represents the loop that is noe being\n+   in LOOP. LOOP_VINFO represents the loop that is now being\n    considered for vectorization (can be LOOP, or an outer-loop\n    enclosing LOOP).  */\n \n@@ -3542,8 +3543,8 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n    Inputs:\n    - a USE in STMT in a loop represented by LOOP_VINFO\n    - LIVE_P, RELEVANT - enum values to be set in the STMT_VINFO of the stmt \n-     that defined USE. This is dont by calling mark_relevant and passing it\n-     the WORKLIST (to add DEF_STMT to the WORKlist in case itis relevant). \n+     that defined USE. This is done by calling mark_relevant and passing it\n+     the WORKLIST (to add DEF_STMT to the WORKLIST in case it is relevant).\n \n    Outputs:\n    Generally, LIVE_P and RELEVANT are used to define the liveness and"}, {"sha": "450af302403ce1ca8206f043a4c237c1693c15bb", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -216,7 +216,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   /* Add additional cost for the peeled instructions in prologue and epilogue\n      loop.\n \n-     FORNOW: If we dont know the value of peel_iters for prologue or epilogue\n+     FORNOW: If we don't know the value of peel_iters for prologue or epilogue\n      at compile-time - we assume it's vf/2 (the worst would be vf-1).\n \n      TODO: Build an expression that represents peel_iters for prologue and\n@@ -332,7 +332,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      branches.\n \n      TODO: The back end may reorder the BBS's differently and reverse\n-     conditions/branch directions.  Change the stimates below to\n+     conditions/branch directions.  Change the estimates below to\n      something more reasonable.  */\n \n   if (runtime_test)\n@@ -1392,15 +1392,15 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n      created vectors. It is greater than 1 if unrolling is performed. \n \n      For example, we have two scalar operands, s1 and s2 (e.g., group of\n-     strided accesses of size two), while NUINTS is four (i.e., four scalars\n+     strided accesses of size two), while NUNITS is four (i.e., four scalars\n      of this type can be packed in a vector). The output vector will contain\n      two copies of each scalar operand: {s1, s2, s1, s2}. (NUMBER_OF_COPIES\n      will be 2).\n \n      If GROUP_SIZE > NUNITS, the scalars will be split into several vectors \n      containing the operands.\n \n-     For example, NUINTS is four as before, and the group size is 8 \n+     For example, NUNITS is four as before, and the group size is 8\n      (s1, s2, ..., s8). We will create two vectors {s1, s2, s3, s4} and\n      {s5, s6, s7, s8}.  */\n     \n@@ -4481,7 +4481,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n \n       /* Arguments are ready. Create the new vector stmt.  We are creating \n          two vector defs because the widened result does not fit in one vector.\n-         The vectorized stmt can be expressed as a call to a taregt builtin,\n+         The vectorized stmt can be expressed as a call to a target builtin,\n          or a using a tree-code.  */\n       /* Generate first half of the widened result:  */\n       new_stmt = vect_gen_widened_results_half (code1, vectype_out, decl1, \n@@ -6199,7 +6199,7 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_then_clause = vect_get_vec_def_for_operand (then_clause, stmt, NULL);\n   vec_else_clause = vect_get_vec_def_for_operand (else_clause, stmt, NULL);\n \n-  /* Arguments are ready. create the new vector stmt.  */\n+  /* Arguments are ready. Create the new vector stmt.  */\n   vec_compare = build2 (TREE_CODE (cond_expr), vectype, \n \t\t\tvec_cond_lhs, vec_cond_rhs);\n   vec_cond_expr = build3 (VEC_COND_EXPR, vectype, "}, {"sha": "be93e02457691de5966123e978b4f30fb50c3af5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -396,7 +397,7 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n    I.E., the overall structure is:\n \n         loop1_preheader_bb:\n-                guard1 (goto loop1/merg1_bb)\n+                guard1 (goto loop1/merge1_bb)\n         loop1\n         loop1_exit_bb:\n                 guard2 (goto merge1_bb/merge2_bb)\n@@ -463,7 +464,7 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n    In the context of the overall structure, we have:\n \n         loop1_preheader_bb: \n-                guard1 (goto loop1/merg1_bb)\n+                guard1 (goto loop1/merge1_bb)\n LOOP->  loop1\n         loop1_exit_bb:\n                 guard2 (goto merge1_bb/merge2_bb)\n@@ -506,7 +507,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n     {\n       /* Virtual phi; Mark it for renaming. We actually want to call\n \t mar_sym_for_renaming, but since all ssa renaming datastructures\n-\t are going to be freed before we get to call ssa_upate, we just\n+\t are going to be freed before we get to call ssa_update, we just\n \t record this name for now in a bitmap, and will mark it for\n \t renaming later.  */\n       name = PHI_RESULT (orig_phi);\n@@ -590,7 +591,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n    In the context of the overall structure, we have:\n \n         loop1_preheader_bb: \n-                guard1 (goto loop1/merg1_bb)\n+                guard1 (goto loop1/merge1_bb)\n         loop1\n         loop1_exit_bb: \n                 guard2 (goto merge1_bb/merge2_bb)\n@@ -979,13 +980,13 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n   basic_block loop1_entry_bb = loop_preheader_edge (first_loop)->src;\n \n   /* A guard that controls whether the second_loop is to be executed or skipped\n-     is placed in first_loop->exit.  first_loopt->exit therefore has two\n+     is placed in first_loop->exit.  first_loop->exit therefore has two\n      successors - one is the preheader of second_loop, and the other is a bb\n      after second_loop.\n    */\n   gcc_assert (EDGE_COUNT (loop1_exit_bb->succs) == 2);\n    \n-  /* 1. Verify that one of the successors of first_loopt->exit is the preheader\n+  /* 1. Verify that one of the successors of first_loop->exit is the preheader\n         of second_loop.  */\n    \n   /* The preheader of new_loop is expected to have two predecessors:\n@@ -997,7 +998,7 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n                || (EDGE_PRED (loop2_entry_bb, 1)->src ==  loop1_exit_bb\n                    && EDGE_PRED (loop2_entry_bb, 0)->src == loop1_entry_bb)));\n   \n-  /* Verify that the other successor of first_loopt->exit is after the\n+  /* Verify that the other successor of first_loop->exit is after the\n      second_loop.  */\n   /* TODO */\n }\n@@ -1101,10 +1102,10 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n         is false, the caller of this function may want to take care of this\n         (this can be useful if we don't want new stmts added to first-loop).\n    - TH: cost model profitability threshold of iterations for vectorization.\n-   - CHECK_PROFITABILITY: specify whether cost model check has not occured\n+   - CHECK_PROFITABILITY: specify whether cost model check has not occurred\n                           during versioning and hence needs to occur during\n \t\t\t  prologue generation or whether cost model check \n-\t\t\t  has not occured during prologue generation and hence\n+\t\t\t  has not occurred during prologue generation and hence\n \t\t\t  needs to occur during epilogue generation.\n \t    \n \n@@ -1200,7 +1201,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   /* 2.  Add the guard code in one of the following ways:\n \n      2.a Add the guard that controls whether the first loop is executed.\n-         This occurs when this function is invoked for prologue or epilogiue\n+         This occurs when this function is invoked for prologue or epilogue\n \t generation and when the cost model check can be done at compile time.\n \n          Resulting CFG would be:\n@@ -2120,7 +2121,7 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n   /* The result of a vectorized widening operation usually requires two vectors\n      (because the widened results do not fit int one vector). The generated \n      vector results would normally be expected to be generated in the same \n-     order as in the original scalar computation. i.e. if 8 results are \n+     order as in the original scalar computation, i.e. if 8 results are\n      generated in each vector iteration, they are to be organized as follows:\n         vect1: [res1,res2,res3,res4], vect2: [res5,res6,res7,res8]. \n \n@@ -2132,7 +2133,7 @@ supportable_widening_operation (enum tree_code code, tree stmt, tree vectype,\n      of {mult_even,mult_odd} generate the following vectors:\n         vect1: [res1,res3,res5,res7], vect2: [res2,res4,res6,res8].\n \n-     When vectorizaing outer-loops, we execute the inner-loop sequentially\n+     When vectorizing outer-loops, we execute the inner-loop sequentially\n      (each vectorized inner-loop iteration contributes to VF outer-loop \n      iterations in parallel). We therefore don't allow to change the order \n      of the computation in the inner-loop during outer-loop vectorization.  */\n@@ -2493,7 +2494,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, tree phi)\n      computation.  This may change the behavior of the program in some\n      cases, so we need to check that this is ok.  One exception is when \n      vectorizing an outer-loop: the inner-loop is executed sequentially,\n-     and therefore vectorizing reductions in the inner-loop durint \n+     and therefore vectorizing reductions in the inner-loop during\n      outer-loop vectorization is safe.  */\n \n   /* CHECKME: check for !flag_finite_math_only too?  */"}, {"sha": "4960ac5aea34f14ce7a6475fc8d88b1e90c537f7", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Value Numbering routines for tree expressions.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n    Contributed by Daniel Berlin <dan@dberlin.org>, Steven Bosscher\n    <stevenb@suse.de> and Diego Novillo <dnovillo@redhat.com>\n \n@@ -211,7 +212,7 @@ vn_add (tree expr, tree val)\n     add_to_value (val, expr);\n }\n \n-/* Insert EXPR into the value numbering tables.  with value VAL, and\n+/* Insert EXPR into the value numbering tables with value VAL, and\n    add expression EXPR to the value set for value VAL.  VUSES\n    represents the virtual use operands associated with EXPR.  It is\n    used when computing a hash value for EXPR.  */"}, {"sha": "404531f45042dd65a517420289390e4b893bb750", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Support routines for Value Range Propagation (VRP).\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>.\n \n This file is part of GCC.\n@@ -1585,7 +1585,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t\t3a. If the high limit of the VR_ANTI_RANGE resides\n \t\t    within the VR_RANGE, then the result is a new\n \t\t    VR_RANGE starting at the high limit of the\n-\t\t    the VR_ANTI_RANGE + 1 and extending to the\n+\t\t    VR_ANTI_RANGE + 1 and extending to the\n \t\t    high limit of the original VR_RANGE.\n \n \t\t3b. If the low limit of the VR_ANTI_RANGE resides\n@@ -6440,7 +6440,7 @@ simplify_stmt_for_jump_threading (tree stmt, tree within_stmt)\n }\n \n /* Blocks which have more than one predecessor and more than\n-   one successor present jump threading opportunities.  ie,\n+   one successor present jump threading opportunities, i.e.,\n    when the block is reached from a specific predecessor, we\n    may be able to determine which of the outgoing edges will\n    be traversed.  When this optimization applies, we are able"}, {"sha": "2d0ddc330738822b4d1d876b85fca183361f1ad2", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -3946,7 +3946,7 @@ merge_dllimport_decl_attributes (tree old, tree new)\n     }\n   else if (DECL_DLLIMPORT_P (old) && !DECL_DLLIMPORT_P (new))\n     {\n-      /* Warn about overriding a symbol that has already been used. eg:\n+      /* Warn about overriding a symbol that has already been used, e.g.:\n            extern int __attribute__ ((dllimport)) foo;\n \t   int* bar () {return &foo;}\n \t   int foo;"}, {"sha": "2c0e9f63d5ba791c7cff2e49238f34e81b78b9fa", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the\n    tree codes used in GCC.\n    Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001, 2004, 2005, \n-   2006, 2007 Free Software Foundation, Inc.\n+   2006, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -942,7 +942,7 @@ DEFTREECODE (VALUE_HANDLE, \"value_handle\", tcc_exceptional, 0)\n \t2- EXPR is a conditional expression and is known to be true.\n \n    Valid and to be expected forms of conditional expressions are\n-   valid GIMPLE condidional expressions (as defined by is_gimple_condexpr)\n+   valid GIMPLE conditional expressions (as defined by is_gimple_condexpr)\n    and conditional expressions with the first operand being a\n    PLUS_EXPR with a variable possibly wrapped in a NOP_EXPR first\n    operand and an integer constant second operand.\n@@ -1096,7 +1096,7 @@ DEFTREECODE (REDUC_MAX_EXPR, \"reduc_max_expr\", tcc_unary, 1)\n DEFTREECODE (REDUC_MIN_EXPR, \"reduc_min_expr\", tcc_unary, 1)\n DEFTREECODE (REDUC_PLUS_EXPR, \"reduc_plus_expr\", tcc_unary, 1)\n \n-/* Widenning dot-product.\n+/* Widening dot-product.\n    The first two arguments are of type t1.\n    The third argument and the result are of type t2, such that t2 is at least\n    twice the size of t1. DOT_PROD_EXPR(arg1,arg2,arg3) is equivalent to:\n@@ -1107,7 +1107,7 @@ DEFTREECODE (REDUC_PLUS_EXPR, \"reduc_plus_expr\", tcc_unary, 1)\n         arg3 = WIDEN_SUM_EXPR (tmp, arg3);\t\t */\n DEFTREECODE (DOT_PROD_EXPR, \"dot_prod_expr\", tcc_expression, 3)\n \n-/* Widenning summation.\n+/* Widening summation.\n    The first argument is of type t1.\n    The second argument is of type t2, such that t2 is at least twice\n    the size of t1. The type of the entire expression is also t2.\n@@ -1116,7 +1116,7 @@ DEFTREECODE (DOT_PROD_EXPR, \"dot_prod_expr\", tcc_expression, 3)\n    with the second argument.  */\n DEFTREECODE (WIDEN_SUM_EXPR, \"widen_sum_expr\", tcc_binary, 2)\n    \n-/* Widenning multiplication. \n+/* Widening multiplication.\n    The two arguments are of type t1.\n    The result is of type t2, such that t2 is at least twice\n    the size of t1. WIDEN_MULT_EXPR is equivalent to first widening (promoting)"}, {"sha": "c10cc0380e71ddfa06f69f88db9639c8baea8f38", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -174,7 +174,7 @@ extern const enum tree_code_class tree_code_type[];\n #define IS_EXPR_CODE_CLASS(CLASS)\\\n \t((CLASS) >= tcc_reference && (CLASS) <= tcc_expression)\n \n-/* Returns nonzer iff CLASS is a GIMPLE statement.  */\n+/* Returns nonzero iff CLASS is a GIMPLE statement.  */\n \n #define IS_GIMPLE_STMT_CODE_CLASS(CLASS) ((CLASS) == tcc_gimple_stmt)\n \n@@ -3175,7 +3175,7 @@ extern void decl_debug_expr_insert (tree, tree);\n #define SET_DECL_DEBUG_EXPR(NODE, VAL) \\\n   (decl_debug_expr_insert (VAR_DECL_CHECK (NODE), VAL))\n \n-/* An initializationp priority.  */\n+/* An initialization priority.  */\n typedef unsigned short priority_type;\n \n extern priority_type decl_init_priority_lookup (tree);"}, {"sha": "674976f2e564f679781c5039c99064fdb4e7b49f", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines needed for unwinding stack frames for exception handling.  */\n-/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n    Free Software Foundation, Inc.\n    Contributed by Jason Merrill <jason@cygnus.com>.\n \n@@ -947,7 +947,7 @@ search_object (struct object* ob, void *pc)\n     }\n   else\n     {\n-      /* Long slow labourious linear search, cos we've no memory.  */\n+      /* Long slow laborious linear search, cos we've no memory.  */\n       if (ob->s.b.from_array)\n \t{\n \t  fde **p;"}, {"sha": "e0ab71c412f6625f8091dd623f989fa4e69ca1ae", "filename": "gcc/unwind.inc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Funwind.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Funwind.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.inc?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,5 @@\n /* Exception handling and frame unwind runtime interface routines. -*- C -*-\n-   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003, 2008 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -108,7 +108,7 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)\n \treturn _URC_END_OF_STACK;\n \n       if (code != _URC_NO_REASON)\n-\t/* Some error encountered.  Ususally the unwinder doesn't\n+\t/* Some error encountered.  Usually the unwinder doesn't\n \t   diagnose these and merely crashes.  */\n \treturn _URC_FATAL_PHASE1_ERROR;\n "}, {"sha": "f1330def6889424c12b94b4892ef0af24b21c359", "filename": "gcc/value-prof.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,5 +1,6 @@\n /* Transformations based on profile information for values.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n+   Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1062,7 +1063,7 @@ find_func_by_pid (int\tpid)\n \n /* Do transformation\n \n-  if (actual_callee_addres == addres_of_most_common_function/method)\n+  if (actual_callee_address == address_of_most_common_function/method)\n     do direct call\n   else\n     old call"}, {"sha": "751e44cc0d465dd3bfdb5bcef0ce6f3f5974dd4f", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa10beec52789c84fe0c22a16fe73c895b275b1e/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=fa10beec52789c84fe0c22a16fe73c895b275b1e", "patch": "@@ -1,6 +1,6 @@\n /* Output VMS debug format symbol table information from GCC.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (rupp@gnat.com).\n    Updated by Bernard W. Giroud (bgiroud@users.sourceforge.net).\n@@ -125,7 +125,7 @@ static unsigned int func_table_in_use;\n static vms_func_ref func_table;\n \n /* Local pointer to the name of the main input file.  Initialized in\n-   avmdbgout_init.  */\n+   vmsdbgout_init.  */\n static const char *primary_filename;\n \n static char *module_producer;"}]}