{"sha": "8ab4b484153031c407b7d8c760b6a2605da1199a", "node_id": "C_kwDOANBUbNoAKDhhYjRiNDg0MTUzMDMxYzQwN2I3ZDhjNzYwYjZhMjYwNWRhMTE5OWE", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-04-08T03:26:46Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-05-13T01:02:48Z"}, "message": "Strip of a vector load which is only used partially.\n\nOptimize\n\n  _4 = VEC_PERM_EXPR <_1, _1, { 4, 5, 6, 7, 4, 5, 6, 7 }>;\n  _5 = BIT_FIELD_REF <_4, 128, 0>;\n\nto\n\n  _5 = BIT_FIELD_REF <_1, 128, 128>;\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102583\n\t* tree-ssa-forwprop.cc (simplify_bitfield_ref): Extended to a\n\tcontiguous stride in the VEC_PERM_EXPR.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr102583.c: New test.\n\t* gcc.target/i386/pr92645-2.c: Adjust testcase.\n\t* gcc.target/i386/pr92645-3.c: Ditto.", "tree": {"sha": "deaeccc923e04d132dfd3ba6edb77a0fb8c92816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deaeccc923e04d132dfd3ba6edb77a0fb8c92816"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ab4b484153031c407b7d8c760b6a2605da1199a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab4b484153031c407b7d8c760b6a2605da1199a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ab4b484153031c407b7d8c760b6a2605da1199a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab4b484153031c407b7d8c760b6a2605da1199a/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49ace834ab15c1614a96a81005304eae0f2f525e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ace834ab15c1614a96a81005304eae0f2f525e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ace834ab15c1614a96a81005304eae0f2f525e"}], "stats": {"total": 125, "additions": 93, "deletions": 32}, "files": [{"sha": "4ef2f296d0c9b9dfa8af48fed41688929e27f345", "filename": "gcc/testsuite/gcc.target/i386/pr102583.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102583.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102583.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102583.c?ref=8ab4b484153031c407b7d8c760b6a2605da1199a", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512f -O2\" } */\n+/* { dg-final { scan-assembler-times {(?n)vcvtdq2ps[ \\t]+32\\(%.*%ymm} 1 } } */\n+/* { dg-final { scan-assembler-times {(?n)vcvtdq2ps[ \\t]+16\\(%.*%xmm} 1 } } */\n+/* { dg-final { scan-assembler-times {(?n)vmovq[ \\t]+16\\(%.*%xmm} 1 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not {(?n)vpermd[ \\t]+.*%zmm} } } */\n+\n+typedef int v16si __attribute__((vector_size(64)));\n+typedef float v8sf __attribute__((vector_size(32)));\n+typedef float v4sf __attribute__((vector_size(16)));\n+typedef float v2sf __attribute__((vector_size(8)));\n+\n+v8sf part (v16si *srcp)\n+{\n+  v16si src = *srcp;\n+  return (v8sf) { (float)src[8], (float) src[9], (float)src[10], (float)src[11],\n+      (float)src[12], (float)src[13], (float)src[14], (float)src[15] };\n+}\n+\n+v4sf part1 (v16si *srcp)\n+{\n+  v16si src = *srcp;\n+  return (v4sf) { (float)src[4], (float)src[5], (float)src[6], (float)src[7] };\n+}\n+\n+v2sf part2 (v16si *srcp)\n+{\n+  v16si src = *srcp;\n+  return (v2sf) { (float)src[4], (float)src[5] };\n+}"}, {"sha": "f0608de938a73da9b8594983f2332b8bab12d57b", "filename": "gcc/testsuite/gcc.target/i386/pr92645-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-2.c?ref=8ab4b484153031c407b7d8c760b6a2605da1199a", "patch": "@@ -29,6 +29,6 @@ void odd (v2si *dst, v4si *srcp)\n }\n \n /* { dg-final { scan-tree-dump-times \"BIT_FIELD_REF\" 4 \"cddce1\" } } */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 3 \"cddce1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 3 \"cddce1\" { xfail *-*-* } } } */\n /* Ideally highpart extraction would elide the permutation as well.  */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"cddce1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"cddce1\" } } */"}, {"sha": "691011195c92c1ca6d7f8be2f0e0a58b291a0521", "filename": "gcc/testsuite/gcc.target/i386/pr92645-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-3.c?ref=8ab4b484153031c407b7d8c760b6a2605da1199a", "patch": "@@ -32,6 +32,6 @@ void odd (v4sf *dst, v8si *srcp)\n /* Four conversions, on the smaller vector type, to not convert excess\n    elements.  */\n /* { dg-final { scan-tree-dump-times \" = \\\\\\(vector\\\\\\(4\\\\\\) float\\\\\\)\" 4 \"cddce1\" } } */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 3 \"cddce1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 3 \"cddce1\" { xfail *-*-* } } } */\n /* Ideally highpart extraction would elide the VEC_PERM_EXPR as well.  */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"cddce1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"cddce1\" } } */"}, {"sha": "c5b2a4f9f42d1cea0e42f16e30a9bbe2403faabe", "filename": "gcc/tree-ssa-forwprop.cc", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftree-ssa-forwprop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ab4b484153031c407b7d8c760b6a2605da1199a/gcc%2Ftree-ssa-forwprop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.cc?ref=8ab4b484153031c407b7d8c760b6a2605da1199a", "patch": "@@ -2334,8 +2334,10 @@ simplify_bitfield_ref (gimple_stmt_iterator *gsi)\n   gimple *stmt = gsi_stmt (*gsi);\n   gimple *def_stmt;\n   tree op, op0, op1;\n-  tree elem_type;\n-  unsigned idx, size;\n+  tree elem_type, type;\n+  tree p, m, tem;\n+  unsigned HOST_WIDE_INT nelts, idx;\n+  poly_uint64 size, elem_size;\n   enum tree_code code;\n \n   op = gimple_assign_rhs1 (stmt);\n@@ -2353,42 +2355,71 @@ simplify_bitfield_ref (gimple_stmt_iterator *gsi)\n   op1 = TREE_OPERAND (op, 1);\n   code = gimple_assign_rhs_code (def_stmt);\n   elem_type = TREE_TYPE (TREE_TYPE (op0));\n-  if (TREE_TYPE (op) != elem_type)\n-    return false;\n+  type = TREE_TYPE (op);\n+  /* Also hanlde vector type.\n+   .i.e.\n+   _7 = VEC_PERM_EXPR <_1, _1, { 2, 3, 2, 3 }>;\n+   _11 = BIT_FIELD_REF <_7, 64, 0>;\n+\n+   to\n \n-  size = TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n+   _11 = BIT_FIELD_REF <_1, 64, 64>.  */\n+\n+  size = tree_to_poly_uint64 (TYPE_SIZE (type));\n   if (maybe_ne (bit_field_size (op), size))\n     return false;\n \n-  if (code == VEC_PERM_EXPR\n-      && constant_multiple_p (bit_field_offset (op), size, &idx))\n+  elem_size = tree_to_poly_uint64 (TYPE_SIZE (elem_type));\n+  if (code != VEC_PERM_EXPR\n+      || !constant_multiple_p (bit_field_offset (op), elem_size, &idx))\n+    return false;\n+\n+  m = gimple_assign_rhs3 (def_stmt);\n+  if (TREE_CODE (m) != VECTOR_CST\n+      || !VECTOR_CST_NELTS (m).is_constant (&nelts))\n+    return false;\n+\n+  /* One element.  */\n+  if (known_eq (size, elem_size))\n+    idx = TREE_INT_CST_LOW (VECTOR_CST_ELT (m, idx));\n+  else\n     {\n-      tree p, m, tem;\n-      unsigned HOST_WIDE_INT nelts;\n-      m = gimple_assign_rhs3 (def_stmt);\n-      if (TREE_CODE (m) != VECTOR_CST\n-\t  || !VECTOR_CST_NELTS (m).is_constant (&nelts))\n+      unsigned HOST_WIDE_INT nelts_op;\n+      if (!constant_multiple_p (size, elem_size, &nelts_op)\n+\t  || !pow2p_hwi (nelts_op))\n \treturn false;\n-      idx = TREE_INT_CST_LOW (VECTOR_CST_ELT (m, idx));\n-      idx %= 2 * nelts;\n-      if (idx < nelts)\n-\t{\n-\t  p = gimple_assign_rhs1 (def_stmt);\n-\t}\n-      else\n+      unsigned start = TREE_INT_CST_LOW (vector_cst_elt (m, idx));\n+      unsigned end = TREE_INT_CST_LOW (vector_cst_elt (m, idx + nelts_op - 1));\n+      /* Be in the same vector.  */\n+      if ((start < nelts) != (end < nelts))\n+\treturn false;\n+      for (unsigned HOST_WIDE_INT i = 1; i != nelts_op; i++)\n \t{\n-\t  p = gimple_assign_rhs2 (def_stmt);\n-\t  idx -= nelts;\n+\t  /* Continuous area.  */\n+\t  if (TREE_INT_CST_LOW (vector_cst_elt (m, idx + i)) - 1\n+\t      != TREE_INT_CST_LOW (vector_cst_elt (m, idx + i - 1)))\n+\t    return false;\n \t}\n-      tem = build3 (BIT_FIELD_REF, TREE_TYPE (op),\n-\t\t    unshare_expr (p), op1, bitsize_int (idx * size));\n-      gimple_assign_set_rhs1 (stmt, tem);\n-      fold_stmt (gsi);\n-      update_stmt (gsi_stmt (*gsi));\n-      return true;\n+      /* Alignment not worse than before.  */\n+      if (start % nelts_op)\n+       return false;\n+      idx = start;\n     }\n \n-  return false;\n+  if (idx < nelts)\n+    p = gimple_assign_rhs1 (def_stmt);\n+  else\n+    {\n+      p = gimple_assign_rhs2 (def_stmt);\n+      idx -= nelts;\n+    }\n+\n+  tem = build3 (BIT_FIELD_REF, TREE_TYPE (op),\n+\t\tp, op1, bitsize_int (idx * elem_size));\n+  gimple_assign_set_rhs1 (stmt, tem);\n+  fold_stmt (gsi);\n+  update_stmt (gsi_stmt (*gsi));\n+  return true;\n }\n \n /* Determine whether applying the 2 permutations (mask1 then mask2)"}]}