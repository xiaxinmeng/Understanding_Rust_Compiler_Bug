{"sha": "bfbf933af83d1520667a3f05e7c6e0521645c06b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZiZjkzM2FmODNkMTUyMDY2N2EzZjA1ZTdjNmUwNTIxNjQ1YzA2Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-02T01:41:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-02T01:41:11Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1135", "tree": {"sha": "36c7f3024a90ce2543c91aa90dccccbf8d48517d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36c7f3024a90ce2543c91aa90dccccbf8d48517d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfbf933af83d1520667a3f05e7c6e0521645c06b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfbf933af83d1520667a3f05e7c6e0521645c06b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfbf933af83d1520667a3f05e7c6e0521645c06b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfbf933af83d1520667a3f05e7c6e0521645c06b/comments", "author": null, "committer": null, "parents": [{"sha": "69d6c854c0990cdf355bb7265002795d7a5abcd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d6c854c0990cdf355bb7265002795d7a5abcd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d6c854c0990cdf355bb7265002795d7a5abcd7"}], "stats": {"total": 89, "additions": 44, "deletions": 45}, "files": [{"sha": "310bc4a558530cec21e3641e9640b4604226b8e5", "filename": "gcc/calls.c", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfbf933af83d1520667a3f05e7c6e0521645c06b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfbf933af83d1520667a3f05e7c6e0521645c06b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=bfbf933af83d1520667a3f05e7c6e0521645c06b", "patch": "@@ -1208,22 +1208,11 @@ expand_call (exp, target, ignore)\n \t       highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n       needed = 0;\n \n-      /* The only way the stack pointer can change here is if some arguments\n-\t which are passed in memory are constructed in place in the outgoing\n-\t argument area.  All objects which are constructed in place have\n-\t pass_on_stack == 1 (see store_one_arg ()).\n-\n-\t The test for arguments being constructed on the stack is just an\n-\t optimization: it would be correct but suboptimal to call\n-\t copy_addr_to_reg () unconditionally.  */\n+      /* The address of the outgoing argument list must not be copied to a\n+\t register here, because argblock would be left pointing to the\n+\t wrong place after the call to allocate_dynamic_stack_space below. */\n \n       argblock = virtual_outgoing_args_rtx;\n-      for (i = 0; i < num_actuals; i++)\n-\tif (args[i].pass_on_stack)\n-\t  {\n-\t    argblock = copy_addr_to_reg (argblock);\n-\t    break;\n-\t  }\n \n #else /* not ACCUMULATE_OUTGOING_ARGS */\n       if (inhibit_defer_pop == 0)\n@@ -1258,6 +1247,47 @@ expand_call (exp, target, ignore)\n #endif /* not ACCUMULATE_OUTGOING_ARGS */\n     }\n \n+\n+#ifdef ACCUMULATE_OUTGOING_ARGS\n+  /* The save/restore code in store_one_arg handles all cases except one:\n+     a constructor call (including a C function returning a BLKmode struct)\n+     to initialize an argument.  */\n+  if (stack_arg_under_construction)\n+    {\n+#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n+      rtx push_size = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       reg_parm_stack_space + args_size.constant);\n+#else\n+      rtx push_size = gen_rtx (CONST_INT, VOIDmode, args_size.constant);\n+#endif\n+      if (old_stack_level == 0)\n+\t{\n+\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n+\t  old_pending_adj = pending_stack_adjust;\n+\t  pending_stack_adjust = 0;\n+\t  /* stack_arg_under_construction says whether a stack arg is\n+\t     being constructed at the old stack level.  Pushing the stack\n+\t     gets a clean outgoing argument block.  */\n+\t  old_stack_arg_under_construction = stack_arg_under_construction;\n+\t  stack_arg_under_construction = 0;\n+\t  /* Make a new map for the new argument list.  */\n+\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n+\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n+\t  highest_outgoing_arg_in_use = 0;\n+\t}\n+      allocate_dynamic_stack_space (push_size, 0, BITS_PER_UNIT);\n+    }\n+  /* If argument evaluation might modify the stack pointer, copy the\n+     address of the argument list to a register.  */\n+  for (i = 0; i < num_actuals; i++)\n+    if (args[i].pass_on_stack)\n+      {\n+\targblock = copy_addr_to_reg (argblock);\n+\tbreak;\n+      }\n+#endif\n+\n+\n   /* If we preallocated stack space, compute the address of each argument.\n      We need not ensure it is a valid memory address here; it will be \n      validized when it is used.  */\n@@ -1310,37 +1340,6 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  /* The save/restore code in store_one_arg handles all cases except one:\n-     a constructor call (including a C function returning a BLKmode struct)\n-     to initialize an argument.  */\n-  if (stack_arg_under_construction)\n-    {\n-#if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n-      rtx push_size = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       reg_parm_stack_space + args_size.constant);\n-#else\n-      rtx push_size = gen_rtx (CONST_INT, VOIDmode, args_size.constant);\n-#endif\n-      if (old_stack_level == 0)\n-\t{\n-\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n-\t  old_pending_adj = pending_stack_adjust;\n-\t  pending_stack_adjust = 0;\n-\t  /* stack_arg_under_construction says whether a stack arg is\n-\t     being constructed at the old stack level.  Pushing the stack\n-\t     gets a clean outgoing argument block.  */\n-\t  old_stack_arg_under_construction = stack_arg_under_construction;\n-\t  stack_arg_under_construction = 0;\n-\t  /* Make a new map for the new argument list.  */\n-\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n-\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n-\t  highest_outgoing_arg_in_use = 0;\n-\t}\n-      allocate_dynamic_stack_space (push_size, 0, BITS_PER_UNIT);\n-    }\n-#endif\n-\n   /* Don't try to defer pops if preallocating, not even from the first arg,\n      since ARGBLOCK probably refers to the SP.  */\n   if (argblock)"}]}