{"sha": "aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEwYjQ0NjU5MTJiMmJhZjhhZDhjN2U5ZmI2OGI2ZjYxNjAzNmUxOQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@bitmover.com", "date": "1999-08-27T20:37:06Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-08-27T20:37:06Z"}, "message": "rtl.c: Define CONST_DOUBLE_FORMAT to the appropriate format for a CONST_DOUBLE...\n\n1999-08-27 13:27 -0700  Zack Weinberg  <zack@bitmover.com>\n\n\t* rtl.c: Define CONST_DOUBLE_FORMAT to the appropriate format\n\tfor a CONST_DOUBLE, at compile time.  Initialize rtx_length\n\tand class_narrowest_mode at compile time.  Kill init_rtl.\n\tMark rtx_length, mode_class, mode_size, mode_unit_size,\n\tmode_wider_mode, mode_mask_array, class_narrowest_mode, and\n\trtx_format as const.  Kill all references to EXTRA_CC_MODES or\n\tEXTRA_CC_NAMES.\n\t* rtl.def (CONST_DOUBLE): Use CONST_DOUBLE_FORMAT macro for\n\tformat.\n\t* rtl.h: Declare rtx_length and rtx_format as const.\n\t* machmode.def: Define CC().  Use CC() to define CCmode.  If\n\tEXTRA_CC_MODES is defined, expand it here.\n\t* machmode.h: Declare mode_class, mode_size, mode_unit_size,\n\tmode_wider_mode, mode_mask_array, and class_narrowest_mode as\n\tconst.  Kill all references to EXTRA_CC_MODES.\n\n\t* toplev.c: Don't prototype or call init_rtl.\n\t* optabs.c: Don't call init_mov_optab.\n\t* genemit.c: Don't generate init_mov_optab.  Don't call\n\tinit_rtl.\n\t* gengenrtl.c: Duplicate calculation of CONST_DOUBLE_FORMAT\n\there.\n\t* genattr.c, genattrtab.c, gencodes.c, genconfig.c,\n\tgenextract.c, genflags.c, genopinit.c, genoutput.c, genpeep.c,\n\tgenrecog.c: Don't call init_rtl.\n\n\t* arc.h, arm.h, c4x.h, i386.h, i960.h, m88k.h, pa.h, pdp11.h,\n\trs6000.h, sparc.h: Don't define EXTRA_CC_NAMES.  Use CC() in\n\tdefinition of EXTRA_CC_MODES.\n\n\t* md.texi: Kill ref to EXTRA_CC_NAMES.\n\t* tm.texi: Document new way to define EXTRA_CC_MODES.\n\n\t* genrecog.c: Do not look up the name of a define_split.\n\t(Unrelated bugfix.)\n\nFrom-SVN: r28937", "tree": {"sha": "0f423580e9aa14c0c796b441ff0df89475c8d5e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f423580e9aa14c0c796b441ff0df89475c8d5e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/comments", "author": null, "committer": null, "parents": [{"sha": "b780db794f97d51a956d6eb5f922d5ea0651ab8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b780db794f97d51a956d6eb5f922d5ea0651ab8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b780db794f97d51a956d6eb5f922d5ea0651ab8d"}], "stats": {"total": 429, "additions": 192, "deletions": 237}, "files": [{"sha": "636608ab8de8679fc28616fdcfe3e23c0beb0a82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1,3 +1,41 @@\n+1999-08-27 13:27 -0700  Zack Weinberg  <zack@bitmover.com>\n+\n+\t* rtl.c: Define CONST_DOUBLE_FORMAT to the appropriate format\n+\tfor a CONST_DOUBLE, at compile time.  Initialize rtx_length\n+\tand class_narrowest_mode at compile time.  Kill init_rtl.\n+\tMark rtx_length, mode_class, mode_size, mode_unit_size,\n+\tmode_wider_mode, mode_mask_array, class_narrowest_mode, and\n+\trtx_format as const.  Kill all references to EXTRA_CC_MODES or\n+\tEXTRA_CC_NAMES.\n+\t* rtl.def (CONST_DOUBLE): Use CONST_DOUBLE_FORMAT macro for\n+\tformat.\n+\t* rtl.h: Declare rtx_length and rtx_format as const.\n+\t* machmode.def: Define CC().  Use CC() to define CCmode.  If\n+\tEXTRA_CC_MODES is defined, expand it here.\n+\t* machmode.h: Declare mode_class, mode_size, mode_unit_size,\n+\tmode_wider_mode, mode_mask_array, and class_narrowest_mode as\n+\tconst.  Kill all references to EXTRA_CC_MODES.\n+\n+\t* toplev.c: Don't prototype or call init_rtl.\n+\t* optabs.c: Don't call init_mov_optab.\n+\t* genemit.c: Don't generate init_mov_optab.  Don't call\n+\tinit_rtl.\n+\t* gengenrtl.c: Duplicate calculation of CONST_DOUBLE_FORMAT\n+\there.\n+\t* genattr.c, genattrtab.c, gencodes.c, genconfig.c,\n+\tgenextract.c, genflags.c, genopinit.c, genoutput.c, genpeep.c,\n+\tgenrecog.c: Don't call init_rtl.\n+\n+\t* arc.h, arm.h, c4x.h, i386.h, i960.h, m88k.h, pa.h, pdp11.h,\n+\trs6000.h, sparc.h: Don't define EXTRA_CC_NAMES.  Use CC() in\n+\tdefinition of EXTRA_CC_MODES.\n+\n+\t* md.texi: Kill ref to EXTRA_CC_NAMES.\n+\t* tm.texi: Document new way to define EXTRA_CC_MODES.\n+\n+\t* genrecog.c: Do not look up the name of a define_split.\n+\t(Unrelated bugfix.)\n+\n Fri Aug 27 17:03:42 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/v850/v850.md: Fix typo introduced by previous delta."}, {"sha": "10a163bad9a073892cd575f055c69ad18c3a1191", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1047,9 +1047,9 @@ do { \\\n /* Some insns set all condition code flags, some only set the ZNC flags, and\n    some only set the ZN flags.  */\n \n-#define EXTRA_CC_MODES CCZNCmode, CCZNmode\n-\n-#define EXTRA_CC_NAMES \"CCZNC\", \"CCZN\"\n+#define EXTRA_CC_MODES \\\n+\tCC(CCZNCmode, \"CCZNC\") \\\n+\tCC(CCZNmode, \"CCZN\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */"}, {"sha": "e5c89e78fbfca54ad0bf2bf98a154a2f7c83097a", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1889,14 +1889,23 @@ extern int making_const_table;\n    CC_Zmode should be used if only the Z flag is set correctly\n    CCmode should be used otherwise. */\n \n-#define EXTRA_CC_MODES CC_NOOVmode, CC_Zmode, CC_SWPmode, \\\n-  CCFPmode, CCFPEmode, CC_DNEmode, CC_DEQmode, CC_DLEmode, \\\n-  CC_DLTmode, CC_DGEmode, CC_DGTmode, CC_DLEUmode, CC_DLTUmode, \\\n-  CC_DGEUmode, CC_DGTUmode, CC_Cmode\n-\n-#define EXTRA_CC_NAMES \"CC_NOOV\", \"CC_Z\", \"CC_SWP\", \"CCFP\", \"CCFPE\", \\\n-  \"CC_DNE\", \"CC_DEQ\", \"CC_DLE\", \"CC_DLT\", \"CC_DGE\", \"CC_DGT\", \"CC_DLEU\", \\\n-  \"CC_DLTU\", \"CC_DGEU\", \"CC_DGTU\", \"CC_C\"\n+#define EXTRA_CC_MODES\t\t\\\n+    CC(CC_NOOVmode,  \"CC_NOOV\")\t\\\n+    CC(CC_Zmode,     \"CC_Z\")\t\\\n+    CC(CC_SWPmode,   \"CC_SWP\")\t\\\n+    CC(CCFPmode,     \"CCFP\")\t\\\n+    CC(CCFPEmode,    \"CCFPE\")\t\\\n+    CC(CC_DNEmode,   \"CC_DNE\")\t\\\n+    CC(CC_DEQmode,   \"CC_DEQ\")\t\\\n+    CC(CC_DLEmode,   \"CC_DLE\")\t\\\n+    CC(CC_DLTmode,   \"CC_DLT\")\t\\\n+    CC(CC_DGEmode,   \"CC_DGE\")\t\\\n+    CC(CC_DGTmode,   \"CC_DGT\")\t\\\n+    CC(CC_DLEUmode,  \"CC_DLEU\")\t\\\n+    CC(CC_DLTUmode,  \"CC_DLTU\")\t\\\n+    CC(CC_DGEUmode,  \"CC_DGEU\")\t\\\n+    CC(CC_DGTUmode,  \"CC_DGTU\")\t\\\n+    CC(CC_Cmode,     \"CC_C\")\n \n #define SELECT_CC_MODE(OP,X,Y)  arm_select_cc_mode ((OP), (X), (Y))\n "}, {"sha": "2d019b5304e74cc0a718d06991a23fe623638a78", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1532,11 +1532,7 @@ extern struct rtx_def *c4x_function_arg();\n    load instructions after an add, subtract, neg, abs or multiply.\n    We must emit a compare insn to check the result against 0.  */\n \n-#define EXTRA_CC_MODES CC_NOOVmode\n-\n-/* Define the names for the modes specified above.  */\n-\n-#define EXTRA_CC_NAMES \"CC_NOOV\"\n+#define EXTRA_CC_MODES CC(CC_NOOVmode, \"CC_NOOV\")\n \n /* CC_NOOVmode should be used when the first operand is a PLUS, MINUS, NEG\n    or MULT."}, {"sha": "827d021e5fe879e491619c8990a5ff4e6cee23eb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -2299,10 +2299,7 @@ while (0)\n    For the i386, we need separate modes when floating-point equality\n    comparisons are being done.  */\n \n-#define EXTRA_CC_MODES CCFPEQmode\n-\n-/* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CCFPEQ\"\n+#define EXTRA_CC_MODES CC(CCFPEQmode, \"CCFPEQ\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison."}, {"sha": "e273438ca28d7d523674d657036c2fc343f9f6b8", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1237,10 +1237,9 @@ extern struct rtx_def *gen_compare_reg ();\n \n    Also, signed and unsigned comparisons are distinguished, as\n    are operations which are compatible with chkbit insns.  */\n-#define EXTRA_CC_MODES CC_UNSmode, CC_CHKmode\n-\n-/* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CC_UNS\", \"CC_CHK\"\n+#define EXTRA_CC_MODES\t\t\\\n+    CC(CC_UNSmode, \"CC_UNS\")\t\\\n+    CC(CC_CHKmode, \"CC_CHK\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point, CCFPmode"}, {"sha": "5017d8d901b2f1499dff06f66840c26ad8e10fa0", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1252,9 +1252,7 @@ extern struct rtx_def *m88k_va_arg ();\n \f\n /*** Addressing Modes ***/\n \n-#define EXTRA_CC_MODES CCEVENmode\n-\n-#define EXTRA_CC_NAMES \"CCEVEN\"\n+#define EXTRA_CC_MODES CC(CCEVENmode, \"CCEVEN\")\n \n #define SELECT_CC_MODE(OP,X,Y) CCmode\n "}, {"sha": "3f993e11971f15b56f33650e8eda52ec22d30756", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -1710,10 +1710,7 @@ while (0)\n /* Add any extra modes needed to represent the condition code.\n \n    HPPA floating comparisons produce condition codes. */\n-#define EXTRA_CC_MODES CCFPmode\n-\n-/* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CCFP\"\n+#define EXTRA_CC_MODES CC(CCFPmode, \"CCFP\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point, CCFPmode"}, {"sha": "2a1d936f6e40f8a717b849d2e15ec7853cfc3083", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -944,10 +944,7 @@ extern int may_call_alloca;\n /* Add any extra modes needed to represent the condition code.\n \n    CCFPmode is used for FPU, but should we use a separate reg? */\n-#define EXTRA_CC_MODES CCFPmode\n-\n-/* the name for the mode above */\n-#define EXTRA_CC_NAMES \"CCFPmode\"\n+#define EXTRA_CC_MODES CC(CCFPmode, \"CCFP\")\n \n /* Give a comparison code (EQ, NE etc) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point, CCFPmode"}, {"sha": "79ab635c2eb24da0740eb9de9628946d1a0c3e82", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -2412,10 +2412,10 @@ do {                                                                    \\\n    use a mode for the case when we are comparing the results of two\n    comparisons.  */\n \n-#define EXTRA_CC_MODES CCUNSmode, CCFPmode, CCEQmode\n-\n-/* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CCUNS\", \"CCFP\", \"CCEQ\"\n+#define EXTRA_CC_MODES\t\t\\\n+    CC(CCUNSmode,  \"CCUNS\")\t\\\n+    CC(CCFPmode,   \"CCFP\")\t\\\n+    CC(CCEQmode,   \"CCEQ\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point, CCFPmode"}, {"sha": "20ba7dca730851130c691a7ecbff93f75cbd01de", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -2566,11 +2566,12 @@ do {                                                                    \\\n \n    CCXmode and CCX_NOOVmode are only used by v9.  */\n \n-#define EXTRA_CC_MODES CCXmode, CC_NOOVmode, CCX_NOOVmode, CCFPmode, CCFPEmode\n-\n-/* Define the names for the modes specified above.  */\n-\n-#define EXTRA_CC_NAMES \"CCX\", \"CC_NOOV\", \"CCX_NOOV\", \"CCFP\", \"CCFPE\"\n+#define EXTRA_CC_MODES\t\t\t\\\n+    CC(CCXmode,\t     \"CCX\")\t\t\\\n+    CC(CC_NOOVmode,  \"CC_NOOV\")\t\t\\\n+    CC(CCX_NOOVmode, \"CCX_NOOV\")\t\\\n+    CC(CCFPmode,     \"CCFP\")\t\t\\\n+    CC(CCFPEmode,    \"CCFPE\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,"}, {"sha": "60dc73aefc283d3ac663ea39debb86e2f01ca75f", "filename": "gcc/genattr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -258,8 +258,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   printf (\"/* Generated automatically by the program `genattr'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n "}, {"sha": "5c1a3be73ecc13c9764f2f912f6582ef7d0afbcc", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -5982,8 +5982,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   /* Set up true and false rtx's */\n   true_rtx = rtx_alloc (CONST_INT);\n   XWINT (true_rtx, 0) = 1;"}, {"sha": "c737e2a6d30fc5514bc3d8dc1f40558721598d49", "filename": "gcc/gencodes.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -101,8 +101,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   printf (\"/* Generated automatically by the program `gencodes'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n "}, {"sha": "8f4568d37ad13d311e3914c9e9f630d6bff3b461", "filename": "gcc/genconfig.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -290,8 +290,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   printf (\"/* Generated automatically by the program `genconfig'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n "}, {"sha": "dc9a49af9d6f56f384aad3c7a00e6f730582cb15", "filename": "gcc/genemit.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -643,40 +643,6 @@ output_add_clobbers ()\n   printf (\"}\\n\");\n }\n \f\n-/* Write a function, init_mov_optab, that is called to set up entries\n-   in mov_optab for EXTRA_CC_MODES.  */\n-\n-static void\n-output_init_mov_optab ()\n-{\n-#ifdef EXTRA_CC_NAMES\n-  static char *cc_names[] = { EXTRA_CC_NAMES };\n-  char *p;\n-  size_t i;\n-\n-  printf (\"\\nvoid\\ninit_mov_optab ()\\n{\\n\");\n-\n-  for (i = 0; i < sizeof cc_names / sizeof cc_names[0]; i++)\n-    {\n-      printf (\"#ifdef HAVE_mov\");\n-      for (p = cc_names[i]; *p; p++)\n-\tprintf (\"%c\", *p >= 'A' && *p <= 'Z' ? *p - 'A' + 'a' : *p);\n-      printf (\"\\n\");\n-      printf (\"  if (HAVE_mov\");\n-      for (p = cc_names[i]; *p; p++)\n-\tprintf (\"%c\", *p >= 'A' && *p <= 'Z' ? *p - 'A' + 'a' : *p);\n-      printf (\")\\n\");\n-      printf (\"    mov_optab->handlers[(int) %smode].insn_code = CODE_FOR_mov\",\n-\t      cc_names[i]);\n-      for (p = cc_names[i]; *p; p++)\n-\tprintf (\"%c\", *p >= 'A' && *p <= 'Z' ? *p - 'A' + 'a' : *p);\n-      printf (\";\\n#endif\\n\");\n-    }\n-\n-  printf (\"}\\n\");\n-#endif\n-}\n-\f\n PTR\n xmalloc (size)\n   size_t size;\n@@ -726,8 +692,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   /* Assign sequential codes to all entries in the machine description\n      in parallel with the tables in insn-output.c.  */\n \n@@ -790,9 +754,6 @@ from the machine description file `md'.  */\\n\\n\");\n   /* Write out the routine to add CLOBBERs to a pattern.  */\n   output_add_clobbers ();\n \n-  /* Write the routine to initialize mov_optab for the EXTRA_CC_MODES.  */\n-  output_init_mov_optab ();\n-\n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n   /* NOTREACHED */"}, {"sha": "d3b2061ba4ec8e06653c9e69bfad83648c7d8f6b", "filename": "gcc/genextract.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -402,8 +402,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   /* Assign sequential codes to all entries in the machine description\n      in parallel with the tables in insn-output.c.  */\n "}, {"sha": "b1fa6bb842452e00979638298e374d1d9c45137f", "filename": "gcc/genflags.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -227,8 +227,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   printf (\"/* Generated automatically by the program `genflags'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n "}, {"sha": "762c96fa4e42e398b8e043172ed9433c74682b78", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -26,6 +26,27 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #undef abort\n \n+#include \"real.h\"\n+\n+/* Calculate the format for CONST_DOUBLE.  This depends on the relative\n+   widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n+   We only need to go out to e0wwww, since min(HOST_WIDE_INT)==32 and\n+   max(LONG_DOUBLE_TYPE_SIZE)==128.\n+   This is duplicated in rtl.c.  \n+   A number of places assume that there are always at least two 'w'\n+   slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n+#if HOST_BITS_PER_WIDE_INT >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+#elif HOST_BITS_PER_WIDE_INT*2 >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+#elif HOST_BITS_PER_WIDE_INT*3 >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0www\"\n+#elif HOST_BITS_PER_WIDE_INT*4 >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0wwww\"\n+#else\n+#define CONST_DOUBLE_FORMAT\t/* nothing - will cause syntax error */\n+#endif\n+\n \n struct rtx_definition \n {"}, {"sha": "249500549e9fba597a2d0a80dd7cb2f600ea9c3e", "filename": "gcc/genopinit.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -326,8 +326,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   printf (\"/* Generated automatically by the program `genopinit'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n "}, {"sha": "c0a4cf581634474780cfd88f620c0510cf8a6ee4", "filename": "gcc/genoutput.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -162,10 +162,6 @@ struct data *end_of_insn_data;\n \n int have_constraints;\n \n-/* Nonzero if some error has occurred.  We will make all errors fatal, but\n-   might as well continue until we see all of them.  */\n-\n-static int have_error;\n \f\n static char * name_for_index PROTO((int));\n static void output_prologue PROTO((void));\n@@ -951,8 +947,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   output_prologue ();\n   next_code_number = 0;\n   next_index_number = 0;"}, {"sha": "3a877fe6cc0e3d0655f9eecc0afb5d1036d46a9e", "filename": "gcc/genpeep.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -431,8 +431,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n-\n   printf (\"/* Generated automatically by the program `genpeep'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n "}, {"sha": "166fc7a0e256ac17f8ad533d82ef858414251392", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -213,7 +213,7 @@ make_insn_sequence (insn, type)\n   {\n     static const char *last_real_name = \"insn\";\n     static int last_real_code = 0;\n-    char *name;\n+    char *name = 0;\n \n     if (insn_name_ptr_size <= next_insn_code)\n       {\n@@ -226,7 +226,8 @@ make_insn_sequence (insn, type)\n \tinsn_name_ptr_size = new_size;\n       }\n \n-    name = XSTR (insn, 0);\n+    if (type == RECOG)\n+      name = XSTR (insn, 0);\n     if (!name || name[0] == '\\0')\n       {\n \tname = xmalloc (strlen (last_real_name) + 10);\n@@ -1733,7 +1734,6 @@ main (argc, argv)\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  init_rtl ();\n   next_insn_code = 0;\n   next_index = 0;\n "}, {"sha": "a2258aae371e96b68a36fca26be5282b6cbc66ee", "filename": "gcc/machmode.def", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -106,11 +106,20 @@ DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, VOIDmode)\n \n /* The modes for representing the condition codes come last.  CCmode is\n    always defined.  Additional modes for the condition code can be specified\n-   in the EXTRA_CC_MODES macro.  Everything but the names of the modes\n-   are copied from CCmode.  For these modes, GET_MODE_WIDER_MODE points\n-   to the next defined CC mode, if any.  */\n+   in the EXTRA_CC_MODES macro.\n+   All MODE_CC modes are the same width as SImode and have VOIDmode as their\n+   next wider mode.\n+*/\n+\n+#define CC(E, M)  DEF_MACHMODE (E, M, MODE_CC, 4, 4, VOIDmode)\n+\n+CC (CCmode, \"CC\")\n+\n+#ifdef EXTRA_CC_MODES\n+EXTRA_CC_MODES\n+#endif\n \n-DEF_MACHMODE (CCmode, \"CC\", MODE_CC, 4, 4, VOIDmode)\n+#undef CC\n \n /* The symbol Pmode stands for one of the above machine modes (usually SImode).\n    The tm file specifies which one.  It is not a distinct mode.  */"}, {"sha": "79ab7b046ebe5acd6704c8683e50dee0028c4968", "filename": "gcc/machmode.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -42,10 +42,6 @@ Boston, MA 02111-1307, USA.  */\n \n enum machine_mode {\n #include \"machmode.def\"\n-\n-#ifdef EXTRA_CC_MODES\n-  EXTRA_CC_MODES,\n-#endif\n MAX_MACHINE_MODE };\n \n #undef DEF_MACHMODE\n@@ -65,7 +61,7 @@ enum mode_class { MODE_RANDOM, MODE_INT, MODE_FLOAT, MODE_PARTIAL_INT, MODE_CC,\n /* Get the general kind of object that mode MODE represents\n    (integer, floating, complex, etc.)  */\n \n-extern enum mode_class mode_class[];\n+extern const enum mode_class mode_class[];\n #define GET_MODE_CLASS(MODE)\t\t(mode_class[(int) (MODE)])\n \n /* Nonzero if MODE is an integral mode.  */\n@@ -86,12 +82,12 @@ extern enum mode_class mode_class[];\n \n /* Get the size in bytes of an object of mode MODE.  */\n \n-extern int mode_size[];\n+extern const int mode_size[];\n #define GET_MODE_SIZE(MODE)\t\t(mode_size[(int) (MODE)])\n \n /* Get the size in bytes of the basic parts of an object of mode MODE.  */\n \n-extern int mode_unit_size[];\n+extern const int mode_unit_size[];\n #define GET_MODE_UNIT_SIZE(MODE)\t(mode_unit_size[(int) (MODE)])\n \n /* Get the number of units in the object.  */\n@@ -109,15 +105,15 @@ extern int mode_unit_size[];\n /* Get a bitmask containing 1 for all bits in a word\n    that fit within mode MODE.  */\n \n-extern unsigned HOST_WIDE_INT mode_mask_array[];\n+extern const unsigned HOST_WIDE_INT mode_mask_array[];\n \n #define GET_MODE_MASK(MODE) mode_mask_array[(int) (MODE)]\n \n #endif /* HOST_WIDE_INT */\n \n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n \n-extern unsigned char mode_wider_mode[];\n+extern const unsigned char mode_wider_mode[];\n #define GET_MODE_WIDER_MODE(MODE)\t((enum machine_mode)mode_wider_mode[(int) (MODE)])\n \n /* Return the mode for data of a given size SIZE and mode class CLASS.\n@@ -149,7 +145,7 @@ extern enum machine_mode get_best_mode PROTO((int, int, int, enum machine_mode,\n \n /* For each class, get the narrowest mode in that class.  */\n \n-extern enum machine_mode class_narrowest_mode[];\n+extern const enum machine_mode class_narrowest_mode[];\n #define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode[(int) (CLASS)]\n \n /* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD"}, {"sha": "c300c299ef74e8be4ce1008aa83223dc0edb50de", "filename": "gcc/md.texi", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -2787,7 +2787,6 @@ is in class @code{MODE_CC}.  Normally, it will be @code{CCmode}.  If\n additional modes are required (as for the add example mentioned above in\n the Sparc), define the macro @code{EXTRA_CC_MODES} to list the\n additional modes required (@pxref{Condition Code}).  Also define\n-@code{EXTRA_CC_NAMES} to list the names of those modes and\n @code{SELECT_CC_MODE} to choose a mode given an operand of a compare.\n \n If it is known during RTL generation that a different mode will be"}, {"sha": "82bfc6a4e12c745f4466031ce9fe228c52be49df", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -4612,10 +4612,6 @@ init_optabs ()\n       fixtrunctab[i][j][1] = fixtrunctab[i][j][0];\n #endif\n \n-#ifdef EXTRA_CC_MODES\n-  init_mov_optab ();\n-#endif\n-\n   /* Initialize the optabs with the names of the library functions.  */\n   init_integral_libfuncs (add_optab, \"add\", '3');\n   init_floating_libfuncs (add_optab, \"add\", '3');"}, {"sha": "e13e4d2bfb00ab95e3cb19abfb16afafd4a6c398", "filename": "gcc/rtl.c", "status": "modified", "additions": 49, "deletions": 82, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -41,11 +41,36 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack *rtl_obstack;\n \f\n+\n+/* Calculate the format for CONST_DOUBLE.  This depends on the relative\n+   widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n+   We only need to go out to e0wwww, since min(HOST_WIDE_INT)==32 and\n+   max(LONG_DOUBLE_TYPE_SIZE)==128.\n+   This is duplicated in gengenrtl.c.\n+   A number of places assume that there are always at least two 'w'\n+   slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n+#if HOST_BITS_PER_WIDE_INT >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+#elif HOST_BITS_PER_WIDE_INT*2 >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+#elif HOST_BITS_PER_WIDE_INT*3 >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0www\"\n+#elif HOST_BITS_PER_WIDE_INT*4 >= LONG_DOUBLE_TYPE_SIZE\n+#define CONST_DOUBLE_FORMAT\t\"e0wwww\"\n+#else\n+#define CONST_DOUBLE_FORMAT\t/* nothing - will cause syntax error */\n+#endif\n+\n /* Indexed by rtx code, gives number of operands for an rtx with that code.\n-   Does NOT include rtx header data (code and links).\n-   This array is initialized in init_rtl.  */\n+   Does NOT include rtx header data (code and links).  */\n \n-int rtx_length[NUM_RTX_CODE + 1];\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   sizeof FORMAT - 1 ,\n+\n+const int rtx_length[NUM_RTX_CODE + 1] = {\n+#include \"rtl.def\"\n+};\n+\n+#undef DEF_RTL_EXPR\n \n /* Indexed by rtx code, gives the name of that kind of rtx, as a C string.  */\n \n@@ -64,10 +89,6 @@ const char * const rtx_name[] = {\n \n const char * const mode_name[(int) MAX_MACHINE_MODE + 1] = {\n #include \"machmode.def\"\n-\n-#ifdef EXTRA_CC_MODES\n-  EXTRA_CC_NAMES,\n-#endif\n   /* Add an extra field to avoid a core dump if someone tries to convert\n      MAX_MACHINE_MODE to a string.   */\n   \"\"\n@@ -80,7 +101,7 @@ const char * const mode_name[(int) MAX_MACHINE_MODE + 1] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  CLASS,\n \n-enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n+const enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\n };\n \n@@ -91,7 +112,7 @@ enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  SIZE,\n \n-int mode_size[(int) MAX_MACHINE_MODE] = {\n+const int mode_size[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\n };\n \n@@ -102,7 +123,7 @@ int mode_size[(int) MAX_MACHINE_MODE] = {\n \n #define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  UNIT,\n \n-int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n+const int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\t\t/* machine modes are documented here */\n };\n \n@@ -115,7 +136,7 @@ int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n #define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  \\\n   (unsigned char) WIDER,\n \n-unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n+const unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\t\t/* machine modes are documented here */\n };\n \n@@ -126,19 +147,30 @@ unsigned char mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n \n /* Indexed by machine mode, gives mask of significant bits in mode.  */\n \n-unsigned HOST_WIDE_INT mode_mask_array[(int) MAX_MACHINE_MODE] = {\n+const unsigned HOST_WIDE_INT mode_mask_array[(int) MAX_MACHINE_MODE] = {\n #include \"machmode.def\"\n };\n \n-/* Indexed by mode class, gives the narrowest mode for each class.  */\n-\n-enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS];\n+/* Indexed by mode class, gives the narrowest mode for each class.\n+   The Q modes are always of width 1 (2 for complex) - it is impossible\n+   for any mode to be narrower.  */\n+\n+const enum machine_mode class_narrowest_mode[(int) MAX_MODE_CLASS] = {\n+    /* MODE_RANDOM */\t\tVOIDmode,\n+    /* MODE_INT */\t\tQImode,\n+    /* MODE_FLOAT */\t\tQFmode,\n+    /* MODE_PARTIAL_INT */\tPQImode,\n+    /* MODE_CC */\t\tCCmode,\n+    /* MODE_COMPLEX_INT */\tCQImode,\n+    /* MODE_COMPLEX_FLOAT */\tQCmode\n+};\n+\t\t\t\n \n /* Indexed by rtx code, gives a sequence of operand-types for\n    rtx's of that code.  The sequence is a C string in which\n    each character describes one operand.  */\n \n-const char *rtx_format[] = {\n+const char * const rtx_format[] = {\n   /* \"*\" undefined.\n          can cause a warning message\n      \"0\" field is unused (or used in a phase-dependent manner)\n@@ -901,71 +933,6 @@ read_rtx (infile)\n \n   return return_rtx;\n }\n-\f\n-/* This is called once per compilation, before any rtx's are constructed.\n-   It initializes the vector `rtx_length', the extra CC modes, if any,\n-   and computes certain commonly-used modes.  */\n-\n-void\n-init_rtl ()\n-{\n-  int min_class_size[(int) MAX_MODE_CLASS];\n-  enum machine_mode mode;\n-  int i;\n-\n-  for (i = 0; i < NUM_RTX_CODE; i++)\n-    rtx_length[i] = strlen (GET_RTX_FORMAT(i));\n-\n-  /* Make CONST_DOUBLE bigger, if real values are bigger than\n-     it normally expects to have room for.\n-     Note that REAL_VALUE_TYPE is not defined by default,\n-     since tree.h is not included.  But the default dfn as `double'\n-     would do no harm.  */\n-#ifdef REAL_VALUE_TYPE\n-  i = sizeof (REAL_VALUE_TYPE) / sizeof (rtunion) + 2;\n-  if (rtx_length[(int) CONST_DOUBLE] < i)\n-    {\n-      char *s = (char *) xmalloc (i + 1);\n-      rtx_length[(int) CONST_DOUBLE] = i;\n-      rtx_format[(int) CONST_DOUBLE] = s;\n-      *s++ = 'e';\n-      *s++ = '0';\n-      /* Set the GET_RTX_FORMAT of CONST_DOUBLE to a string\n-\t of as many `w's as we now have elements.  Subtract two from\n-\t the size to account for the 'e' and the '0'.  */\n-      for (i = 2; i < rtx_length[(int) CONST_DOUBLE]; i++)\n-\t*s++ = 'w';\n-      *s++ = 0;\n-    }\n-#endif\n-\n-#ifdef EXTRA_CC_MODES\n-  for (i = (int) CCmode + 1; i < (int) MAX_MACHINE_MODE; i++)\n-    {\n-      mode_class[i] = MODE_CC;\n-      mode_mask_array[i] = mode_mask_array[(int) CCmode];\n-      mode_size[i] = mode_size[(int) CCmode];\n-      mode_unit_size[i] = mode_unit_size[(int) CCmode];\n-      mode_wider_mode[i - 1] = i;\n-      mode_wider_mode[i] = (unsigned char)VOIDmode;\n-    }\n-#endif\n-\n-  /* Find the narrowest mode for each class.  */\n-\n-  for (i = 0; i < (int) MAX_MODE_CLASS; i++)\n-    min_class_size[i] = 1000;\n-\n-  for (mode = VOIDmode; (int) mode < (int) MAX_MACHINE_MODE;\n-       mode = (enum machine_mode) ((int) mode + 1))\n-    {\n-      if (GET_MODE_SIZE (mode) < min_class_size[(int) GET_MODE_CLASS (mode)])\n-\t{\n-\t  class_narrowest_mode[(int) GET_MODE_CLASS (mode)] = mode;\n-\t  min_class_size[(int) GET_MODE_CLASS (mode)] = GET_MODE_SIZE (mode);\n-\t}\n-    }\n-}\n \n /* These are utility functions used by fatal-error functions all over the\n    code.  rtl.c happens to be linked by all the programs that need them,\n@@ -980,7 +947,7 @@ static const char *\n trim_filename (name)\n      const char *name;\n {\n-  static const char *this_file = __FILE__;\n+  static const char this_file[] = __FILE__;\n   const char *p = name, *q = this_file;\n \n   while (*p == *q && *p != 0 && *q != 0) p++, q++;"}, {"sha": "357585e37f92123e86e27b547f6691c84971a711", "filename": "gcc/rtl.def", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -509,14 +509,15 @@ DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", 'x')\n /* numeric integer constant */\n DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n \n-/* numeric double constant.\n-   Operand 0 is the MEM that stores this constant in memory,\n-   or various other things (see comments at immed_double_const in varasm.c).\n-   Operand 1 is a chain of all CONST_DOUBLEs in use in the current function.\n-   Remaining operands hold the actual value.\n-   The number of operands may be more than 2 if cross-compiling;\n-   see init_rtl.  */\n-DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", \"e0ww\", 'o')\n+/* numeric floating point constant.\n+   Operand 0 ('e') is the MEM that stores this constant in memory, or\n+   various other things (see comments at immed_double_const in\n+   varasm.c).\n+   Operand 1 ('0') is a chain of all CONST_DOUBLEs in use in the\n+   current function.\n+   Remaining operands hold the actual value.  They are all 'w' and\n+   there may be from 1 to 4; see rtl.c.  */\n+DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, 'o')\n \n /* String constant.  Used only for attributes right now.  */\n DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')"}, {"sha": "837dad1af6d5902a106687e45dc1582285d1d515", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -48,13 +48,13 @@ enum rtx_code  {\n #define NUM_RTX_CODE ((int)LAST_AND_UNUSED_RTX_CODE)\n \t\t\t\t/* The cast here, saves many elsewhere.  */\n \n-extern int rtx_length[];\n+extern const int rtx_length[];\n #define GET_RTX_LENGTH(CODE)\t\t(rtx_length[(int) (CODE)])\n \n extern const char * const rtx_name[];\n #define GET_RTX_NAME(CODE)\t\t(rtx_name[(int) (CODE)])\n \n-extern const char *rtx_format[];\n+extern const char * const rtx_format[];\n #define GET_RTX_FORMAT(CODE)\t\t(rtx_format[(int) (CODE)])\n \n extern const char rtx_class[];"}, {"sha": "0ed550a5163c75c2ba5e0069548db64932631c5a", "filename": "gcc/tm.texi", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -4498,27 +4498,24 @@ two places, the @file{md} file and in @code{NOTICE_UPDATE_CC}.\n \n @findex EXTRA_CC_MODES\n @item EXTRA_CC_MODES\n-A list of names to be used for additional modes for condition code\n-values in registers (@pxref{Jump Patterns}).  These names are added\n-to @code{enum machine_mode} and all have class @code{MODE_CC}.  By\n-convention, they should start with @samp{CC} and end with @samp{mode}.\n+A list of additional modes for condition code values in registers \n+(@pxref{Jump Patterns}).  This macro should expand to a sequence of\n+calls of the macro @code{CC} separated by white space.  @code{CC} takes\n+two arguments.  The first is the enumeration name of the mode, which\n+should begin with @samp{CC} and end with @samp{mode}.  The second is a C\n+string giving the printable name of the mode; it should be the same as\n+the first argument, but with the trailing @samp{mode} removed.\n \n-You should only define this macro if your machine does not use @code{cc0}\n-and only if additional modes are required.\n-\n-@findex EXTRA_CC_NAMES\n-@item EXTRA_CC_NAMES\n-A list of C strings giving the names for the modes listed in\n-@code{EXTRA_CC_MODES}.  For example, the Sparc defines this macro and\n-@code{EXTRA_CC_MODES} as\n+You should only define this macro if additional modes are required.\n \n+A sample definition of @code{EXTRA_CC_MODES} is:\n @smallexample\n-#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode, CCFPEmode\n-#define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\", \"CCFPE\"\n+#define EXTRA_CC_MODES            \\\n+    CC(CC_NOOVmode, \"CC_NOOV\")    \\\n+    CC(CCFPmode, \"CCFP\")          \\\n+    CC(CCFPEmode, \"CCFPE\")\n @end smallexample\n \n-This macro is not required if @code{EXTRA_CC_MODES} is not defined.\n-\n @findex SELECT_CC_MODE\n @item SELECT_CC_MODE (@var{op}, @var{x}, @var{y})\n Returns a mode from class @code{MODE_CC} to be used when comparison"}, {"sha": "112c89133b4871c1dd8e49765571fc663d4813d1", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0b4465912b2baf8ad8c7e9fb68b6f616036e19/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=aa0b4465912b2baf8ad8c7e9fb68b6f616036e19", "patch": "@@ -153,7 +153,6 @@ extern void finish_parse ();\n extern void init_decl_processing ();\n extern void init_obstacks ();\n extern void init_tree_codes ();\n-extern void init_rtl ();\n extern void init_regs ();\n extern void init_optabs ();\n extern void init_stmt ();\n@@ -2895,7 +2894,6 @@ compile_file (name)\n   init_obstacks ();\n   init_tree_codes ();\n   name = init_parse (name);\n-  init_rtl ();\n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n \t\t  || flag_test_coverage"}]}