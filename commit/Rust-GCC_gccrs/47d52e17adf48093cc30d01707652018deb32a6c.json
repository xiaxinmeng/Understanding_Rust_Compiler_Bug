{"sha": "47d52e17adf48093cc30d01707652018deb32a6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkNTJlMTdhZGY0ODA5M2NjMzBkMDE3MDc2NTIwMThkZWIzMmE2Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:11Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:11Z"}, "message": "doc: Add documentation for rtl-ssa\n\nThis patch adds some documentation to rtl.texi about the SSA form.\nIt only really describes the high-level structure -- I think for\nAPI-level stuff it's better to rely on function comments instead.\n\ngcc/\n\t* doc/rtl.texi (RTL SSA): New node.", "tree": {"sha": "445722a9b0cbd46b0b62d32af08152163b3af8d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/445722a9b0cbd46b0b62d32af08152163b3af8d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d52e17adf48093cc30d01707652018deb32a6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d52e17adf48093cc30d01707652018deb32a6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d52e17adf48093cc30d01707652018deb32a6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d52e17adf48093cc30d01707652018deb32a6c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a20cc01679040fb3b069285a638e3a469c688159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20cc01679040fb3b069285a638e3a469c688159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20cc01679040fb3b069285a638e3a469c688159"}], "stats": {"total": 787, "additions": 787, "deletions": 0}, "files": [{"sha": "86290ded4ef1034879d67359d6864858e1d7a005", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 787, "deletions": 0, "changes": 787, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d52e17adf48093cc30d01707652018deb32a6c/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d52e17adf48093cc30d01707652018deb32a6c/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=47d52e17adf48093cc30d01707652018deb32a6c", "patch": "@@ -39,6 +39,7 @@ form uses nested parentheses to indicate the pointers in the internal form.\n * Debug Information:: Expressions representing debugging information.\n * Insns::             Expression types for entire insns.\n * Calls::             RTL representation of function call insns.\n+* RTL SSA::           An on-the-side SSA form for RTL\n * Sharing::           Some expressions are unique; others *must* be copied.\n * Reading RTL::       Reading textual RTL from a file.\n @end menu\n@@ -4444,6 +4445,792 @@ function.  Similarly, if registers other than those in\n containing a single @code{clobber} follow immediately after the call to\n indicate which registers.\n \n+@node RTL SSA\n+@section On-the-Side SSA Form for RTL\n+@cindex SSA, RTL form\n+@cindex RTL SSA\n+\n+The patterns of an individual RTL instruction describe which registers\n+are inputs to that instruction and which registers are outputs from\n+that instruction.  However, it is often useful to know where the\n+definition of a register input comes from and where the result of\n+a register output is used.  One way of obtaining this information\n+is to use the RTL SSA form, which provides a Static Single Assignment\n+representation of the RTL instructions.\n+\n+The RTL SSA code is located in the @file{rtl-ssa} subdirectory of the GCC\n+source tree.  This section only gives a brief overview of it; please\n+see the comments in the source code for more details.\n+\n+@menu\n+* Using RTL SSA::             What a pass needs to do to use the RTL SSA form\n+* RTL SSA Instructions::      How instructions are represented and organized\n+* RTL SSA Basic Blocks::      How instructions are grouped into blocks\n+* RTL SSA Resources::         How registers and memory are represented\n+* RTL SSA Accesses::          How register and memory accesses are represented\n+* RTL SSA Phi Nodes::         How multiple sources are combined into one\n+* RTL SSA Access Lists::      How accesses are chained together\n+* Changing RTL Instructions:: How to use the RTL SSA framework to change insns\n+@end menu\n+\n+@node Using RTL SSA\n+@subsection Using RTL SSA in a pass\n+\n+A pass that wants to use the RTL SSA form should start with the following:\n+\n+@smallexample\n+#define INCLUDE_ALGORITHM\n+#define INCLUDE_FUNCTIONAL\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"df.h\"\n+#include \"rtl-ssa.h\"\n+@end smallexample\n+\n+All the RTL SSA code is contained in the @code{rtl_ssa} namespace,\n+so most passes will then want to do:\n+\n+@smallexample\n+using namespace rtl_ssa;\n+@end smallexample\n+\n+However, this is purely a matter of taste, and the examples in the rest of\n+this section do not require it.\n+\n+The RTL SSA represention is an optional on-the-side feature that applies\n+on top of the normal RTL instructions.  It is currently local to individual\n+RTL passes and is not maintained across passes.\n+\n+However, in order to allow the RTL SSA information to be preserved across\n+passes in future, @samp{crtl->ssa} points to the current function's\n+SSA form (if any).  Passes that want to use the RTL SSA form should\n+first do:\n+\n+@smallexample\n+crtl->ssa = new rtl_ssa::function_info (@var{fn});\n+@end smallexample\n+\n+where @var{fn} is the function that the pass is processing.\n+(Passes that are @code{using namespace rtl_ssa} do not need\n+the @samp{rtl_ssa::}.)\n+\n+Once the pass has finished with the SSA form, it should do the following:\n+\n+@smallexample\n+free_dominance_info (CDI_DOMINATORS);\n+if (crtl->ssa->perform_pending_updates ())\n+  cleanup_cfg (0);\n+\n+delete crtl->ssa;\n+crtl->ssa = nullptr;\n+@end smallexample\n+\n+The @code{free_dominance_info} call is necessary because\n+dominance information is not currently maintained between RTL passes.\n+The next two lines commit any changes to the RTL instructions that\n+were queued for later; see the comment above the declaration of\n+@code{perform_pending_updates} for details.  The final two lines\n+discard the RTL SSA form and free the associated memory.\n+\n+@node RTL SSA Instructions\n+@subsection RTL SSA Instructions\n+\n+@cindex RPO\n+@cindex reverse postorder\n+@cindex instructions, RTL SSA\n+@findex rtl_ssa::insn_info\n+RTL SSA instructions are represented by an @code{rtl_ssa::insn_info}.\n+These instructions are chained together in a single list that follows\n+a reverse postorder (RPO) traversal of the function.  This means that\n+if any path through the function can execute an instruction @var{I1}\n+and then later execute an instruction @var{I2} for the first time,\n+@var{I1} appears before @var{I2} in the list@footnote{Note that this\n+order is different from the order of the underlying RTL instructions,\n+which follow machine code order instead.}.\n+\n+Two RTL SSA instructions can be compared to find which instruction\n+occurs earlier than the other in the RPO@.  One way to do this is\n+to use the C++ comparison operators, such as:\n+\n+@example\n+*@var{insn1} < *@var{insn2}\n+@end example\n+\n+Another way is to use the @code{compare_with} function:\n+\n+@example\n+@var{insn1}->compare_with (@var{insn2})\n+@end example\n+\n+This expression is greater than zero if @var{insn1} comes after @var{insn2}\n+in the RPO, less than zero if @var{insn1} comes before @var{insn2} in the\n+RPO, or zero if @var{insn1} and @var{insn2} are the same.  This order is\n+maintained even if instructions are added to the function or moved around.\n+\n+The main purpose of @code{rtl_ssa::insn_info} is to hold\n+SSA information about an instruction.  However, it also caches\n+certain properties of the instruction, such as whether it is an\n+inline assembly instruction, whether it has volatile accesses, and so on.\n+\n+@node RTL SSA Basic Blocks\n+@subsection RTL SSA Basic Blocks\n+\n+@cindex basic blocks, RTL SSA\n+@findex basic_block\n+@findex rtl_ssa::bb_info\n+RTL SSA instructions (@pxref{RTL SSA Instructions}) are organized into\n+basic blocks, with each block being represented by an @code{rtl_ssa:bb_info}.\n+There is a one-to-one mapping between these @code{rtl_ssa:bb_info}\n+structures and the underlying CFG @code{basic_block} structures\n+(@pxref{Basic Blocks}).\n+\n+@cindex ``real'' instructions, RTL SSA\n+@anchor{real RTL SSA insns}\n+If a CFG basic block @var{bb} contains an RTL instruction @var{insn},\n+the RTL SSA represenation of @var{bb} also contains an RTL SSA representation\n+of @var{insn}@footnote{Note that this excludes non-instruction things like\n+@code{note}s and @code{barrier}s that also appear in the chain of RTL\n+instructions.}.  Within RTL SSA, these instructions are referred to as\n+``real'' instructions.  These real instructions fall into two groups:\n+debug instructions and nondebug instructions.  Only nondebug instructions\n+should affect code generation decisions.\n+\n+In addition, each RTL SSA basic block has two ``artificial''\n+instructions: a ``head'' instruction that comes before all the real\n+instructions and an ``end'' instruction that comes after all real\n+instructions.  These instructions exist to represent things that\n+are conceptually defined or used at the start and end of a basic block.\n+The instructions always exist, even if they do not currently do anything.\n+\n+Like instructions, these blocks are chained together in a reverse\n+postorder.  This list includes the entry block (which always comes\n+first) and the exit block (which always comes last).\n+\n+@cindex extended basic blocks, RTL SSA\n+@findex rtl_ssa::ebb_info\n+RTL SSA basic blocks are chained together into ``extended basic blocks''\n+(EBBs), represented by an @code{rtl_ssa::ebb_info}.  Extended basic\n+blocks contain one or more basic blocks.  They have the property\n+that if a block @var{bby} comes immediately after a block @var{bbx}\n+in an EBB, then @var{bby} can only be reached by @var{bbx}; in other words,\n+@var{bbx} is the sole predecessor of @var{bby}.\n+\n+Each extended basic block starts with an artificial ``phi node''\n+instruction.  This instruction defines all phi nodes for the EBB\n+(@pxref{RTL SSA Phi Nodes}).  (Individual blocks in an EBB do not\n+need phi nodes because their live values can only come from one source.)\n+\n+The contents of a function are therefore represented using a\n+four-level hierarchy:\n+\n+@itemize @bullet\n+@item\n+functions (@code{rtl_ssa::function_info}), which contain @dots{}\n+\n+@item\n+extended basic blocks (@code{rtl_ssa::ebb_info}), which contain @dots{}\n+\n+@item\n+basic blocks (@code{rtl_ssa::bb_info}), which contain @dots{}\n+\n+@item\n+instructions (@code{rtl_ssa::insn_info})\n+@end itemize\n+\n+In dumps, a basic block is identified as @code{bb@var{n}}, where @var{n}\n+is the index of the associated CFG @code{basic_block} structure.\n+An EBB is in turn identified by the index of its first block.\n+For example, an EBB that contains @samp{bb10}, @code{bb5}, @code{bb6}\n+and @code{bb9} is identified as @var{ebb10}.\n+\n+@node RTL SSA Resources\n+@subsection RTL SSA Resources\n+\n+The RTL SSA form tracks two types of ``resource'': registers and memory.\n+Each hard and pseudo register is a separate resource.  Memory is a\n+single unified resource, like it is in GIMPLE (@pxref{GIMPLE}).\n+\n+Each resource has a unique identifier.  The unique identifier for a\n+register is simply its register number.  The unique identifier for\n+memory is a special register number called @code{MEM_REGNO}.\n+\n+Since resource numbers so closely match register numbers, it is sometimes\n+convenient to refer to them simply as register numbers, or ``regnos''\n+for short.  However, the RTL SSA form also provides an abstraction\n+of resources in the form of @code{rtl_ssa::resource_info}.\n+This is a lightweight class that records both the regno of a resource\n+and the @code{machine_mode} that the resource has (@pxref{Machine Modes}).\n+It has functions for testing whether a resource is a register or memory.\n+In principle it could be extended to other kinds of resource in future.\n+\n+@node RTL SSA Accesses\n+@subsection RTL SSA Register and Memory Accesses\n+\n+In the RTL SSA form, most reads or writes of a resource are\n+represented as a @code{rtl_ssa::access_info}@footnote{The exceptions\n+are call clobbers, which are generally represented separately.\n+See the comment above @code{rtl_ssa::insn_info} for details.}.\n+These @code{rtl_ssa::access_info}s are organized into the following\n+class hierarchy:\n+\n+@findex rtl_ssa::access_info\n+@findex rtl_ssa::use_info\n+@findex rtl_ssa::def_info\n+@findex rtl_ssa::clobber_info\n+@findex rtl_ssa::set_info\n+@findex rtl_ssa::phi_info\n+@smallexample\n+rtl_ssa::access_info\n+  |\n+  +-- rtl_ssa::use_info\n+  |\n+  +-- rtl_ssa::def_info\n+        |\n+        +-- rtl_ssa::clobber_info\n+        |\n+        +-- rtl_ssa::set_info\n+              |\n+              +-- rtl_ssa::phi_info\n+@end smallexample\n+\n+A @code{rtl_ssa::use_info} represents a read or use of a resource and\n+a @code{rtl_ssa::def_info} represents a write or definition of a resource.\n+As in the main RTL representation, there are two basic types of\n+definition: clobbers and sets.  The difference is that a clobber\n+leaves the register with an unspecified value that cannot be used\n+or relied on by later instructions, while a set leaves the register\n+with a known value that later instructions could use if they wanted to.\n+A @code{rtl_ssa::clobber_info} represents a clobber and\n+a @code{rtl_ssa::set_info} represent a set.\n+\n+Each @code{rtl_ssa::use_info} records which single @code{rtl_ssa::set_info}\n+provides the value of the resource; this is null if the resource is\n+completely undefined at the point of use.  Each @code{rtl_ssa::set_info}\n+in turn records all the @code{rtl_ssa::use_info}s that use its value.\n+\n+If a value of a resource can come from multiple sources,\n+a @code{rtl_ssa::phi_info} brings those multiple sources together\n+into a single definition (@pxref{RTL SSA Phi Nodes}).\n+\n+@node RTL SSA Phi Nodes\n+@subsection RTL SSA Phi Nodes\n+\n+@cindex phi nodes, RTL SSA\n+@findex rtl_ssa::phi_info\n+If a resource is live on entry to an extended basic block and if the\n+resource's value can come from multiple sources, the extended basic block\n+has a ``phi node'' that collects together these multiple sources.\n+The phi node conceptually has one input for each incoming edge of\n+the extended basic block, with the input specifying the value of\n+the resource on that edge.  For example, suppose a function contains\n+the following RTL:\n+\n+@smallexample\n+;; Basic block bb3\n+@dots{}\n+(set (reg:SI R1) (const_int 0))  ;; A\n+(set (pc) (label_ref bb5))\n+\n+;; Basic block bb4\n+@dots{}\n+(set (reg:SI R1) (const_int 1))  ;; B\n+;; Fall through\n+\n+;; Basic block bb5\n+;; preds: bb3, bb4\n+;; live in: R1 @dots{}\n+(code_label bb5)\n+@dots{}\n+(set (reg:SI @var{R2})\n+     (plus:SI (reg:SI R1) @dots{}))  ;; C\n+@end smallexample\n+\n+The value of R1 on entry to block 5 can come from either A or B@.\n+The extended basic block that contains block 5 would therefore have a\n+phi node with two inputs: the first input would have the value of\n+R1 defined by A and the second input would have the value of\n+R1 defined by B@.  This phi node would then provide the value of\n+R1 for C (assuming that R1 does not change again between\n+the start of block 5 and C).\n+\n+Since RTL is not a ``native'' SSA representation, these phi nodes\n+simply collect together definitions that already exist.  Each input\n+to a phi node for a resource @var{R} is itself a definition of\n+resource @var{R} (or is null if the resource is completely\n+undefined for a particular incoming edge).  This is in contrast\n+to a native SSA representation like GIMPLE, where the phi inputs\n+can be arbitrary expressions.  As a result, RTL SSA phi nodes\n+never involve ``hidden'' moves: all moves are instead explicit.\n+\n+Phi nodes are represented as a @code{rtl_ssa::phi_node}.\n+Each input to a phi node is represented as an @code{rtl_ssa::use_info}.\n+\n+@node RTL SSA Access Lists\n+@subsection RTL SSA Access Lists\n+\n+All the definitions of a resource are chained together in reverse postorder.\n+In general, this list can contain an arbitrary mix of both sets\n+(@code{rtl_ssa::set_info}) and clobbers (@code{rtl_ssa::clobber_info}).\n+However, it is often useful to skip over all intervening clobbers\n+of a resource in order to find the next set.  The list is constructed\n+in such a way that this can be done in amortized constant time.\n+\n+All uses (@code{rtl_ssa::use_info}) of a given set are also chained\n+together into a list.  This list of uses is divided into three parts:\n+\n+@enumerate\n+@item\n+uses by ``real'' nondebug instructions (@pxref{real RTL SSA insns})\n+\n+@item\n+uses by real debug instructions\n+\n+@item\n+uses by phi nodes (@pxref{RTL SSA Phi Nodes})\n+@end enumerate\n+\n+The first and second parts individually follow reverse postorder.\n+The third part has no particular order.\n+\n+@cindex degenerate phi node, RTL SSA\n+The last use by a real nondebug instruction always comes earlier in\n+the reverse postorder than the next definition of the resource (if any).\n+This means that the accesses follow a linear sequence of the form:\n+\n+@itemize @bullet\n+@item\n+first definition of resource R\n+\n+@itemize @bullet\n+@item\n+first use by a real nondebug instruction of the first definition of resource R\n+\n+@item\n+@dots{}\n+\n+@item\n+last use by a real nondebug instruction of the first definition of resource R\n+@end itemize\n+\n+@item\n+second definition of resource R\n+\n+@itemize @bullet\n+@item\n+first use by a real nondebug instruction of the second definition of resource R\n+\n+@item\n+@dots{}\n+\n+@item\n+last use by a real nondebug instruction of the second definition of resource R\n+@end itemize\n+\n+@item\n+@dots{}\n+\n+@item\n+last definition of resource R\n+\n+@itemize @bullet\n+@item\n+first use by a real nondebug instruction of the last definition of resource R\n+\n+@item\n+@dots{}\n+\n+@item\n+last use by a real nondebug instruction of the last definition of resource R\n+@end itemize\n+@end itemize\n+\n+(Note that clobbers never have uses; only sets do.)\n+\n+This linear view is easy to achieve when there is only a single definition\n+of a resource, which is commonly true for pseudo registers.  However,\n+things are more complex  if code has a structure like the following:\n+\n+@smallexample\n+// ebb2, bb2\n+R = @var{va};        // A\n+if (@dots{})\n+  @{\n+    // ebb2, bb3\n+    use1 (R);  // B\n+    @dots{}\n+    R = @var{vc};    // C\n+  @}\n+else\n+  @{\n+    // ebb4, bb4\n+    use2 (R);  // D\n+  @}\n+@end smallexample\n+\n+The list of accesses would begin as follows:\n+\n+@itemize @bullet\n+@item\n+definition of R by A\n+\n+@itemize @bullet\n+@item\n+use of A's definition of R by B\n+@end itemize\n+\n+@item\n+definition of R by C\n+@end itemize\n+\n+The next access to R is in D, but the value of R that D uses comes from\n+A rather than C@.\n+\n+This is resolved by adding a phi node for @code{ebb4}.  All inputs to this\n+phi node have the same value, which in the example above is A's definition\n+of R@.  In other circumstances, it would not be necessary to create a phi\n+node when all inputs are equal, so these phi nodes are referred to as\n+``degenerate'' phi nodes.\n+\n+The full list of accesses to R is therefore:\n+\n+@itemize @bullet\n+@item\n+definition of R by A\n+\n+@itemize @bullet\n+@item\n+use of A's definition of R by B\n+@end itemize\n+\n+@item\n+definition of R by C\n+\n+@item\n+definition of R by ebb4's phi instruction, with the input coming from A\n+\n+@itemize @bullet\n+@item\n+use of the ebb4's R phi definition of R by B\n+@end itemize\n+@end itemize\n+\n+Note that A's definition is also used by ebb4's phi node, but this\n+use belongs to the third part of the use list described above and\n+so does not form part of the linear sequence.\n+\n+It is possible to ``look through'' any degenerate phi to the ultimate\n+definition using the function @code{look_through_degenerate_phi}.\n+Note that the input to a degenerate phi is never itself provided\n+by a degenerate phi.\n+\n+At present, the SSA form takes this principle one step further\n+and guarantees that, for any given resource @var{res}, one of the\n+following is true:\n+\n+@itemize\n+@item\n+The resource has a single definition @var{def}, which is not a phi node.\n+Excluding uses of undefined registers, all uses of @var{res} by real\n+nondebug instructions use the value provided by @var{def}.\n+\n+@item\n+Excluding uses of undefined registers, all uses of @var{res} use\n+values provided by definitions that occur earlier in the same\n+extended basic block.  These definitions might come from phi nodes\n+or from real instructions.\n+@end itemize\n+\n+@node Changing RTL Instructions\n+@subsection Using the RTL SSA framework to change instructions\n+\n+@findex rtl_ssa::insn_change\n+There are various routines that help to change a single RTL instruction\n+or a group of RTL instructions while keeping the RTL SSA form up-to-date.\n+This section first describes the process for changing a single instruction,\n+then goes on to describe the differences when changing multiple instructions.\n+\n+@menu\n+* Changing One RTL SSA Instruction::\n+* Changing Multiple RTL SSA Instructions::\n+@end menu\n+\n+@node Changing One RTL SSA Instruction\n+@subsubsection Changing One RTL SSA Instruction\n+\n+Before making a change, passes should first use a statement like the\n+following:\n+\n+@smallexample\n+auto attempt = crtl->ssa->new_change_attempt ();\n+@end smallexample\n+\n+Here, @code{attempt} is an RAII object that should remain in scope\n+for the entire change attempt.  It automatically frees temporary\n+memory related to the changes when it goes out of scope.\n+\n+Next, the pass should create an @code{rtl_ssa::insn_change} object\n+for the instruction that it wants to change.  This object specifies\n+several things:\n+\n+@itemize @bullet\n+@item\n+what the instruction's new list of uses should be (@code{new_uses}).\n+By default this is the same as the instruction's current list of uses.\n+\n+@item\n+what the instruction's new list of definitions should be (@code{new_defs}).\n+By default this is the same as the instruction's current list of\n+definitions.\n+\n+@item\n+where the instruction should be located (@code{move_range}).\n+This is a range of instructions after which the instruction could\n+be placed, represented as an @code{rtl_ssa::insn_range}.\n+By default the instruction must remain at its current position.\n+@end itemize\n+\n+If a pass was attempting to change all these properties of an instruction\n+@code{insn}, it might do something like this:\n+\n+@smallexample\n+rtl_ssa::insn_change change (insn);\n+change.new_defs = @dots{};\n+change.new_uses = @dots{};\n+change.move_range = @dots{};\n+@end smallexample\n+\n+This @code{rtl_ssa::insn_change} only describes something that the\n+pass @emph{might} do; at this stage, nothing has actually changed.\n+\n+As noted above, the default @code{move_range} requires the instruction\n+to remain where it is.  At the other extreme, it is possible to allow\n+the instruction to move anywhere within its extended basic block,\n+provided that all the new uses and definitions can be performed\n+at the new location.  The way to do this is:\n+\n+@smallexample\n+change.move_range = insn->ebb ()->insn_range ();\n+@end smallexample\n+\n+In either case, the next step is to make sure that move range is\n+consistent with the new uses and definitions.  The way to do this is:\n+\n+@smallexample\n+if (!rtl_ssa::restrict_movement (change))\n+  return false;\n+@end smallexample\n+\n+This function tries to limit @code{move_range} to a range of instructions\n+at which @code{new_uses} and @code{new_defs} can be correctly performed.\n+It returns true on success or false if no suitable location exists.\n+\n+The pass should also tentatively change the pattern of the instruction\n+to whatever form the pass wants the instruction to have.  This should use\n+the facilities provided by @file{recog.c}.  For example:\n+\n+@smallexample\n+rtl_insn *rtl = insn->rtl ();\n+insn_change_watermark watermark;\n+validate_change (rtl, &PATTERN (rtl), new_pat, 1);\n+@end smallexample\n+\n+will tentatively replace @code{insn}'s pattern with @code{new_pat}.\n+\n+These changes and the construction of the @code{rtl_ssa::insn_change}\n+can happen in either order or be interleaved.\n+\n+After the tentative changes to the instruction are complete,\n+the pass should check whether the new pattern matches a target\n+instruction or satisfies the requirements of an inline asm:\n+\n+@smallexample\n+if (!rtl_ssa::recog (change))\n+  return false;\n+@end smallexample\n+\n+This step might change the instruction pattern further in order to\n+make it match.  It might also add new definitions or restrict the range\n+of the move.  For example, if the new pattern did not match in its original\n+form, but could be made to match by adding a clobber of the flags\n+register, @code{rtl_ssa::recog} will check whether the flags register\n+is free at an appropriate point.  If so, it will add a clobber of the\n+flags register to @code{new_defs} and restrict @code{move_range} to\n+the locations at which the flags register can be safely clobbered.\n+\n+Even if the proposed new instruction is valid according to\n+@code{rtl_ssa::recog}, the change might not be worthwhile.\n+For example, when optimizing for speed, the new instruction might\n+turn out to be slower than the original one.  When optimizing for\n+size, the new instruction might turn out to be bigger than the\n+original one.\n+\n+Passes should check for this case using @code{change_is_worthwhile}.\n+For example:\n+\n+@smallexample\n+if (!rtl_ssa::change_is_worthwhile (change))\n+  return false;\n+@end smallexample\n+\n+If the change passes this test too then the pass can perform the change using:\n+\n+@smallexample\n+confirm_change_group ();\n+crtl->ssa->change_insn (change);\n+@end smallexample\n+\n+Putting all this together, the change has the following form:\n+\n+@smallexample\n+auto attempt = crtl->ssa->new_change_attempt ();\n+\n+rtl_ssa::insn_change change (insn);\n+change.new_defs = @dots{};\n+change.new_uses = @dots{};\n+change.move_range = @dots{};\n+\n+if (!rtl_ssa::restrict_movement (change))\n+  return false;\n+\n+insn_change_watermark watermark;\n+// Use validate_change etc. to change INSN's pattern.\n+@dots{}\n+if (!rtl_ssa::recog (change)\n+    || !rtl_ssa::change_is_worthwhile (change))\n+  return false;\n+\n+confirm_change_group ();\n+crtl->ssa->change_insn (change);\n+@end smallexample\n+\n+@node Changing Multiple RTL SSA Instructions\n+@subsubsection Changing Multiple RTL SSA Instructions\n+\n+The process for changing multiple instructions is similar\n+to the process for changing single instructions\n+(@pxref{Changing One RTL SSA Instruction}).  The pass should\n+again start the change attempt with:\n+\n+@smallexample\n+auto attempt = crtl->ssa->new_change_attempt ();\n+@end smallexample\n+\n+and keep @code{attempt} in scope for the duration of the change\n+attempt.  It should then construct an @code{rtl_ssa::insn_change}\n+for each change that it wants to make.\n+\n+After this, it should combine the changes into a sequence of\n+@code{rtl_ssa::insn_change} pointers.  This sequence must be in\n+reverse postorder; the instructions will remain strictly in the\n+order that the sequence specifies.\n+\n+For example, if a pass is changing exactly two instructions,\n+it might do:\n+\n+@smallexample\n+rtl_ssa::insn_change *changes[] = @{ &change1, change2 @};\n+@end smallexample\n+\n+where @code{change1}'s instruction must come before @code{change2}'s.\n+Alternatively, if the pass is changing a variable number of\n+instructions, it might build up the sequence in a\n+@code{vec<rtl_ssa::insn_change *>}.\n+\n+By default, @code{rtl_ssa::restrict_movement} assumes that all\n+instructions other than the one passed to it will remain in their\n+current positions and will retain their current uses and definitions.\n+When changing multiple instructions, it is usually more effective\n+to ignore the other instructions that are changing.  The sequencing\n+described above ensures that the changing instructions remain\n+in the correct order with respect to each other.\n+The way to do this is:\n+\n+@smallexample\n+if (!rtl_ssa::restrict_movement (change, insn_is_changing (changes)))\n+  return false;\n+@end smallexample\n+\n+Similarly, when @code{rtl_ssa::restrict_movement} is detecting\n+whether a register can be clobbered, it by default assumes that\n+all other instructions will remain in their current positions and\n+retain their current form.  It is again more effective to ignore\n+changing instructions (which might, for example, no longer need\n+to clobber the flags register).  The way to do this is:\n+\n+@smallexample\n+if (!rtl_ssa::recog (change, insn_is_changing (changes)))\n+  return false;\n+@end smallexample\n+\n+When changing multiple instructions, the important question is usually\n+not whether each individual change is worthwhile, but whether the changes\n+as a whole are worthwhile.  The way to test this is:\n+\n+@smallexample\n+if (!rtl_ssa::changes_are_worthwhile (changes))\n+  return false;\n+@end smallexample\n+\n+The process for changing single instructions makes sure that one\n+@code{rtl_ssa::insn_change} in isolation is valid.  But when changing\n+multiple instructions, it is also necessary to test whether the\n+sequence as a whole is valid.  For example, it might be impossible\n+to satisfy all of the @code{move_range}s at once.\n+\n+Therefore, once the pass has a sequence of changes that are\n+individually correct, it should use:\n+\n+@smallexample\n+if (!crtl->ssa->verify_insn_changes (changes))\n+  return false;\n+@end smallexample\n+\n+to check whether the sequence as a whole is valid.  If all checks pass,\n+the final step is:\n+\n+@smallexample\n+confirm_change_group ();\n+crtl->ssa->change_insns (changes);\n+@end smallexample\n+\n+Putting all this together, the process for a two-instruction change is:\n+\n+@smallexample\n+auto attempt = crtl->ssa->new_change_attempt ();\n+\n+rtl_ssa::insn_change change (insn1);\n+change1.new_defs = @dots{};\n+change1.new_uses = @dots{};\n+change1.move_range = @dots{};\n+\n+rtl_ssa::insn_change change (insn2);\n+change2.new_defs = @dots{};\n+change2.new_uses = @dots{};\n+change2.move_range = @dots{};\n+\n+rtl_ssa::insn_change *changes[] = @{ &change1, change2 @};\n+\n+auto is_changing = insn_is_changing (changes);\n+if (!rtl_ssa::restrict_movement (change1, is_changing)\n+    || !rtl_ssa::restrict_movement (change2, is_changing))\n+  return false;\n+\n+insn_change_watermark watermark;\n+// Use validate_change etc. to change INSN1's and INSN2's patterns.\n+@dots{}\n+if (!rtl_ssa::recog (change1, is_changing)\n+    || !rtl_ssa::recog (change2, is_changing)\n+    || !rtl_ssa::changes_are_worthwhile (changes)\n+    || !crtl->ssa->verify_insn_changes (changes))\n+  return false;\n+\n+confirm_change_group ();\n+crtl->ssa->change_insns (changes);\n+@end smallexample\n+\n @node Sharing\n @section Structure Sharing Assumptions\n @cindex sharing of RTL components"}]}