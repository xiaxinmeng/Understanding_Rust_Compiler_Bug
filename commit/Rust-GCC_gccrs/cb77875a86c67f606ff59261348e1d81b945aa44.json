{"sha": "cb77875a86c67f606ff59261348e1d81b945aa44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I3Nzg3NWE4NmM2N2Y2MDZmZjU5MjYxMzQ4ZTFkODFiOTQ1YWE0NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-18T15:29:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-18T15:29:03Z"}, "message": "Two RTL CC tweaks for SVE pmore/plast conditions\n\nSVE has two composite conditions:\n\n  pmore == at least one bit set && last bit clear\n  plast == no bits set || last bit set\n\nSo in general we generate them from:\n\n  A: CC = test bits\n  B: reg1 = first condition\n  C: CC = test bits\n  D: reg2 = second condition\n  E: result = (reg1 op reg2)   where op is || or &&\n\nTo fold all this into a single test, we need to be able to remove\nthe redundant C (the cse.c patch) and then fold B, D and E down to\na single condition (the simplify-rtx.c patch).\n\nThe underlying conditions are unsigned, so the simplify-rtx.c part needs\nto support both unsigned comparisons and AND.  However, to avoid opening\nthe can of worms that is ANDing FP comparisons for unordered inputs,\nI've restricted the new AND handling to cases in which NaNs can be\nignored.  I think this is still a strict extension of what we have now,\nit just doesn't go as far as it could.  Going further would need an\nentirely different set of testcases so I think would make more sense\nas separate work.\n\n2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* cse.c (cse_insn): Delete no-op register moves too.\n\t* simplify-rtx.c (comparison_to_mask): Handle unsigned comparisons.\n\tTake a second comparison to control the value for NE.\n\t(mask_to_comparison): Handle unsigned comparisons.\n\t(simplify_logical_relational_operation): Likewise.  Update call\n\tto comparison_to_mask.  Handle AND if !HONOR_NANs.\n\t(simplify_binary_operation_1): Call the above for AND too.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/acle/asm/ptest_pmore.c: New test.\n\nFrom-SVN: r278411", "tree": {"sha": "dc574d98d522088958c22365f79fe15298902192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc574d98d522088958c22365f79fe15298902192"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb77875a86c67f606ff59261348e1d81b945aa44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb77875a86c67f606ff59261348e1d81b945aa44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb77875a86c67f606ff59261348e1d81b945aa44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb77875a86c67f606ff59261348e1d81b945aa44/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13c247d6f2a75b7e7a11546e897489716bc31506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c247d6f2a75b7e7a11546e897489716bc31506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c247d6f2a75b7e7a11546e897489716bc31506"}], "stats": {"total": 161, "additions": 140, "deletions": 21}, "files": [{"sha": "4198461c74e079282217e283ac5397f64bfc4fce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb77875a86c67f606ff59261348e1d81b945aa44", "patch": "@@ -1,3 +1,13 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* cse.c (cse_insn): Delete no-op register moves too.\n+\t* simplify-rtx.c (comparison_to_mask): Handle unsigned comparisons.\n+\tTake a second comparison to control the value for NE.\n+\t(mask_to_comparison): Handle unsigned comparisons.\n+\t(simplify_logical_relational_operation): Likewise.  Update call\n+\tto comparison_to_mask.  Handle AND if !HONOR_NANs.\n+\t(simplify_binary_operation_1): Call the above for AND too.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* fold-const.c (native_encode_vector): Turn into a wrapper function,"}, {"sha": "0ab79b916548114dab01b511d5bea01221c3ca4d", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=cb77875a86c67f606ff59261348e1d81b945aa44", "patch": "@@ -4625,7 +4625,7 @@ cse_insn (rtx_insn *insn)\n   for (i = 0; i < n_sets; i++)\n     {\n       bool repeat = false;\n-      bool mem_noop_insn = false;\n+      bool noop_insn = false;\n       rtx src, dest;\n       rtx src_folded;\n       struct table_elt *elt = 0, *p;\n@@ -5324,17 +5324,17 @@ cse_insn (rtx_insn *insn)\n \t    }\n \n \t  /* Similarly, lots of targets don't allow no-op\n-\t     (set (mem x) (mem x)) moves.  */\n+\t     (set (mem x) (mem x)) moves.  Even (set (reg x) (reg x))\n+\t     might be impossible for certain registers (like CC registers).  */\n \t  else if (n_sets == 1\n-\t\t   && MEM_P (trial)\n-\t\t   && MEM_P (dest)\n+\t\t   && (MEM_P (trial) || REG_P (trial))\n \t\t   && rtx_equal_p (trial, dest)\n \t\t   && !side_effects_p (dest)\n \t\t   && (cfun->can_delete_dead_exceptions\n \t\t       || insn_nothrow_p (insn)))\n \t    {\n \t      SET_SRC (sets[i].rtl) = trial;\n-\t      mem_noop_insn = true;\n+\t      noop_insn = true;\n \t      break;\n \t    }\n \n@@ -5562,8 +5562,8 @@ cse_insn (rtx_insn *insn)\n \t  sets[i].rtl = 0;\n \t}\n \n-      /* Similarly for no-op MEM moves.  */\n-      else if (mem_noop_insn)\n+      /* Similarly for no-op moves.  */\n+      else if (noop_insn)\n \t{\n \t  if (cfun->can_throw_non_call_exceptions && can_throw_internal (insn))\n \t    cse_cfg_altered = true;"}, {"sha": "f16516ede729d79ba00210d6ccd30dcf12ecd305", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=cb77875a86c67f606ff59261348e1d81b945aa44", "patch": "@@ -2125,12 +2125,17 @@ simplify_associative_operation (enum rtx_code code, machine_mode mode,\n   return 0;\n }\n \n-/* Return a mask describing the COMPARISON.  */\n+/* Return a mask describing the COMPARISON.  Treat NE as unsigned\n+   if OTHER_COMPARISON is.  */\n static int\n-comparison_to_mask (enum rtx_code comparison)\n+comparison_to_mask (rtx_code comparison, rtx_code other_comparison)\n {\n   switch (comparison)\n     {\n+    case LTU:\n+      return 32;\n+    case GTU:\n+      return 16;\n     case LT:\n       return 8;\n     case GT:\n@@ -2140,6 +2145,10 @@ comparison_to_mask (enum rtx_code comparison)\n     case UNORDERED:\n       return 1;\n \n+    case LEU:\n+      return 34;\n+    case GEU:\n+      return 18;\n     case LTGT:\n       return 12;\n     case LE:\n@@ -2156,7 +2165,10 @@ comparison_to_mask (enum rtx_code comparison)\n     case ORDERED:\n       return 14;\n     case NE:\n-      return 13;\n+      return (other_comparison == LTU\n+\t      || other_comparison == LEU\n+\t      || other_comparison == GTU\n+\t      || other_comparison == GEU ? 48 : 13);\n     case UNLE:\n       return 11;\n     case UNGE:\n@@ -2173,6 +2185,10 @@ mask_to_comparison (int mask)\n {\n   switch (mask)\n     {\n+    case 32:\n+      return LTU;\n+    case 16:\n+      return GTU;\n     case 8:\n       return LT;\n     case 4:\n@@ -2182,6 +2198,10 @@ mask_to_comparison (int mask)\n     case 1:\n       return UNORDERED;\n \n+    case 34:\n+      return LEU;\n+    case 18:\n+      return GEU;\n     case 12:\n       return LTGT;\n     case 10:\n@@ -2197,6 +2217,7 @@ mask_to_comparison (int mask)\n \n     case 14:\n       return ORDERED;\n+    case 48:\n     case 13:\n       return NE;\n     case 11:\n@@ -2216,8 +2237,9 @@ rtx\n simplify_logical_relational_operation (enum rtx_code code, machine_mode mode,\n \t\t\t\t       rtx op0, rtx op1)\n {\n-  /* We only handle IOR of two relational operations.  */\n-  if (code != IOR)\n+  /* We only handle AND if we can ignore unordered cases.  */\n+  bool honor_nans_p = HONOR_NANS (GET_MODE (op0));\n+  if (code != IOR && (code != AND || honor_nans_p))\n     return 0;\n \n   if (!(COMPARISON_P (op0) && COMPARISON_P (op1)))\n@@ -2230,18 +2252,20 @@ simplify_logical_relational_operation (enum rtx_code code, machine_mode mode,\n   enum rtx_code code0 = GET_CODE (op0);\n   enum rtx_code code1 = GET_CODE (op1);\n \n-  /* We don't handle unsigned comparisons currently.  */\n-  if (code0 == LTU || code0 == GTU || code0 == LEU || code0 == GEU)\n-    return 0;\n-  if (code1 == LTU || code1 == GTU || code1 == LEU || code1 == GEU)\n-    return 0;\n+  int mask0 = comparison_to_mask (code0, code1);\n+  int mask1 = comparison_to_mask (code1, code0);\n \n-  int mask0 = comparison_to_mask (code0);\n-  int mask1 = comparison_to_mask (code1);\n+  /* Reject combinations of signed and unsigned comparisons,\n+     with ORDERED being signed.  */\n+  if (((mask0 & 13) && (mask1 & 48)) || ((mask1 & 13) && (mask0 & 48)))\n+    return NULL_RTX;\n \n-  int mask = mask0 | mask1;\n+  int mask = (code == IOR ? mask0 | mask1 : mask0 & mask1);\n \n-  if (mask == 15)\n+  if (mask == 0)\n+    return const0_rtx;\n+\n+  if (mask == 50 || mask == 15)\n     return const_true_rtx;\n \n   code = mask_to_comparison (mask);\n@@ -3448,6 +3472,10 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \treturn tem;\n \n       tem = simplify_associative_operation (code, mode, op0, op1);\n+      if (tem)\n+\treturn tem;\n+\n+      tem = simplify_logical_relational_operation (code, mode, op0, op1);\n       if (tem)\n \treturn tem;\n       break;"}, {"sha": "3a37d94ae1473c84d94316724e0f0ddeb42eb1d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb77875a86c67f606ff59261348e1d81b945aa44", "patch": "@@ -1,3 +1,7 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/acle/asm/ptest_pmore.c: New test.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/acle/general/temporaries_1.c: New test."}, {"sha": "bdae9b8c5b50430949e7aa5681165a005191d897", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/asm/ptest_pmore.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fptest_pmore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb77875a86c67f606ff59261348e1d81b945aa44/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fptest_pmore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fptest_pmore.c?ref=cb77875a86c67f606ff59261348e1d81b945aa44", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-additional-options \"-msve-vector-bits=scalable\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"-DCHECK_ASM\" } } */\n+\n+#include \"test_sve_acle.h\"\n+#include <stdbool.h>\n+\n+/*\n+** test_bool_pmore:\n+**\tptest\tp0, p1\\.b\n+**\tcset\t[wx]0, pmore\n+**\tret\n+*/\n+TEST_PTEST (test_bool_pmore, bool,\n+\t    x0 = svptest_any (p0, p1) & !svptest_last (p0, p1));\n+\n+/*\n+** test_bool_plast:\n+**\tptest\tp0, p1\\.b\n+**\tcset\t[wx]0, plast\n+**\tret\n+*/\n+TEST_PTEST (test_bool_plast, bool,\n+\t    x0 = !svptest_any (p0, p1) | svptest_last (p0, p1));\n+\n+/*\n+** test_int_pmore:\n+**\tptest\tp0, p1\\.b\n+**\tcset\t[wx]0, pmore\n+**\tret\n+*/\n+TEST_PTEST (test_int_pmore, int,\n+\t    x0 = svptest_any (p0, p1) & !svptest_last (p0, p1));\n+\n+/*\n+** test_int_plast:\n+**\tptest\tp0, p1\\.b\n+**\tcset\t[wx]0, plast\n+**\tret\n+*/\n+TEST_PTEST (test_int_plast, int,\n+\t    x0 = !svptest_any (p0, p1) | svptest_last (p0, p1));\n+\n+/*\n+** test_int64_t_pmore:\n+**\tptest\tp0, p1\\.b\n+**\tcset\t[wx]0, pmore\n+**\tret\n+*/\n+TEST_PTEST (test_int64_t_pmore, int64_t,\n+\t    x0 = svptest_any (p0, p1) & !svptest_last (p0, p1));\n+\n+/*\n+** test_int64_t_plast:\n+**\tptest\tp0, p1\\.b\n+**\tcset\t[wx]0, plast\n+**\tret\n+*/\n+TEST_PTEST (test_int64_t_plast, int64_t,\n+\t    x0 = !svptest_any (p0, p1) | svptest_last (p0, p1));\n+\n+/*\n+** sel_pmore:\n+**\tptest\tp0, p1\\.b\n+**\tcsel\tx0, (x0, x1, pmore|x1, x0, plast)\n+**\tret\n+*/\n+TEST_PTEST (sel_pmore, int64_t,\n+\t    x0 = svptest_any (p0, p1) & !svptest_last (p0, p1) ? x0 : x1);\n+\n+/*\n+** sel_plast:\n+**\tptest\tp0, p1\\.b\n+**\tcsel\tx0, (x0, x1, plast|x1, x0, pmore)\n+**\tret\n+*/\n+TEST_PTEST (sel_plast, int64_t,\n+\t    x0 = !svptest_any (p0, p1) | svptest_last (p0, p1) ? x0 : x1);"}]}