{"sha": "416f403e615016c974f87ca41b23bf298dfed08f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2ZjQwM2U2MTUwMTZjOTc0Zjg3Y2E0MWIyM2JmMjk4ZGZlZDA4Zg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-09-20T13:59:38Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-09-20T13:59:38Z"}, "message": "tree-data-ref.c (get_number_of_iters_for_loop): New function.\n\n2005-09-18  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-data-ref.c (get_number_of_iters_for_loop): New function.\n\t(analyze_siv_subscript_cst_affine): Add weak SIV test.\n\t(compute_overlap_steps_for_affine_1_2): Use\n\tget_number_of_iters_for_loop.\n\t(analyze_subscript_affine_affine): Check whether difference is\n\tzero first.\n\tUse get_number_of_iters_for_loop.\n\tCheck whether overlap occurs outside of bounds.\n\t(analyze_miv_subscript): Use get_number_of_iters_for_loop.\n\nFrom-SVN: r104451", "tree": {"sha": "cee4ff5e4d92f47f2c14b58a47717ebab00b9208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cee4ff5e4d92f47f2c14b58a47717ebab00b9208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/416f403e615016c974f87ca41b23bf298dfed08f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416f403e615016c974f87ca41b23bf298dfed08f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416f403e615016c974f87ca41b23bf298dfed08f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416f403e615016c974f87ca41b23bf298dfed08f/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c95fbad89d6d8e6e6a78a25d7a1fb27e293f1af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c95fbad89d6d8e6e6a78a25d7a1fb27e293f1af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c95fbad89d6d8e6e6a78a25d7a1fb27e293f1af"}], "stats": {"total": 175, "additions": 110, "deletions": 65}, "files": [{"sha": "5051fd6a57fb038340a12954e747ae53472030fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416f403e615016c974f87ca41b23bf298dfed08f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416f403e615016c974f87ca41b23bf298dfed08f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=416f403e615016c974f87ca41b23bf298dfed08f", "patch": "@@ -1,3 +1,15 @@\n+2005-09-18  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-data-ref.c (get_number_of_iters_for_loop): New function.\n+\t(analyze_siv_subscript_cst_affine): Add weak SIV test.\n+\t(compute_overlap_steps_for_affine_1_2): Use\n+\tget_number_of_iters_for_loop.\n+\t(analyze_subscript_affine_affine): Check whether difference is\n+\tzero first.\n+\tUse get_number_of_iters_for_loop.\n+\tCheck whether overlap occurs outside of bounds.\n+\t(analyze_miv_subscript): Use get_number_of_iters_for_loop.\n+\n 2005-09-20  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* tree-ssa-address.c (create_mem_ref): Put the symbol reference into the"}, {"sha": "0ecb8a03894e8d3a09c164b74d7bcb5d10372cd0", "filename": "gcc/testsuite/gcc.dg/vect/vect-dv-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416f403e615016c974f87ca41b23bf298dfed08f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416f403e615016c974f87ca41b23bf298dfed08f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c?ref=416f403e615016c974f87ca41b23bf298dfed08f", "patch": "@@ -73,5 +73,5 @@ int main ()\n \n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e87d66458de9582b0020f85d1fea695beed86fb3", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 97, "deletions": 64, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416f403e615016c974f87ca41b23bf298dfed08f/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416f403e615016c974f87ca41b23bf298dfed08f/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=416f403e615016c974f87ca41b23bf298dfed08f", "patch": "@@ -2152,6 +2152,22 @@ analyze_ziv_subscript (tree chrec_a,\n     fprintf (dump_file, \")\\n\");\n }\n \n+/* Get the real or estimated number of iterations for LOOPNUM, whichever is\n+   available. Return the number of iterations as a tree, or NULL_TREE if\n+   we don't know.  */\n+\n+static tree\n+get_number_of_iters_for_loop (int loopnum)\n+{\n+  tree numiter = number_of_iterations_in_loop (current_loops->parray[loopnum]);\n+\n+  if (TREE_CODE (numiter) != INTEGER_CST)\n+    numiter = current_loops->parray[loopnum]->estimated_nb_iterations;\n+  if (chrec_contains_undetermined (numiter))\n+    return NULL_TREE;\n+  return numiter;\n+}\n+    \n /* Analyze a SIV (Single Index Variable) subscript where CHREC_A is a\n    constant, and CHREC_B is an affine function.  *OVERLAPS_A and\n    *OVERLAPS_B are initialized to the functions that describe the\n@@ -2200,13 +2216,31 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  \n \t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n+\t\t      tree numiter;\n+\t\t      int loopnum = CHREC_VARIABLE (chrec_b);\n+\n \t\t      *overlaps_a = integer_zero_node;\n \t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n \t\t\t\t\t\t fold_build1 (ABS_EXPR,\n \t\t\t\t\t\t\t      integer_type_node,\n \t\t\t\t\t\t\t      difference),\n \t\t\t\t\t\t CHREC_RIGHT (chrec_b));\n \t\t      *last_conflicts = integer_one_node;\n+\t\t      \n+\n+\t\t      /* Perform weak-zero siv test to see if overlap is\n+\t\t\t outside the loop bounds.  */\n+\t\t      numiter = get_number_of_iters_for_loop (loopnum);\n+\n+\t\t      if (numiter != NULL_TREE\n+\t\t\t  && TREE_CODE (*overlaps_b) == INTEGER_CST\n+\t\t\t  && tree_int_cst_lt (numiter, *overlaps_b))\n+\t\t\t{\n+\t\t\t  *overlaps_a = chrec_known;\n+\t\t\t  *overlaps_b = chrec_known;\n+\t\t\t  *last_conflicts = integer_zero_node;\n+\t\t\t  return;\n+\t\t\t}\t\t\n \t\t      return;\n \t\t    }\n \t\t  \n@@ -2254,11 +2288,28 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  */\n \t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n+\t\t      tree numiter;\n+\t\t      int loopnum = CHREC_VARIABLE (chrec_b);\n+\n \t\t      *overlaps_a = integer_zero_node;\n \t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR,\n \t\t\t\t      \t\t integer_type_node, difference, \n \t\t\t\t\t\t CHREC_RIGHT (chrec_b));\n \t\t      *last_conflicts = integer_one_node;\n+\n+\t\t      /* Perform weak-zero siv test to see if overlap is\n+\t\t\t outside the loop bounds.  */\n+\t\t      numiter = get_number_of_iters_for_loop (loopnum);\n+\n+\t\t      if (numiter != NULL_TREE\n+\t\t\t  && TREE_CODE (*overlaps_b) == INTEGER_CST\n+\t\t\t  && tree_int_cst_lt (numiter, *overlaps_b))\n+\t\t\t{\n+\t\t\t  *overlaps_a = chrec_known;\n+\t\t\t  *overlaps_b = chrec_known;\n+\t\t\t  *last_conflicts = integer_zero_node;\n+\t\t\t  return;\n+\t\t\t}\t\n \t\t      return;\n \t\t    }\n \t\t  \n@@ -2382,29 +2433,12 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n   step_y = int_cst_value (CHREC_RIGHT (chrec_a));\n   step_z = int_cst_value (CHREC_RIGHT (chrec_b));\n \n-  numiter_x = number_of_iterations_in_loop \n-    (current_loops->parray[CHREC_VARIABLE (CHREC_LEFT (chrec_a))]);\n-  numiter_y = number_of_iterations_in_loop \n-    (current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n-  numiter_z = number_of_iterations_in_loop \n-    (current_loops->parray[CHREC_VARIABLE (chrec_b)]);\n-\n-  if (TREE_CODE (numiter_x) != INTEGER_CST)\n-    numiter_x = current_loops->parray[CHREC_VARIABLE (CHREC_LEFT (chrec_a))]\n-      ->estimated_nb_iterations;\n-  if (TREE_CODE (numiter_y) != INTEGER_CST)\n-    numiter_y = current_loops->parray[CHREC_VARIABLE (chrec_a)]\n-      ->estimated_nb_iterations;\n-  if (TREE_CODE (numiter_z) != INTEGER_CST)\n-    numiter_z = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n-      ->estimated_nb_iterations;\n-\n-  if (chrec_contains_undetermined (numiter_x)\n-      || chrec_contains_undetermined (numiter_y)\n-      || chrec_contains_undetermined (numiter_z)\n-      || TREE_CODE (numiter_x) != INTEGER_CST\n-      || TREE_CODE (numiter_y) != INTEGER_CST\n-      || TREE_CODE (numiter_z) != INTEGER_CST)\n+  numiter_x = get_number_of_iters_for_loop (CHREC_VARIABLE (CHREC_LEFT (chrec_a)));\n+  numiter_y = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n+  numiter_z = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n+  \n+  if (numiter_x == NULL_TREE || numiter_y == NULL_TREE \n+      || numiter_z == NULL_TREE)\n     {\n       *overlaps_a = chrec_dont_know;\n       *overlaps_b = chrec_dont_know;\n@@ -2497,7 +2531,17 @@ analyze_subscript_affine_affine (tree chrec_a,\n   int init_a, init_b, gamma, gcd_alpha_beta;\n   int tau1, tau2;\n   lambda_matrix A, U, S;\n+  tree difference = chrec_fold_minus (integer_type_node, chrec_a, chrec_b);\n \n+  if (integer_zerop (difference))\n+    {\n+      /* The difference is equal to zero: the accessed index\n+\t overlaps for each iteration in the loop.  */\n+      *overlaps_a = integer_zero_node;\n+      *overlaps_b = integer_zero_node;\n+      *last_conflicts = chrec_dont_know;\n+      return;\n+    }\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_subscript_affine_affine \\n\");\n   \n@@ -2541,21 +2585,9 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  int niter, niter_a, niter_b;\n \t  tree numiter_a, numiter_b;\n \n-\t  numiter_a = number_of_iterations_in_loop \n-\t    (current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n-\t  numiter_b = number_of_iterations_in_loop \n-\t    (current_loops->parray[CHREC_VARIABLE (chrec_b)]);\n-\n-\t  if (TREE_CODE (numiter_a) != INTEGER_CST)\n-\t    numiter_a = current_loops->parray[CHREC_VARIABLE (chrec_a)]\n-\t      ->estimated_nb_iterations;\n-\t  if (TREE_CODE (numiter_b) != INTEGER_CST)\n-\t    numiter_b = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n-\t      ->estimated_nb_iterations;\n-\t  if (chrec_contains_undetermined (numiter_a)\n-\t      || chrec_contains_undetermined (numiter_b)\n-\t      || TREE_CODE (numiter_a) != INTEGER_CST\n-\t      || TREE_CODE (numiter_b) != INTEGER_CST)\n+\t  numiter_a = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n+\t  numiter_b = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n+\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n \t    {\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;\n@@ -2645,21 +2677,10 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  int niter, niter_a, niter_b;\n \t  tree numiter_a, numiter_b;\n \n-\t  numiter_a = number_of_iterations_in_loop \n-\t    (current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n-\t  numiter_b = number_of_iterations_in_loop \n-\t    (current_loops->parray[CHREC_VARIABLE (chrec_b)]);\n-\n-\t  if (TREE_CODE (numiter_a) != INTEGER_CST)\n-\t    numiter_a = current_loops->parray[CHREC_VARIABLE (chrec_a)]\n-\t      ->estimated_nb_iterations;\n-\t  if (TREE_CODE (numiter_b) != INTEGER_CST)\n-\t    numiter_b = current_loops->parray[CHREC_VARIABLE (chrec_b)]\n-\t      ->estimated_nb_iterations;\n-\t  if (chrec_contains_undetermined (numiter_a)\n-\t      || chrec_contains_undetermined (numiter_b)\n-\t      || TREE_CODE (numiter_a) != INTEGER_CST\n-\t      || TREE_CODE (numiter_b) != INTEGER_CST)\n+\t  numiter_a = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n+\t  numiter_b = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_b));\n+\n+\t  if (numiter_a == NULL_TREE || numiter_b == NULL_TREE)\n \t    {\n \t      *overlaps_a = chrec_dont_know;\n \t      *overlaps_b = chrec_dont_know;\n@@ -2715,15 +2736,27 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t\t      tau1 = (x0 - i0)/i1;\n \t\t      last_conflict = tau2 - tau1;\n \n-\t\t      *overlaps_a = build_polynomial_chrec\n-\t\t\t(1,\n-\t\t\t build_int_cst (NULL_TREE, x0),\n-\t\t\t build_int_cst (NULL_TREE, i1));\n-\t\t      *overlaps_b = build_polynomial_chrec\n-\t\t\t(1,\n-\t\t\t build_int_cst (NULL_TREE, y0),\n-\t\t\t build_int_cst (NULL_TREE, j1));\n-\t\t      *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n+\t\t      /* If the overlap occurs outside of the bounds of the\n+\t\t\t loop, there is no dependence.  */\n+\t\t      if (x0 > niter || y0  > niter)\n+\n+\t\t\t{\n+\t\t\t  *overlaps_a = chrec_known;\n+\t\t\t  *overlaps_b = chrec_known;\n+\t\t\t  *last_conflicts = integer_zero_node;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  *overlaps_a = build_polynomial_chrec\n+\t\t\t    (1,\n+\t\t\t     build_int_cst (NULL_TREE, x0),\n+\t\t\t     build_int_cst (NULL_TREE, i1));\n+\t\t\t  *overlaps_b = build_polynomial_chrec\n+\t\t\t    (1,\n+\t\t\t     build_int_cst (NULL_TREE, y0),\n+\t\t\t     build_int_cst (NULL_TREE, j1));\n+\t\t\t  *last_conflicts = build_int_cst (NULL_TREE, last_conflict);\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -2870,8 +2903,8 @@ analyze_miv_subscript (tree chrec_a,\n \t in the same order.  */\n       *overlaps_a = integer_zero_node;\n       *overlaps_b = integer_zero_node;\n-      *last_conflicts = number_of_iterations_in_loop \n-\t(current_loops->parray[CHREC_VARIABLE (chrec_a)]);\n+      *last_conflicts = get_number_of_iters_for_loop (CHREC_VARIABLE (chrec_a));\n+      \n     }\n   \n   else if (evolution_function_is_constant_p (difference)"}]}