{"sha": "b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmNzcyY2U4ZDMxNjk5NzRiNjAwZTRjM2YxNmI4MWY3YzY5YWIwYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-06-23T17:31:12Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-06-23T17:31:12Z"}, "message": "PR middle-end/PR36584\n\n\tPR middle-end/PR36584\n\t* calls.c (expand_call): Increase alignment for recursive functions.\n\ntestsuite/ChangeLog:\n\n\tPR middle-end/PR36584\n\t* testsuite/gcc.dg/pr36584.c: New test.\n\t* testsuite/gcc.target/i386/local2.c: Remove invalid test.\n\nFrom-SVN: r137045", "tree": {"sha": "82b2f6f39414af2b6ce011a0393ef291a7b05e3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b2f6f39414af2b6ce011a0393ef291a7b05e3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/comments", "author": null, "committer": null, "parents": [{"sha": "f9f6caf50d6a3ea1d66ee4df6a28a00395789842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f6caf50d6a3ea1d66ee4df6a28a00395789842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f6caf50d6a3ea1d66ee4df6a28a00395789842"}], "stats": {"total": 328, "additions": 296, "deletions": 32}, "files": [{"sha": "9ab80e03a9fac4794966e72389716ad215bb61bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "patch": "@@ -1,3 +1,8 @@\n+2008-06-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR middle-end/PR36584\n+\t* calls.c (expand_call): Increase alignment for recursive functions.\n+\n 2008-06-23  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/avr/avr.c (avr_function_value): Add new 'outgoing' argument.\n@@ -147,8 +152,7 @@\n \n \t* ggc.h (GGC_RESIZEVAR): New, reorder macros.\n \t* tracer.c (tail_duplicate): Fix for -Wc++-compat.\n-\t* tree-affine.c (aff_combination_expand, free_name_expansion):\n-\tLikewise.\n+\t* tree-affine.c (aff_combination_expand, free_name_expansion): Likewise.\n \t* tree-cfg.c (replace_by_duplicate_decl, replace_ssa_name,\n \tmove_stmt_r, new_label_mapper): Likewise.\n \t* tree-complex.c (cvc_lookup): Likewise."}, {"sha": "92ff9050e3bf4ea6414bb48971d4a73ff3ad875d", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "patch": "@@ -2298,11 +2298,9 @@ expand_call (tree exp, rtx target, int ignore)\n       || !lang_hooks.decls.ok_for_sibcall (fndecl))\n     try_tail_call = 0;\n \n-  /* Ensure current function's preferred stack boundary is at least\n-     what we need.  We don't have to increase alignment for recursive\n-     functions.  */\n-  if (crtl->preferred_stack_boundary < preferred_stack_boundary\n-      && fndecl != current_function_decl)\n+  /* Ensure current function's preferred stack\n+     boundary is at least what we need.  */\n+  if (crtl->preferred_stack_boundary < preferred_stack_boundary)\n     crtl->preferred_stack_boundary = preferred_stack_boundary;\n \n   preferred_unit_stack_boundary = preferred_stack_boundary / BITS_PER_UNIT;"}, {"sha": "a377829b6744e7b342eb323992713a69bce74de0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "patch": "@@ -1,3 +1,9 @@\n+2008-06-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR middle-end/PR36584\n+\t* testsuite/gcc.dg/pr36584.c: New test.\n+\t* testsuite/gcc.target/i386/local2.c: Remove invalid test.\n+\n 2008-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/36533"}, {"sha": "7d83ece3339d2a47a429ce548437095aa79e433a", "filename": "gcc/testsuite/gcc.dg/pr36584.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36584.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f772ce8d3169974b600e4c3f16b81f7c69ab0c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36584.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36584.c?ref=b5f772ce8d3169974b600e4c3f16b81f7c69ab0c", "patch": "@@ -0,0 +1,281 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -lm\" } */\n+/* { dg-options \"-O2 -msse2 -mfpmath=sse\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+\n+\n+#ifdef __i386__\n+#include \"cpuid.h\"\n+#endif\n+\n+extern double fabs (double);\n+extern void abort (void);\n+\n+const int MAX_ITERATIONS = 50;\n+const double SMALL_ENOUGH = 1.0e-10;\n+const double RELERROR = 1.0e-12;\n+\n+typedef struct p\n+{\n+  int ord;\n+  double coef[7];\n+}\n+polynomial;\n+\n+static double\n+polyeval (double x, int n, double *Coeffs)\n+{\n+  register int i;\n+  double val;\n+\n+  val = Coeffs[n];\n+  for (i = n - 1; i >= 0; i--)\n+    val = val * x + Coeffs[i];\n+\n+  return (val);\n+}\n+\n+static int\n+regula_falsa (int order, double *coef, double a, double b, double *val)\n+{\n+  int its;\n+  double fa, fb, x, fx, lfx;\n+\n+  fa = polyeval (a, order, coef);\n+  fb = polyeval (b, order, coef);\n+\n+  if (fa * fb > 0.0)\n+    return 0;\n+\n+  if (fabs (fa) < SMALL_ENOUGH)\n+    {\n+      *val = a;\n+      return 1;\n+    }\n+\n+  if (fabs (fb) < SMALL_ENOUGH)\n+    {\n+      *val = b;\n+      return 1;\n+    }\n+\n+  lfx = fa;\n+\n+  for (its = 0; its < MAX_ITERATIONS; its++)\n+    {\n+      x = (fb * a - fa * b) / (fb - fa);\n+      fx = polyeval (x, order, coef);\n+      if (fabs (x) > RELERROR)\n+\t{\n+\t  if (fabs (fx / x) < RELERROR)\n+\t    {\n+\t      *val = x;\n+\t      return 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (fabs (fx) < RELERROR)\n+\t    {\n+\t      *val = x;\n+\t      return 1;\n+\t    }\n+\t}\n+\n+      if (fa < 0)\n+\t{\n+\t  if (fx < 0)\n+\t    {\n+\t      a = x;\n+\t      fa = fx;\n+\t      if ((lfx * fx) > 0)\n+\t\tfb /= 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      b = x;\n+\t      fb = fx;\n+\t      if ((lfx * fx) > 0)\n+\t\tfa /= 2;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (fx < 0)\n+\t    {\n+\t      b = x;\n+\t      fb = fx;\n+\t      if ((lfx * fx) > 0)\n+\t\tfa /= 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      a = x;\n+\t      fa = fx;\n+\t      if ((lfx * fx) > 0)\n+\t\tfb /= 2;\n+\t    }\n+\t}\n+\n+      if (fabs (b - a) < RELERROR)\n+\t{\n+\t  *val = x;\n+\t  return 1;\n+\t}\n+\n+      lfx = fx;\n+    }\n+\n+  return 0;\n+}\n+\n+static int\n+numchanges (int np, polynomial * sseq, double a)\n+{\n+  int changes;\n+  double f, lf;\n+  polynomial *s;\n+  changes = 0;\n+\n+  lf = polyeval (a, sseq[0].ord, sseq[0].coef);\n+\n+  for (s = sseq + 1; s <= sseq + np; s++)\n+    {\n+      f = polyeval (a, s->ord, s->coef);\n+      if (lf == 0.0 || lf * f < 0)\n+\tchanges++;\n+\n+      lf = f;\n+    }\n+\n+  return changes;\n+}\n+\n+int\n+sbisect (int np, polynomial * sseq, double min_value, double max_value,\n+\t int atmin, int atmax, double *roots)\n+{\n+  double mid;\n+  int n1, n2, its, atmid;\n+\n+  if ((atmin - atmax) == 1)\n+    {\n+      if (regula_falsa (sseq->ord, sseq->coef, min_value, max_value, roots))\n+\treturn 1;\n+      else\n+\t{\n+\t  for (its = 0; its < MAX_ITERATIONS; its++)\n+\t    {\n+\t      mid = (min_value + max_value) / 2;\n+\t      atmid = numchanges (np, sseq, mid);\n+\t      if ((atmid < atmax) || (atmid > atmin))\n+\t\treturn 0;\n+\n+\t      if (fabs (mid) > RELERROR)\n+\t\t{\n+\t\t  if (fabs ((max_value - min_value) / mid) < RELERROR)\n+\t\t    {\n+\t\t      roots[0] = mid;\n+\t\t      return 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (fabs (max_value - min_value) < RELERROR)\n+\t\t    {\n+\t\t      roots[0] = mid;\n+\t\t      return 1;\n+\t\t    }\n+\t\t}\n+\n+\t      if ((atmin - atmid) == 0)\n+\t\tmin_value = mid;\n+\t      else\n+\t\tmax_value = mid;\n+\t    }\n+\n+\t  roots[0] = mid;\n+\t  return 1;\n+\t}\n+    }\n+\n+  for (its = 0; its < MAX_ITERATIONS; its++)\n+    {\n+      mid = (min_value + max_value) / 2;\n+      atmid = numchanges (np, sseq, mid);\n+      if ((atmid < atmax) || (atmid > atmin))\n+\treturn 0;\n+\n+      if (fabs (mid) > RELERROR)\n+\t{\n+\t  if (fabs ((max_value - min_value) / mid) < RELERROR)\n+\t    {\n+\t      roots[0] = mid;\n+\t      return 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (fabs (max_value - min_value) < RELERROR)\n+\t    {\n+\t      roots[0] = mid;\n+\t      return 1;\n+\t    }\n+\t}\n+\n+      n1 = atmin - atmid;\n+      n2 = atmid - atmax;\n+\n+      if ((n1 != 0) && (n2 != 0))\n+\t{\n+\t  n1 = sbisect (np, sseq, min_value, mid, atmin, atmid, roots);\n+\t  n2 = sbisect (np, sseq, mid, max_value, atmid, atmax, &roots[n1]);\n+\n+\t  return (n1 + n2);\n+\t}\n+\n+      if (n1 == 0)\n+\tmin_value = mid;\n+      else\n+\tmax_value = mid;\n+    }\n+\n+  roots[0] = mid;\n+  return 1;\n+}\n+\n+int\n+main ()\n+{\n+  polynomial sseq[7] = {\n+    {6, {0.15735259075109281, -5.1185263411378736, 1.8516070705868664,\n+\t 7.348009172322695, -2.2152395279161343, -2.7543325329350692, 1.0}},\n+    {5, {-0.8530877235229789, 0.61720235686228875, 3.6740045861613475,\n+\t -1.4768263519440896, -2.2952771107792245, 1.0}},\n+    {4, {0.13072124257049417, 2.2220687798791126, -1.6299431586726509,\n+\t -1.6718404582408546, 1.0}},\n+    {3, {0.86776597575462633, -2.1051099695282511, -0.49008580100694688,\n+\t 1.0}},\n+    {2, {-11.117984175064155, 10.89886635045883, 1.0}},\n+    {1, {0.94453099602191237, -1.0}},\n+    {0, {-0.068471716890574186}}\n+  };\n+\n+  double roots[7];\n+  int nroots;\n+\n+#ifdef __i386__\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    return 0;\n+\n+  if (!(edx & bit_SSE2))\n+    return 0;\n+#endif\n+\n+  nroots = sbisect (6, sseq, 0.0, 10000000.0, 5, 1, roots);\n+  if (nroots != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b6d960cbc120d5f06b277bd038c1d2a9e206cf45", "filename": "gcc/testsuite/gcc.target/i386/local2.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f6caf50d6a3ea1d66ee4df6a28a00395789842/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Flocal2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f6caf50d6a3ea1d66ee4df6a28a00395789842/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Flocal2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Flocal2.c?ref=f9f6caf50d6a3ea1d66ee4df6a28a00395789842", "patch": "@@ -1,25 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target ilp32 } */\n-/* { dg-require-effective-target nonpic } */\n-/* { dg-options \"-O2 -funit-at-a-time -fomit-frame-pointer\" } */\n-/* { dg-final { scan-assembler-not \"sub\\[^\\\\n\\]*sp\" } } */\n-\n-static __attribute__ ((noinline)) q ();\n-int a;\n-\n-/* This function should not require any stack manipulation\n-   for preferred stack bounday.  */\n-void\n-e ()\n-{\n-  if (a)\n-  {\n-    e ();\n-    a--;\n-  }\n-  q ();\n-}\n-\n-static __attribute__ ((noinline)) q ()\n-{\n-}"}]}