{"sha": "a624388b9546b066250be8baa118b7d50c403c25", "node_id": "C_kwDOANBUbNoAKGE2MjQzODhiOTU0NmIwNjYyNTBiZThiYWExMThiN2Q1MGM0MDNjMjU", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-03-09T09:35:14Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-03-22T13:35:34Z"}, "message": "[nvptx] Add warp sync at simt exit\n\nConsider this code (with N defined to 1024):\n...\n  float v = 0.0;\n  #pragma omp target map(tofrom: v)\n  #pragma omp parallel for simd\n  for (int i = 0 ; i < N; i++)\n    {\n      #pragma omp atomic update\n      v = v + 1.0;\n    }\n...\n\nIt hangs when executing on target board unix/-foffload=-misa=sm_75, using\ndrivers 470.103.01 and 510.54 on a T400 board (sm_75).\n\nI'm tentatively identifying the problem as a bug in -muniform-simt for\narchitectures that support Independent Thread Scheduling (sm_70 and later).\n\nThe problem -muniform-simt is trying to address is to make sure that a\nregister produced outside an openmp simd region is available when used in any\nlane inside an simd region.\n\nThe solution is to, outside an simd region, execute in all warp lanes, thus\nproducing consistent values in result registers in each warp thread.\n\nThis approach doesn't work when executing in all warp lanes multiplies the\nside effects from 1 to 32 separate side effects, which is the case for atomic\ninsns.  So atomic insns are rewritten to execute only in lane 0, and if\nthere are any results, those are propagated to the other threads in the warp.\n[ And likewise for system calls malloc, free, vprintf. ]\n\nNow, consider a non-atomic update: ld, add, store.  The store has side\neffects, are those multiplied or not?\n\nPre-sm_70 we can assume that at the end of an SIMT region, any divergent\ncontrol flow has reconverged, and we have a uniform warp, executing in lock\nstep.  So:\n- the load will load the same value into the result register across the warp,\n- the add will write the same value into the result register across the warp,\n- the store will write the same value to the same memory location, 32 times,\n  at once, having the result of a single store.\nSo, no side-effect multiplication (well, at least that's the observation).\n\nStarting sm_70, the threads in a warp are no longer guaranteed to reconverge\nafter divergence.  There's a \"Convergence Optimizer\" that can can identify\nthat it is safe for a warp to reconverge, but that works only as long as the\ncode does not contain \"synchronizing operations\".\n\nConsequently, the ld, add, store sequence can be executed by a non-uniform\nwarp, which means the side effects can have multiplied, and the registers are\nno longer guarantueed to be in sync.\n\nThe atomic update in the example above is translated using an atom.cas loop,\nwhich means that we have divergence (because only one thread is allowed to\nsucceed at a time) and the \"Convergence Optimizer\" doesn't reconverge probably\nbecause the atom.cas counts as a \"synchronizing operation\".  So, it seems\nplausible that the root cause for the mentioned hang is the problem described\nabove.\n\nFix this by adding an explicit warp sync at simt exit.\n\nNote that we're assuming here that the warp will stay uniform until the next\nSIMT region entry.\n\nTested on x86_64 with nvptx accelerator.\n\ngcc/ChangeLog:\n\n2022-03-09  Tom de Vries  <tdevries@suse.de>\n\n\tPR target/104916\n\tPR target/104783\n\t* config/nvptx/nvptx.md (define_expand \"omp_simt_exit\"): Emit warp\n\tsync (or uniform warp check for mptx < 6.0).\n\nlibgomp/ChangeLog:\n\n2022-03-15  Tom de Vries  <tdevries@suse.de>\n\n\tPR target/104916\n\tPR target/104783\n\t* testsuite/libgomp.c/pr104783-2.c: New test.", "tree": {"sha": "f2d1a3801a1f5ccc75571fe4a1d6cc611c6aae9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2d1a3801a1f5ccc75571fe4a1d6cc611c6aae9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a624388b9546b066250be8baa118b7d50c403c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a624388b9546b066250be8baa118b7d50c403c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a624388b9546b066250be8baa118b7d50c403c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a624388b9546b066250be8baa118b7d50c403c25/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08f263e703c4100fa7b9f08cb26cee6c0bd75e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08f263e703c4100fa7b9f08cb26cee6c0bd75e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08f263e703c4100fa7b9f08cb26cee6c0bd75e4a"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "5550ce255135760d50420352801ea228a74ab642", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a624388b9546b066250be8baa118b7d50c403c25/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a624388b9546b066250be8baa118b7d50c403c25/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=a624388b9546b066250be8baa118b7d50c403c25", "patch": "@@ -1881,6 +1881,10 @@\n   \"\"\n {\n   emit_insn (gen_omp_simt_exit (Pmode, operands[0]));\n+  if (TARGET_PTX_6_0)\n+    emit_insn (gen_nvptx_warpsync ());\n+  else\n+    emit_insn (gen_nvptx_uniform_warp_check ());\n   DONE;\n })\n "}, {"sha": "8750d915d01e642d8a43687168ffdc93235d962e", "filename": "libgomp/testsuite/libgomp.c/pr104783-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a624388b9546b066250be8baa118b7d50c403c25/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr104783-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a624388b9546b066250be8baa118b7d50c403c25/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr104783-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr104783-2.c?ref=a624388b9546b066250be8baa118b7d50c403c25", "patch": "@@ -0,0 +1,25 @@\n+#define N (32 * 32)\n+\n+#define TYPE float\n+#define VAR v\n+#define INIT 0.0\n+#define UPDATE + 1.0\n+#define EXPECTED N\n+\n+int\n+main (void)\n+{\n+  TYPE VAR = INIT;\n+  #pragma omp target map(tofrom: VAR)\n+  #pragma omp parallel for simd\n+  for (int i = 0 ; i < N; i++)\n+    {\n+      #pragma omp atomic update\n+      VAR = VAR UPDATE;\n+    }\n+\n+  if (VAR != EXPECTED)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}