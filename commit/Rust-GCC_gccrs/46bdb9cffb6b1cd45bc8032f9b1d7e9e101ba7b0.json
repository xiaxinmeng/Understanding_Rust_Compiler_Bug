{"sha": "46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZiZGI5Y2ZmYjZiMWNkNDViYzgwMzJmOWIxZDdlOWUxMDFiYTdiMA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-06-15T15:55:47Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-06-15T15:55:47Z"}, "message": "c-tree.h (default_function_array_conversion): Declare.\n\n\t* c-tree.h (default_function_array_conversion): Declare.\n\t* c-typeck.c (default_function_array_conversion): Export.  Correct\n\tcomment.\n\t(default_conversion): Do not call\n\tdefault_function_array_conversion.  Do not allow FUNCTION_TYPE.\n\t(build_function_call): Call default_function_array_conversion on\n\tthe function.\n\t(convert_arguments): Do not call it on the function arguments.\n\t(build_unary_op): Do not allow ARRAY_TYPE or FUNCTION_TYPE for\n\tTRUTH_NOT_EXPR.  Call default_function_array_conversion for taking\n\taddress of ARRAY_REF.\n\t(build_compound_expr): Do not call\n\tdefault_function_array_conversion.\n\t(build_c_cast): Do not call default_function_array_conversion.\n\t(convert_for_assignment): Do not call default_conversion.\n\t(digest_init): Call default_function_array_conversion to convert\n\tstring constants and compound literals to pointers, but not\n\totherwise.\n\t(output_init_element): Likewise.\n\t(build_asm_expr): Do not call default_function_array_conversion.\n\t(c_process_expr_stmt): Likewise.\n\t(c_objc_common_truthvalue_conversion): Likewise.  Do not allow\n\tFUNCTION_TYPE.\n\t* c-parser.c (c_parser_expression_conv): New.\n\t(c_parser_asm_operands, c_parser_expr_list): Add convert_p\n\targument.  All callers changed.  Call\n\tdefault_function_array_conversion if convert_p.\n\t(c_parser_initializer, c_parser_initval): Call\n\tdefault_function_array_conversion except for string constants and\n\tcompound literals.\n\t(c_parser_initelt): Call default_function_array_conversion for\n\tObjC expression received.\n\t(c_parser_statement_after_labels): Call c_parser_expression_conv\n\tfor return and expression statements.\n\t(c_parser_paren_condition, c_parser_for_statement,\n\tc_parser_conditional_expression): Call c_parser_expression_conv.\n\t(c_parser_expr_no_commas, c_parser_conditional_expression,\n\tc_parser_binary_expression, c_parser_cast_expression,\n\tc_parser_unary_expression): Call\n\tdefault_function_array_conversion.\n\nobjc:\n\t* objc-act.c (my_build_string_pointer): New.\n\t(objc_get_class_reference, get_super_receiver): Call\n\tmy_build_string_pointer instead of my_build_string when building\n\tfunction arguments.\n\ntestsuite:\n\t* gcc.dg/noncompile/20040203-3.c: Update expected message.\n\nFrom-SVN: r100984", "tree": {"sha": "1872e122192fae90234ef8f17d82cd485d62d6cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1872e122192fae90234ef8f17d82cd485d62d6cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e19e4c73b8614fb094c5c36abdd7da47a26a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e19e4c73b8614fb094c5c36abdd7da47a26a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e19e4c73b8614fb094c5c36abdd7da47a26a50"}], "stats": {"total": 320, "additions": 205, "deletions": 115}, "files": [{"sha": "dc88ef013484501a442ca117a9aa8802b309313c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -1,3 +1,46 @@\n+2005-06-15  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* c-tree.h (default_function_array_conversion): Declare.\n+\t* c-typeck.c (default_function_array_conversion): Export.  Correct\n+\tcomment.\n+\t(default_conversion): Do not call\n+\tdefault_function_array_conversion.  Do not allow FUNCTION_TYPE.\n+\t(build_function_call): Call default_function_array_conversion on\n+\tthe function.\n+\t(convert_arguments): Do not call it on the function arguments.\n+\t(build_unary_op): Do not allow ARRAY_TYPE or FUNCTION_TYPE for\n+\tTRUTH_NOT_EXPR.  Call default_function_array_conversion for taking\n+\taddress of ARRAY_REF.\n+\t(build_compound_expr): Do not call\n+\tdefault_function_array_conversion.\n+\t(build_c_cast): Do not call default_function_array_conversion.\n+\t(convert_for_assignment): Do not call default_conversion.\n+\t(digest_init): Call default_function_array_conversion to convert\n+\tstring constants and compound literals to pointers, but not\n+\totherwise.\n+\t(output_init_element): Likewise.\n+\t(build_asm_expr): Do not call default_function_array_conversion.\n+\t(c_process_expr_stmt): Likewise.\n+\t(c_objc_common_truthvalue_conversion): Likewise.  Do not allow\n+\tFUNCTION_TYPE.\n+\t* c-parser.c (c_parser_expression_conv): New.\n+\t(c_parser_asm_operands, c_parser_expr_list): Add convert_p\n+\targument.  All callers changed.  Call\n+\tdefault_function_array_conversion if convert_p.\n+\t(c_parser_initializer, c_parser_initval): Call\n+\tdefault_function_array_conversion except for string constants and\n+\tcompound literals.\n+\t(c_parser_initelt): Call default_function_array_conversion for\n+\tObjC expression received.\n+\t(c_parser_statement_after_labels): Call c_parser_expression_conv\n+\tfor return and expression statements.\n+\t(c_parser_paren_condition, c_parser_for_statement,\n+\tc_parser_conditional_expression): Call c_parser_expression_conv.\n+\t(c_parser_expr_no_commas, c_parser_conditional_expression,\n+\tc_parser_binary_expression, c_parser_cast_expression,\n+\tc_parser_unary_expression): Call\n+\tdefault_function_array_conversion.\n+\n 2005-06-15  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-vrp.c (vrp_int_const_binop): Do not handle MAX_EXPR"}, {"sha": "88b89e2804f7c3c8e20484356529dd995bd847de", "filename": "gcc/c-parser.c", "status": "modified", "additions": 100, "deletions": 41, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -904,7 +904,7 @@ static void c_parser_while_statement (c_parser *);\n static void c_parser_do_statement (c_parser *);\n static void c_parser_for_statement (c_parser *);\n static tree c_parser_asm_statement (c_parser *);\n-static tree c_parser_asm_operands (c_parser *);\n+static tree c_parser_asm_operands (c_parser *, bool);\n static tree c_parser_asm_clobbers (c_parser *);\n static struct c_expr c_parser_expr_no_commas (c_parser *, struct c_expr *);\n static struct c_expr c_parser_conditional_expression (c_parser *,\n@@ -920,7 +920,8 @@ static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,\n static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n \t\t\t\t\t\t\t\tstruct c_expr);\n static struct c_expr c_parser_expression (c_parser *);\n-static tree c_parser_expr_list (c_parser *);\n+static struct c_expr c_parser_expression_conv (c_parser *);\n+static tree c_parser_expr_list (c_parser *, bool);\n \n /* These Objective-C parser functions are only ever called when\n    compiling Objective-C.  */\n@@ -2749,15 +2750,15 @@ c_parser_attributes (c_parser *parser)\n \t\t{\n \t\t  c_parser_consume_token (parser);\n \t\t  attr_args = tree_cons (NULL_TREE, arg1,\n-\t\t\t\t\t c_parser_expr_list (parser));\n+\t\t\t\t\t c_parser_expr_list (parser, false));\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t\tattr_args = NULL_TREE;\n \t      else\n-\t\tattr_args = c_parser_expr_list (parser);\n+\t\tattr_args = c_parser_expr_list (parser, false);\n \t    }\n \t  attr = build_tree_list (attr_name, attr_args);\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -2874,7 +2875,14 @@ c_parser_initializer (c_parser *parser)\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     return c_parser_braced_init (parser, NULL_TREE, false);\n   else\n-    return c_parser_expr_no_commas (parser, NULL);\n+    {\n+      struct c_expr ret;\n+      ret = c_parser_expr_no_commas (parser, NULL);\n+      if (TREE_CODE (ret.value) != STRING_CST\n+\t  && TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)\n+\tret.value = default_function_array_conversion (ret.value);\n+      return ret;\n+    }\n }\n \n /* Parse a braced initializer list.  TYPE is the type specified for a\n@@ -3031,6 +3039,7 @@ c_parser_initelt (c_parser *parser)\n \t\t      tree next;\n \t\t      c_parser_consume_token (parser);\n \t\t      next = c_parser_expr_no_commas (parser, NULL).value;\n+\t\t      next = default_function_array_conversion (next);\n \t\t      rec = build_compound_expr (rec, next);\n \t\t    }\n \t\tparse_message_args:\n@@ -3116,7 +3125,13 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE) && !after)\n     init = c_parser_braced_init (parser, NULL_TREE, true);\n   else\n-    init = c_parser_expr_no_commas (parser, after);\n+    {\n+      init = c_parser_expr_no_commas (parser, after);\n+      if (init.value != NULL_TREE\n+\t  && TREE_CODE (init.value) != STRING_CST\n+\t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n+\tinit.value = default_function_array_conversion (init.value);\n+    }\n   process_init_element (init);\n }\n \n@@ -3498,7 +3513,7 @@ c_parser_statement_after_labels (c_parser *parser)\n \t    }\n \t  else\n \t    {\n-\t      stmt = c_finish_return (c_parser_expression (parser).value);\n+\t      stmt = c_finish_return (c_parser_expression_conv (parser).value);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -3546,7 +3561,7 @@ c_parser_statement_after_labels (c_parser *parser)\n       break;\n     default:\n     expr_stmt:\n-      stmt = c_finish_expr_stmt (c_parser_expression (parser).value);\n+      stmt = c_finish_expr_stmt (c_parser_expression_conv (parser).value);\n     expect_semicolon:\n       c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n       break;\n@@ -3579,7 +3594,7 @@ c_parser_paren_condition (c_parser *parser)\n     return error_mark_node;\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_objc_common_truthvalue_conversion\n-    (c_parser_expression (parser).value);\n+    (c_parser_expression_conv (parser).value);\n   if (EXPR_P (cond))\n     SET_EXPR_LOCATION (cond, loc);\n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -3814,7 +3829,7 @@ c_parser_for_statement (c_parser *parser)\n \t}\n       else\n \t{\n-\t  tree ocond = c_parser_expression (parser).value;\n+\t  tree ocond = c_parser_expression_conv (parser).value;\n \t  cond = c_objc_common_truthvalue_conversion (ocond);\n \t  if (EXPR_P (cond))\n \t    SET_EXPR_LOCATION (cond, loc);\n@@ -3910,7 +3925,7 @@ c_parser_asm_statement (c_parser *parser)\n       || c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n     outputs = NULL_TREE;\n   else\n-    outputs = c_parser_asm_operands (parser);\n+    outputs = c_parser_asm_operands (parser, false);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n     {\n       inputs = NULL_TREE;\n@@ -3928,7 +3943,7 @@ c_parser_asm_statement (c_parser *parser)\n       || c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n     inputs = NULL_TREE;\n   else\n-    inputs = c_parser_asm_operands (parser);\n+    inputs = c_parser_asm_operands (parser, true);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n     {\n       clobbers = NULL_TREE;\n@@ -3956,7 +3971,9 @@ c_parser_asm_statement (c_parser *parser)\n   return ret;\n }\n \n-/* Parse asm operands, a GNU extension.\n+/* Parse asm operands, a GNU extension.  If CONVERT_P (for inputs but\n+   not outputs), apply the default conversion of functions and arrays\n+   to pointers.\n \n    asm-operands:\n      asm-operand\n@@ -3968,7 +3985,7 @@ c_parser_asm_statement (c_parser *parser)\n */\n \n static tree\n-c_parser_asm_operands (c_parser *parser)\n+c_parser_asm_operands (c_parser *parser, bool convert_p)\n {\n   tree list = NULL_TREE;\n   while (true)\n@@ -4005,6 +4022,8 @@ c_parser_asm_operands (c_parser *parser)\n \t  return NULL_TREE;\n \t}\n       expr = c_parser_expression (parser).value;\n+      if (convert_p)\n+\texpr = default_function_array_conversion (expr);\n       c_lex_string_translate = 0;\n       if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n \t{\n@@ -4110,6 +4129,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n     }\n   c_parser_consume_token (parser);\n   rhs = c_parser_expr_no_commas (parser, NULL);\n+  rhs.value = default_function_array_conversion (rhs.value);\n   ret.value = build_modify_expr (lhs.value, code, rhs.value);\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n@@ -4143,6 +4163,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   cond = c_parser_binary_expression (parser, after);\n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n+  cond.value = default_function_array_conversion (cond.value);\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n@@ -4159,7 +4180,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \t= c_objc_common_truthvalue_conversion\n \t(default_conversion (cond.value));\n       skip_evaluation += cond.value == truthvalue_false_node;\n-      exp1 = c_parser_expression (parser);\n+      exp1 = c_parser_expression_conv (parser);\n       skip_evaluation += ((cond.value == truthvalue_true_node)\n \t\t\t  - (cond.value == truthvalue_false_node));\n     }\n@@ -4171,6 +4192,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       return ret;\n     }\n   exp2 = c_parser_conditional_expression (parser, NULL);\n+  exp2.value = default_function_array_conversion (exp2.value);\n   skip_evaluation -= cond.value == truthvalue_true_node;\n   ret.value = build_conditional_expr (cond.value, exp1.value, exp2.value);\n   ret.original_code = ERROR_MARK;\n@@ -4294,6 +4316,10 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       default:\t\t\t\t\t\t\t\t      \\\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       }\t\t\t\t\t\t\t\t\t      \\\n+    stack[sp - 1].expr.value\t\t\t\t\t\t      \\\n+      = default_function_array_conversion (stack[sp - 1].expr.value);\t      \\\n+    stack[sp].expr.value\t\t\t\t\t\t      \\\n+      = default_function_array_conversion (stack[sp].expr.value);\t      \\\n     stack[sp - 1].expr = parser_build_binary_op (stack[sp].op,\t\t      \\\n \t\t\t\t\t\t stack[sp - 1].expr,\t      \\\n \t\t\t\t\t\t stack[sp].expr);\t      \\\n@@ -4394,11 +4420,15 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       switch (ocode)\n \t{\n \tcase TRUTH_ANDIF_EXPR:\n+\t  stack[sp].expr.value\n+\t    = default_function_array_conversion (stack[sp].expr.value);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_false_node;\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n+\t  stack[sp].expr.value\n+\t    = default_function_array_conversion (stack[sp].expr.value);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_true_node;\n@@ -4456,6 +4486,7 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n \treturn c_parser_postfix_expression_after_paren_type (parser,\n \t\t\t\t\t\t\t     type_name);\n       expr = c_parser_cast_expression (parser, NULL).value;\n+      expr = default_function_array_conversion (expr);\n       ret.value = c_cast_expr (type_name, expr);\n       ret.original_code = ERROR_MARK;\n       return ret;\n@@ -4495,47 +4526,53 @@ static struct c_expr\n c_parser_unary_expression (c_parser *parser)\n {\n   int ext;\n-  struct c_expr ret;\n+  struct c_expr ret, op;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_PLUS_PLUS:\n       c_parser_consume_token (parser);\n-      return parser_build_unary_op (PREINCREMENT_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL));\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      return parser_build_unary_op (PREINCREMENT_EXPR, op);\n     case CPP_MINUS_MINUS:\n       c_parser_consume_token (parser);\n-      return parser_build_unary_op (PREDECREMENT_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL));\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      return parser_build_unary_op (PREDECREMENT_EXPR, op);\n     case CPP_AND:\n       c_parser_consume_token (parser);\n       return parser_build_unary_op (ADDR_EXPR,\n \t\t\t\t    c_parser_cast_expression (parser, NULL));\n     case CPP_MULT:\n       c_parser_consume_token (parser);\n-      ret.value\n-\t= build_indirect_ref (c_parser_cast_expression (parser, NULL).value,\n-\t\t\t      \"unary *\");\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      ret.value = build_indirect_ref (op.value, \"unary *\");\n       ret.original_code = ERROR_MARK;\n       return ret;\n     case CPP_PLUS:\n       c_parser_consume_token (parser);\n       if (!c_dialect_objc () && !in_system_header)\n \twarning (OPT_Wtraditional,\n \t\t \"traditional C rejects the unary plus operator\");\n-      return parser_build_unary_op (CONVERT_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL));\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      return parser_build_unary_op (CONVERT_EXPR, op);\n     case CPP_MINUS:\n       c_parser_consume_token (parser);\n-      return parser_build_unary_op (NEGATE_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL));\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      return parser_build_unary_op (NEGATE_EXPR, op);\n     case CPP_COMPL:\n       c_parser_consume_token (parser);\n-      return parser_build_unary_op (BIT_NOT_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL));\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      return parser_build_unary_op (BIT_NOT_EXPR, op);\n     case CPP_NOT:\n       c_parser_consume_token (parser);\n-      return parser_build_unary_op (TRUTH_NOT_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL));\n+      op = c_parser_cast_expression (parser, NULL);\n+      op.value = default_function_array_conversion (op.value);\n+      return parser_build_unary_op (TRUTH_NOT_EXPR, op);\n     case CPP_AND_AND:\n       /* Refer to the address of a label as a pointer.  */\n       c_parser_consume_token (parser);\n@@ -4567,14 +4604,14 @@ c_parser_unary_expression (c_parser *parser)\n \t  return ret;\n \tcase RID_REALPART:\n \t  c_parser_consume_token (parser);\n-\t  return parser_build_unary_op (REALPART_EXPR,\n-\t\t\t\t\tc_parser_cast_expression (parser,\n-\t\t\t\t\t\t\t\t  NULL));\n+\t  op = c_parser_cast_expression (parser, NULL);\n+\t  op.value = default_function_array_conversion (op.value);\n+\t  return parser_build_unary_op (REALPART_EXPR, op);\n \tcase RID_IMAGPART:\n \t  c_parser_consume_token (parser);\n-\t  return parser_build_unary_op (IMAGPART_EXPR,\n-\t\t\t\t\tc_parser_cast_expression (parser,\n-\t\t\t\t\t\t\t\t  NULL));\n+\t  op = c_parser_cast_expression (parser, NULL);\n+\t  op.value = default_function_array_conversion (op.value);\n+\t  return parser_build_unary_op (IMAGPART_EXPR, op);\n \tdefault:\n \t  return c_parser_postfix_expression (parser);\n \t}\n@@ -5204,7 +5241,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t    exprlist = NULL_TREE;\n \t  else\n-\t    exprlist = c_parser_expr_list (parser);\n+\t    exprlist = c_parser_expr_list (parser, true);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  expr.value = build_function_call (expr.value, exprlist);\n@@ -5213,6 +5250,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DOT:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n+\t  expr.value = default_function_array_conversion (expr.value);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -5229,6 +5267,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DEREF:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n+\t  expr.value = default_function_array_conversion (expr.value);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -5246,12 +5285,14 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n \t  c_parser_consume_token (parser);\n+\t  expr.value = default_function_array_conversion (expr.value);\n \t  expr.value = build_unary_op (POSTINCREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n \t  c_parser_consume_token (parser);\n+\t  expr.value = default_function_array_conversion (expr.value);\n \t  expr.value = build_unary_op (POSTDECREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n@@ -5278,30 +5319,48 @@ c_parser_expression (c_parser *parser)\n       struct c_expr next;\n       c_parser_consume_token (parser);\n       next = c_parser_expr_no_commas (parser, NULL);\n+      next.value = default_function_array_conversion (next.value);\n       expr.value = build_compound_expr (expr.value, next.value);\n       expr.original_code = COMPOUND_EXPR;\n     }\n   return expr;\n }\n \n-/* Parse a non-empty list of expressions.\n+/* Parse an expression and convert functions or arrays to\n+   pointers.  */\n+\n+static struct c_expr\n+c_parser_expression_conv (c_parser *parser)\n+{\n+  struct c_expr expr;\n+  expr = c_parser_expression (parser);\n+  expr.value = default_function_array_conversion (expr.value);\n+  return expr;\n+}\n+\n+/* Parse a non-empty list of expressions.  If CONVERT_P, convert\n+   functions and arrays to pointers.\n \n    nonempty-expr-list:\n      assignment-expression\n      nonempty-expr-list , assignment-expression\n */\n \n static tree\n-c_parser_expr_list (c_parser *parser)\n+c_parser_expr_list (c_parser *parser, bool convert_p)\n {\n   struct c_expr expr;\n   tree ret, cur;\n   expr = c_parser_expr_no_commas (parser, NULL);\n+  if (convert_p)\n+    expr.value = default_function_array_conversion (expr.value);\n   ret = cur = build_tree_list (NULL_TREE, expr.value);\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n       expr = c_parser_expr_no_commas (parser, NULL);\n+      if (convert_p)\n+\texpr.value = default_function_array_conversion (expr.value);\n       cur = TREE_CHAIN (cur) = build_tree_list (NULL_TREE, expr.value);\n     }\n   return ret;\n@@ -6162,7 +6221,7 @@ c_parser_objc_message_args (c_parser *parser)\n static tree\n c_parser_objc_keywordexpr (c_parser *parser)\n {\n-  tree list = c_parser_expr_list (parser);\n+  tree list = c_parser_expr_list (parser, true);\n   if (TREE_CHAIN (list) == NULL_TREE)\n     {\n       /* Just return the expression, remove a level of"}, {"sha": "e2e3bf8b26cbec733c19ae78ae95b513b1c11a11", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -523,6 +523,7 @@ extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (tree, tree);\n extern tree c_type_promotes_to (tree);\n extern tree default_conversion (tree);\n+extern tree default_function_array_conversion (tree);\n extern tree composite_type (tree, tree);\n extern tree build_component_ref (tree, tree);\n extern tree build_indirect_ref (tree, const char *);"}, {"sha": "7dcd577f5389a8b434a064e2cab7b0a69e752855", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 33, "deletions": 69, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -80,7 +80,6 @@ static int comp_target_types (tree, tree);\n static int function_types_compatible_p (tree, tree);\n static int type_lists_compatible_p (tree, tree);\n static tree decl_constant_value_for_broken_optimization (tree);\n-static tree default_function_array_conversion (tree);\n static tree lookup_field (tree, tree);\n static tree convert_arguments (tree, tree, tree, tree);\n static tree pointer_diff (tree, tree);\n@@ -1263,9 +1262,9 @@ decl_constant_value_for_broken_optimization (tree decl)\n \n /* Perform the default conversion of arrays and functions to pointers.\n    Return the result of converting EXP.  For any other expression, just\n-   return EXP.  */\n+   return EXP after removing NOPs.  */\n \n-static tree\n+tree\n default_function_array_conversion (tree exp)\n {\n   tree orig_exp;\n@@ -1410,8 +1409,7 @@ perform_integral_promotions (tree exp)\n \n \n /* Perform default promotions for C data used in expressions.\n-   Arrays and functions are converted to pointers;\n-   enumeral types or short or char, to int.\n+   Enumeral types or short or char are converted to int.\n    In addition, manifest constants symbols are replaced by their values.  */\n \n tree\n@@ -1421,8 +1419,10 @@ default_conversion (tree exp)\n   tree type = TREE_TYPE (exp);\n   enum tree_code code = TREE_CODE (type);\n \n-  if (code == FUNCTION_TYPE || code == ARRAY_TYPE)\n-    return default_function_array_conversion (exp);\n+  /* Functions and arrays have been converted during parsing.  */\n+  gcc_assert (code != FUNCTION_TYPE);\n+  if (code == ARRAY_TYPE)\n+    return exp;\n \n   /* Constants can be used directly unless they're not loadable.  */\n   if (TREE_CODE (exp) == CONST_DECL)\n@@ -1990,18 +1990,8 @@ build_function_call (tree function, tree params)\n \treturn tem;\n \n       name = DECL_NAME (function);\n-\n-      /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n-\t (because calling an inline function does not mean the function\n-\t needs to be separately compiled).  */\n-      fntype = build_type_variant (TREE_TYPE (function),\n-\t\t\t\t   TREE_READONLY (function),\n-\t\t\t\t   TREE_THIS_VOLATILE (function));\n-      fundecl = function;\n-      function = build1 (ADDR_EXPR, build_pointer_type (fntype), function);\n     }\n-  else\n-    function = default_conversion (function);\n+  function = default_function_array_conversion (function);\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n@@ -2163,8 +2153,6 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \n       STRIP_TYPE_NOPS (val);\n \n-      val = default_function_array_conversion (val);\n-\n       val = require_complete_type (val);\n \n       if (type != 0)\n@@ -2589,13 +2577,9 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      /* ??? Why do most validation here but that for non-lvalue arrays\n-\t in c_objc_common_truthvalue_conversion?  */\n       if (typecode != INTEGER_TYPE\n \t  && typecode != REAL_TYPE && typecode != POINTER_TYPE\n-\t  && typecode != COMPLEX_TYPE\n-\t  /* These will convert to a pointer.  */\n-\t  && typecode != ARRAY_TYPE && typecode != FUNCTION_TYPE)\n+\t  && typecode != COMPLEX_TYPE)\n \t{\n \t  error (\"wrong type argument to unary exclamation mark\");\n \t  return error_mark_node;\n@@ -2736,7 +2720,9 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t{\n \t  if (!c_mark_addressable (TREE_OPERAND (arg, 0)))\n \t    return error_mark_node;\n-\t  return build_binary_op (PLUS_EXPR, TREE_OPERAND (arg, 0),\n+\t  return build_binary_op (PLUS_EXPR,\n+\t\t\t\t  default_function_array_conversion\n+\t\t\t\t    (TREE_OPERAND (arg, 0)),\n \t\t\t\t  TREE_OPERAND (arg, 1), 1);\n \t}\n \n@@ -3115,9 +3101,6 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n tree\n build_compound_expr (tree expr1, tree expr2)\n {\n-  /* Convert arrays and functions to pointers.  */\n-  expr2 = default_function_array_conversion (expr2);\n-\n   if (!TREE_SIDE_EFFECTS (expr1))\n     {\n       /* The left-hand operand of a comma expression is like an expression\n@@ -3189,7 +3172,6 @@ build_c_cast (tree type, tree expr)\n   else if (TREE_CODE (type) == UNION_TYPE)\n     {\n       tree field;\n-      value = default_function_array_conversion (value);\n \n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (field)),\n@@ -3217,14 +3199,9 @@ build_c_cast (tree type, tree expr)\n     {\n       tree otype, ovalue;\n \n-      /* If casting to void, avoid the error that would come\n-\t from default_conversion in the case of a non-lvalue array.  */\n       if (type == void_type_node)\n \treturn build1 (CONVERT_EXPR, type, value);\n \n-      /* Convert functions and arrays to pointers,\n-\t but don't convert any other types.  */\n-      value = default_function_array_conversion (value);\n       otype = TREE_TYPE (value);\n \n       /* Optionally warn about potentially worrisome casts.  */\n@@ -3558,10 +3535,8 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \n   STRIP_TYPE_NOPS (rhs);\n \n-  if (TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n-      || TREE_CODE (TREE_TYPE (rhs)) == FUNCTION_TYPE)\n-    rhs = default_conversion (rhs);\n-  else if (optimize && TREE_CODE (rhs) == VAR_DECL)\n+  if (optimize && TREE_CODE (rhs) == VAR_DECL\n+\t   && TREE_CODE (TREE_TYPE (rhs)) != ARRAY_TYPE)\n     rhs = decl_constant_value_for_broken_optimization (rhs);\n \n   rhstype = TREE_TYPE (rhs);\n@@ -4373,15 +4348,13 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t  || (code == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n \t      && comptypes (TREE_TYPE (TREE_TYPE (inside_init)),\n-\t\t\t    TREE_TYPE (type)))\n-\t  || (code == POINTER_TYPE\n-\t      && TREE_CODE (TREE_TYPE (inside_init)) == FUNCTION_TYPE\n-\t      && comptypes (TREE_TYPE (inside_init),\n \t\t\t    TREE_TYPE (type)))))\n     {\n       if (code == POINTER_TYPE)\n \t{\n-\t  inside_init = default_function_array_conversion (inside_init);\n+\t  if (TREE_CODE (inside_init) == STRING_CST\n+\t      || TREE_CODE (inside_init) == COMPOUND_LITERAL_EXPR)\n+\t    inside_init = default_function_array_conversion (inside_init);\n \n \t  if (TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE)\n \t    {\n@@ -4448,9 +4421,9 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n       || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n       || code == VECTOR_TYPE)\n     {\n-      /* Note that convert_for_assignment calls default_conversion\n-\t for arrays and functions.  We must not call it in the\n-\t case where inside_init is a null pointer constant.  */\n+      if (TREE_CODE (init) == STRING_CST\n+\t  || TREE_CODE (init) == COMPOUND_LITERAL_EXPR)\n+\tinit = default_function_array_conversion (init);\n       inside_init\n \t= convert_for_assignment (type, init, ic_init,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n@@ -5800,14 +5773,15 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n       constructor_erroneous = 1;\n       return;\n     }\n-  if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n-      || (TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n-\t  && !(TREE_CODE (value) == STRING_CST\n-\t       && TREE_CODE (type) == ARRAY_TYPE\n-\t       && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n-\t  && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n-\t\t\t TYPE_MAIN_VARIANT (type))))\n-    value = default_conversion (value);\n+  if (TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n+      && (TREE_CODE (value) == STRING_CST\n+\t  || TREE_CODE (value) == COMPOUND_LITERAL_EXPR)\n+      && !(TREE_CODE (value) == STRING_CST\n+\t   && TREE_CODE (type) == ARRAY_TYPE\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n+      && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n+\t\t     TYPE_MAIN_VARIANT (type)))\n+    value = default_function_array_conversion (value);\n \n   if (TREE_CODE (value) == COMPOUND_LITERAL_EXPR\n       && require_constant_value && !flag_isoc99 && pending)\n@@ -6519,18 +6493,13 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n       TREE_VALUE (tail) = output;\n     }\n \n-  /* Perform default conversions on array and function inputs.\n-     Don't do this for other types as it would screw up operands\n-     expected to be in memory.  */\n   for (i = 0, tail = inputs; tail; ++i, tail = TREE_CHAIN (tail))\n     {\n       tree input;\n \n       constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n       input = TREE_VALUE (tail);\n \n-      input = default_function_array_conversion (input);\n-\n       if (parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n \t\t\t\t  oconstraints, &allows_mem, &allows_reg))\n \t{\n@@ -7084,13 +7053,6 @@ c_process_expr_stmt (tree expr)\n   if (!expr)\n     return NULL_TREE;\n \n-  /* Do default conversion if safe and possibly important,\n-     in case within ({...}).  */\n-  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-       && (flag_isoc99 || lvalue_p (expr)))\n-      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n-    expr = default_conversion (expr);\n-\n   if (warn_sequence_point)\n     verify_sequence_points (expr);\n \n@@ -8107,12 +8069,11 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \n /* Convert EXPR to be a truth-value, validating its type for this\n-   purpose.  Passes EXPR to default_function_array_conversion.  */\n+   purpose.  */\n \n tree\n c_objc_common_truthvalue_conversion (tree expr)\n {\n-  expr = default_function_array_conversion (expr);\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n     case ARRAY_TYPE:\n@@ -8127,6 +8088,9 @@ c_objc_common_truthvalue_conversion (tree expr)\n       error (\"used union type value where scalar is required\");\n       return error_mark_node;\n \n+    case FUNCTION_TYPE:\n+      gcc_unreachable ();\n+\n     default:\n       break;\n     }"}, {"sha": "d9eb3d15f8d6af7b1527b2cbed8ea160a02ee503", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -1,3 +1,10 @@\n+2005-06-15  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* objc-act.c (my_build_string_pointer): New.\n+\t(objc_get_class_reference, get_super_receiver): Call\n+\tmy_build_string_pointer instead of my_build_string when building\n+\tfunction arguments.\n+\n 2005-05-25  Mike Stump  <mrs@mrs.kithrup.com>\n \n \t* objc-act.c (volatilized_hash): Avoid warnings on 64-bit"}, {"sha": "3329318ef2a42adbc3e1a88365abb0f6f8130401", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -1722,6 +1722,16 @@ my_build_string (int len, const char *str)\n   return fix_string_type (build_string (len, str));\n }\n \n+/* Build a string with contents STR and length LEN and convert it to a\n+   pointer.  */\n+\n+static tree\n+my_build_string_pointer (int len, const char *str)\n+{\n+  tree string = my_build_string (len, str);\n+  tree ptrtype = build_pointer_type (TREE_TYPE (TREE_TYPE (string)));\n+  return build1 (ADDR_EXPR, ptrtype, string);\n+}\n \n static hashval_t\n string_hash (const void *ptr)\n@@ -2699,8 +2709,9 @@ objc_get_class_reference (tree ident)\n       add_class_reference (ident);\n \n       params = build_tree_list (NULL_TREE,\n-\t\t\t\tmy_build_string (IDENTIFIER_LENGTH (ident) + 1,\n-\t\t\t\t\t\t IDENTIFIER_POINTER (ident)));\n+\t\t\t\tmy_build_string_pointer\n+\t\t\t\t(IDENTIFIER_LENGTH (ident) + 1,\n+\t\t\t\t IDENTIFIER_POINTER (ident)));\n \n       assemble_external (objc_get_class_decl);\n       return build_function_call (objc_get_class_decl, params);\n@@ -8641,8 +8652,9 @@ get_super_receiver (void)\n \t\t  (super_class,\n \t\t   build_tree_list\n \t\t   (NULL_TREE,\n-\t\t    my_build_string (IDENTIFIER_LENGTH (super_name) + 1,\n-\t\t\t\t     IDENTIFIER_POINTER (super_name))));\n+\t\t    my_build_string_pointer\n+\t\t    (IDENTIFIER_LENGTH (super_name) + 1,\n+\t\t     IDENTIFIER_POINTER (super_name))));\n \t    }\n \n \t  super_expr"}, {"sha": "adcfe2dd5adcd73fbb8e102174e45bc7ad7c3ec9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -1,3 +1,7 @@\n+2005-06-15  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/20040203-3.c: Update expected message.\n+\n 2005-06-15  David Ung  <davidu@mips.com>\n \n \t* gcc.target/mips/mips16e-extends.c: New test for testing the"}, {"sha": "5b90c3ee84499dfed0defb4812ab6a4d0f3eaab0", "filename": "gcc/testsuite/gcc.dg/noncompile/20040203-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20040203-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20040203-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20040203-3.c?ref=46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "patch": "@@ -12,5 +12,5 @@ int bug_or(void) { return (f().c || 1); }  /* { dg-error \"array that cannot be c\n int bug_and(void) { return (f().c && 1); }  /* { dg-error \"array that cannot be converted\" } */\n int bug_cond(void) { return (f().c ? 1 : 0); }  /* { dg-error \"array that cannot be converted\" } */\n int bug_cond2(void) { return (f().c ? : 0); }  /* { dg-error \"array that cannot be converted\" } */\n-int bug_not(void) { return !f().c; }  /* { dg-error \"array that cannot be converted\" } */\n+int bug_not(void) { return !f().c; }  /* { dg-error \"wrong type argument to unary exclamation mark\" } */\n int bug_bool(void) { return (_Bool) f().c; }  /* { dg-error \"array that cannot be converted\" } */"}]}