{"sha": "20f292863f6ed230335c443893d4db664a8140d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBmMjkyODYzZjZlZDIzMDMzNWM0NDM4OTNkNGRiNjY0YTgxNDBkMA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T03:18:00Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T03:18:00Z"}, "message": "c++: Diagnose unstable satisfaction\n\nThis implements lightweight heuristical detection and diagnosing of\nsatisfaction whose result changes at different points in the program,\nwhich renders the program ill-formed NDR as of P2104.  We've recently\nstarted to more aggressively cache satisfaction results, and so the goal\nwith this patch is to make this caching behavior more transparent to\nthe user.\n\nA satisfaction result is flagged as \"potentially unstable\" (at the atom\ngranularity) if during its computation, some type completion failure\noccurs.  This is detected by making complete_type_or_maybe_complain\nincrement a counter upon failure and comparing the value of the counter\nbefore and after satisfaction.  (We don't instrument complete_type\ndirectly because it's used \"opportunistically\" in many spots where type\ncompletion failure doesn't necessary lead to substitution failure.)\n\nSuch flagged satisfaction results are always recomputed from scratch,\neven when performing satisfaction quietly.  When saving a satisfaction\nresult, we now compare the computed result with the cached result, and\nif they differ, proceed with diagnosing the instability.\n\nMost of the implementation is confined to the satisfaction_cache class,\nwhich has been completely rewritten.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (failed_type_completion_count): New.\n\t(note_failed_type_completion_for_satisfaction): New.\n\t(sat_entry::constr): Rename to ...\n\t(sat_entry::atom): ... this.\n\t(sat_entry::location): New member.\n\t(sat_entry::maybe_unstable): New member.\n\t(sat_entry::diagnose_instability): New member.\n\t(struct sat_hasher): Adjust after the above renaming.\n\t(get_satisfaction, save_satisfaction): Remove.\n\t(satisfaction_cache): Rewrite completely.\n\t(satisfy_atom): When instantiation of the parameter mapping\n\tfails, set diagnose_instability.  Propagate location from\n\tinst_cache.entry to cache.entry if the secondary lookup\n\tsucceeded.\n\t(satisfy_declaration_constraints): When\n\tfailed_type_completion_count differs before and after\n\tsatisfaction, then don't cache the satisfaction result.\n\t* cp-tree.h (note_failed_type_completion_for_satisfaction):\n\tDeclare.\n\t* pt.c (tsubst) <case TYPENAME_TYPE>: Use\n\tcomplete_type_or_maybe_complain instead of open-coding it.\n\t* typeck.c (complete_type_or_maybe_complain): Call\n\tnote_failed_type_completion_for_satisfaction when type\n\tcompletion fails.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-complete1.C: New test.\n\t* g++.dg/cpp2a/concepts-complete2.C: New test.\n\t* g++.dg/cpp2a/concepts-complete3.C: New test.", "tree": {"sha": "5d32236d1e1f15d7837bc0abacdbfb1698755c71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d32236d1e1f15d7837bc0abacdbfb1698755c71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20f292863f6ed230335c443893d4db664a8140d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f292863f6ed230335c443893d4db664a8140d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20f292863f6ed230335c443893d4db664a8140d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20f292863f6ed230335c443893d4db664a8140d0/comments", "author": null, "committer": null, "parents": [{"sha": "cd69e3d5cd61a6d9ea68b673528a6f55c03b57fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd69e3d5cd61a6d9ea68b673528a6f55c03b57fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd69e3d5cd61a6d9ea68b673528a6f55c03b57fa"}], "stats": {"total": 334, "additions": 273, "deletions": 61}, "files": [{"sha": "47cf882a704c477487dc7de72c2fbbf35c477341", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 211, "deletions": 54, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -2374,35 +2374,82 @@ tsubst_parameter_mapping (tree map, tree args, tsubst_flags_t complain, tree in_\n                         Constraint satisfaction\n ---------------------------------------------------------------------------*/\n \n-/* Hash functions for satisfaction entries.  */\n+/* A counter incremented by note_failed_type_completion_for_satisfaction().\n+   It's used by the satisfaction caches in order to flag \"potentially unstable\"\n+   satisfaction results.  */\n+\n+static unsigned failed_type_completion_count;\n+\n+/* Called whenever a type completion failure occurs that definitely affects\n+   the semantics of the program, by e.g. inducing substitution failure.  */\n+\n+void\n+note_failed_type_completion_for_satisfaction (tree type)\n+{\n+  gcc_checking_assert (!COMPLETE_TYPE_P (type));\n+  if (CLASS_TYPE_P (type)\n+      && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+    /* After instantiation, a class template specialization that's\n+       incomplete will remain incomplete, so for our purposes we can\n+       ignore this completion failure event.  */;\n+  else\n+    ++failed_type_completion_count;\n+}\n+\n+/* Hash functions and data types for satisfaction cache entries.  */\n \n struct GTY((for_user)) sat_entry\n {\n-  tree constr;\n+  /* The relevant ATOMIC_CONSTR.  */\n+  tree atom;\n+\n+  /* The relevant template arguments.  */\n   tree args;\n+\n+  /* The result of satisfaction of ATOM+ARGS.\n+     This is either boolean_true_node, boolean_false_node or error_mark_node,\n+     where error_mark_node indicates ill-formed satisfaction.\n+     It's set to NULL_TREE while computing satisfaction of ATOM+ARGS for\n+     the first time.  */\n   tree result;\n+\n+  /* The value of input_location when satisfaction of ATOM+ARGS was first\n+     performed.  */\n+  location_t location;\n+\n+  /* True if this satisfaction result is flagged as \"potentially unstable\",\n+     i.e. the result might change at different points in the program if\n+     recomputed from scratch (which would be ill-formed).  This flag controls\n+     whether to recompute a cached satisfaction result from scratch even when\n+     evaluating quietly.  */\n+  bool maybe_unstable;\n+\n+  /* True if we want to diagnose the above instability when it's detected.\n+     We don't always want to do so, in order to avoid emitting duplicate\n+     diagnostics in some cases.  */\n+  bool diagnose_instability;\n };\n \n struct sat_hasher : ggc_ptr_hash<sat_entry>\n {\n   static hashval_t hash (sat_entry *e)\n   {\n-    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e->constr))\n+    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e->atom))\n       {\n \t/* Atoms with instantiated mappings are built during satisfaction.\n \t   They live only inside the sat_cache, and we build one to query\n \t   the cache with each time we instantiate a mapping.  */\n \tgcc_assert (!e->args);\n-\treturn hash_atomic_constraint (e->constr);\n+\treturn hash_atomic_constraint (e->atom);\n       }\n \n     /* Atoms with uninstantiated mappings are built during normalization.\n        Since normalize_atom caches the atoms it returns, we can assume\n        pointer-based identity for fast hashing and comparison.  Even if this\n        assumption is violated, that's okay, we'll just get a cache miss.  */\n-    hashval_t value = htab_hash_pointer (e->constr);\n+    hashval_t value = htab_hash_pointer (e->atom);\n \n-    if (tree map = ATOMIC_CONSTR_MAP (e->constr))\n+    if (tree map = ATOMIC_CONSTR_MAP (e->atom))\n       /* Only the parameters that are used in the targets of the mapping\n \t affect the satisfaction value of the atom.  So we consider only\n \t the arguments for these parameters, and ignore the rest.  */\n@@ -2421,21 +2468,21 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n \n   static bool equal (sat_entry *e1, sat_entry *e2)\n   {\n-    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e1->constr)\n-\t!= ATOMIC_CONSTR_MAP_INSTANTIATED_P (e2->constr))\n+    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e1->atom)\n+\t!= ATOMIC_CONSTR_MAP_INSTANTIATED_P (e2->atom))\n       return false;\n \n     /* See sat_hasher::hash.  */\n-    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e1->constr))\n+    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e1->atom))\n       {\n \tgcc_assert (!e1->args && !e2->args);\n-\treturn atomic_constraints_identical_p (e1->constr, e2->constr);\n+\treturn atomic_constraints_identical_p (e1->atom, e2->atom);\n       }\n \n-    if (e1->constr != e2->constr)\n+    if (e1->atom != e2->atom)\n       return false;\n \n-    if (tree map = ATOMIC_CONSTR_MAP (e1->constr))\n+    if (tree map = ATOMIC_CONSTR_MAP (e1->atom))\n       for (tree target_parms = TREE_TYPE (map);\n \t   target_parms;\n \t   target_parms = TREE_CHAIN (target_parms))\n@@ -2458,58 +2505,145 @@ static GTY((deletable)) hash_table<sat_hasher> *sat_cache;\n /* Cache the result of constraint_satisfaction_value.  */\n static GTY((deletable)) hash_map<tree, tree> *decl_satisfied_cache;\n \n-static tree\n-get_satisfaction (tree constr, tree args)\n+/* A tool used by satisfy_atom to help manage satisfaction caching and to\n+   diagnose \"unstable\" satisfaction values.  We insert into the cache only\n+   when performing satisfaction quietly.  */\n+\n+struct satisfaction_cache\n {\n-  if (!sat_cache)\n-    return NULL_TREE;\n-  sat_entry elt = { constr, args, NULL_TREE };\n-  sat_entry* found = sat_cache->find (&elt);\n-  if (found)\n-    return found->result;\n-  else\n-    return NULL_TREE;\n-}\n+  satisfaction_cache (tree, tree, sat_info);\n+  tree get ();\n+  tree save (tree);\n \n-static void\n-save_satisfaction (tree constr, tree args, tree result)\n+  sat_entry *entry;\n+  sat_info info;\n+  unsigned ftc_count;\n+};\n+\n+/* Constructor for the satisfaction_cache class.  We're performing satisfaction\n+   of ATOM+ARGS according to INFO.  */\n+\n+satisfaction_cache\n+::satisfaction_cache (tree atom, tree args, sat_info info)\n+  : entry(nullptr), info(info), ftc_count(failed_type_completion_count)\n {\n   if (!sat_cache)\n     sat_cache = hash_table<sat_hasher>::create_ggc (31);\n-  sat_entry elt = {constr, args, result};\n-  sat_entry** slot = sat_cache->find_slot (&elt, INSERT);\n-  sat_entry* entry = ggc_alloc<sat_entry> ();\n-  *entry = elt;\n-  *slot = entry;\n+\n+  /* When noisy, we query the satisfaction cache in order to diagnose\n+     \"unstable\" satisfaction values.  */\n+  if (info.noisy ())\n+    {\n+      /* When noisy, constraints have been re-normalized, and that breaks the\n+\t pointer-based identity assumption of sat_cache (for atoms with\n+\t uninstantiated mappings).  So undo this re-normalization by looking in\n+\t the atom_cache for the corresponding atom that was used during quiet\n+\t satisfaction.  */\n+      if (!ATOMIC_CONSTR_MAP_INSTANTIATED_P (atom))\n+\t{\n+\t  if (tree found = atom_cache->find (atom))\n+\t    atom = found;\n+\t  else\n+\t    /* The lookup should always succeed, but if it fails then let's\n+\t       just leave 'entry' empty, effectively disabling the cache.  */\n+\t    return;\n+\t}\n+    }\n+\n+  /* Look up or create the corresponding satisfaction entry.  */\n+  sat_entry elt;\n+  elt.atom = atom;\n+  elt.args = args;\n+  sat_entry **slot = sat_cache->find_slot (&elt, INSERT);\n+  if (*slot)\n+    entry = *slot;\n+  else if (info.quiet ())\n+    {\n+      entry = ggc_alloc<sat_entry> ();\n+      entry->atom = atom;\n+      entry->args = args;\n+      entry->result = NULL_TREE;\n+      entry->location = input_location;\n+      entry->maybe_unstable = false;\n+      entry->diagnose_instability = false;\n+      if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (atom))\n+\t/* We always want to diagnose instability of an atom with an\n+\t   instantiated parameter mapping.  For atoms with an uninstantiated\n+\t   mapping, we set this flag (in satisfy_atom) only if substitution\n+\t   into its mapping previously failed.  */\n+\tentry->diagnose_instability = true;\n+      *slot = entry;\n+    }\n+  else\n+    /* We shouldn't get here, but if we do, let's just leave 'entry'\n+       empty, effectively disabling the cache.  */\n+    return;\n }\n \n-/* A tool to help manage satisfaction caching in satisfy_constraint_r.\n-   Note the cache is only used when not diagnosing errors.  */\n+/* Returns the cached satisfaction result if we have one and we're not\n+   recomputing the satisfaction result from scratch.  Otherwise returns\n+   NULL_TREE.  */\n \n-struct satisfaction_cache\n+tree\n+satisfaction_cache::get ()\n {\n-  satisfaction_cache (tree constr, tree args, tsubst_flags_t complain)\n-    : constr(constr), args(args), complain(complain)\n-  { }\n+  if (!entry)\n+    return NULL_TREE;\n \n-  tree get ()\n-  {\n-    if (complain == tf_none)\n-      return get_satisfaction (constr, args);\n+  if (info.noisy () || entry->maybe_unstable)\n+    /* We're recomputing the satisfaction result from scratch.  */\n     return NULL_TREE;\n-  }\n+  else\n+    return entry->result;\n+}\n \n-  tree save (tree result)\n-  {\n-    if (complain == tf_none)\n-      save_satisfaction (constr, args, result);\n+/* RESULT is the computed satisfaction result.  If RESULT differs from the\n+   previously cached result, this routine issues an appropriate error.\n+   Otherwise, when evaluating quietly, updates the cache appropriately.  */\n+\n+tree\n+satisfaction_cache::save (tree result)\n+{\n+  if (!entry)\n     return result;\n-  }\n \n-  tree constr;\n-  tree args;\n-  tsubst_flags_t complain;\n-};\n+  if (entry->result && result != entry->result)\n+    {\n+      if (info.quiet ())\n+\t/* Return error_mark_node to force satisfaction to get replayed\n+\t   noisily.  */\n+\treturn error_mark_node;\n+      else\n+\t{\n+\t  if (entry->diagnose_instability)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      error_at (EXPR_LOCATION (ATOMIC_CONSTR_EXPR (entry->atom)),\n+\t\t\t\"satisfaction value of atomic constraint %qE changed \"\n+\t\t\t\"from %qE to %qE\", entry->atom, entry->result, result);\n+\t      inform (entry->location,\n+\t\t      \"satisfaction value first evaluated to %qE from here\",\n+\t\t      entry->result);\n+\t    }\n+\t  /* For sake of error recovery, allow this latest satisfaction result\n+\t     to prevail.  */\n+\t  entry->result = result;\n+\t  return result;\n+\t}\n+    }\n+\n+  if (info.quiet ())\n+    {\n+      entry->result = result;\n+      /* We heuristically flag this satisfaction result as potentially unstable\n+\t iff during its computation, completion of a type failed.  Note that\n+\t this may also clear the flag if the result turned out to be\n+\t independent of the previously detected type completion failure.  */\n+      entry->maybe_unstable = (ftc_count != failed_type_completion_count);\n+    }\n+\n+  return result;\n+}\n \n static int satisfying_constraint = 0;\n \n@@ -2722,7 +2856,7 @@ static void diagnose_atomic_constraint (tree, tree, tree, subst_info);\n static tree\n satisfy_atom (tree t, tree args, sat_info info)\n {\n-  satisfaction_cache cache (t, args, info.complain);\n+  satisfaction_cache cache (t, args, info);\n   if (tree r = cache.get ())\n     return r;\n \n@@ -2742,6 +2876,11 @@ satisfy_atom (tree t, tree args, sat_info info)\n \t not satisfied.  Replay the substitution.  */\n       if (info.diagnose_unsatisfaction_p ())\n \ttsubst_parameter_mapping (ATOMIC_CONSTR_MAP (t), args, info);\n+      if (info.quiet ())\n+\t/* Since instantiation of the parameter mapping failed, we\n+\t   want to diagnose potential instability of this satisfaction\n+\t   result.  */\n+\tcache.entry->diagnose_instability = true;\n       return cache.save (boolean_false_node);\n     }\n \n@@ -2753,9 +2892,12 @@ satisfy_atom (tree t, tree args, sat_info info)\n   ATOMIC_CONSTR_MAP (t) = map;\n   gcc_assert (!ATOMIC_CONSTR_MAP_INSTANTIATED_P (t));\n   ATOMIC_CONSTR_MAP_INSTANTIATED_P (t) = true;\n-  satisfaction_cache inst_cache (t, /*args=*/NULL_TREE, info.complain);\n+  satisfaction_cache inst_cache (t, /*args=*/NULL_TREE, info);\n   if (tree r = inst_cache.get ())\n-    return cache.save (r);\n+    {\n+      cache.entry->location = inst_cache.entry->location;\n+      return cache.save (r);\n+    }\n \n   /* Rebuild the argument vector from the parameter mapping.  */\n   args = get_mapped_args (map);\n@@ -2946,6 +3088,8 @@ satisfy_declaration_constraints (tree t, sat_info info)\n       norm = normalize_nontemplate_requirements (t, info.noisy ());\n     }\n \n+  unsigned ftc_count = failed_type_completion_count;\n+\n   tree result = boolean_true_node;\n   if (norm)\n     {\n@@ -2957,7 +3101,20 @@ satisfy_declaration_constraints (tree t, sat_info info)\n       pop_tinst_level ();\n     }\n \n-  if (info.quiet ())\n+  /* True if this satisfaction is (heuristically) potentially unstable, i.e.\n+     if its result may depend on where in the program it was performed.  */\n+  bool maybe_unstable_satisfaction = false;\n+\n+  if (ftc_count != failed_type_completion_count)\n+    /* Type completion failure occurred during satisfaction.  The satisfaction\n+       result may (or may not) materially depend on the completeness of a type,\n+       so we consider it potentially unstable.   */\n+    maybe_unstable_satisfaction = true;\n+\n+  if (maybe_unstable_satisfaction)\n+    /* Don't cache potentially unstable satisfaction, to allow satisfy_atom\n+       to check the stability the next time around.  */;\n+  else if (info.quiet ())\n     hash_map_safe_put<hm_ggc> (decl_satisfied_cache, saved_t, result);\n \n   return result;"}, {"sha": "b4fb3deb6d35d96316e9fb8cfcea8cf177e78c72", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -8128,6 +8128,8 @@ extern hashval_t iterative_hash_constraint      (tree, hashval_t);\n extern hashval_t hash_atomic_constraint         (tree);\n extern void diagnose_constraints                (location_t, tree, tree);\n \n+extern void note_failed_type_completion_for_satisfaction (tree);\n+\n /* A structural hasher for ATOMIC_CONSTRs.  */\n \n struct atom_hasher : default_hash_traits<tree>"}, {"sha": "ce2e8797aae6244c07776b91ea61240b72d5e337", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -16002,13 +16002,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t       But, such constructs have already been resolved by this\n \t       point, so here CTX really should have complete type, unless\n \t       it's a partial instantiation.  */\n-\t    ctx = complete_type (ctx);\n-\t    if (!COMPLETE_TYPE_P (ctx))\n-\t      {\n-\t\tif (complain & tf_error)\n-\t\t  cxx_incomplete_type_error (NULL_TREE, ctx);\n-\t\treturn error_mark_node;\n-\t      }\n+\t    if (!complete_type_or_maybe_complain (ctx, NULL_TREE, complain))\n+\t      return error_mark_node;\n \t  }\n \n \tf = make_typename_type (ctx, f, typename_type,"}, {"sha": "c41457bcce8c625187c4df9d0b738ceb137ff30d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -154,6 +154,7 @@ complete_type_or_maybe_complain (tree type, tree value, tsubst_flags_t complain)\n     {\n       if (complain & tf_error)\n \tcxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n+      note_failed_type_completion_for_satisfaction (type);\n       return NULL_TREE;\n     }\n   else"}, {"sha": "e8487bf9c0918d3d5b7ea9b5b3e6e38e3aae3087", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-complete1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete1.C?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -0,0 +1,18 @@\n+// Verify we diagnose an unstable satisfaction result that depends on\n+// completeness of the type A below.\n+//\n+// { dg-do compile { target c++20 } }\n+\n+template <class T> concept has_mem_type = requires { typename T::type; };\n+// { dg-message \"satisfaction of 'has_mem_type<T>' .with T = A.\" \"\" { target *-*-* } .-1 }\n+// { dg-error \"satisfaction value of atomic constraint 'requires.typename T::type;. .with T = A.' changed from 'false' to 'true'\" \"\" { target *-*-* } .-2 }\n+\n+template <has_mem_type T> int f () { return 0; }\n+template <class T> char f() { return 0; }\n+\n+struct A;\n+static_assert (sizeof (f<A>()) == 1); // { dg-message \"first evaluated to 'false' from here\" }\n+struct A { typedef int type; };\n+static_assert (sizeof (f<A>()) > 1); // { dg-error \"assert\" }\n+// { dg-message \"required from here\" \"\" { target *-*-* } .-1 }\n+static_assert (sizeof (f<A>()) > 1);"}, {"sha": "b2c1160673756e73102b9f3081949195e5f59dfa", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-complete2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete2.C?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -0,0 +1,23 @@\n+// Verify we diagnose an unstable satisfaction result that depends on\n+// completeness of the type A below.\n+//\n+// Like in the previous test, here satisfaction also initially fails,\n+// but this time due to failed substitution into the atom's parameter mapping.\n+//\n+// { dg-do compile { target c++20 } }\n+\n+template <class T> concept valid_type = requires { typename T; };\n+// { dg-message \"satisfaction of 'valid_type<typename T::type>' .with T = A.\" \"\" { target *-*-* } .-1 }\n+// { dg-error \"satisfaction value of atomic constraint 'requires.T;. .with T = typename T::type.' changed from 'false' to 'true'\" \"\" { target *-*-* } .-2 }\n+\n+template <class T> concept has_mem_type = valid_type<typename T::type>;\n+// { dg-message \"satisfaction of 'has_mem_type<T>' .with T = A.\" \"\" { target *-*-* } .-1 }\n+\n+template <has_mem_type T> int f () { return 0; }\n+template <class T> char f() { return 0; }\n+\n+struct A;\n+static_assert (sizeof (f<A>()) == 1); // { dg-message \"first evaluated to 'false' from here\" }\n+struct A { typedef int type; };\n+static_assert (sizeof (f<A>()) > 1); // { dg-error \"assert\" }\n+static_assert (sizeof (f<A>()) > 1);"}, {"sha": "5b07371a6be4fb76136834436790d0e73b255e87", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-complete3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20f292863f6ed230335c443893d4db664a8140d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-complete3.C?ref=20f292863f6ed230335c443893d4db664a8140d0", "patch": "@@ -0,0 +1,16 @@\n+// Verify we diagnose an unstable satisfaction result that depends on\n+// return type deduction of the member function A::foo() below.\n+//\n+// { dg-do compile { target c++20 } }\n+\n+template <class T> concept fooable = requires (T t) { t.foo(); };\n+// { dg-error \"'false' to 'true'\" \"\" { target *-*-* } .-1 }\n+\n+template <fooable T> int f () { return 0; }\n+template <class T> char f() { return 0; }\n+\n+struct A { auto foo(); };\n+static_assert (sizeof (f<A>()) == 1); // { dg-message \"first evaluated to 'false' from here\" }\n+auto A::foo() { }\n+static_assert (sizeof (f<A>()) > 1); // { dg-error \"assert\" }\n+static_assert (sizeof (f<A>()) > 1);"}]}