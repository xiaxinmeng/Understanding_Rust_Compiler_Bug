{"sha": "2a3398e1245426f04592cf53a21bde8befa6f3ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzMzk4ZTEyNDU0MjZmMDQ1OTJjZjUzYTIxYmRlOGJlZmE2ZjNhZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-26T19:10:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-26T19:10:26Z"}, "message": "cp-tree.h (begin_init_stmts, [...]): Remove.\n\n\t* cp-tree.h (begin_init_stmts, finish_init_stmts): Remove.\n\t(begin_global_stmt_expr, finish_global_stmt_expr): Remove.\n\t* init.c (begin_init_stmts): Make static. Return is_global\n\tvalue. Always call begin_stmt_expr.\n\t(finish_init_stmts): Make static. Add is_global parm. Always\n\tbuilding a stmt tree.\n\t(build_aggr_init): Adjust begin_init_stmts, finish_init_stmts calls.\n\t(build_vec_init): Likewise. Always building a stmt tree.\n\t(expand_default_init): Always building a stmt tree.\n\t(get_temp_regvar): Likewise.\n\t* semantics.c (begin_global_stmt_expr,\n\tfinish_global_stmt_expr): Remove.\n\nFrom-SVN: r69830", "tree": {"sha": "b5fef0e9e96ec251d4eacefa562073b7516cd36a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5fef0e9e96ec251d4eacefa562073b7516cd36a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a3398e1245426f04592cf53a21bde8befa6f3ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3398e1245426f04592cf53a21bde8befa6f3ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3398e1245426f04592cf53a21bde8befa6f3ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3398e1245426f04592cf53a21bde8befa6f3ae/comments", "author": null, "committer": null, "parents": [{"sha": "11a004efdb03c8b44723cd8a995f16c55247b1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11a004efdb03c8b44723cd8a995f16c55247b1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11a004efdb03c8b44723cd8a995f16c55247b1bb"}], "stats": {"total": 127, "additions": 29, "deletions": 98}, "files": [{"sha": "20fc8fc47960ca315e7e4d29ca3f0f69ef80f7e2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3398e1245426f04592cf53a21bde8befa6f3ae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3398e1245426f04592cf53a21bde8befa6f3ae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2a3398e1245426f04592cf53a21bde8befa6f3ae", "patch": "@@ -3891,8 +3891,6 @@ extern void push_base_cleanups\t\t\t(void);\n extern tree build_vbase_delete\t\t\t(tree, tree);\n extern tree build_vec_delete\t\t\t(tree, tree, special_function_kind, int);\n extern tree create_temporary_var                (tree);\n-extern void begin_init_stmts                    (tree *, tree *);\n-extern tree finish_init_stmts                   (tree, tree);\n extern void initialize_vtbl_ptrs                (tree);\n extern tree build_java_class_ref                (tree);\n \n@@ -4178,8 +4176,6 @@ extern tree do_poplevel                         (void);\n extern void finish_mem_initializers             (tree);\n extern void setup_vtbl_ptr\t\t\t(tree, tree);\n extern void clear_out_block                     (void);\n-extern tree begin_global_stmt_expr              (void);\n-extern tree finish_global_stmt_expr             (tree);\n extern tree check_template_template_default_arg (tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);"}, {"sha": "bf4a592ab9f14faab5745b42363cdc2b02e00d18", "filename": "gcc/cp/init.c", "status": "modified", "additions": 29, "deletions": 65, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3398e1245426f04592cf53a21bde8befa6f3ae/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3398e1245426f04592cf53a21bde8befa6f3ae/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2a3398e1245426f04592cf53a21bde8befa6f3ae", "patch": "@@ -35,6 +35,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n \n+static bool begin_init_stmts (tree *, tree *);\n+static tree finish_init_stmts (bool, tree, tree);\n static void construct_virtual_base (tree, tree);\n static void expand_aggr_init_1 (tree, tree, tree, tree, int);\n static void expand_default_init (tree, tree, tree, tree, int);\n@@ -64,40 +66,31 @@ static tree build_vtbl_address (tree);\n    pass them back to finish_init_stmts when the expression is\n    complete.  */\n \n-void\n+static bool\n begin_init_stmts (tree *stmt_expr_p, tree *compound_stmt_p)\n {\n-  if (building_stmt_tree ())\n-    *stmt_expr_p = begin_stmt_expr ();\n-  else\n-    *stmt_expr_p = begin_global_stmt_expr ();\n+  bool is_global = !building_stmt_tree ();\n   \n-  if (building_stmt_tree ())\n-    *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n+  *stmt_expr_p = begin_stmt_expr ();\n+  *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n+\n+  return is_global;\n }\n \n /* Finish out the statement-expression begun by the previous call to\n    begin_init_stmts.  Returns the statement-expression itself.  */\n \n-tree\n-finish_init_stmts (tree stmt_expr, tree compound_stmt)\n+static tree\n+finish_init_stmts (bool is_global, tree stmt_expr, tree compound_stmt)\n {  \n-  if (building_stmt_tree ())\n-    finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n-  \n-  if (building_stmt_tree ())\n-    {\n-      stmt_expr = finish_stmt_expr (stmt_expr);\n-      STMT_EXPR_NO_SCOPE (stmt_expr) = true;\n-    }\n-  else\n-    stmt_expr = finish_global_stmt_expr (stmt_expr);\n+  finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n   \n-  /* To avoid spurious warnings about unused values, we set \n-     TREE_USED.  */\n-  if (stmt_expr)\n-    TREE_USED (stmt_expr) = 1;\n+  stmt_expr = finish_stmt_expr (stmt_expr);\n+  STMT_EXPR_NO_SCOPE (stmt_expr) = true;\n+  TREE_USED (stmt_expr) = 1;\n \n+  my_friendly_assert (!building_stmt_tree () == is_global, 20030726);\n+  \n   return stmt_expr;\n }\n \n@@ -1045,6 +1038,7 @@ build_aggr_init (tree exp, tree init, int flags)\n   tree type = TREE_TYPE (exp);\n   int was_const = TREE_READONLY (exp);\n   int was_volatile = TREE_THIS_VOLATILE (exp);\n+  int is_global;\n \n   if (init == error_mark_node)\n     return error_mark_node;\n@@ -1098,12 +1092,12 @@ build_aggr_init (tree exp, tree init, int flags)\n     TREE_USED (exp) = 1;\n \n   TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n-  begin_init_stmts (&stmt_expr, &compound_stmt);\n+  is_global = begin_init_stmts (&stmt_expr, &compound_stmt);\n   destroy_temps = stmts_are_full_exprs_p ();\n   current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n   expand_aggr_init_1 (TYPE_BINFO (type), exp, exp,\n \t\t      init, LOOKUP_NORMAL|flags);\n-  stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n+  stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);\n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   TREE_TYPE (exp) = type;\n   TREE_READONLY (exp) = was_const;\n@@ -1200,12 +1194,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n \n   rval = build_special_member_call (exp, ctor_name, parms, binfo, flags);\n   if (TREE_SIDE_EFFECTS (rval))\n-    {\n-      if (building_stmt_tree ())\n-\tfinish_expr_stmt (rval);\n-      else\n-\tgenrtl_expr_stmt (rval);\n-    }\n+    finish_expr_stmt (rval);\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -2377,10 +2366,8 @@ get_temp_regvar (tree type, tree init)\n   tree decl;\n \n   decl = create_temporary_var (type);\n-  if (building_stmt_tree ())\n-    add_decl_stmt (decl);\n-  else\n-    SET_DECL_RTL (decl, assign_temp (type, 2, 0, 1));\n+  add_decl_stmt (decl);\n+  \n   finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \n   return decl;\n@@ -2422,7 +2409,8 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n   tree try_block = NULL_TREE;\n   tree try_body = NULL_TREE;\n   int num_initialized_elts = 0;\n-\n+  bool is_global;\n+  \n   if (TYPE_DOMAIN (atype))\n     maxindex = array_type_nelts (atype);\n \n@@ -2483,7 +2471,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n      of whatever cleverness the back-end has for dealing with copies\n      of blocks of memory.  */\n \n-  begin_init_stmts (&stmt_expr, &compound_stmt);\n+  is_global = begin_init_stmts (&stmt_expr, &compound_stmt);\n   destroy_temps = stmts_are_full_exprs_p ();\n   current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n   rval = get_temp_regvar (ptype, base);\n@@ -2578,20 +2566,6 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n       /* Otherwise, loop through the elements.  */\n       for_body = begin_compound_stmt (/*has_no_scope=*/1);\n \n-      /* When we're not building a statement-tree, things are a little\n-\t complicated.  If, when we recursively call build_aggr_init,\n-\t an expression containing a TARGET_EXPR is expanded, then it\n-\t may get a cleanup.  Then, the result of that expression is\n-\t passed to finish_expr_stmt, which will call\n-\t expand_start_target_temps/expand_end_target_temps.  However,\n-\t the latter call will not cause the cleanup to run because\n-\t that block will still be on the block stack.  So, we call\n-\t expand_start_target_temps here manually; the corresponding\n-\t call to expand_end_target_temps below will cause the cleanup\n-\t to be performed.  */\n-      if (!building_stmt_tree ())\n-\texpand_start_target_temps ();\n-\n       if (from_array)\n \t{\n \t  tree to = build1 (INDIRECT_REF, type, base);\n@@ -2623,19 +2597,9 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \telt_init = build_aggr_init (build1 (INDIRECT_REF, type, base), \n \t\t\t\t    init, 0);\n       \n-      /* The initialization of each array element is a\n-\t full-expression, as per core issue 124.  */\n-      if (!building_stmt_tree ())\n-\t{\n-\t  genrtl_expr_stmt (elt_init);\n-\t  expand_end_target_temps ();\n-\t}\n-      else\n-\t{\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-\t  finish_expr_stmt (elt_init);\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n-\t}\n+      current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n+      finish_expr_stmt (elt_init);\n+      current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n       finish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base, 0));\n       if (base2)\n@@ -2674,7 +2638,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n      first element in the array.  */\n   finish_expr_stmt (rval);\n \n-  stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n+  stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);\n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   return stmt_expr;\n }"}, {"sha": "1ce6bd3318107c72888fd0fd3b498f370f570318", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3398e1245426f04592cf53a21bde8befa6f3ae/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3398e1245426f04592cf53a21bde8befa6f3ae/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2a3398e1245426f04592cf53a21bde8befa6f3ae", "patch": "@@ -1425,35 +1425,6 @@ begin_stmt_expr (void)\n   return last_tree; \n }\n \n-/* Used when beginning a statement-expression outside function scope.\n-   For example, when handling a file-scope initializer, we use this\n-   function.  */\n-\n-tree\n-begin_global_stmt_expr (void)\n-{\n-  if (! cfun && !last_tree)\n-    begin_stmt_tree (&scope_chain->x_saved_tree);\n-\n-  keep_next_level (1);\n-  \n-  return last_tree ? last_tree : expand_start_stmt_expr(/*has_scope=*/1); \n-}\n-\n-/* Finish the STMT_EXPR last begun with begin_global_stmt_expr.  */\n-\n-tree \n-finish_global_stmt_expr (tree stmt_expr)\n-{\n-  stmt_expr = expand_end_stmt_expr (stmt_expr);\n-  \n-  if (! cfun\n-      && TREE_CHAIN (scope_chain->x_saved_tree) == NULL_TREE)\n-    finish_stmt_tree (&scope_chain->x_saved_tree);\n-\n-  return stmt_expr;\n-}\n-\n /* Finish a statement-expression.  RTL_EXPR should be the value\n    returned by the previous begin_stmt_expr; EXPR is the\n    statement-expression.  Returns an expression representing the"}]}