{"sha": "8072f69c31859b34df8a4613ec740f1174d0ae3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3MmY2OWMzMTg1OWIzNGRmOGE0NjEzZWM3NDBmMTE3NGQwYWUzZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-11-02T06:28:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-02T06:28:31Z"}, "message": "alias.c (init_alias_analysis): Handle -fno-alias-check when optimizing correctly.\n\n        * alias.c (init_alias_analysis): Handle -fno-alias-check when\n        optimizing correctly.\n\nFrom-SVN: r16268", "tree": {"sha": "be3d50c7f385b3b45c1e1e155851a8151087a816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be3d50c7f385b3b45c1e1e155851a8151087a816"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8072f69c31859b34df8a4613ec740f1174d0ae3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8072f69c31859b34df8a4613ec740f1174d0ae3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8072f69c31859b34df8a4613ec740f1174d0ae3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8072f69c31859b34df8a4613ec740f1174d0ae3e/comments", "author": null, "committer": null, "parents": [{"sha": "6cad9e32806390204acfb911337aa4adb3502f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cad9e32806390204acfb911337aa4adb3502f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cad9e32806390204acfb911337aa4adb3502f91"}], "stats": {"total": 105, "additions": 58, "deletions": 47}, "files": [{"sha": "265182fb6dd33b151bf26b51f5f6a9283af56987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8072f69c31859b34df8a4613ec740f1174d0ae3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8072f69c31859b34df8a4613ec740f1174d0ae3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8072f69c31859b34df8a4613ec740f1174d0ae3e", "patch": "@@ -9,6 +9,9 @@ Sat Nov  1 21:43:00 1997  Mike Stump  (mrs@wrs.com)\n \n Sat Nov  1 19:15:28 1997  Jeffrey A Law  (law@cygnus.com)\n \n+\t* alias.c (init_alias_analysis): Handle -fno-alias-check when\n+\toptimizing correctly.\n+\n \t* expr.c (expand_builtin_setjmp): Don't emit a SETJMP note\n \tor set current_function_calls_setjmp anymore.\n "}, {"sha": "855abaeec20460b5e93afabecf32bc5b4bb7192e", "filename": "gcc/alias.c", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8072f69c31859b34df8a4613ec740f1174d0ae3e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8072f69c31859b34df8a4613ec740f1174d0ae3e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8072f69c31859b34df8a4613ec740f1174d0ae3e", "patch": "@@ -1002,12 +1002,6 @@ init_alias_analysis ()\n       /* Assume nothing will change this iteration of the loop.  */\n       changed = 0;\n \n-      /* Wipe the potential alias information clean for this pass.  */\n-      bzero ((char *) new_reg_base_value, reg_base_value_size * sizeof (rtx));\n-\n-      /* Wipe the reg_seen array clean.  */\n-      bzero ((char *) reg_seen, reg_base_value_size);\n-\n       /* We want to assign the same IDs each iteration of this loop, so\n \t start counting from zero each iteration of the loop.  */\n       unique_id = 0;\n@@ -1016,43 +1010,56 @@ init_alias_analysis ()\n \t loop, so we're copying arguments.  */\n       copying_arguments = 1;\n \n-      /* Mark all hard registers which may contain an address.\n-\t The stack, frame and argument pointers may contain an address.\n-\t An argument register which can hold a Pmode value may contain\n-\t an address even if it is not in BASE_REGS.\n+      /* Only perform initialization of the arrays if we're actually\n+\t performing alias analysis. */\n+      if (flag_alias_check)\n+\t{\n+\t  /* Wipe the potential alias information clean for this pass.  */\n+\t  bzero ((char *) new_reg_base_value,\n+\t\t reg_base_value_size * sizeof (rtx));\n+\n+\t  /* Wipe the reg_seen array clean.  */\n+\t  bzero ((char *) reg_seen, reg_base_value_size);\n \n-\t The address expression is VOIDmode for an argument and\n-\t Pmode for other registers.  */\n+\t  /* Mark all hard registers which may contain an address.\n+\t     The stack, frame and argument pointers may contain an address.\n+\t     An argument register which can hold a Pmode value may contain\n+\t     an address even if it is not in BASE_REGS.\n+\n+\t     The address expression is VOIDmode for an argument and\n+\t     Pmode for other registers.  */\n #ifndef OUTGOING_REGNO\n #define OUTGOING_REGNO(N) N\n #endif\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t/* Check whether this register can hold an incoming pointer\n-\t   argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n-\t   numbers, so translate if necessary due to register windows. */\n-\tif (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i)) && HARD_REGNO_MODE_OK (i, Pmode))\n-\t  new_reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n-\t\t\t\t\t   gen_rtx (REG, Pmode, i));\n-\n-      new_reg_base_value[STACK_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n-      new_reg_base_value[ARG_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n-      new_reg_base_value[FRAME_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    /* Check whether this register can hold an incoming pointer\n+\t       argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n+\t       numbers, so translate if necessary due to register windows. */\n+\t    if (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i))\n+\t\t&& HARD_REGNO_MODE_OK (i, Pmode))\n+\t      new_reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n+\t\t\t\t\t       gen_rtx (REG, Pmode, i));\n+\n+\t  new_reg_base_value[STACK_POINTER_REGNUM]\n+\t    = gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n+\t  new_reg_base_value[ARG_POINTER_REGNUM]\n+\t    = gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n+\t  new_reg_base_value[FRAME_POINTER_REGNUM]\n+\t    = gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-      new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n+\t  new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n+\t    = gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n #endif\n-      if (struct_value_incoming_rtx\n-\t  && GET_CODE (struct_value_incoming_rtx) == REG)\n-      new_reg_base_value[REGNO (struct_value_incoming_rtx)]\n-\t= gen_rtx (ADDRESS, Pmode, struct_value_incoming_rtx);\n-\n-      if (static_chain_rtx\n-\t  && GET_CODE (static_chain_rtx) == REG)\n-      new_reg_base_value[REGNO (static_chain_rtx)]\n-\t= gen_rtx (ADDRESS, Pmode, static_chain_rtx);\n+\t  if (struct_value_incoming_rtx\n+\t      && GET_CODE (struct_value_incoming_rtx) == REG)\n+\t    new_reg_base_value[REGNO (struct_value_incoming_rtx)]\n+\t      = gen_rtx (ADDRESS, Pmode, struct_value_incoming_rtx);\n+\n+\t  if (static_chain_rtx\n+\t      && GET_CODE (static_chain_rtx) == REG)\n+\t    new_reg_base_value[REGNO (static_chain_rtx)]\n+\t      = gen_rtx (ADDRESS, Pmode, static_chain_rtx);\n+\t}\n \n       /* Walk the insns adding values to the new_reg_base_value array.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -1089,16 +1096,17 @@ init_alias_analysis ()\n \t}\n \n       /* Now propagate values from new_reg_base_value to reg_base_value.  */\n-      for (i = 0; i < reg_base_value_size; i++)\n-\t{\n-\t  if (new_reg_base_value[i]\n-\t      && new_reg_base_value[i] != reg_base_value[i]\n-\t      && !rtx_equal_p (new_reg_base_value[i], reg_base_value[i]))\n-\t    {\n-\t      reg_base_value[i] = new_reg_base_value[i];\n-\t      changed = 1;\n-\t    }\n-\t}\n+      if (flag_alias_check)\n+\tfor (i = 0; i < reg_base_value_size; i++)\n+\t  {\n+\t    if (new_reg_base_value[i]\n+\t        && new_reg_base_value[i] != reg_base_value[i]\n+\t        && !rtx_equal_p (new_reg_base_value[i], reg_base_value[i]))\n+\t      {\n+\t        reg_base_value[i] = new_reg_base_value[i];\n+\t        changed = 1;\n+\t      }\n+\t  }\n     }\n \n   /* Fill in the remaining entries.  */"}]}