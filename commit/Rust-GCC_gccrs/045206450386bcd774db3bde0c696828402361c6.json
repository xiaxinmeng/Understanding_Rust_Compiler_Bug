{"sha": "045206450386bcd774db3bde0c696828402361c6", "node_id": "C_kwDOANBUbNoAKDA0NTIwNjQ1MDM4NmJjZDc3NGRiM2JkZTBjNjk2ODI4NDAyMzYxYzY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-12T09:21:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-16T10:31:56Z"}, "message": "tree-optimization/102880 - improve CD-DCE\n\nThe PR shows a missed control-dependent DCE caused by CFG cleanup\nmerging a forwarder resulting in a partially degenerate PHI node.\nWith control-dependent DCE we need to mark control dependences\nof incoming edges into PHIs as necessary but that is unnecessarily\nconservative for the case when two edges have the same value.\nThere is no easy way to mark only a subset of control dependences\nof both edges necessary so the fix is to produce forwarder blocks\nwhere then the control dependence captures the requirements more\nprecisely.\n\nFor gcc.dg/tree-ssa/ssa-dom-thread-7.c the number of edges in the\nCFG decrease as we have commonized PHI arguments which in turn\nresults in different threadings.  The testcase is too complex\nand the dump scanning too simple to do anything meaningful here\nbut to adjust the number of expected threads.\n\nThe same CFG massaging could be useful at RTL expansion time to\nreduce the number of copies we need to insert on edges.\n\nFAIL: gcc.dg/tree-ssa/ssa-hoist-4.c scan-tree-dump-times optimized \"MAX_EXPR\" 1\n\n2021-11-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102880\n\t* tree-ssa-dce.c (sort_phi_args): New function.\n\t(make_forwarders_with_degenerate_phis): Likewise.\n\t(perform_tree_ssa_dce): Call\n\tmake_forwarders_with_degenerate_phis.\n\n\t* gcc.dg/tree-ssa/pr102880.c: New testcase.\n\t* gcc.dg/tree-ssa/pr69270-3.c: Robustify.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Change the number of\n\texpected threadings.", "tree": {"sha": "d699881a02279559fad395114182ea23d53bbb6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d699881a02279559fad395114182ea23d53bbb6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/045206450386bcd774db3bde0c696828402361c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045206450386bcd774db3bde0c696828402361c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/045206450386bcd774db3bde0c696828402361c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/045206450386bcd774db3bde0c696828402361c6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f98f373dd822b35c52356b753d528924e9f89678", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98f373dd822b35c52356b753d528924e9f89678", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98f373dd822b35c52356b753d528924e9f89678"}], "stats": {"total": 202, "additions": 196, "deletions": 6}, "files": [{"sha": "0306deedb6c30b791ba960190e78ad624c4af19b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr102880.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102880.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102880.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102880.c?ref=045206450386bcd774db3bde0c696828402361c6", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void foo(void);\n+\n+static int b, c, d, e, f, ah;\n+static short g, ai, am, aq, as;\n+static char an, at, av, ax, ay;\n+static char a(char h, char i) { return i == 0 || h && i == 1 ? 0 : h % i; }\n+static void ae(int h) {\n+  if (a(b, h))\n+    foo();\n+\n+}\n+int main() {\n+  ae(1);\n+  ay = a(0, ay);\n+  ax = a(g, aq);\n+  at = a(0, as);\n+  av = a(c, 1);\n+  an = a(am, f);\n+  int al = e || ((a(1, ah) && b) & d) == 2;\n+  ai = al;\n+}\n+\n+/* We should eliminate the call to foo.  */\n+/* { dg-final { scan-tree-dump-not \"foo\" \"optimized\" } } */"}, {"sha": "5ffd5f71506159b865520ee0363cbc8cb8cffa95", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr69270-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69270-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69270-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69270-3.c?ref=045206450386bcd774db3bde0c696828402361c6", "patch": "@@ -3,7 +3,7 @@\n \n /* We're looking for a constant argument a PHI node.  There\n    should only be one if we unpropagate correctly.  */\n-/* { dg-final { scan-tree-dump-times \", 1\" 1 \"uncprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"<1\\|, 1\" 1 \"uncprop1\"} } */\n \n typedef long unsigned int size_t;\n typedef union gimple_statement_d *gimple;"}, {"sha": "b64e71dae227af944ce0b4cffba2a4098255b86a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=045206450386bcd774db3bde0c696828402361c6", "patch": "@@ -11,7 +11,7 @@\n    to change decisions in switch expansion which in turn can expose new\n    jump threading opportunities.  Skip the later tests on aarch64.  */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom3\" { target { ! aarch64*-*-* } } } } */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 11\"  \"thread2\" { target { ! aarch64*-*-* } } } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 7\"  \"thread2\" { target { ! aarch64*-*-* } } } } */\n /* { dg-final { scan-tree-dump \"Jumps threaded: 18\"  \"thread2\" { target { aarch64*-*-* } } } } */\n \n enum STATE {"}, {"sha": "dbf02c434de48af1ee13ef384e7a6266b08a58c9", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 167, "deletions": 4, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/045206450386bcd774db3bde0c696828402361c6/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=045206450386bcd774db3bde0c696828402361c6", "patch": "@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"gimple-fold.h\"\n+#include \"tree-ssa.h\"\n \n static struct stmt_stats\n {\n@@ -1612,6 +1613,164 @@ tree_dce_done (bool aggressive)\n   worklist.release ();\n }\n \n+/* Sort PHI argument values for make_forwarders_with_degenerate_phis.  */\n+\n+static int\n+sort_phi_args (const void *a_, const void *b_)\n+{\n+  auto *a = (const std::pair<edge, hashval_t> *) a_;\n+  auto *b = (const std::pair<edge, hashval_t> *) b_;\n+  hashval_t ha = a->second;\n+  hashval_t hb = b->second;\n+  if (ha < hb)\n+    return -1;\n+  else if (ha > hb)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Look for a non-virtual PHIs and make a forwarder block when all PHIs\n+   have the same argument on a set of edges.  This is to not consider\n+   control dependences of individual edges for same values but only for\n+   the common set.  */\n+\n+static unsigned\n+make_forwarders_with_degenerate_phis (function *fn)\n+{\n+  unsigned todo = 0;\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      /* Only PHIs with three or more arguments have opportunities.  */\n+      if (EDGE_COUNT (bb->preds) < 3)\n+\tcontinue;\n+      /* Do not touch loop headers.  */\n+      if (bb->loop_father->header == bb)\n+\tcontinue;\n+\n+      /* Take one PHI node as template to look for identical\n+\t arguments.  Build a vector of candidates forming sets\n+\t of argument edges with equal values.  Note optimality\n+\t depends on the particular choice of the template PHI\n+\t since equal arguments are unordered leaving other PHIs\n+\t with more than one set of equal arguments within this\n+\t argument range unsorted.  We'd have to break ties by\n+\t looking at other PHI nodes.  */\n+      gphi_iterator gsi = gsi_start_nonvirtual_phis (bb);\n+      if (gsi_end_p (gsi))\n+\tcontinue;\n+      gphi *phi = gsi.phi ();\n+      auto_vec<std::pair<edge, hashval_t>, 8> args;\n+      for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t{\n+\t  edge e = gimple_phi_arg_edge (phi, i);\n+\t  /* Skip abnormal edges since we cannot redirect them.  */\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    continue;\n+\t  /* Skip loop exit edges when we are in loop-closed SSA form\n+\t     since the forwarder we'd create does not have a PHI node.  */\n+\t  if (loops_state_satisfies_p (LOOP_CLOSED_SSA)\n+\t      && loop_exit_edge_p (e->src->loop_father, e))\n+\t    continue;\n+\t  args.safe_push (std::make_pair (e, iterative_hash_expr\n+\t\t\t\t\t     (gimple_phi_arg_def (phi, i), 0)));\n+\t}\n+      if (args.length () < 2)\n+\tcontinue;\n+      args.qsort (sort_phi_args);\n+\n+      /* From the candidates vector now verify true candidates for\n+\t forwarders and create them.  */\n+      gphi *vphi = get_virtual_phi (bb);\n+      unsigned start = 0;\n+      while (start < args.length () - 1)\n+\t{\n+\t  unsigned i;\n+\t  for (i = start + 1; i < args.length (); ++i)\n+\t    if (!operand_equal_p (PHI_ARG_DEF_FROM_EDGE (phi, args[start].first),\n+\t\t\t\t  PHI_ARG_DEF_FROM_EDGE (phi, args[i].first)))\n+\t      break;\n+\t  /* args[start]..args[i-1] are equal.  */\n+\t  if (start != i - 1)\n+\t    {\n+\t      /* Check all PHI nodes for argument equality.  */\n+\t      bool equal = true;\n+\t      gphi_iterator gsi2 = gsi;\n+\t      gsi_next (&gsi2);\n+\t      for (; !gsi_end_p (gsi2); gsi_next (&gsi2))\n+\t\t{\n+\t\t  gphi *phi2 = gsi2.phi ();\n+\t\t  if (virtual_operand_p (gimple_phi_result (phi2)))\n+\t\t    continue;\n+\t\t  tree start_arg\n+\t\t    = PHI_ARG_DEF_FROM_EDGE (phi2, args[start].first);\n+\t\t  for (unsigned j = start + 1; j < i; ++j)\n+\t\t    {\n+\t\t      if (!operand_equal_p (start_arg,\n+\t\t\t\t\t    PHI_ARG_DEF_FROM_EDGE\n+\t\t\t\t\t      (phi2, args[j].first)))\n+\t\t\t{\n+\t\t\t  /* Another PHI might have a shorter set of\n+\t\t\t     equivalent args.  Go for that.  */\n+\t\t\t  i = j;\n+\t\t\t  if (j == start + 1)\n+\t\t\t    equal = false;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  if (!equal)\n+\t\t    break;\n+\t\t}\n+\t      if (equal)\n+\t\t{\n+\t\t  /* If we are asked to forward all edges the block\n+\t\t     has all degenerate PHIs.  Do nothing in that case.  */\n+\t\t  if (start == 0\n+\t\t      && i == args.length ()\n+\t\t      && args.length () == gimple_phi_num_args (phi))\n+\t\t    break;\n+\t\t  /* Instead of using make_forwarder_block we are\n+\t\t     rolling our own variant knowing that the forwarder\n+\t\t     does not need PHI nodes apart from eventually\n+\t\t     a virtual one.  */\n+\t\t  auto_vec<tree, 8> vphi_args;\n+\t\t  if (vphi)\n+\t\t    {\n+\t\t      vphi_args.reserve_exact (i - start);\n+\t\t      for (unsigned j = start; j < i; ++j)\n+\t\t\tvphi_args.quick_push\n+\t\t\t  (PHI_ARG_DEF_FROM_EDGE (vphi, args[j].first));\n+\t\t    }\n+\t\t  free_dominance_info (fn, CDI_DOMINATORS);\n+\t\t  basic_block forwarder = split_edge (args[start].first);\n+\t\t  for (unsigned j = start + 1; j < i; ++j)\n+\t\t    {\n+\t\t      edge e = args[j].first;\n+\t\t      redirect_edge_and_branch_force (e, forwarder);\n+\t\t      redirect_edge_var_map_clear (e);\n+\t\t    }\n+\t\t  if (vphi)\n+\t\t    {\n+\t\t      tree def = copy_ssa_name (vphi_args[0]);\n+\t\t      gphi *vphi_copy = create_phi_node (def, forwarder);\n+\t\t      for (unsigned j = start; j < i; ++j)\n+\t\t\tadd_phi_arg (vphi_copy, vphi_args[j - start],\n+\t\t\t\t     args[j].first, UNKNOWN_LOCATION);\n+\t\t      SET_PHI_ARG_DEF\n+\t\t\t(vphi, single_succ_edge (forwarder)->dest_idx, def);\n+\t\t    }\n+\t\t  todo |= TODO_cleanup_cfg;\n+\t\t}\n+\t    }\n+\t  /* Continue searching for more opportunities.  */\n+\t  start = i;\n+\t}\n+    }\n+  return todo;\n+}\n+\n /* Main routine to eliminate dead code.\n \n    AGGRESSIVE controls the aggressiveness of the algorithm.\n@@ -1630,8 +1789,7 @@ static unsigned int\n perform_tree_ssa_dce (bool aggressive)\n {\n   bool something_changed = 0;\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n+  unsigned todo = 0;\n \n   /* Preheaders are needed for SCEV to work.\n      Simple lateches and recorded exits improve chances that loop will\n@@ -1644,6 +1802,11 @@ perform_tree_ssa_dce (bool aggressive)\n \t\t\t   | LOOPS_HAVE_RECORDED_EXITS);\n     }\n \n+  if (aggressive)\n+    todo |= make_forwarders_with_degenerate_phis (cfun);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n   tree_dce_init (aggressive);\n \n   if (aggressive)\n@@ -1701,9 +1864,9 @@ perform_tree_ssa_dce (bool aggressive)\n       free_numbers_of_iterations_estimates (cfun);\n       if (in_loop_pipeline)\n \tscev_reset ();\n-      return TODO_update_ssa | TODO_cleanup_cfg;\n+      todo |= TODO_update_ssa | TODO_cleanup_cfg;\n     }\n-  return 0;\n+  return todo;\n }\n \n /* Pass entry points.  */"}]}