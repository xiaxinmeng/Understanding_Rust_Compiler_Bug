{"sha": "f4d578da666c948839a56e141071b0ee9c50f555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRkNTc4ZGE2NjZjOTQ4ODM5YTU2ZTE0MTA3MWIwZWU5YzUwZjU1NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-01-04T14:17:40Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-01-04T14:17:40Z"}, "message": "Some tidyups for ia64 problems\n\nFrom-SVN: r38682", "tree": {"sha": "730a0d4118a0999cf159752ac960ad1c37f3249e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730a0d4118a0999cf159752ac960ad1c37f3249e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4d578da666c948839a56e141071b0ee9c50f555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d578da666c948839a56e141071b0ee9c50f555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4d578da666c948839a56e141071b0ee9c50f555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d578da666c948839a56e141071b0ee9c50f555/comments", "author": null, "committer": null, "parents": [{"sha": "03b9ab42612740a5db1047dfbe57a89dd51cb3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b9ab42612740a5db1047dfbe57a89dd51cb3cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b9ab42612740a5db1047dfbe57a89dd51cb3cb"}], "stats": {"total": 90, "additions": 80, "deletions": 10}, "files": [{"sha": "2a0f123370dece66b9fdc9c2592f9279eac376e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d578da666c948839a56e141071b0ee9c50f555/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d578da666c948839a56e141071b0ee9c50f555/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4d578da666c948839a56e141071b0ee9c50f555", "patch": "@@ -1,3 +1,14 @@\n+2001-01-04  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* regrename.c (regrename_optimize): Don't rename from frame pointer\n+\tif frame_pointer_needed.\n+\t(do_replace): Don't set ORIGINAL_REGNO to a hard register number.\n+\t* config/ia64/ia64.c (emit_all_group_insn_barriers): New function.\n+\t(ia64_reorg): Use it instead of scheduling if ! optimize.\n+\t(errata_emit_nops): Properly call asm_noperands.\n+\t(ia64_sched_reorder): Finish cycle if we see an asm.\n+\t(ia64_variable_issue): Clear scheduling state after asms.\n+\n 2001-01-04  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cpp.texi: Update for -MT."}, {"sha": "82fca4ae10f48e61ecebf9636f4281525ee13359", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d578da666c948839a56e141071b0ee9c50f555/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d578da666c948839a56e141071b0ee9c50f555/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f4d578da666c948839a56e141071b0ee9c50f555", "patch": "@@ -116,6 +116,7 @@ static void ia64_add_gc_roots PARAMS ((void));\n static void ia64_init_machine_status PARAMS ((struct function *));\n static void ia64_mark_machine_status PARAMS ((struct function *));\n static void emit_insn_group_barriers PARAMS ((FILE *, rtx));\n+static void emit_all_insn_group_barriers PARAMS ((FILE *, rtx));\n static void emit_predicate_relation_info PARAMS ((void));\n static int process_set PARAMS ((FILE *, rtx));\n \n@@ -4450,7 +4451,11 @@ safe_group_barrier_needed_p (insn)\n }\n \n /* INSNS is an chain of instructions.  Scan the chain, and insert stop bits\n-   as necessary to eliminate dependendencies.  */\n+   as necessary to eliminate dependendencies.  This function assumes that\n+   a final instruction scheduling pass has been run which has already\n+   inserted most of the necessary stop bits.  This function only inserts\n+   new ones at basic block boundaries, since these are invisible to the\n+   scheduler.  */\n \n static void\n emit_insn_group_barriers (dump, insns)\n@@ -4505,6 +4510,36 @@ emit_insn_group_barriers (dump, insns)\n \t}\n     }\n }\n+\n+/* Like emit_insn_group_barriers, but run if no final scheduling pass was run.\n+   This function has to emit all necessary group barriers.  */\n+\n+static void\n+emit_all_insn_group_barriers (dump, insns)\n+     FILE *dump;\n+     rtx insns;\n+{\n+  rtx insn;\n+\n+  init_insn_group_barriers ();\n+\n+  for (insn = insns; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == INSN\n+\t       && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n+\t       && XINT (PATTERN (insn), 1) == 2)\n+\tinit_insn_group_barriers ();\n+      else if (INSN_P (insn))\n+\t{\n+\t  if (group_barrier_needed_p (insn))\n+\t    {\n+\t      emit_insn_before (gen_insn_group_barrier (GEN_INT (3)), insn);\n+\t      init_insn_group_barriers ();\n+\t      group_barrier_needed_p (insn);\n+\t    }\n+\t}\n+    }\n+}\n \f\n static int errata_find_address_regs PARAMS ((rtx *, void *));\n static void errata_emit_nops PARAMS ((rtx));\n@@ -4567,7 +4602,7 @@ errata_emit_nops (insn)\n       || GET_CODE (real_pat) == ASM_INPUT\n       || GET_CODE (real_pat) == ADDR_VEC\n       || GET_CODE (real_pat) == ADDR_DIFF_VEC\n-      || asm_noperands (insn) >= 0)\n+      || asm_noperands (PATTERN (insn)) >= 0)\n     return;\n \n   /* single_set doesn't work for COND_EXEC insns, so we have to duplicate\n@@ -5612,6 +5647,12 @@ ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, reorder_type)\n \t\tschedule_stop (sched_verbose ? dump : NULL);\n \t\tsched_data.last_was_stop = 1;\n \t      }\n+\t    else if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t     || asm_noperands (PATTERN (insn)) >= 0)\n+\t      {\n+\t\t/* It must be an asm of some kind.  */\n+\t\tcycle_end_fill_slots (sched_verbose ? dump : NULL);\n+\t      }\n \t    return 1;\n \t  }\n       }\n@@ -5811,6 +5852,12 @@ ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n     {\n       if (sched_verbose)\n \tfprintf (dump, \"// Ignoring type %s\\n\", type_names[t]);\n+      if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t  || asm_noperands (PATTERN (insn)) >= 0)\n+\t{\n+\t  /* This must be some kind of asm.  Clear the scheduling state.  */\n+\t  rotate_two_bundles (sched_verbose ? dump : NULL);\n+\t}\n       return 1;\n     }\n \n@@ -5931,13 +5978,18 @@ ia64_reorg (insns)\n   find_basic_blocks (insns, max_reg_num (), NULL);\n   life_analysis (insns, NULL, PROP_DEATH_NOTES);\n \n-  ia64_final_schedule = 1;\n-  schedule_ebbs (rtl_dump_file);\n-  ia64_final_schedule = 0;\n+  if (optimize)\n+    {\n+      ia64_final_schedule = 1;\n+      schedule_ebbs (rtl_dump_file);\n+      ia64_final_schedule = 0;\n \n-  /* This relies on the NOTE_INSN_BASIC_BLOCK notes to be in the same\n-     place as they were during scheduling.  */\n-  emit_insn_group_barriers (rtl_dump_file, insns);\n+      /* This relies on the NOTE_INSN_BASIC_BLOCK notes to be in the same\n+\t place as they were during scheduling.  */\n+      emit_insn_group_barriers (rtl_dump_file, insns);\n+    }\n+  else\n+    emit_all_insn_group_barriers (rtl_dump_file, insns);\n \n   fixup_errata ();\n   emit_predicate_relation_info ();"}, {"sha": "ae25e2171fb89f96f3b8592a5c05c67e8c8a4a24", "filename": "gcc/regrename.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d578da666c948839a56e141071b0ee9c50f555/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d578da666c948839a56e141071b0ee9c50f555/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=f4d578da666c948839a56e141071b0ee9c50f555", "patch": "@@ -248,7 +248,13 @@ regrename_optimize ()\n \t    }\n #endif\n \n-\t  if (fixed_regs[reg] || global_regs[reg])\n+\t  if (fixed_regs[reg] || global_regs[reg]\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\t      || (frame_pointer_needed && reg == HARD_FRAME_POINTER_REGNUM)\n+#else\n+\t      || (frame_pointer_needed && reg == FRAME_POINTER_REGNUM)\n+#endif\n+\t      )\n \t    continue;\n \n \t  COPY_HARD_REG_SET (this_unavailable, unavailable);\n@@ -351,7 +357,8 @@ do_replace (chain, reg)\n     {\n       unsigned int regno = ORIGINAL_REGNO (*chain->loc);\n       *chain->loc = gen_raw_REG (GET_MODE (*chain->loc), reg);\n-      ORIGINAL_REGNO (*chain->loc) = regno;\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tORIGINAL_REGNO (*chain->loc) = regno;\n       chain = chain->next_use;\n     }\n }"}]}