{"sha": "dcfdd2851b297e0005a8490b7f867ca45d1ad340", "node_id": "C_kwDOANBUbNoAKGRjZmRkMjg1MWIyOTdlMDAwNWE4NDkwYjdmODY3Y2E0NWQxYWQzNDA", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-02T08:40:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-02T08:40:12Z"}, "message": "i386: Optimize away shift count masking of shifts/rotates some more [PR105778]\n\nAs the following testcase shows, our x86 backend support for optimizing\nout useless masking of shift/rotate counts when using instructions\nthat naturally modulo the count themselves is insufficient.\nThe *_mask define_insn_and_split patterns use\n(subreg:QI (and:SI (match_operand:SI) (match_operand \"const_int_operand\")))\nfor the masking, but that can catch only the case where the masking\nis done in SImode, so typically in SImode in the source.\nWe then have another set of patterns, *_mask_1, which use\n(and:QI (match_operand:QI) (match_operand \"const_int_operand\"))\nIf the masking is done in DImode or in theory in HImode, we don't match\nit.\nThe following patch does 4 different things to improve this:\n1) drops the mode from AND and MATCH_OPERAND inside of the subreg:QI\n   and replaces that by checking that the register shift count has\n   SWI48 mode - I think doing it this way is cheaper than adding\n   another mode iterator to patterns which use already another mode\n   iterator and sometimes a code iterator as well\n2) the doubleword shift patterns were only handling the case where\n   the shift count is masked with a constant that has the most significant\n   bit clear, i.e. where we know the shift count is less than half the\n   number of bits in double-word.  If the mask is equal to half the\n   number of bits in double-word minus 1, the masking was optimized\n   away, otherwise the AND was kept.\n   But if the most significant bit isn't clear, e use a word-sized shift\n   and SHRD instruction, where the former does the modulo and the latter\n   modulo with 64 / 32 depending on what mode the CPU is in (so 64 for\n   128-bit doubleword and 32 or 64-bit doubleword).  So we can also\n   optimize away the masking when the mask has all the relevant bits set,\n   masking with the most significant bit will remain for the cmove\n   test.\n3) as requested, this patch adds a bunch of force_reg calls before\n   gen_lowpart\n4) 1-3 above unfortunately regressed\n   +FAIL: gcc.target/i386/bt-mask-2.c scan-assembler-not and[lq][ \\\\t]\n   +FAIL: gcc.target/i386/pr57819.c scan-assembler-not and[lq][ \\\\t]\n   where we during combine match the new pattern we didn't match\n   before and in the end don't match the pattern we were testing for.\n   These 2 tests are fixed by the *jcc_bt<mode>_mask_1 pattern\n   addition and small tweak to target rtx_costs, because even with\n   the pattern around we'd refuse to match it because it appeared to\n   have higher instruction cost\n\n2022-06-02  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/105778\n\t* config/i386/i386.md (*ashl<dwi>3_doubleword_mask): Remove :SI\n\tfrom AND and its operands and just verify operands[2] has HImode,\n\tSImode or for TARGET_64BIT DImode.  Allow operands[3] to be a mask\n\twith all low 6 (64-bit) or 5 (32-bit) bits set and in that case\n\tjust throw away the masking.  Use force_reg before calling\n\tgen_lowpart.\n\t(*ashl<dwi>3_doubleword_mask_1): Allow operands[3] to be a mask\n\twith all low 6 (64-bit) or 5 (32-bit) bits set and in that case\n\tjust throw away the masking.\n\t(*ashl<mode>3_doubleword): Rename to ...\n\t(ashl<mode>3_doubleword): ... this.\n\t(*ashl<mode>3_mask): Remove :SI from AND and its operands and just\n\tverify operands[2] has HImode, SImode or for TARGET_64BIT DImode.\n\tUse force_reg before calling gen_lowpart.\n\t(*<insn><mode>3_mask): Likewise.\n\t(*<insn><dwi>3_doubleword_mask): Likewise.  Allow operands[3] to be\n\ta mask with all low 6 (64-bit) or 5 (32-bit) bits set and in that\n\tcase just throw away the masking.  Use force_reg before calling\n\tgen_lowpart.\n\t(*<insn><dwi>3_doubleword_mask_1): Allow operands[3] to be a mask\n\twith all low 6 (64-bit) or 5 (32-bit) bits set and in that case just\n\tthrow away the masking.\n\t(*<insn><mode>3_doubleword): Rename to ...\n\t(<insn><mode>3_doubleword): ... this.\n\t(*<insn><mode>3_mask): Remove :SI from AND and its operands and just\n\tverify operands[2] has HImode, SImode or for TARGET_64BIT DImode.\n\tUse force_reg before calling gen_lowpart.\n\t(splitter after it): Remove :SI from AND and its operands and just\n\tverify operands[2] has HImode, SImode or for TARGET_64BIT DImode.\n\t(*<btsc><mode>_mask, *<btsc><mode>_mask): Remove :SI from AND and its\n\toperands and just verify operands[1] has HImode, SImode or for\n\tTARGET_64BIT DImode.  Use force_reg before calling gen_lowpart.\n\t(*jcc_bt<mode>_mask_1): New define_insn_and_split pattern.\n\t* config/i386/i386.cc (ix86_rtx_costs): For ZERO_EXTRACT with\n\tZERO_EXTEND QI->SI in last operand ignore the cost of the ZERO_EXTEND.\n\n\t* gcc.target/i386/pr105778.c: New test.", "tree": {"sha": "87d590ae306942ab2e1ae34eaf8926893c8c45f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87d590ae306942ab2e1ae34eaf8926893c8c45f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcfdd2851b297e0005a8490b7f867ca45d1ad340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfdd2851b297e0005a8490b7f867ca45d1ad340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcfdd2851b297e0005a8490b7f867ca45d1ad340", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfdd2851b297e0005a8490b7f867ca45d1ad340/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08afab6f8642f58f702010ec196dce3b00955627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08afab6f8642f58f702010ec196dce3b00955627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08afab6f8642f58f702010ec196dce3b00955627"}], "stats": {"total": 257, "additions": 219, "deletions": 38}, "files": [{"sha": "11f4ddfd453c7b05f814deb475bee1d273f19565", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfdd2851b297e0005a8490b7f867ca45d1ad340/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfdd2851b297e0005a8490b7f867ca45d1ad340/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=dcfdd2851b297e0005a8490b7f867ca45d1ad340", "patch": "@@ -20995,6 +20995,20 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n         *total += 1;\n       return false;\n \n+    case ZERO_EXTRACT:\n+      if (XEXP (x, 1) == const1_rtx\n+\t  && GET_CODE (XEXP (x, 2)) == ZERO_EXTEND\n+\t  && GET_MODE (XEXP (x, 2)) == SImode\n+\t  && GET_MODE (XEXP (XEXP (x, 2), 0)) == QImode)\n+\t{\n+\t  /* Ignore cost of zero extension and masking of last argument.  */\n+\t  *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+\t  *total += rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n+\t  *total += rtx_cost (XEXP (XEXP (x, 2), 0), mode, code, 2, speed);\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       return false;\n     }"}, {"sha": "eae1cb595c324dbf5fdcf2b7a557ddedd8e5ac69", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 160, "deletions": 38, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfdd2851b297e0005a8490b7f867ca45d1ad340/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfdd2851b297e0005a8490b7f867ca45d1ad340/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=dcfdd2851b297e0005a8490b7f867ca45d1ad340", "patch": "@@ -11890,11 +11890,16 @@\n \t(ashift:<DWI>\n \t  (match_operand:<DWI> 1 \"register_operand\")\n \t  (subreg:QI\n-\t    (and:SI\n-\t      (match_operand:SI 2 \"register_operand\" \"c\")\n-\t      (match_operand:SI 3 \"const_int_operand\")) 0)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+\t    (and\n+\t      (match_operand 2 \"register_operand\" \"c\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+    || ((INTVAL (operands[3]) & (2 * <MODE_SIZE> * BITS_PER_UNIT - 1))\n+\t == (2 * <MODE_SIZE> * BITS_PER_UNIT - 1)))\n+   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -11912,6 +11917,15 @@\n \t   (ashift:DWIH (match_dup 5) (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n {\n+  if ((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) != 0)\n+    {\n+      operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+      operands[2] = gen_lowpart (QImode, operands[2]);\n+      emit_insn (gen_ashl<dwi>3_doubleword (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+      DONE;\n+    }\n+\n   split_double_mode (<DWI>mode, &operands[0], 2, &operands[4], &operands[6]);\n \n   operands[8] = GEN_INT (<MODE_SIZE> * BITS_PER_UNIT - 1);\n@@ -11925,6 +11939,7 @@\n       operands[2] = tem;\n     }\n \n+  operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n   operands[2] = gen_lowpart (QImode, operands[2]);\n \n   if (!rtx_equal_p (operands[6], operands[7]))\n@@ -11939,7 +11954,9 @@\n \t    (match_operand:QI 2 \"register_operand\" \"c\")\n \t    (match_operand:QI 3 \"const_int_operand\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+  \"((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+    || ((INTVAL (operands[3]) & (2 * <MODE_SIZE> * BITS_PER_UNIT - 1))\n+\t == (2 * <MODE_SIZE> * BITS_PER_UNIT - 1)))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -11957,6 +11974,13 @@\n \t   (ashift:DWIH (match_dup 5) (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n {\n+  if ((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) != 0)\n+    {\n+      emit_insn (gen_ashl<dwi>3_doubleword (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n+      DONE;\n+    }\n+\n   split_double_mode (<DWI>mode, &operands[0], 2, &operands[4], &operands[6]);\n \n   operands[8] = GEN_INT (<MODE_SIZE> * BITS_PER_UNIT - 1);\n@@ -11974,7 +11998,7 @@\n     emit_move_insn (operands[6], operands[7]);\n })\n \n-(define_insn \"*ashl<mode>3_doubleword\"\n+(define_insn \"ashl<mode>3_doubleword\"\n   [(set (match_operand:DWI 0 \"register_operand\" \"=&r\")\n \t(ashift:DWI (match_operand:DWI 1 \"reg_or_pm1_operand\" \"0n\")\n \t\t    (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n@@ -12186,13 +12210,16 @@\n \t(ashift:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\")\n \t  (subreg:QI\n-\t    (and:SI\n-\t      (match_operand:SI 2 \"register_operand\" \"c,r\")\n-\t      (match_operand:SI 3 \"const_int_operand\")) 0)))\n+\t    (and\n+\t      (match_operand 2 \"register_operand\" \"c,r\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (ASHIFT, <MODE>mode, operands)\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n+   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -12201,7 +12228,10 @@\n \t   (ashift:SWI48 (match_dup 1)\n \t\t\t (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+{\n+  operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+  operands[2] = gen_lowpart (QImode, operands[2]);\n+}\n   [(set_attr \"isa\" \"*,bmi2\")])\n \n (define_insn_and_split \"*ashl<mode>3_mask_1\"\n@@ -12774,13 +12804,16 @@\n \t(any_shiftrt:SWI48\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\")\n \t  (subreg:QI\n-\t    (and:SI\n-\t      (match_operand:SI 2 \"register_operand\" \"c,r\")\n-\t      (match_operand:SI 3 \"const_int_operand\")) 0)))\n+\t    (and\n+\t      (match_operand 2 \"register_operand\" \"c,r\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n+   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -12789,7 +12822,10 @@\n \t   (any_shiftrt:SWI48 (match_dup 1)\n \t\t\t      (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = gen_lowpart (QImode, operands[2]);\"\n+{\n+  operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+  operands[2] = gen_lowpart (QImode, operands[2]);\n+}\n   [(set_attr \"isa\" \"*,bmi2\")])\n \n (define_insn_and_split \"*<insn><mode>3_mask_1\"\n@@ -12819,11 +12855,16 @@\n \t(any_shiftrt:<DWI>\n \t  (match_operand:<DWI> 1 \"register_operand\")\n \t  (subreg:QI\n-\t    (and:SI\n-\t      (match_operand:SI 2 \"register_operand\" \"c\")\n-\t      (match_operand:SI 3 \"const_int_operand\")) 0)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+\t    (and\n+\t      (match_operand 2 \"register_operand\" \"c\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+    || ((INTVAL (operands[3]) & (2 * <MODE_SIZE> * BITS_PER_UNIT - 1))\n+\t == (2 * <MODE_SIZE> * BITS_PER_UNIT - 1)))\n+   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -12841,6 +12882,15 @@\n \t   (any_shiftrt:DWIH (match_dup 7) (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n {\n+  if ((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) != 0)\n+    {\n+      operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+      operands[2] = gen_lowpart (QImode, operands[2]);\n+      emit_insn (gen_<insn><dwi>3_doubleword (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+      DONE;\n+    }\n+\n   split_double_mode (<DWI>mode, &operands[0], 2, &operands[4], &operands[6]);\n \n   operands[8] = GEN_INT (<MODE_SIZE> * BITS_PER_UNIT - 1);\n@@ -12854,6 +12904,7 @@\n       operands[2] = tem;\n     }\n \n+  operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n   operands[2] = gen_lowpart (QImode, operands[2]);\n \n   if (!rtx_equal_p (operands[4], operands[5]))\n@@ -12868,7 +12919,9 @@\n \t    (match_operand:QI 2 \"register_operand\" \"c\")\n \t    (match_operand:QI 3 \"const_int_operand\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+  \"((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) == 0\n+    || ((INTVAL (operands[3]) & (2 * <MODE_SIZE> * BITS_PER_UNIT - 1))\n+\t == (2 * <MODE_SIZE> * BITS_PER_UNIT - 1)))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -12886,6 +12939,13 @@\n \t   (any_shiftrt:DWIH (match_dup 7) (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n {\n+  if ((INTVAL (operands[3]) & (<MODE_SIZE> * BITS_PER_UNIT)) != 0)\n+    {\n+      emit_insn (gen_<insn><dwi>3_doubleword (operands[0], operands[1],\n+\t\t\t\t\t      operands[2]));\n+      DONE;\n+    }\n+\n   split_double_mode (<DWI>mode, &operands[0], 2, &operands[4], &operands[6]);\n \n   operands[8] = GEN_INT (<MODE_SIZE> * BITS_PER_UNIT - 1);\n@@ -12903,7 +12963,7 @@\n     emit_move_insn (operands[4], operands[5]);\n })\n \n-(define_insn_and_split \"*<insn><mode>3_doubleword\"\n+(define_insn_and_split \"<insn><mode>3_doubleword\"\n   [(set (match_operand:DWI 0 \"register_operand\" \"=&r\")\n \t(any_shiftrt:DWI (match_operand:DWI 1 \"register_operand\" \"0\")\n \t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n@@ -13586,13 +13646,16 @@\n \t(any_rotate:SWI\n \t  (match_operand:SWI 1 \"nonimmediate_operand\")\n \t  (subreg:QI\n-\t    (and:SI\n-\t      (match_operand:SI 2 \"register_operand\" \"c\")\n-\t      (match_operand:SI 3 \"const_int_operand\")) 0)))\n+\t    (and\n+\t      (match_operand 2 \"register_operand\" \"c\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\n    && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n+   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -13601,18 +13664,24 @@\n \t   (any_rotate:SWI (match_dup 1)\n \t\t\t   (match_dup 2)))\n       (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = gen_lowpart (QImode, operands[2]);\")\n+{\n+  operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+  operands[2] = gen_lowpart (QImode, operands[2]);\n+})\n \n (define_split\n   [(set (match_operand:SWI 0 \"register_operand\")\n \t(any_rotate:SWI\n \t  (match_operand:SWI 1 \"const_int_operand\")\n \t  (subreg:QI\n-\t    (and:SI\n-\t      (match_operand:SI 2 \"register_operand\")\n-\t      (match_operand:SI 3 \"const_int_operand\")) 0)))]\n+\t    (and\n+\t      (match_operand 2 \"register_operand\")\n+\t      (match_operand 3 \"const_int_operand\")) 0)))]\n  \"(INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode) - 1))\n-   == GET_MODE_BITSIZE (<MODE>mode) - 1\"\n+   == GET_MODE_BITSIZE (<MODE>mode) - 1\n+  && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+  && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t       4 << (TARGET_64BIT ? 1 : 0))\"\n  [(set (match_dup 4) (match_dup 1))\n   (set (match_dup 0)\n        (any_rotate:SWI (match_dup 4)\n@@ -13976,14 +14045,17 @@\n \t  (ashift:SWI48\n \t    (const_int 1)\n \t    (subreg:QI\n-\t      (and:SI\n-\t\t(match_operand:SI 1 \"register_operand\")\n-\t\t(match_operand:SI 2 \"const_int_operand\")) 0))\n+\t      (and\n+\t\t(match_operand 1 \"register_operand\")\n+\t\t(match_operand 2 \"const_int_operand\")) 0))\n \t  (match_operand:SWI48 3 \"register_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_USE_BT\n    && (INTVAL (operands[2]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n+   && GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[1])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -13994,7 +14066,10 @@\n \t\t\t   (match_dup 1))\n \t     (match_dup 3)))\n       (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = gen_lowpart (QImode, operands[1]);\")\n+{\n+  operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n+  operands[1] = gen_lowpart (QImode, operands[1]);\n+})\n \n (define_insn_and_split \"*<btsc><mode>_mask_1\"\n   [(set (match_operand:SWI48 0 \"register_operand\")\n@@ -14041,14 +14116,17 @@\n \t  (rotate:SWI48\n \t    (const_int -2)\n \t    (subreg:QI\n-\t      (and:SI\n-\t\t(match_operand:SI 1 \"register_operand\")\n-\t\t(match_operand:SI 2 \"const_int_operand\")) 0))\n+\t      (and\n+\t\t(match_operand 1 \"register_operand\")\n+\t\t(match_operand 2 \"const_int_operand\")) 0))\n \t  (match_operand:SWI48 3 \"register_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_USE_BT\n    && (INTVAL (operands[2]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n       == GET_MODE_BITSIZE (<MODE>mode)-1\n+   && GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[1])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n    && ix86_pre_reload_split ()\"\n   \"#\"\n   \"&& 1\"\n@@ -14059,7 +14137,10 @@\n \t\t\t   (match_dup 1))\n \t     (match_dup 3)))\n       (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = gen_lowpart (QImode, operands[1]);\")\n+{\n+  operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n+  operands[1] = gen_lowpart (QImode, operands[1]);\n+})\n \n (define_insn_and_split \"*btr<mode>_mask_1\"\n   [(set (match_operand:SWI48 0 \"register_operand\")\n@@ -14410,6 +14491,47 @@\n   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));\n })\n \n+(define_insn_and_split \"*jcc_bt<mode>_mask_1\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"bt_comparison_operator\"\n+\t\t\t[(zero_extract:SWI48\n+\t\t\t   (match_operand:SWI48 1 \"register_operand\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (zero_extend:SI\n+\t\t\t     (subreg:QI\n+\t\t\t       (and\n+\t\t\t\t (match_operand 2 \"register_operand\")\n+\t\t\t\t (match_operand 3 \"const_int_operand\")) 0)))])\n+\t\t      (label_ref (match_operand 4))\n+\t\t      (pc)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(TARGET_USE_BT || optimize_function_for_size_p (cfun))\n+   && (INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode)-1))\n+      == GET_MODE_BITSIZE (<MODE>mode)-1\n+   && GET_MODE_CLASS (GET_MODE (operands[2])) == MODE_INT\n+   && IN_RANGE (GET_MODE_SIZE (GET_MODE (operands[2])), 2,\n+\t\t4 << (TARGET_64BIT ? 1 : 0))\n+   && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (zero_extract:SWI48\n+\t    (match_dup 1)\n+\t    (const_int 1)\n+\t    (match_dup 2))\n+\t  (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0 [(reg:CCC FLAGS_REG) (const_int 0)])\n+\t\t      (label_ref (match_dup 4))\n+\t\t      (pc)))]\n+{\n+  operands[2] = force_reg (GET_MODE (operands[2]), operands[2]);\n+  operands[2] = gen_lowpart (SImode, operands[2]);\n+  operands[0] = shallow_copy_rtx (operands[0]);\n+  PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));\n+})\n+\n ;; Help combine recognize bt followed by cmov\n (define_split\n   [(set (match_operand:SWI248 0 \"register_operand\")"}, {"sha": "bf0490401d7a21d0158f18f920c437cb0a3ac5ff", "filename": "gcc/testsuite/gcc.target/i386/pr105778.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfdd2851b297e0005a8490b7f867ca45d1ad340/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105778.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfdd2851b297e0005a8490b7f867ca45d1ad340/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105778.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105778.c?ref=dcfdd2851b297e0005a8490b7f867ca45d1ad340", "patch": "@@ -0,0 +1,45 @@\n+/* PR target/105778 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not \"\\tand\\[^\\n\\r]*\\(31\\|63\\|127\\|255\\)\" } } */\n+\n+unsigned int f1 (unsigned int x, unsigned long y) { y &= 31; return x << y; }\n+unsigned int f2 (unsigned int x, unsigned long y) { return x << (y & 31); }\n+unsigned int f3 (unsigned int x, unsigned long y) { y &= 31; return x >> y; }\n+unsigned int f4 (unsigned int x, unsigned long y) { return x >> (y & 31); }\n+int f5 (int x, unsigned long y) { y &= 31; return x >> y; }\n+int f6 (int x, unsigned long y) { return x >> (y & 31); }\n+unsigned long long f7 (unsigned long long x, unsigned long y) { y &= 63; return x << y; }\n+unsigned long long f8 (unsigned long long x, unsigned long y) { return x << (y & 63); }\n+unsigned long long f9 (unsigned long long x, unsigned long y) { y &= 63; return x >> y; }\n+unsigned long long f10 (unsigned long long x, unsigned long y) { return x >> (y & 63); }\n+long long f11 (long long x, unsigned long y) { y &= 63; return x >> y; }\n+long long f12 (long long x, unsigned long y) { return x >> (y & 63); }\n+#ifdef __SIZEOF_INT128__\n+unsigned __int128 f13 (unsigned __int128 x, unsigned long y) { y &= 127; return x << y; }\n+unsigned __int128 f14 (unsigned __int128 x, unsigned long y) { return x << (y & 127); }\n+unsigned __int128 f15 (unsigned __int128 x, unsigned long y) { y &= 127; return x >> y; }\n+unsigned __int128 f16 (unsigned __int128 x, unsigned long y) { return x >> (y & 127); }\n+__int128 f17 (__int128 x, unsigned long y) { y &= 127; return x >> y; }\n+__int128 f18 (__int128 x, unsigned long y) { return x >> (y & 127); }\n+#endif\n+unsigned int f19 (unsigned int x, unsigned long y) { y &= 63; return x << y; }\n+unsigned int f20 (unsigned int x, unsigned long y) { return x << (y & 63); }\n+unsigned int f21 (unsigned int x, unsigned long y) { y &= 63; return x >> y; }\n+unsigned int f22 (unsigned int x, unsigned long y) { return x >> (y & 63); }\n+int f23 (int x, unsigned long y) { y &= 63; return x >> y; }\n+int f24 (int x, unsigned long y) { return x >> (y & 63); }\n+unsigned long long f25 (unsigned long long x, unsigned long y) { y &= 127; return x << y; }\n+unsigned long long f26 (unsigned long long x, unsigned long y) { return x << (y & 127); }\n+unsigned long long f27 (unsigned long long x, unsigned long y) { y &= 127; return x >> y; }\n+unsigned long long f28 (unsigned long long x, unsigned long y) { return x >> (y & 127); }\n+long long f29 (long long x, unsigned long y) { y &= 127; return x >> y; }\n+long long f30 (long long x, unsigned long y) { return x >> (y & 127); }\n+#ifdef __SIZEOF_INT128__\n+unsigned __int128 f31 (unsigned __int128 x, unsigned long y) { y &= 255; return x << y; }\n+unsigned __int128 f32 (unsigned __int128 x, unsigned long y) { return x << (y & 255); }\n+unsigned __int128 f33 (unsigned __int128 x, unsigned long y) { y &= 255; return x >> y; }\n+unsigned __int128 f34 (unsigned __int128 x, unsigned long y) { return x >> (y & 255); }\n+__int128 f35 (__int128 x, unsigned long y) { y &= 255; return x >> y; }\n+__int128 f36 (__int128 x, unsigned long y) { return x >> (y & 255); }\n+#endif"}]}