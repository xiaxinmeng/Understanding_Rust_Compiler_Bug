{"sha": "12f8dc0b642db5edc702f252af1a5231606b29db", "node_id": "C_kwDOANBUbNoAKDEyZjhkYzBiNjQyZGI1ZWRjNzAyZjI1MmFmMWE1MjMxNjA2YjI5ZGI", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-03-02T17:13:06Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2022-03-02T17:13:06Z"}, "message": "Undo multi-word optional reloads correctly\n\nUnlike e.g. remove_inheritance_pseudos, undo_optional_reloads didn't\ndeal with subregs, so instead of removing multi-word moves, it\nreplaced the reload pseudo with the original pseudo.  Besides the\nredundant move, that retained the clobber of the dest, that starts a\nmulti-word move.  After the remap, the sequence that should have\nbecome a no-op move starts by clobbering the original pseudo and then\nmoving its pieces onto themselves.  The problem is the clobber: it\nmakes earlier sets of the original pseudo to be regarded as dead: if\nthe optional reload sequence was an output reload, the insn for which\nthe output reload was attempted may be regarded as dead and deleted.\n\nI've arranged for undo_optional_reloads to accept SUBREGs and use\nget_regno, like remove_inheritance_pseudo, adjusted its insn-removal\nloop to tolerate iterating over a removed clobber, and added logic to\ncatch any left-over reload clobbers that could trigger the problem.\n\n\nfor  gcc/ChangeLog\n\n\t* lra-constraints.cc (undo_optional_reloads): Recognize and\n\tdrop insns of multi-word move sequences, tolerate removal\n\titeration on an already-removed clobber, and refuse to\n\tsubstitute original pseudos into clobbers.", "tree": {"sha": "76ed9d7ed0b6eeedaacac523fa0a609a569e4328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76ed9d7ed0b6eeedaacac523fa0a609a569e4328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f8dc0b642db5edc702f252af1a5231606b29db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f8dc0b642db5edc702f252af1a5231606b29db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f8dc0b642db5edc702f252af1a5231606b29db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f8dc0b642db5edc702f252af1a5231606b29db/comments", "author": null, "committer": null, "parents": [{"sha": "dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbaabd06aaf4a1b0f2a20671c39148a0bd6ccf0e"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "5cd89e7eeddc279147c1bd145666b50da486a8ef", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f8dc0b642db5edc702f252af1a5231606b29db/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f8dc0b642db5edc702f252af1a5231606b29db/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=12f8dc0b642db5edc702f252af1a5231606b29db", "patch": "@@ -7261,15 +7261,17 @@ undo_optional_reloads (void)\n \t      continue;\n \t    src = SET_SRC (set);\n \t    dest = SET_DEST (set);\n-\t    if (! REG_P (src) || ! REG_P (dest))\n+\t    if ((! REG_P (src) && ! SUBREG_P (src))\n+\t\t|| (! REG_P (dest) && ! SUBREG_P (dest)))\n \t      continue;\n-\t    if (REGNO (dest) == regno\n+\t    if (get_regno (dest) == (int) regno\n \t\t/* Ignore insn for optional reloads itself.  */\n-\t\t&& REGNO (lra_reg_info[regno].restore_rtx) != REGNO (src)\n+\t\t&& (get_regno (lra_reg_info[regno].restore_rtx)\n+\t\t    != get_regno (src))\n \t\t/* Check only inheritance on last inheritance pass.  */\n-\t\t&& (int) REGNO (src) >= new_regno_start\n+\t\t&& get_regno (src) >= new_regno_start\n \t\t/* Check that the optional reload was inherited.  */\n-\t\t&& bitmap_bit_p (&lra_inheritance_pseudos, REGNO (src)))\n+\t\t&& bitmap_bit_p (&lra_inheritance_pseudos, get_regno (src)))\n \t      {\n \t\tkeep_p = true;\n \t\tbreak;\n@@ -7291,26 +7293,30 @@ undo_optional_reloads (void)\n       bitmap_copy (insn_bitmap, &lra_reg_info[regno].insn_bitmap);\n       EXECUTE_IF_SET_IN_BITMAP (insn_bitmap, 0, uid, bi2)\n \t{\n+\t  /* We may have already removed a clobber.  */\n+\t  if (!lra_insn_recog_data[uid])\n+\t    continue;\n \t  insn = lra_insn_recog_data[uid]->insn;\n \t  if ((set = single_set (insn)) != NULL_RTX)\n \t    {\n \t      src = SET_SRC (set);\n \t      dest = SET_DEST (set);\n-\t      if (REG_P (src) && REG_P (dest)\n-\t\t  && ((REGNO (src) == regno\n-\t\t       && (REGNO (lra_reg_info[regno].restore_rtx)\n-\t\t\t   == REGNO (dest)))\n-\t\t      || (REGNO (dest) == regno\n-\t\t\t  && (REGNO (lra_reg_info[regno].restore_rtx)\n-\t\t\t      == REGNO (src)))))\n+\t      if ((REG_P (src) || SUBREG_P (src))\n+\t\t  && (REG_P (dest) || SUBREG_P (dest))\n+\t\t  && ((get_regno (src) == (int) regno\n+\t\t       && (get_regno (lra_reg_info[regno].restore_rtx)\n+\t\t\t   == get_regno (dest)))\n+\t\t      || (get_regno (dest) == (int) regno\n+\t\t\t  && (get_regno (lra_reg_info[regno].restore_rtx)\n+\t\t\t      == get_regno (src)))))\n \t\t{\n \t\t  if (lra_dump_file != NULL)\n \t\t    {\n \t\t      fprintf (lra_dump_file, \"  Deleting move %u\\n\",\n \t\t\t       INSN_UID (insn));\n \t\t      dump_insn_slim (lra_dump_file, insn);\n \t\t    }\n-\t\t  delete_move_and_clobber (insn, REGNO (dest));\n+\t\t  delete_move_and_clobber (insn, get_regno (dest));\n \t\t  continue;\n \t\t}\n \t      /* We should not worry about generation memory-memory\n@@ -7319,6 +7325,11 @@ undo_optional_reloads (void)\n \t\t we remove the inheritance pseudo and the optional\n \t\t reload.  */\n \t    }\n+\t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+\t      && REG_P (SET_DEST (insn))\n+\t      && get_regno (SET_DEST (insn)) == (int) regno)\n+\t    /* Refuse to remap clobbers to preexisting pseudos.  */\n+\t    gcc_unreachable ();\n \t  lra_substitute_pseudo_within_insn\n \t    (insn, regno, lra_reg_info[regno].restore_rtx, false);\n \t  lra_update_insn_regno_info (insn);"}]}