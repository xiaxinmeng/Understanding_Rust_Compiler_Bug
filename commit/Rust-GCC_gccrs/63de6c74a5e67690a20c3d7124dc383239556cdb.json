{"sha": "63de6c74a5e67690a20c3d7124dc383239556cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNkZTZjNzRhNWU2NzY5MGEyMGMzZDcxMjRkYzM4MzIzOTU1NmNkYg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-09-06T21:55:23Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-09-06T21:55:23Z"}, "message": "* haifa-sched.c: Tidy comments.\n\nFrom-SVN: r29145", "tree": {"sha": "987746a355d3e597063069ed2d10b28ca26fe023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/987746a355d3e597063069ed2d10b28ca26fe023"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63de6c74a5e67690a20c3d7124dc383239556cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63de6c74a5e67690a20c3d7124dc383239556cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63de6c74a5e67690a20c3d7124dc383239556cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63de6c74a5e67690a20c3d7124dc383239556cdb/comments", "author": null, "committer": null, "parents": [{"sha": "4bbebb32e6b131a20907ae734e0f816c59d1ae91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bbebb32e6b131a20907ae734e0f816c59d1ae91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bbebb32e6b131a20907ae734e0f816c59d1ae91"}], "stats": {"total": 527, "additions": 277, "deletions": 250}, "files": [{"sha": "4871d1ae99f52019ae2f9392fd2729067b16ea49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63de6c74a5e67690a20c3d7124dc383239556cdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63de6c74a5e67690a20c3d7124dc383239556cdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63de6c74a5e67690a20c3d7124dc383239556cdb", "patch": "@@ -1,3 +1,7 @@\n+Tue Sep  7 09:36:01 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* haifa-sched.c: Tidy comments.\n+\n Mon Sep  6 14:30:13 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* Makefile.in (C_AND_OBJC_OBJS): Remove ggc-callbacks.o."}, {"sha": "a4bf5c4be2ae194efbdb71cfc5b4e5fbc3b02f99", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 273, "deletions": 250, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63de6c74a5e67690a20c3d7124dc383239556cdb/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63de6c74a5e67690a20c3d7124dc383239556cdb/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=63de6c74a5e67690a20c3d7124dc383239556cdb", "patch": "@@ -177,10 +177,10 @@ extern rtx *reg_known_value;\n \n /* target_units bitmask has 1 for each unit in the cpu.  It should be\n    possible to compute this variable from the machine description.\n-   But currently it is computed by examinning the insn list.  Since\n+   But currently it is computed by examining the insn list.  Since\n    this is only needed for visualization, it seems an acceptable\n    solution.  (For understanding the mapping of bits to units, see\n-   definition of function_units[] in \"insn-attrtab.c\") */\n+   definition of function_units[] in \"insn-attrtab.c\".)  */\n \n static int target_units = 0;\n \n@@ -209,11 +209,11 @@ static int issue_rate;\n static int sched_verbose_param = 0;\n static int sched_verbose = 0;\n \n-/* nr_inter/spec counts interblock/speculative motion for the function */\n+/* nr_inter/spec counts interblock/speculative motion for the function.  */\n static int nr_inter, nr_spec;\n \n \n-/* debugging file. all printouts are sent to dump, which is always set,\n+/* Debugging file.  All printouts are sent to dump, which is always set,\n    either to stderr, or to the dump listing file (-dRS).  */\n static FILE *dump = 0;\n \n@@ -274,8 +274,9 @@ static short *insn_costs;\n static short *insn_units;\n #define INSN_UNIT(INSN)\tinsn_units[INSN_UID (INSN)]\n \n-/* Vector indexed by INSN_UID giving each instruction a register-weight.\n-   This weight is an estimation of the insn contribution to registers pressure.  */\n+/* Vector indexed by INSN_UID giving each instruction a\n+   register-weight.  This weight is an estimation of the insn\n+   contribution to registers pressure.  */\n static int *insn_reg_weight;\n #define INSN_REG_WEIGHT(INSN) (insn_reg_weight[INSN_UID (INSN)])\n \n@@ -317,7 +318,8 @@ static unsigned int *insn_blockage;\n #define DONE_PRIORITY_P(INSN) (INSN_PRIORITY (INSN) < 0)\n #define LOW_PRIORITY_P(INSN) ((INSN_PRIORITY (INSN) & 0x7f000000) == 0)\n \n-/* Vector indexed by INSN_UID giving number of insns referring to this insn.  */\n+/* Vector indexed by INSN_UID giving number of insns referring to this\n+   insn.  */\n static int *insn_ref_count;\n #define INSN_REF_COUNT(INSN) (insn_ref_count[INSN_UID (INSN)])\n \n@@ -481,11 +483,11 @@ static haifa_edge *edge_table;\n #define FROM_BLOCK(edge) (edge_table[edge].from_block)\n #define TO_BLOCK(edge) (edge_table[edge].to_block)\n \n-/* Number of edges in the control flow graph.  (in fact larger than\n-   that by 1, since edge 0 is unused.) */\n+/* Number of edges in the control flow graph.  (In fact, larger than\n+   that by 1, since edge 0 is unused.)  */\n static int nr_edges;\n \n-/* Circular list of incoming/outgoing edges of a block */\n+/* Circular list of incoming/outgoing edges of a block.  */\n static int *in_edges;\n static int *out_edges;\n \n@@ -505,26 +507,24 @@ static void new_edge PROTO ((int, int));\n    control flow graph edges, in the 'up' direction.  */\n typedef struct\n   {\n-    int rgn_nr_blocks;\t\t/* number of blocks in region */\n-    int rgn_blocks;\t\t/* blocks in the region (actually index in rgn_bb_table) */\n+    int rgn_nr_blocks;\t\t/* Number of blocks in region.  */\n+    int rgn_blocks;\t\t/* cblocks in the region (actually index in rgn_bb_table).  */\n   }\n region;\n \n-/* Number of regions in the procedure */\n+/* Number of regions in the procedure.  */\n static int nr_regions;\n \n-/* Table of region descriptions */\n+/* Table of region descriptions.  */\n static region *rgn_table;\n \n-/* Array of lists of regions' blocks */\n+/* Array of lists of regions' blocks.  */\n static int *rgn_bb_table;\n \n /* Topological order of blocks in the region (if b2 is reachable from\n-   b1, block_to_bb[b2] > block_to_bb[b1]).\n-   Note: A basic block is always referred to by either block or b,\n-   while its topological order name (in the region) is refered to by\n-   bb.\n- */\n+   b1, block_to_bb[b2] > block_to_bb[b1]).  Note: A basic block is\n+   always referred to by either block or b, while its topological\n+   order name (in the region) is refered to by bb.  */\n static int *block_to_bb;\n \n /* The number of the region containing a block.  */\n@@ -547,7 +547,7 @@ extern void debug_live PROTO ((int, int));\n static int current_nr_blocks;\n static int current_blocks;\n \n-/* The mapping from bb to block */\n+/* The mapping from bb to block.  */\n #define BB_TO_BLOCK(bb) (rgn_bb_table[current_blocks + (bb)])\n \n \n@@ -557,8 +557,8 @@ static int current_blocks;\n typedef unsigned HOST_WIDE_INT *bitset;\n typedef struct\n   {\n-    int *first_member;\t\t/* pointer to the list start in bitlst_table.  */\n-    int nr_members;\t\t/* the number of members of the bit list.     */\n+    int *first_member;\t\t/* Pointer to the list start in bitlst_table.  */\n+    int nr_members;\t\t/* The number of members of the bit list.  */\n   }\n bitlst;\n \n@@ -569,7 +569,7 @@ static int *bitlst_table;\n static char bitset_member PROTO ((bitset, int, int));\n static void extract_bitlst PROTO ((bitset, int, bitlst *));\n \n-/* target info declarations.\n+/* Target info declarations.\n \n    The block currently being scheduled is referred to as the \"target\" block,\n    while other blocks in the region from which insns can be moved to the\n@@ -593,8 +593,8 @@ static candidate *candidate_table;\n    After a speculative motion, live information should be modified in\n    the 'update' blocks.\n \n-   Lists of split and update blocks for  each candidate of the current\n-   target  are  in  array bblst_table */\n+   Lists of split and update blocks for each candidate of the current\n+   target are in array bblst_table.  */\n static int *bblst_table, bblst_size, bblst_last;\n \n #define IS_VALID(src) ( candidate_table[src].is_valid )\n@@ -607,7 +607,7 @@ static int target_bb;\n /* List of edges.  */\n typedef bitlst edgelst;\n \n-/* target info functions */\n+/* Target info functions.  */\n static void split_edges PROTO ((int, int, edgelst *));\n static void compute_trg_info PROTO ((int));\n void debug_candidate PROTO ((int));\n@@ -624,7 +624,7 @@ static int bbset_size;\n    bb i in the region.  */\n static bbset *dom;\n \n-/* bb 0 is the only region entry */\n+/* bb 0 is the only region entry.  */\n #define IS_RGN_ENTRY(bb) (!bb)\n \n /* Is bb_src dominated by bb_trg.  */\n@@ -635,7 +635,7 @@ static bbset *dom;\n    of bb i relative to the region entry.  */\n static float *prob;\n \n-/*  The probability of bb_src, relative to bb_trg.  Note, that while the\n+/* The probability of bb_src, relative to bb_trg.  Note, that while the\n    'prob[bb]' is a float in [0, 1], this macro returns an integer\n    in [0, 100].  */\n #define GET_SRC_PROB(bb_src, bb_trg) ((int) (100.0 * (prob[bb_src] / \\\n@@ -647,10 +647,10 @@ typedef bitset edgeset;\n /* Number of edges in the region.  */\n static int rgn_nr_edges;\n \n-/* Array of size rgn_nr_edges.    */\n+/* Array of size rgn_nr_edges.  */\n static int *rgn_edges;\n \n-/* Number of words in an edgeset.    */\n+/* Number of words in an edgeset.  */\n static int edgeset_size;\n \n /* Mapping from each edge in the graph to its number in the rgn.  */\n@@ -675,12 +675,12 @@ static void compute_dom_prob_ps PROTO ((int));\n #define IS_SPECULATIVE_INSN(INSN) (IS_SPECULATIVE (BLOCK_TO_BB (INSN_BLOCK (INSN))))\n #define INSN_BB(INSN) (BLOCK_TO_BB (INSN_BLOCK (INSN)))\n \n-/* parameters affecting the decision of rank_for_schedule() */\n+/* Parameters affecting the decision of rank_for_schedule().  */\n #define MIN_DIFF_PRIORITY 2\n #define MIN_PROBABILITY 40\n #define MIN_PROB_DIFF 10\n \n-/* speculative scheduling functions */\n+/* Speculative scheduling functions.  */\n static int check_live_1 PROTO ((int, rtx));\n static void update_live_1 PROTO ((int, rtx));\n static int check_live PROTO ((rtx, int));\n@@ -986,7 +986,7 @@ static rtx *bb_last_pending_memory_flush;\n static rtx *bb_last_function_call;\n static rtx *bb_sched_before_next_call;\n \n-/* functions for construction of the control flow graph.  */\n+/* Functions for construction of the control flow graph.  */\n \n /* Return 1 if control flow graph should not be constructed, 0 otherwise.\n \n@@ -1023,7 +1023,7 @@ is_cfg_nonregular ()\n \n   /* If we have non-jumping insns which refer to labels, then we consider\n      the cfg not well structured.  */\n-  /* check for labels referred to other thn by jumps */\n+  /* Check for labels referred to other thn by jumps.  */\n   for (b = 0; b < n_basic_blocks; b++)\n     for (insn = BLOCK_HEAD (b);; insn = NEXT_INSN (insn))\n       {\n@@ -1097,7 +1097,7 @@ build_control_flow (s_preds, s_succs, num_preds, num_succs)\n \t  new_edge (i, INT_LIST_VAL (succ));\n       }\n \n-  /* increment by 1, since edge 0 is unused.  */\n+  /* Increment by 1, since edge 0 is unused.  */\n   nr_edges++;\n \n   return unreachable;\n@@ -1117,7 +1117,7 @@ new_edge (source, target)\n   int e, next_edge;\n   int curr_edge, fst_edge;\n \n-  /* check for duplicates */\n+  /* Check for duplicates.  */\n   fst_edge = curr_edge = OUT_EDGES (source);\n   while (curr_edge)\n     {\n@@ -1166,28 +1166,28 @@ new_edge (source, target)\n \n /* BITSET macros for operations on the control flow graph.  */\n \n-/* Compute  bitwise union  of two  bitsets.  */\n+/* Compute bitwise union of two bitsets.  */\n #define BITSET_UNION(set1, set2, len)                                \\\n do { register bitset tp = set1, sp = set2;                           \\\n      register int i;                                                 \\\n      for (i = 0; i < len; i++)                                       \\\n        *(tp++) |= *(sp++); } while (0)\n \n-/* Compute  bitwise intersection  of two  bitsets.  */\n+/* Compute bitwise intersection of two bitsets.  */\n #define BITSET_INTER(set1, set2, len)                                \\\n do { register bitset tp = set1, sp = set2;                           \\\n      register int i;                                                 \\\n      for (i = 0; i < len; i++)                                       \\\n        *(tp++) &= *(sp++); } while (0)\n \n-/* Compute bitwise   difference of  two bitsets.  */\n+/* Compute bitwise difference of two bitsets.  */\n #define BITSET_DIFFER(set1, set2, len)                               \\\n do { register bitset tp = set1, sp = set2;                           \\\n      register int i;                                                 \\\n      for (i = 0; i < len; i++)                                       \\\n        *(tp++) &= ~*(sp++); } while (0)\n \n-/* Inverts every bit of bitset 'set' */\n+/* Inverts every bit of bitset 'set'.  */\n #define BITSET_INVERT(set, len)                                      \\\n do { register bitset tmpset = set;                                   \\\n      register int i;                                                 \\\n@@ -1215,7 +1215,7 @@ do { register bitset tmpset = set;                                   \\\n }\n \n \n-/* Check if the index'th bit in bitset  set is on.  */\n+/* Check if the index'th bit in bitset set is on.  */\n \n static char\n bitset_member (set, index, len)\n@@ -1240,7 +1240,7 @@ extract_bitlst (set, len, bl)\n   int i, j, offset;\n   unsigned HOST_WIDE_INT word;\n \n-  /* bblst table space is reused in each call to extract_bitlst */\n+  /* bblst table space is reused in each call to extract_bitlst.  */\n   bitlst_table_last = 0;\n \n   bl->first_member = &bitlst_table[bitlst_table_last];\n@@ -1265,7 +1265,7 @@ extract_bitlst (set, len, bl)\n }\n \n \n-/* functions for the construction of regions */\n+/* Functions for the construction of regions.  */\n \n /* Print the regions, for debugging purposes.  Callable from debugger.  */\n \n@@ -1549,7 +1549,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n      to hold degree counts.  */\n   degree = dfs_nr;\n \n-  /* Compute the in-degree of every block in the graph */\n+  /* Compute the in-degree of every block in the graph.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     degree[i] = num_preds[i];\n \n@@ -1576,9 +1576,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \n \t      /* Now check that the loop is reducible.  We do this separate\n \t\t from finding inner loops so that we do not find a reducible\n-\t\t loop which contains an inner  non-reducible loop.\n+\t\t loop which contains an inner non-reducible loop.\n \n-\t\t A simple way to find reducible/natrual loops is to verify\n+\t\t A simple way to find reducible/natural loops is to verify\n \t\t that each block in the loop is dominated by the loop\n \t\t header.\n \n@@ -1598,8 +1598,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t    }\n \t\t}\n \n-\t      /* If we exited the loop early, then I is the header of a non\n-\t\t reducible loop and we should quit processing it now.  */\n+\t      /* If we exited the loop early, then I is the header of\n+\t\t a non-reducible loop and we should quit processing it\n+\t\t now.  */\n \t      if (j != n_basic_blocks)\n \t\tcontinue;\n \n@@ -1622,7 +1623,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t\t   - INSN_LUID (BLOCK_HEAD (i)));\n \n \n-\t      /* Find all loop latches (blocks which back edges to the loop\n+\t      /* Find all loop latches (blocks with back edges to the loop\n \t\t header) or all the leaf blocks in the cfg has no loops.\n \n \t\t Place those blocks into the queue.  */\n@@ -1743,9 +1744,10 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t  CONTAINING_RGN (i) = nr_regions;\n \t\t  BLOCK_TO_BB (i) = count = 0;\n \n-\t\t  /* Remove blocks from queue[] when their in degree becomes\n-\t\t zero.  Repeat until no blocks are left on the list.  This\n-\t\t produces a topological list of blocks in the region.  */\n+\t\t  /* Remove blocks from queue[] when their in degree\n+\t\t     becomes zero.  Repeat until no blocks are left on the\n+\t\t     list.  This produces a topological list of blocks in\n+\t\t     the region.  */\n \t\t  while (tail >= 0)\n \t\t    {\n \t\t      int_list_ptr ps;\n@@ -1795,7 +1797,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n }\n \n \n-/* functions for regions scheduling information */\n+/* Functions for regions scheduling information.  */\n \n /* Compute dominators, probability, and potential-split-edges of bb.\n    Assume that these values were already computed for bb's predecessors.  */\n@@ -1817,7 +1819,7 @@ compute_dom_prob_ps (bb)\n \n   fst_in_edge = nxt_in_edge = IN_EDGES (BB_TO_BLOCK (bb));\n \n-  /* intialize dom[bb] to '111..1' */\n+  /* Intialize dom[bb] to '111..1'.  */\n   BITSET_INVERT (dom[bb], bbset_size);\n \n   do\n@@ -1839,15 +1841,15 @@ compute_dom_prob_ps (bb)\n \n       BITSET_ADD (pot_split[bb], EDGE_TO_BIT (fst_out_edge), edgeset_size);\n \n-      /* the successor doesn't belong the region? */\n+      /* The successor doesn't belong in the region?  */\n       if (CONTAINING_RGN (TO_BLOCK (fst_out_edge)) !=\n \t  CONTAINING_RGN (BB_TO_BLOCK (bb)))\n \t++nr_rgn_out_edges;\n \n       while (fst_out_edge != nxt_out_edge)\n \t{\n \t  ++nr_out_edges;\n-\t  /* the successor doesn't belong the region? */\n+\t  /* The successor doesn't belong in the region?  */\n \t  if (CONTAINING_RGN (TO_BLOCK (nxt_out_edge)) !=\n \t      CONTAINING_RGN (BB_TO_BLOCK (bb)))\n \t    ++nr_rgn_out_edges;\n@@ -1856,9 +1858,9 @@ compute_dom_prob_ps (bb)\n \n \t}\n \n-      /* now nr_rgn_out_edges is the number of region-exit edges from pred,\n-         and nr_out_edges will be the number of pred out edges not leaving\n-         the region.  */\n+      /* Now nr_rgn_out_edges is the number of region-exit edges from\n+         pred, and nr_out_edges will be the number of pred out edges\n+         not leaving the region.  */\n       nr_out_edges -= nr_rgn_out_edges;\n       if (nr_rgn_out_edges > 0)\n \tprob[bb] += 0.9 * prob[BLOCK_TO_BB (pred)] / nr_out_edges;\n@@ -1875,7 +1877,7 @@ compute_dom_prob_ps (bb)\n     fprintf (dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb), (int) (100.0 * prob[bb]));\n }\t\t\t\t/* compute_dom_prob_ps */\n \n-/* functions for target info */\n+/* Functions for target info.  */\n \n /* Compute in BL the list of split-edges of bb_src relatively to bb_trg.\n    Note that bb_trg dominates bb_src.  */\n@@ -1909,7 +1911,7 @@ compute_trg_info (trg)\n   int check_block, update_idx;\n   int i, j, k, fst_edge, nxt_edge;\n \n-  /* define some of the fields for the target bb as well */\n+  /* Define some of the fields for the target bb as well.  */\n   sp = candidate_table + trg;\n   sp->is_valid = 1;\n   sp->is_speculative = 0;\n@@ -2031,7 +2033,7 @@ debug_candidates (trg)\n }\n \n \n-/* functions for speculative scheduing */\n+/* Functions for speculative scheduing.  */\n \n /* Return 0 if x is a set of a register alive in the beginning of one\n    of the split-blocks of src, otherwise return 1.  */\n@@ -2070,14 +2072,14 @@ check_live_1 (src, x)\n \n   if (regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n     {\n-      /* Global registers are assumed live */\n+      /* Global registers are assumed live.  */\n       return 0;\n     }\n   else\n     {\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  /* check for hard registers */\n+\t  /* Check for hard registers.  */\n \t  int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n \t  while (--j >= 0)\n \t    {\n@@ -2095,7 +2097,7 @@ check_live_1 (src, x)\n \t}\n       else\n \t{\n-\t  /* check for psuedo registers */\n+\t  /* Check for psuedo registers.  */\n \t  for (i = 0; i < candidate_table[src].split_bbs.nr_members; i++)\n \t    {\n \t      int b = candidate_table[src].split_bbs.first_member[i];\n@@ -2187,7 +2189,7 @@ check_live (insn, src)\n      rtx insn;\n      int src;\n {\n-  /* find the registers set by instruction */\n+  /* Find the registers set by instruction.  */\n   if (GET_CODE (PATTERN (insn)) == SET\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return check_live_1 (src, PATTERN (insn));\n@@ -2215,7 +2217,7 @@ update_live (insn, src)\n      rtx insn;\n      int src;\n {\n-  /* find the registers set by instruction */\n+  /* Find the registers set by instruction.  */\n   if (GET_CODE (PATTERN (insn)) == SET\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     update_live_1 (src, PATTERN (insn));\n@@ -2260,7 +2262,8 @@ update_live (insn, src)\n \n    - insn1 is not in the same block as load-insn\n    - there is a DEF-USE dependence chain (insn1, ..., load-insn)\n-   - test-insn is either a compare or a branch, not in the same block as load-insn\n+   - test-insn is either a compare or a branch, not in the same block\n+     as load-insn\n    - load-insn is reachable from test-insn\n    - there is a DEF-USE dependence chain (insn1, ..., test-insn)\n \n@@ -2298,8 +2301,8 @@ enum INSN_TRAP_CLASS\n #define WORST_CLASS(class1, class2) \\\n ((class1 > class2) ? class1 : class2)\n \n-/* Indexed by INSN_UID, and set if there's DEF-USE dependence between */\n-/* some speculatively moved load insn and this one.  */\n+/* Indexed by INSN_UID, and set if there's DEF-USE dependence between \n+   some speculatively moved load insn and this one.  */\n char *fed_by_spec_load;\n char *is_load_insn;\n \n@@ -2313,7 +2316,7 @@ char *is_load_insn;\n #define FED_BY_SPEC_LOAD(insn) (fed_by_spec_load[INSN_UID (insn)])\n #define IS_LOAD_INSN(insn) (is_load_insn[INSN_UID (insn)])\n \n-/* Non-zero iff the address is comprised from at most 1 register */\n+/* Non-zero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n   (GET_CODE (x) == REG\t\t\t\t\t\\\n    || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS   \\\n@@ -2334,8 +2337,8 @@ set_spec_fed (load_insn)\n       FED_BY_SPEC_LOAD (XEXP (link, 0)) = 1;\n }\t\t\t\t/* set_spec_fed */\n \n-/* On the path from the insn to load_insn_bb, find a conditional branch */\n-/* depending on insn, that guards the speculative load.  */\n+/* On the path from the insn to load_insn_bb, find a conditional\n+branch depending on insn, that guards the speculative load.  */\n \n static int\n find_conditional_protection (insn, load_insn_bb)\n@@ -2344,7 +2347,7 @@ find_conditional_protection (insn, load_insn_bb)\n {\n   rtx link;\n \n-  /* iterate through DEF-USE forward dependences */\n+  /* Iterate through DEF-USE forward dependences.  */\n   for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n     {\n       rtx next = XEXP (link, 0);\n@@ -2385,28 +2388,28 @@ is_conditionally_protected (load_insn, bb_src, bb_trg)\n     {\n       rtx insn1 = XEXP (link, 0);\n \n-      /* must be a DEF-USE dependence upon non-branch */\n+      /* Must be a DEF-USE dependence upon non-branch.  */\n       if (GET_MODE (link) != VOIDmode\n \t  || GET_CODE (insn1) == JUMP_INSN)\n \tcontinue;\n \n-      /* must exist a path: region-entry -> ... -> bb_trg -> ... load_insn */\n+      /* Must exist a path: region-entry -> ... -> bb_trg -> ... load_insn.  */\n       if (INSN_BB (insn1) == bb_src\n \t  || (CONTAINING_RGN (INSN_BLOCK (insn1))\n \t      != CONTAINING_RGN (BB_TO_BLOCK (bb_src)))\n \t  || (!IS_REACHABLE (bb_trg, INSN_BB (insn1))\n \t      && !IS_REACHABLE (INSN_BB (insn1), bb_trg)))\n \tcontinue;\n \n-      /* now search for the conditional-branch */\n+      /* Now search for the conditional-branch.  */\n       if (find_conditional_protection (insn1, bb_src))\n \treturn 1;\n \n-      /* recursive step: search another insn1, \"above\" current insn1.  */\n+      /* Recursive step: search another insn1, \"above\" current insn1.  */\n       return is_conditionally_protected (insn1, bb_src, bb_trg);\n     }\n \n-  /* the chain does not exsist */\n+  /* The chain does not exist.  */\n   return 0;\n }\t\t\t\t/* is_conditionally_protected */\n \n@@ -2435,7 +2438,7 @@ is_pfree (load_insn, bb_src, bb_trg)\n   register candidate *candp = candidate_table + bb_src;\n \n   if (candp->split_bbs.nr_members != 1)\n-    /* must have exactly one escape block */\n+    /* Must have exactly one escape block.  */\n     return 0;\n \n   for (back_link = LOG_LINKS (load_insn);\n@@ -2445,7 +2448,7 @@ is_pfree (load_insn, bb_src, bb_trg)\n \n       if (GET_MODE (back_link) == VOIDmode)\n \t{\n-\t  /* found a DEF-USE dependence (insn1, load_insn) */\n+\t  /* Found a DEF-USE dependence (insn1, load_insn).  */\n \t  rtx fore_link;\n \n \t  for (fore_link = INSN_DEPEND (insn1);\n@@ -2454,24 +2457,24 @@ is_pfree (load_insn, bb_src, bb_trg)\n \t      rtx insn2 = XEXP (fore_link, 0);\n \t      if (GET_MODE (fore_link) == VOIDmode)\n \t\t{\n-\t\t  /* found a DEF-USE dependence (insn1, insn2) */\n+\t\t  /* Found a DEF-USE dependence (insn1, insn2).  */\n \t\t  if (haifa_classify_insn (insn2) != PFREE_CANDIDATE)\n-\t\t    /* insn2 not guaranteed to be a 1 base reg load */\n+\t\t    /* insn2 not guaranteed to be a 1 base reg load.  */\n \t\t    continue;\n \n \t\t  if (INSN_BB (insn2) == bb_trg)\n-\t\t    /* insn2 is the similar load, in the target block */\n+\t\t    /* insn2 is the similar load, in the target block.  */\n \t\t    return 1;\n \n \t\t  if (*(candp->split_bbs.first_member) == INSN_BLOCK (insn2))\n-\t\t    /* insn2 is a similar load, in a split-block */\n+\t\t    /* insn2 is a similar load, in a split-block.  */\n \t\t    return 1;\n \t\t}\n \t    }\n \t}\n     }\n \n-  /* couldn't find a similar load */\n+  /* Couldn't find a similar load.  */\n   return 0;\n }\t\t\t\t/* is_pfree */\n \n@@ -2497,28 +2500,27 @@ may_trap_exp (x, is_store)\n     }\n   if (code == MEM)\n     {\n-      /* The insn uses memory */\n-      /* a volatile load */\n+      /* The insn uses memory:  a volatile load.  */\n       if (MEM_VOLATILE_P (x))\n \treturn IRISKY;\n-      /* an exception-free load */\n+      /* An exception-free load.  */\n       if (!may_trap_p (x))\n \treturn IFREE;\n-      /* a load with 1 base register, to be further checked */\n+      /* A load with 1 base register, to be further checked.  */\n       if (CONST_BASED_ADDRESS_P (XEXP (x, 0)))\n \treturn PFREE_CANDIDATE;\n-      /* no info on the load, to be further checked */\n+      /* No info on the load, to be further checked.  */\n       return PRISKY_CANDIDATE;\n     }\n   else\n     {\n       const char *fmt;\n       int i, insn_class = TRAP_FREE;\n \n-      /* neither store nor load, check if it may cause a trap */\n+      /* Neither store nor load, check if it may cause a trap.  */\n       if (may_trap_p (x))\n \treturn TRAP_RISKY;\n-      /* recursive step: walk the insn...  */\n+      /* Recursive step: walk the insn...  */\n       fmt = GET_RTX_FORMAT (code);\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n@@ -2574,15 +2576,15 @@ haifa_classify_insn (insn)\n \t  switch (code)\n \t    {\n \t    case CLOBBER:\n-\t      /* test if it is a 'store' */\n+\t      /* Test if it is a 'store'.  */\n \t      tmp_class = may_trap_exp (XEXP (XVECEXP (pat, 0, i), 0), 1);\n \t      break;\n \t    case SET:\n-\t      /* test if it is a store */\n+\t      /* Test if it is a store.  */\n \t      tmp_class = may_trap_exp (SET_DEST (XVECEXP (pat, 0, i)), 1);\n \t      if (tmp_class == TRAP_RISKY)\n \t\tbreak;\n-\t      /* test if it is a load  */\n+\t      /* Test if it is a load.  */\n \t      tmp_class =\n \t\tWORST_CLASS (tmp_class,\n \t\t\t   may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)), 0));\n@@ -2603,15 +2605,15 @@ haifa_classify_insn (insn)\n       switch (code)\n \t{\n \tcase CLOBBER:\n-\t  /* test if it is a 'store' */\n+\t  /* Test if it is a 'store'.  */\n \t  tmp_class = may_trap_exp (XEXP (pat, 0), 1);\n \t  break;\n \tcase SET:\n-\t  /* test if it is a store */\n+\t  /* Test if it is a store.  */\n \t  tmp_class = may_trap_exp (SET_DEST (pat), 1);\n \t  if (tmp_class == TRAP_RISKY)\n \t    break;\n-\t  /* test if it is a load  */\n+\t  /* Test if it is a load.  */\n \t  tmp_class =\n \t    WORST_CLASS (tmp_class,\n \t\t\t may_trap_exp (SET_SRC (pat), 0));\n@@ -2641,7 +2643,7 @@ is_prisky (load_insn, bb_src, bb_trg)\n     return 1;\n \n   if (LOG_LINKS (load_insn) == NULL)\n-    /* dependence may 'hide' out of the region.  */\n+    /* Dependence may 'hide' out of the region.  */\n     return 1;\n \n   if (is_conditionally_protected (load_insn, bb_src, bb_trg))\n@@ -2661,7 +2663,7 @@ is_exception_free (insn, bb_src, bb_trg)\n {\n   int insn_class = haifa_classify_insn (insn);\n \n-  /* handle non-load insns */\n+  /* Handle non-load insns.  */\n   switch (insn_class)\n     {\n     case TRAP_FREE:\n@@ -2671,7 +2673,7 @@ is_exception_free (insn, bb_src, bb_trg)\n     default:;\n     }\n \n-  /* handle loads */\n+  /* Handle loads.  */\n   if (!flag_schedule_speculative_load)\n     return 0;\n   IS_LOAD_INSN (insn) = 1;\n@@ -2684,7 +2686,7 @@ is_exception_free (insn, bb_src, bb_trg)\n     case PFREE_CANDIDATE:\n       if (is_pfree (insn, bb_src, bb_trg))\n \treturn 1;\n-      /* don't 'break' here: PFREE-candidate is also PRISKY-candidate */\n+      /* Don't 'break' here: PFREE-candidate is also PRISKY-candidate.  */\n     case PRISKY_CANDIDATE:\n       if (!flag_schedule_speculative_load_dangerous\n \t  || is_prisky (insn, bb_src, bb_trg))\n@@ -2726,7 +2728,8 @@ find_insn_list (insn, list)\n }\n \n \n-/* Return 1 if the pair (insn, x) is found in (LIST, LIST1), or 0 otherwise.  */\n+/* Return 1 if the pair (insn, x) is found in (LIST, LIST1), or 0\n+   otherwise.  */\n \n HAIFA_INLINE static char\n find_insn_mem_list (insn, x, list, list1)\n@@ -2833,7 +2836,7 @@ clear_units ()\n   bzero ((char *) unit_n_insns, sizeof (unit_n_insns));\n }\n \n-/* Return the issue-delay of an insn */\n+/* Return the issue-delay of an insn.  */\n \n HAIFA_INLINE static int\n insn_issue_delay (insn)\n@@ -2842,7 +2845,7 @@ insn_issue_delay (insn)\n   int i, delay = 0;\n   int unit = insn_unit (insn);\n \n-  /* efficiency note: in fact, we are working 'hard' to compute a\n+  /* Efficiency note: in fact, we are working 'hard' to compute a\n      value that was available in md file, and is not available in\n      function_units[] structure.  It would be nice to have this\n      value there, too.  */\n@@ -2870,7 +2873,7 @@ actual_hazard_this_instance (unit, instance, insn, clock, cost)\n      int unit, instance, clock, cost;\n      rtx insn;\n {\n-  int tick = unit_tick[instance];\t/* issue time of the last issued insn */\n+  int tick = unit_tick[instance]; /* Issue time of the last issued insn.  */\n \n   if (tick - clock > cost)\n     {\n@@ -3057,7 +3060,7 @@ insn_cost (insn, link, used)\n \t}\n     }\n \n-  /* in this case estimate cost without caring how insn is used.  */\n+  /* In this case estimate cost without caring how insn is used.  */\n   if (link == 0 && used == 0)\n     return cost;\n \n@@ -3122,7 +3125,7 @@ priority (insn)\n \n \t    next = XEXP (link, 0);\n \n-\t    /* critical path is meaningful in block boundaries only */\n+\t    /* Critical path is meaningful in block boundaries only.  */\n \t    if (INSN_BLOCK (next) != INSN_BLOCK (insn))\n \t      continue;\n \n@@ -3151,7 +3154,7 @@ free_pending_lists ()\n     }\n   else\n     {\n-      /* interblock scheduling */\n+      /* Interblock scheduling.  */\n       int bb;\n \n       for (bb = 0; bb < current_nr_blocks; bb++)\n@@ -3222,7 +3225,7 @@ flush_pending_lists (insn, only_write)\n     }\n   pending_lists_length = 0;\n \n-  /* last_pending_memory_flush is now a list of insns */\n+  /* last_pending_memory_flush is now a list of insns.  */\n   for (u = last_pending_memory_flush; u; u = XEXP (u, 1))\n     add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n@@ -3289,8 +3292,9 @@ sched_analyze_1 (x, insn)\n \t      for (u = reg_last_sets[regno + i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \n-\t      /* Clobbers need not be ordered with respect to one another,\n-\t\t but sets must be ordered with respect to a pending clobber. */\n+\t      /* Clobbers need not be ordered with respect to one\n+\t\t another, but sets must be ordered with respect to a\n+\t\t pending clobber.  */\n \t      if (code == SET)\n \t\t{\n \t\t  free_INSN_LIST_list (&reg_last_uses[regno + i]);\n@@ -3485,7 +3489,8 @@ sched_analyze_2 (x, insn)\n \t  }\n \telse\n \t  {\n-\t    reg_last_uses[regno] = alloc_INSN_LIST (insn, reg_last_uses[regno]);\n+\t    reg_last_uses[regno] = alloc_INSN_LIST (insn,\n+\t\t\t\t\t\t    reg_last_uses[regno]);\n \n \t    for (u = reg_last_sets[regno]; u; u = XEXP (u, 1))\n \t      add_dependence (insn, XEXP (u, 0), 0);\n@@ -3726,9 +3731,9 @@ sched_analyze_insn (x, insn, loop_notes)\n \n     }\n \n-  /* Accumulate clobbers until the next set so that it will be output dependant\n+  /* Accumulate clobbers until the next set so that it will be output dependent\n      on all of them.  At the next set we can clear the clobber list, since\n-     subsequent sets will be output dependant on it.  */\n+     subsequent sets will be output dependent on it.  */\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t\t\t     {\n \t\t\t       free_INSN_LIST_list (&reg_last_sets[i]);\n@@ -3739,7 +3744,8 @@ sched_analyze_insn (x, insn, loop_notes)\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i,\n \t\t\t     {\n \t\t\t       reg_last_clobbers[i]\n-\t\t\t\t = alloc_INSN_LIST (insn, reg_last_clobbers[i]);\n+\t\t\t\t = alloc_INSN_LIST (insn, \n+\t\t\t\t\t\t    reg_last_clobbers[i]);\n \t\t\t     });\n   CLEAR_REG_SET (reg_pending_sets);\n   CLEAR_REG_SET (reg_pending_clobbers);\n@@ -3810,7 +3816,8 @@ sched_analyze (head, tail)\n \t  /* Clear out the stale LOG_LINKS from flow.  */\n \t  free_INSN_LIST_list (&LOG_LINKS (insn));\n \n-\t  /* Make each JUMP_INSN a scheduling barrier for memory references.  */\n+\t  /* Make each JUMP_INSN a scheduling barrier for memory\n+             references.  */\n \t  if (GET_CODE (insn) == JUMP_INSN)\n \t    last_pending_memory_flush\n \t      = alloc_INSN_LIST (insn, last_pending_memory_flush);\n@@ -3858,7 +3865,7 @@ sched_analyze (head, tail)\n \t\t}\n \t      reg_pending_sets_all = 1;\n \n-\t      /* Add a pair of fake REG_NOTE which we will later\n+\t      /* Add a pair of fake REG_NOTEs which we will later\n \t\t convert back into a NOTE_INSN_SETJMP note.  See\n \t\t reemit_notes for why we use a pair of NOTEs.  */\n \t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_DEAD,\n@@ -3905,13 +3912,13 @@ sched_analyze (head, tail)\n \t  /* Depend this function call (actually, the user of this\n \t     function call) on all hard register clobberage.  */\n \n-\t  /* last_function_call is now a list of insns */\n+\t  /* last_function_call is now a list of insns.  */\n \t  free_INSN_LIST_list(&last_function_call);\n \t  last_function_call = alloc_INSN_LIST (insn, NULL_RTX);\n \t}\n \n-      /* See comments on reemit_notes as to why we do this.  */\n-      /* ??? Actually, the reemit_notes just say what is done, not why.  */\n+      /* See comments on reemit_notes as to why we do this.  \n+\t ??? Actually, the reemit_notes just say what is done, not why.  */\n \n       else if (GET_CODE (insn) == NOTE\n \t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_START\n@@ -4068,36 +4075,36 @@ rank_for_schedule (x, y)\n   int val, priority_val, spec_val, prob_val, weight_val;\n \n \n-  /* prefer insn with higher priority */\n+  /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n   if (priority_val)\n     return priority_val;\n \n-  /* prefer an insn with smaller contribution to registers-pressure */\n+  /* Prefer an insn with smaller contribution to registers-pressure.  */\n   if (!reload_completed &&\n       (weight_val = INSN_REG_WEIGHT (tmp) - INSN_REG_WEIGHT (tmp2)))\n     return (weight_val);\n \n-  /* some comparison make sense in interblock scheduling only */\n+  /* Some comparison make sense in interblock scheduling only.  */\n   if (INSN_BB (tmp) != INSN_BB (tmp2))\n     {\n-      /* prefer an inblock motion on an interblock motion */\n+      /* Prefer an inblock motion on an interblock motion.  */\n       if ((INSN_BB (tmp2) == target_bb) && (INSN_BB (tmp) != target_bb))\n \treturn 1;\n       if ((INSN_BB (tmp) == target_bb) && (INSN_BB (tmp2) != target_bb))\n \treturn -1;\n \n-      /* prefer a useful motion on a speculative one */\n+      /* Prefer a useful motion on a speculative one.  */\n       if ((spec_val = IS_SPECULATIVE_INSN (tmp) - IS_SPECULATIVE_INSN (tmp2)))\n \treturn (spec_val);\n \n-      /* prefer a more probable (speculative) insn */\n+      /* Prefer a more probable (speculative) insn.  */\n       prob_val = INSN_PROBABILITY (tmp2) - INSN_PROBABILITY (tmp);\n       if (prob_val)\n \treturn (prob_val);\n     }\n \n-  /* compare insns based on their relation to the last-scheduled-insn */\n+  /* Compare insns based on their relation to the last-scheduled-insn.  */\n   if (last_scheduled_insn)\n     {\n       /* Classify the instructions into three classes:\n@@ -4317,7 +4324,8 @@ schedule_insn (insn, ready, n_ready, clock)\n \n   if (sched_verbose >= 2)\n     {\n-      fprintf (dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \", INSN_UID (insn));\n+      fprintf (dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n+\t       INSN_UID (insn));\n       insn_print_units (insn);\n       fprintf (dump, \"\\n\");\n     }\n@@ -4349,7 +4357,7 @@ schedule_insn (insn, ready, n_ready, clock)\n \t  int effective_cost = INSN_TICK (next) - clock;\n \n \t  /* For speculative insns, before inserting to ready/queue,\n-\t     check live, exception-free, and issue-delay */\n+\t     check live, exception-free, and issue-delay.  */\n \t  if (INSN_BB (next) != target_bb\n \t      && (!IS_VALID (INSN_BB (next))\n \t\t  || CANT_MOVE (next)\n@@ -4361,7 +4369,8 @@ schedule_insn (insn, ready, n_ready, clock)\n \n \t  if (sched_verbose >= 2)\n \t    {\n-\t      fprintf (dump, \";;\\t\\tdependences resolved: insn %d \", INSN_UID (next));\n+\t      fprintf (dump, \";;\\t\\tdependences resolved: insn %d \", \n+\t\t       INSN_UID (next));\n \n \t      if (current_nr_blocks > 1 && INSN_BB (next) != target_bb)\n \t\tfprintf (dump, \"/b%d \", INSN_BLOCK (next));\n@@ -4656,7 +4665,7 @@ attach_deaths (x, insn, set_p)\n \t  return;\n \t}\n \n-      /* fallthrough */\n+      /* Fallthrough.  */\n     default:\n       /* Other cases: walk the insn.  */\n       fmt = GET_RTX_FORMAT (code);\n@@ -4724,7 +4733,7 @@ attach_deaths_insn (insn)\n \t\t     GET_CODE (XEXP (link, 0)) == CLOBBER);\n }\n \n-/* functions for handlnig of notes */\n+/* Functions for handling of notes.  */\n \n /* Delete notes beginning with INSN and put them in the chain\n    of notes ended by NOTE_LIST.\n@@ -5107,7 +5116,7 @@ finish_sometimes_live (regs_sometimes_live, sometimes_max)\n     }\n }\n \n-/* functions for computation of registers live/usage info */\n+/* Functions for computation of registers live/usage info.  */\n \n /* It is assumed that prior to scheduling BASIC_BLOCK (b)->global_live_at_start\n    contains the registers that are alive at the entry to b.\n@@ -5262,7 +5271,7 @@ find_post_sched_live (bb)\n \n   b = BB_TO_BLOCK (bb);\n \n-  /* compute live regs at the end of bb as a function of its successors.  */\n+  /* Compute live regs at the end of bb as a function of its successors.  */\n   if (current_nr_blocks > 1)\n     {\n       int e;\n@@ -5293,7 +5302,7 @@ find_post_sched_live (bb)\n \t\t\t       sched_reg_basic_block[i] = REG_BLOCK_GLOBAL;\n \t\t\t     });\n \n-  /* if the block is empty, same regs are alive at its end and its start.\n+  /* If the block is empty, same regs are alive at its end and its start.\n      since this is not guaranteed after interblock scheduling, make sure they\n      are truly identical.  */\n   if (NEXT_INSN (prev_head) == tail\n@@ -5314,7 +5323,7 @@ find_post_sched_live (bb)\n     = (struct sometimes *) alloca (max_regno * sizeof (struct sometimes));\n   sometimes_max = 0;\n \n-  /* initiate \"sometimes\" data, starting with registers live at end */\n+  /* Initiate \"sometimes\" data, starting with registers live at end.  */\n   sometimes_max = 0;\n   COPY_REG_SET (old_live_regs, bb_live_regs);\n   EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, 0, j,\n@@ -5324,7 +5333,7 @@ find_post_sched_live (bb)\n \t\t\t\t\t\t       j, sometimes_max);\n \t\t\t     });\n \n-  /* scan insns back, computing regs live info */\n+  /* Scan insns back, computing regs live info.  */\n   for (insn = tail; insn != prev_head; insn = PREV_INSN (insn))\n     {\n       /* First we kill registers set by this insn, and then we\n@@ -5507,16 +5516,17 @@ update_reg_usage ()\n \t   Alternatively, we could try to correctly update basic block live\n \t   at start here in sched, but that seems complicated.\n \n-\t   Note: it is possible that a global register became local, as result\n-\t   of interblock motion, but will remain marked as a global register.  */\n+\t   Note: it is possible that a global register became local,\n+\t   as result of interblock motion, but will remain marked as a\n+\t   global register.  */\n \tif (sched_reg_n_calls_crossed[regno]\n \t    || REG_BASIC_BLOCK (regno) != REG_BLOCK_GLOBAL)\n \t  REG_N_CALLS_CROSSED (regno) = sched_reg_n_calls_crossed[regno];\n \n       }\n }\n \n-/* Scheduling clock, modified in schedule_block() and queue_to_ready () */\n+/* Scheduling clock, modified in schedule_block() and queue_to_ready ().  */\n static int clock_var;\n \n /* Move insns that became ready to fire from queue to ready list.  */\n@@ -5591,7 +5601,7 @@ queue_to_ready (ready, n_ready)\n   return n_ready;\n }\n \n-/* Print the ready list for debugging purposes. Callable from debugger.  */\n+/* Print the ready list for debugging purposes.  Callable from debugger.  */\n \n static void\n debug_ready_list (ready, n_ready)\n@@ -5648,7 +5658,7 @@ char *visual_tbl;\n int n_vis_no_unit;\n rtx vis_no_unit[10];\n \n-/* Finds units that are in use in this fuction. Required only\n+/* Finds units that are in use in this fuction.  Required only\n    for visualization.  */\n \n static void\n@@ -5671,7 +5681,7 @@ init_target_units ()\n     }\n }\n \n-/* Return the length of the visualization table */\n+/* Return the length of the visualization table.  */\n \n static int\n get_visual_tbl_length ()\n@@ -5680,12 +5690,12 @@ get_visual_tbl_length ()\n   int n, n1;\n   char *s;\n \n-  /* compute length of one field in line */\n+  /* Compute length of one field in line.  */\n   s = (char *) alloca (INSN_LEN + 6);\n   sprintf (s, \"  %33s\", \"uname\");\n   n1 = strlen (s);\n \n-  /* compute length of one line */\n+  /* Compute length of one line.  */\n   n = strlen (\";; \");\n   n += n1;\n   for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n@@ -5695,11 +5705,11 @@ get_visual_tbl_length ()\n   n += n1;\n   n += strlen (\"\\n\") + 2;\n \n-  /* compute length of visualization string */\n+  /* Compute length of visualization string.  */\n   return (MAX_VISUAL_LINES * n);\n }\n \n-/* Init block visualization debugging info */\n+/* Init block visualization debugging info.  */\n \n static void\n init_block_visualization ()\n@@ -5717,7 +5727,7 @@ safe_concat (buf, cur, str)\n      char *cur;\n      const char *str;\n {\n-  char *end = buf + BUF_LEN - 2;\t/* leave room for null */\n+  char *end = buf + BUF_LEN - 2;\t/* Leave room for null.  */\n   int c;\n \n   if (cur > end)\n@@ -5733,9 +5743,9 @@ safe_concat (buf, cur, str)\n   return cur;\n }\n \n-/* This recognizes rtx, I classified as expressions. These are always */\n-/* represent some action on values or results of other expression, */\n-/* that may be stored in objects representing values.  */\n+/* This recognizes rtx, I classified as expressions.  These are always\n+   represent some action on values or results of other expression, that\n+   may be stored in objects representing values.  */\n \n static void\n print_exp (buf, x, verbose)\n@@ -6051,12 +6061,12 @@ print_exp (buf, x, verbose)\n       }\n       break;\n     default:\n-      /* if (verbose) debug_rtx (x); */\n+      /* If (verbose) debug_rtx (x);  */\n       st[0] = GET_RTX_NAME (GET_CODE (x));\n       break;\n     }\n \n-  /* Print this as a function? */\n+  /* Print this as a function?  */\n   if (fun)\n     {\n       cur = safe_concat (buf, cur, fun);\n@@ -6082,8 +6092,8 @@ print_exp (buf, x, verbose)\n     cur = safe_concat (buf, cur, \")\");\n }\t\t/* print_exp */\n \n-/* Prints rtxes, i customly classified as values. They're constants, */\n-/* registers, labels, symbols and memory accesses.  */\n+/* Prints rtxes, I customly classified as values.  They're constants,\n+   registers, labels, symbols and memory accesses.  */\n \n static void\n print_value (buf, x, verbose)\n@@ -6173,7 +6183,7 @@ print_value (buf, x, verbose)\n     }\n }\t\t\t\t/* print_value */\n \n-/* The next step in insn detalization, its pattern recognition */\n+/* The next step in insn detalization, its pattern recognition.  */\n \n static void\n print_pattern (buf, x, verbose)\n@@ -6279,10 +6289,10 @@ print_pattern (buf, x, verbose)\n \n /* This is the main function in rtl visualization mechanism. It\n    accepts an rtx and tries to recognize it as an insn, then prints it\n-   properly in human readable form, resembling assembler mnemonics.  */\n-/* For every insn it prints its UID and BB the insn belongs */\n-/* too. (probably the last \"option\" should be extended somehow, since */\n-/* it depends now on sched.c inner variables ...) */\n+   properly in human readable form, resembling assembler mnemonics.\n+   For every insn it prints its UID and BB the insn belongs too.\n+   (Probably the last \"option\" should be extended somehow, since it\n+   depends now on sched.c inner variables ...)  */\n \n static void\n print_insn (buf, x, verbose)\n@@ -6351,7 +6361,7 @@ print_insn (buf, x, verbose)\n     }\n }\t\t\t\t/* print_insn */\n \n-/* Print visualization debugging info */\n+/* Print visualization debugging info.  */\n \n static void\n print_block_visualization (b, s)\n@@ -6360,10 +6370,10 @@ print_block_visualization (b, s)\n {\n   int unit, i;\n \n-  /* print header */\n+  /* Print header.  */\n   fprintf (dump, \"\\n;;   ==================== scheduling visualization for block %d %s \\n\", b, s);\n \n-  /* Print names of units */\n+  /* Print names of units.  */\n   fprintf (dump, \";;   %-8s\", \"clock\");\n   for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n     if (function_units[unit].bitmask & target_units)\n@@ -6378,11 +6388,11 @@ print_block_visualization (b, s)\n \tfprintf (dump, \"  %-33s\", \"==============================\");\n   fprintf (dump, \"  %-8s\\n\", \"=======\");\n \n-  /* Print insns in each cycle */\n+  /* Print insns in each cycle.  */\n   fprintf (dump, \"%s\\n\", visual_tbl);\n }\n \n-/* Print insns in the 'no_unit' column of visualization */\n+/* Print insns in the 'no_unit' column of visualization.  */\n \n static void\n visualize_no_unit (insn)\n@@ -6400,7 +6410,7 @@ visualize_scheduled_insns (b, clock)\n {\n   int i, unit;\n \n-  /* if no more room, split table into two */\n+  /* If no more room, split table into two.  */\n   if (n_visual_lines >= MAX_VISUAL_LINES)\n     {\n       print_block_visualization (b, \"(incomplete)\");\n@@ -6417,7 +6427,7 @@ visualize_scheduled_insns (b, clock)\n \t  int instance = unit + i * FUNCTION_UNITS_SIZE;\n \t  rtx insn = unit_last_insn[instance];\n \n-\t  /* print insns that still keep the unit busy */\n+\t  /* Print insns that still keep the unit busy.  */\n \t  if (insn &&\n \t      actual_hazard_this_instance (unit, instance, insn, clock, 0))\n \t    {\n@@ -6430,7 +6440,7 @@ visualize_scheduled_insns (b, clock)\n \t    sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", \"------------------------------\");\n \t}\n \n-  /* print insns that are not assigned to any unit */\n+  /* Print insns that are not assigned to any unit.  */\n   for (i = 0; i < n_vis_no_unit; i++)\n     sprintf (visual_tbl + strlen (visual_tbl), \"  %-8d\",\n \t     INSN_UID (vis_no_unit[i]));\n@@ -6439,15 +6449,15 @@ visualize_scheduled_insns (b, clock)\n   sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n }\n \n-/* Print stalled cycles */\n+/* Print stalled cycles.  */\n \n static void\n visualize_stall_cycles (b, stalls)\n      int b, stalls;\n {\n   int i;\n \n-  /* if no more room, split table into two */\n+  /* If no more room, split table into two.  */\n   if (n_visual_lines >= MAX_VISUAL_LINES)\n     {\n       print_block_visualization (b, \"(incomplete)\");\n@@ -6462,7 +6472,7 @@ visualize_stall_cycles (b, stalls)\n   sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n }\n \n-/* move_insn1: Remove INSN from insn chain, and link it after LAST insn */\n+/* move_insn1: Remove INSN from insn chain, and link it after LAST insn.  */\n \n static rtx\n move_insn1 (insn, last)\n@@ -6605,12 +6615,12 @@ schedule_block (bb, rgn_n_insns)\n   int n_ready = 0;\n   int can_issue_more;\n \n-  /* flow block of this bb */\n+  /* Flow block of this bb.  */\n   int b = BB_TO_BLOCK (bb);\n \n   /* target_n_insns == number of insns in b before scheduling starts.\n      sched_target_n_insns == how many of b's insns were scheduled.\n-     sched_n_insns == how many insns were scheduled in b */\n+     sched_n_insns == how many insns were scheduled in b.  */\n   int target_n_insns = 0;\n   int sched_target_n_insns = 0;\n   int sched_n_insns = 0;\n@@ -6620,7 +6630,7 @@ schedule_block (bb, rgn_n_insns)\n #define NEED_TAIL\t2\n   int new_needs;\n \n-  /* head/tail info for this block */\n+  /* Head/tail info for this block.  */\n   rtx prev_head;\n   rtx next_tail;\n   rtx head;\n@@ -6663,7 +6673,7 @@ schedule_block (bb, rgn_n_insns)\n       && (GET_RTX_CLASS (GET_CODE (head)) != 'i'))\n     return (sched_n_insns);\n \n-  /* debug info */\n+  /* Debug info.  */\n   if (sched_verbose)\n     {\n       fprintf (dump, \";;   ======================================================\\n\");\n@@ -6678,18 +6688,19 @@ schedule_block (bb, rgn_n_insns)\n       init_block_visualization ();\n     }\n \n-  /* remove remaining note insns from the block, save them in\n+  /* Remove remaining note insns from the block, save them in\n      note_list.  These notes are restored at the end of\n      schedule_block ().  */\n   note_list = 0;\n   rm_other_notes (head, tail);\n \n   target_bb = bb;\n \n-  /* prepare current target block info */\n+  /* Prepare current target block info.  */\n   if (current_nr_blocks > 1)\n     {\n-      candidate_table = (candidate *) alloca (current_nr_blocks * sizeof (candidate));\n+      candidate_table = (candidate *) alloca (current_nr_blocks \n+\t\t\t\t\t      * sizeof (candidate));\n \n       bblst_last = 0;\n       /* ??? It is not clear why bblst_size is computed this way.  The original\n@@ -6709,7 +6720,7 @@ schedule_block (bb, rgn_n_insns)\n \n   clear_units ();\n \n-  /* Allocate the ready list */\n+  /* Allocate the ready list.  */\n   ready = (rtx *) alloca ((rgn_n_insns + 1) * sizeof (rtx));\n \n   /* Print debugging information.  */\n@@ -6783,7 +6794,7 @@ schedule_block (bb, rgn_n_insns)\n   MD_SCHED_INIT (dump, sched_verbose);\n #endif\n \n-  /* no insns scheduled in this block yet */\n+  /* No insns scheduled in this block yet.  */\n   last_scheduled_insn = 0;\n \n   /* Q_SIZE is the total number of insns in the queue.  */\n@@ -6804,7 +6815,7 @@ schedule_block (bb, rgn_n_insns)\n   if (PREV_INSN (next_tail) == BLOCK_END (b))\n     new_needs |= NEED_TAIL;\n \n-  /* loop until all the insns in BB are scheduled.  */\n+  /* Loop until all the insns in BB are scheduled.  */\n   while (sched_target_n_insns < target_n_insns)\n     {\n       int b1;\n@@ -6936,7 +6947,7 @@ schedule_block (bb, rgn_n_insns)\n \tvisualize_scheduled_insns (b, clock_var);\n     }\n \n-  /* debug info */\n+  /* Debug info.  */\n   if (sched_verbose)\n     {\n       fprintf (dump, \";;\\tReady list (final):  \");\n@@ -6950,7 +6961,7 @@ schedule_block (bb, rgn_n_insns)\n     if (!flag_schedule_interblock && q_size != 0)\n       abort ();\n \n-  /* update head/tail boundaries.  */\n+  /* Update head/tail boundaries.  */\n   head = NEXT_INSN (prev_head);\n   tail = last;\n \n@@ -6973,14 +6984,14 @@ schedule_block (bb, rgn_n_insns)\n       head = note_head;\n     }\n \n-  /* update target block boundaries.  */\n+  /* Update target block boundaries.  */\n   if (new_needs & NEED_HEAD)\n     BLOCK_HEAD (b) = head;\n \n   if (new_needs & NEED_TAIL)\n     BLOCK_END (b) = tail;\n \n-  /* debugging */\n+  /* Debugging.  */\n   if (sched_verbose)\n     {\n       fprintf (dump, \";;   total time = %d\\n;;   new basic block head = %d\\n\",\n@@ -6993,7 +7004,7 @@ schedule_block (bb, rgn_n_insns)\n }\t\t\t\t/* schedule_block () */\n \f\n \n-/* print the bit-set of registers, S.  callable from debugger */\n+/* Print the bit-set of registers, S, callable from debugger.  */\n \n extern void\n debug_reg_vector (s)\n@@ -7038,7 +7049,7 @@ compute_block_forward_dependences (bb)\n \t  if (x != XEXP (link, 0))\n \t    continue;\n \n-\t  /* Ignore dependences upon deleted insn */\n+\t  /* Ignore dependences upon deleted insn.  */\n \t  if (GET_CODE (x) == NOTE || INSN_DELETED_P (x))\n \t    continue;\n \t  if (find_insn_list (insn, INSN_DEPEND (x)))\n@@ -7056,15 +7067,15 @@ compute_block_forward_dependences (bb)\n }\n \n /* Initialize variables for region data dependence analysis.\n-   n_bbs is the number of region blocks */\n+   n_bbs is the number of region blocks.  */\n \n __inline static void\n init_rgn_data_dependences (n_bbs)\n      int n_bbs;\n {\n   int bb;\n \n-  /* variables for which one copy exists for each block */\n+  /* Variables for which one copy exists for each block.  */\n   bzero ((char *) bb_pending_read_insns, n_bbs * sizeof (rtx));\n   bzero ((char *) bb_pending_read_mems, n_bbs * sizeof (rtx));\n   bzero ((char *) bb_pending_write_insns, n_bbs * sizeof (rtx));\n@@ -7084,7 +7095,8 @@ init_rgn_data_dependences (n_bbs)\n     }\n }\n \n-/* Add dependences so that branches are scheduled to run last in their block */\n+/* Add dependences so that branches are scheduled to run last in their\n+   block.  */\n \n static void\n add_branch_dependences (head, tail)\n@@ -7145,7 +7157,7 @@ add_branch_dependences (head, tail)\n       insn = PREV_INSN (insn);\n     }\n \n-  /* make sure these insns are scheduled last in their block */\n+  /* Make sure these insns are scheduled last in their block.  */\n   insn = last;\n   if (insn != 0)\n     while (insn != head)\n@@ -7164,14 +7176,14 @@ add_branch_dependences (head, tail)\n       }\n }\n \n-/* Compute bacward dependences inside BB.  In a multiple blocks region:\n+/* Compute backward dependences inside bb.  In a multiple blocks region:\n    (1) a bb is analyzed after its predecessors, and (2) the lists in\n    effect at the end of bb (after analyzing for bb) are inherited by\n    bb's successrs.\n \n    Specifically for reg-reg data dependences, the block insns are\n    scanned by sched_analyze () top-to-bottom.  Two lists are\n-   naintained by sched_analyze (): reg_last_defs[] for register DEFs,\n+   maintained by sched_analyze (): reg_last_sets[] for register DEFs,\n    and reg_last_uses[] for register USEs.\n \n    When analysis is completed for bb, we update for its successors:\n@@ -7231,7 +7243,7 @@ compute_block_backward_dependences (bb)\n       sched_before_next_call = bb_sched_before_next_call[bb];\n     }\n \n-  /* do the analysis for this block */\n+  /* Do the analysis for this block.  */\n   get_block_head_tail (bb, &head, &tail);\n   sched_analyze (head, tail);\n   add_branch_dependences (head, tail);\n@@ -7244,21 +7256,22 @@ compute_block_backward_dependences (bb)\n       rtx link_insn, link_mem;\n       rtx u;\n \n-      /* these lists should point to the right place, for correct freeing later.  */\n+      /* These lists should point to the right place, for correct\n+         freeing later.  */\n       bb_pending_read_insns[bb] = pending_read_insns;\n       bb_pending_read_mems[bb] = pending_read_mems;\n       bb_pending_write_insns[bb] = pending_write_insns;\n       bb_pending_write_mems[bb] = pending_write_mems;\n \n-      /* bb's structures are inherited by it's successors */\n+      /* bb's structures are inherited by it's successors.  */\n       first_edge = e = OUT_EDGES (b);\n       if (e > 0)\n \tdo\n \t  {\n \t    b_succ = TO_BLOCK (e);\n \t    bb_succ = BLOCK_TO_BB (b_succ);\n \n-\t    /* only bbs \"below\" bb, in the same region, are interesting */\n+\t    /* Only bbs \"below\" bb, in the same region, are interesting.  */\n \t    if (CONTAINING_RGN (b) != CONTAINING_RGN (b_succ)\n \t\t|| bb_succ <= bb)\n \t      {\n@@ -7269,21 +7282,23 @@ compute_block_backward_dependences (bb)\n \t    for (reg = 0; reg < max_reg; reg++)\n \t      {\n \n-\t\t/* reg-last-uses lists are inherited by bb_succ */\n+\t\t/* reg-last-uses lists are inherited by bb_succ.  */\n \t\tfor (u = reg_last_uses[reg]; u; u = XEXP (u, 1))\n \t\t  {\n-\t\t    if (find_insn_list (XEXP (u, 0), (bb_reg_last_uses[bb_succ])[reg]))\n+\t\t    if (find_insn_list (XEXP (u, 0),\n+\t\t\t\t\t(bb_reg_last_uses[bb_succ])[reg]))\n \t\t      continue;\n \n \t\t    (bb_reg_last_uses[bb_succ])[reg]\n \t\t      = alloc_INSN_LIST (XEXP (u, 0),\n \t\t\t\t\t (bb_reg_last_uses[bb_succ])[reg]);\n \t\t  }\n \n-\t\t/* reg-last-defs lists are inherited by bb_succ */\n+\t\t/* reg-last-defs lists are inherited by bb_succ.  */\n \t\tfor (u = reg_last_sets[reg]; u; u = XEXP (u, 1))\n \t\t  {\n-\t\t    if (find_insn_list (XEXP (u, 0), (bb_reg_last_sets[bb_succ])[reg]))\n+\t\t    if (find_insn_list (XEXP (u, 0),\n+\t\t\t\t\t(bb_reg_last_sets[bb_succ])[reg]))\n \t\t      continue;\n \n \t\t    (bb_reg_last_sets[bb_succ])[reg]\n@@ -7293,7 +7308,8 @@ compute_block_backward_dependences (bb)\n \n \t\tfor (u = reg_last_clobbers[reg]; u; u = XEXP (u, 1))\n \t\t  {\n-\t\t    if (find_insn_list (XEXP (u, 0), (bb_reg_last_clobbers[bb_succ])[reg]))\n+\t\t    if (find_insn_list (XEXP (u, 0),\n+\t\t\t\t\t(bb_reg_last_clobbers[bb_succ])[reg]))\n \t\t      continue;\n \n \t\t    (bb_reg_last_clobbers[bb_succ])[reg]\n@@ -7302,12 +7318,13 @@ compute_block_backward_dependences (bb)\n \t\t  }\n \t      }\n \n-\t    /* mem read/write lists are inherited by bb_succ */\n+\t    /* Mem read/write lists are inherited by bb_succ.  */\n \t    link_insn = pending_read_insns;\n \t    link_mem = pending_read_mems;\n \t    while (link_insn)\n \t      {\n-\t\tif (!(find_insn_mem_list (XEXP (link_insn, 0), XEXP (link_mem, 0),\n+\t\tif (!(find_insn_mem_list (XEXP (link_insn, 0),\n+\t\t\t\t\t  XEXP (link_mem, 0),\n \t\t\t\t\t  bb_pending_read_insns[bb_succ],\n \t\t\t\t\t  bb_pending_read_mems[bb_succ])))\n \t\t  add_insn_mem_dependence (&bb_pending_read_insns[bb_succ],\n@@ -7321,7 +7338,8 @@ compute_block_backward_dependences (bb)\n \t    link_mem = pending_write_mems;\n \t    while (link_insn)\n \t      {\n-\t\tif (!(find_insn_mem_list (XEXP (link_insn, 0), XEXP (link_mem, 0),\n+\t\tif (!(find_insn_mem_list (XEXP (link_insn, 0),\n+\t\t\t\t\t  XEXP (link_mem, 0),\n \t\t\t\t\t  bb_pending_write_insns[bb_succ],\n \t\t\t\t\t  bb_pending_write_mems[bb_succ])))\n \t\t  add_insn_mem_dependence (&bb_pending_write_insns[bb_succ],\n@@ -7332,29 +7350,31 @@ compute_block_backward_dependences (bb)\n \t\tlink_mem = XEXP (link_mem, 1);\n \t      }\n \n-\t    /* last_function_call is inherited by bb_succ */\n+\t    /* last_function_call is inherited by bb_succ.  */\n \t    for (u = last_function_call; u; u = XEXP (u, 1))\n \t      {\n-\t\tif (find_insn_list (XEXP (u, 0), bb_last_function_call[bb_succ]))\n+\t\tif (find_insn_list (XEXP (u, 0),\n+\t\t\t\t    bb_last_function_call[bb_succ]))\n \t\t  continue;\n \n \t\tbb_last_function_call[bb_succ]\n \t\t  = alloc_INSN_LIST (XEXP (u, 0),\n \t\t\t\t     bb_last_function_call[bb_succ]);\n \t      }\n \n-\t    /* last_pending_memory_flush is inherited by bb_succ */\n+\t    /* last_pending_memory_flush is inherited by bb_succ.  */\n \t    for (u = last_pending_memory_flush; u; u = XEXP (u, 1))\n \t      {\n-\t\tif (find_insn_list (XEXP (u, 0), bb_last_pending_memory_flush[bb_succ]))\n+\t\tif (find_insn_list (XEXP (u, 0), \n+\t\t\t\t    bb_last_pending_memory_flush[bb_succ]))\n \t\t  continue;\n \n \t\tbb_last_pending_memory_flush[bb_succ]\n \t\t  = alloc_INSN_LIST (XEXP (u, 0),\n \t\t\t\t     bb_last_pending_memory_flush[bb_succ]);\n \t      }\n \n-\t    /* sched_before_next_call is inherited by bb_succ */\n+\t    /* sched_before_next_call is inherited by bb_succ.  */\n \t    x = LOG_LINKS (sched_before_next_call);\n \t    for (; x; x = XEXP (x, 1))\n \t      add_dependence (bb_sched_before_next_call[bb_succ],\n@@ -7365,7 +7385,7 @@ compute_block_backward_dependences (bb)\n \twhile (e != first_edge);\n     }\n \n-  /* Free up the INSN_LISTs \n+  /* Free up the INSN_LISTs.\n \n      Note this loop is executed max_reg * nr_regions times.  It's first \n      implementation accounted for over 90% of the calls to free_INSN_LIST_list.\n@@ -7391,7 +7411,7 @@ compute_block_backward_dependences (bb)\n     }\n }\n \n-/* Print dependences for debugging, callable from debugger */\n+/* Print dependences for debugging, callable from debugger.  */\n \n void\n debug_dependencies ()\n@@ -7465,7 +7485,7 @@ debug_dependencies ()\n   fprintf (dump, \"\\n\");\n }\n \n-/* Set_priorities: compute priority of each insn in the block */\n+/* Set_priorities: compute priority of each insn in the block.  */\n \n static int\n set_priorities (bb)\n@@ -7504,7 +7524,7 @@ set_priorities (bb)\n    taking the space for all those rtx-vectors from SPACE.\n    SPACE is of type (rtx *), but it is really as long as NELTS rtx-vectors.\n    BYTES_PER_ELT is the number of bytes in one rtx-vector.\n-   (this is the same as init_regset_vector () in flow.c) */\n+   (this is the same as init_regset_vector () in flow.c)  */\n \n static void\n init_rtx_vector (vector, space, nelts, bytes_per_elt)\n@@ -7535,15 +7555,15 @@ schedule_region (rgn)\n   int rgn_n_insns = 0;\n   int sched_rgn_n_insns = 0;\n \n-  /* set variables for the current region */\n+  /* Set variables for the current region.  */\n   current_nr_blocks = RGN_NR_BLOCKS (rgn);\n   current_blocks = RGN_BLOCKS (rgn);\n \n   reg_pending_sets = ALLOCA_REG_SET ();\n   reg_pending_clobbers = ALLOCA_REG_SET ();\n   reg_pending_sets_all = 0;\n \n-  /* initializations for region data dependence analyisis */\n+  /* Initializations for region data dependence analyisis.  */\n   if (current_nr_blocks > 1)\n     {\n       rtx *space;\n@@ -7584,11 +7604,11 @@ schedule_region (rgn)\n       init_rgn_data_dependences (current_nr_blocks);\n     }\n \n-  /* compute LOG_LINKS */\n+  /* Compute LOG_LINKS.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     compute_block_backward_dependences (bb);\n \n-  /* compute INSN_DEPEND */\n+  /* Compute INSN_DEPEND.  */\n   for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n     compute_block_forward_dependences (bb);\n \n@@ -7608,7 +7628,7 @@ schedule_region (rgn)\n       rgn_n_insns += set_priorities (bb);\n     }\n \n-  /* compute interblock info: probabilities, split-edges, dominators, etc.  */\n+  /* Compute interblock info: probabilities, split-edges, dominators, etc.  */\n   if (current_nr_blocks > 1)\n     {\n       int i;\n@@ -7623,7 +7643,7 @@ schedule_region (rgn)\n \t  bzero ((char *) dom[i], bbset_size * sizeof (HOST_WIDE_INT));\n \t}\n \n-      /* edge to bit */\n+      /* Edge to bit.  */\n       rgn_nr_edges = 0;\n       edge_to_bit = (int *) alloca (nr_edges * sizeof (int));\n       for (i = 1; i < nr_edges; i++)\n@@ -7636,10 +7656,11 @@ schedule_region (rgn)\n \tif (CONTAINING_RGN (FROM_BLOCK (i)) == (rgn))\n \t  rgn_edges[rgn_nr_edges++] = i;\n \n-      /* split edges */\n+      /* Split edges.  */\n       edgeset_size = rgn_nr_edges / HOST_BITS_PER_WIDE_INT + 1;\n       pot_split = (edgeset *) alloca (current_nr_blocks * sizeof (edgeset));\n-      ancestor_edges = (edgeset *) alloca (current_nr_blocks * sizeof (edgeset));\n+      ancestor_edges = (edgeset *) alloca (current_nr_blocks \n+\t\t\t\t\t   * sizeof (edgeset));\n       for (i = 0; i < current_nr_blocks; i++)\n \t{\n \t  pot_split[i] =\n@@ -7652,12 +7673,12 @@ schedule_region (rgn)\n \t\t edgeset_size * sizeof (HOST_WIDE_INT));\n \t}\n \n-      /* compute probabilities, dominators, split_edges */\n+      /* Compute probabilities, dominators, split_edges.  */\n       for (bb = 0; bb < current_nr_blocks; bb++)\n \tcompute_dom_prob_ps (bb);\n     }\n \n-  /* now we can schedule all blocks */\n+  /* Now we can schedule all blocks.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n       sched_rgn_n_insns += schedule_block (bb, rgn_n_insns);\n@@ -7667,33 +7688,34 @@ schedule_region (rgn)\n #endif\n     }\n \n-  /* sanity check: verify that all region insns were scheduled */\n+  /* Sanity check: verify that all region insns were scheduled.  */\n   if (sched_rgn_n_insns != rgn_n_insns)\n     abort ();\n \n-  /* update register life and usage information */\n+  /* Update register life and usage information.  */\n   if (reload_completed == 0)\n     {\n       for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n \tfind_post_sched_live (bb);\n \n       if (current_nr_blocks <= 1)\n-\t/* Sanity check.  There should be no REG_DEAD notes leftover at the end.\n-\t   In practice, this can occur as the result of bugs in flow, combine.c,\n-\t   and/or sched.c.  The values of the REG_DEAD notes remaining are\n-\t   meaningless, because dead_notes is just used as a free list.  */\n+\t/* Sanity check.  There should be no REG_DEAD notes leftover\n+\t   at the end.  In practice, this can occur as the result of\n+\t   bugs in flow, combine.c, and/or sched.c.  The values of the\n+\t   REG_DEAD notes remaining are meaningless, because\n+\t   dead_notes is just used as a free list.  */\n \tif (dead_notes != 0)\n \t  abort ();\n     }\n \n-  /* restore line notes.  */\n+  /* Restore line notes.  */\n   if (write_symbols != NO_DEBUG)\n     {\n       for (bb = 0; bb < current_nr_blocks; bb++)\n \trestore_line_notes (bb);\n     }\n \n-  /* Done with this region */\n+  /* Done with this region.  */\n   free_pending_lists ();\n \n   FREE_REG_SET (reg_pending_sets);\n@@ -7715,7 +7737,7 @@ schedule_insns (dump_file)\n \n   int luid;\n \n-  /* disable speculative loads in their presence if cc0 defined */\n+  /* Disable speculative loads in their presence if cc0 defined.  */\n #ifdef HAVE_cc0\n   flag_schedule_speculative_load = 0;\n #endif\n@@ -7725,7 +7747,7 @@ schedule_insns (dump_file)\n   if (n_basic_blocks == 0)\n     return;\n \n-  /* set dump and sched_verbose for the desired debugging output.  If no\n+  /* Set dump and sched_verbose for the desired debugging output.  If no\n      dump-file was specified, but -fsched-verbose-N (any N), print to stderr.\n      For -fsched-verbose-N, N>=10, print everything to stderr.  */\n   sched_verbose = sched_verbose_param;\n@@ -7736,10 +7758,10 @@ schedule_insns (dump_file)\n   nr_inter = 0;\n   nr_spec = 0;\n \n-  /* initialize issue_rate */\n+  /* Initialize issue_rate.  */\n   issue_rate = ISSUE_RATE;\n \n-  /* do the splitting first for all blocks */\n+  /* Do the splitting first for all blocks.  */\n   for (b = 0; b < n_basic_blocks; b++)\n     split_block_insns (b, 1);\n \n@@ -7768,7 +7790,7 @@ schedule_insns (dump_file)\n \t  break;\n       }\n \n-  /* after reload, remove inter-blocks dependences computed before reload.  */\n+  /* After reload, remove inter-blocks dependences computed before reload.  */\n   if (reload_completed)\n     {\n       int b;\n@@ -7808,7 +7830,7 @@ schedule_insns (dump_file)\n   block_to_bb = (int *) alloca ((n_basic_blocks) * sizeof (int));\n   containing_rgn = (int *) alloca ((n_basic_blocks) * sizeof (int));\n \n-  /* compute regions for scheduling */\n+  /* Compute regions for scheduling.  */\n   if (reload_completed\n       || n_basic_blocks == 1\n       || !flag_schedule_interblock)\n@@ -7817,7 +7839,7 @@ schedule_insns (dump_file)\n     }\n   else\n     {\n-      /* verify that a 'good' control flow graph can be built */\n+      /* Verify that a 'good' control flow graph can be built.  */\n       if (is_cfg_nonregular ())\n \t{\n \t  find_single_block_region ();\n@@ -7851,8 +7873,9 @@ schedule_insns (dump_file)\n \n \t  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n \n-\t  /* Compute the dominators and post dominators.  We don't currently use\n-\t     post dominators, but we should for speculative motion analysis.  */\n+\t  /* Compute the dominators and post dominators.  We don't\n+\t     currently use post dominators, but we should for\n+\t     speculative motion analysis.  */\n \t  compute_dominators (dom, pdom, s_preds, s_succs);\n \n \t  /* build_control_flow will return nonzero if it detects unreachable\n@@ -7867,7 +7890,7 @@ schedule_insns (dump_file)\n \t    debug_regions ();\n \n \t  /* For now.  This will move as more and more of haifa is converted\n-\t     to using the cfg code in flow.c  */\n+\t     to using the cfg code in flow.c.  */\n \t  free_bb_mem ();\n \t  free (dom);\n \t  free (pdom);\n@@ -7888,7 +7911,7 @@ schedule_insns (dump_file)\n   insn_blockage = (unsigned int *) xmalloc (max_uid * sizeof (unsigned int));\n   insn_ref_count = (int *) xmalloc (max_uid * sizeof (int));\n \n-  /* Allocate for forward dependencies */\n+  /* Allocate for forward dependencies.  */\n   insn_dep_count = (int *) xmalloc (max_uid * sizeof (int));\n   insn_depend = (rtx *) xmalloc (max_uid * sizeof (rtx));\n \n@@ -7946,11 +7969,11 @@ schedule_insns (dump_file)\n   bzero ((char *) insn_blockage, max_uid * sizeof (unsigned int));\n   bzero ((char *) insn_ref_count, max_uid * sizeof (int));\n \n-  /* Initialize for forward dependencies */\n+  /* Initialize for forward dependencies.  */\n   bzero ((char *) insn_depend, max_uid * sizeof (rtx));\n   bzero ((char *) insn_dep_count, max_uid * sizeof (int));\n \n-  /* Find units used in this fuction, for visualization */\n+  /* Find units used in this fuction, for visualization.  */\n   if (sched_verbose)\n     init_target_units ();\n \n@@ -7967,7 +7990,7 @@ schedule_insns (dump_file)\n \t       && GET_CODE (NEXT_INSN (insn)) == BARRIER)))\n     emit_note_after (NOTE_INSN_DELETED, BLOCK_END (n_basic_blocks - 1));\n \n-  /* Schedule every region in the subroutine */\n+  /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n     {\n       schedule_region (rgn);\n@@ -7982,7 +8005,7 @@ schedule_insns (dump_file)\n   if (reload_completed)\n     reposition_prologue_and_epilogue_notes (get_insns ());\n \n-  /* delete redundant line notes.  */\n+  /* Delete redundant line notes.  */\n   if (write_symbols != NO_DEBUG)\n     rm_redundant_line_notes ();\n "}]}