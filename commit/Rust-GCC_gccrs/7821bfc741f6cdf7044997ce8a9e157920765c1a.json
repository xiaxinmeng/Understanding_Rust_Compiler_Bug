{"sha": "7821bfc741f6cdf7044997ce8a9e157920765c1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgyMWJmYzc0MWY2Y2RmNzA0NDk5N2NlOGE5ZTE1NzkyMDc2NWMxYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-01-25T21:49:52Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-01-25T21:49:52Z"}, "message": "gcse.c (bypass_last_basic_block): New global variable.\n\n\n\t* gcse.c (bypass_last_basic_block): New global variable.\n\t(bypass_block):  Use redirect_edge_and_branch_force to redirect\n\tfall-through edges.  Use bypass_last_basic_block to determine\n\twhich blocks have valid PRE information.\n\t(bypass_conditional_jumps): Initialize bypass_last_basic_block.\n\nFrom-SVN: r61800", "tree": {"sha": "16a8b8743826b7fb1be29a0f0f140d95a6a88de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16a8b8743826b7fb1be29a0f0f140d95a6a88de1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7821bfc741f6cdf7044997ce8a9e157920765c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7821bfc741f6cdf7044997ce8a9e157920765c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7821bfc741f6cdf7044997ce8a9e157920765c1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7821bfc741f6cdf7044997ce8a9e157920765c1a/comments", "author": null, "committer": null, "parents": [{"sha": "5f0bea72c558bdd22238fffb4ba31d71221c473a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0bea72c558bdd22238fffb4ba31d71221c473a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0bea72c558bdd22238fffb4ba31d71221c473a"}], "stats": {"total": 35, "additions": 30, "deletions": 5}, "files": [{"sha": "b34f95717227590e3e266dc0066573dc0da862a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7821bfc741f6cdf7044997ce8a9e157920765c1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7821bfc741f6cdf7044997ce8a9e157920765c1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7821bfc741f6cdf7044997ce8a9e157920765c1a", "patch": "@@ -1,3 +1,11 @@\n+2003-01-25  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcse.c (bypass_last_basic_block): New global variable.\n+\t(bypass_block):  Use redirect_edge_and_branch_force to redirect\n+\tfall-through edges.  Use bypass_last_basic_block to determine\n+\twhich blocks have valid PRE information.\n+\t(bypass_conditional_jumps): Initialize bypass_last_basic_block.\n+\n Sat Jan 25 22:31:59 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcse.c (local_cprop_pass): Update reg_sets table when needed."}, {"sha": "a68374de953bdbbe0a8e48a229ba00381e27407a", "filename": "gcc/gcse.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7821bfc741f6cdf7044997ce8a9e157920765c1a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7821bfc741f6cdf7044997ce8a9e157920765c1a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7821bfc741f6cdf7044997ce8a9e157920765c1a", "patch": "@@ -4527,6 +4527,13 @@ one_cprop_pass (pass, cprop_jumps, bypass_jumps)\n \f\n /* Bypass conditional jumps.  */\n \n+/* The value of last_basic_block at the beginning of the jump_bypass\n+   pass.  The use of redirect_edge_and_branch_force may introduce new\n+   basic blocks, but the data flow analysis is only valid for basic\n+   block indices less than bypass_last_basic_block.  */\n+\n+static int bypass_last_basic_block;\n+\n /* Find a set of REGNO to a constant that is available at the end of basic\n    block BB.  Returns NULL if no such set is found.  Based heavily upon\n    find_avail_set.  */\n@@ -4597,6 +4604,13 @@ bypass_block (bb, setcc, jump)\n   for (e = bb->pred; e; e = enext)\n     {\n       enext = e->pred_next;\n+      if (e->flags & EDGE_COMPLEX)\n+\tcontinue;\n+\n+      /* We can't redirect edges from new basic blocks.  */\n+      if (e->src->index >= bypass_last_basic_block)\n+\tcontinue;\n+\n       for (i = 0; i < reg_use_count; i++)\n \t{\n \t  struct reg_use *reg_used = &reg_use_table[i];\n@@ -4630,12 +4644,13 @@ bypass_block (bb, setcc, jump)\n \t  else\n \t    dest = NULL;\n \n-\t  /* Once basic block indices are stable, we should be able\n-\t     to use redirect_edge_and_branch_force instead.  */\n \t  old_dest = e->dest;\n-\t  if (dest != NULL && dest != old_dest\n-\t      && redirect_edge_and_branch (e, dest))\n-\t    {\n+\t  if (dest != NULL\n+\t      && dest != old_dest\n+\t      && dest != EXIT_BLOCK_PTR)\n+            {\n+\t      redirect_edge_and_branch_force (e, dest);\n+\n \t      /* Copy the register setter to the redirected edge.\n \t\t Don't copy CC0 setters, as CC0 is dead after jump.  */\n \t      if (setcc)\n@@ -4679,6 +4694,8 @@ bypass_conditional_jumps ()\n   if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n     return 0;\n \n+  bypass_last_basic_block = last_basic_block;\n+\n   changed = 0;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb,\n \t\t  EXIT_BLOCK_PTR, next_bb)"}]}