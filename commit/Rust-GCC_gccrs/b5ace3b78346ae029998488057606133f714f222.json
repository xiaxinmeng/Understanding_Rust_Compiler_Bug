{"sha": "b5ace3b78346ae029998488057606133f714f222", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVhY2UzYjc4MzQ2YWUwMjk5OTg0ODgwNTc2MDYxMzNmNzE0ZjIyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:21:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:21:54Z"}, "message": "Resync.\n\nFrom-SVN: r118333", "tree": {"sha": "9bb68fd4d95610a9623e1a0b243495126df99abb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb68fd4d95610a9623e1a0b243495126df99abb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ace3b78346ae029998488057606133f714f222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ace3b78346ae029998488057606133f714f222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ace3b78346ae029998488057606133f714f222", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ace3b78346ae029998488057606133f714f222/comments", "author": null, "committer": null, "parents": [{"sha": "ea7339d1fb89c9744b481ae314b451e90c7dcc63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea7339d1fb89c9744b481ae314b451e90c7dcc63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea7339d1fb89c9744b481ae314b451e90c7dcc63"}], "stats": {"total": 1896, "additions": 1829, "deletions": 67}, "files": [{"sha": "1e998007bb7a7eaa5184fae88b8eb492afa9b3e8", "filename": "gcc/ada/a-crdlli.adb", "status": "added", "additions": 1505, "deletions": 0, "changes": 1505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fa-crdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fa-crdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crdlli.adb?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -0,0 +1,1505 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                       A D A . C O N T A I N E R S .                      --\n+--        R E S R I C T E D  _ D O U B L Y _ L I N K E D _ L I S T S        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Restricted_Doubly_Linked_Lists is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Allocate\n+     (Container : in out List'Class;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type);\n+\n+   procedure Free\n+     (Container : in out List'Class;\n+      X         : Count_Type);\n+\n+   procedure Insert_Internal\n+     (Container : in out List'Class;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type);\n+\n+   function Vet (Position : Cursor) return Boolean;\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : List) return Boolean is\n+      LN : Node_Array renames Left.Nodes;\n+      RN : Node_Array renames Right.Nodes;\n+\n+      LI : Count_Type := Left.First;\n+      RI : Count_Type := Right.First;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      if Left.Length /= Right.Length then\n+         return False;\n+      end if;\n+\n+      for J in 1 .. Left.Length loop\n+         if LN (LI).Element /= RN (RI).Element then\n+            return False;\n+         end if;\n+\n+         LI := LN (LI).Next;\n+         RI := RN (RI).Next;\n+      end loop;\n+\n+      return True;\n+   end \"=\";\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   procedure Allocate\n+     (Container : in out List'Class;\n+      New_Item  : Element_Type;\n+      New_Node  : out Count_Type)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Free >= 0 then\n+         New_Node := Container.Free;\n+         N (New_Node).Element := New_Item;\n+         Container.Free := N (New_Node).Next;\n+\n+      else\n+         New_Node := abs Container.Free;\n+         N (New_Node).Element := New_Item;\n+         Container.Free := Container.Free - 1;\n+      end if;\n+   end Allocate;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, No_Element, New_Item, Count);\n+   end Append;\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out List; Source : List) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Constraint_Error;  -- ???\n+      end if;\n+\n+      Clear (Target);\n+\n+      declare\n+         N : Node_Array renames Source.Nodes;\n+         J : Count_Type := Source.First;\n+\n+      begin\n+         while J /= 0 loop\n+            Append (Target, N (J).Element);\n+            J := N (J).Next;\n+         end loop;\n+      end;\n+   end Assign;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out List) is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n+--       pragma Assert (Container.Busy = 0);\n+--       pragma Assert (Container.Lock = 0);\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+--    if Container.Busy > 0 then\n+--      raise Program_Error;\n+--    end if;\n+\n+      while Container.Length > 1 loop\n+         X := Container.First;\n+\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+\n+      X := Container.First;\n+\n+      Container.First := 0;\n+      Container.Last := 0;\n+      Container.Length := 0;\n+\n+      Free (Container, X);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean\n+   is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n+      if Position.Node = Container.First then\n+         Delete_First (Container, Count);\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         Position := No_Element;\n+         return;\n+      end if;\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      pragma Assert (Container.First >= 1);\n+      pragma Assert (Container.Last >= 1);\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+      for Index in 1 .. Count loop\n+         pragma Assert (Container.Length >= 2);\n+\n+         X := Position.Node;\n+         Container.Length := Container.Length - 1;\n+\n+         if X = Container.Last then\n+            Position := No_Element;\n+\n+            Container.Last := N (X).Prev;\n+            N (Container.Last).Next := 0;\n+\n+            Free (Container, X);\n+            return;\n+         end if;\n+\n+         Position.Node := N (X).Next;\n+\n+         N (N (X).Next).Prev := N (X).Prev;\n+         N (N (X).Prev).Next := N (X).Next;\n+\n+         Free (Container, X);\n+      end loop;\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   ------------------\n+   -- Delete_First --\n+   ------------------\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      for I in 1 .. Count loop\n+         X := Container.First;\n+         pragma Assert (N (N (X).Next).Prev = Container.First);\n+\n+         Container.First := N (X).Next;\n+         N (Container.First).Prev := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+   end Delete_First;\n+\n+   -----------------\n+   -- Delete_Last --\n+   -----------------\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      if Count >= Container.Length then\n+         Clear (Container);\n+         return;\n+      end if;\n+\n+      if Count = 0 then\n+         return;\n+      end if;\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      for I in 1 .. Count loop\n+         X := Container.Last;\n+         pragma Assert (N (N (X).Prev).Next = Container.Last);\n+\n+         Container.Last := N (X).Prev;\n+         N (Container.Last).Next := 0;\n+\n+         Container.Length := Container.Length - 1;\n+\n+         Free (Container, X);\n+      end loop;\n+   end Delete_Last;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n+      declare\n+         N : Node_Array renames Position.Container.Nodes;\n+      begin\n+         return N (Position.Node).Element;\n+      end;\n+   end Element;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Nodes : Node_Array renames Container.Nodes;\n+      Node  : Count_Type := Position.Node;\n+\n+   begin\n+      if Node = 0 then\n+         Node := Container.First;\n+\n+      else\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n+      end if;\n+\n+      while Node /= 0 loop\n+         if Nodes (Node).Element = Item then\n+            return Cursor'(Container'Unrestricted_Access, Node);\n+         end if;\n+\n+         Node := Nodes (Node).Next;\n+      end loop;\n+\n+      return No_Element;\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : List) return Cursor is\n+   begin\n+      if Container.First = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.First);\n+   end First;\n+\n+   -------------------\n+   -- First_Element --\n+   -------------------\n+\n+   function First_Element (Container : List) return Element_Type is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.First = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return N (Container.First).Element;\n+   end First_Element;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (Container : in out List'Class;\n+      X         : Count_Type)\n+   is\n+      pragma Assert (X > 0);\n+      pragma Assert (X <= Container.Capacity);\n+\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n+\n+      if Container.Free >= 0 then\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+\n+      elsif X + 1 = abs Container.Free then\n+         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n+         Container.Free := Container.Free + 1;\n+\n+      else\n+         Container.Free := abs Container.Free;\n+\n+         if Container.Free > Container.Capacity then\n+            Container.Free := 0;\n+\n+         else\n+            for I in Container.Free .. Container.Capacity - 1 loop\n+               N (I).Next := I + 1;\n+            end loop;\n+\n+            N (Container.Capacity).Next := 0;\n+         end if;\n+\n+         N (X).Next := Container.Free;\n+         Container.Free := X;\n+      end if;\n+   end Free;\n+\n+   ---------------------\n+   -- Generic_Sorting --\n+   ---------------------\n+\n+   package body Generic_Sorting is\n+\n+      ---------------\n+      -- Is_Sorted --\n+      ---------------\n+\n+      function Is_Sorted (Container : List) return Boolean is\n+         Nodes : Node_Array renames Container.Nodes;\n+         Node  : Count_Type := Container.First;\n+\n+      begin\n+         for I in 2 .. Container.Length loop\n+            if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n+               return False;\n+            end if;\n+\n+            Node := Nodes (Node).Next;\n+         end loop;\n+\n+         return True;\n+      end Is_Sorted;\n+\n+      ----------\n+      -- Sort --\n+      ----------\n+\n+      procedure Sort (Container : in out List) is\n+         N : Node_Array renames Container.Nodes;\n+\n+         procedure Partition (Pivot, Back : Count_Type);\n+         procedure Sort (Front, Back : Count_Type);\n+\n+         ---------------\n+         -- Partition --\n+         ---------------\n+\n+         procedure Partition (Pivot, Back : Count_Type) is\n+            Node : Count_Type := N (Pivot).Next;\n+\n+         begin\n+            while Node /= Back loop\n+               if N (Node).Element < N (Pivot).Element then\n+                  declare\n+                     Prev : constant Count_Type := N (Node).Prev;\n+                     Next : constant Count_Type := N (Node).Next;\n+\n+                  begin\n+                     N (Prev).Next := Next;\n+\n+                     if Next = 0 then\n+                        Container.Last := Prev;\n+                     else\n+                        N (Next).Prev := Prev;\n+                     end if;\n+\n+                     N (Node).Next := Pivot;\n+                     N (Node).Prev := N (Pivot).Prev;\n+\n+                     N (Pivot).Prev := Node;\n+\n+                     if N (Node).Prev = 0 then\n+                        Container.First := Node;\n+                     else\n+                        N (N (Node).Prev).Next := Node;\n+                     end if;\n+\n+                     Node := Next;\n+                  end;\n+\n+               else\n+                  Node := N (Node).Next;\n+               end if;\n+            end loop;\n+         end Partition;\n+\n+         ----------\n+         -- Sort --\n+         ----------\n+\n+         procedure Sort (Front, Back : Count_Type) is\n+            Pivot : Count_Type;\n+\n+         begin\n+            if Front = 0 then\n+               Pivot := Container.First;\n+            else\n+               Pivot := N (Front).Next;\n+            end if;\n+\n+            if Pivot /= Back then\n+               Partition (Pivot, Back);\n+               Sort (Front, Pivot);\n+               Sort (Pivot, Back);\n+            end if;\n+         end Sort;\n+\n+      --  Start of processing for Sort\n+\n+      begin\n+         if Container.Length <= 1 then\n+            return;\n+         end if;\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+--       if Container.Busy > 0 then\n+--          raise Program_Error;\n+--       end if;\n+\n+         Sort (Front => 0, Back => 0);\n+\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+      end Sort;\n+\n+   end Generic_Sorting;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= 0;\n+   end Has_Element;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      J : Count_Type;\n+\n+   begin\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+      end if;\n+\n+      if Count = 0 then\n+         Position := Before;\n+         return;\n+      end if;\n+\n+      if Container.Length > Container.Capacity - Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      Allocate (Container, New_Item, New_Node => J);\n+      Insert_Internal (Container, Before.Node, New_Node => J);\n+      Position := Cursor'(Container'Unrestricted_Access, Node => J);\n+\n+      for Index in 2 .. Count loop\n+         Allocate (Container, New_Item, New_Node => J);\n+         Insert_Internal (Container, Before.Node, New_Node => J);\n+      end loop;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+      Position : Cursor;\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Do we need to reinit node ???\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n+   ---------------------\n+   -- Insert_Internal --\n+   ---------------------\n+\n+   procedure Insert_Internal\n+     (Container : in out List'Class;\n+      Before    : Count_Type;\n+      New_Node  : Count_Type)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Length = 0 then\n+         pragma Assert (Before = 0);\n+         pragma Assert (Container.First = 0);\n+         pragma Assert (Container.Last = 0);\n+\n+         Container.First := New_Node;\n+         Container.Last := New_Node;\n+\n+         N (Container.First).Prev := 0;\n+         N (Container.Last).Next := 0;\n+\n+      elsif Before = 0 then\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         N (Container.Last).Next := New_Node;\n+         N (New_Node).Prev := Container.Last;\n+\n+         Container.Last := New_Node;\n+         N (Container.Last).Next := 0;\n+\n+      elsif Before = Container.First then\n+         pragma Assert (N (Container.First).Prev = 0);\n+\n+         N (Container.First).Prev := New_Node;\n+         N (New_Node).Next := Container.First;\n+\n+         Container.First := New_Node;\n+         N (Container.First).Prev := 0;\n+\n+      else\n+         pragma Assert (N (Container.First).Prev = 0);\n+         pragma Assert (N (Container.Last).Next = 0);\n+\n+         N (New_Node).Next := Before;\n+         N (New_Node).Prev := N (Before).Prev;\n+\n+         N (N (Before).Prev).Next := New_Node;\n+         N (Before).Prev := New_Node;\n+      end if;\n+\n+      Container.Length := Container.Length + 1;\n+   end Insert_Internal;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : List) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      C : List renames Container'Unrestricted_Access.all;\n+      N : Node_Array renames C.Nodes;\n+--    B : Natural renames C.Busy;\n+\n+      Node  : Count_Type := Container.First;\n+\n+      Index     : Count_Type := 0;\n+      Index_Max : constant Count_Type := Container.Length;\n+\n+   begin\n+      if Index_Max = 0 then\n+         pragma Assert (Node = 0);\n+         return;\n+      end if;\n+\n+      loop\n+         pragma Assert (Node /= 0);\n+\n+         Process (Cursor'(C'Unchecked_Access, Node));\n+         pragma Assert (Container.Length = Index_Max);\n+         pragma Assert (N (Node).Prev /= -1);\n+\n+         Node := N (Node).Next;\n+         Index := Index + 1;\n+\n+         if Index = Index_Max then\n+            pragma Assert (Node = 0);\n+            return;\n+         end if;\n+      end loop;\n+   end Iterate;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Container : List) return Cursor is\n+   begin\n+      if Container.Last = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Container.Last);\n+   end Last;\n+\n+   ------------------\n+   -- Last_Element --\n+   ------------------\n+\n+   function Last_Element (Container : List) return Element_Type is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Container.Last = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return N (Container.Last).Element;\n+   end Last_Element;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : List) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n+      declare\n+         Nodes : Node_Array renames Position.Container.Nodes;\n+         Node  : constant Count_Type := Nodes (Position.Node).Next;\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   -------------\n+   -- Prepend --\n+   -------------\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1)\n+   is\n+   begin\n+      Insert (Container, First (Container), New_Item, Count);\n+   end Prepend;\n+\n+   --------------\n+   -- Previous --\n+   --------------\n+\n+   procedure Previous (Position : in out Cursor) is\n+   begin\n+      Position := Previous (Position);\n+   end Previous;\n+\n+   function Previous (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Previous\");\n+\n+      declare\n+         Nodes : Node_Array renames Position.Container.Nodes;\n+         Node  : constant Count_Type := Nodes (Position.Node).Prev;\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Previous;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n+      declare\n+         C : List renames Position.Container.all'Unrestricted_Access.all;\n+         N : Node_Type renames C.Nodes (Position.Node);\n+\n+      begin\n+         Process (N.Element);\n+         pragma Assert (N.Prev >= 0);\n+      end;\n+   end Query_Element;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+--    if Container.Lock > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      declare\n+         N : Node_Array renames Container.Nodes;\n+      begin\n+         N (Position.Node).Element := New_Item;\n+      end;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out List) is\n+      N : Node_Array renames Container.Nodes;\n+      I : Count_Type := Container.First;\n+      J : Count_Type := Container.Last;\n+\n+      procedure Swap (L, R : Count_Type);\n+\n+      ----------\n+      -- Swap --\n+      ----------\n+\n+      procedure Swap (L, R : Count_Type) is\n+         LN : constant Count_Type := N (L).Next;\n+         LP : constant Count_Type := N (L).Prev;\n+\n+         RN : constant Count_Type := N (R).Next;\n+         RP : constant Count_Type := N (R).Prev;\n+\n+      begin\n+         if LP /= 0 then\n+            N (LP).Next := R;\n+         end if;\n+\n+         if RN /= 0 then\n+            N (RN).Prev := L;\n+         end if;\n+\n+         N (L).Next := RN;\n+         N (R).Prev := LP;\n+\n+         if LN = R then\n+            pragma Assert (RP = L);\n+\n+            N (L).Prev := R;\n+            N (R).Next := L;\n+\n+         else\n+            N (L).Prev := RP;\n+            N (RP).Next := L;\n+\n+            N (R).Next := LN;\n+            N (LN).Prev := R;\n+         end if;\n+      end Swap;\n+\n+   --  Start of processing for Reverse_Elements\n+\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      Container.First := J;\n+      Container.Last := I;\n+      loop\n+         Swap (L => I, R => J);\n+\n+         J := N (J).Next;\n+         exit when I = J;\n+\n+         I := N (I).Prev;\n+         exit when I = J;\n+\n+         Swap (L => J, R => I);\n+\n+         I := N (I).Next;\n+         exit when I = J;\n+\n+         J := N (J).Prev;\n+         exit when I = J;\n+      end loop;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      N    : Node_Array renames Container.Nodes;\n+      Node : Count_Type := Position.Node;\n+\n+   begin\n+      if Node = 0 then\n+         Node := Container.Last;\n+\n+      else\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+      end if;\n+\n+      while Node /= 0 loop\n+         if N (Node).Element = Item then\n+            return Cursor'(Container'Unrestricted_Access, Node);\n+         end if;\n+\n+         Node := N (Node).Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      C : List renames Container'Unrestricted_Access.all;\n+      N : Node_Array renames C.Nodes;\n+--    B : Natural renames C.Busy;\n+\n+      Node : Count_Type := Container.Last;\n+\n+      Index     : Count_Type := 0;\n+      Index_Max : constant Count_Type := Container.Length;\n+\n+   begin\n+      if Index_Max = 0 then\n+         pragma Assert (Node = 0);\n+         return;\n+      end if;\n+\n+      loop\n+         pragma Assert (Node > 0);\n+\n+         Process (Cursor'(C'Unchecked_Access, Node));\n+         pragma Assert (Container.Length = Index_Max);\n+         pragma Assert (N (Node).Prev /= -1);\n+\n+         Node := N (Node).Prev;\n+         Index := Index + 1;\n+\n+         if Index = Index_Max then\n+            pragma Assert (Node = 0);\n+            return;\n+         end if;\n+      end loop;\n+   end Reverse_Iterate;\n+\n+   ------------\n+   -- Splice --\n+   ------------\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : in out Cursor)\n+   is\n+      N : Node_Array renames Container.Nodes;\n+\n+   begin\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      end if;\n+\n+      if Position.Node = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n+      if Position.Node = Before.Node\n+        or else N (Position.Node).Next = Before.Node\n+      then\n+         return;\n+      end if;\n+\n+      pragma Assert (Container.Length >= 2);\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      if Before.Node = 0 then\n+         pragma Assert (Position.Node /= Container.Last);\n+\n+         if Position.Node = Container.First then\n+            Container.First := N (Position.Node).Next;\n+            N (Container.First).Prev := 0;\n+\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (Container.Last).Next := Position.Node;\n+         N (Position.Node).Prev := Container.Last;\n+\n+         Container.Last := Position.Node;\n+         N (Container.Last).Next := 0;\n+\n+         return;\n+      end if;\n+\n+      if Before.Node = Container.First then\n+         pragma Assert (Position.Node /= Container.First);\n+\n+         if Position.Node = Container.Last then\n+            Container.Last := N (Position.Node).Prev;\n+            N (Container.Last).Next := 0;\n+\n+         else\n+            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+         end if;\n+\n+         N (Container.First).Prev := Position.Node;\n+         N (Position.Node).Next := Container.First;\n+\n+         Container.First := Position.Node;\n+         N (Container.First).Prev := 0;\n+\n+         return;\n+      end if;\n+\n+      if Position.Node = Container.First then\n+         Container.First := N (Position.Node).Next;\n+         N (Container.First).Prev := 0;\n+\n+      elsif Position.Node = Container.Last then\n+         Container.Last := N (Position.Node).Prev;\n+         N (Container.Last).Next := 0;\n+\n+      else\n+         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n+         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n+      end if;\n+\n+      N (N (Before.Node).Prev).Next := Position.Node;\n+      N (Position.Node).Prev := N (Before.Node).Prev;\n+\n+      N (Before.Node).Prev := Position.Node;\n+      N (Position.Node).Next := Before.Node;\n+\n+      pragma Assert (N (Container.First).Prev = 0);\n+      pragma Assert (N (Container.Last).Next = 0);\n+   end Splice;\n+\n+   ----------\n+   -- Swap --\n+   ----------\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I.Node = 0\n+        or else J.Node = 0\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access\n+        or else J.Container /= Container'Unrestricted_Access\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+--    if Container.Lock > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n+\n+      declare\n+         N  : Node_Array renames Container.Nodes;\n+\n+         EI : Element_Type renames N (I.Node).Element;\n+         EJ : Element_Type renames N (J.Node).Element;\n+\n+         EI_Copy : constant Element_Type := EI;\n+\n+      begin\n+         EI := EJ;\n+         EJ := EI_Copy;\n+      end;\n+   end Swap;\n+\n+   ----------------\n+   -- Swap_Links --\n+   ----------------\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n+   begin\n+      if I.Node = 0\n+        or else J.Node = 0\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access\n+        or else I.Container /= J.Container\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n+\n+--    if Container.Busy > 0 then\n+--       raise Program_Error;\n+--    end if;\n+\n+      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n+\n+      declare\n+         I_Next : constant Cursor := Next (I);\n+         J_Copy : Cursor := J;\n+\n+      begin\n+         if I_Next = J then\n+            Splice (Container, Before => I, Position => J_Copy);\n+\n+         else\n+            declare\n+               J_Next : constant Cursor := Next (J);\n+               I_Copy : Cursor := I;\n+\n+            begin\n+               if J_Next = I then\n+                  Splice (Container, Before => J, Position => I_Copy);\n+\n+               else\n+                  pragma Assert (Container.Length >= 3);\n+\n+                  Splice (Container, Before => I_Next, Position => J_Copy);\n+                  Splice (Container, Before => J_Next, Position => I_Copy);\n+               end if;\n+            end;\n+         end if;\n+      end;\n+   end Swap_Links;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n+      declare\n+         N  : Node_Type renames Container.Nodes (Position.Node);\n+\n+      begin\n+         Process (N.Element);\n+         pragma Assert (N.Prev >= 0);\n+      end;\n+   end Update_Element;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         L : List renames Position.Container.all;\n+         N : Node_Array renames L.Nodes;\n+\n+      begin\n+         if L.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if L.First = 0 then\n+            return False;\n+         end if;\n+\n+         if L.Last = 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > L.Capacity then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev < 0\n+           or else N (Position.Node).Prev > L.Capacity\n+         then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next > L.Capacity then\n+            return False;\n+         end if;\n+\n+         if N (L.First).Prev /= 0 then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Next /= 0 then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev = 0\n+           and then Position.Node /= L.First\n+         then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next = 0\n+           and then Position.Node /= L.Last\n+         then\n+            return False;\n+         end if;\n+\n+         if L.Length = 1 then\n+            return L.First = L.Last;\n+         end if;\n+\n+         if L.First = L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.First).Next = 0 then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev = 0 then\n+            return False;\n+         end if;\n+\n+         if N (N (L.First).Next).Prev /= L.First then\n+            return False;\n+         end if;\n+\n+         if N (N (L.Last).Prev).Next /= L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Length = 2 then\n+            if N (L.First).Next /= L.Last then\n+               return False;\n+            end if;\n+\n+            if N (L.Last).Prev /= L.First then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end if;\n+\n+         if N (L.First).Next = L.Last then\n+            return False;\n+         end if;\n+\n+         if N (L.Last).Prev = L.First then\n+            return False;\n+         end if;\n+\n+         if Position.Node = L.First then\n+            return True;\n+         end if;\n+\n+         if Position.Node = L.Last then\n+            return True;\n+         end if;\n+\n+         if N (Position.Node).Next = 0 then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Prev = 0 then\n+            return False;\n+         end if;\n+\n+         if N (N (Position.Node).Next).Prev /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if N (N (Position.Node).Prev).Next /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if L.Length = 3 then\n+            if N (L.First).Next /= Position.Node then\n+               return False;\n+            end if;\n+\n+            if N (L.Last).Prev /= Position.Node then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Vet;\n+\n+end Ada.Containers.Restricted_Doubly_Linked_Lists;"}, {"sha": "0e768a4557eb11c11062f3ae092a98d4e3e98f06", "filename": "gcc/ada/a-crdlli.ads", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fa-crdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fa-crdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crdlli.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -0,0 +1,220 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                       A D A . C O N T A I N E R S .                      --\n+--        R E S R I C T E D  _ D O U B L Y _ L I N K E D _ L I S T S        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function \"=\" (Left, Right : Element_Type)\n+      return Boolean is <>;\n+\n+package Ada.Containers.Restricted_Doubly_Linked_Lists is\n+   pragma Pure;\n+\n+   type List (Capacity : Count_Type) is tagged limited private;\n+   pragma Preelaborable_Initialization (List);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_List : constant List;\n+\n+   No_Element : constant Cursor;\n+\n+   function \"=\" (Left, Right : List) return Boolean;\n+\n+   procedure Assign (Target : in out List; Source : List);\n+\n+   function Length (Container : List) return Count_Type;\n+\n+   function Is_Empty (Container : List) return Boolean;\n+\n+   procedure Clear (Container : in out List);\n+\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+\n+   procedure Update_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Prepend\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Append\n+     (Container : in out List;\n+      New_Item  : Element_Type;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete\n+     (Container : in out List;\n+      Position  : in out Cursor;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_First\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Delete_Last\n+     (Container : in out List;\n+      Count     : Count_Type := 1);\n+\n+   procedure Reverse_Elements (Container : in out List);\n+\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Swap_Links\n+     (Container : in out List;\n+      I, J      : Cursor);\n+\n+   procedure Splice\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : in out Cursor);\n+\n+   function First (Container : List) return Cursor;\n+\n+   function First_Element (Container : List) return Element_Type;\n+\n+   function Last (Container : List) return Cursor;\n+\n+   function Last_Element (Container : List) return Element_Type;\n+\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n+\n+   function Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n+\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor));\n+\n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+   end Generic_Sorting;\n+\n+private\n+\n+   type Node_Type is limited record\n+      Prev    : Count_Type'Base;\n+      Next    : Count_Type;\n+      Element : Element_Type;\n+   end record;\n+\n+   type Node_Array is array (Count_Type range <>) of Node_Type;\n+\n+   type List (Capacity : Count_Type) is tagged limited record\n+      Nodes  : Node_Array (1 .. Capacity) := (others => <>);\n+      Free   : Count_Type'Base := -1;\n+      First  : Count_Type := 0;\n+      Last   : Count_Type := 0;\n+      Length : Count_Type := 0;\n+   end record;\n+\n+   Empty_List : constant List := (0, others => <>);\n+\n+   type List_Access is access all List;\n+   for List_Access'Storage_Size use 0;\n+\n+   type Cursor is\n+      record\n+         Container : List_Access;\n+         Node      : Count_Type := 0;\n+      end record;\n+\n+   No_Element : constant Cursor := (null, 0);\n+\n+end Ada.Containers.Restricted_Doubly_Linked_Lists;"}, {"sha": "f5725fad019af9191bd3370dc05b0eee7877ad7c", "filename": "gcc/ada/a-wtenio.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fa-wtenio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fa-wtenio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtenio.adb?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -44,11 +44,9 @@ package body Ada.Wide_Text_IO.Enumeration_IO is\n    procedure Get (File : File_Type; Item : out Enum) is\n       Buf    : Wide_String (1 .. Enum'Width);\n       Buflen : Natural;\n-\n    begin\n       Aux.Get_Enum_Lit (File, Buf, Buflen);\n       Item := Enum'Wide_Value (Buf (1 .. Buflen));\n-\n    exception\n       when Constraint_Error => raise Data_Error;\n    end Get;\n@@ -64,11 +62,9 @@ package body Ada.Wide_Text_IO.Enumeration_IO is\n       Last : out Positive)\n    is\n       Start : Natural;\n-\n    begin\n       Aux.Scan_Enum_Lit (From, Start, Last);\n       Item := Enum'Wide_Value (From (Start .. Last));\n-\n    exception\n       when Constraint_Error => raise Data_Error;\n    end Get;\n@@ -84,7 +80,6 @@ package body Ada.Wide_Text_IO.Enumeration_IO is\n       Set   : Type_Set := Default_Setting)\n    is\n       Image : constant Wide_String := Enum'Wide_Image (Item);\n-\n    begin\n       Aux.Put (File, Image, Width, Set);\n    end Put;\n@@ -104,7 +99,6 @@ package body Ada.Wide_Text_IO.Enumeration_IO is\n       Set  : Type_Set := Default_Setting)\n    is\n       Image : constant Wide_String := Enum'Wide_Image (Item);\n-\n    begin\n       Aux.Puts (To, Image, Set);\n    end Put;"}, {"sha": "0fb616e5cac042887e872ecf346ff6c76d84a48b", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -186,7 +186,6 @@ package body Elists is\n       N : constant Union_Id := Elmts.Table (Elmt).Next;\n \n    begin\n-\n       pragma Assert (Elmt /= No_Elmt);\n \n       Elmts.Increment_Last;\n@@ -301,11 +300,11 @@ package body Elists is\n       return Elmt = No_Elmt;\n    end No;\n \n-   -----------\n+   ----------\n    -- Node --\n-   -----------\n+   ----------\n \n-   function Node (Elmt : Elmt_Id) return Node_Id is\n+   function Node (Elmt : Elmt_Id) return Node_Or_Entity_Id is\n    begin\n       if Elmt = No_Elmt then\n          return Empty;"}, {"sha": "690ff33d99e351bcbdd6e5b8b1836f12345b2286", "filename": "gcc/ada/exp_tss.ads", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -172,20 +172,20 @@ package Exp_Tss is\n \n    procedure Set_TSS (Typ : Entity_Id; TSS : Entity_Id);\n    --  This procedure is used to install a newly created TSS. The second\n-   --  argument is the entity for such a new TSS. This entity is placed in\n-   --  the TSS list for the type given as the first argument, replacing an\n-   --  old entry of the same name if one was present. The tree for the body\n-   --  of this TSS, which is not analyzed yet, is placed in the actions field\n-   --  of the freeze node for the type. All such bodies are inserted into the\n-   --  main tree and analyzed at the point at which the freeze node itself is\n-   --  is expanded.\n+   --  argument is the entity for such a new TSS. This entity is placed in the\n+   --  TSS list for the type given as the first argument, replacing an old\n+   --  entry of the same name if one was present. The tree for the body of this\n+   --  TSS, which is not analyzed yet, is placed in the actions field of the\n+   --  freeze node for the type. All such bodies are inserted into the main\n+   --  tree and analyzed at the point at which the freeze node itself is\n+   --  expanded.\n \n    procedure Copy_TSS (TSS : Entity_Id; Typ : Entity_Id);\n    --  Given an existing TSS for another type (which is already installed,\n    --  analyzed and expanded), install it as the corresponding TSS for Typ.\n-   --  Note that this just copies a reference, not the tree. This can also\n-   --  be used to initially install a TSS in the case where the subprogram\n-   --  for the TSS has already been created and its declaration processed.\n+   --  Note that this just copies a reference, not the tree. This can also be\n+   --  used to initially install a TSS in the case where the subprogram for the\n+   --  TSS has already been created and its declaration processed.\n \n    function Init_Proc (Typ : Entity_Id) return Entity_Id;\n    pragma Inline (Init_Proc);"}, {"sha": "85a30d9239f96845de3b998a507ec25c0fae5cbc", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "009dbee1052660df9a964d413143a8e9f901f691", "filename": "gcc/ada/gnatvsn.ads", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fgnatvsn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fgnatvsn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatvsn.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -45,36 +45,33 @@ package Gnatvsn is\n    --  Static string identifying this version, that can be used as an argument\n    --  to e.g. pragma Ident.\n \n-   type Gnat_Build_Type is (FSF, Public, GAP);\n+   type Gnat_Build_Type is (FSF, GPL);\n    --  See Get_Gnat_Build_Type below for the meaning of these values.\n \n    function Get_Gnat_Build_Type return Gnat_Build_Type;\n    --  This function returns one of the following values of Gnat_Build_Type:\n    --\n    --    FSF\n    --       GNAT FSF version. This version of GNAT is part of a Free Software\n-   --       Foundation release of the GNU Compiler Collection (GCC). The binder\n-   --       will not output informational messages regarding intended use,\n-   --       and the bug box generated by Comperr will give information on\n-   --       how to report bugs and list the \"no warranty\" information.\n+   --       Foundation release of the GNU Compiler Collection (GCC). The bug\n+   --       box generated by Comperr gives information on how to report bugs\n+   --       and list the \"no warranty\" information.\n    --\n-   --    Public\n-   --       GNAT Public version.\n-   --       The binder will output informational messages, and the bug box\n-   --       generated by the package Comperr will give appropriate bug\n-   --       submission instructions.\n-   --\n-   --    GAP\n-   --       GNAT Academic Program, similar to Public.\n+   --    GPL\n+   --       GNAT GPL Edition. This is a special version of GNAT, released by\n+   --       Ada Core Technologies and intended for academic users, and free\n+   --       software developers. The bug box generated by the package Comperr\n+   --       gives appropriate bug submission instructions that do not reference\n+   --       customer number etc.\n \n-   Ver_Len_Max : constant := 32;\n+   Ver_Len_Max : constant := 64;\n    --  Longest possible length for Gnat_Version_String in this or any\n    --  other version of GNAT. This is used by the binder to establish\n    --  space to store any possible version string value for checks. This\n    --  value should never be decreased in the future, but it would be\n    --  OK to increase it if absolutely necessary.\n \n-   Library_Version : constant String := \"4.2\";\n+   Library_Version : constant String := \"4.3\";\n    --  Library version. This value must be updated whenever any change to the\n    --  compiler affects the library formats in such a way as to obsolete\n    --  previously compiled library modules.\n@@ -85,7 +82,7 @@ package Gnatvsn is\n    Verbose_Library_Version : constant String := \"GNAT Lib v\" & Library_Version;\n    --  Version string stored in e.g. ALI files.\n \n-   ASIS_Version_Number : constant := 5;\n+   ASIS_Version_Number : constant := 6;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees, and an ASIS application that is reading the\n    --  trees. It must be updated (incremented) whenever a change is made to"}, {"sha": "f14ac7c91fdf373de44737b0d542a9d8fb15adeb", "filename": "gcc/ada/impunit.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fimpunit.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fimpunit.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "8da30896c4e9950bfafd3a5a6106ad1ca73f5cc8", "filename": "gcc/ada/initialize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Finitialize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Finitialize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finitialize.c?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "9d5eec4eda04bb92b2de9957f884a9cca7db7a39", "filename": "gcc/ada/s-dsaser.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fs-dsaser.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fs-dsaser.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dsaser.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . D S A _ S E R V I C E S                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--            Copyright (C) 2006, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is for distributed system annex services, which require the\n+--  partition communication sub-system to be initialized before they are used.\n+\n+with System.Partition_Interface;\n+with System.RPC;\n+\n+package System.DSA_Services is\n+\n+   function Get_Active_Partition_ID\n+     (Name : Partition_Interface.Unit_Name) return RPC.Partition_ID\n+     renames Partition_Interface.Get_Active_Partition_ID;\n+   --  Returns the partition ID of the partition in which Name resides\n+\n+end System.DSA_Services;"}, {"sha": "41762e1a387eb5912de22b099bfca7c84092aa7e", "filename": "gcc/ada/s-imgdec.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fs-imgdec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fs-imgdec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgdec.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,8 +39,7 @@ package System.Img_Dec is\n \n    function Image_Decimal\n      (V     : Integer;\n-      Scale : Integer)\n-      return  String;\n+      Scale : Integer) return String;\n    --  Compute 'Image of V, the integer value (in units of delta) of a decimal\n    --  type whose Scale is as given and return the result. THe image is given\n    --  by the rules in RM 3.5(34) for fixed-point type image functions."}, {"sha": "2e321615265b82ef765057ae59661140bf6a7fb3", "filename": "gcc/ada/s-osinte-vms.ads", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fs-osinte-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fs-osinte-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n+--             Copyright (C) 1995-2006, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,10 +121,10 @@ package System.OS_Interface is\n \n    procedure Sys_Assign\n      (Status : out Cond_Value_Type;\n-      Devnam : in String;\n+      Devnam : String;\n       Chan   : out unsigned_short;\n       Acmode : in unsigned_short := 0;\n-      Mbxnam : in String := String'Null_Parameter;\n+      Mbxnam : String := String'Null_Parameter;\n       Flags  : in unsigned_long := 0);\n    pragma Interface (External, Sys_Assign);\n    pragma Import_Valued_Procedure\n@@ -147,7 +147,7 @@ package System.OS_Interface is\n    --\n    procedure Sys_Cantim\n      (Status : out Cond_Value_Type;\n-      Reqidt : in Address;\n+      Reqidt : Address;\n       Acmode : in unsigned);\n    pragma Interface (External, Sys_Cantim);\n    pragma Import_Valued_Procedure\n@@ -173,13 +173,13 @@ package System.OS_Interface is\n    --\n    procedure Sys_Crembx\n      (Status : out Cond_Value_Type;\n-      Prmflg : in Boolean;\n+      Prmflg : Boolean;\n       Chan   : out unsigned_short;\n       Maxmsg : in unsigned_long := 0;\n       Bufquo : in unsigned_long := 0;\n       Promsk : in unsigned_short := 0;\n       Acmode : in unsigned_short := 0;\n-      Lognam : in String;\n+      Lognam : String;\n       Flags  : in unsigned_long := 0);\n    pragma Interface (External, Sys_Crembx);\n    pragma Import_Valued_Procedure\n@@ -212,8 +212,8 @@ package System.OS_Interface is\n       Chan   : in unsigned_short;\n       Func   : in unsigned_long := 0;\n       Iosb   : out IO_Status_Block_Type;\n-      Astadr : in AST_Handler := No_AST_Handler;\n-      Astprm : in Address := Null_Address;\n+      Astadr : AST_Handler := No_AST_Handler;\n+      Astprm : Address := Null_Address;\n       P1     : in  unsigned_long := 0;\n       P2     : in  unsigned_long := 0;\n       P3     : in  unsigned_long := 0;\n@@ -226,9 +226,9 @@ package System.OS_Interface is\n       EFN    : in unsigned_long := 0;\n       Chan   : in unsigned_short;\n       Func   : in unsigned_long := 0;\n-      Iosb   : in Address := Null_Address;\n-      Astadr : in AST_Handler := No_AST_Handler;\n-      Astprm : in Address := Null_Address;\n+      Iosb   : Address := Null_Address;\n+      Astadr : AST_Handler := No_AST_Handler;\n+      Astprm : Address := Null_Address;\n       P1     : in  unsigned_long := 0;\n       P2     : in  unsigned_long := 0;\n       P3     : in  unsigned_long := 0;\n@@ -275,9 +275,9 @@ package System.OS_Interface is\n    procedure Sys_Setimr\n      (Status : out Cond_Value_Type;\n       EFN    : in unsigned_long;\n-      Tim    : in Long_Integer;\n-      AST    : in AST_Handler;\n-      Reqidt : in Address;\n+      Tim    : Long_Integer;\n+      AST    : AST_Handler;\n+      Reqidt : Address;\n       Flags  : in unsigned_long);\n    pragma Interface (External, Sys_Setimr);\n    pragma Import_Valued_Procedure"}, {"sha": "288e3007a1f936b7ad5fbd8c8e6b07bca0c763a7", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "d33c33555b52ec5cbc2872a6e15549ea695c5bd1", "filename": "gcc/ada/system-linux-ppc.ads", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fsystem-linux-ppc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ace3b78346ae029998488057606133f714f222/gcc%2Fada%2Fsystem-linux-ppc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-linux-ppc.ads?ref=b5ace3b78346ae029998488057606133f714f222", "patch": "@@ -5,9 +5,9 @@\n --                               S Y S T E M                                --\n --                                                                          --\n --                                 S p e c                                  --\n---                          (GNU-Linux/PPC Version)                         --\n+--                         (GNU-Linux/PPC Version)                          --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -88,17 +88,18 @@ package System is\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n    Default_Bit_Order : constant Bit_Order := High_Order_First;\n+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority           : constant Positive := 30;\n-   Max_Interrupt_Priority : constant Positive := 31;\n+   Max_Priority           : constant Positive := 97;\n+   Max_Interrupt_Priority : constant Positive := 98;\n \n-   subtype Any_Priority       is Integer      range  0 .. 31;\n-   subtype Priority           is Any_Priority range  0 .. 30;\n-   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n+   subtype Any_Priority       is Integer      range  0 .. 98;\n+   subtype Priority           is Any_Priority range  0 .. 97;\n+   subtype Interrupt_Priority is Any_Priority range 98 .. 98;\n \n-   Default_Priority : constant Priority := 15;\n+   Default_Priority : constant Priority := 48;\n \n private\n "}]}