{"sha": "46efdbbc0113427e165b0d3635d5a26fb83d1448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZlZmRiYmMwMTEzNDI3ZTE2NWIwZDM2MzVkNWEyNmZiODNkMTQ0OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-09-23T17:07:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-09-23T17:07:15Z"}, "message": "runtime: rewrite lfstack packing/unpacking to look more like that in Go\n\n    Reviewed-on: https://go-review.googlesource.com/13037\n\nFrom-SVN: r228057", "tree": {"sha": "66208412bf69d3df426444c19fd51e8e694750da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66208412bf69d3df426444c19fd51e8e694750da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46efdbbc0113427e165b0d3635d5a26fb83d1448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46efdbbc0113427e165b0d3635d5a26fb83d1448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46efdbbc0113427e165b0d3635d5a26fb83d1448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46efdbbc0113427e165b0d3635d5a26fb83d1448/comments", "author": null, "committer": null, "parents": [{"sha": "a9c238108bf8532990df88c137383b457acb8893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c238108bf8532990df88c137383b457acb8893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c238108bf8532990df88c137383b457acb8893"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "1ea55554fba1004c934ebb09353f8a44c6679ad2", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46efdbbc0113427e165b0d3635d5a26fb83d1448/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46efdbbc0113427e165b0d3635d5a26fb83d1448/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=46efdbbc0113427e165b0d3635d5a26fb83d1448", "patch": "@@ -1,4 +1,4 @@\n-e069d4417a692c1261df99fe3323277e1a0193d2\n+2087b95180caea3477647c449772b7fecc01a71c\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9eb80d900f92292a0e986f98b73831f40307cb9f", "filename": "libgo/runtime/lfstack.goc", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46efdbbc0113427e165b0d3635d5a26fb83d1448/libgo%2Fruntime%2Flfstack.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46efdbbc0113427e165b0d3635d5a26fb83d1448/libgo%2Fruntime%2Flfstack.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flfstack.goc?ref=46efdbbc0113427e165b0d3635d5a26fb83d1448", "patch": "@@ -9,42 +9,58 @@ package runtime\n #include \"arch.h\"\n \n #if __SIZEOF_POINTER__ == 8\n-// Amd64 uses 48-bit virtual addresses, 47-th bit is used as kernel/user flag.\n-// So we use 17msb of pointers as ABA counter.\n-# define PTR_BITS 47\n-#else\n-# define PTR_BITS 32\n-#endif\n-#define PTR_MASK ((1ull<<PTR_BITS)-1)\n-#define CNT_MASK (0ull-1)\n-\n-#if __SIZEOF_POINTER__ == 8 && (defined(__sparc__) || (defined(__sun__) && defined(__amd64__)))\n // SPARC64 and Solaris on AMD64 uses all 64 bits of virtual addresses.\n // Use low-order three bits as ABA counter.\n // http://docs.oracle.com/cd/E19120-01/open.solaris/816-5138/6mba6ua5p/index.html\n-#undef PTR_BITS\n-#undef CNT_MASK\n-#undef PTR_MASK\n-#define PTR_BITS 0\n-#define CNT_MASK 7\n-#define PTR_MASK ((0ull-1)<<3)\n+# if defined(__sparc__) || (defined(__sun__) && defined(__amd64__))\n+static inline uint64 lfPack(LFNode *node, uintptr cnt) {\n+\treturn ((uint64)(node)) | ((cnt)&7);\n+}\n+static inline LFNode* lfUnpack(uint64 val) {\n+\treturn (LFNode*)(val&~7);\n+}\n+# else\n+#  if defined(__aarch64__)\n+// Depending on the kernel options, pointers on arm64 can have up to 48 significant\n+// bits (see https://www.kernel.org/doc/Documentation/arm64/memory.txt).\n+#   define PTR_BITS 48\n+#  else\n+// Amd64 uses 48-bit virtual addresses, 47-th bit is used as kernel/user flag.\n+// So we use 17msb of pointers as ABA counter.\n+#   define PTR_BITS 47\n+#  endif\n+# endif\n+# define CNT_BITS (64 - PTR_BITS + 3)\n+static inline uint64 lfPack(LFNode *node, uintptr cnt) {\n+\treturn ((uint64)(node)<<(64-PTR_BITS)) | (cnt&(((1<<CNT_BITS)-1)));\n+}\n+static inline LFNode* lfUnpack(uint64 val) {\n+\treturn (LFNode*)((val >> CNT_BITS) << 3);\n+}\n+#else\n+static inline uint64 lfPack(LFNode *node, uintptr cnt) {\n+\treturn ((uint64)(uintptr)(node)<<32) | cnt;\n+}\n+static inline LFNode* lfUnpack(uint64 val) {\n+\treturn (LFNode*)(uintptr)(val >> 32);\n+}\n #endif\n \n void\n runtime_lfstackpush(uint64 *head, LFNode *node)\n {\n \tuint64 old, new;\n \n-\tif((uintptr)node != ((uintptr)node&PTR_MASK)) {\n+\tif(node != lfUnpack(lfPack(node, 0))) {\n \t\truntime_printf(\"p=%p\\n\", node);\n \t\truntime_throw(\"runtime_lfstackpush: invalid pointer\");\n \t}\n \n \tnode->pushcnt++;\n-\tnew = (uint64)(uintptr)node|(((uint64)node->pushcnt&CNT_MASK)<<PTR_BITS);\n+\tnew = lfPack(node, node->pushcnt);\n \tfor(;;) {\n \t\told = runtime_atomicload64(head);\n-\t\tnode->next = (LFNode*)(uintptr)(old&PTR_MASK);\n+\t\tnode->next = lfUnpack(old);\n \t\tif(runtime_cas64(head, old, new))\n \t\t\tbreak;\n \t}\n@@ -60,11 +76,11 @@ runtime_lfstackpop(uint64 *head)\n \t\told = runtime_atomicload64(head);\n \t\tif(old == 0)\n \t\t\treturn nil;\n-\t\tnode = (LFNode*)(uintptr)(old&PTR_MASK);\n+\t\tnode = lfUnpack(old);\n \t\tnode2 = runtime_atomicloadp(&node->next);\n \t\tnew = 0;\n \t\tif(node2 != nil)\n-\t\t\tnew = (uint64)(uintptr)node2|(((uint64)node2->pushcnt&CNT_MASK)<<PTR_BITS);\n+\t\t\tnew = lfPack(node2, node2->pushcnt);\n \t\tif(runtime_cas64(head, old, new))\n \t\t\treturn node;\n \t}"}]}