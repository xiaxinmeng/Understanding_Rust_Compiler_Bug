{"sha": "f95d3af09e1ee6626fe61818e39e5289797f2f4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk1ZDNhZjA5ZTFlZTY2MjZmZTYxODE4ZTM5ZTUyODk3OTdmMmY0ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-27T22:27:53Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-27T22:27:53Z"}, "message": "(TARGET_DEFAULT): Default to 68020-40.\n\n(ASM_SPEC): New macro.\n(FUNCTION_VALUE, FUNCTION_VALUE_REGNO_P): Return pointer in a0.\n(*_LIBCALL): Use functions from sysV68's library.\n(INIT_CUMULATIVE_ARGS, FUNCTION_ARG*): Some libcalls pass parameters in\nregisters.\n\nFrom-SVN: r6655", "tree": {"sha": "4cc98cd8f1a0d92593e5c9cdd62d5bbdaccd6adb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cc98cd8f1a0d92593e5c9cdd62d5bbdaccd6adb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f95d3af09e1ee6626fe61818e39e5289797f2f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95d3af09e1ee6626fe61818e39e5289797f2f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95d3af09e1ee6626fe61818e39e5289797f2f4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95d3af09e1ee6626fe61818e39e5289797f2f4e/comments", "author": null, "committer": null, "parents": [{"sha": "700942a0c60bb556ac7c35f57d4f559e671e0c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700942a0c60bb556ac7c35f57d4f559e671e0c66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700942a0c60bb556ac7c35f57d4f559e671e0c66"}], "stats": {"total": 78, "additions": 60, "deletions": 18}, "files": [{"sha": "c4c8ea5b86ac5f42ec421a29721efa7f777c708d", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 60, "deletions": 18, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f95d3af09e1ee6626fe61818e39e5289797f2f4e/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f95d3af09e1ee6626fe61818e39e5289797f2f4e/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=f95d3af09e1ee6626fe61818e39e5289797f2f4e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  \n    SysV68 Motorola 3300 Delta Series\n-   Copyright (C) 1987, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993, 1994 Free Software Foundation, Inc.\n    Written by Abramo and Roberto Bagnara (bagnara@dipisa.di.unipi.it)\n    based on Alex Crain's 3B1 definitions.\n \n@@ -31,12 +31,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"m68k/m68k.h\"\n \n-/* See m68k.h.  7 means 68020 with 68881.  */\n+/* See m68k.h.  0407 means 68020-68040.  */\n \n #ifndef TARGET_DEFAULT\n-#define\tTARGET_DEFAULT 7\n+#define\tTARGET_DEFAULT 0407\n #endif\n \n+/* -m[c]6800 requires special flag to the assembler.  */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{m68000:-p 000}%{mc68000:-p 000}\"\n+\n /* NYI: FP= is equivalent to -msoft-float  */\n \n /* We use /lib/libp/lib* when profiling.  */\n@@ -265,21 +270,22 @@ output_file_directive ((FILE), main_input_filename)\n /* NYI: If -mold return pointer in a0 and d0 */\n \n #undef FUNCTION_VALUE\n-#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n-\n /* sysV68 (brain damaged) cc convention support. */\n /* Commented out until we find a safe way to make it optional.  */\n-#if 0\n+#if 1\n #define FUNCTION_VALUE(VALTYPE,FUNC) \\\n   (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881 \t\\\n    ? gen_rtx (REG, TYPE_MODE (VALTYPE), 16)\t\t\\\n    : (TREE_CODE (VALTYPE) == POINTER_TYPE \t\t\\\n       ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8)\t\t\\\n       : gen_rtx (REG, TYPE_MODE (VALTYPE), 0)))\n+#else\n+#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n #endif\n \n /* If TARGET_68881, SF and DF values are returned in fp0 instead of d0.  */\n \n+/* Is LIBCALL_VALUE never called with a pointer ? */\n #undef LIBCALL_VALUE\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t   \\\n  gen_rtx (REG, (MODE),\t\t\t\t\t\t\t   \\\n@@ -291,14 +297,14 @@ output_file_directive ((FILE), main_input_filename)\n    d0 may be used, and fp0 as well if -msoft-float is not specified.  */\n \n #undef FUNCTION_VALUE_REGNO_P\n-#define FUNCTION_VALUE_REGNO_P(N) \\\n- ((N) == 0 || (TARGET_68881 && (N) == 16))\n-\n /* sysV68 (brain damaged) cc convention support. */\n /* Commented out until we find a safe way to make it optional.  */\n-#if 0\n+#if 1\n #define FUNCTION_VALUE_REGNO_P(N) \\\n  ((N) == 0 || (N) == 8 || (TARGET_68881 && (N) == 16))\n+#else\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+ ((N) == 0 || (TARGET_68881 && (N) == 16))\n #endif \n \n /* Define this to be true when FUNCTION_VALUE_REGNO_P is true for\n@@ -828,12 +834,48 @@ do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n   sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n \n /* Define subroutines to call to handle multiply, divide, and remainder.\n-   Use the subroutines that the 3b1's library provides.\n+   Use the subroutines that the sysV68's library provides.\n    The `*' prevents an underscore from being prepended by the compiler.  */\n-\n-#define DIVSI3_LIBCALL \"*ldiv\"\n-#define UDIVSI3_LIBCALL \"*uldiv\"\n-#define MODSI3_LIBCALL \"*lrem\"\n-#define UMODSI3_LIBCALL \"*ulrem\"\n-#define MULSI3_LIBCALL \"*lmul\"\n-#define UMULSI3_LIBCALL \"*ulmul\"\n+/* The '*' is also used by INIT_CUMULATIVE_ARGS */\n+\n+#define DIVSI3_LIBCALL \"*ldiv%%\"\n+#define UDIVSI3_LIBCALL \"*uldiv%%\"\n+#define MODSI3_LIBCALL \"*lrem%%\"\n+#define UMODSI3_LIBCALL \"*ulrem%%\"\n+#define MULSI3_LIBCALL \"*lmul%%\"\n+\n+struct sysV68_cumulative_args\n+\t{\n+\tint\toffset;\n+\tint\tlibcall;\n+\t};\n+\n+#undef CUMULATIVE_ARGS\n+#define CUMULATIVE_ARGS struct sysV68_cumulative_args\n+\n+#undef INIT_CUMULATIVE_ARGS\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+do {(CUM).offset = 0;\\\n+(CUM).libcall = (LIBNAME) && (*XSTR((LIBNAME), 0) == '*');} while(0)\n+\n+#undef FUNCTION_ARG_ADVANCE\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM).offset += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+#undef FUNCTION_ARG\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+(((CUM).libcall && (CUM).offset == 0) ? gen_rtx(REG, (MODE), 0)\\\n+: (TARGET_REGPARM && (CUM).offset < 8) ? gen_rtx (REG, (MODE), (CUM).offset / 4) : 0)\n+\n+#undef FUNCTION_ARG_PARTIAL_NREGS\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM).offset < 8\t\t\t\t\\\n+  && 8 < ((CUM).offset + ((MODE) == BLKmode\t\t\t\\\n+\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n+\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n+ ? 2 - (CUM).offset / 4 : 0)\n+\n+#undef FUNCTION_ARG_REGNO_P\n+#define FUNCTION_ARG_REGNO_P(N) (TARGET_68020 ? 0 : (N) == 0)"}]}