{"sha": "6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyZjQwNTBhYWNmNDQ4ZjFlNjNhODQ0ODQ1YTFkMGU3Y2RlNTljYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-19T14:12:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-19T14:12:14Z"}, "message": "call.c (add_list_candidates): Use OVL_FIRST.\n\n\t* call.c (add_list_candidates): Use OVL_FIRST.\n\t(build_new_method_call_1): Likewise.\n\t* cp-tree.h (OVL_SINGLE_P): New.\n\t(TYPE_HIDDEN_P): New.\n\t* decl.c (xref_tag_1): Use TYPE_HIDDEN_P.\n\t* dump.c (cp_tump_tree): Adjust overload dumping.\n\t* error.c (dump_decl): Use OVL_SINGLE_P, simplify context\n\tprinting.\n\t* method.c (lazily_declare_fn): Assert we added it.\n\t* parser.c (cp_parser_nested_name_specifier): Use OVL_SINGLE_P,\n\tOVL_FIRST.\n\t(cp_parser_template_name): Use lkp_iterator.\n\t* pt.c (begin_template_parm_list): Fixup comment.\n\t(instantiate_class_template_1): Use TYPE_HIDDEN_P.\n\t* tree.c (ovl_iterator::remove_node): Cope with inherited ctors.\n\t(ovl_scope): Use lkp_iterator.\n\nFrom-SVN: r248285", "tree": {"sha": "34862ee39fd2a98aebffc638e0b600035d0e75bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34862ee39fd2a98aebffc638e0b600035d0e75bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "546c8974ff51ef7554e18d94177fc953c0e54b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546c8974ff51ef7554e18d94177fc953c0e54b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546c8974ff51ef7554e18d94177fc953c0e54b95"}], "stats": {"total": 115, "additions": 76, "deletions": 39}, "files": [{"sha": "08efe36f35636f0edde49f5aefa1845bc4326de9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -1,3 +1,22 @@\n+2017-05-19  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* call.c (add_list_candidates): Use OVL_FIRST.\n+\t(build_new_method_call_1): Likewise.\n+\t* cp-tree.h (OVL_SINGLE_P): New.\n+\t(TYPE_HIDDEN_P): New.\n+\t* decl.c (xref_tag_1): Use TYPE_HIDDEN_P.\n+\t* dump.c (cp_tump_tree): Adjust overload dumping.\n+\t* error.c (dump_decl): Use OVL_SINGLE_P, simplify context\n+\tprinting.\n+\t* method.c (lazily_declare_fn): Assert we added it.\n+\t* parser.c (cp_parser_nested_name_specifier): Use OVL_SINGLE_P,\n+\tOVL_FIRST.\n+\t(cp_parser_template_name): Use lkp_iterator.\n+\t* pt.c (begin_template_parm_list): Fixup comment.\n+\t(instantiate_class_template_1): Use TYPE_HIDDEN_P.\n+\t* tree.c (ovl_iterator::remove_node): Cope with inherited ctors.\n+\t(ovl_scope): Use lkp_iterator.\n+\n 2017-05-19  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* parser.c (cp_parser_omp_clause_default): Handle"}, {"sha": "f14c0fabcc58b50894a7b76939255e59e8d226b7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -3666,7 +3666,7 @@ add_list_candidates (tree fns, tree first_arg,\n      avoid the copy constructor call for copy-list-initialization.  */\n   flags |= LOOKUP_NO_NARROWING;\n \n-  unsigned nart = num_artificial_parms_for (get_first_fn (fns)) - 1;\n+  unsigned nart = num_artificial_parms_for (OVL_FIRST (fns)) - 1;\n   tree init_list = (*args)[nart];\n \n   /* Always use the default constructor if the list is empty (DR 990).  */\n@@ -8539,7 +8539,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n   gcc_assert (TREE_CODE (fns) == FUNCTION_DECL\n \t      || TREE_CODE (fns) == TEMPLATE_DECL\n \t      || TREE_CODE (fns) == OVERLOAD);\n-  fn = get_first_fn (fns);\n+  fn = OVL_FIRST (fns);\n   name = DECL_NAME (fn);\n \n   basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n@@ -8708,7 +8708,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t      tree errname = name;\n \t      if (IDENTIFIER_CTOR_OR_DTOR_P (errname))\n \t\t{\n-\t\t  tree fn = DECL_ORIGIN (get_first_fn (fns));\n+\t\t  tree fn = DECL_ORIGIN (OVL_FIRST (fns));\n \t\t  errname = DECL_NAME (fn);\n \t\t}\n \t      if (explicit_targs)"}, {"sha": "633377dd429837a40f1733c3a371997cf0157224", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -655,6 +655,10 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n /* The name of the overload set.  */\n #define OVL_NAME(NODE) DECL_NAME (OVL_FIRST (NODE))\n \n+/* Whether this is a single member overload.  */\n+#define OVL_SINGLE_P(NODE) \\\n+  (TREE_CODE (NODE) != OVERLOAD || !OVL_CHAIN (NODE))\n+\n struct GTY(()) tree_overload {\n   struct tree_common common;\n   tree function;\n@@ -3750,6 +3754,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   (DECL_LANG_SPECIFIC (TYPE_FUNCTION_OR_TEMPLATE_DECL_CHECK (NODE)) \\\n    ->u.base.anticipated_p)\n \n+/* True if this is a hidden class type.    */\n+#define TYPE_HIDDEN_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (TYPE_NAME (NODE)) \\\n+   && DECL_ANTICIPATED (TYPE_NAME (NODE)))\n+\n /* True for artificial decls added for OpenMP privatized non-static\n    data members.  */\n #define DECL_OMP_PRIVATIZED_MEMBER(NODE) \\"}, {"sha": "5877f37998e80a6ea7467a9bf3c2f630bafd297f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -13636,16 +13636,18 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n \t}\n \n       /* Make injected friend class visible.  */\n-      if (scope != ts_within_enclosing_non_class\n-\t  && hidden_name_p (TYPE_NAME (t)))\n+      if (scope != ts_within_enclosing_non_class && TYPE_HIDDEN_P (t))\n \t{\n-\t  DECL_ANTICIPATED (TYPE_NAME (t)) = 0;\n-\t  DECL_FRIEND_P (TYPE_NAME (t)) = 0;\n+\t  tree decl = TYPE_NAME (t);\n+\n+\t  DECL_ANTICIPATED (decl) = false;\n+\t  DECL_FRIEND_P (decl) = false;\n \n \t  if (TYPE_TEMPLATE_INFO (t))\n \t    {\n-\t      DECL_ANTICIPATED (TYPE_TI_TEMPLATE (t)) = 0;\n-\t      DECL_FRIEND_P (TYPE_TI_TEMPLATE (t)) = 0;\n+\t      tree tmpl = TYPE_TI_TEMPLATE (t);\n+\t      DECL_ANTICIPATED (tmpl) = false;\n+\t      DECL_FRIEND_P (tmpl) = false;\n \t    }\n \t}\n     }"}, {"sha": "080fa1a978d695f3ce042ac13b4783a0006a321b", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -364,8 +364,10 @@ cp_dump_tree (void* dump_info, tree t)\n       break;\n \n     case OVERLOAD:\n-      dump_child (\"crnt\", OVL_CURRENT (t));\n-      dump_child (\"chan\", OVL_CHAIN (t));\n+      dump_child (\"name\", OVL_NAME (t));\n+      if (!dump_flag (di, TDF_SLIM, t))\n+\tfor (lkp_iterator iter (t); iter; ++iter)\n+\t  dump_child (\"chld\", *iter);\n       break;\n \n     case TRY_BLOCK:"}, {"sha": "1ae25bb486ce7c86aefd4d9c9d901afb5c1e7dc1", "filename": "gcc/cp/error.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -1189,17 +1189,16 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n       break;\n \n     case OVERLOAD:\n-      if (OVL_CHAIN (t))\n+      if (!OVL_SINGLE_P (t))\n \t{\n-\t  t = OVL_CURRENT (t);\n-\t  if (DECL_CLASS_SCOPE_P (t))\n+\t  t = OVL_FIRST (t);\n+\t  tree ctx = CP_DECL_CONTEXT (t);\n+\t  if (ctx != global_namespace)\n \t    {\n-\t      dump_type (pp, DECL_CONTEXT (t), flags);\n-\t      pp_cxx_colon_colon (pp);\n-\t    }\n-\t  else if (!DECL_FILE_SCOPE_P (t))\n-\t    {\n-\t      dump_decl (pp, DECL_CONTEXT (t), flags);\n+\t      if (TYPE_P (ctx))\n+\t\tdump_type (pp, ctx, flags);\n+\t      else\n+\t\tdump_decl (pp, ctx, flags);\n \t      pp_cxx_colon_colon (pp);\n \t    }\n \t  dump_decl (pp, DECL_NAME (t), flags);"}, {"sha": "8aa4f3e67ad332b0f159dfa706f8b2dd4915d1ff", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -2387,7 +2387,8 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n       || sfk == sfk_copy_assignment)\n     check_for_override (fn, type);\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n-  add_method (type, fn, false);\n+  bool added = add_method (type, fn, false);\n+  gcc_assert (added);\n   /* Add it to TYPE_METHODS.  */\n   if (sfk == sfk_destructor\n       && DECL_VIRTUAL_P (fn))"}, {"sha": "c89dc438d5d6a9ffc01ed6ab6bcc207f3d8574bc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -6028,8 +6028,8 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t  if (is_overloaded_fn (tid))\n \t\t    {\n \t\t      tree fns = get_fns (tid);\n-\t\t      if (!OVL_CHAIN (fns))\n-\t\t\ttmpl = OVL_CURRENT (fns);\n+\t\t      if (OVL_SINGLE_P (fns))\n+\t\t\ttmpl = OVL_FIRST (fns);\n \t\t      error_at (token->location, \"function template-id %qD \"\n \t\t\t\t\"in nested-name-specifier\", tid);\n \t\t    }\n@@ -15639,7 +15639,6 @@ cp_parser_template_name (cp_parser* parser,\n {\n   tree identifier;\n   tree decl;\n-  tree fns;\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n   /* If the next token is `operator', then we have either an\n@@ -15765,20 +15764,19 @@ cp_parser_template_name (cp_parser* parser,\n     }\n   else\n     {\n-      tree fn = NULL_TREE;\n-\n       /* The standard does not explicitly indicate whether a name that\n \t names a set of overloaded declarations, some of which are\n \t templates, is a template-name.  However, such a name should\n \t be a template-name; otherwise, there is no way to form a\n \t template-id for the overloaded templates.  */\n-      fns = BASELINK_P (decl) ? BASELINK_FUNCTIONS (decl) : decl;\n-      if (TREE_CODE (fns) == OVERLOAD)\n-\tfor (fn = fns; fn; fn = OVL_NEXT (fn))\n-\t  if (TREE_CODE (OVL_CURRENT (fn)) == TEMPLATE_DECL)\n-\t    break;\n+      bool found = false;\n+\n+      for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));\n+\t   !found && iter; ++iter)\n+\tif (TREE_CODE (*iter) == TEMPLATE_DECL)\n+\t  found = true;\n \n-      if (!fn)\n+      if (!found)\n \t{\n \t  /* The name does not name a template.  */\n \t  cp_parser_error (parser, \"expected template-name\");"}, {"sha": "367e58d336871d64b34f97f68f9bebfd218f5204", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -648,8 +648,8 @@ begin_template_parm_list (void)\n \t template <class T> struct S2 {};\n        };\n \n-     pushtag contains special code to call pushdecl_with_scope on the\n-     TEMPLATE_DECL for S2.  */\n+     pushtag contains special code to insert the TEMPLATE_DECL for S2\n+     at the right scope.  */\n   begin_scope (sk_template_parms, NULL);\n   ++processing_template_decl;\n   ++processing_template_parmlist;\n@@ -10592,7 +10592,7 @@ instantiate_class_template_1 (tree type)\n \t\t  --processing_template_decl;\n \t\t}\n \t      else if (!CLASSTYPE_USE_TEMPLATE (friend_type)\n-\t\t       && hidden_name_p (TYPE_NAME (friend_type)))\n+\t\t       && TYPE_HIDDEN_P (friend_type))\n \t\t{\n \t\t  /* friend class C;\n "}, {"sha": "8490c817f81c2736d03410ecc2114169dde3ceb9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2f4050aacf448f1e63a844845a1d0e7cde59ca/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6f2f4050aacf448f1e63a844845a1d0e7cde59ca", "patch": "@@ -2230,7 +2230,11 @@ ovl_iterator::remove_node (tree overload, tree node)\n      singleton overload (and consequently maybe setting its type),\n      because all uses of this function will be followed by inserting a\n      new node that must follow the place we've cut this out from.  */\n-  *slot = OVL_CHAIN (node);\n+  if (TREE_CODE (node) != OVERLOAD)\n+    /* Cloned inherited ctors don't mark themselves as via_using.  */\n+    *slot = NULL_TREE;\n+  else\n+    *slot = OVL_CHAIN (node);\n \n   return overload;\n }\n@@ -2362,9 +2366,12 @@ ovl_scope (tree ovl)\n   if (TREE_CODE (ovl) == TEMPLATE_ID_EXPR)\n     ovl = TREE_OPERAND (ovl, 0);\n   /* Skip using-declarations.  */\n-  while (TREE_CODE (ovl) == OVERLOAD && OVL_USING_P (ovl) && OVL_CHAIN (ovl))\n-    ovl = OVL_CHAIN (ovl);\n-  return CP_DECL_CONTEXT (OVL_CURRENT (ovl));\n+  lkp_iterator iter (ovl);\n+  do\n+    ovl = *iter;\n+  while (iter.using_p () && ++iter);\n+\n+  return CP_DECL_CONTEXT (ovl);\n }\n \f\n #define PRINT_RING_SIZE 4"}]}