{"sha": "852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyZTRiZDIxZmQ5NmE4ZjZhNDU1ZWVlZGRkNzNkOWU5ZGIzOWU5OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-05T17:57:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-05T17:57:09Z"}, "message": "invoke.texi (-flto-partition, [...]): Document.\n\n\n\t* doc/invoke.texi (-flto-partition, lto-partitions, lto-minpartition):\n\tDocument.\n\t* opts.c (decode_options): Handle lto partitions.\n\t* common.opt (flto-partition=1to1, flto-partition=balanced): New.\n\t* params.def (PARAM_LTO_PARTITIONS, MIN_PARTITION_SIZE): New.\n\n\t* lto.c:  Include params.h.\n\t(add_cgraph_node_to_partition, add_varpool_node_to_partition): Do\n\trefcounting in aux field.\n\t(undo_partition, partition_cgraph_node_p, partition_varpool_node_p):\n\tNew functions.\n\t(lto_1_to_1_map): Simplify.\n\t(lto_balanced_map): New function.\n\t(do_whole_program_analysis): Chose proper partitioning alg.\n\t* Make-lang.in (lto.o): Add dependency on params.h\n\nFrom-SVN: r164995", "tree": {"sha": "39fe2253162e98252ee98f361dabaf26193a3d46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39fe2253162e98252ee98f361dabaf26193a3d46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/comments", "author": null, "committer": null, "parents": [{"sha": "5806d9ac5dc72814e806e61773077a263a6fc728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5806d9ac5dc72814e806e61773077a263a6fc728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5806d9ac5dc72814e806e61773077a263a6fc728"}], "stats": {"total": 471, "additions": 438, "deletions": 33}, "files": [{"sha": "de2ab3b421a93bb81e06c6246d2564a107e4dad3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -1,4 +1,12 @@\n-2010-09-29  Jan Hubicka  <jh@suse.cz>\n+2010-10-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* doc/invoke.texi (-flto-partition, lto-partitions, lto-minpartition):\n+\tDocument.\n+\t* opts.c (decode_options): Handle lto partitions.\n+\t* common.opt (flto-partition=1to1, flto-partition=balanced): New.\n+\t* params.def (PARAM_LTO_PARTITIONS, MIN_PARTITION_SIZE): New.\n+\n+2010-10-05  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (assemble_function): Output thunks and aliases before\n \tthe function itself."}, {"sha": "4bb648d44773879e06d7f2a81202ec597f9b0f50", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -1049,6 +1049,14 @@ flto\n Common Var(flag_lto)\n Enable link-time optimization.\n \n+flto-partition=1to1\n+Common Var(flag_lto_partition_1to1)\n+Partition functions and vars at linktime based on object files they originate from\n+\n+flto-partition=balanced\n+Common Var(flag_lto_partition_balanced)\n+Partition functions and vars at linktime into approximately same sized buckets\n+\n ; The initial value of -1 comes from Z_DEFAULT_COMPRESSION in zlib.h.\n flto-compression-level=\n Common Joined RejectNegative UInteger Var(flag_lto_compression_level) Init(-1)"}, {"sha": "12866435d24b8d2ce619fb7b49f4fcb4aa0042a6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -354,10 +354,10 @@ Objective-C and Objective-C++ Dialects}.\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -floop-block -floop-flatten -floop-interchange -floop-strip-mine @gol\n--floop-parallelize-all -flto -flto-compression-level -flto-report @gol\n--fltrans -fltrans-output-list -fmerge-all-constants -fmerge-constants @gol\n--fmodulo-sched -fmodulo-sched-allow-regmoves -fmove-loop-invariants @gol\n--fmudflap -fmudflapir -fmudflapth -fno-branch-count-reg @gol\n+-floop-parallelize-all -flto -flto-compression-level -flto-partition=@var{alg} @gol\n+-flto-report -fltrans -fltrans-output-list -fmerge-all-constants @gol\n+-fmerge-constants -fmodulo-sched -fmodulo-sched-allow-regmoves @gol\n+-fmove-loop-invariants fmudflap -fmudflapir -fmudflapth -fno-branch-count-reg @gol\n -fno-default-inline @gol\n -fno-defer-pop -fno-function-cse -fno-guess-branch-probability @gol\n -fno-inline -fno-math-errno -fno-peephole -fno-peephole2 @gol\n@@ -7596,6 +7596,13 @@ GNU make.\n \n Disabled by default.\n \n+@item -flto-partition=@var{alg}\n+@opindex flto-partition\n+Specify partitioning algorithm used by @option{-fwhopr} mode.  The value is\n+either @code{1to1} to specify partitioning corresponding to source files\n+or @code{balanced} to specify partitioning into, if possible, equally sized\n+chunks.  The default value is @code{balanced}.\n+\n @item -fwpa\n @opindex fwpa\n This is an internal option used by GCC when compiling with\n@@ -8789,6 +8796,16 @@ parameter in order to perform devirtualization.\n @option{devirt-type-list-size} is the maximum number of types it\n stores per a single formal parameter of a function.\n \n+@item lto-partitions\n+Specify desired nuber of partitions produced during WHOPR copmilation.\n+Number of partitions should exceed number of CPUs used for compilatoin.\n+Default value is 32.\n+\n+@item lto-minpartition\n+Size of minimal paritition for WHOPR (in estimated instructions).\n+This prevents expenses of splitting very small programs into too many\n+partitions.\n+\n @end table\n @end table\n "}, {"sha": "29b29cca553225518d517dfd73ba8852d3631cc2", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -1,3 +1,15 @@\n+2010-10-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c:  Include params.h.\n+\t(add_cgraph_node_to_partition, add_varpool_node_to_partition): Do\n+\trefcounting in aux field.\n+\t(undo_partition, partition_cgraph_node_p, partition_varpool_node_p):\n+\tNew functions.\n+\t(lto_1_to_1_map): Simplify.\n+\t(lto_balanced_map): New function.\n+\t(do_whole_program_analysis): Chose proper partitioning alg.\n+\t* Make-lang.in (lto.o): Add dependency on params.h\n+\n 2010-10-04  Andi Kleen <ak@linux.intel.com>\n \n \t* Make-lang.in (lto1): Add + to build rule."}, {"sha": "216523152691cae68f40b16ed71845b54a71b5bc", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -85,7 +85,7 @@ lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h opts.h \\\n \t$(CGRAPH_H) $(GGC_H) tree-ssa-operands.h $(TREE_PASS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(TIMEVAR_H) $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\\n-\t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h\n+\t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H)\n lto/lto-elf.o: lto/lto-elf.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n \ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H)\n lto/lto-coff.o: lto/lto-coff.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\"}, {"sha": "6623704fa535d217da42de4a51f8a52ca3fa4ed1", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 369, "deletions": 27, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-tree.h\"\n #include \"lto-streamer.h\"\n #include \"splay-tree.h\"\n+#include \"params.h\"\n \n /* This needs to be included after config.h.  Otherwise, _GNU_SOURCE will not\n    be defined in time to set __USE_GNU in the system headers, and strsignal\n@@ -759,12 +760,8 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n   part->insns += node->local.inline_summary.self_size;\n \n   if (node->aux)\n-    {\n-      gcc_assert (node->aux != part);\n-      node->in_other_partition = 1;\n-    }\n-  else\n-    node->aux = part;\n+    node->in_other_partition = 1;\n+  node->aux = (void *)((size_t)node->aux + 1);\n \n   cgraph_node_set_add (part->cgraph_set, node);\n \n@@ -788,12 +785,8 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n   varpool_node_set_add (part->varpool_set, vnode);\n \n   if (vnode->aux)\n-    {\n-      gcc_assert (vnode->aux != part);\n-      vnode->in_other_partition = 1;\n-    }\n-  else\n-    vnode->aux = part;\n+    vnode->in_other_partition = 1;\n+  vnode->aux = (void *)((size_t)vnode->aux + 1);\n \n   add_references_to_partition (part, &vnode->ref_list);\n \n@@ -802,6 +795,70 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n     add_varpool_node_to_partition (part, vnode->same_comdat_group);\n }\n \n+/* Undo all additions until number of cgraph nodes in PARITION is N_CGRAPH_NODES\n+   and number of varpool nodes is N_VARPOOL_NODES.  */\n+\n+static void\n+undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n+\t\tunsigned int n_varpool_nodes)\n+{\n+  while (VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes) >\n+\t n_cgraph_nodes)\n+    {\n+      struct cgraph_node *node = VEC_index (cgraph_node_ptr,\n+\t\t\t\t\t    partition->cgraph_set->nodes,\n+\t\t\t\t\t    n_cgraph_nodes);\n+      partition->insns -= node->local.inline_summary.self_size;\n+      cgraph_node_set_remove (partition->cgraph_set, node);\n+      node->aux = (void *)((size_t)node->aux - 1);\n+    }\n+  while (VEC_length (varpool_node_ptr, partition->varpool_set->nodes) >\n+\t n_varpool_nodes)\n+    {\n+      struct varpool_node *node = VEC_index (varpool_node_ptr,\n+\t\t\t\t\t     partition->varpool_set->nodes,\n+\t\t\t\t\t     n_varpool_nodes);\n+      varpool_node_set_remove (partition->varpool_set, node);\n+      node->aux = (void *)((size_t)node->aux - 1);\n+    }\n+}\n+\n+/* Return true if NODE should be partitioned.\n+   This means that partitioning algorithm should put NODE into one of partitions.\n+   This apply to most functions with bodies.  Functions that are not partitions\n+   are put into every unit needing them.  This is the case of i.e. COMDATs.  */\n+\n+static bool\n+partition_cgraph_node_p (struct cgraph_node *node)\n+{\n+  /* We will get proper partition based on function they are inlined to.  */\n+  if (node->global.inlined_to)\n+    return false;\n+  /* Nodes without a body do not need partitioning.  */\n+  if (!node->analyzed)\n+    return false;\n+  /* Extern inlines and comdat are always only in partitions they are needed.  */\n+  if (DECL_EXTERNAL (node->decl)\n+      || DECL_COMDAT (node->decl))\n+    return false;\n+  return true;\n+}\n+\n+/* Return true if VNODE should be partitioned. \n+   This means that partitioning algorithm should put VNODE into one of partitions. */\n+\n+static bool\n+partition_varpool_node_p (struct varpool_node *vnode)\n+{\n+  if (vnode->alias || !vnode->needed)\n+    return false;\n+  /* Constant pool and comdat are always only in partitions they are needed.  */\n+  if (DECL_IN_CONSTANT_POOL (vnode->decl)\n+      || DECL_COMDAT (vnode->decl))\n+    return false;\n+  return true;\n+}\n+\n /* Group cgrah nodes by input files.  This is used mainly for testing\n    right now.  */\n \n@@ -822,15 +879,7 @@ lto_1_to_1_map (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      /* We will get proper partition based on function they are inlined to.  */\n-      if (node->global.inlined_to)\n-\tcontinue;\n-      /* Nodes without a body do not need partitioning.  */\n-      if (!node->analyzed)\n-\tcontinue;\n-      /* Extern inlines and comdat are always only in partitions they are needed.  */\n-      if (DECL_EXTERNAL (node->decl)\n-\t  || DECL_COMDAT (node->decl))\n+      if (!partition_cgraph_node_p (node))\n \tcontinue;\n \n       file_data = node->local.lto_file_data;\n@@ -865,11 +914,7 @@ lto_1_to_1_map (void)\n \n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n-      if (vnode->alias || !vnode->needed)\n-\tcontinue;\n-      /* Constant pool and comdat are always only in partitions they are needed.  */\n-      if (DECL_IN_CONSTANT_POOL (vnode->decl)\n-\t  || DECL_COMDAT (vnode->decl))\n+      if (!partition_varpool_node_p (vnode))\n \tcontinue;\n       file_data = vnode->lto_file_data;\n       slot = pointer_map_contains (pmap, file_data);\n@@ -903,6 +948,300 @@ lto_1_to_1_map (void)\n \t\t\t\t\t\t ltrans_partitions);\n }\n \n+\n+/* Group cgraph nodes in qually sized partitions.\n+\n+   The algorithm deciding paritions are simple: nodes are taken in predefined\n+   order.  The order correspond to order we wish to have functions in final\n+   output.  In future this will be given by function reordering pass, but at\n+   the moment we use topological order that serve a good approximation.\n+\n+   The goal is to partition this linear order into intervals (partitions) such\n+   that all partitions have approximately the same size and that the number of\n+   callgraph or IPA reference edgess crossing boundaries is minimal.\n+\n+   This is a lot faster (O(n) in size of callgraph) than algorithms doing\n+   priority based graph clustering that are generally O(n^2) and since WHOPR\n+   is designed to make things go well across partitions, it leads to good results.\n+\n+   We compute the expected size of partition as\n+   max (total_size / lto_partitions, min_partition_size).\n+   We use dynamic expected size of partition, so small programs\n+   are partitioning into enough partitions to allow use of multiple CPUs while\n+   large programs are not partitioned too much. Creating too many partition\n+   increase streaming overhead significandly.\n+\n+   In the future we would like to bound maximal size of partition to avoid\n+   ltrans stage consuming too much memory.  At the moment however WPA stage is\n+   most memory intensive phase at large benchmark since too many types and\n+   declarations are read into memory.\n+\n+   The function implement simple greedy algorithm.  Nodes are begin added into\n+   current partition until 3/4th of expected partition size is reached.\n+   After this threshold we keep track of boundary size (number of edges going to\n+   other partitions) and continue adding functions until the current partition\n+   grows into a double of expected partition size.  Then the process is undone\n+   till the point when minimal ration of boundary size and in partition calls\n+   was reached.  */\n+\n+static void\n+lto_balanced_map (void)\n+{\n+  int n_nodes = 0;\n+  struct cgraph_node **postorder =\n+    XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n+  int i, postorder_len;\n+  struct cgraph_node *node;\n+  int total_size = 0;\n+  int partition_size;\n+  ltrans_partition partition;\n+  unsigned int last_visited_cgraph_node = 0, last_visited_varpool_node = 0;\n+  struct varpool_node *vnode;\n+  int cost = 0, internal = 0;\n+  int best_n_nodes = 0, best_n_varpool_nodes = 0, best_i = 0, best_cost =\n+    INT_MAX, best_internal = 0;\n+  int npartitions;\n+\n+  /* Until we have better ordering facility, use toplogical order.\n+     Include only nodes we will partition and compute estimate of program\n+     size.  Note that since nodes that are not partitioned might be put into\n+     multiple partitions, this is just an estimate of real size.  This is why\n+     we keep partition_size updated after every partition is finalized.  */\n+  postorder_len = cgraph_postorder (postorder);\n+  for (i = 0; i < postorder_len; i++)\n+    {\n+      node = postorder[i];\n+      if (partition_cgraph_node_p (node))\n+\t{\n+\t  order[n_nodes++] = node;\n+          total_size += node->local.inline_summary.self_size;\n+\t}\n+    }\n+  free (postorder);\n+\n+  /* Compute partition size and create the first partition.  */\n+  partition_size = total_size / PARAM_VALUE (PARAM_LTO_PARTITIONS);\n+  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n+    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n+  npartitions = 1;\n+  partition = new_partition (\"\");\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \"Total unit size: %i, partition size: %i\\n\",\n+\t     total_size, partition_size);\n+\n+  for (i = 0; i < n_nodes; i++)\n+    {\n+      add_cgraph_node_to_partition (partition, order[i]);\n+\n+      /* Once we added a new node to the partition, we also want to add\n+         all referenced variables unless they was already added into some\n+         earlier partition.\n+\t add_cgraph_node_to_partition adds possibly multiple nodes and\n+\t variables that are needed to satisfy needs of ORDER[i].\n+         We remember last visited cgraph and varpool node from last iteration\n+         of outer loop that allows us to process every new addition. \n+\n+\t At the same time we compute size of the boundary into COST.  Every\n+         callgraph or IPA reference edge leaving the partition contributes into\n+         COST.  Every edge inside partition was earlier computed as one leaving\n+\t it and thus we need to subtract it from COST.  */\n+      while (last_visited_cgraph_node <\n+\t     VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes)\n+\t     || last_visited_varpool_node < VEC_length (varpool_node_ptr,\n+\t\t\t\t\t\t\tpartition->varpool_set->\n+\t\t\t\t\t\t\tnodes))\n+\t{\n+\t  struct ipa_ref_list *refs;\n+\t  int j;\n+\t  struct ipa_ref *ref;\n+\t  bool cgraph_p = false;\n+\n+\t  if (last_visited_cgraph_node <\n+\t      VEC_length (cgraph_node_ptr, partition->cgraph_set->nodes))\n+\t    {\n+\t      struct cgraph_edge *edge;\n+\n+\t      cgraph_p = true;\n+\t      node = VEC_index (cgraph_node_ptr, partition->cgraph_set->nodes,\n+\t\t\t\tlast_visited_cgraph_node);\n+\t      refs = &node->ref_list;\n+\n+\t      total_size -= node->local.inline_summary.self_size;\n+\t      last_visited_cgraph_node++;\n+\n+\t      gcc_assert (node->analyzed);\n+\n+\t      /* Compute boundary cost of callgrpah edges.  */\n+\t      for (edge = node->callees; edge; edge = edge->next_callee)\n+\t\tif (edge->callee->analyzed)\n+\t\t  {\n+\t\t    int edge_cost = edge->frequency;\n+\t\t    cgraph_node_set_iterator csi;\n+\n+\t\t    if (!edge_cost)\n+\t\t      edge_cost = 1;\n+\t\t    gcc_assert (edge_cost > 0);\n+\t\t    csi = cgraph_node_set_find (partition->cgraph_set, edge->callee);\n+\t\t    if (!csi_end_p (csi)\n+\t\t        && csi.index < last_visited_cgraph_node - 1)\n+\t\t      cost -= edge_cost, internal+= edge_cost;\n+\t\t    else\n+\t\t      cost += edge_cost;\n+\t\t  }\n+\t      for (edge = node->callers; edge; edge = edge->next_caller)\n+\t\t{\n+\t\t  int edge_cost = edge->frequency;\n+\t\t  cgraph_node_set_iterator csi;\n+\n+\t\t  gcc_assert (edge->caller->analyzed);\n+\t\t  if (!edge_cost)\n+\t\t    edge_cost = 1;\n+\t\t  gcc_assert (edge_cost > 0);\n+\t\t  csi = cgraph_node_set_find (partition->cgraph_set, edge->caller);\n+\t\t  if (!csi_end_p (csi)\n+\t\t      && csi.index < last_visited_cgraph_node)\n+\t\t    cost -= edge_cost;\n+\t\t  else\n+\t\t    cost += edge_cost;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      refs =\n+\t\t&VEC_index (varpool_node_ptr, partition->varpool_set->nodes,\n+\t\t\t    last_visited_varpool_node)->ref_list;\n+\t      last_visited_varpool_node++;\n+\t    }\n+\n+\t  /* Compute boundary cost of IPA REF edges and at the same time look into\n+\t     variables referenced from current partition and try to add them.  */\n+\t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n+\t    if (ref->refered_type == IPA_REF_VARPOOL)\n+\t      {\n+\t\tvarpool_node_set_iterator vsi;\n+\n+\t\tvnode = ipa_ref_varpool_node (ref);\n+\t\tif (!vnode->finalized)\n+\t\t  continue;\n+\t\tif (!vnode->aux && partition_varpool_node_p (vnode))\n+\t\t  add_varpool_node_to_partition (partition, vnode);\n+\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n+\t\tif (!vsi_end_p (vsi)\n+\t\t    && vsi.index < last_visited_varpool_node - !cgraph_p)\n+\t\t  cost--, internal++;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcgraph_node_set_iterator csi;\n+\n+\t\tnode = ipa_ref_node (ref);\n+\t\tif (!node->analyzed)\n+\t\t  continue;\n+\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n+\t\tif (!csi_end_p (csi)\n+\t\t    && csi.index < last_visited_cgraph_node - cgraph_p)\n+\t\t  cost--, internal++;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t  for (j = 0; ipa_ref_list_refering_iterate (refs, j, ref); j++)\n+\t    if (ref->refering_type == IPA_REF_VARPOOL)\n+\t      {\n+\t\tvarpool_node_set_iterator vsi;\n+\n+\t\tvnode = ipa_ref_refering_varpool_node (ref);\n+\t\tgcc_assert (vnode->finalized);\n+\t\tif (!vnode->aux && partition_varpool_node_p (vnode))\n+\t\t  add_varpool_node_to_partition (partition, vnode);\n+\t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n+\t\tif (!vsi_end_p (vsi)\n+\t\t    && vsi.index < last_visited_varpool_node)\n+\t\t  cost--;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcgraph_node_set_iterator csi;\n+\n+\t\tnode = ipa_ref_refering_node (ref);\n+\t\tgcc_assert (node->analyzed);\n+\t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n+\t\tif (!csi_end_p (csi)\n+\t\t    && csi.index < last_visited_cgraph_node)\n+\t\t  cost--;\n+\t\telse\n+\t\t  cost++;\n+\t      }\n+\t}\n+\n+      /* If the partition is large enough, start looking for smallest boundary cost.  */\n+      if (partition->insns < partition_size * 3 / 4\n+\t  || best_cost == INT_MAX\n+\t  || ((!cost \n+\t       || (best_internal * (HOST_WIDE_INT) cost\n+\t\t   > (internal * (HOST_WIDE_INT)best_cost)))\n+  \t      && partition->insns < partition_size * 5 / 4))\n+\t{\n+\t  best_cost = cost;\n+\t  best_internal = internal;\n+\t  best_i = i;\n+\t  best_n_nodes = VEC_length (cgraph_node_ptr,\n+\t\t\t\t     partition->cgraph_set->nodes);\n+\t  best_n_varpool_nodes = VEC_length (varpool_node_ptr,\n+\t\t\t\t\t     partition->varpool_set->nodes);\n+\t}\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \"Step %i: added %s, size %i, cost %i/%i best %i/%i, step %i\\n\", i,\n+\t\t cgraph_node_name (order[i]), partition->insns, cost, internal,\n+\t\t best_cost, best_internal, best_i);\n+      /* Partition is too large, unwind into step when best cost was reached and\n+\t start new partition.  */\n+      if (partition->insns > 2 * partition_size)\n+\t{\n+\t  if (best_i != i)\n+\t    {\n+\t      if (cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file, \"Unwinding %i insertions to step %i\\n\",\n+\t\t\t i - best_i, best_i);\n+\t      undo_partition (partition, best_n_nodes, best_n_varpool_nodes);\n+\t    }\n+\t  i = best_i;\n+\t  partition = new_partition (\"\");\n+\t  last_visited_cgraph_node = 0;\n+\t  last_visited_varpool_node = 0;\n+\t  cost = 0;\n+\n+\t  if (cgraph_dump_file)\n+\t    fprintf (cgraph_dump_file, \"New partition\\n\");\n+\t  best_n_nodes = 0;\n+\t  best_n_varpool_nodes = 0;\n+\t  best_cost = INT_MAX;\n+\n+\t  /* Since the size of partitions is just approximate, update the size after\n+\t     we finished current one.  */\n+\t  if (npartitions < PARAM_VALUE (PARAM_LTO_PARTITIONS))\n+\t    partition_size = total_size\n+\t      / (PARAM_VALUE (PARAM_LTO_PARTITIONS) - npartitions);\n+\t  else\n+\t    partition_size = INT_MAX;\n+\n+\t  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n+\t    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n+\t  npartitions ++;\n+\t}\n+    }\n+\n+  /* Varables that are not reachable from the code go into last partition.  */\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    if (partition_varpool_node_p (vnode) && !vnode->aux)\n+      add_varpool_node_to_partition (partition, vnode);\n+  free (order);\n+}\n+\n /* Promote variable VNODE to be static.  */\n \n static bool\n@@ -1990,7 +2329,10 @@ do_whole_program_analysis (void)\n   /* We are about to launch the final LTRANS phase, stop the WPA timer.  */\n   timevar_pop (TV_WHOPR_WPA);\n \n-  lto_1_to_1_map ();\n+  if (flag_lto_partition_1to1)\n+    lto_1_to_1_map ();\n+  else\n+    lto_balanced_map ();\n \n   if (!quiet_flag)\n     {"}, {"sha": "03098b5377202773337914ea6ff69ace580f1706", "filename": "gcc/opts.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -1081,6 +1081,13 @@ decode_options (unsigned int argc, const char **argv,\n       error (\"LTO support has not been enabled in this configuration\");\n #endif\n     }\n+  if (flag_lto_partition_balanced || flag_lto_partition_1to1)\n+    {\n+      if (flag_lto_partition_balanced && flag_lto_partition_1to1)\n+\terror (\"Only one -flto-partitoin value can be specified\");\n+      if (!flag_whopr)\n+\terror (\"-flto-partitoin has effect only with -fwhopr\");\n+    }\n \n   /* Reconcile -flto and -fwhopr.  Set additional flags as appropriate and\n      check option consistency.  */"}, {"sha": "49a6185d48b53103737345ebbd2ee1c5b051121e", "filename": "gcc/params.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852e4bd21fd96a8f6a455eeeddd73d9e9db39e99/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=852e4bd21fd96a8f6a455eeeddd73d9e9db39e99", "patch": "@@ -838,6 +838,17 @@ DEFPARAM (PARAM_DEVIRT_TYPE_LIST_SIZE,\n \t  \"devirtualization\",\n \t  8, 0, 0)\n \n+/* WHOPR partitioning configuration.  */\n+\n+DEFPARAM (PARAM_LTO_PARTITIONS,\n+\t  \"lto-partitions\",\n+\t  \"Number of paritions program should be split to\",\n+\t  32, 0, 0)\n+\n+DEFPARAM (MIN_PARTITION_SIZE,\n+\t  \"lto-min-partition\",\n+\t  \"Size of minimal paritition for WHOPR (in estimated instructions)\",\n+\t  1000, 0, 0)\n /*\n Local variables:\n mode:c"}]}