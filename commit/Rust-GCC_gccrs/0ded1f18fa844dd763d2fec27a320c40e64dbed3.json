{"sha": "0ded1f18fa844dd763d2fec27a320c40e64dbed3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlZDFmMThmYTg0NGRkNzYzZDJmZWMyN2EzMjBjNDBlNjRkYmVkMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-01-04T11:56:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-01-04T11:56:18Z"}, "message": "* extend.texi (Bound member functions): Document.\n\nFrom-SVN: r24483", "tree": {"sha": "16b990cc0b6153e74f5107fa291e71cfedf48cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16b990cc0b6153e74f5107fa291e71cfedf48cb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ded1f18fa844dd763d2fec27a320c40e64dbed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ded1f18fa844dd763d2fec27a320c40e64dbed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ded1f18fa844dd763d2fec27a320c40e64dbed3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ded1f18fa844dd763d2fec27a320c40e64dbed3/comments", "author": null, "committer": null, "parents": [{"sha": "02275c91e6770dee4d1e354a050fef86d901dcc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02275c91e6770dee4d1e354a050fef86d901dcc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02275c91e6770dee4d1e354a050fef86d901dcc9"}], "stats": {"total": 43, "additions": 42, "deletions": 1}, "files": [{"sha": "45306aaa3c228c2705a71c58b60fbfdbf8033127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ded1f18fa844dd763d2fec27a320c40e64dbed3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ded1f18fa844dd763d2fec27a320c40e64dbed3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ded1f18fa844dd763d2fec27a320c40e64dbed3", "patch": "@@ -1,3 +1,7 @@\n+Mon Jan  4 11:55:51 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* extend.texi (Bound member functions): Document.\n+\n Mon Jan  4 11:01:48 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mips-tdump.c (st_to_string, sc_to_string, glevel_to_string,"}, {"sha": "88f4588659f5f609f643bfa3a97f57545daa6bc4", "filename": "gcc/extend.texi", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ded1f18fa844dd763d2fec27a320c40e64dbed3/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ded1f18fa844dd763d2fec27a320c40e64dbed3/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=0ded1f18fa844dd763d2fec27a320c40e64dbed3", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988,89,92,93,94,96 Free Software Foundation, Inc.\n+@c Copyright (C) 1988,89,92,93,94,96,99 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -3015,8 +3015,11 @@ Predefined Macros,cpp.info,The C Preprocessor}).\n                          declarations and definitions.\n * Template Instantiation:: Methods for ensuring that exactly one copy of\n                          each needed template instantiation is emitted.\n+* Bound member functions:: You can extract a function pointer to the\n+                        method denoted by a @samp{->*} or @samp{.*} expression.\n * C++ Signatures::\tYou can specify abstract types to get subtype\n \t\t\t polymorphism independent from inheritance.\n+                        \n @end menu\n \n @node Naming Results\n@@ -3476,6 +3479,40 @@ be the same in all translation units, or things are likely to break.\n more discussion of these pragmas.\n @end enumerate\n \n+@node Bound member functions\n+@section Extracting the function pointer from a bound pointer to member function\n+\n+@cindex pmf\n+@cindex pointer to member function\n+@cindex bound pointer to member function\n+\n+In C++, pointer to member functions (PMFs) are implemented using a wide\n+pointer of sorts to handle all the possible call mechanisms; the PMF\n+needs to store information about how to adjust the @samp{this} pointer,\n+and if the function pointed to is virtual, where to find the vtable, and\n+where in the vtable to look for the member function.  If you are using\n+PMFs in an inner loop, you should really reconsider that decision.  If\n+that is not an option, you can extract the pointer to the function that\n+would be called for a given object/PMF pair and call it directly inside\n+the inner loop, to save a bit of time.\n+\n+Note that you will still be paying the penalty for the call through a\n+function pointer; on most modern architectures, such a call defeats the\n+branch prediction features of the CPU.  This is also true of normal\n+virtual function calls.\n+\n+The syntax for this extension is\n+\n+@example\n+extern A a;\n+extern int (A::*fp)();\n+typedef int (*fptr)(A *);\n+\n+fptr p = (fptr)(a.*fp);\n+@end example\n+\n+You must specify @samp{-Wno-pmf-conversions} to use this extension.\n+\n @node C++ Signatures\n @section Type Abstraction using Signatures\n "}]}