{"sha": "27c5a1779badd02b337af5887e26b5420fbf71c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdjNWExNzc5YmFkZDAyYjMzN2FmNTg4N2UyNmI1NDIwZmJmNzFjNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-01-09T12:21:48Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2020-01-09T12:21:48Z"}, "message": "Make cgraph_edge::resolve-speculation static\n\n2020-01-09  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (cgraph_edge): Make remove, set_call_stmt, make_direct,\n\tresolve_speculation and redirect_call_stmt_to_callee static.  Change\n\treturn type of set_call_stmt to cgraph_edge *.\n\t* auto-profile.c (afdo_indirect_call): Adjust call to\n\tredirect_call_stmt_to_callee.\n\t* cgraph.c (cgraph_edge::set_call_stmt): Make return cgraph-edge *,\n\tmake the this pointer explicit, adjust self-recursive calls and the\n\tcall top make_direct.  Return the resulting edge.\n\t(cgraph_edge::remove): Make this pointer explicit.\n\t(cgraph_edge::resolve_speculation): Likewise, adjust call to remove.\n\t(cgraph_edge::make_direct): Likewise, adjust call to\n\tresolve_speculation.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise, also adjust\n\tcall to set_call_stmt.\n\t(cgraph_update_edges_for_call_stmt_node): Update call to\n\tset_call_stmt and remove.\n\t* cgraphclones.c (cgraph_node::set_call_stmt_including_clones):\n\tRenamed edge to master_edge.  Adjusted calls to set_call_stmt.\n\t(cgraph_node::create_edge_including_clones): Moved \"first\" definition\n\tof edge to the block where it was used.  Adjusted calls to\n\tset_call_stmt.\n\t(cgraph_node::remove_symbol_and_inline_clones): Adjust call to\n\tcgraph_edge::remove.\n\t* cgraphunit.c (walk_polymorphic_call_targets): Adjusted calls to\n\tmake_direct and redirect_call_stmt_to_callee.\n\t* ipa-fnsummary.c (redirect_to_unreachable): Adjust calls to\n\tresolve_speculation and make_direct.\n\t* ipa-inline-transform.c (inline_transform): Adjust call to\n\tredirect_call_stmt_to_callee.\n\t(check_speculations_1):: Adjust call to resolve_speculation.\n\t* ipa-inline.c (resolve_noninline_speculation): Adjust call to\n\tresolve-speculation.\n\t(inline_small_functions): Adjust call to resolve_speculation.\n\t(ipa_inline): Likewise.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Adjust call to\n\tmake_direct.\n\t* ipa-visibility.c (function_and_variable_visibility): Make iteration\n\tsafe with regards to edge removal, adjust calls to\n\tredirect_call_stmt_to_callee.\n\t* ipa.c (walk_polymorphic_call_targets): Adjust calls to make_direct\n\tand redirect_call_stmt_to_callee.\n\t* multiple_target.c (create_dispatcher_calls): Adjust call to\n\tredirect_call_stmt_to_callee\n\t(redirect_to_specific_clone): Likewise.\n\t* tree-cfgcleanup.c (delete_unreachable_blocks_update_callgraph):\n\tAdjust calls to cgraph_edge::remove.\n\t* tree-inline.c (copy_bb): Adjust call to set_call_stmt.\n\t(redirect_all_calls): Adjust call to redirect_call_stmt_to_callee.\n\t(expand_call_inline): Adjust call to cgraph_edge::remove.\n\nFrom-SVN: r280043", "tree": {"sha": "1ad98f5766268743f658c44572a4cab09919fef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ad98f5766268743f658c44572a4cab09919fef9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27c5a1779badd02b337af5887e26b5420fbf71c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c5a1779badd02b337af5887e26b5420fbf71c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c5a1779badd02b337af5887e26b5420fbf71c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c5a1779badd02b337af5887e26b5420fbf71c7/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "87f9579a4f9934013b54f115740b7aaa247db58d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f9579a4f9934013b54f115740b7aaa247db58d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f9579a4f9934013b54f115740b7aaa247db58d"}], "stats": {"total": 292, "additions": 176, "deletions": 116}, "files": [{"sha": "d5265db63eea7543e0097d52d0adf8cbd7a28139", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -1,3 +1,55 @@\n+2020-01-09  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.h (cgraph_edge): Make remove, set_call_stmt, make_direct,\n+\tresolve_speculation and redirect_call_stmt_to_callee static.  Change\n+\treturn type of set_call_stmt to cgraph_edge *.\n+\t* auto-profile.c (afdo_indirect_call): Adjust call to\n+\tredirect_call_stmt_to_callee.\n+\t* cgraph.c (cgraph_edge::set_call_stmt): Make return cgraph-edge *,\n+\tmake the this pointer explicit, adjust self-recursive calls and the\n+\tcall top make_direct.  Return the resulting edge.\n+\t(cgraph_edge::remove): Make this pointer explicit.\n+\t(cgraph_edge::resolve_speculation): Likewise, adjust call to remove.\n+\t(cgraph_edge::make_direct): Likewise, adjust call to\n+\tresolve_speculation.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise, also adjust\n+\tcall to set_call_stmt.\n+\t(cgraph_update_edges_for_call_stmt_node): Update call to\n+\tset_call_stmt and remove.\n+\t* cgraphclones.c (cgraph_node::set_call_stmt_including_clones):\n+\tRenamed edge to master_edge.  Adjusted calls to set_call_stmt.\n+\t(cgraph_node::create_edge_including_clones): Moved \"first\" definition\n+\tof edge to the block where it was used.  Adjusted calls to\n+\tset_call_stmt.\n+\t(cgraph_node::remove_symbol_and_inline_clones): Adjust call to\n+\tcgraph_edge::remove.\n+\t* cgraphunit.c (walk_polymorphic_call_targets): Adjusted calls to\n+\tmake_direct and redirect_call_stmt_to_callee.\n+\t* ipa-fnsummary.c (redirect_to_unreachable): Adjust calls to\n+\tresolve_speculation and make_direct.\n+\t* ipa-inline-transform.c (inline_transform): Adjust call to\n+\tredirect_call_stmt_to_callee.\n+\t(check_speculations_1):: Adjust call to resolve_speculation.\n+\t* ipa-inline.c (resolve_noninline_speculation): Adjust call to\n+\tresolve-speculation.\n+\t(inline_small_functions): Adjust call to resolve_speculation.\n+\t(ipa_inline): Likewise.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Adjust call to\n+\tmake_direct.\n+\t* ipa-visibility.c (function_and_variable_visibility): Make iteration\n+\tsafe with regards to edge removal, adjust calls to\n+\tredirect_call_stmt_to_callee.\n+\t* ipa.c (walk_polymorphic_call_targets): Adjust calls to make_direct\n+\tand redirect_call_stmt_to_callee.\n+\t* multiple_target.c (create_dispatcher_calls): Adjust call to\n+\tredirect_call_stmt_to_callee\n+\t(redirect_to_specific_clone): Likewise.\n+\t* tree-cfgcleanup.c (delete_unreachable_blocks_update_callgraph):\n+\tAdjust calls to cgraph_edge::remove.\n+\t* tree-inline.c (copy_bb): Adjust call to set_call_stmt.\n+\t(redirect_all_calls): Adjust call to redirect_call_stmt_to_callee.\n+\t(expand_call_inline): Adjust call to cgraph_edge::remove.\n+\n 2020-01-09  Martin Liska  <mliska@suse.cz>\n \n \t* params.opt: Set Optimization for"}, {"sha": "7d09887c9e189a9ade2fa0479b0fe71bf469da50", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -1055,7 +1055,7 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n   struct cgraph_edge *new_edge\n       = indirect_edge->make_speculative (direct_call,\n \t\t\t\t\t profile_count::uninitialized ());\n-  new_edge->redirect_call_stmt_to_callee ();\n+  cgraph_edge::redirect_call_stmt_to_callee (new_edge);\n   gimple_remove_histogram_value (cfun, stmt, hist);\n   inline_call (new_edge, true, NULL, NULL, false);\n }"}, {"sha": "fe3f06726d4ca74dc41fdb07040f99e081e032a1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -767,55 +767,56 @@ cgraph_node::get_edge (gimple *call_stmt)\n }\n \n \n-/* Change field call_stmt of edge to NEW_STMT.\n-   If UPDATE_SPECULATIVE and E is any component of speculative\n-   edge, then update all components.  */\n+/* Change field call_stmt of edge E to NEW_STMT.  If UPDATE_SPECULATIVE and E\n+   is any component of speculative edge, then update all components.\n+   Speculations can be resolved in the process and EDGE can be removed and\n+   deallocated.  Return the edge that now represents the call.  */\n \n-void\n-cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)\n+cgraph_edge *\n+cgraph_edge::set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n+\t\t\t    bool update_speculative)\n {\n   tree decl;\n \n   /* Speculative edges has three component, update all of them\n      when asked to.  */\n-  if (update_speculative && speculative)\n+  if (update_speculative && e->speculative)\n     {\n       cgraph_edge *direct, *indirect;\n       ipa_ref *ref;\n+      bool e_indirect = e->indirect_unknown_callee;\n \n-      speculative_call_info (direct, indirect, ref);\n-      direct->set_call_stmt (new_stmt, false);\n-      indirect->set_call_stmt (new_stmt, false);\n+      e->speculative_call_info (direct, indirect, ref);\n       ref->stmt = new_stmt;\n-      return;\n+      cgraph_edge *d2 = set_call_stmt (direct, new_stmt, false);\n+      gcc_assert (direct == d2);\n+      indirect = set_call_stmt (indirect, new_stmt, false);\n+      return e_indirect ? indirect : direct;\n     }\n \n   /* Only direct speculative edges go to call_site_hash.  */\n-  if (caller->call_site_hash\n-      && (!speculative || !indirect_unknown_callee))\n-    {\n-      caller->call_site_hash->remove_elt_with_hash\n-\t(call_stmt, cgraph_edge_hasher::hash (call_stmt));\n-    }\n-\n-  cgraph_edge *e = this;\n+  if (e->caller->call_site_hash\n+      && (!e->speculative || !e->indirect_unknown_callee))\n+    e->caller->call_site_hash->remove_elt_with_hash\n+      (e->call_stmt, cgraph_edge_hasher::hash (e->call_stmt));\n \n-  call_stmt = new_stmt;\n-  if (indirect_unknown_callee\n+  e->call_stmt = new_stmt;\n+  if (e->indirect_unknown_callee\n       && (decl = gimple_call_fndecl (new_stmt)))\n     {\n       /* Constant propagation (and possibly also inlining?) can turn an\n \t indirect call into a direct one.  */\n       cgraph_node *new_callee = cgraph_node::get (decl);\n \n       gcc_checking_assert (new_callee);\n-      e = make_direct (new_callee);\n+      e = make_direct (e, new_callee);\n     }\n \n   function *fun = DECL_STRUCT_FUNCTION (e->caller->decl);\n   e->can_throw_external = stmt_can_throw_external (fun, new_stmt);\n   if (e->caller->call_site_hash)\n     cgraph_add_edge_to_call_site_hash (e);\n+  return e;\n }\n \n /* Allocate a cgraph_edge structure and fill it with data according to the\n@@ -1011,20 +1012,20 @@ symbol_table::free_edge (cgraph_edge *e)\n /* Remove the edge in the cgraph.  */\n \n void\n-cgraph_edge::remove (void)\n+cgraph_edge::remove (cgraph_edge *edge)\n {\n   /* Call all edge removal hooks.  */\n-  symtab->call_edge_removal_hooks (this);\n+  symtab->call_edge_removal_hooks (edge);\n \n-  if (!indirect_unknown_callee)\n+  if (!edge->indirect_unknown_callee)\n     /* Remove from callers list of the callee.  */\n-    remove_callee ();\n+    edge->remove_callee ();\n \n   /* Remove from callees list of the callers.  */\n-  remove_caller ();\n+  edge->remove_caller ();\n \n   /* Put the edge onto the free list.  */\n-  symtab->free_edge (this);\n+  symtab->free_edge (edge);\n }\n \n /* Turn edge into speculative call calling N2. Update\n@@ -1135,14 +1136,15 @@ cgraph_edge::speculative_call_info (cgraph_edge *&direct,\n   gcc_assert (e && e2 && ref);\n }\n \n-/* Speculative call edge turned out to be direct call to CALLEE_DECL.\n-   Remove the speculative call sequence and return edge representing the call.\n-   It is up to caller to redirect the call as appropriate. */\n+/* Speculative call EDGE turned out to be direct call to CALLEE_DECL.  Remove\n+   the speculative call sequence and return edge representing the call, the\n+   original EDGE can be removed and deallocated.  It is up to caller to\n+   redirect the call as appropriate.  Return the edge that now represents the\n+   call.  */\n \n cgraph_edge *\n-cgraph_edge::resolve_speculation (tree callee_decl)\n+cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n {\n-  cgraph_edge *edge = this;\n   cgraph_edge *e2;\n   ipa_ref *ref;\n \n@@ -1186,7 +1188,7 @@ cgraph_edge::resolve_speculation (tree callee_decl)\n   e2->speculative = false;\n   ref->remove_reference ();\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n-    e2->remove ();\n+    remove (e2);\n   else\n     e2->callee->remove_symbol_and_inline_clones ();\n   if (edge->caller->call_site_hash)\n@@ -1195,43 +1197,42 @@ cgraph_edge::resolve_speculation (tree callee_decl)\n }\n \n /* Make an indirect edge with an unknown callee an ordinary edge leading to\n-   CALLEE.  DELTA is an integer constant that is to be added to the this\n-   pointer (first parameter) to compensate for skipping a thunk adjustment.  */\n+   CALLEE.  Speculations can be resolved in the process and EDGE can be removed\n+   and deallocated.  Return the edge that now represents the call.  */\n \n cgraph_edge *\n-cgraph_edge::make_direct (cgraph_node *callee)\n+cgraph_edge::make_direct (cgraph_edge *edge, cgraph_node *callee)\n {\n-  cgraph_edge *edge = this;\n-  gcc_assert (indirect_unknown_callee);\n+  gcc_assert (edge->indirect_unknown_callee);\n \n   /* If we are redirecting speculative call, make it non-speculative.  */\n-  if (indirect_unknown_callee && speculative)\n+  if (edge->speculative)\n     {\n-      edge = edge->resolve_speculation (callee->decl);\n+      edge = resolve_speculation (edge, callee->decl);\n \n       /* On successful speculation just return the pre existing direct edge.  */\n       if (!edge->indirect_unknown_callee)\n         return edge;\n     }\n \n-  indirect_unknown_callee = 0;\n-  ggc_free (indirect_info);\n-  indirect_info = NULL;\n+  edge->indirect_unknown_callee = 0;\n+  ggc_free (edge->indirect_info);\n+  edge->indirect_info = NULL;\n \n   /* Get the edge out of the indirect edge list. */\n-  if (prev_callee)\n-    prev_callee->next_callee = next_callee;\n-  if (next_callee)\n-    next_callee->prev_callee = prev_callee;\n-  if (!prev_callee)\n-    caller->indirect_calls = next_callee;\n+  if (edge->prev_callee)\n+    edge->prev_callee->next_callee = edge->next_callee;\n+  if (edge->next_callee)\n+    edge->next_callee->prev_callee = edge->prev_callee;\n+  if (!edge->prev_callee)\n+    edge->caller->indirect_calls = edge->next_callee;\n \n   /* Put it into the normal callee list */\n-  prev_callee = NULL;\n-  next_callee = caller->callees;\n-  if (caller->callees)\n-    caller->callees->prev_callee = edge;\n-  caller->callees = edge;\n+  edge->prev_callee = NULL;\n+  edge->next_callee = edge->caller->callees;\n+  if (edge->caller->callees)\n+    edge->caller->callees->prev_callee = edge;\n+  edge->caller->callees = edge;\n \n   /* Insert to callers list of the new callee.  */\n   edge->set_callee (callee);\n@@ -1242,13 +1243,12 @@ cgraph_edge::make_direct (cgraph_node *callee)\n }\n \n /* If necessary, change the function declaration in the call statement\n-   associated with E so that it corresponds to the edge callee.  */\n+   associated with E so that it corresponds to the edge callee.  Speculations\n+   can be resolved in the process and EDGE can be removed and deallocated.  */\n \n gimple *\n-cgraph_edge::redirect_call_stmt_to_callee (void)\n+cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n {\n-  cgraph_edge *e = this;\n-\n   tree decl = gimple_call_fndecl (e->call_stmt);\n   gcall *new_stmt;\n   gimple_stmt_iterator gsi;\n@@ -1263,7 +1263,7 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n       /* If there already is an direct call (i.e. as a result of inliner's\n \t substitution), forget about speculating.  */\n       if (decl)\n-\te = e->resolve_speculation (decl);\n+\te = resolve_speculation (e, decl);\n       else\n \t{\n \t  /* Expand speculation into GIMPLE code.  */\n@@ -1455,8 +1455,8 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t  if (new_stmt && is_gimple_call (new_stmt) && e->callee\n \t      && fndecl_built_in_p (e->callee->decl, BUILT_IN_UNREACHABLE))\n \t    {\n-              node->get_edge (old_stmt)->set_call_stmt\n-\t\t (as_a <gcall *> (new_stmt));\n+\t      cgraph_edge::set_call_stmt (node->get_edge (old_stmt),\n+\t\t\t\t\t  as_a <gcall *> (new_stmt));\n \t      return;\n \t    }\n \t  /* See if the edge is already there and has the correct callee.  It\n@@ -1470,7 +1470,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t\t  if (callee->decl == new_call\n \t\t      || callee->former_clone_of == new_call)\n \t\t    {\n-\t\t      e->set_call_stmt (as_a <gcall *> (new_stmt));\n+\t\t      cgraph_edge::set_call_stmt (e, as_a <gcall *> (new_stmt));\n \t\t      return;\n \t\t    }\n \t\t  callee = callee->clone_of;\n@@ -1482,7 +1482,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n \t     attached to edge is invalid.  */\n \t  count = e->count;\n  \t  if (e->indirect_unknown_callee || e->inline_failed)\n-\t    e->remove ();\n+\t    cgraph_edge::remove (e);\n \t  else\n \t    e->callee->remove_symbol_and_inline_clones ();\n \t}\n@@ -1502,7 +1502,8 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n     }\n   /* We only updated the call stmt; update pointer in cgraph edge..  */\n   else if (old_stmt != new_stmt)\n-    node->get_edge (old_stmt)->set_call_stmt (as_a <gcall *> (new_stmt));\n+    cgraph_edge::set_call_stmt (node->get_edge (old_stmt),\n+\t\t\t\tas_a <gcall *> (new_stmt));\n }\n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL"}, {"sha": "71cd902312e4af39fc6f89295bbae84eed9e84d5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -1736,13 +1736,15 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   friend struct cgraph_node;\n   friend class symbol_table;\n \n-  /* Remove the edge in the cgraph.  */\n-  void remove (void);\n+  /* Remove EDGE from the cgraph.  */\n+  static void remove (cgraph_edge *edge);\n \n-  /* Change field call_stmt of edge to NEW_STMT.\n-     If UPDATE_SPECULATIVE and E is any component of speculative\n-     edge, then update all components.  */\n-  void set_call_stmt (gcall *new_stmt, bool update_speculative = true);\n+  /* Change field call_stmt of edge E to NEW_STMT.  If UPDATE_SPECULATIVE and E\n+     is any component of speculative edge, then update all components.\n+     Speculations can be resolved in the process and EDGE can be removed and\n+     deallocated.  Return the edge that now represents the call.  */\n+  static cgraph_edge *set_call_stmt (cgraph_edge *e, gcall *new_stmt,\n+\t\t\t\t     bool update_speculative = true);\n \n   /* Redirect callee of the edge to N.  The function does not update underlying\n      call expression.  */\n@@ -1755,10 +1757,10 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   void redirect_callee_duplicating_thunks (cgraph_node *n);\n \n   /* Make an indirect edge with an unknown callee an ordinary edge leading to\n-     CALLEE.  DELTA is an integer constant that is to be added to the this\n-     pointer (first parameter) to compensate for skipping\n-     a thunk adjustment.  */\n-  cgraph_edge *make_direct (cgraph_node *callee);\n+     CALLEE.  Speculations can be resolved in the process and EDGE can be\n+     removed and deallocated.  Return the edge that now represents the\n+     call.  */\n+  static cgraph_edge *make_direct (cgraph_edge *edge, cgraph_node *callee);\n \n   /* Turn edge into speculative call calling N2. Update\n      the profile so the direct call is taken COUNT times\n@@ -1769,14 +1771,19 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   void speculative_call_info (cgraph_edge *&direct, cgraph_edge *&indirect,\n \t\t\t      ipa_ref *&reference);\n \n-  /* Speculative call edge turned out to be direct call to CALLEE_DECL.\n-     Remove the speculative call sequence and return edge representing the call.\n-     It is up to caller to redirect the call as appropriate. */\n-  cgraph_edge *resolve_speculation (tree callee_decl = NULL);\n+  /* Speculative call edge turned out to be direct call to CALLEE_DECL.  Remove\n+     the speculative call sequence and return edge representing the call, the\n+     original EDGE can be removed and deallocated.  It is up to caller to\n+     redirect the call as appropriate.  Return the edge that now represents the\n+     call.  */\n+  static cgraph_edge *resolve_speculation (cgraph_edge *edge,\n+\t\t\t\t\t   tree callee_decl = NULL);\n \n   /* If necessary, change the function declaration in the call statement\n-     associated with the edge so that it corresponds to the edge callee.  */\n-  gimple *redirect_call_stmt_to_callee (void);\n+     associated with edge E so that it corresponds to the edge callee.\n+     Speculations can be resolved in the process and EDGE can be removed and\n+     deallocated.  */\n+  static gimple *redirect_call_stmt_to_callee (cgraph_edge *e);\n \n   /* Create clone of edge in the node N represented\n      by CALL_EXPR the callgraph.  */"}, {"sha": "c186fb98cf56614563e04e91b1baa14654913de1", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -744,10 +744,10 @@ cgraph_node::set_call_stmt_including_clones (gimple *old_stmt,\n \t\t\t\t\t     bool update_speculative)\n {\n   cgraph_node *node;\n-  cgraph_edge *edge = get_edge (old_stmt);\n+  cgraph_edge *master_edge = get_edge (old_stmt);\n \n-  if (edge)\n-    edge->set_call_stmt (new_stmt, update_speculative);\n+  if (master_edge)\n+    cgraph_edge::set_call_stmt (master_edge, new_stmt, update_speculative);\n \n   node = clones;\n   if (node)\n@@ -756,7 +756,8 @@ cgraph_node::set_call_stmt_including_clones (gimple *old_stmt,\n \tcgraph_edge *edge = node->get_edge (old_stmt);\n \tif (edge)\n \t  {\n-\t    edge->set_call_stmt (new_stmt, update_speculative);\n+\t    edge = cgraph_edge::set_call_stmt (edge, new_stmt,\n+\t\t\t\t\t       update_speculative);\n \t    /* If UPDATE_SPECULATIVE is false, it means that we are turning\n \t       speculative call into a real code sequence.  Update the\n \t       callgraph edges.  */\n@@ -800,11 +801,10 @@ cgraph_node::create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t\t   cgraph_inline_failed_t reason)\n {\n   cgraph_node *node;\n-  cgraph_edge *edge;\n \n   if (!get_edge (stmt))\n     {\n-      edge = create_edge (callee, stmt, count);\n+      cgraph_edge *edge = create_edge (callee, stmt, count);\n       edge->inline_failed = reason;\n     }\n \n@@ -821,7 +821,7 @@ cgraph_node::create_edge_including_clones (cgraph_node *callee,\n \t     call in the clone or we are processing clones of unreachable\n \t     master where edges has been removed.  */\n \t  if (edge)\n-\t    edge->set_call_stmt (stmt);\n+\t    edge = cgraph_edge::set_call_stmt (edge, stmt);\n \t  else if (! node->get_edge (stmt))\n \t    {\n \t      edge = node->create_edge (callee, stmt, count);\n@@ -855,7 +855,7 @@ cgraph_node::remove_symbol_and_inline_clones (cgraph_node *forbidden_node)\n \n   if (this == forbidden_node)\n     {\n-      callers->remove ();\n+      cgraph_edge::remove (callers);\n       return true;\n     }\n   for (e = callees; e; e = next)"}, {"sha": "a9dd288be57396e9213687c0266a687bd307a0f8", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -1024,16 +1024,13 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t\t       target->dump_name ());\n \t    }\n \n-\t  edge->make_direct (target);\n-\t  edge->redirect_call_stmt_to_callee ();\n+\t  edge = cgraph_edge::make_direct (edge, target);\n+\t  gimple *new_call = cgraph_edge::redirect_call_stmt_to_callee (edge);\n \n \t  if (symtab->dump_file)\n \t    {\n-\t      fprintf (symtab->dump_file,\n-\t\t       \"Devirtualized as: \");\n-\t      print_gimple_stmt (symtab->dump_file,\n-\t\t\t\t edge->call_stmt, 0,\n-\t\t\t\t TDF_SLIM);\n+\t      fprintf (symtab->dump_file, \"Devirtualized as: \");\n+\t      print_gimple_stmt (symtab->dump_file, new_call, 0, TDF_SLIM);\n \t    }\n \t}\n     }"}, {"sha": "efe42641b6b357b2e3222afb9d610d1d6312e947", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -245,9 +245,9 @@ redirect_to_unreachable (struct cgraph_edge *e)\n \t\t      (builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n \n   if (e->speculative)\n-    e = e->resolve_speculation (target->decl);\n+    e = cgraph_edge::resolve_speculation (e, target->decl);\n   else if (!e->callee)\n-    e->make_direct (target);\n+    e = cgraph_edge::make_direct (e, target);\n   else\n     e->redirect_callee (target);\n   class ipa_call_summary *es = ipa_call_summaries->get (e);"}, {"sha": "fa5015d386bd20fa965798880cde506ba395b7f5", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -258,7 +258,7 @@ check_speculations_1 (cgraph_node *n, vec<cgraph_edge *> *new_edges,\n \t    edge_set->add (new_edges->pop ());\n \t  edge_set->remove (e);\n \n-\t  e->resolve_speculation (NULL);\n+\t  cgraph_edge::resolve_speculation (e, NULL);\n \t  speculation_removed = true;\n \t}\n       else if (!e->inline_failed)\n@@ -712,7 +712,7 @@ inline_transform (struct cgraph_node *node)\n       if (!e->inline_failed)\n \thas_inline = true;\n       next = e->next_callee;\n-      e->redirect_call_stmt_to_callee ();\n+      cgraph_edge::redirect_call_stmt_to_callee (e);\n     }\n   node->remove_all_references ();\n "}, {"sha": "c56cfb04d40e4294bec1bd7eefa37b5bc162940e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -1834,7 +1834,7 @@ resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n \n       if (edge->count.ipa ().initialized_p ())\n         spec_rem += edge->count.ipa ();\n-      edge->resolve_speculation ();\n+      cgraph_edge::resolve_speculation (edge);\n       reset_edge_caches (where);\n       ipa_update_overall_fn_summary (where);\n       update_caller_keys (edge_heap, where,\n@@ -1998,7 +1998,7 @@ inline_small_functions (void)\n \t    if (edge->speculative\n \t\t&& !speculation_useful_p (edge, edge->aux != NULL))\n \t      {\n-\t\tedge->resolve_speculation ();\n+\t\tcgraph_edge::resolve_speculation (edge);\n \t\tupdate = true;\n \t      }\n \t  }\n@@ -2735,7 +2735,7 @@ ipa_inline (void)\n \t\t{\n \t\t  if (edge->count.ipa ().initialized_p ())\n \t\t    spec_rem += edge->count.ipa ();\n-\t\t  edge->resolve_speculation ();\n+\t\t  cgraph_edge::resolve_speculation (edge);\n \t\t  update = true;\n \t\t  remove_functions = true;\n \t\t}"}, {"sha": "ddb3c9b21bc73f395adab649b962ff00fa96a854", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -3299,7 +3299,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n   if (!speculative)\n     {\n       struct cgraph_edge *orig = ie;\n-      ie = ie->make_direct (callee);\n+      ie = cgraph_edge::make_direct (ie, callee);\n       /* If we resolved speculative edge the cost is already up to date\n \t for direct call (adjusted by inline_edge_duplication_hook).  */\n       if (ie == orig)"}, {"sha": "a3845372d7ea020c8940ddcc34c569a753c7b9c9", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -632,8 +632,10 @@ function_and_variable_visibility (bool whole_program)\n \tcontinue;\n \n       cgraph_node *alias = 0;\n-      for (cgraph_edge *e = node->callees; e; e = e->next_callee)\n+      cgraph_edge *next_edge;\n+      for (cgraph_edge *e = node->callees; e; e = next_edge)\n \t{\n+\t  next_edge = e->next_callee;\n \t  /* Recursive function calls usually can't be interposed.  */\n \n \t  if (!e->recursive_p ())\n@@ -649,7 +651,7 @@ function_and_variable_visibility (bool whole_program)\n \t  if (gimple_has_body_p (e->caller->decl))\n \t    {\n \t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n-\t      e->redirect_call_stmt_to_callee ();\n+\t      cgraph_edge::redirect_call_stmt_to_callee (e);\n \t      pop_cfun ();\n \t    }\n \t}\n@@ -780,7 +782,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t  if (gimple_has_body_p (e->caller->decl))\n \t\t    {\n \t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n-\t\t      e->redirect_call_stmt_to_callee ();\n+\t\t      cgraph_edge::redirect_call_stmt_to_callee (e);\n \t\t      pop_cfun ();\n \t\t    }\n \t\t}"}, {"sha": "e2635a717898f2571c426aab7ba0e1add0e58ec6", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -242,12 +242,12 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t\t\t       edge->caller->dump_name (),\n \t\t\t       target->dump_name ());\n \t    }\n-\t  edge = edge->make_direct (target);\n+\t  edge = cgraph_edge::make_direct (edge, target);\n \t  if (ipa_fn_summaries)\n \t    ipa_update_overall_fn_summary (node->inlined_to\n \t\t\t\t\t   ? node->inlined_to : node);\n \t  else if (edge->call_stmt)\n-\t    edge->redirect_call_stmt_to_callee ();\n+\t    cgraph_edge::redirect_call_stmt_to_callee (edge);\n \t}\n     }\n }"}, {"sha": "cccfd2774db0ca92d16c76b51223270ae21634d3", "filename": "gcc/multiple_target.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fmultiple_target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Fmultiple_target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmultiple_target.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -126,7 +126,7 @@ create_dispatcher_calls (struct cgraph_node *node)\n       FOR_EACH_VEC_ELT (edges_to_redirect, i, e)\n \t{\n \t  e->redirect_callee (inode);\n-\t  e->redirect_call_stmt_to_callee ();\n+\t  cgraph_edge::redirect_call_stmt_to_callee (e);\n \t}\n \n       /* Redirect references.  */\n@@ -501,7 +501,7 @@ redirect_to_specific_clone (cgraph_node *node)\n \t      if (attribute_list_equal (attr_target, attr_target2))\n \t\t{\n \t\t  e->redirect_callee (callee);\n-\t\t  e->redirect_call_stmt_to_callee ();\n+\t\t  cgraph_edge::redirect_call_stmt_to_callee (e);\n \t\t  break;\n \t\t}\n \t    }"}, {"sha": "4763cd45a1c07871c4c71552ea73304a328847c9", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -1598,7 +1598,7 @@ delete_unreachable_blocks_update_callgraph (cgraph_node *dst_node,\n \t\t  if (!e->inline_failed)\n \t\t    e->callee->remove_symbol_and_inline_clones (dst_node);\n \t\t  else\n-\t\t    e->remove ();\n+\t\t    cgraph_edge::remove (e);\n \t\t}\n \t      if (update_clones && dst_node->clones)\n \t\tfor (node = dst_node->clones; node != dst_node;)\n@@ -1610,7 +1610,7 @@ delete_unreachable_blocks_update_callgraph (cgraph_node *dst_node,\n \t\t\tif (!e->inline_failed)\n \t\t\t  e->callee->remove_symbol_and_inline_clones (dst_node);\n \t\t\telse\n-\t\t\t  e->remove ();\n+\t\t\t  cgraph_edge::remove (e);\n \t\t      }\n \n \t\t    if (node->clones)"}, {"sha": "51aa06566b194bdc2a49dac3536c99df24f9038b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c5a1779badd02b337af5887e26b5420fbf71c7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=27c5a1779badd02b337af5887e26b5420fbf71c7", "patch": "@@ -2225,7 +2225,7 @@ copy_bb (copy_body_data *id, basic_block bb,\n \t\tcase CB_CGE_MOVE:\n \t\t  edge = id->dst_node->get_edge (orig_stmt);\n \t\t  if (edge)\n-\t\t    edge->set_call_stmt (call_stmt);\n+\t\t    edge = cgraph_edge::set_call_stmt (edge, call_stmt);\n \t\t  break;\n \n \t\tdefault:\n@@ -2899,7 +2899,8 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n \t  struct cgraph_edge *edge = id->dst_node->get_edge (stmt);\n \t  if (edge)\n \t    {\n-\t      gimple *new_stmt = edge->redirect_call_stmt_to_callee ();\n+\t      gimple *new_stmt\n+\t\t= cgraph_edge::redirect_call_stmt_to_callee (edge);\n \t      /* If IPA-SRA transformation, run as part of edge redirection,\n \t\t removed the LHS because it is unused, save it to\n \t\t killed_new_ssa_names so that we can prune it from debug\n@@ -4750,7 +4751,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n       tree op;\n       gimple_stmt_iterator iter = gsi_for_stmt (stmt);\n \n-      cg_edge->remove ();\n+      cgraph_edge::remove (cg_edge);\n       edge = id->src_node->callees->clone (id->dst_node, call_stmt,\n \t\t   \t\t           gimple_uid (stmt),\n \t\t\t\t   \t   profile_count::one (),"}]}