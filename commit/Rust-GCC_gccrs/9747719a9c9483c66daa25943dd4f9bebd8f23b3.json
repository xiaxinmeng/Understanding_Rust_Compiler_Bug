{"sha": "9747719a9c9483c66daa25943dd4f9bebd8f23b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc0NzcxOWE5Yzk0ODNjNjZkYWEyNTk0M2RkNGY5YmViZDhmMjNiMw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-03-05T23:12:20Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-03-05T23:12:20Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.c (sh_expand_t_scc): Remove SH2A special case\n\tand use unified expansion logic.\n\t* config/sh/sh.md (xorsi3_movrt): Rename to movrt.  Move\n\tcloser to the existing movt insn.\n\t(negc): Rename insn to *negc.  Add new expander.\n\t(movnegt): Use xor pattern for T bit negation.  Reserve helper\n\tconstant for negc pattern.\n\t(*movnegt): New insn and splitter.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-1.c: New.\n\t* gcc.target/sh/pr51244-2.c: New.\n\t* gcc.target/sh/pr51244-3.c: New.\n\nFrom-SVN: r184966", "tree": {"sha": "6ee019d6d59407d9f58c395a24e16b730c0a5c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ee019d6d59407d9f58c395a24e16b730c0a5c6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9747719a9c9483c66daa25943dd4f9bebd8f23b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9747719a9c9483c66daa25943dd4f9bebd8f23b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9747719a9c9483c66daa25943dd4f9bebd8f23b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9747719a9c9483c66daa25943dd4f9bebd8f23b3/comments", "author": null, "committer": null, "parents": [{"sha": "5de724244f16e91b67997df6edab0faad7b2c97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de724244f16e91b67997df6edab0faad7b2c97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de724244f16e91b67997df6edab0faad7b2c97d"}], "stats": {"total": 220, "additions": 176, "deletions": 44}, "files": [{"sha": "2f10f58e253df75ba0b2bf120de9ec0b7e5d7e61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -1,3 +1,15 @@\n+2012-03-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.c (sh_expand_t_scc): Remove SH2A special case\n+\tand use unified expansion logic.\n+\t* config/sh/sh.md (xorsi3_movrt): Rename to movrt.  Move\n+\tcloser to the existing movt insn.\n+\t(negc): Rename insn to *negc.  Add new expander.\n+\t(movnegt): Use xor pattern for T bit negation.  Reserve helper\n+\tconstant for negc pattern.\n+\t(*movnegt): New insn and splitter.\n+\n 2012-03-05  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* c-typeck.c (pointer_diff): Check for POINTER_PLUS_EXPR, not"}, {"sha": "4c2d710aea31c4be1ad560bcfcbca20abf7e961a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -11888,15 +11888,8 @@ sh_expand_t_scc (rtx operands[])\n   val = INTVAL (op1);\n   if ((code == EQ && val == 1) || (code == NE && val == 0))\n     emit_insn (gen_movt (result));\n-  else if (TARGET_SH2A && ((code == EQ && val == 0)\n-\t\t\t    || (code == NE && val == 1)))\n-    emit_insn (gen_xorsi3_movrt (result));\n   else if ((code == EQ && val == 0) || (code == NE && val == 1))\n-    {\n-      emit_clobber (result);\n-      emit_insn (gen_subc (result, result, result));\n-      emit_insn (gen_addsi3 (result, result, const1_rtx));\n-    }\n+   emit_insn (gen_movnegt (result));\n   else if (code == EQ || code == NE)\n     emit_insn (gen_move_insn (result, GEN_INT (code == NE)));\n   else"}, {"sha": "eb1c85267f363722e3d3889a4332c750fdd8a2ef", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -3354,15 +3354,6 @@ label:\n \txori\t%1, %2, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n \n-;; Store the complements of the T bit in a register.\n-(define_insn \"xorsi3_movrt\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(xor:SI (reg:SI T_REG)\n-\t\t(const_int 1)))]\n-  \"TARGET_SH2A\"\n-  \"movrt\\\\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,r\")\n \t(xor:DI (match_operand:DI 1 \"arith_reg_operand\" \"%r,r\")\n@@ -4387,7 +4378,17 @@ label:\n ;; Unary arithmetic\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"negc\"\n+(define_expand \"negc\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(neg:SI (plus:SI (reg:SI T_REG)\n+\t\t\t (match_operand:SI 1 \"arith_reg_operand\" \"\"))))\n+   (set (reg:SI T_REG)\n+\t(ne:SI (ior:SI (reg:SI T_REG) (match_dup 1))\n+\t       (const_int 0)))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*negc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(neg:SI (plus:SI (reg:SI T_REG)\n \t\t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n@@ -9528,6 +9529,13 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"movt\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"movrt\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(xor:SI (reg:SI T_REG) (const_int 1)))]\n+  \"TARGET_SH2A\"\n+  \"movrt\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_expand \"cstore4_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(match_operator:SI 1 \"sh_float_comparison_operator\"\n@@ -9654,40 +9662,55 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    DONE;\n \")\n \n-;; sne moves the complement of the T reg to DEST like this:\n-;;      cmp/eq ...\n-;;      mov    #-1,temp\n-;;      negc   temp,dest\n-;;   This is better than xoring compare result with 1 because it does\n-;;   not require r0 and further, the -1 may be CSE-ed or lifted out of a\n-;;   loop.\n+;; Move the complement of the T reg to a reg.\n+;; On SH2A the movrt insn can be used.\n+;; On anything else than SH2A this has to be done with multiple instructions.\n+;; One obvious way would be:\n+;;\tcmp/eq\t...\n+;;\tmovt\tr0\n+;;\txor\t#1,r0\n+;;\n+;; However, this puts pressure on r0 in most cases and thus the following is\n+;; more appealing:\n+;;\tcmp/eq\t...\n+;;\tmov\t#-1,temp\n+;;\tnegc\ttemp,dest\n+;;\n+;; If the constant -1 can be CSE-ed or lifted out of a loop it effectively\n+;; becomes a one instruction operation.  Moreover, care must be taken that\n+;; the insn can still be combined with inverted compare and branch code\n+;; around it.\n+;; The expander will reserve the constant -1, the insn makes the whole thing\n+;; combinable, the splitter finally emits the insn if it was not combined \n+;; away.\n+;; Notice that when using the negc variant the T bit also gets inverted.\n \n (define_expand \"movnegt\"\n   [(set (match_dup 1) (const_int -1))\n-   (parallel [(set (match_operand:SI 0 \"\" \"\")\n-\t\t   (neg:SI (plus:SI (reg:SI T_REG)\n-\t\t\t\t    (match_dup 1))))\n-\t      (set (reg:SI T_REG)\n-\t\t   (ne:SI (ior:SI (reg:SI T_REG) (match_dup 1))\n-\t\t\t  (const_int 0)))])]\n+   (parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t\t   (xor:SI (reg:SI T_REG) (const_int 1)))\n+   (use (match_dup 1))])]\n   \"\"\n-  \"\n {\n   operands[1] = gen_reg_rtx (SImode);\n-}\")\n-\n-;; Recognize mov #-1/negc/neg sequence, and change it to movt/add #-1.\n-;; This prevents a regression that occurred when we switched from xor to\n-;; mov/neg for sne.\n+})\n \n-(define_split\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(plus:SI (reg:SI T_REG)\n-\t\t (const_int -1)))]\n+(define_insn_and_split \"*movnegt\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(xor:SI (reg:SI T_REG) (const_int 1)))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n   \"TARGET_SH1\"\n-  [(set (match_dup 0) (eq:SI (reg:SI T_REG) (const_int 1)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))]\n-  \"\")\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (TARGET_SH2A)\n+    emit_insn (gen_movrt (operands[0]));\n+  else\n+    emit_insn (gen_negc (operands[0], operands[1]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"arith\")])\n \n (define_expand \"cstoresf4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}, {"sha": "b6d68dfb1d9bd631f7ef261f24a14ce055f4e3af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -1,3 +1,10 @@\n+2012-03-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-1.c: New.\n+\t* gcc.target/sh/pr51244-2.c: New.\n+\t* gcc.target/sh/pr51244-3.c: New.\n+\n 2012-03-05  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51930"}, {"sha": "302627893432266058da47a379ab1d93ba595daf", "filename": "gcc/testsuite/gcc.target/sh/pr48596.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr48596.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr48596.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr48596.c?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -0,0 +1,31 @@\n+/* Check that the following code compiles without errors.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+\n+enum { nrrdCenterUnknown, nrrdCenterNode, nrrdCenterCell, nrrdCenterLast };\n+typedef struct { int size; int center; }  NrrdAxis;\n+typedef struct { int dim; NrrdAxis axis[10]; } Nrrd;\n+typedef struct { } NrrdKernel;\n+typedef struct { const NrrdKernel *kernel[10]; int samples[10]; } Info;\n+\n+void\n+foo (Nrrd *nout, Nrrd *nin, const NrrdKernel *kernel, const double *parm,\n+     const int *samples, const double *scalings)\n+{\n+  Info *info;\n+  int d, p, np, center;\n+  for (d=0; d<nin->dim; d++)\n+    {\n+      info->kernel[d] = kernel;\n+      if (samples)\n+\tinfo->samples[d] = samples[d];\n+      else\n+\t{\n+\t  center = _nrrdCenter(nin->axis[d].center);\n+\t  if (nrrdCenterCell == center)\n+\t    info->samples[d] = nin->axis[d].size*scalings[d];\n+\t  else\n+\t    info->samples[d] = (nin->axis[d].size - 1)*scalings[d] + 1;\n+\t}\n+    }\n+}"}, {"sha": "57af1040ae8a2fbf33ca2d5bf9c1eb7d3c957c22", "filename": "gcc/testsuite/gcc.target/sh/pr51244-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-1.c?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -0,0 +1,32 @@\n+/* Check that inverted conditional branch logic does not generate\n+   unnecessary explicit T bit extractions, inversions and \n+   test instructions.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1 -mbranch-cost=2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n+/* { dg-final { scan-assembler-not \"tst|negc|extu\" } } */\n+\n+int\n+testfunc_00 (int a, int b, int c, int d)\n+{\n+  return (a != b || a != d) ? b : c;\n+}\n+\n+int\n+testfunc_01 (int a, char* p, int b, int c)\n+{\n+  return (a == b && a == c) ? b : c;\n+}\n+\n+int\n+testfunc_02 (int a, char* p, int b, int c)\n+{\n+  return (a == b && a == c) ? b : c;\n+}\n+\n+int\n+testfunc_03 (int a, char* p, int b, int c)\n+{\n+  return (a != b && a != c) ? b : c;\n+}\n+"}, {"sha": "d984676102f161b8a472d0c5b26a5afd449daadc", "filename": "gcc/testsuite/gcc.target/sh/pr51244-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-2.c?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -0,0 +1,18 @@\n+/* Check that when taking the complement of the T bit using the negc\n+   instruction pattern, the constant -1 is loaded only once.\n+   On SH2A this test is skipped because the movrt instruction is used\n+   to get the complement of the T bit.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1 -mbranch-cost=2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" \"-m2a*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-times \"mov\\t#-1\" 1 } } */\n+\n+void\n+testfunc_00 (int* a, int* b, int c, int d)\n+{\n+  b[0] = a[0] != c;\n+  b[1] = a[1] != d;\n+  b[2] = a[2] != c;\n+  b[3] = a[3] != d;\n+}\n+"}, {"sha": "ebb3c3ae4c244c6abdf7cebbad024aaf978604c0", "filename": "gcc/testsuite/gcc.target/sh/pr51244-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9747719a9c9483c66daa25943dd4f9bebd8f23b3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-3.c?ref=9747719a9c9483c66daa25943dd4f9bebd8f23b3", "patch": "@@ -0,0 +1,16 @@\n+/* Check that when taking the complement of the T bit on SH2A, \n+   the movrt instruction is being generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1 -mbranch-cost=2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"movrt\" 4 } } */\n+\n+void\n+testfunc_00 (int* a, int* b, int c, int d)\n+{\n+  b[0] = a[0] != c;\n+  b[1] = a[1] != d;\n+  b[2] = a[2] != c;\n+  b[3] = a[3] != d;\n+}\n+"}]}