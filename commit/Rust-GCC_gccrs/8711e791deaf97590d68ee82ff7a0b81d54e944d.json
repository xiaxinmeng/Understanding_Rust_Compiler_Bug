{"sha": "8711e791deaf97590d68ee82ff7a0b81d54e944d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcxMWU3OTFkZWFmOTc1OTBkNjhlZTgyZmY3YTBiODFkNTRlOTQ0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-30T09:48:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-30T09:48:24Z"}, "message": "[AArch64] Fix sve/extract_[12].c for big-endian SVE\n\nsve/extract_[12].c were relying on the target-independent optimisation\nthat removes a redundant vec_select, so that we don't end up with\nthings like:\n\n    dup v0.4s, v0.4s[0]\n    ...use s0...\n\nBut that optimisation rightly doesn't trigger for big-endian targets,\nbecause GCC expects lane 0 to be in the high part of the register\nrather than the low part.\n\nSVE breaks this assumption -- see the comment at the head of\naarch64-sve.md for details -- so the optimisation is valid for\nboth endiannesses.  Long term, we probably need some kind of target\nhook to make GCC aware of this.\n\nBut there's another problem with the current extract pattern: it doesn't\ntell the register allocator how cheap an extraction of lane 0 is with\ntied registers.  It seems better to split the lane 0 case out into\nits own pattern and use tied operands for the FPR<-SIMD case,\nso that using different registers has the cost of an extra reload.\nI think we want this for both endiannesses, regardless of the hook\ndescribed above.\n\nAlso, the gen_lowpart in this pattern fails for aarch64_be due to\nTARGET_CAN_CHANGE_MODE_CLASS restrictions, so the patch uses gen_rtx_REG\ninstead.  We're only creating this rtl in order to print it, so there's\nno need for anything fancier.\n\n2018-01-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/aarch64/aarch64-sve.md (*vec_extract<mode><Vel>_0): New\n\tpattern.\n\t(*vec_extract<mode><Vel>_v128): Require a nonzero lane number.\n\tUse gen_rtx_REG rather than gen_lowpart.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nFrom-SVN: r257178", "tree": {"sha": "74054d566ac7b36c615afb50fe7751bc16a75ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74054d566ac7b36c615afb50fe7751bc16a75ae3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8711e791deaf97590d68ee82ff7a0b81d54e944d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8711e791deaf97590d68ee82ff7a0b81d54e944d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8711e791deaf97590d68ee82ff7a0b81d54e944d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8711e791deaf97590d68ee82ff7a0b81d54e944d/comments", "author": null, "committer": null, "parents": [{"sha": "e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89b01f2b1bb7b4a689502dd23775301ef36eb0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89b01f2b1bb7b4a689502dd23775301ef36eb0d"}], "stats": {"total": 47, "additions": 44, "deletions": 3}, "files": [{"sha": "119be1b6c019d5fe7949dfc4102b010628dca392", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8711e791deaf97590d68ee82ff7a0b81d54e944d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8711e791deaf97590d68ee82ff7a0b81d54e944d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8711e791deaf97590d68ee82ff7a0b81d54e944d", "patch": "@@ -1,3 +1,10 @@\n+2018-01-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/aarch64/aarch64-sve.md (*vec_extract<mode><Vel>_0): New\n+\tpattern.\n+\t(*vec_extract<mode><Vel>_v128): Require a nonzero lane number.\n+\tUse gen_rtx_REG rather than gen_lowpart.\n+\n 2018-01-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* lra-constraints.c (match_reload): Use subreg_lowpart_offset"}, {"sha": "ee942dfad789175491b6dcb613181828e1dfe907", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8711e791deaf97590d68ee82ff7a0b81d54e944d/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8711e791deaf97590d68ee82ff7a0b81d54e944d/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=8711e791deaf97590d68ee82ff7a0b81d54e944d", "patch": "@@ -484,18 +484,52 @@\n   }\n )\n \n+;; Extract element zero.  This is a special case because we want to force\n+;; the registers to be the same for the second alternative, and then\n+;; split the instruction into nothing after RA.\n+(define_insn_and_split \"*vec_extract<mode><Vel>_0\"\n+  [(set (match_operand:<VEL> 0 \"aarch64_simd_nonimmediate_operand\" \"=r, w, Utv\")\n+\t(vec_select:<VEL>\n+\t  (match_operand:SVE_ALL 1 \"register_operand\" \"w, 0, w\")\n+\t  (parallel [(const_int 0)])))]\n+  \"TARGET_SVE\"\n+  {\n+    operands[1] = gen_rtx_REG (<V128>mode, REGNO (operands[1]));\n+    switch (which_alternative)\n+      {\n+\tcase 0:\n+\t  return \"umov\\\\t%<vwcore>0, %1.<Vetype>[0]\";\n+\tcase 1:\n+\t  return \"#\";\n+\tcase 2:\n+\t  return \"st1\\\\t{%1.<Vetype>}[0], %0\";\n+\tdefault:\n+\t  gcc_unreachable ();\n+      }\n+  }\n+  \"&& reload_completed\n+   && REG_P (operands[0])\n+   && REGNO (operands[0]) == REGNO (operands[1])\"\n+  [(const_int 0)]\n+  {\n+    emit_note (NOTE_INSN_DELETED);\n+    DONE;\n+  }\n+  [(set_attr \"type\" \"neon_to_gp_q, untyped, neon_store1_one_lane_q\")]\n+)\n+\n ;; Extract an element from the Advanced SIMD portion of the register.\n ;; We don't just reuse the aarch64-simd.md pattern because we don't\n-;; want any chnage in lane number on big-endian targets.\n+;; want any change in lane number on big-endian targets.\n (define_insn \"*vec_extract<mode><Vel>_v128\"\n   [(set (match_operand:<VEL> 0 \"aarch64_simd_nonimmediate_operand\" \"=r, w, Utv\")\n \t(vec_select:<VEL>\n \t  (match_operand:SVE_ALL 1 \"register_operand\" \"w, w, w\")\n \t  (parallel [(match_operand:SI 2 \"const_int_operand\")])))]\n   \"TARGET_SVE\n-   && IN_RANGE (INTVAL (operands[2]) * GET_MODE_SIZE (<VEL>mode), 0, 15)\"\n+   && IN_RANGE (INTVAL (operands[2]) * GET_MODE_SIZE (<VEL>mode), 1, 15)\"\n   {\n-    operands[1] = gen_lowpart (<V128>mode, operands[1]);\n+    operands[1] = gen_rtx_REG (<V128>mode, REGNO (operands[1]));\n     switch (which_alternative)\n       {\n \tcase 0:"}]}