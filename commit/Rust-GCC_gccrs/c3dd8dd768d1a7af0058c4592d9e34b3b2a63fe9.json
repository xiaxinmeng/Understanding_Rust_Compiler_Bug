{"sha": "c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNkZDhkZDc2OGQxYTdhZjAwNThjNDU5MmQ5ZTM0YjNiMmE2M2ZlOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2012-12-04T09:19:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-12-04T09:19:05Z"}, "message": "re PR tree-optimization/55124 (ICE in find_or_generate_expression, at tree-ssa-pre.c:2803)\n\n2012-12-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/55124\n\t* tree-ssa-pre.c (find_or_generate_expression): Instead of\n\tICEing when we are not able to generate an expression defer it\n\tby signalling failure.  Fix possible wrong-code issue by\n\tnot picking random REFERENCE expressions as fallback.\n\t(create_component_ref_by_pieces_1): Adjust.  Add failure paths.\n\t(create_expression_by_pieces): Likewise.\n\t(insert_into_preds_of_block): When expression generation failed\n\tfor one edge make sure to not insert a PHI node.\n\n\t* gcc.dg/torture/pr55124.c: New testcase.\n\nFrom-SVN: r194125", "tree": {"sha": "c0f80ce30991184212fcbba4fc0844cffd34bef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0f80ce30991184212fcbba4fc0844cffd34bef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2b2ead42ed389a918b586b3f95c26455ae13e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b2ead42ed389a918b586b3f95c26455ae13e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b2ead42ed389a918b586b3f95c26455ae13e7c"}], "stats": {"total": 145, "additions": 119, "deletions": 26}, "files": [{"sha": "f602a1275201715e15def1613bae38f4e7889bd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "patch": "@@ -1,3 +1,15 @@\n+2012-12-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/55124\n+\t* tree-ssa-pre.c (find_or_generate_expression): Instead of\n+\tICEing when we are not able to generate an expression defer it\n+\tby signalling failure.  Fix possible wrong-code issue by\n+\tnot picking random REFERENCE expressions as fallback.\n+\t(create_component_ref_by_pieces_1): Adjust.  Add failure paths.\n+\t(create_expression_by_pieces): Likewise.\n+\t(insert_into_preds_of_block): When expression generation failed\n+\tfor one edge make sure to not insert a PHI node.\n+\n 2012-12-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/ia64/ia64.c (ia64_compute_frame_size): Allocate the scratch"}, {"sha": "aaa6b8b484e0876f6e27993b7fa20a8200717621", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "patch": "@@ -1,3 +1,8 @@\n+2012-12-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/55124\n+\t* gcc.dg/torture/pr55124.c: New testcase.\n+\n 2012-12-03  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/quad_3.f90: New."}, {"sha": "a8eec984b3900ba00f52ba7c680c5f4a69c18ef4", "filename": "gcc/testsuite/gcc.dg/torture/pr55124.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55124.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55124.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55124.c?ref=c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+int a, b;\n+long c;\n+\n+void f2(void)\n+{\n+  unsigned long k = 1;\n+\n+  foo(b ? k = 0 : 0);\n+\n+  b = ((c = b) ? (k ? : (c = 0)) : a) * c;\n+}\n+\n+void f1(void)\n+{\n+  f2();\n+\n+  a = b | c;\n+}"}, {"sha": "9cc795b8c4c2c4f5e8255a0aaffa0b3681ee0ebc", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 82, "deletions": 26, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c3dd8dd768d1a7af0058c4592d9e34b3b2a63fe9", "patch": "@@ -2564,13 +2564,21 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t  fn = currop->op0;\n \telse\n \t  fn = find_or_generate_expression (block, currop->op0, stmts);\n+\tif (!fn)\n+\t  return NULL_TREE;\n \tif (currop->op1)\n-\t  sc = find_or_generate_expression (block, currop->op1, stmts);\n+\t  {\n+\t    sc = find_or_generate_expression (block, currop->op1, stmts);\n+\t    if (!sc)\n+\t      return NULL_TREE;\n+\t  }\n \targs = XNEWVEC (tree, ref->operands.length () - 1);\n \twhile (*operand < ref->operands.length ())\n \t  {\n \t    args[nargs] = create_component_ref_by_pieces_1 (block, ref,\n \t\t\t\t\t\t\t    operand, stmts);\n+\t    if (!args[nargs])\n+\t      return NULL_TREE;\n \t    nargs++;\n \t  }\n \tfolded = build_call_array (currop->type,\n@@ -2587,6 +2595,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n       {\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t\tstmts);\n+\tif (!baseop)\n+\t  return NULL_TREE;\n \ttree offset = currop->op0;\n \tif (TREE_CODE (baseop) == ADDR_EXPR\n \t    && handled_component_p (TREE_OPERAND (baseop, 0)))\n@@ -2610,10 +2620,20 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \tvn_reference_op_t nextop = &ref->operands[++*operand];\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t\tstmts);\n+\tif (!baseop)\n+\t  return NULL_TREE;\n \tif (currop->op0)\n-\t  genop0 = find_or_generate_expression (block, currop->op0, stmts);\n+\t  {\n+\t    genop0 = find_or_generate_expression (block, currop->op0, stmts);\n+\t    if (!genop0)\n+\t      return NULL_TREE;\n+\t  }\n \tif (nextop->op0)\n-\t  genop1 = find_or_generate_expression (block, nextop->op0, stmts);\n+\t  {\n+\t    genop1 = find_or_generate_expression (block, nextop->op0, stmts);\n+\t    if (!genop1)\n+\t      return NULL_TREE;\n+\t  }\n \treturn build5 (TARGET_MEM_REF, currop->type,\n \t\t       baseop, currop->op2, genop0, currop->op1, genop1);\n       }\n@@ -2629,23 +2649,31 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n     case IMAGPART_EXPR:\n     case VIEW_CONVERT_EXPR:\n       {\n-\ttree genop0 = create_component_ref_by_pieces_1 (block, ref,\n-\t\t\t\t\t\t\toperand, stmts);\n+\ttree genop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n+\t\t\t\t\t\t\tstmts);\n+\tif (!genop0)\n+\t  return NULL_TREE;\n \treturn fold_build1 (currop->opcode, currop->type, genop0);\n       }\n \n     case WITH_SIZE_EXPR:\n       {\n \ttree genop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t\tstmts);\n+\tif (!genop0)\n+\t  return NULL_TREE;\n \ttree genop1 = find_or_generate_expression (block, currop->op0, stmts);\n+\tif (!genop1)\n+\t  return NULL_TREE;\n \treturn fold_build2 (currop->opcode, currop->type, genop0, genop1);\n       }\n \n     case BIT_FIELD_REF:\n       {\n \ttree genop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t\tstmts);\n+\tif (!genop0)\n+\t  return NULL_TREE;\n \ttree op1 = currop->op0;\n \ttree op2 = currop->op1;\n \treturn fold_build3 (BIT_FIELD_REF, currop->type, genop0, op1, op2);\n@@ -2661,8 +2689,13 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \ttree genop1 = currop->op0;\n \ttree genop2 = currop->op1;\n \ttree genop3 = currop->op2;\n-\tgenop0 = create_component_ref_by_pieces_1 (block, ref, operand, stmts);\n+\tgenop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n+\t\t\t\t\t\t   stmts);\n+\tif (!genop0)\n+\t  return NULL_TREE;\n \tgenop1 = find_or_generate_expression (block, genop1, stmts);\n+\tif (!genop1)\n+\t  return NULL_TREE;\n \tif (genop2)\n \t  {\n \t    tree domain_type = TYPE_DOMAIN (TREE_TYPE (genop0));\n@@ -2672,7 +2705,11 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t\t    || integer_zerop (TYPE_MIN_VALUE (domain_type))))\n \t      genop2 = NULL_TREE;\n \t    else\n-\t      genop2 = find_or_generate_expression (block, genop2, stmts);\n+\t      {\n+\t\tgenop2 = find_or_generate_expression (block, genop2, stmts);\n+\t\tif (!genop2)\n+\t\t  return NULL_TREE;\n+\t      }\n \t  }\n \tif (genop3)\n \t  {\n@@ -2688,6 +2725,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t\tgenop3 = size_binop (EXACT_DIV_EXPR, genop3,\n \t\t\t\t     size_int (TYPE_ALIGN_UNIT (elmt_type)));\n \t\tgenop3 = find_or_generate_expression (block, genop3, stmts);\n+\t\tif (!genop3)\n+\t\t  return NULL_TREE;\n \t      }\n \t  }\n \treturn build4 (currop->opcode, currop->type, genop0, genop1,\n@@ -2699,10 +2738,16 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \ttree op1;\n \ttree genop2 = currop->op1;\n \top0 = create_component_ref_by_pieces_1 (block, ref, operand, stmts);\n+\tif (!op0)\n+\t  return NULL_TREE;\n \t/* op1 should be a FIELD_DECL, which are represented by themselves.  */\n \top1 = currop->op0;\n \tif (genop2)\n-\t  genop2 = find_or_generate_expression (block, genop2, stmts);\n+\t  {\n+\t    genop2 = find_or_generate_expression (block, genop2, stmts);\n+\t    if (!genop2)\n+\t      return NULL_TREE;\n+\t  }\n \treturn fold_build3 (COMPONENT_REF, TREE_TYPE (op1), op0, op1, genop2);\n       }\n \n@@ -2749,18 +2794,11 @@ create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n   return create_component_ref_by_pieces_1 (block, ref, &op, stmts);\n }\n \n-/* Find a leader for an expression, or generate one using\n-   create_expression_by_pieces if it's ANTIC but\n-   complex.\n+/* Find a simple leader for an expression, or generate one using\n+   create_expression_by_pieces from a NARY expression for the value.\n    BLOCK is the basic_block we are looking for leaders in.\n    OP is the tree expression to find a leader for or generate.\n-   STMTS is the statement list to put the inserted expressions on.\n-   Returns the SSA_NAME of the LHS of the generated expression or the\n-   leader.\n-   DOMSTMT if non-NULL is a statement that should be dominated by\n-   all uses in the generated expression.  If DOMSTMT is non-NULL this\n-   routine can fail and return NULL_TREE.  Otherwise it will assert\n-   on failure.  */\n+   Returns the leader or NULL_TREE on failure.  */\n \n static tree\n find_or_generate_expression (basic_block block, tree op, gimple_seq *stmts)\n@@ -2774,21 +2812,30 @@ find_or_generate_expression (basic_block block, tree op, gimple_seq *stmts)\n \treturn PRE_EXPR_NAME (leader);\n       else if (leader->kind == CONSTANT)\n \treturn PRE_EXPR_CONSTANT (leader);\n+\n+      /* Defer.  */\n+      return NULL_TREE;\n     }\n \n-  /* It must be a complex expression, so generate it recursively.  */\n+  /* It must be a complex expression, so generate it recursively.  Note\n+     that this is only necessary to handle gcc.dg/tree-ssa/ssa-pre28.c\n+     where the insert algorithm fails to insert a required expression.  */\n   bitmap exprset = value_expressions[lookfor];\n   bitmap_iterator bi;\n   unsigned int i;\n   EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n     {\n       pre_expr temp = expression_for_id (i);\n-      if (temp->kind != NAME)\n+      /* We cannot insert random REFERENCE expressions at arbitrary\n+\t places.  We can insert NARYs which eventually re-materializes\n+\t its operand values.  */\n+      if (temp->kind == NARY)\n \treturn create_expression_by_pieces (block, temp, stmts,\n \t\t\t\t\t    get_expr_type (expr));\n     }\n \n-  gcc_unreachable ();\n+  /* Defer.  */\n+  return NULL_TREE;\n }\n \n #define NECESSARY GF_PLF_1\n@@ -2801,15 +2848,13 @@ find_or_generate_expression (basic_block block, tree op, gimple_seq *stmts)\n \n    This function will die if we hit some value that shouldn't be\n    ANTIC but is (IE there is no leader for it, or its components).\n+   The function returns NULL_TREE in case a different antic expression\n+   has to be inserted first.\n    This function may also generate expressions that are themselves\n    partially or fully redundant.  Those that are will be either made\n    fully redundant during the next iteration of insert (for partially\n    redundant ones), or eliminated by eliminate (for fully redundant\n-   ones).\n-\n-   If DOMSTMT is non-NULL then we make sure that all uses in the\n-   expressions dominate that statement.  In this case the function\n-   can return NULL_TREE to signal failure.  */\n+   ones).  */\n \n static tree\n create_expression_by_pieces (basic_block block, pre_expr expr,\n@@ -2838,6 +2883,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n       {\n \tvn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n \tfolded = create_component_ref_by_pieces (block, ref, stmts);\n+\tif (!folded)\n+\t  return NULL_TREE;\n       }\n       break;\n     case NARY:\n@@ -2848,6 +2895,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \tfor (i = 0; i < nary->length; ++i)\n \t  {\n \t    genop[i] = find_or_generate_expression (block, nary->op[i], stmts);\n+\t    if (!genop[i])\n+\t      return NULL_TREE;\n \t    /* Ensure genop[] is properly typed for POINTER_PLUS_EXPR.  It\n \t       may have conversions stripped.  */\n \t    if (nary->opcode == POINTER_PLUS_EXPR)\n@@ -3085,6 +3134,13 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t\t\t\t   &stmts, type);\n \t  gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n \t  gsi_insert_seq_on_edge (pred, stmts);\n+\t  if (!builtexpr)\n+\t    {\n+\t      /* We cannot insert a PHI node if we failed to insert\n+\t\t on one edge.  */\n+\t      nophi = true;\n+\t      continue;\n+\t    }\n \t  avail[pred->dest_idx] = get_or_alloc_expr_for_name (builtexpr);\n \t  insertions = true;\n \t}"}]}