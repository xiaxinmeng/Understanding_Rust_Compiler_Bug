{"sha": "e934ca476b8ff55d661aefb251675c4fef58ea30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkzNGNhNDc2YjhmZjU1ZDY2MWFlZmIyNTE2NzVjNGZlZjU4ZWEzMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-28T22:34:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-28T22:34:53Z"}, "message": "ia64.c (ia64_expand_vecint_compare): Use unsigned saturating subtraction for QI and HImode unsigned compares.\n\n        * config/ia64/ia64.c (ia64_expand_vecint_compare): Use unsigned\n        saturating subtraction for QI and HImode unsigned compares.  Use\n        bit arithmetic tricks for SImode unsigned compares.\n        (ia64_expand_vcondu_v2si): Remove.\n        (ia64_expand_vecint_cmov): Don't call it.\n\nFrom-SVN: r101396", "tree": {"sha": "b2b4dbb2aa5054a10a7c19d3c267a593d7570163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2b4dbb2aa5054a10a7c19d3c267a593d7570163"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e934ca476b8ff55d661aefb251675c4fef58ea30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e934ca476b8ff55d661aefb251675c4fef58ea30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e934ca476b8ff55d661aefb251675c4fef58ea30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e934ca476b8ff55d661aefb251675c4fef58ea30/comments", "author": null, "committer": null, "parents": [{"sha": "505ac5077028e17ceec8612d518ff1dad09f4140", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/505ac5077028e17ceec8612d518ff1dad09f4140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/505ac5077028e17ceec8612d518ff1dad09f4140"}], "stats": {"total": 188, "additions": 60, "deletions": 128}, "files": [{"sha": "cf9c27bbce371060cd9d0ce31cd778536f007086", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e934ca476b8ff55d661aefb251675c4fef58ea30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e934ca476b8ff55d661aefb251675c4fef58ea30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e934ca476b8ff55d661aefb251675c4fef58ea30", "patch": "@@ -1,3 +1,11 @@\n+2005-06-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_expand_vecint_compare): Use unsigned\n+\tsaturating subtraction for QI and HImode unsigned compares.  Use\n+\tbit arithmetic tricks for SImode unsigned compares.\n+\t(ia64_expand_vcondu_v2si): Remove.\n+\t(ia64_expand_vecint_cmov): Don't call it.\n+\n 2005-06-28  Richard Henderson  <rth@redhat.com>\n \n \t* rtlanal.c (nonzero_bits1): Use the mode of the value for"}, {"sha": "0ece66300cacaf3bd976ce3c820d34bceecfbd7f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 52, "deletions": 128, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e934ca476b8ff55d661aefb251675c4fef58ea30/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e934ca476b8ff55d661aefb251675c4fef58ea30/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e934ca476b8ff55d661aefb251675c4fef58ea30", "patch": "@@ -1526,7 +1526,8 @@ ia64_expand_compare (enum rtx_code code, enum machine_mode mode)\n   return gen_rtx_fmt_ee (code, mode, cmp, const0_rtx);\n }\n \n-/* Generate an integral vector comparison.  */\n+/* Generate an integral vector comparison.  Return true if the condition has\n+   been reversed, and so the sense of the comparison should be inverted.  */\n \n static bool\n ia64_expand_vecint_compare (enum rtx_code code, enum machine_mode mode,\n@@ -1535,95 +1536,80 @@ ia64_expand_vecint_compare (enum rtx_code code, enum machine_mode mode,\n   bool negate = false;\n   rtx x;\n \n+  /* Canonicalize the comparison to EQ, GT, GTU.  */\n   switch (code)\n     {\n     case EQ:\n     case GT:\n+    case GTU:\n       break;\n \n     case NE:\n-      code = EQ;\n-      negate = true;\n-      break;\n-\n     case LE:\n-      code = GT;\n+    case LEU:\n+      code = reverse_condition (code);\n       negate = true;\n       break;\n \n     case GE:\n+    case GEU:\n+      code = reverse_condition (code);\n       negate = true;\n       /* FALLTHRU */\n \n     case LT:\n-      x = op0;\n-      op0 = op1;\n-      op1 = x;\n-      code = GT;\n-      break;\n-\n-    case GTU:\n-    case GEU:\n     case LTU:\n-    case LEU:\n-      {\n-\trtx w0h, w0l, w1h, w1l, ch, cl;\n-\tenum machine_mode wmode;\n-\trtx (*unpack_l) (rtx, rtx, rtx);\n-\trtx (*unpack_h) (rtx, rtx, rtx);\n-\trtx (*pack) (rtx, rtx, rtx);\n+      code = swap_condition (code);\n+      x = op0, op0 = op1, op1 = x;\n+      break;\n \n-\t/* We don't have native unsigned comparisons, but we can generate\n-\t   them better than generic code can.  */\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-\tgcc_assert (mode != V2SImode);\n-\tswitch (mode)\n+  /* Unsigned parallel compare is not supported by the hardware.  Play some\n+     tricks to turn this into a GT comparison against 0.  */\n+  if (code == GTU)\n+    {\n+      switch (mode)\n+\t{\n+\tcase V2SImode:\n \t  {\n-\t  case V8QImode:\n-\t    wmode = V4HImode;\n-\t    pack = gen_pack2_sss;\n-\t    unpack_l = gen_unpack1_l;\n-\t    unpack_h = gen_unpack1_h;\n-\t    break;\n-\n-\t  case V4HImode:\n-\t    wmode = V2SImode;\n-\t    pack = gen_pack4_sss;\n-\t    unpack_l = gen_unpack2_l;\n-\t    unpack_h = gen_unpack2_h;\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n+\t    rtx t1, t2, mask;\n+\n+\t    /* Perform a parallel modulo subtraction.  */\n+\t    t1 = gen_reg_rtx (V2SImode);\n+\t    emit_insn (gen_subv2si3 (t1, op0, op1));\n+\n+\t    /* Extract the original sign bit of op0.  */\n+\t    mask = GEN_INT (-0x80000000);\n+\t    mask = gen_rtx_CONST_VECTOR (V2SImode, gen_rtvec (2, mask, mask));\n+\t    mask = force_reg (V2SImode, mask);\n+\t    t2 = gen_reg_rtx (V2SImode);\n+\t    emit_insn (gen_andv2si3 (t2, op0, mask));\n+\n+\t    /* XOR it back into the result of the subtraction.  This results\n+\t       in the sign bit set iff we saw unsigned underflow.  */\n+\t    x = gen_reg_rtx (V2SImode);\n+\t    emit_insn (gen_xorv2si3 (x, t1, t2));\n \t  }\n+\t  break;\n \n-\t/* Unpack into wider vectors, zero extending the elements.  */\n-\n-\tw0l = gen_reg_rtx (wmode);\n-\tw0h = gen_reg_rtx (wmode);\n-\tw1l = gen_reg_rtx (wmode);\n-\tw1h = gen_reg_rtx (wmode);\n-\temit_insn (unpack_l (gen_lowpart (mode, w0l), op0, CONST0_RTX (mode)));\n-\temit_insn (unpack_h (gen_lowpart (mode, w0h), op0, CONST0_RTX (mode)));\n-\temit_insn (unpack_l (gen_lowpart (mode, w1l), op1, CONST0_RTX (mode)));\n-\temit_insn (unpack_h (gen_lowpart (mode, w1h), op1, CONST0_RTX (mode)));\n-\n-\t/* Compare in the wider mode.  */\n-\n-\tcl = gen_reg_rtx (wmode);\n-\tch = gen_reg_rtx (wmode);\n-\tcode = signed_condition (code);\n-\tia64_expand_vecint_compare (code, wmode, cl, w0l, w1l);\n-\tnegate = ia64_expand_vecint_compare (code, wmode, ch, w0h, w1h);\n-\n-\t/* Repack into a single narrower vector.  */\n+\tcase V8QImode:\n+\tcase V4HImode:\n+\t  /* Perform a parallel unsigned saturating subtraction.  */\n+\t  x = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, x,\n+\t\t\t\t  gen_rtx_US_MINUS (mode, op0, op1)));\n+\t  break;\n \n-\temit_insn (pack (dest, cl, ch));\n-      }\n-      return negate;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n-    default:\n-      gcc_unreachable ();\n+      code = GT;\n+      op0 = x;\n+      op1 = CONST0_RTX (mode);\n     }\n \n   x = gen_rtx_fmt_ee (code, mode, op0, op1);\n@@ -1632,59 +1618,6 @@ ia64_expand_vecint_compare (enum rtx_code code, enum machine_mode mode,\n   return negate;\n }\n \n-static void\n-ia64_expand_vcondu_v2si (enum rtx_code code, rtx operands[])\n-{\n-  rtx dl, dh, bl, bh, op1l, op1h, op2l, op2h, op4l, op4h, op5l, op5h, x;\n-\n-  /* In this case, we extract the two SImode quantities and generate\n-     normal comparisons for each of them.  */\n-\n-  op1l = gen_lowpart (SImode, operands[1]);\n-  op2l = gen_lowpart (SImode, operands[2]);\n-  op4l = gen_lowpart (SImode, operands[4]);\n-  op5l = gen_lowpart (SImode, operands[5]);\n-\n-  op1h = gen_reg_rtx (SImode);\n-  op2h = gen_reg_rtx (SImode);\n-  op4h = gen_reg_rtx (SImode);\n-  op5h = gen_reg_rtx (SImode);\n-\n-  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op1h),\n-\t\t\t  gen_lowpart (DImode, operands[1]), GEN_INT (32)));\n-  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op2h),\n-\t\t\t  gen_lowpart (DImode, operands[2]), GEN_INT (32)));\n-  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op4h),\n-\t\t\t  gen_lowpart (DImode, operands[4]), GEN_INT (32)));\n-  emit_insn (gen_lshrdi3 (gen_lowpart (DImode, op5h),\n-\t\t\t  gen_lowpart (DImode, operands[5]), GEN_INT (32)));\n-\n-  bl = gen_reg_rtx (BImode);\n-  x = gen_rtx_fmt_ee (code, BImode, op4l, op5l);\n-  emit_insn (gen_rtx_SET (VOIDmode, bl, x));\n-\n-  bh = gen_reg_rtx (BImode);\n-  x = gen_rtx_fmt_ee (code, BImode, op4h, op5h);\n-  emit_insn (gen_rtx_SET (VOIDmode, bh, x));\n-\n-  /* With the results of the comparisons, emit conditional moves.  */\n-\n-  dl = gen_reg_rtx (SImode);\n-  x = gen_rtx_NE (VOIDmode, bl, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (SImode, x, op1l, op2l);\n-  emit_insn (gen_rtx_SET (VOIDmode, dl, x));\n-\n-  dh = gen_reg_rtx (SImode);\n-  x = gen_rtx_NE (VOIDmode, bh, const0_rtx);\n-  x = gen_rtx_IF_THEN_ELSE (SImode, x, op1h, op2h);\n-  emit_insn (gen_rtx_SET (VOIDmode, dh, x));\n-\n-  /* Merge the two partial results back into a vector.  */\n-\n-  x = gen_rtx_VEC_CONCAT (V2SImode, dl, dh);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0], x));\n-}\n-\n /* Emit an integral vector conditional move.  */\n \n void\n@@ -1695,15 +1628,6 @@ ia64_expand_vecint_cmov (rtx operands[])\n   bool negate;\n   rtx cmp, x, ot, of;\n \n-  /* Since we don't have unsigned V2SImode comparisons, it's more efficient\n-     to special-case them entirely.  */\n-  if (mode == V2SImode\n-      && (code == GTU || code == GEU || code == LEU || code == LTU))\n-    {\n-      ia64_expand_vcondu_v2si (code, operands);\n-      return;\n-    }\n-\n   cmp = gen_reg_rtx (mode);\n   negate = ia64_expand_vecint_compare (code, mode, cmp,\n \t\t\t\t       operands[4], operands[5]);"}]}