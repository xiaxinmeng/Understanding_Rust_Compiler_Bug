{"sha": "08d95f9128a3edc487281033732341b2d95552be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhkOTVmOTEyOGEzZWRjNDg3MjgxMDMzNzMyMzQxYjJkOTU1NTJiZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-01T23:22:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-01T23:22:21Z"}, "message": "Add prototypes for static functions.\n\n(auto_inc_dec_reg_p): New function.\n(regclass): Call it to allow a register needing a secondary reload to be used\nfor inc/dec if it is already valid for it.\n\nFrom-SVN: r6461", "tree": {"sha": "7a9c7cc755d9eaf4f269a64cfad2e9ec951eae91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a9c7cc755d9eaf4f269a64cfad2e9ec951eae91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08d95f9128a3edc487281033732341b2d95552be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08d95f9128a3edc487281033732341b2d95552be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08d95f9128a3edc487281033732341b2d95552be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08d95f9128a3edc487281033732341b2d95552be/comments", "author": null, "committer": null, "parents": [{"sha": "2c3dd6b7bd90e7856d2c6c89075f757528f69f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c3dd6b7bd90e7856d2c6c89075f757528f69f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c3dd6b7bd90e7856d2c6c89075f757528f69f02"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "e055c4f1d1f8b639e2f75275697622927bb65618", "filename": "gcc/regclass.c", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d95f9128a3edc487281033732341b2d95552be/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d95f9128a3edc487281033732341b2d95552be/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=08d95f9128a3edc487281033732341b2d95552be", "patch": "@@ -503,10 +503,13 @@ static int loop_depth;\n \n static int loop_cost;\n \n-static int copy_cost ();\n-static void record_reg_classes ();\n-static void record_address_regs ();\n-\n+static void record_reg_classes\tPROTO((int, int, rtx *, enum machine_mode *,\n+\t\t\t\t       char **, rtx));\n+static int copy_cost\t\tPROTO((rtx, enum machine_mode, \n+\t\t\t\t       enum reg_class, int));\n+static void record_address_regs\tPROTO((rtx, enum reg_class, int));\n+static auto_inc_dec_reg_p\tPROTO((rtx, enum machine_mode));\n+static void reg_scan_mark_refs\tPROTO((rtx, rtx, int));\n \n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n@@ -584,16 +587,23 @@ regclass (f, nregs)\n \t      if (HARD_REGNO_MODE_OK (j, m))\n \t\t{\n \t\t  PUT_MODE (r, m);\n-\t\t  if (0\n+\n+\t\t  /* If a register is not directly suitable for an\n+\t\t     auto-increment or decrement addressing mode and\n+\t\t     requires secondary reloads, disallow its class from\n+\t\t     being used in such addresses.  */\n+\n+\t\t  if ((0\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n-\t\t      || (SECONDARY_INPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n-\t\t\t  != NO_REGS)\n+\t\t       || (SECONDARY_INPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t\t   != NO_REGS)\n #endif\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t\t      || (SECONDARY_OUTPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n-\t\t\t  != NO_REGS)\n+\t\t       || (SECONDARY_OUTPUT_RELOAD_CLASS (BASE_REG_CLASS, m, r)\n+\t\t\t   != NO_REGS)\n #endif\n-\t\t      )\n+\t\t       )\n+\t\t      && ! auto_inc_dec_reg_p (r, m))\n \t\t    forbidden_inc_dec_class[i] = 1;\n \t\t}\n \t  }\n@@ -1478,6 +1488,41 @@ record_address_regs (x, class, scale)\n       }\n     }\n }\n+\f\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\n+/* Return 1 if REG is valid as an auto-increment memory reference\n+   to an object of MODE.  */\n+\n+static \n+auto_inc_dec_reg_p (reg, mode)\n+     rtx reg;\n+     enum machine_mode mode;\n+{\n+#ifdef HAVE_POST_INCREMENT\n+  if (memory_address_p (mode, gen_rtx (POST_INC, Pmode, reg)))\n+    return 1;\n+#endif\n+\n+#ifdef HAVE_POST_DECREMENT\n+  if (memory_address_p (mode, gen_rtx (POST_DEC, Pmode, reg)))\n+    return 1;\n+#endif\n+\n+#ifdef HAVE_PRE_INCREMENT\n+  if (memory_address_p (mode, gen_rtx (PRE_INC, Pmode, reg)))\n+    return 1;\n+#endif\n+\n+#ifdef HAVE_PRE_DECREMENT\n+  if (memory_address_p (mode, gen_rtx (PRE_DEC, Pmode, reg)))\n+    return 1;\n+#endif\n+\n+  return 0;\n+}\n+#endif\n+\n #endif /* REGISTER_CONSTRAINTS */\n \f\n /* This is the `regscan' pass of the compiler, run just before cse\n@@ -1516,8 +1561,6 @@ static int highest_regno_in_uid_map;\n \n int max_parallel;\n \n-void reg_scan_mark_refs ();\n-\n void\n reg_scan (f, nregs, repeat)\n      rtx f;\n@@ -1565,7 +1608,7 @@ reg_scan (f, nregs, repeat)\n /* X is the expression to scan.  INSN is the insn it appears in.\n    NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.  */\n \n-void\n+static void\n reg_scan_mark_refs (x, insn, note_flag)\n      rtx x;\n      rtx insn;"}]}