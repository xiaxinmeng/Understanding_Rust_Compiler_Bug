{"sha": "13f34a3ff1be41d95ada5f840c25060072e7abf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNmMzRhM2ZmMWJlNDFkOTVhZGE1Zjg0MGMyNTA2MDA3MmU3YWJmNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:47:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:47:02Z"}, "message": "sem_eval.adb (Eval_Relational_Op): nothing to do if an operand is an illegal aggregate and the type is still...\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_eval.adb (Eval_Relational_Op): nothing to do if an operand is an\n\tillegal aggregate and the type is still Any_Composite.\n\t(Subtypes_Statically_Match): Fix problem of empty discriminant list\n\nFrom-SVN: r125460", "tree": {"sha": "8e4d646cb542473c4cdab9ac858889a5b0b7b3aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e4d646cb542473c4cdab9ac858889a5b0b7b3aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13f34a3ff1be41d95ada5f840c25060072e7abf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f34a3ff1be41d95ada5f840c25060072e7abf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f34a3ff1be41d95ada5f840c25060072e7abf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f34a3ff1be41d95ada5f840c25060072e7abf4/comments", "author": null, "committer": null, "parents": [{"sha": "79e448454ba29dac783a9124e369776b5b417183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e448454ba29dac783a9124e369776b5b417183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e448454ba29dac783a9124e369776b5b417183"}], "stats": {"total": 81, "additions": 46, "deletions": 35}, "files": [{"sha": "81729906d493375fc98c5c7c2d5445ce45fab730", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f34a3ff1be41d95ada5f840c25060072e7abf4/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f34a3ff1be41d95ada5f840c25060072e7abf4/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=13f34a3ff1be41d95ada5f840c25060072e7abf4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Errout;   use Errout;\n with Eval_Fat; use Eval_Fat;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n+with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n@@ -2262,11 +2263,13 @@ package body Sem_Eval is\n       --  then we can replace the entire result by False. We only\n       --  do this for one dimensional arrays, because the case of\n       --  multi-dimensional arrays is rare and too much trouble!\n+      --  If one of the operands is an illegal aggregate, its type\n+      --  might still be an arbitrary composite type, so nothing to do.\n \n       if Is_Array_Type (Typ)\n+        and then Typ /= Any_Composite\n         and then Number_Dimensions (Typ) = 1\n-        and then (Nkind (N) = N_Op_Eq\n-                    or else Nkind (N) = N_Op_Ne)\n+        and then (Nkind (N) = N_Op_Eq or else Nkind (N) = N_Op_Ne)\n       then\n          if Raises_Constraint_Error (Left)\n            or else Raises_Constraint_Error (Right)\n@@ -2276,9 +2279,9 @@ package body Sem_Eval is\n \n          declare\n             procedure Get_Static_Length (Op : Node_Id; Len : out Uint);\n-            --  If Op is an expression for a constrained array with a\n-            --  known at compile time length, then Len is set to this\n-            --  (non-negative length). Otherwise Len is set to minus 1.\n+            --  If Op is an expression for a constrained array with a known\n+            --  at compile time length, then Len is set to this (non-negative\n+            --  length). Otherwise Len is set to minus 1.\n \n             -----------------------\n             -- Get_Static_Length --\n@@ -2963,9 +2966,9 @@ package body Sem_Eval is\n       Val    : Uint;\n \n    begin\n-      --  If already in cache, then we know it's compile time known and\n-      --  we can return the value that was previously stored in the cache\n-      --  since compile time known values cannot change :-)\n+      --  If already in cache, then we know it's compile time known and we can\n+      --  return the value that was previously stored in the cache since\n+      --  compile time known values cannot change.\n \n       if CV_Ent.N = N then\n          return CV_Ent.V;\n@@ -4092,45 +4095,53 @@ package body Sem_Eval is\n             DL1 : constant Elist_Id := Discriminant_Constraint (T1);\n             DL2 : constant Elist_Id := Discriminant_Constraint (T2);\n \n-            DA1 : Elmt_Id := First_Elmt (DL1);\n-            DA2 : Elmt_Id := First_Elmt (DL2);\n+            DA1 : Elmt_Id;\n+            DA2 : Elmt_Id;\n \n          begin\n             if DL1 = DL2 then\n                return True;\n-\n             elsif Is_Constrained (T1) /= Is_Constrained (T2) then\n                return False;\n             end if;\n \n-            while Present (DA1) loop\n-               declare\n-                  Expr1 : constant Node_Id := Node (DA1);\n-                  Expr2 : constant Node_Id := Node (DA2);\n+            --  Now loop through the discriminant constraints\n \n-               begin\n-                  if not Is_Static_Expression (Expr1)\n-                    or else not Is_Static_Expression (Expr2)\n-                  then\n-                     return False;\n+            --  Note: the guard here seems necessary, since it is possible at\n+            --  least for DL1 to be No_Elist. Not clear this is reasonable ???\n \n-                  --  If either expression raised a constraint error,\n-                  --  consider the expressions as matching, since this\n-                  --  helps to prevent cascading errors.\n+            if Present (DL1) and then Present (DL2) then\n+               DA1 := First_Elmt (DL1);\n+               DA2 := First_Elmt (DL2);\n+               while Present (DA1) loop\n+                  declare\n+                     Expr1 : constant Node_Id := Node (DA1);\n+                     Expr2 : constant Node_Id := Node (DA2);\n \n-                  elsif Raises_Constraint_Error (Expr1)\n-                    or else Raises_Constraint_Error (Expr2)\n-                  then\n-                     null;\n+                  begin\n+                     if not Is_Static_Expression (Expr1)\n+                       or else not Is_Static_Expression (Expr2)\n+                     then\n+                        return False;\n \n-                  elsif Expr_Value (Expr1) /= Expr_Value (Expr2) then\n-                     return False;\n-                  end if;\n-               end;\n+                        --  If either expression raised a constraint error,\n+                        --  consider the expressions as matching, since this\n+                        --  helps to prevent cascading errors.\n \n-               Next_Elmt (DA1);\n-               Next_Elmt (DA2);\n-            end loop;\n+                     elsif Raises_Constraint_Error (Expr1)\n+                       or else Raises_Constraint_Error (Expr2)\n+                     then\n+                        null;\n+\n+                     elsif Expr_Value (Expr1) /= Expr_Value (Expr2) then\n+                        return False;\n+                     end if;\n+                  end;\n+\n+                  Next_Elmt (DA1);\n+                  Next_Elmt (DA2);\n+               end loop;\n+            end if;\n          end;\n \n          return True;"}]}