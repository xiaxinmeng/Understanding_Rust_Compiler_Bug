{"sha": "2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzOTE0Mjg3ZDRjMWM3NTM5NGQ0ZjEwMWFkNWJkNGQ5ZDRiNjZlOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-10-06T09:39:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-10-06T09:39:07Z"}, "message": "re PR tree-optimization/82434 (-fstore-merging does not work reliably.)\n\n\tPR tree-optimization/82434\n\t* fold-const.h (can_native_encode_type_p,\n\tcan_native_encode_string_p): Remove.\n\t* fold-const.c (native_encode_int): Formatting fixes.  If ptr is NULL,\n\tdon't encode anything, just return what would be otherwise returned.\n\t(native_encode_fixed, native_encode_complex, native_encode_vector):\n\tLikewise.\n\t(native_encode_string): Likewise.  Inline by hand\n\tcan_native_encode_string_p.\n\t(can_native_encode_type_p): Remove.\n\t(can_native_encode_string_p): Remove.\n\t* tree-vect-stmts.c (vectorizable_store): Instead of testing just\n\tSTRING_CSTs using can_native_encode_string_p, test all\n\tCONSTANT_CLASS_P values using native_encode_expr with NULL ptr.\n\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Remove last\n\targument from native_encode_expr.\n\t(rhs_valid_for_store_merging_p): Use native_encode_expr with NULL ptr.\n\t(pass_store_merging::execute): Don't unnecessarily look for 3 stmts,\n\tbut just 2.\n\n\t* gcc.dg/store_merging_9.c: New test.\n\nFrom-SVN: r253483", "tree": {"sha": "305f8eac06e4d9b00a2a7347b8b47303405eb9b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/305f8eac06e4d9b00a2a7347b8b47303405eb9b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d20eac1b41b9a86128a80f374e029d9638d14cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d20eac1b41b9a86128a80f374e029d9638d14cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d20eac1b41b9a86128a80f374e029d9638d14cba"}], "stats": {"total": 175, "additions": 102, "deletions": 73}, "files": [{"sha": "1aec8d306800a58c27bb81297976a43a9c7e3ba4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -1,3 +1,25 @@\n+2017-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/82434\n+\t* fold-const.h (can_native_encode_type_p,\n+\tcan_native_encode_string_p): Remove.\n+\t* fold-const.c (native_encode_int): Formatting fixes.  If ptr is NULL,\n+\tdon't encode anything, just return what would be otherwise returned.\n+\t(native_encode_fixed, native_encode_complex, native_encode_vector):\n+\tLikewise.\n+\t(native_encode_string): Likewise.  Inline by hand\n+\tcan_native_encode_string_p.\n+\t(can_native_encode_type_p): Remove.\n+\t(can_native_encode_string_p): Remove.\n+\t* tree-vect-stmts.c (vectorizable_store): Instead of testing just\n+\tSTRING_CSTs using can_native_encode_string_p, test all\n+\tCONSTANT_CLASS_P values using native_encode_expr with NULL ptr.\n+\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Remove last\n+\targument from native_encode_expr.\n+\t(rhs_valid_for_store_merging_p): Use native_encode_expr with NULL ptr.\n+\t(pass_store_merging::execute): Don't unnecessarily look for 3 stmts,\n+\tbut just 2.\n+\n 2017-10-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82397"}, {"sha": "d8dc56cea6b7dbb601d7e3605da03c123e9285cd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 58, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -6982,11 +6982,15 @@ native_encode_int (const_tree expr, unsigned char *ptr, int len, int off)\n   int byte, offset, word, words;\n   unsigned char value;\n \n-  if ((off == -1 && total_bytes > len)\n-      || off >= total_bytes)\n+  if ((off == -1 && total_bytes > len) || off >= total_bytes)\n     return 0;\n   if (off == -1)\n     off = 0;\n+\n+  if (ptr == NULL)\n+    /* Dry run.  */\n+    return MIN (len, total_bytes - off);\n+\n   words = total_bytes / UNITS_PER_WORD;\n \n   for (byte = 0; byte < total_bytes; byte++)\n@@ -7009,8 +7013,7 @@ native_encode_int (const_tree expr, unsigned char *ptr, int len, int off)\n \t}\n       else\n \toffset = BYTES_BIG_ENDIAN ? (total_bytes - 1) - byte : byte;\n-      if (offset >= off\n-\t  && offset - off < len)\n+      if (offset >= off && offset - off < len)\n \tptr[offset - off] = value;\n     }\n   return MIN (len, total_bytes - off);\n@@ -7036,8 +7039,7 @@ native_encode_fixed (const_tree expr, unsigned char *ptr, int len, int off)\n \n   i_type = lang_hooks.types.type_for_size (GET_MODE_BITSIZE (mode), 1);\n \n-  if (NULL_TREE == i_type\n-      || TYPE_PRECISION (i_type) != total_bytes)\n+  if (NULL_TREE == i_type || TYPE_PRECISION (i_type) != total_bytes)\n     return 0;\n   \n   value = TREE_FIXED_CST (expr);\n@@ -7065,11 +7067,15 @@ native_encode_real (const_tree expr, unsigned char *ptr, int len, int off)\n      up to 192 bits.  */\n   long tmp[6];\n \n-  if ((off == -1 && total_bytes > len)\n-      || off >= total_bytes)\n+  if ((off == -1 && total_bytes > len) || off >= total_bytes)\n     return 0;\n   if (off == -1)\n     off = 0;\n+\n+  if (ptr == NULL)\n+    /* Dry run.  */\n+    return MIN (len, total_bytes - off);\n+\n   words = (32 / BITS_PER_UNIT) / UNITS_PER_WORD;\n \n   real_to_target (tmp, TREE_REAL_CST_PTR (expr), TYPE_MODE (type));\n@@ -7123,15 +7129,14 @@ native_encode_complex (const_tree expr, unsigned char *ptr, int len, int off)\n \n   part = TREE_REALPART (expr);\n   rsize = native_encode_expr (part, ptr, len, off);\n-  if (off == -1\n-      && rsize == 0)\n+  if (off == -1 && rsize == 0)\n     return 0;\n   part = TREE_IMAGPART (expr);\n   if (off != -1)\n     off = MAX (0, off - GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (part))));\n-  isize = native_encode_expr (part, ptr+rsize, len-rsize, off);\n-  if (off == -1\n-      && isize != rsize)\n+  isize = native_encode_expr (part, ptr ? ptr + rsize : NULL,\n+\t\t\t      len - rsize, off);\n+  if (off == -1 && isize != rsize)\n     return 0;\n   return rsize + isize;\n }\n@@ -7161,9 +7166,9 @@ native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)\n \t  continue;\n \t}\n       elem = VECTOR_CST_ELT (expr, i);\n-      int res = native_encode_expr (elem, ptr+offset, len-offset, off);\n-      if ((off == -1 && res != size)\n-\t  || res == 0)\n+      int res = native_encode_expr (elem, ptr ? ptr + offset : NULL,\n+\t\t\t\t    len - offset, off);\n+      if ((off == -1 && res != size) || res == 0)\n \treturn 0;\n       offset += res;\n       if (offset >= len)\n@@ -7183,16 +7188,24 @@ native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)\n static int\n native_encode_string (const_tree expr, unsigned char *ptr, int len, int off)\n {\n-  if (! can_native_encode_string_p (expr))\n+  tree type = TREE_TYPE (expr);\n+\n+  /* Wide-char strings are encoded in target byte-order so native\n+     encoding them is trivial.  */\n+  if (BITS_PER_UNIT != CHAR_BIT\n+      || TREE_CODE (type) != ARRAY_TYPE\n+      || TREE_CODE (TREE_TYPE (type)) != INTEGER_TYPE\n+      || !tree_fits_shwi_p (TYPE_SIZE_UNIT (type)))\n     return 0;\n \n   HOST_WIDE_INT total_bytes = tree_to_shwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)));\n-  if ((off == -1 && total_bytes > len)\n-      || off >= total_bytes)\n+  if ((off == -1 && total_bytes > len) || off >= total_bytes)\n     return 0;\n   if (off == -1)\n     off = 0;\n-  if (TREE_STRING_LENGTH (expr) - off < MIN (total_bytes, len))\n+  if (ptr == NULL)\n+    /* Dry run.  */;\n+  else if (TREE_STRING_LENGTH (expr) - off < MIN (total_bytes, len))\n     {\n       int written = 0;\n       if (off < TREE_STRING_LENGTH (expr))\n@@ -7211,7 +7224,8 @@ native_encode_string (const_tree expr, unsigned char *ptr, int len, int off)\n \n /* Subroutine of fold_view_convert_expr.  Encode the INTEGER_CST,\n    REAL_CST, COMPLEX_CST or VECTOR_CST specified by EXPR into the\n-   buffer PTR of length LEN bytes.  If OFF is not -1 then start\n+   buffer PTR of length LEN bytes.  If PTR is NULL, don't actually store\n+   anything, just do a dry run.  If OFF is not -1 then start\n    the encoding at byte offset OFF and encode at most LEN bytes.\n    Return the number of bytes placed in the buffer, or zero upon failure.  */\n \n@@ -7459,43 +7473,6 @@ can_native_interpret_type_p (tree type)\n     }\n }\n \n-/* Return true iff a constant of type TYPE is accepted by\n-   native_encode_expr.  */\n-\n-bool\n-can_native_encode_type_p (tree type)\n-{\n-  switch (TREE_CODE (type))\n-    {\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case FIXED_POINT_TYPE:\n-    case COMPLEX_TYPE:\n-    case VECTOR_TYPE:\n-    case POINTER_TYPE:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Return true iff a STRING_CST S is accepted by\n-   native_encode_expr.  */\n-\n-bool\n-can_native_encode_string_p (const_tree expr)\n-{\n-  tree type = TREE_TYPE (expr);\n-\n-  /* Wide-char strings are encoded in target byte-order so native\n-     encoding them is trivial.  */\n-  if (BITS_PER_UNIT != CHAR_BIT\n-      || TREE_CODE (type) != ARRAY_TYPE\n-      || TREE_CODE (TREE_TYPE (type)) != INTEGER_TYPE\n-      || !tree_fits_shwi_p (TYPE_SIZE_UNIT (type)))\n-    return false;\n-  return true;\n-}\n \n /* Fold a VIEW_CONVERT_EXPR of a constant expression EXPR to type\n    TYPE at compile-time.  If we're unable to perform the conversion"}, {"sha": "0684ae762350730eba38f7caed3b961582f284f0", "filename": "gcc/fold-const.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -27,8 +27,6 @@ extern int folding_initializer;\n /* Convert between trees and native memory representation.  */\n extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);\n extern tree native_interpret_expr (tree, const unsigned char *, int);\n-extern bool can_native_encode_type_p (tree);\n-extern bool can_native_encode_string_p (const_tree);\n \n /* Fold constants as much as possible in an expression.\n    Returns the simplified expression."}, {"sha": "bc50bab3bae76165a9d4e4b886b17a3e1b9bcf53", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -357,8 +357,7 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n \t\t\t|| !int_mode_for_size (bitlen, 0).exists ());\n \n   if (!sub_byte_op_p)\n-    return (native_encode_expr (tmp_int, ptr + first_byte, total_bytes, 0)\n-\t    != 0);\n+    return native_encode_expr (tmp_int, ptr + first_byte, total_bytes) != 0;\n \n   /* LITTLE-ENDIAN\n      We are writing a non byte-sized quantity or at a position that is not\n@@ -408,7 +407,7 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n   memset (tmpbuf, '\\0', byte_size);\n   /* The store detection code should only have allowed constants that are\n      accepted by native_encode_expr.  */\n-  if (native_encode_expr (expr, tmpbuf, byte_size - 1, 0) == 0)\n+  if (native_encode_expr (expr, tmpbuf, byte_size - 1) == 0)\n     gcc_unreachable ();\n \n   /* The native_encode_expr machinery uses TYPE_MODE to determine how many\n@@ -1326,12 +1325,8 @@ lhs_valid_for_store_merging_p (tree lhs)\n static bool\n rhs_valid_for_store_merging_p (tree rhs)\n {\n-  tree type = TREE_TYPE (rhs);\n-  if (TREE_CODE_CLASS (TREE_CODE (rhs)) != tcc_constant\n-      || !can_native_encode_type_p (type))\n-    return false;\n-\n-  return true;\n+  return native_encode_expr (rhs, NULL,\n+\t\t\t     GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (rhs)))) != 0;\n }\n \n /* Entry point for the pass.  Go over each basic block recording chains of\n@@ -1357,7 +1352,7 @@ pass_store_merging::execute (function *fun)\n \t  if (is_gimple_debug (gsi_stmt (gsi)))\n \t    continue;\n \n-\t  if (++num_statements > 2)\n+\t  if (++num_statements >= 2)\n \t    break;\n \t}\n "}, {"sha": "266bedc792ae01acccbb3748a8feb15b99d3f6cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -1,3 +1,8 @@\n+2017-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/82434\n+\t* gcc.dg/store_merging_9.c: New test.\n+\n 2017-10-06  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82397"}, {"sha": "4c9f21ef62b522c3165aab5441a2c5dac58ee4fb", "filename": "gcc/testsuite/gcc.dg/store_merging_9.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_9.c?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -0,0 +1,33 @@\n+/* PR tree-optimization/82434 */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+enum E { E0, E1, E2 = __INT_MAX__, E3 = -__INT_MAX__ - 1 };\n+\n+struct bar {\n+  enum E a;\n+  char b;\n+  _Bool c;\n+  short d;\n+};\n+\n+void\n+foo1 (struct bar *p)\n+{\n+  p->b = 0;\n+  p->a = E0;\n+  p->c = (_Bool) 0;\n+  p->d = 0;\n+}\n+\n+void\n+foo2 (struct bar *p)\n+{\n+  p->b = 0;\n+  p->a = E0;\n+  p->c = (_Bool) 1;\n+  p->d = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */"}, {"sha": "f986b753c83b3bfe1ff36be7a70e8c0017bbbc9c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2f3914287d4c1c75394d4f101ad5bd4d9d4b66e8", "patch": "@@ -5728,10 +5728,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   op = gimple_assign_rhs1 (stmt);\n \n-  /* In the case this is a store from a STRING_CST make sure\n+  /* In the case this is a store from a constant make sure\n      native_encode_expr can handle it.  */\n-  if (TREE_CODE (op) == STRING_CST\n-      && ! can_native_encode_string_p (op))\n+  if (CONSTANT_CLASS_P (op) && native_encode_expr (op, NULL, 64) == 0)\n     return false;\n \n   if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt, &rhs_vectype))"}]}