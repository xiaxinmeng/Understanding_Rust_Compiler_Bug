{"sha": "591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkxMDk5Y2QxOWZjMmE5YjE3OThhMWQ0ZjM0ZDIzY2NlYzBhNmFhMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-05T13:56:00Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-05T13:56:00Z"}, "message": "* doc/cppinternals.texi: Update.\n\nFrom-SVN: r46033", "tree": {"sha": "14640fded15a72be01f6c64350a03882bbe00f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14640fded15a72be01f6c64350a03882bbe00f86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1/comments", "author": null, "committer": null, "parents": [{"sha": "523fbd9df50a45bf6543df72fcb0fa29fa4b12b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523fbd9df50a45bf6543df72fcb0fa29fa4b12b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523fbd9df50a45bf6543df72fcb0fa29fa4b12b9"}], "stats": {"total": 147, "additions": 138, "deletions": 9}, "files": [{"sha": "ee149b2b2d7ece603ba940f44be1e829da053041", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1", "patch": "@@ -1,3 +1,7 @@\n+2001-10-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* doc/cppinternals.texi: Update.\n+\n Fri Oct  5 08:17:46 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* config/i386/i386.c (ix86_split_to_parts): Use trunc_int_for_mode"}, {"sha": "ea8b13ee49e7d95ab1575333a2ca1a522bd11d9e", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 134, "deletions": 9, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=591099cd19fc2a9b1798a1d4f34d23ccec0a6aa1", "patch": "@@ -83,9 +83,11 @@ written with the preprocessing token as the fundamental unit; the\n preprocessor in previous versions of GCC would operate on text strings\n as the fundamental unit.\n \n-This brief manual documents some of the internals of cpplib, and a few\n-tricky issues encountered.  It also describes certain behaviour we would\n-like to preserve, such as the format and spacing of its output.\n+This brief manual documents the internals of cpplib, and explains some\n+of the tricky issues.  It is intended that, along with the comments in\n+the source code, a reasonably competent C programmer should be able to\n+figure out what the code is doing, and why things have been implemented\n+the way they have.\n \n @menu\n * Conventions::         Conventions used in the code.\n@@ -201,14 +203,14 @@ error about an unterminated macro argument list.\n The C standard also specifies that a new line in the middle of the\n arguments to a macro is treated as whitespace.  This white space is\n important in case the macro argument is stringified.  The state variable\n-@code{parsing_args} is non-zero when the preprocessor is collecting the\n+@var{parsing_args} is non-zero when the preprocessor is collecting the\n arguments to a macro call.  It is set to 1 when looking for the opening\n parenthesis to a function-like macro, and 2 when collecting the actual\n arguments up to the closing parenthesis, since these two cases need to\n be distinguished sometimes.  One such time is here: the lexer sets the\n @code{PREV_WHITE} flag of a token if it meets a new line when\n-@code{parsing_args} is set to 2.  It doesn't set it if it meets a new\n-line when @code{parsing_args} is 1, since then code like\n+@var{parsing_args} is set to 2.  It doesn't set it if it meets a new\n+line when @var{parsing_args} is 1, since then code like\n \n @smallexample\n #define foo() bar\n@@ -224,7 +226,7 @@ foo\n @end smallexample\n \n This is a good example of the subtlety of getting token spacing correct\n-in the preprocessor; there are plenty of tests in the test-suite for\n+in the preprocessor; there are plenty of tests in the test suite for\n corner cases like this.\n \n The lexer is written to treat each of @samp{\\r}, @samp{\\n}, @samp{\\r\\n}\n@@ -381,7 +383,7 @@ issues, but not all.  The opening parenthesis after a function-like\n macro name might lie on a different line, and the front ends definitely\n want the ability to look ahead past the end of the current line.  So\n cpplib only moves back to the start of the token run at the end of a\n-line if the variable @code{keep_tokens} is zero.  Line-buffering is\n+line if the variable @var{keep_tokens} is zero.  Line-buffering is\n quite natural for the preprocessor, and as a result the only time cpplib\n needs to increment this variable is whilst looking for the opening\n parenthesis to, and reading the arguments of, a function-like macro.  In\n@@ -623,8 +625,131 @@ variable, which is updated with every newline whether escaped or not.\n \n @node Guard Macros\n @unnumbered The Multiple-Include Optimization\n+@cindex guard macros\n+@cindex controlling macros\n+@cindex multiple-include optimization\n \n-@c TODO\n+Header files are often of the form\n+\n+@smallexample\n+#ifndef FOO\n+#define FOO\n+@dots{}\n+#endif\n+@end smallexample\n+\n+@noindent\n+to prevent the compiler from processing them more than once.  The\n+preprocessor notices such header files, so that if the header file\n+appears in a subsequent @code{#include} directive and @var{FOO} is\n+defined, then it is ignored and it doesn't preprocess or even re-open\n+the file a second time.  This is referred to as the @dfn{multiple\n+include optimization}.\n+\n+Under what circumstances is such an optimization valid?  If the file\n+were included a second time, it can only be optimized away if that\n+inclusion would result in no tokens to return, and no relevant\n+directives to process.  Therefore the current implementation imposes\n+requirements and makes some allowances as follows:\n+\n+@enumerate\n+@item\n+There must be no tokens outside the controlling @code{#if}-@code{#endif}\n+pair, but whitespace and comments are permitted.\n+\n+@item\n+There must be no directives outside the controlling directive pair, but\n+the @dfn{null directive} (a line containing nothing other than a single\n+@samp{#} and possibly whitespace) is permitted.\n+\n+@item\n+The opening directive must be of the form\n+\n+@display\n+#ifndef FOO\n+@end display\n+\n+or\n+\n+@display\n+#if !defined FOO     [equivalently, #if !defined(FOO)]\n+@end display\n+\n+@item\n+In the second form above, the tokens forming the @code{#if} expression\n+must have come directly from the source file---no macro expansion must\n+have been involved.  This is because macro definitions can change, and\n+tracking whether or not a relevant change has been made is not worth the\n+implementation cost.\n+\n+@item\n+There can be no @code{#else} or @code{#elif} directives at the outer\n+conditional block level, because they would probably contain something\n+of interest to a subsequent pass.\n+@end enumerate\n+\n+First, when pushing a new file on the buffer stack,\n+@code{_stack_include_file} sets the controlling macro @var{mi_cmacro} to\n+@code{NULL}, and sets @var{mi_valid} to @code{true}.  This indicates\n+that the preprocessor has not yet encountered anything that would\n+invalidate the multiple-include optimization.  As described in the next\n+few paragraphs, these two variables having these values effectively\n+indicates top-of-file.\n+\n+When about to return a token that is not part of a directive,\n+@code{_cpp_lex_token} sets @var{mi_valid} to @code{false}.  This\n+enforces the constraint that tokens outside the controlling conditional\n+block invalidate the optimization.\n+\n+The @code{do_if}, when appropriate, and @code{do_ifndef} directive\n+handlers pass the controlling macro to the function\n+@code{push_conditional}.  cpplib maintains a stack of nested conditional\n+blocks, and after processing every opening conditional this function\n+pushes an @code{if_stack} structure onto the stack.  In this structure\n+it records the controlling macro for the block, provided there is one\n+and we're at top-of-file (as described above).  If an @code{#elif} or\n+@code{#else} directive is encountered, the controlling macro for that\n+block is cleared to @code{NULL}.  Otherwise, it survives until the\n+@code{#endif} closing the block, upon which @code{do_endif} sets\n+@var{mi_valid} to true and stores the controlling macro in\n+@var{mi_cmacro}.\n+\n+@code{_cpp_handle_directive} clears @var{mi_valid} when processing any\n+directive other than an opening conditional and the null directive.\n+With this, and requiring top-of-file to record a controlling macro, and\n+no @code{#else} or @code{#elif} for it to survive and be copied to\n+@var{mi_cmacro} by @code{do_endif}, we have enforced the absence of\n+directives outside the main conditional block for the optimization to be\n+on.\n+\n+Note that whilst we are inside the conditional block, @var{mi_valid} is\n+likely to be reset to @code{false}, but this does not matter since the\n+the closing @code{#endif} restores it to @code{true} if appropriate.\n+\n+Finally, since @code{_cpp_lex_direct} pops the file off the buffer stack\n+at @code{EOF} without returning a token, if the @code{#endif} directive\n+was not followed by any tokens, @var{mi_valid} is @code{true} and\n+@code{_cpp_pop_file_buffer} remembers the controlling macro associated\n+with the file.  Subsequent calls to @code{stack_include_file} result in\n+no buffer being pushed if the controlling macro is defined, effecting\n+the optimization.\n+\n+A quick word on how we handle the\n+\n+@display\n+#if !defined FOO\n+@end display\n+\n+@noindent\n+case.  @code{_cpp_parse_expr} and @code{parse_defined} take steps to see\n+whether the three stages @samp{!}, @samp{defined-expression} and\n+@samp{end-of-directive} occur in order in a @code{#if} expression.  If\n+so, they return the guard macro to @code{do_if} in the variable\n+@var{mi_ind_cmacro}, and otherwise set it to @code{NULL}.\n+@code{enter_macro_context} sets @var{mi_valid} to false, so if a macro\n+was expanded whilst parsing any part of the expression, then the\n+top-of-file test in @code{push_conditional} fails and the optimization\n+is turned off.\n \n @node Files\n @unnumbered File Handling"}]}