{"sha": "c02a5ccbdf231861265f03f2e75dc7dc3665215b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyYTVjY2JkZjIzMTg2MTI2NWYwM2YyZTc1ZGM3ZGMzNjY1MjE1Yg==", "commit": {"author": {"name": "Sanjin Liu", "email": "scliu@faraday-tech.com", "date": "2010-12-20T17:48:51Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2010-12-20T17:48:51Z"}, "message": "arm-cores.def: Add Faraday CPU support - fa526/fa626/fa606te/fa626te/fmp626/fa726te.\n\n2010-12-20  Sanjin Liu\t<scliu@faraday-tech.com>\n\tMingfeng Wu  <mingfeng@faraday-tech.com>\n\n\t* config/arm/arm-cores.def: Add Faraday CPU support -\n\tfa526/fa626/fa606te/fa626te/fmp626/fa726te.\n\t* config/arm/arm-tune.md: Regenerate.\n\t* config/arm/arm.c (arm_fa726te_tune): New tune_params for fa726te\n\t(fa726te_sched_adjust_cost): New cost function for fa726te.\n\t(arm_issue_rate): Add fa726te.\n\t* config/arm/arm.md (generic_sched): Add Faraday cores to generic_sched\n\tand include machine description files.\n\t* config/arm/bpabi.h (TARGET_FIX_V4BX_SPEC): Add fa526 and fa626.\n\t* config/arm/t-arm (MD_INCLUDES): Include machine description files for\n\tFaraday cores.\n\t* config/arm/t-arm-elf: Add multilib option for Faraday cores.\n\t* config/arm/t-linux-eabi: Add multilib option for Faraday cores except\n\tfa526 and fa626.\n\t* doc/invoke.texi: Document -mcpu for Faraday cores.\n\t* config/arm/fa526.md: New file.\n\t* config/arm/fa606te.md: New file.\n\t* config/arm/fa626te.md: New file.\n\t* config/arm/fmp626.md: New file.\n\t* config/arm/fa726te.md: New file.\n\nCo-Authored-By: Mingfeng Wu <mingfeng@faraday-tech.com>\n\nFrom-SVN: r168090", "tree": {"sha": "4f20a6c8b1b8cb43b72df8a0c86c7e50f84b8ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f20a6c8b1b8cb43b72df8a0c86c7e50f84b8ea9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c02a5ccbdf231861265f03f2e75dc7dc3665215b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02a5ccbdf231861265f03f2e75dc7dc3665215b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02a5ccbdf231861265f03f2e75dc7dc3665215b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02a5ccbdf231861265f03f2e75dc7dc3665215b/comments", "author": null, "committer": null, "parents": [{"sha": "2e902fab1f52ee52202fd40913bdcdb515173d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e902fab1f52ee52202fd40913bdcdb515173d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e902fab1f52ee52202fd40913bdcdb515173d43"}], "stats": {"total": 1000, "additions": 995, "deletions": 5}, "files": [{"sha": "ee139cc6007078551f455e635c5c2eaf1edc9bdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -1,3 +1,27 @@\n+2010-12-20  Sanjin Liu\t<scliu@faraday-tech.com>\n+\tMingfeng Wu  <mingfeng@faraday-tech.com>\n+\n+\t* config/arm/arm-cores.def: Add Faraday CPU support -\n+\tfa526/fa626/fa606te/fa626te/fmp626/fa726te.\n+\t* config/arm/arm-tune.md: Regenerate.\n+\t* config/arm/arm.c (arm_fa726te_tune): New tune_params for fa726te\n+\t(fa726te_sched_adjust_cost): New cost function for fa726te.\n+\t(arm_issue_rate): Add fa726te.\n+\t* config/arm/arm.md (generic_sched): Add Faraday cores to generic_sched\n+\tand include machine description files.\n+\t* config/arm/bpabi.h (TARGET_FIX_V4BX_SPEC): Add fa526 and fa626.\n+\t* config/arm/t-arm (MD_INCLUDES): Include machine description files for\n+\tFaraday cores.\n+\t* config/arm/t-arm-elf: Add multilib option for Faraday cores.\n+\t* config/arm/t-linux-eabi: Add multilib option for Faraday cores except\n+\tfa526 and fa626.\n+\t* doc/invoke.texi: Document -mcpu for Faraday cores.\n+\t* config/arm/fa526.md: New file.\n+\t* config/arm/fa606te.md: New file.\n+\t* config/arm/fa626te.md: New file.\n+\t* config/arm/fmp626.md: New file.\n+\t* config/arm/fa726te.md: New file.\n+\n 2010-12-20  Yvan Roux  <yvan.roux@st.com>\n \n \t* config/arm/lib1funcs.asm (ARM_DIV_BODY case __OPTIMIZE_SIZE__): Fix"}, {"sha": "e06bf65bc516675313477669a1cf0c2e57389b66", "filename": "gcc/config/arm/arm-cores.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cores.def?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -74,6 +74,8 @@ ARM_CORE(\"strongarm\",     strongarm,\t4,\t             FL_MODE26 | FL_LDSCHED | FL\n ARM_CORE(\"strongarm110\",  strongarm110,\t4,\t             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)\n ARM_CORE(\"strongarm1100\", strongarm1100, 4,\t             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)\n ARM_CORE(\"strongarm1110\", strongarm1110, 4,\t             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)\n+ARM_CORE(\"fa526\",         fa526,        4,                               FL_LDSCHED, fastmul)\n+ARM_CORE(\"fa626\",         fa626,        4,                               FL_LDSCHED, fastmul)\n \n /* V4T Architecture Processors */\n ARM_CORE(\"arm7tdmi\",      arm7tdmi,\t4T,\tFL_CO_PROC          , fastmul)\n@@ -104,6 +106,10 @@ ARM_CORE(\"arm1022e\",      arm1022e,\t5TE,\t\t\t\t FL_LDSCHED, fastmul)\n ARM_CORE(\"xscale\",        xscale,\t5TE,\t                         FL_LDSCHED | FL_STRONG | FL_XSCALE, xscale)\n ARM_CORE(\"iwmmxt\",        iwmmxt,\t5TE,\t                         FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)\n ARM_CORE(\"iwmmxt2\",       iwmmxt2,\t5TE,\t                         FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)\n+ARM_CORE(\"fa606te\",       fa606te,      5TE,                             FL_LDSCHED, 9e)\n+ARM_CORE(\"fa626te\",       fa626te,      5TE,                             FL_LDSCHED, 9e)\n+ARM_CORE(\"fmp626\",        fmp626,       5TE,                             FL_LDSCHED, 9e)\n+ARM_CORE(\"fa726te\",       fa726te,      5TE,                             FL_LDSCHED, fa726te)\n \n /* V5TEJ Architecture Processors */\n ARM_CORE(\"arm926ej-s\",    arm926ejs,\t5TEJ,\t                         FL_LDSCHED, 9e)"}, {"sha": "9b664e7e66ba712920fa6a48ba31f0172b44be05", "filename": "gcc/config/arm/arm-tune.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm-tune.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm-tune.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-tune.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -1,5 +1,5 @@\n ;; -*- buffer-read-only: t -*-\n ;; Generated automatically by gentune.sh from arm-cores.def\n (define_attr \"tune\"\n-\t\"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,arm1156t2fs,cortexa5,cortexa8,cortexa9,cortexa15,cortexr4,cortexr4f,cortexm4,cortexm3,cortexm1,cortexm0\"\n+\t\"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,fa526,fa626,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,fa606te,fa626te,fmp626,fa726te,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,arm1156t2fs,cortexa5,cortexa8,cortexa9,cortexa15,cortexr4,cortexr4f,cortexm4,cortexm3,cortexm1,cortexm0\"\n \t(const (symbol_ref \"((enum attr_tune) arm_tune)\")))"}, {"sha": "be7bb060bedc18c42533c5dae1e00b4a91922d75", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -240,6 +240,7 @@ static rtx arm_trampoline_adjust_address (rtx);\n static rtx arm_pic_static_addr (rtx orig, rtx reg);\n static bool cortex_a9_sched_adjust_cost (rtx, rtx, rtx, int *);\n static bool xscale_sched_adjust_cost (rtx, rtx, rtx, int *);\n+static bool fa726te_sched_adjust_cost (rtx, rtx, rtx, int *);\n static enum machine_mode arm_preferred_simd_mode (enum machine_mode);\n static bool arm_class_likely_spilled_p (reg_class_t);\n static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);\n@@ -886,6 +887,14 @@ const struct tune_params arm_cortex_a9_tune =\n   ARM_PREFETCH_BENEFICIAL(4,32,32)\n };\n \n+const struct tune_params arm_fa726te_tune =\n+{\n+  arm_9e_rtx_costs,\n+  fa726te_sched_adjust_cost,\n+  1,\n+  ARM_PREFETCH_NOT_BENEFICIAL\n+};\n+\n \n /* Not all of these give usefully different compilation alternatives,\n    but there is no simple way of generalizing them.  */\n@@ -7996,6 +8005,36 @@ cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n   return true;\n }\n \n+/* Adjust cost hook for FA726TE.  */\n+static bool\n+fa726te_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n+{\n+  /* For FA726TE, true dependency on CPSR (i.e. set cond followed by predicated)\n+     have penalty of 3.  */\n+  if (REG_NOTE_KIND (link) == REG_DEP_TRUE\n+      && recog_memoized (insn) >= 0\n+      && recog_memoized (dep) >= 0\n+      && get_attr_conds (dep) == CONDS_SET)\n+    {\n+      /* Use of carry (e.g. 64-bit arithmetic) in ALU: 3-cycle latency.  */\n+      if (get_attr_conds (insn) == CONDS_USE\n+          && get_attr_type (insn) != TYPE_BRANCH)\n+        {\n+          *cost = 3;\n+          return false;\n+        }\n+\n+      if (GET_CODE (PATTERN (insn)) == COND_EXEC\n+          || get_attr_conds (insn) == CONDS_USE)\n+        {\n+          *cost = 0;\n+          return false;\n+        }\n+    }\n+\n+  return true;\n+}\n+\n /* This function implements the target macro TARGET_SCHED_ADJUST_COST.\n    It corrects the value of COST based on the relationship between\n    INSN and DEP through the dependence LINK.  It returns the new\n@@ -22840,6 +22879,7 @@ arm_issue_rate (void)\n     case cortexa5:\n     case cortexa8:\n     case cortexa9:\n+    case fa726te:\n       return 2;\n \n     default:"}, {"sha": "5a9a914da4d94f9a0efd901c075352e28fd7e998", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -498,7 +498,7 @@\n \n (define_attr \"generic_sched\" \"yes,no\"\n   (const (if_then_else\n-          (ior (eq_attr \"tune\" \"arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa5,cortexa8,cortexa9,cortexm4\")\n+          (ior (eq_attr \"tune\" \"fa526,fa626,fa606te,fa626te,fmp626,fa726te,arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa5,cortexa8,cortexa9,cortexm4\")\n \t       (eq_attr \"tune_cortexr4\" \"yes\"))\n           (const_string \"no\")\n           (const_string \"yes\"))))\n@@ -516,6 +516,11 @@\n (include \"arm1020e.md\")\n (include \"arm1026ejs.md\")\n (include \"arm1136jfs.md\")\n+(include \"fa526.md\")\n+(include \"fa606te.md\")\n+(include \"fa626te.md\")\n+(include \"fmp626.md\")\n+(include \"fa726te.md\")\n (include \"cortex-a5.md\")\n (include \"cortex-a8.md\")\n (include \"cortex-a9.md\")"}, {"sha": "7b5ee62310702ac9f8b7a3214b9743424bcedfb3", "filename": "gcc/config/arm/bpabi.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Fbpabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Fbpabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fbpabi.h?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -52,13 +52,16 @@\n /* The BPABI integer comparison routines return { -1, 0, 1 }.  */\n #define TARGET_LIB_INT_CMP_BIASED !TARGET_BPABI\n \n-#define TARGET_FIX_V4BX_SPEC \" %{mcpu=arm8|mcpu=arm810|mcpu=strongarm*|march=armv4:--fix-v4bx}\"\n+#define TARGET_FIX_V4BX_SPEC \" %{mcpu=arm8|mcpu=arm810|mcpu=strongarm*\"\\\n+  \"|march=armv4|mcpu=fa526|mcpu=fa626:--fix-v4bx}\"\n \n-#define BE8_LINK_SPEC \" %{mbig-endian:%{march=armv7-a|mcpu=cortex-a5|mcpu=cortex-a8|mcpu=cortex-a9|mcpu=cortex-a15:%{!r:--be8}}}\"\n+#define BE8_LINK_SPEC \" %{mbig-endian:%{march=armv7-a|mcpu=cortex-a5\"\\\n+  \"|mcpu=cortex-a8|mcpu=cortex-a9|mcpu=cortex-a15:%{!r:--be8}}}\"\n \n /* Tell the assembler to build BPABI binaries.  */\n #undef  SUBTARGET_EXTRA_ASM_SPEC\n-#define SUBTARGET_EXTRA_ASM_SPEC \"%{mabi=apcs-gnu|mabi=atpcs:-meabi=gnu;:-meabi=5}\" TARGET_FIX_V4BX_SPEC\n+#define SUBTARGET_EXTRA_ASM_SPEC \\\n+  \"%{mabi=apcs-gnu|mabi=atpcs:-meabi=gnu;:-meabi=5}\" TARGET_FIX_V4BX_SPEC\n \n #ifndef SUBTARGET_EXTRA_LINK_SPEC\n #define SUBTARGET_EXTRA_LINK_SPEC \"\""}, {"sha": "42eb9b272fb1b9df553c566e8c41cb4d44c306ca", "filename": "gcc/config/arm/fa526.md", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa526.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa526.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa526.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -0,0 +1,161 @@\n+;; Faraday FA526 Pipeline Description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Written by I-Jui Sung, based on ARM926EJ-S Pipeline Description.\n+\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; FA526 Core Design Note, Copyright (c) 2010 Faraday Technology Corp.\n+;;\n+;; Modeled pipeline characteristics:\n+;; LD -> any use: latency = 3 (2 cycle penalty).\n+;; ALU -> any use: latency = 2 (1 cycle penalty).\n+\n+;; This automaton provides a pipeline description for the Faraday\n+;; FA526 core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"fa526\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There is a single pipeline\n+;;\n+;;   The ALU pipeline has fetch, decode, execute, memory, and\n+;;   write stages.  We only need to model the execute, memory and write\n+;;   stages.\n+\n+;;      S      E      M      W\n+\n+(define_cpu_unit \"fa526_core\" \"fa526\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require two cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations\n+(define_insn_reservation \"526_alu_op\" 1\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"alu\"))\n+ \"fa526_core\")\n+\n+(define_insn_reservation \"526_alu_shift_op\" 2\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"alu_shift,alu_shift_reg\"))\n+ \"fa526_core\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn_reservation \"526_mult1\" 2\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"insn\" \"smlalxy,smulxy,smlaxy,smlalxy\"))\n+ \"fa526_core\")\n+\n+(define_insn_reservation \"526_mult2\" 5\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"insn\" \"mul,mla,muls,mlas,umull,umlal,smull,smlal,umulls,\\\n+                       umlals,smulls,smlals,smlawx\"))\n+ \"fa526_core*4\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+(define_insn_reservation \"526_load1_op\" 3\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"load1,load_byte\"))\n+ \"fa526_core\")\n+\n+(define_insn_reservation \"526_load2_op\" 4\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"load2\"))\n+ \"fa526_core*2\")\n+\n+(define_insn_reservation \"526_load3_op\" 5\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"load3\"))\n+ \"fa526_core*3\")\n+\n+(define_insn_reservation \"526_load4_op\" 6\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"load4\"))\n+ \"fa526_core*4\")\n+\n+(define_insn_reservation \"526_store1_op\" 0\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"fa526_core\")\n+\n+(define_insn_reservation \"526_store2_op\" 1\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"store2\"))\n+ \"fa526_core*2\")\n+\n+(define_insn_reservation \"526_store3_op\" 2\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"store3\"))\n+ \"fa526_core*3\")\n+\n+(define_insn_reservation \"526_store4_op\" 3\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"store4\"))\n+ \"fa526_core*4\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The FA526\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycle to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"526_branch_op\" 0\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"fa526_core\")\n+\n+;; The latency for a call is actually the latency when the result is available.\n+;; i.e. R0 ready for int return value.  For most cases, the return value is set\n+;; by a mov instruction, which has 1 cycle latency.\n+(define_insn_reservation \"526_call_op\" 1\n+ (and (eq_attr \"tune\" \"fa526\")\n+      (eq_attr \"type\" \"call\"))\n+ \"fa526_core\")\n+"}, {"sha": "06e63d696bde2e13556982e053cf2b0fd719d1ce", "filename": "gcc/config/arm/fa606te.md", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa606te.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa606te.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa606te.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -0,0 +1,171 @@\n+;; Faraday FA606TE Pipeline Description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Written by Mingfeng Wu, based on ARM926EJ-S Pipeline Description.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; FA606TE Core Design Note, Copyright (c) 2010 Faraday Technology Corp.\n+\n+;; Modeled pipeline characteristics:\n+;; LD -> any use: latency = 2 (1 cycle penalty).\n+;; ALU -> any use: latency = 1 (0 cycle penalty).\n+\n+;; This automaton provides a pipeline description for the Faraday\n+;; FA606TE core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"fa606te\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There is a single pipeline\n+;;\n+;;   The ALU pipeline has fetch, decode, execute, memory, and\n+;;   write stages.  We only need to model the execute, memory and write\n+;;   stages.\n+\n+;;      E      M      W\n+\n+(define_cpu_unit \"fa606te_core\" \"fa606te\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require two cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations\n+(define_insn_reservation \"606te_alu_op\" 1\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"alu,alu_shift,alu_shift_reg\"))\n+ \"fa606te_core\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn_reservation \"606te_mult1\" 2\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"insn\" \"smlalxy\"))\n+ \"fa606te_core\")\n+\n+(define_insn_reservation \"606te_mult2\" 3\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"insn\" \"smlaxy,smulxy,smulwy,smlawy\"))\n+ \"fa606te_core*2\")\n+\n+(define_insn_reservation \"606te_mult3\" 4\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"insn\" \"mul,mla,muls,mlas\"))\n+ \"fa606te_core*3\")\n+\n+(define_insn_reservation \"606te_mult4\" 5\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"insn\" \"umull,umlal,smull,smlal,umulls,umlals,smulls,smlals\"))\n+ \"fa606te_core*4\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+(define_insn_reservation \"606te_load1_op\" 2\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"load1,load_byte\"))\n+ \"fa606te_core\")\n+\n+(define_insn_reservation \"606te_load2_op\" 3\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"load2\"))\n+ \"fa606te_core*2\")\n+\n+(define_insn_reservation \"606te_load3_op\" 4\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"load3\"))\n+ \"fa606te_core*3\")\n+\n+(define_insn_reservation \"606te_load4_op\" 5\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"load4\"))\n+ \"fa606te_core*4\")\n+\n+(define_insn_reservation \"606te_store1_op\" 0\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"fa606te_core\")\n+\n+(define_insn_reservation \"606te_store2_op\" 1\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"store2\"))\n+ \"fa606te_core*2\")\n+\n+(define_insn_reservation \"606te_store3_op\" 2\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"store3\"))\n+ \"fa606te_core*3\")\n+\n+(define_insn_reservation \"606te_store4_op\" 3\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"store4\"))\n+ \"fa606te_core*4\")\n+\n+\n+;;(define_insn_reservation \"606te_ldm_op\" 9\n+;; (and (eq_attr \"tune\" \"fa606te\")\n+;;      (eq_attr \"type\" \"load2,load3,load4,store2,store3,store4\"))\n+;; \"fa606te_core*7\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The FA606TE\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycles to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"606te_branch_op\" 0\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"fa606te_core\")\n+\n+;; The latency for a call is actually the latency when the result is available.\n+;; i.e. R0 ready for int return value.  For most cases, the return value is set\n+;; by a mov instruction, which has 1 cycle latency.\n+(define_insn_reservation \"606te_call_op\" 1\n+ (and (eq_attr \"tune\" \"fa606te\")\n+      (eq_attr \"type\" \"call\"))\n+ \"fa606te_core\")\n+"}, {"sha": "7fe1c8724bef3feae8a291777379a5dac3cf31d1", "filename": "gcc/config/arm/fa626te.md", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa626te.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa626te.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa626te.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -0,0 +1,165 @@\n+;; Faraday FA626TE Pipeline Description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Written by I-Jui Sung, based on ARM926EJ-S Pipeline Description.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; FA626TE Core Design Note, Copyright (c) 2010 Faraday Technology Corp.\n+\n+;; Modeled pipeline characteristics:\n+;; ALU -> simple address LDR/STR: latency = 2 (available after 2 cycles).\n+;; ALU -> shifted address LDR/STR: latency = 3.\n+;;\t\t( extra 1 cycle unavoidable stall).\n+;; ALU -> other use: latency = 2 (available after 2 cycles).\n+;; LD  -> simple address LDR/STR: latency = 3 (available after 3 cycles).\n+;; LD  -> shifted address LDR/STR: latency = 4\n+;;\t\t( extra 1 cycle unavoidable stall).\n+;; LD  -> any other use: latency = 3 (available after 3 cycles).\n+\n+;; This automaton provides a pipeline description for the Faraday\n+;; FA626TE core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"fa626te\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There is a single pipeline\n+;;\n+;;   The ALU pipeline has fetch, decode, execute, memory, and\n+;;   write stages.  We only need to model the execute, memory and write\n+;;   stages.\n+\n+;;      S      E      M      W\n+\n+(define_cpu_unit \"fa626te_core\" \"fa626te\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require two cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations\n+(define_insn_reservation \"626te_alu_op\" 1\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"alu\"))\n+ \"fa626te_core\")\n+\n+(define_insn_reservation \"626te_alu_shift_op\" 2\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"alu_shift,alu_shift_reg\"))\n+ \"fa626te_core\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn_reservation \"626te_mult1\" 2\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"insn\" \"smulwy,smlawy,smulxy,smlaxy\"))\n+ \"fa626te_core\")\n+\n+(define_insn_reservation \"626te_mult2\" 2\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"insn\" \"mul,mla\"))\n+ \"fa626te_core\")\n+\n+(define_insn_reservation \"626te_mult3\" 3\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"insn\" \"muls,mlas,smull,smlal,umull,umlal,smlalxy,smlawx\"))\n+ \"fa626te_core*2\")\n+\n+(define_insn_reservation \"626te_mult4\" 4\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"insn\" \"smulls,smlals,umulls,umlals\"))\n+ \"fa626te_core*3\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+(define_insn_reservation \"626te_load1_op\" 3\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"load1,load_byte\"))\n+ \"fa626te_core\")\n+\n+(define_insn_reservation \"626te_load2_op\" 4\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"load2,load3\"))\n+ \"fa626te_core*2\")\n+\n+(define_insn_reservation \"626te_load3_op\" 5\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"load4\"))\n+ \"fa626te_core*3\")\n+\n+(define_insn_reservation \"626te_store1_op\" 0\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"fa626te_core\")\n+\n+(define_insn_reservation \"626te_store2_op\" 1\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"store2,store3\"))\n+ \"fa626te_core*2\")\n+\n+(define_insn_reservation \"626te_store3_op\" 2\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"store4\"))\n+ \"fa626te_core*3\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The FA626TE\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycle to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"626te_branch_op\" 0\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"fa626te_core\")\n+\n+;; The latency for a call is actually the latency when the result is available.\n+;; i.e. R0 ready for int return value. \n+(define_insn_reservation \"626te_call_op\" 1\n+ (and (eq_attr \"tune\" \"fa626,fa626te\")\n+      (eq_attr \"type\" \"call\"))\n+ \"fa626te_core\")\n+"}, {"sha": "3c33d59710478a5a46435e4df3177bbfcca1faff", "filename": "gcc/config/arm/fa726te.md", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa726te.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffa726te.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa726te.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -0,0 +1,218 @@\n+;; Faraday FA726TE Pipeline Description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Written by I-Jui Sung, based on ARM926EJ-S Pipeline Description.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; FA726TE Core Design Note, Copyright (c) 2010 Faraday Technology Corp.\n+\n+;; This automaton provides a pipeline description for the Faraday\n+;; FA726TE core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"fa726te\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;;   The ALU pipeline has fetch, decode, execute, memory, and\n+;;   write stages.  We only need to model the execute, memory and write\n+;;   stages.\n+\n+;;\tE1\tE2\tE3\tE4\tE5\tWB\n+;;______________________________________________________\n+;;\n+;;      <-------------- LD/ST ----------->\n+;;    shifter + LU      <-- AU -->\n+;;      <-- AU -->     shifter + LU    CPSR     (Pipe 0)\n+;;______________________________________________________\n+;;\n+;;      <---------- MUL --------->\n+;;    shifter + LU      <-- AU -->\n+;;      <-- AU -->     shifter + LU    CPSR     (Pipe 1)\n+\n+\n+(define_cpu_unit \"fa726te_alu0_pipe,fa726te_alu1_pipe\" \"fa726te\")\n+(define_cpu_unit \"fa726te_mac_pipe\" \"fa726te\")\n+(define_cpu_unit \"fa726te_lsu_pipe_e,fa726te_lsu_pipe_w\" \"fa726te\")\n+\n+;; Pretend we have 2 LSUs (the second is ONLY for LDR), which can possibly\n+;; improve code quality.\n+(define_query_cpu_unit \"fa726te_lsu1_pipe_e,fa726te_lsu1_pipe_w\" \"fa726te\")\n+(define_cpu_unit \"fa726te_is0,fa726te_is1\" \"fa726te\")\n+\n+(define_reservation \"fa726te_issue\" \"(fa726te_is0|fa726te_is1)\")\n+;; Reservation to restrict issue to 1.\n+(define_reservation \"fa726te_blockage\" \"(fa726te_is0+fa726te_is1)\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require three cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; Move instructions.\n+(define_insn_reservation \"726te_shift_op\" 1\n+  (and (eq_attr \"tune\" \"fa726te\")\n+       (eq_attr \"insn\" \"mov,mvn\"))\n+  \"fa726te_issue+(fa726te_alu0_pipe|fa726te_alu1_pipe)\")\n+\n+;; ALU operations with no shifted operand will finished in 1 cycle\n+;; Other ALU instructions 2 cycles.\n+(define_insn_reservation \"726te_alu_op\" 1\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (and (eq_attr \"type\" \"alu\")\n+           (not (eq_attr \"insn\" \"mov,mvn\"))))\n+  \"fa726te_issue+(fa726te_alu0_pipe|fa726te_alu1_pipe)\")\n+\n+;; ALU operations with a shift-by-register operand.\n+;; These really stall in the decoder, in order to read the shift value\n+;; in the first cycle.  If the instruction uses both shifter and AU,\n+;; it takes 3 cycles.\n+(define_insn_reservation \"726te_alu_shift_op\" 3\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (and (eq_attr \"type\" \"alu_shift\")\n+           (not (eq_attr \"insn\" \"mov,mvn\"))))\n+  \"fa726te_issue+(fa726te_alu0_pipe|fa726te_alu1_pipe)\")\n+\n+(define_insn_reservation \"726te_alu_shift_reg_op\" 3\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (and (eq_attr \"type\" \"alu_shift_reg\")\n+           (not (eq_attr \"insn\" \"mov,mvn\"))))\n+  \"fa726te_issue+(fa726te_alu0_pipe|fa726te_alu1_pipe)\")\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Multiplication instructions loop in the execute stage until the\n+;; instruction has been passed through the multiplier array enough\n+;; times.  Multiply operations occur in both the execute and memory\n+;; stages of the pipeline\n+\n+(define_insn_reservation \"726te_mult_op\" 3\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"insn\" \"smlalxy,mul,mla,muls,mlas,umull,umlal,smull,smlal,\\\n+                       umulls,umlals,smulls,smlals,smlawx,smulxy,smlaxy\"))\n+ \"fa726te_issue+fa726te_mac_pipe\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+;; Loads with a shifted offset take 3 cycles, and are (a) probably the\n+;; most common and (b) the pessimistic assumption will lead to fewer stalls.\n+\n+;; Scalar loads are pipelined in FA726TE LSU pipe.\n+;; Here we model the resource conflict between Load@E3-stage & Store@W-stage.\n+;; The 2nd LSU (lsu1) is to model the fact that if 2 loads are scheduled in the\n+;; same \"bundle\", and the 2nd load will introudce another ISSUE stall but is\n+;; still ok to execute (and may be benefical sometimes).\n+\n+(define_insn_reservation \"726te_load1_op\" 3\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"load1,load_byte\"))\n+ \"(fa726te_issue+fa726te_lsu_pipe_e+fa726te_lsu_pipe_w)\\\n+  | (fa726te_issue+fa726te_lsu1_pipe_e+fa726te_lsu1_pipe_w,fa726te_blockage)\")\n+\n+(define_insn_reservation \"726te_store1_op\" 1\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"fa726te_blockage*2\")\n+\n+;; Load/Store Multiple blocks all pipelines in EX stages until WB.\n+;; No other instructions can be issued together.  Since they essentially\n+;; prevent all scheduling opportunities, we model them together here.\n+\n+;; The LDM is breaking into multiple load instructions, later instruction in\n+;; the pipe 1 is stalled.\n+(define_insn_reservation \"726te_ldm2_op\" 4\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"load2,load3\"))\n+ \"fa726te_blockage*4\")\n+\n+(define_insn_reservation \"726te_ldm3_op\" 5\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"load4\"))\n+ \"fa726te_blockage*5\")\n+\n+(define_insn_reservation \"726te_stm2_op\" 2\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"store2,store3\"))\n+ \"fa726te_blockage*3\")\n+\n+(define_insn_reservation \"726te_stm3_op\" 3\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"store4\"))\n+ \"fa726te_blockage*4\")\n+\n+(define_bypass 1 \"726te_load1_op,726te_ldm2_op,726te_ldm3_op\" \"726te_store1_op,\\\n+                  726te_stm2_op,726te_stm3_op\" \"arm_no_early_store_addr_dep\")\n+(define_bypass 0 \"726te_shift_op,726te_alu_op,726te_alu_shift_op,\\\n+                 726te_alu_shift_reg_op,726te_mult_op\" \"726te_store1_op\"\n+                 \"arm_no_early_store_addr_dep\")\n+(define_bypass 0 \"726te_shift_op,726te_alu_op\" \"726te_shift_op,726te_alu_op\")\n+(define_bypass 1 \"726te_alu_shift_op,726te_alu_shift_reg_op\"\n+                 \"726te_shift_op,726te_alu_op\")\n+(define_bypass 1 \"726te_alu_shift_op,726te_alu_shift_reg_op,726te_mult_op\"\n+                 \"726te_alu_shift_op\" \"arm_no_early_alu_shift_dep\")\n+(define_bypass 1 \"726te_alu_shift_op,726te_alu_shift_reg_op,726te_mult_op\"\n+                 \"726te_alu_shift_reg_op\" \"arm_no_early_alu_shift_value_dep\")\n+(define_bypass 1 \"726te_mult_op\" \"726te_shift_op,726te_alu_op\")\n+\n+(define_bypass 4 \"726te_load1_op\" \"726te_mult_op\")\n+(define_bypass 5 \"726te_ldm2_op\" \"726te_mult_op\")\n+(define_bypass 6 \"726te_ldm3_op\" \"726te_mult_op\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The FA726TE\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycle to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"726te_branch_op\" 0\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"fa726te_blockage\")\n+\n+;; The latency for a call is actually the latency when the result is available.\n+;; i.e. R0 is ready for int return value.\n+(define_insn_reservation \"726te_call_op\" 1\n+ (and (eq_attr \"tune\" \"fa726te\")\n+      (eq_attr \"type\" \"call\"))\n+ \"fa726te_blockage\")\n+"}, {"sha": "9ba33ddec4741ef3124c23ca8cf9f42f38feb6c8", "filename": "gcc/config/arm/fmp626.md", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffmp626.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ffmp626.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffmp626.md?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -0,0 +1,182 @@\n+;; Faraday FA626TE Pipeline Description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Written by Mingfeng Wu, based on ARM926EJ-S Pipeline Description.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; FMP626 Core Design Note, Copyright (c) 2010 Faraday Technology Corp.\n+\n+;; Pipeline architecture\n+;;\tS\tE\tM\tW(Q1)\tQ2\n+;;   ___________________________________________\n+;;    shifter alu\n+;;    mul1    mul2    mul3\n+;;    ld/st1  ld/st2  ld/st3  ld/st4  ld/st5\n+\n+;; This automaton provides a pipeline description for the Faraday\n+;; FMP626 core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"fmp626\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There is a single pipeline\n+;;\n+;;   The ALU pipeline has fetch, decode, execute, memory, and\n+;;   write stages.  We only need to model the execute, memory and write\n+;;   stages.\n+\n+(define_cpu_unit \"fmp626_core\" \"fmp626\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require two cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations\n+(define_insn_reservation \"mp626_alu_op\" 1\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"alu\"))\n+ \"fmp626_core\")\n+\n+(define_insn_reservation \"mp626_alu_shift_op\" 2\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"alu_shift,alu_shift_reg\"))\n+ \"fmp626_core\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_insn_reservation \"mp626_mult1\" 2\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"insn\" \"smulwy,smlawy,smulxy,smlaxy\"))\n+ \"fmp626_core\")\n+\n+(define_insn_reservation \"mp626_mult2\" 2\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"insn\" \"mul,mla\"))\n+ \"fmp626_core\")\n+\n+(define_insn_reservation \"mp626_mult3\" 3\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"insn\" \"muls,mlas,smull,smlal,umull,umlal,smlalxy,smlawx\"))\n+ \"fmp626_core*2\")\n+\n+(define_insn_reservation \"mp626_mult4\" 4\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"insn\" \"smulls,smlals,umulls,umlals\"))\n+ \"fmp626_core*3\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+(define_insn_reservation \"mp626_load1_op\" 5\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"load1,load_byte\"))\n+ \"fmp626_core\")\n+\n+(define_insn_reservation \"mp626_load2_op\" 6\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"load2,load3\"))\n+ \"fmp626_core*2\")\n+\n+(define_insn_reservation \"mp626_load3_op\" 7\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"load4\"))\n+ \"fmp626_core*3\")\n+\n+(define_insn_reservation \"mp626_store1_op\" 0\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"fmp626_core\")\n+\n+(define_insn_reservation \"mp626_store2_op\" 1\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"store2,store3\"))\n+ \"fmp626_core*2\")\n+\n+(define_insn_reservation \"mp626_store3_op\" 2\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"store4\"))\n+ \"fmp626_core*3\")\n+\n+(define_bypass 1 \"mp626_load1_op,mp626_load2_op,mp626_load3_op\"\n+                 \"mp626_store1_op,mp626_store2_op,mp626_store3_op\"\n+                 \"arm_no_early_store_addr_dep\")\n+(define_bypass 1 \"mp626_alu_op,mp626_alu_shift_op,mp626_mult1,mp626_mult2,\\\n+                  mp626_mult3,mp626_mult4\" \"mp626_store1_op\"\n+                 \"arm_no_early_store_addr_dep\")\n+(define_bypass 1 \"mp626_alu_shift_op\" \"mp626_alu_op\")\n+(define_bypass 1 \"mp626_alu_shift_op\" \"mp626_alu_shift_op\"\n+                 \"arm_no_early_alu_shift_dep\")\n+(define_bypass 1 \"mp626_mult1,mp626_mult2\" \"mp626_alu_shift_op\"\n+                 \"arm_no_early_alu_shift_dep\")\n+(define_bypass 2 \"mp626_mult3\" \"mp626_alu_shift_op\"\n+                 \"arm_no_early_alu_shift_dep\")\n+(define_bypass 3 \"mp626_mult4\" \"mp626_alu_shift_op\"\n+                 \"arm_no_early_alu_shift_dep\")\n+(define_bypass 1 \"mp626_mult1,mp626_mult2\" \"mp626_alu_op\")\n+(define_bypass 2 \"mp626_mult3\" \"mp626_alu_op\")\n+(define_bypass 3 \"mp626_mult4\" \"mp626_alu_op\")\n+(define_bypass 4 \"mp626_load1_op\" \"mp626_alu_op\")\n+(define_bypass 5 \"mp626_load2_op\" \"mp626_alu_op\")\n+(define_bypass 6 \"mp626_load3_op\" \"mp626_alu_op\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The FMP626\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycle to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"mp626_branch_op\" 0\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"fmp626_core\")\n+\n+;; The latency for a call is actually the latency when the result is available.\n+;; i.e. R0 ready for int return value.\n+(define_insn_reservation \"mp626_call_op\" 1\n+ (and (eq_attr \"tune\" \"fmp626\")\n+      (eq_attr \"type\" \"call\"))\n+ \"fmp626_core\")\n+"}, {"sha": "0f05f0dea4353e4efef541a7ed218697f02e6f72", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -24,6 +24,11 @@ MD_INCLUDES= \t$(srcdir)/config/arm/arm-tune.md \\\n \t\t$(srcdir)/config/arm/arm1020e.md \\\n \t\t$(srcdir)/config/arm/arm1026ejs.md \\\n \t\t$(srcdir)/config/arm/arm1136jfs.md \\\n+\t\t$(srcdir)/config/arm/fa526.md \\\n+\t\t$(srcdir)/config/arm/fa606te.md \\\n+\t\t$(srcdir)/config/arm/fa626te.md \\\n+\t\t$(srcdir)/config/arm/fmp626.md \\\n+\t\t$(srcdir)/config/arm/fa726te.md \\\n \t\t$(srcdir)/config/arm/arm926ejs.md \\\n \t\t$(srcdir)/config/arm/cirrus.md \\\n \t\t$(srcdir)/config/arm/fpa.md \\"}, {"sha": "eb2752cc67ca3251531a67b948bcd9b56307e24c", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -36,6 +36,10 @@ MULTILIB_DIRNAMES    = arm thumb\n MULTILIB_EXCEPTIONS  = \n MULTILIB_MATCHES     =\n \n+#MULTILIB_OPTIONS     += mcpu=fa526/mcpu=fa626/mcpu=fa606te/mcpu=fa626te/mcpu=fmp626/mcpu=fa726te\n+#MULTILIB_DIRNAMES    += fa526 fa626 fa606te fa626te fmp626 fa726te\n+#MULTILIB_EXCEPTIONS  += *mthumb*/*mcpu=fa526 *mthumb*/*mcpu=fa626\n+\n #MULTILIB_OPTIONS      += march=armv7\n #MULTILIB_DIRNAMES     += thumb2\n #MULTILIB_EXCEPTIONS   += march=armv7* marm/*march=armv7*\n@@ -52,6 +56,8 @@ MULTILIB_MATCHES     =\n MULTILIB_OPTIONS       += mfloat-abi=hard\n MULTILIB_DIRNAMES      += fpu\n MULTILIB_EXCEPTIONS    += *mthumb/*mfloat-abi=hard*\n+#MULTILIB_EXCEPTIONS    += *mcpu=fa526/*mfloat-abi=hard*\n+#MULTILIB_EXCEPTIONS    += *mcpu=fa626/*mfloat-abi=hard*\n \n # MULTILIB_OPTIONS    += mcpu=ep9312\n # MULTILIB_DIRNAMES   += ep9312"}, {"sha": "9a2f3b8d4cee63e229842765339477acbdca759d", "filename": "gcc/config/arm/t-linux-eabi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ft-linux-eabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02a5ccbdf231861265f03f2e75dc7dc3665215b/gcc%2Fconfig%2Farm%2Ft-linux-eabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-linux-eabi?ref=c02a5ccbdf231861265f03f2e75dc7dc3665215b", "patch": "@@ -24,6 +24,10 @@ TARGET_LIBGCC2_CFLAGS = -fPIC\n MULTILIB_OPTIONS\t=\n MULTILIB_DIRNAMES\t=\n \n+#MULTILIB_OPTIONS     += mcpu=fa606te/mcpu=fa626te/mcpu=fmp626/mcpu=fa726te\n+#MULTILIB_DIRNAMES    += fa606te fa626te fmp626 fa726te\n+#MULTILIB_EXCEPTIONS  += *mthumb/*mcpu=fa606te *mthumb/*mcpu=fa626te *mthumb/*mcpu=fmp626 *mthumb/*mcpu=fa726te*\n+\n # Use a version of div0 which raises SIGFPE, and a special __clear_cache.\n LIB1ASMFUNCS := $(filter-out _dvmd_tls,$(LIB1ASMFUNCS)) _dvmd_lnx _clear_cache\n "}]}