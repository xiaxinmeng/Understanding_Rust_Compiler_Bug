{"sha": "058b15c1dc2199a810e4f8793993dc4ede61bb0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4YjE1YzFkYzIxOTlhODEwZTRmODc5Mzk5M2RjNGVkZTYxYmIwYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-06-22T07:18:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-06-22T07:18:38Z"}, "message": "cp-tree.def (NEW_EXPR): Add a fourth slot.\n\n\t* cp-tree.def (NEW_EXPR): Add a fourth slot.\n\t* cp-tree.h (PARMLIST_ELLIPSIS_P): Remove.\n\t(TREE_PARMLIST): Likewise.\n\t(CALL_DECLARATOR_PARMS): Likewise.\n\t(CALL_DECLARATOR_QUALS): Likewise.\n\t(CALL_DECLARATOR_EXCEPTION_SPEC): Likewise.\n\t(cp_declarator_kind): New type.\n\t(cp_parameter_declarator): Likewise.\n\t(cp_declarator): Likewise.\n\t(cp_error_declarator): Likewise.\n\t(no_parameters): Likewise.\n\t(groktypename): Change prototype.\n\t(start_decl): Likewise.\n\t(start_handler_parms): Likewise.\n\t(get_scope_of_declarator): Likewise.\n\t(start_function): Likewise.\n\t(start_preparsed_function): New function.\n\t(start_function): Change prototype.\n\t(start_method): Likewise.\n\t(grokfield): Likewise.\n\t(grokbitfield): Likewise.\n\t(build_new): Likewise.\n\t(make_pointer_declarator): Remove.\n\t(make_reference_declarator): Likewise.\n\t(make_call_declarator): Likewise.\n\t(set_quals_and_spec): Likewise.\n\t(process_template_parm): Change prototype.\n\t(begin_function_definition): Remove.\n\t(finish_parmlist): Remove.\n\t* decl.c (groktypename): Do not use trees to represent\n\tdeclarators.\n\t(start_decl): Likewise.\n\t(start_handler_parms): Remove.\n\t(get_scope_of_declarator): Reimplement.\n\t(grokdeclarator): Do not use trees to represent\tdeclarators.\n\t(grokparms): Likewise.\n\t(start_function): Likewise.\n\t(start_method): Likewise.\n\t(build_void_list_mode): Do not use TREE_PARMLIST.\n\t* decl.h (grokdeclarator): Change prototype.\n\t* decl2.c (grok_method_quals): Robustify.\n\t(grok_x_components): Do not use trees to represent declarators.\n\t(grokfield): Likewise.\n\t(grokbitfield): Likewise.\n\t(start_objects): Build FUNCTION_DECLs, not declarators.\n\t(start_static_storage_duration_function): Likewise.\n\t* init.c (build_new): Simplify.\n\t* lex.c (make_pointer_declarator): Remove.\n\t(make_reference_declarator): Likewise.\n\t(make_call_declarator): Likewise.\n\t(set_quals_and_spec): Likewise.\n\t* method.c (use_thunk): Use start_preparsed_function.\n\t(synthesize_method): Likewise.\n\t(implicitly_declare_fn): Build FUNCTION_DECLs, not declarators.\n\t* optimize.c (maybe_clone_body): Use start_preparsed_function.\n\t* parser.c (cp_error_declarator): New variable.\n\t(declarator_obstack): Likewise.\n\t(alloc_declarator): New function.\n\t(make_declarator): Likewise.\n\t(make_id_declarator): Likewise.\n\t(make_pointer_declarator): Likewise.\n\t(make_reference_declarator): Likewise.\n\t(make_ptrmem_declarator): Likewise.\n\t(make_call_declarator): Likewise.\n\t(make_array_declarator): Likewise.\n\t(no_parameters): New variable.\n\t(make_parameter_declarator): Likewise.\n\t(cp_parser_check_for_definition_in_return_type): Do not use trees\n\tto represent declarators.\n\t(cp_parser_translation_unit): Likewise.\n\t(cp_parser_new_expression): Likewise.\n\t(cp_parser_new_type_id): Likewise.\n\t(cp_parser_new_declarator_opt): Likewise.\n\t(cp_parser_direct_new_declarator): Likewise.\n\t(cp_parser_condition): Likewise.\n\t(cp_parser_declaration_statement): Likewise.\n\t(cp_parser_declaration): Likewise.\n\t(cp_parser_conversion_type_id): Likewise.\n\t(cp_parser_conversion_declarator_opt): Likewise.\n\t(cp_parser_template_parameter_list): Likewise.\n\t(cp_parser_template_parameter): Likewise.\n\t(cp_parser_explicit_instantiation): Likewise.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_declarator): Likewise.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_type_id): Likewise.\n\t(cp_parser_parameter_declaration_clause): Likewise.\n\t(cp_parser_parameter_declaration_list): Likewise.\n\t(cp_parser_parameter_declaration): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_exception_declaration): Likewise.\n\t(cp_parser_check_declarator_template_parameters): Likewise.\n\t(cp_parser_function_definition_from_specifiers_and_declarator):\n\tLikewise.\n\t(cp_parser_save_member_function_body): Likewise.\n\t* pt.c (process_template_parm): Add is_non_type parameter.\n\t(convert_template_argument): Adjust call to groktypename.\n\t(tsubst_call_declarator_parms): Remove use of TREE_PARMLIST.\n\t(tsubst): Do not expect declarators.\n\t(tsubst_copy_and_build): Adjust NEW_EXPR case to handle additional\n\targument.\n\t(instantiate_decl): Use start_preparsed_function.\n\t* semantics.c (begin_function_definition): Remove.\n\t(finish_parmlist): Remove.\n\t* cp-mudflap.c (mflang_flush_calls): Build FUNCTION_DECLs, not\n\tdeclarators.\n\nFrom-SVN: r83482", "tree": {"sha": "7c02283f18d2310094c350da6ada68b06b88aa56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c02283f18d2310094c350da6ada68b06b88aa56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/058b15c1dc2199a810e4f8793993dc4ede61bb0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058b15c1dc2199a810e4f8793993dc4ede61bb0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058b15c1dc2199a810e4f8793993dc4ede61bb0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058b15c1dc2199a810e4f8793993dc4ede61bb0a/comments", "author": null, "committer": null, "parents": [{"sha": "c0d578e68f92d8add050826588146be0a6fd1ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d578e68f92d8add050826588146be0a6fd1ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d578e68f92d8add050826588146be0a6fd1ee0"}], "stats": {"total": 2773, "additions": 1343, "deletions": 1430}, "files": [{"sha": "05ddba31d7b2471eb7bd2ee23a5bec567dd009ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -1,3 +1,112 @@\n+2004-06-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (NEW_EXPR): Add a fourth slot.\n+\t* cp-tree.h (PARMLIST_ELLIPSIS_P): Remove.\n+\t(TREE_PARMLIST): Likewise.\n+\t(CALL_DECLARATOR_PARMS): Likewise.\n+\t(CALL_DECLARATOR_QUALS): Likewise.\n+\t(CALL_DECLARATOR_EXCEPTION_SPEC): Likewise.\n+\t(cp_declarator_kind): New type.\n+\t(cp_parameter_declarator): Likewise.\n+\t(cp_declarator): Likewise.\n+\t(cp_error_declarator): Likewise.\n+\t(no_parameters): Likewise.\n+\t(groktypename): Change prototype.\n+\t(start_decl): Likewise.\n+\t(start_handler_parms): Likewise.\n+\t(get_scope_of_declarator): Likewise.\n+\t(start_function): Likewise.\n+\t(start_preparsed_function): New function.\n+\t(start_function): Change prototype.\n+\t(start_method): Likewise.\n+\t(grokfield): Likewise.\n+\t(grokbitfield): Likewise.\n+\t(build_new): Likewise.\n+\t(make_pointer_declarator): Remove.\n+\t(make_reference_declarator): Likewise.\n+\t(make_call_declarator): Likewise.\n+\t(set_quals_and_spec): Likewise.\n+\t(process_template_parm): Change prototype.\n+\t(begin_function_definition): Remove.\n+\t(finish_parmlist): Remove.\n+\t* decl.c (groktypename): Do not use trees to represent\n+\tdeclarators.\n+\t(start_decl): Likewise.\n+\t(start_handler_parms): Remove.\n+\t(get_scope_of_declarator): Reimplement.\n+\t(grokdeclarator): Do not use trees to represent\tdeclarators.\n+\t(grokparms): Likewise.\n+\t(start_function): Likewise.\n+\t(start_method): Likewise.\n+\t(build_void_list_mode): Do not use TREE_PARMLIST.\n+\t* decl.h (grokdeclarator): Change prototype.\n+\t* decl2.c (grok_method_quals): Robustify.\n+\t(grok_x_components): Do not use trees to represent declarators.\n+\t(grokfield): Likewise.\n+\t(grokbitfield): Likewise.\n+\t(start_objects): Build FUNCTION_DECLs, not declarators.\n+\t(start_static_storage_duration_function): Likewise.\n+\t* init.c (build_new): Simplify.\n+\t* lex.c (make_pointer_declarator): Remove.\n+\t(make_reference_declarator): Likewise.\n+\t(make_call_declarator): Likewise.\n+\t(set_quals_and_spec): Likewise.\n+\t* method.c (use_thunk): Use start_preparsed_function.\n+\t(synthesize_method): Likewise.\n+\t(implicitly_declare_fn): Build FUNCTION_DECLs, not declarators.\n+\t* optimize.c (maybe_clone_body): Use start_preparsed_function.\n+\t* parser.c (cp_error_declarator): New variable.\n+\t(declarator_obstack): Likewise.\n+\t(alloc_declarator): New function.\n+\t(make_declarator): Likewise.\n+\t(make_id_declarator): Likewise.\n+\t(make_pointer_declarator): Likewise.\n+\t(make_reference_declarator): Likewise.\n+\t(make_ptrmem_declarator): Likewise.\n+\t(make_call_declarator): Likewise.\n+\t(make_array_declarator): Likewise.\n+\t(no_parameters): New variable.\n+\t(make_parameter_declarator): Likewise.\n+\t(cp_parser_check_for_definition_in_return_type): Do not use trees\n+\tto represent declarators.\n+\t(cp_parser_translation_unit): Likewise.\n+\t(cp_parser_new_expression): Likewise.\n+\t(cp_parser_new_type_id): Likewise.\n+\t(cp_parser_new_declarator_opt): Likewise.\n+\t(cp_parser_direct_new_declarator): Likewise.\n+\t(cp_parser_condition): Likewise.\n+\t(cp_parser_declaration_statement): Likewise.\n+\t(cp_parser_declaration): Likewise.\n+\t(cp_parser_conversion_type_id): Likewise.\n+\t(cp_parser_conversion_declarator_opt): Likewise.\n+\t(cp_parser_template_parameter_list): Likewise.\n+\t(cp_parser_template_parameter): Likewise.\n+\t(cp_parser_explicit_instantiation): Likewise.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_declarator): Likewise.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_type_id): Likewise.\n+\t(cp_parser_parameter_declaration_clause): Likewise.\n+\t(cp_parser_parameter_declaration_list): Likewise.\n+\t(cp_parser_parameter_declaration): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_exception_declaration): Likewise.\n+\t(cp_parser_check_declarator_template_parameters): Likewise.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator):\n+\tLikewise.\n+\t(cp_parser_save_member_function_body): Likewise.\n+\t* pt.c (process_template_parm): Add is_non_type parameter.\n+\t(convert_template_argument): Adjust call to groktypename.\n+\t(tsubst_call_declarator_parms): Remove use of TREE_PARMLIST.\n+\t(tsubst): Do not expect declarators.\n+\t(tsubst_copy_and_build): Adjust NEW_EXPR case to handle additional\n+\targument.\n+\t(instantiate_decl): Use start_preparsed_function.\n+\t* semantics.c (begin_function_definition): Remove.\n+\t(finish_parmlist): Remove.\n+\t* cp-mudflap.c (mflang_flush_calls): Build FUNCTION_DECLs, not\n+\tdeclarators.\n+\n 2004-06-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* call.c (build_vfield_ref): Add new operand for COMPONENT_REF."}, {"sha": "23e875029d6de73b34b6052d2d2411834c21732f", "filename": "gcc/cp/cp-mudflap.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fcp-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fcp-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-mudflap.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -63,25 +63,24 @@ void\n mflang_flush_calls (tree enqueued_call_stmt_chain)\n {\n   tree fnname, fndecl, body;\n+  tree type;\n \n   /* Short-circuit!  */\n   if (enqueued_call_stmt_chain == NULL_TREE)\n     return;\n \n   /* Create a ctor function declaration.  */\n   fnname = get_identifier (\"__static_initialization_and_destruction_mudflap\");\n-\n-  start_function (void_list_node,\n-\t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n-\t\t\t\t\tNULL_TREE),\n-\t\t  NULL_TREE, SF_DEFAULT);\n+  type = build_function_type (void_type_node, void_list_node);\n+  fndecl = build_lang_decl (FUNCTION_DECL, fnname, type);\n \n   TREE_PUBLIC (current_function_decl) = 0;\n   TREE_USED (current_function_decl) = 1;\n   DECL_ARTIFICIAL (current_function_decl) = 1;\n   mf_mark (current_function_decl);\n \n   /* Generate the body, one statement at a time.  */\n+  start_preparsed_function (fndecl, /*attrs=*/NULL_TREE, SF_PRE_PARSED);\n   body = begin_compound_stmt (BCS_FN_BODY);\n \n   while (enqueued_call_stmt_chain)"}, {"sha": "f1912b17438ec949568a850ea359543d6c8bd102", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -51,8 +51,9 @@ DEFTREECODE (PTRMEM_CST, \"ptrmem_cst\", 'c', 0)\n \n /* For NEW_EXPR, operand 0 is the placement list.\n    Operand 1 is the new-declarator.\n-   Operand 2 is the initializer.  */\n-DEFTREECODE (NEW_EXPR, \"nw_expr\", 'e', 3)\n+   Operand 2 is the number of elements in the array.\n+   Operand 3 is the initializer.  */\n+DEFTREECODE (NEW_EXPR, \"nw_expr\", 'e', 4)\n DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", 'e', 3)\n \n /* For DELETE_EXPR, operand 0 is the store to be destroyed."}, {"sha": "e29e084e0bb20582730cfe0742a2280019e972a7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 93, "deletions": 39, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -45,7 +45,6 @@ struct diagnostic_context;\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF)\n-      PARMLIST_ELLIPSIS_P (in PARMLIST)\n       DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n       KOENIG_LOOKUP_P (in CALL_EXPR)\n       STATEMENT_LIST_NO_SCOPE (in STATEMENT_LIST).\n@@ -64,7 +63,6 @@ struct diagnostic_context;\n       TYPE_POLYMORPHIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n       BINFO_LOST_PRIMARY_P (in BINFO)\n-      TREE_PARMLIST (in TREE_LIST)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n@@ -1566,13 +1564,6 @@ struct lang_type GTY(())\n #define BV_FN(NODE) (TREE_VALUE (NODE))\n \n \f\n-/* Nonzero for TREE_LIST node means that this list of things\n-   is a list of parameters, as opposed to a list of expressions.  */\n-#define TREE_PARMLIST(NODE) (TREE_LANG_FLAG_2 (NODE))\n-\n-/* Nonzero for a parmlist means that this parmlist ended in ...  */\n-#define PARMLIST_ELLIPSIS_P(NODE) TREE_LANG_FLAG_0 (NODE)\n-\n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n    will be NULL_TREE to indicate a throw specification of `()', or\n@@ -2953,18 +2944,6 @@ struct lang_decl GTY(())\n #define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n #define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n \n-/* The parameters for a call-declarator.  */\n-#define CALL_DECLARATOR_PARMS(NODE) \\\n-  (TREE_PURPOSE (TREE_OPERAND (NODE, 1)))\n-\n-/* The cv-qualifiers for a call-declarator.  */\n-#define CALL_DECLARATOR_QUALS(NODE) \\\n-  (TREE_VALUE (TREE_OPERAND (NODE, 1)))\n-\n-/* The exception-specification for a call-declarator.  */\n-#define CALL_DECLARATOR_EXCEPTION_SPEC(NODE) \\\n-  (TREE_TYPE (NODE))\n-\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types { \n   none_type = 0, /* Not a tag type.  */\n@@ -3529,6 +3508,89 @@ extern GTY(()) operator_name_info_t operator_name_info\n extern GTY(()) operator_name_info_t assignment_operator_name_info\n   [(int) LAST_CPLUS_TREE_CODE];\n \n+/* The various kinds of declarators.  */\n+\n+typedef enum cp_declarator_kind {\n+  cdk_id,\n+  cdk_function,\n+  cdk_array,\n+  cdk_pointer,\n+  cdk_reference,\n+  cdk_ptrmem,\n+  cdk_error\n+} cp_declarator_kind;\n+\n+/* A declarator.  */\n+\n+typedef struct cp_declarator cp_declarator;\n+\n+typedef struct cp_parameter_declarator cp_parameter_declarator;\n+\n+/* A parameter, before it has been semantically analyzed.  */\n+struct cp_parameter_declarator {\n+  /* The next parameter, or NULL_TREE if none.  */\n+  cp_parameter_declarator *next;\n+  /* The decl-specifiers-seq for the parameter.  */\n+  tree decl_specifiers;\n+  /* The declarator for the parameter.  */\n+  cp_declarator *declarator;\n+  /* The default-argument expression, or NULL_TREE, if none.  */\n+  tree default_argument;\n+  /* True iff this is the first parameter in the list and the\n+     parameter sequence ends with an ellipsis.  */\n+  bool ellipsis_p;\n+};\n+\n+/* A declarator.  */\n+struct cp_declarator {\n+  /* The kind of declarator.  */\n+  cp_declarator_kind kind;\n+  /* Attributes that apply to this declarator.  */\n+  tree attributes;\n+  /* For all but cdk_id and cdk_error, the contained declarator.  For\n+     cdk_id and cdk_error, guaranteed to be NULL.  */\n+  cp_declarator *declarator;\n+  union {\n+    /* For identifiers.  */\n+    struct {\n+      /* The name of the function -- an IDENTIFIER_NODE, BIT_NOT_EXPR,\n+\t TEMPLATE_ID_EXPR, or SCOPE_REF.  */\n+      tree name;\n+      /* If this is the name of a function, what kind of special\n+\t function (if any).  */\n+      special_function_kind sfk;\n+    } id;\n+    /* For functions.  */\n+    struct {\n+      /* The parameters to the function.  */\n+      cp_parameter_declarator *parameters;\n+      /* The cv-qualifiers for the function.  */\n+      tree qualifiers;\n+      /* The exception-specification for the function.  */\n+      tree exception_specification;\n+    } function;\n+    /* For arrays.  */\n+    struct {\n+      /* The bounds to the array.  */\n+      tree bounds;\n+    } array;\n+    /* For cdk_pointer, cdk_reference, and cdk_ptrmem.  */\n+    struct {\n+      /* The cv-qualifiers for the pointer.  */\n+      tree qualifiers;\n+      /* For cdk_ptrmem, the class type containing the member.  */\n+      tree class_type;\n+    } pointer;\n+  } u;\n+};\n+\n+/* An erroneous declarator.  */\n+extern cp_declarator *cp_error_declarator;\n+\n+/* A parameter list indicating for a function with no parameters,\n+   e.g  \"int f(void)\".  */\n+extern cp_parameter_declarator *no_parameters;\n+\n /* in call.c */\n extern bool check_dtor_name (tree, tree);\n \n@@ -3674,19 +3736,18 @@ extern tree push_throw_library_fn\t\t(tree, tree);\n extern int init_type_desc\t\t\t(void);\n extern tree check_tag_decl\t\t\t(tree);\n extern tree shadow_tag\t\t\t\t(tree);\n-extern tree groktypename\t\t\t(tree);\n-extern tree start_decl\t\t\t\t(tree, tree, int, tree, tree);\n+extern tree groktypename\t\t\t(tree, const cp_declarator *);\n+extern tree start_decl\t\t\t\t(const cp_declarator *, tree, int, tree, tree);\n extern void start_decl_1\t\t\t(tree);\n extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n extern void maybe_inject_for_scope_var          (tree);\n-extern tree start_handler_parms                 (tree, tree);\n extern int complete_array_type\t\t\t(tree, tree, int);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type                   (tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n extern int copy_fn_p\t\t\t\t(tree);\n-extern tree get_scope_of_declarator             (tree);\n+extern tree get_scope_of_declarator             (const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n extern int grok_ctor_properties\t\t\t(tree, tree);\n extern bool grok_op_properties\t\t\t(tree, int, bool);\n@@ -3696,11 +3757,12 @@ extern void xref_basetypes\t\t\t(tree, tree);\n extern tree start_enum\t\t\t\t(tree);\n extern void finish_enum\t\t\t\t(tree);\n extern void build_enumerator\t\t\t(tree, tree, tree);\n-extern int start_function\t\t\t(tree, tree, tree, int);\n+extern void start_preparsed_function            (tree, tree, int);\n+extern int start_function\t\t\t(tree, const cp_declarator *, tree);\n extern tree begin_function_body\t\t\t(void);\n extern void finish_function_body\t\t(tree);\n extern tree finish_function\t\t\t(int);\n-extern tree start_method\t\t\t(tree, tree, tree);\n+extern tree start_method\t\t\t(tree, const cp_declarator *, tree);\n extern tree finish_method\t\t\t(tree);\n extern void maybe_register_incomplete_var       (tree);\n extern void complete_vars\t\t\t(tree);\n@@ -3749,8 +3811,8 @@ extern tree grok_array_decl (tree, tree);\n extern tree delete_sanity (tree, tree, bool, int);\n extern tree check_classfn (tree, tree, tree);\n extern void check_member_template (tree);\n-extern tree grokfield (tree, tree, tree, tree, tree);\n-extern tree grokbitfield (tree, tree, tree);\n+extern tree grokfield (const cp_declarator *, tree, tree, tree, tree);\n+extern tree grokbitfield (const cp_declarator *, tree, tree);\n extern tree groktypefield\t\t\t(tree, tree);\n extern void cplus_decl_attributes (tree *, tree, int);\n extern void finish_anon_union (tree);\n@@ -3828,7 +3890,7 @@ extern tree get_aggr_from_typedef\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init       \t\t(tree, tree, bool);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n-extern tree build_new\t\t\t\t(tree, tree, tree, int);\n+extern tree build_new\t\t\t\t(tree, tree, tree, tree, int);\n extern tree build_vec_init\t\t\t(tree, tree, tree, int);\n extern tree build_x_delete\t\t\t(tree, int, tree);\n extern tree build_delete\t\t\t(tree, tree, special_function_kind, int, int);\n@@ -3839,14 +3901,8 @@ extern tree create_temporary_var                (tree);\n extern void initialize_vtbl_ptrs                (tree);\n extern tree build_java_class_ref                (tree);\n \n-/* in input.c */\n-\n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);\n-extern tree make_pointer_declarator\t\t(tree, tree);\n-extern tree make_reference_declarator\t\t(tree, tree);\n-extern tree make_call_declarator\t\t(tree, tree, tree, tree);\n-extern void set_quals_and_spec\t\t\t(tree, tree, tree);\n extern void print_parse_statistics\t\t(void);\n extern void do_pending_inlines\t\t\t(void);\n extern void yyungetc\t\t\t\t(int, int);\n@@ -3892,7 +3948,7 @@ extern void end_specialization                  (void);\n extern void begin_explicit_instantiation        (void);\n extern void end_explicit_instantiation          (void);\n extern tree check_explicit_specialization       (tree, tree, int, int);\n-extern tree process_template_parm\t\t(tree, tree);\n+extern tree process_template_parm\t\t(tree, tree, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n extern tree current_template_args\t\t(void);\n@@ -4095,11 +4151,9 @@ extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr                (enum tree_code, tree);\n extern tree finish_compound_literal             (tree, tree);\n extern tree finish_fname                        (tree);\n-extern int begin_function_definition            (tree, tree, tree);\n extern void finish_translation_unit             (void);\n extern tree finish_template_type_parm           (tree, tree);\n extern tree finish_template_template_parm       (tree, tree);\n-extern tree finish_parmlist                     (tree, int);\n extern tree begin_class_definition              (tree);\n extern void finish_default_args                 (void);\n extern tree finish_member_class_template        (tree);"}, {"sha": "66f6b36e9fed9ff76da4faf0b749e3e4cc3e83fb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 474, "deletions": 749, "changes": 1223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -53,7 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"timevar.h\"\n #include \"tree-flow.h\"\n \n-static tree grokparms (tree, tree *);\n+static tree grokparms (const cp_parameter_declarator *, tree *);\n static const char *redeclaration_error_message (tree, tree);\n \n static int decl_jump_unsafe (tree);\n@@ -3564,8 +3564,8 @@ shadow_tag (tree declspecs)\n \n       if (TYPE_FIELDS (t))\n \t{\n-\t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n-\t\t\t\t      NULL);\n+\t  tree decl = grokdeclarator (/*declarator=*/NULL, \n+\t\t\t\t      declspecs, NORMAL, 0, NULL);\n \t  finish_anon_union (decl);\n \t}\n     }\n@@ -3576,15 +3576,12 @@ shadow_tag (tree declspecs)\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n-groktypename (tree typename)\n+groktypename (tree type_specifiers, const cp_declarator *declarator)\n {\n   tree specs, attrs;\n   tree type;\n-  if (TREE_CODE (typename) != TREE_LIST)\n-    return typename;\n-  split_specs_attrs (TREE_PURPOSE (typename), &specs, &attrs);\n-  type = grokdeclarator (TREE_VALUE (typename), specs,\n-\t\t\t TYPENAME, 0, &attrs);\n+  split_specs_attrs (type_specifiers, &specs, &attrs);\n+  type = grokdeclarator (declarator, specs, TYPENAME, 0, &attrs);\n   if (attrs)\n     cplus_decl_attributes (&type, attrs, 0);\n   return type;\n@@ -3606,7 +3603,7 @@ groktypename (tree typename)\n    grokfield and not through here.  */\n \n tree\n-start_decl (tree declarator, \n+start_decl (const cp_declarator *declarator, \n             tree declspecs, \n             int initialized, \n             tree attributes, \n@@ -5122,7 +5119,7 @@ start_cleanup_fn (void)\n     }\n \n   pushdecl (fndecl);\n-  start_function (/*specs=*/NULL_TREE, fndecl, NULL_TREE, SF_PRE_PARSED);\n+  start_preparsed_function (fndecl, NULL_TREE, SF_PRE_PARSED);\n \n   interface_unknown = old_interface_unknown;\n   interface_only = old_interface_only;\n@@ -5284,25 +5281,6 @@ expand_static_init (tree decl, tree init)\n     static_aggregates = tree_cons (init, decl, static_aggregates);\n }\n \n-/* Finish the declaration of a catch-parameter.  */\n-\n-tree\n-start_handler_parms (tree declspecs, tree declarator)\n-{\n-  tree decl;\n-  if (declspecs)\n-    {\n-      decl = grokdeclarator (declarator, declspecs, CATCHPARM,\n-\t\t\t     1, NULL);\n-      if (decl == NULL_TREE)\n-\terror (\"invalid catch parameter\");\n-    }\n-  else\n-    decl = NULL_TREE;\n-\n-  return decl;\n-}\n-\n \f\n /* Make TYPE a complete type based on INITIAL_VALUE.\n    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,\n@@ -6140,40 +6118,21 @@ compute_array_index_type (tree name, tree size)\n    unqualified name, NULL_TREE is returned.  */\n \n tree\n-get_scope_of_declarator (tree declarator)\n+get_scope_of_declarator (const cp_declarator *declarator)\n {\n-  if (!declarator)\n-    return NULL_TREE;\n-  \n-  switch (TREE_CODE (declarator))\n-    {\n-    case CALL_EXPR:\n-    case ARRAY_REF:\n-    case INDIRECT_REF:\n-    case ADDR_EXPR:\n-      /* For any of these, the main declarator is the first operand.  */\n-      return get_scope_of_declarator (TREE_OPERAND\n-\t\t\t\t      (declarator, 0));\n-\n-    case SCOPE_REF:\n-      /* For a pointer-to-member, continue descending.  */\n-      if (TREE_CODE (TREE_OPERAND (declarator, 1))\n-\t  == INDIRECT_REF)\n-\treturn get_scope_of_declarator (TREE_OPERAND\n-\t\t\t\t\t(declarator, 1));\n-      /* Otherwise, if the declarator-id is a SCOPE_REF, the scope in\n-\t which the declaration occurs is the first operand.  */\n-      return TREE_OPERAND (declarator, 0);\n-\n-    case TREE_LIST:\n-      /* Attributes to be applied. The declarator is TREE_VALUE.  */\n-      return get_scope_of_declarator (TREE_VALUE (declarator));\n-      \n-    default:\n-      /* Otherwise, we have a declarator-id which is not a qualified\n-\t name; the entity will be declared in the current scope.  */\n-      return NULL_TREE;\n-    }\n+  while (declarator && declarator->kind != cdk_id)\n+    declarator = declarator->declarator;\n+\n+  /* If the declarator-id is a SCOPE_REF, the scope in which the\n+     declaration occurs is the first operand.  */\n+  if (declarator\n+      && declarator->u.id.name\n+      && TREE_CODE (declarator->u.id.name) == SCOPE_REF)\n+    return TREE_OPERAND (declarator->u.id.name, 0);\n+\n+  /* Otherwise, the declarator is not a quablified name; the entity will\n+     be declared in the current scope.  */\n+  return NULL_TREE;\n }\n \n /* Returns an ARRAY_TYPE for an array with SIZE elements of the\n@@ -6332,7 +6291,7 @@ check_special_function_return_type (special_function_kind sfk,\n    should not be `S'.  */\n \n tree\n-grokdeclarator (tree declarator,\n+grokdeclarator (const cp_declarator *declarator,\n                 tree declspecs,\n                 enum decl_context decl_context,\n                 int initialized,\n@@ -6352,10 +6311,10 @@ grokdeclarator (tree declarator,\n   tree dependant_name = NULL_TREE;\n   \n   tree typedef_decl = NULL_TREE;\n-  const char *name;\n+  const char *name = NULL;\n   tree typedef_type = NULL_TREE;\n   int funcdef_flag = 0;\n-  enum tree_code innermost_code = ERROR_MARK;\n+  cp_declarator_kind innermost_code = cdk_error;\n   int bitfield = 0;\n #if 0\n   /* See the code below that used this.  */\n@@ -6368,16 +6327,27 @@ grokdeclarator (tree declarator,\n   special_function_kind sfk = sfk_none;\n \n   tree dname = NULL_TREE;\n-  tree ctype = current_class_type;\n   tree ctor_return_type = NULL_TREE;\n   enum overload_flags flags = NO_SPECIAL;\n   tree quals = NULL_TREE;\n   tree raises = NULL_TREE;\n   int template_count = 0;\n-  tree in_namespace = NULL_TREE;\n   tree returned_attrs = NULL_TREE;\n-  tree scope = NULL_TREE;\n   tree parms = NULL_TREE;\n+  const cp_declarator *id_declarator;\n+  /* The unqualified name of the declarator; either an\n+     IDENTIFIER_NODE, BIT_NOT_EXPR, or TEMPLATE_ID_EXPR.  */\n+  tree unqualified_id;\n+  /* The class type, if any, in which this entity is located,\n+     or NULL_TREE if none.  Note that this value may be different from\n+     the current class type; for example if an attempt is made to declare\n+     \"A::f\" inside \"B\", this value will be \"A\".  */\n+  tree ctype = current_class_type;\n+  /* The NAMESPACE_DECL for the namespace in which this entity is\n+     located.  If an unqualified name is used to declare the entity,\n+     this value will be NULL_TREE, even if the entity is located at\n+     namespace scope.  */ \n+  tree in_namespace = NULL_TREE;\n \n   RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n@@ -6389,186 +6359,35 @@ grokdeclarator (tree declarator,\n \n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n-  {\n-    tree *next = &declarator;\n-    tree decl;\n-    name = NULL;\n-\n-    while (next && *next)\n-      {\n-\tdecl = *next;\n-\tswitch (TREE_CODE (decl))\n-\t  {\n-\t  case TREE_LIST:\n-\t    /* For attributes.  */\n-\t    next = &TREE_VALUE (decl);\n-\t    break;\n-\n-\t  case COND_EXPR:\n-\t    ctype = NULL_TREE;\n-\t    next = &TREE_OPERAND (decl, 0);\n-\t    break;\n+  for (id_declarator = declarator; \n+       id_declarator; \n+       id_declarator = id_declarator->declarator)\n+    {\n+      if (id_declarator->kind != cdk_id)\n+\tinnermost_code = id_declarator->kind;\n \n-\t  case BIT_NOT_EXPR:\t/* For C++ destructors!  */\n+      switch (id_declarator->kind)\n+\t{\n+\tcase cdk_function:\n+\t  if (id_declarator->declarator\n+\t      && id_declarator->declarator->kind == cdk_id)\n \t    {\n-\t      tree name = TREE_OPERAND (decl, 0);\n-\t      tree rename = NULL_TREE;\n-\n-\t      my_friendly_assert (flags == NO_SPECIAL, 152);\n-\t      flags = DTOR_FLAG;\n-\t      sfk = sfk_destructor;\n-\t      if (TYPE_P (name))\n-\t\tTREE_OPERAND (decl, 0) = name = constructor_name (name);\n-\t      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 153);\n-\t      if (ctype == NULL_TREE)\n-\t\t{\n-\t\t  if (current_class_type == NULL_TREE)\n-\t\t    {\n-\t\t      error (\"destructors must be member functions\");\n-\t\t      flags = NO_SPECIAL;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      tree t = constructor_name (current_class_type);\n-\t\t      if (t != name)\n-\t\t\trename = t;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  tree t = constructor_name (ctype);\n-\t\t  if (t != name)\n-\t\t    rename = t;\n-\t\t}\n-\n-\t      if (rename)\n-\t\t{\n-\t\t  error (\"destructor `%T' must match class name `%T'\",\n-\t\t\t    name, rename);\n-\t\t  TREE_OPERAND (decl, 0) = rename;\n-\t\t}\n-\t      next = &name;\n+\t      sfk = id_declarator->declarator->u.id.sfk;\n+\t      if (sfk == sfk_destructor)\n+\t\tflags = DTOR_FLAG;\n \t    }\n-\t    break;\n-\n-\t  case ADDR_EXPR:\t/* C++ reference declaration */\n-\t    /* Fall through.  */\n-\t  case ARRAY_REF:\n-\t  case INDIRECT_REF:\n-\t    ctype = NULL_TREE;\n-\t    innermost_code = TREE_CODE (decl);\n-\t    next = &TREE_OPERAND (decl, 0);\n-\t    break;\n-\n-\t  case CALL_EXPR:\n-\t    innermost_code = TREE_CODE (decl);\n-\t    if (decl_context == FIELD && ctype == NULL_TREE)\n-\t      ctype = current_class_type;\n-\t    if (ctype\n-\t\t&& TREE_OPERAND (decl, 0)\n-\t\t&& (TREE_CODE (TREE_OPERAND (decl, 0)) == TYPE_DECL\n-\t\t    && constructor_name_p (DECL_NAME (TREE_OPERAND (decl, 0)),\n-\t\t\t\t\t   ctype)))\n-\t      TREE_OPERAND (decl, 0) = constructor_name (ctype);\n-\t    next = &TREE_OPERAND (decl, 0);\n-\t    decl = *next;\n-\t    if (ctype != NULL_TREE\n-\t\t&& decl != NULL_TREE && flags != DTOR_FLAG\n-\t\t&& constructor_name_p (decl, ctype))\n-\t      {\n-\t\tsfk = sfk_constructor;\n-\t\tctor_return_type = ctype;\n-\t      }\n-\t    ctype = NULL_TREE;\n-\t    break;\n-\n-\t  case TEMPLATE_ID_EXPR:\n-\t      {\n-\t\ttree fns = TREE_OPERAND (decl, 0);\n-\n-\t\tdname = fns;\n-\t\tif (TREE_CODE (dname) == COMPONENT_REF)\n-\t\t  dname = TREE_OPERAND (dname, 1);\n-\t\tif (TREE_CODE (dname) != IDENTIFIER_NODE)\n-\t\t  {\n-\t\t    my_friendly_assert (is_overloaded_fn (dname),\n-\t\t\t\t\t19990331);\n-\t\t    dname = DECL_NAME (get_first_fn (dname));\n-\t\t  }\n-\t      }\n-\t  /* Fall through.  */\n-\n-\t  case IDENTIFIER_NODE:\n-\t    if (TREE_CODE (decl) == IDENTIFIER_NODE)\n-\t      dname = decl;\n-\n-\t    next = 0;\n+\t  break;\n \n-\t    if (C_IS_RESERVED_WORD (dname))\n-\t      {\n-\t\terror (\"declarator-id missing; using reserved word `%D'\",\n-\t\t\t  dname);\n-\t\tname = IDENTIFIER_POINTER (dname);\n-\t      }\n-\t    else if (!IDENTIFIER_TYPENAME_P (dname))\n-\t      name = IDENTIFIER_POINTER (dname);\n-\t    else\n+\tcase cdk_id:\n+\t  {\n+\t    tree decl = id_declarator->u.id.name;\n+\t    if (!decl)\n+\t      break;\n+\t    if (TREE_CODE (decl) == SCOPE_REF)\n \t      {\n-\t\tmy_friendly_assert (flags == NO_SPECIAL, 154);\n-\t\tflags = TYPENAME_FLAG;\n-\t\tctor_return_type = TREE_TYPE (dname);\n-\t\tsfk = sfk_conversion;\n-\t\tif (is_typename_at_global_scope (dname))\n-\t\t  name = IDENTIFIER_POINTER (dname);\n-\t\telse\n-\t\t  name = \"<invalid operator>\";\n-\t      }\n-\t    break;\n-\n-\t    /* C++ extension */\n-\t  case SCOPE_REF:\n-\t    {\n-\t      /* Perform error checking, and decide on a ctype.  */\n-\t      tree cname = TREE_OPERAND (decl, 0);\n-\t      if (cname == NULL_TREE)\n-\t\tctype = NULL_TREE;\n-\t      else if (TREE_CODE (cname) == NAMESPACE_DECL)\n-\t\t{\n-\t\t  ctype = NULL_TREE;\n-\t\t  in_namespace = TREE_OPERAND (decl, 0);\n-\t\t}\n-\t      else if (! is_aggr_type (cname, 1))\n-\t\tctype = NULL_TREE;\n-\t      /* Must test TREE_OPERAND (decl, 1), in case user gives\n-\t\t us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */\n-\t      else if (TREE_OPERAND (decl, 1)\n-\t\t       && TREE_CODE (TREE_OPERAND (decl, 1)) == INDIRECT_REF)\n-\t\tctype = cname;\n-\t      else if (TREE_CODE (cname) == TEMPLATE_TYPE_PARM\n-\t\t       || TREE_CODE (cname) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-\t\t{\n-\t  \t  /* This might be declaring a member of a template\n-\t\t     parm to be a friend.  */\n-\t\t  ctype = cname;\n-\t\t  dependant_name = TREE_OPERAND (decl, 1);\n-\t\t}\n-\t      else if (ctype == NULL_TREE)\n-\t\tctype = cname;\n-\t      else if (TREE_COMPLEXITY (decl) == current_class_depth)\n-\t\t;\n-\t      else\n-\t\t{\n-\t\t  if (! UNIQUELY_DERIVED_FROM_P (cname, ctype))\n-\t\t    {\n-\t\t      error (\"type `%T' is not derived from type `%T'\",\n-\t\t\t\tcname, ctype);\n-\t\t      ctype = NULL_TREE;\n-\t\t    }\n-\t\t  else\n-\t\t    ctype = cname;\n-\t\t}\n-\n-\t      /* It is valid to write:\n+\t\ttree qualifying_scope = TREE_OPERAND (decl, 0);\n+;\n+\t\t/* It is valid to write:\n \n \t\t   class C { void f(); };\n \t\t   typedef C D;\n@@ -6578,93 +6397,112 @@ grokdeclarator (tree declarator,\n \t\t legal; as of 2002-09-15 the committee is considering\n \t\t that question.  EDG 3.0 allows that syntax.\n \t\t Therefore, we do as well.  */\n-\t      if (ctype)\n-\t\tctype = TYPE_MAIN_VARIANT (ctype);\n-\t      /* Update the declarator so that when we process it\n-\t\t again the correct type is present.  */\n-\t      TREE_OPERAND (decl, 0) = ctype;\n-\n-\t      if (ctype && TREE_CODE (TREE_OPERAND (decl, 1)) == TYPE_DECL\n-\t\t  && constructor_name_p (DECL_NAME (TREE_OPERAND (decl, 1)),\n-\t\t\t\t\t ctype))\n-\t\tTREE_OPERAND (decl, 1) = constructor_name (ctype);\n-\t      next = &TREE_OPERAND (decl, 1);\n-\t      decl = *next;\n-\t      if (ctype)\n+\t\tif (qualifying_scope && TYPE_P (qualifying_scope))\n+\t\t  {\n+\t\t    ctype = TYPE_MAIN_VARIANT (qualifying_scope); \n+\t\t    if (innermost_code != cdk_function\n+\t\t\t&& current_class_type\n+\t\t\t&& !UNIQUELY_DERIVED_FROM_P (ctype, \n+\t\t\t\t\t\t     current_class_type))\n+\t\t      {\n+\t\t\terror (\"type `%T' is not derived from type `%T'\",\n+\t\t\t       ctype, current_class_type);\n+\t\t\tctype = NULL_TREE;\n+\t\t      }\n+\t\t    TREE_OPERAND (decl, 0) = ctype; \n+\t\t  }\n+\t\telse if (TREE_CODE (qualifying_scope) == NAMESPACE_DECL)\n+\t\t  in_namespace = qualifying_scope;\n+\t\tdecl = TREE_OPERAND (decl, 1);\n+\t      }\n+\t    if (TREE_CODE (decl) == BASELINK)\n+\t      decl = BASELINK_FUNCTIONS (decl);\n+\t    switch (TREE_CODE (decl))\n+\t      {\n+\t      case BIT_NOT_EXPR:\n \t\t{\n-\t\t  tree name = decl;\n+\t\t  tree type = TREE_OPERAND (decl, 0);\n+\t\t  type = constructor_name (type);\n+\t\t  name = IDENTIFIER_POINTER (type);\n+\t\t}\n+\t\tbreak;\n \n-\t\t  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\t\t    name = TREE_OPERAND (name, 0);\n+\t      case TEMPLATE_ID_EXPR:\n+\t\t{\n+\t\t  tree fns = TREE_OPERAND (decl, 0);\n \n-\t\t  if (!constructor_name_p (decl, ctype))\n-\t\t    ;\n-\t\t  else if (decl == name)\n-\t\t    {\n-\t\t      sfk = sfk_constructor;\n-\t\t      ctor_return_type = ctype;\n-\t\t    }\n-\t\t  else\n+\t\t  dname = fns;\n+\t\t  if (TREE_CODE (dname) == COMPONENT_REF)\n+\t\t    dname = TREE_OPERAND (dname, 1);\n+\t\t  if (TREE_CODE (dname) != IDENTIFIER_NODE)\n \t\t    {\n-\t\t      sfk = sfk_destructor;\n-\t\t      ctor_return_type = ctype;\n-\t\t      flags = DTOR_FLAG;\n-\t\t      TREE_OPERAND (decl, 0) = constructor_name (ctype);\n-\t\t      next = &TREE_OPERAND (decl, 0);\n+\t\t      my_friendly_assert (is_overloaded_fn (dname),\n+\t\t\t\t\t  19990331);\n+\t\t      dname = DECL_NAME (get_first_fn (dname));\n \t\t    }\n \t\t}\n-\t    }\n-\t    break;\n+\t\t/* Fall through.  */\n \n-\t  case ERROR_MARK:\n-\t    next = 0;\n-\t    break;\n+\t      case IDENTIFIER_NODE:\n+\t\tif (TREE_CODE (decl) == IDENTIFIER_NODE)\n+\t\t  dname = decl;\n \n-\t  case TYPE_DECL:\n-\t    /* Parse error puts this typespec where\n-\t       a declarator should go.  */\n-\t    error (\"`%T' specified as declarator-id\", DECL_NAME (decl));\n-\t    if (TREE_TYPE (decl) == current_class_type)\n-\t      error (\"  perhaps you want `%T' for a constructor\",\n-\t\t\tcurrent_class_name);\n-\t    dname = DECL_NAME (decl);\n-\t    name = IDENTIFIER_POINTER (dname);\n-\n-\t    /* Avoid giving two errors for this.  */\n-\t    IDENTIFIER_CLASS_VALUE (dname) = NULL_TREE;\n-\n-\t    declspecs = tree_cons (NULL_TREE, integer_type_node, declspecs);\n-\t    *next = dname;\n-\t    next = 0;\n+\t\tif (C_IS_RESERVED_WORD (dname))\n+\t\t  {\n+\t\t    error (\"declarator-id missing; using reserved word `%D'\",\n+\t\t\t   dname);\n+\t\t    name = IDENTIFIER_POINTER (dname);\n+\t\t  }\n+\t\telse if (!IDENTIFIER_TYPENAME_P (dname))\n+\t\t  name = IDENTIFIER_POINTER (dname);\n+\t\telse\n+\t\t  {\n+\t\t    my_friendly_assert (flags == NO_SPECIAL, 154);\n+\t\t    flags = TYPENAME_FLAG;\n+\t\t    ctor_return_type = TREE_TYPE (dname);\n+\t\t    sfk = sfk_conversion;\n+\t\t    if (is_typename_at_global_scope (dname))\n+\t\t      name = IDENTIFIER_POINTER (dname);\n+\t\t    else\n+\t\t      name = \"<invalid operator>\";\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case TYPE_DECL:\n+\t\tdname = constructor_name (TREE_TYPE (decl));\n+\t\tname = IDENTIFIER_POINTER (dname);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tabort ();\n+\t      }\n \t    break;\n \n-\t  case BASELINK:\n-\t    next = &BASELINK_FUNCTIONS (decl);\n+\t  case cdk_array:\n+\t  case cdk_pointer:\n+\t  case cdk_reference:\n+\t  case cdk_ptrmem:\n \t    break;\n \n-\t  case TEMPLATE_DECL:\n-\t    /* Sometimes, we see a template-name used as part of a \n-\t       decl-specifier like in \n-\t          std::allocator alloc;\n-\t       Handle that gracefully.  */\n-\t    error (\"invalid use of template-name '%E' in a declarator\", decl);\n-\t    return error_mark_node;\n+\t  case cdk_error:\n \t    break;\n-\t    \n+\n \t  default:\n-\t    my_friendly_assert (0, 20020917);\n+\t    abort ();\n \t  }\n-      }\n-  }\n+\t}\n+      if (id_declarator->kind == cdk_id)\n+\tbreak;\n+    }\n \n   /* A function definition's declarator must have the form of\n      a function declarator.  */\n \n-  if (funcdef_flag && innermost_code != CALL_EXPR)\n+  if (funcdef_flag && innermost_code != cdk_function)\n     return 0;\n \n   if (((dname && IDENTIFIER_OPNAME_P (dname)) || flags == TYPENAME_FLAG)\n-      && innermost_code != CALL_EXPR\n+      && innermost_code != cdk_function\n       && ! (ctype && declspecs == NULL_TREE))\n     {\n       error (\"declaration of `%D' as non-function\", dname);\n@@ -7143,10 +6981,10 @@ grokdeclarator (tree declarator,\n \t      if (declarator)\n \t\t{\n \t\t  /* Avoid trying to get an operand off an identifier node.  */\n-\t\t  if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n-\t\t    tmp = declarator;\n+\t\t  if (declarator->kind != cdk_id)\n+\t\t    tmp = declarator->declarator->u.id.name;\n \t\t  else\n-\t\t    tmp = TREE_OPERAND (declarator, 0);\n+\t\t    tmp = declarator->u.id.name;\n \t\t  op = IDENTIFIER_OPNAME_P (tmp);\n \t\t  if (IDENTIFIER_TYPENAME_P (tmp))\n \t\t    {\n@@ -7205,114 +7043,85 @@ grokdeclarator (tree declarator,\n   if (nclasses > 0 && friendp)\n     error (\"storage class specifiers invalid in friend function declarations\");\n \n-  scope = get_scope_of_declarator (declarator);\n-\n-  /* Now figure out the structure of the declarator proper.\n-     Descend through it, creating more complex types, until we reach\n-     the declared identifier (or NULL_TREE, in an abstract declarator).  */\n-\n-  while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE\n-\t && TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n+  if (!id_declarator)\n+    unqualified_id = NULL_TREE;\n+  else\n     {\n-      /* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]),\n-\t an INDIRECT_REF (for *...),\n-\t a CALL_EXPR (for ...(...)),\n-\t an identifier (for the name being declared)\n-\t or a null pointer (for the place in an absolute declarator\n-\t where the name was omitted).\n-\t For the last two cases, we have just exited the loop.\n-\n-\t For C++ it could also be\n-\t a SCOPE_REF (for class :: ...).  In this case, we have converted\n-\t sensible names to types, and those are the values we use to\n-\t qualify the member name.\n-\t an ADDR_EXPR (for &...),\n-\t a BIT_NOT_EXPR (for destructors)\n-\n-\t At this point, TYPE is the type of elements of an array,\n-\t or for a function to return, or for a pointer to point to.\n-\t After this sequence of ifs, TYPE is the type of the\n-\t array or function or pointer, and DECLARATOR has had its\n-\t outermost layer removed.  */\n-\n-      if (type == error_mark_node)\n+      unqualified_id = id_declarator->u.id.name;\n+      if (TREE_CODE (unqualified_id) == SCOPE_REF)\n+\tunqualified_id = TREE_OPERAND (unqualified_id, 1);\n+      if (TREE_CODE (unqualified_id) == BASELINK)\n+\tunqualified_id = BASELINK_FUNCTIONS (unqualified_id);\n+      switch (TREE_CODE (unqualified_id))\n \t{\n-\t  if (declarator == error_mark_node)\n-\t    return error_mark_node;\n-\t  else if (TREE_CODE (declarator) == SCOPE_REF)\n-\t    declarator = TREE_OPERAND (declarator, 1);\n-\t  else\n-\t    declarator = TREE_OPERAND (declarator, 0);\n-\t  continue;\n-\t}\n-      if (quals != NULL_TREE\n-\t  && (declarator == NULL_TREE\n-\t      || TREE_CODE (declarator) != SCOPE_REF))\n-\t{\n-\t  if (ctype == NULL_TREE && TREE_CODE (type) == METHOD_TYPE)\n-\t    ctype = TYPE_METHOD_BASETYPE (type);\n-\t  if (ctype != NULL_TREE)\n-\t    {\n-\t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n-\t      grok_method_quals (ctype, dummy, quals);\n-\t      type = TREE_TYPE (dummy);\n-\t      quals = NULL_TREE;\n-\t    }\n-\t}\n+\tcase BIT_NOT_EXPR:\n+\t  unqualified_id \n+\t    = constructor_name (TREE_OPERAND (unqualified_id, 0));\n+\t  break;\n+\t  \n+\tcase TYPE_DECL:\n+\t  unqualified_id \n+\t    = constructor_name (TREE_TYPE (unqualified_id));\n+\t  break;\n \n-      switch (TREE_CODE (declarator))\n-\t{\n-\tcase TREE_LIST:\n-\t  {\n-\t    /* We encode a declarator with embedded attributes using\n-\t       a TREE_LIST.  */\n-\t    tree attrs = TREE_PURPOSE (declarator);\n-\t    tree inner_decl;\n-\t    int attr_flags;\n-\n-\t    declarator = TREE_VALUE (declarator);\n-\t    inner_decl = declarator;\n-\t    while (inner_decl != NULL_TREE\n-\t\t   && TREE_CODE (inner_decl) == TREE_LIST)\n-\t      inner_decl = TREE_VALUE (inner_decl);\n-\t    attr_flags = 0;\n-\t    if (inner_decl == NULL_TREE\n-\t\t|| TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n-\t      attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n-\t    if (TREE_CODE (inner_decl) == CALL_EXPR)\n-\t      attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n-\t    if (TREE_CODE (inner_decl) == ARRAY_REF)\n-\t      attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n-\t    returned_attrs = decl_attributes (&type,\n-\t\t\t\t\t      chainon (returned_attrs, attrs),\n-\t\t\t\t\t      attr_flags);\n-\t  }\n+\tcase IDENTIFIER_NODE:\n+\tcase TEMPLATE_ID_EXPR:\n \t  break;\n+\t\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n \n-\tcase ARRAY_REF:\n-\t  {\n-\t    tree size = TREE_OPERAND (declarator, 1);\n-\t    declarator = TREE_OPERAND (declarator, 0);\n+  /* Determine the type of the entity declared by recurring on the\n+     declarator.  */\n+  for (; \n+       declarator && declarator->kind != cdk_id;\n+       declarator = declarator->declarator)\n+    {\n+      const cp_declarator *inner_declarator;\n+      tree attrs;\n \n-\t    type = create_array_type_for_decl (dname, type, size);\n+      if (type == error_mark_node)\n+\treturn error_mark_node;\n \n-\t    if (declarator\n-\t\t&& (TREE_CODE (declarator) == INDIRECT_REF\n-\t\t    || TREE_CODE (declarator) == ADDR_EXPR))\n-\t      /* We can never complete an array type which is the target of a\n-\t\t pointer, so go ahead and lay it out.  */\n-\t      layout_type (type);\n+      inner_declarator = declarator->declarator;\n \n-\t    ctype = NULL_TREE;\n-\t  }\n+      attrs = declarator->attributes;\n+      if (attrs)\n+\t{\n+\t  int attr_flags;\n+\t  \n+\t  attr_flags = 0;\n+\t  if (declarator == NULL || declarator->kind == cdk_id)\n+\t    attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n+\t  if (declarator->kind == cdk_function)\n+\t    attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n+\t  if (declarator->kind == cdk_array)\n+\t    attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n+\t  returned_attrs = decl_attributes (&type,\n+\t\t\t\t\t    chainon (returned_attrs, attrs),\n+\t\t\t\t\t    attr_flags);\n+\t}\n+\n+      switch (declarator->kind)\n+\t{\n+\tcase cdk_array:\n+\t  type = create_array_type_for_decl (dname, type, \n+\t\t\t\t\t     declarator->u.array.bounds);\n+\t  if (inner_declarator\n+\t      && (inner_declarator->kind == cdk_pointer\n+\t\t  || inner_declarator->kind == cdk_reference\n+\t\t  || inner_declarator->kind == cdk_ptrmem))\n+\t    /* We can never complete an array type which is the\n+\t       target of a pointer, so go ahead and lay it out.  */\n+\t    layout_type (type);\n \t  break;\n \n-\tcase CALL_EXPR:\n+\tcase cdk_function:\n \t  {\n \t    tree arg_types;\n \t    int funcdecl_p;\n-\t    tree inner_parms = CALL_DECLARATOR_PARMS (declarator);\n-\t    tree inner_decl = TREE_OPERAND (declarator, 0);\n \n \t    /* Declaring a function type.\n \t       Make sure we have a valid type for the function to return.  */\n@@ -7334,25 +7143,15 @@ grokdeclarator (tree declarator,\n \t\ttype = integer_type_node;\n \t      }\n \n-\t    if (inner_decl && TREE_CODE (inner_decl) == SCOPE_REF)\n-\t      inner_decl = TREE_OPERAND (inner_decl, 1);\n-\n-\t    if (inner_decl && TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR)\n-\t      inner_decl = dname;\n-\n \t    /* Pick up type qualifiers which should be applied to `this'.  */\n-\t    quals = CALL_DECLARATOR_QUALS (declarator);\n+\t    quals = declarator->u.function.qualifiers;\n \n \t    /* Pick up the exception specifications.  */\n-\t    raises = CALL_DECLARATOR_EXCEPTION_SPEC (declarator);\n+\t    raises = declarator->u.function.exception_specification;\n \n \t    /* Say it's a definition only for the CALL_EXPR\n \t       closest to the identifier.  */\n-\t    funcdecl_p\n-\t      = inner_decl\n-\t      && (TREE_CODE (inner_decl) == IDENTIFIER_NODE\n-\t\t  || TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR\n-\t\t  || TREE_CODE (inner_decl) == BIT_NOT_EXPR);\n+\t    funcdecl_p = inner_declarator && inner_declarator->kind == cdk_id;\n \n \t    if (ctype == NULL_TREE\n \t\t&& decl_context == FIELD\n@@ -7362,7 +7161,8 @@ grokdeclarator (tree declarator,\n \n \t    if (ctype && sfk == sfk_conversion)\n \t      TYPE_HAS_CONVERSION (ctype) = 1;\n-\t    if (ctype && constructor_name_p (dname, ctype))\n+\t    if (ctype && (sfk == sfk_constructor\n+\t\t\t  || sfk == sfk_destructor))\n \t      {\n \t\t/* We are within a class's scope. If our declarator name\n \t\t   is the same as the class name, and we are defining\n@@ -7451,83 +7251,84 @@ grokdeclarator (tree declarator,\n \t\t\t    name);\n \t      }\n \n-\t    /* Construct the function type and go to the next\n-\t       inner layer of declarator.  */\n-\n-\t    declarator = TREE_OPERAND (declarator, 0);\n-\n-\t    arg_types = grokparms (inner_parms, &parms);\n+\t    arg_types = grokparms (declarator->u.function.parameters, \n+\t\t\t\t   &parms);\n \n-\t    if (declarator && flags == DTOR_FLAG)\n+\t    if (inner_declarator\n+\t\t&& inner_declarator->kind == cdk_id\n+\t\t&& inner_declarator->u.id.sfk == sfk_destructor\n+\t\t&& arg_types != void_list_node)\n \t      {\n-\t\t/* A destructor declared in the body of a class will\n-\t\t   be represented as a BIT_NOT_EXPR.  But, we just\n-\t\t   want the underlying IDENTIFIER.  */\n-\t\tif (TREE_CODE (declarator) == BIT_NOT_EXPR)\n-\t\t  declarator = TREE_OPERAND (declarator, 0);\n-\n-                if (arg_types != void_list_node)\n-\t\t  {\n-\t\t    error (\"destructors may not have parameters\");\n-\t\t    arg_types = void_list_node;\n-\t\t    parms = NULL_TREE;\n-\t\t  }\n+\t\terror (\"destructors may not have parameters\");\n+\t\targ_types = void_list_node;\n+\t\tparms = NULL_TREE;\n \t      }\n-\n-\t    /* ANSI says that `const int foo ();'\n-\t       does not make the function foo const.  */\n+\t    \n \t    type = build_function_type (type, arg_types);\n \t  }\n \t  break;\n \n-\tcase ADDR_EXPR:\n-\tcase INDIRECT_REF:\n+\tcase cdk_pointer:\n+\tcase cdk_reference:\n+\tcase cdk_ptrmem:\n \t  /* Filter out pointers-to-references and references-to-references.\n \t     We can get these if a TYPE_DECL is used.  */\n \n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n-\t      error (TREE_CODE (declarator) == ADDR_EXPR\n+\t      error (declarator->kind == cdk_reference\n \t\t     ? \"cannot declare reference to `%#T'\"\n \t\t     : \"cannot declare pointer to `%#T'\", type);\n \t      type = TREE_TYPE (type);\n \t    }\n-\t  else if (VOID_TYPE_P (type)\n-\t\t   && (ctype || TREE_CODE (declarator) == ADDR_EXPR))\n-\t    error (ctype ? \"cannot declare pointer to `%#T' member\"\n-\t\t     : \"cannot declare reference to `%#T'\", type);\n-\n-\t  /* Merge any constancy or volatility into the target type\n-\t     for the pointer.  */\n+\t  else if (VOID_TYPE_P (type))\n+\t    {\n+\t      if (declarator->kind == cdk_reference)\n+\t\terror (\"cannot declare reference to `%#T'\", type);\n+\t      else if (declarator->kind == cdk_ptrmem)\n+\t\terror (\"cannot declare pointer to `%#T' member\", type);\n+\t    }\n \n \t  /* We now know that the TYPE_QUALS don't apply to the decl,\n \t     but to the target of the pointer.  */\n \t  type_quals = TYPE_UNQUALIFIED;\n \n-\t  if (TREE_CODE (declarator) == ADDR_EXPR)\n+\t  if (declarator->kind == cdk_ptrmem\n+\t      && (TREE_CODE (type) == FUNCTION_TYPE\n+\t\t  || (quals && TREE_CODE (type) == METHOD_TYPE)))\n+\t    {\n+\t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n+\t      grok_method_quals (declarator->u.pointer.class_type, \n+\t\t\t\t dummy, quals);\n+\t      type = TREE_TYPE (dummy);\n+\t      quals = NULL_TREE;\n+\t    }\n+\n+\t  if (declarator->kind == cdk_reference)\n \t    {\n \t      if (!VOID_TYPE_P (type))\n \t\ttype = build_reference_type (type);\n \t    }\n \t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t    type = build_ptrmemfunc_type (build_pointer_type (type));\n-\t  else if (ctype)\n-\t    type = build_ptrmem_type (ctype, type);\n+\t  else if (declarator->kind == cdk_ptrmem)\n+\t    type = build_ptrmem_type (declarator->u.pointer.class_type, \n+\t\t\t\t      type);\n \t  else\n \t    type = build_pointer_type (type);\n \n \t  /* Process a list of type modifier keywords (such as\n \t     const or volatile) that were given inside the `*' or `&'.  */\n \n-\t  if (TREE_TYPE (declarator))\n+\t  if (declarator->u.pointer.qualifiers)\n \t    {\n \t      tree typemodlist;\n \t      int erred = 0;\n \t      int constp = 0;\n \t      int volatilep = 0;\n \t      int restrictp = 0;\n \t      \n-\t      for (typemodlist = TREE_TYPE (declarator); typemodlist;\n+\t      for (typemodlist = declarator->u.pointer.qualifiers; typemodlist;\n \t\t   typemodlist = TREE_CHAIN (typemodlist))\n \t\t{\n \t\t  tree qualifier = TREE_VALUE (typemodlist);\n@@ -7562,158 +7363,115 @@ grokdeclarator (tree declarator,\n \t      type = cp_build_qualified_type (type, type_quals);\n \t      type_quals = cp_type_quals (type);\n \t    }\n-\t  declarator = TREE_OPERAND (declarator, 0);\n \t  ctype = NULL_TREE;\n \t  break;\n \n-\tcase SCOPE_REF:\n-\t  {\n-\t    /* We have converted type names to NULL_TREE if the\n-\t       name was bogus, or to a _TYPE node, if not.\n-\n-\t       The variable CTYPE holds the type we will ultimately\n-\t       resolve to.  The code here just needs to build\n-\t       up appropriate member types.  */\n-\t    tree sname = TREE_OPERAND (declarator, 1);\n-\t    tree t;\n-\n-\t    /* Destructors can have their visibilities changed as well.  */\n-\t    if (TREE_CODE (sname) == BIT_NOT_EXPR)\n-\t      sname = TREE_OPERAND (sname, 0);\n-\n-\t    if (TREE_OPERAND (declarator, 0) == NULL_TREE)\n-\t      {\n-\t\t/* We had a reference to a global decl, or\n-\t\t   perhaps we were given a non-aggregate typedef,\n-\t\t   in which case we cleared this out, and should just\n-\t\t   keep going as though it wasn't there.  */\n-\t\tdeclarator = sname;\n-\t\tcontinue;\n-\t      }\n-\t    ctype = TREE_OPERAND (declarator, 0);\n+\tcase cdk_error:\n+\t  break;\n \n-\t    t = ctype;\n-\t    if (TREE_CODE (TREE_OPERAND (declarator, 1)) != INDIRECT_REF)\n-\t      while (t != NULL_TREE && CLASS_TYPE_P (t))\n-\t\t{\n-\t\t  /* You're supposed to have one `template <...>'\n-\t\t     for every template class, but you don't need one\n-\t\t     for a full specialization.  For example:\n-\t\t     \n-\t\t     template <class T> struct S{};\n-\t\t     template <> struct S<int> { void f(); };\n-\t\t     void S<int>::f () {}\n-\t\t     \n-\t\t     is correct; there shouldn't be a `template <>' for\n-\t\t     the definition of `S<int>::f'.  */\n-\t\t  if (CLASSTYPE_TEMPLATE_INFO (t)\n-\t\t      && (CLASSTYPE_TEMPLATE_INSTANTIATION (t)\n-\t\t\t  || uses_template_parms (CLASSTYPE_TI_ARGS (t)))\n-\t\t      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n-\t\t    template_count += 1;\n-\t\t  \n-\t\t  t = TYPE_MAIN_DECL (t);\n-\t\t  t = DECL_CONTEXT (t);\n-\t\t}\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  \n+  if (unqualified_id && TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR\n+      && TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != METHOD_TYPE)\n+    {\n+      error (\"template-id `%D' used as a declarator\", \n+\t     unqualified_id);\n+      unqualified_id = dname;\n+    }\n \n-\t    if (sname == NULL_TREE)\n-\t      goto done_scoping;\n+  /* If DECLARATOR is non-NULL, we know it is a cdk_id declarator;\n+     otherwise, we would not have exited the loop above.  */\n+  if (declarator \n+      && TREE_CODE (declarator->u.id.name) == SCOPE_REF\n+      /* If the qualifying scope was invalid, it will have been set to\n+\t NULL_TREE above.  */\n+      && TREE_OPERAND (declarator->u.id.name, 0)\n+      && TYPE_P (TREE_OPERAND (declarator->u.id.name, 0)))\n+    {\n+      tree t;\n \n-\t    if (TREE_CODE (sname) == IDENTIFIER_NODE)\n-\t      {\n-\t\t/* This is the `standard' use of the scoping operator:\n-\t\t   basetype :: member .  */\n+      ctype = TREE_OPERAND (declarator->u.id.name, 0);\n+      if (TYPE_P (ctype))\n+\tctype = TYPE_MAIN_VARIANT (ctype);\n+      t = ctype;\n+      while (t != NULL_TREE && CLASS_TYPE_P (t))\n+\t{\n+\t  /* You're supposed to have one `template <...>' for every\n+\t     template class, but you don't need one for a full\n+\t     specialization.  For example:\n \n-\t\tif (ctype == current_class_type)\n-\t\t  {\n-\t\t    /* class A {\n-\t\t         void A::f ();\n-\t\t       };\n+\t       template <class T> struct S{};\n+\t       template <> struct S<int> { void f(); };\n+\t       void S<int>::f () {}\n \n-\t\t       Is this ill-formed?  */\n+\t     is correct; there shouldn't be a `template <>' for the\n+\t     definition of `S<int>::f'.  */\n+\t  if (CLASSTYPE_TEMPLATE_INFO (t)\n+\t      && (CLASSTYPE_TEMPLATE_INSTANTIATION (t)\n+\t\t  || uses_template_parms (CLASSTYPE_TI_ARGS (t)))\n+\t      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n+\t    template_count += 1;\n \n-\t\t    if (pedantic)\n-\t\t      pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n-\t\t\t\t  ctype, name);\n-\t\t  }\n-\t\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t\t  {\n-\t\t    if (NEW_DELETE_OPNAME_P (sname))\n-\t\t      /* Overloaded operator new and operator delete\n-\t\t\t are always static functions.  */\n-\t\t      ;\n-\t\t    else if (current_class_type == NULL_TREE || friendp)\n-\t\t      type \n-\t\t\t= build_method_type_directly (ctype, \n-\t\t\t\t\t\t      TREE_TYPE (type),\n-\t\t\t\t\t\t      TYPE_ARG_TYPES (type));\n-\t\t    else\n-\t\t      {\n-\t\t\terror (\"cannot declare member function `%T::%s' within `%T'\",\n-\t\t\t\t  ctype, name, current_class_type);\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t  }\n-\t\telse if (RIDBIT_SETP (RID_TYPEDEF, specbits)\n-\t\t\t || COMPLETE_TYPE_P (complete_type (ctype)))\n-\t\t  {\n-\t\t    /* Have to move this code elsewhere in this function.\n-\t\t       this code is used for i.e., typedef int A::M; M *pm;\n-\n-\t\t       It is?  How? jason 10/2/94 */\n-\n-\t\t    if (current_class_type)\n-\t\t      {\n-\t\t\terror (\"cannot declare member `%T::%s' within `%T'\",\n-\t\t\t\t  ctype, name, current_class_type);\n-\t\t\treturn void_type_node;\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t          {\n-\t            cxx_incomplete_type_error (NULL_TREE, ctype);\n-\t            return error_mark_node;\n-\t\t  }\n+\t  t = TYPE_MAIN_DECL (t);\n+\t  t = DECL_CONTEXT (t);\n+\t}\n \n-\t\tdeclarator = sname;\n-\t      }\n-\t    else if (TREE_CODE (sname) == SCOPE_REF)\n-\t      abort ();\n-\t    else\n-\t      {\n-\t      done_scoping:\n-\t\tdeclarator = TREE_OPERAND (declarator, 1);\n-\t\tif (declarator && TREE_CODE (declarator) == CALL_EXPR)\n-\t\t  /* In this case, we will deal with it later.  */\n-\t\t  ;\n-\t\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t\t  type = build_method_type_directly (ctype, \n-\t\t\t\t\t\t     TREE_TYPE (type),\n-\t\t\t\t\t\t     TYPE_ARG_TYPES (type));\n-\t      }\n-\t  }\n-\t  break;\n+      if (ctype == current_class_type)\n+\t{\n+\t  /* class A {\n+\t       void A::f ();\n+\t     };\n \n-\tcase BIT_NOT_EXPR:\n-\t  declarator = TREE_OPERAND (declarator, 0);\n-\t  break;\n+\t     Is this ill-formed?  */\n \n-\tcase BASELINK:\n-\t  declarator = BASELINK_FUNCTIONS (declarator);\n-\t  break;\n+\t  if (pedantic)\n+\t    pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n+\t\t\tctype, name);\n+\t}\n+      else if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t{\n+\t  tree sname = TREE_OPERAND (declarator->u.id.name, 1);\n \n-\tcase RECORD_TYPE:\n-\tcase UNION_TYPE:\n-\tcase ENUMERAL_TYPE:\n-\t  declarator = NULL_TREE;\n-\t  break;\n+\t  if (TREE_CODE (sname) == IDENTIFIER_NODE\n+\t      && NEW_DELETE_OPNAME_P (sname))\n+\t    /* Overloaded operator new and operator delete\n+\t       are always static functions.  */\n+\t    ;\n+\t  else if (current_class_type == NULL_TREE || friendp)\n+\t    type \n+\t      = build_method_type_directly (ctype, \n+\t\t\t\t\t    TREE_TYPE (type),\n+\t\t\t\t\t    TYPE_ARG_TYPES (type));\n+\t  else\n+\t    {\n+\t      error (\"cannot declare member function `%T::%s' within `%T'\",\n+ \t\t     ctype, name, current_class_type);\n+\t      return error_mark_node;\n+\t    }\n+\t}\n+      else if (RIDBIT_SETP (RID_TYPEDEF, specbits)\n+\t       || COMPLETE_TYPE_P (complete_type (ctype)))\n+\t{\n+\t  /* Have to move this code elsewhere in this function.\n+\t     this code is used for i.e., typedef int A::M; M *pm;\n \n-\tcase ERROR_MARK:\n-\t  declarator = NULL_TREE;\n-\t  break;\n+\t     It is?  How? jason 10/2/94 */\n \n-\tdefault:\n-\t  abort ();\n+\t  if (current_class_type)\n+\t    {\n+\t      error (\"cannot declare member `%T::%s' within `%T'\",\n+\t\t     ctype, name, current_class_type);\n+\t      return void_type_node;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  cxx_incomplete_type_error (NULL_TREE, ctype);\n+\t  return error_mark_node;\n \t}\n     }\n \n@@ -7788,24 +7546,7 @@ grokdeclarator (tree declarator,\n \t}\n     }\n \n-  if (declarator == NULL_TREE\n-      || TREE_CODE (declarator) == ERROR_MARK\n-      || TREE_CODE (declarator) == IDENTIFIER_NODE\n-      || (TREE_CODE (declarator) == TEMPLATE_ID_EXPR\n-\t  && (TREE_CODE (type) == FUNCTION_TYPE\n-\t      || TREE_CODE (type) == METHOD_TYPE)))\n-    /* OK */;\n-  else if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n-    {\n-      error (\"template-id `%D' used as a declarator\", declarator);\n-      declarator = dname;\n-    }\n-  else\n-    /* Unexpected declarator format.  */\n-    abort ();\n-\n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n-\n   if (RIDBIT_SETP (RID_TYPEDEF, specbits) && decl_context != TYPENAME)\n     {\n       tree decl;\n@@ -7817,14 +7558,14 @@ grokdeclarator (tree declarator,\n \n       if (decl_context == FIELD)\n \t{\n-\t  if (constructor_name_p (declarator, current_class_type))\n+\t  if (constructor_name_p (unqualified_id, current_class_type))\n \t    pedwarn (\"ISO C++ forbids nested type `%D' with same name as enclosing class\",\n-\t\t\tdeclarator);\n-\t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n+\t\t     unqualified_id);\n+\t  decl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n \t}\n       else\n \t{\n-\t  decl = build_decl (TYPE_DECL, declarator, type);\n+\t  decl = build_decl (TYPE_DECL, unqualified_id, type);\n \t  if (in_namespace || ctype)\n \t    error (\"%Jtypedef name may not be a nested-name-specifier\", decl);\n \t  if (!current_function_decl)\n@@ -7836,7 +7577,7 @@ grokdeclarator (tree declarator,\n \t Nothing can refer to it, so nothing needs know about the name\n \t change.  */\n       if (type != error_mark_node\n-\t  && declarator\n+\t  && unqualified_id\n \t  && TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && TYPE_ANONYMOUS_P (type)\n@@ -7848,7 +7589,7 @@ grokdeclarator (tree declarator,\n \t  tree t;\n \n \t  /* Replace the anonymous name with the real name everywhere.  */\n-\t  lookup_tag_reverse (type, declarator);\n+\t  lookup_tag_reverse (type, unqualified_id);\n \t  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n \t    if (TYPE_NAME (t) == oldname)\n \t      TYPE_NAME (t) = decl;\n@@ -7984,21 +7725,21 @@ grokdeclarator (tree declarator,\n \t    }\n \t  if (ctype)\n \t    {\n-\t      tree dummy = build_decl (TYPE_DECL, declarator, type);\n+\t      tree dummy = build_decl (TYPE_DECL, unqualified_id, type);\n \t      grok_method_quals (ctype, dummy, quals);\n \t      type = TREE_TYPE (dummy);\n \t    }\n \t}\n \n       return type;\n     }\n-  else if (declarator == NULL_TREE && decl_context != PARM\n+  else if (unqualified_id == NULL_TREE && decl_context != PARM\n \t   && decl_context != CATCHPARM\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && ! bitfield)\n     {\n       error (\"abstract declarator `%T' used as declaration\", type);\n-      declarator = make_anon_name ();\n+      unqualified_id = make_anon_name ();\n     }\n \n   /* `void' at top level (not within pointer)\n@@ -8008,11 +7749,11 @@ grokdeclarator (tree declarator,\n \n   if (TREE_CODE (type) == VOID_TYPE && decl_context != PARM)\n     {\n-      if (! declarator)\n+      if (! unqualified_id)\n \terror (\"unnamed variable or field declared void\");\n-      else if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n+      else if (TREE_CODE (unqualified_id) == IDENTIFIER_NODE)\n \t{\n-\t  if (IDENTIFIER_OPNAME_P (declarator))\n+\t  if (IDENTIFIER_OPNAME_P (unqualified_id))\n \t    abort ();\n \t  else\n \t    error (\"variable or field `%s' declared void\", name);\n@@ -8049,7 +7790,7 @@ grokdeclarator (tree declarator,\n \n     if (decl_context == PARM)\n       {\n-\tdecl = cp_build_parm_decl (declarator, type);\n+\tdecl = cp_build_parm_decl (unqualified_id, type);\n \n \tbad_specifiers (decl, \"parameter\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n@@ -8083,10 +7824,10 @@ grokdeclarator (tree declarator,\n \n \t    /* We catch the others as conflicts with the builtin\n \t       typedefs.  */\n-\t    if (friendp && declarator == ridpointers[(int) RID_SIGNED])\n+\t    if (friendp && unqualified_id == ridpointers[(int) RID_SIGNED])\n \t      {\n \t\terror (\"function `%D' cannot be declared friend\",\n-\t\t\t  declarator);\n+\t\t       unqualified_id);\n \t\tfriendp = 0;\n \t      }\n \n@@ -8098,7 +7839,7 @@ grokdeclarator (tree declarator,\n \t\tif (ctype == NULL_TREE)\n \t\t  {\n \t\t    error (\"can't make `%D' into a method -- not in a class\",\n-\t\t\t      declarator);\n+\t\t\t   unqualified_id);\n \t\t    return void_type_node;\n \t\t  }\n \n@@ -8107,16 +7848,16 @@ grokdeclarator (tree declarator,\n \t\tif (virtualp && TREE_CODE (ctype) == UNION_TYPE)\n \t\t  {\n \t\t    error (\"function `%D' declared virtual inside a union\",\n-\t\t\t      declarator);\n+\t\t\t   unqualified_id);\n \t\t    return void_type_node;\n \t\t  }\n \n-\t\tif (NEW_DELETE_OPNAME_P (declarator))\n+\t\tif (NEW_DELETE_OPNAME_P (unqualified_id))\n \t\t  {\n \t\t    if (virtualp)\n \t\t      {\n \t\t\terror (\"`%D' cannot be declared virtual, since it is always static\",\n-\t\t\t\t  declarator);\n+\t\t\t       unqualified_id);\n \t\t\tvirtualp = 0;\n \t\t      }\n \t\t  }\n@@ -8132,10 +7873,10 @@ grokdeclarator (tree declarator,\n \t    publicp = (! friendp || ! staticp)\n \t      && function_context == NULL_TREE;\n \t    decl = grokfndecl (ctype, type,\n-\t\t\t       TREE_CODE (declarator) != TEMPLATE_ID_EXPR\n-\t\t\t       ? declarator : dname,\n+\t\t\t       TREE_CODE (unqualified_id) != TEMPLATE_ID_EXPR\n+\t\t\t       ? unqualified_id : dname,\n \t\t\t       parms,\n-\t\t\t       declarator,\n+\t\t\t       unqualified_id,\n \t\t\t       virtualp, flags, quals, raises,\n \t\t\t       friendp ? -1 : 0, friendp, publicp, inlinep,\n \t\t\t       funcdef_flag, template_count, in_namespace);\n@@ -8179,10 +7920,10 @@ grokdeclarator (tree declarator,\n \t    /* All method decls are public, so tell grokfndecl to set\n \t       TREE_PUBLIC, also.  */\n \t    decl = grokfndecl (ctype, type,\n-\t\t\t       TREE_CODE (declarator) != TEMPLATE_ID_EXPR\n-\t\t\t       ? declarator : dname,\n+\t\t\t       TREE_CODE (unqualified_id) != TEMPLATE_ID_EXPR\n+\t\t\t       ? unqualified_id : dname,\n \t\t\t       parms,\n-\t\t\t       declarator,\n+\t\t\t       unqualified_id,\n \t\t\t       virtualp, flags, quals, raises,\n \t\t\t       friendp ? -1 : 0, friendp, 1, 0, funcdef_flag,\n \t\t\t       template_count, in_namespace);\n@@ -8193,8 +7934,8 @@ grokdeclarator (tree declarator,\n \t\t && !COMPLETE_TYPE_P (complete_type (type))\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n \t  {\n-\t    if (declarator)\n-\t      error (\"field `%D' has incomplete type\", declarator);\n+\t    if (unqualified_id)\n+\t      error (\"field `%D' has incomplete type\", unqualified_id);\n \t    else\n \t      error (\"name `%T' has incomplete type\", type);\n \n@@ -8216,7 +7957,7 @@ grokdeclarator (tree declarator,\n \t    if (friendp)\n \t      {\n \t\terror (\"`%E' is neither function nor member function; \"\n-                       \"cannot be declared friend\", declarator);\n+                       \"cannot be declared friend\", unqualified_id);\n \t\tfriendp = 0;\n \t      }\n \t    decl = NULL_TREE;\n@@ -8232,13 +7973,13 @@ grokdeclarator (tree declarator,\n \t\tif (template_class_depth (current_class_type) == 0)\n \t\t  {\n \t\t    decl = check_explicit_specialization\n-\t\t      (declarator, decl, template_count,\n+\t\t      (unqualified_id, decl, template_count,\n \t\t       2 * (funcdef_flag != 0) + 4);\n \t\t    if (decl == error_mark_node)\n \t\t      return error_mark_node;\n \t\t  }\n \t\t\n-\t\tdecl = do_friend (ctype, declarator, decl,\n+\t\tdecl = do_friend (ctype, unqualified_id, decl,\n \t\t\t\t  *attrlist, flags, quals, funcdef_flag);\n \t\treturn decl;\n \t      }\n@@ -8267,15 +8008,15 @@ grokdeclarator (tree declarator,\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n \t\t    pedwarn (\"ISO C++ forbids initialization of member `%D'\",\n-\t\t\t\tdeclarator);\n-\t\t    pedwarn (\"making `%D' static\", declarator);\n+\t\t\t     unqualified_id);\n+\t\t    pedwarn (\"making `%D' static\", unqualified_id);\n \t\t    staticp = 1;\n \t\t  }\n \n \t\tif (uses_template_parms (type))\n \t\t  /* We'll check at instantiation time.  */\n \t\t  ;\n-\t\telse if (check_static_variable_definition (declarator,\n+\t\telse if (check_static_variable_definition (unqualified_id,\n \t\t\t\t\t\t\t   type))\n \t\t  /* If we just return the declaration, crashes\n \t\t     will sometimes occur.  We therefore return\n@@ -8289,14 +8030,14 @@ grokdeclarator (tree declarator,\n \t      {\n \t\t/* C++ allows static class members.  All other work\n \t\t   for this is done by grokfield.  */\n-\t\tdecl = build_lang_decl (VAR_DECL, declarator, type);\n+\t\tdecl = build_lang_decl (VAR_DECL, unqualified_id, type);\n \t\tTREE_STATIC (decl) = 1;\n \t\t/* In class context, 'static' means public access.  */\n \t\tTREE_PUBLIC (decl) = DECL_EXTERNAL (decl) = 1;\n \t      }\n \t    else\n \t      {\n-\t\tdecl = build_decl (FIELD_DECL, declarator, type);\n+\t\tdecl = build_decl (FIELD_DECL, unqualified_id, type);\n \t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \t\tif (RIDBIT_SETP (RID_MUTABLE, specbits))\n \t\t  {\n@@ -8315,13 +8056,13 @@ grokdeclarator (tree declarator,\n \ttree original_name;\n \tint publicp = 0;\n \n-\tif (! declarator)\n+\tif (!unqualified_id)\n \t  return NULL_TREE;\n \n-\tif (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+\tif (TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR)\n \t  original_name = dname;\n \telse\n-\t  original_name = declarator;\n+\t  original_name = unqualified_id;\n \n \tif (RIDBIT_SETP (RID_AUTO, specbits))\n \t  error (\"storage class `auto' invalid for function `%s'\", name);\n@@ -8363,7 +8104,7 @@ grokdeclarator (tree declarator,\n \t\t   || RIDBIT_SETP (RID_EXTERN, specbits)\n \t\t   || !RIDBIT_SETP (RID_STATIC, specbits));\n \n-\tdecl = grokfndecl (ctype, type, original_name, parms, declarator,\n+\tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n \t\t\t   virtualp, flags, quals, raises,\n \t\t\t   1, friendp,\n \t\t\t   publicp, inlinep, funcdef_flag,\n@@ -8401,7 +8142,7 @@ grokdeclarator (tree declarator,\n \t/* It's a variable.  */\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, declarator, &specbits,\n+\tdecl = grokvardecl (type, unqualified_id, &specbits,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    ctype ? ctype : in_namespace);\n@@ -8601,48 +8342,33 @@ check_default_argument (tree decl, tree arg)\n    Given the list of things declared inside the parens,\n    return a list of types.\n \n-   We determine whether ellipsis parms are used by PARMLIST_ELLIPSIS_P\n-   flag. If unset, we append void_list_node. A parmlist declared\n-   as `(void)' is accepted as the empty parmlist.\n+   If this parameter does not end with an ellipsis, we append\n+   void_list_node.\n \n    *PARMS is set to the chain of PARM_DECLs created.  */\n \n static tree\n-grokparms (tree first_parm, tree *parms)\n+grokparms (const cp_parameter_declarator *first_parm, tree *parms)\n {\n   tree result = NULL_TREE;\n   tree decls = NULL_TREE;\n-  int ellipsis = !first_parm || PARMLIST_ELLIPSIS_P (first_parm);\n-  tree parm, chain;\n+  int ellipsis = !first_parm || first_parm->ellipsis_p;\n+  const cp_parameter_declarator *parm;\n   int any_error = 0;\n \n-  my_friendly_assert (!first_parm || TREE_PARMLIST (first_parm), 20001115);\n-\n-  for (parm = first_parm; parm != NULL_TREE; parm = chain)\n+  for (parm = first_parm; parm != NULL; parm = parm->next)\n     {\n       tree type = NULL_TREE;\n-      tree decl = TREE_VALUE (parm);\n-      tree init = TREE_PURPOSE (parm);\n+      tree decl_specifiers = parm->decl_specifiers;\n+      tree init = parm->default_argument;\n       tree specs, attrs;\n+      tree decl;\n \n-      chain = TREE_CHAIN (parm);\n-      /* @@ weak defense against parse errors.  */\n-      if (TREE_CODE (decl) != VOID_TYPE\n-\t  && TREE_CODE (decl) != TREE_LIST)\n-\t{\n-\t  /* Give various messages as the need arises.  */\n-\t  if (TREE_CODE (decl) == STRING_CST)\n-\t    error (\"invalid string constant `%E'\", decl);\n-\t  else if (TREE_CODE (decl) == INTEGER_CST)\n-\t    error (\"invalid integer constant in parameter list, did you forget to give parameter name?\");\n-\t  continue;\n-\t}\n-\n-      if (parm == void_list_node)\n+      if (parm == no_parameters)\n         break;\n \n-      split_specs_attrs (TREE_PURPOSE (decl), &specs, &attrs);\n-      decl = grokdeclarator (TREE_VALUE (decl), specs,\n+      split_specs_attrs (decl_specifiers, &specs, &attrs);\n+      decl = grokdeclarator (parm->declarator, specs,\n \t\t\t     PARM, init != NULL_TREE, &attrs);\n       if (! decl || TREE_TYPE (decl) == error_mark_node)\n         continue;\n@@ -8654,7 +8380,7 @@ grokparms (tree first_parm, tree *parms)\n       if (VOID_TYPE_P (type))\n         {\n           if (same_type_p (type, void_type_node)\n-              && !DECL_NAME (decl) && !result && !chain && !ellipsis)\n+              && !DECL_NAME (decl) && !result && !parm->next && !ellipsis)\n             /* this is a parmlist of `(void)', which is ok.  */\n             break;\n           cxx_incomplete_type_error (decl, type);\n@@ -10036,19 +9762,14 @@ check_function_type (tree decl, tree current_function_parms)\n    This function creates a binding context for the function body\n    as well as setting up the FUNCTION_DECL in current_function_decl.\n \n-   Returns 1 on success.  If the DECLARATOR is not suitable for a function\n-   (it defines a datum instead), we return 0, which tells\n-   yyparse to report a parse error.\n-\n    For C++, we must first check whether that datum makes any sense.\n    For example, \"class A local_a(1,2);\" means that variable local_a\n    is an aggregate of type A, which should have a constructor\n    applied to it with the argument list [1, 2].  */\n \n-int\n-start_function (tree declspecs, tree declarator, tree attrs, int flags)\n+void\n+start_preparsed_function (tree decl1, tree attrs, int flags)\n {\n-  tree decl1;\n   tree ctype = NULL_TREE;\n   tree fntype;\n   tree restype;\n@@ -10060,67 +9781,23 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n   my_friendly_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE, 160);\n   my_friendly_assert (TREE_CHAIN (void_list_node) == NULL_TREE, 161);\n \n-  /* This should only be done once on the top most decl.  */\n-  if (have_extern_spec)\n-    {\n-      declspecs = tree_cons (NULL_TREE, get_identifier (\"extern\"), declspecs);\n-      have_extern_spec = false;\n-    }\n-\n-  if (flags & SF_PRE_PARSED)\n-    {\n-      decl1 = declarator;\n-\n-      fntype = TREE_TYPE (decl1);\n-      if (TREE_CODE (fntype) == METHOD_TYPE)\n-\tctype = TYPE_METHOD_BASETYPE (fntype);\n-\n-      /* ISO C++ 11.4/5.  A friend function defined in a class is in\n-\t the (lexical) scope of the class in which it is defined.  */\n-      if (!ctype && DECL_FRIEND_P (decl1))\n-\t{\n-\t  ctype = DECL_FRIEND_CONTEXT (decl1);\n-\n-\t  /* CTYPE could be null here if we're dealing with a template;\n-\t     for example, `inline friend float foo()' inside a template\n-\t     will have no CTYPE set.  */\n-\t  if (ctype && TREE_CODE (ctype) != RECORD_TYPE)\n-\t    ctype = NULL_TREE;\n-\t  else\n-\t    doing_friend = 1;\n-\t}\n-    }\n-  else\n+  fntype = TREE_TYPE (decl1);\n+  if (TREE_CODE (fntype) == METHOD_TYPE)\n+    ctype = TYPE_METHOD_BASETYPE (fntype);\n+  \n+  /* ISO C++ 11.4/5.  A friend function defined in a class is in\n+     the (lexical) scope of the class in which it is defined.  */\n+  if (!ctype && DECL_FRIEND_P (decl1))\n     {\n-      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, &attrs);\n-      /* If the declarator is not suitable for a function definition,\n-\t cause a syntax error.  */\n-      if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL)\n-\treturn 0;\n-\n-      cplus_decl_attributes (&decl1, attrs, 0);\n-\n-      /* If #pragma weak was used, mark the decl weak now.  */\n-      if (global_scope_p (current_binding_level))\n-\tmaybe_apply_pragma_weak (decl1);\n-\n-      fntype = TREE_TYPE (decl1);\n-\n-      restype = TREE_TYPE (fntype);\n-\n-      if (TREE_CODE (fntype) == METHOD_TYPE)\n-\tctype = TYPE_METHOD_BASETYPE (fntype);\n-      else if (DECL_MAIN_P (decl1))\n-\t{\n-\t  /* If this doesn't return integer_type, or a typedef to\n-\t     integer_type, complain.  */\n-\t  if (!same_type_p (TREE_TYPE (TREE_TYPE (decl1)), integer_type_node))\n-\t    {\n-\t      if (pedantic || warn_return_type)\n-\t\tpedwarn (\"return type for `main' changed to `int'\");\n-\t      TREE_TYPE (decl1) = fntype = default_function_type;\n-\t    }\n-\t}\n+      ctype = DECL_FRIEND_CONTEXT (decl1);\n+      \n+      /* CTYPE could be null here if we're dealing with a template;\n+\t for example, `inline friend float foo()' inside a template\n+\t will have no CTYPE set.  */\n+      if (ctype && TREE_CODE (ctype) != RECORD_TYPE)\n+\tctype = NULL_TREE;\n+      else\n+\tdoing_friend = 1;\n     }\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n@@ -10382,6 +10059,55 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n   start_fname_decls ();\n   \n   store_parm_decls (current_function_parms);\n+}\n+\n+\n+/* Like start_preparsed_function, except that instead of a\n+   FUNCTION_DECL, this function takes DECLSPECS and DECLARATOR.\n+\n+   Returns 1 on success.  If the DECLARATOR is not suitable for a function\n+   (it defines a datum instead), we return 0, which tells\n+   yyparse to report a parse error.  */\n+\n+int\n+start_function (tree declspecs, const cp_declarator *declarator,\n+\t\ttree attrs)\n+{\n+  tree decl1;\n+\n+  if (have_extern_spec)\n+    {\n+      declspecs = tree_cons (NULL_TREE, get_identifier (\"extern\"), \n+\t\t\t     declspecs);\n+      /* This should only be done once on the outermost decl.  */\n+      have_extern_spec = false;\n+    }\n+  \n+  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, &attrs);\n+  /* If the declarator is not suitable for a function definition,\n+     cause a syntax error.  */\n+  if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL)\n+    return 0;\n+  \n+  cplus_decl_attributes (&decl1, attrs, 0);\n+  \n+  /* If #pragma weak was used, mark the decl weak now.  */\n+  if (global_scope_p (current_binding_level))\n+    maybe_apply_pragma_weak (decl1);\n+  \n+  if (DECL_MAIN_P (decl1))\n+    {\n+      /* If this doesn't return integer_type, or a typedef to\n+\t integer_type, complain.  */\n+      if (!same_type_p (TREE_TYPE (TREE_TYPE (decl1)), integer_type_node))\n+\t{\n+\t  if (pedantic || warn_return_type)\n+\t    pedwarn (\"return type for `main' changed to `int'\");\n+\t  TREE_TYPE (decl1) = default_function_type;\n+\t}\n+    }\n+\n+  start_preparsed_function (decl1, attrs, /*flags=*/SF_DEFAULT);\n \n   return 1;\n }\n@@ -10872,7 +10598,7 @@ finish_function (int flags)\n    CHANGES TO CODE IN `grokfield'.  */\n \n tree\n-start_method (tree declspecs, tree declarator, tree attrlist)\n+start_method (tree declspecs, const cp_declarator *declarator, tree attrlist)\n {\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n \t\t\t\t&attrlist);\n@@ -11184,7 +10910,6 @@ tree\n build_void_list_node (void)\n {\n   tree t = build_tree_list (NULL_TREE, void_type_node);\n-  TREE_PARMLIST (t) = 1;\n   return t;\n }\n "}, {"sha": "871d568a0c58b05508624cc0fa35fe50f797bcd6", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -31,7 +31,7 @@ enum decl_context\n };\n \n /* We need this in here to get the decl_context definition.  */\n-extern tree grokdeclarator (tree, tree, enum decl_context, int, tree*);\n+extern tree grokdeclarator (const cp_declarator *, tree, enum decl_context, int, tree*);\n \n #ifdef DEBUG_CP_BINDING_LEVELS\n /* Purely for debugging purposes.  */"}, {"sha": "80e56ec82e7bc97381477bfea9eefdf8cfbefd19", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -127,7 +127,7 @@ grok_method_quals (tree ctype, tree function, tree quals)\n   int dup_quals = TYPE_UNQUALIFIED;\n   int this_quals = TYPE_UNQUALIFIED;\n \n-  do\n+  while (quals)\n     {\n       int tq = cp_type_qual_from_rid (TREE_VALUE (quals));\n       \n@@ -139,7 +139,6 @@ grok_method_quals (tree ctype, tree function, tree quals)\n \ttype_quals |= tq;\n       quals = TREE_CHAIN (quals);\n     } \n-  while (quals);\n \n   if (dup_quals != TYPE_UNQUALIFIED)\n     error (\"duplicate type qualifiers in %s declaration\",\n@@ -168,7 +167,7 @@ grok_x_components (tree specs)\n   specs = strip_attrs (specs);\n \n   check_tag_decl (specs);\n-  t = groktypename (build_tree_list (specs, NULL_TREE)); \n+  t = groktypename (specs, /*declarator=*/NULL);\n \n   /* The only case where we need to do anything additional here is an\n      anonymous union field, e.g.: `struct S { union { int i; }; };'.  */\n@@ -841,23 +840,27 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n    CHANGES TO CODE IN `start_method'.  */\n \n tree\n-grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n+grokfield (const cp_declarator *declarator, tree declspecs, \n+\t   tree init, tree asmspec_tree,\n            tree attrlist)\n {\n   tree value;\n   const char *asmspec = 0;\n   int flags = LOOKUP_ONLYCONVERTING;\n \n   if (declspecs == NULL_TREE\n-      && TREE_CODE (declarator) == SCOPE_REF\n-      && TREE_CODE (TREE_OPERAND (declarator, 1)) == IDENTIFIER_NODE)\n+      && declarator->kind == cdk_id\n+      && TREE_CODE (declarator->u.id.name) == SCOPE_REF\n+      && (TREE_CODE (TREE_OPERAND (declarator->u.id.name, 1)) \n+\t  == IDENTIFIER_NODE))\n     {\n       /* Access declaration */\n-      if (! IS_AGGR_TYPE_CODE (TREE_CODE (TREE_OPERAND (declarator, 0))))\n+      if (! IS_AGGR_TYPE_CODE (TREE_CODE \n+\t\t\t       (TREE_OPERAND (declarator->u.id.name, 0))))\n \t;\n-      else if (TREE_COMPLEXITY (declarator) == current_class_depth)\n+      else if (TREE_COMPLEXITY (declarator->u.id.name) == current_class_depth)\n \tpop_nested_class ();\n-      return do_class_using_decl (declarator);\n+      return do_class_using_decl (declarator->u.id.name);\n     }\n \n   if (init\n@@ -1020,7 +1023,7 @@ grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */\n \n tree\n-grokbitfield (tree declarator, tree declspecs, tree width)\n+grokbitfield (const cp_declarator *declarator, tree declspecs, tree width)\n {\n   tree value = grokdeclarator (declarator, declspecs, BITFIELD, 0, NULL);\n \n@@ -1915,8 +1918,8 @@ set_guard (tree guard)\n static tree\n start_objects (int method_type, int initp)\n {\n-  tree fnname;\n   tree body;\n+  tree fndecl;\n   char type[10];\n \n   /* Make ctor or dtor function.  METHOD_TYPE may be 'I' or 'D'.  */\n@@ -1936,12 +1939,11 @@ start_objects (int method_type, int initp)\n   else\n     sprintf (type, \"%c\", method_type);\n \n-  fnname = get_file_function_name_long (type);\n-\n-  start_function (void_list_node,\n-\t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n-\t\t\t\t\tNULL_TREE),\n-\t\t  NULL_TREE, SF_DEFAULT);\n+  fndecl = build_lang_decl (FUNCTION_DECL, \n+\t\t\t    get_file_function_name_long (type),\n+\t\t\t    build_function_type (void_type_node,\n+\t\t\t\t\t\t void_list_node));\n+  start_preparsed_function (fndecl, /*attrs=*/NULL_TREE, SF_PRE_PARSED);\n \n   /* It can be a static function as long as collect2 does not have\n      to scan the object file to find its ctor/dtor routine.  */\n@@ -2108,10 +2110,9 @@ start_static_storage_duration_function (unsigned count)\n        \n      It is static because we only need to call this function from the\n      various constructor and destructor functions for this module.  */\n-  start_function (/*specs=*/NULL_TREE, \n-\t\t  ssdf_decl,\n-\t\t  /*attrs=*/NULL_TREE,\n-\t\t  SF_PRE_PARSED);\n+  start_preparsed_function (ssdf_decl,\n+\t\t\t    /*attrs=*/NULL_TREE,\n+\t\t\t    SF_PRE_PARSED);\n \n   /* Set up the scope of the outermost block in the function.  */\n   body = begin_compound_stmt (BCS_FN_BODY);"}, {"sha": "c2a98781431ad4d2910f9543615254975f95ab41", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 134, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -1665,126 +1665,18 @@ build_builtin_delete_call (tree addr)\n    PLACEMENT is the `placement' list for user-defined operator new ().  */\n \n tree\n-build_new (tree placement, tree decl, tree init, int use_global_new)\n+build_new (tree placement, tree type, tree nelts, tree init, \n+\t   int use_global_new)\n {\n-  tree type, rval;\n-  tree nelts = NULL_TREE, t;\n-  int has_array = 0;\n+  tree rval;\n \n-  if (decl == error_mark_node)\n+  if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (decl) == TREE_LIST)\n-    {\n-      tree absdcl = TREE_VALUE (decl);\n-      tree last_absdcl = NULL_TREE;\n-\n-      if (current_function_decl\n-\t  && DECL_CONSTRUCTOR_P (current_function_decl))\n-\tmy_friendly_assert (immediate_size_expand == 0, 19990926);\n-\n-      nelts = integer_one_node;\n-\n-      if (absdcl && TREE_CODE (absdcl) == CALL_EXPR)\n-\tabort ();\n-      while (absdcl && TREE_CODE (absdcl) == INDIRECT_REF)\n-\t{\n-\t  last_absdcl = absdcl;\n-\t  absdcl = TREE_OPERAND (absdcl, 0);\n-\t}\n-\n-      if (absdcl && TREE_CODE (absdcl) == ARRAY_REF)\n-\t{\n-\t  /* Probably meant to be a vec new.  */\n-\t  tree this_nelts;\n-\n-\t  while (TREE_OPERAND (absdcl, 0)\n-\t\t && TREE_CODE (TREE_OPERAND (absdcl, 0)) == ARRAY_REF)\n-\t    {\n-\t      last_absdcl = absdcl;\n-\t      absdcl = TREE_OPERAND (absdcl, 0);\n-\t    }\n-\n-\t  has_array = 1;\n-\t  this_nelts = TREE_OPERAND (absdcl, 1);\n-\t  if (this_nelts != error_mark_node)\n-\t    {\n-\t      if (this_nelts == NULL_TREE)\n-\t\terror (\"new of array type fails to specify size\");\n-\t      else if (processing_template_decl)\n-\t\t{\n-\t\t  nelts = this_nelts;\n-\t\t  absdcl = TREE_OPERAND (absdcl, 0);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (build_expr_type_conversion (WANT_INT | WANT_ENUM, \n-\t\t\t\t\t\t  this_nelts, false)\n-\t\t      == NULL_TREE)\n-\t\t    pedwarn (\"size in array new must have integral type\");\n-\n-\t\t  this_nelts = save_expr (cp_convert (sizetype, this_nelts));\n-\t\t  absdcl = TREE_OPERAND (absdcl, 0);\n-\t          if (this_nelts == integer_zero_node)\n-\t\t    {\n-\t\t      warning (\"zero size array reserves no space\");\n-\t\t      nelts = integer_zero_node;\n-\t\t    }\n-\t\t  else\n-\t\t    nelts = cp_build_binary_op (MULT_EXPR, nelts, this_nelts);\n-\t\t}\n-\t    }\n-\t  else\n-\t    nelts = integer_zero_node;\n-\t}\n-\n-      if (last_absdcl)\n-\tTREE_OPERAND (last_absdcl, 0) = absdcl;\n-      else\n-\tTREE_VALUE (decl) = absdcl;\n-\n-      type = groktypename (decl);\n-      if (! type || type == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-  else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n-    {\n-      if (IDENTIFIER_HAS_TYPE_VALUE (decl))\n-\t{\n-\t  /* An aggregate type.  */\n-\t  type = IDENTIFIER_TYPE_VALUE (decl);\n-\t  decl = TYPE_MAIN_DECL (type);\n-\t}\n-      else\n-\t{\n-\t  /* A builtin type.  */\n-\t  decl = lookup_name (decl, 1);\n-\t  my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 215);\n-\t  type = TREE_TYPE (decl);\n-\t}\n-    }\n-  else if (TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      type = TREE_TYPE (decl);\n-    }\n-  else\n-    {\n-      type = decl;\n-      decl = TYPE_MAIN_DECL (type);\n-    }\n-\n   if (processing_template_decl)\n     {\n-      if (has_array)\n-\tt = tree_cons (tree_cons (NULL_TREE, type, NULL_TREE),\n-\t\t       build_min_nt (ARRAY_REF, NULL_TREE, nelts,\n-\t\t\t\t     NULL_TREE, NULL_TREE),\n-\t\t       NULL_TREE);\n-      else\n-\tt = type;\n-\t\n       rval = build_min (NEW_EXPR, build_pointer_type (type), \n-\t\t\tplacement, t, init);\n+\t\t\tplacement, type, nelts, init);\n       NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n       TREE_SIDE_EFFECTS (rval) = 1;\n       return rval;\n@@ -1805,22 +1697,8 @@ build_new (tree placement, tree decl, tree init, int use_global_new)\n       return error_mark_node;\n     }\n \n-  /* When the object being created is an array, the new-expression yields a\n-     pointer to the initial element (if any) of the array.  For example,\n-     both new int and new int[10] return an int*.  5.3.4.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && has_array == 0)\n-    {\n-      nelts = array_type_nelts_top (type);\n-      has_array = 1;\n-      type = TREE_TYPE (type);\n-    }\n-\n-  if (has_array)\n-    t = build_nt (ARRAY_REF, type, nelts, NULL_TREE, NULL_TREE);\n-  else\n-    t = type;\n-\n-  rval = build (NEW_EXPR, build_pointer_type (type), placement, t, init);\n+  rval = build (NEW_EXPR, build_pointer_type (type), placement, type,\n+\t\tnelts, init);\n   NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n   TREE_SIDE_EFFECTS (rval) = 1;\n   rval = build_new_1 (rval);\n@@ -1957,15 +1835,14 @@ build_new_1 (tree exp)\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n-  init = TREE_OPERAND (exp, 2);\n+  nelts = TREE_OPERAND (exp, 2);\n+  init = TREE_OPERAND (exp, 3);\n   globally_qualified_p = NEW_EXPR_USE_GLOBAL (exp);\n \n-  if (TREE_CODE (type) == ARRAY_REF)\n+  if (nelts)\n     {\n       has_array = 1;\n-      nelts = outer_nelts = TREE_OPERAND (type, 1);\n-      type = TREE_OPERAND (type, 0);\n-\n+      outer_nelts = nelts;\n       /* Use an incomplete array type to avoid VLA headaches.  */\n       full_type = build_cplus_array_type (type, NULL_TREE);\n     }"}, {"sha": "7152e692759296c780c760f9a8cef231b8553694", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -82,62 +82,6 @@ struct impl_files\n \n static struct impl_files *impl_file_chain;\n \n-\f\n-/* Return something to represent absolute declarators containing a *.\n-   TARGET is the absolute declarator that the * contains.\n-   CV_QUALIFIERS is a list of modifiers such as const or volatile\n-   to apply to the pointer type, represented as identifiers.\n-\n-   We return an INDIRECT_REF whose \"contents\" are TARGET\n-   and whose type is the modifier list.  */\n-\n-tree\n-make_pointer_declarator (tree cv_qualifiers, tree target)\n-{\n-  if (target && TREE_CODE (target) == IDENTIFIER_NODE\n-      && ANON_AGGRNAME_P (target))\n-    error (\"type name expected before `*'\");\n-  target = build_nt (INDIRECT_REF, target);\n-  TREE_TYPE (target) = cv_qualifiers;\n-  return target;\n-}\n-\n-/* Return something to represent absolute declarators containing a &.\n-   TARGET is the absolute declarator that the & contains.\n-   CV_QUALIFIERS is a list of modifiers such as const or volatile\n-   to apply to the reference type, represented as identifiers.\n-\n-   We return an ADDR_EXPR whose \"contents\" are TARGET\n-   and whose type is the modifier list.  */\n-\n-tree\n-make_reference_declarator (tree cv_qualifiers, tree target)\n-{\n-  target = build_nt (ADDR_EXPR, target);\n-  TREE_TYPE (target) = cv_qualifiers;\n-  return target;\n-}\n-\n-tree\n-make_call_declarator (tree target, tree parms, tree cv_qualifiers, \n-                      tree exception_specification)\n-{\n-  target = build_nt (CALL_EXPR, target,\n-\t\t     tree_cons (parms, cv_qualifiers, NULL_TREE),\n-\t\t     /* The third operand is really RTL.  We\n-\t\t\tshouldn't put anything there.  */\n-\t\t     NULL_TREE);\n-  CALL_DECLARATOR_EXCEPTION_SPEC (target) = exception_specification;\n-  return target;\n-}\n-\n-void\n-set_quals_and_spec (tree call_declarator, tree cv_qualifiers, \n-                    tree exception_specification)\n-{\n-  CALL_DECLARATOR_QUALS (call_declarator) = cv_qualifiers;\n-  CALL_DECLARATOR_EXCEPTION_SPEC (call_declarator) = exception_specification;\n-}\n \f\n int interface_only;\t\t/* whether or not current file is only for\n \t\t\t\t   interface definitions.  */"}, {"sha": "cc06725c3c3b40bdd68f473ac098f8186c6099b8", "filename": "gcc/cp/method.c", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -448,7 +448,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n       DECL_RESULT (thunk_fndecl) = NULL_TREE;\n \n-      start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n+      start_preparsed_function (thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n       /* We don't bother with a body block for thunks.  */\n \n       /* There's no need to check accessibility inside the thunk body.  */\n@@ -742,7 +742,7 @@ synthesize_method (tree fndecl)\n   DECL_SOURCE_LOCATION (fndecl) = input_location;\n \n   interface_unknown = 1;\n-  start_function (NULL_TREE, fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n+  start_preparsed_function (fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n   clear_last_expr ();\n   stmt = begin_function_body ();\n \n@@ -937,78 +937,94 @@ locate_copy (tree type, void *client_)\n tree\n implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n {\n-  tree declspecs = NULL_TREE;\n-  tree fn, args = NULL_TREE;\n+  tree fn;\n+  tree parameter_types = void_list_node;\n+  tree return_type = void_type_node;\n+  tree fn_type;\n   tree raises = empty_except_spec;\n-  bool retref = false;\n-  bool has_parm = false;\n-  tree name = constructor_name (type);\n+  tree rhs_parm_type = NULL_TREE;\n+  tree name;\n \n   switch (kind)\n     {\n     case sfk_destructor:\n       /* Destructor.  */\n-      name = build_nt (BIT_NOT_EXPR, name);\n-      args = void_list_node;\n+      name = constructor_name (type);\n       raises = synthesize_exception_spec (type, &locate_dtor, 0);\n       break;\n \n     case sfk_constructor:\n       /* Default constructor.  */\n-      args = void_list_node;\n+      name = constructor_name (type);\n       raises = synthesize_exception_spec (type, &locate_ctor, 0);\n+      TYPE_HAS_CONSTRUCTOR (type) = 1;\n       break;\n \n     case sfk_copy_constructor:\n+      TYPE_HAS_CONSTRUCTOR (type) = 1;\n+      /* Fall through. */\n     case sfk_assignment_operator:\n     {\n       struct copy_data data;\n-      tree argtype = type;\n       \n-      has_parm = true;\n       data.name = NULL;\n       data.quals = 0;\n       if (kind == sfk_assignment_operator)\n         {\n-          retref = true;\n-          declspecs = build_tree_list (NULL_TREE, type);\n-\n+\t  return_type = build_reference_type (type);\n           name = ansi_assopname (NOP_EXPR);\n           data.name = name;\n         }\n+      else\n+\tname = constructor_name (type);\n+\n       if (const_p)\n         {\n           data.quals = TYPE_QUAL_CONST;\n-          argtype = build_qualified_type (argtype, TYPE_QUAL_CONST);\n+\t  rhs_parm_type = build_qualified_type (type, TYPE_QUAL_CONST);\n         }\n-    \n-      argtype = build_reference_type (argtype);\n-      args = build_tree_list (hash_tree_chain (argtype, NULL_TREE),\n-\t\t\t      get_identifier (\"_ctor_arg\"));\n-      args = tree_cons (NULL_TREE, args, void_list_node);\n-      \n+      else\n+\trhs_parm_type = type;\n+      rhs_parm_type = build_reference_type (rhs_parm_type);\n+      parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n       raises = synthesize_exception_spec (type, &locate_copy, &data);\n       break;\n     }\n     default:\n       abort ();\n     }\n \n-  TREE_PARMLIST (args) = 1;\n-\n-  {\n-    tree declarator = make_call_declarator (name, args, NULL_TREE, raises);\n-    \n-    if (retref)\n-      declarator = build_nt (ADDR_EXPR, declarator);\n-\n-    fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE, NULL_TREE);\n-    if (has_parm)\n-      TREE_USED (FUNCTION_FIRST_USER_PARM (fn)) = 1;\n-  }\n-\n-  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 20000408);\n+  /* Create the function.  */\n+  fn_type = build_method_type_directly (type, return_type, parameter_types);\n+  if (raises)\n+    fn_type = build_exception_variant (fn_type, raises);\n+  fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n+  if (kind == sfk_constructor || kind == sfk_copy_constructor)\n+    DECL_CONSTRUCTOR_P (fn) = 1;\n+  else if (kind == sfk_destructor)\n+    DECL_DESTRUCTOR_P (fn) = 1;\n+  else\n+    {\n+      DECL_ASSIGNMENT_OPERATOR_P (fn) = 1;\n+      SET_OVERLOADED_OPERATOR_CODE (fn, NOP_EXPR);\n+    }\n+  /* Create the argument list.  The call to \"grokclassfn\" will add the\n+     \"this\" parameter and any other implicit parameters.  */\n+  if (rhs_parm_type)\n+    {\n+      /* Note that this parameter is *not* marked DECL_ARTIFICIAL; we\n+\t want its type to be included in the mangled function\n+\t name.  */\n+      DECL_ARGUMENTS (fn) = cp_build_parm_decl (NULL_TREE, rhs_parm_type);\n+      TREE_READONLY (DECL_ARGUMENTS (fn)) = 1;\n+    }\n \n+  grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL,\n+\t       /*quals=*/NULL_TREE);\n+  grok_special_member_properties (fn);\n+  cp_finish_decl (fn, /*init=*/NULL_TREE, /*asmspec_tree=*/NULL_TREE,\n+\t\t  /*flags=*/LOOKUP_ONLYCONVERTING);\n+  DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;"}, {"sha": "448a0b376a900cc1c91194574701872631d6140a", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -132,7 +132,7 @@ maybe_clone_body (tree fn)\n \n       /* Start processing the function.  */\n       push_to_top_level ();\n-      start_function (NULL_TREE, clone, NULL_TREE, SF_PRE_PARSED);\n+      start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n \n       /* Remap the parameters.  */\n       decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);"}, {"sha": "d86f203967506a3be3b469cdd08d1e63d8733632", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 558, "deletions": 298, "changes": 856, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -995,6 +995,181 @@ cp_lexer_stop_debugging (cp_lexer* lexer)\n }\n \n \f\n+/* Declarators.  */\n+\n+/* Nothing other than the parser should be creating declarators;\n+   declarators are a semi-syntactic representation of C++ entities.\n+   Other parts of the front end that need to create entities (like\n+   VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n+\n+static cp_declarator *make_id_declarator \n+  (tree);\n+static cp_declarator *make_call_declarator\t\n+  (cp_declarator *, cp_parameter_declarator *, tree, tree);\n+static cp_declarator *make_array_declarator\t\n+  (cp_declarator *, tree);\n+static cp_declarator *make_pointer_declarator\t\n+  (tree, cp_declarator *);\n+static cp_declarator *make_reference_declarator\t\n+  (tree, cp_declarator *);\n+static cp_parameter_declarator *make_parameter_declarator \n+  (tree, cp_declarator *, tree);\n+static cp_declarator *make_ptrmem_declarator\t\n+  (tree, tree, cp_declarator *);\n+\n+cp_declarator *cp_error_declarator;\n+\n+/* The obstack on which declarators and related data structures are\n+   allocated.  */\n+static struct obstack declarator_obstack;\n+\n+/* Alloc BYTES from the declarator memory pool.  */\n+\n+static inline void *\n+alloc_declarator (size_t bytes)\n+{\n+  return obstack_alloc (&declarator_obstack, bytes);\n+}\n+\n+/* Allocate a declarator of the indicated KIND.  Clear fields that are\n+   common to all declarators.  */\n+\n+static cp_declarator *\n+make_declarator (cp_declarator_kind kind)\n+{\n+  cp_declarator *declarator;\n+\n+  declarator = (cp_declarator *) alloc_declarator (sizeof (cp_declarator));\n+  declarator->kind = kind;\n+  declarator->attributes = NULL_TREE;\n+  declarator->declarator = NULL;\n+\n+  return declarator;\n+}\n+\n+/* Make a declarator for a generalized identifier.  */\n+\n+cp_declarator *\n+make_id_declarator (tree id)\n+{\n+  cp_declarator *declarator;\n+  \n+  declarator = make_declarator (cdk_id);\n+  declarator->u.id.name = id;\n+  declarator->u.id.sfk = sfk_none;\n+\n+  return declarator;\n+}\n+\n+/* Make a declarator for a pointer to TARGET.  CV_QUALIFIERS is a list\n+   of modifiers such as const or volatile to apply to the pointer\n+   type, represented as identifiers.  */\n+\n+cp_declarator *\n+make_pointer_declarator (tree cv_qualifiers, cp_declarator *target)\n+{\n+  cp_declarator *declarator;\n+\n+  declarator = make_declarator (cdk_pointer);\n+  declarator->declarator = target;\n+  declarator->u.pointer.qualifiers = cv_qualifiers;\n+  declarator->u.pointer.class_type = NULL_TREE;\n+\n+  return declarator;\n+}\n+\n+/* Like make_pointer_declarator -- but for references.  */\n+\n+cp_declarator *\n+make_reference_declarator (tree cv_qualifiers, cp_declarator *target)\n+{\n+  cp_declarator *declarator;\n+\n+  declarator = make_declarator (cdk_reference);\n+  declarator->declarator = target;\n+  declarator->u.pointer.qualifiers = cv_qualifiers;\n+  declarator->u.pointer.class_type = NULL_TREE;\n+\n+  return declarator;\n+}\n+\n+/* Like make_pointer_declarator -- but for a pointer to a non-static\n+   member of CLASS_TYPE.  */\n+\n+cp_declarator *\n+make_ptrmem_declarator (tree cv_qualifiers, tree class_type,\n+\t\t\tcp_declarator *pointee)\n+{\n+  cp_declarator *declarator;\n+\n+  declarator = make_declarator (cdk_ptrmem);\n+  declarator->declarator = pointee;\n+  declarator->u.pointer.qualifiers = cv_qualifiers;\n+  declarator->u.pointer.class_type = class_type;\n+\n+  return declarator;\n+}\n+\n+/* Make a declarator for the function given by TARGET, with the\n+   indicated PARMS.  The CV_QUALIFIERS aply to the function, as in\n+   \"const\"-qualified member function.  The EXCEPTION_SPECIFICATION\n+   indicates what exceptions can be thrown.  */\n+\n+cp_declarator *\n+make_call_declarator (cp_declarator *target, \n+\t\t      cp_parameter_declarator *parms,\n+\t\t      tree cv_qualifiers, \n+                      tree exception_specification)\n+{\n+  cp_declarator *declarator;\n+\n+  declarator = make_declarator (cdk_function);\n+  declarator->declarator = target;\n+  declarator->u.function.parameters = parms;\n+  declarator->u.function.qualifiers = cv_qualifiers;\n+  declarator->u.function.exception_specification = exception_specification;\n+\n+  return declarator;\n+}\n+\n+/* Make a declarator for an array of BOUNDS elements, each of which is\n+   defined by ELEMENT.  */\n+\n+cp_declarator *\n+make_array_declarator (cp_declarator *element, tree bounds)\n+{\n+  cp_declarator *declarator;\n+\n+  declarator = make_declarator (cdk_array);\n+  declarator->declarator = element;\n+  declarator->u.array.bounds = bounds;\n+\n+  return declarator;\n+}\n+\n+cp_parameter_declarator *no_parameters;\n+\n+/* Create a parameter declarator with the indicated DECL_SPECIFIERS,\n+   DECLARATOR and DEFAULT_ARGUMENT.  */\n+\n+cp_parameter_declarator *\n+make_parameter_declarator (tree decl_specifiers, \n+\t\t\t   cp_declarator *declarator,\n+\t\t\t   tree default_argument)\n+{\n+  cp_parameter_declarator *parameter;\n+\n+  parameter = ((cp_parameter_declarator *) \n+\t       alloc_declarator (sizeof (cp_parameter_declarator)));\n+  parameter->next = NULL;\n+  parameter->decl_specifiers = decl_specifiers;\n+  parameter->declarator = declarator;\n+  parameter->default_argument = default_argument;\n+  parameter->ellipsis_p = false;\n+\n+  return parameter;\n+}\n+\n /* The parser.  */\n \n /* Overview\n@@ -1366,10 +1541,10 @@ static tree cp_parser_new_expression\n static tree cp_parser_new_placement\n   (cp_parser *);\n static tree cp_parser_new_type_id\n+  (cp_parser *, tree *);\n+static cp_declarator *cp_parser_new_declarator_opt\n   (cp_parser *);\n-static tree cp_parser_new_declarator_opt\n-  (cp_parser *);\n-static tree cp_parser_direct_new_declarator\n+static cp_declarator *cp_parser_direct_new_declarator\n   (cp_parser *);\n static tree cp_parser_new_initializer\n   (cp_parser *);\n@@ -1495,9 +1670,9 @@ static void cp_parser_linkage_specification\n \n static tree cp_parser_init_declarator\n   (cp_parser *, tree, tree, bool, bool, int, bool *);\n-static tree cp_parser_declarator\n+static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *);\n-static tree cp_parser_direct_declarator\n+static cp_declarator *cp_parser_direct_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *);\n static enum tree_code cp_parser_ptr_operator\n   (cp_parser *, tree *, tree *);\n@@ -1511,11 +1686,11 @@ static tree cp_parser_type_id\n   (cp_parser *);\n static tree cp_parser_type_specifier_seq\n   (cp_parser *);\n-static tree cp_parser_parameter_declaration_clause\n+static cp_parameter_declarator *cp_parser_parameter_declaration_clause\n   (cp_parser *);\n-static tree cp_parser_parameter_declaration_list\n-  (cp_parser *);\n-static tree cp_parser_parameter_declaration\n+static cp_parameter_declarator *cp_parser_parameter_declaration_list\n+  (cp_parser *, bool *);\n+static cp_parameter_declarator *cp_parser_parameter_declaration\n   (cp_parser *, bool, bool *);\n static void cp_parser_function_body\n   (cp_parser *);\n@@ -1561,7 +1736,7 @@ static tree cp_parser_conversion_function_id\n   (cp_parser *);\n static tree cp_parser_conversion_type_id\n   (cp_parser *);\n-static tree cp_parser_conversion_declarator_opt\n+static cp_declarator *cp_parser_conversion_declarator_opt\n   (cp_parser *);\n static bool cp_parser_ctor_initializer_opt\n   (cp_parser *);\n@@ -1586,7 +1761,7 @@ static void cp_parser_template_declaration\n static tree cp_parser_template_parameter_list\n   (cp_parser *);\n static tree cp_parser_template_parameter\n-  (cp_parser *);\n+  (cp_parser *, bool *);\n static tree cp_parser_type_parameter\n   (cp_parser *);\n static tree cp_parser_template_id\n@@ -1647,7 +1822,7 @@ static tree cp_parser_lookup_name_simple\n static tree cp_parser_maybe_treat_template_as_class\n   (tree, bool);\n static bool cp_parser_check_declarator_template_parameters\n-  (cp_parser *, tree);\n+  (cp_parser *, cp_declarator *);\n static bool cp_parser_check_template_parameters\n   (cp_parser *, unsigned);\n static tree cp_parser_simple_cast_expression\n@@ -1659,7 +1834,7 @@ static tree cp_parser_global_scope_opt\n static bool cp_parser_constructor_declarator_p\n   (cp_parser *, bool);\n static tree cp_parser_function_definition_from_specifiers_and_declarator\n-  (cp_parser *, tree, tree, tree);\n+  (cp_parser *, tree, tree, const cp_declarator *);\n static tree cp_parser_function_definition_after_declarator\n   (cp_parser *, bool);\n static void cp_parser_template_declaration_after_export\n@@ -1669,7 +1844,7 @@ static tree cp_parser_single_declaration\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n-  (cp_parser *, tree, tree, tree);\n+  (cp_parser *, tree, cp_declarator *, tree);\n static tree cp_parser_enclosed_template_argument_list\n   (cp_parser *);\n static void cp_parser_save_default_args\n@@ -1729,7 +1904,7 @@ static bool cp_parser_simulate_error\n static void cp_parser_check_type_definition\n   (cp_parser *);\n static void cp_parser_check_for_definition_in_return_type\n-  (tree, int);\n+  (cp_declarator *, int);\n static void cp_parser_check_for_invalid_template_id\n   (cp_parser *, tree);\n static bool cp_parser_non_integral_constant_expression\n@@ -1871,18 +2046,19 @@ cp_parser_check_type_definition (cp_parser* parser)\n    then an error is issued.  */\n \n static void\n-cp_parser_check_for_definition_in_return_type (tree declarator,\n+cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n \t\t\t\t\t       int declares_class_or_enum)\n {\n   /* [dcl.fct] forbids type definitions in return types.\n      Unfortunately, it's not easy to know whether or not we are\n      processing a return type until after the fact.  */\n   while (declarator\n-\t && (TREE_CODE (declarator) == INDIRECT_REF\n-\t     || TREE_CODE (declarator) == ADDR_EXPR))\n-    declarator = TREE_OPERAND (declarator, 0);\n+\t && (declarator->kind == cdk_pointer\n+\t     || declarator->kind == cdk_reference\n+\t     || declarator->kind == cdk_ptrmem))\n+    declarator = declarator->declarator;\n   if (declarator\n-      && TREE_CODE (declarator) == CALL_EXPR\n+      && declarator->kind == cdk_function\n       && declares_class_or_enum & 2)\n     error (\"new types may not be defined in a return type\");\n }\n@@ -2423,27 +2599,55 @@ cp_parser_identifier (cp_parser* parser)\n static bool\n cp_parser_translation_unit (cp_parser* parser)\n {\n+  /* The address of the first non-permanent object on the declarator\n+     obstack.  */\n+  static void *declarator_obstack_base;\n+\n+  bool success;\n+  \n+  /* Create the declarator obstack, if necessary.  */\n+  if (!cp_error_declarator)\n+    {\n+      gcc_obstack_init (&declarator_obstack);\n+      /* Create the error declarator.  */\n+      cp_error_declarator = make_declarator (cdk_error);\n+      /* Create the empty parameter list.  */\n+      no_parameters = make_parameter_declarator (NULL_TREE, NULL, NULL_TREE);\n+      /* Remember where the base of the declarator obstack lies.  */\n+      declarator_obstack_base = obstack_next_free (&declarator_obstack);\n+    }\n+\n   while (true)\n     {\n       cp_parser_declaration_seq_opt (parser);\n \n       /* If there are no tokens left then all went well.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n-\tbreak;\n+\t{\n+\t  /* Consume the EOF token.  */\n+\t  cp_parser_require (parser, CPP_EOF, \"end-of-file\");\n+\t  \n+\t  /* Finish up.  */\n+\t  finish_translation_unit ();\n \n-      /* Otherwise, issue an error message.  */\n-      cp_parser_error (parser, \"expected declaration\");\n-      return false;\n+\t  success = true;\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  cp_parser_error (parser, \"expected declaration\");\n+\t  success = false;\n+\t  break;\n+\t}\n     }\n \n-  /* Consume the EOF token.  */\n-  cp_parser_require (parser, CPP_EOF, \"end-of-file\");\n-\n-  /* Finish up.  */\n-  finish_translation_unit ();\n+  /* Make sure the declarator obstack was fully cleaned up.  */\n+  my_friendly_assert (obstack_next_free (&declarator_obstack) ==\n+\t\t      declarator_obstack_base,\n+\t\t      20040621);\n \n   /* All went well.  */\n-  return true;\n+  return success;\n }\n \n /* Expressions [gram.expr] */\n@@ -4557,6 +4761,7 @@ cp_parser_new_expression (cp_parser* parser)\n   tree placement;\n   tree type;\n   tree initializer;\n+  tree nelts;\n \n   /* Look for the optional `::' operator.  */\n   global_scope_p\n@@ -4593,10 +4798,11 @@ cp_parser_new_expression (cp_parser* parser)\n \t  inform (\"try removing the parentheses around the type-id\");\n \t  cp_parser_direct_new_declarator (parser);\n \t}\n+      nelts = integer_one_node;\n     }\n   /* Otherwise, there must be a new-type-id.  */\n   else\n-    type = cp_parser_new_type_id (parser);\n+    type = cp_parser_new_type_id (parser, &nelts);\n \n   /* If the next token is a `(', then we have a new-initializer.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n@@ -4610,7 +4816,7 @@ cp_parser_new_expression (cp_parser* parser)\n     return error_mark_node;\n \n   /* Create a representation of the new-expression.  */\n-  return build_new (placement, type, initializer, global_scope_p);\n+  return build_new (placement, type, nelts, initializer, global_scope_p);\n }\n \n /* Parse a new-placement.\n@@ -4637,15 +4843,19 @@ cp_parser_new_placement (cp_parser* parser)\n    new-type-id:\n      type-specifier-seq new-declarator [opt]\n \n-   Returns a TREE_LIST whose TREE_PURPOSE is the type-specifier-seq,\n-   and whose TREE_VALUE is the new-declarator.  */\n+   Returns the TYPE allocated.  If the new-type-id indicates an array\n+   type, *NELTS is set to the number of elements in the last array\n+   bound; the TYPE will not include the last array bound.  */\n \n static tree\n-cp_parser_new_type_id (cp_parser* parser)\n+cp_parser_new_type_id (cp_parser* parser, tree *nelts)\n {\n   tree type_specifier_seq;\n-  tree declarator;\n+  cp_declarator *new_declarator;\n+  cp_declarator *declarator;\n+  cp_declarator *outer_declarator;\n   const char *saved_message;\n+  tree type;\n \n   /* The type-specifier sequence must not contain type definitions.\n      (It cannot contain declarations of new types either, but if they\n@@ -4659,9 +4869,56 @@ cp_parser_new_type_id (cp_parser* parser)\n   /* Restore the old message.  */\n   parser->type_definition_forbidden_message = saved_message;\n   /* Parse the new-declarator.  */\n-  declarator = cp_parser_new_declarator_opt (parser);\n+  new_declarator = cp_parser_new_declarator_opt (parser);\n \n-  return build_tree_list (type_specifier_seq, declarator);\n+  /* Determine the number of elements in the last array dimension, if\n+     any.  */\n+  *nelts = NULL_TREE;\n+  /* Skip down to the last array dimension.  */\n+  declarator = new_declarator;\n+  outer_declarator = NULL;\n+  while (declarator && (declarator->kind == cdk_pointer\n+\t\t\t|| declarator->kind == cdk_ptrmem))\n+    {\n+      outer_declarator = declarator;\n+      declarator = declarator->declarator;\n+    }\n+  while (declarator \n+\t && declarator->kind == cdk_array\n+\t && declarator->declarator\n+\t && declarator->declarator->kind == cdk_array)\n+    {\n+      outer_declarator = declarator;\n+      declarator = declarator->declarator;\n+    }\n+  \n+  if (declarator && declarator->kind == cdk_array)\n+    {\n+      *nelts = declarator->u.array.bounds;\n+      if (*nelts == error_mark_node)\n+\t*nelts = integer_one_node;\n+      else if (!processing_template_decl)\n+\t{\n+\t  if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, *nelts, \n+\t\t\t\t\t   false))\n+\t    pedwarn (\"size in array new must have integral type\");\n+\t  *nelts = save_expr (cp_convert (sizetype, *nelts));\n+\t  if (*nelts == integer_zero_node)\n+\t    warning (\"zero size array reserves no space\");\n+\t}\n+      if (outer_declarator)\n+\touter_declarator->declarator = declarator->declarator;\n+      else\n+\tnew_declarator = NULL;\n+    }\n+\n+  type = groktypename (type_specifier_seq, new_declarator);\n+  if (TREE_CODE (type) == ARRAY_TYPE && *nelts == NULL_TREE)\n+    {\n+      *nelts = array_type_nelts_top (type);\n+      type = TREE_TYPE (type);\n+    }\n+  return type;\n }\n \n /* Parse an (optional) new-declarator.\n@@ -4670,10 +4927,9 @@ cp_parser_new_type_id (cp_parser* parser)\n      ptr-operator new-declarator [opt]\n      direct-new-declarator\n \n-   Returns a representation of the declarator.  See\n-   cp_parser_declarator for the representations used.  */\n+   Returns the declarator.  */\n \n-static tree\n+static cp_declarator *\n cp_parser_new_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n@@ -4687,31 +4943,31 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n   /* If that worked, look for more new-declarators.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n-      tree declarator;\n+      cp_declarator *declarator;\n \n       /* Parse another optional declarator.  */\n       declarator = cp_parser_new_declarator_opt (parser);\n \n       /* Create the representation of the declarator.  */\n-      if (code == INDIRECT_REF)\n+      if (type)\n+\tdeclarator = make_ptrmem_declarator (cv_qualifier_seq,\n+\t\t\t\t\t     type,\n+\t\t\t\t\t     declarator);\n+      else if (code == INDIRECT_REF)\n \tdeclarator = make_pointer_declarator (cv_qualifier_seq,\n \t\t\t\t\t      declarator);\n       else\n \tdeclarator = make_reference_declarator (cv_qualifier_seq,\n \t\t\t\t\t\tdeclarator);\n \n-     /* Handle the pointer-to-member case.  */\n-     if (type)\n-       declarator = build_nt (SCOPE_REF, type, declarator);\n-\n       return declarator;\n     }\n \n   /* If the next token is a `[', there is a direct-new-declarator.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n     return cp_parser_direct_new_declarator (parser);\n \n-  return NULL_TREE;\n+  return NULL;\n }\n \n /* Parse a direct-new-declarator.\n@@ -4720,13 +4976,12 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n      [ expression ]\n      direct-new-declarator [constant-expression]\n \n-   Returns an ARRAY_REF, following the same conventions as are\n-   documented for cp_parser_direct_declarator.  */\n+   */\n \n-static tree\n+static cp_declarator *\n cp_parser_direct_new_declarator (cp_parser* parser)\n {\n-  tree declarator = NULL_TREE;\n+  cp_declarator *declarator = NULL;\n \n   while (true)\n     {\n@@ -4767,8 +5022,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n \n       /* Add this bound to the declarator.  */\n-      declarator = build_nt (ARRAY_REF, declarator, expression,\n-\t\t\t     NULL_TREE, NULL_TREE);\n+      declarator = make_array_declarator (declarator, expression);\n \n       /* If the next token is not a `[', then there are no more\n \t bounds.  */\n@@ -6023,7 +6277,7 @@ cp_parser_condition (cp_parser* parser)\n       tree decl;\n       tree asm_specification;\n       tree attributes;\n-      tree declarator;\n+      cp_declarator *declarator;\n       tree initializer = NULL_TREE;\n \n       /* Parse the declarator.  */\n@@ -6334,9 +6588,17 @@ cp_parser_jump_statement (cp_parser* parser)\n static void\n cp_parser_declaration_statement (cp_parser* parser)\n {\n-  /* Parse the block-declaration.  */\n+  void *p;\n+\n+  /* Get the high-water mark for the DECLARATOR_OBSTACK.  */\n+  p = obstack_alloc (&declarator_obstack, 0);\n+\n+ /* Parse the block-declaration.  */\n   cp_parser_block_declaration (parser, /*statement_p=*/true);\n \n+  /* Free any declarators allocated.  */\n+  obstack_free (&declarator_obstack, p);\n+\n   /* Finish off the statement.  */\n   finish_stmt ();\n }\n@@ -6467,6 +6729,7 @@ cp_parser_declaration (cp_parser* parser)\n   cp_token token1;\n   cp_token token2;\n   int saved_pedantic;\n+  void *p;\n \n   /* Set this here since we can be called after\n      pushing the linkage specification.  */\n@@ -6495,6 +6758,9 @@ cp_parser_declaration (cp_parser* parser)\n \n   c_lex_string_translate = 1;\n \n+  /* Get the high-water mark for the DECLARATOR_OBSTACK.  */\n+  p = obstack_alloc (&declarator_obstack, 0);\n+\n   /* If the next token is `extern' and the following token is a string\n      literal, then we have a linkage specification.  */\n   if (token1.keyword == RID_EXTERN\n@@ -6544,6 +6810,9 @@ cp_parser_declaration (cp_parser* parser)\n   else\n     /* Try to parse a block-declaration, or a function-definition.  */\n     cp_parser_block_declaration (parser, /*statement_p=*/false);\n+\n+  /* Free any declarators allocated.  */\n+  obstack_free (&declarator_obstack, p);\n }\n \n /* Parse a block-declaration.\n@@ -7229,7 +7498,7 @@ cp_parser_conversion_type_id (cp_parser* parser)\n {\n   tree attributes;\n   tree type_specifiers;\n-  tree declarator;\n+  cp_declarator *declarator;\n \n   /* Parse the attributes.  */\n   attributes = cp_parser_attributes_opt (parser);\n@@ -7250,10 +7519,9 @@ cp_parser_conversion_type_id (cp_parser* parser)\n    conversion-declarator:\n      ptr-operator conversion-declarator [opt]\n \n-   Returns a representation of the declarator.  See\n-   cp_parser_declarator for details.  */\n+   */\n \n-static tree\n+static cp_declarator *\n cp_parser_conversion_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n@@ -7268,27 +7536,27 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n   /* If it worked, look for more conversion-declarators.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n-     tree declarator;\n-\n-     /* Parse another optional declarator.  */\n-     declarator = cp_parser_conversion_declarator_opt (parser);\n-\n-     /* Create the representation of the declarator.  */\n-     if (code == INDIRECT_REF)\n-       declarator = make_pointer_declarator (cv_qualifier_seq,\n+      cp_declarator *declarator;\n+      \n+      /* Parse another optional declarator.  */\n+      declarator = cp_parser_conversion_declarator_opt (parser);\n+      \n+      /* Create the representation of the declarator.  */\n+      if (class_type)\n+\tdeclarator = make_ptrmem_declarator (cv_qualifier_seq,\n+\t\t\t\t\t     class_type,\n \t\t\t\t\t     declarator);\n-     else\n-       declarator =  make_reference_declarator (cv_qualifier_seq,\n+      else if (code == INDIRECT_REF)\n+\tdeclarator = make_pointer_declarator (cv_qualifier_seq,\n+\t\t\t\t\t      declarator);\n+      else\n+\tdeclarator = make_reference_declarator (cv_qualifier_seq,\n \t\t\t\t\t\tdeclarator);\n-\n-     /* Handle the pointer-to-member case.  */\n-     if (class_type)\n-       declarator = build_nt (SCOPE_REF, class_type, declarator);\n-\n-     return declarator;\n+      \n+      return declarator;\n    }\n \n-  return NULL_TREE;\n+  return NULL;\n }\n \n /* Parse an (optional) ctor-initializer.\n@@ -7812,13 +8080,14 @@ cp_parser_template_parameter_list (cp_parser* parser)\n     {\n       tree parameter;\n       cp_token *token;\n+      bool is_non_type;\n \n       /* Parse the template-parameter.  */\n-      parameter = cp_parser_template_parameter (parser);\n+      parameter = cp_parser_template_parameter (parser, &is_non_type);\n       /* Add it to the list.  */\n       parameter_list = process_template_parm (parameter_list,\n-\t\t\t\t\t      parameter);\n-\n+\t\t\t\t\t      parameter,\n+\t\t\t\t\t      is_non_type);\n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       /* If it's not a `,', we're done.  */\n@@ -7838,13 +8107,17 @@ cp_parser_template_parameter_list (cp_parser* parser)\n      parameter-declaration\n \n    Returns a TREE_LIST.  The TREE_VALUE represents the parameter.  The\n-   TREE_PURPOSE is the default value, if any.  */\n+   TREE_PURPOSE is the default value, if any.  *IS_NON_TYPE is set to\n+   true iff this parameter is a non-type parameter.  */\n \n static tree\n-cp_parser_template_parameter (cp_parser* parser)\n+cp_parser_template_parameter (cp_parser* parser, bool *is_non_type)\n {\n   cp_token *token;\n+  const cp_parameter_declarator *parameter_declarator;\n \n+  /* Assume it is a type parameter or a template parameter.  */\n+  *is_non_type = false;\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* If it is `class' or `template', we have a type-parameter.  */\n@@ -7886,9 +8159,16 @@ cp_parser_template_parameter (cp_parser* parser)\n      template-parameter, the first non-nested `>' is taken as the end\n      of the template parameter-list rather than a greater-than\n      operator.  */\n-  return\n-    cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,\n-\t\t\t\t     /*parenthesized_p=*/NULL);\n+  *is_non_type = true;\n+  parameter_declarator\n+     = cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,\n+\t\t\t\t\t/*parenthesized_p=*/NULL);\n+  return (build_tree_list \n+\t  (parameter_declarator->default_argument,\n+\t   grokdeclarator (parameter_declarator->declarator,\n+\t\t\t   parameter_declarator->decl_specifiers,\n+\t\t\t   PARM, /*initialized=*/0, \n+\t\t\t   /*attrlist=*/NULL)));\n }\n \n /* Parse a type-parameter.\n@@ -8769,7 +9049,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n     }\n   else\n     {\n-      tree declarator;\n+      cp_declarator *declarator;\n       tree decl;\n \n       /* Parse the declarator.  */\n@@ -8779,7 +9059,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\t/*parenthesized_p=*/NULL);\n       cp_parser_check_for_definition_in_return_type (declarator,\n \t\t\t\t\t\t     declares_class_or_enum);\n-      if (declarator != error_mark_node)\n+      if (declarator != cp_error_declarator)\n \t{\n \t  decl = grokdeclarator (declarator, decl_specifiers,\n \t\t\t\t NORMAL, 0, NULL);\n@@ -10098,7 +10378,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   bool* function_definition_p)\n {\n   cp_token *token;\n-  tree declarator;\n+  cp_declarator *declarator;\n   tree attributes;\n   tree asm_specification;\n   tree initializer;\n@@ -10131,7 +10411,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* If the DECLARATOR was erroneous, there's no need to go\n      further.  */\n-  if (declarator == error_mark_node)\n+  if (declarator == cp_error_declarator)\n     return error_mark_node;\n \n   cp_parser_check_for_definition_in_return_type (declarator,\n@@ -10373,26 +10653,6 @@ cp_parser_init_declarator (cp_parser* parser,\n      attributes [opt] ptr-operator abstract-declarator [opt]\n      attributes [opt] direct-abstract-declarator\n \n-   Returns a representation of the declarator.  If the declarator has\n-   the form `* declarator', then an INDIRECT_REF is returned, whose\n-   only operand is the sub-declarator.  Analogously, `& declarator' is\n-   represented as an ADDR_EXPR.  For `X::* declarator', a SCOPE_REF is\n-   used.  The first operand is the TYPE for `X'.  The second operand\n-   is an INDIRECT_REF whose operand is the sub-declarator.\n-\n-   Otherwise, the representation is as for a direct-declarator.\n-\n-   (It would be better to define a structure type to represent\n-   declarators, rather than abusing `tree' nodes to represent\n-   declarators.  That would be much clearer and save some memory.\n-   There is no reason for declarators to be garbage-collected, for\n-   example; they are created during parser and no longer needed after\n-   `grokdeclarator' has been called.)\n-\n-   For a ptr-operator that has the optional cv-qualifier-seq,\n-   cv-qualifiers will be stored in the TREE_TYPE of the INDIRECT_REF\n-   node.\n-\n    If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to\n    detect constructor, destructor or conversion operators. It is set\n    to -1 if the declarator is a name, and +1 if it is a\n@@ -10410,14 +10670,14 @@ cp_parser_init_declarator (cp_parser* parser,\n    If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff\n    the declarator is a direct-declarator of the form \"(...)\".  */\n \n-static tree\n+static cp_declarator *\n cp_parser_declarator (cp_parser* parser,\n                       cp_parser_declarator_kind dcl_kind,\n                       int* ctor_dtor_or_conv_p,\n \t\t      bool* parenthesized_p)\n {\n   cp_token *token;\n-  tree declarator;\n+  cp_declarator *declarator;\n   enum tree_code code;\n   tree cv_qualifier_seq;\n   tree class_type;\n@@ -10461,18 +10721,19 @@ cp_parser_declarator (cp_parser* parser,\n \t case where the dependent declarator is absent.  */\n       if (dcl_kind != CP_PARSER_DECLARATOR_NAMED\n \t  && !cp_parser_parse_definitely (parser))\n-\tdeclarator = NULL_TREE;\n+\tdeclarator = NULL;\n \n       /* Build the representation of the ptr-operator.  */\n-      if (code == INDIRECT_REF)\n+      if (class_type)\n+\tdeclarator = make_ptrmem_declarator (cv_qualifier_seq,\n+\t\t\t\t\t     class_type,\n+\t\t\t\t\t     declarator);\n+      else if (code == INDIRECT_REF)\n \tdeclarator = make_pointer_declarator (cv_qualifier_seq,\n \t\t\t\t\t      declarator);\n       else\n \tdeclarator = make_reference_declarator (cv_qualifier_seq,\n \t\t\t\t\t\tdeclarator);\n-      /* Handle the pointer-to-member case.  */\n-      if (class_type)\n-\tdeclarator = build_nt (SCOPE_REF, class_type, declarator);\n     }\n   /* Everything else is a direct-declarator.  */\n   else\n@@ -10484,8 +10745,8 @@ cp_parser_declarator (cp_parser* parser,\n \t\t\t\t\t\tctor_dtor_or_conv_p);\n     }\n \n-  if (attributes && declarator != error_mark_node)\n-    declarator = tree_cons (attributes, declarator, NULL_TREE);\n+  if (attributes && declarator != cp_error_declarator)\n+    declarator->attributes = attributes;\n \n   return declarator;\n }\n@@ -10515,24 +10776,15 @@ cp_parser_declarator (cp_parser* parser,\n    CP_PARSER_DECLARATOR_EITHER, if we can accept either - in the case\n    of ambiguity we prefer an abstract declarator, as per\n    [dcl.ambig.res].  CTOR_DTOR_OR_CONV_P is as for\n-   cp_parser_declarator.\n+   cp_parser_declarator.  */\n \n-   For the declarator-id production, the representation is as for an\n-   id-expression, except that a qualified name is represented as a\n-   SCOPE_REF.  A function-declarator is represented as a CALL_EXPR;\n-   see the documentation of the FUNCTION_DECLARATOR_* macros for\n-   information about how to find the various declarator components.\n-   An array-declarator is represented as an ARRAY_REF.  The\n-   direct-declarator is the first operand; the constant-expression\n-   indicating the size of the array is the second operand.  */\n-\n-static tree\n+static cp_declarator *\n cp_parser_direct_declarator (cp_parser* parser,\n                              cp_parser_declarator_kind dcl_kind,\n                              int* ctor_dtor_or_conv_p)\n {\n   cp_token *token;\n-  tree declarator = NULL_TREE;\n+  cp_declarator *declarator = NULL;\n   tree scope = NULL_TREE;\n   bool saved_default_arg_ok_p = parser->default_arg_ok_p;\n   bool saved_in_declarator_p = parser->in_declarator_p;\n@@ -10585,7 +10837,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t  if (!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n \t    {\n-\t      tree params;\n+\t      cp_parameter_declarator *params;\n \t      unsigned saved_num_template_parameter_lists;\n \n \t      cp_parser_parse_tentatively (parser);\n@@ -10667,8 +10919,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      first = false;\n \t      /* Expect a `)'.  */\n \t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n-\t\tdeclarator = error_mark_node;\n-\t      if (declarator == error_mark_node)\n+\t\tdeclarator = cp_error_declarator;\n+\t      if (declarator == cp_error_declarator)\n \t\tbreak;\n \n \t      goto handle_declarator;\n@@ -10711,37 +10963,40 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  /* Look for the closing `]'.  */\n \t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\"))\n \t    {\n-\t      declarator = error_mark_node;\n+\t      declarator = cp_error_declarator;\n \t      break;\n \t    }\n \n-\t  declarator = build_nt (ARRAY_REF, declarator, bounds,\n-\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  declarator = make_array_declarator (declarator, bounds);\n \t}\n       else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{\n+\t  tree id;\n+\n \t  /* Parse a declarator-id */\n \t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n \t    cp_parser_parse_tentatively (parser);\n-\t  declarator = cp_parser_declarator_id (parser);\n+\t  id = cp_parser_declarator_id (parser);\n \t  if (dcl_kind == CP_PARSER_DECLARATOR_EITHER)\n \t    {\n \t      if (!cp_parser_parse_definitely (parser))\n-\t\tdeclarator = error_mark_node;\n-\t      else if (TREE_CODE (declarator) != IDENTIFIER_NODE)\n+\t\tid = error_mark_node;\n+\t      else if (TREE_CODE (id) != IDENTIFIER_NODE)\n \t\t{\n \t\t  cp_parser_error (parser, \"expected unqualified-id\");\n-\t\t  declarator = error_mark_node;\n+\t\t  id = error_mark_node;\n \t\t}\n \t    }\n \n-\t  if (declarator == error_mark_node)\n-\t    break;\n+\t  if (id == error_mark_node)\n+\t    {\n+\t      declarator = cp_error_declarator;\n+\t      break;\n+\t    }\n \n-\t  if (TREE_CODE (declarator) == SCOPE_REF\n-\t      && !current_scope ())\n+\t  if (TREE_CODE (id) == SCOPE_REF && !current_scope ())\n \t    {\n-\t      tree scope = TREE_OPERAND (declarator, 0);\n+\t      tree scope = TREE_OPERAND (id, 0);\n \n \t      /* In the declaration of a member of a template class\n \t     \t outside of the class itself, the SCOPE will sometimes\n@@ -10772,53 +11027,54 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t   TYPE_CONTEXT (scope),\n \t\t\t   TYPE_IDENTIFIER (scope));\n \t\t  /* Build a new DECLARATOR.  */\n-\t\t  declarator = build_nt (SCOPE_REF,\n-\t\t\t\t\t type,\n-\t\t\t\t\t TREE_OPERAND (declarator, 1));\n+\t\t  id = build_nt (SCOPE_REF, type, TREE_OPERAND (id, 1));\n \t\t}\n \t    }\n \n-\t  /* Check to see whether the declarator-id names a constructor,\n-\t     destructor, or conversion.  */\n-\t  if (declarator && ctor_dtor_or_conv_p\n-\t      && ((TREE_CODE (declarator) == SCOPE_REF\n-\t\t   && CLASS_TYPE_P (TREE_OPERAND (declarator, 0)))\n-\t\t  || (TREE_CODE (declarator) != SCOPE_REF\n-\t\t      && at_class_scope_p ())))\n+\t  declarator = make_id_declarator (id);\n+\t  if (id)\n \t    {\n-\t      tree unqualified_name;\n \t      tree class_type;\n+\t      tree unqualified_name;\n \n-\t      /* Get the unqualified part of the name.  */\n-\t      if (TREE_CODE (declarator) == SCOPE_REF)\n+\t      if (TREE_CODE (id) == SCOPE_REF\n+\t\t  && CLASS_TYPE_P (TREE_OPERAND (id, 0)))\n \t\t{\n-\t\t  class_type = TREE_OPERAND (declarator, 0);\n-\t\t  unqualified_name = TREE_OPERAND (declarator, 1);\n+\t\t  class_type = TREE_OPERAND (id, 0);\n+\t\t  unqualified_name = TREE_OPERAND (id, 1);\n \t\t}\n \t      else\n \t\t{\n \t\t  class_type = current_class_type;\n-\t\t  unqualified_name = declarator;\n+\t\t  unqualified_name = id;\n \t\t}\n \n-\t      /* See if it names ctor, dtor or conv.  */\n-\t      if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n-\t\t  || IDENTIFIER_TYPENAME_P (unqualified_name)\n-\t\t  || constructor_name_p (unqualified_name, class_type)\n-\t\t  || (TREE_CODE (unqualified_name) == TYPE_DECL\n-\t\t      && same_type_p (TREE_TYPE (unqualified_name),\n-\t\t\t\t      class_type)))\n-\t\t*ctor_dtor_or_conv_p = -1;\n-\t\tif (TREE_CODE (declarator) == SCOPE_REF\n-\t\t    && TREE_CODE (unqualified_name) == TYPE_DECL \n-\t\t    && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n-\t\t  {\n-\t\t    error (\"invalid use of constructor as a template\");\n-\t\t    inform (\"use `%T::%D' instead of `%T::%T' to name the \"\n-\t\t\t    \"constructor in a qualified name\", class_type, \n-\t\t\t    DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n-\t\t\t    class_type, class_type);\n-\t\t  }\n+\t      if (class_type)\n+\t\t{\n+\t\t  if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)\n+\t\t    declarator->u.id.sfk = sfk_destructor;\n+\t\t  else if (IDENTIFIER_TYPENAME_P (unqualified_name))\n+\t\t    declarator->u.id.sfk = sfk_conversion;\n+\t\t  else if (constructor_name_p (unqualified_name,\n+\t\t\t\t\t       class_type)\n+\t\t\t   || (TREE_CODE (unqualified_name) == TYPE_DECL\n+\t\t\t       && same_type_p (TREE_TYPE (unqualified_name),\n+\t\t\t\t\t       class_type)))\n+\t\t    declarator->u.id.sfk = sfk_constructor;\n+\n+\t\t  if (ctor_dtor_or_conv_p && declarator->u.id.sfk != sfk_none)\n+\t\t    *ctor_dtor_or_conv_p = -1;\n+\t\t  if (TREE_CODE (id) == SCOPE_REF\n+\t\t      && TREE_CODE (unqualified_name) == TYPE_DECL \n+\t\t      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n+\t\t    {\n+\t\t      error (\"invalid use of constructor as a template\");\n+\t\t      inform (\"use `%T::%D' instead of `%T::%T' to name the \"\n+\t\t\t      \"constructor in a qualified name\", class_type, \n+\t\t\t      DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n+\t\t\t      class_type, class_type);\n+\t\t    }\n+\t\t}\n \t    }\n \n \thandle_declarator:;\n@@ -10829,9 +11085,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t    pop_p = push_scope (scope);\n \t  parser->in_declarator_p = true;\n \t  if ((ctor_dtor_or_conv_p && *ctor_dtor_or_conv_p)\n-\t      || (declarator\n-\t\t  && (TREE_CODE (declarator) == SCOPE_REF\n-\t\t      || TREE_CODE (declarator) == IDENTIFIER_NODE)))\n+\t      || (declarator && declarator->kind == cdk_id))\n \t    /* Default args are only allowed on function\n \t       declarations.  */\n \t    parser->default_arg_ok_p = saved_default_arg_ok_p;\n@@ -11078,7 +11332,7 @@ static tree\n cp_parser_type_id (cp_parser* parser)\n {\n   tree type_specifier_seq;\n-  tree abstract_declarator;\n+  cp_declarator *abstract_declarator;\n \n   /* Parse the type-specifier-seq.  */\n   type_specifier_seq\n@@ -11094,10 +11348,9 @@ cp_parser_type_id (cp_parser* parser)\n \t\t\t    /*parenthesized_p=*/NULL);\n   /* Check to see if there really was a declarator.  */\n   if (!cp_parser_parse_definitely (parser))\n-    abstract_declarator = NULL_TREE;\n+    abstract_declarator = NULL;\n \n-  return groktypename (build_tree_list (type_specifier_seq,\n-\t\t\t\t\tabstract_declarator));\n+  return groktypename (type_specifier_seq, abstract_declarator);\n }\n \n /* Parse a type-specifier-seq.\n@@ -11168,19 +11421,17 @@ cp_parser_type_specifier_seq (cp_parser* parser)\n      parameter-declaration-list [opt] ... [opt]\n      parameter-declaration-list , ...\n \n-   Returns a representation for the parameter declarations.  Each node\n-   is a TREE_LIST.  (See cp_parser_parameter_declaration for the exact\n-   representation.)  If the parameter-declaration-clause ends with an\n-   ellipsis, PARMLIST_ELLIPSIS_P will hold of the first node in the\n-   list.  A return value of NULL_TREE indicates a\n-   parameter-declaration-clause consisting only of an ellipsis.  */\n+   Returns a representation for the parameter declarations.  A return\n+   value of NULL indicates a parameter-declaration-clause consisting\n+   only of an ellipsis.  */\n \n-static tree\n+static cp_parameter_declarator *\n cp_parser_parameter_declaration_clause (cp_parser* parser)\n {\n-  tree parameters;\n+  cp_parameter_declarator *parameters;\n   cp_token *token;\n   bool ellipsis_p;\n+  bool is_error;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -11189,18 +11440,18 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n     {\n       /* Consume the `...' token.  */\n       cp_lexer_consume_token (parser->lexer);\n-      return NULL_TREE;\n+      return NULL;\n     }\n   else if (token->type == CPP_CLOSE_PAREN)\n     /* There are no parameters.  */\n     {\n #ifndef NO_IMPLICIT_EXTERN_C\n       if (in_system_header && current_class_type == NULL\n \t  && current_lang_name == lang_name_c)\n-\treturn NULL_TREE;\n+\treturn NULL;\n       else\n #endif\n-\treturn void_list_node;\n+\treturn no_parameters;\n     }\n   /* Check for `(void)', too, which is a special case.  */\n   else if (token->keyword == RID_VOID\n@@ -11210,16 +11461,16 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n       /* Consume the `void' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* There are no parameters.  */\n-      return void_list_node;\n+      return no_parameters;\n     }\n \n   /* Parse the parameter-declaration-list.  */\n-  parameters = cp_parser_parameter_declaration_list (parser);\n+  parameters = cp_parser_parameter_declaration_list (parser, &is_error);\n   /* If a parse error occurred while parsing the\n      parameter-declaration-list, then the entire\n      parameter-declaration-clause is erroneous.  */\n-  if (parameters == error_mark_node)\n-    return error_mark_node;\n+  if (is_error)\n+    return NULL;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -11245,7 +11496,10 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n     ellipsis_p = false;\n \n   /* Finish the parameter list.  */\n-  return finish_parmlist (parameters, ellipsis_p);\n+  if (parameters && ellipsis_p)\n+    parameters->ellipsis_p = true;\n+  \n+  return parameters;\n }\n \n /* Parse a parameter-declaration-list.\n@@ -11256,17 +11510,22 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n \n    Returns a representation of the parameter-declaration-list, as for\n    cp_parser_parameter_declaration_clause.  However, the\n-   `void_list_node' is never appended to the list.  */\n+   `void_list_node' is never appended to the list.  Upon return,\n+   *IS_ERROR will be true iff an error occurred.  */\n \n-static tree\n-cp_parser_parameter_declaration_list (cp_parser* parser)\n+static cp_parameter_declarator *\n+cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n {\n-  tree parameters = NULL_TREE;\n+  cp_parameter_declarator *parameters = NULL;\n+  cp_parameter_declarator **tail = &parameters;\n+\n+  /* Assume all will go well.  */\n+  *is_error = false;\n \n   /* Look for more parameters.  */\n   while (true)\n     {\n-      tree parameter;\n+      cp_parameter_declarator *parameter;\n       bool parenthesized_p;\n       /* Parse the parameter.  */\n       parameter\n@@ -11276,14 +11535,15 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n \n       /* If a parse error occurred parsing the parameter declaration,\n \t then the entire parameter-declaration-list is erroneous.  */\n-      if (parameter == error_mark_node)\n+      if (!parameter)\n \t{\n-\t  parameters = error_mark_node;\n+\t  *is_error = true;\n+\t  parameters = NULL;\n \t  break;\n \t}\n       /* Add the new parameter to the list.  */\n-      TREE_CHAIN (parameter) = parameters;\n-      parameters = parameter;\n+      *tail = parameter;\n+      tail = &parameter->next;\n \n       /* Peek at the next token.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN)\n@@ -11338,8 +11598,7 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n \t}\n     }\n \n-  /* We built up the list in reverse order; straighten it out now.  */\n-  return nreverse (parameters);\n+  return parameters;\n }\n \n /* Parse a parameter declaration.\n@@ -11355,16 +11614,11 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n    token encountered during the parsing of the assignment-expression\n    is not interpreted as a greater-than operator.)\n \n-   Returns a TREE_LIST representing the parameter-declaration.  The\n-   TREE_PURPOSE is the default argument expression, or NULL_TREE if\n-   there is no default argument.  The TREE_VALUE is a representation\n-   of the decl-specifier-seq and declarator.  In particular, the\n-   TREE_VALUE will be a TREE_LIST whose TREE_PURPOSE represents the\n-   decl-specifier-seq and whose TREE_VALUE represents the declarator.\n-   If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff\n-   the declarator is of the form \"(p)\".  */\n+   Returns a representation of the parameter, or NULL if an error\n+   occurs.  If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to\n+   true iff the declarator is of the form \"(p)\".  */\n \n-static tree\n+static cp_parameter_declarator *\n cp_parser_parameter_declaration (cp_parser *parser,\n \t\t\t\t bool template_parm_p,\n \t\t\t\t bool *parenthesized_p)\n@@ -11373,9 +11627,8 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   bool greater_than_is_operator_p;\n   tree decl_specifiers;\n   tree attributes;\n-  tree declarator;\n+  cp_declarator *declarator;\n   tree default_argument;\n-  tree parameter;\n   cp_token *token;\n   const char *saved_message;\n \n@@ -11405,7 +11658,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   if (cp_parser_error_occurred (parser))\n     {\n       parser->type_definition_forbidden_message = saved_message;\n-      return error_mark_node;\n+      return NULL;\n     }\n \n   /* Peek at the next token.  */\n@@ -11418,7 +11671,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       || token->type == CPP_ELLIPSIS\n       || token->type == CPP_GREATER)\n     {\n-      declarator = NULL_TREE;\n+      declarator = NULL;\n       if (parenthesized_p)\n \t*parenthesized_p = false;\n     }\n@@ -11596,11 +11849,10 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   /* Create the representation of the parameter.  */\n   if (attributes)\n     decl_specifiers = tree_cons (attributes, NULL_TREE, decl_specifiers);\n-  parameter = build_tree_list (default_argument,\n-\t\t\t       build_tree_list (decl_specifiers,\n-\t\t\t\t\t\tdeclarator));\n \n-  return parameter;\n+  return make_parameter_declarator (decl_specifiers,\n+\t\t\t\t    declarator,\n+\t\t\t\t    default_argument);\n }\n \n /* Parse a function-body.\n@@ -12744,15 +12996,17 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      attributes = chainon (prefix_attributes, attributes);\n \n \t      /* Create the bitfield declaration.  */\n-\t      decl = grokbitfield (identifier,\n+\t      decl = grokbitfield (identifier \n+\t\t\t\t   ? make_id_declarator (identifier)\n+\t\t\t\t   : NULL,\n \t\t\t\t   decl_specifiers,\n \t\t\t\t   width);\n \t      /* Apply the attributes.  */\n \t      cplus_decl_attributes (&decl, attributes, /*flags=*/0);\n \t    }\n \t  else\n \t    {\n-\t      tree declarator;\n+\t      cp_declarator *declarator;\n \t      tree initializer;\n \t      tree asm_specification;\n \t      int ctor_dtor_or_conv_p;\n@@ -12765,7 +13019,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t      /* If something went wrong parsing the declarator, make sure\n \t\t that we at least consume some tokens.  */\n-\t      if (declarator == error_mark_node)\n+\t      if (declarator == cp_error_declarator)\n \t\t{\n \t\t  /* Skip to the end of the statement.  */\n \t\t  cp_parser_skip_to_end_of_statement (parser);\n@@ -12815,7 +13069,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t     for a pure-specifier; otherwise, we look for a\n \t\t     constant-initializer.  When we call `grokfield', it will\n \t\t     perform more stringent semantics checks.  */\n-\t\t  if (TREE_CODE (declarator) == CALL_EXPR)\n+\t\t  if (declarator->kind == cdk_function)\n \t\t    initializer = cp_parser_pure_specifier (parser);\n \t\t  else\n \t\t    /* Parse the initializer.  */\n@@ -13352,8 +13606,9 @@ cp_parser_handler (cp_parser* parser)\n static tree\n cp_parser_exception_declaration (cp_parser* parser)\n {\n+  tree decl;\n   tree type_specifiers;\n-  tree declarator;\n+  cp_declarator *declarator;\n   const char *saved_message;\n \n   /* If it's an ellipsis, it's easy to handle.  */\n@@ -13373,7 +13628,7 @@ cp_parser_exception_declaration (cp_parser* parser)\n   type_specifiers = cp_parser_type_specifier_seq (parser);\n   /* If it's a `)', then there is no declarator.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n-    declarator = NULL_TREE;\n+    declarator = NULL;\n   else\n     declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_EITHER,\n \t\t\t\t       /*ctor_dtor_or_conv_p=*/NULL,\n@@ -13382,7 +13637,16 @@ cp_parser_exception_declaration (cp_parser* parser)\n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;\n \n-  return start_handler_parms (type_specifiers, declarator);\n+  if (type_specifiers)\n+    {\n+      decl = grokdeclarator (declarator, type_specifiers, CATCHPARM, 1, NULL);\n+      if (decl == NULL_TREE)\n+\terror (\"invalid catch parameter\");\n+    }\n+  else\n+    decl = NULL_TREE;\n+\n+  return decl;\n }\n \n /* Parse a throw-expression.\n@@ -14028,73 +14292,68 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n \n static bool\n cp_parser_check_declarator_template_parameters (cp_parser* parser,\n-                                                tree declarator)\n+\t\t\t\t\t\tcp_declarator *declarator)\n {\n   unsigned num_templates;\n \n   /* We haven't seen any classes that involve template parameters yet.  */\n   num_templates = 0;\n \n-  switch (TREE_CODE (declarator))\n+  switch (declarator->kind)\n     {\n-    case CALL_EXPR:\n-    case ARRAY_REF:\n-    case INDIRECT_REF:\n-    case ADDR_EXPR:\n-      {\n-\ttree main_declarator = TREE_OPERAND (declarator, 0);\n-\treturn\n-\t  cp_parser_check_declarator_template_parameters (parser,\n-\t\t\t\t\t\t\t  main_declarator);\n-      }\n-\n-    case SCOPE_REF:\n-      {\n-\ttree scope;\n-\ttree member;\n-\n-\tscope = TREE_OPERAND (declarator, 0);\n-\tmember = TREE_OPERAND (declarator, 1);\n-\n-\t/* If this is a pointer-to-member, then we are not interested\n-\t   in the SCOPE, because it does not qualify the thing that is\n-\t   being declared.  */\n-\tif (TREE_CODE (member) == INDIRECT_REF)\n-\t  return (cp_parser_check_declarator_template_parameters\n-\t\t  (parser, member));\n-\n-\twhile (scope && CLASS_TYPE_P (scope))\n-\t  {\n-\t    /* You're supposed to have one `template <...>'\n-\t       for every template class, but you don't need one\n-\t       for a full specialization.  For example:\n-\n-\t       template <class T> struct S{};\n-\t       template <> struct S<int> { void f(); };\n-\t       void S<int>::f () {}\n-\n-\t       is correct; there shouldn't be a `template <>' for\n-\t       the definition of `S<int>::f'.  */\n-\t    if (CLASSTYPE_TEMPLATE_INFO (scope)\n-\t\t&& (CLASSTYPE_TEMPLATE_INSTANTIATION (scope)\n-\t\t    || uses_template_parms (CLASSTYPE_TI_ARGS (scope)))\n-\t\t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (scope)))\n-\t      ++num_templates;\n+    case cdk_id:\n+      if (TREE_CODE (declarator->u.id.name) == SCOPE_REF)\n+\t{\n+\t  tree scope;\n+\t  tree member;\n \n-\t    scope = TYPE_CONTEXT (scope);\n-\t  }\n-      }\n+\t  scope = TREE_OPERAND (declarator->u.id.name, 0);\n+\t  member = TREE_OPERAND (declarator->u.id.name, 1);\n \n-      /* Fall through.  */\n+\t  while (scope && CLASS_TYPE_P (scope))\n+\t    {\n+\t      /* You're supposed to have one `template <...>'\n+\t\t for every template class, but you don't need one\n+\t\t for a full specialization.  For example:\n+\n+\t\t template <class T> struct S{};\n+\t\t template <> struct S<int> { void f(); };\n+\t\t void S<int>::f () {}\n+\n+\t\t is correct; there shouldn't be a `template <>' for\n+\t\t the definition of `S<int>::f'.  */\n+\t      if (CLASSTYPE_TEMPLATE_INFO (scope)\n+\t\t  && (CLASSTYPE_TEMPLATE_INSTANTIATION (scope)\n+\t\t      || uses_template_parms (CLASSTYPE_TI_ARGS (scope)))\n+\t\t  && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (scope)))\n+\t\t++num_templates;\n+\n+\t      scope = TYPE_CONTEXT (scope);\n+\t    }\n+\t}\n \n-    default:\n       /* If the DECLARATOR has the form `X<y>' then it uses one\n \t additional level of template parameters.  */\n-      if (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+      if (TREE_CODE (declarator->u.id.name) == TEMPLATE_ID_EXPR)\n \t++num_templates;\n \n       return cp_parser_check_template_parameters (parser,\n \t\t\t\t\t\t  num_templates);\n+\n+    case cdk_function:\n+    case cdk_array:\n+    case cdk_pointer:\n+    case cdk_reference:\n+    case cdk_ptrmem:\n+      return (cp_parser_check_declarator_template_parameters \n+\t      (parser, declarator->declarator));\n+\n+    case cdk_error:\n+      return true;\n+\n+    default:\n+      abort ();\n+      return false;\n     }\n }\n \n@@ -14403,15 +14662,17 @@ cp_parser_function_definition_from_specifiers_and_declarator\n   (cp_parser* parser,\n    tree decl_specifiers,\n    tree attributes,\n-   tree declarator)\n+   const cp_declarator *declarator)\n {\n   tree fn;\n   bool success_p;\n \n   /* Begin the function-definition.  */\n-  success_p = begin_function_definition (decl_specifiers,\n-\t\t\t\t\t attributes,\n-\t\t\t\t\t declarator);\n+  success_p = start_function (decl_specifiers, declarator, attributes);\n+\n+  /* The things we're about to see are not directly qualified by any\n+     template headers we've seen thus far.  */\n+  reset_specialization ();\n \n   /* If there were names looked up in the decl-specifier-seq that we\n      did not check, check them now.  We must wait until we are in the\n@@ -14421,8 +14682,7 @@ cp_parser_function_definition_from_specifiers_and_declarator\n \n   if (!success_p)\n     {\n-      /* If begin_function_definition didn't like the definition, skip\n-\t the entire function.  */\n+      /* Skip the entire function.  */\n       error (\"invalid function declaration\");\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n       fn = error_mark_node;\n@@ -14707,7 +14967,7 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n static tree\n cp_parser_save_member_function_body (cp_parser* parser,\n \t\t\t\t     tree decl_specifiers,\n-\t\t\t\t     tree declarator,\n+\t\t\t\t     cp_declarator *declarator,\n \t\t\t\t     tree attributes)\n {\n   cp_token_cache *cache;\n@@ -14881,8 +15141,8 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n \n       /* Let the front end know that we going to be defining this\n \t function.  */\n-      start_function (NULL_TREE, member_function, NULL_TREE,\n-\t\t      SF_PRE_PARSED | SF_INCLASS_INLINE);\n+      start_preparsed_function (member_function, NULL_TREE,\n+\t\t\t\tSF_PRE_PARSED | SF_INCLASS_INLINE);\n \n       /* Now, parse the body of the function.  */\n       cp_parser_function_definition_after_declarator (parser,\n@@ -15050,7 +15310,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n \t\t\t\t  type);\n \n \t  /* Call grokdeclarator to figure out what type this is.  */\n-\t  expr = grokdeclarator (NULL_TREE,\n+\t  expr = grokdeclarator (NULL,\n \t\t\t\t type,\n \t\t\t\t TYPENAME,\n \t\t\t\t /*initialized=*/0,"}, {"sha": "e451a29fc20b57dda66c8fa7946b8dd952cb9e1c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 53, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -2161,21 +2161,20 @@ reduce_template_parm_level (tree index, tree type, int levels)\n }\n \n /* Process information from new template parameter NEXT and append it to the\n-   LIST being built.  */\n+   LIST being built.  This new parameter is a non-type parameter iff\n+   IS_NON_TYPE is true.  */\n \n tree\n-process_template_parm (tree list, tree next)\n+process_template_parm (tree list, tree next, bool is_non_type)\n {\n   tree parm;\n   tree decl = 0;\n   tree defval;\n-  int is_type, idx;\n+  int idx;\n \n   parm = next;\n   my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 259);\n   defval = TREE_PURPOSE (parm);\n-  parm = TREE_VALUE (parm);\n-  is_type = TREE_PURPOSE (parm) == class_type_node;\n \n   if (list)\n     {\n@@ -2190,12 +2189,10 @@ process_template_parm (tree list, tree next)\n   else\n     idx = 0;\n \n-  if (!is_type)\n+  if (is_non_type)\n     {\n-      my_friendly_assert (TREE_CODE (TREE_PURPOSE (parm)) == TREE_LIST, 260);\n-      /* is a const-param */\n-      parm = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm),\n-\t\t\t     PARM, 0, NULL);\n+      parm = TREE_VALUE (parm);\n+\n       SET_DECL_TEMPLATE_PARM_P (parm);\n \n       /* [temp.param]\n@@ -2222,7 +2219,7 @@ process_template_parm (tree list, tree next)\n   else\n     {\n       tree t;\n-      parm = TREE_VALUE (parm);\n+      parm = TREE_VALUE (TREE_VALUE (parm));\n       \n       if (parm && TREE_CODE (parm) == TEMPLATE_DECL)\n \t{\n@@ -3757,7 +3754,7 @@ convert_template_argument (tree parm,\n \t    }\n \t}\n       else\n-\tval = groktypename (arg);\n+\tval = arg;\n     }\n   else\n     {\n@@ -6600,9 +6597,6 @@ tsubst_call_declarator_parms (tree parms,\n      doesn't check TREE_PARMLIST.  */\n   new_parms = tree_cons (defarg, type, new_parms);\n \n-  /* And note that these are parameters.  */\n-  TREE_PARMLIST (new_parms) = 1;\n-  \n   return new_parms;\n }\n \n@@ -6852,7 +6846,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case TREE_LIST:\n       {\n-\ttree purpose, value, chain, result;\n+\ttree purpose, value, chain;\n \n \tif (t == void_list_node)\n \t  return t;\n@@ -6882,14 +6876,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n \t  return t;\n-\tif (TREE_PARMLIST (t))\n-\t  {\n-\t    result = tree_cons (purpose, value, chain);\n-\t    TREE_PARMLIST (result) = 1;\n-\t  }\n-\telse\n-\t  result = hash_tree_cons (purpose, value, chain);\n-\treturn result;\n+\treturn hash_tree_cons (purpose, value, chain);\n       }\n     case TREE_VEC:\n       if (type != NULL_TREE)\n@@ -7179,20 +7166,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       }\n \n     case INDIRECT_REF:\n-      {\n-\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\tif (e == error_mark_node)\n-\t  return error_mark_node;\n-\treturn make_pointer_declarator (type, e);\n-      }\n-\n     case ADDR_EXPR:\n-      {\n-\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\tif (e == error_mark_node)\n-\t  return error_mark_node;\n-\treturn make_reference_declarator (type, e);\n-      }\n+    case CALL_EXPR:\n+      abort ();\n \n     case ARRAY_REF:\n       {\n@@ -7204,21 +7180,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \treturn build_nt (ARRAY_REF, e1, e2, NULL_TREE, NULL_TREE);\n       }\n \n-    case CALL_EXPR:\n-      {\n-\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\ttree e2 = (tsubst_call_declarator_parms\n-\t\t   (CALL_DECLARATOR_PARMS (t), args, complain, in_decl));\n-\ttree e3 = tsubst (CALL_DECLARATOR_EXCEPTION_SPEC (t), args,\n-\t\t\t  complain, in_decl);\n-\n-\tif (e1 == error_mark_node || e2 == error_mark_node \n-\t    || e3 == error_mark_node)\n-\t  return error_mark_node;\n-\n-\treturn make_call_declarator (e1, e2, CALL_DECLARATOR_QUALS (t), e3);\n-      }\n-\n     case SCOPE_REF:\n       {\n \ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n@@ -8306,6 +8267,7 @@ tsubst_copy_and_build (tree t,\n \t(RECUR (TREE_OPERAND (t, 0)),\n \t RECUR (TREE_OPERAND (t, 1)),\n \t RECUR (TREE_OPERAND (t, 2)),\n+\t RECUR (TREE_OPERAND (t, 3)),\n \t NEW_EXPR_USE_GLOBAL (t));\n \n     case DELETE_EXPR:\n@@ -11198,7 +11160,7 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n \n       /* Set up context.  */\n       import_export_decl (d);\n-      start_function (NULL_TREE, d, NULL_TREE, SF_PRE_PARSED);\n+      start_preparsed_function (d, NULL_TREE, SF_PRE_PARSED);\n \n       /* Create substitution entries for the parameters.  */\n       subst_decl = DECL_TEMPLATE_RESULT (template_for_substitution (d));"}, {"sha": "0d4f4a75a97df73fda5f98f42c4a31228d182120", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058b15c1dc2199a810e4f8793993dc4ede61bb0a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=058b15c1dc2199a810e4f8793993dc4ede61bb0a", "patch": "@@ -1900,23 +1900,6 @@ finish_fname (tree id)\n   return decl;\n }\n \n-/* Begin a function definition declared with DECL_SPECS, ATTRIBUTES,\n-   and DECLARATOR.  Returns nonzero if the function-declaration is\n-   valid.  */\n-\n-int\n-begin_function_definition (tree decl_specs, tree attributes, tree declarator)\n-{\n-  if (!start_function (decl_specs, declarator, attributes, SF_DEFAULT))\n-    return 0;\n-\n-  /* The things we're about to see are not directly qualified by any\n-     template headers we've seen thus far.  */\n-  reset_specialization ();\n-\n-  return 1;\n-}\n-\n /* Finish a translation unit.  */\n \n void \n@@ -1998,24 +1981,6 @@ check_template_template_default_arg (tree argument)\n   return argument;\n }\n \n-/* Finish a parameter list, indicated by PARMS.  If ELLIPSIS is\n-   nonzero, the parameter list was terminated by a `...'.  */\n-\n-tree\n-finish_parmlist (tree parms, int ellipsis)\n-{\n-  if (parms)\n-    {\n-      /* We mark the PARMS as a parmlist so that declarator processing can\n-         disambiguate certain constructs.  */\n-      TREE_PARMLIST (parms) = 1;\n-      /* We do not append void_list_node here, but leave it to grokparms\n-         to do that.  */\n-      PARMLIST_ELLIPSIS_P (parms) = ellipsis;\n-    }\n-  return parms;\n-}\n-\n /* Begin a class definition, as indicated by T.  */\n \n tree"}]}