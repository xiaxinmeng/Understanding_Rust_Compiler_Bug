{"sha": "99ea153e45c86a1b0318e3f5e983624c3336445e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTllYTE1M2U0NWM4NmExYjAzMThlM2Y1ZTk4MzYyNGMzMzM2NDQ1ZQ==", "commit": {"author": {"name": "Sterling Augustine", "email": "saugustine@google.com", "date": "2012-11-06T23:15:25Z"}, "committer": {"name": "Sterling Augustine", "email": "sterling@gcc.gnu.org", "date": "2012-11-06T23:15:25Z"}, "message": "common.opt (gno-split-dwarf, [...]): New switches.\n\ngcc/ChangeLog\n\n2012-11-06  Sterling Augustine <saugustine@google.com>\n            Cary Coutant <ccoutant@google.com>\n\n\t* common.opt (gno-split-dwarf, gsplit-dwarf): New switches.\n\t* doc/invoke.texi (Debugging Options): Document them.\n\t* gcc.c (replace_extension_spec_func):  New function.\n\t(ASM_FINAL_SPEC): Adjust.\n\t(static_spec_functions): Add new field for replace-extension.\n\t(check_live_switch): Adjust comment.  Add case for 'g'.\n\t* opts.c (finish_options): Set x_debug_generate_pub_sections based on\n\tx_dwarf_split_debug_info.\n\t(common_handle_option): Add case for OPT_gsplit_dwarf.\n\t* dwarf2out.h (addr_table_entry_struct): Add forward declaration.\n\t(dw_val_struct): Add val_entry pointer.\n\t* dwarf2out.c: (debug_skeleton_info_section,\n\tdebug_skeleton_abbrev_section, debug_addr_section,\n\tdebug_skeleton_line_section, debug_str_offsets_section): New globals.\n\t(NOT_INDEXED, NO_INDEX_ASSIGNED): New defines.\n\t(indirect_string_node): New field index.\n\t(ate_kind): New enum with fields ate_kind_rtc, ate_kind_rtx_dtprel,\n\tate_kind_label.\n\t(addr_table_entry): New structure and type.\n\t(dw_loc_list_struct): Add field begin_entry.\n\t(new_loc_desc): Initialize val_entry.\n\t(size_of_loc_descr, output_loc_operands, output_loc_operands_raw):\n\tAdd cases for DW_OP_GNU_addr_index and DW_OP_const_index.\n\t(build_cfa_loc): Initialize val_entry.\n\t(AT_index, add_addr_table_entry, remove_addr_table_entry,\n\tadd_AT_lbl_id): New functions.\n\t(add_AT_addr, add_AT_range_list): New parameter force_direct.\n\t(output_die_abbrevs): New function.\n\t(add_ranges_by_labels): New parameter force_direct.\n\t(output_line_info): New parameter prologue_only.\n\t(dtprel_bool): New enum with dtprel_false and dtprel_true.\n\t(dw_addr_op, new_addr_loc_descr): New functions.\n\t(DEBUG_DWO_INFO_SECTION, DEBUG_DWO_ABBREV_SECTION,\n\tDEBUG_ADDR_SECTION, DEBUG_NORM_MACINFO_SECTION,\n\tDEBUG_DWO_MACINFO_SECTION, DEBUG_MACINFO_SECTION,\n\tDEBUG_NORM_MACRO_SECTION, DEBUG_DWO_MACRO_SECTION,\n\tDEBUG_MACRO_SECTION, DEBUG_DWO_LINE_SECTION,\n\tDEBUG_DWO_LOC_SECTION, DEBUG_NORM_STR_OFFSETS_SECTION,\n\tDEBUG_DWO_STR_OFFSETS_SECTION, DEBUG_STR_OFFSETS_SECTION,\n\tDEBUG_DWO_STR_SECTION, DEBUG_NORM_STR_SECTION, DEBUG_STR_SECTION,\n\tDEBUG_MACRO_SECTION_FLAGS, DEBUG_SKELETON_LINE_SECTION_LABEL,\n\tDEBUG_SKELETON_INFO_SECTION_LABEL, DEBUG_ADDR_SECTION_LABEL\n\tDEBUG_SKELETON_ABBREV_SECTION_LABEL): New macros.\n\t(DEBUG_STR_SECTION_FLAGS): Adjust.\n\t(TEXT_SECTION_LABEL, COLD_TEXT_SECTION_LABEL,\n\tDEBUG_LINE_SECTION_LABEL, DEBUG_INFO_SECTION_LABEL,\n\tDEBUG_ABBREV_SECTION_LABEL, DEBUG_ADDR_SECTION_LABEL,\n\tDEBUG_LOC_SECTION_LABEL, DEBUG_RANGES_SECTION_LABEL,\n\tDEBUG_MACINFO_SECTION_LABEL, DEBUG_MACRO_SECTION_LABEL): Adjust\n\tindentation.\n\t(debug_skeleton_abbrev_section_label, debug_addr_section_label,\n\tdebug_skeleton_line_section_label, debug_skeleton_info_section_label):\n\tNew global variables.\n\t(add_AT_flag, add_AT_int, add_AT_unsigned, add_AT_double, add_AT_vec,\n\tadd_AT_data8): Initialize val_entry.\n\t(add_AT_low_high_pc): New parameter force_direct. Handle\n\tdwarf_split_debug_info.\n\t(set_indirect_string, find_AT_string_form): New functions.\n\t(AT_string_form): Adjust to call find_AT_string_from.\n\t(add_AT_die_ref, add_AT_fde_ref, add_AT_loc, add_AT_list):\n\tInitialize val_entry.\n\t(addr_index_table): New global variable.\n\t(addr_table_entry_do_hash, addr_table_entry_eq, add_addr_table_entry,\n\tinit_addr_table_entry, remove_addr_table_entry, index_addr_table_entry,\n\tremove_loc_list_addr_table_entries): New functions.\n\t(add_AT_addr, add_AT_lbl_id, add_AT_range_list): New parameter\n\tforce_direct.  Handle dwarf_split_debug_info.\n\t(add_AT_file, add_AT_vms_delta, add_AT_lineptr, add_AT_macptr,\n\tadd_AT_offset): Initialize val_entry.\n\t(UNRELOCATED_OFFSET, RELOCATED_OFFSET): New defines.\n\t(size_of_die): Handle dwarf_split_debug_info.\n\t(size_of_aranges, value_format): Call AT_class.  Check AT_index.\n\t(output_die_abbrevs): New function.\n\t(output_abbrev_section): Call output_die_abbrevs.\n\t(new_loc_list): Initialize begin_entry.\n\t(output_loc_list): Handle dwarf_split_debug_info.\n\t(output_range_list_offset, output_loc_list_offset,\n\toutput_attr_index_or_value, ): New functions.\n\t(output_die): Fix call to dw2_asm_output_data.  Call\n\toutput_attr_index_or_value and output_range_list_offset.\n\tAdjust logic around dw_val_class_str.\n\t(add_top_lebel_skeleton_die_attrs, get_skeleton_type_unit,\n\toutput_skeleton_debug_sections): New functions.\n\t(output_comdat_type_unit, output_pubname, output_aranges): Handle\n\tdwarf_split_debug_info.\n\t(add_ranges_by_labels): New parameter force_direct.\n\t(mem_loc_descriptor, loc_descr): Call new_addr_loc_descr.\n\t(loc_list_from_tree, add_const_value_attribtue): Use dtprel_bools in\n\tplace of generic integer.\n\t(dwarf2out_vms_debug_main_pointer, gen_entry_point_die, gen_label_die,\n\tgen_call_site_die, gen_subprogram_die, gen_variable_die,\n\tadd_high_low_attributes): Adjust calls to add_AT_lbl_id.\n\t(output_macinfo_op): Adjust indirect_string_logic.\n\t(save_macinfo_strings): New function.\n\t(output_macinfo): Adjust.\n\t(dwarf2out_init): Handle dwarf_split_debug_info.\n\t(index_string, output_index_string_offset, output_index_string): New\n\tfunctions.\n\t(output_indirect_string): Adjust.\n\t(output_indirect_strings, output_addr_table_entry, output_addr_table):\n\tNew functions.\n\t(resolve_addr_in_expr, hash_loc_operands): Handle DW_OP_GNU_addr_index\n\tand DW_OP_GNU_const_index.  Handle dwarf_split_debug_info.  Call\n\tremove_loc_list_addr_table_entries and remove_addr_table_entry.\n\t(index_location_lists): New function.\n\t(dwarf2out_finish): Handle dwarf_split_debug_info.  New variable\n\tmain_comp_unit_die.  Adjust calls to add_AT_low_high_pc,\n\tadd_ranges_by_labels, add_AT_addr, and add_AT_lineptr. Call\n\tsave_macinfo_strings and output_indirect_strings.\n\ninclude/ChangeLog\n\n2012-10-29  Sterling Augustine <saugustine@google.com>\n            Cary Coutant <ccoutant@google.com>\n\n\t* dwarf2.h (dwarf_location_list_entry_type): New enum with fields\n\tDW_LLE_GNU_end_of_list_entry, DW_LLE_GNU_base_address_selection_entry,\n\tDW_LLE_GNU_start_end_entry and DW_LLE_GNU_start_length_entry.\n\n\n\n\nCo-Authored-By: Cary Coutant <ccoutant@google.com>\n\nFrom-SVN: r193267", "tree": {"sha": "febfaf6088d8ca6dd6bcd34ff4948244ce49af9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/febfaf6088d8ca6dd6bcd34ff4948244ce49af9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99ea153e45c86a1b0318e3f5e983624c3336445e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99ea153e45c86a1b0318e3f5e983624c3336445e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99ea153e45c86a1b0318e3f5e983624c3336445e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99ea153e45c86a1b0318e3f5e983624c3336445e/comments", "author": {"login": "Sterling-Augustine", "id": 56981066, "node_id": "MDQ6VXNlcjU2OTgxMDY2", "avatar_url": "https://avatars.githubusercontent.com/u/56981066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sterling-Augustine", "html_url": "https://github.com/Sterling-Augustine", "followers_url": "https://api.github.com/users/Sterling-Augustine/followers", "following_url": "https://api.github.com/users/Sterling-Augustine/following{/other_user}", "gists_url": "https://api.github.com/users/Sterling-Augustine/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sterling-Augustine/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sterling-Augustine/subscriptions", "organizations_url": "https://api.github.com/users/Sterling-Augustine/orgs", "repos_url": "https://api.github.com/users/Sterling-Augustine/repos", "events_url": "https://api.github.com/users/Sterling-Augustine/events{/privacy}", "received_events_url": "https://api.github.com/users/Sterling-Augustine/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e808687a8ccc75ed362176302f88e96f59299db5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e808687a8ccc75ed362176302f88e96f59299db5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e808687a8ccc75ed362176302f88e96f59299db5"}], "stats": {"total": 1659, "additions": 1437, "deletions": 222}, "files": [{"sha": "b4dd302fe6028b7bafd000b1db3de894d81838b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -1,3 +1,116 @@\n+2012-11-06  Sterling Augustine <saugustine@google.com>\n+            Cary Coutant <ccoutant@google.com>\n+\n+\t* common.opt (gno-split-dwarf, gsplit-dwarf): New switches.\n+\t* doc/invoke.texi (Debugging Options): Document them.\n+\t* gcc.c (replace_extension_spec_func):  New function.\n+\t(ASM_FINAL_SPEC): Adjust.\n+\t(static_spec_functions): Add new field for replace-extension.\n+\t(check_live_switch): Adjust comment.  Add case for 'g'.\n+\t* opts.c (finish_options): Set x_debug_generate_pub_sections based on\n+\tx_dwarf_split_debug_info.\n+\t(common_handle_option): Add case for OPT_gsplit_dwarf.\n+\t* dwarf2out.h (addr_table_entry_struct): Add forward declaration.\n+\t(dw_val_struct): Add val_entry pointer.\n+\t* dwarf2out.c: (debug_skeleton_info_section,\n+\tdebug_skeleton_abbrev_section, debug_addr_section,\n+\tdebug_skeleton_line_section, debug_str_offsets_section): New globals.\n+\t(NOT_INDEXED, NO_INDEX_ASSIGNED): New defines.\n+\t(indirect_string_node): New field index.\n+\t(ate_kind): New enum with fields ate_kind_rtc, ate_kind_rtx_dtprel,\n+\tate_kind_label.\n+\t(addr_table_entry): New structure and type.\n+\t(dw_loc_list_struct): Add field begin_entry.\n+\t(new_loc_desc): Initialize val_entry.\n+\t(size_of_loc_descr, output_loc_operands, output_loc_operands_raw):\n+\tAdd cases for DW_OP_GNU_addr_index and DW_OP_const_index.\n+\t(build_cfa_loc): Initialize val_entry.\n+\t(AT_index, add_addr_table_entry, remove_addr_table_entry,\n+\tadd_AT_lbl_id): New functions.\n+\t(add_AT_addr, add_AT_range_list): New parameter force_direct.\n+\t(output_die_abbrevs): New function.\n+\t(add_ranges_by_labels): New parameter force_direct.\n+\t(output_line_info): New parameter prologue_only.\n+\t(dtprel_bool): New enum with dtprel_false and dtprel_true.\n+\t(dw_addr_op, new_addr_loc_descr): New functions.\n+\t(DEBUG_DWO_INFO_SECTION, DEBUG_DWO_ABBREV_SECTION,\n+\tDEBUG_ADDR_SECTION, DEBUG_NORM_MACINFO_SECTION,\n+\tDEBUG_DWO_MACINFO_SECTION, DEBUG_MACINFO_SECTION,\n+\tDEBUG_NORM_MACRO_SECTION, DEBUG_DWO_MACRO_SECTION,\n+\tDEBUG_MACRO_SECTION, DEBUG_DWO_LINE_SECTION,\n+\tDEBUG_DWO_LOC_SECTION, DEBUG_NORM_STR_OFFSETS_SECTION,\n+\tDEBUG_DWO_STR_OFFSETS_SECTION, DEBUG_STR_OFFSETS_SECTION,\n+\tDEBUG_DWO_STR_SECTION, DEBUG_NORM_STR_SECTION, DEBUG_STR_SECTION,\n+\tDEBUG_MACRO_SECTION_FLAGS, DEBUG_SKELETON_LINE_SECTION_LABEL,\n+\tDEBUG_SKELETON_INFO_SECTION_LABEL, DEBUG_ADDR_SECTION_LABEL\n+\tDEBUG_SKELETON_ABBREV_SECTION_LABEL): New macros.\n+\t(DEBUG_STR_SECTION_FLAGS): Adjust.\n+\t(TEXT_SECTION_LABEL, COLD_TEXT_SECTION_LABEL,\n+\tDEBUG_LINE_SECTION_LABEL, DEBUG_INFO_SECTION_LABEL,\n+\tDEBUG_ABBREV_SECTION_LABEL, DEBUG_ADDR_SECTION_LABEL,\n+\tDEBUG_LOC_SECTION_LABEL, DEBUG_RANGES_SECTION_LABEL,\n+\tDEBUG_MACINFO_SECTION_LABEL, DEBUG_MACRO_SECTION_LABEL): Adjust\n+\tindentation.\n+\t(debug_skeleton_abbrev_section_label, debug_addr_section_label,\n+\tdebug_skeleton_line_section_label, debug_skeleton_info_section_label):\n+\tNew global variables.\n+\t(add_AT_flag, add_AT_int, add_AT_unsigned, add_AT_double, add_AT_vec,\n+\tadd_AT_data8): Initialize val_entry.\n+\t(add_AT_low_high_pc): New parameter force_direct. Handle\n+\tdwarf_split_debug_info.\n+\t(set_indirect_string, find_AT_string_form): New functions.\n+\t(AT_string_form): Adjust to call find_AT_string_from.\n+\t(add_AT_die_ref, add_AT_fde_ref, add_AT_loc, add_AT_list):\n+\tInitialize val_entry.\n+\t(addr_index_table): New global variable.\n+\t(addr_table_entry_do_hash, addr_table_entry_eq, add_addr_table_entry,\n+\tinit_addr_table_entry, remove_addr_table_entry, index_addr_table_entry,\n+\tremove_loc_list_addr_table_entries): New functions.\n+\t(add_AT_addr, add_AT_lbl_id, add_AT_range_list): New parameter\n+\tforce_direct.  Handle dwarf_split_debug_info.\n+\t(add_AT_file, add_AT_vms_delta, add_AT_lineptr, add_AT_macptr,\n+\tadd_AT_offset): Initialize val_entry.\n+\t(UNRELOCATED_OFFSET, RELOCATED_OFFSET): New defines.\n+\t(size_of_die): Handle dwarf_split_debug_info.\n+\t(size_of_aranges, value_format): Call AT_class.  Check AT_index.\n+\t(output_die_abbrevs): New function.\n+\t(output_abbrev_section): Call output_die_abbrevs.\n+\t(new_loc_list): Initialize begin_entry.\n+\t(output_loc_list): Handle dwarf_split_debug_info.\n+\t(output_range_list_offset, output_loc_list_offset,\n+\toutput_attr_index_or_value, ): New functions.\n+\t(output_die): Fix call to dw2_asm_output_data.  Call\n+\toutput_attr_index_or_value and output_range_list_offset.\n+\tAdjust logic around dw_val_class_str.\n+\t(add_top_lebel_skeleton_die_attrs, get_skeleton_type_unit,\n+\toutput_skeleton_debug_sections): New functions.\n+\t(output_comdat_type_unit, output_pubname, output_aranges): Handle\n+\tdwarf_split_debug_info.\n+\t(add_ranges_by_labels): New parameter force_direct.\n+\t(mem_loc_descriptor, loc_descr): Call new_addr_loc_descr.\n+\t(loc_list_from_tree, add_const_value_attribtue): Use dtprel_bools in\n+\tplace of generic integer.\n+\t(dwarf2out_vms_debug_main_pointer, gen_entry_point_die, gen_label_die,\n+\tgen_call_site_die, gen_subprogram_die, gen_variable_die,\n+\tadd_high_low_attributes): Adjust calls to add_AT_lbl_id.\n+\t(output_macinfo_op): Adjust indirect_string_logic.\n+\t(save_macinfo_strings): New function.\n+\t(output_macinfo): Adjust.\n+\t(dwarf2out_init): Handle dwarf_split_debug_info.\n+\t(index_string, output_index_string_offset, output_index_string): New\n+\tfunctions.\n+\t(output_indirect_string): Adjust.\n+\t(output_indirect_strings, output_addr_table_entry, output_addr_table):\n+\tNew functions.\n+\t(resolve_addr_in_expr, hash_loc_operands): Handle DW_OP_GNU_addr_index\n+\tand DW_OP_GNU_const_index.  Handle dwarf_split_debug_info.  Call\n+\tremove_loc_list_addr_table_entries and remove_addr_table_entry.\n+\t(index_location_lists): New function.\n+\t(dwarf2out_finish): Handle dwarf_split_debug_info.  New variable\n+\tmain_comp_unit_die.  Adjust calls to add_AT_low_high_pc,\n+\tadd_ranges_by_labels, add_AT_addr, and add_AT_lineptr. Call\n+\tsave_macinfo_strings and output_indirect_strings.\n+\n 2012-11-06  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* config/i386/i386.c (make_dispatcher_decl): Guard with"}, {"sha": "6b95c0558b7c58dd7054c9a7e91d04a57731f258", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -2314,6 +2314,14 @@ grecord-gcc-switches\n Common RejectNegative Var(dwarf_record_gcc_switches,1)\n Record gcc command line switches in DWARF DW_AT_producer.\n \n+gno-split-dwarf\n+Common Driver RejectNegative Var(dwarf_split_debug_info,0) Init(0)\n+Don't generate debug information in separate .dwo files\n+\n+gsplit-dwarf\n+Common Driver RejectNegative Var(dwarf_split_debug_info,1)\n+Generate debug information in separate .dwo files\n+\n gstabs\n Common JoinedOrMissing Negative(gstabs+)\n Generate debug information in STABS format"}, {"sha": "55f72297ea0517acd8fb57c4eec733eb1af5d385", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -4846,6 +4846,14 @@ it reasonable to use the optimizer for programs that might have bugs.\n The following options are useful when GCC is generated with the\n capability for more than one debugging format.\n \n+@item -gsplit-dwarf\n+@opindex gsplit-dwarf\n+Separate as much dwarf debugging information as possible into a\n+separate output file with the extension .dwo.  This option allows\n+the build system to avoid linking files with debug information.  To\n+be useful, this option requires a debugger capable of reading .dwo\n+files.\n+\n @item -ggdb\n @opindex ggdb\n Produce debugging information for use by GDB@.  This means to use the"}, {"sha": "310f2dd5373c41973bd2fdff9e5fd62927609f49", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1235, "deletions": 218, "changes": 1453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -147,14 +147,19 @@ static GTY(()) VEC(tree,gc) *decl_scope_table;\n \n /* Pointers to various DWARF2 sections.  */\n static GTY(()) section *debug_info_section;\n+static GTY(()) section *debug_skeleton_info_section;\n static GTY(()) section *debug_abbrev_section;\n+static GTY(()) section *debug_skeleton_abbrev_section;\n static GTY(()) section *debug_aranges_section;\n+static GTY(()) section *debug_addr_section;\n static GTY(()) section *debug_macinfo_section;\n static GTY(()) section *debug_line_section;\n+static GTY(()) section *debug_skeleton_line_section;\n static GTY(()) section *debug_loc_section;\n static GTY(()) section *debug_pubnames_section;\n static GTY(()) section *debug_pubtypes_section;\n static GTY(()) section *debug_str_section;\n+static GTY(()) section *debug_str_offsets_section;\n static GTY(()) section *debug_ranges_section;\n static GTY(()) section *debug_frame_section;\n \n@@ -190,13 +195,17 @@ DEF_VEC_ALLOC_P (dw_fde_ref, gc);\n \n /* A vector for a table that contains frame description\n    information for each routine.  */\n+#define NOT_INDEXED (-1U)\n+#define NO_INDEX_ASSIGNED (-2U)\n+\n static GTY(()) VEC(dw_fde_ref, gc) *fde_vec;\n \n struct GTY(()) indirect_string_node {\n   const char *str;\n   unsigned int refcount;\n   enum dwarf_form form;\n   char *label;\n+  unsigned int index;\n };\n \n static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;\n@@ -1198,13 +1207,35 @@ static GTY(()) VEC(deferred_locations, gc) *deferred_locations_list;\n DEF_VEC_P(dw_die_ref);\n DEF_VEC_ALLOC_P(dw_die_ref,heap);\n \n+/* Describe an entry into the .debug_addr section.  */\n+\n+enum ate_kind {\n+  ate_kind_rtx,\n+  ate_kind_rtx_dtprel,\n+  ate_kind_label\n+};\n+\n+typedef struct GTY(()) addr_table_entry_struct {\n+  enum ate_kind kind;\n+  unsigned int refcount;\n+  unsigned int index;\n+  union addr_table_entry_struct_union\n+    {\n+      rtx GTY ((tag (\"0\"))) rtl;\n+      char * GTY ((tag (\"1\"))) label;\n+    }\n+  GTY ((desc (\"%1.kind\"))) addr;\n+}\n+addr_table_entry;\n+\n /* Location lists are ranges + location descriptions for that range,\n    so you can track variables that are in different places over\n    their entire life.  */\n typedef struct GTY(()) dw_loc_list_struct {\n   dw_loc_list_ref dw_loc_next;\n-  const char *begin; /* Label for begin address of range */\n-  const char *end;  /* Label for end address of range */\n+  const char *begin; /* Label and addr_entry for start of range */\n+  addr_table_entry *begin_entry;\n+  const char *end;  /* Label for end of range */\n   char *ll_symbol; /* Label for beginning of location list.\n \t\t      Only on head of list */\n   const char *section; /* Section this loclist is relative to */\n@@ -1248,8 +1279,10 @@ new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,\n \n   descr->dw_loc_opc = op;\n   descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;\n+  descr->dw_loc_oprnd1.val_entry = NULL;\n   descr->dw_loc_oprnd1.v.val_unsigned = oprnd1;\n   descr->dw_loc_oprnd2.val_class = dw_val_class_unsigned_const;\n+  descr->dw_loc_oprnd2.val_entry = NULL;\n   descr->dw_loc_oprnd2.v.val_unsigned = oprnd2;\n \n   return descr;\n@@ -1454,6 +1487,11 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n     case DW_OP_addr:\n       size += DWARF2_ADDR_SIZE;\n       break;\n+    case DW_OP_GNU_addr_index:\n+    case DW_OP_GNU_const_index:\n+      gcc_assert (loc->dw_loc_oprnd1.val_entry->index != NO_INDEX_ASSIGNED);\n+      size += size_of_uleb128 (loc->dw_loc_oprnd1.val_entry->index);\n+      break;\n     case DW_OP_const1u:\n     case DW_OP_const1s:\n       size += 1;\n@@ -1890,6 +1928,13 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n \t}\n       break;\n \n+    case DW_OP_GNU_addr_index:\n+    case DW_OP_GNU_const_index:\n+      gcc_assert (loc->dw_loc_oprnd1.val_entry->index != NO_INDEX_ASSIGNED);\n+      dw2_asm_output_data_uleb128 (loc->dw_loc_oprnd1.val_entry->index,\n+                                   \"(index into .debug_addr)\");\n+      break;\n+\n     case DW_OP_GNU_implicit_pointer:\n       {\n \tchar label[MAX_ARTIFICIAL_LABEL_BYTES\n@@ -2065,6 +2110,8 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n   switch (loc->dw_loc_opc)\n     {\n     case DW_OP_addr:\n+    case DW_OP_GNU_addr_index:\n+    case DW_OP_GNU_const_index:\n     case DW_OP_implicit_value:\n       /* We cannot output addresses in .cfi_escape, only bytes.  */\n       gcc_unreachable ();\n@@ -2248,6 +2295,7 @@ build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n     {\n       head = new_reg_loc_descr (cfa->reg, cfa->base_offset);\n       head->dw_loc_oprnd1.val_class = dw_val_class_const;\n+      head->dw_loc_oprnd1.val_entry = NULL;\n       tmp = new_loc_descr (DW_OP_deref, 0, 0);\n       add_loc_descr (&head, tmp);\n       if (offset != 0)\n@@ -2877,6 +2925,7 @@ static tree decl_ultimate_origin (const_tree);\n static tree decl_class_context (tree);\n static void add_dwarf_attr (dw_die_ref, dw_attr_ref);\n static inline enum dw_val_class AT_class (dw_attr_ref);\n+static inline unsigned int AT_index (dw_attr_ref);\n static void add_AT_flag (dw_die_ref, enum dwarf_attribute, unsigned);\n static inline unsigned AT_flag (dw_attr_ref);\n static void add_AT_int (dw_die_ref, enum dwarf_attribute, HOST_WIDE_INT);\n@@ -2904,15 +2953,17 @@ static inline dw_loc_descr_ref AT_loc (dw_attr_ref);\n static void add_AT_loc_list (dw_die_ref, enum dwarf_attribute,\n \t\t\t     dw_loc_list_ref);\n static inline dw_loc_list_ref AT_loc_list (dw_attr_ref);\n-static void add_AT_addr (dw_die_ref, enum dwarf_attribute, rtx);\n+static addr_table_entry *add_addr_table_entry (void *, enum ate_kind);\n+static void remove_addr_table_entry (addr_table_entry *);\n+static void add_AT_addr (dw_die_ref, enum dwarf_attribute, rtx, bool);\n static inline rtx AT_addr (dw_attr_ref);\n static void add_AT_lbl_id (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_lineptr (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_macptr (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_offset (dw_die_ref, enum dwarf_attribute,\n \t\t\t   unsigned HOST_WIDE_INT);\n static void add_AT_range_list (dw_die_ref, enum dwarf_attribute,\n-\t\t\t       unsigned long);\n+                               unsigned long, bool);\n static inline const char *AT_lbl (dw_attr_ref);\n static dw_attr_ref get_AT (dw_die_ref, enum dwarf_attribute);\n static const char *get_AT_low_pc (dw_die_ref);\n@@ -3007,6 +3058,7 @@ static unsigned long size_of_aranges (void);\n static enum dwarf_form value_format (dw_attr_ref);\n static void output_value_format (dw_attr_ref);\n static void output_abbrev_section (void);\n+static void output_die_abbrevs (unsigned long, dw_die_ref);\n static void output_die_symbol (dw_die_ref);\n static void output_die (dw_die_ref);\n static void output_compilation_unit_header (void);\n@@ -3022,10 +3074,10 @@ static void output_aranges (unsigned long);\n static unsigned int add_ranges_num (int);\n static unsigned int add_ranges (const_tree);\n static void add_ranges_by_labels (dw_die_ref, const char *, const char *,\n-\t\t\t\t  bool *);\n+                                  bool *, bool);\n static void output_ranges (void);\n static dw_line_info_table *new_line_info_table (void);\n-static void output_line_info (void);\n+static void output_line_info (bool);\n static void output_file_names (void);\n static dw_die_ref base_type_die (tree);\n static int is_base_type (tree);\n@@ -3164,36 +3216,124 @@ static bool generic_type_p (tree);\n static void schedule_generic_params_dies_gen (tree t);\n static void gen_scheduled_generic_parms_dies (void);\n \n+/* enum for tracking thread-local variables whose address is really an offset\n+   relative to the TLS pointer, which will need link-time relocation, but will\n+   not need relocation by the DWARF consumer.  */\n+\n+enum dtprel_bool\n+{\n+  dtprel_false = 0,\n+  dtprel_true = 1\n+};\n+\n+/* Return the operator to use for an address of a variable.  For dtprel_true, we\n+   use DW_OP_const*.  For regular variables, which need both link-time\n+   relocation and consumer-level relocation (e.g., to account for shared objects\n+   loaded at a random address), we use DW_OP_addr*.  */\n+\n+static inline enum dwarf_location_atom\n+dw_addr_op (enum dtprel_bool dtprel)\n+{\n+  if (dtprel == dtprel_true)\n+    return (dwarf_split_debug_info ? DW_OP_GNU_const_index\n+            : (DWARF2_ADDR_SIZE == 4 ? DW_OP_const4u : DW_OP_const8u));\n+  else\n+    return dwarf_split_debug_info ? DW_OP_GNU_addr_index : DW_OP_addr;\n+}\n+\n+/* Return a pointer to a newly allocated address location description.  If\n+   dwarf_split_debug_info is true, then record the address with the appropriate\n+   relocation.  */\n+static inline dw_loc_descr_ref\n+new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n+{\n+  dw_loc_descr_ref ref = new_loc_descr (dw_addr_op (dtprel), 0, 0);\n+\n+  ref->dw_loc_oprnd1.val_class = dw_val_class_addr;\n+  ref->dw_loc_oprnd1.v.val_addr = addr;\n+  ref->dtprel = dtprel;\n+  if (dwarf_split_debug_info)\n+    ref->dw_loc_oprnd1.val_entry\n+        = add_addr_table_entry (addr,\n+                                dtprel ? ate_kind_rtx_dtprel : ate_kind_rtx);\n+  else\n+    ref->dw_loc_oprnd1.val_entry = NULL;\n+\n+  return ref;\n+}\n+\n /* Section names used to hold DWARF debugging information.  */\n+\n #ifndef DEBUG_INFO_SECTION\n #define DEBUG_INFO_SECTION\t\".debug_info\"\n #endif\n+#ifndef DEBUG_DWO_INFO_SECTION\n+#define DEBUG_DWO_INFO_SECTION \".debug_info.dwo\"\n+#endif\n #ifndef DEBUG_ABBREV_SECTION\n #define DEBUG_ABBREV_SECTION\t\".debug_abbrev\"\n #endif\n+#ifndef DEBUG_DWO_ABBREV_SECTION\n+#define DEBUG_DWO_ABBREV_SECTION \".debug_abbrev.dwo\"\n+#endif\n #ifndef DEBUG_ARANGES_SECTION\n #define DEBUG_ARANGES_SECTION\t\".debug_aranges\"\n #endif\n+#ifndef DEBUG_ADDR_SECTION\n+#define DEBUG_ADDR_SECTION     \".debug_addr\"\n+#endif\n+#ifndef DEBUG_NORM_MACINFO_SECTION\n+#define DEBUG_NORM_MACINFO_SECTION     \".debug_macinfo\"\n+#endif\n+#ifndef DEBUG_DWO_MACINFO_SECTION\n+#define DEBUG_DWO_MACINFO_SECTION      \".debug_macinfo.dwo\"\n+#endif\n #ifndef DEBUG_MACINFO_SECTION\n-#define DEBUG_MACINFO_SECTION\t\".debug_macinfo\"\n+#define DEBUG_MACINFO_SECTION                                           \\\n+  (!dwarf_split_debug_info                                              \\\n+   ? (DEBUG_NORM_MACINFO_SECTION) : (DEBUG_DWO_MACINFO_SECTION))\n+#endif\n+#ifndef DEBUG_NORM_MACRO_SECTION\n+#define DEBUG_NORM_MACRO_SECTION \".debug_macro\"\n+#endif\n+#ifndef DEBUG_DWO_MACRO_SECTION\n+#define DEBUG_DWO_MACRO_SECTION        \".debug_macro.dwo\"\n #endif\n #ifndef DEBUG_MACRO_SECTION\n-#define DEBUG_MACRO_SECTION\t\".debug_macro\"\n+#define DEBUG_MACRO_SECTION                                             \\\n+  (!dwarf_split_debug_info                                              \\\n+   ? (DEBUG_NORM_MACRO_SECTION) : (DEBUG_DWO_MACRO_SECTION))\n #endif\n #ifndef DEBUG_LINE_SECTION\n #define DEBUG_LINE_SECTION\t\".debug_line\"\n #endif\n+#ifndef DEBUG_DWO_LINE_SECTION\n+#define DEBUG_DWO_LINE_SECTION \".debug_line.dwo\"\n+#endif\n #ifndef DEBUG_LOC_SECTION\n #define DEBUG_LOC_SECTION\t\".debug_loc\"\n #endif\n+#ifndef DEBUG_DWO_LOC_SECTION\n+#define DEBUG_DWO_LOC_SECTION  \".debug_loc.dwo\"\n+#endif\n #ifndef DEBUG_PUBNAMES_SECTION\n #define DEBUG_PUBNAMES_SECTION\t\".debug_pubnames\"\n #endif\n #ifndef DEBUG_PUBTYPES_SECTION\n #define DEBUG_PUBTYPES_SECTION\t\".debug_pubtypes\"\n #endif\n+#define DEBUG_NORM_STR_OFFSETS_SECTION \".debug_str_offsets\"\n+#define DEBUG_DWO_STR_OFFSETS_SECTION \".debug_str_offsets.dwo\"\n+#ifndef DEBUG_STR_OFFSETS_SECTION\n+#define DEBUG_STR_OFFSETS_SECTION                                       \\\n+  (!dwarf_split_debug_info                                              \\\n+   ? (DEBUG_NORM_STR_OFFSETS_SECTION) : (DEBUG_DWO_STR_OFFSETS_SECTION))\n+#endif\n+#define DEBUG_DWO_STR_SECTION   \".debug_str.dwo\"\n+#define DEBUG_NORM_STR_SECTION  \".debug_str\"\n #ifndef DEBUG_STR_SECTION\n-#define DEBUG_STR_SECTION\t\".debug_str\"\n+#define DEBUG_STR_SECTION                               \\\n+  (!dwarf_split_debug_info ? (DEBUG_NORM_STR_SECTION) : (DEBUG_DWO_STR_SECTION))\n #endif\n #ifndef DEBUG_RANGES_SECTION\n #define DEBUG_RANGES_SECTION\t\".debug_ranges\"\n@@ -3204,43 +3344,62 @@ static void gen_scheduled_generic_parms_dies (void);\n #define TEXT_SECTION_NAME\t\".text\"\n #endif\n \n+/* Section flags for .debug_macinfo/.debug_macro section.  */\n+#define DEBUG_MACRO_SECTION_FLAGS \\\n+  (dwarf_split_debug_info ? SECTION_DEBUG | SECTION_EXCLUDE : SECTION_DEBUG)\n+\n /* Section flags for .debug_str section.  */\n #define DEBUG_STR_SECTION_FLAGS \\\n-  (HAVE_GAS_SHF_MERGE && flag_merge_debug_strings\t\t\\\n-   ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1\t\\\n-   : SECTION_DEBUG)\n+  (dwarf_split_debug_info \\\n+   ? SECTION_DEBUG | SECTION_EXCLUDE \\\n+   : (HAVE_GAS_SHF_MERGE && flag_merge_debug_strings \\\n+      ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1        \\\n+      : SECTION_DEBUG))\n \n /* Labels we insert at beginning sections we can reference instead of\n    the section names themselves.  */\n \n #ifndef TEXT_SECTION_LABEL\n-#define TEXT_SECTION_LABEL\t\t\"Ltext\"\n+#define TEXT_SECTION_LABEL                 \"Ltext\"\n #endif\n #ifndef COLD_TEXT_SECTION_LABEL\n-#define COLD_TEXT_SECTION_LABEL         \"Ltext_cold\"\n+#define COLD_TEXT_SECTION_LABEL             \"Ltext_cold\"\n #endif\n #ifndef DEBUG_LINE_SECTION_LABEL\n-#define DEBUG_LINE_SECTION_LABEL\t\"Ldebug_line\"\n+#define DEBUG_LINE_SECTION_LABEL           \"Ldebug_line\"\n+#endif\n+#ifndef DEBUG_SKELETON_LINE_SECTION_LABEL\n+#define DEBUG_SKELETON_LINE_SECTION_LABEL   \"Lskeleton_debug_line\"\n #endif\n #ifndef DEBUG_INFO_SECTION_LABEL\n-#define DEBUG_INFO_SECTION_LABEL\t\"Ldebug_info\"\n+#define DEBUG_INFO_SECTION_LABEL           \"Ldebug_info\"\n+#endif\n+#ifndef DEBUG_SKELETON_INFO_SECTION_LABEL\n+#define DEBUG_SKELETON_INFO_SECTION_LABEL   \"Lskeleton_debug_info\"\n #endif\n #ifndef DEBUG_ABBREV_SECTION_LABEL\n-#define DEBUG_ABBREV_SECTION_LABEL\t\"Ldebug_abbrev\"\n+#define DEBUG_ABBREV_SECTION_LABEL         \"Ldebug_abbrev\"\n+#endif\n+#ifndef DEBUG_SKELETON_ABBREV_SECTION_LABEL\n+#define DEBUG_SKELETON_ABBREV_SECTION_LABEL \"Lskeleton_debug_abbrev\"\n+#endif\n+#ifndef DEBUG_ADDR_SECTION_LABEL\n+#define DEBUG_ADDR_SECTION_LABEL           \"Ldebug_addr\"\n #endif\n #ifndef DEBUG_LOC_SECTION_LABEL\n-#define DEBUG_LOC_SECTION_LABEL\t\t\"Ldebug_loc\"\n+#define DEBUG_LOC_SECTION_LABEL                    \"Ldebug_loc\"\n #endif\n #ifndef DEBUG_RANGES_SECTION_LABEL\n-#define DEBUG_RANGES_SECTION_LABEL\t\"Ldebug_ranges\"\n+#define DEBUG_RANGES_SECTION_LABEL         \"Ldebug_ranges\"\n #endif\n #ifndef DEBUG_MACINFO_SECTION_LABEL\n-#define DEBUG_MACINFO_SECTION_LABEL     \"Ldebug_macinfo\"\n+#define DEBUG_MACINFO_SECTION_LABEL         \"Ldebug_macinfo\"\n #endif\n #ifndef DEBUG_MACRO_SECTION_LABEL\n-#define DEBUG_MACRO_SECTION_LABEL\t\"Ldebug_macro\"\n+#define DEBUG_MACRO_SECTION_LABEL          \"Ldebug_macro\"\n #endif\n-\n+#define SKELETON_COMP_DIE_ABBREV 1\n+#define SKELETON_TYPE_DIE_ABBREV 2\n \n /* Definitions of defaults for formats and names of various special\n    (artificial) labels which may be generated within this file (when the -g\n@@ -3254,7 +3413,11 @@ static char cold_text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char cold_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char debug_skeleton_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char debug_skeleton_abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char debug_addr_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char debug_skeleton_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char macinfo_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char loc_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3495,6 +3658,21 @@ AT_class (dw_attr_ref a)\n   return a->dw_attr_val.val_class;\n }\n \n+/* Return the index for any attribute that will be referenced with a\n+   DW_FORM_GNU_addr_index or DW_FORM_GNU_str_index.  String indices\n+   are stored in dw_attr_val.v.val_str for reference counting\n+   pruning.  */\n+\n+static inline unsigned int\n+AT_index (dw_attr_ref a)\n+{\n+  if (AT_class (a) == dw_val_class_str)\n+    return a->dw_attr_val.v.val_str->index;\n+  else if (a->dw_attr_val.val_entry != NULL)\n+    return a->dw_attr_val.val_entry->index;\n+  return NOT_INDEXED;\n+}\n+\n /* Add a flag value attribute to a DIE.  */\n \n static inline void\n@@ -3504,6 +3682,7 @@ add_AT_flag (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int flag)\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_flag;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_flag = flag;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3524,6 +3703,7 @@ add_AT_int (dw_die_ref die, enum dwarf_attribute attr_kind, HOST_WIDE_INT int_va\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_const;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_int = int_val;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3545,6 +3725,7 @@ add_AT_unsigned (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_unsigned_const;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_unsigned = unsigned_val;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3566,6 +3747,7 @@ add_AT_double (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_const_double;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_double.high = high;\n   attr.dw_attr_val.v.val_double.low = low;\n   add_dwarf_attr (die, &attr);\n@@ -3581,6 +3763,7 @@ add_AT_vec (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_vec;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_vec.length = length;\n   attr.dw_attr_val.v.val_vec.elt_size = elt_size;\n   attr.dw_attr_val.v.val_vec.array = array;\n@@ -3597,27 +3780,47 @@ add_AT_data8 (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_data8;\n+  attr.dw_attr_val.val_entry = NULL;\n   memcpy (attr.dw_attr_val.v.val_data8, data8, 8);\n   add_dwarf_attr (die, &attr);\n }\n \n-/* Add DW_AT_low_pc and DW_AT_high_pc to a DIE.  */\n+/* Add DW_AT_low_pc and DW_AT_high_pc to a DIE.  When using\n+   dwarf_split_debug_info, address attributes in dies destined for the\n+   final executable have force_direct set to avoid using indexed\n+   references.  */\n+\n static inline void\n-add_AT_low_high_pc (dw_die_ref die, const char *lbl_low, const char *lbl_high)\n+add_AT_low_high_pc (dw_die_ref die, const char *lbl_low, const char *lbl_high,\n+                    bool force_direct)\n {\n   dw_attr_node attr;\n+  char * lbl_id;\n \n+  lbl_id = xstrdup (lbl_low);\n   attr.dw_attr = DW_AT_low_pc;\n   attr.dw_attr_val.val_class = dw_val_class_lbl_id;\n-  attr.dw_attr_val.v.val_lbl_id = xstrdup (lbl_low);\n+  attr.dw_attr_val.v.val_lbl_id = lbl_id;\n+  if (dwarf_split_debug_info && !force_direct)\n+    attr.dw_attr_val.val_entry\n+        = add_addr_table_entry (lbl_id, ate_kind_label);\n+  else\n+    attr.dw_attr_val.val_entry = NULL;\n   add_dwarf_attr (die, &attr);\n \n   attr.dw_attr = DW_AT_high_pc;\n   if (dwarf_version < 4)\n     attr.dw_attr_val.val_class = dw_val_class_lbl_id;\n   else\n     attr.dw_attr_val.val_class = dw_val_class_high_pc;\n-  attr.dw_attr_val.v.val_lbl_id = xstrdup (lbl_high);\n+  lbl_id = xstrdup (lbl_high);\n+  attr.dw_attr_val.v.val_lbl_id = lbl_id;\n+  if (attr.dw_attr_val.val_class == dw_val_class_lbl_id\n+      && dwarf_split_debug_info && !force_direct)\n+    attr.dw_attr_val.val_entry\n+        = add_addr_table_entry (lbl_id, ate_kind_label);\n+  else\n+    attr.dw_attr_val.val_entry = NULL;\n   add_dwarf_attr (die, &attr);\n }\n \n@@ -3675,6 +3878,7 @@ add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_str;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_str = node;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3686,19 +3890,43 @@ AT_string (dw_attr_ref a)\n   return a->dw_attr_val.v.val_str->str;\n }\n \n+/* Call this function directly to bypass AT_string_form's logic to put\n+   the string inline in the die. */\n+\n+static void\n+set_indirect_string (struct indirect_string_node *node)\n+{\n+  char label[32];\n+  /* Already indirect is a no op.  */\n+  if (node->form == DW_FORM_strp || node->form == DW_FORM_GNU_str_index)\n+    {\n+      gcc_assert (node->label);\n+      return;\n+    }\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n+  ++dw2_string_counter;\n+  node->label = xstrdup (label);\n+\n+  if (!dwarf_split_debug_info)\n+    {\n+      node->form = DW_FORM_strp;\n+      node->index = NOT_INDEXED;\n+    }\n+  else\n+    {\n+      node->form = DW_FORM_GNU_str_index;\n+      node->index = NO_INDEX_ASSIGNED;\n+    }\n+}\n+\n /* Find out whether a string should be output inline in DIE\n    or out-of-line in .debug_str section.  */\n \n static enum dwarf_form\n-AT_string_form (dw_attr_ref a)\n+find_string_form (struct indirect_string_node *node)\n {\n-  struct indirect_string_node *node;\n   unsigned int len;\n-  char label[32];\n \n-  gcc_assert (a && AT_class (a) == dw_val_class_str);\n-\n-  node = a->dw_attr_val.v.val_str;\n   if (node->form)\n     return node->form;\n \n@@ -3717,11 +3945,19 @@ AT_string_form (dw_attr_ref a)\n       && (len - DWARF_OFFSET_SIZE) * node->refcount <= len))\n     return node->form = DW_FORM_string;\n \n-  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n-  ++dw2_string_counter;\n-  node->label = xstrdup (label);\n+  set_indirect_string (node);\n+\n+  return node->form;\n+}\n \n-  return node->form = DW_FORM_strp;\n+/* Find out whether the string referenced from the attribute should be\n+   output inline in DIE or out-of-line in .debug_str section.  */\n+\n+static enum dwarf_form\n+AT_string_form (dw_attr_ref a)\n+{\n+  gcc_assert (a && AT_class (a) == dw_val_class_str);\n+  return find_string_form (a->dw_attr_val.v.val_str);\n }\n \n /* Add a DIE reference attribute value to a DIE.  */\n@@ -3742,6 +3978,7 @@ add_AT_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind, dw_die_ref targ_\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_die_ref;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_die_ref.die = targ_die;\n   attr.dw_attr_val.v.val_die_ref.external = 0;\n   add_dwarf_attr (die, &attr);\n@@ -3800,6 +4037,7 @@ add_AT_fde_ref (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int tar\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_fde_ref;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_fde_index = targ_fde;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3813,6 +4051,7 @@ add_AT_loc (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_descr_ref loc\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_loc;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_loc = loc;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3831,6 +4070,7 @@ add_AT_loc_list (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_list_ref\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_loc_list;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_loc_list = loc_list;\n   add_dwarf_attr (die, &attr);\n   have_location_lists = true;\n@@ -3850,16 +4090,169 @@ AT_loc_list_ptr (dw_attr_ref a)\n   return &a->dw_attr_val.v.val_loc_list;\n }\n \n-/* Add an address constant attribute value to a DIE.  */\n+/* Table of entries into the .debug_addr section.  */\n+\n+static GTY ((param_is (addr_table_entry))) htab_t addr_index_table;\n+\n+/* Hash an address_table_entry.  */\n+\n+static hashval_t\n+addr_table_entry_do_hash (const void *x)\n+{\n+  const addr_table_entry *a = (const addr_table_entry *) x;\n+  switch (a->kind)\n+    {\n+      case ate_kind_rtx:\n+        return iterative_hash_rtx (a->addr.rtl, 0);\n+      case ate_kind_rtx_dtprel:\n+        return iterative_hash_rtx (a->addr.rtl, 1);\n+      case ate_kind_label:\n+        return htab_hash_string (a->addr.label);\n+      default:\n+        gcc_unreachable ();\n+    }\n+}\n+\n+/* Determine equality for two address_table_entries.  */\n+\n+static int\n+addr_table_entry_eq (const void *x1, const void *x2)\n+{\n+  const addr_table_entry *a1 = (const addr_table_entry *) x1;\n+  const addr_table_entry *a2 = (const addr_table_entry *) x2;\n+\n+  if (a1->kind != a2->kind)\n+    return 0;\n+  switch (a1->kind)\n+    {\n+      case ate_kind_rtx:\n+      case ate_kind_rtx_dtprel:\n+        return rtx_equal_p (a1->addr.rtl, a2->addr.rtl);\n+      case ate_kind_label:\n+        return strcmp (a1->addr.label, a2->addr.label) == 0;\n+      default:\n+        gcc_unreachable ();\n+    }\n+}\n+\n+/* Initialize an addr_table_entry.  */\n+\n+void\n+init_addr_table_entry (addr_table_entry *e, enum ate_kind kind, void *addr)\n+{\n+  e->kind = kind;\n+  switch (kind)\n+    {\n+      case ate_kind_rtx:\n+      case ate_kind_rtx_dtprel:\n+        e->addr.rtl = (rtx) addr;\n+        break;\n+      case ate_kind_label:\n+        e->addr.label = (char *) addr;\n+        break;\n+    }\n+  e->refcount = 0;\n+  e->index = NO_INDEX_ASSIGNED;\n+}\n+\n+/* Add attr to the address table entry to the table.  Defer setting an\n+   index until output time.  */\n+\n+static addr_table_entry *\n+add_addr_table_entry (void *addr, enum ate_kind kind)\n+{\n+  addr_table_entry *node;\n+  addr_table_entry finder;\n+  void **slot;\n+\n+  gcc_assert (dwarf_split_debug_info);\n+  if (! addr_index_table)\n+    addr_index_table = htab_create_ggc (10, addr_table_entry_do_hash,\n+                                        addr_table_entry_eq, NULL);\n+  init_addr_table_entry (&finder, kind, addr);\n+  slot = htab_find_slot (addr_index_table, &finder, INSERT);\n+\n+  if (*slot == HTAB_EMPTY_ENTRY)\n+    {\n+      node = ggc_alloc_cleared_addr_table_entry ();\n+      init_addr_table_entry (node, kind, addr);\n+      *slot = node;\n+    }\n+  else\n+    node = (addr_table_entry *) *slot;\n+\n+  node->refcount++;\n+  return node;\n+}\n+\n+/* Remove an entry from the addr table by decrementing its refcount.\n+   Strictly, decrementing the refcount would be enough, but the\n+   assertion that the entry is actually in the table has found\n+   bugs.  */\n+\n+static void\n+remove_addr_table_entry (addr_table_entry *entry)\n+{\n+  addr_table_entry *node;\n+\n+  gcc_assert (dwarf_split_debug_info && addr_index_table);\n+  node = (addr_table_entry *) htab_find (addr_index_table, entry);\n+  /* After an index is assigned, the table is frozen.  */\n+  gcc_assert (node->refcount > 0 && node->index == NO_INDEX_ASSIGNED);\n+  node->refcount--;\n+}\n+\n+/* Given a location list, remove all addresses it refers to from the\n+   address_table.  */\n+\n+static void\n+remove_loc_list_addr_table_entries (dw_loc_descr_ref descr)\n+{\n+  for (; descr; descr = descr->dw_loc_next)\n+    if (descr->dw_loc_oprnd1.val_entry != NULL)\n+      {\n+        gcc_assert (descr->dw_loc_oprnd1.val_entry->index == NO_INDEX_ASSIGNED);\n+        remove_addr_table_entry (descr->dw_loc_oprnd1.val_entry);\n+      }\n+}\n+\n+/* A helper function for dwarf2out_finish called through\n+   htab_traverse.  Assign an addr_table_entry its index.  All entries\n+   must be collected into the table when this function is called,\n+   because the indexing code relies on htab_traverse to traverse nodes\n+   in the same order for each run. */\n+\n+static int\n+index_addr_table_entry (void **h, void *v)\n+{\n+  addr_table_entry *node = (addr_table_entry *) *h;\n+  unsigned int *index = (unsigned int *) v;\n+\n+  gcc_assert(node->index == NO_INDEX_ASSIGNED);\n+  node->index = *index;\n+  *index += 1;\n+\n+  return 1;\n+}\n+\n+/* Add an address constant attribute value to a DIE.  When using\n+   dwarf_split_debug_info, address attributes in dies destined for the\n+   final executable should be direct references--setting the parameter\n+   force_direct ensures this behavior.  */\n \n static inline void\n-add_AT_addr (dw_die_ref die, enum dwarf_attribute attr_kind, rtx addr)\n+add_AT_addr (dw_die_ref die, enum dwarf_attribute attr_kind, rtx addr,\n+             bool force_direct)\n {\n   dw_attr_node attr;\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_addr;\n   attr.dw_attr_val.v.val_addr = addr;\n+  if (dwarf_split_debug_info && !force_direct)\n+    attr.dw_attr_val.val_entry = add_addr_table_entry (addr, ate_kind_rtx);\n+  else\n+    attr.dw_attr_val.val_entry = NULL;\n   add_dwarf_attr (die, &attr);\n }\n \n@@ -3882,6 +4275,7 @@ add_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_file;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_file = fd;\n   add_dwarf_attr (die, &attr);\n }\n@@ -3905,6 +4299,7 @@ add_AT_vms_delta (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_vms_delta;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_vms_delta.lbl1 = xstrdup (lbl1);\n   attr.dw_attr_val.v.val_vms_delta.lbl2 = xstrdup (lbl2);\n   add_dwarf_attr (die, &attr);\n@@ -3913,13 +4308,19 @@ add_AT_vms_delta (dw_die_ref die, enum dwarf_attribute attr_kind,\n /* Add a label identifier attribute value to a DIE.  */\n \n static inline void\n-add_AT_lbl_id (dw_die_ref die, enum dwarf_attribute attr_kind, const char *lbl_id)\n+add_AT_lbl_id (dw_die_ref die, enum dwarf_attribute attr_kind,\n+               const char *lbl_id)\n {\n   dw_attr_node attr;\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_lbl_id;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_lbl_id = xstrdup (lbl_id);\n+  if (dwarf_split_debug_info)\n+    attr.dw_attr_val.val_entry\n+        = add_addr_table_entry (attr.dw_attr_val.v.val_lbl_id,\n+                                ate_kind_label);\n   add_dwarf_attr (die, &attr);\n }\n \n@@ -3934,6 +4335,7 @@ add_AT_lineptr (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_lineptr;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_lbl_id = xstrdup (label);\n   add_dwarf_attr (die, &attr);\n }\n@@ -3949,6 +4351,7 @@ add_AT_macptr (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_macptr;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_lbl_id = xstrdup (label);\n   add_dwarf_attr (die, &attr);\n }\n@@ -3963,20 +4366,34 @@ add_AT_offset (dw_die_ref die, enum dwarf_attribute attr_kind,\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_offset;\n+  attr.dw_attr_val.val_entry = NULL;\n   attr.dw_attr_val.v.val_offset = offset;\n   add_dwarf_attr (die, &attr);\n }\n \n-/* Add an range_list attribute value to a DIE.  */\n+/* Add a range_list attribute value to a DIE.  When using\n+   dwarf_split_debug_info, address attributes in dies destined for the\n+   final executable should be direct references--setting the parameter\n+   force_direct ensures this behavior.  */\n+\n+#define UNRELOCATED_OFFSET ((addr_table_entry *) 1)\n+#define RELOCATED_OFFSET (NULL)\n \n static void\n add_AT_range_list (dw_die_ref die, enum dwarf_attribute attr_kind,\n-\t\t   long unsigned int offset)\n+                   long unsigned int offset, bool force_direct)\n {\n   dw_attr_node attr;\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_range_list;\n+  /* For the range_list attribute, use val_entry to store whether the\n+     offset should follow split-debug-info or normal semantics.  This\n+     value is read in output_range_list_offset.  */\n+  if (dwarf_split_debug_info && !force_direct)\n+    attr.dw_attr_val.val_entry = UNRELOCATED_OFFSET;\n+  else\n+    attr.dw_attr_val.val_entry = RELOCATED_OFFSET;\n   attr.dw_attr_val.v.val_offset = offset;\n   add_dwarf_attr (die, &attr);\n }\n@@ -7163,14 +7580,21 @@ size_of_die (dw_die_ref die)\n   unsigned long size = 0;\n   dw_attr_ref a;\n   unsigned ix;\n+  enum dwarf_form form;\n \n   size += size_of_uleb128 (die->die_abbrev);\n   FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       switch (AT_class (a))\n \t{\n \tcase dw_val_class_addr:\n-\t  size += DWARF2_ADDR_SIZE;\n+          if (dwarf_split_debug_info && AT_index (a) != NOT_INDEXED)\n+            {\n+              gcc_assert (AT_index (a) != NO_INDEX_ASSIGNED);\n+              size += size_of_uleb128 (AT_index (a));\n+            }\n+          else\n+            size += DWARF2_ADDR_SIZE;\n \t  break;\n \tcase dw_val_class_offset:\n \t  size += DWARF_OFFSET_SIZE;\n@@ -7188,10 +7612,16 @@ size_of_die (dw_die_ref die)\n \t  }\n \t  break;\n \tcase dw_val_class_loc_list:\n-\t  size += DWARF_OFFSET_SIZE;\n+          if (dwarf_split_debug_info && AT_index (a) != NOT_INDEXED)\n+            {\n+              gcc_assert (AT_index (a) != NO_INDEX_ASSIGNED);\n+              size += size_of_uleb128 (AT_index (a));\n+            }\n+          else\n+            size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_range_list:\n-\t  size += DWARF_OFFSET_SIZE;\n+          size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_const:\n \t  size += size_of_sleb128 (AT_int (a));\n@@ -7251,15 +7681,24 @@ size_of_die (dw_die_ref die)\n \t  size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_lbl_id:\n-\t  size += DWARF2_ADDR_SIZE;\n+          if (dwarf_split_debug_info && AT_index (a) != NOT_INDEXED)\n+            {\n+              gcc_assert (AT_index (a) != NO_INDEX_ASSIGNED);\n+              size += size_of_uleb128 (AT_index (a));\n+            }\n+          else\n+            size += DWARF2_ADDR_SIZE;\n \t  break;\n \tcase dw_val_class_lineptr:\n \tcase dw_val_class_macptr:\n-\t  size += DWARF_OFFSET_SIZE;\n+          size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_str:\n-\t  if (AT_string_form (a) == DW_FORM_strp)\n+          form = AT_string_form (a);\n+          if (form == DW_FORM_strp)\n \t    size += DWARF_OFFSET_SIZE;\n+         else if (form == DW_FORM_GNU_str_index)\n+            size += size_of_uleb128 (AT_index (a));\n \t  else\n \t    size += strlen (a->dw_attr_val.v.val_str->str) + 1;\n \t  break;\n@@ -7444,7 +7883,7 @@ size_of_aranges (void)\n static enum dwarf_form\n value_format (dw_attr_ref a)\n {\n-  switch (a->dw_attr_val.val_class)\n+  switch (AT_class (a))\n     {\n     case dw_val_class_addr:\n       /* Only very few attributes allow DW_FORM_addr.  */\n@@ -7454,7 +7893,8 @@ value_format (dw_attr_ref a)\n \tcase DW_AT_high_pc:\n \tcase DW_AT_entry_pc:\n \tcase DW_AT_trampoline:\n-\t  return DW_FORM_addr;\n+          return (AT_index (a) == NOT_INDEXED\n+                  ? DW_FORM_addr : DW_FORM_GNU_addr_index);\n \tdefault:\n \t  break;\n \t}\n@@ -7572,7 +8012,8 @@ value_format (dw_attr_ref a)\n     case dw_val_class_fde_ref:\n       return DW_FORM_data;\n     case dw_val_class_lbl_id:\n-      return DW_FORM_addr;\n+      return (AT_index (a) == NOT_INDEXED\n+              ? DW_FORM_addr : DW_FORM_GNU_addr_index);\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n       return dwarf_version >= 4 ? DW_FORM_sec_offset : DW_FORM_data;\n@@ -7624,40 +8065,46 @@ output_value_format (dw_attr_ref a)\n   dw2_asm_output_data_uleb128 (form, \"(%s)\", dwarf_form_name (form));\n }\n \n-/* Output the .debug_abbrev section which defines the DIE abbreviation\n-   table.  */\n+/* Given a die and id, produce the appropriate abbreviations.  */\n \n static void\n-output_abbrev_section (void)\n+output_die_abbrevs (unsigned long abbrev_id, dw_die_ref abbrev)\n {\n-  unsigned long abbrev_id;\n+  unsigned ix;\n+  dw_attr_ref a_attr;\n \n-  for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n+  dw2_asm_output_data_uleb128 (abbrev_id, \"(abbrev code)\");\n+  dw2_asm_output_data_uleb128 (abbrev->die_tag, \"(TAG: %s)\",\n+                               dwarf_tag_name (abbrev->die_tag));\n+\n+  if (abbrev->die_child != NULL)\n+    dw2_asm_output_data (1, DW_children_yes, \"DW_children_yes\");\n+  else\n+    dw2_asm_output_data (1, DW_children_no, \"DW_children_no\");\n+\n+  for (ix = 0; VEC_iterate (dw_attr_node, abbrev->die_attr, ix, a_attr);\n+       ix++)\n     {\n-      dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n-      unsigned ix;\n-      dw_attr_ref a_attr;\n+      dw2_asm_output_data_uleb128 (a_attr->dw_attr, \"(%s)\",\n+                                   dwarf_attr_name (a_attr->dw_attr));\n+      output_value_format (a_attr);\n+    }\n \n-      dw2_asm_output_data_uleb128 (abbrev_id, \"(abbrev code)\");\n-      dw2_asm_output_data_uleb128 (abbrev->die_tag, \"(TAG: %s)\",\n-\t\t\t\t   dwarf_tag_name (abbrev->die_tag));\n+  dw2_asm_output_data (1, 0, NULL);\n+  dw2_asm_output_data (1, 0, NULL);\n+}\n \n-      if (abbrev->die_child != NULL)\n-\tdw2_asm_output_data (1, DW_children_yes, \"DW_children_yes\");\n-      else\n-\tdw2_asm_output_data (1, DW_children_no, \"DW_children_no\");\n \n-      for (ix = 0; VEC_iterate (dw_attr_node, abbrev->die_attr, ix, a_attr);\n-\t   ix++)\n-\t{\n-\t  dw2_asm_output_data_uleb128 (a_attr->dw_attr, \"(%s)\",\n-\t\t\t\t       dwarf_attr_name (a_attr->dw_attr));\n-\t  output_value_format (a_attr);\n-\t}\n+/* Output the .debug_abbrev section which defines the DIE abbreviation\n+   table.  */\n \n-      dw2_asm_output_data (1, 0, NULL);\n-      dw2_asm_output_data (1, 0, NULL);\n-    }\n+static void\n+output_abbrev_section (void)\n+{\n+  unsigned long abbrev_id;\n+\n+  for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n+    output_die_abbrevs (abbrev_id, abbrev_die_table[abbrev_id]);\n \n   /* Terminate the table.  */\n   dw2_asm_output_data (1, 0, NULL);\n@@ -7694,6 +8141,7 @@ new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,\n   dw_loc_list_ref retlist = ggc_alloc_cleared_dw_loc_list_node ();\n \n   retlist->begin = begin;\n+  retlist->begin_entry = NULL;\n   retlist->end = end;\n   retlist->expr = expr;\n   retlist->section = section;\n@@ -7738,7 +8186,22 @@ output_loc_list (dw_loc_list_ref list_head)\n \t in a single range are unlikely very useful.  */\n       if (size > 0xffff)\n \tcontinue;\n-      if (!have_multiple_function_sections)\n+      if (dwarf_split_debug_info)\n+        {\n+          dw2_asm_output_data (1, DW_LLE_GNU_start_length_entry,\n+                               \"Location list start/length entry (%s)\",\n+                               list_head->ll_symbol);\n+          dw2_asm_output_data_uleb128 (curr->begin_entry->index,\n+                                       \"Location list range start index (%s)\",\n+                                       curr->begin);\n+          /* The length field is 4 bytes.  If we ever need to support\n+            an 8-byte length, we can add a new DW_LLE code or fall back\n+            to DW_LLE_GNU_start_end_entry.  */\n+          dw2_asm_output_delta (4, curr->end, curr->begin,\n+                                \"Location list range length (%s)\",\n+                                list_head->ll_symbol);\n+        }\n+      else if (!have_multiple_function_sections)\n \t{\n \t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr->begin, curr->section,\n \t\t\t\t\"Location list begin address (%s)\",\n@@ -7764,12 +8227,86 @@ output_loc_list (dw_loc_list_ref list_head)\n       output_loc_sequence (curr->expr, -1);\n     }\n \n-  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n-\t\t       \"Location list terminator begin (%s)\",\n-\t\t       list_head->ll_symbol);\n-  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n-\t\t       \"Location list terminator end (%s)\",\n-\t\t       list_head->ll_symbol);\n+  if (dwarf_split_debug_info)\n+    dw2_asm_output_data (1, DW_LLE_GNU_end_of_list_entry,\n+                         \"Location list terminator (%s)\",\n+                         list_head->ll_symbol);\n+  else\n+    {\n+      dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n+                           \"Location list terminator begin (%s)\",\n+                           list_head->ll_symbol);\n+      dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n+                           \"Location list terminator end (%s)\",\n+                           list_head->ll_symbol);\n+    }\n+}\n+\n+/* Output a range_list offset into the debug_range section.  Emit a\n+   relocated reference if val_entry is NULL, otherwise, emit an\n+   indirect reference.  */\n+\n+static void\n+output_range_list_offset (dw_attr_ref a)\n+{\n+  const char *name = dwarf_attr_name (a->dw_attr);\n+\n+  if (a->dw_attr_val.val_entry == RELOCATED_OFFSET)\n+    {\n+      char *p = strchr (ranges_section_label, '\\0');\n+      sprintf (p, \"+\" HOST_WIDE_INT_PRINT_HEX, a->dw_attr_val.v.val_offset);\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE, ranges_section_label,\n+                             debug_ranges_section, \"%s\", name);\n+      *p = '\\0';\n+    }\n+  else\n+    dw2_asm_output_data (DWARF_OFFSET_SIZE, a->dw_attr_val.v.val_offset,\n+                         \"%s (offset from %s)\", name, ranges_section_label);\n+}\n+\n+/* Output the offset into the debug_loc section.  */\n+\n+static void\n+output_loc_list_offset (dw_attr_ref a)\n+{\n+  char *sym = AT_loc_list (a)->ll_symbol;\n+\n+  gcc_assert (sym);\n+  if (dwarf_split_debug_info)\n+    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,\n+                          \"%s\", dwarf_attr_name (a->dw_attr));\n+  else\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,\n+                           \"%s\", dwarf_attr_name (a->dw_attr));\n+}\n+\n+/* Output an attribute's index or value appropriately.  */\n+\n+static void\n+output_attr_index_or_value (dw_attr_ref a)\n+{\n+  const char *name = dwarf_attr_name (a->dw_attr);\n+\n+  if (dwarf_split_debug_info && AT_index (a) != NOT_INDEXED)\n+    {\n+      dw2_asm_output_data_uleb128 (AT_index (a), \"%s\", name);\n+      return;\n+    }\n+  switch (AT_class (a))\n+    {\n+      case dw_val_class_addr:\n+        dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), \"%s\", name);\n+        break;\n+      case dw_val_class_high_pc:\n+      case dw_val_class_lbl_id:\n+        dw2_asm_output_addr (DWARF2_ADDR_SIZE, AT_lbl (a), \"%s\", name);\n+        break;\n+      case dw_val_class_loc_list:\n+        output_loc_list_offset (a);\n+        break;\n+      default:\n+        gcc_unreachable ();\n+    }\n }\n \n /* Output a type signature.  */\n@@ -7810,7 +8347,7 @@ output_die (dw_die_ref die)\n       switch (AT_class (a))\n \t{\n \tcase dw_val_class_addr:\n-\t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), \"%s\", name);\n+          output_attr_index_or_value (a);\n \t  break;\n \n \tcase dw_val_class_offset:\n@@ -7819,15 +8356,7 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_range_list:\n-\t  {\n-\t    char *p = strchr (ranges_section_label, '\\0');\n-\n-\t    sprintf (p, \"+\" HOST_WIDE_INT_PRINT_HEX,\n-\t\t     a->dw_attr_val.v.val_offset);\n-\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, ranges_section_label,\n-\t\t\t\t   debug_ranges_section, \"%s\", name);\n-\t    *p = '\\0';\n-\t  }\n+          output_range_list_offset (a);\n \t  break;\n \n \tcase dw_val_class_loc:\n@@ -7883,7 +8412,7 @@ output_die (dw_die_ref die)\n \t      }\n \n \t    dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,\n-\t\t\t\t first, name);\n+                                 first, \"%s\", name);\n \t    dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,\n \t\t\t\t second, NULL);\n \t  }\n@@ -7930,13 +8459,7 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_loc_list:\n-\t  {\n-\t    char *sym = AT_loc_list (a)->ll_symbol;\n-\n-\t    gcc_assert (sym);\n-\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,\n-\t\t\t\t   \"%s\", name);\n-\t  }\n+          output_attr_index_or_value (a);\n \t  break;\n \n \tcase dw_val_class_die_ref:\n@@ -7993,7 +8516,7 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_lbl_id:\n-\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, AT_lbl (a), \"%s\", name);\n+          output_attr_index_or_value (a);\n \t  break;\n \n \tcase dw_val_class_lineptr:\n@@ -8007,12 +8530,15 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_str:\n-\t  if (AT_string_form (a) == DW_FORM_strp)\n-\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n-\t\t\t\t   a->dw_attr_val.v.val_str->label,\n-\t\t\t\t   debug_str_section,\n-\t\t\t\t   \"%s: \\\"%s\\\"\", name, AT_string (a));\n-\t  else\n+          if (a->dw_attr_val.v.val_str->form == DW_FORM_strp)\n+            dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+                                   a->dw_attr_val.v.val_str->label,\n+                                   debug_str_section,\n+                                   \"%s: \\\"%s\\\"\", name, AT_string (a));\n+          else if (a->dw_attr_val.v.val_str->form == DW_FORM_GNU_str_index)\n+            dw2_asm_output_data_uleb128 (AT_index (a),\n+                                         \"%s: \\\"%s\\\"\", name, AT_string (a));\n+          else\n \t    dw2_asm_output_nstring (AT_string (a), -1, \"%s\", name);\n \t  break;\n \n@@ -8155,6 +8681,96 @@ add_AT_pubnames (dw_die_ref die)\n     add_AT_flag (die, DW_AT_GNU_pubnames, 1);\n }\n \n+/* Helper function to generate top-level dies for skeleton debug_info and\n+   debug_types.  */\n+\n+static void\n+add_top_level_skeleton_die_attrs (dw_die_ref die)\n+{\n+  const char *dwo_file_name = concat (aux_base_name, \".dwo\", NULL);\n+  dw_attr_ref attr;\n+\n+  add_comp_dir_attribute (die);\n+  add_AT_string (die, DW_AT_GNU_dwo_name, dwo_file_name);\n+  /* The specification suggests that these attributes be inline to avoid\n+     having a .debug_str section.  We know that they exist in the die because\n+     we just added them.  */\n+  attr = get_AT (die, DW_AT_GNU_dwo_name);\n+  attr->dw_attr_val.v.val_str->form = DW_FORM_string;\n+  attr = get_AT (die, DW_AT_comp_dir);\n+  attr->dw_attr_val.v.val_str->form = DW_FORM_string;\n+\n+  add_AT_pubnames (die);\n+  add_AT_lineptr (die, DW_AT_GNU_addr_base, debug_addr_section_label);\n+}\n+\n+/* Return the single type-unit die for skeleton type units.  */\n+\n+static dw_die_ref\n+get_skeleton_type_unit (void)\n+{\n+  /* For dwarf_split_debug_sections with use_type info, all type units in the\n+     skeleton sections have identical dies (but different headers).  This\n+     single die will be output many times.  */\n+\n+  static dw_die_ref skeleton_type_unit = NULL;\n+\n+  if (skeleton_type_unit == NULL)\n+    {\n+      skeleton_type_unit = new_die (DW_TAG_type_unit, NULL, NULL);\n+      add_top_level_skeleton_die_attrs (skeleton_type_unit);\n+      skeleton_type_unit->die_abbrev = SKELETON_TYPE_DIE_ABBREV;\n+    }\n+  return skeleton_type_unit;\n+}\n+\n+/* Output skeleton debug sections that point to the dwo file.  */\n+\n+static void\n+output_skeleton_debug_sections (dw_die_ref comp_unit)\n+{\n+  /* These attributes will be found in the full debug_info section.  */\n+  remove_AT (comp_unit, DW_AT_producer);\n+  remove_AT (comp_unit, DW_AT_language);\n+\n+  /* Add attributes common to skeleton compile_units and type_units.  */\n+  add_top_level_skeleton_die_attrs (comp_unit);\n+\n+  switch_to_section (debug_skeleton_info_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_info_section_label);\n+\n+  /* Produce the skeleton compilation-unit header.  This one differs enough from\n+     a normal CU header that it's better not to call output_compilation_unit\n+     header.  */\n+  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+    dw2_asm_output_data (4, 0xffffffff,\n+      \"Initial length escape value indicating 64-bit DWARF extension\");\n+\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+                       DWARF_COMPILE_UNIT_HEADER_SIZE\n+                       - DWARF_INITIAL_LENGTH_SIZE\n+                       + size_of_die (comp_unit),\n+                      \"Length of Compilation Unit Info\");\n+  dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n+  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_abbrev_section_label,\n+                         debug_abbrev_section,\n+                         \"Offset Into Abbrev. Section\");\n+  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n+\n+  comp_unit->die_abbrev = SKELETON_COMP_DIE_ABBREV;\n+  output_die (comp_unit);\n+\n+  /* Build the skeleton debug_abbrev section.  */\n+  switch_to_section (debug_skeleton_abbrev_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_abbrev_section_label);\n+\n+  output_die_abbrevs (SKELETON_COMP_DIE_ABBREV, comp_unit);\n+  if (use_debug_types)\n+    output_die_abbrevs (SKELETON_TYPE_DIE_ABBREV, get_skeleton_type_unit ());\n+\n+  dw2_asm_output_data (1, 0, \"end of skeleton .debug_abbrev\");\n+}\n+\n /* Output a comdat type unit DIE and its children.  */\n \n static void\n@@ -8182,7 +8798,11 @@ output_comdat_type_unit (comdat_type_node *node)\n   calc_die_sizes (node->root_die);\n \n #if defined (OBJECT_FORMAT_ELF)\n-  secname = \".debug_types\";\n+  if (!dwarf_split_debug_info)\n+    secname = \".debug_types\";\n+  else\n+    secname = \".debug_types.dwo\";\n+\n   tmp = XALLOCAVEC (char, 4 + DWARF_TYPE_SIGNATURE_SIZE * 2);\n   sprintf (tmp, \"wt.\");\n   for (i = 0; i < DWARF_TYPE_SIGNATURE_SIZE; i++)\n@@ -8208,6 +8828,36 @@ output_comdat_type_unit (comdat_type_node *node)\n   output_die (node->root_die);\n \n   unmark_dies (node->root_die);\n+\n+  if (dwarf_split_debug_info)\n+    {\n+      /* Produce the skeleton type-unit header.  */\n+      const char *secname = \".debug_types\";\n+\n+      targetm.asm_out.named_section (secname,\n+                                     SECTION_DEBUG | SECTION_LINKONCE,\n+                                     comdat_key);\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+        dw2_asm_output_data (4, 0xffffffff,\n+          \"Initial length escape value indicating 64-bit DWARF extension\");\n+\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+                           DWARF_COMPILE_UNIT_HEADER_SIZE\n+                           - DWARF_INITIAL_LENGTH_SIZE\n+                           + size_of_die (get_skeleton_type_unit ())\n+                           + DWARF_TYPE_SIGNATURE_SIZE + DWARF_OFFSET_SIZE,\n+                           \"Length of Type Unit Info\");\n+      dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+                             debug_skeleton_abbrev_section_label,\n+                             debug_abbrev_section,\n+                             \"Offset Into Abbrev. Section\");\n+      dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n+      output_signature (node->signature, \"Type Signature\");\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, \"Offset to Type DIE\");\n+\n+      output_die (get_skeleton_type_unit ());\n+    }\n }\n \n /* Return the DWARF2/3 pubname associated with a decl.  */\n@@ -8243,7 +8893,7 @@ add_pubname (tree decl, dw_die_ref die)\n      class_member, it will either be inside the class already, or will have just\n      looked up the class to find the member.  Either way, searching the class is\n      faster than searching the index.  */\n-  if ((TREE_PUBLIC (decl) && !is_class_die (die->die_parent))\n+  if ((TREE_PUBLIC (decl) && !class_scope_p (die->die_parent))\n       || is_cu_die (die->die_parent) || is_namespace_die (die->die_parent))\n     {\n       const char *name = dwarf2_name (decl, 1);\n@@ -8351,9 +9001,14 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n \t\t\t \"Length of Public Type Names Info\");\n   /* Version number for pubnames/pubtypes is still 2, even in DWARF3.  */\n   dw2_asm_output_data (2, 2, \"DWARF Version\");\n-  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n-\t\t\t debug_info_section,\n-\t\t\t \"Offset of Compilation Unit Info\");\n+  if (dwarf_split_debug_info)\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,\n+                           debug_skeleton_info_section,\n+                           \"Offset of Compilation Unit Info\");\n+  else\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+                           debug_info_section,\n+                           \"Offset of Compilation Unit Info\");\n   dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,\n \t\t       \"Compilation Unit Length\");\n \n@@ -8414,9 +9069,14 @@ output_aranges (unsigned long aranges_length)\n \t\t       \"Length of Address Ranges Info\");\n   /* Version number for aranges is still 2, even in DWARF3.  */\n   dw2_asm_output_data (2, 2, \"DWARF Version\");\n-  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n-\t\t\t debug_info_section,\n-\t\t\t \"Offset of Compilation Unit Info\");\n+  if (dwarf_split_debug_info)\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,\n+                           debug_skeleton_info_section,\n+                           \"Offset of Compilation Unit Info\");\n+  else\n+    dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+                           debug_info_section,\n+                           \"Offset of Compilation Unit Info\");\n   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Size of Address\");\n   dw2_asm_output_data (1, 0, \"Size of Segment Descriptor\");\n \n@@ -8513,12 +9173,14 @@ add_ranges (const_tree block)\n   return add_ranges_num (block ? BLOCK_NUMBER (block) : 0);\n }\n \n-/* Add a new entry to .debug_ranges corresponding to a pair of\n-   labels.  */\n+/* Add a new entry to .debug_ranges corresponding to a pair of labels.\n+   When using dwarf_split_debug_info, address attributes in dies destined\n+   for the final executable should be direct references--setting the\n+   parameter force_direct ensures this behavior.  */\n \n static void\n add_ranges_by_labels (dw_die_ref die, const char *begin, const char *end,\n-\t\t      bool *added)\n+                      bool *added, bool force_direct)\n {\n   unsigned int in_use = ranges_by_label_in_use;\n   unsigned int offset;\n@@ -8541,7 +9203,7 @@ add_ranges_by_labels (dw_die_ref die, const char *begin, const char *end,\n   offset = add_ranges_num (-(int)in_use - 1);\n   if (!*added)\n     {\n-      add_AT_range_list (die, DW_AT_ranges, offset);\n+      add_AT_range_list (die, DW_AT_ranges, offset, force_direct);\n       *added = true;\n     }\n }\n@@ -9078,7 +9740,7 @@ output_one_line_info_table (dw_line_info_table *table)\n    information goes into the .debug_line section.  */\n \n static void\n-output_line_info (void)\n+output_line_info (bool prologue_only)\n {\n   char l1[20], l2[20], p1[20], p2[20];\n   int ver = dwarf_version;\n@@ -9148,6 +9810,12 @@ output_line_info (void)\n   /* Write out the information about the files we use.  */\n   output_file_names ();\n   ASM_OUTPUT_LABEL (asm_out_file, p2);\n+  if (prologue_only)\n+    {\n+      /* Output the marker for the end of the line number info.  */\n+      ASM_OUTPUT_LABEL (asm_out_file, l2);\n+      return;\n+    }\n \n   if (separate_line_info)\n     {\n@@ -11452,14 +12120,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)\n \t    break;\n \n-\t  /* We used to emit DW_OP_addr here, but that's wrong, since\n-\t     DW_OP_addr should be relocated by the debug info consumer,\n-\t     while DW_OP_GNU_push_tls_address operand should not.  */\n-\t  temp = new_loc_descr (DWARF2_ADDR_SIZE == 4\n-\t\t\t\t? DW_OP_const4u : DW_OP_const8u, 0, 0);\n-\t  temp->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-\t  temp->dw_loc_oprnd1.v.val_addr = rtl;\n-\t  temp->dtprel = true;\n+          temp = new_addr_loc_descr (rtl, dtprel_true);\n \n \t  mem_loc_result = new_loc_descr (DW_OP_GNU_push_tls_address, 0, 0);\n \t  add_loc_descr (&mem_loc_result, temp);\n@@ -11471,9 +12132,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \tbreak;\n \n     symref:\n-      mem_loc_result = new_loc_descr (DW_OP_addr, 0, 0);\n-      mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-      mem_loc_result->dw_loc_oprnd1.v.val_addr = rtl;\n+      mem_loc_result = new_addr_loc_descr (rtl, dtprel_false);\n       VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n       break;\n \n@@ -12377,9 +13036,7 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n       if (mode != VOIDmode && GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE\n \t  && (dwarf_version >= 4 || !dwarf_strict))\n \t{\n-\t  loc_result = new_loc_descr (DW_OP_addr, 0, 0);\n-\t  loc_result->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-\t  loc_result->dw_loc_oprnd1.v.val_addr = rtl;\n+         loc_result = new_addr_loc_descr (rtl, dtprel_false);\n \t  add_loc_descr (&loc_result, new_loc_descr (DW_OP_stack_value, 0, 0));\n \t  VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n \t}\n@@ -13079,9 +13736,8 @@ loc_list_from_tree (tree loc, int want_address)\n       if (DECL_THREAD_LOCAL_P (loc))\n \t{\n \t  rtx rtl;\n-\t  enum dwarf_location_atom first_op;\n-\t  enum dwarf_location_atom second_op;\n-\t  bool dtprel = false;\n+         enum dwarf_location_atom tls_op;\n+         enum dtprel_bool dtprel = dtprel_false;\n \n \t  if (targetm.have_tls)\n \t    {\n@@ -13098,9 +13754,8 @@ loc_list_from_tree (tree loc, int want_address)\n \t\t  operand shouldn't be.  */\n \t      if (DECL_EXTERNAL (loc) && !targetm.binds_local_p (loc))\n \t\treturn 0;\n-\t      first_op = DWARF2_ADDR_SIZE == 4 ? DW_OP_const4u : DW_OP_const8u;\n-\t      dtprel = true;\n-\t      second_op = DW_OP_GNU_push_tls_address;\n+             dtprel = dtprel_true;\n+             tls_op = DW_OP_GNU_push_tls_address;\n \t    }\n \t  else\n \t    {\n@@ -13112,8 +13767,7 @@ loc_list_from_tree (tree loc, int want_address)\n \t\t no longer appear in gimple code.  We used the control\n \t\t variable in specific so that we could pick it up here.  */\n \t      loc = DECL_VALUE_EXPR (loc);\n-\t      first_op = DW_OP_addr;\n-\t      second_op = DW_OP_form_tls_address;\n+              tls_op = DW_OP_form_tls_address;\n \t    }\n \n \t  rtl = rtl_for_decl_location (loc);\n@@ -13126,12 +13780,8 @@ loc_list_from_tree (tree loc, int want_address)\n \t  if (! CONSTANT_P (rtl))\n \t    return 0;\n \n-\t  ret = new_loc_descr (first_op, 0, 0);\n-\t  ret->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-\t  ret->dw_loc_oprnd1.v.val_addr = rtl;\n-\t  ret->dtprel = dtprel;\n-\n-\t  ret1 = new_loc_descr (second_op, 0, 0);\n+          ret = new_addr_loc_descr (rtl, dtprel);\n+          ret1 = new_loc_descr (tls_op, 0, 0);\n \t  add_loc_descr (&ret, ret1);\n \n \t  have_address = 1;\n@@ -13176,11 +13826,7 @@ loc_list_from_tree (tree loc, int want_address)\n \t    return 0;\n \t  }\n \telse if (CONSTANT_P (rtl) && const_ok_for_output (rtl))\n-\t  {\n-\t    ret = new_loc_descr (DW_OP_addr, 0, 0);\n-\t    ret->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-\t    ret->dw_loc_oprnd1.v.val_addr = rtl;\n-\t  }\n+          ret = new_addr_loc_descr (rtl, dtprel_false);\n \telse\n \t  {\n \t    enum machine_mode mode, mem_mode;\n@@ -14105,9 +14751,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t  dw_loc_descr_ref loc_result;\n \t  resolve_one_addr (&rtl, NULL);\n \trtl_addr:\n-\t  loc_result = new_loc_descr (DW_OP_addr, 0, 0);\n-\t  loc_result->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-\t  loc_result->dw_loc_oprnd1.v.val_addr = rtl;\n+          loc_result = new_addr_loc_descr (rtl, dtprel_false);\n \t  add_loc_descr (&loc_result, new_loc_descr (DW_OP_stack_value, 0, 0));\n \t  add_AT_loc (die, DW_AT_location, loc_result);\n \t  VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n@@ -15627,7 +16271,7 @@ add_name_and_src_coords_attributes (dw_die_ref die, tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))\n     {\n       add_AT_addr (die, DW_AT_VMS_rtnbeg_pd_address,\n-\t\t   XEXP (DECL_RTL (decl), 0));\n+                  XEXP (DECL_RTL (decl), 0), false);\n       VEC_safe_push (rtx, gc, used_rtx_array, XEXP (DECL_RTL (decl), 0));\n     }\n #endif /* VMS_DEBUGGING_INFO */\n@@ -16896,7 +17540,7 @@ gen_call_site_die (tree decl, dw_die_ref subr_die,\n       if (tdie)\n \tadd_AT_die_ref (die, DW_AT_abstract_origin, tdie);\n       else\n-\tadd_AT_addr (die, DW_AT_abstract_origin, ca_loc->symbol_ref);\n+        add_AT_addr (die, DW_AT_abstract_origin, ca_loc->symbol_ref, false);\n     }\n   return die;\n }\n@@ -17089,7 +17733,8 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  if (fde->dw_fde_begin)\n \t    {\n \t      /* We have already generated the labels.  */\n-\t      add_AT_low_high_pc (subr_die, fde->dw_fde_begin, fde->dw_fde_end);\n+             add_AT_low_high_pc (subr_die, fde->dw_fde_begin,\n+                                 fde->dw_fde_end, false);\n \t    }\n \t  else\n \t    {\n@@ -17100,7 +17745,8 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t\t\t\t   current_function_funcdef_no);\n \t      ASM_GENERATE_INTERNAL_LABEL (label_id_high, FUNC_END_LABEL,\n \t\t\t\t\t   current_function_funcdef_no);\n-\t      add_AT_low_high_pc (subr_die, label_id_low, label_id_high);\n+             add_AT_low_high_pc (subr_die, label_id_low, label_id_high,\n+                                 false);\n \t    }\n \n #if VMS_DEBUGGING_INFO\n@@ -17143,10 +17789,11 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t     alignment offset.  */\n \t\t  bool range_list_added = false;\n \t\t  add_ranges_by_labels (subr_die, fde->dw_fde_begin,\n-\t\t\t\t\tfde->dw_fde_end, &range_list_added);\n+                                        fde->dw_fde_end, &range_list_added,\n+                                        false);\n \t\t  add_ranges_by_labels (subr_die, fde->dw_fde_second_begin,\n \t\t\t\t\tfde->dw_fde_second_end,\n-\t\t\t\t\t&range_list_added);\n+                                       &range_list_added, false);\n \t\t  if (range_list_added)\n \t\t    add_ranges (NULL);\n \t\t}\n@@ -17165,7 +17812,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n \t\t  /* Do the 'primary' section.   */\n \t\t  add_AT_low_high_pc (subr_die, fde->dw_fde_begin,\n-\t\t\t\t      fde->dw_fde_end);\n+                                      fde->dw_fde_end, false);\n \n \t\t  /* Build a minimal DIE for the secondary section.  */\n \t\t  seg_die = new_die (DW_TAG_subprogram,\n@@ -17190,14 +17837,15 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n \t\t  name = concat (\"__second_sect_of_\", name, NULL); \n \t\t  add_AT_low_high_pc (seg_die, fde->dw_fde_second_begin,\n-\t\t\t\t      fde->dw_fde_second_end);\n+                                      fde->dw_fde_second_end, false);\n \t\t  add_name_attribute (seg_die, name);\n \t\t  if (want_pubnames ())\n \t\t    add_pubname_string (name, seg_die);\n \t\t}\n \t    }\n \t  else\n-\t    add_AT_low_high_pc (subr_die, fde->dw_fde_begin, fde->dw_fde_end);\n+           add_AT_low_high_pc (subr_die, fde->dw_fde_begin, fde->dw_fde_end,\n+                               false);\n \t}\n \n       cfa_fb_offset = CFA_FRAME_BASE_OFFSET (decl);\n@@ -17638,7 +18286,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t    {\n \t      /* Optimize the common case.  */\n \t      if (single_element_loc_list_p (loc)\n-\t\t  && loc->expr->dw_loc_opc == DW_OP_addr\n+                  && loc->expr->dw_loc_opc == DW_OP_addr\n \t\t  && loc->expr->dw_loc_next == NULL\n \t\t  && GET_CODE (loc->expr->dw_loc_oprnd1.v.val_addr) == SYMBOL_REF)\n \t\t{\n@@ -17825,15 +18473,15 @@ gen_label_die (tree decl, dw_die_ref context_die)\n \t  gcc_assert (!INSN_DELETED_P (insn));\n \n \t  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (insn));\n-\t  add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);\n+          add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);\n \t}\n       else if (insn\n \t       && NOTE_P (insn)\n \t       && NOTE_KIND (insn) == NOTE_INSN_DELETED_DEBUG_LABEL\n \t       && CODE_LABEL_NUMBER (insn) != -1)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (label, \"LDL\", CODE_LABEL_NUMBER (insn));\n-\t  add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);\n+          add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);\n \t}\n     }\n }\n@@ -17874,7 +18522,7 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,\n \t\t\t\t       BLOCK_NUMBER (stmt));\n-\t  add_AT_lbl_id (die, DW_AT_entry_pc, label);\n+          add_AT_lbl_id (die, DW_AT_entry_pc, label);\n \t}\n \n       /* Optimize duplicate .debug_ranges lists or even tails of\n@@ -17922,12 +18570,13 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t    ++thiscnt;\n \t  gcc_assert (supercnt >= thiscnt);\n \t  add_AT_range_list (die, DW_AT_ranges,\n-\t\t\t     (off + supercnt - thiscnt)\n-\t\t\t     * 2 * DWARF2_ADDR_SIZE);\n+                             ((off + supercnt - thiscnt)\n+                              * 2 * DWARF2_ADDR_SIZE),\n+                             false);\n \t  return;\n \t}\n \n-      add_AT_range_list (die, DW_AT_ranges, add_ranges (stmt));\n+      add_AT_range_list (die, DW_AT_ranges, add_ranges (stmt), false);\n \n       chain = BLOCK_FRAGMENT_CHAIN (stmt);\n       do\n@@ -17945,7 +18594,7 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t\t\t\t   BLOCK_NUMBER (stmt));\n       ASM_GENERATE_INTERNAL_LABEL (label_high, BLOCK_END_LABEL,\n \t\t\t\t   BLOCK_NUMBER (stmt));\n-      add_AT_low_high_pc (die, label, label_high);\n+      add_AT_low_high_pc (die, label, label_high, false);\n     }\n }\n \n@@ -20539,23 +21188,22 @@ output_macinfo_op (macinfo_entry *ref)\n     case DW_MACRO_GNU_define_indirect:\n     case DW_MACRO_GNU_undef_indirect:\n       node = find_AT_string (ref->info);\n-      if (node->form != DW_FORM_strp)\n-\t{\n-\t  char label[32];\n-\t  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n-\t  ++dw2_string_counter;\n-\t  node->label = xstrdup (label);\n-\t  node->form = DW_FORM_strp;\n-\t}\n+      gcc_assert (node\n+                  && ((node->form == DW_FORM_strp)\n+                      || (node->form == DW_FORM_GNU_str_index)));\n       dw2_asm_output_data (1, ref->code,\n \t\t\t   ref->code == DW_MACRO_GNU_define_indirect\n \t\t\t   ? \"Define macro indirect\"\n \t\t\t   : \"Undefine macro indirect\");\n       dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\",\n \t\t\t\t   (unsigned long) ref->lineno);\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE, node->label,\n-\t\t\t     debug_str_section, \"The macro: \\\"%s\\\"\",\n-\t\t\t     ref->info);\n+      if (node->form == DW_FORM_strp)\n+        dw2_asm_output_offset (DWARF_OFFSET_SIZE, node->label,\n+                               debug_str_section, \"The macro: \\\"%s\\\"\",\n+                               ref->info);\n+      else\n+        dw2_asm_output_data_uleb128 (node->index, \"The macro: \\\"%s\\\"\",\n+                                     ref->info);\n       break;\n     case DW_MACRO_GNU_transparent_include:\n       dw2_asm_output_data (1, ref->code, \"Transparent include\");\n@@ -20698,6 +21346,42 @@ optimize_macinfo_range (unsigned int idx, VEC (macinfo_entry, gc) *files,\n   return count;\n }\n \n+/* Save any strings needed by the macinfo table in the debug str\n+   table.  All strings must be collected into the table by the time\n+   index_string is called.  */\n+\n+static void\n+save_macinfo_strings (void)\n+{\n+  unsigned len;\n+  unsigned i;\n+  macinfo_entry *ref;\n+\n+  for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n+    {\n+      switch (ref->code)\n+        {\n+          /* Match the logic in output_macinfo_op to decide on\n+             indirect strings.  */\n+          case DW_MACINFO_define:\n+          case DW_MACINFO_undef:\n+            len = strlen (ref->info) + 1;\n+            if (!dwarf_strict\n+                && len > DWARF_OFFSET_SIZE\n+                && !DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET\n+                && (debug_str_section->common.flags & SECTION_MERGE) != 0)\n+              set_indirect_string (find_AT_string (ref->info));\n+            break;\n+          case DW_MACRO_GNU_define_indirect:\n+          case DW_MACRO_GNU_undef_indirect:\n+            set_indirect_string (find_AT_string (ref->info));\n+            break;\n+          default:\n+            break;\n+        }\n+    }\n+}\n+\n /* Output macinfo section(s).  */\n \n static void\n@@ -20726,8 +21410,10 @@ output_macinfo (void)\n \tdw2_asm_output_data (1, 3, \"Flags: 64-bit, lineptr present\");\n       else\n \tdw2_asm_output_data (1, 2, \"Flags: 32-bit, lineptr present\");\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_line_section_label,\n-\t\t\t     debug_line_section, NULL);\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+                             (!dwarf_split_debug_info ? debug_line_section_label\n+                              : debug_skeleton_line_section_label),\n+                             debug_line_section, NULL);\n     }\n \n   /* In the first loop, it emits the primary .debug_macinfo section\n@@ -20866,20 +21552,54 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \n   used_rtx_array = VEC_alloc (rtx, gc, 32);\n \n-  debug_info_section = get_section (DEBUG_INFO_SECTION,\n-\t\t\t\t    SECTION_DEBUG, NULL);\n-  debug_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n-\t\t\t\t      SECTION_DEBUG, NULL);\n+  if (!dwarf_split_debug_info)\n+    {\n+      debug_info_section = get_section (DEBUG_INFO_SECTION,\n+                                        SECTION_DEBUG, NULL);\n+      debug_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n+                                          SECTION_DEBUG, NULL);\n+      debug_loc_section = get_section (DEBUG_LOC_SECTION,\n+                                       SECTION_DEBUG, NULL);\n+    }\n+  else\n+    {\n+      debug_info_section = get_section (DEBUG_DWO_INFO_SECTION,\n+                                        SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+      debug_abbrev_section = get_section (DEBUG_DWO_ABBREV_SECTION,\n+                                          SECTION_DEBUG | SECTION_EXCLUDE,\n+                                          NULL);\n+      debug_addr_section = get_section (DEBUG_ADDR_SECTION,\n+                                        SECTION_DEBUG, NULL);\n+      debug_skeleton_info_section = get_section (DEBUG_INFO_SECTION,\n+                                                 SECTION_DEBUG, NULL);\n+      debug_skeleton_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n+                                                   SECTION_DEBUG, NULL);\n+      ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_abbrev_section_label,\n+                                  DEBUG_SKELETON_ABBREV_SECTION_LABEL, 0);\n+\n+      /* Somewhat confusing detail: The skeleton_[abbrev|info] sections stay in\n+         the main .o, but the skeleton_line goes into the split off dwo.  */\n+      debug_skeleton_line_section\n+          = get_section (DEBUG_DWO_LINE_SECTION,\n+                         SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+      ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,\n+                                   DEBUG_SKELETON_LINE_SECTION_LABEL, 0);\n+      debug_str_offsets_section = get_section (DEBUG_STR_OFFSETS_SECTION,\n+                                               SECTION_DEBUG | SECTION_EXCLUDE,\n+                                               NULL);\n+      ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,\n+                                   DEBUG_SKELETON_INFO_SECTION_LABEL, 0);\n+      debug_loc_section = get_section (DEBUG_DWO_LOC_SECTION,\n+                                       SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+    }\n   debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,\n \t\t\t\t       SECTION_DEBUG, NULL);\n   debug_macinfo_section = get_section (dwarf_strict\n \t\t\t\t       ? DEBUG_MACINFO_SECTION\n \t\t\t\t       : DEBUG_MACRO_SECTION,\n-\t\t\t\t       SECTION_DEBUG, NULL);\n+                                       DEBUG_MACRO_SECTION_FLAGS, NULL);\n   debug_line_section = get_section (DEBUG_LINE_SECTION,\n \t\t\t\t    SECTION_DEBUG, NULL);\n-  debug_loc_section = get_section (DEBUG_LOC_SECTION,\n-\t\t\t\t   SECTION_DEBUG, NULL);\n   debug_pubnames_section = get_section (DEBUG_PUBNAMES_SECTION,\n \t\t\t\t\tSECTION_DEBUG, NULL);\n   debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,\n@@ -20905,10 +21625,13 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t\t       DEBUG_LINE_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,\n \t\t\t       DEBUG_RANGES_SECTION_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (debug_addr_section_label,\n+                               DEBUG_ADDR_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n \t\t\t       dwarf_strict\n \t\t\t       ? DEBUG_MACINFO_SECTION_LABEL\n \t\t\t       : DEBUG_MACRO_SECTION_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (loc_section_label, DEBUG_LOC_SECTION_LABEL, 0);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     macinfo_table = VEC_alloc (macinfo_entry, gc, 64);\n@@ -20934,6 +21657,71 @@ dwarf2out_assembly_start (void)\n     fprintf (asm_out_file, \"\\t.cfi_sections\\t.debug_frame\\n\");\n }\n \n+/* A helper function for dwarf2out_finish called through\n+   htab_traverse.  Assign a string its index.  All strings must be\n+   collected into the table by the time index_string is called,\n+   because the indexing code relies on htab_traverse to traverse nodes\n+   in the same order for each run. */\n+\n+static int\n+index_string (void **h, void *v)\n+{\n+  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n+  unsigned int *index = (unsigned int *) v;\n+\n+  find_string_form (node);\n+  if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n+    {\n+      gcc_assert(node->index == NO_INDEX_ASSIGNED);\n+      node->index = *index;\n+      *index += 1;\n+    }\n+  return 1;\n+}\n+\n+/* A helper function for output_indirect_strings called through\n+   htab_traverse.  Output the offset to a string and update the\n+   current offset.  */\n+\n+static int\n+output_index_string_offset (void **h, void *v)\n+{\n+  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n+  unsigned int *offset = (unsigned int *) v;\n+\n+  if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n+    {\n+      /* Assert that this node has been assigned an index.  */\n+      gcc_assert (node->index != NO_INDEX_ASSIGNED\n+                  && node->index != NOT_INDEXED);\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE, *offset,\n+                           \"indexed string 0x%x: %s\", node->index, node->str);\n+      *offset += strlen (node->str) + 1;\n+    }\n+  return 1;\n+}\n+\n+/* A helper function for dwarf2out_finish called through\n+   htab_traverse.  Output the indexed string.  */\n+\n+static int\n+output_index_string (void **h, void *v)\n+{\n+  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n+  unsigned int *cur_idx = (unsigned int *) v;\n+\n+  if (node->form == DW_FORM_GNU_str_index && node->refcount > 0)\n+    {\n+      /* Assert that the strings are output in the same order as their\n+         indexes were assigned.  */\n+      gcc_assert (*cur_idx == node->index);\n+      ASM_OUTPUT_LABEL (asm_out_file, node->label);\n+      assemble_string (node->str, strlen (node->str) + 1);\n+      *cur_idx += 1;\n+    }\n+  return 1;\n+}\n+\n /* A helper function for dwarf2out_finish called through\n    htab_traverse.  Emit one queued .debug_str string.  */\n \n@@ -20942,16 +21730,96 @@ output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)\n {\n   struct indirect_string_node *node = (struct indirect_string_node *) *h;\n \n-  if (node->form == DW_FORM_strp)\n+  if (node->form == DW_FORM_strp && node->refcount > 0)\n     {\n-      switch_to_section (debug_str_section);\n       ASM_OUTPUT_LABEL (asm_out_file, node->label);\n       assemble_string (node->str, strlen (node->str) + 1);\n     }\n \n   return 1;\n }\n \n+/* Output the indexed string table.  */\n+\n+static void\n+output_indirect_strings (void)\n+{\n+  if (!dwarf_split_debug_info)\n+    {\n+      switch_to_section (debug_str_section);\n+      htab_traverse (debug_str_hash, output_indirect_string, NULL);\n+    }\n+  else\n+    {\n+      unsigned int offset = 0;\n+      unsigned int cur_idx = 0;\n+\n+      switch_to_section (debug_str_offsets_section);\n+      htab_traverse_noresize (debug_str_hash,\n+                              output_index_string_offset,\n+                              &offset);\n+      switch_to_section (debug_str_section);\n+      htab_traverse_noresize (debug_str_hash,\n+                              output_index_string,\n+                              &cur_idx);\n+    }\n+}\n+\n+/* Callback for htab_traverse to assign an index to an entry in the\n+   table, and to write that entry to the .debug_addr section.  */\n+\n+static int\n+output_addr_table_entry (void **slot, void *data)\n+{\n+  addr_table_entry *entry = (addr_table_entry *) *slot;\n+  unsigned int *cur_index = (unsigned int *)data;\n+\n+  if (entry->refcount == 0)\n+    {\n+      gcc_assert (entry->index == NO_INDEX_ASSIGNED\n+                  || entry->index == NOT_INDEXED);\n+      return 1;\n+    }\n+\n+  gcc_assert (entry->index == *cur_index);\n+  (*cur_index)++;\n+\n+  switch (entry->kind)\n+    {\n+      case ate_kind_rtx:\n+        dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, entry->addr.rtl,\n+                                 \"0x%x\", entry->index);\n+        break;\n+      case ate_kind_rtx_dtprel:\n+        gcc_assert (targetm.asm_out.output_dwarf_dtprel);\n+        targetm.asm_out.output_dwarf_dtprel (asm_out_file,\n+                                             DWARF2_ADDR_SIZE,\n+                                             entry->addr.rtl);\n+        fputc ('\\n', asm_out_file);\n+        break;\n+      case ate_kind_label:\n+        dw2_asm_output_addr (DWARF2_ADDR_SIZE, entry->addr.label,\n+                                 \"0x%x\", entry->index);\n+        break;\n+      default:\n+        gcc_unreachable ();\n+    }\n+  return 1;\n+}\n+\n+/* Produce the .debug_addr section.  */\n+\n+static void\n+output_addr_table (void)\n+{\n+  unsigned int index = 0;\n+  if (addr_index_table == NULL || htab_size (addr_index_table) == 0)\n+    return;\n+\n+  switch_to_section (debug_addr_section);\n+  htab_traverse_noresize (addr_index_table, output_addr_table_entry, &index);\n+}\n+\n #if ENABLE_ASSERT_CHECKING\n /* Verify that all marks are clear.  */\n \n@@ -21571,6 +22439,16 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n \tif (resolve_one_addr (&loc->dw_loc_oprnd1.v.val_addr, NULL))\n \t  return false;\n \tbreak;\n+      case DW_OP_GNU_addr_index:\n+      case DW_OP_GNU_const_index:\n+        {\n+          if ((loc->dw_loc_opc == DW_OP_GNU_addr_index\n+               || (loc->dw_loc_opc == DW_OP_GNU_const_index && loc->dtprel))\n+              && resolve_one_addr (&loc->dw_loc_oprnd1.val_entry->addr.rtl,\n+                                   NULL))\n+            return false;\n+        }\n+       break;\n       case DW_OP_const4u:\n       case DW_OP_const8u:\n \tif (loc->dtprel\n@@ -21705,11 +22583,15 @@ resolve_addr (dw_die_ref die)\n \t\tif (!resolve_addr_in_expr ((*curr)->expr))\n \t\t  {\n \t\t    dw_loc_list_ref next = (*curr)->dw_loc_next;\n+                    dw_loc_descr_ref l = (*curr)->expr;\n+\n \t\t    if (next && (*curr)->ll_symbol)\n \t\t      {\n \t\t\tgcc_assert (!next->ll_symbol);\n \t\t\tnext->ll_symbol = (*curr)->ll_symbol;\n \t\t      }\n+                    if (dwarf_split_debug_info)\n+                      remove_loc_list_addr_table_entries (l);\n \t\t    *curr = next;\n \t\t  }\n \t\telse\n@@ -21723,6 +22605,8 @@ resolve_addr (dw_die_ref die)\n \t    else\n \t      {\n \t\tloc->replaced = 1;\n+                if (dwarf_split_debug_info)\n+                  remove_loc_list_addr_table_entries (loc->expr);\n \t\tloc->dw_loc_next = *start;\n \t      }\n \t  }\n@@ -21747,6 +22631,8 @@ resolve_addr (dw_die_ref die)\n \t       || l->dw_loc_next != NULL)\n \t      && !resolve_addr_in_expr (l))\n \t    {\n+              if (dwarf_split_debug_info)\n+                remove_loc_list_addr_table_entries (l);\n \t      remove_AT (die, a->dw_attr);\n \t      ix--;\n \t    }\n@@ -21758,6 +22644,8 @@ resolve_addr (dw_die_ref die)\n \tif (a->dw_attr == DW_AT_const_value\n \t    && resolve_one_addr (&a->dw_attr_val.v.val_addr, NULL))\n \t  {\n+            if (AT_index (a) != NOT_INDEXED)\n+              remove_addr_table_entry (a->dw_attr_val.val_entry);\n \t    remove_AT (die, a->dw_attr);\n \t    ix--;\n \t  }\n@@ -21781,6 +22669,8 @@ resolve_addr (dw_die_ref die)\n \t      }\n \t    else\n \t      {\n+                if (AT_index (a) != NOT_INDEXED)\n+                  remove_addr_table_entry (a->dw_attr_val.val_entry);\n \t\tremove_AT (die, a->dw_attr);\n \t\tix--;\n \t      }\n@@ -21914,6 +22804,17 @@ hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n \t}\n       hash = iterative_hash_rtx (val1->v.val_addr, hash);\n       break;\n+    case DW_OP_GNU_addr_index:\n+    case DW_OP_GNU_const_index:\n+      {\n+        if (loc->dtprel)\n+          {\n+            unsigned char dtprel = 0xd1;\n+            hash = iterative_hash_object (dtprel, hash);\n+          }\n+        hash = iterative_hash_rtx (val1->val_entry->addr.rtl, hash);\n+      }\n+      break;\n     case DW_OP_GNU_implicit_pointer:\n       hash = iterative_hash_object (val2->v.val_int, hash);\n       break;\n@@ -22095,9 +22996,12 @@ compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)\n       return valx1->v.val_int == valy1->v.val_int;\n     case DW_OP_skip:\n     case DW_OP_bra:\n+      /* If splitting debug info, the use of DW_OP_GNU_addr_index\n+        can cause irrelevant differences in dw_loc_addr.  */\n       gcc_assert (valx1->val_class == dw_val_class_loc\n \t\t  && valy1->val_class == dw_val_class_loc\n-\t\t  && x->dw_loc_addr == y->dw_loc_addr);\n+                  && (dwarf_split_debug_info\n+                      || x->dw_loc_addr == y->dw_loc_addr));\n       return valx1->v.val_loc->dw_loc_addr == valy1->v.val_loc->dw_loc_addr;\n     case DW_OP_implicit_value:\n       if (valx1->v.val_unsigned != valy1->v.val_unsigned\n@@ -22128,6 +23032,13 @@ compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)\n     case DW_OP_addr:\n     hash_addr:\n       return rtx_equal_p (valx1->v.val_addr, valy1->v.val_addr);\n+    case DW_OP_GNU_addr_index:\n+    case DW_OP_GNU_const_index:\n+      {\n+        rtx ax1 = valx1->val_entry->addr.rtl;\n+        rtx ay1 = valy1->val_entry->addr.rtl;\n+        return rtx_equal_p (ax1, ay1);\n+      }\n     case DW_OP_GNU_implicit_pointer:\n       return valx1->val_class == dw_val_class_die_ref\n \t     && valx1->val_class == valy1->val_class\n@@ -22241,12 +23152,45 @@ optimize_location_lists_1 (dw_die_ref die, htab_t htab)\n \tif (*slot == NULL)\n \t  *slot = (void *) list;\n \telse\n-\t  a->dw_attr_val.v.val_loc_list = (dw_loc_list_ref) *slot;\n+          a->dw_attr_val.v.val_loc_list = (dw_loc_list_ref) *slot;\n       }\n \n   FOR_EACH_CHILD (die, c, optimize_location_lists_1 (c, htab));\n }\n \n+\n+/* Recursively assign each location list a unique index into the debug_addr\n+   section.  */\n+\n+static void\n+index_location_lists (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_attr_ref a;\n+  unsigned ix;\n+\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+    if (AT_class (a) == dw_val_class_loc_list)\n+      {\n+        dw_loc_list_ref list = AT_loc_list (a);\n+        dw_loc_list_ref curr;\n+        for (curr = list; curr != NULL; curr = curr->dw_loc_next)\n+          {\n+            /* Don't index an entry that has already been indexed\n+               or won't be output.  */\n+            if (curr->begin_entry != NULL\n+                || (strcmp (curr->begin, curr->end) == 0 && !curr->force))\n+              continue;\n+\n+            curr->begin_entry\n+                = add_addr_table_entry (xstrdup (curr->begin),\n+                                        ate_kind_label);\n+          }\n+      }\n+\n+  FOR_EACH_CHILD (die, c, index_location_lists (c));\n+}\n+\n /* Optimize location lists referenced from DIE\n    children and share them whenever possible.  */\n \n@@ -22268,6 +23212,7 @@ dwarf2out_finish (const char *filename)\n   comdat_type_node *ctnode;\n   htab_t comdat_type_table;\n   unsigned int i;\n+  dw_die_ref main_comp_unit_die;\n \n   /* PCH might result in DW_AT_producer string being restored from the\n      header compilation, fix it up if needed.  */\n@@ -22420,6 +23365,14 @@ dwarf2out_finish (const char *filename)\n   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n     add_sibling_attributes (ctnode->root_die);\n \n+  /* When splitting DWARF info, we put some attributes in the\n+     skeleton compile_unit DIE that remains in the .o, while\n+     most attributes go in the DWO compile_unit_die.  */\n+  if (dwarf_split_debug_info)\n+    main_comp_unit_die = gen_compile_unit_die (NULL);\n+  else\n+    main_comp_unit_die = comp_unit_die ();\n+\n   /* Output a terminator label for the .text section.  */\n   switch_to_section (text_section);\n   targetm.asm_out.internal_label (asm_out_file, TEXT_END_LABEL, 0);\n@@ -22436,8 +23389,8 @@ dwarf2out_finish (const char *filename)\n     {\n       /* Don't add if the CU has no associated code.  */\n       if (text_section_used)\n-\tadd_AT_low_high_pc (comp_unit_die (), text_section_label,\n-\t\t\t    text_end_label);\n+        add_AT_low_high_pc (main_comp_unit_die, text_section_label,\n+                            text_end_label, true);\n     }\n   else\n     {\n@@ -22446,22 +23399,24 @@ dwarf2out_finish (const char *filename)\n       bool range_list_added = false;\n \n       if (text_section_used)\n-\tadd_ranges_by_labels (comp_unit_die (), text_section_label,\n-\t\t\t      text_end_label, &range_list_added);\n+        add_ranges_by_labels (main_comp_unit_die, text_section_label,\n+                              text_end_label, &range_list_added, true);\n       if (cold_text_section_used)\n-\tadd_ranges_by_labels (comp_unit_die (), cold_text_section_label,\n-\t\t\t      cold_end_label, &range_list_added);\n+        add_ranges_by_labels (main_comp_unit_die, cold_text_section_label,\n+                              cold_end_label, &range_list_added, true);\n \n       FOR_EACH_VEC_ELT (dw_fde_ref, fde_vec, fde_idx, fde)\n \t{\n \t  if (DECL_IGNORED_P (fde->decl))\n \t    continue;\n \t  if (!fde->in_std_section)\n-\t    add_ranges_by_labels (comp_unit_die (), fde->dw_fde_begin,\n-\t\t\t\t  fde->dw_fde_end, &range_list_added);\n+            add_ranges_by_labels (main_comp_unit_die, fde->dw_fde_begin,\n+                                  fde->dw_fde_end, &range_list_added,\n+                                  true);\n \t  if (fde->dw_fde_second_begin && !fde->second_in_std_section)\n-\t    add_ranges_by_labels (comp_unit_die (), fde->dw_fde_second_begin,\n-\t\t\t\t  fde->dw_fde_second_end, &range_list_added);\n+            add_ranges_by_labels (main_comp_unit_die, fde->dw_fde_second_begin,\n+                                  fde->dw_fde_second_end, &range_list_added,\n+                                  true);\n \t}\n \n       if (range_list_added)\n@@ -22471,26 +23426,45 @@ dwarf2out_finish (const char *filename)\n \t     absolute.  Historically, we've emitted the unexpected\n \t     DW_AT_entry_pc instead of DW_AT_low_pc for this purpose.\n \t     Emit both to give time for other tools to adapt.  */\n-\t  add_AT_addr (comp_unit_die (), DW_AT_low_pc, const0_rtx);\n+          add_AT_addr (main_comp_unit_die, DW_AT_low_pc, const0_rtx, true);\n \t  if (! dwarf_strict && dwarf_version < 4)\n-\t    add_AT_addr (comp_unit_die (), DW_AT_entry_pc, const0_rtx);\n+            add_AT_addr (main_comp_unit_die, DW_AT_entry_pc, const0_rtx, true);\n \n \t  add_ranges (NULL);\n \t}\n     }\n \n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n-    add_AT_lineptr (comp_unit_die (), DW_AT_stmt_list,\n+    add_AT_lineptr (main_comp_unit_die, DW_AT_stmt_list,\n \t\t    debug_line_section_label);\n \n   if (have_macinfo)\n     add_AT_macptr (comp_unit_die (),\n \t\t   dwarf_strict ? DW_AT_macro_info : DW_AT_GNU_macros,\n \t\t   macinfo_section_label);\n \n+  if (dwarf_split_debug_info && addr_index_table != NULL)\n+    {\n+      /* optimize_location_lists calculates the size of the lists,\n+         so index them first, and assign indices to the entries.\n+         Although optimize_location_lists will remove entries from\n+         the table, it only does so for duplicates, and therefore\n+         only reduces ref_counts to 1.  */\n+      unsigned int index = 0;\n+      index_location_lists (comp_unit_die ());\n+      htab_traverse_noresize (addr_index_table,\n+                              index_addr_table_entry, &index);\n+    }\n   if (have_location_lists)\n     optimize_location_lists (comp_unit_die ());\n \n+  save_macinfo_strings ();\n+  if (dwarf_split_debug_info)\n+    {\n+      unsigned int index = 0;\n+      htab_traverse_noresize (debug_str_hash, index_string, &index);\n+    }\n+\n   /* Output all of the compilation units.  We put the main one last so that\n      the offsets are available to output_pubnames.  */\n   for (node = limbo_die_list; node; node = node->next)\n@@ -22510,19 +23484,58 @@ dwarf2out_finish (const char *filename)\n          attributes.  */\n       if (debug_info_level >= DINFO_LEVEL_NORMAL)\n         add_AT_lineptr (ctnode->root_die, DW_AT_stmt_list,\n-\t\t        debug_line_section_label);\n+                        (!dwarf_split_debug_info\n+                         ? debug_line_section_label\n+                         : debug_skeleton_line_section_label));\n \n       output_comdat_type_unit (ctnode);\n       *slot = ctnode;\n     }\n   htab_delete (comdat_type_table);\n \n-  add_AT_pubnames (comp_unit_die ());\n+  /* The AT_pubnames attribute needs to go in all skeleton dies, including\n+     both the main_cu and all skeleton TUs.  Making this call unconditional\n+     would end up either adding a second copy of the AT_pubnames attribute, or\n+     requiring a special case in add_top_level_skeleton_die_attrs.  */\n+  if (!dwarf_split_debug_info)\n+    add_AT_pubnames (comp_unit_die ());\n+\n+  if (dwarf_split_debug_info)\n+    {\n+      int mark;\n+      unsigned char checksum[16];\n+      struct md5_ctx ctx;\n+\n+      /* Compute a checksum of the comp_unit to use as the dwo_id.  */\n+      md5_init_ctx (&ctx);\n+      mark = 0;\n+      die_checksum (comp_unit_die (), &ctx, &mark);\n+      unmark_all_dies (comp_unit_die ());\n+      md5_finish_ctx (&ctx, checksum);\n+\n+      /* Use the first 8 bytes of the checksum as the dwo_id,\n+        and add it to both comp-unit DIEs.  */\n+      add_AT_data8 (main_comp_unit_die, DW_AT_GNU_dwo_id, checksum);\n+      add_AT_data8 (comp_unit_die (), DW_AT_GNU_dwo_id, checksum);\n+\n+      /* Add the base offset of the ranges table to the skeleton\n+        comp-unit DIE.  */\n+      if (ranges_table_in_use)\n+        add_AT_lineptr (main_comp_unit_die, DW_AT_GNU_ranges_base,\n+                        ranges_section_label);\n+\n+      switch_to_section (debug_addr_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, debug_addr_section_label);\n+      output_addr_table ();\n+    }\n \n   /* Output the main compilation unit if non-empty or if .debug_macinfo\n      or .debug_macro will be emitted.  */\n   output_comp_unit (comp_unit_die (), have_macinfo);\n \n+  if (dwarf_split_debug_info && info_section_emitted)\n+    output_skeleton_debug_sections (main_comp_unit_die);\n+\n   /* Output the abbreviation table.  */\n   if (abbrev_die_table_in_use != 1)\n     {\n@@ -22536,8 +23549,6 @@ dwarf2out_finish (const char *filename)\n     {\n       /* Output the location lists info.  */\n       switch_to_section (debug_loc_section);\n-      ASM_GENERATE_INTERNAL_LABEL (loc_section_label,\n-\t\t\t\t   DEBUG_LOC_SECTION_LABEL, 0);\n       ASM_OUTPUT_LABEL (asm_out_file, loc_section_label);\n       output_location_lists (comp_unit_die ());\n     }\n@@ -22588,12 +23599,18 @@ dwarf2out_finish (const char *filename)\n   switch_to_section (debug_line_section);\n   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);\n   if (! DWARF2_ASM_LINE_DEBUG_INFO)\n-    output_line_info ();\n+    output_line_info (false);\n+\n+  if (dwarf_split_debug_info && info_section_emitted)\n+    {\n+      switch_to_section (debug_skeleton_line_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_line_section_label);\n+      output_line_info (true);\n+    }\n \n-  /* If we emitted any DW_FORM_strp form attribute, output the string\n-     table too.  */\n+  /* If we emitted any indirect strings, output the string table too.  */\n   if (debug_str_hash)\n-    htab_traverse (debug_str_hash, output_indirect_string, NULL);\n+    output_indirect_strings ();\n }\n \n #include \"gt-dwarf2out.h\""}, {"sha": "7fa625811776d7363c5665a1a9f990a3c2cb6f81", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -167,11 +167,14 @@ typedef struct GTY(()) dw_vec_struct {\n }\n dw_vec_const;\n \n+struct addr_table_entry_struct;\n+\n /* The dw_val_node describes an attribute's value, as it is\n    represented internally.  */\n \n typedef struct GTY(()) dw_val_struct {\n   enum dw_val_class val_class;\n+  struct addr_table_entry_struct * GTY(()) val_entry;\n   union dw_val_struct_union\n     {\n       rtx GTY ((tag (\"dw_val_class_addr\"))) val_addr;"}, {"sha": "a795981f00298eed4a0ee8e99d7a84dd7e3ff951", "filename": "gcc/gcc.c", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -267,6 +267,7 @@ static const char *compare_debug_dump_opt_spec_function (int, const char **);\n static const char *compare_debug_self_opt_spec_function (int, const char **);\n static const char *compare_debug_auxbase_opt_spec_function (int, const char **);\n static const char *pass_through_libs_spec_func (int, const char **);\n+static const char *replace_extension_spec_func (int, const char **);\n \f\n /* The Specs Language\n \n@@ -447,7 +448,7 @@ ignored.  White space may also appear anywhere on the left side of the\n colon in these constructs, except between . or * and the corresponding\n word.\n \n-The -O, -f, -m, and -W switches are handled specifically in these\n+The -O, -f, -g, -m, and -W switches are handled specifically in these\n constructs.  If another value of -O or the negated form of a -f, -m, or\n -W switch is found later in the command line, the earlier switch\n value is ignored, except with {S*} where S is just one letter; this\n@@ -480,7 +481,14 @@ proper position among the other output files.  */\n /* config.h can define ASM_FINAL_SPEC to run a post processor after\n    the assembler has run.  */\n #ifndef ASM_FINAL_SPEC\n-#define ASM_FINAL_SPEC \"\"\n+#define ASM_FINAL_SPEC \\\n+  \"%{gsplit-dwarf: \\n\\\n+       objcopy --extract-dwo \\\n+\t %{c:%{o*:%*}%{!o*:%b%O}}%{!c:%U%O} \\\n+\t %{c:%{o*:%:replace-extension(%{o*:%*} .dwo)}%{!o*:%b.dwo}}%{!c:%b.dwo} \\n\\\n+       objcopy --strip-dwo \\\n+\t %{c:%{o*:%*}%{!o*:%b%O}}%{!c:%U%O} \\\n+    }\"\n #endif\n \n /* config.h can define CPP_SPEC to provide extra args to the C preprocessor\n@@ -1262,6 +1270,7 @@ static const struct spec_function static_spec_functions[] =\n   { \"compare-debug-self-opt\",\tcompare_debug_self_opt_spec_function },\n   { \"compare-debug-auxbase-opt\", compare_debug_auxbase_opt_spec_function },\n   { \"pass-through-libs\",\tpass_through_libs_spec_func },\n+  { \"replace-extension\",\treplace_extension_spec_func },\n #ifdef EXTRA_SPEC_FUNCTIONS\n   EXTRA_SPEC_FUNCTIONS\n #endif\n@@ -5814,7 +5823,7 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n    on the command line.  PREFIX_LENGTH is the length of XXX in an {XXX*}\n    spec, or -1 if either exact match or %* is used.\n \n-   A -O switch is obsoleted by a later -O switch.  A -f, -m, or -W switch\n+   A -O switch is obsoleted by a later -O switch.  A -f, -g, -m, or -W switch\n    whose value does not begin with \"no-\" is obsoleted by the same value\n    with the \"no-\", similarly for a switch with the \"no-\" prefix.  */\n \n@@ -5851,7 +5860,7 @@ check_live_switch (int switchnum, int prefix_length)\n \t  }\n       break;\n \n-    case 'W':  case 'f':  case 'm':\n+    case 'W':  case 'f':  case 'm': case 'g':\n       if (! strncmp (name + 1, \"no-\", 3))\n \t{\n \t  /* We have Xno-YYY, search for XYYY.  */\n@@ -8380,3 +8389,33 @@ pass_through_libs_spec_func (int argc, const char **argv)\n     }\n   return prepended;\n }\n+\n+/* %:replace-extension spec function.  Replaces the extension of the\n+   first argument with the second argument.  */\n+\n+const char *\n+replace_extension_spec_func (int argc, const char **argv)\n+{\n+  char *name;\n+  char *p;\n+  char *result;\n+  int i;\n+\n+  if (argc != 2)\n+    fatal_error (\"too few arguments to %%:replace-extension\");\n+\n+  name = xstrdup (argv[0]);\n+\n+  for (i = strlen(name) - 1; i >= 0; i--)\n+    if (IS_DIR_SEPARATOR (name[i]))\n+      break;\n+\n+  p = strrchr (name + i + 1, '.');\n+  if (p != NULL)\n+      *p = '\\0';\n+\n+  result = concat (name, argv[1], NULL);\n+\n+  free (name);\n+  return result;\n+}"}, {"sha": "34c5698ba30e9eb92e2315d74d7d37704fd0ae3d", "filename": "gcc/opts.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -829,6 +829,9 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n     maybe_set_param_value (PARAM_MAX_STORES_TO_SINK, 0,\n                            opts->x_param_values, opts_set->x_param_values);\n \n+  /* The -gsplit-dwarf option requires -gpubnames.  */\n+  if (opts->x_dwarf_split_debug_info)\n+    opts->x_debug_generate_pub_sections = 1;\n }\n \n #define LEFT_COLUMN\t27\n@@ -1705,6 +1708,11 @@ common_handle_option (struct gcc_options *opts,\n       set_debug_level (DWARF2_DEBUG, false, \"\", opts, opts_set, loc);\n       break;\n \n+    case OPT_gsplit_dwarf:\n+      set_debug_level (NO_DEBUG, DEFAULT_GDB_EXTENSIONS, \"\", opts, opts_set,\n+\t\t       loc);\n+      break;\n+\n     case OPT_ggdb:\n       set_debug_level (NO_DEBUG, 2, arg, opts, opts_set, loc);\n       break;"}, {"sha": "afac33a7aef7c32adcebcdf34f28524426b5aa70", "filename": "include/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -1,3 +1,11 @@\n+2012-10-29  Sterling Augustine <saugustine@google.com>\n+            Cary Coutant <ccoutant@google.com>\n+\n+\t* dwarf2.h (dwarf_location_list_entry_type): New enum with fields\n+\tDW_LLE_GNU_end_of_list_entry, DW_LLE_GNU_base_address_selection_entry,\n+\tDW_LLE_GNU_start_end_entry and DW_LLE_GNU_start_length_entry.\n+\n+\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n \t* demangle.h (enum demangle_component_type): Add"}, {"sha": "e98505ac2f928756b5486704c9f25846dbe9b7b3", "filename": "include/dwarf2.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99ea153e45c86a1b0318e3f5e983624c3336445e/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99ea153e45c86a1b0318e3f5e983624c3336445e/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=99ea153e45c86a1b0318e3f5e983624c3336445e", "patch": "@@ -259,6 +259,17 @@ enum dwarf_line_number_hp_sfc_ops\n     DW_LNE_HP_SFC_associate = 3\n   };\n \n+/* Type codes for location list entries.\n+   Extension for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n+\n+enum dwarf_location_list_entry_type\n+  {\n+    DW_LLE_GNU_end_of_list_entry = 0,\n+    DW_LLE_GNU_base_address_selection_entry = 1,\n+    DW_LLE_GNU_start_end_entry = 2,\n+    DW_LLE_GNU_start_length_entry = 3\n+  };\n+\n #define DW_CIE_ID\t  0xffffffff\n #define DW64_CIE_ID\t  0xffffffffffffffffULL\n #define DW_CIE_VERSION\t  1"}]}