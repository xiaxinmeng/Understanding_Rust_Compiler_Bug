{"sha": "3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U0ZWFjM2ZlOWY0YjU5MGU2Yzk1MzU2YzNmY2I3YjA4NjMwYWNmMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-10-07T01:45:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-10-07T01:45:21Z"}, "message": "function.c (diddle_return_value): Examine current_function_return_rtx instead of the DECL_RESULT.\n\n        * function.c (diddle_return_value): Examine\n        current_function_return_rtx instead of the DECL_RESULT.\n        (expand_function_end): Handle reloading DECL_RESULT from memory\n        into a hard register.  Query promote_mode for sign of mismatched\n        modes.\n\nFrom-SVN: r36769", "tree": {"sha": "9d13e5f3092be6335d2cfa6ba7da64b6af514668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d13e5f3092be6335d2cfa6ba7da64b6af514668"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2/comments", "author": null, "committer": null, "parents": [{"sha": "15f18aaca64d6d5b27f29cc0072f46b5f04dbbe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f18aaca64d6d5b27f29cc0072f46b5f04dbbe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f18aaca64d6d5b27f29cc0072f46b5f04dbbe2"}], "stats": {"total": 84, "additions": 56, "deletions": 28}, "files": [{"sha": "4c6d27590cde937b6d464204943c21a54914fe8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2", "patch": "@@ -1,3 +1,11 @@\n+2000-10-06  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (diddle_return_value): Examine\n+\tcurrent_function_return_rtx instead of the DECL_RESULT.\n+\t(expand_function_end): Handle reloading DECL_RESULT from memory\n+\tinto a hard register.  Query promote_mode for sign of mismatched\n+\tmodes.\n+\n 2000-10-06  Vladimir Makarov  <vmakarov@touchme.toronto.redhat.com>\n \n \t* haifa-sched.c (schedule_insns): Fix typo in freeing"}, {"sha": "11ceea7c971fa32c6cd4698d1d911a3d0793afd5", "filename": "gcc/function.c", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3e4eac3fe9f4b590e6c95356c3fcb7b08630acf2", "patch": "@@ -6444,8 +6444,7 @@ diddle_return_value (doit, arg)\n       /* If this is a BLKmode structure being returned in registers, then use\n \t the mode computed in expand_return.  */\n       if (GET_MODE (outgoing) == BLKmode)\n-\tPUT_MODE (outgoing,\n-\t\t  GET_MODE (DECL_RTL (DECL_RESULT (current_function_decl))));\n+\tPUT_MODE (outgoing, GET_MODE (current_function_return_rtx));\n       REG_FUNCTION_VALUE_P (outgoing) = 1;\n     }\n \n@@ -6730,37 +6729,58 @@ expand_function_end (filename, line, end_bindings)\n \temit_stack_restore (SAVE_FUNCTION, tem, NULL_RTX);\n       }\n \n-  /* If scalar return value was computed in a pseudo-reg,\n-     copy that to the hard return register.  */\n-  if (DECL_RTL (DECL_RESULT (current_function_decl)) != 0\n-      && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG\n-      && (REGNO (DECL_RTL (DECL_RESULT (current_function_decl)))\n-\t  >= FIRST_PSEUDO_REGISTER))\n+  /* If scalar return value was computed in a pseudo-reg, or was a named\n+     return value that got dumped to the stack, copy that to the hard\n+     return register.  */\n+  if (DECL_RTL (DECL_RESULT (current_function_decl)) != 0)\n     {\n-      rtx real_decl_result;\n+      tree decl_result = DECL_RESULT (current_function_decl);\n+      rtx decl_rtl = DECL_RTL (decl_result);\n+\n+      if (REG_P (decl_rtl)\n+\t  ? REGNO (decl_rtl) >= FIRST_PSEUDO_REGISTER\n+\t  : DECL_REGISTER (decl_result))\n+\t{\n+\t  rtx real_decl_rtl;\n \n #ifdef FUNCTION_OUTGOING_VALUE\n-      real_decl_result\n-\t= FUNCTION_OUTGOING_VALUE (TREE_TYPE (DECL_RESULT (current_function_decl)),\n-\t\t\t\t   current_function_decl);\n+\t  real_decl_rtl = FUNCTION_OUTGOING_VALUE (TREE_TYPE (decl_result),\n+\t\t\t\t\t\t   current_function_decl);\n #else\n-      real_decl_result\n-\t= FUNCTION_VALUE (TREE_TYPE (DECL_RESULT (current_function_decl)),\n-\t\t\t  current_function_decl);\n+\t  real_decl_rtl = FUNCTION_VALUE (TREE_TYPE (decl_result),\n+\t\t\t\t\t  current_function_decl);\n #endif\n-      REG_FUNCTION_VALUE_P (real_decl_result) = 1;\n-      /* If this is a BLKmode structure being returned in registers, then use\n-\t the mode computed in expand_return.  */\n-      if (GET_MODE (real_decl_result) == BLKmode)\n-\tPUT_MODE (real_decl_result,\n-\t\t  GET_MODE (DECL_RTL (DECL_RESULT (current_function_decl))));\n-      emit_move_insn (real_decl_result,\n-\t\t      DECL_RTL (DECL_RESULT (current_function_decl)));\n-\n-      /* The delay slot scheduler assumes that current_function_return_rtx\n-\t holds the hard register containing the return value, not a temporary\n-\t pseudo.  */\n-      current_function_return_rtx = real_decl_result;\n+\t  REG_FUNCTION_VALUE_P (real_decl_rtl) = 1;\n+\n+\t  /* If this is a BLKmode structure being returned in registers,\n+\t     then use the mode computed in expand_return.  Note that if\n+\t     decl_rtl is memory, then its mode may have been changed, \n+\t     but that current_function_return_rtx has not.  */\n+\t  if (GET_MODE (real_decl_rtl) == BLKmode)\n+\t    PUT_MODE (real_decl_rtl, GET_MODE (current_function_return_rtx));\n+\n+\t  /* If a named return value dumped decl_return to memory, then\n+\t     we may need to re-do the PROMOTE_MODE signed/unsigned \n+\t     extension.  */\n+\t  if (GET_MODE (real_decl_rtl) != GET_MODE (decl_rtl))\n+\t    {\n+\t      int unsignedp = TREE_UNSIGNED (TREE_TYPE (decl_result));\n+\n+#ifdef PROMOTE_FUNCTION_RETURN\n+\t      promote_mode (TREE_TYPE (decl_result), GET_MODE (decl_rtl),\n+\t\t\t    &unsignedp, 1);\n+#endif\n+\n+\t      convert_move (real_decl_rtl, decl_rtl, unsignedp);\n+\t    }\n+\t  else\n+\t    emit_move_insn (real_decl_rtl, decl_rtl);\n+\n+\t  /* The delay slot scheduler assumes that current_function_return_rtx\n+\t     holds the hard register containing the return value, not a\n+\t     temporary pseudo.  */\n+\t  current_function_return_rtx = real_decl_rtl;\n+\t}\n     }\n \n   /* If returning a structure, arrange to return the address of the value"}]}