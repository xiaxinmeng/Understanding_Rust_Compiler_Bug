{"sha": "65e214672611ba3350918855de84d81fcbfa14d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVlMjE0NjcyNjExYmEzMzUwOTE4ODU1ZGU4NGQ4MWZjYmZhMTRkMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-03-31T17:10:48Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-03-31T17:10:48Z"}, "message": "HSA: handle alignment of string builtins (PR hsa/70391)\n\n\tPR hsa/70391\n\t* hsa-gen.c (hsa_function_representation::update_dominance): New\n\tfunction.\n\t(convert_addr_to_flat_segment): Likewise.\n\t(gen_hsa_memory_set): New alignment argument.\n\t(gen_hsa_ctor_assignment): Likewise.\n\t(gen_hsa_insns_for_single_assignment): Provide alignment\n\tto gen_hsa_ctor_assignment.\n\t(gen_hsa_insns_for_direct_call): Add new argument.\n\t(expand_lhs_of_string_op): New function.\n\t(expand_string_operation_builtin): Likewise.\n\t(expand_memory_copy): New function.\n\t(expand_memory_set): New function.\n\t(gen_hsa_insns_for_call): Use HOST_WIDE_INT.\n\t(convert_switch_statements): Change signature.\n\t(generate_hsa): Use a return value of the function.\n\t(pass_gen_hsail::execute): Do not call\n\tconvert_switch_statements here.\n\t* hsa-regalloc.c (hsa_regalloc): Call update_dominance.\n\t* hsa.h (hsa_function_representation::m_modified_cfg):\n\tNew flag.\n\t(hsa_function_representation::update_dominance): New function.\n\nFrom-SVN: r234644", "tree": {"sha": "c1bca0edd58f080640ccf63dd1092713120eb8b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1bca0edd58f080640ccf63dd1092713120eb8b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65e214672611ba3350918855de84d81fcbfa14d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e214672611ba3350918855de84d81fcbfa14d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e214672611ba3350918855de84d81fcbfa14d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e214672611ba3350918855de84d81fcbfa14d1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "320c1a36793e0f408924b38bc006e6b791dceff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320c1a36793e0f408924b38bc006e6b791dceff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/320c1a36793e0f408924b38bc006e6b791dceff7"}], "stats": {"total": 415, "additions": 305, "deletions": 110}, "files": [{"sha": "822ad343105d3c6fb2217cfdcc1b627d775cc28b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65e214672611ba3350918855de84d81fcbfa14d1", "patch": "@@ -1,3 +1,28 @@\n+2016-03-31  Martin Liska  <mliska@suse.cz>\n+\n+\tPR hsa/70391\n+\t* hsa-gen.c (hsa_function_representation::update_dominance): New\n+\tfunction.\n+\t(convert_addr_to_flat_segment): Likewise.\n+\t(gen_hsa_memory_set): New alignment argument.\n+\t(gen_hsa_ctor_assignment): Likewise.\n+\t(gen_hsa_insns_for_single_assignment): Provide alignment\n+\tto gen_hsa_ctor_assignment.\n+\t(gen_hsa_insns_for_direct_call): Add new argument.\n+\t(expand_lhs_of_string_op): New function.\n+\t(expand_string_operation_builtin): Likewise.\n+\t(expand_memory_copy): New function.\n+\t(expand_memory_set): New function.\n+\t(gen_hsa_insns_for_call): Use HOST_WIDE_INT.\n+\t(convert_switch_statements): Change signature.\n+\t(generate_hsa): Use a return value of the function.\n+\t(pass_gen_hsail::execute): Do not call\n+\tconvert_switch_statements here.\n+\t* hsa-regalloc.c (hsa_regalloc): Call update_dominance.\n+\t* hsa.h (hsa_function_representation::m_modified_cfg):\n+\tNew flag.\n+\t(hsa_function_representation::update_dominance): New function.\n+\n 2016-03-31  Martin Liska  <mliska@suse.cz>\n \n \tPR hsa/70391"}, {"sha": "4c86023d08808697ce1757217a9f23d7ac3e0eb0", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 271, "deletions": 109, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=65e214672611ba3350918855de84d81fcbfa14d1", "patch": "@@ -211,10 +211,12 @@ hsa_symbol::fillup_for_decl (tree decl)\n /* Constructor of class representing global HSA function/kernel information and\n    state.  FNDECL is function declaration, KERNEL_P is true if the function\n    is going to become a HSA kernel.  If the function has body, SSA_NAMES_COUNT\n-   should be set to number of SSA names used in the function.  */\n+   should be set to number of SSA names used in the function.\n+   MODIFIED_CFG is set to true in case we modified control-flow graph\n+   of the function.  */\n \n hsa_function_representation::hsa_function_representation\n-  (tree fdecl, bool kernel_p, unsigned ssa_names_count)\n+  (tree fdecl, bool kernel_p, unsigned ssa_names_count, bool modified_cfg)\n   : m_name (NULL),\n     m_reg_count (0), m_input_args (vNULL),\n     m_output_arg (NULL), m_spill_symbols (vNULL), m_global_symbols (vNULL),\n@@ -223,7 +225,8 @@ hsa_function_representation::hsa_function_representation\n     m_in_ssa (true), m_kern_p (kernel_p), m_declaration_p (false),\n     m_decl (fdecl), m_internal_fn (NULL), m_shadow_reg (NULL),\n     m_kernel_dispatch_count (0), m_maximum_omp_data_size (0),\n-    m_seen_error (false), m_temp_symbol_count (0), m_ssa_map ()\n+    m_seen_error (false), m_temp_symbol_count (0), m_ssa_map (),\n+    m_modified_cfg (modified_cfg)\n {\n   int sym_init_len = (vec_safe_length (cfun->local_decls) / 2) + 1;;\n   m_local_symbols = new hash_table <hsa_noop_symbol_hasher> (sym_init_len);\n@@ -319,6 +322,16 @@ hsa_function_representation::init_extra_bbs ()\n   hsa_init_new_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n }\n \n+void\n+hsa_function_representation::update_dominance ()\n+{\n+  if (m_modified_cfg)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      calculate_dominance_info (CDI_DOMINATORS);\n+    }\n+}\n+\n hsa_symbol *\n hsa_function_representation::create_hsa_temporary (BrigType16_t type)\n {\n@@ -2246,30 +2259,14 @@ gen_hsa_addr_for_arg (tree tree_type, int index)\n   return new hsa_op_address (sym);\n }\n \n-/* Generate HSA instructions that calculate address of VAL including all\n-   necessary conversions to flat addressing and place the result into DEST.\n+/* Generate HSA instructions that process all necessary conversions\n+   of an ADDR to flat addressing and place the result into DEST.\n    Instructions are appended to HBB.  */\n \n static void\n-gen_hsa_addr_insns (tree val, hsa_op_reg *dest, hsa_bb *hbb)\n+convert_addr_to_flat_segment (hsa_op_address *addr, hsa_op_reg *dest,\n+\t\t\t      hsa_bb *hbb)\n {\n-  /* Handle cases like tmp = NULL, where we just emit a move instruction\n-     to a register.  */\n-  if (TREE_CODE (val) == INTEGER_CST)\n-    {\n-      hsa_op_immed *c = new hsa_op_immed (val);\n-      hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV,\n-\t\t\t\t\t\t dest->m_type, dest, c);\n-      hbb->append_insn (insn);\n-      return;\n-    }\n-\n-  hsa_op_address *addr;\n-\n-  gcc_assert (dest->m_type == hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT));\n-  if (TREE_CODE (val) == ADDR_EXPR)\n-    val = TREE_OPERAND (val, 0);\n-  addr = gen_hsa_addr (val, hbb);\n   hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_LDA);\n   insn->set_op (1, addr);\n   if (addr->m_symbol && addr->m_symbol->m_segment != BRIG_SEGMENT_GLOBAL)\n@@ -2298,6 +2295,34 @@ gen_hsa_addr_insns (tree val, hsa_op_reg *dest, hsa_bb *hbb)\n     }\n }\n \n+/* Generate HSA instructions that calculate address of VAL including all\n+   necessary conversions to flat addressing and place the result into DEST.\n+   Instructions are appended to HBB.  */\n+\n+static void\n+gen_hsa_addr_insns (tree val, hsa_op_reg *dest, hsa_bb *hbb)\n+{\n+  /* Handle cases like tmp = NULL, where we just emit a move instruction\n+     to a register.  */\n+  if (TREE_CODE (val) == INTEGER_CST)\n+    {\n+      hsa_op_immed *c = new hsa_op_immed (val);\n+      hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV,\n+\t\t\t\t\t\t dest->m_type, dest, c);\n+      hbb->append_insn (insn);\n+      return;\n+    }\n+\n+  hsa_op_address *addr;\n+\n+  gcc_assert (dest->m_type == hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT));\n+  if (TREE_CODE (val) == ADDR_EXPR)\n+    val = TREE_OPERAND (val, 0);\n+  addr = gen_hsa_addr (val, hbb);\n+\n+  convert_addr_to_flat_segment (addr, dest, hbb);\n+}\n+\n /* Return an HSA register or HSA immediate value operand corresponding to\n    gimple operand OP.  */\n \n@@ -2728,9 +2753,9 @@ gen_hsa_insns_for_store (tree lhs, hsa_op_base *src, hsa_bb *hbb)\n }\n \n /* Generate memory copy instructions that are going to be used\n-   for copying a HSA symbol SRC_SYMBOL (or SRC_REG) to TARGET memory,\n+   for copying a SRC memory to TARGET memory,\n    represented by pointer in a register.  MIN_ALIGN is minimal alignment\n-   of provided HSA addresses. */\n+   of provided HSA addresses.  */\n \n static void\n gen_hsa_memory_copy (hsa_bb *hbb, hsa_op_address *target, hsa_op_address *src,\n@@ -2792,17 +2817,19 @@ build_memset_value (unsigned HOST_WIDE_INT constant, unsigned byte_size)\n }\n \n /* Generate memory set instructions that are going to be used\n-   for setting a CONSTANT byte value to TARGET memory of SIZE bytes.  */\n+   for setting a CONSTANT byte value to TARGET memory of SIZE bytes.\n+   MIN_ALIGN is minimal alignment of provided HSA addresses.  */\n \n static void\n gen_hsa_memory_set (hsa_bb *hbb, hsa_op_address *target,\n \t\t    unsigned HOST_WIDE_INT constant,\n-\t\t    unsigned size)\n+\t\t    unsigned size, BrigAlignment8_t min_align)\n {\n   hsa_op_address *addr;\n   hsa_insn_mem *mem;\n \n   unsigned offset = 0;\n+  unsigned min_byte_align = hsa_byte_alignment (min_align);\n \n   while (size)\n     {\n@@ -2816,6 +2843,9 @@ gen_hsa_memory_set (hsa_bb *hbb, hsa_op_address *target,\n       else\n \ts = 1;\n \n+      if (s > min_byte_align)\n+\ts = min_byte_align;\n+\n       addr = new hsa_op_address (target->m_symbol, target->m_reg,\n \t\t\t\t target->m_imm_offset + offset);\n \n@@ -2832,10 +2862,12 @@ gen_hsa_memory_set (hsa_bb *hbb, hsa_op_address *target,\n \n /* Generate HSAIL instructions for a single assignment\n    of an empty constructor to an ADDR_LHS.  Constructor is passed as a\n-   tree RHS and all instructions are appended to HBB.  */\n+   tree RHS and all instructions are appended to HBB.  ALIGN is\n+   alignment of the address.  */\n \n void\n-gen_hsa_ctor_assignment (hsa_op_address *addr_lhs, tree rhs, hsa_bb *hbb)\n+gen_hsa_ctor_assignment (hsa_op_address *addr_lhs, tree rhs, hsa_bb *hbb,\n+\t\t\t BrigAlignment8_t align)\n {\n   if (vec_safe_length (CONSTRUCTOR_ELTS (rhs)))\n     {\n@@ -2845,7 +2877,7 @@ gen_hsa_ctor_assignment (hsa_op_address *addr_lhs, tree rhs, hsa_bb *hbb)\n     }\n \n   unsigned size = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (rhs)));\n-  gen_hsa_memory_set (hbb, addr_lhs, 0, size);\n+  gen_hsa_memory_set (hbb, addr_lhs, 0, size, align);\n }\n \n /* Generate HSA instructions for a single assignment of RHS to LHS.\n@@ -2879,7 +2911,7 @@ gen_hsa_insns_for_single_assignment (tree lhs, tree rhs, hsa_bb *hbb)\n \t\t\t\t\t\t\t  &lhs_align);\n \n       if (TREE_CODE (rhs) == CONSTRUCTOR)\n-\tgen_hsa_ctor_assignment (addr_lhs, rhs, hbb);\n+\tgen_hsa_ctor_assignment (addr_lhs, rhs, hbb, lhs_align);\n       else\n \t{\n \t  BrigAlignment8_t rhs_align;\n@@ -3523,10 +3555,13 @@ get_format_argument_type (tree formal_arg_type, BrigType16_t actual_arg_type)\n \n /* Generate HSA instructions for a direct call instruction.\n    Instructions will be appended to HBB, which also needs to be the\n-   corresponding structure to the basic_block of STMT.  */\n+   corresponding structure to the basic_block of STMT.\n+   If ASSIGN_LHS is false, do not copy HSA function result argument into the\n+   corresponding HSA representation of the gimple statement LHS.  */\n \n static void\n-gen_hsa_insns_for_direct_call (gimple *stmt, hsa_bb *hbb)\n+gen_hsa_insns_for_direct_call (gimple *stmt, hsa_bb *hbb,\n+\t\t\t       bool assign_lhs = true)\n {\n   tree decl = gimple_call_fndecl (stmt);\n   verify_function_arguments (decl);\n@@ -3608,7 +3643,7 @@ gen_hsa_insns_for_direct_call (gimple *stmt, hsa_bb *hbb)\n \n       /* Even if result of a function call is unused, we have to emit\n \t declaration for the result.  */\n-      if (result)\n+      if (result && assign_lhs)\n \t{\n \t  tree lhs_type = TREE_TYPE (result);\n \n@@ -4481,6 +4516,195 @@ get_address_from_value (tree val, hsa_bb *hbb)\n     }\n }\n \n+/* Expand assignment of a result of a string BUILTIN to DST.\n+   Size of the operation is N bytes, where instructions\n+   will be append to HBB.  */\n+\n+static void\n+expand_lhs_of_string_op (gimple *stmt,\n+\t\t\t unsigned HOST_WIDE_INT n, hsa_bb *hbb,\n+\t\t\t enum built_in_function builtin)\n+{\n+  /* If LHS is expected, we need to emit a PHI instruction.  */\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  hsa_op_reg *lhs_reg = hsa_cfun->reg_for_gimple_ssa (lhs);\n+\n+  hsa_op_with_type *dst_reg\n+    = hsa_reg_or_immed_for_gimple_op (gimple_call_arg (stmt, 0), hbb);\n+  hsa_op_with_type *tmp;\n+\n+  switch (builtin)\n+    {\n+    case BUILT_IN_MEMPCPY:\n+      {\n+\ttmp = new hsa_op_reg (dst_reg->m_type);\n+\thsa_insn_basic *add\n+\t  = new hsa_insn_basic (3, BRIG_OPCODE_ADD, tmp->m_type,\n+\t\t\t\ttmp, dst_reg,\n+\t\t\t\tnew hsa_op_immed (n, dst_reg->m_type));\n+\thbb->append_insn (add);\n+\tbreak;\n+      }\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMSET:\n+      tmp = dst_reg;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  hbb->append_insn (new hsa_insn_basic (2, BRIG_OPCODE_MOV, lhs_reg->m_type,\n+\t\t\t\t\tlhs_reg, tmp));\n+}\n+\n+#define HSA_MEMORY_BUILTINS_LIMIT     128\n+\n+/* Expand a string builtin (from a gimple STMT) in a way that\n+   according to MISALIGNED_FLAG we process either direct emission\n+   (a bunch of memory load and store instructions), or we emit a function call\n+   of a library function (for instance 'memcpy'). Actually, a basic block\n+   for direct emission is just prepared, where caller is responsible\n+   for emission of corresponding instructions.\n+   All instruction are appended to HBB.  */\n+\n+hsa_bb *\n+expand_string_operation_builtin (gimple *stmt, hsa_bb *hbb,\n+\t\t\t\t hsa_op_reg *misaligned_flag)\n+{\n+  edge e = split_block (hbb->m_bb, stmt);\n+  basic_block condition_bb = e->src;\n+  hbb->append_insn (new hsa_insn_br (misaligned_flag));\n+\n+  /* Prepare the control flow.  */\n+  edge condition_edge = EDGE_SUCC (condition_bb, 0);\n+  basic_block call_bb = split_edge (condition_edge);\n+\n+  basic_block expanded_bb = split_edge (EDGE_SUCC (call_bb, 0));\n+  basic_block cont_bb = EDGE_SUCC (expanded_bb, 0)->dest;\n+  basic_block merge_bb = split_edge (EDGE_PRED (cont_bb, 0));\n+\n+  condition_edge->flags &= ~EDGE_FALLTHRU;\n+  condition_edge->flags |= EDGE_TRUE_VALUE;\n+  make_edge (condition_bb, expanded_bb, EDGE_FALSE_VALUE);\n+\n+  redirect_edge_succ (EDGE_SUCC (call_bb, 0), merge_bb);\n+\n+  hsa_cfun->m_modified_cfg = true;\n+\n+  hsa_init_new_bb (expanded_bb);\n+\n+  /* Slow path: function call.  */\n+  gen_hsa_insns_for_direct_call (stmt, hsa_init_new_bb (call_bb), false);\n+\n+  return hsa_bb_for_bb (expanded_bb);\n+}\n+\n+/* Expand a memory copy BUILTIN (BUILT_IN_MEMCPY, BUILT_IN_MEMPCPY) from\n+   a gimple STMT and store all necessary instruction to HBB basic block.  */\n+\n+static void\n+expand_memory_copy (gimple *stmt, hsa_bb *hbb, enum built_in_function builtin)\n+{\n+  tree byte_size = gimple_call_arg (stmt, 2);\n+\n+  if (!tree_fits_uhwi_p (byte_size))\n+    {\n+      gen_hsa_insns_for_direct_call (stmt, hbb);\n+      return;\n+    }\n+\n+  unsigned HOST_WIDE_INT n = tree_to_uhwi (byte_size);\n+\n+  if (n > HSA_MEMORY_BUILTINS_LIMIT)\n+    {\n+      gen_hsa_insns_for_direct_call (stmt, hbb);\n+      return;\n+    }\n+\n+  tree dst = gimple_call_arg (stmt, 0);\n+  tree src = gimple_call_arg (stmt, 1);\n+\n+  hsa_op_address *dst_addr = get_address_from_value (dst, hbb);\n+  hsa_op_address *src_addr = get_address_from_value (src, hbb);\n+\n+  /* As gen_hsa_memory_copy relies on memory alignment\n+     greater or equal to 8 bytes, we need to verify the alignment.  */\n+  BrigType16_t addrtype = hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT);\n+  hsa_op_reg *src_addr_reg = new hsa_op_reg (addrtype);\n+  hsa_op_reg *dst_addr_reg = new hsa_op_reg (addrtype);\n+\n+  convert_addr_to_flat_segment (src_addr, src_addr_reg, hbb);\n+  convert_addr_to_flat_segment (dst_addr, dst_addr_reg, hbb);\n+\n+  /* Process BIT OR for source and destination addresses.  */\n+  hsa_op_reg *or_reg = new hsa_op_reg (addrtype);\n+  gen_hsa_binary_operation (BRIG_OPCODE_OR, or_reg, src_addr_reg,\n+\t\t\t    dst_addr_reg, hbb);\n+\n+  /* Process BIT AND with 0x7 to identify the desired alignment\n+     of 8 bytes.  */\n+  hsa_op_reg *masked = new hsa_op_reg (addrtype);\n+\n+  gen_hsa_binary_operation (BRIG_OPCODE_AND, masked, or_reg,\n+\t\t\t    new hsa_op_immed (7, addrtype), hbb);\n+\n+  hsa_op_reg *misaligned = new hsa_op_reg (BRIG_TYPE_B1);\n+  hbb->append_insn (new hsa_insn_cmp (BRIG_COMPARE_NE, misaligned->m_type,\n+\t\t\t\t      misaligned, masked,\n+\t\t\t\t      new hsa_op_immed (0, masked->m_type)));\n+\n+  hsa_bb *native_impl_bb\n+    = expand_string_operation_builtin (stmt, hbb, misaligned);\n+\n+  gen_hsa_memory_copy (native_impl_bb, dst_addr, src_addr, n, BRIG_ALIGNMENT_8);\n+  hsa_bb *merge_bb\n+    = hsa_init_new_bb (EDGE_SUCC (native_impl_bb->m_bb, 0)->dest);\n+  expand_lhs_of_string_op (stmt, n, merge_bb, builtin);\n+}\n+\n+\n+/* Expand a memory set BUILTIN (BUILT_IN_MEMSET, BUILT_IN_BZERO) from\n+   a gimple STMT and store all necessary instruction to HBB basic block.\n+   The operation set N bytes with a CONSTANT value.  */\n+\n+static void\n+expand_memory_set (gimple *stmt, unsigned HOST_WIDE_INT n,\n+\t\t   unsigned HOST_WIDE_INT constant, hsa_bb *hbb,\n+\t\t   enum built_in_function builtin)\n+{\n+  tree dst = gimple_call_arg (stmt, 0);\n+  hsa_op_address *dst_addr = get_address_from_value (dst, hbb);\n+\n+  /* As gen_hsa_memory_set relies on memory alignment\n+     greater or equal to 8 bytes, we need to verify the alignment.  */\n+  BrigType16_t addrtype = hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT);\n+  hsa_op_reg *dst_addr_reg = new hsa_op_reg (addrtype);\n+  convert_addr_to_flat_segment (dst_addr, dst_addr_reg, hbb);\n+\n+  /* Process BIT AND with 0x7 to identify the desired alignment\n+     of 8 bytes.  */\n+  hsa_op_reg *masked = new hsa_op_reg (addrtype);\n+\n+  gen_hsa_binary_operation (BRIG_OPCODE_AND, masked, dst_addr_reg,\n+\t\t\t    new hsa_op_immed (7, addrtype), hbb);\n+\n+  hsa_op_reg *misaligned = new hsa_op_reg (BRIG_TYPE_B1);\n+  hbb->append_insn (new hsa_insn_cmp (BRIG_COMPARE_NE, misaligned->m_type,\n+\t\t\t\t      misaligned, masked,\n+\t\t\t\t      new hsa_op_immed (0, masked->m_type)));\n+\n+  hsa_bb *native_impl_bb\n+    = expand_string_operation_builtin (stmt, hbb, misaligned);\n+\n+  gen_hsa_memory_set (native_impl_bb, dst_addr, constant, n, BRIG_ALIGNMENT_8);\n+  hsa_bb *merge_bb\n+    = hsa_init_new_bb (EDGE_SUCC (native_impl_bb->m_bb, 0)->dest);\n+  expand_lhs_of_string_op (stmt, n, merge_bb, builtin);\n+}\n+\n /* Return string for MEMMODEL.  */\n \n static const char *\n@@ -4811,8 +5035,6 @@ gen_hsa_insn_for_internal_fn_call (gcall *stmt, hsa_bb *hbb)\n     }\n }\n \n-#define HSA_MEMORY_BUILTINS_LIMIT     128\n-\n /* Generate HSA instructions for the given call statement STMT.  Instructions\n    will be appended to HBB.  */\n \n@@ -5169,58 +5391,11 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n     case BUILT_IN_MEMCPY:\n     case BUILT_IN_MEMPCPY:\n       {\n-\ttree byte_size = gimple_call_arg (stmt, 2);\n-\n-\tif (!tree_fits_uhwi_p (byte_size))\n-\t  {\n-\t    gen_hsa_insns_for_direct_call (stmt, hbb);\n-\t    return;\n-\t  }\n-\n-\tunsigned n = tree_to_uhwi (byte_size);\n-\n-\tif (n > HSA_MEMORY_BUILTINS_LIMIT)\n-\t  {\n-\t    gen_hsa_insns_for_direct_call (stmt, hbb);\n-\t    return;\n-\t  }\n-\n-\ttree dst = gimple_call_arg (stmt, 0);\n-\ttree src = gimple_call_arg (stmt, 1);\n-\n-\thsa_op_address *dst_addr = get_address_from_value (dst, hbb);\n-\thsa_op_address *src_addr = get_address_from_value (src, hbb);\n-\n-\tgen_hsa_memory_copy (hbb, dst_addr, src_addr, n, BRIG_ALIGNMENT_1);\n-\n-\ttree lhs = gimple_call_lhs (stmt);\n-\tif (lhs)\n-\t  {\n-\t    hsa_op_reg *lhs_reg = hsa_cfun->reg_for_gimple_ssa (lhs);\n-\t    hsa_op_with_type *dst_reg = hsa_reg_or_immed_for_gimple_op (dst,\n-\t\t\t\t\t\t\t\t\thbb);\n-\t    hsa_op_with_type *tmp;\n-\n-\t    if (builtin == BUILT_IN_MEMPCPY)\n-\t      {\n-\t\ttmp = new hsa_op_reg (dst_reg->m_type);\n-\t\thsa_insn_basic *add\n-\t\t  = new hsa_insn_basic (3, BRIG_OPCODE_ADD, tmp->m_type,\n-\t\t\t\t\ttmp, dst_reg,\n-\t\t\t\t\tnew hsa_op_immed (n, dst_reg->m_type));\n-\t\thbb->append_insn (add);\n-\t      }\n-\t    else\n-\t      tmp = dst_reg;\n-\n-\t    hsa_build_append_simple_mov (lhs_reg, tmp, hbb);\n-\t  }\n-\n+\texpand_memory_copy (stmt, hbb, builtin);\n \tbreak;\n       }\n     case BUILT_IN_MEMSET:\n       {\n-\ttree dst = gimple_call_arg (stmt, 0);\n \ttree c = gimple_call_arg (stmt, 1);\n \n \tif (TREE_CODE (c) != INTEGER_CST)\n@@ -5237,30 +5412,23 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \t    return;\n \t  }\n \n-\tunsigned n = tree_to_uhwi (byte_size);\n+\tunsigned HOST_WIDE_INT n = tree_to_uhwi (byte_size);\n \n \tif (n > HSA_MEMORY_BUILTINS_LIMIT)\n \t  {\n \t    gen_hsa_insns_for_direct_call (stmt, hbb);\n \t    return;\n \t  }\n \n-\thsa_op_address *dst_addr;\n-\tdst_addr = get_address_from_value (dst, hbb);\n \tunsigned HOST_WIDE_INT constant\n \t  = tree_to_uhwi (fold_convert (unsigned_char_type_node, c));\n \n-\tgen_hsa_memory_set (hbb, dst_addr, constant, n);\n-\n-\ttree lhs = gimple_call_lhs (stmt);\n-\tif (lhs)\n-\t  gen_hsa_insns_for_single_assignment (lhs, dst, hbb);\n+\texpand_memory_set (stmt, n, constant, hbb, builtin);\n \n \tbreak;\n       }\n     case BUILT_IN_BZERO:\n       {\n-\ttree dst = gimple_call_arg (stmt, 0);\n \ttree byte_size = gimple_call_arg (stmt, 1);\n \n \tif (!tree_fits_uhwi_p (byte_size))\n@@ -5269,18 +5437,15 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \t    return;\n \t  }\n \n-\tunsigned n = tree_to_uhwi (byte_size);\n+\tunsigned HOST_WIDE_INT n = tree_to_uhwi (byte_size);\n \n \tif (n > HSA_MEMORY_BUILTINS_LIMIT)\n \t  {\n \t    gen_hsa_insns_for_direct_call (stmt, hbb);\n \t    return;\n \t  }\n \n-\thsa_op_address *dst_addr;\n-\tdst_addr = get_address_from_value (dst, hbb);\n-\n-\tgen_hsa_memory_set (hbb, dst_addr, 0, n);\n+\texpand_memory_set (stmt, n, 0, hbb, builtin);\n \n \tbreak;\n       }\n@@ -5832,13 +5997,13 @@ LD:    hard_work_3 ();\n \n */\n \n-static void\n-convert_switch_statements ()\n+static bool\n+convert_switch_statements (void)\n {\n   function *func = DECL_STRUCT_FUNCTION (current_function_decl);\n   basic_block bb;\n \n-  bool need_update = false;\n+  bool modified_cfg = false;\n \n   FOR_EACH_BB_FN (bb, func)\n   {\n@@ -5856,7 +6021,7 @@ convert_switch_statements ()\n \tif (transformable_switch_to_sbr_p (s))\n \t  continue;\n \n-\tneed_update = true;\n+\tmodified_cfg = true;\n \n \tunsigned labels = gimple_switch_num_labels (s);\n \ttree index = gimple_switch_index (s);\n@@ -6023,11 +6188,7 @@ convert_switch_statements ()\n   if (dump_file)\n     dump_function_to_file (current_function_decl, dump_file, TDF_DETAILS);\n \n-  if (need_update)\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-      calculate_dominance_info (CDI_DOMINATORS);\n-    }\n+  return modified_cfg;\n }\n \n /* Expand builtins that can't be handled by HSA back-end.  */\n@@ -6127,9 +6288,11 @@ generate_hsa (bool kernel)\n   if (hsa_num_threads == NULL)\n     emit_hsa_module_variables ();\n \n+  bool modified_cfg = convert_switch_statements ();\n   /* Initialize hsa_cfun.  */\n   hsa_cfun = new hsa_function_representation (cfun->decl, kernel,\n-\t\t\t\t\t      SSANAMES (cfun)->length ());\n+\t\t\t\t\t      SSANAMES (cfun)->length (),\n+\t\t\t\t\t      modified_cfg);\n   hsa_cfun->init_extra_bbs ();\n \n   if (flag_tm)\n@@ -6234,7 +6397,6 @@ pass_gen_hsail::execute (function *)\n   hsa_function_summary *s\n     = hsa_summaries->get (cgraph_node::get_create (current_function_decl));\n \n-  convert_switch_statements ();\n   expand_builtins ();\n   generate_hsa (s->m_kind == HSA_KERNEL);\n   TREE_ASM_WRITTEN (current_function_decl) = 1;"}, {"sha": "50bf51155dfe52174f5c4e147c536a28c481df89", "filename": "gcc/hsa-regalloc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2Fhsa-regalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2Fhsa-regalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-regalloc.c?ref=65e214672611ba3350918855de84d81fcbfa14d1", "patch": "@@ -700,6 +700,7 @@ regalloc (void)\n void\n hsa_regalloc (void)\n {\n+  hsa_cfun->update_dominance ();\n   naive_outof_ssa ();\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "b7b1e3c76397280407d749ff30eefe998ab9c2a6", "filename": "gcc/hsa.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e214672611ba3350918855de84d81fcbfa14d1/gcc%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.h?ref=65e214672611ba3350918855de84d81fcbfa14d1", "patch": "@@ -1123,7 +1123,8 @@ class hsa_function_representation\n {\n public:\n   hsa_function_representation (tree fdecl, bool kernel_p,\n-\t\t\t       unsigned ssa_names_count);\n+\t\t\t       unsigned ssa_names_count,\n+\t\t\t       bool modified_cfg = false);\n   hsa_function_representation (hsa_internal_fn *fn);\n   ~hsa_function_representation ();\n \n@@ -1139,6 +1140,9 @@ class hsa_function_representation\n      so we need hsa_bb instances of them.  */\n   void init_extra_bbs ();\n \n+  /* Update CFG dominators if m_modified_cfg flag is set.  */\n+  void update_dominance ();\n+\n   /* Return linkage of the representation.  */\n   BrigLinkage8_t get_linkage ();\n \n@@ -1219,6 +1223,9 @@ class hsa_function_representation\n \n   /* SSA names mapping.  */\n   vec <hsa_op_reg_p> m_ssa_map;\n+\n+  /* Flag whether a function needs update of dominators before RA.  */\n+  bool m_modified_cfg;\n };\n \n enum hsa_function_kind"}]}