{"sha": "ca0f5734fe3daccfbd630628e4c11ebec230220d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EwZjU3MzRmZTNkYWNjZmJkNjMwNjI4ZTRjMTFlYmVjMjMwMjIwZA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-01T14:44:04Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-01T14:44:04Z"}, "message": "re PR d/88462 (All D execution tests FAIL on Solaris/SPARC)\n\n    PR d/88462\nlibphobos: Fix abort in pthread_mutex_init on Solaris.\n\nMerges upstream druntime d57fa1ff.\n\nReviewed-on: https://github.com/dlang/druntime/pull/2534\n\nFrom-SVN: r270057", "tree": {"sha": "628b32f528e89d8a7c5d36688a8974b03acf7907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/628b32f528e89d8a7c5d36688a8974b03acf7907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca0f5734fe3daccfbd630628e4c11ebec230220d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0f5734fe3daccfbd630628e4c11ebec230220d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0f5734fe3daccfbd630628e4c11ebec230220d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0f5734fe3daccfbd630628e4c11ebec230220d/comments", "author": null, "committer": null, "parents": [{"sha": "f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ba6c5a51936ac9065789b1fdb77f4e35f90efd"}], "stats": {"total": 53, "additions": 42, "deletions": 11}, "files": [{"sha": "15a55ab612a56f7a2538c73341f5c3e9081398fa", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0f5734fe3daccfbd630628e4c11ebec230220d/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0f5734fe3daccfbd630628e4c11ebec230220d/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=ca0f5734fe3daccfbd630628e4c11ebec230220d", "patch": "@@ -1,4 +1,4 @@\n-b9564bef1147c797842e6c1a804f2c3565c64ac1\n+d57fa1ffaecc858229ed7a730e8486b59197dee5\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "e56f016c35596c079250730d4cbf037e0c780db6", "filename": "libphobos/libdruntime/core/internal/traits.d", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0f5734fe3daccfbd630628e4c11ebec230220d/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0f5734fe3daccfbd630628e4c11ebec230220d/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d?ref=ca0f5734fe3daccfbd630628e4c11ebec230220d", "patch": "@@ -170,6 +170,29 @@ template anySatisfy(alias F, T...)\n     }\n }\n \n+// simplified from std.traits.maxAlignment\n+template maxAlignment(U...)\n+{\n+    static if (U.length == 0)\n+        static assert(0);\n+    else static if (U.length == 1)\n+        enum maxAlignment = U[0].alignof;\n+    else static if (U.length == 2)\n+        enum maxAlignment = U[0].alignof > U[1].alignof ? U[0].alignof : U[1].alignof;\n+    else\n+    {\n+        enum a = maxAlignment!(U[0 .. ($+1)/2]);\n+        enum b = maxAlignment!(U[($+1)/2 .. $]);\n+        enum maxAlignment = a > b ? a : b;\n+    }\n+}\n+\n+template classInstanceAlignment(T)\n+if (is(T == class))\n+{\n+    alias classInstanceAlignment = maxAlignment!(void*, typeof(T.tupleof));\n+}\n+\n // Somehow fails for non-static nested structs without support for aliases\n template hasElaborateDestructor(T...)\n {"}, {"sha": "1cf26641e05e34b411993042b79850511dec04a2", "filename": "libphobos/libdruntime/core/thread.d", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0f5734fe3daccfbd630628e4c11ebec230220d/libphobos%2Flibdruntime%2Fcore%2Fthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0f5734fe3daccfbd630628e4c11ebec230220d/libphobos%2Flibdruntime%2Fcore%2Fthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread.d?ref=ca0f5734fe3daccfbd630628e4c11ebec230220d", "patch": "@@ -114,6 +114,13 @@ private\n {\n     import core.atomic, core.memory, core.sync.mutex;\n \n+    // Handling unaligned mutexes are not supported on all platforms, so we must\n+    // ensure that the address of all shared data are appropriately aligned.\n+    import core.internal.traits : classInstanceAlignment;\n+\n+    enum mutexAlign = classInstanceAlignment!Mutex;\n+    enum mutexClassInstanceSize = __traits(classInstanceSize, Mutex);\n+\n     //\n     // exposed by compiler runtime\n     //\n@@ -1708,29 +1715,30 @@ private:\n     // lock order inversion.\n     @property static Mutex slock() nothrow @nogc\n     {\n-        return cast(Mutex)_locks[0].ptr;\n+        return cast(Mutex)_slock.ptr;\n     }\n \n     @property static Mutex criticalRegionLock() nothrow @nogc\n     {\n-        return cast(Mutex)_locks[1].ptr;\n+        return cast(Mutex)_criticalRegionLock.ptr;\n     }\n \n-    __gshared align(Mutex.alignof) void[__traits(classInstanceSize, Mutex)][2] _locks;\n+    __gshared align(mutexAlign) void[mutexClassInstanceSize] _slock;\n+    __gshared align(mutexAlign) void[mutexClassInstanceSize] _criticalRegionLock;\n \n     static void initLocks()\n     {\n-        foreach (ref lock; _locks)\n-        {\n-            lock[] = typeid(Mutex).initializer[];\n-            (cast(Mutex)lock.ptr).__ctor();\n-        }\n+        _slock[] = typeid(Mutex).initializer[];\n+        (cast(Mutex)_slock.ptr).__ctor();\n+\n+        _criticalRegionLock[] = typeid(Mutex).initializer[];\n+        (cast(Mutex)_criticalRegionLock.ptr).__ctor();\n     }\n \n     static void termLocks()\n     {\n-        foreach (ref lock; _locks)\n-            (cast(Mutex)lock.ptr).__dtor();\n+        (cast(Mutex)_slock.ptr).__dtor();\n+        (cast(Mutex)_criticalRegionLock.ptr).__dtor();\n     }\n \n     __gshared Context*  sm_cbeg;"}]}