{"sha": "8ae261c007a5cdb70d1115d0195c32659561115f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlMjYxYzAwN2E1Y2RiNzBkMTExNWQwMTk1YzMyNjU5NTYxMTE1Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-08-15T09:50:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-08-15T09:50:33Z"}, "message": "re PR debug/71906 (Fortran allocatable strings debug info type size regression)\n\n\tPR debug/71906\n\t* dwarf2out.c (string_types): New variable.\n\t(gen_array_type_die): Change early_dwarf handling of\n\tDW_AT_string_length, create DW_OP_call4 referencing the\n\tlength var temporarily.  Handle parameters that are pointers\n\tto string length.\n\t(adjust_string_types): New function.\n\t(gen_subprogram_die): Temporarily set string_types to local var,\n\tcall adjust_string_types if needed.\n\t(non_dwarf_expression, copy_deref_exprloc, optimize_string_length):\n\tNew functions.\n\t(resolve_addr): Adjust DW_AT_string_length if it is DW_OP_call4.\n\n\t* trans-decl.c (gfc_get_symbol_decl): Call gfc_finish_var_decl\n\tfor decl's character length before gfc_finish_var_decl on the\n\tdecl itself.\n\nFrom-SVN: r239469", "tree": {"sha": "081e5d0d4e40144ee0cd92dbd5c087ccd07cebd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/081e5d0d4e40144ee0cd92dbd5c087ccd07cebd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ae261c007a5cdb70d1115d0195c32659561115f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ae261c007a5cdb70d1115d0195c32659561115f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ae261c007a5cdb70d1115d0195c32659561115f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ae261c007a5cdb70d1115d0195c32659561115f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28619cd767c281af7ce543925d4212d843a09de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28619cd767c281af7ce543925d4212d843a09de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28619cd767c281af7ce543925d4212d843a09de8"}], "stats": {"total": 368, "additions": 345, "deletions": 23}, "files": [{"sha": "ecf62929dc3b040da9c531824cbbcf034fb0f21d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ae261c007a5cdb70d1115d0195c32659561115f", "patch": "@@ -1,3 +1,18 @@\n+2016-08-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/71906\n+\t* dwarf2out.c (string_types): New variable.\n+\t(gen_array_type_die): Change early_dwarf handling of\n+\tDW_AT_string_length, create DW_OP_call4 referencing the\n+\tlength var temporarily.  Handle parameters that are pointers\n+\tto string length.\n+\t(adjust_string_types): New function.\n+\t(gen_subprogram_die): Temporarily set string_types to local var,\n+\tcall adjust_string_types if needed.\n+\t(non_dwarf_expression, copy_deref_exprloc, optimize_string_length):\n+\tNew functions.\n+\t(resolve_addr): Adjust DW_AT_string_length if it is DW_OP_call4.\n+\n 2016-08-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* doc/install.texi (*-*-solaris2*): Fix version number and document"}, {"sha": "fbf3f6ae5d01804e6e734767cd24e67e0fa5b899", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 310, "deletions": 7, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8ae261c007a5cdb70d1115d0195c32659561115f", "patch": "@@ -3123,6 +3123,10 @@ static bool frame_pointer_fb_offset_valid;\n \n static vec<dw_die_ref> base_types;\n \n+/* Pointer to vector of DW_TAG_string_type DIEs that need finalization\n+   once all arguments are parsed.  */\n+static vec<dw_die_ref> *string_types;\n+\n /* Flags to represent a set of attribute classes for attributes that represent\n    a scalar value (bounds, pointers, ...).  */\n enum dw_scalar_form\n@@ -19289,18 +19293,70 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n       if (size >= 0)\n \tadd_AT_unsigned (array_die, DW_AT_byte_size, size);\n       else if (TYPE_DOMAIN (type) != NULL_TREE\n-\t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n-\t       && DECL_P (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+\t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE)\n \t{\n \t  tree szdecl = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t  dw_loc_list_ref loc = loc_list_from_tree (szdecl, 2, NULL);\n+\t  tree rszdecl = szdecl;\n+\t  HOST_WIDE_INT rsize = 0;\n \n \t  size = int_size_in_bytes (TREE_TYPE (szdecl));\n-\t  if (loc && size > 0)\n+\t  if (!DECL_P (szdecl))\n+\t    {\n+\t      if (TREE_CODE (szdecl) == INDIRECT_REF\n+\t\t  && DECL_P (TREE_OPERAND (szdecl, 0)))\n+\t\t{\n+\t\t  rszdecl = TREE_OPERAND (szdecl, 0);\n+\t\t  rsize = int_size_in_bytes (TREE_TYPE (rszdecl));\n+\t\t  if (rsize <= 0)\n+\t\t    size = 0;\n+\t\t}\n+\t      else\n+\t\tsize = 0;\n+\t    }\n+\t  if (size > 0)\n \t    {\n-\t      add_AT_location_description (array_die, DW_AT_string_length, loc);\n-\t      if (size != DWARF2_ADDR_SIZE)\n-\t\tadd_AT_unsigned (array_die, DW_AT_byte_size, size);\n+\t      dw_loc_list_ref loc = loc_list_from_tree (szdecl, 2, NULL);\n+\t      if (loc == NULL\n+\t\t  && early_dwarf\n+\t\t  && current_function_decl\n+\t\t  && DECL_CONTEXT (rszdecl) == current_function_decl)\n+\t\t{\n+\t\t  dw_die_ref ref = lookup_decl_die (rszdecl);\n+\t\t  dw_loc_descr_ref l = NULL;\n+\t\t  if (ref)\n+\t\t    {\n+\t\t      l = new_loc_descr (DW_OP_call4, 0, 0);\n+\t\t      l->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t\t      l->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t\t      l->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t\t    }\n+\t\t  else if (TREE_CODE (rszdecl) == PARM_DECL\n+\t\t\t   && string_types)\n+\t\t    {\n+\t\t      l = new_loc_descr (DW_OP_call4, 0, 0);\n+\t\t      l->dw_loc_oprnd1.val_class = dw_val_class_decl_ref;\n+\t\t      l->dw_loc_oprnd1.v.val_decl_ref = rszdecl;\n+\t\t      string_types->safe_push (array_die);\n+\t\t    }\n+\t\t  if (l && rszdecl != szdecl)\n+\t\t    {\n+\t\t      if (rsize == DWARF2_ADDR_SIZE)\n+\t\t\tadd_loc_descr (&l, new_loc_descr (DW_OP_deref,\n+\t\t\t\t\t\t\t  0, 0));\n+\t\t      else\n+\t\t\tadd_loc_descr (&l, new_loc_descr (DW_OP_deref_size,\n+\t\t\t\t\t\t\t  rsize, 0));\n+\t\t    }\n+\t\t  if (l)\n+\t\t    loc = new_loc_list (l, NULL, NULL, NULL);\n+\t\t}\n+\t      if (loc)\n+\t\t{\n+\t\t  add_AT_location_description (array_die, DW_AT_string_length,\n+\t\t\t\t\t       loc);\n+\t\t  if (size != DWARF2_ADDR_SIZE)\n+\t\t    add_AT_unsigned (array_die, DW_AT_byte_size, size);\n+\t\t}\n \t    }\n \t}\n       return;\n@@ -19366,6 +19422,37 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n     add_pubtype (type, array_die);\n }\n \n+/* After all arguments are created, adjust any DW_TAG_string_type\n+   DIEs DW_AT_string_length attributes.  */\n+\n+static void\n+adjust_string_types (void)\n+{\n+  dw_die_ref array_die;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (*string_types, i, array_die)\n+    {\n+      dw_attr_node *a = get_AT (array_die, DW_AT_string_length);\n+      if (a == NULL)\n+\tcontinue;\n+      dw_loc_descr_ref loc = AT_loc (a);\n+      gcc_assert (loc->dw_loc_opc == DW_OP_call4\n+\t\t  && loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref);\n+      dw_die_ref ref = lookup_decl_die (loc->dw_loc_oprnd1.v.val_decl_ref);\n+      if (ref)\n+\t{\n+\t  loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+\t  loc->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+\t  loc->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+\t}\n+      else\n+\t{\n+\t  remove_AT (array_die, DW_AT_string_length);\n+\t  remove_AT (array_die, DW_AT_byte_size);\n+\t}\n+    }\n+}\n+\n /* This routine generates DIE for array with hidden descriptor, details\n    are filled into *info by a langhook.  */\n \n@@ -20806,6 +20893,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       tree generic_decl_parm = generic_decl\n \t\t\t\t? DECL_ARGUMENTS (generic_decl)\n \t\t\t\t: NULL;\n+      auto_vec<dw_die_ref> string_types_vec;\n+      if (string_types == NULL)\n+\tstring_types = &string_types_vec;\n \n       /* Now we want to walk the list of parameters of the function and\n \t emit their relevant DIEs.\n@@ -20868,6 +20958,14 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  else if (DECL_INITIAL (decl) == NULL_TREE)\n \t    gen_unspecified_parameters_die (decl, subr_die);\n \t}\n+\n+      /* Adjust DW_TAG_string_type DIEs if needed, now that all arguments\n+\t have DIEs.  */\n+      if (string_types == &string_types_vec)\n+\t{\n+\t  adjust_string_types ();\n+\t  string_types = NULL;\n+\t}\n     }\n \n   if (subr_die != old_die)\n@@ -26722,6 +26820,175 @@ optimize_location_into_implicit_ptr (dw_die_ref die, tree decl)\n     }\n }\n \n+/* Return NULL if l is a DWARF expression, or first op that is not\n+   valid DWARF expression.  */\n+\n+static dw_loc_descr_ref\n+non_dwarf_expression (dw_loc_descr_ref l)\n+{\n+  while (l)\n+    {\n+      if (l->dw_loc_opc >= DW_OP_reg0 && l->dw_loc_opc <= DW_OP_reg31)\n+\treturn l;\n+      switch (l->dw_loc_opc)\n+\t{\n+\tcase DW_OP_regx:\n+\tcase DW_OP_implicit_value:\n+\tcase DW_OP_stack_value:\n+\tcase DW_OP_GNU_implicit_pointer:\n+\tcase DW_OP_GNU_parameter_ref:\n+\tcase DW_OP_piece:\n+\tcase DW_OP_bit_piece:\n+\t  return l;\n+\tdefault:\n+\t  break;\n+\t}\n+      l = l->dw_loc_next;\n+    }\n+  return NULL;\n+}\n+\n+/* Return adjusted copy of EXPR:\n+   If it is empty DWARF expression, return it.\n+   If it is valid non-empty DWARF expression,\n+   return copy of EXPR with copy of DEREF appended to it.\n+   If it is DWARF expression followed by DW_OP_reg{N,x}, return\n+   copy of the DWARF expression with DW_OP_breg{N,x} <0> appended\n+   and no DEREF.\n+   If it is DWARF expression followed by DW_OP_stack_value, return\n+   copy of the DWARF expression without anything appended.\n+   Otherwise, return NULL.  */\n+\n+static dw_loc_descr_ref\n+copy_deref_exprloc (dw_loc_descr_ref expr, dw_loc_descr_ref deref)\n+{\n+  \n+  if (expr == NULL)\n+    return NULL;\n+\n+  dw_loc_descr_ref l = non_dwarf_expression (expr);\n+  if (l && l->dw_loc_next)\n+    return NULL;\n+\n+  if (l)\n+    {\n+      if (l->dw_loc_opc >= DW_OP_reg0 && l->dw_loc_opc <= DW_OP_reg31)\n+\tderef = new_loc_descr ((enum dwarf_location_atom)\n+\t\t\t       (DW_OP_breg0 + (l->dw_loc_opc - DW_OP_reg0)),\n+\t\t\t       0, 0);\n+      else\n+\tswitch (l->dw_loc_opc)\n+\t  {\n+\t  case DW_OP_regx:\n+\t    deref = new_loc_descr (DW_OP_bregx,\n+\t\t\t\t   l->dw_loc_oprnd1.v.val_unsigned, 0);\n+\t    break;\n+\t  case DW_OP_stack_value:\n+\t    deref = NULL;\n+\t    break;\n+\t  default:\n+\t    return NULL;\n+\t  }\n+    }\n+  else\n+    deref = new_loc_descr (deref->dw_loc_opc,\n+\t\t\t   deref->dw_loc_oprnd1.v.val_int, 0);\n+\n+  dw_loc_descr_ref ret = NULL, *p = &ret;\n+  while (expr != l)\n+    {\n+      *p = new_loc_descr (expr->dw_loc_opc, 0, 0);\n+      (*p)->dw_loc_oprnd1 = expr->dw_loc_oprnd1;\n+      (*p)->dw_loc_oprnd2 = expr->dw_loc_oprnd2;\n+      p = &(*p)->dw_loc_next;\n+      expr = expr->dw_loc_next;\n+    }\n+  *p = deref;\n+  return ret;\n+}\n+\n+/* For DW_AT_string_length attribute with DW_OP_call4 reference to a variable\n+   or argument, adjust it if needed and return:\n+   -1 if the DW_AT_string_length attribute and DW_AT_byte_size attribute\n+      if present should be removed\n+   0 keep the attribute as is if the referenced var or argument has\n+     only DWARF expression that covers all ranges\n+   1 if the attribute has been successfully adjusted.  */\n+\n+static int\n+optimize_string_length (dw_attr_node *a)\n+{\n+  dw_loc_descr_ref l = AT_loc (a), lv;\n+  dw_die_ref die = l->dw_loc_oprnd1.v.val_die_ref.die;\n+  dw_attr_node *av = get_AT (die, DW_AT_location);\n+  dw_loc_list_ref d;\n+  bool non_dwarf_expr = false;\n+\n+  if (av == NULL)\n+    return -1;\n+  switch (AT_class (av))\n+    {\n+    case dw_val_class_loc_list:\n+      for (d = AT_loc_list (av); d != NULL; d = d->dw_loc_next)\n+\tif (d->expr && non_dwarf_expression (d->expr))\n+\t  non_dwarf_expr = true;\n+      break;\n+    case dw_val_class_loc:\n+      lv = AT_loc (av);\n+      if (lv == NULL)\n+\treturn -1;\n+      if (non_dwarf_expression (lv))\n+\tnon_dwarf_expr = true;\n+      break;\n+    default:\n+      return -1;\n+    }\n+\n+  /* If it is safe to keep DW_OP_call4 in, keep it.  */\n+  if (!non_dwarf_expr\n+      && (l->dw_loc_next == NULL || AT_class (av) == dw_val_class_loc))\n+    return 0;\n+\n+  /* If not dereferencing the DW_OP_call4 afterwards, we can just\n+     copy over the DW_AT_location attribute from die to a.  */\n+  if (l->dw_loc_next == NULL)\n+    {\n+      a->dw_attr_val = av->dw_attr_val;\n+      return 1;\n+    }\n+\n+  dw_loc_list_ref list, *p;\n+  switch (AT_class (av))\n+    {\n+    case dw_val_class_loc_list:\n+      p = &list;\n+      list = NULL;\n+      for (d = AT_loc_list (av); d != NULL; d = d->dw_loc_next)\n+\t{\n+\t  lv = copy_deref_exprloc (d->expr, l->dw_loc_next);\n+\t  if (lv)\n+\t    {\n+\t      *p = new_loc_list (lv, d->begin, d->end, d->section);\n+\t      p = &(*p)->dw_loc_next;\n+\t    }\n+\t}\n+      if (list == NULL)\n+\treturn -1;\n+      a->dw_attr_val.val_class = dw_val_class_loc_list;\n+      gen_llsym (list);\n+      *AT_loc_list_ptr (a) = list;\n+      return 1;\n+    case dw_val_class_loc:\n+      lv = copy_deref_exprloc (AT_loc (av), l->dw_loc_next);\n+      if (lv == NULL)\n+\treturn -1;\n+      a->dw_attr_val.v.val_loc = lv;\n+      return 1;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Resolve DW_OP_addr and DW_AT_const_value CONST_STRING arguments to\n    an address in .rodata section if the string literal is emitted there,\n    or remove the containing location list or replace DW_AT_const_value\n@@ -26736,6 +27003,7 @@ resolve_addr (dw_die_ref die)\n   dw_attr_node *a;\n   dw_loc_list_ref *curr, *start, loc;\n   unsigned ix;\n+  bool remove_AT_byte_size = false;\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     switch (AT_class (a))\n@@ -26796,6 +27064,38 @@ resolve_addr (dw_die_ref die)\n       case dw_val_class_loc:\n \t{\n \t  dw_loc_descr_ref l = AT_loc (a);\n+\t  /* Using DW_OP_call4 or DW_OP_call4 DW_OP_deref in\n+\t     DW_AT_string_length is only a rough approximation; unfortunately\n+\t     DW_AT_string_length can't be a reference to a DIE.  DW_OP_call4\n+\t     needs a DWARF expression, while DW_AT_location of the referenced\n+\t     variable or argument might be any location description.  */\n+\t  if (a->dw_attr == DW_AT_string_length\n+\t      && l\n+\t      && l->dw_loc_opc == DW_OP_call4\n+\t      && l->dw_loc_oprnd1.val_class == dw_val_class_die_ref\n+\t      && (l->dw_loc_next == NULL\n+\t\t  || (l->dw_loc_next->dw_loc_next == NULL\n+\t\t      && (l->dw_loc_next->dw_loc_opc == DW_OP_deref\n+\t\t\t  || l->dw_loc_next->dw_loc_opc != DW_OP_deref_size))))\n+\t    {\n+\t      switch (optimize_string_length (a))\n+\t\t{\n+\t\tcase -1:\n+\t\t  remove_AT (die, a->dw_attr);\n+\t\t  ix--;\n+\t\t  /* For DWARF4 and earlier, if we drop DW_AT_string_length,\n+\t\t     we need to drop also DW_AT_byte_size.  */\n+\t\t  remove_AT_byte_size = true;\n+\t\t  continue;\n+\t\tdefault:\n+\t\t  break;\n+\t\tcase 1:\n+\t\t  /* Even if we keep the optimized DW_AT_string_length,\n+\t\t     it might have changed AT_class, so process it again.  */\n+\t\t  ix--;\n+\t\t  continue;\n+\t\t}\n+\t    }\n \t  /* For -gdwarf-2 don't attempt to optimize\n \t     DW_AT_data_member_location containing\n \t     DW_OP_plus_uconst - older consumers might\n@@ -26880,6 +27180,9 @@ resolve_addr (dw_die_ref die)\n \tbreak;\n       }\n \n+  if (remove_AT_byte_size)\n+    remove_AT (die, DW_AT_byte_size);\n+\n   FOR_EACH_CHILD (die, c, resolve_addr (c));\n }\n \f"}, {"sha": "5972a3e7e6f166d272235968e12fcf435a6fa8d4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8ae261c007a5cdb70d1115d0195c32659561115f", "patch": "@@ -1,3 +1,10 @@\n+2016-08-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/71906\n+\t* trans-decl.c (gfc_get_symbol_decl): Call gfc_finish_var_decl\n+\tfor decl's character length before gfc_finish_var_decl on the\n+\tdecl itself.\n+\n 2016-08-14  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \tPR fortran/70598"}, {"sha": "25b846e7b850a52dc1b985eaeda670314e7eb893", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae261c007a5cdb70d1115d0195c32659561115f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=8ae261c007a5cdb70d1115d0195c32659561115f", "patch": "@@ -1676,26 +1676,23 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  && !(sym->attr.use_assoc && !intrinsic_array_parameter)))\n     gfc_defer_symbol_init (sym);\n \n+  /* Associate names can use the hidden string length variable\n+     of their associated target.  */\n+  if (sym->ts.type == BT_CHARACTER\n+      && TREE_CODE (length) != INTEGER_CST)\n+    {\n+      gfc_finish_var_decl (length, sym);\n+      gcc_assert (!sym->value);\n+    }\n+\n   gfc_finish_var_decl (decl, sym);\n \n   if (sym->ts.type == BT_CHARACTER)\n-    {\n-      /* Character variables need special handling.  */\n-      gfc_allocate_lang_decl (decl);\n-\n-      /* Associate names can use the hidden string length variable\n-\t of their associated target.  */\n-      if (TREE_CODE (length) != INTEGER_CST)\n-\t{\n-\t  gfc_finish_var_decl (length, sym);\n-\t  gcc_assert (!sym->value);\n-\t}\n-    }\n+    /* Character variables need special handling.  */\n+    gfc_allocate_lang_decl (decl);\n   else if (sym->attr.subref_array_pointer)\n-    {\n-      /* We need the span for these beasts.  */\n-      gfc_allocate_lang_decl (decl);\n-    }\n+    /* We need the span for these beasts.  */\n+    gfc_allocate_lang_decl (decl);\n \n   if (sym->attr.subref_array_pointer)\n     {"}]}