{"sha": "1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg2NWRiYjVlMmNhYzJiZGNiZmRjMTM2YjU3ZWYwNzlhMWIzYWRmZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-01-25T05:59:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-01-25T05:59:18Z"}, "message": "dwarf2out.c: include \"varray.h\", not dyn-string.h.\n\n        * dwarf2out.c: include \"varray.h\", not dyn-string.h.\n        (ASM_OUTPUT_DWARF2_ADDR_CONST, ASM_NAME_TO_STRING): Lose.\n        (addr_const_to_string, addr_to_string): Lose.\n        (ASM_OUTPUT_DWARF_ADDR_CONST): Copy from dwarfout.c.\n        (struct dw_val_struct): val_addr is now an rtx.\n        (add_AT_addr, AT_addr, free_AT, output_aranges): Adjust.\n        (used_rtx_varray): New varray.\n        (dwarf2out_init): Initialize it.\n        (save_rtx): New fn.\n        (mem_loc_descriptor, add_const_value_attribute): Call it instead of\n        addr_to_string.\n        * arm/telf.h, arm/unknown-elf.h, mn10200.h, mn10300.h,\n        sparc/sp64-elf.h: Remove definition of ASM_OUTPUT_DWARF2_ADDR_CONST.\n        * Makefile.in (dwarf2out.o): Update dependencies.\n\n        * i386.c (i386_dwarf_output_addr_const): New.\n        * i386.h (ASM_OUTPUT_DWARF_ADDR_CONST): New.\n\n        * dwarf2out.c (mem_loc_descriptor): Call ASM_SIMPLIFY_DWARF_ADDR\n        if defined.\n        * dwarfout.c (output_mem_loc_descriptor): Likewise.\n        * i386.c (i386_simplify_dwarf_addr): New.\n        * i386.h (ASM_SIMPLIFY_DWARF_ADDR): New.\n\nFrom-SVN: r31602", "tree": {"sha": "9b8e288adb2c3828f86368240aa8fa0eb91ec933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b8e288adb2c3828f86368240aa8fa0eb91ec933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/comments", "author": null, "committer": null, "parents": [{"sha": "7610f2ce1bff1c54feeb451f0b40dcc3d3350389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7610f2ce1bff1c54feeb451f0b40dcc3d3350389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7610f2ce1bff1c54feeb451f0b40dcc3d3350389"}], "stats": {"total": 337, "additions": 140, "deletions": 197}, "files": [{"sha": "a3509c730cee5b9bca843175af071eba85afdfc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1,3 +1,31 @@\n+2000-01-24  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* dwarf2out.c: include \"varray.h\", not dyn-string.h.\n+\t(ASM_OUTPUT_DWARF2_ADDR_CONST, ASM_NAME_TO_STRING): Lose.\n+\t(addr_const_to_string, addr_to_string): Lose.\n+\t(ASM_OUTPUT_DWARF_ADDR_CONST): Copy from dwarfout.c.\n+\t(struct dw_val_struct): val_addr is now an rtx.\n+\t(add_AT_addr, AT_addr, free_AT, output_aranges): Adjust.\n+\t(used_rtx_varray): New varray.\n+\t(dwarf2out_init): Initialize it.\n+\t(save_rtx): New fn.\n+\t(mem_loc_descriptor, add_const_value_attribute): Call it instead of\n+\taddr_to_string.\n+\t* arm/telf.h, arm/unknown-elf.h, mn10200.h, mn10300.h, \n+\tsparc/sp64-elf.h: Remove definition of ASM_OUTPUT_DWARF2_ADDR_CONST.\n+\t* Makefile.in (dwarf2out.o): Update dependencies.\n+\n+2000-01-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386.c (i386_dwarf_output_addr_const): New.\n+\t* i386.h (ASM_OUTPUT_DWARF_ADDR_CONST): New.\n+\n+\t* dwarf2out.c (mem_loc_descriptor): Call ASM_SIMPLIFY_DWARF_ADDR\n+\tif defined.\n+\t* dwarfout.c (output_mem_loc_descriptor): Likewise.\n+\t* i386.c (i386_simplify_dwarf_addr): New.\n+\t* i386.h (ASM_SIMPLIFY_DWARF_ADDR): New.\n+\n Mon Jan 24 16:56:10 2000  Jim Wilson  <wilson@cygnus.com>\n \n \t* dwarf2out.c (gen_struct_or_union_type_die): Set complete if"}, {"sha": "65bdbb992ca85caa2f119df17f1990c54d67eca4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1532,7 +1532,7 @@ dwarfout.o : dwarfout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf.h \\\n    flags.h insn-config.h reload.h output.h defaults.h toplev.h dwarfout.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf2.h \\\n    flags.h insn-config.h reload.h output.h defaults.h \\\n-   hard-reg-set.h $(REGS_H) $(EXPR_H) toplev.h dwarf2out.h dyn-string.h \\\n+   hard-reg-set.h $(REGS_H) $(EXPR_H) toplev.h dwarf2out.h varray.h \\\n    ggc.h except.h\n xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h ggc.h"}, {"sha": "65a74b3c6fd1a23ac877439d48b513eeea7120f6", "filename": "gcc/config/arm/telf.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Farm%2Ftelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Farm%2Ftelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftelf.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for Thumb with ELF obj format.\n-   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1999, 2000 Free Software Foundation, Inc.\n    \n This file is part of GNU CC.\n \n@@ -141,13 +141,6 @@ extern int arm_structure_size_boundary;\n    dwarf2.out. */ \n #define UNALIGNED_WORD_ASM_OP \".4byte\"\n \n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)\t\t\t\\\n- if (((ADDR)[0] == '.') && ((ADDR)[1] == 'L')) \t\t\t\\\n-   fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, (ADDR));\t\\\n- else                                                     \t\\\n-  fprintf ((FILE), \"\\t%s\\t%s\",\t\t\t\t\t\\\n-           UNALIGNED_WORD_ASM_OP, (ADDR))\n-\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\"}, {"sha": "331c765081df8eea3fb1a5f08db2565c372bfbdc", "filename": "gcc/config/arm/unknown-elf.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Farm%2Funknown-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Farm%2Funknown-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for non-Linux based ARM systems using ELF\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Catherine Moore <clm@cygnus.com>\n \n This file is part of GNU CC.\n@@ -107,9 +107,6 @@ func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n    dwarf2.out. */ \n #define UNALIGNED_WORD_ASM_OP \".4byte\"\n \n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)                  \\\n-     fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, ADDR)\n-\n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)                   \\\n do {\t\t\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_WORD_ASM_OP);\t\t\\"}, {"sha": "9d4076846797e7b4b5a93180e0c9bb08eaf4ebc9", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -82,6 +82,9 @@ extern const char *output_387_binary_op PARAMS ((rtx, rtx*));\n extern const char *output_fix_trunc PARAMS ((rtx, rtx*));\n extern const char *output_fp_compare PARAMS ((rtx, rtx*, int, int));\n \n+extern void i386_dwarf_output_addr_const PARAMS ((FILE*, rtx));\n+extern rtx i386_simplify_dwarf_addr PARAMS ((rtx));\n+\n extern void ix86_expand_move PARAMS ((enum machine_mode, rtx[]));\n extern void ix86_expand_binary_operator PARAMS ((enum rtx_code,\n \t\t\t\t\t       enum machine_mode, rtx[]));"}, {"sha": "a5f2524bce6e141bfe8163b4d1b11e7558959138", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -2818,6 +2818,51 @@ output_pic_addr_const (file, x, code)\n       output_operand_lossage (\"invalid expression as operand\");\n     }\n }\n+\n+/* This is called from dwarfout.c via ASM_OUTPUT_DWARF_ADDR_CONST.  \n+   We need to handle our special PIC relocations.  */\n+\n+void \n+i386_dwarf_output_addr_const (file, x)\n+     FILE *file;\n+     rtx x;\n+{\n+  fprintf (file, \"\\t%s\\t\", INT_ASM_OP);\n+  if (flag_pic)\n+    output_pic_addr_const (file, x, '\\0');\n+  else\n+    output_addr_const (file, x);\n+  fputc ('\\n', file);\n+}\n+\n+/* In the name of slightly smaller debug output, and to cater to\n+   general assembler losage, recognize PIC+GOTOFF and turn it back\n+   into a direct symbol reference.  */\n+\n+rtx\n+i386_simplify_dwarf_addr (orig_x)\n+     rtx orig_x;\n+{\n+  rtx x = orig_x;\n+\n+  if (GET_CODE (x) != PLUS\n+      || GET_CODE (XEXP (x, 0)) != REG\n+      || GET_CODE (XEXP (x, 1)) != CONST)\n+    return orig_x;\n+\n+  x = XEXP (XEXP (x, 1), 0);\n+  if (GET_CODE (x) == UNSPEC\n+      && XINT (x, 1) == 7)\n+    return XVECEXP (x, 0, 0);\n+\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == UNSPEC\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && XINT (XEXP (x, 0), 1) == 7)\n+    return gen_rtx_PLUS (VOIDmode, XVECEXP (XEXP (x, 0), 0, 0), XEXP (x, 1));\n+\n+  return orig_x;\n+}\n \f\n static void\n put_condition_code (code, mode, reverse, fp, file)"}, {"sha": "c6af71f8180514c924c60be0b10e4cfb695ab389", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -2309,6 +2309,17 @@ do { long l;\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t%s\\t%s%d-%s%d\\n\",ASM_LONG, LPREFIX, VALUE, LPREFIX, REL)\n \n+/* A C statement that outputs an address constant appropriate to \n+   for DWARF debugging.  */\n+\n+#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,X) \\\n+  i386_dwarf_output_addr_const((FILE),(X))\n+\n+/* Either simplify a location expression, or return the original.  */\n+\n+#define ASM_SIMPLIFY_DWARF_ADDR(X) \\\n+  i386_simplify_dwarf_addr(X)\n+\n /* Define the parentheses used to group arithmetic operations\n    in assembler code.  */\n "}, {"sha": "60928c4dab3ef8807d0e82f12303e35ddfb1eaa3", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -981,10 +981,6 @@ do { char dstr[30];\t\t\t\t\t\\\n   ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n     + (frame_pointer_needed ? 0 : -total_frame_size ()))\n \n-/* We need to prepend underscores.  */\n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR) \\\n-  fprintf ((FILE), \"\\t%s\\t_%s\", UNALIGNED_WORD_ASM_OP, (ADDR))\n-  \n /* Define to use software floating point emulator for REAL_ARITHMETIC and\n    decimal <-> binary conversion. */\n #define REAL_ARITHMETIC"}, {"sha": "403091e8c5f97622f8accc98ecc807cb7a65000a", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1028,10 +1028,6 @@ do { char dstr[30];\t\t\t\t\t\\\n     + (frame_pointer_needed \\\n        ? 0 : -initial_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM)))\n \n-/* We need to prepend underscores.  */\n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR) \\\n-  fprintf ((FILE), \"\\t%s\\t_%s\", UNALIGNED_WORD_ASM_OP, (ADDR))\n-\n /* Define to use software floating point emulator for REAL_ARITHMETIC and\n    decimal <-> binary conversion. */\n #define REAL_ARITHMETIC"}, {"sha": "4ce12ed7fff67b6e840d7d0913b3dc2e60a99eee", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for SPARC64, ELF.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998  Free Software Foundation, Inc.\n+   Copyright (C) 1994, 95, 96, 97, 98, 2000  Free Software Foundation, Inc.\n    Contributed by Doug Evans, dje@cygnus.com.\n \n This file is part of GNU CC.\n@@ -146,9 +146,6 @@ do {\t\t\t\t\t\t\t\t\\\n   fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n } while (0)\n \n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE, ADDR) \\\n-  fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_LONGLONG_ASM_OP, (ADDR))\n-\n /* ??? Not sure if this should be 4 or 8 bytes.  4 works for now.  */\n #define ASM_OUTPUT_DWARF_REF(FILE, LABEL) \\\n do {\t\t\t\t\t\t\t\t\\"}, {"sha": "22c515b702456e25bf9affeb3facd77622d83211", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 45, "deletions": 172, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -53,7 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"dwarf2.h\"\n #include \"dwarf2out.h\"\n #include \"toplev.h\"\n-#include \"dyn-string.h\"\n+#include \"varray.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n \n@@ -357,19 +357,13 @@ static void dwarf2out_frame_debug_expr\tPARAMS ((rtx, char *));\n   } while (0)\n #endif\n \n-/* ??? This macro takes an RTX in dwarfout.c and a string in dwarf2out.c.\n-   We resolve the conflict by creating a new macro ASM_OUTPUT_DWARF2_ADDR_CONST\n-   for ports that want to support both DWARF1 and DWARF2.  This needs a better\n-   solution.  See also the comments in sparc/sp64-elf.h.  */\n-#ifdef ASM_OUTPUT_DWARF2_ADDR_CONST\n-#undef ASM_OUTPUT_DWARF_ADDR_CONST\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,ADDR) \\\n-  ASM_OUTPUT_DWARF2_ADDR_CONST (FILE, ADDR)\n-#endif\n-\n #ifndef ASM_OUTPUT_DWARF_ADDR_CONST\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,ADDR)\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_WORD_ASM_OP, (ADDR))\n+#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n+    output_addr_const ((FILE), (RTX));\t\t\t\t\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_OFFSET4\n@@ -2025,7 +2019,7 @@ typedef struct dw_val_struct\n   dw_val_class val_class;\n   union\n     {\n-      char *val_addr;\n+      rtx val_addr;\n       dw_loc_descr_ref val_loc;\n       long int val_int;\n       long unsigned val_unsigned;\n@@ -2330,10 +2324,14 @@ static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n #endif\n \n+/* Array of RTXes referenced by the debugging information, which therefore\n+   must be kept around forever.  We do this rather than perform GC on\n+   the dwarf info because almost all of the dwarf info lives forever, and\n+   it's easier to support non-GC frontends this way.  */\n+static varray_type used_rtx_varray;\n+\n /* Forward declarations for functions defined in this file.  */\n \n-static void addr_const_to_string\tPARAMS ((dyn_string_t, rtx));\n-static char *addr_to_string\t\tPARAMS ((rtx));\n static int is_pseudo_reg\t\tPARAMS ((rtx));\n static tree type_main_variant\t\tPARAMS ((tree));\n static int is_tagged_type\t\tPARAMS ((tree));\n@@ -2377,7 +2375,7 @@ static void add_AT_loc\t\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t dw_loc_descr_ref));\n static void add_AT_addr\t\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n-\t\t\t\t\t\t char *));\n+\t\t\t\t\t\t rtx));\n static void add_AT_lbl_id\t\tPARAMS ((dw_die_ref,\n \t\t\t\t\t\t enum dwarf_attribute,\n \t\t\t\t\t\t char *));\n@@ -2614,25 +2612,6 @@ static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef SEPARATE_LINE_CODE_LABEL\n #define SEPARATE_LINE_CODE_LABEL\t\"LSM\"\n #endif\n-\n-/* Convert a reference to the assembler name of a C-level name.  This\n-   macro has the same effect as ASM_OUTPUT_LABELREF, but copies to\n-   a string rather than writing to a file.  */\n-#ifndef ASM_NAME_TO_STRING\n-#define ASM_NAME_TO_STRING(STR, NAME)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-      if ((NAME)[0] == '*')\t\t\t\t\\\n-\tdyn_string_append (STR, NAME + 1);\t\t\\\n-      else\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  const char *newstr;\t\t\t\t\\\n-\t  STRIP_NAME_ENCODING (newstr, NAME);\t\t\\\n-\t  dyn_string_append (STR, user_label_prefix);\t\\\n-\t  dyn_string_append (STR, newstr);\t\t\\\n-\t}\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-  while (0)\n-#endif\n \f\n /* We allow a language front-end to designate a function that is to be\n    called to \"demangle\" any name before it it put into a DIE.  */\n@@ -2646,141 +2625,25 @@ dwarf2out_set_demangle_name_func (func)\n   demangle_name_func = func;\n }\n \f\n-/* Convert an integer constant expression into assembler syntax.  Addition\n-   and subtraction are the only arithmetic that may appear in these\n-   expressions.   This is an adaptation of output_addr_const in final.c.\n-   Here, the target of the conversion is a string buffer.  We can't use\n-   output_addr_const directly, because it writes to a file.  */\n+/* Return an rtx like ORIG which lives forever.  If we're doing GC,\n+   that means adding it to used_rtx_varray.  If not, that means making\n+   a copy on the permanent_obstack.  */\n \n-static void\n-addr_const_to_string (str, x)\n-     dyn_string_t str;\n-     rtx x;\n+static rtx\n+save_rtx (orig)\n+     register rtx orig;\n {\n-  char buf1[256];\n-\n-restart:\n-  switch (GET_CODE (x))\n+  if (ggc_p)\n+    VARRAY_PUSH_RTX (used_rtx_varray, orig);\n+  else\n     {\n-    case PC:\n-      if (flag_pic)\n-\tdyn_string_append (str, \",\");\n-      else\n-\tabort ();\n-      break;\n-\n-    case SYMBOL_REF:\n-      ASM_NAME_TO_STRING (str, XSTR (x, 0));\n-      break;\n-\n-    case LABEL_REF:\n-      ASM_GENERATE_INTERNAL_LABEL (buf1, \"L\", CODE_LABEL_NUMBER (XEXP (x, 0)));\n-      ASM_NAME_TO_STRING (str, buf1);\n-      break;\n-\n-    case CODE_LABEL:\n-      ASM_GENERATE_INTERNAL_LABEL (buf1, \"L\", CODE_LABEL_NUMBER (x));\n-      ASM_NAME_TO_STRING (str, buf1);\n-      break;\n-\n-    case CONST_INT:\n-      sprintf (buf1, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n-      dyn_string_append (str, buf1);\n-      break;\n-\n-    case CONST:\n-      /* This used to output parentheses around the expression, but that does \n-         not work on the 386 (either ATT or BSD assembler).  */\n-      addr_const_to_string (str, XEXP (x, 0));\n-      break;\n-\n-    case CONST_DOUBLE:\n-      if (GET_MODE (x) == VOIDmode)\n-\t{\n-\t  /* We can use %d if the number is one word and positive.  */\n-\t  if (CONST_DOUBLE_HIGH (x))\n-\t    sprintf (buf1, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n-\t\t     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n-\t  else if (CONST_DOUBLE_LOW (x) < 0)\n-\t    sprintf (buf1, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_LOW (x));\n-\t  else\n-\t    sprintf (buf1, HOST_WIDE_INT_PRINT_DEC,\n-\t\t     CONST_DOUBLE_LOW (x));\n-\t  dyn_string_append (str, buf1);\n-\t}\n-      else\n-\t/* We can't handle floating point constants; PRINT_OPERAND must\n-\t   handle them.  */\n-\toutput_operand_lossage (\"floating constant misused\");\n-      break;\n-\n-    case PLUS:\n-      /* Some assemblers need integer constants to appear last (eg masm).  */\n-      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n-\t{\n-\t  addr_const_to_string (str, XEXP (x, 1));\n-\t  if (INTVAL (XEXP (x, 0)) >= 0)\n-\t    dyn_string_append (str, \"+\");\n-\n-\t  addr_const_to_string (str, XEXP (x, 0));\n-\t}\n-      else\n-\t{\n-\t  addr_const_to_string (str, XEXP (x, 0));\n-\t  if (INTVAL (XEXP (x, 1)) >= 0)\n-\t    dyn_string_append (str, \"+\");\n-\n-\t  addr_const_to_string (str, XEXP (x, 1));\n-\t}\n-      break;\n-\n-    case MINUS:\n-      /* Avoid outputting things like x-x or x+5-x, since some assemblers\n-         can't handle that.  */\n-      x = simplify_subtraction (x);\n-      if (GET_CODE (x) != MINUS)\n-\tgoto restart;\n-\n-      addr_const_to_string (str, XEXP (x, 0));\n-      dyn_string_append (str, \"-\");\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) < 0)\n-\t{\n-\t  dyn_string_append (str, ASM_OPEN_PAREN);\n-\t  addr_const_to_string (str, XEXP (x, 1));\n-\t  dyn_string_append (str, ASM_CLOSE_PAREN);\n-\t}\n-      else\n-\taddr_const_to_string (str, XEXP (x, 1));\n-      break;\n-\n-    case ZERO_EXTEND:\n-    case SIGN_EXTEND:\n-      addr_const_to_string (str, XEXP (x, 0));\n-      break;\n-\n-    default:\n-      output_operand_lossage (\"invalid expression as operand\");\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      orig = copy_rtx (orig);\n+      pop_obstacks ();\n     }\n-}\n-\n-/* Convert an address constant to a string, and return a pointer to\n-   a copy of the result, located on the heap.  */\n-\n-static char *\n-addr_to_string (x)\n-     rtx x;\n-{\n-  dyn_string_t ds = dyn_string_new (256);\n-  char *s;\n \n-  addr_const_to_string (ds, x);\n-  \n-  /* Return the dynamically allocated string, but free the\n-     dyn_string_t itself.  */\n-  s = ds->s;\n-  free (ds);\n-  return s;\n+  return orig;\n }\n \n /* Test if rtl node points to a pseudo register.  */\n@@ -3837,7 +3700,7 @@ static inline void\n add_AT_addr (die, attr_kind, addr)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n-     char *addr;\n+     rtx addr;\n {\n   register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n@@ -3848,7 +3711,7 @@ add_AT_addr (die, attr_kind, addr)\n   add_dwarf_attr (die, attr);\n }\n \n-static inline const char *\n+static inline rtx\n AT_addr (a)\n      register dw_attr_ref a;\n {\n@@ -4029,7 +3892,6 @@ free_AT (a)\n {\n   switch (AT_class (a))\n     {\n-    case dw_val_class_addr:\n     case dw_val_class_str:\n     case dw_val_class_lbl_id:\n     case dw_val_class_lbl_offset:\n@@ -5533,7 +5395,8 @@ output_aranges ()\n \t  if (loc->dw_loc_opc != DW_OP_addr)\n \t    abort ();\n \n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, loc->dw_loc_oprnd1.v.val_addr);\n+\t  ASM_OUTPUT_DWARF_ADDR_CONST (asm_out_file,\n+\t\t\t\t       loc->dw_loc_oprnd1.v.val_addr);\n \t}\n \n       if (flag_debug_asm)\n@@ -6433,6 +6296,10 @@ mem_loc_descriptor (rtl, mode)\n      actually within the array.  That's *not* necessarily the same as the\n      zeroth element of the array.  */\n \n+#ifdef ASM_SIMPLIFY_DWARF_ADDR\n+  rtl = ASM_SIMPLIFY_DWARF_ADDR (rtl);\n+#endif\n+\n   switch (GET_CODE (rtl))\n     {\n     case POST_INC:\n@@ -6482,7 +6349,7 @@ mem_loc_descriptor (rtl, mode)\n     case SYMBOL_REF:\n       mem_loc_result = new_loc_descr (DW_OP_addr, 0, 0);\n       mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_addr;\n-      mem_loc_result->dw_loc_oprnd1.v.val_addr = addr_to_string (rtl);\n+      mem_loc_result->dw_loc_oprnd1.v.val_addr = save_rtx (rtl);\n       break;\n \n     case PRE_INC:\n@@ -6942,7 +6809,7 @@ add_const_value_attribute (die, rtl)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST:\n-      add_AT_addr (die, DW_AT_const_value, addr_to_string (rtl));\n+      add_AT_addr (die, DW_AT_const_value, save_rtx (rtl));\n       break;\n \n     case PLUS:\n@@ -9959,6 +9826,12 @@ dwarf2out_init (asm_out_file, main_input_filename)\n      invoked when the given (base) source file was compiled.  */\n   comp_unit_die = gen_compile_unit_die (main_input_filename);\n \n+  if (ggc_p)\n+    {\n+      VARRAY_RTX_INIT (used_rtx_varray, 32, \"used_rtx_varray\");\n+      ggc_add_tree_varray_root (&used_rtx_varray, 1);\n+    }\n+\n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label, ABBREV_SECTION_LABEL, 0);\n   if (DWARF2_GENERATE_TEXT_SECTION_LABEL)"}, {"sha": "e8809361017831712dd9242d89f08dda24ae565b", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=1865dbb5e2cac2bdcbfdc136b57ef079a1b3adff", "patch": "@@ -1715,6 +1715,10 @@ output_mem_loc_descriptor (rtl)\n      which is actually within the array.  That's *not* necessarily the\n      same as the zeroth element of the array.  */\n \n+#ifdef ASM_SIMPLIFY_DWARF_ADDR\n+  rtl = ASM_SIMPLIFY_DWARF_ADDR (rtl);\n+#endif\n+\n   switch (GET_CODE (rtl))\n     {\n       case SUBREG:"}]}