{"sha": "a82289f536862ea01ae5b221f0e1e3a79eb5b541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyMjg5ZjUzNjg2MmVhMDFhZTViMjIxZjBlMWUzYTc5ZWI1YjU0MQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-02-06T23:19:32Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-02-06T23:19:32Z"}, "message": "PR jit/64752 - Rewrite jit testsuite to eliminate use of \"file\"\n\ngcc/testsuite/ChangeLog:\n\tPR jit/64752\n\t* jit.dg/create-code-for-hello-world-executable.h: New file, taken\n\tfrom jit.dg/test-compile-to-executable.c's create_code, with a\n\tclarification of the output message.\n\t* jit.dg/harness.h (CHECK_NO_ERRORS): Add test and __func__ to the\n\tpass/fail message.\n\t(test_jit): Use CHECK_NO_ERRORS when calling\n\tgcc_jit_context_compile_to_file.\n\t* jit.dg/jit.exp (jit-dg-test): Update grep for rename of\n\tjit-verify-compile-to-file to jit-verify-output-file-was-created.\n\t(jit-setup-compile-to-file): Likewise.  Add a verbose comment\n\tabout deletions that are attempted.\n\t(jit-verify-compile-to-file): Rename to...\n\t(jit-verify-output-file-was-created): ...this, and drop the\n\tattempt to run \"file\" and verify the output.\n\t(jit-verify-assembler): New function.\n\t(jit-verify-object): New function.\n\t(jit-verify-dynamic-library): New function.\n\t* jit.dg/test-compile-to-assembler.c (create_code): Eliminate in\n\tfavor of an implementation from new file\n\tcreate-code-for-hello-world-executable.h, which also adds a\n\t\"main\".\n\t(dg-final): Replace jit-verify-compile-to-file with\n\tjit-verify-output-file-was-created, and invoke new function\n\tjit-verify-assembler.\n\t* jit.dg/test-compile-to-dynamic-library.c (create_code): Clarify\n\tthe output message.\n\t(dg-final): Replace jit-verify-compile-to-file with\n\tjit-verify-output-file-was-created, and invoke new function\n\tjit-verify-dynamic-library.\n\t* jit.dg/test-compile-to-executable.c (create_code): Eliminate in\n\tfavor of an implementation from new file\n\tcreate-code-for-hello-world-executable.h, which also adds a\n\t\"main\".\n\t(dg-final): Replace jit-verify-compile-to-file with\n\tjit-verify-output-file-was-created.  Strengthen the expected stdout\n\tfrom the built executable.\n\t* jit.dg/test-compile-to-object.c (create_code): Eliminate in\n\tfavor of an implementation from new file\n\tcreate-code-for-hello-world-executable.h, which also adds a\n\t\"main\".\n\t(dg-final): Replace jit-verify-compile-to-file with\n\tjit-verify-output-file-was-created, and invoke new function\n\tjit-verify-object.\n\t* jit.dg/verify-dynamic-library.c: New source file.\n\nFrom-SVN: r220494", "tree": {"sha": "d04c75fc76af49ba9707bb68e973dee63a8c0473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d04c75fc76af49ba9707bb68e973dee63a8c0473"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a82289f536862ea01ae5b221f0e1e3a79eb5b541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82289f536862ea01ae5b221f0e1e3a79eb5b541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82289f536862ea01ae5b221f0e1e3a79eb5b541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82289f536862ea01ae5b221f0e1e3a79eb5b541/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45beb02eb0ab4714349e56e854c96cf2910a1f1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45beb02eb0ab4714349e56e854c96cf2910a1f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45beb02eb0ab4714349e56e854c96cf2910a1f1b"}], "stats": {"total": 466, "additions": 218, "deletions": 248}, "files": [{"sha": "dbe52cf0fd6f5c6388339a77fbcecf3dab84bc48", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -1,3 +1,51 @@\n+2015-02-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR jit/64752\n+\t* jit.dg/create-code-for-hello-world-executable.h: New file, taken\n+\tfrom jit.dg/test-compile-to-executable.c's create_code, with a\n+\tclarification of the output message.\n+\t* jit.dg/harness.h (CHECK_NO_ERRORS): Add test and __func__ to the\n+\tpass/fail message.\n+\t(test_jit): Use CHECK_NO_ERRORS when calling\n+\tgcc_jit_context_compile_to_file.\n+\t* jit.dg/jit.exp (jit-dg-test): Update grep for rename of\n+\tjit-verify-compile-to-file to jit-verify-output-file-was-created.\n+\t(jit-setup-compile-to-file): Likewise.  Add a verbose comment\n+\tabout deletions that are attempted.\n+\t(jit-verify-compile-to-file): Rename to...\n+\t(jit-verify-output-file-was-created): ...this, and drop the\n+\tattempt to run \"file\" and verify the output.\n+\t(jit-verify-assembler): New function.\n+\t(jit-verify-object): New function.\n+\t(jit-verify-dynamic-library): New function.\n+\t* jit.dg/test-compile-to-assembler.c (create_code): Eliminate in\n+\tfavor of an implementation from new file\n+\tcreate-code-for-hello-world-executable.h, which also adds a\n+\t\"main\".\n+\t(dg-final): Replace jit-verify-compile-to-file with\n+\tjit-verify-output-file-was-created, and invoke new function\n+\tjit-verify-assembler.\n+\t* jit.dg/test-compile-to-dynamic-library.c (create_code): Clarify\n+\tthe output message.\n+\t(dg-final): Replace jit-verify-compile-to-file with\n+\tjit-verify-output-file-was-created, and invoke new function\n+\tjit-verify-dynamic-library.\n+\t* jit.dg/test-compile-to-executable.c (create_code): Eliminate in\n+\tfavor of an implementation from new file\n+\tcreate-code-for-hello-world-executable.h, which also adds a\n+\t\"main\".\n+\t(dg-final): Replace jit-verify-compile-to-file with\n+\tjit-verify-output-file-was-created.  Strengthen the expected stdout\n+\tfrom the built executable.\n+\t* jit.dg/test-compile-to-object.c (create_code): Eliminate in\n+\tfavor of an implementation from new file\n+\tcreate-code-for-hello-world-executable.h, which also adds a\n+\t\"main\".\n+\t(dg-final): Replace jit-verify-compile-to-file with\n+\tjit-verify-output-file-was-created, and invoke new function\n+\tjit-verify-object.\n+\t* jit.dg/verify-dynamic-library.c: New source file.\n+\n 2015-02-06  Sebastian Pop  <s.pop@samsung.com>\n \t    Brian Rzycki  <b.rzycki@samsung.com>\n "}, {"sha": "907da5620b1aa2418077349d65eb7ef9a494a8c3", "filename": "gcc/testsuite/jit.dg/harness.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -112,9 +112,9 @@ static char test[1024];\n   do { \\\n     const char *err = gcc_jit_context_get_first_error (CTXT); \\\n     if (err) \\\n-      fail (\"error unexpectedly occurred: %s\", err); \\\n+      fail (\"%s: %s: error unexpectedly occurred: %s\", test, __func__, err); \\\n     else \\\n-      pass (\"no errors occurred\"); \\\n+      pass (\"%s: %s: no errors occurred\", test, __func__); \\\n   } while (0)\n \n /* Hooks that testcases should provide.  */\n@@ -362,6 +362,7 @@ test_jit (const char *argv0, void *user_data)\n   gcc_jit_context_compile_to_file (ctxt,\n \t\t\t\t   (OUTPUT_KIND),\n \t\t\t\t   (OUTPUT_FILENAME));\n+  CHECK_NO_ERRORS (ctxt);\n #else /* #ifdef TEST_COMPILING_TO_FILE */\n   /* This actually calls into GCC and runs the build, all\n      in a mutex for now.  */"}, {"sha": "d13f6b5e19143ec5a0636386eb642e763eb9f739", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "modified", "additions": 154, "deletions": 33, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -375,11 +375,10 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n \tappend extra_tool_flags \" -lpthread\"\n     }\n \n-    # Any test case that uses\n-    #   { dg-final { jit-verify-compile-to-file FOO } }\n+    # Any test case that uses jit-verify-output-file-was-created\n     # needs to call jit-setup-compile-to-file here.\n     # (is there a better way to handle setup/finish pairs in dg?)\n-    set tmp [grep $prog \"jit-verify-compile-to-file\"]\n+    set tmp [grep $prog \"jit-verify-output-file-was-created\"]\n     if {![string match \"\" $tmp]} {\n \tjit-setup-compile-to-file $prog\n     }\n@@ -601,7 +600,7 @@ proc jit-get-output-filename {prog} {\n     return \"\"\n }\n \n-# For testcases that use jit-verify-compile-to-file,\n+# For testcases that use jit-verify-output-file-was-created\n # delete OUTPUT_FILENAME beforehand, to ensure that the\n # testcase is indeed creating it.\n \n@@ -610,21 +609,13 @@ proc jit-setup-compile-to-file { prog } {\n     set output_filename [jit-get-output-filename $prog]\n     verbose \"  output_filename: $output_filename\"\n     if {![string match \"\" $output_filename]} {\n+\tverbose \"  deleting any $output_filename\"\n \tcatch \"exec rm -f $output_filename\"\n     }\n }\n \n-# Locate OUTPUT_FILENAME within the testcase.  Verify\n-# that a file with that name was created, and that\n-# the output of running the \"file\" utility on it\n-# matches the given regex.\n-# For use by the various test-compile-to-*.c testcases.\n-\n-proc jit-verify-compile-to-file {args} {\n-    verbose \"jit-verify-compile-to-file: $args\"\n-\n-    set file_regex [lindex $args 0]\n-    verbose \"file_regex: $file_regex\"\n+proc jit-verify-output-file-was-created { args } {\n+    verbose \"jit-verify-output-file-was-created: $args\"\n \n     upvar 2 prog prog\n     verbose \"prog: $prog\"\n@@ -636,25 +627,7 @@ proc jit-verify-compile-to-file {args} {\n \tpass \"$output_filename exists\"\n     } else {\n \tfail \"$output_filename does not exist\"\n-\treturn\n-    }\n-\n-    # Run \"file\" on OUTPUT_FILENAME, and verify that the output\n-    # matches $file_regex.\n-    spawn -noecho \"file\" $output_filename\n-    set file_id $spawn_id\n-    expect \"\\n\" {\n-\tverbose \"got newline: $expect_out(buffer)\"\n-\tset classification $expect_out(buffer)\n-\tverbose \"classification: $classification\"\n-\tif { [regexp $file_regex $classification] } {\n-\t    pass \"'file' output on $output_filename matched: $file_regex\"\n-\t} else {\n-\t    fail \"'file' output on $output_filename did not match: $file_regex\"\n-\t}\n     }\n-    set $spawn_id $file_id\n-    close\n }\n \n # Verify that the given file exists, and is executable.\n@@ -709,6 +682,154 @@ proc jit-run-executable { args } {\n     }\n }\n \n+# Assuming that a .s file has been written out named\n+# OUTPUT_FILENAME, invoke the driver to try to turn it into\n+# an executable, and try to run the result.\n+# For use by the test-compile-to-assembler.c testcase.\n+proc jit-verify-assembler { args } {\n+    verbose \"jit-verify-assembler: $args\"\n+\n+    set dg-output-text [lindex $args 0]\n+    verbose \"dg-output-text: ${dg-output-text}\"\n+\n+    upvar 2 name name\n+    verbose \"name: $name\"\n+\n+    upvar 2 prog prog\n+    verbose \"prog: $prog\"\n+    set asm_filename [jit-get-output-filename $prog]\n+    verbose \"  asm_filename: ${asm_filename}\"\n+\n+    # Name the built executable as OUTPUT_FILENAME with\n+    # \".exe\" appended.\n+    set executable_from_asm ${asm_filename}.exe\n+    verbose \"  executable_from_asm: ${executable_from_asm}\"\n+\n+    # Invoke the driver to assemble/link the .s file to the .exe\n+    set comp_output [gcc_target_compile \\\n+\t\t\t ${asm_filename} \\\n+\t\t\t ${executable_from_asm} \\\n+\t\t\t \"executable\" \\\n+\t\t\t \"{}\"]\n+    if ![jit_check_compile \\\n+\t     \"$name\" \\\n+\t     \"assemble/link of ${asm_filename}\" \\\n+\t     ${executable_from_asm} \\\n+\t     $comp_output] then {\n+      return\n+    }\n+\n+    # Verify that the executable was created.\n+    if { [file exists $executable_from_asm] == 1} {\n+\tpass \"$executable_from_asm exists\"\n+    } else {\n+\tfail \"$executable_from_asm does not exist\"\n+    }\n+\n+    # Run it and verify that the output matches the regex.\n+    jit-run-executable ${executable_from_asm} ${dg-output-text}\n+}\n+\n+# Assuming that a .o file has been written out named\n+# OUTPUT_FILENAME, invoke the driver to try to turn it into\n+# an executable, and try to run the result.\n+# For use by the test-compile-to-object.c testcase.\n+proc jit-verify-object { args } {\n+    verbose \"jit-verify-object: $args\"\n+\n+    set dg-output-text [lindex $args 0]\n+    verbose \"dg-output-text: ${dg-output-text}\"\n+\n+    upvar 2 name name\n+    verbose \"name: $name\"\n+\n+    upvar 2 prog prog\n+    verbose \"prog: $prog\"\n+    set obj_filename [jit-get-output-filename $prog]\n+    verbose \"  obj_filename: ${obj_filename}\"\n+\n+    # Name the linked executable as OUTPUT_FILENAME with\n+    # \".exe\" appended.\n+    set executable_from_obj ${obj_filename}.exe\n+    verbose \"  executable_from_obj: ${executable_from_obj}\"\n+\n+    # Invoke the driver to link the .o file to the .exe\n+    set comp_output [gcc_target_compile \\\n+\t\t\t ${obj_filename} \\\n+\t\t\t ${executable_from_obj} \\\n+\t\t\t \"executable\" \\\n+\t\t\t \"{}\"]\n+    if ![jit_check_compile \\\n+\t     \"$name\" \\\n+\t     \"link of ${obj_filename}\" \\\n+\t     ${executable_from_obj} \\\n+\t     $comp_output] then {\n+      return\n+    }\n+\n+    # Verify that the executable was created.\n+    if { [file exists $executable_from_obj] == 1} {\n+\tpass \"$executable_from_obj exists\"\n+    } else {\n+\tfail \"$executable_from_obj does not exist\"\n+    }\n+\n+    # Run it and verify that the output matches the regex.\n+    jit-run-executable ${executable_from_obj} ${dg-output-text}\n+}\n+\n+# Assuming that a .so file has been written out named\n+# OUTPUT_FILENAME, build a test executable to use it,\n+# and try to run the result.\n+# For use by the test-compile-to-dynamic-library.c testcase.\n+proc jit-verify-dynamic-library { args } {\n+    verbose \"jit-verify-object: $args\"\n+\n+    global srcdir\n+    global subdir\n+\n+    set dg-output-text [lindex $args 0]\n+    verbose \"dg-output-text: ${dg-output-text}\"\n+\n+    upvar 2 name name\n+    verbose \"name: $name\"\n+\n+    upvar 2 prog prog\n+    verbose \"prog: $prog\"\n+    set obj_filename [jit-get-output-filename $prog]\n+    verbose \"  obj_filename: ${obj_filename}\"\n+\n+    # Build a test executable from\n+    # verify-dynamic-library.c\n+    set test_src \"verify-dynamic-library.c\"\n+    set test_executable ${test_src}.exe\n+    verbose \"  test_executable: ${test_executable}\"\n+\n+    # Invoke the driver to build the test executable\n+    set comp_output [gcc_target_compile \\\n+\t\t\t $srcdir/$subdir/${test_src} \\\n+\t\t\t ${test_executable} \\\n+\t\t\t \"executable\" \\\n+\t\t\t \"{additional_flags=-ldl}\"]\n+    if ![jit_check_compile \\\n+\t     \"$name\" \\\n+\t     \"build of ${test_executable}\" \\\n+\t     ${test_executable} \\\n+\t     $comp_output] then {\n+      return\n+    }\n+\n+    # Verify that the test executable was created.\n+    if { [file exists $test_executable] == 1} {\n+\tpass \"$test_executable exists\"\n+    } else {\n+\tfail \"$test_executable does not exist\"\n+    }\n+\n+    # Run it and verify that the output matches the regex.\n+    jit-run-executable ${test_executable} ${dg-output-text}\n+}\n+\n # A way to invoke \"jit-run-executable\" with the given regex,\n # using OUTPUT_FILENAME within the testcase to determine\n # the name of the executable to run."}, {"sha": "e3a6d2edd20898b0b2cd47e6a88ae6ac9724c7fa", "filename": "gcc/testsuite/jit.dg/test-compile-to-assembler.c", "status": "modified", "additions": 3, "deletions": 55, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-assembler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-assembler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-assembler.c?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -7,59 +7,7 @@\n #define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_ASSEMBLER\n #define OUTPUT_FILENAME  \"output-of-test-compile-to-assembler.c.s\"\n #include \"harness.h\"\n+#include \"create-code-for-hello-world-executable.h\"\n \n-void\n-create_code (gcc_jit_context *ctxt, void *user_data)\n-{\n-  /* Let's try to inject the equivalent of:\n-     void\n-     hello_world (const char *name)\n-     {\n-       // a test comment\n-       printf (\"hello %s\\n\", name);\n-     }\n-  */\n-  gcc_jit_type *void_type =\n-    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n-  gcc_jit_type *const_char_ptr_type =\n-    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n-  gcc_jit_param *param_name =\n-    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n-  gcc_jit_function *func =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n-\t\t\t\t  void_type,\n-\t\t\t\t  \"hello_world\",\n-\t\t\t\t  1, &param_name,\n-\t\t\t\t  0);\n-\n-  gcc_jit_param *param_format =\n-    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n-  gcc_jit_function *printf_func =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n-\t\t\t\t  gcc_jit_context_get_type (\n-\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n-\t\t\t\t  \"printf\",\n-\t\t\t\t  1, &param_format,\n-\t\t\t\t  1);\n-  gcc_jit_rvalue *args[2];\n-  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n-  args[1] = gcc_jit_param_as_rvalue (param_name);\n-\n-  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n-\n-  gcc_jit_block_add_comment (\n-    block, NULL,\n-    \"a test comment\");\n-\n-  gcc_jit_block_add_eval (\n-    block, NULL,\n-    gcc_jit_context_new_call (ctxt,\n-\t\t\t      NULL,\n-\t\t\t      printf_func,\n-\t\t\t      2, args));\n-  gcc_jit_block_end_with_void_return (block, NULL);\n-}\n-\n-/* { dg-final { jit-verify-compile-to-file \"assembler source text\" } } */\n+/* { dg-final { jit-verify-output-file-was-created \"\" } } */\n+/* { dg-final { jit-verify-assembler \"hello from ./output-of-test-compile-to-assembler.c.s.exe\" } } */"}, {"sha": "c29e6f6d6289b0e209e21afa6d47e9f8f6123b20", "filename": "gcc/testsuite/jit.dg/test-compile-to-dynamic-library.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-dynamic-library.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-dynamic-library.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-dynamic-library.c?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -16,7 +16,7 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n      hello_world (const char *name)\n      {\n        // a test comment\n-       printf (\"hello %s\\n\", name);\n+       printf (\"hello from %s\\n\", name);\n      }\n   */\n   gcc_jit_type *void_type =\n@@ -44,7 +44,7 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n \t\t\t\t  1, &param_format,\n \t\t\t\t  1);\n   gcc_jit_rvalue *args[2];\n-  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n+  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello from %s\\n\");\n   args[1] = gcc_jit_param_as_rvalue (param_name);\n \n   gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n@@ -62,4 +62,5 @@ create_code (gcc_jit_context *ctxt, void *user_data)\n   gcc_jit_block_end_with_void_return (block, NULL);\n }\n \n-/* { dg-final { jit-verify-compile-to-file \"shared object.+dynamically linked\" } } */\n+/* { dg-final { jit-verify-output-file-was-created \"\" } } */\n+/* { dg-final { jit-verify-dynamic-library \"hello from ./verify-dynamic-library.c.exe\" } } */"}, {"sha": "2fb0bd91cc927637dcf3531474bf3511bd1e3d5e", "filename": "gcc/testsuite/jit.dg/test-compile-to-executable.c", "status": "modified", "additions": 3, "deletions": 100, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-executable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-executable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-executable.c?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -7,104 +7,7 @@\n #define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_EXECUTABLE\n #define OUTPUT_FILENAME  \"output-of-test-compile-to-executable.c.exe\"\n #include \"harness.h\"\n+#include \"create-code-for-hello-world-executable.h\"\n \n-void\n-create_code (gcc_jit_context *ctxt, void *user_data)\n-{\n-  /* Let's try to inject the equivalent of:\n-     static void\n-     hello_world (const char *name)\n-     {\n-       // a test comment\n-       printf (\"hello %s\\n\", name);\n-     }\n-\n-     extern int\n-     main (int argc, char **argv)\n-     {\n-       hello_world (argv[0]);\n-       return 0;\n-     }\n-  */\n-  gcc_jit_type *void_type =\n-    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n-  gcc_jit_type *const_char_ptr_type =\n-    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n-  gcc_jit_param *param_name =\n-    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n-  gcc_jit_function *func =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_INTERNAL,\n-\t\t\t\t  void_type,\n-\t\t\t\t  \"hello_world\",\n-\t\t\t\t  1, &param_name,\n-\t\t\t\t  0);\n-\n-  gcc_jit_param *param_format =\n-    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n-  gcc_jit_function *printf_func =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n-\t\t\t\t  gcc_jit_context_get_type (\n-\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n-\t\t\t\t  \"printf\",\n-\t\t\t\t  1, &param_format,\n-\t\t\t\t  1);\n-  gcc_jit_rvalue *args[2];\n-  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n-  args[1] = gcc_jit_param_as_rvalue (param_name);\n-\n-  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n-\n-  gcc_jit_block_add_comment (\n-    block, NULL,\n-    \"a test comment\");\n-\n-  gcc_jit_block_add_eval (\n-    block, NULL,\n-    gcc_jit_context_new_call (ctxt,\n-\t\t\t      NULL,\n-\t\t\t      printf_func,\n-\t\t\t      2, args));\n-  gcc_jit_block_end_with_void_return (block, NULL);\n-\n-  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n-  gcc_jit_param *param_argc =\n-    gcc_jit_context_new_param (ctxt, NULL, int_type, \"argc\");\n-  gcc_jit_type *char_ptr_ptr_type =\n-    gcc_jit_type_get_pointer (\n-      gcc_jit_type_get_pointer (\n-\tgcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR)));\n-  gcc_jit_param *param_argv =\n-    gcc_jit_context_new_param (ctxt, NULL, char_ptr_ptr_type, \"argv\");\n-  gcc_jit_param *params[2] = {param_argc, param_argv};\n-  gcc_jit_function *func_main =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n-\t\t\t\t  int_type,\n-\t\t\t\t  \"main\",\n-\t\t\t\t  2, params,\n-\t\t\t\t  0);\n-  block = gcc_jit_function_new_block (func_main, NULL);\n-  gcc_jit_rvalue *zero = gcc_jit_context_zero (ctxt, int_type);\n-  args[0] = gcc_jit_context_new_cast (\n-\tctxt,\n-\tNULL,\n-\tgcc_jit_lvalue_as_rvalue (\n-\t  gcc_jit_context_new_array_access (\n-\t    ctxt,\n-\t    NULL,\n-\t    gcc_jit_param_as_rvalue (param_argv),\n-\t    zero)),\n-\tconst_char_ptr_type);\n-  gcc_jit_block_add_eval (\n-    block, NULL,\n-    gcc_jit_context_new_call (ctxt,\n-\t\t\t      NULL,\n-\t\t\t      func,\n-\t\t\t      1, args));\n-  gcc_jit_block_end_with_return (block, NULL, zero);\n-}\n-\n-/* { dg-final { jit-verify-compile-to-file \"executable\" } } */\n-/* { dg-final { jit-verify-executable \"hello .*\" } } */\n+/* { dg-final { jit-verify-output-file-was-created \"\" } } */\n+/* { dg-final { jit-verify-executable \"hello from ./output-of-test-compile-to-executable.c.exe\" } } */"}, {"sha": "81d41c21d4027db26f03c88e118a1986eb13e0b9", "filename": "gcc/testsuite/jit.dg/test-compile-to-object.c", "status": "modified", "additions": 3, "deletions": 55, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82289f536862ea01ae5b221f0e1e3a79eb5b541/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-compile-to-object.c?ref=a82289f536862ea01ae5b221f0e1e3a79eb5b541", "patch": "@@ -7,59 +7,7 @@\n #define OUTPUT_KIND      GCC_JIT_OUTPUT_KIND_OBJECT_FILE\n #define OUTPUT_FILENAME  \"output-of-test-compile-to-object.c.o\"\n #include \"harness.h\"\n+#include \"create-code-for-hello-world-executable.h\"\n \n-void\n-create_code (gcc_jit_context *ctxt, void *user_data)\n-{\n-  /* Let's try to inject the equivalent of:\n-     void\n-     hello_world (const char *name)\n-     {\n-       // a test comment\n-       printf (\"hello %s\\n\", name);\n-     }\n-  */\n-  gcc_jit_type *void_type =\n-    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n-  gcc_jit_type *const_char_ptr_type =\n-    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CONST_CHAR_PTR);\n-  gcc_jit_param *param_name =\n-    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"name\");\n-  gcc_jit_function *func =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n-\t\t\t\t  void_type,\n-\t\t\t\t  \"hello_world\",\n-\t\t\t\t  1, &param_name,\n-\t\t\t\t  0);\n-\n-  gcc_jit_param *param_format =\n-    gcc_jit_context_new_param (ctxt, NULL, const_char_ptr_type, \"format\");\n-  gcc_jit_function *printf_func =\n-    gcc_jit_context_new_function (ctxt, NULL,\n-\t\t\t\t  GCC_JIT_FUNCTION_IMPORTED,\n-\t\t\t\t  gcc_jit_context_get_type (\n-\t\t\t\t     ctxt, GCC_JIT_TYPE_INT),\n-\t\t\t\t  \"printf\",\n-\t\t\t\t  1, &param_format,\n-\t\t\t\t  1);\n-  gcc_jit_rvalue *args[2];\n-  args[0] = gcc_jit_context_new_string_literal (ctxt, \"hello %s\\n\");\n-  args[1] = gcc_jit_param_as_rvalue (param_name);\n-\n-  gcc_jit_block *block = gcc_jit_function_new_block (func, NULL);\n-\n-  gcc_jit_block_add_comment (\n-    block, NULL,\n-    \"a test comment\");\n-\n-  gcc_jit_block_add_eval (\n-    block, NULL,\n-    gcc_jit_context_new_call (ctxt,\n-\t\t\t      NULL,\n-\t\t\t      printf_func,\n-\t\t\t      2, args));\n-  gcc_jit_block_end_with_void_return (block, NULL);\n-}\n-\n-/* { dg-final { jit-verify-compile-to-file \"relocatable\" } } */\n+/* { dg-final { jit-verify-output-file-was-created \"\" } } */\n+/* { dg-final { jit-verify-object \"hello from ./output-of-test-compile-to-object.c.o.exe\" } } */"}]}