{"sha": "5a1c10de98acd4aa12483d1d09878c4f1e634973", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWExYzEwZGU5OGFjZDRhYTEyNDgzZDFkMDk4NzhjNGYxZTYzNDk3Mw==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-12-24T03:11:57Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-12-24T03:11:57Z"}, "message": "(FUNCTION_INCOMING_ARG): Delete definition.\n\n(RTX_COSTS) [PLUS]: Rewrite.\n(output_scc_insn): Delete.\n(output_floatsisf2): Delete.\n(output_floatsidf2): Delete.\n(PREDICATE_CODES): Define, but leave within #if 0 for now.\n(CONDITIONAL_REGISTER_USAGE): Never make\nPIC_OFFSET_TABLE_REGNUM fixed.\n(INITIALIZE_PIC): Delete.\n\nFrom-SVN: r6293", "tree": {"sha": "882839feed9e2a8bbcbd76201c37d9e124b5fc85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/882839feed9e2a8bbcbd76201c37d9e124b5fc85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a1c10de98acd4aa12483d1d09878c4f1e634973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1c10de98acd4aa12483d1d09878c4f1e634973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a1c10de98acd4aa12483d1d09878c4f1e634973", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1c10de98acd4aa12483d1d09878c4f1e634973/comments", "author": null, "committer": null, "parents": [{"sha": "23f6f34fca525e2a1ad98377fb08c7a80977bce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f6f34fca525e2a1ad98377fb08c7a80977bce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23f6f34fca525e2a1ad98377fb08c7a80977bce1"}], "stats": {"total": 138, "additions": 84, "deletions": 54}, "files": [{"sha": "103f0b2a26807ea71632c95824edd304375abbf9", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 84, "deletions": 54, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a1c10de98acd4aa12483d1d09878c4f1e634973/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a1c10de98acd4aa12483d1d09878c4f1e634973/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=5a1c10de98acd4aa12483d1d09878c4f1e634973", "patch": "@@ -42,7 +42,7 @@ extern int target_flags;\n \n /* Disable all FP registers (they all become fixed).  This may be necessary\n    for compiling kernels which perform lazy context switching of FP regs.\n-   Note if you use this option and try to perform floating point operations \n+   Note if you use this option and try to perform floating point operations\n    the compiler will abort!  */\n \n #define TARGET_DISABLE_FPREGS (target_flags & 2)\n@@ -53,7 +53,7 @@ extern int target_flags;\n /* Force all function calls to indirect addressing via a register.  This\n    avoids lossage when the function is very far away from the current PC.\n \n-   ??? What about simple jumps, they can suffer from the same problem.  \n+   ??? What about simple jumps, they can suffer from the same problem.\n    Would require significant surgery in pa.md.  */\n \n #define TARGET_LONG_CALLS (target_flags & 16)\n@@ -64,7 +64,7 @@ extern int target_flags;\n \n /* Emit directives only understood by GAS.  This allows parameter\n    relocations to work for static functions.  There is no way\n-   to make them work the HP assembler at this time. \n+   to make them work the HP assembler at this time.\n \n    Also forces a colon to be tacked onto the end of local and\n    global labes.  */\n@@ -115,7 +115,7 @@ extern int target_flags;\n /* Defines for a K&R CC */\n \n #define CC1_SPEC \"%{pg:} %{p:}\"\n-  \n+\n #define LINK_SPEC \"-u main\"\n \n /* Allow $ in identifiers.  */\n@@ -144,7 +144,7 @@ extern int target_flags;\n }\n \n /* Omit frame pointer at high optimization levels.  */\n-  \n+\n #define OPTIMIZATION_OPTIONS(OPTIMIZE) \\\n {  \t\t\t\t\t\t\t\t\\\n   if (OPTIMIZE >= 2) \t\t\t\t\t\t\\\n@@ -244,9 +244,9 @@ extern int target_flags;\n    HP-PA 1.0 has 32 fullword registers and 16 floating point\n    registers. The floating point registers hold either word or double\n    word values.\n-   \n+\n    16 additional registers are reserved.\n-   \n+\n    HP-PA 1.1 has 32 fullword registers and 32 floating point\n    registers. However, the floating point registers behave\n    differently: the left and right halves of registers are addressable\n@@ -291,7 +291,6 @@ extern int target_flags;\n    Freg 8L-11R\t= Temporary Registers\n    Freg 12L-21R\t= Preserved Registers\n    Freg 22L-31R = Temporary Registers\n-   \n \n */\n \n@@ -335,7 +334,7 @@ extern int target_flags;\n   0, 0, 0, 0, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1}    \n+  1}\n \n /* Make sure everything's fine if we *don't* have a given processor.\n    This assumes that putting a register in fixed_regs will keep the\n@@ -371,8 +370,10 @@ extern int target_flags;\n        if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n \tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n     } \t\t\t\t\t\t\\\n+  /* This makes cse think PIC_OFFSET_TABLE_REGNUM is not clobbered\n+     in calls.\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\\\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1; */\t\\\n }\n \n /* Allocated the call used registers first.  This should minimize\n@@ -452,7 +453,7 @@ extern int target_flags;\n \n /* Value should be nonzero if functions must have frame pointers. */\n #define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n-  \n+\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue.\n@@ -475,7 +476,6 @@ extern int target_flags;\n \n #define PIC_OFFSET_TABLE_REGNUM 19\n \n-#define INITIALIZE_PIC initialize_pic ()\n #define FINALIZE_PIC finalize_pic ()\n \n /* SOM ABI says that objects larger than 64 bits are returned in memory.  */\n@@ -515,7 +515,7 @@ extern int target_flags;\n \n enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n   HI_SNAKE_FP_REGS, SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\n-  FP_OR_SNAKE_FP_REGS, NON_SHIFT_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES}; \n+  FP_OR_SNAKE_FP_REGS, NON_SHIFT_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n@@ -567,7 +567,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n   (CLASS == FP_REGS || CLASS == SNAKE_FP_REGS || CLASS == HI_SNAKE_FP_REGS)\n \n /* Get reg_class from a letter such as appears in the machine description.\n-   Note 'Z' is not the same as 'r' since SHIFT_REGS is not part of \n+   Note 'Z' is not the same as 'r' since SHIFT_REGS is not part of\n    GENERAL_REGS.  */\n \n #define REG_CLASS_FROM_LETTER(C) \\\n@@ -628,7 +628,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   secondary_reload_class (CLASS, MODE, IN)\n \n-/* On the PA it is not possible to directly move data between \n+/* On the PA it is not possible to directly move data between\n    GENERAL_REGS and FP_REGS.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)  \\\n   ((FP_REG_CLASS_P (CLASS1) && ! FP_REG_CLASS_P (CLASS2))\t\\\n@@ -678,12 +678,12 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \n    ??? Have to check on this.*/\n \n-#define FIRST_PARM_OFFSET(FNDECL) -32 \n+#define FIRST_PARM_OFFSET(FNDECL) -32\n \n /* Absolute value of offset from top-of-stack address to location to store the\n    function parameter if it can't go in a register.\n    Addresses for following parameters are computed relative to this one.  */\n-#define FIRST_PARM_CALLER_OFFSET(FNDECL) -32 \n+#define FIRST_PARM_CALLER_OFFSET(FNDECL) -32\n \n \n /* When a parameter is passed in a register, stack space is still\n@@ -699,11 +699,11 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    doesn't behave itself when the stack pointer moves within\n    the function!  */\n #define ACCUMULATE_OUTGOING_ARGS\n-  \n-/* The weird HPPA calling conventions require a minimum of 48 bytes on \n+\n+/* The weird HPPA calling conventions require a minimum of 48 bytes on\n    the stack: 16 bytes for register saves, and 32 bytes for magic.\n    This is the difference between the logical top of stack and the\n-   actual sp. */ \n+   actual sp. */\n #define STACK_POINTER_OFFSET -32\n \n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n@@ -726,7 +726,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\t\\\n \t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n \t\t\t\t      (TARGET_SNAKE ? 44 : 32) : 28))\n \n@@ -823,12 +823,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n \t\t  : (27 - (CUM) - FUNCTION_ARG_SIZE ((MODE), (TYPE))))))\\\n    : 0)\n \n-/* Define where a function finds its arguments.\n-   This would be different from FUNCTION_ARG if we had register windows.  */\n-\n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-  FUNCTION_ARG (CUM, MODE, TYPE, NAMED)\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n@@ -1002,9 +996,9 @@ extern union tree_node *current_function_decl;\n \n    This code template is copied from text segment to stack location\n    and then patched with INITIALIZE_TRAMPOLINE to contain\n-   valid values, and then entered as a subroutine. \n+   valid values, and then entered as a subroutine.\n \n-   It is best to keep this as small as possible to avoid having to \n+   It is best to keep this as small as possible to avoid having to\n    flush multiple lines in the cache.  */\n \n #define TRAMPOLINE_TEMPLATE(FILE) \\\n@@ -1026,7 +1020,7 @@ extern union tree_node *current_function_decl;\n \n    Flush the cache entries corresponding to the first and last addresses\n    of the trampoline.  This is necessary as the trampoline may cross two\n-   cache lines.  \n+   cache lines.\n \n    If the code part of the trampoline ever grows to > 32 bytes, then it\n    will become necessary to hack on the cacheflush pattern in pa.md.  */\n@@ -1126,7 +1120,7 @@ extern union tree_node *current_function_decl;\n   (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n     || (X) == CONST0_RTX (GET_MODE (X)))\n \n-/* Subroutine for EXTRA_CONSTRAINT.  \n+/* Subroutine for EXTRA_CONSTRAINT.\n \n    Return 1 iff OP is a pseudo which did not get a hard register and\n    we are running the reload pass.  */\n@@ -1146,7 +1140,7 @@ extern union tree_node *current_function_decl;\n    constrain_operands to fail.\n \n    Also note `Q' accepts any memory operand during the reload pass.\n-   This includes out-of-range displacements in reg+d addressing. \n+   This includes out-of-range displacements in reg+d addressing.\n    This makes for better code.  (??? For 2.5 address this issue).\n \n    `R' is unused.\n@@ -1352,7 +1346,7 @@ do\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\\\n while (0)\n-  \n+\n /* Store the user-specified part of SYMBOL_NAME in VAR.\n    This is sort of inverse to ENCODE_SECTION_INFO.  */\n \n@@ -1437,7 +1431,7 @@ while (0)\n    is a byte address (for indexing purposes)\n    so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE SImode\n-  \n+\n /* Define this if addresses of constant functions\n    shouldn't be put through pseudo regs where they can be cse'd.\n    Desirable on machines where ordinary constants are expensive\n@@ -1483,7 +1477,7 @@ while (0)\n    Make moves from SAR so expensive they should never happen.  We used to\n    have 0xffff here, but that generates overflow in rare cases.\n \n-   Copies involving a FP register and a non-FP register are relatively \n+   Copies involving a FP register and a non-FP register are relatively\n    expensive because they must go through memory.\n \n    Other copies are reasonably cheap.  */\n@@ -1498,17 +1492,21 @@ while (0)\n    switch on CODE.  The purpose for the cost of MULT is to encourage\n    `synth_mult' to find a synthetic multiply when reasonable.  */\n \n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\\\n-    return TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\t\\\n-      ? COSTS_N_INSNS (8) : COSTS_N_INSNS (20); \t\\\n-  case DIV:\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (60);\t\t\t\t\\\n-  case PLUS: /* this includes shNadd insns */\t\t\\\n-    return COSTS_N_INSNS (1) + 2;\n+#define RTX_COSTS(X,CODE,OUTER_CODE) \\\n+  case MULT:\t\t\t\t\t\t\t\\\n+    return TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\t\t\\\n+      ? COSTS_N_INSNS (8) : COSTS_N_INSNS (20); \t\t\\\n+  case DIV:\t\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (60);\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n+\t&& shadd_operand (XEXP (XEXP (X, 0), 1), VOIDmode))\t\\\n+      return (2 + rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n+\t      + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+    break;\n \n /* Adjust the cost of dependencies.  */\n \n@@ -1531,8 +1529,8 @@ while (0)\n    are expected to clobber their arguments, %r1, %r29, and %r31 and\n    nothing else.\n \n-   These macros tell reorg that the references to arguments and \n-   register clobbers for millicode calls do not appear to happen \n+   These macros tell reorg that the references to arguments and\n+   register clobbers for millicode calls do not appear to happen\n    until after the millicode call.  This allows reorg to put insns\n    which set the argument registers into the delay slot of the millicode\n    call -- thus they act more like traditional CALL_INSNs.\n@@ -1552,7 +1550,7 @@ while (0)\n     && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n     && GET_CODE (PATTERN (X)) != USE\t\t\\\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n-    && get_attr_type (X) == TYPE_MILLI))\t\n+    && get_attr_type (X) == TYPE_MILLI))\n \n \f\n /* Control the assembler format that we output.  */\n@@ -1702,7 +1700,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n \t }\\\n      } while (0)\n \n-/* The bogus HP assembler requires ALL external references to be \n+/* The bogus HP assembler requires ALL external references to be\n    \"imported\", even library calls. They look a bit different, so\n    here's this macro. */\n \n@@ -1790,7 +1788,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n   output_ascii ((FILE), (P), (SIZE))\n \n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO) \n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n /* This is how to output an element of a case-vector that is absolute.\n    Note that this method makes filling these branch delay slots\n    impossible.  */\n@@ -1928,15 +1926,12 @@ extern char *output_ior ();\n extern char *output_move_double ();\n extern char *output_fp_move_double ();\n extern char *output_block_move ();\n-extern char *output_scc_insn ();\n extern char *output_cbranch ();\n extern char *output_bb ();\n extern char *output_dbra ();\n extern char *output_movb ();\n extern char *output_return ();\n extern char *output_call ();\n-extern char *output_floatsisf2 ();\n-extern char *output_floatsidf2 ();\n extern char *output_mul_insn ();\n extern char *output_div_insn ();\n extern char *output_mod_insn ();\n@@ -1948,3 +1943,38 @@ extern struct rtx_def *gen_cmp_fp ();\n extern void hppa_encode_label ();\n \n extern struct rtx_def *hppa_save_pic_table_rtx;\n+\n+#if 0\n+#define PREDICATE_CODES \\\n+  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"reg_or_cint_move_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"arith32_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"arith11_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"arith5_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"pre_cint_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"post_cint_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"int5_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"uint5_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"uint32_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"int11_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"ior_operand\", {CONST_INT}},\t\t\t\t\t\t\\\n+  {\"lhs_lshift_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"lhs_lshift_cint_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"plus_xor_ior_operator\", {PLUS, XOR, IOR}},\t\t\t\t\\\n+  {\"shadd_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"eq_neq_comparison_operator\", {EQ, NE}},\t\t\t\t\\\n+  {\"movb_comparison_operator\", {EQ, NE, LT, GE}},\t\t\t\\\n+  {\"pc_or_label_operand\", {LABEL_REF, PC}},\t\t\t\t\\\n+  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n+  {\"reg_or_nonsymb_mem_operand\", {REG, SUBREG, MEM}},\t\t\t\\\n+  {\"move_operand\", {REG, SUBREG, CONST_INT, MEM}},\t\t\t\\\n+  {\"pic_operand\", {REG, SUBREG, CONST_INT, SYMBOL_REF, LABEL_REF,\t\\\n+\t\t   CONST, HIGH, PC}},\t/* No clue */\t\t\t\\\n+  {\"function_label_operand\", {SYMBOL_REF}},\t\t\t\t\\\n+  {\"reg_or_0_or_nonsymb_mem_operand\", {REG, SUBREG, CONST_INT, MEM}},\t\\\n+  {\"div_operand\", {REG, CONST_INT}},\t\t\t\t\t\\\n+  {\"call_operand_address\", {LABEL_REF, SYMBOL_REF, CONST_INT,\t\t\\\n+\t\t\t    CONST, HIGH}},\n+#endif"}]}