{"sha": "b949ea8b0f724013ec018b7af86ba134a229d723", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk0OWVhOGIwZjcyNDAxM2VjMDE4YjdhZjg2YmExMzRhMjI5ZDcyMw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2000-08-25T16:52:24Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2000-08-25T16:52:24Z"}, "message": "i386.c (ix86_find_base_term): New.\n\n\t* i386.c (ix86_find_base_term): New.\n\t* i386-protos.h (ix86_find_base_term): Prototype.\n\t* i386.h (FIND_BASE_TERM): Define.\n\t* alias.c (find_base_term): Use it.\n\t* tm.texi (FIND_BASE_TERM): Document it.\n\n\t* alias.c (true_dependence, write_dependence_p): Unchanging\n\tmemory can't conflict with non-unchanging memory.\n\n\t* alias.c (memrefs_conflict_p): A BLKmode reference\n\tto a symbol (or CONST_INT address) always conflicts\n\twith a reference to another symbol.\n\nFrom-SVN: r35985", "tree": {"sha": "1f4cb865a07357d51f3f12cc3e78156fa5a0c581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f4cb865a07357d51f3f12cc3e78156fa5a0c581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b949ea8b0f724013ec018b7af86ba134a229d723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b949ea8b0f724013ec018b7af86ba134a229d723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b949ea8b0f724013ec018b7af86ba134a229d723", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b949ea8b0f724013ec018b7af86ba134a229d723/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "343b7260c6f4c4164fd65368a7d2391defcbd098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/343b7260c6f4c4164fd65368a7d2391defcbd098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/343b7260c6f4c4164fd65368a7d2391defcbd098"}], "stats": {"total": 105, "additions": 94, "deletions": 11}, "files": [{"sha": "892c22239ec5758c8dc6ae876dc05f3d312c30bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b949ea8b0f724013ec018b7af86ba134a229d723", "patch": "@@ -1,3 +1,18 @@\n+Fri Aug 25 12:52:49 EDT 2000  John Wehle  (john@feith.com)\n+\n+\t* i386.c (ix86_find_base_term): New.\n+\t* i386-protos.h (ix86_find_base_term): Prototype.\n+\t* i386.h (FIND_BASE_TERM): Define.\n+\t* alias.c (find_base_term): Use it.\n+\t* tm.texi (FIND_BASE_TERM): Document it.\n+\n+\t* alias.c (true_dependence, write_dependence_p): Unchanging\n+\tmemory can't conflict with non-unchanging memory.\n+\n+\t* alias.c (memrefs_conflict_p): A BLKmode reference\n+\tto a symbol (or CONST_INT address) always conflicts\n+\twith a reference to another symbol.\n+\n 2000-08-25  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-common.c (time_char_table): Don't allow width and flags with"}, {"sha": "cb5a636377915156081f8eeb7d4f7fb4e12b078d", "filename": "gcc/alias.c", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b949ea8b0f724013ec018b7af86ba134a229d723", "patch": "@@ -1033,6 +1033,11 @@ find_base_term (x)\n   cselib_val *val;\n   struct elt_loc_list *l;\n \n+#if defined (FIND_BASE_TERM)\n+  /* Try machine-dependent ways to find the base term.  */\n+  x = FIND_BASE_TERM (x);\n+#endif\n+\n   switch (GET_CODE (x))\n     {\n     case REG:\n@@ -1078,6 +1083,9 @@ find_base_term (x)\n \t   is a shift or multiply, then it must be the index register and the\n \t   other operand is the base register.  */\n \t\n+\tif (tmp1 == pic_offset_table_rtx && CONSTANT_P (tmp2))\n+\t  return find_base_term (tmp2);\n+\n \t/* If either operand is known to be a pointer, then use it\n \t   to determine the base term.  */\n \tif (REG_P (tmp1) && REGNO_POINTER_FLAG (REGNO (tmp1)))\n@@ -1469,10 +1477,9 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \t\t\t\t   canon_rtx (XEXP (y, 0)), c);\n \n       if (CONSTANT_P (y))\n-\treturn (xsize < 0 || ysize < 0\n+\treturn (xsize <= 0 || ysize <= 0\n \t\t|| (rtx_equal_for_memref_p (x, y)\n-\t\t    && (xsize == 0 || ysize == 0\n-\t\t        || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0))));\n+\t\t    && ((c >= 0 && xsize > c) || (c < 0 && ysize+c > 0))));\n \n       return 1;\n     }\n@@ -1574,14 +1581,14 @@ true_dependence (mem, mem_mode, x, varies)\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n-  /* If X is an unchanging read, then it can't possibly conflict with any\n-     non-unchanging store.  It may conflict with an unchanging write though,\n-     because there may be a single store to this address to initialize it.\n-     Just fall through to the code below to resolve the case where we have\n-     both an unchanging read and an unchanging write.  This won't handle all\n-     cases optimally, but the possible performance loss should be\n-     negligible.  */\n-  if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n+  /* Unchanging memory can't conflict with non-unchanging memory.\n+     A non-unchanging read can conflict with a non-unchanging write.\n+     An unchanging read can conflict with an unchanging write since\n+     there may be a single store to this address to initialize it.\n+     Just fall through to the code below to resolve potential conflicts.\n+     This won't handle all cases optimally, but the possible performance\n+     loss should be negligible.  */\n+  if (RTX_UNCHANGING_P (x) != RTX_UNCHANGING_P (mem))\n     return 0;\n \n   if (mem_mode == VOIDmode)\n@@ -1642,6 +1649,10 @@ write_dependence_p (mem, x, writep)\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n+  /* Unchanging memory can't conflict with non-unchanging memory.  */\n+  if (RTX_UNCHANGING_P (x) != RTX_UNCHANGING_P (mem))\n+    return 0;\n+\n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n      have occurred somewhere before MEM.  */"}, {"sha": "f5d075b5b0d3788a7087e2a979fc0ddc4a6dfa4c", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=b949ea8b0f724013ec018b7af86ba134a229d723", "patch": "@@ -111,6 +111,7 @@ extern void ix86_split_ashrdi PARAMS ((rtx *, rtx));\n extern void ix86_split_lshrdi PARAMS ((rtx *, rtx));\n extern void ix86_expand_strlensi_unroll_1 PARAMS ((rtx, rtx, rtx));\n extern int ix86_address_cost PARAMS ((rtx));\n+extern rtx ix86_find_base_term PARAMS ((rtx));\n \n extern rtx assign_386_stack_local PARAMS ((enum machine_mode, int));\n extern int ix86_attr_length_immediate_default PARAMS ((rtx, int));"}, {"sha": "aa9b4973726e20311ec4a573ace10ea45e9cd450", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b949ea8b0f724013ec018b7af86ba134a229d723", "patch": "@@ -2332,6 +2332,40 @@ ix86_address_cost (x)\n   return cost;\n }\n \f\n+/* If X is a machine specific address (i.e. a symbol or label being\n+   referenced as a displacement from the GOT implemented using an\n+   UNSPEC), then return the base term.  Otherwise return X.  */\n+\n+rtx\n+ix86_find_base_term (x)\n+     rtx x;\n+{\n+  rtx term;\n+\n+  if (GET_CODE (x) != PLUS\n+      || XEXP (x, 0) != pic_offset_table_rtx\n+      || GET_CODE (XEXP (x, 1)) != CONST)\n+    return x;\n+\n+  term = XEXP (XEXP (x, 1), 0);\n+\n+  if (GET_CODE (term) == PLUS && GET_CODE (XEXP (term, 1)) == CONST_INT)\n+    term = XEXP (term, 0);\n+\n+  if (GET_CODE (term) != UNSPEC\n+      || XVECLEN (term, 0) != 1\n+      || XINT (term, 1) !=  7)\n+    return x;\n+\n+  term = XVECEXP (term, 0, 0);\n+\n+  if (GET_CODE (term) != SYMBOL_REF\n+      && GET_CODE (term) != LABEL_REF)\n+    return x;\n+\n+  return term;\n+}\n+\f\n /* Determine if a given CONST RTX is a valid memory displacement\n    in PIC mode.  */\n    "}, {"sha": "d7ced8669b9f8c8f623396ec46cc0608f07fb90b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b949ea8b0f724013ec018b7af86ba134a229d723", "patch": "@@ -1659,6 +1659,17 @@ pop{l} %0\"\t\t\t\t\t\t\t\\\n \n #endif\n \n+/* If defined, a C expression to determine the base term of address X.\n+   This macro is used in only one place: `find_base_term' in alias.c.\n+\n+   It is always safe for this macro to not be defined.  It exists so\n+   that alias analysis can understand machine-dependent addresses.\n+\n+   The typical use of this macro is to handle addresses containing\n+   a label_ref or symbol_ref within an UNSPEC.  */\n+\n+#define FIND_BASE_TERM(X) ix86_find_base_term (x)\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c."}, {"sha": "7006cbf49fa9b4e594aeba3473a2635b91465879", "filename": "gcc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b949ea8b0f724013ec018b7af86ba134a229d723/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=b949ea8b0f724013ec018b7af86ba134a229d723", "patch": "@@ -4453,6 +4453,17 @@ may serve in each capacity.  The compiler will try both labelings,\n looking for one that is valid, and will reload one or both registers\n only if neither labeling works.\n \n+@findex FIND_BASE_TERM\n+@item FIND_BASE_TERM (@var{x})\n+A C expression to determine the base term of address @var{x}.\n+This macro is used in only one place: `find_base_term' in alias.c.\n+\n+It is always safe for this macro to not be defined.  It exists so\n+that alias analysis can understand machine-dependent addresses.\n+\n+The typical use of this macro is to handle addresses containing\n+a label_ref or symbol_ref within an UNSPEC.\n+\n @findex LEGITIMIZE_ADDRESS\n @item LEGITIMIZE_ADDRESS (@var{x}, @var{oldx}, @var{mode}, @var{win})\n A C compound statement that attempts to replace @var{x} with a valid"}]}