{"sha": "3930dbe9d6c9849e32ce39d7ff585348d4716329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzMGRiZTlkNmM5ODQ5ZTMyY2UzOWQ3ZmY1ODUzNDhkNDcxNjMyOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-03T00:46:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-03T00:46:49Z"}, "message": "mangle.c (write_unnamed_type_name): Implement.\n\n\t* mangle.c (write_unnamed_type_name): Implement.\n\t(local_class_index): Split out from...\n\t(discriminator_for_local_entity): ...here.\n\t(nested_anon_class_index): New.\n\t* cp-tree.h (TYPE_FUNCTION_SCOPE_P): New.\n\nFrom-SVN: r152429", "tree": {"sha": "dce6c2dc62ee375a25c6ec2937c1971bb4daf712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dce6c2dc62ee375a25c6ec2937c1971bb4daf712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3930dbe9d6c9849e32ce39d7ff585348d4716329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3930dbe9d6c9849e32ce39d7ff585348d4716329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3930dbe9d6c9849e32ce39d7ff585348d4716329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3930dbe9d6c9849e32ce39d7ff585348d4716329/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2eb5a67b218756fb956146cc72b69f2cf475f5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2eb5a67b218756fb956146cc72b69f2cf475f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2eb5a67b218756fb956146cc72b69f2cf475f5c"}], "stats": {"total": 151, "additions": 129, "deletions": 22}, "files": [{"sha": "0fea9127c8136d6849ad8e6e8a9e36c7c90b7ff4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3930dbe9d6c9849e32ce39d7ff585348d4716329", "patch": "@@ -1,3 +1,11 @@\n+2009-10-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* mangle.c (write_unnamed_type_name): Implement.\n+\t(local_class_index): Split out from...\n+\t(discriminator_for_local_entity): ...here.\n+\t(nested_anon_class_index): New.\n+\t* cp-tree.h (TYPE_FUNCTION_SCOPE_P): New.\n+\n 2009-10-02  Janis Johnson  <janis187@us.ibm.com>\n \n \t* call.c (convert_arg_to_ellipsis): Avoid promoting decimal32"}, {"sha": "8a185759912dfb71f2504ed81281275d3076fcdb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3930dbe9d6c9849e32ce39d7ff585348d4716329", "patch": "@@ -2249,6 +2249,9 @@ struct GTY(()) lang_decl {\n   (DECL_CONTEXT (NODE) \\\n    && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n \n+#define TYPE_FUNCTION_SCOPE_P(NODE) \\\n+  (TYPE_CONTEXT (NODE) && TREE_CODE (TYPE_CONTEXT (NODE)) == FUNCTION_DECL)\n+\n /* 1 iff VAR_DECL node NODE is a type-info decl.  This flag is set for\n    both the primary typeinfo object and the associated NTBS name.  */\n #define DECL_TINFO_P(NODE) TREE_LANG_FLAG_4 (VAR_DECL_CHECK (NODE))"}, {"sha": "d96a929ec5cf687b67824a64e5a3357e2ed39afd", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 73, "deletions": 22, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=3930dbe9d6c9849e32ce39d7ff585348d4716329", "patch": "@@ -217,6 +217,7 @@ static void write_discriminator (const int);\n static void write_local_name (tree, const tree, const tree);\n static void dump_substitution_candidates (void);\n static tree mangle_decl_string (const tree);\n+static int local_class_index (tree);\n \n /* Control functions.  */\n \n@@ -1204,8 +1205,7 @@ write_unqualified_name (const tree decl)\n       tree type = TREE_TYPE (decl);\n \n       if (TREE_CODE (decl) == TYPE_DECL\n-          && TYPE_ANONYMOUS_P (type)\n-          && !ANON_UNION_TYPE_P (type))\n+          && TYPE_ANONYMOUS_P (type))\n         write_unnamed_type_name (type);\n       else if (TREE_CODE (decl) == TYPE_DECL\n                && LAMBDA_TYPE_P (type))\n@@ -1252,14 +1252,48 @@ write_compact_number (int num)\n   write_char ('_');\n }\n \n+/* Return how many unnamed types precede TYPE in its enclosing class.  */\n+\n+static int\n+nested_anon_class_index (tree type)\n+{\n+  int index = 0;\n+  tree member = TYPE_FIELDS (TYPE_CONTEXT (type));\n+  for (; member; member = TREE_CHAIN (member))\n+    if (DECL_IMPLICIT_TYPEDEF_P (member))\n+      {\n+\ttree memtype = TREE_TYPE (member);\n+\tif (memtype == type)\n+\t  return index;\n+\telse if (TYPE_ANONYMOUS_P (memtype))\n+\t  ++index;\n+      }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* <unnamed-type-name> ::= Ut [ <nonnegative number> ] _ */\n+\n static void\n write_unnamed_type_name (const tree type __attribute__ ((__unused__)))\n {\n+  int discriminator;\n   MANGLE_TRACE_TREE (\"unnamed-type-name\", type);\n \n+  if (TYPE_FUNCTION_SCOPE_P (type))\n+    discriminator = local_class_index (type);\n+  else if (TYPE_CLASS_SCOPE_P (type))\n+    discriminator = nested_anon_class_index (type);\n+  else\n+    {\n+      gcc_assert (no_linkage_check (type, /*relaxed_p=*/true));\n+      /* Just use the old mangling at namespace scope.  */\n+      write_source_name (TYPE_IDENTIFIER (type));\n+      return;\n+    }\n+\n   write_string (\"Ut\");\n-  /* TODO: Implement discriminators for unnamed-types.  */\n-  write_char ('_');\n+  write_compact_number (discriminator);\n }\n \n /* <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _\n@@ -1539,41 +1573,58 @@ write_special_name_destructor (const tree dtor)\n     }\n }\n \n+/* Scan the vector of local classes and return how many others with the\n+   same name (or same no name) and context precede ENTITY.  */\n+\n+static int\n+local_class_index (tree entity)\n+{\n+  int ix, discriminator = 0;\n+  tree name = (TYPE_ANONYMOUS_P (entity) ? NULL_TREE\n+\t       : TYPE_IDENTIFIER (entity));\n+  tree ctx = TYPE_CONTEXT (entity);\n+  for (ix = 0; ; ix++)\n+    {\n+      tree type = VEC_index (tree, local_classes, ix);\n+      if (type == entity)\n+\treturn discriminator;\n+      if (TYPE_CONTEXT (type) == ctx\n+\t  && (name ? TYPE_IDENTIFIER (type) == name\n+\t      : TYPE_ANONYMOUS_P (type)))\n+\t++discriminator;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Return the discriminator for ENTITY appearing inside\n    FUNCTION.  The discriminator is the lexical ordinal of VAR among\n    entities with the same name in the same FUNCTION.  */\n \n static int\n discriminator_for_local_entity (tree entity)\n {\n-  /* Assume this is the only local entity with this name.  */\n-  int discriminator = 0;\n-\n-  if (DECL_DISCRIMINATOR_P (entity) && DECL_LANG_SPECIFIC (entity))\n-    discriminator = DECL_DISCRIMINATOR (entity);\n+  if (DECL_DISCRIMINATOR_P (entity))\n+    {\n+      if (DECL_LANG_SPECIFIC (entity))\n+\treturn DECL_DISCRIMINATOR (entity);\n+      else\n+\t/* The first entity with a particular name doesn't get\n+\t   DECL_LANG_SPECIFIC/DECL_DISCRIMINATOR.  */\n+\treturn 0;\n+    }\n   else if (TREE_CODE (entity) == TYPE_DECL)\n     {\n-      int ix;\n-\n       /* Scan the list of local classes.  */\n       entity = TREE_TYPE (entity);\n \n       /* Lambdas and unnamed types have their own discriminators.  */\n       if (LAMBDA_TYPE_P (entity) || TYPE_ANONYMOUS_P (entity))\n \treturn 0;\n \n-      for (ix = 0; ; ix++)\n-\t{\n-\t  tree type = VEC_index (tree, local_classes, ix);\n-\t  if (type == entity)\n-\t    break;\n-\t  if (TYPE_IDENTIFIER (type) == TYPE_IDENTIFIER (entity)\n-\t      && TYPE_CONTEXT (type) == TYPE_CONTEXT (entity))\n-\t    ++discriminator;\n-\t}\n+      return local_class_index (entity);\n     }\n-\n-  return discriminator;\n+  else\n+    gcc_unreachable ();\n }\n \n /* Return the discriminator for STRING, a string literal used inside"}, {"sha": "ef98be2c321e3c1c986d42b978453de07a62033f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3930dbe9d6c9849e32ce39d7ff585348d4716329", "patch": "@@ -1,3 +1,7 @@\n+2009-10-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/abi/mangle32.C: New.\n+\n 2009-10-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/atomic2.adb: New test."}, {"sha": "de02887f9975a8f8e41ac9c39f59fe60caad46d2", "filename": "gcc/testsuite/g++.dg/abi/mangle32.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3930dbe9d6c9849e32ce39d7ff585348d4716329/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle32.C?ref=3930dbe9d6c9849e32ce39d7ff585348d4716329", "patch": "@@ -0,0 +1,41 @@\n+// Testcase for mangling of unnamed types.\n+\n+// namespace-scope unnamed types have no linkage, so we only test that they\n+// are distinct.\n+typedef struct { } *A;\n+typedef struct { } *B;\n+\n+void f(A) { }\n+void f(B) { }\n+\n+struct C\n+{\n+  typedef struct { }* D;\n+  typedef enum { }* E;\n+};\n+\n+// { dg-final { scan-assembler \"_Z2g1PN1CUt_E\" } }\n+void g1(C::D) { }\n+// { dg-final { scan-assembler \"_Z2g2PN1CUt0_E\" } }\n+void g2(C::E) { }\n+\n+template <class T>\n+void h1(T t) { }\n+\n+template <class T>\n+void h2(T t) { }\n+\n+inline void j()\n+{\n+  typedef enum { }* F;\n+// { dg-final { scan-assembler \"_Z2h1IPZ1jvEUt_EvT_\" } }\n+  h1(F());\n+  typedef struct { }* G;\n+// { dg-final { scan-assembler \"_Z2h2IPZ1jvEUt0_EvT_\" } }\n+  h2(G());\n+}\n+\n+int main()\n+{\n+  j();\n+}"}]}