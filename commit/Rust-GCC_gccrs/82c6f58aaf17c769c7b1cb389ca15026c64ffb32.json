{"sha": "82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjNmY1OGFhZjE3Yzc2OWM3YjFjYjM4OWNhMTUwMjZjNjRmZmIzMg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-04-20T07:13:23Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-04-20T07:13:23Z"}, "message": "PR70674: S/390: Add memory barrier to stack pointer restore from fpr.\n\nThis patches fixes a problem with stack variable accesses being\nscheduled after the stack pointer restore instructions.  In the\ntestcase this happened with the stack variable 'a' accessed through the\nframe pointer.\n\nThe existing stack_tie we have in the backend is basically useless\nwhen trying to block stack variable accesses from being scheduled\nacross an insn.  The alias set of stack variables and the frame alias\nset usually differ and hence aren't in conflict with each other.  The\nsolution appears to be a magic MEM term with a scratch register which\nis handled as a full memory barrier when analyzing scheduling\ndependencies.\n\nWith the patch a (clobber (mem:BLK (scratch))) is being added to the\nrestore instruction in order to prevent any memory operations to be\nscheduled across the insn.  The patch does that only for the one case\nwhere the stack pointer is restored from an FPR.  Theoretically this\nmight happen also in the case where the stack pointer gets restored\nusing a load multiple.  However, triggering that problem with\nload-multiple appears to be much harder since the load-multiple will\nrestore the frame pointer as well.  So in order to see the problem a\ndifferent call-clobbered register would need to be used as temporary\nstack pointer.\n\nAnother case which needs to be handled some day is the stack pointer\nallocation part.  It needs to be a memory barrier as well.\n\nBootstrapped and regression tested with --with-arch z196 and z13 on\ns390 and s390x.\n\n-Andreas-\n\ngcc/ChangeLog:\n\n2016-04-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\tPR target/70674\n\t* config/s390/s390.c (s390_restore_gprs_from_fprs): Pick the new\n\tstack_restore_from_fpr pattern when restoring r15.\n\t(s390_optimize_prologue): Strip away the memory barrier in the\n\tparallel when trying to get rid of restore insns.\n\t* config/s390/s390.md (\"stack_restore_from_fpr\"): New insn\n\tdefinition for loading the stack pointer from an FPR.  Compared to\n\tthe normal move insn this pattern includes a full memory barrier.\n\ngcc/testsuite/ChangeLog:\n\n2016-04-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\tPR target/70674\n\t* gcc.target/s390/pr70674.c: New test.\n\nFrom-SVN: r235234", "tree": {"sha": "6173dc8b27fe3bd23e45989366037df9723eb16a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6173dc8b27fe3bd23e45989366037df9723eb16a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/comments", "author": null, "committer": null, "parents": [{"sha": "843110834c557d7a68c11c9313d426301ca65dc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/843110834c557d7a68c11c9313d426301ca65dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/843110834c557d7a68c11c9313d426301ca65dc1"}], "stats": {"total": 130, "additions": 92, "deletions": 38}, "files": [{"sha": "685aba31ccb66dc217b92e241ec19e2e92651913", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "patch": "@@ -1,3 +1,14 @@\n+2016-04-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\tPR target/70674\n+\t* config/s390/s390.c (s390_restore_gprs_from_fprs): Pick the new\n+\tstack_restore_from_fpr pattern when restoring r15.\n+\t(s390_optimize_prologue): Strip away the memory barrier in the\n+\tparallel when trying to get rid of restore insns.\n+\t* config/s390/s390.md (\"stack_restore_from_fpr\"): New insn\n+\tdefinition for loading the stack pointer from an FPR.  Compared to\n+\tthe normal move insn this pattern includes a full memory barrier.\n+\n 2016-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/70680"}, {"sha": "a1d0930c071383f65905b2197f7673c02de415f7", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "patch": "@@ -10538,19 +10538,25 @@ s390_restore_gprs_from_fprs (void)\n \n   for (i = 6; i < 16; i++)\n     {\n-      if (FP_REGNO_P (cfun_gpr_save_slot (i)))\n-\t{\n-\t  rtx_insn *insn =\n-\t    emit_move_insn (gen_rtx_REG (DImode, i),\n-\t\t\t    gen_rtx_REG (DImode, cfun_gpr_save_slot (i)));\n-\t  df_set_regs_ever_live (i, true);\n-\t  add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (DImode, i));\n-\t  if (i == STACK_POINTER_REGNUM)\n-\t    add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t STACK_POINTER_OFFSET));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n+      rtx_insn *insn;\n+\n+      if (!FP_REGNO_P (cfun_gpr_save_slot (i)))\n+\tcontinue;\n+\n+      rtx fpr = gen_rtx_REG (DImode, cfun_gpr_save_slot (i));\n+\n+      if (i == STACK_POINTER_REGNUM)\n+\tinsn = emit_insn (gen_stack_restore_from_fpr (fpr));\n+      else\n+\tinsn = emit_move_insn (gen_rtx_REG (DImode, i), fpr);\n+\n+      df_set_regs_ever_live (i, true);\n+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (DImode, i));\n+      if (i == STACK_POINTER_REGNUM)\n+\tadd_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t      plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t     STACK_POINTER_OFFSET));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n }\n \n@@ -13032,37 +13038,46 @@ s390_optimize_prologue (void)\n \n       /* Remove ldgr/lgdr instructions used for saving and restore\n \t GPRs if possible.  */\n-      if (TARGET_Z10\n-\t  && GET_CODE (pat) == SET\n-\t  && GET_MODE (SET_SRC (pat)) == DImode\n-\t  && REG_P (SET_SRC (pat))\n-\t  && REG_P (SET_DEST (pat)))\n+      if (TARGET_Z10)\n \t{\n-\t  int src_regno = REGNO (SET_SRC (pat));\n-\t  int dest_regno = REGNO (SET_DEST (pat));\n-\t  int gpr_regno;\n-\t  int fpr_regno;\n+\t  rtx tmp_pat = pat;\n \n-\t  if (!((GENERAL_REGNO_P (src_regno) && FP_REGNO_P (dest_regno))\n-\t\t|| (FP_REGNO_P (src_regno) && GENERAL_REGNO_P (dest_regno))))\n-\t    continue;\n+\t  if (INSN_CODE (insn) == CODE_FOR_stack_restore_from_fpr)\n+\t    tmp_pat = XVECEXP (pat, 0, 0);\n \n-\t  gpr_regno = GENERAL_REGNO_P (src_regno) ? src_regno : dest_regno;\n-\t  fpr_regno = FP_REGNO_P (src_regno) ? src_regno : dest_regno;\n+\t  if (GET_CODE (tmp_pat) == SET\n+\t      && GET_MODE (SET_SRC (tmp_pat)) == DImode\n+\t      && REG_P (SET_SRC (tmp_pat))\n+\t      && REG_P (SET_DEST (tmp_pat)))\n+\t    {\n+\t      int src_regno = REGNO (SET_SRC (tmp_pat));\n+\t      int dest_regno = REGNO (SET_DEST (tmp_pat));\n+\t      int gpr_regno;\n+\t      int fpr_regno;\n+\n+\t      if (!((GENERAL_REGNO_P (src_regno)\n+\t\t     && FP_REGNO_P (dest_regno))\n+\t\t    || (FP_REGNO_P (src_regno)\n+\t\t\t&& GENERAL_REGNO_P (dest_regno))))\n+\t\tcontinue;\n \n-\t  /* GPR must be call-saved, FPR must be call-clobbered.  */\n-\t  if (!call_really_used_regs[fpr_regno]\n-\t      || call_really_used_regs[gpr_regno])\n-\t    continue;\n+\t      gpr_regno = GENERAL_REGNO_P (src_regno) ? src_regno : dest_regno;\n+\t      fpr_regno = FP_REGNO_P (src_regno) ? src_regno : dest_regno;\n \n-\t  /* It must not happen that what we once saved in an FPR now\n-\t     needs a stack slot.  */\n-\t  gcc_assert (cfun_gpr_save_slot (gpr_regno) != SAVE_SLOT_STACK);\n+\t      /* GPR must be call-saved, FPR must be call-clobbered.  */\n+\t      if (!call_really_used_regs[fpr_regno]\n+\t\t  || call_really_used_regs[gpr_regno])\n+\t\tcontinue;\n \n-\t  if (cfun_gpr_save_slot (gpr_regno) == SAVE_SLOT_NONE)\n-\t    {\n-\t      remove_insn (insn);\n-\t      continue;\n+\t      /* It must not happen that what we once saved in an FPR now\n+\t\t needs a stack slot.  */\n+\t      gcc_assert (cfun_gpr_save_slot (gpr_regno) != SAVE_SLOT_STACK);\n+\n+\t      if (cfun_gpr_save_slot (gpr_regno) == SAVE_SLOT_NONE)\n+\t\t{\n+\t\t  remove_insn (insn);\n+\t\t  continue;\n+\t\t}\n \t    }\n \t}\n "}, {"sha": "2b4e8f4b2b2338bb5294312e7ec64d29a356149d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "patch": "@@ -299,6 +299,8 @@\n    (BASE_REGNUM\t\t\t13)\n    ; Return address register.\n    (RETURN_REGNUM\t\t14)\n+   ; Stack pointer register.\n+   (STACK_REGNUM\t\t15)\n    ; Condition code register.\n    (CC_REGNUM\t\t\t33)\n    ; Thread local storage pointer register.\n@@ -10387,6 +10389,14 @@\n   [(set_attr \"length\" \"0\")])\n \n \n+(define_insn \"stack_restore_from_fpr\"\n+  [(set (reg:DI STACK_REGNUM)\n+\t(match_operand:DI 0 \"register_operand\" \"f\"))\n+   (clobber (mem:BLK (scratch)))]\n+  \"TARGET_Z10\"\n+  \"lgdr\\t%%r15,%0\"\n+  [(set_attr \"op_type\"  \"RRE\")])\n+\n ;\n ; Data prefetch patterns\n ;"}, {"sha": "55e7bbda21f4394abf9f7fe37da769e869802820", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "patch": "@@ -1,3 +1,8 @@\n+2016-04-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\tPR target/70674\n+\t* gcc.target/s390/pr70674.c: New test.\n+\n 2016-04-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/70684"}, {"sha": "13bf271d95ffac6588bf4f9b11263a801fc1d5e4", "filename": "gcc/testsuite/gcc.target/s390/pr70674.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr70674.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c6f58aaf17c769c7b1cb389ca15026c64ffb32/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr70674.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr70674.c?ref=82c6f58aaf17c769c7b1cb389ca15026c64ffb32", "patch": "@@ -0,0 +1,13 @@\n+/* Test case for PR/70674.  */\n+\n+/* { dg-do compile { target s390x-*-* } } */\n+/* { dg-options \"-march=z10 -mtune=z196 -O2 -fno-omit-frame-pointer -fno-asynchronous-unwind-tables\" } */\n+\n+void\n+foo (void)\n+{\n+  volatile int a = 5;\n+  (void) a;\n+}\n+\n+/* { dg-final { scan-assembler-not \"^.*lgdr.*\\n.*\\\\(%r11\\\\)\" } } */"}]}