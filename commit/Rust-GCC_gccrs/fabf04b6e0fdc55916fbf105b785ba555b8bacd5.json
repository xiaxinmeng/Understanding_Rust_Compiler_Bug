{"sha": "fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiZjA0YjZlMGZkYzU1OTE2ZmJmMTA1Yjc4NWJhNTU1YjhiYWNkNQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-18T23:06:06Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-18T23:06:06Z"}, "message": "ns32k-protos.h: New file.\n\n        * ns32k-protos.h: New file.\n\n        * ns32k.c: Fix compile time warnings.\n\n        * ns32k.h: Move prototypes to ns32k-protos.h.  Fix compile time\n        warnings.\n\n        * ns32k.md: Likewise.\n\nFrom-SVN: r31494", "tree": {"sha": "722249e7acd5b072e14bd7ca3151db758705d97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/722249e7acd5b072e14bd7ca3151db758705d97b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/comments", "author": null, "committer": null, "parents": [{"sha": "2fd58acb350822b9b9fd4dc92fc924f5a53a30b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd58acb350822b9b9fd4dc92fc924f5a53a30b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd58acb350822b9b9fd4dc92fc924f5a53a30b4"}], "stats": {"total": 175, "additions": 104, "deletions": 71}, "files": [{"sha": "d41d3bbb5053b097d68ecff44a0cbb68fed85209", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "patch": "@@ -1,3 +1,14 @@\n+2000-01-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* ns32k-protos.h: New file.\n+\n+\t* ns32k.c: Fix compile time warnings.\n+\t\n+\t* ns32k.h: Move prototypes to ns32k-protos.h.  Fix compile time\n+\twarnings.\n+\n+\t* ns32k.md: Likewise.\n+\n 2000-01-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* vax-protos.h: New file."}, {"sha": "496d0862e09b24183b6dde501e2366fdd7352fda", "filename": "gcc/config/ns32k/ns32k-protos.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k-protos.h?ref=fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "patch": "@@ -0,0 +1,49 @@\n+/* Definitions of target machine for GNU compiler.  NS32000 version.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Prototypes for functions in ns32k.c */\n+\n+#ifdef RTX_CODE\n+extern int calc_address_cost PARAMS ((rtx));\n+extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n+\t\t\t\t\t\t      enum machine_mode, rtx));\n+extern int reg_or_mem_operand PARAMS ((rtx, enum machine_mode));\n+\n+extern void split_di PARAMS ((rtx[], int, rtx[], rtx[]));\n+extern void expand_block_move PARAMS ((rtx[]));\n+extern int global_symbolic_reference_mentioned_p PARAMS ((rtx, int));\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern const char *output_move_double PARAMS ((rtx *));\n+extern const char *output_shift_insn PARAMS ((rtx *));\n+extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern int ns32k_comp_type_attributes PARAMS ((tree, tree));\n+extern int ns32k_return_pops_args PARAMS ((tree, tree, int));\n+extern int ns32k_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n+extern int ns32k_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+#endif /* TREE_CODE */\n+\n+extern int hard_regno_mode_ok PARAMS ((int, enum machine_mode));\n+extern int register_move_cost PARAMS ((enum reg_class, enum reg_class));\n+extern const char *output_move_dconst PARAMS ((int, const char *));"}, {"sha": "bf63a882759e80aa2e33db7603b892ca6cde55a0", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the NS32000.\n-   Copyright (C) 1988, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 94-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -33,16 +33,18 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n+#include \"recog.h\"\n+#include \"tm_p.h\"\n \n #ifdef OSF_OS\n int ns32k_num_files = 0;\n #endif\n \n-/* This duplicates reg_class_contens in reg_class.c, but maybe that isn't\n+/* This duplicates reg_class_contents in reg_class.c, but maybe that isn't\n    initialized in time. Also this is more convenient as an array of ints.\n    We know that HARD_REG_SET fits in an unsigned int */\n \n-unsigned int ns32k_reg_class_contents[N_REG_CLASSES] = REG_CLASS_CONTENTS;\n+unsigned int ns32k_reg_class_contents[N_REG_CLASSES][1] = REG_CLASS_CONTENTS;\n \n enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n {\n@@ -55,15 +57,11 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   FRAME_POINTER_REG, STACK_POINTER_REG\n };\n \n-char *ns32k_out_reg_names[] = OUTPUT_REGISTER_NAMES;\n-\n-void\n-trace (s, s1, s2)\n-     char *s, *s1, *s2;\n-{\n-  fprintf (stderr, s, s1, s2);\n-}\n+const char *const ns32k_out_reg_names[] = OUTPUT_REGISTER_NAMES;\n \n+static rtx gen_indexed_expr PARAMS ((rtx, rtx, rtx));\n+static const char *singlemove_string PARAMS ((rtx *));\n+static void move_tail PARAMS ((rtx[], int, int));\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n int\n@@ -179,7 +177,7 @@ calc_address_cost (operand)\n enum reg_class\n secondary_reload_class (class, mode, in)\n      enum reg_class class;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      rtx in;\n {\n   int regno = true_regnum (in);\n@@ -265,7 +263,7 @@ split_di (operands, num, lo_half, hi_half)\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.  */\n \n-static char *\n+static const char *\n singlemove_string (operands)\n      rtx *operands;\n {\n@@ -276,7 +274,7 @@ singlemove_string (operands)\n   return \"movd %1,%0\";\n }\n \n-char *\n+const char *\n output_move_double (operands)\n      rtx *operands;\n {\n@@ -454,7 +452,6 @@ expand_block_move (operands)\n   rtx src_reg = gen_rtx(REG, Pmode, 1);\n   rtx dest_reg = gen_rtx(REG, Pmode, 2);\n   rtx count_reg = gen_rtx(REG, SImode, 0);\n-  rtx insn;\n \n   if (constp && bytes <= 0)\n     return;\n@@ -463,6 +460,7 @@ expand_block_move (operands)\n     {\n       int words = bytes >> 2;\n       if (words)\n+      {\n \tif (words < 3 || flag_unroll_loops)\n \t  {\n \t    int offset = 0;\n@@ -488,6 +486,7 @@ expand_block_move (operands)\n \t    \n \t    emit_insn(gen_movstrsi2(dest, src, GEN_INT(words)));\n \t  }\n+      }\n       move_tail(operands, bytes & 3, bytes & ~3);\n       return;\n     }\n@@ -504,8 +503,6 @@ expand_block_move (operands)\n \n   if (constp && (align == UNITS_PER_WORD || bytes < MAX_UNALIGNED_COPY))\n     {\n-      rtx  bytes_reg;\n-\n       /* constant no of bytes and aligned or small enough copy to not bother\n        * aligning. Emit insns to copy by words.\n        */\n@@ -640,10 +637,10 @@ symbolic_reference_mentioned_p (op)\n \n int\n ns32k_valid_decl_attribute_p (decl, attributes, identifier, args)\n-     tree decl;\n-     tree attributes;\n-     tree identifier;\n-     tree args;\n+     tree decl ATTRIBUTE_UNUSED;\n+     tree attributes ATTRIBUTE_UNUSED;\n+     tree identifier ATTRIBUTE_UNUSED;\n+     tree args ATTRIBUTE_UNUSED;\n {\n   return 0;\n }\n@@ -655,7 +652,7 @@ ns32k_valid_decl_attribute_p (decl, attributes, identifier, args)\n int\n ns32k_valid_type_attribute_p (type, attributes, identifier, args)\n      tree type;\n-     tree attributes;\n+     tree attributes ATTRIBUTE_UNUSED;\n      tree identifier;\n      tree args;\n {\n@@ -682,8 +679,8 @@ ns32k_valid_type_attribute_p (type, attributes, identifier, args)\n \n int\n ns32k_comp_type_attributes (type1, type2)\n-     tree type1;\n-     tree type2;\n+     tree type1 ATTRIBUTE_UNUSED;\n+     tree type2 ATTRIBUTE_UNUSED;\n {\n   return 1;\n }\n@@ -708,7 +705,7 @@ ns32k_comp_type_attributes (type1, type2)\n \n int\n ns32k_return_pops_args (fundecl, funtype, size)\n-     tree fundecl;\n+     tree fundecl ATTRIBUTE_UNUSED;\n      tree funtype;\n      int size;\n {\n@@ -744,7 +741,7 @@ void\n print_operand (file, x, code)\n      FILE *file;\n      rtx x;\n-     char code;\n+     int code;\n {\n   if (code == '$')\n     PUT_IMMEDIATE_PREFIX (file);\n@@ -754,7 +751,6 @@ print_operand (file, x, code)\n     fprintf (file, \"%s\", ns32k_out_reg_names[REGNO (x)]);\n   else if (GET_CODE (x) == MEM)\n     {\n-      rtx tmp = XEXP (x, 0);\n       output_address (XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n@@ -1124,13 +1120,14 @@ print_operand_address (file, addr)\n /* National 32032 shifting is so bad that we can get\n    better performance in many common cases by using other\n    techniques.  */\n-char *\n+const char *\n output_shift_insn (operands)\n      rtx *operands;\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) > 0\n       && INTVAL (operands[2]) <= 3)\n+  {\n     if (GET_CODE (operands[0]) == REG)\n       {\n \tif (GET_CODE (operands[1]) == REG)\n@@ -1169,13 +1166,14 @@ output_shift_insn (operands)\n \t  return \"addd %0,%0\";\n       }\n     else return \"ashd %2,%0\";\n+  }\n   return \"ashd %2,%0\";\n }\n \n-char *\n+const char *\n output_move_dconst (n, s)\n \tint n;\n-\tchar *s;\n+\tconst char *s;\n {\n   static char r[32];\n "}, {"sha": "f8ec28e73e1bacbbcfbb9bbaf99682a316da7ac7", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  NS32000 version.\n-   Copyright (C) 1988, 93, 94-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 93, 94-99, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -408,12 +408,12 @@ enum reg_class\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS {0, 0x00ff, 0x100, 0x300, 0xff00, \\\n-                            0xffff00, 0xffffff, 0x1000000, 0x2000000, \\\n-                            0x30000ff, 0x3ffffff }\n+#define REG_CLASS_CONTENTS {{0}, {0x00ff}, {0x100}, {0x300}, {0xff00}, \\\n+                            {0xffff00}, {0xffffff}, {0x1000000}, {0x2000000}, \\\n+                            {0x30000ff}, {0x3ffffff} }\n \n #define SUBSET_P(CLASS1, CLASS2) \\\n-   ((ns32k_reg_class_contents[CLASS1] & ~ns32k_reg_class_contents[CLASS2]) \\\n+   ((ns32k_reg_class_contents[CLASS1][0] & ~ns32k_reg_class_contents[CLASS2][0]) \\\n      == 0)\n \n /* The same information, inverted:\n@@ -1145,8 +1145,7 @@ __transfer_from_trampoline ()\t\t\\\n /* Go to ADDR if X is a valid address not using indexing.\n    (This much is the easy part.)  */\n #define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n+{ if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n   if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n     if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1)))\t\t\t\\\n@@ -1211,7 +1210,9 @@ __transfer_from_trampoline ()\t\t\\\n   else if (INDEX_TERM_P (xfooy, MODE))\t\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (xfooy) == PRE_DEC)\t\t\t\t\t\\\n-    if (REGNO (XEXP (xfooy, 0)) == STACK_POINTER_REGNUM) goto ADDR;\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (REGNO (XEXP (xfooy, 0)) == STACK_POINTER_REGNUM) goto ADDR;\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   else abort ();\t\t\t\t\t\t\t\\\n }\n \n@@ -1594,7 +1595,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    This is suitable for output with `assemble_name'.  */\n \n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+  sprintf (LABEL, \"*%s%ld\", PREFIX, (long) NUM)\n \n /* This is how to align the code that follows an unconditional branch.  */\n \n@@ -1676,38 +1677,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address(FILE, ADDR)\n \n-/* Prototypes for functions in ns32k.c */\n-\n-/* Prototypes would be nice, but for now it causes too many problems.\n-   This file gets included in places where the types (such as \"rtx\"\n-   and enum machine_mode) are not defined. */\n-#define NS32K_PROTO(ARGS) ()\n-\n-int hard_regno_mode_ok NS32K_PROTO((int regno, enum machine_mode mode));\n-int register_move_cost NS32K_PROTO((enum reg_class CLASS1, enum reg_class CLASS2));\n-int calc_address_cost NS32K_PROTO((rtx operand));\n-enum reg_class secondary_reload_class NS32K_PROTO((enum reg_class class,\n-\t\t\t\t\t     enum machine_mode mode, rtx in));\n-int reg_or_mem_operand NS32K_PROTO((register rtx op, enum machine_mode mode));\n-\n-void split_di NS32K_PROTO((rtx operands[], int num, rtx lo_half[], hi_half[]));\n-\n-void expand_block_move NS32K_PROTO((rtx operands[]));\n-int global_symbolic_reference_mentioned_p NS32K_PROTO((rtx op, int f));\n-int ns32k_comp_type_attributes NS32K_PROTO((tree type1, tree type2));\n-int ns32k_return_pops_args NS32K_PROTO((tree fundecl, tree funtype, int size));\n-int ns32k_valid_decl_attribute_p NS32K_PROTO((tree decl, tree attributes,\n-\t\t\t\t\t\ttree identifier, tree args));\n-int ns32k_valid_type_attribute_p NS32K_PROTO((tree decl, tree attributes,\n-\t\t\t\t\t\ttree identifier, tree args));\n-void print_operand NS32K_PROTO((FILE *file, rtx x, char code));\n-void print_operand_address NS32K_PROTO((register FILE *file, register rtx addr));\n-char *output_move_dconst NS32K_PROTO((int n, char *s));\n-char *output_move_double NS32K_PROTO((rtx *operands));\n-char *output_shift_insn NS32K_PROTO((rtx *operands));\n-\n-extern unsigned int ns32k_reg_class_contents[N_REG_CLASSES];\n-extern char *ns32k_out_reg_names[];\n+extern unsigned int ns32k_reg_class_contents[N_REG_CLASSES][1];\n+extern const char *const ns32k_out_reg_names[];\n extern enum reg_class regclass_map[];\t\t/* smalled class containing REGNO */\n \n /*"}, {"sha": "10ba1d413a1ca59c11ebb6982894b202cdcdea97", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabf04b6e0fdc55916fbf105b785ba555b8bacd5/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=fabf04b6e0fdc55916fbf105b785ba555b8bacd5", "patch": "@@ -2245,12 +2245,14 @@\n   \"TARGET_BITFIELD\"\n   \"*\n { if (GET_CODE (operands[2]) == CONST_INT)\n+  {\n     if (INTVAL (operands[1]) <= 8)\n       return \\\"inssb %3,%0,%2,%1\\\";\n     else if (INTVAL (operands[1]) <= 16)\n       return \\\"inssw %3,%0,%2,%1\\\";\n     else\n       return \\\"inssd %3,%0,%2,%1\\\";\n+  }\n   return \\\"insd %2,%3,%0,%1\\\";\n }\")\n \n@@ -2262,12 +2264,14 @@\n   \"TARGET_BITFIELD\"\n   \"*\n { if (GET_CODE (operands[2]) == CONST_INT)\n+  {\n     if (INTVAL (operands[1]) <= 8)\n       return \\\"inssb %3,%0,%2,%1\\\";\n     else if (INTVAL (operands[1]) <= 16)\n       return \\\"inssw %3,%0,%2,%1\\\";\n     else\n       return \\\"inssd %3,%0,%2,%1\\\";\n+  }\n   return \\\"insd %2,%3,%0,%1\\\";\n }\")\n "}]}