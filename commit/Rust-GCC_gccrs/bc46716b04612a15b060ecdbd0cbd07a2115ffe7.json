{"sha": "bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0NjcxNmIwNDYxMmExNWIwNjBlY2RiZDBjYmQwN2EyMTE1ZmZlNw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-01-04T23:57:40Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-04T23:57:40Z"}, "message": "c4x.h (IS_XXX_REG, [...]): Swap behaviour of macros so that they're consistent with their names.\n\n\t* config/c4x/c4x.h (IS_XXX_REG, IS_XXX_REGNO): Swap behaviour of\n\tmacros so that they're consistent with their names.\n\t* config/c4x/c4x.c (IS_XXX_REG, IS_XXX_REGNO): Likewise.\n\t* config/c4x/c4x.md (IS_XXX_REG, IS_XXX_REGNO): Likewise.\n\nFrom-SVN: r31221", "tree": {"sha": "60e19e2500f2d130a1f841d904b58c21c857617f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60e19e2500f2d130a1f841d904b58c21c857617f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/comments", "author": null, "committer": null, "parents": [{"sha": "d79229bd58843650dd7585079bb5915ffc8afe60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79229bd58843650dd7585079bb5915ffc8afe60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79229bd58843650dd7585079bb5915ffc8afe60"}], "stats": {"total": 288, "additions": 150, "deletions": 138}, "files": [{"sha": "860318cad27e36361b76999edf1cd63e7fc6dcb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "patch": "@@ -1,3 +1,10 @@\n+2000-01-05  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.h (IS_XXX_REG, IS_XXX_REGNO): Swap behaviour of \n+\tmacros so that they're consistent with their names.\n+\t* config/c4x/c4x.c (IS_XXX_REG, IS_XXX_REGNO): Likewise.\n+\t* config/c4x/c4x.md (IS_XXX_REG, IS_XXX_REGNO): Likewise.\n+\n 2000-01-05  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (*addqi3_noclobber_reload): Ensure that CC never"}, {"sha": "778773d4f6c2dcc71e119d0407f41e7aed6c54b4", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the TMS320C[34]x\n-   Copyright (C) 1994-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1994-99, 2000 Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n               and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n@@ -332,22 +332,22 @@ c4x_hard_regno_mode_ok (regno, mode)\n     case Pmode:\t\t\t/* Pointer (24/32 bits) */\n #endif\n     case QImode:\t\t/* Integer (32 bits) */\n-      return IS_INT_REG (regno);\n+      return IS_INT_REGNO (regno);\n \n     case QFmode:\t\t/* Float, Double (32 bits) */\n     case HFmode:\t\t/* Long Double (40 bits) */\n-      return IS_EXT_REG (regno);\n+      return IS_EXT_REGNO (regno);\n \n     case CCmode:\t\t/* Condition Codes */\n     case CC_NOOVmode:\t\t/* Condition Codes */\n-      return IS_ST_REG (regno);\n+      return IS_ST_REGNO (regno);\n \n     case HImode:\t\t/* Long Long (64 bits) */\n       /* We need two registers to store long longs.  Note that \n \t it is much easier to constrain the first register\n \t to start on an even boundary.  */\n-      return IS_INT_REG (regno)\n-\t&& IS_INT_REG (regno + 1)\n+      return IS_INT_REGNO (regno)\n+\t&& IS_INT_REGNO (regno + 1)\n \t&& (regno & 1) == 0;\n \n     default:\n@@ -636,13 +636,13 @@ c4x_isr_reg_used_p (regno)\n {\n   /* Don't save/restore FP or ST, we handle them separately.  */\n   if (regno == FRAME_POINTER_REGNUM\n-      || IS_ST_REG (regno))\n+      || IS_ST_REGNO (regno))\n     return 0;\n \n   /* We could be a little smarter abut saving/restoring DP.\n      We'll only save if for the big memory model or if\n      we're paranoid. ;-)  */\n-  if (IS_DP_REG (regno))\n+  if (IS_DP_REGNO (regno))\n     return ! TARGET_SMALL || TARGET_PARANOID;\n \n   /* Only save/restore regs in leaf function that are used.  */\n@@ -652,7 +652,7 @@ c4x_isr_reg_used_p (regno)\n   /* Only save/restore regs that are used by the ISR and regs\n      that are likely to be used by functions the ISR calls\n      if they are not fixed.  */\n-  return IS_EXT_REG (regno)\n+  return IS_EXT_REGNO (regno)\n     || ((regs_ever_live[regno] || call_used_regs[regno]) \n \t&& fixed_regs[regno] == 0);\n }\n@@ -757,7 +757,7 @@ c4x_function_prologue (file, size)\n \t  if (c4x_isr_reg_used_p (regno))\n \t    {\n \t      fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n-\t      if (IS_EXT_REG (regno))\t/* save 32MSB of R0--R11 */\n+\t      if (IS_EXT_REGNO (regno))\t/* save 32MSB of R0--R11 */\n \t\tfprintf (file, \"\\tpushf\\t%s\\n\", float_reg_names[regno]);\n \t    }\n \t}\n@@ -890,7 +890,7 @@ c4x_function_epilogue (file, size)\n \t{\n \t  if (! c4x_isr_reg_used_p (regno))\n \t    continue;\n-\t  if (IS_EXT_REG (regno))\n+\t  if (IS_EXT_REGNO (regno))\n \t    fprintf (file, \"\\tpopf\\t%s\\n\", float_reg_names[regno]);\n \t  fprintf (file, \"\\tpop\\t%s\\n\", reg_names[regno]);\n \t}\n@@ -1371,7 +1371,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \t      {\n \t\tbase = op0;\t/* base + index */\n \t\tindx = op1;\n-\t\tif (IS_INDEX_REGNO (base) || IS_ADDR_REGNO (indx))\n+\t\tif (IS_INDEX_REG (base) || IS_ADDR_REG (indx))\n \t\t  {\n \t\t    base = op1;\n \t\t    indx = op0;\n@@ -1466,7 +1466,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \treturn 1;\n       if (strict && ! REGNO_OK_FOR_BASE_P (REGNO (base)))\n \treturn 0;\n-      else if (! strict && ! IS_ADDR_OR_PSEUDO_REGNO (base))\n+      else if (! strict && ! IS_ADDR_OR_PSEUDO_REG (base))\n \treturn 0;\n     }\n \n@@ -1477,7 +1477,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \treturn 0;\n       if (strict && ! REGNO_OK_FOR_INDEX_P (REGNO (indx)))\n \treturn 0;\n-      else if (! strict && ! IS_INDEX_OR_PSEUDO_REGNO (indx))\n+      else if (! strict && ! IS_INDEX_OR_PSEUDO_REG (indx))\n \treturn 0;\n     }\n \n@@ -1984,7 +1984,7 @@ c4x_print_operand_address (file, addr)\n \t  {\n \t    if (REG_P (op1))\n \t      {\n-\t\tif (IS_INDEX_REGNO (op0))\n+\t\tif (IS_INDEX_REG (op0))\n \t\t  {\n \t\t    fprintf (file, \"*+%s(%s)\",\n \t\t\t     reg_names[REGNO (op1)],\n@@ -2238,15 +2238,15 @@ static int\n c4x_a_register (op)\n      rtx op;\n {\n-  return REG_P (op) && IS_ADDR_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_ADDR_OR_PSEUDO_REG (op);\n }\n \n \n static int\n c4x_x_register (op)\n      rtx op;\n {\n-  return REG_P (op) && IS_INDEX_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_INDEX_OR_PSEUDO_REG (op);\n }\n \n \n@@ -2468,7 +2468,7 @@ c4x_R_indirect (op)\n   switch (GET_CODE (op))\n     {\n     case REG:\n-      return IS_ADDR_OR_PSEUDO_REGNO (op);\n+      return IS_ADDR_OR_PSEUDO_REG (op);\n \n     case PLUS:\n       {\n@@ -2477,12 +2477,12 @@ c4x_R_indirect (op)\n \n \t/* HImode and HFmode must be offsettable.  */\n \tif (mode == HImode || mode == HFmode)\n-\t  return IS_ADDR_OR_PSEUDO_REGNO (op0)\n+\t  return IS_ADDR_OR_PSEUDO_REG (op0)\n \t    && GET_CODE (op1) == CONST_INT \n \t    && IS_UINT5_CONST (INTVAL (op1) + 1);\n \n \treturn REG_P (op0)\n-\t  && IS_ADDR_OR_PSEUDO_REGNO (op0)\n+\t  && IS_ADDR_OR_PSEUDO_REG (op0)\n \t  && GET_CODE (op1) == CONST_INT\n \t  && IS_UINT5_CONST (INTVAL (op1));\n       }\n@@ -2580,7 +2580,7 @@ c4x_S_indirect (op)\n       op = XEXP (op, 0);\n \n     case REG:\n-      return IS_ADDR_OR_PSEUDO_REGNO (op);\n+      return IS_ADDR_OR_PSEUDO_REG (op);\n \n     case PRE_MODIFY:\n     case POST_MODIFY:\n@@ -2597,8 +2597,8 @@ c4x_S_indirect (op)\n \t\n \top0 = XEXP (op1, 0);\n \top1 = XEXP (op1, 1);\n-\treturn REG_P (op0) && IS_ADDR_OR_PSEUDO_REGNO (op0)\n-\t  && REG_P (op1) && IS_INDEX_OR_PSEUDO_REGNO (op1);\n+\treturn REG_P (op0) && IS_ADDR_OR_PSEUDO_REG (op0)\n+\t  && REG_P (op1) && IS_INDEX_OR_PSEUDO_REG (op1);\n \t/* pre or post_modify with a displacement of 0 or 1 \n \t   should not be generated.  */\n       }\n@@ -2612,17 +2612,17 @@ c4x_S_indirect (op)\n \t  {\n \t    /* HImode and HFmode must be offsettable.  */\n \t    if (mode == HImode || mode == HFmode)\n-\t      return IS_ADDR_OR_PSEUDO_REGNO (op0)\n+\t      return IS_ADDR_OR_PSEUDO_REG (op0)\n \t\t&& GET_CODE (op1) == CONST_INT \n \t\t&& IS_DISP1_OFF_CONST (INTVAL (op1));\n \n \t    if (REG_P (op1))\n-\t      return (IS_INDEX_OR_PSEUDO_REGNO (op1)\n-\t\t      && IS_ADDR_OR_PSEUDO_REGNO (op0))\n-\t\t|| (IS_ADDR_OR_PSEUDO_REGNO (op1)\n-\t\t    && IS_INDEX_OR_PSEUDO_REGNO (op0));\n+\t      return (IS_INDEX_OR_PSEUDO_REG (op1)\n+\t\t      && IS_ADDR_OR_PSEUDO_REG (op0))\n+\t\t|| (IS_ADDR_OR_PSEUDO_REG (op1)\n+\t\t    && IS_INDEX_OR_PSEUDO_REG (op0));\n \t    \n-\t    return IS_ADDR_OR_PSEUDO_REGNO (op0)\n+\t    return IS_ADDR_OR_PSEUDO_REG (op0)\n \t      && GET_CODE (op1) == CONST_INT \n \t      && IS_DISP1_CONST (INTVAL (op1));\n \t  }\n@@ -2897,7 +2897,7 @@ r0r1_reg_operand (op, mode)\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  return REG_P (op) && IS_R0R1_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_R0R1_OR_PSEUDO_REG (op);\n }\n \n \n@@ -2912,7 +2912,7 @@ r2r3_reg_operand (op, mode)\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  return REG_P (op) && IS_R2R3_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_R2R3_OR_PSEUDO_REG (op);\n }\n \n \n@@ -2927,7 +2927,7 @@ ext_low_reg_operand (op, mode)\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  return REG_P (op) && IS_EXT_LOW_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_EXT_LOW_OR_PSEUDO_REG (op);\n }\n \n \n@@ -2944,7 +2944,7 @@ ext_reg_operand (op, mode)\n     op = SUBREG_REG (op);\n   if (! REG_P (op))\n     return 0;\n-  return IS_EXT_OR_PSEUDO_REGNO (op);\n+  return IS_EXT_OR_PSEUDO_REG (op);\n }\n \n \n@@ -2959,7 +2959,7 @@ std_reg_operand (op, mode)\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  return REG_P (op) && IS_STD_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_STD_OR_PSEUDO_REG (op);\n }\n \n \n@@ -2998,7 +2998,7 @@ dp_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return REG_P (op) && IS_DP_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_DP_OR_PSEUDO_REG (op);\n }\n \n \n@@ -3009,7 +3009,7 @@ sp_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return REG_P (op) && IS_SP_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_SP_OR_PSEUDO_REG (op);\n }\n \n \n@@ -3020,7 +3020,7 @@ st_reg_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return REG_P (op) && IS_ST_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_ST_OR_PSEUDO_REG (op);\n }\n \n \n@@ -3031,7 +3031,7 @@ rc_reg_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return REG_P (op) && IS_RC_OR_PSEUDO_REGNO (op);\n+  return REG_P (op) && IS_RC_OR_PSEUDO_REG (op);\n }\n \n \n@@ -3832,7 +3832,7 @@ group1_reg_operand (op, mode)\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  return REG_P (op) && IS_GROUP1_REG (REGNO (op));\n+  return REG_P (op) && IS_GROUP1_REG (op);\n }\n \n \n@@ -3852,11 +3852,11 @@ group1_mem_operand (op, mode)\n \t  rtx op0 = XEXP (op, 0);\n \t  rtx op1 = XEXP (op, 1);\n \n-\t  if (((GET_CODE (op0) == REG) && IS_GROUP1_REGNO (op0))\n-\t      || ((GET_CODE (op1) == REG) && IS_GROUP1_REGNO (op1)))\n+\t  if (((GET_CODE (op0) == REG) && IS_GROUP1_REG (op0))\n+\t      || ((GET_CODE (op1) == REG) && IS_GROUP1_REG (op1)))\n \t    return 1;\n \t}\n-      else if ((REG_P (op)) && IS_GROUP1_REGNO (op))\n+      else if ((REG_P (op)) && IS_GROUP1_REG (op))\n \treturn 1;\n     }\n \n@@ -3875,7 +3875,7 @@ arx_reg_operand (op, mode)\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n-  return REG_P (op) && IS_ADDR_REGNO (op);\n+  return REG_P (op) && IS_ADDR_REG (op);\n }\n \n "}, {"sha": "d0e876bc4f129327dc165ede8b3e48d573dbb5c8", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 94, "deletions": 89, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  TMS320C[34]x\n-   Copyright (C) 1994-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1994-99, 2000 Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n               and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n@@ -362,9 +362,9 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n \n #define REAL_ARITHMETIC\n \n-/* Define register numbers */\n+/* Define register numbers.  */\n \n-/* Extended-precision registers */\n+/* Extended-precision registers.  */\n \n #define R0_REGNO   0\n #define R1_REGNO   1\n@@ -375,7 +375,7 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n #define R6_REGNO   6\n #define R7_REGNO   7\n \n-/* Auxiliary (address) registers */\n+/* Auxiliary (address) registers.  */\n \n #define AR0_REGNO  8\n #define AR1_REGNO  9\n@@ -386,118 +386,123 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n #define AR6_REGNO 14\n #define AR7_REGNO 15\n \n-/* Data page register */\n+/* Data page register.  */\n \n #define DP_REGNO  16\n \n-/* Index registers */\n+/* Index registers.  */\n \n #define IR0_REGNO 17\n #define IR1_REGNO 18\n \n-/* Block size register */\n+/* Block size register.  */\n \n #define BK_REGNO  19\n \n-/* Stack pointer */\n+/* Stack pointer.  */\n \n #define SP_REGNO  20\n \n-/* Status register */\n+/* Status register.  */\n \n #define ST_REGNO  21\n \n-/* Misc. interrupt registers */\n+/* Misc. interrupt registers.  */\n \n-#define DIE_REGNO 22\t\t/* C4x only */\n-#define IE_REGNO  22\t\t/* C3x only */\n-#define IIE_REGNO 23\t\t/* C4x only */\n-#define IF_REGNO  23\t\t/* C3x only */\n-#define IIF_REGNO 24\t\t/* C4x only */\n-#define IOF_REGNO 24\t\t/* C3x only */\n+#define DIE_REGNO 22\t\t/* C4x only.  */\n+#define IE_REGNO  22\t\t/* C3x only.  */\n+#define IIE_REGNO 23\t\t/* C4x only.  */\n+#define IF_REGNO  23\t\t/* C3x only.  */\n+#define IIF_REGNO 24\t\t/* C4x only.  */\n+#define IOF_REGNO 24\t\t/* C3x only.  */\n \n-/* Repeat block registers */\n+/* Repeat block registers.  */\n \n #define RS_REGNO  25\n #define RE_REGNO  26\n #define RC_REGNO  27\n \n-/* Additional extended-precision registers */\n+/* Additional extended-precision registers.  */\n \n-#define R8_REGNO  28\t\t/* C4x only */\n-#define R9_REGNO  29\t\t/* C4x only */\n-#define R10_REGNO 30\t\t/* C4x only */\n-#define R11_REGNO 31\t\t/* C4x only */\n+#define R8_REGNO  28\t\t/* C4x only.  */\n+#define R9_REGNO  29\t\t/* C4x only.  */\n+#define R10_REGNO 30\t\t/* C4x only.  */\n+#define R11_REGNO 31\t\t/* C4x only.  */\n \n #define FIRST_PSEUDO_REGISTER\t32\n \n-/* Extended precision registers (low set) */\n+/* Extended precision registers (low set).  */\n \n-#define IS_R0R1_REG(r)             ((((r) >= R0_REGNO) && ((r) <= R1_REGNO)))\n-#define IS_R2R3_REG(r)             ((((r) >= R2_REGNO) && ((r) <= R3_REGNO)))\n-#define IS_EXT_LOW_REG(r)          ((((r) >= R0_REGNO) && ((r) <= R7_REGNO)))\n+#define IS_R0R1_REGNO(r)           ((((r) >= R0_REGNO) && ((r) <= R1_REGNO)))\n+#define IS_R2R3_REGNO(r)           ((((r) >= R2_REGNO) && ((r) <= R3_REGNO)))\n+#define IS_EXT_LOW_REGNO(r)        ((((r) >= R0_REGNO) && ((r) <= R7_REGNO)))\n \n-/* Extended precision registers (high set) */\n+/* Extended precision registers (high set).  */\n \n-#define IS_EXT_HIGH_REG(r)         (! TARGET_C3X \\\n+#define IS_EXT_HIGH_REGNO(r)       (! TARGET_C3X \\\n \t\t\t            && ((r) >= R8_REGNO) && ((r) <= R11_REGNO))\n-/* Address registers */\n-\n-#define IS_AUX_REG(r)    (((r) >= AR0_REGNO) && ((r) <= AR7_REGNO))\n-#define IS_ADDR_REG(r)   IS_AUX_REG(r)\n-#define IS_DP_REG(r)     ((r) == DP_REGNO)\n-#define IS_INDEX_REG(r)  (((r) == IR0_REGNO) || ((r) == IR1_REGNO))\n-#define IS_SP_REG(r)     ((r) == SP_REGNO)\n-#define IS_BK_REG(r)     (TARGET_BK && (r) == BK_REGNO)\n-\n-/* Misc registers */\n-\n-#define IS_ST_REG(r)     ((r) == ST_REGNO)\n-#define IS_RC_REG(r)     ((r) == RC_REGNO)\n-#define IS_REPEAT_REG(r) (((r) >= RS_REGNO) && ((r) <= RC_REGNO))\n-\n-/* Composite register sets */\n-\n-#define IS_ADDR_OR_INDEX_REG(r) (IS_ADDR_REG(r) || IS_INDEX_REG(r))\n-#define IS_EXT_REG(r)           (IS_EXT_LOW_REG(r) || IS_EXT_HIGH_REG(r))\n-#define IS_STD_REG(r)           (IS_ADDR_OR_INDEX_REG(r) || IS_REPEAT_REG(r) \\\n-                                 || IS_SP_REG(r) || IS_BK_REG(r))\n-#define IS_INT_REG(r)           (IS_EXT_REG(r) || IS_STD_REG(r))\n-#define IS_GROUP1_REG(r)        (IS_ADDR_OR_INDEX_REG(r) || IS_BK_REG(r))\n-\n-\n-#define IS_PSEUDO_REG(r)            ((r) >= FIRST_PSEUDO_REGISTER)\n-#define IS_R0R1_OR_PSEUDO_REG(r)    (IS_R0R1_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_R2R3_OR_PSEUDO_REG(r)    (IS_R2R3_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_EXT_OR_PSEUDO_REG(r)     (IS_EXT_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_STD_OR_PSEUDO_REG(r)     (IS_STD_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_INT_OR_PSEUDO_REG(r)     (IS_INT_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_ADDR_OR_PSEUDO_REG(r)    (IS_ADDR_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_INDEX_OR_PSEUDO_REG(r)   (IS_INDEX_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_EXT_LOW_OR_PSEUDO_REG(r) (IS_EXT_LOW_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_DP_OR_PSEUDO_REG(r)      (IS_DP_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_SP_OR_PSEUDO_REG(r)      (IS_SP_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_ST_OR_PSEUDO_REG(r)      (IS_ST_REG(r) || IS_PSEUDO_REG(r))\n-#define IS_RC_OR_PSEUDO_REG(r)      (IS_RC_REG(r) || IS_PSEUDO_REG(r))\n-\n-#define IS_PSEUDO_REGNO(op)          (IS_PSEUDO_REG(REGNO(op)))\n-#define IS_ADDR_REGNO(op)            (IS_ADDR_REG(REGNO(op)))\n-#define IS_INDEX_REGNO(op)           (IS_INDEX_REG(REGNO(op)))\n-#define IS_GROUP1_REGNO(r)           (IS_GROUP1_REG(REGNO(op)))\n-\n-#define IS_R0R1_OR_PSEUDO_REGNO(op)  (IS_R0R1_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_R2R3_OR_PSEUDO_REGNO(op)  (IS_R2R3_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_EXT_OR_PSEUDO_REGNO(op)   (IS_EXT_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_STD_OR_PSEUDO_REGNO(op)   (IS_STD_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_EXT_LOW_OR_PSEUDO_REGNO(op) (IS_EXT_LOW_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_INT_OR_PSEUDO_REGNO(op)   (IS_INT_OR_PSEUDO_REG(REGNO(op)))\n-\n-#define IS_ADDR_OR_PSEUDO_REGNO(op)  (IS_ADDR_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_INDEX_OR_PSEUDO_REGNO(op) (IS_INDEX_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_DP_OR_PSEUDO_REGNO(op)    (IS_DP_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_SP_OR_PSEUDO_REGNO(op)    (IS_SP_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_ST_OR_PSEUDO_REGNO(op)    (IS_ST_OR_PSEUDO_REG(REGNO(op)))\n-#define IS_RC_OR_PSEUDO_REGNO(op)    (IS_RC_OR_PSEUDO_REG(REGNO(op)))\n+/* Address registers.  */\n+\n+#define IS_AUX_REGNO(r)    (((r) >= AR0_REGNO) && ((r) <= AR7_REGNO))\n+#define IS_ADDR_REGNO(r)   IS_AUX_REGNO(r)\n+#define IS_DP_REGNO(r)     ((r) == DP_REGNO)\n+#define IS_INDEX_REGNO(r)  (((r) == IR0_REGNO) || ((r) == IR1_REGNO))\n+#define IS_SP_REGNO(r)     ((r) == SP_REGNO)\n+#define IS_BK_REGNO(r)     (TARGET_BK && (r) == BK_REGNO)\n+\n+/* Misc registers.  */\n+\n+#define IS_ST_REGNO(r)     ((r) == ST_REGNO)\n+#define IS_RC_REGNO(r)     ((r) == RC_REGNO)\n+#define IS_REPEAT_REGNO(r) (((r) >= RS_REGNO) && ((r) <= RC_REGNO))\n+\n+/* Composite register sets.  */\n+\n+#define IS_ADDR_OR_INDEX_REGNO(r) (IS_ADDR_REGNO(r) || IS_INDEX_REGNO(r))\n+#define IS_EXT_REGNO(r)           (IS_EXT_LOW_REGNO(r) || IS_EXT_HIGH_REGNO(r))\n+#define IS_STD_REGNO(r)           (IS_ADDR_OR_INDEX_REGNO(r) \\\n+\t\t\t\t   || IS_REPEAT_REGNO(r) \\\n+                                   || IS_SP_REGNO(r) \\\n+\t\t       \t\t   || IS_BK_REGNO(r))\n+#define IS_INT_REGNO(r)           (IS_EXT_REGNO(r) || IS_STD_REGNO(r))\n+#define IS_GROUP1_REGNO(r)        (IS_ADDR_OR_INDEX_REGNO(r) || IS_BK_REGNO(r))\n+\n+#define IS_PSEUDO_REGNO(r)            ((r) >= FIRST_PSEUDO_REGISTER)\n+#define IS_R0R1_OR_PSEUDO_REGNO(r)    (IS_R0R1_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_R2R3_OR_PSEUDO_REGNO(r)    (IS_R2R3_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_EXT_OR_PSEUDO_REGNO(r)     (IS_EXT_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_STD_OR_PSEUDO_REGNO(r)     (IS_STD_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_INT_OR_PSEUDO_REGNO(r)     (IS_INT_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_ADDR_OR_PSEUDO_REGNO(r)    (IS_ADDR_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_INDEX_OR_PSEUDO_REGNO(r)   (IS_INDEX_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_EXT_LOW_OR_PSEUDO_REGNO(r) (IS_EXT_LOW_REGNO(r) \\\n+\t\t\t\t       || IS_PSEUDO_REGNO(r))\n+#define IS_DP_OR_PSEUDO_REGNO(r)      (IS_DP_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_SP_OR_PSEUDO_REGNO(r)      (IS_SP_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_ST_OR_PSEUDO_REGNO(r)      (IS_ST_REGNO(r) || IS_PSEUDO_REGNO(r))\n+#define IS_RC_OR_PSEUDO_REGNO(r)      (IS_RC_REGNO(r) || IS_PSEUDO_REGNO(r))\n+\n+#define IS_PSEUDO_REG(op)          (IS_PSEUDO_REGNO(REGNO(op)))\n+#define IS_ADDR_REG(op)            (IS_ADDR_REGNO(REGNO(op)))\n+#define IS_INDEX_REG(op)           (IS_INDEX_REGNO(REGNO(op)))\n+#define IS_GROUP1_REG(r)           (IS_GROUP1_REGNO(REGNO(op)))\n+#define IS_SP_REG(op)              (IS_SP_REGNO(REGNO(op)))\n+#define IS_STD_REG(op)             (IS_STD_REGNO(REGNO(op)))\n+#define IS_EXT_REG(op)             (IS_EXT_REGNO(REGNO(op)))\n+\n+#define IS_R0R1_OR_PSEUDO_REG(op)  (IS_R0R1_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_R2R3_OR_PSEUDO_REG(op)  (IS_R2R3_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_EXT_OR_PSEUDO_REG(op)   (IS_EXT_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_STD_OR_PSEUDO_REG(op)   (IS_STD_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_EXT_LOW_OR_PSEUDO_REG(op) (IS_EXT_LOW_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_INT_OR_PSEUDO_REG(op)   (IS_INT_OR_PSEUDO_REGNO(REGNO(op)))\n+\n+#define IS_ADDR_OR_PSEUDO_REG(op)  (IS_ADDR_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_INDEX_OR_PSEUDO_REG(op) (IS_INDEX_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_DP_OR_PSEUDO_REG(op)    (IS_DP_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_SP_OR_PSEUDO_REG(op)    (IS_SP_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_ST_OR_PSEUDO_REG(op)    (IS_ST_OR_PSEUDO_REGNO(REGNO(op)))\n+#define IS_RC_OR_PSEUDO_REG(op)    (IS_RC_OR_PSEUDO_REGNO(REGNO(op)))\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n@@ -801,10 +806,10 @@ enum reg_class\n    has been allocated, which happens in local-alloc.c.  */\n \n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n-     (IS_ADDR_REG(REGNO) || IS_ADDR_REG((unsigned)reg_renumber[REGNO]))\n+     (IS_ADDR_REGNO(REGNO) || IS_ADDR_REGNO((unsigned)reg_renumber[REGNO]))\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-     (IS_INDEX_REG(REGNO) || IS_INDEX_REG((unsigned)reg_renumber[REGNO]))\n+     (IS_INDEX_REGNO(REGNO) || IS_INDEX_REGNO((unsigned)reg_renumber[REGNO]))\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n \n@@ -1575,11 +1580,11 @@ CUMULATIVE_ARGS;\n \n /* Nonzero if X is a hard or pseudo reg that can be used as an base.  */\n \n-#define REG_OK_FOR_BASE_P(X) IS_ADDR_OR_PSEUDO_REG(REGNO(X))\n+#define REG_OK_FOR_BASE_P(X) IS_ADDR_OR_PSEUDO_REG(X)\n \n /* Nonzero if X is a hard or pseudo reg that can be used as an index.  */\n \n-#define REG_OK_FOR_INDEX_P(X) IS_INDEX_OR_PSEUDO_REG(REGNO(X))\n+#define REG_OK_FOR_INDEX_P(X) IS_INDEX_OR_PSEUDO_REG(X)\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "8a3189eafdec7845ecdaef8fb7a938639447fc96", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc46716b04612a15b060ecdbd0cbd07a2115ffe7/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=bc46716b04612a15b060ecdbd0cbd07a2115ffe7", "patch": "@@ -1344,9 +1344,9 @@\n    /* The lda instruction cannot use the same register as source\n       and destination.  */\n    if (! TARGET_C3X && which_alternative == 1\n-       && (   IS_ADDR_REG (REGNO (operands[0]))\n-           || IS_INDEX_REG (REGNO (operands[0]))\n-           || IS_SP_REG (REGNO (operands[0])))\n+       && (   IS_ADDR_REG (operands[0])\n+           || IS_INDEX_REG (operands[0])\n+           || IS_SP_REG (operands[0]))\n        && (REGNO (operands[0]) != REGNO (operands[1])))\n       return \\\"lda\\\\t%1,%0\\\";\n    return \\\"ldiu\\\\t%1,%0\\\";\n@@ -1762,8 +1762,8 @@\n   \"\"\n   \"legitimize_operands (PLUS, operands, QImode);\n    if (reload_in_progress\n-       || (! IS_PSEUDO_REGNO (operands[0]) \n-           && ! IS_EXT_REG (REGNO (operands[0]))))\n+       || (! IS_PSEUDO_REG (operands[0]) \n+           && ! IS_EXT_REG (operands[0])))\n    {\n       emit_insn (gen_addqi3_noclobber (operands[0], operands[1], operands[2]));\n       DONE;\n@@ -1890,7 +1890,7 @@\n                  (match_operand:QI 2 \"src_operand\" \"rIm,JR,rS<>,rIm,JR,rS<>\")))]\n   \"reload_in_progress\"\n   \"*\n-   if (IS_STD_REG (REGNO (operands[0])))\n+   if (IS_STD_REG (operands[0]))\n      {\n        if (which_alternative == 0)\n \t return \\\"addi\\\\t%2,%0\\\";"}]}