{"sha": "d5fabb58358641e0d597a966b34e20339c231180", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmYWJiNTgzNTg2NDFlMGQ1OTdhOTY2YjM0ZTIwMzM5YzIzMTE4MA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-11-25T13:16:03Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-11-25T13:16:03Z"}, "message": "target.def (supports_split_stack, [...]): Take gcc_options parameters.\n\n\t* target.def (supports_split_stack, except_unwind_info): Take\n\tgcc_options parameters.\n\t* targhooks.c (default_except_unwind_info,\n\tdwarf2_except_unwind_info, sjlj_except_unwind_info): Take\n\tgcc_options parameters.\n\t* targhooks.h (default_except_unwind_info,\n\tdwarf2_except_unwind_info, sjlj_except_unwind_info): Update\n\tprototypes.\n\t* doc/tm.texi.in (TARGET_IRA_COVER_CLASSES,\n\tTARGET_HAVE_NAMED_SECTIONS, TARGET_UNWIND_TABLES_DEFAULT):\n\tDocument that hooks must not be modified.\n\t(TARGET_EXCEPT_UNWIND_INFO): Refer to opts argument.\n\t* doc/tm.texi: Regenerate.\n\t* defaults.h (STACK_OLD_CHECK_PROTECT, STACK_CHECK_PROTECT): Pass\n\t&global_options to targetm.except_unwind_info.\n\t* dwarf2out.c (dwarf2out_do_frame, dwarf2out_do_cfi_asm,\n\tdwarf2out_begin_prologue, dwarf2out_frame_init,\n\tdwarf2out_frame_finish, dwarf2out_assembly_start): Pass\n\t&global_options to targetm.except_unwind_info.\n\t* except.c (init_eh, finish_eh_generation,\n\tgate_convert_to_eh_region_ranges,\n\toutput_one_function_exception_table): Pass &global_options to\n\ttargetm.except_unwind_info.\n\t* expr.c (build_personality_function): Pass &global_options to\n\ttargetm.except_unwind_info.\n\t* function.c (expand_function_end): Pass &global_options to\n\ttargetm.except_unwind_info.\n\t* hooks.c (hook_bool_bool_gcc_optionsp_false): New.\n\t* hooks.h (hook_bool_bool_gcc_optionsp_false): Declare.\n\t* opts.c (finish_options): Pass opts to targetm.except_unwind_info\n\tand targetm.supports_split_stack.  Remove assertions about opts\n\tand opts_set.\n\t(common_handle_option): Remove assertions about opts, opts_set and\n\tdc.\n\t* tree-tailcall.c (suitable_for_tail_call_opt_p): Pass\n\t&global_options to targetm.except_unwind_info.\n\t* tree.c (build_common_builtin_nodes: Pass &global_options to\n\ttargetm.except_unwind_info.\n\t* config/arm/arm.c (arm_except_unwind_info): Add gcc_options\n\tparameter.\n\t(arm_compute_func_type, arm_expand_prologue, thumb_pushpop,\n\tthumb1_expand_prologue, thumb1_output_function_prologue,\n\tarm_unwind_emit, arm_output_fn_unwind): Update calls to\n\tarm_except_unwind_info.\n\t* config/i386/i386.c (ix86_supports_split_stack): Add gcc_options\n\tparameter.\n\t* config/ia64/ia64.c (ia64_except_unwind_info): Add gcc_options\n\tparameter.\n\t(ia64_output_function_prologue, ia64_add_bundle_selector_before,\n\tia64_reorg, ia64_asm_unwind_emit): Update calls to\n\tia64_except_unwind_info.\n\t* config/pa/pa.c (pa_option_override): Pass &global_options to\n\ttargetm.except_unwind_info.\n\t* config/picochip/picochip-protos.h (picochip_except_unwind_info):\n\tRemove prototype.\n\nc-family:\n\t* c-cppbuiltin.c (c_cpp_builtins): Pass &global_options to\n\ttargetm.except_unwind_info.\n\nFrom-SVN: r167145", "tree": {"sha": "2ae1898b130194eab38d660e71fb70c7ded18d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ae1898b130194eab38d660e71fb70c7ded18d9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5fabb58358641e0d597a966b34e20339c231180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fabb58358641e0d597a966b34e20339c231180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fabb58358641e0d597a966b34e20339c231180", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fabb58358641e0d597a966b34e20339c231180/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d602c5900c50a7cda00695c00e1945badc184cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d602c5900c50a7cda00695c00e1945badc184cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d602c5900c50a7cda00695c00e1945badc184cf"}], "stats": {"total": 238, "additions": 162, "deletions": 76}, "files": [{"sha": "8c5473b4f88a3a8d3167a97799867d65fe45b029", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -1,3 +1,61 @@\n+2010-11-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* target.def (supports_split_stack, except_unwind_info): Take\n+\tgcc_options parameters.\n+\t* targhooks.c (default_except_unwind_info,\n+\tdwarf2_except_unwind_info, sjlj_except_unwind_info): Take\n+\tgcc_options parameters.\n+\t* targhooks.h (default_except_unwind_info,\n+\tdwarf2_except_unwind_info, sjlj_except_unwind_info): Update\n+\tprototypes.\n+\t* doc/tm.texi.in (TARGET_IRA_COVER_CLASSES,\n+\tTARGET_HAVE_NAMED_SECTIONS, TARGET_UNWIND_TABLES_DEFAULT):\n+\tDocument that hooks must not be modified.\n+\t(TARGET_EXCEPT_UNWIND_INFO): Refer to opts argument.\n+\t* doc/tm.texi: Regenerate.\n+\t* defaults.h (STACK_OLD_CHECK_PROTECT, STACK_CHECK_PROTECT): Pass\n+\t&global_options to targetm.except_unwind_info.\n+\t* dwarf2out.c (dwarf2out_do_frame, dwarf2out_do_cfi_asm,\n+\tdwarf2out_begin_prologue, dwarf2out_frame_init,\n+\tdwarf2out_frame_finish, dwarf2out_assembly_start): Pass\n+\t&global_options to targetm.except_unwind_info.\n+\t* except.c (init_eh, finish_eh_generation,\n+\tgate_convert_to_eh_region_ranges,\n+\toutput_one_function_exception_table): Pass &global_options to\n+\ttargetm.except_unwind_info.\n+\t* expr.c (build_personality_function): Pass &global_options to\n+\ttargetm.except_unwind_info.\n+\t* function.c (expand_function_end): Pass &global_options to\n+\ttargetm.except_unwind_info.\n+\t* hooks.c (hook_bool_bool_gcc_optionsp_false): New.\n+\t* hooks.h (hook_bool_bool_gcc_optionsp_false): Declare.\n+\t* opts.c (finish_options): Pass opts to targetm.except_unwind_info\n+\tand targetm.supports_split_stack.  Remove assertions about opts\n+\tand opts_set.\n+\t(common_handle_option): Remove assertions about opts, opts_set and\n+\tdc.\n+\t* tree-tailcall.c (suitable_for_tail_call_opt_p): Pass\n+\t&global_options to targetm.except_unwind_info.\n+\t* tree.c (build_common_builtin_nodes: Pass &global_options to\n+\ttargetm.except_unwind_info.\n+\t* config/arm/arm.c (arm_except_unwind_info): Add gcc_options\n+\tparameter.\n+\t(arm_compute_func_type, arm_expand_prologue, thumb_pushpop,\n+\tthumb1_expand_prologue, thumb1_output_function_prologue,\n+\tarm_unwind_emit, arm_output_fn_unwind): Update calls to\n+\tarm_except_unwind_info.\n+\t* config/i386/i386.c (ix86_supports_split_stack): Add gcc_options\n+\tparameter.\n+\t* config/ia64/ia64.c (ia64_except_unwind_info): Add gcc_options\n+\tparameter.\n+\t(ia64_output_function_prologue, ia64_add_bundle_selector_before,\n+\tia64_reorg, ia64_asm_unwind_emit): Update calls to\n+\tia64_except_unwind_info.\n+\t* config/pa/pa.c (pa_option_override): Pass &global_options to\n+\ttargetm.except_unwind_info.\n+\t* config/picochip/picochip-protos.h (picochip_except_unwind_info):\n+\tRemove prototype.\n+\n 2010-11-25  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* cgraphunit.c (process_function_and_variable_attributes):"}, {"sha": "41ae904d66cd438ba8862ed89b420f630006684c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -1,3 +1,8 @@\n+2010-11-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Pass &global_options to\n+\ttargetm.except_unwind_info.\n+\n 2010-11-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-opts.c (c_common_handle_option): Pass location to"}, {"sha": "50dced35b567236d306acad408b9de8d69f09670", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -627,7 +627,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t\t\t\t   1000 + flag_abi_version);\n \n   /* libgcc needs to know this.  */\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     cpp_define (pfile, \"__USING_SJLJ_EXCEPTIONS__\");\n \n   /* limits.h and stdint.h need to know these.  */"}, {"sha": "ef42e45c57f4149db5ace0054072b39289cd0474", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -201,7 +201,7 @@ static bool arm_output_ttype (rtx);\n static void arm_asm_emit_except_personality (rtx);\n static void arm_asm_init_sections (void);\n #endif\n-static enum unwind_info_type arm_except_unwind_info (void);\n+static enum unwind_info_type arm_except_unwind_info (struct gcc_options *);\n static void arm_dwarf_handle_frame_unspec (const char *, rtx, int);\n static rtx arm_dwarf_register_span (rtx);\n \n@@ -2071,7 +2071,8 @@ arm_compute_func_type (void)\n   if (optimize > 0\n       && (TREE_NOTHROW (current_function_decl)\n           || !(flag_unwind_tables\n-               || (flag_exceptions && arm_except_unwind_info () != UI_SJLJ)))\n+               || (flag_exceptions\n+\t\t   && arm_except_unwind_info (&global_options) != UI_SJLJ)))\n       && TREE_THIS_VOLATILE (current_function_decl))\n     type |= ARM_FT_VOLATILE;\n \n@@ -15773,7 +15774,7 @@ arm_expand_prologue (void)\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n   if (crtl->profile || !TARGET_SCHED_PROLOG\n-      || (arm_except_unwind_info () == UI_TARGET\n+      || (arm_except_unwind_info (&global_options) == UI_TARGET\n \t  && cfun->can_throw_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n@@ -19656,7 +19657,7 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n       return;\n     }\n \n-  if (push && arm_except_unwind_info () == UI_TARGET)\n+  if (push && arm_except_unwind_info (&global_options) == UI_TARGET)\n     {\n       fprintf (f, \"\\t.save\\t{\");\n       for (regno = 0; regno < 15; regno++)\n@@ -20596,7 +20597,7 @@ thumb1_expand_prologue (void)\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n   if (crtl->profile || !TARGET_SCHED_PROLOG\n-      || (arm_except_unwind_info () == UI_TARGET\n+      || (arm_except_unwind_info (&global_options) == UI_TARGET\n \t  && cfun->can_throw_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n@@ -20710,7 +20711,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n   if (crtl->args.pretend_args_size)\n     {\n       /* Output unwind directive for the stack adjustment.  */\n-      if (arm_except_unwind_info () == UI_TARGET)\n+      if (arm_except_unwind_info (&global_options) == UI_TARGET)\n \tfprintf (f, \"\\t.pad #%d\\n\",\n \t\t crtl->args.pretend_args_size);\n \n@@ -20780,7 +20781,7 @@ thumb1_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       work_register = thumb_find_work_register (live_regs_mask);\n \n-      if (arm_except_unwind_info () == UI_TARGET)\n+      if (arm_except_unwind_info (&global_options) == UI_TARGET)\n \tasm_fprintf (f, \"\\t.pad #16\\n\");\n \n       asm_fprintf\n@@ -22388,7 +22389,7 @@ arm_unwind_emit (FILE * asm_out_file, rtx insn)\n {\n   rtx pat;\n \n-  if (arm_except_unwind_info () != UI_TARGET)\n+  if (arm_except_unwind_info (&global_options) != UI_TARGET)\n     return;\n \n   if (!(flag_unwind_tables || crtl->uses_eh_lsda)\n@@ -22462,7 +22463,7 @@ arm_asm_init_sections (void)\n /* Implement TARGET_EXCEPT_UNWIND_INFO.  */\n \n static enum unwind_info_type\n-arm_except_unwind_info (void)\n+arm_except_unwind_info (struct gcc_options *opts)\n {\n   /* Honor the --enable-sjlj-exceptions configure switch.  */\n #ifdef CONFIG_SJLJ_EXCEPTIONS\n@@ -22475,7 +22476,7 @@ arm_except_unwind_info (void)\n     {\n       /* For simplicity elsewhere in this file, indicate that all unwind\n \t info is disabled if we're not emitting unwind tables.  */\n-      if (!flag_exceptions && !flag_unwind_tables)\n+      if (!opts->x_flag_exceptions && !opts->x_flag_unwind_tables)\n \treturn UI_NONE;\n       else\n \treturn UI_TARGET;\n@@ -22515,7 +22516,7 @@ arm_dwarf_handle_frame_unspec (const char *label, rtx pattern, int index)\n void\n arm_output_fn_unwind (FILE * f, bool prologue)\n {\n-  if (arm_except_unwind_info () != UI_TARGET)\n+  if (arm_except_unwind_info (&global_options) != UI_TARGET)\n     return;\n \n   if (prologue)"}, {"sha": "a66a0c4778b77712ff6784ab1879f2dfdb2266d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -9037,7 +9037,8 @@ ix86_builtin_setjmp_frame_value (void)\n    field in the TCB, so they can not be used together.  */\n \n static bool\n-ix86_supports_split_stack (bool report ATTRIBUTE_UNUSED)\n+ix86_supports_split_stack (bool report ATTRIBUTE_UNUSED,\n+\t\t\t   struct gcc_options *opts ATTRIBUTE_UNUSED)\n {\n   bool ret = true;\n "}, {"sha": "878cd72a6526c6756962486ffcc6f02f7a5f77df", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -262,7 +262,7 @@ static void ia64_asm_emit_except_personality (rtx);\n static void ia64_asm_init_sections (void);\n \n static enum unwind_info_type ia64_debug_unwind_info (void);\n-static enum unwind_info_type ia64_except_unwind_info (void);\n+static enum unwind_info_type ia64_except_unwind_info (struct gcc_options *);\n \n static struct bundle_state *get_free_bundle_state (void);\n static void free_bundle_state (struct bundle_state *);\n@@ -4020,7 +4020,7 @@ ia64_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t     current_frame_info.n_output_regs,\n \t     current_frame_info.n_rotate_regs);\n \n-  if (ia64_except_unwind_info () != UI_TARGET)\n+  if (ia64_except_unwind_info (&global_options) != UI_TARGET)\n     return;\n \n   /* Emit the .prologue directive.  */\n@@ -4078,7 +4078,7 @@ ia64_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n static void\n ia64_output_function_end_prologue (FILE *file)\n {\n-  if (ia64_except_unwind_info () != UI_TARGET)\n+  if (ia64_except_unwind_info (&global_options) != UI_TARGET)\n     return;\n \n   fputs (\"\\t.body\\n\", file);\n@@ -8700,7 +8700,7 @@ ia64_add_bundle_selector_before (int template0, rtx insn)\n   ia64_emit_insn_before (b, insn);\n #if NR_BUNDLES == 10\n   if ((template0 == 4 || template0 == 5)\n-      && ia64_except_unwind_info () == UI_TARGET)\n+      && ia64_except_unwind_info (&global_options) == UI_TARGET)\n     {\n       int i;\n       rtx note = NULL_RTX;\n@@ -9541,7 +9541,7 @@ ia64_reorg (void)\n   /* A call must not be the last instruction in a function, so that the\n      return address is still within the function, so that unwinding works\n      properly.  Note that IA-64 differs from dwarf2 on this point.  */\n-  if (ia64_except_unwind_info () == UI_TARGET)\n+  if (ia64_except_unwind_info (&global_options) == UI_TARGET)\n     {\n       rtx insn;\n       int saw_stop = 0;\n@@ -10007,7 +10007,7 @@ process_cfa_offset (FILE *asm_out_file, rtx pat, bool unwind)\n static void\n ia64_asm_unwind_emit (FILE *asm_out_file, rtx insn)\n {\n-  bool unwind = ia64_except_unwind_info () == UI_TARGET;\n+  bool unwind = ia64_except_unwind_info (&global_options) == UI_TARGET;\n   bool frame = dwarf2out_do_frame ();\n   rtx note, pat;\n   bool handled_one;\n@@ -10144,7 +10144,7 @@ ia64_debug_unwind_info (void)\n /* Implement TARGET_EXCEPT_UNWIND_INFO.  */\n \n static enum unwind_info_type\n-ia64_except_unwind_info (void)\n+ia64_except_unwind_info (struct gcc_options *opts)\n {\n   /* Honor the --enable-sjlj-exceptions configure switch.  */\n #ifdef CONFIG_UNWIND_EXCEPTIONS\n@@ -10154,7 +10154,7 @@ ia64_except_unwind_info (void)\n \n   /* For simplicity elsewhere in this file, indicate that all unwind\n      info is disabled if we're not emitting unwind tables.  */\n-  if (!flag_exceptions && !flag_unwind_tables)\n+  if (!opts->x_flag_exceptions && !opts->x_flag_unwind_tables)\n     return UI_NONE;\n \n   return UI_TARGET;"}, {"sha": "81d85b9ae64d28f9baa13a77ef65ad289226c2e5", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -543,7 +543,8 @@ pa_option_override (void)\n      call frame information.  There is no benefit in using this optimization\n      on PA8000 and later processors.  */\n   if (pa_cpu >= PROCESSOR_8000\n-      || (targetm.except_unwind_info () == UI_DWARF2 && flag_exceptions)\n+      || (targetm.except_unwind_info (&global_options) == UI_DWARF2\n+\t  && flag_exceptions)\n       || flag_unwind_tables)\n     target_flags &= ~MASK_JUMP_IN_DELAY;\n "}, {"sha": "965098eec4520100dbd10c293f95d63b1707769a", "filename": "gcc/config/picochip/picochip-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -120,8 +120,6 @@ extern int picochip_flag_schedule_insns2;\n \n extern void picochip_asm_output_anchor (rtx symbol);\n \n-extern enum unwind_info_type picochip_except_unwind_info (void);\n-\n /* Instruction set capability flags.  These are initialised to the\n    appropriate values by picochip_option_override, once the user has\n    selected a CPU type. */"}, {"sha": "77e7685f3b0232592783c4f33bec00dadaf7e5d0", "filename": "gcc/defaults.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -1292,16 +1292,20 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifdef STACK_CHECK_PROTECT\n #define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT\n #else\n-#define STACK_OLD_CHECK_PROTECT \\\n- (targetm.except_unwind_info () == UI_SJLJ ? 75 * UNITS_PER_WORD : 8 * 1024)\n+#define STACK_OLD_CHECK_PROTECT\t\t\t\t\t\\\n+ (targetm.except_unwind_info (&global_options) == UI_SJLJ\t\\\n+  ? 75 * UNITS_PER_WORD\t\t\t\t\t\t\\\n+  : 8 * 1024)\n #endif\n \n /* Minimum amount of stack required to recover from an anticipated stack\n    overflow detection.  The default value conveys an estimate of the amount\n    of stack required to propagate an exception.  */\n #ifndef STACK_CHECK_PROTECT\n-#define STACK_CHECK_PROTECT \\\n- (targetm.except_unwind_info () == UI_SJLJ ? 75 * UNITS_PER_WORD : 12 * 1024)\n+#define STACK_CHECK_PROTECT\t\t\t\t\t\\\n+ (targetm.except_unwind_info (&global_options) == UI_SJLJ\t\\\n+  ? 75 * UNITS_PER_WORD\t\t\t\t\t\t\\\n+  : 12 * 1024)\n #endif\n \n /* Make the maximum frame size be the largest we can and still only need"}, {"sha": "6bc5f1f17f2ec918037cb7cd69c16d116fc1e3b6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -2872,6 +2872,9 @@ otherwise there is no default implementation.  You must define either this\n macro or @code{IRA_COVER_CLASSES} in order to use the integrated register\n allocator with Chaitin-Briggs coloring. If the macro is not defined,\n the only available coloring algorithm is Chow's priority coloring.\n+\n+This hook must not be modified from @code{NULL} to non-@code{NULL} or\n+vice versa by command-line option processing.\n @end deftypefn\n \n @defmac IRA_COVER_CLASSES\n@@ -4936,8 +4939,8 @@ The default version of this hook invokes a function called\n normally defined in @file{libgcc2.c}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_SUPPORTS_SPLIT_STACK (bool)\n-Whether this target supports splitting the stack.  This is called after options have been parsed, so the target may reject splitting the stack in some configurations.  The default version of this hook returns false.  If @var{report} is true, this function may issue a warning or error; if @var{report} is false, it must simply return a value\n+@deftypefn {Target Hook} bool TARGET_SUPPORTS_SPLIT_STACK (bool @var{report}, struct gcc_options *@var{opts})\n+Whether this target supports splitting the stack when the options described in @var{opts} have been passed.  This is called after options have been parsed, so the target may reject splitting the stack in some configurations.  The default version of this hook returns false.  If @var{report} is true, this function may issue a warning or error; if @var{report} is false, it must simply return a value\n @end deftypefn\n \n @node Varargs\n@@ -7340,6 +7343,7 @@ Return NULL if function should go to default text section.\n \n @deftypevr {Target Hook} bool TARGET_HAVE_NAMED_SECTIONS\n This flag is true if the target supports @code{TARGET_ASM_NAMED_SECTION}.\n+It must not be modified by command-line option processing.\n @end deftypevr\n \n @anchor{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}\n@@ -8860,7 +8864,7 @@ Otherwise, if your target supports this information (if it defines\n or @code{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.\n @end defmac\n \n-@deftypefn {Target Hook} {enum unwind_info_type} TARGET_EXCEPT_UNWIND_INFO (void)\n+@deftypefn {Target Hook} {enum unwind_info_type} TARGET_EXCEPT_UNWIND_INFO (struct gcc_options *@var{opts})\n This hook defines the mechanism that will be used for exception handling\n by the target.  If the target has ABI specified unwind tables, the hook\n should return @code{UI_TARGET}.  If the target is to use the\n@@ -8873,19 +8877,23 @@ This may end up simplifying other parts of target-specific code.  The\n default implementation of this hook never returns @code{UI_NONE}.\n \n Note that the value returned by this hook should be constant.  It should\n-not depend on anything except command-line switches.  In particular, the\n+not depend on anything except the command-line switches described by\n+@var{opts}.  In particular, the\n setting @code{UI_SJLJ} must be fixed at compiler start-up as C pre-processor\n macros and builtin functions related to exception handling are set up\n depending on this setting.\n \n The default implementation of the hook first honors the\n @option{--enable-sjlj-exceptions} configure option, then\n-@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.\n+@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.  If\n+@code{DWARF2_UNWIND_INFO} depends on command-line options, the target\n+must define this hook so that @var{opts} is used correctly.\n @end deftypefn\n \n @deftypevr {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT\n This variable should be set to @code{true} if the target ABI requires unwinding\n-tables even when exceptions are not used.\n+tables even when exceptions are not used.  It must not be modified by\n+command-line option processing.\n @end deftypevr\n \n @defmac DONT_USE_BUILTIN_SETJMP"}, {"sha": "47d5be2980a34c8ae7e8d4c80e2cb3204a4224ce", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -2862,6 +2862,9 @@ otherwise there is no default implementation.  You must define either this\n macro or @code{IRA_COVER_CLASSES} in order to use the integrated register\n allocator with Chaitin-Briggs coloring. If the macro is not defined,\n the only available coloring algorithm is Chow's priority coloring.\n+\n+This hook must not be modified from @code{NULL} to non-@code{NULL} or\n+vice versa by command-line option processing.\n @end deftypefn\n \n @defmac IRA_COVER_CLASSES\n@@ -7315,6 +7318,7 @@ Return NULL if function should go to default text section.\n \n @hook TARGET_HAVE_NAMED_SECTIONS\n This flag is true if the target supports @code{TARGET_ASM_NAMED_SECTION}.\n+It must not be modified by command-line option processing.\n @end deftypevr\n \n @anchor{TARGET_HAVE_SWITCHABLE_BSS_SECTIONS}\n@@ -8843,19 +8847,23 @@ This may end up simplifying other parts of target-specific code.  The\n default implementation of this hook never returns @code{UI_NONE}.\n \n Note that the value returned by this hook should be constant.  It should\n-not depend on anything except command-line switches.  In particular, the\n+not depend on anything except the command-line switches described by\n+@var{opts}.  In particular, the\n setting @code{UI_SJLJ} must be fixed at compiler start-up as C pre-processor\n macros and builtin functions related to exception handling are set up\n depending on this setting.\n \n The default implementation of the hook first honors the\n @option{--enable-sjlj-exceptions} configure option, then\n-@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.\n+@code{DWARF2_UNWIND_INFO}, and finally defaults to @code{UI_SJLJ}.  If\n+@code{DWARF2_UNWIND_INFO} depends on command-line options, the target\n+must define this hook so that @var{opts} is used correctly.\n @end deftypefn\n \n @hook TARGET_UNWIND_TABLES_DEFAULT\n This variable should be set to @code{true} if the target ABI requires unwinding\n-tables even when exceptions are not used.\n+tables even when exceptions are not used.  It must not be modified by\n+command-line option processing.\n @end deftypevr\n \n @defmac DONT_USE_BUILTIN_SETJMP"}, {"sha": "3195a9271c21527ddec71d4672d85220dd949aab", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -153,7 +153,7 @@ dwarf2out_do_frame (void)\n     return true;\n \n   if ((flag_unwind_tables || flag_exceptions)\n-      && targetm.except_unwind_info () == UI_DWARF2)\n+      && targetm.except_unwind_info (&global_options) == UI_DWARF2)\n     return true;\n \n   return false;\n@@ -189,7 +189,7 @@ dwarf2out_do_cfi_asm (void)\n      dwarf2 unwind info for exceptions, then emit .debug_frame by hand.  */\n   if (!HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n       && !flag_unwind_tables && !flag_exceptions\n-      && targetm.except_unwind_info () != UI_DWARF2)\n+      && targetm.except_unwind_info (&global_options) != UI_DWARF2)\n     return false;\n \n   saved_do_cfi_asm = true;\n@@ -4072,7 +4072,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n      call-site information.  We must emit this label if it might be used.  */\n   if (!do_frame\n       && (!flag_exceptions\n-\t  || targetm.except_unwind_info () != UI_TARGET))\n+\t  || targetm.except_unwind_info (&global_options) != UI_TARGET))\n     return;\n \n   fnsec = function_section (current_function_decl);\n@@ -4256,7 +4256,7 @@ dwarf2out_frame_init (void)\n   dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n \n   if (targetm.debug_unwind_info () == UI_DWARF2\n-      || targetm.except_unwind_info () == UI_DWARF2)\n+      || targetm.except_unwind_info (&global_options) == UI_DWARF2)\n     initial_return_save (INCOMING_RETURN_ADDR_RTX);\n }\n \n@@ -4269,7 +4269,7 @@ dwarf2out_frame_finish (void)\n \n   /* Output another copy for the unwinder.  */\n   if ((flag_unwind_tables || flag_exceptions)\n-      && targetm.except_unwind_info () == UI_DWARF2)\n+      && targetm.except_unwind_info (&global_options) == UI_DWARF2)\n     output_call_frame_info (1);\n }\n \n@@ -22014,7 +22014,7 @@ dwarf2out_assembly_start (void)\n   if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n       && dwarf2out_do_cfi_asm ()\n       && (!(flag_unwind_tables || flag_exceptions)\n-\t  || targetm.except_unwind_info () != UI_DWARF2))\n+\t  || targetm.except_unwind_info (&global_options) != UI_DWARF2))\n     fprintf (asm_out_file, \"\\t.cfi_sections\\t.debug_frame\\n\");\n }\n "}, {"sha": "2912caeaa0d3983361d30a68fbe26671d8155ef9", "filename": "gcc/except.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -209,7 +209,7 @@ init_eh (void)\n \n   /* Create the SjLj_Function_Context structure.  This should match\n      the definition in unwind-sjlj.c.  */\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     {\n       tree f_jbuf, f_per, f_lsda, f_prev, f_cs, f_data, tmp;\n \n@@ -1375,13 +1375,13 @@ finish_eh_generation (void)\n   basic_block bb;\n \n   /* Construct the landing pads.  */\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     sjlj_build_landing_pads ();\n   else\n     dw2_build_landing_pads ();\n   break_superblocks ();\n \n-  if (targetm.except_unwind_info () == UI_SJLJ\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ\n       /* Kludge for Alpha/Tru64 (see alpha_gp_save_rtx).  */\n       || single_succ_edge (ENTRY_BLOCK_PTR)->insns.r)\n     commit_edge_insertions ();\n@@ -2622,7 +2622,7 @@ gate_convert_to_eh_region_ranges (void)\n   /* Nothing to do for SJLJ exceptions or if no regions created.  */\n   if (cfun->eh->region_tree == NULL)\n     return false;\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     return false;\n   return true;\n }\n@@ -2961,7 +2961,7 @@ output_one_function_exception_table (int section)\n \t\t       eh_data_format_name (tt_format));\n \n #ifndef HAVE_AS_LEB128\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     call_site_len = sjlj_size_of_call_site_table ();\n   else\n     call_site_len = dw2_size_of_call_site_table (section);\n@@ -3028,14 +3028,14 @@ output_one_function_exception_table (int section)\n   dw2_asm_output_delta_uleb128 (cs_end_label, cs_after_size_label,\n \t\t\t\t\"Call-site table length\");\n   ASM_OUTPUT_LABEL (asm_out_file, cs_after_size_label);\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     sjlj_output_call_site_table ();\n   else\n     dw2_output_call_site_table (cs_format, section);\n   ASM_OUTPUT_LABEL (asm_out_file, cs_end_label);\n #else\n   dw2_asm_output_data_uleb128 (call_site_len, \"Call-site table length\");\n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     sjlj_output_call_site_table ();\n   else\n     dw2_output_call_site_table (cs_format, section);"}, {"sha": "56a6249cb50a72ce1d1702731fdfb4efd7264807", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -10290,7 +10290,7 @@ build_personality_function (const char *lang)\n   tree decl, type;\n   char *name;\n \n-  switch (targetm.except_unwind_info ())\n+  switch (targetm.except_unwind_info (&global_options))\n     {\n     case UI_NONE:\n       return NULL;"}, {"sha": "c69a5c55554ef741418afd2194d216deca1e865a", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -4900,7 +4900,7 @@ expand_function_end (void)\n   /* Output the label for the actual return from the function.  */\n   emit_label (return_label);\n \n-  if (targetm.except_unwind_info () == UI_SJLJ)\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ)\n     {\n       /* Let except.c know where it should emit the call to unregister\n \t the function context for sjlj exceptions.  */\n@@ -5059,7 +5059,7 @@ expand_function_end (void)\n      may trap are not moved into the epilogue by scheduling, because\n      we don't always emit unwind information for the epilogue.  */\n   if (cfun->can_throw_non_call_exceptions\n-      && targetm.except_unwind_info () != UI_SJLJ)\n+      && targetm.except_unwind_info (&global_options) != UI_SJLJ)\n     emit_insn (gen_blockage ());\n \n   /* If stack protection is enabled for this function, check the guard.  */"}, {"sha": "f859dd96507155f29ee0a0a16e5d89fd4eab15e4", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -56,6 +56,14 @@ hook_bool_bool_false (bool a ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Generic hook that takes (bool, struct gcc_options *) and returns false.  */\n+bool\n+hook_bool_bool_gcc_optionsp_false (bool a ATTRIBUTE_UNUSED,\n+\t\t\t\t   struct gcc_options *opts ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Generic hook that takes const int, const int) and returns true.  */\n bool hook_bool_const_int_const_int_true (const int a ATTRIBUTE_UNUSED,\n                                          const int b ATTRIBUTE_UNUSED)"}, {"sha": "7962fe818ba028e02a49af1f8d979001b021ff76", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -28,6 +28,7 @@\n extern bool hook_bool_void_false (void);\n extern bool hook_bool_void_true (void);\n extern bool hook_bool_bool_false (bool);\n+extern bool hook_bool_bool_gcc_optionsp_false (bool, struct gcc_options *);\n extern bool hook_bool_const_int_const_int_true (const int, const int);\n extern bool hook_bool_mode_false (enum machine_mode);\n extern bool hook_bool_mode_true (enum machine_mode);"}, {"sha": "cd69fe1bd9ff31f82eaf909af019f3a6ca6128c3", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -632,12 +632,6 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n {\n   enum unwind_info_type ui_except;\n \n-  /* These assertions are because of the use of target hooks that\n-     still access global data rather than being passed an options\n-     structure pointer.  */\n-  gcc_assert (opts == &global_options);\n-  gcc_assert (opts_set = &global_options_set);\n-\n   if (opts->x_dump_base_name && ! IS_ABSOLUTE_PATH (opts->x_dump_base_name))\n     {\n       /* First try to make OPTS->X_DUMP_BASE_NAME relative to the\n@@ -727,7 +721,7 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n      generating unwind info.  If opts->x_flag_exceptions is turned on\n      we need to turn off the partitioning optimization.  */\n \n-  ui_except = targetm.except_unwind_info ();\n+  ui_except = targetm.except_unwind_info (opts);\n \n   if (opts->x_flag_exceptions\n       && opts->x_flag_reorder_blocks_and_partition\n@@ -827,7 +821,7 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n     opts->x_flag_split_stack = 0;\n   else if (opts->x_flag_split_stack)\n     {\n-      if (!targetm.supports_split_stack (true))\n+      if (!targetm.supports_split_stack (true, opts))\n \t{\n \t  error_at (loc, \"%<-fsplit-stack%> is not supported by \"\n \t\t    \"this compiler configuration\");\n@@ -1173,9 +1167,6 @@ common_handle_option (struct gcc_options *opts,\n   int value = decoded->value;\n   enum opt_code code = (enum opt_code) scode;\n \n-  gcc_assert (opts == &global_options);\n-  gcc_assert (opts_set == &global_options_set);\n-  gcc_assert (dc == global_dc);\n   gcc_assert (decoded->canonical_option_num_elements <= 2);\n \n   switch (code)"}, {"sha": "a486ffad4858b6add41c47de78ba5e2b14616e5b", "filename": "gcc/target.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -1831,13 +1831,14 @@ DEFHOOK\n \n DEFHOOK\n (supports_split_stack,\n- \"Whether this target supports splitting the stack.  This is called\\\n+ \"Whether this target supports splitting the stack when the options\\\n+ described in @var{opts} have been passed.  This is called\\\n  after options have been parsed, so the target may reject splitting\\\n  the stack in some configurations.  The default version of this hook\\\n  returns false.  If @var{report} is true, this function may issue a warning\\\n  or error; if @var{report} is false, it must simply return a value\",\n- bool, (bool),\n- hook_bool_bool_false)\n+ bool, (bool report, struct gcc_options *opts),\n+ hook_bool_bool_gcc_optionsp_false)\n \n /* Returns NULL if target supports the insn within a doloop block,\n    otherwise it returns an error message.  */\n@@ -2576,7 +2577,7 @@ DEFHOOK\n DEFHOOK\n (except_unwind_info,\n  \"\",\n- enum unwind_info_type, (void),\n+ enum unwind_info_type, (struct gcc_options *opts),\n  default_except_unwind_info)\n \n /* Leave the boolean fields at the end.  */"}, {"sha": "cdc280981cb8c288adbd0acd3235b3214d96e41f", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -1309,7 +1309,7 @@ default_debug_unwind_info (void)\n /* Determine the exception handling mechanism for the target.  */\n \n enum unwind_info_type\n-default_except_unwind_info (void)\n+default_except_unwind_info (struct gcc_options *opts ATTRIBUTE_UNUSED)\n {\n   /* Obey the configure switch to turn on sjlj exceptions.  */\n #ifdef CONFIG_SJLJ_EXCEPTIONS\n@@ -1329,7 +1329,7 @@ default_except_unwind_info (void)\n /* To be used by targets that force dwarf2 unwind enabled.  */\n \n enum unwind_info_type\n-dwarf2_except_unwind_info (void)\n+dwarf2_except_unwind_info (struct gcc_options *opts ATTRIBUTE_UNUSED)\n {\n   /* Obey the configure switch to turn on sjlj exceptions.  */\n #ifdef CONFIG_SJLJ_EXCEPTIONS\n@@ -1343,7 +1343,7 @@ dwarf2_except_unwind_info (void)\n /* To be used by targets that force sjlj unwind enabled.  */\n \n enum unwind_info_type\n-sjlj_except_unwind_info (void)\n+sjlj_except_unwind_info (struct gcc_options *opts ATTRIBUTE_UNUSED)\n {\n   return UI_SJLJ;\n }"}, {"sha": "ce73f994cb8126b32748babe004dff2bc2ac7bcc", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -163,9 +163,9 @@ extern reg_class_t default_preferred_output_reload_class (rtx, reg_class_t);\n extern bool default_class_likely_spilled_p (reg_class_t);\n \n extern enum unwind_info_type default_debug_unwind_info (void);\n-extern enum unwind_info_type default_except_unwind_info (void);\n-extern enum unwind_info_type dwarf2_except_unwind_info (void);\n-extern enum unwind_info_type sjlj_except_unwind_info (void);\n+extern enum unwind_info_type default_except_unwind_info (struct gcc_options *);\n+extern enum unwind_info_type dwarf2_except_unwind_info (struct gcc_options *);\n+extern enum unwind_info_type sjlj_except_unwind_info (struct gcc_options *);\n \n extern int default_label_align_after_barrier_max_skip (rtx);\n extern int default_loop_align_max_skip (rtx);"}, {"sha": "a9bf62835c7c0761fde89a3b138214ace89b8905", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -152,7 +152,7 @@ suitable_for_tail_call_opt_p (void)\n   /* If we are using sjlj exceptions, we may need to add a call to\n      _Unwind_SjLj_Unregister at exit of the function.  Which means\n      that we cannot do any sibcall transformations.  */\n-  if (targetm.except_unwind_info () == UI_SJLJ\n+  if (targetm.except_unwind_info (&global_options) == UI_SJLJ\n       && current_function_has_exception_handlers ())\n     return false;\n "}, {"sha": "2f8d96ef4a2054da68715d6135ebb7835a68e0c6", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fabb58358641e0d597a966b34e20339c231180/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d5fabb58358641e0d597a966b34e20339c231180", "patch": "@@ -9343,7 +9343,8 @@ build_common_builtin_nodes (void)\n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_unwind_resume\", ftype,\n \t\t\tBUILT_IN_UNWIND_RESUME,\n-\t\t\t(targetm.except_unwind_info () == UI_SJLJ\n+\t\t\t((targetm.except_unwind_info (&global_options)\n+\t\t\t  == UI_SJLJ)\n \t\t\t ? \"_Unwind_SjLj_Resume\" : \"_Unwind_Resume\"),\n \t\t\tECF_NORETURN);\n "}]}