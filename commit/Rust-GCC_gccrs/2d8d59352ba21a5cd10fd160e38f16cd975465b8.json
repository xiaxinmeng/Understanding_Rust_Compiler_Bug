{"sha": "2d8d59352ba21a5cd10fd160e38f16cd975465b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ4ZDU5MzUyYmEyMWE1Y2QxMGZkMTYwZTM4ZjE2Y2Q5NzU0NjViOA==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@CeBiTec.Uni-Bielefeld.DE", "date": "2011-07-11T14:40:56Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-07-11T14:40:56Z"}, "message": "dfp-bit.c, dfp-bit.h: Move to ../libgcc.\n\n\tgcc:\n\t* config/dfp-bit.c, config/dfp-bit.h: Move to ../libgcc.\n\t* config/t-dfprules: Move to ../libgcc/config.\n\t* config.gcc (i[34567]86-*-linux*, i[34567]86-*-kfreebsd*-gnu,\n\ti[34567]86-*-knetbsd*-gnu, i[34567]86-*-gnu*,\n\ti[34567]86-*-kopensolaris*-gnu): Remove t-dfprules from tmake_file.\n\t(x86_64-*-linux*, x86_64-*-kfreebsd*-gnu, x86_64-*-knetbsd*-gnu):\n\tLikewise.\n\t(i[34567]86-*-cygwin*): Likewise.\n\t(i[34567]86-*-mingw*,  x86_64-*-mingw*): Likewise.\n\t(powerpc-*-linux*, powerpc64-*-linux*): Likewise.\n\t* Makefile.in (D32PBIT_FUNCS, D64PBIT_FUNCS, D128PBIT_FUNCS): Remove.\n\t(libgcc.mvars): Remove DFP_ENABLE, DFP_CFLAGS, D32PBIT_FUNCS,\n\tD64PBIT_FUNCS, D128PBIT_FUNCS.\n\n\tlibgcc:\n\t* dfp-bit.c, dfp-bit.h: New files.\n\t* Makefile.in (D32PBIT_FUNCS, D64PBIT_FUNCS, D128PBIT_FUNCS): New\n\tvariables.\n\t($(d32pbit-o)): Use $(srcdir) to refer to dfp-bit.c\n\t($(d64pbit-o)): Likewise.\n\t($(d128pbit-o)): Likewise.\n\t* config/t-dfprules: New file.\n\t* config.host (i[34567]86-*-linux*): Add t-dfprules to tmake_file.\n\t(i[34567]86-*-kfreebsd*-gnu, i[34567]86-*-knetbsd*-gnu,\n\ti[34567]86-*-gnu*, i[34567]86-*-kopensolaris*-gnu): Likewise.\n\t(x86_64-*-linux*): Likewise.\n\t(x86_64-*-kfreebsd*-gnu, x86_64-*-knetbsd*-gnu): Likewise.\n\t(i[34567]86-*-cygwin*): Likewise.\n\t(i[34567]86-*-mingw*,  x86_64-*-mingw*): Likewise.\n\t(powerpc-*-linux*, powerpc64-*-linux*): Likewise.\n\nFrom-SVN: r176156", "tree": {"sha": "c0961cab7a9db9c24685d74ec85b00dee649c332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0961cab7a9db9c24685d74ec85b00dee649c332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d8d59352ba21a5cd10fd160e38f16cd975465b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8d59352ba21a5cd10fd160e38f16cd975465b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d8d59352ba21a5cd10fd160e38f16cd975465b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8d59352ba21a5cd10fd160e38f16cd975465b8/comments", "author": {"login": "rorth", "id": 3930951, "node_id": "MDQ6VXNlcjM5MzA5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rorth", "html_url": "https://github.com/rorth", "followers_url": "https://api.github.com/users/rorth/followers", "following_url": "https://api.github.com/users/rorth/following{/other_user}", "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rorth/subscriptions", "organizations_url": "https://api.github.com/users/rorth/orgs", "repos_url": "https://api.github.com/users/rorth/repos", "events_url": "https://api.github.com/users/rorth/events{/privacy}", "received_events_url": "https://api.github.com/users/rorth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dcc95c20883bb4f104314650e76176d30ad8396e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcc95c20883bb4f104314650e76176d30ad8396e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcc95c20883bb4f104314650e76176d30ad8396e"}], "stats": {"total": 1438, "additions": 1391, "deletions": 47}, "files": [{"sha": "e12c14d76df599369f26ebb49b84341bcd9cd4a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -1,3 +1,19 @@\n+2011-07-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* config/dfp-bit.c, config/dfp-bit.h: Move to ../libgcc.\n+\t* config/t-dfprules: Move to ../libgcc/config.\n+\t* config.gcc (i[34567]86-*-linux*, i[34567]86-*-kfreebsd*-gnu,\n+\ti[34567]86-*-knetbsd*-gnu, i[34567]86-*-gnu*,\n+\ti[34567]86-*-kopensolaris*-gnu): Remove t-dfprules from tmake_file.\n+\t(x86_64-*-linux*, x86_64-*-kfreebsd*-gnu, x86_64-*-knetbsd*-gnu):\n+\tLikewise.\n+\t(i[34567]86-*-cygwin*): Likewise.\n+\t(i[34567]86-*-mingw*,  x86_64-*-mingw*): Likewise.\n+\t(powerpc-*-linux*, powerpc64-*-linux*): Likewise.\n+\t* Makefile.in (D32PBIT_FUNCS, D64PBIT_FUNCS, D128PBIT_FUNCS): Remove.\n+\t(libgcc.mvars): Remove DFP_ENABLE, DFP_CFLAGS, D32PBIT_FUNCS,\n+\tD64PBIT_FUNCS, D128PBIT_FUNCS.\n+\n 2011-07-11  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-vrp.c (simplify_conversion_using_ranges): Manually"}, {"sha": "caef28c822ff64592287df16d0089808948f56c6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -1555,30 +1555,6 @@ TPBIT_FUNCS = _pack_tf _unpack_tf _addsub_tf _mul_tf _div_tf \\\n     _lt_tf _le_tf _unord_tf _si_to_tf _tf_to_si _negate_tf _make_tf \\\n     _tf_to_df _tf_to_sf _thenan_tf _tf_to_usi _usi_to_tf\n \n-D32PBIT_FUNCS = _addsub_sd _div_sd _mul_sd _plus_sd _minus_sd \\\n-\t_eq_sd _ne_sd _lt_sd _gt_sd _le_sd _ge_sd \\\n-\t_sd_to_si _sd_to_di _sd_to_usi _sd_to_udi \\\n-\t_si_to_sd _di_to_sd _usi_to_sd _udi_to_sd \\\n-\t_sd_to_sf _sd_to_df _sd_to_xf _sd_to_tf \\\n-\t_sf_to_sd _df_to_sd _xf_to_sd _tf_to_sd \\\n-\t_sd_to_dd _sd_to_td _unord_sd _conv_sd\n-\n-D64PBIT_FUNCS = _addsub_dd _div_dd _mul_dd _plus_dd _minus_dd \\\n-\t_eq_dd _ne_dd _lt_dd _gt_dd _le_dd _ge_dd \\\n-\t_dd_to_si _dd_to_di _dd_to_usi _dd_to_udi \\\n-\t_si_to_dd _di_to_dd _usi_to_dd _udi_to_dd \\\n-\t_dd_to_sf _dd_to_df _dd_to_xf _dd_to_tf \\\n-\t_sf_to_dd _df_to_dd _xf_to_dd _tf_to_dd \\\n-\t_dd_to_sd _dd_to_td _unord_dd _conv_dd\n-\n-D128PBIT_FUNCS = _addsub_td _div_td _mul_td _plus_td _minus_td \\\n-\t_eq_td _ne_td _lt_td _gt_td _le_td _ge_td \\\n-\t_td_to_si _td_to_di _td_to_usi _td_to_udi \\\n-\t_si_to_td _di_to_td _usi_to_td _udi_to_td \\\n-\t_td_to_sf _td_to_df _td_to_xf _td_to_tf \\\n-\t_sf_to_td _df_to_td _xf_to_td _tf_to_td \\\n-\t_td_to_sd _td_to_dd _unord_td _conv_td\n-\n # These might cause a divide overflow trap and so are compiled with\n # unwinder info.\n LIB2_DIVMOD_FUNCS = _divdi3 _moddi3 _udivdi3 _umoddi3 _udiv_w_sdiv _udivmoddi4\n@@ -1941,14 +1917,6 @@ libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \\\n \techo DPBIT_FUNCS = '$(DPBIT_FUNCS)' >> tmp-libgcc.mvars\n \techo TPBIT = '$(TPBIT)' >> tmp-libgcc.mvars\n \techo TPBIT_FUNCS = '$(TPBIT_FUNCS)' >> tmp-libgcc.mvars\n-\techo DFP_ENABLE = '$(DFP_ENABLE)' >> tmp-libgcc.mvars\n-\techo DFP_CFLAGS='$(DFP_CFLAGS)' >> tmp-libgcc.mvars\n-\techo D32PBIT='$(D32PBIT)' >> tmp-libgcc.mvars\n-\techo D32PBIT_FUNCS='$(D32PBIT_FUNCS)' >> tmp-libgcc.mvars\n-\techo D64PBIT='$(D64PBIT)' >> tmp-libgcc.mvars\n-\techo D64PBIT_FUNCS='$(D64PBIT_FUNCS)' >> tmp-libgcc.mvars\n-\techo D128PBIT='$(D128PBIT)' >> tmp-libgcc.mvars\n-\techo D128PBIT_FUNCS='$(D128PBIT_FUNCS)' >> tmp-libgcc.mvars\n \techo GCC_EXTRA_PARTS = '$(GCC_EXTRA_PARTS)' >> tmp-libgcc.mvars\n \techo SHLIB_LINK = '$(subst $(GCC_FOR_TARGET),$$(GCC_FOR_TARGET),$(SHLIB_LINK))' >> tmp-libgcc.mvars\n \techo SHLIB_INSTALL = '$(SHLIB_INSTALL)' >> tmp-libgcc.mvars"}, {"sha": "aa27283519fbb0c7ac1c46b8f8f630079cd76ca5", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -1311,7 +1311,7 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i\n \ti[34567]86-*-kopensolaris*-gnu) tm_file=\"${tm_file} i386/gnu-user.h kopensolaris-gnu.h i386/kopensolaris-gnu.h\" ;;\n \ti[34567]86-*-gnu*) tm_file=\"$tm_file i386/gnu-user.h gnu.h i386/gnu.h\";;\n \tesac\n-\ttmake_file=\"${tmake_file} i386/t-crtstuff i386/t-crtpc i386/t-crtfm t-dfprules\"\n+\ttmake_file=\"${tmake_file} i386/t-crtstuff i386/t-crtpc i386/t-crtfm\"\n \t;;\n x86_64-*-linux* | x86_64-*-kfreebsd*-gnu | x86_64-*-knetbsd*-gnu)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h gnu-user.h glibc-stdint.h \\\n@@ -1323,7 +1323,7 @@ x86_64-*-linux* | x86_64-*-kfreebsd*-gnu | x86_64-*-knetbsd*-gnu)\n \tx86_64-*-kfreebsd*-gnu) tm_file=\"${tm_file} kfreebsd-gnu.h i386/kfreebsd-gnu64.h\" ;;\n \tx86_64-*-knetbsd*-gnu) tm_file=\"${tm_file} knetbsd-gnu.h\" ;;\n \tesac\n-\ttmake_file=\"${tmake_file} i386/t-linux64 i386/t-crtstuff i386/t-crtpc i386/t-crtfm t-dfprules\"\n+\ttmake_file=\"${tmake_file} i386/t-linux64 i386/t-crtstuff i386/t-crtpc i386/t-crtfm\"\n \tx86_multilibs=\"${with_multilib_list}\"\n \tif test \"$x86_multilibs\" = \"default\"; then\n \t\tx86_multilibs=\"m64,m32\"\n@@ -1458,7 +1458,7 @@ i[34567]86-*-cygwin*)\n \telse\n \t\ttmake_dlldir_file=\"i386/t-dlldir-x\"\n \tfi\n-\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-cygming i386/t-cygwin t-dfprules\"\n+\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-cygming i386/t-cygwin\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_options=\"${extra_options} i386/cygming.opt\"\n \textra_objs=\"winnt.o winnt-stubs.o\"\n@@ -1524,7 +1524,7 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)\n \telse\n \t\ttmake_dlldir_file=\"i386/t-dlldir-x\"\n \tfi\n-\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-cygming t-dfprules\"\n+\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-cygming\"\n         case ${target} in\n                x86_64-w64-*)\n                \t\ttmake_file=\"${tmake_file} i386/t-mingw-w64\"\n@@ -2114,7 +2114,7 @@ powerpc-*-rtems*)\n powerpc-*-linux* | powerpc64-*-linux*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h freebsd-spec.h rs6000/sysv4.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"t-dfprules rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \tmaybe_biarch=yes\n \tcase ${target} in\n \t    powerpc64-*-linux*spe* | powerpc64-*-linux*paired*)"}, {"sha": "cc392378e5b4808b7cad95283c9e1aa47c2873bd", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -1,3 +1,21 @@\n+2011-07-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* dfp-bit.c, dfp-bit.h: New files.\n+\t* Makefile.in (D32PBIT_FUNCS, D64PBIT_FUNCS, D128PBIT_FUNCS): New\n+\tvariables.\n+\t($(d32pbit-o)): Use $(srcdir) to refer to dfp-bit.c\n+\t($(d64pbit-o)): Likewise.\n+\t($(d128pbit-o)): Likewise.\n+\t* config/t-dfprules: New file.\n+\t* config.host (i[34567]86-*-linux*): Add t-dfprules to tmake_file.\n+\t(i[34567]86-*-kfreebsd*-gnu, i[34567]86-*-knetbsd*-gnu,\n+\ti[34567]86-*-gnu*, i[34567]86-*-kopensolaris*-gnu): Likewise.\n+\t(x86_64-*-linux*): Likewise.\n+\t(x86_64-*-kfreebsd*-gnu, x86_64-*-knetbsd*-gnu): Likewise.\n+\t(i[34567]86-*-cygwin*): Likewise.\n+\t(i[34567]86-*-mingw*,  x86_64-*-mingw*): Likewise.\n+\t(powerpc-*-linux*, powerpc64-*-linux*): Likewise.\n+\n 2011-07-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Makfile.in (LIBGCOV): New variable."}, {"sha": "8c41ffcf7a62bad53c843c2e7b4066e4f57f0b95", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -554,6 +554,30 @@ endif\n libgcc-objects += $(decbits-objects)\n \n # Next build individual support functions.\n+D32PBIT_FUNCS = _addsub_sd _div_sd _mul_sd _plus_sd _minus_sd \\\n+\t_eq_sd _ne_sd _lt_sd _gt_sd _le_sd _ge_sd \\\n+\t_sd_to_si _sd_to_di _sd_to_usi _sd_to_udi \\\n+\t_si_to_sd _di_to_sd _usi_to_sd _udi_to_sd \\\n+\t_sd_to_sf _sd_to_df _sd_to_xf _sd_to_tf \\\n+\t_sf_to_sd _df_to_sd _xf_to_sd _tf_to_sd \\\n+\t_sd_to_dd _sd_to_td _unord_sd _conv_sd\n+\n+D64PBIT_FUNCS = _addsub_dd _div_dd _mul_dd _plus_dd _minus_dd \\\n+\t_eq_dd _ne_dd _lt_dd _gt_dd _le_dd _ge_dd \\\n+\t_dd_to_si _dd_to_di _dd_to_usi _dd_to_udi \\\n+\t_si_to_dd _di_to_dd _usi_to_dd _udi_to_dd \\\n+\t_dd_to_sf _dd_to_df _dd_to_xf _dd_to_tf \\\n+\t_sf_to_dd _df_to_dd _xf_to_dd _tf_to_dd \\\n+\t_dd_to_sd _dd_to_td _unord_dd _conv_dd\n+\n+D128PBIT_FUNCS = _addsub_td _div_td _mul_td _plus_td _minus_td \\\n+\t_eq_td _ne_td _lt_td _gt_td _le_td _ge_td \\\n+\t_td_to_si _td_to_di _td_to_usi _td_to_udi \\\n+\t_si_to_td _di_to_td _usi_to_td _udi_to_td \\\n+\t_td_to_sf _td_to_df _td_to_xf _td_to_tf \\\n+\t_sf_to_td _df_to_td _xf_to_td _tf_to_td \\\n+\t_td_to_sd _td_to_dd _unord_td _conv_td\n+\n ifeq ($(enable_decimal_float),bid)\n ifneq ($(D32PBIT),)\n D32PBIT_FUNCS:=$(filter-out _plus_sd _minus_sd _conv_sd, $(D32PBIT_FUNCS))\n@@ -573,7 +597,7 @@ d32pbit-o = $(patsubst %,%$(objext),$(D32PBIT_FUNCS))\n ifeq ($(enable_decimal_float),bid)\n $(d32pbit-o): %$(objext): $(srcdir)/config/libbid/%.c\n else\n-$(d32pbit-o): %$(objext): $(gcc_srcdir)/config/dfp-bit.c\n+$(d32pbit-o): %$(objext): $(srcdir)/dfp-bit.c\n endif\n \t$(gcc_compile) -DFINE_GRAINED_LIBRARIES -DL$* -DWIDTH=32 -c $<\n libgcc-objects += $(d32pbit-o)\n@@ -584,7 +608,7 @@ d64pbit-o = $(patsubst %,%$(objext),$(D64PBIT_FUNCS))\n ifeq ($(enable_decimal_float),bid)\n $(d64pbit-o): %$(objext): $(srcdir)/config/libbid/%.c\n else\n-$(d64pbit-o): %$(objext): $(gcc_srcdir)/config/dfp-bit.c\n+$(d64pbit-o): %$(objext): $(srcdir)/dfp-bit.c\n endif\n \t$(gcc_compile) -DFINE_GRAINED_LIBRARIES -DL$* -DWIDTH=64 -c $<\n libgcc-objects += $(d64pbit-o)\n@@ -595,7 +619,7 @@ d128pbit-o = $(patsubst %,%$(objext),$(D128PBIT_FUNCS))\n ifeq ($(enable_decimal_float),bid)\n $(d128pbit-o): %$(objext): $(srcdir)/config/libbid/%.c\n else\n-$(d128pbit-o): %$(objext): $(gcc_srcdir)/config/dfp-bit.c\n+$(d128pbit-o): %$(objext): $(srcdir)/dfp-bit.c\n endif\n \t$(gcc_compile) -DFINE_GRAINED_LIBRARIES -DL$* -DWIDTH=128 -c $<\n libgcc-objects += $(d128pbit-o)"}, {"sha": "55f8a5107665467d86f1291770e3cda5ed2fbc42", "filename": "libgcc/config.host", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -346,21 +346,21 @@ i[34567]86-*-openbsd*)\n \t;;\n i[34567]86-*-linux*)\n \textra_parts=\"$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o\"\n-\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm\"\n+\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm t-dfprules\"\n \tmd_unwind_header=i386/linux-unwind.h\n \t;;\n i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu)\n \textra_parts=\"$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o\"\n-\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm\"\n+\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm t-dfprules\"\n \t;;\n x86_64-*-linux*)\n \textra_parts=\"$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o\"\n-\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm\"\n+\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm t-dfprules\"\n \tmd_unwind_header=i386/linux-unwind.h\n \t;;\n x86_64-*-kfreebsd*-gnu | x86_64-*-knetbsd*-gnu)\n \textra_parts=\"$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o\"\n-\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm\"\n+\ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm t-dfprules\"\n \t;;\n i[34567]86-pc-msdosdjgpp*)\n \t;;\n@@ -388,14 +388,15 @@ i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n \t;;\n i[34567]86-*-cygwin*)\n \textra_parts=\"crtbegin.o crtend.o crtfastmath.o\"\n-\ttmake_file=\"i386/t-cygming i386/t-crtfm\"\n+\ttmake_file=\"i386/t-cygming i386/t-crtfm t-dfprules\"\n \t;;\n i[34567]86-*-mingw*)\n \textra_parts=\"crtbegin.o crtend.o crtfastmath.o\"\n-\ttmake_file=\"i386/t-cygming i386/t-crtfm\"\n+\ttmake_file=\"i386/t-cygming i386/t-crtfm t-dfprules\"\n \tmd_unwind_header=i386/w32-unwind.h\n \t;;\n x86_64-*-mingw*)\n+\ttmake_file=t-dfprules\n \t;;\n i[34567]86-*-interix3*)\n \t;;\n@@ -551,7 +552,7 @@ powerpc-*-eabi*)\n powerpc-*-rtems*)\n \t;;\n powerpc-*-linux* | powerpc64-*-linux*)\n-\ttmake_file=\"${tmake_file} rs6000/t-ppccomm rs6000/t-ldbl128 t-softfp\"\n+\ttmake_file=\"${tmake_file} rs6000/t-ppccomm rs6000/t-ldbl128 t-softfp t-dfprules\"\n \tmd_unwind_header=rs6000/linux-unwind.h\n \t;;\n powerpc-wrs-vxworks|powerpc-wrs-vxworksae)"}, {"sha": "6bf6246d8c7055944b736e012cfb559ebce0c184", "filename": "libgcc/config/t-dfprules", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fconfig%2Ft-dfprules", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fconfig%2Ft-dfprules", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ft-dfprules?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -0,0 +1,10 @@\n+# Use DFP_ENABLE to build decimal floating point support routines for\n+# all decimal floating point types (32-bit, 64-bit and 128-bit). We\n+# use `true' for clarity, but any value will do.\n+#\n+DFP_ENABLE = true\n+\n+# DFP_CFLAGS can be used to pass target-specific CFLAGS when compiling\n+# dfp-bit.c.  This is useful for overriding the definition of macros.\n+#\n+# DFP_CFLAGS = -DFOO=bar"}, {"sha": "48dcb735510a9de13dbfd9b3e947f641631d14c2", "filename": "libgcc/dfp-bit.c", "status": "added", "additions": 681, "deletions": 0, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fdfp-bit.c?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -0,0 +1,681 @@\n+/* This is a software decimal floating point library.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2011\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This implements IEEE 754 decimal floating point arithmetic, but\n+   does not provide a mechanism for setting the rounding mode, or for\n+   generating or handling exceptions.  Conversions between decimal\n+   floating point types and other types depend on C library functions.\n+\n+   Contributed by Ben Elliston  <bje@au.ibm.com>.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+/* FIXME: compile with -std=gnu99 to get these from stdlib.h */\n+extern float strtof (const char *, char **);\n+extern long double strtold (const char *, char **);\n+#include <string.h>\n+#include <limits.h>\n+\n+#include \"dfp-bit.h\"\n+\n+/* Forward declarations.  */\n+#if WIDTH == 32 || WIDTH_TO == 32\n+void __host_to_ieee_32 (_Decimal32 in, decimal32 *out);\n+void __ieee_to_host_32 (decimal32 in, _Decimal32 *out);\n+#endif\n+#if WIDTH == 64 || WIDTH_TO == 64\n+void __host_to_ieee_64 (_Decimal64 in, decimal64 *out);\n+void __ieee_to_host_64 (decimal64 in, _Decimal64 *out);\n+#endif\n+#if WIDTH == 128 || WIDTH_TO == 128\n+void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);\n+void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);\n+#endif\n+\n+/* A pointer to a binary decFloat operation.  */\n+typedef decFloat* (*dfp_binary_func)\n+     (decFloat *, const decFloat *, const decFloat *, decContext *);\n+\f\n+/* Binary operations.  */\n+\n+/* Use a decFloat (decDouble or decQuad) function to perform a DFP\n+   binary operation.  */\n+static inline decFloat\n+dfp_binary_op (dfp_binary_func op, decFloat arg_a, decFloat arg_b)\n+{\n+  decFloat result;\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+\n+  /* Perform the operation.  */\n+  op (&result, &arg_a, &arg_b, &context);\n+\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    {\n+      /* decNumber exception flags we care about here.  */\n+      int ieee_flags;\n+      int dec_flags = DEC_IEEE_854_Division_by_zero | DEC_IEEE_854_Inexact\n+\t\t      | DEC_IEEE_854_Invalid_operation | DEC_IEEE_854_Overflow\n+\t\t      | DEC_IEEE_854_Underflow;\n+      dec_flags &= context.status;\n+      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n+      if (ieee_flags != 0)\n+        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n+    }\n+\n+  return result;\n+}\n+\n+#if WIDTH == 32\n+/* The decNumber package doesn't provide arithmetic for decSingle (32 bits);\n+   convert to decDouble, use the operation for that, and convert back.  */\n+static inline _Decimal32\n+d32_binary_op (dfp_binary_func op, _Decimal32 arg_a, _Decimal32 arg_b)\n+{\n+  union { _Decimal32 c; decSingle f; } a32, b32, res32;\n+  decDouble a, b, res;\n+  decContext context;\n+\n+  /* Widen the operands and perform the operation.  */\n+  a32.c = arg_a;\n+  b32.c = arg_b;\n+  decSingleToWider (&a32.f, &a);\n+  decSingleToWider (&b32.f, &b);\n+  res = dfp_binary_op (op, a, b);\n+\n+  /* Narrow the result, which might result in an underflow or overflow.  */\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+  decSingleFromWider (&res32.f, &res, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    {\n+      /* decNumber exception flags we care about here.  */\n+      int ieee_flags;\n+      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Overflow\n+\t\t      | DEC_IEEE_854_Underflow;\n+      dec_flags &= context.status;\n+      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n+      if (ieee_flags != 0)\n+        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n+    }\n+\n+  return res32.c;\n+}\n+#else\n+/* decFloat operations are supported for decDouble (64 bits) and\n+   decQuad (128 bits).  The bit patterns for the types are the same.  */\n+static inline DFP_C_TYPE\n+dnn_binary_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } a, b, result;\n+\n+  a.c = arg_a;\n+  b.c = arg_b;\n+  result.f = dfp_binary_op (op, a.f, b.f);\n+  return result.c;\n+}\n+#endif\n+\n+/* Comparison operations.  */\n+\n+/* Use a decFloat (decDouble or decQuad) function to perform a DFP\n+   comparison.  */\n+static inline CMPtype\n+dfp_compare_op (dfp_binary_func op, decFloat arg_a, decFloat arg_b)\n+{\n+  decContext context;\n+  decFloat res;\n+  int result;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+\n+  /* Perform the comparison.  */\n+  op (&res, &arg_a, &arg_b, &context);\n+\n+  if (DEC_FLOAT_IS_SIGNED (&res))\n+    result = -1;\n+  else if (DEC_FLOAT_IS_ZERO (&res))\n+    result = 0;\n+  else if (DEC_FLOAT_IS_NAN (&res))\n+    result = -2;\n+  else\n+    result = 1;\n+\n+  return (CMPtype) result;\n+}\n+\n+#if WIDTH == 32\n+/* The decNumber package doesn't provide comparisons for decSingle (32 bits);\n+   convert to decDouble, use the operation for that, and convert back.  */\n+static inline CMPtype\n+d32_compare_op (dfp_binary_func op, _Decimal32 arg_a, _Decimal32 arg_b)\n+{\n+  union { _Decimal32 c; decSingle f; } a32, b32;\n+  decDouble a, b;\n+\n+  a32.c = arg_a;\n+  b32.c = arg_b;\n+  decSingleToWider (&a32.f, &a);\n+  decSingleToWider (&b32.f, &b);\n+  return dfp_compare_op (op, a, b);  \n+}\n+#else\n+/* decFloat comparisons are supported for decDouble (64 bits) and\n+   decQuad (128 bits).  The bit patterns for the types are the same.  */\n+static inline CMPtype\n+dnn_compare_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } a, b;\n+\n+  a.c = arg_a;\n+  b.c = arg_b;\n+  return dfp_compare_op (op, a.f, b.f);  \n+}\n+#endif\n+\f\n+#if defined(L_conv_sd)\n+void\n+__host_to_ieee_32 (_Decimal32 in, decimal32 *out)\n+{\n+  memcpy (out, &in, 4);\n+}\n+\n+void\n+__ieee_to_host_32 (decimal32 in, _Decimal32 *out)\n+{\n+  memcpy (out, &in, 4);\n+}\n+#endif /* L_conv_sd */\n+\n+#if defined(L_conv_dd)\n+void\n+__host_to_ieee_64 (_Decimal64 in, decimal64 *out)\n+{\n+  memcpy (out, &in, 8);\n+}\n+\n+void\n+__ieee_to_host_64 (decimal64 in, _Decimal64 *out)\n+{\n+  memcpy (out, &in, 8);\n+}\n+#endif /* L_conv_dd */\n+\n+#if defined(L_conv_td)\n+void\n+__host_to_ieee_128 (_Decimal128 in, decimal128 *out)\n+{\n+  memcpy (out, &in, 16);\n+}\n+\n+void\n+__ieee_to_host_128 (decimal128 in, _Decimal128 *out)\n+{\n+  memcpy (out, &in, 16);\n+}\n+#endif /* L_conv_td */\n+\n+#if defined(L_addsub_sd) || defined(L_addsub_dd) || defined(L_addsub_td)\n+DFP_C_TYPE\n+DFP_ADD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return DFP_BINARY_OP (DEC_FLOAT_ADD, arg_a, arg_b);\n+}\n+\n+DFP_C_TYPE\n+DFP_SUB (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return DFP_BINARY_OP (DEC_FLOAT_SUBTRACT, arg_a, arg_b);\n+}\n+#endif /* L_addsub */\n+\n+#if defined(L_mul_sd) || defined(L_mul_dd) || defined(L_mul_td)\n+DFP_C_TYPE\n+DFP_MULTIPLY (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return DFP_BINARY_OP (DEC_FLOAT_MULTIPLY, arg_a, arg_b);\n+}\n+#endif /* L_mul */\n+\n+#if defined(L_div_sd) || defined(L_div_dd) || defined(L_div_td)\n+DFP_C_TYPE\n+DFP_DIVIDE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return DFP_BINARY_OP (DEC_FLOAT_DIVIDE, arg_a, arg_b);\n+}\n+#endif /* L_div */\n+\n+#if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n+CMPtype\n+DFP_EQ (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  CMPtype stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n+  /* For EQ return zero for true, nonzero for false.  */\n+  return stat != 0;\n+}\n+#endif /* L_eq */\n+\n+#if defined (L_ne_sd) || defined (L_ne_dd) || defined (L_ne_td)\n+CMPtype\n+DFP_NE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n+  /* For NE return zero for true, nonzero for false.  */\n+  if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n+    return 1;\n+  return stat != 0;\n+}\n+#endif /* L_ne */\n+\n+#if defined (L_lt_sd) || defined (L_lt_dd) || defined (L_lt_td)\n+CMPtype\n+DFP_LT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n+  /* For LT return -1 (<0) for true, 1 for false.  */\n+  return (stat == -1) ? -1 : 1;\n+}\n+#endif /* L_lt */\n+\n+#if defined (L_gt_sd) || defined (L_gt_dd) || defined (L_gt_td)\n+CMPtype\n+DFP_GT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n+  /* For GT return 1 (>0) for true, -1 for false.  */\n+  return (stat == 1) ? 1 : -1;\n+}\n+#endif\n+\n+#if defined (L_le_sd) || defined (L_le_dd) || defined (L_le_td)\n+CMPtype\n+DFP_LE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n+  /* For LE return 0 (<= 0) for true, 1 for false.  */\n+  if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n+    return 1;\n+  return stat == 1;\n+}\n+#endif /* L_le */\n+\n+#if defined (L_ge_sd) || defined (L_ge_dd) || defined (L_ge_td)\n+CMPtype\n+DFP_GE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n+  /* For GE return 1 (>=0) for true, -1 for false.  */\n+  if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n+    return -1;\n+  return (stat != -1) ? 1 : -1;\n+}\n+#endif /* L_ge */\n+\n+#define BUFMAX 128\n+\n+/* Check for floating point exceptions that are relevant for conversions\n+   between decimal float values and handle them.  */\n+static inline void\n+dfp_conversion_exceptions (const int status)\n+{\n+  /* decNumber exception flags we care about here.  */\n+  int ieee_flags;\n+  int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n+\t\t  | DEC_IEEE_854_Overflow;\n+  dec_flags &= status;\n+  ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n+  if (ieee_flags != 0)\n+    DFP_HANDLE_EXCEPTIONS (ieee_flags);\n+}\n+\n+#if defined (L_sd_to_dd)\n+/* Use decNumber to convert directly from _Decimal32 to _Decimal64.  */\n+_Decimal64\n+DFP_TO_DFP (_Decimal32 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } from;\n+  union { _Decimal64 c; decDouble f; } to;\n+\n+  from.c = f_from;\n+  to.f = *decSingleToWider (&from.f, &to.f);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_sd_to_td)\n+/* Use decNumber to convert directly from _Decimal32 to _Decimal128.  */\n+_Decimal128\n+DFP_TO_DFP (_Decimal32 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } from;\n+  union { _Decimal128 c; decQuad f; } to;\n+  decDouble temp;\n+\n+  from.c = f_from;\n+  temp = *decSingleToWider (&from.f, &temp);\n+  to.f = *decDoubleToWider (&temp, &to.f);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_dd_to_td)\n+/* Use decNumber to convert directly from _Decimal64 to _Decimal128.  */\n+_Decimal128\n+DFP_TO_DFP (_Decimal64 f_from)\n+{\n+  union { _Decimal64 c; decDouble f; } from;\n+  union { _Decimal128 c; decQuad f; } to;\n+\n+  from.c = f_from;\n+  to.f = *decDoubleToWider (&from.f, &to.f);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_dd_to_sd)\n+/* Use decNumber to convert directly from _Decimal64 to _Decimal32.  */\n+_Decimal32\n+DFP_TO_DFP (_Decimal64 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } to;\n+  union { _Decimal64 c; decDouble f; } from;\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+  from.c = f_from;\n+  to.f = *decSingleFromWider (&to.f, &from.f, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_td_to_sd)\n+/* Use decNumber to convert directly from _Decimal128 to _Decimal32.  */\n+_Decimal32\n+DFP_TO_DFP (_Decimal128 f_from)\n+{\n+  union { _Decimal32 c; decSingle f; } to;\n+  union { _Decimal128 c; decQuad f; } from;\n+  decDouble temp;\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+  from.c = f_from;\n+  temp = *decDoubleFromWider (&temp, &from.f, &context);\n+  to.f = *decSingleFromWider (&to.f, &temp, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_td_to_dd)\n+/* Use decNumber to convert directly from _Decimal128 to _Decimal64.  */\n+_Decimal64\n+DFP_TO_DFP (_Decimal128 f_from)\n+{\n+  union { _Decimal64 c; decDouble f; } to;\n+  union { _Decimal128 c; decQuad f; } from;\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+  from.c = f_from;\n+  to.f = *decDoubleFromWider (&to.f, &from.f, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return to.c;\n+}\n+#endif\n+\n+#if defined (L_dd_to_si) || defined (L_td_to_si) \\\n+  || defined (L_dd_to_usi) || defined (L_td_to_usi)\n+/* Use decNumber to convert directly from decimal float to integer types.  */\n+INT_TYPE\n+DFP_TO_INT (DFP_C_TYPE x)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } u;\n+  decContext context;\n+  INT_TYPE i;\n+\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  context.round = DEC_ROUND_DOWN;\n+  u.c = x;\n+  i = DEC_FLOAT_TO_INT (&u.f, &context, context.round);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return i;\n+}\n+#endif\n+\n+#if defined (L_sd_to_si) || (L_sd_to_usi)\n+/* Use decNumber to convert directly from decimal float to integer types.  */\n+INT_TYPE\n+DFP_TO_INT (_Decimal32 x)\n+{\n+  union { _Decimal32 c; decSingle f; } u32;\n+  decDouble f64;\n+  decContext context;\n+  INT_TYPE i;\n+\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  context.round = DEC_ROUND_DOWN;\n+  u32.c = x;\n+  f64 = *decSingleToWider (&u32.f, &f64);\n+  i = DEC_FLOAT_TO_INT (&f64, &context, context.round);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return i;\n+}\n+#endif\n+\n+#if defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n+  || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n+/* decNumber doesn't provide support for conversions to 64-bit integer\n+   types, so do it the hard way.  */\n+INT_TYPE\n+DFP_TO_INT (DFP_C_TYPE x)\n+{\n+  /* decNumber's decimal* types have the same format as C's _Decimal*\n+     types, but they have different calling conventions.  */\n+\n+  /* TODO: Decimal float to integer conversions should raise FE_INVALID\n+     if the result value does not fit into the result type.  */\n+\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+  char *pos;\n+  decNumber qval, n1, n2;\n+  decContext context;\n+\n+  /* Use a large context to avoid losing precision.  */\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  /* Need non-default rounding mode here.  */\n+  context.round = DEC_ROUND_DOWN;\n+\n+  HOST_TO_IEEE (x, &s);\n+  TO_INTERNAL (&s, &n1);\n+  /* Rescale if the exponent is less than zero.  */\n+  decNumberToIntegralValue (&n2, &n1, &context);\n+  /* Get a value to use for the quantize call.  */\n+  decNumberFromString (&qval, \"1.\", &context);\n+  /* Force the exponent to zero.  */\n+  decNumberQuantize (&n1, &n2, &qval, &context);\n+  /* Get a string, which at this point will not include an exponent.  */\n+  decNumberToString (&n1, buf);\n+  /* Ignore the fractional part.  */\n+  pos = strchr (buf, '.');\n+  if (pos)\n+    *pos = 0;\n+  /* Use a C library function to convert to the integral type.  */\n+  return STR_TO_INT (buf, NULL, 10);\n+}\n+#endif\n+\n+#if defined (L_si_to_dd) || defined (L_si_to_td) \\\n+  || defined (L_usi_to_dd) || defined (L_usi_to_td)\n+/* Use decNumber to convert directly from integer to decimal float types.  */\n+DFP_C_TYPE\n+INT_TO_DFP (INT_TYPE i)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } u;\n+\n+  u.f = *DEC_FLOAT_FROM_INT (&u.f, i);\n+  return u.c;\n+}\n+#endif\n+\n+#if defined (L_si_to_sd) || defined (L_usi_to_sd)\n+_Decimal32\n+/* Use decNumber to convert directly from integer to decimal float types.  */\n+INT_TO_DFP (INT_TYPE i)\n+{\n+  union { _Decimal32 c; decSingle f; } u32;\n+  decDouble f64;\n+  decContext context;\n+\n+  decContextDefault (&context, DEC_INIT_DECIMAL128);\n+  f64 = *DEC_FLOAT_FROM_INT (&f64, i);\n+  u32.f = *decSingleFromWider (&u32.f, &f64, &context);\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+  return u32.c;\n+}\n+#endif\n+\n+#if defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n+  || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+/* decNumber doesn't provide support for conversions from 64-bit integer\n+   types, so do it the hard way.  */\n+DFP_C_TYPE\n+INT_TO_DFP (INT_TYPE i)\n+{\n+  DFP_C_TYPE f;\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+\n+  /* Use a C library function to get a floating point string.  */\n+  sprintf (buf, INT_FMT \".\", CAST_FOR_FMT(i));\n+  /* Convert from the floating point string to a decimal* type.  */\n+  FROM_STRING (&s, buf, &context);\n+  IEEE_TO_HOST (s, &f);\n+\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    dfp_conversion_exceptions (context.status);\n+\n+  return f;\n+}\n+#endif\n+\n+#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n+ || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n+ || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n+BFP_TYPE\n+DFP_TO_BFP (DFP_C_TYPE f)\n+{\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+\n+  HOST_TO_IEEE (f, &s);\n+  /* Write the value to a string.  */\n+  TO_STRING (&s, buf);\n+  /* Read it as the binary floating point type and return that.  */\n+  return STR_TO_BFP (buf, NULL);\n+}\n+#endif\n+                                                                                \n+#if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n+ || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n+ || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n+DFP_C_TYPE\n+BFP_TO_DFP (BFP_TYPE x)\n+{\n+  DFP_C_TYPE f;\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  DFP_INIT_ROUNDMODE (context.round);\n+\n+  /* Use a C library function to write the floating point value to a string.  */\n+  sprintf (buf, BFP_FMT, (BFP_VIA_TYPE) x);\n+\n+  /* Convert from the floating point string to a decimal* type.  */\n+  FROM_STRING (&s, buf, &context);\n+  IEEE_TO_HOST (s, &f);\n+\n+  if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n+    {\n+      /* decNumber exception flags we care about here.  */\n+      int ieee_flags;\n+      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Invalid_operation\n+\t\t      | DEC_IEEE_854_Overflow | DEC_IEEE_854_Underflow;\n+      dec_flags &= context.status;\n+      ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n+      if (ieee_flags != 0)\n+        DFP_HANDLE_EXCEPTIONS (ieee_flags);\n+    }\n+\n+  return f;\n+}\n+#endif\n+\n+#if defined (L_unord_sd) || defined (L_unord_dd) || defined (L_unord_td)\n+CMPtype\n+DFP_UNORD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  decNumber arg1, arg2;\n+  IEEE_TYPE a, b;\n+\n+  HOST_TO_IEEE (arg_a, &a);\n+  HOST_TO_IEEE (arg_b, &b);\n+  TO_INTERNAL (&a, &arg1);\n+  TO_INTERNAL (&b, &arg2);\n+  return (decNumberIsNaN (&arg1) || decNumberIsNaN (&arg2));\n+}\n+#endif /* L_unord_sd || L_unord_dd || L_unord_td */"}, {"sha": "45b79086bc928e2b102e3e8893dc99a037dca499", "filename": "libgcc/dfp-bit.h", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fdfp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d59352ba21a5cd10fd160e38f16cd975465b8/libgcc%2Fdfp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fdfp-bit.h?ref=2d8d59352ba21a5cd10fd160e38f16cd975465b8", "patch": "@@ -0,0 +1,626 @@\n+/* Header file for dfp-bit.c.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _DFPBIT_H\n+#define _DFPBIT_H\n+\n+#include <float.h>\n+#include <fenv.h>\n+#include <decRound.h>\n+#include <decExcept.h>\n+#include \"tconfig.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n+#endif\n+\n+/* We need to know the size of long double that the C library supports.\n+   Don't use LIBGCC2_HAS_XF_MODE or LIBGCC2_HAS_TF_MODE here because\n+   some targets set both of those.  */\n+\n+#define LONG_DOUBLE_HAS_XF_MODE \\\n+  (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n+\n+#define LONG_DOUBLE_HAS_TF_MODE \\\n+  (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n+\n+/* Depending on WIDTH, define a number of macros:\n+\n+   DFP_C_TYPE: type of the arguments to the libgcc functions;\n+\t(eg _Decimal32)\n+\n+   IEEE_TYPE: the corresponding (encoded) IEEE754 type;\n+\t(eg decimal32)\n+   \n+   TO_INTERNAL: the name of the decNumber function to convert an\n+   encoded value into the decNumber internal representation;\n+\n+   TO_ENCODED: the name of the decNumber function to convert an\n+   internally represented decNumber into the encoded\n+   representation.\n+\n+   FROM_STRING: the name of the decNumber function to read an\n+   encoded value from a string.\n+\n+   TO_STRING: the name of the decNumber function to write an\n+   encoded value to a string.  */\n+\n+#if WIDTH == 32\n+#define DFP_C_TYPE\t_Decimal32\n+#define IEEE_TYPE\tdecimal32\n+#define HOST_TO_IEEE\t__host_to_ieee_32\n+#define IEEE_TO_HOST\t__ieee_to_host_32\n+#define TO_INTERNAL\t__decimal32ToNumber\n+#define TO_ENCODED\t__decimal32FromNumber\n+#define FROM_STRING\t__decimal32FromString\n+#define TO_STRING\t__decimal32ToString\n+#elif WIDTH == 64\n+#define DFP_C_TYPE\t_Decimal64\n+#define IEEE_TYPE\tdecimal64\n+#define HOST_TO_IEEE\t__host_to_ieee_64\n+#define IEEE_TO_HOST\t__ieee_to_host_64\n+#define TO_INTERNAL\t__decimal64ToNumber\n+#define TO_ENCODED\t__decimal64FromNumber\n+#define FROM_STRING\t__decimal64FromString\n+#define TO_STRING\t__decimal64ToString\n+#elif WIDTH == 128\n+#define DFP_C_TYPE\t_Decimal128\n+#define IEEE_TYPE\tdecimal128\n+#define HOST_TO_IEEE\t__host_to_ieee_128\n+#define IEEE_TO_HOST\t__ieee_to_host_128\n+#define TO_INTERNAL\t__decimal128ToNumber\n+#define TO_ENCODED\t__decimal128FromNumber\n+#define FROM_STRING\t__decimal128FromString\n+#define TO_STRING\t__decimal128ToString\n+#else\n+#error invalid decimal float word width\n+#endif\n+\n+/* We define __DEC_EVAL_METHOD__ to 2, saying that we evaluate all\n+   operations and constants to the range and precision of the _Decimal128\n+   type.  Make it so.  */\n+#if WIDTH == 32\n+#define CONTEXT_INIT DEC_INIT_DECIMAL32\n+#elif WIDTH == 64\n+#define CONTEXT_INIT DEC_INIT_DECIMAL64\n+#elif WIDTH == 128\n+#define CONTEXT_INIT DEC_INIT_DECIMAL128\n+#endif\n+\n+#ifndef DFP_INIT_ROUNDMODE\n+#define DFP_INIT_ROUNDMODE(A) A = DEC_ROUND_HALF_EVEN\n+#endif\n+\n+#ifdef DFP_EXCEPTIONS_ENABLED\n+/* Return IEEE exception flags based on decNumber status flags.  */\n+#define DFP_IEEE_FLAGS(DEC_FLAGS) __extension__\t\t\t\\\n+({int _fe_flags = 0;\t\t\t\t\t\t\\\n+  if ((dec_flags & DEC_IEEE_854_Division_by_zero) != 0)\t\t\\\n+    _fe_flags |= FE_DIVBYZERO;\t\t\t\t\t\\\n+  if ((dec_flags & DEC_IEEE_854_Inexact) != 0)\t\t\t\\\n+    _fe_flags |= FE_INEXACT;\t\t\t\t\t\\\n+  if ((dec_flags & DEC_IEEE_854_Invalid_operation) != 0)\t\\\n+    _fe_flags |= FE_INVALID;\t\t\t\t\t\\\n+  if ((dec_flags & DEC_IEEE_854_Overflow) != 0)\t\t\t\\\n+    _fe_flags |= FE_OVERFLOW;\t\t\t\t\t\\\n+  if ((dec_flags & DEC_IEEE_854_Underflow) != 0)\t\t\\\n+    _fe_flags |= FE_UNDERFLOW;\t\t\t\t\t\\\n+  _fe_flags; })\n+#else\n+#define DFP_EXCEPTIONS_ENABLED 0\n+#define DFP_IEEE_FLAGS(A) 0\n+#define DFP_HANDLE_EXCEPTIONS(A) do {} while (0)\n+#endif\n+\n+/* Conversions between different decimal float types use WIDTH_TO to\n+   determine additional macros to define.  */\n+\n+#if defined (L_dd_to_sd) || defined (L_td_to_sd)\n+#define WIDTH_TO 32\n+#elif defined (L_sd_to_dd) || defined (L_td_to_dd)\n+#define WIDTH_TO 64\n+#elif defined (L_sd_to_td) || defined (L_dd_to_td)\n+#define WIDTH_TO 128\n+#endif\n+\n+/* If WIDTH_TO is defined, define additional macros:\n+\n+   DFP_C_TYPE_TO: type of the result of dfp to dfp conversion.\n+\n+   IEEE_TYPE_TO: the corresponding (encoded) IEEE754 type.\n+\n+   TO_ENCODED_TO: the name of the decNumber function to convert an\n+   internally represented decNumber into the encoded representation\n+   for the destination.  */\n+\n+#if WIDTH_TO == 32\n+#define DFP_C_TYPE_TO\t_Decimal32\n+#define IEEE_TYPE_TO\tdecimal32\n+#define TO_ENCODED_TO\t__decimal32FromNumber\n+#define IEEE_TO_HOST_TO __ieee_to_host_32\n+#elif WIDTH_TO == 64\n+#define DFP_C_TYPE_TO\t_Decimal64\n+#define IEEE_TYPE_TO\tdecimal64\n+#define TO_ENCODED_TO\t__decimal64FromNumber\n+#define IEEE_TO_HOST_TO __ieee_to_host_64\n+#elif WIDTH_TO == 128\n+#define DFP_C_TYPE_TO\t_Decimal128\n+#define IEEE_TYPE_TO\tdecimal128\n+#define TO_ENCODED_TO\t__decimal128FromNumber\n+#define IEEE_TO_HOST_TO __ieee_to_host_128\n+#endif\n+\n+/* Conversions between decimal float types and integral types use INT_KIND\n+   to determine the data type and C functions to use.  */\n+\n+#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si)  \\\n+   || defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td)\n+#define INT_KIND 1\n+#elif defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n+   || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td)\n+#define INT_KIND 2\n+#elif defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n+   || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td)\n+#define INT_KIND 3\n+#elif defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi) \\\n+   || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+#define INT_KIND 4\n+#endif\n+\n+/*  If INT_KIND is defined, define additional macros:\n+\n+    INT_TYPE: The integer data type.\n+\n+    INT_FMT: The format string for writing the integer to a string.\n+\n+    CAST_FOR_FMT: Cast variable of INT_KIND to C type for sprintf.\n+    This works for ILP32 and LP64, won't for other type size systems.\n+\n+    STR_TO_INT: The function to read the integer from a string.  */\n+\n+#if INT_KIND == 1\n+#define INT_TYPE SItype\n+#define INT_FMT \"%d\"\n+#define CAST_FOR_FMT(A) (int)A\n+#define STR_TO_INT strtol\n+#elif INT_KIND == 2\n+#define INT_TYPE DItype\n+#define INT_FMT \"%lld\"\n+#define CAST_FOR_FMT(A) (long long)A\n+#define STR_TO_INT strtoll\n+#elif INT_KIND == 3\n+#define INT_TYPE USItype\n+#define INT_FMT \"%u\"\n+#define CAST_FOR_FMT(A) (unsigned int)A\n+#define STR_TO_INT strtoul\n+#elif INT_KIND == 4\n+#define INT_TYPE UDItype\n+#define INT_FMT \"%llu\"\n+#define CAST_FOR_FMT(A) (unsigned long long)A\n+#define STR_TO_INT strtoull\n+#endif\n+\n+/* Conversions between decimal float types and binary float types use\n+   BFP_KIND to determine the data type and C functions to use.  */\n+\n+#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n+ || defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td)\n+#define BFP_KIND 1\n+#elif defined (L_sd_to_df) || defined (L_dd_to_df ) || defined (L_td_to_df) \\\n+ ||   defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td)\n+#define BFP_KIND 2\n+#elif defined (L_sd_to_xf) || defined (L_dd_to_xf ) || defined (L_td_to_xf) \\\n+ ||   defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)\n+#define BFP_KIND 3\n+#elif defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf) \\\n+ ||   defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)\n+#define BFP_KIND 4\n+#endif\n+\n+/*  If BFP_KIND is defined, define additional macros:\n+\n+    BFP_TYPE: The binary floating point data type.\n+\n+    BFP_FMT: The format string for writing the value to a string.\n+    The number of decimal digits printed is\n+       ceil (nbits / log2 (10.) + 1)\n+    as described in David Matula's CACM 19(3) 716-723 June 1968 paper.\n+\n+    BFP_VIA_TYPE: Type to which to cast a variable of BPF_TYPE for a\n+    call to sprintf.\n+    \n+    STR_TO_BFP: The function to read the value from a string.  */\n+\n+#if BFP_KIND == 1\n+#define BFP_TYPE SFtype\n+#define BFP_FMT \"%.9e\"\n+#define BFP_VIA_TYPE double\n+#define STR_TO_BFP strtof\n+\n+#elif BFP_KIND == 2\n+#define BFP_TYPE DFtype\n+#define BFP_FMT \"%.17e\"\n+#define BFP_VIA_TYPE double\n+#define STR_TO_BFP strtod\n+\n+#elif BFP_KIND == 3\n+#if LONG_DOUBLE_HAS_XF_MODE\n+#define BFP_TYPE XFtype\n+#define BFP_FMT \"%.21Le\"\n+#define BFP_VIA_TYPE long double\n+#define STR_TO_BFP strtold\n+#endif /* LONG_DOUBLE_HAS_XF_MODE */\n+\n+#elif BFP_KIND == 4\n+#if LONG_DOUBLE_HAS_TF_MODE\n+#define BFP_TYPE TFtype\n+#if LDBL_MANT_DIG == 106\n+#define BFP_FMT \"%.33Le\"\n+#elif LDBL_MANT_DIG == 113\n+#define BFP_FMT \"%.36Le\"\n+#else\n+#error \"unknown long double size, cannot define BFP_FMT\"\n+#endif /* LDBL_MANT_DIG */\n+#define STR_TO_BFP strtold\n+#define BFP_VIA_TYPE long double\n+#endif /* LONG_DOUBLE_HAS_TF_MODE */\n+\n+#endif /* BFP_KIND */\n+\n+#if WIDTH == 128 || WIDTH_TO == 128\n+#include \"decimal128.h\"\n+#include \"decQuad.h\"\n+#endif\n+#if WIDTH == 64 || WIDTH_TO == 64\n+#include \"decimal64.h\"\n+#include \"decDouble.h\"\n+#endif\n+#if WIDTH == 32 || WIDTH_TO == 32\n+#include \"decimal32.h\"\n+#include \"decSingle.h\"\n+#endif\n+#include \"decNumber.h\"\n+\n+/* Names of arithmetic functions.  */\n+\n+#if ENABLE_DECIMAL_BID_FORMAT\n+#define DPD_BID_NAME(DPD,BID) BID\n+#else\n+#define DPD_BID_NAME(DPD,BID) DPD\n+#endif\n+\n+#if WIDTH == 32\n+#define DFP_ADD\t\tDPD_BID_NAME(__dpd_addsd3,__bid_addsd3)\n+#define DFP_SUB\t\tDPD_BID_NAME(__dpd_subsd3,__bid_subsd3)\n+#define DFP_MULTIPLY\tDPD_BID_NAME(__dpd_mulsd3,__bid_mulsd3)\n+#define DFP_DIVIDE\tDPD_BID_NAME(__dpd_divsd3,__bid_divsd3)\n+#define DFP_EQ\t\tDPD_BID_NAME(__dpd_eqsd2,__bid_eqsd2)\n+#define DFP_NE\t\tDPD_BID_NAME(__dpd_nesd2,__bid_nesd2)\n+#define DFP_LT\t\tDPD_BID_NAME(__dpd_ltsd2,__bid_ltsd2)\n+#define DFP_GT\t\tDPD_BID_NAME(__dpd_gtsd2,__bid_gtsd2)\n+#define DFP_LE\t\tDPD_BID_NAME(__dpd_lesd2,__bid_lesd2)\n+#define DFP_GE\t\tDPD_BID_NAME(__dpd_gesd2,__bid_gesd2)\n+#define DFP_UNORD\tDPD_BID_NAME(__dpd_unordsd2,__bid_unordsd2)\n+#elif WIDTH == 64\n+#define DFP_ADD\t\tDPD_BID_NAME(__dpd_adddd3,__bid_adddd3)\n+#define DFP_SUB\t\tDPD_BID_NAME(__dpd_subdd3,__bid_subdd3)\n+#define DFP_MULTIPLY\tDPD_BID_NAME(__dpd_muldd3,__bid_muldd3)\n+#define DFP_DIVIDE\tDPD_BID_NAME(__dpd_divdd3,__bid_divdd3)\n+#define DFP_EQ\t\tDPD_BID_NAME(__dpd_eqdd2,__bid_eqdd2)\n+#define DFP_NE\t\tDPD_BID_NAME(__dpd_nedd2,__bid_nedd2)\n+#define DFP_LT\t\tDPD_BID_NAME(__dpd_ltdd2,__bid_ltdd2)\n+#define DFP_GT\t\tDPD_BID_NAME(__dpd_gtdd2,__bid_gtdd2)\n+#define DFP_LE\t\tDPD_BID_NAME(__dpd_ledd2,__bid_ledd2)\n+#define DFP_GE\t\tDPD_BID_NAME(__dpd_gedd2,__bid_gedd2)\n+#define DFP_UNORD\tDPD_BID_NAME(__dpd_unorddd2,__bid_unorddd2)\n+#elif WIDTH == 128\n+#define DFP_ADD\t\tDPD_BID_NAME(__dpd_addtd3,__bid_addtd3)\n+#define DFP_SUB\t\tDPD_BID_NAME(__dpd_subtd3,__bid_subtd3)\n+#define DFP_MULTIPLY\tDPD_BID_NAME(__dpd_multd3,__bid_multd3)\n+#define DFP_DIVIDE\tDPD_BID_NAME(__dpd_divtd3,__bid_divtd3)\n+#define DFP_EQ\t\tDPD_BID_NAME(__dpd_eqtd2,__bid_eqtd2)\n+#define DFP_NE\t\tDPD_BID_NAME(__dpd_netd2,__bid_netd2)\n+#define DFP_LT\t\tDPD_BID_NAME(__dpd_lttd2,__bid_lttd2)\n+#define DFP_GT\t\tDPD_BID_NAME(__dpd_gttd2,__bid_gttd2)\n+#define DFP_LE\t\tDPD_BID_NAME(__dpd_letd2,__bid_letd2)\n+#define DFP_GE\t\tDPD_BID_NAME(__dpd_getd2,__bid_getd2)\n+#define DFP_UNORD\tDPD_BID_NAME(__dpd_unordtd2,__bid_unordtd2)\n+#endif\n+\n+/* Names of decNumber functions for DPD arithmetic.  */\n+\n+#if WIDTH == 32\n+#define decFloat\t\tdecDouble\n+#define DFP_BINARY_OP\t\td32_binary_op\n+#define DFP_COMPARE_OP\t\td32_compare_op\n+#define DEC_FLOAT_ADD\t\tdecDoubleAdd\n+#define DEC_FLOAT_SUBTRACT\tdecDoubleSubtract\n+#define DEC_FLOAT_MULTIPLY\tdecDoubleMultiply\n+#define DEC_FLOAT_DIVIDE\tdecDoubleDivide\n+#define DEC_FLOAT_COMPARE\tdecDoubleCompare\n+#define DEC_FLOAT_IS_ZERO\tdecDoubleIsZero\n+#define DEC_FLOAT_IS_NAN\tdecDoubleIsNaN\n+#define DEC_FLOAT_IS_SIGNED\tdecDoubleIsSigned\n+#elif WIDTH == 64\n+#define DFP_BINARY_OP\t\tdnn_binary_op\n+#define DFP_COMPARE_OP\t\tdnn_compare_op\n+#define decFloat\t\tdecDouble\n+#define DEC_FLOAT_ADD\t\tdecDoubleAdd\n+#define DEC_FLOAT_SUBTRACT\tdecDoubleSubtract\n+#define DEC_FLOAT_MULTIPLY\tdecDoubleMultiply\n+#define DEC_FLOAT_DIVIDE\tdecDoubleDivide\n+#define DEC_FLOAT_COMPARE\tdecDoubleCompare\n+#define DEC_FLOAT_IS_ZERO\tdecDoubleIsZero\n+#define DEC_FLOAT_IS_NAN\tdecDoubleIsNaN\n+#define DEC_FLOAT_IS_SIGNED\tdecDoubleIsSigned\n+#elif WIDTH == 128\n+#define DFP_BINARY_OP\t\tdnn_binary_op\n+#define DFP_COMPARE_OP\t\tdnn_compare_op\n+#define decFloat\t\tdecQuad\n+#define DEC_FLOAT_ADD\t\tdecQuadAdd\n+#define DEC_FLOAT_SUBTRACT\tdecQuadSubtract\n+#define DEC_FLOAT_MULTIPLY\tdecQuadMultiply\n+#define DEC_FLOAT_DIVIDE\tdecQuadDivide\n+#define DEC_FLOAT_COMPARE\tdecQuadCompare\n+#define DEC_FLOAT_IS_ZERO\tdecQuadIsZero\n+#define DEC_FLOAT_IS_NAN\tdecQuadIsNaN\n+#define DEC_FLOAT_IS_SIGNED\tdecQuadIsSigned\n+#endif\n+\n+/* Names of functions to convert between different decimal float types.  */\n+\n+#if WIDTH == 32\n+#if WIDTH_TO == 64\n+#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsddd2,__bid_extendsddd2)\n+#elif WIDTH_TO == 128\n+#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsdtd2,__bid_extendsdtd2)\n+#endif\n+#elif WIDTH == 64\t\n+#if WIDTH_TO == 32\n+#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_truncddsd2,__bid_truncddsd2)\n+#elif WIDTH_TO == 128\n+#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_extendddtd2,__bid_extendddtd2)\n+#endif\n+#elif WIDTH == 128\n+#if WIDTH_TO == 32\n+#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctdsd2,__bid_trunctdsd2)\n+#elif WIDTH_TO == 64\n+#define DFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctddd2,__bid_trunctddd2)\n+#endif\n+#endif\n+\n+/* Names of functions to convert between decimal float and integers.  */\n+\n+#if WIDTH == 32\n+#if INT_KIND == 1\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsisd,__bid_floatsisd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixsdsi,__bid_fixsdsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToInt32\n+#elif INT_KIND == 2\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatdisd,__bid_floatdisd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixsddi,__bid_fixsddi)\n+#elif INT_KIND == 3\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssisd,__bid_floatunssisd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunssdsi,__bid_fixunssdsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromUInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToUInt32\n+#elif INT_KIND == 4\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsdisd,__bid_floatunsdisd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunssddi,__bid_fixunssddi)\n+#endif\n+#elif WIDTH == 64\n+#define decFloat\tdecDouble\n+#if INT_KIND == 1\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsidd,__bid_floatsidd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixddsi,__bid_fixddsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToInt32\n+#elif INT_KIND == 2\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatdidd,__bid_floatdidd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixdddi,__bid_fixdddi)\n+#elif INT_KIND == 3\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssidd,__bid_floatunssidd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunsddsi,__bid_fixunsddsi)\n+#define DEC_FLOAT_FROM_INT decDoubleFromUInt32\n+#define DEC_FLOAT_TO_INT   decDoubleToUInt32\n+#elif INT_KIND == 4\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsdidd,__bid_floatunsdidd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunsdddi,__bid_fixunsdddi)\n+#endif\n+#elif WIDTH == 128\n+#define decFloat\tdecQuad\n+#if INT_KIND == 1\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatsitd,__bid_floatsitd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixtdsi,__bid_fixtdsi)\n+#define DEC_FLOAT_FROM_INT decQuadFromInt32\n+#define DEC_FLOAT_TO_INT   decQuadToInt32\n+#elif INT_KIND == 2\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatditd,__bid_floatditd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixtddi,__bid_fixtddi)\n+#elif INT_KIND == 3\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunssitd,__bid_floatunssitd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunstdsi,__bid_fixunstdsi)\n+#define DEC_FLOAT_FROM_INT decQuadFromUInt32\n+#define DEC_FLOAT_TO_INT   decQuadToUInt32\n+#elif INT_KIND == 4\n+#define INT_TO_DFP\tDPD_BID_NAME(__dpd_floatunsditd,__bid_floatunsditd)\n+#define DFP_TO_INT\tDPD_BID_NAME(__dpd_fixunstddi,__bid_fixunstddi)\n+#endif\n+#endif\n+\n+/* Names of functions to convert between decimal float and binary float.  */\n+\n+#if WIDTH == 32\n+#if BFP_KIND == 1\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsfsd,__bid_extendsfsd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_truncsdsf,__bid_truncsdsf)\n+#elif BFP_KIND == 2\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncdfsd,__bid_truncdfsd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsddf,__bid_extendsddf)\n+#elif BFP_KIND == 3\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncxfsd,__bid_truncxfsd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsdxf,__bid_extendsdxf)\n+#elif BFP_KIND == 4\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctfsd,__bid_trunctfsd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsdtf,__bid_extendsdtf)\n+#endif /* BFP_KIND */\n+\n+#elif WIDTH == 64\n+#if BFP_KIND == 1\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsfdd,__bid_extendsfdd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_truncddsf,__bid_truncddsf)\n+#elif BFP_KIND == 2\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extenddfdd,__bid_extenddfdd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_truncdddf,__bid_truncdddf)\n+#elif BFP_KIND == 3\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncxfdd,__bid_truncxfdd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendddxf,__bid_extendddxf)\n+#elif BFP_KIND == 4\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctfdd,__bid_trunctfdd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendddtf,__bid_extendddtf)\n+#endif /* BFP_KIND */\n+\n+#elif WIDTH == 128\n+#if BFP_KIND == 1\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendsftd,__bid_extendsftd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdsf,__bid_trunctdsf)\n+#elif BFP_KIND == 2\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extenddftd,__bid_extenddftd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctddf,__bid_trunctddf)\n+#elif BFP_KIND == 3\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendxftd,__bid_extendxftd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdxf,__bid_trunctdxf)\n+#elif BFP_KIND == 4\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendtftd,__bid_extendtftd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdtf,__bid_trunctdtf)\n+#endif /* BFP_KIND */\n+\n+#endif /* WIDTH */\n+\n+/* Some handy typedefs.  */\n+\n+typedef float SFtype __attribute__ ((mode (SF)));\n+typedef float DFtype __attribute__ ((mode (DF)));\n+#if LONG_DOUBLE_HAS_XF_MODE\n+typedef float XFtype __attribute__ ((mode (XF)));\n+#endif /* LONG_DOUBLE_HAS_XF_MODE */\n+#if LONG_DOUBLE_HAS_TF_MODE\n+typedef float TFtype __attribute__ ((mode (TF)));\n+#endif /* LONG_DOUBLE_HAS_TF_MODE */\n+\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+\n+/* The type of the result of a decimal float comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+\n+typedef int CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+\n+/* Prototypes.  */\n+\n+#if defined (L_mul_sd) || defined (L_mul_dd) || defined (L_mul_td)\n+extern DFP_C_TYPE DFP_MULTIPLY (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_div_sd) || defined (L_div_dd) || defined (L_div_td)\n+extern DFP_C_TYPE DFP_DIVIDE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_addsub_sd) || defined (L_addsub_dd) || defined (L_addsub_td)\n+extern DFP_C_TYPE DFP_ADD (DFP_C_TYPE, DFP_C_TYPE);\n+extern DFP_C_TYPE DFP_SUB (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n+extern CMPtype DFP_EQ (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_ne_sd) || defined (L_ne_dd) || defined (L_ne_td)\n+extern CMPtype DFP_NE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_lt_sd) || defined (L_lt_dd) || defined (L_lt_td)\n+extern CMPtype DFP_LT (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_gt_sd) || defined (L_gt_dd) || defined (L_gt_td)\n+extern CMPtype DFP_GT (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_le_sd) || defined (L_le_dd) || defined (L_le_td)\n+extern CMPtype DFP_LE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_ge_sd) || defined (L_ge_dd) || defined (L_ge_td)\n+extern CMPtype DFP_GE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_unord_sd) || defined (L_unord_dd) || defined (L_unord_td)\n+extern CMPtype DFP_UNORD (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_sd_to_dd) || defined (L_sd_to_td) || defined (L_dd_to_sd) \\\n+ || defined (L_dd_to_td) || defined (L_td_to_sd) || defined (L_td_to_dd)\n+extern DFP_C_TYPE_TO DFP_TO_DFP (DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si) \\\n+ || defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n+ || defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n+ || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n+extern INT_TYPE DFP_TO_INT (DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td) \\\n+ || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n+ || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td) \\\n+ || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+extern DFP_C_TYPE INT_TO_DFP (INT_TYPE);\n+#endif\n+\n+#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n+ || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n+ || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n+extern BFP_TYPE DFP_TO_BFP (DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n+ || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n+ || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n+extern DFP_C_TYPE BFP_TO_DFP (BFP_TYPE);\n+#endif\n+\n+#endif /* _DFPBIT_H */"}]}