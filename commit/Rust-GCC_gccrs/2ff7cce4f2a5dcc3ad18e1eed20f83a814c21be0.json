{"sha": "2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZmN2NjZTRmMmE1ZGNjM2FkMThlMWVlZDIwZjgzYTgxNGMyMWJlMA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2003-12-17T00:25:24Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2003-12-17T00:25:24Z"}, "message": "re PR c/3347 (Too large bitfields should be errors)\n\n2003-12-17  Neil Booth  <neil@daikokuya.co.uk>\n            Joseph S. Myers  <jsm@polyomino.org.uk>\n\n\tPR c/3347\n\t* c-decl.c (enum_decl_context): Remove BITFIELD.\n\t(grokdeclarator): Take bit-field width as an input.\n\tPerform bit-field width validation with\n\tcheck_bitfield_type_and_width rather than waiting for\n\tfinish_struct.\n\t(groktypename, groktypename_in_parm_context, start_decl,\n\tpush_parm_decl, grokfield, start_function): Update calls to\n\tgrokdeclarator.\n\t(check_bitfield_type_and_width): New function.\n\t(finish_struct): Move bit-field validation to grokdeclarator\n\tand check_bitfield_type_and_width.\n\ntestsuite:\n\t* gcc.dg/bitfld-8.c: New test.\n\nFrom-SVN: r74725", "tree": {"sha": "4fbf0e973113ecb7c320c16aca6d53d949bafa53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fbf0e973113ecb7c320c16aca6d53d949bafa53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89843f8b85f09ac1b2e2ca617904722271a26835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89843f8b85f09ac1b2e2ca617904722271a26835", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89843f8b85f09ac1b2e2ca617904722271a26835"}], "stats": {"total": 210, "additions": 129, "deletions": 81}, "files": [{"sha": "2ccddfad2c46f5a8b74ceb6d590e6cdd06952275", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "patch": "@@ -1,3 +1,19 @@\n+2003-12-17  Neil Booth  <neil@daikokuya.co.uk>\n+            Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/3347\n+\t* c-decl.c (enum_decl_context): Remove BITFIELD.\n+\t(grokdeclarator): Take bit-field width as an input.\n+\tPerform bit-field width validation with\n+\tcheck_bitfield_type_and_width rather than waiting for\n+\tfinish_struct.\n+\t(groktypename, groktypename_in_parm_context, start_decl,\n+\tpush_parm_decl, grokfield, start_function): Update calls to\n+\tgrokdeclarator.\n+\t(check_bitfield_type_and_width): New function.\n+\t(finish_struct): Move bit-field validation to grokdeclarator\n+\tand check_bitfield_type_and_width.\n+\n 2003-12-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR bootstrap/13386"}, {"sha": "d07c83383543214b575510a136d3f8434a25dcdc", "filename": "gcc/c-decl.c", "status": "modified", "additions": 101, "deletions": 81, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "patch": "@@ -61,7 +61,6 @@ enum decl_context\n   FUNCDEF,\t\t\t/* Function definition */\n   PARM,\t\t\t\t/* Declaration of parm before function body */\n   FIELD,\t\t\t/* Declaration inside struct or union */\n-  BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME};\t\t\t/* Typename (inside cast or sizeof)  */\n \n \f\n@@ -315,7 +314,7 @@ static void bind_label (tree, tree, struct c_scope *);\n static void implicit_decl_warning (tree);\n static tree lookup_tag (enum tree_code, tree, int);\n static tree lookup_name_current_level (tree);\n-static tree grokdeclarator (tree, tree, enum decl_context, int);\n+static tree grokdeclarator (tree, tree, enum decl_context, int, tree *);\n static tree grokparms (tree, int);\n static void layout_array_type (tree);\n static void store_parm_decls_newstyle (void);\n@@ -325,6 +324,7 @@ static void c_expand_body_1 (tree, int);\n static tree any_external_decl (tree);\n static void record_external_decl (tree);\n static void warn_if_shadowing (tree, tree);\n+static void check_bitfield_type_and_width (tree *, tree *, const char *);\n static void clone_underlying_type (tree);\n static bool flexible_array_type_p (tree);\n static hashval_t link_hash_hash\t(const void *);\n@@ -2540,7 +2540,8 @@ groktypename (tree typename)\n \n   split_specs_attrs (TREE_PURPOSE (typename), &specs, &attrs);\n \n-  typename = grokdeclarator (TREE_VALUE (typename), specs, TYPENAME, 0);\n+  typename = grokdeclarator (TREE_VALUE (typename), specs, TYPENAME, 0,\n+\t\t\t     NULL);\n \n   /* Apply attributes.  */\n   decl_attributes (&typename, attrs, 0);\n@@ -2557,7 +2558,7 @@ groktypename_in_parm_context (tree typename)\n     return typename;\n   return grokdeclarator (TREE_VALUE (typename),\n \t\t\t TREE_PURPOSE (typename),\n-\t\t\t PARM, 0);\n+\t\t\t PARM, 0, NULL);\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -2587,7 +2588,7 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n     deprecated_state = DEPRECATED_SUPPRESS;\n \n   decl = grokdeclarator (declarator, declspecs,\n-\t\t\t NORMAL, initialized);\n+\t\t\t NORMAL, initialized, NULL);\n \n   deprecated_state = DEPRECATED_NORMAL;\n \n@@ -3023,7 +3024,8 @@ push_parm_decl (tree parm)\n   immediate_size_expand = 0;\n \n   decl = grokdeclarator (TREE_VALUE (TREE_PURPOSE (parm)),\n-\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)), PARM, 0);\n+\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)),\n+\t\t\t PARM, 0, NULL);\n   decl_attributes (&decl, TREE_VALUE (parm), 0);\n \n   decl = pushdecl (decl);\n@@ -3218,6 +3220,80 @@ flexible_array_type_p (tree type)\n   }\n }\n \f\n+/* Performs sanity checks on the TYPE and WIDTH of the bit-field NAME,\n+   replacing with appropriate values if they are invalid.  */\n+static void\n+check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n+{\n+  tree type_mv;\n+  unsigned int max_width;\n+  unsigned HOST_WIDE_INT w;\n+  const char *name = orig_name ? orig_name: _(\"<anonymous>\");\n+\n+  /* Necessary?  */\n+  STRIP_NOPS (*width);\n+\n+  /* Detect and ignore out of range field width and process valid\n+     field widths.  */\n+  if (TREE_CODE (*width) != INTEGER_CST)\n+    {\n+      error (\"bit-field `%s' width not an integer constant\", name);\n+      *width = integer_one_node;\n+    }\n+  else\n+    {\n+      constant_expression_warning (*width);\n+      if (tree_int_cst_sgn (*width) < 0)\n+\t{\n+\t  error (\"negative width in bit-field `%s'\", name);\n+\t  *width = integer_one_node;\n+\t}\n+      else if (integer_zerop (*width) && orig_name)\n+\t{\n+\t  error (\"zero width for bit-field `%s'\", name);\n+\t  *width = integer_one_node;\n+\t}\n+    }\n+\n+  /* Detect invalid bit-field type.  */\n+  if (TREE_CODE (*type) != INTEGER_TYPE\n+      && TREE_CODE (*type) != BOOLEAN_TYPE\n+      && TREE_CODE (*type) != ENUMERAL_TYPE)\n+    {\n+      error (\"bit-field `%s' has invalid type\", name);\n+      *type = unsigned_type_node;\n+    }\n+\n+  type_mv = TYPE_MAIN_VARIANT (*type);\n+  if (pedantic\n+      && type_mv != integer_type_node\n+      && type_mv != unsigned_type_node\n+      && type_mv != boolean_type_node\n+      /* Accept an enum that's equivalent to int or unsigned int.  */\n+      && (TREE_CODE (*type) != ENUMERAL_TYPE\n+\t  || TYPE_PRECISION (*type) != TYPE_PRECISION (integer_type_node)))\n+    pedwarn (\"type of bit-field `%s' is a GCC extension\", name);\n+\n+  if (type_mv == boolean_type_node)\n+    max_width = CHAR_TYPE_SIZE;\n+  else\n+    max_width = TYPE_PRECISION (*type);\n+\n+  if (0 < compare_tree_int (*width, max_width))\n+    {\n+      error (\"width of `%s' exceeds its type\", name);\n+      w = max_width;\n+      *width = build_int_2 (w, 0);\n+    }\n+  else\n+    w = tree_low_cst (*width, 1);\n+\n+  if (TREE_CODE (*type) == ENUMERAL_TYPE\n+      && (w < min_precision (TYPE_MIN_VALUE (*type), TREE_UNSIGNED (*type))\n+\t  || w < min_precision (TYPE_MAX_VALUE (*type), TREE_UNSIGNED (*type))))\n+    warning (\"`%s' is narrower than values of its type\", name);\n+}\n+\f\n /* Given declspecs and a declarator,\n    determine the name and type of the object declared\n    and construct a ..._DECL node for it.\n@@ -3237,8 +3313,9 @@ flexible_array_type_p (tree type)\n      TYPENAME if for a typename (in a cast or sizeof).\n       Don't make a DECL node; just return the ..._TYPE node.\n      FIELD for a struct or union field; make a FIELD_DECL.\n-     BITFIELD for a field with specified width.\n    INITIALIZED is 1 if the decl has an initializer.\n+   WIDTH is non-NULL for bit-fields, and is a pointer to an INTEGER_CST node\n+   representing the width of the bit-field.\n \n    In the TYPENAME case, DECLARATOR is really an absolute declarator.\n    It may also be so in the PARM case, for a prototype where the\n@@ -3249,7 +3326,7 @@ flexible_array_type_p (tree type)\n \n static tree\n grokdeclarator (tree declarator, tree declspecs,\n-\t\tenum decl_context decl_context, int initialized)\n+\t\tenum decl_context decl_context, int initialized, tree *width)\n {\n   int specbits = 0;\n   tree spec;\n@@ -3264,19 +3341,16 @@ grokdeclarator (tree declarator, tree declspecs,\n   int explicit_char = 0;\n   int defaulted_int = 0;\n   tree typedef_decl = 0;\n-  const char *name;\n+  const char *name, *orig_name;\n   tree typedef_type = 0;\n   int funcdef_flag = 0;\n   enum tree_code innermost_code = ERROR_MARK;\n-  int bitfield = 0;\n   int size_varies = 0;\n   tree decl_attr = NULL_TREE;\n   tree array_ptr_quals = NULL_TREE;\n   int array_parm_static = 0;\n   tree returned_attrs = NULL_TREE;\n-\n-  if (decl_context == BITFIELD)\n-    bitfield = 1, decl_context = FIELD;\n+  bool bitfield = width != NULL;\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n@@ -3309,6 +3383,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \tdefault:\n \t  abort ();\n \t}\n+    orig_name = name;\n     if (name == 0)\n       name = \"type name\";\n   }\n@@ -3541,7 +3616,7 @@ grokdeclarator (tree declarator, tree declspecs,\n     }\n \n   /* Decide whether an integer type is signed or not.\n-     Optionally treat bitfields as signed by default.  */\n+     Optionally treat bit-fields as signed by default.  */\n   if (specbits & 1 << (int) RID_UNSIGNED\n       || (bitfield && ! flag_signed_bitfields\n \t  && (explicit_int || defaulted_int || explicit_char\n@@ -3613,6 +3688,10 @@ grokdeclarator (tree declarator, tree declspecs,\n \t}\n     }\n \n+  /* Check the type and width of a bit-field.  */\n+  if (bitfield)\n+    check_bitfield_type_and_width (&type, width, orig_name);\n+\n   /* Figure out the type qualifiers for the declaration.  There are\n      two ways a declaration can become qualified.  One is something\n      like `const int i' where the `const' is explicit.  Another is\n@@ -4769,7 +4848,7 @@ start_struct (enum tree_code code, tree name)\n \n /* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n    of a structure component, returning a FIELD_DECL node.\n-   WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.\n+   WIDTH is non-NULL for bit-fields only, and is an INTEGER_CST node.\n \n    This is done during the parsing of the struct declaration.\n    The FIELD_DECL nodes are chained together and the lot of them\n@@ -4824,7 +4903,8 @@ grokfield (tree declarator, tree declspecs, tree width)\n \t}\n     }\n \n-  value = grokdeclarator (declarator, declspecs, width ? BITFIELD : FIELD, 0);\n+  value = grokdeclarator (declarator, declspecs, FIELD, 0,\n+\t\t\t  width ? &width : NULL);\n \n   finish_decl (value, NULL_TREE, NULL_TREE);\n   DECL_INITIAL (value) = width;\n@@ -4971,72 +5051,12 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \terror (\"nested redefinition of `%s'\",\n \t       IDENTIFIER_POINTER (TYPE_NAME (t)));\n \n-      /* Detect invalid bit-field size.  */\n-      if (DECL_INITIAL (x))\n-\tSTRIP_NOPS (DECL_INITIAL (x));\n       if (DECL_INITIAL (x))\n \t{\n-\t  if (TREE_CODE (DECL_INITIAL (x)) == INTEGER_CST)\n-\t    constant_expression_warning (DECL_INITIAL (x));\n-\t  else\n-\t    {\n-\t      error (\"%Jbit-field '%D' width not an integer constant\", x, x);\n-\t      DECL_INITIAL (x) = NULL;\n-\t    }\n-\t}\n-\n-      /* Detect invalid bit-field type.  */\n-      if (DECL_INITIAL (x)\n-\t  && TREE_CODE (TREE_TYPE (x)) != INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE\n-\t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n-\t{\n-\t  error (\"%Jbit-field '%D' has invalid type\", x, x);\n-\t  DECL_INITIAL (x) = NULL;\n-\t}\n-\n-      if (DECL_INITIAL (x) && pedantic\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != integer_type_node\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != unsigned_type_node\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (x)) != boolean_type_node\n-\t  /* Accept an enum that's equivalent to int or unsigned int.  */\n-\t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t       && (TYPE_PRECISION (TREE_TYPE (x))\n-\t\t   == TYPE_PRECISION (integer_type_node))))\n-\tpedwarn (\"%Jbit-field '%D' type invalid in ISO C\", x, x);\n-\n-      /* Detect and ignore out of range field width and process valid\n-\t field widths.  */\n-      if (DECL_INITIAL (x))\n-\t{\n-\t  int max_width\n-\t    = (TYPE_MAIN_VARIANT (TREE_TYPE (x)) == boolean_type_node\n-\t       ? CHAR_TYPE_SIZE : TYPE_PRECISION (TREE_TYPE (x)));\n-\n-\t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n-\t    error (\"%Jnegative width in bit-field '%D'\", x, x);\n-\t  else if (0 < compare_tree_int (DECL_INITIAL (x), max_width))\n-\t    pedwarn (\"%Jwidth of '%D' exceeds its type\", x, x);\n-\t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n-\t    error (\"%Jzero width for bit-field '%D'\", x, x);\n-\t  else\n-\t    {\n-\t      /* The test above has assured us that TREE_INT_CST_HIGH is 0.  */\n-\t      unsigned HOST_WIDE_INT width\n-\t\t= tree_low_cst (DECL_INITIAL (x), 1);\n-\n-\t      if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t\t  && (width < min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t     TREE_UNSIGNED (TREE_TYPE (x)))\n-\t\t      || (width\n-\t\t\t  < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))))))\n-\t\twarning (\"%J'%D' is narrower than values of its type\", x, x);\n-\n-\t      DECL_SIZE (x) = bitsize_int (width);\n-\t      DECL_BIT_FIELD (x) = 1;\n-\t      SET_DECL_C_BIT_FIELD (x);\n-\t    }\n+\t  unsigned HOST_WIDE_INT width = tree_low_cst (DECL_INITIAL (x), 1);\n+\t  DECL_SIZE (x) = bitsize_int (width);\n+\t  DECL_BIT_FIELD (x) = 1;\n+\t  SET_DECL_C_BIT_FIELD (x);\n \t}\n \n       DECL_INITIAL (x) = 0;\n@@ -5461,7 +5481,7 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   /* Don't expand any sizes in the return type of the function.  */\n   immediate_size_expand = 0;\n \n-  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1);\n+  decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, NULL);\n \n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */"}, {"sha": "a0aa37f75dcd63980890b538141d38a5ffd004d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "patch": "@@ -1,3 +1,8 @@\n+2003-12-17  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\tPR c/3347\n+\t* gcc.dg/bitfld-8.c: New test.\n+\n 2003-12-16  James Lemke  <jim@wasabisystems.com>\n \n \t* gcc.dg/arm-scd42-[123].c: New tests."}, {"sha": "937fb64f5f4a54c9b5ec4d822842c95d81621b13", "filename": "gcc/testsuite/gcc.dg/bitfld-8.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbitfld-8.c?ref=2ff7cce4f2a5dcc3ad18e1eed20f83a814c21be0", "patch": "@@ -0,0 +1,7 @@\n+/* Test that too wide bit-fields are hard errors.  PR c/3347.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk>, from PR c/3347 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+struct { int i : 1999; } x; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+/* { dg-error \"width\" \"bit-field too wide\" { target *-*-* } 6 } */"}]}