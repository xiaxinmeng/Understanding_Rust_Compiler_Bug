{"sha": "429ee11aa39ba700510d789b446d74b65e202754", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5ZWUxMWFhMzliYTcwMDUxMGQ3ODliNDQ2ZDc0YjY1ZTIwMjc1NA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-09-23T11:26:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-09-23T11:26:45Z"}, "message": "Fix semantics of Filesystem TS directory iterators\n\n[class.directory_iterator] p4 and [directory_iterator.members] p4\nrequire that only the default constructor and ignored permission denied\nerrors can create the end iterator.\n\n\t* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Remove _GLIBCXX_\n\tprefix from HAVE_STRUCT_DIRENT_D_TYPE.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* include/experimental/fs_dir.h (operator==, operator==):\n\tUse owner_before instead of pointer equality.\n\t(directory_iterator(std::shared_ptr<_Dir>, error_code*)): Remove.\n\t* src/filesystem/dir.cc (ErrorCode): Remove.\n\t(_Dir::advance): Change ErrorCode parameter to error_code*, add\n\tdirectory_options parameter and check it on error.\n\t(opendir): Rename to open_dir to avoid clashing with macro. Change\n\tErrorCode parameter to error_code*.\n\t(make_shared_dir): Remove.\n\t(native_readdir) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Don't set errno.\n\t(directory_iterator(std::shared_ptr<_Dir>, error_code*)): Remove.\n\t(directory_iterator(const path&, directory_options, error_code*)):\n\tPass options to _Dir::advance and create non-end iterator on error.\n\t(recursive_directory_iterator(const path&, directory_options,\n\terror_code*)): Clear error_code on ignored error, create non-end\n\titerator otherwise.\n\t(recursive_directory_iterator::increment): Pass _M_options to\n\t_Dir::advance.\n\t(recursive_directory_iterator::pop): Likewise.\n\t* testsuite/experimental/filesystem/iterators/directory_iterator.cc:\n\tNew.\n\t* testsuite/experimental/filesystem/iterators/\n\trecursive_directory_iterator.cc: New.\n\nFrom-SVN: r228042", "tree": {"sha": "332f8455f9310ad1295e8550bf2f7b2eca7520ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/332f8455f9310ad1295e8550bf2f7b2eca7520ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/429ee11aa39ba700510d789b446d74b65e202754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ee11aa39ba700510d789b446d74b65e202754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429ee11aa39ba700510d789b446d74b65e202754", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ee11aa39ba700510d789b446d74b65e202754/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "366703118cd68810da3cc24ad2f9198d2116fa09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366703118cd68810da3cc24ad2f9198d2116fa09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366703118cd68810da3cc24ad2f9198d2116fa09"}], "stats": {"total": 361, "additions": 286, "deletions": 75}, "files": [{"sha": "578c5510b01c0d9e14c536437b226e6b7ac68e66", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -1,5 +1,33 @@\n 2015-09-23  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Remove _GLIBCXX_\n+\tprefix from HAVE_STRUCT_DIRENT_D_TYPE.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* include/experimental/fs_dir.h (operator==, operator==):\n+\tUse owner_before instead of pointer equality.\n+\t(directory_iterator(std::shared_ptr<_Dir>, error_code*)): Remove.\n+\t* src/filesystem/dir.cc (ErrorCode): Remove.\n+\t(_Dir::advance): Change ErrorCode parameter to error_code*, add\n+\tdirectory_options parameter and check it on error.\n+\t(opendir): Rename to open_dir to avoid clashing with macro. Change\n+\tErrorCode parameter to error_code*.\n+\t(make_shared_dir): Remove.\n+\t(native_readdir) [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Don't set errno.\n+\t(directory_iterator(std::shared_ptr<_Dir>, error_code*)): Remove.\n+\t(directory_iterator(const path&, directory_options, error_code*)):\n+\tPass options to _Dir::advance and create non-end iterator on error.\n+\t(recursive_directory_iterator(const path&, directory_options,\n+\terror_code*)): Clear error_code on ignored error, create non-end\n+\titerator otherwise.\n+\t(recursive_directory_iterator::increment): Pass _M_options to\n+\t_Dir::advance.\n+\t(recursive_directory_iterator::pop): Likewise.\n+\t* testsuite/experimental/filesystem/iterators/directory_iterator.cc:\n+\tNew.\n+\t* testsuite/experimental/filesystem/iterators/\n+\trecursive_directory_iterator.cc: New.\n+\n \t* src/filesystem/ops.cc (is_dot, is_dotdot): Define new helpers.\n \t(create_directories): Fix error handling.\n \t* testsuite/experimental/filesystem/operations/create_directories.cc:"}, {"sha": "4b031f7117f6b193271e46474640abac8e7172b8", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -3940,7 +3940,7 @@ dnl\n       [glibcxx_cv_dirent_d_type=no])\n   ])\n   if test $glibcxx_cv_dirent_d_type = yes; then\n-    AC_DEFINE(_GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE, 1, [Define to 1 if `d_type' is a member of `struct dirent'.])\n+    AC_DEFINE(HAVE_STRUCT_DIRENT_D_TYPE, 1, [Define to 1 if `d_type' is a member of `struct dirent'.])\n   fi\n   AC_MSG_RESULT($glibcxx_cv_dirent_d_type)\n dnl"}, {"sha": "8ae1c5bfe6950e52f7e5b46bc6d443c355120213", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -378,6 +378,9 @@\n /* Define to 1 if you have the `strtold' function. */\n #undef HAVE_STRTOLD\n \n+/* Define to 1 if `d_type' is a member of `struct dirent'. */\n+#undef HAVE_STRUCT_DIRENT_D_TYPE\n+\n /* Define if strxfrm_l is available in <string.h>. */\n #undef HAVE_STRXFRM_L\n \n@@ -741,9 +744,6 @@\n /* Define if gthreads library is available. */\n #undef _GLIBCXX_HAS_GTHREADS\n \n-/* Define to 1 if `d_type' is a member of `struct dirent'. */\n-#undef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE\n-\n /* Define to 1 if a full hosted library is built, or 0 if freestanding. */\n #undef _GLIBCXX_HOSTED\n "}, {"sha": "73d45b1a680cd40e617acdf072b8fdc68dd4dd84", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -79165,7 +79165,7 @@ fi\n \n   if test $glibcxx_cv_dirent_d_type = yes; then\n \n-$as_echo \"#define _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE 1\" >>confdefs.h\n+$as_echo \"#define HAVE_STRUCT_DIRENT_D_TYPE 1\" >>confdefs.h\n \n   fi\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_dirent_d_type\" >&5"}, {"sha": "0c5253fb62d0d89c5d96a700b44910ffb591bcac", "filename": "libstdc++-v3/include/experimental/fs_dir.h", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_dir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_dir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ffs_dir.h?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -201,14 +201,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       return __tmp;\n     }\n \n-    friend bool\n-    operator==(const directory_iterator& __lhs,\n-               const directory_iterator& __rhs)\n-    { return __lhs._M_dir == __rhs._M_dir; }\n-\n   private:\n     directory_iterator(const path&, directory_options, error_code*);\n-    directory_iterator(std::shared_ptr<_Dir>, error_code*);\n+\n+    friend bool\n+    operator==(const directory_iterator& __lhs,\n+               const directory_iterator& __rhs);\n \n     friend class recursive_directory_iterator;\n \n@@ -221,6 +219,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   inline directory_iterator\n   end(directory_iterator) { return directory_iterator(); }\n \n+  inline bool\n+  operator==(const directory_iterator& __lhs, const directory_iterator& __rhs)\n+  {\n+    return !__rhs._M_dir.owner_before(__lhs._M_dir)\n+      && !__lhs._M_dir.owner_before(__rhs._M_dir);\n+  }\n+\n   inline bool\n   operator!=(const directory_iterator& __lhs, const directory_iterator& __rhs)\n   { return !(__lhs == __rhs); }\n@@ -287,14 +292,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n     void disable_recursion_pending() { _M_pending = false; }\n \n-    friend bool\n-    operator==(const recursive_directory_iterator& __lhs,\n-               const recursive_directory_iterator& __rhs)\n-    { return __lhs._M_dirs == __rhs._M_dirs; }\n-\n   private:\n     recursive_directory_iterator(const path&, directory_options, error_code*);\n \n+    friend bool\n+    operator==(const recursive_directory_iterator& __lhs,\n+               const recursive_directory_iterator& __rhs);\n+\n     struct _Dir_stack;\n     std::shared_ptr<_Dir_stack> _M_dirs;\n     directory_options _M_options;\n@@ -307,6 +311,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   inline recursive_directory_iterator\n   end(recursive_directory_iterator) { return recursive_directory_iterator(); }\n \n+  inline bool\n+  operator==(const recursive_directory_iterator& __lhs,\n+             const recursive_directory_iterator& __rhs)\n+  {\n+    return !__rhs._M_dirs.owner_before(__lhs._M_dirs)\n+      && !__lhs._M_dirs.owner_before(__rhs._M_dirs);\n+  }\n+\n   inline bool\n   operator!=(const recursive_directory_iterator& __lhs,\n              const recursive_directory_iterator& __rhs)"}, {"sha": "bce751c3fb1d843e6eb474dc93278c3e7fb49065", "filename": "libstdc++-v3/src/filesystem/dir.cc", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -43,28 +43,6 @@\n \n namespace fs = std::experimental::filesystem;\n \n-namespace\n-{\n-  struct ErrorCode\n-  {\n-    ErrorCode(std::error_code* p) : ec(p) { }\n-\n-    ErrorCode(ErrorCode&& e) : ec(std::exchange(e.ec, nullptr)) { }\n-\n-    ~ErrorCode() { if (ec) ec->clear(); }\n-\n-    void assign(int err)\n-    {\n-      ec->assign(err, std::generic_category());\n-      ec = nullptr;\n-    }\n-\n-    explicit operator bool() { return ec != nullptr; }\n-\n-    std::error_code* ec;\n-  };\n-}\n-\n struct fs::_Dir\n {\n   _Dir() : dirp(nullptr) { }\n@@ -80,7 +58,7 @@ struct fs::_Dir\n \n   ~_Dir() { if (dirp) ::closedir(dirp); }\n \n-  bool advance(ErrorCode);\n+  bool advance(std::error_code*, directory_options = directory_options::none);\n \n   DIR*\t\t\tdirp;\n   fs::path\t\tpath;\n@@ -96,9 +74,14 @@ namespace\n       return (obj & bits) != Bitmask::none;\n     }\n \n+  // Returns {dirp, p} on success, {nullptr, p} on error.\n+  // If an ignored EACCES error occurs returns {}.\n   fs::_Dir\n-  opendir(const fs::path& p, fs::directory_options options, ErrorCode ec)\n+  open_dir(const fs::path& p, fs::directory_options options, std::error_code* ec)\n   {\n+    if (ec)\n+      ec->clear();\n+\n     if (DIR* dirp = ::opendir(p.c_str()))\n       return {dirp, p};\n \n@@ -112,16 +95,8 @@ namespace\n             \"directory iterator cannot open directory\", p,\n             std::error_code(err, std::generic_category())));\n \n-    ec.assign(err);\n-    return {};\n-  }\n-\n-  inline std::shared_ptr<fs::_Dir>\n-  make_shared_dir(fs::_Dir&& dir)\n-  {\n-    if (dir.dirp)\n-      return std::make_shared<fs::_Dir>(std::move(dir));\n-    return {};\n+    ec->assign(err, std::generic_category());\n+    return {nullptr, p};\n   }\n \n   inline fs::file_type\n@@ -158,7 +133,6 @@ namespace\n   native_readdir(DIR* dirp, ::dirent*& entryp)\n   {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-    errno = 0;\n     if ((entryp = ::readdir(dirp)))\n       return 0;\n     return errno;\n@@ -168,25 +142,34 @@ namespace\n   }\n }\n \n+// Returns false when the end of the directory entries is reached.\n+// Reports errors by setting ec or throwing.\n bool\n-fs::_Dir::advance(ErrorCode ec)\n+fs::_Dir::advance(error_code* ec, directory_options options)\n {\n+  if (ec)\n+    ec->clear();\n+\n   ::dirent ent;\n   ::dirent* result = &ent;\n   if (int err = native_readdir(dirp, result))\n     {\n+      if (err == EACCES\n+        && is_set(options, directory_options::skip_permission_denied))\n+\treturn false;\n+\n       if (!ec)\n \t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t      \"directory iterator cannot advance\",\n \t      std::error_code(err, std::generic_category())));\n-      ec.assign(err);\n+      ec->assign(err, std::generic_category());\n       return true;\n     }\n   else if (result != nullptr)\n     {\n       // skip past dot and dot-dot\n       if (!strcmp(ent.d_name, \".\") || !strcmp(ent.d_name, \"..\"))\n-\treturn advance(std::move(ec));\n+\treturn advance(ec, options);\n       entry = fs::directory_entry{path / ent.d_name};\n       type = get_file_type(ent);\n       return true;\n@@ -202,15 +185,21 @@ fs::_Dir::advance(ErrorCode ec)\n \n fs::directory_iterator::\n directory_iterator(const path& p, directory_options options, error_code* ec)\n-: directory_iterator(make_shared_dir(opendir(p, options, ec)), ec)\n-{ }\n-\n-fs::directory_iterator::\n-directory_iterator(std::shared_ptr<_Dir> dir, error_code* ec)\n-: _M_dir(std::move(dir))\n {\n-  if (_M_dir && !_M_dir->advance(ec))\n-    _M_dir.reset();\n+  _Dir dir = open_dir(p, options, ec);\n+\n+  if (dir.dirp)\n+    {\n+      auto sp = std::make_shared<fs::_Dir>(std::move(dir));\n+      if (sp->advance(ec, options))\n+\t_M_dir.swap(sp);\n+    }\n+  else if (!dir.path.empty())\n+    {\n+      // An error occurred, we need a non-empty shared_ptr so that *this will\n+      // not compare equal to the end iterator.\n+      _M_dir.reset(static_cast<fs::_Dir*>(nullptr));\n+    }\n }\n \n const fs::directory_entry&\n@@ -257,7 +246,7 @@ struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>\n \n fs::recursive_directory_iterator::\n recursive_directory_iterator(const path& p, directory_options options,\n-                                 error_code* ec)\n+                             error_code* ec)\n : _M_options(options), _M_pending(true)\n {\n   if (DIR* dirp = ::opendir(p.c_str()))\n@@ -272,14 +261,22 @@ recursive_directory_iterator(const path& p, directory_options options,\n       const int err = errno;\n       if (err == EACCES\n \t  && is_set(options, fs::directory_options::skip_permission_denied))\n-\treturn;\n+\t{\n+\t  if (ec)\n+\t    ec->clear();\n+\t  return;\n+\t}\n \n       if (!ec)\n \t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t      \"recursive directory iterator cannot open directory\", p,\n \t      std::error_code(err, std::generic_category())));\n \n       ec->assign(err, std::generic_category());\n+\n+      // An error occurred, we need a non-empty shared_ptr so that *this will\n+      // not compare equal to the end iterator.\n+      _M_dirs.reset(static_cast<_Dir_stack*>(nullptr));\n     }\n }\n \n@@ -358,21 +355,14 @@ fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n \n   if (std::exchange(_M_pending, true) && recurse(top, _M_options, ec))\n     {\n-      _Dir dir = opendir(top.entry.path(), _M_options, &ec);\n-      if (ec.value())\n+      _Dir dir = open_dir(top.entry.path(), _M_options, &ec);\n+      if (ec)\n \treturn *this;\n       if (dir.dirp)\n-\t{\n \t  _M_dirs->push(std::move(dir));\n-\t  if (!_M_dirs->top().advance(&ec)) // dir is empty\n-\t    pop();\n-\t  return *this;\n-\t}\n-      // else skip permission denied and continue in parent dir\n     }\n \n-  ec.clear();\n-  while (!_M_dirs->top().advance(&ec) && !ec.value())\n+  while (!_M_dirs->top().advance(&ec, _M_options) && !ec)\n     {\n       _M_dirs->pop();\n       if (_M_dirs->empty())\n@@ -399,5 +389,5 @@ fs::recursive_directory_iterator::pop()\n \t_M_dirs.reset();\n \treturn;\n       }\n-  } while (!_M_dirs->top().advance(nullptr));\n+  } while (!_M_dirs->top().advance(nullptr, _M_options));\n }"}, {"sha": "56b808d3252575da54fae7ae279e8ee2592ec96b", "filename": "libstdc++-v3/testsuite/experimental/filesystem/iterators/directory_iterator.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Fdirectory_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Fdirectory_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Fdirectory_iterator.cc?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+  std::error_code ec;\n+\n+  // Test non-existent path.\n+  const auto p = __gnu_test::nonexistent_path();\n+  fs::directory_iterator iter(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter != fs::directory_iterator() );\n+\n+  // Test empty directory.\n+  create_directory(p, fs::current_path(), ec);\n+  VERIFY( !ec );\n+  iter = fs::directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == fs::directory_iterator() );\n+\n+  // Test non-empty directory.\n+  create_directory_symlink(p, p / \"l\", ec);\n+  VERIFY( !ec );\n+  iter = fs::directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != fs::directory_iterator() );\n+  VERIFY( iter->path() == p/\"l\" );\n+  ++iter;\n+  VERIFY( iter == fs::directory_iterator() );\n+\n+  // Test inaccessible directory.\n+  permissions(p, fs::perms::none, ec);\n+  VERIFY( !ec );\n+  iter = fs::directory_iterator(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter != fs::directory_iterator() );\n+\n+  // Test inaccessible directory, skipping permission denied.\n+  const auto opts = fs::directory_options::skip_permission_denied;\n+  iter = fs::directory_iterator(p, opts, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == fs::directory_iterator() );\n+\n+  permissions(p, fs::perms::owner_all, ec);\n+  remove_all(p, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "9424c80ab833af8366626dab9eb8bdacc19ad185", "filename": "libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Frecursive_directory_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ee11aa39ba700510d789b446d74b65e202754/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Frecursive_directory_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fiterators%2Frecursive_directory_iterator.cc?ref=429ee11aa39ba700510d789b446d74b65e202754", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11 -lstdc++fs\" }\n+// { dg-require-filesystem-ts \"\" }\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+namespace fs = std::experimental::filesystem;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = false;\n+  std::error_code ec;\n+\n+  // Test non-existent path.\n+  const auto p = __gnu_test::nonexistent_path();\n+  fs::recursive_directory_iterator iter(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter != fs::recursive_directory_iterator() );\n+\n+  // Test empty directory.\n+  create_directory(p, fs::current_path(), ec);\n+  VERIFY( !ec );\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == fs::recursive_directory_iterator() );\n+\n+  // Test non-empty directory.\n+  create_directories(p / \"d1/d2\");\n+  VERIFY( !ec );\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != fs::recursive_directory_iterator() );\n+  VERIFY( iter->path() == p/\"d1\" );\n+  ++iter;\n+  VERIFY( iter->path() == p/\"d1/d2\" );\n+  ++iter;\n+  VERIFY( iter == fs::recursive_directory_iterator() );\n+\n+  // Test inaccessible directory.\n+  permissions(p, fs::perms::none, ec);\n+  VERIFY( !ec );\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( ec );\n+  VERIFY( iter != fs::recursive_directory_iterator() );\n+\n+  // Test inaccessible directory, skipping permission denied.\n+  const auto opts = fs::directory_options::skip_permission_denied;\n+  iter = fs::recursive_directory_iterator(p, opts, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter == fs::recursive_directory_iterator() );\n+\n+  // Test inaccessible sub-directory.\n+  permissions(p, fs::perms::owner_all, ec);\n+  VERIFY( !ec );\n+  permissions(p/\"d1/d2\", fs::perms::none, ec);\n+  VERIFY( !ec );\n+  iter = fs::recursive_directory_iterator(p, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != fs::recursive_directory_iterator() );\n+  VERIFY( iter->path() == p/\"d1\" );\n+  ++iter;              // should recurse into d1\n+  VERIFY( iter->path() == p/\"d1/d2\" );\n+  iter.increment(ec);  // should fail to recurse into p/d1/d2\n+  VERIFY( ec );\n+\n+  // Test inaccessible sub-directory, skipping permission denied.\n+  iter = fs::recursive_directory_iterator(p, opts, ec);\n+  VERIFY( !ec );\n+  VERIFY( iter != fs::recursive_directory_iterator() );\n+  VERIFY( iter->path() == p/\"d1\" );\n+  ++iter;              // should recurse into d1\n+  VERIFY( iter->path() == p/\"d1/d2\" );\n+  iter.increment(ec);  // should fail to recurse into p/d1/d2, so skip it\n+  VERIFY( !ec );\n+  VERIFY( iter == fs::recursive_directory_iterator() );\n+\n+  permissions(p/\"d1/d2\", fs::perms::owner_all, ec);\n+  remove_all(p, ec);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}