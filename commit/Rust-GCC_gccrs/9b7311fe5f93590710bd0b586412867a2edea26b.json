{"sha": "9b7311fe5f93590710bd0b586412867a2edea26b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI3MzExZmU1ZjkzNTkwNzEwYmQwYjU4NjQxMjg2N2EyZWRlYTI2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-05-18T17:49:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-05-18T17:49:10Z"}, "message": "(VMS_write, VMS_read): Delete.\n\n(safe_write): If MAX_WRITE_LEN is defined, limit\nincremental write attempts to that amount.\n(safe_read): Analogous situation for MAX_READ_LEN.\n\nFrom-SVN: r14092", "tree": {"sha": "73f193dd39e633cfaba2a547951f69aaeb37045c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73f193dd39e633cfaba2a547951f69aaeb37045c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b7311fe5f93590710bd0b586412867a2edea26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7311fe5f93590710bd0b586412867a2edea26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7311fe5f93590710bd0b586412867a2edea26b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7311fe5f93590710bd0b586412867a2edea26b/comments", "author": null, "committer": null, "parents": [{"sha": "0a22948f601ec68de091c55bcab733fa55bf594c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a22948f601ec68de091c55bcab733fa55bf594c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a22948f601ec68de091c55bcab733fa55bf594c"}], "stats": {"total": 83, "additions": 21, "deletions": 62}, "files": [{"sha": "828c0a9d407dd33b86bb670acec3bfb5837e329a", "filename": "gcc/cccp.c", "status": "modified", "additions": 21, "deletions": 62, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b7311fe5f93590710bd0b586412867a2edea26b/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b7311fe5f93590710bd0b586412867a2edea26b/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=9b7311fe5f93590710bd0b586412867a2edea26b", "patch": "@@ -219,15 +219,11 @@ my_bzero (b, length)\n /* VMS-specific definitions */\n #ifdef VMS\n #include <descrip.h>\n-#define read(fd,buf,size)\tVMS_read (fd,buf,size)\n-#define write(fd,buf,size)\tVMS_write (fd,buf,size)\n #define open(fname,mode,prot)\tVMS_open (fname,mode,prot)\n #define fopen(fname,mode)\tVMS_fopen (fname,mode)\n #define freopen(fname,mode,ofile) VMS_freopen (fname,mode,ofile)\n #define fstat(fd,stbuf)\t\tVMS_fstat (fd,stbuf)\n static int VMS_fstat (), VMS_stat ();\n-static int VMS_read ();\n-static int VMS_write ();\n static int VMS_open ();\n static FILE * VMS_fopen ();\n static FILE * VMS_freopen ();\n@@ -1216,7 +1212,8 @@ static GENERIC_PTR xcalloc PROTO((size_t, size_t));\n static char *savestring PROTO((char *));\n \f\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n-   retrying if necessary.  Return a negative value if an error occurs,\n+   retrying if necessary.  If MAX_READ_LEN is defined, read at most\n+   that bytes at a time.  Return a negative value if an error occurs,\n    otherwise return the actual number of bytes read,\n    which must be LEN unless end-of-file was reached.  */\n \n@@ -1226,9 +1223,16 @@ safe_read (desc, ptr, len)\n      char *ptr;\n      int len;\n {\n-  int left = len;\n+  int left, rcount, nchars;\n+\n+  left = len;\n   while (left > 0) {\n-    int nchars = read (desc, ptr, left);\n+    rcount = left;\n+#ifdef MAX_READ_LEN\n+    if (rcount > MAX_READ_LEN)\n+      rcount = MAX_READ_LEN;\n+#endif\n+    nchars = read (desc, ptr, rcount);\n     if (nchars < 0)\n       {\n #ifdef EINTR\n@@ -1246,16 +1250,24 @@ safe_read (desc, ptr, len)\n }\n \n /* Write LEN bytes at PTR to descriptor DESC,\n-   retrying if necessary, and treating any real error as fatal.  */\n+   retrying if necessary, and treating any real error as fatal.\n+   If MAX_WRITE_LEN is defined, write at most that many bytes at a time.  */\n \n static void\n safe_write (desc, ptr, len)\n      int desc;\n      char *ptr;\n      int len;\n {\n+  int wcount, written;\n+\n   while (len > 0) {\n-    int written = write (desc, ptr, len);\n+    wcount = len;\n+#ifdef MAX_WRITE_LEN\n+    if (wcount > MAX_WRITE_LEN)\n+      wcount = MAX_WRITE_LEN;\n+#endif\n+    written = write (desc, ptr, wcount);\n     if (written < 0)\n       {\n #ifdef EINTR\n@@ -10173,59 +10185,6 @@ hack_vms_include_specification (fname, vaxc_include)\n \f\n #ifdef\tVMS\n \n-/* These are the read/write replacement routines for\n-   VAX-11 \"C\".  They make read/write behave enough\n-   like their UNIX counterparts that CCCP will work */\n-\n-static int\n-read (fd, buf, size)\n-     int fd;\n-     char *buf;\n-     int size;\n-{\n-#undef\tread\t/* Get back the REAL read routine */\n-  register int i;\n-  register int total = 0;\n-\n-  /* Read until the buffer is exhausted */\n-  while (size > 0) {\n-    /* Limit each read to 32KB */\n-    i = (size > (32*1024)) ? (32*1024) : size;\n-    i = read (fd, buf, i);\n-    if (i <= 0) {\n-      if (i == 0) return (total);\n-      return (i);\n-    }\n-    /* Account for this read */\n-    total += i;\n-    buf += i;\n-    size -= i;\n-  }\n-  return (total);\n-}\n-\n-static int\n-write (fd, buf, size)\n-     int fd;\n-     char *buf;\n-     int size;\n-{\n-#undef\twrite\t/* Get back the REAL write routine */\n-  int i;\n-  int j;\n-\n-  /* Limit individual writes to 32Kb */\n-  i = size;\n-  while (i > 0) {\n-    j = (i > (32*1024)) ? (32*1024) : i;\n-    if (write (fd, buf, j) < 0) return (-1);\n-    /* Account for the data written */\n-    buf += j;\n-    i -= j;\n-  }\n-  return (size);\n-}\n-\n /* The following wrapper functions supply additional arguments to the VMS\n    I/O routines to optimize performance with file handling.  The arguments\n    are:"}]}