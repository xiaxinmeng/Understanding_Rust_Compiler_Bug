{"sha": "e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllYjgwOWRlYzY5YjYyODBlZDJmMjgzMGVmZDFhYzhiN2Q5YmNiOA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-07-09T03:19:14Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-07-09T03:19:14Z"}, "message": "tree-scalar-evolution.c: New file.\n\n\t* tree-scalar-evolution.c: New file.\n\t* tree-scalar-evolution.h: New file.\n\t* tree-ssa-loop-niter.c: New file.\n\t* Makefile.in (SCEV_H): New.\n\t(tree-scalar-evolution.o, tree-ssa-loop-niter.o): Add new files.\n\t* cfgloop.h (struct loop): Add bounds field.\n\t* tree-flow.h (struct tree_niter_desc): New type.\n\t(number_of_iterations_cond, number_of_iterations_exit,\n\tloop_niter_by_eval, find_loop_niter_by_eval,\n\testimate_numbers_of_iterations, can_count_iv_in_wider_type,\n\tfree_numbers_of_iterations_estimates): Declare.\n\t* tree.h (lower_bound_in_type, upper_bound_in_type): Declare.\n\t* params.def (PARAM_MAX_ITERATIONS_TO_TRACK): New parameter.\n\t* doc/invoke.texi (max-iterations-to-track): Document.\n\nFrom-SVN: r84340", "tree": {"sha": "b093da742fb0c72680308c3cb8cd011bf2fbc8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b093da742fb0c72680308c3cb8cd011bf2fbc8fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/comments", "author": null, "committer": null, "parents": [{"sha": "dd29d26b24928bdbcbdb1e7cbe09284f76f886f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd29d26b24928bdbcbdb1e7cbe09284f76f886f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd29d26b24928bdbcbdb1e7cbe09284f76f886f7"}], "stats": {"total": 1488, "additions": 1487, "deletions": 1}, "files": [{"sha": "8136c4e5f7161c8da39b9602e3973f301da9fb82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -1,3 +1,20 @@\n+2004-07-08  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-scalar-evolution.c: New file.\n+\t* tree-scalar-evolution.h: New file.\n+\t* tree-ssa-loop-niter.c: New file.\n+\t* Makefile.in (SCEV_H): New.\n+\t(tree-scalar-evolution.o, tree-ssa-loop-niter.o): Add new files.\n+\t* cfgloop.h (struct loop): Add bounds field.\n+\t* tree-flow.h (struct tree_niter_desc): New type.\n+\t(number_of_iterations_cond, number_of_iterations_exit,\n+\tloop_niter_by_eval, find_loop_niter_by_eval,\n+\testimate_numbers_of_iterations, can_count_iv_in_wider_type,\n+\tfree_numbers_of_iterations_estimates): Declare.\n+\t* tree.h (lower_bound_in_type, upper_bound_in_type): Declare.\n+\t* params.def (PARAM_MAX_ITERATIONS_TO_TRACK): New parameter.\n+\t* doc/invoke.texi (max-iterations-to-track): Document.\n+\n 2004-07-08  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (sh_va_arg): Initinalize lab_over."}, {"sha": "3e20a0ced4bf918dcca9857ba5599c002fed80d6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -728,6 +728,7 @@ TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H)\n PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)\n C_PRETTY_PRINT_H = $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n+SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -886,7 +887,7 @@ C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n # Language-independent object files.\n \n OBJS-common = \\\n- tree-chrec.o                                                              \\\n+ tree-chrec.o tree-scalar-evolution.o\t\t\t\t\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n  tree-alias-type.o gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n  tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o tree-vn.o             \\\n@@ -895,6 +896,7 @@ OBJS-common = \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n+ tree-ssa-loop-niter.o \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1676,6 +1678,10 @@ tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(FLAGS_H) tree-inline.h\n+tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) cfgloop.h $(PARAMS_H) tree-inline.h \\\n+   output.h diagnostic.h $(TM_H) coretypes.h $(TREE_DUMP_H) flags.h \\\n+   tree-pass.h $(SCEV_H)\t\t \n tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n@@ -1708,6 +1714,10 @@ tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TM_H) coretypes.h\n tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    errors.h $(GGC_H) $(TREE_H) tree-chrec.h tree-pass.h\n+tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n+   coretypes.h $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) \\\n+   $(BASIC_BLOCK_H) diagnostic.h $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n+   $(TIMEVAR_H) cfgloop.h $(SCEV_H)\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\"}, {"sha": "156438aa29f94de770ebb5ca95663273c1e6789b", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -175,6 +175,9 @@ struct loop\n   /* The number of LABEL_REFs on exit_labels for this loop and all\n      loops nested inside it.  */\n   int exit_count;\n+\n+  /* Upper bound on number of iterations of a loop.  */\n+  struct nb_iter_bound *bounds;\n };\n \n /* Flags for state of loop structure.  */"}, {"sha": "aed9010dc0192c69a5bdd16e8828c707ff4883b8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -5174,6 +5174,11 @@ The maximum number of insns of an unswitched loop.\n @item max-unswitch-level\n The maximum number of branches unswitched in a single loop.\n \n+@item max-iterations-to-track\n+\n+The maximum number of iterations of a loop the brute force algorithm\n+for analysis of # of iterations of the loop tries to evaluate.\n+\n @item hot-bb-count-fraction\n Select fraction of the maximal count of repetitions of basic block in program\n given basic block needs to have to be considered hot."}, {"sha": "56d83609a29874740e4679d812f998aae588ca06", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -229,6 +229,14 @@ DEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,\n \t\"The maximum number of unswitchings in a single loop\",\n \t3)\n \n+/* The maximum number of iterations of a loop the brute force algorithm\n+   for analysis of # of iterations of the loop tries to evaluate.  */\n+DEFPARAM(PARAM_MAX_ITERATIONS_TO_TRACK,\n+\t\"max-iterations-to-track\",\n+\t\"Bound on the number of iterations the brute force # of iterations \\\n+\t analysis algorithm evaluates\",\n+\t1000)\n+\n DEFPARAM(PARAM_MAX_SMS_LOOP_NUMBER,\n \t \"max-sms-loop-number\",\n \t \"Maximum number of loops to perform swing modulo scheduling on \\"}, {"sha": "102b6ea5f04e64fc8b6f33ecd8df1383d7b5fb91", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -597,6 +597,50 @@ extern void propagate_tree_value (tree *, tree);\n extern void replace_exp (use_operand_p, tree);\n extern bool may_propagate_copy (tree, tree);\n \n+/* Description of number of iterations of a loop.  All the expressions inside\n+   the structure can be evaluated at the end of the loop's preheader\n+   (and due to ssa form, also anywhere inside the body of the loop).  */\n+\n+struct tree_niter_desc\n+{\n+  tree assumptions;\t/* The boolean expression.  If this expression evalutes\n+\t\t\t   to false, then the other fields in this structure\n+\t\t\t   should not be used; there is no guarantee that they\n+\t\t\t   will be correct.  */\n+  tree may_be_zero;\t/* The booleand expression.  If it evaluates to true,\n+\t\t\t   the loop will exit in the first iteration (i.e.\n+\t\t\t   its latch will not be executed), even if the niter\n+\t\t\t   field says otherwise.  */\n+  tree niter;\t\t/* The expression giving the number of iterations of\n+\t\t\t   a loop (provided that assumptions == true and\n+\t\t\t   may_be_zero == false), more precisely the number\n+\t\t\t   of executions of the latch of the loop.  */\n+  tree additional_info;\t/* The boolean expression.  Sometimes we use additional\n+\t\t\t   knowledge to simplify the other expressions\n+\t\t\t   contained in this structure (for example the\n+\t\t\t   knowledge about value ranges of operands on entry to\n+\t\t\t   the loop).  If this is a case, conjunction of such\n+\t\t\t   condition is stored in this field, so that we do not\n+\t\t\t   lose the information: for example if may_be_zero\n+\t\t\t   is (n <= 0) and niter is (unsigned) n, we know\n+\t\t\t   that the number of iterations is at most\n+\t\t\t   MAX_SIGNED_INT.  However if the (n <= 0) assumption\n+\t\t\t   is eliminated (by looking at the guard on entry of\n+\t\t\t   the loop), then the information would be lost.  */\n+};\n+\n+/* In tree-ssa-loop*.c  */\n+\n+void number_of_iterations_cond (tree, tree, tree, enum tree_code, tree, tree,\n+\t\t\t\tstruct tree_niter_desc *);\n+bool number_of_iterations_exit (struct loop *, edge,\n+\t\t\t\tstruct tree_niter_desc *niter);\n+tree loop_niter_by_eval (struct loop *, edge);\n+tree find_loop_niter_by_eval (struct loop *, edge *);\n+void estimate_numbers_of_iterations (struct loops *);\n+tree can_count_iv_in_wider_type (struct loop *, tree, tree, tree, tree);\n+void free_numbers_of_iterations_estimates (struct loops *);\n+\n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);\n static inline bool is_call_clobbered (tree);"}, {"sha": "fc671e392641ef017b4fa907fe9633ee370ad74c", "filename": "gcc/tree-scalar-evolution.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -0,0 +1,61 @@\n+/* Scalar evolution detector.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-scalar-evolution.h\"\n+\n+/* Analyze all the parameters of the chrec that were left under a\n+   symbolic form.  LOOP is the loop in which symbolic names have to\n+   be analyzed and instantiated.  */\n+\n+tree\n+instantiate_parameters (struct loop *loop ATTRIBUTE_UNUSED,\n+\t\t\ttree chrec)\n+{\n+  /* Just a dummy definition for now.  */\n+  return chrec;\n+}\n+\n+/* Checks whether OP behaves as a simple affine iv of LOOP in STMT and returns\n+   its BASE and STEP if possible.  */\n+\n+bool\n+simple_iv (struct loop *loop ATTRIBUTE_UNUSED, tree stmt ATTRIBUTE_UNUSED,\n+\t   tree op ATTRIBUTE_UNUSED, tree *base ATTRIBUTE_UNUSED,\n+\t   tree *step ATTRIBUTE_UNUSED)\n+{\n+  /* Just a dummy definition for now.  */\n+  return false;\n+}"}, {"sha": "d39fd935423015be0d4d0445c1a046a457af623e", "filename": "gcc/tree-scalar-evolution.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -0,0 +1,28 @@\n+/* Scalar evolution detector.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_TREE_SCALAR_EVOLUTION_H\n+#define GCC_TREE_SCALAR_EVOLUTION_H\n+\n+extern tree instantiate_parameters (struct loop *, tree);\n+extern bool simple_iv (struct loop *, tree, tree, tree *, tree *);\n+\n+#endif  /* GCC_TREE_SCALAR_EVOLUTION_H  */"}, {"sha": "67663e42f9fe380862e83b76d410fa0f278f4d90", "filename": "gcc/tree-ssa-loop-niter.c", "status": "added", "additions": 1305, "deletions": 0, "changes": 1305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -0,0 +1,1305 @@\n+/* Functions to determine/estimate number of iterations of a loop.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-pass.h\"\n+#include \"ggc.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"params.h\"\n+#include \"flags.h\"\n+#include \"tree-inline.h\"\n+\n+#define SWAP(X, Y) do { void *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n+\n+/* Just to shorten the ugly names.  */\n+#define EXEC_BINARY nondestructive_fold_binary_to_constant\n+#define EXEC_UNARY nondestructive_fold_unary_to_constant\n+\n+/*\n+\n+   Analysis of number of iterations of an affine exit test.\n+\n+*/\n+\n+/* Returns true if ARG is either NULL_TREE or constant zero.  */\n+\n+static bool\n+zero_p (tree arg)\n+{\n+  if (!arg)\n+    return true;\n+\n+  return integer_zerop (arg);\n+}\n+\n+/* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */\n+\n+static tree\n+inverse (tree x, tree mask)\n+{\n+  tree type = TREE_TYPE (x);\n+  tree ctr = EXEC_BINARY (RSHIFT_EXPR, type, mask, integer_one_node);\n+  tree rslt = convert (type, integer_one_node);\n+\n+  while (integer_nonzerop (ctr))\n+    {\n+      rslt = EXEC_BINARY (MULT_EXPR, type, rslt, x);\n+      rslt = EXEC_BINARY (BIT_AND_EXPR, type, rslt, mask);\n+      x = EXEC_BINARY (MULT_EXPR, type, x, x);\n+      x = EXEC_BINARY (BIT_AND_EXPR, type, x, mask);\n+      ctr = EXEC_BINARY (RSHIFT_EXPR, type, ctr, integer_one_node);\n+    }\n+\n+  return rslt;\n+}\n+\n+/* Returns unsigned variant of TYPE.  */\n+\n+static tree\n+unsigned_type_for (tree type)\n+{\n+  return make_unsigned_type (TYPE_PRECISION (type));\n+}\n+\n+/* Returns signed variant of TYPE.  */\n+\n+static tree\n+signed_type_for (tree type)\n+{\n+  return make_signed_type (TYPE_PRECISION (type));\n+}\n+\n+/* Determine the number of iterations according to condition (for staying\n+   inside loop) which compares two induction variables using comparison\n+   operator CODE.  The induction variable on left side of the comparison\n+   has base BASE0 and step STEP0. the right-hand side one has base\n+   BASE1 and step STEP1.  Both induction variables must have type TYPE,\n+   which must be an integer or pointer type.  STEP0 and STEP1 must be\n+   constants (or NULL_TREE, which is interpreted as constant zero).\n+   \n+   The results (number of iterations and assumptions as described in\n+   comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.\n+   In case we are unable to determine number of iterations, contents of\n+   this structure is unchanged.  */\n+\n+void\n+number_of_iterations_cond (tree type, tree base0, tree step0,\n+\t\t\t   enum tree_code code, tree base1, tree step1,\n+\t\t\t   struct tree_niter_desc *niter)\n+{\n+  tree step, delta, mmin, mmax;\n+  tree may_xform, bound, s, d, tmp;\n+  bool was_sharp = false;\n+  tree assumption;\n+  tree assumptions = boolean_true_node;\n+  tree noloop_assumptions = boolean_false_node;\n+  tree niter_type, signed_niter_type;\n+\n+  /* The meaning of these assumptions is this:\n+     if !assumptions\n+       then the rest of information does not have to be valid\n+     if noloop_assumptions then the loop does not have to roll\n+       (but it is only conservative approximation, i.e. it only says that\n+       if !noloop_assumptions, then the loop does not end before the computed\n+       number of iterations)  */\n+\n+  /* Make < comparison from > ones.  */\n+  if (code == GE_EXPR\n+      || code == GT_EXPR)\n+    {\n+      SWAP (base0, base1);\n+      SWAP (step0, step1);\n+      code = swap_tree_comparison (code);\n+    }\n+\n+  /* We can handle the case when neither of the sides of the comparison is\n+     invariant, provided that the test is NE_EXPR.  This rarely occurs in\n+     practice, but it is simple enough to manage.  */\n+  if (!zero_p (step0) && !zero_p (step1))\n+    {\n+      if (code != NE_EXPR)\n+\treturn;\n+\n+      step0 = EXEC_BINARY (MINUS_EXPR, type, step0, step1);\n+      step1 = NULL_TREE;\n+    }\n+\n+  /* If the result is a constant,  the loop is weird.  More precise handling\n+     would be possible, but the situation is not common enough to waste time\n+     on it.  */\n+  if (zero_p (step0) && zero_p (step1))\n+    return;\n+\n+  /* Ignore loops of while (i-- < 10) type.  */\n+  if (code != NE_EXPR)\n+    {\n+      if (step0 && !tree_expr_nonnegative_p (step0))\n+\treturn;\n+\n+      if (!zero_p (step1) && tree_expr_nonnegative_p (step1))\n+\treturn;\n+    }\n+\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      /* We assume pointer arithmetic never overflows.  */\n+      mmin = mmax = NULL_TREE;\n+    }\n+  else\n+    {\n+      mmin = TYPE_MIN_VALUE (type);\n+      mmax = TYPE_MAX_VALUE (type);\n+    }\n+\n+  /* Some more condition normalization.  We must record some assumptions\n+     due to overflows.  */\n+\n+  if (code == LT_EXPR)\n+    {\n+      /* We want to take care only of <=; this is easy,\n+\t as in cases the overflow would make the transformation unsafe the loop\n+\t does not roll.  Seemingly it would make more sense to want to take\n+\t care of <, as NE is more simmilar to it, but the problem is that here\n+\t the transformation would be more difficult due to possibly infinite\n+\t loops.  */\n+      if (zero_p (step0))\n+\t{\n+\t  if (mmax)\n+\t    assumption = fold (build (EQ_EXPR, boolean_type_node, base0, mmax));\n+\t  else\n+\t    assumption = boolean_false_node;\n+\t  if (integer_nonzerop (assumption))\n+\t    goto zero_iter;\n+\t  base0 = fold (build (PLUS_EXPR, type, base0,\n+\t\t\t       convert (type, integer_one_node)));\n+\t}\n+      else\n+\t{\n+\t  if (mmin)\n+\t    assumption = fold (build (EQ_EXPR, boolean_type_node, base1, mmin));\n+\t  else\n+\t    assumption = boolean_false_node;\n+\t  if (integer_nonzerop (assumption))\n+\t    goto zero_iter;\n+\t  base1 = fold (build (MINUS_EXPR, type, base1,\n+\t\t\t       convert (type, integer_one_node)));\n+\t}\n+      noloop_assumptions = assumption;\n+      code = LE_EXPR;\n+\n+      /* It will be useful to be able to tell the difference once more in\n+\t <= -> != reduction.  */\n+      was_sharp = true;\n+    }\n+\n+  /* Take care of trivially infinite loops.  */\n+  if (code != NE_EXPR)\n+    {\n+      if (zero_p (step0)\n+\t  && mmin\n+\t  && operand_equal_p (base0, mmin, 0))\n+\treturn;\n+      if (zero_p (step1)\n+\t  && mmax\n+\t  && operand_equal_p (base1, mmax, 0))\n+\treturn;\n+    }\n+\n+  /* If we can we want to take care of NE conditions instead of size\n+     comparisons, as they are much more friendly (most importantly\n+     this takes care of special handling of loops with step 1).  We can\n+     do it if we first check that upper bound is greater or equal to\n+     lower bound, their difference is constant c modulo step and that\n+     there is not an overflow.  */\n+  if (code != NE_EXPR)\n+    {\n+      if (zero_p (step0))\n+\tstep = EXEC_UNARY (NEGATE_EXPR, type, step1);\n+      else\n+\tstep = step0;\n+      delta = build (MINUS_EXPR, type, base1, base0);\n+      delta = fold (build (FLOOR_MOD_EXPR, type, delta, step));\n+      may_xform = boolean_false_node;\n+\n+      if (TREE_CODE (delta) == INTEGER_CST)\n+\t{\n+\t  tmp = EXEC_BINARY (MINUS_EXPR, type, step,\n+\t\t\t     convert (type, integer_one_node));\n+\t  if (was_sharp\n+\t      && operand_equal_p (delta, tmp, 0))\n+\t    {\n+\t      /* A special case.  We have transformed condition of type\n+\t\t for (i = 0; i < 4; i += 4)\n+\t\t into\n+\t\t for (i = 0; i <= 3; i += 4)\n+\t\t obviously if the test for overflow during that transformation\n+\t\t passed, we cannot overflow here.  Most importantly any\n+\t\t loop with sharp end condition and step 1 falls into this\n+\t\t cathegory, so handling this case specially is definitely\n+\t\t worth the troubles.  */\n+\t      may_xform = boolean_true_node;\n+\t    }\n+\t  else if (zero_p (step0))\n+\t    {\n+\t      if (!mmin)\n+\t\tmay_xform = boolean_true_node;\n+\t      else\n+\t\t{\n+\t\t  bound = EXEC_BINARY (PLUS_EXPR, type, mmin, step);\n+\t\t  bound = EXEC_BINARY (MINUS_EXPR, type, bound, delta);\n+\t\t  may_xform = fold (build (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t   bound, base0));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!mmax)\n+\t\tmay_xform = boolean_true_node;\n+\t      else\n+\t\t{\n+\t\t  bound = EXEC_BINARY (MINUS_EXPR, type, mmax, step);\n+\t\t  bound = EXEC_BINARY (PLUS_EXPR, type, bound, delta);\n+\t\t  may_xform = fold (build (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t   base1, bound));\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (!integer_zerop (may_xform))\n+\t{\n+\t  /* We perform the transformation always provided that it is not\n+\t     completely senseless.  This is OK, as we would need this assumption\n+\t     to determine the number of iterations anyway.  */\n+\t  if (!integer_nonzerop (may_xform))\n+\t    assumptions = may_xform;\n+\n+\t  if (zero_p (step0))\n+\t    {\n+\t      base0 = build (PLUS_EXPR, type, base0, delta);\n+\t      base0 = fold (build (MINUS_EXPR, type, base0, step));\n+\t    }\n+\t  else\n+\t    {\n+\t      base1 = build (MINUS_EXPR, type, base1, delta);\n+\t      base1 = fold (build (PLUS_EXPR, type, base1, step));\n+\t    }\n+\n+\t  assumption = fold (build (GT_EXPR, boolean_type_node, base0, base1));\n+\t  noloop_assumptions = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t\t    noloop_assumptions, assumption));\n+\t  code = NE_EXPR;\n+\t}\n+    }\n+\n+  /* Count the number of iterations.  */\n+  niter_type = unsigned_type_for (type);\n+  signed_niter_type = signed_type_for (type);\n+\n+  if (code == NE_EXPR)\n+    {\n+      /* Everything we do here is just arithmetics modulo size of mode.  This\n+\t makes us able to do more involved computations of number of iterations\n+\t than in other cases.  First transform the condition into shape\n+\t s * i <> c, with s positive.  */\n+      base1 = fold (build (MINUS_EXPR, type, base1, base0));\n+      base0 = NULL_TREE;\n+      if (!zero_p (step1))\n+  \tstep0 = EXEC_UNARY (NEGATE_EXPR, type, step1);\n+      step1 = NULL_TREE;\n+      if (!tree_expr_nonnegative_p (convert (signed_niter_type, step0)))\n+\t{\n+\t  step0 = EXEC_UNARY (NEGATE_EXPR, type, step0);\n+\t  base1 = fold (build1 (NEGATE_EXPR, type, base1));\n+\t}\n+\n+      base1 = convert (niter_type, base1);\n+      step0 = convert (niter_type, step0);\n+\n+      /* Let nsd (s, size of mode) = d.  If d does not divide c, the loop\n+\t is infinite.  Otherwise, the number of iterations is\n+\t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n+      s = step0;\n+      d = integer_one_node;\n+      bound = convert (niter_type, build_int_2 (~0, ~0));\n+      while (1)\n+\t{\n+\t  tmp = EXEC_BINARY (BIT_AND_EXPR, niter_type, s,\n+\t\t\t     convert (niter_type, integer_one_node));\n+\t  if (integer_nonzerop (tmp))\n+\t    break;\n+\t  \n+\t  s = EXEC_BINARY (RSHIFT_EXPR, niter_type, s,\n+\t\t\t   convert (niter_type, integer_one_node));\n+\t  d = EXEC_BINARY (LSHIFT_EXPR, niter_type, d,\n+\t\t\t   convert (niter_type, integer_one_node));\n+\t  bound = EXEC_BINARY (RSHIFT_EXPR, niter_type, bound,\n+\t\t\t       convert (niter_type, integer_one_node));\n+\t}\n+\n+      tmp = fold (build (EXACT_DIV_EXPR, niter_type, base1, d));\n+      tmp = fold (build (MULT_EXPR, niter_type, tmp, inverse (s, bound)));\n+      niter->niter = fold (build (BIT_AND_EXPR, niter_type, tmp, bound));\n+    }\n+  else\n+    {\n+      if (zero_p (step1))\n+\t/* Condition in shape a + s * i <= b\n+\t   We must know that b + s does not overflow and a <= b + s and then we\n+\t   can compute number of iterations as (b + s - a) / s.  (It might\n+\t   seem that we in fact could be more clever about testing the b + s\n+\t   overflow condition using some information about b - a mod s,\n+\t   but it was already taken into account during LE -> NE transform).  */\n+\t{\n+\t  if (mmax)\n+\t    {\n+\t      bound = EXEC_BINARY (MINUS_EXPR, type, mmax, step0);\n+\t      assumption = fold (build (LE_EXPR, boolean_type_node,\n+\t\t\t\t\tbase1, bound));\n+\t      assumptions = fold (build (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t assumptions, assumption));\n+\t    }\n+\n+\t  step = step0;\n+\t  tmp = fold (build (PLUS_EXPR, type, base1, step0));\n+\t  assumption = fold (build (GT_EXPR, boolean_type_node, base0, tmp));\n+\t  delta = fold (build (PLUS_EXPR, type, base1, step));\n+\t  delta = fold (build (MINUS_EXPR, type, delta, base0));\n+\t  delta = convert (niter_type, delta);\n+\t}\n+      else\n+\t{\n+\t  /* Condition in shape a <= b - s * i\n+\t     We must know that a - s does not overflow and a - s <= b and then\n+\t     we can again compute number of iterations as (b - (a - s)) / s.  */\n+\t  if (mmin)\n+\t    {\n+\t      bound = EXEC_BINARY (MINUS_EXPR, type, mmin, step1);\n+\t      assumption = fold (build (LE_EXPR, boolean_type_node,\n+\t\t\t\t\tbound, base0));\n+\t      assumptions = fold (build (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t assumptions, assumption));\n+\t    }\n+\t  step = fold (build1 (NEGATE_EXPR, type, step1));\n+\t  tmp = fold (build (PLUS_EXPR, type, base0, step1));\n+\t  assumption = fold (build (GT_EXPR, boolean_type_node, tmp, base1));\n+\t  delta = fold (build (MINUS_EXPR, type, base0, step));\n+\t  delta = fold (build (MINUS_EXPR, type, base1, delta));\n+\t  delta = convert (niter_type, delta);\n+\t}\n+      noloop_assumptions = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t\tnoloop_assumptions, assumption));\n+      delta = fold (build (FLOOR_DIV_EXPR, niter_type, delta,\n+\t\t\t   convert (niter_type, step)));\n+      niter->niter = delta;\n+    }\n+\n+  niter->assumptions = assumptions;\n+  niter->may_be_zero = noloop_assumptions;\n+  return;\n+\n+zero_iter:\n+  niter->assumptions = boolean_true_node;\n+  niter->may_be_zero = boolean_true_node;\n+  niter->niter = convert (type, integer_zero_node);\n+  return;\n+}\n+\n+/* Tries to simplify EXPR using the evolutions of the loop invariants\n+   in the superloops of LOOP.  Returns the simplified expression\n+   (or EXPR unchanged, if no simplification was possible).  */\n+\n+static tree\n+simplify_using_outer_evolutions (struct loop *loop, tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  bool changed;\n+  tree e, e0, e1, e2;\n+\n+  if (is_gimple_min_invariant (expr))\n+    return expr;\n+\n+  if (code == TRUTH_OR_EXPR\n+      || code == TRUTH_AND_EXPR\n+      || code == COND_EXPR)\n+    {\n+      changed = false;\n+\n+      e0 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 0));\n+      if (TREE_OPERAND (expr, 0) != e0)\n+\tchanged = true;\n+\n+      e1 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 1));\n+      if (TREE_OPERAND (expr, 1) != e1)\n+\tchanged = true;\n+\n+      if (code == COND_EXPR)\n+\t{\n+\t  e2 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 2));\n+\t  if (TREE_OPERAND (expr, 2) != e2)\n+\t    changed = true;\n+\t}\n+      else\n+\te2 = NULL_TREE;\n+\n+      if (changed)\n+\t{\n+\t  if (code == COND_EXPR)\n+\t    expr = build (code, boolean_type_node, e0, e1, e2);\n+\t  else\n+\t    expr = build (code, boolean_type_node, e0, e1);\n+\t  expr = fold (expr);\n+\t}\n+\n+      return expr;\n+    }\n+\n+  e = instantiate_parameters (loop, expr);\n+  if (is_gimple_min_invariant (e))\n+    return e;\n+\n+  return expr;\n+}\n+\n+/* Tries to simplify EXPR using the condition COND.  Returns the simplified\n+   expression (or EXPR unchanged, if no simplification was possible).*/\n+\n+static tree\n+tree_simplify_using_condition (tree cond, tree expr)\n+{\n+  bool changed;\n+  tree e, e0, e1, e2, notcond;\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  if (code == INTEGER_CST)\n+    return expr;\n+\n+  if (code == TRUTH_OR_EXPR\n+      || code == TRUTH_AND_EXPR\n+      || code == COND_EXPR)\n+    {\n+      changed = false;\n+\n+      e0 = tree_simplify_using_condition (cond, TREE_OPERAND (expr, 0));\n+      if (TREE_OPERAND (expr, 0) != e0)\n+\tchanged = true;\n+\n+      e1 = tree_simplify_using_condition (cond, TREE_OPERAND (expr, 1));\n+      if (TREE_OPERAND (expr, 1) != e1)\n+\tchanged = true;\n+\n+      if (code == COND_EXPR)\n+\t{\n+\t  e2 = tree_simplify_using_condition (cond, TREE_OPERAND (expr, 2));\n+\t  if (TREE_OPERAND (expr, 2) != e2)\n+\t    changed = true;\n+\t}\n+      else\n+\te2 = NULL_TREE;\n+\n+      if (changed)\n+\t{\n+\t  if (code == COND_EXPR)\n+\t    expr = build (code, boolean_type_node, e0, e1, e2);\n+\t  else\n+\t    expr = build (code, boolean_type_node, e0, e1);\n+\t  expr = fold (expr);\n+\t}\n+\n+      return expr;\n+    }\n+\n+  /* Check whether COND ==> EXPR.  */\n+  notcond = invert_truthvalue (cond);\n+  e = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t   notcond, expr));\n+  if (integer_nonzerop (e))\n+    return e;\n+\n+  /* Check whether COND ==> not EXPR.  */\n+  e = fold (build (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t   cond, expr));\n+  if (integer_zerop (e))\n+    return e;\n+\n+  return expr;\n+}\n+\n+/* Tries to simplify EXPR using the conditions on entry to LOOP.\n+   Record the conditions used for simplification to CONDS_USED.\n+   Returns the simplified expression (or EXPR unchanged, if no\n+   simplification was possible).*/\n+\n+static tree\n+simplify_using_initial_conditions (struct loop *loop, tree expr,\n+\t\t\t\t   tree *conds_used)\n+{\n+  edge e;\n+  basic_block bb;\n+  tree exp, cond;\n+\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    return expr;\n+\n+  for (bb = loop->header;\n+       bb != ENTRY_BLOCK_PTR;\n+       bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      e = bb->pred;\n+      if (e->pred_next)\n+\tcontinue;\n+\n+      if (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n+\tcontinue;\n+\n+      cond = COND_EXPR_COND (last_stmt (e->src));\n+      if (e->flags & EDGE_FALSE_VALUE)\n+\tcond = invert_truthvalue (cond);\n+      exp = tree_simplify_using_condition (cond, expr);\n+\n+      if (exp != expr)\n+\t*conds_used = fold (build (TRUTH_AND_EXPR,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   *conds_used,\n+\t\t\t\t   cond));\n+\n+      expr = exp;\n+    }\n+\n+  return expr;\n+}\n+\n+/* Stores description of number of iterations of LOOP derived from\n+   EXIT (an exit edge of the LOOP) in NITER.  Returns true if some\n+   useful information could be derived (and fields of NITER has\n+   meaning described in comments at struct tree_niter_desc\n+   declaration), false otherwise.  */\n+\n+bool\n+number_of_iterations_exit (struct loop *loop, edge exit,\n+\t\t\t   struct tree_niter_desc *niter)\n+{\n+  tree stmt, cond, type;\n+  tree op0, base0, step0;\n+  tree op1, base1, step1;\n+  enum tree_code code;\n+\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src))\n+    return false;\n+\n+  niter->assumptions = boolean_false_node;\n+  stmt = last_stmt (exit->src);\n+  if (!stmt || TREE_CODE (stmt) != COND_EXPR)\n+    return false;\n+\n+  /* We want the condition for staying inside loop.  */\n+  cond = COND_EXPR_COND (stmt);\n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    cond = invert_truthvalue (cond);\n+\n+  code = TREE_CODE (cond);\n+  switch (code)\n+    {\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case NE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+  \n+  op0 = TREE_OPERAND (cond, 0);\n+  op1 = TREE_OPERAND (cond, 1);\n+  type = TREE_TYPE (op0);\n+\n+  if (TREE_CODE (type) != INTEGER_TYPE\n+    && TREE_CODE (type) != POINTER_TYPE)\n+    return false;\n+     \n+  if (!simple_iv (loop, stmt, op0, &base0, &step0))\n+    return false;\n+  if (!simple_iv (loop, stmt, op1, &base1, &step1))\n+    return false;\n+\n+  niter->niter = NULL_TREE;\n+  number_of_iterations_cond (type, base0, step0, code, base1, step1,\n+\t\t\t     niter);\n+  if (!niter->niter)\n+    return false;\n+\n+  niter->assumptions = simplify_using_outer_evolutions (loop,\n+\t\t\t\t\t\t\tniter->assumptions);\n+  niter->may_be_zero = simplify_using_outer_evolutions (loop,\n+\t\t\t\t\t\t\tniter->may_be_zero);\n+  niter->niter = simplify_using_outer_evolutions (loop, niter->niter);\n+\n+  niter->additional_info = boolean_true_node;\n+  niter->assumptions\n+\t  = simplify_using_initial_conditions (loop,\n+\t\t\t\t\t       niter->assumptions,\n+\t\t\t\t\t       &niter->additional_info);\n+  niter->may_be_zero\n+\t  = simplify_using_initial_conditions (loop,\n+\t\t\t\t\t       niter->may_be_zero,\n+\t\t\t\t\t       &niter->additional_info);\n+  return integer_onep (niter->assumptions);\n+}\n+\n+/*\n+\n+   Analysis of a number of iterations of a loop by a brute-force evaluation.\n+\n+*/\n+\n+/* Bound on the number of iterations we try to evaluate.  */\n+\n+#define MAX_ITERATIONS_TO_TRACK \\\n+  ((unsigned) PARAM_VALUE (PARAM_MAX_ITERATIONS_TO_TRACK))\n+\n+/* Returns the loop phi node of LOOP such that ssa name X is derived from its\n+   result by a chain of operations such that all but exactly one of their\n+   operands are constants.  */\n+\n+static tree\n+chain_of_csts_start (struct loop *loop, tree x)\n+{\n+  tree stmt = SSA_NAME_DEF_STMT (x);\n+  basic_block bb = bb_for_stmt (stmt);\n+  use_optype uses;\n+\n+  if (!bb\n+      || !flow_bb_inside_loop_p (loop, bb))\n+    return NULL_TREE;\n+  \n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    {\n+      if (bb == loop->header)\n+\treturn stmt;\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return NULL_TREE;\n+\n+  get_stmt_operands (stmt);\n+  if (NUM_VUSES (STMT_VUSE_OPS (stmt)) > 0)\n+    return NULL_TREE;\n+  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0)\n+    return NULL_TREE;\n+  if (NUM_V_MUST_DEFS (STMT_V_MUST_DEF_OPS (stmt)) > 0)\n+    return NULL_TREE;\n+  if (NUM_DEFS (STMT_DEF_OPS (stmt)) > 1)\n+    return NULL_TREE;\n+  uses = STMT_USE_OPS (stmt);\n+  if (NUM_USES (uses) != 1)\n+    return NULL_TREE;\n+\n+  return chain_of_csts_start (loop, USE_OP (uses, 0));\n+}\n+\n+/* Determines whether the expression X is derived from a result of a phi node\n+   in header of LOOP such that\n+\n+   * the derivation of X consists only from operations with constants\n+   * the initial value of the phi node is constant\n+   * the value of the phi node in the next iteration can be derived from the\n+     value in the current iteration by a chain of operations with constants.\n+   \n+   If such phi node exists, it is returned.  If X is a constant, X is returned\n+   unchanged.  Otherwise NULL_TREE is returned.  */\n+\n+static tree\n+get_base_for (struct loop *loop, tree x)\n+{\n+  tree phi, init, next;\n+\n+  if (is_gimple_min_invariant (x))\n+    return x;\n+\n+  phi = chain_of_csts_start (loop, x);\n+  if (!phi)\n+    return NULL_TREE;\n+\n+  init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n+  next = PHI_ARG_DEF_FROM_EDGE (phi, loop_latch_edge (loop));\n+\n+  if (TREE_CODE (next) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  if (!is_gimple_min_invariant (init))\n+    return NULL_TREE;\n+\n+  if (chain_of_csts_start (loop, next) != phi)\n+    return NULL_TREE;\n+\n+  return phi;\n+}\n+\n+/* Given an expression X, then \n+ \n+   * if BASE is NULL_TREE, X must be a constant and we return X.\n+   * otherwise X is a SSA name, whose value in the considered loop is derived\n+     by a chain of operations with constant from a result of a phi node in\n+     the header of the loop.  Then we return value of X when the value of the\n+     result of this phi node is given by the constant BASE.  */\n+\n+static tree\n+get_val_for (tree x, tree base)\n+{\n+  tree stmt, nx, val;\n+  use_optype uses;\n+  use_operand_p op;\n+\n+  if (!x)\n+    return base;\n+\n+  stmt = SSA_NAME_DEF_STMT (x);\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return base;\n+\n+  uses = STMT_USE_OPS (stmt);\n+  op = USE_OP_PTR (uses, 0);\n+\n+  nx = USE_FROM_PTR (op);\n+  val = get_val_for (nx, base);\n+  SET_USE (op, val);\n+  val = fold (TREE_OPERAND (stmt, 1));\n+  SET_USE (op, nx);\n+\n+  return val;\n+}\n+\n+/* Tries to count the number of iterations of LOOP till it exits by EXIT\n+   by brute force -- i.e. by determining the value of the operands of the\n+   condition at EXIT in first few iterations of the loop (assuming that\n+   these values are constant) and determining the first one in that the\n+   condition is not satisfied.  Returns the constant giving the number\n+   of the iterations of LOOP if successful, chrec_dont_know otherwise.  */\n+\n+tree\n+loop_niter_by_eval (struct loop *loop, edge exit)\n+{\n+  tree cond, cnd, acnd;\n+  tree op[2], val[2], next[2], aval[2], phi[2];\n+  unsigned i, j;\n+  enum tree_code cmp;\n+\n+  cond = last_stmt (exit->src);\n+  if (!cond || TREE_CODE (cond) != COND_EXPR)\n+    return chrec_dont_know;\n+\n+  cnd = COND_EXPR_COND (cond);\n+  if (exit->flags & EDGE_TRUE_VALUE)\n+    cnd = invert_truthvalue (cnd);\n+\n+  cmp = TREE_CODE (cnd);\n+  switch (cmp)\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      for (j = 0; j < 2; j++)\n+\top[j] = TREE_OPERAND (cnd, j);\n+      break;\n+\n+    default:\n+      return chrec_dont_know;\n+    }\n+\n+  for (j = 0; j < 2; j++)\n+    {\n+      phi[j] = get_base_for (loop, op[j]);\n+      if (!phi[j])\n+\treturn chrec_dont_know;\n+    }\n+\n+  for (j = 0; j < 2; j++)\n+    {\n+      if (TREE_CODE (phi[j]) == PHI_NODE)\n+\t{\n+\t  val[j] = PHI_ARG_DEF_FROM_EDGE (phi[j], loop_preheader_edge (loop));\n+\t  next[j] = PHI_ARG_DEF_FROM_EDGE (phi[j], loop_latch_edge (loop));\n+\t}\n+      else\n+\t{\n+\t  val[j] = phi[j];\n+\t  next[j] = NULL_TREE;\n+\t  op[j] = NULL_TREE;\n+\t}\n+    }\n+\n+  for (i = 0; i < MAX_ITERATIONS_TO_TRACK; i++)\n+    {\n+      for (j = 0; j < 2; j++)\n+\taval[j] = get_val_for (op[j], val[j]);\n+\n+      acnd = fold (build (cmp, boolean_type_node, aval[0], aval[1]));\n+      if (integer_zerop (acnd))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Proved that loop %d iterates %d times using brute force.\\n\",\n+\t\t     loop->num, i);\n+\t  return build_int_2 (i, 0);\n+\t}\n+\n+      for (j = 0; j < 2; j++)\n+\tval[j] = get_val_for (next[j], val[j]);\n+    }\n+\n+  return chrec_dont_know;\n+}\n+\n+/* Finds the exit of the LOOP by that the loop exits after a constant\n+   number of iterations and stores the exit edge to *EXIT.  The constant\n+   giving the number of iterations of LOOP is returned.  The number of\n+   iterations is determined using loop_niter_by_eval (i.e. by brute force\n+   evaluation).  If we are unable to find the exit for that loop_niter_by_eval\n+   determines the number of iterations, chrec_dont_know is returned.  */\n+\n+tree\n+find_loop_niter_by_eval (struct loop *loop, edge *exit)\n+{\n+  unsigned n_exits, i;\n+  edge *exits = get_loop_exit_edges (loop, &n_exits);\n+  edge ex;\n+  tree niter = NULL_TREE, aniter;\n+\n+  *exit = NULL;\n+  for (i = 0; i < n_exits; i++)\n+    {\n+      ex = exits[i];\n+      if (!just_once_each_iteration_p (loop, ex->src))\n+\tcontinue;\n+\n+      aniter = loop_niter_by_eval (loop, ex);\n+      if (chrec_contains_undetermined (aniter)\n+\t  || TREE_CODE (aniter) != INTEGER_CST)\n+\tcontinue;\n+\n+      if (niter\n+\t  && !integer_nonzerop (fold (build (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t     aniter, niter))))\n+\tcontinue;\n+\n+      niter = aniter;\n+      *exit = ex;\n+    }\n+  free (exits);\n+\n+  return niter ? niter : chrec_dont_know;\n+}\n+\n+/*\n+\n+   Analysis of upper bounds on number of iterations of a loop.\n+\n+*/\n+\n+/* The structure describing a bound on number of iterations of a loop.  */\n+\n+struct nb_iter_bound\n+{\n+  tree bound;\t\t/* The expression whose value is an upper bound on the\n+\t\t\t   number of executions of anything after ...  */\n+  tree at_stmt;\t\t/* ... this statement during one execution of loop.  */\n+  tree additional;\t/* A conjunction of conditions the operands of BOUND\n+\t\t\t   satisfy.  The additional information about the value\n+\t\t\t   of the bound may be derived from it.  */\n+  struct nb_iter_bound *next;\n+\t\t\t/* The next bound in a list.  */\n+};\n+\n+/* Records that AT_STMT is executed at most BOUND times in LOOP.  The\n+   additional condition ADDITIONAL is recorded with the bound.  */\n+\n+static void\n+record_estimate (struct loop *loop, tree bound, tree additional, tree at_stmt)\n+{\n+  struct nb_iter_bound *elt = xmalloc (sizeof (struct nb_iter_bound));\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Statements after \");\n+      print_generic_expr (dump_file, at_stmt, TDF_SLIM);\n+      fprintf (dump_file, \" are executed at most \");\n+      print_generic_expr (dump_file, bound, TDF_SLIM);\n+      fprintf (dump_file, \" times in loop %d.\\n\", loop->num);\n+    }\n+\n+  elt->bound = bound;\n+  elt->at_stmt = at_stmt;\n+  elt->additional = additional;\n+  elt->next = loop->bounds;\n+  loop->bounds = elt;\n+}\n+\n+/* Records estimates on numbers of iterations of LOOP.  */\n+\n+static void\n+estimate_numbers_of_iterations_loop (struct loop *loop)\n+{\n+  edge *exits;\n+  tree niter, type;\n+  unsigned i, n_exits;\n+  struct tree_niter_desc niter_desc;\n+\n+  exits = get_loop_exit_edges (loop, &n_exits);\n+  for (i = 0; i < n_exits; i++)\n+    {\n+      if (!number_of_iterations_exit (loop, exits[i], &niter_desc))\n+\tcontinue;\n+\n+      niter = niter_desc.niter;\n+      type = TREE_TYPE (niter);\n+      if (!integer_zerop (niter_desc.may_be_zero)\n+\t  && !integer_nonzerop (niter_desc.may_be_zero))\n+\tniter = build (COND_EXPR, type, niter_desc.may_be_zero,\n+\t\t       convert (type, integer_zero_node),\n+\t\t       niter);\n+      record_estimate (loop, niter,\n+\t\t       niter_desc.additional_info,\n+\t\t       last_stmt (exits[i]->src));\n+    }\n+  free (exits);\n+  \n+  /* TODO Here we could use other possibilities, like bounds of arrays accessed\n+     in the loop.  */\n+}\n+\n+/* Records estimates on numbers of iterations of LOOPS.  */\n+\n+void\n+estimate_numbers_of_iterations (struct loops *loops)\n+{\n+  unsigned i;\n+  struct loop *loop;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (loop)\n+\testimate_numbers_of_iterations_loop (loop);\n+    }\n+}\n+\n+/* If A > B, returns -1.  If A == B, returns 0.  If A < B, returns 1.\n+   If neither of these relations can be proved, returns 2.  */\n+\n+static int\n+compare_trees (tree a, tree b)\n+{\n+  tree typea = TREE_TYPE (a), typeb = TREE_TYPE (b);\n+  tree type;\n+\n+  if (TYPE_PRECISION (typea) > TYPE_PRECISION (typeb))\n+    type = typea;\n+  else\n+    type = typeb;\n+\n+  a = convert (type, a);\n+  b = convert (type, b);\n+\n+  if (integer_nonzerop (fold (build (EQ_EXPR, boolean_type_node, a, b))))\n+    return 0;\n+  if (integer_nonzerop (fold (build (LT_EXPR, boolean_type_node, a, b))))\n+    return 1;\n+  if (integer_nonzerop (fold (build (GT_EXPR, boolean_type_node, a, b))))\n+    return -1;\n+\n+  return 2;\n+}\n+\n+/* Returns the largest value obtainable by casting something in INNER type to\n+   OUTER type.  */\n+\n+tree\n+upper_bound_in_type (tree outer, tree inner)\n+{\n+  unsigned HOST_WIDE_INT lo, hi;\n+  unsigned bits = TYPE_PRECISION (inner);\n+\n+  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n+    {\n+      /* Zero extending in these cases.  */\n+      if (bits <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  hi = 0;\n+\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (HOST_BITS_PER_WIDE_INT - bits);\n+\t}\n+      else\n+\t{\n+\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits);\n+\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n+\t}\n+    }\n+  else\n+    {\n+      /* Sign extending in these cases.  */\n+      if (bits <= HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  hi = 0;\n+\t  lo = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (HOST_BITS_PER_WIDE_INT - bits) >> 1;\n+\t}\n+      else\n+\t{\n+\t  hi = (~(unsigned HOST_WIDE_INT) 0)\n+\t\t  >> (2 * HOST_BITS_PER_WIDE_INT - bits) >> 1;\n+\t  lo = ~(unsigned HOST_WIDE_INT) 0;\n+\t}\n+    }\n+\n+  return convert (outer,\n+\t\t  convert (inner,\n+\t\t\t   build_int_2 (lo, hi)));\n+}\n+\n+/* Returns the smallest value obtainable by casting something in INNER type to\n+   OUTER type.  */\n+\n+tree\n+lower_bound_in_type (tree outer, tree inner)\n+{\n+  unsigned HOST_WIDE_INT lo, hi;\n+  unsigned bits = TYPE_PRECISION (inner);\n+\n+  if (TYPE_UNSIGNED (outer) || TYPE_UNSIGNED (inner))\n+    lo = hi = 0;\n+  else if (bits <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      hi = ~(unsigned HOST_WIDE_INT) 0;\n+      lo = (~(unsigned HOST_WIDE_INT) 0) << (bits - 1);\n+    }\n+  else\n+    {\n+      hi = (~(unsigned HOST_WIDE_INT) 0) << (bits - HOST_BITS_PER_WIDE_INT - 1);\n+      lo = 0;\n+    }\n+\n+  return convert (outer,\n+\t\t  convert (inner,\n+\t\t\t   build_int_2 (lo, hi)));\n+}\n+\n+/* Returns true if statement S1 dominates statement S2.  */\n+\n+static bool\n+stmt_dominates_stmt_p (tree s1, tree s2)\n+{\n+  basic_block bb1 = bb_for_stmt (s1), bb2 = bb_for_stmt (s2);\n+\n+  if (!bb1\n+      || s1 == s2)\n+    return true;\n+\n+  if (bb1 == bb2)\n+    {\n+      block_stmt_iterator bsi;\n+\n+      for (bsi = bsi_start (bb1); bsi_stmt (bsi) != s2; bsi_next (&bsi))\n+\tif (bsi_stmt (bsi) == s1)\n+\t  return true;\n+\n+      return false;\n+    }\n+\n+  return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n+}\n+\n+/* Checks whether it is correct to count the induction variable BASE + STEP * I\n+   at AT_STMT in wider TYPE, using the fact that statement OF is executed at\n+   most BOUND times in the loop.  If it is possible, return the value of step\n+   of the induction variable in the TYPE, otherwise return NULL_TREE.\n+   \n+   ADDITIONAL is the additional condition recorded for operands of the bound.\n+   This is useful in the following case, created by loop header copying:\n+\n+   i = 0;\n+   if (n > 0)\n+     do\n+       {\n+         something;\n+       } while (++i < n)\n+\n+   If the n > 0 condition is taken into account, the number of iterations of the\n+   loop can be expressed as n - 1.  If the type of n is signed, the ADDITIONAL\n+   assumption \"n > 0\" says us that the value of the number of iterations is at\n+   most MAX_TYPE - 1 (without this assumption, it might overflow).  */\n+\n+static tree\n+can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n+\t\t\t\t  tree at_stmt,\n+\t\t\t\t  tree bound,\n+\t\t\t\t  tree additional,\n+\t\t\t\t  tree of)\n+{\n+  tree inner_type = TREE_TYPE (base), b, bplusstep, new_step, new_step_abs;\n+  tree valid_niter, extreme, unsigned_type, delta, bound_type;\n+  tree cond;\n+\n+  b = convert (type, base);\n+  bplusstep = convert (type,\n+\t\t       fold (build (PLUS_EXPR, inner_type, base, step)));\n+  new_step = fold (build (MINUS_EXPR, type, bplusstep, b));\n+  if (TREE_CODE (new_step) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  switch (compare_trees (bplusstep, b))\n+    {\n+    case -1:\n+      extreme = upper_bound_in_type (type, inner_type);\n+      delta = fold (build (MINUS_EXPR, type, extreme, b));\n+      new_step_abs = new_step;\n+      break;\n+\n+    case 1:\n+      extreme = lower_bound_in_type (type, inner_type);\n+      new_step_abs = fold (build (NEGATE_EXPR, type, new_step));\n+      delta = fold (build (MINUS_EXPR, type, b, extreme));\n+      break;\n+\n+    case 0:\n+      return new_step;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  unsigned_type = unsigned_type_for (type);\n+  delta = convert (unsigned_type, delta);\n+  new_step_abs = convert (unsigned_type, new_step_abs);\n+  valid_niter = fold (build (FLOOR_DIV_EXPR, unsigned_type,\n+\t\t\t     delta, new_step_abs));\n+\n+  bound_type = TREE_TYPE (bound);\n+  if (TYPE_PRECISION (type) > TYPE_PRECISION (bound_type))\n+    bound = convert (unsigned_type, bound);\n+  else\n+    valid_niter = convert (bound_type, valid_niter);\n+    \n+  if (at_stmt && stmt_dominates_stmt_p (of, at_stmt))\n+    {\n+      /* After the statement OF we know that anything is executed at most\n+\t BOUND times.  */\n+      cond = build (GE_EXPR, boolean_type_node, valid_niter, bound);\n+    }\n+  else\n+    {\n+      /* Before the statement OF we know that anything is executed at most\n+\t BOUND + 1 times.  */\n+      cond = build (GT_EXPR, boolean_type_node, valid_niter, bound);\n+    }\n+\n+  cond = fold (cond);\n+  if (integer_nonzerop (cond))\n+    return new_step;\n+\n+  /* Try taking additional conditions into account.  */\n+  cond = build (TRUTH_OR_EXPR, boolean_type_node,\n+\t\tinvert_truthvalue (additional),\n+\t\tcond);\n+  cond = fold (cond);\n+  if (integer_nonzerop (cond))\n+    return new_step;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Checks whether it is correct to count the induction variable BASE + STEP * I\n+   at AT_STMT in wider TYPE, using the bounds on numbers of iterations of a\n+   LOOP.  If it is possible, return the value of step of the induction variable\n+   in the TYPE, otherwise return NULL_TREE.  */\n+\n+tree\n+can_count_iv_in_wider_type (struct loop *loop, tree type, tree base, tree step,\n+\t\t\t    tree at_stmt)\n+{\n+  struct nb_iter_bound *bound;\n+  tree new_step;\n+\n+  for (bound = loop->bounds; bound; bound = bound->next)\n+    {\n+      new_step = can_count_iv_in_wider_type_bound (type, base, step,\n+\t\t\t\t\t\t   at_stmt,\n+\t\t\t\t\t\t   bound->bound,\n+\t\t\t\t\t\t   bound->additional,\n+\t\t\t\t\t\t   bound->at_stmt);\n+\n+      if (new_step)\n+\treturn new_step;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Frees the information on upper bounds on numbers of iterations of LOOP.  */\n+\n+static void\n+free_numbers_of_iterations_estimates_loop (struct loop *loop)\n+{\n+  struct nb_iter_bound *bound, *next;\n+  \n+  for (bound = loop->bounds; bound; bound = next)\n+    {\n+      next = bound->next;\n+      free (bound);\n+    }\n+\n+  loop->bounds = NULL;\n+}\n+\n+/* Frees the information on upper bounds on numbers of iterations of LOOPS.  */\n+\n+void\n+free_numbers_of_iterations_estimates (struct loops *loops)\n+{\n+  unsigned i;\n+  struct loop *loop;\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      loop = loops->parray[i];\n+      if (loop)\n+\tfree_numbers_of_iterations_estimates_loop (loop);\n+    }\n+}"}, {"sha": "ac13f1234628dcfd4850a790bc91e1a5543f9b9a", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "patch": "@@ -3754,4 +3754,9 @@ extern int tree_node_sizes[];\n    restricted to creating gimple expressions.  */\n extern bool in_gimple_form;\n     \n+/* In tree-ssa-loop-niter.c.  */\n+\n+tree lower_bound_in_type (tree, tree);\n+tree upper_bound_in_type (tree, tree);\n+\n #endif  /* GCC_TREE_H  */"}]}