{"sha": "81797aba4d836b687db22cc8cf605e78b0ba6d3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE3OTdhYmE0ZDgzNmI2ODdkYjIyY2M4Y2Y2MDVlNzhiMGJhNmQzZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-06T07:38:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-06T07:38:01Z"}, "message": "loop.c (invariant_p): Don't test flag_rerun_loop_opt.\n\n        * loop.c (invariant_p): Don't test flag_rerun_loop_opt.\n        (loop_optimize, scan_loop, strength_reduce): New argument unroll_p.\n        * toplev.c (rest_of_compilation): Pass it.  Remove code to\n        save / clear / restore flag_unroll_{,all_}loops.\n\n        * i386.c (notice_update_cc): Remove bogus pentium GCC code.\n\n        * stmt.c (warn_if_unused_value): Don't warn for TRY_CATCH_EXPR.\nVarious pending patches.\n\nFrom-SVN: r16973", "tree": {"sha": "7a4cbf1399e77121a2583dbf140547de7417e785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a4cbf1399e77121a2583dbf140547de7417e785"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81797aba4d836b687db22cc8cf605e78b0ba6d3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81797aba4d836b687db22cc8cf605e78b0ba6d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81797aba4d836b687db22cc8cf605e78b0ba6d3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81797aba4d836b687db22cc8cf605e78b0ba6d3f/comments", "author": null, "committer": null, "parents": [{"sha": "a58248fa8a1efab68d49eb51f48821864be2e77a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58248fa8a1efab68d49eb51f48821864be2e77a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58248fa8a1efab68d49eb51f48821864be2e77a"}], "stats": {"total": 72, "additions": 33, "deletions": 39}, "files": [{"sha": "0ba530a3c7177f7891b4af5ef93edb3fe0d0f4d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81797aba4d836b687db22cc8cf605e78b0ba6d3f", "patch": "@@ -1,3 +1,18 @@\n+Fri Dec  5 18:26:25 1997  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (invariant_p): Don't test flag_rerun_loop_opt.\n+\t(loop_optimize, scan_loop, strength_reduce): New argument unroll_p.\n+\t* toplev.c (rest_of_compilation): Pass it.  Remove code to\n+\tsave / clear / restore flag_unroll_{,all_}loops.\n+\n+Fri Dec  5 16:26:03 1997  Bernd Schmidt <crux@ohara.Informatik.RWTH-Aachen.DE>\n+\n+\t* i386.c (notice_update_cc): Remove bogus pentium GCC code.\n+\n+Fri Dec  5 16:25:14 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* stmt.c (warn_if_unused_value): Don't warn for TRY_CATCH_EXPR.\n+\n Thu Dec  4 11:51:00 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* except.c (get_dynamic_handler_chain): Only make the call once per"}, {"sha": "fc10a9c9092a460badf1bfc49b5703af4b1b43e5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=81797aba4d836b687db22cc8cf605e78b0ba6d3f", "patch": "@@ -3543,15 +3543,6 @@ notice_update_cc (exp)\n       if (SET_DEST (exp) == pc_rtx)\n \treturn;\n \n-#ifdef IS_STACK_MODE\n-      /* Moving into a memory of stack_mode may have been moved\n-         in between the use and set of cc0 by loop_spl(). So\n-         old value of cc.status must be retained */\n-      if (GET_CODE(SET_DEST(exp)) == MEM \n-\t  && IS_STACK_MODE (GET_MODE (SET_DEST (exp))))\n-\treturn;\n-#endif\n-\n       /* Moving register or memory into a register:\n \t it doesn't alter the cc's, but it might invalidate\n \t the RTX's which we remember the cc's came from."}, {"sha": "cd086ac323915b1e2f403eb327c6cdbaf532543f", "filename": "gcc/f/intdoc.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Ff%2Fintdoc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Ff%2Fintdoc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.texi?ref=81797aba4d836b687db22cc8cf605e78b0ba6d3f", "patch": "@@ -6355,7 +6355,7 @@ Int2(@var{A})\n Int2: @code{INTEGER(KIND=6)} function.\n \n @noindent\n-@var{A}: @code{INTEGER}; scalar; INTENT(IN).\n+@var{A}: @code{INTEGER}, @code{REAL}, or @code{COMPLEX}; scalar; INTENT(IN).\n \n @noindent\n Intrinsic groups: @code{gnu}.\n@@ -6390,7 +6390,7 @@ Int8(@var{A})\n Int8: @code{INTEGER(KIND=2)} function.\n \n @noindent\n-@var{A}: @code{INTEGER}; scalar; INTENT(IN).\n+@var{A}: @code{INTEGER}, @code{REAL}, or @code{COMPLEX}; scalar; INTENT(IN).\n \n @noindent\n Intrinsic groups: @code{gnu}."}, {"sha": "6c0d00da3ec8db5e862ff203c751521d09b95e4b", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=81797aba4d836b687db22cc8cf605e78b0ba6d3f", "patch": "@@ -374,10 +374,11 @@ init_loop ()\n    (or 0 if none should be output).  */\n \n void\n-loop_optimize (f, dumpfile)\n+loop_optimize (f, dumpfile, unroll_p)\n      /* f is the first instruction of a chain of insns for one function */\n      rtx f;\n      FILE *dumpfile;\n+     int unroll_p;\n {\n   register rtx insn;\n   register int i;\n@@ -502,7 +503,7 @@ loop_optimize (f, dumpfile)\n       uid_luid[i] = uid_luid[i - 1];\n \n   /* Create a mapping from loops to BLOCK tree nodes.  */\n-  if (flag_unroll_loops && write_symbols != NO_DEBUG)\n+  if (unroll_p && write_symbols != NO_DEBUG)\n     find_loop_tree_blocks ();\n \n   /* Determine if the function has indirect jump.  On some systems\n@@ -514,12 +515,12 @@ loop_optimize (f, dumpfile)\n   for (i = max_loop_num-1; i >= 0; i--)\n     if (! loop_invalid[i] && loop_number_loop_ends[i])\n       scan_loop (loop_number_loop_starts[i], loop_number_loop_ends[i],\n-\t\t max_reg_num ());\n+\t\t max_reg_num (), unroll_p);\n \n   /* If debugging and unrolling loops, we must replicate the tree nodes\n      corresponding to the blocks inside the loop, so that the original one\n      to one mapping will remain.  */\n-  if (flag_unroll_loops && write_symbols != NO_DEBUG)\n+  if (unroll_p && write_symbols != NO_DEBUG)\n     unroll_block_trees ();\n }\n \f\n@@ -534,9 +535,10 @@ loop_optimize (f, dumpfile)\n    write, then we can also mark the memory read as invariant.  */\n \n static void\n-scan_loop (loop_start, end, nregs)\n+scan_loop (loop_start, end, nregs, unroll_p)\n      rtx loop_start, end;\n      int nregs;\n+     int unroll_p;\n {\n   register int i;\n   register rtx p;\n@@ -1051,7 +1053,7 @@ scan_loop (loop_start, end, nregs)\n \n   if (flag_strength_reduce)\n     strength_reduce (scan_start, end, loop_top,\n-\t\t     insn_count, loop_start, end);\n+\t\t     insn_count, loop_start, end, unroll_p);\n }\n \f\n /* Add elements to *OUTPUT to record all the pseudo-regs\n@@ -2847,12 +2849,7 @@ invariant_p (x)\n \n \t We don't know the loop bounds here though, so just fail for all\n \t labels.  */\n-      /* ??? This is also necessary if flag_rerun_loop_opt is true, because in\n-\t this case we may be doing loop unrolling the second time we run loop,\n-\t and hence the first loop run also needs this check.  There is no way\n-\t to check here whether the second run will actually do loop unrolling\n-\t though, as that info is in a local var in rest_of_compilation.  */\n-      if (flag_unroll_loops || flag_rerun_loop_opt)\n+      if (flag_unroll_loops)\n \treturn 0;\n       else\n \treturn 1;\n@@ -3339,13 +3336,14 @@ static rtx addr_placeholder;\n \n static void\n strength_reduce (scan_start, end, loop_top, insn_count,\n-\t\t loop_start, loop_end)\n+\t\t loop_start, loop_end, unroll_p)\n      rtx scan_start;\n      rtx end;\n      rtx loop_top;\n      int insn_count;\n      rtx loop_start;\n      rtx loop_end;\n+     int unroll_p;\n {\n   rtx p;\n   rtx set;\n@@ -3583,7 +3581,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n     {\n       /* Can still unroll the loop anyways, but indicate that there is no\n \t strength reduction info available.  */\n-      if (flag_unroll_loops)\n+      if (unroll_p)\n \tunroll_loop (loop_end, insn_count, loop_start, end_insert_before, 0);\n \n       return;\n@@ -4362,7 +4360,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      induction variable information that strength_reduce has already\n      collected.  */\n   \n-  if (flag_unroll_loops)\n+  if (unroll_p)\n     unroll_loop (loop_end, insn_count, loop_start, end_insert_before, 1);\n \n #ifdef HAIFA"}, {"sha": "9810ddbc010926dfca5f745f4945a72c0596bac9", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=81797aba4d836b687db22cc8cf605e78b0ba6d3f", "patch": "@@ -1873,6 +1873,7 @@ warn_if_unused_value (exp)\n     case CALL_EXPR:\n     case METHOD_CALL_EXPR:\n     case RTL_EXPR:\n+    case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n     case EXIT_EXPR:\n       /* We don't warn about COND_EXPR because it may be a useful"}, {"sha": "4e50173718fa43e06cb8d0a6133cb759d00db12d", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81797aba4d836b687db22cc8cf605e78b0ba6d3f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=81797aba4d836b687db22cc8cf605e78b0ba6d3f", "patch": "@@ -3313,28 +3313,17 @@ rest_of_compilation (decl)\n     {\n       TIMEVAR (loop_time,\n \t       {\n-\t\t int save_flag_unroll_loops;\n-\t\t int save_flag_unroll_all_loops;\n-\n \t\t if (flag_rerun_loop_opt)\n \t\t   {\n \t\t      /* We only want to perform unrolling once.  */\n-\t\t      save_flag_unroll_loops = flag_unroll_loops;\n-\t\t      save_flag_unroll_all_loops = flag_unroll_all_loops;\n-\t\t      flag_unroll_loops = 0;\n-\t\t      flag_unroll_all_loops = 0;\n \n-\t\t      loop_optimize (insns, loop_dump_file);\n+\t\t      loop_optimize (insns, loop_dump_file, 0);\n \n \t\t      /* The regscan pass may not be necessary, but let's\n \t\t\t be safe until we can prove otherwise.  */\n \t\t      reg_scan (insns, max_reg_num (), 1);\n-\n-\t\t      /* Restore loop unrolling flags.  */\n-\t\t      flag_unroll_loops = save_flag_unroll_loops;\n-\t\t      flag_unroll_all_loops = save_flag_unroll_all_loops;\n \t\t   }\n-\t\t loop_optimize (insns, loop_dump_file);\n+\t\t loop_optimize (insns, loop_dump_file, flag_unroll_loops);\n \t       });\n     }\n "}]}