{"sha": "b4661bfe214bf5ae119c511f994336ccc3fe144c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2NjFiZmUyMTRiZjVhZTExOWM1MTFmOTk0MzM2Y2NjM2ZlMTQ0Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-09T17:29:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-09T17:29:21Z"}, "message": "passes.c (ipa_write_summaries_1): Set state; do not call compute_ltrans_boundary.\n\n\n\n\t* passes.c (ipa_write_summaries_1): Set state;\n\tdo not call compute_ltrans_boundary.\n\t(ipa_write_optimization_summaries): Likewise.\n\t(ipa_write_summaries): compute_ltrans_boundary here.\n\t* lto-streamer.h (lto_symtab_encoder_d): NODES are allocated in heap.\n\t(compute_ltrans_boundary): Update prototype.\n\n\t* lto.c (lto_wpa_write_files): Do not delete partition encoder;\n\tit is deleted after streaming.\n\t* lto-partition.c (partition_symbol_p): New function.\n\t(promote_var, promote_fn): Remove.\n\t(promote_symbol): New function.\n\t(lto_promote_cross_file_statics): First compute boundaries; rewrite\n\tto lookup the actual boundaries instead of computing them ad-hoc.\n\nFrom-SVN: r191113", "tree": {"sha": "267374ed574354532c002262d01eab0c5d4195fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/267374ed574354532c002262d01eab0c5d4195fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4661bfe214bf5ae119c511f994336ccc3fe144c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4661bfe214bf5ae119c511f994336ccc3fe144c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4661bfe214bf5ae119c511f994336ccc3fe144c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4661bfe214bf5ae119c511f994336ccc3fe144c/comments", "author": null, "committer": null, "parents": [{"sha": "3ca6351daa2a4e90af9a97085f8fa316b6ede57f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca6351daa2a4e90af9a97085f8fa316b6ede57f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca6351daa2a4e90af9a97085f8fa316b6ede57f"}], "stats": {"total": 288, "additions": 118, "deletions": 170}, "files": [{"sha": "3307a6688ac87c7bf529f9cf123292e6eea9a4c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -1,3 +1,12 @@\n+2012-09-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* passes.c (ipa_write_summaries_1): Set state;\n+\tdo not call compute_ltrans_boundary.\n+\t(ipa_write_optimization_summaries): Likewise.\n+\t(ipa_write_summaries): compute_ltrans_boundary here.\n+\t* lto-streamer.h (lto_symtab_encoder_d): NODES are allocated in heap.\n+\t(compute_ltrans_boundary): Update prototype.\n+\n 2012-09-09  Ulrich Drepper  <drepper@gmail.com>\n \n \t* config/i386/cpuid.h: Define signature_*_e[bcd]x macros for"}, {"sha": "300e5714e6638d37b0a2e05fb7fd8b9e10cf7a25", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -588,38 +588,6 @@ output_profile_summary (struct lto_simple_output_block *ob)\n     streamer_write_uhwi_stream (ob->main_stream, 0);\n }\n \n-/* Add NODE into encoder as well as nodes it is cloned from.\n-   Do it in a way so clones appear first.  */\n-\n-static void\n-add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n-\t     bool include_body)\n-{\n-  if (node->clone_of)\n-    add_node_to (encoder, node->clone_of, include_body);\n-  else if (include_body)\n-    lto_set_symtab_encoder_encode_body (encoder, node);\n-  lto_symtab_encoder_encode (encoder, (symtab_node)node);\n-}\n-\n-/* Add all references in LIST to encoders.  */\n-\n-static void\n-add_references (lto_symtab_encoder_t encoder,\n-\t\tstruct ipa_ref_list *list)\n-{\n-  int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n-    if (symtab_function_p (ref->referred))\n-      add_node_to (encoder, ipa_ref_node (ref), false);\n-    else\n-      {\n-\tstruct varpool_node *vnode = ipa_ref_varpool_node (ref);\n-        lto_symtab_encoder_encode (encoder, (symtab_node)vnode);\n-      }\n-}\n-\n /* Output all callees or indirect outgoing edges.  EDGE must be the first such\n    edge.  */\n \n@@ -674,19 +642,56 @@ output_refs (lto_symtab_encoder_t encoder)\n   lto_destroy_simple_output_block (ob);\n }\n \n-/* Find out all cgraph and varpool nodes we want to encode in current unit\n-   and insert them to encoders.  */\n-void\n-compute_ltrans_boundary (struct lto_out_decl_state *state,\n-\t\t\t lto_symtab_encoder_t in_encoder)\n+/* Add NODE into encoder as well as nodes it is cloned from.\n+   Do it in a way so clones appear first.  */\n+\n+static void\n+add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n+\t     bool include_body)\n+{\n+  if (node->clone_of)\n+    add_node_to (encoder, node->clone_of, include_body);\n+  else if (include_body)\n+    lto_set_symtab_encoder_encode_body (encoder, node);\n+  lto_symtab_encoder_encode (encoder, (symtab_node)node);\n+}\n+\n+/* Add all references in LIST to encoders.  */\n+\n+static void\n+add_references (lto_symtab_encoder_t encoder,\n+\t\tstruct ipa_ref_list *list)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+    if (symtab_function_p (ref->referred))\n+      add_node_to (encoder, ipa_ref_node (ref), false);\n+    else\n+      {\n+\tstruct varpool_node *vnode = ipa_ref_varpool_node (ref);\n+        lto_symtab_encoder_encode (encoder, (symtab_node)vnode);\n+      }\n+}\n+\n+/* Find all symbols we want to stream into given partition and insert them\n+   to encoders.\n+\n+   The function actually replaces IN_ENCODER by new one.  The reason is that\n+   streaming code needs clone's origin to be streamed before clone.  This\n+   means that we need to insert the nodes in specific order.  This order is\n+   ignored by the partitioning logic earlier.  */\n+\n+lto_symtab_encoder_t \n+compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n   int i;\n   lto_symtab_encoder_t encoder;\n   lto_symtab_encoder_iterator lsei;\n \n-  encoder = state->symtab_node_encoder = lto_symtab_encoder_new ();\n+  encoder = lto_symtab_encoder_new ();\n \n   /* Go over all entries in the IN_ENCODER and duplicate them to\n      ENCODER. At the same time insert masters of clones so\n@@ -747,6 +752,8 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n \t    }\n \t}\n     }\n+ lto_symtab_encoder_delete (in_encoder);\n+ return encoder;\n }\n \n /* Output the part of the symtab in SET and VSET.  */"}, {"sha": "cab5906e0268efc776d591ff143a52d3686865ed", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -441,7 +441,7 @@ DEF_VEC_ALLOC_O(lto_encoder_entry, heap);\n /* Encoder data structure used to stream callgraph nodes.  */\n struct lto_symtab_encoder_d\n {\n-  VEC(lto_encoder_entry,gc) *nodes;\n+  VEC(lto_encoder_entry,heap) *nodes;\n   pointer_map_t *map;\n };\n \n@@ -856,8 +856,7 @@ bool referenced_from_this_partition_p (struct ipa_ref_list *,\n \t\t\t\t\tlto_symtab_encoder_t);\n bool reachable_from_this_partition_p (struct cgraph_node *,\n \t\t\t\t      lto_symtab_encoder_t);\n-void compute_ltrans_boundary (struct lto_out_decl_state *state,\n-\t\t\t      lto_symtab_encoder_t encoder);\n+lto_symtab_encoder_t compute_ltrans_boundary (lto_symtab_encoder_t encoder);\n \n \n /* In lto-symtab.c.  */"}, {"sha": "51965c7d0d79bcb9c65b061f17d22d0d63565b94", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -1,3 +1,13 @@\n+2012-08-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_wpa_write_files): Do not delete partition encoder;\n+\tit is deleted after streaming.\n+\t* lto-partition.c (partition_symbol_p): New function.\n+\t(promote_var, promote_fn): Remove.\n+\t(promote_symbol): New function.\n+\t(lto_promote_cross_file_statics): First compute boundaries; rewrite\n+\tto lookup the actual boundaries instead of computing them ad-hoc.\n+\n 2012-08-12  Jan Hubicka  <jh@suse.cz>\n \n \tReplace cgraph_node_set and varpool_node_set by symtab_node_encoder"}, {"sha": "8ec28892d08bea90f38639630a136b4c79631241", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 49, "deletions": 125, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -280,6 +280,18 @@ partition_varpool_node_p (struct varpool_node *vnode)\n   return true;\n }\n \n+/* Return true if NODE should be partitioned. \n+   This means that partitioning algorithm should put NODE into one of partitions. */\n+\n+static bool\n+partition_symbol_p (symtab_node node)\n+{\n+  if (symtab_function_p (node))\n+    return partition_cgraph_node_p (cgraph (node));\n+  else\n+    return partition_varpool_node_p (varpool (node));\n+}\n+\n /* Group cgrah nodes by input files.  This is used mainly for testing\n    right now.  */\n \n@@ -739,158 +751,70 @@ lto_balanced_map (void)\n \n /* Promote variable VNODE to be static.  */\n \n-static bool\n-promote_var (struct varpool_node *vnode)\n+static void\n+promote_symbol (symtab_node node)\n {\n-  if (TREE_PUBLIC (vnode->symbol.decl) || DECL_EXTERNAL (vnode->symbol.decl))\n-    return false;\n-  gcc_assert (flag_wpa);\n-  TREE_PUBLIC (vnode->symbol.decl) = 1;\n-  DECL_VISIBILITY (vnode->symbol.decl) = VISIBILITY_HIDDEN;\n-  DECL_VISIBILITY_SPECIFIED (vnode->symbol.decl) = true;\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n-\t    \"Promoting var as hidden: %s\\n\", varpool_node_name (vnode));\n-  return true;\n-}\n-\n-/* Promote function NODE to be static.  */\n+  /* We already promoted ... */\n+  if (DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_HIDDEN\n+      && DECL_VISIBILITY_SPECIFIED (node->symbol.decl)\n+      && TREE_PUBLIC (node->symbol.decl))\n+    return;\n \n-static bool\n-promote_fn (struct cgraph_node *node)\n-{\n-  gcc_assert (flag_wpa);\n-  if (TREE_PUBLIC (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n-    return false;\n+  gcc_checking_assert (!TREE_PUBLIC (node->symbol.decl)\n+\t\t       && !DECL_EXTERNAL (node->symbol.decl));\n   TREE_PUBLIC (node->symbol.decl) = 1;\n   DECL_VISIBILITY (node->symbol.decl) = VISIBILITY_HIDDEN;\n   DECL_VISIBILITY_SPECIFIED (node->symbol.decl) = true;\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n-\t     \"Promoting function as hidden: %s/%i\\n\",\n-\t     cgraph_node_name (node), node->uid);\n-  return true;\n+\t    \"Promoting as hidden: %s\\n\", symtab_node_name (node));\n }\n \n+\n /* Find out all static decls that need to be promoted to global because\n    of cross file sharing.  This function must be run in the WPA mode after\n    all inlinees are added.  */\n \n void\n lto_promote_cross_file_statics (void)\n {\n-  struct varpool_node *vnode;\n   unsigned i, n_sets;\n-  VEC(varpool_node_ptr, heap) *promoted_initializers = NULL;\n-  struct pointer_set_t *inserted = pointer_set_create ();\n-  lto_symtab_encoder_iterator lsei;\n-  lto_symtab_encoder_t encoder;\n \n   gcc_assert (flag_wpa);\n \n+  /* First compute boundaries.  */\n   n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n   for (i = 0; i < n_sets; i++)\n     {\n       ltrans_partition part\n \t= VEC_index (ltrans_partition, ltrans_partitions, i);\n-      encoder = part->encoder;\n-\n-      /* If node called or referred to from other partition, it needs to be\n-\t globalized.  */\n-      for (lsei = lsei_start_in_partition (encoder); !lsei_end_p (lsei);\n-\t   lsei_next_in_partition (&lsei))\n-\t{\n-\t  symtab_node node = lsei_node (lsei);\n-\t  if (node->symbol.externally_visible)\n-\t    continue;\n-\t  if (symtab_function_p (node))\n-\t    {\n-\t      struct cgraph_node *cnode = cgraph (node);\n-\t      if (partition_cgraph_node_p (cnode)\n-\t\t  && (referenced_from_other_partition_p (&cnode->symbol.ref_list, encoder)\n-\t\t      || reachable_from_other_partition_p (cnode, encoder)))\n-\t\tpromote_fn (cnode);\n-\t    }\n-\t  else if (symtab_variable_p (node))\n-\t    {\n-\t      vnode = varpool (node);\n-\t      /* Constant pool references use internal labels and thus can not\n-\t\t be made global.  It is sensible to keep those ltrans local to\n-\t\t allow better optimization.  */\n-\t      if (partition_varpool_node_p (vnode)\n-\t\t  && referenced_from_other_partition_p (&vnode->symbol.ref_list,\n-\t\t\t\t\t\t\tencoder))\n-\t\tpromote_var (vnode);\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n+      part->encoder = compute_ltrans_boundary (part->encoder);\n+    }\n \n-      /* We export the initializer of a read-only var into each partition\n-\t referencing the var.  Folding might take declarations from the\n-\t initializer and use them, so everything referenced from the\n-\t initializer can be accessed from this partition after folding.\n+  /* Look at boundaries and promote symbols as needed.  */\n+  for (i = 0; i < n_sets; i++)\n+    {\n+      lto_symtab_encoder_iterator lsei;\n+      lto_symtab_encoder_t encoder;\n+      ltrans_partition part\n+\t= VEC_index (ltrans_partition, ltrans_partitions, i);\n \n-\t This means that we need to promote all variables and functions\n-\t referenced from all initializers of read-only vars referenced\n-\t from this partition that are not in this partition.  This needs\n-\t to be done recursively.  */\n-      FOR_EACH_VARIABLE (vnode)\n-\tif (const_value_known_p (vnode->symbol.decl)\n-\t    && DECL_INITIAL (vnode->symbol.decl)\n-\t    && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)vnode)\n-\t    && referenced_from_this_partition_p (&vnode->symbol.ref_list, encoder)\n-\t    && !pointer_set_insert (inserted, vnode))\n-\tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n-\n-      while (!VEC_empty (varpool_node_ptr, promoted_initializers))\n-\t{\n-\t  int i;\n-\t  struct ipa_ref *ref;\n+      encoder = part->encoder;\n+      for (lsei = lsei_start (encoder); !lsei_end_p (lsei);\n+\t   lsei_next (&lsei))\n+        {\n+          symtab_node node = lsei_node (lsei);\n+\n+\t  /* No need to promote if symbol already is externally visible ... */\n+\t  if (node->symbol.externally_visible\n+ \t      /* ... or if it is part of current partition ... */\n+\t      || lto_symtab_encoder_in_partition_p (encoder, node)\n+\t      /* ... or if we do not partition it. This mean that it will\n+\t\t appear in every partition refernecing it.  */\n+\t      || !partition_symbol_p (node))\n+\t    continue;\n \n-\t  vnode = VEC_pop (varpool_node_ptr, promoted_initializers);\n-\t  for (i = 0;\n-\t       ipa_ref_list_reference_iterate (&vnode->symbol.ref_list, i, ref);\n-\t       i++)\n-\t    {\n-\t      if (symtab_function_p (ref->referred))\n-\t\t{\n-\t\t  struct cgraph_node *n = ipa_ref_node (ref);\n-\t\t  gcc_assert (!n->global.inlined_to);\n-\t\t  if (!n->symbol.externally_visible\n-\t\t      && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)n))\n-\t\t    promote_fn (n);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  struct varpool_node *v = ipa_ref_varpool_node (ref);\n-\t\t  if (lto_symtab_encoder_in_partition_p (encoder, (symtab_node)v))\n-\t\t    continue;\n-\n-\t\t  /* Constant pool references use internal labels and thus\n-\t\t     cannot be made global.  It is sensible to keep those\n-\t\t     ltrans local to allow better optimization.\n-\t\t     Similarly we ship external vars initializers into\n-\t\t     every ltrans unit possibly referring to it.  */\n-\t\t  if (DECL_IN_CONSTANT_POOL (v->symbol.decl)\n-\t\t      || DECL_EXTERNAL (v->symbol.decl))\n-\t\t    {\n-\t\t      if (!pointer_set_insert (inserted, vnode))\n-\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n-\t\t\t\t       promoted_initializers, v);\n-\t\t    }\n-\t\t  else if (!v->symbol.externally_visible && v->analyzed)\n-\t\t    {\n-\t\t      if (promote_var (v)\n-\t\t\t  && DECL_INITIAL (v->symbol.decl)\n-\t\t\t  && const_value_known_p (v->symbol.decl)\n-\t\t\t  && !pointer_set_insert (inserted, vnode))\n-\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n-\t\t\t\t       promoted_initializers, v);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+          promote_symbol (node);\n+        }\n     }\n-  pointer_set_destroy (inserted);\n }"}, {"sha": "3123871cd004a1b2bb1d62bffb20eab69d477266", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -1514,7 +1514,6 @@ lto_wpa_write_files (void)\n \n       lto_set_current_out_file (NULL);\n       lto_obj_file_close (file);\n-      lto_symtab_encoder_delete (part->encoder);\n       part->encoder = NULL;\n \n       len = strlen (temp_filename);"}, {"sha": "e6a4f93adfa318477cffea1c2d0040cfeccd3d8c", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4661bfe214bf5ae119c511f994336ccc3fe144c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b4661bfe214bf5ae119c511f994336ccc3fe144c", "patch": "@@ -2264,7 +2264,7 @@ static void\n ipa_write_summaries_1 (lto_symtab_encoder_t encoder)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n-  compute_ltrans_boundary (state, encoder);\n+  state->symtab_node_encoder = encoder;\n \n   lto_push_out_decl_state (state);\n \n@@ -2324,7 +2324,7 @@ ipa_write_summaries (void)\n     if ((!vnode->alias || vnode->alias_of))\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n \n-  ipa_write_summaries_1 (encoder);\n+  ipa_write_summaries_1 (compute_ltrans_boundary (encoder));\n \n   free (order);\n }\n@@ -2376,7 +2376,7 @@ ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)\n {\n   struct lto_out_decl_state *state = lto_new_out_decl_state ();\n   lto_symtab_encoder_iterator lsei;\n-  compute_ltrans_boundary (state, encoder);\n+  state->symtab_node_encoder = encoder;\n \n   lto_push_out_decl_state (state);\n   for (lsei = lsei_start_function_in_partition (encoder);"}]}