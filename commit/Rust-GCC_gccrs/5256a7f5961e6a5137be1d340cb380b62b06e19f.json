{"sha": "5256a7f5961e6a5137be1d340cb380b62b06e19f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI1NmE3ZjU5NjFlNmE1MTM3YmUxZDM0MGNiMzgwYjYyYjA2ZTE5Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-30T17:48:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-30T17:48:57Z"}, "message": "cp-tree.def (OVERLOAD): Fix comment.\n\n\t* cp-tree.def (OVERLOAD): Fix comment.\n\t* cp-tree.h: Fix comments and whitespace.\n\t* error.c (dump_decl): Use pp_cxx_colon_colon, ovl_scope.\n\t* name-lookup.c (add_decl_to_level): Assert not class.\n\t(check_local_shadow): Use OVL_P.\n\t(pushdecl_with_scope_1): Rename to ...\n\t(do_pushdecl_with_Scope): ... here.\n\t(do_nonmember_using_decl): Use qualified_namespace_lookup return\n\tvalue.\n\t(push_class_level_binding_1): Use OVL_P.\n\t(pushdecl_namespace_level): Use do_pushdecl_with_scope.\n\t(pushtag_1): Rename to ...\n\t(do_pushtag): ... here.  Adjust do_pushdecl_with_scope call.\n\t(pushtag): Adjust.\n\t(store_class_bindings): Do not time here.\n\t* name-lookup.h (pushdecl_outermost_localscope): Reorder.\n\t* pt.c (listify): Declare argvec at point of initialization.\n\nFrom-SVN: r248693", "tree": {"sha": "b301de4f497dcfb4c508ca5a98f65b8dfc86a2a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b301de4f497dcfb4c508ca5a98f65b8dfc86a2a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5256a7f5961e6a5137be1d340cb380b62b06e19f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5256a7f5961e6a5137be1d340cb380b62b06e19f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5256a7f5961e6a5137be1d340cb380b62b06e19f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5256a7f5961e6a5137be1d340cb380b62b06e19f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77d1dbdb4c9d4036d73ba2a3a90aca530a244071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77d1dbdb4c9d4036d73ba2a3a90aca530a244071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77d1dbdb4c9d4036d73ba2a3a90aca530a244071"}], "stats": {"total": 85, "additions": 47, "deletions": 38}, "files": [{"sha": "1e4685f0756d4a850ce614962a49bbae9ae81ef7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -1,5 +1,23 @@\n 2017-05-30  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.def (OVERLOAD): Fix comment.\n+\t* cp-tree.h: Fix comments and whitespace.\n+\t* error.c (dump_decl): Use pp_cxx_colon_colon, ovl_scope.\n+\t* name-lookup.c (add_decl_to_level): Assert not class.\n+\t(check_local_shadow): Use OVL_P.\n+\t(pushdecl_with_scope_1): Rename to ...\n+\t(do_pushdecl_with_Scope): ... here.\n+\t(do_nonmember_using_decl): Use qualified_namespace_lookup return\n+\tvalue.\n+\t(push_class_level_binding_1): Use OVL_P.\n+\t(pushdecl_namespace_level): Use do_pushdecl_with_scope.\n+\t(pushtag_1): Rename to ...\n+\t(do_pushtag): ... here.  Adjust do_pushdecl_with_scope call.\n+\t(pushtag): Adjust.\n+\t(store_class_bindings): Do not time here.\n+\t* name-lookup.h (pushdecl_outermost_localscope): Reorder.\n+\t* pt.c (listify): Declare argvec at point of initialization.\n+\n \tPR c++/80913\n \t* name-lookup.c (add_decl_to_level): Assert not making a circular\n \tchain."}, {"sha": "356d0305a7f49de6e895e31220f05b37050281f2", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -228,8 +228,7 @@ DEFTREECODE (DEFERRED_NOEXCEPT, \"deferred_noexcept\", tcc_exceptional, 0)\n    member template, the template may be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", tcc_expression, 2)\n \n-/* A list-like node for chaining overloading candidates. TREE_TYPE is\n-   the original name, and the parameter is the FUNCTION_DECL.  */\n+/* One of a set of overloaded functions.  */\n DEFTREECODE (OVERLOAD, \"overload\", tcc_exceptional, 0)\n \n /* A pseudo-destructor, of the form \"OBJECT.~DESTRUCTOR\" or"}, {"sha": "a01e76a228d509100a7b21ced5743d9be05a8284", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -692,7 +692,8 @@ struct GTY(()) tree_overload {\n   tree function;\n };\n \n-/* Iterator for a 1 dimensional overload. */\n+/* Iterator for a 1 dimensional overload.  Permits iterating over the\n+   outer level of a 2-d overload when explicitly enabled.  */\n \n class ovl_iterator \n {\n@@ -970,7 +971,7 @@ enum GTY(()) abstract_class_use {\n   (LANG_IDENTIFIER_CAST (NODE)->class_template_info)\n \n /* The IDENTIFIER_BINDING is the innermost cxx_binding for the\n-    identifier.  It's PREVIOUS is the next outermost binding.  Each\n+    identifier.  Its PREVIOUS is the next outermost binding.  Each\n     VALUE field is a DECL for the associated declaration.  Thus,\n     name lookup consists simply of pulling off the node at the front\n     of the list (modulo oddities for looking up the names of types,\n@@ -1454,6 +1455,7 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n     userdef_literal;\n };\n \n+\f\n /* Global state.  */\n \n struct GTY(()) saved_scope {\n@@ -2496,9 +2498,9 @@ struct GTY(()) lang_decl_fn {\n   unsigned static_function : 1;\n   unsigned pure_virtual : 1;\n   unsigned defaulted_p : 1;\n-\n   unsigned has_in_charge_parm_p : 1;\n   unsigned has_vtt_parm_p : 1;\n+  \n   unsigned pending_inline_p : 1;\n   unsigned nonconverting : 1;\n   unsigned thunk_p : 1;"}, {"sha": "8481e2d1e17338040f456c81e71e924ac7eb4741", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -1146,7 +1146,7 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n \n     case SCOPE_REF:\n       dump_type (pp, TREE_OPERAND (t, 0), flags);\n-      pp_colon_colon (pp);\n+      pp_cxx_colon_colon (pp);\n       dump_decl (pp, TREE_OPERAND (t, 1), TFF_UNQUALIFIED_NAME);\n       break;\n \n@@ -1193,8 +1193,7 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n     case OVERLOAD:\n       if (!OVL_SINGLE_P (t))\n \t{\n-\t  t = OVL_FIRST (t);\n-\t  tree ctx = CP_DECL_CONTEXT (t);\n+\t  tree ctx = ovl_scope (t);\n \t  if (ctx != global_namespace)\n \t    {\n \t      if (TYPE_P (ctx))\n@@ -1203,7 +1202,7 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n \t\tdump_decl (pp, ctx, flags);\n \t      pp_cxx_colon_colon (pp);\n \t    }\n-\t  dump_decl (pp, DECL_NAME (t), flags);\n+\t  dump_decl (pp, OVL_NAME (t), flags);\n \t  break;\n \t}\n "}, {"sha": "7f58682f594b23db0f1bb62b310ebcf9cfe4a9e9", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -120,13 +120,12 @@ find_namespace_value (tree ns, tree name)\n static void\n add_decl_to_level (cp_binding_level *b, tree decl)\n {\n-  /* We used to record virtual tables as if they were ordinary\n-     variables, but no longer do so.  */\n-  gcc_assert (!(VAR_P (decl) && DECL_VIRTUAL_P (decl)));\n+  gcc_assert (b->kind != sk_class);\n \n-  if (TREE_CODE (decl) == NAMESPACE_DECL\n-      && !DECL_NAMESPACE_ALIAS (decl))\n+  if (TREE_CODE (decl) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (decl))\n     {\n+      /* Inner namespaces get their own chain, to make walking\n+\t simpler.  */\n       DECL_CHAIN (decl) = b->namespaces;\n       b->namespaces = decl;\n     }\n@@ -2132,8 +2131,7 @@ check_local_shadow (tree decl)\n \n \t/* Warn if a variable shadows a non-function, or the variable\n \t   is a function or a pointer-to-function.  */\n-\tif ((TREE_CODE (member) != FUNCTION_DECL\n-\t     && TREE_CODE (member) != OVERLOAD)\n+\tif (!OVL_P (member)\n \t    || TREE_CODE (decl) == FUNCTION_DECL\n \t    || TYPE_PTRFN_P (TREE_TYPE (decl))\n \t    || TYPE_PTRMEMFUNC_P (TREE_TYPE (decl)))\n@@ -3328,7 +3326,7 @@ push_using_decl (tree scope, tree name)\n    closer binding level than LEVEL.  */\n \n static tree\n-pushdecl_with_scope_1 (tree x, cp_binding_level *level, bool is_friend)\n+do_pushdecl_with_scope (tree x, cp_binding_level *level, bool is_friend)\n {\n   cp_binding_level *b;\n   tree function_decl = current_function_decl;\n@@ -3365,7 +3363,7 @@ pushdecl_outermost_localscope (tree x)\n        n->kind != sk_function_parms; n = b->level_chain)\n     b = n;\n \n-  tree ret = b ? pushdecl_with_scope_1 (x, b, false) : error_mark_node;\n+  tree ret = b ? do_pushdecl_with_scope (x, b, false) : error_mark_node;\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n \n   return ret;\n@@ -3436,10 +3434,6 @@ do_nonmember_using_decl (tree scope, tree name, tree *value_p, tree *type_p)\n   name_lookup lookup (name, 0);\n \n   if (!qualified_namespace_lookup (scope, &lookup))\n-    /* Lookup error */\n-    return;\n-\n-  if (!lookup.value)\n     {\n       error (\"%qD not declared\", name);\n       return;\n@@ -4062,7 +4056,7 @@ push_class_level_binding_1 (tree name, tree x)\n \t    }\n \t}\n       else if (TREE_CODE (target_decl) == OVERLOAD\n-\t       && is_overloaded_fn (target_bval))\n+\t       && OVL_P (target_bval))\n \told_decl = bval;\n       else if (TREE_CODE (decl) == USING_DECL\n \t       && TREE_CODE (bval) == USING_DECL\n@@ -4077,10 +4071,10 @@ push_class_level_binding_1 (tree name, tree x)\n \t       && DECL_DEPENDENT_P (bval))\n \treturn true;\n       else if (TREE_CODE (decl) == USING_DECL\n-\t       && is_overloaded_fn (target_bval))\n+\t       && OVL_P (target_bval))\n \told_decl = bval;\n       else if (TREE_CODE (bval) == USING_DECL\n-\t       && is_overloaded_fn (target_decl))\n+\t       && OVL_P (target_decl))\n \treturn true;\n \n       if (old_decl && binding->scope == class_binding_level)\n@@ -4544,7 +4538,7 @@ pushdecl_namespace_level (tree x, bool is_friend)\n   tree t;\n \n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  t = pushdecl_with_scope_1\n+  t = do_pushdecl_with_scope\n     (x, NAMESPACE_LEVEL (current_namespace), is_friend);\n \n   /* Now, the type_shadowed stack may screw us.  Munge it so it does\n@@ -5627,12 +5621,11 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n    Returns TYPE upon success and ERROR_MARK_NODE otherwise.  */\n \n static tree\n-pushtag_1 (tree name, tree type, tag_scope scope)\n+do_pushtag (tree name, tree type, tag_scope scope)\n {\n-  cp_binding_level *b;\n   tree decl;\n \n-  b = current_binding_level;\n+  cp_binding_level *b = current_binding_level;\n   while (/* Cleanup scopes are not scopes from the point of view of\n \t    the language.  */\n \t b->kind == sk_cleanup\n@@ -5721,7 +5714,7 @@ pushtag_1 (tree name, tree type, tag_scope scope)\n \t}\n       else if (b->kind != sk_template_parms)\n \t{\n-\t  decl = pushdecl_with_scope_1 (decl, b, /*is_friend=*/false);\n+\t  decl = do_pushdecl_with_scope (decl, b, /*is_friend=*/false);\n \t  if (decl == error_mark_node)\n \t    return decl;\n \n@@ -5783,14 +5776,14 @@ pushtag_1 (tree name, tree type, tag_scope scope)\n   return type;\n }\n \n-/* Wrapper for pushtag_1.  */\n+/* Wrapper for do_pushtag.  */\n \n tree\n pushtag (tree name, tree type, tag_scope scope)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = pushtag_1 (name, type, scope);\n+  ret = do_pushtag (name, type, scope);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -5879,7 +5872,6 @@ store_class_bindings (vec<cp_class_binding, va_gc> *names,\n   size_t i;\n   cp_class_binding *cb;\n \n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   for (i = 0; vec_safe_iterate (names, i, &cb); ++i)\n     if (store_binding_p (cb->identifier))\n       bindings_need_stored.safe_push (cb->identifier);\n@@ -5891,7 +5883,6 @@ store_class_bindings (vec<cp_class_binding, va_gc> *names,\n \tstore_binding (id, old_bindings);\n       bindings_need_stored.truncate (0);\n     }\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n /* A chain of saved_scope structures awaiting reuse.  */"}, {"sha": "7a61b96562c0ab37d4e9c355507b03fec646b305", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -194,7 +194,6 @@ struct GTY(()) cp_binding_level {\n   /* A list of USING_DECL nodes.  */\n   tree usings;\n \n-\n   /* Using directives.  */\n   vec<tree, va_gc> *using_directives;\n \n@@ -331,8 +330,8 @@ extern void finish_namespace_using_decl (tree, tree, tree);\n extern void finish_local_using_decl (tree, tree, tree);\n extern void finish_namespace_using_directive (tree, tree);\n extern void finish_local_using_directive (tree, tree);\n-extern tree pushdecl_outermost_localscope (tree);\n extern tree pushdecl (tree, bool is_friend = false);\n+extern tree pushdecl_outermost_localscope (tree);\n extern tree pushdecl_top_level (tree, bool is_friend = false);\n extern tree pushdecl_top_level_and_finish (tree, tree);\n extern tree pushtag (tree, tree, tag_scope);"}, {"sha": "8f699395d4803c22a38d203a35d08087e6462924", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5256a7f5961e6a5137be1d340cb380b62b06e19f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5256a7f5961e6a5137be1d340cb380b62b06e19f", "patch": "@@ -24788,15 +24788,16 @@ static tree\n listify (tree arg)\n {\n   tree std_init_list = get_namespace_binding (std_node, init_list_identifier);\n-  tree argvec;\n+\n   if (!std_init_list || !DECL_CLASS_TEMPLATE_P (std_init_list))\n     {    \n       error (\"deducing from brace-enclosed initializer list requires \"\n \t     \"#include <initializer_list>\");\n       return error_mark_node;\n     }\n-  argvec = make_tree_vec (1);\n+  tree argvec = make_tree_vec (1);\n   TREE_VEC_ELT (argvec, 0) = arg;\n+\n   return lookup_template_class (std_init_list, argvec, NULL_TREE,\n \t\t\t\tNULL_TREE, 0, tf_warning_or_error);\n }"}]}