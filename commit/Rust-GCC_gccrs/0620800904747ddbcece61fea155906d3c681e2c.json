{"sha": "0620800904747ddbcece61fea155906d3c681e2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYyMDgwMDkwNDc0N2RkYmNlY2U2MWZlYTE1NTkwNmQzYzY4MWUyYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2005-06-24T19:30:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2005-06-24T19:30:20Z"}, "message": "tree-nrv.c (tree_nrv): Fix to check assignments to the RESULT_DECL rather than just RETURN_EXPRs.\n\n        * tree-nrv.c (tree_nrv): Fix to check assignments to the\n        RESULT_DECL rather than just RETURN_EXPRs.\n        (finalize_nrv_r): Adjust.\n\nFrom-SVN: r101296", "tree": {"sha": "cc1eb57acf77bc335e4ef70031c382fff9d100a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc1eb57acf77bc335e4ef70031c382fff9d100a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0620800904747ddbcece61fea155906d3c681e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0620800904747ddbcece61fea155906d3c681e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0620800904747ddbcece61fea155906d3c681e2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0620800904747ddbcece61fea155906d3c681e2c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce91e74c187986865c3de8fbd871242183afa93d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce91e74c187986865c3de8fbd871242183afa93d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce91e74c187986865c3de8fbd871242183afa93d"}], "stats": {"total": 160, "additions": 115, "deletions": 45}, "files": [{"sha": "ca633f3658c49311b014edd6fca0bf4151957cfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0620800904747ddbcece61fea155906d3c681e2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0620800904747ddbcece61fea155906d3c681e2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0620800904747ddbcece61fea155906d3c681e2c", "patch": "@@ -1,3 +1,9 @@\n+2005-06-24  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree-nrv.c (tree_nrv): Fix to check assignments to the\n+\tRESULT_DECL rather than just RETURN_EXPRs.\n+\t(finalize_nrv_r): Adjust.\n+\n 2005-06-24  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-optimize.c (init_tree_optimization_passes): Fix flags of"}, {"sha": "ca700924a239c04d01509940b491fba3ac12f487", "filename": "gcc/testsuite/gcc.dg/nrv1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0620800904747ddbcece61fea155906d3c681e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0620800904747ddbcece61fea155906d3c681e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv1.c?ref=0620800904747ddbcece61fea155906d3c681e2c", "patch": "@@ -0,0 +1,28 @@\n+/* Test that the NRV optimization doesn't cause a1 to change too soon.  This\n+   is equivalent to c++/19317.  */\n+/* { dg-do run } */\n+\n+void abort (void);\n+\n+struct A\n+{\n+  int i[100];\n+};\n+\n+struct A a1;\n+\n+struct A f ()\n+{\n+  struct A a2;\n+  a2.i[0] = 42;\n+  /* a1.i[0] should still be 0 until we return. */\n+  if (a1.i[0] != 0)\n+    abort ();\n+  return a2;\n+}\n+\n+int main()\n+{\n+  a1 = f();\n+  return 0;\n+}"}, {"sha": "e4d1f9aba3a7b0ef928a8947c5af4a07a19168d8", "filename": "gcc/testsuite/gcc.dg/nrv2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0620800904747ddbcece61fea155906d3c681e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0620800904747ddbcece61fea155906d3c681e2c/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnrv2.c?ref=0620800904747ddbcece61fea155906d3c681e2c", "patch": "@@ -0,0 +1,25 @@\n+/* Test that the tree_nrv pass works by making sure that we don't generate\n+   a memcpy.  Throw in a bit of control flow to make its job a bit harder.  */\n+\n+/* { dg-options \"-O\" } */\n+\n+struct A { int i[100]; };\n+\n+int b;\n+\n+struct A f ()\n+{\n+  struct A a;\n+  if (b)\n+    {\n+      a.i[0] = 42;\n+      return a;\n+    }\n+  else\n+    {\n+      a.i[42] = 1;\n+      return a;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"memcpy\" } } */"}, {"sha": "9e1c56dd1d38c519aac7241b55846cfe7dd56abe", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0620800904747ddbcece61fea155906d3c681e2c/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0620800904747ddbcece61fea155906d3c681e2c/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=0620800904747ddbcece61fea155906d3c681e2c", "patch": "@@ -81,10 +81,6 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n   if (TYPE_P (*tp))\n     *walk_subtrees = 0;\n \n-  /* If this is a RETURN_EXPR, set the expression being returned to RESULT.  */\n-  else if (TREE_CODE (*tp) == RETURN_EXPR)\n-    TREE_OPERAND (*tp, 0) = dp->result;\n-\n   /* Otherwise replace all occurrences of VAR with RESULT.  */\n   else if (*tp == dp->var)\n     *tp = dp->result;\n@@ -112,56 +108,61 @@ tree_nrv (void)\n   tree result_type = TREE_TYPE (result);\n   tree found = NULL;\n   basic_block bb;\n+  block_stmt_iterator bsi;\n   struct nrv_data data;\n \n   /* If this function does not return an aggregate type in memory, then\n      there is nothing to do.  */\n   if (!aggregate_value_p (result, current_function_decl))\n     return;\n \n-  /* Look through each block for suitable return expressions.   RETURN_EXPRs\n-     end basic blocks, so we only have to look at the last statement in\n-     each block.  That makes this very fast.  */\n+  /* Look through each block for assignments to the RESULT_DECL.  */\n   FOR_EACH_BB (bb)\n     {\n-      tree stmt = last_stmt (bb);\n-\n-      if (stmt && TREE_CODE (stmt) == RETURN_EXPR)\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n-\t  tree ret_expr = TREE_OPERAND (stmt, 0);\n-\n-\t  /* This probably should not happen, but just to be safe do\n-\t     not perform NRV optimizations if only some of the return\n-\t     statement return a value.  */\n-\t  if (!ret_expr\n-\t      || TREE_CODE (ret_expr) != MODIFY_EXPR\n-\t      || TREE_CODE (TREE_OPERAND (ret_expr, 0)) != RESULT_DECL)\n-\t    return;\n-\n-\t  /* Now verify that this return statement uses the same value\n-\t     as any previously encountered return statement.  */\n-\t  if (found != NULL)\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  tree ret_expr;\n+\n+\t  if (TREE_CODE (stmt) == RETURN_EXPR)\n \t    {\n-\t      /* If we found a return statement using a different variable\n-\t\t than previous return statements, then we can not perform\n-\t\t NRV optimizations.  */\n-\t      if (found != TREE_OPERAND (ret_expr, 1))\n+\t      /* In a function with an aggregate return value, the\n+\t\t gimplifier has changed all non-empty RETURN_EXPRs to\n+\t\t return the RESULT_DECL.  */\n+\t      ret_expr = TREE_OPERAND (stmt, 0);\n+\t      if (ret_expr)\n+\t\tgcc_assert (ret_expr == result);\n+\t    }\n+\t  else if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t\t   && TREE_OPERAND (stmt, 0) == result)\n+\t    {\n+\t      ret_expr = TREE_OPERAND (stmt, 1);\n+\n+\t      /* Now verify that this return statement uses the same value\n+\t\t as any previously encountered return statement.  */\n+\t      if (found != NULL)\n+\t\t{\n+\t\t  /* If we found a return statement using a different variable\n+\t\t     than previous return statements, then we can not perform\n+\t\t     NRV optimizations.  */\n+\t\t  if (found != ret_expr)\n+\t\t    return;\n+\t\t}\n+\t      else\n+\t\tfound = ret_expr;\n+\n+\t      /* The returned value must be a local automatic variable of the\n+\t\t same type and alignment as the function's result.  */\n+\t      if (TREE_CODE (found) != VAR_DECL\n+\t\t  || TREE_THIS_VOLATILE (found)\n+\t\t  || DECL_CONTEXT (found) != current_function_decl\n+\t\t  || TREE_STATIC (found)\n+\t\t  || TREE_ADDRESSABLE (found)\n+\t\t  || DECL_ALIGN (found) > DECL_ALIGN (result)\n+\t\t  || !lang_hooks.types_compatible_p (TREE_TYPE (found), \n+\t\t\t\t\t\t     result_type))\n \t\treturn;\n \t    }\n-\t  else\n-\t    found = TREE_OPERAND (ret_expr, 1);\n-\n-\t  /* The returned value must be a local automatic variable of the\n-\t     same type and alignment as the function's result.  */\n-\t  if (TREE_CODE (found) != VAR_DECL\n-\t      || TREE_THIS_VOLATILE (found)\n-\t      || DECL_CONTEXT (found) != current_function_decl\n-\t      || TREE_STATIC (found)\n-\t      || TREE_ADDRESSABLE (found)\n-\t      || DECL_ALIGN (found) > DECL_ALIGN (result)\n-              || !lang_hooks.types_compatible_p (TREE_TYPE (found), \n- \t\t result_type))\n-\t    return;\n \t}\n     }\n \n@@ -192,10 +193,20 @@ tree_nrv (void)\n   data.result = result;\n   FOR_EACH_BB (bb)\n     {\n-      block_stmt_iterator bsi;\n-\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\twalk_tree (bsi_stmt_ptr (bsi), finalize_nrv_r, &data, 0);\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n+\t{\n+\t  tree *tp = bsi_stmt_ptr (bsi);\n+\t  /* If this is a copy from VAR to RESULT, remove it.  */\n+\t  if (TREE_CODE (*tp) == MODIFY_EXPR\n+\t      && TREE_OPERAND (*tp, 0) == result\n+\t      && TREE_OPERAND (*tp, 1) == found)\n+\t    bsi_remove (&bsi);\n+\t  else\n+\t    {\n+\t      walk_tree (tp, finalize_nrv_r, &data, 0);\n+\t      bsi_next (&bsi);\n+\t    }\n+\t}\n     }\n \n   /* FOUND is no longer used.  Ensure it gets removed.  */"}]}