{"sha": "a065d52eff29059a680ee8d44b11f03c0a544562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA2NWQ1MmVmZjI5MDU5YTY4MGVlOGQ0NGIxMWYwM2MwYTU0NDU2Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-31T16:45:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-31T16:45:05Z"}, "message": "ipa-cp.c (ipcp_need_original_clone_p): Remove.\n\n\t* ipa-cp.c (ipcp_need_original_clone_p): Remove.\n\t(ipcp_estimate_growth): New.\n\t(ipcp_insert_stage): Use ipcp_estimate_growth.\n\t* profile.c (branch_prob): When reading failed, do not consider\n\tprofile as read.\n\nFrom-SVN: r139835", "tree": {"sha": "422fb0a8faa00c7edd926c5753a32a442ce9540d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/422fb0a8faa00c7edd926c5753a32a442ce9540d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a065d52eff29059a680ee8d44b11f03c0a544562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a065d52eff29059a680ee8d44b11f03c0a544562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a065d52eff29059a680ee8d44b11f03c0a544562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a065d52eff29059a680ee8d44b11f03c0a544562/comments", "author": null, "committer": null, "parents": [{"sha": "079990a2bffd576c7f8a3f375e8f02be2bc00306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/079990a2bffd576c7f8a3f375e8f02be2bc00306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/079990a2bffd576c7f8a3f375e8f02be2bc00306"}], "stats": {"total": 82, "additions": 61, "deletions": 21}, "files": [{"sha": "bfbf234c34c85c9a40816bf86b2792a3969e0b8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065d52eff29059a680ee8d44b11f03c0a544562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065d52eff29059a680ee8d44b11f03c0a544562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a065d52eff29059a680ee8d44b11f03c0a544562", "patch": "@@ -1,3 +1,11 @@\n+2008-08-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_need_original_clone_p): Remove.\n+\t(ipcp_estimate_growth): New.\n+\t(ipcp_insert_stage): Use ipcp_estimate_growth.\n+\t* profile.c (branch_prob): When reading failed, do not consider\n+\tprofile as read.\n+\n 2008-08-31  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Check that"}, {"sha": "8f1c1614cd8f227d74f0469cb2c735acb83c13f6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065d52eff29059a680ee8d44b11f03c0a544562/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065d52eff29059a680ee8d44b11f03c0a544562/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a065d52eff29059a680ee8d44b11f03c0a544562", "patch": "@@ -1042,22 +1042,58 @@ ipcp_update_profiling (void)\n     }\n }\n \n-/* Return true if original clone needs to be preserved.  */\n-static bool\n-ipcp_need_original_clone_p (struct cgraph_node *node)\n+/* If NODE was cloned, how much would program grow? */\n+static long\n+ipcp_estimate_growth (struct cgraph_node *node)\n {\n-  struct cgraph_edge *e;\n+  struct cgraph_edge *cs;\n+  int redirectable_node_callers = 0;\n+  int removable_args = 0;\n+  bool need_original = node->needed;\n+  struct ipa_node_params *info;\n+  int i, count;\n+  int growth;\n \n-  if (node->needed)\n-    return true;\n-  for (e = node->callers; e; e = e->next_caller)\n-    if (!bitmap_bit_p (dead_nodes, e->caller->uid)\n-        && ipcp_need_redirect_p (e))\n-      return true;\n+  for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n+    if (!ipcp_need_redirect_p (cs))\n+      redirectable_node_callers++;\n+    else\n+      need_original = true;\n+\n+  /* If we will be able to fully replace orignal node, we never increase\n+     program size.  */\n+  if (!need_original)\n+    return false;\n \n-  return false;\n+  info = IPA_NODE_REF (node);\n+  count = ipa_get_param_count (info);\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+      tree parm_tree = ipa_get_ith_param (info, i);\n+\n+      /* We can proactively remove obviously unused arguments.  */\n+      if (is_gimple_reg (parm_tree)\n+\t  && !gimple_default_def (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t  parm_tree))\n+\tremovable_args++;\n+\n+      if (lat->type == IPA_CONST_VALUE)\n+\tremovable_args++;\n+    }\n+\n+  /* We make just very simple estimate of savings for removal of operand from\n+     call site.  Precise cost is dificult to get, as our size metric counts\n+     constants and moves as free.  Generally we are looking for cases that\n+     small function is called very many times.  */\n+  growth = node->local.inline_summary.self_insns\n+  \t   - removable_args * redirectable_node_callers;\n+  if (growth < 0)\n+    return 0;\n+  return growth;\n }\n \n+\n /* Estimate cost of cloning NODE.  */\n static long\n ipcp_estimate_cloning_cost (struct cgraph_node *node)\n@@ -1067,12 +1103,12 @@ ipcp_estimate_cloning_cost (struct cgraph_node *node)\n   struct cgraph_edge *e;\n   int cost;\n \n-  /* When we don't need original clone; we should always propagate.  */\n-  if (!ipcp_need_original_clone_p (node))\n+  cost = ipcp_estimate_growth (node) * 1000;\n+  if (!cost)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Function %s can be fully propagated\\n\",\n-\t\t cgraph_node_name (node));\n+        fprintf (dump_file, \"Versioning of %s will save code size\\n\",\n+\t         cgraph_node_name (node));\n       return 0;\n     }\n \n@@ -1084,7 +1120,6 @@ ipcp_estimate_cloning_cost (struct cgraph_node *node)\n \tfreq_sum += e->frequency + 1;\n       }\n \n-  cost = node->local.inline_summary.self_insns * 1000;\n   if (max_count)\n     cost /= count_sum * 1000 / max_count + 1;\n   else\n@@ -1185,10 +1220,7 @@ ipcp_insert_stage (void)\n \tfprintf (dump_file, \"considering function %s\\n\",\n \t\t cgraph_node_name (node));\n \n-      if (ipcp_need_original_clone_p (node))\n-        growth = node->local.inline_summary.self_insns;\n-      else\n-\tbitmap_set_bit (dead_nodes, node->uid);\n+      growth = ipcp_estimate_growth (node);\n \n       if (new_insns + growth > max_new_insns)\n \tbreak;"}, {"sha": "6f89645d1fbb3b3f114ca86b5c463548ea7f4d20", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a065d52eff29059a680ee8d44b11f03c0a544562/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a065d52eff29059a680ee8d44b11f03c0a544562/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=a065d52eff29059a680ee8d44b11f03c0a544562", "patch": "@@ -1154,7 +1154,7 @@ branch_prob (void)\n \n   VEC_free (histogram_value, heap, values);\n   free_edge_list (el);\n-  if (flag_branch_probabilities)\n+  if (flag_branch_probabilities && profile_info)\n     profile_status = PROFILE_READ;\n   coverage_end_function ();\n }"}]}