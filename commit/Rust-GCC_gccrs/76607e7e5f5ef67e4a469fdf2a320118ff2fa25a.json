{"sha": "76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2MDdlN2U1ZjVlZjY3ZTRhNDY5ZmRmMmEzMjAxMThmZjJmYTI1YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-12-19T13:36:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-12-19T13:36:16Z"}, "message": "[AArch64] Reject invalid subregs involving partial SVE modes\n\nWhen adding partial SVE modes, I'd remembered to handle reloads\nin a similar way to full big-endian SVE vectors, but forgot the\njust-as-important mode-change rules.\n\n2019-12-19  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_can_change_mode_class):\n\tDon't allow changes between partial SVE modes and other kinds\n\tof mode.  Don't allow changes between two partial SVE modes\n\tif they have different container or element sizes.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/mixed_size_8.c: New test.\n\nFrom-SVN: r279572", "tree": {"sha": "a0de6df37de444fc88a84ccdb4f1f9d07d046f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0de6df37de444fc88a84ccdb4f1f9d07d046f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6aa5370cccf7c0475192dc8c641450722ae1e477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aa5370cccf7c0475192dc8c641450722ae1e477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aa5370cccf7c0475192dc8c641450722ae1e477"}], "stats": {"total": 70, "additions": 67, "deletions": 3}, "files": [{"sha": "542bdf6e910a389544a05459c4fcc839f44ecd39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "patch": "@@ -1,3 +1,10 @@\n+2019-12-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_can_change_mode_class):\n+\tDon't allow changes between partial SVE modes and other kinds\n+\tof mode.  Don't allow changes between two partial SVE modes\n+\tif they have different container or element sizes.\n+\n 2019-12-19  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_function_value_1): New function,"}, {"sha": "88baf96efc2d60d7dc4ea6e57900e51821902e6f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "patch": "@@ -21457,11 +21457,30 @@ static bool\n aarch64_can_change_mode_class (machine_mode from,\n \t\t\t       machine_mode to, reg_class_t)\n {\n+  unsigned int from_flags = aarch64_classify_vector_mode (from);\n+  unsigned int to_flags = aarch64_classify_vector_mode (to);\n+\n+  bool from_sve_p = (from_flags & VEC_ANY_SVE);\n+  bool to_sve_p = (to_flags & VEC_ANY_SVE);\n+\n+  bool from_partial_sve_p = from_sve_p && (from_flags & VEC_PARTIAL);\n+  bool to_partial_sve_p = to_sve_p && (to_flags & VEC_PARTIAL);\n+\n+  /* Don't allow changes between partial SVE modes and other modes.\n+     The contents of partial SVE modes are distributed evenly across\n+     the register, whereas GCC expects them to be clustered together.  */\n+  if (from_partial_sve_p != to_partial_sve_p)\n+    return false;\n+\n+  /* Similarly reject changes between partial SVE modes that have\n+     different patterns of significant and insignificant bits.  */\n+  if (from_partial_sve_p\n+      && (aarch64_sve_container_bits (from) != aarch64_sve_container_bits (to)\n+\t  || GET_MODE_UNIT_SIZE (from) != GET_MODE_UNIT_SIZE (to)))\n+    return false;\n+\n   if (BYTES_BIG_ENDIAN)\n     {\n-      bool from_sve_p = aarch64_sve_data_mode_p (from);\n-      bool to_sve_p = aarch64_sve_data_mode_p (to);\n-\n       /* Don't allow changes between SVE data modes and non-SVE modes.\n \t See the comment at the head of aarch64-sve.md for details.  */\n       if (from_sve_p != to_sve_p)"}, {"sha": "7d474882c634382c0ebf4456223269927fb117da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "patch": "@@ -1,3 +1,7 @@\n+2019-12-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/mixed_size_8.c: New test.\n+\n 2019-12-19  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/pcs/gnu_vectors_3.c: New test."}, {"sha": "f9e95d34011200aa9bb0821fdd1c991fb12b11af", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mixed_size_8.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmixed_size_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76607e7e5f5ef67e4a469fdf2a320118ff2fa25a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmixed_size_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmixed_size_8.c?ref=76607e7e5f5ef67e4a469fdf2a320118ff2fa25a", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-options \"-O2 -msve-vector-bits=512\" } */\n+\n+typedef int int32x16_t __attribute__((vector_size(64)));\n+typedef int int32x8_t __attribute__((vector_size(32)));\n+\n+int32x8_t\n+f1 (int32x16_t x)\n+{\n+  union u { int32x16_t full; int32x8_t pair[2]; } u;\n+  u.full = x | 2;\n+  return u.pair[0] + (int32x8_t) { 1, 2, 3, 4, 5, 6, 7, 8 };\n+}\n+\n+int32x8_t\n+f2 (int32x16_t x)\n+{\n+  union u { int32x16_t full; int32x8_t pair[2]; } u;\n+  u.full = x | 2;\n+  return u.pair[1] + (int32x8_t) { 1, 2, 3, 4, 5, 6, 7, 8 };\n+}\n+\n+/* We could do something more efficient than spill the int32x16_t and\n+   reload the int32x8_t.  The important thing is that we don't do\n+   something like:\n+\n+\torr\tz0.s, z0.s, #2\n+\tindex\tz1.d, #1, #1\n+\tadd\tz0.s, z0.s, z1.s\n+\tst1w\tz0.d, p0, [x8]\n+\n+   We're supposed to add z1 to one half of the ORR result instead.  */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.d} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\.d} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.d} 2 } } */"}]}