{"sha": "4ca228d2f32e5eb6e9516f487be85383225d5a00", "node_id": "C_kwDOANBUbNoAKDRjYTIyOGQyZjMyZTVlYjZlOTUxNmY0ODdiZTg1MzgzMjI1ZDVhMDA", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-16T11:40:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:28Z"}, "message": "rust-constexpr.cc: port over cxx_eval_array_reference and\ncxx_eval_component_reference.\n\nSome important parts are commented out and marked such. These will\nneed revisiting.", "tree": {"sha": "e2e870e7baea1e918a9757db8ad6c1e456077ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e870e7baea1e918a9757db8ad6c1e456077ebc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ca228d2f32e5eb6e9516f487be85383225d5a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca228d2f32e5eb6e9516f487be85383225d5a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca228d2f32e5eb6e9516f487be85383225d5a00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca228d2f32e5eb6e9516f487be85383225d5a00/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "debe4aedc76a1f52c3072254b6be4da4f4c4696c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debe4aedc76a1f52c3072254b6be4da4f4c4696c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debe4aedc76a1f52c3072254b6be4da4f4c4696c"}], "stats": {"total": 414, "additions": 388, "deletions": 26}, "files": [{"sha": "c0194db6b2181eca05e80ea8adc2536a90f14dc6", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 301, "deletions": 26, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca228d2f32e5eb6e9516f487be85383225d5a00/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca228d2f32e5eb6e9516f487be85383225d5a00/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=4ca228d2f32e5eb6e9516f487be85383225d5a00", "patch": "@@ -1532,6 +1532,273 @@ adjust_temp_type (tree type, tree temp)\n   return fold_convert (cv_unqualified (type), temp);\n }\n \n+// forked from gcc/cp/constexpr.cc free_constructor\n+\n+/* If T is a CONSTRUCTOR, ggc_free T and any sub-CONSTRUCTORs.  */\n+\n+static void\n+free_constructor (tree t)\n+{\n+  if (!t || TREE_CODE (t) != CONSTRUCTOR)\n+    return;\n+  releasing_vec ctors;\n+  vec_safe_push (ctors, t);\n+  while (!ctors->is_empty ())\n+    {\n+      tree c = ctors->pop ();\n+      if (vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (c))\n+\t{\n+\t  constructor_elt *ce;\n+\t  for (HOST_WIDE_INT i = 0; vec_safe_iterate (elts, i, &ce); ++i)\n+\t    if (TREE_CODE (ce->value) == CONSTRUCTOR)\n+\t      vec_safe_push (ctors, ce->value);\n+\t  ggc_free (elts);\n+\t}\n+      ggc_free (c);\n+    }\n+}\n+\n+static tree\n+eval_and_check_array_index (const constexpr_ctx *ctx, tree t,\n+\t\t\t    bool allow_one_past, bool *non_constant_p,\n+\t\t\t    bool *overflow_p);\n+\n+// forked from gcc/cp/constexpr.cc cxx_eval_array_reference\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to reduce a reference to an array slot.  */\n+\n+static tree\n+eval_array_reference (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t      bool *non_constant_p, bool *overflow_p)\n+{\n+  tree oldary = TREE_OPERAND (t, 0);\n+  tree ary\n+    = eval_constant_expression (ctx, oldary, lval, non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n+  if (!lval && TREE_CODE (ary) == VIEW_CONVERT_EXPR\n+      && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (ary, 0)))\n+      && TREE_TYPE (t) == TREE_TYPE (TREE_TYPE (TREE_OPERAND (ary, 0))))\n+    ary = TREE_OPERAND (ary, 0);\n+\n+  tree oldidx = TREE_OPERAND (t, 1);\n+  tree index\n+    = eval_and_check_array_index (ctx, t, lval, non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n+\n+  if (lval && ary == oldary && index == oldidx)\n+    return t;\n+  else if (lval)\n+    return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n+\n+  unsigned len = 0, elem_nchars = 1;\n+  tree elem_type = TREE_TYPE (TREE_TYPE (ary));\n+  if (TREE_CODE (ary) == CONSTRUCTOR)\n+    len = CONSTRUCTOR_NELTS (ary);\n+  else if (TREE_CODE (ary) == STRING_CST)\n+    {\n+      elem_nchars\n+\t= (TYPE_PRECISION (elem_type) / TYPE_PRECISION (char_type_node));\n+      len = (unsigned) TREE_STRING_LENGTH (ary) / elem_nchars;\n+    }\n+  else if (TREE_CODE (ary) == VECTOR_CST)\n+    /* We don't create variable-length VECTOR_CSTs.  */\n+    len = VECTOR_CST_NELTS (ary).to_constant ();\n+  else\n+    {\n+      /* We can't do anything with other tree codes, so use\n+\t VERIFY_CONSTANT to complain and fail.  */\n+      VERIFY_CONSTANT (ary);\n+      gcc_unreachable ();\n+    }\n+\n+  bool found;\n+  HOST_WIDE_INT i = 0;\n+  if (TREE_CODE (ary) == CONSTRUCTOR)\n+    {\n+      HOST_WIDE_INT ix = find_array_ctor_elt (ary, index);\n+      found = (ix >= 0);\n+      if (found)\n+\ti = ix;\n+    }\n+  else\n+    {\n+      i = tree_to_shwi (index);\n+      found = (i < len);\n+    }\n+\n+  if (found)\n+    {\n+      tree r;\n+      if (TREE_CODE (ary) == CONSTRUCTOR)\n+\tr = (*CONSTRUCTOR_ELTS (ary))[i].value;\n+      else if (TREE_CODE (ary) == VECTOR_CST)\n+\tr = VECTOR_CST_ELT (ary, i);\n+      else\n+\tr = extract_string_elt (ary, elem_nchars, i);\n+\n+      if (r)\n+\t/* Don't VERIFY_CONSTANT here.  */\n+\treturn r;\n+\n+      /* Otherwise the element doesn't have a value yet.  */\n+    }\n+\n+  /* Not found.  */\n+\n+  if (TREE_CODE (ary) == CONSTRUCTOR && CONSTRUCTOR_NO_CLEARING (ary))\n+    {\n+      /* 'ary' is part of the aggregate initializer we're currently\n+\t building; if there's no initializer for this element yet,\n+\t that's an error.  */\n+      if (!ctx->quiet)\n+\terror (\"accessing uninitialized array element\");\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* If it's within the array bounds but doesn't have an explicit\n+     initializer, it's initialized from {}.  But use build_value_init\n+     directly for non-aggregates to avoid creating a garbage CONSTRUCTOR.  */\n+  tree val;\n+  constexpr_ctx new_ctx;\n+  if (is_really_empty_class (elem_type, /*ignore_vptr*/ false))\n+    return build_constructor (elem_type, NULL);\n+  // Faisal: commenting this out as not sure if we need this but we need to come\n+  // back to handle this to assign suitable value to val before sending it in\n+  // eval_constant_expression below\n+  // else if (CP_AGGREGATE_TYPE_P (elem_type))\n+  //  {\n+  //    tree empty_ctor = build_constructor (init_list_type_node, NULL);\n+  //    val = digest_init (elem_type, empty_ctor, tf_warning_or_error);\n+  //  }\n+  // else\n+  //  val = build_value_init (elem_type, tf_warning_or_error);\n+\n+  if (!SCALAR_TYPE_P (elem_type))\n+    {\n+      new_ctx = *ctx;\n+      if (ctx->object)\n+\t/* If there was no object, don't add one: it could confuse us\n+\t   into thinking we're modifying a const object.  */\n+\tnew_ctx.object = t;\n+      new_ctx.ctor = build_constructor (elem_type, NULL);\n+      ctx = &new_ctx;\n+    }\n+  t = eval_constant_expression (ctx, val, lval, non_constant_p, overflow_p);\n+  if (!SCALAR_TYPE_P (elem_type) && t != ctx->ctor)\n+    free_constructor (ctx->ctor);\n+  return t;\n+}\n+\n+// forked from gcc/cp/constexpr.cc cxx_eval_component_reference\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to reduce a field access of a value of class type.  */\n+\n+static tree\n+eval_component_reference (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t\t  bool *non_constant_p, bool *overflow_p)\n+{\n+  unsigned HOST_WIDE_INT i;\n+  tree field;\n+  tree value;\n+  tree part = TREE_OPERAND (t, 1);\n+  tree orig_whole = TREE_OPERAND (t, 0);\n+  tree whole = eval_constant_expression (ctx, orig_whole, lval, non_constant_p,\n+\t\t\t\t\t overflow_p);\n+  if (INDIRECT_REF_P (whole) && integer_zerop (TREE_OPERAND (whole, 0)))\n+    {\n+      if (!ctx->quiet)\n+\terror (\"dereferencing a null pointer in %qE\", orig_whole);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  if (whole == orig_whole)\n+    return t;\n+  if (lval)\n+    return fold_build3 (COMPONENT_REF, TREE_TYPE (t), whole, part, NULL_TREE);\n+  /* Don't VERIFY_CONSTANT here; we only want to check that we got a\n+     CONSTRUCTOR.  */\n+  if (!*non_constant_p && TREE_CODE (whole) != CONSTRUCTOR)\n+    {\n+      if (!ctx->quiet)\n+\terror (\"%qE is not a constant expression\", orig_whole);\n+      *non_constant_p = true;\n+    }\n+  if (DECL_MUTABLE_P (part))\n+    {\n+      if (!ctx->quiet)\n+\terror (\"mutable %qD is not usable in a constant expression\", part);\n+      *non_constant_p = true;\n+    }\n+  if (*non_constant_p)\n+    return t;\n+  bool pmf = TYPE_PTRMEMFUNC_P (TREE_TYPE (whole));\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)\n+    {\n+      /* Use name match for PMF fields, as a variant will have a\n+\t different FIELD_DECL with a different type.  */\n+      if (pmf ? DECL_NAME (field) == DECL_NAME (part) : field == part)\n+\t{\n+\t  if (value)\n+\t    {\n+\t      STRIP_ANY_LOCATION_WRAPPER (value);\n+\t      return value;\n+\t    }\n+\t  else\n+\t    /* We're in the middle of initializing it.  */\n+\t    break;\n+\t}\n+    }\n+  if (TREE_CODE (TREE_TYPE (whole)) == UNION_TYPE\n+      && CONSTRUCTOR_NELTS (whole) > 0)\n+    {\n+      /* DR 1188 says we don't have to deal with this.  */\n+      if (!ctx->quiet)\n+\t{\n+\t  constructor_elt *cep = CONSTRUCTOR_ELT (whole, 0);\n+\t  if (cep->value == NULL_TREE)\n+\t    error (\"accessing uninitialized member %qD\", part);\n+\t  else\n+\t    error (\"accessing %qD member instead of initialized %qD member in \"\n+\t\t   \"constant expression\",\n+\t\t   part, cep->index);\n+\t}\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* We only create a CONSTRUCTOR for a subobject when we modify it, so empty\n+     classes never get represented; throw together a value now.  */\n+  if (is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/ false))\n+    return build_constructor (TREE_TYPE (t), NULL);\n+\n+  gcc_assert (DECL_CONTEXT (part) == TYPE_MAIN_VARIANT (TREE_TYPE (whole)));\n+\n+  if (CONSTRUCTOR_NO_CLEARING (whole))\n+    {\n+      /* 'whole' is part of the aggregate initializer we're currently\n+\t building; if there's no initializer for this member yet, that's an\n+\t error.  */\n+      if (!ctx->quiet)\n+\terror (\"accessing uninitialized member %qD\", part);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* If there's no explicit init for this field, it's value-initialized.  */\n+  // Faisal: commenting this out as not sure if we need this but we need to come\n+  // back to handle this to assign suitable value to value before sending it in\n+  // eval_constant_expression below\n+  // value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n+  return eval_constant_expression (ctx, value, lval, non_constant_p,\n+\t\t\t\t   overflow_p);\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n@@ -1964,6 +2231,24 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       eval_switch_expr (ctx, t, non_constant_p, overflow_p, jump_target);\n       break;\n \n+    case ARRAY_REF:\n+      r = eval_array_reference (ctx, t, lval, non_constant_p, overflow_p);\n+      break;\n+\n+    case COMPONENT_REF:\n+      if (is_overloaded_fn (t))\n+\t{\n+\t  /* We can only get here in checking mode via\n+\t     build_non_dependent_expr,  because any expression that\n+\t     calls or takes the address of the function will have\n+\t     pulled a FUNCTION_DECL out of the COMPONENT_REF.  */\n+\t  gcc_checking_assert (ctx->quiet || errorcount);\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+      r = eval_component_reference (ctx, t, lval, non_constant_p, overflow_p);\n+      break;\n+\n     case BIT_FIELD_REF:\n       r = eval_bit_field_ref (ctx, t, lval, non_constant_p, overflow_p);\n       break;\n@@ -4144,32 +4429,6 @@ extract_string_elt (tree string, unsigned chars_per_elt, unsigned index)\n   return r;\n }\n \n-// forked from gcc/cp/constexpr.cc free_constructor\n-\n-/* If T is a CONSTRUCTOR, ggc_free T and any sub-CONSTRUCTORs.  */\n-\n-static void\n-free_constructor (tree t)\n-{\n-  if (!t || TREE_CODE (t) != CONSTRUCTOR)\n-    return;\n-  releasing_vec ctors;\n-  vec_safe_push (ctors, t);\n-  while (!ctors->is_empty ())\n-    {\n-      tree c = ctors->pop ();\n-      if (vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (c))\n-\t{\n-\t  constructor_elt *ce;\n-\t  for (HOST_WIDE_INT i = 0; vec_safe_iterate (elts, i, &ce); ++i)\n-\t    if (TREE_CODE (ce->value) == CONSTRUCTOR)\n-\t      vec_safe_push (ctors, ce->value);\n-\t  ggc_free (elts);\n-\t}\n-      ggc_free (c);\n-    }\n-}\n-\n /* Check whether the parameter and return types of FUN are valid for a\n    constexpr function, and complain if COMPLAIN.  */\n \n@@ -6129,6 +6388,22 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t\t\t\t  &target);\n }\n \n+// forked from gcc/cp/constexpr.cc fold_non_dependent_init\n+\n+/* Like maybe_constant_init but first fully instantiate the argument.  */\n+\n+tree\n+fold_non_dependent_init (tree t,\n+\t\t\t tsubst_flags_t complain /*=tf_warning_or_error*/,\n+\t\t\t bool manifestly_const_eval /*=false*/,\n+\t\t\t tree object /* = NULL_TREE */)\n+{\n+  if (t == NULL_TREE)\n+    return NULL_TREE;\n+\n+  return maybe_constant_init (t, object, manifestly_const_eval);\n+}\n+\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}, {"sha": "ce820f08eaa347557a4bfbeba7592d331a43472f", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca228d2f32e5eb6e9516f487be85383225d5a00/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca228d2f32e5eb6e9516f487be85383225d5a00/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=4ca228d2f32e5eb6e9516f487be85383225d5a00", "patch": "@@ -6146,4 +6146,63 @@ explain_non_literal_class (tree t)\n     }\n }\n \n+// forked from gcc/cp/call.cc reference_related_p\n+\n+/* Returns nonzero if T1 is reference-related to T2.  */\n+\n+bool\n+reference_related_p (tree t1, tree t2)\n+{\n+  if (t1 == error_mark_node || t2 == error_mark_node)\n+    return false;\n+\n+  t1 = TYPE_MAIN_VARIANT (t1);\n+  t2 = TYPE_MAIN_VARIANT (t2);\n+\n+  /* [dcl.init.ref]\n+\n+     Given types \"cv1 T1\" and \"cv2 T2,\" \"cv1 T1\" is reference-related\n+     to \"cv2 T2\" if T1 is similar to T2, or T1 is a base class of T2.  */\n+  return (similar_type_p (t1, t2)\n+\t  /*|| (CLASS_TYPE_P (t1) && CLASS_TYPE_P (t2)\n+\t      && DERIVED_FROM_P (t1, t2))*/);\n+}\n+\n+// forked from gcc/cp/typeck2.cc ordinary_char_type_p\n+\n+/* True iff TYPE is a C++20 \"ordinary\" character type.  */\n+\n+bool\n+ordinary_char_type_p (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  return (type == char_type_node || type == signed_char_type_node\n+\t  || type == unsigned_char_type_node);\n+}\n+\n+// forked from gcc/cp/typeck2.cc array_string_literal_compatible_p\n+\n+/* True iff the string literal INIT has a type suitable for initializing array\n+   TYPE.  */\n+\n+bool\n+array_string_literal_compatible_p (tree type, tree init)\n+{\n+  tree to_char_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+  tree from_char_type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n+\n+  if (to_char_type == from_char_type)\n+    return true;\n+  /* The array element type does not match the initializing string\n+     literal element type; this is only allowed when both types are\n+     ordinary character type.  There are no string literals of\n+     signed or unsigned char type in the language, but we can get\n+     them internally from converting braced-init-lists to\n+     STRING_CST.  */\n+  if (ordinary_char_type_p (to_char_type)\n+      && ordinary_char_type_p (from_char_type))\n+    return true;\n+  return false;\n+}\n+\n } // namespace Rust"}, {"sha": "87ed2b6ae56cec8d4811fd35f8a82b122f3a1a71", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca228d2f32e5eb6e9516f487be85383225d5a00/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca228d2f32e5eb6e9516f487be85383225d5a00/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=4ca228d2f32e5eb6e9516f487be85383225d5a00", "patch": "@@ -1529,6 +1529,24 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n #define TYPE_HAS_COMPLEX_DFLT(NODE)                                            \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_dflt)\n \n+/* [dcl.init.aggr]\n+\n+   An aggregate is an array or a class with no user-provided\n+   constructors, no brace-or-equal-initializers for non-static data\n+   members, no private or protected non-static data members, no\n+   base classes, and no virtual functions.\n+\n+   As an extension, we also treat vectors as aggregates.  Keep these\n+   checks in ascending code order.  */\n+#define CP_AGGREGATE_TYPE_P(TYPE)                                              \\\n+  (gnu_vector_type_p (TYPE) || TREE_CODE (TYPE) == ARRAY_TYPE                  \\\n+   || (CLASS_TYPE_P (TYPE) && COMPLETE_TYPE_P (TYPE)                           \\\n+       && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n+\n+/* Nonzero for a FIELD_DECL means that this member object type\n+   is mutable.  */\n+#define DECL_MUTABLE_P(NODE) (DECL_LANG_FLAG_0 (FIELD_DECL_CHECK (NODE)))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -3116,6 +3134,12 @@ extern tree get_first_fn (tree) ATTRIBUTE_PURE;\n \n extern void explain_non_literal_class (tree);\n \n+extern bool reference_related_p (tree, tree);\n+\n+extern bool ordinary_char_type_p (tree);\n+\n+extern bool array_string_literal_compatible_p (tree, tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -3351,6 +3375,10 @@ literal_type_p (tree t);\n \n extern bool\n maybe_constexpr_fn (tree t);\n+\n+extern tree\n+fold_non_dependent_init (tree, tsubst_flags_t = tf_warning_or_error,\n+\t\t\t bool = false, tree = NULL_TREE);\n }\n \n } // namespace Rust"}]}