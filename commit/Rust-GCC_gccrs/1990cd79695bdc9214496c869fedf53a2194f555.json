{"sha": "1990cd79695bdc9214496c869fedf53a2194f555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk5MGNkNzk2OTViZGM5MjE0NDk2Yzg2OWZlZGY1M2EyMTk0ZjU1NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-09-01T02:47:59Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-09-01T02:47:59Z"}, "message": "re PR target/23649 (gcc.dg/ppc-and-1.c failure due to not using rlwinm)\n\n\tPR target/23649\n\t* config/rs6000/predicates.md (mask_operand): Only handle rlwinm masks.\n\t(mask64_operand): Reinstate code prior to 2005-06-11 change.\n\t(mask64_2_operand): Reinstate code prior to 2004-11-11 change.\n\t(and64_2_operand): Tweak to use predicate.\n\t(and_operand): Adjust for mask_operand changes.\n\t* config/rs6000/rs6000.c (num_insns_constant): Revert 2005-06-11.\n\t(print_operand): Likewise.\n\t(rs6000_rtx_costs): Pass mode to mask_operand and use mask64_operand.\n\t(mask64_1or2_operand): Delete.\n\t* rs6000/rs6000-protos.h (mask64_1or2_operand): Delete.\n\t* config/rs6000/rs6000.h (EXTRA_CONSTRAINT <S>): Revert 2005-06-11.\n\t(EXTRA_CONSTRAINT <T>): Pass operand mode to predicate.\n\t(EXTRA_CONSTRAINT <t>): Disallow mask64_operand matches.\n\t* config/rs6000/rs6000.md (andsi3_internal3 split): Revert 2005-06-11.\n\t(rotldi3_internal4): Likewise.\n\t(rotldi3_internal5, rotldi3_internal5 split): Likewise.\n\t(rotldi3_internal6, rotldi3_internal6 split): Likewise.\n\t(ashldi3_internal7): Likewise.\n\t(ashldi3_internal8, ashldi3_internal8 split): Likewise.\n\t(ashldi3_internal, ashldi3_internal9 split): Likewise.\n\t(anddi3 split): Don't match mask64_operand.\n\t(anddi3_internal2): Add rlwinm.  Modify 't' splitter predicate.\n\t(anddi3_internal3): Add rlwinm.  Use and64_2_operand in non-cr0\n\tsplitter and match TARGET_64BIT not TARGET_POWERPC64.  Modify\n\t't' splitter predicate.\n\t(movdi_internal64 + 2): Revert 2005-06-11 change.\n\nFrom-SVN: r103716", "tree": {"sha": "3e3c262979b2fe6478c697cb522554c27efc95c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e3c262979b2fe6478c697cb522554c27efc95c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1990cd79695bdc9214496c869fedf53a2194f555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1990cd79695bdc9214496c869fedf53a2194f555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1990cd79695bdc9214496c869fedf53a2194f555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1990cd79695bdc9214496c869fedf53a2194f555/comments", "author": null, "committer": null, "parents": [{"sha": "e9555b13766fcb8b1d1927a14aa05ead1ec285f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9555b13766fcb8b1d1927a14aa05ead1ec285f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9555b13766fcb8b1d1927a14aa05ead1ec285f0"}], "stats": {"total": 309, "additions": 179, "deletions": 130}, "files": [{"sha": "0d1946573d4c18bc60df350f466f1b97b7d9216d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1990cd79695bdc9214496c869fedf53a2194f555", "patch": "@@ -1,3 +1,33 @@\n+2005-09-01  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/23649\n+\t* config/rs6000/predicates.md (mask_operand): Only handle rlwinm masks.\n+\t(mask64_operand): Reinstate code prior to 2005-06-11 change.\n+\t(mask64_2_operand): Reinstate code prior to 2004-11-11 change.\n+\t(and64_2_operand): Tweak to use predicate.\n+\t(and_operand): Adjust for mask_operand changes.\n+\t* config/rs6000/rs6000.c (num_insns_constant): Revert 2005-06-11.\n+\t(print_operand): Likewise.\n+\t(rs6000_rtx_costs): Pass mode to mask_operand and use mask64_operand.\n+\t(mask64_1or2_operand): Delete.\n+\t* rs6000/rs6000-protos.h (mask64_1or2_operand): Delete.\n+\t* config/rs6000/rs6000.h (EXTRA_CONSTRAINT <S>): Revert 2005-06-11.\n+\t(EXTRA_CONSTRAINT <T>): Pass operand mode to predicate.\n+\t(EXTRA_CONSTRAINT <t>): Disallow mask64_operand matches.\n+\t* config/rs6000/rs6000.md (andsi3_internal3 split): Revert 2005-06-11.\n+\t(rotldi3_internal4): Likewise.\n+\t(rotldi3_internal5, rotldi3_internal5 split): Likewise.\n+\t(rotldi3_internal6, rotldi3_internal6 split): Likewise.\n+\t(ashldi3_internal7): Likewise.\n+\t(ashldi3_internal8, ashldi3_internal8 split): Likewise.\n+\t(ashldi3_internal, ashldi3_internal9 split): Likewise.\n+\t(anddi3 split): Don't match mask64_operand.\n+\t(anddi3_internal2): Add rlwinm.  Modify 't' splitter predicate.\n+\t(anddi3_internal3): Add rlwinm.  Use and64_2_operand in non-cr0\n+\tsplitter and match TARGET_64BIT not TARGET_POWERPC64.  Modify\n+\t't' splitter predicate.\n+\t(movdi_internal64 + 2): Revert 2005-06-11 change.\n+\n 2005-08-31  DJ Delorie  <dj@redhat.com>\n \n \t* config/m32c/m32c.c (m32c_valid_pointer_mode): New."}, {"sha": "64304e536d196fec5b254e915313ae7db1dfa331", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 94, "deletions": 31, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=1990cd79695bdc9214496c869fedf53a2194f555", "patch": "@@ -452,49 +452,49 @@\n        (and (not (match_operand 0 \"logical_operand\"))\n \t    (match_operand 0 \"reg_or_logical_cint_operand\"))))\n \n-;; For SImode, return 1 if op is a constant that can be encoded in a\n-;; 32-bit mask (no more than two 1->0 or 0->1 transitions).  Reject\n-;; all ones and all zeros, since these should have been optimized away\n-;; and confuse the making of MB and ME.\n-;; For DImode, return 1 if the operand is a constant that is a\n-;; PowerPC64 mask (no more than one 1->0 or 0->1 transitions).  Reject\n-;; all zeros, since zero should have been optimized away and confuses\n-;; the making of MB and ME.\n+;; Return 1 if op is a constant that can be encoded in a 32-bit mask,\n+;; suitable for use with rlwinm (no more than two 1->0 or 0->1\n+;; transitions).  Reject all ones and all zeros, since these should have\n+;; been optimized away and confuse the making of MB and ME.\n (define_predicate \"mask_operand\"\n   (match_code \"const_int\")\n {\n   HOST_WIDE_INT c, lsb;\n \n   c = INTVAL (op);\n \n-  /* Fail in 64-bit mode if the mask wraps around because the upper\n-     32-bits of the mask will all be 1s, contrary to GCC's internal view.  */\n-  if (mode == SImode && TARGET_POWERPC64 && (c & 0x80000001) == 0x80000001)\n-    return 0;\n+  if (TARGET_POWERPC64)\n+    {\n+      /* Fail if the mask is not 32-bit.  */\n+      if (mode == DImode && (c & ~(unsigned HOST_WIDE_INT) 0xffffffff) != 0)\n+\treturn 0;\n \n-  /* Reject all zeros or all ones in 32-bit mode.  */\n-  if (c == 0 || (mode == SImode && c == -1))\n-    return 0;\n+      /* Fail if the mask wraps around because the upper 32-bits of the\n+\t mask will all be 1s, contrary to GCC's internal view.  */\n+      if ((c & 0x80000001) == 0x80000001)\n+\treturn 0;\n+    }\n \n   /* We don't change the number of transitions by inverting,\n      so make sure we start with the LS bit zero.  */\n   if (c & 1)\n     c = ~c;\n \n+  /* Reject all zeros or all ones.  */\n+  if (c == 0)\n+    return 0;\n+\n   /* Find the first transition.  */\n   lsb = c & -c;\n \n-  if (mode == SImode)\n-    {\n-      /* Invert to look for a second transition.  */\n-      c = ~c;\n+  /* Invert to look for a second transition.  */\n+  c = ~c;\n \n-      /* Erase first transition.  */\n-      c &= -lsb;\n+  /* Erase first transition.  */\n+  c &= -lsb;\n \n-      /* Find the second transition (if any).  */\n-      lsb = c & -c;\n-    }\n+  /* Find the second transition (if any).  */\n+  lsb = c & -c;\n \n   /* Match if all the bits above are 1's (or c is zero).  */\n   return c == -lsb;\n@@ -522,20 +522,81 @@\n   return c == -lsb;\n })\n \n-;; Like mask_operand, but allow up to three transitions.  This\n+;; Return 1 if the operand is a constant that is a PowerPC64 mask\n+;; suitable for use with rldicl or rldicr (no more than one 1->0 or 0->1\n+;; transition).  Reject all zeros, since zero should have been\n+;; optimized away and confuses the making of MB and ME.\n+(define_predicate \"mask64_operand\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT c, lsb;\n+\n+  c = INTVAL (op);\n+\n+  /* Reject all zeros.  */\n+  if (c == 0)\n+    return 0;\n+\n+  /* We don't change the number of transitions by inverting,\n+     so make sure we start with the LS bit zero.  */\n+  if (c & 1)\n+    c = ~c;\n+\n+  /* Find the first transition.  */\n+  lsb = c & -c;\n+\n+  /* Match if all the bits above are 1's (or c is zero).  */\n+  return c == -lsb;\n+})\n+\n+;; Like mask64_operand, but allow up to three transitions.  This\n ;; predicate is used by insn patterns that generate two rldicl or\n ;; rldicr machine insns.\n (define_predicate \"mask64_2_operand\"\n   (match_code \"const_int\")\n {\n-  return mask64_1or2_operand (op, mode, false);\n+  HOST_WIDE_INT c, lsb;\n+\n+  c = INTVAL (op);\n+\n+  /* Disallow all zeros.  */\n+  if (c == 0)\n+    return 0;\n+\n+  /* We don't change the number of transitions by inverting,\n+     so make sure we start with the LS bit zero.  */\n+  if (c & 1)\n+    c = ~c;\n+\n+  /* Find the first transition.  */\n+  lsb = c & -c;\n+\n+  /* Invert to look for a second transition.  */\n+  c = ~c;\n+\n+  /* Erase first transition.  */\n+  c &= -lsb;\n+\n+  /* Find the second transition.  */\n+  lsb = c & -c;\n+\n+  /* Invert to look for a third transition.  */\n+  c = ~c;\n+\n+  /* Erase second transition.  */\n+  c &= -lsb;\n+\n+  /* Find the third transition (if any).  */\n+  lsb = c & -c;\n+\n+  /* Match if all the bits above are 1's (or c is zero).  */\n+  return c == -lsb;\n })\n \n ;; Like and_operand, but also match constants that can be implemented\n ;; with two rldicl or rldicr insns.\n (define_predicate \"and64_2_operand\"\n-  (ior (and (match_code \"const_int\")\n-\t    (match_test \"mask64_1or2_operand (op, mode, true)\"))\n+  (ior (match_operand 0 \"mask64_2_operand\")\n        (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n \t (match_operand 0 \"gpc_reg_operand\")\n \t (match_operand 0 \"logical_operand\"))))\n@@ -544,9 +605,11 @@\n ;; constant that can be used as the operand of a logical AND.\n (define_predicate \"and_operand\"\n   (ior (match_operand 0 \"mask_operand\")\n-       (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n-\t (match_operand 0 \"gpc_reg_operand\")\n-\t (match_operand 0 \"logical_operand\"))))\n+       (ior (and (match_test \"TARGET_POWERPC64 && mode == DImode\")\n+\t\t (match_operand 0 \"mask64_operand\"))\n+            (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n+\t      (match_operand 0 \"gpc_reg_operand\")\n+\t      (match_operand 0 \"logical_operand\")))))\n \n ;; Return 1 if the operand is either a logical operand or a short cint operand.\n (define_predicate \"scc_eq_operand\""}, {"sha": "b946c90d9390983de9b9fc85b54e00ef2f9d4621", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=1990cd79695bdc9214496c869fedf53a2194f555", "patch": "@@ -34,7 +34,6 @@ extern void rs6000_va_start (tree, rtx);\n \n extern int easy_vector_same (rtx, enum machine_mode);\n extern int easy_vector_splat_const (int, enum machine_mode);\n-extern int mask64_1or2_operand (rtx, enum machine_mode, bool);\n extern bool macho_lo_sum_memory_operand (rtx, enum machine_mode);\n extern int num_insns_constant (rtx, enum machine_mode);\n extern int num_insns_constant_wide (HOST_WIDE_INT);"}, {"sha": "ca58f306d7f2799f948f75051d809677c560de58", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 60, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1990cd79695bdc9214496c869fedf53a2194f555", "patch": "@@ -1980,7 +1980,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n     case CONST_INT:\n #if HOST_BITS_PER_WIDE_INT == 64\n       if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n-\t  && mask_operand (op, mode))\n+\t  && mask64_operand (op, mode))\n \treturn 2;\n       else\n #endif\n@@ -2022,7 +2022,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t\t|| (high == -1 && low < 0))\n \t      return num_insns_constant_wide (low);\n \n-\t    else if (mask_operand (op, mode))\n+\t    else if (mask64_operand (op, mode))\n \t      return 2;\n \n \t    else if (low == 0)\n@@ -2346,61 +2346,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n   emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n }\n \n-int\n-mask64_1or2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       bool allow_one)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      HOST_WIDE_INT c, lsb;\n-      bool one_ok;\n-\n-      c = INTVAL (op);\n-\n-      /* Disallow all zeros.  */\n-      if (c == 0)\n-\treturn 0;\n-\n-      /* We can use a single rlwinm insn if no upper bits of C are set\n-         AND there are zero, one or two transitions in the _whole_ of\n-         C.  */\n-      one_ok = !(c & ~(HOST_WIDE_INT)0xffffffff);\n-\n-      /* We don't change the number of transitions by inverting,\n-\t so make sure we start with the LS bit zero.  */\n-      if (c & 1)\n-\tc = ~c;\n-\n-      /* Find the first transition.  */\n-      lsb = c & -c;\n-\n-      /* Invert to look for a second transition.  */\n-      c = ~c;\n-\n-      /* Erase first transition.  */\n-      c &= -lsb;\n-\n-      /* Find the second transition.  */\n-      lsb = c & -c;\n-\n-      /* Invert to look for a third transition.  */\n-      c = ~c;\n-\n-      /* Erase second transition.  */\n-      c &= -lsb;\n-\n-      if (one_ok && !(allow_one || c))\n-\treturn 0;\n-\n-      /* Find the third transition (if any).  */\n-      lsb = c & -c;\n-\n-      /* Match if all the bits above are 1's (or c is zero).  */\n-      return c == -lsb;\n-    }\n-  return 0;\n-}\n-\n /* Generates shifts and masks for a pair of rldicl or rldicr insns to\n    implement ANDing by the mask IN.  */\n void\n@@ -10379,7 +10324,7 @@ print_operand (FILE *file, rtx x, int code)\n       /* PowerPC64 mask position.  All 0's is excluded.\n \t CONST_INT 32-bit mask is considered sign-extended so any\n \t transition must occur within the CONST_INT, not on the boundary.  */\n-      if (! mask_operand (x, DImode))\n+      if (! mask64_operand (x, DImode))\n \toutput_operand_lossage (\"invalid %%S value\");\n \n       uval = INT_LOWPART (x);\n@@ -18235,7 +18180,9 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n \t\t  || (CONST_OK_FOR_LETTER_P (INTVAL (x),\n \t\t\t\t\t     mode == SImode ? 'L' : 'J'))\n-\t\t  || mask_operand (x, VOIDmode)))\n+\t\t  || mask_operand (x, mode)\n+\t\t  || (mode == DImode\n+\t\t      && mask64_operand (x, DImode))))\n \t  || ((outer_code == IOR || outer_code == XOR)\n \t      && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n \t\t  || (CONST_OK_FOR_LETTER_P (INTVAL (x),\n@@ -18287,7 +18234,8 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  && ((outer_code == AND\n \t       && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n \t\t   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L')\n-\t\t   || mask_operand (x, DImode)))\n+\t\t   || mask_operand (x, DImode)\n+\t\t   || mask64_operand (x, DImode)))\n \t      || ((outer_code == IOR || outer_code == XOR)\n \t\t  && CONST_DOUBLE_HIGH (x) == 0\n \t\t  && (CONST_DOUBLE_LOW (x)"}, {"sha": "679ccee8144c09508bc42ac4e625210e9e4275df", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=1990cd79695bdc9214496c869fedf53a2194f555", "patch": "@@ -1105,26 +1105,28 @@ enum reg_class\n \n    'Q' means that is a memory operand that is just an offset from a reg.\n    'R' is for AIX TOC entries.\n-   'S' is a constant that can be placed into a 64-bit mask operand\n-   'T' is a constant that can be placed into a 32-bit mask operand\n+   'S' is a constant that can be placed into a 64-bit mask operand.\n+   'T' is a constant that can be placed into a 32-bit mask operand.\n    'U' is for V.4 small data references.\n    'W' is a vector constant that can be easily generated (no mem refs).\n    'Y' is an indexed or word-aligned displacement memory operand.\n    'Z' is an indexed or indirect memory operand.\n    'a'  is an indexed or indirect address operand.\n-   't' is for AND masks that can be performed by two rldic{l,r} insns.  */\n+   't' is for AND masks that can be performed by two rldic{l,r} insns\n+       (but excluding those that could match other constraints of anddi3.)  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n    : (C) == 'R' ? legitimate_constant_pool_address_p (OP)\t\t\\\n-   : (C) == 'S' ? mask_operand (OP, DImode)\t\t\t\t\\\n-   : (C) == 'T' ? mask_operand (OP, SImode)\t\t\t\t\\\n+   : (C) == 'S' ? mask64_operand (OP, DImode)\t\t\t\t\\\n+   : (C) == 'T' ? mask_operand (OP, GET_MODE (OP))\t\t\t\\\n    : (C) == 'U' ? (DEFAULT_ABI == ABI_V4\t\t\t\t\\\n \t\t   && small_data_operand (OP, GET_MODE (OP)))\t\t\\\n    : (C) == 't' ? (mask64_2_operand (OP, DImode)\t\t\t\\\n \t\t   && (fixed_regs[CR0_REGNO]\t\t\t\t\\\n \t\t       || !logical_operand (OP, DImode))\t\t\\\n-\t\t   && !mask_operand (OP, DImode))\t\t\t\\\n+\t\t   && !mask_operand (OP, DImode)\t\t\t\\\n+\t\t   && !mask64_operand (OP, DImode))\t\t\t\\\n    : (C) == 'W' ? (easy_vector_constant (OP, GET_MODE (OP)))\t\t\\\n    : (C) == 'Y' ? (word_offset_memref_operand (OP, GET_MODE (OP)))      \\\n    : (C) == 'Z' ? (indexed_or_indirect_operand (OP, GET_MODE (OP)))\t\\"}, {"sha": "d8332e3457084eb25c75c78666d692da9ee387a9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1990cd79695bdc9214496c869fedf53a2194f555/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=1990cd79695bdc9214496c869fedf53a2194f555", "patch": "@@ -5979,7 +5979,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n-\t\t(match_operand:DI 3 \"mask_operand\" \"n\")))]\n+\t\t(match_operand:DI 3 \"mask64_operand\" \"n\")))]\n   \"TARGET_POWERPC64\"\n   \"rld%I2c%B3 %0,%1,%H2,%S3\")\n \n@@ -5988,7 +5988,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n-\t\t     (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n+\t\t     (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 4 \"=r,r\"))]\n   \"TARGET_64BIT\"\n@@ -6003,7 +6003,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\"))\n-\t\t     (match_operand:DI 3 \"mask_operand\" \"\"))\n+\t\t     (match_operand:DI 3 \"mask64_operand\" \"\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 4 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n@@ -6021,7 +6021,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n-\t\t     (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n+\t\t     (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6037,7 +6037,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\"))\n-\t\t     (match_operand:DI 3 \"mask_operand\" \"\"))\n+\t\t     (match_operand:DI 3 \"mask64_operand\" \"\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6435,7 +6435,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:DI 3 \"mask_operand\" \"n\")))]\n+\t\t(match_operand:DI 3 \"mask64_operand\" \"n\")))]\n   \"TARGET_POWERPC64 && includes_rldicr_lshift_p (operands[2], operands[3])\"\n   \"rldicr %0,%1,%H2,%S3\")\n \n@@ -6444,7 +6444,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n+\t\t (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"=r,r\"))]\n   \"TARGET_64BIT && includes_rldicr_lshift_p (operands[2], operands[3])\"\n@@ -6459,7 +6459,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\n@@ -6477,7 +6477,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t    (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n+\t\t    (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6493,7 +6493,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6698,7 +6698,8 @@\n    (clobber (match_scratch:CC 3 \"\"))]\n   \"TARGET_POWERPC64\n     && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask_operand (operands[2], DImode)\"\n+    && !mask_operand (operands[2], DImode)\n+    && !mask64_operand (operands[2], DImode)\"\n   [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 4))\n@@ -6712,26 +6713,28 @@\n })\n \n (define_insn \"*anddi3_internal2\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,x,?y,?y,??y,??y,?y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,K,J,t,r,S,K,J,t\"))\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,x,x,?y,?y,?y,??y,??y,?y\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,T,K,J,t,r,S,T,K,J,t\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r,r,r,r,r,r,r,r,r\"))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,x,x,X\"))]\n+   (clobber (match_scratch:DI 3 \"=r,r,r,r,r,r,r,r,r,r,r,r\"))\n+   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,X,X,x,x,X\"))]\n   \"TARGET_64BIT\"\n   \"@\n    and. %3,%1,%2\n    rldic%B2. %3,%1,0,%S2\n+   rlwinm. %3,%1,0,%m2,%M2\n    andi. %3,%1,%b2\n    andis. %3,%1,%u2\n    #\n    #\n    #\n    #\n    #\n+   #\n    #\"\n-  [(set_attr \"type\" \"compare,delayed_compare,compare,compare,delayed_compare,compare,compare,compare,compare,compare\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,8,8,12\")])\n+  [(set_attr \"type\" \"compare,delayed_compare,delayed_compare,compare,compare,delayed_compare,delayed_compare,compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"4,4,4,4,4,8,8,8,8,8,8,12\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n@@ -6740,9 +6743,10 @@\n                     (const_int 0)))\n    (clobber (match_scratch:DI 3 \"\"))\n    (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\n+  \"TARGET_64BIT && reload_completed\n     && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask_operand (operands[2], DImode)\"\n+    && !mask_operand (operands[2], DImode)\n+    && !mask64_operand (operands[2], DImode)\"\n   [(set (match_dup 3)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 5))\n@@ -6759,37 +6763,39 @@\n }\")\n \n (define_insn \"*anddi3_internal3\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,x,?y,?y,??y,??y,?y\")\n-\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,K,J,t,r,S,K,J,t\"))\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,x,x,?y,?y,?y,??y,??y,?y\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r,r,r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"r,S,T,K,J,t,r,S,T,K,J,t\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r,r,r\")\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r,r,r,r,r\")\n \t(and:DI (match_dup 1) (match_dup 2)))\n-   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,x,x,X\"))]\n+   (clobber (match_scratch:CC 4 \"=X,X,X,X,X,X,X,X,X,x,x,X\"))]\n   \"TARGET_64BIT\"\n   \"@\n    and. %0,%1,%2\n    rldic%B2. %0,%1,0,%S2\n+   rlwinm. %0,%1,0,%m2,%M2\n    andi. %0,%1,%b2\n    andis. %0,%1,%u2\n    #\n    #\n    #\n    #\n    #\n+   #\n    #\"\n-  [(set_attr \"type\" \"compare,delayed_compare,compare,compare,delayed_compare,compare,compare,compare,compare,compare\")\n-   (set_attr \"length\" \"4,4,4,4,8,8,8,8,8,12\")])\n+  [(set_attr \"type\" \"compare,delayed_compare,delayed_compare,compare,compare,delayed_compare,delayed_compare,compare,compare,compare,compare,compare\")\n+   (set_attr \"length\" \"4,4,4,4,4,8,8,8,8,8,8,12\")])\n \n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"and_operand\" \"\"))\n+\t\t\t    (match_operand:DI 2 \"and64_2_operand\" \"\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (match_dup 1) (match_dup 2)))\n    (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n+  \"TARGET_64BIT && reload_completed\"\n   [(parallel [(set (match_dup 0)\n \t\t    (and:DI (match_dup 1) (match_dup 2)))\n \t       (clobber (match_dup 4))])\n@@ -6806,9 +6812,10 @@\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (match_dup 1) (match_dup 2)))\n    (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\n+  \"TARGET_64BIT && reload_completed\n     && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask_operand (operands[2], DImode)\"\n+    && !mask_operand (operands[2], DImode)\n+    && !mask64_operand (operands[2], DImode)\"\n   [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 5))\n@@ -8024,7 +8031,7 @@\n ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"mask_operand\" \"\"))]\n+\t(match_operand:DI 1 \"mask64_operand\" \"\"))]\n   \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0) (const_int -1))\n    (set (match_dup 0)"}]}