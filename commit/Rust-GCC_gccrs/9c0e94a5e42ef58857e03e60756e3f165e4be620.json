{"sha": "9c0e94a5e42ef58857e03e60756e3f165e4be620", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMwZTk0YTVlNDJlZjU4ODU3ZTAzZTYwNzU2ZTNmMTY1ZTRiZTYyMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-06-16T17:08:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-06-16T17:08:48Z"}, "message": "alpha.c (alpha_expand_prologue, [...]): New fns.\n\n        * alpha.c (alpha_expand_prologue, alpha_expand_epilogue): New fns.\n        (output_prologue, output_epilogue): Merge VMS and OSF versions;\n        Remove anything related to the actual code generation.\n        (output_end_prologue): New function.\n        (alpha_sa_mask, alpha_sa_size): Merge VMS and OSF versions.\n        (alpha_does_function_need_gp): Return false for VMS.\n        (alpha_function_needs_gp): Make static.\n        (add_long_const): Delete.\n        (summarize_insn): Don't assume a SUBREG is of a REG.\n        Prototype all static functions.  Rename VMS-specific global\n        variables vms_*.\n        * alpha.h (TARGET_CAN_FAULT_IN_PROLOGUE): Default to 0.\n        (FUNCTION_BOUNDARY): Align to cache line.\n        (LOOP_ALIGN, ALIGN_LABEL_AFTER_BARRIER): Align to octaword.\n        (FUNCTION_END_PROLOGUE): New macro.\n        * alpha.md (attribute length): New.  Mark all insns.\n        (return_internal, prologue_stack_probe_loop) New patterns.\n        (prologue, init_fp, epilogue): New patterns.\n        Disable peepholes.\n        * linux.h (TARGET_CAN_FAULT_IN_PROLOGUE): Define.\n\nFrom-SVN: r20528", "tree": {"sha": "b0c0bec26333689d589f1537f9731b32506da91d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0c0bec26333689d589f1537f9731b32506da91d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c0e94a5e42ef58857e03e60756e3f165e4be620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c0e94a5e42ef58857e03e60756e3f165e4be620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c0e94a5e42ef58857e03e60756e3f165e4be620", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c0e94a5e42ef58857e03e60756e3f165e4be620/comments", "author": null, "committer": null, "parents": [{"sha": "ad1da1de8c8be979a895f794def77ddd05ac8a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1da1de8c8be979a895f794def77ddd05ac8a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad1da1de8c8be979a895f794def77ddd05ac8a53"}], "stats": {"total": 1491, "additions": 745, "deletions": 746}, "files": [{"sha": "0c0b1691a89aeab471c0b7be72573638b5ab7922", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c0e94a5e42ef58857e03e60756e3f165e4be620", "patch": "@@ -1,3 +1,26 @@\n+Tue Jun 16 16:49:26 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_expand_prologue, alpha_expand_epilogue): New fns.\n+\t(output_prologue, output_epilogue): Merge VMS and OSF versions;\n+\tRemove anything related to the actual code generation.\n+\t(output_end_prologue): New function.\n+\t(alpha_sa_mask, alpha_sa_size): Merge VMS and OSF versions.\n+\t(alpha_does_function_need_gp): Return false for VMS.\n+\t(alpha_function_needs_gp): Make static.\n+\t(add_long_const): Delete.\n+\t(summarize_insn): Don't assume a SUBREG is of a REG.\n+\tPrototype all static functions.  Rename VMS-specific global\n+\tvariables vms_*.\n+\t* alpha.h (TARGET_CAN_FAULT_IN_PROLOGUE): Default to 0.\n+\t(FUNCTION_BOUNDARY): Align to cache line.\n+\t(LOOP_ALIGN, ALIGN_LABEL_AFTER_BARRIER): Align to octaword.\n+\t(FUNCTION_END_PROLOGUE): New macro.\n+\t* alpha.md (attribute length): New.  Mark all insns.\n+\t(return_internal, prologue_stack_probe_loop) New patterns.\n+\t(prologue, init_fp, epilogue): New patterns.\n+\tDisable peepholes.\n+\t* linux.h (TARGET_CAN_FAULT_IN_PROLOGUE): Define.\n+\n Tue Jun 16 17:36:35 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* toplev.c (lang_options): Add -trigraphs option for cpplib."}, {"sha": "172bf69b15c2c516e160ccb212f8a6f974f1c4c3", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 583, "deletions": 696, "changes": 1279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=9c0e94a5e42ef58857e03e60756e3f165e4be620", "patch": "@@ -89,10 +89,6 @@ char *alpha_function_name;\n \n static int inside_function = FALSE;\n \n-/* Nonzero if the current function needs gp.  */\n-\n-int alpha_function_needs_gp;\n-\n /* If non-null, this rtx holds the return address for the function.  */\n \n static rtx alpha_return_addr_rtx;\n@@ -101,30 +97,34 @@ static rtx alpha_return_addr_rtx;\n \n int alpha_memory_latency = 3;\n \n+/* Whether the function needs the GP.  */\n+\n+static int alpha_function_needs_gp;\n+\n /* Declarations of static functions.  */\n-static void alpha_set_memflags_1  PROTO((rtx, int, int, int));\n-static rtx alpha_emit_set_const_1 PROTO((rtx, enum machine_mode,\n-\t\t\t\t\t HOST_WIDE_INT, int));\n-static void add_long_const\tPROTO((FILE *, HOST_WIDE_INT, int, int, int));\n+static void alpha_set_memflags_1\n+  PROTO((rtx, int, int, int));\n+static rtx alpha_emit_set_const_1\n+  PROTO((rtx, enum machine_mode, HOST_WIDE_INT, int));\n+static void alpha_expand_unaligned_load_words\n+  PROTO((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n+static void alpha_expand_unaligned_store_words\n+  PROTO((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n+static void alpha_sa_mask\n+  PROTO((unsigned long *imaskP, unsigned long *fmaskP));\n+static int alpha_does_function_need_gp\n+  PROTO((void));\n+\n \n-/* Compute the size of the save area in the stack.  */\n-#if OPEN_VMS\n-static void alpha_sa_mask\tPROTO((unsigned long *imaskP,\n-\t\t\t\t       unsigned long *fmaskP));\n-#endif\n /* Get the number of args of a function in one of two ways.  */\n #ifdef OPEN_VMS\n #define NUM_ARGS current_function_args_info.num_args\n #else\n #define NUM_ARGS current_function_args_info\n #endif\n \n-#if OPEN_VMS\n #define REG_PV 27\n #define REG_RA 26\n-#else\n-#define REG_RA 26\n-#endif\n \f\n /* Parse target option strings. */\n \n@@ -813,6 +813,17 @@ any_memory_operand (op, mode)\n \t      && REGNO (SUBREG_REG (op)) >= FIRST_PSEUDO_REGISTER));\n }\n \n+/* Return 1 if this function can directly return via $26.  */\n+\n+int\n+direct_return ()\n+{\n+  return (! TARGET_OPEN_VMS && reload_completed && alpha_sa_size () == 0\n+\t  && get_frame_size () == 0\n+\t  && current_function_outgoing_args_size == 0\n+\t  && current_function_pretend_args_size == 0);\n+}\n+\n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into\n    *PBITNUM.  */\n@@ -2900,26 +2911,24 @@ alpha_builtin_saveregs (arglist)\n \n /* Compute the size of the save area in the stack.  */\n \n-#if OPEN_VMS\n-\n /* These variables are used for communication between the following functions.\n    They indicate various things about the current function being compiled\n    that are used to tell what kind of prologue, epilogue and procedure\n    descriptior to generate. */\n \n /* Nonzero if we need a stack procedure.  */\n-static int is_stack_procedure;\n+static int vms_is_stack_procedure;\n \n /* Register number (either FP or SP) that is used to unwind the frame.  */\n-static int unwind_regno;\n+static int vms_unwind_regno;\n \n /* Register number used to save FP.  We need not have one for RA since\n    we don't modify it for register procedures.  This is only defined\n    for register frame procedures.  */\n-static int save_fp_regno;\n+static int vms_save_fp_regno;\n \n /* Register number used to reference objects off our PV.  */\n-static int base_regno;\n+static int vms_base_regno;\n \n /*  Compute register masks for saved registers.  */\n \n@@ -2932,7 +2941,7 @@ alpha_sa_mask (imaskP, fmaskP)\n   unsigned long fmask = 0;\n   int i;\n \n-  if (is_stack_procedure)\n+  if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n     imask |= (1L << HARD_FRAME_POINTER_REGNUM);\n \n   /* One for every register we have to save.  */\n@@ -2947,6 +2956,9 @@ alpha_sa_mask (imaskP, fmaskP)\n \t  fmask |= (1L << (i - 32));\n       }\n \n+  if (imask || fmask || alpha_ra_ever_killed ())\n+    imask |= (1L << REG_RA);\n+\n   *imaskP = imask;\n   *fmaskP = fmask;\n \n@@ -2957,7 +2969,6 @@ int\n alpha_sa_size ()\n {\n   int sa_size = 0;\n-  HOST_WIDE_INT stack_needed;\n   int i;\n \n   /* One for every register we have to save.  */\n@@ -2967,40 +2978,54 @@ alpha_sa_size ()\n \t&& regs_ever_live[i] && i != REG_RA)\n       sa_size++;\n \n-  /* Start by assuming we can use a register procedure if we don't make any\n-     calls (REG_RA not used) or need to save any registers and a stack\n-     procedure if we do.  */\n-  is_stack_procedure = sa_size != 0 || alpha_ra_ever_killed ();\n-\n-  /* Decide whether to refer to objects off our PV via FP or PV.\n-     If we need FP for something else or if we receive a nonlocal\n-     goto (which expects PV to contain the value), we must use PV.\n-     Otherwise, start by assuming we can use FP.  */\n-  base_regno = (frame_pointer_needed || current_function_has_nonlocal_label\n-\t\t|| is_stack_procedure\n-\t\t|| current_function_outgoing_args_size\n-\t\t? REG_PV : HARD_FRAME_POINTER_REGNUM);\n-\n-  /* If we want to copy PV into FP, we need to find some register in which to\n-     save FP.  */\n-\n-  save_fp_regno = -1;\n-\n-  if (base_regno == HARD_FRAME_POINTER_REGNUM)\n-    for (i = 0; i < 32; i++)\n-      if (! fixed_regs[i] && call_used_regs[i] && ! regs_ever_live[i])\n-\tsave_fp_regno = i;\n-\n-  if (save_fp_regno == -1)\n-    base_regno = REG_PV, is_stack_procedure = 1;\n-\n-  /* Stack unwinding should be done via FP unless we use it for PV.  */\n-  unwind_regno\n-    = base_regno == REG_PV ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM;\n-\n-  /* If this is a stack procedure, allow space for saving FP and RA.  */\n-  if (is_stack_procedure)\n-    sa_size += 2;\n+  if (TARGET_OPEN_VMS)\n+    {\n+      /* Start by assuming we can use a register procedure if we don't\n+\t make any calls (REG_RA not used) or need to save any\n+\t registers and a stack procedure if we do.  */\n+      vms_is_stack_procedure = sa_size != 0 || alpha_ra_ever_killed ();\n+\n+      /* Decide whether to refer to objects off our PV via FP or PV.\n+\t If we need FP for something else or if we receive a nonlocal\n+\t goto (which expects PV to contain the value), we must use PV.\n+\t Otherwise, start by assuming we can use FP.  */\n+      vms_base_regno = (frame_pointer_needed\n+\t\t\t|| current_function_has_nonlocal_label\n+\t\t\t|| vms_is_stack_procedure\n+\t\t\t|| current_function_outgoing_args_size\n+\t\t\t? REG_PV : HARD_FRAME_POINTER_REGNUM);\n+\n+      /* If we want to copy PV into FP, we need to find some register\n+\t in which to save FP.  */\n+\n+      vms_save_fp_regno = -1;\n+      if (vms_base_regno == HARD_FRAME_POINTER_REGNUM)\n+\tfor (i = 0; i < 32; i++)\n+\t  if (! fixed_regs[i] && call_used_regs[i] && ! regs_ever_live[i])\n+\t    vms_save_fp_regno = i;\n+\n+      if (vms_save_fp_regno == -1)\n+\tvms_base_regno = REG_PV, vms_is_stack_procedure = 1;\n+\n+      /* Stack unwinding should be done via FP unless we use it for PV.  */\n+      vms_unwind_regno = (vms_base_regno == REG_PV\n+\t\t\t  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\n+      /* If this is a stack procedure, allow space for saving FP and RA.  */\n+      if (vms_is_stack_procedure)\n+\tsa_size += 2;\n+    }\n+  else\n+    {\n+      /* If some registers were saved but not RA, RA must also be saved,\n+\t so leave space for it.  */\n+      if (sa_size != 0 || alpha_ra_ever_killed ())\n+\tsa_size++;\n+\n+      /* Our size must be even (multiple of 16 bytes).  */\n+      if (sa_size & 1)\n+\tsa_size++;\n+    }\n \n   return sa_size * 8;\n }\n@@ -3009,52 +3034,61 @@ int\n alpha_pv_save_size ()\n {\n   alpha_sa_size ();\n-  return is_stack_procedure ? 8 : 0;\n+  return vms_is_stack_procedure ? 8 : 0;\n }\n \n int\n alpha_using_fp ()\n {\n   alpha_sa_size ();\n-  return unwind_regno == HARD_FRAME_POINTER_REGNUM;\n+  return vms_unwind_regno == HARD_FRAME_POINTER_REGNUM;\n }\n \n-#else /* ! OPEN_VMS */\n-\n int\n-alpha_sa_size ()\n+vms_valid_decl_attribute_p (decl, attributes, identifier, args)\n+     tree decl;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n {\n-  int size = 0;\n-  int i;\n+  if (is_attribute_p (\"overlaid\", identifier))\n+    return (args == NULL_TREE);\n+  return 0;\n+}\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& regs_ever_live[i] && i != REG_RA)\n-      size++;\n+static int\n+alpha_does_function_need_gp ()\n+{\n+  rtx insn;\n \n-  /* If some registers were saved but not reg 26, reg 26 must also\n-     be saved, so leave space for it.  */\n-  if (size != 0 || alpha_ra_ever_killed ())\n-    size++;\n+  /* We never need a GP for Windows/NT or VMS.  */\n+  if (TARGET_WINDOWS_NT || TARGET_OPEN_VMS)\n+    return 0;\n \n-  /* Our size must be even (multiple of 16 bytes).  */\n-  if (size & 1)\n-    size ++;\n+#ifdef TARGET_PROFILING_NEEDS_GP\n+  if (profile_flag)\n+    return 1;\n+#endif\n \n-  return size * 8;\n-}\n+  /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n+     Even if we are a static function, we still need to do this in case\n+     our address is taken and passed to something like qsort.  */\n \n-#endif /* ! OPEN_VMS */\n+  push_topmost_sequence ();\n+  insn = get_insns ();\n+  pop_topmost_sequence ();\n \n-/* Return 1 if this function can directly return via $26.  */\n+  for (; insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& GET_CODE (PATTERN (insn)) != USE\n+\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n+      {\n+\tenum attr_type type = get_attr_type (insn);\n+\tif (type == TYPE_LDSYM || type == TYPE_JSR)\n+\t  return 1;\n+      }\n \n-int\n-direct_return ()\n-{\n-  return (! TARGET_OPEN_VMS && reload_completed && alpha_sa_size () == 0\n-\t  && get_frame_size () == 0\n-\t  && current_function_outgoing_args_size == 0\n-\t  && current_function_pretend_args_size == 0);\n+  return 0;\n }\n \n /* Write a version stamp.  Don't write anything if we are running as a\n@@ -3073,68 +3107,8 @@ alpha_write_verstamp (file)\n #endif\n }\n \f\n-/* Write code to add constant C to register number IN_REG (possibly 31)\n-   and put the result into OUT_REG.  Use TEMP_REG as a scratch register;\n-   usually this will be OUT_REG, but should not be if OUT_REG is \n-   STACK_POINTER_REGNUM, since it must be updated in a single instruction.\n-   Write the code to FILE.  */\n-\n-static void\n-add_long_const (file, c, in_reg, out_reg, temp_reg)\n-     FILE *file;\n-     HOST_WIDE_INT c;\n-     int in_reg, out_reg, temp_reg;\n-{\n-  HOST_WIDE_INT low = (c & 0xffff) - 2 * (c & 0x8000);\n-  HOST_WIDE_INT tmp1 = c - low;\n-  HOST_WIDE_INT high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-  HOST_WIDE_INT extra = 0;\n-\n-  /* We don't have code to write out constants larger than 32 bits.  */\n-#if HOST_BITS_PER_LONG_INT == 64\n-  if ((unsigned HOST_WIDE_INT) c >> 32 != 0)\n-    abort ();\n-#endif\n-\n-  /* If HIGH will be interpreted as negative, we must adjust it to do two\n-     ldha insns.  Note that we will never be building a negative constant\n-     here.  */\n-\n-  if (high & 0x8000)\n-    {\n-      extra = 0x4000;\n-      tmp1 -= 0x40000000;\n-      high = ((tmp1 >> 16) & 0xffff) - 2 * ((tmp1 >> 16) & 0x8000);\n-    }\n-\n-  if (low != 0)\n-    {\n-      int result_reg = (extra == 0 && high == 0) ? out_reg : temp_reg;\n-\n-      if (low >= 0 && low < 255)\n-\tfprintf (file, \"\\taddq $%d,%d,$%d\\n\", in_reg, low, result_reg);\n-      else\n-\tfprintf (file, \"\\tlda $%d,%d($%d)\\n\", result_reg, low, in_reg);\n-\n-      in_reg = result_reg;\n-    }\n-\n-  if (extra)\n-    {\n-      int result_reg = (high == 0) ? out_reg : temp_reg;\n-\n-      fprintf (file, \"\\tldah $%d,%d($%d)\\n\", result_reg, extra, in_reg);\n-      in_reg = result_reg;\n-    }\n-\n-  if (high)\n-    fprintf (file, \"\\tldah $%d,%d($%d)\\n\", out_reg, high, in_reg);\n-}\n-\n /* Write function prologue.  */\n \n-#if OPEN_VMS\n-\n /* On vms we have two kinds of functions:\n \n    - stack frame (PROC_STACK)\n@@ -3147,47 +3121,44 @@ add_long_const (file, c, in_reg, out_reg, temp_reg)\n    proper pdsc (procedure descriptor)\n    This is done with the '.pdesc' command.\n \n-   size is the stack size needed for local variables.  */\n+   On not-vms, we don't really differentiate between the two, as we can\n+   simply allocate stack without saving registers.  */\n \n void\n-output_prolog (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n+alpha_expand_prologue ()\n {\n+  /* Registers to save.  */\n   unsigned long imask = 0;\n   unsigned long fmask = 0;\n   /* Stack space needed for pushing registers clobbered by us.  */\n   HOST_WIDE_INT sa_size;\n   /* Complete stack size needed.  */\n   HOST_WIDE_INT frame_size;\n   /* Offset from base reg to register save area.  */\n-  int rsa_offset = 8;\n-  /* Offset during register save.  */\n-  int reg_offset;\n-  /* Label for the procedure entry.  */\n-  char *entry_label = (char *) alloca (strlen (alpha_function_name) + 6);\n+  HOST_WIDE_INT reg_offset;\n+  rtx sa_reg;\n   int i;\n \n   sa_size = alpha_sa_size ();\n-  frame_size\n-    = ALPHA_ROUND (sa_size \n-\t\t   + (is_stack_procedure ? 8 : 0)\n-\t\t   + size + current_function_pretend_args_size);\n \n-  /* Issue function start and label.  */\n-  fprintf (file, \"\\t.ent \");\n-  assemble_name (file, alpha_function_name);\n-  fprintf (file, \"\\n\");\n-  sprintf (entry_label, \"%s..en\", alpha_function_name);\n-  ASM_OUTPUT_LABEL (file, entry_label);\n-  inside_function = TRUE;\n-\n-  fprintf (file, \"\\t.base $%d\\n\", base_regno);\n+  frame_size = get_frame_size ();\n+  if (TARGET_OPEN_VMS)\n+    frame_size = ALPHA_ROUND (sa_size \n+\t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n+\t\t\t      + frame_size\n+\t\t\t      + current_function_pretend_args_size);\n+  else\n+    frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n+\t\t  + sa_size\n+\t\t  + ALPHA_ROUND (frame_size\n+\t\t\t\t + current_function_pretend_args_size));\n \n-  /* Calculate register masks for clobbered registers.  */\n+  if (TARGET_OPEN_VMS)\n+    reg_offset = 8;\n+  else\n+    reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n \n-  if (is_stack_procedure)\n-    alpha_sa_mask (&imask, &fmask);\n+  alpha_sa_mask (&imask, &fmask);\n \n   /* Adjust the stack by the frame size.  If the frame size is > 4096\n      bytes, we need to be sure we probe somewhere in the first and last\n@@ -3198,319 +3169,203 @@ output_prolog (file, size)\n \n      Note that we are only allowed to adjust sp once in the prologue.  */\n \n-  if (frame_size < 32768)\n+  if (frame_size <= 32768)\n     {\n       if (frame_size > 4096)\n \t{\n \t  int probed = 4096;\n \n-\t  fprintf (file, \"\\tstq $31,-%d($30)\\n\", probed);\n-\n-\t  while (probed + 8192 < frame_size)\n-\t    fprintf (file, \"\\tstq $31,-%d($30)\\n\", probed += 8192);\n+\t  do\n+\t    emit_insn (gen_probe_stack (GEN_INT (-probed)));\n+\t  while ((probed += 8192) < frame_size);\n \n \t  /* We only have to do this probe if we aren't saving registers.  */\n \t  if (sa_size == 0 && probed + 4096 < frame_size)\n-\t    fprintf (file, \"\\tstq $31,-%d($30)\\n\", frame_size);\n+\t    emit_insn (gen_probe_stack (GEN_INT (-frame_size)));\n \t}\n \n       if (frame_size != 0)\n-\t  fprintf (file, \"\\tlda $30,-%d($30)\\n\", frame_size);\n+\t{\n+\t  emit_move_insn (stack_pointer_rtx,\n+\t\t\t  plus_constant (stack_pointer_rtx, -frame_size));\n+\t}\n     }\n   else\n     {\n-      /* Here we generate code to set R4 to SP + 4096 and set R23 to the\n+      /* Here we generate code to set R22 to SP + 4096 and set R23 to the\n \t number of 8192 byte blocks to probe.  We then probe each block\n \t in the loop and then set SP to the proper location.  If the\n \t amount remaining is > 4096, we have to do one more probe if we\n \t are not saving any registers.  */\n \n       HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;\n       HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;\n+      rtx ptr = gen_rtx_REG (DImode, 22);\n+      rtx count = gen_rtx_REG (DImode, 23);\n \n-      add_long_const (file, blocks, 31, 23, 23);\n-\n-      fprintf (file, \"\\tlda $22,4096($30)\\n\");\n+      emit_move_insn (count, GEN_INT (blocks));\n+      emit_move_insn (ptr, plus_constant (stack_pointer_rtx, 4096));\n \n-      fputc ('$', file);\n-      assemble_name (file, alpha_function_name);\n-      fprintf (file, \"..sc:\\n\");\n-\n-      fprintf (file, \"\\tstq $31,-8192($22)\\n\");\n-      fprintf (file, \"\\tsubq $23,1,$23\\n\");\n-      fprintf (file, \"\\tlda $22,-8192($22)\\n\");\n-\n-      fprintf (file, \"\\tbne $23,$\");\n-      assemble_name (file, alpha_function_name);\n-      fprintf (file, \"..sc\\n\");\n+      /* Because of the difficulty in emitting a new basic block this\n+\t late in the compilation, generate the loop as a single insn.  */\n+      emit_insn (gen_prologue_stack_probe_loop (count, ptr));\n \n       if (leftover > 4096 && sa_size == 0)\n-\tfprintf (file, \"\\tstq $31,-%d($22)\\n\", leftover);\n+\t{\n+\t  rtx last = gen_rtx_MEM (DImode, plus_constant (ptr, -leftover));\n+\t  MEM_VOLATILE_P (last) = 1;\n+\t  emit_move_insn (last, const0_rtx);\n+\t}\n \n-      fprintf (file, \"\\tlda $30,-%d($22)\\n\", leftover);\n+      emit_move_insn (stack_pointer_rtx, plus_constant (ptr, -leftover));\n     }\n \n-  if (is_stack_procedure)\n+  /* Cope with very large offsets to the register save area.  */\n+  sa_reg = stack_pointer_rtx;\n+  if (reg_offset + sa_size > 0x8000)\n     {\n-      int reg_offset = rsa_offset;\n-\n-      /* Store R26 (RA) first.  */\n-      fprintf (file, \"\\tstq $26,%d($30)\\n\", reg_offset);\n-      reg_offset += 8;\n-\n-      /* Store integer regs. according to mask.  */\n-      for (i = 0; i < 32; i++)\n-        if (imask & (1L<<i))\n-\t  {\n-\t    fprintf (file, \"\\tstq $%d,%d($30)\\n\", i, reg_offset);\n-\t    reg_offset += 8;\n-\t  }\n-\n-      /* Print the register mask and do floating-point saves.  */\n-\n-      if (imask)\n-\tfprintf (file, \"\\t.mask 0x%x,0\\n\", imask);\n-\n-      for (i = 0; i < 32; i++)\n-\t{\n-\t  if (fmask & (1L << i))\n-\t    {\n-\t      fprintf (file, \"\\tstt $f%d,%d($30)\\n\", i, reg_offset);\n-\t      reg_offset += 8;\n-\t    }\n-\t}\n+      int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n+      HOST_WIDE_INT bias;\n \n-      /* Print the floating-point mask, if we've saved any fp register.  */\n-      if (fmask)\n-\tfprintf (file, \"\\t.fmask 0x%x,0\\n\", fmask);\n+      if (low + sa_size <= 0x8000)\n+\tbias = reg_offset - low, reg_offset = low;\n+      else \n+\tbias = reg_offset, reg_offset = 0;\n \n-      fprintf (file, \"\\tstq $27,0($30)\\n\");\n+      sa_reg = gen_rtx_REG (DImode, 24);\n+      emit_move_insn (sa_reg, plus_constant (stack_pointer_rtx, bias));\n     }\n-  else \n+    \n+  /* Save regs in stack order.  Beginning with VMS PV.  */\n+  if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n     {\n-      fprintf (file, \"\\t.fp_save $%d\\n\", save_fp_regno);\n-      fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", HARD_FRAME_POINTER_REGNUM,\n-\t       HARD_FRAME_POINTER_REGNUM, save_fp_regno);\n+      emit_move_insn (gen_rtx_MEM (DImode, stack_pointer_rtx),\n+\t\t      gen_rtx_REG (DImode, REG_PV));\n     }\n \n-  if (base_regno != REG_PV)\n-    fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", REG_PV, REG_PV, base_regno);\n-\n-  if (unwind_regno == HARD_FRAME_POINTER_REGNUM)\n-    fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", STACK_POINTER_REGNUM,\n-\t     STACK_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM);\n-\n-  /* Describe our frame.  */\n-  fprintf (file, \"\\t.frame $%d,\", unwind_regno);\n-\n-  /* If the frame size is larger than an integer, print it as zero to\n-     avoid an assembler error.  We won't be properly describing such a\n-     frame, but that's the best we can do.  */\n-  fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-#if HOST_BITS_PER_WIDE_INT == 64\n-\t   frame_size >= (1l << 31) ? 0:\n-#endif\n-\t   frame_size\n-\t   );\n-  fprintf (file, \",$26,%d\\n\", rsa_offset);\n-\n-  /* If we have to allocate space for outgoing args, do it now.  */\n-  if (current_function_outgoing_args_size != 0)\n-    fprintf (file, \"\\tlda $%d,%d($%d)\\n\", STACK_POINTER_REGNUM,\n-\t     - ALPHA_ROUND (current_function_outgoing_args_size),\n-\t     HARD_FRAME_POINTER_REGNUM);\n-\n-  fprintf (file, \"\\t.prologue\\n\");\n-\n-  readonly_section ();\n-  fprintf (file, \"\\t.align 3\\n\");\n-  assemble_name (file, alpha_function_name); fputs (\"..na:\\n\", file);\n-  fputs (\"\\t.ascii \\\"\", file);\n-  assemble_name (file, alpha_function_name);\n-  fputs (\"\\\\0\\\"\\n\", file);\n-      \n-  link_section ();\n-  fprintf (file, \"\\t.align 3\\n\");\n-  fputs (\"\\t.name \", file);\n-  assemble_name (file, alpha_function_name);\n-  fputs (\"..na\\n\", file);\n-  ASM_OUTPUT_LABEL (file, alpha_function_name);\n-  fprintf (file, \"\\t.pdesc \");\n-  assemble_name (file, alpha_function_name);\n-  fprintf (file, \"..en,%s\\n\", is_stack_procedure ? \"stack\" : \"reg\");\n-  alpha_need_linkage (alpha_function_name, 1);\n-  text_section ();\n-\n-  return;\n-}\n-\n-/* Write function epilogue.  */\n-\n-void\n-output_epilog (file, size)\n-     FILE *file;\n-     int size;\n-{\n-  unsigned long imask = 0;\n-  unsigned long fmask = 0;\n-  /* Stack space needed for pushing registers clobbered by us.  */\n-  HOST_WIDE_INT sa_size = alpha_sa_size ();\n-  /* Complete stack size needed.  */\n-  HOST_WIDE_INT frame_size\n-    = ALPHA_ROUND (sa_size\n-\t\t   + (is_stack_procedure ? 8 : 0)\n-\t\t   + size + current_function_pretend_args_size);\n-  int i;\n-  rtx insn = get_last_insn ();\n+  /* Save register RA next.  */\n+  if (imask & (1L << REG_RA))\n+    {\n+      emit_move_insn (gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset)),\n+\t\t      gen_rtx_REG (DImode, REG_RA));\n+      imask &= ~(1L << REG_RA);\n+      reg_offset += 8;\n+    }\n \n-  /* If the last insn was a BARRIER, we don't have to write anything except\n-     the .end pseudo-op.  */\n+  /* Now save any other registers required to be saved.  */\n+  for (i = 0; i < 32; i++)\n+    if (imask & (1L << i))\n+      {\n+\temit_move_insn (gen_rtx_MEM (DImode,\n+\t\t\t\t     plus_constant (sa_reg, reg_offset)),\n+\t\t\tgen_rtx_REG (DImode, i));\n+\treg_offset += 8;\n+      }\n \n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n+  for (i = 0; i < 32; i++)\n+    if (fmask & (1L << i))\n+      {\n+\temit_move_insn (gen_rtx_MEM (DFmode,\n+\t\t\t\t     plus_constant (sa_reg, reg_offset)),\n+\t\t\tgen_rtx_REG (DFmode, i+32));\n+\treg_offset += 8;\n+      }\n \n-  if (insn == 0 || GET_CODE (insn) != BARRIER)\n+  if (TARGET_OPEN_VMS)\n     {\n-      /* Restore clobbered registers, load FP last.  */\n-\n-      if (is_stack_procedure)\n+      if (!vms_is_stack_procedure)\n \t{\n-\t  int rsa_offset = 8;\n-\t  int reg_offset;\n-\t  int fp_offset;\n-\n-\t  if (unwind_regno == HARD_FRAME_POINTER_REGNUM)\n-\t    fprintf (file, \"\\tbis $%d,$%d,$%d\\n\", HARD_FRAME_POINTER_REGNUM,\n-\t\t     HARD_FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);\n-\n-\t  alpha_sa_mask (&imask, &fmask);\n-\n-\t  /* Start reloading registers after RA.  */\n-\t  reg_offset = rsa_offset + 8;\n-\n-\t  for (i = 0; i < 32; i++)\n-\t    if (imask & (1L<<i))\n-\t      {\n-\t\tif (i == HARD_FRAME_POINTER_REGNUM)\n-\t\t  fp_offset = reg_offset;\n-\t\telse\n-\t\t  fprintf (file, \"\\tldq $%d,%d($30)\\n\",\n-\t\t\t\t  i, reg_offset);\n-\t\treg_offset += 8;\n-\t      }\n-\n-\t  for (i = 0; i < 32; i++)\n-\t    if (fmask & (1L << i))\n-\t      {\n-\t\tfprintf (file, \"\\tldt $f%d,%d($30)\\n\", i, reg_offset);\n-\t\treg_offset += 8;\n-\t      }\n+\t  /* Register frame procedures fave the fp.  */\n+\t  emit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),\n+\t\t\t  hard_frame_pointer_rtx);\n+\t}\n \n-\t  /* Restore R26 (RA).  */\n-\t  fprintf (file, \"\\tldq $26,%d($30)\\n\", rsa_offset);\n+      if (vms_base_regno != REG_PV)\n+\temit_move_insn (gen_rtx_REG (DImode, vms_base_regno),\n+\t\t\tgen_rtx_REG (DImode, REG_PV));\n \n-\t  /* Restore R29 (FP).  */\n-\t  fprintf (file, \"\\tldq $29,%d($30)\\n\", fp_offset);\n+      if (vms_unwind_regno == HARD_FRAME_POINTER_REGNUM)\n+\t{\n+\t  emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t}\n-      else\n-\tfprintf (file, \"\\tbis $%d,$%d,$%d\\n\", save_fp_regno, save_fp_regno,\n-\t\t HARD_FRAME_POINTER_REGNUM);\n \n-      if (frame_size != 0)\n+      /* If we have to allocate space for outgoing args, do it now.  */\n+      if (current_function_outgoing_args_size != 0)\n \t{\n-\t  if (frame_size < 32768)\n-\t    fprintf (file, \"\\tlda $30,%d($30)\\n\", frame_size);\n+\t  emit_move_insn (stack_pointer_rtx, \n+\t    plus_constant (hard_frame_pointer_rtx,\n+\t      - ALPHA_ROUND (current_function_outgoing_args_size)));\n+\t}\n+    }\n+  else\n+    {\n+      /* If we need a frame pointer, set it from the stack pointer.  */\n+      if (frame_pointer_needed)\n+\t{\n+\t  if (TARGET_CAN_FAULT_IN_PROLOGUE)\n+\t    emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t  else\n \t    {\n-\t      long high = frame_size >> 16;\n-\t      long low = frame_size & 0xffff;\n-\t      if (low & 0x8000)\n-\t\t{\n-\t\t  high++;\n-\t\t  low = -32768 + (low & 0x7fff);\n-\t\t}\n-\t      fprintf (file, \"\\tldah $2,%ld($31)\\n\", high);\n-\t      fprintf (file, \"\\tlda $2,%ld($2)\\n\", low);\n-\t      fprintf (file, \"\\taddq $30,$2,$30\\n\");\n+\t      /* This must always be the last instruction in the\n+\t\t prologue, thus we emit a special move + clobber.  */\n+\t      emit_insn (gen_init_fp (hard_frame_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx, sa_reg));\n \t    }\n \t}\n-\n-      /* Finally return to the caller.  */\n-      fprintf (file, \"\\tret $31,($26),1\\n\");\n     }\n \n-  /* End the function.  */\n-  fprintf (file, \"\\t.end \");\n-  assemble_name (file,  alpha_function_name);\n-  fprintf (file, \"\\n\");\n-  inside_function = FALSE;\n+  /* The ABIs for VMS and OSF/1 say that while we can schedule insns into\n+     the prologue, for exception handling reasons, we cannot do this for\n+     any insn that might fault.  We could prevent this for mems with a\n+     (clobber:BLK (scratch)), but this doesn't work for fp insns.  So we\n+     have to prevent all such scheduling with a blockage.\n \n-  /* Show that we know this function if it is called again.  */\n-  SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n-}\n+     Linux, on the other hand, never bothered to implement OSF/1's \n+     exception handling, and so doesn't care about such things.  Anyone\n+     planning to use dwarf2 frame-unwind info can also omit the blockage.  */\n \n-int\n-vms_valid_decl_attribute_p (decl, attributes, identifier, args)\n-     tree decl;\n-     tree attributes;\n-     tree identifier;\n-     tree args;\n-{\n-  if (is_attribute_p (\"overlaid\", identifier))\n-    return (args == NULL_TREE);\n-  return 0;\n+  if (! TARGET_CAN_FAULT_IN_PROLOGUE)\n+    emit_insn (gen_blockage ());\n }\n \n-#else /* !OPEN_VMS */\n+/* Output the rest of the textual info surrounding the prologue.  */\n \n-static int\n-alpha_does_function_need_gp ()\n+void\n+output_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n {\n-  rtx insn;\n-\n-  /* We never need a GP for Windows/NT.  */\n-  if (TARGET_WINDOWS_NT)\n-    return 0;\n-\n-#ifdef TARGET_PROFILING_NEEDS_GP\n-  if (profile_flag)\n-    return 1;\n-#endif\n+  unsigned long imask = 0;\n+  unsigned long fmask = 0;\n+  /* Stack space needed for pushing registers clobbered by us.  */\n+  HOST_WIDE_INT sa_size;\n+  /* Complete stack size needed.  */\n+  HOST_WIDE_INT frame_size;\n+  /* Offset from base reg to register save area.  */\n+  HOST_WIDE_INT reg_offset;\n+  char *entry_label = (char *) alloca (strlen (alpha_function_name) + 6);\n+  int i;\n \n-  /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n-     Even if we are a static function, we still need to do this in case\n-     our address is taken and passed to something like qsort.  */\n+  sa_size = alpha_sa_size ();\n \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t&& GET_CODE (PATTERN (insn)) != USE\n-\t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n-      {\n-\tenum attr_type type = get_attr_type (insn);\n-\tif (type == TYPE_LDSYM || type == TYPE_JSR)\n-\t  return 1;\n-      }\n+  frame_size = get_frame_size ();\n+  if (TARGET_OPEN_VMS)\n+    frame_size = ALPHA_ROUND (sa_size \n+\t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n+\t\t\t      + frame_size\n+\t\t\t      + current_function_pretend_args_size);\n+  else\n+    frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n+\t\t  + sa_size\n+\t\t  + ALPHA_ROUND (frame_size\n+\t\t\t\t + current_function_pretend_args_size));\n \n-  return 0;\n-}\n+  if (TARGET_OPEN_VMS)\n+    reg_offset = 8;\n+  else\n+    reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n \n-void\n-output_prolog (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  HOST_WIDE_INT out_args_size\n-    = ALPHA_ROUND (current_function_outgoing_args_size);\n-  HOST_WIDE_INT sa_size = alpha_sa_size ();\n-  HOST_WIDE_INT frame_size\n-    = (out_args_size + sa_size\n-       + ALPHA_ROUND (size + current_function_pretend_args_size));\n-  HOST_WIDE_INT reg_offset = out_args_size;\n-  HOST_WIDE_INT start_reg_offset = reg_offset;\n-  HOST_WIDE_INT actual_start_reg_offset = start_reg_offset;\n-  int int_reg_save_area_size = 0;\n-  unsigned reg_mask = 0;\n-  int i, sa_reg;\n+  alpha_sa_mask (&imask, &fmask);\n \n   /* Ecoff can handle multiple .file directives, so put out file and lineno.\n      We have to do that before the .ent directive as we cannot switch\n@@ -3529,314 +3384,341 @@ output_prolog (file, size)\n \t\t\t\tDECL_SOURCE_LINE (current_function_decl));\n     }\n \n-  /* The assembly language programmer's guide states that the second argument\n-     to the .ent directive, the lex_level, is ignored by the assembler,\n-     so we might as well omit it.  */\n-     \n-  if (!flag_inhibit_size_directive)\n+  /* Issue function start and label.  */\n+  if (TARGET_OPEN_VMS || !flag_inhibit_size_directive)\n     {\n-      fprintf (file, \"\\t.ent \");\n+      fputs (\"\\t.ent \", file);\n       assemble_name (file, alpha_function_name);\n-      fprintf (file, \"\\n\");\n+      putc ('\\n', file);\n     }\n-  ASM_OUTPUT_LABEL (file, alpha_function_name);\n-  inside_function = TRUE;\n \n-  if (TARGET_IEEE_CONFORMANT && !flag_inhibit_size_directive)\n-    /* Set flags in procedure descriptor to request IEEE-conformant\n-       math-library routines.  The value we set it to is PDSC_EXC_IEEE\n-       (/usr/include/pdsc.h). */\n-    fprintf (file, \"\\t.eflag 48\\n\");\n-\n-  /* Set up offsets to alpha virtual arg/local debugging pointer.  */\n-\n-  alpha_auto_offset = -frame_size + current_function_pretend_args_size;\n-  alpha_arg_offset = -frame_size + 48;\n+  strcpy (entry_label, alpha_function_name);\n+  if (TARGET_OPEN_VMS)\n+    strcat (entry_label, \"..en\");\n+  ASM_OUTPUT_LABEL (file, entry_label);\n+  inside_function = TRUE;\n \n-  alpha_function_needs_gp = alpha_does_function_need_gp ();\n+  if (TARGET_OPEN_VMS)\n+    fprintf (file, \"\\t.base $%d\\n\", vms_base_regno);\n \n-  if (TARGET_WINDOWS_NT == 0)\n+  if (!TARGET_OPEN_VMS && TARGET_IEEE_CONFORMANT\n+      && !flag_inhibit_size_directive)\n     {\n-      if (alpha_function_needs_gp)\n-\tfprintf (file, \"\\tldgp $29,0($27)\\n\");\n-\n-      /* Put a label after the GP load so we can enter the function at it.  */\n-      fputc ('$', file);\n-      assemble_name (file, alpha_function_name);\n-      fprintf (file, \"..ng:\\n\");\n+      /* Set flags in procedure descriptor to request IEEE-conformant\n+\t math-library routines.  The value we set it to is PDSC_EXC_IEEE\n+\t (/usr/include/pdsc.h). */\n+      fputs (\"\\t.eflag 48\\n\", file);\n     }\n \n-  /* Adjust the stack by the frame size.  If the frame size is > 4096\n-     bytes, we need to be sure we probe somewhere in the first and last\n-     4096 bytes (we can probably get away without the latter test) and\n-     every 8192 bytes in between.  If the frame size is > 32768, we\n-     do this in a loop.  Otherwise, we generate the explicit probe\n-     instructions. \n-\n-     Note that we are only allowed to adjust sp once in the prologue.  */\n-\n-  if (frame_size < 32768)\n-    {\n-      if (frame_size > 4096)\n-\t{\n-\t  int probed = 4096;\n-\n-\t  fprintf (file, \"\\tstq $31,-%d($30)\\n\", probed);\n-\n-\t  while (probed + 8192 < frame_size)\n-\t    fprintf (file, \"\\tstq $31,-%d($30)\\n\", probed += 8192);\n-\n-\t  /* We only have to do this probe if we aren't saving registers.  */\n-\t  if (sa_size == 0 && probed + 4096 < frame_size)\n-\t    fprintf (file, \"\\tstq $31,-%d($30)\\n\", frame_size);\n-\t}\n+  /* Set up offsets to alpha virtual arg/local debugging pointer.  */\n+  alpha_auto_offset = -frame_size + current_function_pretend_args_size;\n+  alpha_arg_offset = -frame_size + 48;\n \n-      if (frame_size != 0)\n-\tfprintf (file, \"\\tlda $30,-%d($30)\\n\", frame_size);\n-    }\n-  else\n+  /* Describe our frame.  If the frame size is larger than an integer,\n+     print it as zero to avoid an assembler error.  We won't be\n+     properly describing such a frame, but that's the best we can do.  */\n+  if (TARGET_OPEN_VMS)\n     {\n-      /* Here we generate code to set R4 to SP + 4096 and set R5 to the\n-\t number of 8192 byte blocks to probe.  We then probe each block\n-\t in the loop and then set SP to the proper location.  If the\n-\t amount remaining is > 4096, we have to do one more probe if we\n-\t are not saving any registers.  */\n-\n-      HOST_WIDE_INT blocks = (frame_size + 4096) / 8192;\n-      HOST_WIDE_INT leftover = frame_size + 4096 - blocks * 8192;\n-\n-      add_long_const (file, blocks, 31, 5, 5);\n-\n-      fprintf (file, \"\\tlda $4,4096($30)\\n\");\n-\n-      fputc ('$', file);\n-      assemble_name (file, alpha_function_name);\n-      fprintf (file, \"..sc:\\n\");\n-\n-      fprintf (file, \"\\tstq $31,-8192($4)\\n\");\n-      fprintf (file, \"\\tsubq $5,1,$5\\n\");\n-      fprintf (file, \"\\tlda $4,-8192($4)\\n\");\n-\n-      fprintf (file, \"\\tbne $5,$\");\n-      assemble_name (file, alpha_function_name);\n-      fprintf (file, \"..sc\\n\");\n-\n-      if (leftover > 4096 && sa_size == 0)\n-\tfprintf (file, \"\\tstq $31,-%d($4)\\n\", leftover);\n-\n-      fprintf (file, \"\\tlda $30,-%d($4)\\n\", leftover);\n+      fprintf (file, \"\\t.frame $%d,\", vms_unwind_regno);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\t       frame_size >= (1l << 31) ? 0 : frame_size);\n+      fprintf (file, \",$26,%d\\n\", reg_offset);\n     }\n-\n-  /* Describe our frame.  */\n-  if (!flag_inhibit_size_directive)\n+  else if (!flag_inhibit_size_directive)\n     {\n       fprintf (file, \"\\t.frame $%d,\",\n \t       (frame_pointer_needed\n-\t        ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM));\n-\n-      /* If the frame size is larger than an integer, print it as zero to\n-\t avoid an assembler error.  We won't be properly describing such a\n-\t frame, but that's the best we can do.  */\n+\t\t? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM));\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-#if HOST_BITS_PER_WIDE_INT == 64\n-\t       frame_size >= (1l << 31) ? 0 :\n-#endif\n-\t       frame_size\n-\t       );\n+\t       frame_size >= (1l << 31) ? 0 : frame_size);\n       fprintf (file, \",$26,%d\\n\", current_function_pretend_args_size);\n     }\n \n-  /* Cope with very large offsets to the register save area.  */\n-  sa_reg = 30;\n-  if (reg_offset + sa_size > 0x8000)\n+  /* Describe which registers were spilled.  */\n+  if (TARGET_OPEN_VMS)\n     {\n-      int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n-      if (low + sa_size <= 0x8000)\n+      if (imask)\n+        /* ??? Does VMS care if mask contains ra?  The old code did'nt\n+           set it, so I don't here.  */\n+\tfprintf (file, \"\\t.mask 0x%x,0\\n\", imask & ~(1L << REG_RA));\n+      if (fmask)\n+\tfprintf (file, \"\\t.fmask 0x%x,0\\n\", fmask);\n+      if (!vms_is_stack_procedure)\n+\tfprintf (file, \"\\t.fp_save $%d\\n\", vms_save_fp_regno);\n+    }\n+  else if (!flag_inhibit_size_directive)\n+    {\n+      if (imask)\n \t{\n-\t  add_long_const (file, reg_offset - low, 30, 24, 24);\n-\t  reg_offset = low;\n+\t  fprintf (file, \"\\t.mask 0x%x,\", imask);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\t\t   frame_size >= (1l << 31) ? 0 : reg_offset - frame_size);\n+\t  putc ('\\n', file);\n+\n+\t  for (i = 0; i < 32; ++i)\n+\t    if (imask & (1L << i))\n+\t      reg_offset += 8;\n \t}\n-      else\n+\n+      if (fmask)\n \t{\n-          add_long_const (file, reg_offset, 30, 24, 24);\n-          reg_offset = 0;\n+\t  fprintf (file, \"\\t.fmask 0x%x,\", fmask);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\t\t   frame_size >= (1l << 31) ? 0 : reg_offset - frame_size);\n+\t  putc ('\\n', file);\n \t}\n-      sa_reg = 24;\n-    }\n-    \n-  /* Save register RA if any other register needs to be saved.  */\n-  if (sa_size != 0)\n-    {\n-      reg_mask |= 1 << REG_RA;\n-      fprintf (file, \"\\tstq $26,%d($%d)\\n\", reg_offset, sa_reg);\n-      reg_offset += 8;\n-      int_reg_save_area_size += 8;\n     }\n \n-  /* Now save any other used integer registers required to be saved.  */\n-  for (i = 0; i < 32; i++)\n-    if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& regs_ever_live[i] && i != REG_RA)\n-      {\n-\treg_mask |= 1 << i;\n-\tfprintf (file, \"\\tstq $%d,%d($%d)\\n\", i, reg_offset, sa_reg);\n-\treg_offset += 8;\n-\tint_reg_save_area_size += 8;\n-      }\n-\n-  /* Print the register mask and do floating-point saves.  */\n-  if (reg_mask && !flag_inhibit_size_directive)\n+  /* Emit GP related things.  It is rather unfortunate about the alignment\n+     issues surrounding a CODE_LABEL that forces us to do the label in \n+     plain text.  */\n+  if (!TARGET_OPEN_VMS && !TARGET_WINDOWS_NT)\n     {\n-      fprintf (file, \"\\t.mask 0x%x,\", reg_mask);\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n-#if HOST_BITS_PER_WIDE_INT == 64\n-\t       frame_size >= (1l << 31) ? 0 :\n-#endif\n-\t       actual_start_reg_offset - frame_size);\n-      fprintf (file, \"\\n\");\n-    }\n+      rtx lab;\n+      char *name;\n \n-  start_reg_offset = reg_offset;\n-  reg_mask = 0;\n+      alpha_function_needs_gp = alpha_does_function_need_gp ();\n+      if (alpha_function_needs_gp)\n+\tfputs (\"\\tldgp $29,0($27)\\n\", file);\n \n-  for (i = 0; i < 32; i++)\n-    if (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n-\t&& regs_ever_live[i + 32])\n-      {\n-\treg_mask |= 1 << i;\n-\tfprintf (file, \"\\tstt $f%d,%d($%d)\\n\", i, reg_offset, sa_reg);\n-\treg_offset += 8;\n-      }\n+      putc ('$', file);\n+      assemble_name (file, alpha_function_name);\n+      fputs (\"..ng:\\n\", file);\n+    }\n \n-  /* Print the floating-point mask, if we've saved any fp register.  */\n-  if (reg_mask && !flag_inhibit_size_directive)\n-    fprintf (file, \"\\t.fmask 0x%x,%d\\n\", reg_mask,\n-\t     actual_start_reg_offset - frame_size + int_reg_save_area_size);\n+#ifdef OPEN_VMS\n+  /* Ifdef'ed cause readonly_section and link_section are only\n+     available then.  */\n+  readonly_section ();\n+  fprintf (file, \"\\t.align 3\\n\");\n+  assemble_name (file, alpha_function_name); fputs (\"..na:\\n\", file);\n+  fputs (\"\\t.ascii \\\"\", file);\n+  assemble_name (file, alpha_function_name);\n+  fputs (\"\\\\0\\\"\\n\", file);\n+      \n+  link_section ();\n+  fprintf (file, \"\\t.align 3\\n\");\n+  fputs (\"\\t.name \", file);\n+  assemble_name (file, alpha_function_name);\n+  fputs (\"..na\\n\", file);\n+  ASM_OUTPUT_LABEL (file, alpha_function_name);\n+  fprintf (file, \"\\t.pdesc \");\n+  assemble_name (file, alpha_function_name);\n+  fprintf (file, \"..en,%s\\n\", vms_is_stack_procedure ? \"stack\" : \"reg\");\n+  alpha_need_linkage (alpha_function_name, 1);\n+  text_section ();\n+#endif\n+}\n \n-  /* If we need a frame pointer, set it from the stack pointer.  Note that\n-     this must always be the last instruction in the prologue.  */\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\tbis $30,$30,$15\\n\");\n+/* Emit the .prologue note at the scheduled end of the prologue.  */\n \n-  /* End the prologue and say if we used gp.  */\n-  if (!flag_inhibit_size_directive)\n+void\n+output_end_prologue (file)\n+     FILE *file;\n+{\n+  if (TARGET_OPEN_VMS)\n+    fputs (\"\\t.prologue\\n\", file);\n+  else if (TARGET_WINDOWS_NT)\n+    fputs (\"\\t.prologue 0\\n\", file);\n+  else if (!flag_inhibit_size_directive)\n     fprintf (file, \"\\t.prologue %d\\n\", alpha_function_needs_gp);\n }\n \n /* Write function epilogue.  */\n \n void\n-output_epilog (file, size)\n-     FILE *file;\n-     int size;\n+alpha_expand_epilogue ()\n {\n-  rtx insn = get_last_insn ();\n-  HOST_WIDE_INT out_args_size\n-    = ALPHA_ROUND (current_function_outgoing_args_size);\n-  HOST_WIDE_INT sa_size = alpha_sa_size ();\n-  HOST_WIDE_INT frame_size\n-    = (out_args_size + sa_size\n-       + ALPHA_ROUND (size + current_function_pretend_args_size));\n-  HOST_WIDE_INT reg_offset = out_args_size;\n-  int restore_fp\n-    = frame_pointer_needed && regs_ever_live[HARD_FRAME_POINTER_REGNUM];\n+  /* Registers to save.  */\n+  unsigned long imask = 0;\n+  unsigned long fmask = 0;\n+  /* Stack space needed for pushing registers clobbered by us.  */\n+  HOST_WIDE_INT sa_size;\n+  /* Complete stack size needed.  */\n+  HOST_WIDE_INT frame_size;\n+  /* Offset from base reg to register save area.  */\n+  HOST_WIDE_INT reg_offset;\n+  int fp_is_frame_pointer, fp_offset;\n+  rtx sa_reg, sa_reg_exp = NULL;\n+  rtx sp_adj1, sp_adj2;\n   int i;\n \n-  /* If the last insn was a BARRIER, we don't have to write anything except\n-     the .end pseudo-op.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn == 0 || GET_CODE (insn) != BARRIER)\n-    {\n-      int fp_offset = 0;\n-      int sa_reg;\n+  sa_size = alpha_sa_size ();\n \n-      /* If we have a frame pointer, restore SP from it.  */\n-      if (frame_pointer_needed)\n-\tfprintf (file, \"\\tbis $15,$15,$30\\n\");\n+  frame_size = get_frame_size ();\n+  if (TARGET_OPEN_VMS)\n+    frame_size = ALPHA_ROUND (sa_size \n+\t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n+\t\t\t      + frame_size\n+\t\t\t      + current_function_pretend_args_size);\n+  else\n+    frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n+\t\t  + sa_size\n+\t\t  + ALPHA_ROUND (frame_size\n+\t\t\t\t + current_function_pretend_args_size));\n \n-      /* Cope with large offsets to the register save area.  */\n-      sa_reg = 30;\n-      if (reg_offset + sa_size > 0x8000)\n+  if (TARGET_OPEN_VMS)\n+    reg_offset = 8;\n+  else\n+    reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n+\n+  alpha_sa_mask (&imask, &fmask);\n+\n+  fp_is_frame_pointer = ((TARGET_OPEN_VMS && vms_is_stack_procedure)\n+\t\t\t || (!TARGET_OPEN_VMS && frame_pointer_needed));\n+\n+  if (sa_size)\n+    {\n+      /* If we have a frame pointer, restore SP from it.  */\n+      if ((TARGET_OPEN_VMS\n+\t   && vms_unwind_regno == HARD_FRAME_POINTER_REGNUM)\n+\t  || (!TARGET_OPEN_VMS && frame_pointer_needed))\n \t{\n-          int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n-          if (low + sa_size <= 0x8000)\n-\t    {\n-\t      add_long_const (file, reg_offset - low, 30, 24, 24);\n-\t      reg_offset = low;\n-\t    }\n-          else\n-\t    {\n-              add_long_const (file, reg_offset, 30, 24, 24);\n-              reg_offset = 0;\n-\t    }\n-\t  sa_reg = 24;\n+\t  emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n \t}\n \n-      /* Restore all the registers, starting with the return address\n-\t register.  */\n-      if (sa_size != 0)\n+      /* Cope with very large offsets to the register save area.  */\n+      sa_reg = stack_pointer_rtx;\n+      if (reg_offset + sa_size > 0x8000)\n \t{\n-\t  fprintf (file, \"\\tldq $26,%d($%d)\\n\", reg_offset, sa_reg);\n-\t  reg_offset += 8;\n+\t  int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n+\t  HOST_WIDE_INT bias;\n+\n+\t  if (low + sa_size <= 0x8000)\n+\t    bias = reg_offset - low, reg_offset = low;\n+\t  else \n+\t    bias = reg_offset, reg_offset = 0;\n+\n+\t  sa_reg = gen_rtx_REG (DImode, 22);\n+\t  sa_reg_exp = plus_constant (stack_pointer_rtx, bias);\n+\n+\t  emit_move_insn (sa_reg, sa_reg_exp);\n \t}\n+\t  \n+      /* Restore registers in order, excepting a true frame pointer. */\n \n-      /* Now restore any other used integer registers that we saved,\n-\t except for FP if it is being used as FP, since it must be\n-\t restored last.  */\n+      emit_move_insn (gen_rtx_REG (DImode, REG_RA),\n+\t\t      gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset)));\n+      reg_offset += 8;\n+      imask &= ~(1L << REG_RA);\n \n-      for (i = 0; i < 32; i++)\n-\tif (! fixed_regs[i] && ! call_used_regs[i] && regs_ever_live[i]\n-\t    && i != 26)\n+      for (i = 0; i < 32; ++i)\n+\tif (imask & (1L << i))\n \t  {\n-\t    if (i == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+\t    if (i == HARD_FRAME_POINTER_REGNUM && fp_is_frame_pointer)\n \t      fp_offset = reg_offset;\n \t    else\n-\t      fprintf (file, \"\\tldq $%d,%d($%d)\\n\", i, reg_offset, sa_reg);\n+\t      {\n+\t\temit_move_insn (gen_rtx_REG (DImode, i),\n+\t\t\t\tgen_rtx_MEM (DImode,\n+\t\t\t\t\t     plus_constant(sa_reg,\n+\t\t\t\t\t\t           reg_offset)));\n+\t      }\n \t    reg_offset += 8;\n \t  }\n \n-      for (i = 0; i < 32; i++)\n-\tif (! fixed_regs[i + 32] && ! call_used_regs[i + 32]\n-\t    && regs_ever_live[i + 32])\n+      for (i = 0; i < 32; ++i)\n+\tif (fmask & (1L << i))\n \t  {\n-\t    fprintf (file, \"\\tldt $f%d,%d($%d)\\n\", i, reg_offset, sa_reg);\n+\t    emit_move_insn (gen_rtx_REG (DFmode, i+32),\n+\t\t\t    gen_rtx_MEM (DFmode,\n+\t\t\t\t\t plus_constant(sa_reg, reg_offset)));\n \t    reg_offset += 8;\n \t  }\n+    }\n \n-      /* If the stack size is large and we have a frame pointer, compute the\n-\t size of the stack into a register because the old FP restore, stack\n-\t pointer adjust, and return are required to be consecutive\n-\t instructions.   */\n-      if (frame_size > 32767 && restore_fp)\n-\tadd_long_const (file, frame_size, 31, 1, 1);\n-\n-      /* If we needed a frame pointer and we have to restore it, do it\n-\t now.  This must be done in one instruction immediately\n-\t before the SP update.  */\n-      if (restore_fp && fp_offset)\n-\tfprintf (file, \"\\tldq $15,%d($%d)\\n\", fp_offset, sa_reg);\n-\n-      /* Now update the stack pointer, if needed.  Only one instruction must\n-\t modify the stack pointer.  It must be the last instruction in the\n-\t sequence and must be an ADDQ or LDA instruction.  If the frame\n-\t pointer was loaded above, we may only put one instruction here.  */\n-\n-      if (frame_size > 32768 && restore_fp)\n-\tfprintf  (file, \"\\taddq $1,$30,$30\\n\");\n+  if (frame_size)\n+    {\n+      /* If the stack size is large, begin computation into a temporary\n+\t register so as not to interfere with a potential fp restore,\n+\t which must be consecutive with an SP restore.  */\n+      if (frame_size < 32768)\n+\t{\n+\t  sp_adj1 = stack_pointer_rtx;\n+\t  sp_adj2 = GEN_INT (frame_size);\n+\t}\n+      else if (frame_size < 0x40007fffL)\n+\t{\n+\t  int low = ((frame_size & 0xffff) ^ 0x8000) - 0x8000;\n+\n+\t  sp_adj2 = plus_constant (stack_pointer_rtx, frame_size - low);\n+\t  if (sa_reg_exp && rtx_equal_p (sa_reg_exp, sp_adj2))\n+\t    sp_adj1 = sa_reg;\n+\t  else\n+\t    {\n+\t      sp_adj1 = gen_rtx_REG (DImode, 23);\n+\t      emit_move_insn (sp_adj1, sp_adj2);\n+\t    }\n+\t  sp_adj2 = GEN_INT (low);\n+\t}\n       else\n-\tadd_long_const (file, frame_size, 30, 30, 1);\n+\t{\n+\t  sp_adj2 = gen_rtx_REG (DImode, 23);\n+\t  sp_adj1 = alpha_emit_set_const (sp_adj2, DImode, frame_size, 3);\n+\t  if (!sp_adj1)\n+\t    {\n+\t      /* We can't drop new things to memory this late, afaik,\n+\t\t so build it up by pieces.  */\n+#if HOST_BITS_PER_WIDE_INT == 64\n+\t      sp_adj1 = alpha_emit_set_long_const (sp_adj2, frame_size);\n+\t      if (!sp_adj1)\n+\t\tabort ();\n+#else\n+\t      abort ();\n+#endif\n+\t    }\n+\t  sp_adj2 = stack_pointer_rtx;\n+\t}\n \n-      /* Finally return to the caller.  */\n-      fprintf (file, \"\\tret $31,($26),1\\n\");\n+      /* From now on, things must be in order.  So emit blockages.  */\n+\n+      /* Restore the frame pointer.  */\n+      if (fp_is_frame_pointer)\n+\t{\n+\t  emit_insn (gen_blockage ());\n+\t  emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t  gen_rtx_MEM (DImode,\n+\t\t\t\t       plus_constant(sa_reg, fp_offset)));\n+\t}\n+      else if (TARGET_OPEN_VMS)\n+\t{\n+\t  emit_insn (gen_blockage ());\n+\t  emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t  gen_rtx_REG (DImode, vms_save_fp_regno));\n+\t}\n+\n+      /* Restore the stack pointer.  */\n+      emit_insn (gen_blockage ());\n+      emit_move_insn (stack_pointer_rtx,\n+\t\t      gen_rtx_PLUS (DImode, sp_adj1, sp_adj2));\n+    }\n+  else \n+    {\n+      if (TARGET_OPEN_VMS && !vms_is_stack_procedure)\n+        {\n+          emit_insn (gen_blockage ());\n+          emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t  gen_rtx_REG (DImode, vms_save_fp_regno));\n+        }\n     }\n \n+  /* Return.  */\n+  emit_jump_insn (gen_return_internal ());\n+}\n+\n+/* Output the rest of the textual info surrounding the epilogue.  */\n+\n+void\n+output_epilogue (file, size)\n+     FILE *file;\n+     int size;\n+{\n   /* End the function.  */\n   if (!flag_inhibit_size_directive)\n     {\n-      fprintf (file, \"\\t.end \");\n+      fputs (\"\\t.end \", file);\n       assemble_name (file, alpha_function_name);\n-      fprintf (file, \"\\n\");\n+      putc ('\\n', file);\n     }\n   inside_function = FALSE;\n \n@@ -3850,7 +3732,6 @@ output_epilog (file, size)\n   if (!flag_pic || !TREE_PUBLIC (current_function_decl))\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n }\n-#endif /* !OPEN_VMS */\n \f\n /* Debugging support.  */\n \n@@ -3954,6 +3835,9 @@ struct shadow_summary\n   } used, defd;\n };\n \n+static void summarize_insn PROTO((rtx, struct shadow_summary *, int));\n+static void alpha_handle_trap_shadows PROTO((rtx));\n+\n /* Summary the effects of expression X on the machine.  Update SUM, a pointer\n    to the summary structure.  SET is nonzero if the insn is setting the\n    object, otherwise zero.  */\n@@ -3998,8 +3882,8 @@ summarize_insn (x, sum, set)\n       break;\n \n     case SUBREG:\n-      x = SUBREG_REG (x);\n-      /* FALLTHRU */\n+      summarize_insn (SUBREG_REG (x), sum, 0);\n+      break;\n \n     case REG:\n       {\n@@ -4081,32 +3965,36 @@ summarize_insn (x, sum, set)\n     }\n }\n \n-/* Ensure a sufficient number of `trapb' insns are in the code when the user\n-   requests code with a trap precision of functions or instructions.\n-\n-   In naive mode, when the user requests a trap-precision of \"instruction\", a\n-   trapb is needed after every instruction that may generate a trap (and after\n-   jsr/bsr instructions, because called functions may import a trap from the\n-   caller).  This ensures that the code is resumption safe but it is also slow.\n-\n-   When optimizations are turned on, we delay issuing a trapb as long as\n-   possible.  In this context, a trap shadow is the sequence of instructions\n-   that starts with a (potentially) trap generating instruction and extends to\n-   the next trapb or call_pal instruction (but GCC never generates call_pal by\n-   itself).  We can delay (and therefore sometimes omit) a trapb subject to the\n-   following conditions:\n-\n-   (a) On entry to the trap shadow, if any Alpha register or memory location\n-   contains a value that is used as an operand value by some instruction in\n-   the trap shadow (live on entry), then no instruction in the trap shadow\n-   may modify the register or memory location.\n-\n-   (b) Within the trap shadow, the computation of the base register for a\n-   memory load or store instruction may not involve using the result\n-   of an instruction that might generate an UNPREDICTABLE result.\n-\n-   (c) Within the trap shadow, no register may be used more than once as a\n-   destination register.  (This is to make life easier for the trap-handler.)\n+/* Ensure a sufficient number of `trapb' insns are in the code when\n+   the user requests code with a trap precision of functions or\n+   instructions.\n+\n+   In naive mode, when the user requests a trap-precision of\n+   \"instruction\", a trapb is needed after every instruction that may\n+   generate a trap.  This ensures that the code is resumption safe but\n+   it is also slow.\n+\n+   When optimizations are turned on, we delay issuing a trapb as long\n+   as possible.  In this context, a trap shadow is the sequence of\n+   instructions that starts with a (potentially) trap generating\n+   instruction and extends to the next trapb or call_pal instruction\n+   (but GCC never generates call_pal by itself).  We can delay (and\n+   therefore sometimes omit) a trapb subject to the following\n+   conditions:\n+\n+   (a) On entry to the trap shadow, if any Alpha register or memory\n+   location contains a value that is used as an operand value by some\n+   instruction in the trap shadow (live on entry), then no instruction\n+   in the trap shadow may modify the register or memory location.\n+\n+   (b) Within the trap shadow, the computation of the base register\n+   for a memory load or store instruction may not involve using the\n+   result of an instruction that might generate an UNPREDICTABLE\n+   result.\n+\n+   (c) Within the trap shadow, no register may be used more than once\n+   as a destination register.  (This is to make life easier for the\n+   trap-handler.)\n \n    (d) The trap shadow may not include any branch instructions.  */\n \n@@ -4257,7 +4145,7 @@ alpha_reorg (insns)\n \f\n /* Check a floating-point value for validity for a particular machine mode.  */\n \n-static char *float_strings[] =\n+static char * const float_strings[] =\n {\n   /* These are for FLOAT_VAX.  */\n    \"1.70141173319264430e+38\", /* 2^127 (2^24 - 1) / 2^24 */\n@@ -4475,4 +4363,3 @@ alpha_need_linkage (name, is_local)\n }\n \n #endif /* OPEN_VMS */\n-"}, {"sha": "f81efdfec7bb5f6cbc49d86b6b9be40f3da99529", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=9c0e94a5e42ef58857e03e60756e3f165e4be620", "patch": "@@ -171,7 +171,9 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #ifndef TARGET_AS_CAN_SUBTRACT_LABELS\n #define TARGET_AS_CAN_SUBTRACT_LABELS TARGET_GAS\n #endif\n-\n+#ifndef TARGET_CAN_FAULT_IN_PROLOGUE\n+#define TARGET_CAN_FAULT_IN_PROLOGUE 0\n+#endif\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -371,7 +373,7 @@ extern void override_options ();\n #define STACK_BOUNDARY 64\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 64\n+#define FUNCTION_BOUNDARY 256\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 64\n@@ -387,20 +389,16 @@ extern void override_options ();\n    ??? Kludge this and the next macro for the moment by not doing anything if\n    we don't optimize and also if we are writing ECOFF symbols to work around\n    a bug in DEC's assembler. */\n-/* Aligning past 2**3 wastes insn cache lines, and doesn't buy much \n-   issue-wise on average anyway.  */\n \n #define LOOP_ALIGN(LABEL) \\\n-  (optimize > 0 && write_symbols != SDB_DEBUG ? 3 : 0)\n+  (optimize > 0 && write_symbols != SDB_DEBUG ? 4 : 0)\n \n-/* This is how to align an instruction for optimal branching.\n-   On Alpha we'll get better performance by aligning on a quadword\n+/* This is how to align an instruction for optimal branching.  On\n+   Alpha we'll get better performance by aligning on an octaword\n    boundary.  */\n-/* Aligning past 2**3 wastes insn cache lines, and doesn't buy much \n-   issue-wise on average anyway.  */\n \n #define ALIGN_LABEL_AFTER_BARRIER(FILE)\t\\\n-  (optimize > 0 && write_symbols != SDB_DEBUG ? 3 : 0)\n+  (optimize > 0 && write_symbols != SDB_DEBUG ? 4 : 0)\n \n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64\n@@ -1118,7 +1116,11 @@ extern char *alpha_function_name;\n    is ever used in the function.  This macro is responsible for\n    knowing which registers should not be saved even if used.  */\n \n-#define FUNCTION_PROLOGUE(FILE, SIZE)  output_prolog (FILE, SIZE)\n+#define FUNCTION_PROLOGUE(FILE, SIZE)  output_prologue (FILE, SIZE)\n+\n+/* This macro notes the end of the prologue.  */\n+\n+#define FUNCTION_END_PROLOGUE(FILE)  output_end_prologue (FILE)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  Under OSF/1, profiling is enabled\n@@ -1179,7 +1181,7 @@ extern char *alpha_function_name;\n    of alloca; we also take advantage of it to omit stack adjustments\n    before returning.  */\n \n-#define FUNCTION_EPILOGUE(FILE, SIZE)\toutput_epilog (FILE, SIZE)\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\toutput_epilogue (FILE, SIZE)\n \n \f\n /* Output assembler code for a block containing the constant parts\n@@ -1253,7 +1255,6 @@ extern char *alpha_function_name;\n /* Attempt to turn on access permissions for the stack.  */\n \n #define TRANSFER_FROM_TRAMPOLINE\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n __enable_execute_stack (addr)\t\t\t\t\t\t\\\n      void *addr;\t\t\t\t\t\t\t\\"}, {"sha": "65eacf7a6cd0d6a2eb86678b8073397c6ddea930", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 119, "deletions": 35, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=9c0e94a5e42ef58857e03e60756e3f165e4be620", "patch": "@@ -37,7 +37,7 @@\n ;;\t2\tbuiltin_setjmp_receiver\n ;;\t3\tbuiltin_longjmp\n ;;\t4\ttrapb\n-\n+;;\t5\tprologue_stack_probe_loop\n \f\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n@@ -54,13 +54,20 @@\n   \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof\"\n   (const_string \"iadd\"))\n \n+;; Define the operand size an insn operates on.  Used primarily by mul\n+;; and div operations that have size dependant timings.\n+\n (define_attr \"opsize\" \"si,di,udi\" (const_string \"di\"))\n \n ;; The TRAP_TYPE attribute marks instructions that may generate traps\n ;; (which are imprecise and may need a trapb if software completion\n ;; is desired).\n+\n (define_attr \"trap\" \"no,yes\" (const_string \"no\"))\n \n+;; The length of an instruction sequence in bytes.\n+\n+(define_attr \"length\" \"\" (const_int 4))\n \f\n ;; On EV4 there are two classes of resources to consider: resources needed\n ;; to issue, and resources needed to execute.  IBUS[01] are in the first\n@@ -385,7 +392,8 @@\n    addl %1,$31,%0\n    ldl %0,%1\n    lds %0,%1\\;cvtlq %0,%0\"\n-  [(set_attr \"type\" \"iadd,ild,fld\")])\n+  [(set_attr \"type\" \"iadd,ild,fld\")\n+   (set_attr \"length\" \"*,*,8\")])\n \n ;; Due to issues with CLASS_CANNOT_CHANGE_SIZE, we cannot use a subreg here.\n (define_split\n@@ -917,6 +925,8 @@\n   \"!TARGET_OPEN_VMS\"\n   \"\")\n \n+;; Lengths of 8 for ldq $t12,__divq($gp); jsr $t9,($t12),__divq as\n+;; expanded by the assembler.\n (define_insn \"\"\n   [(set (reg:DI 27)\n \t(sign_extend:DI (match_operator:SI 1 \"divmod_operator\"\n@@ -925,7 +935,8 @@\n    (clobber (reg:DI 28))]\n   \"!TARGET_OPEN_VMS\"\n   \"%E1 $24,$25,$27\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (reg:DI 27)\n@@ -935,7 +946,8 @@\n    (clobber (reg:DI 28))]\n   \"!TARGET_OPEN_VMS\"\n   \"%E1 $24,$25,$27\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"8\")])\n \f\n ;; Next are the basic logical operations.  These only exist in DImode.\n \n@@ -2357,7 +2369,8 @@\n    (clobber (match_scratch:DI 4 \"=&r\"))]\n   \"\"\n   \"addq %0,%1,%4\\;cmov%C2 %r3,%4,%0\"\n-  [(set_attr \"type\" \"icmov\")])\n+  [(set_attr \"type\" \"icmov\")\n+   (set_attr \"length\" \"8\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3679,7 +3692,8 @@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,$%0..ng\n    jsr $26,%0\\;ldgp $29,0($26)\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,*,12\")])\n       \n (define_insn \"\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n@@ -3690,7 +3704,8 @@\n    jsr $26,(%0)\n    bsr $26,%0\n    jsr $26,%0\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"*,*,12\")])\n       \n (define_insn \"\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,i\"))\n@@ -3703,7 +3718,8 @@\n   \"@\n    bis %2,%2,$27\\;jsr $26,0\\;ldq $27,0($29)\n    ldq $27,%2\\;jsr $26,%0\\;ldq $27,0($29)\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,16\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=rf,rf,rf\")\n@@ -3716,7 +3732,8 @@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,$%1..ng\n    jsr $26,%1\\;ldgp $29,0($26)\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,*,12\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"=rf,rf,rf\")\n@@ -3728,7 +3745,8 @@\n    jsr $26,(%1)\n    bsr $26,%1\n    jsr $26,%1\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"*,*,12\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -3742,7 +3760,8 @@\n   \"@\n    bis %3,%3,$27\\;jsr $26,0\\;ldq $27,0($29)\n    ldq $27,%3\\;jsr $26,%1\\;ldq $27,0($29)\"\n-  [(set_attr \"type\" \"jsr\")])\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,16\")])\n \n ;; Call subroutine returning any type.\n \n@@ -3779,7 +3798,8 @@\n (define_insn \"blockage\"\n   [(unspec_volatile [(const_int 0)] 1)]\n   \"\"\n-  \"\")\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n \n (define_insn \"jump\"\n   [(set (pc)\n@@ -3794,6 +3814,15 @@\n   \"ret $31,($26),1\"\n   [(set_attr \"type\" \"ibr\")])\n \n+;; Use a different pattern for functions which have non-trivial\n+;; epilogues so as not to confuse jump and reorg.\n+(define_insn \"return_internal\"\n+  [(use (reg:DI 26))\n+   (return)]\n+  \"\"\n+  \"ret $31,($26),1\"\n+  [(set_attr \"type\" \"ibr\")])\n+\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:DI 0 \"register_operand\" \"r\"))]\n   \"\"\n@@ -3803,7 +3832,7 @@\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"bis $31,$31,$31\"\n+  \"nop\"\n   [(set_attr \"type\" \"ilog\")])\n \n (define_expand \"tablejump\"\n@@ -3900,7 +3929,8 @@\n   else\n     return \\\"addq %0,$29,%2\\;jmp $31,(%2),0\\\";\n }\"\n-  [(set_attr \"type\" \"ibr\")])\n+  [(set_attr \"type\" \"ibr\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -5058,6 +5088,57 @@\n     }\n }\")\n \n+;; This is used by alpha_expand_prolog to do the same thing as above,\n+;; except we cannot at that time generate new basic blocks, so we hide\n+;; the loop in this one insn.\n+\n+(define_insn \"prologue_stack_probe_loop\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")\n+\t\t     (match_operand 1 \"register_operand\" \"r\")] 5)]\n+  \"\"\n+  \"*\n+{\n+  static int label_no;\n+  int count_regno = REGNO (operands[0]);\n+  int ptr_regno = REGNO (operands[1]);\n+  char label[64];\n+\n+  /* Ho hum, output the hard way to get the label at the beginning of\n+     the line.  Wish there were a magic char you could get\n+     asm_output_printf to do that.  Then we could use %= as well and\n+     get rid of the label_no bits here too.  */\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, \\\"LSC\\\", label_no);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LSC\\\", label_no++);\n+\n+  fprintf (asm_out_file, \\\"\\\\tstq $31,-8192($%d)\\\\n\\\", ptr_regno);\n+  fprintf (asm_out_file, \\\"\\\\tsubq $%d,1,$%d\\\\n\\\", count_regno, count_regno);\n+  fprintf (asm_out_file, \\\"\\\\tlda $%d,-8192($%d)\\\\n\\\", ptr_regno, ptr_regno);\n+  fprintf (asm_out_file, \\\"\\\\tbne $%d,\\\", count_regno);\n+  assemble_name (asm_out_file, label);\n+  putc ('\\\\n', asm_out_file);\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_expand \"prologue\"\n+  [(clobber (const_int 0))]\n+  \"\"\n+  \"alpha_expand_prologue (); DONE;\")\n+\n+(define_insn \"init_fp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"r\")\n+        (match_operand:DI 1 \"register_operand\" \"r\"))\n+   (clobber (mem:BLK (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"bis %1,%1,%0\")\n+\n+(define_expand \"epilogue\"\n+  [(clobber (const_int 0))]\n+  \"\"\n+  \"alpha_expand_epilogue (); DONE;\")\n+\n (define_expand \"builtin_longjmp\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n@@ -5085,12 +5166,14 @@\n (define_insn \"builtin_setjmp_receiver\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT && TARGET_AS_CAN_SUBTRACT_LABELS\"\n-  \"\\\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\")\n+  \"\\\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n+  [(set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n-  \"br $27,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($27)\")\n+  \"br $27,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($27)\"\n+  [(set_attr \"length\" \"12\")])\n \n (define_expand \"nonlocal_goto_receiver\"\n   [(unspec_volatile [(const_int 0)] 1)\n@@ -5121,7 +5204,8 @@\n    (clobber (reg:DI 25))\n    (clobber (reg:DI 0))]\n   \"TARGET_OPEN_VMS\"\n-  \"lda $0,OTS$HOME_ARGS\\;ldq $0,8($0)\\;jsr $0,OTS$HOME_ARGS\")\n+  \"lda $0,OTS$HOME_ARGS\\;ldq $0,8($0)\\;jsr $0,OTS$HOME_ARGS\"\n+  [(set_attr \"length\" \"16\")])\n \n ;; Close the trap shadow of preceeding instructions.  This is generated\n ;; by alpha_reorg.\n@@ -5137,22 +5221,22 @@\n ;; Optimize sign-extension of SImode loads.  This shows up in the wake of\n ;; reload when converting fp->int.\n ;;\n-;; ??? What to do when we are actually caring about the packing and\n+;; ??? What to do now that we actually care about the packing and\n ;; alignment of instructions?  Perhaps reload can be enlightened, or\n-;; the peephole pass moved up after reload but before sched2.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (match_operand:SI 1 \"memory_operand\" \"m\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n-        (sign_extend:DI (match_dup 0)))]\n-  \"dead_or_set_p (insn, operands[0])\"\n-  \"ldl %2,%1\")\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (match_operand:SI 1 \"hard_fp_register_operand\" \"f\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n-        (sign_extend:DI (match_dup 0)))]\n-  \"TARGET_CIX && dead_or_set_p (insn, operands[0])\"\n-  \"ftois %1,%2\")\n+;; the peephole pass moved up after reload but before sched2?\n+;\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;        (match_operand:SI 1 \"memory_operand\" \"m\"))\n+;   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n+;        (sign_extend:DI (match_dup 0)))]\n+;  \"dead_or_set_p (insn, operands[0])\"\n+;  \"ldl %2,%1\")\n+;\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;        (match_operand:SI 1 \"hard_fp_register_operand\" \"f\"))\n+;   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n+;        (sign_extend:DI (match_dup 0)))]\n+;  \"TARGET_CIX && dead_or_set_p (insn, operands[0])\"\n+;  \"ftois %1,%2\")"}, {"sha": "47e06c62aa471ca9a246df7c56576fdace80fdb0", "filename": "gcc/config/alpha/linux.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c0e94a5e42ef58857e03e60756e3f165e4be620/gcc%2Fconfig%2Falpha%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flinux.h?ref=9c0e94a5e42ef58857e03e60756e3f165e4be620", "patch": "@@ -31,14 +31,18 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define LIB_SPEC \"%{pg:-lgmon} %{pg:-lc_p} %{!pg:-lc}\"\n \n /* Generate calls to memcpy, etc., not bcopy, etc. */\n-#define TARGET_MEM_FUNCTIONS\n+#define TARGET_MEM_FUNCTIONS 1\n \n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\\\n \tfputs (\"\\tlda $28,_mcount\\n\\tjsr $28,($28),_mcount\\n\", (FILE))\n \n /* Show that we need a GP when profiling.  */\n-#define TARGET_PROFILING_NEEDS_GP\n+#define TARGET_PROFILING_NEEDS_GP 1\n+\n+/* Don't care about faults in the prologue.  */\n+#undef TARGET_CAN_FAULT_IN_PROLOGUE\n+#define TARGET_CAN_FAULT_IN_PROLOGUE 1\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code."}]}