{"sha": "84d77ca61a12ab677c9b63d8cb78b07094f0cd93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkNzdjYTYxYTEyYWI2NzdjOWI2M2Q4Y2I3OGIwNzA5NGYwY2Q5Mw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-04T09:16:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-04T09:16:58Z"}, "message": "tree-ssa-ccp.c (get_constant_value): New function.\n\n2010-08-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-ccp.c (get_constant_value): New function.\n\t(get_rhs_assign_op_for_ccp): Remove.\n\t(valueize_op): New function.\n\t(ccp_fold): Use get_constant_value and valueize_op.\n\t(fold_const_aggregate_ref): Likewise.\n\t(ccp_fold_stmt): Likewise.\n\t(visit_assignment): Simplify.\n\nFrom-SVN: r162860", "tree": {"sha": "2bbf688db9561aecaabc1b3a46c560e355794f52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bbf688db9561aecaabc1b3a46c560e355794f52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84d77ca61a12ab677c9b63d8cb78b07094f0cd93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d77ca61a12ab677c9b63d8cb78b07094f0cd93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d77ca61a12ab677c9b63d8cb78b07094f0cd93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d77ca61a12ab677c9b63d8cb78b07094f0cd93/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "552cbe64b6e53a613e67e1aef1ecaed66bd71ed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/552cbe64b6e53a613e67e1aef1ecaed66bd71ed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/552cbe64b6e53a613e67e1aef1ecaed66bd71ed7"}], "stats": {"total": 182, "additions": 72, "deletions": 110}, "files": [{"sha": "39a29831a349a8b48cb9283cd896dd3c5025ee2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d77ca61a12ab677c9b63d8cb78b07094f0cd93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d77ca61a12ab677c9b63d8cb78b07094f0cd93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84d77ca61a12ab677c9b63d8cb78b07094f0cd93", "patch": "@@ -1,3 +1,13 @@\n+2010-08-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-ccp.c (get_constant_value): New function.\n+\t(get_rhs_assign_op_for_ccp): Remove.\n+\t(valueize_op): New function.\n+\t(ccp_fold): Use get_constant_value and valueize_op.\n+\t(fold_const_aggregate_ref): Likewise.\n+\t(ccp_fold_stmt): Likewise.\n+\t(visit_assignment): Simplify.\n+\n 2010-08-04  Richard Guenther  <rguenther@suse.de>\n \n \t* Makefile.in (double-int.o): Add $(TOPLEV_H) dependency."}, {"sha": "830a0e4072ba705f5faab9e30f531c76eebe842f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 62, "deletions": 110, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d77ca61a12ab677c9b63d8cb78b07094f0cd93/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d77ca61a12ab677c9b63d8cb78b07094f0cd93/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=84d77ca61a12ab677c9b63d8cb78b07094f0cd93", "patch": "@@ -281,6 +281,17 @@ get_value (tree var)\n   return val;\n }\n \n+/* Return the constant tree value associated with VAR.  */\n+\n+static inline tree\n+get_constant_value (tree var)\n+{\n+  prop_value_t *val = get_value (var);\n+  if (val && val->lattice_val == CONSTANT)\n+    return val->value;\n+  return NULL_TREE;\n+}\n+\n /* Sets the value associated with VAR to VARYING.  */\n \n static inline void\n@@ -782,19 +793,16 @@ ccp_visit_phi_node (gimple phi)\n     return SSA_PROP_NOT_INTERESTING;\n }\n \n-/* Get operand number OPNR from the rhs of STMT.  Before returning it,\n-   simplify it to a constant if possible.  */\n+/* Return the constant value for OP or OP otherwise.  */\n \n static tree\n-get_rhs_assign_op_for_ccp (gimple stmt, int opnr)\n+valueize_op (tree op)\n {\n-  tree op = gimple_op (stmt, opnr);\n-  \n   if (TREE_CODE (op) == SSA_NAME)\n     {\n-      prop_value_t *val = get_value (op);\n-      if (val->lattice_val == CONSTANT)\n-\top = get_value (op)->value;\n+      tree tem = get_constant_value (op);\n+      if (tem)\n+\treturn tem;\n     }\n   return op;\n }\n@@ -829,7 +837,7 @@ ccp_fold (gimple stmt)\n                 {\n                   /* If the RHS is an SSA_NAME, return its known constant value,\n                      if any.  */\n-                  return get_value (rhs)->value;\n+                  return get_constant_value (rhs);\n                 }\n \t      /* Handle propagating invariant addresses into address operations.\n \t\t The folding we do here matches that in tree-ssa-forwprop.c.  */\n@@ -842,14 +850,14 @@ ccp_fold (gimple stmt)\n \t\t  if (TREE_CODE (*base) == MEM_REF\n \t\t      && TREE_CODE (TREE_OPERAND (*base, 0)) == SSA_NAME)\n \t\t    {\n-\t\t      prop_value_t *val = get_value (TREE_OPERAND (*base, 0));\n-\t\t      if (val->lattice_val == CONSTANT\n-\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR)\n+\t\t      tree val = get_constant_value (TREE_OPERAND (*base, 0));\n+\t\t      if (val\n+\t\t\t  && TREE_CODE (val) == ADDR_EXPR)\n \t\t\t{\n \t\t\t  tree ret, save = *base;\n \t\t\t  tree new_base;\n \t\t\t  new_base = fold_build2 (MEM_REF, TREE_TYPE (*base),\n-\t\t\t\t\t\t  unshare_expr (val->value),\n+\t\t\t\t\t\t  unshare_expr (val),\n \t\t\t\t\t\t  TREE_OPERAND (*base, 1));\n \t\t\t  /* We need to return a new tree, not modify the IL\n \t\t\t     or share parts of it.  So play some tricks to\n@@ -873,9 +881,7 @@ ccp_fold (gimple stmt)\n \t\t  list = NULL_TREE;\n \t\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n \t\t    {\n-\t\t      if (TREE_CODE (val) == SSA_NAME\n-\t\t\t  && get_value (val)->lattice_val == CONSTANT)\n-\t\t\tval = get_value (val)->value;\n+\t\t      val = valueize_op (val);\n \t\t      if (TREE_CODE (val) == INTEGER_CST\n \t\t\t  || TREE_CODE (val) == REAL_CST\n \t\t\t  || TREE_CODE (val) == FIXED_CST)\n@@ -894,21 +900,21 @@ ccp_fold (gimple stmt)\n \t\t       || TREE_CODE (rhs) == IMAGPART_EXPR)\n \t\t      && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n \t\t    {\n-\t\t      prop_value_t *val = get_value (TREE_OPERAND (rhs, 0));\n-\t\t      if (val->lattice_val == CONSTANT)\n+\t\t      tree val = get_constant_value (TREE_OPERAND (rhs, 0));\n+\t\t      if (val)\n \t\t\treturn fold_unary_loc (EXPR_LOCATION (rhs),\n-\t\t\t\t\t   TREE_CODE (rhs),\n-\t\t\t\t\t   TREE_TYPE (rhs), val->value);\n+\t\t\t\t\t       TREE_CODE (rhs),\n+\t\t\t\t\t       TREE_TYPE (rhs), val);\n \t\t    }\n \t\t  else if (TREE_CODE (rhs) == MEM_REF\n \t\t\t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n \t\t    {\n-\t\t      prop_value_t *val = get_value (TREE_OPERAND (rhs, 0));\n-\t\t      if (val->lattice_val == CONSTANT\n-\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR)\n+\t\t      tree val = get_constant_value (TREE_OPERAND (rhs, 0));\n+\t\t      if (val\n+\t\t\t  && TREE_CODE (val) == ADDR_EXPR)\n \t\t\t{\n \t\t\t  tree tem = fold_build2 (MEM_REF, TREE_TYPE (rhs),\n-\t\t\t\t\t\t  unshare_expr (val->value),\n+\t\t\t\t\t\t  unshare_expr (val),\n \t\t\t\t\t\t  TREE_OPERAND (rhs, 1));\n \t\t\t  if (tem)\n \t\t\t    rhs = tem;\n@@ -927,7 +933,7 @@ ccp_fold (gimple stmt)\n                  Note that we know the single operand must be a constant,\n                  so this should almost always return a simplified RHS.  */\n               tree lhs = gimple_assign_lhs (stmt);\n-              tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n+              tree op0 = valueize_op (gimple_assign_rhs1 (stmt));\n \n \t      /* Conversions are useless for CCP purposes if they are\n \t\t value-preserving.  Thus the restrictions that\n@@ -958,8 +964,8 @@ ccp_fold (gimple stmt)\n           case GIMPLE_BINARY_RHS:\n             {\n               /* Handle binary operators that can appear in GIMPLE form.  */\n-              tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n-              tree op1 = get_rhs_assign_op_for_ccp (stmt, 2);\n+              tree op0 = valueize_op (gimple_assign_rhs1 (stmt));\n+              tree op1 = valueize_op (gimple_assign_rhs2 (stmt));\n \n \t      /* Translate &x + CST into an invariant form suitable for\n \t         further propagation.  */\n@@ -980,10 +986,10 @@ ccp_fold (gimple stmt)\n \n           case GIMPLE_TERNARY_RHS:\n             {\n-              /* Handle binary operators that can appear in GIMPLE form.  */\n-              tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n-              tree op1 = get_rhs_assign_op_for_ccp (stmt, 2);\n-              tree op2 = get_rhs_assign_op_for_ccp (stmt, 3);\n+              /* Handle ternary operators that can appear in GIMPLE form.  */\n+              tree op0 = valueize_op (gimple_assign_rhs1 (stmt));\n+              tree op1 = valueize_op (gimple_assign_rhs2 (stmt));\n+              tree op2 = valueize_op (gimple_assign_rhs3 (stmt));\n \n               return fold_ternary_loc (loc, subcode,\n \t\t\t\t       gimple_expr_type (stmt), op0, op1, op2);\n@@ -997,15 +1003,7 @@ ccp_fold (gimple stmt)\n \n     case GIMPLE_CALL:\n       {\n-\ttree fn = gimple_call_fn (stmt);\n-\tprop_value_t *val;\n-\n-\tif (TREE_CODE (fn) == SSA_NAME)\n-\t  {\n-\t    val = get_value (fn);\n-\t    if (val->lattice_val == CONSTANT)\n-\t      fn = val->value;\n-\t  }\n+\ttree fn = valueize_op (gimple_call_fn (stmt));\n \tif (TREE_CODE (fn) == ADDR_EXPR\n \t    && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n \t    && DECL_BUILT_IN (TREE_OPERAND (fn, 0)))\n@@ -1014,15 +1012,7 @@ ccp_fold (gimple stmt)\n \t    tree call, retval;\n \t    unsigned i;\n \t    for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-\t      {\n-\t\targs[i] = gimple_call_arg (stmt, i);\n-\t\tif (TREE_CODE (args[i]) == SSA_NAME)\n-\t\t  {\n-\t\t    val = get_value (args[i]);\n-\t\t    if (val->lattice_val == CONSTANT)\n-\t\t      args[i] = val->value;\n-\t\t  }\n-\t      }\n+\t      args[i] = valueize_op (gimple_call_arg (stmt, i));\n \t    call = build_call_array_loc (loc,\n \t\t\t\t\t gimple_call_return_type (stmt),\n \t\t\t\t\t fn, gimple_call_num_args (stmt), args);\n@@ -1038,40 +1028,16 @@ ccp_fold (gimple stmt)\n     case GIMPLE_COND:\n       {\n         /* Handle comparison operators that can appear in GIMPLE form.  */\n-        tree op0 = gimple_cond_lhs (stmt);\n-        tree op1 = gimple_cond_rhs (stmt);\n+        tree op0 = valueize_op (gimple_cond_lhs (stmt));\n+        tree op1 = valueize_op (gimple_cond_rhs (stmt));\n         enum tree_code code = gimple_cond_code (stmt);\n-\n-        /* Simplify the operands down to constants when appropriate.  */\n-        if (TREE_CODE (op0) == SSA_NAME)\n-          {\n-            prop_value_t *val = get_value (op0);\n-            if (val->lattice_val == CONSTANT)\n-              op0 = val->value;\n-          }\n-\n-        if (TREE_CODE (op1) == SSA_NAME)\n-          {\n-            prop_value_t *val = get_value (op1);\n-            if (val->lattice_val == CONSTANT)\n-              op1 = val->value;\n-          }\n-\n         return fold_binary_loc (loc, code, boolean_type_node, op0, op1);\n       }\n \n     case GIMPLE_SWITCH:\n       {\n-        tree rhs = gimple_switch_index (stmt);\n-\n-        if (TREE_CODE (rhs) == SSA_NAME)\n-          {\n-            /* If the RHS is an SSA_NAME, return its known constant value,\n-               if any.  */\n-            return get_value (rhs)->value;\n-          }\n-\n-        return rhs;\n+\t/* Return the constant switch index.  */\n+        return valueize_op (gimple_switch_index (stmt));\n       }\n \n     default:\n@@ -1086,10 +1052,10 @@ ccp_fold (gimple stmt)\n tree\n fold_const_aggregate_ref (tree t)\n {\n-  prop_value_t *value;\n   tree base, ctor, idx, field;\n   unsigned HOST_WIDE_INT cnt;\n   tree cfield, cval;\n+  tree tem;\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == tcc_declaration)\n     return get_symbol_constant_value (t);\n@@ -1149,10 +1115,9 @@ fold_const_aggregate_ref (tree t)\n       switch (TREE_CODE (idx))\n \t{\n \tcase SSA_NAME:\n-\t  if ((value = get_value (idx))\n-\t      && value->lattice_val == CONSTANT\n-\t      && TREE_CODE (value->value) == INTEGER_CST)\n-\t    idx = value->value;\n+\t  if ((tem = get_constant_value (idx))\n+\t      && TREE_CODE (tem) == INTEGER_CST)\n+\t    idx = tem;\n \t  else\n \t    return NULL_TREE;\n \t  break;\n@@ -1257,9 +1222,8 @@ fold_const_aggregate_ref (tree t)\n       /* Get the base object we are accessing.  */\n       base = TREE_OPERAND (t, 0);\n       if (TREE_CODE (base) == SSA_NAME\n-\t  && (value = get_value (base))\n-\t  && value->lattice_val == CONSTANT)\n-\tbase = value->value;\n+\t  && (tem = get_constant_value (base)))\n+\tbase = tem;\n       if (TREE_CODE (base) != ADDR_EXPR)\n \treturn NULL_TREE;\n       base = TREE_OPERAND (base, 0);\n@@ -1477,7 +1441,7 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n     case GIMPLE_CALL:\n       {\n \ttree lhs = gimple_call_lhs (stmt);\n-\tprop_value_t *val;\n+\ttree val;\n \ttree argt;\n \tbool changed = false;\n \tunsigned i;\n@@ -1487,10 +1451,9 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t   type issues.  */\n \tif (lhs\n \t    && TREE_CODE (lhs) == SSA_NAME\n-\t    && (val = get_value (lhs))\n-\t    && val->lattice_val == CONSTANT)\n+\t    && (val = get_constant_value (lhs)))\n \t  {\n-\t    tree new_rhs = unshare_expr (val->value);\n+\t    tree new_rhs = unshare_expr (val);\n \t    bool res;\n \t    if (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t    TREE_TYPE (new_rhs)))\n@@ -1510,13 +1473,12 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t  {\n \t    tree arg = gimple_call_arg (stmt, i);\n \t    if (TREE_CODE (arg) == SSA_NAME\n-\t\t&& (val = get_value (arg))\n-\t\t&& val->lattice_val == CONSTANT\n+\t\t&& (val = get_constant_value (arg))\n \t\t&& useless_type_conversion_p\n \t\t     (TYPE_MAIN_VARIANT (TREE_VALUE (argt)),\n-\t\t      TYPE_MAIN_VARIANT (TREE_TYPE (val->value))))\n+\t\t      TYPE_MAIN_VARIANT (TREE_TYPE (val))))\n \t      {\n-\t\tgimple_call_set_arg (stmt, i, unshare_expr (val->value));\n+\t\tgimple_call_set_arg (stmt, i, unshare_expr (val));\n \t\tchanged = true;\n \t      }\n \t  }\n@@ -1527,16 +1489,15 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n     case GIMPLE_ASSIGN:\n       {\n \ttree lhs = gimple_assign_lhs (stmt);\n-\tprop_value_t *val;\n+\ttree val;\n \n \t/* If we have a load that turned out to be constant replace it\n \t   as we cannot propagate into all uses in all cases.  */\n \tif (gimple_assign_single_p (stmt)\n \t    && TREE_CODE (lhs) == SSA_NAME\n-\t    && (val = get_value (lhs))\n-\t    && val->lattice_val == CONSTANT)\n+\t    && (val = get_constant_value (lhs)))\n \t  {\n-\t    tree rhs = unshare_expr (val->value);\n+\t    tree rhs = unshare_expr (val);\n \t    if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t      rhs = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n \t    gimple_assign_set_rhs_from_tree (gsi, rhs);\n@@ -1569,19 +1530,10 @@ visit_assignment (gimple stmt, tree *output_p)\n   gcc_assert (gimple_code (stmt) != GIMPLE_CALL\n               || gimple_call_lhs (stmt) != NULL_TREE);\n \n-  if (gimple_assign_copy_p (stmt))\n-    {\n-      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-      if  (TREE_CODE (rhs) == SSA_NAME)\n-        {\n-          /* For a simple copy operation, we copy the lattice values.  */\n-          prop_value_t *nval = get_value (rhs);\n-          val = *nval;\n-        }\n-      else\n-        val = evaluate_stmt (stmt);\n-    }\n+  if (gimple_assign_single_p (stmt)\n+      && gimple_assign_rhs_code (stmt) == SSA_NAME)\n+    /* For a simple copy operation, we copy the lattice values.  */\n+    val = *get_value (gimple_assign_rhs1 (stmt));\n   else\n     /* Evaluate the statement, which could be\n        either a GIMPLE_ASSIGN or a GIMPLE_CALL.  */"}]}