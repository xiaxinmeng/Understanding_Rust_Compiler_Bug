{"sha": "7088fca94118e4e68a80f349ee55cda4930823b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4OGZjYTk0MTE4ZTRlNjhhODBmMzQ5ZWU1NWNkYTQ5MzA4MjNiMQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2002-10-30T15:54:10Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2002-10-30T15:54:10Z"}, "message": "Core issue 287, PR c++/7639\n\n\tCore issue 287, PR c++/7639\n\t* cp-tree.h (lang_type_class): Add decl_list field.\n\t(CLASSTYPE_DECL_LIST): New macro.\n\t(maybe_add_class_template_decl_list): Add declaration.\n\t* class.c (duplicate_tag_error): Initialize CLASSTYPE_DECL_LIST.\n\t(unreverse_member_declarations): Reverse CLASSTYPE_DECL_LIST.\n\t(maybe_add_class_template_decl_list): New function.\n\t(add_implicitly_declared_members): Use it.\n\t* decl.c (maybe_process_template_type_declaration): Likewise.\n\t(pushtag): Likewise.\n\t* friend.c (add_friend): Likewise.\n\t(make_friend_class): Likewise.\n\t* semantics.c (finish_member_declaration): Likewise.\n\t(begin_class_definition): Initialize CLASSTYPE_DECL_LIST.\n\t* pt.c (instantiate_class_template): Use CLASSTYPE_DECL_LIST\n\tto process members and friends in the order of declaration.\n\n\tCore issue 287, PR c++/7639\n\t* g++.dg/template/instantiate1.C: Adjust error location.\n\t* g++.dg/template/instantiate3.C: New test.\n\t* g++.old-deja/g++.pt/crash10.C: Adjust error location.\n\t* g++.old-deja/g++.pt/derived3.C: Adjust error location.\n\t* g++.old-deja/g++.pt/spec28.C: Reorder declaration.\n\nFrom-SVN: r58654", "tree": {"sha": "de9d8ee4f80351fcf0257caba03bc679119f5b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de9d8ee4f80351fcf0257caba03bc679119f5b27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7088fca94118e4e68a80f349ee55cda4930823b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7088fca94118e4e68a80f349ee55cda4930823b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7088fca94118e4e68a80f349ee55cda4930823b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7088fca94118e4e68a80f349ee55cda4930823b1/comments", "author": null, "committer": null, "parents": [{"sha": "d2d199a3e6103b6cd2e0088cbcfdd0047d2c631e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d199a3e6103b6cd2e0088cbcfdd0047d2c631e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d199a3e6103b6cd2e0088cbcfdd0047d2c631e"}], "stats": {"total": 423, "additions": 261, "deletions": 162}, "files": [{"sha": "1dc2487d52618ed34e12264b19b4e9f7307cb71e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -1,3 +1,22 @@\n+2002-10-30  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tCore issue 287, PR c++/7639\n+\t* cp-tree.h (lang_type_class): Add decl_list field.\n+\t(CLASSTYPE_DECL_LIST): New macro.\n+\t(maybe_add_class_template_decl_list): Add declaration.\n+\t* class.c (duplicate_tag_error): Initialize CLASSTYPE_DECL_LIST.\n+\t(unreverse_member_declarations): Reverse CLASSTYPE_DECL_LIST.\n+\t(maybe_add_class_template_decl_list): New function.\n+\t(add_implicitly_declared_members): Use it.\n+\t* decl.c (maybe_process_template_type_declaration): Likewise.\n+\t(pushtag): Likewise.\n+\t* friend.c (add_friend): Likewise.\n+\t(make_friend_class): Likewise.\n+\t* semantics.c (finish_member_declaration): Likewise.\n+\t(begin_class_definition): Initialize CLASSTYPE_DECL_LIST.\n+\t* pt.c (instantiate_class_template): Use CLASSTYPE_DECL_LIST\n+\tto process members and friends in the order of declaration.\n+\n 2002-10-29  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/8287"}, {"sha": "d189686fdcf4877b344de60f9a54fc75a805884c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -2093,6 +2093,7 @@ duplicate_tag_error (t)\n       TYPE_REDEFINED (t) = 1;\n       CLASSTYPE_TEMPLATE_INFO (t) = template_info;\n       CLASSTYPE_USE_TEMPLATE (t) = use_template;\n+      CLASSTYPE_DECL_LIST (t) = NULL_TREE;\n     }\n   TYPE_SIZE (t) = NULL_TREE;\n   TYPE_MODE (t) = VOIDmode;\n@@ -2744,6 +2745,29 @@ finish_struct_anon (t)\n     }\n }\n \n+/* Add T to CLASSTYPE_DECL_LIST of current_class_type which\n+   will be used later during class template instantiation.\n+   When FRIEND_P is zero, T can be a static member data (VAR_DECL),\n+   a non-static member data (FIELD_DECL), a member function\n+   (FUNCTION_DECL), a nested type (RECORD_TYPE, ENUM_TYPE), \n+   a typedef (TYPE_DECL) or a member class template (TEMPLATE_DECL)\n+   When FRIEND_P is nonzero, T is either a friend class\n+   (RECORD_TYPE, TEMPLATE_DECL) or a friend function\n+   (FUNCTION_DECL, TEMPLATE_DECL).  */\n+\n+void\n+maybe_add_class_template_decl_list (type, t, friend_p)\n+     tree type;\n+     tree t;\n+     int friend_p;\n+{\n+  /* Save some memory by not creating TREE_LIST if TYPE is not template.  */\n+  if (CLASSTYPE_TEMPLATE_INFO (type))\n+    CLASSTYPE_DECL_LIST (type)\n+      = tree_cons (friend_p ? NULL_TREE : type,\n+\t\t   t, CLASSTYPE_DECL_LIST (type));\n+}\n+\n /* Create default constructors, assignment operators, and so forth for\n    the type indicated by T, if they are needed.\n    CANT_HAVE_DEFAULT_CTOR, CANT_HAVE_CONST_CTOR, and\n@@ -2824,7 +2848,10 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n   /* Now, hook all of the new functions on to TYPE_METHODS,\n      and add them to the CLASSTYPE_METHOD_VEC.  */\n   for (f = &implicit_fns; *f; f = &TREE_CHAIN (*f))\n-    add_method (t, *f, /*error_p=*/0);\n+    {\n+      add_method (t, *f, /*error_p=*/0);\n+      maybe_add_class_template_decl_list (current_class_type, *f, /*friend_p=*/0);\n+    }\n   *f = TYPE_METHODS (t);\n   TYPE_METHODS (t) = implicit_fns;\n \n@@ -5305,10 +5332,11 @@ unreverse_member_declarations (t)\n   tree prev;\n   tree x;\n \n-  /* The TYPE_FIELDS, TYPE_METHODS, and CLASSTYPE_TAGS are all in\n-     reverse order.  Put them in declaration order now.  */\n+  /* The following lists are all in reverse order.  Put them in\n+     declaration order now.  */\n   TYPE_METHODS (t) = nreverse (TYPE_METHODS (t));\n   CLASSTYPE_TAGS (t) = nreverse (CLASSTYPE_TAGS (t));\n+  CLASSTYPE_DECL_LIST (t) = nreverse (CLASSTYPE_DECL_LIST (t));\n \n   /* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in\n      reverse order, so we can't just use nreverse.  */"}, {"sha": "d9bde845c5523ab512071836db7131c12b673a39", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -1159,6 +1159,7 @@ struct lang_type_class GTY(())\n   tree friend_classes;\n   tree rtti;\n   tree methods;\n+  tree decl_list;\n   tree template_info;\n   tree befriending_classes;\n };\n@@ -1295,6 +1296,12 @@ struct lang_type GTY(())\n    functions are sorted, once the class is complete.  */\n #define CLASSTYPE_METHOD_VEC(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->methods)\n \n+/* For class templates, this is a TREE_LIST of all member data,\n+   functions, types, and friends in the order of declaration.\n+   The TREE_PURPOSE of each TREE_LIST is NULL_TREE for a friend,\n+   and the RECORD_TYPE for the class template otherwise.  */\n+#define CLASSTYPE_DECL_LIST(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->decl_list)\n+\n /* The slot in the CLASSTYPE_METHOD_VEC where constructors go.  */\n #define CLASSTYPE_CONSTRUCTOR_SLOT 0\n \n@@ -3572,6 +3579,7 @@ extern void cxx_print_error_function\tPARAMS ((struct diagnostic_context *,\n extern void build_self_reference\t\tPARAMS ((void));\n extern int same_signature_p\t\t\tPARAMS ((tree, tree));\n extern void warn_hidden\t\t\t\tPARAMS ((tree));\n+extern void maybe_add_class_template_decl_list\tPARAMS ((tree, tree, int));\n extern tree get_enclosing_class\t\t\tPARAMS ((tree));\n int is_base_of_enclosing_class\t\t\tPARAMS ((tree, tree));\n extern void unreverse_member_declarations       PARAMS ((tree));"}, {"sha": "4fcb36369ddb80204f266955b3c5d658d8af3bad", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -2617,7 +2617,11 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t      b->level_chain->tags =\n \t\ttree_cons (name, type, b->level_chain->tags);\n \t      if (!COMPLETE_TYPE_P (current_class_type))\n-\t\tCLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n+\t\t{\n+\t\t  maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t\t      type, /*friend_p=*/0);\n+\t\t  CLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -2781,7 +2785,11 @@ pushtag (name, type, globalize)\n       if (b->parm_flag == 2)\n \t{\n \t  if (!COMPLETE_TYPE_P (current_class_type))\n-\t    CLASSTYPE_TAGS (current_class_type) = b->tags;\n+\t    {\n+\t      maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t\t  type, /*friend_p=*/0);\n+\t      CLASSTYPE_TAGS (current_class_type) = b->tags;\n+\t    }\n \t}\n     }\n "}, {"sha": "7b718ace0dfa26399ec672a1047e17722321291e", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -159,13 +159,18 @@ add_friend (type, decl)\n \t\t  return;\n \t\t}\n \t    }\n+\n+\t  maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n+\n \t  TREE_VALUE (list) = tree_cons (error_mark_node, decl,\n \t\t\t\t\t TREE_VALUE (list));\n \t  return;\n \t}\n       list = TREE_CHAIN (list);\n     }\n \n+  maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n+\n   DECL_FRIENDLIST (typedecl)\n     = tree_cons (DECL_NAME (decl), build_tree_list (error_mark_node, decl),\n \t\t DECL_FRIENDLIST (typedecl));\n@@ -267,6 +272,8 @@ make_friend_class (type, friend_type)\n \t\tTREE_VALUE (classes), type);\n   else\n     {\n+      maybe_add_class_template_decl_list (type, friend_type, /*friend_p=*/1);\n+\n       CLASSTYPE_FRIEND_CLASSES (type)\n \t= tree_cons (NULL_TREE, friend_type, CLASSTYPE_FRIEND_CLASSES (type));\n       if (is_template_friend)"}, {"sha": "09e225add65d6504be23c8ad6ef54ff15d3d5452", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -4975,7 +4975,7 @@ tree\n instantiate_class_template (type)\n      tree type;\n {\n-  tree template, args, pattern, t;\n+  tree template, args, pattern, t, member;\n   tree typedecl;\n \n   if (type == error_mark_node)\n@@ -5070,6 +5070,7 @@ instantiate_class_template (type)\n       TYPE_BINFO_BASETYPES (type) = TYPE_BINFO_BASETYPES (pattern);\n       TYPE_FIELDS (type) = TYPE_FIELDS (pattern);\n       TYPE_METHODS (type) = TYPE_METHODS (pattern);\n+      CLASSTYPE_DECL_LIST (type) = CLASSTYPE_DECL_LIST (pattern);\n       CLASSTYPE_TAGS (type) = CLASSTYPE_TAGS (pattern);\n       CLASSTYPE_VBASECLASSES (type) = CLASSTYPE_VBASECLASSES (pattern);\n       \n@@ -5223,175 +5224,174 @@ instantiate_class_template (type)\n      class.  */\n   pushclass (type, 1);\n \n-  for (t = CLASSTYPE_TAGS (pattern); t; t = TREE_CHAIN (t))\n+  /* Now members are processed in the order of declaration.  */\n+  for (member = CLASSTYPE_DECL_LIST (pattern); member; member = TREE_CHAIN (member))\n     {\n-      tree tag = TREE_VALUE (t);\n-      tree name = TYPE_IDENTIFIER (tag);\n-      tree newtag;\n+      tree t = TREE_VALUE (member);\n \n-      newtag = tsubst (tag, args, tf_error, NULL_TREE);\n-      my_friendly_assert (newtag != error_mark_node, 20010206);\n-      if (TREE_CODE (newtag) != ENUMERAL_TYPE)\n+      if (TREE_PURPOSE (member))\n \t{\n-\t  if (TYPE_LANG_SPECIFIC (tag) && CLASSTYPE_IS_TEMPLATE (tag))\n-\t    /* Unfortunately, lookup_template_class sets\n-\t       CLASSTYPE_IMPLICIT_INSTANTIATION for a partial\n-\t       instantiation (i.e., for the type of a member template\n-\t       class nested within a template class.)  This behavior is\n-\t       required for maybe_process_partial_specialization to work\n-\t       correctly, but is not accurate in this case; the TAG is not\n-\t       an instantiation of anything.  (The corresponding\n-\t       TEMPLATE_DECL is an instantiation, but the TYPE is not.) */\n-\t    CLASSTYPE_USE_TEMPLATE (newtag) = 0;\n-\n-\t  /* Now, we call pushtag to put this NEWTAG into the scope of\n-\t     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid\n-\t     pushtag calling push_template_decl.  We don't have to do\n-\t     this for enums because it will already have been done in\n-\t     tsubst_enum.  */\n-\t  if (name)\n-\t    SET_IDENTIFIER_TYPE_VALUE (name, newtag);\n-\t  pushtag (name, newtag, /*globalize=*/0);\n-\t}\n-    }\n+\t  if (TYPE_P (t))\n+\t    {\n+\t      /* Build new CLASSTYPE_TAGS.  */\n \n-  /* Don't replace enum constants here.  */\n-  for (t = TYPE_FIELDS (pattern); t; t = TREE_CHAIN (t))\n-    if (TREE_CODE (t) != CONST_DECL)\n-      {\n-\ttree r;\n+\t      tree tag = t;\n+\t      tree name = TYPE_IDENTIFIER (tag);\n+\t      tree newtag;\n \n-\t/* The the file and line for this declaration, to assist in\n-\t   error message reporting.  Since we called push_tinst_level\n-\t   above, we don't need to restore these.  */\n-\tlineno = DECL_SOURCE_LINE (t);\n-\tinput_filename = DECL_SOURCE_FILE (t);\n+\t      newtag = tsubst (tag, args, tf_error, NULL_TREE);\n+\t      my_friendly_assert (newtag != error_mark_node, 20010206);\n+\t      if (TREE_CODE (newtag) != ENUMERAL_TYPE)\n+\t\t{\n+\t\t  if (TYPE_LANG_SPECIFIC (tag) && CLASSTYPE_IS_TEMPLATE (tag))\n+\t\t    /* Unfortunately, lookup_template_class sets\n+\t\t       CLASSTYPE_IMPLICIT_INSTANTIATION for a partial\n+\t\t       instantiation (i.e., for the type of a member template\n+\t\t       class nested within a template class.)  This behavior is\n+\t\t       required for maybe_process_partial_specialization to work\n+\t\t       correctly, but is not accurate in this case; the TAG is not\n+\t\t       an instantiation of anything.  (The corresponding\n+\t\t       TEMPLATE_DECL is an instantiation, but the TYPE is not.) */\n+\t\t    CLASSTYPE_USE_TEMPLATE (newtag) = 0;\n+\n+\t\t  /* Now, we call pushtag to put this NEWTAG into the scope of\n+\t\t     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid\n+\t\t     pushtag calling push_template_decl.  We don't have to do\n+\t\t     this for enums because it will already have been done in\n+\t\t     tsubst_enum.  */\n+\t\t  if (name)\n+\t\t    SET_IDENTIFIER_TYPE_VALUE (name, newtag);\n+\t\t  pushtag (name, newtag, /*globalize=*/0);\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (t) == FUNCTION_DECL \n+\t\t   || DECL_FUNCTION_TEMPLATE_P (t))\n+\t    {\n+\t      /* Build new TYPE_METHODS.  */\n \n-\tr = tsubst (t, args, tf_error | tf_warning, NULL_TREE);\n-\tif (TREE_CODE (r) == VAR_DECL)\n-\t  {\n-\t    tree init;\n+\t      tree r = tsubst (t, args, tf_error, NULL_TREE);\n+\t      set_current_access_from_decl (r);\n+\t      grok_special_member_properties (r);\n+\t      finish_member_declaration (r);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Build new TYPE_FIELDS.  */\n \n-\t    if (DECL_INITIALIZED_IN_CLASS_P (r))\n-\t      init = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t\t  tf_error | tf_warning, NULL_TREE);\n-\t    else\n-\t      init = NULL_TREE;\n+\t      if (TREE_CODE (t) != CONST_DECL)\n+\t\t{\n+\t\t  tree r;\n \n-\t    finish_static_data_member_decl (r, init,\n-\t\t\t\t\t    /*asmspec_tree=*/NULL_TREE, \n-\t\t\t\t\t    /*flags=*/0);\n+\t\t  /* The the file and line for this declaration, to assist\n+\t\t     in error message reporting.  Since we called \n+\t\t     push_tinst_level above, we don't need to restore these.  */\n+\t\t  lineno = DECL_SOURCE_LINE (t);\n+\t\t  input_filename = DECL_SOURCE_FILE (t);\n \n-\t    if (DECL_INITIALIZED_IN_CLASS_P (r))\n-\t      check_static_variable_definition (r, TREE_TYPE (r));\n-\t  }\n-\telse if (TREE_CODE (r) == FIELD_DECL)\n-\t  {\n-\t    /* Determine whether R has a valid type and can be\n-\t       completed later.  If R is invalid, then it is replaced\n-\t       by error_mark_node so that it will not be added to\n-\t       TYPE_FIELDS.  */\n-\t    tree rtype = TREE_TYPE (r);\n-\t    if (!can_complete_type_without_circularity (rtype))\n-\t      {\n-\t\tcxx_incomplete_type_error (r, rtype);\n-\t\tr = error_mark_node;\n-\t      }\n-\t  }\n+\t\t  r = tsubst (t, args, tf_error | tf_warning, NULL_TREE);\n+\t\t  if (TREE_CODE (r) == VAR_DECL)\n+\t\t    {\n+\t\t      tree init;\n \n-\t/* R will have a TREE_CHAIN if and only if it has already been\n-\t   processed by finish_member_declaration.  This can happen\n-\t   if, for example, it is a TYPE_DECL for a class-scoped\n-\t   ENUMERAL_TYPE; such a thing will already have been added to\n-\t   the field list by tsubst_enum above.  */\n-\tif (!TREE_CHAIN (r))\n-\t  {\n-\t    set_current_access_from_decl (r);\n-\t    finish_member_declaration (r);\n-\t  }\n-      }\n+\t\t      if (DECL_INITIALIZED_IN_CLASS_P (r))\n+\t\t\tinit = tsubst_expr (DECL_INITIAL (t), args,\n+\t\t\t\t\t    tf_error | tf_warning, NULL_TREE);\n+\t\t      else\n+\t\t\tinit = NULL_TREE;\n \n-  /* Set up the list (TYPE_METHODS) and vector (CLASSTYPE_METHOD_VEC)\n-     for this instantiation.  */\n-  for (t = TYPE_METHODS (pattern); t; t = TREE_CHAIN (t))\n-    {\n-      tree r = tsubst (t, args, tf_error, NULL_TREE);\n-      set_current_access_from_decl (r);\n-      grok_special_member_properties (r);\n-      finish_member_declaration (r);\n-    }\n+\t\t      finish_static_data_member_decl (r, init,\n+\t\t\t\t\t\t      /*asmspec_tree=*/NULL_TREE, \n+\t\t\t\t\t\t      /*flags=*/0);\n \n-  /* Construct the DECL_FRIENDLIST for the new class type.  */\n-  typedecl = TYPE_MAIN_DECL (type);\n-  for (t = DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern));\n-       t != NULL_TREE;\n-       t = TREE_CHAIN (t))\n-    {\n-      tree friends;\n-\n-      for (friends = TREE_VALUE (t);\n-\t   friends != NULL_TREE;\n-\t   friends = TREE_CHAIN (friends))\n-\tif (TREE_PURPOSE (friends) == error_mark_node)\n-\t  add_friend (type, \n-\t\t      tsubst_friend_function (TREE_VALUE (friends),\n-\t\t\t\t\t      args));\n-\telse\n-\t  abort ();\n-    }\n-\n-  for (t = CLASSTYPE_FRIEND_CLASSES (pattern);\n-       t != NULL_TREE;\n-       t = TREE_CHAIN (t))\n-    {\n-      tree friend_type = TREE_VALUE (t);\n-      tree new_friend_type;\n+\t\t      if (DECL_INITIALIZED_IN_CLASS_P (r))\n+\t\t\tcheck_static_variable_definition (r, TREE_TYPE (r));\n+\t\t    }\n+\t\t  else if (TREE_CODE (r) == FIELD_DECL)\n+\t\t    {\n+\t\t      /* Determine whether R has a valid type and can be\n+\t\t\t completed later.  If R is invalid, then it is\n+\t\t\t replaced by error_mark_node so that it will not be\n+\t\t\t added to TYPE_FIELDS.  */\n+\t\t      tree rtype = TREE_TYPE (r);\n+\t\t      if (can_complete_type_without_circularity (rtype))\n+\t\t\tcomplete_type (rtype);\n+\n+\t\t      if (!COMPLETE_TYPE_P (rtype))\n+\t\t\t{\n+\t\t\t  cxx_incomplete_type_error (r, rtype);\n+\t\t  \t  r = error_mark_node;\n+\t\t\t}\n+\t\t    }\n \n-      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n-\tnew_friend_type = tsubst_friend_class (friend_type, args);\n-      else if (uses_template_parms (friend_type))\n-\tnew_friend_type = tsubst (friend_type, args,\n-\t\t\t\t  tf_error | tf_warning, NULL_TREE);\n-      else \n-\t{\n-\t  tree ns = decl_namespace_context (TYPE_MAIN_DECL (friend_type));\n-\n-\t  /* The call to xref_tag_from_type does injection for friend\n-\t     classes.  */\n-\t  push_nested_namespace (ns);\n-\t  new_friend_type = \n-\t    xref_tag_from_type (friend_type, NULL_TREE, 1);\n-\t  pop_nested_namespace (ns);\n+\t\t  /* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE,\n+\t\t     such a thing will already have been added to the field\n+\t\t     list by tsubst_enum in finish_member_declaration in the\n+\t\t     CLASSTYPE_TAGS case above.  */\n+\t\t  if (!(TREE_CODE (r) == TYPE_DECL\n+\t\t\t&& TREE_CODE (TREE_TYPE (r)) == ENUMERAL_TYPE\n+\t\t\t&& TYPE_CONTEXT (TREE_TYPE (r)) == type))\n+\t\t    {\n+\t\t      set_current_access_from_decl (r);\n+\t\t      finish_member_declaration (r);\n+\t\t    }\n+\t        }\n+\t    }\n \t}\n+      else\n+\t{\n+\t  if (TYPE_P (t) || DECL_CLASS_TEMPLATE_P (t))\n+\t    {\n+\t      /* Build new CLASSTYPE_FRIEND_CLASSES.  */\n \n-      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n-\t/* Trick make_friend_class into realizing that the friend\n-\t   we're adding is a template, not an ordinary class.  It's\n-\t   important that we use make_friend_class since it will\n-\t   perform some error-checking and output cross-reference\n-\t   information.  */\n-\t++processing_template_decl;\n+\t      tree friend_type = t;\n+\t      tree new_friend_type;\n \n-      if (new_friend_type != error_mark_node)\n-        make_friend_class (type, new_friend_type);\n+\t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t\tnew_friend_type = tsubst_friend_class (friend_type, args);\n+\t      else if (uses_template_parms (friend_type))\n+\t\tnew_friend_type = tsubst (friend_type, args,\n+\t\t\t\t\t  tf_error | tf_warning, NULL_TREE);\n+\t      else \n+\t\t{\n+\t\t  tree ns = decl_namespace_context (TYPE_MAIN_DECL (friend_type));\n+\n+\t\t  /* The call to xref_tag_from_type does injection for friend\n+\t\t     classes.  */\n+\t\t  push_nested_namespace (ns);\n+\t\t  new_friend_type = \n+\t\t    xref_tag_from_type (friend_type, NULL_TREE, 1);\n+\t\t  pop_nested_namespace (ns);\n+\t\t}\n \n-      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n-\t--processing_template_decl;\n-    }\n+\t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t\t/* Trick make_friend_class into realizing that the friend\n+\t\t   we're adding is a template, not an ordinary class.  It's\n+\t\t   important that we use make_friend_class since it will\n+\t\t   perform some error-checking and output cross-reference\n+\t\t   information.  */\n+\t\t++processing_template_decl;\n \n-  /* Now that TYPE_FIELDS and TYPE_METHODS are set up.  We can\n-     instantiate templates used by this class.  */\n-  for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n-    if (TREE_CODE (t) == FIELD_DECL)\n-      {\n-\tTREE_TYPE (t) = complete_type (TREE_TYPE (t));\n-\trequire_complete_type (t);\n-      }\n+\t      if (new_friend_type != error_mark_node)\n+\t        make_friend_class (type, new_friend_type);\n+\n+\t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t\t--processing_template_decl;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Build new DECL_FRIENDLIST.  */\n+\n+\t      add_friend (type, \n+\t\t\t  tsubst_friend_function (t, args));\n+\t    }\n+\t}\n+    }\n \n   /* Set the file and line number information to whatever is given for\n      the class itself.  This puts error messages involving generated\n      implicit functions at a predictable point, and the same point\n      that would be used for non-template classes.  */\n+  typedecl = TYPE_MAIN_DECL (type);\n   lineno = DECL_SOURCE_LINE (typedecl);\n   input_filename = DECL_SOURCE_FILE (typedecl);\n "}, {"sha": "81b4ccfdafc4e8faddc45bda99b794bf335f72e8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -1754,6 +1754,7 @@ begin_class_definition (t)\n \t  TYPE_BINFO_BASETYPES (t) = NULL_TREE;\n \t  TYPE_FIELDS (t) = NULL_TREE;\n \t  TYPE_METHODS (t) = NULL_TREE;\n+\t  CLASSTYPE_DECL_LIST (t) = NULL_TREE;\n \t  CLASSTYPE_TAGS (t) = NULL_TREE;\n \t  CLASSTYPE_VBASECLASSES (t) = NULL_TREE;\n \t  TYPE_SIZE (t) = NULL_TREE;\n@@ -1835,6 +1836,8 @@ finish_member_declaration (decl)\n   if (DECL_LANG_SPECIFIC (decl) && DECL_LANGUAGE (decl) == lang_c)\n     SET_DECL_LANGUAGE (decl, lang_cplusplus);\n \n+  maybe_add_class_template_decl_list (current_class_type, decl, /*friend_p=*/0);\n+\n   /* Put functions on the TYPE_METHODS list and everything else on the\n      TYPE_FIELDS list.  Note that these are built up in reverse order.\n      We reverse them (to obtain declaration order) in finish_struct.  */"}, {"sha": "2c0826d0b30d3d9cdd867539e26a31ad2b5cda08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -1,3 +1,12 @@\n+2002-10-30  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tCore issue 287, PR c++/7639\n+\t* g++.dg/template/instantiate1.C: Adjust error location.\n+\t* g++.dg/template/instantiate3.C: New test.\n+\t* g++.old-deja/g++.pt/crash10.C: Adjust error location.\n+\t* g++.old-deja/g++.pt/derived3.C: Adjust error location.\n+\t* g++.old-deja/g++.pt/spec28.C: Reorder declaration.\n+\n 2002-10-29  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* lib/compat.exp (compat-execute): Don't clean out a gluefile."}, {"sha": "e4e7bc981785abc40d356a997de210f8b62de1bf", "filename": "gcc/testsuite/g++.dg/template/instantiate1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finstantiate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finstantiate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finstantiate1.C?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -8,12 +8,12 @@ template <class T> struct X {\n   T t;\t\t\t\t// { dg-error \"incomplete\" }\n };\n \n-template <class T> struct Y {\t// { dg-error \"instantiated\" }\n-  X<T> x;\n+template <class T> struct Y {\n+  X<T> x;\t\t\t// { dg-error \"instantiated\" }\n };\n \n-template <class T> struct Z {\t// { dg-error \"instantiated|declaration\" }\n-  Y<Z<T> > y;\n+template <class T> struct Z {\t// { dg-error \"declaration\" }\n+  Y<Z<T> > y;\t\t\t// { dg-error \"instantiated\" }\n };\n \n struct ZZ : Z<int>"}, {"sha": "e75b570cf8290c6c76196b653d34ff9f38b39c42", "filename": "gcc/testsuite/g++.dg/template/instantiate3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finstantiate3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finstantiate3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Finstantiate3.C?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// Origin: Scott Snyder <snyder@fnal.gov>\n+\n+// PR c++/7639\n+// ICE when accessing member with incomplete type.\n+\n+class ACE_Null_Mutex;\t// { dg-error \"forward declaration\" }\n+\n+template <class TYPE>\n+struct ACE_Cleanup_Adapter\n+{\n+  TYPE &object ()\n+  { return object_; }\t// { dg-error \"no member\" }\n+  TYPE object_;\t\t// { dg-error \"incomplete type\" }\n+};\n+\n+template class ACE_Cleanup_Adapter<ACE_Null_Mutex>; // { dg-error \"instantiated from here\" }"}, {"sha": "a7633a0d58ead97aecb9f86c5746c832b4732b09", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash10.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash10.C?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -3,9 +3,9 @@\n template<int M, int N>\n class GCD {\n public:\n-  enum { val = (N == 0) ? M : GCD<N, M % N>::val }; \n+  enum { val = (N == 0) ? M : GCD<N, M % N>::val }; // ERROR - division\n };\n \n int main() {\n-  GCD< 1, 0 >::val; // ERROR - division\n+  GCD< 1, 0 >::val; // ERROR - instantiated\n }"}, {"sha": "262c1c7df7901c314c811af4f4fc713a4a3e242f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/derived3.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fderived3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fderived3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fderived3.C?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -6,10 +6,10 @@\n \n template<class T>\n class X {\n-\tclass Y : public T {}; // ERROR - invalid base type\n-\tY y;\n+\tclass Y : public T {};\n+\tY y;\t\t\t// ERROR - invalid base type\n };\n int main() {\n-\tX<int> x;\n+\tX<int> x;\t\t// ERROR - instantiated\n }\n "}, {"sha": "cb073802a925b3127795707f6edae557c638e5a0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7088fca94118e4e68a80f349ee55cda4930823b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec28.C?ref=7088fca94118e4e68a80f349ee55cda4930823b1", "patch": "@@ -2,8 +2,8 @@\n \n template <class T> \n struct S1 {\n-  friend bool f<>(const S1&);\n   typedef T X;\n+  friend bool f<>(const S1&);\n };\n \n template <class T>"}]}