{"sha": "4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2YzYwN2YyZTdjNmEwYTQ0M2UzMzM1NmVhZjJiY2Q1ZmY4ZWIxNw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-04-11T20:48:54Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-04-11T20:48:54Z"}, "message": "m32r.h (UPPER16_P): Fix calculation.\n\n\t* m32r/m32r.h (UPPER16_P): Fix calculation.\n\t* m32r/m32r.c (two_insn_const_operand): New function.\n\t(m32r_print_operand): Handle 'X'.\n\t* m32r/m32r.md (movsi): Tweak.\n\t(*movsi_insn): Output hex value of constants too.\n\t(movsi define_split): Add.\n\t(andsi3,orsi3,xorsi3): Output hex value of constants too.\n\nFrom-SVN: r13857", "tree": {"sha": "c2dc6e74d32b0b6f530c64aec40a5d1856311e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2dc6e74d32b0b6f530c64aec40a5d1856311e10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/comments", "author": null, "committer": null, "parents": [{"sha": "4e007b6eea06c7668e340e7bafc1cb94054b23e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e007b6eea06c7668e340e7bafc1cb94054b23e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e007b6eea06c7668e340e7bafc1cb94054b23e6"}], "stats": {"total": 98, "additions": 87, "deletions": 11}, "files": [{"sha": "9a36ec82dfce57fcdcb6a806aa98b53d3a9b18fc", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "patch": "@@ -707,6 +707,22 @@ reg_or_cmp_int16_operand (op, mode)\n   return CMP_INT16_P (INTVAL (op));\n }\n \n+/* Return true if OP is a const_int requiring two instructions to load.  */\n+\n+int\n+two_insn_const_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  if (INT16_P (INTVAL (op))\n+      || UINT24_P (INTVAL (op))\n+      || UPPER16_P (INTVAL (op)))\n+    return 0;\n+  return 1;\n+}\n+\n /* Return true if OP is an acceptable argument for a single word\n    move source.  */\n \n@@ -1667,6 +1683,18 @@ m32r_print_operand (file, x, code)\n \toutput_operand_lossage (\"invalid operand to %N code\");\n       return;\n \n+    case 'X' :\n+      /* Print a const_int in hex.  Used in comments.  */\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t \"0x%x\",\n+#else\n+\t\t \"0x%lx\",\n+#endif\n+\t\t INTVAL (x));\n+      return;\n+\n     case '#' :\n       fputs (IMMEDIATE_PREFIX, file);\n       return;"}, {"sha": "e199ff9923b459201619f818980a6421c31e8907", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "patch": "@@ -593,7 +593,7 @@ extern enum reg_class m32r_regno_reg_class[];\n #define INT16_P(X) ((unsigned) ((X) + 0x8000) < 0x10000)\n #define CMP_INT16_P(X) ((unsigned) ((X) - 1 + 0x8000) < 0x10000)\n #define UINT16_P(X) ((unsigned) (X) < 0x10000)\n-#define UPPER16_P(X) (((X) & 0xffff0000) == 0)\n+#define UPPER16_P(X) (((X) & ~0xffff0000) == 0)\n #define UINT24_P(X) ((unsigned) (X) < 0x1000000)\n #define INT32_P(X) ((X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1) \\\n \t\t    && (X) <= (unsigned HOST_WIDE_INT) 0xffffffff)"}, {"sha": "814d41ddfc06dc898e58abbe2b60d4500948f6b2", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 58, "deletions": 10, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=4d6c607f2e7c6a0a443e33356eaf2bcd5ff8eb17", "patch": "@@ -168,19 +168,21 @@\n   \"\"\n   \"\n {\n-  /* Everything except mem = const or mem = mem can be done easily.\n-     If medium or large code model, symbols have to be loaded with seth/add3.\n-     Objects in the small data area are handled too.  */\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n \n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (SImode, operands[1]);\n \n+  /* Small Data Area reference?  */\n   if (small_data_operand (operands[1], SImode))\n     {\n       emit_insn (gen_movsi_sda (operands[0], operands[1]));\n       DONE;\n     }\n-  else if (addr32_operand (operands[1], SImode))\n+\n+  /* If medium or large code model, symbols have to be loaded with\n+     seth/add3.  */\n+  if (addr32_operand (operands[1], SImode))\n     {\n       emit_insn (gen_movsi_addr32 (operands[0], operands[1]));\n       DONE;\n@@ -194,15 +196,61 @@\n   \"register_operand (operands[0], SImode) || register_operand (operands[1], SImode)\"\n   \"@\n    mv %0,%1\n-   ldi %0,%#%1\n-   ldi %0,%#%1\n-   ld24 %0,%#%1\n+   ldi %0,%#%1 ; %X1\n+   ldi %0,%#%1 ; %X1\n+   ld24 %0,%#%1 ; %X1\n    seth %0,%#%T1\n    seth %0,%#%T1\\;or3 %0,%0,%#%B1\n    ld %0,%1\n    st %1,%0\"\n   [(set_attr \"type\" \"move,move,move4,move4,move4,multi,load,store\")])\n \n+; Try to use a four byte / two byte pair for constants not loadable with\n+; ldi, ld24, seth.\n+\n+(define_split\n+ [(set (match_operand:SI 0 \"register_operand\" \"\")\n+       (match_operand:SI 1 \"two_insn_const_operand\" \"\"))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ior:SI (match_dup 0) (match_dup 3)))]\n+  \"\n+{\n+  unsigned HOST_WIDE_INT val = INTVAL (operands[1]);\n+  unsigned HOST_WIDE_INT tmp;\n+  int shift;\n+\n+  /* In all cases we will emit two instructions.  However we try to\n+     use 2 byte instructions whereever possible.  We can assume the\n+     constant isn't loadable with any of ldi, ld24, or seth.  */\n+\n+  /* See if we can load a 24 bit unsigned value and invert it.  */\n+  if (UINT24_P (~ val))\n+    {\n+      emit_insn (gen_movsi (operands[0], GEN_INT (~ val)));\n+      emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));\n+      DONE;\n+    }\n+\n+  /* See if we can load a 24 bit unsigned value and shift it into place.\n+     0x01fffffe is just beyond ld24's range.  */\n+  for (shift = 1, tmp = 0x01fffffe;\n+       shift < 8;\n+       ++shift, tmp <<= 1)\n+    {\n+      if ((val & ~tmp) == 0)\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], GEN_INT (val >> shift)));\n+\t  emit_insn (gen_ashlsi3 (operands[0], operands[0], GEN_INT (shift)));\n+\t  DONE;\n+\t}\n+    }\n+\n+  /* Can't use any two byte insn, fall back to seth/or3.  */\n+  operands[2] = GEN_INT ((val) & 0xffff0000);\n+  operands[3] = GEN_INT ((val) & 0xffff);\n+}\")\n+\n ;; Small data area support.\n ;; The address of _SDA_BASE_ is loaded into a register and all objects in\n ;; the small data area are indexed off that.  This is done for each reference\n@@ -769,7 +817,7 @@\n   \"\"\n   \"@\n    and %0,%2\n-   and3 %0,%1,%#%2\"\n+   and3 %0,%1,%#%2 ; %X2\"\n   [(set_attr \"type\" \"binary\")])\n \n (define_insn \"iorsi3\"\n@@ -779,7 +827,7 @@\n   \"\"\n   \"@\n    or %0,%2\n-   or3 %0,%1,%#%2\"\n+   or3 %0,%1,%#%2 ; %X2\"\n   [(set_attr \"type\" \"binary\")])\n \n (define_insn \"xorsi3\"\n@@ -789,7 +837,7 @@\n   \"\"\n   \"@\n    xor %0,%2\n-   xor3 %0,%1,%#%2\"\n+   xor3 %0,%1,%#%2 ; %X2\"\n   [(set_attr \"type\" \"binary\")])\n \n (define_insn \"negsi2\""}]}