{"sha": "cbb436643a3975e41baf5f24bb12363df3b82cff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiNDM2NjQzYTM5NzVlNDFiYWY1ZjI0YmIxMjM2M2RmM2I4MmNmZg==", "commit": {"author": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2014-02-03T12:04:33Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2014-02-03T12:04:33Z"}, "message": "Actually add the test case from the previous commit.\n\nFrom-SVN: r207422", "tree": {"sha": "eec0708fe566b79551812b1159c18e68eab2d02e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec0708fe566b79551812b1159c18e68eab2d02e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb436643a3975e41baf5f24bb12363df3b82cff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb436643a3975e41baf5f24bb12363df3b82cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb436643a3975e41baf5f24bb12363df3b82cff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb436643a3975e41baf5f24bb12363df3b82cff/comments", "author": null, "committer": null, "parents": [{"sha": "861ec4f37e9e9a6a8e54ae7477b53a43271b7424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861ec4f37e9e9a6a8e54ae7477b53a43271b7424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861ec4f37e9e9a6a8e54ae7477b53a43271b7424"}], "stats": {"total": 339, "additions": 339, "deletions": 0}, "files": [{"sha": "1354790e976b04ba966aee6794a4fe1ecbf69431", "filename": "gcc/testsuite/g++.dg/pr57662.C", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb436643a3975e41baf5f24bb12363df3b82cff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57662.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb436643a3975e41baf5f24bb12363df3b82cff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57662.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57662.C?ref=cbb436643a3975e41baf5f24bb12363df3b82cff", "patch": "@@ -0,0 +1,339 @@\n+/* { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -fselective-scheduling2 -fsel-sched-pipelining\" } */\n+\n+extern \"C\" {\n+\ttypedef struct _IO_FILE FILE;\n+\textern int putc(int __c, FILE * __stream);\n+\textern int strcmp(__const char *__s1, __const char *__s2) throw()\n+\t    __attribute__ ((__pure__)) __attribute__ ((__nonnull__(1, 2)));\n+} typedef union tree_node *tree;\n+struct gcc_options {\n+\tint x_flag_openmp;\n+};\n+extern struct gcc_options global_options;\n+struct ht_identifier {\n+\tconst unsigned char *str;\n+};\n+enum cpp_ttype {\n+\tCPP_SEMICOLON, CPP_NAME\n+};\n+struct vl_embed {\n+};\n+struct va_heap {\n+};\n+struct va_gc {\n+\ttypedef vl_embed default_layout;\n+};\n+template < typename T, typename A = va_heap, typename L =\n+    typename A::default_layout > struct vec {\n+};\n+enum tree_code {\n+\tERROR_MARK,\n+\tIDENTIFIER_NODE,\n+\tOMP_SIMD,\n+\tCILK_SIMD,\n+\tMAX_TREE_CODES\n+};\n+struct tree_identifier {\n+\tstruct ht_identifier\n+\t id;\n+};\n+union tree_node {\n+\tstruct tree_identifier\n+\t identifier;\n+};\n+inline tree\n+tree_check(tree __t, const char *__f, int __l, const char *__g, tree_code __c)\n+{\n+}\n+\n+extern tree chainon(tree, tree);\n+extern vec < tree, va_gc > *make_tree_vector(void);\n+typedef unsigned long omp_clause_mask;\n+enum c_omp_clause_split {\n+\tC_OMP_CLAUSE_SPLIT_TARGET = 0, C_OMP_CLAUSE_SPLIT_COUNT\n+};\n+typedef struct cxx_saved_binding {\n+\ttree attributes;\n+} cp_decl_specifier_seq;\n+typedef enum pragma_kind {\n+\tPRAGMA_NONE = 0, PRAGMA_OMP_DECLARE_REDUCTION, PRAGMA_OMP_TARGET\n+} pragma_kind;\n+typedef enum pragma_omp_clause {\n+\tPRAGMA_OMP_CLAUSE_NONE =\n+\t    0, PRAGMA_OMP_CLAUSE_DEVICE, PRAGMA_OMP_CLAUSE_IF,\n+\t    PRAGMA_OMP_CLAUSE_MAP\n+} pragma_omp_clause;\n+typedef struct cp_token {\n+\tenum cpp_ttype type:8;\n+\tunion cp_token_value {\n+\t\ttree value;\n+\t} u;\n+} cp_token;\n+typedef struct cp_token *cp_token_position;\n+typedef struct cp_lexer {\n+\tcp_token_position next_token;\n+\tbool debugging_p;\n+\tcp_lexer *lexer;\n+} cp_parser;\n+static FILE *cp_lexer_debug_stream;\n+static inline bool cp_lexer_debugging_p(cp_lexer * lexer)\n+{\n+\treturn lexer->debugging_p;\n+}\n+\n+static inline cp_token *cp_lexer_peek_token(cp_lexer * lexer)\n+{\n+\tif (cp_lexer_debugging_p(lexer)) {\n+\t\tputc('\\n', cp_lexer_debug_stream);\n+\t}\n+\treturn lexer->next_token;\n+}\n+\n+static inline bool cp_lexer_next_token_is(cp_lexer * lexer, enum cpp_ttype type)\n+{\n+}\n+\n+enum {\n+\tCP_PARSER_FLAGS_NONE = 0x0, CP_PARSER_FLAGS_OPTIONAL =\n+\t    0x1, CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES =\n+\t    0x2, CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS =\n+\t    0x4, CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR = 0x8\n+};\n+typedef int cp_parser_flags;\n+extern tree\n+cp_parser_type_specifier(cp_parser *, cp_parser_flags,\n+\t\t\t cp_decl_specifier_seq *, bool, int *, bool *);\n+static void\n+cp_parser_type_specifier_seq(cp_parser *, bool, bool, cp_decl_specifier_seq *);\n+extern bool cp_next_tokens_can_be_attribute_p(cp_parser *);\n+extern tree cp_parser_attributes_opt(cp_parser *);\n+enum pragma_context {\n+\tpragma_external,\n+\tpragma_member,\n+\tpragma_objc_icode,\n+\tpragma_stmt,\n+\tpragma_compound\n+};\n+static bool cp_parser_pragma(cp_parser *, enum pragma_context);\n+static bool cp_parser_translation_unit(cp_parser * parser)\n+{\n+\twhile (true) {\n+\t\tcp_token *token;\n+\t\tif (token->type == CPP_SEMICOLON) {\n+\t\t\tcp_parser_pragma(parser, pragma_external);\n+\t\t}\n+\t}\n+}\n+\n+static tree\n+cp_parser_type_id_1(cp_parser * parser, bool is_template_arg,\n+\t\t    bool is_trailing_return)\n+{\n+\tcp_decl_specifier_seq type_specifier_seq;\n+\tcp_parser_type_specifier_seq(parser, false, is_trailing_return,\n+\t\t\t\t     &type_specifier_seq);\n+}\n+\n+static tree cp_parser_type_id(cp_parser * parser)\n+{\n+\treturn cp_parser_type_id_1(parser, false, false);\n+}\n+\n+static void\n+cp_parser_type_specifier_seq(cp_parser * parser, bool is_declaration,\n+\t\t\t     bool is_trailing_return,\n+\t\t\t     cp_decl_specifier_seq * type_specifier_seq)\n+{\n+\tcp_parser_flags flags = CP_PARSER_FLAGS_OPTIONAL;\n+\tcp_token *start_token = __null;\n+\twhile (true) {\n+\t\ttree type_specifier;\n+\t\tbool is_cv_qualifier;\n+\t\tif (cp_next_tokens_can_be_attribute_p(parser)) {\n+\t\t\ttype_specifier_seq->attributes =\n+\t\t\t    chainon(type_specifier_seq->attributes,\n+\t\t\t\t    cp_parser_attributes_opt(parser));\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (!start_token)\n+\t\t\tstart_token = cp_lexer_peek_token(parser->lexer);\n+\t\ttype_specifier =\n+\t\t    cp_parser_type_specifier(parser, flags, type_specifier_seq,\n+\t\t\t\t\t     false, __null, &is_cv_qualifier);\n+\t\tif (!type_specifier) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (is_declaration && !is_cv_qualifier)\n+\t\t\tflags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n+\t}\n+}\n+\n+static bool\n+cp_parser_omp_for_loop_init(cp_parser * parser, bool parsing_openmp,\n+\t\t\t    tree & this_pre_body, vec < tree,\n+\t\t\t    va_gc > *for_block, tree & init, tree & decl,\n+\t\t\t    tree & real_decl)\n+{\n+\tcp_decl_specifier_seq type_specifiers;\n+\tcp_parser_type_specifier_seq(parser, true, false, &type_specifiers);\n+}\n+\n+static tree\n+cp_parser_omp_for_loop(cp_parser * parser, enum tree_code code, tree clauses,\n+\t\t       tree * cclauses)\n+{\n+\ttree init, cond, incr, body, decl, pre_body = (tree) __null, ret;\n+\ttree real_decl, initv, condv, incrv, declv;\n+\ttree this_pre_body, cl;\n+\tint i, collapse = 1, nbraces = 0;\n+\tvec < tree, va_gc > *for_block = make_tree_vector();\n+\tfor (i = 0; i < collapse; i++) {\n+\t\tbool add_private_clause = false;\n+\t\tadd_private_clause |=\n+\t\t    cp_parser_omp_for_loop_init(parser, code != CILK_SIMD,\n+\t\t\t\t\t\tthis_pre_body, for_block, init,\n+\t\t\t\t\t\tdecl, real_decl);\n+\t}\n+}\n+\n+static tree\n+cp_parser_omp_simd(cp_parser * parser, cp_token * pragma_tok, char *p_name,\n+\t\t   omp_clause_mask mask, tree * cclauses)\n+{\n+\ttree clauses, sb, ret;\n+\tret = cp_parser_omp_for_loop(parser, OMP_SIMD, clauses, cclauses);\n+}\n+\n+static tree\n+cp_parser_omp_distribute(cp_parser * parser, cp_token * pragma_tok,\n+\t\t\t char *p_name, omp_clause_mask mask, tree * cclauses)\n+{\n+\tif (cp_lexer_next_token_is(parser->lexer, CPP_NAME)) {\n+\t\ttree id = cp_lexer_peek_token(parser->lexer)->u.value;\n+\t\tconst char *p =\n+\t\t    ((const char\n+\t\t      *)(tree_check((id),\n+\t\t\t\t    \"/home/bonzo/develop/trunk/gcc/cp/parser.c\",\n+\t\t\t\t    29966, __FUNCTION__,\n+\t\t\t\t    (IDENTIFIER_NODE)))->identifier.id.str);\n+\t\tbool simd = false;\n+\t\tbool parallel = false;\n+\t\tif (strcmp(p, \"simd\") == 0)\n+\t\t\tsimd = true;\n+\t\tif (parallel || simd) {\n+\t\t\tif (!global_options.x_flag_openmp) {\n+\t\t\t\tif (simd)\n+\t\t\t\t\treturn cp_parser_omp_simd(parser,\n+\t\t\t\t\t\t\t\t  pragma_tok,\n+\t\t\t\t\t\t\t\t  p_name, mask,\n+\t\t\t\t\t\t\t\t  cclauses);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+static tree\n+cp_parser_omp_teams(cp_parser * parser, cp_token * pragma_tok, char *p_name,\n+\t\t    omp_clause_mask mask, tree * cclauses)\n+{\n+\tif (cp_lexer_next_token_is(parser->lexer, CPP_NAME)) {\n+\t\ttree id = cp_lexer_peek_token(parser->lexer)->u.value;\n+\t\tconst char *p =\n+\t\t    ((const char\n+\t\t      *)(tree_check((id),\n+\t\t\t\t    \"/home/bonzo/develop/trunk/gcc/cp/parser.c\",\n+\t\t\t\t    30062, __FUNCTION__,\n+\t\t\t\t    (IDENTIFIER_NODE)))->identifier.id.str);\n+\t\tif (strcmp(p, \"distribute\") == 0) {\n+\t\t\tif (!global_options.x_flag_openmp)\n+\t\t\t\treturn cp_parser_omp_distribute(parser,\n+\t\t\t\t\t\t\t\tpragma_tok,\n+\t\t\t\t\t\t\t\tp_name, mask,\n+\t\t\t\t\t\t\t\tcclauses);\n+\t\t}\n+\t}\n+}\n+\n+static bool\n+cp_parser_omp_target(cp_parser * parser, cp_token * pragma_tok,\n+\t\t     enum pragma_context context)\n+{\n+\tif (context != pragma_stmt && context != pragma_compound) {\n+\t\ttree id = cp_lexer_peek_token(parser->lexer)->u.value;\n+\t\tconst char *p =\n+\t\t    ((const char\n+\t\t      *)(tree_check((id),\n+\t\t\t\t    \"/home/bonzo/develop/trunk/gcc/cp/parser.c\",\n+\t\t\t\t    30201, __FUNCTION__,\n+\t\t\t\t    (IDENTIFIER_NODE)))->identifier.id.str);\n+\t\tif (strcmp(p, \"teams\") == 0) {\n+\t\t\ttree cclauses[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t\t\tchar p_name[sizeof\n+\t\t\t\t    (\"#pragma omp target teams distribute \"\n+\t\t\t\t     \"parallel for simd\")];\n+\t\t\tif (!global_options.x_flag_openmp)\n+\t\t\t\treturn cp_parser_omp_teams(parser, pragma_tok,\n+\t\t\t\t\t\t\t   p_name,\n+\t\t\t\t\t\t\t   ((((omp_clause_mask)\n+\t\t\t\t\t\t\t      1) <<\n+\t\t\t\t\t\t\t     PRAGMA_OMP_CLAUSE_DEVICE)\n+\t\t\t\t\t\t\t    |\n+\t\t\t\t\t\t\t    (((omp_clause_mask)\n+\t\t\t\t\t\t\t      1) <<\n+\t\t\t\t\t\t\t     PRAGMA_OMP_CLAUSE_MAP)\n+\t\t\t\t\t\t\t    |\n+\t\t\t\t\t\t\t    (((omp_clause_mask)\n+\t\t\t\t\t\t\t      1) <<\n+\t\t\t\t\t\t\t     PRAGMA_OMP_CLAUSE_IF)),\n+\t\t\t\t\t\t\t   cclauses);\n+\t\t}\n+\t}\n+}\n+\n+static void\n+cp_parser_omp_declare_reduction(cp_parser * parser, cp_token * pragma_tok,\n+\t\t\t\tenum pragma_context)\n+{\n+\ttree reduc_id = (tree) __null, orig_reduc_id = (tree) __null, type;\n+\twhile (true) {\n+\t\ttype = cp_parser_type_id(parser);\n+\t}\n+}\n+\n+static void\n+cp_parser_omp_declare(cp_parser * parser, cp_token * pragma_tok,\n+\t\t      enum pragma_context context)\n+{\n+\tif (cp_lexer_next_token_is(parser->lexer, CPP_NAME)) {\n+\t\ttree id = cp_lexer_peek_token(parser->lexer)->u.value;\n+\t\tconst char *p =\n+\t\t    ((const char\n+\t\t      *)(tree_check((id),\n+\t\t\t\t    \"/home/bonzo/develop/trunk/gcc/cp/parser.c\",\n+\t\t\t\t    30883, __FUNCTION__,\n+\t\t\t\t    (IDENTIFIER_NODE)))->identifier.id.str);\n+\t\tif (strcmp(p, \"simd\") == 0) {\n+\t\t\tcp_parser_omp_declare_reduction(parser, pragma_tok,\n+\t\t\t\t\t\t\tcontext);\n+\t\t}\n+\t}\n+}\n+\n+static cp_parser *the_parser;\n+static bool cp_parser_pragma(cp_parser * parser, enum pragma_context context)\n+{\n+\tcp_token *pragma_tok;\n+\tunsigned int id;\n+\tswitch (id) {\n+\tcase PRAGMA_OMP_DECLARE_REDUCTION:\n+\t\tcp_parser_omp_declare(parser, pragma_tok, context);\n+\tcase PRAGMA_OMP_TARGET:\n+\t\treturn cp_parser_omp_target(parser, pragma_tok, context);\n+\t}\n+}\n+\n+void c_parse_file(void)\n+{\n+\tcp_parser_translation_unit(the_parser);\n+}"}]}