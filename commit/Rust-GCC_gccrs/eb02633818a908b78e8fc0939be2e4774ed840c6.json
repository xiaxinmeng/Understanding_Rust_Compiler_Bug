{"sha": "eb02633818a908b78e8fc0939be2e4774ed840c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIwMjYzMzgxOGE5MDhiNzhlOGZjMDkzOWJlMmU0Nzc0ZWQ4NDBjNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-09-25T02:26:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-09-25T02:26:01Z"}, "message": "Handle deferred parsing of NSDMIs.\n\n\t* parser.h (cp_unparsed_functions_entry): Add nsdmis field.\n\t* parser.c (unparsed_nsdmis, cp_parser_save_nsdmi): New.\n\t(cp_parser_late_parse_one_default_arg): Split out from\n\tcp_parser_late_parsing_default_args.\n\t(cp_parser_late_parsing_nsdmi): New.\n\t(push_unparsed_function_queues): Set it.\n\t(cp_parser_parameter_declaration): Save the '=' token.\n\t(cp_parser_template_parameter): Likewise.\n\t(cp_parser_default_argument): Call cp_parser_initializer\n\trather than cp_parser_initializer_clause.\n\t(cp_parser_class_specifier_1): Parse unparsed_nsdmis.\n\t(cp_parser_member_declaration): Handle nsdmis.\n\t* decl2.c (grokfield): Handle DEFAULT_ARG for a function.\n\nFrom-SVN: r179156", "tree": {"sha": "4ed25f3377c184a6d3a1db8397675121388b3ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ed25f3377c184a6d3a1db8397675121388b3ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb02633818a908b78e8fc0939be2e4774ed840c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb02633818a908b78e8fc0939be2e4774ed840c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb02633818a908b78e8fc0939be2e4774ed840c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb02633818a908b78e8fc0939be2e4774ed840c6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e5f8a598de1c8dc44fb59c6d0ea0dcd557f695a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5f8a598de1c8dc44fb59c6d0ea0dcd557f695a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5f8a598de1c8dc44fb59c6d0ea0dcd557f695a"}], "stats": {"total": 271, "additions": 213, "deletions": 58}, "files": [{"sha": "f1496b63d8950de24496571992d8ba90ed5112d8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -1,5 +1,20 @@\n 2011-09-24  Jason Merrill  <jason@redhat.com>\n \n+\tHandle deferred parsing of NSDMIs.\n+\t* parser.h (cp_unparsed_functions_entry): Add nsdmis field.\n+\t* parser.c (unparsed_nsdmis, cp_parser_save_nsdmi): New.\n+\t(cp_parser_late_parse_one_default_arg): Split out from\n+\tcp_parser_late_parsing_default_args.\n+\t(cp_parser_late_parsing_nsdmi): New.\n+\t(push_unparsed_function_queues): Set it.\n+\t(cp_parser_parameter_declaration): Save the '=' token.\n+\t(cp_parser_template_parameter): Likewise.\n+\t(cp_parser_default_argument): Call cp_parser_initializer\n+\trather than cp_parser_initializer_clause.\n+\t(cp_parser_class_specifier_1): Parse unparsed_nsdmis.\n+\t(cp_parser_member_declaration): Handle nsdmis.\n+\t* decl2.c (grokfield): Handle DEFAULT_ARG for a function.\n+\n \tImplement C++11 non-static data member initializers.\n \t* cp-tree.h (enum cpp_warn_str): Add CPP0X_NSDMI.\n \t* error.c (maybe_warn_cpp0x): Handle it."}, {"sha": "45bf6a121a39d242752401a5ec5c1485f69b6963", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -6077,7 +6077,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n   /* Just store non-static data member initializers for later.  */\n   if (init && TREE_CODE (decl) == FIELD_DECL)\n-    DECL_INITIAL (decl) = digest_init_flags (TREE_TYPE (decl), init, flags);\n+    DECL_INITIAL (decl) = init;\n \n   /* Take care of TYPE_DECLs up front.  */\n   if (TREE_CODE (decl) == TYPE_DECL)"}, {"sha": "6e5f7cc7d7519f03bb032d6f8487ed0580e6a73b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -902,6 +902,8 @@ grokfield (const cp_declarator *declarator,\n \t\t  DECL_DECLARED_INLINE_P (value) = 1;\n \t\t}\n \t    }\n+\t  else if (TREE_CODE (init) == DEFAULT_ARG)\n+\t    error (\"invalid initializer for member function %qD\", value);\n \t  else if (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE)\n \t    {\n \t      if (integer_zerop (init))"}, {"sha": "2dbe86613c4b9e80d570b8e94bc8897cb8d31a74", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 152, "deletions": 44, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -1486,6 +1486,8 @@ cp_parser_context_new (cp_parser_context* next)\n   VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues)->funs_with_default_args\n #define unparsed_funs_with_definitions \\\n   VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues)->funs_with_definitions\n+#define unparsed_nsdmis \\\n+  VEC_last (cp_unparsed_functions_entry, parser->unparsed_queues)->nsdmis\n \n static void\n push_unparsed_function_queues (cp_parser *parser)\n@@ -1494,6 +1496,7 @@ push_unparsed_function_queues (cp_parser *parser)\n \t\t parser->unparsed_queues, NULL);\n   unparsed_funs_with_default_args = NULL;\n   unparsed_funs_with_definitions = make_tree_vector ();\n+  unparsed_nsdmis = NULL;\n }\n \n static void\n@@ -1936,12 +1939,18 @@ static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n   (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree);\n+static tree cp_parser_save_nsdmi\n+  (cp_parser *);\n static tree cp_parser_enclosed_template_argument_list\n   (cp_parser *);\n static void cp_parser_save_default_args\n   (cp_parser *, tree);\n static void cp_parser_late_parsing_for_member\n   (cp_parser *, tree);\n+static tree cp_parser_late_parse_one_default_arg\n+  (cp_parser *, tree, tree, tree);\n+static void cp_parser_late_parsing_nsdmi\n+  (cp_parser *, tree);\n static void cp_parser_late_parsing_default_args\n   (cp_parser *, tree);\n static tree cp_parser_sizeof_operand\n@@ -11343,9 +11352,7 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \t user may try to do so, so we'll parse them and give an\n \t appropriate diagnostic here.  */\n \n-      /* Consume the `='.  */\n       cp_token *start_token = cp_lexer_peek_token (parser->lexer);\n-      cp_lexer_consume_token (parser->lexer);\n       \n       /* Find the name of the parameter pack.  */     \n       id_declarator = parameter_declarator->declarator;\n@@ -16323,9 +16330,6 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   /* If the next token is `=', then process a default argument.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n     {\n-      /* Consume the `='.  */\n-      cp_lexer_consume_token (parser->lexer);\n-\n       /* If we are defining a class, then the tokens that make up the\n \t default argument must be saved and processed later.  */\n       if (!template_parm_p && at_class_scope_p ()\n@@ -16535,7 +16539,7 @@ cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n   tree default_argument = NULL_TREE;\n   bool saved_greater_than_is_operator_p;\n   bool saved_local_variables_forbidden_p;\n-  bool non_constant_p;\n+  bool non_constant_p, is_direct_init;\n \n   /* Make sure that PARSER->GREATER_THAN_IS_OPERATOR_P is\n      set correctly.  */\n@@ -16549,7 +16553,7 @@ cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n   if (template_parm_p)\n     push_deferring_access_checks (dk_no_deferred);\n   default_argument\n-    = cp_parser_initializer_clause (parser, &non_constant_p);\n+    = cp_parser_initializer (parser, &is_direct_init, &non_constant_p);\n   if (BRACE_ENCLOSED_INITIALIZER_P (default_argument))\n     maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n   if (template_parm_p)\n@@ -17265,7 +17269,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n      there is no need to delay the parsing of `A::B::f'.  */\n   if (--parser->num_classes_being_defined == 0)\n     {\n-      tree fn;\n+      tree decl;\n       tree class_type = NULL_TREE;\n       tree pushed_scope = NULL_TREE;\n       unsigned ix;\n@@ -17284,7 +17288,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n       FOR_EACH_VEC_ELT (cp_default_arg_entry, unparsed_funs_with_default_args,\n \t\t\tix, e)\n \t{\n-\t  fn = e->decl;\n+\t  decl = e->decl;\n \t  /* If there are default arguments that have not yet been processed,\n \t     take care of them now.  */\n \t  if (class_type != e->class_type)\n@@ -17295,18 +17299,31 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t      pushed_scope = push_scope (class_type);\n \t    }\n \t  /* Make sure that any template parameters are in scope.  */\n-\t  maybe_begin_member_template_processing (fn);\n+\t  maybe_begin_member_template_processing (decl);\n \t  /* Parse the default argument expressions.  */\n-\t  cp_parser_late_parsing_default_args (parser, fn);\n+\t  cp_parser_late_parsing_default_args (parser, decl);\n \t  /* Remove any template parameters from the symbol table.  */\n \t  maybe_end_member_template_processing ();\n \t}\n+      VEC_truncate (cp_default_arg_entry, unparsed_funs_with_default_args, 0);\n+      /* Now parse any NSDMIs.  */\n+      FOR_EACH_VEC_ELT (tree, unparsed_nsdmis, ix, decl)\n+\t{\n+\t  if (class_type != DECL_CONTEXT (decl))\n+\t    {\n+\t      if (pushed_scope)\n+\t\tpop_scope (pushed_scope);\n+\t      class_type = DECL_CONTEXT (decl);\n+\t      pushed_scope = push_scope (class_type);\n+\t    }\n+\t  cp_parser_late_parsing_nsdmi (parser, decl);\n+\t}\n+      VEC_truncate (tree, unparsed_nsdmis, 0);\n       if (pushed_scope)\n \tpop_scope (pushed_scope);\n-      VEC_truncate (cp_default_arg_entry, unparsed_funs_with_default_args, 0);\n       /* Now parse the body of the functions.  */\n-      FOR_EACH_VEC_ELT (tree, unparsed_funs_with_definitions, ix, fn)\n-\tcp_parser_late_parsing_for_member (parser, fn);\n+      FOR_EACH_VEC_ELT (tree, unparsed_funs_with_definitions, ix, decl)\n+\tcp_parser_late_parsing_for_member (parser, decl);\n       VEC_truncate (tree, unparsed_funs_with_definitions, 0);\n     }\n \n@@ -18185,8 +18202,14 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t     constant-initializer.  When we call `grokfield', it will\n \t\t     perform more stringent semantics checks.  */\n \t\t  initializer_token_start = cp_lexer_peek_token (parser->lexer);\n-\t\t  if (function_declarator_p (declarator))\n+\t\t  if (function_declarator_p (declarator)\n+\t\t      || (decl_specifiers.type\n+\t\t\t  && TREE_CODE (decl_specifiers.type) == TYPE_DECL\n+\t\t\t  && (TREE_CODE (TREE_TYPE (decl_specifiers.type))\n+\t\t\t      == FUNCTION_TYPE)))\n \t\t    initializer = cp_parser_pure_specifier (parser);\n+\t\t  else if (decl_specifiers.storage_class != sc_static)\n+\t\t    initializer = cp_parser_save_nsdmi (parser);\n \t\t  else if (cxx_dialect >= cxx0x)\n \t\t    {\n \t\t      bool nonconst;\n@@ -18206,7 +18229,10 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t       && !function_declarator_p (declarator))\n \t\t{\n \t\t  bool x;\n-\t\t  initializer = cp_parser_initializer (parser, &x, &x);\n+\t\t  if (decl_specifiers.storage_class != sc_static)\n+\t\t    initializer = cp_parser_save_nsdmi (parser);\n+\t\t  else\n+\t\t    initializer = cp_parser_initializer (parser, &x, &x);\n \t\t}\n \t      /* Otherwise, there is no initializer.  */\n \t      else\n@@ -18292,6 +18318,11 @@ cp_parser_member_declaration (cp_parser* parser)\n \n \t      if (TREE_CODE (decl) == FUNCTION_DECL)\n \t\tcp_parser_save_default_args (parser, decl);\n+\t      else if (TREE_CODE (decl) == FIELD_DECL\n+\t\t       && !DECL_C_BIT_FIELD (decl)\n+\t\t       && DECL_INITIAL (decl))\n+\t\t/* Add DECL to the queue of NSDMI to be parsed later.  */\n+\t\tVEC_safe_push (tree, gc, unparsed_nsdmis, decl);\n \t    }\n \n \t  if (assume_semicolon)\n@@ -20539,6 +20570,30 @@ cp_parser_save_member_function_body (cp_parser* parser,\n   return fn;\n }\n \n+/* Save the tokens that make up the in-class initializer for a non-static\n+   data member.  Returns a DEFAULT_ARG.  */\n+\n+static tree\n+cp_parser_save_nsdmi (cp_parser* parser)\n+{\n+  /* Save away the tokens that make up the body of the\n+     function.  */\n+  cp_token *first = parser->lexer->next_token;\n+  cp_token *last;\n+  tree node;\n+\n+  cp_parser_cache_group (parser, CPP_CLOSE_PAREN, /*depth=*/0);\n+\n+  last = parser->lexer->next_token;\n+\n+  node = make_node (DEFAULT_ARG);\n+  DEFARG_TOKENS (node) = cp_token_cache_new (first, last);\n+  DEFARG_INSTANTIATIONS (node) = NULL;\n+\n+  return node;\n+}\n+\n+\n /* Parse a template-argument-list, as well as the trailing \">\" (but\n    not the opening \">\").  See cp_parser_template_argument_list for the\n    return value.  */\n@@ -20744,6 +20799,83 @@ cp_parser_save_default_args (cp_parser* parser, tree decl)\n       }\n }\n \n+/* DEFAULT_ARG contains the saved tokens for the initializer of DECL,\n+   which is either a FIELD_DECL or PARM_DECL.  Parse it and return\n+   the result.  For a PARM_DECL, PARMTYPE is the corresponding type\n+   from the parameter-type-list.  */\n+\n+static tree\n+cp_parser_late_parse_one_default_arg (cp_parser *parser, tree decl,\n+\t\t\t\t      tree default_arg, tree parmtype)\n+{\n+  cp_token_cache *tokens;\n+  tree parsed_arg;\n+  bool dummy;\n+\n+  /* Push the saved tokens for the default argument onto the parser's\n+     lexer stack.  */\n+  tokens = DEFARG_TOKENS (default_arg);\n+  cp_parser_push_lexer_for_tokens (parser, tokens);\n+\n+  start_lambda_scope (decl);\n+\n+  /* Parse the default argument.  */\n+  parsed_arg = cp_parser_initializer (parser, &dummy, &dummy);\n+  if (BRACE_ENCLOSED_INITIALIZER_P (parsed_arg))\n+    maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n+\n+  finish_lambda_scope ();\n+\n+  if (!processing_template_decl)\n+    {\n+      /* In a non-template class, check conversions now.  In a template,\n+\t we'll wait and instantiate these as needed.  */\n+      if (TREE_CODE (decl) == PARM_DECL)\n+\tparsed_arg = check_default_argument (parmtype, parsed_arg);\n+      else\n+\t{\n+\t  int flags = LOOKUP_IMPLICIT;\n+\t  if (BRACE_ENCLOSED_INITIALIZER_P (parsed_arg)\n+\t      && CONSTRUCTOR_IS_DIRECT_INIT (parsed_arg))\n+\t    flags = LOOKUP_NORMAL;\n+\t  parsed_arg = digest_init_flags (TREE_TYPE (decl), parsed_arg, flags);\n+\t}\n+    }\n+\n+  /* If the token stream has not been completely used up, then\n+     there was extra junk after the end of the default\n+     argument.  */\n+  if (!cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+    {\n+      if (TREE_CODE (decl) == PARM_DECL)\n+\tcp_parser_error (parser, \"expected %<,%>\");\n+      else\n+\tcp_parser_error (parser, \"expected %<;%>\");\n+    }\n+\n+  /* Revert to the main lexer.  */\n+  cp_parser_pop_lexer (parser);\n+\n+  return parsed_arg;\n+}\n+\n+/* FIELD is a non-static data member with an initializer which we saved for\n+   later; parse it now.  */\n+\n+static void\n+cp_parser_late_parsing_nsdmi (cp_parser *parser, tree field)\n+{\n+  tree def;\n+\n+  push_unparsed_function_queues (parser);\n+  def = cp_parser_late_parse_one_default_arg (parser, field,\n+\t\t\t\t\t      DECL_INITIAL (field),\n+\t\t\t\t\t      NULL_TREE);\n+  pop_unparsed_function_queues (parser);\n+\n+  DECL_INITIAL (field) = def;\n+}\n+\n /* FN is a FUNCTION_DECL which may contains a parameter with an\n    unparsed DEFAULT_ARG.  Parse the default args now.  This function\n    assumes that the current scope is the scope in which the default\n@@ -20753,7 +20885,6 @@ static void\n cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n {\n   bool saved_local_variables_forbidden_p;\n-  bool non_constant_p;\n   tree parm, parmdecl;\n \n   /* While we're parsing the default args, we might (due to the\n@@ -20775,7 +20906,6 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n        parm = TREE_CHAIN (parm),\n \t parmdecl = DECL_CHAIN (parmdecl))\n     {\n-      cp_token_cache *tokens;\n       tree default_arg = TREE_PURPOSE (parm);\n       tree parsed_arg;\n       VEC(tree,gc) *insts;\n@@ -20790,43 +20920,21 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \t   already declared with default arguments.  */\n \tcontinue;\n \n-       /* Push the saved tokens for the default argument onto the parser's\n-\t  lexer stack.  */\n-      tokens = DEFARG_TOKENS (default_arg);\n-      cp_parser_push_lexer_for_tokens (parser, tokens);\n-\n-      start_lambda_scope (parmdecl);\n-\n-      /* Parse the assignment-expression.  */\n-      parsed_arg = cp_parser_initializer_clause (parser, &non_constant_p);\n+      parsed_arg\n+\t= cp_parser_late_parse_one_default_arg (parser, parmdecl,\n+\t\t\t\t\t\tdefault_arg,\n+\t\t\t\t\t\tTREE_VALUE (parm));\n       if (parsed_arg == error_mark_node)\n \t{\n-\t  cp_parser_pop_lexer (parser);\n \t  continue;\n \t}\n-      if (BRACE_ENCLOSED_INITIALIZER_P (parsed_arg))\n-\tmaybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n-\n-      if (!processing_template_decl)\n-\tparsed_arg = check_default_argument (TREE_VALUE (parm), parsed_arg);\n \n       TREE_PURPOSE (parm) = parsed_arg;\n \n       /* Update any instantiations we've already created.  */\n       for (insts = DEFARG_INSTANTIATIONS (default_arg), ix = 0;\n \t   VEC_iterate (tree, insts, ix, copy); ix++)\n \tTREE_PURPOSE (copy) = parsed_arg;\n-\n-      finish_lambda_scope ();\n-\n-      /* If the token stream has not been completely used up, then\n-\t there was extra junk after the end of the default\n-\t argument.  */\n-      if (!cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n-\tcp_parser_error (parser, \"expected %<,%>\");\n-\n-      /* Revert to the main lexer.  */\n-      cp_parser_pop_lexer (parser);\n     }\n \n   pop_defarg_context ();"}, {"sha": "e08c0b415a08ef2c13da4f3ec952058850575399", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -169,6 +169,10 @@ typedef struct GTY(()) cp_unparsed_functions_entry_d {\n   /* Functions with defintions that require post-processing.  Functions\n      appear in this list in declaration order.  */\n   VEC(tree,gc) *funs_with_definitions;\n+\n+  /* Non-static data members with initializers that require post-processing.\n+     FIELD_DECLs appear in this list in declaration order.  */\n+  VEC(tree,gc) *nsdmis;\n } cp_unparsed_functions_entry;\n \n DEF_VEC_O(cp_unparsed_functions_entry);"}, {"sha": "1e516695aa6a4472c47d839867b05df94de9ef34", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -1,5 +1,8 @@\n 2011-09-24  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/cpp0x/nsdmi-defer1.C: New.\n+\t* g++.dg/cpp0x/nsdmi-defer2.C: New.\n+\n \t* g++.dg/cpp0x/nsdmi1.C: New.\n \t* g++.dg/cpp0x/nsdmi2.C: New.\n \t* g++.dg/cpp0x/nsdmi3.C: New."}, {"sha": "b3d9b9357502552a10bd0eb535bfa2ee1f95fed1", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-defer1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer1.C?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -std=c++0x }\n+\n+#define SA(X) static_assert(X,#X)\n+\n+struct A\n+{\n+  int i = f();\n+  int j { f() };\n+  static constexpr int f() { return 42; }\n+};\n+\n+constexpr A a;\n+SA(a.i == 42);\n+SA(a.j == 42);"}, {"sha": "1951262f9dae1f7731accb3ac8575e8e69afa954", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-defer2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer2.C?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  int i = f();\n+  static int f(int i = 42) { return i; }\n+};\n+\n+A a;"}, {"sha": "e1494106bb091bedd469733b888a64c86f5df100", "filename": "gcc/testsuite/g++.dg/other/pr39060.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr39060.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr39060.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr39060.C?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -3,17 +3,17 @@\n \n struct A\n {\n-  A(void* i=);\t// { dg-error \"with|specification\" }\n-  A(void* i=);\t// { dg-error \"overloaded\" }\n-  A(void* i=);\t// { dg-error \"overloaded\" }\n+  A(void* i=);\t// { dg-error \"with|specification|primary-expression\" }\n+  A(void* i=);\t// { dg-error \"overloaded|primary-expression\" }\n+  A(void* i=);\t// { dg-error \"overloaded|primary-expression\" }\n \n   void operator+ (void* i=);\t// { dg-error \"arguments\" }\n \n-  virtual void foo1(=);\t// { dg-error \"identifier\" }\n-  void foo2(=);\t\t// { dg-error \"identifier\" }\n-  void foo3(=);\t\t// { dg-error \"identifier\" }\n-  void foo4(=);\t\t// { dg-error \"identifier\" }\n-  void foo5(=);\t\t// { dg-error \"identifier\" }\n-};\t// { dg-error \"primary-expression\" }\n+  virtual void foo1(=);\t// { dg-error \"identifier|primary-expression\" }\n+  void foo2(=);\t\t// { dg-error \"identifier|primary-expression\" }\n+  void foo3(=);\t\t// { dg-error \"identifier|primary-expression\" }\n+  void foo4(=);\t\t// { dg-error \"identifier|primary-expression\" }\n+  void foo5(=);\t\t// { dg-error \"identifier|primary-expression\" }\n+};\n \n A::A (void* i=) {}\t// { dg-error \"primary-expression|argument\" }"}, {"sha": "2b823aed4025a5d66ff35caddb5b5d5381195267", "filename": "gcc/testsuite/g++.dg/parse/crash56.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash56.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb02633818a908b78e8fc0939be2e4774ed840c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash56.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash56.C?ref=eb02633818a908b78e8fc0939be2e4774ed840c6", "patch": "@@ -5,13 +5,13 @@\n struct A\n {\n   typedef void (F)();\n-  F f = []{}; /* { dg-error \"invalid initializer\" } */\n+  F f = []{}; /* { dg-error \"invalid pure\" } */\n };\n \n struct B\n {\n   typedef void (F)();\n-  F f = 1; /* { dg-error \"invalid initializer\" } */\n-  virtual F f2 = 2; /* { dg-error \"invalid initializer\" } */\n-  F f3 = 3; /* { dg-error \"invalid initializer\" } */\n+  F f = 1; /* { dg-error \"invalid pure\" } */\n+  virtual F f2 = 2; /* { dg-error \"invalid pure\" } */\n+  F f3 = 3; /* { dg-error \"invalid pure\" } */\n };"}]}