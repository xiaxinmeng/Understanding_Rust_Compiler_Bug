{"sha": "f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhhYmM5YmEyZDE1YWM3ZWUwNmNlOWMxMzU3MzIyNzYyMDNlY2UxZA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2015-02-03T09:26:46Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2015-02-03T09:26:46Z"}, "message": "PR preprocessor/64803 - __LINE__ inside macro is not constant\n\nConsider the example code mentionned in this PR:\n\n $ cat -n test.c\n      1\t#define C(a, b) a ## b\n      2\t#define L(x) C(L, x)\n      3\t#define M(a) goto L(__LINE__); __LINE__; L(__LINE__):\n      4\tM(a /* --> this is the line of the expansion point of M.  */\n      5\t  ); /* --> this is the line of the end of the invocation of M.  */\n $\n\n\"cc1 -quiet -E test.c\" yields:\n\n goto L5; 5; L4:\n    ;\n\nNotice how we have a 'L4' there, where it should be L5.  That is the issue.\n\nMy understanding is that during the *second* expansion of __LINE__\n(the one between the two L(__LINE__)), builtin_macro() is called by\nenter_macro_context() with the location of the expansion point of M\n(which is at line 4).  Then _cpp_builtin_macro_text() expands __LINE__\ninto the line number of the location of the last token that has been\nlexed, which is the location of the closing parenthesis of the\ninvocation of M, at line 5.  So that invocation of __LINE__ is\nexpanded into 5.\n\nNow let's see why the last invocation of __LINE__ is expanded into 4.\n\nIn builtin_macro(), we have this code at some point:\n\n   /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n   pfile->cur_token = _cpp_temp_token (pfile);\n   cpp_token *token = _cpp_lex_direct (pfile);\n   /* We should point to the expansion point of the builtin macro.  */\n   token->src_loc = loc;\n\nThe first two statements insert a new token in the stream of lexed\ntoken and pfile->cur_token[-1], is the \"new\" last token that has been\nlexed.  But the location of pfile->cur_token[-1] is the same location\nas the location of the \"previous\" pfile->cur_token[-1], by courtesy of\n_cpp_temp_token().  So normally, in subsequent invocations of\nbuiltin_macro(), the location of pfile->cur_token[-1] should always be\nthe location of the closing parenthesis of the invocation of M at line\n5.  Except that that code in master now has the statement\n\"token->src_loc = loc;\" on the next line.  That statement actually\nsets the location of pfile->cur_token[-1] to 'loc'.  Which is the\nlocation of the expansion point of M, which is on line 4.\n\nSo in the subsequent call to builtin_macro() (for the last expansion\nof __LINE__ in L(__LINE__)), for _cpp_builtin_macro_text(),\npfile->cur_token[-1].src_loc is going to have a line number of 4.\n\nI think the core issue here is that the location that is passed to\nbuiltin_macro() from enter_macro_context() is not correct when we are\nin presence of a top-most function-like macro invocation; in that\ncase, that location should be the location of the closing parenthesis\nof the macro invocation.  Otherwise, if we are in presence of a a\ntop-most object-like macro invocation then the location passed down\nto builtin_macro should be the location of the expansion point of the\nmacro.\n\nThat way, in the particular case of the input code above, the location\nreceived by builtin_macro() will always have line number 5.\n\nBoostrapped and tested on x86_64-unknown-linux-gnu against trunk.\n\nlibcpp/ChangeLog:\n\n\t* internal.h (cpp_reader::top_most_macro_node): New data member.\n\t* macro.c (enter_macro_context): Pass the location of the end of\n\tthe top-most invocation of the function-like macro, or the\n\tlocation of the expansion point of the top-most object-like macro.\n\t(cpp_get_token_1): Store the top-most macro node in the new\n\tpfile->top_most_macro_node data member.\n\t(_cpp_pop_context): Clear the new cpp_reader::top_most_macro_node\n\tdata member.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/cpp/builtin-macro-1.c: New test case.\n\nSigned-off-by: Dodji Seketeli <dodji@redhat.com>\n\nFrom-SVN: r220367", "tree": {"sha": "47cefdc794e9091bc26d4d8495566ec527535ffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47cefdc794e9091bc26d4d8495566ec527535ffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/comments", "author": null, "committer": null, "parents": [{"sha": "18fbd1ecf1440151236c388933b1541784f4f8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fbd1ecf1440151236c388933b1541784f4f8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fbd1ecf1440151236c388933b1541784f4f8c2"}], "stats": {"total": 81, "additions": 78, "deletions": 3}, "files": [{"sha": "c85fa087d60fa7d7e588e8f3315e0e2dc3720dcb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "patch": "@@ -1,3 +1,8 @@\n+2015-02-03    <dodji@redhat.com>\n+\n+\tPR preprocessor/64803\n+\t* gcc.dg/cpp/builtin-macro-1.c: New test case.\n+\n 2015-02-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/ipa/devirt-37.C: Disable early inlining."}, {"sha": "90c2883b4711aba63d5a23704f11a8b7669fbd25", "filename": "gcc/testsuite/gcc.dg/cpp/builtin-macro-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fbuiltin-macro-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fbuiltin-macro-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fbuiltin-macro-1.c?ref=f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "patch": "@@ -0,0 +1,28 @@\n+/* Origin PR preprocessor/64803\n+\n+   This test ensures that the value the __LINE__ macro expands to is\n+   constant and corresponds to the line of the closing parenthesis of\n+   the top-most function-like macro expansion it's part of.\n+\n+   { dg-do run }\n+   { do-options -no-integrated-cpp }  */\n+\n+#include <assert.h>\n+\n+#define C(a, b) a ## b\n+#define L(x) C(L, x)\n+#define M(a) int L(__LINE__) = __LINE__; assert(L(__LINE__) == __LINE__);\n+\n+int\n+main()\n+{\n+  M(a\n+    );\n+\n+  assert(L20 == 20);\t\t/* 20 is the line number of the\n+\t\t\t\t   closing parenthesis of the\n+\t\t\t\t   invocation of the M macro.  Please\n+\t\t\t\t   adjust in case the layout of this\n+\t\t\t\t   file changes.  */\n+  return 0;\n+}"}, {"sha": "325f706096336e396cbdeeb0c5c7a25e1363f9e1", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "patch": "@@ -1,3 +1,15 @@\n+2015-02-03    <dodji@redhat.com>\n+\n+\tPR preprocessor/64803\n+\t* internal.h (cpp_reader::top_most_macro_node): New data member.\n+\t* macro.c (enter_macro_context): Pass the location of the end of\n+\tthe top-most invocation of the function-like macro, or the\n+\tlocation of the expansion point of the top-most object-like macro.\n+\t(cpp_get_token_1): Store the top-most macro node in the new\n+\tpfile->top_most_macro_node data member.\n+\t(_cpp_pop_context): Clear the new cpp_reader::top_most_macro_node\n+\tdata member.\n+\n 2015-01-30  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* lex.c (search_line_fast): Change __ARM_NEON__ to __ARM_NEON."}, {"sha": "96ccc19e447bd7d7fed3ac1e700cbf291b57d40e", "filename": "libcpp/internal.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "patch": "@@ -421,6 +421,11 @@ struct cpp_reader\n      macro invocation.  */\n   source_location invocation_location;\n \n+  /* This is the node representing the macro being expanded at\n+     top-level.  The value of this data member is valid iff\n+     in_macro_expansion_p() returns TRUE.  */\n+  cpp_hashnode *top_most_macro_node;\n+\n   /* Nonzero if we are about to expand a macro.  Note that if we are\n      really expanding a macro, the function macro_of_context returns\n      the macro being expanded and this flag is set to false.  Client"}, {"sha": "1e0a0b560ba34bc7b208c59cad2fe5b2695b3404", "filename": "libcpp/macro.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8abc9ba2d15ac7ee06ce9c135732276203ece1d/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "patch": "@@ -1228,7 +1228,24 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n \n   pfile->about_to_expand_macro_p = false;\n   /* Handle built-in macros and the _Pragma operator.  */\n-  return builtin_macro (pfile, node, location);\n+  {\n+    source_location loc;\n+    if (/* The top-level macro invocation that triggered the expansion\n+\t   we are looking at is with a standard macro ...*/\n+\t!(pfile->top_most_macro_node->flags & NODE_BUILTIN)\n+\t/* ... and it's a function-like macro invocation.  */\n+\t&& pfile->top_most_macro_node->value.macro->fun_like)\n+      /* Then the location of the end of the macro invocation is the\n+\t location of the closing parenthesis.  */\n+      loc = pfile->cur_token[-1].src_loc;\n+    else\n+      /* Otherwise, the location of the end of the macro invocation is\n+\t the location of the expansion point of that top-level macro\n+\t invocation.  */\n+      loc = location;\n+\n+    return builtin_macro (pfile, node, loc);\n+  }\n }\n \n /* De-allocate the memory used by BUFF which is an array of instances\n@@ -2296,6 +2313,10 @@ _cpp_pop_context (cpp_reader *pfile)\n \t     macro expansion.  */\n \t  && macro_of_context (context->prev) != macro)\n \tmacro->flags &= ~NODE_DISABLED;\n+\n+      if (macro == pfile->top_most_macro_node && context->prev == NULL)\n+\t/* We are popping the context of the top-most macro node.  */\n+\tpfile->top_most_macro_node = NULL;\n     }\n \n   if (context->buff)\n@@ -2460,9 +2481,13 @@ cpp_get_token_1 (cpp_reader *pfile, source_location *location)\n \t{\n \t  int ret = 0;\n \t  /* If not in a macro context, and we're going to start an\n-\t     expansion, record the location.  */\n+\t     expansion, record the location and the top level macro\n+\t     about to be expanded.  */\n \t  if (!in_macro_expansion_p (pfile))\n-\t    pfile->invocation_location = result->src_loc;\n+\t    {\n+\t      pfile->invocation_location = result->src_loc;\n+\t      pfile->top_most_macro_node = node;\n+\t    }\n \t  if (pfile->state.prevent_expansion)\n \t    break;\n "}]}