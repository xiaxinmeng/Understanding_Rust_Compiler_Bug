{"sha": "b3c6d2ea006d4c688964c044a081ddea7884148a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjNmQyZWEwMDZkNGM2ODg5NjRjMDQ0YTA4MWRkZWE3ODg0MTQ4YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-01-05T19:05:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-01-05T19:05:46Z"}, "message": "c-common.c (decl_with_nonnull_addr_p): New function.\n\n./:\t* c-common.c (decl_with_nonnull_addr_p): New function.\n\t(c_common_truthvalue_conversion): Call it.\n\t* c-typeck.c (build_binary_op): Likewise.\n\t* c-common.h (decl_with_nonnull_addr_p): Declare.\ncp/:\n\t* typeck.c (build_binary_op): Warn about comparing a non-weak\n\taddress to NULL.\ntestsuite/:\n\t* gcc.dg/Walways-true-1.c: New test.\n\t* gcc.dg/Walways-true-2.c: New test.\n\t* g++.dg/warn/Walways-true-1.C: New test.\n\t* g++.dg/warn/Walways-true-2.C: New test.\n\nFrom-SVN: r120493", "tree": {"sha": "5758b8cb24576b1e3eb71016f81cfeab25bbd494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5758b8cb24576b1e3eb71016f81cfeab25bbd494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3c6d2ea006d4c688964c044a081ddea7884148a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c6d2ea006d4c688964c044a081ddea7884148a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c6d2ea006d4c688964c044a081ddea7884148a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c6d2ea006d4c688964c044a081ddea7884148a/comments", "author": null, "committer": null, "parents": [{"sha": "97af925ba7b16e64c9f8b48cbfd5b4ccaa905f36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97af925ba7b16e64c9f8b48cbfd5b4ccaa905f36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97af925ba7b16e64c9f8b48cbfd5b4ccaa905f36"}], "stats": {"total": 315, "additions": 293, "deletions": 22}, "files": [{"sha": "92925123a4a498950ac1e2e67e8c883703bc5323", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -1,3 +1,10 @@\n+2007-01-05  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c-common.c (decl_with_nonnull_addr_p): New function.\n+\t(c_common_truthvalue_conversion): Call it.\n+\t* c-typeck.c (build_binary_op): Likewise.\n+\t* c-common.h (decl_with_nonnull_addr_p): Declare.\n+\n 2007-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/30360"}, {"sha": "1794bd8642ead970aaa4ed027a246a83f598d156", "filename": "gcc/c-common.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -2591,6 +2591,18 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n   return fold_build2 (resultcode, result_type, ptrop, intop);\n }\n \f\n+/* Return whether EXPR is a declaration whose address can never be\n+   NULL.  */\n+\n+bool\n+decl_with_nonnull_addr_p (tree expr)\n+{\n+  return (DECL_P (expr)\n+\t  && (TREE_CODE (expr) == PARM_DECL\n+\t      || TREE_CODE (expr) == LABEL_DECL\n+\t      || !DECL_WEAK (expr)));\n+}\n+\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n    or for an `if' or `while' statement or ?..: exp.  It should already\n    have been validated to be of suitable type; otherwise, a bad\n@@ -2656,23 +2668,22 @@ c_common_truthvalue_conversion (tree expr)\n     case ADDR_EXPR:\n       {\n  \ttree inner = TREE_OPERAND (expr, 0);\n-\tif (DECL_P (inner)\n-\t    && (TREE_CODE (inner) == PARM_DECL\n-\t\t|| TREE_CODE (inner) == LABEL_DECL\n-\t\t|| !DECL_WEAK (inner)))\n+\tif (decl_with_nonnull_addr_p (inner))\n \t  {\n-\t    /* Common Ada/Pascal programmer's mistake.  We always warn\n-\t       about this since it is so bad.  */\n-\t    warning (OPT_Walways_true, \"the address of %qD will always evaluate as %<true%>\",\n+\t    /* Common Ada/Pascal programmer's mistake.  */\n+\t    warning (OPT_Walways_true,\n+\t\t     \"the address of %qD will always evaluate as %<true%>\",\n \t\t     inner);\n \t    return truthvalue_true_node;\n \t  }\n \n-\t/* If we are taking the address of an external decl, it might be\n-\t   zero if it is weak, so we cannot optimize.  */\n-\tif (DECL_P (inner)\n-\t    && DECL_EXTERNAL (inner))\n-\t  break;\n+\t/* If we still have a decl, it is possible for its address to\n+\t   be NULL, so we cannot optimize.  */\n+\tif (DECL_P (inner))\n+\t  {\n+\t    gcc_assert (DECL_WEAK (inner));\n+\t    break;\n+\t  }\n \n \tif (TREE_SIDE_EFFECTS (inner))\n \t  return build2 (COMPOUND_EXPR, truthvalue_type_node,"}, {"sha": "86b44870a57b61452460d6df8336cdcbd795d349", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -652,6 +652,7 @@ extern tree c_common_unsigned_type (tree);\n extern tree c_common_signed_type (tree);\n extern tree c_common_signed_or_unsigned_type (int, tree);\n extern tree c_build_bitfield_integer_type (unsigned HOST_WIDE_INT, int);\n+extern bool decl_with_nonnull_addr_p (tree);\n extern tree c_common_truthvalue_conversion (tree);\n extern void c_apply_type_quals_to_decl (int, tree);\n extern tree c_sizeof_or_alignof_type (tree, bool, int);"}, {"sha": "28d023de552de079efc8758d2986f0c40e39cd60", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -8013,21 +8013,15 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n \t  if (TREE_CODE (op0) == ADDR_EXPR\n-\t      && DECL_P (TREE_OPERAND (op0, 0))\n-\t      && (TREE_CODE (TREE_OPERAND (op0, 0)) == PARM_DECL\n-\t\t  || TREE_CODE (TREE_OPERAND (op0, 0)) == LABEL_DECL\n-\t\t  || !DECL_WEAK (TREE_OPERAND (op0, 0))))\n+\t      && decl_with_nonnull_addr_p (TREE_OPERAND (op0, 0)))\n \t    warning (OPT_Walways_true, \"the address of %qD will never be NULL\",\n \t\t     TREE_OPERAND (op0, 0));\n \t  result_type = type0;\n \t}\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  if (TREE_CODE (op1) == ADDR_EXPR\n-\t      && DECL_P (TREE_OPERAND (op1, 0))\n-\t      && (TREE_CODE (TREE_OPERAND (op1, 0)) == PARM_DECL\n-\t\t  || TREE_CODE (TREE_OPERAND (op1, 0)) == LABEL_DECL\n-\t\t  || !DECL_WEAK (TREE_OPERAND (op1, 0))))\n+\t      && decl_with_nonnull_addr_p (TREE_OPERAND (op1, 0)))\n \t    warning (OPT_Walways_true, \"the address of %qD will never be NULL\",\n \t\t     TREE_OPERAND (op1, 0));\n \t  result_type = type1;"}, {"sha": "1f7945d9b1ffee733502c418835576b9a87b2ea3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -1,3 +1,8 @@\n+2007-01-05  Ian Lance Taylor  <iant@google.com>\n+\n+\t* typeck.c (build_binary_op): Warn about comparing a non-weak\n+\taddress to NULL.\n+\n 2007-01-05  Douglas Gregor  <doug.gregor@gmail.com>\n \n \t* pt.c (tsubst): Propagate the need for structural equality checks"}, {"sha": "061241dbf52da3bcf950772f6b6169b7aabb167a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -3334,10 +3334,22 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t\t\t\t      \"comparison\");\n       else if ((code0 == POINTER_TYPE || TYPE_PTRMEM_P (type0))\n \t       && null_ptr_cst_p (op1))\n-\tresult_type = type0;\n+\t{\n+\t  if (TREE_CODE (op0) == ADDR_EXPR\n+\t      && decl_with_nonnull_addr_p (TREE_OPERAND (op0, 0)))\n+\t    warning (OPT_Walways_true, \"the address of %qD will never be NULL\",\n+\t\t     TREE_OPERAND (op0, 0));\n+\t  result_type = type0;\n+\t}\n       else if ((code1 == POINTER_TYPE || TYPE_PTRMEM_P (type1))\n \t       && null_ptr_cst_p (op0))\n-\tresult_type = type1;\n+\t{\n+\t  if (TREE_CODE (op1) == ADDR_EXPR \n+\t      && decl_with_nonnull_addr_p (TREE_OPERAND (op1, 0)))\n+\t    warning (OPT_Walways_true, \"the address of %qD will never be NULL\",\n+\t\t     TREE_OPERAND (op1, 0));\n+\t  result_type = type1;\n+\t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;"}, {"sha": "8856b7e2ff62cb53f5869d1d849cffc4a3e11580", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -1,3 +1,10 @@\n+2007-01-05  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Walways-true-1.c: New test.\n+\t* gcc.dg/Walways-true-2.c: New test.\n+\t* g++.dg/warn/Walways-true-1.C: New test.\n+\t* g++.dg/warn/Walways-true-2.C: New test.\n+\n 2007-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/30360"}, {"sha": "5102ca1a3773c132214712e1f44632be2d7cc718", "filename": "gcc/testsuite/g++.dg/warn/Walways-true-1.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-1.C?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -0,0 +1,57 @@\n+// Test -Walways-true for testing an address against NULL.\n+// Origin: Ian Lance Taylor <iant@google.com>\n+\n+// { dg-do compile}\n+// { dg-options \"-Walways-true\" }\n+\n+extern int foo (int);\n+\n+int i;\n+\n+void\n+bar (int a)\n+{\n+ lab:\n+  if (foo)\t// { dg-warning \"always evaluate as\" \"correct warning\" }\n+    foo (0);\n+  if (foo (1))\n+    ;\n+  if (&i)\t// { dg-warning \"always evaluate as\" \"correct warning\" }\n+    foo (2);\n+  if (i)\n+    foo (3);\n+  if (&a)\t// { dg-warning \"always evaluate as\" \"correct warning\" }\n+    foo (4);\n+  if (a)\n+    foo (5);\n+  if (&&lab)\t// { dg-warning \"always evaluate as\" \"correct warning\" }\n+    foo (6);\n+  if (foo == 0)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (7);\n+  if (foo (1) == 0)\n+    foo (8);\n+  if (&i == 0)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (9);\n+  if (i == 0)\n+    foo (10);\n+  if (&a == 0)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (11);\n+  if (a == 0)\n+    foo (12);\n+  if (&&lab == 0) // { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (13);\n+  if (0 == foo)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (14);\n+  if (0 == foo (1))\n+    foo (15);\n+  if (0 == &i)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (16);\n+  if (0 == i)\n+    foo (17);\n+  if (0 == &a)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (18);\n+  if (0 == a)\n+    foo (19);\n+  if (0 == &&lab) // { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (20);\n+}"}, {"sha": "540856650e60d1b542ade4f0e0e5ff2abc7f9566", "filename": "gcc/testsuite/g++.dg/warn/Walways-true-2.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWalways-true-2.C?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -0,0 +1,60 @@\n+// Make sure we don't assume that a weak symbol is always non-NULL.\n+// This is just like Walways-true-1.C, except that it uses a weak\n+// symbol.\n+// Origin: Ian Lance Taylor <iant@google.com>\n+\n+// { dg-do compile}\n+// { dg-options \"-Walways-true\" }\n+// { dg-require-weak \"\" }\n+\n+extern int foo (int) __attribute__ ((weak));\n+\n+int i __attribute__ ((weak));\n+\n+void\n+bar (int a)\n+{\n+ lab:\n+  if (foo)\n+    foo (0);\n+  if (foo (1))\n+    ;\n+  if (&i)\n+    foo (2);\n+  if (i)\n+    foo (3);\n+  if (&a)\t// { dg-warning \"always evaluate as\" \"correct warning\" }\n+    foo (4);\n+  if (a)\n+    foo (5);\n+  if (&&lab)\t// { dg-warning \"always evaluate as\" \"correct warning\" }\n+    foo (6);\n+  if (foo == 0)\n+    foo (7);\n+  if (foo (1) == 0)\n+    foo (8);\n+  if (&i == 0)\n+    foo (9);\n+  if (i == 0)\n+    foo (10);\n+  if (&a == 0)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (11);\n+  if (a == 0)\n+    foo (12);\n+  if (&&lab == 0) // { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (13);\n+  if (0 == foo)\n+    foo (14);\n+  if (0 == foo (1))\n+    foo (15);\n+  if (0 == &i)\n+    foo (16);\n+  if (0 == i)\n+    foo (17);\n+  if (0 == &a)\t// { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (18);\n+  if (0 == a)\n+    foo (19);\n+  if (0 == &&lab) // { dg-warning \"never be NULL\" \"correct warning\" }\n+    foo (20);\n+}"}, {"sha": "f531e8f4b79c6596c0698aa5d8fe54c3c1adab30", "filename": "gcc/testsuite/gcc.dg/Walways-true-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-1.c?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -0,0 +1,57 @@\n+/* Test -Walways-true for testing an address against NULL.\n+   Origin: Ian Lance Taylor <iant@google.com>.  */\n+\n+/* { dg-do compile} */\n+/* { dg-options \"-Walways-true\" } */\n+\n+extern int foo (int);\n+\n+int i;\n+\n+void\n+bar (int a)\n+{\n+ lab:\n+  if (foo)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+    foo (0);\n+  if (foo (1))\n+    ;\n+  if (&i)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+    foo (2);\n+  if (i)\n+    foo (3);\n+  if (&a)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+    foo (4);\n+  if (a)\n+    foo (5);\n+  if (&&lab)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+    foo (6);\n+  if (foo == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (7);\n+  if (foo (1) == 0)\n+    foo (8);\n+  if (&i == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (9);\n+  if (i == 0)\n+    foo (10);\n+  if (&a == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (11);\n+  if (a == 0)\n+    foo (12);\n+  if (&&lab == 0) /* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (13);\n+  if (0 == foo)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (14);\n+  if (0 == foo (1))\n+    foo (15);\n+  if (0 == &i)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (16);\n+  if (0 == i)\n+    foo (17);\n+  if (0 == &a)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (18);\n+  if (0 == a)\n+    foo (19);\n+  if (0 == &&lab) /* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (20);\n+}"}, {"sha": "cab897b4e3d8cb2da45f7eee91ffdd0f5da83034", "filename": "gcc/testsuite/gcc.dg/Walways-true-2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c6d2ea006d4c688964c044a081ddea7884148a/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalways-true-2.c?ref=b3c6d2ea006d4c688964c044a081ddea7884148a", "patch": "@@ -0,0 +1,60 @@\n+/* Make sure we don't assume that a weak symbol is always non-NULL.\n+   This is just like Walways-true-1.C, except that it uses a weak\n+   symbol.\n+   Origin: Ian Lance Taylor <iant@google.com>.  */\n+\n+/* { dg-do compile} */\n+/* { dg-options \"-Walways-true\" } */\n+/* { dg-require-weak \"\" } */\n+\n+extern int foo (int) __attribute__ ((weak));\n+\n+int i __attribute__ ((weak));\n+\n+void\n+bar (int a)\n+{\n+ lab:\n+  if (foo)\n+    foo (0);\n+  if (foo (1))\n+    ;\n+  if (&i)\n+    foo (2);\n+  if (i)\n+    foo (3);\n+  if (&a)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+    foo (4);\n+  if (a)\n+    foo (5);\n+  if (&&lab)\t/* { dg-warning \"always evaluate as\" \"correct warning\" } */\n+    foo (6);\n+  if (foo == 0)\n+    foo (7);\n+  if (foo (1) == 0)\n+    foo (8);\n+  if (&i == 0)\n+    foo (9);\n+  if (i == 0)\n+    foo (10);\n+  if (&a == 0)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (11);\n+  if (a == 0)\n+    foo (12);\n+  if (&&lab == 0) /* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (13);\n+  if (0 == foo)\n+    foo (14);\n+  if (0 == foo (1))\n+    foo (15);\n+  if (0 == &i)\n+    foo (16);\n+  if (0 == i)\n+    foo (17);\n+  if (0 == &a)\t/* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (18);\n+  if (0 == a)\n+    foo (19);\n+  if (0 == &&lab) /* { dg-warning \"never be NULL\" \"correct warning\" } */\n+    foo (20);\n+}"}]}