{"sha": "f9e9e7134fc4137a53d91ceb09f58015e0eedaa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjllOWU3MTM0ZmM0MTM3YTUzZDkxY2ViMDlmNTgwMTVlMGVlZGFhOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T12:17:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T12:17:33Z"}, "message": "Removed, no longer used.\n\nFrom-SVN: r251976", "tree": {"sha": "95542465a027c5eda1920d43a5edcd5a521c8240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95542465a027c5eda1920d43a5edcd5a521c8240"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9e9e7134fc4137a53d91ceb09f58015e0eedaa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e9e7134fc4137a53d91ceb09f58015e0eedaa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9e9e7134fc4137a53d91ceb09f58015e0eedaa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e9e7134fc4137a53d91ceb09f58015e0eedaa9/comments", "author": null, "committer": null, "parents": [{"sha": "ab3dd4aba8edefd009fc719e3d1f83b93cb8bc0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3dd4aba8edefd009fc719e3d1f83b93cb8bc0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3dd4aba8edefd009fc719e3d1f83b93cb8bc0b"}], "stats": {"total": 1025, "additions": 0, "deletions": 1025}, "files": [{"sha": "e539f477beef080a0523bf36f801d38d7a98261d", "filename": "gcc/ada/math_lib.adb", "status": "removed", "additions": 0, "deletions": 1025, "changes": 1025, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3dd4aba8edefd009fc719e3d1f83b93cb8bc0b/gcc%2Fada%2Fmath_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3dd4aba8edefd009fc719e3d1f83b93cb8bc0b/gcc%2Fada%2Fmath_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmath_lib.adb?ref=ab3dd4aba8edefd009fc719e3d1f83b93cb8bc0b", "patch": "@@ -1,1025 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                             M A T H _ L I B                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This body is specifically for using an Ada interface to C math.h to get\n---  the computation engine. Many special cases are handled locally to avoid\n---  unnecessary calls. This is not a \"strict\" implementation, but takes full\n---  advantage of the C functions, e.g. in providing interface to hardware\n---  provided versions of the elementary functions.\n-\n---  A known weakness is that on the x86, all computation is done in Double,\n---  which means that a lot of accuracy is lost for the Long_Long_Float case.\n-\n---  Uses functions sqrt, exp, log, pow, sin, asin, cos, acos, tan, atan,\n---  sinh, cosh, tanh from C library via math.h\n-\n---  This is an adaptation of Ada.Numerics.Generic_Elementary_Functions that\n---  provides a compatible body for the DEC Math_Lib package.\n-\n-with Ada.Numerics.Aux;\n-use type Ada.Numerics.Aux.Double;\n-with Ada.Numerics; use Ada.Numerics;\n-\n-package body Math_Lib is\n-\n-   Log_Two : constant := 0.69314_71805_59945_30941_72321_21458_17656_80755;\n-\n-   Two_Pi     : constant Real'Base := 2.0 * Pi;\n-   Half_Pi    : constant Real'Base := Pi / 2.0;\n-   Fourth_Pi  : constant Real'Base := Pi / 4.0;\n-   Epsilon    : constant Real'Base := Real'Base'Epsilon;\n-   IEpsilon   : constant Real'Base := 1.0 / Epsilon;\n-\n-   subtype Double is Aux.Double;\n-\n-   DEpsilon    : constant Double := Double (Epsilon);\n-   DIEpsilon   : constant Double := Double (IEpsilon);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Arctan\n-     (Y    : Real;\n-      A    : Real := 1.0)\n-      return Real;\n-\n-   function Arctan\n-     (Y     : Real;\n-      A     : Real := 1.0;\n-      Cycle : Real)\n-      return  Real;\n-\n-   function Exact_Remainder\n-     (A    : Real;\n-      Y    : Real)\n-      return Real;\n-   --  Computes exact remainder of A divided by Y\n-\n-   function Half_Log_Epsilon return Real;\n-   --  Function to provide constant: 0.5 * Log (Epsilon)\n-\n-   function Local_Atan\n-     (Y    : Real;\n-      A    : Real := 1.0)\n-      return Real;\n-   --  Common code for arc tangent after cycle reduction\n-\n-   function Log_Inverse_Epsilon return Real;\n-   --  Function to provide constant: Log (1.0 / Epsilon)\n-\n-   function Square_Root_Epsilon return Real;\n-   --  Function to provide constant: Sqrt (Epsilon)\n-\n-   ----------\n-   -- \"**\" --\n-   ----------\n-\n-   function \"**\" (A1, A2 : Real) return Real is\n-\n-   begin\n-      if A1 = 0.0\n-        and then A2 = 0.0\n-      then\n-         raise Argument_Error;\n-\n-      elsif A1 < 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A2 = 0.0 then\n-         return 1.0;\n-\n-      elsif A1 = 0.0 then\n-         if A2 < 0.0 then\n-            raise Constraint_Error;\n-         else\n-            return 0.0;\n-         end if;\n-\n-      elsif A1 = 1.0 then\n-         return 1.0;\n-\n-      elsif A2 = 1.0 then\n-         return A1;\n-\n-      else\n-         begin\n-            if A2 = 2.0 then\n-               return A1 * A1;\n-            else\n-               return\n-                 Real (Aux.pow (Double (A1), Double (A2)));\n-            end if;\n-\n-         exception\n-            when others =>\n-               raise Constraint_Error;\n-         end;\n-      end if;\n-   end \"**\";\n-\n-   ------------\n-   -- Arccos --\n-   ------------\n-\n-   --  Natural cycle\n-\n-   function Arccos (A : Real) return Real is\n-      Temp : Real'Base;\n-\n-   begin\n-      if abs A > 1.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return Pi / 2.0 - A;\n-\n-      elsif A = 1.0 then\n-         return 0.0;\n-\n-      elsif A = -1.0 then\n-         return Pi;\n-      end if;\n-\n-      Temp := Real (Aux.acos (Double (A)));\n-\n-      if Temp < 0.0 then\n-         Temp := Pi + Temp;\n-      end if;\n-\n-      return Temp;\n-   end Arccos;\n-\n-   --  Arbitrary cycle\n-\n-   function Arccos (A, Cycle : Real) return Real is\n-      Temp : Real'Base;\n-\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A > 1.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return Cycle / 4.0;\n-\n-      elsif A = 1.0 then\n-         return 0.0;\n-\n-      elsif A = -1.0 then\n-         return Cycle / 2.0;\n-      end if;\n-\n-      Temp := Arctan (Sqrt (1.0 - A * A) / A, 1.0, Cycle);\n-\n-      if Temp < 0.0 then\n-         Temp := Cycle / 2.0 + Temp;\n-      end if;\n-\n-      return Temp;\n-   end Arccos;\n-\n-   -------------\n-   -- Arccosh --\n-   -------------\n-\n-   function Arccosh (A : Real) return Real is\n-   begin\n-      --  Return Log (A - Sqrt (A * A - 1.0));  double valued,\n-      --    only positive value returned\n-      --  What is this comment ???\n-\n-      if A < 1.0 then\n-         raise Argument_Error;\n-\n-      elsif A < 1.0 + Square_Root_Epsilon then\n-         return A - 1.0;\n-\n-      elsif abs A > 1.0 / Square_Root_Epsilon then\n-         return Log (A) + Log_Two;\n-\n-      else\n-         return Log (A + Sqrt (A * A - 1.0));\n-      end if;\n-   end Arccosh;\n-\n-   ------------\n-   -- Arccot --\n-   ------------\n-\n-   --  Natural cycle\n-\n-   function Arccot\n-     (A    : Real;\n-      Y    : Real := 1.0)\n-      return Real\n-   is\n-   begin\n-      --  Just reverse arguments\n-\n-      return Arctan (Y, A);\n-   end Arccot;\n-\n-   --  Arbitrary cycle\n-\n-   function Arccot\n-     (A     : Real;\n-      Y     : Real := 1.0;\n-      Cycle : Real)\n-      return  Real\n-   is\n-   begin\n-      --  Just reverse arguments\n-\n-      return Arctan (Y, A, Cycle);\n-   end Arccot;\n-\n-   -------------\n-   -- Arccoth --\n-   -------------\n-\n-   function Arccoth (A : Real) return Real is\n-   begin\n-      if abs A = 1.0 then\n-         raise Constraint_Error;\n-\n-      elsif abs A < 1.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A > 1.0 / Epsilon then\n-         return 0.0;\n-\n-      else\n-         return 0.5 * Log ((1.0 + A) / (A - 1.0));\n-      end if;\n-   end Arccoth;\n-\n-   ------------\n-   -- Arcsin --\n-   ------------\n-\n-   --  Natural cycle\n-\n-   function Arcsin (A : Real) return Real is\n-   begin\n-      if abs A > 1.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return A;\n-\n-      elsif A = 1.0 then\n-         return Pi / 2.0;\n-\n-      elsif A = -1.0 then\n-         return -Pi / 2.0;\n-      end if;\n-\n-      return Real (Aux.asin (Double (A)));\n-   end Arcsin;\n-\n-   --  Arbitrary cycle\n-\n-   function Arcsin (A, Cycle : Real) return Real is\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A > 1.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         return A;\n-\n-      elsif A = 1.0 then\n-         return Cycle / 4.0;\n-\n-      elsif A = -1.0 then\n-         return -Cycle / 4.0;\n-      end if;\n-\n-      return Arctan (A / Sqrt (1.0 - A * A), 1.0, Cycle);\n-   end Arcsin;\n-\n-   -------------\n-   -- Arcsinh --\n-   -------------\n-\n-   function Arcsinh (A : Real) return Real is\n-   begin\n-      if abs A < Square_Root_Epsilon then\n-         return A;\n-\n-      elsif A > 1.0 / Square_Root_Epsilon then\n-         return Log (A) + Log_Two;\n-\n-      elsif A < -1.0 / Square_Root_Epsilon then\n-         return -(Log (-A) + Log_Two);\n-\n-      elsif A < 0.0 then\n-         return -Log (abs A + Sqrt (A * A + 1.0));\n-\n-      else\n-         return Log (A + Sqrt (A * A + 1.0));\n-      end if;\n-   end Arcsinh;\n-\n-   ------------\n-   -- Arctan --\n-   ------------\n-\n-   --  Natural cycle\n-\n-   function Arctan\n-     (Y    : Real;\n-      A    : Real := 1.0)\n-      return Real\n-   is\n-   begin\n-      if A = 0.0\n-        and then Y = 0.0\n-      then\n-         raise Argument_Error;\n-\n-      elsif Y = 0.0 then\n-         if A > 0.0 then\n-            return 0.0;\n-         else -- A < 0.0\n-            return Pi;\n-         end if;\n-\n-      elsif A = 0.0 then\n-         if Y > 0.0 then\n-            return Half_Pi;\n-         else -- Y < 0.0\n-            return -Half_Pi;\n-         end if;\n-\n-      else\n-         return Local_Atan (Y, A);\n-      end if;\n-   end Arctan;\n-\n-   --  Arbitrary cycle\n-\n-   function Arctan\n-     (Y     : Real;\n-      A     : Real := 1.0;\n-      Cycle : Real)\n-      return  Real\n-   is\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0\n-        and then Y = 0.0\n-      then\n-         raise Argument_Error;\n-\n-      elsif Y = 0.0 then\n-         if A > 0.0 then\n-            return 0.0;\n-         else -- A < 0.0\n-            return Cycle / 2.0;\n-         end if;\n-\n-      elsif A = 0.0 then\n-         if Y > 0.0 then\n-            return Cycle / 4.0;\n-         else -- Y < 0.0\n-            return -Cycle / 4.0;\n-         end if;\n-\n-      else\n-         return Local_Atan (Y, A) *  Cycle / Two_Pi;\n-      end if;\n-   end Arctan;\n-\n-   -------------\n-   -- Arctanh --\n-   -------------\n-\n-   function Arctanh (A : Real) return Real is\n-   begin\n-      if abs A = 1.0 then\n-         raise Constraint_Error;\n-\n-      elsif abs A > 1.0 then\n-         raise Argument_Error;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return A;\n-\n-      else\n-         return 0.5 * Log ((1.0 + A) / (1.0 - A));\n-      end if;\n-   end Arctanh;\n-\n-   ---------\n-   -- Cos --\n-   ---------\n-\n-   --  Natural cycle\n-\n-   function Cos (A : Real) return Real is\n-   begin\n-      if A = 0.0 then\n-         return 1.0;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return 1.0;\n-\n-      end if;\n-\n-      return Real (Aux.Cos (Double (A)));\n-   end Cos;\n-\n-   --  Arbitrary cycle\n-\n-   function Cos (A, Cycle : Real) return Real is\n-      T : Real'Base;\n-\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         return 1.0;\n-      end if;\n-\n-      T := Exact_Remainder (abs (A), Cycle) / Cycle;\n-\n-      if T = 0.25\n-        or else T = 0.75\n-        or else T = -0.25\n-        or else T = -0.75\n-      then\n-         return 0.0;\n-\n-      elsif T = 0.5 or T = -0.5 then\n-         return -1.0;\n-      end if;\n-\n-      return Real (Aux.Cos (Double (T * Two_Pi)));\n-   end Cos;\n-\n-   ----------\n-   -- Cosh --\n-   ----------\n-\n-   function Cosh (A : Real) return Real is\n-   begin\n-      if abs A < Square_Root_Epsilon then\n-         return 1.0;\n-\n-      elsif abs A > Log_Inverse_Epsilon then\n-         return Exp ((abs A) - Log_Two);\n-      end if;\n-\n-      return Real (Aux.cosh (Double (A)));\n-\n-   exception\n-      when others =>\n-         raise Constraint_Error;\n-   end Cosh;\n-\n-   ---------\n-   -- Cot --\n-   ---------\n-\n-   --  Natural cycle\n-\n-   function Cot (A : Real) return Real is\n-   begin\n-      if A = 0.0 then\n-         raise Constraint_Error;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return 1.0 / A;\n-      end if;\n-\n-      return Real (1.0 / Real'Base (Aux.tan (Double (A))));\n-   end Cot;\n-\n-   --  Arbitrary cycle\n-\n-   function Cot (A, Cycle : Real) return Real is\n-      T : Real'Base;\n-\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         raise Constraint_Error;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return 1.0 / A;\n-      end if;\n-\n-      T := Exact_Remainder (A, Cycle) / Cycle;\n-\n-      if T = 0.0 or T = 0.5 or T = -0.5 then\n-         raise Constraint_Error;\n-      else\n-         return  Cos (T * Two_Pi) / Sin (T * Two_Pi);\n-      end if;\n-   end Cot;\n-\n-   ----------\n-   -- Coth --\n-   ----------\n-\n-   function Coth (A : Real) return Real is\n-   begin\n-      if A = 0.0 then\n-         raise Constraint_Error;\n-\n-      elsif A < Half_Log_Epsilon then\n-         return -1.0;\n-\n-      elsif A > -Half_Log_Epsilon then\n-         return 1.0;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return 1.0 / A;\n-      end if;\n-\n-      return Real (1.0 / Real'Base (Aux.tanh (Double (A))));\n-   end Coth;\n-\n-   ---------------------\n-   -- Exact_Remainder --\n-   ---------------------\n-\n-   function Exact_Remainder\n-     (A    : Real;\n-      Y    : Real)\n-      return Real\n-   is\n-      Denominator : Real'Base := abs A;\n-      Divisor     : Real'Base := abs Y;\n-      Reducer     : Real'Base;\n-      Sign        : Real'Base := 1.0;\n-\n-   begin\n-      if Y = 0.0 then\n-         raise Constraint_Error;\n-\n-      elsif A = 0.0 then\n-         return 0.0;\n-\n-      elsif A = Y then\n-         return 0.0;\n-\n-      elsif Denominator < Divisor then\n-         return A;\n-      end if;\n-\n-      while Denominator >= Divisor loop\n-\n-         --  Put divisors mantissa with denominators exponent to make reducer\n-\n-         Reducer := Divisor;\n-\n-         begin\n-            while Reducer * 1_048_576.0 < Denominator loop\n-               Reducer := Reducer * 1_048_576.0;\n-            end loop;\n-\n-         exception\n-            when others => null;\n-         end;\n-\n-         begin\n-            while Reducer * 1_024.0 < Denominator loop\n-               Reducer := Reducer * 1_024.0;\n-            end loop;\n-\n-         exception\n-            when others => null;\n-         end;\n-\n-         begin\n-            while Reducer * 2.0 < Denominator loop\n-               Reducer := Reducer * 2.0;\n-            end loop;\n-\n-         exception\n-            when others => null;\n-         end;\n-\n-         Denominator := Denominator - Reducer;\n-      end loop;\n-\n-      if A < 0.0 then\n-         return -Denominator;\n-      else\n-         return Denominator;\n-      end if;\n-   end Exact_Remainder;\n-\n-   ---------\n-   -- Exp --\n-   ---------\n-\n-   function Exp (A : Real) return Real is\n-      Result : Real'Base;\n-\n-   begin\n-      if A = 0.0 then\n-         return 1.0;\n-\n-      else\n-         Result := Real (Aux.Exp (Double (A)));\n-\n-         --  The check here catches the case of Exp returning IEEE infinity\n-\n-         if Result > Real'Last then\n-            raise Constraint_Error;\n-         else\n-            return Result;\n-         end if;\n-      end if;\n-   end Exp;\n-\n-   ----------------------\n-   -- Half_Log_Epsilon --\n-   ----------------------\n-\n-   --  Cannot precompute this constant, because this is required to be a\n-   --  pure package, which allows no state. A pity, but no way around it!\n-\n-   function Half_Log_Epsilon return Real is\n-   begin\n-      return Real (0.5 * Real'Base (Aux.Log (DEpsilon)));\n-   end Half_Log_Epsilon;\n-\n-   ----------------\n-   -- Local_Atan --\n-   ----------------\n-\n-   function Local_Atan\n-     (Y    : Real;\n-      A    : Real := 1.0)\n-      return Real\n-   is\n-      Z        : Real'Base;\n-      Raw_Atan : Real'Base;\n-\n-   begin\n-      if abs Y > abs A then\n-         Z := abs (A / Y);\n-      else\n-         Z := abs (Y / A);\n-      end if;\n-\n-      if Z < Square_Root_Epsilon then\n-         Raw_Atan := Z;\n-\n-      elsif Z = 1.0 then\n-         Raw_Atan := Pi / 4.0;\n-\n-      elsif Z < Square_Root_Epsilon then\n-         Raw_Atan := Z;\n-\n-      else\n-         Raw_Atan := Real'Base (Aux.Atan (Double (Z)));\n-      end if;\n-\n-      if abs Y > abs A then\n-         Raw_Atan := Half_Pi - Raw_Atan;\n-      end if;\n-\n-      if A > 0.0 then\n-         if Y > 0.0 then\n-            return Raw_Atan;\n-         else                 --  Y < 0.0\n-            return -Raw_Atan;\n-         end if;\n-\n-      else                    --  A < 0.0\n-         if Y > 0.0 then\n-            return Pi - Raw_Atan;\n-         else                  --  Y < 0.0\n-            return -(Pi - Raw_Atan);\n-         end if;\n-      end if;\n-   end Local_Atan;\n-\n-   ---------\n-   -- Log --\n-   ---------\n-\n-   --  Natural base\n-\n-   function Log (A : Real) return Real is\n-   begin\n-      if A < 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         raise Constraint_Error;\n-\n-      elsif A = 1.0 then\n-         return 0.0;\n-      end if;\n-\n-      return Real (Aux.Log (Double (A)));\n-   end Log;\n-\n-   --  Arbitrary base\n-\n-   function Log (A, Base : Real) return Real is\n-   begin\n-      if A < 0.0 then\n-         raise Argument_Error;\n-\n-      elsif Base <= 0.0 or else Base = 1.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         raise Constraint_Error;\n-\n-      elsif A = 1.0 then\n-         return 0.0;\n-      end if;\n-\n-      return Real (Aux.Log (Double (A)) / Aux.Log (Double (Base)));\n-   end Log;\n-\n-   -------------------------\n-   -- Log_Inverse_Epsilon --\n-   -------------------------\n-\n-   --  Cannot precompute this constant, because this is required to be a\n-   --  pure package, which allows no state. A pity, but no way around it!\n-\n-   function Log_Inverse_Epsilon return Real is\n-   begin\n-      return Real (Aux.Log (DIEpsilon));\n-   end Log_Inverse_Epsilon;\n-\n-   ---------\n-   -- Sin --\n-   ---------\n-\n-   --  Natural cycle\n-\n-   function Sin (A : Real) return Real is\n-   begin\n-      if abs A < Square_Root_Epsilon then\n-         return A;\n-      end if;\n-\n-      return Real (Aux.Sin (Double (A)));\n-   end Sin;\n-\n-   --  Arbitrary cycle\n-\n-   function Sin (A, Cycle : Real) return Real is\n-      T : Real'Base;\n-\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         return A;\n-      end if;\n-\n-      T := Exact_Remainder (A, Cycle) / Cycle;\n-\n-      if T = 0.0 or T = 0.5 or T = -0.5 then\n-         return 0.0;\n-\n-      elsif T = 0.25 or T = -0.75 then\n-         return 1.0;\n-\n-      elsif T = -0.25 or T = 0.75 then\n-         return -1.0;\n-\n-      end if;\n-\n-      return Real (Aux.Sin (Double (T * Two_Pi)));\n-   end Sin;\n-\n-   ----------\n-   -- Sinh --\n-   ----------\n-\n-   function Sinh (A : Real) return Real is\n-   begin\n-      if abs A < Square_Root_Epsilon then\n-         return A;\n-\n-      elsif  A > Log_Inverse_Epsilon then\n-         return Exp (A - Log_Two);\n-\n-      elsif A < -Log_Inverse_Epsilon then\n-         return -Exp ((-A) - Log_Two);\n-      end if;\n-\n-      return Real (Aux.Sinh (Double (A)));\n-\n-   exception\n-      when others =>\n-         raise Constraint_Error;\n-   end Sinh;\n-\n-   -------------------------\n-   -- Square_Root_Epsilon --\n-   -------------------------\n-\n-   --  Cannot precompute this constant, because this is required to be a\n-   --  pure package, which allows no state. A pity, but no way around it!\n-\n-   function Square_Root_Epsilon return Real is\n-   begin\n-      return Real (Aux.Sqrt (DEpsilon));\n-   end Square_Root_Epsilon;\n-\n-   ----------\n-   -- Sqrt --\n-   ----------\n-\n-   function Sqrt (A : Real) return Real is\n-   begin\n-      if A < 0.0 then\n-         raise Argument_Error;\n-\n-      --  Special case Sqrt (0.0) to preserve possible minus sign per IEEE\n-\n-      elsif A = 0.0 then\n-         return A;\n-\n-      --  Sqrt (1.0) must be exact for good complex accuracy\n-\n-      elsif A = 1.0 then\n-         return 1.0;\n-\n-      end if;\n-\n-      return Real (Aux.Sqrt (Double (A)));\n-   end Sqrt;\n-\n-   ---------\n-   -- Tan --\n-   ---------\n-\n-   --  Natural cycle\n-\n-   function Tan (A : Real) return Real is\n-   begin\n-      if abs A < Square_Root_Epsilon then\n-         return A;\n-\n-      elsif abs A = Pi / 2.0 then\n-         raise Constraint_Error;\n-      end if;\n-\n-      return Real (Aux.tan (Double (A)));\n-   end Tan;\n-\n-   --  Arbitrary cycle\n-\n-   function Tan (A, Cycle : Real) return Real is\n-      T : Real'Base;\n-\n-   begin\n-      if Cycle <= 0.0 then\n-         raise Argument_Error;\n-\n-      elsif A = 0.0 then\n-         return A;\n-      end if;\n-\n-      T := Exact_Remainder (A, Cycle) / Cycle;\n-\n-      if T = 0.25\n-        or else T = 0.75\n-        or else T = -0.25\n-        or else T = -0.75\n-      then\n-         raise Constraint_Error;\n-\n-      else\n-         return  Sin (T * Two_Pi) / Cos (T * Two_Pi);\n-      end if;\n-   end Tan;\n-\n-   ----------\n-   -- Tanh --\n-   ----------\n-\n-   function Tanh (A : Real) return Real is\n-   begin\n-      if A < Half_Log_Epsilon then\n-         return -1.0;\n-\n-      elsif A > -Half_Log_Epsilon then\n-         return 1.0;\n-\n-      elsif abs A < Square_Root_Epsilon then\n-         return A;\n-      end if;\n-\n-      return Real (Aux.tanh (Double (A)));\n-   end Tanh;\n-\n-   ----------------------------\n-   -- DEC-Specific functions --\n-   ----------------------------\n-\n-   function LOG10  (A : REAL) return REAL is\n-   begin\n-      return Log (A, 10.0);\n-   end LOG10;\n-\n-   function LOG2   (A : REAL) return REAL is\n-   begin\n-      return Log (A, 2.0);\n-   end LOG2;\n-\n-   function ASIN (A : REAL) return REAL renames Arcsin;\n-   function ACOS (A : REAL) return REAL renames Arccos;\n-\n-   function ATAN (A : REAL) return REAL is\n-   begin\n-      return Arctan (A, 1.0);\n-   end ATAN;\n-\n-   function ATAN2 (A1, A2 : REAL) return REAL renames Arctan;\n-\n-   function SIND   (A : REAL) return REAL is\n-   begin\n-      return Sin (A, 360.0);\n-   end SIND;\n-\n-   function COSD   (A : REAL) return REAL is\n-   begin\n-      return  Cos (A, 360.0);\n-   end COSD;\n-\n-   function TAND   (A : REAL) return REAL is\n-   begin\n-      return  Tan (A, 360.0);\n-   end TAND;\n-\n-   function ASIND  (A : REAL) return REAL is\n-   begin\n-      return  Arcsin (A, 360.0);\n-   end ASIND;\n-\n-   function ACOSD  (A : REAL) return REAL is\n-   begin\n-      return  Arccos (A, 360.0);\n-   end ACOSD;\n-\n-   function Arctan  (A : REAL) return REAL is\n-   begin\n-      return  Arctan (A, 1.0, 360.0);\n-   end Arctan;\n-\n-   function ATAND (A : REAL) return REAL is\n-   begin\n-      return Arctan (A, 1.0, 360.0);\n-   end ATAND;\n-\n-   function ATAN2D (A1, A2 : REAL) return REAL is\n-   begin\n-      return Arctan (A1, A2, 360.0);\n-   end ATAN2D;\n-\n-end Math_Lib;"}]}