{"sha": "d9c0e0578aba733b7b336f8090efe957acc9509d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDljMGUwNTc4YWJhNzMzYjdiMzM2ZjgwOTBlZmU5NTdhY2M5NTA5ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-22T12:12:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-22T12:12:36Z"}, "message": "[multiple changes]\n\n2009-04-22  Robert Dewar  <dewar@adacore.com>\n\n\t* prj.adb: Minor code reorganization\n\tCode clean up.\n\n\t* prj-proc.adb: Minor code reorganization, clean up.\n\n\t* prj-nmsc.adb: Minor reformatting\n\tMinor code reorganization\n\n\t* gnat_ugn.texi: Add to doc on strict aliasing\n\n2009-04-22  Pascal Obry  <obry@adacore.com>\n\n\t* s-osinte-mingw.ads: Rename Reserved field in CRITICAL_SECTION to\n\tSpinCount.\n\n\t* s-tasini.adb: Minor reformatting.\n\n\t* s-tassta.adb: Minor reformatting.\n\nFrom-SVN: r146573", "tree": {"sha": "efc41e88390f6c9f02a7590b7713256f67e41a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efc41e88390f6c9f02a7590b7713256f67e41a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9c0e0578aba733b7b336f8090efe957acc9509d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c0e0578aba733b7b336f8090efe957acc9509d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c0e0578aba733b7b336f8090efe957acc9509d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c0e0578aba733b7b336f8090efe957acc9509d/comments", "author": null, "committer": null, "parents": [{"sha": "4c33221ccd7955ab2e2e442b28fd4df277c1f728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c33221ccd7955ab2e2e442b28fd4df277c1f728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c33221ccd7955ab2e2e442b28fd4df277c1f728"}], "stats": {"total": 687, "additions": 352, "deletions": 335}, "files": [{"sha": "c9b0168f97c07da48985468c81fe6b85f4fef49c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -1,3 +1,24 @@\n+2009-04-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* prj.adb: Minor code reorganization\n+\tCode clean up.\n+\n+\t* prj-proc.adb: Minor code reorganization, clean up.\n+\n+\t* prj-nmsc.adb: Minor reformatting\n+\tMinor code reorganization\n+\n+\t* gnat_ugn.texi: Add to doc on strict aliasing\n+\n+2009-04-22  Pascal Obry  <obry@adacore.com>\n+\n+\t* s-osinte-mingw.ads: Rename Reserved field in CRITICAL_SECTION to\n+\tSpinCount.\n+\n+\t* s-tasini.adb: Minor reformatting.\n+\n+\t* s-tassta.adb: Minor reformatting.\n+\n 2009-04-22  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-proc.adb, prj-nmsc.adb (Check_Naming_Schemes): split into several"}, {"sha": "dc9a86deee1a54ccc938ec65c90e767e522ce693", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -10128,7 +10128,7 @@ required to dereference it each time through the loop.\n \n This kind of optimization, called strict aliasing analysis, is\n triggered by specifying an optimization level of @option{-O2} or\n-higher and allows @code{GNAT} to generate more efficient code\n+higher or @option{-Os} and allows @code{GNAT} to generate more efficient code\n when access values are involved.\n \n However, although this optimization is always correct in terms of\n@@ -10297,6 +10297,21 @@ conversion only for primitive types. This is not really a significant\n restriction since any possible desired effect can be achieved by\n unchecked conversion of access values.\n \n+The aliasing analysis done in strict aliasing mode can certainly\n+have significant benefits. We have seen cases of large scale\n+application code where the time is increased by up to 5% by turning\n+this optimization off. If you have code that includes significant\n+usage of unchecked conversion, you might want to just stick with\n+@option{-O1} and avoid the entire issue. If you get adequate\n+performance at this level of optimization level, that's probably\n+the safest approach. If tests show that you really need higher\n+levels of optimization, then you can experiment with @option{-O2}\n+and @option{-O2 -fno-strict-aliasing} to see how much effect this\n+has on size and speed of the code. If you really need to use\n+@option{-O2} with strict aliasing in effect, then you should\n+review any uses of unchecked conversion of access types,\n+particularly if you are getting the warnings described above.\n+\n @ifset vms\n @node Coverage Analysis\n @subsection Coverage Analysis"}, {"sha": "5cb81c1b63f6c5ca5751c6ec38769cbad4ab9722", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 301, "deletions": 314, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -116,7 +116,9 @@ package body Prj.Nmsc is\n       Key        => Name_Id,\n       Hash       => Hash,\n       Equal      => \"=\");\n-   --  Hash table to store the unit exceptions\n+   --  Hash table to store the unit exceptions.\n+   --  ??? Seems to be used only by the multi_lang mode\n+   --  ??? Should not be a global array, but stored in the project_data\n \n    package Recursive_Dirs is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n@@ -139,10 +141,6 @@ package body Prj.Nmsc is\n    end record;\n    --  Comment needed???\n \n-   --  Why is the following commented out ???\n-   --  No_Unit : constant Unit_Info :=\n-   --              (Specification, No_Name, No_Ada_Naming_Exception);\n-\n    package Ada_Naming_Exception_Table is new Table.Table\n      (Table_Component_Type => Unit_Info,\n       Table_Index_Type     => Ada_Naming_Exception_Id,\n@@ -160,6 +158,8 @@ package body Prj.Nmsc is\n       Equal      => \"=\");\n    --  A hash table to store naming exceptions for Ada. For each file name\n    --  there is one or several unit in table Ada_Naming_Exception_Table.\n+   --  ??? This is for ada_only mode, we should be able to merge with\n+   --  Unit_Exceptions table, used by multi_lang mode.\n \n    package Object_File_Names is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n@@ -255,14 +255,17 @@ package body Prj.Nmsc is\n    --  This alters Name_Buffer\n \n    function Suffix_Matches\n-     (Filename : String; Suffix : File_Name_Type) return Boolean;\n+     (Filename : String;\n+      Suffix   : File_Name_Type) return Boolean;\n    --  True if the filename ends with the given suffix. It always returns False\n    --  if Suffix is No_Name\n \n    procedure Replace_Into_Name_Buffer\n-     (Str : String; Pattern : String; Replacement : Character);\n-   --  Copy Str into Name_Buffer, replacing Pattern with Replacement.\n-   --  Str is converted to lower-case at the same time\n+     (Str         : String;\n+      Pattern     : String;\n+      Replacement : Character);\n+   --  Copy Str into Name_Buffer, replacing Pattern with Replacement. Str is\n+   --  converted to lower-case at the same time.\n \n    function ALI_File_Name (Source : String) return String;\n    --  Return the ALI file name corresponding to a source\n@@ -276,12 +279,6 @@ package body Prj.Nmsc is\n       In_Tree : Project_Tree_Ref);\n    --  Check the naming scheme part of Data\n \n-   procedure Check_Ada_Naming_Scheme_Validity\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref;\n-      Naming  : Naming_Data);\n-   --  Check that the package Naming is correct\n-\n    procedure Check_Configuration\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref;\n@@ -434,7 +431,6 @@ package body Prj.Nmsc is\n    procedure Check_File_Naming_Schemes\n      (In_Tree               : Project_Tree_Ref;\n       Data                  : in out Project_Data;\n-      Filename              : String;\n       File_Name             : File_Name_Type;\n       Alternate_Languages   : out Alternate_Language_Id;\n       Language              : out Language_Index;\n@@ -493,7 +489,7 @@ package body Prj.Nmsc is\n    --  (all languages are processed anyway when in Multi_Language mode).\n \n    procedure Compute_Unit_Name\n-     (Filename        : String;\n+     (File_Name       : File_Name_Type;\n       Dot_Replacement : File_Name_Type;\n       Separate_Suffix : File_Name_Type;\n       Body_Suffix     : File_Name_Type;\n@@ -520,8 +516,8 @@ package body Prj.Nmsc is\n    --  units that the source contains.\n \n    function Is_Illegal_Suffix\n-     (Suffix                          : String;\n-      Dot_Replacement_Is_A_Single_Dot : Boolean) return Boolean;\n+     (Suffix          : File_Name_Type;\n+      Dot_Replacement : File_Name_Type) return Boolean;\n    --  Returns True if the string Suffix cannot be used as a spec suffix, a\n    --  body suffix or a separate suffix.\n \n@@ -628,13 +624,17 @@ package body Prj.Nmsc is\n    ------------------------------\n \n    procedure Replace_Into_Name_Buffer\n-     (Str : String; Pattern : String; Replacement : Character)\n+     (Str         : String;\n+      Pattern     : String;\n+      Replacement : Character)\n    is\n       Max : constant Integer := Str'Last - Pattern'Length + 1;\n-      J : Positive := Str'First;\n+      J   : Positive;\n+\n    begin\n       Name_Len := 0;\n \n+      J := Str'First;\n       while J <= Str'Last loop\n          Name_Len := Name_Len + 1;\n \n@@ -656,7 +656,9 @@ package body Prj.Nmsc is\n    --------------------\n \n    function Suffix_Matches\n-     (Filename : String; Suffix : File_Name_Type) return Boolean is\n+     (Filename : String;\n+      Suffix   : File_Name_Type) return Boolean\n+   is\n    begin\n       if Suffix = No_File then\n          return False;\n@@ -1194,101 +1196,6 @@ package body Prj.Nmsc is\n       end if;\n    end Check_Ada_Name;\n \n-   --------------------------------------\n-   -- Check_Ada_Naming_Scheme_Validity --\n-   --------------------------------------\n-\n-   procedure Check_Ada_Naming_Scheme_Validity\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref;\n-      Naming  : Naming_Data)\n-   is\n-   begin\n-      --  Only check if we are not using the Default naming scheme\n-\n-      if Naming /= In_Tree.Private_Part.Default_Naming then\n-         declare\n-            Dot_Replacement : constant String :=\n-                                Get_Name_String\n-                                  (Naming.Dot_Replacement);\n-\n-            Spec_Suffix : constant String :=\n-                                  Spec_Suffix_Of (In_Tree, \"ada\", Naming);\n-\n-            Body_Suffix : constant String :=\n-                                  Body_Suffix_Of (In_Tree, \"ada\", Naming);\n-\n-            Separate_Suffix : constant String :=\n-                                Get_Name_String\n-                                  (Naming.Separate_Suffix);\n-\n-         begin\n-            --  Suffixes cannot\n-            --   - be empty\n-\n-            if Is_Illegal_Suffix\n-                 (Spec_Suffix, Dot_Replacement = \".\")\n-            then\n-               Err_Vars.Error_Msg_File_1 :=\n-                 Spec_Suffix_Id_Of (In_Tree, Name_Ada, Naming);\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ is illegal for Spec_Suffix\",\n-                  Naming.Ada_Spec_Suffix_Loc);\n-            end if;\n-\n-            if Is_Illegal_Suffix\n-                 (Body_Suffix, Dot_Replacement = \".\")\n-            then\n-               Err_Vars.Error_Msg_File_1 :=\n-                 Body_Suffix_Id_Of (In_Tree, Name_Ada, Naming);\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"{ is illegal for Body_Suffix\",\n-                  Naming.Ada_Body_Suffix_Loc);\n-            end if;\n-\n-            if Body_Suffix /= Separate_Suffix then\n-               if Is_Illegal_Suffix\n-                    (Separate_Suffix, Dot_Replacement = \".\")\n-               then\n-                  Err_Vars.Error_Msg_File_1 := Naming.Separate_Suffix;\n-                  Error_Msg\n-                    (Project, In_Tree,\n-                     \"{ is illegal for Separate_Suffix\",\n-                     Naming.Sep_Suffix_Loc);\n-               end if;\n-            end if;\n-\n-            --  Spec_Suffix cannot be equal to Body_Suffix Separate_Suffix,\n-            --  since that would cause a clear ambiguity. Note that we do\n-            --  allow a Spec_Suffix to have the same termination as one of\n-            --  these, which causes a potential ambiguity, but we resolve\n-            --  that my matching the longest possible suffix.\n-\n-            if Spec_Suffix = Body_Suffix then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"Body_Suffix (\"\"\" &\n-                  Body_Suffix &\n-                  \"\"\") cannot be the same as Spec_Suffix.\",\n-                  Naming.Ada_Body_Suffix_Loc);\n-            end if;\n-\n-            if Body_Suffix /= Separate_Suffix\n-              and then Spec_Suffix = Separate_Suffix\n-            then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"Separate_Suffix (\"\"\" &\n-                  Separate_Suffix &\n-                  \"\"\") cannot be the same as Spec_Suffix.\",\n-                  Naming.Sep_Suffix_Loc);\n-            end if;\n-         end;\n-      end if;\n-   end Check_Ada_Naming_Scheme_Validity;\n-\n    -------------------------\n    -- Check_Configuration --\n    -------------------------\n@@ -2259,8 +2166,7 @@ package body Prj.Nmsc is\n                      pragma Unsuppress (All_Checks);\n                   begin\n                      Data.Config.Separate_Run_Path_Options :=\n-                       Boolean'Value (Get_Name_String\n-                                        (Attribute.Value.Value));\n+                       Boolean'Value (Get_Name_String (Attribute.Value.Value));\n                   exception\n                      when Constraint_Error =>\n                         Error_Msg\n@@ -2847,14 +2753,16 @@ package body Prj.Nmsc is\n       List       : Array_Element_Id;\n       Debug_Name : String)\n    is\n-      Current   : Array_Element_Id := List;\n+      Current   : Array_Element_Id;\n       Element   : Array_Element;\n       Unit_Name : Name_Id;\n+\n    begin\n       if Current_Verbosity = High then\n          Write_Line (\"  Checking unit names in \" & Debug_Name);\n       end if;\n \n+      Current := List;\n       while Current /= No_Array_Element loop\n          Element := In_Tree.Array_Elements.Table (Current);\n          Element.Value.Value :=\n@@ -2918,7 +2826,7 @@ package body Prj.Nmsc is\n          Casing          : in out Casing_Type;\n          Casing_Defined  : out Boolean;\n          Separate_Suffix : in out File_Name_Type;\n-         Sep_Suffix_Loc  : in out Source_Ptr);\n+         Sep_Suffix_Loc  : out Source_Ptr);\n       --  Check attributes common to Ada_Only and Multi_Lang modes\n \n       ------------------\n@@ -2930,23 +2838,32 @@ package body Prj.Nmsc is\n          Casing          : in out Casing_Type;\n          Casing_Defined  : out Boolean;\n          Separate_Suffix : in out File_Name_Type;\n-         Sep_Suffix_Loc  : in out Source_Ptr)\n+         Sep_Suffix_Loc  : out Source_Ptr)\n       is\n-         Dot_Repl        : constant Variable_Value :=\n-           Util.Value_Of\n-             (Name_Dot_Replacement, Naming.Decl.Attributes, In_Tree);\n+         Dot_Repl      : constant Variable_Value :=\n+                           Util.Value_Of\n+                             (Name_Dot_Replacement,\n+                              Naming.Decl.Attributes,\n+                              In_Tree);\n          Casing_String : constant Variable_Value :=\n-           Util.Value_Of (Name_Casing, Naming.Decl.Attributes, In_Tree);\n-         Sep_Suffix : constant Variable_Value :=\n-           Util.Value_Of\n-             (Name_Separate_Suffix, Naming.Decl.Attributes, In_Tree);\n-\n-         Dot_Repl_Loc    : Source_Ptr;\n+                           Util.Value_Of\n+                             (Name_Casing,\n+                              Naming.Decl.Attributes,\n+                              In_Tree);\n+         Sep_Suffix    : constant Variable_Value :=\n+                           Util.Value_Of\n+                             (Name_Separate_Suffix,\n+                              Naming.Decl.Attributes,\n+                              In_Tree);\n+         Dot_Repl_Loc  : Source_Ptr;\n \n       begin\n+         Sep_Suffix_Loc := No_Location;\n+\n          if not Dot_Repl.Default then\n             pragma Assert\n               (Dot_Repl.Kind = Single, \"Dot_Replacement is not a string\");\n+\n             if Length_Of_Name (Dot_Repl.Value) = 0 then\n                Error_Msg\n                  (Project, In_Tree,\n@@ -2959,6 +2876,7 @@ package body Prj.Nmsc is\n \n             declare\n                Repl : constant String := Get_Name_String (Dot_Replacement);\n+\n             begin\n                --  Dot_Replacement cannot\n                --   - be empty\n@@ -2971,11 +2889,13 @@ package body Prj.Nmsc is\n                  or else Is_Alphanumeric (Repl (Repl'First))\n                  or else Is_Alphanumeric (Repl (Repl'Last))\n                  or else (Repl (Repl'First) = '_'\n-                          and then\n-                            (Repl'Length = 1\n-                             or else Is_Alphanumeric (Repl (Repl'First + 1))))\n+                           and then\n+                             (Repl'Length = 1\n+                               or else\n+                                 Is_Alphanumeric (Repl (Repl'First + 1))))\n                  or else (Repl'Length > 1\n-                          and then Index (Source => Repl, Pattern => \".\") /= 0)\n+                           and then\n+                             Index (Source => Repl, Pattern => \".\") /= 0)\n                then\n                   Error_Msg\n                     (Project, In_Tree,\n@@ -2997,7 +2917,7 @@ package body Prj.Nmsc is\n \n             declare\n                Casing_Image : constant String :=\n-                 Get_Name_String (Casing_String.Value);\n+                                Get_Name_String (Casing_String.Value);\n             begin\n                if Casing_Image'Length = 0 then\n                   Error_Msg\n@@ -3033,6 +2953,14 @@ package body Prj.Nmsc is\n             else\n                Separate_Suffix := Canonical_Case_File_Name (Sep_Suffix.Value);\n                Sep_Suffix_Loc  := Sep_Suffix.Location;\n+\n+               if Is_Illegal_Suffix (Separate_Suffix, Dot_Replacement) then\n+                  Err_Vars.Error_Msg_File_1 := Separate_Suffix;\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"{ is illegal for Separate_Suffix\",\n+                     Sep_Suffix.Location);\n+               end if;\n             end if;\n          end if;\n \n@@ -3319,8 +3247,34 @@ package body Prj.Nmsc is\n       ---------------------------\n \n       procedure Check_Naming_Ada_Only is\n-         Casing_Defined : Boolean;\n+         Casing_Defined  : Boolean;\n+         Spec_Suffix     : File_Name_Type;\n+         Body_Suffix     : File_Name_Type;\n+         Sep_Suffix_Loc  : Source_Ptr;\n+\n+         Ada_Spec_Suffix : constant Variable_Value :=\n+           Prj.Util.Value_Of\n+             (Index     => Name_Ada,\n+              Src_Index => 0,\n+              In_Array  => Data.Naming.Spec_Suffix,\n+              In_Tree   => In_Tree);\n+\n+         Ada_Body_Suffix : constant Variable_Value :=\n+           Prj.Util.Value_Of\n+             (Index     => Name_Ada,\n+              Src_Index => 0,\n+              In_Array  => Data.Naming.Body_Suffix,\n+              In_Tree   => In_Tree);\n+\n       begin\n+         --  We'll need the dot replacement below, so compute it first\n+         Check_Common\n+           (Dot_Replacement => Data.Naming.Dot_Replacement,\n+            Casing          => Data.Naming.Casing,\n+            Casing_Defined  => Casing_Defined,\n+            Separate_Suffix => Data.Naming.Separate_Suffix,\n+            Sep_Suffix_Loc  => Sep_Suffix_Loc);\n+\n          Data.Naming.Bodies :=\n            Util.Value_Of (Name_Body, Naming.Decl.Arrays, In_Tree);\n \n@@ -3339,70 +3293,81 @@ package body Prj.Nmsc is\n \n          --  Check Spec_Suffix\n \n-         declare\n-            Ada_Spec_Suffix : constant Variable_Value :=\n-              Prj.Util.Value_Of\n-                (Index     => Name_Ada,\n-                 Src_Index => 0,\n-                 In_Array  => Data.Naming.Spec_Suffix,\n-                 In_Tree   => In_Tree);\n+         if Ada_Spec_Suffix.Kind = Single\n+           and then Length_Of_Name (Ada_Spec_Suffix.Value) /= 0\n+         then\n+            Spec_Suffix := Canonical_Case_File_Name (Ada_Spec_Suffix.Value);\n+            Set_Spec_Suffix (In_Tree, \"ada\", Data.Naming, Spec_Suffix);\n \n-         begin\n-            if Ada_Spec_Suffix.Kind = Single\n-              and then Get_Name_String (Ada_Spec_Suffix.Value) /= \"\"\n+            if Is_Illegal_Suffix\n+              (Spec_Suffix, Data.Naming.Dot_Replacement)\n             then\n-               Set_Spec_Suffix\n-                 (In_Tree, \"ada\", Data.Naming,\n-                  Canonical_Case_File_Name (Ada_Spec_Suffix.Value));\n-               Data.Naming.Ada_Spec_Suffix_Loc := Ada_Spec_Suffix.Location;\n-\n-            else\n-               Set_Spec_Suffix\n-                 (In_Tree, \"ada\", Data.Naming, Default_Ada_Spec_Suffix);\n+               Err_Vars.Error_Msg_File_1 := Spec_Suffix;\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"{ is illegal for Spec_Suffix\",\n+                  Ada_Spec_Suffix.Location);\n             end if;\n \n-            Write_Attr\n-              (\"Spec_Suffix\", Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming));\n-         end;\n+         else\n+            Spec_Suffix := Default_Ada_Spec_Suffix;\n+            Set_Spec_Suffix (In_Tree, \"ada\", Data.Naming, Spec_Suffix);\n+         end if;\n+\n+         Write_Attr (\"Spec_Suffix\", Get_Name_String (Spec_Suffix));\n \n          --  Check Body_Suffix\n \n-         declare\n-            Ada_Body_Suffix : constant Variable_Value :=\n-              Prj.Util.Value_Of\n-                (Index     => Name_Ada,\n-                 Src_Index => 0,\n-                 In_Array  => Data.Naming.Body_Suffix,\n-                 In_Tree   => In_Tree);\n+         if Ada_Body_Suffix.Kind = Single\n+           and then Get_Name_String (Ada_Body_Suffix.Value) /= \"\"\n+         then\n+            Body_Suffix := Canonical_Case_File_Name (Ada_Body_Suffix.Value);\n+            Data.Naming.Separate_Suffix := Body_Suffix;\n+            Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Body_Suffix);\n \n-         begin\n-            if Ada_Body_Suffix.Kind = Single\n-              and then Get_Name_String (Ada_Body_Suffix.Value) /= \"\"\n+            if Is_Illegal_Suffix\n+              (Body_Suffix, Data.Naming.Dot_Replacement)\n             then\n-               Data.Naming.Separate_Suffix :=\n-                 Canonical_Case_File_Name (Ada_Body_Suffix.Value);\n-               Set_Body_Suffix\n-                 (In_Tree, \"ada\", Data.Naming, Data.Naming.Separate_Suffix);\n-               Data.Naming.Ada_Body_Suffix_Loc := Ada_Body_Suffix.Location;\n-\n-            else\n-               Data.Naming.Separate_Suffix := Default_Ada_Body_Suffix;\n-               Set_Body_Suffix\n-                 (In_Tree, \"ada\", Data.Naming, Default_Ada_Body_Suffix);\n+               Err_Vars.Error_Msg_File_1 := Body_Suffix;\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"{ is illegal for Body_Suffix\",\n+                  Ada_Body_Suffix.Location);\n             end if;\n \n-            Write_Attr\n-              (\"Body_Suffix\", Body_Suffix_Of (In_Tree, \"ada\", Data.Naming));\n-         end;\n+         else\n+            Body_Suffix := Default_Ada_Body_Suffix;\n+            Data.Naming.Separate_Suffix := Body_Suffix;\n+            Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Body_Suffix);\n+         end if;\n \n-         Check_Common\n-           (Dot_Replacement => Data.Naming.Dot_Replacement,\n-            Casing          => Data.Naming.Casing,\n-            Casing_Defined  => Casing_Defined,\n-            Separate_Suffix => Data.Naming.Separate_Suffix,\n-            Sep_Suffix_Loc  => Data.Naming.Sep_Suffix_Loc);\n+         Write_Attr (\"Body_Suffix\", Get_Name_String (Body_Suffix));\n+\n+         --  Spec_Suffix cannot be equal to Body_Suffix or Separate_Suffix,\n+         --  since that would cause a clear ambiguity. Note that we do\n+         --  allow a Spec_Suffix to have the same termination as one of\n+         --  these, which causes a potential ambiguity, but we resolve\n+         --  that my matching the longest possible suffix.\n \n-         Check_Ada_Naming_Scheme_Validity (Project, In_Tree, Data.Naming);\n+         if Spec_Suffix = Body_Suffix then\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"Body_Suffix (\"\"\" &\n+               Get_Name_String (Body_Suffix) &\n+               \"\"\") cannot be the same as Spec_Suffix.\",\n+               Ada_Body_Suffix.Location);\n+         end if;\n+\n+         if Body_Suffix /= Data.Naming.Separate_Suffix\n+           and then Spec_Suffix = Data.Naming.Separate_Suffix\n+         then\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"Separate_Suffix (\"\"\" &\n+               Get_Name_String (Data.Naming.Separate_Suffix) &\n+               \"\"\") cannot be the same as Spec_Suffix.\",\n+               Sep_Suffix_Loc);\n+         end if;\n       end Check_Naming_Ada_Only;\n \n       -----------------------------\n@@ -3422,10 +3387,10 @@ package body Prj.Nmsc is\n          declare\n             Dot_Replacement : File_Name_Type := No_File;\n             Separate_Suffix : File_Name_Type := No_File;\n-            Sep_Suffix_Loc  : Source_Ptr     := No_Location;\n             Casing          : Casing_Type    := All_Lower_Case;\n             Casing_Defined  : Boolean;\n             Lang_Id         : Language_Index;\n+            Sep_Suffix_Loc  : Source_Ptr;\n \n          begin\n             Check_Common\n@@ -3529,6 +3494,12 @@ package body Prj.Nmsc is\n                       File_Name_Type (Suffix.Value);\n                end if;\n \n+               --  ??? As opposed to what is done in Check_Naming_Ada_Only,\n+               --  we do not check whether spec_suffix=body_suffix, which\n+               --  should be illegal. Best would be to share this code into\n+               --  Check_Common, but we access the attributes from the project\n+               --  files slightly differently apparently.\n+\n                Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n             end loop;\n          end;\n@@ -3547,7 +3518,8 @@ package body Prj.Nmsc is\n    --  Start of processing for Check_Naming_Schemes\n \n    begin\n-      --  No Naming package or parsing a configuration file ? nothing to do\n+      --  No Naming package or parsing a configuration file? nothing to do\n+\n       if Naming_Id /= No_Package and not In_Configuration then\n          Naming := In_Tree.Packages.Table (Naming_Id);\n \n@@ -6657,7 +6629,7 @@ package body Prj.Nmsc is\n    -----------------------\n \n    procedure Compute_Unit_Name\n-     (Filename        : String;\n+     (File_Name       : File_Name_Type;\n       Dot_Replacement : File_Name_Type;\n       Separate_Suffix : File_Name_Type;\n       Body_Suffix     : File_Name_Type;\n@@ -6666,12 +6638,22 @@ package body Prj.Nmsc is\n       Kind            : out Source_Kind;\n       Unit            : out Name_Id)\n    is\n-      Last : Integer := Filename'Last;\n-      Sep_Len : constant Integer := Integer (Length_Of_Name (Separate_Suffix));\n-      Body_Len : constant Integer := Integer (Length_Of_Name (Body_Suffix));\n-      Spec_Len : constant Integer := Integer (Length_Of_Name (Spec_Suffix));\n-      Standard_GNAT : constant Boolean := Spec_Suffix = Default_Ada_Spec_Suffix\n-        and then Body_Suffix = Default_Ada_Body_Suffix;\n+      Filename : constant String := Get_Name_String (File_Name);\n+      Last     : Integer := Filename'Last;\n+      Sep_Len  : constant Integer :=\n+                   Integer (Length_Of_Name (Separate_Suffix));\n+      Body_Len : constant Integer :=\n+                   Integer (Length_Of_Name (Body_Suffix));\n+      Spec_Len : constant Integer :=\n+                   Integer (Length_Of_Name (Spec_Suffix));\n+\n+      Standard_GNAT : constant Boolean :=\n+                        Spec_Suffix = Default_Ada_Spec_Suffix\n+                          and then\n+                        Body_Suffix = Default_Ada_Body_Suffix;\n+\n+      Unit_Except : Unit_Exception;\n+      Masked      : Boolean  := False;\n    begin\n       Unit := No_Name;\n       Kind := Spec;\n@@ -6719,7 +6701,7 @@ package body Prj.Nmsc is\n       if File_Names_Case_Sensitive then\n          case Casing is\n             when All_Lower_Case =>\n-               for J in Filename'Range loop\n+               for J in Filename'First .. Last loop\n                   if Is_Letter (Filename (J))\n                     and then not Is_Lower (Filename (J))\n                   then\n@@ -6731,7 +6713,7 @@ package body Prj.Nmsc is\n                end loop;\n \n             when All_Upper_Case =>\n-               for J in Filename'Range loop\n+               for J in Filename'First .. Last loop\n                   if Is_Letter (Filename (J))\n                     and then not Is_Upper (Filename (J))\n                   then\n@@ -6752,6 +6734,7 @@ package body Prj.Nmsc is\n \n       declare\n          Dot_Repl : constant String := Get_Name_String (Dot_Replacement);\n+\n       begin\n          if Dot_Repl /= \".\" then\n             for Index in Filename'First .. Last loop\n@@ -6805,8 +6788,10 @@ package body Prj.Nmsc is\n                   Name_Buffer (2) := '.';\n \n                elsif S2 = '.' then\n-                  --  If it is potentially a run time source, disable\n-                  --  filling of the mapping file to avoid warnings.\n+\n+                  --  If it is potentially a run time source, disable filling\n+                  --  of the mapping file to avoid warnings.\n+\n                   Set_Mapping_File_Initial_State_To_Empty;\n                end if;\n             end if;\n@@ -6818,6 +6803,40 @@ package body Prj.Nmsc is\n \n       Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit);\n \n+      --  If there is a naming exception for the same unit, the file is not\n+      --  a source for the unit. Currently, this only applies in multi_lang\n+      --  mode, since Unit_Exceptions is no set in ada_only mode.\n+\n+      if Unit /= No_Name then\n+         Unit_Except := Unit_Exceptions.Get (Unit);\n+\n+         if Kind = Spec then\n+            Masked := Unit_Except.Spec /= No_File\n+              and then Unit_Except.Spec /= File_Name;\n+         else\n+            Masked := Unit_Except.Impl /= No_File\n+              and then Unit_Except.Impl /= File_Name;\n+         end if;\n+\n+         if Masked then\n+            if Current_Verbosity = High then\n+               Write_Str (\"   \"\"\" & Filename & \"\"\" contains the \");\n+\n+               if Kind = Spec then\n+                  Write_Str (\"spec of a unit found in \"\"\");\n+                  Write_Str (Get_Name_String (Unit_Except.Spec));\n+               else\n+                  Write_Str (\"body of a unit found in \"\"\");\n+                  Write_Str (Get_Name_String (Unit_Except.Impl));\n+               end if;\n+\n+               Write_Line (\"\"\" (ignored)\");\n+            end if;\n+\n+            Unit := No_Name;\n+         end if;\n+      end if;\n+\n       if Unit /= No_Name\n         and then Current_Verbosity = High\n       then\n@@ -6850,19 +6869,18 @@ package body Prj.Nmsc is\n       Kind     : Source_Kind;\n \n    begin\n-      if Info_Id = No_Ada_Naming_Exception then\n-         if Hostparm.OpenVMS then\n-            VMS_Name := Canonical_File_Name;\n-            Get_Name_String (VMS_Name);\n-\n-            if Name_Buffer (Name_Len) = '.' then\n-               Name_Len := Name_Len - 1;\n-               VMS_Name := Name_Find;\n-            end if;\n+      if Info_Id = No_Ada_Naming_Exception\n+        and then Hostparm.OpenVMS\n+      then\n+         VMS_Name := Canonical_File_Name;\n+         Get_Name_String (VMS_Name);\n \n-            Info_Id := Ada_Naming_Exceptions.Get (VMS_Name);\n+         if Name_Buffer (Name_Len) = '.' then\n+            Name_Len := Name_Len - 1;\n+            VMS_Name := Name_Find;\n          end if;\n \n+         Info_Id := Ada_Naming_Exceptions.Get (VMS_Name);\n       end if;\n \n       if Info_Id /= No_Ada_Naming_Exception then\n@@ -6874,7 +6892,7 @@ package body Prj.Nmsc is\n          Needs_Pragma := False;\n          Exception_Id := No_Ada_Naming_Exception;\n          Compute_Unit_Name\n-           (Filename       => Get_Name_String (Canonical_File_Name),\n+           (File_Name       => Canonical_File_Name,\n             Dot_Replacement => Naming.Dot_Replacement,\n             Separate_Suffix => Naming.Separate_Suffix,\n             Body_Suffix     => Body_Suffix_Id_Of (In_Tree, Name_Ada, Naming),\n@@ -6904,35 +6922,34 @@ package body Prj.Nmsc is\n    -----------------------\n \n    function Is_Illegal_Suffix\n-     (Suffix                          : String;\n-      Dot_Replacement_Is_A_Single_Dot : Boolean) return Boolean\n+     (Suffix          : File_Name_Type;\n+      Dot_Replacement : File_Name_Type) return Boolean\n    is\n+      Suffix_Str : constant String := Get_Name_String (Suffix);\n    begin\n-      if Suffix'Length = 0 or else Index (Suffix, \".\") = 0 then\n+      if Suffix_Str'Length = 0 or else Index (Suffix_Str, \".\") = 0 then\n          return True;\n       end if;\n \n       --  If dot replacement is a single dot, and first character of suffix is\n       --  also a dot\n \n-      if Dot_Replacement_Is_A_Single_Dot\n-        and then Suffix (Suffix'First) = '.'\n+      if Get_Name_String (Dot_Replacement) = \".\"\n+        and then Suffix_Str (Suffix_Str'First) = '.'\n       then\n-         for Index in Suffix'First + 1 .. Suffix'Last loop\n+         for Index in Suffix_Str'First + 1 .. Suffix_Str'Last loop\n \n             --  If there is another dot\n \n-            if Suffix (Index) = '.' then\n+            if Suffix_Str (Index) = '.' then\n \n                --  It is illegal to have a letter following the initial dot\n \n-               return Is_Letter (Suffix (Suffix'First + 1));\n+               return Is_Letter (Suffix_Str (Suffix_Str'First + 1));\n             end if;\n          end loop;\n       end if;\n \n-      --  Everything is OK\n-\n       return False;\n    end Is_Illegal_Suffix;\n \n@@ -7097,19 +7114,26 @@ package body Prj.Nmsc is\n       In_Tree : Project_Tree_Ref;\n       Data    : Project_Data)\n    is\n-      Excluded_Source_List_File : constant Variable_Value := Util.Value_Of\n-        (Name_Excluded_Source_List_File, Data.Decl.Attributes, In_Tree);\n+      Excluded_Source_List_File : constant Variable_Value :=\n+                                    Util.Value_Of\n+                                      (Name_Excluded_Source_List_File,\n+                                       Data.Decl.Attributes,\n+                                       In_Tree);\n+\n       Excluded_Sources          : Variable_Value := Util.Value_Of\n-        (Name_Excluded_Source_Files, Data.Decl.Attributes, In_Tree);\n-\n-      Current                   : String_List_Id;\n-      Element                   : String_Element;\n-      Location                  : Source_Ptr;\n-      Name                      : File_Name_Type;\n-      File                      : Prj.Util.Text_File;\n-      Line                      : String (1 .. 300);\n-      Last                      : Natural;\n-      Locally_Removed           : Boolean := False;\n+                                    (Name_Excluded_Source_Files,\n+                                     Data.Decl.Attributes,\n+                                     In_Tree);\n+\n+      Current         : String_List_Id;\n+      Element         : String_Element;\n+      Location        : Source_Ptr;\n+      Name            : File_Name_Type;\n+      File            : Prj.Util.Text_File;\n+      Line            : String (1 .. 300);\n+      Last            : Natural;\n+      Locally_Removed : Boolean := False;\n+\n    begin\n       --  If Excluded_Source_Files is not declared, check\n       --  Locally_Removed_Files.\n@@ -7631,15 +7655,18 @@ package body Prj.Nmsc is\n       Lang    : Name_List_Index) return Language_Index\n    is\n       Name     : constant Name_Id := In_Tree.Name_Lists.Table (Lang).Name;\n-      Language : Language_Index := Data.First_Language_Processing;\n+      Language : Language_Index;\n+\n    begin\n+      Language := Data.First_Language_Processing;\n       while Language /= No_Language_Index loop\n          if In_Tree.Languages_Data.Table (Language).Name = Name then\n             return Language;\n          end if;\n \n          Language := In_Tree.Languages_Data.Table (Language).Next;\n       end loop;\n+\n       return No_Language_Index;\n    end Get_Language_Processing_From_Lang;\n \n@@ -7650,7 +7677,6 @@ package body Prj.Nmsc is\n    procedure Check_File_Naming_Schemes\n      (In_Tree               : Project_Tree_Ref;\n       Data                  : in out Project_Data;\n-      Filename              : String;\n       File_Name             : File_Name_Type;\n       Alternate_Languages   : out Alternate_Language_Id;\n       Language              : out Language_Index;\n@@ -7660,11 +7686,12 @@ package body Prj.Nmsc is\n       Lang_Kind             : out Language_Kind;\n       Kind                  : out Source_Kind)\n    is\n+      Filename       : constant String := Get_Name_String (File_Name);\n       Config         : Language_Config;\n       Lang           : Name_List_Index := Data.Languages;\n       Tmp_Lang       : Language_Index;\n \n-      Header_File    : Boolean := False;\n+      Header_File : Boolean := False;\n       --  True if we found at least one language for which the file is a header\n       --  In such a case, we search for all possible languages where this is\n       --  also a header (C and C++ for instance), since the file might be used\n@@ -7680,9 +7707,6 @@ package body Prj.Nmsc is\n       --  file could belong to several languages (C and C++ for instance). Thus\n       --  if we found a header we'll check whether it matches other languages\n \n-      procedure Check_Unit_Based_Lang;\n-      --  Does the naming scheme test for unit-based languages\n-\n       ---------------------------\n       -- Check_File_Based_Lang --\n       ---------------------------\n@@ -7715,6 +7739,7 @@ package body Prj.Nmsc is\n                   Next     => Alternate_Languages);\n                Alternate_Languages :=\n                  Alternate_Language_Table.Last (In_Tree.Alt_Langs);\n+\n             else\n                Header_File := True;\n                Kind        := Spec;\n@@ -7724,71 +7749,6 @@ package body Prj.Nmsc is\n          end if;\n       end Check_File_Based_Lang;\n \n-      ---------------------------\n-      -- Check_Unit_Based_Lang --\n-      ---------------------------\n-\n-      procedure Check_Unit_Based_Lang is\n-         Masked      : Boolean  := False;\n-         Unit_Except : Unit_Exception;\n-      begin\n-         Compute_Unit_Name\n-           (Filename        => Filename,\n-            Dot_Replacement => Config.Naming_Data.Dot_Replacement,\n-            Separate_Suffix => Config.Naming_Data.Separate_Suffix,\n-            Body_Suffix     => Config.Naming_Data.Body_Suffix,\n-            Spec_Suffix     => Config.Naming_Data.Spec_Suffix,\n-            Casing          => Config.Naming_Data.Casing,\n-            Kind            => Kind,\n-            Unit            => Unit);\n-\n-         --  If there is a naming exception for the same unit, the file is not\n-         --  a source for the unit\n-\n-         if Unit /= No_Name then\n-            Unit_Except := Unit_Exceptions.Get (Unit);\n-\n-            if Kind = Spec then\n-               Masked := Unit_Except.Spec /= No_File\n-                 and then Unit_Except.Spec /= File_Name;\n-            else\n-               Masked := Unit_Except.Impl /= No_File\n-                 and then Unit_Except.Impl /= File_Name;\n-            end if;\n-\n-            if Masked then\n-               if Current_Verbosity = High then\n-                  Write_Str (\"   \"\"\" & Filename & \"\"\" contains the \");\n-\n-                  if Kind = Spec then\n-                     Write_Str (\"spec of a unit found in \"\"\");\n-                     Write_Str (Get_Name_String (Unit_Except.Spec));\n-                  else\n-                     Write_Str (\"body of a unit found in \"\"\");\n-                     Write_Str (Get_Name_String (Unit_Except.Impl));\n-                  end if;\n-\n-                  Write_Line (\"\"\" (ignored)\");\n-               end if;\n-\n-            else\n-               if Current_Verbosity = High then\n-                  if Kind = Spec then\n-                     Write_Str (\"     spec of \");\n-                  else\n-                     Write_Str (\"     body of \");\n-                  end if;\n-\n-                  Write_Str (Get_Name_String (Unit));\n-                  Write_Str (\" language: \");\n-                  Write_Line (Get_Name_String (Display_Language_Name));\n-               end if;\n-\n-               Language    := Tmp_Lang;\n-            end if;\n-         end if;\n-      end Check_Unit_Based_Lang;\n-\n    begin\n       Language              := No_Language_Index;\n       Alternate_Languages   := No_Alternate_Language;\n@@ -7823,8 +7783,20 @@ package body Prj.Nmsc is\n                   --  We know it belongs to a least a file_based language, no\n                   --  need to check unit-based ones.\n                   if not Header_File then\n-                     Check_Unit_Based_Lang;\n-                     exit when Language /= No_Language_Index;\n+                     Compute_Unit_Name\n+                       (File_Name       => File_Name,\n+                        Dot_Replacement => Config.Naming_Data.Dot_Replacement,\n+                        Separate_Suffix => Config.Naming_Data.Separate_Suffix,\n+                        Body_Suffix     => Config.Naming_Data.Body_Suffix,\n+                        Spec_Suffix     => Config.Naming_Data.Spec_Suffix,\n+                        Casing          => Config.Naming_Data.Casing,\n+                        Kind            => Kind,\n+                        Unit            => Unit);\n+\n+                     if Unit /= No_Name then\n+                        Language    := Tmp_Lang;\n+                        exit;\n+                     end if;\n                   end if;\n             end case;\n          end if;\n@@ -7872,6 +7844,7 @@ package body Prj.Nmsc is\n       Src_Ind           : Source_File_Index;\n       Unit              : Name_Id;\n       Source_To_Replace : Source_Id := No_Source;\n+\n       Language_Name         : Name_Id;\n       Display_Language_Name : Name_Id;\n       Lang_Kind             : Language_Kind;\n@@ -7946,7 +7919,6 @@ package body Prj.Nmsc is\n          Check_File_Naming_Schemes\n            (In_Tree               => In_Tree,\n             Data                  => Data,\n-            Filename              => Get_Name_String (File_Name),\n             File_Name             => File_Name,\n             Alternate_Languages   => Alternate_Languages,\n             Language              => Language,\n@@ -8227,12 +8199,14 @@ package body Prj.Nmsc is\n       In_Tree : Project_Tree_Ref;\n       Data    : in out Project_Data)\n    is\n-      Source : Source_Id := Data.First_Source;\n+      Source : Source_Id;\n       File   : File_Name_Type;\n       Unit   : Name_Id;\n+\n    begin\n       Unit_Exceptions.Reset;\n \n+      Source := Data.First_Source;\n       while Source /= No_Source loop\n          File := In_Tree.Sources.Table (Source).File;\n          Unit := In_Tree.Sources.Table (Source).Unit;\n@@ -8314,14 +8288,23 @@ package body Prj.Nmsc is\n          Excluded : File_Found := Excluded_Sources_Htable.Get_First;\n \n          procedure Exclude\n-           (Extended : Project_Id; Index : Unit_Index; Kind : Spec_Or_Body);\n+           (Extended : Project_Id;\n+            Index    : Unit_Index;\n+            Kind     : Spec_Or_Body);\n          --  If the current file (Excluded) belongs to the current project or\n          --  one that the current project extends, then mark this file/unit as\n          --  excluded. It is an error to locally remove a file from another\n          --  project.\n \n+         -------------\n+         -- Exclude --\n+         -------------\n+\n          procedure Exclude\n-           (Extended : Project_Id; Index : Unit_Index; Kind : Spec_Or_Body) is\n+           (Extended : Project_Id;\n+            Index    : Unit_Index;\n+            Kind     : Spec_Or_Body)\n+         is\n          begin\n             if Extended = Project\n               or else Is_Extending (Project, Extended, In_Tree)\n@@ -8354,16 +8337,20 @@ package body Prj.Nmsc is\n             end if;\n          end Exclude;\n \n+      --  Start of processing for Mark_Excluded_Sources\n+\n       begin\n          while Excluded /= No_File_Found loop\n             OK     := False;\n \n             case Get_Mode is\n             when Ada_Only =>\n+\n                --  ??? This loop could be the same as for Multi_Language if\n                --  we were setting In_Tree.First_Source when we search for\n                --  Ada sources (basically once we have removed the use of\n                --  Data.Ada_Sources).\n+\n                For_Each_Unit :\n                for Index in Unit_Table.First ..\n                  Unit_Table.Last (In_Tree.Units)\n@@ -8514,7 +8501,7 @@ package body Prj.Nmsc is\n \n       if (Get_Mode = Ada_Only and then Is_A_Language (In_Tree, Data, Name_Ada))\n         or else (Get_Mode = Multi_Language\n-                 and then Data.First_Language_Processing /= No_Language_Index)\n+                  and then Data.First_Language_Processing /= No_Language_Index)\n       then\n          if Get_Mode = Multi_Language then\n             Load_Naming_Exceptions (Project, In_Tree, Data);\n@@ -8560,9 +8547,9 @@ package body Prj.Nmsc is\n       end if;\n    end Path_Name_Of;\n \n-   -------------------------------\n+   -----------------------------------\n    -- Prepare_Ada_Naming_Exceptions --\n-   -------------------------------\n+   -----------------------------------\n \n    procedure Prepare_Ada_Naming_Exceptions\n      (List    : Array_Element_Id;"}, {"sha": "f595fd75361220571bc6e370f90ad682b819daf9", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -2535,11 +2535,14 @@ package body Prj.Proc is\n         (Imported     : in out Project_List;\n          Limited_With : Boolean)\n       is\n-         With_Clause : Project_Node_Id := First_With_Clause_Of\n-           (From_Project_Node, From_Project_Node_Tree);\n+         With_Clause : Project_Node_Id;\n          New_Project : Project_Id;\n          Proj_Node   : Project_Node_Id;\n+\n       begin\n+         With_Clause :=\n+           First_With_Clause_Of\n+             (From_Project_Node, From_Project_Node_Tree);\n          while Present (With_Clause) loop\n             Proj_Node :=\n               Non_Limited_Project_Node_Of\n@@ -2585,6 +2588,8 @@ package body Prj.Proc is\n          end loop;\n       end Process_Imported_Projects;\n \n+   --  Start of processing for Recursive_Process\n+\n    begin\n       if No (From_Project_Node) then\n          Project := No_Project;"}, {"sha": "6d55276f385f779716357ea2e4a5f30bffc08837", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,11 +75,8 @@ package body Prj is\n                        (Dot_Replacement           => Standard_Dot_Replacement,\n                         Casing                    => All_Lower_Case,\n                         Spec_Suffix               => No_Array_Element,\n-                        Ada_Spec_Suffix_Loc       => No_Location,\n                         Body_Suffix               => No_Array_Element,\n-                        Ada_Body_Suffix_Loc       => No_Location,\n                         Separate_Suffix           => No_File,\n-                        Sep_Suffix_Loc            => No_Location,\n                         Specs                     => No_Array_Element,\n                         Bodies                    => No_Array_Element,\n                         Specification_Exceptions  => No_Array_Element,\n@@ -654,9 +651,10 @@ package body Prj is\n       Extended  : Project_Id;\n       In_Tree   : Project_Tree_Ref) return Boolean\n    is\n-      Proj : Project_Id := Extending;\n+      Proj : Project_Id;\n \n    begin\n+      Proj := Extending;\n       while Proj /= No_Project loop\n          if Proj = Extended then\n             return True;"}, {"sha": "f1d8760999aaaac9d71da8dfa76e9fd037ad9a97", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -878,21 +878,14 @@ package Prj is\n       --  source file name of a spec.\n       --  Indexed by the programming language.\n \n-      Ada_Spec_Suffix_Loc : Source_Ptr := No_Location;\n-\n       Body_Suffix : Array_Element_Id := No_Array_Element;\n       --  The string to append to the unit name for the\n       --  source file name of a body.\n       --  Indexed by the programming language.\n \n-      Ada_Body_Suffix_Loc : Source_Ptr := No_Location;\n-\n       Separate_Suffix : File_Name_Type := No_File;\n       --  String to append to unit name for source file name of an Ada subunit\n \n-      Sep_Suffix_Loc : Source_Ptr := No_Location;\n-      --  Position in the project file source where Separate_Suffix is defined\n-\n       Specs : Array_Element_Id := No_Array_Element;\n       --  An associative array mapping individual specs to source file names\n       --  This is specific to Ada."}, {"sha": "b3ac024ddddef2a458e6230b0051db7e3fb3843e", "filename": "gcc/ada/s-osinte-mingw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fs-osinte-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fs-osinte-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-mingw.ads?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -357,7 +357,7 @@ private\n       --  section for the resource.\n \n       LockSemaphore : Win32.HANDLE;\n-      Reserved      : Win32.DWORD;\n+      SpinCount     : Win32.DWORD;\n    end record;\n \n end System.OS_Interface;"}, {"sha": "f473e0e7595c5728e8981beb93803444759fd810", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -527,8 +527,7 @@ package body System.Tasking.Initialization is\n       while C /= Null_Task loop\n          if C = T then\n             if Previous = Null_Task then\n-               All_Tasks_List :=\n-                 All_Tasks_List.Common.All_Tasks_Link;\n+               All_Tasks_List := All_Tasks_List.Common.All_Tasks_Link;\n             else\n                Previous.Common.All_Tasks_Link := C.Common.All_Tasks_Link;\n             end if;"}, {"sha": "62aee276f711bc99dda0f46fd5f9beb9c2da452e", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c0e0578aba733b7b336f8090efe957acc9509d/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=d9c0e0578aba733b7b336f8090efe957acc9509d", "patch": "@@ -515,8 +515,7 @@ package body System.Tasking.Stages is\n          raise Program_Error with \"potentially blocking operation\";\n       end if;\n \n-      pragma Debug\n-        (Debug.Trace (Self_ID, \"Create_Task\", 'C'));\n+      pragma Debug (Debug.Trace (Self_ID, \"Create_Task\", 'C'));\n \n       if Priority = Unspecified_Priority then\n          Base_Priority := Self_ID.Common.Base_Priority;"}]}