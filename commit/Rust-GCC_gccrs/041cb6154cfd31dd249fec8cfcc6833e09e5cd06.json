{"sha": "041cb6154cfd31dd249fec8cfcc6833e09e5cd06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQxY2I2MTU0Y2ZkMzFkZDI0OWZlYzhjZmNjNjgzM2UwOWU1Y2QwNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-11-20T11:46:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-20T11:46:41Z"}, "message": "Optimize updating of badness after applying inline\n\n        * ipa-inline.c (wrapper_heuristics_may_apply): Break out from ...\n\t(edge_badness): ... here.\n\t(inline_small_functions): Use monotonicity of badness calculation\n\tto avoid redundant updates.\n\nFrom-SVN: r278496", "tree": {"sha": "2fa13516e17fc4666b63160f4d7bb4df367f850c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fa13516e17fc4666b63160f4d7bb4df367f850c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/041cb6154cfd31dd249fec8cfcc6833e09e5cd06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041cb6154cfd31dd249fec8cfcc6833e09e5cd06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041cb6154cfd31dd249fec8cfcc6833e09e5cd06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041cb6154cfd31dd249fec8cfcc6833e09e5cd06/comments", "author": null, "committer": null, "parents": [{"sha": "140ee00a961fda084c1b4b3f0e7e489a917858f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140ee00a961fda084c1b4b3f0e7e489a917858f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140ee00a961fda084c1b4b3f0e7e489a917858f7"}], "stats": {"total": 39, "additions": 34, "deletions": 5}, "files": [{"sha": "79b8210eccc6548c24b6635a49c27c059f2e6fbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041cb6154cfd31dd249fec8cfcc6833e09e5cd06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041cb6154cfd31dd249fec8cfcc6833e09e5cd06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=041cb6154cfd31dd249fec8cfcc6833e09e5cd06", "patch": "@@ -1,3 +1,10 @@\n+2019-11-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (wrapper_heuristics_may_apply): Break out from ...\n+\t(edge_badness): ... here.\n+\t(inline_small_functions): Use monotonicity of badness calculation\n+\tto avoid redundant updates.\n+\n 2019-11-20  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-slp.c (vect_analyze_slp_instance): Dump"}, {"sha": "5d8b87a7bc3f3a5c25914f68dacb399eb18c1fba", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041cb6154cfd31dd249fec8cfcc6833e09e5cd06/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041cb6154cfd31dd249fec8cfcc6833e09e5cd06/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=041cb6154cfd31dd249fec8cfcc6833e09e5cd06", "patch": "@@ -1097,6 +1097,17 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n   return true;\n }\n \n+/* Return true if WHERE of SIZE is a possible candidate for wrapper heuristics\n+   in estimate_edge_badness.  */\n+\n+static bool\n+wrapper_heuristics_may_apply (struct cgraph_node *where, int size)\n+{\n+  return size < (DECL_DECLARED_INLINE_P (where->decl)\n+\t\t ? inline_insns_single (where, false)\n+\t\t : inline_insns_auto (where, false));\n+}\n+\n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n    the costs of all caller edges of nodes affected are recomputed so the\n@@ -1227,10 +1238,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t     and it is not called once.  */\n \t  if (!caller_info->single_caller && overall_growth < caller_growth\n \t      && caller_info->inlinable\n-\t      && ipa_size_summaries->get (caller)->size\n-\t\t < (DECL_DECLARED_INLINE_P (caller->decl)\n-\t\t    ? inline_insns_single (caller, false)\n-\t\t    : inline_insns_auto (caller, false)))\n+\t      && wrapper_heuristics_may_apply\n+\t     \t (caller, ipa_size_summaries->get (caller)->size))\n \t    {\n \t      if (dump)\n \t\tfprintf (dump_file,\n@@ -2158,11 +2167,24 @@ inline_small_functions (void)\n \t    fprintf (dump_file, \" Peeling recursion with depth %i\\n\", depth);\n \n \t  gcc_checking_assert (!callee->inlined_to);\n+\n+\t  int old_size = ipa_size_summaries->get (where)->size;\n+\t  sreal old_time = ipa_fn_summaries->get (where)->time;\n+\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n \t  reset_edge_caches (edge->callee);\n \t  add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n-\t  update_callee_keys (&edge_heap, where, updated_nodes);\n+\t  /* If caller's size and time increased we do not need to update\n+\t     all edges becuase badness is not going to decrease.  */\n+\t  if (old_size <= ipa_size_summaries->get (where)->size\n+\t      && old_time <= ipa_fn_summaries->get (where)->time\n+\t      /* Wrapper penalty may be non-monotonous in this respect.\n+\t         Fortunately it only affects small functions.  */\n+\t      && !wrapper_heuristics_may_apply (where, old_size))\n+\t    update_callee_keys (&edge_heap, edge->callee, updated_nodes);\n+\t  else\n+\t    update_callee_keys (&edge_heap, where, updated_nodes);\n \t}\n       where = edge->caller;\n       if (where->inlined_to)"}]}