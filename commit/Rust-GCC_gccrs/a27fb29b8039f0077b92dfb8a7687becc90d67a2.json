{"sha": "a27fb29b8039f0077b92dfb8a7687becc90d67a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI3ZmIyOWI4MDM5ZjAwNzdiOTJkZmI4YTc2ODdiZWNjOTBkNjdhMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-07-25T10:16:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-07-25T10:16:00Z"}, "message": "invoke.texi: Document -mabi=meabi, and expand on the EABI description.\n\n\t* doc/invoke.texi: Document -mabi=meabi, and expand on the EABI\n\tdescription.  Document -mips32, -mips64, and the associated -march\n\tvalues.  Describe the \"mipsN\" arguments to -march.  Say that the\n\t-mipsN options are equivalent to -march.  Reword the description\n\tof default type sizes.\n\t* toplev.h (target_flags_explicit): Declare.\n\t* toplev.c (target_flags_explicit): New var.\n\t(set_target_switch): Update target_flags_explicit.\n\t* config/mips/abi64.h (SUBTARGET_TARGET_OPTIONS): Undefine.\n\t* config/mips/elf64.h (MIPS_ISA_DEFAULT): Undefine.\n\t* config/mips/iris6.h (SUBTARGET_ASM_SPEC): -mabi=64 implies -mips3.\n\t* config/mips/isa3264.h (MIPS_ENABLE_EMBEDDED_O32): Undefine.\n\t* config/mips/mips.h (mips_cpu_info): New struct.\n\t(mips_cpu_string, mips_explicit_type_size_string): Remove.\n\t(mips_cpu_info_table, mips_arch_info, mips_tune_info): Declare.\n\t(MIPS_CPP_SET_PROCESSOR): New macro.\n\t(TARGET_CPP_BUILTINS): Declare a macro for each supported processor.\n\tDefine _MIPS_ARCH and _MIPS_TUNE.\n\t(MIPS_ISA_DEFAULT): Don't provide a default value.  Instead...\n\t(MIPS_CPU_STRING_DEFAULT): Set to \"from-abi\" if neither it nor\n\tMIPS_ISA_DEFAULT were already defined.\n\t(MULTILIB_DEFAULTS): Add MULTILIB_ABI_DEFAULT.\n\t(TARGET_OPTIONS): Remove -mcpu and -mexplicit-type-size.\n\t(ABI_NEEDS_32BIT_REGS, ABI_NEEDS_64BIT_REGS): New.\n\t(GAS_ASM_SPEC): Remove -march, -mcpu, -mgp* and -mabi rules.\n\t(ABI_GAS_ASM_SPEC): Remove.\n\t(MULTILIB_ABI_DEFAULT, ASM_ABI_DEFAULT_SPEC): New macros.\n\t(ASM_SPEC): Add -mgp32, -mgp64, -march, -mabi=eabi and -mabi=o64.\n\tInvoke %(asm_abi_default_spec) if no ABI was specified.\n\t(CC1_SPEC): Remove ISA -> register-size rules.\n\t(EXTRA_SPECS): Remove abi_gas_asm_spec.  Add asm_abi_default_spec.\n\t* config/mips/mips.c (mips_arch_info, mips_tune_info): New vars.\n\t(mips_cpu_string, mips_explicit_type_size_string): Remove.\n\t(mips_cpu_info_table): New array.\n\t(mips_set_architecture, mips_set_tune): New fns.\n\t(override_options): Rework to make -mipsN equivalent to -march.\n\tDetect more erroneous cases, including those removed from CC1_SPEC.\n\tDon't change the ABI based on architecture, or vice versa.\n\tUnify logic with GAS.\n\t(mips_asm_file_start): Get architecture name from mips_arch_info.\n\t(mips_strict_matching_cpu_name_p, mips_matching_cpu_name_p): New fns.\n\t(mips_parse_cpu): Take the name of the option as argument.  Handle\n\t'from-abi'.  Raise an error if the option is wrong.\n\t(mips_cpu_info_from_isa): New fn.\n\n[gcc/testsuite]\n\t* gcc.dg/mips-args-[123].c: New tests.\n\nFrom-SVN: r55747", "tree": {"sha": "045a0c27b96c99d3585900bc306c64fdbb6bed02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/045a0c27b96c99d3585900bc306c64fdbb6bed02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a27fb29b8039f0077b92dfb8a7687becc90d67a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27fb29b8039f0077b92dfb8a7687becc90d67a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a27fb29b8039f0077b92dfb8a7687becc90d67a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27fb29b8039f0077b92dfb8a7687becc90d67a2/comments", "author": null, "committer": null, "parents": [{"sha": "6bbdc7595cf95df31ffadb01265aca7da4c147b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bbdc7595cf95df31ffadb01265aca7da4c147b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bbdc7595cf95df31ffadb01265aca7da4c147b8"}], "stats": {"total": 1046, "additions": 629, "deletions": 417}, "files": [{"sha": "ad40abd9b0bd5d27f73127088b4368a69d4ed0cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -1,3 +1,50 @@\n+2002-07-25  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* doc/invoke.texi: Document -mabi=meabi, and expand on the EABI\n+\tdescription.  Document -mips32, -mips64, and the associated -march\n+\tvalues.  Describe the \"mipsN\" arguments to -march.  Say that the\n+\t-mipsN options are equivalent to -march.  Reword the description\n+\tof default type sizes.\n+\t* toplev.h (target_flags_explicit): Declare.\n+\t* toplev.c (target_flags_explicit): New var.\n+\t(set_target_switch): Update target_flags_explicit.\n+\t* config/mips/abi64.h (SUBTARGET_TARGET_OPTIONS): Undefine.\n+\t* config/mips/elf64.h (MIPS_ISA_DEFAULT): Undefine.\n+\t* config/mips/iris6.h (SUBTARGET_ASM_SPEC): -mabi=64 implies -mips3.\n+\t* config/mips/isa3264.h (MIPS_ENABLE_EMBEDDED_O32): Undefine.\n+\t* config/mips/mips.h (mips_cpu_info): New struct.\n+\t(mips_cpu_string, mips_explicit_type_size_string): Remove.\n+\t(mips_cpu_info_table, mips_arch_info, mips_tune_info): Declare.\n+\t(MIPS_CPP_SET_PROCESSOR): New macro.\n+\t(TARGET_CPP_BUILTINS): Declare a macro for each supported processor.\n+\tDefine _MIPS_ARCH and _MIPS_TUNE.\n+\t(MIPS_ISA_DEFAULT): Don't provide a default value.  Instead...\n+\t(MIPS_CPU_STRING_DEFAULT): Set to \"from-abi\" if neither it nor\n+\tMIPS_ISA_DEFAULT were already defined.\n+\t(MULTILIB_DEFAULTS): Add MULTILIB_ABI_DEFAULT.\n+\t(TARGET_OPTIONS): Remove -mcpu and -mexplicit-type-size.\n+\t(ABI_NEEDS_32BIT_REGS, ABI_NEEDS_64BIT_REGS): New.\n+\t(GAS_ASM_SPEC): Remove -march, -mcpu, -mgp* and -mabi rules.\n+\t(ABI_GAS_ASM_SPEC): Remove.\n+\t(MULTILIB_ABI_DEFAULT, ASM_ABI_DEFAULT_SPEC): New macros.\n+\t(ASM_SPEC): Add -mgp32, -mgp64, -march, -mabi=eabi and -mabi=o64.\n+\tInvoke %(asm_abi_default_spec) if no ABI was specified.\n+\t(CC1_SPEC): Remove ISA -> register-size rules.\n+\t(EXTRA_SPECS): Remove abi_gas_asm_spec.  Add asm_abi_default_spec.\n+\t* config/mips/mips.c (mips_arch_info, mips_tune_info): New vars.\n+\t(mips_cpu_string, mips_explicit_type_size_string): Remove.\n+\t(mips_cpu_info_table): New array.\n+\t(mips_set_architecture, mips_set_tune): New fns.\n+\t(override_options): Rework to make -mipsN equivalent to -march.\n+\tDetect more erroneous cases, including those removed from CC1_SPEC.\n+\tDon't change the ABI based on architecture, or vice versa.\n+\tUnify logic with GAS.\n+\t(mips_asm_file_start): Get architecture name from mips_arch_info.\n+\t(mips_strict_matching_cpu_name_p, mips_matching_cpu_name_p): New fns.\n+\t(mips_parse_cpu): Take the name of the option as argument.  Handle\n+\t'from-abi'.  Raise an error if the option is wrong.\n+\t(mips_cpu_info_from_isa): New fn.\n+\n 2002-07-25  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (tablejump_mips161): Use gen_rtx_LABEL_REF."}, {"sha": "86b8aa819d18cdebdb9c3e9a4a6e2a0748bd2168", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -21,11 +21,6 @@ Boston, MA 02111-1307, USA.  */\n /* Macros to implement the 64 bit ABI.  This file is meant to be included\n    after mips.h.  */\n \n-#undef SUBTARGET_TARGET_OPTIONS\n-#define SUBTARGET_TARGET_OPTIONS \\\n-  { \"abi=\", &mips_abi_string,\t\t\t\t\t\t\\\n-      \"Specify ABI to use\"},\n-\n #undef STACK_BOUNDARY\n #define STACK_BOUNDARY \\\n   ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI) \\"}, {"sha": "4fd74313ed0cd9fdc19a94311ee4f4b9266c0765", "filename": "gcc/config/mips/elf64.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Felf64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Felf64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Felf64.h?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -22,15 +22,12 @@ Boston, MA 02111-1307, USA.  */\n \n #define OBJECT_FORMAT_ELF\n \n-/* Default to -mips3.  */\n+/* If an embedded ABI is selected, prefer to generate 64-bit code.\n+   Implies -mips3 in such cases.  */\n #ifndef TARGET_DEFAULT\n #define TARGET_DEFAULT MASK_FLOAT64|MASK_64BIT\n #endif\n \n-#ifndef MIPS_ISA_DEFAULT\n-#define MIPS_ISA_DEFAULT 3\n-#endif\n-\n /* This should change to n32 when it is supported in gas.  */\n #ifndef MIPS_ABI_DEFAULT\n #define MIPS_ABI_DEFAULT ABI_O64"}, {"sha": "e42fa541ec1f57fb4838951aa623019270d0653e", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -238,7 +238,7 @@ Boston, MA 02111-1307, USA.  */\n    on the mipsX option.  */\n /* If no mips[3,4] option given, give the appropriate default for mabi=X */\n #undef SUBTARGET_ASM_SPEC\n-#define SUBTARGET_ASM_SPEC \"%{!mabi*:-n32} %{!mips*: %{!mabi*:-mips3} %{mabi=n32:-mips3} %{mabi=64:-mips4}}\"\n+#define SUBTARGET_ASM_SPEC \"%{!mabi*:-n32} %{!mips*: %{!mabi*:-mips3} %{mabi=n32|mabi=64:-mips3}}\"\n \n /* Must pass -g0 to the assembler, otherwise it may overwrite our\n    debug info with its own debug info.  */"}, {"sha": "b7ab601cfec32dd6ed4e1c9bd584e7fa176eeedd", "filename": "gcc/config/mips/isa3264.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fisa3264.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fisa3264.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fisa3264.h?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -27,10 +27,6 @@ Boston, MA 02111-1307, USA.  */\n #define MIPS_ABI_DEFAULT ABI_MEABI\n #endif\n \n-#ifndef MIPS_ENABLE_EMBEDDED_O32\n-#define MIPS_ENABLE_EMBEDDED_O32 1\n-#endif\n-\n #ifndef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n #endif"}, {"sha": "8c5a34ffbc786bd84c91c96b4c44811cb8d11c9c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 289, "deletions": 317, "changes": 606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -119,7 +119,15 @@ static int symbolic_expression_p                PARAMS ((rtx));\n static bool mips_assemble_integer\t  PARAMS ((rtx, unsigned int, int));\n static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void mips_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static enum processor_type mips_parse_cpu       PARAMS ((const char *));\n+static void mips_set_architecture    PARAMS ((const struct mips_cpu_info *));\n+static void mips_set_tune\t     PARAMS ((const struct mips_cpu_info *));\n+static bool mips_strict_matching_cpu_name_p\tPARAMS ((const char *,\n+\t\t\t\t\t\t\t const char *));\n+static bool mips_matching_cpu_name_p\t\tPARAMS ((const char *,\n+\t\t\t\t\t\t\t const char *));\n+static const struct mips_cpu_info *mips_parse_cpu   PARAMS ((const char *,\n+\t\t\t\t\t\t\t      const char *));\n+static const struct mips_cpu_info *mips_cpu_info_from_isa PARAMS ((int));\n static void copy_file_data\t\t\tPARAMS ((FILE *, FILE *));\n #ifdef TARGET_IRIX6\n static void iris6_asm_named_section_1\t\tPARAMS ((const char *,\n@@ -294,9 +302,11 @@ enum cmp_type branch_type;\n \n /* The target cpu for code generation.  */\n enum processor_type mips_arch;\n+const struct mips_cpu_info *mips_arch_info;\n \n /* The target cpu for optimization and scheduling.  */\n enum processor_type mips_tune;\n+const struct mips_cpu_info *mips_tune_info;\n \n /* which instruction set architecture to use.  */\n int mips_isa;\n@@ -305,7 +315,6 @@ int mips_isa;\n int mips_abi;\n \n /* Strings to hold which cpu and instruction set architecture to use.  */\n-const char *mips_cpu_string;\t/* for -mcpu=<xxx> */\n const char *mips_arch_string;   /* for -march=<xxx> */\n const char *mips_tune_string;   /* for -mtune=<xxx> */\n const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n@@ -320,11 +329,6 @@ int mips16;\n    just a way to avoid using up another bit in target_flags.  */\n const char *mips_no_mips16_string;\n \n-/* This is only used to determine if an type size setting option was\n-   explicitly specified (-mlong64, -mint64, -mlong32).  The specs\n-   set this option if such an option is used.  */\n-const char *mips_explicit_type_size_string;\n-\n /* Whether we are generating mips16 hard float code.  In mips16 mode\n    we always set TARGET_SOFT_FLOAT; this variable is nonzero if\n    -msoft-float was not specified by the user, which means that we\n@@ -562,6 +566,54 @@ enum reg_class mips_char_to_class[256] =\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n };\n \f\n+/* A table describing all the processors gcc knows about.  Names are\n+   matched in the order listed.  The first mention of an ISA level is\n+   taken as the canonical name for that ISA.\n+\n+   To ease comparison, please keep this table in the same order as\n+   gas's mips_cpu_info_table[].  */\n+const struct mips_cpu_info mips_cpu_info_table[] = {\n+  /* Entries for generic ISAs */\n+  { \"mips1\", PROCESSOR_R3000, 1 },\n+  { \"mips2\", PROCESSOR_R6000, 2 },\n+  { \"mips3\", PROCESSOR_R4000, 3 },\n+  { \"mips4\", PROCESSOR_R8000, 4 },\n+  { \"mips32\", PROCESSOR_R4KC, 32 },\n+  { \"mips64\", PROCESSOR_R5KC, 64 },\n+\n+  /* MIPS I */\n+  { \"r3000\", PROCESSOR_R3000, 1 },\n+  { \"r2000\", PROCESSOR_R3000, 1 }, /* = r3000 */\n+  { \"r3900\", PROCESSOR_R3900, 1 },\n+\n+  /* MIPS II */\n+  { \"r6000\", PROCESSOR_R6000, 2 },\n+\n+  /* MIPS III */\n+  { \"r4000\", PROCESSOR_R4000, 3 },\n+  { \"vr4100\", PROCESSOR_R4100, 3 },\n+  { \"vr4300\", PROCESSOR_R4300, 3 },\n+  { \"r4400\", PROCESSOR_R4000, 3 }, /* = r4000 */\n+  { \"r4600\", PROCESSOR_R4600, 3 },\n+  { \"orion\", PROCESSOR_R4600, 3 }, /* = r4600 */\n+  { \"r4650\", PROCESSOR_R4650, 3 },\n+\n+  /* MIPS IV */\n+  { \"r8000\", PROCESSOR_R8000, 4 },\n+  { \"vr5000\", PROCESSOR_R5000, 4 },\n+\n+  /* MIPS 32 */\n+  { \"4kc\", PROCESSOR_R4KC, 32 },\n+  { \"4kp\", PROCESSOR_R4KC, 32 }, /* = 4kc */\n+\n+  /* MIPS 64 */\n+  { \"5kc\", PROCESSOR_R5KC, 64 },\n+  { \"20kc\", PROCESSOR_R20KC, 64 },\n+\n+  /* End marker */\n+  { 0, 0, 0 }\n+};\n+\f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n@@ -4931,16 +4983,44 @@ abort_with_insn (insn, reason)\n   abort ();\n }\n \f\n+/* Set up globals to generate code for the ISA or processor\n+   described by INFO.  */\n+\n+static void\n+mips_set_architecture (info)\n+     const struct mips_cpu_info *info;\n+{\n+  if (info != 0)\n+    {\n+      mips_arch_info = info;\n+      mips_arch = info->cpu;\n+      mips_isa = info->isa;\n+    }\n+}\n+\n+\n+/* Likewise for tuning.  */\n+\n+static void\n+mips_set_tune (info)\n+     const struct mips_cpu_info *info;\n+{\n+  if (info != 0)\n+    {\n+      mips_tune_info = info;\n+      mips_tune = info->cpu;\n+    }\n+}\n+\n+\n /* Set up the threshold for data to go into the small data area, instead\n    of the normal data area, and detect any conflicts in the switches.  */\n \n void\n override_options ()\n {\n-  register int i, start;\n-  register int regno;\n-  register enum machine_mode mode;\n-  register enum processor_type mips_cpu;\n+  int i, start, regno;\n+  enum machine_mode mode;\n \n   mips_section_threshold = g_switch_set ? g_switch_value : MIPS_DEFAULT_GVALUE;\n \n@@ -4958,250 +5038,137 @@ override_options ()\n     target_flags &= ~((TARGET_DEFAULT) & (MASK_SOFT_FLOAT | MASK_SINGLE_FLOAT));\n #endif\n \n-  /* Get the architectural level.  */\n-  if (mips_isa_string == 0)\n-    mips_isa = MIPS_ISA_DEFAULT;\n+  /* Interpret -mabi.  */\n+  mips_abi = MIPS_ABI_DEFAULT;\n+  if (mips_abi_string != 0)\n+    {\n+      if (strcmp (mips_abi_string, \"32\") == 0)\n+\tmips_abi = ABI_32;\n+      else if (strcmp (mips_abi_string, \"o64\") == 0)\n+\tmips_abi = ABI_O64;\n+      else if (strcmp (mips_abi_string, \"n32\") == 0)\n+\tmips_abi = ABI_N32;\n+      else if (strcmp (mips_abi_string, \"64\") == 0)\n+\tmips_abi = ABI_64;\n+      else if (strcmp (mips_abi_string, \"eabi\") == 0)\n+\tmips_abi = ABI_EABI;\n+      else if (strcmp (mips_abi_string, \"meabi\") == 0)\n+\tmips_abi = ABI_MEABI;\n+      else\n+\tfatal_error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n+    }\n+\n+  /* The following code determines the architecture and register size.\n+     Similar code was added to GAS 2.14 (see tc-mips.c:md_after_parse_args()).\n+     The GAS and GCC code should be kept in sync as much as possible.  */\n \n-  else if (mips_isa_string != 0\n-\t   && mips_arch_string != 0)\n-      warning (\"The -march option is incompatible to -mipsN and therefore ignored.\");\n+  if (mips_arch_string != 0)\n+    mips_set_architecture (mips_parse_cpu (\"-march\", mips_arch_string));\n \n-  else if (ISDIGIT (*mips_isa_string))\n+  if (mips_tune_string != 0)\n+    mips_set_tune (mips_parse_cpu (\"-mtune\", mips_tune_string));\n+\n+  if (mips_isa_string != 0)\n     {\n-      mips_isa = atoi (mips_isa_string);\n-      if (mips_isa == 16)\n+      /* Handle -mipsN.  */\n+      int level = atoi (mips_isa_string);\n+      if (level == 16)\n \t{\n-\t  /* -mno-mips16 overrides -mips16.  */\n+\t  /* -mips16 specifies an ASE rather than a processor, so don't\n+\t     change mips_arch here.  -mno-mips16 overrides -mips16.  */\n \t  if (mips_no_mips16_string == NULL)\n-\t    {\n-\t      target_flags |= MASK_MIPS16;\n-\t      if (TARGET_64BIT)\n-\t\tmips_isa = 3;\n-\t      else\n-\t\tmips_isa = MIPS_ISA_DEFAULT;\n-\t    }\n-\t  else\n-\t    {\n-\t      mips_isa = MIPS_ISA_DEFAULT;\n-\t    }\n+\t    target_flags |= MASK_MIPS16;\n \t}\n-      else if (mips_isa < 1\n-\t       || (mips_isa > 4\n-\t\t   && mips_isa != 32\n-\t\t   && mips_isa != 64))\n+      else if (mips_arch_info != 0)\n \t{\n-\t  error (\"-mips%d not supported\", mips_isa);\n-\t  mips_isa = 1;\n+\t  /* -march takes precedence over -mipsN, since it is more descriptive.\n+\t     There's no harm in specifying both as long as the ISA levels\n+\t     are the same.  */\n+\t  if (mips_isa != level)\n+\t    error (\"-mips%d conflicts with the other architecture options, which specify a MIPS%d processor\",\n+\t\t   level, mips_isa);\n \t}\n-    }\n-\n-  else\n-    {\n-      error (\"bad value (%s) for -mips switch\", mips_isa_string);\n-      mips_isa = 1;\n-    }\n-\n-#ifdef MIPS_ABI_DEFAULT\n-  /* Get the ABI to use.  */\n-  if (mips_abi_string == (char *) 0)\n-    mips_abi = MIPS_ABI_DEFAULT;\n-  else if (! strcmp (mips_abi_string, \"32\"))\n-    mips_abi = ABI_32;\n-  else if (! strcmp (mips_abi_string, \"o64\"))\n-    mips_abi = ABI_O64;\n-  else if (! strcmp (mips_abi_string, \"n32\"))\n-    mips_abi = ABI_N32;\n-  else if (! strcmp (mips_abi_string, \"64\"))\n-    mips_abi = ABI_64;\n-  else if (! strcmp (mips_abi_string, \"eabi\"))\n-    mips_abi = ABI_EABI;\n-  else if (! strcmp (mips_abi_string, \"meabi\"))\n-    mips_abi = ABI_MEABI;\n-  else\n-    error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n-\n-  /* A specified ISA defaults the ABI if it was not specified.  */\n-  if (mips_abi_string == 0 && mips_isa_string\n-      && mips_abi != ABI_EABI\n-      && mips_abi != ABI_O64\n-      && mips_abi != ABI_MEABI)\n-    {\n-      if (mips_isa == 64)\n-\tmips_abi = ABI_O64;\n       else\n \t{\n-\t  if (! ISA_HAS_64BIT_REGS)\n-\t    mips_abi = ABI_32;\n-\t  else if (mips_abi != ABI_N32)\n-\t    mips_abi = ABI_64;\n+\t  mips_set_architecture (mips_cpu_info_from_isa (level));\n+\t  if (mips_arch_info == 0)\n+\t    error (\"bad value (%s) for -mips switch\", mips_isa_string);\n \t}\n     }\n \n-#ifdef MIPS_CPU_STRING_DEFAULT\n-  /* A specified ABI defaults the ISA if it was not specified.  */\n-  else if (mips_isa_string == 0 && mips_abi_string\n-\t   && mips_abi != ABI_EABI && mips_abi != ABI_O64)\n-    {\n-      if (mips_abi == ABI_32)\n-\tmips_isa = 1;\n-      else if (mips_abi == ABI_N32)\n-\tmips_isa = 3;\n-      else\n-\tmips_isa = 4;\n-    }\n-#endif\n-\n-  /* If both ABI and ISA were specified, check for conflicts.  */\n-  else if (mips_isa_string && mips_abi_string)\n+  if (mips_arch_info == 0)\n     {\n-      if (! ISA_HAS_64BIT_REGS && (mips_abi == ABI_N32 || mips_abi == ABI_64\n-\t\t\t     || mips_abi == ABI_O64))\n-\terror (\"-mabi=%s does not support -mips%d\", mips_abi_string, mips_isa);\n-    }\n-\n-  /* Override TARGET_DEFAULT if necessary.  */\n-  if (mips_abi == ABI_32)\n-    target_flags &= ~ (MASK_FLOAT64|MASK_64BIT);\n-\n-  /* If no type size setting options (-mlong64,-mint64,-mlong32) were used\n-     then set the type sizes.  In the EABI in 64 bit mode, longs and\n-     pointers are 64 bits.  Likewise for the SGI Irix6 N64 ABI.  */\n-  if (mips_explicit_type_size_string == NULL\n-      && ((mips_abi == ABI_EABI && TARGET_64BIT)\n-\t  || mips_abi == ABI_64))\n-    target_flags |= MASK_LONG64;\n-\n+#ifdef MIPS_CPU_STRING_DEFAULT\n+      mips_set_architecture (mips_parse_cpu (\"default CPU\",\n+\t\t\t\t\t     MIPS_CPU_STRING_DEFAULT));\n #else\n-  if (mips_abi_string)\n-    error (\"this target does not support the -mabi switch\");\n+      mips_set_architecture (mips_cpu_info_from_isa (MIPS_ISA_DEFAULT));\n #endif\n+    }\n \n-#ifdef MIPS_CPU_STRING_DEFAULT\n-  /* ??? There is a minor inconsistency here.  If the user specifies an ISA\n-     greater than that supported by the default processor, then the user gets\n-     an error.  Normally, the compiler will just default to the base level cpu\n-     for the indicated isa.  */\n-  if (mips_arch_string == 0)\n-    mips_arch_string = MIPS_CPU_STRING_DEFAULT;\n-  if (mips_tune_string == 0)\n-    mips_tune_string = MIPS_CPU_STRING_DEFAULT;\n-#endif\n+  if (ABI_NEEDS_64BIT_REGS && !ISA_HAS_64BIT_REGS)\n+    error (\"-march=%s is not compatible with the selected ABI\",\n+\t   mips_arch_info->name);\n \n-  /* Identify the processor type.  */\n+  /* Optimize for mips_arch, unless -mtune selects a different processor.  */\n+  if (mips_tune_info == 0)\n+    mips_set_tune (mips_arch_info);\n \n-  if (mips_cpu_string != 0)\n+  if ((target_flags_explicit & MASK_64BIT) != 0)\n     {\n-      mips_cpu = mips_parse_cpu (mips_cpu_string);\n-      if (mips_cpu == PROCESSOR_DEFAULT)\n-\t{\n-\t  error (\"bad value (%s) for -mcpu= switch\", mips_cpu_string);\n-\t  mips_cpu_string = \"default\";\n-\t}\n-      mips_arch = mips_cpu;\n-      mips_tune = mips_cpu;\n-    }\n-\n-  if (mips_arch_string == 0\n-      || ! strcmp (mips_arch_string, \"default\")\n-      || ! strcmp (mips_arch_string, \"DEFAULT\"))\n-    {\n-      switch (mips_isa)\n-\t{\n-\tdefault:\n-\t  mips_arch_string = \"3000\";\n-\t  mips_arch = PROCESSOR_R3000;\n-\t  break;\n-\tcase 2:\n-\t  mips_arch_string = \"6000\";\n-\t  mips_arch = PROCESSOR_R6000;\n-\t  break;\n-\tcase 3:\n-\t  mips_arch_string = \"4000\";\n-\t  mips_arch = PROCESSOR_R4000;\n-\t  break;\n-\tcase 4:\n-\t  mips_arch_string = \"8000\";\n-\t  mips_arch = PROCESSOR_R8000;\n-\t  break;\n-\tcase 32:\n-          mips_arch_string = \"4kc\";\n-          mips_arch = PROCESSOR_R4KC;\n-          break;\n-        case 64:\n-          mips_arch_string = \"5kc\";\n-          mips_arch = PROCESSOR_R5KC;\n-          break;\n-\t}\n+      /* The user specified the size of the integer registers.  Make sure\n+\t it agrees with the ABI and ISA.  */\n+      if (TARGET_64BIT && !ISA_HAS_64BIT_REGS)\n+\terror (\"-mgp64 used with a 32-bit processor\");\n+      else if (!TARGET_64BIT && ABI_NEEDS_64BIT_REGS)\n+\terror (\"-mgp32 used with a 64-bit ABI\");\n+      else if (TARGET_64BIT && ABI_NEEDS_32BIT_REGS)\n+\terror (\"-mgp64 used with a 32-bit ABI\");\n     }\n   else\n     {\n-      mips_arch = mips_parse_cpu (mips_arch_string);\n-      if (mips_arch == PROCESSOR_DEFAULT)\n-\t{\n-\t  error (\"bad value (%s) for -march= switch\", mips_arch_string);\n-\t  mips_arch_string = \"default\";\n-\t}\n-    }\n-  if (mips_tune_string == 0\n-      || ! strcmp (mips_tune_string, \"default\")\n-      || ! strcmp (mips_tune_string, \"DEFAULT\"))\n-    {\n-      if (mips_arch != PROCESSOR_DEFAULT)\n-\tmips_tune = mips_arch;\n+      /* Infer the integer register size from the ABI and processor.\n+\t Restrict ourselves to 32-bit registers if that's all the\n+\t processor has, or if the ABI cannot handle 64-bit registers.  */\n+      if (ABI_NEEDS_32BIT_REGS || !ISA_HAS_64BIT_REGS)\n+\ttarget_flags &= ~MASK_64BIT;\n       else\n-      switch (mips_isa)\n-\t{\n-\tdefault:\n-\t  mips_tune_string = \"3000\";\n-\t  mips_tune = PROCESSOR_R3000;\n-\t  break;\n-\tcase 2:\n-\t  mips_tune_string = \"6000\";\n-\t  mips_tune = PROCESSOR_R6000;\n-\t  break;\n-\tcase 3:\n-\t  mips_tune_string = \"4000\";\n-\t  mips_tune = PROCESSOR_R4000;\n-\t  break;\n-\tcase 4:\n-\t  mips_tune_string = \"8000\";\n-\t  mips_tune = PROCESSOR_R8000;\n-\t  break;\n-\tcase 32:\n-\t  mips_tune_string = \"4kc\";\n-\t  mips_tune = PROCESSOR_R4KC;\n-\t  break;\n-\tcase 64:\n-\t  mips_tune_string = \"5kc\";\n-\t  mips_tune = PROCESSOR_R5KC;\n-\t  break;\n-\t}\n+\ttarget_flags |= MASK_64BIT;\n+    }\n \n+  if ((target_flags_explicit & MASK_FLOAT64) != 0)\n+    {\n+      /* Really, -mfp32 and -mfp64 are ornamental options.  There's\n+\t only one right answer here.  */\n+      if (TARGET_64BIT && TARGET_DOUBLE_FLOAT && !TARGET_FLOAT64)\n+\terror (\"unsupported combination: %s\", \"-mgp64 -mfp32 -mdouble-float\");\n+      else if (!TARGET_64BIT && TARGET_FLOAT64)\n+\terror (\"unsupported combination: %s\", \"-mgp32 -mfp64\");\n+      else if (TARGET_SINGLE_FLOAT && TARGET_FLOAT64)\n+\terror (\"unsupported combination: %s\", \"-mfp64 -msingle-float\");\n     }\n   else\n     {\n-       mips_tune = mips_parse_cpu (mips_tune_string);\n-      if (mips_tune == PROCESSOR_DEFAULT)\n-\t{\n-\t  error (\"bad value (%s) for -mtune= switch\", mips_tune_string);\n-\t  mips_tune_string = \"default\";\n-\t}\n+      /* -msingle-float selects 32-bit float registers.  Otherwise the\n+\t float registers should be the same size as the integer ones.  */\n+      if (TARGET_64BIT && TARGET_DOUBLE_FLOAT)\n+\ttarget_flags |= MASK_FLOAT64;\n+      else\n+\ttarget_flags &= ~MASK_FLOAT64;\n     }\n \n-  /* make sure sizes of ints/longs/etc. are ok */\n-  if (! ISA_HAS_64BIT_REGS)\n-    {\n-      if (TARGET_FLOAT64)\n-\t{\n-\t  error (\"-mips%d does not support 64 bit fp registers\", mips_isa);\n-\t  target_flags &= ~ MASK_FLOAT64;\n-\t}\n+  /* End of code shared with GAS.  */\n \n-      else if (TARGET_64BIT)\n-\t{\n-\t  error (\"-mips%d does not support 64 bit gp registers\", mips_isa);\n-\t  target_flags &= ~MASK_64BIT;\n-\t}\n+  if ((target_flags_explicit & MASK_LONG64) == 0)\n+    {\n+      /* If no type size setting options (-mlong64,-mint64,-mlong32)\n+\t were used, then set the type sizes.  In the EABI in 64 bit mode,\n+\t longs and pointers are 64 bits.  Likewise for the SGI Irix6 N64\n+\t ABI.  */\n+      if ((mips_abi == ABI_EABI && TARGET_64BIT) || mips_abi == ABI_64)\n+\ttarget_flags |= MASK_LONG64;\n+      else\n+\ttarget_flags &= ~MASK_LONG64;\n     }\n \n   if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n@@ -6361,7 +6328,7 @@ mips_asm_file_start (stream)\n   if (flag_verbose_asm)\n     fprintf (stream, \"\\n%s -G value = %d, Arch = %s, ISA = %d\\n\",\n \t     ASM_COMMENT_START,\n-\t     mips_section_threshold, mips_arch_string, mips_isa);\n+\t     mips_section_threshold, mips_arch_info->name, mips_isa);\n }\n \f\n /* If we are optimizing the global pointer, emit the text section now and any\n@@ -10166,115 +10133,120 @@ mips_output_conditional_branch (insn,\n   /* NOTREACHED */\n   return 0;\n }\n+\f\n+/* Return true if GIVEN is the same as CANONICAL, or if it is CANONICAL\n+   with a final \"000\" replaced by \"k\".  Ignore case.\n+\n+   Note: this function is shared between GCC and GAS.  */\n \n-static enum processor_type\n-mips_parse_cpu (cpu_string)\n-     const char *cpu_string;\n+static bool\n+mips_strict_matching_cpu_name_p (canonical, given)\n+     const char *canonical, *given;\n {\n-  const char *p = cpu_string;\n-  int seen_v = 0;\n-  enum processor_type cpu;\n-  int warn_upper_case = 0;\n+  while (*given != 0 && TOLOWER (*given) == TOLOWER (*canonical))\n+    given++, canonical++;\n \n-  /* We need to cope with the various \"vr\" prefixes for the NEC 4300\n-     and 4100 processors.  */\n-  if (*p == 'v' || *p == 'V')\n-    {\n-      if (*p == 'V')\n-\twarn_upper_case = 1;\n-      seen_v = 1, p++;\n-    }\n+  return ((*given == 0 && *canonical == 0)\n+\t  || (strcmp (canonical, \"000\") == 0 && strcasecmp (given, \"k\") == 0));\n+}\n \n-  if (*p == 'r' || *p == 'R')\n-    {\n-      if (*p == 'R')\n-\twarn_upper_case = 1;\n-      p++;\n-    }\n \n-  if (warn_upper_case)\n-    warning (\"the cpu name must be lower case\");\n+/* Return true if GIVEN matches CANONICAL, where GIVEN is a user-supplied\n+   CPU name.  We've traditionally allowed a lot of variation here.\n \n-  /* Since there is no difference between a R2000 and R3000 in\n-     terms of the scheduler, we collapse them into just an R3000.  */\n+   Note: this function is shared between GCC and GAS.  */\n \n-  cpu = PROCESSOR_DEFAULT;\n-  switch (*p)\n-    {\n-    case '2':\n-      if (!strcmp (p, \"2000\") || !strcmp (p, \"2k\") || !strcmp (p, \"2K\"))\n-\tcpu = PROCESSOR_R3000;\n-      else if (!strcmp (p, \"20kc\") || !strcmp (p, \"20Kc\") )\n-        cpu = PROCESSOR_R20KC;\n-      break;\n+static bool\n+mips_matching_cpu_name_p (canonical, given)\n+     const char *canonical, *given;\n+{\n+  /* First see if the name matches exactly, or with a final \"000\"\n+     turned into \"k\".  */\n+  if (mips_strict_matching_cpu_name_p (canonical, given))\n+    return true;\n \n-    case '3':\n-      if (!strcmp (p, \"3000\") || !strcmp (p, \"3k\") || !strcmp (p, \"3K\"))\n-\tcpu = PROCESSOR_R3000;\n-      else if (!strcmp (p, \"3900\"))\n-\tcpu = PROCESSOR_R3900;\n-      break;\n+  /* If not, try comparing based on numerical designation alone.\n+     See if GIVEN is an unadorned number, or 'r' followed by a number.  */\n+  if (TOLOWER (*given) == 'r')\n+    given++;\n+  if (!ISDIGIT (*given))\n+    return false;\n \n-    case '4':\n-      if (!strcmp (p, \"4000\") || !strcmp (p, \"4k\") || !strcmp (p, \"4K\"))\n-\tcpu = PROCESSOR_R4000;\n-      /* The vr4100 is a non-FP ISA III processor with some extra\n-\t instructions.  */\n-      else if (!strcmp (p, \"4100\"))\n-\t  cpu = PROCESSOR_R4100;\n-      /* The vr4300 is a standard ISA III processor, but with a different\n-\t pipeline.  */\n-      else if (!strcmp (p, \"4300\"))\n-\tcpu = PROCESSOR_R4300;\n-      /* The r4400 is exactly the same as the r4000 from the compiler's\n-\t viewpoint.  */\n-      else if (!strcmp (p, \"4400\"))\n-\tcpu = PROCESSOR_R4000;\n-      else if (!strcmp (p, \"4600\"))\n-\tcpu = PROCESSOR_R4600;\n-      else if (!strcmp (p, \"4650\"))\n-\tcpu = PROCESSOR_R4650;\n-      /* The 4kc and 4kp processor cores are the same for\n-\t scheduling purposes; they both implement the MIPS32\n-\t ISA and only differ in their memory management\n-\t methods.  */\n-      else if (!strcmp (p, \"4kc\") || !strcmp (p, \"4Kc\")\n-               || !strcmp (p, \"4kp\") || !strcmp (p, \"4Kp\") )\n-\tcpu = PROCESSOR_R4KC;\n-      break;\n+  /* Skip over some well-known prefixes in the canonical name,\n+     hoping to find a number there too.  */\n+  if (TOLOWER (canonical[0]) == 'v' && TOLOWER (canonical[1]) == 'r')\n+    canonical += 2;\n+  else if (TOLOWER (canonical[0]) == 'r' && TOLOWER (canonical[1]) == 'm')\n+    canonical += 2;\n+  else if (TOLOWER (canonical[0]) == 'r')\n+    canonical += 1;\n \n-    case '5':\n-      if (!strcmp (p, \"5000\") || !strcmp (p, \"5k\") || !strcmp (p, \"5K\"))\n-\tcpu = PROCESSOR_R5000;\n-      else if (!strcmp (p, \"5kc\") || !strcmp (p, \"5Kc\") )\n-          cpu = PROCESSOR_R5KC;\n-      break;\n+  return mips_strict_matching_cpu_name_p (canonical, given);\n+}\n \n-    case '6':\n-      if (!strcmp (p, \"6000\") || !strcmp (p, \"6k\") || !strcmp (p, \"6K\"))\n-\tcpu = PROCESSOR_R6000;\n-      break;\n \n-    case '8':\n-      if (!strcmp (p, \"8000\"))\n-\tcpu = PROCESSOR_R8000;\n-      break;\n+/* Parse an option that takes the name of a processor as its argument.\n+   OPTION is the name of the option and CPU_STRING is the argument.\n+   Return the corresponding processor enumeration if the CPU_STRING is\n+   recognized, otherwise report an error and return null.\n \n-    case 'o':\n-      if (!strcmp (p, \"orion\"))\n-\tcpu = PROCESSOR_R4600;\n-      break;\n-    }\n+   A similar function exists in GAS.  */\n+\n+static const struct mips_cpu_info *\n+mips_parse_cpu (option, cpu_string)\n+     const char *option, *cpu_string;\n+{\n+  const struct mips_cpu_info *p;\n+  const char *s;\n \n-  if (seen_v\n-      && cpu != PROCESSOR_R4300\n-      && cpu != PROCESSOR_R4100\n-      && cpu != PROCESSOR_R5000)\n-    cpu = PROCESSOR_DEFAULT;\n+  /* In the past, we allowed upper-case CPU names, but it doesn't\n+     work well with the multilib machinery.  */\n+  for (s = cpu_string; *s != 0; s++)\n+    if (ISUPPER (*s))\n+      {\n+\twarning (\"the cpu name must be lower case\");\n+\tbreak;\n+      }\n \n-  return cpu;\n+  /* 'from-abi' selects the most compatible architecture for the given\n+     ABI: MIPS I for 32-bit ABIs and MIPS III for 64-bit ABIs.  For the\n+     EABIs, we have to decide whether we're using the 32-bit or 64-bit\n+     version.  Look first at the -mgp options, if given, otherwise base\n+     the choice on MASK_64BIT in TARGET_DEFAULT.  */\n+  if (strcasecmp (cpu_string, \"from-abi\") == 0)\n+    return mips_cpu_info_from_isa (ABI_NEEDS_32BIT_REGS ? 1\n+\t\t\t\t   : ABI_NEEDS_64BIT_REGS ? 3\n+\t\t\t\t   : (TARGET_64BIT ? 3 : 1));\n+\n+  /* 'default' has traditionally been a no-op.  Probably not very useful.  */\n+  if (strcasecmp (cpu_string, \"default\") == 0)\n+    return 0;\n+\n+  for (p = mips_cpu_info_table; p->name != 0; p++)\n+    if (mips_matching_cpu_name_p (p->name, cpu_string))\n+      return p;\n+\n+  error (\"bad value (%s) for %s\", cpu_string, option);\n+  return 0;\n }\n \n+\n+/* Return the processor associated with the given ISA level, or null\n+   if the ISA isn't valid.  */\n+\n+static const struct mips_cpu_info *\n+mips_cpu_info_from_isa (isa)\n+     int isa;\n+{\n+  const struct mips_cpu_info *p;\n+\n+  for (p = mips_cpu_info_table; p->name != 0; p++)\n+    if (p->isa == isa)\n+      return p;\n+\n+  return 0;\n+}\n+\f\n /* Adjust the cost of INSN based on the relationship between INSN that\n    is dependent on DEP_INSN through the dependence LINK.  The default\n    is to make no adjustment to COST."}, {"sha": "84b6880ddf1dd1cb9437c6ae08548b64d5421035", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 109, "deletions": 25, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -118,6 +118,23 @@ enum block_move_type {\n   BLOCK_MOVE_LAST\t\t\t/* generate just the last store */\n };\n \n+/* Information about one recognised processor.  Defined here for the\n+   benefit of TARGET_CPU_CPP_BUILTINS.  */\n+struct mips_cpu_info {\n+  /* The 'canonical' name of the processor as far as GCC is concerned.\n+     It's typically a manufacturer's prefix followed by a numerical\n+     designation.  It should be lower case.  */\n+  const char *name;\n+\n+  /* The internal processor number that most closely matches this\n+     entry.  Several processors can have the same value, if there's no\n+     difference between them from GCC's point of view.  */\n+  enum processor_type cpu;\n+\n+  /* The ISA level that the processor implements.  */\n+  int isa;\n+};\n+\n extern char mips_reg_names[][8];\t/* register names (a0 vs. $4).  */\n extern char mips_print_operand_punct[256]; /* print_operand punctuation chars */\n extern const char *current_function_file; /* filename current function is in */\n@@ -146,14 +163,12 @@ extern int mips_isa;\t\t\t/* architectural level */\n extern int mips16;\t\t\t/* whether generating mips16 code */\n extern int mips16_hard_float;\t\t/* mips16 without -msoft-float */\n extern int mips_entry;\t\t\t/* generate entry/exit for mips16 */\n-extern const char *mips_cpu_string;\t/* for -mcpu=<xxx> */\n extern const char *mips_arch_string;    /* for -march=<xxx> */\n extern const char *mips_tune_string;    /* for -mtune=<xxx> */\n extern const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n extern const char *mips_abi_string;\t/* for -mabi={32,n32,64} */\n extern const char *mips_entry_string;\t/* for -mentry */\n extern const char *mips_no_mips16_string;/* for -mno-mips16 */\n-extern const char *mips_explicit_type_size_string;/* for -mexplicit-type-size */\n extern const char *mips_cache_flush_func;/* for -mflush-func= and -mno-flush-func */\n extern int mips_split_addresses;\t/* perform high/lo_sum support */\n extern int dslots_load_total;\t\t/* total # load related delay slots */\n@@ -167,6 +182,9 @@ extern GTY(()) rtx mips_load_reg2;\t/* 2nd reg to check for load delay */\n extern GTY(()) rtx mips_load_reg3;\t/* 3rd reg to check for load delay */\n extern GTY(()) rtx mips_load_reg4;\t/* 4th reg to check for load delay */\n extern int mips_string_length;\t\t/* length of strings for mips16 */\n+extern const struct mips_cpu_info mips_cpu_info_table[];\n+extern const struct mips_cpu_info *mips_arch_info;\n+extern const struct mips_cpu_info *mips_tune_info;\n \n /* Functions to change what output section we are using.  */\n extern void\t\tsdata_section PARAMS ((void));\n@@ -342,6 +360,25 @@ extern void\t\tsbss_section PARAMS ((void));\n #define TUNE_MIPS5000               (mips_tune == PROCESSOR_R5000)\n #define TUNE_MIPS6000               (mips_tune == PROCESSOR_R6000)\n \n+/* Define preprocessor macros for the -march and -mtune options.\n+   PREFIX is either _MIPS_ARCH or _MIPS_TUNE, INFO is the selected\n+   processor.  If INFO's canonical name is \"foo\", define PREFIX to\n+   be \"foo\", and define an additional macro PREFIX_FOO.  */\n+#define MIPS_CPP_SET_PROCESSOR(PREFIX, INFO)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char *macro, *p;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      macro = concat ((PREFIX), \"_\", (INFO)->name, NULL);\t\\\n+      for (p = macro; *p != 0; p++)\t\t\t\t\\\n+\t*p = TOUPPER (*p);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      builtin_define (macro);\t\t\t\t\t\\\n+      builtin_define_with_value ((PREFIX), (INFO)->name, 1);\t\\\n+      free (macro);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n /* Target CPU builtins.  */\n #define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n@@ -355,16 +392,16 @@ extern void\t\tsbss_section PARAMS ((void));\n       if (!flag_iso)\t\t\t\t\t\t\\\n \t  builtin_define (\"mips\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n+      /* Treat _R3000 and _R4000 like register-size defines,\t\\\n+\t which is how they've historically been used.  */\t\\\n       if (TARGET_64BIT)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  builtin_define (\"__mips64\");     \t\t\t\\\n-\t  /* Silly, but will do until processor defines.  */\t\\\n \t  builtin_define_std (\"R4000\");\t\t\t\t\\\n \t  builtin_define (\"_R4000\");\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  /* Ditto.  */\t\t\t\t\t\t\\\n \t  builtin_define_std (\"R3000\");\t\t\t\t\\\n \t  builtin_define (\"_R3000\");\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n@@ -376,6 +413,9 @@ extern void\t\tsbss_section PARAMS ((void));\n       if (TARGET_MIPS16)\t\t\t\t\t\\\n \t  builtin_define (\"__mips16\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n+      MIPS_CPP_SET_PROCESSOR (\"_MIPS_ARCH\", mips_arch_info);\t\\\n+      MIPS_CPP_SET_PROCESSOR (\"_MIPS_TUNE\", mips_tune_info);\t\\\n+\t\t\t\t\t\t\t\t\\\n       if (ISA_MIPS1)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  builtin_define (\"__mips=1\");\t\t\t\t\\\n@@ -605,8 +645,11 @@ extern void\t\tsbss_section PARAMS ((void));\n #define TARGET_ENDIAN_DEFAULT MASK_BIG_ENDIAN\n #endif\n \n+/* 'from-abi' makes a good default: you get whatever the ABI requires.  */\n #ifndef MIPS_ISA_DEFAULT\n-#define MIPS_ISA_DEFAULT 1\n+#ifndef MIPS_CPU_STRING_DEFAULT\n+#define MIPS_CPU_STRING_DEFAULT \"from-abi\"\n+#endif\n #endif\n \n #ifdef IN_LIBGCC2\n@@ -656,7 +699,8 @@ extern void\t\tsbss_section PARAMS ((void));\n #endif\n \n #ifndef MULTILIB_DEFAULTS\n-#define MULTILIB_DEFAULTS { MULTILIB_ENDIAN_DEFAULT, MULTILIB_ISA_DEFAULT }\n+#define MULTILIB_DEFAULTS \\\n+    { MULTILIB_ENDIAN_DEFAULT, MULTILIB_ISA_DEFAULT, MULTILIB_ABI_DEFAULT }\n #endif\n \n /* We must pass -EL to the linker by default for little endian embedded\n@@ -675,20 +719,18 @@ extern void\t\tsbss_section PARAMS ((void));\n #define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   SUBTARGET_TARGET_OPTIONS\t\t\t\t\t\t\\\n-  { \"cpu=\",\t&mips_cpu_string,\t\t\t\t\t\\\n-      N_(\"Specify CPU for scheduling purposes\")},\t\t\t\\\n   { \"tune=\",    &mips_tune_string,\t\t\t                \\\n       N_(\"Specify CPU for scheduling purposes\")},                       \\\n   { \"arch=\",    &mips_arch_string,                                      \\\n       N_(\"Specify CPU for code generation purposes\")},                  \\\n+  { \"abi=\", &mips_abi_string,\t\t\t\t\t\t\\\n+      N_(\"Specify an ABI\")},\t\t\t\t\t\t\\\n   { \"ips\",\t&mips_isa_string,\t\t\t\t\t\\\n       N_(\"Specify a Standard MIPS ISA\")},\t\t\t\t\\\n   { \"entry\",\t&mips_entry_string,\t\t\t\t\t\\\n       N_(\"Use mips16 entry/exit psuedo ops\")},\t\t\t\t\\\n   { \"no-mips16\", &mips_no_mips16_string,\t\t\t\t\\\n       N_(\"Don't use MIPS16 instructions\")},\t\t\t\t\\\n-  { \"explicit-type-size\", &mips_explicit_type_size_string,\t\t\\\n-      NULL},\t\t\t\t\t\t\t\t\\\n   { \"no-flush-func\", &mips_cache_flush_func,\t\t\t\t\\\n       N_(\"Don't call any cache flush functions\")},\t\t\t\\\n   { \"flush-func=\", &mips_cache_flush_func,\t\t\t\t\\\n@@ -716,6 +758,16 @@ extern void\t\tsbss_section PARAMS ((void));\n #define BRANCH_LIKELY_P()\tGENERATE_BRANCHLIKELY\n #define HAVE_SQRT_P()\t\t(!ISA_MIPS1)\n \n+/* True if the ABI can only work with 64-bit integer registers.  We\n+   generally allow ad-hoc variations for TARGET_SINGLE_FLOAT, but\n+   otherwise floating-point registers must also be 64-bit.  */\n+#define ABI_NEEDS_64BIT_REGS\t(mips_abi == ABI_64\t\t\t\\\n+\t\t\t\t || mips_abi == ABI_O64\t\t\t\\\n+\t\t\t\t || mips_abi == ABI_N32)\n+\n+/* Likewise for 32-bit regs.  */\n+#define ABI_NEEDS_32BIT_REGS\t(mips_abi == ABI_32)\n+\n /* ISA has instructions for managing 64 bit fp and gp regs (eg. mips3).  */\n #define ISA_HAS_64BIT_REGS\t(ISA_MIPS3\t\t\t\t\\\n \t\t\t\t || ISA_MIPS4\t\t\t\t\\\n@@ -911,7 +963,7 @@ while (0)\n /* GAS_ASM_SPEC is passed when using gas, rather than the MIPS\n    assembler.  */\n \n-#define GAS_ASM_SPEC \"%{march=*} %{mtune=*} %{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64} %(abi_gas_asm_spec) %{mabi=32:%{!mips*:-mips1}}\"\n+#define GAS_ASM_SPEC \"%{mtune=*} %{v}\"\n \n \n extern int mips_abi;\n@@ -920,8 +972,43 @@ extern int mips_abi;\n #define MIPS_ABI_DEFAULT ABI_32\n #endif\n \n-#ifndef ABI_GAS_ASM_SPEC\n-#define ABI_GAS_ASM_SPEC \"\"\n+/* Use the most portable ABI flag for the ASM specs.  */\n+\n+#if MIPS_ABI_DEFAULT == ABI_32\n+#define MULTILIB_ABI_DEFAULT \"mabi=32\"\n+#define ASM_ABI_DEFAULT_SPEC \"-32\"\n+#endif\n+\n+#if MIPS_ABI_DEFAULT == ABI_O64\n+#define MULTILIB_ABI_DEFAULT \"mabi=o64\"\n+#define ASM_ABI_DEFAULT_SPEC \"-mabi=o64\"\n+#endif\n+\n+#if MIPS_ABI_DEFAULT == ABI_N32\n+#define MULTILIB_ABI_DEFAULT \"mabi=n32\"\n+#define ASM_ABI_DEFAULT_SPEC \"-n32\"\n+#endif\n+\n+#if MIPS_ABI_DEFAULT == ABI_64\n+#define MULTILIB_ABI_DEFAULT \"mabi=64\"\n+#define ASM_ABI_DEFAULT_SPEC \"-64\"\n+#endif\n+\n+#if MIPS_ABI_DEFAULT == ABI_EABI\n+#define MULTILIB_ABI_DEFAULT \"mabi=eabi\"\n+#define ASM_ABI_DEFAULT_SPEC \"-mabi=eabi\"\n+#endif\n+\n+#if MIPS_ABI_DEFAULT == ABI_MEABI\n+/* Most GAS don't know about MEABI.  */\n+#define MULTILIB_ABI_DEFAULT \"mabi=meabi\"\n+#define ASM_ABI_DEFAULT_SPEC \"\"\n+#endif\n+\n+/* Only ELF targets can switch the ABI.  */\n+#ifndef OBJECT_FORMAT_ELF\n+#undef ASM_ABI_DEFAULT_SPEC\n+#define ASM_ABI_DEFAULT_SPEC \"\"\n #endif\n \n /* TARGET_ASM_SPEC is used to select either MIPS_AS_ASM_SPEC or\n@@ -969,7 +1056,11 @@ extern int mips_abi;\n #define SUBTARGET_ASM_SPEC \"\"\n #endif\n \n-/* ASM_SPEC is the set of arguments to pass to the assembler.  */\n+/* ASM_SPEC is the set of arguments to pass to the assembler.  Note: we\n+   pass -mgp32, -mgp64, -march, -mabi=eabi and -meabi=o64 regardless of\n+   whether we're using GAS.  These options can only be used properly\n+   with GAS, and it is better to get an error from a non-GAS assembler\n+   than to silently generate bad code.  */\n \n #undef ASM_SPEC\n #define ASM_SPEC \"\\\n@@ -978,7 +1069,9 @@ extern int mips_abi;\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n %{membedded-pic} \\\n-%{mabi=32:-32}%{mabi=o32:-32}%{mabi=n32:-n32}%{mabi=64:-64}%{mabi=n64:-64} \\\n+%{mabi=32:-32}%{mabi=n32:-n32}%{mabi=64:-64}%{mabi=n64:-64} \\\n+%{mabi=eabi} %{mabi=o64} %{!mabi*: %(asm_abi_default_spec)} \\\n+%{mgp32} %{mgp64} %{march=*} \\\n %(target_asm_spec) \\\n %(subtarget_asm_spec)\"\n \n@@ -1049,15 +1142,6 @@ extern int mips_abi;\n #ifndef CC1_SPEC\n #define CC1_SPEC \"\\\n %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n-%{mips1:-mfp32 -mgp32} %{mips2:-mfp32 -mgp32}\\\n-%{mips3:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n-%{mips4:%{!msingle-float:%{!m4650:-mfp64}} -mgp64} \\\n-%{mips32:-mfp32 -mgp32} \\\n-%{mips64:%{!msingle-float:-mfp64} -mgp64} \\\n-%{mfp64:%{msingle-float:%emay not use both -mfp64 and -msingle-float}} \\\n-%{mfp64:%{m4650:%emay not use both -mfp64 and -m4650}} \\\n-%{mint64|mlong64|mlong32:-mexplicit-type-size }\\\n-%{mgp32: %{mfp64:%emay not use both -mgp32 and -mfp64} %{!mfp32: -mfp32}} \\\n %{G*} %{EB:-meb} %{EL:-mel} %{EB:%{EL:%emay not use both -EB and -EL}} \\\n %{save-temps: } \\\n %(subtarget_cc1_spec)\"\n@@ -1088,12 +1172,12 @@ extern int mips_abi;\n   { \"subtarget_cpp_spec\", SUBTARGET_CPP_SPEC },\t\t\t\t\\\n   { \"mips_as_asm_spec\", MIPS_AS_ASM_SPEC },\t\t\t\t\\\n   { \"gas_asm_spec\", GAS_ASM_SPEC },\t\t\t\t\t\\\n-  { \"abi_gas_asm_spec\", ABI_GAS_ASM_SPEC },                             \\\n   { \"target_asm_spec\", TARGET_ASM_SPEC },\t\t\t\t\\\n   { \"subtarget_mips_as_asm_spec\", SUBTARGET_MIPS_AS_ASM_SPEC }, \t\\\n   { \"subtarget_asm_optimizing_spec\", SUBTARGET_ASM_OPTIMIZING_SPEC },\t\\\n   { \"subtarget_asm_debugging_spec\", SUBTARGET_ASM_DEBUGGING_SPEC },\t\\\n   { \"subtarget_asm_spec\", SUBTARGET_ASM_SPEC },\t\t\t\t\\\n+  { \"asm_abi_default_spec\", ASM_ABI_DEFAULT_SPEC },\t\t\t\\\n   { \"endian_spec\", ENDIAN_SPEC },\t\t\t\t\t\\\n   SUBTARGET_EXTRA_SPECS\n "}, {"sha": "427f5c47384af1d0391a9cb819b254af96fd3642", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 79, "deletions": 60, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -6976,65 +6976,77 @@ These @samp{-m} options are defined for the MIPS family of computers:\n \n @table @gcctabopt\n \n-@item -march=@var{cpu-type}\n+@item -march=@var{arch}\n @opindex march\n-Assume the defaults for the machine type @var{cpu-type} when generating\n-instructions.  The choices for @var{cpu-type} are  @samp{r2000}, @samp{r3000},\n-@samp{r3900}, @samp{r4000}, @samp{r4100}, @samp{r4300}, @samp{r4400},\n-@samp{r4600}, @samp{r4650}, @samp{r5000}, @samp{r6000}, @samp{r8000},\n-and @samp{orion}.  Additionally, the @samp{r2000}, @samp{r3000},\n-@samp{r4000}, @samp{r5000}, and @samp{r6000} can be abbreviated as\n-@samp{r2k} (or @samp{r2K}), @samp{r3k}, etc.\n-\n-@item -mtune=@var{cpu-type}\n+Generate code that will run on @var{arch}, which can be the name of a\n+generic MIPS ISA, or the name of a particular processor.  The ISA names\n+are: @samp{mips1}, @samp{mips2}, @samp{mips3}, @samp{mips4}, @samp{mips32}\n+and @samp{mips64}.  The processor names are: @samp{r2000},\n+@samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{vr4100}, @samp{vr4300},\n+@samp{r4400}, @samp{r4600}, @samp{r4650}, @samp{vr5000}, @samp{r6000},\n+@samp{r8000}, @samp{4kc}, @samp{4kp}, @samp{5kc}, @samp{20kc}\n+and @samp{orion}.  The special value @samp{from-abi} selects the\n+most compatible architecture for the selected ABI (that is,\n+@samp{mips1} for 32-bit ABIs and @samp{mips3} for 64-bit ABIs)@.\n+\n+In processor names, a final @samp{000} can be abbreviated as @samp{k}\n+(for example, @samp{-march=r2k}).  Prefixes are optional, and\n+@samp{vr} may be written @samp{r}.\n+\n+GCC defines two macros based on the value of this option.  The first\n+is @samp{_MIPS_ARCH}, which gives the name of target architecture, as\n+a string.  The second has the form @samp{_MIPS_ARCH_@var{foo}},\n+where @var{foo} is the capitialized value of @samp{_MIPS_ARCH}@.\n+For example, @samp{-march=r2000} will set @samp{_MIPS_ARCH}\n+to @samp{\"r2000\"} and define the macro @samp{_MIPS_ARCH_R2000}.\n+\n+Note that the @samp{_MIPS_ARCH} macro uses the processor names given\n+above.  In other words, it will have the full prefix and will not\n+abbreviate @samp{000} as @samp{k}.  In the case of @samp{from-abi},\n+the macro names the resolved architecture (either @samp{\"mips1\"} or\n+@samp{\"mips3\"}).  It names the default architecture when no\n+@option{-march} option is given.\n+\n+@item -mtune=@var{arch}\n @opindex mtune\n-Assume the defaults for the machine type @var{cpu-type} when scheduling\n-instructions.  The choices for @var{cpu-type} are @samp{r2000}, @samp{r3000},\n-@samp{r3900}, @samp{r4000}, @samp{r4100}, @samp{r4300}, @samp{r4400},\n-@samp{r4600}, @samp{r4650}, @samp{r5000}, @samp{r6000}, @samp{r8000},\n-and @samp{orion}.  Additionally, the @samp{r2000}, @samp{r3000},\n-@samp{r4000}, @samp{r5000}, and @samp{r6000} can be abbreviated as\n-@samp{r2k} (or @samp{r2K}), @samp{r3k}, etc.  While picking a specific\n-@var{cpu-type} will schedule things appropriately for that particular\n-chip, the compiler will not generate any code that does not meet level 1\n-of the MIPS ISA (instruction set architecture) without a @option{-mipsX}\n-or @option{-mabi} switch being used.\n+Optimize for @var{arch}.  Among other things, this option controls\n+the way instructions are scheduled, and the perceived cost of arithmetic\n+operations.  The list of @var{arch} values is the same as for\n+@option{-march}.\n \n-@item -mcpu=@var{cpu-type}\n-@opindex mcpu\n-This is identical to specifying both @option{-march} and @option{-mtune}.\n+When this option is not used, GCC will optimize for the processor\n+specified by @option{-march}.  By using @option{-march} and\n+@option{-mtune} together, it is possible to generate code that will\n+run on a family of processors, but optimize the code for one\n+particular member of that family.\n+\n+@samp{-mtune} defines the macros @samp{_MIPS_TUNE} and\n+@samp{_MIPS_TUNE_@var{foo}}, which work in the same way as the\n+@samp{-march} ones described above.\n \n @item -mips1\n @opindex mips1\n-Issue instructions from level 1 of the MIPS ISA@.  This is the default.\n-@samp{r3000} is the default @var{cpu-type} at this ISA level.\n+Equivalent to @samp{-march=mips1}.\n \n @item -mips2\n @opindex mips2\n-Issue instructions from level 2 of the MIPS ISA (branch likely, square\n-root instructions).  @samp{r6000} is the default @var{cpu-type} at this\n-ISA level.\n+Equivalent to @samp{-march=mips2}.\n \n @item -mips3\n @opindex mips3\n-Issue instructions from level 3 of the MIPS ISA (64-bit instructions).\n-@samp{r4000} is the default @var{cpu-type} at this ISA level.\n+Equivalent to @samp{-march=mips3}.\n \n @item -mips4\n @opindex mips4\n-Issue instructions from level 4 of the MIPS ISA (conditional move,\n-prefetch, enhanced FPU instructions).  @samp{r8000} is the default\n-@var{cpu-type} at this ISA level.\n+Equivalent to @samp{-march=mips4}.\n \n-@item -mfp32\n-@opindex mfp32\n-Assume that 32 32-bit floating point registers are available.  This is\n-the default.\n+@item -mips32\n+@opindex mips32\n+Equivalent to @samp{-march=mips32}.\n \n-@item -mfp64\n-@opindex mfp64\n-Assume that 32 64-bit floating point registers are available.  This is\n-the default when the @option{-mips3} option is used.\n+@item -mips64\n+@opindex mips64\n+Equivalent to @samp{-march=mips64}.\n \n @item -mfused-madd\n @itemx -mno-fused-madd\n@@ -7048,15 +7060,21 @@ in the mode where denormals are rounded to zero where denormals\n generated by multiply and accumulate instructions cause exceptions\n anyway.\n \n+@item -mfp32\n+@opindex mfp32\n+Assume that floating point registers are 32 bits wide.\n+\n+@item -mfp64\n+@opindex mfp64\n+Assume that floating point registers are 64 bits wide.\n+\n @item -mgp32\n @opindex mgp32\n-Assume that 32 32-bit general purpose registers are available.  This is\n-the default.\n+Assume that general purpose registers are 32 bits wide.\n \n @item -mgp64\n @opindex mgp64\n-Assume that 32 64-bit general purpose registers are available.  This is\n-the default when the @option{-mips3} option is used.\n+Assume that general purpose registers are 64 bits wide.\n \n @item -mint64\n @opindex mint64\n@@ -7072,31 +7090,32 @@ explanation of the default, and the width of pointers.\n @opindex mlong32\n Force long, int, and pointer types to be 32 bits wide.\n \n-If none of @option{-mlong32}, @option{-mlong64}, or @option{-mint64} are set,\n-the size of ints, longs, and pointers depends on the ABI and ISA chosen.\n-For @option{-mabi=32}, and @option{-mabi=n32}, ints and longs are 32 bits\n-wide.  For @option{-mabi=64}, ints are 32 bits, and longs are 64 bits wide.\n-For @option{-mabi=eabi} and either @option{-mips1} or @option{-mips2}, ints\n-and longs are 32 bits wide.  For @option{-mabi=eabi} and higher ISAs, ints\n-are 32 bits, and longs are 64 bits wide.  The width of pointer types is\n-the smaller of the width of longs or the width of general purpose\n-registers (which in turn depends on the ISA)@.\n+The default size of ints, longs and pointers depends on the ABI@.  All\n+the supported ABIs use 32-bit ints.  The n64 ABI uses 64-bit longs, as\n+does the 64-bit Cygnus EABI; the others use 32-bit longs.  Pointers\n+are the same size as longs, or the same size as integer registers,\n+whichever is smaller.\n \n @item -mabi=32\n @itemx -mabi=o64\n @itemx -mabi=n32\n @itemx -mabi=64\n @itemx -mabi=eabi\n+@itemx -mabi=meabi\n @opindex mabi=32\n @opindex mabi=o64\n @opindex mabi=n32\n @opindex mabi=64\n @opindex mabi=eabi\n-Generate code for the indicated ABI@.  The default instruction level is\n-@option{-mips1} for @samp{32}, @option{-mips3} for @samp{n32}, and\n-@option{-mips4} otherwise.  Conversely, with @option{-mips1} or\n-@option{-mips2}, the default ABI is @samp{32}; otherwise, the default ABI\n-is @samp{64}.\n+@opindex mabi=meabi\n+Generate code for the given ABI@.\n+\n+Note that there are two embedded ABIs: @option{-mabi=eabi}\n+selects the one defined by Cygnus while @option{-meabi=meabi}\n+selects the one defined by MIPS@.  Both these ABIs have\n+32-bit and 64-bit variants.  Normally, GCC will generate\n+64-bit code when you select a 64-bit architecture, but you\n+can use @option{-mgp32} to get 32-bit code instead.\n \n @item -mmips-as\n @opindex mmips-as"}, {"sha": "991d5e1349b7428b2caf0405082bdabdf429730b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -1,3 +1,7 @@\n+2002-07-25  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.dg/mips-args-[123].c: New tests.\n+\n 2002-07-24  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gcc.dg/ppc-spe.c: New."}, {"sha": "d5799fae0e642ac902c54b19d97e8fe22a892623", "filename": "gcc/testsuite/gcc.dg/mips-args-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-1.c?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -0,0 +1,35 @@\n+/* Check that certain preprocessor macros are defined, and do some\n+   consistency checks.  */\n+/* { dg-do compile { target mips*-*-* } } */\n+\n+const char *compiled_for = _MIPS_ARCH;\n+const char *optimized_for = _MIPS_TUNE;\n+\n+#if __mips_fpr != 32 && __mips_fpr != 64\n+#error Bad __mips_fpr\n+#endif\n+\n+/* Test complementary macro pairs: exactly one of each pair\n+   must be defined.  */\n+\n+#if defined (_R3000) == defined (_R4000)\n+#error _R3000 / _R4000 mismatch\n+#endif\n+\n+#if defined (__mips_hard_float) == defined (__mips_soft_float)\n+#error __mips_hard_float / __mips_soft_float mismatch\n+#endif\n+\n+#if defined (_MIPSEL) == defined (_MIPSEB)\n+#error _MIPSEL / _MIPSEB mismatch\n+#endif\n+\n+/* Check for __mips64 consistency.  */\n+\n+#if defined (__mips64) != defined (_R4000)\n+#error __mips64 / _R4000 mismatch\n+#endif\n+\n+#if defined (__mips64) && __mips != 3 && __mips != 4 && __mips != 64\n+#error __mips64 / __mips mismatch\n+#endif"}, {"sha": "f53bfb2cde5f3dc05be7a0298e463331738bf4ab", "filename": "gcc/testsuite/gcc.dg/mips-args-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-2.c?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -0,0 +1,15 @@\n+/* Check the _MIPSEB and _MIPSEL macros are accurate.  */\n+/* { dg-do run { target mips*-*-* } } */\n+short foo = 1;\n+int main ()\n+{\n+  char *p = (char *) &foo;\n+\n+#ifdef _MIPSEB\n+  if (p[0] != 0 || p[1] != 1)\n+#else\n+  if (p[0] != 1 || p[1] != 0)\n+#endif\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "9ce3553fa94f46b640d69f5d85c9be9c1b85199d", "filename": "gcc/testsuite/gcc.dg/mips-args-3.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmips-args-3.c?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -0,0 +1,35 @@\n+/* __mips, and related defines, guarantee that certain assembly\n+   instructions can be used.  Check a few examples.  */\n+/* { dg-do run { target mips*-*-* } } */\n+typedef int int32 __attribute__ ((mode (SI)));\n+typedef int int64 __attribute__ ((mode (DI)));\n+int foo (float inf, int64 in64, int32 in32)\n+{\n+  int64 res64;\n+  int32 res32;\n+\n+#if __mips != 1 && defined (__mips_hard_float)\n+  __asm__ (\"trunc.w.s %0, %1\" : \"=f\" (res32) : \"f\" (inf));\n+  if (res32 != 11)\n+    abort ();\n+#endif\n+\n+#if defined (__mips64)\n+  __asm__ (\"daddu %0, %1, %1\" : \"=r\" (res64) : \"r\" (in64));\n+  if (res64 != 50)\n+    abort ();\n+#endif\n+\n+#if (__mips == 4 || __mips == 32 || __mips == 64) && !defined (__mips16)\n+  __asm__ (\"move %0,%.\\n\\tmovn %0,%1,%2\"\n+\t   : \"=&r\" (res32) : \"r\" (in32), \"r\" (in64 != 0));\n+  if (res32 != 60)\n+    abort ();\n+#endif\n+}\n+\n+int main ()\n+{\n+  foo (11.4f, 25, 60);\n+  exit (0);\n+}"}, {"sha": "0022fcb289cb67f9a5a50883ff939b98dd9bf481", "filename": "gcc/toplev.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -179,6 +179,11 @@ const char *dump_base_name;\n \n extern int target_flags;\n \n+/* A mask of target_flags that includes bit X if X was set or cleared\n+   on the command line.  */\n+\n+int target_flags_explicit;\n+\n /* Debug hooks - dependent upon command line options.  */\n \n const struct gcc_debug_hooks *debug_hooks = &do_nothing_debug_hooks;\n@@ -4411,6 +4416,13 @@ set_target_switch (name)\n \t  target_flags &= ~-target_switches[j].value;\n \telse\n \t  target_flags |= target_switches[j].value;\n+\tif (name[0] != 0)\n+\t  {\n+\t    if (target_switches[j].value < 0)\n+\t      target_flags_explicit |= -target_switches[j].value;\n+\t    else\n+\t      target_flags_explicit |= target_switches[j].value;\n+\t  }\n \tvalid_target_option = 1;\n       }\n "}, {"sha": "aa7345b477e6adb77acebba535183348c2e8675d", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27fb29b8039f0077b92dfb8a7687becc90d67a2/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=a27fb29b8039f0077b92dfb8a7687becc90d67a2", "patch": "@@ -108,6 +108,7 @@ extern void check_global_declarations   PARAMS ((union tree_node **, int));\n \n extern const char *progname;\n extern const char *dump_base_name;\n+extern int target_flags_explicit;\n \n /* The hashtable, so that the C front ends can pass it to cpplib.  */\n extern struct ht *ident_hash;"}]}