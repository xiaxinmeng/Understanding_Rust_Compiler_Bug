{"sha": "6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQxOGFkYmMyYzAwYjI5MTljYmY2YjU5MjE5YTIyODdlNmZlZWNkNw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-07-29T17:27:57Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-07-29T17:27:57Z"}, "message": "cppexp.c (parse_defined): Always record the macro name.\n\n\t* cppexp.c (parse_defined): Always record the macro name.\n\t(lex): Don't worry about identifiers, or special-case\n\tCPP_NOT here.\n\t(_cpp_parse_expr): Figure out at the end of the routine\n\twhether we saw a valid !defined() expression.\n\t* cppfiles.c (stack_include_file): Update for mi_valid.\n\t(_cpp_pop_file_buffer): Similarly.\n\t* cpplex.c (_cpp_lex_token): Similarly.\n\t* cpphash.h (enum mi_state, enum mi_ind, mi_state,\n\tmi_if_not_defined, mi_lexed): Remove.\n\t(mi_valid): New.\n\t* cpplib.c (do_if): Simplify.\n\t(do_endif, push_conditional, _cpp_handle_directive): Update\n\tfor renaming of mi_state to mi_valid.\n\n\t* cpp.texi: Add index entries for digraphs, and add comment\n\tthat C++ refers to them as alternative tokens.\n\nFrom-SVN: r44459", "tree": {"sha": "ae3bf4ef61f7e71d609b714e200c82e7e441cba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae3bf4ef61f7e71d609b714e200c82e7e441cba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/comments", "author": null, "committer": null, "parents": [{"sha": "0068fd9637aa304ba7b27d720719bd589a7755ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0068fd9637aa304ba7b27d720719bd589a7755ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0068fd9637aa304ba7b27d720719bd589a7755ce"}], "stats": {"total": 125, "additions": 68, "deletions": 57}, "files": [{"sha": "cb73400b1ee822c4c6fbec05cfe7a579ca1d442b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -1,3 +1,23 @@\n+2001-07-29  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (parse_defined): Always record the macro name.\n+\t(lex): Don't worry about identifiers, or special-case\n+\tCPP_NOT here.\n+\t(_cpp_parse_expr): Figure out at the end of the routine\n+\twhether we saw a valid !defined() expression.\n+\t* cppfiles.c (stack_include_file): Update for mi_valid.\n+\t(_cpp_pop_file_buffer): Similarly.\n+\t* cpplex.c (_cpp_lex_token): Similarly.\n+\t* cpphash.h (enum mi_state, enum mi_ind, mi_state,\n+\tmi_if_not_defined, mi_lexed): Remove.\n+\t(mi_valid): New.\n+\t* cpplib.c (do_if): Simplify.\n+\t(do_endif, push_conditional, _cpp_handle_directive): Update\n+\tfor renaming of mi_state to mi_valid.\n+doc:\n+\t* cpp.texi: Add index entries for digraphs, and add comment\n+\tthat C++ refers to them as alternative tokens.\n+\n Sun Jul 29 18:59:13 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* basic-block.h (CLEANUP_PRE_LOOP): New."}, {"sha": "52ffb27881c174f2308ed94f7cb82ee169854767", "filename": "gcc/cppexp.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -267,16 +267,9 @@ parse_defined (pfile)\n       op.unsignedp = 0;\n       op.op = CPP_NUMBER;\n \n-      /* No macros?  At top of file?  */\n-      if (pfile->mi_state == MI_OUTSIDE && pfile->mi_cmacro == 0\n-\t  && pfile->mi_if_not_defined == MI_IND_NOT && pfile->mi_lexed == 1)\n-\t{\n-\t  cpp_start_lookahead (pfile);\n-\t  cpp_get_token (pfile, &token);\n-\t  if (token.type == CPP_EOF)\n-\t    pfile->mi_ind_cmacro = node;\n-\t  cpp_stop_lookahead (pfile, 0);\n-\t}\n+      /* A possible controlling macro of the form #if !defined ().\n+\t _cpp_parse_expr checks there was no other junk on the line.  */\n+      pfile->mi_ind_cmacro = node;\n     }\n \n   pfile->state.prevent_expansion--;\n@@ -351,10 +344,6 @@ lex (pfile, skip_evaluation, token)\n \t}\n       else\n \t{\n-\t  /* Controlling #if expressions cannot contain identifiers (they\n-\t     could become macros in the future).  */\n-\t  pfile->mi_state = MI_FAILED;\n-\n \t  op.op = CPP_NUMBER;\n \t  op.unsignedp = 0;\n \t  op.value = 0;\n@@ -377,11 +366,6 @@ lex (pfile, skip_evaluation, token)\n \treturn op;\n       }\n \n-    case CPP_NOT:\n-      /* We don't worry about its position here.  */\n-      pfile->mi_if_not_defined = MI_IND_NOT;\n-      /* Fall through.  */\n-\n     default:\n       if (((int) token->type > (int) CPP_EQ\n \t   && (int) token->type < (int) CPP_PLUS_EQ)\n@@ -598,10 +582,12 @@ _cpp_parse_expr (pfile)\n   register struct op *top = stack + 1;\n   int skip_evaluation = 0;\n   int result;\n+  unsigned int lex_count, saw_leading_not;\n \n   /* Set up detection of #if ! defined().  */\n-  pfile->mi_lexed = 0;\n-  pfile->mi_if_not_defined = MI_IND_NONE;\n+  pfile->mi_ind_cmacro = 0;\n+  saw_leading_not = 0;\n+  lex_count = 0;\n \n   /* We've finished when we try to reduce this.  */\n   top->op = CPP_EOF;\n@@ -618,7 +604,7 @@ _cpp_parse_expr (pfile)\n \n       /* Read a token */\n       op = lex (pfile, skip_evaluation, &token);\n-      pfile->mi_lexed++;\n+      lex_count++;\n \n       /* If the token is an operand, push its value and get next\n \t token.  If it is an operator, get its priority and flags, and\n@@ -638,6 +624,11 @@ _cpp_parse_expr (pfile)\n \t  continue;\n \n \tcase CPP_EOF:\tprio = FORCE_REDUCE_PRIO;\tbreak;\n+\n+\tcase CPP_NOT:\n+\t  saw_leading_not = lex_count == 1;\n+\t  prio = op_to_prio[op.op];\n+\t  break;\n \tcase CPP_PLUS:\n \tcase CPP_MINUS: prio = PLUS_PRIO;  if (top->flags & HAVE_VALUE) break;\n           /* else unary; fall through */\n@@ -869,7 +860,14 @@ _cpp_parse_expr (pfile)\n     }\n \n  done:\n+  /* The controlling macro expression is only valid if we called lex 3\n+     times: <!> <defined expression> and <EOF>.  push_conditional ()\n+     checks that we are at top-of-file.  */\n+  if (pfile->mi_ind_cmacro && !(saw_leading_not && lex_count == 3))\n+    pfile->mi_ind_cmacro = 0;\n+\n   result = (top[1].value != 0);\n+\n   if (top != stack)\n     CPP_ICE (\"unbalanced stack in #if\");\n   else if (!(top[1].flags & HAVE_VALUE))"}, {"sha": "cb6ca5eda73419931f43d2049502f41d21699eb3", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -332,7 +332,7 @@ stack_include_file (pfile, inc)\n   fp->sysp = sysp;\n \n   /* Initialise controlling macro state.  */\n-  pfile->mi_state = MI_OUTSIDE;\n+  pfile->mi_valid = true;\n   pfile->mi_cmacro = 0;\n   pfile->include_depth++;\n \n@@ -748,12 +748,12 @@ _cpp_pop_file_buffer (pfile, buf)\n     pfile->include_depth--;\n \n   /* Record the inclusion-preventing macro, which could be NULL\n-     meaning no controlling macro, if we haven't got it already.  */\n-  if (pfile->mi_state == MI_OUTSIDE && inc->cmacro == NULL)\n+     meaning no controlling macro.  */\n+  if (pfile->mi_valid && inc->cmacro == NULL)\n     inc->cmacro = pfile->mi_cmacro;\n \n   /* Invalidate control macros in the #including file.  */\n-  pfile->mi_state = MI_FAILED;\n+  pfile->mi_valid = false;\n \n   inc->refcnt--;\n   if (inc->refcnt == 0 && DO_NOT_REREAD (inc))"}, {"sha": "368fe46f2871610f12abb3cc42e17e4a3196aa08", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -93,10 +93,6 @@ struct search_path\n   struct file_name_map *name_map;\n };\n \n-/* Multiple-include optimisation.  */\n-enum mi_state {MI_FAILED = 0, MI_OUTSIDE};\n-enum mi_ind {MI_IND_NONE = 0, MI_IND_NOT};\n-\n /* #include types.  */\n enum include_type {IT_INCLUDE, IT_INCLUDE_NEXT, IT_IMPORT, IT_CMDLINE};\n \n@@ -268,11 +264,9 @@ struct cpp_reader\n   const struct directive *directive;\n \n   /* Multiple inlcude optimisation.  */\n-  enum mi_state mi_state;\n-  enum mi_ind mi_if_not_defined;\n-  unsigned int mi_lexed;\n   const cpp_hashnode *mi_cmacro;\n   const cpp_hashnode *mi_ind_cmacro;\n+  bool mi_valid;\n \n   /* Token lookahead.  */\n   struct cpp_lookahead *la_read;\t/* Read from this lookahead.  */"}, {"sha": "5248a422f458aa6329d0883db0a30d68e80b59de", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -1266,7 +1266,7 @@ _cpp_lex_token (pfile, result)\n \n   /* If not in a directive, this token invalidates controlling macros.  */\n   if (!pfile->state.in_directive)\n-    pfile->mi_state = MI_FAILED;\n+    pfile->mi_valid = false;\n }\n \n /* An upper bound on the number of bytes needed to spell a token,"}, {"sha": "8f9f54c8be6ecfb283f81c84660b3c8ccded7b2a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -358,7 +358,7 @@ _cpp_handle_directive (pfile, indented)\n \t      /* If we have a directive that is not an opening\n \t\t conditional, invalidate any control macro.  */\n \t      if (! (dir->flags & IF_COND))\n-\t\tpfile->mi_state = MI_FAILED;\n+\t\tpfile->mi_valid = false;\n \n \t      (*dir->handler) (pfile);\n \t    }\n@@ -1278,27 +1278,22 @@ do_ifndef (pfile)\n   push_conditional (pfile, skip, T_IFNDEF, node);\n }\n \n-/* #if cooperates with parse_defined to handle multiple-include\n-   optimisations.  If macro expansions or identifiers appear in the\n-   expression, we cannot treat it as a controlling conditional, since\n-   their values could change in the future.  */\n+/* _cpp_parse_expr puts a macro in a \"#if !defined ()\" expression in\n+   pfile->mi_ind_cmacro so we can handle multiple-include\n+   optimisations.  If macro expansion occurs in the expression, we\n+   cannot treat it as a controlling conditional, since the expansion\n+   could change in the future.  That is handled by cpp_get_token.  */\n \n static void\n do_if (pfile)\n      cpp_reader *pfile;\n {\n   int skip = 1;\n-  const cpp_hashnode *cmacro = 0;\n \n   if (! pfile->state.skipping)\n-    {\n-      /* Controlling macro of #if ! defined ()  */\n-      pfile->mi_ind_cmacro = 0;\n-      skip = _cpp_parse_expr (pfile) == 0;\n-      cmacro = pfile->mi_ind_cmacro;\n-    }\n+    skip = _cpp_parse_expr (pfile) == 0;\n \n-  push_conditional (pfile, skip, T_IF, cmacro);\n+  push_conditional (pfile, skip, T_IF, pfile->mi_ind_cmacro);\n }\n \n /* Flip skipping state if appropriate and continue without changing\n@@ -1395,7 +1390,7 @@ do_endif (pfile)\n       /* If potential control macro, we go back outside again.  */\n       if (ifs->next == 0 && ifs->mi_cmacro)\n \t{\n-\t  pfile->mi_state = MI_OUTSIDE;\n+\t  pfile->mi_valid = true;\n \t  pfile->mi_cmacro = ifs->mi_cmacro;\n \t}\n \n@@ -1406,8 +1401,8 @@ do_endif (pfile)\n }\n \n /* Push an if_stack entry and set pfile->state.skipping accordingly.\n-   If this is a #ifndef starting at the beginning of a file,\n-   CMACRO is the macro name tested by the #ifndef.  */\n+   If this is a #if or #ifndef, CMACRO is a potentially controlling\n+   macro - we need to check here that we are at the top of the file.  */\n \n static void\n push_conditional (pfile, skip, type, cmacro)\n@@ -1425,7 +1420,8 @@ push_conditional (pfile, skip, type, cmacro)\n   ifs->skip_elses = pfile->state.skipping || !skip;\n   ifs->was_skipping = pfile->state.skipping;\n   ifs->type = type;\n-  if (pfile->mi_state == MI_OUTSIDE && pfile->mi_cmacro == 0)\n+  /* This condition is effectively a test for top-of-file.  */\n+  if (pfile->mi_valid && pfile->mi_cmacro == 0)\n     ifs->mi_cmacro = cmacro;\n   else\n     ifs->mi_cmacro = 0;"}, {"sha": "a4569a3e0733e750d3836995d0a8f2d3b639346a", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -953,7 +953,7 @@ cpp_get_token (pfile, token)\n \t  cpp_hashnode *node = token->val.node;\n \n \t  /* Macros invalidate controlling macros.  */\n-\t  pfile->mi_state = MI_FAILED;\n+\t  pfile->mi_valid = false;\n \n \t  if (node->flags & NODE_BUILTIN)\n \t    {"}, {"sha": "319f73510d874d0c39abe15208a98321cd9247a3", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d18adbc2c00b2919cbf6b59219a2287e6feecd7/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=6d18adbc2c00b2919cbf6b59219a2287e6feecd7", "patch": "@@ -536,15 +536,18 @@ be removed in GCC 3.1.  You may use continued lines instead, or string\n constant concatenation.  @xref{Differences from previous versions}.\n \n @cindex punctuators\n+@cindex digraphs\n+@cindex alternative tokens\n @dfn{Punctuators} are all the usual bits of punctuation which are\n meaningful to C and C++.  All but three of the punctuation characters in\n ASCII are C punctuators.  The exceptions are @samp{@@}, @samp{$}, and\n @samp{`}.  In addition, all the two- and three-character operators are\n-punctuators.  There are also six @dfn{digraphs}, which are merely\n-alternate ways to spell other punctuators.  This is a second attempt to\n-work around missing punctuation in obsolete systems.  It has no negative\n-side effects, unlike trigraphs, but does not cover as much ground.  The\n-digraphs and their corresponding normal punctuators are:\n+punctuators.  There are also six @dfn{digraphs}, which the C++ standard\n+calls @dfn{alternative tokens}, which are merely alternate ways to spell\n+other punctuators.  This is a second attempt to work around missing\n+punctuation in obsolete systems.  It has no negative side effects,\n+unlike trigraphs, but does not cover as much ground.  The digraphs and\n+their corresponding normal punctuators are:\n \n @example\n Digraph:        <%  %>  <:  :>  %:  %:%:"}]}